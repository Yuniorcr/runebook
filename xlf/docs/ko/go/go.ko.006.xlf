<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="go">
    <body>
      <group id="go">
        <trans-unit id="e63a57b040488970eacecfd2272a9deb62e2be3e" translate="yes" xml:space="preserve">
          <source>It returns an error if the receiver is not an exported type or has no suitable methods. It also logs the error using package log. The client accesses each method using a string of the form &quot;Type.Method&quot;, where Type is the receiver's concrete type.</source>
          <target state="translated">수신자가 익스포트 된 유형이 아니거나 적합한 메소드가없는 경우 오류를 리턴합니다. 또한 패키지 로그를 사용하여 오류를 기록합니다. 클라이언트는 &quot;Type.Method&quot;형식의 문자열을 사용하여 각 메소드에 액세스합니다. 여기서 Type은 수신자의 구체적 유형입니다.</target>
        </trans-unit>
        <trans-unit id="4dde580c3be3f14ce5fe15d368688767eafb64f5" translate="yes" xml:space="preserve">
          <source>It returns the IP address and the network implied by the IP and prefix length. For example, ParseCIDR(&quot;192.0.2.1/24&quot;) returns the IP address 192.0.2.1 and the network 192.0.2.0/24.</source>
          <target state="translated">IP와 접두사 길이에 의해 암시 된 IP 주소와 네트워크를 반환합니다. 예를 들어 ParseCIDR ( &quot;192.0.2.1/24&quot;)은 IP 주소 192.0.2.1과 네트워크 192.0.2.0/24를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0b053a1afdc2a3fb959c27dc82bd3e04e4d3478f" translate="yes" xml:space="preserve">
          <source>It sets only the Path and Args in the returned structure.</source>
          <target state="translated">반환 된 구조에서 Path와 Args 만 설정합니다.</target>
        </trans-unit>
        <trans-unit id="810599e9d82ed867f48c9be47863d26eaa5d33f3" translate="yes" xml:space="preserve">
          <source>It sets z to the (possibly rounded) value of the corresponding floating- point value, and returns z, the actual base b, and an error err, if any. The entire string (not just a prefix) must be consumed for success. If z's precision is 0, it is changed to 64 before rounding takes effect. The number must be of the form:</source>
          <target state="translated">z를 해당 부동 소수점 값의 반올림 값으로 설정하고 z, 실제 기준 b 및 오류 err (있는 경우)를 리턴합니다. 성공하려면 전체 문자열 (접두사뿐만 아니라)을 사용해야합니다. z의 정밀도가 0이면 반올림이 적용되기 전에 64로 변경됩니다. 숫자는 다음과 같은 형식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="4b0e67dd55e6df4a3c7132865324312cab9fb6a8" translate="yes" xml:space="preserve">
          <source>It should not be used for recursive read locking; a blocked Lock call excludes new readers from acquiring the lock. See the documentation on the RWMutex type.</source>
          <target state="translated">재귀 적 읽기 잠금에는 사용하지 않아야합니다. 차단 된 잠금 호출은 새로운 독자가 잠금을 획득하지 못하게합니다. RWMutex 유형에 대한 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ff62c59d333b6b7669c7f0b6568819a5dff0f396" translate="yes" xml:space="preserve">
          <source>Iterate calls f for the files in the file set in the order they were added until f returns false.</source>
          <target state="translated">반복은 f가 false를 리턴 할 때까지 추가 된 순서대로 파일 세트의 파일에 대해 f를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="380c384a3bc4560682612879309496ebdde5cfd3" translate="yes" xml:space="preserve">
          <source>Itoa</source>
          <target state="translated">Itoa</target>
        </trans-unit>
        <trans-unit id="aac52064292950f4b3f0337ac6b1ebbc54bd40af" translate="yes" xml:space="preserve">
          <source>Itoa is equivalent to FormatInt(int64(i), 10).</source>
          <target state="translated">Itoa는 FormatInt (int64 (i), 10)와 같습니다.</target>
        </trans-unit>
        <trans-unit id="2d1e23b725be8aad6b338015ecefbc3479bf797c" translate="yes" xml:space="preserve">
          <source>J0 returns the order-zero Bessel function of the first kind.</source>
          <target state="translated">J0은 첫 번째 종류의 0 차 베셀 함수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9b402d642da0f20c362bc1bcf6bfd3cb9482a1ee" translate="yes" xml:space="preserve">
          <source>J1 returns the order-one Bessel function of the first kind.</source>
          <target state="translated">J1은 첫 번째 종류의 1 차 베셀 함수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0a183d189787e52c86d1ff01f1f68fc26c61737d" translate="yes" xml:space="preserve">
          <source>JPEG is defined in ITU-T T.81: &lt;a href=&quot;https://www.w3.org/Graphics/JPEG/itu-t81.pdf&quot;&gt;https://www.w3.org/Graphics/JPEG/itu-t81.pdf&lt;/a&gt;.</source>
          <target state="translated">JPEG는 ITU-T T.81 : &lt;a href=&quot;https://www.w3.org/Graphics/JPEG/itu-t81.pdf&quot;&gt;https://www.w3.org/Graphics/JPEG/itu-t81.pdf에&lt;/a&gt; 정의되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bd49e7822aebcb558798ee4f0f590d63e8da7cc1" translate="yes" xml:space="preserve">
          <source>JPEG, VP8, the MPEG family and other codecs use this color model. Such codecs often use the terms YUV and Y'CbCr interchangeably, but strictly speaking, the term YUV applies only to analog video signals, and Y' (luma) is Y (luminance) after applying gamma correction.</source>
          <target state="translated">JPEG, VP8, MPEG 제품군 및 기타 코덱은이 색상 모델을 사용합니다. 이러한 코덱은 종종 YUV와 Y'CbCr이라는 용어를 서로 바꾸어 사용할 수 있지만 YUV라는 용어는 아날로그 비디오 신호에만 적용되며 Y '(루마)는 감마 보정을 적용한 후 Y (휘도)입니다.</target>
        </trans-unit>
        <trans-unit id="922b9fe605d8db0c621e15bc38a3c570a5ce91fd" translate="yes" xml:space="preserve">
          <source>JS encapsulates a known safe EcmaScript5 Expression, for example, `(x + y * z())`. Template authors are responsible for ensuring that typed expressions do not break the intended precedence and that there is no statement/expression ambiguity as when passing an expression like &quot;{ foo: bar() }\n['foo']()&quot;, which is both a valid Expression and a valid Program with a very different meaning.</source>
          <target state="translated">JS는 알려진 안전한 EcmaScript5 Expression을 캡슐화합니다 (예 :`(x + y * z ())`). 템플리트 작성자는 유형이 지정된 표현식이 의도 된 우선 순위를 위반하지 않도록하고 &quot;{foo : bar ()} \ n [ 'foo'] ()&quot;와 같은 표현식을 전달할 때와 같이 명령문 / 표현 모호성이 없는지 확인해야합니다. 유효한 Expression과 매우 다른 의미의 유효한 Program입니다.</target>
        </trans-unit>
        <trans-unit id="26cbdc0eb97f168871a53f6c7842d5c136b64697" translate="yes" xml:space="preserve">
          <source>JSEscape writes to w the escaped JavaScript equivalent of the plain text data b.</source>
          <target state="translated">JSEscape는 일반 텍스트 데이터와 동등한 이스케이프 된 JavaScript를 작성합니다. b.</target>
        </trans-unit>
        <trans-unit id="bd3faa1039cdd3fc555ce394120927a3ffbfdfd6" translate="yes" xml:space="preserve">
          <source>JSEscapeString returns the escaped JavaScript equivalent of the plain text data s.</source>
          <target state="translated">JSEscapeString은 일반 텍스트 데이터에 해당하는 이스케이프 된 JavaScript를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="0657ce896f15a5407782a5a0cb9e814dbb9243d9" translate="yes" xml:space="preserve">
          <source>JSEscaper returns the escaped JavaScript equivalent of the textual representation of its arguments.</source>
          <target state="translated">JSEscaper는 인수의 텍스트 표현과 동등한 이스케이프 된 JavaScript를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="69a10a5b123daa69a949ffea8479901f451d66ee" translate="yes" xml:space="preserve">
          <source>JSON cannot represent cyclic data structures and Marshal does not handle them. Passing cyclic structures to Marshal will result in an error.</source>
          <target state="translated">JSON은 순환 데이터 구조를 나타낼 수 없으며 Marshal은이를 처리하지 않습니다. 순환 구조를 Marshal에 전달하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3bd554b8109b0533f9a7bb62634a7c4956ea4b3a" translate="yes" xml:space="preserve">
          <source>JSON cannot represent cyclic data structures and Marshal does not handle them. Passing cyclic structures to Marshal will result in an infinite recursion.</source>
          <target state="translated">JSON은 순환 데이터 구조를 나타낼 수 없으며 Marshal은이를 처리하지 않습니다. 순환 구조를 원수로 전달하면 무한 재귀가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="16c95a3afe47aa9594cf8938af617a9901298497" translate="yes" xml:space="preserve">
          <source>JSStr encapsulates a sequence of characters meant to be embedded between quotes in a JavaScript expression. The string must match a series of StringCharacters:</source>
          <target state="translated">JSStr은 JavaScript 표현식에서 따옴표로 묶어야하는 일련의 문자를 캡슐화합니다. 문자열은 일련의 StringCharacter와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="7ee415a9e606531fbf364133b0de844b1078510a" translate="yes" xml:space="preserve">
          <source>JSValue implements Wrapper interface.</source>
          <target state="translated">JSValue는 래퍼 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="b800dfb6df40a19873f9dc7ec5927a93b2cfe769" translate="yes" xml:space="preserve">
          <source>Jacobi returns the Jacobi symbol (x/y), either +1, -1, or 0. The y argument must be an odd integer.</source>
          <target state="translated">Jacobi는 +1, -1 또는 0의 Jacobi 기호 (x / y)를 반환합니다. y 인수는 홀수 정수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="173acb21066734464813cc933e35bf49fb5074d7" translate="yes" xml:space="preserve">
          <source>Jar implements the http.CookieJar interface from the net/http package.</source>
          <target state="translated">Jar는 net / http 패키지에서 http.CookieJar 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="0a5f33ea0d4d273fa523aad519e0bd5003a1f2a2" translate="yes" xml:space="preserve">
          <source>Jn returns the order-n Bessel function of the first kind.</source>
          <target state="translated">Jn은 첫 번째 종류의 B 형 함수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e0d73143de80d17e82de2e017ac156ca3b9c4e01" translate="yes" xml:space="preserve">
          <source>Join</source>
          <target state="translated">Join</target>
        </trans-unit>
        <trans-unit id="b160ff3535de402a5c7113020ea1b5b48c93aaa3" translate="yes" xml:space="preserve">
          <source>Join concatenates the elements of a to create a single string. The separator string sep is placed between elements in the resulting string.</source>
          <target state="translated">Join은 a의 요소를 연결하여 단일 문자열을 만듭니다. 구분자 문자열 sep는 결과 ​​문자열의 요소 사이에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="eb1bffc0eefb099fa476568b7bfaeb338665eac0" translate="yes" xml:space="preserve">
          <source>Join concatenates the elements of its first argument to create a single string. The separator string sep is placed between elements in the resulting string.</source>
          <target state="translated">Join은 첫 번째 인수의 요소를 연결하여 단일 문자열을 만듭니다. 구분 문자열 sep는 결과 ​​문자열의 요소 사이에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="6badcc1917f6227c17c3b5a3bb3a7ab0dac561dd" translate="yes" xml:space="preserve">
          <source>Join concatenates the elements of s to create a new byte slice. The separator sep is placed between elements in the resulting slice.</source>
          <target state="translated">Join은 s의 요소를 연결하여 새 바이트 슬라이스를 만듭니다. 분리기 (se)는 최종 슬라이스에서 요소들 사이에 배치된다.</target>
        </trans-unit>
        <trans-unit id="aa67e6029ba49c3f992d57c2d0ab202a04ec1080" translate="yes" xml:space="preserve">
          <source>Join joins any number of path elements into a single path, adding a Separator if necessary. Join calls Clean on the result; in particular, all empty strings are ignored. On Windows, the result is a UNC path if and only if the first path element is a UNC path.</source>
          <target state="translated">조인은 여러 경로 요소를 단일 경로로 결합하여 필요한 경우 구분 기호를 추가합니다. 통화 참여 결과에 대한 정리; 특히 빈 문자열은 모두 무시됩니다. Windows에서 첫 번째 경로 요소가 UNC 경로 인 경우에만 결과가 UNC 경로입니다.</target>
        </trans-unit>
        <trans-unit id="945c23e567973c47ce3562fa8cf5ef5f3d5533ea" translate="yes" xml:space="preserve">
          <source>Join joins any number of path elements into a single path, adding a separating slash if necessary. The result is Cleaned; in particular, all empty strings are ignored.</source>
          <target state="translated">조인은 여러 경로 요소를 단일 경로로 결합하여 필요한 경우 분리 슬래시를 추가합니다. 결과가 정리됩니다. 특히 빈 문자열은 모두 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="a3a49c8f80c8e5d91256710add83dcb9a3a81e62" translate="yes" xml:space="preserve">
          <source>Join joins any number of path elements into a single path, separating them with an OS specific Separator. Empty elements are ignored. The result is Cleaned. However, if the argument list is empty or all its elements are empty, Join returns an empty string. On Windows, the result will only be a UNC path if the first non-empty element is a UNC path.</source>
          <target state="translated">Join은 여러 경로 요소를 단일 경로로 결합하여 OS 별 구분자로 분리합니다. 빈 요소는 무시됩니다. 결과는 정리됩니다. 그러나 인수 목록이 비어 있거나 모든 요소가 비어있는 경우 Join은 빈 문자열을 반환합니다. Windows에서 비어 있지 않은 첫 번째 요소가 UNC 경로 인 경우 결과는 UNC 경로 만됩니다.</target>
        </trans-unit>
        <trans-unit id="6d2d5664268a2d39abd731e2e8cd12f3a113ecce" translate="yes" xml:space="preserve">
          <source>Join joins any number of path elements into a single path, separating them with slashes. Empty elements are ignored. The result is Cleaned. However, if the argument list is empty or all its elements are empty, Join returns an empty string.</source>
          <target state="translated">Join은 여러 경로 요소를 슬래시로 구분하여 단일 경로로 결합합니다. 빈 요소는 무시됩니다. 결과는 정리됩니다. 그러나 인수 목록이 비어 있거나 모든 요소가 비어있는 경우 Join은 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0f25f02ad0ad7ded23a0d09d8ea462e385b6164c" translate="yes" xml:space="preserve">
          <source>JoinHostPort combines host and port into a network address of the form &quot;host:port&quot;. If host contains a colon, as found in literal IPv6 addresses, then JoinHostPort returns &quot;[host]:port&quot;.</source>
          <target state="translated">JoinHostPort는 호스트와 포트를 &quot;host : port&quot;형식의 네트워크 주소로 결합합니다. 호스트에 리터럴 IPv6 주소에서와 같이 콜론이 포함 된 경우 JoinHostPort는 &quot;[host] : port&quot;를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="0cf4b24840f4e27435d8326ea5a70f3fed6a3f6e" translate="yes" xml:space="preserve">
          <source>KeepAlive marks its argument as currently reachable. This ensures that the object is not freed, and its finalizer is not run, before the point in the program where KeepAlive is called.</source>
          <target state="translated">KeepAlive는 인수가 현재 도달 가능한 것으로 표시합니다. 이렇게하면 KeepAlive가 호출되는 프로그램의 포인트 이전에 오브젝트가 해제되지 않고 종료자가 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4901b1829f2829b984a0de81f7472f13edad3727" translate="yes" xml:space="preserve">
          <source>Key returns the key of the iterator's current map entry.</source>
          <target state="translated">키는 반복자의 현재 맵 항목의 키를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="91d7c5c0cb63de8145a0cccf24bc8d2f799ffa8e" translate="yes" xml:space="preserve">
          <source>Key returns the key type of map m.</source>
          <target state="translated">키는지도 m의 키 유형을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="376426fe335e339ad2d0569150ad1299f858528e" translate="yes" xml:space="preserve">
          <source>KeyUsage represents the set of actions that are valid for a given key. It's a bitmap of the KeyUsage* constants.</source>
          <target state="translated">KeyUsage는 주어진 키에 유효한 일련의 동작을 나타냅니다. KeyUsage * 상수의 비트 맵입니다.</target>
        </trans-unit>
        <trans-unit id="096044ddbad86155a76b804e09110be8b259d0c6" translate="yes" xml:space="preserve">
          <source>KeyValue represents a single entry in a Map.</source>
          <target state="translated">KeyValue는 맵에서 단일 항목을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="054ac770f511da2fe690104026b09ee1f229a5cb" translate="yes" xml:space="preserve">
          <source>Kill causes the Process to exit immediately. Kill does not wait until the Process has actually exited. This only kills the Process itself, not any other processes it may have started.</source>
          <target state="translated">강제 종료하면 프로세스가 즉시 종료됩니다. 프로세스가 실제로 종료 될 때까지 강제 종료하지 않습니다. 이것은 프로세스가 시작되었을 때 프로세스가 아닌 프로세스 자체 만 종료시킵니다.</target>
        </trans-unit>
        <trans-unit id="e00ac23f2ac2ff73ad4f3c4b263d6c5bbfb80190" translate="yes" xml:space="preserve">
          <source>Kind</source>
          <target state="translated">Kind</target>
        </trans-unit>
        <trans-unit id="2f96efc28c6a98b35f43fa160b16237570ef8889" translate="yes" xml:space="preserve">
          <source>Kind returns the kind of basic type b.</source>
          <target state="translated">종류는 기본 유형 b의 종류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1333bd1a9ccf64ac482cd7154071753a44d2a74b" translate="yes" xml:space="preserve">
          <source>Kind returns the selection kind.</source>
          <target state="translated">종류는 선택 종류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c33cadf6bcbf16450240b63ecfd3a8a6cf556ed6" translate="yes" xml:space="preserve">
          <source>Kind returns the tag representing the kind of value this is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c89bd23580c2ae3925d134637371987fedb05e1" translate="yes" xml:space="preserve">
          <source>Kind returns v's Kind. If v is the zero Value (IsValid returns false), Kind returns Invalid.</source>
          <target state="translated">Kind는 v의 Kind를 반환합니다. v가 0 값이면 (IsValid는 false를 반환) Kind는 Invalid를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="069ade3ad94bb7d5e1d27e83fcea3337da44893d" translate="yes" xml:space="preserve">
          <source>Kind specifies the kind of value represented by a Value.</source>
          <target state="translated">종류는 값으로 표시되는 값의 종류를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="4774d947be420886f05bc80b8d7b99a878f5521e" translate="yes" xml:space="preserve">
          <source>Known networks are &quot;tcp&quot;, &quot;tcp4&quot; (IPv4-only), &quot;tcp6&quot; (IPv6-only), &quot;udp&quot;, &quot;udp4&quot; (IPv4-only), &quot;udp6&quot; (IPv6-only), &quot;ip&quot;, &quot;ip4&quot; (IPv4-only), &quot;ip6&quot; (IPv6-only), &quot;unix&quot;, &quot;unixgram&quot; and &quot;unixpacket&quot;.</source>
          <target state="translated">알려진 네트워크는 &quot;tcp&quot;, &quot;tcp4&quot;(IPv4 만), &quot;tcp6&quot;(IPv6 만), &quot;udp&quot;, &quot;udp4&quot;(IPv4 만), &quot;udp6&quot;(IPv6 만), &quot;ip&quot;입니다. , &quot;ip4&quot;(IPv4 전용), &quot;ip6&quot;(IPv6 전용), &quot;unix&quot;, &quot;unixgram&quot;및 &quot;unixpacket&quot;.</target>
        </trans-unit>
        <trans-unit id="b8b88dd6dbbf9262e1174af16ab3d22e577d2db5" translate="yes" xml:space="preserve">
          <source>Known options:</source>
          <target state="translated">알려진 옵션 :</target>
        </trans-unit>
        <trans-unit id="14eee53dd9c3bca9efa386f9ef53c298322ea056" translate="yes" xml:space="preserve">
          <source>Label returns the value of the label with the given key on ctx, and a boolean indicating whether that label exists.</source>
          <target state="translated">Label은 ctx에 제공된 키가있는 레이블 값과 해당 레이블이 존재하는지 여부를 나타내는 부울을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="17f6783a9c705de835debb13cac8a07e2f5a8b94" translate="yes" xml:space="preserve">
          <source>LabelSet is a set of labels.</source>
          <target state="translated">LabelSet은 레이블 집합입니다.</target>
        </trans-unit>
        <trans-unit id="bd752eb91afd54f78c7060bac232ea7dd334932f" translate="yes" xml:space="preserve">
          <source>Labels takes an even number of strings representing key-value pairs and makes a LabelSet containing them. A label overwrites a prior label with the same key. Currently only CPU profile utilizes labels information. See &lt;a href=&quot;https://golang.org/issue/23458&quot;&gt;https://golang.org/issue/23458&lt;/a&gt; for details.</source>
          <target state="translated">레이블은 키-값 쌍을 나타내는 짝수 개의 문자열을 가져 와서이를 포함하는 LabelSet을 만듭니다. 레이블은 동일한 키로 이전 레이블을 덮어 씁니다. 현재 CPU 프로파일 만 레이블 정보를 사용합니다. 자세한 내용은 &lt;a href=&quot;https://golang.org/issue/23458&quot;&gt;https://golang.org/issue/23458&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7b4c0dd78376377f6719d381d9475b9c65e91949" translate="yes" xml:space="preserve">
          <source>Labels takes an even number of strings representing key-value pairs and makes a LabelSet containing them. A label overwrites a prior label with the same key. Currently only the CPU and goroutine profiles utilize any labels information. See &lt;a href=&quot;https://golang.org/issue/23458&quot;&gt;https://golang.org/issue/23458&lt;/a&gt; for details.</source>
          <target state="translated">Labels는 키-값 쌍을 나타내는 짝수의 문자열을 가져와이를 포함하는 LabelSet을 만듭니다. 레이블은 동일한 키로 이전 레이블을 덮어 씁니다. 현재는 CPU 및 고 루틴 프로파일 만 레이블 정보를 활용합니다. 자세한 내용은 &lt;a href=&quot;https://golang.org/issue/23458&quot;&gt;https://golang.org/issue/23458&lt;/a&gt; 을 참조 하세요 .</target>
        </trans-unit>
        <trans-unit id="c80c2e659a9bc68c02557be9a6c755aeed779cd0" translate="yes" xml:space="preserve">
          <source>LastIndex</source>
          <target state="translated">LastIndex</target>
        </trans-unit>
        <trans-unit id="c2daa604f07bcb24a260e4fea3217009758689c4" translate="yes" xml:space="preserve">
          <source>LastIndex returns the index of the last instance of sep in s, or -1 if sep is not present in s.</source>
          <target state="translated">LastIndex는 s에서 sep의 마지막 인스턴스 인덱스를 반환하거나 sep가 s에 없으면 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b07643ffeaf5942b3f11986d945cbd1ca4dc0db5" translate="yes" xml:space="preserve">
          <source>LastIndex returns the index of the last instance of substr in s, or -1 if substr is not present in s.</source>
          <target state="translated">LastIndex는 s에서 substr의 마지막 인스턴스 색인을 반환하거나, substr이 s에 없으면 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a55ae6e0d05b49527c27558955cfb6017a5cb79e" translate="yes" xml:space="preserve">
          <source>LastIndexAny</source>
          <target state="translated">LastIndexAny</target>
        </trans-unit>
        <trans-unit id="c468ec7af80d497e073da5281108fc969df48a62" translate="yes" xml:space="preserve">
          <source>LastIndexAny interprets s as a sequence of UTF-8-encoded Unicode code points. It returns the byte index of the last occurrence in s of any of the Unicode code points in chars. It returns -1 if chars is empty or if there is no code point in common.</source>
          <target state="translated">LastIndexAny는 s를 UTF-8로 인코딩 된 유니 코드 코드 포인트의 시퀀스로 해석합니다. 문자의 모든 유니 코드 코드 포인트에서 s로 마지막 발생의 바이트 인덱스를 리턴합니다. 문자가 비어 있거나 공통 코드 포인트가 없으면 -1을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="f35ff2cbc15f8519c2de1c522556210dbec6f0d9" translate="yes" xml:space="preserve">
          <source>LastIndexAny returns the index of the last instance of any Unicode code point from chars in s, or -1 if no Unicode code point from chars is present in s.</source>
          <target state="translated">LastIndexAny는 s의 문자에서 유니 코드 코드 포인트의 마지막 인스턴스의 인덱스를 반환하거나, s에 유니 코드 코드 포인트가 없으면 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e5af45bb29df606a6ad9f71c5f8ffe801cf806e3" translate="yes" xml:space="preserve">
          <source>LastIndexByte</source>
          <target state="translated">LastIndexByte</target>
        </trans-unit>
        <trans-unit id="715ec7346f22f455ae3b4f77928429d6e6ea2e7d" translate="yes" xml:space="preserve">
          <source>LastIndexByte returns the index of the last instance of c in s, or -1 if c is not present in s.</source>
          <target state="translated">LastIndexByte는 s에서 c의 마지막 인스턴스 인덱스를 반환하거나 s에 c가 없으면 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0052a6c35642a0a5651d0e514c35ebcc1b001ad3" translate="yes" xml:space="preserve">
          <source>LastIndexFunc</source>
          <target state="translated">LastIndexFunc</target>
        </trans-unit>
        <trans-unit id="e9e6d245d6f60be69d3deb822ef844937727defc" translate="yes" xml:space="preserve">
          <source>LastIndexFunc interprets s as a sequence of UTF-8-encoded code points. It returns the byte index in s of the last Unicode code point satisfying f(c), or -1 if none do.</source>
          <target state="translated">LastIndexFunc는 s를 UTF-8로 인코딩 된 코드 포인트의 시퀀스로 해석합니다. f (c)를 만족하는 마지막 유니 코드 코드 포인트의 s 단위로 바이트 인덱스를 반환하고, 그렇지 않으면 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="573828a944fe303002f7c0336cac457a4d45085f" translate="yes" xml:space="preserve">
          <source>LastIndexFunc returns the index into s of the last Unicode code point satisfying f(c), or -1 if none do.</source>
          <target state="translated">LastIndexFunc는 f (c)를 만족하는 마지막 유니 코드 코드 포인트의 s로 인덱스를 반환하거나 없으면 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cdb76fffe46f91856747d3f589e0a3ea42a00f8c" translate="yes" xml:space="preserve">
          <source>Lchown changes the numeric uid and gid of the named file. If the file is a symbolic link, it changes the uid and gid of the link itself. If there is an error, it will be of type *PathError.</source>
          <target state="translated">Lchown은 명명 된 파일의 숫자 uid와 gid를 변경합니다. 파일이 기호 링크 인 경우 링크 자체의 uid 및 gid가 변경됩니다. 오류가 있으면 * PathError 유형입니다.</target>
        </trans-unit>
        <trans-unit id="9f1275e6821f8a51315e2ca81450b41140587c42" translate="yes" xml:space="preserve">
          <source>Ldexp is the inverse of Frexp. It returns frac &amp;times; 2**exp.</source>
          <target state="translated">Ldexp는 Frexp의 역수입니다. frac &amp;times; 2 ** exp를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0bfbea9fa1b1bd75227de20412ea5faba23da169" translate="yes" xml:space="preserve">
          <source>LeadingZeros returns the number of leading zero bits in x; the result is UintSize for x == 0.</source>
          <target state="translated">LeadingZeros는 x의 선행 0 비트 수를 반환합니다. 결과는 x == 0에 대한 UintSize입니다.</target>
        </trans-unit>
        <trans-unit id="e3dbef4bbdf5cce299ff063f0c95032879c3da58" translate="yes" xml:space="preserve">
          <source>LeadingZeros16</source>
          <target state="translated">LeadingZeros16</target>
        </trans-unit>
        <trans-unit id="44f8376c5ec759270046aff7d8e5b19117ded5c1" translate="yes" xml:space="preserve">
          <source>LeadingZeros16 returns the number of leading zero bits in x; the result is 16 for x == 0.</source>
          <target state="translated">LeadingZeros16은 x의 선행 0 비트 수를 반환합니다. x == 0의 경우 결과는 16입니다.</target>
        </trans-unit>
        <trans-unit id="e9ed6b4c7187930afe2c50c883fcac4812515684" translate="yes" xml:space="preserve">
          <source>LeadingZeros32</source>
          <target state="translated">LeadingZeros32</target>
        </trans-unit>
        <trans-unit id="d0f408a69a9bfc0c9d5428df849a3e3f9c88b61c" translate="yes" xml:space="preserve">
          <source>LeadingZeros32 returns the number of leading zero bits in x; the result is 32 for x == 0.</source>
          <target state="translated">LeadingZeros32는 x의 선행 0 비트 수를 반환합니다. x == 0의 경우 결과는 32입니다.</target>
        </trans-unit>
        <trans-unit id="f987ddc8abdaac6d127e5eafa8b11404f85e5b1a" translate="yes" xml:space="preserve">
          <source>LeadingZeros64</source>
          <target state="translated">LeadingZeros64</target>
        </trans-unit>
        <trans-unit id="fda83273480c3e8d70a28c2f123cbf299bd51fd9" translate="yes" xml:space="preserve">
          <source>LeadingZeros64 returns the number of leading zero bits in x; the result is 64 for x == 0.</source>
          <target state="translated">LeadingZeros64는 x의 선행 0 비트 수를 반환합니다. x == 0의 경우 결과는 64입니다.</target>
        </trans-unit>
        <trans-unit id="fda98988d92b8709dacc15db674b3e6e61682f64" translate="yes" xml:space="preserve">
          <source>LeadingZeros8</source>
          <target state="translated">LeadingZeros8</target>
        </trans-unit>
        <trans-unit id="d8a16180e08b654e4c4467808de5826069ff567a" translate="yes" xml:space="preserve">
          <source>LeadingZeros8 returns the number of leading zero bits in x; the result is 8 for x == 0.</source>
          <target state="translated">LeadingZeros8은 x의 선행 0 비트 수를 반환합니다. x == 0의 경우 결과는 8입니다.</target>
        </trans-unit>
        <trans-unit id="721bda08d146a886975a86dd204cbec756066f9e" translate="yes" xml:space="preserve">
          <source>Least Surprise Property: &quot;A developer (or code reviewer) familiar with HTML, CSS, and JavaScript, who knows that contextual autoescaping happens should be able to look at a {{.}} and correctly infer what sanitization happens.&quot;</source>
          <target state="translated">최소한의 놀람 속성 : &quot;문맥 자동 이스케이프가 발생한다는 것을 알고있는 HTML, CSS 및 JavaScript에 익숙한 개발자 (또는 코드 검토 자)는 {{.}}을 (를)보고 위생 처리를 올바르게 유추 할 수 있어야합니다.&quot;</target>
        </trans-unit>
        <trans-unit id="8d92112ff544a635650fbaf730715150d27bea5c" translate="yes" xml:space="preserve">
          <source>Len computes the number of elements in ring r. It executes in time proportional to the number of elements.</source>
          <target state="translated">Len은 링 r의 요소 수를 계산합니다. 요소 수에 비례하여 시간에 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="1399044ec4cebde1e345bfb6e7bc0665028c448d" translate="yes" xml:space="preserve">
          <source>Len returns the length of array a. A negative result indicates an unknown length.</source>
          <target state="translated">Len은 배열 a의 길이를 반환합니다. 음수 결과는 알 수없는 길이를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="93ef3e242273d75e5bb1dbc766c5fd7830570833" translate="yes" xml:space="preserve">
          <source>Len returns the minimum number of bits required to represent x; the result is 0 for x == 0.</source>
          <target state="translated">Len은 x를 나타내는 데 필요한 최소 비트 수를 반환합니다. x == 0의 경우 결과는 0입니다.</target>
        </trans-unit>
        <trans-unit id="ca5afaea7adacd073486db0f70027386a60f94b6" translate="yes" xml:space="preserve">
          <source>Len returns the number of accumulated bytes; b.Len() == len(b.String()).</source>
          <target state="translated">Len은 누적 된 바이트 수를 반환합니다. b. Len () == len (b.String ()).</target>
        </trans-unit>
        <trans-unit id="ee2f279ceb0f8a58afdf88fefe8cee3f9c31fa50" translate="yes" xml:space="preserve">
          <source>Len returns the number of bytes of the unread portion of the buffer; b.Len() == len(b.Bytes()).</source>
          <target state="translated">Len은 버퍼의 읽지 않은 부분의 바이트 수를 리턴합니다. b. Len () == len (b.Bytes ()).</target>
        </trans-unit>
        <trans-unit id="67467f9c2f5df39d1ac34826fd0579c560dedb06" translate="yes" xml:space="preserve">
          <source>Len returns the number of bytes of the unread portion of the slice.</source>
          <target state="translated">Len은 슬라이스에서 읽지 않은 부분의 바이트 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9a34422a61609509fefc4a297f2f9c07ff69ccf9" translate="yes" xml:space="preserve">
          <source>Len returns the number of bytes of the unread portion of the string.</source>
          <target state="translated">Len은 읽지 않은 문자열 부분의 바이트 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="be3ac6245438d5424b518ab2335163e6f1965692" translate="yes" xml:space="preserve">
          <source>Len returns the number of elements of list l. The complexity is O(1).</source>
          <target state="translated">Len은리스트 l의 요소 수를 반환합니다. 복잡도는 O (1)입니다.</target>
        </trans-unit>
        <trans-unit id="a7b0b1334a129ccc7a0e235fc902ddfdb01aa234" translate="yes" xml:space="preserve">
          <source>Len returns the number of methods in s.</source>
          <target state="translated">Len은 s의 메소드 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9909b01102ccbea5c34e603dc1a8df16cade5eea" translate="yes" xml:space="preserve">
          <source>Len returns the number of scope elements.</source>
          <target state="translated">Len은 범위 요소 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8315c44360f57db88aab9b44a76e81307e540e3a" translate="yes" xml:space="preserve">
          <source>Len returns the number variables of tuple t.</source>
          <target state="translated">Len은 튜플 t의 숫자 변수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ca8349640e110d5798f69868438b094ed5d5cb6c" translate="yes" xml:space="preserve">
          <source>Len returns v's length. It panics if v's Kind is not Array, Chan, Map, Slice, or String.</source>
          <target state="translated">Len은 v의 길이를 반환합니다. v의 Kind가 Array, Chan, Map, Slice 또는 String이 아닌 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b58611e03df383dbaa4dc9ba6fd2e4a6b8e52327" translate="yes" xml:space="preserve">
          <source>Len16</source>
          <target state="translated">Len16</target>
        </trans-unit>
        <trans-unit id="f5e60795826c955dcfd526c1230894564783d120" translate="yes" xml:space="preserve">
          <source>Len16 returns the minimum number of bits required to represent x; the result is 0 for x == 0.</source>
          <target state="translated">Len16은 x를 나타내는 데 필요한 최소 비트 수를 반환합니다. x == 0의 경우 결과는 0입니다.</target>
        </trans-unit>
        <trans-unit id="76efc8ef8d6465f58231c9d295309a299f1d8534" translate="yes" xml:space="preserve">
          <source>Len32</source>
          <target state="translated">Len32</target>
        </trans-unit>
        <trans-unit id="2bdd325b510dd0548fcbb4a4b3c4d52a4f66d711" translate="yes" xml:space="preserve">
          <source>Len32 returns the minimum number of bits required to represent x; the result is 0 for x == 0.</source>
          <target state="translated">Len32는 x를 나타내는 데 필요한 최소 비트 수를 반환합니다. x == 0의 경우 결과는 0입니다.</target>
        </trans-unit>
        <trans-unit id="5bed2d704a16234c65f3795d3067f97369c94923" translate="yes" xml:space="preserve">
          <source>Len64</source>
          <target state="translated">Len64</target>
        </trans-unit>
        <trans-unit id="67dd373d63df43f7c3cfe611f388cdd1def82589" translate="yes" xml:space="preserve">
          <source>Len64 returns the minimum number of bits required to represent x; the result is 0 for x == 0.</source>
          <target state="translated">Len64는 x를 나타내는 데 필요한 최소 비트 수를 반환합니다. x == 0의 경우 결과는 0입니다.</target>
        </trans-unit>
        <trans-unit id="5877dcf480cd63f747b4cd7b2e4473a4fb01962a" translate="yes" xml:space="preserve">
          <source>Len8</source>
          <target state="translated">Len8</target>
        </trans-unit>
        <trans-unit id="ead2ce671d2982c7db8677f2bb62a7b4fdd9a8e8" translate="yes" xml:space="preserve">
          <source>Len8 returns the minimum number of bits required to represent x; the result is 0 for x == 0.</source>
          <target state="translated">Len8은 x를 나타내는 데 필요한 최소 비트 수를 반환합니다. x == 0의 경우 결과는 0입니다.</target>
        </trans-unit>
        <trans-unit id="2981abdd30fd95f0ea0e0799884f920048d0fba8" translate="yes" xml:space="preserve">
          <source>Length returns the JavaScript property &quot;length&quot; of v. It panics if v is not a JavaScript object.</source>
          <target state="translated">Length는 v의 JavaScript 속성 &quot;length&quot;를 반환합니다. v가 JavaScript 객체가 아닌 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f0f51015552f0c7df8f3dcfecc5c896adfb05b7f" translate="yes" xml:space="preserve">
          <source>Length returns the column type length for variable length column types such as text and binary field types. If the type length is unbounded the value will be math.MaxInt64 (any database limits will still apply). If the column type is not variable length, such as an int, or if not supported by the driver ok is false.</source>
          <target state="translated">길이는 텍스트 및 이진 필드 유형과 같은 가변 길이 열 유형에 대한 열 유형 길이를 반환합니다. 유형 길이가 제한되지 않으면 값은 math.MaxInt64입니다 (데이터베이스 제한은 여전히 ​​적용됨). 열 유형이 int와 같이 가변 길이가 아니거나 드라이버가 지원하지 않는 경우 ok는 false입니다.</target>
        </trans-unit>
        <trans-unit id="7beb25af4ef1b6178972b02133e74127d796618a" translate="yes" xml:space="preserve">
          <source>Less reports whether x[i] should be ordered before x[j], as required by the sort Interface. Note that floating-point comparison by itself is not a transitive relation: it does not report a consistent ordering for not-a-number (NaN) values. This implementation of Less places NaN values before any others, by using:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7467b2c9a7e459bce96e4603f4b9c0fecbbea6e6" translate="yes" xml:space="preserve">
          <source>Lgamma returns the natural logarithm and sign (-1 or +1) of Gamma(x).</source>
          <target state="translated">Lgamma는 감마 (x)의 자연 로그와 부호 (-1 또는 +1)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7db120ff0add5b38c6339cbb76ef30243d16848f" translate="yes" xml:space="preserve">
          <source>Licensed under the Creative Commons Attribution License 3.0.</source>
          <target state="translated">Creative Commons Attribution License 3.0에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="7d9d345bfff5b874e03396293193a78237bde2df" translate="yes" xml:space="preserve">
          <source>Like Scanf and Fscanf, Sscanf need not consume its entire input. There is no way to recover how much of the input string Sscanf used.</source>
          <target state="translated">Scanf 및 Fscanf와 마찬가지로 Sscanf는 전체 입력을 사용할 필요가 없습니다. 사용 된 입력 문자열 Sscanf의 양을 복구 할 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="7e1cb140c6b5c5e4e4aa15375a7a581d31852d58" translate="yes" xml:space="preserve">
          <source>Like in tests, benchmark logs are accumulated during execution and dumped to standard error when done. Unlike in tests, benchmark logs are always printed, so as not to hide output whose existence may be affecting benchmark results.</source>
          <target state="translated">테스트와 마찬가지로 벤치 마크 로그는 실행 중에 누적되고 완료되면 표준 오류로 덤프됩니다. 테스트와 달리 벤치 마크 로그는 항상 인쇄되므로 벤치 마크 결과에 영향을 줄 수있는 출력을 숨기지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eb83a6fa3fb8d575ea5425178090b707c4e5b7e9" translate="yes" xml:space="preserve">
          <source>Like in tests, benchmark logs are accumulated during execution and dumped to standard output when done. Unlike in tests, benchmark logs are always printed, so as not to hide output whose existence may be affecting benchmark results.</source>
          <target state="translated">테스트에서와 마찬가지로 벤치 마크 로그는 실행 중에 누적되고 완료되면 표준 출력으로 덤프됩니다. 테스트와 달리 벤치 마크 로그는 항상 인쇄되므로 벤치 마크 결과에 영향을 미칠 수있는 출력을 숨기지 않습니다.</target>
        </trans-unit>
        <trans-unit id="64d7a9c098ae2cc78ad63fdda4f717ce942dd2cc" translate="yes" xml:space="preserve">
          <source>Like the RoundTripper interface, the error types returned by RoundTrip are unspecified.</source>
          <target state="translated">RoundTripper 인터페이스와 마찬가지로 RoundTrip에서 반환 된 오류 유형은 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8c3e2cc8bde5ef9c910164a74c49f21b4ecb6bc1" translate="yes" xml:space="preserve">
          <source>LimitReader</source>
          <target state="translated">LimitReader</target>
        </trans-unit>
        <trans-unit id="82f17ce7a899200e83a237fbfff2e0aec18adc46" translate="yes" xml:space="preserve">
          <source>LimitReader returns a Reader that reads from r but stops with EOF after n bytes. The underlying implementation is a *LimitedReader.</source>
          <target state="translated">LimitReader는 r에서 읽지 만 n 바이트 후에 EOF로 중지되는 Reader를 반환합니다. 기본 구현은 * LimitedReader입니다.</target>
        </trans-unit>
        <trans-unit id="dfc4ccc73713d6d0c21377e9d4eb82cf06cf9ec2" translate="yes" xml:space="preserve">
          <source>Line returns the line number for the given file position p; p must be a Pos value in that file or NoPos.</source>
          <target state="translated">Line은 주어진 파일 위치 p에 대한 행 번호를 리턴합니다. p는 해당 파일의 Pos 값이거나 NoPos 여야합니다.</target>
        </trans-unit>
        <trans-unit id="c80f69f5d4f28c6e33fd6610f08a1143f38de111" translate="yes" xml:space="preserve">
          <source>LineCount returns the number of lines in file f.</source>
          <target state="translated">LineCount는 파일 f의 줄 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8021239ce81a740af9d1126d1dcb955373ee8d6d" translate="yes" xml:space="preserve">
          <source>LineReader returns a new reader for the line table of compilation unit cu, which must be an Entry with tag TagCompileUnit.</source>
          <target state="translated">LineReader는 컴파일 단위 cu의 행 테이블에 대한 새 리더를 리턴합니다.이 태그는 TagCompileUnit 태그가있는 항목이어야합니다.</target>
        </trans-unit>
        <trans-unit id="d6e6998fd35451f00c85f965d2d22dc96e7bd958" translate="yes" xml:space="preserve">
          <source>LineStart returns the Pos value of the start of the specified line. It ignores any alternative positions set using AddLineColumnInfo. LineStart panics if the 1-based line number is invalid.</source>
          <target state="translated">LineStart는 지정된 줄 시작의 Pos 값을 반환합니다. AddLineColumnInfo를 사용하여 설정 한 대체 위치는 무시합니다. 1 기반 줄 번호가 유효하지 않으면 LineStart 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4776e3cbe12ee14e372370ae9f2a2f5ec9999059" translate="yes" xml:space="preserve">
          <source>LineToPC looks up the first program counter on the given line in the named file. It returns UnknownPathError or UnknownLineError if there is an error looking up this line.</source>
          <target state="translated">LineToPC는 명명 된 파일에서 주어진 행의 첫 번째 프로그램 카운터를 찾습니다. 이 줄을 찾는 동안 오류가 발생하면 UnknownPathError 또는 UnknownLineError를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e41c87878f5ec2dd68efcc90f4932d27c2b8d1c2" translate="yes" xml:space="preserve">
          <source>LineToPC returns the program counter for the given line number, considering only program counters before maxpc.</source>
          <target state="translated">LineToPC는 maxpc 이전의 프로그램 카운터 만 고려하여 주어진 행 번호에 대한 프로그램 카운터를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="d3ece36672b155d5080f24d88b4ef4dc56af15c6" translate="yes" xml:space="preserve">
          <source>Link connects ring r with ring s such that r.Next() becomes s and returns the original value for r.Next(). r must not be empty.</source>
          <target state="translated">Link는 r.Next ()가 s가되도록 r과 ring s를 연결하고 r.Next ()의 원래 값을 리턴합니다. r은 비워 둘 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="61bc01a247b2210bb40d4dab78269bb633df6036" translate="yes" xml:space="preserve">
          <source>Link creates newname as a hard link to the oldname file. If there is an error, it will be of type *LinkError.</source>
          <target state="translated">링크는 새 이름을 이전 이름 ​​파일에 대한 하드 링크로 만듭니다. 오류가 있으면 * LinkError 유형입니다.</target>
        </trans-unit>
        <trans-unit id="8c53bb40a220e2f4f66bfd2012a9dda9a12bc64f" translate="yes" xml:space="preserve">
          <source>LinkError records an error during a link or symlink or rename system call and the paths that caused it.</source>
          <target state="translated">LinkError는 링크 또는 심볼릭 링크 또는 시스템 호출 이름 변경 및 오류를 발생시킨 경로에서 오류를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="2ca439921c0481dec50573fdcf5a08b538a5f2a3" translate="yes" xml:space="preserve">
          <source>List represents a doubly linked list. The zero value for List is an empty list ready to use.</source>
          <target state="translated">목록은 이중 연결 목록을 나타냅니다. List의 0 값은 사용 가능한 빈 목록입니다.</target>
        </trans-unit>
        <trans-unit id="ed96ea56ffbf3b559f9c41465dc17435379898fd" translate="yes" xml:space="preserve">
          <source>ListNode holds a sequence of nodes.</source>
          <target state="translated">ListNode는 일련의 노드를 보유합니다.</target>
        </trans-unit>
        <trans-unit id="ca24c0263416d5489002e073f3f7f972b1a2c801" translate="yes" xml:space="preserve">
          <source>Listen announces on the local network address.</source>
          <target state="translated">Listen은 로컬 네트워크 주소를 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="fbc501a375c74f3f294816964a99702dd99275fe" translate="yes" xml:space="preserve">
          <source>Listen creates a TLS listener accepting connections on the given network address using net.Listen. The configuration config must be non-nil and must include at least one certificate or else set GetCertificate.</source>
          <target state="translated">Listen은 net.Listen을 사용하여 지정된 네트워크 주소에서 연결을 수락하는 TLS 수신기를 만듭니다. 구성 구성은 0이 아니어야하며 하나 이상의 인증서를 포함하거나 GetCertificate를 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="6c1bd8cd11c9c376470f7f547014d7596b4d2372" translate="yes" xml:space="preserve">
          <source>ListenAndServe</source>
          <target state="translated">ListenAndServe</target>
        </trans-unit>
        <trans-unit id="ca4b599f82e29135dc1efc68105574de3edf6ae1" translate="yes" xml:space="preserve">
          <source>ListenAndServe always returns a non-nil error.</source>
          <target state="translated">ListenAndServe는 항상 0이 아닌 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5dd294a2ba295a8af34a90f46a25099808a8e7bb" translate="yes" xml:space="preserve">
          <source>ListenAndServe always returns a non-nil error. After Shutdown or Close, the returned error is ErrServerClosed.</source>
          <target state="translated">ListenAndServe는 항상 0이 아닌 오류를 반환합니다. 종료 또는 닫기 후 반환 된 오류는 ErrServerClosed입니다.</target>
        </trans-unit>
        <trans-unit id="0e017d6f66fb57e5159203491154acdfd7f3155e" translate="yes" xml:space="preserve">
          <source>ListenAndServe listens on the TCP network address addr and then calls Serve with handler to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives.</source>
          <target state="translated">ListenAndServe는 TCP 네트워크 주소 가산기를 수신 한 다음 처리기로 Serve를 호출하여 들어오는 연결의 요청을 처리합니다. 허용 된 연결은 TCP 연결 유지를 사용하도록 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="1eb6871fd885bb71d1764b988ed8e0b1207dbd10" translate="yes" xml:space="preserve">
          <source>ListenAndServe listens on the TCP network address srv.Addr and then calls Serve to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives.</source>
          <target state="translated">ListenAndServe는 TCP 네트워크 주소 srv.Addr에서 수신 한 다음 Serve를 호출하여 들어오는 연결에 대한 요청을 처리합니다. 허용 된 연결은 TCP 연결 유지를 사용하도록 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="f672409681724db7975a81f059dabf70eb0a6552" translate="yes" xml:space="preserve">
          <source>ListenAndServe starts an HTTP server with a given address and handler. The handler is usually nil, which means to use DefaultServeMux. Handle and HandleFunc add handlers to DefaultServeMux:</source>
          <target state="translated">ListenAndServe는 주어진 주소와 핸들러로 HTTP 서버를 시작합니다. 핸들러는 일반적으로 nil이므로 DefaultServeMux를 사용합니다. Handle 및 HandleFunc는 DefaultServeMux에 핸들러를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="b1444c4d4c91aea2ff2c287b0f4c6b6c33effbc6" translate="yes" xml:space="preserve">
          <source>ListenAndServeTLS</source>
          <target state="translated">ListenAndServeTLS</target>
        </trans-unit>
        <trans-unit id="4b13ffad776ec4c1e6e622baa48939390c7f43be" translate="yes" xml:space="preserve">
          <source>ListenAndServeTLS acts identically to ListenAndServe, except that it expects HTTPS connections. Additionally, files containing a certificate and matching private key for the server must be provided. If the certificate is signed by a certificate authority, the certFile should be the concatenation of the server's certificate, any intermediates, and the CA's certificate.</source>
          <target state="translated">ListenAndServeTLS는 HTTPS 연결이 필요하다는 점을 제외하고 ListenAndServe와 동일하게 작동합니다. 또한 서버에 대한 인증서 및 일치하는 개인 키를 포함하는 파일이 제공되어야합니다. 인증 기관이 인증서에 서명 한 경우 certFile은 서버 인증서, 중간체 및 CA 인증서를 연결해야합니다.</target>
        </trans-unit>
        <trans-unit id="e993bc61c7cd05bdd6aa504a7bf534f06ff70ebd" translate="yes" xml:space="preserve">
          <source>ListenAndServeTLS always returns a non-nil error. After Shutdown or Close, the returned error is ErrServerClosed.</source>
          <target state="translated">ListenAndServeTLS는 항상 0이 아닌 오류를 반환합니다. 종료 또는 닫기 후 반환 된 오류는 ErrServerClosed입니다.</target>
        </trans-unit>
        <trans-unit id="4de6956912052ccb175eeb5c4727583b8c87a58f" translate="yes" xml:space="preserve">
          <source>ListenAndServeTLS listens on the TCP network address srv.Addr and then calls ServeTLS to handle requests on incoming TLS connections. Accepted connections are configured to enable TCP keep-alives.</source>
          <target state="translated">ListenAndServeTLS는 TCP 네트워크 주소 srv.Addr에서 수신 한 다음 ServeTLS를 호출하여 들어오는 TLS 연결에 대한 요청을 처리합니다. 허용 된 연결은 TCP 연결 유지를 사용하도록 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="2ef32140a96f71533a922e8af1a4a1287b2aa08c" translate="yes" xml:space="preserve">
          <source>ListenConfig contains options for listening to an address.</source>
          <target state="translated">ListenConfig에는 주소를 듣기위한 옵션이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="56e637fe09ab78156ad9d4b14c696af0fcd5c313" translate="yes" xml:space="preserve">
          <source>ListenIP acts like ListenPacket for IP networks.</source>
          <target state="translated">ListenIP는 IP 네트워크 용 ListenPacket처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="f21580354d675fc10d1e9ee1c4db6486064ec455" translate="yes" xml:space="preserve">
          <source>ListenMulticastUDP acts like ListenPacket for UDP networks but takes a group address on a specific network interface.</source>
          <target state="translated">ListenMulticastUDP는 UDP 네트워크 용 ListenPacket처럼 작동하지만 특정 네트워크 인터페이스에서 그룹 주소를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="867f2d87132f64efe5f8f6f86d2c98549b471fdb" translate="yes" xml:space="preserve">
          <source>ListenMulticastUDP is just for convenience of simple, small applications. There are golang.org/x/net/ipv4 and golang.org/x/net/ipv6 packages for general purpose uses.</source>
          <target state="translated">ListenMulticastUDP는 단순하고 작은 응용 프로그램의 편의를위한 것입니다. 일반적인 용도의 golang.org/x/net/ipv4 및 golang.org/x/net/ipv6 패키지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd5f6e57a541e39939141511f957be405b380471" translate="yes" xml:space="preserve">
          <source>ListenMulticastUDP listens on all available IP addresses of the local system including the group, multicast IP address. If ifi is nil, ListenMulticastUDP uses the system-assigned multicast interface, although this is not recommended because the assignment depends on platforms and sometimes it might require routing configuration. If the Port field of gaddr is 0, a port number is automatically chosen.</source>
          <target state="translated">ListenMulticastUDP는 그룹 멀티 캐스트 IP 주소를 포함하여 로컬 시스템의 사용 가능한 모든 IP 주소를 수신합니다. ifi가 nil 인 경우 ListenMulticastUDP는 시스템 할당 멀티 캐스트 인터페이스를 사용하지만 할당은 플랫폼에 따라 다르며 때로는 라우팅 구성이 필요할 수 있으므로 권장하지 않습니다. gaddr의 포트 필드가 0이면 포트 번호가 자동으로 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="468da55aa49f2b551af4d2ec242f5d19018b56ca" translate="yes" xml:space="preserve">
          <source>ListenPacket announces on the local network address.</source>
          <target state="translated">ListenPacket은 로컬 네트워크 주소를 발표합니다.</target>
        </trans-unit>
        <trans-unit id="df604088a8b978cdce196e569a7b165e976e6869" translate="yes" xml:space="preserve">
          <source>ListenTCP acts like Listen for TCP networks.</source>
          <target state="translated">ListenTCP는 TCP 네트워크 수신과 같은 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="9851cfe87c5b9ef168f40038c7d75b3a82ee3529" translate="yes" xml:space="preserve">
          <source>ListenUDP acts like ListenPacket for UDP networks.</source>
          <target state="translated">ListenUDP는 UDP 네트워크 용 ListenPacket처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="5b7757b4611e8ba6d66b663a1f48d50bfcf3ecc4" translate="yes" xml:space="preserve">
          <source>ListenUnix acts like Listen for Unix networks.</source>
          <target state="translated">ListenUnix는 Unix 네트워크 청취와 같은 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="df0abb591dbf2fca4d32aeb087ddbb3eb5bf7905" translate="yes" xml:space="preserve">
          <source>ListenUnixgram acts like ListenPacket for Unix networks.</source>
          <target state="translated">ListenUnixgram은 Unix 네트워크 용 ListenPacket처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="37ea46b5942beaeb21bb4e06a14e4f7232d2a1b0" translate="yes" xml:space="preserve">
          <source>Listener</source>
          <target state="translated">Listener</target>
        </trans-unit>
        <trans-unit id="0391fe0f913571d2818f72cca0ff528d31c4414b" translate="yes" xml:space="preserve">
          <source>LiteralPrefix returns a literal string that must begin any match of the regular expression re. It returns the boolean true if the literal string comprises the entire regular expression.</source>
          <target state="translated">LiteralPrefix는 정규 표현식 re와 일치하는 문자를 시작해야하는 리터럴 문자열을 반환합니다. 리터럴 문자열이 전체 정규식을 포함하는 경우 부울 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="ecdd85ee0de784370070e365d9f936724803e148" translate="yes" xml:space="preserve">
          <source>LittleEndian is the little-endian implementation of ByteOrder.</source>
          <target state="translated">LittleEndian은 ByteOrder의 리틀 엔디안 구현입니다.</target>
        </trans-unit>
        <trans-unit id="d5ae70e267716ec3e2a976b68757e30ee0e214a8" translate="yes" xml:space="preserve">
          <source>Load returns the value set by the most recent Store. It returns nil if there has been no call to Store for this Value.</source>
          <target state="translated">Load는 가장 최근 Store에서 설정 한 값을 반환합니다. 이 값에 대한 Store 호출이 없으면 nil을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="74c5a2d6710e8b201a98f6c2837198f613eec0fa" translate="yes" xml:space="preserve">
          <source>Load returns the value stored in the map for a key, or nil if no value is present. The ok result indicates whether value was found in the map.</source>
          <target state="translated">Load는 키에 대한 맵에 저장된 값을 반환하거나 값이 없으면 nil을 반환합니다. ok 결과는 맵에서 값을 찾았는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="bfe3a7d08b4bcafd9312e5433ad874e88e9a309d" translate="yes" xml:space="preserve">
          <source>LoadAndDelete deletes the value for a key, returning the previous value if any. The loaded result reports whether the key was present.</source>
          <target state="translated">LoadAndDelete는 키 값을 삭제하고 이전 값이있는 경우 반환합니다. 로드 된 결과는 키가 있는지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="881052b1a20f63445e79814467ecdb5374883ab0" translate="yes" xml:space="preserve">
          <source>LoadInt32 atomically loads *addr.</source>
          <target state="translated">LoadInt32는 * addr을 원자 적으로로드합니다.</target>
        </trans-unit>
        <trans-unit id="2ac3794cf69cbb4165a4ee85d8ea313e85610e69" translate="yes" xml:space="preserve">
          <source>LoadInt64 atomically loads *addr.</source>
          <target state="translated">LoadInt64는 * addr을 원자 적으로로드합니다.</target>
        </trans-unit>
        <trans-unit id="3cd00c96c1dde37f4e165d9dd83f094e52c09c97" translate="yes" xml:space="preserve">
          <source>LoadLocation</source>
          <target state="translated">LoadLocation</target>
        </trans-unit>
        <trans-unit id="942c4e15f8861257bc29d285e307a9855ad8da88" translate="yes" xml:space="preserve">
          <source>LoadLocation returns the Location with the given name.</source>
          <target state="translated">LoadLocation은 주어진 이름으로 Location을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="452c7f6aa0b947a115cd7ebee668ccabc28767f6" translate="yes" xml:space="preserve">
          <source>LoadLocationFromTZData returns a Location with the given name initialized from the IANA Time Zone database-formatted data. The data should be in the format of a standard IANA time zone file (for example, the content of /etc/localtime on Unix systems).</source>
          <target state="translated">LoadLocationFromTZData는 IANA 표준 시간대 데이터베이스 형식 데이터에서 초기화 된 지정된 이름의 위치를 ​​반환합니다. 데이터는 표준 IANA 표준 시간대 파일 형식이어야합니다 (예 : Unix 시스템의 / etc / localtime 내용).</target>
        </trans-unit>
        <trans-unit id="730b9fd8d031760ad2f11544687c7f3a4c32ba10" translate="yes" xml:space="preserve">
          <source>LoadOrStore returns the existing value for the key if present. Otherwise, it stores and returns the given value. The loaded result is true if the value was loaded, false if stored.</source>
          <target state="translated">LoadOrStore는 존재하는 경우 키의 기존 값을 반환합니다. 그렇지 않으면 주어진 값을 저장하고 반환합니다. 로드 된 결과는 값이로드 된 경우 true이고 저장되면 false입니다.</target>
        </trans-unit>
        <trans-unit id="16e5531718ad0441ff996bffe1bdb2f9013072b8" translate="yes" xml:space="preserve">
          <source>LoadPointer atomically loads *addr.</source>
          <target state="translated">LoadPointer는 * addr을 원자 적으로로드합니다.</target>
        </trans-unit>
        <trans-unit id="3a58860dce2950635c9b0aec0356bd0e023fcd4b" translate="yes" xml:space="preserve">
          <source>LoadUint32 atomically loads *addr.</source>
          <target state="translated">LoadUint32는 * addr을 원자 적으로로드합니다.</target>
        </trans-unit>
        <trans-unit id="ed4689d0f224e4c5a01ae1b69433a91e9f118b20" translate="yes" xml:space="preserve">
          <source>LoadUint64 atomically loads *addr.</source>
          <target state="translated">LoadUint64는 * addr을 원자 적으로로드합니다.</target>
        </trans-unit>
        <trans-unit id="9cfbde985c4614b9808e9de0d65afb5568c9c53d" translate="yes" xml:space="preserve">
          <source>LoadUintptr atomically loads *addr.</source>
          <target state="translated">LoadUintptr은 * addr을 원자 적으로로드합니다.</target>
        </trans-unit>
        <trans-unit id="e85b79501e4b543de03554e2a29fd9cbd965ec40" translate="yes" xml:space="preserve">
          <source>LoadX509KeyPair</source>
          <target state="translated">LoadX509KeyPair</target>
        </trans-unit>
        <trans-unit id="45fae6424c26a4b8eb19ae242ef820e6061dab08" translate="yes" xml:space="preserve">
          <source>LoadX509KeyPair reads and parses a public/private key pair from a pair of files. The files must contain PEM encoded data. The certificate file may contain intermediate certificates following the leaf certificate to form a certificate chain. On successful return, Certificate.Leaf will be nil because the parsed form of the certificate is not retained.</source>
          <target state="translated">LoadX509KeyPair는 한 쌍의 파일에서 공개 / 개인 키 쌍을 읽고 구문 분석합니다. 파일에는 PEM 인코딩 데이터가 포함되어야합니다. 인증서 파일에는 리프 인증서 뒤에 인증서 체인을 형성하는 중간 인증서가 포함될 수 있습니다. 성공적으로 반환되면 구문 분석 된 인증서 형식이 유지되지 않으므로 Certificate.Leaf는 0이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="1da25ed4d4f6ff8e68f5335ba8ba070399bd7f5f" translate="yes" xml:space="preserve">
          <source>Local represents the system's local time zone.</source>
          <target state="translated">로컬은 시스템의 현지 시간대를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4f717f0478e589f031d904c7f74748dd18f86eeb" translate="yes" xml:space="preserve">
          <source>Local represents the system's local time zone. On Unix systems, Local consults the TZ environment variable to find the time zone to use. No TZ means use the system default /etc/localtime. TZ=&quot;&quot; means use UTC. TZ=&quot;foo&quot; means use file foo in the system timezone directory.</source>
          <target state="translated">로컬은 시스템의 로컬 시간대를 나타냅니다. Unix 시스템에서 Local은 사용할 표준 시간대를 찾기 위해 TZ 환경 변수를 참조합니다. TZ 없음은 시스템 기본 / etc / localtime을 사용함을 의미합니다. TZ = &quot;&quot;는 UTC 사용을 의미합니다. TZ = &quot;foo&quot;는 시스템 시간대 디렉토리의 foo 파일 사용을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="bd6d294473bbbfce0d1197b903b10c86fb6c3b7b" translate="yes" xml:space="preserve">
          <source>Local returns t with the location set to local time.</source>
          <target state="translated">현지 시간은 현지 시간으로 설정된 위치에서 t를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4a5ab837cb8b234abbab484d911af5705d613e13" translate="yes" xml:space="preserve">
          <source>LocalAddr returns the local network address.</source>
          <target state="translated">LocalAddr은 로컬 네트워크 주소를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c10eb870360e8baad53b9b506e944815aa5896df" translate="yes" xml:space="preserve">
          <source>LocalAddr returns the local network address. The Addr returned is shared by all invocations of LocalAddr, so do not modify it.</source>
          <target state="translated">LocalAddr은 로컬 네트워크 주소를 반환합니다. 리턴 된 Addr은 LocalAddr의 모든 호출에서 공유되므로 수정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="238b4cd4fe464f99416bb574ab9c5c6651970ad5" translate="yes" xml:space="preserve">
          <source>LocalhostCert is a PEM-encoded TLS cert with SAN IPs &quot;127.0.0.1&quot; and &quot;[::1]&quot;, expiring at Jan 29 16:00:00 2084 GMT. generated from src/crypto/tls: go run generate_cert.go --rsa-bits 1024 --host 127.0.0.1,::1,example.com --ca --start-date &quot;Jan 1 00:00:00 1970&quot; --duration=1000000h</source>
          <target state="translated">LocalhostCert는 SAN IP가 &quot;127.0.0.1&quot;및 &quot;[:: 1]&quot;인 PEM으로 인코딩 된 TLS 인증서로, 2084 년 1 월 29 일 16:00:00에 만료됩니다. src / crypto / tls에서 생성됨 : go run generate_cert.go --rsa-bits 1024 --host 127.0.0.1, :: 1, example.com --ca --start-date &quot;Jan 1 00:00:00 1970 &quot;--duration = 1000000h</target>
        </trans-unit>
        <trans-unit id="2852b827de5091ca5aa6958386fa1405befa6094" translate="yes" xml:space="preserve">
          <source>LocalhostKey is the private key for localhostCert.</source>
          <target state="translated">LocalhostKey는 localhostCert의 개인 키입니다.</target>
        </trans-unit>
        <trans-unit id="d219c68101f532de10add2cf42fb9dbeca73d3be" translate="yes" xml:space="preserve">
          <source>Location</source>
          <target state="translated">Location</target>
        </trans-unit>
        <trans-unit id="c9551a197b6ccbbe733e98e1afb44218648f365d" translate="yes" xml:space="preserve">
          <source>Location returns the URL of the response's &quot;Location&quot; header, if present. Relative redirects are resolved relative to the Response's Request. ErrNoLocation is returned if no Location header is present.</source>
          <target state="translated">Location은 응답의 &quot;Location&quot;헤더 (있는 경우)의 URL을 반환합니다. 상대 리디렉션은 응답 요청과 관련하여 해결됩니다. Location 헤더가 없으면 ErrNoLocation이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6b99376f9c15a7e92154da5850b5d13b41ab37cc" translate="yes" xml:space="preserve">
          <source>Location returns the time zone information associated with t.</source>
          <target state="translated">위치는 t와 관련된 시간대 정보를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f30d8c256e2218530f9f115302f529d73fbbff9d" translate="yes" xml:space="preserve">
          <source>Lock locks m. If the lock is already in use, the calling goroutine blocks until the mutex is available.</source>
          <target state="translated">잠금 장치 m. 잠금이 이미 사용중인 경우 호출 고 루틴은 뮤텍스를 사용할 수있을 때까지 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="c3a987424c4290a7edfb3d1d597eb0eadb3ba378" translate="yes" xml:space="preserve">
          <source>Lock locks rw for writing. If the lock is already locked for reading or writing, Lock blocks until the lock is available.</source>
          <target state="translated">쓰기를위한 잠금 잠금 rw. 읽기 또는 쓰기를 위해 잠금이 이미 잠겨 있으면 잠금을 사용할 수있을 때까지 잠금이 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="5e340916752857a7b67a505378d157d115c1dd5a" translate="yes" xml:space="preserve">
          <source>LockOSThread wires the calling goroutine to its current operating system thread. The calling goroutine will always execute in that thread, and no other goroutine will execute in it, until the calling goroutine has made as many calls to UnlockOSThread as to LockOSThread. If the calling goroutine exits without unlocking the thread, the thread will be terminated.</source>
          <target state="translated">LockOSThread는 호출 고 루틴을 현재 운영 체제 스레드에 연결합니다. 호출 goroutine은 항상 해당 스레드에서 실행되며 호출 goroutine이 LockOSThread만큼 UnlockOSThread를 호출 할 때까지 다른 goroutine은 실행되지 않습니다. 스레드를 잠금 해제하지 않고 호출 고 루틴이 종료되면 스레드가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="8bf95ea372568c7a254ba9fada5f6f1701ebc5b5" translate="yes" xml:space="preserve">
          <source>Log</source>
          <target state="translated">Log</target>
        </trans-unit>
        <trans-unit id="fef609891d98d73a3ae686771d1e86e56fc90748" translate="yes" xml:space="preserve">
          <source>Log emits a one-off event with the given category and message. Category can be empty and the API assumes there are only a handful of unique categories in the system.</source>
          <target state="translated">로그는 주어진 카테고리 및 메시지와 함께 일회성 이벤트를 생성합니다. 카테고리는 비어있을 수 있으며 API는 시스템에 소수의 고유 카테고리 만 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="2353b4e8ade1606ef5c45cccd26ad3ad6087c78a" translate="yes" xml:space="preserve">
          <source>Log emits a timestamped message to the execution trace along with additional information such as the category of the message and which goroutine called Log. The execution tracer provides UIs to filter and group goroutines using the log category and the message supplied in Log.</source>
          <target state="translated">로그는 메시지 범주 및 로그라는 goroutine과 같은 추가 정보와 함께 타임 스탬프 된 메시지를 실행 추적에 보냅니다. 실행 추적 프로그램은 로그 범주와 로그에 제공된 메시지를 사용하여 고 루틴을 필터링하고 그룹화하는 UI를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9821e0db1231d181423f2e3b3225f154baa6bcf6" translate="yes" xml:space="preserve">
          <source>Log formats its arguments using default formatting, analogous to Println, and records the text in the error log. For tests, the text will be printed only if the test fails or the -test.v flag is set. For benchmarks, the text is always printed to avoid having performance depend on the value of the -test.v flag.</source>
          <target state="translated">Log는 Println과 유사한 기본 형식을 사용하여 인수의 형식을 지정하고 텍스트를 오류 로그에 기록합니다. 테스트의 경우 테스트에 실패하거나 -test.v 플래그가 설정된 경우에만 텍스트가 인쇄됩니다. 벤치 마크의 경우, 텍스트는 항상 -test.v 플래그의 값에 따라 성능이 달라지지 않도록 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="ad88d5c498edf7ea21028a5246446ba6a3bf9e4a" translate="yes" xml:space="preserve">
          <source>Log returns the natural logarithm of x.</source>
          <target state="translated">Log는 x의 자연 로그를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="81d615cdf905d64451161a1aa0b68ae0ffb374e3" translate="yes" xml:space="preserve">
          <source>Log10</source>
          <target state="translated">Log10</target>
        </trans-unit>
        <trans-unit id="977a2b5c893e89719e9a7736a4e1f9cc525e8f11" translate="yes" xml:space="preserve">
          <source>Log10 returns the decimal logarithm of x.</source>
          <target state="translated">Log10은 x의 10 진수 로그를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8671c0c40d7db0093d8bf62e5f04cba5c99ec3ea" translate="yes" xml:space="preserve">
          <source>Log10 returns the decimal logarithm of x. The special cases are the same as for Log.</source>
          <target state="translated">Log10은 x의 10 진수 로그를 반환합니다. 특별한 경우는 Log와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="a5b2fd4cb1a8e2bb305b5672e391aef89a37298c" translate="yes" xml:space="preserve">
          <source>Log1p returns the natural logarithm of 1 plus its argument x. It is more accurate than Log(1 + x) when x is near zero.</source>
          <target state="translated">Log1p는 자연 대수 1에 인수 x를 더한 값을 반환합니다. x가 0에 가까울 때 Log (1 + x)보다 더 정확합니다.</target>
        </trans-unit>
        <trans-unit id="6687db9bf747c384bcc8d36417e42b952196b766" translate="yes" xml:space="preserve">
          <source>Log2</source>
          <target state="translated">Log2</target>
        </trans-unit>
        <trans-unit id="7a0389c8675757d7572efc0a10b125d5c66b151f" translate="yes" xml:space="preserve">
          <source>Log2 returns the binary logarithm of x. The special cases are the same as for Log.</source>
          <target state="translated">Log2는 x의 이진 로그를 반환합니다. 특별한 경우는 Log와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="5963a7c64c0149e44b174ff76b7f701d23bc3074" translate="yes" xml:space="preserve">
          <source>Logb returns the binary exponent of x.</source>
          <target state="translated">Logb는 x의 이진 지수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ea0c4052b7cdd5aadd9cd6f72174db65e462d77d" translate="yes" xml:space="preserve">
          <source>Logf formats its arguments according to the format, analogous to Printf, and records the text in the error log. A final newline is added if not provided. For tests, the text will be printed only if the test fails or the -test.v flag is set. For benchmarks, the text is always printed to avoid having performance depend on the value of the -test.v flag.</source>
          <target state="translated">Logf는 Printf와 유사한 형식에 따라 인수의 형식을 지정하고 텍스트를 오류 로그에 기록합니다. 제공되지 않으면 최종 줄 바꿈이 추가됩니다. 테스트의 경우 테스트에 실패하거나 -test.v 플래그가 설정된 경우에만 텍스트가 인쇄됩니다. 벤치 마크의 경우, 텍스트는 항상 -test.v 플래그의 값에 따라 성능이 달라지지 않도록 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="38de20acad3e04f48129d8399f6a41e7517acf40" translate="yes" xml:space="preserve">
          <source>Logf is like Log, but the value is formatted using the specified format spec.</source>
          <target state="translated">Logf는 Log와 비슷하지만 값은 지정된 형식 사양을 사용하여 형식이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="8432c24573f3f89fad60802fe8eddf1da6315768" translate="yes" xml:space="preserve">
          <source>Logger</source>
          <target state="translated">Logger</target>
        </trans-unit>
        <trans-unit id="71c466638d24f772f0edc78440c6db3a9b5a9e5d" translate="yes" xml:space="preserve">
          <source>Logger.Output</source>
          <target state="translated">Logger.Output</target>
        </trans-unit>
        <trans-unit id="00aa9c00206cc40c149f1a777f6bcbff0a6df954" translate="yes" xml:space="preserve">
          <source>Longest makes future searches prefer the leftmost-longest match. That is, when matching against text, the regexp returns a match that begins as early as possible in the input (leftmost), and among those it chooses a match that is as long as possible. This method modifies the Regexp and may not be called concurrently with any other methods.</source>
          <target state="translated">가장 길면 향후 검색에서 가장 왼쪽 일치하는 항목을 선호합니다. 즉, 텍스트와 일치하는 경우 정규 표현식은 입력 (가장 왼쪽)에서 가능한 한 빨리 시작되는 일치를 반환하며 그 중에서 가능한 한 긴 일치를 선택합니다. 이 메소드는 Regexp를 수정하며 다른 메소드와 동시에 호출 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2397e2af778033b693f99aeecb7590b807be4783" translate="yes" xml:space="preserve">
          <source>LookPath</source>
          <target state="translated">LookPath</target>
        </trans-unit>
        <trans-unit id="3feb8389b758c68212533dd8278b352dcce121bf" translate="yes" xml:space="preserve">
          <source>LookPath searches for an executable named file in the directories named by the PATH environment variable. If file contains a slash, it is tried directly and the PATH is not consulted. The result may be an absolute path or a path relative to the current directory.</source>
          <target state="translated">LookPath는 PATH 환경 변수로 명명 된 디렉토리에서 파일 명명 된 실행 파일을 검색합니다. 파일에 슬래시가 포함되어 있으면 직접 시도하고 PATH를 참조하지 않습니다. 결과는 절대 경로이거나 현재 디렉토리에 상대적인 경로 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31ab9ed47ac6872e6361cf76170e61fbc5a37449" translate="yes" xml:space="preserve">
          <source>Lookup looks up a user by username. If the user cannot be found, the returned error is of type UnknownUserError.</source>
          <target state="translated">조회는 사용자 이름으로 사용자를 찾습니다. 사용자를 찾을 수 없으면 리턴 된 오류는 UnknownUserError 유형입니다.</target>
        </trans-unit>
        <trans-unit id="2c6f1e000a822d2c47b6a21ebdd8f5f93b104795" translate="yes" xml:space="preserve">
          <source>Lookup maps an identifier to its keyword token or IDENT (if not a keyword).</source>
          <target state="translated">조회는 식별자를 키워드 토큰 또는 IDENT (키워드가 아닌 경우)에 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="e9251196227d6115352b68461b921cf61a906b43" translate="yes" xml:space="preserve">
          <source>Lookup returns an unsorted list of at most n indices where the byte string s occurs in the indexed data. If n &amp;lt; 0, all occurrences are returned. The result is nil if s is empty, s is not found, or n == 0. Lookup time is O(log(N)*len(s) + len(result)) where N is the size of the indexed data.</source>
          <target state="translated">조회는 인덱싱 된 데이터에서 바이트 문자열 s가 발생하는 최대 n 개의 인덱스로 정렬되지 않은 목록을 반환합니다. n &amp;lt;0이면 모든 발생이 반환됩니다. s가 비어 있거나 s가 없거나 n == 0이면 결과는 nil입니다. 조회 시간은 O (log (N) * len (s) + len (result))입니다. 여기서 N은 인덱싱 된 데이터의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="13380eb03660f02dbd5d025d2b74f6f24450d311" translate="yes" xml:space="preserve">
          <source>Lookup returns the Flag structure of the named command-line flag, returning nil if none exists.</source>
          <target state="translated">Lookup은 명명 된 명령 줄 플래그의 플래그 구조를 반환하고 존재하지 않는 경우 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7e5483b0c984c3a57ec759db6fb278e7b255ecf8" translate="yes" xml:space="preserve">
          <source>Lookup returns the Flag structure of the named flag, returning nil if none exists.</source>
          <target state="translated">Lookup은 명명 된 플래그의 Flag 구조를 반환하고 존재하지 않는 경우 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5b0f26aebf1133c7a9f5776675b02659900d5a6f" translate="yes" xml:space="preserve">
          <source>Lookup returns the method with matching package and name, or nil if not found.</source>
          <target state="translated">Lookup은 일치하는 패키지 및 이름을 가진 메소드를 리턴하거나 찾지 못하면 nil을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="903dddeee2a83198e7d326397e76f54d9c716c8e" translate="yes" xml:space="preserve">
          <source>Lookup returns the object in scope s with the given name if such an object exists; otherwise the result is nil.</source>
          <target state="translated">Lookup은 해당 오브젝트가 존재하는 경우 지정된 이름으로 범위의 오브젝트를 리턴합니다. 그렇지 않으면 결과는 nil입니다.</target>
        </trans-unit>
        <trans-unit id="103697c251b3570afaab5577775dc041e648c7f1" translate="yes" xml:space="preserve">
          <source>Lookup returns the object with the given name if it is found in scope s, otherwise it returns nil. Outer scopes are ignored.</source>
          <target state="translated">Lookup은 scope에서 발견 된 경우 주어진 이름의 객체를 반환하고, 그렇지 않으면 nil을 반환합니다. 외부 범위는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="85596012a102f4cba55be912c69d163f2b6f529c" translate="yes" xml:space="preserve">
          <source>Lookup returns the profile with the given name, or nil if no such profile exists.</source>
          <target state="translated">조회는 지정된 이름의 프로파일을 리턴하거나 해당 프로파일이 없으면 nil을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="38285e372c5ecf7fee79e8f5475a7ad611b07ce7" translate="yes" xml:space="preserve">
          <source>Lookup returns the template with the given name that is associated with t, or nil if there is no such template.</source>
          <target state="translated">조회는 t와 연관된 지정된 이름의 템플리트를 리턴하거나 해당 템플리트가없는 경우 nil을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="b619549e7b11c0494158ea2b89e4d841aca101b2" translate="yes" xml:space="preserve">
          <source>Lookup returns the template with the given name that is associated with t. It returns nil if there is no such template or the template has no definition.</source>
          <target state="translated">조회는 t와 연관된 지정된 이름의 템플리트를 리턴합니다. 이러한 템플릿이 없거나 템플릿에 정의가 없으면 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c7a19da9ed723c89b3a482cb521b80e66fbdef7d" translate="yes" xml:space="preserve">
          <source>Lookup returns the value associated with key in the tag string. If the key is present in the tag the value (which may be empty) is returned. Otherwise the returned value will be the empty string. The ok return value reports whether the value was explicitly set in the tag string. If the tag does not have the conventional format, the value returned by Lookup is unspecified.</source>
          <target state="translated">조회는 태그 문자열에서 키와 관련된 값을 반환합니다. 태그에 키가 있으면 값이 비어있을 수 있습니다. 그렇지 않으면 반환 된 값은 빈 문자열이됩니다. ok 반환 값은 값이 태그 문자열에 명시 적으로 설정되었는지 여부를보고합니다. 태그에 일반적인 형식이 없으면 Lookup에서 반환 된 값이 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b1ca47c6e14b4100767398ad08b18ceba8715515" translate="yes" xml:space="preserve">
          <source>Lookup searches for a symbol named symName in plugin p. A symbol is any exported variable or function. It reports an error if the symbol is not found. It is safe for concurrent use by multiple goroutines.</source>
          <target state="translated">검색은 플러그인 p에서 symName이라는 기호를 검색합니다. 심볼은 내 보낸 변수 또는 함수입니다. 기호가 없으면 오류를보고합니다. 여러 고 루틴이 동시에 사용하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="99f5d988af7e6ab773a1a6146dd567b1c079995f" translate="yes" xml:space="preserve">
          <source>LookupAddr performs a reverse lookup for the given address, returning a list of names mapping to that address.</source>
          <target state="translated">LookupAddr은 주어진 주소에 대해 역방향 조회를 수행하여 해당 주소에 매핑되는 이름 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c70e79ec87ca49562ea197d9f2381d9321d8fe1b" translate="yes" xml:space="preserve">
          <source>LookupCNAME returns the canonical name for the given host. Callers that do not care about the canonical name can call LookupHost or LookupIP directly; both take care of resolving the canonical name as part of the lookup.</source>
          <target state="translated">LookupCNAME은 지정된 호스트의 정식 이름을 반환합니다. 표준 이름을 신경 쓰지 않는 발신자는 LookupHost 또는 LookupIP를 직접 호출 할 수 있습니다. 둘 다 조회의 일부로 정식 이름을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="8f4cf5e540b2d7dc315df0e1c1d62f60bab0e907" translate="yes" xml:space="preserve">
          <source>LookupEnv</source>
          <target state="translated">LookupEnv</target>
        </trans-unit>
        <trans-unit id="1ae2ee5065be9305542647e69dc65b9fd29b64fe" translate="yes" xml:space="preserve">
          <source>LookupEnv retrieves the value of the environment variable named by the key. If the variable is present in the environment the value (which may be empty) is returned and the boolean is true. Otherwise the returned value will be empty and the boolean will be false.</source>
          <target state="translated">LookupEnv는 키로 명명 된 환경 변수의 값을 검색합니다. 변수가 환경에 존재하면 값 (비어있을 수 있음)이 리턴되고 부울 값은 true입니다. 그렇지 않으면 반환 된 값은 비어 있고 부울은 거짓입니다.</target>
        </trans-unit>
        <trans-unit id="450e346d69b1c045fb4f52550736ebb0d1d8a4f8" translate="yes" xml:space="preserve">
          <source>LookupFieldOrMethod looks up a field or method with given package and name in T and returns the corresponding *Var or *Func, an index sequence, and a bool indicating if there were any pointer indirections on the path to the field or method. If addressable is set, T is the type of an addressable variable (only matters for method lookups).</source>
          <target state="translated">LookupFieldOrMethod는 주어진 패키지와 이름이 T로 된 필드 또는 메소드를 조회하고 해당 * Var 또는 * Func, 인덱스 시퀀스 및 필드 또는 메소드의 경로에 포인터 간접 지시가 있는지를 나타내는 부울을 리턴합니다. 주소 지정 가능이 설정되면 T는 주소 지정 가능 변수의 유형입니다 (메소드 조회에만 중요 함).</target>
        </trans-unit>
        <trans-unit id="9411c991fe6ec6318c1ddadaf5239d4c8ddf419e" translate="yes" xml:space="preserve">
          <source>LookupFunc returns the text, data, or bss symbol with the given name, or nil if no such symbol is found.</source>
          <target state="translated">LookupFunc는 지정된 이름의 텍스트, 데이터 또는 bss 기호를 반환하거나 그러한 기호가 없으면 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b92e9ccf5cc37f1e202dab80af7fdd5adb2d4fdf" translate="yes" xml:space="preserve">
          <source>LookupGroup looks up a group by name. If the group cannot be found, the returned error is of type UnknownGroupError.</source>
          <target state="translated">LookupGroup은 이름별로 그룹을 찾습니다. 그룹을 찾을 수 없으면 리턴 된 오류는 UnknownGroupError 유형입니다.</target>
        </trans-unit>
        <trans-unit id="864ecbbe82138c5e60336462e2e26b9cc0321aa1" translate="yes" xml:space="preserve">
          <source>LookupGroupId looks up a group by groupid. If the group cannot be found, the returned error is of type UnknownGroupIdError.</source>
          <target state="translated">LookupGroupId는 groupid별로 그룹을 찾습니다. 그룹을 찾을 수 없으면 리턴 된 오류는 UnknownGroupIdError 유형입니다.</target>
        </trans-unit>
        <trans-unit id="b9002491d44dda33fcc5ee2b368b90bad48de6db" translate="yes" xml:space="preserve">
          <source>LookupHost looks up the given host using the local resolver. It returns a slice of that host's addresses.</source>
          <target state="translated">LookupHost는 로컬 리졸버를 사용하여 지정된 호스트를 찾습니다. 해당 호스트 주소의 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="755f9feba02c89c681a556fd82001ef270f65acd" translate="yes" xml:space="preserve">
          <source>LookupIP looks up host for the given network using the local resolver. It returns a slice of that host's IP addresses of the type specified by network. network must be one of &quot;ip&quot;, &quot;ip4&quot; or &quot;ip6&quot;.</source>
          <target state="translated">LookupIP는 로컬 해석기를 사용하여 주어진 네트워크에 대한 호스트를 찾습니다. 네트워크에서 지정한 유형의 해당 호스트 IP 주소 조각을 반환합니다. 네트워크는 &quot;ip&quot;, &quot;ip4&quot;또는 &quot;ip6&quot;중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="e9702748a7f19b9de210233c47deec534e3b2cf2" translate="yes" xml:space="preserve">
          <source>LookupIP looks up host using the local resolver. It returns a slice of that host's IPv4 and IPv6 addresses.</source>
          <target state="translated">LookupIP는 로컬 확인자를 사용하여 호스트를 찾습니다. 해당 호스트의 IPv4 및 IPv6 주소 조각을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f974c6e0590936cd53144b751f0c8c53e1e56f97" translate="yes" xml:space="preserve">
          <source>LookupIPAddr looks up host using the local resolver. It returns a slice of that host's IPv4 and IPv6 addresses.</source>
          <target state="translated">LookupIPAddr은 로컬 리졸버를 사용하여 호스트를 찾습니다. 해당 호스트의 IPv4 및 IPv6 주소의 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="39cfba6c5476e7337eb21e14ebf7cf0d6e5bedc2" translate="yes" xml:space="preserve">
          <source>LookupId looks up a user by userid. If the user cannot be found, the returned error is of type UnknownUserIdError.</source>
          <target state="translated">LookupId는 사용자 ID별로 사용자를 찾습니다. 사용자를 찾을 수 없으면 리턴 된 오류는 UnknownUserIdError 유형입니다.</target>
        </trans-unit>
        <trans-unit id="fa6df437374a8db7470645bbe9d4e27c81caaaeb" translate="yes" xml:space="preserve">
          <source>LookupMX returns the DNS MX records for the given domain name sorted by preference.</source>
          <target state="translated">LookupMX는 기본 도메인별로 지정된 도메인 이름에 대한 DNS MX 레코드를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="eb321dee8209258e986d88d75de6022a02c641f4" translate="yes" xml:space="preserve">
          <source>LookupNS returns the DNS NS records for the given domain name.</source>
          <target state="translated">LookupNS는 주어진 도메인 이름에 대한 DNS NS 레코드를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="74ae49fce9af1a0aa1c34cc08bb2eaff3e2f9136" translate="yes" xml:space="preserve">
          <source>LookupParent follows the parent chain of scopes starting with s until it finds a scope where Lookup(name) returns a non-nil object, and then returns that scope and object. If a valid position pos is provided, only objects that were declared at or before pos are considered. If no such scope and object exists, the result is (nil, nil).</source>
          <target state="translated">LookupParent는 Lookup (name)이 null이 아닌 개체를 반환하는 범위를 찾은 다음 해당 범위와 개체를 반환 할 때까지 s로 시작하는 범위의 부모 체인을 따릅니다. 유효한 위치 pos가 제공되면 pos 또는 pos 전에 선언 된 오브젝트 만 고려됩니다. 이러한 범위와 개체가 없으면 결과는 (nil, nil)입니다.</target>
        </trans-unit>
        <trans-unit id="0730b69dbfb75d19ecc78b2277aae489ac068a4f" translate="yes" xml:space="preserve">
          <source>LookupPort looks up the port for the given network and service.</source>
          <target state="translated">LookupPort는 주어진 네트워크 및 서비스에 대한 포트를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="f0a5a2c68645491f7f14b8ebf958dd03393284be" translate="yes" xml:space="preserve">
          <source>LookupSRV constructs the DNS name to look up following RFC 2782. That is, it looks up _service._proto.name. To accommodate services publishing SRV records under non-standard names, if both service and proto are empty strings, LookupSRV looks up name directly.</source>
          <target state="translated">LookupSRV는 RFC 2782 다음에 조회 할 DNS 이름을 구성합니다. 즉, _service._proto.name을 찾습니다. 비표준 이름으로 SRV 레코드를 게시하는 서비스를 수용하기 위해 service와 proto가 모두 빈 문자열 인 경우 LookupSRV는 이름을 직접 찾습니다.</target>
        </trans-unit>
        <trans-unit id="6b37c6078d739a1c536ea751e03fbdc7bcfb4fd9" translate="yes" xml:space="preserve">
          <source>LookupSRV tries to resolve an SRV query of the given service, protocol, and domain name. The proto is &quot;tcp&quot; or &quot;udp&quot;. The returned records are sorted by priority and randomized by weight within a priority.</source>
          <target state="translated">LookupSRV는 지정된 서비스, 프로토콜 및 도메인 이름의 SRV 쿼리를 확인하려고합니다. 프로토 타입은 &quot;tcp&quot;또는 &quot;udp&quot;입니다. 반환 된 레코드는 우선 순위별로 정렬되고 우선 순위 내에서 가중치별로 무작위로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="53adeca568bb0a57f84e1f9d5ebd3b79ee2295f0" translate="yes" xml:space="preserve">
          <source>LookupSym returns the text, data, or bss symbol with the given name, or nil if no such symbol is found.</source>
          <target state="translated">LookupSym은 주어진 이름의 텍스트, 데이터 또는 bss 기호를 반환하고, 그러한 기호가 없으면 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e3ed61b0b0e3039a19a182ecd64a64ecece699f9" translate="yes" xml:space="preserve">
          <source>LookupTXT returns the DNS TXT records for the given domain name.</source>
          <target state="translated">LookupTXT는 주어진 도메인 이름에 대한 DNS TXT 레코드를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="be0fd93650565eb4e261e38483006a0a6e96ae35" translate="yes" xml:space="preserve">
          <source>Lsh sets z = x &amp;lt;&amp;lt; n and returns z.</source>
          <target state="translated">Lsh는 z = x &amp;lt;&amp;lt; n을 설정하고 z를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8432c7185b33f226f3a96e2aaaeb0017fbd79a53" translate="yes" xml:space="preserve">
          <source>Lstat returns a FileInfo describing the named file. If the file is a symbolic link, the returned FileInfo describes the symbolic link. Lstat makes no attempt to follow the link. If there is an error, it will be of type *PathError.</source>
          <target state="translated">Lstat는 명명 된 파일을 설명하는 FileInfo를 반환합니다. 파일이 기호 링크 인 경우, 리턴 된 FileInfo는 기호 링크를 설명합니다. Lstat는 링크를 따르려고 시도하지 않습니다. 오류가 있으면 * PathError 유형입니다.</target>
        </trans-unit>
        <trans-unit id="653b7ad5571eb02f2761c383b0762a05ad1e21e9" translate="yes" xml:space="preserve">
          <source>M is a type passed to a TestMain function to run the actual tests.</source>
          <target state="translated">M은 실제 테스트를 실행하기 위해 TestMain 함수에 전달 된 유형입니다.</target>
        </trans-unit>
        <trans-unit id="6c4afe9957321d9f90932c8eebed2802a4ac1436" translate="yes" xml:space="preserve">
          <source>MD5 is cryptographically broken and should not be used for secure applications.</source>
          <target state="translated">MD5는 암호화 방식으로 손상되어 보안 응용 프로그램에 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="2c0f2626fcfbcf6f5cc06f45f9a06123950573c9" translate="yes" xml:space="preserve">
          <source>Machine is found in Header.Machine.</source>
          <target state="translated">기계는 Header.Machine에 있습니다.</target>
        </trans-unit>
        <trans-unit id="abd1aeb6203ae00a3b2e20d1890fa31ee8357446" translate="yes" xml:space="preserve">
          <source>Magic number for the elf trampoline, chosen wisely to be an immediate value.</source>
          <target state="translated">엘프 트램폴린의 마법 번호는 현명한 가치로 현명하게 선택되었습니다.</target>
        </trans-unit>
        <trans-unit id="34db1d3199d388dde94cedd16c554b4e44c4ed46" translate="yes" xml:space="preserve">
          <source>Mail issues a MAIL command to the server using the provided email address. If the server supports the 8BITMIME extension, Mail adds the BODY=8BITMIME parameter. If the server supports the SMTPUTF8 extension, Mail adds the SMTPUTF8 parameter. This initiates a mail transaction and is followed by one or more Rcpt calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d30cb76631db62a976ef3584c436e5f44c54006c" translate="yes" xml:space="preserve">
          <source>Mail issues a MAIL command to the server using the provided email address. If the server supports the 8BITMIME extension, Mail adds the BODY=8BITMIME parameter. This initiates a mail transaction and is followed by one or more Rcpt calls.</source>
          <target state="translated">Mail은 제공된 이메일 주소를 사용하여 서버에 MAIL 명령을 발행합니다. 서버가 8BITMIME 확장자를 지원하면 Mail은 BODY = 8BITMIME 매개 변수를 추가합니다. 이것은 메일 트랜잭션을 시작하고 하나 이상의 Rcpt 호출이 뒤 따릅니다.</target>
        </trans-unit>
        <trans-unit id="62bce9422ff2d14f69ab80a154510232fc8a9afd" translate="yes" xml:space="preserve">
          <source>Main</source>
          <target state="translated">Main</target>
        </trans-unit>
        <trans-unit id="0784ed59d6aa6164d650ee5788e4f48c9ab53ccb" translate="yes" xml:space="preserve">
          <source>Main is an internal function, part of the implementation of the &quot;go test&quot; command. It was exported because it is cross-package and predates &quot;internal&quot; packages. It is no longer used by &quot;go test&quot; but preserved, as much as possible, for other systems that simulate &quot;go test&quot; using Main, but Main sometimes cannot be updated as new functionality is added to the testing package. Systems simulating &quot;go test&quot; should be updated to use MainStart.</source>
          <target state="translated">Main은 &quot;go test&quot;명령 구현의 일부인 내부 기능입니다. 크로스 패키지이고 &quot;내부&quot;패키지보다 오래 되었기 때문에 내보냈습니다. Main을 사용하여 &quot;go test&quot;를 시뮬레이트하는 다른 시스템에서는 더 이상 &quot;go test&quot;에서 사용되지 않지만 가능한 한 많이 보존되지만 새로운 기능이 테스트 패키지에 추가되면 Main을 업데이트 할 수없는 경우가 있습니다. &quot;시작 테스트&quot;를 시뮬레이션하는 시스템은 MainStart를 사용하도록 업데이트해야합니다.</target>
        </trans-unit>
        <trans-unit id="b4948070b9137e3c4295247505827d161a1430c0" translate="yes" xml:space="preserve">
          <source>MainStart is meant for use by tests generated by 'go test'. It is not meant to be called directly and is not subject to the Go 1 compatibility document. It may change signature from release to release.</source>
          <target state="translated">MainStart는 'go test'에 의해 생성 된 테스트에 사용됩니다. 직접 호출하기위한 것이 아니며 Go 1 호환성 문서의 적용을받지 않습니다. 서명이 릴리스마다 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76f0e763aa0460d3ebdb6819d8a8618bd610502c" translate="yes" xml:space="preserve">
          <source>Make returns the Value for x.</source>
          <target state="translated">Make는 x의 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d212d37a7f555035543edd9847aa0f8944d00dd6" translate="yes" xml:space="preserve">
          <source>MakeBool returns the Bool value for b.</source>
          <target state="translated">MakeBool은 b에 대한 Bool 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1bde4b612786d9c5dc71f0124e7f5aff783bd040" translate="yes" xml:space="preserve">
          <source>MakeChan creates a new channel with the specified type and buffer size.</source>
          <target state="translated">MakeChan은 지정된 유형과 버퍼 크기로 새 채널을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="07c781b2f5d2aafadbf3e2e50e6f01577121585d" translate="yes" xml:space="preserve">
          <source>MakeFloat64 returns the Float value for x. If x is -0.0, the result is 0.0. If x is not finite, the result is an Unknown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8499a9ac9172e4fd5f8c155f860005e583c8290f" translate="yes" xml:space="preserve">
          <source>MakeFloat64 returns the Float value for x. If x is not finite, the result is an Unknown.</source>
          <target state="translated">MakeFloat64는 x에 대한 Float 값을 반환합니다. x가 유한하지 않으면 결과는 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="080b5a4b73c758656574c66abecfca2800793e12" translate="yes" xml:space="preserve">
          <source>MakeFromBytes returns the Int value given the bytes of its little-endian binary representation. An empty byte slice argument represents 0.</source>
          <target state="translated">MakeFromBytes는 리틀 엔디안 이진 표현의 바이트가 주어진 Int 값을 반환합니다. 빈 바이트 슬라이스 인수는 0을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="04110b4029f3d51d7f1b1e32dfd59973aae981d8" translate="yes" xml:space="preserve">
          <source>MakeFromLiteral returns the corresponding integer, floating-point, imaginary, character, or string value for a Go literal string. The tok value must be one of token.INT, token.FLOAT, token.IMAG, token.CHAR, or token.STRING. The final argument must be zero. If the literal string syntax is invalid, the result is an Unknown.</source>
          <target state="translated">MakeFromLiteral은 Go 리터럴 문자열에 해당하는 정수, 부동 소수점, 허수, 문자 또는 문자열 값을 반환합니다. 토큰 값은 token.INT, token.FLOAT, token.IMAG, token.CHAR 또는 token.STRING 중 하나 여야합니다. 마지막 인수는 0이어야합니다. 리터럴 문자열 구문이 유효하지 않은 경우 결과는 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="07a7a52634a41aa9116fcfbf959be30745aab340" translate="yes" xml:space="preserve">
          <source>MakeFunc</source>
          <target state="translated">MakeFunc</target>
        </trans-unit>
        <trans-unit id="643c1268f2628745bb74a74c0b6210fc3a37b52e" translate="yes" xml:space="preserve">
          <source>MakeFunc returns a new function of the given Type that wraps the function fn. When called, that new function does the following:</source>
          <target state="translated">MakeFunc는 함수 fn을 래핑하는 지정된 Type의 새 함수를 반환합니다. 이 새로운 함수가 호출되면 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="e91507405a52b25c3084428772c7fd9dd85d29bc" translate="yes" xml:space="preserve">
          <source>MakeImag returns the Complex value x*i; x must be Int, Float, or Unknown. If x is Unknown, the result is Unknown.</source>
          <target state="translated">MakeImag는 복소수 값 x * i를 반환합니다. x는 Int, Float 또는 Unknown이어야합니다. x가 알 수없는 경우 결과는 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="da6ba30b4b9d9da1cda2bb8d92f1cb545785138a" translate="yes" xml:space="preserve">
          <source>MakeInt64 returns the Int value for x.</source>
          <target state="translated">MakeInt64는 x에 대한 Int 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f32c29a01762bfefeedc6eb9373c057117a43683" translate="yes" xml:space="preserve">
          <source>MakeMap creates a new map with the specified type.</source>
          <target state="translated">MakeMap은 지정된 유형의 새 맵을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="f52a4bb4c4b8bb40c53081e9faafbd87a3b197bc" translate="yes" xml:space="preserve">
          <source>MakeMapWithSize creates a new map with the specified type and initial space for approximately n elements.</source>
          <target state="translated">MakeMapWithSize는 약 n 개의 요소에 대해 지정된 유형과 초기 공간으로 새 맵을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="ddd7ccbb39b9b3baa5ecbf90987fe0065249d556" translate="yes" xml:space="preserve">
          <source>MakeSeed returns a new random seed.</source>
          <target state="translated">MakeSeed는 새로운 임의의 시드를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="55769617e91451b5769c2caeaf264e53ded13fa6" translate="yes" xml:space="preserve">
          <source>MakeSlice creates a new zero-initialized slice value for the specified slice type, length, and capacity.</source>
          <target state="translated">MakeSlice는 지정된 슬라이스 유형, 길이 및 용량에 대해 새로운 0으로 초기화 된 슬라이스 값을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="fbaf52cf63ee748130cb04d59e9e62d4763220eb" translate="yes" xml:space="preserve">
          <source>MakeString returns the String value for s.</source>
          <target state="translated">MakeString은 s의 문자열 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5e3fa6d0673feb64d51f64ca41937f6da75eff62" translate="yes" xml:space="preserve">
          <source>MakeTable</source>
          <target state="translated">MakeTable</target>
        </trans-unit>
        <trans-unit id="785bab6ccfcc81c98865184a96f5abfea960b9ee" translate="yes" xml:space="preserve">
          <source>MakeTable returns a Table constructed from the specified polynomial. The contents of this Table must not be modified.</source>
          <target state="translated">MakeTable은 지정된 다항식으로 구성된 테이블을 반환합니다. 이 표의 내용을 수정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="9a7cf77039092ac36f999962d307dd473ba79848" translate="yes" xml:space="preserve">
          <source>MakeUint64 returns the Int value for x.</source>
          <target state="translated">MakeUint64는 x에 대한 Int 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e3694e34668330687dd83b2555828d28784d9456" translate="yes" xml:space="preserve">
          <source>MakeUnknown returns the Unknown value.</source>
          <target state="translated">MakeUnknown은 Unknown 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fc2df9e4256f3cab4d6220a72b883983cc586bc1" translate="yes" xml:space="preserve">
          <source>MantExp breaks x into its mantissa and exponent components and returns the exponent. If a non-nil mant argument is provided its value is set to the mantissa of x, with the same precision and rounding mode as x. The components satisfy x == mant &amp;times; 2**exp, with 0.5 &amp;lt;= |mant| &amp;lt; 1.0. Calling MantExp with a nil argument is an efficient way to get the exponent of the receiver.</source>
          <target state="translated">MantExp는 x를 가수와 지수 성분으로 나누고 지수를 반환합니다. 0이 아닌 mant 인수가 제공되면 x와 동일한 정밀도 및 반올림 모드를 사용하여 값이 x의 가수로 설정됩니다. 구성 요소는 x == mant &amp;times; 2 ** exp를 만족하며 0.5 &amp;lt;= | mant | &amp;lt;1.0. nil 인수로 MantExp를 호출하는 것은 수신자의 지수를 얻는 효율적인 방법입니다.</target>
        </trans-unit>
        <trans-unit id="ab478f3efc840eebab919dff1b9512286f70c10c" translate="yes" xml:space="preserve">
          <source>Map</source>
          <target state="translated">Map</target>
        </trans-unit>
        <trans-unit id="053e42c081459c8a8812cfba3b82d0d77adea8da" translate="yes" xml:space="preserve">
          <source>Map is a string-to-Var map variable that satisfies the Var interface.</source>
          <target state="translated">Map은 Var 인터페이스를 만족하는 string-to-Var 맵 변수입니다.</target>
        </trans-unit>
        <trans-unit id="f35fa30552bf86b6a97457f5a529f46b1ec4ac90" translate="yes" xml:space="preserve">
          <source>Map is like a Go map[interface{}]interface{} but is safe for concurrent use by multiple goroutines without additional locking or coordination. Loads, stores, and deletes run in amortized constant time.</source>
          <target state="translated">맵은 Go 맵 [interface {}] 인터페이스 {}와 유사하지만 추가 잠금이나 조정없이 여러 고 루틴이 동시에 사용할 수 있습니다. 상각 된 일정한 시간에로드, 저장 및 삭제가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="a55357ddaf2509ac1bf72db741f5c0cb32477d6c" translate="yes" xml:space="preserve">
          <source>Map returns a copy of the byte slice s with all its characters modified according to the mapping function. If mapping returns a negative value, the character is dropped from the byte slice with no replacement. The characters in s and the output are interpreted as UTF-8-encoded code points.</source>
          <target state="translated">Map은 매핑 함수에 따라 모든 문자가 수정 된 바이트 슬라이스의 복사본을 반환합니다. 매핑이 음수 값을 반환하면 문자는 대체없이 바이트 슬라이스에서 삭제됩니다. 의 문자와 출력은 UTF-8로 인코딩 된 코드 포인트로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="0c9f196c46a54d96a050fd1d4b324297d8b6bbfd" translate="yes" xml:space="preserve">
          <source>Map returns a copy of the string s with all its characters modified according to the mapping function. If mapping returns a negative value, the character is dropped from the string with no replacement.</source>
          <target state="translated">Map은 매핑 함수에 따라 모든 문자가 수정 된 문자열의 복사본을 반환합니다. 매핑이 음수 값을 반환하면 문자가 문자열에서 대체없이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="4153ac6503fd2f26b78b101383b87a23ab8757a1" translate="yes" xml:space="preserve">
          <source>Map values are deeply equal when all of the following are true: they are both nil or both non-nil, they have the same length, and either they are the same map object or their corresponding keys (matched using Go equality) map to deeply equal values.</source>
          <target state="translated">다음 값이 모두 참이면 맵 값이 완전히 동일합니다.이 값은 모두 nil 또는 0이 아닌 값이며 길이가 같으며 동일한 맵 오브젝트 또는 해당 키 (Go equality를 사용하여 일치) 맵입니다. 동일한 값.</target>
        </trans-unit>
        <trans-unit id="ff4de2d02636ff0b35d7ac62c39c77c38ada9f83" translate="yes" xml:space="preserve">
          <source>Map values encode as JSON objects. The map's key type must either be a string, an integer type, or implement encoding.TextMarshaler. The map keys are sorted and used as JSON object keys by applying the following rules, subject to the UTF-8 coercion described for string values above:</source>
          <target state="translated">맵 값은 JSON 객체로 인코딩됩니다. 지도의 키 유형은 문자열, 정수 유형이거나 encoding.TextMarshaler를 구현해야합니다. 위의 문자열 값에 대해 설명 된 UTF-8 강제에 따라 다음 규칙을 적용하여 맵 키가 정렬되어 JSON 객체 키로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b746be79a80992b182da84fae71887f2ec6be3ae" translate="yes" xml:space="preserve">
          <source>MapIndex returns the value associated with key in the map v. It panics if v's Kind is not Map. It returns the zero Value if key is not found in the map or if v represents a nil map. As in Go, the key's value must be assignable to the map's key type.</source>
          <target state="translated">MapIndex는지도 v에서 키와 관련된 값을 반환합니다. v의 종류가지도가 아닌 경우 패닉이 발생합니다. 키가 맵에 없거나 v가 nil 맵을 나타내는 경우 0 값을 리턴합니다. Go와 마찬가지로 키의 값은지도의 키 유형에 할당 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="8a8f96c2a60281e18fdf86af937035c625b23750" translate="yes" xml:space="preserve">
          <source>MapKeys returns a slice containing all the keys present in the map, in unspecified order. It panics if v's Kind is not Map. It returns an empty slice if v represents a nil map.</source>
          <target state="translated">MapKeys는지도에있는 모든 키가 포함 된 슬라이스를 지정되지 않은 순서로 반환합니다. v의 종류가지도가 아닌 경우 패닉이 발생합니다. v가 nil 맵을 나타내는 경우 빈 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="393371509edfbb2648f262a9e6f9034fb677acf3" translate="yes" xml:space="preserve">
          <source>MapOf returns the map type with the given key and element types. For example, if k represents int and e represents string, MapOf(k, e) represents map[int]string.</source>
          <target state="translated">MapOf는 주어진 키와 요소 유형을 가진지도 유형을 반환합니다. 예를 들어, k가 int를 나타내고 e가 문자열을 나타내는 경우 MapOf (k, e)는 map [int] string을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d868be238acb64c17c8f70f0fad5dbca2528fe1a" translate="yes" xml:space="preserve">
          <source>MapRange returns a range iterator for a map. It panics if v's Kind is not Map.</source>
          <target state="translated">MapRange는지도의 범위 반복자를 반환합니다. v의 종류가지도가 아닌 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="61f910b08995efdd96acb55eeb3536149a9ef35f" translate="yes" xml:space="preserve">
          <source>Mapping between XML elements and data structures is inherently flawed: an XML element is an order-dependent collection of anonymous values, while a data structure is an order-independent collection of named values. See package json for a textual representation more suitable to data structures.</source>
          <target state="translated">XML 요소와 데이터 구조 간의 매핑은 본질적으로 결함이 있습니다. XML 요소는 순서에 따라 익명 값을 수집하는 반면 데이터 구조는 순서에 관계없이 명명 된 값을 수집합니다. 데이터 구조에 더 적합한 텍스트 표현은 패키지 json을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2b32ea0b0909e5260b55a58bd4f84f53b5d1ee01" translate="yes" xml:space="preserve">
          <source>Maps are sent as an unsigned count followed by that many key, element pairs. Empty but non-nil maps are sent, so if the receiver has not allocated one already, one will always be allocated on receipt unless the transmitted map is nil and not at the top level.</source>
          <target state="translated">지도는 서명되지 않은 개수로 전송되고 그 뒤에 여러 키, 요소 쌍이 전송됩니다. 비어 있지만 넌이 아닌 맵이 전송되므로, 수신자가 아직 할당하지 않은 경우, 전송 된 맵이 nil이고 최상위 레벨이 아닌 경우 수신시 항상 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="ea8cf739cc820968d208878224615030de7ce782" translate="yes" xml:space="preserve">
          <source>MarkComplete marks a package as complete.</source>
          <target state="translated">MarkComplete는 패키지를 완료된 것으로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="9cdfbcba7d735bd862886d7bc92cdad6e808e063" translate="yes" xml:space="preserve">
          <source>Marshal</source>
          <target state="translated">Marshal</target>
        </trans-unit>
        <trans-unit id="eb880bd9042393d95106d6336ca91dc7587c2469" translate="yes" xml:space="preserve">
          <source>Marshal converts a point into the uncompressed form specified in section 4.3.6 of ANSI X9.62.</source>
          <target state="translated">Marshal은 점을 ANSI X9.62의 4.3.6 절에 지정된 비 압축 형태로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="9a568ce91bc9dd658d20c975742fe8852b970117" translate="yes" xml:space="preserve">
          <source>Marshal converts a point on the curve into the uncompressed form specified in section 4.3.6 of ANSI X9.62.</source>
          <target state="translated">Marshal은 곡선의 한 점을 ANSI X9.62의 섹션 4.3.6에 지정된 압축되지 않은 형식으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="9dcb1e980e770758d048cdbf31965108d4392cbe" translate="yes" xml:space="preserve">
          <source>Marshal handles an array or slice by marshaling each of the elements. Marshal handles a pointer by marshaling the value it points at or, if the pointer is nil, by writing nothing. Marshal handles an interface value by marshaling the value it contains or, if the interface value is nil, by writing nothing. Marshal handles all other data by writing one or more XML elements containing the data.</source>
          <target state="translated">Marshal은 각 요소를 마샬링하여 배열 또는 슬라이스를 처리합니다. Marshal은 가리키는 값을 마샬링하거나 포인터가 nil 인 경우 아무 것도 쓰지 않으면 서 포인터를 처리합니다. Marshal은 포함 된 값을 마샬링하거나 인터페이스 값이 nil 인 경우 아무 것도 쓰지 않으면 서 인터페이스 값을 처리합니다. Marshal은 데이터를 포함하는 하나 이상의 XML 요소를 작성하여 다른 모든 데이터를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="62270c3791161d9e12b821a2dd5a09da76b7d939" translate="yes" xml:space="preserve">
          <source>Marshal returns the ASN.1 encoding of val.</source>
          <target state="translated">Marshal은 val의 ASN.1 인코딩을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d0688338eb6d31b2244e733d8a38556baae70f6c" translate="yes" xml:space="preserve">
          <source>Marshal returns the JSON encoding of v.</source>
          <target state="translated">Marshal은 v의 JSON 인코딩을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fd91d49c812b62dbf02b368713f03ffdd50b3ad6" translate="yes" xml:space="preserve">
          <source>Marshal returns the XML encoding of v.</source>
          <target state="translated">Marshal은 v의 XML 인코딩을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0de0f4cea1e586ddc2b14ecaaa41c4020891c164" translate="yes" xml:space="preserve">
          <source>Marshal traverses the value v recursively. If an encountered value implements the Marshaler interface and is not a nil pointer, Marshal calls its MarshalJSON method to produce JSON. If no MarshalJSON method is present but the value implements encoding.TextMarshaler instead, Marshal calls its MarshalText method and encodes the result as a JSON string. The nil pointer exception is not strictly necessary but mimics a similar, necessary exception in the behavior of UnmarshalJSON.</source>
          <target state="translated">원수는 값 v를 재귀 적으로 순회합니다. 발견 된 값이 Marshaler 인터페이스를 구현하고 nil 포인터가 아닌 경우 Marshal은 MarshalJSON 메소드를 호출하여 JSON을 생성합니다. MarshalJSON 메서드가 없지만 값이 encoding.TextMarshaler를 구현하는 경우 Marshal은 MarshalText 메서드를 호출하고 결과를 JSON 문자열로 인코딩합니다. nil 포인터 예외는 반드시 필요한 것은 아니지만 UnmarshalJSON의 동작에서 비슷하고 필요한 예외를 모방합니다.</target>
        </trans-unit>
        <trans-unit id="fafaa1ebf620f3798cc6a8c58b669a7ea73fa6b9" translate="yes" xml:space="preserve">
          <source>Marshal will return an error if asked to marshal a channel, function, or map.</source>
          <target state="translated">채널, 함수 또는 맵을 마샬링하도록 요청하면 Marshal에서 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="db453e34c5fbd8220b129af743f7150483dd7932" translate="yes" xml:space="preserve">
          <source>MarshalBinary encodes the receiver into a binary form and returns the result.</source>
          <target state="translated">MarshalBinary는 수신자를 이진 형식으로 인코딩하고 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0bedf8f876a84577084ab2b16cacfd3254f063b2" translate="yes" xml:space="preserve">
          <source>MarshalBinary implements the encoding.BinaryMarshaler interface.</source>
          <target state="translated">MarshalBinary는 encoding.BinaryMarshaler 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="b0dd910cac1cbbac9d43ce35c5c8bd02d8b6dc15" translate="yes" xml:space="preserve">
          <source>MarshalCompressed converts a point on the curve into the compressed form specified in section 4.3.6 of ANSI X9.62.</source>
          <target state="translated">MarshalCompressed는 곡선의 한 점을 ANSI X9.62의 섹션 4.3.6에 지정된 압축 형식으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="ee53c721c287cd02dbf9f92c9f5e2a991f1f615d" translate="yes" xml:space="preserve">
          <source>MarshalECPrivateKey converts an EC private key to SEC 1, ASN.1 DER form.</source>
          <target state="translated">MarshalECPrivateKey는 EC 개인 키를 SEC 1, ASN.1 DER 형식으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="f9e73b7909d7a048a7d6c9e44a0504b100446e17" translate="yes" xml:space="preserve">
          <source>MarshalIndent</source>
          <target state="translated">MarshalIndent</target>
        </trans-unit>
        <trans-unit id="42cea4e6f776e84fbd92d4a9f5ef1c3b218c54ea" translate="yes" xml:space="preserve">
          <source>MarshalIndent is like Marshal but applies Indent to format the output. Each JSON element in the output will begin on a new line beginning with prefix followed by one or more copies of indent according to the indentation nesting.</source>
          <target state="translated">MarshalIndent는 Marshal과 비슷하지만 들여 쓰기를 적용하여 출력 형식을 지정합니다. 출력의 각 JSON 요소는 접두사로 시작하고 들여 쓰기 중첩에 따라 하나 이상의 들여 쓰기 사본이 오는 새 줄에서 시작합니다.</target>
        </trans-unit>
        <trans-unit id="b93c5c2e6a3ce1b1ffab83edfd3027b2f5a958ee" translate="yes" xml:space="preserve">
          <source>MarshalIndent works like Marshal, but each XML element begins on a new indented line that starts with prefix and is followed by one or more copies of indent according to the nesting depth.</source>
          <target state="translated">MarshalIndent는 Marshal처럼 작동하지만 각 XML 요소는 접두사로 시작하고 중첩 깊이에 따라 하나 이상의 들여 쓰기 복사본이 오는 새 들여 쓰기 된 줄에서 시작합니다.</target>
        </trans-unit>
        <trans-unit id="1fe8186b542a0c93fd906dfbf1d378366d66b83e" translate="yes" xml:space="preserve">
          <source>MarshalJSON implements the json.Marshaler interface.</source>
          <target state="translated">MarshalJSON은 json.Marshaler 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="34cafb57f3bf4f148de8715aea906ddd24ca5b67" translate="yes" xml:space="preserve">
          <source>MarshalJSON implements the json.Marshaler interface. The time is a quoted string in RFC 3339 format, with sub-second precision added if present.</source>
          <target state="translated">MarshalJSON은 json.Marshaler 인터페이스를 구현합니다. 시간은 RFC 3339 형식의 따옴표로 묶인 문자열이며, 존재하는 경우 초 이하의 정밀도가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="79739908efedb1d030bbc1bed7fc419173d502bc" translate="yes" xml:space="preserve">
          <source>MarshalJSON returns m as the JSON encoding of m.</source>
          <target state="translated">MarshalJSON은 m을 JSON 인코딩으로 m을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dc6df497a7bc177e42838cf4d34e8a9fff8f37f9" translate="yes" xml:space="preserve">
          <source>MarshalPKCS1PrivateKey converts an RSA private key to PKCS #1, ASN.1 DER form.</source>
          <target state="translated">MarshalPKCS1PrivateKey는 RSA 개인 키를 PKCS # 1, ASN.1 DER 형식으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="49c4c53b126d5e728f2103ee05aeb8456df06352" translate="yes" xml:space="preserve">
          <source>MarshalPKCS1PrivateKey converts an RSA private key to PKCS#1, ASN.1 DER form.</source>
          <target state="translated">MarshalPKCS1PrivateKey는 RSA 개인 키를 PKCS # 1, ASN.1 DER 형식으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="679ae9ec5a41bfe29c2cb0674503ed9d5f0c3931" translate="yes" xml:space="preserve">
          <source>MarshalPKCS1PublicKey converts an RSA public key to PKCS #1, ASN.1 DER form.</source>
          <target state="translated">MarshalPKCS1PublicKey는 RSA 공개 키를 PKCS # 1, ASN.1 DER 형식으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="6dbb4afc98d66ecc773730ab53b2d3d25670dae3" translate="yes" xml:space="preserve">
          <source>MarshalPKCS1PublicKey converts an RSA public key to PKCS#1, ASN.1 DER form.</source>
          <target state="translated">MarshalPKCS1PublicKey는 RSA 공개 키를 PKCS # 1, ASN.1 DER 형식으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="45354407cae2db32eaa7718849355ec2165c982c" translate="yes" xml:space="preserve">
          <source>MarshalPKCS8PrivateKey converts a private key to PKCS #8, ASN.1 DER form.</source>
          <target state="translated">MarshalPKCS8PrivateKey는 개인 키를 PKCS # 8, ASN.1 DER 형식으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="de5c14e75241b3422cb105f3219299fa62dfe8b0" translate="yes" xml:space="preserve">
          <source>MarshalPKCS8PrivateKey converts an RSA private key to PKCS#8, ASN.1 DER form.</source>
          <target state="translated">MarshalPKCS8PrivateKey는 RSA 개인 키를 PKCS # 8, ASN.1 DER 형식으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="7c79ebdd42b60d7be91053c9a1161ea6d5ebbab9" translate="yes" xml:space="preserve">
          <source>MarshalPKIXPublicKey converts a public key to PKIX, ASN.1 DER form.</source>
          <target state="translated">MarshalPKIXPublicKey는 공개 키를 PKIX, ASN.1 DER 형식으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="f11f550d1b6c7d3b4aec2299c3db3d8ce95b07ef" translate="yes" xml:space="preserve">
          <source>MarshalPKIXPublicKey converts a public key to PKIX, ASN.1 DER form. The encoded public key is a SubjectPublicKeyInfo structure (see RFC 5280, Section 4.1).</source>
          <target state="translated">MarshalPKIXPublicKey는 공개 키를 PKIX, ASN.1 DER 형식으로 변환합니다. 인코딩 된 공개 키는 SubjectPublicKeyInfo 구조입니다 (RFC 5280, 섹션 4.1 참조).</target>
        </trans-unit>
        <trans-unit id="def0005fff87679bf808d28ec17c1164d884c779" translate="yes" xml:space="preserve">
          <source>MarshalText encodes the receiver into UTF-8-encoded text and returns the result.</source>
          <target state="translated">MarshalText는 수신자를 UTF-8로 인코딩 된 텍스트로 인코딩하고 결과를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="0e6ec969b789b52d1c5120ea85c9ad182259f168" translate="yes" xml:space="preserve">
          <source>MarshalText implements the encoding.TextMarshaler interface.</source>
          <target state="translated">MarshalText는 encoding.TextMarshaler 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="e9f45c26a4b805caf1ff0c7f133453fe1405ea6f" translate="yes" xml:space="preserve">
          <source>MarshalText implements the encoding.TextMarshaler interface. Only the Float value is marshaled (in full precision), other attributes such as precision or accuracy are ignored.</source>
          <target state="translated">MarshalText는 encoding.TextMarshaler 인터페이스를 구현합니다. Float 값만 마샬링되고 (정밀도) 정밀도 또는 정확도와 같은 다른 속성은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="1fbe6f2d906b1d5948fbd9851ef463bba4786bcb" translate="yes" xml:space="preserve">
          <source>MarshalText implements the encoding.TextMarshaler interface. The encoding is the same as returned by String, with one exception: When len(ip) is zero, it returns an empty slice.</source>
          <target state="translated">MarshalText는 encoding.TextMarshaler 인터페이스를 구현합니다. 인코딩은 String이 반환 한 것과 동일하지만 한 가지 예외가 있습니다. len (ip)가 0이면 빈 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="83f43718a3654277944df9768c5af959f91ebe45" translate="yes" xml:space="preserve">
          <source>MarshalText implements the encoding.TextMarshaler interface. The time is formatted in RFC 3339 format, with sub-second precision added if present.</source>
          <target state="translated">MarshalText는 encoding.TextMarshaler 인터페이스를 구현합니다. 시간은 RFC 3339 형식으로 표시되며 초 단위 정밀도가 있으면 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="14fcaccd265e76bda57404dd966d33311a65ffc3" translate="yes" xml:space="preserve">
          <source>MarshalWithParams allows field parameters to be specified for the top-level element. The form of the params is the same as the field tags.</source>
          <target state="translated">MarshalWithParams를 사용하면 최상위 요소에 필드 매개 변수를 지정할 수 있습니다. 매개 변수의 형식은 필드 태그와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="34052c5ea18ea7495e24eea4a4d137cecba4872c" translate="yes" xml:space="preserve">
          <source>MarshalXML encodes the receiver as zero or more XML elements. By convention, arrays or slices are typically encoded as a sequence of elements, one per entry. Using start as the element tag is not required, but doing so will enable Unmarshal to match the XML elements to the correct struct field. One common implementation strategy is to construct a separate value with a layout corresponding to the desired XML and then to encode it using e.EncodeElement. Another common strategy is to use repeated calls to e.EncodeToken to generate the XML output one token at a time. The sequence of encoded tokens must make up zero or more valid XML elements.</source>
          <target state="translated">MarshalXML은 수신자를 0 개 이상의 XML 요소로 인코딩합니다. 일반적으로 배열 또는 슬라이스는 일반적으로 항목 당 하나씩 일련의 요소로 인코딩됩니다. element 태그로 start를 사용할 필요는 없지만 Unmarshal을 사용하면 XML 요소를 올바른 구조체 필드에 일치시킬 수 있습니다. 일반적인 구현 전략 중 하나는 원하는 XML에 해당하는 레이아웃으로 별도의 값을 구성한 다음 e.EncodeElement를 사용하여 인코딩하는 것입니다. 또 다른 일반적인 전략은 e.EncodeToken에 대한 반복 호출을 사용하여 한 번에 하나의 토큰으로 XML 출력을 생성하는 것입니다. 인코딩 된 토큰 시퀀스는 0 개 이상의 유효한 XML 요소를 구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="41210996386655a5e9f720c4f9e735ef866f35cb" translate="yes" xml:space="preserve">
          <source>MarshalXMLAttr returns an XML attribute with the encoded value of the receiver. Using name as the attribute name is not required, but doing so will enable Unmarshal to match the attribute to the correct struct field. If MarshalXMLAttr returns the zero attribute Attr{}, no attribute will be generated in the output. MarshalXMLAttr is used only for struct fields with the &quot;attr&quot; option in the field tag.</source>
          <target state="translated">MarshalXMLAttr은 수신자의 인코딩 된 값이있는 XML 속성을 리턴합니다. 속성 이름으로 name을 사용할 필요는 없지만, 그렇게하면 Unmarshal이 속성을 올바른 구조체 필드에 일치시킬 수 있습니다. MarshalXMLAttr이 0 속성 Attr {}을 리턴하면 출력에 속성이 생성되지 않습니다. MarshalXMLAttr은 필드 태그에 &quot;attr&quot;옵션이있는 구조체 필드에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="18fd048394e569d8195a81313b9e64f2eba7ee35" translate="yes" xml:space="preserve">
          <source>Marshaler is the interface implemented by objects that can marshal themselves into valid XML elements.</source>
          <target state="translated">Marshaler는 유효한 XML 요소로 마샬링 할 수있는 객체로 구현 된 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="47a2664e5f80a08312afe3946a74993c99143c6d" translate="yes" xml:space="preserve">
          <source>Marshaler is the interface implemented by types that can marshal themselves into valid JSON.</source>
          <target state="translated">Marshaler는 유효한 JSON으로 마샬링 할 수있는 유형으로 구현 된 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="4a00ca7b38dd0506417989c16c2542f21f4d7c58" translate="yes" xml:space="preserve">
          <source>MarshalerAttr is the interface implemented by objects that can marshal themselves into valid XML attributes.</source>
          <target state="translated">MarshalerAttr은 유효한 XML 속성으로 마샬링 할 수있는 객체로 구현 된 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="5c61140e5006502f101ce6ee77324538231946bb" translate="yes" xml:space="preserve">
          <source>Mask returns the result of masking the IP address ip with mask.</source>
          <target state="translated">마스크는 IP 주소 ip를 마스크로 마스킹 한 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0335207f5e840d81afa158c6c2bb6e3fa02653b4" translate="yes" xml:space="preserve">
          <source>Match</source>
          <target state="translated">Match</target>
        </trans-unit>
        <trans-unit id="b841b8491dab0dabb8feb21367e059b0624fa3bb" translate="yes" xml:space="preserve">
          <source>Match reports whether name matches the shell file name pattern. The pattern syntax is:</source>
          <target state="translated">일치는 이름이 쉘 파일 이름 패턴과 일치하는지 여부를보고합니다. 패턴 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="65238f3fd69244258d0fe7834a55d41fd9fdb4b5" translate="yes" xml:space="preserve">
          <source>Match reports whether name matches the shell pattern. The pattern syntax is:</source>
          <target state="translated">일치는 이름이 쉘 패턴과 일치하는지 여부를보고합니다. 패턴 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5f5677ee8a35a029aa3e90c1d56b65878192d3b4" translate="yes" xml:space="preserve">
          <source>Match reports whether the byte slice b contains any match of the regular expression pattern. More complicated queries need to use Compile and the full Regexp interface.</source>
          <target state="translated">Match는 바이트 슬라이스 b에 정규식 패턴이 일치하는지 여부를보고합니다. 더 복잡한 쿼리는 컴파일 및 전체 Regexp 인터페이스를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="269393d413e09f2ec5ba2e6fbdd662834a23a90b" translate="yes" xml:space="preserve">
          <source>Match reports whether the byte slice b contains any match of the regular expression re.</source>
          <target state="translated">Match는 바이트 슬라이스 b에 정규 표현식 re와 일치하는 항목이 있는지보고합니다.</target>
        </trans-unit>
        <trans-unit id="188538220b1d59de0ef20f48b5e9a854e7a08bec" translate="yes" xml:space="preserve">
          <source>Match requires pattern to match all of name, not just a substring. The only possible returned error is ErrBadPattern, when pattern is malformed.</source>
          <target state="translated">일치에는 패턴이 하위 문자열뿐만 아니라 모든 이름과 일치해야합니다. 패턴이 잘못되었을 때 반환 될 수있는 유일한 오류는 ErrBadPattern입니다.</target>
        </trans-unit>
        <trans-unit id="fb78f24b3584ab26ff8d868ae02c24bc3e7a84f8" translate="yes" xml:space="preserve">
          <source>MatchEmptyWidth reports whether the instruction matches an empty string between the runes before and after. It should only be called when i.Op == InstEmptyWidth.</source>
          <target state="translated">MatchEmptyWidth는 명령이 런 사이의 빈 문자열과 전후에 빈 문자열과 일치하는지 여부를보고합니다. i.Op == InstEmptyWidth 인 경우에만 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="766801810391656eb72b30e1a620adc09dc91643" translate="yes" xml:space="preserve">
          <source>MatchFile considers the name of the file and may use ctxt.OpenFile to read some or all of the file's content.</source>
          <target state="translated">MatchFile은 파일 이름을 고려하고 ctxt.OpenFile을 사용하여 파일 내용의 일부 또는 전부를 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32f23226c3beda09b3f84dfe037d9c9ada013d83" translate="yes" xml:space="preserve">
          <source>MatchFile reports whether the file with the given name in the given directory matches the context and would be included in a Package created by ImportDir of that directory.</source>
          <target state="translated">MatchFile은 주어진 디렉토리에 주어진 이름을 가진 파일이 컨텍스트와 일치하고 해당 디렉토리의 ImportDir에 의해 작성된 패키지에 포함되는지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="230e93d3f899e27c4d81d89f3ff53b1eca08bb37" translate="yes" xml:space="preserve">
          <source>MatchReader reports whether the text returned by the RuneReader contains any match of the regular expression pattern. More complicated queries need to use Compile and the full Regexp interface.</source>
          <target state="translated">MatchReader는 RuneReader가 반환 한 텍스트에 정규식 패턴이 일치하는지 여부를보고합니다. 더 복잡한 쿼리는 컴파일 및 전체 Regexp 인터페이스를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="25c8a8e56012833544924619010cf5721432e9ab" translate="yes" xml:space="preserve">
          <source>MatchReader reports whether the text returned by the RuneReader contains any match of the regular expression re.</source>
          <target state="translated">MatchReader는 RuneReader가 반환 한 텍스트에 정규 표현식 re와 일치하는 항목이 포함되어 있는지보고합니다.</target>
        </trans-unit>
        <trans-unit id="da28fa625630bc6b02e3ddab6dad208f72cd40bb" translate="yes" xml:space="preserve">
          <source>MatchRune reports whether the instruction matches (and consumes) r. It should only be called when i.Op == InstRune.</source>
          <target state="translated">MatchRune은 명령이 일치하는지 (소비되는지)를보고합니다. r. i.Op == InstRune 인 경우에만 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="c488501e6169e99f4e3f5cf4b601fce5b1d18d9c" translate="yes" xml:space="preserve">
          <source>MatchRunePos checks whether the instruction matches (and consumes) r. If so, MatchRunePos returns the index of the matching rune pair (or, when len(i.Rune) == 1, rune singleton). If not, MatchRunePos returns -1. MatchRunePos should only be called when i.Op == InstRune.</source>
          <target state="translated">MatchRunePos는 명령이 일치하는지 (및 소비)인지 확인합니다. r. 일치하면 MatchRunePos는 일치하는 룬 쌍의 색인을 반환합니다 (또는 len (i.Rune) == 1 인 경우 룬 싱글 톤). 그렇지 않으면 MatchRunePos는 -1을 반환합니다. MatchRunePos는 i.Op == InstRune 인 경우에만 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="c78293f6444063ae02b61b422c861a74ea5c0992" translate="yes" xml:space="preserve">
          <source>MatchString</source>
          <target state="translated">MatchString</target>
        </trans-unit>
        <trans-unit id="16440a205b6632a6f9ce394e96f4e30da62834e6" translate="yes" xml:space="preserve">
          <source>MatchString reports whether the string s contains any match of the regular expression pattern. More complicated queries need to use Compile and the full Regexp interface.</source>
          <target state="translated">MatchString은 문자열 s에 정규식 패턴과 일치하는 항목이 있는지보고합니다. 더 복잡한 쿼리는 컴파일 및 전체 Regexp 인터페이스를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="0b53f246428ae463a3e54d71ff6883543bf5e6b2" translate="yes" xml:space="preserve">
          <source>MatchString reports whether the string s contains any match of the regular expression re.</source>
          <target state="translated">MatchString은 문자열 s에 정규 표현식 re와 일치하는 항목이 있는지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="386301aac4b9205f957c7e2aded15dd3a3170a4d" translate="yes" xml:space="preserve">
          <source>Mathematical constants.</source>
          <target state="translated">수학 상수.</target>
        </trans-unit>
        <trans-unit id="e9339d8c2f10a09643bf33b4b293ddbf19fb634d" translate="yes" xml:space="preserve">
          <source>Mathematical interval notation such as [0, n) is used throughout the documentation for this package.</source>
          <target state="translated">[0, n)과 같은 수학적 간격 표기법은이 패키지의 설명서 전체에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b64028b7ef9651f5e0c9bf08d57c40c964fb143d" translate="yes" xml:space="preserve">
          <source>Max returns the larger of x or y.</source>
          <target state="translated">최대 값은 x 또는 y 중 큰 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6c955f951ae2dab8e6f5e54e3a98c7139c879b48" translate="yes" xml:space="preserve">
          <source>MaxBase is the largest number base accepted for string conversions.</source>
          <target state="translated">MaxBase는 문자열 변환에 허용되는 최대 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="d9d067026e10599a63c5386be336904174743560" translate="yes" xml:space="preserve">
          <source>MaxBytesReader is similar to io.LimitReader but is intended for limiting the size of incoming request bodies. In contrast to io.LimitReader, MaxBytesReader's result is a ReadCloser, returns a non-EOF error for a Read beyond the limit, and closes the underlying reader when its Close method is called.</source>
          <target state="translated">MaxBytesReader는 io.LimitReader와 유사하지만 들어오는 요청 본문의 크기를 제한하기위한 것입니다. io.LimitReader와 달리 MaxBytesReader의 결과는 ReadCloser이며, 한계를 초과하는 Read에 대해 EOF가 아닌 오류를 반환하며 Close 메서드가 호출 될 때 기본 판독기를 닫습니다.</target>
        </trans-unit>
        <trans-unit id="739ec125397a0373ef46f377effdf6be903c6fd8" translate="yes" xml:space="preserve">
          <source>MaxBytesReader prevents clients from accidentally or maliciously sending a large request and wasting server resources.</source>
          <target state="translated">MaxBytesReader는 클라이언트가 실수로 또는 악의적으로 큰 요청을 보내거나 서버 리소스를 낭비하지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="61be69d33fec3be907f4ea6e04af100d85f7675e" translate="yes" xml:space="preserve">
          <source>MaxCap walks the regexp to find the maximum capture index.</source>
          <target state="translated">MaxCap은 정규 표현식을 따라 최대 캡처 인덱스를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="df7b72cdcf2650790c955b9e993a0a0c2fbe25b4" translate="yes" xml:space="preserve">
          <source>MaxEncodedLen returns the maximum length of an encoding of n source bytes.</source>
          <target state="translated">MaxEncodedLen은 n 소스 바이트 인코딩의 최대 길이를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="89c65689a7af2cc891fbeafce261f8df625c4303" translate="yes" xml:space="preserve">
          <source>MaxVarintLenN is the maximum length of a varint-encoded N-bit integer.</source>
          <target state="translated">MaxVarintLenN은 varint 인코딩 된 N 비트 정수의 최대 길이입니다.</target>
        </trans-unit>
        <trans-unit id="1157d0585a10f5f650da7952c06f96ac83134419" translate="yes" xml:space="preserve">
          <source>MemProfile returns a profile of memory allocated and freed per allocation site.</source>
          <target state="translated">MemProfile은 할당 사이트 당 할당 및 해제 된 메모리 프로파일을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d8d6b923c77de71210013c81589eaf2c4fe10654" translate="yes" xml:space="preserve">
          <source>MemProfile returns n, the number of records in the current memory profile. If len(p) &amp;gt;= n, MemProfile copies the profile into p and returns n, true. If len(p) &amp;lt; n, MemProfile does not change p and returns n, false.</source>
          <target state="translated">MemProfile은 현재 메모리 프로파일의 레코드 수인 n을 리턴합니다. len (p)&amp;gt; = n 인 경우 MemProfile은 프로파일을 p에 복사하고 n, true를 리턴합니다. len (p) &amp;lt;n이면 MemProfile은 p를 변경하지 않고 n을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c013eb0f98db13dab8418c5c8a82f2ae00733c42" translate="yes" xml:space="preserve">
          <source>MemProfileRate controls the fraction of memory allocations that are recorded and reported in the memory profile. The profiler aims to sample an average of one allocation per MemProfileRate bytes allocated.</source>
          <target state="translated">MemProfileRate는 메모리 프로파일에 기록 및보고되는 메모리 할당 비율을 제어합니다. 프로파일 러는 할당 된 MemProfileRate 바이트 당 평균 하나의 할당을 샘플링하는 것을 목표로합니다.</target>
        </trans-unit>
        <trans-unit id="e7ca02f761fad2cef95bf22ec3a49a7a10d4d7ec" translate="yes" xml:space="preserve">
          <source>MemString returns r.AllocedBytesPerOp and r.AllocsPerOp in the same format as 'go test'.</source>
          <target state="translated">MemString은 'go test'와 동일한 형식으로 r.AllocedBytesPerOp 및 r.AllocsPerOp를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5885c324e2b06a6d3881d7dca39a2a9515c8b84e" translate="yes" xml:space="preserve">
          <source>MergeLine merges a line with the following line. It is akin to replacing the newline character at the end of the line with a space (to not change the remaining offsets). To obtain the line number, consult e.g. Position.Line. MergeLine will panic if given an invalid line number.</source>
          <target state="translated">MergeLine은 한 줄을 다음 줄과 병합합니다. 줄 끝의 줄 바꿈 문자를 공백으로 바꾸는 것과 비슷합니다 (나머지 오프셋을 변경하지 않기 위해). 라인 번호를 얻으려면 예를 들어 Position.Line을 참조하십시오. 유효하지 않은 라인 번호가 주어지면 MergeLine이 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="c56ee5f274246d4907a3f8792aa47b70201e2839" translate="yes" xml:space="preserve">
          <source>MergePackageFiles creates a file AST by merging the ASTs of the files belonging to a package. The mode flags control merging behavior.</source>
          <target state="translated">MergePackageFiles는 패키지에 속하는 파일의 AST를 병합하여 파일 AST를 만듭니다. 모드 플래그는 병합 동작을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="7f6f0438a1b28dd75bfa1675a817c685d6ecf309" translate="yes" xml:space="preserve">
          <source>Method represents a single method.</source>
          <target state="translated">방법은 단일 방법을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d5cc6ded0a12c1ea7e555fe80a4dd907a9326b65" translate="yes" xml:space="preserve">
          <source>Method returns a function value corresponding to v's i'th method. The arguments to a Call on the returned function should not include a receiver; the returned function will always use v as the receiver. Method panics if i is out of range or if v is a nil interface value.</source>
          <target state="translated">Method는 v의 i 번째 메소드에 해당하는 함수 값을 리턴합니다. 리턴 된 함수에서 호출에 대한 인수는 수신자를 포함하지 않아야합니다. 리턴 된 함수는 항상 v를 수신자로 사용합니다. i가 범위를 벗어 났거나 v가 nil 인터페이스 값인 경우 메소드 패닉.</target>
        </trans-unit>
        <trans-unit id="8580bc7cf729ccd2e220561b0a2aa0093af75313" translate="yes" xml:space="preserve">
          <source>Method returns the i'th method of interface t for 0 &amp;lt;= i &amp;lt; t.NumMethods(). The methods are ordered by their unique Id.</source>
          <target state="translated">메소드는 0 &amp;lt;= i &amp;lt;t.NumMethods ()에 대해 인터페이스 t의 i 번째 메소드를 리턴합니다. 방법은 고유 한 ID로 주문됩니다.</target>
        </trans-unit>
        <trans-unit id="e73d31c50554a72b3457fac0045f98cc3b8b72de" translate="yes" xml:space="preserve">
          <source>Method returns the i'th method of interface t for 0 &amp;lt;= i &amp;lt; t.NumMethods(). The methods are ordered by their unique Id. The interface must have been completed.</source>
          <target state="translated">메서드는 0 &amp;lt;= i &amp;lt;t.NumMethods ()에 대해 인터페이스 t의 i 번째 메서드를 반환합니다. 메서드는 고유 한 ID로 정렬됩니다. 인터페이스가 완료되어야합니다.</target>
        </trans-unit>
        <trans-unit id="0d5919064169d4fa2dfa670c5cd1d31fe4f5ec77" translate="yes" xml:space="preserve">
          <source>Method returns the i'th method of named type t for 0 &amp;lt;= i &amp;lt; t.NumMethods().</source>
          <target state="translated">메소드는 0 &amp;lt;= i &amp;lt;t.NumMethods ()에 대해 명명 된 유형 t의 i 번째 메소드를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7b406879ef1e276f5ac32d320c19bb15ff9ced44" translate="yes" xml:space="preserve">
          <source>MethodByName returns a function value corresponding to the method of v with the given name. The arguments to a Call on the returned function should not include a receiver; the returned function will always use v as the receiver. It returns the zero Value if no method was found.</source>
          <target state="translated">MethodByName은 주어진 이름을 가진 v의 메소드에 해당하는 함수 값을 리턴합니다. 리턴 된 함수에서 호출에 대한 인수는 수신자를 포함하지 않아야합니다. 리턴 된 함수는 항상 v를 수신자로 사용합니다. 메소드를 찾지 못하면 0 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="1995bb7d8a495c29ba7a59b0b373d66ee1f82142" translate="yes" xml:space="preserve">
          <source>MethodSet</source>
          <target state="translated">MethodSet</target>
        </trans-unit>
        <trans-unit id="c5e9a1bdc9129c6b25b91c69272ee11aa65ae4ac" translate="yes" xml:space="preserve">
          <source>Methods of this form typically return the incoming receiver as well, to enable simple call chaining.</source>
          <target state="translated">이 형식의 메소드는 일반적으로 간단한 호출 체인을 가능하게하기 위해 수신 수신자도 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="68e37169f0406f89039a63dc143d5a05fc9b5510" translate="yes" xml:space="preserve">
          <source>Methods which don't require a result value to be passed in (for instance, Int.Sign), simply return the result. In this case, the receiver is typically the first operand, named x:</source>
          <target state="translated">결과 값을 전달할 필요가없는 메소드 (예 : Int.Sign)는 단순히 결과를 리턴합니다. 이 경우 수신자는 일반적으로 x라는 첫 번째 피연산자입니다.</target>
        </trans-unit>
        <trans-unit id="ae0ec4a01266d62782eafe6da2c5652e2035cd23" translate="yes" xml:space="preserve">
          <source>Metric key format</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b7255f6144e583d2f9b057070f13f8273f6bf2d" translate="yes" xml:space="preserve">
          <source>Metrics are designated by a string key, rather than, for example, a field name in a struct. The full list of supported metrics is always available in the slice of Descriptions returned by All. Each Description also includes useful information about the metric.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="594fd92ee6be7b72c6f8d9451d2a9f9e3bae51ed" translate="yes" xml:space="preserve">
          <source>Microseconds returns the duration as an integer microsecond count.</source>
          <target state="translated">마이크로 초는 지속 시간을 정수 마이크로 초 카운트로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c825c82257bdcbc1a135579145266c6ee484713a" translate="yes" xml:space="preserve">
          <source>Milliseconds returns the duration as an integer millisecond count.</source>
          <target state="translated">밀리 초는 지속 시간을 정수 밀리 초 카운트로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d4a6fe67a8f15c1c894bf05225db6c07db7dc926" translate="yes" xml:space="preserve">
          <source>Min returns the smaller of x or y.</source>
          <target state="translated">최소값은 x 또는 y 중 작은 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dacfaba796bce8b807113e726ae0618041c980f0" translate="yes" xml:space="preserve">
          <source>MinPrec returns the minimum precision required to represent x exactly (i.e., the smallest prec before x.SetPrec(prec) would start rounding x). The result is 0 for |x| == 0 and |x| == Inf.</source>
          <target state="translated">MinPrec은 x를 정확하게 나타내는 데 필요한 최소 정밀도를 반환합니다 (즉, x.SetPrec (prec)가 x를 반올림하기 전에 가장 작은 prec). | x |의 경우 결과는 0입니다 == 0 및 | x | == Inf.</target>
        </trans-unit>
        <trans-unit id="b959e8418a57efc341ef2ea80360e0eee71f265e" translate="yes" xml:space="preserve">
          <source>MinRead is the minimum slice size passed to a Read call by Buffer.ReadFrom. As long as the Buffer has at least MinRead bytes beyond what is required to hold the contents of r, ReadFrom will not grow the underlying buffer.</source>
          <target state="translated">MinRead는 Buffer.ReadFrom이 Read 호출에 전달한 최소 슬라이스 크기입니다. 버퍼에 r의 내용을 보유하는 데 필요한 것보다 최소한 MinRead 바이트가있는 한 ReadFrom은 기본 버퍼를 늘리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ba682b9edf600874d186945b125535bdb2fd2d00" translate="yes" xml:space="preserve">
          <source>Minute returns the minute offset within the hour specified by t, in the range [0, 59].</source>
          <target state="translated">분은 [0, 59] 범위에서 t로 지정된 시간 내에 분 오프셋을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f75dd7f0b206dbae82a8f8f0b7023bff54f3a266" translate="yes" xml:space="preserve">
          <source>Minutes returns the duration as a floating point number of minutes.</source>
          <target state="translated">분은 기간을 부동 소수점 수 (분)로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="eb3dbdbaa825e8d8a44607bf8d9e0b1911e69e12" translate="yes" xml:space="preserve">
          <source>MissingMethod returns (nil, false) if V implements T, otherwise it returns a missing method required by T and whether it is missing or just has the wrong type.</source>
          <target state="translated">V가 T를 구현하면 MissingMethod는 (nil, false)를 반환하고, 그렇지 않으면 T에 필요한 누락 된 메서드와 누락되었거나 잘못된 유형인지 여부를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="37de4657eb0dc5b3413cb095b60f3d8129f6593f" translate="yes" xml:space="preserve">
          <source>Mkdir creates a new directory with the specified name and permission bits (before umask). If there is an error, it will be of type *PathError.</source>
          <target state="translated">Mkdir은 지정된 이름과 권한 비트 (umask 이전)를 사용하여 새 디렉토리를 만듭니다. 오류가 있으면 * PathError 유형입니다.</target>
        </trans-unit>
        <trans-unit id="677ef1c770313b12ac646270f84a792125bb5633" translate="yes" xml:space="preserve">
          <source>MkdirAll creates a directory named path, along with any necessary parents, and returns nil, or else returns an error. The permission bits perm (before umask) are used for all directories that MkdirAll creates. If path is already a directory, MkdirAll does nothing and returns nil.</source>
          <target state="translated">MkdirAll은 필요한 부모와 함께 path라는 디렉토리를 작성하고 nil을 리턴하거나 그렇지 않으면 오류를 리턴합니다. 권한 비트 perm (umask 이전)은 MkdirAll이 작성하는 모든 디렉토리에 사용됩니다. path가 이미 디렉토리이면 MkdirAll은 아무 작업도 수행하지 않고 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="69abe658c607f76904840b22f129f99c5cdd5602" translate="yes" xml:space="preserve">
          <source>MkdirTemp</source>
          <target state="translated">MkdirTemp</target>
        </trans-unit>
        <trans-unit id="7a5b7f37aa4dbbfd95b5cb948d3603090e4e4163" translate="yes" xml:space="preserve">
          <source>MkdirTemp (Suffix)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15d9ed356acc6188361ff1f707194945a55386da" translate="yes" xml:space="preserve">
          <source>MkdirTemp creates a new temporary directory in the directory dir and returns the pathname of the new directory. The new directory's name is generated by adding a random string to the end of pattern. If pattern includes a &quot;*&quot;, the random string replaces the last &quot;*&quot; instead. If dir is the empty string, MkdirTemp uses the default directory for temporary files, as returned by TempDir. Multiple programs or goroutines calling MkdirTemp simultaneously will not choose the same directory. It is the caller's responsibility to remove the directory when it is no longer needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f388dbfb78ec3e8821ae0844a947cecd488dd5ff" translate="yes" xml:space="preserve">
          <source>Mod</source>
          <target state="translated">Mod</target>
        </trans-unit>
        <trans-unit id="373154d6ec87032b198bd3426fdb98b629297d1b" translate="yes" xml:space="preserve">
          <source>Mod returns the floating-point remainder of x/y. The magnitude of the result is less than y and its sign agrees with that of x.</source>
          <target state="translated">Mod는 x / y의 부동 소수점 나머지를 반환합니다. 결과의 크기는 y보다 작으며 기호는 x의 기호와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="f2b25579075ef3b96af2a2e04dfbe27a4023e7c3" translate="yes" xml:space="preserve">
          <source>Mod returns the point q in r such that p.X-q.X is a multiple of r's width and p.Y-q.Y is a multiple of r's height.</source>
          <target state="translated">Mod는 pX-qX가 r의 너비의 배수이고 pY-qY가 r의 높이의 배수가되도록 r에서 점 q를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5301dec2851eeeadb9f8edd3bcc14178a7cc1eac" translate="yes" xml:space="preserve">
          <source>Mod sets z to the modulus x%y for y != 0 and returns z. If y == 0, a division-by-zero run-time panic occurs. Mod implements Euclidean modulus (unlike Go); see DivMod for more details.</source>
          <target state="translated">Mod는 y! = 0에 대해 z를 계수 x % y로 설정하고 z를 반환합니다. y == 0이면 0으로 나누기 런타임 패닉이 발생합니다. Mod는 Gocli와 달리 유클리드 모듈러스를 구현합니다. 자세한 내용은 DivMod를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6d74b87ee55add7bade81d22a2a4510010f96ac8" translate="yes" xml:space="preserve">
          <source>ModInverse sets z to the multiplicative inverse of g in the ring ℤ/nℤ and returns z. If g and n are not relatively prime, g has no multiplicative inverse in the ring ℤ/nℤ. In this case, z is unchanged and the return value is nil.</source>
          <target state="translated">ModInverse는 z를 링 ℤ / nℤ에서 g의 곱셈 역수로 설정하고 z를 반환합니다. g와 n이 상대적으로 소수가 아닌 경우, g는 고리 ℤ / nℤ에 곱하기 역수가 없습니다. 이 경우 z는 변경되지 않고 리턴 값은 nil입니다.</target>
        </trans-unit>
        <trans-unit id="7a4fd0d385cd06f73e61243a029e76aa018a4f23" translate="yes" xml:space="preserve">
          <source>ModSqrt sets z to a square root of x mod p if such a square root exists, and returns z. The modulus p must be an odd prime. If x is not a square mod p, ModSqrt leaves z unchanged and returns nil. This function panics if p is not an odd integer.</source>
          <target state="translated">ModSqrt는 제곱근이 존재하면 z를 x mod p의 제곱근으로 설정하고 z를 반환합니다. 계수 p는 홀수 소수 여야합니다. x가 제곱 mod p가 아닌 경우 ModSqrt는 z를 변경하지 않고 그대로두고 nil을 반환합니다. p가 홀수가 아닌 경우이 함수는 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="aac634faa69d653814bcee88f0a5dfc61028be1b" translate="yes" xml:space="preserve">
          <source>ModTime returns the modification time in UTC using the legacy ModifiedDate and ModifiedTime fields.</source>
          <target state="translated">ModTime은 레거시 ModifiedDate 및 ModifiedTime 필드를 사용하여 수정 시간을 UTC로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="aa00a628811be04815f4dd62095833b576cd8722" translate="yes" xml:space="preserve">
          <source>Mode returns the permission and mode bits for the FileHeader.</source>
          <target state="translated">Mode는 FileHeader에 대한 권한 및 모드 비트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="28a0f960b89726a468e14a8ebdf922a21170bc22" translate="yes" xml:space="preserve">
          <source>Mode returns the rounding mode of x.</source>
          <target state="translated">Mode는 x의 반올림 모드를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6298c555b80608e54cb786bb4e651a115a6841d0" translate="yes" xml:space="preserve">
          <source>Mode values control the operation of New and NewFromFiles.</source>
          <target state="translated">모드 값은 New 및 NewFromFiles의 작업을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="8b4ea19087de0202d8e6a728b310de2dbb997d4d" translate="yes" xml:space="preserve">
          <source>Mode values control the operation of New.</source>
          <target state="translated">모드 값은 New의 작동을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="ee5a2d9bea8822761c2af443e30dd8b140094e31" translate="yes" xml:space="preserve">
          <source>Model can convert any Color to one from its own color model. The conversion may be lossy.</source>
          <target state="translated">모델은 모든 색상을 자체 색상 모델에서 색상으로 변환 할 수 있습니다. 변환이 손실 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b1b5b05fec2cd6d8e78c93f5a64f37706828f50" translate="yes" xml:space="preserve">
          <source>ModelFunc returns a Model that invokes f to implement the conversion.</source>
          <target state="translated">ModelFunc는 f를 호출하여 변환을 구현하는 Model을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5361e7791528a917952293ec5274927cfb3ce5f8" translate="yes" xml:space="preserve">
          <source>Models for the standard color types.</source>
          <target state="translated">표준 색상 유형에 대한 모델.</target>
        </trans-unit>
        <trans-unit id="4ab1036aa9ff79a5be9e4d8141cfacd5fbaebbcc" translate="yes" xml:space="preserve">
          <source>Modf</source>
          <target state="translated">Modf</target>
        </trans-unit>
        <trans-unit id="e56d540b050862c318d1aab05d9e382cf0a4c4af" translate="yes" xml:space="preserve">
          <source>Modf returns integer and fractional floating-point numbers that sum to f. Both values have the same sign as f.</source>
          <target state="translated">Modf는 f에 해당하는 정수 및 소수 부동 소수점 숫자를 반환합니다. 두 값 모두 f와 같은 부호를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="c8fdb64fd7614b420c244d4e876ef3defb57abcc" translate="yes" xml:space="preserve">
          <source>Modular exponentation of inputs of a particular size is not a cryptographically constant-time operation.</source>
          <target state="translated">특정 크기의 입력에 대한 모듈 식 지수는 암호 적으로 일정한 시간 연산이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="69af563fc3d8f6971f904cbb0080c2ef55ec0b2c" translate="yes" xml:space="preserve">
          <source>Modular exponentiation of inputs of a particular size is not a cryptographically constant-time operation.</source>
          <target state="translated">특정 크기의 입력에 대한 모듈 식 지수화는 암호 학적으로 일정한 시간 작업이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="2dd5487e8328e8658b359aa63c39e650ee5e1172" translate="yes" xml:space="preserve">
          <source>Module represents a module.</source>
          <target state="translated">모듈은 모듈을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b1156729972d424016ec9426afb303f681b9f79f" translate="yes" xml:space="preserve">
          <source>Monotonic Clocks</source>
          <target state="translated">단조로운 시계</target>
        </trans-unit>
        <trans-unit id="082bc378cd60e17a38d99898b21955299c5b60c8" translate="yes" xml:space="preserve">
          <source>Month</source>
          <target state="translated">Month</target>
        </trans-unit>
        <trans-unit id="66f2529dffac9fbc9ec633022a5f8b0bedc8c37f" translate="yes" xml:space="preserve">
          <source>Month returns the month of the year specified by t.</source>
          <target state="translated">Month는 t로 지정된 연도의 월을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="668403e4d2bd4eddcb9aed021f2a174eb200dc88" translate="yes" xml:space="preserve">
          <source>More control over the server's behavior is available by creating a custom Server:</source>
          <target state="translated">사용자 정의 서버를 작성하여 서버 작동을보다 세밀하게 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85e92ae26cba75c5b6d8d17d26d228885ce889bf" translate="yes" xml:space="preserve">
          <source>More intricate examples appear below.</source>
          <target state="translated">더 복잡한 예가 아래에 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="544eaf68f34e5f73c2388e2ae8096fe2204e2585" translate="yes" xml:space="preserve">
          <source>More reports whether there is another element in the current array or object being parsed.</source>
          <target state="translated">현재 배열 또는 구문 분석중인 객체에 다른 요소가 있는지 더보고합니다.</target>
        </trans-unit>
        <trans-unit id="90d58f1e96850d37632fc55c5c016f2a97fe1679" translate="yes" xml:space="preserve">
          <source>Most applications should not use the cipher suites in this list, and should only use those returned by CipherSuites.</source>
          <target state="translated">대부분의 응용 프로그램은이 목록에있는 암호 제품군을 사용하지 않아야하며 CipherSuites에서 반환 된 암호 제품군 만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="0f3ee8adfe02375a24e073f00bd7e8a1f885bbc4" translate="yes" xml:space="preserve">
          <source>Most callers should instead use Open, which transparently decompresses data and verifies checksums.</source>
          <target state="translated">대부분의 호출자는 대신 데이터를 투명하게 압축 해제하고 체크섬을 확인하는 Open을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="3646fecc5107fd2c20aa969acb21a6f56c99b136" translate="yes" xml:space="preserve">
          <source>Most clients are better served by the more efficient ReadDir method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="204dcf13599d817427dd2073f0e35f29dec05bc1" translate="yes" xml:space="preserve">
          <source>Most clients should use the runtime/pprof package instead of calling GoroutineProfile directly.</source>
          <target state="translated">대부분의 클라이언트는 GoroutineProfile을 직접 호출하는 대신 runtime / pprof 패키지를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="2d4c0e8a354401dd8233b4356c1a0bfb3bef2533" translate="yes" xml:space="preserve">
          <source>Most clients should use the runtime/pprof package instead of calling MutexProfile directly.</source>
          <target state="translated">대부분의 클라이언트는 MutexProfile을 직접 호출하는 대신 runtime / pprof 패키지를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="fd55cd96fc64e1ee33e5ec28f8d3ef1539755bd8" translate="yes" xml:space="preserve">
          <source>Most clients should use the runtime/pprof package instead of calling ThreadCreateProfile directly.</source>
          <target state="translated">대부분의 클라이언트는 ThreadCreateProfile을 직접 호출하는 대신 런타임 / pprof 패키지를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="646d3b37e5e676f43944b0bc1ef49ce31304c768" translate="yes" xml:space="preserve">
          <source>Most clients should use the runtime/pprof package or the testing package's -test.blockprofile flag instead of calling BlockProfile directly.</source>
          <target state="translated">대부분의 클라이언트는 BlockProfile을 직접 호출하는 대신 runtime / pprof 패키지 또는 테스트 패키지의 -test.blockprofile 플래그를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="fb5152386c9af905d8957add4efa5a79dbea3046" translate="yes" xml:space="preserve">
          <source>Most clients should use the runtime/pprof package or the testing package's -test.cpuprofile flag instead of calling SetCPUProfileRate directly.</source>
          <target state="translated">대부분의 클라이언트는 SetCPUProfileRate를 직접 호출하는 대신 runtime / pprof 패키지 또는 테스트 패키지의 -test.cpuprofile 플래그를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="cc35c049e953a9f16068abcc035a22ebd5b44d39" translate="yes" xml:space="preserve">
          <source>Most clients should use the runtime/pprof package or the testing package's -test.memprofile flag instead of calling MemProfile directly.</source>
          <target state="translated">대부분의 클라이언트는 MemProfile을 직접 호출하는 대신 runtime / pprof 패키지 또는 테스트 패키지의 -test.memprofile 플래그를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="4ec46c99b7f54aae4ce499a3028a52ae6552a566" translate="yes" xml:space="preserve">
          <source>Most code should use package sql.</source>
          <target state="translated">대부분의 코드는 sql 패키지를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="19ad74392792ed9739e1d28d7638006df3165986" translate="yes" xml:space="preserve">
          <source>Most users will open a database via a driver-specific connection helper function that returns a *DB. No database drivers are included in the Go standard library. See &lt;a href=&quot;https://golang.org/s/sqldrivers&quot;&gt;https://golang.org/s/sqldrivers&lt;/a&gt; for a list of third-party drivers.</source>
          <target state="translated">대부분의 사용자는 * DB를 반환하는 드라이버 별 연결 도우미 함수를 통해 데이터베이스를 엽니 다. Go 표준 라이브러리에는 데이터베이스 드라이버가 포함되어 있지 않습니다. 타사 드라이버 목록은 &lt;a href=&quot;https://golang.org/s/sqldrivers&quot;&gt;https://golang.org/s/sqldrivers&lt;/a&gt; 를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="6f91f314aaefda0dd307d2029c302761e8e26460" translate="yes" xml:space="preserve">
          <source>Most uses of this package need not call Handshake explicitly: the first Read or Write will call it automatically.</source>
          <target state="translated">이 패키지를 사용하는 대부분의 경우 Handshake를 명시 적으로 호출 할 필요는 없습니다. 첫 번째 Read 또는 Write는이를 자동으로 호출합니다.</target>
        </trans-unit>
        <trans-unit id="99ed633024d8dc0b448fbe281ca6b8177fe27c56" translate="yes" xml:space="preserve">
          <source>Move moves n % r.Len() elements backward (n &amp;lt; 0) or forward (n &amp;gt;= 0) in the ring and returns that ring element. r must not be empty.</source>
          <target state="translated">이동은 링에서 n % r.Len () 요소를 뒤로 (n &amp;lt;0) 또는 앞으로 (n&amp;gt; = 0) 이동하고 해당 링 요소를 반환합니다. r은 비워 둘 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9b69d844fd11e170cd47ef8ff2a97178038b339b" translate="yes" xml:space="preserve">
          <source>MoveAfter moves element e to its new position after mark. If e or mark is not an element of l, or e == mark, the list is not modified. The element and mark must not be nil.</source>
          <target state="translated">MoveAfter는 요소 e를 마크 뒤 새 위치로 이동합니다. e 또는 mark가 l의 요소가 아니거나 e == mark 인 경우 목록이 수정되지 않습니다. 요소와 마크는 0이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="33d96c6050800194a8407c20b5ca64f6846c7299" translate="yes" xml:space="preserve">
          <source>MoveBefore moves element e to its new position before mark. If e or mark is not an element of l, or e == mark, the list is not modified. The element and mark must not be nil.</source>
          <target state="translated">MoveBefore는 요소 e를 마크 이전의 새 위치로 이동합니다. e 또는 mark가 l의 요소가 아니거나 e == mark 인 경우 목록이 수정되지 않습니다. 요소와 마크는 0이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="48e25efa9d98fcd9ecb09e7fe7ed87eb426e273a" translate="yes" xml:space="preserve">
          <source>MoveToBack moves element e to the back of list l. If e is not an element of l, the list is not modified. The element must not be nil.</source>
          <target state="translated">MoveToBack은 요소 e를 목록 l의 뒤로 이동합니다. e가 l의 요소가 아닌 경우 목록이 수정되지 않습니다. 요소는 0이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="6f362d110c32c4c4500cf8d4c490f31132fbb839" translate="yes" xml:space="preserve">
          <source>MoveToFront moves element e to the front of list l. If e is not an element of l, the list is not modified. The element must not be nil.</source>
          <target state="translated">MoveToFront는 요소 e를 목록 l의 맨 앞으로 이동합니다. e가 l의 요소가 아닌 경우 목록이 수정되지 않습니다. 요소는 0이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="90114025b275cbc4bcd8b562c1a58b937341fdfb" translate="yes" xml:space="preserve">
          <source>Mul returns the full-width product of x and y: (hi, lo) = x * y with the product bits' upper half returned in hi and the lower half returned in lo.</source>
          <target state="translated">Mul은 x와 y의 전각 곱을 반환합니다 : (hi, lo) = x * y는 제품 비트의 상반부가 hi로, 하반부는 lo로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="26a6e266f6cfb3f2f503215e9850aa02f8f9da06" translate="yes" xml:space="preserve">
          <source>Mul returns the vector p*k.</source>
          <target state="translated">Mul은 벡터 p * k를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="da7ddc591d70c1b455e617b48abf92f18b455b2b" translate="yes" xml:space="preserve">
          <source>Mul sets z to the product x*y and returns z.</source>
          <target state="translated">Mul은 z를 곱 x * y로 설정하고 z를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="77d0b9f0608c4902ed59d2c704e92843cbc28318" translate="yes" xml:space="preserve">
          <source>Mul sets z to the rounded product x*y and returns z. Precision, rounding, and accuracy reporting are as for Add. Mul panics with ErrNaN if one operand is zero and the other operand an infinity. The value of z is undefined in that case.</source>
          <target state="translated">Mul은 z를 둥근 제품 x * y로 설정하고 z를 반환합니다. 정밀도, 반올림 및 정확도보고는 추가와 같습니다. 하나의 피연산자가 0이고 다른 피연산자가 무한대이면 ErrNaN으로 다중 패닉. 이 경우 z 값은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b861b19bddbd0bc8bab01f2fb9899e8f0de45d9e" translate="yes" xml:space="preserve">
          <source>Mul32 returns the 64-bit product of x and y: (hi, lo) = x * y with the product bits' upper half returned in hi and the lower half returned in lo.</source>
          <target state="translated">Mul32는 x와 y의 64 비트 곱을 반환합니다 : (hi, lo) = x * y는 제품 비트의 상반신이 hi로, 하반부는 lo로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a25ed66383b36d2221150102c89edba8efbb0c02" translate="yes" xml:space="preserve">
          <source>Mul64 returns the 128-bit product of x and y: (hi, lo) = x * y with the product bits' upper half returned in hi and the lower half returned in lo.</source>
          <target state="translated">Mul64는 x와 y의 128 비트 곱을 반환합니다. (hi, lo) = x * y는 제품 비트의 상반부가 hi로, 하반부는 lo로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="9b4ec4f00f8b7fc0f34cde307521a1856a53aa0b" translate="yes" xml:space="preserve">
          <source>MulRange sets z to the product of all integers in the range [a, b] inclusively and returns z. If a &amp;gt; b (empty range), the result is 1.</source>
          <target state="translated">MulRange는 z를 [a, b] 범위에있는 모든 정수의 곱으로 설정하고 z를 반환합니다. a&amp;gt; b (빈 범위) 인 경우 결과는 1입니다.</target>
        </trans-unit>
        <trans-unit id="9eaaace92dc7df7151a8f45536ad19d09279e182" translate="yes" xml:space="preserve">
          <source>MultiReader</source>
          <target state="translated">MultiReader</target>
        </trans-unit>
        <trans-unit id="5d860fccf2fdf207ce3f3ccf216ed942057c9707" translate="yes" xml:space="preserve">
          <source>MultiReader returns a Reader that's the logical concatenation of the provided input readers. They're read sequentially. Once all inputs have returned EOF, Read will return EOF. If any of the readers return a non-nil, non-EOF error, Read will return that error.</source>
          <target state="translated">MultiReader는 제공된 입력 판독기의 논리적 연결 인 Reader를 반환합니다. 순차적으로 읽습니다. 모든 입력이 EOF를 반환하면 Read는 EOF를 반환합니다. 판독기가 non-non, EOF 이외의 오류를 반환하면 Read는 해당 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4faad6c802b39e83086bf59c7e2903092d5a691b" translate="yes" xml:space="preserve">
          <source>MultiWriter</source>
          <target state="translated">MultiWriter</target>
        </trans-unit>
        <trans-unit id="0e1b7f58a5f86256f9545cb408ae583680594854" translate="yes" xml:space="preserve">
          <source>MultiWriter creates a writer that duplicates its writes to all the provided writers, similar to the Unix tee(1) command.</source>
          <target state="translated">MultiWriter는 Unix tee (1) 명령과 유사하게 제공된 모든 기록기에 기록을 복제하는 기록기를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="3688e77a9282752c7dda127e113710f59d4dafc0" translate="yes" xml:space="preserve">
          <source>MulticastAddrs returns a list of multicast, joined group addresses for a specific interface.</source>
          <target state="translated">MulticastAddrs는 특정 인터페이스에 대해 결합 된 멀티 캐스트 그룹 주소 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b9bb2b61e03ad9524ce2fff2bf8e39b44ea3373a" translate="yes" xml:space="preserve">
          <source>MultipartReader returns a MIME multipart reader if this is a multipart/form-data or a multipart/mixed POST request, else returns nil and an error. Use this function instead of ParseMultipartForm to process the request body as a stream.</source>
          <target state="translated">MultipartReader는 multipart / form-data 또는 multipart / mixed POST 요청 인 경우 MIME multipart reader를 반환하고, 그렇지 않으면 nil과 오류를 반환합니다. 요청 본문을 스트림으로 처리하려면 ParseMultipartForm 대신이 함수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a782cf6ce52ba3c0409a2a494107b5e5d1c07de1" translate="yes" xml:space="preserve">
          <source>Multiple example functions for a package/type/function/method may be provided by appending a distinct suffix to the name. The suffix must start with a lower-case letter.</source>
          <target state="translated">패키지 / 유형 / 함수 / 방법에 대한 복수의 예시적인 기능은 명칭에 별개의 접미사를 추가함으로써 제공 될 수있다. 접미사는 소문자로 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="97b40210f32960166bd52edfda4ec341de71235b" translate="yes" xml:space="preserve">
          <source>Multiple goroutines may invoke methods on a Conn simultaneously.</source>
          <target state="translated">여러 고로 틴은 Conn에서 동시에 메소드를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6556b625ec1c61ad052df5128208f619bcfcc88f" translate="yes" xml:space="preserve">
          <source>Multiple goroutines may invoke methods on a Listener simultaneously.</source>
          <target state="translated">다수의 고 루틴은 리스너에서 동시에 메소드를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d58239811314fdc4f9e0084cf7b627a6e3f8ff5f" translate="yes" xml:space="preserve">
          <source>Multiple goroutines may invoke methods on a PacketConn simultaneously.</source>
          <target state="translated">여러 고 루틴이 PacketConn에서 동시에 메서드를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e78e9f2f9df049dd02923df34377c4f53cba9951" translate="yes" xml:space="preserve">
          <source>Multiple invocations of this function will return the same value, so it can be used for equality checks and switch statements.</source>
          <target state="translated">이 함수를 여러 번 호출하면 동일한 값이 반환되므로 동등성 검사 및 switch 문에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df2c141b4f12a4ff075a8eeb676ff9cf5032e4dc" translate="yes" xml:space="preserve">
          <source>MultiplePackageError describes a directory containing multiple buildable Go source files for multiple packages.</source>
          <target state="translated">MultiplePackageError는 여러 패키지에 대해 여러 빌드 가능한 Go 소스 파일을 포함하는 디렉토리를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="79a3dc65878a83d5c3f20c9bd1c6028718af5b1b" translate="yes" xml:space="preserve">
          <source>Multistream controls whether the reader supports multistream files.</source>
          <target state="translated">멀티 스트림은 리더가 멀티 스트림 파일을 지원하는지 여부를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="5d72b823f6e2f60a18b59bcf20086228b774dfee" translate="yes" xml:space="preserve">
          <source>Must is a helper that wraps a call to a function returning (*Template, error) and panics if the error is non-nil. It is intended for use in variable initializations such as</source>
          <target state="translated">오류가 0이 아닌 경우 반환 함수 (* Template, error) 및 패닉에 대한 호출을 래핑하는 도우미 여야합니다. 다음과 같은 변수 초기화에 사용하기위한 것입니다</target>
        </trans-unit>
        <trans-unit id="a51f1ed56a509883e121438647786188d9af7d2f" translate="yes" xml:space="preserve">
          <source>MustCompile is like Compile but panics if the expression cannot be parsed. It simplifies safe initialization of global variables holding compiled regular expressions.</source>
          <target state="translated">MustCompile은 Compile과 비슷하지만 표현식을 구문 분석 할 수없는 경우 패닉 상태입니다. 컴파일 된 정규식을 보유하는 전역 변수의 안전한 초기화를 단순화합니다.</target>
        </trans-unit>
        <trans-unit id="9116a0a3a6e98be619745d64aa7d73bda9c8d13e" translate="yes" xml:space="preserve">
          <source>MustCompilePOSIX is like CompilePOSIX but panics if the expression cannot be parsed. It simplifies safe initialization of global variables holding compiled regular expressions.</source>
          <target state="translated">MustCompilePOSIX는 CompilePOSIX와 유사하지만 표현식을 구문 분석 할 수없는 경우 패닉 상태입니다. 컴파일 된 정규식을 보유하는 전역 변수의 안전한 초기화를 단순화합니다.</target>
        </trans-unit>
        <trans-unit id="3784bc24f8a3c7e8d169e2b4535e09805ebe5ca0" translate="yes" xml:space="preserve">
          <source>MutexProfile returns n, the number of records in the current mutex profile. If len(p) &amp;gt;= n, MutexProfile copies the profile into p and returns n, true. Otherwise, MutexProfile does not change p, and returns n, false.</source>
          <target state="translated">MutexProfile은 현재 뮤텍스 프로파일의 레코드 수인 n을 반환합니다. len (p)&amp;gt; = n 인 경우 MutexProfile은 프로파일을 p에 복사하고 n을 true로 리턴합니다. 그렇지 않으면 MutexProfile은 p를 변경하지 않고 n, false를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="5d847ec5889f3982ffb9b7ffa72ed90e47750577" translate="yes" xml:space="preserve">
          <source>NArg is the number of arguments remaining after flags have been processed.</source>
          <target state="translated">NArg는 플래그가 처리 된 후 남아있는 인수의 수입니다.</target>
        </trans-unit>
        <trans-unit id="2f24c1c2739257b059d4d3dc9321f1cdf1115063" translate="yes" xml:space="preserve">
          <source>NFlag returns the number of command-line flags that have been set.</source>
          <target state="translated">NFlag는 설정된 명령 줄 플래그 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="810e97bcf54f7c38d780b8018b94bedc96063ac9" translate="yes" xml:space="preserve">
          <source>NFlag returns the number of flags that have been set.</source>
          <target state="translated">NFlag는 설정된 플래그 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c725fb1ef92b939b16dd002af225b2de23e38031" translate="yes" xml:space="preserve">
          <source>NRGBA is an in-memory image whose At method returns color.NRGBA values.</source>
          <target state="translated">NRGBA는 At 메서드가 color.NRGBA 값을 반환하는 메모리 내 이미지입니다.</target>
        </trans-unit>
        <trans-unit id="d8bb0d248591faba7b18624bf05d5a4e94d4a0a2" translate="yes" xml:space="preserve">
          <source>NRGBA represents a non-alpha-premultiplied 32-bit color.</source>
          <target state="translated">NRGBA는 비 알파 미리 곱셈 된 32 비트 색상을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5b8e9eaa83b4e60710ae3746671221d4b97e37ff" translate="yes" xml:space="preserve">
          <source>NRGBA64 is an in-memory image whose At method returns color.NRGBA64 values.</source>
          <target state="translated">NRGBA64는 At 메서드가 color.NRGBA64 값을 반환하는 메모리 내 이미지입니다.</target>
        </trans-unit>
        <trans-unit id="0c537b2ac3425dc17a66dbbf5b63bd3a7a48fb29" translate="yes" xml:space="preserve">
          <source>NRGBA64 represents a non-alpha-premultiplied 64-bit color, having 16 bits for each of red, green, blue and alpha.</source>
          <target state="translated">NRGBA64는 빨강, 초록, 파랑 ​​및 알파 각각에 대해 16 비트를 갖는 비 알파 사전 곱셈 된 64 비트 색상을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2cacdaed348d8c69a0481b79dcd2e483e182ae7b" translate="yes" xml:space="preserve">
          <source>NType values; used in core files.</source>
          <target state="translated">N 형 값; 핵심 파일에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="dfe809819a7c3bc6a6cb826d8f87edea50d7df8a" translate="yes" xml:space="preserve">
          <source>NYCbCrA is an in-memory image of non-alpha-premultiplied Y'CbCr-with-alpha colors. A and AStride are analogous to the Y and YStride fields of the embedded YCbCr.</source>
          <target state="translated">NYCbCrA는 알파가 아닌 미리 곱셈 된 Y'CbCr- 알파 색상의 메모리 내 이미지입니다. A 및 AStride는 내장 된 YCbCr의 Y 및 YStride 필드와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="381ced7e52d37e0dab6bd72178c010245712478e" translate="yes" xml:space="preserve">
          <source>NYCbCrA represents a non-alpha-premultiplied Y'CbCr-with-alpha color, having 8 bits each for one luma, two chroma and one alpha component.</source>
          <target state="translated">NYCbCrA는 하나의 루마, 2 개의 크로마 및 1 개의 알파 성분에 대해 각각 8 비트를 갖는 알파가 아닌 미리 곱셈 된 Y'CbCr- 알파 컬러를 나타낸다.</target>
        </trans-unit>
        <trans-unit id="3ddf7ce6d18dffcfd157667c9d84e86a1c6b7d4e" translate="yes" xml:space="preserve">
          <source>NYCbCrAModel is the Model for non-alpha-premultiplied Y'CbCr-with-alpha colors.</source>
          <target state="translated">NYCbCrAModel은 알파가 아닌 미리 곱셈 된 Y'CbCr- 알파 색상에 대한 모델입니다.</target>
        </trans-unit>
        <trans-unit id="57d5b53b7b3ad276283b2d42d51634e430be6df3" translate="yes" xml:space="preserve">
          <source>NaN returns a complex &amp;ldquo;not-a-number&amp;rdquo; value.</source>
          <target state="translated">NaN은 복잡한 숫자가 아닌 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="01647cea0fd9639449467ddb347270a0682c015d" translate="yes" xml:space="preserve">
          <source>NaN returns an IEEE 754 &amp;ldquo;not-a-number&amp;rdquo; value.</source>
          <target state="translated">NaN은 IEEE 754 &quot;숫자가 아님&quot;값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="458abd2d58ca4f6a99a8329ebea64a0b18022e43" translate="yes" xml:space="preserve">
          <source>Name Resolution</source>
          <target state="translated">이름 확인</target>
        </trans-unit>
        <trans-unit id="ea688af26f8e22c900a79fc16d82ceab4193e65a" translate="yes" xml:space="preserve">
          <source>Name constraint validation follows the rules from RFC 5280, with the addition that DNS name constraints may use the leading period format defined for emails and URIs. When a constraint has a leading period it indicates that at least one additional label must be prepended to the constrained name to be considered valid.</source>
          <target state="translated">이름 제약 조건 유효성 검사는 RFC 5280의 규칙을 따르며 DNS 이름 제약 조건이 이메일 및 URI에 대해 정의 된 선행 마침표 형식을 사용할 수 있습니다. 제약 조건에 선행 마침표가있는 경우 유효한 것으로 간주 되려면 제약 된 이름 앞에 하나 이상의 추가 레이블이 추가되어야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="99409b3041e22d0d0c5a802c5fd9d08e77da5379" translate="yes" xml:space="preserve">
          <source>Name constraints in the intermediates will be applied to all names claimed in the chain, not just opts.DNSName. Thus it is invalid for a leaf to claim example.com if an intermediate doesn't permit it, even if example.com is not the name being validated. Note that DirectoryName constraints are not supported.</source>
          <target state="translated">중간체의 이름 제약은 opts.DNSName뿐만 아니라 체인에서 주장하는 모든 이름에 적용됩니다. 따라서 잎이 example.com이 유효한 이름이 아니더라도 중간에 허용되지 않으면 example.com의 소유권을 주장하는 것은 유효하지 않습니다. DirectoryName 제약 조건은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e4faca25c7d92ae57c0deecd43f083feb7d672a5" translate="yes" xml:space="preserve">
          <source>Name represents an X.509 distinguished name. This only includes the common elements of a DN. Note that Name is only an approximation of the X.509 structure. If an accurate representation is needed, asn1.Unmarshal the raw subject or issuer as an RDNSequence.</source>
          <target state="translated">이름은 X.509 고유 이름을 나타냅니다. 여기에는 DN의 공통 요소 만 포함됩니다. 이름은 X.509 구조의 근사치 일뿐입니다. 정확한 표현이 필요한 경우 asn1. 원시 주제 또는 발급자를 RDNSequence로 정렬 해제합니다.</target>
        </trans-unit>
        <trans-unit id="0fba782366c931b096922fa065c94888533271bf" translate="yes" xml:space="preserve">
          <source>Name represents an X.509 distinguished name. This only includes the common elements of a DN. When parsing, all elements are stored in Names and non-standard elements can be extracted from there. When marshaling, elements in ExtraNames are appended and override other values with the same OID.</source>
          <target state="translated">이름은 X.509 고유 이름을 나타냅니다. 여기에는 DN의 공통 요소 만 포함됩니다. 구문 분석 할 때 모든 요소가 이름에 저장되고 비표준 요소를 추출 할 수 있습니다. 마샬링 할 때 ExtraNames의 요소가 추가되고 동일한 OID로 다른 값을 재정의합니다.</target>
        </trans-unit>
        <trans-unit id="e3f01020dd86fefd968bc57f34e6cf3dc39dbcdc" translate="yes" xml:space="preserve">
          <source>Name resolution maps each identifier (ast.Ident) in the program to the language object (Object) it denotes. Use Info.{Defs,Uses,Implicits} for the results of name resolution.</source>
          <target state="translated">이름 확인은 프로그램의 각 식별자 (ast.Ident)를 나타내는 언어 개체 (Object)에 매핑합니다. 이름 확인 결과에 Info. {Defs, Uses, Implicits}를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="dff2bc150a13aad1afbb3a0e77b91c6f29404d25" translate="yes" xml:space="preserve">
          <source>Name returns the file name of file f as registered with AddFile.</source>
          <target state="translated">이름은 AddFile에 등록 된 파일 f의 파일 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dbf0685fdc3e1fc7383fb6378b40c72d45ba31cf" translate="yes" xml:space="preserve">
          <source>Name returns the name of basic type b.</source>
          <target state="translated">이름은 기본 유형의 이름을 반환합니다. b.</target>
        </trans-unit>
        <trans-unit id="8fcb1133e9348f92420cdfc4678a083c2132530b" translate="yes" xml:space="preserve">
          <source>Name returns the name of the file as presented to Open.</source>
          <target state="translated">이름은 Open에 표시되는 파일 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ddf8f3d9e671d5c8526b346806d1b0aee8900f60" translate="yes" xml:space="preserve">
          <source>Name returns the name of the flag set.</source>
          <target state="translated">이름은 플래그 세트의 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2302d490bb5c27edeb93f2429b3dd3925a94667d" translate="yes" xml:space="preserve">
          <source>Name returns the name of the function.</source>
          <target state="translated">이름은 함수의 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1e85527ce244650d2eef45c942c6fb4c49d00958" translate="yes" xml:space="preserve">
          <source>Name returns the name of the running test or benchmark.</source>
          <target state="translated">이름은 실행중인 테스트 또는 벤치 마크의 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ae31bd0a4e13087d9881916ed12efd37cc202962" translate="yes" xml:space="preserve">
          <source>Name returns the name of the template.</source>
          <target state="translated">이름은 템플릿의 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9d0afdb2756b72089c5803a1fea5a6f6af89abf2" translate="yes" xml:space="preserve">
          <source>Name returns the name or alias of the column.</source>
          <target state="translated">이름은 열의 이름 또는 별명을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="6fdae4adddc5e0ab59190994aa36753a8da75cde" translate="yes" xml:space="preserve">
          <source>Name returns the object's (package-local, unqualified) name.</source>
          <target state="translated">이름은 객체의 (패키지 로컬, 규정되지 않은) 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="715e38c6f54ac0414267875866ec7639f2185b6c" translate="yes" xml:space="preserve">
          <source>Name returns the package name.</source>
          <target state="translated">이름은 패키지 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f2f1501e711468701351739094e89f2faaa9754b" translate="yes" xml:space="preserve">
          <source>Name returns this profile's name, which can be passed to Lookup to reobtain the profile.</source>
          <target state="translated">Name은이 프로파일의 이름을 반환하며,이 프로파일은 Lookup으로 전달되어 프로파일을 다시 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07ef5638500e255787c53cfed76765c95ef368f8" translate="yes" xml:space="preserve">
          <source>Named character classes as character class elements:</source>
          <target state="translated">문자 클래스 요소로 명명 된 문자 클래스 :</target>
        </trans-unit>
        <trans-unit id="5214e3c70b9463e72846eff24f10e0e17205139c" translate="yes" xml:space="preserve">
          <source>Named provides a more concise way to create NamedArg values.</source>
          <target state="translated">Named는 NamedArg 값을 작성하는보다 간결한 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9f9c1c1ca0e676e9e2072afd4d97cad1c4edafd2" translate="yes" xml:space="preserve">
          <source>NamedValue holds both the value name and value.</source>
          <target state="translated">NamedValue는 값 이름과 값을 모두 보유합니다.</target>
        </trans-unit>
        <trans-unit id="c99f38d2678a853989d8a832348bdca952de6c49" translate="yes" xml:space="preserve">
          <source>NamedValueChecker may be optionally implemented by Conn or Stmt. It provides the driver more control to handle Go and database types beyond the default Values types allowed.</source>
          <target state="translated">NamedValueChecker는 선택적으로 Conn 또는 Stmt에 의해 구현 될 수 있습니다. 허용되는 기본 값 유형 이외의 Go 및 데이터베이스 유형을 처리하도록 드라이버에 더 많은 제어를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4abb0014fb99c3ea27630821804136f4a291ddd2" translate="yes" xml:space="preserve">
          <source>Names returns the scope's element names in sorted order.</source>
          <target state="translated">이름은 범위의 요소 이름을 정렬 된 순서로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3bc9b96acdd25f0e29a5d98a8eb3024f16d84408" translate="yes" xml:space="preserve">
          <source>Namespaced and data- attributes</source>
          <target state="translated">네임 스페이스 및 데이터 속성</target>
        </trans-unit>
        <trans-unit id="68be7148b1d69811d870e9714f9a627c5b3b1099" translate="yes" xml:space="preserve">
          <source>Naming a file dns_windows.go will cause it to be included only when building the package for Windows; similarly, math_386.s will be included only when building the package for 32-bit x86.</source>
          <target state="translated">dns_windows.go 파일의 이름을 지정하면 Windows 용 패키지를 빌드 할 때만 파일이 포함됩니다. 마찬가지로 math_386.s는 32 비트 x86 용 패키지를 빌드 할 때만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="4bf5d85dcbaccbe3002900f02f86f380a1080e28" translate="yes" xml:space="preserve">
          <source>Nano returns the time stored in ts as nanoseconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45aee9ac8768fce9beebcaf8f73e63c4ab9417be" translate="yes" xml:space="preserve">
          <source>Nano returns the time stored in tv as nanoseconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cabaa7d294786796f928e96fc93a4f221988121e" translate="yes" xml:space="preserve">
          <source>Nano returns ts as the number of nanoseconds elapsed since the Unix epoch.</source>
          <target state="translated">Nano는 유닉스 시대 이후로 경과 된 나노초 수로 ts를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7cc13f72d19e3af8ee9e16f480775aaded9f3087" translate="yes" xml:space="preserve">
          <source>Nano returns tv as the number of nanoseconds elapsed since the Unix epoch.</source>
          <target state="translated">Nano는 유닉스 시대 이후로 경과 한 나노초 수로 tv를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0e6c24671bd350d239a637f4eb004b1ac035f0f6" translate="yes" xml:space="preserve">
          <source>Nanosecond returns the nanosecond offset within the second specified by t, in the range [0, 999999999].</source>
          <target state="translated">나노초는 [0, 999999999] 범위에서 t로 지정된 초 이내에 나노초 오프셋을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9254412c6c417a32ffd67afde8a4d3f64458a58f" translate="yes" xml:space="preserve">
          <source>Nanoseconds returns the duration as an integer nanosecond count.</source>
          <target state="translated">나노초는 지속 시간을 정수 나노초 카운트로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ba032ae40abdc5925e0860a082adf4aba20cf4c6" translate="yes" xml:space="preserve">
          <source>Neg sets z to -x and returns z.</source>
          <target state="translated">Neg는 z를 -x로 설정하고 z를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="381b641c01f8a09410b41524ec6b9c342099d866" translate="yes" xml:space="preserve">
          <source>Neg sets z to the (possibly rounded) value of x with its sign negated, and returns z.</source>
          <target state="translated">Neg는 z를 부호가 무시 된 x의 (올림 된) 값으로 설정하고 z를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="8646ff662d17d59189bbe1c09e1b45ec2fcbe881" translate="yes" xml:space="preserve">
          <source>Nested template definitions</source>
          <target state="translated">중첩 템플릿 정의</target>
        </trans-unit>
        <trans-unit id="d8c5cfb403999ea3c1717d789cd51587c786bc53" translate="yes" xml:space="preserve">
          <source>NetlinkMessage represents a netlink message.</source>
          <target state="translated">NetlinkMessage는 netlink 메시지를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9c4870d25f2151dc7bae14a92d6848398da82d87" translate="yes" xml:space="preserve">
          <source>NetlinkRIB returns routing information base, as known as RIB, which consists of network facility information, states and parameters.</source>
          <target state="translated">NetlinkRIB는 RIB로 알려진 라우팅 정보 기반을 반환하며, 이는 네트워크 기능 정보, 상태 및 매개 변수로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="602233e97016bb5f79aa0bd9f5a926d8f7889c93" translate="yes" xml:space="preserve">
          <source>NetlinkRouteAttr represents a netlink route attribute.</source>
          <target state="translated">NetlinkRouteAttr은 netlink 경로 속성을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="44279944636fb5149ee9e75b524255aa96e79a4e" translate="yes" xml:space="preserve">
          <source>NetlinkRouteRequest represents a request message to receive routing and link states from the kernel.</source>
          <target state="translated">NetlinkRouteRequest는 커널로부터 라우팅 및 링크 상태를 수신하기위한 요청 메시지를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="884a4650baee52e272bb3c5efceff09f71b0dc8c" translate="yes" xml:space="preserve">
          <source>Network returns the address's network name, &quot;ip&quot;.</source>
          <target state="translated">네트워크는 주소의 네트워크 이름 &quot;ip&quot;를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="872aebe8ec9741bc61a3685b3731dbde3529008c" translate="yes" xml:space="preserve">
          <source>Network returns the address's network name, &quot;ip+net&quot;.</source>
          <target state="translated">네트워크는 주소의 네트워크 이름 &quot;ip + net&quot;을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fa465c71127a452dc67c99401e7bc2d64148685d" translate="yes" xml:space="preserve">
          <source>Network returns the address's network name, &quot;tcp&quot;.</source>
          <target state="translated">네트워크는 주소의 네트워크 이름 &quot;tcp&quot;를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="985257f66305f39d2139512f1ac004ba3741bdd6" translate="yes" xml:space="preserve">
          <source>Network returns the address's network name, &quot;udp&quot;.</source>
          <target state="translated">네트워크는 주소의 네트워크 이름 &quot;udp&quot;를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="85eeab19d1e5738f817203c5a4d550375f022dc2" translate="yes" xml:space="preserve">
          <source>Network returns the address's network name, &quot;unix&quot;, &quot;unixgram&quot; or &quot;unixpacket&quot;.</source>
          <target state="translated">네트워크는 주소의 네트워크 이름 &quot;unix&quot;, &quot;unixgram&quot;또는 &quot;unixpacket&quot;을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6403f2b7eb2aaafe6de34cbf2a029b01afebc512" translate="yes" xml:space="preserve">
          <source>New</source>
          <target state="translated">New</target>
        </trans-unit>
        <trans-unit id="73e705a3151bc08fd1addfd7992ec83ec85bc2d3" translate="yes" xml:space="preserve">
          <source>New (Errorf)</source>
          <target state="translated">새로운 (Errorf)</target>
        </trans-unit>
        <trans-unit id="ce9f1f28f9b789d29a4ccd4ff058458cc3933476" translate="yes" xml:space="preserve">
          <source>New (File)</source>
          <target state="translated">새로운 파일)</target>
        </trans-unit>
        <trans-unit id="13a673772e81bed6fd77076f80c7ff1f6ee89e61" translate="yes" xml:space="preserve">
          <source>New allocates a new HTML template associated with the given one and with the same delimiters. The association, which is transitive, allows one template to invoke another with a {{template}} action.</source>
          <target state="translated">새로 만들기는 지정된 것과 동일한 구분 기호를 사용하여 새 HTML 템플릿을 할당합니다. 전 이적 연관은 한 템플리트가 {{template}} 조치로 다른 템플리트를 호출 할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="1c98d75d213247ac29168d2da24b2789a4dbb7a8" translate="yes" xml:space="preserve">
          <source>New allocates a new HTML template with the given name.</source>
          <target state="translated">New는 주어진 이름으로 새로운 HTML 템플릿을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="34bc55c1fb0c505ee8f76b87c91bd2fc06fc027b" translate="yes" xml:space="preserve">
          <source>New allocates a new parse tree with the given name.</source>
          <target state="translated">New는 주어진 이름으로 새로운 구문 분석 트리를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="685d42b22fd5f12d0d18a35ac55a1b6c69615a8a" translate="yes" xml:space="preserve">
          <source>New allocates a new, undefined template associated with the given one and with the same delimiters. The association, which is transitive, allows one template to invoke another with a {{template}} action.</source>
          <target state="translated">새로 만들기는 지정된 템플릿과 동일한 구분 기호와 관련된 새 정의되지 않은 템플릿을 할당합니다. 전 이적 연관은 한 템플리트가 {{template}} 조치로 다른 템플리트를 호출 할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="1bfbe44c21200e9acb8918513405e990a5ad64ec" translate="yes" xml:space="preserve">
          <source>New allocates a new, undefined template with the given name.</source>
          <target state="translated">새로 만들기는 주어진 이름으로 정의되지 않은 새 템플릿을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="d58e7e7be4ff87f86b4026a755b5a08e8395893d" translate="yes" xml:space="preserve">
          <source>New changes in the system cert pool might not be reflected in subsequent calls.</source>
          <target state="translated">시스템 인증서 풀의 새로운 변경 사항은 후속 호출에 반영되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8732c118b0cc7bc660fa4e5273983e4bed17a5c" translate="yes" xml:space="preserve">
          <source>New computes the package documentation for the given package AST. New takes ownership of the AST pkg and may edit or overwrite it.</source>
          <target state="translated">New는 주어진 패키지 AST에 대한 패키지 문서를 계산합니다. New는 AST pkg의 소유권을 가지며이를 편집하거나 덮어 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc0e34f3cf5ad3fd313178553550b414b18c18ba" translate="yes" xml:space="preserve">
          <source>New computes the package documentation for the given package AST. New takes ownership of the AST pkg and may edit or overwrite it. To have the Examples fields populated, use NewFromFiles and include the package's _test.go files.</source>
          <target state="translated">New는 주어진 패키지 AST에 대한 패키지 문서를 계산합니다. New는 AST 패키지의 소유권을 가져 와서 편집하거나 덮어 쓸 수 있습니다. 예제 필드를 채우려면 NewFromFiles를 사용하고 패키지의 _test.go 파일을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="42a02872376b9cd15170d6472cf48d2f256d4269" translate="yes" xml:space="preserve">
          <source>New creates a new Index for data. Index creation time is O(N) for N = len(data).</source>
          <target state="translated">새로 작성하면 데이터에 대한 새 색인이 작성됩니다. 인덱스 생성 시간은 N = len (data)에 대해 O (N)입니다.</target>
        </trans-unit>
        <trans-unit id="848e8a805c0a023e8c5b587ab5386886eded5422" translate="yes" xml:space="preserve">
          <source>New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties.</source>
          <target state="translated">새로 만들기는 새 로거를 만듭니다. out 변수는 로그 데이터가 기록 될 대상을 설정합니다. 접두사는 생성 된 각 로그 줄의 시작 부분 또는 Lmsgprefix 플래그가 제공된 경우 로그 헤더 뒤에 나타납니다. flag 인수는 로깅 속성을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="1938bcca0d3c4801a22481ce59e7278f4b6da953" translate="yes" xml:space="preserve">
          <source>New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line. The flag argument defines the logging properties.</source>
          <target state="translated">새로 작성하면 새 로거가 작성됩니다. out 변수는 로그 데이터가 기록 될 대상을 설정합니다. 접두사는 생성 된 각 로그 줄의 시작 부분에 나타납니다. 플래그 인수는 로깅 특성을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="9a296c49d13ddf053bb1930fb55493ded12e0b12" translate="yes" xml:space="preserve">
          <source>New creates a new hash.Hash32 computing the CRC-32 checksum using the polynomial represented by the Table. Its Sum method will lay the value out in big-endian byte order. The returned Hash32 also implements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to marshal and unmarshal the internal state of the hash.</source>
          <target state="translated">New는 새로운 해시를 생성합니다. Table로 표시되는 다항식을 사용하여 CRC-32 체크섬을 계산합니다. Sum 메소드는 값을 빅 엔디안 바이트 순서로 배치합니다. 반환 된 Hash32는 해시의 내부 상태를 마샬링하고 언 마샬링하기 위해 encoding.BinaryMarshaler 및 encoding.BinaryUnmarshaler도 구현합니다.</target>
        </trans-unit>
        <trans-unit id="f96eb28144daf2fb90bf412860be6e76ca52cf10" translate="yes" xml:space="preserve">
          <source>New creates a new hash.Hash64 computing the CRC-64 checksum using the polynomial represented by the Table. Its Sum method will lay the value out in big-endian byte order. The returned Hash64 also implements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to marshal and unmarshal the internal state of the hash.</source>
          <target state="translated">New는 새로운 해시를 생성합니다. Table로 표시되는 다항식을 사용하여 CRC-64 체크섬을 계산합니다. Sum 메소드는 값을 빅 엔디안 바이트 순서로 배치합니다. 반환 된 Hash64는 해시의 내부 상태를 마샬링하고 마샬링 해제하기 위해 encoding.BinaryMarshaler 및 encoding.BinaryUnmarshaler도 구현합니다.</target>
        </trans-unit>
        <trans-unit id="44ec7b7b536da273869e89c5cb90df2959fd9688" translate="yes" xml:space="preserve">
          <source>New creates a ring of n elements.</source>
          <target state="translated">새로 만들기는 n 개의 요소의 고리를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="e7fd8b4c480fbc496999332eaae2de8518c1f830" translate="yes" xml:space="preserve">
          <source>New establishes a new connection to the system log daemon. Each write to the returned writer sends a log message with the given priority (a combination of the syslog facility and severity) and prefix tag. If tag is empty, the os.Args[0] is used.</source>
          <target state="translated">새로 작성하면 시스템 로그 디먼에 대한 새 연결이 설정됩니다. 리턴 된 기록기에 대한 각 쓰기는 주어진 우선 순위 (syslog 기능과 심각도의 조합) 및 접 두부 태그가있는 로그 메시지를 보냅니다. 태그가 비어 있으면 os.Args [0]이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2c433bff47e0e23c62ed805b07cbec0f2f0b6f46" translate="yes" xml:space="preserve">
          <source>New returns a Value representing a pointer to a new zero value for the specified type. That is, the returned Value's Type is PtrTo(typ).</source>
          <target state="translated">New는 지정된 유형의 새 0 값에 대한 포인터를 나타내는 Value를 반환합니다. 즉, 반환 된 Value의 Type은 PtrTo (typ)입니다.</target>
        </trans-unit>
        <trans-unit id="0c3bbfe7ec852d2a1508f7c286818c11369b8298" translate="yes" xml:space="preserve">
          <source>New returns a new Data object initialized from the given parameters. Rather than calling this function directly, clients should typically use the DWARF method of the File type of the appropriate package debug/elf, debug/macho, or debug/pe.</source>
          <target state="translated">New는 주어진 매개 변수에서 초기화 된 새로운 Data 객체를 반환합니다. 클라이언트는이 함수를 직접 호출하는 대신 일반적으로 적절한 패키지 디버그 / elf, 디버그 / 마초 또는 디버그 / pe의 파일 유형의 DWARF 메소드를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="c20d7d89f2e0839ea2c75a738970b383d37ac73d" translate="yes" xml:space="preserve">
          <source>New returns a new HMAC hash using the given hash.Hash type and key. New functions like sha256.New from crypto/sha256 can be used as h. h must return a new Hash every time it is called. Note that unlike other hash implementations in the standard library, the returned Hash does not implement encoding.BinaryMarshaler or encoding.BinaryUnmarshaler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34063232a48f53eca99c828d036ef36cf5de37bb" translate="yes" xml:space="preserve">
          <source>New returns a new HMAC hash using the given hash.Hash type and key. Note that unlike other hash implementations in the standard library, the returned Hash does not implement encoding.BinaryMarshaler or encoding.BinaryUnmarshaler.</source>
          <target state="translated">New는 주어진 hash.Hash 유형과 키를 사용하여 새로운 HMAC 해시를 반환합니다. 표준 라이브러리의 다른 해시 구현과 달리 반환 된 Hash는 encoding.BinaryMarshaler 또는 encoding.BinaryUnmarshaler를 구현하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dae1d45948f3340a826a534080ea715da59576dc" translate="yes" xml:space="preserve">
          <source>New returns a new Rand that uses random values from src to generate other random values.</source>
          <target state="translated">New는 src에서 임의의 값을 사용하여 다른 임의의 값을 생성하는 새 랜드를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="99c2c428e0dc030c03d2e8b41267ed3ddbe36dfb" translate="yes" xml:space="preserve">
          <source>New returns a new cookie jar. A nil *Options is equivalent to a zero Options.</source>
          <target state="translated">New는 새로운 쿠키 항아리를 반환합니다. nil * Options는 제로 Options와 같습니다.</target>
        </trans-unit>
        <trans-unit id="1f821272946e1801b5f1d4a05a86314806248536" translate="yes" xml:space="preserve">
          <source>New returns a new hash.Hash calculating the given hash function. New panics if the hash function is not linked into the binary.</source>
          <target state="translated">New는 새로운 해시를 반환합니다. 해시는 주어진 해시 함수를 계산합니다. 해시 함수가 바이너리에 연결되지 않은 경우 새로운 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1098b04617924fcea48eac93732552bb3d10a9b9" translate="yes" xml:space="preserve">
          <source>New returns a new hash.Hash computing the MD5 checksum. The Hash also implements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to marshal and unmarshal the internal state of the hash.</source>
          <target state="translated">New는 새로운 해시를 반환합니다. MD5 체크섬을 계산하는 해시. 해시는 또한 해시의 내부 상태를 마샬링하고 언 마샬링하기 위해 encoding.BinaryMarshaler 및 encoding.BinaryUnmarshaler를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="f0a16128a32aa274883c639054d37ccdc6937e39" translate="yes" xml:space="preserve">
          <source>New returns a new hash.Hash computing the SHA-512 checksum.</source>
          <target state="translated">New는 새로운 해시를 반환합니다. SHA-512 체크섬을 계산하는 해시.</target>
        </trans-unit>
        <trans-unit id="cf1f289ea19766f37df0d90899ff5c24c8ae2c4a" translate="yes" xml:space="preserve">
          <source>New returns a new hash.Hash computing the SHA1 checksum. The Hash also implements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to marshal and unmarshal the internal state of the hash.</source>
          <target state="translated">New는 새로운 해시를 반환합니다. SHA1 체크섬을 계산하는 해시. 해시는 또한 해시의 내부 상태를 마샬링하고 언 마샬링하기 위해 encoding.BinaryMarshaler 및 encoding.BinaryUnmarshaler를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="4fd916c9b4b6d94508616e145a5d3f06d397cd5d" translate="yes" xml:space="preserve">
          <source>New returns a new hash.Hash computing the SHA256 checksum. The Hash also implements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to marshal and unmarshal the internal state of the hash.</source>
          <target state="translated">New는 새로운 해시를 반환합니다. SHA256 체크섬을 계산하는 해시. 해시는 또한 해시의 내부 상태를 마샬링하고 언 마샬링하기 위해 encoding.BinaryMarshaler 및 encoding.BinaryUnmarshaler를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="f8209c7edf904061031f392b03dfd5924df101b5" translate="yes" xml:space="preserve">
          <source>New returns a new hash.Hash32 computing the Adler-32 checksum. Its Sum method will lay the value out in big-endian byte order. The returned Hash32 also implements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to marshal and unmarshal the internal state of the hash.</source>
          <target state="translated">New는 새로운 해시를 반환합니다. Adler-32 체크섬을 계산하는 Hash32. Sum 메소드는 값을 빅 엔디안 바이트 순서로 배치합니다. 반환 된 Hash32는 해시의 내부 상태를 마샬링하고 언 마샬링하기 위해 encoding.BinaryMarshaler 및 encoding.BinaryUnmarshaler도 구현합니다.</target>
        </trans-unit>
        <trans-unit id="e84f60f6e65d95fd4ece96b0004a9de85df6b343" translate="yes" xml:space="preserve">
          <source>New returns an error that formats as the given text. Each call to New returns a distinct error value even if the text is identical.</source>
          <target state="translated">새로 작성은 주어진 텍스트로 형식화되는 오류를 리턴합니다. 텍스트가 동일하더라도 New를 호출 할 때마다 고유 한 오류 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="2d8951b361a0209c54ff9386028d34a39773602f" translate="yes" xml:space="preserve">
          <source>New returns an initialized list.</source>
          <target state="translated">New는 초기화 된 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5801fe069c8fe2aaa55fda0624f44928b4775b87" translate="yes" xml:space="preserve">
          <source>New uses JavaScript's &quot;new&quot; operator with value v as constructor and the given arguments. It panics if v is not a JavaScript function. The arguments get mapped to JavaScript values according to the ValueOf function.</source>
          <target state="translated">New는 생성자와 주어진 인수로 값 v를 가진 JavaScript의 &quot;new&quot;연산자를 사용합니다. v가 JavaScript 함수가 아닌 경우 패닉 상태가됩니다. 인수는 ValueOf 함수에 따라 JavaScript 값에 맵핑됩니다.</target>
        </trans-unit>
        <trans-unit id="de47e55b8079b059389f17b105e9ffd1afb3a3e3" translate="yes" xml:space="preserve">
          <source>New128 returns a new 128-bit FNV-1 hash.Hash. Its Sum method will lay the value out in big-endian byte order.</source>
          <target state="translated">New128은 새로운 128 비트 FNV-1 해시를 반환합니다. Sum 메소드는 값을 빅 엔디안 바이트 순서로 배치합니다.</target>
        </trans-unit>
        <trans-unit id="a8005a100f6b39010fda63d549052f17d08741bd" translate="yes" xml:space="preserve">
          <source>New128a returns a new 128-bit FNV-1a hash.Hash. Its Sum method will lay the value out in big-endian byte order.</source>
          <target state="translated">New128a는 새로운 128 비트 FNV-1a 해시를 반환합니다. Sum 메소드는 값을 빅 엔디안 바이트 순서로 배치합니다.</target>
        </trans-unit>
        <trans-unit id="0ce753ca8c15a0a1b2e753ae81ad1104c1644498" translate="yes" xml:space="preserve">
          <source>New224 returns a new hash.Hash computing the SHA224 checksum.</source>
          <target state="translated">New224는 새 해시를 반환하고 SHA224 체크섬을 계산하는 해시입니다.</target>
        </trans-unit>
        <trans-unit id="ccc0f5023730b0e5ae85216a310b3047f4aa8ea2" translate="yes" xml:space="preserve">
          <source>New32 returns a new 32-bit FNV-1 hash.Hash. Its Sum method will lay the value out in big-endian byte order.</source>
          <target state="translated">New32는 새로운 32 비트 FNV-1 해시를 반환합니다. Sum 메소드는 값을 빅 엔디안 바이트 순서로 배치합니다.</target>
        </trans-unit>
        <trans-unit id="d56753001efd2485e723a8e5a73fff58d273b67c" translate="yes" xml:space="preserve">
          <source>New32a returns a new 32-bit FNV-1a hash.Hash. Its Sum method will lay the value out in big-endian byte order.</source>
          <target state="translated">New32a는 새로운 32 비트 FNV-1a 해시를 반환합니다. Sum 메소드는 값을 빅 엔디안 바이트 순서로 배치합니다.</target>
        </trans-unit>
        <trans-unit id="7d5d99bcf25b2336b4de3cdadf8a35eaf7a0c199" translate="yes" xml:space="preserve">
          <source>New384 returns a new hash.Hash computing the SHA-384 checksum.</source>
          <target state="translated">New384는 새로운 해시를 반환하고 SHA-384 체크섬을 계산하는 해시입니다.</target>
        </trans-unit>
        <trans-unit id="4b7f283752df73a2e87a9802891e3f0dd0c8d4d7" translate="yes" xml:space="preserve">
          <source>New512_224 returns a new hash.Hash computing the SHA-512/224 checksum.</source>
          <target state="translated">New512_224는 새 해시를 반환합니다. SHA-512 / 224 체크섬을 계산하는 해시.</target>
        </trans-unit>
        <trans-unit id="825abc60343f43e649b2364900655dff3568736f" translate="yes" xml:space="preserve">
          <source>New512_256 returns a new hash.Hash computing the SHA-512/256 checksum.</source>
          <target state="translated">New512_256은 새로운 해시를 반환합니다. SHA-512 / 256 체크섬을 계산하는 해시.</target>
        </trans-unit>
        <trans-unit id="d87077707d6ea0d456a51c30f664d7873c8bd355" translate="yes" xml:space="preserve">
          <source>New64 returns a new 64-bit FNV-1 hash.Hash. Its Sum method will lay the value out in big-endian byte order.</source>
          <target state="translated">New64는 새로운 64 비트 FNV-1 해시를 반환합니다. Sum 메소드는 값을 빅 엔디안 바이트 순서로 배치합니다.</target>
        </trans-unit>
        <trans-unit id="46dd6ddaccb45d3f0be1865973ec33eaa9f63cd3" translate="yes" xml:space="preserve">
          <source>New64a returns a new 64-bit FNV-1a hash.Hash. Its Sum method will lay the value out in big-endian byte order.</source>
          <target state="translated">New64a는 새로운 64 비트 FNV-1a 해시를 반환합니다. Sum 메소드는 값을 빅 엔디안 바이트 순서로 배치합니다.</target>
        </trans-unit>
        <trans-unit id="7b22f1177470c7c4e87fe25b4cd79c1fd84c6501" translate="yes" xml:space="preserve">
          <source>NewAlpha returns a new Alpha image with the given bounds.</source>
          <target state="translated">NewAlpha는 주어진 범위를 가진 새로운 알파 이미지를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="add0bb0be61493133a58e39dd7700e6c9889401b" translate="yes" xml:space="preserve">
          <source>NewAlpha16 returns a new Alpha16 image with the given bounds.</source>
          <target state="translated">NewAlpha16은 주어진 범위를 가진 새로운 Alpha16 이미지를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4c61d8963b5a530bd472131f346eba16878a4408" translate="yes" xml:space="preserve">
          <source>NewArray returns a new array type for the given element type and length. A negative length indicates an unknown length.</source>
          <target state="translated">NewArray는 주어진 요소 유형과 길이에 대해 새로운 배열 유형을 반환합니다. 음수 길이는 알 수없는 길이를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="638c31aba3c5c6f8398df36fb530211241e94c4c" translate="yes" xml:space="preserve">
          <source>NewAt returns a Value representing a pointer to a value of the specified type, using p as that pointer.</source>
          <target state="translated">NewAt는 p를 해당 포인터로 사용하여 지정된 유형의 값에 대한 포인터를 나타내는 Value를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="72dec367b963904f8628c7bf12ee4335879a75b8" translate="yes" xml:space="preserve">
          <source>NewBuffer creates and initializes a new Buffer using buf as its initial contents. The new Buffer takes ownership of buf, and the caller should not use buf after this call. NewBuffer is intended to prepare a Buffer to read existing data. It can also be used to set the initial size of the internal buffer for writing. To do that, buf should have the desired capacity but a length of zero.</source>
          <target state="translated">NewBuffer는 buf를 초기 내용으로 사용하여 새로운 버퍼를 생성하고 초기화합니다. 새로운 버퍼는 buf의 소유권을 가지며 호출자는이 호출 후에 buf를 사용해서는 안됩니다. NewBuffer는 기존 데이터를 읽을 수있는 버퍼를 준비하기위한 것입니다. 또한 쓰기를위한 내부 버퍼의 초기 크기를 설정하는 데 사용될 수도 있습니다. 이를 위해 buf는 원하는 용량을 가져야하지만 길이는 0입니다.</target>
        </trans-unit>
        <trans-unit id="ed5f25f81fed45774081165b1641415b15da1746" translate="yes" xml:space="preserve">
          <source>NewBufferString creates and initializes a new Buffer using string s as its initial contents. It is intended to prepare a buffer to read an existing string.</source>
          <target state="translated">NewBufferString은 문자열 s를 초기 내용으로 사용하여 새 버퍼를 작성하고 초기화합니다. 기존 문자열을 읽을 수 있도록 버퍼를 준비하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="22844417cd1bd7e56381df290ad9aba37327ed60" translate="yes" xml:space="preserve">
          <source>NewCBCDecrypter</source>
          <target state="translated">NewCBCDecrypter</target>
        </trans-unit>
        <trans-unit id="ca52eb6c91f944ba65ea2ffb0b84fcc2a10abe90" translate="yes" xml:space="preserve">
          <source>NewCBCDecrypter returns a BlockMode which decrypts in cipher block chaining mode, using the given Block. The length of iv must be the same as the Block's block size and must match the iv used to encrypt the data.</source>
          <target state="translated">NewCBCDecrypter는 주어진 블록을 사용하여 암호 블록 체인 모드에서 해독하는 BlockMode를 반환합니다. iv의 길이는 블록의 블록 크기와 같아야하며 데이터를 암호화하는 데 사용 된 iv와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="255e7115ae5f4d3fbd66659d8c19d19341701776" translate="yes" xml:space="preserve">
          <source>NewCBCEncrypter</source>
          <target state="translated">NewCBCEncrypter</target>
        </trans-unit>
        <trans-unit id="fa88ee5beeb923f46e28b0b6307e4efcac6244ff" translate="yes" xml:space="preserve">
          <source>NewCBCEncrypter returns a BlockMode which encrypts in cipher block chaining mode, using the given Block. The length of iv must be the same as the Block's block size.</source>
          <target state="translated">NewCBCEncrypter는 주어진 블록을 사용하여 암호 블록 체인 모드로 암호화하는 BlockMode를 반환합니다. iv의 길이는 블록의 블록 크기와 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="38ff31a554e5558a01b8168178cf0796b7209a44" translate="yes" xml:space="preserve">
          <source>NewCFBDecrypter</source>
          <target state="translated">NewCFBDecrypter</target>
        </trans-unit>
        <trans-unit id="2d168991a51faf9df3fede3ceed6622acdae5d65" translate="yes" xml:space="preserve">
          <source>NewCFBDecrypter returns a Stream which decrypts with cipher feedback mode, using the given Block. The iv must be the same length as the Block's block size.</source>
          <target state="translated">NewCFBDecrypter는 주어진 블록을 사용하여 암호 피드백 모드로 해독하는 Stream을 반환합니다. iv의 길이는 블록의 블록 크기와 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="08b4648ba8de6f7a55002e90d7740de77aaee124" translate="yes" xml:space="preserve">
          <source>NewCFBEncrypter</source>
          <target state="translated">NewCFBEncrypter</target>
        </trans-unit>
        <trans-unit id="46ae2754dd56eaa723f258dcc13d30b6a837033a" translate="yes" xml:space="preserve">
          <source>NewCFBEncrypter returns a Stream which encrypts with cipher feedback mode, using the given Block. The iv must be the same length as the Block's block size.</source>
          <target state="translated">NewCFBEncrypter는 주어진 블록을 사용하여 암호 피드백 모드로 암호화하는 스트림을 반환합니다. iv의 길이는 블록의 블록 크기와 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="253cccaa3711561810055bfc51a9b95d2ac7b353" translate="yes" xml:space="preserve">
          <source>NewCMYK returns a new CMYK image with the given bounds.</source>
          <target state="translated">NewCMYK는 주어진 범위를 가진 새로운 CMYK 이미지를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f23a2508c9195bfe11e43b2f877a2121ff4896e8" translate="yes" xml:space="preserve">
          <source>NewCTR</source>
          <target state="translated">NewCTR</target>
        </trans-unit>
        <trans-unit id="48cf25f578fd7e4d9bde53a1056264acc0f6565d" translate="yes" xml:space="preserve">
          <source>NewCTR returns a Stream which encrypts/decrypts using the given Block in counter mode. The length of iv must be the same as the Block's block size.</source>
          <target state="translated">NewCTR은 카운터 모드에서 지정된 블록을 사용하여 암호화 / 암호 해독하는 스트림을 반환합니다. iv의 길이는 블록의 블록 크기와 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="78b43a9ea76afd66f0e904c5af7000251dc2615e" translate="yes" xml:space="preserve">
          <source>NewCertPool returns a new, empty CertPool.</source>
          <target state="translated">NewCertPool은 비어있는 새 CertPool을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="24df68fca6c4873d326ba2cccc1b01b5610f3e8e" translate="yes" xml:space="preserve">
          <source>NewChan returns a new channel type for the given direction and element type.</source>
          <target state="translated">NewChan은 주어진 방향과 요소 유형에 대한 새 채널 유형을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="62fa4bf0653f8c5396d1118a3de960d9396357d1" translate="yes" xml:space="preserve">
          <source>NewChecker returns a new Checker instance for a given package. Package files may be added incrementally via checker.Files.</source>
          <target state="translated">NewChecker는 주어진 패키지에 대한 새로운 Checker 인스턴스를 반환합니다. 패키지 파일은 checker.Files를 통해 점진적으로 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2380ca2f8a09151f6aa44494bd0336745a8e73ba" translate="yes" xml:space="preserve">
          <source>NewChunkedReader is not needed by normal applications. The http package automatically decodes chunking when reading response bodies.</source>
          <target state="translated">일반 응용 프로그램에는 NewChunkedReader가 필요하지 않습니다. http 패키지는 응답 본문을 읽을 때 청킹을 자동으로 디코딩합니다.</target>
        </trans-unit>
        <trans-unit id="f0cf338b02e3e48fa365cda270fb9dee555b3d17" translate="yes" xml:space="preserve">
          <source>NewChunkedReader returns a new chunkedReader that translates the data read from r out of HTTP &quot;chunked&quot; format before returning it. The chunkedReader returns io.EOF when the final 0-length chunk is read.</source>
          <target state="translated">NewChunkedReader는 r에서 읽은 데이터를 HTTP &quot;chunked&quot;형식으로 변환하여 반환하기 전에 새로운 chunkedReader를 반환합니다. chunkedReader는 최종 0 길이 청크를 읽을 때 io.EOF를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="349a471f1f7196f4cd28f8d83c309c02f591534f" translate="yes" xml:space="preserve">
          <source>NewChunkedWriter is not needed by normal applications. The http package adds chunking automatically if handlers don't set a Content-Length header. Using NewChunkedWriter inside a handler would result in double chunking or chunking with a Content-Length length, both of which are wrong.</source>
          <target state="translated">일반 응용 프로그램에는 NewChunkedWriter가 필요하지 않습니다. 핸들러가 Content-Length 헤더를 설정하지 않으면 http 패키지는 자동으로 청크를 추가합니다. 핸들러 내에서 NewChunkedWriter를 사용하면 Content-Length 길이의 이중 청크 또는 청크가 발생하며 둘 다 잘못되었습니다.</target>
        </trans-unit>
        <trans-unit id="b746b9ef76b22845d6f63dc9d95e97e36a08dd5c" translate="yes" xml:space="preserve">
          <source>NewChunkedWriter is not needed by normal applications. The http package adds chunking automatically if handlers don't set a Content-Length header. Using newChunkedWriter inside a handler would result in double chunking or chunking with a Content-Length length, both of which are wrong.</source>
          <target state="translated">일반 응용 프로그램에는 NewChunkedWriter가 필요하지 않습니다. 핸들러가 Content-Length 헤더를 설정하지 않으면 http 패키지는 자동으로 청크를 추가합니다. 핸들러 내에서 newChunkedWriter를 사용하면 Content-Length 길이의 이중 청크 또는 청크가 발생하며 둘 다 잘못되었습니다.</target>
        </trans-unit>
        <trans-unit id="bbde3c49be540aed6f3b9a07213ce9f0f0985a47" translate="yes" xml:space="preserve">
          <source>NewChunkedWriter returns a new chunkedWriter that translates writes into HTTP &quot;chunked&quot; format before writing them to w. Closing the returned chunkedWriter sends the final 0-length chunk that marks the end of the stream but does not send the final CRLF that appears after trailers; trailers and the last CRLF must be written separately.</source>
          <target state="translated">NewChunkedWriter는 쓰기를 w에 쓰기 전에 HTTP &quot;청크&quot;형식으로 변환하는 새로운 chunkedWriter를 반환합니다. 반환 된 chunkedWriter를 닫으면 스트림의 끝을 표시하지만 트레일러 뒤에 나타나는 최종 CRLF를 보내지 않는 최종 길이가 0 인 청크를 보냅니다. 트레일러와 마지막 CRLF는 별도로 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="0f92d63907abdded9ec398f437e0cf965d51343f" translate="yes" xml:space="preserve">
          <source>NewCipher creates and returns a new Cipher. The key argument should be the RC4 key, at least 1 byte and at most 256 bytes.</source>
          <target state="translated">NewCipher는 새로운 암호를 생성하고 반환합니다. 키 인수는 RC4 키 (최소 1 바이트, 최대 256 바이트) 여야합니다.</target>
        </trans-unit>
        <trans-unit id="8328cb0f867c2e756f382b0ca63e4950d8850883" translate="yes" xml:space="preserve">
          <source>NewCipher creates and returns a new cipher.Block.</source>
          <target state="translated">NewCipher는 새로운 암호를 생성하고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6b22b2787fd6b2ed8659da500429f9fa3fe86072" translate="yes" xml:space="preserve">
          <source>NewCipher creates and returns a new cipher.Block. The key argument should be the AES key, either 16, 24, or 32 bytes to select AES-128, AES-192, or AES-256.</source>
          <target state="translated">NewCipher는 새로운 암호를 생성하고 반환합니다. AES-128, AES-192 또는 AES-256을 선택하려면 키 인수는 16, 24 또는 32 바이트 인 AES 키 여야합니다.</target>
        </trans-unit>
        <trans-unit id="b860dfa2340445fd2cf308e5a3748fea60faee9b" translate="yes" xml:space="preserve">
          <source>NewClient returns a new Client to handle requests to the set of services at the other end of the connection. It adds a buffer to the write side of the connection so the header and payload are sent as a unit.</source>
          <target state="translated">NewClient는 연결의 다른 쪽 끝에있는 서비스 집합에 대한 요청을 처리하기 위해 새 클라이언트를 반환합니다. 연결의 쓰기 측에 버퍼를 추가하여 헤더와 페이로드가 단위로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="b078c0d5ff1e636af20c5c0ed8dd22f85b7f4282" translate="yes" xml:space="preserve">
          <source>NewClient returns a new Client using an existing connection and host as a server name to be used when authenticating.</source>
          <target state="translated">NewClient는 인증시 사용할 기존 연결 및 호스트를 서버 이름으로 사용하여 새 클라이언트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f8fb1181ae8a229864a05cfebb15c90112fff65c" translate="yes" xml:space="preserve">
          <source>NewClient returns a new rpc.Client to handle requests to the set of services at the other end of the connection.</source>
          <target state="translated">NewClient는 연결의 다른 쪽 끝에있는 서비스 집합에 대한 요청을 처리하기 위해 새로운 rpc.Client를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="856bbb45168cae23811fbc886f1b4d3be27846fe" translate="yes" xml:space="preserve">
          <source>NewClientCodec returns a new rpc.ClientCodec using JSON-RPC on conn.</source>
          <target state="translated">NewClientCodec는 conn에서 JSON-RPC를 사용하여 새로운 rpc.ClientCodec를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b7383a602fa795d357297b4de95d8575b00a78ab" translate="yes" xml:space="preserve">
          <source>NewClientConn is an artifact of Go's early HTTP implementation. It is low-level, old, and unused by Go's current HTTP stack. We should have deleted it before Go 1.</source>
          <target state="translated">NewClientConn은 Go의 초기 HTTP 구현의 인공물입니다. Go의 현재 HTTP 스택에서 저수준이며 오래되었으며 사용되지 않습니다. Go 1 전에 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="4aa403c83da74918792480724a9f264584f0a604" translate="yes" xml:space="preserve">
          <source>NewClientWithCodec is like NewClient but uses the specified codec to encode requests and decode responses.</source>
          <target state="translated">NewClientWithCodec는 NewClient와 유사하지만 지정된 코덱을 사용하여 요청을 인코딩하고 응답을 디코딩합니다.</target>
        </trans-unit>
        <trans-unit id="413a5b89d02aeac4a6363a735de94f49289195bd" translate="yes" xml:space="preserve">
          <source>NewCommentMap creates a new comment map by associating comment groups of the comments list with the nodes of the AST specified by node.</source>
          <target state="translated">NewCommentMap은 주석 목록의 주석 그룹을 node로 지정된 AST의 노드와 연관시켜 새 주석 맵을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="9378822df6d0b7340f61509bcb85e6fd00318896" translate="yes" xml:space="preserve">
          <source>NewCommentMap tries to associate a comment group to the &quot;largest&quot; node possible: For instance, if the comment is a line comment trailing an assignment, the comment is associated with the entire assignment rather than just the last operand in the assignment.</source>
          <target state="translated">NewCommentMap은 주석 그룹을 가능한 &quot;가장 큰&quot;노드에 연결하려고 시도합니다. 예를 들어, 주석이 할당 후행 줄 주석 인 경우, 주석은 할당의 마지막 피연산자보다는 전체 할당과 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="4fd7049b9f856641359b9b5ca0cbb7b1cd2c0fac" translate="yes" xml:space="preserve">
          <source>NewCond returns a new Cond with Locker l.</source>
          <target state="translated">NewCond는 Locker l이있는 새로운 Cond를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="eee961cdebdc3886242b174d6b32a3a25041270b" translate="yes" xml:space="preserve">
          <source>NewConn returns a new Conn using conn for I/O.</source>
          <target state="translated">NewConn은 I / O에 conn을 사용하여 새 Conn을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f81c5ab59d9f6c3c64039d6d5945f0e9cc54b88d" translate="yes" xml:space="preserve">
          <source>NewConst returns a new constant with value val. The remaining arguments set the attributes found with all Objects.</source>
          <target state="translated">NewConst는 값이 val 인 새로운 상수를 반환합니다. 나머지 인수는 모든 객체에서 찾은 속성을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="bdc96fab96f7e5d7b8628b8398bba38bf6580815" translate="yes" xml:space="preserve">
          <source>NewDecoder constructs a new ascii85 stream decoder.</source>
          <target state="translated">NewDecoder는 새로운 ascii85 스트림 디코더를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="369f6e69c20c8e4d13528053c51cd1d3a61e68de" translate="yes" xml:space="preserve">
          <source>NewDecoder constructs a new base32 stream decoder.</source>
          <target state="translated">NewDecoder는 새로운 base32 스트림 디코더를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="d864a240d883e7dc24b71e88a8d5c0c1948d801c" translate="yes" xml:space="preserve">
          <source>NewDecoder constructs a new base64 stream decoder.</source>
          <target state="translated">NewDecoder는 새로운 base64 스트림 디코더를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="060a7de61a5514feea18b0489167470b12d0112a" translate="yes" xml:space="preserve">
          <source>NewDecoder creates a new XML parser reading from r. If r does not implement io.ByteReader, NewDecoder will do its own buffering.</source>
          <target state="translated">NewDecoder는 r에서 새로운 XML 파서를 읽는다. r이 io.ByteReader를 구현하지 않으면 NewDecoder는 자체 버퍼링을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="89572a28c9f62f14398327362d699001d2142b0d" translate="yes" xml:space="preserve">
          <source>NewDecoder returns a new decoder that reads from r.</source>
          <target state="translated">NewDecoder는 r에서 읽는 새 디코더를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="96af6984e1ed3c2ee798e01c4c02872b06029e89" translate="yes" xml:space="preserve">
          <source>NewDecoder returns a new decoder that reads from the io.Reader. If r does not also implement io.ByteReader, it will be wrapped in a bufio.Reader.</source>
          <target state="translated">NewDecoder는 io.Reader에서 읽는 새 디코더를 반환합니다. r이 io.ByteReader도 구현하지 않으면 bufio.Reader에 래핑됩니다.</target>
        </trans-unit>
        <trans-unit id="56f76b42c4fa44e21b83722e16f9a4c656264781" translate="yes" xml:space="preserve">
          <source>NewDecoder returns an io.Reader that decodes hexadecimal characters from r. NewDecoder expects that r contain only an even number of hexadecimal characters.</source>
          <target state="translated">NewDecoder는 r에서 16 진수 문자를 해독하는 io.Reader를 반환합니다. NewDecoder는 r에 짝수의 16 진 문자 만 포함 할 것으로 예상합니다.</target>
        </trans-unit>
        <trans-unit id="815c279b763f19acec3e56299892af2ccb9c6e0b" translate="yes" xml:space="preserve">
          <source>NewDecoder wraps an io.Reader interface around Decode.</source>
          <target state="translated">NewDecoder는 Decode 주위에 io.Reader 인터페이스를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="415b5e5928dc67ca5917ce4d88ceda8c89e1b092" translate="yes" xml:space="preserve">
          <source>NewEncoder</source>
          <target state="translated">NewEncoder</target>
        </trans-unit>
        <trans-unit id="018ed3a7983059a17dab1b137a9844370d5a2b74" translate="yes" xml:space="preserve">
          <source>NewEncoder returns a new ascii85 stream encoder. Data written to the returned writer will be encoded and then written to w. Ascii85 encodings operate in 32-bit blocks; when finished writing, the caller must Close the returned encoder to flush any trailing partial block.</source>
          <target state="translated">NewEncoder는 새로운 ascii85 스트림 인코더를 반환합니다. 반환 된 기록기에 기록 된 데이터는 인코딩 된 다음 w에 기록됩니다. Ascii85 인코딩은 32 비트 블록에서 작동합니다. 쓰기가 끝나면 호출자는 후행 부분 블록을 플러시하기 위해 반환 된 인코더를 닫아야합니다.</target>
        </trans-unit>
        <trans-unit id="dd7f4a301864c468eb1cb40a57cdfbd02a050c05" translate="yes" xml:space="preserve">
          <source>NewEncoder returns a new base32 stream encoder. Data written to the returned writer will be encoded using enc and then written to w. Base32 encodings operate in 5-byte blocks; when finished writing, the caller must Close the returned encoder to flush any partially written blocks.</source>
          <target state="translated">NewEncoder는 새로운 base32 스트림 인코더를 반환합니다. 반환 된 기록기에 기록 된 데이터는 enc를 사용하여 인코딩 된 다음 w에 기록됩니다. Base32 인코딩은 5 바이트 블록으로 작동합니다. 쓰기가 끝나면 호출자는 반환 된 인코더를 닫아 부분적으로 작성된 블록을 플러시해야합니다.</target>
        </trans-unit>
        <trans-unit id="44ee1dd433d92306638dd13e3127df94408d4089" translate="yes" xml:space="preserve">
          <source>NewEncoder returns a new base64 stream encoder. Data written to the returned writer will be encoded using enc and then written to w. Base64 encodings operate in 4-byte blocks; when finished writing, the caller must Close the returned encoder to flush any partially written blocks.</source>
          <target state="translated">NewEncoder는 새로운 base64 스트림 인코더를 반환합니다. 반환 된 기록기에 기록 된 데이터는 enc를 사용하여 인코딩 된 다음 w에 기록됩니다. Base64 인코딩은 4 바이트 블록으로 작동합니다. 쓰기가 끝나면 호출자는 반환 된 인코더를 닫아 부분적으로 작성된 블록을 플러시해야합니다.</target>
        </trans-unit>
        <trans-unit id="d754a23d4130a807a013e53a62e7006beaa7e442" translate="yes" xml:space="preserve">
          <source>NewEncoder returns a new encoder that will transmit on the io.Writer.</source>
          <target state="translated">NewEncoder는 io.Writer에서 전송할 새 인코더를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d092172077c4670e0835be93cc4b418229db1d7a" translate="yes" xml:space="preserve">
          <source>NewEncoder returns a new encoder that writes to w.</source>
          <target state="translated">NewEncoder는 w에 쓰는 새 인코더를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6bc807b2bebb618f92c16dd28d4ba73b4801ef86" translate="yes" xml:space="preserve">
          <source>NewEncoder returns an io.Writer that writes lowercase hexadecimal characters to w.</source>
          <target state="translated">NewEncoder는 소문자 16 진 문자를 w에 쓰는 io.Writer를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ec3215d4f7a860c50c96d8ebe05c612fbb607223" translate="yes" xml:space="preserve">
          <source>NewEncoding returns a new Encoding defined by the given alphabet, which must be a 32-byte string.</source>
          <target state="translated">NewEncoding은 주어진 알파벳으로 정의 된 새로운 인코딩을 반환하며, 이는 32 바이트 문자열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="a225db48b3273b7eabd0d6e7950dc3ffe5785055" translate="yes" xml:space="preserve">
          <source>NewEncoding returns a new padded Encoding defined by the given alphabet, which must be a 64-byte string that does not contain the padding character or CR / LF ('\r', '\n'). The resulting Encoding uses the default padding character ('='), which may be changed or disabled via WithPadding.</source>
          <target state="translated">NewEncoding은 주어진 알파벳으로 정의 된 새로운 패딩 된 인코딩을 반환하며, 이는 패딩 문자 나 CR / LF ( '\ r', '\ n')를 포함하지 않는 64 바이트 문자열이어야합니다. 결과 인코딩은 기본 패딩 문자 ( '=')를 사용하며 WithPadding을 통해 변경하거나 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3eb6effd2379105d96f5ae281be769ac968f9b4" translate="yes" xml:space="preserve">
          <source>NewFatFile creates a new FatFile for accessing all the Mach-O images in a universal binary. The Mach-O binary is expected to start at position 0 in the ReaderAt.</source>
          <target state="translated">NewFatFile은 범용 바이너리로 모든 Mach-O 이미지에 액세스하기위한 새로운 FatFile을 생성합니다. Mach-O 바이너리는 ReaderAt의 위치 0에서 시작될 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="d86df188426dbb1a1da9539d4f76b961b9e5801b" translate="yes" xml:space="preserve">
          <source>NewField returns a new variable representing a struct field. For embedded fields, the name is the unqualified type name / under which the field is accessible.</source>
          <target state="translated">NewField는 구조체 필드를 나타내는 새 변수를 반환합니다. 임베드 된 필드의 경우 이름은 필드에 액세스 할 수있는 규정되지 않은 유형 이름입니다.</target>
        </trans-unit>
        <trans-unit id="fa49724aa2bb7b06a7e49b7b14c21627f72f66fe" translate="yes" xml:space="preserve">
          <source>NewFile creates a new File for accessing a Mach-O binary in an underlying reader. The Mach-O binary is expected to start at position 0 in the ReaderAt.</source>
          <target state="translated">NewFile은 기본 리더에서 Mach-O 바이너리에 액세스하기위한 새 파일을 만듭니다. Mach-O 바이너리는 ReaderAt의 위치 0에서 시작될 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="c4cb0bcb5da3b7cb9c222f07d952f1deb79331f9" translate="yes" xml:space="preserve">
          <source>NewFile creates a new File for accessing a PE binary in an underlying reader.</source>
          <target state="translated">NewFile은 기본 리더에서 PE 바이너리에 액세스하기위한 새 파일을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="fb3c69eb6155088ad1b0a5da31e3f5031165ea55" translate="yes" xml:space="preserve">
          <source>NewFile creates a new File for accessing a Plan 9 binary in an underlying reader. The Plan 9 binary is expected to start at position 0 in the ReaderAt.</source>
          <target state="translated">NewFile은 기본 판독기에서 Plan 9 바이너리에 액세스하기위한 새 파일을 작성합니다. Plan 9 바이너리는 ReaderAt의 0 위치에서 시작될 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="02c382510f60f7ac0e7f9dd332c2062d9f122bae" translate="yes" xml:space="preserve">
          <source>NewFile creates a new File for accessing an ELF binary in an underlying reader. The ELF binary is expected to start at position 0 in the ReaderAt.</source>
          <target state="translated">NewFile은 기본 리더에서 ELF 바이너리에 액세스하기위한 새 파일을 만듭니다. ELF 바이너리는 ReaderAt의 위치 0에서 시작될 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="dd7d78c4172dcb2fe6cfcff9bb7e67f44f614ee3" translate="yes" xml:space="preserve">
          <source>NewFile returns a new File with the given file descriptor and name. The returned value will be nil if fd is not a valid file descriptor. On Unix systems, if the file descriptor is in non-blocking mode, NewFile will attempt to return a pollable File (one for which the SetDeadline methods work).</source>
          <target state="translated">NewFile은 주어진 파일 기술자와 이름을 가진 새로운 File을 반환합니다. fd가 유효한 파일 디스크립터가 아닌 경우 리턴 값은 nil입니다. Unix 시스템에서 파일 디스크립터가 비 블로킹 모드 인 경우 NewFile은 폴링 가능 파일 (SetDeadline 메소드가 작동하는 파일)을 리턴하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="146b2f1f1201d86650233642cb2b7d8638ac3e22" translate="yes" xml:space="preserve">
          <source>NewFileSet creates a new file set.</source>
          <target state="translated">NewFileSet은 새로운 파일 세트를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="39ae9e749e1c008bbfaf63f08fa2bb4e930b56b2" translate="yes" xml:space="preserve">
          <source>NewFileTransport returns a new RoundTripper, serving the provided FileSystem. The returned RoundTripper ignores the URL host in its incoming requests, as well as most other properties of the request.</source>
          <target state="translated">NewFileTransport는 제공된 FileSystem을 제공하는 새로운 RoundTripper를 반환합니다. 반환 된 RoundTripper는 들어오는 요청의 URL 호스트와 요청의 다른 대부분의 속성을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="f495b9657d10d27f36446d430fd6f4942c405b7b" translate="yes" xml:space="preserve">
          <source>NewFlagSet returns a new, empty flag set with the specified name and error handling property. If the name is not empty, it will be printed in the default usage message and in error messages.</source>
          <target state="translated">NewFlagSet은 지정된 이름 및 오류 처리 속성으로 설정된 새로운 빈 플래그를 반환합니다. 이름이 비어 있지 않으면 기본 사용 메시지와 오류 메시지에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="6c1be2205981424ac6113bbac1c50ddc8e645067" translate="yes" xml:space="preserve">
          <source>NewFloat allocates and returns a new Float set to x, with precision 53 and rounding mode ToNearestEven. NewFloat panics with ErrNaN if x is a NaN.</source>
          <target state="translated">NewFloat는 정밀도 53과 반올림 모드 ToNearestEven을 사용하여 x로 설정된 새 Float를 할당하고 반환합니다. x가 NaN 인 경우 ErrNaN으로 NewFloat 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2c91158e9955fcc78b6177862dde11c92e0a8e89" translate="yes" xml:space="preserve">
          <source>NewFromFiles</source>
          <target state="translated">NewFromFiles</target>
        </trans-unit>
        <trans-unit id="d5aa413c2ae053b79a6371a10ccf3bd1d17cfac2" translate="yes" xml:space="preserve">
          <source>NewFromFiles computes documentation for a package.</source>
          <target state="translated">NewFromFiles는 패키지에 대한 문서를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="4a2d01ef38cc1f681b00bbd8645c1b2f1cdf0884" translate="yes" xml:space="preserve">
          <source>NewFromFiles takes ownership of the AST files and may edit them, unless the PreserveAST Mode bit is on.</source>
          <target state="translated">NewFromFiles는 AST 파일의 소유권을 가지며 PreserveAST 모드 비트가 켜져 있지 않으면 편집 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62cad2834cd366b48375257d77d59b7e9a0915c1" translate="yes" xml:space="preserve">
          <source>NewFunc returns a new function with the given signature, representing the function's type.</source>
          <target state="translated">NewFunc는 함수의 타입을 나타내는 주어진 서명을 가진 새로운 함수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1ab1fbb5a4b914ad66a4cae1cb655fa076b9ba96" translate="yes" xml:space="preserve">
          <source>NewGCM (Decrypt)</source>
          <target state="translated">NewGCM (암호 해독)</target>
        </trans-unit>
        <trans-unit id="88779115714f813ff34a3c2fff6aef4d291f21ae" translate="yes" xml:space="preserve">
          <source>NewGCM (Encrypt)</source>
          <target state="translated">NewGCM (암호화)</target>
        </trans-unit>
        <trans-unit id="d8e7f4fd8eb6323a1d235af8804d7f84b6c49124" translate="yes" xml:space="preserve">
          <source>NewGCM returns the given 128-bit, block cipher wrapped in Galois Counter Mode with the standard nonce length.</source>
          <target state="translated">NewGCM은 표준 nonce 길이로 Galois Counter Mode로 래핑 된 지정된 128 비트 블록 암호를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1973de63c4df3596c58655e33db1f26efd7af742" translate="yes" xml:space="preserve">
          <source>NewGCMWithNonceSize returns the given 128-bit, block cipher wrapped in Galois Counter Mode, which accepts nonces of the given length.</source>
          <target state="translated">NewGCMWithNonceSize는 주어진 길이의 nonces를 허용하는 Galois Counter Mode로 래핑 된 주어진 128 비트 블록 암호를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="23bb3140d85ffc465c1c9d547b9527a6165fd0c6" translate="yes" xml:space="preserve">
          <source>NewGCMWithNonceSize returns the given 128-bit, block cipher wrapped in Galois Counter Mode, which accepts nonces of the given length. The length must not be zero.</source>
          <target state="translated">NewGCMWithNonceSize는 주어진 길이의 nonce를 받아들이는 Galois Counter Mode로 래핑 된 주어진 128 비트 블록 암호를 반환합니다. 길이는 0이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="c89798890939059366d5fe1d2975869f4976a143" translate="yes" xml:space="preserve">
          <source>NewGCMWithTagSize returns the given 128-bit, block cipher wrapped in Galois Counter Mode, which generates tags with the given length.</source>
          <target state="translated">NewGCMWithTagSize는 지정된 길이의 태그를 생성하는 Galois Counter Mode로 래핑 된 지정된 128 비트 블록 암호를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="454b2fc86978be3ab7ad864f00d10ff49dc84b08" translate="yes" xml:space="preserve">
          <source>NewGray returns a new Gray image with the given bounds.</source>
          <target state="translated">NewGray는 주어진 범위를 가진 새로운 회색 이미지를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3f20d3a865eb95651d9773b55020e283c7cda789" translate="yes" xml:space="preserve">
          <source>NewGray16 returns a new Gray16 image with the given bounds.</source>
          <target state="translated">NewGray16은 주어진 범위를 가진 새로운 Gray16 이미지를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7063568571cff8011c550348a1d249dbcd1b3164" translate="yes" xml:space="preserve">
          <source>NewIEEE creates a new hash.Hash32 computing the CRC-32 checksum using the IEEE polynomial. Its Sum method will lay the value out in big-endian byte order. The returned Hash32 also implements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to marshal and unmarshal the internal state of the hash.</source>
          <target state="translated">NewIEEE는 IEEE 다항식을 사용하여 CRC-32 체크섬을 계산하여 새 해시를 생성합니다. Sum 메소드는 값을 빅 엔디안 바이트 순서로 배치합니다. 반환 된 Hash32는 해시의 내부 상태를 마샬링하고 언 마샬링하기 위해 encoding.BinaryMarshaler 및 encoding.BinaryUnmarshaler도 구현합니다.</target>
        </trans-unit>
        <trans-unit id="4d0116b71b732a25476a4fce3bfdd9a186665b0a" translate="yes" xml:space="preserve">
          <source>NewIdent creates a new Ident without position. Useful for ASTs generated by code other than the Go parser.</source>
          <target state="translated">NewIdent는 위치없이 새로운 Ident를 만듭니다. Go 구문 분석기 이외의 코드로 생성 된 AST에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="a1da620d7851b36eddceb2d1155bd10520ef1e3d" translate="yes" xml:space="preserve">
          <source>NewIdentifier returns a new IdentifierNode with the given identifier name.</source>
          <target state="translated">NewIdentifier는 주어진 식별자 이름으로 새로운 IdentifierNode를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="525b5936156155224309c259d63dc7a201bbb3b9" translate="yes" xml:space="preserve">
          <source>NewInt allocates and returns a new Int set to x.</source>
          <target state="translated">NewInt는 x로 설정된 새로운 Int를 할당하고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ce33b2838258d1a7fb77fc3c2496c70b71309e0c" translate="yes" xml:space="preserve">
          <source>NewInterface returns a new (incomplete) interface for the given methods and embedded types. Each embedded type must have an underlying type of interface type. NewInterface takes ownership of the provided methods and may modify their types by setting missing receivers. To compute the method set of the interface, Complete must be called.</source>
          <target state="translated">NewInterface는 주어진 메소드와 임베디드 타입에 대해 새로운 (불완전한) 인터페이스를 반환합니다. 각 임베디드 유형에는 기본 유형의 인터페이스 유형이 있어야합니다. NewInterface는 제공된 메소드의 소유권을 가지며 누락 된 수신자를 설정하여 해당 유형을 수정할 수 있습니다. 인터페이스의 메소드 세트를 계산하려면 Complete를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="c1879314ab1ca85d9a540a3d842506cb8e3d5935" translate="yes" xml:space="preserve">
          <source>NewInterfaceType returns a new (incomplete) interface for the given methods and embedded types. Each embedded type must have an underlying type of interface type (this property is not verified for defined types, which may be in the process of being set up and which don't have a valid underlying type yet). NewInterfaceType takes ownership of the provided methods and may modify their types by setting missing receivers. To compute the method set of the interface, Complete must be called.</source>
          <target state="translated">NewInterfaceType은 주어진 메소드와 임베디드 타입에 대해 새로운 (불완전한) 인터페이스를 반환합니다. 각 임베디드 유형에는 기본 유형의 인터페이스 유형이 있어야합니다 (이 특성은 정의 된 유형에 대해 검증되지 않았으며, 설정중인 프로세스에 아직 유효한 기본 유형이없는 경우). NewInterfaceType은 제공된 메소드의 소유권을 가지며 누락 된 수신자를 설정하여 해당 유형을 수정할 수 있습니다. 인터페이스의 메소드 세트를 계산하려면 Complete를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="412fcf56e8322a2530a374f7516c3ab81d822a6e" translate="yes" xml:space="preserve">
          <source>NewKeyFromSeed calculates a private key from a seed. It will panic if len(seed) is not SeedSize. This function is provided for interoperability with RFC 8032. RFC 8032's private keys correspond to seeds in this package.</source>
          <target state="translated">NewKeyFromSeed는 시드에서 개인 키를 계산합니다. len (seed)가 SeedSize가 아닌 경우 공황 상태가됩니다. 이 기능은 RFC 8032와의 상호 운용성을 위해 제공됩니다. RFC 8032의 개인 키는이 패키지의 시드에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="7f204c9bcbc69e7346a4be4a91e71094cadba874" translate="yes" xml:space="preserve">
          <source>NewLRUClientSessionCache returns a ClientSessionCache with the given capacity that uses an LRU strategy. If capacity is &amp;lt; 1, a default capacity is used instead.</source>
          <target state="translated">NewLRUClientSessionCache는 LRU 전략을 사용하는 지정된 용량으로 ClientSessionCache를 리턴합니다. 용량이 &amp;lt;1 인 경우 기본 용량이 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e85de83deae1f6ea413617fafa918347032b364d" translate="yes" xml:space="preserve">
          <source>NewLabel returns a new label.</source>
          <target state="translated">NewLabel은 새 레이블을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c00322f2990498c11eaea48009e4263db8d2b147" translate="yes" xml:space="preserve">
          <source>NewLineTable returns a new PC/line table corresponding to the encoded data. Text must be the start address of the corresponding text segment.</source>
          <target state="translated">NewLineTable은 인코딩 된 데이터에 해당하는 새로운 PC / 라인 테이블을 반환합니다. 텍스트는 해당 텍스트 세그먼트의 시작 주소 여야합니다.</target>
        </trans-unit>
        <trans-unit id="ee273ce2cc40669abe88f8cbd5b969c8b99cc1d8" translate="yes" xml:space="preserve">
          <source>NewListener creates a Listener which accepts connections from an inner Listener and wraps each connection with Server. The configuration config must be non-nil and must include at least one certificate or else set GetCertificate.</source>
          <target state="translated">NewListener는 내부 리스너의 연결을 수락하고 각 연결을 서버와 래핑하는 리스너를 만듭니다. 구성 구성은 0이 아니어야하며 하나 이상의 인증서를 포함하거나 GetCertificate를 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="b8ae0fc1fd1b3795d43931c769132b8b76d67124" translate="yes" xml:space="preserve">
          <source>NewLogger creates a log.Logger whose output is written to the system log service with the specified priority, a combination of the syslog facility and severity. The logFlag argument is the flag set passed through to log.New to create the Logger.</source>
          <target state="translated">NewLogger는 syslog 기능과 심각도의 조합으로 지정된 우선 순위로 시스템 로그 서비스에 출력이 기록되는 log.Logger를 작성합니다. logFlag 인수는 log.New에 전달 된 플래그 집합으로 Logger를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="c2cf8bf27d6896fb60a3c00c2f29046150140e53" translate="yes" xml:space="preserve">
          <source>NewMap returns a new map for the given key and element types.</source>
          <target state="translated">NewMap은 주어진 키 및 요소 유형에 대한 새 맵을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="02aaaae9f75a28f52b63beb3faa08f1c64a67962" translate="yes" xml:space="preserve">
          <source>NewMethodSet returns the method set for the given type T. It always returns a non-nil method set, even if it is empty.</source>
          <target state="translated">NewMethodSet은 주어진 유형 T에 대해 설정된 메소드를 반환합니다. 비어 있지 않은 경우에도 항상 넌이 아닌 메소드 세트를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="8a80c96af1db7665cca4280156494ace76054fb6" translate="yes" xml:space="preserve">
          <source>NewNRGBA returns a new NRGBA image with the given bounds.</source>
          <target state="translated">NewNRGBA는 주어진 범위를 가진 새로운 NRGBA 이미지를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="91846ee562c7c231bc0d057ad08777b2cf971613" translate="yes" xml:space="preserve">
          <source>NewNRGBA64 returns a new NRGBA64 image with the given bounds.</source>
          <target state="translated">NewNRGBA64는 주어진 범위를 가진 새로운 NRGBA64 이미지를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="808f42c5f206bd7e6ba827599de3fbf867803134" translate="yes" xml:space="preserve">
          <source>NewNYCbCrA returns a new NYCbCrA image with the given bounds and subsample ratio.</source>
          <target state="translated">NewNYCbCrA는 주어진 범위와 서브 샘플 비율로 새로운 NYCbCrA 이미지를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1fd8ffb265de65f1861cce1196f85b25e1d6856a" translate="yes" xml:space="preserve">
          <source>NewNamed returns a new named type for the given type name, underlying type, and associated methods. If the given type name obj doesn't have a type yet, its type is set to the returned named type. The underlying type must not be a *Named.</source>
          <target state="translated">NewNamed는 지정된 형식 이름, 기본 형식 및 관련 메서드에 대해 새로운 명명 된 형식을 반환합니다. 주어진 타입 이름 obj에 아직 타입이 없다면, 타입은 반환 된 명명 된 타입으로 설정됩니다. 기본 유형은 * Named가 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="e782c15bb55a8ae8ebce9f874df5b1a0c46216d1" translate="yes" xml:space="preserve">
          <source>NewOFB</source>
          <target state="translated">NewOFB</target>
        </trans-unit>
        <trans-unit id="b57f2ce3c1f5586132093d982185af2e0ee68f6c" translate="yes" xml:space="preserve">
          <source>NewOFB returns a Stream that encrypts or decrypts using the block cipher b in output feedback mode. The initialization vector iv's length must be equal to b's block size.</source>
          <target state="translated">NewOFB는 출력 피드백 모드에서 블록 암호 b를 사용하여 암호화하거나 해독하는 Stream을 반환합니다. 초기화 벡터 iv의 길이는 b의 블록 크기와 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="8ec79b70c4182bbf15d13c7ed9c2f93fc95d113e" translate="yes" xml:space="preserve">
          <source>NewObj creates a new object of a given kind and name.</source>
          <target state="translated">NewObj는 주어진 종류와 이름의 새 객체를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="36552f14153f539c86094444ec1ce5a1a1e5bd03" translate="yes" xml:space="preserve">
          <source>NewPackage creates a new Package node from a set of File nodes. It resolves unresolved identifiers across files and updates each file's Unresolved list accordingly. If a non-nil importer and universe scope are provided, they are used to resolve identifiers not declared in any of the package files. Any remaining unresolved identifiers are reported as undeclared. If the files belong to different packages, one package name is selected and files with different package names are reported and then ignored. The result is a package node and a scanner.ErrorList if there were errors.</source>
          <target state="translated">NewPackage는 파일 노드 세트에서 새 패키지 노드를 작성합니다. 파일 전체에서 확인되지 않은 식별자를 확인하고 그에 따라 각 파일의 확인되지 않은 목록을 업데이트합니다. 가져 오기가 아닌 가져 오기 및 유니버스 범위가 제공되면 패키지 파일에 선언되지 않은 식별자를 확인하는 데 사용됩니다. 남아있는 해결되지 않은 식별자는 선언되지 않은 것으로보고됩니다. 파일이 다른 패키지에 속하는 경우 하나의 패키지 이름이 선택되고 다른 패키지 이름을 가진 파일이보고 된 다음 무시됩니다. 결과는 패키지 노드와 scanner.ErrorList입니다 (오류가있는 경우).</target>
        </trans-unit>
        <trans-unit id="8b93023f444decd83a57effbd1356f40d43944cd" translate="yes" xml:space="preserve">
          <source>NewPackage returns a new Package for the given package path and name. The package is not complete and contains no explicit imports.</source>
          <target state="translated">NewPackage는 지정된 패키지 경로 및 이름에 대한 새 패키지를 반환합니다. 패키지가 완전하지 않으며 명시적인 가져 오기가 없습니다.</target>
        </trans-unit>
        <trans-unit id="7604882861f8171ac92bb5a0ff3402c04452837d" translate="yes" xml:space="preserve">
          <source>NewPaletted returns a new Paletted image with the given width, height and palette.</source>
          <target state="translated">NewPaletted는 주어진 너비, 높이 및 팔레트를 가진 새로운 Paletted 이미지를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8157edaefd4d8244aead4c748c2239a1e9cdf406" translate="yes" xml:space="preserve">
          <source>NewParam returns a new variable representing a function parameter.</source>
          <target state="translated">NewParam은 함수 매개 변수를 나타내는 새 변수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="760c953eeca5555c276ff2137d11f1ac464a3878" translate="yes" xml:space="preserve">
          <source>NewPkgName returns a new PkgName object representing an imported package. The remaining arguments set the attributes found with all Objects.</source>
          <target state="translated">NewPkgName은 가져온 패키지를 나타내는 새로운 PkgName 객체를 반환합니다. 나머지 인수는 모든 객체에서 찾은 속성을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="7267fd8d7fb296d4d49d2c7f2fba8f9caa6a9909" translate="yes" xml:space="preserve">
          <source>NewPointer returns a new pointer type for the given element (base) type.</source>
          <target state="translated">NewPointer는 주어진 요소 (기본) 유형에 대한 새로운 포인터 유형을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ad8326fa0e1c2920bea4e6fdd7be9537d18c5951" translate="yes" xml:space="preserve">
          <source>NewProfile creates a new profile with the given name. If a profile with that name already exists, NewProfile panics. The convention is to use a 'import/path.' prefix to create separate name spaces for each package. For compatibility with various tools that read pprof data, profile names should not contain spaces.</source>
          <target state="translated">NewProfile은 주어진 이름으로 새 프로필을 만듭니다. 해당 이름의 프로필이 이미 존재하면 NewProfile이 패닉 상태가됩니다. 규칙은 '가져 오기 / 경로'를 사용하는 것입니다. 접두사를 사용하여 각 패키지에 대해 별도의 네임 스페이스를 만듭니다. pprof 데이터를 읽는 다양한 도구와의 호환성을 위해 프로파일 이름에는 공백이 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="7dee9fd54a2c7c0d2e2445231875724a5129fb2a" translate="yes" xml:space="preserve">
          <source>NewProxyClientConn is an artifact of Go's early HTTP implementation. It is low-level, old, and unused by Go's current HTTP stack. We should have deleted it before Go 1.</source>
          <target state="translated">NewProxyClientConn은 Go의 초기 HTTP 구현의 인공물입니다. Go의 현재 HTTP 스택에서 저수준이며 오래되었으며 사용되지 않습니다. Go 1 전에 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="7013b5c7630f0f9aff6a55861942f65a617ff634" translate="yes" xml:space="preserve">
          <source>NewRGBA returns a new RGBA image with the given bounds.</source>
          <target state="translated">NewRGBA는 주어진 범위를 가진 새로운 RGBA 이미지를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="06634c84293e78aa59af4c55605513918ba019e7" translate="yes" xml:space="preserve">
          <source>NewRGBA64 returns a new RGBA64 image with the given bounds.</source>
          <target state="translated">NewRGBA64는 주어진 범위를 가진 새로운 RGBA64 이미지를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="00d97e53207565a29c223d381563f8ace2580585" translate="yes" xml:space="preserve">
          <source>NewRat creates a new Rat with numerator a and denominator b.</source>
          <target state="translated">NewRat은 분자 a와 분모 b를 가진 새로운 쥐를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="8b51e66ddf0c0bc242e2972b3ed47f8e19aa8aff" translate="yes" xml:space="preserve">
          <source>NewReadLogger returns a reader that behaves like r except that it logs (using log.Printf) each read to standard error, printing the prefix and the hexadecimal data read.</source>
          <target state="translated">NewReadLogger는 r과 같이 동작하는 리더를 반환합니다 (log.Printf를 사용하여) 각 읽기를 표준 오류에 기록하고 접두사와 16 진수 데이터를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="4ddd20c3c7ab3b134b41334b4749254502eec73c" translate="yes" xml:space="preserve">
          <source>NewReadWriter allocates a new ReadWriter that dispatches to r and w.</source>
          <target state="translated">NewReadWriter는 r과 w에 디스패치하는 새로운 ReadWriter를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="abdd552b8a6a378c711658cbda39673b4658c843" translate="yes" xml:space="preserve">
          <source>NewReader</source>
          <target state="translated">NewReader</target>
        </trans-unit>
        <trans-unit id="656b7888dc8300d6258cc09514612ef897a06356" translate="yes" xml:space="preserve">
          <source>NewReader creates a new ReadCloser. Reads from the returned ReadCloser read and decompress data from r. If r does not implement io.ByteReader, the decompressor may read more data than necessary from r. It is the caller's responsibility to call Close on the ReadCloser when done.</source>
          <target state="translated">NewReader는 새로운 ReadCloser를 만듭니다. 리턴 된 ReadCloser에서 읽기를 수행하고 r에서 데이터를 압축 해제합니다. r이 io.ByteReader를 구현하지 않으면 압축 해제 기는 r에서 필요한 것보다 많은 데이터를 읽을 수 있습니다. 완료되면 ReadCloser에서 Close를 호출하는 것은 호출자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="03de0f94de657abcdcd727d93d1385934f4b4c2a" translate="yes" xml:space="preserve">
          <source>NewReader creates a new Reader reading from r.</source>
          <target state="translated">NewReader는 r에서 새로운 Reader 판독 값을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="9310cd05d389a1e08ddfb9e4317d864d066d18ff" translate="yes" xml:space="preserve">
          <source>NewReader creates a new Reader reading the given reader. If r does not also implement io.ByteReader, the decompressor may read more data than necessary from r.</source>
          <target state="translated">NewReader는 주어진 리더를 읽는 새 리더를 만듭니다. r이 io.ByteReader도 구현하지 않으면 압축 해제 기는 r에서 필요한 것보다 많은 데이터를 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1afded549345ec0238483e2ba55aa75ed2ded5bd" translate="yes" xml:space="preserve">
          <source>NewReader creates a new io.ReadCloser. Reads from the returned io.ReadCloser read and decompress data from r. If r does not also implement io.ByteReader, the decompressor may read more data than necessary from r. It is the caller's responsibility to call Close on the ReadCloser when finished reading. The number of bits to use for literal codes, litWidth, must be in the range [2,8] and is typically 8. It must equal the litWidth used during compression.</source>
          <target state="translated">NewReader는 새로운 io.ReadCloser를 만듭니다. 반환 된 io에서 읽습니다 .ReadCloser는 r에서 데이터를 읽고 압축 해제합니다. r이 io.ByteReader도 구현하지 않으면 압축 해제 기는 r에서 필요한 것보다 많은 데이터를 읽을 수 있습니다. 읽기가 끝나면 ReadCloser에서 Close를 호출하는 것은 호출자의 책임입니다. 리터럴 코드에 사용되는 비트 수인 litWidth는 [2,8] 범위에 있어야하며 일반적으로 8이어야합니다. 압축하는 동안 사용되는 litWidth와 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="104785202390e0ba0e171f6e70831714a74466f6" translate="yes" xml:space="preserve">
          <source>NewReader creates a new multipart Reader reading from r using the given MIME boundary.</source>
          <target state="translated">NewReader는 주어진 MIME 경계를 사용하여 r에서 새로운 multipart Reader 판독 값을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c18de38552330a3ffd438fa2e288016ca23d0e4e" translate="yes" xml:space="preserve">
          <source>NewReader returns a new ReadCloser that can be used to read the uncompressed version of r. If r does not also implement io.ByteReader, the decompressor may read more data than necessary from r. It is the caller's responsibility to call Close on the ReadCloser when finished reading.</source>
          <target state="translated">NewReader는 압축되지 않은 r 버전을 읽는 데 사용할 수있는 새로운 ReadCloser를 반환합니다. r이 io.ByteReader도 구현하지 않으면 압축 해제 기는 r에서 필요한 것보다 많은 데이터를 읽을 수 있습니다. 읽기가 끝나면 ReadCloser에서 Close를 호출하는 것은 호출자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="36241ff4da2c1821f96dba25272112a2ddbe76ee" translate="yes" xml:space="preserve">
          <source>NewReader returns a new Reader reading from b.</source>
          <target state="translated">NewReader는 b에서 새로운 Reader 판독 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9e007e6c23a0a667f419ff954033af0ca806b580" translate="yes" xml:space="preserve">
          <source>NewReader returns a new Reader reading from r, which is assumed to have the given size in bytes.</source>
          <target state="translated">NewReader는 r에서 새로운 판독 값을 반환합니다.이 판독 값은 주어진 크기를 바이트 단위로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="0a237744e6cd622e08bcaadcb57e9896c2c1bd36" translate="yes" xml:space="preserve">
          <source>NewReader returns a new Reader reading from r.</source>
          <target state="translated">NewReader는 r에서 새로운 Reader 판독 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8809e71360f0f480fd09d2bb6c73d758eb20bf24" translate="yes" xml:space="preserve">
          <source>NewReader returns a new Reader reading from s. It is similar to bytes.NewBufferString but more efficient and read-only.</source>
          <target state="translated">NewReader는 s에서 읽은 새 Reader를 반환합니다. bytes.NewBufferString과 유사하지만보다 효율적이고 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="4b591a6aa8b2fa42d203301d41858890dc4a8ba3" translate="yes" xml:space="preserve">
          <source>NewReader returns a new Reader that reads from r.</source>
          <target state="translated">NewReader는 r에서 읽는 새 Reader를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c08939cbf0fe51e296c0a2ccf3a3311832697807" translate="yes" xml:space="preserve">
          <source>NewReader returns a new Reader whose buffer has the default size.</source>
          <target state="translated">NewReader는 버퍼의 기본 크기를 가진 새로운 Reader를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ab008cb6047aabfffe29520f5a1d9f6947d1bb37" translate="yes" xml:space="preserve">
          <source>NewReader returns a quoted-printable reader, decoding from r.</source>
          <target state="translated">NewReader는 r에서 디코딩 된 인용 인쇄 가능한 리더를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="15423ba5dc90eb7ca320aa86b1e4769688d373ee" translate="yes" xml:space="preserve">
          <source>NewReader returns an io.Reader which decompresses bzip2 data from r. If r does not also implement io.ByteReader, the decompressor may read more data than necessary from r.</source>
          <target state="translated">NewReader는 r에서 bzip2 데이터를 압축 해제하는 io.Reader를 반환합니다. r이 io.ByteReader도 구현하지 않으면 압축 해제 기는 r에서 필요한 것보다 많은 데이터를 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ceca3110c418c227d4c22c9ca1803e30b1fbc6a9" translate="yes" xml:space="preserve">
          <source>NewReaderDict is like NewReader but initializes the reader with a preset dictionary. The returned Reader behaves as if the uncompressed data stream started with the given dictionary, which has already been read. NewReaderDict is typically used to read data compressed by NewWriterDict.</source>
          <target state="translated">NewReaderDict는 NewReader와 유사하지만 사전 설정 사전으로 리더를 초기화합니다. 반환 된 Reader는 압축되지 않은 데이터 스트림이 이미 읽은 주어진 사전으로 시작된 것처럼 동작합니다. NewReaderDict는 일반적으로 NewWriterDict에 의해 압축 된 데이터를 읽는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="15dcb5ef9b327e52dad13c8a81c8c78369449efa" translate="yes" xml:space="preserve">
          <source>NewReaderDict is like NewReader but uses a preset dictionary. NewReaderDict ignores the dictionary if the compressed data does not refer to it. If the compressed data refers to a different dictionary, NewReaderDict returns ErrDictionary.</source>
          <target state="translated">NewReaderDict는 NewReader와 비슷하지만 사전 설정 사전을 사용합니다. 압축 된 데이터가이를 참조하지 않으면 NewReaderDict는 사전을 무시합니다. 압축 된 데이터가 다른 사전을 참조하면 NewReaderDict는 ErrDictionary를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="62226d4a3a7ef180876e33ca9f9e3e5dd9d4d275" translate="yes" xml:space="preserve">
          <source>NewReaderSize returns a new Reader whose buffer has at least the specified size. If the argument io.Reader is already a Reader with large enough size, it returns the underlying Reader.</source>
          <target state="translated">NewReaderSize는 버퍼가 지정된 크기 이상인 새 Reader를 반환합니다. io.Reader 인수가 이미 충분히 큰 리더 인 경우 기본 Reader를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="9a90b37d52d4387ba6d3b8a70e9b4fe0675a973d" translate="yes" xml:space="preserve">
          <source>NewRecorder returns an initialized ResponseRecorder.</source>
          <target state="translated">NewRecorder는 초기화 된 ResponseRecorder를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cc38b91034f7148cfc66856688fcf7b15792b799" translate="yes" xml:space="preserve">
          <source>NewReplacer</source>
          <target state="translated">NewReplacer</target>
        </trans-unit>
        <trans-unit id="98fb98214a91e4f9ae6ab220237b228d86508a63" translate="yes" xml:space="preserve">
          <source>NewReplacer panics if given an odd number of arguments.</source>
          <target state="translated">홀수 개의 인수가 제공되면 NewReplacer 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2061a29533176cb14bbeea4aaacbdde390807809" translate="yes" xml:space="preserve">
          <source>NewReplacer returns a new Replacer from a list of old, new string pairs. Replacements are performed in the order they appear in the target string, without overlapping matches. The old string comparisons are done in argument order.</source>
          <target state="translated">NewReplacer는 기존의 새 문자열 쌍 목록에서 새 Replacer를 반환합니다. 대체는 일치하는 항목없이 대상 문자열에 나타나는 순서대로 수행됩니다. 이전 문자열 비교는 인수 순서로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="06ae50f5cf1308acbe8676644fb3a80e68b35dfc" translate="yes" xml:space="preserve">
          <source>NewRequest panics on error for ease of use in testing, where a panic is acceptable.</source>
          <target state="translated">패닉이 허용되는 테스트에서 사용하기 쉽도록 오류에 대한 패닉을 새로 요청합니다.</target>
        </trans-unit>
        <trans-unit id="dbad5b531961f7dd8c542979ba9a9f6fb56fe9e3" translate="yes" xml:space="preserve">
          <source>NewRequest returns a new incoming server Request, suitable for passing to an http.Handler for testing.</source>
          <target state="translated">NewRequest는 테스트를 위해 http.Handler로 전달하기에 적합한 새로운 수신 서버 요청을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="5c6d605363051e92ce514815fc8e9cdd4cb00b63" translate="yes" xml:space="preserve">
          <source>NewRequest wraps NewRequestWithContext using the background context.</source>
          <target state="translated">NewRequest는 백그라운드 컨텍스트를 사용하여 NewRequestWithContext를 래핑합니다.</target>
        </trans-unit>
        <trans-unit id="9035fed12b576aa1b44e2c5e5447b9c7c51d7382" translate="yes" xml:space="preserve">
          <source>NewRequestWithContext returns a Request suitable for use with Client.Do or Transport.RoundTrip. To create a request for use with testing a Server Handler, either use the NewRequest function in the net/http/httptest package, use ReadRequest, or manually update the Request fields. For an outgoing client request, the context controls the entire lifetime of a request and its response: obtaining a connection, sending the request, and reading the response headers and body. See the Request type's documentation for the difference between inbound and outbound request fields.</source>
          <target state="translated">NewRequestWithContext는 Client.Do 또는 Transport.RoundTrip과 함께 사용하기에 적합한 Request를 반환합니다. 서버 핸들러 테스트에 사용할 요청을 작성하려면 net / http / httptest 패키지의 NewRequest 함수를 사용하거나 ReadRequest를 사용하거나 요청 필드를 수동으로 업데이트하십시오. 발신 클라이언트 요청의 경우 컨텍스트는 요청의 전체 수명과 응답을 제어합니다. 연결 확보, 요청 전송 및 응답 헤더 및 본문 읽기. 인바운드 요청과 아웃 바운드 요청 필드의 차이점에 대해서는 요청 유형 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1c9af43cdfcafd0e3590f3e143e4db860b3e1b49" translate="yes" xml:space="preserve">
          <source>NewRequestWithContext returns a new Request given a method, URL, and optional body.</source>
          <target state="translated">NewRequestWithContext는 메소드, URL 및 선택적 본문이 지정된 새 요청을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="6032a09b3acaf432867b7a2e2a1165faa7e1e7a1" translate="yes" xml:space="preserve">
          <source>NewScanner returns a new Scanner to read from r. The split function defaults to ScanLines.</source>
          <target state="translated">NewScanner는 r에서 읽을 새 스캐너를 반환합니다. 분할 기능은 기본적으로 ScanLines입니다.</target>
        </trans-unit>
        <trans-unit id="95df7c8275be1758c09804f6f255a61f60fde088" translate="yes" xml:space="preserve">
          <source>NewScope creates a new scope nested in the outer scope.</source>
          <target state="translated">NewScope는 외부 범위에 중첩 된 새 범위를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="80fe301e9f5c51453bef4cd9884ae93f5be56853" translate="yes" xml:space="preserve">
          <source>NewScope returns a new, empty scope contained in the given parent scope, if any. The comment is for debugging only.</source>
          <target state="translated">NewScope는 주어진 상위 범위에 포함 된 새로운 빈 범위를 반환합니다 (있는 경우). 주석은 디버깅 전용입니다.</target>
        </trans-unit>
        <trans-unit id="11c7ae4097aa2447e01ff30db2236f8b8bdd3d07" translate="yes" xml:space="preserve">
          <source>NewSectionReader returns a SectionReader that reads from r starting at offset off and stops with EOF after n bytes.</source>
          <target state="translated">NewSectionReader는 오프셋 오프에서 r부터 시작하여 n 바이트 후에 EOF로 중지되는 SectionReader를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="92cc00b8df6d155a718390d6b132a73074091695" translate="yes" xml:space="preserve">
          <source>NewServeMux allocates and returns a new ServeMux.</source>
          <target state="translated">NewServeMux는 새로운 ServeMux를 할당하고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f4c25e90df416fbb8a0117d35fe5407fe24aa713" translate="yes" xml:space="preserve">
          <source>NewServer returns a new Server.</source>
          <target state="translated">NewServer는 새 서버를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="babde56071601a12e116397bafca814c40fa7cd4" translate="yes" xml:space="preserve">
          <source>NewServer starts and returns a new Server. The caller should call Close when finished, to shut it down.</source>
          <target state="translated">NewServer가 시작되고 새 서버를 반환합니다. 호출자가 종료되면 닫기를 호출하여 종료해야합니다.</target>
        </trans-unit>
        <trans-unit id="c2a60c8cf74ea37683e9a87d1c42a435ef059ce9" translate="yes" xml:space="preserve">
          <source>NewServerCodec returns a new rpc.ServerCodec using JSON-RPC on conn.</source>
          <target state="translated">NewServerCodec는 conn에서 JSON-RPC를 사용하여 새로운 rpc.ServerCodec을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8ce930cf303061e4c3d16d518dfb921dd3f19755" translate="yes" xml:space="preserve">
          <source>NewServerConn is an artifact of Go's early HTTP implementation. It is low-level, old, and unused by Go's current HTTP stack. We should have deleted it before Go 1.</source>
          <target state="translated">NewServerConn은 Go의 초기 HTTP 구현의 인공물입니다. Go의 현재 HTTP 스택에서 저수준이며 오래되었으며 사용되지 않습니다. Go 1 전에 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="af189f332f7b93936d5df009ddc216614f2c215d" translate="yes" xml:space="preserve">
          <source>NewSignature returns a new function type for the given receiver, parameters, and results, either of which may be nil. If variadic is set, the function is variadic, it must have at least one parameter, and the last parameter must be of unnamed slice type.</source>
          <target state="translated">NewSignature는 지정된 수신자, 매개 변수 및 결과에 대해 새 함수 유형을 리턴하며, 둘 중 하나는 nil 일 수 있습니다. variadic이 설정되면 함수는 variadic이고, 하나 이상의 매개 변수를 가져야하며 마지막 매개 변수는 이름이없는 슬라이스 유형이어야합니다.</target>
        </trans-unit>
        <trans-unit id="f456531de00193a99678056eea0c8fcdbfa6dfa5" translate="yes" xml:space="preserve">
          <source>NewSingleHostReverseProxy returns a new ReverseProxy that routes URLs to the scheme, host, and base path provided in target. If the target's path is &quot;/base&quot; and the incoming request was for &quot;/dir&quot;, the target request will be for /base/dir. NewSingleHostReverseProxy does not rewrite the Host header. To rewrite Host headers, use ReverseProxy directly with a custom Director policy.</source>
          <target state="translated">NewSingleHostReverseProxy는 URL을 대상에 제공된 체계, 호스트 및 기본 경로로 라우팅하는 새로운 ReverseProxy를 반환합니다. 대상의 경로가 &quot;/ base&quot;이고 수신 요청이 &quot;/ dir&quot;인 ​​경우 대상 요청은 / base / dir입니다. NewSingleHostReverseProxy는 호스트 헤더를 다시 쓰지 않습니다. 호스트 헤더를 다시 쓰려면 사용자 지정 디렉터 정책과 함께 ReverseProxy를 직접 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="881af40d9181550600eb2130180e0aa0b7ef4fc9" translate="yes" xml:space="preserve">
          <source>NewSlice returns a new slice type for the given element type.</source>
          <target state="translated">NewSlice는 주어진 요소 유형에 대해 새로운 슬라이스 유형을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e721e99b1b2d7da11daa968d62a8bde773167ca1" translate="yes" xml:space="preserve">
          <source>NewSource returns a new pseudo-random Source seeded with the given value. Unlike the default Source used by top-level functions, this source is not safe for concurrent use by multiple goroutines.</source>
          <target state="translated">NewSource는 주어진 값으로 시드 된 새로운 의사 랜덤 소스를 반환합니다. 최상위 기능에서 사용하는 기본 소스와 달리이 소스는 여러 고 루틴이 동시에 사용하기에 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2632cf950aa513ee1017bf4dcbadbfbcd59a77fb" translate="yes" xml:space="preserve">
          <source>NewStruct returns a new struct with the given fields and corresponding field tags. If a field with index i has a tag, tags[i] must be that tag, but len(tags) may be only as long as required to hold the tag with the largest index i. Consequently, if no field has a tag, tags may be nil.</source>
          <target state="translated">NewStruct는 주어진 필드와 해당 필드 태그가있는 새 구조체를 반환합니다. 인덱스 i가있는 필드에 태그가있는 경우 tags [i]는 해당 태그 여야하지만 len (tags)은 인덱스 i가 가장 큰 태그를 보유하는 데 필요한 길이만큼만있을 수 있습니다. 따라서 태그가있는 필드가 없으면 태그가 nil 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="103ea95c3f50f8126d8830a74f99ac0e3f79bcc5" translate="yes" xml:space="preserve">
          <source>NewSyscallError returns, as an error, a new SyscallError with the given system call name and error details. As a convenience, if err is nil, NewSyscallError returns nil.</source>
          <target state="translated">NewSyscallError는 지정된 시스템 호출 이름 및 오류 세부 사항을 가진 새 SyscallError를 오류로 리턴합니다. 편의상 err이 nil이면 NewSyscallError는 nil을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="15af8e116827b7526d8d125b743d53ce97e9ccf0" translate="yes" xml:space="preserve">
          <source>NewTLSServer</source>
          <target state="translated">NewTLSServer</target>
        </trans-unit>
        <trans-unit id="ee9c0929ee87d66c85d071ce6743847eebd27e1d" translate="yes" xml:space="preserve">
          <source>NewTLSServer starts and returns a new Server using TLS. The caller should call Close when finished, to shut it down.</source>
          <target state="translated">NewTLSServer는 TLS를 사용하여 새 서버를 시작하고 리턴합니다. 호출자가 종료되면 닫기를 호출하여 종료해야합니다.</target>
        </trans-unit>
        <trans-unit id="00d18b3ba661f69ed9cfe9015dd706b999fa00de" translate="yes" xml:space="preserve">
          <source>NewTable decodes the Go symbol table (the &quot;.gosymtab&quot; section in ELF), returning an in-memory representation. Starting with Go 1.3, the Go symbol table no longer includes symbol data.</source>
          <target state="translated">NewTable은 이동 기호 표 (ELF의 &quot;.gosymtab&quot;섹션)를 디코딩하여 메모리 내 표현을 반환합니다. Go 1.3부터 ​​Go 심볼 테이블에는 더 이상 심볼 데이터가 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6c3faf897ce3b4d9467485319643370fa9199652" translate="yes" xml:space="preserve">
          <source>NewTask creates a task instance with the type taskType and returns it along with a Context that carries the task. If the input context contains a task, the new task is its subtask.</source>
          <target state="translated">NewTask는 taskType 유형의 태스크 인스턴스를 작성하고 태스크를 전달하는 컨텍스트와 함께이를 리턴합니다. 입력 컨텍스트에 작업이 포함 된 경우 새 작업은 해당 하위 작업입니다.</target>
        </trans-unit>
        <trans-unit id="b8fb5e998a5bfa39f457a0e00d00ff8fbdd42ef8" translate="yes" xml:space="preserve">
          <source>NewTicker</source>
          <target state="translated">NewTicker</target>
        </trans-unit>
        <trans-unit id="eee251daae31d5716c4903a076b81feb4bcdc3be" translate="yes" xml:space="preserve">
          <source>NewTicker returns a new Ticker containing a channel that will send the time on the channel after each tick. The period of the ticks is specified by the duration argument. The ticker will adjust the time interval or drop ticks to make up for slow receivers. The duration d must be greater than zero; if not, NewTicker will panic. Stop the ticker to release associated resources.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b035640e964a55296a2efb5506fa864ce9c9bfff" translate="yes" xml:space="preserve">
          <source>NewTicker returns a new Ticker containing a channel that will send the time with a period specified by the duration argument. It adjusts the intervals or drops ticks to make up for slow receivers. The duration d must be greater than zero; if not, NewTicker will panic. Stop the ticker to release associated resources.</source>
          <target state="translated">NewTicker는 duration 인수로 지정된 기간으로 시간을 보내는 채널이 포함 된 새 티커를 반환합니다. 느린 수신기를 위해 간격을 조정하거나 틱을 떨어 뜨립니다. 지속 시간 d는 0보다 커야합니다. 그렇지 않으면 NewTicker가 패닉 상태가됩니다. 관련 리소스를 해제하려면 티커를 중지하십시오.</target>
        </trans-unit>
        <trans-unit id="bf6547887c37f917a009906b59fe98e227a67450" translate="yes" xml:space="preserve">
          <source>NewTimer creates a new Timer that will send the current time on its channel after at least duration d.</source>
          <target state="translated">NewTimer는 최소한 지속 시간이 지난 후 채널에서 현재 시간을 보내는 새 타이머를 만듭니다. d.</target>
        </trans-unit>
        <trans-unit id="09aa7464c6b6cfad4c77e4bd499188c3746a2702" translate="yes" xml:space="preserve">
          <source>NewTokenDecoder creates a new XML parser using an underlying token stream.</source>
          <target state="translated">NewTokenDecoder는 기본 토큰 스트림을 사용하여 새 XML 파서를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="4a23d472e6b06cb6e963edf429927add90a46a91" translate="yes" xml:space="preserve">
          <source>NewTripleDESCipher</source>
          <target state="translated">NewTripleDESCipher</target>
        </trans-unit>
        <trans-unit id="84af04213903c43ab9d1e733d66e68af85c238b7" translate="yes" xml:space="preserve">
          <source>NewTripleDESCipher creates and returns a new cipher.Block.</source>
          <target state="translated">NewTripleDESCipher는 새로운 암호를 생성하고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f40b69134a3f0736deea2eaa2750678b0c5b55ae" translate="yes" xml:space="preserve">
          <source>NewTuple returns a new tuple for the given variables.</source>
          <target state="translated">NewTuple은 주어진 변수에 대한 새로운 튜플을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c765721cc8a5281c315a4053b16ddc74c0799a82" translate="yes" xml:space="preserve">
          <source>NewTypeName returns a new type name denoting the given typ. The remaining arguments set the attributes found with all Objects.</source>
          <target state="translated">NewTypeName은 지정된 유형을 나타내는 새 유형 이름을 반환합니다. 나머지 인수는 모든 객체에서 찾은 속성을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="389032a37584685bd3442905ff3d707a5dc68c23" translate="yes" xml:space="preserve">
          <source>NewUniform returns a new Uniform image of the given color.</source>
          <target state="translated">NewUniform은 주어진 색상의 새로운 Uniform 이미지를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fc82f99da3f381417b3f2ddf213f8678bc887a05" translate="yes" xml:space="preserve">
          <source>NewUnstartedServer returns a new Server but doesn't start it.</source>
          <target state="translated">NewUnstartedServer는 새 서버를 반환하지만 시작하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="077e4a879a7f7aeb3402f9e60fcfed25d2f462f1" translate="yes" xml:space="preserve">
          <source>NewVar returns a new variable. The arguments set the attributes found with all Objects.</source>
          <target state="translated">NewVar는 새 변수를 반환합니다. 인수는 모든 객체에서 찾은 속성을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="931cae5ffd260d5017ab39bc76af1f4af39d3c45" translate="yes" xml:space="preserve">
          <source>NewWriteLogger returns a writer that behaves like w except that it logs (using log.Printf) each write to standard error, printing the prefix and the hexadecimal data written.</source>
          <target state="translated">NewWriteLogger는 각 쓰기를 표준 오류에 기록하고 (log.Printf를 사용하여) 기록 된 접두사와 16 진 데이터를 인쇄한다는 점을 제외하고 w와 같이 작동하는 기록기를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="32dc084c221b7ac68250900d07e80ef98477176c" translate="yes" xml:space="preserve">
          <source>NewWriter</source>
          <target state="translated">NewWriter</target>
        </trans-unit>
        <trans-unit id="db406b8d211203f1503f7b49dc65e93e6c1d2ac9" translate="yes" xml:space="preserve">
          <source>NewWriter allocates and initializes a new tabwriter.Writer. The parameters are the same as for the Init function.</source>
          <target state="translated">NewWriter는 새 tabwriter.Writer를 할당하고 초기화합니다. 파라미터는 초기화 기능과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="eb99a0a4fd37c15275e7565ffb0b13403d80a96e" translate="yes" xml:space="preserve">
          <source>NewWriter creates a new Writer writing to w.</source>
          <target state="translated">NewWriter는 w에 새 Writer를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="3c66bbe4244d139551b9b86abb1f943bea6cca3c" translate="yes" xml:space="preserve">
          <source>NewWriter creates a new Writer. Writes to the returned Writer are compressed and written to w.</source>
          <target state="translated">NewWriter는 새로운 작가를 만듭니다. 리턴 된 Writer에 대한 쓰기는 압축되어 w에 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="6d237dd5c37ca4fbda972f04e6f597bc8e44916c" translate="yes" xml:space="preserve">
          <source>NewWriter creates a new io.WriteCloser. Writes to the returned io.WriteCloser are compressed and written to w. It is the caller's responsibility to call Close on the WriteCloser when finished writing. The number of bits to use for literal codes, litWidth, must be in the range [2,8] and is typically 8. Input bytes must be less than 1&amp;lt;&amp;lt;litWidth.</source>
          <target state="translated">NewWriter는 새로운 io.WriteCloser를 만듭니다. 반환 된 io.WriteCloser에 기록하고 w에 기록합니다. 쓰기가 끝나면 WriteCloser에서 Close를 호출하는 것은 호출자의 책임입니다. 리터럴 코드에 사용할 비트 수인 litWidth는 [2,8] 범위에 있어야하며 일반적으로 8입니다. 입력 바이트는 1 &amp;lt;&amp;lt; litWidth보다 작아야합니다.</target>
        </trans-unit>
        <trans-unit id="5d8c71239de18e81bb2408f6be3d174f8b53cc5b" translate="yes" xml:space="preserve">
          <source>NewWriter returns a new Writer compressing data at the given level. Following zlib, levels range from 1 (BestSpeed) to 9 (BestCompression); higher levels typically run slower but compress more. Level 0 (NoCompression) does not attempt any compression; it only adds the necessary DEFLATE framing. Level -1 (DefaultCompression) uses the default compression level. Level -2 (HuffmanOnly) will use Huffman compression only, giving a very fast compression for all types of input, but sacrificing considerable compression efficiency.</source>
          <target state="translated">NewWriter는 주어진 수준에서 데이터를 압축하는 새로운 Writer를 반환합니다. zlib에 이어 레벨의 범위는 1 (BestSpeed)에서 9 (BestCompression)입니다. 높은 수준은 일반적으로 느리게 실행되지만 더 많이 압축합니다. 레벨 0 (NoCompression)은 압축을 시도하지 않습니다. 필요한 DEFLATE 프레이밍 만 추가합니다. Level -1 (DefaultCompression)은 기본 압축 수준을 사용합니다. 레벨 -2 (HuffmanOnly)는 Huffman 압축 만 사용하므로 모든 유형의 입력에 대해 매우 빠른 압축을 제공하지만 상당한 압축 효율을 희생합니다.</target>
        </trans-unit>
        <trans-unit id="77a9ef9463dc28c378543b4ca1ab833768dcb916" translate="yes" xml:space="preserve">
          <source>NewWriter returns a new Writer that writes to w.</source>
          <target state="translated">NewWriter는 w에 쓰는 새 Writer를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6ed1faccc6afb2894578d5ce15a1b66df2ed7562" translate="yes" xml:space="preserve">
          <source>NewWriter returns a new Writer whose buffer has the default size.</source>
          <target state="translated">NewWriter는 버퍼의 기본 크기가 새로운 Writer를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="28df5b8c07e84a79a10bcd4ad1689f3c9f232d1d" translate="yes" xml:space="preserve">
          <source>NewWriter returns a new Writer writing a zip file to w.</source>
          <target state="translated">NewWriter는 zip 파일을 쓰는 새로운 Writer를 w에 반환합니다.</target>
        </trans-unit>
        <trans-unit id="15d873b5f31a0567bb2f33a96b73193d43330bbf" translate="yes" xml:space="preserve">
          <source>NewWriter returns a new Writer writing to w.</source>
          <target state="translated">NewWriter는 새로운 Writer writing을 w에 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8553cec920a1bbc2b884d29ae54a45cdb28b9a7f" translate="yes" xml:space="preserve">
          <source>NewWriter returns a new Writer. Writes to the returned writer are compressed and written to w.</source>
          <target state="translated">NewWriter는 새로운 Writer를 반환합니다. 리턴 된 기록기에 대한 쓰기는 압축되어 w에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="41a8b4d0cc45c1f4744d9ed11afc5cc850ba9075" translate="yes" xml:space="preserve">
          <source>NewWriter returns a new multipart Writer with a random boundary, writing to w.</source>
          <target state="translated">NewWriter는 w에 쓰는 임의의 경계를 가진 새로운 multipart Writer를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ba4df4f4844996231636be43db04ad5d9a575122" translate="yes" xml:space="preserve">
          <source>NewWriterDict is like NewWriter but initializes the new Writer with a preset dictionary. The returned Writer behaves as if the dictionary had been written to it without producing any compressed output. The compressed data written to w can only be decompressed by a Reader initialized with the same dictionary.</source>
          <target state="translated">NewWriterDict는 NewWriter와 비슷하지만 사전 설정 사전을 사용하여 새 Writer를 초기화합니다. 리턴 된 Writer는 압축 된 출력을 생성하지 않고 사전이 작성된 것처럼 작동합니다. w에 기록 된 압축 데이터는 동일한 사전으로 초기화 된 Reader를 통해서만 압축 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d66b95134ebabf02390f85e665bafa07e307f028" translate="yes" xml:space="preserve">
          <source>NewWriterLevel is like NewWriter but specifies the compression level instead of assuming DefaultCompression.</source>
          <target state="translated">NewWriterLevel은 NewWriter와 비슷하지만 DefaultCompression을 가정하는 대신 압축 수준을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="2244762bcd986f7cb2bc9adec833aa8f04c34752" translate="yes" xml:space="preserve">
          <source>NewWriterLevelDict is like NewWriterLevel but specifies a dictionary to compress with.</source>
          <target state="translated">NewWriterLevelDict는 NewWriterLevel과 비슷하지만 압축 할 사전을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="fba4df7d4f867ec10b6be90ace669ea6f21a1c64" translate="yes" xml:space="preserve">
          <source>NewWriterSize returns a new Writer whose buffer has at least the specified size. If the argument io.Writer is already a Writer with large enough size, it returns the underlying Writer.</source>
          <target state="translated">NewWriterSize는 버퍼가 지정된 크기 이상인 새 작성기를 반환합니다. io.Writer 인수가 이미 충분히 큰 크기의 Writer 인 경우 기본 Writer를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6a8e1967a776dd6bc255e00e323e531b785051db" translate="yes" xml:space="preserve">
          <source>NewYCbCr returns a new YCbCr image with the given bounds and subsample ratio.</source>
          <target state="translated">NewYCbCr은 주어진 범위와 서브 샘플 비율로 새로운 YCbCr 이미지를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="24448d424137595a3746992f824b6edb3b30eda0" translate="yes" xml:space="preserve">
          <source>NewZipf returns a Zipf variate generator. The generator generates values k &amp;isin; [0, imax] such that P(k) is proportional to (v + k) ** (-s). Requirements: s &amp;gt; 1 and v &amp;gt;= 1.</source>
          <target state="translated">NewZipf는 Zipf 변형 생성기를 반환합니다. 발생기는 P (k)가 (v + k) ** (-s)에 비례하도록 k &amp;isin; [0, imax] 값을 생성합니다. 요구 사항 : s&amp;gt; 1 및 v&amp;gt; = 1.</target>
        </trans-unit>
        <trans-unit id="7ce32fccbc1a59952ff2a17d5ecf204917f2f0f8" translate="yes" xml:space="preserve">
          <source>Newlines and commas may be included in a quoted-field</source>
          <target state="translated">줄 바꿈과 쉼표는 인용 필드에 포함될 수 있습니다</target>
        </trans-unit>
        <trans-unit id="680ad9f662c74a9364f8a6a8275f58c7b8082fcd" translate="yes" xml:space="preserve">
          <source>Next advances the map iterator and reports whether there is another entry. It returns false when the iterator is exhausted; subsequent calls to Key, Value, or Next will panic.</source>
          <target state="translated">다음으로 맵 반복기를 진행시키고 다른 항목이 있는지보고합니다. 반복자가 소진되면 false를 리턴합니다. 이후에 Key, Value 또는 Next를 호출하면 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="a3886733d4cb9e8e0a30e9e159418bfd55e791d5" translate="yes" xml:space="preserve">
          <source>Next advances to the next entry in the tar archive. The Header.Size determines how many bytes can be read for the next file. Any remaining data in the current file is automatically discarded.</source>
          <target state="translated">다음은 tar 아카이브의 다음 항목으로 진행합니다. Header.Size는 다음 파일에 대해 읽을 수있는 바이트 수를 결정합니다. 현재 파일에 남아있는 모든 데이터는 자동으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="4901308d5dc25a2990110e9739d7a18a2e5ad01b" translate="yes" xml:space="preserve">
          <source>Next prepares the next result row for reading with the Scan method. It returns true on success, or false if there is no next result row or an error happened while preparing it. Err should be consulted to distinguish between the two cases.</source>
          <target state="translated">다음은 스캔 방법으로 읽을 다음 결과 행을 준비합니다. 성공하면 true를 반환하고 다음 결과 행이 없거나 준비하는 동안 오류가 발생하면 false를 반환합니다. 두 경우를 구별하기 위해 Err을 참조해야합니다.</target>
        </trans-unit>
        <trans-unit id="4b13fef4541a1e8d67cdfed20bd2375d09afaf54" translate="yes" xml:space="preserve">
          <source>Next reads and returns the next Unicode character. It returns EOF at the end of the source. It reports a read error by calling s.Error, if not nil; otherwise it prints an error message to os.Stderr. Next does not update the Scanner's Position field; use Pos() to get the current position.</source>
          <target state="translated">다음은 다음 유니 코드 문자를 읽고 반환합니다. 소스의 끝에 EOF를 리턴합니다. nil이 아닌 경우 s.Error를 호출하여 읽기 오류를보고합니다. 그렇지 않으면 오류 메시지를 os.Stderr에 인쇄합니다. 다음은 스캐너 위치 필드를 업데이트하지 않습니다. 현재 위치를 얻으려면 Pos ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f9300d09b7df4ad5d5720f19adfdc038ac61f1df" translate="yes" xml:space="preserve">
          <source>Next reads the next entry from the encoded entry stream. It returns nil, nil when it reaches the end of the section. It returns an error if the current offset is invalid or the data at the offset cannot be decoded as a valid Entry.</source>
          <target state="translated">다음은 인코딩 된 항목 스트림에서 다음 항목을 읽습니다. 섹션의 끝에 도달하면 nil, nil을 리턴합니다. 현재 오프셋이 유효하지 않거나 오프셋의 데이터를 유효한 항목으로 디코딩 할 수없는 경우 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5e6ab5cae4a8ae2aa846c67f99d971fa518e2e06" translate="yes" xml:space="preserve">
          <source>Next reports whether there are more iterations to execute.</source>
          <target state="translated">다음으로 실행할 반복이 더 있는지보고합니다.</target>
        </trans-unit>
        <trans-unit id="93f915543eeb533b1a50713e83a0f24c2c27db55" translate="yes" xml:space="preserve">
          <source>Next returns a slice containing the next n bytes from the buffer, advancing the buffer as if the bytes had been returned by Read. If there are fewer than n bytes in the buffer, Next returns the entire buffer. The slice is only valid until the next call to a read or write method.</source>
          <target state="translated">Next는 버퍼에서 다음 n 바이트를 포함하는 슬라이스를 반환하여 마치 바이트가 Read에 의해 반환 된 것처럼 버퍼를 진행시킵니다. 버퍼에 n 바이트 미만이 있으면 Next는 전체 버퍼를 반환합니다. 슬라이스는 다음에 읽기 또는 쓰기 메소드를 호출 할 때까지만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="c448db08820ee5a2da21a99a2f7ee9ecfecee2a6" translate="yes" xml:space="preserve">
          <source>Next returns frame information for the next caller. If more is false, there are no more callers (the Frame value is valid).</source>
          <target state="translated">다음은 다음 발신자의 프레임 정보를 반환합니다. 더 이상 거짓이면 더 이상 발신자가 없습니다 (프레임 값이 유효 함).</target>
        </trans-unit>
        <trans-unit id="330b3e94c1faae753e446839e4e00b09aaa021f5" translate="yes" xml:space="preserve">
          <source>Next returns the next id for a request/response pair.</source>
          <target state="translated">다음은 요청 / 응답 쌍의 다음 ID를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="31070c09d9898d8d82df0861c7359cedd6d1bee8" translate="yes" xml:space="preserve">
          <source>Next returns the next list element or nil.</source>
          <target state="translated">다음은 다음 목록 요소 또는 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="835c3bdc06b3af77ee23ce1cd0bc1f932319b6e0" translate="yes" xml:space="preserve">
          <source>Next returns the next ring element. r must not be empty.</source>
          <target state="translated">다음은 다음 링 요소를 반환합니다. r은 비워 둘 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3515095d5db1d9b6b3020f18bccf17c7141a06e9" translate="yes" xml:space="preserve">
          <source>Next sets *entry to the next row in this line table and moves to the next row. If there are no more entries and the line table is properly terminated, it returns io.EOF.</source>
          <target state="translated">다음은이 행 테이블에서 * 항목을 다음 행으로 설정하고 다음 행으로 이동합니다. 더 이상 항목이없고 회선 테이블이 올바르게 종료되면 io.EOF를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="59243d78d75adcc23308fcf3c7522b53b0e48d6d" translate="yes" xml:space="preserve">
          <source>NextPart returns the next part in the multipart or an error. When there are no more parts, the error io.EOF is returned.</source>
          <target state="translated">NextPart는 멀티 파트의 다음 파트 또는 오류를 반환합니다. 더 이상 부품이 없으면 오류 io.EOF가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="0b0a0e6bb9ba56ca1889244a65d5fa48810d737e" translate="yes" xml:space="preserve">
          <source>NextRawPart returns the next part in the multipart or an error. When there are no more parts, the error io.EOF is returned.</source>
          <target state="translated">NextRawPart는 다중 부분 또는 오류의 다음 부분을 반환합니다. 부품이 더 이상 없으면 io.EOF 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7fe82d0a11eaa23908a02323edde641d4f84c09e" translate="yes" xml:space="preserve">
          <source>NextResultSet prepares the next result set for reading. It reports whether there is further result sets, or false if there is no further result set or if there is an error advancing to it. The Err method should be consulted to distinguish between the two cases.</source>
          <target state="translated">NextResultSet은 읽을 다음 결과 세트를 준비합니다. 추가 결과 세트가 있는지 여부를보고하거나 추가 결과 세트가 없거나 오류가 발생하면 false를보고합니다. 두 경우를 구별하기 위해 Err 방법을 참고해야합니다.</target>
        </trans-unit>
        <trans-unit id="98468e4766dcce0e39d3ad725e6449c114807ef7" translate="yes" xml:space="preserve">
          <source>Nextafter returns the next representable float64 value after x towards y.</source>
          <target state="translated">Nextafter는 x 다음에 y를 향한 다음 표현 가능한 float64 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="75d1da7ce66cd551626a0d105347dbf7bbebadb0" translate="yes" xml:space="preserve">
          <source>Nextafter32 returns the next representable float32 value after x towards y.</source>
          <target state="translated">Nextafter32는 x 다음에 y를 향한 다음 표현 가능한 float32 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f22ed1e707c4376c926b166081941a42b8018a27" translate="yes" xml:space="preserve">
          <source>Nil represents the predeclared value nil.</source>
          <target state="translated">Nil은 미리 선언 된 값 nil을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7b09d67cac8107c868d3a3b7af77e77ea7720296" translate="yes" xml:space="preserve">
          <source>NilNode holds the special identifier 'nil' representing an untyped nil constant.</source>
          <target state="translated">NilNode는 형식화되지 않은 nil 상수를 나타내는 특수 식별자 'nil'을 보유합니다.</target>
        </trans-unit>
        <trans-unit id="b524d9a99adffa02a516e6aa0d4d13aac2897fdc" translate="yes" xml:space="preserve">
          <source>NoBody is an io.ReadCloser with no bytes. Read always returns EOF and Close always returns nil. It can be used in an outgoing client request to explicitly signal that a request has zero bytes. An alternative, however, is to simply set Request.Body to nil.</source>
          <target state="translated">NoBody는 바이트가없는 io.ReadCloser입니다. 읽기는 항상 EOF를 반환하고 닫기는 항상 nil을 반환합니다. 요청이 0 바이트임을 명시 적으로 알리기 위해 발신 클라이언트 요청에서 사용될 수 있습니다. 그러나 다른 방법은 Request.Body를 nil로 설정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="52ef1a3746a958c4a53a19c9d87395684668883e" translate="yes" xml:space="preserve">
          <source>NoGoError is the error used by Import to describe a directory containing no buildable Go source files. (It may still contain test files, files hidden by build tags, and so on.)</source>
          <target state="translated">NoGoError는 가져 오기에서 빌드 가능한 Go 소스 파일이없는 디렉토리를 설명하기 위해 사용하는 오류입니다. (여전히 테스트 파일, 빌드 태그로 숨겨진 파일 등이 포함될 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="260f7a8cd4f6938b3cc185a619847cb83d670219" translate="yes" xml:space="preserve">
          <source>Node</source>
          <target state="translated">Node</target>
        </trans-unit>
        <trans-unit id="14b0e62d6fc1422eb757516da0b18c46890cfc16" translate="yes" xml:space="preserve">
          <source>Node formats node in canonical gofmt style and writes the result to dst.</source>
          <target state="translated">노드는 표준 gofmt 스타일로 노드를 형식화하고 결과를 dst에 씁니다.</target>
        </trans-unit>
        <trans-unit id="da15215d50f0207cc3f3bf867716d8b653cbbf4d" translate="yes" xml:space="preserve">
          <source>NodeType identifies the type of a parse tree node.</source>
          <target state="translated">NodeType은 구문 분석 트리 노드의 유형을 식별합니다.</target>
        </trans-unit>
        <trans-unit id="b2c069378b3bfe6ff1e505ef1691402f0b8b4e2b" translate="yes" xml:space="preserve">
          <source>Non-Go programs that call Go code</source>
          <target state="translated">Go 코드를 호출하는 비 Go 프로그램</target>
        </trans-unit>
        <trans-unit id="902b501103969363a75f55b1d4ea5e8e3aaa9ff5" translate="yes" xml:space="preserve">
          <source>Non-string values can be used in JavaScript contexts. If {{.}} is</source>
          <target state="translated">문자열이 아닌 값은 JavaScript 컨텍스트에서 사용할 수 있습니다. {{.}}이 (가)</target>
        </trans-unit>
        <trans-unit id="3d2c97b640a04b4cfaa42b436b4f88eedd1e3354" translate="yes" xml:space="preserve">
          <source>Noop sends the NOOP command to the server. It does nothing but check that the connection to the server is okay.</source>
          <target state="translated">Noop은 NOOP 명령을 서버로 보냅니다. 서버에 대한 연결이 올바른지 확인하는 것뿐입니다.</target>
        </trans-unit>
        <trans-unit id="85cca9a9c13590980a1e26da797767deb94d87fd" translate="yes" xml:space="preserve">
          <source>NopCloser returns a ReadCloser with a no-op Close method wrapping the provided Reader r.</source>
          <target state="translated">NopCloser는 제공된 리더 r을 랩핑하지 않은 Close 메소드가없는 ReadCloser를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7bc360841341e5ff79e2d9db0ccaba1681a641e9" translate="yes" xml:space="preserve">
          <source>NormFloat64 returns a normally distributed float64 in the range -math.MaxFloat64 through +math.MaxFloat64 inclusive, with standard normal distribution (mean = 0, stddev = 1). To produce a different normal distribution, callers can adjust the output using:</source>
          <target state="translated">NormFloat64는 표준 정규 분포 (평균 = 0, stddev = 1)와 함께 -math.MaxFloat64에서 + math.MaxFloat64 범위의 정규 분포 float64를 반환합니다. 다른 정규 분포를 생성하기 위해 호출자는 다음을 사용하여 출력을 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="584a03e17a58b140265f4319a3b8d37d0b326573" translate="yes" xml:space="preserve">
          <source>NormFloat64 returns a normally distributed float64 in the range [-math.MaxFloat64, +math.MaxFloat64] with standard normal distribution (mean = 0, stddev = 1) from the default Source. To produce a different normal distribution, callers can adjust the output using:</source>
          <target state="translated">NormFloat64는 기본 소스에서 표준 정규 분포 (평균 = 0, stddev = 1)를 사용하여 [-math.MaxFloat64, + math.MaxFloat64] 범위의 정규 분포 float64를 반환합니다. 다른 정규 분포를 생성하기 위해 호출자는 다음을 사용하여 출력을 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16ef8f27fb77f3e3923ae623df4ac9f719342330" translate="yes" xml:space="preserve">
          <source>Not all drivers and databases support OUTPUT value parameters.</source>
          <target state="translated">모든 드라이버와 데이터베이스가 OUTPUT 값 매개 변수를 지원하는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="28197ebc86a75fec0d20747340a0a7790f4e6e65" translate="yes" xml:space="preserve">
          <source>Not all methods apply to all kinds of types. Restrictions, if any, are noted in the documentation for each method. Use the Kind method to find out the kind of type before calling kind-specific methods. Calling a method inappropriate to the kind of type causes a run-time panic.</source>
          <target state="translated">모든 방법이 모든 종류의 유형에 적용되는 것은 아닙니다. 제한 사항이있는 경우 각 방법에 대한 설명서에 명시되어 있습니다. 종류별 메서드를 호출하기 전에 Kind 메서드를 사용하여 종류를 확인하십시오. 종류에 맞지 않는 메서드를 호출하면 런타임 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="aebe464c9e025a8d065addc9b1418e295beb91ab" translate="yes" xml:space="preserve">
          <source>Not all methods apply to all kinds of values. Restrictions, if any, are noted in the documentation for each method. Use the Kind method to find out the kind of value before calling kind-specific methods. Calling a method inappropriate to the kind of type causes a run time panic.</source>
          <target state="translated">모든 방법이 모든 종류의 값에 적용되는 것은 아닙니다. 제한 사항이있는 경우 각 방법에 대한 설명서에 명시되어 있습니다. 종류별 메서드를 호출하기 전에 Kind 메서드를 사용하여 종류의 값을 찾으십시오. 이런 종류의 유형에 부적절한 메서드를 호출하면 런타임 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0ad6482316efeb0367fac0cef294df9931657e21" translate="yes" xml:space="preserve">
          <source>Not sets z = ^x and returns z.</source>
          <target state="translated">z = ^ x를 설정하지 않고 z를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7742382b9eb1d24a7003bcf20989045729354b55" translate="yes" xml:space="preserve">
          <source>NotFound replies to the request with an HTTP 404 not found error.</source>
          <target state="translated">NotFound는 HTTP 404를 찾을 수 없음 오류와 함께 요청에 응답합니다.</target>
        </trans-unit>
        <trans-unit id="d73243f8dff55155dc23697de39081a99659e339" translate="yes" xml:space="preserve">
          <source>NotFoundHandler</source>
          <target state="translated">NotFoundHandler</target>
        </trans-unit>
        <trans-unit id="4cb94eae88a4f55a499c64d3eb533d60d5f636a3" translate="yes" xml:space="preserve">
          <source>NotFoundHandler returns a simple request handler that replies to each request with a &amp;ldquo;404 page not found&amp;rdquo; reply.</source>
          <target state="translated">NotFoundHandler는 &quot;404 페이지를 찾을 수 없음&quot;응답으로 각 요청에 응답하는 간단한 요청 핸들러를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="fa1f72946015817c3defa6f9ca3e62b13a4cbe23" translate="yes" xml:space="preserve">
          <source>NotNilFilter returns true for field values that are not nil; it returns false otherwise.</source>
          <target state="translated">NotNilFilter는 nil이 아닌 필드 값에 대해 true를 리턴합니다. 그렇지 않으면 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="48697afd9134ab8c796d4134241a98bd8c0e1e0e" translate="yes" xml:space="preserve">
          <source>NotNull is a type that implements ValueConverter by disallowing nil values but otherwise delegating to another ValueConverter.</source>
          <target state="translated">NotNull은 nil 값을 허용하지 않지만 다른 ValueConverter에 위임하여 ValueConverter를 구현하는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="ea5ffd3d5d924f61e0aab5c8328c4565de280e8f" translate="yes" xml:space="preserve">
          <source>Notational convention: Incoming method parameters (including the receiver) are named consistently in the API to clarify their use. Incoming operands are usually named x, y, a, b, and so on, but never z. A parameter specifying the result is named z (typically the receiver).</source>
          <target state="translated">표기법 : 수신 메소드 매개 변수 (수신자 포함)는 API에서 일관성있게 이름을 지정하여 사용법을 명확하게합니다. 들어오는 피연산자는 일반적으로 x, y, a, b 등으로 이름이 지정되지만 z는 지정되지 않습니다. 결과를 지정하는 매개 변수의 이름은 z (일반적으로 수신자)입니다.</target>
        </trans-unit>
        <trans-unit id="08dfc0b4556c0a1e642330802e9a9fdabdeafde7" translate="yes" xml:space="preserve">
          <source>Note that *os.File implements the io.ReadSeeker interface.</source>
          <target state="translated">* os.File은 io.ReadSeeker 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="c7438b24f5f10d8ed5111e3a3eeea38cdce805d1" translate="yes" xml:space="preserve">
          <source>Note that DWARF line tables only permit sequential, forward scans. Hence, in the worst case, this takes time linear in the size of the line table. If the caller wishes to do repeated fast PC lookups, it should build an appropriate index of the line table.</source>
          <target state="translated">DWARF 라인 테이블은 순방향 순방향 스캔 만 허용합니다. 따라서 최악의 경우 라인 테이블의 크기에서 시간이 선형으로 걸립니다. 발신자가 빠른 PC 검색을 반복하려면 적절한 회선 테이블 색인을 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="1708406405db2b0b3521a819d371938a3ec0fc07" translate="yes" xml:space="preserve">
          <source>Note that Dir could expose sensitive files and directories. Dir will follow symlinks pointing out of the directory tree, which can be especially dangerous if serving from a directory in which users are able to create arbitrary symlinks. Dir will also allow access to files and directories starting with a period, which could expose sensitive directories like .git or sensitive files like .htpasswd. To exclude files with a leading period, remove the files/directories from the server or create a custom FileSystem implementation.</source>
          <target state="translated">Dir는 민감한 파일과 디렉토리를 노출 할 수 있습니다. Dir는 디렉토리 트리를 가리키는 심볼릭 링크를 따르며, 이는 사용자가 임의의 심볼릭 링크를 생성 할 수있는 디렉토리에서 제공하는 경우 특히 위험 할 수 있습니다. Dir는 마침표로 시작하는 파일 및 디렉토리에 대한 액세스도 허용합니다.이 경우 .git과 같은 민감한 디렉토리 또는 .htpasswd와 같은 민감한 파일이 노출 될 수 있습니다. 선행 마침표가있는 파일을 제외하려면 서버에서 파일 / 디렉터리를 제거하거나 사용자 지정 파일 시스템 구현을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="d08c2aea787a35db90158742ee5e75a3c73282a4" translate="yes" xml:space="preserve">
          <source>Note that Dir will allow access to files and directories starting with a period, which could expose sensitive directories like a .git directory or sensitive files like .htpasswd. To exclude files with a leading period, remove the files/directories from the server or create a custom FileSystem implementation.</source>
          <target state="translated">Dir은 마침표로 시작하는 파일 및 디렉토리에 대한 액세스를 허용하므로 .git 디렉토리와 같은 민감한 디렉토리 또는 .htpasswd와 같은 민감한 파일을 노출시킬 수 있습니다. 선행 기간이있는 파일을 제외하려면 서버에서 파일 / 디렉토리를 제거하거나 사용자 정의 FileSystem 구현을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="393ff3471e998698fad165109d1597eedb023fa4" translate="yes" xml:space="preserve">
          <source>Note that DirFS(&quot;/prefix&quot;) only guarantees that the Open calls it makes to the operating system will begin with &quot;/prefix&quot;: DirFS(&quot;/prefix&quot;).Open(&quot;file&quot;) is the same as os.Open(&quot;/prefix/file&quot;). So if /prefix/file is a symbolic link pointing outside the /prefix tree, then using DirFS does not stop the access any more than using os.Open does. DirFS is therefore not a general substitute for a chroot-style security mechanism when the directory tree contains arbitrary content.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74976bc5278e7780a62cf9ceb79267a86a939300" translate="yes" xml:space="preserve">
          <source>Note that FIPS 186-3 section 4.6 specifies that the hash should be truncated to the byte-length of the subgroup. This function does not perform that truncation itself.</source>
          <target state="translated">FIPS 186-3 섹션 4.6은 해시가 하위 그룹의 바이트 길이로 잘 리도록 지정합니다. 이 기능은 해당 잘림 자체를 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bbf97d3b36e492a77bf717cf84e9406daab3263a" translate="yes" xml:space="preserve">
          <source>Note that Init may call err if there is an error in the first character of the file.</source>
          <target state="translated">파일의 첫 문자에 오류가 있으면 Init에서 err을 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a0c39680eb9df4d26108a728fd58d66d7905a72" translate="yes" xml:space="preserve">
          <source>Note that LineContinuations are not allowed. JSStr(&quot;foo\\nbar&quot;) is fine, but JSStr(&quot;foo\\\nbar&quot;) is not.</source>
          <target state="translated">LineContinuations는 허용되지 않습니다. JSStr ( &quot;foo \\ nbar&quot;)는 괜찮지 만 JSStr ( &quot;foo \\\ nbar&quot;)는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fa1d78ad1e16f8cfce0fba38b7b9641b9c047419" translate="yes" xml:space="preserve">
          <source>Note that ListenMulticastUDP will set the IP_MULTICAST_LOOP socket option to 0 under IPPROTO_IP, to disable loopback of multicast packets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b706c905f9e49dd39547ae798a12e332969a754b" translate="yes" xml:space="preserve">
          <source>Note that Push and Pop in this interface are for package heap's implementation to call. To add and remove things from the heap, use heap.Push and heap.Pop.</source>
          <target state="translated">이 인터페이스의 Push 및 Pop은 패키지 힙 구현을 호출하기위한 것입니다. 힙에서 항목을 추가하고 제거하려면 heap.Push 및 heap.Pop을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2ac58c63ec2feb638471975be648c8926228c666" translate="yes" xml:space="preserve">
          <source>Note that Sub(os.DirFS(&quot;/&quot;), &quot;prefix&quot;) is equivalent to os.DirFS(&quot;/prefix&quot;) and that neither of them guarantees to avoid operating system accesses outside &quot;/prefix&quot;, because the implementation of os.DirFS does not check for symbolic links inside &quot;/prefix&quot; that point to other directories. That is, os.DirFS is not a general substitute for a chroot-style security mechanism, and Sub does not change that fact.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57724cba67b0754543683d705a43db50bcf5c63d" translate="yes" xml:space="preserve">
          <source>Note that both conversions must appear in the same expression, with only the intervening arithmetic between them:</source>
          <target state="translated">두 변환은 모두 같은 식으로 나타나야하며 그 사이에 산술 연산 만 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="00d2f4b507ea636132af470ff7c66414d9db9755" translate="yes" xml:space="preserve">
          <source>Note that calls with a positive delta that occur when the counter is zero must happen before a Wait. Calls with a negative delta, or calls with a positive delta that start when the counter is greater than zero, may happen at any time. Typically this means the calls to Add should execute before the statement creating the goroutine or other event to be waited for. If a WaitGroup is reused to wait for several independent sets of events, new Add calls must happen after all previous Wait calls have returned. See the WaitGroup example.</source>
          <target state="translated">카운터가 0 일 때 발생하는 양의 델타가있는 호출은 대기 전에 발생해야합니다. 음수가 델타 인 통화 또는 카운터가 0보다 클 때 시작하는 플러스 델타 인 통화는 언제든지 발생할 수 있습니다. 일반적으로 이것은 goroutine 또는 대기 할 다른 이벤트를 작성하는 명령문 전에 Add 호출이 실행되어야 함을 의미합니다. WaitGroup이 여러 개의 독립적 인 이벤트 세트를 기다리는 데 재사용되는 경우, 모든 이전 대기 호출이 리턴 된 후 새로운 추가 호출이 발생해야합니다. WaitGroup 예제를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5455acc6a0156c4dfa920acddbd7ebf8cf932467" translate="yes" xml:space="preserve">
          <source>Note that even for ResponseWriters that support Flush, if the client is connected through an HTTP proxy, the buffered data may not reach the client until the response completes.</source>
          <target state="translated">Flush를 지원하는 ResponseWriter의 경우에도 클라이언트가 HTTP 프록시를 통해 연결된 경우 응답이 완료 될 때까지 버퍼링 된 데이터가 클라이언트에 도달하지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64cbc1b328d9716763cd1ed4ffd9ce9462300826" translate="yes" xml:space="preserve">
          <source>Note that for the CHAR and STRING kinds, the literal is stored with its quotes. For example, for a double-quoted STRING, the first and the last rune in the Value field will be &quot;. The Unquote and UnquoteChar functions in the strconv package can be used to unquote STRING and CHAR values, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c3bd0ea640e306f27d50ba34f2f7b783e999786" translate="yes" xml:space="preserve">
          <source>Note that formatting of Go source code changes over time, so tools relying on consistent formatting should execute a specific version of the gofmt binary instead of using this package. That way, the formatting will be stable, and the tools won't need to be recompiled each time gofmt changes.</source>
          <target state="translated">Go 소스 코드의 형식은 시간이 지남에 따라 변경되므로 일관된 형식을 사용하는 도구는이 패키지를 사용하는 대신 특정 버전의 gofmt 바이너리를 실행해야합니다. 이렇게하면 서식이 안정적이되고 변경 될 때마다 도구를 다시 컴파일 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e22ab49cba234a39b62136e423150811ceaf9eb2" translate="yes" xml:space="preserve">
          <source>Note that if len(b) == 0 and len(oob) &amp;gt; 0, this function will still read (and discard) 1 byte from the connection.</source>
          <target state="translated">len (b) == 0 및 len (oob)&amp;gt; 0 인 경우이 함수는 여전히 연결에서 1 바이트를 읽고 버립니다.</target>
        </trans-unit>
        <trans-unit id="1c2f06f3a5255f8d8b8129f0755c03b6610969a5" translate="yes" xml:space="preserve">
          <source>Note that if len(b) == 0 and len(oob) &amp;gt; 0, this function will still write 1 byte to the connection.</source>
          <target state="translated">len (b) == 0이고 len (oob)&amp;gt; 0 인 경우이 함수는 여전히 연결에 1 바이트를 씁니다.</target>
        </trans-unit>
        <trans-unit id="6530be365312a7c4f8e32cd5888520ad9f3f1f1d" translate="yes" xml:space="preserve">
          <source>Note that if the session key is too small then it may be possible for an attacker to brute-force it. If they can do that then they can learn whether a random value was used (because it'll be different for the same ciphertext) and thus whether the padding was correct. This defeats the point of this function. Using at least a 16-byte key will protect against this attack.</source>
          <target state="translated">세션 키가 너무 작 으면 공격자가 무차별 공격을 할 수 있습니다. 그들이 그렇게 할 수 있다면, 임의의 값이 사용되었는지 (같은 암호문에 대해 다르기 때문에) 패딩이 올바른지 여부를 알 수 있습니다. 이것은이 기능의 요점을 무너 뜨립니다. 16 바이트 이상의 키를 사용하면이 공격으로부터 보호 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="344ecaa4cf851728d938597c41196d419ce8996a" translate="yes" xml:space="preserve">
          <source>Note that in this documentation, referring to an IP address as an IPv4 address or an IPv6 address is a semantic property of the address, not just the length of the byte slice: a 16-byte slice can still be an IPv4 address.</source>
          <target state="translated">이 문서에서 IP 주소를 IPv4 주소 또는 IPv6 주소라고하는 것은 바이트 슬라이스의 길이가 아니라 주소의 의미 적 속성입니다. 16 바이트 슬라이스는 여전히 IPv4 주소가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a249db9e2c9671edb18dbf9a7216586dc071e0a3" translate="yes" xml:space="preserve">
          <source>Note that it is not possible to use Reset's return value correctly, as there is a race condition between draining the channel and the new timer expiring. Reset should always be invoked on stopped or expired channels, as described above. The return value exists to preserve compatibility with existing programs.</source>
          <target state="translated">채널 드레인과 새 타이머 만료 사이에 경쟁 조건이 있으므로 리셋의 반환 값을 올바르게 사용할 수 없습니다. 위에서 설명한대로 정지 또는 만료 된 채널에서 항상 리셋을 호출해야합니다. 리턴 값은 기존 프로그램과의 호환성을 유지하기 위해 존재합니다.</target>
        </trans-unit>
        <trans-unit id="9e389ad8751ed58f2ca67fb14ba2bd798ed9096f" translate="yes" xml:space="preserve">
          <source>Note that multiple subexpressions can be written using the same name, as in (?P&amp;lt;bob&amp;gt;a+)(?P&amp;lt;bob&amp;gt;b+), which declares two subexpressions named &quot;bob&quot;. In this case, SubexpIndex returns the index of the leftmost such subexpression in the regular expression.</source>
          <target state="translated">&quot;bob&quot;이라는 두 개의 하위 식을 선언하는 (? P &amp;lt;bob&amp;gt; a +) (? P &amp;lt;bob&amp;gt; b +)에서와 같이 동일한 이름을 사용하여 여러 하위 식을 작성할 수 있습니다. 이 경우 SubexpIndex는 정규식에서 가장 왼쪽에있는 하위 식의 인덱스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="47adc6d6003c04964db156378f371c69c6920eb2" translate="yes" xml:space="preserve">
          <source>Note that obj.Parent() may be different from the returned scope if the object was inserted into the scope and already had a parent at that time (see Insert). This can only happen for dot-imported objects whose scope is the scope of the package that exported them.</source>
          <target state="translated">obj.Parent ()는 개체가 범위에 삽입되었고 그 당시 이미 부모가있는 경우 반환 된 범위와 다를 수 있습니다 (삽입 참조). 이는 범위가 해당 개체를 내 보낸 패키지의 범위 인 점으로 가져온 개체에 대해서만 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbcbc6dbbe1cd946285db0917941f30791e5e34b" translate="yes" xml:space="preserve">
          <source>Note that obj.Parent() may be different from the returned scope if the object was inserted into the scope and already had a parent at that time (see Insert, below). This can only happen for dot-imported objects whose scope is the scope of the package that exported them.</source>
          <target state="translated">obj.Parent ()는 객체가 스코프에 삽입되었고 그 시점에 이미 부모가있는 경우 반환 된 스코프와 다를 수 있습니다 (아래 삽입 참조). 이것은 범위가 객체를 내 보낸 패키지의 범위 인 도트 가져 오기 된 객체에만 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fedc6a9186b4da1c6c4f2abf1943dc2cd31def02" translate="yes" xml:space="preserve">
          <source>Note that paths are slash-separated on all systems, even Windows. Paths containing other characters such as backslash and colon are accepted as valid, but those characters must never be interpreted by an FS implementation as path element separators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b894b1c82e2b9813c83c86241df2c9ed11092e90" translate="yes" xml:space="preserve">
          <source>Note that re-use has some caveats. Notably, Values should not be read or manipulated while a Read with that value is outstanding; that is a data race. This property includes pointer-typed Values (for example, Float64Histogram) whose underlying storage will be reused by Read when possible. To safely use such values in a concurrent setting, all data must be deep-copied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="295b47a82aa942008478736d689df68628de7e25" translate="yes" xml:space="preserve">
          <source>Note that since a pattern ending in a slash names a rooted subtree, the pattern &quot;/&quot; matches all paths not matched by other registered patterns, not just the URL with Path == &quot;/&quot;.</source>
          <target state="translated">슬래시로 끝나는 패턴은 루트 하위 트리의 이름을 가지므로 &quot;/&quot;패턴은 Path == &quot;/&quot;인 URL뿐만 아니라 다른 등록 된 패턴과 일치하지 않는 모든 경로와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="5f4e1f66b103f275a7a85fe240ec0793b18c4588" translate="yes" xml:space="preserve">
          <source>Note that the 'x' form is the one used by most other languages and libraries.</source>
          <target state="translated">'x'형식은 대부분의 다른 언어 및 라이브러리에서 사용되는 형식입니다.</target>
        </trans-unit>
        <trans-unit id="62af18353b85ece5ad43a8e2791ac7b4ef16a2b9" translate="yes" xml:space="preserve">
          <source>Note that the Go == operator compares not just the time instant but also the Location and the monotonic clock reading. See the documentation for the Time type for a discussion of equality testing for Time values.</source>
          <target state="translated">Go == 연산자는 시간 순간뿐만 아니라 위치 및 단조로운 시계 판독 값을 비교합니다. 시간 값에 대한 등식 테스트에 대한 설명은 시간 유형에 대한 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9bc5465e665f7d6206122a236966d74814c47dbc" translate="yes" xml:space="preserve">
          <source>Note that the Go == operator compares not just the time instant but also the Location and the monotonic clock reading. Therefore, Time values should not be used as map or database keys without first guaranteeing that the identical Location has been set for all values, which can be achieved through use of the UTC or Local method, and that the monotonic clock reading has been stripped by setting t = t.Round(0). In general, prefer t.Equal(u) to t == u, since t.Equal uses the most accurate comparison available and correctly handles the case when only one of its arguments has a monotonic clock reading.</source>
          <target state="translated">Go == 연산자는 시간 순간뿐만 아니라 위치 및 단조로운 시계 판독 값을 비교합니다. 따라서 UTC 또는 로컬 방법을 사용하여 달성 할 수있는 모든 위치에 동일한 위치가 설정되어 있고 단조로운 시계 판독 값이 제거되었음을 보장하지 않고는 시간 값을 맵 또는 데이터베이스 키로 사용해서는 안됩니다. t = t.Round (0) 설정. t.Equal은 사용 가능한 가장 정확한 비교를 사용하고 인수 중 하나에 만 단조로운 시계 판독 값이있는 경우를 올바르게 처리하므로 일반적으로 t.Equal (u)에서 t == u를 선호하십시오.</target>
        </trans-unit>
        <trans-unit id="f47d1736b65573bc0db0e46ddb437d8586c42dc1" translate="yes" xml:space="preserve">
          <source>Note that the Go runtime writes to standard error for panics and crashes; closing Stderr may cause those messages to go elsewhere, perhaps to a file opened later.</source>
          <target state="translated">Go 런타임은 패닉 및 충돌에 대한 표준 오류에 기록합니다. Stderr를 닫으면 해당 메시지가 나중에 다른 파일로 이동 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b94d521ccf655c50db2b1ef784ea75e16313781" translate="yes" xml:space="preserve">
          <source>Note that the Path field is stored in decoded form: /%47%6f%2f becomes /Go/. A consequence is that it is impossible to tell which slashes in the Path were slashes in the raw URL and which were %2f. This distinction is rarely important, but when it is, the code should use RawPath, an optional field which only gets set if the default encoding is different from Path.</source>
          <target state="translated">경로 필드는 디코딩 된 형식으로 저장됩니다. / % 47 % 6f % 2f는 / Go /가됩니다. 결과적으로 경로의 슬래시가 원시 URL에서 슬래시이고 어떤 것이 % 2f인지 알 수 없습니다. 이 구별은 거의 중요하지 않지만 코드가 기본 인코딩이 경로와 다른 경우에만 설정되는 선택적 필드 인 RawPath를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="2571b053e2312e837e4fa30b8af829d887a497ae" translate="yes" xml:space="preserve">
          <source>Note that the RFC822, RFC850, and RFC1123 formats should be applied only to local times. Applying them to UTC times will use &quot;UTC&quot; as the time zone abbreviation, while strictly speaking those RFCs require the use of &quot;GMT&quot; in that case. In general RFC1123Z should be used instead of RFC1123 for servers that insist on that format, and RFC3339 should be preferred for new protocols. RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting; when used with time.Parse they do not accept all the time formats permitted by the RFCs and they do accept time formats not formally defined. The RFC3339Nano format removes trailing zeros from the seconds field and thus may not sort correctly once formatted.</source>
          <target state="translated">RFC822, RFC850 및 RFC1123 형식은 현지 시간에만 적용해야합니다. UTC 시간에 적용하면 표준 시간대 약어로 &quot;UTC&quot;가 사용되지만 엄밀히 말하면 이러한 RFC는 &quot;GMT&quot;를 사용해야합니다. 일반적으로 해당 형식을 고집하는 서버에는 RFC1123 대신 RFC1123Z를 사용해야하며 새 프로토콜에는 RFC3339를 선호해야합니다. RFC3339, RFC822, RFC822Z, RFC1123 및 RFC1123Z는 형식화에 유용합니다. time.Parse와 함께 사용할 때 RFC에서 허용하는 모든 시간 형식을 허용하지 않으며 공식적으로 정의되지 않은 시간 형식도 허용합니다. RFC3339Nano 형식은 초 필드에서 후행 0을 제거하므로 형식이 지정되면 올바르게 정렬되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6fb073049f21533864d69200a5feb9b782ae4382" translate="yes" xml:space="preserve">
          <source>Note that the RFC822, RFC850, and RFC1123 formats should be applied only to local times. Applying them to UTC times will use &quot;UTC&quot; as the time zone abbreviation, while strictly speaking those RFCs require the use of &quot;GMT&quot; in that case. In general RFC1123Z should be used instead of RFC1123 for servers that insist on that format, and RFC3339 should be preferred for new protocols. RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting; when used with time.Parse they do not accept all the time formats permitted by the RFCs. The RFC3339Nano format removes trailing zeros from the seconds field and thus may not sort correctly once formatted.</source>
          <target state="translated">RFC822, RFC850 및 RFC1123 형식은 현지 시간에만 적용해야합니다. UTC 시간에 적용하면 시간대 약어로 &quot;UTC&quot;가 사용되지만 RFC를 엄격하게 말하면이 경우 &quot;GMT&quot;가 필요합니다. 일반적으로 해당 형식을 요구하는 서버의 경우 RFC1123 대신 RFC1123Z를 사용해야하며 새 프로토콜에는 RFC3339를 선호해야합니다. RFC3339, RFC822, RFC822Z, RFC1123 및 RFC1123Z는 형식화에 유용합니다. 구문 분석은 RFC에서 허용하는 모든 시간 형식을 허용하지 않습니다. RFC3339Nano 형식은 초 필드에서 후행 0을 제거하므로 일단 형식화되면 올바르게 정렬되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf45110f19f93211e34437dda6c947478fbddd92" translate="yes" xml:space="preserve">
          <source>Note that the examples in this package assume a Unix system. They may not run on Windows, and they do not run in the Go Playground used by golang.org and godoc.org.</source>
          <target state="translated">이 패키지의 예제는 Unix 시스템을 가정합니다. Windows에서는 실행되지 않을 수 있으며 golang.org 및 godoc.org에서 사용하는 Go Playground에서는 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b0a81d3e2cb77a7a98d611a9a24358352c170df1" translate="yes" xml:space="preserve">
          <source>Note that the input is still malleable, as new line characters (CR and LF) are still ignored.</source>
          <target state="translated">새 줄 문자 (CR 및 LF)는 여전히 무시되므로 입력은 여전히 ​​가변적입니다.</target>
        </trans-unit>
        <trans-unit id="532559dd628d5f97489f0222823fd716d088b914" translate="yes" xml:space="preserve">
          <source>Note that the point at infinity (0, 0) is not considered on the curve, and although it can be returned by Add, Double, ScalarMult, or ScalarBaseMult, it can't be marshaled or unmarshaled, and IsOnCurve will return false for it.</source>
          <target state="translated">무한대 (0, 0)의 점은 곡선에서 고려되지 않으며 Add, Double, ScalarMult 또는 ScalarBaseMult에 의해 반환 될 수 있지만 마샬링되거나 마샬링 될 수 없으며 IsOnCurve는 이에 대해 false를 반환합니다. .</target>
        </trans-unit>
        <trans-unit id="cabbff14cb2952c80edb181213c130b459a02692" translate="yes" xml:space="preserve">
          <source>Note that the pointer must point into an allocated object, so it may not be nil.</source>
          <target state="translated">포인터는 할당 된 객체를 가리켜 야하므로 0이 아닐 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee73d643f6fa22eddd036e602800c4d837e9ec70" translate="yes" xml:space="preserve">
          <source>Note that using CGI means starting a new process to handle each request, which is typically less efficient than using a long-running server. This package is intended primarily for compatibility with existing systems.</source>
          <target state="translated">CGI를 사용한다는 것은 각 요청을 처리하기 위해 새로운 프로세스를 시작한다는 것을 의미합니다. 이는 일반적으로 장기 실행 서버를 사용하는 것보다 덜 효율적입니다. 이 패키지는 주로 기존 시스템과의 호환성을 위해 고안되었습니다.</target>
        </trans-unit>
        <trans-unit id="e229bb3e45eb0475b8c930c1335cc5ff4dab911b" translate="yes" xml:space="preserve">
          <source>Note that whether this function returns an error or not discloses secret information. If an attacker can cause this function to run repeatedly and learn whether each instance returned an error then they can decrypt and forge signatures as if they had the private key. See DecryptPKCS1v15SessionKey for a way of solving this problem.</source>
          <target state="translated">이 함수가 오류를 반환하는지 여부는 비밀 정보를 공개합니다. 공격자가이 기능을 반복적으로 실행하고 각 인스턴스가 오류를 반환했는지 여부를 알게되면 개인 키가있는 것처럼 서명을 해독하고 위조 할 수 있습니다. 이 문제를 해결하는 방법은 DecryptPKCS1v15SessionKey를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="916171d84342fed453d228a3166add2d096261bc" translate="yes" xml:space="preserve">
          <source>Note: Eval and CheckExpr should not be used instead of running Check to compute types and values, but in addition to Check, as these functions ignore the context in which an expression is used (e.g., an assignment). Thus, top-level untyped constants will return an untyped type rather then the respective context-specific type.</source>
          <target state="translated">참고 : 형식 및 값을 계산하기 위해 Check를 실행하는 대신 Eval 및 CheckExpr을 사용해서는 안되며, 이러한 함수는식이 사용되는 컨텍스트 (예 : 대입)를 무시하므로 Check 이외에도 사용해야합니다. 따라서 최상위 수준의 형식화되지 않은 상수는 각 상황 별 형식이 아닌 형식화되지 않은 형식을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bd05f6d0d39a629d554e37dad544b0971bdc2e22" translate="yes" xml:space="preserve">
          <source>Note: Fscan etc. can read one character (rune) past the input they return, which means that a loop calling a scan routine may skip some of the input. This is usually a problem only when there is no space between input values. If the reader provided to Fscan implements ReadRune, that method will be used to read characters. If the reader also implements UnreadRune, that method will be used to save the character and successive calls will not lose data. To attach ReadRune and UnreadRune methods to a reader without that capability, use bufio.NewReader.</source>
          <target state="translated">참고 : Fscan 등은 반환 된 입력을지나 한 문자 (룬)를 읽을 수 있습니다. 이는 스캔 루틴을 호출하는 루프가 일부 입력을 건너 뛸 수 있음을 의미합니다. 일반적으로 입력 값 사이에 공백이없는 경우에만 문제가됩니다. Fscan에 제공된 판독기가 ReadRune을 구현하는 경우 해당 메소드를 사용하여 문자를 읽습니다. 리더가 UnreadRune도 구현하는 경우 해당 메소드는 문자를 저장하는 데 사용되며 연속적인 호출은 데이터를 잃지 않습니다. 해당 기능이없는 리더에 ReadRune 및 UnreadRune 메소드를 첨부하려면 bufio.NewReader를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2262c6082b97775886bda26c19137facc9855b36" translate="yes" xml:space="preserve">
          <source>Note: Since gobs can be stored permanently, it is good design to guarantee the encoding used by a GobEncoder is stable as the software evolves. For instance, it might make sense for GobEncode to include a version number in the encoding.</source>
          <target state="translated">참고 : gob는 영구적으로 저장할 수 있으므로 소프트웨어가 발전함에 따라 GobEncoder에서 사용하는 인코딩이 안정적으로 유지되도록하는 것이 좋습니다. 예를 들어 GobEncode가 인코딩에 버전 번호를 포함시키는 것이 합리적 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1a8b94ea000b0ee13d1c73b1460cd401f581d14" translate="yes" xml:space="preserve">
          <source>Note: The maximum number of concurrent operations on a File may be limited by the OS or the system. The number should be high, but exceeding it may degrade performance or cause other issues.</source>
          <target state="translated">참고 : 파일에 대한 최대 동시 작업 수는 OS 또는 시스템에 따라 제한 될 수 있습니다. 숫자는 높아야하지만이를 초과하면 성능이 저하되거나 다른 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e78b4237e62fef8d0e64dd07f8141dd5b9dd8dd5" translate="yes" xml:space="preserve">
          <source>Note: this method does not generate an RFC 5280 conformant X.509 v2 CRL. To generate a standards compliant CRL, use CreateRevocationList instead.</source>
          <target state="translated">참고 :이 방법은 RFC 5280 준수 X.509 v2 CRL을 생성하지 않습니다. 표준 준수 CRL을 생성하려면 대신 CreateRevocationList를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e27a7e32b7a1bd280289613fd2ddd6c441487040" translate="yes" xml:space="preserve">
          <source>Notice logs a message with severity LOG_NOTICE, ignoring the severity passed to New.</source>
          <target state="translated">통지는 심각도가 LOG_NOTICE 인 메시지를 기록하며 심각도는 새로 작성에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="6c03ee54ad3a51fc92a1d69943e99667847705b6" translate="yes" xml:space="preserve">
          <source>Notify</source>
          <target state="translated">Notify</target>
        </trans-unit>
        <trans-unit id="f32ad9d0db01cf6742ecb4a7f760ed9166d4e428" translate="yes" xml:space="preserve">
          <source>Notify (AllSignals)</source>
          <target state="translated">알림 (모든 신호)</target>
        </trans-unit>
        <trans-unit id="ec0a8c1ae8d23b04c5ac40659f605bd7d0769148" translate="yes" xml:space="preserve">
          <source>Notify causes package signal to relay incoming signals to c. If no signals are provided, all incoming signals will be relayed to c. Otherwise, just the provided signals will.</source>
          <target state="translated">알림은 패키지 신호가 들어오는 신호를 릴레이하도록합니다. c. 신호가 제공되지 않으면 들어오는 모든 신호가 c로 릴레이됩니다. 그렇지 않으면 제공된 신호 만 나타납니다.</target>
        </trans-unit>
        <trans-unit id="1dd2e9632e1d54f09b183732b58f92622a16dfc8" translate="yes" xml:space="preserve">
          <source>Notify disables the default behavior for a given set of asynchronous signals and instead delivers them over one or more registered channels. Specifically, it applies to the signals SIGHUP, SIGINT, SIGQUIT, SIGABRT, and SIGTERM. It also applies to the job control signals SIGTSTP, SIGTTIN, and SIGTTOU, in which case the system default behavior does not occur. It also applies to some signals that otherwise cause no action: SIGUSR1, SIGUSR2, SIGPIPE, SIGALRM, SIGCHLD, SIGCONT, SIGURG, SIGXCPU, SIGXFSZ, SIGVTALRM, SIGWINCH, SIGIO, SIGPWR, SIGSYS, SIGINFO, SIGTHR, SIGWAITING, SIGLWP, SIGFREEZE, SIGTHAW, SIGLOST, SIGXRES, SIGJVM1, SIGJVM2, and any real time signals used on the system. Note that not all of these signals are available on all systems.</source>
          <target state="translated">알림은 지정된 비동기 신호 세트에 대한 기본 동작을 비활성화하고 대신 하나 이상의 등록 된 채널을 통해 전달합니다. 특히 SIGHUP, SIGINT, SIGQUIT, SIGABRT 및 SIGTERM 신호에 적용됩니다. 작업 제어 신호 SIGTSTP, SIGTTIN 및 SIGTTOU에도 적용되며,이 경우 시스템 기본 동작이 발생하지 않습니다. SIGUSR1, SIGUSR2, SIGPIPE, SIGALRM, SIGCHLD, SIGCONT, SIGURG, SIGXCPU, SIGXFSZ, SIGVTALRM, SIGWINCH, SIGIO, SIGPWR, SIGSYS, SIGINFO, SIGTHR, SIGWAITING SISIGIZE SIGISR1, SIGUSR2, SIGPILD SIGTHAW, SIGLOST, SIGXRES, SIGJVM1, SIGJVM2 및 시스템에서 사용되는 모든 실시간 신호. 모든 시스템에서 이러한 신호를 모두 사용할 수있는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="ec1c8c26ce98414989276e685377bfa9bed740af" translate="yes" xml:space="preserve">
          <source>NotifyContext</source>
          <target state="translated">NotifyContext</target>
        </trans-unit>
        <trans-unit id="02ae0b499d7d8a520d67a814401a2f5ce01f64ec" translate="yes" xml:space="preserve">
          <source>NotifyContext returns a copy of the parent context that is marked done (its Done channel is closed) when one of the listed signals arrives, when the returned stop function is called, or when the parent context's Done channel is closed, whichever happens first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a03da0ac3a6fe09e0b74b0584dcf52f14832da35" translate="yes" xml:space="preserve">
          <source>Now returns the current local time.</source>
          <target state="translated">이제 현재 현지 시간을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="12f30fd28d8fbc7bdfb188f1073bae8ad0c81a0a" translate="yes" xml:space="preserve">
          <source>NsPerOp returns the &quot;ns/op&quot; metric.</source>
          <target state="translated">NsPerOp는 &quot;ns / op&quot;메트릭을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3e29aeff769634126fe308f4a3be01d64c577d98" translate="yes" xml:space="preserve">
          <source>NsecToTimespec converts a number of nanoseconds into a Timespec.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3f04b0789ea5fe434b5bac945daef8d6c790ae0" translate="yes" xml:space="preserve">
          <source>NsecToTimespec takes a number of nanoseconds since the Unix epoch and returns the corresponding Timespec value.</source>
          <target state="translated">NsecToTimespec은 유닉스 시대 이후 많은 나노초를 가져와 해당 Timespec 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0982b86aa619573eb41cb1f627ccd8ec0dad5961" translate="yes" xml:space="preserve">
          <source>NsecToTimeval converts a number of nanoseconds into a Timeval.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba97613a512663d90a9d8bf323b048ee6483da36" translate="yes" xml:space="preserve">
          <source>NsecToTimeval takes a number of nanoseconds since the Unix epoch and returns the corresponding Timeval value.</source>
          <target state="translated">NsecToTimeval은 Unix 시대 이후 많은 나노초를 가져와 해당 Timeval 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="50a5fe209ccfd051610f95a63741ad7f7b729cb1" translate="yes" xml:space="preserve">
          <source>Null is a type that implements ValueConverter by allowing nil values but otherwise delegating to another ValueConverter.</source>
          <target state="translated">Null은 nil 값을 허용하지만 다른 ValueConverter에 위임하여 ValueConverter를 구현하는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="98cd8ff39a93a75c21d65e0a235ee463a7bbb829" translate="yes" xml:space="preserve">
          <source>Null returns the JavaScript value &quot;null&quot;.</source>
          <target state="translated">Null은 JavaScript 값 &quot;null&quot;을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6f8b0f41b489cc3f5ce2776f939ca31dc0509085" translate="yes" xml:space="preserve">
          <source>NullBool represents a bool that may be null. NullBool implements the Scanner interface so it can be used as a scan destination, similar to NullString.</source>
          <target state="translated">NullBool은 null 일 수있는 bool을 나타냅니다. NullBool은 스캐너 인터페이스를 구현하므로 NullString과 유사한 스캔 대상으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6792a3139e23717e375cad9a592c4bd259439184" translate="yes" xml:space="preserve">
          <source>NullBytes contains bytes representing the DER-encoded ASN.1 NULL type.</source>
          <target state="translated">NullBytes는 DER로 인코딩 된 ASN.1 NULL 유형을 나타내는 바이트를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="5f6d3dcfb1e3aa678952637bbe19fdc90b78b127" translate="yes" xml:space="preserve">
          <source>NullFloat64 represents a float64 that may be null. NullFloat64 implements the Scanner interface so it can be used as a scan destination, similar to NullString.</source>
          <target state="translated">NullFloat64는 null 일 수있는 float64를 나타냅니다. NullFloat64는 스캐너 인터페이스를 구현하므로 NullString과 유사한 스캔 대상으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e472847699046a5829bc4e4e7c408ab93169a01" translate="yes" xml:space="preserve">
          <source>NullInt32 represents an int32 that may be null. NullInt32 implements the Scanner interface so it can be used as a scan destination, similar to NullString.</source>
          <target state="translated">NullInt32는 null 일 수있는 int32를 나타냅니다. NullInt32는 스캐너 인터페이스를 구현하므로 NullString과 유사한 스캔 대상으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9129057ccbbeafcc9b65fe6615ea2dfe0d92de58" translate="yes" xml:space="preserve">
          <source>NullInt64 represents an int64 that may be null. NullInt64 implements the Scanner interface so it can be used as a scan destination, similar to NullString.</source>
          <target state="translated">NullInt64는 null 일 수있는 int64를 나타냅니다. NullInt64는 스캐너 인터페이스를 구현하므로 NullString과 유사한 스캔 대상으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0dce04dd9159fa0b0caa17ec78453211e1469bd" translate="yes" xml:space="preserve">
          <source>NullRawValue is a RawValue with its Tag set to the ASN.1 NULL type tag (5).</source>
          <target state="translated">NullRawValue는 태그가 ASN.1 NULL 유형 태그 (5)로 설정된 RawValue입니다.</target>
        </trans-unit>
        <trans-unit id="74f3d9e74fdee0a23974ea8f9c10c75b52420438" translate="yes" xml:space="preserve">
          <source>NullString represents a string that may be null. NullString implements the Scanner interface so it can be used as a scan destination:</source>
          <target state="translated">NullString은 null 일 수있는 문자열을 나타냅니다. NullString은 스캐너 인터페이스를 구현하여 스캔 대상으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="764711d7b7a7e05fa628aa8a88164882909b5ea1" translate="yes" xml:space="preserve">
          <source>NullTime represents a time.Time that may be null. NullTime implements the Scanner interface so it can be used as a scan destination, similar to NullString.</source>
          <target state="translated">NullTime은 시간을 나타내며 null 일 수 있습니다. NullTime은 스캐너 인터페이스를 구현하므로 NullString과 유사한 스캔 대상으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f04c9d785121ddad7627d64968a461809b36b14b" translate="yes" xml:space="preserve">
          <source>Nullable reports whether the column may be null. If a driver does not support this property ok will be false.</source>
          <target state="translated">널 입력 가능은 열이 널인지 여부를보고합니다. 드라이버가이 속성을 지원하지 않으면 ok는 false입니다.</target>
        </trans-unit>
        <trans-unit id="b616503fdba110413e1c79f07f22ca93729b1af0" translate="yes" xml:space="preserve">
          <source>Num returns the numerator of x; it may be &amp;lt;= 0. The result is a reference to x's numerator; it may change if a new value is assigned to x, and vice versa. The sign of the numerator corresponds to the sign of x.</source>
          <target state="translated">Num은 x의 분자를 반환합니다. &amp;lt;= 0 일 수 있습니다. 결과는 x의 분자에 대한 참조입니다. x에 새로운 값이 할당되면 변경 될 수 있습니다. 분자의 부호는 x의 부호에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="49dfb6250d5c5b7065edd1796c9ba60b2981b754" translate="yes" xml:space="preserve">
          <source>Num returns the numerator of x; x must be Int, Float, or Unknown. If x is Unknown, or if it is too large or small to represent as a fraction, the result is Unknown. Otherwise the result is an Int with the same sign as x.</source>
          <target state="translated">Num은 x의 분자를 반환합니다. x는 Int, Float 또는 Unknown이어야합니다. x가 알 수없는 경우 또는 분수로 나타내기에는 너무 크거나 작은 경우 결과는 알 수 없습니다. 그렇지 않으면 결과는 x와 같은 부호를 가진 Int입니다.</target>
        </trans-unit>
        <trans-unit id="07e8e8142272a14853fc3d4225faf1955a80ec0e" translate="yes" xml:space="preserve">
          <source>NumCPU returns the number of logical CPUs usable by the current process.</source>
          <target state="translated">NumCPU는 현재 프로세스에서 사용할 수있는 논리 CPU 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3bdcf0e9793febfba96be526d3f799da8d6c4599" translate="yes" xml:space="preserve">
          <source>NumCgoCall returns the number of cgo calls made by the current process.</source>
          <target state="translated">NumCgoCall은 현재 프로세스에서 수행 한 cgo 호출 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="99d769aca95925934bfe7234523a8e266cfa3e86" translate="yes" xml:space="preserve">
          <source>NumChildren returns the number of scopes nested in s.</source>
          <target state="translated">NumChildren은에 중첩 된 범위 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7f8d5fa9c98c840bdcabc50036c605aaa61914fa" translate="yes" xml:space="preserve">
          <source>NumEmbeddeds returns the number of embedded types in interface t.</source>
          <target state="translated">NumEmbeddeds는 인터페이스 t에 포함 된 유형의 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="48274f29256d93bd977745ada6c383a46661d04c" translate="yes" xml:space="preserve">
          <source>NumError</source>
          <target state="translated">NumError</target>
        </trans-unit>
        <trans-unit id="085f257e02817fe0403777855cdf9b9d714c7182" translate="yes" xml:space="preserve">
          <source>NumExplicitMethods returns the number of explicitly declared methods of interface t.</source>
          <target state="translated">NumExplicitMethods는 인터페이스 t의 명시 적으로 선언 된 메소드 수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="dc69c4938a12562dfc9db7decbe294fadc96a88a" translate="yes" xml:space="preserve">
          <source>NumField returns the number of fields in the struct v. It panics if v's Kind is not Struct.</source>
          <target state="translated">NumField는 구조체 v의 필드 수를 반환합니다. v의 종류가 구조가 아닌 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="37d55c8516ca892bb76b586c5b36e164d3bfee83" translate="yes" xml:space="preserve">
          <source>NumFields returns the number of fields in the struct (including blank and embedded fields).</source>
          <target state="translated">NumFields는 구조체의 필드 수 (공백 및 포함 필드 포함)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="67aa508431878c89dfc1facabaf28776d55930aa" translate="yes" xml:space="preserve">
          <source>NumFields returns the number of parameters or struct fields represented by a FieldList.</source>
          <target state="translated">NumFields는 FieldList로 표시되는 매개 변수 또는 구조체 필드 수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="64877a16861b7f92b7b931c3dd32e6bffe105163" translate="yes" xml:space="preserve">
          <source>NumGoroutine returns the number of goroutines that currently exist.</source>
          <target state="translated">NumGoroutine은 현재 존재하는 고 루틴의 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="20f482d6f3d78d176b8cba126c2420b8ebb6a1e9" translate="yes" xml:space="preserve">
          <source>NumMethod returns the number of exported methods in the value's method set.</source>
          <target state="translated">NumMethod는 값의 메소드 세트에서 내 보낸 메소드 수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="e16da0849c5c39aaf5008c6fb5c0acd6258e7143" translate="yes" xml:space="preserve">
          <source>NumMethods returns the number of explicit methods whose receiver is named type t.</source>
          <target state="translated">NumMethods는 수신자의 이름이 t 인 명시 적 메소드의 수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="efca93e8ccf5085b691b876b60dbb50f530aac0f" translate="yes" xml:space="preserve">
          <source>NumMethods returns the total number of methods of interface t.</source>
          <target state="translated">NumMethods는 인터페이스 t의 총 메서드 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a0673e2061679abd4029b9bc04ce1dc9f32ef5a9" translate="yes" xml:space="preserve">
          <source>NumMethods returns the total number of methods of interface t. The interface must have been completed.</source>
          <target state="translated">NumMethods는 인터페이스 t의 총 메서드 수를 반환합니다. 인터페이스가 완료되어야합니다.</target>
        </trans-unit>
        <trans-unit id="f56f8cd32be5e8eed5e5b31f9ccdc038bef949c9" translate="yes" xml:space="preserve">
          <source>NumSubexp returns the number of parenthesized subexpressions in this Regexp.</source>
          <target state="translated">NumSubexp는이 Regexp에서 괄호로 묶인 하위 표현식의 수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="8bd18a7cf0e1d4bc6bca5d9c1e222116af743cd5" translate="yes" xml:space="preserve">
          <source>NumberNode holds a number: signed or unsigned integer, float, or complex. The value is parsed and stored under all the types that can represent the value. This simulates in a small amount of code the behavior of Go's ideal constants.</source>
          <target state="translated">NumberNode는 부호있는 또는 부호없는 정수, 부동 소수점 또는 복소수와 같은 숫자를 보유합니다. 값을 구문 분석하고 값을 나타낼 수있는 모든 유형으로 저장합니다. 이것은 소량의 코드에서 Go의 이상적인 상수의 동작을 시뮬레이션합니다.</target>
        </trans-unit>
        <trans-unit id="aebc8ea3b91ff7b79f4c3ee912e30d014d9c0e7c" translate="yes" xml:space="preserve">
          <source>Numbers are translated by reading and writing fixed-size values. A fixed-size value is either a fixed-size arithmetic type (bool, int8, uint8, int16, float32, complex64, ...) or an array or struct containing only fixed-size values.</source>
          <target state="translated">고정 크기 값을 읽고 쓰면 숫자가 변환됩니다. 고정 크기 값은 고정 크기 산술 유형 (bool, int8, uint8, int16, float32, complex64, ...)이거나 고정 크기 값만 포함하는 배열 또는 구조체입니다.</target>
        </trans-unit>
        <trans-unit id="514d0c82a993264caef98a3606fa7dc9d584da1d" translate="yes" xml:space="preserve">
          <source>Numbers fundamental to the encoding.</source>
          <target state="translated">인코딩에 필수적인 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="f72c4497b8297399ea538316ed693eb0b0f69dbb" translate="yes" xml:space="preserve">
          <source>Numeric Conversions</source>
          <target state="translated">숫자 변환</target>
        </trans-unit>
        <trans-unit id="294de652150e65884a04c4fc22af8edbb1682a0b" translate="yes" xml:space="preserve">
          <source>Numeric time zone offsets format as follows:</source>
          <target state="translated">숫자 시간대 오프셋 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="42abdd30b855d13cdf926751fede5f671a054974" translate="yes" xml:space="preserve">
          <source>OAEP is parameterised by a hash function that is used as a random oracle. Encryption and decryption of a given message must use the same hash function and sha256.New() is a reasonable choice.</source>
          <target state="translated">OAEP는 임의 오라클로 사용되는 해시 함수에 의해 매개 변수화됩니다. 지정된 메시지의 암호화 및 암호 해독에는 동일한 해시 함수를 사용해야하며 sha256.New ()는 합리적인 선택입니다.</target>
        </trans-unit>
        <trans-unit id="7c5f4d9d83e4f742a8c6f7a878b2a58947298d00" translate="yes" xml:space="preserve">
          <source>OAEPOptions is an interface for passing options to OAEP decryption using the crypto.Decrypter interface.</source>
          <target state="translated">OAEPOptions는 crypto.Decrypter 인터페이스를 사용하여 옵션을 OAEP 암호 해독에 전달하기위한 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="ad8427a11879cfd2d8db1b9e8e8f59a37957814e" translate="yes" xml:space="preserve">
          <source>OCSPResponse returns the stapled OCSP response from the TLS server, if any. (Only valid for client connections.)</source>
          <target state="translated">OCSPResponse는 TLS 서버에서 스테이플 된 OCSP 응답을 리턴합니다 (있는 경우). (클라이언트 연결에만 유효합니다.)</target>
        </trans-unit>
        <trans-unit id="e8520e97ccf3aeee86e1f8ac2f743514a534e58a" translate="yes" xml:space="preserve">
          <source>OSABI is found in Header.Ident[EI_OSABI] and Header.OSABI.</source>
          <target state="translated">OSABI는 Header.Ident [EI_OSABI] 및 Header.OSABI에 있습니다.</target>
        </trans-unit>
        <trans-unit id="68fe95dd58ed02ddd93208f0b1d291299be0c119" translate="yes" xml:space="preserve">
          <source>Obj returns the object denoted by x.f; a *Var for a field selection, and a *Func in all other cases.</source>
          <target state="translated">Obj는 xf로 표시된 객체를 반환합니다. 필드 선택에 * Var, 다른 모든 경우에 * Func</target>
        </trans-unit>
        <trans-unit id="9eb16182993cc59927b4da07ba021ca619da9eaa" translate="yes" xml:space="preserve">
          <source>Obj returns the type name for the named type t.</source>
          <target state="translated">Obj는 명명 된 유형 t의 유형 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ea5997c7d13deb46517727f9e2dc50eb58fb0ac9" translate="yes" xml:space="preserve">
          <source>ObjKind describes what an object represents.</source>
          <target state="translated">ObjKind는 객체가 나타내는 것을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="148bd125b03ec79b1e809f1705cff50161dd08f8" translate="yes" xml:space="preserve">
          <source>ObjectOf returns the object denoted by the specified id, or nil if not found.</source>
          <target state="translated">ObjectOf는 지정된 ID로 표시된 객체를 반환하거나 찾지 못하면 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="696fabf5d47e7927b31c4529cb32de76645f9e45" translate="yes" xml:space="preserve">
          <source>ObjectString returns the string form of obj. The Qualifier controls the printing of package-level objects, and may be nil.</source>
          <target state="translated">ObjectString은 obj의 문자열 형식을 반환합니다. 한정자는 패키지 수준 개체의 인쇄를 제어하며 nil 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a0a0f32e63d21edc60ea1562ca9a173b5386b67" translate="yes" xml:space="preserve">
          <source>Of the asynchronous signals, the SIGHUP signal is sent when a program loses its controlling terminal. The SIGINT signal is sent when the user at the controlling terminal presses the interrupt character, which by default is ^C (Control-C). The SIGQUIT signal is sent when the user at the controlling terminal presses the quit character, which by default is ^\ (Control-Backslash). In general you can cause a program to simply exit by pressing ^C, and you can cause it to exit with a stack dump by pressing ^\.</source>
          <target state="translated">비동기 신호 중 SIGHUP 신호는 프로그램이 제어 터미널을 잃을 때 전송됩니다. SIGINT 신호는 제어 터미널의 사용자가 인터럽트 문자를 누를 때 전송되며 기본적으로 ^ C (Control-C)입니다. SIGQUIT 신호는 제어 터미널의 사용자가 종료 문자를 누를 때 전송되며 기본적으로 ^ \ (Control-Backslash)입니다. 일반적으로 ^ C를 누르면 프로그램이 종료되고 ^ \를 누르면 스택 덤프가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="65a759f4644d298e31d53fd1d1620c7a2eccb79e" translate="yes" xml:space="preserve">
          <source>Offset returns the offset for the given file position p; p must be a valid Pos value in that file. f.Offset(f.Pos(offset)) == offset.</source>
          <target state="translated">오프셋은 주어진 파일 위치 p에 대한 오프셋을 반환합니다. p는 해당 파일에서 유효한 Pos 값이어야합니다. f. 오프셋 (f.Pos (offset)) == 오프셋.</target>
        </trans-unit>
        <trans-unit id="e668fecf796eebcf71860aea79f4acfd32998a26" translate="yes" xml:space="preserve">
          <source>Offsetof returns the offset within the struct of the field represented by x, which must be of the form structValue.field. In other words, it returns the number of bytes between the start of the struct and the start of the field. The return value of Offsetof is a Go constant.</source>
          <target state="translated">Offsetof는 x로 표시되는 필드의 구조체 내에서 오프셋을 반환하며 이는 structValue.field 형식이어야합니다. 즉, 구조체의 시작과 필드의 시작 사이의 바이트 수를 반환합니다. Offsetof의 반환 값은 Go 상수입니다.</target>
        </trans-unit>
        <trans-unit id="0ac54daba3530c56c22c7ab5fd0f77563ce7acd3" translate="yes" xml:space="preserve">
          <source>Often, ascii85-encoded data is wrapped in &amp;lt;~ and ~&amp;gt; symbols. Encode does not add these.</source>
          <target state="translated">종종 ascii85로 인코딩 된 데이터는 &amp;lt;~ 및 ~&amp;gt; 기호로 래핑됩니다. 인코딩은 이것을 추가하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6413c8b7ce1d9eff6207fb9349fe2d0c981a61bc" translate="yes" xml:space="preserve">
          <source>On 386, the 64-bit functions use instructions unavailable before the Pentium MMX.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23cc25224e88c84b965606d1525d366853ed4824" translate="yes" xml:space="preserve">
          <source>On AIX, DragonFly BSD, NetBSD, OpenBSD, Plan 9 and Solaris, the MulticastAddrs method of Interface is not implemented.</source>
          <target state="translated">AIX, DragonFly BSD, NetBSD, OpenBSD, Plan 9 및 Solaris에서는 인터페이스의 MulticastAddrs 메소드가 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="322a40be48fec2648aeb02ef3005e17bc581549f" translate="yes" xml:space="preserve">
          <source>On ARM, 386, and 32-bit MIPS, it is the caller's responsibility to arrange for 64-bit alignment of 64-bit words accessed atomically. The first word in a variable or in an allocated struct, array, or slice can be relied upon to be 64-bit aligned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1d045aa427adecabc2fe461f86a4e36227e3495" translate="yes" xml:space="preserve">
          <source>On ARM, x86-32, and 32-bit MIPS, it is the caller's responsibility to arrange for 64-bit alignment of 64-bit words accessed atomically. The first word in a variable or in an allocated struct, array, or slice can be relied upon to be 64-bit aligned.</source>
          <target state="translated">ARM, x86-32 및 32 비트 MIPS에서 원자 적으로 액세스 된 64 비트 단어의 64 비트 정렬을 정렬하는 것은 호출자의 책임입니다. 변수 또는 할당 된 구조체, 배열 또는 슬라이스의 첫 번째 단어는 64 비트로 정렬 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78d4a89f2d2e09c9cf23ea8b902790da4d5ff91d" translate="yes" xml:space="preserve">
          <source>On DragonFly BSD and OpenBSD, listening on the &quot;tcp&quot; and &quot;udp&quot; networks does not listen for both IPv4 and IPv6 connections. This is due to the fact that IPv4 traffic will not be routed to an IPv6 socket - two separate sockets are required if both address families are to be supported. See inet6(4) for details.</source>
          <target state="translated">DragonFly BSD 및 OpenBSD에서 &quot;tcp&quot;및 &quot;udp&quot;네트워크를 수신하면 IPv4 및 IPv6 연결을 모두 수신 할 수 없습니다. 이는 IPv4 트래픽이 IPv6 소켓으로 라우팅되지 않기 때문입니다. 두 주소 제품군을 모두 지원하려면 두 개의 별도 소켓이 필요합니다. 자세한 내용은 inet6 (4)를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bc2494255e41ee3a52e5ab617366af15ab263764" translate="yes" xml:space="preserve">
          <source>On JS and NaCl, methods and functions related to Interface are not implemented.</source>
          <target state="translated">JS 및 NaCl에서는 인터페이스와 관련된 메소드 및 함수가 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="192f11c9370338b47035100e9f2d82d3defced91" translate="yes" xml:space="preserve">
          <source>On JS and Plan 9, methods and functions related to IPConn are not implemented.</source>
          <target state="translated">JS 및 Plan 9에서는 IPConn과 관련된 메서드 및 기능이 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="99ce1e2fb44b89c9c5878b1c6736f5b7ccf5c3c1" translate="yes" xml:space="preserve">
          <source>On JS and Plan 9, methods and functions related to UnixConn and UnixListener are not implemented.</source>
          <target state="translated">JS 및 Plan 9에서는 UnixConn 및 UnixListener와 관련된 메소드 및 기능이 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="44ade6d9d0e9dc1e5841a92c33c3f4dc6e0db317" translate="yes" xml:space="preserve">
          <source>On JS and Plan 9, the Control, Read and Write methods of syscall.RawConn are not implemented.</source>
          <target state="translated">JS 및 Plan 9에서는 syscall.RawConn의 Control, Read 및 Write 메서드가 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="523f976c2cabf45b1020d7ffffaa352ae10a88bf" translate="yes" xml:space="preserve">
          <source>On JS and Windows, the File method of TCPConn and TCPListener is not implemented.</source>
          <target state="translated">JS 및 Windows에서는 TCPConn 및 TCPListener의 File 메소드가 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1d4b947349b83f8062406fe052b018a151c0a171" translate="yes" xml:space="preserve">
          <source>On JS and Windows, the FileConn, FileListener and FilePacketConn functions are not implemented.</source>
          <target state="translated">JS 및 Windows에서는 FileConn, FileListener 및 FilePacketConn 함수가 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a22fcd32dddc8742d71eeb00fd66a97a307dec2b" translate="yes" xml:space="preserve">
          <source>On JS, NaCl and Plan 9, methods and functions related to IPConn are not implemented.</source>
          <target state="translated">JS, NaCl 및 Plan 9에서는 IPConn 관련 메소드 및 기능이 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c330a67c6571f090abbe696684e69b144f23ffce" translate="yes" xml:space="preserve">
          <source>On JS, NaCl and Plan 9, methods and functions related to UnixConn and UnixListener are not implemented.</source>
          <target state="translated">JS, NaCl 및 Plan 9에서는 UnixConn 및 UnixListener와 관련된 메소드 및 기능이 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="187bea53a3943264ca3ab448938a9eb5588890ad" translate="yes" xml:space="preserve">
          <source>On JS, NaCl and Plan 9, the Control, Read and Write methods of syscall.RawConn are not implemented.</source>
          <target state="translated">JS, NaCl 및 Plan 9에서는 syscall.RawConn의 Control, Read 및 Write 메소드가 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8af01a3a36621e313c89de20d229f16557b6c642" translate="yes" xml:space="preserve">
          <source>On JS, NaCl and Windows, the File method of TCPConn and TCPListener is not implemented.</source>
          <target state="translated">JS, NaCl 및 Windows에서는 TCPConn 및 TCPListener의 File 메소드가 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c3a3c87314e5ae7220ae61af7b9a4aaad742b9fa" translate="yes" xml:space="preserve">
          <source>On JS, NaCl and Windows, the FileConn, FileListener and FilePacketConn functions are not implemented.</source>
          <target state="translated">JS, NaCl 및 Windows에서는 FileConn, FileListener 및 FilePacketConn 함수가 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="013710184aedbc65d0484c3d6e19b6b05cf4d0a4" translate="yes" xml:space="preserve">
          <source>On JS, methods and functions related to Interface are not implemented.</source>
          <target state="translated">JS에서는 Interface와 관련된 메소드 및 기능이 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="50eadbc0d323969884ecf9cc0009e49c34ea969b" translate="yes" xml:space="preserve">
          <source>On JS, methods and functions related to UDPConn are not implemented.</source>
          <target state="translated">JS에서는 UDPConn과 관련된 메소드 및 함수가 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a1c684d38068da43548a6ff99a071652823f3627" translate="yes" xml:space="preserve">
          <source>On Linux and FreeBSD, Reader uses getrandom(2) if available, /dev/urandom otherwise. On OpenBSD, Reader uses getentropy(2). On other Unix-like systems, Reader reads from /dev/urandom. On Windows systems, Reader uses the CryptGenRandom API. On Wasm, Reader uses the Web Crypto API.</source>
          <target state="translated">Linux 및 FreeBSD에서 Reader는 사용 가능한 경우 getrandom (2)을 사용하고, 그렇지 않은 경우 / dev / urandom을 사용합니다. OpenBSD에서 Reader는 getentropy (2)를 사용합니다. 다른 유닉스 계열 시스템에서는 Reader가 / dev / urandom에서 읽습니다. Windows 시스템에서 Reader는 CryptGenRandom API를 사용합니다. Wasm에서 Reader는 Web Crypto API를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a9dc397364bf0485259b5abb3ca6453bbc0cfd31" translate="yes" xml:space="preserve">
          <source>On Linux and FreeBSD, Reader uses getrandom(2) if available, /dev/urandom otherwise. On OpenBSD, Reader uses getentropy(2). On other Unix-like systems, Reader reads from /dev/urandom. On Windows systems, Reader uses the RtlGenRandom API. On Wasm, Reader uses the Web Crypto API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8ff5cc97c5ee66d154a1695c234ed4080927ad5" translate="yes" xml:space="preserve">
          <source>On NaCl and Plan 9, the ReadMsgUDP and WriteMsgUDP methods of UDPConn are not implemented.</source>
          <target state="translated">NaCl 및 Plan 9에서는 UDPConn의 ReadMsgUDP 및 WriteMsgUDP 메소드가 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="87e667c5ede44ae5764673fc28b292659a0f5bd8" translate="yes" xml:space="preserve">
          <source>On NaCl, the ListenMulticastUDP function is not implemented.</source>
          <target state="translated">NaCl에서는 ListenMulticastUDP 기능이 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a330e696a92e2d53090bac7c262b179695141719" translate="yes" xml:space="preserve">
          <source>On POSIX systems Gid contains a decimal number representing the group ID.</source>
          <target state="translated">POSIX 시스템에서 Gid는 그룹 ID를 나타내는 10 진수를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="2703d3b45f73f82bdf72e3fead14e53678acde02" translate="yes" xml:space="preserve">
          <source>On Plan 9, signals have type syscall.Note, which is a string. Calling Notify with a syscall.Note will cause that value to be sent on the channel when that string is posted as a note.</source>
          <target state="translated">플랜 9에서 신호의 유형은 syscall.Note이며 문자열입니다. syscall.Note로 Notify를 호출하면 해당 문자열이 메모로 게시 될 때 해당 값이 채널에 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="3750cfdfc10eef27e8dec499f3310e013386e383" translate="yes" xml:space="preserve">
          <source>On Plan 9, the ReadMsgUDP and WriteMsgUDP methods of UDPConn are not implemented.</source>
          <target state="translated">Plan 9에서는 UDPConn의 ReadMsgUDP 및 WriteMsgUDP 메서드가 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="4b29c33c1c929a09e8c06f8cea419c82c9628ed0" translate="yes" xml:space="preserve">
          <source>On Plan 9, the mode's permission bits, ModeAppend, ModeExclusive, and ModeTemporary are used.</source>
          <target state="translated">계획 9에서는 모드의 권한 비트, ModeAppend, ModeExclusive 및 ModeTemporary가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f8763fb392ab0ac0ea38c3b25946a7a1236134b7" translate="yes" xml:space="preserve">
          <source>On Plan 9, the resolver always accesses /net/cs and /net/dns.</source>
          <target state="translated">계획 9에서 확인자는 항상 / net / cs 및 / net / dns에 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="a1fe82f792d7b21f9ebd6296c1d86e735f0892e1" translate="yes" xml:space="preserve">
          <source>On Solaris, it returns one of the logical network interfaces sharing the logical data link; for more precision use InterfaceByName.</source>
          <target state="translated">Solaris에서는 논리 데이터 링크를 공유하는 논리 네트워크 인터페이스 중 하나를 리턴합니다. 더 정밀하게하려면 InterfaceByName을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d85518513a854a5111d381e48be350b2e36728b6" translate="yes" xml:space="preserve">
          <source>On UNIX systems the environment variables SSL_CERT_FILE and SSL_CERT_DIR can be used to override the system default locations for the SSL certificate file and SSL certificate files directory, respectively.</source>
          <target state="translated">UNIX 시스템에서 SSL_CERT_FILE 및 SSL_CERT_DIR 환경 변수를 사용하여 SSL 인증서 파일 및 SSL 인증서 파일 디렉토리의 시스템 기본 위치를 각각 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ae424a5db2afedd39c9f3dac84609afa2ca2005" translate="yes" xml:space="preserve">
          <source>On Unix systems other than macOS the environment variables SSL_CERT_FILE and SSL_CERT_DIR can be used to override the system default locations for the SSL certificate file and SSL certificate files directory, respectively. The latter can be a colon-separated list.</source>
          <target state="translated">macOS가 아닌 Unix 시스템에서는 SSL_CERT_FILE 및 SSL_CERT_DIR 환경 변수를 사용하여 각각 SSL 인증서 파일 및 SSL 인증서 파일 디렉터리의 시스템 기본 위치를 재정의 할 수 있습니다. 후자는 콜론으로 구분 된 목록 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88f58a825e10f84944f638859f6290d9816daa64" translate="yes" xml:space="preserve">
          <source>On Unix systems, FindProcess always succeeds and returns a Process for the given pid, regardless of whether the process exists.</source>
          <target state="translated">유닉스 시스템에서 FindProcess는 프로세스의 존재 여부에 관계없이 항상 주어진 pid에 대해 Process를 성공하고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="98e3b9345fcee9a653cd9ea250ff090f5fd5a0bd" translate="yes" xml:space="preserve">
          <source>On Unix systems, it returns $TMPDIR if non-empty, else /tmp. On Windows, it uses GetTempPath, returning the first non-empty value from %TMP%, %TEMP%, %USERPROFILE%, or the Windows directory. On Plan 9, it returns /tmp.</source>
          <target state="translated">유닉스 시스템에서는 비어 있지 않으면 $ TMPDIR을, 그렇지 않으면 / tmp를 반환합니다. Windows에서는 GetTempPath를 사용하여 % TMP %, % TEMP %, % USERPROFILE % 또는 Windows 디렉토리에서 비어 있지 않은 첫 번째 값을 리턴합니다. 계획 9에서는 / tmp를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d3d0aebf8d4f43a79a7a617076bea555037789dd" translate="yes" xml:space="preserve">
          <source>On Unix systems, it returns $XDG_CACHE_HOME as specified by &lt;a href=&quot;https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html&quot;&gt;https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html&lt;/a&gt; if non-empty, else $HOME/.cache. On Darwin, it returns $HOME/Library/Caches. On Windows, it returns %LocalAppData%. On Plan 9, it returns $home/lib/cache.</source>
          <target state="translated">Unix 시스템에서는 &lt;a href=&quot;https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html&quot;&gt;https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html에&lt;/a&gt; 지정된대로 $ XDG_CACHE_HOME을 반환하고 비어 있지 않으면 $ HOME / .cache를 반환합니다 . Darwin에서는 $ HOME / Library / Caches를 반환합니다. Windows에서는 % LocalAppData %를 반환합니다. 플랜 9에서는 $ home / lib / cache를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a069a183e2963c2a249b77ad664c6a016ed84b52" translate="yes" xml:space="preserve">
          <source>On Unix systems, it returns $XDG_CACHE_HOME as specified by &lt;a href=&quot;https://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html&quot;&gt;https://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html&lt;/a&gt; if non-empty, else $HOME/.cache. On Darwin, it returns $HOME/Library/Caches. On Windows, it returns %LocalAppData%. On Plan 9, it returns $home/lib/cache.</source>
          <target state="translated">Unix 시스템에서는 비어 있지 않은 경우 &lt;a href=&quot;https://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html&quot;&gt;https://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html에&lt;/a&gt; 지정된대로 $ XDG_CACHE_HOME을 반환 하고 그렇지 않으면 $ HOME / .cache를 반환합니다 . 다윈에서는 $ HOME / Library / Caches를 반환합니다. Windows에서는 % LocalAppData %를 리턴합니다. 계획 9에서는 $ home / lib / cache를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c4f447ec06dd9cfc46159127ffa2dcc14e35ae88" translate="yes" xml:space="preserve">
          <source>On Unix systems, it returns $XDG_CONFIG_HOME as specified by &lt;a href=&quot;https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html&quot;&gt;https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html&lt;/a&gt; if non-empty, else $HOME/.config. On Darwin, it returns $HOME/Library/Application Support. On Windows, it returns %AppData%. On Plan 9, it returns $home/lib.</source>
          <target state="translated">Unix 시스템에서는 &lt;a href=&quot;https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html&quot;&gt;https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html에&lt;/a&gt; 지정된대로 $ XDG_CONFIG_HOME을 반환하고 비어 있지 않으면 $ HOME / .config를 반환합니다 . Darwin에서는 $ HOME / Library / Application Support를 반환합니다. Windows에서는 % AppData %를 반환합니다. 계획 9에서는 $ home / lib를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1807151e52b0b2b36b5236bbf2d0ef14a9ec1abc" translate="yes" xml:space="preserve">
          <source>On Unix systems, it returns $XDG_CONFIG_HOME as specified by &lt;a href=&quot;https://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html&quot;&gt;https://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html&lt;/a&gt; if non-empty, else $HOME/.config. On Darwin, it returns $HOME/Library/Application Support. On Windows, it returns %AppData%. On Plan 9, it returns $home/lib.</source>
          <target state="translated">Unix 시스템에서는 비어 있지 않은 경우 &lt;a href=&quot;https://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html&quot;&gt;https://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html에&lt;/a&gt; 지정된대로 $ XDG_CONFIG_HOME을 반환 하고 그렇지 않으면 $ HOME / .config를 반환합니다 . Darwin에서는 $ HOME / Library / Application Support를 리턴합니다. Windows에서는 % AppData %를 리턴합니다. 계획 9에서는 $ home / lib를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2893f193d590bc3c2b7840d64034a29f26c7240a" translate="yes" xml:space="preserve">
          <source>On Unix systems, the resolver has two options for resolving names. It can use a pure Go resolver that sends DNS requests directly to the servers listed in /etc/resolv.conf, or it can use a cgo-based resolver that calls C library routines such as getaddrinfo and getnameinfo.</source>
          <target state="translated">유닉스 시스템에서 리졸버는 이름을 확인하기위한 두 가지 옵션이 있습니다. /etc/resolv.conf에 나열된 서버로 직접 DNS 요청을 보내는 순수 Go 리졸버를 사용하거나 getaddrinfo 및 getnameinfo와 같은 C 라이브러리 루틴을 호출하는 cgo 기반 리졸버를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c7408069288e442b0e9334096b1f9423749a2cb" translate="yes" xml:space="preserve">
          <source>On Unix, including macOS, it returns the $HOME environment variable. On Windows, it returns %USERPROFILE%. On Plan 9, it returns the $home environment variable.</source>
          <target state="translated">macOS를 포함한 Unix에서는 $ HOME 환경 변수를 반환합니다. Windows에서는 % USERPROFILE %을 리턴합니다. 계획 9에서는 $ home 환경 변수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="5c4d1d5958d138a86f133f67425aa5377e82d717" translate="yes" xml:space="preserve">
          <source>On Unix, the mode's permission bits, ModeSetuid, ModeSetgid, and ModeSticky are used.</source>
          <target state="translated">Unix에서는 모드의 권한 비트, ModeSetuid, ModeSetgid 및 ModeSticky가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b3748b447fc18cd33fa72cfd10ff7a8e4c810a41" translate="yes" xml:space="preserve">
          <source>On Unix-like systems, StartCPUProfile does not work by default for Go code built with -buildmode=c-archive or -buildmode=c-shared. StartCPUProfile relies on the SIGPROF signal, but that signal will be delivered to the main program's SIGPROF signal handler (if any) not to the one used by Go. To make it work, call os/signal.Notify for syscall.SIGPROF, but note that doing so may break any profiling being done by the main program.</source>
          <target state="translated">Unix 계열 시스템에서 StartCPUProfile은 기본적으로 -buildmode = c-archive 또는 -buildmode = c-shared로 빌드 된 Go 코드에 대해 작동하지 않습니다. StartCPUProfile은 SIGPROF 신호에 의존하지만 해당 신호는 Go에서 사용 된 것이 아닌 주 프로그램의 SIGPROF 신호 처리기 (있는 경우)로 전달됩니다. 작동 시키려면 syscall.SIGPROF에 대해 os / signal.Notify를 호출하십시오. 그러나 그렇게하면 기본 프로그램이 수행하는 프로파일 링이 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38c48a0935e355c448766738061267dd6c7374a5" translate="yes" xml:space="preserve">
          <source>On Windows a ^C (Control-C) or ^BREAK (Control-Break) normally cause the program to exit. If Notify is called for os.Interrupt, ^C or ^BREAK will cause os.Interrupt to be sent on the channel, and the program will not exit. If Reset is called, or Stop is called on all channels passed to Notify, then the default behavior will be restored.</source>
          <target state="translated">Windows에서 ^ C (Control-C) 또는 ^ BREAK (Control-Break)는 일반적으로 프로그램을 종료시킵니다. os.Interrupt에 대해 Notify를 호출하면 ^ C 또는 ^ BREAK로 인해 채널에서 os.Interrupt가 전송되고 프로그램이 종료되지 않습니다. Notify에 전달 된 모든 채널에서 Reset이 호출되거나 Stop이 호출되면 기본 동작이 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="84cb9183f88acab7f0a3e8615676023c95cfe1f4" translate="yes" xml:space="preserve">
          <source>On Windows or Plan 9, Chown always returns the syscall.EWINDOWS or EPLAN9 error, wrapped in *PathError.</source>
          <target state="translated">Windows 또는 Plan 9에서 Chown은 항상 * PathError로 래핑 된 syscall.EWINDOWS 또는 EPLAN9 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f5c6a1e271d70b402bf7e630854ac58bbcf34f9f" translate="yes" xml:space="preserve">
          <source>On Windows, MIME types are extracted from the registry.</source>
          <target state="translated">Windows에서는 MIME 유형이 레지스트리에서 추출됩니다.</target>
        </trans-unit>
        <trans-unit id="5350be8357b453f05f4ce5a07cf3bf1dba9318a4" translate="yes" xml:space="preserve">
          <source>On Windows, escaping is disabled. Instead, '\\' is treated as path separator.</source>
          <target state="translated">Windows에서는 이스케이프가 비활성화되어 있습니다. 대신 '\\'는 경로 구분 기호로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="a41bed9c4201556ec574f1ac26f677457e930cdc" translate="yes" xml:space="preserve">
          <source>On Windows, it always returns the syscall.EWINDOWS error, wrapped in *PathError.</source>
          <target state="translated">Windows에서는 항상 * PathError로 랩핑 된 syscall.EWINDOWS 오류를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="6f31a978cb1a7e83893ce791c5aa32ff7ac495fa" translate="yes" xml:space="preserve">
          <source>On Windows, it returns -1.</source>
          <target state="translated">Windows에서는 -1을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="6a02f4fe5f583e59f31f6cbc5e10b9216b10a0af" translate="yes" xml:space="preserve">
          <source>On Windows, it returns syscall.EWINDOWS. See the os/user package for a possible alternative.</source>
          <target state="translated">Windows에서는 syscall.EWINDOWS를 리턴합니다. 가능한 대안은 os / user 패키지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0d3a0f41f0df73942f4fecfe70a64ca015408110" translate="yes" xml:space="preserve">
          <source>On Windows, methods and functions related to UnixConn and UnixListener don't work for &quot;unixgram&quot; and &quot;unixpacket&quot;.</source>
          <target state="translated">Windows에서 &quot;unixgram&quot;및 &quot;unixpacket&quot;에는 UnixConn 및 UnixListener와 관련된 메소드 및 함수가 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bd2981a73df24a936314bf6d1873afd69dc8adde" translate="yes" xml:space="preserve">
          <source>On Windows, only the 0200 bit (owner writable) of mode is used; it controls whether the file's read-only attribute is set or cleared. The other bits are currently unused. For compatibility with Go 1.12 and earlier, use a non-zero mode. Use mode 0400 for a read-only file and 0600 for a readable+writable file.</source>
          <target state="translated">Windows에서는 0200 비트 (소유자 쓰기 가능) 모드 만 사용됩니다. 파일의 읽기 전용 속성 설정 여부를 제어합니다. 다른 비트는 현재 사용되지 않습니다. Go 1.12 및 이전 버전과의 호환성을 위해 0이 아닌 모드를 사용하십시오. 읽기 전용 파일의 경우 모드 0400을 사용하고 읽기 가능하고 쓰기 가능한 파일의 경우 0600을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2612d030cdd95b20b0743477158be3874169bfe3" translate="yes" xml:space="preserve">
          <source>On Windows, processes receive the whole command line as a single string and do their own parsing. Command combines and quotes Args into a command line string with an algorithm compatible with applications using CommandLineToArgvW (which is the most common way). Notable exceptions are msiexec.exe and cmd.exe (and thus, all batch files), which have a different unquoting algorithm. In these or other similar cases, you can do the quoting yourself and provide the full command line in SysProcAttr.CmdLine, leaving Args empty.</source>
          <target state="translated">Windows에서 프로세스는 전체 명령 행을 단일 문자열로 수신하고 자체 구문 분석을 수행합니다. Command는 CommandLineToArgvW (가장 일반적인 방법)를 사용하는 응용 프로그램과 호환되는 알고리즘을 사용하여 Args를 명령 줄 문자열로 결합하고 인용합니다. 주목할만한 예외는 인용 부호 매김 알고리즘이 다른 msiexec.exe 및 cmd.exe (및 모든 배치 파일)입니다. 이러한 경우 또는 다른 유사한 경우 직접 인용을 수행하고 SysProcAttr.CmdLine에 전체 명령 줄을 제공하고 Args는 비워 둘 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0058230d55ce789eb5612e2b93e4da6eea793a83" translate="yes" xml:space="preserve">
          <source>On Windows, the File method of IPConn is not implemented.</source>
          <target state="translated">Windows에서는 IPConn의 File 메소드가 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d755b555a5935f43a3d90e65b76056dcf10027ed" translate="yes" xml:space="preserve">
          <source>On Windows, the File method of UDPConn is not implemented.</source>
          <target state="translated">Windows에서는 UDPConn의 File 메소드가 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f31f810d1a4482b639a8bee446be568ce053ee4a" translate="yes" xml:space="preserve">
          <source>On Windows, the Write method of syscall.RawConn does not integrate with the runtime's network poller. It cannot wait for the connection to become writeable, and does not respect deadlines. If the user-provided callback returns false, the Write method will fail immediately.</source>
          <target state="translated">Windows에서 syscall.RawConn의 Write 메소드는 런타임의 네트워크 폴러와 통합되지 않습니다. 연결이 쓰기 가능할 때까지 기다릴 수 없으며 마감 기한을 지키지 않습니다. 사용자 제공 콜백이 false를 반환하면 Write 메서드가 즉시 실패합니다.</target>
        </trans-unit>
        <trans-unit id="8b8fbd99e87c243a50d7f3fe8f96df26bcf452aa" translate="yes" xml:space="preserve">
          <source>On Windows, the resolver always uses C library functions, such as GetAddrInfo and DnsQuery.</source>
          <target state="translated">Windows에서 리졸버는 항상 GetAddrInfo 및 DnsQuery와 같은 C 라이브러리 함수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="bf70d5852ec76636f3807a9db0f77a9465a35084" translate="yes" xml:space="preserve">
          <source>On all platforms, the traceback function is invoked when a call from Go to C to Go requests a stack trace. On linux/amd64, linux/ppc64le, and freebsd/amd64, the traceback function is also invoked when a signal is received by a thread that is executing a cgo call. The traceback function should not make assumptions about when it is called, as future versions of Go may make additional calls.</source>
          <target state="translated">모든 플랫폼에서 Go to C에서 Go 로의 호출이 스택 추적을 요청할 때 역 추적 기능이 호출됩니다. linux / amd64, linux / ppc64le 및 freebsd / amd64에서 cgo 호출을 실행중인 스레드가 신호를 수신하면 역 추적 기능도 호출됩니다. 향후 버전의 Go에서 추가 호출을 수행 할 수 있으므로 역 추적 기능은 호출 시점에 대해 가정하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="d6c40e8d8a1cb9c0f6c9d4c03dcd550161059582" translate="yes" xml:space="preserve">
          <source>On certain machines, for certain types of connections, this is optimized into an OS-specific batch write operation (such as &quot;writev&quot;).</source>
          <target state="translated">특정 컴퓨터에서 특정 유형의 연결에 대해 OS 별 배치 쓰기 작업 (예 : &quot;writev&quot;)에 최적화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c77b73816658f653733e14c2986094f012e8e513" translate="yes" xml:space="preserve">
          <source>On error, any Response can be ignored. A non-nil Response with a non-nil error only occurs when CheckRedirect fails, and even then the returned Response.Body is already closed.</source>
          <target state="translated">오류가 발생하면 모든 응답을 무시할 수 있습니다. nil이 아닌 오류가있는 nil이 아닌 응답은 CheckRedirect가 실패한 경우에만 발생하며 반환 된 Response.Body가 이미 닫힌 경우에만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="13e02db1965a04d36b6a5db4b5d676787f23298f" translate="yes" xml:space="preserve">
          <source>On every POSIX platform, reads from the &quot;ip4&quot; network using the ReadFrom or ReadFromIP method might not return a complete IPv4 packet, including its header, even if there is space available. This can occur even in cases where Read or ReadMsgIP could return a complete packet. For this reason, it is recommended that you do not use these methods if it is important to receive a full packet.</source>
          <target state="translated">모든 POSIX 플랫폼에서 사용 가능한 공간이 있어도 ReadFrom 또는 ReadFromIP 메소드를 사용하여 &quot;ip4&quot;네트워크에서 읽기는 헤더를 포함한 전체 IPv4 패킷을 반환하지 않을 수 있습니다. Read 또는 ReadMsgIP가 완전한 패킷을 반환 할 수있는 경우에도 발생할 수 있습니다. 따라서 전체 패킷을받는 것이 중요한 경우 이러한 방법을 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3c23c9c1e399b461c8c28a7144948fd27bdb61bb" translate="yes" xml:space="preserve">
          <source>On many Linux systems, /etc/ssl/cert.pem will contain the system wide set of root CAs in a format suitable for this function.</source>
          <target state="translated">많은 Linux 시스템에서 /etc/ssl/cert.pem은이 기능에 적합한 형식으로 시스템 전체 루트 CA 세트를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="ca1a155daae24035a913fb63720c32b8136a4b91" translate="yes" xml:space="preserve">
          <source>On non-Linux ARM, the 64-bit functions use instructions unavailable before the ARMv6k core.</source>
          <target state="translated">Linux 이외의 ARM에서 64 비트 함수는 ARMv6k 코어 이전에는 사용할 수없는 명령어를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1357e885cae46582ed3a6ff4521cb427fb02bd90" translate="yes" xml:space="preserve">
          <source>On some systems the monotonic clock will stop if the computer goes to sleep. On such a system, t.Sub(u) may not accurately reflect the actual time that passed between t and u.</source>
          <target state="translated">일부 시스템에서는 컴퓨터가 절전 모드로 전환되면 단조로운 시계가 중지됩니다. 이러한 시스템에서 t.Sub (u)는 t와 u 사이를 통과 한 실제 시간을 정확하게 반영하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66c05351e7478785f8f137c02ebcef5c050b614d" translate="yes" xml:space="preserve">
          <source>On the other hand, a free list maintained as part of a short-lived object is not a suitable use for a Pool, since the overhead does not amortize well in that scenario. It is more efficient to have such objects implement their own free list.</source>
          <target state="translated">반면, 수명이 짧은 개체의 일부로 유지 관리되는 사용 가능 목록은 해당 시나리오에서 오버 헤드가 잘 상각되지 않기 때문에 풀에 적합하지 않습니다. 이러한 객체가 자체 자유 목록을 구현하도록하는 것이 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="389950f4460ec73a72ec78dde5ba3b73d32c35ab" translate="yes" xml:space="preserve">
          <source>On x86-32, the 64-bit functions use instructions unavailable before the Pentium MMX.</source>
          <target state="translated">x86-32에서 64 비트 기능은 Pentium MMX 이전에는 사용할 수없는 명령어를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d9c768782ea8653d485fb3b7f5aba21cb2ca7bf3" translate="yes" xml:space="preserve">
          <source>Once</source>
          <target state="translated">Once</target>
        </trans-unit>
        <trans-unit id="d104fb961a8c78122b2f62dee3ef43757b182f86" translate="yes" xml:space="preserve">
          <source>Once Shutdown has been called on a server, it may not be reused; future calls to methods such as Serve will return ErrServerClosed.</source>
          <target state="translated">서버에서 시스템 종료가 호출되면 재사용되지 않을 수 있습니다. 나중에 Serve와 같은 메소드를 호출하면 ErrServerClosed가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="843e914dc9185fa382b5f053202ed67b742aeba3" translate="yes" xml:space="preserve">
          <source>Once f returns and err is nil, the Conn will continue to be usable until Conn.Close is called.</source>
          <target state="translated">f가 반환되고 err이 nil이면 Conn.Close가 호출 될 때까지 Conn을 계속 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c1d5279ebafd6b3423844bd2276728e8cc52fbd" translate="yes" xml:space="preserve">
          <source>Once is an object that will perform exactly one action.</source>
          <target state="translated">한 번만 정확히 하나의 동작을 수행하는 개체입니다.</target>
        </trans-unit>
        <trans-unit id="7227e9a075a44764452a578989f4cc83bbee577f" translate="yes" xml:space="preserve">
          <source>Once parsed, a template may be executed safely in parallel, although if parallel executions share a Writer the output may be interleaved.</source>
          <target state="translated">구문 분석 된 후에는 병렬 실행이 라이터를 공유하는 경우 출력이 인터리브 될 수 있지만 템플릿은 병렬로 안전하게 실행될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0281f78c03be67c1f2a3acafcdaa61c0cdc49c86" translate="yes" xml:space="preserve">
          <source>One or two minus signs may be used; they are equivalent. The last form is not permitted for boolean flags because the meaning of the command</source>
          <target state="translated">하나 또는 두 개의 빼기 부호가 사용될 수 있습니다. 그것들은 동등합니다. 명령의 의미 때문에 마지막 형식은 부울 플래그에 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="69577389d4c08755d52755f4e17faf59267dd621" translate="yes" xml:space="preserve">
          <source>OneByteReader returns a Reader that implements each non-empty Read by reading one byte from r.</source>
          <target state="translated">OneByteReader는 r에서 1 바이트를 읽음으로써 비어 있지 않은 각 Read를 구현하는 Reader를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="99aaec6fa8f2d0bdb9045bd117dd6c71497e9a74" translate="yes" xml:space="preserve">
          <source>OnesCount</source>
          <target state="translated">OnesCount</target>
        </trans-unit>
        <trans-unit id="433a6ff8b314e9c198548ae00ba6fcecd1eee098" translate="yes" xml:space="preserve">
          <source>OnesCount returns the number of one bits (&quot;population count&quot;) in x.</source>
          <target state="translated">OnesCount는 x에서 1 비트 수 ( &quot;인구 수&quot;)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c380e0ef7643051dda1d040515dc580f28605550" translate="yes" xml:space="preserve">
          <source>OnesCount16</source>
          <target state="translated">OnesCount16</target>
        </trans-unit>
        <trans-unit id="0999fcac9097d75e1573b11d0ffd816e52cf5855" translate="yes" xml:space="preserve">
          <source>OnesCount16 returns the number of one bits (&quot;population count&quot;) in x.</source>
          <target state="translated">OnesCount16은 x에서 1 비트 수 ( &quot;인구 수&quot;)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="11a58244491d18b07e203d19e0549197d7478647" translate="yes" xml:space="preserve">
          <source>OnesCount32</source>
          <target state="translated">OnesCount32</target>
        </trans-unit>
        <trans-unit id="5f0db4433d3c95e463c6c2a1eadf16ccd1d19ea6" translate="yes" xml:space="preserve">
          <source>OnesCount32 returns the number of one bits (&quot;population count&quot;) in x.</source>
          <target state="translated">OnesCount32는 x에서 1 비트 수 ( &quot;인구 수&quot;)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f8bf5b0787d28b51c08417f12183c3a8050bbddf" translate="yes" xml:space="preserve">
          <source>OnesCount64</source>
          <target state="translated">OnesCount64</target>
        </trans-unit>
        <trans-unit id="f4aecef923e1b31d46e0ebe7b85940e72b4c07f4" translate="yes" xml:space="preserve">
          <source>OnesCount64 returns the number of one bits (&quot;population count&quot;) in x.</source>
          <target state="translated">OnesCount64는 x에서 1 비트 수 ( &quot;인구 수&quot;)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d82a2ce39ad5e48e37815f9f28a1215fe50fea08" translate="yes" xml:space="preserve">
          <source>OnesCount8</source>
          <target state="translated">OnesCount8</target>
        </trans-unit>
        <trans-unit id="cb4e53f8fd7e82903aefdeda2e2114c5812e0d65" translate="yes" xml:space="preserve">
          <source>OnesCount8 returns the number of one bits (&quot;population count&quot;) in x.</source>
          <target state="translated">OnesCount8은 x에서 1 비트 수 ( &quot;인구 수&quot;)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e2a07178400736bcb7be81ae2feca4dcd008d7f5" translate="yes" xml:space="preserve">
          <source>Only methods that satisfy these criteria will be made available for remote access; other methods will be ignored:</source>
          <target state="translated">이러한 기준을 만족하는 방법 만 원격 액세스에 사용할 수 있습니다. 다른 방법은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="f19caf46e787ec1b99d851f024d8d32d31c130ae" translate="yes" xml:space="preserve">
          <source>Only one call to Dial is necessary. On write failures, the syslog client will attempt to reconnect to the server and write again.</source>
          <target state="translated">한 번의 전화 걸기 만하면됩니다. 쓰기 실패시 syslog 클라이언트는 서버에 다시 연결을 시도하고 다시 쓰려고합니다.</target>
        </trans-unit>
        <trans-unit id="0bb2640773cf0b724d4c0f4b422833704c7b1dde" translate="yes" xml:space="preserve">
          <source>Only some kinds of files support setting a deadline. Calls to SetDeadline for files that do not support deadlines will return ErrNoDeadline. On most systems ordinary files do not support deadlines, but pipes do.</source>
          <target state="translated">마감일 설정을 지원하는 파일 종류는 일부입니다. 마감일을 지원하지 않는 파일에 대해 SetDeadline을 호출하면 ErrNoDeadline이 반환됩니다. 대부분의 시스템에서 일반 파일은 마감일을 지원하지 않지만 파이프는 마감일을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="1f2bc4d6c6973cdf7add1d2aa0d072a9bc333db3" translate="yes" xml:space="preserve">
          <source>Only use this function if you require compatibility with an existing cryptosystem that uses non-standard nonce lengths. All other users should use NewGCM, which is faster and more resistant to misuse.</source>
          <target state="translated">비표준 nonce 길이를 사용하는 기존 암호화 시스템과의 호환성이 필요한 경우에만이 기능을 사용하십시오. 다른 모든 사용자는 NewGCM을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="15128cc4fc0390673cf1d5ff25c809ffa9a2a0a9" translate="yes" xml:space="preserve">
          <source>Only use this function if you require compatibility with an existing cryptosystem that uses non-standard tag lengths. All other users should use NewGCM, which is more resistant to misuse.</source>
          <target state="translated">비표준 태그 길이를 사용하는 기존 암호화 시스템과의 호환성이 필요한 경우에만이 기능을 사용하십시오. 다른 모든 사용자는 오용에 더 강한 NewGCM을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="1b727317ee1d6f8ec7fdb2282449eaeba440af19" translate="yes" xml:space="preserve">
          <source>Op is a Porter-Duff compositing operator.</source>
          <target state="translated">Op은 Porter-Duff 합성 연산자입니다.</target>
        </trans-unit>
        <trans-unit id="5af1dc92a9e2658f3244c1615c860d1105099061" translate="yes" xml:space="preserve">
          <source>OpError is the error type usually returned by functions in the net package. It describes the operation, network type, and address of an error.</source>
          <target state="translated">OpError는 일반적으로 net 패키지의 함수에 의해 반환되는 오류 유형입니다. 작업, 네트워크 유형 및 오류 주소에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="18f672481765f9d884600846dfaa4fd9da765b39" translate="yes" xml:space="preserve">
          <source>Opaque scans the entire image and reports whether it is fully opaque.</source>
          <target state="translated">불투명은 전체 이미지를 스캔하고 완전히 불투명한지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="b7443a4b74ca4cfa1bcd5bba9250ca69f1869f28" translate="yes" xml:space="preserve">
          <source>Open implements FileSystem using os.Open, opening files for reading rooted and relative to the directory d.</source>
          <target state="translated">Open은 os.Open을 사용하여 FileSystem을 구현하고 디렉토리를 기준으로 루트 및 루트를 읽기위한 파일을 엽니 다. d.</target>
        </trans-unit>
        <trans-unit id="6171c49e2bc16b1abb139c13c4d94d148a1c46f3" translate="yes" xml:space="preserve">
          <source>Open may just validate its arguments without creating a connection to the database. To verify that the data source name is valid, call Ping.</source>
          <target state="translated">Open은 데이터베이스에 연결하지 않고 인수의 유효성을 검사 할 수 있습니다. 데이터 소스 이름이 유효한지 확인하려면 Ping을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="5020abe2d6e35be83ee66706a97f7b42a3cce7b0" translate="yes" xml:space="preserve">
          <source>Open opens a Go plugin. If a path has already been opened, then the existing *Plugin is returned. It is safe for concurrent use by multiple goroutines.</source>
          <target state="translated">Open은 Go 플러그인을 엽니 다. 경로가 이미 열려 있으면 기존 * Plugin이 반환됩니다. 여러 고 루틴이 동시에 사용하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="66a147f16950427bc220b36b7335c4430f2e435a" translate="yes" xml:space="preserve">
          <source>Open opens a database specified by its database driver name and a driver-specific data source name, usually consisting of at least a database name and connection information.</source>
          <target state="translated">Open은 데이터베이스 드라이버 이름과 드라이버 특정 데이터 소스 이름으로 지정된 데이터베이스를 엽니 다. 일반적으로 데이터베이스 이름과 연결 정보로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="37d7b9b7fb804765c0c890c3a9927f5e792e10c2" translate="yes" xml:space="preserve">
          <source>Open opens and returns the FileHeader's associated File.</source>
          <target state="translated">열기가 열리고 FileHeader의 관련 파일이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4d09e8d3dfbdf4323b9d5cdc91f1fd80d7807611" translate="yes" xml:space="preserve">
          <source>Open opens the named file for reading and returns it as an fs.File.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f531c4cd3491cbb25cd300045e949a3c6a2f783" translate="yes" xml:space="preserve">
          <source>Open opens the named file for reading. If successful, methods on the returned file can be used for reading; the associated file descriptor has mode O_RDONLY. If there is an error, it will be of type *PathError.</source>
          <target state="translated">열기는 명명 된 파일을 읽기 위해 엽니 다. 성공하면 리턴 된 파일의 메소드를 사용하여 읽을 수 있습니다. 연관된 파일 디스크립터는 O_RDONLY 모드를 갖습니다. 오류가 있으면 * PathError 유형입니다.</target>
        </trans-unit>
        <trans-unit id="b390953cf8856a09a788eb0abb38c45237e64b69" translate="yes" xml:space="preserve">
          <source>Open opens the named file in the ZIP archive, using the semantics of fs.FS.Open: paths are always slash separated, with no leading / or ../ elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="371cc608c2ba1c0990eaf9fb6894bbf2a52158f7" translate="yes" xml:space="preserve">
          <source>Open opens the named file using os.Open and prepares it for use as a Mach-O binary.</source>
          <target state="translated">Open은 os.Open을 사용하여 명명 된 파일을 열고 Mach-O 바이너리로 사용할 수 있도록 준비합니다.</target>
        </trans-unit>
        <trans-unit id="7d04ca361fd4f73d2b0f9d528191bbbad4f3caa9" translate="yes" xml:space="preserve">
          <source>Open opens the named file using os.Open and prepares it for use as a PE binary.</source>
          <target state="translated">Open은 os.Open을 사용하여 명명 된 파일을 열고 PE 바이너리로 사용할 수 있도록 준비합니다.</target>
        </trans-unit>
        <trans-unit id="401e69358b39b00234c49cca571dfb25656931d2" translate="yes" xml:space="preserve">
          <source>Open opens the named file using os.Open and prepares it for use as a Plan 9 a.out binary.</source>
          <target state="translated">Open은 os.Open을 사용하여 명명 된 파일을 열고 Plan 9 a.out 바이너리로 사용할 수 있도록 준비합니다.</target>
        </trans-unit>
        <trans-unit id="9b1194bbc276659f78fdca3adfdc9b10d19c8660" translate="yes" xml:space="preserve">
          <source>Open opens the named file using os.Open and prepares it for use as an ELF binary.</source>
          <target state="translated">Open은 os.Open을 사용하여 명명 된 파일을 열고 ELF 바이너리로 사용할 수 있도록 준비합니다.</target>
        </trans-unit>
        <trans-unit id="534129bcf580066c175776306db4a220c2bad897" translate="yes" xml:space="preserve">
          <source>Open opens the named file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f50055a1ded1f305ba4233bb037ec0d820624aa9" translate="yes" xml:space="preserve">
          <source>Open returns a ReadCloser that provides access to the File's contents. Multiple files may be read concurrently.</source>
          <target state="translated">Open은 파일 내용에 액세스 할 수있는 ReadCloser를 반환합니다. 여러 파일을 동시에 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc15ea0e79b5a5fd3585bbb7eb793bc7927e0c43" translate="yes" xml:space="preserve">
          <source>Open returns a new ReadSeeker reading the ELF program body.</source>
          <target state="translated">Open은 ELF 프로그램 본문을 읽는 새로운 ReadSeeker를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cb2948f8796f4e20787b4c3d93aa97d5e5dd5298" translate="yes" xml:space="preserve">
          <source>Open returns a new ReadSeeker reading the ELF section. Even if the section is stored compressed in the ELF file, the ReadSeeker reads uncompressed data.</source>
          <target state="translated">Open은 ELF 섹션을 읽는 새로운 ReadSeeker를 반환합니다. 섹션이 ELF 파일로 압축 저장되어 있어도 ReadSeeker는 압축되지 않은 데이터를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="21b5b726e4f4ade0871cc002a3334fa728428adc" translate="yes" xml:space="preserve">
          <source>Open returns a new ReadSeeker reading the Mach-O section.</source>
          <target state="translated">Open은 Mach-O 섹션을 읽는 새로운 ReadSeeker를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b61efb693d7cf70cb90d5aedf0d5a372c5aa6512" translate="yes" xml:space="preserve">
          <source>Open returns a new ReadSeeker reading the PE section s.</source>
          <target state="translated">Open은 PE 섹션을 읽는 새로운 ReadSeeker를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="84fc1af6d68e3cc755958db236fc07677794c372" translate="yes" xml:space="preserve">
          <source>Open returns a new ReadSeeker reading the Plan 9 a.out section.</source>
          <target state="translated">Open은 Plan 9 a.out 섹션을 읽는 새로운 ReadSeeker를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="387b57706c30c22b6f03a484c6bd4b511d83f9ce" translate="yes" xml:space="preserve">
          <source>Open returns a new ReadSeeker reading the segment.</source>
          <target state="translated">Open은 세그먼트를 읽는 새로운 ReadSeeker를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1007daa5b98f8257c13edf3ea065301dd1ebaf2b" translate="yes" xml:space="preserve">
          <source>OpenDB may just validate its arguments without creating a connection to the database. To verify that the data source name is valid, call Ping.</source>
          <target state="translated">OpenDB는 데이터베이스에 연결하지 않고 인수의 유효성을 검사 할 수 있습니다. 데이터 소스 이름이 유효한지 확인하려면 Ping을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="25e1b5a42de4942dfe6b4bfced8324ba7ad01162" translate="yes" xml:space="preserve">
          <source>OpenDB opens a database using a Connector, allowing drivers to bypass a string based data source name.</source>
          <target state="translated">OpenDB는 커넥터를 사용하여 데이터베이스를 열어 드라이버가 문자열 기반 데이터 소스 이름을 무시할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="02205221603211c0f70a26822c2a5ea1275e3176" translate="yes" xml:space="preserve">
          <source>OpenFat opens the named file using os.Open and prepares it for use as a Mach-O universal binary.</source>
          <target state="translated">OpenFat은 os.Open을 사용하여 명명 된 파일을 열고 Mach-O 범용 바이너리로 사용할 수 있도록 준비합니다.</target>
        </trans-unit>
        <trans-unit id="f89511e6449f4d72c17e5b2730171b3d593b5ed7" translate="yes" xml:space="preserve">
          <source>OpenFile</source>
          <target state="translated">OpenFile</target>
        </trans-unit>
        <trans-unit id="0c82063df1128e3daff7e360a09afecb32d7114a" translate="yes" xml:space="preserve">
          <source>OpenFile (Append)</source>
          <target state="translated">OpenFile (추가)</target>
        </trans-unit>
        <trans-unit id="4fc4a091591f11a5786d39de5a16c7ed7ce1eeab" translate="yes" xml:space="preserve">
          <source>OpenFile is the generalized open call; most users will use Open or Create instead. It opens the named file with specified flag (O_RDONLY etc.). If the file does not exist, and the O_CREATE flag is passed, it is created with mode perm (before umask). If successful, methods on the returned File can be used for I/O. If there is an error, it will be of type *PathError.</source>
          <target state="translated">OpenFile은 일반화 된 공개 통화입니다. 대부분의 사용자는 Open 또는 Create를 대신 사용합니다. 지정된 플래그 (O_RDONLY 등)로 명명 된 파일을 엽니 다. 파일이 존재하지 않고 O_CREATE 플래그가 전달되면 모드 perm (umask 이전)으로 작성됩니다. 성공하면 리턴 된 파일의 메소드를 I / O에 사용할 수 있습니다. 오류가 있으면 * PathError 유형입니다.</target>
        </trans-unit>
        <trans-unit id="154227f07677e156add449cf112307bf838866a9" translate="yes" xml:space="preserve">
          <source>OpenReader will open the Zip file specified by name and return a ReadCloser.</source>
          <target state="translated">OpenReader는 이름으로 지정된 Zip 파일을 열고 ReadCloser를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6cbb449ad00bd956208ebf3bc7a9b2a9d9466e94" translate="yes" xml:space="preserve">
          <source>Operating systems provide both a &amp;ldquo;wall clock,&amp;rdquo; which is subject to changes for clock synchronization, and a &amp;ldquo;monotonic clock,&amp;rdquo; which is not. The general rule is that the wall clock is for telling time and the monotonic clock is for measuring time. Rather than split the API, in this package the Time returned by time.Now contains both a wall clock reading and a monotonic clock reading; later time-telling operations use the wall clock reading, but later time-measuring operations, specifically comparisons and subtractions, use the monotonic clock reading.</source>
          <target state="translated">운영 체제는 클럭 동기화를 위해 변경 될 수있는 &quot;월 클럭&quot;과 그렇지 않은 &quot;모노 닉 클럭&quot;을 모두 제공합니다. 일반적으로 벽시계는 시간을 알려주기위한 것이며 단조로운 시계는 시간을 측정하기위한 것입니다. API를 분할하는 대신이 패키지에서 Time은 time에 의해 반환됩니다. 이제 벽시계 판독 값과 단조로운 클록 판독 값이 모두 포함됩니다. 나중에 시간을 알리는 작업은 벽시계 판독을 사용하지만 나중에 시간을 측정하는 작업, 특히 비교 및 ​​뺄셈은 단조로운 시계 판독을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f30cabbd8e785b594ba56b3801fd9d4f1260078a" translate="yes" xml:space="preserve">
          <source>Operations always take pointer arguments (*Float) rather than Float values, and each unique Float value requires its own unique *Float pointer. To &quot;copy&quot; a Float value, an existing (or newly allocated) Float must be set to a new value using the Float.Set method; shallow copies of Floats are not supported and may lead to errors.</source>
          <target state="translated">연산은 항상 Float 값 대신 포인터 인수 (* Float)를 사용하며 각 고유 Float 값에는 고유 한 * Float 포인터가 필요합니다. Float 값을 &quot;복사&quot;하려면 기존 (또는 새로 할당 된) Float를 Float.Set 메서드를 사용하여 새 값으로 설정해야합니다. 플로트의 얕은 복사본은 지원되지 않으며 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1165d6e4bac8282c929350a1919aee2062c5958" translate="yes" xml:space="preserve">
          <source>Operations always take pointer arguments (*Int) rather than Int values, and each unique Int value requires its own unique *Int pointer. To &quot;copy&quot; an Int value, an existing (or newly allocated) Int must be set to a new value using the Int.Set method; shallow copies of Ints are not supported and may lead to errors.</source>
          <target state="translated">연산은 항상 Int 값 대신 포인터 인수 (* Int)를 사용하며 각 고유 Int 값에는 고유 한 * Int 포인터가 필요합니다. Int 값을 &quot;복사&quot;하려면 기존 (또는 새로 할당 된) Int를 Int.Set 메서드를 사용하여 새 값으로 설정해야합니다. 얕은 Ints 사본은 지원되지 않으며 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be2237e984f46419a4f93c71fc7a1e90b45fca20" translate="yes" xml:space="preserve">
          <source>Operations always take pointer arguments (*Rat) rather than Rat values, and each unique Rat value requires its own unique *Rat pointer. To &quot;copy&quot; a Rat value, an existing (or newly allocated) Rat must be set to a new value using the Rat.Set method; shallow copies of Rats are not supported and may lead to errors.</source>
          <target state="translated">조작은 항상 Rat 값 대신 포인터 인수 (* Rat)를 사용하며 각 고유 한 Rat 값에는 고유 한 * Rat 포인터가 필요합니다. Rat 값을 &quot;복사&quot;하려면 기존 (또는 새로 할당 된) Rat를 Rat.Set 메소드를 사용하여 새 값으로 설정해야합니다. 얕은 쥐의 복사본은 지원되지 않으며 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ff98727eb74457bb348de0295d7fc660d04eb4a" translate="yes" xml:space="preserve">
          <source>Operations to set or modify these public variables are atomic.</source>
          <target state="translated">이러한 공용 변수를 설정하거나 수정하는 작업은 원 자성입니다.</target>
        </trans-unit>
        <trans-unit id="a344aa2f0644d620585ef6109d1a2e6c58d16a89" translate="yes" xml:space="preserve">
          <source>Option sets options for the template. Options are described by strings, either a simple string or &quot;key=value&quot;. There can be at most one equals sign in an option string. If the option string is unrecognized or otherwise invalid, Option panics.</source>
          <target state="translated">옵션은 템플릿의 옵션을 설정합니다. 옵션은 간단한 문자열 또는 &quot;key = value&quot;문자열로 설명됩니다. 옵션 문자열에는 최대 하나의 등호가있을 수 있습니다. 옵션 문자열이 인식되지 않거나 유효하지 않으면 옵션 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="cce1a4813966599e90a08f133505dd0509cbda9c" translate="yes" xml:space="preserve">
          <source>OptionalHeader64.DllCharacteristics and OptionalHeader32.DllCharacteristics values. These can be combined together.</source>
          <target state="translated">OptionalHeader64.DllCharacteristics 및 OptionalHeader32.DllCharacteristics 값. 이들은 함께 결합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4bc236bd251ed2cc9db099c813ca0960052738d0" translate="yes" xml:space="preserve">
          <source>OptionalHeader64.Subsystem and OptionalHeader32.Subsystem values.</source>
          <target state="translated">OptionalHeader64.Subsystem 및 OptionalHeader32.Subsystem 값.</target>
        </trans-unit>
        <trans-unit id="b6fd04b8e4249d97e36c417ecf8d4f601359dc00" translate="yes" xml:space="preserve">
          <source>Optionally, a single extra argument of type Mode can be provided to control low-level aspects of the documentation extraction behavior.</source>
          <target state="translated">선택적으로 Mode 유형의 단일 추가 인수를 제공하여 문서 추출 동작의 저수준 측면을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22bdd06043dd23aedf196f8c5aa67a749424f26f" translate="yes" xml:space="preserve">
          <source>Options are the encoding parameters.</source>
          <target state="translated">옵션은 인코딩 매개 변수입니다.</target>
        </trans-unit>
        <trans-unit id="2ae1ba4c5551ccfa17f3cc4234e6c983b6c4a751" translate="yes" xml:space="preserve">
          <source>Options are the encoding parameters. Quality ranges from 1 to 100 inclusive, higher is better.</source>
          <target state="translated">옵션은 인코딩 매개 변수입니다. 품질 범위는 1에서 100까지이며 높을수록 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3574245ef01db27c04b70bab947169f3717705e6" translate="yes" xml:space="preserve">
          <source>Options are the options for creating a new Jar.</source>
          <target state="translated">옵션은 새로운 Jar를 생성하기위한 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="adec537139c73f02b553920372adc3c02c28272e" translate="yes" xml:space="preserve">
          <source>Or sets z = x | y and returns z.</source>
          <target state="translated">또는 z = x | y는 z를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1b4b94d1371289b3526620aa944ef691c23c5e97" translate="yes" xml:space="preserve">
          <source>Or to collect a 5-second execution trace:</source>
          <target state="translated">또는 5 초 실행 추적을 수집하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="50c67b4d826544d33e4676d47eb11f1c27fb8432" translate="yes" xml:space="preserve">
          <source>Or to look at a 30-second CPU profile:</source>
          <target state="translated">또는 30 초 CPU 프로파일을 보려면</target>
        </trans-unit>
        <trans-unit id="b615664e9607d56a174a9eae8d3c5a2c6e80bd6a" translate="yes" xml:space="preserve">
          <source>Or to look at the goroutine blocking profile, after calling runtime.SetBlockProfileRate in your program:</source>
          <target state="translated">또는 프로그램에서 runtime.SetBlockProfileRate를 호출 한 후 고 루틴 차단 프로파일을 보려면 :</target>
        </trans-unit>
        <trans-unit id="9e825dc80cfaf2eaa80db6ce23de3b3fc8a8346c" translate="yes" xml:space="preserve">
          <source>Or to look at the holders of contended mutexes, after calling runtime.SetMutexProfileFraction in your program:</source>
          <target state="translated">또는 프로그램에서 runtime.SetMutexProfileFraction을 호출 한 후 경합 된 뮤텍스의 홀더를 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="8ab86bd1259ac4f40dd163dea09a395538c7b9f8" translate="yes" xml:space="preserve">
          <source>Or you can create custom flags that satisfy the Value interface (with pointer receivers) and couple them to flag parsing by</source>
          <target state="translated">또는 Value 인터페이스 (포인터 리시버 포함)를 만족시키는 커스텀 플래그를 생성하고이를 플래그 파싱에 결합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e10a8547b0d36316e030b08eda98a7d2a3b8233" translate="yes" xml:space="preserve">
          <source>Order specifies the bit ordering in an LZW data stream.</source>
          <target state="translated">순서는 LZW 데이터 스트림에서 비트 순서를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="5cbea92714ef396bc3e8932074a0396b90c6e75c" translate="yes" xml:space="preserve">
          <source>Other ASN.1 types are not supported; if it encounters them, Unmarshal returns a parse error.</source>
          <target state="translated">다른 ASN.1 유형은 지원되지 않습니다. 발견되면 Unmarshal은 구문 분석 오류를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7ba1580fd9fc904fa02322480bcec7e07c54f2cc" translate="yes" xml:space="preserve">
          <source>Other definitions of spacing characters are set by category Z and property Pattern_White_Space.</source>
          <target state="translated">간격 문자의 다른 정의는 범주 Z 및 속성 Pattern_White_Space에 의해 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="b7a56a76d64dcdb6eb16b696315251945b43a236" translate="yes" xml:space="preserve">
          <source>Other flags:</source>
          <target state="translated">다른 깃발 :</target>
        </trans-unit>
        <trans-unit id="bd1405bb0e6eee6e420fe2dfb40f43a986aa8880" translate="yes" xml:space="preserve">
          <source>Other idioms, such as time.Since(start), time.Until(deadline), and time.Now().Before(deadline), are similarly robust against wall clock resets.</source>
          <target state="translated">time.Since (start), time.Until (deadline) 및 time.Now (). Before (deadline)과 같은 다른 관용구는 벽시계 재설정에 대해 유사하게 강력합니다.</target>
        </trans-unit>
        <trans-unit id="aa4d97b3571d62fa73ceb918bc9a47b9937e01e1" translate="yes" xml:space="preserve">
          <source>Other packages</source>
          <target state="translated">다른 패키지</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
