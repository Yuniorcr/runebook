<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="go">
    <body>
      <group id="go">
        <trans-unit id="472080cd520700e392bc20718f22b819dfe546bb" translate="yes" xml:space="preserve">
          <source>Rem64 returns the remainder of (hi, lo) divided by y. Rem64 panics for y == 0 (division by zero) but, unlike Div64, it doesn't panic on a quotient overflow.</source>
          <target state="translated">Rem64는 (hi, lo)의 나머지를 y로 나눈 값을 반환합니다. Rem64는 y == 0 (0으로 나누기)에 대해 패닉하지만 Div64와 달리 몫 오버플로에 대해 패닉하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5a90835af9526ee1f92955fe811ed706ded57897" translate="yes" xml:space="preserve">
          <source>Remainder returns the IEEE 754 floating-point remainder of x/y.</source>
          <target state="translated">나머지는 x / y의 IEEE 754 부동 소수점 나머지를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2dbe95bdd28a0d327a2826a1eef6ea3b725d6372" translate="yes" xml:space="preserve">
          <source>RemoteAddr returns the remote network address.</source>
          <target state="translated">RemoteAddr은 원격 네트워크 주소를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8f214e8a0c44c6dd9e0f980e84dc95f63540d94a" translate="yes" xml:space="preserve">
          <source>RemoteAddr returns the remote network address. The Addr returned is shared by all invocations of RemoteAddr, so do not modify it.</source>
          <target state="translated">RemoteAddr은 원격 네트워크 주소를 반환합니다. 리턴 된 Addr은 RemoteAddr의 모든 호출에서 공유되므로 수정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="90f28a6964f1d3561d308698fa02c4f609406cc1" translate="yes" xml:space="preserve">
          <source>Remove removes and returns the element at index i from the heap. The complexity is O(log n) where n = h.Len().</source>
          <target state="translated">제거는 힙에서 인덱스 i의 요소를 제거하고 리턴합니다. 복잡도는 O (log n)이며 여기서 n = h.Len ()입니다.</target>
        </trans-unit>
        <trans-unit id="63f1e9035000ecf346c434c7cac5dc81f24b1fd9" translate="yes" xml:space="preserve">
          <source>Remove removes e from l if e is an element of list l. It returns the element value e.Value. The element must not be nil.</source>
          <target state="translated">e가 목록 l의 요소 인 경우 제거는 l에서 e를 제거합니다. 요소 값 e.Value를 리턴합니다. 요소는 0이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="e157d0f3ede189bf26b7e5070547dae063fd8af3" translate="yes" xml:space="preserve">
          <source>Remove removes the execution stack associated with value from the profile. It is a no-op if the value is not in the profile.</source>
          <target state="translated">제거는 값과 연관된 실행 스택을 프로파일에서 제거합니다. 값이 프로파일에없는 경우 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="737a090d3844bc76afa279471870777ff484d715" translate="yes" xml:space="preserve">
          <source>Remove removes the named file or (empty) directory. If there is an error, it will be of type *PathError.</source>
          <target state="translated">제거는 명명 된 파일 또는 (빈) 디렉토리를 제거합니다. 오류가 있으면 * PathError 유형입니다.</target>
        </trans-unit>
        <trans-unit id="2570a819a5c470bfe2d2d19b6aafa9194f77567b" translate="yes" xml:space="preserve">
          <source>RemoveAll removes any temporary files associated with a Form.</source>
          <target state="translated">RemoveAll은 양식과 관련된 모든 임시 파일을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="4fad214b70e3f0d318c435f74dd889aca7ef4dce" translate="yes" xml:space="preserve">
          <source>RemoveAll removes path and any children it contains. It removes everything it can but returns the first error it encounters. If the path does not exist, RemoveAll returns nil (no error). If there is an error, it will be of type *PathError.</source>
          <target state="translated">RemoveAll은 경로와 여기에 포함 된 모든 자식을 제거합니다. 가능한 모든 것을 제거하지만 발생한 첫 번째 오류를 반환합니다. 경로가 없으면 RemoveAll은 nil을 반환합니다 (오류 없음). 오류가 있으면 * PathError 유형입니다.</target>
        </trans-unit>
        <trans-unit id="a4df6c6f5aeda6e3a5e7e46422d0e2c2213a3c07" translate="yes" xml:space="preserve">
          <source>RemoveMultiples sorts an ErrorList and removes all but the first error per line.</source>
          <target state="translated">RemoveMultiples는 ErrorList를 정렬하고 행당 첫 번째 오류를 제외한 모든 오류를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="c2642ac096483cfaf0dfa99c4fbd35ae36daa1eb" translate="yes" xml:space="preserve">
          <source>Rename renames (moves) oldpath to newpath. If newpath already exists and is not a directory, Rename replaces it. OS-specific restrictions may apply when oldpath and newpath are in different directories. If there is an error, it will be of type *LinkError.</source>
          <target state="translated">이름 바꾸기는 oldpath의 이름을 newpath로 바꿉니다 (이동). newpath가 이미 존재하고 디렉토리가 아닌 경우 이름 바꾸기가이를 대체합니다. oldpath와 newpath가 다른 디렉토리에있는 경우 OS 특정 제한 사항이 적용될 수 있습니다. 오류가 있으면 * LinkError 유형입니다.</target>
        </trans-unit>
        <trans-unit id="fdd5e93217a24d0127aee52fa57edae8bdb219bf" translate="yes" xml:space="preserve">
          <source>Renegotiation is not defined in TLS 1.3.</source>
          <target state="translated">재협상은 TLS 1.3에 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="592ed73cf658d5bb06fa571424af0b382c1c93a8" translate="yes" xml:space="preserve">
          <source>RenegotiationSupport enumerates the different levels of support for TLS renegotiation. TLS renegotiation is the act of performing subsequent handshakes on a connection after the first. This significantly complicates the state machine and has been the source of numerous, subtle security issues. Initiating a renegotiation is not supported, but support for accepting renegotiation requests may be enabled.</source>
          <target state="translated">재협상 지원은 TLS 재협상에 대한 서로 다른 수준의 지원을 열거합니다. TLS 재협상은 첫 번째 연결 후 연결에서 후속 핸드 셰이크를 수행하는 작업입니다. 이것은 상태 머신을 상당히 복잡하게 만들고 수많은 미묘한 보안 문제의 원인이되었습니다. 재협상 시작은 지원되지 않지만 재협상 요청 수락 지원이 활성화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="659eba121958f4a29fab3d29d61cedc55a892334" translate="yes" xml:space="preserve">
          <source>Repeat</source>
          <target state="translated">Repeat</target>
        </trans-unit>
        <trans-unit id="599d1421a3d35ed387e2145047d3b7a4416981b0" translate="yes" xml:space="preserve">
          <source>Repeat returns a new byte slice consisting of count copies of b.</source>
          <target state="translated">반복은 b의 카운트 사본으로 구성된 새 바이트 슬라이스를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="0843316565926f24e0d78b098353e903c702fd32" translate="yes" xml:space="preserve">
          <source>Repeat returns a new string consisting of count copies of the string s.</source>
          <target state="translated">반복은 문자열의 개수 사본으로 구성된 새 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b93ec95436616b79bd94ec117ace8a646628d209" translate="yes" xml:space="preserve">
          <source>Repetitions:</source>
          <target state="translated">Repetitions:</target>
        </trans-unit>
        <trans-unit id="a7cf7b25a703b308887c7f1d100c4326ef20ac46" translate="yes" xml:space="preserve">
          <source>Replace</source>
          <target state="translated">Replace</target>
        </trans-unit>
        <trans-unit id="14a86b576c43d99c7af38126a244d77d20b45014" translate="yes" xml:space="preserve">
          <source>Replace returns a copy of s with all replacements performed.</source>
          <target state="translated">Replace는 모든 교체가 수행 된 s 사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="486c15b931366bdf03143c243ee2b4d97be57dd7" translate="yes" xml:space="preserve">
          <source>Replace returns a copy of the slice s with the first n non-overlapping instances of old replaced by new. If old is empty, it matches at the beginning of the slice and after each UTF-8 sequence, yielding up to k+1 replacements for a k-rune slice. If n &amp;lt; 0, there is no limit on the number of replacements.</source>
          <target state="translated">Replace는 슬라이스의 사본을 겹치지 않는 오래된 n 개의 인스턴스를 new로 바꿉니다. old가 비어 있으면 슬라이스 시작시와 각 UTF-8 시퀀스 이후에 일치하여 k- 룬 슬라이스를 k + 1로 대체합니다. n &amp;lt;0이면 교체 횟수에 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="db4d7af1ecfbb4c54ae4d472073701051302c13a" translate="yes" xml:space="preserve">
          <source>Replace returns a copy of the string s with the first n non-overlapping instances of old replaced by new. If old is empty, it matches at the beginning of the string and after each UTF-8 sequence, yielding up to k+1 replacements for a k-rune string. If n &amp;lt; 0, there is no limit on the number of replacements.</source>
          <target state="translated">Replace는 문자열 s의 복사본을 겹치지 않는 오래된 n 개의 인스턴스를 new로 대체합니다. old가 비어 있으면 문자열의 시작 부분과 각 UTF-8 시퀀스 이후에 일치하여 k- 룬 문자열의 최대 k + 1 대체를 생성합니다. n &amp;lt;0이면 교체 횟수에 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="6eadb25ec304f683e79d867595086d352904b5b3" translate="yes" xml:space="preserve">
          <source>ReplaceAll</source>
          <target state="translated">ReplaceAll</target>
        </trans-unit>
        <trans-unit id="73ca5d06cabf37b075a8580fb5101f87650ad229" translate="yes" xml:space="preserve">
          <source>ReplaceAll returns a copy of src, replacing matches of the Regexp with the replacement text repl. Inside repl, $ signs are interpreted as in Expand, so for instance $1 represents the text of the first submatch.</source>
          <target state="translated">ReplaceAll은 src의 복사본을 반환하고 Regexp의 일치 항목을 대체 텍스트 repl로 바꿉니다. repl 내에서 $ 부호는 Expand와 같이 해석되므로 예를 들어 $ 1은 첫 번째 하위 일치 텍스트를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="506447353e7b3822dcf4613a0f93ab71e29d1735" translate="yes" xml:space="preserve">
          <source>ReplaceAll returns a copy of the slice s with all non-overlapping instances of old replaced by new. If old is empty, it matches at the beginning of the slice and after each UTF-8 sequence, yielding up to k+1 replacements for a k-rune slice.</source>
          <target state="translated">ReplaceAll은 겹치지 않는 모든 오래된 인스턴스가 new로 교체 된 슬라이스 사본을 반환합니다. old가 비어 있으면 슬라이스 시작시와 각 UTF-8 시퀀스 이후에 일치하여 k- 룬 슬라이스를 k + 1로 대체합니다.</target>
        </trans-unit>
        <trans-unit id="435dc323288417e80211f8927c3695e3ce359257" translate="yes" xml:space="preserve">
          <source>ReplaceAll returns a copy of the string s with all non-overlapping instances of old replaced by new. If old is empty, it matches at the beginning of the string and after each UTF-8 sequence, yielding up to k+1 replacements for a k-rune string.</source>
          <target state="translated">ReplaceAll은 겹치지 않는 모든 오래된 인스턴스가 new로 대체 된 문자열 s를 반환합니다. old가 비어 있으면 문자열의 시작 부분과 각 UTF-8 시퀀스 이후에 일치하여 k- 룬 문자열의 최대 k + 1 대체를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="3d66ecd6da17fab5c8cd96769f904257ef13a398" translate="yes" xml:space="preserve">
          <source>ReplaceAllFunc returns a copy of src in which all matches of the Regexp have been replaced by the return value of function repl applied to the matched byte slice. The replacement returned by repl is substituted directly, without using Expand.</source>
          <target state="translated">ReplaceAllFunc는 Regexp의 모든 일치 항목이 일치하는 바이트 슬라이스에 적용된 repl 함수의 반환 값으로 대체 된 src의 복사본을 반환합니다. repl에 의해 반환 된 대체는 Expand를 사용하지 않고 직접 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="2a17131c7994cd05d7daea07beea0ef31e257581" translate="yes" xml:space="preserve">
          <source>ReplaceAllLiteral returns a copy of src, replacing matches of the Regexp with the replacement bytes repl. The replacement repl is substituted directly, without using Expand.</source>
          <target state="translated">ReplaceAllLiteral은 src의 복사본을 반환하고 Regexp의 일치 항목을 대체 바이트 repl로 바꿉니다. 대체 repl은 Expand를 사용하지 않고 직접 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="87232f03b040c072f8f75219db9d85c61ff38e7c" translate="yes" xml:space="preserve">
          <source>ReplaceAllLiteralString returns a copy of src, replacing matches of the Regexp with the replacement string repl. The replacement repl is substituted directly, without using Expand.</source>
          <target state="translated">ReplaceAllLiteralString은 Regexp의 일치 항목을 대체 문자열 repl로 바꾸어 src 사본을 리턴합니다. 대체 repl은 Expand를 사용하지 않고 직접 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="bef70f919214d0f77e4d3a42c824dfffa5202cf4" translate="yes" xml:space="preserve">
          <source>ReplaceAllString returns a copy of src, replacing matches of the Regexp with the replacement string repl. Inside repl, $ signs are interpreted as in Expand, so for instance $1 represents the text of the first submatch.</source>
          <target state="translated">ReplaceAllString은 src의 복사본을 반환하고 Regexp의 일치 항목을 대체 문자열 repl로 바꿉니다. repl 내에서 $ 부호는 Expand와 같이 해석되므로 예를 들어 $ 1은 첫 번째 하위 일치 텍스트를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a3e275047465f9460cb043d0b2093b457293bb06" translate="yes" xml:space="preserve">
          <source>ReplaceAllStringFunc returns a copy of src in which all matches of the Regexp have been replaced by the return value of function repl applied to the matched substring. The replacement returned by repl is substituted directly, without using Expand.</source>
          <target state="translated">ReplaceAllStringFunc는 Regexp의 모든 일치 항목이 일치하는 하위 문자열에 적용된 repl 함수의 반환 값으로 대체 된 src의 복사본을 반환합니다. repl에 의해 반환 된 대체는 Expand를 사용하지 않고 직접 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="15e8ece6d83eb79a1b1a825152f49a545610894e" translate="yes" xml:space="preserve">
          <source>Replacer replaces a list of strings with replacements. It is safe for concurrent use by multiple goroutines.</source>
          <target state="translated">Replacer는 문자열 목록을 대체로 바꿉니다. 여러 고 루틴이 동시에 사용하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="5cf96ab71fbe348ef9fe46121c7813b382500496" translate="yes" xml:space="preserve">
          <source>Replacing the sign in the format with a Z triggers the ISO 8601 behavior of printing Z instead of an offset for the UTC zone. Thus:</source>
          <target state="translated">형식으로 부호를 Z로 바꾸면 UTC 영역에 대한 오프셋 대신 Z 인쇄의 ISO 8601 동작이 트리거됩니다. 그러므로:</target>
        </trans-unit>
        <trans-unit id="4b4d5cf4e6e2109de9a6b60e939d3a3fb07ec141" translate="yes" xml:space="preserve">
          <source>ReportAllocs enables malloc statistics for this benchmark. It is equivalent to setting -test.benchmem, but it only affects the benchmark function that calls ReportAllocs.</source>
          <target state="translated">ReportAllocs는이 벤치 마크에 대한 malloc 통계를 사용합니다. -test.benchmem 설정과 동일하지만 ReportAllocs를 호출하는 벤치 마크 함수에만 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="ca2f164e5206d2fe2c80e762a870dbd7b150154b" translate="yes" xml:space="preserve">
          <source>ReportMetric adds &quot;n unit&quot; to the reported benchmark results. If the metric is per-iteration, the caller should divide by b.N, and by convention units should end in &quot;/op&quot;. ReportMetric overrides any previously reported value for the same unit. ReportMetric panics if unit is the empty string or if unit contains any whitespace. If unit is a unit normally reported by the benchmark framework itself (such as &quot;allocs/op&quot;), ReportMetric will override that metric. Setting &quot;ns/op&quot; to 0 will suppress that built-in metric.</source>
          <target state="translated">ReportMetric은보고 된 벤치 마크 결과에 &quot;n 단위&quot;를 추가합니다. 메트릭이 반복 단위 인 경우 호출자는 bN으로 나누고 컨벤션 단위는 &quot;/ op&quot;로 끝나야합니다. ReportMetric은 동일한 단위에 대해 이전에보고 된 값을 무시합니다. unit이 빈 문자열이거나 unit에 공백이 있으면 ReportMetric 패닉이 발생합니다. 단위가 벤치 마크 프레임 워크 자체 (예 : &quot;allocs / op&quot;)에서 일반적으로보고하는 단위 인 경우 ReportMetric은 해당 메트릭을 재정의합니다. &quot;ns / op&quot;를 0으로 설정하면 내장 메트릭이 억제됩니다.</target>
        </trans-unit>
        <trans-unit id="bbfd1ef8b32af00f36af4ce56ffc90aaec2642df" translate="yes" xml:space="preserve">
          <source>Representations of a Time value saved by the GobEncode, MarshalBinary, MarshalJSON, and MarshalText methods store the Time.Location's offset, but not the location name. They therefore lose information about Daylight Saving Time.</source>
          <target state="translated">GobEncode, MarshalBinary, MarshalJSON 및 MarshalText 메소드에 의해 저장된 시간 값의 표현은 Time.Location의 오프셋을 저장하지만 위치 이름은 저장하지 않습니다. 따라서 일광 절약 시간제에 대한 정보가 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="034f490ecab4d9730ca1969131b6a78b84d524bf" translate="yes" xml:space="preserve">
          <source>Request is a header written before every RPC call. It is used internally but documented here as an aid to debugging, such as when analyzing network traffic.</source>
          <target state="translated">요청은 모든 RPC 호출 전에 작성된 헤더입니다. 내부적으로 사용되지만 네트워크 트래픽을 분석 할 때와 같이 디버깅을 돕기 위해 여기에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7fe490925acca7c7d2d43d098e092cfd78223216" translate="yes" xml:space="preserve">
          <source>Request returns the HTTP request as represented in the current environment. This assumes the current program is being run by a web server in a CGI environment. The returned Request's Body is populated, if applicable.</source>
          <target state="translated">요청은 현재 환경에 표시된대로 HTTP 요청을 반환합니다. 이것은 현재 프로그램이 CGI 환경의 웹 서버에 의해 실행되고 있다고 가정합니다. 해당되는 경우 반환 된 요청 본문이 채워집니다.</target>
        </trans-unit>
        <trans-unit id="d122cdaacba1573bfe57f160ca47386cbda87132" translate="yes" xml:space="preserve">
          <source>RequestFromMap creates an http.Request from CGI variables. The returned Request's Body field is not populated.</source>
          <target state="translated">RequestFromMap은 CGI 변수에서 http.Request를 작성합니다. 리턴 된 요청 본문 필드가 채워지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="27b1cff1ae1ef7bb8ea746c0ebbfe176f573422d" translate="yes" xml:space="preserve">
          <source>RequestURI returns the encoded path?query or opaque?query string that would be used in an HTTP request for u.</source>
          <target state="translated">RequestURI는 u에 대한 HTTP 요청에 사용될 인코딩 된 경로 쿼리 또는 불투명 쿼리 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3b21fedf00a3371e3f28d17145c5a692c6831e7c" translate="yes" xml:space="preserve">
          <source>Reset changes the timer to expire after duration d. It returns true if the timer had been active, false if the timer had expired or been stopped.</source>
          <target state="translated">재설정은 지속 시간 후에 타이머가 만료되도록 변경합니다. d. 타이머가 활성화 된 경우 true를, 타이머가 만료되었거나 중지 된 경우 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1eaa7c3f868073620d91cca86ce9b81e6921a9e0" translate="yes" xml:space="preserve">
          <source>Reset clears the state of the Writer z such that it is equivalent to its initial state from NewWriterLevel or NewWriterLevelDict, but instead writing to w.</source>
          <target state="translated">Reset은 Writer z의 상태를 지워 NewWriterLevel 또는 NewWriterLevelDict의 초기 상태와 동일하지만 대신 w에 기록합니다.</target>
        </trans-unit>
        <trans-unit id="d65a3d23577a5069af398a8c007957f5676a5eea" translate="yes" xml:space="preserve">
          <source>Reset discards all bytes added to h. (The seed remains the same.)</source>
          <target state="translated">재설정은 h에 추가 된 모든 바이트를 버립니다. (씨앗은 동일하게 유지됩니다.)</target>
        </trans-unit>
        <trans-unit id="8fad0a06171db3d325d00805f309209741be9985" translate="yes" xml:space="preserve">
          <source>Reset discards any buffered data, resets all state, and switches the buffered reader to read from r.</source>
          <target state="translated">Reset은 버퍼링 된 데이터를 버리고 모든 상태를 재설정 한 다음 r에서 읽도록 버퍼링 된 리더를 전환합니다.</target>
        </trans-unit>
        <trans-unit id="ddec4089b2023a9f5966b6899a6d86b3c6ba6d0e" translate="yes" xml:space="preserve">
          <source>Reset discards any unflushed buffered data, clears any error, and resets b to write its output to w.</source>
          <target state="translated">재설정은 버퍼링되지 않은 버퍼링 된 데이터를 버리고 오류를 지우고 b를 재설정하여 출력을 w에 씁니다.</target>
        </trans-unit>
        <trans-unit id="0f6193249698e8c1cc414024f184ff9d63a0b799" translate="yes" xml:space="preserve">
          <source>Reset discards the Reader z's state and makes it equivalent to the result of its original state from NewReader, but reading from r instead. This permits reusing a Reader rather than allocating a new one.</source>
          <target state="translated">Reset은 Reader z의 상태를 버리고 NewReader의 원래 상태 결과와 동일하지만 대신 r에서 읽습니다. 이를 통해 새로운 리더를 할당하는 대신 리더를 재사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8366944feb20881339d2bc39051aaaff11ba2e7" translate="yes" xml:space="preserve">
          <source>Reset discards the Writer z's state and makes it equivalent to the result of its original state from NewWriter or NewWriterLevel, but writing to w instead. This permits reusing a Writer rather than allocating a new one.</source>
          <target state="translated">Reset은 Writer z의 상태를 버리고 NewWriter 또는 NewWriterLevel의 원래 상태 결과와 동일하지만 대신 w에 쓰는 것입니다. 이를 통해 새로운 것을 할당하는 대신 라이터를 재사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1192ba3cfdd5644c337b189600cac9374ed9f399" translate="yes" xml:space="preserve">
          <source>Reset discards the writer's state and makes it equivalent to the result of NewWriter or NewWriterDict called with dst and w's level and dictionary.</source>
          <target state="translated">Reset은 기록기의 상태를 버리고 dst 및 w의 수준 및 사전으로 호출 된 NewWriter 또는 NewWriterDict의 결과와 같습니다.</target>
        </trans-unit>
        <trans-unit id="f44016b53cb6e5efb7b07f97bdd7a58a3f9acd27" translate="yes" xml:space="preserve">
          <source>Reset repositions the line table reader at the beginning of the line table.</source>
          <target state="translated">재설정은 행 테이블의 시작 부분에서 행 테이블 판독기를 재배치합니다.</target>
        </trans-unit>
        <trans-unit id="fc5e1e89a723101da37c5f7cdde61464338d0205" translate="yes" xml:space="preserve">
          <source>Reset resets an ErrorList to no errors.</source>
          <target state="translated">Reset은 ErrorList를 오류없이 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="06a254b1693f024953c4504eb0ab4b1efccfe485" translate="yes" xml:space="preserve">
          <source>Reset resets the Builder to be empty.</source>
          <target state="translated">재설정은 빌더가 비어 있도록 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="e5afd25b08aea0811ed90f3f30191e4fc43f9115" translate="yes" xml:space="preserve">
          <source>Reset resets the Reader to be reading from b.</source>
          <target state="translated">재설정은 판독기에서 읽도록 재설정합니다. b.</target>
        </trans-unit>
        <trans-unit id="15670331b1298dacd5ea205176b1269922b3d2b5" translate="yes" xml:space="preserve">
          <source>Reset resets the Reader to be reading from s.</source>
          <target state="translated">재설정은 리더가 s에서 읽을 수 있도록 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="170c10bab8e54e5cf030eb670497e5196563378e" translate="yes" xml:space="preserve">
          <source>Reset resets the buffer to be empty, but it retains the underlying storage for use by future writes. Reset is the same as Truncate(0).</source>
          <target state="translated">Reset은 버퍼를 비우도록 재설정하지만 이후 쓰기에서 사용할 수 있도록 기본 스토리지를 유지합니다. 재설정은 Truncate (0)과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="1cf78ba3d25ca4518fc926a9a64e46d873a5c2b0" translate="yes" xml:space="preserve">
          <source>Reset sends the RSET command to the server, aborting the current mail transaction.</source>
          <target state="translated">Reset은 RSET 명령을 서버로 보내 현재 메일 트랜잭션을 중단합니다.</target>
        </trans-unit>
        <trans-unit id="a8bd7c2aca0a58855a450ef3c393b7f8dd845541" translate="yes" xml:space="preserve">
          <source>Reset should be invoked only on stopped or expired timers with drained channels. If a program has already received a value from t.C, the timer is known to have expired and the channel drained, so t.Reset can be used directly. If a program has not yet received a value from t.C, however, the timer must be stopped and&amp;mdash;if Stop reports that the timer expired before being stopped&amp;mdash;the channel explicitly drained:</source>
          <target state="translated">채널이 비워진 중지 또는 만료 된 타이머에서만 재설정을 호출해야합니다. 프로그램이 이미 tC로부터 값을 수신 한 경우 타이머가 만료되고 채널이 비워진 것으로 알려져 있으므로 t.Reset을 직접 사용할 수 있습니다. 그러나 프로그램이 아직 tC로부터 값을받지 못한 경우 타이머를 중지해야하며 중지가 타이머가 중지되기 전에 타이머가 만료되었다고보고하면 채널이 명시 적으로 비워집니다.</target>
        </trans-unit>
        <trans-unit id="772cf6a4a9219e97ce203a7287641add064eb314" translate="yes" xml:space="preserve">
          <source>Reset stops a ticker and resets its period to the specified duration. The next tick will arrive after the new period elapses.</source>
          <target state="translated">재설정은 티커를 중지하고 해당 기간을 지정된 기간으로 재설정합니다. 다음 틱은 새로운 기간이 지나면 도착합니다.</target>
        </trans-unit>
        <trans-unit id="c62db3fae7c3e711fbf34aadc1b1afc1b9253c1a" translate="yes" xml:space="preserve">
          <source>Reset undoes the effect of any prior calls to Notify for the provided signals. If no signals are provided, all signal handlers will be reset.</source>
          <target state="translated">재설정은 제공된 신호에 대한 알림 호출에 대한 이전 호출의 효과를 취소합니다. 신호가 제공되지 않으면 모든 신호 처리기가 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="27fa1b9793c51dfd946a69a14c0ddb57c10ad547" translate="yes" xml:space="preserve">
          <source>Reset zeros the key data and makes the Cipher unusable.</source>
          <target state="translated">Reset은 키 데이터를 0으로 만들고 암호를 사용할 수 없게합니다.</target>
        </trans-unit>
        <trans-unit id="f310c59e5a0084054073df7b5f573d812cdd0fd8" translate="yes" xml:space="preserve">
          <source>ResetTimer zeroes the elapsed benchmark time and memory allocation counters and deletes user-reported metrics. It does not affect whether the timer is running.</source>
          <target state="translated">ResetTimer는 경과 된 벤치 마크 시간 및 메모리 할당 카운터를 0으로 만들고 사용자가보고 한 메트릭을 삭제합니다. 타이머가 실행 중인지 여부에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="33ee9712ca346c749995f4d74bcd18ae6c0b0650" translate="yes" xml:space="preserve">
          <source>Resetter resets a ReadCloser returned by NewReader or NewReaderDict to switch to a new underlying Reader. This permits reusing a ReadCloser instead of allocating a new one.</source>
          <target state="translated">Resetter는 NewReader 또는 NewReaderDict에서 반환 된 ReadCloser를 재설정하여 새로운 기본 Reader로 전환합니다. 이를 통해 새로운 것을 할당하는 대신 ReadCloser를 재사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7007d754cde94120e44343157ab76b14a831c26c" translate="yes" xml:space="preserve">
          <source>ResolveIPAddr returns an address of IP end point.</source>
          <target state="translated">ResolveIPAddr은 IP 엔드 포인트의 주소를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="07b69306928a5a3a0b8c2314c2531e10de93c9cf" translate="yes" xml:space="preserve">
          <source>ResolveReference resolves a URI reference to an absolute URI from an absolute base URI u, per RFC 3986 Section 5.2. The URI reference may be relative or absolute. ResolveReference always returns a new URL instance, even if the returned URL is identical to either the base or reference. If ref is an absolute URL, then ResolveReference ignores base and returns a copy of ref.</source>
          <target state="translated">ResolveReference는 RFC 3986 섹션 5.2에 따라 절대 기본 URI u에서 절대 URI에 대한 URI 참조를 분석합니다. URI 참조는 상대적이거나 절대적 일 수 있습니다. 반환 된 URL이 기본 또는 참조와 동일하더라도 ResolveReference는 항상 새 URL 인스턴스를 반환합니다. ref가 절대 URL 인 경우 ResolveReference는 base를 무시하고 ref의 사본을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="3273804861eaad79df80c3d22cf109398eb595c4" translate="yes" xml:space="preserve">
          <source>ResolveTCPAddr returns an address of TCP end point.</source>
          <target state="translated">ResolveTCPAddr은 TCP 끝점의 주소를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d940491c716336f4aaf080189bdb0c28cf1b6ec4" translate="yes" xml:space="preserve">
          <source>ResolveUDPAddr returns an address of UDP end point.</source>
          <target state="translated">ResolveUDPAddr은 UDP 엔드 포인트의 주소를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2928800c224397786b541e4886439dcdc0ecfc66" translate="yes" xml:space="preserve">
          <source>ResolveUnixAddr returns an address of Unix domain socket end point.</source>
          <target state="translated">ResolveUnixAddr은 Unix 도메인 소켓 끝점의 주소를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3dd3f1ec80ee28cb3dd53e5b932daca2d3fdd951" translate="yes" xml:space="preserve">
          <source>Response is a header written before every RPC return. It is used internally but documented here as an aid to debugging, such as when analyzing network traffic.</source>
          <target state="translated">응답은 모든 RPC가 반환되기 전에 작성된 헤더입니다. 내부적으로 사용되지만 네트워크 트래픽을 분석 할 때와 같이 디버깅을 돕기 위해 여기에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="78fa8e7076763a708a759f35e6fdf9c8c2792c3e" translate="yes" xml:space="preserve">
          <source>Response represents the response from an HTTP request.</source>
          <target state="translated">응답은 HTTP 요청의 응답을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2c870a02afd7772b1a5c1104af64d975949d9837" translate="yes" xml:space="preserve">
          <source>ResponseRecorder</source>
          <target state="translated">ResponseRecorder</target>
        </trans-unit>
        <trans-unit id="294d856644ce3293fbb784b42f79f661b3d60595" translate="yes" xml:space="preserve">
          <source>ResponseRecorder is an implementation of http.ResponseWriter that records its mutations for later inspection in tests.</source>
          <target state="translated">ResponseRecorder는 테스트에서 나중에 검사 할 수 있도록 돌연변이를 기록하는 http.ResponseWriter의 구현입니다.</target>
        </trans-unit>
        <trans-unit id="d0d0da2350df38e89f18eec0c8c277a390ef8032" translate="yes" xml:space="preserve">
          <source>ResponseWriter (Trailers)</source>
          <target state="translated">ResponseWriter (예고편)</target>
        </trans-unit>
        <trans-unit id="3f9f60a3d963394dba2b9af5ad21d7cf9b8efc40" translate="yes" xml:space="preserve">
          <source>Responses with status codes in the 1xx range are either handled automatically (100 expect-continue) or ignored. The one exception is HTTP status code 101 (Switching Protocols), which is considered a terminal status and returned by RoundTrip. To see the ignored 1xx responses, use the httptrace trace package's ClientTrace.Got1xxResponse.</source>
          <target state="translated">1xx 범위의 상태 코드가있는 응답은 자동으로 처리되거나 (예상 100 계속) 무시됩니다. 한 가지 예외는 HTTP 상태 코드 101 (스위칭 프로토콜)이며, 이는 터미널 상태로 간주되어 RoundTrip에 의해 반환됩니다. 무시 된 1xx 응답을 보려면 httptrace 추적 패키지의 ClientTrace.Got1xxResponse를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c92c6b4dd981d78fca3ec0b5b13d22c3c7e3c9ff" translate="yes" xml:space="preserve">
          <source>Result is the result of a query execution.</source>
          <target state="translated">결과는 쿼리 실행의 결과입니다.</target>
        </trans-unit>
        <trans-unit id="1f4d7bab508f22f797e449d5f6998b16e4434cbe" translate="yes" xml:space="preserve">
          <source>Result must only be called after the handler has finished running.</source>
          <target state="translated">핸들러 실행이 완료된 후에 만 ​​결과를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="1b5febf7558713f1ecb2fbd2c227fbc55af9bbed" translate="yes" xml:space="preserve">
          <source>Result returns the response generated by the handler.</source>
          <target state="translated">결과는 핸들러가 생성 한 응답을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="2d5559e8af761fd8963b92d10b52cc8627380cc7" translate="yes" xml:space="preserve">
          <source>ResultNoRows is a pre-defined Result for drivers to return when a DDL command (such as a CREATE TABLE) succeeds. It returns an error for both LastInsertId and RowsAffected.</source>
          <target state="translated">ResultNoRows는 DDL 명령 (예 : CREATE TABLE)이 성공할 때 드라이버가 반환 할 미리 정의 된 결과입니다. LastInsertId 및 RowsAffected 모두에 대해 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c3b838adfac99fd155c663831ad38556581e0407" translate="yes" xml:space="preserve">
          <source>Results returns the results of signature s, or nil.</source>
          <target state="translated">Results는 서명 결과 또는 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="962f14cb7eca51d5151fcfbeb4ab3ed937db54aa" translate="yes" xml:space="preserve">
          <source>Return the most recent call to Scan as a []byte.</source>
          <target state="translated">Scan에 대한 가장 최근 호출을 [] 바이트로 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="57f9933768794f845d000833d367d5698393211d" translate="yes" xml:space="preserve">
          <source>Reverse</source>
          <target state="translated">Reverse</target>
        </trans-unit>
        <trans-unit id="902e55a122fa4891a6dae083e18230ea968dc9a3" translate="yes" xml:space="preserve">
          <source>Reverse returns the reverse order for data.</source>
          <target state="translated">역순은 데이터의 역순을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="78b0b4cb759dec2da3c6713767fbf6f4bc040c4d" translate="yes" xml:space="preserve">
          <source>Reverse returns the value of x with its bits in reversed order.</source>
          <target state="translated">역순으로 비트의 x 값을 역순으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="92de4737778eb41e55ca2f7a627a47fd6ba4a889" translate="yes" xml:space="preserve">
          <source>Reverse16</source>
          <target state="translated">Reverse16</target>
        </trans-unit>
        <trans-unit id="b383f837c66d7bdba479cd898a8ff90df6a54bdc" translate="yes" xml:space="preserve">
          <source>Reverse16 returns the value of x with its bits in reversed order.</source>
          <target state="translated">Reverse16은 비트가있는 x의 값을 역순으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bc5bc5fb62f24a53fcf7486ea47cb526c49ed16b" translate="yes" xml:space="preserve">
          <source>Reverse32</source>
          <target state="translated">Reverse32</target>
        </trans-unit>
        <trans-unit id="31e983ab5d2fdae281f62da27af16c6410c88366" translate="yes" xml:space="preserve">
          <source>Reverse32 returns the value of x with its bits in reversed order.</source>
          <target state="translated">Reverse32는 비트가있는 x의 값을 역순으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4b8d738bc3f5b572852bef49d9d1b74649451478" translate="yes" xml:space="preserve">
          <source>Reverse64</source>
          <target state="translated">Reverse64</target>
        </trans-unit>
        <trans-unit id="0a95ddc6b008b1c60668050345ad2bbd0048d26d" translate="yes" xml:space="preserve">
          <source>Reverse64 returns the value of x with its bits in reversed order.</source>
          <target state="translated">Reverse64는 비트와 함께 x의 값을 역순으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8b7d623b04231c73d009937cc199213fab60a116" translate="yes" xml:space="preserve">
          <source>Reverse8</source>
          <target state="translated">Reverse8</target>
        </trans-unit>
        <trans-unit id="4e2cfa80f1f3211b8d7b8f97b9c866dc8e5602ee" translate="yes" xml:space="preserve">
          <source>Reverse8 returns the value of x with its bits in reversed order.</source>
          <target state="translated">Reverse8은 비트가있는 x의 값을 역순으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="be39e968e6f8b02161cf145a91c2242f8ac3e738" translate="yes" xml:space="preserve">
          <source>ReverseBytes returns the value of x with its bytes in reversed order.</source>
          <target state="translated">ReverseBytes는 바이트와 함께 x의 값을 역순으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b3a8220fbdce3c882a295efbc513cc8d73cb1a7a" translate="yes" xml:space="preserve">
          <source>ReverseBytes16</source>
          <target state="translated">ReverseBytes16</target>
        </trans-unit>
        <trans-unit id="2a7c652af5267d559395a2d601cef862d0dc08f3" translate="yes" xml:space="preserve">
          <source>ReverseBytes16 returns the value of x with its bytes in reversed order.</source>
          <target state="translated">ReverseBytes16은 바이트 단위의 x 값을 역순으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0b3b6869428b45a4008a611a88e1d858c7f82ca5" translate="yes" xml:space="preserve">
          <source>ReverseBytes32</source>
          <target state="translated">ReverseBytes32</target>
        </trans-unit>
        <trans-unit id="bd4bbc4dc35b34c8851580c4ed26f1553540d805" translate="yes" xml:space="preserve">
          <source>ReverseBytes32 returns the value of x with its bytes in reversed order.</source>
          <target state="translated">ReverseBytes32는 바이트 단위의 x 값을 역순으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="27b3c718307e25ebd0df6355d5ba2181fe72066f" translate="yes" xml:space="preserve">
          <source>ReverseBytes64</source>
          <target state="translated">ReverseBytes64</target>
        </trans-unit>
        <trans-unit id="2bfe4d5fab882bedb4ed52db5659be4b630cad79" translate="yes" xml:space="preserve">
          <source>ReverseBytes64 returns the value of x with its bytes in reversed order.</source>
          <target state="translated">ReverseBytes64는 바이트 단위의 x 값을 역순으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="08e888d81afdf833be45fe65662c8198e86a5832" translate="yes" xml:space="preserve">
          <source>ReverseProxy</source>
          <target state="translated">ReverseProxy</target>
        </trans-unit>
        <trans-unit id="c3cde67321667db5b0ff2afa430c2b271723997c" translate="yes" xml:space="preserve">
          <source>ReverseProxy by default sets the client IP as the value of the X-Forwarded-For header.</source>
          <target state="translated">ReverseProxy는 기본적으로 클라이언트 IP를 X-Forwarded-For 헤더의 값으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="9bfcf9ccffddea8678782d891a9bd8387a2cdb0f" translate="yes" xml:space="preserve">
          <source>ReverseProxy is an HTTP Handler that takes an incoming request and sends it to another server, proxying the response back to the client.</source>
          <target state="translated">ReverseProxy는 들어오는 요청을 가져 와서 다른 서버로 보내서 클라이언트에게 응답을 프록시하는 HTTP 핸들러입니다.</target>
        </trans-unit>
        <trans-unit id="4f8dffba226130f5ed0c1d019f2b7969133c43c4" translate="yes" xml:space="preserve">
          <source>RevocationList contains the fields used to create an X.509 v2 Certificate Revocation list with CreateRevocationList.</source>
          <target state="translated">RevocationList에는 CreateRevocationList를 사용하여 X.509 v2 인증서 해지 목록을 만드는 데 사용되는 필드가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="36bf57062b0695082d5c3ab1cea707663eb8d688" translate="yes" xml:space="preserve">
          <source>RevokedCertificate represents the ASN.1 structure of the same name. See RFC 5280, section 5.1.</source>
          <target state="translated">RevokedCertificate는 같은 이름의 ASN.1 구조를 나타냅니다. RFC 5280, 섹션 5.1을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1dbb08e5127fb312affa46a438163965fc7ebf23" translate="yes" xml:space="preserve">
          <source>RightAlign returns a slice where the padding bits are at the beginning. The slice may share memory with the BitString.</source>
          <target state="translated">RightAlign은 패딩 비트가 시작 부분에있는 슬라이스를 반환합니다. 슬라이스는 메모리를 BitString과 공유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86681d4d51562a20e98b2b7ff856763c761235e0" translate="yes" xml:space="preserve">
          <source>Ring.Do</source>
          <target state="translated">Ring.Do</target>
        </trans-unit>
        <trans-unit id="c3de3d65f1bf374c9d07b4dfcda75c2206063f2b" translate="yes" xml:space="preserve">
          <source>Ring.Len</source>
          <target state="translated">Ring.Len</target>
        </trans-unit>
        <trans-unit id="ef738e03a934b3cea0ed8b70a7545fe51b5d290c" translate="yes" xml:space="preserve">
          <source>Ring.Link</source>
          <target state="translated">Ring.Link</target>
        </trans-unit>
        <trans-unit id="7fd8ab417197e9dee9db859427b5d7f544203d42" translate="yes" xml:space="preserve">
          <source>Ring.Move</source>
          <target state="translated">Ring.Move</target>
        </trans-unit>
        <trans-unit id="0851656843c7ec1e30ec39e3f0f5e84ae6a75fcd" translate="yes" xml:space="preserve">
          <source>Ring.Next</source>
          <target state="translated">Ring.Next</target>
        </trans-unit>
        <trans-unit id="61b297ba7e636a60d4221303b63f5d9cc41422d9" translate="yes" xml:space="preserve">
          <source>Ring.Prev</source>
          <target state="translated">Ring.Prev</target>
        </trans-unit>
        <trans-unit id="d7d905b26d8d9e9d4ae570e8e8161e643805b969" translate="yes" xml:space="preserve">
          <source>Ring.Unlink</source>
          <target state="translated">Ring.Unlink</target>
        </trans-unit>
        <trans-unit id="1a9da6de639f9bb2699bfe42d158358d7d6e5dc9" translate="yes" xml:space="preserve">
          <source>Rollback aborts the transaction.</source>
          <target state="translated">롤백이 트랜잭션을 중단합니다.</target>
        </trans-unit>
        <trans-unit id="b1d06a98df3a5bd7537bc07af57648fbe210073d" translate="yes" xml:space="preserve">
          <source>RotateLeft returns the value of x rotated left by (k mod UintSize) bits. To rotate x right by k bits, call RotateLeft(x, -k).</source>
          <target state="translated">RotateLeft는 왼쪽으로 x 회전 한 값을 (k mod UintSize) 비트만큼 반환합니다. x를 k 비트 씩 오른쪽으로 회전하려면 RotateLeft (x, -k)를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="761f01b6be4cc6f5188ea10477b0dc7cd1161d8c" translate="yes" xml:space="preserve">
          <source>RotateLeft16</source>
          <target state="translated">RotateLeft16</target>
        </trans-unit>
        <trans-unit id="d66c06db349417bfddd607ad14fa9bf5a5638d62" translate="yes" xml:space="preserve">
          <source>RotateLeft16 returns the value of x rotated left by (k mod 16) bits. To rotate x right by k bits, call RotateLeft16(x, -k).</source>
          <target state="translated">RotateLeft16은 (k mod 16) 비트만큼 왼쪽으로 회전 한 x 값을 반환합니다. x를 k 비트 씩 오른쪽으로 회전하려면 RotateLeft16 (x, -k)를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="60bcbc4fb2bbce0ec43078cea8be747ff9281e19" translate="yes" xml:space="preserve">
          <source>RotateLeft32</source>
          <target state="translated">RotateLeft32</target>
        </trans-unit>
        <trans-unit id="c60016746c6ad6b197ec5092101071fc87f7021a" translate="yes" xml:space="preserve">
          <source>RotateLeft32 returns the value of x rotated left by (k mod 32) bits. To rotate x right by k bits, call RotateLeft32(x, -k).</source>
          <target state="translated">RotateLeft32는 (k mod 32) 비트만큼 왼쪽으로 회전 한 x 값을 반환합니다. x를 k 비트 씩 오른쪽으로 회전하려면 RotateLeft32 (x, -k)를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="6dc01719e1f445b08ee2ebc7136ef6822502932a" translate="yes" xml:space="preserve">
          <source>RotateLeft64</source>
          <target state="translated">RotateLeft64</target>
        </trans-unit>
        <trans-unit id="c0ff555090cb3bc9a90815cda1f96719ce3d40be" translate="yes" xml:space="preserve">
          <source>RotateLeft64 returns the value of x rotated left by (k mod 64) bits. To rotate x right by k bits, call RotateLeft64(x, -k).</source>
          <target state="translated">RotateLeft64는 (k mod 64) 비트만큼 왼쪽으로 회전 한 x 값을 반환합니다. x를 k 비트 씩 오른쪽으로 회전하려면 RotateLeft64 (x, -k)를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="fdef633274845494879cbf0afeac8f854e3ba879" translate="yes" xml:space="preserve">
          <source>RotateLeft8</source>
          <target state="translated">RotateLeft8</target>
        </trans-unit>
        <trans-unit id="26ebe86c57d1d128d3a27bb9fd4358573f445da7" translate="yes" xml:space="preserve">
          <source>RotateLeft8 returns the value of x rotated left by (k mod 8) bits. To rotate x right by k bits, call RotateLeft8(x, -k).</source>
          <target state="translated">RotateLeft8은 (k mod 8) 비트만큼 왼쪽으로 회전 한 x 값을 반환합니다. x를 k 비트 씩 오른쪽으로 회전하려면 RotateLeft8 (x, -k)를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="ec7b59833520bb2b53fd4d44b3d581720b55c442" translate="yes" xml:space="preserve">
          <source>Round</source>
          <target state="translated">Round</target>
        </trans-unit>
        <trans-unit id="000868eccd1432acf77f6949a96b4844d59b1fce" translate="yes" xml:space="preserve">
          <source>Round operates on the time as an absolute duration since the zero time; it does not operate on the presentation form of the time. Thus, Round(Hour) may return a time with a non-zero minute, depending on the time's Location.</source>
          <target state="translated">라운드는 제로 시간 이후의 절대 지속 시간으로 시간에 작동합니다. 시간의 프리젠 테이션 형식에서는 작동하지 않습니다. 따라서 Round (Hour)는 시간의 위치에 따라 0이 아닌 분으로 시간을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b948ea2f553b57093a9dabad37c8d45230573ca2" translate="yes" xml:space="preserve">
          <source>Round returns the nearest integer, rounding half away from zero.</source>
          <target state="translated">Round는 0에서 반으로 반올림하여 가장 가까운 정수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="09b508228bc941d31ad58d40d683a414360f74b0" translate="yes" xml:space="preserve">
          <source>Round returns the result of rounding d to the nearest multiple of m. The rounding behavior for halfway values is to round away from zero. If the result exceeds the maximum (or minimum) value that can be stored in a Duration, Round returns the maximum (or minimum) duration. If m &amp;lt;= 0, Round returns d unchanged.</source>
          <target state="translated">Round는 d를 가장 가까운 m의 배수로 반올림 한 결과를 반환합니다. 반값의 반올림 동작은 0에서 반올림하는 것입니다. 결과가 Duration에 저장할 수있는 최대 (또는 최소) 값을 초과하면 Round는 최대 (또는 최소) 지속 시간을 반환합니다. m &amp;lt;= 0이면 Round는 변경되지 않은 d를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="46948003a0f2b7ed98f113a7c6a561fd40784b4d" translate="yes" xml:space="preserve">
          <source>Round returns the result of rounding t to the nearest multiple of d (since the zero time). The rounding behavior for halfway values is to round up. If d &amp;lt;= 0, Round returns t stripped of any monotonic clock reading but otherwise unchanged.</source>
          <target state="translated">Round는 t를 0의 가장 가까운 d의 가장 가까운 배수로 반올림 한 결과를 반환합니다. 반값의 반올림 동작은 반올림하는 것입니다. d &amp;lt;= 0 인 경우 Round는 단조로운 클럭 판독 값에서 t를 제거하지만 달리 변경하지 않은 t를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bd8a6768cc1684f5b293529415380ca31ee44b5b" translate="yes" xml:space="preserve">
          <source>RoundToEven</source>
          <target state="translated">RoundToEven</target>
        </trans-unit>
        <trans-unit id="721a33257fa34d285056f870605bb51c3b9a00a0" translate="yes" xml:space="preserve">
          <source>RoundToEven returns the nearest integer, rounding ties to even.</source>
          <target state="translated">RoundToEven은 가장 가까운 정수를 반올림하여 반올림합니다.</target>
        </trans-unit>
        <trans-unit id="31fa67ead55ff94cd48d5e48d25e6ab30cbcca05" translate="yes" xml:space="preserve">
          <source>RoundTrip implements the RoundTripper interface.</source>
          <target state="translated">RoundTrip은 RoundTripper 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="aef4d01bc99ecc3d07fd6dbc9d4b0127aaa57cd4" translate="yes" xml:space="preserve">
          <source>RoundTripper is an interface representing the ability to execute a single HTTP transaction, obtaining the Response for a given Request.</source>
          <target state="translated">RoundTripper는 단일 HTTP 트랜잭션을 실행하여 주어진 요청에 대한 응답을 얻는 기능을 나타내는 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="14ab950eb98caa165c8e3b8a580c9eeda3c87fc0" translate="yes" xml:space="preserve">
          <source>RoundingMode</source>
          <target state="translated">RoundingMode</target>
        </trans-unit>
        <trans-unit id="e0448d85da96897c679953ae05b1d33acf337b63" translate="yes" xml:space="preserve">
          <source>RoundingMode determines how a Float value is rounded to the desired precision. Rounding may change the Float value; the rounding error is described by the Float's Accuracy.</source>
          <target state="translated">RoundingMode는 Float 값이 원하는 정밀도로 반올림되는 방법을 결정합니다. 반올림은 Float 값을 변경할 수 있습니다. 반올림 오차는 Float의 정확도로 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="b1898ce5b72c9fe9acbd96617227555ca58001da" translate="yes" xml:space="preserve">
          <source>Row is the result of calling QueryRow to select a single row.</source>
          <target state="translated">행은 단일 행을 선택하기 위해 QueryRow를 호출 한 결과입니다.</target>
        </trans-unit>
        <trans-unit id="52d0b35277ee4b2b66ec4016620c658d99c7b57a" translate="yes" xml:space="preserve">
          <source>Rows</source>
          <target state="translated">Rows</target>
        </trans-unit>
        <trans-unit id="40bc6f7b056d7162e958bb7c34f2141aad10960f" translate="yes" xml:space="preserve">
          <source>Rows are always in order of increasing entry.Address, but entry.Line may go forward or backward.</source>
          <target state="translated">행은 항상 항목을 증가시키는 순서입니다. 주소, 그러나 항목. 줄은 앞뒤로 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="136224253b0a1cede998fd8310adbf37059cd8b9" translate="yes" xml:space="preserve">
          <source>Rows is an iterator over an executed query's results.</source>
          <target state="translated">행은 실행 된 쿼리 결과에 대한 반복자입니다.</target>
        </trans-unit>
        <trans-unit id="5bf0da8d1e143c858970004b1d4e4fc2c3190c46" translate="yes" xml:space="preserve">
          <source>Rows is the result of a query. Its cursor starts before the first row of the result set. Use Next to advance from row to row.</source>
          <target state="translated">행은 쿼리 결과입니다. 커서는 결과 세트의 첫 번째 행보다 먼저 시작됩니다. 행을 진행하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c7e43ca77abe23e5cf32ea7c3a359b9f55d612a0" translate="yes" xml:space="preserve">
          <source>RowsAffected implements Result for an INSERT or UPDATE operation which mutates a number of rows.</source>
          <target state="translated">영향을받는 행은 여러 행을 변경하는 INSERT 또는 UPDATE 작업에 대한 결과를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="ef8ccf0ef3b6629b0198be9228cd5d4456951fd1" translate="yes" xml:space="preserve">
          <source>RowsColumnTypeDatabaseTypeName may be implemented by Rows. It should return the database system type name without the length. Type names should be uppercase. Examples of returned types: &quot;VARCHAR&quot;, &quot;NVARCHAR&quot;, &quot;VARCHAR2&quot;, &quot;CHAR&quot;, &quot;TEXT&quot;, &quot;DECIMAL&quot;, &quot;SMALLINT&quot;, &quot;INT&quot;, &quot;BIGINT&quot;, &quot;BOOL&quot;, &quot;[]BIGINT&quot;, &quot;JSONB&quot;, &quot;XML&quot;, &quot;TIMESTAMP&quot;.</source>
          <target state="translated">RowsColumnTypeDatabaseTypeName은 Rows로 구현 될 수 있습니다. 길이가없는 데이터베이스 시스템 유형 이름을 리턴해야합니다. 유형 이름은 대문자 여야합니다. 리턴 된 유형의 예 : &quot;VARCHAR&quot;, &quot;NVARCHAR&quot;, &quot;VARCHAR2&quot;, &quot;CHAR&quot;, &quot;TEXT&quot;, &quot;DECIMAL&quot;, &quot;SMALLINT&quot;, &quot;INT&quot;, &quot;BIGINT&quot;, &quot;BOOL&quot;, &quot;[] BIGINT&quot; , &quot;JSONB&quot;, &quot;XML&quot;, &quot;TIMESTAMP&quot;.</target>
        </trans-unit>
        <trans-unit id="3c91b4c84603ef829584c3342618f9e341f34eef" translate="yes" xml:space="preserve">
          <source>RowsColumnTypeLength may be implemented by Rows. It should return the length of the column type if the column is a variable length type. If the column is not a variable length type ok should return false. If length is not limited other than system limits, it should return math.MaxInt64. The following are examples of returned values for various types:</source>
          <target state="translated">RowsColumnTypeLength는 Rows로 구현 될 수 있습니다. 열이 가변 길이 유형 인 경우 열 유형의 길이를 리턴해야합니다. 열이 가변 길이 유형이 아닌 경우 ok는 false를 리턴해야합니다. 시스템 제한 이외의 길이가 제한되지 않으면 math.MaxInt64를 반환해야합니다. 다음은 다양한 유형에 대한 리턴 값의 예입니다.</target>
        </trans-unit>
        <trans-unit id="e25b9be843083730384947899329e16d7e8ce2ee" translate="yes" xml:space="preserve">
          <source>RowsColumnTypeNullable may be implemented by Rows. The nullable value should be true if it is known the column may be null, or false if the column is known to be not nullable. If the column nullability is unknown, ok should be false.</source>
          <target state="translated">RowsColumnTypeNullable은 Rows로 구현 될 수 있습니다. 널 입력 가능 값은 컬럼이 널 (null) 일 수있는 경우 true이거나 컬럼이 널 입력 가능하지 않은 경우 false입니다. 열 Null 허용 여부를 알 수 없으면 ok는 false 여야합니다.</target>
        </trans-unit>
        <trans-unit id="11e1119cb21771faadd92c0fac63385e0fabd647" translate="yes" xml:space="preserve">
          <source>RowsColumnTypePrecisionScale may be implemented by Rows. It should return the precision and scale for decimal types. If not applicable, ok should be false. The following are examples of returned values for various types:</source>
          <target state="translated">RowsColumnTypePrecisionScale은 Rows로 구현 될 수 있습니다. 10 진수 유형의 정밀도와 스케일을 반환해야합니다. 해당되지 않는 경우 ok는 false 여야합니다. 다음은 다양한 유형에 대한 리턴 값의 예입니다.</target>
        </trans-unit>
        <trans-unit id="c4ef56c355e3d98c76299376ceea4adea3479a58" translate="yes" xml:space="preserve">
          <source>RowsColumnTypeScanType may be implemented by Rows. It should return the value type that can be used to scan types into. For example, the database column type &quot;bigint&quot; this should return &quot;reflect.TypeOf(int64(0))&quot;.</source>
          <target state="translated">RowsColumnTypeScanType은 Rows로 구현 될 수 있습니다. 유형을 스캔하는 데 사용할 수있는 값 유형을 리턴해야합니다. 예를 들어 데이터베이스 열 유형 &quot;bigint&quot;는 &quot;reflect.TypeOf (int64 (0))&quot;을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="7efce4893f3ac361f87721da26fe098b878a1c27" translate="yes" xml:space="preserve">
          <source>RowsNextResultSet extends the Rows interface by providing a way to signal the driver to advance to the next result set.</source>
          <target state="translated">RowsNextResultSet는 다음 결과 세트로 진행하도록 드라이버에 신호를 보내는 방법을 제공하여 Rows 인터페이스를 확장합니다.</target>
        </trans-unit>
        <trans-unit id="1ab76c953a9e273e85fb13e73235ab1aa106b9cd" translate="yes" xml:space="preserve">
          <source>Rsh sets z = x &amp;gt;&amp;gt; n and returns z.</source>
          <target state="translated">Rsh는 z = x &amp;gt;&amp;gt; n을 설정하고 z를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="64578d8b2d51c5abcc22005302c8d44dd6d930ad" translate="yes" xml:space="preserve">
          <source>Run benchmarks f as a subbenchmark with the given name. It reports whether there were any failures.</source>
          <target state="translated">주어진 이름으로 하위 벤치 마크로 벤치 마크 f를 실행하십시오. 실패가 있었는지보고합니다.</target>
        </trans-unit>
        <trans-unit id="872b6e9fc5c925d028b4808b5136d4cf35164f22" translate="yes" xml:space="preserve">
          <source>Run does not return until parallel subtests have completed, providing a way to clean up after a group of parallel tests:</source>
          <target state="translated">병렬 하위 테스트가 완료 될 때까지 실행이 반환되지 않으므로 병렬 테스트 그룹 후에 정리할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8c556db4b76966a7511e9f2b360cd616f36f626" translate="yes" xml:space="preserve">
          <source>Run may be called simultaneously from multiple goroutines, but all such calls must return before the outer test function for t returns.</source>
          <target state="translated">Run은 여러 고 루틴에서 동시에 호출 될 수 있지만 t와 같은 외부 테스트 기능을 수행하기 전에 이러한 모든 호출을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="d90bfc177fd90c93bbd1a663aa066ee65d25e1b1" translate="yes" xml:space="preserve">
          <source>Run runs f as a subtest of t called name. It runs f in a separate goroutine and blocks until f returns or calls t.Parallel to become a parallel test. Run reports whether f succeeded (or at least did not fail before calling t.Parallel).</source>
          <target state="translated">run은 f라는 t의 하위 테스트로 f를 실행합니다. 그것은 별도의 고 루틴에서 f를 실행하고 f가 t.Parallel을 호출하거나 병렬 테스트가 될 때까지 차단합니다. f가 성공했는지 (또는 t.Parallel을 호출하기 전에 최소한 실패하지 않았는지)보고합니다.</target>
        </trans-unit>
        <trans-unit id="53e0451894d3b3781ea079b9077c47afbf558128" translate="yes" xml:space="preserve">
          <source>Run runs the tests. It returns an exit code to pass to os.Exit.</source>
          <target state="translated">실행은 테스트를 실행합니다. os.Exit에 전달할 종료 코드를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="48c893a581570ffe26dfe952410c12f6cdc2e260" translate="yes" xml:space="preserve">
          <source>Run starts the specified command and waits for it to complete.</source>
          <target state="translated">실행은 지정된 명령을 시작하고 완료 될 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="f93b07d64251dda56a436dcbde68f9da5bc328c2" translate="yes" xml:space="preserve">
          <source>RunBenchmarks is an internal function but exported because it is cross-package; it is part of the implementation of the &quot;go test&quot; command.</source>
          <target state="translated">RunBenchmarks는 내부 함수이지만 크로스 패키지이기 때문에 내 보냅니다. &quot;go test&quot;명령 구현의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="32dc551964c4269304db7eb1f811d1caad804e12" translate="yes" xml:space="preserve">
          <source>RunExamples is an internal function but exported because it is cross-package; it is part of the implementation of the &quot;go test&quot; command.</source>
          <target state="translated">RunExamples는 내부 함수이지만 크로스 패키지이기 때문에 내 보냅니다. &quot;go test&quot;명령 구현의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="452df5dd646b599a67dd36e4b5527c206ddf15e5" translate="yes" xml:space="preserve">
          <source>RunParallel runs a benchmark in parallel. It creates multiple goroutines and distributes b.N iterations among them. The number of goroutines defaults to GOMAXPROCS. To increase parallelism for non-CPU-bound benchmarks, call SetParallelism before RunParallel. RunParallel is usually used with the go test -cpu flag.</source>
          <target state="translated">RunParallel은 벤치 마크를 병렬로 실행합니다. 여러 고 루틴을 생성하고 이들 사이에 bN 반복을 분산시킵니다. 고 루틴의 수는 기본적으로 GOMAXPROCS입니다. 비 CPU 바운드 벤치 마크의 병렬 처리를 늘리려면 RunParallel 전에 SetParallelism을 호출하십시오. RunParallel은 일반적으로 go test -cpu 플래그와 함께 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="47b2ac0560eb4a2067fd84225d3accb1efb1f8a0" translate="yes" xml:space="preserve">
          <source>RunTests is an internal function but exported because it is cross-package; it is part of the implementation of the &quot;go test&quot; command.</source>
          <target state="translated">RunTests는 내부 함수이지만 크로스 패키지이기 때문에 내 보냅니다. &quot;go test&quot;명령 구현의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="c1304d4ae46895f99bd865fe49bce5376fb7e0b6" translate="yes" xml:space="preserve">
          <source>RuneCount</source>
          <target state="translated">RuneCount</target>
        </trans-unit>
        <trans-unit id="ed1038ffbfe375ac70c3f1a1ca67f29234afffbf" translate="yes" xml:space="preserve">
          <source>RuneCount returns the number of runes in p. Erroneous and short encodings are treated as single runes of width 1 byte.</source>
          <target state="translated">RuneCount는 p의 룬 수를 반환합니다. 잘못되고 짧은 인코딩은 너비가 1 바이트 인 단일 룬으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="78c4e1dde9ab6b8f5586f9612a115ee5d698d2fb" translate="yes" xml:space="preserve">
          <source>RuneCountInString</source>
          <target state="translated">RuneCountInString</target>
        </trans-unit>
        <trans-unit id="f740d84fa32707ddc183ab07c7c8f221a896cf18" translate="yes" xml:space="preserve">
          <source>RuneCountInString is like RuneCount but its input is a string.</source>
          <target state="translated">RuneCountInString은 RuneCount와 유사하지만 입력은 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="7f39387ee01e0d6561f94fb1cc196d068d979052" translate="yes" xml:space="preserve">
          <source>RuneLen</source>
          <target state="translated">RuneLen</target>
        </trans-unit>
        <trans-unit id="da827d364b8d785022152482b581a5b08129882b" translate="yes" xml:space="preserve">
          <source>RuneLen returns the number of bytes required to encode the rune. It returns -1 if the rune is not a valid value to encode in UTF-8.</source>
          <target state="translated">RuneLen은 룬을 인코딩하는 데 필요한 바이트 수를 반환합니다. 룬이 UTF-8로 인코딩하기에 유효한 값이 아닌 경우 -1을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="cf36c219da8d056dc79efd005cdbeaf40198de2a" translate="yes" xml:space="preserve">
          <source>RuneReader is the interface that wraps the ReadRune method.</source>
          <target state="translated">RuneReader는 ReadRune 메서드를 래핑하는 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="8dce52bc0fa438508ccfe7940691e478794d8014" translate="yes" xml:space="preserve">
          <source>RuneScanner is the interface that adds the UnreadRune method to the basic ReadRune method.</source>
          <target state="translated">RuneScanner는 UnreadRune 메소드를 기본 ReadRune 메소드에 추가하는 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="48c879258018813f4ec13050feaaab65a67d910b" translate="yes" xml:space="preserve">
          <source>RuneStart</source>
          <target state="translated">RuneStart</target>
        </trans-unit>
        <trans-unit id="6b79de7db8117808de36133366c8ef414e9c5c82" translate="yes" xml:space="preserve">
          <source>RuneStart reports whether the byte could be the first byte of an encoded, possibly invalid rune. Second and subsequent bytes always have the top two bits set to 10.</source>
          <target state="translated">RuneStart는 바이트가 인코딩 된 유효하지 않은 룬의 첫 번째 바이트 일 수 있는지보고합니다. 두 번째 및 이후 바이트는 항상 상위 2 비트가 10으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="6756bd3e1a442e2ce0d16a235b1d5c8c2882b1e6" translate="yes" xml:space="preserve">
          <source>Runes</source>
          <target state="translated">Runes</target>
        </trans-unit>
        <trans-unit id="9a62b7b5f90f9e424bb04160b8de2eb558ee92a9" translate="yes" xml:space="preserve">
          <source>Runes interprets s as a sequence of UTF-8-encoded code points. It returns a slice of runes (Unicode code points) equivalent to s.</source>
          <target state="translated">Runes는 s를 일련의 UTF-8 인코딩 코드 포인트로 해석합니다. s에 해당하는 룬 조각 (유니 코드 코드 포인트)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f5d45a3fe840544aad462798c4e4ed8942f7ef58" translate="yes" xml:space="preserve">
          <source>Running &quot;go vet&quot; can help find uses of Pointer that do not conform to these patterns, but silence from &quot;go vet&quot; is not a guarantee that the code is valid.</source>
          <target state="translated">&quot;go vet&quot;을 실행하면 이러한 패턴에 맞지 않는 포인터 사용을 찾는 데 도움이되지만 &quot;go vet&quot;의 침묵은 코드가 유효하다는 것을 보증하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aeacdbd801cd3a6c88be9cbc91df0dca2b46aba8" translate="yes" xml:space="preserve">
          <source>SHA-1 is cryptographically broken and should not be used for secure applications.</source>
          <target state="translated">SHA-1은 암호화 방식으로 손상되어 보안 응용 프로그램에 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="1d7bc000e103e4ca4294205e7c5c40ddc6f69520" translate="yes" xml:space="preserve">
          <source>SHA2-512(priv.D || entropy || hash)[:32]</source>
          <target state="translated">SHA2-512 (priv.D || 엔트로피 || 해시) [: 32]</target>
        </trans-unit>
        <trans-unit id="7b3caa78fa594eb19ef5d1955f9e6f4a06aac1d4" translate="yes" xml:space="preserve">
          <source>SIGPIPE</source>
          <target state="translated">SIGPIPE</target>
        </trans-unit>
        <trans-unit id="91d8535876524df724c0df972b3fd914eb03fb2f" translate="yes" xml:space="preserve">
          <source>SameFile reports whether fi1 and fi2 describe the same file. For example, on Unix this means that the device and inode fields of the two underlying structures are identical; on other systems the decision may be based on the path names. SameFile only applies to results returned by this package's Stat. It returns false in other cases.</source>
          <target state="translated">SameFile은 fi1과 fi2가 동일한 파일을 설명하는지 여부를보고합니다. 예를 들어, Unix에서 이것은 두 기본 구조의 디바이스와 inode 필드가 동일하다는 것을 의미합니다. 다른 시스템에서는 결정이 경로 이름을 기반으로 할 수 있습니다. SameFile은이 패키지의 Stat에 의해 반환 된 결과에만 적용됩니다. 다른 경우에는 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9f57e34c6960ba52fd743b2bc0ff1557eb707bd2" translate="yes" xml:space="preserve">
          <source>SameSite allows a server to define a cookie attribute making it impossible for the browser to send this cookie along with cross-site requests. The main goal is to mitigate the risk of cross-origin information leakage, and provide some protection against cross-site request forgery attacks.</source>
          <target state="translated">SameSite는 서버가 쿠키 속성을 정의하여 브라우저가 사이트 간 요청과 함께이 쿠키를 보낼 수 없도록합니다. 주요 목표는 출처 간 정보 유출 위험을 완화하고 사이트 간 요청 위조 공격에 대한 보호 기능을 제공하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a0b6fd267e524ab1b350adb6e2b1dd91cd63b1b3" translate="yes" xml:space="preserve">
          <source>Sample captures a single metric sample.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="629f25cee39d2ec711564ddf90e361792133879f" translate="yes" xml:space="preserve">
          <source>Sample values with names not appearing in All will have their Value populated as KindBad to indicate that the name is unknown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8abf172daab8b3ea3c6865151b033d1cd5e837c" translate="yes" xml:space="preserve">
          <source>Scan adds line information to the file added to the file set with Init. Token positions are relative to that file and thus relative to the file set.</source>
          <target state="translated">스캔은 Init으로 설정된 파일에 추가 된 파일에 행 정보를 추가합니다. 토큰 위치는 해당 파일을 기준으로하므로 파일 세트를 기준으로합니다.</target>
        </trans-unit>
        <trans-unit id="e4ac4597c96634ebcbf4b7a158793f756f373f9c" translate="yes" xml:space="preserve">
          <source>Scan advances the Scanner to the next token, which will then be available through the Bytes or Text method. It returns false when the scan stops, either by reaching the end of the input or an error. After Scan returns false, the Err method will return any error that occurred during scanning, except that if it was io.EOF, Err will return nil. Scan panics if the split function returns too many empty tokens without advancing the input. This is a common error mode for scanners.</source>
          <target state="translated">스캔은 스캐너를 다음 토큰으로 진행 한 다음 바이트 또는 텍스트 방법을 통해 사용할 수 있습니다. 입력이 끝나거나 오류가 발생하여 스캔이 중지되면 false를 반환합니다. Scan이 false를 반환하면 Err 메서드는 io.EOF 인 경우 Err이 nil을 반환한다는 점을 제외하고 검색 중에 발생한 오류를 반환합니다. split 함수가 입력을 진행하지 않고 빈 토큰을 너무 많이 반환하면 패닉을 스캔하십시오. 스캐너의 일반적인 오류 모드입니다.</target>
        </trans-unit>
        <trans-unit id="19b1c6ecbd861a4833fc5e32bbb8df547210090f" translate="yes" xml:space="preserve">
          <source>Scan also converts between string and numeric types, as long as no information would be lost. While Scan stringifies all numbers scanned from numeric database columns into *string, scans into numeric types are checked for overflow. For example, a float64 with value 300 or a string with value &quot;300&quot; can scan into a uint16, but not into a uint8, though float64(255) or &quot;255&quot; can scan into a uint8. One exception is that scans of some float64 numbers to strings may lose information when stringifying. In general, scan floating point columns into *float64.</source>
          <target state="translated">또한 정보가 손실되지 않는 한 스캔은 문자열과 숫자 유형 사이를 변환합니다. 스캔은 숫자 데이터베이스 열에서 스캔 된 모든 숫자를 * 문자열로 문자열 화하지만 숫자 유형으로 스캔하면 오버 플로우가 있는지 점검합니다. 예를 들어, 값이 300 인 float64 또는 값이 &quot;300&quot;인 문자열은 uint16으로 스캔 할 수 있지만 uint8로는 스캔 할 수 없지만 float64 (255) 또는 &quot;255&quot;는 uint8로 스캔 할 수 있습니다. 일부 float64 숫자를 문자열로 스캔하면 문자열 화시 정보가 손실 될 수 있습니다. 일반적으로 부동 소수점 열을 * float64로 스캔하십시오.</target>
        </trans-unit>
        <trans-unit id="feb542d2e67b91b0880c1fd1b4cf7b50af77bd5b" translate="yes" xml:space="preserve">
          <source>Scan can also convert a cursor returned from a query, such as &quot;select cursor(select * from my_table) from dual&quot;, into a *Rows value that can itself be scanned from. The parent select query will close any cursor *Rows if the parent *Rows is closed.</source>
          <target state="translated">스캔은 또한 쿼리에서 리턴 된 커서 (예 : &quot;select cursor (select * from my_table) from dual&quot;)를 자체적으로 스캔 할 수있는 * Rows 값으로 변환 할 수 있습니다. 부모 * 행이 닫히면 부모 선택 쿼리는 커서 * 행을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="48ec4d9dec15d05d875f1baa84e9dcd1d7cc9f07" translate="yes" xml:space="preserve">
          <source>Scan converts columns read from the database into the following common Go types and special types provided by the sql package:</source>
          <target state="translated">스캔은 데이터베이스에서 읽은 열을 sql 패키지에서 제공하는 다음 공통 Go 유형 및 특수 유형으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="2677a1f2dd5662fd0ec43cba40359a57293f1867" translate="yes" xml:space="preserve">
          <source>Scan copies the columns from the matched row into the values pointed at by dest. See the documentation on Rows.Scan for details. If more than one row matches the query, Scan uses the first row and discards the rest. If no row matches the query, Scan returns ErrNoRows.</source>
          <target state="translated">Scan은 일치하는 행의 열을 dest가 가리키는 값으로 복사합니다. 자세한 내용은 Rows.Scan 설명서를 참조하십시오. 둘 이상의 행이 쿼리와 일치하면 Scan은 첫 번째 행을 사용하고 나머지는 버립니다. 쿼리와 일치하는 행이 없으면 Scan은 ErrNoRows를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d701545494296850286215953fde0ddf540061d1" translate="yes" xml:space="preserve">
          <source>Scan copies the columns in the current row into the values pointed at by dest. The number of values in dest must be the same as the number of columns in Rows.</source>
          <target state="translated">Scan은 현재 행의 열을 dest가 가리키는 값으로 복사합니다. dest의 값 수는 행의 열 수와 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="0a799e57e8d283a9aa1ec133950cd6bd3e127332" translate="yes" xml:space="preserve">
          <source>Scan implements the Scanner interface.</source>
          <target state="translated">스캔은 스캐너 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="bd92cac731a36521f9119e135b2c47485aabb150" translate="yes" xml:space="preserve">
          <source>Scan is a support routine for fmt.Scanner. It accepts the formats 'e', 'E', 'f', 'F', 'g', 'G', and 'v'. All formats are equivalent.</source>
          <target state="translated">스캔은 fmt.Scanner 지원 루틴입니다. 'e', 'E', 'f', 'F', 'g', 'G'및 'v'형식을 허용합니다. 모든 형식은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="d953d557a4046bfc8df6c55ce44c304f6ff14a59" translate="yes" xml:space="preserve">
          <source>Scan is a support routine for fmt.Scanner; it sets z to the value of the scanned number. It accepts formats whose verbs are supported by fmt.Scan for floating point values, which are: 'b' (binary), 'e', 'E', 'f', 'F', 'g' and 'G'. Scan doesn't handle &amp;plusmn;Inf.</source>
          <target state="translated">스캔은 fmt.Scanner 지원 루틴입니다. z를 스캔 된 숫자 값으로 설정합니다. fmt.에서 동사를 지원하는 형식을 허용합니다. 'b'(이진), 'e', ​​'E', 'f', 'F', 'g'및 'G'와 같은 부동 소수점 값을 스캔합니다. 스캔이 &amp;plusmn; Inf를 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ac6efbbbf8b516bb14977cb03cef43746936b2f5" translate="yes" xml:space="preserve">
          <source>Scan is a support routine for fmt.Scanner; it sets z to the value of the scanned number. It accepts the formats 'b' (binary), 'o' (octal), 'd' (decimal), 'x' (lowercase hexadecimal), and 'X' (uppercase hexadecimal).</source>
          <target state="translated">스캔은 fmt.Scanner 지원 루틴입니다. z를 스캔 된 숫자 값으로 설정합니다. 'b'(2 진), 'o'(8 진), 'd'(10 진), 'x'(16 진 소문자) 및 'X'(16 진 대문자) 형식을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="386a7678b7de663dffac69cf7ab3e1a7092be8f9" translate="yes" xml:space="preserve">
          <source>Scan reads the next token or Unicode character from source and returns it. It only recognizes tokens t for which the respective Mode bit (1&amp;lt;&amp;lt;-t) is set. It returns EOF at the end of the source. It reports scanner errors (read and token errors) by calling s.Error, if not nil; otherwise it prints an error message to os.Stderr.</source>
          <target state="translated">스캔은 소스에서 다음 토큰 또는 유니 코드 문자를 읽고 리턴합니다. 각 모드 비트 (1 &amp;lt;&amp;lt;-t)가 설정된 토큰 t 만 인식합니다. 소스의 끝에 EOF를 리턴합니다. nil이 아닌 경우 s.Error를 호출하여 스캐너 오류 (읽기 및 토큰 오류)를보고합니다. 그렇지 않으면 오류 메시지를 os.Stderr에 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="981608b22833d116739df1bad639bfec043f4338" translate="yes" xml:space="preserve">
          <source>Scan scans text read from standard input, storing successive space-separated values into successive arguments. Newlines count as space. It returns the number of items successfully scanned. If that is less than the number of arguments, err will report why.</source>
          <target state="translated">스캔은 표준 입력에서 읽은 텍스트를 스캔하여 연속 공백으로 구분 된 값을 연속 인수에 저장합니다. 줄 바꿈은 공백으로 계산됩니다. 성공적으로 스캔 한 항목 수를 반환합니다. 그것이 인수의 수보다 적 으면, err가 이유를보고합니다.</target>
        </trans-unit>
        <trans-unit id="9421db6432c3608ab7d6333584635bf58a2d9300" translate="yes" xml:space="preserve">
          <source>Scan scans the next token and returns the token position, the token, and its literal string if applicable. The source end is indicated by token.EOF.</source>
          <target state="translated">스캔은 다음 토큰을 스캔하고 해당되는 경우 토큰 위치, 토큰 및 리터럴 문자열을 리턴합니다. 소스 엔드는 token.EOF로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="b3d5e9556bfff0957b67d0485be76ef988e69293" translate="yes" xml:space="preserve">
          <source>Scan, Fscan, Sscan treat newlines in the input as spaces.</source>
          <target state="translated">스캔, Fscan, Sscan은 입력의 개행을 공백으로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="f2ef262aa067e44dfcde945e7bebf0433b1baaed" translate="yes" xml:space="preserve">
          <source>ScanBytes is a split function for a Scanner that returns each byte as a token.</source>
          <target state="translated">ScanBytes는 각 바이트를 토큰으로 반환하는 스캐너의 분할 기능입니다.</target>
        </trans-unit>
        <trans-unit id="d509b35e48ef6a5d396ee01678b179a959774867" translate="yes" xml:space="preserve">
          <source>ScanLines is a split function for a Scanner that returns each line of text, stripped of any trailing end-of-line marker. The returned line may be empty. The end-of-line marker is one optional carriage return followed by one mandatory newline. In regular expression notation, it is `\r?\n`. The last non-empty line of input will be returned even if it has no newline.</source>
          <target state="translated">ScanLines는 스캐너의 분할 기능으로, 모든 텍스트 줄을 반환하여 줄 끝 마커를 제거합니다. 반환 된 줄이 비어있을 수 있습니다. 줄 끝 마커는 하나의 선택적인 캐리지 리턴과 하나의 필수 개행입니다. 정규식 표기법에서는`\ r? \ n`입니다. 비어 있지 않은 마지막 입력 행은 줄 바꿈이 없어도 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b4049bc82d2e16ae520fd9c175cc98d3e8214592" translate="yes" xml:space="preserve">
          <source>ScanRunes is a split function for a Scanner that returns each UTF-8-encoded rune as a token. The sequence of runes returned is equivalent to that from a range loop over the input as a string, which means that erroneous UTF-8 encodings translate to U+FFFD = &quot;\xef\xbf\xbd&quot;. Because of the Scan interface, this makes it impossible for the client to distinguish correctly encoded replacement runes from encoding errors.</source>
          <target state="translated">ScanRunes는 UTF-8로 인코딩 된 각 룬을 토큰으로 반환하는 검사기의 분할 기능입니다. 리턴 된 룬 순서는 입력에 대한 범위 루프에서 문자열로 표시되는 순서와 동일합니다. 이는 잘못된 UTF-8 인코딩이 U + FFFD = &quot;\ xef \ xbf \ xbd&quot;로 변환됨을 의미합니다. 스캔 인터페이스로 인해 클라이언트가 인코딩 된 대체 룬을 인코딩 오류와 구별 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f4641d488fdcb83f61b3c11fd542f4c6a3c4ffa5" translate="yes" xml:space="preserve">
          <source>ScanState represents the scanner state passed to custom scanners. Scanners may do rune-at-a-time scanning or ask the ScanState to discover the next space-delimited token.</source>
          <target state="translated">ScanState는 사용자 정의 스캐너로 전달 된 스캐너 상태를 나타냅니다. 스캐너는 한 번에 한 번씩 스캔을 수행하거나 ScanState에 다음으로 구분 된 토큰을 찾도록 요청할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59161b57fccdcbdd902cc6d57c2979e0dc44f79e" translate="yes" xml:space="preserve">
          <source>ScanType returns a Go type suitable for scanning into using Rows.Scan. If a driver does not support this property ScanType will return the type of an empty interface.</source>
          <target state="translated">ScanType은 Rows.Scan을 사용하여 스캔하기에 적합한 Go 유형을 반환합니다. 드라이버가이 속성을 지원하지 않으면 ScanType은 빈 인터페이스의 유형을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="faa25d7e517bfa0b7ebed36b40faf73e8faf8ace" translate="yes" xml:space="preserve">
          <source>ScanWords is a split function for a Scanner that returns each space-separated word of text, with surrounding spaces deleted. It will never return an empty string. The definition of space is set by unicode.IsSpace.</source>
          <target state="translated">ScanWords는 스캐너를위한 분할 기능으로, 공백으로 구분 된 각 단어를 반환하고 주변 공백은 삭제합니다. 빈 문자열을 반환하지 않습니다. 공간 정의는 unicode.IsSpace로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="bc0d545831527f222a939e3851bf7f5c1605d659" translate="yes" xml:space="preserve">
          <source>Scanf scans text read from standard input, storing successive space-separated values into successive arguments as determined by the format. It returns the number of items successfully scanned. If that is less than the number of arguments, err will report why. Newlines in the input must match newlines in the format. The one exception: the verb %c always scans the next rune in the input, even if it is a space (or tab etc.) or newline.</source>
          <target state="translated">Scanf는 표준 입력에서 읽은 텍스트를 스캔하여 형식으로 결정된 연속 공백으로 구분 된 값을 연속 인수로 저장합니다. 성공적으로 스캔 한 항목 수를 반환합니다. 그것이 인수의 수보다 적 으면, err가 이유를보고합니다. 입력의 개행은 형식의 개행과 일치해야합니다. 한 가지 예외 : 동사 % c는 공백 (또는 탭 등) 또는 줄 바꿈 인 경우에도 입력에서 다음 룬을 항상 스캔합니다.</target>
        </trans-unit>
        <trans-unit id="6f640beb056a4e8e9aa6bfcd8d1f5bf1b4feaaee" translate="yes" xml:space="preserve">
          <source>Scanf, Fscanf, and Sscanf parse the arguments according to a format string, analogous to that of Printf. In the text that follows, 'space' means any Unicode whitespace character except newline.</source>
          <target state="translated">Scanf, Fscanf 및 Sscanf는 Printf와 유사한 형식 문자열에 따라 인수를 구문 분석합니다. 다음 텍스트에서 'space'는 줄 바꿈을 제외한 모든 유니 코드 공백 문자를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="c8ed7e72e9070ffbdd1df56f018a211791f2dcc9" translate="yes" xml:space="preserve">
          <source>Scanln is similar to Scan, but stops scanning at a newline and after the final item there must be a newline or EOF.</source>
          <target state="translated">Scanln은 스캔과 비슷하지만 줄 바꿈에서 스캔을 중지하며 마지막 항목 뒤에 줄 바꿈 또는 EOF가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="22a932411390fa7368633b6d040508332e0196e9" translate="yes" xml:space="preserve">
          <source>Scanln, Fscanln and Sscanln stop scanning at a newline and require that the items be followed by a newline or EOF.</source>
          <target state="translated">Scanln, Fscanln 및 Sscanln은 줄 바꿈에서 스캔을 중지하고 항목 뒤에 줄 바꿈 또는 EOF가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="01c8580ef4911b472b2f5804014f5bd82d1af7aa" translate="yes" xml:space="preserve">
          <source>Scanner (Custom)</source>
          <target state="translated">스캐너 (사용자 정의)</target>
        </trans-unit>
        <trans-unit id="1d4892a40553aaa21bb91693fe76c51b9f51e530" translate="yes" xml:space="preserve">
          <source>Scanner (EmptyFinalToken)</source>
          <target state="translated">스캐너 (EmptyFinalToken)</target>
        </trans-unit>
        <trans-unit id="d1ca38099d8459b3cc3f6b48eaf9fc6b340ae9b4" translate="yes" xml:space="preserve">
          <source>Scanner (Lines)</source>
          <target state="translated">스캐너 (라인)</target>
        </trans-unit>
        <trans-unit id="ab67b93c24c839ac0830f79b29ad7b412a9dc7b4" translate="yes" xml:space="preserve">
          <source>Scanner (Words)</source>
          <target state="translated">스캐너 (워드)</target>
        </trans-unit>
        <trans-unit id="2192924325d3946492271abc8671373e1f38daa1" translate="yes" xml:space="preserve">
          <source>Scanner is an interface used by Scan.</source>
          <target state="translated">스캐너는 스캔에서 사용되는 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="16f1f8a9cae9f1e07478a7953ec158b0c2b03d9c" translate="yes" xml:space="preserve">
          <source>Scanner is implemented by any value that has a Scan method, which scans the input for the representation of a value and stores the result in the receiver, which must be a pointer to be useful. The Scan method is called for any argument to Scan, Scanf, or Scanln that implements it.</source>
          <target state="translated">스캐너는 Scan 메서드가있는 값으로 구현됩니다.이 메서드는 값 표현을 위해 입력을 스캔하고 결과를 수신기에 저장합니다. 이는 유용한 포인터 여야합니다. Scan 메서드는 Scan, Scanf 또는 Scanln을 구현하는 모든 인수에 대해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="76f47cb3079e4595ce1c03abbd158345ae636c90" translate="yes" xml:space="preserve">
          <source>Scanner provides a convenient interface for reading data such as a file of newline-delimited lines of text. Successive calls to the Scan method will step through the 'tokens' of a file, skipping the bytes between the tokens. The specification of a token is defined by a split function of type SplitFunc; the default split function breaks the input into lines with line termination stripped. Split functions are defined in this package for scanning a file into lines, bytes, UTF-8-encoded runes, and space-delimited words. The client may instead provide a custom split function.</source>
          <target state="translated">스캐너는 줄 바꿈으로 구분 된 텍스트 줄과 같은 데이터를 읽기위한 편리한 인터페이스를 제공합니다. Scan 메서드에 대한 연속적인 호출은 파일의 '토큰'을 단계별로 실행하여 토큰 사이의 바이트를 건너 뜁니다. 토큰의 사양은 SplitFunc 유형의 split 함수로 정의됩니다. 기본 스플릿 기능은 라인 터미네이션이 제거 된 라인으로 입력을 분리합니다. 이 패키지에는 파일을 행, 바이트, UTF-8로 인코딩 된 룬 및 공백으로 구분 된 단어로 스캔하기위한 분할 기능이 정의되어 있습니다. 클라이언트는 대신 사용자 정의 스플릿 기능을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="221c21d253261d097c5eddd34e07f0e854f9f8be" translate="yes" xml:space="preserve">
          <source>Scanner.Bytes</source>
          <target state="translated">Scanner.Bytes</target>
        </trans-unit>
        <trans-unit id="db2650dfa50b9653ed3b24b83e400aa246e21e57" translate="yes" xml:space="preserve">
          <source>Scanner.Scan</source>
          <target state="translated">Scanner.Scan</target>
        </trans-unit>
        <trans-unit id="e230f66cb2480e61c70e7940e1168e3d3dc1b2cf" translate="yes" xml:space="preserve">
          <source>Scanning</source>
          <target state="translated">Scanning</target>
        </trans-unit>
        <trans-unit id="0e43a71fd5dc304b08b8c37610739914b52545a4" translate="yes" xml:space="preserve">
          <source>Scanning stops if the function returns an error, in which case some of the input may be discarded.</source>
          <target state="translated">함수가 오류를 반환하면 스캔이 중지되며이 경우 일부 입력이 삭제 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3672319a15266023841ffc344b2b9ae68437119" translate="yes" xml:space="preserve">
          <source>Scanning stops unrecoverably at EOF, the first I/O error, or a token too large to fit in the buffer. When a scan stops, the reader may have advanced arbitrarily far past the last token. Programs that need more control over error handling or large tokens, or must run sequential scans on a reader, should use bufio.Reader instead.</source>
          <target state="translated">EOF, 첫 번째 I / O 오류 또는 버퍼에 비해 너무 큰 토큰에서 스캔이 복구 불가능하게 중지됩니다. 스캔이 중지되면 리더가 마지막 토큰을 지나쳐 임의로 이동했을 수 있습니다. 오류 처리 또는 큰 토큰에 대해 더 많은 제어가 필요하거나 리더에서 순차적 스캔을 실행해야하는 프로그램은 bufio.Reader를 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="4651a34e4df9619783ad372f905d6d3b84e9d76d" translate="yes" xml:space="preserve">
          <source>Scope</source>
          <target state="translated">Scope</target>
        </trans-unit>
        <trans-unit id="2ebfb1a9903c43a33373f64197eeaf8911c9f134" translate="yes" xml:space="preserve">
          <source>Scope returns the (complete or incomplete) package scope holding the objects declared at package level (TypeNames, Consts, Vars, and Funcs).</source>
          <target state="translated">Scope는 패키지 수준에서 선언 된 객체 (TypeNames, Consts, Vars 및 Funcs)를 포함하는 (완전 또는 불완전) 패키지 범위를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f31d3986ec66463fe9a83dfd9a2accc1b70877c7" translate="yes" xml:space="preserve">
          <source>Scope returns the scope of the function's body block.</source>
          <target state="translated">범위는 함수 본문 블록의 범위를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="caf135bc624d4b0feb9650ec0d00441eafcdc77d" translate="yes" xml:space="preserve">
          <source>Scripts is the set of Unicode script tables.</source>
          <target state="translated">스크립트는 유니 코드 스크립트 테이블 세트입니다.</target>
        </trans-unit>
        <trans-unit id="bce06414177f72ab70e6387b6af9f8ceef0d6049" translate="yes" xml:space="preserve">
          <source>Search</source>
          <target state="translated">Search</target>
        </trans-unit>
        <trans-unit id="f3e40d362f51c406a8e1778fc061f0dd3ad57de4" translate="yes" xml:space="preserve">
          <source>Search (DescendingOrder)</source>
          <target state="translated">검색 (내림차순)</target>
        </trans-unit>
        <trans-unit id="fdbb604a543d329419799366cc3a9af7390d3bcf" translate="yes" xml:space="preserve">
          <source>Search returns the result of applying SearchFloat64s to the receiver and x.</source>
          <target state="translated">검색은 SearchFloat64를 수신기와 x에 적용한 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1ab6c8f0fd768a91b3e79c036cb01cc452193fe2" translate="yes" xml:space="preserve">
          <source>Search returns the result of applying SearchInts to the receiver and x.</source>
          <target state="translated">검색은 SearchInts를 수신자와 x에 적용한 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1c4f638fca65e5a738654ac393880f806f3b7f65" translate="yes" xml:space="preserve">
          <source>Search returns the result of applying SearchStrings to the receiver and x.</source>
          <target state="translated">검색은 SearchStrings를 수신자와 x에 적용한 결과를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="794b977a863a1d9dc8d7b0fd80d6eef6736bd69e" translate="yes" xml:space="preserve">
          <source>Search uses binary search to find and return the smallest index i in [0, n) at which f(i) is true, assuming that on the range [0, n), f(i) == true implies f(i+1) == true. That is, Search requires that f is false for some (possibly empty) prefix of the input range [0, n) and then true for the (possibly empty) remainder; Search returns the first true index. If there is no such index, Search returns n. (Note that the &quot;not found&quot; return value is not -1 as in, for instance, strings.Index.) Search calls f(i) only for i in the range [0, n).</source>
          <target state="translated">검색은 이진 검색을 사용하여 [0, n) 범위에서 f (i) == true 인 경우 f (i + 1) == 참. 즉, 검색에서는 입력 범위 [0, n)의 일부 (비어있을 수있는) 접두어에 대해 f가 false이고 나머지 (비어있을 수 있음) 인 경우에는 true 여야합니다. 검색은 첫 번째 실제 인덱스를 반환합니다. 그러한 색인이 없으면 검색은 n을 리턴합니다. &quot;찾을 수 없음&quot;반환 값은 예를 들어 strings.Index와 같이 -1이 아닙니다. 검색은 [0, n) 범위의 i에 대해서만 f (i)를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="895f11590a6ed175f7bac01b38c2ec5640f6fc28" translate="yes" xml:space="preserve">
          <source>SearchFloat64s searches for x in a sorted slice of float64s and returns the index as specified by Search. The return value is the index to insert x if x is not present (it could be len(a)). The slice must be sorted in ascending order.</source>
          <target state="translated">SearchFloat64s는 정렬 된 float64 조각에서 x를 검색하고 검색에 지정된대로 색인을 리턴합니다. 반환 값은 x가 없으면 x를 삽입하는 인덱스입니다 (len (a) 일 수 있음). 슬라이스는 오름차순으로 정렬해야합니다.</target>
        </trans-unit>
        <trans-unit id="b48f643546b25f6e6918e845a0e8a3ab0175ad09" translate="yes" xml:space="preserve">
          <source>SearchInts searches for x in a sorted slice of ints and returns the index as specified by Search. The return value is the index to insert x if x is not present (it could be len(a)). The slice must be sorted in ascending order.</source>
          <target state="translated">SearchInts는 정렬 된 int 슬라이스에서 x를 검색하고 Search에 지정된 인덱스를 반환합니다. 반환 값은 x가 없으면 x를 삽입하는 인덱스입니다 (len (a) 일 수 있음). 슬라이스는 오름차순으로 정렬해야합니다.</target>
        </trans-unit>
        <trans-unit id="ed762c6e866455b20a9bc0ff477d563626862413" translate="yes" xml:space="preserve">
          <source>SearchStrings searches for x in a sorted slice of strings and returns the index as specified by Search. The return value is the index to insert x if x is not present (it could be len(a)). The slice must be sorted in ascending order.</source>
          <target state="translated">SearchStrings는 정렬 된 문자열 조각에서 x를 검색하고 검색에 지정된대로 색인을 리턴합니다. 반환 값은 x가 없으면 x를 삽입하는 인덱스입니다 (len (a) 일 수 있음). 슬라이스는 오름차순으로 정렬해야합니다.</target>
        </trans-unit>
        <trans-unit id="d1110c735a627c55e67957485addfcd1740c3fa1" translate="yes" xml:space="preserve">
          <source>Searching data sorted in descending order would use the &amp;lt;= operator instead of the &amp;gt;= operator.</source>
          <target state="translated">내림차순으로 정렬 된 데이터를 검색하면&amp;gt; = 연산자 대신 &amp;lt;= 연산자가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0feecc756efff0f52e43fa2ad18e92887874359a" translate="yes" xml:space="preserve">
          <source>Second returns the second offset within the minute specified by t, in the range [0, 59].</source>
          <target state="translated">Second는 t로 지정된 분 내에서 [0, 59] 범위에서 두 번째 오프셋을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dc37c27c2403f9ad16f9ab9d1b775208efbdf200" translate="yes" xml:space="preserve">
          <source>Second, if a directory's ReadDir method fails, WalkDir calls the function with path set to the directory's path, d set to an fs.DirEntry describing the directory, and err set to the error from ReadDir. In this second case, the function is called twice with the path of the directory: the first call is before the directory read is attempted and has err set to nil, giving the function a chance to return SkipDir and avoid the ReadDir entirely. The second call is after a failed ReadDir and reports the error from ReadDir. (If ReadDir succeeds, there is no second call.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1de746bd641a2fc1f0ddf0dfe26386c6e5724ff" translate="yes" xml:space="preserve">
          <source>Second, if a directory's Readdirnames method fails, Walk calls the function with path set to the directory's path, info, set to an fs.FileInfo describing the directory, and err set to the error from Readdirnames.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aec1eca3aa532659c858922be555e4b78f91472b" translate="yes" xml:space="preserve">
          <source>Seconds returns the duration as a floating point number of seconds.</source>
          <target state="translated">초는 지속 시간을 부동 소수점 수 (초)로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="883d7225a5feea9c004792c2e5762e5e8b90b937" translate="yes" xml:space="preserve">
          <source>Section compression type.</source>
          <target state="translated">섹션 압축 유형.</target>
        </trans-unit>
        <trans-unit id="23c76af95b6f5d08de2ecfd9a9b5758fd241b4b6" translate="yes" xml:space="preserve">
          <source>Section flags.</source>
          <target state="translated">섹션 플래그.</target>
        </trans-unit>
        <trans-unit id="62f89d87896d7ef06a64cbb776d3fd356378e295" translate="yes" xml:space="preserve">
          <source>Section provides access to PE COFF section.</source>
          <target state="translated">섹션은 PE COFF 섹션에 대한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0a9d0e16d038258c30fb66c2551ff2e94b6e8ab2" translate="yes" xml:space="preserve">
          <source>Section returns a section with the given name, or nil if no such section exists.</source>
          <target state="translated">Section은 주어진 이름의 섹션을 반환하거나 해당 섹션이 없으면 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fc54ab0b090fa88e8cee7f8d9e554c227fd11b85" translate="yes" xml:space="preserve">
          <source>Section returns the first section with the given name, or nil if no such section exists.</source>
          <target state="translated">Section은 주어진 이름의 첫 번째 섹션을 반환하거나, 해당 섹션이 없으면 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8743382bf5087384ab8d5b7b47a198bf1c224282" translate="yes" xml:space="preserve">
          <source>Section type.</source>
          <target state="translated">섹션 유형.</target>
        </trans-unit>
        <trans-unit id="d498edd9cfc2fe612ccd52dd5a6b59dfb6cad8e5" translate="yes" xml:space="preserve">
          <source>SectionByType returns the first section in f with the given type, or nil if there is no such section.</source>
          <target state="translated">SectionByType은 주어진 유형을 가진 f의 첫 번째 섹션을 리턴하거나 해당 섹션이없는 경우 nil을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="dbabe3978d24b41c968a7e3b657294f716964e11" translate="yes" xml:space="preserve">
          <source>SectionHeader is similar to SectionHeader32 with Name field replaced by Go string.</source>
          <target state="translated">SectionHeader는 이름 필드가 Go 문자열로 대체 된 SectionHeader32와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="236a39825c17abffb62d175c97b2ff1d1ddf6257" translate="yes" xml:space="preserve">
          <source>SectionHeader32 represents real PE COFF section header.</source>
          <target state="translated">SectionHeader32는 실제 PE COFF 섹션 헤더를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="36fac8b648a8b963f174eff7d8e38ad8b061b47f" translate="yes" xml:space="preserve">
          <source>SectionReader</source>
          <target state="translated">SectionReader</target>
        </trans-unit>
        <trans-unit id="7c71d38d1e94fa11b5d9d25b519a23c96d399f77" translate="yes" xml:space="preserve">
          <source>SectionReader implements Read, Seek, and ReadAt on a section of an underlying ReaderAt.</source>
          <target state="translated">SectionReader는 기본 ReaderAt의 섹션에서 Read, Seek 및 ReadAt를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="559bf9fc1a7e8d17f180e11f63d09376be0206a5" translate="yes" xml:space="preserve">
          <source>SectionReader.ReadAt</source>
          <target state="translated">SectionReader.ReadAt</target>
        </trans-unit>
        <trans-unit id="665de6075b0f11336eab3dd46baf160774a5a70d" translate="yes" xml:space="preserve">
          <source>SectionReader.Seek</source>
          <target state="translated">SectionReader.Seek</target>
        </trans-unit>
        <trans-unit id="0f309ea1521bd5ca8e406b86f34f3a7a0ebff642" translate="yes" xml:space="preserve">
          <source>Security Model</source>
          <target state="translated">보안 모델</target>
        </trans-unit>
        <trans-unit id="01953de86431ce77344577ae5495196d927df9a0" translate="yes" xml:space="preserve">
          <source>See &quot;Gobs of data&quot; for a design discussion of the gob wire format: &lt;a href=&quot;https://blog.golang.org/gobs-of-data&quot;&gt;https://blog.golang.org/gobs-of-data&lt;/a&gt;</source>
          <target state="translated">gob 와이어 형식에 대한 설계 토론은 &quot;데이터의 gobs&quot;를 참조하십시오. &lt;a href=&quot;https://blog.golang.org/gobs-of-data&quot;&gt;https://blog.golang.org/gobs-of-data&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3774cda758049661070b6c5a6625f40ce94f1003" translate="yes" xml:space="preserve">
          <source>See &quot;JSON and Go&quot; for an introduction to this package: &lt;a href=&quot;https://golang.org/doc/articles/json_and_go.html&quot;&gt;https://golang.org/doc/articles/json_and_go.html&lt;/a&gt;</source>
          <target state="translated">이 패키지에 대한 소개는 &quot;JSON and Go&quot;를 참조하십시오 : &lt;a href=&quot;https://golang.org/doc/articles/json_and_go.html&quot;&gt;https://golang.org/doc/articles/json_and_go.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2434441ee0019a17c985accfc44984c0fc83f78c" translate="yes" xml:space="preserve">
          <source>See &quot;The Go image package&quot; for more details: &lt;a href=&quot;https://golang.org/doc/articles/image_package.html&quot;&gt;https://golang.org/doc/articles/image_package.html&lt;/a&gt;</source>
          <target state="translated">자세한 내용은 &quot;Go 이미지 패키지&quot;를 참조하십시오 : &lt;a href=&quot;https://golang.org/doc/articles/image_package.html&quot;&gt;https://golang.org/doc/articles/image_package.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f5ff28b5d6f4a465abbce4a3d8096187a236d24e" translate="yes" xml:space="preserve">
          <source>See &quot;The Go image/draw package&quot; for an introduction to this package: &lt;a href=&quot;https://golang.org/doc/articles/image_draw.html&quot;&gt;https://golang.org/doc/articles/image_draw.html&lt;/a&gt;</source>
          <target state="translated">이 패키지에 대한 소개는 &quot;Go 이미지 / 그리기 패키지&quot;를 &lt;a href=&quot;https://golang.org/doc/articles/image_draw.html&quot;&gt;참조하십시오&lt;/a&gt; : https://golang.org/doc/articles/image_draw.html</target>
        </trans-unit>
        <trans-unit id="f837700d9a3417d92fc3f9f0548fd849b9aa7119" translate="yes" xml:space="preserve">
          <source>See &quot;The Laws of Reflection&quot; for an introduction to reflection in Go: &lt;a href=&quot;https://golang.org/doc/articles/laws_of_reflection.html&quot;&gt;https://golang.org/doc/articles/laws_of_reflection.html&lt;/a&gt;</source>
          <target state="translated">Go의 리플렉션에 대한 소개는 &quot;리플렉션 법칙&quot;을 참조하십시오 : &lt;a href=&quot;https://golang.org/doc/articles/laws_of_reflection.html&quot;&gt;https://golang.org/doc/articles/laws_of_reflection.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2ab345c73717657f0ff30644abe019ba2856efb0" translate="yes" xml:space="preserve">
          <source>See 'go help buildconstraint' (&lt;a href=&quot;https://golang.org/cmd/go/#hdr-Build_constraints&quot;&gt;https://golang.org/cmd/go/#hdr-Build_constraints&lt;/a&gt;) for details.</source>
          <target state="translated">'go help buildconstraint'( &lt;a href=&quot;https://golang.org/cmd/go/#hdr-Build_constraints&quot;&gt;https://golang.org/cmd/go/#hdr-Build_constraints 참조)&lt;/a&gt; )를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="cd38865133cd9a5c006edfe52fb23197b681651e" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://blog.golang.org/context&quot;&gt;https://blog.golang.org/context&lt;/a&gt; for example code for a server that uses Contexts.</source>
          <target state="translated">컨텍스트를 사용하는 서버의 코드 예제는 &lt;a href=&quot;https://blog.golang.org/context&quot;&gt;https://blog.golang.org/context&lt;/a&gt; 를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="f8fa4b86ca7a1947812b5144ad80bb7923b98b76" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://blog.golang.org/http-tracing&quot;&gt;https://blog.golang.org/http-tracing&lt;/a&gt; for more.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://blog.golang.org/http-tracing&quot;&gt;https://blog.golang.org/http-tracing&lt;/a&gt; 을 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="55fd6381c1e6f556a9d9a122b9ddab024cd5623c" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels&quot;&gt;https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels&quot;&gt;https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="5b6207cb402edce8d859bdca9debb6fc32598a7f" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematics_of_cyclic_redundancy_checks#Reversed_representations_and_reciprocal_polynomials&quot;&gt;https://en.wikipedia.org/wiki/Mathematics_of_cyclic_redundancy_checks#Reversed_representations_and_reciprocal_polynomials&lt;/a&gt; for information.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematics_of_cyclic_redundancy_checks#Reversed_representations_and_reciprocal_polynomials&quot;&gt;https://en.wikipedia.org/wiki/Mathematics_of_cyclic_redundancy_checks#Reversed_representations_and_reciprocal_polynomials&lt;/a&gt; 를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="822defb6e38c1c8b51e3bd857cd8e75be7930a08" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://en.wikipedia.org/wiki/Web_colors#Web-safe_colors&quot;&gt;https://en.wikipedia.org/wiki/Web_colors#Web-safe_colors&lt;/a&gt; for details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Web_colors#Web-safe_colors&quot;&gt;https://en.wikipedia.org/wiki/Web_colors#Web-safe_colors&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="012d19a411e4e0484271ae09bcb7f34da4a9a591" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://fast-cgi.github.io/&quot;&gt;https://fast-cgi.github.io/&lt;/a&gt; for an unofficial mirror of the original documentation.</source>
          <target state="translated">원본 문서의 비공식 미러는 &lt;a href=&quot;https://fast-cgi.github.io/&quot;&gt;https://fast-cgi.github.io/&lt;/a&gt; 를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="c591b3698d1803b8997f519f5ea5ff42b510cd7a" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00&quot;&gt;https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00&lt;/a&gt; for details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00&quot;&gt;https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ebe2d422131406c7b8b8363b0278a5d60f19e086" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;https://tools.ietf.org/html/rfc6265&lt;/a&gt; for details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;https://tools.ietf.org/html/rfc6265&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f939efd0712db18e39e637012cde4b443ec363ef" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://www.iana.org/assignments/tls-parameters/tls-parameters.xml&quot;&gt;https://www.iana.org/assignments/tls-parameters/tls-parameters.xml&lt;/a&gt;</source>
          <target state="translated">보다 &lt;a href=&quot;https://www.iana.org/assignments/tls-parameters/tls-parameters.xml&quot;&gt; https://www.iana.org/assignments/tls-parameters/tls-parameters.xml를&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cfeb891e01c83428f5fff33780366881bea259da" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://www.w3.org/TR/css3-syntax/#parsing&quot;&gt;https://www.w3.org/TR/css3-syntax/#parsing&lt;/a&gt; and &lt;a href=&quot;https://web.archive.org/web/20090211114933/http://w3.org/TR/css3-syntax#style&quot;&gt;https://web.archive.org/web/20090211114933/http://w3.org/TR/css3-syntax#style&lt;/a&gt;</source>
          <target state="translated">참조 &lt;a href=&quot;https://www.w3.org/TR/css3-syntax/#parsing&quot;&gt;https://www.w3.org/TR/css3-syntax/#parsing&lt;/a&gt; 및 &lt;a href=&quot;https://web.archive.org/web/20090211114933/http://w3.org/TR/css3-syntax#style&quot;&gt;https://web.archive.org/web/20090211114933/http://w3.org/TR/css3-syntax#style&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b12c5bb65217a01227ad162d33c3fed71b0401c9" translate="yes" xml:space="preserve">
          <source>See MarshalIndent for an example.</source>
          <target state="translated">예를 들어 MarshalIndent를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cec031b75e78fe653173c9a966907dfc7a5c304d" translate="yes" xml:space="preserve">
          <source>See PublicKey.Equal for details on how Curve is compared.</source>
          <target state="translated">Curve를 비교하는 방법에 대한 자세한 내용은 PublicKey.Equal을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4a1e97ca1a62398cd193e09c77540d6a3a116112" translate="yes" xml:space="preserve">
          <source>See also &amp;ldquo;A Layman's Guide to a Subset of ASN.1, BER, and DER,&amp;rdquo; &lt;a href=&quot;http://luca.ntop.org/Teaching/Appunti/asn1.html&quot;&gt;http://luca.ntop.org/Teaching/Appunti/asn1.html&lt;/a&gt;.</source>
          <target state="translated">&amp;ldquo;ASN.1, BER 및 DER의 하위 집합에 대한 Layman 's Guide&amp;rdquo;( &lt;a href=&quot;http://luca.ntop.org/Teaching/Appunti/asn1.html&quot;&gt;http://luca.ntop.org/Teaching/Appunti/asn1.html)도 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f35fe0b7c2e4d6b79cc655771a00378e8038d6ad" translate="yes" xml:space="preserve">
          <source>See also Rob Pike, &amp;ldquo;Lexical File Names in Plan 9 or Getting Dot-Dot Right,&amp;rdquo; &lt;a href=&quot;https://9p.io/sys/doc/lexnames.html&quot;&gt;https://9p.io/sys/doc/lexnames.html&lt;/a&gt;</source>
          <target state="translated">Rob Pike,&amp;ldquo;계획 9의 성명 파일 이름 또는 올바른 점 찍기&amp;rdquo;, &lt;a href=&quot;https://9p.io/sys/doc/lexnames.html&quot;&gt;https://9p.io/sys/doc/lexnames.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c57c543e703b305eac0e44a135198463dbeead16" translate="yes" xml:space="preserve">
          <source>See func Dial for a description of the host and port parameters.</source>
          <target state="translated">호스트 및 포트 매개 변수에 대한 설명은 func Dial을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b9538b240ebef42fb9902c82f39f4d8fe015d462" translate="yes" xml:space="preserve">
          <source>See func Dial for a description of the hostport parameter, and host and port results.</source>
          <target state="translated">hostport 매개 변수 및 호스트 및 포트 결과에 대한 설명은 func Dial을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f55bd52960d8a9b74f8c169b63b303f83068df0d" translate="yes" xml:space="preserve">
          <source>See func Dial for a description of the network and address parameters.</source>
          <target state="translated">네트워크 및 주소 매개 변수에 대한 설명은 func Dial을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="27af5de3a2347f6faceaa84c4b1f14ae1dbd0c9d" translate="yes" xml:space="preserve">
          <source>See func Listen for a description of the network and address parameters.</source>
          <target state="translated">네트워크 및 주소 매개 변수에 대한 설명은 func Listen을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6b6b3dee4908b79bcc47570b27eb5ceec2a78402" translate="yes" xml:space="preserve">
          <source>See func ListenPacket for a description of the network and address parameters.</source>
          <target state="translated">네트워크 및 주소 매개 변수에 대한 설명은 func ListenPacket을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ad4f4bb8708490d77806cbbb7379b205b4ed91be" translate="yes" xml:space="preserve">
          <source>See package json to understand how non-string content is marshaled for embedding in JavaScript contexts.</source>
          <target state="translated">JavaScript 컨텍스트에 포함하기 위해 문자열이 아닌 컨텐츠를 마샬링하는 방법을 이해하려면 패키지 json을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6e66c2f2a3fcd4dca444d07ce7d1a4b916782623" translate="yes" xml:space="preserve">
          <source>See page 36 of RFC 959 (&lt;a href=&quot;https://www.ietf.org/rfc/rfc959.txt&quot;&gt;https://www.ietf.org/rfc/rfc959.txt&lt;/a&gt;) for details of another form of response accepted:</source>
          <target state="translated">허용되는 다른 형태의 응답에 대한 자세한 내용 은 RFC 959 ( &lt;a href=&quot;https://www.ietf.org/rfc/rfc959.txt&quot;&gt;https://www.ietf.org/rfc/rfc959.txt&lt;/a&gt; )의 36 페이지를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="89753a3f5bb64713c93e9dd202de0a7448a21cee" translate="yes" xml:space="preserve">
          <source>See the Client.Do method documentation for details on how redirects are handled.</source>
          <target state="translated">리디렉션 처리 방법에 대한 자세한 내용은 Client.Do 메서드 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ca6b0bd4889c5a06e76626f48ec79733e1fde8b5" translate="yes" xml:space="preserve">
          <source>See the Decoder.Strict and Decoder.Entity fields' documentation.</source>
          <target state="translated">Decoder.Strict 및 Decoder.Entity 필드 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="69633a7324ac73d11db8887864a0a74fd2f5588f" translate="yes" xml:space="preserve">
          <source>See the documentation for Marshal for details about the conversion of Go values to JSON.</source>
          <target state="translated">Go 값을 JSON으로 변환하는 방법에 대한 자세한 내용은 Marshal 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="45c89cab840adb83eec8d88d66bfe51744007d64" translate="yes" xml:space="preserve">
          <source>See the documentation for Marshal for details about the conversion of Go values to XML.</source>
          <target state="translated">Go 값을 XML로 변환하는 방법에 대한 자세한 내용은 Marshal 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f6ad8d64ce7abf48e48759b114cf5bbde1ec1217" translate="yes" xml:space="preserve">
          <source>See the documentation for Reader's DotReader method for details about dot-encoding.</source>
          <target state="translated">도트 인코딩에 대한 자세한 내용은 Reader의 DotReader 방법 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="07bb2782143cae54efbc20f97e601c6258fdfa3a" translate="yes" xml:space="preserve">
          <source>See the documentation for Unmarshal for details about the conversion of JSON into a Go value.</source>
          <target state="translated">JSON을 Go 값으로 변환하는 방법에 대한 자세한 내용은 Unmarshal 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5b7d9e398b9767ef1472ee8144b5fcbf7154f428" translate="yes" xml:space="preserve">
          <source>See the documentation for the DotReader method for details about dot-encoding.</source>
          <target state="translated">도트 인코딩에 대한 자세한 내용은 DotReader 메서드 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="20a56feb05a514c49115ca9854f4e8b6ab081007" translate="yes" xml:space="preserve">
          <source>See the documentation of ErrorCode for details.</source>
          <target state="translated">자세한 내용은 ErrorCode 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="130b144345eef54088939126445f2041356e9967" translate="yes" xml:space="preserve">
          <source>See the net/http/pprof package for more details about all of the debug endpoints installed by this import.</source>
          <target state="translated">이 가져 오기로 설치 한 모든 디버그 엔드 포인트에 대한 자세한 내용은 net / http / pprof 패키지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8ea13af2c476fd8c34b53410467a8c4eec967244" translate="yes" xml:space="preserve">
          <source>See the net/http/pprof package for more details.</source>
          <target state="translated">자세한 내용은 net / http / pprof 패키지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="58a48e9dbb684e401e679bc392894a41123c39b5" translate="yes" xml:space="preserve">
          <source>See the package documentation for more details about initializing an FS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7129eb47abb47be846a8de8beba3573c278ce39c" translate="yes" xml:space="preserve">
          <source>See type IPNet and func ParseCIDR for details.</source>
          <target state="translated">자세한 내용은 IPNet 및 func ParseCIDR 유형을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d95f74a97d247876324f75dbbfb30fd3fdf53de6" translate="yes" xml:space="preserve">
          <source>See: &lt;a href=&quot;https://www.pkware.com/appnote&quot;&gt;https://www.pkware.com/appnote&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;https://www.pkware.com/appnote&quot;&gt;https://www.pkware.com/appnote&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4c4d4997512bc2a6a144281549f19954818ba0de" translate="yes" xml:space="preserve">
          <source>Seed returns h's seed value.</source>
          <target state="translated">Seed는 h의 시드 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="421cab07939e4ef921a875d22fec2c50b6b26cc4" translate="yes" xml:space="preserve">
          <source>Seed returns the private key seed corresponding to priv. It is provided for interoperability with RFC 8032. RFC 8032's private keys correspond to seeds in this package.</source>
          <target state="translated">Seed는 priv에 해당하는 개인 키 시드를 반환합니다. RFC 8032와의 상호 운용성을 위해 제공됩니다. RFC 8032의 개인 키는이 패키지의 시드에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="b24f14f5efbc89ced2f3c041e71ddf2e16d01a87" translate="yes" xml:space="preserve">
          <source>Seed uses the provided seed value to initialize the default Source to a deterministic state. If Seed is not called, the generator behaves as if seeded by Seed(1). Seed values that have the same remainder when divided by 2&amp;sup3;&amp;sup1;-1 generate the same pseudo-random sequence. Seed, unlike the Rand.Seed method, is safe for concurrent use.</source>
          <target state="translated">Seed는 제공된 seed 값을 사용하여 기본 소스를 결정적 상태로 초기화합니다. Seed가 호출되지 않으면 생성기는 Seed (1)에 의해 시드 된 것처럼 작동합니다. 2&amp;sup3;&amp;sup1;-1로 나눌 때 나머지가 동일한 시드 값은 동일한 의사 랜덤 시퀀스를 생성합니다. Rand.Seed 방법과 달리 Seed는 동시에 사용하기에 안전합니다.</target>
        </trans-unit>
        <trans-unit id="a2daea0c21550e6b91614c2942780e2e38582d89" translate="yes" xml:space="preserve">
          <source>Seed uses the provided seed value to initialize the default Source to a deterministic state. If Seed is not called, the generator behaves as if seeded by Seed(1). Seed values that have the same remainder when divided by 2^31-1 generate the same pseudo-random sequence. Seed, unlike the Rand.Seed method, is safe for concurrent use.</source>
          <target state="translated">Seed는 제공된 seed 값을 사용하여 기본 소스를 결정적 상태로 초기화합니다. Seed가 호출되지 않으면 생성기는 Seed (1)에 의해 시드 된 것처럼 동작합니다. 2 ^ 31-1로 나눈 나머지가 동일한 시드 값은 동일한 의사 랜덤 시퀀스를 생성합니다. Rand.Seed 방법과 달리 씨앗은 동시에 사용하기에 안전합니다.</target>
        </trans-unit>
        <trans-unit id="06599ffd87d9ecfcc5955a8a8f6f2e80af71b779" translate="yes" xml:space="preserve">
          <source>Seed uses the provided seed value to initialize the generator to a deterministic state. Seed should not be called concurrently with any other Rand method.</source>
          <target state="translated">Seed는 제공된 seed 값을 사용하여 생성기를 결정적 상태로 초기화합니다. 다른 Rand 메소드와 동시에 Seed를 호출하면 안됩니다.</target>
        </trans-unit>
        <trans-unit id="63eada0c1ee90c191cced8ff6a478d23ec01c7bb" translate="yes" xml:space="preserve">
          <source>Seek implements the io.Seeker interface.</source>
          <target state="translated">Seek는 io.Seeker 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="410f9d629b5b2020b5303452364dec83676d0a30" translate="yes" xml:space="preserve">
          <source>Seek positions the Reader at offset off in the encoded entry stream. Offset 0 can be used to denote the first entry.</source>
          <target state="translated">검색은 인코딩 된 입력 스트림에서 판독기를 오프셋으로 끕니다. 첫 번째 항목을 나타 내기 위해 오프셋 0을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73550a62d2076f2c392030c22ea826a5948745a2" translate="yes" xml:space="preserve">
          <source>Seek restores the line table reader to a position returned by Tell.</source>
          <target state="translated">Seek은 Line 테이블 리더를 Tell이 리턴 한 위치로 복원합니다.</target>
        </trans-unit>
        <trans-unit id="6d637ad9eaafe14fbed4d5e3bc3eb33df03f11cb" translate="yes" xml:space="preserve">
          <source>Seek sets the offset for the next Read or Write on file to offset, interpreted according to whence: 0 means relative to the origin of the file, 1 means relative to the current offset, and 2 means relative to the end. It returns the new offset and an error, if any. The behavior of Seek on a file opened with O_APPEND is not specified.</source>
          <target state="translated">Seek는 다음에 따라 파일에서 다음 읽기 또는 쓰기에 대한 오프셋을 오프셋으로 설정합니다. 0은 파일의 원점을 기준으로, 1은 현재 오프셋을 기준으로, 2는 끝을 기준으로 의미합니다. 새 오프셋과 오류 (있는 경우)를 반환합니다. O_APPEND로 열린 파일에서 찾기 동작이 지정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="e00a273e91af976fc6df810663ccae8e6326bc28" translate="yes" xml:space="preserve">
          <source>Seek sets the offset for the next Read or Write to offset, interpreted according to whence: SeekStart means relative to the start of the file, SeekCurrent means relative to the current offset, and SeekEnd means relative to the end. Seek returns the new offset relative to the start of the file and an error, if any.</source>
          <target state="translated">Seek는 다음 읽기 또는 쓰기 오프셋에 대한 오프셋을 whence에 따라 해석됩니다. SeekStart는 파일의 시작을 기준으로, SeekCurrent는 현재 오프셋을 기준으로, SeekEnd는 끝을 기준으로 의미합니다. Seek는 파일의 시작과 관련된 새 오프셋과 오류가있는 경우 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f2691430f4c04cd93d687e7abb0ccf591170c83f" translate="yes" xml:space="preserve">
          <source>Seek whence values.</source>
          <target state="translated">whence 값을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="69cfaf772b14f0b576e9cb0bbd8f02155636d19d" translate="yes" xml:space="preserve">
          <source>SeekPC returns the Entry for the compilation unit that includes pc, and positions the reader to read the children of that unit. If pc is not covered by any unit, SeekPC returns ErrUnknownPC and the position of the reader is undefined.</source>
          <target state="translated">SeekPC는 pc가 포함 된 컴파일 단위에 대한 항목을 반환하고 리더가 해당 단위의 자식을 읽도록 위치시킵니다. pc가 어떤 장치로도 보호되지 않으면 SeekPC는 ErrUnknownPC를 반환하고 판독기의 위치는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ce674d68613294249c458dda3fd950d087fbda52" translate="yes" xml:space="preserve">
          <source>SeekPC sets *entry to the LineEntry that includes pc and positions the reader on the next entry in the line table. If necessary, this will seek backwards to find pc.</source>
          <target state="translated">SeekPC는 pc를 포함하는 LineEntry로 * entry를 설정하고 행 테이블의 다음 항목에 판독기를 배치합니다. 필요한 경우 pc를 찾기 위해 뒤로 검색합니다.</target>
        </trans-unit>
        <trans-unit id="9d91685eee68f0702fc5f565a2ad58bdb01cbd6c" translate="yes" xml:space="preserve">
          <source>Seeker is the interface that wraps the basic Seek method.</source>
          <target state="translated">Seeker는 기본 Seek 메소드를 래핑하는 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="c221b3bf48536c91e36f1aa582e0e6ad14671a86" translate="yes" xml:space="preserve">
          <source>Seeking to an offset before the start of the file is an error. Seeking to any positive offset is legal, but the behavior of subsequent I/O operations on the underlying object is implementation-dependent.</source>
          <target state="translated">파일을 시작하기 전에 오프셋을 찾는 것은 오류입니다. 긍정적 인 오프셋을 찾는 것은 합법적이지만 기본 개체에 대한 후속 I / O 작업의 동작은 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="d283b12149f88184eedb3514ba9c006d88d9d635" translate="yes" xml:space="preserve">
          <source>Segment returns the first Segment with the given name, or nil if no such segment exists.</source>
          <target state="translated">Segment는 주어진 이름의 첫 번째 Segment를 반환하거나 해당 Segment가 없으면 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4ee9c170709717ea62d8ec2ac63808bf3b81d532" translate="yes" xml:space="preserve">
          <source>Select executes a select operation described by the list of cases. Like the Go select statement, it blocks until at least one of the cases can proceed, makes a uniform pseudo-random choice, and then executes that case. It returns the index of the chosen case and, if that case was a receive operation, the value received and a boolean indicating whether the value corresponds to a send on the channel (as opposed to a zero value received because the channel is closed).</source>
          <target state="translated">Select는 케이스 목록에 설명 된 선택 조작을 실행합니다. Go select 문과 같이, 적어도 하나의 경우가 진행될 때까지 차단하고 균일 한 의사 랜덤 선택을 한 다음 해당 경우를 실행합니다. 선택한 케이스의 색인을 리턴하며, 해당 케이스가 수신 조작 인 경우, 값이 수신되고 값이 채널의 송신에 해당하는지 여부를 나타내는 부울 (채널이 닫혀서 수신 된 0 값이 아닌)을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="9f23aae7e3512dd0773f6a470359d03ccb841782" translate="yes" xml:space="preserve">
          <source>Select executes a select operation described by the list of cases. Like the Go select statement, it blocks until at least one of the cases can proceed, makes a uniform pseudo-random choice, and then executes that case. It returns the index of the chosen case and, if that case was a receive operation, the value received and a boolean indicating whether the value corresponds to a send on the channel (as opposed to a zero value received because the channel is closed). Select supports a maximum of 65536 cases.</source>
          <target state="translated">Select는 케이스 목록에 설명 된 선택 작업을 실행합니다. Go select 문과 마찬가지로 케이스 중 하나 이상이 진행될 때까지 차단하고 균일 한 의사 랜덤 선택을 한 다음 해당 케이스를 실행합니다. 선택한 케이스의 인덱스를 반환하고 해당 케이스가 수신 작업 인 경우 수신 된 값과 해당 값이 채널의 전송에 해당하는지 여부를 나타내는 부울을 반환합니다 (채널이 닫혀 있기 때문에 수신 된 0 값과 반대). Select는 최대 65536 개의 케이스를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="7716a94c0a405511b91cc23c646dfce03e542371" translate="yes" xml:space="preserve">
          <source>SelectionKind describes the kind of a selector expression x.f (excluding qualified identifiers).</source>
          <target state="translated">SelectionKind는 선택기 표현식 xf의 종류를 설명합니다 (제한된 식별자 제외).</target>
        </trans-unit>
        <trans-unit id="656dfc577aeb6e9f277a9a8820fcfc6e5db75f21" translate="yes" xml:space="preserve">
          <source>SelectionString returns the string form of s. The Qualifier controls the printing of package-level objects, and may be nil.</source>
          <target state="translated">SelectionString은 s의 문자열 형식을 반환합니다. 한정자는 패키지 수준 개체의 인쇄를 제어하며 nil 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="edad40365c9764afdd964f9245649f6856af2d11" translate="yes" xml:space="preserve">
          <source>Send sends x on the channel v. It panics if v's kind is not Chan or if x's type is not the same type as v's element type. As in Go, x's value must be assignable to the channel's element type.</source>
          <target state="translated">Send는 채널 v에서 x를 전송합니다. v의 종류가 Chan이 아니거나 x의 유형이 v의 요소 유형과 같은 유형이 아닌 경우 패닉이 발생합니다. Go에서와 같이 x의 값은 채널의 요소 유형에 지정 가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="2750b0f06411195ed08fefe45f59d520ab6f8353" translate="yes" xml:space="preserve">
          <source>SendMail</source>
          <target state="translated">SendMail</target>
        </trans-unit>
        <trans-unit id="1a5bbac84e0744da338847af3ed794816ef236ce" translate="yes" xml:space="preserve">
          <source>SendMail connects to the server at addr, switches to TLS if possible, authenticates with the optional mechanism a if possible, and then sends an email from address from, to addresses to, with message msg. The addr must include a port, as in &quot;mail.example.com:smtp&quot;.</source>
          <target state="translated">SendMail은 addr에서 서버에 연결하고 가능한 경우 TLS로 전환하고 가능한 경우 선택적 메커니즘을 사용하여 인증 한 다음 메시지 msg를 사용하여 전자 메일을 주소에서 전자 메일로 보냅니다. 주소는 &quot;mail.example.com:smtp&quot;와 같이 포트를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="9866b4faed06fd643cf801f0e203a46a3fe6c756" translate="yes" xml:space="preserve">
          <source>Serve accepts incoming FastCGI connections on the listener l, creating a new goroutine for each. The goroutine reads requests and then calls handler to reply to them. If l is nil, Serve accepts connections from os.Stdin. If handler is nil, http.DefaultServeMux is used.</source>
          <target state="translated">서브는 리스너에서 들어오는 FastCGI 연결을 수락하여 각각에 대해 새로운 고 루틴을 만듭니다. goroutine은 요청을 읽은 후 핸들러를 호출하여 응답합니다. l이 nil이면 Serve는 os.Stdin의 연결을 수락합니다. 핸들러가 nil이면 http.DefaultServeMux가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d8de44e0fb5292324dadb958bb0ec67283e1e920" translate="yes" xml:space="preserve">
          <source>Serve accepts incoming HTTP connections on the listener l, creating a new service goroutine for each. The service goroutines read requests and then call handler to reply to them.</source>
          <target state="translated">서브는 리스너에서 들어오는 HTTP 연결을 받아 들여 각각에 대해 새로운 서비스 고 루틴을 만듭니다. 서비스는 요청을 읽고 처리기를 호출하여 응답합니다.</target>
        </trans-unit>
        <trans-unit id="fb2fbb4a3d173feafc83e986b5d91f4c043b98cd" translate="yes" xml:space="preserve">
          <source>Serve accepts incoming connections on the Listener l, creating a new service goroutine for each. The service goroutines read requests and then call srv.Handler to reply to them.</source>
          <target state="translated">Serve는 리스너 l에서 들어오는 연결을 받아 들여 각각에 대한 새로운 서비스 고 루틴을 만듭니다. 서비스는 요청을 읽은 다음 srv.Handler를 호출하여 응답합니다.</target>
        </trans-unit>
        <trans-unit id="f65496b12ef6ef062ca261d02fdcc1afec4ce5ea" translate="yes" xml:space="preserve">
          <source>Serve always returns a non-nil error and closes l. After Shutdown or Close, the returned error is ErrServerClosed.</source>
          <target state="translated">Serve는 항상 nil이 아닌 오류를 반환하고 l을 닫습니다. 종료 또는 닫기 후 반환 된 오류는 ErrServerClosed입니다.</target>
        </trans-unit>
        <trans-unit id="4671511496e9d853a658f8c526e4dbf184a2c34c" translate="yes" xml:space="preserve">
          <source>Serve always returns a non-nil error.</source>
          <target state="translated">검색은 항상 0이 아닌 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="497078ba977bfc095dad2477b3172dcb26f1c0ab" translate="yes" xml:space="preserve">
          <source>Serve executes the provided Handler on the currently active CGI request, if any. If there's no current CGI environment an error is returned. The provided handler may be nil to use http.DefaultServeMux.</source>
          <target state="translated">Serve는 현재 활성화 된 CGI 요청에서 제공된 처리기를 실행합니다 (있는 경우). 현재 CGI 환경이 없으면 오류가 반환됩니다. 제공된 핸들러는 http.DefaultServeMux를 사용하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbfb7d2b5b789e7fe76f3c2462b4817839783a1b" translate="yes" xml:space="preserve">
          <source>ServeCodec is like ServeConn but uses the specified codec to decode requests and encode responses.</source>
          <target state="translated">ServeCodec은 ServeConn과 유사하지만 지정된 코덱을 사용하여 요청을 디코딩하고 응답을 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="09ac76223546ffdd3d100d24b6bc49c0b7956df0" translate="yes" xml:space="preserve">
          <source>ServeConn runs the DefaultServer on a single connection. ServeConn blocks, serving the connection until the client hangs up. The caller typically invokes ServeConn in a go statement. ServeConn uses the gob wire format (see package gob) on the connection. To use an alternate codec, use ServeCodec. See NewClient's comment for information about concurrent access.</source>
          <target state="translated">ServeConn은 단일 연결에서 DefaultServer를 실행합니다. 클라이언트가 전화를 끊을 때까지 연결을 제공하는 ServeConn 블록. 호출자는 일반적으로 go 문에서 ServeConn을 호출합니다. ServeConn은 연결에 gob 와이어 형식 (패키지 gob 참조)을 사용합니다. 대체 코덱을 사용하려면 ServeCodec을 사용하십시오. 동시 액세스에 대한 정보는 NewClient의 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d136d0992046f83551cea5f2576de13dc7e39384" translate="yes" xml:space="preserve">
          <source>ServeConn runs the JSON-RPC server on a single connection. ServeConn blocks, serving the connection until the client hangs up. The caller typically invokes ServeConn in a go statement.</source>
          <target state="translated">ServeConn은 단일 연결에서 JSON-RPC 서버를 실행합니다. 클라이언트가 전화를 끊을 때까지 연결을 제공하는 ServeConn 블록. 호출자는 일반적으로 go 문에서 ServeConn을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="2f01374418f76760c6cb616cbabd675e38909787" translate="yes" xml:space="preserve">
          <source>ServeConn runs the server on a single connection. ServeConn blocks, serving the connection until the client hangs up. The caller typically invokes ServeConn in a go statement. ServeConn uses the gob wire format (see package gob) on the connection. To use an alternate codec, use ServeCodec. See NewClient's comment for information about concurrent access.</source>
          <target state="translated">ServeConn은 단일 연결에서 서버를 실행합니다. 클라이언트가 전화를 끊을 때까지 연결을 제공하는 ServeConn 블록. 호출자는 일반적으로 go 문에서 ServeConn을 호출합니다. ServeConn은 연결에 gob 와이어 형식 (패키지 gob 참조)을 사용합니다. 대체 코덱을 사용하려면 ServeCodec을 사용하십시오. 동시 액세스에 대한 정보는 NewClient의 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ef53643ab98faf2b116983a1f327c585aaa8a435" translate="yes" xml:space="preserve">
          <source>ServeContent replies to the request using the content in the provided ReadSeeker. The main benefit of ServeContent over io.Copy is that it handles Range requests properly, sets the MIME type, and handles If-Match, If-Unmodified-Since, If-None-Match, If-Modified-Since, and If-Range requests.</source>
          <target state="translated">ServeContent는 제공된 ReadSeeker의 컨텐츠를 사용하여 요청에 응답합니다. io.Copy에 비해 ServeContent의 주요 이점은 Range 요청을 올바르게 처리하고 MIME 유형을 설정하며 If-Match, If-Unmodified-Since, If-None-Match, If-Modified-Since 및 If-Range를 처리한다는 것입니다. 요청.</target>
        </trans-unit>
        <trans-unit id="cfd658fe667ad1d964897018a5c4cf11bec05335" translate="yes" xml:space="preserve">
          <source>ServeFile replies to the request with the contents of the named file or directory.</source>
          <target state="translated">ServeFile은 명명 된 파일 또는 디렉토리의 내용으로 요청에 응답합니다.</target>
        </trans-unit>
        <trans-unit id="049197d23952867737fe7bc77daa12a248c70057" translate="yes" xml:space="preserve">
          <source>ServeHTTP calls f(w, r).</source>
          <target state="translated">ServeHTTP는 f (w, r)를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="4c4916bc850460672f4222f24dda17f824b214d6" translate="yes" xml:space="preserve">
          <source>ServeHTTP dispatches the request to the handler whose pattern most closely matches the request URL.</source>
          <target state="translated">ServeHTTP는 요청 URL과 가장 일치하는 패턴을 가진 처리기로 요청을 발송합니다.</target>
        </trans-unit>
        <trans-unit id="21deb32922a44f4fb534ed8afc10e377cb3ed92e" translate="yes" xml:space="preserve">
          <source>ServeHTTP implements an http.Handler that answers RPC requests.</source>
          <target state="translated">ServeHTTP는 RPC 요청에 응답하는 http.Handler를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="6b5f212880feffc9d4b20ece24bb964f1dfe9a0e" translate="yes" xml:space="preserve">
          <source>ServeHTTP should write reply headers and data to the ResponseWriter and then return. Returning signals that the request is finished; it is not valid to use the ResponseWriter or read from the Request.Body after or concurrently with the completion of the ServeHTTP call.</source>
          <target state="translated">ServeHTTP는 응답 헤더와 데이터를 ResponseWriter에 쓴 다음 반환해야합니다. 요청이 완료되었다는 신호를 반환합니다. ServeHTTP 호출 완료 후 또는 동시에 ResponseWriter를 사용하거나 Request.Body에서 읽는 것은 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="643b76d4394a8e8ca4ec7165cbad824736ed0dab" translate="yes" xml:space="preserve">
          <source>ServeMux also takes care of sanitizing the URL request path and the Host header, stripping the port number and redirecting any request containing . or .. elements or repeated slashes to an equivalent, cleaner URL.</source>
          <target state="translated">ServeMux는 또한 URL 요청 경로와 호스트 헤더를 정리하여 포트 번호를 제거하고을 포함하는 요청을 리디렉션합니다. 또는 .. 요소 또는 반복되는 동일한 슬래시 URL 로의 슬래시.</target>
        </trans-unit>
        <trans-unit id="c2c623da8699103087cc62f3c47b54b0c6fbdef4" translate="yes" xml:space="preserve">
          <source>ServeMux is an HTTP request multiplexer. It matches the URL of each incoming request against a list of registered patterns and calls the handler for the pattern that most closely matches the URL.</source>
          <target state="translated">ServeMux는 HTTP 요청 멀티플렉서입니다. 등록 된 패턴 목록과 각 수신 요청의 URL을 일치시키고 URL과 가장 일치하는 패턴의 핸들러를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="d57d6d29bc00d69dcb5016e00c29678f29b25c20" translate="yes" xml:space="preserve">
          <source>ServeMux.Handle</source>
          <target state="translated">ServeMux.Handle</target>
        </trans-unit>
        <trans-unit id="a2ccb85e8b555a7018f6848932b3cf1638f89e04" translate="yes" xml:space="preserve">
          <source>ServeRequest is like ServeCodec but synchronously serves a single request. It does not close the codec upon completion.</source>
          <target state="translated">ServeRequest는 ServeCodec와 유사하지만 단일 요청을 동 기적으로 제공합니다. 완료시 코덱을 닫지 않습니다.</target>
        </trans-unit>
        <trans-unit id="914b527f3acbaa5705eeffe44b971ef90f12446b" translate="yes" xml:space="preserve">
          <source>ServeTLS accepts incoming HTTPS connections on the listener l, creating a new service goroutine for each. The service goroutines read requests and then call handler to reply to them.</source>
          <target state="translated">ServeTLS는 리스너에서 들어오는 HTTPS 연결을 수락하여 각각에 대해 새로운 서비스 고 루틴을 만듭니다. 서비스는 요청을 읽고 처리기를 호출하여 응답합니다.</target>
        </trans-unit>
        <trans-unit id="0a96e454a3074cfb2a672bba732fc55cf3ace063" translate="yes" xml:space="preserve">
          <source>ServeTLS accepts incoming connections on the Listener l, creating a new service goroutine for each. The service goroutines perform TLS setup and then read requests, calling srv.Handler to reply to them.</source>
          <target state="translated">ServeTLS는 리스너 l에서 들어오는 연결을 받아 들여 각각에 대한 새로운 서비스 고 루틴을 만듭니다. 서비스 goroutines는 TLS 설정을 수행 한 다음 srv.Handler를 호출하여 요청을 읽고 응답합니다.</target>
        </trans-unit>
        <trans-unit id="5d05c42df2acb99153f40488ff8b30bf621e7c31" translate="yes" xml:space="preserve">
          <source>ServeTLS always returns a non-nil error.</source>
          <target state="translated">ServeTLS는 항상 0이 아닌 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="49b6a1abd7e8e016f95152133848467bef1659cf" translate="yes" xml:space="preserve">
          <source>ServeTLS always returns a non-nil error. After Shutdown or Close, the returned error is ErrServerClosed.</source>
          <target state="translated">ServeTLS는 항상 0이 아닌 오류를 반환합니다. 종료 또는 닫기 후 반환 된 오류는 ErrServerClosed입니다.</target>
        </trans-unit>
        <trans-unit id="cb0cb170d106f8e8d5af1e05bbdbd3a96a7de197" translate="yes" xml:space="preserve">
          <source>Server</source>
          <target state="translated">Server</target>
        </trans-unit>
        <trans-unit id="fd27359b7f3750869c6d376d504d1fa87f6d2a64" translate="yes" xml:space="preserve">
          <source>Server (HTTP2)</source>
          <target state="translated">서버 (HTTP2)</target>
        </trans-unit>
        <trans-unit id="4ddf4403b77024142dd6473786b6571dc8b196f9" translate="yes" xml:space="preserve">
          <source>Server represents an RPC Server.</source>
          <target state="translated">서버는 RPC 서버를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="313ac33490fd78320856fae075839a276bcab472" translate="yes" xml:space="preserve">
          <source>Server returns a new TLS server side connection using conn as the underlying transport. The configuration config must be non-nil and must include at least one certificate or else set GetCertificate.</source>
          <target state="translated">서버는 conn을 기본 전송으로 사용하여 새 TLS 서버 측 연결을 반환합니다. 구성 구성은 0이 아니어야하며 하나 이상의 인증서를 포함하거나 GetCertificate를 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="e0b4e659e40eb8a8a1e289fa3271bf98ef6e2706" translate="yes" xml:space="preserve">
          <source>Server.Shutdown</source>
          <target state="translated">Server.Shutdown</target>
        </trans-unit>
        <trans-unit id="e8983457da1ab21a6c85c2a9507e94af92a8934d" translate="yes" xml:space="preserve">
          <source>ServerConn is an artifact of Go's early HTTP implementation. It is low-level, old, and unused by Go's current HTTP stack. We should have deleted it before Go 1.</source>
          <target state="translated">ServerConn은 Go의 초기 HTTP 구현의 인공물입니다. Go의 현재 HTTP 스택에서 저수준이며 오래되었으며 사용되지 않습니다. Go 1 전에 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="e48e77ca43f54c7c217d619efb9bd95f1a1f8aba" translate="yes" xml:space="preserve">
          <source>ServerError represents an error that has been returned from the remote side of the RPC connection.</source>
          <target state="translated">ServerError는 RPC 연결의 원격 쪽에서 반환 된 오류를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="547b92e886182f3f71367607ff47558fb0fe8029" translate="yes" xml:space="preserve">
          <source>ServerInfo records information about an SMTP server.</source>
          <target state="translated">ServerInfo는 SMTP 서버에 대한 정보를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="870594a7b5d015bba7a8d2c0875c56f2fce85f71" translate="yes" xml:space="preserve">
          <source>SessionResetter may be implemented by Conn to allow drivers to reset the session state associated with the connection and to signal a bad connection.</source>
          <target state="translated">Conn에 의해 SessionResetter가 구현되어 드라이버가 연결과 관련된 세션 상태를 재설정하고 연결 상태가 불량하다는 신호를 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aab8e5c4d0aeae85893fd621bc37db1b1a73696a" translate="yes" xml:space="preserve">
          <source>Set assigns x to the value v. It panics if CanSet returns false. As in Go, x's value must be assignable to v's type.</source>
          <target state="translated">Set는 x를 값 v에 할당합니다. CanSet이 false를 반환하면 패닉이 발생합니다. Go에서와 같이 x의 값은 v의 유형에 지정할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="1d2a8709f5b7f411cc9ba583a652581b21b6d185" translate="yes" xml:space="preserve">
          <source>Set is called once, in command line order, for each flag present. The flag package may call the String method with a zero-valued receiver, such as a nil pointer.</source>
          <target state="translated">각 플래그가 존재하면 명령 행 순서로 Set이 한 번 호출됩니다. 플래그 패키지는 nil 포인터와 같이 값이 0 인 수신자로 String 메소드를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8fb40cfeae3d73e6b30e01495ac2c9fe7ff8cc2" translate="yes" xml:space="preserve">
          <source>Set sets the JavaScript property p of value v to ValueOf(x). It panics if v is not a JavaScript object.</source>
          <target state="translated">Set 값 v의 JavaScript 속성 p를 ValueOf (x)로 설정합니다. v가 JavaScript 객체가 아닌 경우 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="87f6096d8457ac4b04a70faa68ba0c62c9f61ecc" translate="yes" xml:space="preserve">
          <source>Set sets the header entries associated with key to the single element value. It replaces any existing values associated with key.</source>
          <target state="translated">설정은 키와 연관된 헤더 항목을 단일 요소 값으로 설정합니다. 키와 관련된 기존 값을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="82fcf24728ab76cc9481c998a3f5414cead1eb36" translate="yes" xml:space="preserve">
          <source>Set sets the header entries associated with key to the single element value. It replaces any existing values associated with key. The key is case insensitive; it is canonicalized by textproto.CanonicalMIMEHeaderKey. To use non-canonical keys, assign to the map directly.</source>
          <target state="translated">설정은 키와 연관된 헤더 항목을 단일 요소 값으로 설정합니다. 키와 관련된 기존 값을 대체합니다. 키는 대소 문자를 구분하지 않습니다. textproto.CanonicalMIMEHeaderKey에 의해 정규화됩니다. 비정규 키를 사용하려면 맵에 직접 할당하십시오.</target>
        </trans-unit>
        <trans-unit id="ac88d8d813ac589b26e82c68ebe23a65cc8513a6" translate="yes" xml:space="preserve">
          <source>Set sets the key to value. It replaces any existing values.</source>
          <target state="translated">설정은 키를 값으로 설정합니다. 기존 값을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="03d2da815b81b3b89a818437487ee57f67fe7d66" translate="yes" xml:space="preserve">
          <source>Set sets the value of the named command-line flag.</source>
          <target state="translated">Set은 명명 된 명령 줄 플래그의 값을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="f73f9638b07619a017d2f6dac015fd0d243d8333" translate="yes" xml:space="preserve">
          <source>Set sets the value of the named flag.</source>
          <target state="translated">이름 지정된 플래그의 값을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="2c301753363dd5c13e85e87be14b65f72e0bdbb9" translate="yes" xml:space="preserve">
          <source>Set sets v to value.</source>
          <target state="translated">v를 값으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="0e0649c67f5fc5e092366b50d2ec623dd85834a8" translate="yes" xml:space="preserve">
          <source>Set sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to the precision of x before setting z (and rounding will have no effect). Rounding is performed according to z's precision and rounding mode; and z's accuracy reports the result error relative to the exact (not rounded) result.</source>
          <target state="translated">z를 x의 (둥근 반올림) 값으로 설정하고 z를 반환합니다. z의 정밀도가 0이면 z를 설정하기 전에 x의 정밀도로 변경됩니다 (반올림은 적용되지 않습니다). 반올림은 z의 정밀도 및 반올림 모드에 따라 수행됩니다. z의 정확도는 정확한 (반올림되지 않은) 결과에 대한 결과 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="74c097d8a8db6198a9f30d1da9cc40810faf97ea" translate="yes" xml:space="preserve">
          <source>Set sets z to x (by making a copy of x) and returns z.</source>
          <target state="translated">x를 복사하여 z를 x로 설정하고 z를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2de2c16a0340db2bee0118ccf9d1587fd704cd50" translate="yes" xml:space="preserve">
          <source>Set sets z to x and returns z.</source>
          <target state="translated">z를 x로 설정하고 z를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fd19264e05439f601808981687979a9cbd55329f" translate="yes" xml:space="preserve">
          <source>SetBasicAuth sets the request's Authorization header to use HTTP Basic Authentication with the provided username and password.</source>
          <target state="translated">SetBasicAuth는 요청의 Authorization 헤더가 제공된 사용자 이름과 비밀번호로 HTTP 기본 인증을 사용하도록 설정합니다.</target>
        </trans-unit>
        <trans-unit id="22bdae472d3db85cab5c57989c6be910d803a01e" translate="yes" xml:space="preserve">
          <source>SetBit sets z to x, with x's i'th bit set to b (0 or 1). That is, if b is 1 SetBit sets z = x | (1 &amp;lt;&amp;lt; i); if b is 0 SetBit sets z = x &amp;amp;^ (1 &amp;lt;&amp;lt; i). If b is not 0 or 1, SetBit will panic.</source>
          <target state="translated">SetBit은 z를 x로 설정하고 x의 i 번째 비트를 b (0 또는 1)로 설정합니다. 즉, b가 1이면 SetBit은 z = x를 설정합니다. | (1 &amp;lt;&amp;lt; i); b가 0이면 SetBit은 z = x &amp;amp; ^ (1 &amp;lt;&amp;lt; i)를 설정합니다. b가 0 또는 1이 아니면 SetBit이 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="feba31f1e1635889b9235c6993fbb340077ba325" translate="yes" xml:space="preserve">
          <source>SetBits provides raw (unchecked but fast) access to z by setting its value to abs, interpreted as a little-endian Word slice, and returning z. The result and abs share the same underlying array. SetBits is intended to support implementation of missing low-level Int functionality outside this package; it should be avoided otherwise.</source>
          <target state="translated">SetBits는 값을 abs로 설정하고 리틀 엔디안 워드 슬라이스로 해석 한 다음 z를 반환하여 z에 대한 원시 (확인되지 ​​않았지만 빠른) 액세스를 제공합니다. 결과와 abs는 동일한 기본 배열을 공유합니다. SetBits는이 패키지 외부에서 누락 된 저수준 Int 기능의 구현을 지원하기위한 것입니다. 그렇지 않으면 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="f0a90ede61cca8ba0e26af9fe2c3c6480079bf80" translate="yes" xml:space="preserve">
          <source>SetBlockProfileRate controls the fraction of goroutine blocking events that are reported in the blocking profile. The profiler aims to sample an average of one blocking event per rate nanoseconds spent blocked.</source>
          <target state="translated">SetBlockProfileRate는 차단 프로파일에보고되는 고 루틴 차단 이벤트의 비율을 제어합니다. 프로파일 러는 차단 된 나노 초당 속도 당 평균 1 회의 차단 이벤트를 샘플링하는 것을 목표로합니다.</target>
        </trans-unit>
        <trans-unit id="459d3a69d65d385fb3b3fbe398bb9c85138ddcc2" translate="yes" xml:space="preserve">
          <source>SetBool sets v's underlying value. It panics if v's Kind is not Bool or if CanSet() is false.</source>
          <target state="translated">SetBool은 v의 기본 값을 설정합니다. v의 Kind가 Bool이 아니거나 CanSet ()이 false 인 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7e2455227631da0419c37dea6613f51644e9e03d" translate="yes" xml:space="preserve">
          <source>SetBoundary must be called before any parts are created, may only contain certain ASCII characters, and must be non-empty and at most 70 bytes long.</source>
          <target state="translated">부품을 만들기 전에 SetBoundary를 호출해야하며 특정 ASCII 문자 만 포함 할 수 있으며 비어 있지 않아야하며 최대 70 바이트 여야합니다.</target>
        </trans-unit>
        <trans-unit id="b06cf4ca1fda2091c2541de19f0b4a515ade4ba9" translate="yes" xml:space="preserve">
          <source>SetBoundary overrides the Writer's default randomly-generated boundary separator with an explicit value.</source>
          <target state="translated">SetBoundary는 Writer의 무작위로 생성 된 기본 경계 분리자를 명시 적 값으로 대체합니다.</target>
        </trans-unit>
        <trans-unit id="6106f2ae31464af3b2e7f9b63e64b76356750152" translate="yes" xml:space="preserve">
          <source>SetBytes interprets buf as the bytes of a big-endian unsigned integer, sets z to that value, and returns z.</source>
          <target state="translated">SetBytes는 buf를 부호없는 빅 엔디안 정수의 바이트로 해석하고 z를 해당 값으로 설정 한 다음 z를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7a0583b12bc86b9434e36c34c4ce6e8b5c26ba75" translate="yes" xml:space="preserve">
          <source>SetBytes records the number of bytes processed in a single operation. If this is called, the benchmark will report ns/op and MB/s.</source>
          <target state="translated">SetBytes는 단일 작업에서 처리 된 바이트 수를 기록합니다. 이것이 호출되면 벤치 마크는 ns / op 및 MB / s를보고합니다.</target>
        </trans-unit>
        <trans-unit id="bba92654aa999e9512f4dfa6313cb2838144dfe3" translate="yes" xml:space="preserve">
          <source>SetBytes sets v's underlying value. It panics if v's underlying value is not a slice of bytes.</source>
          <target state="translated">SetBytes는 v의 기본 값을 설정합니다. v의 기본 값이 바이트 슬라이스가 아닌 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="344d8ddf2a696d0cf0cc16a1825af1241c772a89" translate="yes" xml:space="preserve">
          <source>SetCPUProfileRate sets the CPU profiling rate to hz samples per second. If hz &amp;lt;= 0, SetCPUProfileRate turns off profiling. If the profiler is on, the rate cannot be changed without first turning it off.</source>
          <target state="translated">SetCPUProfileRate는 CPU 프로파일 링 속도를 초당 hz 샘플로 설정합니다. hz &amp;lt;= 0이면 SetCPUProfileRate가 프로파일 링을 끕니다. 프로파일 러가 켜져 있으면 먼저 끄지 않고 속도를 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1afcde63337e23e05a9b84c1c7b85f57c0092cd7" translate="yes" xml:space="preserve">
          <source>SetCap sets v's capacity to n. It panics if v's Kind is not Slice or if n is smaller than the length or greater than the capacity of the slice.</source>
          <target state="translated">SetCap은 v의 용량을 n으로 설정합니다. v의 종류가 슬라이스가 아니거나 n이 길이보다 작거나 슬라이스의 용량보다 큰 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="44731bc16b3d80516224c7c852f64732d07d62c1" translate="yes" xml:space="preserve">
          <source>SetCgoTraceback records three C functions to use to gather traceback information from C code and to convert that traceback information into symbolic information. These are used when printing stack traces for a program that uses cgo.</source>
          <target state="translated">SetCgoTraceback은 C 코드에서 역 추적 정보를 수집하고 해당 역 추적 정보를 기호 정보로 변환하는 데 사용되는 세 가지 C 함수를 기록합니다. cgo를 사용하는 프로그램의 스택 추적을 인쇄 할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="348727b9cf484ab1b9762cea6ba0daa8dde8a933" translate="yes" xml:space="preserve">
          <source>SetCgoTraceback should be called only once, ideally from an init function.</source>
          <target state="translated">SetCgoTraceback은 init 함수에서 이상적으로 한 번만 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="67fdfbbba9d56846727e0eb32ef8332c0bf20f53" translate="yes" xml:space="preserve">
          <source>SetComment sets the end-of-central-directory comment field. It can only be called before Close.</source>
          <target state="translated">SetComment는 중앙 디렉토리 끝 주석 필드를 설정합니다. 닫기 전에 만 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64f03250bccb0b87aeb45d79cb945d1dd0319cb9" translate="yes" xml:space="preserve">
          <source>SetComplex sets v's underlying value to x. It panics if v's Kind is not Complex64 or Complex128, or if CanSet() is false.</source>
          <target state="translated">SetComplex는 v의 기본 값을 x로 설정합니다. v의 Kind가 Complex64 또는 Complex128이 아니거나 CanSet ()이 false 인 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b69ac591abf21b23b441af754a7112fe6fa046f7" translate="yes" xml:space="preserve">
          <source>SetConnMaxIdleTime sets the maximum amount of time a connection may be idle.</source>
          <target state="translated">SetConnMaxIdleTime은 연결이 유휴 상태 일 수있는 최대 시간을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="ac6f79734771b4e3adca460b8931ae634206e20f" translate="yes" xml:space="preserve">
          <source>SetConnMaxLifetime sets the maximum amount of time a connection may be reused.</source>
          <target state="translated">SetConnMaxLifetime은 연결을 재사용 할 수있는 최대 시간을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="cdfc398e60b71e846a0a56ba3b1860f275a8c713" translate="yes" xml:space="preserve">
          <source>SetCookie adds a Set-Cookie header to the provided ResponseWriter's headers. The provided cookie must have a valid Name. Invalid cookies may be silently dropped.</source>
          <target state="translated">SetCookie는 Set-Cookie 헤더를 제공된 ResponseWriter의 헤더에 추가합니다. 제공된 쿠키는 유효한 이름을 가져야합니다. 유효하지 않은 쿠키가 자동으로 삭제 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1b53737e17baa71a51a0e5ede6a121ccba30720" translate="yes" xml:space="preserve">
          <source>SetCookies implements the SetCookies method of the http.CookieJar interface.</source>
          <target state="translated">SetCookies는 http.CookieJar 인터페이스의 SetCookies 메소드를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="d3cec8d8761e8a9c75efaa51883455428c208775" translate="yes" xml:space="preserve">
          <source>SetDeadline implements the Conn SetDeadline method.</source>
          <target state="translated">SetDeadline은 Conn SetDeadline 메소드를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="c0b50695667af085ed75f6ae0d7d496b50008cd3" translate="yes" xml:space="preserve">
          <source>SetDeadline sets the deadline associated with the listener. A zero time value disables the deadline.</source>
          <target state="translated">SetDeadline은 리스너와 관련된 최종 기한을 설정합니다. 시간 값이 0이면 최종 기한이 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="a7b4723a8859169359d85b5290587d68a0fc3307" translate="yes" xml:space="preserve">
          <source>SetDeadline sets the read and write deadlines associated with the connection. A zero value for t means Read and Write will not time out. After a Write has timed out, the TLS state is corrupt and all future writes will return the same error.</source>
          <target state="translated">SetDeadline은 연결과 관련된 읽기 및 쓰기 기한을 설정합니다. t 값이 0이면 읽기 및 쓰기 시간이 초과되지 않습니다. 쓰기 시간이 초과되면 TLS 상태가 손상되고 이후의 모든 쓰기에서 동일한 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="883b1167470e9a9bc17df175940ef7113ec71b15" translate="yes" xml:space="preserve">
          <source>SetDeadline sets the read and write deadlines for a File. It is equivalent to calling both SetReadDeadline and SetWriteDeadline.</source>
          <target state="translated">SetDeadline은 파일의 읽기 및 쓰기 기한을 설정합니다. SetReadDeadline 및 SetWriteDeadline을 모두 호출하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7aad8c47d1ea7eb52b60d62c5b63c9894a7f6a08" translate="yes" xml:space="preserve">
          <source>SetEscapeHTML specifies whether problematic HTML characters should be escaped inside JSON quoted strings. The default behavior is to escape &amp;amp;, &amp;lt;, and &amp;gt; to \u0026, \u003c, and \u003e to avoid certain safety problems that can arise when embedding JSON in HTML.</source>
          <target state="translated">SetEscapeHTML은 문제가있는 HTML 문자가 JSON 인용 문자열 내에서 이스케이프되어야하는지 여부를 지정합니다. 기본 동작은 JSON을 HTML에 임베드 할 때 발생할 수있는 특정 안전 문제를 피하기 위해 &amp;amp;, &amp;lt;및&amp;gt;를 \ u0026, \ u003c 및 \ u003e로 이스케이프하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="dd27241a174aea4c1fb70802e55de9c35c7e1aca" translate="yes" xml:space="preserve">
          <source>SetFinalizer sets the finalizer associated with obj to the provided finalizer function. When the garbage collector finds an unreachable block with an associated finalizer, it clears the association and runs finalizer(obj) in a separate goroutine. This makes obj reachable again, but now without an associated finalizer. Assuming that SetFinalizer is not called again, the next time the garbage collector sees that obj is unreachable, it will free obj.</source>
          <target state="translated">SetFinalizer는 obj와 관련된 종료자를 제공된 종료 자 기능으로 설정합니다. 가비지 콜렉터는 연관된 종료자가있는 도달 할 수없는 블록을 찾으면 연관을 지우고 별도의 고 루틴에서 finalizer (obj)를 실행합니다. 이렇게하면 obj에 다시 도달 할 수 있지만 관련 finalizer가 없어집니다. SetFinalizer가 다시 호출되지 않는다고 가정하면 다음에 가비지 수집기가 obj에 도달 할 수 없음을 확인하면 obj를 해제합니다.</target>
        </trans-unit>
        <trans-unit id="516de8a9b6e7300def0c0d80a14119cce09c9af1" translate="yes" xml:space="preserve">
          <source>SetFinalizer(obj, nil) clears any finalizer associated with obj.</source>
          <target state="translated">SetFinalizer (obj, nil)는 obj와 관련된 종료자를 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="fce6aef209330cc8b12176816b79927fb4cacd60" translate="yes" xml:space="preserve">
          <source>SetFlags sets the output flags for the logger.</source>
          <target state="translated">SetFlags는 로거의 출력 플래그를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="2389acee4b107177db39a04d2a50d69a80e07539" translate="yes" xml:space="preserve">
          <source>SetFlags sets the output flags for the logger. The flag bits are Ldate, Ltime, and so on.</source>
          <target state="translated">SetFlags는 로거의 출력 플래그를 설정합니다. 플래그 비트는 Ldate, Ltime 등입니다.</target>
        </trans-unit>
        <trans-unit id="dd0ec7930cc082a2a1ef8ed98443be56c5746d85" translate="yes" xml:space="preserve">
          <source>SetFlags sets the output flags for the standard logger.</source>
          <target state="translated">SetFlags는 표준 로거의 출력 플래그를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="e112d20317b511d78e95cf42b818e10d239d1b7a" translate="yes" xml:space="preserve">
          <source>SetFlags sets the output flags for the standard logger. The flag bits are Ldate, Ltime, and so on.</source>
          <target state="translated">SetFlags는 표준 로거에 대한 출력 플래그를 설정합니다. 플래그 비트는 Ldate, Ltime 등입니다.</target>
        </trans-unit>
        <trans-unit id="a44e49f661219c769f20780167a6964483f17f7a" translate="yes" xml:space="preserve">
          <source>SetFloat sets v's underlying value to x. It panics if v's Kind is not Float32 or Float64, or if CanSet() is false.</source>
          <target state="translated">SetFloat는 v의 기본 값을 x로 설정합니다. v의 Kind가 Float32 또는 Float64가 아니거나 CanSet ()이 false 인 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8e47d96a49d3af2841a8dc184d5134cb1a32de48" translate="yes" xml:space="preserve">
          <source>SetFloat64 sets z to exactly f and returns z. If f is not finite, SetFloat returns nil.</source>
          <target state="translated">SetFloat64는 z를 정확히 f로 설정하고 z를 반환합니다. f가 유한하지 않으면 SetFloat는 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7d8e2534e02690c3fed1859413bf2f8f63c436f1" translate="yes" xml:space="preserve">
          <source>SetFloat64 sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to 53 (and rounding will have no effect). SetFloat64 panics with ErrNaN if x is a NaN.</source>
          <target state="translated">SetFloat64는 z를 x의 (둥근 반올림) 값으로 설정하고 z를 반환합니다. z의 정밀도가 0이면 53으로 변경되며 반올림은 적용되지 않습니다. x가 NaN 인 경우 ErrNaN을 사용하여 Float64 패닉을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="7b801568b0fa82e3d000c6cfdb98f7b328836a9b" translate="yes" xml:space="preserve">
          <source>SetFrac sets z to a/b and returns z.</source>
          <target state="translated">SetFrac은 z를 a / b로 설정하고 z를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a9ac4380aa91d01b1e1308169f05c3eff9861e31" translate="yes" xml:space="preserve">
          <source>SetFrac sets z to a/b and returns z. If b == 0, SetFrac panics.</source>
          <target state="translated">SetFrac은 z를 a / b로 설정하고 z를 반환합니다. b == 0이면 SetFrac에 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="45fde5eac415722d6b8394ea7547d400d1373021" translate="yes" xml:space="preserve">
          <source>SetFrac64 sets z to a/b and returns z.</source>
          <target state="translated">SetFrac64는 z를 a / b로 설정하고 z를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5993df56e43367a1c47f44460a83d56bdcf65739" translate="yes" xml:space="preserve">
          <source>SetFrac64 sets z to a/b and returns z. If b == 0, SetFrac64 panics.</source>
          <target state="translated">SetFrac64는 z를 a / b로 설정하고 z를 반환합니다. b == 0이면 SetFrac64에 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="805636f93a7dd0b6aa2183e35b0d00ca6d7104e9" translate="yes" xml:space="preserve">
          <source>SetGCPercent sets the garbage collection target percentage: a collection is triggered when the ratio of freshly allocated data to live data remaining after the previous collection reaches this percentage. SetGCPercent returns the previous setting. The initial setting is the value of the GOGC environment variable at startup, or 100 if the variable is not set. A negative percentage disables garbage collection.</source>
          <target state="translated">SetGCPercent는 가비지 콜렉션 대상 백분율을 설정합니다. 이전 콜렉션이 남아있는 후 새로 할당 된 데이터 대 라이브 데이터의 비율이이 백분율에 도달하면 콜렉션이 트리거됩니다. SetGCPercent는 이전 설정을 반환합니다. 초기 설정은 시작시 GOGC 환경 변수의 값이거나 변수가 설정되지 않은 경우 100입니다. 음수 백분율은 가비지 수집을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="906978195b1fb386902e36080f453c88d02f6211" translate="yes" xml:space="preserve">
          <source>SetGoroutineLabels sets the current goroutine's labels to match ctx. A new goroutine inherits the labels of the goroutine that created it. This is a lower-level API than Do, which should be used instead when possible.</source>
          <target state="translated">SetGoroutineLabels는 현재 goroutine의 레이블을 ctx와 일치하도록 설정합니다. 새로운 고 루틴은 그것을 생성 한 고 루틴의 레이블을 상속합니다. 이 API는 Do보다 낮은 수준의 API이므로 가능한 경우 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="7c95fdd46823686f50f0d15060d185e4b4e5d563" translate="yes" xml:space="preserve">
          <source>SetImports sets the list of explicitly imported packages to list. It is the caller's responsibility to make sure list elements are unique.</source>
          <target state="translated">SetImports는 명시 적으로 가져온 패키지 목록을 나열하도록 설정합니다. 목록 요소가 고유한지 확인하는 것은 호출자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="e7fb2cb55e4274d490452e6757d30cb84eb70855" translate="yes" xml:space="preserve">
          <source>SetIndent instructs the encoder to format each subsequent encoded value as if indented by the package-level function Indent(dst, src, prefix, indent). Calling SetIndent(&quot;&quot;, &quot;&quot;) disables indentation.</source>
          <target state="translated">SetIndent는 패키지 레벨 함수 Indent (dst, src, prefix, indent)에 의해 들여 쓰기 된 것처럼 각 후속 인코딩 된 값을 포맷하도록 인코더에 지시합니다. SetIndent ( &quot;&quot;, &quot;&quot;)를 호출하면 들여 쓰기가 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="17d73d2c7105e3ec880ec1de340daf4f290af178" translate="yes" xml:space="preserve">
          <source>SetIndex sets the JavaScript index i of value v to ValueOf(x). It panics if v is not a JavaScript object.</source>
          <target state="translated">SetIndex는 값 v의 JavaScript 인덱스 i를 ValueOf (x)로 설정합니다. v가 JavaScript 객체가 아닌 경우 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="cea11721fc2a69428fc01f2bd7212d126248c97a" translate="yes" xml:space="preserve">
          <source>SetInf sets z to the infinite Float -Inf if signbit is set, or +Inf if signbit is not set, and returns z. The precision of z is unchanged and the result is always Exact.</source>
          <target state="translated">SetInf는 부호 비트가 설정되어 있으면 z를 무한 Float -Inf로 설정하고 부호 비트가 설정되어 있지 않으면 + Inf로 설정하고 z를 반환합니다. z의 정밀도는 변경되지 않으며 결과는 항상 정확합니다.</target>
        </trans-unit>
        <trans-unit id="7fbe79d67709b54bb947c5fb56d1678d22a06e68" translate="yes" xml:space="preserve">
          <source>SetInt sets v's underlying value to x. It panics if v's Kind is not Int, Int8, Int16, Int32, or Int64, or if CanSet() is false.</source>
          <target state="translated">SetInt는 v의 기본 값을 x로 설정합니다. v의 Kind가 Int, Int8, Int16, Int32 또는 Int64가 아니거나 CanSet ()이 false 인 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e9791f172aed7c20562244430ee2933689079ec7" translate="yes" xml:space="preserve">
          <source>SetInt sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to the larger of x.BitLen() or 64 (and rounding will have no effect).</source>
          <target state="translated">SetInt는 z를 x의 (둥근 반올림) 값으로 설정하고 z를 반환합니다. z의 정밀도가 0이면 x.BitLen () 또는 64보다 크게 변경됩니다 (반올림은 적용되지 않습니다).</target>
        </trans-unit>
        <trans-unit id="512491a3910b089e941ff0967a1c4600d38512e1" translate="yes" xml:space="preserve">
          <source>SetInt sets z to x (by making a copy of x) and returns z.</source>
          <target state="translated">SetInt는 z를 x로 설정하고 (x를 복사하여) z를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e98bca88644a6b411de0d879f43c3dc3a73ef347" translate="yes" xml:space="preserve">
          <source>SetInt64 sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to 64 (and rounding will have no effect).</source>
          <target state="translated">SetInt64는 z를 x의 (둥근 반올림) 값으로 설정하고 z를 반환합니다. z의 정밀도가 0이면 64로 변경되며 반올림은 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b8bc149266ba57391034d803e65399926af1a382" translate="yes" xml:space="preserve">
          <source>SetInt64 sets z to x and returns z.</source>
          <target state="translated">SetInt64는 z를 x로 설정하고 z를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d8ce7465b1093a7258c6cd344217beee671aa978" translate="yes" xml:space="preserve">
          <source>SetKeepAlive sets whether the operating system should send keep-alive messages on the connection.</source>
          <target state="translated">SetKeepAlive는 운영 체제가 연결에서 연결 유지 메시지를 보낼지 여부를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="89bf3d4dd275ff44ab7379e669050fce6f5a7eee" translate="yes" xml:space="preserve">
          <source>SetKeepAlivePeriod sets period between keep-alives.</source>
          <target state="translated">SetKeepAlivePeriod는 연결 유지 기간을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="582102a7fa3d8dd186ee22dfa213a701e54c1846" translate="yes" xml:space="preserve">
          <source>SetKeepAlivesEnabled controls whether HTTP keep-alives are enabled. By default, keep-alives are always enabled. Only very resource-constrained environments or servers in the process of shutting down should disable them.</source>
          <target state="translated">SetKeepAlivesEnabled는 HTTP 연결 유지를 사용할지 여부를 제어합니다. 기본적으로 연결 유지는 항상 활성화되어 있습니다. 시스템을 종료하는 과정에서 리소스가 제한된 환경이나 서버 만 비활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="26dfe6afebdd675610dd8f1d4858b29cc7ee92db" translate="yes" xml:space="preserve">
          <source>SetLen sets v's length to n. It panics if v's Kind is not Slice or if n is negative or greater than the capacity of the slice.</source>
          <target state="translated">SetLen은 v의 길이를 n으로 설정합니다. v의 종류가 슬라이스가 아니거나 n이 음수이거나 슬라이스의 용량보다 큰 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="549c2b676df9b698394503e0fb62c18e8fa20e0b" translate="yes" xml:space="preserve">
          <source>SetLines sets the line offsets for a file and reports whether it succeeded. The line offsets are the offsets of the first character of each line; for instance for the content &quot;ab\nc\n&quot; the line offsets are {0, 3}. An empty file has an empty line offset table. Each line offset must be larger than the offset for the previous line and smaller than the file size; otherwise SetLines fails and returns false. Callers must not mutate the provided slice after SetLines returns.</source>
          <target state="translated">SetLines는 파일의 행 오프셋을 설정하고 파일의 성공 여부를보고합니다. 행 오프셋은 각 행의 첫 문자의 오프셋입니다. 예를 들어 컨텐츠 &quot;ab \ nc \ n&quot;의 경우 라인 오프셋은 {0, 3}입니다. 빈 파일에는 빈 줄 오프셋 테이블이 있습니다. 각 줄 오프셋은 이전 줄의 오프셋보다 크고 파일 크기보다 작아야합니다. 그렇지 않으면 SetLines가 실패하고 false를 반환합니다. SetLines가 반환 된 후 호출자는 제공된 슬라이스를 변경해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="d21966bc8423cbdfca9062e709a1e1bfe2b23f9c" translate="yes" xml:space="preserve">
          <source>SetLinesForContent sets the line offsets for the given file content. It ignores position-altering //line comments.</source>
          <target state="translated">SetLinesForContent는 주어진 파일 내용에 대한 줄 오프셋을 설정합니다. 위치 변경 // 줄 주석은 무시합니다.</target>
        </trans-unit>
        <trans-unit id="7ead5ff3e458c012090db0e3e46dd956293c59f9" translate="yes" xml:space="preserve">
          <source>SetLinger sets the behavior of Close on a connection which still has data waiting to be sent or to be acknowledged.</source>
          <target state="translated">SetLinger는 여전히 데이터 전송 또는 승인 대기중인 연결에서 닫기 동작을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="be9cec1a054bdf6dae13515b712cb92bca8f03d8" translate="yes" xml:space="preserve">
          <source>SetMantExp sets z to mant &amp;times; 2**exp and returns z. The result z has the same precision and rounding mode as mant. SetMantExp is an inverse of MantExp but does not require 0.5 &amp;lt;= |mant| &amp;lt; 1.0. Specifically:</source>
          <target state="translated">SetMantExp는 z를 mant &amp;times; 2 ** exp로 설정하고 z를 반환합니다. 결과 z는 mant와 동일한 정밀도 및 반올림 모드를 갖습니다. SetMantExp는 MantExp의 역수이지만 0.5 &amp;lt;= | mant | &amp;lt;1.0. 구체적으로 특별히:</target>
        </trans-unit>
        <trans-unit id="e756f252cafbddbad755f1c06583ad4489564d92" translate="yes" xml:space="preserve">
          <source>SetMapIndex sets the element associated with key in the map v to elem. It panics if v's Kind is not Map. If elem is the zero Value, SetMapIndex deletes the key from the map. Otherwise if v holds a nil map, SetMapIndex will panic. As in Go, key's elem must be assignable to the map's key type, and elem's value must be assignable to the map's elem type.</source>
          <target state="translated">SetMapIndex는 맵 v의 키와 관련된 요소를 elem으로 설정합니다. v의 종류가지도가 아닌 경우 패닉이 발생합니다. elem이 0 값이면 SetMapIndex는 맵에서 키를 삭제합니다. 그렇지 않으면 v에 nil 맵이 있으면 SetMapIndex가 패닉 상태가됩니다. Go와 마찬가지로 키의 elem은지도의 키 유형에 할당 할 수 있어야하고 elem의 값은지도의 elem 유형에 할당 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="b83dfa89acb5e3c977158b5fc2760de63b71e48b" translate="yes" xml:space="preserve">
          <source>SetMaxIdleConns sets the maximum number of connections in the idle connection pool.</source>
          <target state="translated">SetMaxIdleConns는 유휴 연결 풀의 최대 연결 수를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="aa3863aa142a9c48791c290f00a7c4c3d76f3b6e" translate="yes" xml:space="preserve">
          <source>SetMaxOpenConns sets the maximum number of open connections to the database.</source>
          <target state="translated">SetMaxOpenConns는 데이터베이스에 대한 최대 열린 연결 수를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="f71d21e95f096f232e72fff30f80b920b1e3f9f5" translate="yes" xml:space="preserve">
          <source>SetMaxStack is useful mainly for limiting the damage done by goroutines that enter an infinite recursion. It only limits future stack growth.</source>
          <target state="translated">SetMaxStack은 무한 재귀에 들어가는 고 루틴에 의한 피해를 제한하는 데 주로 유용합니다. 향후 스택 증가 만 제한합니다.</target>
        </trans-unit>
        <trans-unit id="eeacbe78a8fd0d4396f1b6456e34f5857612c565" translate="yes" xml:space="preserve">
          <source>SetMaxStack sets the maximum amount of memory that can be used by a single goroutine stack. If any goroutine exceeds this limit while growing its stack, the program crashes. SetMaxStack returns the previous setting. The initial setting is 1 GB on 64-bit systems, 250 MB on 32-bit systems.</source>
          <target state="translated">SetMaxStack은 단일 고 루틴 스택에서 사용할 수있는 최대 메모리 양을 설정합니다. 스택이 커지는 동안 goroutine이이 한계를 초과하면 프로그램이 충돌합니다. SetMaxStack은 이전 설정을 반환합니다. 초기 설정은 64 비트 시스템에서 1GB, 32 비트 시스템에서 250MB입니다.</target>
        </trans-unit>
        <trans-unit id="f3db779e80ef6f3114ec1d823f560fd81d90559f" translate="yes" xml:space="preserve">
          <source>SetMaxStack sets the maximum amount of memory that can be used by a single goroutine stack. If any goroutine exceeds this limit while growing its stack, the program crashes. SetMaxStack returns the previous setting. The initial setting is 1 GB on 64-bit systems, 250 MB on 32-bit systems. There may be a system-imposed maximum stack limit regardless of the value provided to SetMaxStack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67aff5f59d34d3ecd519adad914c8c6423eaf752" translate="yes" xml:space="preserve">
          <source>SetMaxThreads is useful mainly for limiting the damage done by programs that create an unbounded number of threads. The idea is to take down the program before it takes down the operating system.</source>
          <target state="translated">SetMaxThreads는 무한한 수의 스레드를 생성하는 프로그램으로 인한 손상을 제한하는 데 주로 유용합니다. 아이디어는 운영 체제를 중단하기 전에 프로그램을 중단하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c6d8bc8cae003fe5d78cf6cda31fbae67e36c482" translate="yes" xml:space="preserve">
          <source>SetMaxThreads sets the maximum number of operating system threads that the Go program can use. If it attempts to use more than this many, the program crashes. SetMaxThreads returns the previous setting. The initial setting is 10,000 threads.</source>
          <target state="translated">SetMaxThreads는 Go 프로그램이 사용할 수있는 최대 운영 체제 스레드 수를 설정합니다. 이보다 많은 수를 사용하려고하면 프로그램이 중단됩니다. SetMaxThreads는 이전 설정을 반환합니다. 초기 설정은 10,000 개의 스레드입니다.</target>
        </trans-unit>
        <trans-unit id="806ff185f3a93cc6a21f24b12259c49de358388c" translate="yes" xml:space="preserve">
          <source>SetModTime sets the Modified, ModifiedTime, and ModifiedDate fields to the given time in UTC.</source>
          <target state="translated">SetModTime은 Modified, ModifiedTime 및 ModifiedDate 필드를 UTC로 지정된 시간으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="e9c592771061ffaaa3d588fb3aae3da84d0635b8" translate="yes" xml:space="preserve">
          <source>SetMode changes the permission and mode bits for the FileHeader.</source>
          <target state="translated">SetMode는 FileHeader의 권한 및 모드 비트를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="de45da11e316c622a3816956315a15e8817585f9" translate="yes" xml:space="preserve">
          <source>SetMode sets z's rounding mode to mode and returns an exact z. z remains unchanged otherwise. z.SetMode(z.Mode()) is a cheap way to set z's accuracy to Exact.</source>
          <target state="translated">SetMode는 z의 반올림 모드를 mode로 설정하고 정확한 z를 반환합니다. 그렇지 않으면 z는 변경되지 않습니다. z.SetMode (z.Mode ())는 z의 정확도를 정확한 값으로 설정하는 가장 저렴한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="b01a08220867d2b1a3c66f3bf6f8b7ca7ea5c1ae" translate="yes" xml:space="preserve">
          <source>SetMutexProfileFraction controls the fraction of mutex contention events that are reported in the mutex profile. On average 1/rate events are reported. The previous rate is returned.</source>
          <target state="translated">SetMutexProfileFraction은 뮤텍스 프로파일에보고되는 뮤텍스 경합 이벤트의 비율을 제어합니다. 평균 1 / 속도 이벤트가보고됩니다. 이전 요금이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="8c38b4a404d96b417f171861cd9ebaba18b51eaf" translate="yes" xml:space="preserve">
          <source>SetName sets the package name.</source>
          <target state="translated">SetName은 패키지 이름을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="d31306f3f7eb161aa0c0b28fdb6eed5363c589c3" translate="yes" xml:space="preserve">
          <source>SetNoDelay controls whether the operating system should delay packet transmission in hopes of sending fewer packets (Nagle's algorithm). The default is true (no delay), meaning that data is sent as soon as possible after a Write.</source>
          <target state="translated">SetNoDelay는 더 적은 수의 패킷을 전송하기 위해 운영 체제에서 패킷 전송을 지연해야하는지 여부를 제어합니다 (Nagle 알고리즘). 기본값은 true (지연 없음)입니다. 즉, 쓰기 후 가능한 빨리 데이터가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="27a3c03ba54fb2a44f36a6c425cfa58520c56752" translate="yes" xml:space="preserve">
          <source>SetOffset sets the offset of the beginning of the zip data within the underlying writer. It should be used when the zip data is appended to an existing file, such as a binary executable. It must be called before any data is written.</source>
          <target state="translated">SetOffset은 기본 작성기 내에서 zip 데이터 시작의 오프셋을 설정합니다. zip 데이터가 2 진 실행 파일과 같은 기존 파일에 추가 될 때 사용해야합니다. 데이터를 작성하기 전에 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="004613f6cff6f004aabdb462fd19757cc3df0edb" translate="yes" xml:space="preserve">
          <source>SetOutput sets the destination for usage and error messages. If output is nil, os.Stderr is used.</source>
          <target state="translated">SetOutput은 사용법 및 오류 메시지의 대상을 설정합니다. 출력이 nil이면 os.Stderr이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="36faf63cafa162e1ef49476325f422ab20f856dd" translate="yes" xml:space="preserve">
          <source>SetOutput sets the output destination for the logger.</source>
          <target state="translated">SetOutput은 로거의 출력 대상을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="76988d10d7783ed1525981a82207c054e24adba8" translate="yes" xml:space="preserve">
          <source>SetOutput sets the output destination for the standard logger.</source>
          <target state="translated">SetOutput은 표준 로거의 출력 대상을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="2547ce0f12468d65a113d53c2cfbf0ddbb6dc9bb" translate="yes" xml:space="preserve">
          <source>SetPanicOnFault controls the runtime's behavior when a program faults at an unexpected (non-nil) address. Such faults are typically caused by bugs such as runtime memory corruption, so the default response is to crash the program. Programs working with memory-mapped files or unsafe manipulation of memory may cause faults at non-nil addresses in less dramatic situations; SetPanicOnFault allows such programs to request that the runtime trigger only a panic, not a crash. SetPanicOnFault applies only to the current goroutine. It returns the previous setting.</source>
          <target state="translated">SetPanicOnFault는 프로그램이 예기치 않은 (0이 아닌) 주소에서 오류가 발생할 때 런타임 동작을 제어합니다. 이러한 결함은 일반적으로 런타임 메모리 손상과 같은 버그로 인해 발생하므로 기본 응답은 프로그램 충돌입니다. 메모리 매핑 된 파일을 사용하거나 안전하지 않은 메모리 조작을하는 프로그램은 덜 극적인 상황에서 0이 아닌 주소에서 오류를 일으킬 수 있습니다. SetPanicOnFault를 사용하면 이러한 프로그램에서 런타임이 충돌이 아닌 패닉 만 트리거하도록 요청할 수 있습니다. SetPanicOnFault는 현재 고 루틴에만 적용됩니다. 이전 설정을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3a5748945f587c9edbe8542b568516d2978238cd" translate="yes" xml:space="preserve">
          <source>SetPanicOnFault controls the runtime's behavior when a program faults at an unexpected (non-nil) address. Such faults are typically caused by bugs such as runtime memory corruption, so the default response is to crash the program. Programs working with memory-mapped files or unsafe manipulation of memory may cause faults at non-nil addresses in less dramatic situations; SetPanicOnFault allows such programs to request that the runtime trigger only a panic, not a crash. The runtime.Error that the runtime panics with may have an additional method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72fac8e6222bd170971f1f697af6f11d0715e763" translate="yes" xml:space="preserve">
          <source>SetParallelism sets the number of goroutines used by RunParallel to p*GOMAXPROCS. There is usually no need to call SetParallelism for CPU-bound benchmarks. If p is less than 1, this call will have no effect.</source>
          <target state="translated">SetParallelism은 RunParallel이 사용하는 고 루틴 수를 p * GOMAXPROCS로 설정합니다. 일반적으로 CPU 바인딩 벤치 마크를 위해 SetParallelism을 호출 할 필요가 없습니다. p가 1보다 작 으면이 호출은 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="8bcdfe56d7b7abb5a2feda191bae07f8cec5d4b8" translate="yes" xml:space="preserve">
          <source>SetPointer sets the unsafe.Pointer value v to x. It panics if v's Kind is not UnsafePointer.</source>
          <target state="translated">SetPointer는 안전하지 않은 Pointer 값 v를 x로 설정합니다. v의 종류가 UnsafePointer가 아닌 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="59bd457f6414829faae9decbaede734f70a9845c" translate="yes" xml:space="preserve">
          <source>SetPos sets the position. NewIdentifier is a public method so we can't modify its signature. Chained for convenience. TODO: fix one day?</source>
          <target state="translated">SetPos는 위치를 설정합니다. NewIdentifier는 공개 메소드이므로 서명을 수정할 수 없습니다. 편의를 위해 연결되었습니다. TODO : 언젠가 고쳐?</target>
        </trans-unit>
        <trans-unit id="d6d5511f09814008767ff9cfe0f77abca174ef5c" translate="yes" xml:space="preserve">
          <source>SetPrec sets z's precision to prec and returns the (possibly) rounded value of z. Rounding occurs according to z's rounding mode if the mantissa cannot be represented in prec bits without loss of precision. SetPrec(0) maps all finite values to &amp;plusmn;0; infinite values remain unchanged. If prec &amp;gt; MaxPrec, it is set to MaxPrec.</source>
          <target state="translated">SetPrec는 z의 정밀도를 prec로 설정하고 z의 반올림 값을 반환합니다. 가수가 정밀도 손실없이 prec 비트로 표현 될 수없는 경우 z의 반올림 모드에 따라 반올림이 발생합니다. SetPrec (0)은 모든 유한 값을 &amp;plusmn; 0에 매핑합니다. 무한 값은 변경되지 않습니다. prec&amp;gt; MaxPrec이면 MaxPrec로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="d2d0c71771db3b5022796766d08921a2f8600461" translate="yes" xml:space="preserve">
          <source>SetPrefix sets the output prefix for the logger.</source>
          <target state="translated">SetPrefix는 로거의 출력 접 두부를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="6bbad9fae1ec236892af0fd5032d525acd1599d4" translate="yes" xml:space="preserve">
          <source>SetPrefix sets the output prefix for the standard logger.</source>
          <target state="translated">SetPrefix는 표준 로거의 출력 접두사를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="ad88a7e02a294ade703b1e817a40a72d93a7117f" translate="yes" xml:space="preserve">
          <source>SetRat sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to the largest of a.BitLen(), b.BitLen(), or 64; with x = a/b.</source>
          <target state="translated">SetRat는 z를 x의 (둥근 반올림) 값으로 설정하고 z를 반환합니다. z의 정밀도가 0이면 최대 a.BitLen (), b.BitLen () 또는 64로 변경됩니다. x = a / b로.</target>
        </trans-unit>
        <trans-unit id="6d4064f9d933c367ae2ed00ed675edff7a545a0e" translate="yes" xml:space="preserve">
          <source>SetReadBuffer sets the size of the operating system's receive buffer associated with the connection.</source>
          <target state="translated">SetReadBuffer는 연결과 관련된 운영 체제의 수신 버퍼 크기를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="ccd6113cf88478a21eac0a31572f18b8edd4bad3" translate="yes" xml:space="preserve">
          <source>SetReadDeadline implements the Conn SetReadDeadline method.</source>
          <target state="translated">SetReadDeadline은 Conn SetReadDeadline 메소드를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="73112eb9e955bd18073b2a5d03cd0dc0569c7e77" translate="yes" xml:space="preserve">
          <source>SetReadDeadline sets the deadline for future Read calls and any currently-blocked Read call. A zero value for t means Read will not time out. Not all files support setting deadlines; see SetDeadline.</source>
          <target state="translated">SetReadDeadline은 향후 읽기 호출 및 현재 차단 된 읽기 호출에 대한 최종 기한을 설정합니다. t 값이 0이면 읽기 시간이 초과되지 않습니다. 모든 파일이 마감일 설정을 지원하지는 않습니다. SetDeadline을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fed46b093271b3a5ec6430ef1d4235557caf69e8" translate="yes" xml:space="preserve">
          <source>SetReadDeadline sets the read deadline on the underlying connection. A zero value for t means Read will not time out.</source>
          <target state="translated">SetReadDeadline은 기본 연결에서 읽기 최종 기한을 설정합니다. t 값이 0이면 읽기 시간이 초과되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a671d8f530db9b20355013a1524aa0514ba3175c" translate="yes" xml:space="preserve">
          <source>SetSeed sets h to use seed, which must have been returned by MakeSeed or by another Hash's Seed method. Two Hash objects with the same seed behave identically. Two Hash objects with different seeds will very likely behave differently. Any bytes added to h before this call will be discarded.</source>
          <target state="translated">SetSeed는 시드를 사용하도록 h를 설정합니다. 이는 MakeSeed 또는 다른 Hash의 Seed 메서드에 의해 반환되어야합니다. 동일한 시드를 가진 두 개의 Hash 객체는 동일하게 작동합니다. 시드가 다른 두 개의 Hash 개체는 다르게 동작 할 가능성이 높습니다. 이 호출 전에 h에 추가 된 모든 바이트는 버려집니다.</target>
        </trans-unit>
        <trans-unit id="9e522bee4b13d693f1283de4766e87f7104cee24" translate="yes" xml:space="preserve">
          <source>SetSessionTicketKeys updates the session ticket keys for a server.</source>
          <target state="translated">SetSessionTicketKeys는 서버의 세션 티켓 키를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="c85e891cbcac943a2a1c3092ec5cc6bdcd4ebc48" translate="yes" xml:space="preserve">
          <source>SetSessionTicketKeys updates the session ticket keys for a server. The first key will be used when creating new tickets, while all keys can be used for decrypting tickets. It is safe to call this function while the server is running in order to rotate the session ticket keys. The function will panic if keys is empty.</source>
          <target state="translated">SetSessionTicketKeys는 서버의 세션 티켓 키를 업데이트합니다. 첫 번째 키는 새 티켓을 만들 때 사용되며 모든 키는 티켓을 해독하는 데 사용할 수 있습니다. 세션 티켓 키를 회전시키기 위해 서버가 실행되는 동안이 기능을 호출하는 것이 안전합니다. 키가 비어 있으면 기능이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="8a945e442cacd2fa72eff38e8c9f6290d8ddbda2" translate="yes" xml:space="preserve">
          <source>SetString sets v's underlying value to x. It panics if v's Kind is not String or if CanSet() is false.</source>
          <target state="translated">SetString은 v의 기본 값을 x로 설정합니다. v의 Kind가 String이 아니거나 CanSet ()이 false 인 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e889ea521a067b34dab32ac1ec6528fffbf097cc" translate="yes" xml:space="preserve">
          <source>SetString sets z to the value of s and returns z and a boolean indicating success. s can be given as a (possibly signed) fraction &quot;a/b&quot;, or as a floating-point number optionally followed by an exponent. If a fraction is provided, both the dividend and the divisor may be a decimal integer or independently use a prefix of &amp;ldquo;0b&amp;rdquo;, &amp;ldquo;0&amp;rdquo; or &amp;ldquo;0o&amp;rdquo;, or &amp;ldquo;0x&amp;rdquo; (or their upper-case variants) to denote a binary, octal, or hexadecimal integer, respectively. The divisor may not be signed. If a floating-point number is provided, it may be in decimal form or use any of the same prefixes as above but for &amp;ldquo;0&amp;rdquo; to denote a non-decimal mantissa. A leading &amp;ldquo;0&amp;rdquo; is considered a decimal leading 0; it does not indicate octal representation in this case. An optional base-10 &amp;ldquo;e&amp;rdquo; or base-2 &amp;ldquo;p&amp;rdquo; (or their upper-case variants) exponent may be provided as well, except for hexadecimal floats which only accept an (optional) &amp;ldquo;p&amp;rdquo; exponent (because an &amp;ldquo;e&amp;rdquo; or &amp;ldquo;E&amp;rdquo; cannot be distinguished from a mantissa digit). The entire string, not just a prefix, must be valid for success. If the operation failed, the value of z is undefined but the returned value is nil.</source>
          <target state="translated">SetString은 z를 s 값으로 설정하고 z와 성공을 나타내는 부울을 리턴합니다. s는 (아마 부호있는) 분수 &quot;a / b&quot;로, 또는 선택적으로 지수 다음에 오는 부동 소수점 숫자로 제공 될 수 있습니다. 분수가 제공되는 경우, 피제수와 제수는 모두 10 진수 정수이거나 &quot;0b&quot;, &quot;0&quot;또는 &quot;0o&quot;또는 &quot;0x&quot;(또는 대문자 변형)의 접두사를 독립적으로 사용하여 이진수, 8 진수 또는 16 진수 정수입니다. 제수는 서명 할 수 없습니다. 부동 소수점 숫자가 제공되면 10 진수 형식이거나 위와 동일한 접두어를 사용할 수 있지만 &quot;0&quot;은 10 진수가 아닌 가수를 나타냅니다. 선행 &quot;0&quot;은 10 진 선행 0으로 간주됩니다. 이 경우 8 진수 표현을 나타내지 않습니다. 선택적인 base-10 &quot;e&quot;또는 base-2 &quot;p&quot;(또는 대문자 변형) 지수도 제공 될 수 있습니다.(선택적) &quot;p&quot;지수 만 허용하는 16 진 부동 소수점을 제외하고 ( &quot;e&quot;또는 &quot;E&quot;는 가수 자리와 구별 할 수 없기 때문에). 접두사뿐만 아니라 전체 문자열이 성공하려면 유효해야합니다. 조작이 실패한 경우 z 값은 정의되지 않지만 리턴 값은 nil입니다.</target>
        </trans-unit>
        <trans-unit id="efbb232582df792d37509713c9b27b267d546a58" translate="yes" xml:space="preserve">
          <source>SetString sets z to the value of s and returns z and a boolean indicating success. s must be a floating-point number of the same format as accepted by Parse, with base argument 0. The entire string (not just a prefix) must be valid for success. If the operation failed, the value of z is undefined but the returned value is nil.</source>
          <target state="translated">SetString은 z를 s 값으로 설정하고 z와 성공을 나타내는 부울을 리턴합니다. s는 기본 인수 0을 사용하여 Parse에 허용 된 형식과 동일한 형식의 부동 소수점 숫자 여야합니다. 접두사뿐만 아니라 전체 문자열은 성공을 위해 유효해야합니다. 조작이 실패한 경우 z 값은 정의되지 않지만 리턴 값은 nil입니다.</target>
        </trans-unit>
        <trans-unit id="63e18202e9d9aea4fa241b783984e3dc354de835" translate="yes" xml:space="preserve">
          <source>SetString sets z to the value of s, interpreted in the given base, and returns z and a boolean indicating success. The entire string (not just a prefix) must be valid for success. If SetString fails, the value of z is undefined but the returned value is nil.</source>
          <target state="translated">SetString은 z를 주어진 밑에서 해석되는 s의 값으로 설정하고 z와 성공을 나타내는 부울을 리턴합니다. 접두사뿐만 아니라 전체 문자열이 성공하려면 유효해야합니다. SetString이 실패하면 z 값은 정의되지 않지만 리턴 값은 nil입니다.</target>
        </trans-unit>
        <trans-unit id="38dbbaefe7e4a783f76cb46c7ca92c9417de8b66" translate="yes" xml:space="preserve">
          <source>SetTraceback sets the amount of detail printed by the runtime in the traceback it prints before exiting due to an unrecovered panic or an internal runtime error. The level argument takes the same values as the GOTRACEBACK environment variable. For example, SetTraceback(&quot;all&quot;) ensure that the program prints all goroutines when it crashes. See the package runtime documentation for details. If SetTraceback is called with a level lower than that of the environment variable, the call is ignored.</source>
          <target state="translated">SetTraceback은 복구되지 않은 패닉이나 내부 런타임 오류로 인해 종료하기 전에 인쇄하는 트레이스 백에서 런타임에 의해 인쇄되는 세부 정보의 양을 설정합니다. level 인수는 GOTRACEBACK 환경 변수와 동일한 값을 갖습니다. 예를 들어, SetTraceback ( &quot;all&quot;)은 프로그램이 충돌 할 때 모든 고 루틴을 인쇄하도록합니다. 자세한 내용은 패키지 런타임 설명서를 참조하십시오. SetTraceback이 환경 변수보다 낮은 수준으로 호출되면 호출이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="2fefbf475ce2643229d0cfdbfe83dace76ec0745" translate="yes" xml:space="preserve">
          <source>SetTree sets the parent tree for the node. NewIdentifier is a public method so we can't modify its signature. Chained for convenience. TODO: fix one day?</source>
          <target state="translated">SetTree는 노드의 부모 트리를 설정합니다. NewIdentifier는 공개 메소드이므로 서명을 수정할 수 없습니다. 편의를 위해 연결되었습니다. TODO : 언젠가 고쳐?</target>
        </trans-unit>
        <trans-unit id="c67115f13df235c71277ca4e4cc4cdf9edef929f" translate="yes" xml:space="preserve">
          <source>SetUint sets v's underlying value to x. It panics if v's Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64, or if CanSet() is false.</source>
          <target state="translated">SetUint는 v의 기본 값을 x로 설정합니다. v의 Kind가 Uint, Uintptr, Uint8, Uint16, Uint32 또는 Uint64가 아니거나 CanSet ()이 false 인 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a0d44c574be3e0563cede63a8860a8c3c9c0ea08" translate="yes" xml:space="preserve">
          <source>SetUint64 sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to 64 (and rounding will have no effect).</source>
          <target state="translated">SetUint64는 z를 x의 (둥근 반올림) 값으로 설정하고 z를 반환합니다. z의 정밀도가 0이면 64로 변경되며 반올림은 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0241edc0d224ec2868d9f80a9b9550102e93ffe8" translate="yes" xml:space="preserve">
          <source>SetUint64 sets z to x and returns z.</source>
          <target state="translated">SetUint64는 z를 x로 설정하고 z를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d938745882d5a8df95a9972a3a9bbbee174d3301" translate="yes" xml:space="preserve">
          <source>SetUnderlying sets the underlying type and marks t as complete.</source>
          <target state="translated">SetUnderlying은 기본 유형을 설정하고 t를 완료로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="6743e47079d741cfccfdce2738e02e6efcdc6dc1" translate="yes" xml:space="preserve">
          <source>SetUnlinkOnClose sets whether the underlying socket file should be removed from the file system when the listener is closed.</source>
          <target state="translated">SetUnlinkOnClose는 리스너가 닫힐 때 기본 소켓 파일을 파일 시스템에서 제거해야하는지 여부를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="3a7d70c082a7c060c7f1583bead1a8cb995d2129" translate="yes" xml:space="preserve">
          <source>SetWriteBuffer sets the size of the operating system's transmit buffer associated with the connection.</source>
          <target state="translated">SetWriteBuffer는 연결과 관련된 운영 체제의 전송 버퍼 크기를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="ce72366b97c1e87523bdc3b4986d2a5ed5efea78" translate="yes" xml:space="preserve">
          <source>SetWriteDeadline implements the Conn SetWriteDeadline method.</source>
          <target state="translated">SetWriteDeadline은 Conn SetWriteDeadline 메소드를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="94da0323d7e4b44c2641176fd8ed70132d7e560c" translate="yes" xml:space="preserve">
          <source>SetWriteDeadline sets the deadline for any future Write calls and any currently-blocked Write call. Even if Write times out, it may return n &amp;gt; 0, indicating that some of the data was successfully written. A zero value for t means Write will not time out. Not all files support setting deadlines; see SetDeadline.</source>
          <target state="translated">SetWriteDeadline은 향후 쓰기 호출 및 현재 차단 된 쓰기 호출에 대한 최종 기한을 설정합니다. 쓰기 시간이 초과 되더라도 일부 데이터가 성공적으로 작성되었음을 나타내는 n&amp;gt; 0을 반환 할 수 있습니다. t의 값이 0이면 쓰기 시간이 초과되지 않음을 의미합니다. 모든 파일이 마감일 설정을 지원하지는 않습니다. SetDeadline을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e383d386b9651b389cbae33232566bb47ae2af13" translate="yes" xml:space="preserve">
          <source>SetWriteDeadline sets the write deadline on the underlying connection. A zero value for t means Write will not time out. After a Write has timed out, the TLS state is corrupt and all future writes will return the same error.</source>
          <target state="translated">SetWriteDeadline은 기본 연결에서 쓰기 기한을 설정합니다. t의 값이 0이면 쓰기 시간이 초과되지 않음을 의미합니다. 쓰기 시간이 초과되면 TLS 상태가 손상되고 이후의 모든 쓰기에서 동일한 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="308be1977132bdbc81c0f89a2767dd32da76c702" translate="yes" xml:space="preserve">
          <source>Setenv sets the value of the environment variable named by the key. It returns an error, if any.</source>
          <target state="translated">Setenv는 키로 명명 된 환경 변수의 값을 설정합니다. 오류가있는 경우 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="509f2c6d0467d5d83c9526f638c505af46797567" translate="yes" xml:space="preserve">
          <source>Setters, numeric operations and predicates are represented as methods of the form:</source>
          <target state="translated">세터, 숫자 연산 및 술어는 다음 형식의 메소드로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="8b84f9f04ca185b4b399c76c8fc7c01ef4f564e3" translate="yes" xml:space="preserve">
          <source>Shift returns the result of the shift expression x op s with op == token.SHL or token.SHR (&amp;lt;&amp;lt; or &amp;gt;&amp;gt;). x must be an Int or an Unknown. If x is Unknown, the result is x.</source>
          <target state="translated">Shift는 op == token.SHL 또는 token.SHR (&amp;lt;&amp;lt; 또는 &amp;gt;&amp;gt;)을 사용하여 시프트 표현식 x op s의 결과를 리턴합니다. x는 Int 또는 Unknown이어야합니다. x가 알 수없는 경우 결과는 x입니다.</target>
        </trans-unit>
        <trans-unit id="fde43f2305da307b56958af17198c21e47808653" translate="yes" xml:space="preserve">
          <source>Short reports whether the -test.short flag is set.</source>
          <target state="translated">Short는 -test.short 플래그가 설정되어 있는지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="5b772b7bfd0a43273fb7c5f49a6c16d837261f35" translate="yes" xml:space="preserve">
          <source>Shuffle</source>
          <target state="translated">Shuffle</target>
        </trans-unit>
        <trans-unit id="79a2c163367d393e517ed372229f5d310534a9d9" translate="yes" xml:space="preserve">
          <source>Shuffle (SlicesInUnison)</source>
          <target state="translated">셔플 (SlicesInUnison)</target>
        </trans-unit>
        <trans-unit id="732d9d1b7fa9ce160a254c0eec34ec29c54e1b79" translate="yes" xml:space="preserve">
          <source>Shuffle pseudo-randomizes the order of elements using the default Source. n is the number of elements. Shuffle panics if n &amp;lt; 0. swap swaps the elements with indexes i and j.</source>
          <target state="translated">의사 셔플은 기본 소스를 사용하여 요소의 순서를 무작위로 지정합니다. n은 요소 수입니다. n &amp;lt;0 인 경우 패닉 셔플. 스왑은 요소를 인덱스 i 및 j로 교체합니다.</target>
        </trans-unit>
        <trans-unit id="6d3cd15e0fd6a7a5b1756b9af5c51872006c475b" translate="yes" xml:space="preserve">
          <source>Shuffle pseudo-randomizes the order of elements. n is the number of elements. Shuffle panics if n &amp;lt; 0. swap swaps the elements with indexes i and j.</source>
          <target state="translated">의사 셔플은 요소의 순서를 무작위로 지정합니다. n은 요소 수입니다. n &amp;lt;0 인 경우 패닉 셔플. 스왑은 요소를 인덱스 i 및 j로 교체합니다.</target>
        </trans-unit>
        <trans-unit id="8e0c7b7cdf248102d52e5f44dcd474d4d82c359e" translate="yes" xml:space="preserve">
          <source>Shutdown does not attempt to close nor wait for hijacked connections such as WebSockets. The caller of Shutdown should separately notify such long-lived connections of shutdown and wait for them to close, if desired. See RegisterOnShutdown for a way to register shutdown notification functions.</source>
          <target state="translated">종료는 WebSockets와 같은 하이재킹 된 연결을 닫거나 기다리지 않습니다. 종료 호출자는 이러한 오래 지속 된 연결 종료를 별도로 알리고 원하는 경우 종료 될 때까지 기다려야합니다. 종료 알림 기능을 등록하는 방법은 RegisterOnShutdown을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="38dcf86ad76a9ad474561d4239201b3f812c81b9" translate="yes" xml:space="preserve">
          <source>Shutdown gracefully shuts down the server without interrupting any active connections. Shutdown works by first closing all open listeners, then closing all idle connections, and then waiting indefinitely for connections to return to idle and then shut down. If the provided context expires before the shutdown is complete, Shutdown returns the context's error, otherwise it returns any error returned from closing the Server's underlying Listener(s).</source>
          <target state="translated">종료는 활성 연결을 방해하지 않고 서버를 정상적으로 종료합니다. 종료는 먼저 열려있는 모든 리스너를 닫은 다음 모든 유휴 연결을 닫은 다음 연결이 유휴 상태로 돌아간 다음 무기한으로 종료 될 때까지 작동합니다. 종료가 완료되기 전에 제공된 컨텍스트가 만료되면 Shutdown은 컨텍스트의 오류를 반환하고, 그렇지 않으면 서버의 기본 리스너를 닫으면 반환 된 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8b3d8d665a765918b70a3f5f0378d51df00b92dd" translate="yes" xml:space="preserve">
          <source>Sign</source>
          <target state="translated">Sign</target>
        </trans-unit>
        <trans-unit id="4dc2181e93ae969f803429357fe579abd176b4b4" translate="yes" xml:space="preserve">
          <source>Sign returns -1, 0, or 1 depending on whether x &amp;lt; 0, x == 0, or x &amp;gt; 0; x must be numeric or Unknown. For complex values x, the sign is 0 if x == 0, otherwise it is != 0. If x is Unknown, the result is 1.</source>
          <target state="translated">부호는 x &amp;lt;0, x == 0 또는 x&amp;gt; 0에 따라 -1, 0 또는 1을 반환합니다. x는 숫자이거나 알 수없는 것이어야합니다. 복소수 값 x의 경우 x == 0이면 부호가 0이고 그렇지 않으면! = 0입니다. x가 알 수없는 경우 결과는 1입니다.</target>
        </trans-unit>
        <trans-unit id="b52aac6f1207124113d4a678eb49a1b5cf712f7a" translate="yes" xml:space="preserve">
          <source>Sign returns:</source>
          <target state="translated">부호 반환 :</target>
        </trans-unit>
        <trans-unit id="6589591f2f20ffb39adee81e8ba10edbe7dacc2e" translate="yes" xml:space="preserve">
          <source>Sign signs a hash (which should be the result of hashing a larger message) using the private key, priv. If the hash is longer than the bit-length of the private key's curve order, the hash will be truncated to that length. It returns the signature as a pair of integers. The security of the private key depends on the entropy of rand.</source>
          <target state="translated">Sign은 개인 키 priv를 사용하여 해시 (더 큰 메시지를 해시 한 결과 여야 함)에 서명합니다. 해시가 개인 키 곡선 순서의 비트 길이보다 길면 해시가 해당 길이로 잘립니다. 서명을 정수 쌍으로 리턴합니다. 개인 키의 보안은 랜드의 엔트로피에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="311212195f2e7e53bfbdc1974b3a767400f6e3ff" translate="yes" xml:space="preserve">
          <source>Sign signs an arbitrary length hash (which should be the result of hashing a larger message) using the private key, priv. It returns the signature as a pair of integers. The security of the private key depends on the entropy of rand.</source>
          <target state="translated">부호는 개인 키 priv를 사용하여 임의 길이의 해시 (더 큰 메시지를 해시 한 결과 여야 함)에 서명합니다. 서명을 정수 쌍으로 리턴합니다. 개인 키의 보안은 랜드의 엔트로피에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="c12807935684d6d5a767b5418d3f2f1d36802c6e" translate="yes" xml:space="preserve">
          <source>Sign signs digest with priv, reading randomness from rand. If opts is a *PSSOptions then the PSS algorithm will be used, otherwise PKCS #1 v1.5 will be used. digest must be the result of hashing the input message using opts.HashFunc().</source>
          <target state="translated">Sign sign은 priv로 다이제스트되어 rand에서 임의성을 읽습니다. opts가 * PSSOptions이면 PSS 알고리즘이 사용되며, 그렇지 않으면 PKCS # 1 v1.5가 사용됩니다. digest는 opts.HashFunc ()를 사용하여 입력 메시지를 해싱 한 결과 여야합니다.</target>
        </trans-unit>
        <trans-unit id="cd714756dfd32673e7a5fdf4e7a7d3f4c1f0476c" translate="yes" xml:space="preserve">
          <source>Sign signs digest with priv, reading randomness from rand. If opts is a *PSSOptions then the PSS algorithm will be used, otherwise PKCS#1 v1.5 will be used.</source>
          <target state="translated">기호 표시는 priv에서 무작위로 읽으며 랜드에서 임의성을 읽습니다. opts가 * PSSOptions이면 PSS 알고리즘이 사용되며, 그렇지 않으면 PKCS # 1 v1.5가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="725a324c83bff5484063c9fb79ed06b1a642a7c9" translate="yes" xml:space="preserve">
          <source>Sign signs digest with priv, reading randomness from rand. The opts argument is not currently used but, in keeping with the crypto.Signer interface, should be the hash function used to digest the message.</source>
          <target state="translated">기호 표시는 priv에서 무작위로 읽으며 랜드에서 임의성을 읽습니다. opts 인수는 현재 사용되지 않지만 crypto.Signer 인터페이스와 함께 메시지를 요약하는 데 사용되는 해시 함수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="cb5cc6baa9959aae2928064eeabac37026d1fdd3" translate="yes" xml:space="preserve">
          <source>Sign signs the given message with priv. Ed25519 performs two passes over messages to be signed and therefore cannot handle pre-hashed messages. Thus opts.HashFunc() must return zero to indicate the message hasn't been hashed. This can be achieved by passing crypto.Hash(0) as the value for opts.</source>
          <target state="translated">Sign은 주어진 메시지를 priv에 서명합니다. Ed25519는 서명 할 메시지를 두 번 전달하므로 미리 해시 된 메시지를 처리 ​​할 수 ​​없습니다. 따라서 opts.HashFunc ()는 메시지가 해시되지 않았 음을 나타 내기 위해 0을 반환해야합니다. 이것은 opts의 값으로 crypto.Hash (0)을 전달하여 달성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d9bc9097d624689f3abd051873c0827e390ddd8" translate="yes" xml:space="preserve">
          <source>Sign signs the message with privateKey and returns a signature. It will panic if len(privateKey) is not PrivateKeySize.</source>
          <target state="translated">서명은 메시지를 privateKey로 서명하고 서명을 리턴합니다. len (privateKey)가 PrivateKeySize가 아닌 경우 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="374ef04419fa455579e2922ef305611877eeff57" translate="yes" xml:space="preserve">
          <source>SignASN1 signs a hash (which should be the result of hashing a larger message) using the private key, priv. If the hash is longer than the bit-length of the private key's curve order, the hash will be truncated to that length. It returns the ASN.1 encoded signature. The security of the private key depends on the entropy of rand.</source>
          <target state="translated">SignASN1은 개인 키 priv를 사용하여 해시 (더 큰 메시지를 해싱 한 결과 여야 함)에 서명합니다. 해시가 개인 키 곡선 순서의 비트 길이보다 길면 해시가 해당 길이로 잘립니다. ASN.1 인코딩 된 서명을 반환합니다. 개인 키의 보안은 rand의 엔트로피에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="73058d5661f51255d2d044bad5e22d1dbeb1615f" translate="yes" xml:space="preserve">
          <source>SignPKCS1v15</source>
          <target state="translated">SignPKCS1v15</target>
        </trans-unit>
        <trans-unit id="c0fa762cfc4f83cc1ae6eb824e2e7d2490239baf" translate="yes" xml:space="preserve">
          <source>SignPKCS1v15 calculates the signature of hashed using RSASSA-PKCS1-V1_5-SIGN from RSA PKCS #1 v1.5. Note that hashed must be the result of hashing the input message using the given hash function. If hash is zero, hashed is signed directly. This isn't advisable except for interoperability.</source>
          <target state="translated">SignPKCS1v15는 RSA PKCS # 1 v1.5에서 RSASSA-PKCS1-V1_5-SIGN을 사용하여 해시 된 서명을 계산합니다. hashed는 주어진 해시 함수를 사용하여 입력 메시지를 해싱 한 결과 여야합니다. hash가 0이면 hashed가 직접 서명됩니다. 이것은 상호 운용성을 제외하고는 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="76a7f1a903c9bd79d05146e331e0afbf510916e4" translate="yes" xml:space="preserve">
          <source>SignPKCS1v15 calculates the signature of hashed using RSASSA-PKCS1-V1_5-SIGN from RSA PKCS#1 v1.5. Note that hashed must be the result of hashing the input message using the given hash function. If hash is zero, hashed is signed directly. This isn't advisable except for interoperability.</source>
          <target state="translated">SignPKCS1v15는 RSA PKCS # 1 v1.5의 RSASSA-PKCS1-V1_5-SIGN을 사용하여 해시 된 서명을 계산합니다. 해시는 주어진 해시 함수를 사용하여 입력 메시지를 해시 한 결과 여야합니다. 해시가 0이면 해시가 직접 서명됩니다. 상호 운용성을 제외하고는 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a8dc8c6fdf07694c004d0ad09c1805b1db05045f" translate="yes" xml:space="preserve">
          <source>SignPSS calculates the signature of digest using PSS.</source>
          <target state="translated">SignPSS는 PSS를 사용하여 다이제스트의 서명을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="4dc02ffb85c827150cad191cf75b74252c850c11" translate="yes" xml:space="preserve">
          <source>SignPSS calculates the signature of hashed using RSASSA-PSS [1]. Note that hashed must be the result of hashing the input message using the given hash function. The opts argument may be nil, in which case sensible defaults are used.</source>
          <target state="translated">SignPSS는 RSASSA-PSS [1]을 사용하여 해시 된 서명을 계산합니다. 해시는 주어진 해시 함수를 사용하여 입력 메시지를 해시 한 결과 여야합니다. opts 인수는 nil 일 수 있으며이 경우 적절한 기본값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="456ecb37c3fc5855213ab977448f009637d487e9" translate="yes" xml:space="preserve">
          <source>Signal sends a signal to the Process. Sending Interrupt on Windows is not implemented.</source>
          <target state="translated">신호는 프로세스로 신호를 보냅니다. Windows에서 전송 인터럽트가 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="113054b65e3d478c55ce8ee9e7136eef91adbb6a" translate="yes" xml:space="preserve">
          <source>Signal wakes one goroutine waiting on c, if there is any.</source>
          <target state="translated">신호가 있으면 c에서 하나의 고 루틴이 대기합니다.</target>
        </trans-unit>
        <trans-unit id="2346a18ea3002ff04eca3a130c7f40e65c56f0c9" translate="yes" xml:space="preserve">
          <source>Signals</source>
          <target state="translated">Signals</target>
        </trans-unit>
        <trans-unit id="9a761dffcc7f2df5b531ae01c6e9c1d10354c3aa" translate="yes" xml:space="preserve">
          <source>Signals are primarily used on Unix-like systems. For the use of this package on Windows and Plan 9, see below.</source>
          <target state="translated">신호는 주로 유닉스 계열 시스템에서 사용됩니다. Windows 및 Plan 9에서이 패키지를 사용하려면 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="be08fe4d5181cd9a339446858cf8e98d5d370ad9" translate="yes" xml:space="preserve">
          <source>SignatureScheme identifies a signature algorithm supported by TLS. See RFC 8446, Section 4.2.3.</source>
          <target state="translated">SignatureScheme은 TLS가 지원하는 서명 알고리즘을 식별합니다. RFC 8446, 섹션 4.2.3을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="72364e765319ca6184606bdfcbeaf4bae3efe083" translate="yes" xml:space="preserve">
          <source>Signbit reports whether x is negative or negative zero.</source>
          <target state="translated">Signbit은 x가 음수인지 음수인지를보고합니다.</target>
        </trans-unit>
        <trans-unit id="06f0622cc55ee3b1ba8ef5291dd67f388a633bbf" translate="yes" xml:space="preserve">
          <source>Signed integers may be received into any signed integer variable: int, int16, etc.; unsigned integers may be received into any unsigned integer variable; and floating point values may be received into any floating point variable. However, the destination variable must be able to represent the value or the decode operation will fail.</source>
          <target state="translated">부호있는 정수는 부호있는 정수 변수 int, int16 등으로 수신 될 수 있습니다. 부호없는 정수는 부호없는 정수 변수로 수신 될 수 있습니다. 부동 소수점 값은 임의의 부동 소수점 변수로 수신 될 수있다. 그러나 대상 변수는 값을 나타낼 수 있어야합니다. 그렇지 않으면 디코딩 작업이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="ae900b849a1bf306b492bb9034be4bb3bc19b163" translate="yes" xml:space="preserve">
          <source>Signer is an interface for an opaque private key that can be used for signing operations. For example, an RSA key kept in a hardware module.</source>
          <target state="translated">서명자는 서명 작업에 사용할 수있는 불투명 개인 키에 대한 인터페이스입니다. 예를 들어 RSA 키는 하드웨어 모듈에 보관됩니다.</target>
        </trans-unit>
        <trans-unit id="38f4531ed194c331b7b23a6d3502ef6906c2f74a" translate="yes" xml:space="preserve">
          <source>SignerOpts contains options for signing with a Signer.</source>
          <target state="translated">서명자 옵션에는 서명자와 서명하는 옵션이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8332f3ce4c218d0bde5211f46f41f270a3be8e0c" translate="yes" xml:space="preserve">
          <source>Similarly to attributes with namespaces, attributes with a &quot;data-&quot; prefix are treated as if they had no &quot;data-&quot; prefix. So given</source>
          <target state="translated">네임 스페이스가있는 속성과 유사하게 &quot;data-&quot;접두사가있는 속성은 &quot;data-&quot;접두사가없는 것처럼 처리됩니다. 그래서 주어진</target>
        </trans-unit>
        <trans-unit id="966d50452c96c3fa11f316a011f44cf776d22a17" translate="yes" xml:space="preserve">
          <source>SimpleFold</source>
          <target state="translated">SimpleFold</target>
        </trans-unit>
        <trans-unit id="8bf97e6e8efa121264307227008493331dea504d" translate="yes" xml:space="preserve">
          <source>SimpleFold iterates over Unicode code points equivalent under the Unicode-defined simple case folding. Among the code points equivalent to rune (including rune itself), SimpleFold returns the smallest rune &amp;gt; r if one exists, or else the smallest rune &amp;gt;= 0. If r is not a valid Unicode code point, SimpleFold(r) returns r.</source>
          <target state="translated">SimpleFold는 유니 코드로 정의 된 간단한 대소 문자 접음에서 동등한 유니 코드 코드 포인트를 반복합니다. 룬 (루프 자체 포함)과 동등한 코드 포인트 중에서 SimpleFold는 가장 작은 룬&amp;gt; r (있는 경우) 또는 가장 작은 룬&amp;gt; = 0을 반환합니다. r이 유효한 유니 코드 코드 포인트가 아닌 경우 SimpleFold (r)는 r을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b27adf68197f928a987f44243ba3dcfcda229444" translate="yes" xml:space="preserve">
          <source>Simplify returns a regexp equivalent to re but without counted repetitions and with various other simplifications, such as rewriting /(?:a+)+/ to /a+/. The resulting regexp will execute correctly but its string representation will not produce the same parse tree, because capturing parentheses may have been duplicated or removed. For example, the simplified form for /(x){1,2}/ is /(x)(x)?/ but both parentheses capture as $1. The returned regexp may share structure with or be the original.</source>
          <target state="translated">Simplify는 반복 횟수는 제외하고 / (?: a +) + /를 / a + /로 다시 쓰는 것과 같은 다양한 다른 단순화없이 정규식을 반환합니다. 결과 정규 표현식은 올바르게 실행되지만 캡처 괄호가 복제되거나 제거되었을 수 있으므로 문자열 표현은 동일한 구문 분석 트리를 생성하지 않습니다. 예를 들어, / (x) {1,2} /의 단순화 된 형식은 / (x) (x)? /이지만 두 괄호는 $ 1로 캡처됩니다. 반환 된 정규 표현식은 구조를 공유하거나 원본 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1baaf4288309b641acaf8ca1164546c4028a35a7" translate="yes" xml:space="preserve">
          <source>Sin</source>
          <target state="translated">Sin</target>
        </trans-unit>
        <trans-unit id="60fef841296be9ebf7de4bce978c61ea99668ac2" translate="yes" xml:space="preserve">
          <source>Sin returns the sine of the radian argument x.</source>
          <target state="translated">Sin은 라디안 인수 x의 사인을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2d7deeeba21d579c050c2a33e2db608612f16ced" translate="yes" xml:space="preserve">
          <source>Sin returns the sine of x.</source>
          <target state="translated">Sin은 x의 사인을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="28345621651842b6184cdaaa54304069ac54ba5c" translate="yes" xml:space="preserve">
          <source>Since fs.FileInfo's Name method only returns the base name of the file it describes, it may be necessary to modify Header.Name to provide the full path name of the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="032d0e9143af25fee0463a47b08e83403e61fbe1" translate="yes" xml:space="preserve">
          <source>Since os.FileInfo's Name method only returns the base name of the file it describes, it may be necessary to modify Header.Name to provide the full path name of the file.</source>
          <target state="translated">os.FileInfo의 Name 메소드는 설명하는 파일의 기본 이름 만 리턴하므로 파일의 전체 경로 이름을 제공하기 위해 Header.Name을 수정해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b67e676cda98cae04b5ce1604ab8e9db4fbb0636" translate="yes" xml:space="preserve">
          <source>Since returns the time elapsed since t. It is shorthand for time.Now().Sub(t).</source>
          <target state="translated">이후 t 이후 경과 된 시간을 리턴합니다. time.Now (). Sub (t)의 줄임말입니다.</target>
        </trans-unit>
        <trans-unit id="4aada6d4483746dcd60dcf298d86136630d9cd91" translate="yes" xml:space="preserve">
          <source>Sincos</source>
          <target state="translated">Sincos</target>
        </trans-unit>
        <trans-unit id="602eea7f1523e01bb1b745122d12becc2cb4a99c" translate="yes" xml:space="preserve">
          <source>Sincos returns Sin(x), Cos(x).</source>
          <target state="translated">Sincos는 Sin (x), Cos (x)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bc9965f20c0e26db0501d3424c1430869ed3389f" translate="yes" xml:space="preserve">
          <source>Single characters:</source>
          <target state="translated">단일 문자 :</target>
        </trans-unit>
        <trans-unit id="e5d65368cdcef8d43d81f8b1167171bcc9e4d453" translate="yes" xml:space="preserve">
          <source>Sinh</source>
          <target state="translated">Sinh</target>
        </trans-unit>
        <trans-unit id="f35b8f7d99b41bcac88dc066f89ded4a25031767" translate="yes" xml:space="preserve">
          <source>Sinh returns the hyperbolic sine of x.</source>
          <target state="translated">Sinh는 x의 쌍곡 사인을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b82e9be74971571cd41c1c21253c9f4cb1846e90" translate="yes" xml:space="preserve">
          <source>Size returns h's hash value size, 8 bytes.</source>
          <target state="translated">Size는 h의 해시 값 크기 인 8 바이트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9d9b9bb8ffbb101e667ceeb0c6df4b2d00eca63e" translate="yes" xml:space="preserve">
          <source>Size returns how many bytes Write would generate to encode the value v, which must be a fixed-size value or a slice of fixed-size values, or a pointer to such data. If v is neither of these, Size returns -1.</source>
          <target state="translated">Size는 값 v를 고정하기 위해 Write가 생성 할 바이트 수를 반환합니다. v는 고정 크기 값 또는 고정 크기 값의 슬라이스이거나 이러한 데이터에 대한 포인터 여야합니다. v가이 중 하나가 아닌 경우 Size는 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="07f99b9766acbd34a40dce6ae52199b1df82e565" translate="yes" xml:space="preserve">
          <source>Size returns r's width and height.</source>
          <target state="translated">크기는 r의 너비와 높이를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="08603885cb8f4581e6caff80c9587384030d6fb2" translate="yes" xml:space="preserve">
          <source>Size returns the length, in bytes, of a digest resulting from the given hash function. It doesn't require that the hash function in question be linked into the program.</source>
          <target state="translated">Size는 주어진 해시 함수로 인한 다이제스트의 길이를 바이트 단위로 반환합니다. 문제의 해시 함수가 프로그램에 연결될 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="e25ab5f340eca2d7c5b223c77e15ee75cde585ef" translate="yes" xml:space="preserve">
          <source>Size returns the modulus size in bytes. Raw signatures and ciphertexts for or by this public key will have the same size.</source>
          <target state="translated">크기는 계수 크기를 바이트 단위로 반환합니다. 이 공개 키에 대한 원시 서명 및 암호문의 크기는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="e670e1a5854b86fb3e790eec7802ceb4072867ce" translate="yes" xml:space="preserve">
          <source>Size returns the number of leading ones and total bits in the mask. If the mask is not in the canonical form--ones followed by zeros--then Size returns 0, 0.</source>
          <target state="translated">Size는 마스크의 선행 및 총 비트 수를 반환합니다. 마스크가 정식 형식이 아닌 경우 (0과 그 뒤에 0) Size는 0, 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e50e49a71b6948817b0c75a5802d436dcfbbd3d4" translate="yes" xml:space="preserve">
          <source>Size returns the original length of the underlying byte slice. Size is the number of bytes available for reading via ReadAt. The returned value is always the same and is not affected by calls to any other method.</source>
          <target state="translated">Size는 기본 바이트 슬라이스의 원래 길이를 반환합니다. 크기는 ReadAt를 통해 읽을 수있는 바이트 수입니다. 반환 된 값은 항상 동일하며 다른 메소드 호출에 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="20090954ae229cf40fcf85ad90018bc0a50c14a6" translate="yes" xml:space="preserve">
          <source>Size returns the original length of the underlying string. Size is the number of bytes available for reading via ReadAt. The returned value is always the same and is not affected by calls to any other method.</source>
          <target state="translated">Size는 기본 문자열의 원래 길이를 반환합니다. 크기는 ReadAt를 통해 읽을 수있는 바이트 수입니다. 반환 된 값은 항상 동일하며 다른 메소드 호출에 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5a0d609fe825a666e200f379bb9b290e727375b4" translate="yes" xml:space="preserve">
          <source>Size returns the size of file f as registered with AddFile.</source>
          <target state="translated">Size는 AddFile에 등록 된 파일 f의 크기를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5716d3e163196d9c451e87a39bff7287017defa9" translate="yes" xml:space="preserve">
          <source>Size returns the size of the section in bytes.</source>
          <target state="translated">Size는 섹션의 크기를 바이트 단위로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="33687cc2c12d65398be28bdfb49be5c9af20dea4" translate="yes" xml:space="preserve">
          <source>Size returns the size of the underlying buffer in bytes.</source>
          <target state="translated">Size는 기본 버퍼의 크기를 바이트 단위로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ad326c620cb25aa3f6f88fe50584af3756cb7137" translate="yes" xml:space="preserve">
          <source>Sizeof takes an expression x of any type and returns the size in bytes of a hypothetical variable v as if v was declared via var v = x. The size does not include any memory possibly referenced by x. For instance, if x is a slice, Sizeof returns the size of the slice descriptor, not the size of the memory referenced by the slice. The return value of Sizeof is a Go constant.</source>
          <target state="translated">Sizeof는 모든 유형의 표현식 x를 취하고 마치 v가 var v = x를 통해 선언 된 것처럼 가상 변수 v의 크기를 바이트 단위로 반환합니다. 크기는 x가 참조 할 수있는 메모리를 포함하지 않습니다. 예를 들어, x가 슬라이스 인 경우 Sizeof는 슬라이스가 참조하는 메모리의 크기가 아니라 슬라이스 디스크립터의 크기를 반환합니다. Sizeof의 반환 값은 Go 상수입니다.</target>
        </trans-unit>
        <trans-unit id="b19905df7d36355c364fc4d465be7029063705c6" translate="yes" xml:space="preserve">
          <source>Sizes defines the sizing functions for package unsafe.</source>
          <target state="translated">크기는 안전하지 않은 패키지의 크기 조정 기능을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="58588dd4d69fcc2bebbb32cb3311a65197ef6d80" translate="yes" xml:space="preserve">
          <source>SizesFor returns the Sizes used by a compiler for an architecture. The result is nil if a compiler/architecture pair is not known.</source>
          <target state="translated">SizesFor는 아키텍처에서 컴파일러가 사용한 크기를 반환합니다. 컴파일러 / 아키텍처 쌍을 알 수없는 경우 결과는 0입니다.</target>
        </trans-unit>
        <trans-unit id="f2bf90f6b1f23cb7aca2de8f99806d297f79d8f6" translate="yes" xml:space="preserve">
          <source>Skip is equivalent to Log followed by SkipNow.</source>
          <target state="translated">건너 뛰기는 Log 다음에 SkipNow와 같습니다.</target>
        </trans-unit>
        <trans-unit id="16403f951a4dfc8a1c243a0f8eb301e145aaacf2" translate="yes" xml:space="preserve">
          <source>Skip reads tokens until it has consumed the end element matching the most recent start element already consumed. It recurs if it encounters a start element, so it can be used to skip nested structures. It returns nil if it finds an end element matching the start element; otherwise it returns an error describing the problem.</source>
          <target state="translated">Skip은 이미 사용한 가장 최근의 시작 요소와 일치하는 끝 요소를 사용할 때까지 토큰을 읽습니다. 시작 요소가 발견되면 반복되므로 중첩 구조를 건너 뛰는 데 사용할 수 있습니다. 시작 요소와 일치하는 끝 요소를 찾으면 nil을 리턴합니다. 그렇지 않으면 문제를 설명하는 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="70514769bf0cf43aa1fd9a8170e861cfc268114d" translate="yes" xml:space="preserve">
          <source>SkipChildren skips over the child entries associated with the last Entry returned by Next. If that Entry did not have children or Next has not been called, SkipChildren is a no-op.</source>
          <target state="translated">SkipChildren은 Next에서 반환 한 마지막 항목과 관련된 하위 항목을 건너 뜁니다. 해당 항목에 자식이 없거나 다음이 호출되지 않은 경우 SkipChildren은 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="63887303b3af72b8bc68b80e2e2f371343498eae" translate="yes" xml:space="preserve">
          <source>SkipDir is used as a return value from WalkDirFuncs to indicate that the directory named in the call is to be skipped. It is not returned as an error by any function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="306f2cf9cd44bb1158534a5fe5beb03317afa4af" translate="yes" xml:space="preserve">
          <source>SkipDir is used as a return value from WalkFuncs to indicate that the directory named in the call is to be skipped. It is not returned as an error by any function.</source>
          <target state="translated">SkipDir은 WalkFuncs의 반환 값으로 사용되어 호출에 이름이 지정된 디렉토리를 건너 뛸 것임을 나타냅니다. 어떤 함수에서도 오류로 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a9f977172633094ba7da3e08af3ab05c0c517aa4" translate="yes" xml:space="preserve">
          <source>SkipNow marks the test as having been skipped and stops its execution by calling runtime.Goexit. If a test fails (see Error, Errorf, Fail) and is then skipped, it is still considered to have failed. Execution will continue at the next test or benchmark. See also FailNow. SkipNow must be called from the goroutine running the test, not from other goroutines created during the test. Calling SkipNow does not stop those other goroutines.</source>
          <target state="translated">SkipNow는 테스트를 건너 뛴 것으로 표시하고 runtime.Goexit를 호출하여 실행을 중지합니다. 테스트가 실패하고 (오류, 오류, 실패 참조) 건너 뛴 경우 여전히 실패한 것으로 간주됩니다. 다음 테스트 또는 벤치 마크에서 실행이 계속됩니다. FailNow를 참조하십시오. SkipNow는 테스트 중에 생성 된 다른 고 루틴이 아니라 테스트를 실행하는 고 루틴에서 호출해야합니다. SkipNow를 호출해도 다른 고 루틴은 멈추지 않습니다.</target>
        </trans-unit>
        <trans-unit id="332b0733aeb219d3842af5da1737b4332e8bb58a" translate="yes" xml:space="preserve">
          <source>Skipf is equivalent to Logf followed by SkipNow.</source>
          <target state="translated">Skipf는 Logf 다음에 SkipNow와 같습니다.</target>
        </trans-unit>
        <trans-unit id="416b07f26916aed7cb9e2ecd9aa8ab976885e47e" translate="yes" xml:space="preserve">
          <source>Skipped reports whether the test was skipped.</source>
          <target state="translated">생략은 테스트를 생략했는지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="22c22c92516b167e48a8850862fd9d43b049ad6a" translate="yes" xml:space="preserve">
          <source>Skipping</source>
          <target state="translated">Skipping</target>
        </trans-unit>
        <trans-unit id="3cac34e674464c2b62286054cd9a2d2c81149efc" translate="yes" xml:space="preserve">
          <source>Sleep</source>
          <target state="translated">Sleep</target>
        </trans-unit>
        <trans-unit id="53bb6e499b626b0d907f8d7f80059af55f685b40" translate="yes" xml:space="preserve">
          <source>Sleep pauses the current goroutine for at least the duration d. A negative or zero duration causes Sleep to return immediately.</source>
          <target state="translated">휴면은 최소 지속 시간 동안 현재 고 루틴을 일시 중지합니다 d. 기간이 음수이거나 0이면 절전 모드가 즉시 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="0c8525a31f225d6db84222cdc68f43cb8c6c18bf" translate="yes" xml:space="preserve">
          <source>Slice</source>
          <target state="translated">Slice</target>
        </trans-unit>
        <trans-unit id="4972372ab292852581dde17e7410c1a0a34536d2" translate="yes" xml:space="preserve">
          <source>Slice returns v[i:j]. It panics if v's Kind is not Array, Slice or String, or if v is an unaddressable array, or if the indexes are out of bounds.</source>
          <target state="translated">슬라이스는 v [i : j]를 반환합니다. v의 종류가 배열, 슬라이스 또는 문자열이 아니거나 v가 주소를 지정할 수없는 배열이거나 인덱스가 범위를 벗어난 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f664f65e07ee83c0603b67c75f98aa98e653bee6" translate="yes" xml:space="preserve">
          <source>Slice sorts the provided slice given the provided less function.</source>
          <target state="translated">슬라이스는 제공된 축소 기능을 제공하여 제공된 슬라이스를 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="b4cfb20fd7104c06dc3a2b04b6a07b65db14a375" translate="yes" xml:space="preserve">
          <source>Slice sorts the slice x given the provided less function. It panics if x is not a slice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9c2b1fb38f90f114fb07f736146472316c1fd01" translate="yes" xml:space="preserve">
          <source>Slice values are deeply equal when all of the following are true: they are both nil or both non-nil, they have the same length, and either they point to the same initial entry of the same underlying array (that is, &amp;amp;x[0] == &amp;amp;y[0]) or their corresponding elements (up to length) are deeply equal. Note that a non-nil empty slice and a nil slice (for example, []byte{} and []byte(nil)) are not deeply equal.</source>
          <target state="translated">다음 값이 모두 참이면 슬라이스 값이 완전히 동일합니다.이 값은 모두 0이거나 0이 아닌 값이며 모두 같은 길이이며 동일한 기본 배열의 동일한 초기 항목을 가리 킵니다 (즉, &amp;amp; x [0 ] == &amp;amp; y [0]) 또는 해당 요소 (최대 길이)는 매우 같습니다. 0이 아닌 빈 슬라이스와 0이 아닌 슬라이스 (예 : [] byte {} 및 [] byte (nil))는 서로 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="187ce922ba02cf6f5feb1dc1495c357805a44a28" translate="yes" xml:space="preserve">
          <source>Slice3 is the 3-index form of the slice operation: it returns v[i:j:k]. It panics if v's Kind is not Array or Slice, or if v is an unaddressable array, or if the indexes are out of bounds.</source>
          <target state="translated">Slice3은 슬라이스 작업의 3 가지 인덱스 형식으로 v [i : j : k]를 반환합니다. v의 Kind가 배열 또는 슬라이스가 아니거나 v가 주소를 지정할 수없는 배열이거나 인덱스가 범위를 벗어난 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="036571bfad79ab866cb35b30d706649dfea91e3e" translate="yes" xml:space="preserve">
          <source>Slice:</source>
          <target state="translated">Slice:</target>
        </trans-unit>
        <trans-unit id="0294a1ce63eca0958f1a3380376dd5b3772daeaa" translate="yes" xml:space="preserve">
          <source>SliceHeader is the runtime representation of a slice. It cannot be used safely or portably and its representation may change in a later release. Moreover, the Data field is not sufficient to guarantee the data it references will not be garbage collected, so programs must keep a separate, correctly typed pointer to the underlying data.</source>
          <target state="translated">SliceHeader는 슬라이스의 런타임 표현입니다. 안전하게 또는 이식 가능하게 사용할 수 없으며 이후 릴리스에서 표현이 변경 될 수 있습니다. 또한 데이터 필드는 참조하는 데이터가 가비지 수집되지 않도록 보장하기에 충분하지 않으므로 프로그램은 기본 데이터에 대해 올바르게 입력 된 별도의 포인터를 유지해야합니다.</target>
        </trans-unit>
        <trans-unit id="18abb4a62706648ce5d49f543c560da00acf877d" translate="yes" xml:space="preserve">
          <source>SliceIsSorted reports whether the slice x is sorted according to the provided less function. It panics if x is not a slice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c22ee253fc38582e76e1a487b795c3ec911e294a" translate="yes" xml:space="preserve">
          <source>SliceIsSorted tests whether a slice is sorted.</source>
          <target state="translated">SliceIsSorted는 슬라이스가 정렬되었는지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="45eaaaf070f6c38ebb684650d2e76ac52a7e3905" translate="yes" xml:space="preserve">
          <source>SliceOf returns the slice type with element type t. For example, if t represents int, SliceOf(t) represents []int.</source>
          <target state="translated">SliceOf는 요소 유형이 t 인 슬라이스 유형을 반환합니다. 예를 들어, t가 int를 나타내는 경우 SliceOf (t)는 [] int를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d3f5d8267a68290ad1478266ac0100b64a9ec9d9" translate="yes" xml:space="preserve">
          <source>SlicePtrFromStrings converts a slice of strings to a slice of pointers to NUL-terminated byte arrays. If any string contains a NUL byte, it returns (nil, EINVAL).</source>
          <target state="translated">SlicePtrFromStrings는 문자열 슬라이스를 NUL 종료 바이트 배열에 대한 포인터 슬라이스로 변환합니다. 문자열에 NUL 바이트가 포함되어 있으면 (nil, EINVAL)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1c864d92c212ef8abfd9b5a7229b7d9cb38de7a2" translate="yes" xml:space="preserve">
          <source>SliceStable</source>
          <target state="translated">SliceStable</target>
        </trans-unit>
        <trans-unit id="291aafdf1861d62c9bc50f1c83d1800a3cb0913c" translate="yes" xml:space="preserve">
          <source>SliceStable sorts the provided slice given the provided less function while keeping the original order of equal elements.</source>
          <target state="translated">SliceStable은 동일한 요소의 원래 순서를 유지하면서 제공된 적은 기능을 제공하여 제공된 슬라이스를 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="5d20f32e3b5c3f936d2856f8b75431892c2e100a" translate="yes" xml:space="preserve">
          <source>SliceStable sorts the slice x using the provided less function, keeping equal elements in their original order. It panics if x is not a slice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24220363f4bcd3c6462dbe1e7e4afff4012817f0" translate="yes" xml:space="preserve">
          <source>Slices of bytes in the returned token data refer to the parser's internal buffer and remain valid only until the next call to Token. To acquire a copy of the bytes, call CopyToken or the token's Copy method.</source>
          <target state="translated">리턴 된 토큰 데이터의 바이트 조각은 구문 분석기의 내부 버퍼를 참조하고 다음에 토큰을 호출 할 때까지만 유효합니다. 바이트의 사본을 얻으려면 CopyToken 또는 토큰의 Copy 메소드를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="fc7f681747838baecdc0ee29795205530bc0b270" translate="yes" xml:space="preserve">
          <source>SocketControlMessage represents a socket control message.</source>
          <target state="translated">SocketControlMessage는 소켓 제어 메시지를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4457c2edf950c3c3e9063b3a5f5427cad62d71ba" translate="yes" xml:space="preserve">
          <source>Some protocols may impose additional requirements on pre-escaping the username and password. For instance, when used with OAuth2, both arguments must be URL encoded first with url.QueryEscape.</source>
          <target state="translated">일부 프로토콜은 사용자 이름과 비밀번호를 미리 이스케이프 처리하는 데 추가 요구 사항을 부과 할 수 있습니다. 예를 들어, OAuth2와 함께 사용되는 경우 두 인수 모두 url.QueryEscape로 먼저 URL 인코딩되어야합니다.</target>
        </trans-unit>
        <trans-unit id="0b8c5ca797beb6df3a3a7d32f3dea277a5bafd3c" translate="yes" xml:space="preserve">
          <source>Some valid layouts are invalid time values for time.Parse, due to formats such as _ for space padding and Z for zone information.</source>
          <target state="translated">일부 유효한 레이아웃은 시간에 대해 유효하지 않은 시간 값입니다. 공간 패딩의 경우 _, 영역 정보의 경우 Z와 같은 형식으로 인해 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="89fbdcfdf1cfcd667a49cfe3f7c3c0bdc4ce5124" translate="yes" xml:space="preserve">
          <source>Sort is a convenience method.</source>
          <target state="translated">정렬은 편리한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="7ccbc9a539210dab661fff1de8dd5fa06bf6d3f4" translate="yes" xml:space="preserve">
          <source>Sort is a convenience method: x.Sort() calls Sort(x).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f520ad1ca9ea89523277ded79bfeb4e271e735a8" translate="yes" xml:space="preserve">
          <source>Sort sorts an ErrorList. *Error entries are sorted by position, other errors are sorted by error message, and before any *Error entry.</source>
          <target state="translated">정렬은 ErrorList를 정렬합니다. * 오류 항목은 위치별로 정렬되고 다른 오류는 오류 메시지 및 * 오류 항목보다 먼저 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="ca2438ac94fd8ace4cf2c599abff83e53875c98f" translate="yes" xml:space="preserve">
          <source>Sort sorts data. It makes one call to data.Len to determine n and O(n*log(n)) calls to data.Less and data.Swap. The sort is not guaranteed to be stable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8bf7dfcfaee16c58648d64101d25f3215cc22e2" translate="yes" xml:space="preserve">
          <source>Sort sorts data. It makes one call to data.Len to determine n, and O(n*log(n)) calls to data.Less and data.Swap. The sort is not guaranteed to be stable.</source>
          <target state="translated">정렬은 데이터를 정렬합니다. 데이터를 한 번 호출합니다 .n을 결정하려면 렌을, O (n * log (n))는 데이터를 호출합니다 .Less and data.Swap. 정렬이 안정적으로 보장되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="decd49ac7a46241d55346a11f6d2fb74335dc7a9" translate="yes" xml:space="preserve">
          <source>SortImports sorts runs of consecutive import lines in import blocks in f. It also removes duplicate imports when it is possible to do so without data loss.</source>
          <target state="translated">SortImports는 f의 가져 오기 블록에서 연속 가져 오기 행 실행을 정렬합니다. 또한 데이터 손실없이 가능한 경우 중복 가져 오기를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="6e2693fb2fa2b916dd95d972bbcb32b0b6b566ec" translate="yes" xml:space="preserve">
          <source>Source formats src in canonical gofmt style and returns the result or an (I/O or syntax) error. src is expected to be a syntactically correct Go source file, or a list of Go declarations or statements.</source>
          <target state="translated">소스는 표준 gofmt 스타일로 src를 포맷하고 결과 또는 (I / O 또는 구문) 오류를 반환합니다. src는 구문 상 올바른 Go 소스 파일이거나 Go 선언 또는 명령문 목록이어야합니다.</target>
        </trans-unit>
        <trans-unit id="a91bed1365204e8353c0f745ca77893ae1b1305d" translate="yes" xml:space="preserve">
          <source>Source values of type bool may be scanned into types *bool, *interface{}, *string, *[]byte, or *RawBytes.</source>
          <target state="translated">bool 유형의 소스 값은 * bool, * interface {}, * string, * [] byte 또는 * RawBytes 유형으로 스캔 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4cd3cd23d4f7a4635c360a861ee7be174fed76cc" translate="yes" xml:space="preserve">
          <source>Source values of type time.Time may be scanned into values of type *time.Time, *interface{}, *string, or *[]byte. When converting to the latter two, time.RFC3339Nano is used.</source>
          <target state="translated">time.Time 유형의 소스 값 * time.Time, * interface {}, * string 또는 * [] byte 유형의 값으로 스캔 될 수 있습니다. 후자 2 개로 변환 할 때는 time.RFC3339Nano가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6bdf6d7926b72078af0c191b3c6238538d7b0cb1" translate="yes" xml:space="preserve">
          <source>Special case is:</source>
          <target state="translated">특별한 경우는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="38cf2e1ac5d0bfa814379b9cb5b1a8aad4c71895" translate="yes" xml:space="preserve">
          <source>Special cases are (in order):</source>
          <target state="translated">특별한 경우는 (순서대로) :</target>
        </trans-unit>
        <trans-unit id="36ff1c61fcf6a6f96273c5129f496e6e2d52bc61" translate="yes" xml:space="preserve">
          <source>Special cases are the same as Exp.</source>
          <target state="translated">특별한 경우는 Exp와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="fb4f18f6f604123235431e09b3313991f0bb526d" translate="yes" xml:space="preserve">
          <source>Special cases are:</source>
          <target state="translated">특별한 경우는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="46044fc293a1827aa7aed188a242765b1470a9ed" translate="yes" xml:space="preserve">
          <source>Special section indices.</source>
          <target state="translated">특별 섹션 지수.</target>
        </trans-unit>
        <trans-unit id="a2fde335dab74ce6562dfce419b45cb58e70ab07" translate="yes" xml:space="preserve">
          <source>SpecialCase</source>
          <target state="translated">SpecialCase</target>
        </trans-unit>
        <trans-unit id="47398a3a12335bdb3df057e3646557b1b5841333" translate="yes" xml:space="preserve">
          <source>SpecialCase represents language-specific case mappings such as Turkish. Methods of SpecialCase customize (by overriding) the standard mappings.</source>
          <target state="translated">SpecialCase는 터키어와 같은 언어 별 사례 매핑을 나타냅니다. SpecialCase의 메소드는 표준 맵핑을 사용자 정의 (재정의)합니다.</target>
        </trans-unit>
        <trans-unit id="fc8230b4119ad4b994db2324d71f4e0ae7ad932c" translate="yes" xml:space="preserve">
          <source>Split</source>
          <target state="translated">Split</target>
        </trans-unit>
        <trans-unit id="23392488f19a5d0be8c39d3cfafde4dd76bd94be" translate="yes" xml:space="preserve">
          <source>Split panics if it is called after scanning has started.</source>
          <target state="translated">스캔이 시작된 후 호출되면 패닉이 분할됩니다.</target>
        </trans-unit>
        <trans-unit id="96e564d2bf5c731af05562ed176616a9d55a5e64" translate="yes" xml:space="preserve">
          <source>Split sets the split function for the Scanner. The default split function is ScanLines.</source>
          <target state="translated">분할은 스캐너의 분할 기능을 설정합니다. 기본 분할 기능은 ScanLines입니다.</target>
        </trans-unit>
        <trans-unit id="eb475bc85cdb49a4c4de00518ab4efe39bcec33e" translate="yes" xml:space="preserve">
          <source>Split slices s into all subslices separated by sep and returns a slice of the subslices between those separators. If sep is empty, Split splits after each UTF-8 sequence. It is equivalent to SplitN with a count of -1.</source>
          <target state="translated">슬라이스를 sep로 분리 한 모든 하위 슬라이스로 분할하고 해당 구분 기호 사이에서 하위 슬라이스 슬라이스를 반환합니다. sep가 비어 있으면 Split은 각 UTF-8 시퀀스 후에 분할됩니다. 카운트가 -1 인 SplitN과 같습니다.</target>
        </trans-unit>
        <trans-unit id="67dbafd6c3b93902b18d8f321af8549a1b6ad6e7" translate="yes" xml:space="preserve">
          <source>Split slices s into all substrings separated by sep and returns a slice of the substrings between those separators.</source>
          <target state="translated">슬라이스를 sep로 구분 된 모든 하위 문자열로 분할하고 해당 구분 기호 사이의 하위 문자열 조각을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8a1469b01e576340018d58bd7e3d302e90dee09f" translate="yes" xml:space="preserve">
          <source>Split slices s into substrings separated by the expression and returns a slice of the substrings between those expression matches.</source>
          <target state="translated">슬라이스를 표현식으로 구분 된 서브 스트링으로 분할하고 해당 표현식 일치 사이의 서브 스트링 슬라이스를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="817430fe1883828acde2ae90d1a5b512a8d87c1e" translate="yes" xml:space="preserve">
          <source>Split splits path immediately following the final Separator, separating it into a directory and file name component. If there is no Separator in path, Split returns an empty dir and file set to path. The returned values have the property that path = dir+file.</source>
          <target state="translated">분할은 최종 구분 기호 바로 다음에 경로를 분할하여 디렉토리와 파일 이름 구성 요소로 분리합니다. 경로에 구분 기호가 없으면 Split은 빈 디렉토리와 파일 세트를 경로로 반환합니다. 리턴 된 값에는 path = dir + file 특성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="04097266465adc5300d2bc3091a77206398acddf" translate="yes" xml:space="preserve">
          <source>Split splits path immediately following the final slash, separating it into a directory and file name component. If there is no slash in path, Split returns an empty dir and file set to path. The returned values have the property that path = dir+file.</source>
          <target state="translated">분할은 마지막 슬래시 바로 다음에 경로를 분할하여 디렉토리와 파일 이름 구성 요소로 분리합니다. 경로에 슬래시가 없으면 Split은 빈 디렉토리와 파일 세트를 경로로 반환합니다. 리턴 된 값에는 path = dir + file 특성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f645051fa0ea9f5fba674ae30e0eb8228c563bbb" translate="yes" xml:space="preserve">
          <source>SplitAfter</source>
          <target state="translated">SplitAfter</target>
        </trans-unit>
        <trans-unit id="af6f57e26d6655b8a560ff5a1ea503e038967615" translate="yes" xml:space="preserve">
          <source>SplitAfter slices s into all subslices after each instance of sep and returns a slice of those subslices. If sep is empty, SplitAfter splits after each UTF-8 sequence. It is equivalent to SplitAfterN with a count of -1.</source>
          <target state="translated">SplitAfter 슬라이스는 sep의 각 인스턴스 이후에 모든 서브 슬라이스로 슬라이스하고 해당 서브 슬라이스 슬라이스를 반환합니다. sep가 비어 있으면 SplitAfter는 각 UTF-8 시퀀스 후에 분할됩니다. 카운트가 -1 인 SplitAfterN과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7b96a1319471e70dc0744f490b304d8e5292e091" translate="yes" xml:space="preserve">
          <source>SplitAfter slices s into all substrings after each instance of sep and returns a slice of those substrings.</source>
          <target state="translated">SplitAfter는 sep의 각 인스턴스 다음에있는 모든 하위 문자열로 슬라이스하고 해당 하위 문자열의 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="183e10127881bddc63e39844aca6fde7b55ad84d" translate="yes" xml:space="preserve">
          <source>SplitAfterN</source>
          <target state="translated">SplitAfterN</target>
        </trans-unit>
        <trans-unit id="71c5d7e2f9fd13201867043dfefbd28be7cef909" translate="yes" xml:space="preserve">
          <source>SplitAfterN slices s into subslices after each instance of sep and returns a slice of those subslices. If sep is empty, SplitAfterN splits after each UTF-8 sequence. The count determines the number of subslices to return:</source>
          <target state="translated">SplitAfterN 슬라이스는 sep의 각 인스턴스 후에 s를 서브 슬라이스로 슬라이스하고 해당 서브 슬라이스의 슬라이스를 반환합니다. sep가 비어 있으면 SplitAfterN은 각 UTF-8 시퀀스 후에 분할됩니다. 개수는 반환 할 하위 슬라이스 수를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="b953b958d37f7636fa29a91139b9e599462e7d0a" translate="yes" xml:space="preserve">
          <source>SplitAfterN slices s into substrings after each instance of sep and returns a slice of those substrings.</source>
          <target state="translated">SplitAfterN은 sep의 각 인스턴스 후에 s를 하위 문자열로 자르고 해당 하위 문자열의 조각을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c42d1c66abbb920d11fa3452a55d6b02ca57969f" translate="yes" xml:space="preserve">
          <source>SplitFunc is the signature of the split function used to tokenize the input. The arguments are an initial substring of the remaining unprocessed data and a flag, atEOF, that reports whether the Reader has no more data to give. The return values are the number of bytes to advance the input and the next token to return to the user, if any, plus an error, if any.</source>
          <target state="translated">SplitFunc는 입력을 토큰 화하는 데 사용되는 split 함수의 서명입니다. 인수는 처리되지 않은 나머지 데이터의 초기 서브 스트링과 Reader에 더 이상 제공 할 데이터가 없는지 여부를보고하는 플래그 atEOF입니다. 리턴 값은 입력을 진행시키기위한 바이트 수와 사용자에게 리턴 할 다음 토큰 (있는 경우)과 오류 (있는 경우)입니다.</target>
        </trans-unit>
        <trans-unit id="b4cd81f732cbd3a8923ecb19ba58f0f16cb90789" translate="yes" xml:space="preserve">
          <source>SplitHostPort splits a network address of the form &quot;host:port&quot;, &quot;host%zone:port&quot;, &quot;[host]:port&quot; or &quot;[host%zone]:port&quot; into host or host%zone and port.</source>
          <target state="translated">SplitHostPort는 &quot;host : port&quot;, &quot;host % zone : port&quot;, &quot;[host] : port&quot;또는 &quot;[host % zone] : port&quot;형식의 네트워크 주소를 호스트 또는 호스트 % zone 및 포트로 분할합니다.</target>
        </trans-unit>
        <trans-unit id="83d28a087df2085b354d9219f029b5d90cf38ec4" translate="yes" xml:space="preserve">
          <source>SplitList</source>
          <target state="translated">SplitList</target>
        </trans-unit>
        <trans-unit id="2810f9f5e2566aed968386693eafb51ff308b597" translate="yes" xml:space="preserve">
          <source>SplitList splits a list of paths joined by the OS-specific ListSeparator, usually found in PATH or GOPATH environment variables. Unlike strings.Split, SplitList returns an empty slice when passed an empty string.</source>
          <target state="translated">SplitList는 일반적으로 PATH 또는 GOPATH 환경 변수에있는 OS 별 ListSeparator로 조인 된 경로 목록을 분할합니다. 문자열과 달리 SplitList는 빈 문자열을 전달하면 빈 조각을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="84cfaf9bc325cc024ba8d73b2f03f1f0b940f375" translate="yes" xml:space="preserve">
          <source>SplitN</source>
          <target state="translated">SplitN</target>
        </trans-unit>
        <trans-unit id="36c3c8ea011f7ef62da6893e010962d6852bd07a" translate="yes" xml:space="preserve">
          <source>SplitN slices s into subslices separated by sep and returns a slice of the subslices between those separators. If sep is empty, SplitN splits after each UTF-8 sequence. The count determines the number of subslices to return:</source>
          <target state="translated">SplitN 슬라이스는 sep로 분리 된 서브 슬라이스로 분리하고 해당 분리 기호 사이의 서브 슬라이스 슬라이스를 반환합니다. sep가 비어 있으면 SplitN은 각 UTF-8 시퀀스 후에 분할됩니다. 개수는 반환 할 하위 슬라이스 수를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="de01961453e6bcc30ddd7714ed914f746f011fab" translate="yes" xml:space="preserve">
          <source>SplitN slices s into substrings separated by sep and returns a slice of the substrings between those separators.</source>
          <target state="translated">SplitN 슬라이스는 sep로 구분 된 하위 문자열로 분리하고 해당 구분 기호 사이의 하위 문자열 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8ca15484a6a50617febf823f3fa1c9e7038688ee" translate="yes" xml:space="preserve">
          <source>Sprint</source>
          <target state="translated">Sprint</target>
        </trans-unit>
        <trans-unit id="d0775164f7f53356c293723cd9c1222468d3a49b" translate="yes" xml:space="preserve">
          <source>Sprint formats using the default formats for its operands and returns the resulting string. Spaces are added between operands when neither is a string.</source>
          <target state="translated">피연산자에 기본 형식을 사용하여 스프린트 형식을 지정하고 결과 문자열을 반환합니다. 문자열이 아닌 경우 피연산자 사이에 공백이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="7d5fe7cc61bbb8158ad630a3820e3c126928a4a6" translate="yes" xml:space="preserve">
          <source>Sprintf</source>
          <target state="translated">Sprintf</target>
        </trans-unit>
        <trans-unit id="5bfb46358289368784772aa4aa5a217258b76236" translate="yes" xml:space="preserve">
          <source>Sprintf formats according to a format specifier and returns the resulting string.</source>
          <target state="translated">Sprintf는 형식 지정자에 따라 형식을 지정하고 결과 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5446f67533b2f88354fccb3b84fed81fd676a9d5" translate="yes" xml:space="preserve">
          <source>Sprintln</source>
          <target state="translated">Sprintln</target>
        </trans-unit>
        <trans-unit id="d0bd83b3300fd81e26aa39c136cc9d6ce11bb5a7" translate="yes" xml:space="preserve">
          <source>Sprintln formats using the default formats for its operands and returns the resulting string. Spaces are always added between operands and a newline is appended.</source>
          <target state="translated">Sprintln은 피연산자에 기본 형식을 사용하여 형식을 지정하고 결과 문자열을 반환합니다. 피연산자 사이에 공백이 항상 추가되고 줄 바꾸기가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="6bbb118b36018412cea4de47bc914f00685c9ac5" translate="yes" xml:space="preserve">
          <source>Sqrt</source>
          <target state="translated">Sqrt</target>
        </trans-unit>
        <trans-unit id="1b795ae9b134bc8c4c0b446e88fecc1f3b41d092" translate="yes" xml:space="preserve">
          <source>Sqrt returns the square root of x.</source>
          <target state="translated">Sqrt는 x의 제곱근을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b85c9b396b0e4464f48aa17058f2b1082008ae70" translate="yes" xml:space="preserve">
          <source>Sqrt returns the square root of x. The result r is chosen so that real(r) &amp;ge; 0 and imag(r) has the same sign as imag(x).</source>
          <target state="translated">Sqrt는 x의 제곱근을 반환합니다. 결과 r은 real (r) &amp;ge; 0 및 imag (r)이 imag (x)와 같은 부호를 갖도록 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="41b5f4c2f86ca750aabbdd4d6bdb915be0584893" translate="yes" xml:space="preserve">
          <source>Sqrt sets z to &amp;lfloor;&amp;radic;x&amp;rfloor;, the largest integer such that z&amp;sup2; &amp;le; x, and returns z. It panics if x is negative.</source>
          <target state="translated">Sqrt는 z를 &amp;sup2;&amp;radic;x&amp;rfloor; (z&amp;sup2; &amp;le; x와 같은 가장 큰 정수)로 설정하고 z를 반환합니다. x가 음수이면 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2e519fcfbc6a90ddf75f1394fae55598d7af8898" translate="yes" xml:space="preserve">
          <source>Sqrt sets z to the rounded square root of x, and returns it.</source>
          <target state="translated">Sqrt는 z를 x의 둥근 제곱근으로 설정하고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b183229b8a0007179105ee23f98db0fa35e992ca" translate="yes" xml:space="preserve">
          <source>SrcDirs returns a list of package source root directories. It draws from the current Go root and Go path but omits directories that do not exist.</source>
          <target state="translated">SrcDirs는 패키지 소스 루트 디렉토리 목록을 리턴합니다. 현재 Go 루트 및 Go 경로에서 가져 오지만 존재하지 않는 디렉토리는 생략합니다.</target>
        </trans-unit>
        <trans-unit id="ace37ead62176f4b0fef73d8a4e6eefe6e4e0808" translate="yes" xml:space="preserve">
          <source>Srcset encapsulates a known safe srcset attribute (see &lt;a href=&quot;https://w3c.github.io/html/semantics-embedded-content.html#element-attrdef-img-srcset&quot;&gt;https://w3c.github.io/html/semantics-embedded-content.html#element-attrdef-img-srcset&lt;/a&gt;).</source>
          <target state="translated">Srcset은 알려진 안전한 srcset 속성을 캡슐화합니다 ( &lt;a href=&quot;https://w3c.github.io/html/semantics-embedded-content.html#element-attrdef-img-srcset&quot;&gt;https://w3c.github.io/html/semantics-embedded-content.html#element-attrdef-img-srcset 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="608729966442ded3bea906aefa46d7a131fb981c" translate="yes" xml:space="preserve">
          <source>Sscan scans the argument string, storing successive space-separated values into successive arguments. Newlines count as space. It returns the number of items successfully scanned. If that is less than the number of arguments, err will report why.</source>
          <target state="translated">Sscan은 공백으로 구분 된 연속 값을 연속 인수로 저장하여 인수 문자열을 스캔합니다. 줄 바꿈은 공백으로 계산됩니다. 성공적으로 스캔 한 항목 수를 반환합니다. 그것이 인수의 수보다 적 으면, err가 이유를보고합니다.</target>
        </trans-unit>
        <trans-unit id="390342df3a9580b3ab53916d8e78ce9a67e05f51" translate="yes" xml:space="preserve">
          <source>Sscanf</source>
          <target state="translated">Sscanf</target>
        </trans-unit>
        <trans-unit id="61a716d2775c775cb5be05f41652e9aaaad32358" translate="yes" xml:space="preserve">
          <source>Sscanf scans the argument string, storing successive space-separated values into successive arguments as determined by the format. It returns the number of items successfully parsed. Newlines in the input must match newlines in the format.</source>
          <target state="translated">Sscanf는 인수 문자열을 스캔하여 형식에 의해 결정된대로 연속 공백으로 구분 된 값을 연속 인수로 저장합니다. 성공적으로 구문 분석 된 항목 수를 반환합니다. 입력의 개행은 형식의 개행과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="af4732932dde6aa0c1e4ad7d04d2e2382ec0a0b6" translate="yes" xml:space="preserve">
          <source>Sscanln is similar to Sscan, but stops scanning at a newline and after the final item there must be a newline or EOF.</source>
          <target state="translated">Sscanln은 Sscan과 비슷하지만 줄 바꿈에서 스캔을 중지하며 마지막 항목 뒤에 줄 바꿈 또는 EOF가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="6f3e4b56a56750c728e3e2463bad931f8918a9d7" translate="yes" xml:space="preserve">
          <source>Stable sorts data while keeping the original order of equal elements.</source>
          <target state="translated">안정적인 동일한 요소의 원래 순서를 유지하면서 데이터를 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="c9e8e2e8cb17ec7f99a9db77c101e60f6136c3a5" translate="yes" xml:space="preserve">
          <source>Stack formats a stack trace of the calling goroutine into buf and returns the number of bytes written to buf. If all is true, Stack formats stack traces of all other goroutines into buf after the trace for the current goroutine.</source>
          <target state="translated">Stack은 호출 goroutine의 스택 추적을 buf로 포맷하고 buf에 쓴 바이트 수를 반환합니다. 모두 참이면, 스택은 현재 고 루틴 추적 후 다른 모든 고 루틴의 흔적을 buf로 쌓습니다.</target>
        </trans-unit>
        <trans-unit id="1cffafd303a34a6584721e138e5265f842cb505a" translate="yes" xml:space="preserve">
          <source>Stack returns a formatted stack trace of the goroutine that calls it. It calls runtime.Stack with a large enough buffer to capture the entire trace.</source>
          <target state="translated">스택은 그것을 호출하는 고 루틴의 형식화 된 스택 추적을 반환합니다. 전체 트레이스를 캡처하기에 충분한 버퍼가있는 runtime.Stack을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="418aa94a169d739e57a35d99f93d9138e0bb4b62" translate="yes" xml:space="preserve">
          <source>Stack returns the stack trace associated with the record, a prefix of r.Stack0.</source>
          <target state="translated">스택은 r.Stack0의 접두사 인 레코드와 관련된 스택 추적을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="687cb3d7c249eff01be44167736a622ba61578c9" translate="yes" xml:space="preserve">
          <source>Standard colors.</source>
          <target state="translated">표준 색상.</target>
        </trans-unit>
        <trans-unit id="360c57caedbd1d1ff38dde144677c893d6ad3792" translate="yes" xml:space="preserve">
          <source>Standard library</source>
          <target state="translated">표준 라이브러리</target>
        </trans-unit>
        <trans-unit id="9fb1a9f741b4439135087b938ed47613619d8e54" translate="yes" xml:space="preserve">
          <source>Start enables tracing for the current program. While tracing, the trace will be buffered and written to w. Start returns an error if tracing is already enabled.</source>
          <target state="translated">시작은 현재 프로그램에 대한 추적을 활성화합니다. 추적하는 동안 추적이 버퍼링되고 w에 기록됩니다. 추적이 이미 사용 가능한 경우 시작은 오류를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="d84f21e1e9935e064f3eccc25d6db5d4fb64a86a" translate="yes" xml:space="preserve">
          <source>Start starts a server from NewUnstartedServer.</source>
          <target state="translated">시작은 NewUnstartedServer에서 서버를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="b61ef15d781bf8c860427db7964980f61966535c" translate="yes" xml:space="preserve">
          <source>Start starts the specified command but does not wait for it to complete.</source>
          <target state="translated">시작은 지정된 명령을 시작하지만 완료 될 때까지 기다리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7f51b09c0923a4603b545c471069b55e22a62f34" translate="yes" xml:space="preserve">
          <source>StartCPUProfile enables CPU profiling for the current process. While profiling, the profile will be buffered and written to w. StartCPUProfile returns an error if profiling is already enabled.</source>
          <target state="translated">StartCPUProfile은 현재 프로세스에 대한 CPU 프로파일 링을 활성화합니다. 프로파일 링 중에 프로파일이 버퍼링되고 w에 기록됩니다. 프로파일 링이 이미 활성화 된 경우 StartCPUProfile은 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f3753321843c42ccf0d93028e612610280e12d5e" translate="yes" xml:space="preserve">
          <source>StartCond returns the leading empty-width conditions that must be true in any match. It returns ^EmptyOp(0) if no matches are possible.</source>
          <target state="translated">StartCond는 일치하는 모든 빈 너비 조건을 반환합니다. 일치하는 항목이 없으면 ^ EmptyOp (0)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e00bec2778efe9f0a1a92501d76b773c7dc58166" translate="yes" xml:space="preserve">
          <source>StartProcess is a low-level interface. The os/exec package provides higher-level interfaces.</source>
          <target state="translated">StartProcess는 저수준 인터페이스입니다. os / exec 패키지는보다 높은 수준의 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4656baf99c52e7677cc8f68ccbc8052e39ef42e9" translate="yes" xml:space="preserve">
          <source>StartProcess starts a new process with the program, arguments and attributes specified by name, argv and attr. The argv slice will become os.Args in the new process, so it normally starts with the program name.</source>
          <target state="translated">StartProcess는 name, argv 및 attr로 지정된 프로그램, 인수 및 속성으로 새 프로세스를 시작합니다. 새로운 프로세스에서 argv 슬라이스는 os.Args가되므로 일반적으로 프로그램 이름으로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="d3d2be7776a3d003cee77683d05001ec6ef09966" translate="yes" xml:space="preserve">
          <source>StartProcess wraps ForkExec for package os.</source>
          <target state="translated">StartProcess는 패키지 os를 위해 ForkExec을 래핑합니다.</target>
        </trans-unit>
        <trans-unit id="4593c93bfc9fb8dacabfc8b4a1731d4454969f64" translate="yes" xml:space="preserve">
          <source>StartRegion starts a region and returns a function for marking the end of the region. The returned Region's End function must be called from the same goroutine where the region was started. Within each goroutine, regions must nest. That is, regions started after this region must be ended before this region can be ended. Recommended usage is</source>
          <target state="translated">StartRegion은 영역을 시작하고 영역의 끝을 표시하는 함수를 반환합니다. 리턴 된 Region의 End 함수는 영역이 시작된 동일한 고 루틴에서 호출되어야합니다. 각 고 루틴 내에서 영역은 중첩되어야합니다. 즉,이 영역 이후에 시작된 영역은이 영역을 종료하기 전에 종료해야합니다. 권장 사용법은</target>
        </trans-unit>
        <trans-unit id="3b719a81fa9e5ddcbfba4cb3fb45c729f487d09e" translate="yes" xml:space="preserve">
          <source>StartRequest blocks until it is time to send (or, if this is a server, receive) the request with the given id.</source>
          <target state="translated">StartRequest는 주어진 ID로 요청을 보낼 때까지 (또는 서버 인 경우)받을 때까지 차단합니다.</target>
        </trans-unit>
        <trans-unit id="338c8f94474f010aa4669ab2c0ae55a5c3a8c12a" translate="yes" xml:space="preserve">
          <source>StartResponse blocks until it is time to receive (or, if this is a server, send) the request with the given id.</source>
          <target state="translated">StartResponse는 주어진 ID로 요청을 수신 (또는 서버 인 경우 전송) 할 때까지 차단합니다.</target>
        </trans-unit>
        <trans-unit id="7ea714fe33f9c8708b382ac24930c9134895c05e" translate="yes" xml:space="preserve">
          <source>StartTLS sends the STARTTLS command and encrypts all further communication. Only servers that advertise the STARTTLS extension support this function.</source>
          <target state="translated">StartTLS는 STARTTLS 명령을 전송하고 이후의 모든 통신을 암호화합니다. STARTTLS 확장을 알리는 서버 만이 기능을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="d062840c5c4653552407064d11c812b2dfbbac16" translate="yes" xml:space="preserve">
          <source>StartTLS starts TLS on a server from NewUnstartedServer.</source>
          <target state="translated">StartTLS는 NewUnstartedServer의 서버에서 TLS를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="01903002ac73fdbc83cec8f016e70281a8a03041" translate="yes" xml:space="preserve">
          <source>StartTimer starts timing a test. This function is called automatically before a benchmark starts, but it can also be used to resume timing after a call to StopTimer.</source>
          <target state="translated">StartTimer는 테스트 타이밍을 시작합니다. 이 기능은 벤치 마크가 시작되기 전에 자동으로 호출되지만 StopTimer 호출 후 타이밍을 재개하는 데 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb33cf53f4e568db572c687d22b2ff2888d74df9" translate="yes" xml:space="preserve">
          <source>StartTrace enables tracing for the current process. While tracing, the data will be buffered and available via ReadTrace. StartTrace returns an error if tracing is already enabled. Most clients should use the runtime/trace package or the testing package's -test.trace flag instead of calling StartTrace directly.</source>
          <target state="translated">StartTrace는 현재 프로세스에 대한 추적을 활성화합니다. 추적하는 동안 데이터는 버퍼링되고 ReadTrace를 통해 사용 가능합니다. 추적이 이미 활성화 된 경우 StartTrace는 오류를 반환합니다. 대부분의 클라이언트는 StartTrace를 직접 호출하는 대신 런타임 / 추적 패키지 또는 테스트 패키지의 -test.trace 플래그를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="6de552c394748272d237ee2909c17f8a5fd51503" translate="yes" xml:space="preserve">
          <source>Starting with Go 1.6, the http package has transparent support for the HTTP/2 protocol when using HTTPS. Programs that must disable HTTP/2 can do so by setting Transport.TLSNextProto (for clients) or Server.TLSNextProto (for servers) to a non-nil, empty map. Alternatively, the following GODEBUG environment variables are currently supported:</source>
          <target state="translated">Go 1.6부터 HTTP 패키지는 HTTPS를 사용할 때 HTTP / 2 프로토콜을 투명하게 지원합니다. HTTP / 2를 비활성화해야하는 프로그램은 Transport.TLSNextProto (클라이언트) 또는 Server.TLSNextProto (서버)를 0이 아닌 빈 맵으로 설정하면됩니다. 또는 다음 GODEBUG 환경 변수가 현재 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="28ec6f916901c65e29319bfbfe8521a54d4bfc1b" translate="yes" xml:space="preserve">
          <source>Stat returns a FileInfo describing the named file from the file system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c555084811f017d34d2693472b49bb062306f30" translate="yes" xml:space="preserve">
          <source>Stat returns a FileInfo describing the named file. If there is an error, it will be of type *PathError.</source>
          <target state="translated">Stat는 명명 된 파일을 설명하는 FileInfo를 반환합니다. 오류가 있으면 * PathError 유형입니다.</target>
        </trans-unit>
        <trans-unit id="e4a95458fc56105197c2a964b9366157865cbb1b" translate="yes" xml:space="preserve">
          <source>Stat returns the FileInfo structure describing file. If there is an error, it will be of type *PathError.</source>
          <target state="translated">Stat는 파일을 설명하는 FileInfo 구조를 반환합니다. 오류가 있으면 * PathError 유형입니다.</target>
        </trans-unit>
        <trans-unit id="6ed6c9c2af9ffd2ea1bfb59989c27d85db3a34df" translate="yes" xml:space="preserve">
          <source>State represents the printer state passed to custom formatters. It provides access to the io.Writer interface plus information about the flags and options for the operand's format specifier.</source>
          <target state="translated">상태는 사용자 정의 포맷터에 전달 된 프린터 상태를 나타냅니다. io.Writer 인터페이스에 액세스하고 피연산자의 형식 지정자에 대한 플래그 및 옵션에 대한 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6c898e0bae6ae6e6a509998b0d70b717982994c3" translate="yes" xml:space="preserve">
          <source>Static reports whether this symbol is static (not visible outside its file).</source>
          <target state="translated">정적은이 심볼이 정적인지 여부를보고합니다 (파일 외부에서는 볼 수 없음).</target>
        </trans-unit>
        <trans-unit id="f107d6fd99e84eaeb4014efe73efa78374b13f61" translate="yes" xml:space="preserve">
          <source>Stats returns database statistics.</source>
          <target state="translated">통계는 데이터베이스 통계를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="473cf8363b9a9dc6de8f9778203d0b0d99ffe820" translate="yes" xml:space="preserve">
          <source>StatusText returns a text for the HTTP status code. It returns the empty string if the code is unknown.</source>
          <target state="translated">StatusText는 HTTP 상태 코드에 대한 텍스트를 반환합니다. 코드를 알 수 없으면 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d95efd4b66df751ef4f7e7c0d6a981a761feec31" translate="yes" xml:space="preserve">
          <source>StdEncoding is the standard base32 encoding, as defined in RFC 4648.</source>
          <target state="translated">StdEncoding은 RFC 4648에 정의 된 표준 base32 인코딩입니다.</target>
        </trans-unit>
        <trans-unit id="a9197d0bbe7d5f346c8fce4d5958e4af36331be4" translate="yes" xml:space="preserve">
          <source>StdEncoding is the standard base64 encoding, as defined in RFC 4648.</source>
          <target state="translated">StdEncoding은 RFC 4648에 정의 된 표준 base64 인코딩입니다.</target>
        </trans-unit>
        <trans-unit id="c30cba7f2a4c150acfe65c8a3aa36a9ff709ad57" translate="yes" xml:space="preserve">
          <source>StdSizes is a convenience type for creating commonly used Sizes. It makes the following simplifying assumptions:</source>
          <target state="translated">StdSizes는 일반적으로 사용되는 크기를 만들기위한 편리한 유형입니다. 다음과 같은 간단한 가정을합니다.</target>
        </trans-unit>
        <trans-unit id="34f196b4b0f694cd0a2f21247970027005c1305c" translate="yes" xml:space="preserve">
          <source>StderrPipe returns a pipe that will be connected to the command's standard error when the command starts.</source>
          <target state="translated">StderrPipe는 명령이 시작될 때 명령의 표준 오류에 연결될 파이프를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f9c5224ebb81b29f683fd0f89569f0498e209b24" translate="yes" xml:space="preserve">
          <source>Stdin, Stdout, and Stderr are open Files pointing to the standard input, standard output, and standard error file descriptors.</source>
          <target state="translated">Stdin, Stdout 및 Stderr은 표준 입력, 표준 출력 및 표준 오류 파일 설명자를 가리키는 열린 파일입니다.</target>
        </trans-unit>
        <trans-unit id="eaaa7d5358fae0ad4ea6507594efa4e1fe1938f3" translate="yes" xml:space="preserve">
          <source>StdinPipe returns a pipe that will be connected to the command's standard input when the command starts. The pipe will be closed automatically after Wait sees the command exit. A caller need only call Close to force the pipe to close sooner. For example, if the command being run will not exit until standard input is closed, the caller must close the pipe.</source>
          <target state="translated">StdinPipe는 명령이 시작될 때 명령의 표준 입력에 연결될 파이프를 반환합니다. 대기 명령이 종료 된 후 파이프가 자동으로 닫힙니다. 호출자는 파이프를 더 빨리 닫으려면 Close 만 호출하면됩니다. 예를 들어, 표준 입력이 닫힐 때까지 실행중인 명령이 종료되지 않으면 호출자는 파이프를 닫아야합니다.</target>
        </trans-unit>
        <trans-unit id="e34e1f63d532ddcb966f6992c5d243530bff512e" translate="yes" xml:space="preserve">
          <source>StdoutPipe returns a pipe that will be connected to the command's standard output when the command starts.</source>
          <target state="translated">StdoutPipe는 명령이 시작될 때 명령의 표준 출력에 연결될 파이프를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="35cb1f2f3090469fddd290f48f6f6f66f6cfbf71" translate="yes" xml:space="preserve">
          <source>Stmt</source>
          <target state="translated">Stmt</target>
        </trans-unit>
        <trans-unit id="e8d756b195575772804ef522d92696943863af82" translate="yes" xml:space="preserve">
          <source>Stmt is a prepared statement. A Stmt is safe for concurrent use by multiple goroutines.</source>
          <target state="translated">Stmt는 준비된 진술입니다. Stmt는 여러 고 루틴이 동시에 사용하기에 안전합니다.</target>
        </trans-unit>
        <trans-unit id="0bb26a3ab8d8618ecc81beec5115670b66a970d5" translate="yes" xml:space="preserve">
          <source>Stmt is a prepared statement. It is bound to a Conn and not used by multiple goroutines concurrently.</source>
          <target state="translated">Stmt는 준비된 진술입니다. Conn에 바인딩되어 있으며 여러 고 루틴에서 동시에 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9e8123e57a051d77d8becac273756b24f947f7c4" translate="yes" xml:space="preserve">
          <source>Stmt returns a transaction-specific prepared statement from an existing statement.</source>
          <target state="translated">Stmt는 기존 명령문에서 트랜잭션 별 준비된 명령문을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="9e2e6090b163c6036190ffea94ddcfbb24b8b882" translate="yes" xml:space="preserve">
          <source>Stmt.QueryRowContext</source>
          <target state="translated">Stmt.QueryRowContext</target>
        </trans-unit>
        <trans-unit id="70af1d64e33ba2bc94ac6b94c7823d3046a2e685" translate="yes" xml:space="preserve">
          <source>StmtContext returns a transaction-specific prepared statement from an existing statement.</source>
          <target state="translated">StmtContext는 기존 명령문에서 트랜잭션 별 준비된 명령문을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="a70153fdc2043d42cd12ca46ccb4c33b57b300d4" translate="yes" xml:space="preserve">
          <source>StmtExecContext enhances the Stmt interface by providing Exec with context.</source>
          <target state="translated">StmtExecContext는 Exec에 컨텍스트를 제공하여 Stmt 인터페이스를 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="1004fd52a4b277314a44a4efa023effe4416d3f8" translate="yes" xml:space="preserve">
          <source>StmtQueryContext enhances the Stmt interface by providing Query with context.</source>
          <target state="translated">StmtQueryContext는 Query에 컨텍스트를 제공하여 Stmt 인터페이스를 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="4e7e607354865ab06dac634d86cb1266a005b9e3" translate="yes" xml:space="preserve">
          <source>Stop causes package signal to stop relaying incoming signals to c. It undoes the effect of all prior calls to Notify using c. When Stop returns, it is guaranteed that c will receive no more signals.</source>
          <target state="translated">중지는 패키지 신호가 들어오는 신호를 릴레이하는 것을 중지시킵니다. c. c를 사용하여 알림에 대한 모든 이전 호출의 효과를 취소합니다. Stop이 반환되면 c는 더 이상 신호를받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="94f72ec5a9e9e46f0269677088e9aed4dc6bf0c7" translate="yes" xml:space="preserve">
          <source>Stop prevents the Timer from firing. It returns true if the call stops the timer, false if the timer has already expired or been stopped. Stop does not close the channel, to prevent a read from the channel succeeding incorrectly.</source>
          <target state="translated">중지하면 타이머가 실행되지 않습니다. 호출이 타이머를 중지하면 true를, 타이머가 이미 만료되었거나 중지 된 경우 false를 반환합니다. 채널에서 읽히지 못하도록 채널이 닫히지 않아 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="96e4cceff229f7d0b6242e33e40b44c6e1f954ad" translate="yes" xml:space="preserve">
          <source>Stop stops the current tracing, if any. Stop only returns after all the writes for the trace have completed.</source>
          <target state="translated">중지는 현재 추적을 중지합니다 (있는 경우). 중지는 추적에 대한 모든 쓰기가 완료된 후에 만 ​​리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="f869959cdbddc758676d9a0b40b1ccec00a007e0" translate="yes" xml:space="preserve">
          <source>Stop turns off a ticker. After Stop, no more ticks will be sent. Stop does not close the channel, to prevent a concurrent goroutine reading from the channel from seeing an erroneous &quot;tick&quot;.</source>
          <target state="translated">중지는 시세를 끕니다. 중지 후에는 더 이상 틱이 전송되지 않습니다. 채널에서 동시 goroutine 읽기가 잘못된 &quot;틱&quot;을 보지 못하게하려면 Stop이 채널을 닫지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6c60cc11ce6206ba7285eea9b92d5192efe41d39" translate="yes" xml:space="preserve">
          <source>StopCPUProfile stops the current CPU profile, if any. StopCPUProfile only returns after all the writes for the profile have completed.</source>
          <target state="translated">StopCPUProfile은 현재 CPU 프로필을 중지합니다 (있는 경우). StopCPUProfile은 프로파일에 대한 모든 쓰기가 완료된 후에 만 ​​리턴합니다.</target>
        </trans-unit>
        <trans-unit id="921647073cddc48eae81cacd6f73563cc3719e6f" translate="yes" xml:space="preserve">
          <source>StopTimer stops timing a test. This can be used to pause the timer while performing complex initialization that you don't want to measure.</source>
          <target state="translated">StopTimer는 테스트 타이밍을 중지합니다. 측정하지 않으려는 복잡한 초기화를 수행하는 동안 타이머를 일시 중지하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84dbe4eb021745433f9d6bb9432228e77ba19099" translate="yes" xml:space="preserve">
          <source>StopTrace stops tracing, if it was previously enabled. StopTrace only returns after all the reads for the trace have completed.</source>
          <target state="translated">StopTrace는 이전에 활성화 된 경우 추적을 중지합니다. StopTrace는 추적에 대한 모든 읽기가 완료된 후에 만 ​​반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e64cf11d9830120b60f240aa4b7f7791804376a7" translate="yes" xml:space="preserve">
          <source>Store sets the value for a key.</source>
          <target state="translated">Store는 키 값을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="0576297e57bdd6afa5e5d4f4c53fb27987cf20cb" translate="yes" xml:space="preserve">
          <source>Store sets the value of the Value to x. All calls to Store for a given Value must use values of the same concrete type. Store of an inconsistent type panics, as does Store(nil).</source>
          <target state="translated">Store는 Value의 값을 x로 설정합니다. 주어진 값에 대한 모든 Store 호출은 동일한 콘크리트 유형의 값을 사용해야합니다. Store (nil)와 마찬가지로 일관성이없는 유형 패닉을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="61fc43e10839248a6ca4c0ad01079c0c4ad0ec37" translate="yes" xml:space="preserve">
          <source>StoreInt32 atomically stores val into *addr.</source>
          <target state="translated">StoreInt32는 원자를 * addr에 원자 적으로 저장합니다.</target>
        </trans-unit>
        <trans-unit id="7914e40a268c91ed6c78dd3a0c674684e23beca2" translate="yes" xml:space="preserve">
          <source>StoreInt64 atomically stores val into *addr.</source>
          <target state="translated">StoreInt64는 원자를 val을 * addr에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="3bd4e783553f00f03c188a415e3661fa8de191b3" translate="yes" xml:space="preserve">
          <source>StorePointer atomically stores val into *addr.</source>
          <target state="translated">StorePointer는 원자를 val을 * addr에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="9cc88c9dca1de73040dfd90e6d827a5b531c64fe" translate="yes" xml:space="preserve">
          <source>StoreUint32 atomically stores val into *addr.</source>
          <target state="translated">StoreUint32는 원자 적으로 val을 * addr에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="e11c1fe521ea309905b20e2bda18135e66472a1e" translate="yes" xml:space="preserve">
          <source>StoreUint64 atomically stores val into *addr.</source>
          <target state="translated">StoreUint64는 원자 적으로 val을 * addr에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="644096d645019d8a2ba6cbc4d305a2699fe9059f" translate="yes" xml:space="preserve">
          <source>StoreUintptr atomically stores val into *addr.</source>
          <target state="translated">StoreUintptr은 val을 * addr에 원자 적으로 저장합니다.</target>
        </trans-unit>
        <trans-unit id="cab8594aca23f91dcc0728ca91d9d20dcd26b690" translate="yes" xml:space="preserve">
          <source>StreamReader</source>
          <target state="translated">StreamReader</target>
        </trans-unit>
        <trans-unit id="2a7fc943079fc92f6a989794ba51133e347d57cd" translate="yes" xml:space="preserve">
          <source>StreamReader wraps a Stream into an io.Reader. It calls XORKeyStream to process each slice of data which passes through.</source>
          <target state="translated">StreamReader는 Stream을 io.Reader로 래핑합니다. XORKeyStream을 호출하여 통과하는 각 데이터 조각을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="232a89f73446348f72f684c82d07ed788b848a3a" translate="yes" xml:space="preserve">
          <source>StreamWriter</source>
          <target state="translated">StreamWriter</target>
        </trans-unit>
        <trans-unit id="fc13aaf005c735ab0e4aa5176b6af67540be3a8b" translate="yes" xml:space="preserve">
          <source>StreamWriter wraps a Stream into an io.Writer. It calls XORKeyStream to process each slice of data which passes through. If any Write call returns short then the StreamWriter is out of sync and must be discarded. A StreamWriter has no internal buffering; Close does not need to be called to flush write data.</source>
          <target state="translated">StreamWriter는 Stream을 io.Writer로 래핑합니다. XORKeyStream을 호출하여 통과하는 각 데이터 조각을 처리합니다. 쓰기 호출이 짧으면 StreamWriter가 동기화되지 않아 버려야합니다. StreamWriter에는 내부 버퍼링이 없습니다. 쓰기 데이터를 플러시하기 위해 Close를 호출 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="61135993a6e29b59a8df3075ca0d3838f94b8d90" translate="yes" xml:space="preserve">
          <source>Strict creates a new encoding identical to enc except with strict decoding enabled. In this mode, the decoder requires that trailing padding bits are zero, as described in RFC 4648 section 3.5.</source>
          <target state="translated">Strict는 엄격한 디코딩이 활성화 된 경우를 제외하고 enc와 동일한 새 인코딩을 만듭니다. 이 모드에서 디코더는 RFC 4648 섹션 3.5에 설명 된대로 후행 패딩 비트가 0이어야합니다.</target>
        </trans-unit>
        <trans-unit id="396b00d6c7e8c1194e27297cd11ae3108cdacd84" translate="yes" xml:space="preserve">
          <source>String Conversions</source>
          <target state="translated">문자열 변환</target>
        </trans-unit>
        <trans-unit id="bd47be7c94487cbe10dfe0be4138815d0017463a" translate="yes" xml:space="preserve">
          <source>String and slice of bytes (treated equivalently with these verbs):</source>
          <target state="translated">문자열과 바이트 조각 (이 동사와 동일하게 처리됨) :</target>
        </trans-unit>
        <trans-unit id="8296a76a0e5d96744b29fe69547a88fb9387440d" translate="yes" xml:space="preserve">
          <source>String defines a string flag with specified name, default value, and usage string. The return value is the address of a string variable that stores the value of the flag.</source>
          <target state="translated">문자열은 지정된 이름, 기본값 및 사용 문자열로 문자열 플래그를 정의합니다. 리턴 값은 플래그 값을 저장하는 문자열 변수의 주소입니다.</target>
        </trans-unit>
        <trans-unit id="9e4dec141cb0219423f92167f6932232e80cdb9e" translate="yes" xml:space="preserve">
          <source>String extracts string from COFF string table st at offset start.</source>
          <target state="translated">문자열은 오프셋 시작시 COFF 문자열 테이블 st에서 문자열을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="dcd688eb0f2fbd5e407777a28042b64595f0fef8" translate="yes" xml:space="preserve">
          <source>String formats the address as a valid RFC 5322 address. If the address's name contains non-ASCII characters the name will be rendered according to RFC 2047.</source>
          <target state="translated">문자열은 주소를 유효한 RFC 5322 주소로 형식화합니다. 주소 이름에 ASCII가 아닌 문자가 포함되어 있으면 RFC 2047에 따라 이름이 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="8d105c469495a5d5f8062e63371ab613869f1e04" translate="yes" xml:space="preserve">
          <source>String formats x like x.Text('g', 10). (String must be called explicitly, Float.Format does not support %s verb.)</source>
          <target state="translated">x.Text ( 'g', 10)과 같은 문자열 형식 x. 문자열은 명시 적으로 호출해야합니다. Float.Format은 % s 동사를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="01748cd6407645feded183980c6258bbb0d669e6" translate="yes" xml:space="preserve">
          <source>String implements the Var interface. To get the unquoted string use Value.</source>
          <target state="translated">문자열은 Var 인터페이스를 구현합니다. 따옴표없는 문자열을 얻으려면 Value를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c388848919b90e3a01d2d3408f1ebde77b3f2a74" translate="yes" xml:space="preserve">
          <source>String is a ValueConverter that converts its input to a string. If the value is already a string or []byte, it's unchanged. If the value is of another type, conversion to string is done with fmt.Sprintf(&quot;%v&quot;, v).</source>
          <target state="translated">String은 입력을 문자열로 변환하는 ValueConverter입니다. 값이 이미 문자열 또는 [] 바이트이면 변경되지 않습니다. 값이 다른 유형 인 경우 문자열 변환은 fmt.Sprintf ( &quot;% v&quot;, v)를 사용하여 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="014933e8c2aa543fd850622d80731a6a9386778b" translate="yes" xml:space="preserve">
          <source>String is a string variable, and satisfies the Var interface.</source>
          <target state="translated">문자열은 문자열 변수이며 Var 인터페이스를 충족시킵니다.</target>
        </trans-unit>
        <trans-unit id="83826ec6cada0ae1502e1aff2c5460723f559354" translate="yes" xml:space="preserve">
          <source>String reassembles the URL into a valid URL string. The general form of the result is one of:</source>
          <target state="translated">문자열은 URL을 유효한 URL 문자열로 재 조립합니다. 결과의 일반적인 형태는 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="1a1a1e5164ab79c22ae49942d67ef810bdba6ad9" translate="yes" xml:space="preserve">
          <source>String returns a descriptive name for the time zone information, corresponding to the name argument to LoadLocation or FixedZone.</source>
          <target state="translated">String은 표준 시간대 정보의 이름을 LoadLocation 또는 FixedZone의 이름 인수에 해당하는 설명적인 이름으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="aa4d82115db66e350e92f539c5427c79fdfb58ed" translate="yes" xml:space="preserve">
          <source>String returns a human-readable description of c. It is intended only for debugging. In particular, it is not suitable for use as input to a shell. The output of String may vary across Go releases.</source>
          <target state="translated">문자열은 사람이 읽을 수있는 c에 대한 설명을 반환합니다. 디버깅 전용입니다. 특히, 쉘 입력으로 사용하기에 적합하지 않습니다. 문자열의 출력은 Go 릴리스마다 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55bb95d4983983ad2bde74eafe604eb90028dc18" translate="yes" xml:space="preserve">
          <source>String returns a string in one of several forms:</source>
          <target state="translated">문자열은 여러 형식 중 하나로 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="345f70fca28ee043619061f7f87c019dadbba1fa" translate="yes" xml:space="preserve">
          <source>String returns a string representation of p like &quot;(3,4)&quot;.</source>
          <target state="translated">문자열은 &quot;(3,4)&quot;와 같이 p의 문자열 표현을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3448960ebb659e656c5021f0b36127dab5b9d619" translate="yes" xml:space="preserve">
          <source>String returns a string representation of r like &quot;(3,4)-(6,5)&quot;.</source>
          <target state="translated">문자열은 &quot;(3,4)-(6,5)&quot;와 같은 r의 문자열 표현을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1b35bdca294966810231e9db40a5c473f629af73" translate="yes" xml:space="preserve">
          <source>String returns a string representation of the scope, for debugging.</source>
          <target state="translated">문자열은 디버깅을 위해 범위의 문자열 표현을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="40800a9640894f3a3149f9e54d890572a4beda8c" translate="yes" xml:space="preserve">
          <source>String returns a string representation of the sequence r, roughly following the RFC 2253 Distinguished Names syntax.</source>
          <target state="translated">문자열은 대략 RFC 2253 식별 이름 구문에 따라 시퀀스 r의 문자열 표현을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7a196811cde011797851e8bcd4ea585d5971e7d9" translate="yes" xml:space="preserve">
          <source>String returns a string representation of x in the form &quot;a/b&quot; (even if b == 1).</source>
          <target state="translated">String은 &quot;a / b&quot;형식으로 x의 문자열 표현을 반환합니다 (b == 1 인 경우에도).</target>
        </trans-unit>
        <trans-unit id="7b4474871a59eadc44e6ad3cc370b5d1fd6eabd1" translate="yes" xml:space="preserve">
          <source>String returns a string representing the duration in the form &quot;72h3m0.5s&quot;. Leading zero units are omitted. As a special case, durations less than one second format use a smaller unit (milli-, micro-, or nanoseconds) to ensure that the leading digit is non-zero. The zero duration formats as 0s.</source>
          <target state="translated">문자열은 지속 시간을 나타내는 문자열을 &quot;72h3m0.5s&quot;형식으로 반환합니다. 선행 0 단위는 생략됩니다. 특별한 경우, 1 초 미만의 지속 시간은 더 작은 단위 (밀리 초, 마이크로 초 또는 나노초)를 사용하여 선행 숫자가 0이 아닌지 확인합니다. 지속 시간이 0 인 형식은 0입니다.</target>
        </trans-unit>
        <trans-unit id="f5e00dac202df16525dc65e74932811ab9752d4e" translate="yes" xml:space="preserve">
          <source>String returns a summary of the benchmark results. It follows the benchmark result line format from &lt;a href=&quot;https://golang.org/design/14313-benchmark-format&quot;&gt;https://golang.org/design/14313-benchmark-format&lt;/a&gt;, not including the benchmark name. Extra metrics override built-in metrics of the same name. String does not include allocs/op or B/op, since those are reported by MemString.</source>
          <target state="translated">문자열은 벤치 마크 결과의 요약을 반환합니다. 벤치 마크 이름을 제외한 &lt;a href=&quot;https://golang.org/design/14313-benchmark-format&quot;&gt;https://golang.org/design/14313-benchmark-format&lt;/a&gt; 의 벤치 마크 결과 라인 형식을 따릅니다 . 추가 메트릭은 동일한 이름의 내장 메트릭보다 우선합니다. 문자열은 allocs / op 또는 B / op를 포함하지 않습니다. 이러한 문자열은 MemString에 의해보고되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="a1320f96272e68242e45787bdcf443a45a5d4acb" translate="yes" xml:space="preserve">
          <source>String returns the CIDR notation of n like &quot;192.0.2.0/24&quot; or &quot;2001:db8::/48&quot; as defined in RFC 4632 and RFC 4291. If the mask is not in the canonical form, it returns the string which consists of an IP address, followed by a slash character and a mask expressed as hexadecimal form with no punctuation like &quot;198.51.100.0/c000ff00&quot;.</source>
          <target state="translated">문자열은 RFC 4632 및 RFC 4291에 정의 된대로 &quot;192.0.2.0/24&quot;또는 &quot;2001 : db8 :: / 48&quot;과 같이 n의 CIDR 표기법을 반환합니다. 마스크가 정식 형식이 아닌 경우에는 구성된 문자열을 반환합니다. &quot;198.51.100.0/c000ff00&quot;과 같이 구두점없이 16 진수 형식으로 표현 된 슬래시 문자와 마스크가 뒤 따릅니다.</target>
        </trans-unit>
        <trans-unit id="f55b73801df68c7614969aee1732afd9d5e38010" translate="yes" xml:space="preserve">
          <source>String returns the English name of the day (&quot;Sunday&quot;, &quot;Monday&quot;, ...).</source>
          <target state="translated">문자열은 요일의 영어 이름 ( &quot;일요일&quot;, &quot;월요일&quot;, ...)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ffc4d02cde72706d98e09a395ce956d9d89dd7b5" translate="yes" xml:space="preserve">
          <source>String returns the English name of the month (&quot;January&quot;, &quot;February&quot;, ...).</source>
          <target state="translated">문자열은 월의 영어 이름 ( &quot;1 월&quot;, &quot;2 월&quot;, ...)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d35cab9a7681d28fe5cfa98797f716ccf4a8148e" translate="yes" xml:space="preserve">
          <source>String returns the accumulated string.</source>
          <target state="translated">문자열은 누적 된 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6a561a9c0ca3a5d45a6220d79144ae4e4f68eaba" translate="yes" xml:space="preserve">
          <source>String returns the contents of the unread portion of the buffer as a string. If the Buffer is a nil pointer, it returns &quot;&amp;lt;nil&amp;gt;&quot;.</source>
          <target state="translated">문자열은 버퍼의 읽지 않은 부분의 내용을 문자열로 반환합니다. 버퍼가 nil 포인터이면 &quot;&amp;lt;nil&amp;gt;&quot;을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="20281079c25e7469dba253811f0a64eb9af0ad50" translate="yes" xml:space="preserve">
          <source>String returns the decimal representation of x as generated by x.Text(10).</source>
          <target state="translated">String은 x.Text (10)에 의해 생성 된 x의 10 진수 표현을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c1f7f34151f59a07d632aef98f6cf3db75ca331f" translate="yes" xml:space="preserve">
          <source>String returns the encoded userinfo information in the standard form of &quot;username[:password]&quot;.</source>
          <target state="translated">문자열은 &quot;username [: password]&quot;의 표준 형식으로 인코딩 된 userinfo 정보를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c9f4b613c07a2c7f71577fe196567617d0abff90" translate="yes" xml:space="preserve">
          <source>String returns the hexadecimal form of m, with no punctuation.</source>
          <target state="translated">문자열은 문장 부호없이 16 진수 형식의 m을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a803d186b1c90a1c53ad70e26c40836efc312842" translate="yes" xml:space="preserve">
          <source>String returns the literal text of the number.</source>
          <target state="translated">문자열은 숫자의 리터럴 텍스트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="efd718d51f4b6dbacf2db82a320892ae4b63a670" translate="yes" xml:space="preserve">
          <source>String returns the name of k.</source>
          <target state="translated">문자열은 k의 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="750dd1515ee90a846665f6d5d112993b3669e476" translate="yes" xml:space="preserve">
          <source>String returns the name of the transaction isolation level.</source>
          <target state="translated">문자열은 트랜잭션 격리 수준의 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e794984ac30a476fc607ba49d30074600724b1fd" translate="yes" xml:space="preserve">
          <source>String returns the serialization of the cookie for use in a Cookie header (if only Name and Value are set) or a Set-Cookie response header (if other fields are set). If c is nil or c.Name is invalid, the empty string is returned.</source>
          <target state="translated">문자열은 쿠키 헤더 (이름 및 값만 설정된 경우) 또는 Set-Cookie 응답 헤더 (다른 필드가 설정된 경우)에 사용하기 위해 쿠키의 직렬화를 반환합니다. c가 nil이거나 c.Name이 유효하지 않으면 빈 문자열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="fe713a69a5fd2ac5cb84c706517fb895d0d57913" translate="yes" xml:space="preserve">
          <source>String returns the source text used to compile the regular expression.</source>
          <target state="translated">문자열은 정규식을 컴파일하는 데 사용되는 소스 텍스트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="34bacca8ec4eef4ee78833a67f79a6eef6da5be0" translate="yes" xml:space="preserve">
          <source>String returns the string corresponding to the token tok. For operators, delimiters, and keywords the string is the actual token character sequence (e.g., for the token ADD, the string is &quot;+&quot;). For all other tokens the string corresponds to the token constant name (e.g. for the token IDENT, the string is &quot;IDENT&quot;).</source>
          <target state="translated">문자열은 토큰 토큰에 해당하는 문자열을 반환합니다. 연산자, 구분 기호 및 키워드의 경우 문자열은 실제 토큰 문자 시퀀스입니다 (예 : 토큰 ADD의 경우 문자열은 &quot;+&quot;). 다른 모든 토큰의 경우 문자열은 토큰 상수 이름에 해당합니다 (예 : 토큰 IDENT의 경우 문자열은 &quot;IDENT&quot;입니다).</target>
        </trans-unit>
        <trans-unit id="2d88168daac6375a514f336433bd215fb612a6a9" translate="yes" xml:space="preserve">
          <source>String returns the string form of n, roughly following the RFC 2253 Distinguished Names syntax.</source>
          <target state="translated">문자열은 대략 RFC 2253 식별 이름 구문에 따라 n의 문자열 형식을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="65a433aa544a0c7b3431068c5cc7f107bc02e8c8" translate="yes" xml:space="preserve">
          <source>String returns the string form of the IP address ip. It returns one of 4 forms:</source>
          <target state="translated">문자열은 IP 주소 ip의 문자열 형식을 반환합니다. 다음 4 가지 형식 중 하나를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="77e4b34a03bfe1d41ef0627a6a3eef76345118dd" translate="yes" xml:space="preserve">
          <source>String returns the string v's underlying value, as a string. String is a special case because of Go's String method convention. Unlike the other getters, it does not panic if v's Kind is not String. Instead, it returns a string of the form &quot;&amp;lt;T value&amp;gt;&quot; where T is v's type. The fmt package treats Values specially. It does not call their String method implicitly but instead prints the concrete values they hold.</source>
          <target state="translated">문자열은 문자열 v의 기본 값을 문자열로 반환합니다. 문자열은 Go의 문자열 메소드 규칙으로 인해 특별한 경우입니다. 다른 getter와 달리 v의 Kind가 String이 아닌 경우 당황하지 않습니다. 대신 &quot;&amp;lt;T value&amp;gt;&quot;형식의 문자열을 반환합니다. 여기서 T는 v 형식입니다. fmt 패키지는 값을 특별히 취급합니다. String 메서드를 암시 적으로 호출하지는 않지만 보유하고있는 구체적인 값을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="da3ada59fed13cf9c42e28f35ce824b152ed6695" translate="yes" xml:space="preserve">
          <source>String returns the time formatted using the format string</source>
          <target state="translated">문자열은 형식 문자열을 사용하여 형식화 된 시간을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7582d0695c8835ce2d6fd48b6b11691af0fd874b" translate="yes" xml:space="preserve">
          <source>String returns the value v as a string. String is a special case because of Go's String method convention. Unlike the other getters, it does not panic if v's Type is not TypeString. Instead, it returns a string of the form &quot;&amp;lt;T&amp;gt;&quot; or &quot;&amp;lt;T: V&amp;gt;&quot; where T is v's type and V is a string representation of v's value.</source>
          <target state="translated">문자열은 값 v를 문자열로 반환합니다. 문자열은 Go의 문자열 메소드 규칙으로 인해 특별한 경우입니다. 다른 getter와 달리 v의 Type이 TypeString이 아닌 경우 당황하지 않습니다. 대신 &quot;&amp;lt;T&amp;gt;&quot;또는 &quot;&amp;lt;T : V&amp;gt;&quot;형식의 문자열을 반환합니다. 여기서 T는 v의 유형이고 V는 v의 값을 나타내는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="b5780fb112a6b774b6985415c1ab7539f30b0d21" translate="yes" xml:space="preserve">
          <source>String values encode as JSON strings coerced to valid UTF-8, replacing invalid bytes with the Unicode replacement rune. So that the JSON will be safe to embed inside HTML &amp;lt;script&amp;gt; tags, the string is encoded using HTMLEscape, which replaces &quot;&amp;lt;&quot;, &quot;&amp;gt;&quot;, &quot;&amp;amp;&quot;, U+2028, and U+2029 are escaped to &quot;\u003c&quot;,&quot;\u003e&quot;, &quot;\u0026&quot;, &quot;\u2028&quot;, and &quot;\u2029&quot;. This replacement can be disabled when using an Encoder, by calling SetEscapeHTML(false).</source>
          <target state="translated">문자열 값은 유효한 UTF-8로 강제 변환 된 JSON 문자열로 인코딩되어 유효하지 않은 바이트를 유니 코드 대체 룬으로 대체합니다. JSON이 HTML &amp;lt;script&amp;gt; 태그에 안전하게 포함되도록 문자열은 HTMLEscape를 사용하여 인코딩되며 &quot;&amp;lt;&quot;, &quot;&amp;gt;&quot;, &quot;&amp;amp;&quot;, U + 2028 및 U + 2029를 &quot;\로 대체합니다. u003c &quot;,&quot;\ u003e &quot;,&quot;\ u0026 &quot;,&quot;\ u2028 &quot;및&quot;\ u2029 &quot;. 이 대체는 인코더를 사용할 때 SetEscapeHTML (false)을 호출하여 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86940bb85d221e97a38bc1e113fc6bce034c8750" translate="yes" xml:space="preserve">
          <source>StringBytePtr returns a pointer to a NUL-terminated array of bytes. If s contains a NUL byte this function panics instead of returning an error.</source>
          <target state="translated">StringBytePtr은 NUL로 끝나는 바이트 배열에 대한 포인터를 반환합니다. s에 NUL 바이트가 포함 된 경우이 함수는 오류를 반환하는 대신 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="c0623ccf68cc35082d287f89796544274ff86c91" translate="yes" xml:space="preserve">
          <source>StringByteSlice converts a string to a NUL-terminated []byte, If s contains a NUL byte this function panics instead of returning an error.</source>
          <target state="translated">StringByteSlice는 문자열을 NUL 종료 [] 바이트로 변환합니다. s에 NUL 바이트가 포함되어 있으면이 함수는 오류를 반환하는 대신 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="6bf1e10cb60d4363fb37f7da731443afa2a654e2" translate="yes" xml:space="preserve">
          <source>StringHeader is the runtime representation of a string. It cannot be used safely or portably and its representation may change in a later release. Moreover, the Data field is not sufficient to guarantee the data it references will not be garbage collected, so programs must keep a separate, correctly typed pointer to the underlying data.</source>
          <target state="translated">StringHeader는 문자열의 런타임 표현입니다. 안전하게 또는 이식 가능하게 사용할 수 없으며 이후 릴리스에서 표현이 변경 될 수 있습니다. 또한 데이터 필드는 참조하는 데이터가 가비지 수집되지 않도록 보장하기에 충분하지 않으므로 프로그램은 기본 데이터에 대해 올바르게 입력 된 별도의 포인터를 유지해야합니다.</target>
        </trans-unit>
        <trans-unit id="a97933503d7359e70c5bcc6d71f20f23e72ff484" translate="yes" xml:space="preserve">
          <source>StringNode holds a string constant. The value has been &quot;unquoted&quot;.</source>
          <target state="translated">StringNode는 문자열 상수를 보유합니다. 값이 &quot;인용되지 않았습니다&quot;.</target>
        </trans-unit>
        <trans-unit id="4e2dc56d882f4e247f4c8c91d09f7ca7c92151b0" translate="yes" xml:space="preserve">
          <source>StringSlice attaches the methods of Interface to []string, sorting in increasing order.</source>
          <target state="translated">StringSlice는 [] 문자열에 인터페이스의 메소드를 첨부하여 오름차순으로 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="0ccdd69f6b44471ac8719f7a4d5092264f1d1540" translate="yes" xml:space="preserve">
          <source>StringSlicePtr converts a slice of strings to a slice of pointers to NUL-terminated byte arrays. If any string contains a NUL byte this function panics instead of returning an error.</source>
          <target state="translated">StringSlicePtr은 문자열 조각을 NUL 종료 바이트 배열에 대한 포인터 조각으로 변환합니다. 문자열에 NUL 바이트가 포함 된 경우이 함수는 오류를 반환하는 대신 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="58cd2c4c0c64b3e8b63116e619c1216921aee8f5" translate="yes" xml:space="preserve">
          <source>StringTable is a COFF string table.</source>
          <target state="translated">StringTable은 COFF 문자열 테이블입니다.</target>
        </trans-unit>
        <trans-unit id="cf2c21cf4463c1c95fd9d9c1165bec97a40c80e4" translate="yes" xml:space="preserve">
          <source>StringVal returns the Go string value of x, which must be a String or an Unknown. If x is Unknown, the result is &quot;&quot;.</source>
          <target state="translated">StringVal은 x의 Go 문자열 값을 반환합니다.이 값은 String 또는 Unknown이어야합니다. x가 알 수없는 경우 결과는 &quot;&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="d9073eff948f092d1e822cdc4b90545ac7f58c79" translate="yes" xml:space="preserve">
          <source>StringVar defines a string flag with specified name, default value, and usage string. The argument p points to a string variable in which to store the value of the flag.</source>
          <target state="translated">StringVar는 지정된 이름, 기본값 및 사용 문자열로 문자열 플래그를 정의합니다. 인수 p는 플래그 값을 저장할 문자열 변수를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="8523e16e4f3d17cbbcc1796a5175f67569825d49" translate="yes" xml:space="preserve">
          <source>StringWriter is the interface that wraps the WriteString method.</source>
          <target state="translated">StringWriter는 WriteString 메서드를 래핑하는 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="2968f2bfae46d2fc485efc7b71be92497e030111" translate="yes" xml:space="preserve">
          <source>Stringer</source>
          <target state="translated">Stringer</target>
        </trans-unit>
        <trans-unit id="58829a9ebd1b847fb0ad45cdde0851c334ed441d" translate="yes" xml:space="preserve">
          <source>Stringer is implemented by any value that has a String method, which defines the &amp;ldquo;native&amp;rdquo; format for that value. The String method is used to print values passed as an operand to any format that accepts a string or to an unformatted printer such as Print.</source>
          <target state="translated">Stringer는 String 메소드가있는 값으로 구현되며, 해당 값의 &quot;기본&quot;형식을 정의합니다. 문자열 메소드는 문자열을 허용하는 형식이나 인쇄와 같은 형식화되지 않은 프린터에 피연산자로 전달 된 값을 인쇄하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3816c4beac471c733eed1d91c213f8c2b6a29262" translate="yes" xml:space="preserve">
          <source>Strings</source>
          <target state="translated">Strings</target>
        </trans-unit>
        <trans-unit id="6de1d7bc7d04e6a2a354d77d2ded289707802988" translate="yes" xml:space="preserve">
          <source>Strings and Bytes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="906a27ee40bd23a1553b39eb16be0c8e8ac3e949" translate="yes" xml:space="preserve">
          <source>Strings and slices of bytes are sent as an unsigned count followed by that many uninterpreted bytes of the value.</source>
          <target state="translated">문자열과 바이트 조각은 부호없는 카운트로 전송되고 그 뒤에 해석되지 않은 많은 바이트 값이 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="faac2cc38ba743bbc17ba9acb7964aa6cee65d73" translate="yes" xml:space="preserve">
          <source>Strings must be UTF-8 encoded and may only contain Unicode code points U+0001 through U+00FF, due to limitations of the GZIP file format.</source>
          <target state="translated">문자열은 UTF-8로 인코딩되어야하며 GZIP 파일 형식의 제한으로 인해 U + 0001에서 U + 00FF까지의 유니 코드 코드 포인트 만 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f76921542e09ce2202753a5d0b5a9e24e8b8a263" translate="yes" xml:space="preserve">
          <source>Strings sorts a slice of strings in increasing order.</source>
          <target state="translated">문자열은 문자열 조각을 오름차순으로 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="4e57e68cbf341e7da7b76b93c619abebcf0858af" translate="yes" xml:space="preserve">
          <source>StringsAreSorted reports whether the slice x is sorted in increasing order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d93c8594f1a8a4b01949156c04f8f3f3ae7fd2a" translate="yes" xml:space="preserve">
          <source>StringsAreSorted tests whether a slice of strings is sorted in increasing order.</source>
          <target state="translated">StringsAreSorted는 문자열 조각이 오름차순으로 정렬되는지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="13ae2dda2de94ac9d40b6ba17fece2797835c04a" translate="yes" xml:space="preserve">
          <source>StripPrefix</source>
          <target state="translated">StripPrefix</target>
        </trans-unit>
        <trans-unit id="5ba2dcca3bbae35a827418cb07ca626a1294f885" translate="yes" xml:space="preserve">
          <source>StripPrefix returns a handler that serves HTTP requests by removing the given prefix from the request URL's Path (and RawPath if set) and invoking the handler h. StripPrefix handles a request for a path that doesn't begin with prefix by replying with an HTTP 404 not found error. The prefix must match exactly: if the prefix in the request contains escaped characters the reply is also an HTTP 404 not found error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0a5f88c187543f04de90ac6fd0379250c9778df" translate="yes" xml:space="preserve">
          <source>StripPrefix returns a handler that serves HTTP requests by removing the given prefix from the request URL's Path and invoking the handler h. StripPrefix handles a request for a path that doesn't begin with prefix by replying with an HTTP 404 not found error.</source>
          <target state="translated">StripPrefix는 요청 URL의 경로에서 지정된 접 두부를 제거하고 핸들러 h를 호출하여 HTTP 요청을 처리하는 핸들러를 리턴합니다. StripPrefix는 HTTP 404를 찾을 수 없음 오류로 응답하여 접두어로 시작하지 않는 경로 요청을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="39170b61b74a11d6a192ff9863dfa73aaecba21c" translate="yes" xml:space="preserve">
          <source>Struct values are deeply equal if their corresponding fields, both exported and unexported, are deeply equal.</source>
          <target state="translated">반출 및 반출되지 않은 해당 필드가 완전히 동일한 경우 구조 값은 매우 동일합니다.</target>
        </trans-unit>
        <trans-unit id="fb5bb421400cdac0575f807d47566c64d1f46c0f" translate="yes" xml:space="preserve">
          <source>Struct values encode as JSON objects. Each exported struct field becomes a member of the object, using the field name as the object key, unless the field is omitted for one of the reasons given below.</source>
          <target state="translated">구조 값은 JSON 객체로 인코딩됩니다. 아래의 이유로 필드를 생략하지 않으면 내 보낸 각 구조체 필드는 필드 이름을 개체 키로 사용하여 개체의 멤버가됩니다.</target>
        </trans-unit>
        <trans-unit id="0b823e55e4d9782e91674576a6c2dba2dbfb679a" translate="yes" xml:space="preserve">
          <source>StructOf</source>
          <target state="translated">StructOf</target>
        </trans-unit>
        <trans-unit id="cbecd3176d1c216f7d05eaf053a4641373b34f6b" translate="yes" xml:space="preserve">
          <source>StructOf currently does not generate wrapper methods for embedded fields and panics if passed unexported StructFields. These limitations may be lifted in a future version.</source>
          <target state="translated">StructOf는 현재 내 보내지 않은 StructField를 전달한 경우 포함 된 필드 및 패닉에 대한 래퍼 메서드를 생성하지 않습니다. 이러한 제한은 향후 버전에서 해제 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e272272dfcabba6b0a57032693b1247f7d907d03" translate="yes" xml:space="preserve">
          <source>StructOf returns the struct type containing fields. The Offset and Index fields are ignored and computed as they would be by the compiler.</source>
          <target state="translated">StructOf는 필드를 포함하는 구조체 유형을 반환합니다. 오프셋 및 색인 필드는 컴파일러에서와 같이 무시되고 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="642ea82e69d222e31d0a11979f4762edc849aa8f" translate="yes" xml:space="preserve">
          <source>StructTag</source>
          <target state="translated">StructTag</target>
        </trans-unit>
        <trans-unit id="666cf050832b24dac5a22e670aae0c296886ba23" translate="yes" xml:space="preserve">
          <source>StructTag.Lookup</source>
          <target state="translated">StructTag.Lookup</target>
        </trans-unit>
        <trans-unit id="5f4f3284caaeebe32585ec344848f50378d011bc" translate="yes" xml:space="preserve">
          <source>Structs are sent as a sequence of (field number, field value) pairs. The field value is sent using the standard gob encoding for its type, recursively. If a field has the zero value for its type (except for arrays; see above), it is omitted from the transmission. The field number is defined by the type of the encoded struct: the first field of the encoded type is field 0, the second is field 1, etc. When encoding a value, the field numbers are delta encoded for efficiency and the fields are always sent in order of increasing field number; the deltas are therefore unsigned. The initialization for the delta encoding sets the field number to -1, so an unsigned integer field 0 with value 7 is transmitted as unsigned delta = 1, unsigned value = 7 or (01 07). Finally, after all the fields have been sent a terminating mark denotes the end of the struct. That mark is a delta=0 value, which has representation (00).</source>
          <target state="translated">Structs는 일련의 (필드 번호, 필드 값) 쌍으로 전송됩니다. 필드 값은 해당 유형에 대한 표준 gob 인코딩을 사용하여 재귀 적으로 전송됩니다. 필드가 해당 유형에 대해 0 값을 갖는 경우 (배열 제외; 위 참조) 전송에서 생략됩니다. 필드 번호는 인코딩 된 구조체의 유형으로 정의됩니다. 인코딩 된 유형의 첫 번째 필드는 필드 0, 두 번째는 필드 1 등입니다. 값을 인코딩 할 때 필드 번호는 효율성을 위해 델타 인코딩되며 필드는 항상 필드 번호가 증가하는 순서대로 전송됩니다. 따라서 델타는 부호가 없습니다. 델타 인코딩의 초기화는 필드 번호를 -1로 설정하므로, 값이 7 인 부호없는 정수 필드 0은 부호없는 델타 = 1, 부호없는 값 = 7 또는 (01 07)로 전송됩니다. 마지막으로, 모든 필드가 전송 된 후 종료 표시는 구조체의 끝을 나타냅니다.이 마크는 델타 = 0 값이며, 표현은 (00)입니다.</target>
        </trans-unit>
        <trans-unit id="7dc46671ebabbdf3c46aadccd97f8c490eefc52c" translate="yes" xml:space="preserve">
          <source>Structs, arrays and slices are also supported. Structs encode and decode only exported fields. Strings and arrays of bytes are supported with a special, efficient representation (see below). When a slice is decoded, if the existing slice has capacity the slice will be extended in place; if not, a new array is allocated. Regardless, the length of the resulting slice reports the number of elements decoded.</source>
          <target state="translated">구조, 배열 및 슬라이스도 지원됩니다. Structs는 내 보낸 필드 만 인코딩하고 디코딩합니다. 문자열과 바이트 배열은 특별하고 효율적인 표현으로 지원됩니다 (아래 참조). 슬라이스가 디코딩 될 때, 기존 슬라이스가 용량을 가지면 슬라이스가 제자리에 확장됩니다. 그렇지 않은 경우 새 배열이 할당됩니다. 어쨌든, 결과 슬라이스의 길이는 디코딩 된 요소의 수를보고합니다.</target>
        </trans-unit>
        <trans-unit id="ad78f09f9c6b3087d8e72e4530ecc70c4956979a" translate="yes" xml:space="preserve">
          <source>Structure Preservation Property: &quot;... when a template author writes an HTML tag in a safe templating language, the browser will interpret the corresponding portion of the output as a tag regardless of the values of untrusted data, and similarly for other structures such as attribute boundaries and JS and CSS string boundaries.&quot;</source>
          <target state="translated">구조 보존 속성 : &quot;... 템플릿 작성자가 안전한 템플릿 언어로 HTML 태그를 작성할 때 브라우저는 신뢰할 수없는 데이터의 값과 상관없이 출력의 해당 부분을 태그로 해석합니다. 속성 경계와 JS 및 CSS 문자열 경계. &quot;</target>
        </trans-unit>
        <trans-unit id="513360eae171b460c616fcd92bc1621ed2cc2ad5" translate="yes" xml:space="preserve">
          <source>Sub returns an FS corresponding to the subtree rooted at fsys's dir.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3c9ca613cd987d897ef5275ec8d3b6be7186d1f" translate="yes" xml:space="preserve">
          <source>Sub returns the difference of x, y and borrow: diff = x - y - borrow. The borrow input must be 0 or 1; otherwise the behavior is undefined. The borrowOut output is guaranteed to be 0 or 1.</source>
          <target state="translated">Sub는 x, y 및 차용의 차이를 반환합니다. diff = x-y-차용. 차용 입력은 0 또는 1이어야합니다. 그렇지 않으면 동작이 정의되지 않습니다. 차용 출력은 0 또는 1로 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="61c41cb657724bf35da0dad82b0d5dee3326e95d" translate="yes" xml:space="preserve">
          <source>Sub returns the duration t-u. If the result exceeds the maximum (or minimum) value that can be stored in a Duration, the maximum (or minimum) duration will be returned. To compute t-d for a duration d, use t.Add(-d).</source>
          <target state="translated">Sub는 기간 tu를 반환합니다. 결과가 Duration에 저장할 수있는 최대 (또는 최소) 값을 초과하면 최대 (또는 최소) 지속 시간이 반환됩니다. 지속 시간 d 동안 td를 계산하려면 t.Add (-d)를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9a9cccdf849236c7b5afc32fedeaf0e730cf15fd" translate="yes" xml:space="preserve">
          <source>Sub returns the rectangle r translated by -p.</source>
          <target state="translated">Sub는 -p로 변환 된 사각형 r을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c74b307e6862c7c0fdbabb48e4f241316eca6f53" translate="yes" xml:space="preserve">
          <source>Sub returns the vector p-q.</source>
          <target state="translated">Sub는 벡터 pq를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2660992e01b4593ff7e0d2ea96dbc6a6fcdbbc82" translate="yes" xml:space="preserve">
          <source>Sub sets z to the difference x-y and returns z.</source>
          <target state="translated">Sub는 z를 차이 xy로 설정하고 z를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="07c120e2c4cb601d9bfe9da745d95ee84f5c8f23" translate="yes" xml:space="preserve">
          <source>Sub sets z to the rounded difference x-y and returns z. Precision, rounding, and accuracy reporting are as for Add. Sub panics with ErrNaN if x and y are infinities with equal signs. The value of z is undefined in that case.</source>
          <target state="translated">Sub는 z를 둥근 차이 xy로 설정하고 z를 반환합니다. 정밀도, 반올림 및 정확도보고는 추가와 같습니다. x와 y가 같은 부호를 갖는 무한대 인 경우 ErrNaN을 사용한 하위 패닉. 이 경우 z 값은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="821524c66883b61b23da230e1f7ac6f247b61c28" translate="yes" xml:space="preserve">
          <source>Sub-repositories</source>
          <target state="translated">Sub-repositories</target>
        </trans-unit>
        <trans-unit id="027b254161eaa851d3de87e3e3811c330b4b1cfe" translate="yes" xml:space="preserve">
          <source>Sub32 returns the difference of x, y and borrow, diff = x - y - borrow. The borrow input must be 0 or 1; otherwise the behavior is undefined. The borrowOut output is guaranteed to be 0 or 1.</source>
          <target state="translated">Sub32는 x, y 및 차용, diff = x-y-차용의 차이를 반환합니다. 차용 입력은 0 또는 1이어야합니다. 그렇지 않으면 동작이 정의되지 않습니다. 차용 출력은 0 또는 1로 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="19abe5243ff65ef214d8cfd1ed7dd0d253eaaf1e" translate="yes" xml:space="preserve">
          <source>Sub64 returns the difference of x, y and borrow: diff = x - y - borrow. The borrow input must be 0 or 1; otherwise the behavior is undefined. The borrowOut output is guaranteed to be 0 or 1.</source>
          <target state="translated">Sub64는 x, y 및 차용의 차이를 반환합니다. diff = x-y-차용. 차용 입력은 0 또는 1이어야합니다. 그렇지 않으면 동작이 정의되지 않습니다. 차용 출력은 0 또는 1로 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="3fc6e21e27e1d98c4a46c59e21cbbbe634de9bcb" translate="yes" xml:space="preserve">
          <source>SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image.</source>
          <target state="translated">SubImage는 r을 통해 보이는 이미지 p의 일부를 나타내는 이미지를 반환합니다. 반환 된 값은 원본 이미지와 픽셀을 공유합니다.</target>
        </trans-unit>
        <trans-unit id="19b094dbedb2add32a27c12c5c0b06b9d304fb7c" translate="yes" xml:space="preserve">
          <source>Subdirectories</source>
          <target state="translated">Subdirectories</target>
        </trans-unit>
        <trans-unit id="73a30231d9aabf0592839371dc3542545b7db703" translate="yes" xml:space="preserve">
          <source>SubexpIndex returns the index of the first subexpression with the given name, or -1 if there is no subexpression with that name.</source>
          <target state="translated">SubexpIndex는 주어진 이름의 첫 번째 하위 표현식의 색인을 반환하거나 해당 이름의 하위 표현식이없는 경우 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="abb46f6f4b961e90d924a27858c117c84efd6aae" translate="yes" xml:space="preserve">
          <source>SubexpNames returns the names of the parenthesized subexpressions in this Regexp. The name for the first sub-expression is names[1], so that if m is a match slice, the name for m[i] is SubexpNames()[i]. Since the Regexp as a whole cannot be named, names[0] is always the empty string. The slice should not be modified.</source>
          <target state="translated">SubexpNames는이 Regexp에서 괄호로 묶인 하위 표현식의 이름을 리턴합니다. 첫 번째 하위 표현식의 이름은 names [1]이므로 m이 일치 슬라이스 인 경우 m [i]의 이름은 SubexpNames () [i]입니다. 전체적으로 정규 표현식의 이름을 지정할 수 없으므로 names [0]은 항상 빈 문자열입니다. 슬라이스를 수정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="c9c047b864469812cfb4b3b886d30b5376a4d0df" translate="yes" xml:space="preserve">
          <source>Subjects returns a list of the DER-encoded subjects of all of the certificates in the pool.</source>
          <target state="translated">주체는 풀에있는 모든 인증서의 DER 인코딩 된 주체 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="91e8bbbf1ff4c8e821148581549206c9787e494e" translate="yes" xml:space="preserve">
          <source>Subtests and Sub-benchmarks</source>
          <target state="translated">하위 테스트 및 하위 벤치 마크</target>
        </trans-unit>
        <trans-unit id="05cc8697fcb7ccef149a7858e8bd798cb2cd774f" translate="yes" xml:space="preserve">
          <source>Subtests can also be used to control parallelism. A parent test will only complete once all of its subtests complete. In this example, all tests are run in parallel with each other, and only with each other, regardless of other top-level tests that may be defined:</source>
          <target state="translated">하위 테스트를 사용하여 병렬 처리를 제어 할 수도 있습니다. 부모 테스트는 모든 하위 테스트가 완료된 후에 만 ​​완료됩니다. 이 예제에서 정의 할 수있는 다른 최상위 테스트에 관계없이 모든 테스트는 서로 병렬로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="bb672ca35fe1893eef6f12fcd0a8efff47a2478c" translate="yes" xml:space="preserve">
          <source>Success reports whether the program exited successfully, such as with exit status 0 on Unix.</source>
          <target state="translated">성공은 Unix에서 종료 상태 0과 같이 프로그램이 성공적으로 종료되었는지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="07eda2eb03735678c89d2490ea6410dd3ad1a43b" translate="yes" xml:space="preserve">
          <source>Such a file is usually paired with another file implementing the default functionality for other systems, which in this case would carry the constraint:</source>
          <target state="translated">이러한 파일은 일반적으로 다른 시스템의 기본 기능을 구현하는 다른 파일과 쌍을 이루어이 경우 제약 조건이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="fc9ce14b28c6f2c3b72caf056ca604b2b96f7d2b" translate="yes" xml:space="preserve">
          <source>Sum</source>
          <target state="translated">Sum</target>
        </trans-unit>
        <trans-unit id="2307e80c75af1c4de56c67f7a9ea0bffff7083aa" translate="yes" xml:space="preserve">
          <source>Sum appends the hash's current 64-bit value to b. It exists for implementing hash.Hash. For direct calls, it is more efficient to use Sum64.</source>
          <target state="translated">Sum은 해시의 현재 64 비트 값을 b에 추가합니다. hash.Hash를 구현하기 위해 존재합니다. 직접 통화의 경우 Sum64를 사용하는 것이 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="1037d5e9f233e3f6a6a25104581ccd4bbd6ac1c7" translate="yes" xml:space="preserve">
          <source>Sum returns the MD5 checksum of the data.</source>
          <target state="translated">Sum은 데이터의 MD5 체크섬을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d8eeaf2ada0e780d70b60f2e9edbd46ef59d4a13" translate="yes" xml:space="preserve">
          <source>Sum returns the SHA-1 checksum of the data.</source>
          <target state="translated">Sum은 데이터의 SHA-1 체크섬을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0dca98b14fcbfeb34897e7396c1a6dfa98d521b4" translate="yes" xml:space="preserve">
          <source>Sum224 returns the SHA224 checksum of the data.</source>
          <target state="translated">Sum224는 데이터의 SHA224 체크섬을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ba05916088015c0f1b00b88d9415ebfa726370d8" translate="yes" xml:space="preserve">
          <source>Sum256</source>
          <target state="translated">Sum256</target>
        </trans-unit>
        <trans-unit id="087b1fabd67b489187e993cab88dfd4147ea385d" translate="yes" xml:space="preserve">
          <source>Sum256 returns the SHA256 checksum of the data.</source>
          <target state="translated">Sum256은 데이터의 SHA256 체크섬을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6bd95a96de2d8140b4ada3f2d7b194594facee01" translate="yes" xml:space="preserve">
          <source>Sum384 returns the SHA384 checksum of the data.</source>
          <target state="translated">Sum384는 데이터의 SHA384 체크섬을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bf1f6e0b5ced478fca66b19297a0e98baeedd390" translate="yes" xml:space="preserve">
          <source>Sum512 returns the SHA512 checksum of the data.</source>
          <target state="translated">Sum512는 데이터의 SHA512 체크섬을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3357361c0e72e316aab24916d39ed7d14bdb335d" translate="yes" xml:space="preserve">
          <source>Sum512_224 returns the Sum512/224 checksum of the data.</source>
          <target state="translated">Sum512_224는 데이터의 Sum512 / 224 체크섬을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ff71eecde6b5c686475ebd821438cf7dd50ffe32" translate="yes" xml:space="preserve">
          <source>Sum512_256 returns the Sum512/256 checksum of the data.</source>
          <target state="translated">Sum512_256은 데이터의 Sum512 / 256 체크섬을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8473e2e1004301cd370598216fa62dc426cca789" translate="yes" xml:space="preserve">
          <source>Sum64 returns h's current 64-bit value, which depends on h's seed and the sequence of bytes added to h since the last call to Reset or SetSeed.</source>
          <target state="translated">Sum64는 h의 시드와 Reset 또는 SetSeed에 대한 마지막 호출 이후 h에 추가 된 바이트 시퀀스에 따라 달라지는 h의 현재 64 비트 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4442b8443612835fd9bd367eb3496bb5cfec606a" translate="yes" xml:space="preserve">
          <source>Support for tracing tests and benchmarks built with the standard testing package is built into `go test`. For example, the following command runs the test in the current directory and writes the trace file (trace.out).</source>
          <target state="translated">표준 테스트 패키지로 구축 된 추적 테스트 및 벤치 마크 지원은`go test`에 내장되어 있습니다. 예를 들어 다음 명령은 현재 디렉토리에서 테스트를 실행하고 추적 파일 (trace.out)을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="05492c0a57ea2d63ba2b476c7222b6bcdddbb676" translate="yes" xml:space="preserve">
          <source>Supported architectures for compiler &quot;gc&quot;: &quot;386&quot;, &quot;arm&quot;, &quot;arm64&quot;, &quot;amd64&quot;, &quot;amd64p32&quot;, &quot;mips&quot;, &quot;mipsle&quot;, &quot;mips64&quot;, &quot;mips64le&quot;, &quot;ppc64&quot;, &quot;ppc64le&quot;, &quot;riscv64&quot;, &quot;s390x&quot;, &quot;sparc64&quot;, &quot;wasm&quot;.</source>
          <target state="translated">컴파일러 &quot;gc&quot;에 지원되는 아키텍처 : &quot;386&quot;, &quot;arm&quot;, &quot;arm64&quot;, &quot;amd64&quot;, &quot;amd64p32&quot;, &quot;mips&quot;, &quot;mipsle&quot;, &quot;mips64&quot;, &quot;mips64le&quot;, &quot;ppc64&quot;, &quot;ppc64le &quot;,&quot;riscv64 &quot;,&quot;s390x &quot;,&quot;sparc64 &quot;,&quot;wasm &quot;.</target>
        </trans-unit>
        <trans-unit id="666c0c52700d4610d711d3fb7958b9574f8a15e7" translate="yes" xml:space="preserve">
          <source>Supported metrics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bd4d45ed11fa0b050a34198a5d7a561630a107e" translate="yes" xml:space="preserve">
          <source>SupportsCertificate returns nil if the provided certificate is supported by the client that sent the ClientHello. Otherwise, it returns an error describing the reason for the incompatibility.</source>
          <target state="translated">SupportsCertificate는 ClientHello를 보낸 클라이언트가 제공된 인증서를 지원하는 경우 nil을 반환합니다. 그렇지 않으면 비 호환성 이유를 설명하는 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="91f216722ea67774c646ac48a3a778f2005845b0" translate="yes" xml:space="preserve">
          <source>SupportsCertificate returns nil if the provided certificate is supported by the server that sent the CertificateRequest. Otherwise, it returns an error describing the reason for the incompatibility.</source>
          <target state="translated">SupportsCertificate는 제공된 인증서가 CertificateRequest를 보낸 서버에서 지원되는 경우 nil을 반환합니다. 그렇지 않으면 비 호환성 이유를 설명하는 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e8b59b633a995b7dd6a0e84deb15f21ce9bf242a" translate="yes" xml:space="preserve">
          <source>SwapInt32 atomically stores new into *addr and returns the previous *addr value.</source>
          <target state="translated">SwapInt32는 * addr에 새로운 것을 원자 적으로 저장하고 이전 * addr 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="96490065dc4e2e645c8a89627e673eb95f4aaa28" translate="yes" xml:space="preserve">
          <source>SwapInt64 atomically stores new into *addr and returns the previous *addr value.</source>
          <target state="translated">SwapInt64는 * addr에 새로운 것을 원자 적으로 저장하고 이전 * addr 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="da115593d3ae663bb42ff237dd86576dfdedf6ad" translate="yes" xml:space="preserve">
          <source>SwapPointer atomically stores new into *addr and returns the previous *addr value.</source>
          <target state="translated">SwapPointer는 원자 적으로 new를 * addr에 저장하고 이전 * addr 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="0c0f6214095877962c7da65a2c141bf3b6cbecc8" translate="yes" xml:space="preserve">
          <source>SwapUint32 atomically stores new into *addr and returns the previous *addr value.</source>
          <target state="translated">SwapUint32는 * addr에 새로운 것을 원자 적으로 저장하고 이전 * addr 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="899e9c7e854930b5577e53934a16009339f15457" translate="yes" xml:space="preserve">
          <source>SwapUint64 atomically stores new into *addr and returns the previous *addr value.</source>
          <target state="translated">SwapUint64는 * addr에 새로운 것을 원자 적으로 저장하고 이전 * addr 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="18cdfb91a16523313759a1c794de0eb9712ac2b2" translate="yes" xml:space="preserve">
          <source>SwapUintptr atomically stores new into *addr and returns the previous *addr value.</source>
          <target state="translated">SwapUintptr은 * addr에 new를 원자 적으로 저장하고 이전 * addr 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="5c2b73e847c3ed8be17c9afe2788c2fedb5bc635" translate="yes" xml:space="preserve">
          <source>Swapper panics if the provided interface is not a slice.</source>
          <target state="translated">제공된 인터페이스가 슬라이스가 아닌 경우 스위퍼 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0485bba36620f415adb72d21b9eac171cd9aadf1" translate="yes" xml:space="preserve">
          <source>Swapper returns a function that swaps the elements in the provided slice.</source>
          <target state="translated">Swapper는 제공된 슬라이스의 요소를 바꾸는 함수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="baf85dad7e64d73c6dc3f04eb46803a601b907a7" translate="yes" xml:space="preserve">
          <source>SymByAddr returns the text, data, or bss symbol starting at the given address.</source>
          <target state="translated">SymByAddr은 주어진 주소에서 시작하는 텍스트, 데이터 또는 bss 기호를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e6a580ed077335806f8a72f4c91bc2108aa36618" translate="yes" xml:space="preserve">
          <source>Symbol Binding - ELFNN_ST_BIND - st_info</source>
          <target state="translated">심볼 바인딩-ELFNN_ST_BIND-st_info</target>
        </trans-unit>
        <trans-unit id="998290f1606e44ec99b08646525255987ca67dd9" translate="yes" xml:space="preserve">
          <source>Symbol is similar to COFFSymbol with Name field replaced by Go string. Symbol also does not have NumberOfAuxSymbols.</source>
          <target state="translated">기호는 이름 필드가 Go 문자열로 대체 된 COFFSymbol과 유사합니다. Symbol에는 NumberOfAuxSymbols도 없습니다.</target>
        </trans-unit>
        <trans-unit id="e746caac18fb8c9ece11fba1c3858dd24402cee1" translate="yes" xml:space="preserve">
          <source>Symbol looks up the program counters listed in the request, responding with a table mapping program counters to function names. The package initialization registers it as /debug/pprof/symbol.</source>
          <target state="translated">Symbol은 요청에 나열된 프로그램 카운터를 찾고 함수 이름에 대한 테이블 맵핑 프로그램 카운터로 응답합니다. 패키지 초기화는이를 / debug / pprof / symbol로 등록합니다.</target>
        </trans-unit>
        <trans-unit id="9183912a1c8677ccbfeafe4a95bb81fdaf9d6c67" translate="yes" xml:space="preserve">
          <source>Symbol type - ELFNN_ST_TYPE - st_info</source>
          <target state="translated">심볼 유형-ELFNN_ST_TYPE-st_info</target>
        </trans-unit>
        <trans-unit id="300ae1bf65f5418188fead7a4f6227a1a8cb17ab" translate="yes" xml:space="preserve">
          <source>Symbol visibility - ELFNN_ST_VISIBILITY - st_other</source>
          <target state="translated">기호 표시-ELFNN_ST_VISIBILITY-st_other</target>
        </trans-unit>
        <trans-unit id="e0dd57ca387a759e2499962eadf5f79f0eaa8ee2" translate="yes" xml:space="preserve">
          <source>Symbols returns the symbol table for f.</source>
          <target state="translated">기호는 f에 대한 기호 테이블을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="40ab78f946263d95260d4886b240965a4da98f61" translate="yes" xml:space="preserve">
          <source>Symbols returns the symbol table for f. The symbols will be listed in the order they appear in f.</source>
          <target state="translated">기호는 f에 대한 기호 테이블을 반환합니다. 기호는 f에 표시된 순서대로 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="2377d81c04be24a887c20fd3bd69bc0f09f37db5" translate="yes" xml:space="preserve">
          <source>Symlink creates newname as a symbolic link to oldname. If there is an error, it will be of type *LinkError.</source>
          <target state="translated">Symlink는 newname을 oldname에 대한 심볼릭 링크로 만듭니다. 오류가 있으면 * LinkError 유형입니다.</target>
        </trans-unit>
        <trans-unit id="0aceec11151392e3e912ee288231038c58c328b4" translate="yes" xml:space="preserve">
          <source>Sync commits the current contents of the file to stable storage. Typically, this means flushing the file system's in-memory copy of recently written data to disk.</source>
          <target state="translated">동기화는 파일의 현재 내용을 안정적인 저장소에 커밋합니다. 일반적으로 이것은 파일 시스템의 메모리에 최근에 기록 된 데이터의 사본을 디스크로 플러시하는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="e15b4a502540aca9807844244039f56ac0ff96c5" translate="yes" xml:space="preserve">
          <source>Synchronous signals are signals triggered by errors in program execution: SIGBUS, SIGFPE, and SIGSEGV. These are only considered synchronous when caused by program execution, not when sent using os.Process.Kill or the kill program or some similar mechanism. In general, except as discussed below, Go programs will convert a synchronous signal into a run-time panic.</source>
          <target state="translated">동기 신호는 프로그램 실행 오류 SIGBUS, SIGFPE 및 SIGSEGV에 의해 트리거되는 신호입니다. os.Process.Kill 또는 kill 프로그램 또는 이와 유사한 메커니즘을 사용하여 전송 된 경우가 아니라 프로그램 실행으로 인해 발생하는 경우에만 동기로 간주됩니다. 일반적으로 아래 설명 된 것을 제외하고 Go 프로그램은 동기 신호를 런타임 패닉으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="36c0630a340d2960affa1c4d2360b0e2c06793fb" translate="yes" xml:space="preserve">
          <source>Synopsis</source>
          <target state="translated">Synopsis</target>
        </trans-unit>
        <trans-unit id="14251985329004226786245f7238c38c1ab2c9f9" translate="yes" xml:space="preserve">
          <source>Synopsis returns a cleaned version of the first sentence in s. That sentence ends after the first period followed by space and not preceded by exactly one uppercase letter. The result string has no \n, \r, or \t characters and uses only single spaces between words. If s starts with any of the IllegalPrefixes, the result is the empty string.</source>
          <target state="translated">개요는 첫 번째 문장의 정리 된 버전을 s로 반환합니다. 이 문장은 첫 번째 마침표 뒤에 공백으로 끝나고 정확히 하나의 대문자가 앞에 오지 않습니다. 결과 문자열에는 \ n, \ r 또는 \ t 문자가 없으며 단어 사이에 단일 공백 ​​만 사용합니다. s가 IllegalPrefixes로 시작하면 결과는 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="17c7ba7676ad1ad6dd1c4e6b997adcae910262c9" translate="yes" xml:space="preserve">
          <source>Syntax</source>
          <target state="translated">Syntax</target>
        </trans-unit>
        <trans-unit id="94881bde696c81108db9e992f3357d3d70383bb4" translate="yes" xml:space="preserve">
          <source>Sys returns system-dependent exit information about the process. Convert it to the appropriate underlying type, such as syscall.WaitStatus on Unix, to access its contents.</source>
          <target state="translated">Sys는 프로세스에 대한 시스템 종속 종료 정보를 리턴합니다. 컨텐츠에 액세스하려면 Unix의 syscall.WaitStatus와 같은 적절한 기본 유형으로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="ce82965024d89928bce7d20275a546fd15078072" translate="yes" xml:space="preserve">
          <source>SysProcIDMap holds Container ID to Host ID mappings used for User Namespaces in Linux. See user_namespaces(7).</source>
          <target state="translated">SysProcIDMap은 Linux에서 사용자 네임 스페이스에 사용되는 컨테이너 ID 대 호스트 ID 맵핑을 보유합니다. user_namespaces (7)를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8ffbaaa01464f1d0b5846f06e745037abe0d8cb8" translate="yes" xml:space="preserve">
          <source>SysUsage returns system-dependent resource usage information about the exited process. Convert it to the appropriate underlying type, such as *syscall.Rusage on Unix, to access its contents. (On Unix, *syscall.Rusage matches struct rusage as defined in the getrusage(2) manual page.)</source>
          <target state="translated">SysUsage는 종료 된 프로세스에 대한 시스템 종속 자원 사용 정보를 리턴합니다. 컨텐츠에 액세스하려면 Unix의 * syscall.Rusage와 같은 적절한 기본 유형으로 변환하십시오. Unix에서 * syscall.Rusage는 getrusage (2) 매뉴얼 페이지에 정의 된대로 struct rusage와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="e293cc54d1f1c47b6fdb1085033440055e2faa2b" translate="yes" xml:space="preserve">
          <source>SyscallConn returns a raw file. This implements the syscall.Conn interface.</source>
          <target state="translated">SyscallConn은 원시 파일을 반환합니다. syscall.Conn 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="93d325a9a596e81112db1a88f6cf17706c8e91ec" translate="yes" xml:space="preserve">
          <source>SyscallConn returns a raw network connection. This implements the syscall.Conn interface.</source>
          <target state="translated">SyscallConn은 원시 네트워크 연결을 반환합니다. syscall.Conn 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="aa615b3f3de4dc13fa4173050b52db98916467bd" translate="yes" xml:space="preserve">
          <source>SyscallError records an error from a specific system call.</source>
          <target state="translated">SyscallError는 특정 시스템 호출의 오류를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="de57d6136b78d4b44c51a17ce5f47f730586e6a6" translate="yes" xml:space="preserve">
          <source>SystemCertPool returns a copy of the system cert pool.</source>
          <target state="translated">SystemCertPool은 시스템 인증서 풀의 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5bc8f6a9ab808b5aa99fa9f5b51afdf83e241a9c" translate="yes" xml:space="preserve">
          <source>SystemRootsError results when we fail to load the system root certificates.</source>
          <target state="translated">시스템 루트 인증서를로드하지 못하면 SystemRootsError가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="326b735dbfcf185462598a45a443d5db5a2c18cd" translate="yes" xml:space="preserve">
          <source>SystemTime returns the system CPU time of the exited process and its children.</source>
          <target state="translated">SystemTime은 종료 된 프로세스 및 해당 자식의 시스템 CPU 시간을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="45c7796c7458dc5d46d3bad14455a8811762231d" translate="yes" xml:space="preserve">
          <source>T is a type passed to Test functions to manage test state and support formatted test logs.</source>
          <target state="translated">T는 테스트 상태를 관리하고 형식화 된 테스트 로그를 지원하기 위해 테스트 함수에 전달되는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="bd9dc41e485032cb18e9d13d513ba555be1b33c2" translate="yes" xml:space="preserve">
          <source>T is a type passed to Test functions to manage test state and support formatted test logs. Logs are accumulated during execution and dumped to standard output when done.</source>
          <target state="translated">T는 테스트 상태를 관리하고 형식화 된 테스트 로그를 지원하기 위해 테스트 기능에 전달되는 유형입니다. 실행 중에 로그가 누적되고 완료되면 표준 출력으로 덤프됩니다.</target>
        </trans-unit>
        <trans-unit id="d71f7f3fa4e9f0ba0065f39db28f69d358c4b941" translate="yes" xml:space="preserve">
          <source>TB is the interface common to T and B.</source>
          <target state="translated">TB는 T와 B에 공통적 인 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="671a2dd281c27979f8b5f140c5da50e321430a64" translate="yes" xml:space="preserve">
          <source>TBSCertificateList represents the ASN.1 structure of the same name. See RFC 5280, section 5.1.</source>
          <target state="translated">TBSCertificateList는 동일한 이름의 ASN.1 구조를 나타냅니다. RFC 5280, 섹션 5.1을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2984ada09d0c49745872575be1763fe615cf3de7" translate="yes" xml:space="preserve">
          <source>TCPAddr represents the address of a TCP end point.</source>
          <target state="translated">TCPAddr은 TCP 엔드 포인트의 주소를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="623c2c8aa88d77780fe4e0bcba75694b81bcf2ad" translate="yes" xml:space="preserve">
          <source>TCPConn is an implementation of the Conn interface for TCP network connections.</source>
          <target state="translated">TCPConn은 TCP 네트워크 연결을위한 Conn 인터페이스의 구현입니다.</target>
        </trans-unit>
        <trans-unit id="1bbfc48812fe8aa4d93c086976c0d5cdc5424e43" translate="yes" xml:space="preserve">
          <source>TCPListener is a TCP network listener. Clients should typically use variables of type Listener instead of assuming TCP.</source>
          <target state="translated">TCPListener는 TCP 네트워크 수신기입니다. 클라이언트는 일반적으로 TCP를 가정하는 대신 리스너 유형의 변수를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="c0df2a7fffd9d8cf03b29589d0b72452730e5dd3" translate="yes" xml:space="preserve">
          <source>TLS 1.3 is available on an opt-out basis in Go 1.13. To disable it, set the GODEBUG environment variable (comma-separated key=value options) such that it includes &quot;tls13=0&quot;.</source>
          <target state="translated">TLS 1.3은 Go 1.13에서 옵트 아웃 방식으로 제공됩니다. 사용하지 않으려면 &quot;tls13 = 0&quot;을 포함하도록 GODEBUG 환경 변수 (쉼표로 구분 된 키 = 값 옵션)를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="daa5896e5821b88d0d9b26d2bc85c2d021b848c8" translate="yes" xml:space="preserve">
          <source>TLSConnectionState returns the client's TLS connection state. The return values are their zero values if StartTLS did not succeed.</source>
          <target state="translated">TLSConnectionState는 클라이언트의 TLS 연결 상태를 반환합니다. StartTLS가 실패한 경우 리턴 값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="ed012370216d609d48fc2b869f8a011268923cad" translate="yes" xml:space="preserve">
          <source>TODO returns a non-nil, empty Context. Code should use context.TODO when it's unclear which Context to use or it is not yet available (because the surrounding function has not yet been extended to accept a Context parameter).</source>
          <target state="translated">TODO는 비어 있지 않은 빈 컨텍스트를 반환합니다. 사용할 컨텍스트가 확실하지 않거나 아직 사용할 수없는 경우 코드는 context.TODO를 사용해야합니다 (주변 함수가 아직 컨텍스트 매개 변수를 허용하도록 확장되지 않았기 때문에).</target>
        </trans-unit>
        <trans-unit id="1f541ebdf888dacb11e44ff51c13846474081ba9" translate="yes" xml:space="preserve">
          <source>Tab-terminated cells in contiguous lines constitute a column. The Writer inserts padding as needed to make all cells in a column have the same width, effectively aligning the columns. It assumes that all characters have the same width, except for tabs for which a tabwidth must be specified. Column cells must be tab-terminated, not tab-separated: non-tab terminated trailing text at the end of a line forms a cell but that cell is not part of an aligned column. For instance, in this example (where | stands for a horizontal tab):</source>
          <target state="translated">인접한 줄의 탭으로 끝나는 셀이 열을 구성합니다. Writer는 열의 모든 셀이 동일한 너비를 가지도록 효과적으로 패딩을 삽입하여 열을 효과적으로 정렬합니다. tabwidth를 지정해야하는 탭을 제외하고 모든 문자의 너비가 동일하다고 가정합니다. 열 셀은 탭으로 구분되지 않고 탭으로 끝나야합니다. 줄 끝에서 탭으로 끝나지 않는 후행 텍스트는 셀을 형성하지만 해당 셀은 정렬 된 열의 일부가 아닙니다. 예를 들어,이 예에서 | |는 가로 탭을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9baa6d565b56c1e4861e3df81a8fd8df65d699d4" translate="yes" xml:space="preserve">
          <source>Table 1 in [2] suggests maximum numbers of primes for a given size.</source>
          <target state="translated">[2]의 표 1은 주어진 크기에 대한 최대 소수의 수를 제안합니다.</target>
        </trans-unit>
        <trans-unit id="ba3ee22bd3b233bdb404d63bfe71ba0cb11ae0a4" translate="yes" xml:space="preserve">
          <source>Table is a 256-word table representing the polynomial for efficient processing.</source>
          <target state="translated">Table은 효율적인 처리를위한 다항식을 나타내는 256 워드 테이블입니다.</target>
        </trans-unit>
        <trans-unit id="599b448991ae5ae6d130b6356ce6b00630c5cefb" translate="yes" xml:space="preserve">
          <source>Table represents a Go symbol table. It stores all of the symbols decoded from the program and provides methods to translate between symbols, names, and addresses.</source>
          <target state="translated">표는 이동 기호 표를 나타냅니다. 프로그램에서 디코딩 된 모든 심볼을 저장하고 심볼, 이름 및 주소 간을 변환하는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bfc4ba347929d28c193a400550bae587488f16cd" translate="yes" xml:space="preserve">
          <source>Tag returns the i'th field tag for 0 &amp;lt;= i &amp;lt; NumFields().</source>
          <target state="translated">Tag는 0 &amp;lt;= i &amp;lt;NumFields ()에 대한 i 번째 필드 태그를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7a39b84c91d8c550355f46b331fdfde2ffca5ba7" translate="yes" xml:space="preserve">
          <source>Tag sizes between 12 and 16 bytes are allowed.</source>
          <target state="translated">12-16 바이트 사이의 태그 크기가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="9dda0ce21be12978cbb42d63ed48bd36a71555e8" translate="yes" xml:space="preserve">
          <source>Taken from &lt;a href=&quot;https://www.iana.org/assignments/tls-parameters/tls-parameters.xml&quot;&gt;https://www.iana.org/assignments/tls-parameters/tls-parameters.xml&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://www.iana.org/assignments/tls-parameters/tls-parameters.xml&quot;&gt;https://www.iana.org/assignments/tls-parameters/tls-parameters.xml&lt;/a&gt; 에서 가져옴</target>
        </trans-unit>
        <trans-unit id="133552ebfbcce8310f8920695422699d5256bac9" translate="yes" xml:space="preserve">
          <source>Tan</source>
          <target state="translated">Tan</target>
        </trans-unit>
        <trans-unit id="c442668b04fe0d2fb49d4d83b1b51198b583f812" translate="yes" xml:space="preserve">
          <source>Tan returns the tangent of the radian argument x.</source>
          <target state="translated">Tan은 라디안 인수 x의 탄젠트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9f8f5243ed4843c5154158c2ff20cd9a586739e0" translate="yes" xml:space="preserve">
          <source>Tan returns the tangent of x.</source>
          <target state="translated">Tan은 x의 탄젠트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="19bff9fbbbadd7b339e0ee0ae1715d62fea9cae0" translate="yes" xml:space="preserve">
          <source>Tanh</source>
          <target state="translated">Tanh</target>
        </trans-unit>
        <trans-unit id="dc8ae90d27ce708b07a5ac10906ccc3ed208c4a5" translate="yes" xml:space="preserve">
          <source>Tanh returns the hyperbolic tangent of x.</source>
          <target state="translated">Tanh는 x의 쌍곡 탄젠트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6f0a22a02d454a68d024fa67fa9340156799d88b" translate="yes" xml:space="preserve">
          <source>Tape archives (tar) are a file format for storing a sequence of files that can be read and written in a streaming manner. This package aims to cover most variations of the format, including those produced by GNU and BSD tar tools.</source>
          <target state="translated">테이프 아카이브 (tar)는 스트리밍 방식으로 읽고 쓸 수있는 일련의 파일을 저장하기위한 파일 형식입니다. 이 패키지는 GNU 및 BSD tar 도구로 작성된 형식을 포함하여 대부분의 형식을 다루는 것을 목표로합니다.</target>
        </trans-unit>
        <trans-unit id="f11f02db734667c97fad6ffb5c8e393a00b87399" translate="yes" xml:space="preserve">
          <source>Task is a data type for tracing a user-defined, logical operation.</source>
          <target state="translated">작업은 사용자 정의 논리 연산을 추적하기위한 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="a9e55d223a3d4713691d397b40624caef60d5252" translate="yes" xml:space="preserve">
          <source>TeeReader</source>
          <target state="translated">TeeReader</target>
        </trans-unit>
        <trans-unit id="c3ce03ea658d6ce846ba37ed8673f608fd0ba578" translate="yes" xml:space="preserve">
          <source>TeeReader returns a Reader that writes to w what it reads from r. All reads from r performed through it are matched with corresponding writes to w. There is no internal buffering - the write must complete before the read completes. Any error encountered while writing is reported as a read error.</source>
          <target state="translated">TeeReader는 r에서 읽은 내용을 w에 쓰는 Reader를 반환합니다. r을 통해 수행 된 모든 읽기는 w에 해당하는 쓰기와 일치합니다. 내부 버퍼링이 없습니다. 읽기가 완료되기 전에 쓰기가 완료되어야합니다. 쓰는 동안 발생한 오류는 읽기 오류로보고됩니다.</target>
        </trans-unit>
        <trans-unit id="d5aae156b3babace54749a4ff370cbf166528804" translate="yes" xml:space="preserve">
          <source>Tell returns the current position in the line table.</source>
          <target state="translated">Tell은 행 테이블에서 현재 위치를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="243b371792899304742de51767e5e63dc878faba" translate="yes" xml:space="preserve">
          <source>TempDir</source>
          <target state="translated">TempDir</target>
        </trans-unit>
        <trans-unit id="4e9f8298798f58791af33409f9e40b224764dd8a" translate="yes" xml:space="preserve">
          <source>TempDir (Suffix)</source>
          <target state="translated">TempDir (접미사)</target>
        </trans-unit>
        <trans-unit id="99e70473aa5b1571f3701ff2584745139273d8ab" translate="yes" xml:space="preserve">
          <source>TempDir creates a new temporary directory in the directory dir with a name beginning with prefix and returns the path of the new directory. If dir is the empty string, TempDir uses the default directory for temporary files (see os.TempDir). Multiple programs calling TempDir simultaneously will not choose the same directory. It is the caller's responsibility to remove the directory when no longer needed.</source>
          <target state="translated">TempDir은 접두사로 시작하는 이름으로 디렉토리 dir에 새 임시 디렉토리를 작성하고 새 디렉토리의 경로를 리턴합니다. dir이 빈 문자열 인 경우 TempDir은 임시 파일의 기본 디렉토리를 사용합니다 (os.TempDir 참조). TempDir을 동시에 호출하는 여러 프로그램은 동일한 디렉토리를 선택하지 않습니다. 더 이상 필요하지 않은 경우 디렉토리를 제거하는 것은 호출자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="cc071fc9ff710ae41b76bf6f9ab98edd65deeafe" translate="yes" xml:space="preserve">
          <source>TempDir creates a new temporary directory in the directory dir. The directory name is generated by taking pattern and applying a random string to the end. If pattern includes a &quot;*&quot;, the random string replaces the last &quot;*&quot;. TempDir returns the name of the new directory. If dir is the empty string, TempDir uses the default directory for temporary files (see os.TempDir). Multiple programs calling TempDir simultaneously will not choose the same directory. It is the caller's responsibility to remove the directory when no longer needed.</source>
          <target state="translated">TempDir는 dir 디렉토리에 새 임시 디렉토리를 만듭니다. 디렉토리 이름은 패턴을 취하고 끝에 임의의 문자열을 적용하여 생성됩니다. 패턴에 &quot;*&quot;가 포함 된 경우 임의의 문자열이 마지막 &quot;*&quot;를 대체합니다. TempDir는 새 디렉터리의 이름을 반환합니다. dir이 빈 문자열이면 TempDir는 임시 파일에 대한 기본 디렉토리를 사용합니다 (os.TempDir 참조). TempDir을 동시에 호출하는 여러 프로그램은 동일한 디렉토리를 선택하지 않습니다. 더 이상 필요하지 않을 때 디렉토리를 제거하는 것은 호출자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="b913aacfee5a65e416908a68d2ac6cb82c0ef71c" translate="yes" xml:space="preserve">
          <source>TempDir returns a temporary directory for the test to use. The directory is automatically removed by Cleanup when the test and all its subtests complete. Each subsequent call to t.TempDir returns a unique directory; if the directory creation fails, TempDir terminates the test by calling Fatal.</source>
          <target state="translated">TempDir는 테스트가 사용할 임시 디렉토리를 반환합니다. 테스트 및 모든 하위 테스트가 완료되면 정리에 의해 디렉터리가 자동으로 제거됩니다. 이후에 t.TempDir을 호출 할 때마다 고유 한 디렉터리가 반환됩니다. 디렉터리 생성에 실패하면 TempDir는 Fatal을 호출하여 테스트를 종료합니다.</target>
        </trans-unit>
        <trans-unit id="275584eb4c05e91a05657287b9e5e68b19aedf60" translate="yes" xml:space="preserve">
          <source>TempDir returns the default directory to use for temporary files.</source>
          <target state="translated">TempDir은 임시 파일에 사용할 기본 디렉토리를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d7cc1fbb5a71addb97fa8de33ce419d1f28b35a1" translate="yes" xml:space="preserve">
          <source>TempFile</source>
          <target state="translated">TempFile</target>
        </trans-unit>
        <trans-unit id="ba14fe997bc74680fd4532ceead516a44881c27a" translate="yes" xml:space="preserve">
          <source>TempFile (Suffix)</source>
          <target state="translated">TempFile (접미사)</target>
        </trans-unit>
        <trans-unit id="db71768a24bbe351f05252c3b917cc624a9ef1b3" translate="yes" xml:space="preserve">
          <source>TempFile creates a new temporary file in the directory dir, opens the file for reading and writing, and returns the resulting *os.File. The filename is generated by taking pattern and adding a random string to the end. If pattern includes a &quot;*&quot;, the random string replaces the last &quot;*&quot;. If dir is the empty string, TempFile uses the default directory for temporary files (see os.TempDir). Multiple programs calling TempFile simultaneously will not choose the same file. The caller can use f.Name() to find the pathname of the file. It is the caller's responsibility to remove the file when no longer needed.</source>
          <target state="translated">TempFile은 디렉토리 dir에 새 임시 파일을 작성하고 읽고 쓸 파일을 열고 결과 * os.File을 리턴합니다. 파일 이름은 패턴을 취하고 끝에 임의의 문자열을 추가하여 생성됩니다. 패턴에 &quot;*&quot;가 포함되어 있으면 임의의 문자열이 마지막 &quot;*&quot;를 대체합니다. dir이 빈 문자열 인 경우 TempFile은 임시 파일의 기본 디렉토리를 사용합니다 (os.TempDir 참조). TempFile을 동시에 호출하는 여러 프로그램은 동일한 파일을 선택하지 않습니다. 호출자는 f.Name ()을 사용하여 파일의 경로 이름을 찾을 수 있습니다. 더 이상 필요하지 않은 경우 파일을 제거하는 것은 호출자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="3ec1ae061c27325c7ecb543adf91235e22cbc9ed" translate="yes" xml:space="preserve">
          <source>Template</source>
          <target state="translated">Template</target>
        </trans-unit>
        <trans-unit id="52ee9ac00f43714b0b4818dd84d35b8b6557c7c3" translate="yes" xml:space="preserve">
          <source>Template (Block)</source>
          <target state="translated">템플릿 (블록)</target>
        </trans-unit>
        <trans-unit id="74122feafa7458ac08ce0eb420614965c6703346" translate="yes" xml:space="preserve">
          <source>Template (Func)</source>
          <target state="translated">템플릿 (Func)</target>
        </trans-unit>
        <trans-unit id="2682dd16a44a1aa85841c66918e903265b4a3cd6" translate="yes" xml:space="preserve">
          <source>Template (Glob)</source>
          <target state="translated">템플릿 (글로벌)</target>
        </trans-unit>
        <trans-unit id="b329235171f350105da0e424a6e94302aadf509f" translate="yes" xml:space="preserve">
          <source>Template (Helpers)</source>
          <target state="translated">템플릿 (도움말)</target>
        </trans-unit>
        <trans-unit id="f6c8b5d715e6b1e91ba606c90a46ade44fbfcfc3" translate="yes" xml:space="preserve">
          <source>Template (Parsefiles)</source>
          <target state="translated">템플릿 (구문 파일)</target>
        </trans-unit>
        <trans-unit id="57600593178e53d1b30c9ce35cfc8c0a348f3a2c" translate="yes" xml:space="preserve">
          <source>Template (Share)</source>
          <target state="translated">템플릿 (공유)</target>
        </trans-unit>
        <trans-unit id="85b91409ae0c75ad6a8c43a15d791cc0c6067ae4" translate="yes" xml:space="preserve">
          <source>Template is a specialized Template from &quot;text/template&quot; that produces a safe HTML document fragment.</source>
          <target state="translated">템플릿은 안전한 HTML 문서 조각을 생성하는 &quot;text / template&quot;의 특수 템플릿입니다.</target>
        </trans-unit>
        <trans-unit id="d8a89275d0782e6367eafd96ad18e35d72254fb0" translate="yes" xml:space="preserve">
          <source>Template is the representation of a parsed template. The *parse.Tree field is exported only for use by html/template and should be treated as unexported by all other clients.</source>
          <target state="translated">템플릿은 구문 분석 된 템플릿을 나타냅니다. * parse.Tree 필드는 html / template에서만 사용하기 위해 내보내지며 다른 모든 클라이언트에서는 내 보내지 않은 것으로 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="19cafd4f58542bc1848a2bc09f68f32df89aaeb6" translate="yes" xml:space="preserve">
          <source>Template.Delims</source>
          <target state="translated">Template.Delims</target>
        </trans-unit>
        <trans-unit id="a8aa430f1c13b8e8ba33d56534b8f8c54974c35f" translate="yes" xml:space="preserve">
          <source>TemplateNode represents a {{template}} action.</source>
          <target state="translated">TemplateNode는 {{template}} 작업을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6272b08c56a555c9301dfcc377b8ee08eca7de29" translate="yes" xml:space="preserve">
          <source>Templates are executed by applying them to a data structure. Annotations in the template refer to elements of the data structure (typically a field of a struct or a key in a map) to control execution and derive values to be displayed. Execution of the template walks the structure and sets the cursor, represented by a period '.' and called &quot;dot&quot;, to the value at the current location in the structure as execution proceeds.</source>
          <target state="translated">템플릿은 데이터 구조에 적용하여 실행됩니다. 템플릿의 주석은 실행을 제어하고 표시 할 값을 도출하기 위해 데이터 구조의 요소 (일반적으로 구조체의 필드 또는 맵의 키)를 나타냅니다. 템플릿을 실행하면 구조를 따라 가고 마침표 '.'로 표시되는 커서를 설정합니다. 실행이 진행됨에 따라 구조에서 현재 위치의 값으로 &quot;도트&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="d659d268d0b2876b00930d9cefac00e94082414d" translate="yes" xml:space="preserve">
          <source>Templates can be redefined in successive calls to Parse, before the first use of Execute on t or any associated template. A template definition with a body containing only white space and comments is considered empty and will not replace an existing template's body. This allows using Parse to add new named template definitions without overwriting the main template body.</source>
          <target state="translated">t 또는 관련 템플릿에서 Execute를 처음 사용하기 전에 Parse를 연속적으로 호출하여 템플릿을 다시 정의 할 수 있습니다. 공백과 주석 만 포함 된 본문이있는 템플릿 정의는 비어있는 것으로 간주되며 기존 템플릿의 본문을 대체하지 않습니다. 이렇게하면 구문 분석을 사용하여 기본 템플릿 본문을 덮어 쓰지 않고 새로운 명명 된 템플릿 정의를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0dad97eb547b69ff6ae16e7728cdc906f69fe6a" translate="yes" xml:space="preserve">
          <source>Templates can be redefined in successive calls to Parse. A template definition with a body containing only white space and comments is considered empty and will not replace an existing template's body. This allows using Parse to add new named template definitions without overwriting the main template body.</source>
          <target state="translated">Parse를 연속적으로 호출하여 템플릿을 재정의 할 수 있습니다. 공백과 주석 만 포함 된 본문이있는 템플릿 정의는 비어있는 것으로 간주되며 기존 템플릿의 본문을 대체하지 않습니다. 이렇게하면 구문 분석을 사용하여 기본 템플릿 본문을 덮어 쓰지 않고 새로운 명명 된 템플릿 정의를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b101f8846f53e53dd0074ea44ad4ea7b299215d" translate="yes" xml:space="preserve">
          <source>Templates returns a slice of defined templates associated with t.</source>
          <target state="translated">템플릿은 t와 관련된 정의 된 템플릿 조각을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ef678e78b264d52108e80621ab16809ee2f68f32" translate="yes" xml:space="preserve">
          <source>Templates returns a slice of the templates associated with t, including t itself.</source>
          <target state="translated">템플릿은 t 자체를 포함하여 t와 연결된 템플릿 조각을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="63499f131caeb094b508fda158f4d32cdfc15875" translate="yes" xml:space="preserve">
          <source>Temporary reports whether the DNS error is known to be temporary. This is not always known; a DNS lookup may fail due to a temporary error and return a DNSError for which Temporary returns false.</source>
          <target state="translated">임시는 DNS 오류가 일시적인 것으로 알려 졌는지보고합니다. 이것이 항상 알려진 것은 아닙니다. 일시적인 오류로 인해 DNS 조회가 실패하고 Temporary가 false를 반환하는 DNSError를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b5595c4587e69f7c655fe870d47a5a1d8fb3ed0" translate="yes" xml:space="preserve">
          <source>TestFS tests a file system implementation. It walks the entire tree of files in fsys, opening and checking that each file behaves correctly. It also checks that the file system contains at least the expected files. As a special case, if no expected files are listed, fsys must be empty. Otherwise, fsys must only contain at least the listed files: it can also contain others. The contents of fsys must not change concurrently with TestFS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e43bc342b1548a3e29005560336fc30b65a42bd" translate="yes" xml:space="preserve">
          <source>TestReader tests that reading from r returns the expected file content. It does reads of different sizes, until EOF. If r implements io.ReaderAt or io.Seeker, TestReader also checks that those operations behave as they should.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="102ab778dfcf2daa890ddca81b62a6c8c57e866c" translate="yes" xml:space="preserve">
          <source>Tests or benchmarks may be skipped at run time with a call to the Skip method of *T or *B:</source>
          <target state="translated">테스트 또는 벤치 마크는 * T 또는 * B의 Skip 메소드를 호출하여 런타임에 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fb2cdb8c84498e97b67876bcf9179f6c6a0681c" translate="yes" xml:space="preserve">
          <source>Text and spaces</source>
          <target state="translated">텍스트와 공백</target>
        </trans-unit>
        <trans-unit id="7c3578369bc9761a19920ddfd71d5074fb77328e" translate="yes" xml:space="preserve">
          <source>Text converts the floating-point number x to a string according to the given format and precision prec. The format is one of:</source>
          <target state="translated">텍스트는 주어진 형식 및 정밀도에 따라 부동 소수점 숫자 x를 문자열로 변환합니다. 형식은 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="9714bb7b9d9dc65203e2f28091e607a38d20869a" translate="yes" xml:space="preserve">
          <source>Text in the format string that is not recognized as part of the reference time is echoed verbatim during Format and expected to appear verbatim in the input to Parse.</source>
          <target state="translated">참조 시간의 일부로 인식되지 않는 형식 문자열의 텍스트는 형식 동안 그대로 에코되며 구문 분석 입력에 그대로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="2a87e174a24b19b122c0ab179b85b925e794409f" translate="yes" xml:space="preserve">
          <source>Text returns the most recent token generated by a call to Scan as a newly allocated string holding its bytes.</source>
          <target state="translated">텍스트는 Scan 호출에 의해 생성 된 최신 토큰을 바이트를 보유하는 새로 할당 된 문자열로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9757ee25c7224af6e75db771ea323fc05ac31e21" translate="yes" xml:space="preserve">
          <source>Text returns the string representation of x in the given base. Base must be between 2 and 62, inclusive. The result uses the lower-case letters 'a' to 'z' for digit values 10 to 35, and the upper-case letters 'A' to 'Z' for digit values 36 to 61. No prefix (such as &quot;0x&quot;) is added to the string. If x is a nil pointer it returns &quot;&amp;lt;nil&amp;gt;&quot;.</source>
          <target state="translated">텍스트는 주어진 밑에서 x의 문자열 표현을 반환합니다. 밑은 2에서 62 사이 여야합니다. 결과는 숫자 값 10 ~ 35에 소문자 'a'~ 'z'를 사용하고 숫자 값 36 ~ 61에 대문자 'A'~ 'Z'를 사용합니다. 접두사 없음 (예 : &quot;0x&quot; )가 문자열에 추가됩니다. x가 nil 포인터이면 &quot;&amp;lt;nil&amp;gt;&quot;을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="544da0b6d8a9e887a60db43ce4a26fd95b56a5d4" translate="yes" xml:space="preserve">
          <source>Text returns the text of the comment. Comment markers (//, /*, and */), the first space of a line comment, and leading and trailing empty lines are removed. Comment directives like &quot;//line&quot; and &quot;//go:noinline&quot; are also removed. Multiple empty lines are reduced to one, and trailing space on lines is trimmed. Unless the result is empty, it is newline-terminated.</source>
          <target state="translated">텍스트는 주석의 텍스트를 반환합니다. 주석 표시 자 (//, / * 및 * /), 줄 주석의 첫 번째 공백, 선행 및 후행 빈 줄이 제거됩니다. &quot;// line&quot;및 &quot;// go : noinline&quot;과 같은 주석 지시문도 제거됩니다. 여러 개의 빈 줄이 하나로 줄어들고 줄의 후행 공백이 잘립니다. 결과가 비어 있지 않으면 개행으로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="42341adeec7d736d3551b283379c31741e77e4f9" translate="yes" xml:space="preserve">
          <source>Text returns the text of the comment. Comment markers (//, /*, and */), the first space of a line comment, and leading and trailing empty lines are removed. Multiple empty lines are reduced to one, and trailing space on lines is trimmed. Unless the result is empty, it is newline-terminated.</source>
          <target state="translated">텍스트는 주석의 텍스트를 반환합니다. 주석 주석 (//, / * 및 * /), 줄 주석의 첫 번째 공백 및 선행 및 후행 빈 줄이 제거됩니다. 여러 개의 빈 줄이 하나로 줄어들고 줄의 후행 공간이 잘립니다. 결과가 비어 있지 않으면 개행 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="02af2db9a5ef05bc960487d876c4df951f9ad592" translate="yes" xml:space="preserve">
          <source>Text types have the charset parameter set to &quot;utf-8&quot; by default.</source>
          <target state="translated">텍스트 유형에는 기본적으로 charset 매개 변수가 &quot;utf-8&quot;로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b44c08e7f92ae7b5fe535298ff7558bf9d8a0cab" translate="yes" xml:space="preserve">
          <source>TextMarshaler is the interface implemented by an object that can marshal itself into a textual form.</source>
          <target state="translated">TextMarshaler는 텍스트 형식으로 마샬링 할 수있는 개체로 구현 된 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="ae8b7afc36cfb51ffddc286e90577602c85186e4" translate="yes" xml:space="preserve">
          <source>TextNode holds plain text.</source>
          <target state="translated">TextNode는 일반 텍스트를 보유합니다.</target>
        </trans-unit>
        <trans-unit id="48668880c8086b3c4c912b1de227b18b3d9a93e1" translate="yes" xml:space="preserve">
          <source>TextUnmarshaler is the interface implemented by an object that can unmarshal a textual representation of itself.</source>
          <target state="translated">TextUnmarshaler는 텍스트 표현을 마샬링 해제 할 수있는 객체로 구현 된 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="33b69b32d53f67278f1556c03b99ca73467e15b3" translate="yes" xml:space="preserve">
          <source>That is, when matching against text, the regexp returns a match that begins as early as possible in the input (leftmost), and among those it chooses a match that is as long as possible. This so-called leftmost-longest matching is the same semantics that early regular expression implementations used and that POSIX specifies.</source>
          <target state="translated">즉, 텍스트와 일치하는 경우 정규 표현식은 입력 (가장 왼쪽)에서 가능한 한 빨리 시작되는 일치를 반환하며 그 중에서 가능한 한 긴 일치를 선택합니다. 이 소위 가장 긴 일치 항목은 초기 정규식 구현에서 사용하고 POSIX에서 지정한 것과 동일한 의미입니다.</target>
        </trans-unit>
        <trans-unit id="1fe9add248f3617655fdc8371d42751cba2e4007" translate="yes" xml:space="preserve">
          <source>The &quot;omitempty&quot; option specifies that the field should be omitted from the encoding if the field has an empty value, defined as false, 0, a nil pointer, a nil interface value, and any empty array, slice, map, or string.</source>
          <target state="translated">&quot;omitempty&quot;옵션은 필드에 빈 값 (false, 0, nil 포인터, nil 인터페이스 값 및 빈 배열, 슬라이스, 맵 또는 문자열)이있는 경우 인코딩에서 필드를 생략하도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="71d19b0f94317203bba62dcd8f10cd68c650f96b" translate="yes" xml:space="preserve">
          <source>The &quot;string&quot; option signals that a field is stored as JSON inside a JSON-encoded string. It applies only to fields of string, floating point, integer, or boolean types. This extra level of encoding is sometimes used when communicating with JavaScript programs:</source>
          <target state="translated">&quot;string&quot;옵션은 필드가 JSON 인코딩 문자열 내에 JSON으로 저장됨을 나타냅니다. 문자열, 부동 소수점, 정수 또는 부울 유형의 필드에만 적용됩니다. 이 추가 수준의 인코딩은 JavaScript 프로그램과 통신 할 때 가끔 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d1ee29ca2c06802f34981d89493c0bb6f1d6d312" translate="yes" xml:space="preserve">
          <source>The %!s just shows the print verb in use when the failure occurred. If the panic is caused by a nil receiver to an Error or String method, however, the output is the undecorated string, &quot;&amp;lt;nil&amp;gt;&quot;.</source>
          <target state="translated">%! s는 실패가 발생했을 때 사용중인 인쇄 동사를 보여줍니다. 그러나 패닉이 nil 수신자에 의해 Error 또는 String 메소드에 의한 경우, 출력은 데코 레이팅되지 않은 문자열 &quot;&amp;lt;nil&amp;gt;&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="743e4c8e9a91e391bfa222546fd5a23a69c683b9" translate="yes" xml:space="preserve">
          <source>The *Basic type for Typ[Byte] will have the name &quot;uint8&quot;. Use Universe.Lookup(&quot;byte&quot;).Type() to obtain the specific alias basic type named &quot;byte&quot; (and analogous for &quot;rune&quot;).</source>
          <target state="translated">Typ [Byte]의 * Basic 유형은 &quot;uint8&quot;입니다. Universe.Lookup ( &quot;byte&quot;). Type ()을 사용하여 &quot;byte&quot;라는 특정 별칭 기본 유형 ( &quot;rune&quot;과 유사)을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="091326b161ce75ad991e494527918578bfa9a062" translate="yes" xml:space="preserve">
          <source>The //go:embed directive accepts multiple space-separated patterns for brevity, but it can also be repeated, to avoid very long lines when there are many patterns. The patterns are interpreted relative to the package directory containing the source file. The path separator is a forward slash, even on Windows systems. Patterns may not contain &amp;lsquo;.&amp;rsquo; or &amp;lsquo;..&amp;rsquo; or empty path elements, nor may they begin or end with a slash. To match everything in the current directory, use &amp;lsquo;*&amp;rsquo; instead of &amp;lsquo;.&amp;rsquo;. To allow for naming files with spaces in their names, patterns can be written as Go double-quoted or back-quoted string literals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7357eb6991ca9109d884f02735e2f6ebb84c05dd" translate="yes" xml:space="preserve">
          <source>The //go:embed directive can be used with both exported and unexported variables, depending on whether the package wants to make the data available to other packages. It can only be used with global variables at package scope, not with local variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="065a2eb0c8a1fc2e4da5a5d35829a4e71f365312" translate="yes" xml:space="preserve">
          <source>The //go:embed directive requires importing &quot;embed&quot;, even when using a string or []byte. In source files that don't refer to embed.FS, use a blank import (import _ &quot;embed&quot;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b48d2fd32986c470905fdc8a6c05c918bb04d66e" translate="yes" xml:space="preserve">
          <source>The //go:embed line for a variable of type string or []byte can have only a single pattern, and that pattern can match only a single file. The string or []byte is initialized with the contents of that file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="850dd1df743a69c63fe9886362ac383beaaa22a7" translate="yes" xml:space="preserve">
          <source>The AES block size in bytes.</source>
          <target state="translated">바이트 단위의 AES 블록 크기입니다.</target>
        </trans-unit>
        <trans-unit id="5673ab8326600fbbe495a6285dd8ced305ce9de8" translate="yes" xml:space="preserve">
          <source>The AES operations in this package are not implemented using constant-time algorithms. An exception is when running on systems with enabled hardware support for AES that makes these operations constant-time. Examples include amd64 systems using AES-NI extensions and s390x systems using Message-Security-Assist extensions. On such systems, when the result of NewCipher is passed to cipher.NewGCM, the GHASH operation used by GCM is also constant-time.</source>
          <target state="translated">이 패키지의 AES 작업은 상수 시간 알고리즘을 사용하여 구현되지 않습니다. 이러한 작업을 일정하게 유지하는 AES에 대한 하드웨어 지원이 가능한 시스템에서 실행되는 경우는 예외입니다. 예는 AES-NI 확장을 사용하는 amd64 시스템과 Message-Security-Assist 확장을 사용하는 s390x 시스템입니다. 이러한 시스템에서 NewCipher의 결과가 cipher.NewGCM으로 전달되면 GCM에서 사용하는 GHASH 조작도 일정 시간입니다.</target>
        </trans-unit>
        <trans-unit id="6adb0b7099e3661b5d507077f904503946e1529a" translate="yes" xml:space="preserve">
          <source>The AuthorityKeyId will be taken from the SubjectKeyId of parent, if any, unless the resulting certificate is self-signed. Otherwise the value from template will be used.</source>
          <target state="translated">AuthorityKeyId는 결과 인증서가 자체 서명되지 않은 경우 상위의 SubjectKeyId (있는 경우)에서 가져옵니다. 그렇지 않으면 템플릿의 값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ef02c253bf1371acc1a3bc5ebf403abe9da8e69d" translate="yes" xml:space="preserve">
          <source>The CPU profile is not available as a Profile. It has a special API, the StartCPUProfile and StopCPUProfile functions, because it streams output to a writer during profiling.</source>
          <target state="translated">CPU 프로파일은 프로파일로 사용할 수 없습니다. 프로파일 링 중에 출력을 출력기로 스트리밍하므로 특수 API 인 StartCPUProfile 및 StopCPUProfile 함수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bedc851c290436a17de2ea56c0e80eced3a4ba0" translate="yes" xml:space="preserve">
          <source>The CRL is signed by priv which should be the private key associated with the public key in the issuer certificate.</source>
          <target state="translated">CRL은 발급자 인증서의 공개 키와 연결된 개인 키 여야하는 priv에 의해 서명됩니다.</target>
        </trans-unit>
        <trans-unit id="1ff86b138d4478667bb91009d716fd7665b76152" translate="yes" xml:space="preserve">
          <source>The CSPRNG key is indifferentiable from a random oracle as shown in [Coron], the AES-CTR stream is indifferentiable from a random oracle under standard cryptographic assumptions (see [Larsson] for examples).</source>
          <target state="translated">CSPRNG 키는 [Coron]에 표시된대로 임의의 오라클과 구별 할 수 없으며, AES-CTR 스트림은 표준 암호화 가정 하에서 임의의 오라클과 구별 할 수 없습니다 (예는 [Larsson] 참조).</target>
        </trans-unit>
        <trans-unit id="36bb730fcee3dc3ab8099094b237b4e5ff536824" translate="yes" xml:space="preserve">
          <source>The Call method waits for the remote call to complete while the Go method launches the call asynchronously and signals completion using the Call structure's Done channel.</source>
          <target state="translated">Call 메소드는 원격 호출이 완료 될 때까지 대기하는 반면 Go 메소드는 호출을 비동기 적으로 시작하고 Call 구조의 완료 채널을 사용하여 완료 신호를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="fa9c5434f905167654701708a6911e94eaa76597" translate="yes" xml:space="preserve">
          <source>The Client and Transport return Responses from servers once the response headers have been received. The response body is streamed on demand as the Body field is read.</source>
          <target state="translated">클라이언트와 전송은 응답 헤더를 받으면 서버에서 응답을 반환합니다. 응답 본문은 본문 필드를 읽을 때 요청시 스트리밍됩니다.</target>
        </trans-unit>
        <trans-unit id="a06861d55f6598b58fca7ecb30c8e99763835023" translate="yes" xml:space="preserve">
          <source>The Client's Transport typically has internal state (cached TCP connections), so Clients should be reused instead of created as needed. Clients are safe for concurrent use by multiple goroutines.</source>
          <target state="translated">클라이언트의 전송에는 일반적으로 내부 상태 (캐시 된 TCP 연결)가 있으므로 필요에 따라 클라이언트를 작성하는 대신 재사용해야합니다. 클라이언트는 여러 고 루틴이 동시에 사용하기에 안전합니다.</target>
        </trans-unit>
        <trans-unit id="ceca2d7732940705f6d00b5d32a4fb0ac5b5ffee" translate="yes" xml:space="preserve">
          <source>The CloseNotifier interface is implemented by ResponseWriters which allow detecting when the underlying connection has gone away.</source>
          <target state="translated">CloseNotifier 인터페이스는 ResponseWriters에 의해 구현되어 기본 연결이 끊어진 시점을 감지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e611d14841eea36df4afcbef6632f0e94c16f389" translate="yes" xml:space="preserve">
          <source>The Comments list contains all comments in the source file in order of appearance, including the comments that are pointed to from other nodes via Doc and Comment fields.</source>
          <target state="translated">주석 목록에는 문서 및 주석 필드를 통해 다른 노드에서 가리키는 주석을 포함하여 소스 파일의 모든 주석이 순서대로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="7243291c556ac8dd62df98afdad8c3760dcef423" translate="yes" xml:space="preserve">
          <source>The Content-Type header is set to application/x-www-form-urlencoded. To set other headers, use NewRequest and Client.Do.</source>
          <target state="translated">Content-Type 헤더는 application / x-www-form-urlencoded로 설정되어 있습니다. 다른 헤더를 설정하려면 NewRequest 및 Client.Do를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4c8514b948c44917ccd4528524ea490c8df7afe9" translate="yes" xml:space="preserve">
          <source>The Content-Type header is set to application/x-www-form-urlencoded. To set other headers, use NewRequest and DefaultClient.Do.</source>
          <target state="translated">Content-Type 헤더는 application / x-www-form-urlencoded로 설정되어 있습니다. 다른 헤더를 설정하려면 NewRequest 및 DefaultClient.Do를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e64fbf6aec6e290cb2a86c841a198b35f0414494" translate="yes" xml:space="preserve">
          <source>The Context field will be zero to gather a traceback from the current program execution point. In this case, the traceback function will be called from C code.</source>
          <target state="translated">현재 프로그램 실행 지점에서 역 추적을 수집하려면 컨텍스트 필드가 0이됩니다. 이 경우 C 코드에서 역 추적 함수가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="0d4ab0b54e24df8d963181a5b8f48a80c3f0be3b" translate="yes" xml:space="preserve">
          <source>The Copy function uses ReaderFrom if available.</source>
          <target state="translated">복사 기능은 사용 가능한 경우 ReaderFrom을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="64b7a752d1105251970c527872a99e908894fe83" translate="yes" xml:space="preserve">
          <source>The Copy function uses WriterTo if available.</source>
          <target state="translated">복사 기능은 가능한 경우 WriterTo를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4068b76cb1fd1e06d5771c04e2c02b7fd65472c1" translate="yes" xml:space="preserve">
          <source>The DES block size in bytes.</source>
          <target state="translated">바이트 단위의 DES 블록 크기입니다.</target>
        </trans-unit>
        <trans-unit id="1b8c2351859f5d138662581cb4874dd621eef345" translate="yes" xml:space="preserve">
          <source>The DSA operations in this package are not implemented using constant-time algorithms.</source>
          <target state="translated">이 패키지의 DSA 작업은 상수 시간 알고리즘을 사용하여 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3d5a6f0be8af4ae349714dde142378b2b0dd32c1" translate="yes" xml:space="preserve">
          <source>The Data fields contains object-specific data:</source>
          <target state="translated">데이터 필드에는 객체 별 데이터가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d70280d8e959481aa07b78bca8cd9c9158da0c1f" translate="yes" xml:space="preserve">
          <source>The Decoder does only basic sanity checking on decoded input sizes, and its limits are not configurable. Take caution when decoding gob data from untrusted sources.</source>
          <target state="translated">디코더는 디코딩 된 입력 크기에 대한 기본 상태 검사 만 수행하며 한계는 구성 할 수 없습니다. 신뢰할 수없는 소스에서 gob 데이터를 디코딩 할 때주의하십시오.</target>
        </trans-unit>
        <trans-unit id="1a3dcfbdb85a6eb02179c9d5c4dd5b3efbbb6016" translate="yes" xml:space="preserve">
          <source>The Dial function connects to a server:</source>
          <target state="translated">다이얼 기능은 서버에 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="e5af1dd969514f431da9aefdd41666a5f815fd72" translate="yes" xml:space="preserve">
          <source>The Error interface identifies a run time error.</source>
          <target state="translated">오류 인터페이스는 런타임 오류를 식별합니다.</target>
        </trans-unit>
        <trans-unit id="8e437b0bdb4841542eba2f049276dee573f887b3" translate="yes" xml:space="preserve">
          <source>The Errorf function lets us use formatting features to create descriptive error messages.</source>
          <target state="translated">Errorf 기능을 사용하면 형식화 기능을 사용하여 설명적인 오류 메시지를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4cc7e273196b60c7b327e2a1e7c92da50e59b611" translate="yes" xml:space="preserve">
          <source>The Examples section of the documentation includes an illustration of how to use MakeFunc to build a swap function for different types.</source>
          <target state="translated">설명서의 예제 섹션에는 MakeFunc를 사용하여 다양한 유형의 스왑 기능을 작성하는 방법이 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b810f0952b2b914f1f6cf5d2f5bc4fc4e059ce92" translate="yes" xml:space="preserve">
          <source>The FS interface is the minimum implementation required of the file system. A file system may implement additional interfaces, such as ReadFileFS, to provide additional or optimized functionality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4103d71ff7738d060819734b8440840f86eb6a7" translate="yes" xml:space="preserve">
          <source>The Flusher interface is implemented by ResponseWriters that allow an HTTP handler to flush buffered data to the client.</source>
          <target state="translated">Flusher 인터페이스는 HTTP 핸들러가 버퍼링 된 데이터를 클라이언트로 플러시 할 수 있도록하는 ResponseWriters에 의해 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="8989cf7d3fb3d7f0d686b9d17d09faeb78214543" translate="yes" xml:space="preserve">
          <source>The GIF specification is at &lt;a href=&quot;https://www.w3.org/Graphics/GIF/spec-gif89a.txt&quot;&gt;https://www.w3.org/Graphics/GIF/spec-gif89a.txt&lt;/a&gt;.</source>
          <target state="translated">GIF 사양은 &lt;a href=&quot;https://www.w3.org/Graphics/GIF/spec-gif89a.txt&quot;&gt;https://www.w3.org/Graphics/GIF/spec-gif89a.txt에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="413f2e2abeee0cebf1b4d1ac0f711038cf2ef825" translate="yes" xml:space="preserve">
          <source>The GOARCH, GOOS, GOPATH, and GOROOT environment variables complete the set of Go environment variables. They influence the building of Go programs (see &lt;a href=&quot;https://golang.org/cmd/go&quot;&gt;https://golang.org/cmd/go&lt;/a&gt; and &lt;a href=&quot;../go/build/index&quot;&gt;https://golang.org/pkg/go/build&lt;/a&gt;). GOARCH, GOOS, and GOROOT are recorded at compile time and made available by constants or functions in this package, but they do not influence the execution of the run-time system.</source>
          <target state="translated">GOARCH, GOOS, GOPATH 및 GOROOT 환경 변수는 일련의 Go 환경 변수를 완료합니다. Go 프로그램 빌드에 영향을줍니다 ( &lt;a href=&quot;https://golang.org/cmd/go&quot;&gt;https://golang.org/cmd/go&lt;/a&gt; 및 &lt;a href=&quot;../go/build/index&quot;&gt;https://golang.org/pkg/go/build 참조&lt;/a&gt; ). GOARCH, GOOS 및 GOROOT는 컴파일시 기록되며이 패키지의 상수 또는 함수에 의해 사용 가능하지만 런타임 시스템의 실행에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="980859c522964a8cbb3109a2a563d54c04b37667" translate="yes" xml:space="preserve">
          <source>The GODEBUG variable controls debugging variables within the runtime. It is a comma-separated list of name=val pairs setting these named variables:</source>
          <target state="translated">GODEBUG 변수는 런타임 내의 디버깅 변수를 제어합니다. 이 명명 된 변수를 설정하는 쉼표로 구분 된 name = val 쌍의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="854b96235a6d258614ac621d5a074c350962980a" translate="yes" xml:space="preserve">
          <source>The GODEBUG variables are not covered by Go's API compatibility promise. Please report any issues before disabling HTTP/2 support: &lt;a href=&quot;https://golang.org/s/http2bug&quot;&gt;https://golang.org/s/http2bug&lt;/a&gt;</source>
          <target state="translated">GODEBUG 변수는 Go의 API 호환성 약속에 포함되지 않습니다. HTTP / 2 지원을 비활성화하기 전에 문제를보고하십시오 : &lt;a href=&quot;https://golang.org/s/http2bug&quot;&gt;https://golang.org/s/http2bug&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="07350ebc65d6866cf7470b34fa919f4c89a12e5a" translate="yes" xml:space="preserve">
          <source>The GOGC variable sets the initial garbage collection target percentage. A collection is triggered when the ratio of freshly allocated data to live data remaining after the previous collection reaches this percentage. The default is GOGC=100. Setting GOGC=off disables the garbage collector entirely. The runtime/debug package's SetGCPercent function allows changing this percentage at run time. See &lt;a href=&quot;debug/index#SetGCPercent&quot;&gt;https://golang.org/pkg/runtime/debug/#SetGCPercent&lt;/a&gt;.</source>
          <target state="translated">GOGC 변수는 초기 가비지 콜렉션 대상 백분율을 설정합니다. 이전 수집 후 남아있는 새로 할당 된 데이터 대 실시간 데이터의 비율이이 백분율에 도달하면 수집이 트리거됩니다. 기본값은 GOGC = 100입니다. GOGC = off를 설정하면 가비지 수집기가 완전히 비활성화됩니다. 런타임 / 디버그 패키지의 SetGCPercent 함수를 사용하면 런타임에이 백분율을 변경할 수 있습니다. &lt;a href=&quot;debug/index#SetGCPercent&quot;&gt;https://golang.org/pkg/runtime/debug/#SetGCPercent를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="23644add17b2d4ea82387647518fec703dd62cda" translate="yes" xml:space="preserve">
          <source>The GOMAXPROCS variable limits the number of operating system threads that can execute user-level Go code simultaneously. There is no limit to the number of threads that can be blocked in system calls on behalf of Go code; those do not count against the GOMAXPROCS limit. This package's GOMAXPROCS function queries and changes the limit.</source>
          <target state="translated">GOMAXPROCS 변수는 사용자 레벨 Go 코드를 동시에 실행할 수있는 운영 체제 스레드 수를 제한합니다. Go 코드 대신 시스템 호출에서 차단 될 수있는 스레드 수에는 제한이 없습니다. 그것들은 GOMAXPROCS 제한에 포함되지 않습니다. 이 패키지의 GOMAXPROCS 함수는 한계를 쿼리하고 변경합니다.</target>
        </trans-unit>
        <trans-unit id="2dc1829c430b9fe1fcd42a5d7af5182478e7df72" translate="yes" xml:space="preserve">
          <source>The GORACE variable configures the race detector, for programs built using -race. See &lt;a href=&quot;https://golang.org/doc/articles/race_detector.html&quot;&gt;https://golang.org/doc/articles/race_detector.html&lt;/a&gt; for details.</source>
          <target state="translated">GORACE 변수는 -race를 사용하여 빌드 된 프로그램에 대해 레이스 탐지기를 구성합니다. 자세한 내용은 &lt;a href=&quot;https://golang.org/doc/articles/race_detector.html&quot;&gt;https://golang.org/doc/articles/race_detector.html&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="895a2c86582e638542cc835d086a523cf9768898" translate="yes" xml:space="preserve">
          <source>The GOTRACEBACK variable controls the amount of output generated when a Go program fails due to an unrecovered panic or an unexpected runtime condition. By default, a failure prints a stack trace for the current goroutine, eliding functions internal to the run-time system, and then exits with exit code 2. The failure prints stack traces for all goroutines if there is no current goroutine or the failure is internal to the run-time. GOTRACEBACK=none omits the goroutine stack traces entirely. GOTRACEBACK=single (the default) behaves as described above. GOTRACEBACK=all adds stack traces for all user-created goroutines. GOTRACEBACK=system is like &amp;ldquo;all&amp;rdquo; but adds stack frames for run-time functions and shows goroutines created internally by the run-time. GOTRACEBACK=crash is like &amp;ldquo;system&amp;rdquo; but crashes in an operating system-specific manner instead of exiting. For example, on Unix systems, the crash raises SIGABRT to trigger a core dump. For historical reasons, the GOTRACEBACK settings 0, 1, and 2 are synonyms for none, all, and system, respectively. The runtime/debug package's SetTraceback function allows increasing the amount of output at run time, but it cannot reduce the amount below that specified by the environment variable. See &lt;a href=&quot;debug/index#SetTraceback&quot;&gt;https://golang.org/pkg/runtime/debug/#SetTraceback&lt;/a&gt;.</source>
          <target state="translated">GOTRACEBACK 변수는 복구되지 않은 패닉 또는 예기치 않은 런타임 조건으로 인해 Go 프로그램이 실패 할 때 생성되는 출력량을 제어합니다. 기본적으로 실패는 현재 고 루틴에 대한 스택 추적을 인쇄하고 런타임 시스템 내부의 기능을 생략 한 다음 종료 코드 2로 종료합니다. 현재 고 루틴이 없거나 실패하면 모든 고 루틴에 대한 스택 추적을 인쇄합니다. 런타임 내부. GOTRACEBACK = 없음은 고 루틴 스택 추적을 완전히 생략하지 않습니다. GOTRACEBACK = 단일 (기본값)은 위에서 설명한대로 동작합니다. GOTRACEBACK = all은 모든 사용자 생성 고 루틴에 대한 스택 추적을 추가합니다. GOTRACEBACK = system은&amp;ldquo;all&amp;rdquo;과 유사하지만 런타임 기능을위한 스택 프레임을 추가하고 런타임에 의해 내부에 생성 된 고 루틴을 보여줍니다.GOTRACEBACK = crash는&amp;ldquo;시스템&amp;rdquo;과 비슷하지만 종료하는 대신 운영 체제 별 방식으로 충돌합니다. 예를 들어, Unix 시스템에서 충돌은 SIGABRT를 발생시켜 코어 덤프를 트리거합니다. 이전의 이유로 GOTRACEBACK 설정 0, 1 및 2는 각각 none, all 및 system의 동의어입니다. 런타임 / 디버그 패키지의 SetTraceback 함수를 사용하면 런타임시 출력량을 늘릴 수 있지만 환경 변수에 지정된 것보다 적은 양을 줄일 수는 없습니다. 보다그러나 환경 변수에 지정된 것보다 적은 양을 줄일 수는 없습니다. 보다그러나 환경 변수에 지정된 것보다 적은 양을 줄일 수는 없습니다. 보다&lt;a href=&quot;debug/index#SetTraceback&quot;&gt;https://golang.org/pkg/runtime/debug/#SetTraceback&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="201ea9b13c6c1b11811e547f191be7e93f488ebd" translate="yes" xml:space="preserve">
          <source>The Go 1 compatibility guidelines make it impossible for us to change the behavior of these methods; use Read or ReadMsgIP instead.</source>
          <target state="translated">Go 1 호환성 지침으로 인해 이러한 방법의 동작을 변경할 수 없습니다. 대신 Read 또는 ReadMsgIP를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="75b1fb4f30d1ce191ea16d73a47dc69ce4dd6484" translate="yes" xml:space="preserve">
          <source>The Go build system will recognize the directives and arrange for the declared variable (in the example above, content) to be populated with the matching files from the file system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbb7c186e3ae50bd364f0be3171da7e4e4fa74f9" translate="yes" xml:space="preserve">
          <source>The Go function fn is called with the value of JavaScript's &quot;this&quot; keyword and the arguments of the invocation. The return value of the invocation is the result of the Go function mapped back to JavaScript according to ValueOf.</source>
          <target state="translated">Go 함수 fn은 JavaScript의 &quot;this&quot;키워드 값과 호출 인수로 호출됩니다. 호출의 반환 값은 ValueOf에 따라 JavaScript에 다시 매핑 된 Go 함수의 결과입니다.</target>
        </trans-unit>
        <trans-unit id="c7566eb3c6d36d40991cd457887383d73c8d32f6" translate="yes" xml:space="preserve">
          <source>The Go path is a list of directory trees containing Go source code. It is consulted to resolve imports that cannot be found in the standard Go tree. The default path is the value of the GOPATH environment variable, interpreted as a path list appropriate to the operating system (on Unix, the variable is a colon-separated string; on Windows, a semicolon-separated string; on Plan 9, a list).</source>
          <target state="translated">Go 경로는 Go 소스 코드가 포함 된 디렉토리 트리 목록입니다. 표준 Go 트리에서 찾을 수없는 가져 오기를 해결하기 위해 참조됩니다. 기본 경로는 운영 체제에 적합한 경로 목록으로 해석되는 GOPATH 환경 변수의 값입니다 (유닉스의 경우 변수는 콜론으로 구분 된 문자열, Windows에서는 세미콜론으로 구분 된 문자열, 계획 9에서는 목록) ).</target>
        </trans-unit>
        <trans-unit id="b3cf2d68365e20d0973a301087cdd0150f378764" translate="yes" xml:space="preserve">
          <source>The Go visibility rules for struct fields are amended for JSON when deciding which field to marshal or unmarshal. If there are multiple fields at the same level, and that level is the least nested (and would therefore be the nesting level selected by the usual Go rules), the following extra rules apply:</source>
          <target state="translated">마샬링하거나 언 마샬링 할 필드를 결정할 때 JSON에 대해 구조체 필드의 가시성 규칙이 수정됩니다. 같은 수준에 여러 개의 필드가 있고 해당 수준이 가장 낮은 중첩 수준이므로 일반적인 Go 규칙에 의해 선택된 중첩 수준이되는 경우 다음과 같은 추가 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="0fd6453ed937237b824b9a18906363db4d73b2a6" translate="yes" xml:space="preserve">
          <source>The HandlerFunc type is an adapter to allow the use of ordinary functions as HTTP handlers. If f is a function with the appropriate signature, HandlerFunc(f) is a Handler that calls f.</source>
          <target state="translated">HandlerFunc 유형은 일반 함수를 HTTP 핸들러로 사용할 수 있도록하는 어댑터입니다. f가 적절한 서명을 가진 함수이면 HandlerFunc (f)는 f를 호출하는 핸들러입니다.</target>
        </trans-unit>
        <trans-unit id="dcde06a75814cbd2f82c57451a15f7098bfdc1f6" translate="yes" xml:space="preserve">
          <source>The Hijacker interface is implemented by ResponseWriters that allow an HTTP handler to take over the connection.</source>
          <target state="translated">하이재커 인터페이스는 HTTP 핸들러가 연결을 인계 할 수 있도록하는 ResponseWriters에 의해 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="3370b385b8e5dd84393ea8ba4a384825a13db61b" translate="yes" xml:space="preserve">
          <source>The Interface type describes the requirements for a type using the routines in this package. Any type that implements it may be used as a min-heap with the following invariants (established after Init has been called or if the data is empty or sorted):</source>
          <target state="translated">인터페이스 유형은이 패키지의 루틴을 사용하여 유형에 대한 요구 사항을 설명합니다. 이를 구현하는 모든 유형은 다음과 같은 변형이있는 최소 힙으로 사용될 수 있습니다 (Init가 호출 된 후 또는 데이터가 비어 있거나 정렬 된 경우).</target>
        </trans-unit>
        <trans-unit id="0aee04eced9ac7c3fac2de601ac7413fde3bf654" translate="yes" xml:space="preserve">
          <source>The JSON null value unmarshals into an interface, map, pointer, or slice by setting that Go value to nil. Because null is often used in JSON to mean &amp;ldquo;not present,&amp;rdquo; unmarshaling a JSON null into any other Go type has no effect on the value and produces no error.</source>
          <target state="translated">JSON null 값은 해당 Go 값을 nil로 설정하여 인터페이스, 맵, 포인터 또는 슬라이스로 마샬링 해제합니다. null은 종종 &quot;존재하지 않음&quot;을 의미하기 위해 JSON에서 사용되므로 JSON null을 다른 Go 유형으로 마샬링 해제해도 값에 영향을 미치지 않으며 오류가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="22f4320ee94c207b6f6c1bf76ec0cc99a4e78e12" translate="yes" xml:space="preserve">
          <source>The Listen function creates servers:</source>
          <target state="translated">청취 기능은 서버를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="f1e8051445ee7295f2015e153c91e6e9f468a7b9" translate="yes" xml:space="preserve">
          <source>The Map type is optimized for two common use cases: (1) when the entry for a given key is only ever written once but read many times, as in caches that only grow, or (2) when multiple goroutines read, write, and overwrite entries for disjoint sets of keys. In these two cases, use of a Map may significantly reduce lock contention compared to a Go map paired with a separate Mutex or RWMutex.</source>
          <target state="translated">맵 유형은 두 가지 일반적인 사용 사례에 최적화되어 있습니다. (1) 주어진 키에 대한 항목이 한 번만 기록되었지만 계속 커지는 캐시 에서처럼 여러 번 읽히는 경우 또는 (2) 여러 고 루틴이 읽고 쓰거나 분리 된 키 세트에 대한 항목을 겹쳐 씁니다. 이 두 가지 경우에 맵을 사용하면 별도의 Mutex 또는 RWMutex와 쌍을 이루는 Go 맵에 비해 잠금 경합이 크게 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="93c1aea237df8273d73d6b2b1db4e7c127b7fdb2" translate="yes" xml:space="preserve">
          <source>The Map type is specialized. Most code should use a plain Go map instead, with separate locking or coordination, for better type safety and to make it easier to maintain other invariants along with the map content.</source>
          <target state="translated">지도 유형이 특화되어 있습니다. 대부분의 코드는 별도의 잠금 또는 조정 기능이있는 일반 Go 맵을 대신 사용하여 유형 안전성을 높이고 맵 내용과 함께 다른 불변을 쉽게 유지 관리해야합니다.</target>
        </trans-unit>
        <trans-unit id="0006e6725a631489c9423aa1f192586acc3a14d6" translate="yes" xml:space="preserve">
          <source>The MergeMode flags control the behavior of MergePackageFiles.</source>
          <target state="translated">MergeMode 플래그는 MergePackageFiles의 동작을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="46419978a96c95f07df701b47af9ce0c381fb8e5" translate="yes" xml:space="preserve">
          <source>The New function creates errors whose only content is a text message.</source>
          <target state="translated">New 함수는 내용 만 문자 메시지 인 오류를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="ed989955d8475da0903bbb33a13d3c6797487592" translate="yes" xml:space="preserve">
          <source>The PC field will be a value returned by a call to the traceback function.</source>
          <target state="translated">PC 필드는 역 추적 함수 호출에 의해 리턴되는 값입니다.</target>
        </trans-unit>
        <trans-unit id="886ce6ce1a2e11f65b175c91749f88d574c43226" translate="yes" xml:space="preserve">
          <source>The PNG specification is at &lt;a href=&quot;https://www.w3.org/TR/PNG/&quot;&gt;https://www.w3.org/TR/PNG/&lt;/a&gt;.</source>
          <target state="translated">PNG 사양은 &lt;a href=&quot;https://www.w3.org/TR/PNG/&quot;&gt;https://www.w3.org/TR/PNG/에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="c904da70bc4311012997fe9bbd4ccc021eaf72a0" translate="yes" xml:space="preserve">
          <source>The Pos value for a given file is a number in the range [base, base+size], where base and size are specified when a file is added to the file set. The difference between a Pos value and the corresponding file base corresponds to the byte offset of that position (represented by the Pos value) from the beginning of the file. Thus, the file base offset is the Pos value representing the first byte in the file.</source>
          <target state="translated">주어진 파일에 대한 Pos 값은 [base, base + size] 범위의 숫자이며, 파일 세트에 파일이 추가 될 때 기본 및 크기가 지정됩니다. Pos 값과 해당 파일베이스 간의 차이는 파일 시작 부분에서 해당 위치 (Pos 값으로 표시됨)의 바이트 오프셋에 해당합니다. 따라서 파일 기본 오프셋은 파일의 첫 번째 바이트를 나타내는 Pos 값입니다.</target>
        </trans-unit>
        <trans-unit id="e01da8fcfe6b3b9e18fc8125aed80da656d99c50" translate="yes" xml:space="preserve">
          <source>The Pos value for a given file is a number in the range [base, base+size], where base and size are specified when adding the file to the file set via AddFile.</source>
          <target state="translated">지정된 파일의 Pos 값은 [base, base + size] 범위의 숫자이며, AddFile을 통해 파일 세트에 파일을 추가 할 때 base 및 size가 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="24b49c8f6cf4d6923667f2f4ded23d7140a2b9f0" translate="yes" xml:space="preserve">
          <source>The Priority is a combination of the syslog facility and severity. For example, LOG_ALERT | LOG_FTP sends an alert severity message from the FTP facility. The default severity is LOG_EMERG; the default facility is LOG_KERN.</source>
          <target state="translated">우선 순위는 syslog 기능과 심각도의 조합입니다. 예를 들면 다음과 같습니다. LOG_ALERT | LOG_FTP는 FTP 기능에서 경고 심각도 메시지를 보냅니다. 기본 심각도는 LOG_EMERG입니다. 기본 기능은 LOG_KERN입니다.</target>
        </trans-unit>
        <trans-unit id="c56c9b0bbe08c95a239dcc95eda30597b6ca619e" translate="yes" xml:space="preserve">
          <source>The Process it returns can be used to obtain information about the underlying operating system process.</source>
          <target state="translated">반환 된 프로세스는 기본 운영 체제 프로세스에 대한 정보를 얻는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10801c2ff1093f1ce7c760ba00803c382474a94e" translate="yes" xml:space="preserve">
          <source>The RSA operations in this package are not implemented using constant-time algorithms.</source>
          <target state="translated">이 패키지의 RSA 작업은 상수 시간 알고리즘을 사용하여 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e75efacd08116681c05f3907c86c9cdff60db179" translate="yes" xml:space="preserve">
          <source>The ReadCloser returned by NewReader also implements Resetter.</source>
          <target state="translated">NewReader가 반환 한 ReadCloser도 Resetter를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="3bfc20a3944403086f24f5757939a8cbd9b7c5ac" translate="yes" xml:space="preserve">
          <source>The ReadCloser returned by NewReaderDict also implements Resetter.</source>
          <target state="translated">NewReaderDict에 의해 반환 된 ReadCloser도 Resetter를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="c4f8edaea822742e73d1aca6a1265098af5d579e" translate="yes" xml:space="preserve">
          <source>The Reader converts all \r\n sequences in its input to plain \n, including in multiline field values, so that the returned data does not depend on which line-ending convention an input file uses.</source>
          <target state="translated">Reader는 여러 줄 필드 값을 포함하여 입력의 모든 \ r \ n 시퀀스를 일반 \ n으로 변환하므로 반환 된 데이터는 입력 파일이 사용하는 줄 끝 규칙에 의존하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="41c2e3518894534a6a634c57bbad5ea70224c3de" translate="yes" xml:space="preserve">
          <source>The Reader.Header fields will be valid in the Reader returned.</source>
          <target state="translated">Reader.Header 필드는 반환 된 Reader에서 유효합니다.</target>
        </trans-unit>
        <trans-unit id="9fd8011df0852a1e27b3907bd2a3f82247ef31e5" translate="yes" xml:space="preserve">
          <source>The Request.Proto is always HTTP/1.1.</source>
          <target state="translated">Request.Proto는 항상 HTTP / 1.1입니다.</target>
        </trans-unit>
        <trans-unit id="09c4e81d433af7e0ae48c721f621859a4e5a3317" translate="yes" xml:space="preserve">
          <source>The Response Body is closed after it is sent.</source>
          <target state="translated">응답 본문은 전송 된 후 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="041fd8da9679545d4de46a3a12d665330f551006" translate="yes" xml:space="preserve">
          <source>The Response.Body is guaranteed to be non-nil and Body.Read call is guaranteed to not return any error other than io.EOF.</source>
          <target state="translated">Response.Body는 0이 아니며 Body.Read 호출은 io.EOF 이외의 오류를 리턴하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bc99bfa959e73d9ff72d10e54ecd5ffaa2259252" translate="yes" xml:space="preserve">
          <source>The Response.Header is a snapshot of the headers at the time of the first write call, or at the time of this call, if the handler never did a write.</source>
          <target state="translated">Response.Header는 첫 번째 쓰기 호출 시점 또는 핸들러가 쓰기를 수행하지 않은 경우이 호출 시점의 헤더 스냅 샷입니다.</target>
        </trans-unit>
        <trans-unit id="18a3ebac1f2c2059df0438aac114025f62ecfbf9" translate="yes" xml:space="preserve">
          <source>The Run methods of T and B allow defining subtests and sub-benchmarks, without having to define separate functions for each. This enables uses like table-driven benchmarks and creating hierarchical tests. It also provides a way to share common setup and tear-down code:</source>
          <target state="translated">T 및 B의 Run 방법을 사용하면 각각에 대해 별도의 기능을 정의하지 않고도 하위 테스트 및 하위 벤치 마크를 정의 할 수 있습니다. 이를 통해 테이블 ​​중심 벤치 마크 및 계층 적 테스트 작성과 같은 사용이 가능합니다. 또한 일반적인 설정 및 해제 코드를 공유하는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2fdffd1148a25e94f2ea65756e345947d69016d2" translate="yes" xml:space="preserve">
          <source>The SendMail function and the net/smtp package are low-level mechanisms and provide no support for DKIM signing, MIME attachments (see the mime/multipart package), or other mail functionality. Higher-level packages exist outside of the standard library.</source>
          <target state="translated">SendMail 기능 및 net / smtp 패키지는 저수준 메커니즘이며 DKIM 서명, MIME 첨부 파일 (mime / multipart 패키지 참조) 또는 기타 메일 기능을 지원하지 않습니다. 더 높은 수준의 패키지는 표준 라이브러리 외부에 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9a92bd5980ed21b3a625476d07c987591bfa7d7" translate="yes" xml:space="preserve">
          <source>The Spec type stands for any of *ImportSpec, *ValueSpec, and *TypeSpec.</source>
          <target state="translated">스펙 유형은 * ImportSpec, * ValueSpec 및 * TypeSpec을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4919a225e3add39379ff15a9bce358f52cae5ffb" translate="yes" xml:space="preserve">
          <source>The Syscall functions in package syscall pass their uintptr arguments directly to the operating system, which then may, depending on the details of the call, reinterpret some of them as pointers. That is, the system call implementation is implicitly converting certain arguments back from uintptr to pointer.</source>
          <target state="translated">패키지 syscall의 Syscall 함수는 uintptr 인수를 운영 체제에 직접 전달한 다음 호출 세부 사항에 따라 일부를 포인터로 재 해석 할 수 있습니다. 즉, 시스템 호출 구현은 특정 인수를 uintptr에서 포인터로 암시 적으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="3e332fd0096a988b6619d722b0818e386abfd30a" translate="yes" xml:space="preserve">
          <source>The TIFF file format uses a similar but incompatible version of the LZW algorithm. See the golang.org/x/image/tiff/lzw package for an implementation.</source>
          <target state="translated">TIFF 파일 형식은 비슷하지만 호환되지 않는 LZW 알고리즘 버전을 사용합니다. 구현 방법은 golang.org/x/image/tiff/lzw 패키지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="58336a8c0934089954efcd803d6fca80fefa9eb4" translate="yes" xml:space="preserve">
          <source>The TLS field is set to a non-nil dummy value if target has scheme &quot;https&quot;.</source>
          <target state="translated">대상에 &quot;https&quot;체계가있는 경우 TLS 필드는 0이 아닌 더미 값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="0c9be03471b041f93e1251c475d46cfa7c686fa2" translate="yes" xml:space="preserve">
          <source>The Text field contains the comment text without carriage returns (\r) that may have been present in the source. Because a comment's end position is computed using len(Text), the position reported by End() does not match the true source end position for comments containing carriage returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d581afca4a5305392d28788d2eee7630e8dc138a" translate="yes" xml:space="preserve">
          <source>The Time returned by time.Now contains a monotonic clock reading. If Time t has a monotonic clock reading, t.Add adds the same duration to both the wall clock and monotonic clock readings to compute the result. Because t.AddDate(y, m, d), t.Round(d), and t.Truncate(d) are wall time computations, they always strip any monotonic clock reading from their results. Because t.In, t.Local, and t.UTC are used for their effect on the interpretation of the wall time, they also strip any monotonic clock reading from their results. The canonical way to strip a monotonic clock reading is to use t = t.Round(0).</source>
          <target state="translated">시간에 의해 반환 된 시간. 이제 단조로운 시계 판독 값이 포함됩니다. 시간 t에 단조로운 시계 판독 값이있는 경우, t.Add는 벽시계와 단조로운 시계 판독 값에 동일한 지속 시간을 추가하여 결과를 계산합니다. t.AddDate (y, m, d), t.Round (d) 및 t.Truncate (d)는 월 시간 계산이므로 항상 결과에서 단조로운 시계 판독 값을 제거합니다. t.In, t.Local 및 t.UTC는 벽 시간 해석에 영향을주기 위해 사용되므로 결과에서 단조로운 시계 판독 값도 제거합니다. 단조로운 시계 판독 값을 제거하는 표준 방법은 t = t.Round (0)를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="33e81456d15715e940a5919174eaa3f7637dcde7" translate="yes" xml:space="preserve">
          <source>The Timer type represents a single event. When the Timer expires, the current time will be sent on C, unless the Timer was created by AfterFunc. A Timer must be created with NewTimer or AfterFunc.</source>
          <target state="translated">타이머 유형은 단일 이벤트를 나타냅니다. 타이머가 만료되면 AfterFunc에서 타이머를 만들지 않은 경우 현재 시간이 C로 전송됩니다. 타이머는 NewTimer 또는 AfterFunc를 사용하여 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="cf73d1723f31995bde582871be9d0a7a3c49f2e8" translate="yes" xml:space="preserve">
          <source>The Universe scope contains all predeclared objects of Go. It is the outermost scope of any chain of nested scopes.</source>
          <target state="translated">유니버스 범위에는 미리 선언 된 모든 Go 개체가 포함됩니다. 중첩 된 범위 체인 중 가장 바깥 쪽 범위입니다.</target>
        </trans-unit>
        <trans-unit id="d2217feb010f2a9e20eb107dc97fbe00b28a97e3" translate="yes" xml:space="preserve">
          <source>The Unsafe package is the package returned by an importer for the import path &quot;unsafe&quot;.</source>
          <target state="translated">안전하지 않은 패키지는 가져 오기 경로 &quot;안전하지 않은&quot;에 대해 수입자가 반환 한 패키지입니다.</target>
        </trans-unit>
        <trans-unit id="82e1a6db6a2ce451395a30960fcbaa8d447276c7" translate="yes" xml:space="preserve">
          <source>The Unwrap, Is and As functions work on errors that may wrap other errors. An error wraps another error if its type has the method</source>
          <target state="translated">Unwrap, Is 및 As 기능은 다른 오류를 감쌀 수있는 오류에 대해 작동합니다. 유형에 메소드가있는 경우 오류가 다른 오류를 줄임</target>
        </trans-unit>
        <trans-unit id="84a102639d5d98f811fc502808b53b881ef02020" translate="yes" xml:space="preserve">
          <source>The Userinfo type is an immutable encapsulation of username and password details for a URL. An existing Userinfo value is guaranteed to have a username set (potentially empty, as allowed by RFC 2396), and optionally a password.</source>
          <target state="translated">Userinfo 유형은 URL의 사용자 이름 및 비밀번호 세부 사항을 변경할 수없는 캡슐화입니다. 기존 Userinfo 값은 사용자 이름 설정 (RFC 2396에서 허용하는대로 비어있을 수 있음) 및 선택적으로 암호를 갖도록 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="fbd19f3117c4f5404c3dc4318c570ed741a162cd" translate="yes" xml:space="preserve">
          <source>The Value.Call method allows the caller to invoke a typed function in terms of Values; in contrast, MakeFunc allows the caller to implement a typed function in terms of Values.</source>
          <target state="translated">Value.Call 메서드를 사용하면 호출자가 값으로 입력 된 함수를 호출 할 수 있습니다. 반대로 MakeFunc를 사용하면 호출자가 값으로 형식화 된 함수를 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b671f0d2f06db5c55a3ebed77ddd3e1fdacf58bc" translate="yes" xml:space="preserve">
          <source>The Wait method will return the exit code and release associated resources once the command exits.</source>
          <target state="translated">Wait 메소드는 종료 코드를 리턴하고 명령이 종료되면 연관된 자원을 해제합니다.</target>
        </trans-unit>
        <trans-unit id="f996448ff14d875bb2a49935e2e1a1c11597d19a" translate="yes" xml:space="preserve">
          <source>The WithCancel, WithDeadline, and WithTimeout functions take a Context (the parent) and return a derived Context (the child) and a CancelFunc. Calling the CancelFunc cancels the child and its children, removes the parent's reference to the child, and stops any associated timers. Failing to call the CancelFunc leaks the child and its children until the parent is canceled or the timer fires. The go vet tool checks that CancelFuncs are used on all control-flow paths.</source>
          <target state="translated">WithCancel, WithDeadline 및 WithTimeout 함수는 컨텍스트 (부모)를 가져오고 파생 된 컨텍스트 (자식) 및 CancelFunc를 반환합니다. CancelFunc를 호출하면 자식과 그 자식을 취소하고 자식에 대한 부모의 참조를 제거하며 관련된 타이머를 중지합니다. CancelFunc를 호출하지 않으면 부모가 취소되거나 타이머가 실행될 때까지 자식과 자식이 누출됩니다. Go vet 도구는 CancelFuncs가 모든 제어 흐름 경로에 사용되는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="7ad67f6f0923ebfa2c780fb9b0118879fff918f1" translate="yes" xml:space="preserve">
          <source>The Writer assumes that all Unicode code points have the same width; this may not be true in some fonts or if the string contains combining characters.</source>
          <target state="translated">라이터는 모든 유니 코드 코드 포인트의 너비가 같다고 가정합니다. 일부 글꼴 또는 문자열에 결합 문자가 포함 된 경우에는 해당되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4b495842c9aa071c7e0475777b24079ec5d06f2" translate="yes" xml:space="preserve">
          <source>The Writer currently provides no support for sparse files.</source>
          <target state="translated">Writer는 현재 스파 스 파일을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="53af9c2eed3edf32c0f1e34e826ade2723d6ef7e" translate="yes" xml:space="preserve">
          <source>The Writer must buffer input internally, because proper spacing of one line may depend on the cells in future lines. Clients must call Flush when done calling Write.</source>
          <target state="translated">한 줄의 적절한 간격은 향후 줄의 셀에 따라 달라질 수 있으므로 Writer는 입력을 내부적으로 버퍼링해야합니다. 클라이언트는 쓰기 호출이 끝나면 Flush를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="628a74097036f85303a5350ae981dc164e95f20b" translate="yes" xml:space="preserve">
          <source>The Writer treats incoming bytes as UTF-8-encoded text consisting of cells terminated by horizontal ('\t') or vertical ('\v') tabs, and newline ('\n') or formfeed ('\f') characters; both newline and formfeed act as line breaks.</source>
          <target state="translated">Writer는 들어오는 바이트를 가로 ( '\ t') 또는 세로 ( '\ v') 탭으로 끝나는 셀과 줄 바꿈 ( '\ n') 또는 폼 피드 ( '\ f')로 구성된 UTF-8 인코딩 텍스트로 처리합니다. 문자; 줄 바꿈과 폼 피드 모두 줄 바꿈 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="ff09099a8f170cf0d12905fa7c7238d645a38332" translate="yes" xml:space="preserve">
          <source>The XML element for a struct contains marshaled elements for each of the exported fields of the struct, with these exceptions:</source>
          <target state="translated">구조체의 XML 요소에는 구조체의 내 보낸 필드 각각에 대한 마샬링 된 요소가 포함되며 다음과 같은 예외가 있습니다.</target>
        </trans-unit>
        <trans-unit id="79336ab4324d9f5dfdaefa0128d6e4be21b88b75" translate="yes" xml:space="preserve">
          <source>The []byte arguments are the data from the corresponding debug section in the object file; for example, for an ELF object, abbrev is the contents of the &quot;.debug_abbrev&quot; section.</source>
          <target state="translated">[] 바이트 인수는 오브젝트 파일에서 해당 디버그 섹션의 데이터입니다. 예를 들어 ELF 객체의 경우 abbrev는 &quot;.debug_abbrev&quot;섹션의 내용입니다.</target>
        </trans-unit>
        <trans-unit id="76c0ad8d05ede9a06fba9319e4883b6c3aed9f8a" translate="yes" xml:space="preserve">
          <source>The actual read interface needed by NewReader. If the passed in io.Reader does not also have ReadByte, the NewReader will introduce its own buffering.</source>
          <target state="translated">NewReader에 필요한 실제 읽기 인터페이스. 전달 된 io.Reader에 ReadByte도없는 경우 NewReader는 자체 버퍼링을 도입합니다.</target>
        </trans-unit>
        <trans-unit id="c853d84a15cfc8c913087ccf677e5edf1ca53e04" translate="yes" xml:space="preserve">
          <source>The add operation, implemented by the AddT functions, is the atomic equivalent of:</source>
          <target state="translated">AddT 함수로 구현 된 추가 작업은 다음과 같은 원자 적 요소입니다.</target>
        </trans-unit>
        <trans-unit id="7b4a22ebac17d94f75fe50addbae480c54b8e412" translate="yes" xml:space="preserve">
          <source>The addresses in the to parameter are the SMTP RCPT addresses.</source>
          <target state="translated">to 매개 변수의 주소는 SMTP RCPT 주소입니다.</target>
        </trans-unit>
        <trans-unit id="fa78f066db9b3a5524ca42a8affe77f75da9d63e" translate="yes" xml:space="preserve">
          <source>The allocs profile is the same as the heap profile but changes the default pprof display to -alloc_space, the total number of bytes allocated since the program began (including garbage-collected bytes).</source>
          <target state="translated">allocs 프로파일은 힙 프로파일과 동일하지만 기본 pprof 표시를 -alloc_space (프로그램이 시작된 이후 할당 된 총 바이트 수 (가비지 수집 된 바이트 포함))로 변경합니다.</target>
        </trans-unit>
        <trans-unit id="7b7e2adce610eba0eb46d47752259233e509b5f5" translate="yes" xml:space="preserve">
          <source>The append built-in function appends elements to the end of a slice. If it has sufficient capacity, the destination is resliced to accommodate the new elements. If it does not, a new underlying array will be allocated. Append returns the updated slice. It is therefore necessary to store the result of append, often in the variable holding the slice itself:</source>
          <target state="translated">내장 기능 추가 기능은 슬라이스 끝에 요소를 추가합니다. 용량이 충분하면 대상이 새 요소를 수용하도록 슬라이스됩니다. 그렇지 않은 경우 새로운 기본 배열이 할당됩니다. 추가는 업데이트 된 슬라이스를 반환합니다. 따라서 추가 결과를 종종 슬라이스 자체를 보유하는 변수에 저장해야합니다.</target>
        </trans-unit>
        <trans-unit id="319121c4cf28a1a73f5a5d055a29a23993940f46" translate="yes" xml:space="preserve">
          <source>The argument obj must be a pointer to an object allocated by calling new, by taking the address of a composite literal, or by taking the address of a local variable. The argument finalizer must be a function that takes a single argument to which obj's type can be assigned, and can have arbitrary ignored return values. If either of these is not true, SetFinalizer may abort the program.</source>
          <target state="translated">인수 obj는 new를 호출하거나 복합 리터럴의 주소를 사용하거나 로컬 변수의 주소를 사용하여 할당 된 객체에 대한 포인터 여야합니다. 인수 finalizer는 obj의 유형을 지정할 수있는 단일 인수를 가져오고 임의의 무시 된 반환 값을 가질 수있는 함수 여야합니다. 둘 중 하나라도 해당되지 않으면 SetFinalizer가 프로그램을 중단 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd8b4269726f03ea74d83f3435788f2723fca1f6" translate="yes" xml:space="preserve">
          <source>The argument pos must have been returned by a call to Tell on this line table.</source>
          <target state="translated">이 행 테이블에서 Tell을 호출하면 pos 인수가 리턴되어야합니다.</target>
        </trans-unit>
        <trans-unit id="b92996537add2723dc45807913fd63c71882192d" translate="yes" xml:space="preserve">
          <source>The argument to the -run and -bench command-line flags is an unanchored regular expression that matches the test's name. For tests with multiple slash-separated elements, such as subtests, the argument is itself slash-separated, with expressions matching each name element in turn. Because it is unanchored, an empty expression matches any string. For example, using &quot;matching&quot; to mean &quot;whose name contains&quot;:</source>
          <target state="translated">-run 및 -bench 명령 행 플래그에 대한 인수는 테스트 이름과 일치하는 고정되지 않은 정규식입니다. 하위 테스트와 같이 슬래시로 구분 된 여러 요소가있는 테스트의 경우 인수는 슬래시로 구분되며 각 이름 요소와 차례로 일치하는 표현식이 사용됩니다. 고정되지 않았으므로 빈 표현식은 모든 문자열과 일치합니다. 예를 들어, &quot;일치하는&quot;을 사용하여 &quot;이름이 포함 된&quot;을 의미하는 경우 :</target>
        </trans-unit>
        <trans-unit id="e79a98521fd13244e0b154d938bb00c75c9b0451" translate="yes" xml:space="preserve">
          <source>The base argument must be 0 or a value between 2 and MaxBase. For base 0, the number prefix determines the actual base: A prefix of &amp;ldquo;0b&amp;rdquo; or &amp;ldquo;0B&amp;rdquo; selects base 2, &amp;ldquo;0&amp;rdquo;, &amp;ldquo;0o&amp;rdquo; or &amp;ldquo;0O&amp;rdquo; selects base 8, and &amp;ldquo;0x&amp;rdquo; or &amp;ldquo;0X&amp;rdquo; selects base 16. Otherwise, the selected base is 10 and no prefix is accepted.</source>
          <target state="translated">기본 인수는 0 또는 2와 MaxBase 사이의 값이어야합니다. 밑줄 0의 경우, 숫자 접두어가 실제 밑변을 결정합니다. &quot;0b&quot;또는 &quot;0B&quot;의 접두어는 밑줄 2를 선택하고 &quot;0&quot;, &quot;0o&quot;또는 &quot;0O&quot;는 밑줄 8을 선택하고 &quot;0x&quot;또는 &quot;0X&quot;는 선택합니다 그렇지 않으면 선택한 기준은 10이고 접두사는 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1f5bc3650196f245f397cccfe0b715471a484024" translate="yes" xml:space="preserve">
          <source>The base argument must be 0, 2, 8, 10, or 16. Providing an invalid base argument will lead to a run-time panic.</source>
          <target state="translated">기본 인수는 0, 2, 8, 10 또는 16이어야합니다. 잘못된 기본 인수를 제공하면 런타임 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="999251e457607fde479613cc188e10bb8aa35ffc" translate="yes" xml:space="preserve">
          <source>The behavior of Close after the first call is undefined. Specific implementations may document their own behavior.</source>
          <target state="translated">첫 번째 호출 후 닫기 동작은 정의되지 않습니다. 특정 구현은 자체 동작을 문서화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5501fbd34c66d8be25df49275f9a5880a90030a" translate="yes" xml:space="preserve">
          <source>The benchmark function must run the target code b.N times. During benchmark execution, b.N is adjusted until the benchmark function lasts long enough to be timed reliably. The output</source>
          <target state="translated">벤치 마크 함수는 대상 코드를 bN 회 실행해야합니다. 벤치 마크 실행 동안 bN은 벤치 마크 기능이 안정적으로 시간을 초과 할 정도로 오래 지속될 때까지 조정됩니다. 출력</target>
        </trans-unit>
        <trans-unit id="5d5239994cd75391745c3ffd216fe5a8cda11e2c" translate="yes" xml:space="preserve">
          <source>The bin/ directory holds compiled commands. Each command is named for its source directory, but only using the final element, not the entire path. That is, the command with source in DIR/src/foo/quux is installed into DIR/bin/quux, not DIR/bin/foo/quux. The foo/ is stripped so that you can add DIR/bin to your PATH to get at the installed commands.</source>
          <target state="translated">bin / 디렉토리에는 컴파일 된 명령이 있습니다. 각 명령의 이름은 소스 디렉토리로 지정되지만 전체 경로가 아닌 최종 요소 만 사용합니다. 즉, DIR / src / foo / quux에 소스가있는 명령은 DIR / bin / foo / quux가 아닌 DIR / bin / quux에 설치됩니다. foo /는 제거되어 PATH에 DIR / bin을 추가하여 설치된 명령을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fb2943938d895315eb0861e562b65ec37e4257a" translate="yes" xml:space="preserve">
          <source>The bitSize argument specifies the integer type that the result must fit into. Bit sizes 0, 8, 16, 32, and 64 correspond to int, int8, int16, int32, and int64. If bitSize is below 0 or above 64, an error is returned.</source>
          <target state="translated">bitSize 인수는 결과가 적합해야하는 정수 유형을 지정합니다. 비트 크기 0, 8, 16, 32 및 64는 int, int8, int16, int32 및 int64에 해당합니다. bitSize가 0보다 작거나 64보다 크면 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="73a023e42c8f449dd9afceb038f53730f09d0f3a" translate="yes" xml:space="preserve">
          <source>The blocksize of MD5 in bytes.</source>
          <target state="translated">MD5의 블록 크기 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="b15f9638286bf74ad9f05789a97346025af52de4" translate="yes" xml:space="preserve">
          <source>The blocksize of SHA-1 in bytes.</source>
          <target state="translated">SHA-1의 블록 크기 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="a7b36663bea360572efce2e38cb3e1eb26ceecf3" translate="yes" xml:space="preserve">
          <source>The blocksize of SHA256 and SHA224 in bytes.</source>
          <target state="translated">바이트 단위의 SHA256 및 SHA224의 블록 크기입니다.</target>
        </trans-unit>
        <trans-unit id="97aa274f72b6214d58f8cac268e6604a5f6faa7b" translate="yes" xml:space="preserve">
          <source>The body function will be run in each goroutine. It should set up any goroutine-local state and then iterate until pb.Next returns false. It should not use the StartTimer, StopTimer, or ResetTimer functions, because they have global effect. It should also not call Run.</source>
          <target state="translated">신체 기능은 각 고 루틴에서 실행됩니다. goroutine-local 상태를 설정 한 다음 pb.Next가 false를 리턴 할 때까지 반복해야합니다. StartTimer, StopTimer 또는 ResetTimer 함수는 전역 효과가 있으므로 사용하지 않아야합니다. 또한 Run을 호출해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="af7dc8ebb6f00c62864546d31e047f12c2a2774d" translate="yes" xml:space="preserve">
          <source>The boolean functions take any zero value to be false and a non-zero value to be true.</source>
          <target state="translated">부울 함수는 0을 false로, 0이 아닌 값을 true로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="0ca3ec8906bf9075e98bceae22793965b445ac42" translate="yes" xml:space="preserve">
          <source>The boundary is usually obtained from the &quot;boundary&quot; parameter of the message's &quot;Content-Type&quot; header. Use mime.ParseMediaType to parse such headers.</source>
          <target state="translated">경계는 일반적으로 메시지 &quot;Content-Type&quot;헤더의 &quot;boundary&quot;매개 변수에서 가져옵니다. 이러한 헤더를 구문 분석하려면 mime.ParseMediaType을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="93f9cb3d63de38d1cca4d1f9efd9ca872f4716ce" translate="yes" xml:space="preserve">
          <source>The built-in table is small but on unix it is augmented by the local system's mime.types file(s) if available under one or more of these names:</source>
          <target state="translated">내장 테이블은 작지만 유닉스에서는 하나 이상의 다음 이름으로 로컬 시스템의 mime.types 파일에 의해 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="d093a31770ef0176a6cc811f5e90de0295df923b" translate="yes" xml:space="preserve">
          <source>The byte offsets for each file in a file set are mapped into distinct (integer) intervals, one interval [base, base+size] per file. Base represents the first byte in the file, and size is the corresponding file size. A Pos value is a value in such an interval. By determining the interval a Pos value belongs to, the file, its file base, and thus the byte offset (position) the Pos value is representing can be computed.</source>
          <target state="translated">파일 세트의 각 파일에 대한 바이트 오프셋은 파일 당 하나의 간격 [기본, 기본 + 크기] 인 고유 한 (정수) 간격으로 매핑됩니다. Base는 파일의 첫 번째 바이트를 나타내고 size는 해당 파일 크기입니다. Pos 값은 이러한 간격의 값입니다. Pos 값이 속하는 간격을 결정함으로써 파일, 파일베이스 및 Pos 값이 나타내는 바이트 오프셋 (위치)을 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3abe768a37a21ebff40b7c9151a7b3edc6c44e0" translate="yes" xml:space="preserve">
          <source>The calendrical calculations always assume a Gregorian calendar, with no leap seconds.</source>
          <target state="translated">달력 계산은 항상 윤초가없는 그레고리력을 가정합니다.</target>
        </trans-unit>
        <trans-unit id="dd3a4f20159bb2231f4a88b4a45f4b772e80ba3c" translate="yes" xml:space="preserve">
          <source>The caller should call Close when finished, to shut it down.</source>
          <target state="translated">호출자가 종료되면 닫기를 호출하여 종료해야합니다.</target>
        </trans-unit>
        <trans-unit id="257fee20f0af9c58c89645e121bcb859cd7d2ba2" translate="yes" xml:space="preserve">
          <source>The cap built-in function returns the capacity of v, according to its type:</source>
          <target state="translated">cap 내장 함수는 유형에 따라 v의 용량을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e553ed25dbd923acc16eb919df1e53d3eec5c8ba" translate="yes" xml:space="preserve">
          <source>The certificate is signed by parent. If parent is equal to template then the certificate is self-signed. The parameter pub is the public key of the signee and priv is the private key of the signer.</source>
          <target state="translated">인증서는 부모가 서명합니다. 부모가 템플릿과 같으면 인증서가 자체 서명됩니다. 매개 변수 pub는 서명자의 공개 키이고 priv는 서명자의 개인 키입니다.</target>
        </trans-unit>
        <trans-unit id="dc1a26e65aace69e5a0db7ec46a4e897871c5c8e" translate="yes" xml:space="preserve">
          <source>The chain consists of err itself followed by the sequence of errors obtained by repeatedly calling Unwrap.</source>
          <target state="translated">체인은 err 자체와 Unwrap을 반복적으로 호출하여 얻은 일련의 오류로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="784fcd80e08909ffdec4906c1c0dba2f7d623904" translate="yes" xml:space="preserve">
          <source>The client must close the response body when finished with it:</source>
          <target state="translated">클라이언트는 다음과 같이 응답 본문을 닫아야합니다.</target>
        </trans-unit>
        <trans-unit id="7b4dd52e8c63aa6987cf8c226672c7d4edb96f82" translate="yes" xml:space="preserve">
          <source>The close built-in function closes a channel, which must be either bidirectional or send-only. It should be executed only by the sender, never the receiver, and has the effect of shutting down the channel after the last sent value is received. After the last value has been received from a closed channel c, any receive from c will succeed without blocking, returning the zero value for the channel element. The form</source>
          <target state="translated">내장 기능 닫기 기능은 양방향 또는 전송 전용 채널이어야합니다. 송신자는 수신자가 아닌 송신자 만 실행해야하며 마지막 송신 된 값을 수신 한 후 채널을 종료하는 효과가 있습니다. 닫힌 채널 c에서 마지막 값을 수신 한 후 c로부터의 모든 수신은 차단하지 않고 채널 요소의 0 값을 반환합니다. 형태</target>
        </trans-unit>
        <trans-unit id="0c580a2c87e0f2186896309d301dc63aad975a10" translate="yes" xml:space="preserve">
          <source>The command must have been started by Start.</source>
          <target state="translated">명령은 시작으로 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="ef8e35ecfe346ef37bdb6a41007c64b491f6581e" translate="yes" xml:space="preserve">
          <source>The comment prefix &quot;Unordered output:&quot; is like &quot;Output:&quot;, but matches any line order:</source>
          <target state="translated">주석 접두어 &quot;정렬되지 않은 출력 :&quot;은 &quot;출력 :&quot;과 비슷하지만 모든 행 순서와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="af6f6bfe9472d6cd742ab07f4d13576c62ddc94c" translate="yes" xml:space="preserve">
          <source>The compare-and-swap operation, implemented by the CompareAndSwapT functions, is the atomic equivalent of:</source>
          <target state="translated">CompareAndSwapT 함수로 구현 된 비교 및 ​​스왑 작업은 원자 적으로 다음과 같습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
