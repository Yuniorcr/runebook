<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="go">
    <body>
      <group id="go">
        <trans-unit id="e6a6e8cadfebe9c4799e999d069f9213bb24bed9" translate="yes" xml:space="preserve">
          <source>FuncOf</source>
          <target state="translated">FuncOf</target>
        </trans-unit>
        <trans-unit id="d863a41e98edea4d63050f4d41d85e38ee53432a" translate="yes" xml:space="preserve">
          <source>FuncOf returns a wrapped function.</source>
          <target state="translated">FuncOf는 랩핑 된 함수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="93a168211e34460ad795ada01d7598344ab1ff0e" translate="yes" xml:space="preserve">
          <source>FuncOf returns the function type with the given argument and result types. For example if k represents int and e represents string, FuncOf([]Type{k}, []Type{e}, false) represents func(int) string.</source>
          <target state="translated">FuncOf는 주어진 인수와 결과 타입으로 함수 타입을 반환합니다. 예를 들어 k가 int를 나타내고 e가 문자열을 나타내는 경우 FuncOf ([] Type {k}, [] Type {e}, false)는 func (int) 문자열을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e545c5b7597389c332937a417c6dbb10d7b9c2b9" translate="yes" xml:space="preserve">
          <source>Funcs adds the elements of the argument map to the template's function map. It must be called before the template is parsed. It panics if a value in the map is not a function with appropriate return type or if the name cannot be used syntactically as a function in a template. It is legal to overwrite elements of the map. The return value is the template, so calls can be chained.</source>
          <target state="translated">Funcs는 인수 맵의 요소를 템플릿의 함수 맵에 추가합니다. 템플릿을 파싱하기 전에 호출해야합니다. 맵의 값이 적절한 리턴 유형의 함수가 아니거나 이름을 템플리트의 함수로 구문 적으로 사용할 수없는 경우 패닉 상태가됩니다. 지도의 요소를 덮어 쓰는 것은 합법적입니다. 반환 값은 템플릿이므로 호출을 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d356e92562acfcaf97196969d96dd79e05dacf25" translate="yes" xml:space="preserve">
          <source>Funcs adds the elements of the argument map to the template's function map. It must be called before the template is parsed. It panics if a value in the map is not a function with appropriate return type. However, it is legal to overwrite elements of the map. The return value is the template, so calls can be chained.</source>
          <target state="translated">Funcs는 인수 맵의 요소를 템플릿의 함수 맵에 추가합니다. 템플릿을 파싱하기 전에 호출해야합니다. 맵의 값이 적절한 리턴 유형을 가진 함수가 아닌 경우 패닉 상태가됩니다. 그러나지도의 요소를 덮어 쓰는 것은 합법적입니다. 반환 값은 템플릿이므로 호출을 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="8c10d9660a016948a806bd8cbcad3722d8e6bc88" translate="yes" xml:space="preserve">
          <source>Functions and channels will not be sent in a gob. Attempting to encode such a value at the top level will fail. A struct field of chan or func type is treated exactly like an unexported field and is ignored.</source>
          <target state="translated">기능과 채널은 gob으로 전송되지 않습니다. 최상위 레벨에서 이러한 값을 인코딩하려고하면 실패합니다. chan 또는 func 유형의 struct 필드는 내 보내지 않은 필드와 동일하게 취급되며 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="515fb65b2b3a55f3a5ea9024aecd183d10145a5b" translate="yes" xml:space="preserve">
          <source>Functions of the form</source>
          <target state="translated">형태의 기능</target>
        </trans-unit>
        <trans-unit id="5bde1b79ff9cf2a64313aa293a07d05136a9d65d" translate="yes" xml:space="preserve">
          <source>Functions starting with &quot;Is&quot; can be used to inspect which table of range a rune belongs to. Note that runes may fit into more than one range.</source>
          <target state="translated">&quot;Is&quot;로 시작하는 함수를 사용하여 룬이 속한 범위 테이블을 검사 할 수 있습니다. 룬은 둘 이상의 범위에 맞을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14038939956e123c4daa0060310ed80bf1b7a49d" translate="yes" xml:space="preserve">
          <source>GC runs a garbage collection and blocks the caller until the garbage collection is complete. It may also block the entire program.</source>
          <target state="translated">GC는 가비지 수집을 실행하고 가비지 수집이 완료 될 때까지 발신자를 차단합니다. 전체 프로그램을 차단할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1dacc63b01c8608c5a77320640ce147950f96e1" translate="yes" xml:space="preserve">
          <source>GCD sets z to the greatest common divisor of a and b, which both must be &amp;gt; 0, and returns z. If x or y are not nil, GCD sets their value such that z = a*x + b*y. If either a or b is &amp;lt;= 0, GCD sets z = x = y = 0.</source>
          <target state="translated">GCD는 z를 a와 b의 최대 공약수로 설정합니다. 둘 다 0보다 커야하고 z를 반환합니다. x 또는 y가 nil이 아닌 경우 GCD는 z = a * x + b * y가되도록 값을 설정합니다. a 또는 b가 &amp;lt;= 0이면 GCD는 z = x = y = 0으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="19dd357da96d7272320f7fadf3fd2965c024dba5" translate="yes" xml:space="preserve">
          <source>GCStats collect information about recent garbage collections.</source>
          <target state="translated">GCStats는 최근 가비지 수집에 대한 정보를 수집합니다.</target>
        </trans-unit>
        <trans-unit id="d010209a0c3d0dee637f5259dfa34515f68772df" translate="yes" xml:space="preserve">
          <source>GIF represents the possibly multiple images stored in a GIF file.</source>
          <target state="translated">GIF는 GIF 파일에 저장된 여러 이미지를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f62024646db1c94f452ef8c25337fad08f62d18e" translate="yes" xml:space="preserve">
          <source>GOARCH is the running program's architecture target: one of 386, amd64, arm, s390x, and so on.</source>
          <target state="translated">GOARCH는 실행중인 프로그램의 아키텍처 대상입니다 (386, amd64, arm, s390x 등).</target>
        </trans-unit>
        <trans-unit id="cb34b31ce447e79881d19460e35c7075fc05a81a" translate="yes" xml:space="preserve">
          <source>GOMAXPROCS sets the maximum number of CPUs that can be executing simultaneously and returns the previous setting. If n &amp;lt; 1, it does not change the current setting. The number of logical CPUs on the local machine can be queried with NumCPU. This call will go away when the scheduler improves.</source>
          <target state="translated">GOMAXPROCS는 동시에 실행할 수있는 최대 CPU 수를 설정하고 이전 설정을 반환합니다. n &amp;lt;1이면 현재 설정이 변경되지 않습니다. 로컬 컴퓨터의 논리 CPU 수는 NumCPU로 쿼리 할 수 ​​있습니다. 이 통화는 스케줄러가 개선되면 사라집니다.</target>
        </trans-unit>
        <trans-unit id="ad65293e987b4a4c08430d0e000aecbc1854ac24" translate="yes" xml:space="preserve">
          <source>GOOS is the running program's operating system target: one of darwin, freebsd, linux, and so on. To view possible combinations of GOOS and GOARCH, run &quot;go tool dist list&quot;.</source>
          <target state="translated">GOOS는 실행중인 프로그램의 운영 체제 대상입니다 (다윈, freebsd, Linux 등). GOOS와 GOARCH의 가능한 조합을 보려면 &quot;go tool dist list&quot;를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="7bb230fcc10199af1bb88085306db7998e9674cd" translate="yes" xml:space="preserve">
          <source>GOROOT returns the root of the Go tree. It uses the GOROOT environment variable, if set at process start, or else the root used during the Go build.</source>
          <target state="translated">GOROOT는 이동 트리의 루트를 반환합니다. 프로세스 시작시 설정된 경우 GOROOT 환경 변수 또는 Go 빌드 중에 사용 된 루트를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3552a70e477a364f8e82a292dad18f46a2ad988b" translate="yes" xml:space="preserve">
          <source>Gamma returns the Gamma function of x.</source>
          <target state="translated">감마는 x의 감마 함수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a2672eb4dac0440844556fb66fa39b9edb2d2041" translate="yes" xml:space="preserve">
          <source>General:</source>
          <target state="translated">General:</target>
        </trans-unit>
        <trans-unit id="453efae49cba4a01a09c987414ab329ee6c4a305" translate="yes" xml:space="preserve">
          <source>Generally Get, Post, or PostForm will be used instead of Do.</source>
          <target state="translated">일반적으로 Do 대신 Get, Post 또는 PostForm이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1c57b54aace051c9a60fd146f5087c013aa2d721" translate="yes" xml:space="preserve">
          <source>GenerateKey generates a public and private key pair.</source>
          <target state="translated">GenerateKey는 공개 키와 개인 키 쌍을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="db1ff76045ebe9cc510f3c31601ddcbcd7fd57de" translate="yes" xml:space="preserve">
          <source>GenerateKey generates a public&amp;amp;private key pair. The Parameters of the PrivateKey must already be valid (see GenerateParameters).</source>
          <target state="translated">GenerateKey는 공개 및 개인 키 쌍을 생성합니다. PrivateKey의 매개 변수는 이미 유효해야합니다 (Generate 매개 변수 참조).</target>
        </trans-unit>
        <trans-unit id="e650907b55be64a19300b70e59344d22b7245e9b" translate="yes" xml:space="preserve">
          <source>GenerateKey generates a public/private key pair using entropy from rand. If rand is nil, crypto/rand.Reader will be used.</source>
          <target state="translated">GenerateKey는 rand의 엔트로피를 사용하여 공개 / 개인 키 쌍을 생성합니다. rand가 nil이면 crypto / rand.Reader가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7f11f0f6942fab0ca9f944e5798d7d37395d774c" translate="yes" xml:space="preserve">
          <source>GenerateKey generates an RSA keypair of the given bit size using the random source random (for example, crypto/rand.Reader).</source>
          <target state="translated">GenerateKey는 임의의 소스 임의 (예 : crypto / rand.Reader)를 사용하여 지정된 비트 크기의 RSA 키 쌍을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="80806cb0e126f8dd45cfba36eccecc7429a61358" translate="yes" xml:space="preserve">
          <source>GenerateKey returns a public/private key pair. The private key is generated using the given reader, which must return random data.</source>
          <target state="translated">GenerateKey는 공개 / 개인 키 쌍을 반환합니다. 개인 키는 지정된 리더를 사용하여 생성되며 임의의 데이터를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="94cfc2c7f30a1879e413d8411b7005501c966655" translate="yes" xml:space="preserve">
          <source>GenerateMultiPrimeKey generates a multi-prime RSA keypair of the given bit size and the given random source, as suggested in [1]. Although the public keys are compatible (actually, indistinguishable) from the 2-prime case, the private keys are not. Thus it may not be possible to export multi-prime private keys in certain formats or to subsequently import them into other code.</source>
          <target state="translated">GenerateMultiPrimeKey는 [1]에 제안 된대로 주어진 비트 크기와 임의의 랜덤 소스의 다중 프라임 RSA 키 쌍을 생성합니다. 공개 키는 2- 프라임 케이스와 호환 가능하지만 (실제로 구분할 수는 없지만) 개인 키는 호환되지 않습니다. 따라서 다중 형식 개인 키를 특정 형식으로 내보내거나 나중에 다른 코드로 가져올 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="51625703089c85c9211c0ab627055dec67c2bfaf" translate="yes" xml:space="preserve">
          <source>GenerateParameters puts a random, valid set of DSA parameters into params. This function can take many seconds, even on fast machines.</source>
          <target state="translated">GenerateParameters는 임의의 유효한 DSA 매개 변수 세트를 매개 변수에 넣습니다. 이 기능은 빠른 기계에서도 몇 초가 걸릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfffd736cddd08a4eee689949c3399cb61da773b" translate="yes" xml:space="preserve">
          <source>Get</source>
          <target state="translated">Get</target>
        </trans-unit>
        <trans-unit id="2fe964aa376032085805189a0397b3cdcf676226" translate="yes" xml:space="preserve">
          <source>Get gets the first value associated with the given key. If there are no values associated with the key, Get returns &quot;&quot;. It is case insensitive; textproto.CanonicalMIMEHeaderKey is used to canonicalize the provided key. To access multiple values of a key, or to use non-canonical keys, access the map directly.</source>
          <target state="translated">Get은 주어진 키와 관련된 첫 번째 값을 가져옵니다. 키와 관련된 값이 없으면 Get은 &quot;&quot;를 반환합니다. 대소 문자를 구분하지 않습니다. textproto.CanonicalMIMEHeaderKey는 제공된 키를 정규화하는 데 사용됩니다. 키의 여러 값에 액세스하거나 비정규 키를 사용하려면 맵에 직접 액세스하십시오.</target>
        </trans-unit>
        <trans-unit id="5819a3dfa32fe18b54e30756235c5c0b3e71efb0" translate="yes" xml:space="preserve">
          <source>Get gets the first value associated with the given key. If there are no values associated with the key, Get returns the empty string. To access multiple values, use the map directly.</source>
          <target state="translated">Get은 주어진 키와 관련된 첫 번째 값을 가져옵니다. 키와 관련된 값이 없으면 Get은 빈 문자열을 반환합니다. 여러 값에 액세스하려면 맵을 직접 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="322573da1168297393f519b4b988bc100cbe0b6c" translate="yes" xml:space="preserve">
          <source>Get gets the first value associated with the given key. It is case insensitive; CanonicalMIMEHeaderKey is used to canonicalize the provided key. If there are no values associated with the key, Get returns &quot;&quot;. To access multiple values of a key, or to use non-canonical keys, access the map directly.</source>
          <target state="translated">Get은 주어진 키와 관련된 첫 번째 값을 가져옵니다. 대소 문자를 구분하지 않습니다. CanonicalMIMEHeaderKey는 제공된 키를 정규화하는 데 사용됩니다. 키와 관련된 값이 없으면 Get은 &quot;&quot;를 반환합니다. 키의 여러 값에 액세스하거나 비정규 키를 사용하려면 맵에 직접 액세스하십시오.</target>
        </trans-unit>
        <trans-unit id="ec73d0c593dbece5412fe884185bdca68896527d" translate="yes" xml:space="preserve">
          <source>Get is a wrapper around DefaultClient.Get.</source>
          <target state="translated">Get은 DefaultClient.Get에 대한 래퍼입니다.</target>
        </trans-unit>
        <trans-unit id="e51f2ab7d6fbd0e2ffab583f80049b3cfc794ac8" translate="yes" xml:space="preserve">
          <source>Get issues a GET to the specified URL. If the response is one of the following redirect codes, Get follows the redirect after calling the Client's CheckRedirect function:</source>
          <target state="translated">지정된 URL에 GET을 발급합니다. 응답이 다음 리디렉션 코드 중 하나 인 경우 Get은 클라이언트의 CheckRedirect 함수를 호출 한 후 리디렉션을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="cff58f3ccfaec37f9252515e01360ee67558791b" translate="yes" xml:space="preserve">
          <source>Get issues a GET to the specified URL. If the response is one of the following redirect codes, Get follows the redirect, up to a maximum of 10 redirects:</source>
          <target state="translated">지정된 URL에 GET을 발급합니다. 응답이 다음 리디렉션 코드 중 하나 인 경우 Get은 최대 10 개의 리디렉션까지 리디렉션을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="4af41ae2934aaf3ecc571a5a758befaaf5dd46ec" translate="yes" xml:space="preserve">
          <source>Get retrieves a named exported variable. It returns nil if the name has not been registered.</source>
          <target state="translated">Get은 명명 된 내 보낸 변수를 검색합니다. 이름이 등록되지 않은 경우 nil을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="afa92ba06d138d5628558f74ba88a7e263aff277" translate="yes" xml:space="preserve">
          <source>Get returns the JavaScript property p of value v. It panics if v is not a JavaScript object.</source>
          <target state="translated">Get은 값 v의 JavaScript 속성 p를 반환합니다. v가 JavaScript 객체가 아닌 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1f152948d80d4df7cedf020669e282541979aaff" translate="yes" xml:space="preserve">
          <source>Get returns the value associated with key in the tag string. If there is no such key in the tag, Get returns the empty string. If the tag does not have the conventional format, the value returned by Get is unspecified. To determine whether a tag is explicitly set to the empty string, use Lookup.</source>
          <target state="translated">Get은 태그 문자열에서 키와 관련된 값을 반환합니다. 태그에 이러한 키가 없으면 Get은 빈 문자열을 반환합니다. 태그에 일반적인 형식이 없으면 Get에서 반환 된 값은 지정되지 않습니다. 태그가 빈 문자열로 명시 적으로 설정되어 있는지 확인하려면 조회를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1c95403f4621e18fe8ba30c67d76e285e8214f43" translate="yes" xml:space="preserve">
          <source>Get selects an arbitrary item from the Pool, removes it from the Pool, and returns it to the caller. Get may choose to ignore the pool and treat it as empty. Callers should not assume any relation between values passed to Put and the values returned by Get.</source>
          <target state="translated">Get은 Pool에서 임의의 항목을 선택하고 Pool에서 제거하여 호출자에게 반환합니다. Get은 풀을 무시하고 비어있는 것으로 취급 할 수 있습니다. 호출자는 Put에 전달 된 값과 Get이 반환 한 값 사이의 관계를 가정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="c21e6716a05006be2a3b33da22f790cc4dacbd14" translate="yes" xml:space="preserve">
          <source>Get, Head, Post, and PostForm make HTTP (or HTTPS) requests:</source>
          <target state="translated">Get, Head, Post 및 PostForm은 HTTP (또는 HTTPS) 요청을합니다.</target>
        </trans-unit>
        <trans-unit id="c5763aa4654b9f9e755a5247c7e85bd6431154eb" translate="yes" xml:space="preserve">
          <source>Getegid returns the numeric effective group id of the caller.</source>
          <target state="translated">Getegid는 발신자의 유효 숫자 그룹 ID를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3ce86e952faaa112161293325cc18e1e8b1d1f86" translate="yes" xml:space="preserve">
          <source>Getenv</source>
          <target state="translated">Getenv</target>
        </trans-unit>
        <trans-unit id="83272f1d9be5d707a2abc299316ecf8c20c6572e" translate="yes" xml:space="preserve">
          <source>Getenv retrieves the value of the environment variable named by the key. It returns the value, which will be empty if the variable is not present. To distinguish between an empty value and an unset value, use LookupEnv.</source>
          <target state="translated">Getenv는 키로 명명 된 환경 변수의 값을 검색합니다. 변수가 없으면 비어있는 값을 반환합니다. 빈 값과 설정되지 않은 값을 구별하려면 LookupEnv를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fb87cd5bc3aee2814b4736bc86345f331ef466ad" translate="yes" xml:space="preserve">
          <source>Geteuid returns the numeric effective user id of the caller.</source>
          <target state="translated">Geteuid는 발신자의 유효 숫자 사용자 ID를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ba1ccf148fadcaa5a423e416bb3b76de027035d5" translate="yes" xml:space="preserve">
          <source>Getgid returns the numeric group id of the caller.</source>
          <target state="translated">Getgid는 호출자의 숫자 그룹 ID를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1a0d3dfabc3d14d5473d84c935b43760abff4984" translate="yes" xml:space="preserve">
          <source>Getgroups returns a list of the numeric ids of groups that the caller belongs to.</source>
          <target state="translated">Getgroups는 호출자가 속한 그룹의 숫자 ID 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cf37c04d335f6576ae2f027091318c6f433db063" translate="yes" xml:space="preserve">
          <source>Getpagesize returns the underlying system's memory page size.</source>
          <target state="translated">Getpagesize는 기본 시스템의 메모리 페이지 크기를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="98c30bd03388e6d00325569f2c09cb7a5c1f7d76" translate="yes" xml:space="preserve">
          <source>Getpid returns the process id of the caller.</source>
          <target state="translated">Getpid는 호출자의 프로세스 ID를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7d80618e0017c08138a1fb60fea1c4ec0dbcc585" translate="yes" xml:space="preserve">
          <source>Getppid returns the process id of the caller's parent.</source>
          <target state="translated">Getppid는 호출자의 부모 프로세스 ID를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ed660f2b70ea9d5fc73733f3c8d0fe3252a11e78" translate="yes" xml:space="preserve">
          <source>Getter is an interface that allows the contents of a Value to be retrieved. It wraps the Value interface, rather than being part of it, because it appeared after Go 1 and its compatibility rules. All Value types provided by this package satisfy the Getter interface.</source>
          <target state="translated">Getter는 Value의 내용을 검색 할 수있는 인터페이스입니다. Go 1 및 호환성 규칙 뒤에 표시 되었기 때문에 Value 인터페이스의 일부가 아니라 Value 인터페이스를 래핑합니다. 이 패키지에서 제공하는 모든 Value 유형은 Getter 인터페이스를 충족시킵니다.</target>
        </trans-unit>
        <trans-unit id="87c5badfd378b66a2a7ada85f8b7415911742baa" translate="yes" xml:space="preserve">
          <source>Getuid returns the numeric user id of the caller.</source>
          <target state="translated">Getuid는 호출자의 숫자 사용자 ID를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="55e12168bb983e41918aba1691a9e5f495430b36" translate="yes" xml:space="preserve">
          <source>Getwd returns a rooted path name corresponding to the current directory. If the current directory can be reached via multiple paths (due to symbolic links), Getwd may return any one of them.</source>
          <target state="translated">Getwd는 현재 디렉토리에 해당하는 루트 경로 이름을 반환합니다. 심볼릭 링크로 인해 여러 경로를 통해 현재 디렉토리에 도달 할 수있는 경우 Getwd는 그 중 하나를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db8c30ea4bb862dc2beac406c90a324c6875e53e" translate="yes" xml:space="preserve">
          <source>Given that input, ReadMIMEHeader returns the map:</source>
          <target state="translated">해당 입력이 주어지면 ReadMIMEHeader는 맵을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0d7c5c492a7ddeb919966cbf89bf311a727d8ab3" translate="yes" xml:space="preserve">
          <source>Glob ignores file system errors such as I/O errors reading directories. The only possible returned error is ErrBadPattern, when pattern is malformed.</source>
          <target state="translated">Glob은 디렉토리를 읽는 I / O 오류와 같은 파일 시스템 오류를 무시합니다. 패턴이 잘못되었을 때 유일하게 리턴되는 오류는 ErrBadPattern입니다.</target>
        </trans-unit>
        <trans-unit id="5a57ea57c1f0982972dd2d2f408926f91cf67c45" translate="yes" xml:space="preserve">
          <source>Glob returns the names of all files matching pattern or nil if there is no matching file. The syntax of patterns is the same as in Match. The pattern may describe hierarchical names such as /usr/*/bin/ed (assuming the Separator is '/').</source>
          <target state="translated">Glob은 모든 파일 일치 패턴의 이름을 반환하거나 일치하는 파일이 없으면 nil을 반환합니다. 패턴 구문은 일치와 동일합니다. 패턴은 / usr / * / bin / ed와 같은 계층 이름을 설명 할 수 있습니다 (구분자가 '/'라고 가정).</target>
        </trans-unit>
        <trans-unit id="599aa1de3cf0d500e8e5f7d1a178d0ab1cc0a630" translate="yes" xml:space="preserve">
          <source>Global returns the JavaScript global object, usually &quot;window&quot; or &quot;global&quot;.</source>
          <target state="translated">Global은 일반적으로 &quot;창&quot;또는 &quot;전역&quot;인 JavaScript 전역 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2e0b45f2a456e8db55f08d7b65e87593a3e9a140" translate="yes" xml:space="preserve">
          <source>Go</source>
          <target state="translated">Go</target>
        </trans-unit>
        <trans-unit id="e2b7859482bcbcd7f30181447cb1227d814aecb3" translate="yes" xml:space="preserve">
          <source>Go Path</source>
          <target state="translated">이동 경로</target>
        </trans-unit>
        <trans-unit id="31c51be344c4f61c8aa40bf7e10aeaf5b3b1af91" translate="yes" xml:space="preserve">
          <source>Go Programming Language</source>
          <target state="translated">프로그래밍 언어로 이동</target>
        </trans-unit>
        <trans-unit id="2c968e5f87e6cf184e435232ef5dd7937823c72a" translate="yes" xml:space="preserve">
          <source>Go code built with -buildmode=c-archive or -buildmode=c-shared will not install any other signal handlers by default. If there is an existing signal handler, the Go runtime will turn on the SA_ONSTACK flag and otherwise keep the signal handler. If Notify is called for an asynchronous signal, a Go signal handler will be installed for that signal. If, later, Reset is called for that signal, the original handling for that signal will be reinstalled, restoring the non-Go signal handler if any.</source>
          <target state="translated">-buildmode = c-archive 또는 -buildmode = c-shared로 빌드 된 Go 코드는 기본적으로 다른 신호 처리기를 설치하지 않습니다. 기존 신호 핸들러가있는 경우 Go 런타임은 SA_ONSTACK 플래그를 켜고 그렇지 않으면 신호 핸들러를 유지합니다. 비동기 신호에 대해 Notify가 호출되면 해당 신호에 대해 Go 신호 처리기가 설치됩니다. 나중에 해당 신호에 대해 재설정이 호출되면 해당 신호의 원래 처리가 다시 설치되어 비 Go 신호 처리기가 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="799dd6ab824dcf093ff420451386c628fa2a9520" translate="yes" xml:space="preserve">
          <source>Go code built without -buildmode=c-archive or -buildmode=c-shared will install a signal handler for the asynchronous signals listed above, and save any existing signal handler. If a signal is delivered to a non-Go thread, it will act as described above, except that if there is an existing non-Go signal handler, that handler will be installed before raising the signal.</source>
          <target state="translated">-buildmode = c-archive 또는 -buildmode = c-shared없이 빌드 된 Go 코드는 위에 나열된 비동기 신호에 대한 신호 처리기를 설치하고 기존 신호 처리기를 저장합니다. 신호가 비고 (non-Go) 스레드로 전달되면 기존 비고 (non-Go) 신호 핸들러가있는 경우 신호를 올리기 전에 해당 핸들러가 설치된다는 점을 제외하고는 위에서 설명한대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="eb5d4b3ab79b5b09438ad686f6a173b50aeb10bd" translate="yes" xml:space="preserve">
          <source>Go identifiers that appear in the words map are italicized; if the corresponding map value is not the empty string, it is considered a URL and the word is converted into a link.</source>
          <target state="translated">단어 맵에 나타나는 Go 식별자는 이탤릭체로 표시됩니다. 해당 맵 값이 빈 문자열이 아닌 경우 URL로 간주되고 단어가 링크로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="ea224aeb731dc78304c02f088e7a39cfe984c1f7" translate="yes" xml:space="preserve">
          <source>Go invokes the function asynchronously. It returns the Call structure representing the invocation. The done channel will signal when the call is complete by returning the same Call object. If done is nil, Go will allocate a new channel. If non-nil, done must be buffered or Go will deliberately crash.</source>
          <target state="translated">Go는 함수를 비동기 적으로 호출합니다. 호출을 나타내는 호출 구조를 리턴합니다. 완료된 채널은 동일한 Call 객체를 반환하여 호출이 완료되면 신호를 보냅니다. 완료되지 않은 경우 Go는 새 채널을 할당합니다. 0이 아닌 경우 완료가 버퍼링되어야합니다. 그렇지 않으면 Go가 의도적으로 충돌합니다.</target>
        </trans-unit>
        <trans-unit id="a7c304672885987fa9e2bc01caee3388d0b9796b" translate="yes" xml:space="preserve">
          <source>Go programs that use cgo or SWIG</source>
          <target state="translated">cgo 또는 SWIG를 사용하는 프로그램 이동</target>
        </trans-unit>
        <trans-unit id="f00375ef44991e7032fc680e2e8afc5d4b4ddcac" translate="yes" xml:space="preserve">
          <source>GoStringer</source>
          <target state="translated">GoStringer</target>
        </trans-unit>
        <trans-unit id="776ec360ea626f63aba6d19bf197cc0106f28f0c" translate="yes" xml:space="preserve">
          <source>GoStringer is implemented by any value that has a GoString method, which defines the Go syntax for that value. The GoString method is used to print values passed as an operand to a %#v format.</source>
          <target state="translated">GoStringer는 해당 값의 Go 구문을 정의하는 GoString 메소드가있는 값으로 구현됩니다. GoString 메서드는 피연산자로 전달 된 값을 % # v 형식으로 인쇄하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="06664245ef1dbe050dbc75990b043c9e9da34427" translate="yes" xml:space="preserve">
          <source>GoWhitespace is the default value for the Scanner's Whitespace field. Its value selects Go's white space characters.</source>
          <target state="translated">GoWhitespace는 스캐너의 공백 필드에 대한 기본값입니다. 그 값은 Go의 공백 문자를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="13594eb4e63d05205c24ee0d18474bb09fad234a" translate="yes" xml:space="preserve">
          <source>Gob can decode a value of any type implementing the GobDecoder or encoding.BinaryUnmarshaler interfaces by calling the corresponding method, again in that order of preference.</source>
          <target state="translated">Gob는 GobDecoder 또는 encoding.BinaryUnmarshaler 인터페이스를 구현하는 모든 유형의 값을 선호하는 순서대로 해당 메소드를 다시 호출하여 디코딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7274c1618f0661ff86ead432a84f718728e78907" translate="yes" xml:space="preserve">
          <source>Gob can encode a value of any type implementing the GobEncoder or encoding.BinaryMarshaler interfaces by calling the corresponding method, in that order of preference.</source>
          <target state="translated">Gob는 GobEncoder 또는 encoding.BinaryMarshaler 인터페이스를 구현하는 모든 유형의 값을 선호하는 순서대로 해당 메소드를 호출하여 인코딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f0664b183bab943699d699e2b7fa06d50e41b1a" translate="yes" xml:space="preserve">
          <source>GobDecode implements the gob.GobDecoder interface.</source>
          <target state="translated">GobDecode는 gob.GobDecoder 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="d350a1211682bc77e1cf31df3df91c75eb68270c" translate="yes" xml:space="preserve">
          <source>GobDecode implements the gob.GobDecoder interface. The result is rounded per the precision and rounding mode of z unless z's precision is 0, in which case z is set exactly to the decoded value.</source>
          <target state="translated">GobDecode는 gob.GobDecoder 인터페이스를 구현합니다. z의 정밀도가 0이 아닌 경우 z의 정밀도 및 반올림 모드에 따라 결과가 반올림됩니다.이 경우 z는 디코딩 된 값으로 정확하게 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="dd719ca2cfb03b3cfba4caf011be5a1140872694" translate="yes" xml:space="preserve">
          <source>GobDecoder is the interface describing data that provides its own routine for decoding transmitted values sent by a GobEncoder.</source>
          <target state="translated">GobDecoder는 GobEncoder에 의해 전송 된 전송 된 값을 디코딩하기위한 자체 루틴을 제공하는 데이터를 설명하는 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="d5aa87ccb7988a5106efef8e6d2f9cae7932e9c6" translate="yes" xml:space="preserve">
          <source>GobEncode implements the gob.GobEncoder interface.</source>
          <target state="translated">GobEncode는 gob.GobEncoder 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="20cb90d239fa73b1f6938fdb92b390d973a1de7f" translate="yes" xml:space="preserve">
          <source>GobEncode implements the gob.GobEncoder interface. The Float value and all its attributes (precision, rounding mode, accuracy) are marshaled.</source>
          <target state="translated">GobEncode는 gob.GobEncoder 인터페이스를 구현합니다. Float 값과 모든 속성 (정밀도, 반올림 모드, 정확성)이 마샬링됩니다.</target>
        </trans-unit>
        <trans-unit id="a019b8cdacb9fe6be4bcfe375ae2210cd1a4074d" translate="yes" xml:space="preserve">
          <source>GobEncoder is the interface describing data that provides its own representation for encoding values for transmission to a GobDecoder. A type that implements GobEncoder and GobDecoder has complete control over the representation of its data and may therefore contain things such as private fields, channels, and functions, which are not usually transmissible in gob streams.</source>
          <target state="translated">GobEncoder는 GobDecoder로 전송하기위한 인코딩 값을위한 고유 한 표현을 제공하는 데이터를 설명하는 인터페이스입니다. GobEncoder 및 GobDecoder를 구현하는 형식은 데이터 표현을 완벽하게 제어 할 수 있으므로 개인 필드, 채널 및 함수와 같은 항목을 포함 할 수 있으며 일반적으로 gob 스트림에서는 전송할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3af908c6818caa06d786a8ce4e61618d352da418" translate="yes" xml:space="preserve">
          <source>Goexit terminates the goroutine that calls it. No other goroutine is affected. Goexit runs all deferred calls before terminating the goroutine. Because Goexit is not a panic, any recover calls in those deferred functions will return nil.</source>
          <target state="translated">Goexit은이를 호출하는 goroutine을 종료합니다. 다른 고 루틴은 영향을받지 않습니다. Goexit은 고 루틴을 종료하기 전에 모든 지연된 통화를 실행합니다. Goexit은 패닉이 아니기 때문에 지연된 함수의 복구 호출은 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="92c1b5045c151c8351b05867329857d4da35385e" translate="yes" xml:space="preserve">
          <source>GoroutineProfile returns n, the number of records in the active goroutine stack profile. If len(p) &amp;gt;= n, GoroutineProfile copies the profile into p and returns n, true. If len(p) &amp;lt; n, GoroutineProfile does not change p and returns n, false.</source>
          <target state="translated">GoroutineProfile은 활성 고 루틴 스택 프로파일의 레코드 수인 n을 반환합니다. len (p)&amp;gt; = n 인 경우 GoroutineProfile은 프로파일을 p에 복사하고 n을 true로 리턴합니다. len (p) &amp;lt;n이면 GoroutineProfile은 p를 변경하지 않고 n을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="62967be4b08298e25e7959a7cdc5602a2a2be72a" translate="yes" xml:space="preserve">
          <source>Gosched yields the processor, allowing other goroutines to run. It does not suspend the current goroutine, so execution resumes automatically.</source>
          <target state="translated">Gosched는 프로세서를 생성하여 다른 고 루틴을 실행할 수있게합니다. 현재 고 루틴을 일시 중단하지 않으므로 실행이 자동으로 다시 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="1c2aaf1310e2e413d539667c1a3e7771e58933c6" translate="yes" xml:space="preserve">
          <source>GotConnInfo is the argument to the ClientTrace.GotConn function and contains information about the obtained connection.</source>
          <target state="translated">GotConnInfo는 ClientTrace.GotConn 함수의 인수이며 획득 한 연결에 대한 정보를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="8aa6da089a7b549e351002a5e03605264795ad2e" translate="yes" xml:space="preserve">
          <source>GraphicRanges defines the set of graphic characters according to Unicode.</source>
          <target state="translated">GraphicRanges는 유니 코드에 따라 그래픽 문자 세트를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="e7195fa4641b119dd2889d0a417f633c2b3c037d" translate="yes" xml:space="preserve">
          <source>Gray is an in-memory image whose At method returns color.Gray values.</source>
          <target state="translated">회색은 At 메서드가 color.Gray 값을 반환하는 메모리 내 이미지입니다.</target>
        </trans-unit>
        <trans-unit id="8551691479e553fcfd58c230f9f1c7702a08e936" translate="yes" xml:space="preserve">
          <source>Gray represents an 8-bit grayscale color.</source>
          <target state="translated">회색은 8 비트 회색조 색상을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8be44534e41a9fdc599304347782cb967b0bd62b" translate="yes" xml:space="preserve">
          <source>Gray16 is an in-memory image whose At method returns color.Gray16 values.</source>
          <target state="translated">Gray16은 At 메서드가 color.Gray16 값을 반환하는 메모리 내 이미지입니다.</target>
        </trans-unit>
        <trans-unit id="b7ee628ee7a9a7bf06c313fa8d8dc808a58abb8f" translate="yes" xml:space="preserve">
          <source>Gray16 represents a 16-bit grayscale color.</source>
          <target state="translated">Gray16은 16 비트 회색조 색상을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6e09be6a83f7d3163e99081e0c679a65e139fc8d" translate="yes" xml:space="preserve">
          <source>Group represents a grouping of users.</source>
          <target state="translated">그룹은 사용자 그룹을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7de1bb0487db53a77d3d5fa786aa26f9027ba7c1" translate="yes" xml:space="preserve">
          <source>GroupIds returns the list of group IDs that the user is a member of.</source>
          <target state="translated">GroupIds는 사용자가 속한 그룹 ID 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d0e679bf3eeb0246c0708b92532613618a2a5627" translate="yes" xml:space="preserve">
          <source>Grouping:</source>
          <target state="translated">Grouping:</target>
        </trans-unit>
        <trans-unit id="a3dd80da68d80e7f0e9f29bcc9f5cb31d2777884" translate="yes" xml:space="preserve">
          <source>Grow grows b's capacity, if necessary, to guarantee space for another n bytes. After Grow(n), at least n bytes can be written to b without another allocation. If n is negative, Grow panics.</source>
          <target state="translated">성장은 필요한 경우 다른 n 바이트에 대한 공간을 보장하기 위해 b의 용량을 증가시킵니다. Grow (n) 이후에, 다른 할당없이 적어도 n 바이트를 b에 쓸 수 있습니다. n이 음수이면 패닉이 커집니다.</target>
        </trans-unit>
        <trans-unit id="ea6ca3eab6713cfdabbbddc578b2358a70e4ccb7" translate="yes" xml:space="preserve">
          <source>Grow grows the buffer's capacity, if necessary, to guarantee space for another n bytes. After Grow(n), at least n bytes can be written to the buffer without another allocation. If n is negative, Grow will panic. If the buffer can't grow it will panic with ErrTooLarge.</source>
          <target state="translated">Grow는 필요한 경우 다른 n 바이트에 대한 공간을 보장하기 위해 버퍼 용량을 늘립니다. Grow (n) 후에는 다른 할당없이 n 바이트 이상을 버퍼에 쓸 수 있습니다. n이 음수이면 Grow가 패닉 상태가됩니다. 버퍼가 커지지 않으면 ErrTooLarge로 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="fcfc665b9c38534864ef4c48c8a42633500c63ee" translate="yes" xml:space="preserve">
          <source>Gzip files store a length and checksum of the uncompressed data. The Reader will return an ErrChecksum when Read reaches the end of the uncompressed data if it does not have the expected length or checksum. Clients should treat data returned by Read as tentative until they receive the io.EOF marking the end of the data.</source>
          <target state="translated">Gzip 파일은 압축되지 않은 데이터의 길이와 체크섬을 저장합니다. 판독기가 예상 길이 또는 체크섬이없는 경우 읽기가 압축되지 않은 데이터의 끝에 도달하면 ErrChecksum을 반환합니다. 고객은 데이터의 끝을 표시하는 io.EOF를받을 때까지 Read에서 반환 한 데이터를 임시로 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="5d71851e777cb11c10615f1403f7831b2abdc279" translate="yes" xml:space="preserve">
          <source>HTML encapsulates a known safe HTML document fragment. It should not be used for HTML from a third-party, or HTML with unclosed tags or comments. The outputs of a sound HTML sanitizer and a template escaped by this package are fine for use with HTML.</source>
          <target state="translated">HTML은 알려진 안전한 HTML 문서 조각을 캡슐화합니다. 타사의 HTML 또는 닫히지 않은 태그 나 주석이있는 HTML에는 사용해서는 안됩니다. 사운드 HTML 소독제의 출력과이 패키지에서 이스케이프 된 템플릿은 HTML과 함께 사용하기에 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b3eeeba32a88681f357c6658794b2cde0a1ffee1" translate="yes" xml:space="preserve">
          <source>HTML templates treat data values as plain text which should be encoded so they can be safely embedded in an HTML document. The escaping is contextual, so actions can appear within JavaScript, CSS, and URI contexts.</source>
          <target state="translated">HTML 템플릿은 데이터 값을 일반 텍스트로 처리하여 HTML 문서에 안전하게 포함되도록 인코딩해야합니다. 이스케이프는 상황에 따라 동작하므로 JavaScript, CSS 및 URI 컨텍스트 내에 작업이 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9941fc69ceb0b7c4c9cd661ccc1d3296d53a1466" translate="yes" xml:space="preserve">
          <source>HTMLAttr encapsulates an HTML attribute from a trusted source, for example, ` dir=&quot;ltr&quot;`.</source>
          <target state="translated">HTMLAttr은 신뢰할 수있는 소스 (예 :`dir = &quot;ltr&quot;)에서 HTML 속성을 캡슐화합니다.</target>
        </trans-unit>
        <trans-unit id="56515df9ce780f70db2a14123d61a78cb0491ced" translate="yes" xml:space="preserve">
          <source>HTMLAutoClose is the set of HTML elements that should be considered to close automatically.</source>
          <target state="translated">HTMLAutoClose는 자동으로 닫는 것으로 간주되는 HTML 요소의 집합입니다.</target>
        </trans-unit>
        <trans-unit id="e3ae2c19a119f12f6bd7618bea966cc88fb1903b" translate="yes" xml:space="preserve">
          <source>HTMLEntity is an entity map containing translations for the standard HTML entity characters.</source>
          <target state="translated">HTMLEntity는 표준 HTML 엔티티 문자에 대한 번역이 포함 된 엔티티 맵입니다.</target>
        </trans-unit>
        <trans-unit id="0502b94bdac42557ec458b2bcfd7d81519bb7f5f" translate="yes" xml:space="preserve">
          <source>HTMLEscape</source>
          <target state="translated">HTMLEscape</target>
        </trans-unit>
        <trans-unit id="108bb0274697ed474af72c0af28941c4694cc443" translate="yes" xml:space="preserve">
          <source>HTMLEscape appends to dst the JSON-encoded src with &amp;lt;, &amp;gt;, &amp;amp;, U+2028 and U+2029 characters inside string literals changed to \u003c, \u003e, \u0026, \u2028, \u2029 so that the JSON will be safe to embed inside HTML &amp;lt;script&amp;gt; tags. For historical reasons, web browsers don't honor standard HTML escaping within &amp;lt;script&amp;gt; tags, so an alternative JSON encoding must be used.</source>
          <target state="translated">HTMLEscape는 문자열 리터럴 내부의 &amp;lt;,&amp;gt;, &amp;amp;, U + 2028 및 U + 2029 문자를 사용하여 JSON 인코딩 src를 dst에 추가하여 JSON이 안전하도록 \ u003c, \ u003e, \ u0026, \ u2028, \ u2029로 변경되었습니다. HTML &amp;lt;script&amp;gt; 태그 안에 포함합니다. 역사적 이유로 웹 브라우저는 &amp;lt;script&amp;gt; 태그 내에서 표준 HTML 이스케이프를 사용하지 않으므로 대체 JSON 인코딩을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="eaa5eff89dbdb13500c068f0e84bf21b7f3be3fb" translate="yes" xml:space="preserve">
          <source>HTMLEscape writes to w the escaped HTML equivalent of the plain text data b.</source>
          <target state="translated">HTMLEscape는 일반 텍스트 데이터와 동등한 이스케이프 된 HTML을 w에 기록합니다. b.</target>
        </trans-unit>
        <trans-unit id="eba1f3f7ea429a820bedfa415a707d8da7ce1238" translate="yes" xml:space="preserve">
          <source>HTMLEscapeString returns the escaped HTML equivalent of the plain text data s.</source>
          <target state="translated">HTMLEscapeString은 일반 텍스트 데이터에 해당하는 이스케이프 된 HTML을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8b2dbe52305b6c07dd244c27d634207753a8523e" translate="yes" xml:space="preserve">
          <source>HTMLEscaper returns the escaped HTML equivalent of the textual representation of its arguments.</source>
          <target state="translated">HTMLEscaper는 인수의 텍스트 표현에 해당하는 이스케이프 된 HTML을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9304c86e0fba62ba5daa5297c254f425c77df161" translate="yes" xml:space="preserve">
          <source>HTTP Trailers are a set of key/value pairs like headers that come after the HTTP response, instead of before.</source>
          <target state="translated">HTTP 트레일러는 이전이 아니라 HTTP 응답 이후에 오는 헤더와 같은 키 / 값 쌍 세트입니다.</target>
        </trans-unit>
        <trans-unit id="0f4dea56c9591992aae081556a866da7a62d7c76" translate="yes" xml:space="preserve">
          <source>HTTP status codes as registered with IANA. See: &lt;a href=&quot;https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml&quot;&gt;https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml&lt;/a&gt;</source>
          <target state="translated">IANA에 등록 된 HTTP 상태 코드 참조 : &lt;a href=&quot;https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml&quot;&gt;https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ffb0634925a034a37cf81c8bf163966c760740e9" translate="yes" xml:space="preserve">
          <source>HTTP/2 support is only enabled if the Listener returns *tls.Conn connections and they were configured with &quot;h2&quot; in the TLS Config.NextProtos.</source>
          <target state="translated">리스너가 * tls.Conn 연결을 리턴하고 TLS Config.NextProtos에서 &quot;h2&quot;로 구성된 경우에만 HTTP / 2 지원이 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="5ee0353f20802f9b3b832dc664b1cf16f1dd8c83" translate="yes" xml:space="preserve">
          <source>HalfReader returns a Reader that implements Read by reading half as many requested bytes from r.</source>
          <target state="translated">HalfReader는 r에서 요청 된 바이트의 절반을 읽음으로써 Read를 구현하는 Reader를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c0392b2b1c472815ba8d1a1e3b20f4a279bf6c50" translate="yes" xml:space="preserve">
          <source>Handle</source>
          <target state="translated">Handle</target>
        </trans-unit>
        <trans-unit id="1f7743a2da5a9b87698980081ed0a9b4a848c67b" translate="yes" xml:space="preserve">
          <source>Handle registers the handler for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched.</source>
          <target state="translated">Handle은 주어진 패턴에 대한 핸들러를 DefaultServeMux에 등록합니다. ServeMux 문서는 패턴이 일치하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="adfb5ece7bb714f07a8d92f38ecaccd93eb91488" translate="yes" xml:space="preserve">
          <source>Handle registers the handler for the given pattern. If a handler already exists for pattern, Handle panics.</source>
          <target state="translated">핸들은 주어진 패턴에 대한 핸들러를 등록합니다. 패턴에 대한 핸들러가 이미 있으면 패닉 처리.</target>
        </trans-unit>
        <trans-unit id="9df709e02c4285ab3a3440b49e05002a1810c202" translate="yes" xml:space="preserve">
          <source>HandleFunc</source>
          <target state="translated">HandleFunc</target>
        </trans-unit>
        <trans-unit id="ba3631b03a8549831c70fb0b756b06eb4ccdf22e" translate="yes" xml:space="preserve">
          <source>HandleFunc registers the handler function for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched.</source>
          <target state="translated">HandleFunc는 DefaultServeMux에서 주어진 패턴에 대한 핸들러 함수를 등록합니다. ServeMux 문서는 패턴이 일치하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="671e02c9111874e0dde4ea20673fb01320ed5a12" translate="yes" xml:space="preserve">
          <source>HandleFunc registers the handler function for the given pattern.</source>
          <target state="translated">HandleFunc는 주어진 패턴에 대한 핸들러 함수를 등록합니다.</target>
        </trans-unit>
        <trans-unit id="b8bc0ae743c24154bab55e05ddac119f84a83a3e" translate="yes" xml:space="preserve">
          <source>HandleHTTP registers an HTTP handler for RPC messages on rpcPath, and a debugging handler on debugPath. It is still necessary to invoke http.Serve(), typically in a go statement.</source>
          <target state="translated">HandleHTTP는 rpcPath에 RPC 메시지에 대한 HTTP 처리기와 debugPath에 디버깅 처리기를 등록합니다. 일반적으로 go 문에서 http.Serve ()를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="104cf096656ffcb1565dfd1219d7035e43630f88" translate="yes" xml:space="preserve">
          <source>HandleHTTP registers an HTTP handler for RPC messages to DefaultServer on DefaultRPCPath and a debugging handler on DefaultDebugPath. It is still necessary to invoke http.Serve(), typically in a go statement.</source>
          <target state="translated">HandleHTTP는 RPC 메시지에 대한 HTTP 처리기를 DefaultRPCPath의 DefaultServer에 등록하고 DefaultDebugPath의 디버깅 처리기를 등록합니다. 일반적으로 go 문에서 http.Serve ()를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="a62b57b0720d266ed6489a123759bbfe855bf88a" translate="yes" xml:space="preserve">
          <source>Handler also returns the registered pattern that matches the request or, in the case of internally-generated redirects, the pattern that will match after following the redirect.</source>
          <target state="translated">또한 핸들러는 요청과 일치하는 등록 된 패턴 또는 내부적으로 생성 된 리디렉션의 경우 리디렉션 이후에 일치하는 패턴을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0ddb06f6f85fc2ca7a7cc5302dfee4fc45947bee" translate="yes" xml:space="preserve">
          <source>Handler returns an HTTP handler that serves the named profile.</source>
          <target state="translated">핸들러는 이름 지정된 프로파일을 제공하는 HTTP 핸들러를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="4065eef104a7b00ebd8ce9a91293334fd4bb0db9" translate="yes" xml:space="preserve">
          <source>Handler returns the expvar HTTP Handler.</source>
          <target state="translated">핸들러는 expvar HTTP 핸들러를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="e63273beb69f3454c447975682e44a2c5d4a0c1e" translate="yes" xml:space="preserve">
          <source>Handler returns the handler to use for the given request, consulting r.Method, r.Host, and r.URL.Path. It always returns a non-nil handler. If the path is not in its canonical form, the handler will be an internally-generated handler that redirects to the canonical path. If the host contains a port, it is ignored when matching handlers.</source>
          <target state="translated">처리기는 r.Method, r.Host 및 r.URL.Path를 참조하여 지정된 요청에 사용할 처리기를 반환합니다. 항상 0이 아닌 핸들러를 리턴합니다. 경로가 정식 형식이 아닌 경우 처리기는 정식 경로로 리디렉션되는 내부 생성 처리기입니다. 호스트에 포트가 포함 된 경우 핸들러를 일치시킬 때 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="a812b2fb8f7451d8a9be630f8c521fc7613cf74d" translate="yes" xml:space="preserve">
          <source>Handler runs an executable in a subprocess with a CGI environment.</source>
          <target state="translated">핸들러는 CGI 환경의 하위 프로세스에서 실행 파일을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="612e8566dcf29030b3f86ae45fac3cd161070575" translate="yes" xml:space="preserve">
          <source>Handling of anonymous struct fields is new in Go 1.1. Prior to Go 1.1, anonymous struct fields were ignored. To force ignoring of an anonymous struct field in both current and earlier versions, give the field a JSON tag of &quot;-&quot;.</source>
          <target state="translated">익명 구조체 필드 처리는 Go 1.1의 새로운 기능입니다. Go 1.1 이전에는 익명 구조체 필드가 ​​무시되었습니다. 현재 및 이전 버전 모두에서 익명 구조체 필드를 강제로 무시하려면 필드에 JSON 태그 &quot;-&quot;를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="8bd5447a341844b0e1ee2ac00ed949437eac1c43" translate="yes" xml:space="preserve">
          <source>Handshake runs the client or server handshake protocol if it has not yet been run. Most uses of this package need not call Handshake explicitly: the first Read or Write will call it automatically.</source>
          <target state="translated">핸드 셰이크는 아직 실행되지 않은 경우 클라이언트 또는 서버 핸드 셰이크 프로토콜을 실행합니다. 이 패키지의 대부분의 사용은 악수를 명시 적으로 호출 할 필요가 없습니다. 첫 번째 읽기 또는 쓰기는 자동으로 호출합니다.</target>
        </trans-unit>
        <trans-unit id="0bf39eaf505133458b930fe0c34986ca5b577cc9" translate="yes" xml:space="preserve">
          <source>HasExpired reports whether certList should have been updated by now.</source>
          <target state="translated">HasExpired는 certList가 지금 업데이트되었는지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="d390517d58b930cb269df7a0b32aa914bfb5311d" translate="yes" xml:space="preserve">
          <source>HasOk reports whether the corresponding expression may be used on the rhs of a comma-ok assignment.</source>
          <target state="translated">HasOk는 해당 표현식이 쉼표 할당의 rhs에 사용될 수 있는지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="e53848ef4c6fc884ed74c95d3ab525fa42a2bbe7" translate="yes" xml:space="preserve">
          <source>HasPrefix</source>
          <target state="translated">HasPrefix</target>
        </trans-unit>
        <trans-unit id="8d314f541aff1011d7ddb318695b8f61b2af6ec2" translate="yes" xml:space="preserve">
          <source>HasPrefix exists for historical compatibility and should not be used.</source>
          <target state="translated">HasPrefix는 기록 호환성을 위해 존재하므로 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="2669e9427d4779bbc09f60c5ccfd3fe6d15b6c70" translate="yes" xml:space="preserve">
          <source>HasPrefix tests whether the byte slice s begins with prefix.</source>
          <target state="translated">HasPrefix는 바이트 슬라이스가 접두어로 시작하는지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="5cd07ae1c7bc3b9ed87eb16cdb61e05184635090" translate="yes" xml:space="preserve">
          <source>HasPrefix tests whether the string s begins with prefix.</source>
          <target state="translated">HasPrefix는 문자열 s가 접두어로 시작하는지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="117455f286c7643c45e4bb7a574dddee082000d6" translate="yes" xml:space="preserve">
          <source>HasSuffix</source>
          <target state="translated">HasSuffix</target>
        </trans-unit>
        <trans-unit id="0d84ad6d23e5d60c659894725feb80de1e5bc00b" translate="yes" xml:space="preserve">
          <source>HasSuffix tests whether the byte slice s ends with suffix.</source>
          <target state="translated">HasSuffix는 바이트 슬라이스 s가 접미사로 끝나는 지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="71e6720e740d9f5d90d030cf5d260029a0041a76" translate="yes" xml:space="preserve">
          <source>HasSuffix tests whether the string s ends with suffix.</source>
          <target state="translated">HasSuffix는 문자열 s가 접미사로 끝나는 지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="c07fb815b0dd23f98464b6c96ba0043996f42574" translate="yes" xml:space="preserve">
          <source>Hash identifies a cryptographic hash function that is implemented in another package.</source>
          <target state="translated">해시는 다른 패키지에 구현 된 암호화 해시 함수를 식별합니다.</target>
        </trans-unit>
        <trans-unit id="a8a4a81d7a93ec8ea6de29fca7e817e8b0ccf094" translate="yes" xml:space="preserve">
          <source>Hash implementations in the standard library (e.g. hash/crc32 and crypto/sha256) implement the encoding.BinaryMarshaler and encoding.BinaryUnmarshaler interfaces. Marshaling a hash implementation allows its internal state to be saved and used for additional processing later, without having to re-write the data previously written to the hash. The hash state may contain portions of the input in its original form, which users are expected to handle for any possible security implications.</source>
          <target state="translated">표준 라이브러리 (예 : hash / crc32 및 crypto / sha256)의 해시 구현은 encoding.BinaryMarshaler 및 encoding.BinaryUnmarshaler 인터페이스를 구현합니다. 해시 구현을 마샬링하면 내부 상태를 저장하고 나중에 추가 처리를 위해 나중에 해시에 쓴 데이터를 다시 쓰지 않고도 추가 처리에 사용할 수 있습니다. 해시 상태는 입력의 일부를 원래 형식으로 포함 할 수 있으며, 사용자는 가능한 모든 보안 관련 사항을 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="afa3769866aaa8e9ccd0894bbb12db0f2a42b294" translate="yes" xml:space="preserve">
          <source>Hash is the common interface implemented by all hash functions.</source>
          <target state="translated">해시는 모든 해시 함수로 구현되는 공통 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="bbb248d3e1082f71a91f55221f9ef1629bac5c92" translate="yes" xml:space="preserve">
          <source>Hash32 is the common interface implemented by all 32-bit hash functions.</source>
          <target state="translated">Hash32는 모든 32 비트 해시 함수로 구현되는 공통 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="05bc44af5e367ef4fc60329373f6d1a44dbf5c85" translate="yes" xml:space="preserve">
          <source>Hash64 is the common interface implemented by all 64-bit hash functions.</source>
          <target state="translated">Hash64는 모든 64 비트 해시 함수로 구현되는 공통 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="3959061e57c74057bbf958321e7f6031a26bba89" translate="yes" xml:space="preserve">
          <source>HashFunc returns pssOpts.Hash so that PSSOptions implements crypto.SignerOpts.</source>
          <target state="translated">PSSOptions가 crypto.SignerOpts를 구현하도록 HashFunc는 pssOpts.Hash를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="860155016136afc0d36dbbc3f9fc98412399783e" translate="yes" xml:space="preserve">
          <source>HashFunc simply returns the value of h so that Hash implements SignerOpts.</source>
          <target state="translated">HashFunc는 단순히 h의 값을 반환하여 Hash가 SignerOpts를 구현하도록합니다.</target>
        </trans-unit>
        <trans-unit id="cd2b2728ea1f997355e4a7e5005a26c5306f470a" translate="yes" xml:space="preserve">
          <source>Head is a wrapper around DefaultClient.Head</source>
          <target state="translated">Head는 DefaultClient를 감싸는 래퍼입니다.</target>
        </trans-unit>
        <trans-unit id="93e59ac29bb3c357b0f9c42db1f78e97e116c128" translate="yes" xml:space="preserve">
          <source>Head issues a HEAD to the specified URL. If the response is one of the following redirect codes, Head follows the redirect after calling the Client's CheckRedirect function:</source>
          <target state="translated">Head는 지정된 URL에 HEAD를 발행합니다. 응답이 다음 리디렉션 코드 중 하나 인 경우 Head는 클라이언트의 CheckRedirect 함수를 호출 한 후 리디렉션을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="24094406af9408bd066ab26a0a1ef55bdcdead08" translate="yes" xml:space="preserve">
          <source>Head issues a HEAD to the specified URL. If the response is one of the following redirect codes, Head follows the redirect, up to a maximum of 10 redirects:</source>
          <target state="translated">Head는 지정된 URL에 HEAD를 발행합니다. 응답이 다음 리디렉션 코드 중 하나 인 경우 Head는 최대 10 개의 리디렉션까지 리디렉션을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="a50c7cbf99b8cae529cf3d620f5022a1c82e8fca" translate="yes" xml:space="preserve">
          <source>Header implements http.ResponseWriter. It returns the response headers to mutate within a handler. To test the headers that were written after a handler completes, use the Result method and see the returned Response value's Header.</source>
          <target state="translated">헤더는 http.ResponseWriter를 구현합니다. 핸들러 내에서 변경 될 응답 헤더를 리턴합니다. 핸들러가 완료된 후 작성된 헤더를 테스트하려면 Result 메소드를 사용하고 리턴 된 응답 값의 헤더를보십시오.</target>
        </trans-unit>
        <trans-unit id="2a403ca7fd2ae0865923ded1f911ee30d4fbde83" translate="yes" xml:space="preserve">
          <source>Hello sends a HELO or EHLO to the server as the given host name. Calling this method is only necessary if the client needs control over the host name used. The client will introduce itself as &quot;localhost&quot; automatically otherwise. If Hello is called, it must be called before any of the other methods.</source>
          <target state="translated">Hello는 주어진 호스트 이름으로 HELO 또는 EHLO를 서버에 보냅니다. 클라이언트가 사용 된 호스트 이름을 제어해야하는 경우에만이 메소드를 호출해야합니다. 그렇지 않으면 클라이언트는 자동으로 &quot;localhost&quot;로 자동 도입됩니다. Hello가 호출되면 다른 메소드보다 먼저 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="0aed41610e50a1818172a103900a5a6fdac5322e" translate="yes" xml:space="preserve">
          <source>Helper marks the calling function as a test helper function. When printing file and line information, that function will be skipped. Helper may be called simultaneously from multiple goroutines.</source>
          <target state="translated">도우미는 호출 함수를 테스트 도우미 함수로 표시합니다. 파일 및 라인 정보를 인쇄 할 때 해당 기능을 건너 뜁니다. 도우미는 여러 고 루틴에서 동시에 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa0b52b8a6b42d9b0905c653c010a924ae5e874a" translate="yes" xml:space="preserve">
          <source>Here are some example one-line templates demonstrating pipelines and variables. All produce the quoted word &quot;output&quot;:</source>
          <target state="translated">다음은 파이프 라인과 변수를 보여주는 예제 한 줄 템플릿입니다. 모두 인용 된 단어 &quot;output&quot;을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="89620d229387855063bd56a8e6d5a3250086c9f0" translate="yes" xml:space="preserve">
          <source>Here is a simple example, opening a file and reading some of it.</source>
          <target state="translated">다음은 파일을 열고 일부를 읽는 간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="2824caba6baa2187c9e56d7836920f8ff25bcc71" translate="yes" xml:space="preserve">
          <source>Here is a simple example. A server wishes to export an object of type Arith:</source>
          <target state="translated">다음은 간단한 예입니다. 서버가 Arith 유형의 객체를 내보내려고합니다.</target>
        </trans-unit>
        <trans-unit id="2c22db98d01fc50d0681541a0b0caf2c4141f0f4" translate="yes" xml:space="preserve">
          <source>Here is a trivial example that prints &quot;17 items are made of wool&quot;.</source>
          <target state="translated">다음은 &quot;17 개 항목이 양모로 만들어 짐&quot;을 인쇄하는 간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="dc0bea3647dd8635722162c3a9c56cc10d70b7ac" translate="yes" xml:space="preserve">
          <source>Here is the list of actions. &quot;Arguments&quot; and &quot;pipelines&quot; are evaluations of data, defined in detail in the corresponding sections that follow.</source>
          <target state="translated">다음은 조치 목록입니다. &quot;인수&quot;및 &quot;파이프 라인&quot;은 다음에 해당하는 섹션에 자세히 정의 된 데이터 평가입니다.</target>
        </trans-unit>
        <trans-unit id="c3b612d75a40adadd01e188d1e2aba30e8b88d33" translate="yes" xml:space="preserve">
          <source>Here we demonstrate loading a set of templates from a directory.</source>
          <target state="translated">여기에서는 디렉토리에서 템플릿 집합을로드하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="c18d789286c40d70b27c77faebcb174f22c85dbc" translate="yes" xml:space="preserve">
          <source>Here we demonstrate loading a set of templates from files in different directories</source>
          <target state="translated">여기서는 다른 디렉토리의 파일에서 템플릿 세트를로드하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="bcef5f73d0a48aab25273d92f8664ff4fb80379d" translate="yes" xml:space="preserve">
          <source>Here's an example directory layout:</source>
          <target state="translated">디렉토리 레이아웃의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="35d5d6962be99793c34862b1061c8b5cacf67fc9" translate="yes" xml:space="preserve">
          <source>HexEncoding is the &amp;ldquo;Extended Hex Alphabet&amp;rdquo; defined in RFC 4648. It is typically used in DNS.</source>
          <target state="translated">HexEncoding은 RFC 4648에 정의 된 &quot;Extended Hex Alphabet&quot;입니다. 일반적으로 DNS에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e23f68e03ccbc9812663415a4a25267a75156114" translate="yes" xml:space="preserve">
          <source>Hijack detaches the ClientConn and returns the underlying connection as well as the read-side bufio which may have some left over data. Hijack may be called before the user or Read have signaled the end of the keep-alive logic. The user should not call Hijack while Read or Write is in progress.</source>
          <target state="translated">Hijack은 ClientConn을 분리하고 기본 연결과 일부 데이터가 남아있을 수있는 읽기 측 bufio를 반환합니다. 사용자 또는 읽기가 연결 유지 논리의 끝을 알리기 전에 도용이 호출 될 수 있습니다. 읽기 또는 쓰기가 진행되는 동안 사용자는 Hijack을 호출해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="9150896df8944dbbb2d645bc78167fd76df1dc80" translate="yes" xml:space="preserve">
          <source>Hijack detaches the ServerConn and returns the underlying connection as well as the read-side bufio which may have some left over data. Hijack may be called before Read has signaled the end of the keep-alive logic. The user should not call Hijack while Read or Write is in progress.</source>
          <target state="translated">하이 잭은 ServerConn을 분리하고 기본 연결뿐만 아니라 일부 데이터가 남아있을 수있는 읽기 측 bufio를 반환합니다. 읽기가 연결 유지 논리의 끝을 알리기 전에 도용이 호출 될 수 있습니다. 읽기 또는 쓰기가 진행되는 동안 사용자는 Hijack을 호출해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="4a56321e103f0a1a522b694db3cb8d2d733e26fd" translate="yes" xml:space="preserve">
          <source>Hijacker</source>
          <target state="translated">Hijacker</target>
        </trans-unit>
        <trans-unit id="162450ef640a1216b7486b356d2e0daf7f97ce1d" translate="yes" xml:space="preserve">
          <source>Hostname returns the host name reported by the kernel.</source>
          <target state="translated">호스트 이름은 커널이보고 한 호스트 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="96c776e02774d643d6c9b2543ae4ea531e374ca6" translate="yes" xml:space="preserve">
          <source>Hostname returns u.Host, stripping any valid port number if present.</source>
          <target state="translated">호스트 이름은 유효한 포트 번호가 있으면 u.Host를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c10a91f09a43d36b8c063665239759dddfc07545" translate="yes" xml:space="preserve">
          <source>HostnameError results when the set of authorized names doesn't match the requested name.</source>
          <target state="translated">인증 된 이름 세트가 요청 된 이름과 일치하지 않으면 HostnameError가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a732fe7ae23ec635b26f3cda289c15cbca4f3d8c" translate="yes" xml:space="preserve">
          <source>Hour returns the hour within the day specified by t, in the range [0, 23].</source>
          <target state="translated">Hour는 [0, 23] 범위에서 t로 지정된 날짜 내의 시간을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="316afefe22138dc95ee9f3b2f4bc4164e8b8424e" translate="yes" xml:space="preserve">
          <source>Hours returns the duration as a floating point number of hours.</source>
          <target state="translated">시간은 지속 시간을 부동 소수점 시간 수로 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="29032d83edd3b2c57e81fe35f7063e01de42a614" translate="yes" xml:space="preserve">
          <source>However, there can be multiple leftmost-longest matches, with different submatch choices, and here this package diverges from POSIX. Among the possible leftmost-longest matches, this package chooses the one that a backtracking search would have found first, while POSIX specifies that the match be chosen to maximize the length of the first subexpression, then the second, and so on from left to right. The POSIX rule is computationally prohibitive and not even well-defined. See &lt;a href=&quot;https://swtch.com/~rsc/regexp/regexp2.html#posix&quot;&gt;https://swtch.com/~rsc/regexp/regexp2.html#posix&lt;/a&gt; for details.</source>
          <target state="translated">그러나 서로 다른 부분 일치 항목을 선택하면 가장 왼쪽에 가장 긴 일치 항목이 여러 개있을 수 있으며 여기서이 패키지는 POSIX와 다릅니다. 가능한 가장 왼쪽 일치 항목 중에서이 패키지는 역 추적 검색에서 가장 먼저 찾은 항목을 선택하는 반면 POSIX는 첫 번째 하위 표현식의 길이를 최대화 한 다음 두 번째 등의 길이를 왼쪽에서 오른쪽으로 최대화하도록 일치 항목을 선택하도록 지정합니다. . POSIX 규칙은 계산 상 금지 적이며 잘 정의되지 않았습니다. 자세한 내용은 &lt;a href=&quot;https://swtch.com/~rsc/regexp/regexp2.html#posix&quot;&gt;https://swtch.com/~rsc/regexp/regexp2.html#posix&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="40708df18a19eb4cd04fce64de3e8c9f00288cb2" translate="yes" xml:space="preserve">
          <source>However, to aid in formatting template source code, if an action's left delimiter (by default &quot;{{&quot;) is followed immediately by a minus sign and ASCII space character (&quot;{{- &quot;), all trailing white space is trimmed from the immediately preceding text. Similarly, if the right delimiter (&quot;}}&quot;) is preceded by a space and minus sign (&quot; -}}&quot;), all leading white space is trimmed from the immediately following text. In these trim markers, the ASCII space must be present; &quot;{{-3}}&quot; parses as an action containing the number -3.</source>
          <target state="translated">그러나 템플리트 소스 코드를 형식화하기 위해 조치의 왼쪽 분리 문자 (기본적으로 &quot;{{&quot;) 바로 뒤에 빼기 부호와 ASCII 공백 문자 ( &quot;{{-&quot;)가 오면 모든 후미 공백은 바로 앞의 텍스트. 마찬가지로 오른쪽 구분 기호 ( &quot;}}&quot;) 앞에 공백과 빼기 부호 ( &quot;-}}&quot;)가 있으면 모든 선행 공백이 바로 다음 텍스트에서 잘립니다. 이 트림 마커에는 ASCII 공간이 있어야합니다. &quot;{{-3}}&quot;은 숫자 -3을 포함하는 조치로 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="d4e4742177e63cc124605c711f8542e79a9c655e" translate="yes" xml:space="preserve">
          <source>However, when printing a byte slice with a string-like verb (%s %q %x %X), it is treated identically to a string, as a single item.</source>
          <target state="translated">그러나 문자열 유사 동사 (% s % q % x % X)를 사용하여 바이트 슬라이스를 인쇄 할 때는 단일 항목으로 문자열과 동일하게 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="5c4cbffa6231f3b3c2514644d0fee825e224c80d" translate="yes" xml:space="preserve">
          <source>Hypot returns Sqrt(p*p + q*q), taking care to avoid unnecessary overflow and underflow.</source>
          <target state="translated">Hypot은 불필요한 오버플로 및 언더 플로를 피하기 위해 Sqrt (p * p + q * q)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="576b7847aead683e23b77c003ff6f222a841ef25" translate="yes" xml:space="preserve">
          <source>IEEETable is the table for the IEEE polynomial.</source>
          <target state="translated">IEEETable은 IEEE 다항식에 대한 테이블입니다.</target>
        </trans-unit>
        <trans-unit id="a220db6c90383cf3092dacd6831c2890463d8ced" translate="yes" xml:space="preserve">
          <source>IMAGE_DIRECTORY_ENTRY constants</source>
          <target state="translated">IMAGE_DIRECTORY_ENTRY 상수</target>
        </trans-unit>
        <trans-unit id="f585c9fe77a34e4b203ca7586560b165b3fa9e06" translate="yes" xml:space="preserve">
          <source>IP address lengths (bytes).</source>
          <target state="translated">IP 주소 길이 (바이트)</target>
        </trans-unit>
        <trans-unit id="e746cf97286466a3ee7a6da22134f5658e5d9835" translate="yes" xml:space="preserve">
          <source>IP.DefaultMask</source>
          <target state="translated">IP.DefaultMask</target>
        </trans-unit>
        <trans-unit id="11cb3659b8e0ce7581cbb847a5c82b1c9f0fd371" translate="yes" xml:space="preserve">
          <source>IP.Mask</source>
          <target state="translated">IP.Mask</target>
        </trans-unit>
        <trans-unit id="afa88b5842f11425f491e338d7ab921fd1ba5273" translate="yes" xml:space="preserve">
          <source>IPAddr represents the address of an IP end point.</source>
          <target state="translated">IPAddr은 IP 엔드 포인트의 주소를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="62bf2467f82c0177288446c3c53fcfe1388fdbf4" translate="yes" xml:space="preserve">
          <source>IPConn is the implementation of the Conn and PacketConn interfaces for IP network connections.</source>
          <target state="translated">IPConn은 IP 네트워크 연결을위한 Conn 및 PacketConn 인터페이스의 구현입니다.</target>
        </trans-unit>
        <trans-unit id="f8a4e52fe170a6b87d8e8f324c9e46497e3e1a1e" translate="yes" xml:space="preserve">
          <source>IPv4</source>
          <target state="translated">IPv4</target>
        </trans-unit>
        <trans-unit id="01eafbb77fe2e5da4ec4f2fa2166e61bdbf17fda" translate="yes" xml:space="preserve">
          <source>IPv4 returns the IP address (in 16-byte form) of the IPv4 address a.b.c.d.</source>
          <target state="translated">IPv4는 IPv4 주소 abcd의 IP 주소 (16 바이트 형식)를 반환합니다</target>
        </trans-unit>
        <trans-unit id="3e2065fb2c469f55091e83e0c17ec6c33b2ade3a" translate="yes" xml:space="preserve">
          <source>IPv4Mask</source>
          <target state="translated">IPv4Mask</target>
        </trans-unit>
        <trans-unit id="d0818e19fd482dbfdc092a8f03eecab69f4f02c6" translate="yes" xml:space="preserve">
          <source>IPv4Mask returns the IP mask (in 4-byte form) of the IPv4 mask a.b.c.d.</source>
          <target state="translated">IPv4Mask는 IPv4 마스크 abcd의 IP 마스크 (4 바이트 형식)를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="84f775d13ea13d9914f862669240b386b5b2ce40" translate="yes" xml:space="preserve">
          <source>ISOWeek returns the ISO 8601 year and week number in which t occurs. Week ranges from 1 to 53. Jan 01 to Jan 03 of year n might belong to week 52 or 53 of year n-1, and Dec 29 to Dec 31 might belong to week 1 of year n+1.</source>
          <target state="translated">ISOWeek는 t가 발생하는 ISO 8601 연도와 주 번호를 반환합니다. 주 범위는 1-53입니다. n 년 1 월 1 일 ~ 1 월 03 일은 n-1 년의 52 주 또는 53 주에 속할 수 있으며, 12 월 29 일부터 12 월 31 일은 n + 1의 1 주차에 속할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08d6764cba419802272bb09d455c908144b957aa" translate="yes" xml:space="preserve">
          <source>Id is a wrapper for Id(obj.Pkg(), obj.Name()).</source>
          <target state="translated">Id는 Id (obj.Pkg (), obj.Name ())의 래퍼입니다.</target>
        </trans-unit>
        <trans-unit id="1d68ea4276c501cd9a850a1820a4a4d86fcccd10" translate="yes" xml:space="preserve">
          <source>Id returns name if it is exported, otherwise it returns the name qualified with the package path.</source>
          <target state="translated">내보내기는 이름을 반환하고, 그렇지 않으면 패키지 경로로 정규화 된 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fa08cb5f856950ffd31e99879394c8d2ecd78b73" translate="yes" xml:space="preserve">
          <source>Identical reports whether x and y are identical types. Receivers of Signature types are ignored.</source>
          <target state="translated">x와 y가 동일한 유형인지 여부는 동일합니다. 서명 유형의 수신자는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="62582ea142e0c589620d5bd10a3675dc62d150bc" translate="yes" xml:space="preserve">
          <source>IdenticalIgnoreTags reports whether x and y are identical types if tags are ignored. Receivers of Signature types are ignored.</source>
          <target state="translated">IdenticalIgnoreTags는 태그를 무시하면 x와 y가 동일한 유형인지보고합니다. 서명 유형의 수신자는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="1b283807cc15b11d0882e9fd847033d20b983bd2" translate="yes" xml:space="preserve">
          <source>IdentifierNode holds an identifier.</source>
          <target state="translated">IdentifierNode는 식별자를 보유합니다.</target>
        </trans-unit>
        <trans-unit id="e3f7a148cc891203b5f7d36d2d9e45cad70d628a" translate="yes" xml:space="preserve">
          <source>If 'All' is present, the routine matches successive non-overlapping matches of the entire expression. Empty matches abutting a preceding match are ignored. The return value is a slice containing the successive return values of the corresponding non-'All' routine. These routines take an extra integer argument, n. If n &amp;gt;= 0, the function returns at most n matches/submatches; otherwise, it returns all of them.</source>
          <target state="translated">'All'이 있으면 루틴은 전체 표현식의 연속적인 겹치지 않는 일치와 일치합니다. 선행 경기에 인접한 빈 경기는 무시됩니다. 리턴 값은 해당하는 'All'루틴의 연속 리턴 값을 포함하는 슬라이스입니다. 이 루틴은 추가 정수 인수 n을 사용합니다. n&amp;gt; = 0이면 함수는 최대 n 개의 일치 / 하위 일치를 반환합니다. 그렇지 않으면 모든 것을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4bc5ea7c2a0ba24905139043c1e06d713fc4b624" translate="yes" xml:space="preserve">
          <source>If 'Index' is present, matches and submatches are identified by byte index pairs within the input string: result[2*n:2*n+1] identifies the indexes of the nth submatch. The pair for n==0 identifies the match of the entire expression. If 'Index' is not present, the match is identified by the text of the match/submatch. If an index is negative or text is nil, it means that subexpression did not match any string in the input. For 'String' versions an empty string means either no match or an empty match.</source>
          <target state="translated">'Index'가 있으면 일치 및 부분 일치는 입력 문자열 내에서 바이트 인덱스 쌍으로 식별됩니다. result [2 * n : 2 * n + 1]은 n 번째 부분 일치의 인덱스를 식별합니다. n == 0의 쌍은 전체 표현식의 일치를 식별합니다. '색인'이 없으면 일치 / 하위 일치 텍스트로 일치를 식별합니다. 인덱스가 음수이거나 텍스트가 nil이면 하위 표현식이 입력의 문자열과 일치하지 않았 음을 의미합니다. '문자열'버전의 경우 빈 문자열은 일치하지 않거나 일치하지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="750f20e67d15d8b15512065e634f8a04cd24649d" translate="yes" xml:space="preserve">
          <source>If 'String' is present, the argument is a string; otherwise it is a slice of bytes; return values are adjusted as appropriate.</source>
          <target state="translated">'String'이 있으면 인수는 문자열입니다. 그렇지 않으면 바이트 조각입니다. 반환 값은 적절하게 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="6b5422b81678b9d8d259a31067e6668262dc0a15" translate="yes" xml:space="preserve">
          <source>If 'Submatch' is present, the return value is a slice identifying the successive submatches of the expression. Submatches are matches of parenthesized subexpressions (also known as capturing groups) within the regular expression, numbered from left to right in order of opening parenthesis. Submatch 0 is the match of the entire expression, submatch 1 the match of the first parenthesized subexpression, and so on.</source>
          <target state="translated">'Submatch'가 있으면 반환 값은 식의 연속적인 하위 일치를 식별하는 조각입니다. 부분 일치는 정규 표현식 내에서 괄호로 묶인 하위 표현식 (캡처 그룹이라고도 함)의 일치로, 괄호를 여는 순서대로 왼쪽에서 오른쪽으로 번호가 매겨집니다. 부분 일치 0은 전체 식의 일치, 부분 일치 1은 첫 번째 괄호로 묶은 하위 식의 일치 등입니다.</target>
        </trans-unit>
        <trans-unit id="c8e129ec8b814ed3ea9bfb24aed18824a3379050" translate="yes" xml:space="preserve">
          <source>If Body is present, Content-Length is &amp;lt;= 0 and TransferEncoding hasn't been set to &quot;identity&quot;, Write adds &quot;Transfer-Encoding: chunked&quot; to the header. Body is closed after it is sent.</source>
          <target state="translated">본문이 있고 Content-Length가 &amp;lt;= 0이고 TransferEncoding이 &quot;identity&quot;로 설정되지 않은 경우 Write는 &quot;Transfer-Encoding : chunked&quot;를 헤더에 추가합니다. 전송 된 후 본문이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="a4c660d2d836ce5011f39f208170601c14fc3f84" translate="yes" xml:space="preserve">
          <source>If CheckNamedValue returns ErrRemoveArgument, the NamedValue will not be included in the final query arguments. This may be used to pass special options to the query itself.</source>
          <target state="translated">CheckNamedValue가 ErrRemoveArgument를 반환하면 NamedValue는 최종 쿼리 인수에 포함되지 않습니다. 이는 특수 옵션을 쿼리 자체에 전달하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16a03bedfc442181d888e7b8ec8eee1e7e8562bb" translate="yes" xml:space="preserve">
          <source>If Conn.Ping returns ErrBadConn, DB.Ping and DB.PingContext will remove the Conn from pool.</source>
          <target state="translated">Conn.Ping이 ErrBadConn을 반환하면 DB.Ping 및 DB.PingContext는 풀에서 Conn을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="9bf5fb8d1ebbb6dc425efaa4065a072560c9aaa0" translate="yes" xml:space="preserve">
          <source>If DIR is a directory listed in the Go path, a package with source in DIR/src/foo/bar can be imported as &quot;foo/bar&quot; and has its compiled form installed to &quot;DIR/pkg/GOOS_GOARCH/foo/bar.a&quot; (or, for gccgo, &quot;DIR/pkg/gccgo/foo/libbar.a&quot;).</source>
          <target state="translated">DIR이 이동 경로에 나열된 디렉토리 인 경우 DIR / src / foo / bar에 소스가있는 패키지를 &quot;foo / bar&quot;로 가져올 수 있으며 컴파일 된 양식이 &quot;DIR / pkg / GOOS_GOARCH / foo / bar에 설치됩니다. a &quot;(또는 gccgo의 경우&quot;DIR / pkg / gccgo / foo / libbar.a &quot;).</target>
        </trans-unit>
        <trans-unit id="626d82422a444f8260197f6a255b844b957560c9" translate="yes" xml:space="preserve">
          <source>If Dir is SelectDefault, the case represents a default case. Chan and Send must be zero Values.</source>
          <target state="translated">Dir이 SelectDefault 인 경우 케이스는 기본 케이스를 나타냅니다. Chan과 Send는 0 값이어야합니다.</target>
        </trans-unit>
        <trans-unit id="b64c8a9a4dd6bc23186cb39d29f2d6a941b37467" translate="yes" xml:space="preserve">
          <source>If Dir is SelectRecv, the case represents a receive operation. Normally Chan's underlying value must be a channel and Send must be a zero Value. If Chan is a zero Value, then the case is ignored, but Send must still be a zero Value. When a receive operation is selected, the received Value is returned by Select.</source>
          <target state="translated">Dir이 SelectRecv이면 케이스는 수신 조작을 나타냅니다. 일반적으로 Chan의 기본 값은 채널이어야하고 Send는 0 값이어야합니다. Chan이 0 값이면 케이스는 무시되지만 Send는 여전히 0 값이어야합니다. 수신 작업이 선택되면 수신 된 값이 Select에 의해 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="fc3241471000ca543780e2776c12ce2c0f98b518" translate="yes" xml:space="preserve">
          <source>If Dir is SelectSend, the case represents a send operation. Normally Chan's underlying value must be a channel, and Send's underlying value must be assignable to the channel's element type. As a special case, if Chan is a zero Value, then the case is ignored, and the field Send will also be ignored and may be either zero or non-zero.</source>
          <target state="translated">Dir이 SelectSend 인 경우 사례는 전송 작업을 나타냅니다. 일반적으로 Chan의 기본 값은 채널이어야하며 Send의 기본 값은 채널의 요소 유형에 지정 가능해야합니다. 특별한 경우, Chan이 0 값이면 케이스가 무시되고 Send 필드도 무시되며 0이 아니거나 0이 아닐 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e5a9a392b54a0f9dbcf70e078d697829fda46e7" translate="yes" xml:space="preserve">
          <source>If Discard skips fewer than n bytes, it also returns an error. If 0 &amp;lt;= n &amp;lt;= b.Buffered(), Discard is guaranteed to succeed without reading from the underlying io.Reader.</source>
          <target state="translated">삭제가 n 바이트 미만을 건너 뛰면 오류도 반환합니다. 0 &amp;lt;= n &amp;lt;= b.Buffered ()이면 기본 io.Reader에서 읽지 않고 버리기가 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="5388f313bdebc1cd743073994620f637168dfccb" translate="yes" xml:space="preserve">
          <source>If DiscardEmptyColumns is set, empty columns that are terminated entirely by vertical (or &quot;soft&quot;) tabs are discarded. Columns terminated by horizontal (or &quot;hard&quot;) tabs are not affected by this flag.</source>
          <target state="translated">DiscardEmptyColumns를 설정하면 세로 (또는 &quot;소프트&quot;) 탭으로 완전히 종료 된 빈 열은 삭제됩니다. 가로 (또는 &quot;하드&quot;) 탭으로 끝나는 열은이 플래그의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c9deb8e1a0cfa1d1825dc49ade2afa7eec850bd3" translate="yes" xml:space="preserve">
          <source>If ErrSkip is returned the column converter error checking path is used for the argument. Drivers may wish to return ErrSkip after they have exhausted their own special cases.</source>
          <target state="translated">ErrSkip가 리턴되면 열 변환기 오류 점검 경로가 인수에 사용됩니다. 운전자는 자신의 특별한 경우를 소진 한 후 ErrSkip을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="acb8bfb04c68aa06cf649fa65fe83fd0ec6ad99b" translate="yes" xml:space="preserve">
          <source>If Get would otherwise return nil and p.New is non-nil, Get returns the result of calling p.New.</source>
          <target state="translated">Get이 달리 nil을 반환하고 p.New가 nil이 아닌 경우 Get은 p.New를 호출 한 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cbb35dd622fd4fc40d747d7fe8a39806c85598b4" translate="yes" xml:space="preserve">
          <source>If MaxIdleConns is greater than 0 and the new MaxOpenConns is less than MaxIdleConns, then MaxIdleConns will be reduced to match the new MaxOpenConns limit.</source>
          <target state="translated">MaxIdleConns가 0보다 크고 새로운 MaxOpenConns가 MaxIdleConns보다 작 으면 MaxIdleConns가 새로운 MaxOpenConns 제한과 일치하도록 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="0566ce3b75e32de588395cc9db25a53062d79613" translate="yes" xml:space="preserve">
          <source>If MaxOpenConns is greater than 0 but less than the new MaxIdleConns, then the new MaxIdleConns will be reduced to match the MaxOpenConns limit.</source>
          <target state="translated">MaxOpenConns가 0보다 크지 만 새 MaxIdleConns보다 작은 경우 MaxOpenConns 제한과 일치하도록 새 MaxIdleConns가 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="ba59fc6bf9458413409db5ff0b9045c64e756bcb" translate="yes" xml:space="preserve">
          <source>If ReadAt is reading from an input source with a seek offset, ReadAt should not affect nor be affected by the underlying seek offset.</source>
          <target state="translated">ReadAt가 탐색 오프셋이있는 입력 소스에서 읽는 경우 ReadAt는 기본 탐색 오프셋에 영향을 주거나 영향을받지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="cc3d6766541295fe523ec22933263aa9a06c4657" translate="yes" xml:space="preserve">
          <source>If ServeHTTP panics, the server (the caller of ServeHTTP) assumes that the effect of the panic was isolated to the active request. It recovers the panic, logs a stack trace to the server error log, and either closes the network connection or sends an HTTP/2 RST_STREAM, depending on the HTTP protocol. To abort a handler so the client sees an interrupted response but the server doesn't log an error, panic with the value ErrAbortHandler.</source>
          <target state="translated">ServeHTTP 패닉 인 경우 서버 (ServeHTTP의 호출자)는 패닉의 영향이 활성 요청과 분리되었다고 가정합니다. 패닉을 복구하고 스택 추적을 서버 오류 로그에 기록한 다음 HTTP 프로토콜에 따라 네트워크 연결을 닫거나 HTTP / 2 RST_STREAM을 보냅니다. 클라이언트가 중단 된 응답을 볼 수 있도록 서버를 중단하기 위해 서버가 오류를 기록하지 않으면 ErrAbortHandler 값으로 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="7c30ed6f837b3e7a9558eb599fa8c56e0e97063b" translate="yes" xml:space="preserve">
          <source>If Times t and u both contain monotonic clock readings, the operations t.After(u), t.Before(u), t.Equal(u), and t.Sub(u) are carried out using the monotonic clock readings alone, ignoring the wall clock readings. If either t or u contains no monotonic clock reading, these operations fall back to using the wall clock readings.</source>
          <target state="translated">시간 t와 u가 모두 단조 클록 판독을 포함하는 경우, t.After (u), t.Before (u), t.Equal (u) 및 t.Sub (u) 연산은 단조 클록 판독 만 사용하여 수행됩니다. , 벽시계 판독 값을 무시합니다. t 또는 u에 단조로운 시계 판독 값이없는 경우 이러한 작업은 벽시계 판독 값 사용으로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="bc4d8baa4dbb3f1a94db59ec9aa34f357782809d" translate="yes" xml:space="preserve">
          <source>If Unmarshal encounters a field type that implements the Unmarshaler interface, Unmarshal calls its UnmarshalXML method to produce the value from the XML element. Otherwise, if the value implements encoding.TextUnmarshaler, Unmarshal calls that value's UnmarshalText method.</source>
          <target state="translated">Unmarshal이 Unmarshaler 인터페이스를 구현하는 필드 유형을 발견하면 Unmarshal은 UnmarshalXML 메소드를 호출하여 XML 요소에서 값을 생성합니다. 그렇지 않으면 값이 encoding.TextUnmarshaler를 구현하면 Unmarshal은 해당 값의 UnmarshalText 메서드를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="e7b1cef9234b9022f80f99b102d2ffde95658f55" translate="yes" xml:space="preserve">
          <source>If UseCRLF is true, the Writer ends each output line with \r\n instead of \n.</source>
          <target state="translated">UseCRLF가 true이면 작성기는 각 출력 행을 \ n 대신 \ r \ n으로 끝냅니다.</target>
        </trans-unit>
        <trans-unit id="24f02297c63afdceb90dae9a889e378f8f5dc1c7" translate="yes" xml:space="preserve">
          <source>If WriteAt is writing to a destination with a seek offset, WriteAt should not affect nor be affected by the underlying seek offset.</source>
          <target state="translated">WriteAt가 탐색 오프셋으로 대상에 쓰는 경우 WriteAt는 기본 탐색 오프셋에 영향을 주거나 영향을받지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="01ec25dfc6204eb6897de5935b9779223b3cad13" translate="yes" xml:space="preserve">
          <source>If a &quot;range&quot; action initializes a variable, the variable is set to the successive elements of the iteration. Also, a &quot;range&quot; may declare two variables, separated by a comma:</source>
          <target state="translated">&quot;범위&quot;조치가 변수를 초기화하면 변수는 반복의 연속 요소로 설정됩니다. 또한 &quot;범위&quot;는 쉼표로 구분 된 두 변수를 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58d444ec12c7fa5d6e872ab50772870b5a393d01" translate="yes" xml:space="preserve">
          <source>If a Conn does not implement ExecerContext, the sql package's DB.Exec will fall back to Execer; if the Conn does not implement Execer either, DB.Exec will first prepare a query, execute the statement, and then close the statement.</source>
          <target state="translated">Conn이 ExecerContext를 구현하지 않으면 SQL 패키지의 DB.Exec은 Execer로 대체됩니다. Conn이 Execer를 구현하지 않으면 DB.Exec은 먼저 쿼리를 준비하고 문을 실행 한 다음 문을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="44e6dfb38005e87694379cf1c0216f95562e9cfb" translate="yes" xml:space="preserve">
          <source>If a Conn does not implement Pinger, the sql package's DB.Ping and DB.PingContext will check if there is at least one Conn available.</source>
          <target state="translated">Conn이 Pinger를 구현하지 않으면 SQL 패키지의 DB.Ping 및 DB.PingContext는 사용 가능한 Conn이 하나 이상 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="21128809a4ab46817c40f8b5969689593dcd6f72" translate="yes" xml:space="preserve">
          <source>If a Conn does not implement QueryerContext, the sql package's DB.Query will fall back to Queryer; if the Conn does not implement Queryer either, DB.Query will first prepare a query, execute the statement, and then close the statement.</source>
          <target state="translated">Conn이 QueryerContext를 구현하지 않으면 SQL 패키지의 DB.Query가 Queryer로 대체됩니다. Conn이 Queryer를 구현하지 않으면 DB.Query는 먼저 쿼리를 준비하고 명령문을 실행 한 다음 명령문을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="45c4be212f44031bede2b5276a4a3589a0dc2b98" translate="yes" xml:space="preserve">
          <source>If a Conn implements neither ExecerContext nor Execer, the sql package's DB.Exec will first prepare a query, execute the statement, and then close the statement.</source>
          <target state="translated">Conn이 ExecerContext도 Execer도 구현하지 않으면 SQL 패키지의 DB.Exec은 먼저 쿼리를 준비하고 문을 실행 한 다음 문을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="1cb5d6dd6f4d516d1ae37935040abf369ba105f8" translate="yes" xml:space="preserve">
          <source>If a Conn implements neither QueryerContext nor Queryer, the sql package's DB.Query will first prepare a query, execute the statement, and then close the statement.</source>
          <target state="translated">Conn이 QueryerContext 또는 Queryer를 구현하지 않으면 sql 패키지의 DB.Query는 먼저 쿼리를 준비하고 명령문을 실행 한 다음 명령문을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="71c0f29e06c175a2adb537fdf47269746a601d0d" translate="yes" xml:space="preserve">
          <source>If a Driver implements DriverContext, then sql.DB will call OpenConnector to obtain a Connector and then invoke that Connector's Conn method to obtain each needed connection, instead of invoking the Driver's Open method for each connection. The two-step sequence allows drivers to parse the name just once and also provides access to per-Conn contexts.</source>
          <target state="translated">Driver가 DriverContext를 구현하면 sql.DB는 OpenConnector를 호출하여 커넥터를 얻은 다음 각 연결에 대해 Driver 's Open 메소드를 호출하는 대신 커넥터의 Conn 메소드를 호출하여 필요한 각 연결을 얻습니다. 2 단계 시퀀스를 통해 드라이버는 이름을 한 번만 구문 분석하고 Conn 컨텍스트마다 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="232b341436c8f9f54c10a5dba1cf92c214798814" translate="yes" xml:space="preserve">
          <source>If a JSON value is not appropriate for a given target type, or if a JSON number overflows the target type, Unmarshal skips that field and completes the unmarshaling as best it can. If no more serious errors are encountered, Unmarshal returns an UnmarshalTypeError describing the earliest such error. In any case, it's not guaranteed that all the remaining fields following the problematic one will be unmarshaled into the target object.</source>
          <target state="translated">JSON 값이 지정된 대상 유형에 적합하지 않거나 JSON 번호가 대상 유형을 오버플로하는 경우 Unmarshal은 해당 필드를 건너 뛰고 가능한 한 비 정렬 화를 완료합니다. 더 이상 심각한 오류가 발생하지 않으면 Unmarshal은 초기 오류를 설명하는 UnmarshalTypeError를 반환합니다. 어쨌든 문제가있는 필드 다음에 남아있는 모든 필드가 대상 객체로 마샬링되지 않는다고 보장 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="07bd09bc1ed04a73b33dd796fe781c9034c95572" translate="yes" xml:space="preserve">
          <source>If a Stmt is prepared on a Tx or Conn, it will be bound to a single underlying connection forever. If the Tx or Conn closes, the Stmt will become unusable and all operations will return an error. If a Stmt is prepared on a DB, it will remain usable for the lifetime of the DB. When the Stmt needs to execute on a new underlying connection, it will prepare itself on the new connection automatically.</source>
          <target state="translated">Stmt가 Tx 또는 Conn에서 준비된 경우 단일 기본 연결에 영구적으로 바인딩됩니다. Tx 또는 Conn이 닫히면 Stmt를 사용할 수 없게되고 모든 작업에서 오류가 반환됩니다. Stmt가 DB에서 준비된 경우 DB 수명 동안 사용할 수 있습니다. Stmt를 새로운 기본 연결에서 실행해야 할 경우 새 연결에서 자동으로 준비됩니다.</target>
        </trans-unit>
        <trans-unit id="3b80dd32b6041fa4ef2f09439544647455bd33ab" translate="yes" xml:space="preserve">
          <source>If a Value has an IsBoolFlag() bool method returning true, the command-line parser makes -name equivalent to -name=true rather than using the next command-line argument.</source>
          <target state="translated">Value에 true를 반환하는 IsBoolFlag () bool 메서드가있는 경우 명령 줄 구문 분석기는 다음 명령 줄 인수를 사용하지 않고 -name을 -name = true와 동일하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="1d651c7c470bed2709ac735baaeec98dda753ea4" translate="yes" xml:space="preserve">
          <source>If a Writer is configured to filter HTML, HTML tags and entities are passed through. The widths of tags and entities are assumed to be zero (tags) and one (entities) for formatting purposes.</source>
          <target state="translated">Writer가 HTML을 필터링하도록 구성된 경우 HTML 태그 및 엔터티가 전달됩니다. 태그 및 엔티티의 너비는 형식화를 위해 0 (태그) 및 1 (엔티티) 인 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="52438c4d80c78ea57962cd3af33f715085501ef6" translate="yes" xml:space="preserve">
          <source>If a benchmark needs some expensive setup before running, the timer may be reset:</source>
          <target state="translated">벤치 마크를 실행하기 전에 값 비싼 설정이 필요한 경우 타이머가 재설정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7727dcc2593fe8b30c299beed7e6a6b86f7e22b" translate="yes" xml:space="preserve">
          <source>If a benchmark needs to test performance in a parallel setting, it may use the RunParallel helper function; such benchmarks are intended to be used with the go test -cpu flag:</source>
          <target state="translated">벤치 마크가 병렬 설정에서 성능을 테스트해야하는 경우 RunParallel 헬퍼 기능을 사용할 수 있습니다. 이러한 벤치 마크는 go test -cpu 플래그와 함께 사용하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="a54ff063e15dbe9b378b4160c9280c7409b22dcb" translate="yes" xml:space="preserve">
          <source>If a dest argument has type *[]byte, Scan saves in that argument a copy of the corresponding data. The copy is owned by the caller and can be modified and held indefinitely. The copy can be avoided by using an argument of type *RawBytes instead; see the documentation for RawBytes for restrictions on its use.</source>
          <target state="translated">대상 인수의 유형이 * [] byte 인 경우 Scan은 해당 인수에 해당 데이터의 사본을 저장합니다. 사본은 발신자가 소유하며 수정 및 무기한 보유 할 수 있습니다. 대신 * RawBytes 유형의 인수를 사용하여 복사를 피할 수 있습니다. 사용에 대한 제한 사항은 RawBytes 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="20186d29e290366ced58a159801092dd58a776e3" translate="yes" xml:space="preserve">
          <source>If a field uses a tag &quot;a&amp;gt;b&amp;gt;c&quot;, then the element c will be nested inside parent elements a and b. Fields that appear next to each other that name the same parent will be enclosed in one XML element.</source>
          <target state="translated">필드가 &quot;a&amp;gt; b&amp;gt; c&quot;태그를 사용하는 경우 요소 c는 부모 요소 a와 b 안에 중첩됩니다. 같은 부모를 나타내는 서로 옆에 나타나는 필드는 하나의 XML 요소로 묶입니다.</target>
        </trans-unit>
        <trans-unit id="9df6c8e2aa87346f45992618c6d030de25253b4a" translate="yes" xml:space="preserve">
          <source>If a file's name, after stripping the extension and a possible _test suffix, matches any of the following patterns:</source>
          <target state="translated">확장자와 가능한 _test 접미사를 제거한 후 파일 이름이 다음 패턴 중 하나와 일치하는 경우 :</target>
        </trans-unit>
        <trans-unit id="d6c46042317668db3b232f00f55a1ab61b108925" translate="yes" xml:space="preserve">
          <source>If a goroutine holds a RWMutex for reading and another goroutine might call Lock, no goroutine should expect to be able to acquire a read lock until the initial read lock is released. In particular, this prohibits recursive read locking. This is to ensure that the lock eventually becomes available; a blocked Lock call excludes new readers from acquiring the lock.</source>
          <target state="translated">goroutine이 읽기 위해 RWMutex를 보유하고 있고 다른 goroutine이 Lock을 호출 할 수있는 경우 goroutine은 초기 읽기 잠금이 해제 될 때까지 읽기 잠금을 확보 할 수 없습니다. 특히, 이것은 재귀 적 읽기 잠금을 금지합니다. 이것은 잠금이 결국 사용 가능하도록하기위한 것입니다. 차단 된 잠금 호출은 새로운 독자가 잠금을 획득하지 못하게합니다.</target>
        </trans-unit>
        <trans-unit id="54b696ffb9e87ece68a0d432b267874461da7b0c" translate="yes" xml:space="preserve">
          <source>If a pointer argument must be converted to uintptr for use as an argument, that conversion must appear in the call expression itself:</source>
          <target state="translated">인수로 사용하기 위해 포인터 인수를 uintptr로 변환해야하는 경우 해당 변환은 호출 표현식 자체에 나타나야합니다.</target>
        </trans-unit>
        <trans-unit id="a7be185efba59538fbd160cb8d8144506dd7c57d" translate="yes" xml:space="preserve">
          <source>If a subtree has been registered and a request is received naming the subtree root without its trailing slash, ServeMux redirects that request to the subtree root (adding the trailing slash). This behavior can be overridden with a separate registration for the path without the trailing slash. For example, registering &quot;/images/&quot; causes ServeMux to redirect a request for &quot;/images&quot; to &quot;/images/&quot;, unless &quot;/images&quot; has been registered separately.</source>
          <target state="translated">하위 트리가 등록되고 후행 슬래시없이 하위 트리 루트의 이름을 지정하는 요청이 수신되면 ServeMux는 해당 요청을 하위 트리 루트로 재 지정합니다 (후행 슬래시 추가). 이 동작은 슬래시없이 경로에 대한 별도의 등록으로 재정의 할 수 있습니다. 예를 들어 &quot;/ images /&quot;를 등록하면 &quot;/ images&quot;가 별도로 등록되지 않은 경우 ServeMux가 &quot;/ images&quot;요청을 &quot;/ images /&quot;로 리디렉션합니다.</target>
        </trans-unit>
        <trans-unit id="104ed2563a73defc4faea46be899a20063ec818c" translate="yes" xml:space="preserve">
          <source>If a template with the given name already exists, the new HTML template will replace it. The existing template will be reset and disassociated with t.</source>
          <target state="translated">지정된 이름의 템플릿이 이미 존재하면 새 HTML 템플릿이이를 대체합니다. 기존 템플릿이 재설정되고 t와 연결이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="463d47c06a7100464461b73a8101f7660c223839" translate="yes" xml:space="preserve">
          <source>If a value is passed to Encode and the type is not a struct (or pointer to struct, etc.), for simplicity of processing it is represented as a struct of one field. The only visible effect of this is to encode a zero byte after the value, just as after the last field of an encoded struct, so that the decode algorithm knows when the top-level value is complete.</source>
          <target state="translated">값이 Encode에 전달되고 유형이 구조체 (또는 구조체에 대한 포인터 등)가 아닌 경우 처리를 단순화하기 위해 한 필드의 구조체로 표시됩니다. 이것의 유일한 눈에 띄는 효과는 인코딩 된 구조체의 마지막 필드와 마찬가지로 값 다음에 0 바이트를 인코딩하여 디코드 알고리즘이 최상위 값이 완료된 시점을 알 수 있도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d7d467cb048cd5252bcf40b068f20c227a6c5268" translate="yes" xml:space="preserve">
          <source>If an Error or String method triggers a panic when called by a print routine, the fmt package reformats the error message from the panic, decorating it with an indication that it came through the fmt package. For example, if a String method calls panic(&quot;bad&quot;), the resulting formatted message will look like</source>
          <target state="translated">에러 또는 문자열 메소드가 인쇄 루틴에 의해 호출 될 때 패닉을 트리거하면 fmt 패키지는 패닉에서 오류 메시지를 다시 포맷하여 fmt 패키지를 통과했다는 표시로 장식합니다. 예를 들어, String 메소드가 panic ( &quot;bad&quot;)를 호출하면 결과 형식화 된 메시지는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d3278ea50ebebf5ea6289948b73b15f204c549e9" translate="yes" xml:space="preserve">
          <source>If an argument has type *interface{}, Scan copies the value provided by the underlying driver without conversion. When scanning from a source value of type []byte to *interface{}, a copy of the slice is made and the caller owns the result.</source>
          <target state="translated">인수에 * interface {} 유형이 있으면 Scan은 기본 드라이버가 제공 한 값을 변환하지 않고 복사합니다. [] byte 유형의 소스 값에서 * interface {}로 스캔 할 때 슬라이스 사본이 작성되고 호출자는 결과를 소유합니다.</target>
        </trans-unit>
        <trans-unit id="6c7525fb96a9e6dded8b4dd1c94198523c01a7a6" translate="yes" xml:space="preserve">
          <source>If an error occurs, Import returns a non-nil error and a non-nil *Package containing partial information.</source>
          <target state="translated">오류가 발생하면 Import는 nil이 아닌 오류와 부분 정보를 포함하는 nil이 아닌 * Package를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="22a8988276a496bd99d453fc14d11bfb8cde90f0" translate="yes" xml:space="preserve">
          <source>If an invalid argument is given for a verb, such as providing a string to %d, the generated string will contain a description of the problem, as in these examples:</source>
          <target state="translated">% d에 문자열을 제공하는 것과 같이 동사에 대해 잘못된 인수가 제공되면 생성 된 문자열에는 다음 예제와 같이 문제에 대한 설명이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="2f5f672edd948d125f1a8e2164d6570e08508e2a" translate="yes" xml:space="preserve">
          <source>If any of c.Stdin, c.Stdout or c.Stderr are not an *os.File, Wait also waits for the respective I/O loop copying to or from the process to complete.</source>
          <target state="translated">c.Stdin, c.Stdout 또는 c.Stderr 중 하나가 * os.File이 아닌 경우, 대기는 또한 각 I / O 루프 복사가 프로세스로 또는 프로세스에서 완료 될 때까지 대기합니다.</target>
        </trans-unit>
        <trans-unit id="f2c348eae7d177d9986e66ac0dbb1fa9c1c8eff2" translate="yes" xml:space="preserve">
          <source>If b has invalid headers and cannot be encoded, EncodeToMemory returns nil. If it is important to report details about this error case, use Encode instead.</source>
          <target state="translated">b에 유효하지 않은 헤더가 있고 인코딩 할 수없는 경우 EncodeToMemory는 nil을 반환합니다. 이 오류 사례에 대한 세부 정보를보고해야하는 경우 대신 Encode를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="81446ee41b4f44409d6c98445688e2c9dc448484" translate="yes" xml:space="preserve">
          <source>If base == 0, the base is implied by the string's prefix: base 2 for &quot;0b&quot;, base 8 for &quot;0&quot; or &quot;0o&quot;, base 16 for &quot;0x&quot;, and base 10 otherwise. Also, for base == 0 only, underscore characters are permitted per the Go integer literal syntax. If base is below 0, is 1, or is above 36, an error is returned.</source>
          <target state="translated">base == 0 인 경우 문자열의 접두사로 &quot;base&quot;, 즉 &quot;0b&quot;의 base 2, &quot;0&quot;또는 &quot;0o&quot;의 base 8, &quot;0x&quot;의 base 16, 그렇지 않은 경우 10이 포함됩니다. 또한 base == 0의 경우에만 Go 정수 리터럴 구문에 따라 밑줄 문자가 허용됩니다. 밑이 0보다 작거나 1이거나 36보다 크면 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ff7cc9932856849c823dcd514ebeb18a3facfdc3" translate="yes" xml:space="preserve">
          <source>If body is of type *bytes.Buffer, *bytes.Reader, or *strings.Reader, the returned request's ContentLength is set to its exact value (instead of -1), GetBody is populated (so 307 and 308 redirects can replay the body), and Body is set to NoBody if the ContentLength is 0.</source>
          <target state="translated">body의 유형이 * bytes.Buffer, * bytes.Reader 또는 * strings.Reader 인 경우, 리턴 된 요청의 ContentLength가 정확한 값 (-1 대신)으로 설정되고 GetBody가 채워 지므로 307 및 308 경로 재 지정을 재생할 수 있습니다. ContentLength가 0이면 Body가 NoBody로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="07cc785c40dfb93b351fa360eaf5c11b3a687a2b" translate="yes" xml:space="preserve">
          <source>If body is true, DumpRequest also returns the body. To do so, it consumes req.Body and then replaces it with a new io.ReadCloser that yields the same bytes. If DumpRequest returns an error, the state of req is undefined.</source>
          <target state="translated">body가 true이면 DumpRequest도 본문을 반환합니다. 그렇게하기 위해 req.Body를 소비 한 다음 동일한 바이트를 생성하는 새로운 io.ReadCloser로 대체합니다. DumpRequest가 오류를 반환하면 req 상태는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e8579022b484933fe4198bbc194c8a61565aa3ef" translate="yes" xml:space="preserve">
          <source>If d &amp;lt;= 0, connections are reused forever.</source>
          <target state="translated">d &amp;lt;= 0이면 연결이 영원히 재사용됩니다.</target>
        </trans-unit>
        <trans-unit id="11054b794a9e66d49b745938ef3b656c43f6d39e" translate="yes" xml:space="preserve">
          <source>If data is a reflect.Value, the template applies to the concrete value that the reflect.Value holds, as in fmt.Print.</source>
          <target state="translated">데이터가 reflect.Value 인 경우 템플리트는 fmt.Print 에서처럼 reflect.Value가 보유하는 구체적인 값에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="f83ceb0ced26c1c764536b5ff1b4fa15e74b62ce" translate="yes" xml:space="preserve">
          <source>If dst implements the ReaderFrom interface, the copy is implemented using it.</source>
          <target state="translated">dst가 ReaderFrom 인터페이스를 구현하는 경우이를 사용하여 사본이 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="6833b17cfcf75e1b486e6c702d0520e85f9b86a2" translate="yes" xml:space="preserve">
          <source>If e.Unwrap() returns a non-nil error w, then we say that e wraps w.</source>
          <target state="translated">e.Unwrap ()이 0이 아닌 에러 w를 반환하면, 우리는 e wrap을 말한다.</target>
        </trans-unit>
        <trans-unit id="81786ec59b1db1b26068cac6cb2b8f77c848e02c" translate="yes" xml:space="preserve">
          <source>If enabled (the default), the Reader expects the input to be a sequence of individually gzipped data streams, each with its own header and trailer, ending at EOF. The effect is that the concatenation of a sequence of gzipped files is treated as equivalent to the gzip of the concatenation of the sequence. This is standard behavior for gzip readers.</source>
          <target state="translated">활성화 된 경우 (기본값) Reader는 입력이 각각 고유 한 헤더와 트레일러가있는 개별적으로 압축 된 데이터 스트림 시퀀스가 ​​EOF에서 끝나기를 기대합니다. 그 효과는 gzipped 파일 시퀀스의 연결이 시퀀스 연결의 gzip과 동일하게 취급된다는 것입니다. 이것은 gzip 리더의 표준 동작입니다.</target>
        </trans-unit>
        <trans-unit id="eddf53f9cf1fca82486b2bf4ab21846e817aba06" translate="yes" xml:space="preserve">
          <source>If f calls Run, the result will be an estimate of running all its subbenchmarks that don't call Run in sequence in a single benchmark.</source>
          <target state="translated">f가 Run을 호출하면 단일 벤치 마크에서 Run을 순차적으로 호출하지 않는 모든 하위 벤치 마크를 실행 한 것으로 추정됩니다.</target>
        </trans-unit>
        <trans-unit id="24aa535ef0441b2f9dcbe0e4bbff395ed6067287" translate="yes" xml:space="preserve">
          <source>If f depends on testing flags, then Init must be used to register those flags before calling Benchmark and before calling flag.Parse.</source>
          <target state="translated">f가 테스트 플래그에 의존하는 경우, Benchmark를 호출하기 전에 그리고 flag.Parse를 호출하기 전에 Init를 사용하여 해당 플래그를 등록해야합니다.</target>
        </trans-unit>
        <trans-unit id="08b53793b968ecc1f35e8cac439169b17517c834" translate="yes" xml:space="preserve">
          <source>If f has a symbol version table, the returned Symbols will have initialized Version and Library fields.</source>
          <target state="translated">f에 기호 버전 테이블이있는 경우 반환 된 기호는 버전 및 라이브러리 필드를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="d8c9bcc7ac7c9df2b87a2dbabc8c6ec7964d0a03" translate="yes" xml:space="preserve">
          <source>If f panics, Do considers it to have returned; future calls of Do return without calling f.</source>
          <target state="translated">공황 상태라면 Do는 그것이 돌아온 것으로 간주합니다. 향후 Do 호출은 호출하지 않고 돌아옵니다. f.</target>
        </trans-unit>
        <trans-unit id="cfdf3a788dfda0a29c8d0cf447a4cec60c0bc739" translate="yes" xml:space="preserve">
          <source>If file was opened with the O_APPEND flag, WriteAt returns an error.</source>
          <target state="translated">O_APPEND 플래그로 파일을 열면 WriteAt에서 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="822b75e4d85498d0d8696aa19251040ab86e6e90" translate="yes" xml:space="preserve">
          <source>If filter != nil, only the files with os.FileInfo entries passing through the filter (and ending in &quot;.go&quot;) are considered. The mode bits are passed to ParseFile unchanged. Position information is recorded in fset, which must not be nil.</source>
          <target state="translated">filter! = nil 인 경우 os.FileInfo 항목이 필터를 통과하고 &quot;.go&quot;로 끝나는 파일 만 고려됩니다. 모드 비트는 변경되지 않고 ParseFile로 전달됩니다. 위치 정보는 fset에 기록되며 nil이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="78e87476be473e05171bc062a52f2074d7a8ce2f" translate="yes" xml:space="preserve">
          <source>If flush is true, Decode assumes that src represents the end of the input stream and processes it completely rather than wait for the completion of another 32-bit block.</source>
          <target state="translated">flush가 true이면, Decode는 src가 입력 스트림의 끝을 나타내고 다른 32 비트 블록의 완료를 기다리지 않고이를 완전히 처리한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="abcd3e65f17be630b169b8e4f1f0e366085cdf18" translate="yes" xml:space="preserve">
          <source>If format is a different character, Text returns a &quot;%&quot; followed by the unrecognized format character.</source>
          <target state="translated">형식이 다른 문자이면 텍스트는 &quot;%&quot;와 인식 할 수없는 형식 문자를 차례로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5da5429fa2e44a95884b22d9fe6c9389416883fa" translate="yes" xml:space="preserve">
          <source>If id is an embedded struct field, ObjectOf returns the field (*Var) it defines, not the type (*TypeName) it uses.</source>
          <target state="translated">id가 내장 구조체 필드 인 경우 ObjectOf는 사용하는 유형 (* TypeName)이 아니라 정의한 필드 (* Var)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5f15fee8dc8778902e45311fbf0205cb96dcffed" translate="yes" xml:space="preserve">
          <source>If inuseZero is true, the profile includes allocation records where r.AllocBytes &amp;gt; 0 but r.AllocBytes == r.FreeBytes. These are sites where memory was allocated, but it has all been released back to the runtime.</source>
          <target state="translated">inuseZero가 true 인 경우 프로파일에는 r.AllocBytes&amp;gt; 0이지만 r.AllocBytes == r.FreeBytes 인 할당 레코드가 포함됩니다. 이들은 메모리가 할당 된 사이트이지만 모두 런타임으로 다시 릴리스되었습니다.</target>
        </trans-unit>
        <trans-unit id="892475b4c6ec1f9a63d5df678595d2602a01d9d3" translate="yes" xml:space="preserve">
          <source>If laddr is nil, a local address is automatically chosen. If the IP field of raddr is nil or an unspecified IP address, the local system is assumed.</source>
          <target state="translated">laddr이 nil이면 로컬 주소가 자동으로 선택됩니다. raddr의 IP 필드가 nil이거나 지정되지 않은 IP 주소 인 경우 로컬 시스템이 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="ba24dc1c2b3bf1cedb83b06f2414cb64ac15d1da" translate="yes" xml:space="preserve">
          <source>If laddr is non-nil, it is used as the local address for the connection.</source>
          <target state="translated">laddr이 0이 아닌 경우 연결의 로컬 주소로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9842a555fc5ba63bad435c92db4ce21af1894ec3" translate="yes" xml:space="preserve">
          <source>If level is in the range [-2, 9] then the error returned will be nil. Otherwise the error returned will be non-nil.</source>
          <target state="translated">레벨이 [-2, 9] 범위에 있으면 반환 된 오류는 nil입니다. 그렇지 않으면 반환 된 오류는 0이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="550da103e5e342ac2c8eff3e35ca3b010db8375f" translate="yes" xml:space="preserve">
          <source>If modtime is not the zero time or Unix epoch, ServeContent includes it in a Last-Modified header in the response. If the request includes an If-Modified-Since header, ServeContent uses modtime to decide whether the content needs to be sent at all.</source>
          <target state="translated">modtime이 0 또는 Unix 시대가 아닌 경우 ServeContent는 응답의 Last-Modified 헤더에 포함합니다. 요청에 If-Modified-Since 헤더가 포함 된 경우 ServeContent는 modtime을 사용하여 컨텐츠를 전혀 보내야하는지 여부를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="4498ca26095d9f0afc17fc3d124ee10f9b929767" translate="yes" xml:space="preserve">
          <source>If n &amp;gt; 0, Readdir returns at most n FileInfo structures. In this case, if Readdir returns an empty slice, it will return a non-nil error explaining why. At the end of a directory, the error is io.EOF.</source>
          <target state="translated">n&amp;gt; 0 인 경우 Readdir은 최대 n 개의 FileInfo 구조를 반환합니다. 이 경우 Readdir이 빈 슬라이스를 반환하면 이유를 설명하는 비논리 오류가 반환됩니다. 디렉토리 끝에서 오류는 io.EOF입니다.</target>
        </trans-unit>
        <trans-unit id="fc3b271d5f3a597b07b28cf1083fa8b465cfe35b" translate="yes" xml:space="preserve">
          <source>If n &amp;gt; 0, Readdirnames returns at most n names. In this case, if Readdirnames returns an empty slice, it will return a non-nil error explaining why. At the end of a directory, the error is io.EOF.</source>
          <target state="translated">n&amp;gt; 0이면 Readdirnames는 최대 n 개의 이름을 반환합니다. 이 경우 Readdirnames가 빈 슬라이스를 반환하면 이유를 설명하는 넌이 아닌 오류를 반환합니다. 디렉토리 끝에서 오류는 io.EOF입니다.</target>
        </trans-unit>
        <trans-unit id="eac4c3ba5a8c94ad8cb8a4a397c8ee90135cea13" translate="yes" xml:space="preserve">
          <source>If n &amp;lt;= 0, Readdir returns all the FileInfo from the directory in a single slice. In this case, if Readdir succeeds (reads all the way to the end of the directory), it returns the slice and a nil error. If it encounters an error before the end of the directory, Readdir returns the FileInfo read until that point and a non-nil error.</source>
          <target state="translated">n &amp;lt;= 0 인 경우 Readdir은 디렉토리에서 모든 FileInfo를 단일 슬라이스로 반환합니다. 이 경우 Readdir이 성공하면 (디렉토리 끝까지 읽음) 슬라이스와 nil 오류가 반환됩니다. 디렉토리가 끝나기 전에 오류가 발생하면 Readdir은 해당 시점까지 읽은 FileInfo를 리턴하고 비-논리 오류를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c3cc55f92ff37a98b5144ea82d578410d2c8c458" translate="yes" xml:space="preserve">
          <source>If n &amp;lt;= 0, Readdirnames returns all the names from the directory in a single slice. In this case, if Readdirnames succeeds (reads all the way to the end of the directory), it returns the slice and a nil error. If it encounters an error before the end of the directory, Readdirnames returns the names read until that point and a non-nil error.</source>
          <target state="translated">n &amp;lt;= 0 인 경우 Readdirnames는 디렉토리의 모든 이름을 단일 슬라이스로 반환합니다. 이 경우 Readdirnames가 성공하면 (디렉토리 끝까지 읽음) 슬라이스와 nil 오류가 반환됩니다. 디렉토리가 끝나기 전에 오류가 발생하면 Readdirnames는 해당 시점까지 읽은 이름과 0이 아닌 오류를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="2b903f7cf121247bf3e7b3aca6c7022dbb5df0e4" translate="yes" xml:space="preserve">
          <source>If n &amp;lt;= 0, no idle connections are retained.</source>
          <target state="translated">n &amp;lt;= 0이면 유휴 연결이 유지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="be61ba0537fe2779cebfab91a18a370978aeba0f" translate="yes" xml:space="preserve">
          <source>If n &amp;lt;= 0, then there is no limit on the number of open connections. The default is 0 (unlimited).</source>
          <target state="translated">n &amp;lt;= 0이면 열린 연결 수에 제한이 없습니다. 기본값은 0 (무제한)입니다.</target>
        </trans-unit>
        <trans-unit id="3ffbdba0310e5330b6e39ba21df32f4ec64c1673" translate="yes" xml:space="preserve">
          <source>If name contains no path separators, Command uses LookPath to resolve name to a complete path if possible. Otherwise it uses name directly as Path.</source>
          <target state="translated">name에 경로 구분 기호가 없으면 Command는 LookPath를 사용하여 가능한 경우 이름을 전체 경로로 확인합니다. 그렇지 않으면 이름을 경로로 직접 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e919c20774517f309335e67ee8266068c715cb69" translate="yes" xml:space="preserve">
          <source>If no entry is found, a nil object is returned. In this case, the returned index and indirect values have the following meaning:</source>
          <target state="translated">항목이 없으면 nil 객체가 반환됩니다. 이 경우 반환 된 인덱스 및 간접 값의 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2a51e78e82aff9bdb39269ef8cd918a49b097d8e" translate="yes" xml:space="preserve">
          <source>If opts.Roots is nil and system roots are unavailable the returned error will be of type SystemRootsError.</source>
          <target state="translated">opts.Roots가 nil이고 시스템 루트를 사용할 수없는 경우 리턴 된 오류는 SystemRootsError 유형입니다.</target>
        </trans-unit>
        <trans-unit id="93b29b6dd544ee070bf7867f11c38d0b30ce0f19" translate="yes" xml:space="preserve">
          <source>If p points into an allocated object, it can be advanced through the object by conversion to uintptr, addition of an offset, and conversion back to Pointer.</source>
          <target state="translated">p가 할당 된 객체를 가리키는 경우, uintptr 로의 변환, 오프셋 추가 및 포인터로의 변환으로 객체를 통해 진행될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c4a4899af1972effe20bb6d4fb3e2cc68991f24" translate="yes" xml:space="preserve">
          <source>If pc is not covered by any entry in this line table, SeekPC returns ErrUnknownPC. In this case, *entry and the final seek position are unspecified.</source>
          <target state="translated">pc가이 행 테이블의 항목으로 덮여 있지 않으면 SeekPC는 ErrUnknownPC를 반환합니다. 이 경우, * entry 및 최종 탐색 위치는 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="47b9ebf87a72a4fc29d6e9526a5e472474f83dfe" translate="yes" xml:space="preserve">
          <source>If pc represents multiple functions because of inlining, it returns the a *Func describing the innermost function, but with an entry of the outermost function.</source>
          <target state="translated">pc가 인라인으로 인해 여러 함수를 나타내는 경우 가장 안쪽 함수를 설명하지만 가장 바깥 쪽 함수를 입력하는 * Func를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8759c1ffe2421dc4e493bad121916d1c4a784268" translate="yes" xml:space="preserve">
          <source>If pkg == nil, the Universe scope is used and the provided position pos is ignored. If pkg != nil, and pos is invalid, the package scope is used. Otherwise, pos must belong to the package.</source>
          <target state="translated">pkg == nil이면 유니버스 범위가 사용되며 제공된 위치 pos는 무시됩니다. pkg! = nil이고 pos가 유효하지 않으면 패키지 범위가 사용됩니다. 그렇지 않으면 pos는 패키지에 속해야합니다.</target>
        </trans-unit>
        <trans-unit id="3b501d10f0b3315a0edcb0a3aa0bfa72db3f19b3" translate="yes" xml:space="preserve">
          <source>If pkg was loaded from export data, Imports includes packages that provide package-level objects referenced by pkg. This may be more or less than the set of packages directly imported by pkg's source code.</source>
          <target state="translated">내보내기 데이터에서 pkg가로드 된 경우 가져 오기에는 pkg에서 참조하는 패키지 레벨 오브젝트를 제공하는 패키지가 포함됩니다. 이것은 pkg의 소스 코드에서 직접 가져온 패키지 세트보다 많거나 적을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a13dac68b11bffa0323115aff464b296dab14f09" translate="yes" xml:space="preserve">
          <source>If r and s point to different rings, linking them creates a single ring with the elements of s inserted after r. The result points to the element following the last element of s after insertion.</source>
          <target state="translated">r과 s가 다른 고리를 가리키는 경우, 고리를 연결하면 r 뒤에 s 요소가 삽입 된 단일 고리가 만들어집니다. 결과는 삽입 후 s의 마지막 요소 다음에 오는 요소를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="b045896c9ac0e612d840b26fdcd16f9492dfd688" translate="yes" xml:space="preserve">
          <source>If r and s point to the same ring, linking them removes the elements between r and s from the ring. The removed elements form a subring and the result is a reference to that subring (if no elements were removed, the result is still the original value for r.Next(), and not nil).</source>
          <target state="translated">r과 s가 동일한 고리를 가리키는 경우,이를 연결하면 r과 s 사이의 요소가 고리에서 제거됩니다. 제거 된 요소는 하위 링을 형성하고 결과는 해당 하위 링에 대한 참조입니다 (요소가 제거되지 않은 경우 결과는 여전히 nil이 아닌 r.Next ()의 원래 값임).</target>
        </trans-unit>
        <trans-unit id="8848277c3a29719067a054c042f2cd449fd3596a" translate="yes" xml:space="preserve">
          <source>If rand is not nil then RSA blinding will be used to avoid timing side-channel attacks.</source>
          <target state="translated">랜드가 0이 아닌 경우 RSA 블라 인 딩은 사이드 채널 공격 타이밍을 피하기 위해 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a19e63938d7a0894376439e5599ffa43b250a5d4" translate="yes" xml:space="preserve">
          <source>If rt.RoundTrip returns ErrSkipAltProtocol, the Transport will handle the RoundTrip itself for that one request, as if the protocol were not registered.</source>
          <target state="translated">rt.RoundTrip이 ErrSkipAltProtocol을 리턴하면 전송은 프로토콜이 등록되지 않은 것처럼 해당 요청에 대한 RoundTrip 자체를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="54ad40399e089deda52c88ae3ba4659988c86560" translate="yes" xml:space="preserve">
          <source>If s does not contain sep and sep is not empty, Split returns a slice of length 1 whose only element is s.</source>
          <target state="translated">s에 sep가없고 sep가 비어 있지 않은 경우 Split는 요소가 s 인 길이 1의 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9daee5dcf8a47681ddd5e5f835fb1dbed1f83aea" translate="yes" xml:space="preserve">
          <source>If s does not contain sep and sep is not empty, SplitAfter returns a slice of length 1 whose only element is s.</source>
          <target state="translated">s에 sep가없고 sep가 비어 있지 않으면 SplitAfter는 요소가 s 인 길이 1의 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="95759bb8e19ebcbb98672ac7fdd18943d4708775" translate="yes" xml:space="preserve">
          <source>If s is not syntactically well-formed, ParseFloat returns err.Err = ErrSyntax.</source>
          <target state="translated">s 구문이 제대로 구성되지 않은 경우 ParseFloat는 err.Err = ErrSyntax를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3e257c93b527ddb828e688937de0ccc11edf5f79" translate="yes" xml:space="preserve">
          <source>If s is syntactically well-formed but is more than 1/2 ULP away from the largest floating point number of the given size, ParseFloat returns f = &amp;plusmn;Inf, err.Err = ErrRange.</source>
          <target state="translated">s의 구문이 올바르게 구성되었지만 주어진 크기의 최대 부동 소수점 수에서 1/2 ULP 이상 떨어져 있으면 ParseFloat는 f = &amp;plusmn; Inf, err.Err = ErrRange를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2958c3475b5e1c01d3ef1742914960b9002f7a9e" translate="yes" xml:space="preserve">
          <source>If sec &amp;gt; 0, the data is sent in the background as with sec &amp;lt; 0. On some operating systems after sec seconds have elapsed any remaining unsent data may be discarded.</source>
          <target state="translated">sec&amp;gt; 0이면 sec &amp;lt;0과 같이 백그라운드로 데이터가 전송됩니다. sec 초 후에 일부 운영 체제에서 남아있는 전송되지 않은 데이터는 버려 질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f56f69cce6422c40a21ab01c5418cdbd4bf77063" translate="yes" xml:space="preserve">
          <source>If sec &amp;lt; 0 (the default), the operating system finishes sending the data in the background.</source>
          <target state="translated">sec &amp;lt;0 (기본값)이면 운영 체제가 백그라운드에서 데이터 전송을 완료합니다.</target>
        </trans-unit>
        <trans-unit id="d8d3489dffe9a7fe6c9ad9a620bad31395af4507" translate="yes" xml:space="preserve">
          <source>If sec == 0, the operating system discards any unsent or unacknowledged data.</source>
          <target state="translated">sec == 0 인 경우 운영 체제는 보내지 않거나 확인되지 않은 데이터를 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="be66aebe1a8866a8f4dc281f1bd57616b1f982bc" translate="yes" xml:space="preserve">
          <source>If sep is empty, Split splits after each UTF-8 sequence. If both s and sep are empty, Split returns an empty slice.</source>
          <target state="translated">sep가 비어 있으면 Split은 각 UTF-8 시퀀스 후에 분할됩니다. s와 sep가 모두 비어 있으면 Split은 빈 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="489ca1eca08b1f0a405730583d47d533fb4b076e" translate="yes" xml:space="preserve">
          <source>If sep is empty, SplitAfter splits after each UTF-8 sequence. If both s and sep are empty, SplitAfter returns an empty slice.</source>
          <target state="translated">sep가 비어 있으면 SplitAfter는 각 UTF-8 시퀀스 후에 분할됩니다. s와 sep가 모두 비어 있으면 SplitAfter는 빈 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2a3657d8164caf54f78f733fc8ef2ecda3905624" translate="yes" xml:space="preserve">
          <source>If src != nil, ParseFile parses the source from src and the filename is only used when recording position information. The type of the argument for the src parameter must be string, []byte, or io.Reader. If src == nil, ParseFile parses the file specified by filename.</source>
          <target state="translated">src! = nil 인 경우 ParseFile은 src에서 소스를 구문 분석하고 파일 이름은 위치 정보를 기록 할 때만 사용됩니다. src 매개 변수의 인수 유형은 문자열, [] byte 또는 io.Reader 여야합니다. src == nil이면 ParseFile은 filename으로 지정된 파일을 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="fe8d7fb1ea6082771e2bec41671407fae46d618e" translate="yes" xml:space="preserve">
          <source>If src implements the WriterTo interface, the copy is implemented by calling src.WriteTo(dst). Otherwise, if dst implements the ReaderFrom interface, the copy is implemented by calling dst.ReadFrom(src).</source>
          <target state="translated">src가 WriterTo 인터페이스를 구현하면 복사는 src.WriteTo (dst)를 호출하여 구현됩니다. 그렇지 않으면 dst가 ReaderFrom 인터페이스를 구현하면 dst.ReadFrom (src)를 호출하여 사본이 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="e40b342e6817ab9c3ac4432d840f11c1f0b22325" translate="yes" xml:space="preserve">
          <source>If src is a partial source file, the leading and trailing space of src is applied to the result (such that it has the same leading and trailing space as src), and the result is indented by the same amount as the first line of src containing code. Imports are not sorted for partial source files.</source>
          <target state="translated">src가 부분 소스 파일 인 경우, src의 선행 및 후행 공간이 결과에 적용되며 (src와 동일한 선행 및 후행 공간을 갖도록) 결과는 src의 첫 번째 행과 동일한 양으로 들여 쓰기됩니다. 코드를 포함합니다. 부분 소스 파일에 대한 가져 오기는 정렬되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7c67bad25cffc131c00d1eef36d585ec638c9170" translate="yes" xml:space="preserve">
          <source>If srv.Addr is blank, &quot;:http&quot; is used.</source>
          <target state="translated">srv.Addr이 비어 있으면 &quot;: http&quot;가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f9e50e1a49136013b88aa780931a141882ea6f39" translate="yes" xml:space="preserve">
          <source>If srv.Addr is blank, &quot;:https&quot; is used.</source>
          <target state="translated">srv.Addr이 비어 있으면 &quot;: https&quot;가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ad0892d319e6dc448b8b5b8890782a44c3d82311" translate="yes" xml:space="preserve">
          <source>If successful, tmpl will now be injection-safe. Otherwise, err is an error defined in the docs for ErrorCode.</source>
          <target state="translated">성공하면 tmpl은 이제 사출 안전합니다. 그렇지 않으면, err은 ErrorCode에 대한 문서에 정의 된 오류입니다.</target>
        </trans-unit>
        <trans-unit id="178b407eef387370d388c8cfe01edb64789c6b52" translate="yes" xml:space="preserve">
          <source>If the Client's Transport does not have a CloseIdleConnections method then this method does nothing.</source>
          <target state="translated">클라이언트의 Transport에 CloseIdleConnections 메소드가없는 경우,이 메소드는 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a2836eacebc948128e4aa3ce4d8b1d3fc7d6a477" translate="yes" xml:space="preserve">
          <source>If the Content-Type header has not been set, Redirect sets it to &quot;text/html; charset=utf-8&quot; and writes a small HTML body. Setting the Content-Type header to any value, including nil, disables that behavior.</source>
          <target state="translated">Content-Type 헤더가 설정되지 않은 경우 Redirect는 헤더를 &quot;text / html; charset = utf-8&quot;로 설정하고 작은 HTML 본문을 작성합니다. Content-Type 헤더를 nil을 포함한 모든 값으로 설정하면 해당 동작이 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="3ae6135ca1107639811cd5daef71ae7fca79e2f6" translate="yes" xml:space="preserve">
          <source>If the Context field is 0, the context function is being called to record the current traceback context. It should record in the Context field whatever information is needed about the current point of execution to later produce a stack trace, probably the stack pointer and PC. In this case the context function will be called from C code.</source>
          <target state="translated">컨텍스트 필드가 0 인 경우, 현재 역 추적 컨텍스트를 기록하기 위해 컨텍스트 함수가 호출됩니다. 나중에 스택 추적, 아마도 스택 포인터와 PC를 생성하기 위해 현재 실행 지점에 필요한 정보를 컨텍스트 필드에 기록해야합니다. 이 경우 컨텍스트 함수는 C 코드에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="42011269501bbfe9917fe4565b51ba6a042b7ead" translate="yes" xml:space="preserve">
          <source>If the Context field is not 0, then it is a value returned by a previous call to the context function. This case is called when the context is no longer needed; that is, when the Go code is returning to its C code caller. This permits the context function to release any associated resources.</source>
          <target state="translated">컨텍스트 필드가 0이 아닌 경우, 컨텍스트 함수에 대한 이전 호출에서 리턴 된 값입니다. 컨텍스트가 더 이상 필요하지 않을 때 호출됩니다. 즉, Go 코드가 C 코드 호출자에게 리턴 될 때입니다. 이를 통해 컨텍스트 기능이 연관된 자원을 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="084a8ea923e025ba6d8130824462ac823dad2f19" translate="yes" xml:space="preserve">
          <source>If the Delta field of a CaseRange is UpperLower, it means this CaseRange represents a sequence of the form (say) Upper Lower Upper Lower.</source>
          <target state="translated">CaseRange의 델타 필드가 UpperLower 인 경우,이 CaseRange는 양식의 순서 (예 : Upper Lower Upper Lower)를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="99155dad735e31c1f83383d55994a89a1d5b0d8e" translate="yes" xml:space="preserve">
          <source>If the Go program is started with a non-empty signal mask, that will generally be honored. However, some signals are explicitly unblocked: the synchronous signals, SIGILL, SIGTRAP, SIGSTKFLT, SIGCHLD, SIGPROF, and, on GNU/Linux, signals 32 (SIGCANCEL) and 33 (SIGSETXID) (SIGCANCEL and SIGSETXID are used internally by glibc). Subprocesses started by os.Exec, or by the os/exec package, will inherit the modified signal mask.</source>
          <target state="translated">비어 있지 않은 신호 마스크로 Go 프로그램을 시작하면 일반적으로 적용됩니다. 그러나 동기 신호, SIGILL, SIGTRAP, SIGSTKFLT, SIGCHLD, SIGPROF 및 GNU / Linux에서는 신호 32 (SIGCANCEL) 및 33 (SIGSETXID) (SIGCANCEL 및 SIGSETXID가 내부적으로 glibc에 의해 사용됨) 인 일부 신호가 명시 적으로 차단 해제됩니다. os.Exec 또는 os / exec 패키지로 시작된 하위 프로세스는 수정 된 신호 마스크를 상속합니다.</target>
        </trans-unit>
        <trans-unit id="9a19e7607fdf15201f487fc6adac4a654bb31d6b" translate="yes" xml:space="preserve">
          <source>If the Go program is started with either SIGHUP or SIGINT ignored (signal handler set to SIG_IGN), they will remain ignored.</source>
          <target state="translated">SIGHUP 또는 SIGINT를 무시하고 (신호 핸들러가 SIG_IGN으로 설정 됨) Go 프로그램을 시작한 경우 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="bb2401bc392b8c040ae8577c33db0583e1939491" translate="yes" xml:space="preserve">
          <source>If the Go runtime sees an existing signal handler for the SIGCANCEL or SIGSETXID signals (which are used only on GNU/Linux), it will turn on the SA_ONSTACK flag and otherwise keep the signal handler.</source>
          <target state="translated">Go 런타임에서 SIGCANCEL 또는 SIGSETXID 신호 (GNU / Linux에서만 사용됨)에 대한 기존 신호 처리기를 발견하면 SA_ONSTACK 플래그를 켜고 신호 처리기를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="b8c9bbe3199fe348a3ebb3c33bad8f777f2557ca" translate="yes" xml:space="preserve">
          <source>If the Go signal handler is invoked on a non-Go thread not running Go code, the handler generally forwards the signal to the non-Go code, as follows. If the signal is SIGPROF, the Go handler does nothing. Otherwise, the Go handler removes itself, unblocks the signal, and raises it again, to invoke any non-Go handler or default system handler. If the program does not exit, the Go handler then reinstalls itself and continues execution of the program.</source>
          <target state="translated">Go 신호 핸들러가 Go 코드를 실행하지 않는 비 Go 스레드에서 호출되는 경우 핸들러는 일반적으로 다음과 같이 신호를 비 Go 코드로 전달합니다. 신호가 SIGPROF 인 경우 Go 핸들러는 아무 작업도 수행하지 않습니다. 그렇지 않으면 Go 핸들러가 자체를 제거하고 신호를 차단 해제 한 후 다시 올려서 Go 이외의 핸들러 또는 기본 시스템 핸들러를 호출합니다. 프로그램이 종료되지 않으면 Go 핸들러가 다시 설치되고 프로그램 실행을 계속합니다.</target>
        </trans-unit>
        <trans-unit id="d1450a83e799c9f838308f1831ad2410ca5837bc" translate="yes" xml:space="preserve">
          <source>If the IP field of laddr is nil or an unspecified IP address, ListenIP listens on all available IP addresses of the local system except multicast IP addresses.</source>
          <target state="translated">laddr의 IP 필드가 nil이거나 지정되지 않은 IP 주소 인 경우 ListenIP는 멀티 캐스트 IP 주소를 제외하고 로컬 시스템의 사용 가능한 모든 IP 주소에서 청취합니다.</target>
        </trans-unit>
        <trans-unit id="af82767d02391b6e900db2816b87a4fb9f84a234" translate="yes" xml:space="preserve">
          <source>If the IP field of laddr is nil or an unspecified IP address, ListenTCP listens on all available unicast and anycast IP addresses of the local system. If the Port field of laddr is 0, a port number is automatically chosen.</source>
          <target state="translated">laddr의 IP 필드가 nil이거나 지정되지 않은 IP 주소 인 경우 ListenTCP는 로컬 시스템의 사용 가능한 모든 유니 캐스트 및 애니 캐스트 IP 주소를 수신합니다. laddr의 포트 필드가 0이면 포트 번호가 자동으로 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="af86e9317bf51d088cb071c3ee8a01bff50d7b6b" translate="yes" xml:space="preserve">
          <source>If the IP field of laddr is nil or an unspecified IP address, ListenUDP listens on all available IP addresses of the local system except multicast IP addresses. If the Port field of laddr is 0, a port number is automatically chosen.</source>
          <target state="translated">laddr의 IP 필드가 nil이거나 지정되지 않은 IP 주소 인 경우 ListenUDP는 멀티 캐스트 IP 주소를 제외하고 로컬 시스템의 사용 가능한 모든 IP 주소에서 청취합니다. laddr의 포트 필드가 0이면 포트 번호가 자동으로 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="5b648936c52bc2fbcc7b753478ee856cc09da205" translate="yes" xml:space="preserve">
          <source>If the XML name for a struct field is defined by both the field tag and the struct's XMLName field, the names must match.</source>
          <target state="translated">구조체 필드의 XML 이름이 필드 태그와 구조체의 XMLName 필드 모두에 의해 정의 된 경우 이름이 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="3ef1f744f6bc6158c837d3a4a05d2dd7419e3d5c" translate="yes" xml:space="preserve">
          <source>If the caller has set w's ETag header formatted per RFC 7232, section 2.3, ServeContent uses it to handle requests using If-Match, If-None-Match, or If-Range.</source>
          <target state="translated">발신자가 RFC 7232, 섹션 2.3에 따라 형식화 된 w의 ETag 헤더를 설정 한 경우 ServeContent는이를 사용하여 If-Match, If-None-Match 또는 If-Range를 사용하여 요청을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="7fe34f55752121c99936b8403a6063a8914cb06e" translate="yes" xml:space="preserve">
          <source>If the calling goroutine has locked the operating system thread with runtime.LockOSThread and modified any inheritable OS-level thread state (for example, Linux or Plan 9 name spaces), the new process will inherit the caller's thread state.</source>
          <target state="translated">호출 goroutine이 runtime.LockOST로 운영 체제 스레드를 잠근 경우 상속 가능한 OS 레벨 스레드 상태 (예 : Linux 또는 Plan 9 네임 스페이스)를 읽고 수정하면 새 프로세스는 호출자의 스레드 상태를 상속합니다.</target>
        </trans-unit>
        <trans-unit id="259a07efdd482c1e280dc36d61c76b7e373057fb" translate="yes" xml:space="preserve">
          <source>If the command fails to run or doesn't complete successfully, the error is of type *ExitError. Other error types may be returned for I/O problems.</source>
          <target state="translated">명령이 실행되지 않거나 완료되지 않으면 오류는 * ExitError입니다. I / O 문제에 대해서는 다른 오류 유형이 반환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b33403be418b27f91a2d42d554ef5c02f7c63947" translate="yes" xml:space="preserve">
          <source>If the command starts but does not complete successfully, the error is of type *ExitError. Other error types may be returned for other situations.</source>
          <target state="translated">명령이 시작되었지만 성공적으로 완료되지 않으면 오류는 * ExitError입니다. 다른 상황에서는 다른 오류 유형이 반환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a122d2b8c97a37a880702f2a3fbe016e3749fd3" translate="yes" xml:space="preserve">
          <source>If the current file is sparse, then the regions marked as a hole are read back as NUL-bytes.</source>
          <target state="translated">현재 파일이 드문 경우 홀로 표시된 영역을 NUL 바이트로 다시 읽습니다.</target>
        </trans-unit>
        <trans-unit id="6253658c1bbbfe0517d9a4b3227473cd894d597c" translate="yes" xml:space="preserve">
          <source>If the directory couldn't be read, a nil map and the respective error are returned. If a parse error occurred, a non-nil but incomplete map and the first error encountered are returned.</source>
          <target state="translated">디렉토리를 읽을 수 없으면 nil 맵과 해당 오류가 리턴됩니다. 구문 분석 오류가 발생하면 0이 아닌 완료되지 않은 맵과 첫 번째 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="01b40bd5ac5583f9db3311853c6994966859d236" translate="yes" xml:space="preserve">
          <source>If the driver supports cursors, a returned Value may also implement the Rows interface in this package. This is used, for example, when a user selects a cursor such as &quot;select cursor(select * from my_table) from dual&quot;. If the Rows from the select is closed, the cursor Rows will also be closed.</source>
          <target state="translated">드라이버가 커서를 지원하는 경우 반환 된 Value는이 패키지에서 Rows 인터페이스를 구현할 수도 있습니다. 예를 들어, 사용자가 &quot;듀얼에서 커서 선택 (select * from my_table)&quot;과 같은 커서를 선택할 때 사용됩니다. 선택에서 행이 닫히면 커서 행도 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="cf50ebb80b297da2b505a620be031cb25dcead76" translate="yes" xml:space="preserve">
          <source>If the format (which is implicitly %v for Println etc.) is valid for a string (%s %q %v %x %X), the following two rules apply:</source>
          <target state="translated">형식 (Println 등에 암시 적으로 % v 임)이 문자열 (% s % q % v % x % X)에 유효한 경우 다음 두 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="0f42e25dba03dca0e51f87ed12e981c71373e332" translate="yes" xml:space="preserve">
          <source>If the format specifier includes a %w verb with an error operand, the returned error will implement an Unwrap method returning the operand. It is invalid to include more than one %w verb or to supply it with an operand that does not implement the error interface. The %w verb is otherwise a synonym for %v.</source>
          <target state="translated">형식 지정자가 오류 피연산자와 함께 % w 동사를 포함하는 경우 반환 된 오류는 피연산자를 반환하는 Unwrap 메서드를 구현합니다. 동사를 둘 이상 포함하거나 오류 인터페이스를 구현하지 않는 피연산자를 제공하는 것은 유효하지 않습니다. 그렇지 않으면 % w 동사는 % v와 동의어입니다.</target>
        </trans-unit>
        <trans-unit id="b70a519f0eee1914e654572a47f9ae5a7a8a3889" translate="yes" xml:space="preserve">
          <source>If the host in the address parameter is not a literal IP address or the port is not a literal port number, ResolveTCPAddr resolves the address to an address of TCP end point. Otherwise, it parses the address as a pair of literal IP address and port number. The address parameter can use a host name, but this is not recommended, because it will return at most one of the host name's IP addresses.</source>
          <target state="translated">address 매개 변수의 호스트가 리터럴 IP 주소가 아니거나 포트가 리터럴 포트 번호가 아닌 경우 ResolveTCPAddr은 주소를 TCP 엔드 포인트의 주소로 분석합니다. 그렇지 않으면 주소를 리터럴 IP 주소와 포트 번호 쌍으로 구문 분석합니다. address 매개 변수는 호스트 이름을 사용할 수 있지만 호스트 이름의 IP 주소 중 최대 하나를 리턴하므로 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="60603d4b10b0e1d0e446fdae0a4a44c25a6c45b7" translate="yes" xml:space="preserve">
          <source>If the host in the address parameter is not a literal IP address or the port is not a literal port number, ResolveUDPAddr resolves the address to an address of UDP end point. Otherwise, it parses the address as a pair of literal IP address and port number. The address parameter can use a host name, but this is not recommended, because it will return at most one of the host name's IP addresses.</source>
          <target state="translated">address 매개 변수의 호스트가 리터럴 IP 주소가 아니거나 포트가 리터럴 포트 번호가 아닌 경우 ResolveUDPAddr은 주소를 UDP 엔드 포인트의 주소로 분석합니다. 그렇지 않으면 주소를 리터럴 IP 주소와 포트 번호 쌍으로 구문 분석합니다. address 매개 변수는 호스트 이름을 사용할 수 있지만 호스트 이름의 IP 주소 중 최대 하나를 리턴하므로 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cd0fc2990a9a9cf8fad81f64436555d3d6b35355" translate="yes" xml:space="preserve">
          <source>If the host in the address parameter is not a literal IP address, ResolveIPAddr resolves the address to an address of IP end point. Otherwise, it parses the address as a literal IP address. The address parameter can use a host name, but this is not recommended, because it will return at most one of the host name's IP addresses.</source>
          <target state="translated">address 매개 변수의 호스트가 리터럴 IP 주소가 아닌 경우 ResolveIPAddr은 주소를 IP 엔드 포인트의 주소로 분석합니다. 그렇지 않으면 주소를 리터럴 IP 주소로 구문 분석합니다. address 매개 변수는 호스트 이름을 사용할 수 있지만 호스트 이름의 IP 주소 중 최대 하나를 리턴하므로 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="199da3dce7215d4cebc5f4fd0619e8dbc8fd6d9d" translate="yes" xml:space="preserve">
          <source>If the key type is not a valid map key type (that is, if it does not implement Go's == operator), MapOf panics.</source>
          <target state="translated">키 유형이 유효한 맵 키 유형이 아닌 경우 (즉, Go의 == 연산자를 구현하지 않은 경우) MapOf는 패닉 상태입니다.</target>
        </trans-unit>
        <trans-unit id="fdcae4b6d304718d87888a4b14792a984d6db584" translate="yes" xml:space="preserve">
          <source>If the location cannot be determined (for example, $HOME is not defined), then it will return an error.</source>
          <target state="translated">위치를 판별 할 수없는 경우 (예 : $ HOME이 정의되지 않은 경우) 오류를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="83fc45c3d88185bce6b913b6fba87e76a3564c14" translate="yes" xml:space="preserve">
          <source>If the n = len(p) bytes returned by ReadAt are at the end of the input source, ReadAt may return either err == EOF or err == nil.</source>
          <target state="translated">ReadAt에 의해 반환 된 n = len (p) 바이트가 입력 소스의 끝에있는 경우 ReadAt은 err == EOF 또는 err == nil을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96928e9a3e37cddefc97fd6808cb69e209a645f8" translate="yes" xml:space="preserve">
          <source>If the name is &quot;&quot; or &quot;UTC&quot;, LoadLocation returns UTC. If the name is &quot;Local&quot;, LoadLocation returns Local.</source>
          <target state="translated">이름이 &quot;&quot;또는 &quot;UTC&quot;이면 LoadLocation은 UTC를 반환합니다. 이름이 &quot;Local&quot;이면 LoadLocation은 Local을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="71bd5d676aea790d3104c9356a66a88a54f27219" translate="yes" xml:space="preserve">
          <source>If the non-Go code called by the Go program does not change any signal handlers or masks, then the behavior is the same as for a pure Go program.</source>
          <target state="translated">Go 프로그램에서 호출 한 비 Go 코드가 신호 처리기 또는 마스크를 변경하지 않으면 동작은 순수한 Go 프로그램과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="7ff28c4dacda2b677d57a006ed06c589035c4906" translate="yes" xml:space="preserve">
          <source>If the non-Go code installs a signal handler for any of the asynchronous signals, it may invoke the Go signal handler or not as it chooses. Naturally, if it does not invoke the Go signal handler, the Go behavior described above will not occur. This can be an issue with the SIGPROF signal in particular.</source>
          <target state="translated">비 Go 코드가 비동기 신호에 대한 신호 처리기를 설치하면 Go 신호 처리기를 호출하거나 선택하지 않을 수 있습니다. 당연히 Go 신호 처리기를 호출하지 않으면 위에서 설명한 Go 동작이 발생하지 않습니다. 이것은 특히 SIGPROF 신호에 문제가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="abd2048f2311a9e6d64b579961e64f72d37d33a6" translate="yes" xml:space="preserve">
          <source>If the non-Go code installs a signal handler for any of the synchronous signals (SIGBUS, SIGFPE, SIGSEGV), then it should record the existing Go signal handler. If those signals occur while executing Go code, it should invoke the Go signal handler (whether the signal occurs while executing Go code can be determined by looking at the PC passed to the signal handler). Otherwise some Go run-time panics will not occur as expected.</source>
          <target state="translated">비 Go 코드가 동기 신호 (SIGBUS, SIGFPE, SIGSEGV) 중 하나에 대한 신호 처리기를 설치하는 경우 기존 Go 신호 처리기를 기록해야합니다. Go 코드를 실행하는 동안 이러한 신호가 발생하면 Go 신호 처리기를 호출해야합니다 (Go 코드를 실행하는 동안 신호 발생 여부는 신호 처리기에 전달 된 PC를 통해 확인할 수 있음). 그렇지 않으면 일부 Go 런타임 패닉이 예상대로 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bb19b115a2d359b987ea5bcb60343aca9ae430dd" translate="yes" xml:space="preserve">
          <source>If the non-Go code installs any signal handlers, it must use the SA_ONSTACK flag with sigaction. Failing to do so is likely to cause the program to crash if the signal is received. Go programs routinely run with a limited stack, and therefore set up an alternate signal stack. Also, the Go standard library expects that any signal handlers will use the SA_RESTART flag. Failing to do so may cause some library calls to return &quot;interrupted system call&quot; errors.</source>
          <target state="translated">비 Go 코드가 신호 핸들러를 설치하는 경우 sigaction과 함께 SA_ONSTACK 플래그를 사용해야합니다. 그렇지 않으면 신호가 수신되면 프로그램이 중단 될 수 있습니다. Go 프로그램은 정기적으로 제한된 스택으로 실행되므로 대체 신호 스택을 설정합니다. 또한 Go 표준 라이브러리는 모든 신호 핸들러가 SA_RESTART 플래그를 사용할 것으로 예상합니다. 그렇지 않으면 일부 라이브러리 호출에서 &quot;인터럽트 된 시스템 호출&quot;오류가 리턴 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e1d203998def7d0f58007e88176f92e21a64b50" translate="yes" xml:space="preserve">
          <source>If the non-Go code starts a new thread, changes the signal mask, and then invokes a Go function in that thread, the Go runtime will automatically unblock certain signals: the synchronous signals, SIGILL, SIGTRAP, SIGSTKFLT, SIGCHLD, SIGPROF, SIGCANCEL, and SIGSETXID. When the Go function returns, the non-Go signal mask will be restored.</source>
          <target state="translated">비 Go 코드가 새 스레드를 시작하고 신호 마스크를 변경 한 다음 해당 스레드에서 Go 함수를 호출하면 Go 런타임이 특정 신호를 자동으로 차단 해제합니다. 동기 신호, SIGILL, SIGTRAP, SIGSTKFLT, SIGCHLD, SIGPROLD, SIGCANCEL 및 SIGSETXID. Go 기능이 반환되면 비 Go 신호 마스크가 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="91074ebc7a3334ebd4f37cdfabaa9ca32fd24f74" translate="yes" xml:space="preserve">
          <source>If the open fails, the error string will be self-explanatory, like</source>
          <target state="translated">열기에 실패하면 오류 문자열은 설명이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="54fcc24f407eeb4900b5f210d5d49a96c53bb1c9" translate="yes" xml:space="preserve">
          <source>If the prefix of the status does not match the digits in expectCode, ReadCodeLine returns with err set to &amp;amp;Error{code, message}. For example, if expectCode is 31, an error will be returned if the status is not in the range [310,319].</source>
          <target state="translated">상태의 접 두부가 expectCode의 숫자와 일치하지 않으면 ReadCodeLine은 err을 &amp;amp; Error {code, message}로 설정하여 리턴합니다. 예를 들어 expectCode가 31 인 경우 상태가 [310,319] 범위에 있지 않으면 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="86837437a16860a8105279be00bffc491da5bba2" translate="yes" xml:space="preserve">
          <source>If the prefix of the status does not match the digits in expectCode, ReadResponse returns with err set to &amp;amp;Error{code, message}. For example, if expectCode is 31, an error will be returned if the status is not in the range [310,319].</source>
          <target state="translated">상태의 접 두부가 expectCode의 숫자와 일치하지 않으면 ReadResponse는 err을 &amp;amp; Error {code, message}로 설정하여 리턴합니다. 예를 들어 expectCode가 31 인 경우 상태가 [310,319] 범위에 있지 않으면 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="5ebf5ba32952d52f53e121ccb89f42cb9010f630" translate="yes" xml:space="preserve">
          <source>If the program has called Notify to receive SIGPIPE signals, the file descriptor number does not matter. The SIGPIPE signal will be delivered to the Notify channel, and the write will fail with an EPIPE error.</source>
          <target state="translated">프로그램이 SIGPIPE 신호를 수신하기 위해 Notify를 호출 한 경우 파일 디스크립터 번호는 중요하지 않습니다. SIGPIPE 신호가 Notify 채널로 전달되고 EPIPE 오류와 함께 쓰기가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="7cf239f9c12fb938b9596c568e4f45900dce20bb" translate="yes" xml:space="preserve">
          <source>If the program has not called Notify to receive SIGPIPE signals, then the behavior depends on the file descriptor number. A write to a broken pipe on file descriptors 1 or 2 (standard output or standard error) will cause the program to exit with a SIGPIPE signal. A write to a broken pipe on some other file descriptor will take no action on the SIGPIPE signal, and the write will fail with an EPIPE error.</source>
          <target state="translated">프로그램이 SIGPIPE 신호를 수신하기 위해 Notify를 호출하지 않은 경우, 파일 디스크립터 번호에 따라 동작이 달라집니다. 파일 디스크립터 1 또는 2 (표준 출력 또는 표준 오류)에서 손상된 파이프에 쓰면 프로그램이 SIGPIPE 신호와 함께 종료됩니다. 다른 파일 디스크립터에서 끊어진 파이프에 대한 쓰기는 SIGPIPE 신호에 대해 조치를 취하지 않으며 EPIPE 오류와 함께 쓰기에 실패합니다.</target>
        </trans-unit>
        <trans-unit id="111ef080bfe5d9de228261353c72d73b391743f0" translate="yes" xml:space="preserve">
          <source>If the program is started with a non-empty signal mask, some signals will be explicitly unblocked as described above. If Notify is called for a blocked signal, it will be unblocked. If, later, Reset is called for that signal, or Stop is called on all channels passed to Notify for that signal, the signal will once again be blocked.</source>
          <target state="translated">비어 있지 않은 신호 마스크로 프로그램을 시작하면 위에서 설명한 것처럼 일부 신호가 명시 적으로 차단 해제됩니다. 차단 된 신호에 대해 알림이 호출되면 차단 해제됩니다. 나중에 해당 신호에 대해 Reset이 호출되거나 해당 신호에 대해 Notify로 전달 된 모든 채널에서 Stop이 호출되면 신호가 다시 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="6b4f665c5cfb9144d49b7e1dcb5bc2df2bfa007a" translate="yes" xml:space="preserve">
          <source>If the program was started with SIGHUP or SIGINT ignored, and Notify is called for either signal, a signal handler will be installed for that signal and it will no longer be ignored. If, later, Reset or Ignore is called for that signal, or Stop is called on all channels passed to Notify for that signal, the signal will once again be ignored. Reset will restore the system default behavior for the signal, while Ignore will cause the system to ignore the signal entirely.</source>
          <target state="translated">SIGHUP 또는 SIGINT를 사용하여 프로그램을 시작하고 신호 중 하나에 대해 Notify를 호출하면 해당 신호에 대해 신호 처리기가 설치되고 더 이상 무시되지 않습니다. 나중에 해당 신호에 대해 Reset 또는 Ignore가 호출되거나 해당 신호에 대해 Notify에 전달 된 모든 채널에서 Stop이 호출되면 신호가 다시 무시됩니다. Reset은 신호에 대한 시스템 기본 동작을 복원하는 반면 Ignore는 시스템이 신호를 완전히 무시하게합니다.</target>
        </trans-unit>
        <trans-unit id="a50b71ad5f04ba376647400ad12d829202f07d7f" translate="yes" xml:space="preserve">
          <source>If the provided body is also an io.Closer, the returned Request.Body is set to body and will be closed by the Client methods Do, Post, and PostForm, and Transport.RoundTrip.</source>
          <target state="translated">제공된 본문이 io.Closer 인 경우 리턴 된 Request.Body가 본문으로 설정되며 클라이언트 메소드 Do, Post 및 PostForm 및 Transport.RoundTrip에 의해 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="a90f0974cd32b46dcc6c15c91f94c9f93252ae8b" translate="yes" xml:space="preserve">
          <source>If the provided body is an io.Closer, it is closed after the request.</source>
          <target state="translated">제공된 바디가 io.Closer이면 요청 후 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="76a4a3b11148dd18ae8c95298059edf28df076dc" translate="yes" xml:space="preserve">
          <source>If the provided file or directory name is a relative path, it is interpreted relative to the current directory and may ascend to parent directories. If the provided name is constructed from user input, it should be sanitized before calling ServeFile.</source>
          <target state="translated">제공된 파일 또는 디렉토리 이름이 상대 경로 인 경우 현재 디렉토리를 기준으로 해석되며 상위 디렉토리로 올라갈 수 있습니다. 제공된 이름이 사용자 입력으로 구성된 경우 ServeFile을 호출하기 전에 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="4e3cf22a6ffbc844d8cc7293fe5c88e56a31e62d" translate="yes" xml:space="preserve">
          <source>If the provided result precision is 0 (see below), it is set to the precision of the argument with the largest precision value before any rounding takes place, and the rounding mode remains unchanged. Thus, uninitialized Floats provided as result arguments will have their precision set to a reasonable value determined by the operands, and their mode is the zero value for RoundingMode (ToNearestEven).</source>
          <target state="translated">제공된 결과 정밀도가 0이면 (아래 참조) 반올림이 발생하기 전에 가장 큰 정밀도 값을 가진 인수의 정밀도로 설정되며 반올림 모드는 변경되지 않습니다. 따라서 결과 인수로 제공된 초기화되지 않은 Float는 정밀도가 피연산자에 의해 결정된 합리적인 값으로 설정되며 해당 모드는 RoundingMode (ToNearestEven)의 0 값입니다.</target>
        </trans-unit>
        <trans-unit id="2b88a75837ac44c3ec57492aadd63fbc336940cb" translate="yes" xml:space="preserve">
          <source>If the request Body's size has not already been limited by MaxBytesReader, the size is capped at 10MB.</source>
          <target state="translated">요청 본문의 크기가 MaxBytesReader에 의해 아직 제한되지 않은 경우 크기는 10MB로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="202ca334b5c1306191933ea4f4be7458350d5dde" translate="yes" xml:space="preserve">
          <source>If the response is multi-line, ReadCodeLine returns an error.</source>
          <target state="translated">응답이 여러 줄이면 ReadCodeLine은 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cca7e3754527e1fa0174f20268f5f2115cb686b6" translate="yes" xml:space="preserve">
          <source>If the response's Content-Type header is not set, ServeContent first tries to deduce the type from name's file extension and, if that fails, falls back to reading the first block of the content and passing it to DetectContentType. The name is otherwise unused; in particular it can be empty and is never sent in the response.</source>
          <target state="translated">응답의 Content-Type 헤더가 설정되어 있지 않으면 ServeContent는 먼저 이름의 파일 확장자에서 유형을 추론하려고 시도하고, 실패하면 내용의 첫 번째 블록을 읽고 DetectContentType으로 전달합니다. 그렇지 않으면 이름이 사용되지 않습니다. 특히 비어있을 수 있으며 응답으로 전송되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4adb610dc4446d1c29fb56aaef6e5c8a55dbd30c" translate="yes" xml:space="preserve">
          <source>If the result is enclosed in square brackets, as literal IPv6 addresses are, the square brackets are removed from the result.</source>
          <target state="translated">리터럴 IPv6 주소와 같이 결과가 대괄호로 묶인 경우 결과에서 대괄호가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="46d8ee162d5e124f43ba34e4b526da01d3ba6f66" translate="yes" xml:space="preserve">
          <source>If the result of this process is an empty string, Clean returns the string &quot;.&quot;.</source>
          <target state="translated">이 프로세스의 결과가 빈 문자열이면 Clean은 &quot;.&quot;문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="63039cb93ec1523520a70aa02f8add44a72d2dcc" translate="yes" xml:space="preserve">
          <source>If the resulting type would be larger than the available address space, ArrayOf panics.</source>
          <target state="translated">결과 유형이 사용 가능한 주소 공간보다 클 경우 ArrayOf panics.</target>
        </trans-unit>
        <trans-unit id="49eb9c6b19926a8575c169e52f8df687a6338f21" translate="yes" xml:space="preserve">
          <source>If the returned error is nil, the Response will contain a non-nil Body which the user is expected to close. If the Body is not both read to EOF and closed, the Client's underlying RoundTripper (typically Transport) may not be able to re-use a persistent TCP connection to the server for a subsequent &quot;keep-alive&quot; request.</source>
          <target state="translated">반환 된 오류가 nil 인 경우 응답에는 사용자가 닫을 것으로 예상되는 nil이 아닌 본문이 포함됩니다. Body가 EOF를 읽지 않고 닫히지 않으면 클라이언트의 기본 RoundTripper (일반적으로 Transport)는 후속 &quot;keep-alive&quot;요청을 위해 서버에 대한 지속적인 TCP 연결을 재사용하지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bd3e276f21c33ca258e2835ea6ef2502ea92047" translate="yes" xml:space="preserve">
          <source>If the returned token is a keyword, the literal string is the keyword.</source>
          <target state="translated">리턴 된 토큰이 키워드 인 경우 리터럴 문자열이 키워드입니다.</target>
        </trans-unit>
        <trans-unit id="d7865630a2cf1e24a8ed7ed472ba9beeb25fa193" translate="yes" xml:space="preserve">
          <source>If the returned token is a literal (token.IDENT, token.INT, token.FLOAT, token.IMAG, token.CHAR, token.STRING) or token.COMMENT, the literal string has the corresponding value.</source>
          <target state="translated">리턴 된 토큰이 리터럴 (token.IDENT, token.INT, token.FLOAT, token.IMAG, token.CHAR, token.STRING) 또는 token.COMMENT 인 경우 리터럴 문자열은 해당 값을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="7b330824cf4af38e2c2f1237e0044975056d896f" translate="yes" xml:space="preserve">
          <source>If the returned token is token.ILLEGAL, the literal string is the offending character.</source>
          <target state="translated">반환 된 토큰이 token.ILLEGAL이면 리터럴 문자열이 문제가되는 문자입니다.</target>
        </trans-unit>
        <trans-unit id="f2065d9b79fae019bc66ef4f832603a41d2a079f" translate="yes" xml:space="preserve">
          <source>If the returned token is token.SEMICOLON, the corresponding literal string is &quot;;&quot; if the semicolon was present in the source, and &quot;\n&quot; if the semicolon was inserted because of a newline or at EOF.</source>
          <target state="translated">리턴 된 토큰이 token.SEMICOLON 인 경우 해당 리터럴 문자열은 &quot;;&quot;입니다. 소스에 세미콜론이 있으면 줄 바꿈이나 EOF로 세미콜론을 삽입 한 경우 &quot;\ n&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="6d82694c27c567dcf0d737897e646720cd59f4a9" translate="yes" xml:space="preserve">
          <source>If the server replies with a redirect, the Client first uses the CheckRedirect function to determine whether the redirect should be followed. If permitted, a 301, 302, or 303 redirect causes subsequent requests to use HTTP method GET (or HEAD if the original request was HEAD), with no body. A 307 or 308 redirect preserves the original HTTP method and body, provided that the Request.GetBody function is defined. The NewRequest function automatically sets GetBody for common standard library body types.</source>
          <target state="translated">서버가 리디렉션으로 응답하는 경우 클라이언트는 먼저 CheckRedirect 기능을 사용하여 리디렉션을 따라야하는지 여부를 결정합니다. 허용되는 경우 301, 302 또는 303 리디렉션은 후속 요청이 본문없이 HTTP 메소드 GET (또는 원래 요청이 HEAD 인 경우 HEAD)을 사용하게합니다. Request.GetBody 함수가 정의 된 경우 307 또는 308 리디렉션은 원래 HTTP 메서드와 본문을 유지합니다. NewRequest 함수는 일반적인 표준 라이브러리 본문 유형에 대해 GetBody를 자동으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="8bef3b53d6d7bb99946b130aacd06c58001e65ba" translate="yes" xml:space="preserve">
          <source>If the source couldn't be read, the returned AST is nil and the error indicates the specific failure. If the source was read but syntax errors were found, the result is a partial AST (with ast.Bad* nodes representing the fragments of erroneous source code). Multiple errors are returned via a scanner.ErrorList which is sorted by file position.</source>
          <target state="translated">소스를 읽을 수없는 경우 반환 된 AST는 nil이며 오류는 특정 실패를 나타냅니다. 소스를 읽었지만 구문 오류가 발견되면 결과는 부분 AST (오류 소스 코드의 조각을 나타내는 ast.Bad * 노드 포함)입니다. 파일 위치별로 정렬 된 scanner.ErrorList를 통해 여러 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f66a139f57b43b60f302e27759bd0543bc9c0e26" translate="yes" xml:space="preserve">
          <source>If the time has a monotonic clock reading, the returned string includes a final field &quot;m=&amp;plusmn;&amp;lt;value&amp;gt;&quot;, where value is the monotonic clock reading formatted as a decimal number of seconds.</source>
          <target state="translated">시간에 단조로운 시계 판독 값이 있으면 반환 된 문자열에 최종 필드 &quot;m = &amp;plusmn; &amp;lt;value&amp;gt;&quot;가 포함됩니다. 여기서 value는 10 진수 초 형식의 단조로운 시계 판독 값입니다.</target>
        </trans-unit>
        <trans-unit id="251f36d24e83127f4dd9319d7cdbc49677b94325" translate="yes" xml:space="preserve">
          <source>If the traceback function is called from a signal handler on a Unix system, SigContext will be the signal context argument passed to the signal handler (a C ucontext_t* cast to uintptr_t). This may be used to start tracing at the point where the signal occurred. If the traceback function is not called from a signal handler, SigContext will be zero.</source>
          <target state="translated">유닉스 시스템의 신호 처리기에서 역 추적 함수를 호출하면 SigContext는 신호 처리기에 전달되는 신호 컨텍스트 인수가됩니다 (C ucontext_t *가 uintptr_t로 캐스트 됨). 신호가 발생한 지점에서 추적을 시작하는 데 사용할 수 있습니다. 신호 처리기에서 역 추적 함수를 호출하지 않으면 SigContext가 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="07b1d78b08994662a459431d46bce8768415b25a" translate="yes" xml:space="preserve">
          <source>If the type name of a slice element ends with &quot;SET&quot; then it's treated as if the &quot;set&quot; tag was set on it. This can be used with nested slices where a struct tag cannot be given.</source>
          <target state="translated">슬라이스 요소의 유형 이름이 &quot;SET&quot;으로 끝나면 &quot;set&quot;태그가 설정된 것처럼 처리됩니다. struct 태그를 제공 할 수없는 중첩 슬라이스에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1b298da75673ff2dc00ea6d79d2dbf4f6d4ad81" translate="yes" xml:space="preserve">
          <source>If the type of the first field of a structure is RawContent then the raw ASN1 contents of the struct will be stored in it.</source>
          <target state="translated">구조의 첫 번째 필드의 유형이 RawContent이면 구조체의 원시 ASN1 내용이 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="94580cf18c0cdda91d151e0855e03334c0926847" translate="yes" xml:space="preserve">
          <source>If there are nested type ids, the types for all inner type ids must be defined before the top-level type id is used to describe an encoded-v.</source>
          <target state="translated">중첩 유형 ID가있는 경우 최상위 유형 ID를 사용하여 encoding-v를 설명하기 전에 모든 내부 유형 ID의 유형을 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="a4b08581fb59710f6d84824026b409a7e3fe2aea" translate="yes" xml:space="preserve">
          <source>If there is an error, it will be of type *PathError.</source>
          <target state="translated">오류가 있으면 * PathError 유형입니다.</target>
        </trans-unit>
        <trans-unit id="d59b10d118f91edc83c197a1ea597908270dd51e" translate="yes" xml:space="preserve">
          <source>If there is no registered handler that applies to the request, Handler returns a &amp;ldquo;page not found&amp;rdquo; handler and an empty pattern.</source>
          <target state="translated">요청에 적용되는 등록 된 핸들러가없는 경우 핸들러는 &quot;페이지를 찾을 수 없음&quot;핸들러와 빈 패턴을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="1a7ace82b8245bf4439307ba5dfdbd1b825dcfff" translate="yes" xml:space="preserve">
          <source>If there was a problem walking to the file or directory named by path, the incoming error will describe the problem and the function can decide how to handle that error (and Walk will not descend into that directory). In the case of an error, the info argument will be nil. If an error is returned, processing stops. The sole exception is when the function returns the special value SkipDir. If the function returns SkipDir when invoked on a directory, Walk skips the directory's contents entirely. If the function returns SkipDir when invoked on a non-directory file, Walk skips the remaining files in the containing directory.</source>
          <target state="translated">path로 이름이 지정된 파일 또는 디렉토리로 이동하는 데 문제점이있는 경우, 수신 오류는 문제점을 설명하고 함수는 해당 오류를 처리하는 방법을 결정할 수 있습니다 (그리고 Walk는 해당 디렉토리로 내려 가지 않습니다). 오류가 발생하면 info 인수는 nil입니다. 오류가 리턴되면 처리가 중지됩니다. 유일한 예외는 함수가 특수 값 SkipDir을 반환하는 경우입니다. 디렉토리에서 호출 될 때 함수가 SkipDir을 반환하면 Walk는 디렉토리의 내용을 완전히 건너 뜁니다. 디렉토리가 아닌 파일에서 호출 될 때 함수가 SkipDir을 반환하면 Walk는 포함하는 디렉토리의 나머지 파일을 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="9f28f83ac01122a6b8eb17da82fc365cf06db186" translate="yes" xml:space="preserve">
          <source>If this compilation unit has no line table, it returns nil, nil.</source>
          <target state="translated">이 컴파일 단위에 행 테이블이 없으면 nil, nil을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="36cfd61621ceef678850032683735978215f2feb" translate="yes" xml:space="preserve">
          <source>If u.Host doesn't contain a valid numeric port, Port returns an empty string.</source>
          <target state="translated">u.Host에 유효한 숫자 포트가 없으면 Port는 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1f16e20c1b2a3c0d7a413b8fa21221a527ff3a01" translate="yes" xml:space="preserve">
          <source>If u.Opaque is non-empty, String uses the first form; otherwise it uses the second form. Any non-ASCII characters in host are escaped. To obtain the path, String uses u.EscapedPath().</source>
          <target state="translated">u.Opaque가 비어 있지 않으면 String은 첫 번째 형식을 사용합니다. 그렇지 않으면 두 번째 양식을 사용합니다. 호스트의 ASCII가 아닌 문자는 모두 이스케이프됩니다. 경로를 얻기 위해 String은 u.EscapedPath ()를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8013c9355c400aa79a6367baa057f4b9d4888841" translate="yes" xml:space="preserve">
          <source>If used in an unsafe context, then the value might be filtered out:</source>
          <target state="translated">안전하지 않은 컨텍스트에서 사용되는 경우 값이 필터링 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="169176f5802d140421e02d07f71892f55914e587" translate="yes" xml:space="preserve">
          <source>If v's Kind is Func, the returned pointer is an underlying code pointer, but not necessarily enough to identify a single function uniquely. The only guarantee is that the result is zero if and only if v is a nil func Value.</source>
          <target state="translated">v의 Kind가 Func이면 반환 된 포인터는 기본 코드 포인터이지만 단일 함수를 고유하게 식별하기에는 충분하지 않습니다. 유일한 보증은 v가 nil func Value 인 경우에만 결과가 0이라는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ee9b69667b384fa6c8c1419304597f7a05f5dda4" translate="yes" xml:space="preserve">
          <source>If v's Kind is Slice, the returned pointer is to the first element of the slice. If the slice is nil the returned value is 0. If the slice is empty but non-nil the return value is non-zero.</source>
          <target state="translated">v의 종류가 슬라이스 인 경우 반환 된 포인터는 슬라이스의 첫 번째 요소에 대한 것입니다. 슬라이스가 nil이면 리턴 값은 0입니다. 슬라이스가 비어 있지만 nil이 아닌 경우 리턴 값은 0이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="ccce50575e90f1da7bb594b206672d76cc0b7fdc" translate="yes" xml:space="preserve">
          <source>If x is prime, ProbablyPrime returns true. If x is chosen randomly and not prime, ProbablyPrime probably returns false. The probability of returning true for a randomly chosen non-prime is at most &amp;frac14;ⁿ.</source>
          <target state="translated">x가 소수이면 ProbablyPrime은 true를 반환합니다. x가 무작위로 선택되고 소수가 아닌 경우 ProbablyPrime은 아마도 false를 반환합니다. 무작위로 선택된 비 프라임에 대해 true를 리턴 할 확률은 최대 1/4입니다.</target>
        </trans-unit>
        <trans-unit id="bf8bf41d1552e2a2314c86bbee51c546608c7502" translate="yes" xml:space="preserve">
          <source>If you like, you can bind the flag to a variable using the Var() functions.</source>
          <target state="translated">원하는 경우 Var () 함수를 사용하여 플래그를 변수에 바인딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a6f437f93f8b5dbc142b89b4316e10878736145" translate="yes" xml:space="preserve">
          <source>If your application is not already running an http server, you need to start one. Add &quot;net/http&quot; and &quot;log&quot; to your imports and the following code to your main function:</source>
          <target state="translated">응용 프로그램에서 아직 http 서버를 실행하고 있지 않으면 시작해야합니다. &quot;net / http&quot;및 &quot;log&quot;를 가져 오기에 추가하고 다음 코드를 기본 기능에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="e7a7bb87f973e19b80ef2f0c235948e2ab80ca50" translate="yes" xml:space="preserve">
          <source>If z's precision is 0, it is changed to x's precision before the operation. Rounding is performed according to z's precision and rounding mode.</source>
          <target state="translated">z의 정밀도가 0이면 연산 전에 x의 정밀도로 변경됩니다. 반올림은 z의 정밀도 및 반올림 모드에 따라 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="bf3bdba69c06f396d015a2e68cfa8b8e0dc2a553" translate="yes" xml:space="preserve">
          <source>If {{.}} is the innocuous word, `left`, then it can appear more widely,</source>
          <target state="translated">{{.}}가 무해한 단어 인 '왼쪽'이라면 더 광범위하게 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35dc1b1b93ecc62032ac0000d9cf5065af4bc463" translate="yes" xml:space="preserve">
          <source>IfNode represents an {{if}} action and its commands.</source>
          <target state="translated">IfNode는 {{if}} 조치 및 해당 명령을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a40a74611ce76ddfa9aec134c7c4d57d7e7d1a0b" translate="yes" xml:space="preserve">
          <source>Ignore causes the provided signals to be ignored. If they are received by the program, nothing will happen. Ignore undoes the effect of any prior calls to Notify for the provided signals. If no signals are provided, all incoming signals will be ignored.</source>
          <target state="translated">무시하면 제공된 신호가 무시됩니다. 프로그램에 의해 수신되면 아무 일도 일어나지 않습니다. 무시는 제공된 신호에 대해 알림에 대한 이전 호출의 영향을 취소합니다. 신호가 제공되지 않으면 들어오는 모든 신호가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="98d36857a614a1e009d79e216b4eb0d9115f0404" translate="yes" xml:space="preserve">
          <source>Ignored reports whether sig is currently ignored.</source>
          <target state="translated">무시는 sig가 현재 무시되는지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="4d88a112acad4eaba636cd685d95e848e229a4fb" translate="yes" xml:space="preserve">
          <source>Ilogb returns the binary exponent of x as an integer.</source>
          <target state="translated">Ilogb는 x의 이진 지수를 정수로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="44e069a8f4a7e1ac23418ede1f9fbec843a967dd" translate="yes" xml:space="preserve">
          <source>Imag returns the imaginary part of x, which must be a numeric or unknown value. If x is Unknown, the result is Unknown.</source>
          <target state="translated">Imag는 x의 허수 부분을 반환하며, 숫자 또는 알 수없는 값이어야합니다. x가 알 수없는 경우 결과는 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="30d40b43edb0bdc3eabf2d534c36f9d06f964b6e" translate="yes" xml:space="preserve">
          <source>Image is a finite rectangular grid of color.Color values taken from a color model.</source>
          <target state="translated">이미지는 유한 사각형 사각형 격자로, 색상 모델에서 가져온 색상 값입니다.</target>
        </trans-unit>
        <trans-unit id="26d71317c3ede5b3f54e923608b8db6326957a5e" translate="yes" xml:space="preserve">
          <source>Image is an image.Image with a Set method to change a single pixel.</source>
          <target state="translated">이미지는 이미지입니다. 단일 픽셀을 변경하는 Set 메소드가있는 이미지입니다.</target>
        </trans-unit>
        <trans-unit id="b146748a0514484acff9fb056c40176e7e0d62af" translate="yes" xml:space="preserve">
          <source>Implementation restriction: The counting forms x{n,m}, x{n,}, and x{n} reject forms that create a minimum or maximum repetition count above 1000. Unlimited repetitions are not subject to this restriction.</source>
          <target state="translated">구현 제한 : 계산 양식 x {n, m}, x {n,} 및 x {n}은 최소 또는 최대 반복 횟수가 1000보다 큰 양식을 거부합니다. 무제한 반복에는이 제한이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="75c9903908feb1732654db7dd3662c68681cf3c0" translate="yes" xml:space="preserve">
          <source>Implementations must not retain p.</source>
          <target state="translated">구현은 p를 유지해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="baccfe949bd483e0aa453da0b286a6848971e885" translate="yes" xml:space="preserve">
          <source>Implementations of CookieJar must be safe for concurrent use by multiple goroutines.</source>
          <target state="translated">CookieJar의 구현은 여러 고 루틴이 동시에 사용할 수 있도록 안전해야합니다.</target>
        </trans-unit>
        <trans-unit id="2496dd56381c55b51499d5f91502dcff20d2b771" translate="yes" xml:space="preserve">
          <source>Implementations of PublicSuffixList must be safe for concurrent use by multiple goroutines.</source>
          <target state="translated">PublicSuffixList의 구현은 여러 고 루틴이 동시에 사용할 수 있도록 안전해야합니다.</target>
        </trans-unit>
        <trans-unit id="f73bf070b6238c284ef7b4d02061d370d3bb9d34" translate="yes" xml:space="preserve">
          <source>Implementations of Read are discouraged from returning a zero byte count with a nil error, except when len(p) == 0. Callers should treat a return of 0 and nil as indicating that nothing happened; in particular it does not indicate EOF.</source>
          <target state="translated">read 구현은 len (p) == 0 인 경우를 제외하고 nil 오류와 함께 0 바이트 카운트를 반환하지 않는 것이 좋습니다. 특히 EOF를 나타내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9c4eb58019f122cd6fcd79f868e42855509e5b17" translate="yes" xml:space="preserve">
          <source>Implementations of Token are discouraged from returning a nil token with a nil error. Callers should treat a return of nil, nil as indicating that nothing happened; in particular it does not indicate EOF.</source>
          <target state="translated">토큰 구현은 nil 오류로 nil 토큰을 반환하지 않는 것이 좋습니다. 호출자는 nil, nil의 리턴을 아무 일도 발생하지 않았 음을 나타내는 것으로 처리해야합니다. 특히 EOF를 나타내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3b31ef7323ed3ca421b9bab6f7dbaab32c7ce726" translate="yes" xml:space="preserve">
          <source>Implements reports whether type V implements interface T.</source>
          <target state="translated">V 유형이 인터페이스 T를 구현하는지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="5ba5f70840c67e6a055ce04e03bb2454bb162d9f" translate="yes" xml:space="preserve">
          <source>Import is shorthand for Default.Import.</source>
          <target state="translated">가져 오기는 Default.Import의 약어입니다.</target>
        </trans-unit>
        <trans-unit id="6afc9b3e57abb6585be9561d376bdea28ca944ae" translate="yes" xml:space="preserve">
          <source>Import returns details about the Go package named by the import path, interpreting local import paths relative to the srcDir directory. If the path is a local import path naming a package that can be imported using a standard import path, the returned package will set p.ImportPath to that path.</source>
          <target state="translated">가져 오기는 srcDir 디렉토리에 상대적인 로컬 가져 오기 경로를 해석하여 가져 오기 경로로 이름이 지정된 Go 패키지에 대한 세부 사항을 리턴합니다. 경로가 표준 가져 오기 경로를 사용하여 가져올 수있는 패키지를 명명하는 로컬 가져 오기 경로 인 경우 반환 된 패키지는 p.ImportPath를 해당 경로로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="93d88a517c9d75699c2e4045b6e3fc932cd88482" translate="yes" xml:space="preserve">
          <source>ImportDir is like Import but processes the Go package found in the named directory.</source>
          <target state="translated">ImportDir은 가져 오기와 유사하지만 명명 된 디렉토리에있는 Go 패키지를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="58d6f3af90d9fbc41be2c405bfa8615d93151250" translate="yes" xml:space="preserve">
          <source>ImportDir is shorthand for Default.ImportDir.</source>
          <target state="translated">ImportDir은 Default.ImportDir의 줄임말입니다.</target>
        </trans-unit>
        <trans-unit id="2d321830ed77e3baaf4ac8b7f7efc36408c85002" translate="yes" xml:space="preserve">
          <source>ImportMode is reserved for future use.</source>
          <target state="translated">ImportMode는 나중에 사용하기 위해 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="81d5bfd42309b64b183f9701f930099193a14426" translate="yes" xml:space="preserve">
          <source>Imported returns the package that was imported. It is distinct from Pkg(), which is the package containing the import statement.</source>
          <target state="translated">가져 오기는 가져온 패키지를 반환합니다. import 문을 포함하는 패키지 인 Pkg ()와는 다릅니다.</target>
        </trans-unit>
        <trans-unit id="98f8e071166bb5be3aecf52c0312f3d8e38c742a" translate="yes" xml:space="preserve">
          <source>ImportedLibraries returns the names of all libraries referred to by the binary f that are expected to be linked with the binary at dynamic link time.</source>
          <target state="translated">ImportedLibraries는 동적 링크 타임에 바이너리와 링크 될 것으로 예상되는 바이너리 f가 참조하는 모든 라이브러리의 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6d0d053d5be94190ae4125e53a45e74c9bfff903" translate="yes" xml:space="preserve">
          <source>ImportedLibraries returns the paths of all libraries referred to by the binary f that are expected to be linked with the binary at dynamic link time.</source>
          <target state="translated">ImportedLibraries는 동적 링크 타임에 바이너리와 링크 될 것으로 예상되는 바이너리 f가 참조하는 모든 라이브러리의 경로를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="27f49356d80e117cb6ff37f13e3b8dc616e332cb" translate="yes" xml:space="preserve">
          <source>ImportedSymbols returns the names of all symbols referred to by the binary f that are expected to be satisfied by other libraries at dynamic load time.</source>
          <target state="translated">ImportedSymbols는 동적로드 시간에 다른 라이브러리에서 만족할 것으로 예상되는 이진 f가 참조하는 모든 심볼의 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="80301d15602072b275cf4e9d642684ee556fd2a0" translate="yes" xml:space="preserve">
          <source>ImportedSymbols returns the names of all symbols referred to by the binary f that are expected to be satisfied by other libraries at dynamic load time. It does not return weak symbols.</source>
          <target state="translated">ImportedSymbols는 동적로드 시간에 다른 라이브러리에서 만족할 것으로 예상되는 이진 f가 참조하는 모든 심볼의 이름을 반환합니다. 약한 기호는 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="75eb201c4952cde504ceda9eb34765cbfc018641" translate="yes" xml:space="preserve">
          <source>Imports returns the list of packages directly imported by pkg; the list is in source order.</source>
          <target state="translated">Imports는 pkg에서 직접 가져온 패키지 목록을 반환합니다. 목록은 소스 순서입니다.</target>
        </trans-unit>
        <trans-unit id="cb7bc76d7380682c92ffb45e3be0edf510619c0c" translate="yes" xml:space="preserve">
          <source>In C syntax, this struct will be</source>
          <target state="translated">C 구문에서이 구조체는</target>
        </trans-unit>
        <trans-unit id="031e67b82062bc206ba16bfbb78969301350778f" translate="yes" xml:space="preserve">
          <source>In Go 1 and Go 1.1, each package produced one Obj for all Go sources and one Obj per C source file.</source>
          <target state="translated">Go 1 및 Go 1.1에서 각 패키지는 모든 Go 소스에 대해 하나의 Obj와 C 소스 파일 당 하나의 Obj를 생성했습니다.</target>
        </trans-unit>
        <trans-unit id="f1a4145c4d681021c6b688a748d3fd850af7e56f" translate="yes" xml:space="preserve">
          <source>In Go 1.1 and earlier, each function (represented by a Func) had its own LineTable, and the line number corresponded to a numbering of all source lines in the program, across all files. That absolute line number would then have to be converted separately to a file name and line number within the file.</source>
          <target state="translated">Go 1.1 및 이전 버전에서 각 함수 (Func로 표시)에는 고유 한 LineTable이 있으며 행 번호는 모든 파일에서 프로그램의 모든 소스 행 번호에 해당합니다. 그런 절대 행 번호는 파일 내의 파일 이름과 행 번호로 개별적으로 변환되어야합니다.</target>
        </trans-unit>
        <trans-unit id="35c4a15e4a2e0d9709fe9d9d2d8891336f5119ee" translate="yes" xml:space="preserve">
          <source>In Go 1.12 and earlier, it was possible to distribute packages in binary form without including the source code used for compiling the package. The package was distributed with a source file not excluded by build constraints and containing a &quot;//go:binary-only-package&quot; comment. Like a build constraint, this comment appeared at the top of a file, preceded only by blank lines and other line comments and with a blank line following the comment, to separate it from the package documentation. Unlike build constraints, this comment is only recognized in non-test Go source files.</source>
          <target state="translated">Go 1.12 및 이전 버전에서는 패키지 컴파일에 사용 된 소스 코드를 포함하지 않고 바이너리 형식으로 패키지를 배포 할 수있었습니다. 패키지는 빌드 제약 조건에 의해 제외되지 않고 &quot;// go : binary-only-package&quot;주석이 포함 된 소스 파일과 함께 배포되었습니다. 빌드 제약 조건과 마찬가지로이 주석은 파일 맨 위에 나타나고, 빈 줄과 다른 줄 주석 만 있고 주석 다음에 빈 줄만 있으면 패키지 설명서와 구분됩니다. 빌드 제약 조건과 달리이 주석은 테스트되지 않은 Go 소스 파일에서만 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="cc8775c16cc6c9f67e9f67d2c4b9b38bd2343802" translate="yes" xml:space="preserve">
          <source>In Go 1.2, the format of the data changed so that there is a single LineTable for the entire program, shared by all Funcs, and there are no absolute line numbers, just line numbers within specific files.</source>
          <target state="translated">Go 1.2에서는 데이터 형식이 변경되어 전체 Funcs가 공유하는 전체 프로그램에 대해 단일 LineTable이 있고 절대 파일 번호가없고 특정 파일 내에 라인 번호 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="94c3f9b8a2f1195c43f29bc6d1587c741d49bcbe" translate="yes" xml:space="preserve">
          <source>In Go 1.2, there is a single Obj for the entire program.</source>
          <target state="translated">Go 1.2에는 전체 프로그램에 대한 단일 Obj가 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc1a1510c05c5e605f2bf42bab100aff6fd4f01e" translate="yes" xml:space="preserve">
          <source>In Printf, Sprintf, and Fprintf, the default behavior is for each formatting verb to format successive arguments passed in the call. However, the notation [n] immediately before the verb indicates that the nth one-indexed argument is to be formatted instead. The same notation before a '*' for a width or precision selects the argument index holding the value. After processing a bracketed expression [n], subsequent verbs will use arguments n+1, n+2, etc. unless otherwise directed.</source>
          <target state="translated">Printf, Sprintf 및 Fprintf에서 기본 동작은 각 형식 동사가 호출에 전달 된 연속 인수의 형식을 지정하는 것입니다. 그러나 동사 바로 앞의 표기법 [n]은 n 번째 1 인덱스 인수가 대신 형식화되어야 함을 나타냅니다. 너비 또는 정밀도에 대해 '*'앞의 동일한 표기법은 값을 보유하는 인수 인덱스를 선택합니다. 대괄호로 묶은 표현식 [n]을 처리 한 후, 다른 동사는 별도의 지시가없는 한 인수 n + 1, n + 2 등을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6f69301b556dc9f571bc4bb3612422a63af49e86" translate="yes" xml:space="preserve">
          <source>In TLS 1.3, this type is called NamedGroup, but at this time this library only supports Elliptic Curve based groups. See RFC 8446, Section 4.2.7.</source>
          <target state="translated">TLS 1.3에서는이 유형을 NamedGroup이라고하지만 현재이 라이브러리는 타원 곡선 기반 그룹 만 지원합니다. RFC 8446, 섹션 4.2.7을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="93a2aff531fe6a26d094463bdd12d8ce980726db" translate="yes" xml:space="preserve">
          <source>In a Go program that includes non-Go code, typically C/C++ code accessed using cgo or SWIG, Go's startup code normally runs first. It configures the signal handlers as expected by the Go runtime, before the non-Go startup code runs. If the non-Go startup code wishes to install its own signal handlers, it must take certain steps to keep Go working well. This section documents those steps and the overall effect changes to signal handler settings by the non-Go code can have on Go programs. In rare cases, the non-Go code may run before the Go code, in which case the next section also applies.</source>
          <target state="translated">일반적으로 cgo 또는 SWIG를 사용하여 액세스하는 C / C ++ 코드 인 비 Go 코드가 포함 된 Go 프로그램에서 Go의 시작 코드가 먼저 실행됩니다. Go가 아닌 시작 코드가 실행되기 전에 Go 런타임에 예상되는대로 신호 핸들러를 구성합니다. 비 Go 시작 코드가 자체 신호 처리기를 설치하려면 Go가 잘 작동하도록 특정 단계를 수행해야합니다. 이 섹션에서는 이러한 단계를 설명하고 비 Go 코드에 의해 신호 처리기 설정에 대한 전반적인 효과 변경 사항은 Go 프로그램에서 가질 수 있습니다. 드문 경우이지만 Go 코드가 아닌 코드가 Go 코드보다 먼저 실행될 수 있으며,이 경우 다음 섹션도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="b709a8b5c95be5a899a7612ec04af9fcd8c6fe68" translate="yes" xml:space="preserve">
          <source>In addition to adding the HTTP handler, this package registers the following variables:</source>
          <target state="translated">HTTP 처리기를 추가하는 것 외에도이 패키지는 다음 변수를 등록합니다.</target>
        </trans-unit>
        <trans-unit id="c7232c786e65fae897885a5d1905f0858ffd2ae2" translate="yes" xml:space="preserve">
          <source>In addition to the required &amp;ldquo;wall clock&amp;rdquo; reading, a Time may contain an optional reading of the current process's monotonic clock, to provide additional precision for comparison or subtraction. See the &amp;ldquo;Monotonic Clocks&amp;rdquo; section in the package documentation for details.</source>
          <target state="translated">필요한 &quot;벽시계&quot;판독 값 외에 Time에는 현재 프로세스의 단조로운 클록에 대한 선택적 판독 값이 포함되어 비교 또는 뺄셈에 대한 추가 정밀도를 제공 할 수 있습니다. 자세한 내용은 패키지 설명서의 &quot;단조 클럭&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="965439857efd394443e37d36ace60b7ac7d83473" translate="yes" xml:space="preserve">
          <source>In addition to the struct tags recognised by Unmarshal, the following can be used:</source>
          <target state="translated">Unmarshal에서 인식하는 구조체 태그 외에도 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d07fa607208161c419b4aff2675e4f243b41086c" translate="yes" xml:space="preserve">
          <source>In all other cases, Scan returns an empty literal string.</source>
          <target state="translated">다른 모든 경우 Scan은 빈 리터럴 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dc451d8d43456b62826bda28dfbc96cdb2eb2524" translate="yes" xml:space="preserve">
          <source>In all the scanning functions, a carriage return followed immediately by a newline is treated as a plain newline (\r\n means the same as \n).</source>
          <target state="translated">모든 스캔 기능에서 캐리지 리턴과 바로 다음에 개행 문자는 일반 개행 문자로 취급됩니다 (\ r \ n은 \ n과 동일 함).</target>
        </trans-unit>
        <trans-unit id="fedccbf24f7f68d8101f599e3218a03c5ffaf765" translate="yes" xml:space="preserve">
          <source>In all the scanning functions, if an operand implements method Scan (that is, it implements the Scanner interface) that method will be used to scan the text for that operand. Also, if the number of arguments scanned is less than the number of arguments provided, an error is returned.</source>
          <target state="translated">모든 스캔 기능에서 피연산자가 Scan 메소드를 구현하는 경우 (즉, 스캐너 인터페이스를 구현하는 경우) 해당 피연산자의 텍스트를 스캔하는 데 해당 메소드가 사용됩니다. 또한 스캔 된 인수 수가 제공된 인수 수보다 적 으면 오류가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="a1bf502195aaabff9af8feae702eb1ba2c806b3d" translate="yes" xml:space="preserve">
          <source>In an ErrorList, an error is represented by an *Error. The position Pos, if valid, points to the beginning of the offending token, and the error condition is described by Msg.</source>
          <target state="translated">ErrorList에서 오류는 * Error로 표시됩니다. 위치 Pos가 유효하면 문제가되는 토큰의 시작을 가리키고 오류 조건은 메시지로 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="c43ce5959f73c41a703ce648d64371023d38a1e1" translate="yes" xml:space="preserve">
          <source>In early versions of Go each source file became a different Obj.</source>
          <target state="translated">초기 버전의 Go에서 각 소스 파일은 다른 Obj가되었습니다.</target>
        </trans-unit>
        <trans-unit id="42a68547a9dca9735cb7eba8147953340f09b72e" translate="yes" xml:space="preserve">
          <source>In effect, the method must look schematically like</source>
          <target state="translated">실제로이 방법은 개략적으로 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="b72051420981768a1127b1640516d07dc80b1c1a" translate="yes" xml:space="preserve">
          <source>In general DeepEqual is a recursive relaxation of Go's == operator. However, this idea is impossible to implement without some inconsistency. Specifically, it is possible for a value to be unequal to itself, either because it is of func type (uncomparable in general) or because it is a floating-point NaN value (not equal to itself in floating-point comparison), or because it is an array, struct, or interface containing such a value. On the other hand, pointer values are always equal to themselves, even if they point at or contain such problematic values, because they compare equal using Go's == operator, and that is a sufficient condition to be deeply equal, regardless of content. DeepEqual has been defined so that the same short-cut applies to slices and maps: if x and y are the same slice or the same map, they are deeply equal regardless of content.</source>
          <target state="translated">일반적으로 DeepEqual은 Go = 연산자의 재귀 적 완화입니다. 그러나이 아이디어는 약간의 일관성이 없으면 구현할 수 없습니다. 특히, 함수 유형 (일반적으로 비교할 수 없음)이거나 부동 소수점 NaN 값 (부동 소수점 비교에서 자체와 같지 않음) 또는 값 때문에 값이 자체와 같지 않을 수 있습니다. 그러한 값을 포함하는 배열, 구조체 또는 인터페이스입니다. 반면에 포인터 값은 Go의 == 연산자를 사용하여 동일하게 비교하기 때문에 이러한 문제가있는 값을 가리 키거나 포함하는 경우에도 항상 자신과 같습니다. 이는 내용에 관계없이 깊게 동일하기에 충분한 조건입니다. DeepEqual은 슬라이스와 맵에 동일한 바로 가기가 적용되도록 정의되었습니다. x와 y가 같은 슬라이스이거나 동일한 맵인 경우,내용에 관계없이 깊이 동일합니다.</target>
        </trans-unit>
        <trans-unit id="07b960c708d879d40875264c73a08a0683383d6b" translate="yes" xml:space="preserve">
          <source>In general, a given attribute's value may take on one of several possible classes defined by DWARF, each of which leads to a slightly different interpretation of the attribute.</source>
          <target state="translated">일반적으로, 주어진 속성 값은 DWARF에 의해 정의 된 몇 가지 가능한 클래스 중 하나를 취할 수 있으며, 각각은 속성에 대해 약간 다르게 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="2e9ecaaf397056078378f799dda9c4e1072c7928" translate="yes" xml:space="preserve">
          <source>In general, a gzip file can be a concatenation of gzip files, each with its own header. Reads from the Reader return the concatenation of the uncompressed data of each. Only the first header is recorded in the Reader fields.</source>
          <target state="translated">일반적으로 gzip 파일은 각각 고유 한 헤더가있는 gzip 파일의 연결 일 수 있습니다. 판독기에서 읽은 값은 각각의 압축되지 않은 데이터의 연결을 반환합니다. 첫 번째 헤더 만 리더 필드에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="b6ffd0a95c8557850de7ace105d0c02e95a18d70" translate="yes" xml:space="preserve">
          <source>In general, if allocation is required, the decoder will allocate memory. If not, it will update the destination variables with values read from the stream. It does not initialize them first, so if the destination is a compound value such as a map, struct, or slice, the decoded values will be merged elementwise into the existing variables.</source>
          <target state="translated">일반적으로 할당이 필요한 경우 디코더는 메모리를 할당합니다. 그렇지 않은 경우 대상 변수를 스트림에서 읽은 값으로 업데이트합니다. 먼저 초기화하지 않으므로 대상이 맵, 구조체 또는 슬라이스와 같은 복합 값인 경우 디코딩 된 값은 요소별로 기존 변수에 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="d1a73603a88217147c68ec9c324a3f4cba1ebddc" translate="yes" xml:space="preserve">
          <source>In general, reflect.SliceHeader and reflect.StringHeader should be used only as *reflect.SliceHeader and *reflect.StringHeader pointing at actual slices or strings, never as plain structs. A program should not declare or allocate variables of these struct types.</source>
          <target state="translated">일반적으로 reflect.SliceHeader 및 reflect.StringHeader는 실제 슬라이스 나 문자열을 가리키는 * reflect.SliceHeader 및 * reflect.StringHeader로만 사용해야합니다. 프로그램은 이러한 구조체 타입의 변수를 선언하거나 할당해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="99dc4b6fd44a858b786d20b64de92f5f16319ca0" translate="yes" xml:space="preserve">
          <source>In general, the GHASH operation performed by this implementation of GCM is not constant-time. An exception is when the underlying Block was created by aes.NewCipher on systems with hardware support for AES. See the crypto/aes package documentation for details.</source>
          <target state="translated">일반적으로,이 GCM 구현에 의해 수행 된 GHASH 연산은 일정한 시간이 아닙니다. AES에 대한 하드웨어 지원 시스템에서 aes.NewCipher가 기본 블록을 작성한 경우는 예외입니다. 자세한 내용은 crypto / aes 패키지 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="63a94d50c6e71995bfdddbf6d3b7ddbbd572fca1" translate="yes" xml:space="preserve">
          <source>In most cases, new(Buffer) (or just declaring a Buffer variable) is sufficient to initialize a Buffer.</source>
          <target state="translated">대부분의 경우 버퍼를 초기화하기 위해 new (Buffer) (또는 Buffer 변수 선언)로 충분합니다.</target>
        </trans-unit>
        <trans-unit id="ce6abe6e4a1757599621f3d92af6850089e3e51d" translate="yes" xml:space="preserve">
          <source>In non-HTML settings where the escaping interferes with the readability of the output, SetEscapeHTML(false) disables this behavior.</source>
          <target state="translated">이스케이프가 출력의 가독성을 방해하는 HTML이 아닌 설정에서 SetEscapeHTML (false)는이 동작을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="7077ca93ebf4ef49120708550f14d220620ccf80" translate="yes" xml:space="preserve">
          <source>In panics if loc is nil.</source>
          <target state="translated">loc이 nil이면 패닉 상태입니다.</target>
        </trans-unit>
        <trans-unit id="f52d38c87623b45c8b7767cba23884c87bb2c3a8" translate="yes" xml:space="preserve">
          <source>In particular, it implements LZW as used by the GIF and PDF file formats, which means variable-width codes up to 12 bits and the first two non-literal codes are a clear code and an EOF code.</source>
          <target state="translated">특히 GIF 및 PDF 파일 형식에서 사용되는 LZW를 구현합니다. 이는 최대 12 비트의 가변 폭 코드를 의미하며 처음 두 개의 비 문자 코드는 일반 코드 및 EOF 코드입니다.</target>
        </trans-unit>
        <trans-unit id="4026aa85ef00c786dfe0c796e4b667cd2644b68d" translate="yes" xml:space="preserve">
          <source>In performance critical applications, Reset can be used to discard the current compressor or decompressor state and reinitialize them quickly by taking advantage of previously allocated memory.</source>
          <target state="translated">성능이 중요한 응용 분야에서는 Reset을 사용하여 현재 압축기 또는 압축 해제 기 상태를 버리고 이전에 할당 된 메모리를 활용하여 빠르게 다시 초기화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6db233d0c99db26b8c12c611c05604abfea98d46" translate="yes" xml:space="preserve">
          <source>In reports whether every point in r is in s.</source>
          <target state="translated">r의 모든 점이 s인지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="84fe4eae8d319a1913e35010d51f1271fd7ded56" translate="yes" xml:space="preserve">
          <source>In reports whether p is in r.</source>
          <target state="translated">p가 r에 있는지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="0fd55e418f00485b3f2efc5b428b0418b6a94be8" translate="yes" xml:space="preserve">
          <source>In reports whether the rune is a member of one of the ranges.</source>
          <target state="translated">룬이 범위 중 하나의 구성원인지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="472b3dea5785c77ec21b439277ea93730e47a2be" translate="yes" xml:space="preserve">
          <source>In returns a copy of t representing the same time instant, but with the copy's location information set to loc for display purposes.</source>
          <target state="translated">In은 동일한 시간 순간을 나타내는 t의 사본을 리턴하지만 사본의 위치 정보는 표시 목적으로 loc로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="711d8c9ceb05e3476e4192e2fd5e66ccc3b3ba1b" translate="yes" xml:space="preserve">
          <source>In slices and arrays, as well as maps, all elements, even zero-valued elements, are transmitted, even if all the elements are zero.</source>
          <target state="translated">맵과 함께 슬라이스와 배열에서는 모든 요소가 0 인 경우에도 모든 요소, 값이 0 인 요소도 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="9f17f1b7292d381dce79c4e2b9b83d7f1d5da96e" translate="yes" xml:space="preserve">
          <source>In summary, a gob stream looks like</source>
          <target state="translated">요약하면, 덩어리 스트림은</target>
        </trans-unit>
        <trans-unit id="2d78ddedbd337c0bea6888e7055a4838325b74f8" translate="yes" xml:space="preserve">
          <source>In the $name form, name is taken to be as long as possible: $1x is equivalent to ${1x}, not ${1}x, and, $10 is equivalent to ${10}, not ${1}0.</source>
          <target state="translated">$ name 양식에서 이름은 가능한 한 길어야합니다. $ 1x는 $ {1} x가 아니라 $ {1x}와 같으며 $ 10은 $ {1} 0이 아니라 $ {10}과 같습니다. .</target>
        </trans-unit>
        <trans-unit id="37a0ec0d20103e0c83570c4610c7755ff7ac53c0" translate="yes" xml:space="preserve">
          <source>In the absence of a time zone indicator, Parse returns a time in UTC.</source>
          <target state="translated">시간대 표시기가 없으면 Parse는 UTC로 시간을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b029486adc899e6b2e4bce186582f459ceb89a34" translate="yes" xml:space="preserve">
          <source>In the directory containing the package, .go, .c, .h, and .s files are considered part of the package except for:</source>
          <target state="translated">패키지가 포함 된 디렉토리에서 .go, .c, .h 및 .s 파일은 다음을 제외하고 패키지의 일부로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="fa1c6c88c18a52fe6d2731df7b2ac739dc65317f" translate="yes" xml:space="preserve">
          <source>In the format string, a verb introduced by the % character consumes and parses input; these verbs are described in more detail below. A character other than %, space, or newline in the format consumes exactly that input character, which must be present. A newline with zero or more spaces before it in the format string consumes zero or more spaces in the input followed by a single newline or the end of the input. A space following a newline in the format string consumes zero or more spaces in the input. Otherwise, any run of one or more spaces in the format string consumes as many spaces as possible in the input. Unless the run of spaces in the format string appears adjacent to a newline, the run must consume at least one space from the input or find the end of the input.</source>
          <target state="translated">형식 문자열에서 % 문자에 의해 도입 된 동사는 입력을 소비하고 구문 분석합니다. 이 동사는 아래에 더 자세히 설명되어 있습니다. 형식에서 %, 공백 또는 개행 문자 이외의 문자는 반드시 입력 문자를 사용해야하며 반드시 입력 문자를 사용해야합니다. 형식 문자열에서 0 개 이상의 공백이있는 개행은 입력에서 0 개 이상의 공백을 사용한 후 단일 개행 또는 입력 끝을 사용합니다. 형식 문자열에서 개행 다음에 오는 공백은 입력에서 0 개 이상의 공백을 소비합니다. 그렇지 않으면 형식 문자열에서 하나 이상의 공백을 실행하면 입력에서 가능한 한 많은 공백이 사용됩니다. 형식 문자열의 공백이 줄 바꿈 옆에 나타나지 않으면 런은 입력에서 하나 이상의 공백을 소비하거나 입력의 끝을 찾아야합니다.</target>
        </trans-unit>
        <trans-unit id="ed1a2050a365f5d52ef37144115d11517ff42bc2" translate="yes" xml:space="preserve">
          <source>In the most simple case, if the type of the value from the source column is an integer, bool or string type T and dest is of type *T, Scan simply assigns the value through the pointer.</source>
          <target state="translated">가장 간단한 경우, 소스 열의 값 유형이 정수, bool 또는 문자열 유형 T이고 dest가 * T 유형 인 경우 Scan은 포인터를 통해 값을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="5c811352496639bcd7be1278e40839e6992f883a" translate="yes" xml:space="preserve">
          <source>In the second form, the following rules apply:</source>
          <target state="translated">두 번째 양식에서는 다음 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="9ca6beb2058ca8ef81c9dbee1705e13b3578af1f" translate="yes" xml:space="preserve">
          <source>In the template, a variable is denoted by a substring of the form $name or ${name}, where name is a non-empty sequence of letters, digits, and underscores. A purely numeric name like $1 refers to the submatch with the corresponding index; other names refer to capturing parentheses named with the (?P&amp;lt;name&amp;gt;...) syntax. A reference to an out of range or unmatched index or a name that is not present in the regular expression is replaced with an empty slice.</source>
          <target state="translated">템플릿에서 변수는 $ name 또는 $ {name} 형식의 하위 문자열로 표시됩니다. 여기서 name은 비어 있지 않은 문자, 숫자 및 밑줄입니다. $ 1과 같은 순수한 숫자 이름은 해당 색인과의 하위 일치를 나타냅니다. 다른 이름은 (? P &amp;lt;name&amp;gt; ...) 구문으로 명명 된 괄호 캡처를 나타냅니다. 범위를 벗어 났거나 일치하지 않는 인덱스 또는 정규식에없는 이름에 대한 참조는 빈 조각으로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="5a1c160af25c73f96bab58b7ac18692fbbe1ffa1" translate="yes" xml:space="preserve">
          <source>In the terminology of the zlib library, Flush is equivalent to Z_SYNC_FLUSH.</source>
          <target state="translated">zlib 라이브러리의 용어에서 Flush는 Z_SYNC_FLUSH와 같습니다.</target>
        </trans-unit>
        <trans-unit id="2dd7b02fa4aa241d6b5f4aad090e1521eaf7af73" translate="yes" xml:space="preserve">
          <source>In this usage hdr.Data is really an alternate way to refer to the underlying pointer in the string header, not a uintptr variable itself.</source>
          <target state="translated">이 사용법에서 hdr.Data는 실제로 uintptr 변수 자체가 아니라 문자열 헤더의 기본 포인터를 참조하는 대체 방법입니다.</target>
        </trans-unit>
        <trans-unit id="b66dfbc84a8b6f209be163efb64c95ba40440449" translate="yes" xml:space="preserve">
          <source>InUseBytes returns the number of bytes in use (AllocBytes - FreeBytes).</source>
          <target state="translated">InUseBytes는 사용중인 바이트 수 (AllocBytes-FreeBytes)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d6ed56286846a6cf59f0baa7c19dd1836590eeba" translate="yes" xml:space="preserve">
          <source>InUseObjects returns the number of objects in use (AllocObjects - FreeObjects).</source>
          <target state="translated">InUseObjects는 사용중인 개체 수 (AllocObjects-FreeObjects)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dfe141017385b1d5692d01442e77119d4a1ae1e2" translate="yes" xml:space="preserve">
          <source>Incoming requests to a server should create a Context, and outgoing calls to servers should accept a Context. The chain of function calls between them must propagate the Context, optionally replacing it with a derived Context created using WithCancel, WithDeadline, WithTimeout, or WithValue. When a Context is canceled, all Contexts derived from it are also canceled.</source>
          <target state="translated">서버에 들어오는 요청은 컨텍스트를 작성하고 서버에 대한 발신 호출은 컨텍스트를 승인해야합니다. 이들 사이의 함수 호출 체인은 컨텍스트를 전파해야하며, 선택적으로 WithCancel, WithDeadline, WithTimeout 또는 WithValue를 사용하여 작성된 파생 컨텍스트로 대체해야합니다. 컨텍스트가 취소되면 해당 컨텍스트에서 파생 된 모든 컨텍스트도 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="f3527c443ffc9a19a79c9a5af60b69f82dd615d1" translate="yes" xml:space="preserve">
          <source>IncorrectPasswordError is returned when an incorrect password is detected.</source>
          <target state="translated">잘못된 비밀번호가 감지되면 IncorrectPasswordError가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="aacf42132cce6cf5c1608a5d27f90fcbf93ae851" translate="yes" xml:space="preserve">
          <source>Indent</source>
          <target state="translated">Indent</target>
        </trans-unit>
        <trans-unit id="ffaaf5870213dda02bfcfd6086cb6c73c505917c" translate="yes" xml:space="preserve">
          <source>Indent appends to dst an indented form of the JSON-encoded src. Each element in a JSON object or array begins on a new, indented line beginning with prefix followed by one or more copies of indent according to the indentation nesting. The data appended to dst does not begin with the prefix nor any indentation, to make it easier to embed inside other formatted JSON data. Although leading space characters (space, tab, carriage return, newline) at the beginning of src are dropped, trailing space characters at the end of src are preserved and copied to dst. For example, if src has no trailing spaces, neither will dst; if src ends in a trailing newline, so will dst.</source>
          <target state="translated">들여 쓰기는 들여 쓰기 된 JSON 인코딩 src 양식을 dst에 추가합니다. JSON 객체 또는 배열의 각 요소는 접두사로 시작하고 들여 쓰기 네 스팅에 따라 하나 이상의 들여 쓰기 사본으로 시작하는 들여 쓰기 된 새 줄에서 시작합니다. dst에 추가 된 데이터는 접두어 나 들여 쓰기로 시작하지 않으므로 다른 형식의 JSON 데이터에 쉽게 포함 할 수 있습니다. src 시작 부분의 선행 공백 문자 (공백, 탭, 캐리지 리턴, 개행 문자)는 삭제되지만 src 끝의 후행 공백 문자는 유지되고 dst에 복사됩니다. 예를 들어, src에 후행 공백이 없으면 dst도 마찬가지입니다. src가 후행 줄 바꿈으로 끝나면 dst도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="68e20af4dfa7d94d1e8e99b5a45a2168cf2653cc" translate="yes" xml:space="preserve">
          <source>Indent sets the encoder to generate XML in which each element begins on a new indented line that starts with prefix and is followed by one or more copies of indent according to the nesting depth.</source>
          <target state="translated">들여 쓰기는 각 요소가 접두사로 시작하고 중첩 깊이에 따라 하나 이상의 들여 쓰기 사본이 오는 새 들여 쓰기 행에서 시작하는 XML을 생성하도록 인코더를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="421722312ce68c9bf9eb41def321649c4712dbd6" translate="yes" xml:space="preserve">
          <source>Index describes the path from x to f in x.f. The last index entry is the field or method index of the type declaring f; either:</source>
          <target state="translated">색인은 xf에서 x에서 f까지의 경로를 설명합니다. 마지막 색인 항목은 f를 선언하는 유형의 필드 또는 메소드 색인입니다. 어느 한 쪽:</target>
        </trans-unit>
        <trans-unit id="1d0b49853e61d44f4f8b07282b1903e9f2bc5158" translate="yes" xml:space="preserve">
          <source>Index implements a suffix array for fast substring search.</source>
          <target state="translated">인덱스는 빠른 하위 문자열 검색을 위해 접미사 배열을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="af573efacc3f6c1539d934e082a33b7c5805e74a" translate="yes" xml:space="preserve">
          <source>Index responds with the pprof-formatted profile named by the request. For example, &quot;/debug/pprof/heap&quot; serves the &quot;heap&quot; profile. Index responds to a request for &quot;/debug/pprof/&quot; with an HTML page listing the available profiles.</source>
          <target state="translated">인덱스는 요청에 의해 명명 된 pprof 형식의 프로파일로 응답합니다. 예를 들어 &quot;/ debug / pprof / heap&quot;은 &quot;heap&quot;프로필을 제공합니다. 색인은 사용 가능한 프로파일을 나열하는 HTML 페이지와 함께 &quot;/ debug / pprof /&quot;요청에 응답합니다.</target>
        </trans-unit>
        <trans-unit id="fd5b04a55e6c188f04225c052c3a4ebb3eecf806" translate="yes" xml:space="preserve">
          <source>Index returns JavaScript index i of value v. It panics if v is not a JavaScript object.</source>
          <target state="translated">Index는 값 v의 JavaScript 인덱스 i를 반환합니다. v가 JavaScript 객체가 아닌 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="41cc91c9bcf3f0a08fb627d21f4a77281aee4bad" translate="yes" xml:space="preserve">
          <source>Index returns the index of the first instance of sep in s, or -1 if sep is not present in s.</source>
          <target state="translated">Index는 s에서 sep의 첫 번째 인스턴스의 인덱스를 반환하거나 sep가 s에없는 경우 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1f02d6f4db0fe2bb71d169a720ea48dacd4410f7" translate="yes" xml:space="preserve">
          <source>Index returns the index of the first instance of substr in s, or -1 if substr is not present in s.</source>
          <target state="translated">Index는 s에서 substr의 첫 번째 인스턴스의 인덱스를 반환하거나 s에 substr이없는 경우 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6672a7ad3732041777afcc9d59e94790fa08598a" translate="yes" xml:space="preserve">
          <source>Index returns the index of the palette color closest to c in Euclidean R,G,B,A space.</source>
          <target state="translated">색인은 유클리드 R, G, B, A 공간에서 c에 가장 가까운 팔레트 색상의 색인을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="08cc5090355bf36192f88d52e3809f63b35b1be3" translate="yes" xml:space="preserve">
          <source>Index returns v's i'th element. It panics if v's Kind is not Array, Slice, or String or i is out of range.</source>
          <target state="translated">인덱스는 v의 i 번째 요소를 반환합니다. v의 Kind가 배열, 슬라이스 또는 문자열이 아니거나 i가 범위를 벗어나면 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f604fe204d59450e53c6f0f981bb463a3da262fc" translate="yes" xml:space="preserve">
          <source>Index.Lookup</source>
          <target state="translated">Index.Lookup</target>
        </trans-unit>
        <trans-unit id="693f6afea6d2763baec63c4f683ab836809a8526" translate="yes" xml:space="preserve">
          <source>IndexAny</source>
          <target state="translated">IndexAny</target>
        </trans-unit>
        <trans-unit id="227cd6f0abdfd091813bf35b8fd1dcfbc25cecd9" translate="yes" xml:space="preserve">
          <source>IndexAny interprets s as a sequence of UTF-8-encoded Unicode code points. It returns the byte index of the first occurrence in s of any of the Unicode code points in chars. It returns -1 if chars is empty or if there is no code point in common.</source>
          <target state="translated">IndexAny는 s를 UTF-8로 인코딩 된 유니 코드 코드 포인트의 시퀀스로 해석합니다. 문자의 모든 유니 코드 코드 포인트 중 s로 첫 번째 발생의 바이트 인덱스를 리턴합니다. 문자가 비어 있거나 공통 코드 포인트가 없으면 -1을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="1adf36d0e196212f2787325e2cb626ccc3228c3b" translate="yes" xml:space="preserve">
          <source>IndexAny returns the index of the first instance of any Unicode code point from chars in s, or -1 if no Unicode code point from chars is present in s.</source>
          <target state="translated">IndexAny는 s의 문자에서 유니 코드 코드 포인트의 첫 번째 인스턴스의 인덱스를 반환하거나 s에 유니 코드 코드 포인트가 없으면 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="91d007c3332e259ec2e02f981423ecacc90c6ee6" translate="yes" xml:space="preserve">
          <source>IndexByte</source>
          <target state="translated">IndexByte</target>
        </trans-unit>
        <trans-unit id="c4f06e8f47e53dedfca453887d03a95ac035b5de" translate="yes" xml:space="preserve">
          <source>IndexByte returns the index of the first instance of c in b, or -1 if c is not present in b.</source>
          <target state="translated">IndexByte는 b에서 c의 첫 번째 인스턴스의 인덱스를 반환하거나 b에 c가 없으면 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c369952c4d2f42c9a51eabe33a7908d4c8f60ad4" translate="yes" xml:space="preserve">
          <source>IndexByte returns the index of the first instance of c in s, or -1 if c is not present in s.</source>
          <target state="translated">IndexByte는 s에서 c의 첫 번째 인스턴스의 인덱스를 반환하거나 s에 c가 없으면 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4b29f4c46fd4242b96d7f6d96005476262ea25b4" translate="yes" xml:space="preserve">
          <source>IndexFunc</source>
          <target state="translated">IndexFunc</target>
        </trans-unit>
        <trans-unit id="fd5aa7f0734b2b2162a12de708cba7a93a1ba269" translate="yes" xml:space="preserve">
          <source>IndexFunc interprets s as a sequence of UTF-8-encoded code points. It returns the byte index in s of the first Unicode code point satisfying f(c), or -1 if none do.</source>
          <target state="translated">IndexFunc는 s를 UTF-8로 인코딩 된 코드 포인트의 시퀀스로 해석합니다. f (c)를 만족하는 첫 번째 유니 코드 코드 포인트의 s 단위로 바이트 인덱스를 반환하고, 그렇지 않으면 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="67453fcd073346734a7503bb3d4207a4ffac0a81" translate="yes" xml:space="preserve">
          <source>IndexFunc returns the index into s of the first Unicode code point satisfying f(c), or -1 if none do.</source>
          <target state="translated">IndexFunc는 f (c)를 만족하는 첫 번째 유니 코드 코드 포인트의 s로 인덱스를 반환하거나 없으면 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0404886738141ffe45c4d013ff978a64bde2ba63" translate="yes" xml:space="preserve">
          <source>IndexRune</source>
          <target state="translated">IndexRune</target>
        </trans-unit>
        <trans-unit id="f4318ccac75e1dd461aaa7a9c7842e97a421edce" translate="yes" xml:space="preserve">
          <source>IndexRune interprets s as a sequence of UTF-8-encoded code points. It returns the byte index of the first occurrence in s of the given rune. It returns -1 if rune is not present in s. If r is utf8.RuneError, it returns the first instance of any invalid UTF-8 byte sequence.</source>
          <target state="translated">IndexRune은 s를 UTF-8로 인코딩 된 코드 포인트의 시퀀스로 해석합니다. 주어진 룬의 s에서 첫 번째 발생의 바이트 인덱스를 반환합니다. 룬이 s에 없으면 -1을 리턴합니다. r이 utf8.RuneError이면 유효하지 않은 UTF-8 바이트 시퀀스의 첫 번째 인스턴스를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="042bb768e6a79fc4f2a8939cb46f8d887178fb46" translate="yes" xml:space="preserve">
          <source>IndexRune returns the index of the first instance of the Unicode code point r, or -1 if rune is not present in s. If r is utf8.RuneError, it returns the first instance of any invalid UTF-8 byte sequence.</source>
          <target state="translated">IndexRune은 유니 코드 코드 포인트 r의 첫 번째 인스턴스 인덱스를 반환하거나 룬이 s에 없으면 -1을 반환합니다. r이 utf8.RuneError이면 유효하지 않은 UTF-8 바이트 시퀀스의 첫 번째 인스턴스를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="a85d156f8eef16ea6fae8f47130c09e7ab738f38" translate="yes" xml:space="preserve">
          <source>Indexes into the Header.Ident array.</source>
          <target state="translated">Header.Ident 배열에 인덱스합니다.</target>
        </trans-unit>
        <trans-unit id="bee82bdb7da751fd64eea7f5143956992f5aed77" translate="yes" xml:space="preserve">
          <source>Indices into the Delta arrays inside CaseRanges for case mapping.</source>
          <target state="translated">사례 매핑을 위해 CaseRanges 내의 델타 배열에 대한 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="22023c8031bf3535a364147cd1c4ebacba51eca8" translate="yes" xml:space="preserve">
          <source>Indirect reports whether any pointer indirection was required to get from x to f in x.f.</source>
          <target state="translated">간접은 xf에서 x에서 f로 포인터 간접 지시가 필요한지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="1dbf2dfd2ac6c93be252e418d12775d2db6f53d8" translate="yes" xml:space="preserve">
          <source>Indirect returns the value that v points to. If v is a nil pointer, Indirect returns a zero Value. If v is not a pointer, Indirect returns v.</source>
          <target state="translated">간접은 v가 가리키는 값을 반환합니다. v가 nil 포인터이면 Indirect는 0을 반환합니다. v가 포인터가 아닌 경우 간접은 v를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fe7ad1fbee745b4ca3d08d7729476db7d9fb4fe9" translate="yes" xml:space="preserve">
          <source>Inf returns a complex infinity, complex(+Inf, +Inf).</source>
          <target state="translated">Inf는 복소수 무한대 complex (+ Inf, + Inf)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0125073a5f3757f1dc62bea262918d4c5b3bae8e" translate="yes" xml:space="preserve">
          <source>Inf returns positive infinity if sign &amp;gt;= 0, negative infinity if sign &amp;lt; 0.</source>
          <target state="translated">Inf는 sign&amp;gt; = 0이면 양의 무한대를, sign &amp;lt;0이면 음의 무한대를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fd7feb1c61f7423453cbee79d9998496c4df75f3" translate="yes" xml:space="preserve">
          <source>Infinite recursion can also be triggered by self-referential data structures, such as a slice that contains itself as an element, if that type has a String method. Such pathologies are rare, however, and the package does not protect against them.</source>
          <target state="translated">유형에 String 메소드가있는 경우 자체 참조를 포함하는 슬라이스와 같은 자체 참조 데이터 구조에 의해 무한 재귀가 트리거 될 수도 있습니다. 그러나 그러한 병리학은 드물며 패키지는 그것들을 보호하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4b631f69842530d659306c8f06dbad594a6b1807" translate="yes" xml:space="preserve">
          <source>Info</source>
          <target state="translated">Info</target>
        </trans-unit>
        <trans-unit id="0e2ca261be59b2db86de1819fd95c5c62808d215" translate="yes" xml:space="preserve">
          <source>Info holds result type information for a type-checked package. Only the information for which a map is provided is collected. If the package has type errors, the collected information may be incomplete.</source>
          <target state="translated">Info는 유형 검사 패키지에 대한 결과 유형 정보를 보유합니다. 맵이 제공되는 정보 만 수집됩니다. 패키지에 유형 오류가 있으면 수집 된 정보가 불완전 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="829a6f4d1b71214eb93db4bdc76fb1b790f4e5d1" translate="yes" xml:space="preserve">
          <source>Info logs a message with severity LOG_INFO, ignoring the severity passed to New.</source>
          <target state="translated">Info는 심각도가 LOG_INFO 인 메시지를 기록하며 심각도는 New로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="d0968061a8aa60c3762f0e765c2376d0827896c3" translate="yes" xml:space="preserve">
          <source>Info returns information about properties of basic type b.</source>
          <target state="translated">정보는 기본 유형의 속성에 대한 정보를 반환합니다. b.</target>
        </trans-unit>
        <trans-unit id="4bebef89f6713b109d9329a6bfe51cba5fd0be4f" translate="yes" xml:space="preserve">
          <source>Init establishes the heap invariants required by the other routines in this package. Init is idempotent with respect to the heap invariants and may be called whenever the heap invariants may have been invalidated. The complexity is O(n) where n = h.Len().</source>
          <target state="translated">Init는이 패키지의 다른 루틴에 필요한 힙 불변량을 설정합니다. Init은 힙 불변에 대해 dem 등원이며 힙 불변이 무효화 될 때마다 호출 될 수 있습니다. 복잡도는 O (n)이며 여기서 n = h.Len ()입니다.</target>
        </trans-unit>
        <trans-unit id="e025530212d94f43014839edcd8664101cb1d082" translate="yes" xml:space="preserve">
          <source>Init has no effect if it was already called.</source>
          <target state="translated">이미 호출 된 경우 Init은 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ab8a6a690d98493f29c3a7eded17da06a0fe4963" translate="yes" xml:space="preserve">
          <source>Init initializes a Scanner with a new source and returns s. Error is set to nil, ErrorCount is set to 0, Mode is set to GoTokens, and Whitespace is set to GoWhitespace.</source>
          <target state="translated">Init는 새로운 소스로 검사기를 초기화하고 s를 반환합니다. Error는 nil로, ErrorCount는 0으로, Mode는 GoTokens로, Whitespace는 GoWhitespace로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="38f2f0576d19cc2c5fa27415d0b566e72a9f5fcc" translate="yes" xml:space="preserve">
          <source>Init initializes or clears list l.</source>
          <target state="translated">Init는 목록 l을 초기화하거나 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="4828f42508fc3abcabc5d7577bba28e3151a2a20" translate="yes" xml:space="preserve">
          <source>Init prepares the scanner s to tokenize the text src by setting the scanner at the beginning of src. The scanner uses the file set file for position information and it adds line information for each line. It is ok to re-use the same file when re-scanning the same file as line information which is already present is ignored. Init causes a panic if the file size does not match the src size.</source>
          <target state="translated">Init는 스캐너를 src의 시작 부분에 설정하여 텍스트 src를 토큰 화하도록 스캐너를 준비합니다. 스캐너는 위치 정보에 파일 세트 파일을 사용하고 각 라인에 대한 라인 정보를 추가합니다. 이미 존재하는 회선 정보가 무시 될 때와 동일한 파일을 다시 스캔 할 때 동일한 파일을 재사용해도됩니다. 파일 크기가 src 크기와 일치하지 않으면 Init에서 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1ff5728fd1958fa03cc23f0615bd53c6b8512d71" translate="yes" xml:space="preserve">
          <source>Init registers testing flags. These flags are automatically registered by the &quot;go test&quot; command before running test functions, so Init is only needed when calling functions such as Benchmark without using &quot;go test&quot;.</source>
          <target state="translated">Init은 테스트 플래그를 등록합니다. 이 플래그는 테스트 기능을 실행하기 전에 &quot;go test&quot;명령에 의해 자동으로 등록되므로 &quot;go test&quot;를 사용하지 않고 Benchmark와 같은 기능을 호출 할 때만 Init가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="e71fb65b44dd31464c3ab6d5dc9c1b767849af42" translate="yes" xml:space="preserve">
          <source>Init removes all keys from the map.</source>
          <target state="translated">Init는 맵에서 모든 키를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="2f9d5d06290960b800b664c463e2749afea3e374" translate="yes" xml:space="preserve">
          <source>Init sets the name and error handling property for a flag set. By default, the zero FlagSet uses an empty name and the ContinueOnError error handling policy.</source>
          <target state="translated">Init는 플래그 세트의 이름 및 오류 처리 특성을 설정합니다. 기본적으로 Zero FlagSet은 빈 이름과 ContinueOnError 오류 처리 정책을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1ff277aa8c5f044965228237465cbaf43a54dec6" translate="yes" xml:space="preserve">
          <source>Initial magic number for ELF files.</source>
          <target state="translated">ELF 파일의 초기 매직 번호.</target>
        </trans-unit>
        <trans-unit id="7ceb1ca1dad4f40542d5a478441bc59f2f8873ca" translate="yes" xml:space="preserve">
          <source>Innermost returns the innermost (child) scope containing pos. If pos is not within any scope, the result is nil. The result is also nil for the Universe scope. The result is guaranteed to be valid only if the type-checked AST has complete position information.</source>
          <target state="translated">가장 안쪽은 pos를 포함하는 가장 안쪽 (자식) 범위를 반환합니다. pos가 범위 내에 없으면 결과는 nil입니다. 유니버스 범위에는 결과가 없습니다. 형식 확인 AST에 위치 정보가 완전한 경우에만 결과가 유효합니다.</target>
        </trans-unit>
        <trans-unit id="d3d677ba8b8fb62d3d734397c41c430f5735b25c" translate="yes" xml:space="preserve">
          <source>Input processed by verbs is implicitly space-delimited: the implementation of every verb except %c starts by discarding leading spaces from the remaining input, and the %s verb (and %v reading into a string) stops consuming input at the first space or newline character.</source>
          <target state="translated">동사에 의해 처리 된 입력은 암시 적으로 공백으로 구분됩니다. % c를 제외한 모든 동사의 구현은 나머지 입력에서 선행 공백을 삭제하여 시작하고 % s 동사 (및 % v는 문자열을 읽음)는 첫 번째 공간에서 입력 소비를 중지합니다. 개행 문자.</target>
        </trans-unit>
        <trans-unit id="f2b998d9fdcbc1c4a3ffebeea1625f9214a80db4" translate="yes" xml:space="preserve">
          <source>InputOffset returns the input stream byte offset of the current decoder position. The offset gives the location of the end of the most recently returned token and the beginning of the next token.</source>
          <target state="translated">InputOffset은 현재 디코더 위치의 입력 스트림 바이트 오프셋을 반환합니다. 오프셋은 가장 최근에 반환 된 토큰의 끝 위치와 다음 토큰의 시작 위치를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c6bdbccac97746d550ea930e761dad7ffa800d06" translate="yes" xml:space="preserve">
          <source>Insert attempts to insert a named object obj into the scope s. If the scope already contains an object alt with the same name, Insert leaves the scope unchanged and returns alt. Otherwise it inserts obj and returns nil.</source>
          <target state="translated">Insert는 명명 된 객체 obj를 범위에 삽입하려고 시도합니다. 범위에 이름이 같은 객체 alt가 이미 포함되어 있으면 Insert는 범위를 변경하지 않고 그대로 둡니다. 그렇지 않으면 obj를 삽입하고 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3c51f0bca7bc21285dde2f4365d66539c9045fbd" translate="yes" xml:space="preserve">
          <source>Insert attempts to insert an object obj into scope s. If s already contains an alternative object alt with the same name, Insert leaves s unchanged and returns alt. Otherwise it inserts obj, sets the object's parent scope if not already set, and returns nil.</source>
          <target state="translated">Insert는 객체 obj를 scope에 삽입하려고 시도합니다. s에 이미 동일한 이름의 대체 객체 alt가 포함 된 경우 Insert는 s를 변경하지 않고 그대로 둡니다. 그렇지 않으면 obj를 삽입하고 아직 설정되지 않은 경우 객체의 부모 범위를 설정 한 다음 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e5d297ca4eb4122848b745777ba08d9e98e99026" translate="yes" xml:space="preserve">
          <source>InsertAfter inserts a new element e with value v immediately after mark and returns e. If mark is not an element of l, the list is not modified. The mark must not be nil.</source>
          <target state="translated">InsertAfter는 마크 바로 뒤에 값 v를 가진 새로운 요소 e를 삽입하고 e를 반환합니다. mark가 l의 요소가 아닌 경우 목록이 수정되지 않습니다. 마크는 0이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="f8690dfd3964564996a8ec4c6a534ffd7d8cce51" translate="yes" xml:space="preserve">
          <source>InsertBefore inserts a new element e with value v immediately before mark and returns e. If mark is not an element of l, the list is not modified. The mark must not be nil.</source>
          <target state="translated">InsertBefore는 마크 바로 앞에 값 v를 가진 새로운 요소 e를 삽입하고 e를 반환합니다. mark가 l의 요소가 아닌 경우 목록이 수정되지 않습니다. 마크는 0이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="1a44ed1d9fdf3b19a9445ead705835b2d7701bba" translate="yes" xml:space="preserve">
          <source>Inset returns the rectangle r inset by n, which may be negative. If either of r's dimensions is less than 2*n then an empty rectangle near the center of r will be returned.</source>
          <target state="translated">삽입은 사각형 r을 n만큼 삽입하여 반환하며, 음수 일 수 있습니다. r의 차원 중 하나가 2 * n보다 작은 경우 r 중심 근처의 빈 사각형이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="18ca87afec4298d9de864e32b4eeb6a31786e496" translate="yes" xml:space="preserve">
          <source>Inspect</source>
          <target state="translated">Inspect</target>
        </trans-unit>
        <trans-unit id="165da1fa673b9fd9a581f6c1c726cccbffc7e2ca" translate="yes" xml:space="preserve">
          <source>Inspect traverses an AST in depth-first order: It starts by calling f(node); node must not be nil. If f returns true, Inspect invokes f recursively for each of the non-nil children of node, followed by a call of f(nil).</source>
          <target state="translated">검사는 AST를 깊이 우선 순서로 트래버스합니다. f (node); 노드는 0이 아니어야합니다. f가 true를 반환하면 Inspect는 노드의 넌이 아닌 각 하위 노드에 대해 f를 재귀 적으로 호출 한 다음 f (nil)를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="a6a380194dfce8d967bc921f5f0bd2558e839e1f" translate="yes" xml:space="preserve">
          <source>InstanceOf reports whether v is an instance of type t according to JavaScript's instanceof operator.</source>
          <target state="translated">InstanceOf는 JavaScript의 instanceof 연산자에 따라 v가 t 유형의 인스턴스인지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="ebf808b93582c50b9dee098ffbc7851e8bbd1bc5" translate="yes" xml:space="preserve">
          <source>Int defines an int flag with specified name, default value, and usage string. The return value is the address of an int variable that stores the value of the flag.</source>
          <target state="translated">Int는 지정된 이름, 기본값 및 사용 문자열로 int 플래그를 정의합니다. 리턴 값은 플래그 값을 저장하는 int 변수의 주소입니다.</target>
        </trans-unit>
        <trans-unit id="4a82193f61167eeb73caee70b7d931807aee1e38" translate="yes" xml:space="preserve">
          <source>Int is a 64-bit integer variable that satisfies the Var interface.</source>
          <target state="translated">Int는 Var 인터페이스를 만족하는 64 비트 정수 변수입니다.</target>
        </trans-unit>
        <trans-unit id="af260c99fb6b16af9acf30bb7ef7c67bfd7f461c" translate="yes" xml:space="preserve">
          <source>Int returns a non-negative pseudo-random int from the default Source.</source>
          <target state="translated">Int는 기본 소스에서 음이 아닌 의사 난수 int를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="381ad8d2cdfa2db4d632061cd5638bdb827c118f" translate="yes" xml:space="preserve">
          <source>Int returns a non-negative pseudo-random int.</source>
          <target state="translated">Int는 음이 아닌 의사 난수 int를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="78b2c6c511c1ed56b26a62f7cd24e23bebce41b7" translate="yes" xml:space="preserve">
          <source>Int returns a uniform random value in [0, max). It panics if max &amp;lt;= 0.</source>
          <target state="translated">Int는 [0, max)로 균일 한 랜덤 값을 반환합니다. 최대 &amp;lt;= 0이면 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5333a3a7b26511027f14a3034f5b9a08970c91dc" translate="yes" xml:space="preserve">
          <source>Int returns the result of truncating x towards zero; or nil if x is an infinity. The result is Exact if x.IsInt(); otherwise it is Below for x &amp;gt; 0, and Above for x &amp;lt; 0. If a non-nil *Int argument z is provided, Int stores the result in z instead of allocating a new Int.</source>
          <target state="translated">Int는 x를 0으로 자른 결과를 반환합니다. x가 무한대이면 nil. 결과는 x.IsInt (); 그렇지 않은 경우 x&amp;gt; 0 이하, x &amp;lt;0 이상입니다. 0이 아닌 * Int 인수 z가 제공되면 Int는 새 Int를 할당하는 대신 결과를 z에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="b48fef275365436d3178b531a98b6df9140d4a4e" translate="yes" xml:space="preserve">
          <source>Int returns the value v truncated to an int. It panics if v is not a JavaScript number.</source>
          <target state="translated">Int는 v를 int로 잘린 값을 반환합니다. v가 JavaScript 번호가 아닌 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7aeadc703783366afed8a63b0734b22311f2a7e4" translate="yes" xml:space="preserve">
          <source>Int returns v's underlying value, as an int64. It panics if v's Kind is not Int, Int8, Int16, Int32, or Int64.</source>
          <target state="translated">Int는 v의 기본 값을 int64로 반환합니다. v의 종류가 Int, Int8, Int16, Int32 또는 Int64가 아닌 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="53c091a9597bdba1f2ca46d491f5c108342e031f" translate="yes" xml:space="preserve">
          <source>Int.Scan</source>
          <target state="translated">Int.Scan</target>
        </trans-unit>
        <trans-unit id="5de699e08eb78e768e5b08ea65a2d2d995d6cca4" translate="yes" xml:space="preserve">
          <source>Int.SetString</source>
          <target state="translated">Int.SetString</target>
        </trans-unit>
        <trans-unit id="25863d22096f1ba104e899340881b4d53e78900e" translate="yes" xml:space="preserve">
          <source>Int31 returns a non-negative pseudo-random 31-bit integer as an int32 from the default Source.</source>
          <target state="translated">Int31은 음이 아닌 의사 난수 31 비트 정수를 기본 소스에서 int32로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8668fa86efe442ed5c0ddfb6799eac348a1585d9" translate="yes" xml:space="preserve">
          <source>Int31 returns a non-negative pseudo-random 31-bit integer as an int32.</source>
          <target state="translated">Int31은 음이 아닌 의사 난수 31 비트 정수를 int32로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4ef488a0ec898f126b9413bbb42319fb0eaeff13" translate="yes" xml:space="preserve">
          <source>Int31n returns, as an int32, a non-negative pseudo-random number in [0,n) from the default Source. It panics if n &amp;lt;= 0.</source>
          <target state="translated">Int31n은 기본 소스에서 [0, n)의 음수가 아닌 의사 난수를 int32로 반환합니다. n &amp;lt;= 0이면 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="90d847f9e26c6ab28ce7fd160e1218ad35e875d4" translate="yes" xml:space="preserve">
          <source>Int31n returns, as an int32, a non-negative pseudo-random number in [0,n). It panics if n &amp;lt;= 0.</source>
          <target state="translated">Int31n은 [0, n)의 음수가 아닌 의사 난수를 int32로 반환합니다. n &amp;lt;= 0이면 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="848b71a013b8e0169e247e647c756adf54d70a3d" translate="yes" xml:space="preserve">
          <source>Int32 is a ValueConverter that converts input values to int64, respecting the limits of an int32 value.</source>
          <target state="translated">Int32는 int32 값의 한계를 고려하여 입력 값을 int64로 변환하는 ValueConverter입니다.</target>
        </trans-unit>
        <trans-unit id="40feceb2effc4993d828a64f0bbc7bd4b65472d1" translate="yes" xml:space="preserve">
          <source>Int63 returns a non-negative pseudo-random 63-bit integer as an int64 from the default Source.</source>
          <target state="translated">Int63은 음수가 아닌 의사 난수 63 비트 정수를 기본 소스에서 int64로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="73b13ad335bd8c446e54125036bbdb60110b8a67" translate="yes" xml:space="preserve">
          <source>Int63 returns a non-negative pseudo-random 63-bit integer as an int64.</source>
          <target state="translated">Int63은 음이 아닌 의사 난수 63 비트 정수를 int64로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ccf199104b81302e6aa6420d9d53fbe6d1e5e481" translate="yes" xml:space="preserve">
          <source>Int63n returns, as an int64, a non-negative pseudo-random number in [0,n) from the default Source. It panics if n &amp;lt;= 0.</source>
          <target state="translated">Int63n은 기본 소스에서 [0, n)의 음수가 아닌 의사 난수를 int64로 반환합니다. n &amp;lt;= 0이면 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="adc50ec6888e251cb9eb8237744893f852c6674f" translate="yes" xml:space="preserve">
          <source>Int63n returns, as an int64, a non-negative pseudo-random number in [0,n). It panics if n &amp;lt;= 0.</source>
          <target state="translated">Int63n은 [0, n)의 음수가 아닌 의사 난수를 int64로 반환합니다. n &amp;lt;= 0이면 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="caf7332f4387883214a684cf486e59d1298af5e4" translate="yes" xml:space="preserve">
          <source>Int64 defines an int64 flag with specified name, default value, and usage string. The return value is the address of an int64 variable that stores the value of the flag.</source>
          <target state="translated">Int64는 지정된 이름, 기본값 및 사용 문자열로 int64 플래그를 정의합니다. 리턴 값은 플래그 값을 저장하는 int64 변수의 주소입니다.</target>
        </trans-unit>
        <trans-unit id="5ea42bb5a91b0f37c1c104284dddf7aee6dd3d40" translate="yes" xml:space="preserve">
          <source>Int64 returns the int64 representation of x. If x cannot be represented in an int64, the result is undefined.</source>
          <target state="translated">Int64는 x의 int64 표현을 반환합니다. x를 int64로 표현할 수 없으면 결과는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="024ee0329e5ac0182a79c3f0f817ea471b5da8f4" translate="yes" xml:space="preserve">
          <source>Int64 returns the integer resulting from truncating x towards zero. If math.MinInt64 &amp;lt;= x &amp;lt;= math.MaxInt64, the result is Exact if x is an integer, and Above (x &amp;lt; 0) or Below (x &amp;gt; 0) otherwise. The result is (math.MinInt64, Above) for x &amp;lt; math.MinInt64, and (math.MaxInt64, Below) for x &amp;gt; math.MaxInt64.</source>
          <target state="translated">Int64는 x를 0으로 자른 결과 정수를 반환합니다. math.MinInt64 &amp;lt;= x &amp;lt;= math.MaxInt64 인 경우 x가 정수이면 결과가 정확하고, 그렇지 않으면 위 (x &amp;lt;0) 또는 아래 (x&amp;gt; 0)입니다. 결과는 x &amp;lt;math.MinInt64의 경우 (math.MinInt64, Above)이고 x&amp;gt; math.MaxInt64의 경우 (math.MinInt64, Below)입니다.</target>
        </trans-unit>
        <trans-unit id="a7858f715e5515e9b11682c98c7e956884fa03d3" translate="yes" xml:space="preserve">
          <source>Int64 returns the number as an int64.</source>
          <target state="translated">Int64는 숫자를 int64로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e87b1cbe8a7626b33b6c26f9454e9b97aa48ff20" translate="yes" xml:space="preserve">
          <source>Int64Val returns the Go int64 value of x and whether the result is exact; x must be an Int or an Unknown. If the result is not exact, its value is undefined. If x is Unknown, the result is (0, false).</source>
          <target state="translated">Int64Val은 x의 Go int64 값과 결과가 정확한지 여부를 반환합니다. x는 Int 또는 Unknown이어야합니다. 결과가 정확하지 않으면 값이 정의되지 않습니다. x가 알 수없는 경우 결과는 (0, false)입니다.</target>
        </trans-unit>
        <trans-unit id="e48ba0f308dabec3542a772cd98df7b4a194464a" translate="yes" xml:space="preserve">
          <source>Int64Var defines an int64 flag with specified name, default value, and usage string. The argument p points to an int64 variable in which to store the value of the flag.</source>
          <target state="translated">Int64Var는 지정된 이름, 기본값 및 사용 문자열로 int64 플래그를 정의합니다. 인수 p는 플래그 값을 저장할 int64 변수를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="826fdf675ec889637dd1607e0ecbc7b4617ed6b5" translate="yes" xml:space="preserve">
          <source>IntSize is the size in bits of an int or uint value.</source>
          <target state="translated">IntSize는 int 또는 uint 값의 비트 크기입니다.</target>
        </trans-unit>
        <trans-unit id="7d0ad3a5fc2c5562d1a3d5edaf660d5681e2e7dd" translate="yes" xml:space="preserve">
          <source>IntSlice attaches the methods of Interface to []int, sorting in increasing order.</source>
          <target state="translated">IntSlice는 Interface 메서드를 [] int에 연결하여 오름차순으로 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="259cdcc1487407a0effb8761c09ff465d822351b" translate="yes" xml:space="preserve">
          <source>IntVar defines an int flag with specified name, default value, and usage string. The argument p points to an int variable in which to store the value of the flag.</source>
          <target state="translated">IntVar는 지정된 이름, 기본값 및 사용 문자열로 int 플래그를 정의합니다. 인수 p는 플래그 값을 저장할 int 변수를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="e927198b4dfea79ca477c6ca320b7977e5f907d8" translate="yes" xml:space="preserve">
          <source>Integer flags accept 1234, 0664, 0x1234 and may be negative. Boolean flags may be:</source>
          <target state="translated">정수 플래그는 1234, 0664, 0x1234를 허용하며 음수 일 수 있습니다. 부울 플래그는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d8d2cb0f1ba846253e8f8508e7b268037f761677" translate="yes" xml:space="preserve">
          <source>Integer limit values.</source>
          <target state="translated">정수 한계 값.</target>
        </trans-unit>
        <trans-unit id="8e6549b1b15bddbc7e4ca51ecb54082a0c50f802" translate="yes" xml:space="preserve">
          <source>Integer:</source>
          <target state="translated">Integer:</target>
        </trans-unit>
        <trans-unit id="8ef45f34654a956038b7d2e46f7b980bceca0a1e" translate="yes" xml:space="preserve">
          <source>IntegerType is here for the purposes of documentation only. It is a stand-in for any integer type: int, uint, int8 etc.</source>
          <target state="translated">IntegerType은 문서 목적으로 만 사용됩니다. int, uint, int8 등의 정수 유형에 대한 독립형입니다.</target>
        </trans-unit>
        <trans-unit id="5a289c0331a1e2ae1cddd468bdbd08515a751488" translate="yes" xml:space="preserve">
          <source>Integers are transmitted two ways: arbitrary precision signed integers or arbitrary precision unsigned integers. There is no int8, int16 etc. discrimination in the gob format; there are only signed and unsigned integers. As described below, the transmitter sends the value in a variable-length encoding; the receiver accepts the value and stores it in the destination variable. Floating-point numbers are always sent using IEEE-754 64-bit precision (see below).</source>
          <target state="translated">정수는 임의의 정밀도 부호있는 정수 또는 임의의 정밀도 부호없는 정수의 두 가지 방법으로 전송됩니다. gob 형식에는 int8, int16 등의 차별이 없습니다. 부호있는 정수와 부호없는 정수만 있습니다. 후술하는 바와 같이, 송신기는 가변 길이 인코딩으로 값을 전송한다; 수신자는 값을 받아 대상 변수에 저장합니다. 부동 소수점 숫자는 항상 IEEE-754 64 비트 정밀도를 사용하여 전송됩니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="8a7e153030b338cdad7a41aa466f441af45e4a11" translate="yes" xml:space="preserve">
          <source>Interface represents a mapping between network interface name and index. It also represents network interface facility information.</source>
          <target state="translated">인터페이스는 네트워크 인터페이스 이름과 색인 간의 매핑을 나타냅니다. 네트워크 인터페이스 기능 정보도 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6da3607f32beaa93e64c1a37a2f36fbed997c327" translate="yes" xml:space="preserve">
          <source>Interface returns v's current value as an interface{}. It is equivalent to:</source>
          <target state="translated">Interface는 v의 현재 값을 interface {}로 반환합니다. 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5ea5c3979b46b5a2713cc2d1786a81b1f8ec63c2" translate="yes" xml:space="preserve">
          <source>Interface types are not checked for compatibility; all interface types are treated, for transmission, as members of a single &quot;interface&quot; type, analogous to int or []byte - in effect they're all treated as interface{}. Interface values are transmitted as a string identifying the concrete type being sent (a name that must be pre-defined by calling Register), followed by a byte count of the length of the following data (so the value can be skipped if it cannot be stored), followed by the usual encoding of concrete (dynamic) value stored in the interface value. (A nil interface value is identified by the empty string and transmits no value.) Upon receipt, the decoder verifies that the unpacked concrete item satisfies the interface of the receiving variable.</source>
          <target state="translated">인터페이스 유형은 호환성을 확인하지 않습니다. 모든 인터페이스 유형은 전송을 위해 int 또는 [] byte와 유사한 단일 &quot;인터페이스&quot;유형의 멤버로 처리됩니다. 사실상 모든 인터페이스 유형은 인터페이스 {}로 취급됩니다. 인터페이스 값은 전송되는 구체적인 유형 (Register를 호출하여 사전 정의해야하는 이름)을 식별하는 문자열로 전송되고, 다음 데이터 길이의 바이트 수가 뒤 따릅니다 (따라서 값을 건너 뛸 수없는 경우 건너 뛸 수 있음) 인터페이스 값에 저장된 콘크리트 (동적) 값의 일반적인 인코딩이 뒤 따릅니다. (없음 인터페이스 값은 빈 문자열로 식별되며 값을 전송하지 않습니다.) 수신시, 디코더는 언 패킹 된 콘크리트 아이템이 수신 변수의 인터페이스를 만족하는지 검증합니다.</target>
        </trans-unit>
        <trans-unit id="74b4a1f2cd95d6ac03afcfd27826497cd84b5ae7" translate="yes" xml:space="preserve">
          <source>Interface values are deeply equal if they hold deeply equal concrete values.</source>
          <target state="translated">인터페이스 값이 매우 동일한 콘크리트 값을 보유하는 경우 인터페이스 값이 동일합니다.</target>
        </trans-unit>
        <trans-unit id="09203e8778d59b495323467d890a95f5807f26bf" translate="yes" xml:space="preserve">
          <source>Interface values encode as the value contained in the interface. A nil interface value encodes as the null JSON value.</source>
          <target state="translated">인터페이스 값은 인터페이스에 포함 된 값으로 인코딩됩니다. nil 인터페이스 값은 null JSON 값으로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="360b50370b24932254b26c7af3e111445c188db0" translate="yes" xml:space="preserve">
          <source>InterfaceAddrs returns a list of the system's unicast interface addresses.</source>
          <target state="translated">InterfaceAddrs는 시스템의 유니 캐스트 인터페이스 주소 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9ce937dfbe60c7ef5a110a8b5806627105e626f1" translate="yes" xml:space="preserve">
          <source>InterfaceByIndex returns the interface specified by index.</source>
          <target state="translated">InterfaceByIndex는 index로 지정된 인터페이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4245d4428eaccf8da6182470aec7d558cea28a53" translate="yes" xml:space="preserve">
          <source>InterfaceByName returns the interface specified by name.</source>
          <target state="translated">InterfaceByName은 이름으로 지정된 인터페이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a63d53fbc696efd4a28db884d8645a21dcabe121" translate="yes" xml:space="preserve">
          <source>InterfaceData returns the interface v's value as a uintptr pair. It panics if v's Kind is not Interface.</source>
          <target state="translated">InterfaceData는 인터페이스 v의 값을 uintptr 쌍으로 리턴합니다. v의 종류가 인터페이스가 아닌 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="470a021de3b9df70021376a7834ee99ab5ab1f2e" translate="yes" xml:space="preserve">
          <source>Interfaces returns a list of the system's network interfaces.</source>
          <target state="translated">인터페이스는 시스템의 네트워크 인터페이스 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a60781d644f0c18cd790184e8cc93bbf04ff58fe" translate="yes" xml:space="preserve">
          <source>Intersect returns the largest rectangle contained by both r and s. If the two rectangles do not overlap then the zero rectangle will be returned.</source>
          <target state="translated">교차는 r과 s에 포함 된 가장 큰 사각형을 반환합니다. 두 사각형이 겹치지 않으면 0 사각형이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="37b82affb5d88e1d235360ffb5b4876b9c358ef4" translate="yes" xml:space="preserve">
          <source>Intn</source>
          <target state="translated">Intn</target>
        </trans-unit>
        <trans-unit id="54d0c13534e6e00abbb2d04b4cb149c7d0ddea38" translate="yes" xml:space="preserve">
          <source>Intn returns, as an int, a non-negative pseudo-random number in [0,n) from the default Source. It panics if n &amp;lt;= 0.</source>
          <target state="translated">Intn은 기본 소스에서 [0, n)의 음수가 아닌 의사 난수를 정수로 반환합니다. n &amp;lt;= 0이면 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8f26feb5337a07fc6e35ec73e1c6b06a4a8f7c21" translate="yes" xml:space="preserve">
          <source>Intn returns, as an int, a non-negative pseudo-random number in [0,n). It panics if n &amp;lt;= 0.</source>
          <target state="translated">Intn은 [0, n)의 음수가 아닌 의사 난수를 정수로 반환합니다. n &amp;lt;= 0이면 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="b7f44e53c873fdc1db7cef7777af521f4a3b60c1" translate="yes" xml:space="preserve">
          <source>Ints</source>
          <target state="translated">Ints</target>
        </trans-unit>
        <trans-unit id="0d62fa520893beed143100d8873cdbc43cfe7428" translate="yes" xml:space="preserve">
          <source>Ints sorts a slice of ints in increasing order.</source>
          <target state="translated">Ints는 int 슬라이스를 오름차순으로 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="00382ca46ab71a1b23e2790f3cf0a66b6faa90df" translate="yes" xml:space="preserve">
          <source>IntsAreSorted</source>
          <target state="translated">IntsAreSorted</target>
        </trans-unit>
        <trans-unit id="d11bf023986ecfce333bd8a5477d90f31eb1db0a" translate="yes" xml:space="preserve">
          <source>IntsAreSorted tests whether a slice of ints is sorted in increasing order.</source>
          <target state="translated">IntsAreSorted는 int 슬라이스가 오름차순으로 정렬되는지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="e6124bd83c6b099c79f4ac3379192d76121e3dfb" translate="yes" xml:space="preserve">
          <source>Inv sets z to 1/x and returns z.</source>
          <target state="translated">Inv는 z를 1 / x로 설정하고 z를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="57f0200085fa1268ae261758bfb7dee5795a5704" translate="yes" xml:space="preserve">
          <source>InvalidByteError values describe errors resulting from an invalid byte in a hex string.</source>
          <target state="translated">InvalidByteError 값은 16 진 문자열에서 유효하지 않은 바이트로 인한 오류를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="fc945344ffab3c8e0685a8f6f0b347b0e1b5f04c" translate="yes" xml:space="preserve">
          <source>Invoke does a JavaScript call of the value v with the given arguments. It panics if v is not a JavaScript function. The arguments get mapped to JavaScript values according to the ValueOf function.</source>
          <target state="translated">Invoke는 주어진 인수를 사용하여 값 v의 JavaScript 호출을 수행합니다. v가 JavaScript 함수가 아닌 경우 패닉 상태가됩니다. 인수는 ValueOf 함수에 따라 JavaScript 값에 맵핑됩니다.</target>
        </trans-unit>
        <trans-unit id="a8bc24ce97a4c19ceec821a6c13e305d4cc7093a" translate="yes" xml:space="preserve">
          <source>Invoking the JavaScript function will synchronously call the Go function fn with the value of JavaScript's &quot;this&quot; keyword and the arguments of the invocation. The return value of the invocation is the result of the Go function mapped back to JavaScript according to ValueOf.</source>
          <target state="translated">JavaScript 함수를 호출하면 JavaScript의 &quot;this&quot;키워드 값과 호출 인수를 사용하여 Go 함수 fn을 동 기적으로 호출합니다. 호출의 리턴 값은 ValueOf에 따라 JavaScript로 다시 맵핑 된 Go 함수의 결과입니다.</target>
        </trans-unit>
        <trans-unit id="b80342e2833069978eb2ebabac8e59ca1a3fbfc5" translate="yes" xml:space="preserve">
          <source>Is reports whether any error in err's chain matches target.</source>
          <target state="translated">오류 체인의 오류가 대상과 일치하는지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="2dcad3f5fb898f44a28ca9cc90eb869f037180e6" translate="yes" xml:space="preserve">
          <source>Is reports whether the rune is in the specified table of ranges.</source>
          <target state="translated">룬이 지정된 범위 테이블에 있는지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="d895a1147fb9e99c093e2c8e3aa2a3a161a62599" translate="yes" xml:space="preserve">
          <source>Is unwraps its first argument sequentially looking for an error that matches the second. It reports whether it finds a match. It should be used in preference to simple equality checks:</source>
          <target state="translated">Is는 첫 번째 인수를 순차적으로 풀어서 두 번째 인수와 일치하는 오류를 찾습니다. 일치하는 것이 있는지보고합니다. 단순 평등 검사보다 우선적으로 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="4240feb2e7eac03ab7672bf3d52cbd0df60964bf" translate="yes" xml:space="preserve">
          <source>IsAbs</source>
          <target state="translated">IsAbs</target>
        </trans-unit>
        <trans-unit id="6ba3e5deb5d3ce3b158c2019d9e58f42637cf610" translate="yes" xml:space="preserve">
          <source>IsAbs reports whether the URL is absolute. Absolute means that it has a non-empty scheme.</source>
          <target state="translated">IsAbs는 URL이 절대적인지 여부를보고합니다. 절대는 비어 있지 않은 체계가 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="36a0d5f9413d1e35ae6366ef607edd836694bee0" translate="yes" xml:space="preserve">
          <source>IsAbs reports whether the path is absolute.</source>
          <target state="translated">IsAbs는 경로가 절대적인지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="e1eaf7841a07f287f076c00cb20e44f9651ff13f" translate="yes" xml:space="preserve">
          <source>IsAlias reports whether obj is an alias name for a type.</source>
          <target state="translated">IsAlias는 obj가 유형의 별칭 이름인지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="0e84022f347580b90f81c69d614f481de5c48849" translate="yes" xml:space="preserve">
          <source>IsBuiltin reports whether the corresponding expression denotes a (possibly parenthesized) built-in function.</source>
          <target state="translated">IsBuiltin은 해당 표현식이 (괄호로 묶은) 내장 함수를 나타내는 지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="c915051f076524ecaa2f5d332eb2bb4d2765eefa" translate="yes" xml:space="preserve">
          <source>IsCommand reports whether the package is considered a command to be installed (not just a library). Packages named &quot;main&quot; are treated as commands.</source>
          <target state="translated">IsCommand는 패키지가 라이브러리가 아닌 설치할 명령으로 간주되는지 여부를보고합니다. &quot;main&quot;이라는 패키지는 명령으로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="2cd3abc2f41e5f98828e0ebaee47dfbcd10387ad" translate="yes" xml:space="preserve">
          <source>IsControl reports whether the rune is a control character. The C (Other) Unicode category includes more code points such as surrogates; use Is(C, r) to test for them.</source>
          <target state="translated">IsControl은 룬이 제어 문자인지 여부를보고합니다. C (기타) 유니 코드 범주에는 서로 게이트와 같은 더 많은 코드 포인트가 포함됩니다. 테스트하려면 Is (C, r)를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c746a0807bba76d32760f9142c884716d0699c51" translate="yes" xml:space="preserve">
          <source>IsDigit reports whether the rune is a decimal digit.</source>
          <target state="translated">IsDigit는 룬이 10 진수인지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="3dc4a185454e26efa4716393eed4775f2e55fe7c" translate="yes" xml:space="preserve">
          <source>IsDir reports whether m describes a directory. That is, it tests for the ModeDir bit being set in m.</source>
          <target state="translated">IsDir은 m이 디렉토리를 설명하는지 여부를보고합니다. 즉, m으로 설정된 ModeDir 비트를 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="5fd80e2b1854e3452cd6bfd7234aa8fa8ddcdc63" translate="yes" xml:space="preserve">
          <source>IsEmptyTree reports whether this tree (node) is empty of everything but space.</source>
          <target state="translated">IsEmptyTree는이 트리 (노드)가 공간을 제외한 모든 것이 비어 있는지보고합니다.</target>
        </trans-unit>
        <trans-unit id="cd43f5281afe605e10c23fa5e5c73089248f9feb" translate="yes" xml:space="preserve">
          <source>IsEnabled reports whether tracing is enabled. The information is advisory only. The tracing status may have changed by the time this function returns.</source>
          <target state="translated">IsEnabled는 추적 사용 여부를보고합니다. 정보는 단지 자문 일뿐입니다. 이 함수가 리턴 될 때마다 추적 상태가 변경되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39e18e7e1b9d6fbe4b3f09d74593704f059a0c0a" translate="yes" xml:space="preserve">
          <source>IsEncryptedPEMBlock returns if the PEM block is password encrypted.</source>
          <target state="translated">PEM 블록이 암호로 암호화되어 있으면 IsEncryptedPEMBlock이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="bc66205543d841780222acbebc983e058e70415a" translate="yes" xml:space="preserve">
          <source>IsExist returns a boolean indicating whether the error is known to report that a file or directory already exists. It is satisfied by ErrExist as well as some syscall errors.</source>
          <target state="translated">IsExist는 오류가 파일 또는 디렉토리가 이미 존재한다고보고하는지 여부를 나타내는 부울을 리턴합니다. 일부 syscall 오류뿐만 아니라 ErrExist에 의해 만족됩니다.</target>
        </trans-unit>
        <trans-unit id="fc56fa9983588228bd9fa3b0b5a7931ac3cb75f1" translate="yes" xml:space="preserve">
          <source>IsExported reports whether id starts with an upper-case letter.</source>
          <target state="translated">IsExported는 id가 대문자로 시작하는지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="3c6d4e31e0d52ed1d2823481dfa21ed80c9b776d" translate="yes" xml:space="preserve">
          <source>IsExported reports whether name starts with an upper-case letter.</source>
          <target state="translated">IsExported는 이름이 대문자로 시작하는지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="504274dd55fc2a273ebc2bd501f5695303ffe229" translate="yes" xml:space="preserve">
          <source>IsField reports whether the variable is a struct field.</source>
          <target state="translated">IsField는 변수가 구조체 필드인지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="d9bdbeb50a8c37eb5d00e31069315d70d10359d6" translate="yes" xml:space="preserve">
          <source>IsGlobalUnicast reports whether ip is a global unicast address.</source>
          <target state="translated">IsGlobalUnicast는 ip가 글로벌 유니 캐스트 주소인지보고합니다.</target>
        </trans-unit>
        <trans-unit id="d72f8c1ccd0ac092185d981b6c61eacc3c121ef6" translate="yes" xml:space="preserve">
          <source>IsGraphic</source>
          <target state="translated">IsGraphic</target>
        </trans-unit>
        <trans-unit id="56022820abfd812a684373d7b12ff29c87996877" translate="yes" xml:space="preserve">
          <source>IsGraphic reports whether the rune is defined as a Graphic by Unicode. Such characters include letters, marks, numbers, punctuation, symbols, and spaces, from categories L, M, N, P, S, Zs.</source>
          <target state="translated">IsGraphic은 룬이 Unicode로 그래픽으로 정의되어 있는지 여부를보고합니다. 이러한 문자에는 L, M, N, P, S, Zs 범주의 문자, 마크, 숫자, 문장 부호, 기호 및 공백이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="3bed5baca126f10003a7fc44f4e55808b330feda" translate="yes" xml:space="preserve">
          <source>IsGraphic reports whether the rune is defined as a Graphic by Unicode. Such characters include letters, marks, numbers, punctuation, symbols, and spaces, from categories L, M, N, P, S, and Zs.</source>
          <target state="translated">IsGraphic은 룬이 Unicode로 그래픽으로 정의되어 있는지 여부를보고합니다. 이러한 문자에는 L, M, N, P, S 및 Z 범주의 문자, 마크, 숫자, 문장 부호, 기호 및 공백이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="93d167ded0e381246ad35c4922eb8c26e2a4fc55" translate="yes" xml:space="preserve">
          <source>IsIdentifier reports whether name is a Go identifier, that is, a non-empty string made up of letters, digits, and underscores, where the first character is not a digit. Keywords are not identifiers.</source>
          <target state="translated">IsIdentifier는 name이 Go 식별자인지 여부, 즉 첫 문자가 숫자가 아닌 문자, 숫자 및 밑줄로 구성된 비어 있지 않은 문자열인지 여부를보고합니다. 키워드는 식별자가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="679d30c5187a96f463dfbcdfb594ecc9983403ef" translate="yes" xml:space="preserve">
          <source>IsInf reports whether either real(x) or imag(x) is an infinity.</source>
          <target state="translated">IsInf는 real (x) 또는 imag (x)가 무한대인지보고합니다.</target>
        </trans-unit>
        <trans-unit id="13dd75a92325ad267d0a2fa14c6cb50f24a9dd7b" translate="yes" xml:space="preserve">
          <source>IsInf reports whether f is an infinity, according to sign. If sign &amp;gt; 0, IsInf reports whether f is positive infinity. If sign &amp;lt; 0, IsInf reports whether f is negative infinity. If sign == 0, IsInf reports whether f is either infinity.</source>
          <target state="translated">IsInf는 부호에 따라 f가 무한대인지 여부를보고합니다. 부호가 0보다 크면 IsInf는 f가 양의 무한대인지 여부를보고합니다. 부호 &amp;lt;0이면 IsInf는 f가 음의 무한대인지 여부를보고합니다. sign == 0이면 IsInf는 f가 무한대인지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="8e1783a22a02fb29f43965c4b4c975183d78e4dd" translate="yes" xml:space="preserve">
          <source>IsInf reports whether x is +Inf or -Inf.</source>
          <target state="translated">IsInf는 x가 + Inf인지 -Inf인지보고합니다.</target>
        </trans-unit>
        <trans-unit id="1b05edd34484393d17b771d708b4b2dd276cb90e" translate="yes" xml:space="preserve">
          <source>IsInt reports whether the denominator of x is 1.</source>
          <target state="translated">IsInt는 x의 분모가 1인지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="63c80063be9af3740f75431caecb4e56ba22484c" translate="yes" xml:space="preserve">
          <source>IsInt reports whether x is an integer. &amp;plusmn;Inf values are not integers.</source>
          <target state="translated">IsInt는 x가 정수인지 여부를보고합니다. &amp;plusmn; Inf 값은 정수가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="00a1b79e443959417f450c9b16cf5f48a8929d0f" translate="yes" xml:space="preserve">
          <source>IsInt64 reports whether x can be represented as an int64.</source>
          <target state="translated">IsInt64는 x를 int64로 표시 할 수 있는지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="ab97d0f94b18fe8f3b28313a45a877858cc4fa50" translate="yes" xml:space="preserve">
          <source>IsInterface reports whether typ is an interface type.</source>
          <target state="translated">IsInterface는 typ가 인터페이스 유형인지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="c6bdcbe107886851b028b532be31d52568400157" translate="yes" xml:space="preserve">
          <source>IsInterfaceLocalMulticast reports whether ip is an interface-local multicast address.</source>
          <target state="translated">IsInterfaceLocalMulticast는 ip가 인터페이스 로컬 멀티 캐스트 주소인지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="203bcfa02f0ff2531137c0e97e09e91145ccf765" translate="yes" xml:space="preserve">
          <source>IsKeyword reports whether name is a Go keyword, such as &quot;func&quot; or &quot;return&quot;.</source>
          <target state="translated">IsKeyword는 name이 &quot;func&quot;또는 &quot;return&quot;과 같은 Go 키워드인지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="b1af467f9e4844b489b1e4d07d7f23c5a24e49f8" translate="yes" xml:space="preserve">
          <source>IsKeyword returns true for tokens corresponding to keywords; it returns false otherwise.</source>
          <target state="translated">IsKeyword는 키워드에 해당하는 토큰에 대해 true를 반환합니다. 그렇지 않으면 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9e659e799b643d193bc338fa878bc56e93c2043d" translate="yes" xml:space="preserve">
          <source>IsLetter reports whether the rune is a letter (category L).</source>
          <target state="translated">IsLetter는 룬 문자인지 여부를보고합니다 (범주 L).</target>
        </trans-unit>
        <trans-unit id="796f0c2eac4ef075bdac49252f1a8a9437f7cb5a" translate="yes" xml:space="preserve">
          <source>IsLinkLocalMulticast reports whether ip is a link-local multicast address.</source>
          <target state="translated">IsLinkLocalMulticast는 ip가 링크 로컬 멀티 캐스트 주소인지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="bb398472e4891951632d23a856db9700a4f1260f" translate="yes" xml:space="preserve">
          <source>IsLinkLocalUnicast reports whether ip is a link-local unicast address.</source>
          <target state="translated">IsLinkLocalUnicast는 ip가 링크 로컬 유니 캐스트 주소인지보고합니다.</target>
        </trans-unit>
        <trans-unit id="338823e775821fbbffd934b6dc8f8c7b06cf31f5" translate="yes" xml:space="preserve">
          <source>IsLiteral returns true for tokens corresponding to identifiers and basic type literals; it returns false otherwise.</source>
          <target state="translated">IsLiteral은 식별자 및 기본 유형 리터럴에 해당하는 토큰에 대해 true를 반환합니다. 그렇지 않으면 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a302aa5062a5a2939f950e77a3b1bd2cffbbb134" translate="yes" xml:space="preserve">
          <source>IsLocalImport reports whether the import path is a local import path, like &quot;.&quot;, &quot;..&quot;, &quot;./foo&quot;, or &quot;../foo&quot;.</source>
          <target state="translated">IsLocalImport는 가져 오기 경로가 &quot;.&quot;, &quot;..&quot;, &quot;./foo&quot;또는 &quot;../foo&quot;와 같은 로컬 가져 오기 경로인지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="a279a0dd486da312eb888a933fcd3c106d5ddf1b" translate="yes" xml:space="preserve">
          <source>IsLoopback reports whether ip is a loopback address.</source>
          <target state="translated">IsLoopback은 ip가 루프백 주소인지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="4c6115a445a46684f9b4821abab1454dcf00a510" translate="yes" xml:space="preserve">
          <source>IsLower reports whether the rune is a lower case letter.</source>
          <target state="translated">IsLower는 룬 문자가 소문자인지보고합니다.</target>
        </trans-unit>
        <trans-unit id="e316f3e3a4a4a943e13f969fe03fe3e6888a42f0" translate="yes" xml:space="preserve">
          <source>IsMark reports whether the rune is a mark character (category M).</source>
          <target state="translated">IsMark는 룬이 마크 문자인지 여부를보고합니다 (범주 M).</target>
        </trans-unit>
        <trans-unit id="e919a8a1e5af711657ece2a09a282e053c84e876" translate="yes" xml:space="preserve">
          <source>IsMulticast reports whether ip is a multicast address.</source>
          <target state="translated">IsMulticast는 ip가 멀티 캐스트 주소인지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="0d71475a6ac8cde45586a2e1ee4e9f1a73195c46" translate="yes" xml:space="preserve">
          <source>IsNaN reports whether either real(x) or imag(x) is NaN and neither is an infinity.</source>
          <target state="translated">IsNaN은 real (x) 또는 imag (x)가 NaN인지 무한대도 아닌지보고합니다.</target>
        </trans-unit>
        <trans-unit id="51cb1fb375010c76e1d272e937551b9aa294ed29" translate="yes" xml:space="preserve">
          <source>IsNaN reports whether f is an IEEE 754 &amp;ldquo;not-a-number&amp;rdquo; value.</source>
          <target state="translated">IsNaN은 f가 IEEE 754 &quot;숫자가 아님&quot;값인지보고합니다.</target>
        </trans-unit>
        <trans-unit id="8a70a6c8c78f197d95d9931060aaaff0e1ad7ace" translate="yes" xml:space="preserve">
          <source>IsNil reports whether its argument v is nil. The argument must be a chan, func, interface, map, pointer, or slice value; if it is not, IsNil panics. Note that IsNil is not always equivalent to a regular comparison with nil in Go. For example, if v was created by calling ValueOf with an uninitialized interface variable i, i==nil will be true but v.IsNil will panic as v will be the zero Value.</source>
          <target state="translated">IsNil은 인수 v가 nil인지보고합니다. 인수는 chan, func, interface, map, pointer 또는 slice 값이어야합니다. 그렇지 않으면 IsNil 패닉이 발생합니다. IsNil이 Go에서 nil을 정기적으로 비교하는 것과 항상 같지는 않습니다. 예를 들어 초기화되지 않은 인터페이스 변수 i를 사용하여 ValueOf를 호출하여 v를 만든 경우, i == nil은 true이지만 v.IsNil은 v가 0이되기 때문에 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="d1cbf137d274a495776ae13213f6abf32b87d01c" translate="yes" xml:space="preserve">
          <source>IsNil reports whether the corresponding expression denotes the predeclared value nil.</source>
          <target state="translated">IsNil은 해당식이 미리 선언 된 값 nil을 나타내는 지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="299ff42ffbb3020ccb3e165c3f47990aa016cf3b" translate="yes" xml:space="preserve">
          <source>IsNotExist</source>
          <target state="translated">IsNotExist</target>
        </trans-unit>
        <trans-unit id="03c20e37da945e513d60a4c872afa073a5099855" translate="yes" xml:space="preserve">
          <source>IsNotExist returns a boolean indicating whether the error is known to report that a file or directory does not exist. It is satisfied by ErrNotExist as well as some syscall errors.</source>
          <target state="translated">IsNotExist는 파일이나 디렉토리가 존재하지 않는다는 오류가보고되는지 여부를 나타내는 부울을 리턴합니다. 일부 syscall 오류뿐만 아니라 ErrNotExist에 의해 만족됩니다.</target>
        </trans-unit>
        <trans-unit id="f2c323038256b2a2953181c6a475ccd896ada404" translate="yes" xml:space="preserve">
          <source>IsNumber reports whether the rune is a number (category N).</source>
          <target state="translated">IsNumber는 룬이 숫자인지 (범주 N)보고합니다.</target>
        </trans-unit>
        <trans-unit id="245475f668f23bbed41324e2de1b4948cc531ddc" translate="yes" xml:space="preserve">
          <source>IsOneOf reports whether the rune is a member of one of the ranges. The function &quot;In&quot; provides a nicer signature and should be used in preference to IsOneOf.</source>
          <target state="translated">IsOneOf는 룬이 범위 중 하나의 구성원인지 여부를보고합니다. &quot;In&quot;기능은 더 나은 서명을 제공하며 IsOneOf보다 우선적으로 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="a20bd2f5568b340e7370b04b798bc3f83596bcce" translate="yes" xml:space="preserve">
          <source>IsOperator returns true for tokens corresponding to operators and delimiters; it returns false otherwise.</source>
          <target state="translated">IsOperator는 연산자 및 구분 기호에 해당하는 토큰에 대해 true를 반환합니다. 그렇지 않으면 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="73c5624da9ca6fbf3e420dbf86786a852cc89a14" translate="yes" xml:space="preserve">
          <source>IsPathSeparator reports whether c is a directory separator character.</source>
          <target state="translated">IsPathSeparator는 c가 디렉토리 구분 문자인지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="8bd40ac27999a79bc28cf90f839e43d8f9372279" translate="yes" xml:space="preserve">
          <source>IsPermission returns a boolean indicating whether the error is known to report that permission is denied. It is satisfied by ErrPermission as well as some syscall errors.</source>
          <target state="translated">IsPermission은 권한이 거부되었음을보고하는 오류가 알려져 있는지 여부를 나타내는 부울을 반환합니다. 일부 syscall 오류뿐만 아니라 ErrPermission에 의해 만족됩니다.</target>
        </trans-unit>
        <trans-unit id="e48f3df15b49da83d51099ad5b3eb8bbfd8edc75" translate="yes" xml:space="preserve">
          <source>IsPredeclared reports whether s is a predeclared identifier.</source>
          <target state="translated">IsPredeclared는 s가 사전 선언 된 식별자인지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="36ebaf4d189aca534d273d48d5ddeec782d7bed9" translate="yes" xml:space="preserve">
          <source>IsPrint</source>
          <target state="translated">IsPrint</target>
        </trans-unit>
        <trans-unit id="9798b863454466bfa901e359486dca8125aebd8e" translate="yes" xml:space="preserve">
          <source>IsPrint reports whether the rune is defined as printable by Go, with the same definition as unicode.IsPrint: letters, numbers, punctuation, symbols and ASCII space.</source>
          <target state="translated">IsPrint는 룬이 유니 코드와 동일한 정의로 Go에 의해 인쇄 가능한 것으로 정의되는지 여부를보고합니다. IsPrint : 문자, 숫자, 문장 부호, 기호 및 ASCII 공간.</target>
        </trans-unit>
        <trans-unit id="98481c27a5fae0a861fa7de3b6778c4d86a82e18" translate="yes" xml:space="preserve">
          <source>IsPrint reports whether the rune is defined as printable by Go. Such characters include letters, marks, numbers, punctuation, symbols, and the ASCII space character, from categories L, M, N, P, S and the ASCII space character. This categorization is the same as IsGraphic except that the only spacing character is ASCII space, U+0020.</source>
          <target state="translated">IsPrint는 Go에 의해 룬이 인쇄 가능한 것으로 정의되어 있는지보고합니다. 이러한 문자에는 문자, 마크, 숫자, 문장 부호, 기호 및 ASCII 공백 문자 (카테고리 L, M, N, P, S 및 ASCII 공백 문자)가 포함됩니다. 이 분류는 간격 문자 만 ASCII 공간 U + 0020이라는 점을 제외하고 IsGraphic과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="8d669f2d873d45ac65ae33ba5fc527f66e56a570" translate="yes" xml:space="preserve">
          <source>IsPunct reports whether the rune is a Unicode punctuation character (category P).</source>
          <target state="translated">IsPunct는 룬이 유니 코드 문장 부호 문자 (범주 P)인지보고합니다.</target>
        </trans-unit>
        <trans-unit id="09f51db22f739274d216b281ce628857122cde77" translate="yes" xml:space="preserve">
          <source>IsRegular reports whether m describes a regular file. That is, it tests that no mode type bits are set.</source>
          <target state="translated">IsRegular는 m이 일반 파일을 설명하는지 여부를보고합니다. 즉, 모드 유형 비트가 설정되지 않았는지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="7aa02fb0658d675b5c73f5d774f227af20e5eda3" translate="yes" xml:space="preserve">
          <source>IsScanValue is equivalent to IsValue. It exists for compatibility.</source>
          <target state="translated">IsScanValue는 IsValue와 같습니다. 호환성을 위해 존재합니다.</target>
        </trans-unit>
        <trans-unit id="02fd007fd97349a8b2fafa3e48b3fe7f504ea24c" translate="yes" xml:space="preserve">
          <source>IsSorted reports whether data is sorted.</source>
          <target state="translated">IsSorted는 데이터 정렬 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="514d21d401add5f58b109e05d3a8a2615962f831" translate="yes" xml:space="preserve">
          <source>IsSpace reports whether the rune is a space character as defined by Unicode's White Space property; in the Latin-1 space this is</source>
          <target state="translated">IsSpace는 룬이 유니 코드의 공백 속성으로 정의 된 공백 문자인지 여부를보고합니다. 라틴 -1 공간에서 이것은</target>
        </trans-unit>
        <trans-unit id="b8364c32e39bc01deb2db29de008f790b53e0511" translate="yes" xml:space="preserve">
          <source>IsSurrogate reports whether the specified Unicode code point can appear in a surrogate pair.</source>
          <target state="translated">IsSurrogate는 지정된 유니 코드 코드 포인트가 서로 게이트 쌍으로 나타날 수 있는지보고합니다.</target>
        </trans-unit>
        <trans-unit id="94ff69a73ee80e68160fc5d14463531f326feb1a" translate="yes" xml:space="preserve">
          <source>IsSymbol reports whether the rune is a symbolic character.</source>
          <target state="translated">IsSymbol은 룬이 기호 문자인지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="80e8a9046c478caac6544a67a67898f6f56d102d" translate="yes" xml:space="preserve">
          <source>IsTimeout returns a boolean indicating whether the error is known to report that a timeout occurred.</source>
          <target state="translated">IsTimeout은 오류가 시간 초과가 발생했다고보고되는지 여부를 나타내는 부울을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5dae031aae8f79fce18391198feff6e45790996f" translate="yes" xml:space="preserve">
          <source>IsTitle reports whether the rune is a title case letter.</source>
          <target state="translated">IsTitle은 룬이 제목 케이스 문자인지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="47cdd782e568065cbc896003cc3080e6fa343e64" translate="yes" xml:space="preserve">
          <source>IsTrue reports whether the value is 'true', in the sense of not the zero of its type, and whether the value has a meaningful truth value. This is the definition of truth used by if and other such actions.</source>
          <target state="translated">IsTrue는 값이 0이 아니라는 의미에서 값이 'true'인지 여부와 값에 의미있는 진리 값이 있는지 여부를보고합니다. 이것은 if와 다른 그러한 행동에 의해 사용되는 진실의 정의입니다.</target>
        </trans-unit>
        <trans-unit id="f386d0c906e9366cb699b0ae4451bc9d70023dc4" translate="yes" xml:space="preserve">
          <source>IsType reports whether the corresponding expression specifies a type.</source>
          <target state="translated">IsType은 해당 표현식이 유형을 지정하는지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="bd72caa363338547d5699b96c1b4ac80c8cd24c1" translate="yes" xml:space="preserve">
          <source>IsUint64 reports whether x can be represented as a uint64.</source>
          <target state="translated">IsUint64는 x를 uint64로 나타낼 수 있는지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="6b3721da2086f5e9441475d80b1c204e06489512" translate="yes" xml:space="preserve">
          <source>IsUnspecified reports whether ip is an unspecified address, either the IPv4 address &quot;0.0.0.0&quot; or the IPv6 address &quot;::&quot;.</source>
          <target state="translated">IsUnspecified는 ip가 IPv4 주소 &quot;0.0.0.0&quot;또는 IPv6 주소 &quot;::&quot;중 지정되지 않은 주소인지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="b72d29b8198db403c8169f5f00434fb729acb678" translate="yes" xml:space="preserve">
          <source>IsUpper reports whether the rune is an upper case letter.</source>
          <target state="translated">IsUpper는 룬이 대문자인지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="ecc382ac4eeae90631c4ff786a142c8cd4a2a1e3" translate="yes" xml:space="preserve">
          <source>IsValid reports whether the position is valid.</source>
          <target state="translated">IsValid는 위치가 유효한지보고합니다.</target>
        </trans-unit>
        <trans-unit id="6b4d65bab951e443a5b5a6cb70b5527aa329d397" translate="yes" xml:space="preserve">
          <source>IsValid reports whether v represents a value. It returns false if v is the zero Value. If IsValid returns false, all other methods except String panic. Most functions and methods never return an invalid value. If one does, its documentation states the conditions explicitly.</source>
          <target state="translated">IsValid는 v가 값을 나타내는 지 여부를보고합니다. v가 0 인 경우 false를 리턴합니다. IsValid가 false를 반환하면 String panic을 제외한 다른 모든 메서드입니다. 대부분의 함수와 메소드는 유효하지 않은 값을 반환하지 않습니다. 그럴 경우 문서에 조건이 명시 적으로 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="55d30ff7d3d863a32468776759178dbe0451ccce" translate="yes" xml:space="preserve">
          <source>IsValue reports whether the corresponding expression is a value. Builtins are not considered values. Constant values have a non- nil Value.</source>
          <target state="translated">IsValue는 해당 표현식이 값인지 여부를보고합니다. 내장은 가치로 간주되지 않습니다. 상수 값은 0이 아닌 값을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="9d7a5d3a7652824e4f9b549a7d5a262a10ef59c5" translate="yes" xml:space="preserve">
          <source>IsValue reports whether v is a valid Value parameter type.</source>
          <target state="translated">IsValue는 v가 유효한 Value 매개 변수 유형인지보고합니다.</target>
        </trans-unit>
        <trans-unit id="65e1a871482dad54f08e17dd72762a3fd2f75d74" translate="yes" xml:space="preserve">
          <source>IsVoid reports whether the corresponding expression is a function call without results.</source>
          <target state="translated">IsVoid는 해당 표현식이 결과없이 함수 호출인지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="297c16f9ae029663b610c3b616363007a062b053" translate="yes" xml:space="preserve">
          <source>IsWordChar reports whether r is consider a &amp;ldquo;word character&amp;rdquo; during the evaluation of the \b and \B zero-width assertions. These assertions are ASCII-only: the word characters are [A-Za-z0-9_].</source>
          <target state="translated">IsWordChar는 \ b 및 \ B 0 너비 어설 션을 평가하는 동안 r이 &quot;워드 문자&quot;로 간주되는지 여부를보고합니다. 이러한 어설 션은 ASCII 전용입니다. 단어 문자는 [A-Za-z0-9_]입니다.</target>
        </trans-unit>
        <trans-unit id="5f0397c5af2b47c485a6cac89d344b49d39148e5" translate="yes" xml:space="preserve">
          <source>IsZero reports whether t represents the zero time instant, January 1, year 1, 00:00:00 UTC.</source>
          <target state="translated">IsZero는 t가 0 년 1 월 1 일 00:00:00 UTC를 나타내는 0시 순간인지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="14b29f8979f8b38e486b8c2fc265fcec75315a1b" translate="yes" xml:space="preserve">
          <source>IsZero reports whether v is the zero value for its type. It panics if the argument is invalid.</source>
          <target state="translated">IsZero는 v가 해당 유형의 0 값인지 여부를보고합니다. 인수가 유효하지 않으면 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="2e5ba7b50d53dc66de9ac76f94ae84e19ac42a4e" translate="yes" xml:space="preserve">
          <source>IsolationLevel is the transaction isolation level stored in TxOptions.</source>
          <target state="translated">IsolationLevel은 TxOptions에 저장된 트랜잭션 격리 수준입니다.</target>
        </trans-unit>
        <trans-unit id="00b8885e61c34531225b38e32ae41a763eb82a05" translate="yes" xml:space="preserve">
          <source>IsolationLevel is the transaction isolation level used in TxOptions.</source>
          <target state="translated">IsolationLevel은 TxOptions에서 사용되는 트랜잭션 격리 수준입니다.</target>
        </trans-unit>
        <trans-unit id="d76fb5eb8c221bc52330dc2413a54b325f8af681" translate="yes" xml:space="preserve">
          <source>It does nothing if the URL's scheme is not HTTP or HTTPS.</source>
          <target state="translated">URL 스킴이 HTTP 또는 HTTPS가 아닌 경우 아무 것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="730fc66fc7c6f8658abbd279912d4debd6897a14" translate="yes" xml:space="preserve">
          <source>It is allowed but not required for the caller to hold c.L during the call.</source>
          <target state="translated">호출 중에 호출자가 cL을 보유 할 수는 있지만 허용되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="64b18effbf60d196d9c9972b0f4752ad49d90515" translate="yes" xml:space="preserve">
          <source>It is allowed to call Notify multiple times with different channels and the same signals: each channel receives copies of incoming signals independently.</source>
          <target state="translated">다른 채널과 동일한 신호로 여러 번 Notify를 호출 할 수 있습니다. 각 채널은 들어오는 신호의 사본을 독립적으로받습니다.</target>
        </trans-unit>
        <trans-unit id="2b72f5a15cc86252895b6a5820ed7c36974cccb2" translate="yes" xml:space="preserve">
          <source>It is allowed to call Notify multiple times with the same channel: each call expands the set of signals sent to that channel. The only way to remove signals from the set is to call Stop.</source>
          <target state="translated">동일한 채널로 여러 번 알림을 호출 할 수 있습니다. 각 호출은 해당 채널로 전송 된 신호 세트를 확장합니다. 세트에서 신호를 제거하는 유일한 방법은 Stop을 호출하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="64b9ab50226fefd57abe4e106fe4fbde6d348569" translate="yes" xml:space="preserve">
          <source>It is defined in RFC 1950:</source>
          <target state="translated">RFC 1950에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3527f9b32341885623b87c38f5f98392bdedd8dc" translate="yes" xml:space="preserve">
          <source>It is equivalent to SplitAfterN with a count of -1.</source>
          <target state="translated">카운트가 -1 인 SplitAfterN과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dbac3455f5dcff27b15907e612c36dc6d6627118" translate="yes" xml:space="preserve">
          <source>It is equivalent to SplitN with a count of -1.</source>
          <target state="translated">카운트가 -1 인 SplitN과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9bc89c86db3c02e15ec65887cfcf0cc312b36a24" translate="yes" xml:space="preserve">
          <source>It is not associated with any particular color profile.</source>
          <target state="translated">특정 색상 프로파일과 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="8b9cf269b7a066efe335dc4941105afdd2791a76" translate="yes" xml:space="preserve">
          <source>It is not guaranteed that a finalizer will run for objects allocated in initializers for package-level variables. Such objects may be linker-allocated, not heap-allocated.</source>
          <target state="translated">패키지 레벨 변수의 이니셜 라이저에 할당 된 오브젝트에 대해서는 종료자가 실행된다는 보장이 없습니다. 이러한 객체는 힙 할당이 아닌 링커 할당 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="185afc47d5312f1df75d7c2e1fd8c497c93c1bee" translate="yes" xml:space="preserve">
          <source>It is not guaranteed that a finalizer will run if the size of *obj is zero bytes.</source>
          <target state="translated">* obj의 크기가 0 바이트 인 경우 종료자가 실행된다는 보장이 없습니다.</target>
        </trans-unit>
        <trans-unit id="e276973efe0e06473fcbf2184470a55ce905f9ea" translate="yes" xml:space="preserve">
          <source>It is rare to Close a DB, as the DB handle is meant to be long-lived and shared between many goroutines.</source>
          <target state="translated">DB 핸들은 많은 고 루틴들 사이에서 오래 지속되고 공유되어야하기 때문에 DB를 닫는 것은 드 rare니다.</target>
        </trans-unit>
        <trans-unit id="13c70c7692f708ab80a79d217ba3b943c3b63874" translate="yes" xml:space="preserve">
          <source>It is safe to call Read and Write in parallel with each other or with Close. Parallel calls to Read and parallel calls to Write are also safe: the individual calls will be gated sequentially.</source>
          <target state="translated">서로 병렬로 또는 닫기로 읽기 및 쓰기를 호출하는 것이 안전합니다. 병렬 호출 읽기 및 병렬 호출 쓰기도 안전합니다. 개별 호출은 순차적으로 게이트됩니다.</target>
        </trans-unit>
        <trans-unit id="8e87bdde62b3a11cc618f6eef7d1ef7e95ea027e" translate="yes" xml:space="preserve">
          <source>It is sometimes necessary for a test program to do extra setup or teardown before or after testing. It is also sometimes necessary for a test to control which code runs on the main thread. To support these and other cases, if a test file contains a function:</source>
          <target state="translated">테스트 프로그램이 테스트 전후에 추가 설정 또는 해제를 수행해야하는 경우가 있습니다. 때로는 테스트가 메인 스레드에서 실행되는 코드를 제어해야 할 수도 있습니다. 테스트 파일에 함수가 포함 된 경우 이러한 경우와 다른 경우를 지원하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="c4c640b2d1c13408fc0addbe9ca9b3e33c914d4c" translate="yes" xml:space="preserve">
          <source>It is the caller's responsibility to call Close on the Reader when done.</source>
          <target state="translated">완료되면 리더에서 닫기를 호출하는 것은 호출자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="986480998eaebed4b6a54647e1482613d046d84f" translate="yes" xml:space="preserve">
          <source>It is the caller's responsibility to call Close on the Writer when done. Writes may be buffered and not flushed until Close.</source>
          <target state="translated">완료되면 작성기에서 닫기를 호출하는 것은 호출자의 책임입니다. 쓰기는 버퍼링되어 닫힐 때까지 플러시되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d5e9d1ff14ea8de0b89e8865f3f584d482a0afe" translate="yes" xml:space="preserve">
          <source>It is useful mainly in compressed network protocols, to ensure that a remote reader has enough data to reconstruct a packet. Flush does not return until the data has been written. If the underlying writer returns an error, Flush returns that error.</source>
          <target state="translated">원격 리더에 패킷을 재구성하기에 충분한 데이터가 있는지 확인하는 데 주로 압축 네트워크 프로토콜에 유용합니다. 데이터가 기록 될 때까지 플러시가 반환되지 않습니다. 기본 작성기가 오류를 반환하면 Flush가 해당 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="31cc99464ed62136a451655119e840afa7451b83" translate="yes" xml:space="preserve">
          <source>It is valid both to add and to subtract offsets from a pointer in this way. It is also valid to use &amp;amp;^ to round pointers, usually for alignment. In all cases, the result must continue to point into the original allocated object.</source>
          <target state="translated">이런 식으로 포인터에서 오프셋을 더하거나 빼는 것이 모두 유효합니다. 일반적으로 정렬을 위해 포인터를 반올림하기 위해 &amp;amp; ^를 사용하는 것도 유효합니다. 모든 경우에 결과는 원래 할당 된 객체를 계속 가리켜 야합니다.</target>
        </trans-unit>
        <trans-unit id="dd1e16d418b70f8a4bcbc355b1da37369ffe8113" translate="yes" xml:space="preserve">
          <source>It makes one call to data.Len to determine n, O(n*log(n)) calls to data.Less and O(n*log(n)*log(n)) calls to data.Swap.</source>
          <target state="translated">데이터를 한 번 호출합니다 .n, O (n * log (n)) 데이터 호출을 결정합니다 .Less and O (n * log (n) * log (n)) call to data.Swap.</target>
        </trans-unit>
        <trans-unit id="49a3b03dcb3864c71030445c5ba5bfe2611711d2" translate="yes" xml:space="preserve">
          <source>It may also be received into any of these:</source>
          <target state="translated">다음 중 하나에 수신 될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b88fc3e61debf0d0f1a1581e71a0996edf539a5" translate="yes" xml:space="preserve">
          <source>It panics if count is negative or if the result of (len(b) * count) overflows.</source>
          <target state="translated">count가 음수이거나 (len (b) * count)의 결과가 오버플로되면 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8b61a1a4bb411ee036d7d3cc509678ace33cef83" translate="yes" xml:space="preserve">
          <source>It panics if count is negative or if the result of (len(s) * count) overflows.</source>
          <target state="translated">count가 음수이거나 (len (s) * count)의 결과가 오버플로되면 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="652db58383317d0338f369bbd62022ed3ab07600" translate="yes" xml:space="preserve">
          <source>It panics if the Value was obtained by accessing unexported struct fields.</source>
          <target state="translated">내 보내지 않은 구조체 필드에 액세스하여 값을 얻은 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="564d342d70ea92defe3199a234b7ca21ece54f95" translate="yes" xml:space="preserve">
          <source>It returns a *rsa.PrivateKey, a *ecdsa.PrivateKey, or a ed25519.PrivateKey. More types might be supported in the future.</source>
          <target state="translated">* rsa.PrivateKey, * ecdsa.PrivateKey 또는 ed25519.PrivateKey를 리턴합니다. 앞으로 더 많은 유형이 지원 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f11d9cd546ed2abe8e697fa6f8bbdc2a3d2e5ef" translate="yes" xml:space="preserve">
          <source>It returns a *rsa.PublicKey, *dsa.PublicKey, *ecdsa.PublicKey, or ed25519.PublicKey. More types might be supported in the future.</source>
          <target state="translated">* rsa.PublicKey, * dsa.PublicKey, * ecdsa.PublicKey 또는 ed25519.PublicKey를 리턴합니다. 앞으로 더 많은 유형이 지원 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5010d434ca33dd92d7a44910817533939048059" translate="yes" xml:space="preserve">
          <source>It returns an empty slice if the URL's scheme is not HTTP or HTTPS.</source>
          <target state="translated">URL 스킴이 HTTP 또는 HTTPS가 아닌 경우 빈 슬라이스를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="2b565edf53edd5e13295b4a395aad926eda82327" translate="yes" xml:space="preserve">
          <source>It returns an error if t has already been executed.</source>
          <target state="translated">t가 이미 실행 된 경우 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a56353db7fb203c22e0bfd117b292abd05c5de94" translate="yes" xml:space="preserve">
          <source>It returns an error if t or any associated template has already been executed.</source>
          <target state="translated">t 또는 관련 템플릿이 이미 실행 된 경우 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e63a57b040488970eacecfd2272a9deb62e2be3e" translate="yes" xml:space="preserve">
          <source>It returns an error if the receiver is not an exported type or has no suitable methods. It also logs the error using package log. The client accesses each method using a string of the form &quot;Type.Method&quot;, where Type is the receiver's concrete type.</source>
          <target state="translated">수신자가 익스포트 된 유형이 아니거나 적합한 메소드가없는 경우 오류를 리턴합니다. 또한 패키지 로그를 사용하여 오류를 기록합니다. 클라이언트는 &quot;Type.Method&quot;형식의 문자열을 사용하여 각 메소드에 액세스합니다. 여기서 Type은 수신자의 구체적 유형입니다.</target>
        </trans-unit>
        <trans-unit id="4dde580c3be3f14ce5fe15d368688767eafb64f5" translate="yes" xml:space="preserve">
          <source>It returns the IP address and the network implied by the IP and prefix length. For example, ParseCIDR(&quot;192.0.2.1/24&quot;) returns the IP address 192.0.2.1 and the network 192.0.2.0/24.</source>
          <target state="translated">IP와 접두사 길이에 의해 암시 된 IP 주소와 네트워크를 반환합니다. 예를 들어 ParseCIDR ( &quot;192.0.2.1/24&quot;)은 IP 주소 192.0.2.1과 네트워크 192.0.2.0/24를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0b053a1afdc2a3fb959c27dc82bd3e04e4d3478f" translate="yes" xml:space="preserve">
          <source>It sets only the Path and Args in the returned structure.</source>
          <target state="translated">반환 된 구조에서 Path와 Args 만 설정합니다.</target>
        </trans-unit>
        <trans-unit id="810599e9d82ed867f48c9be47863d26eaa5d33f3" translate="yes" xml:space="preserve">
          <source>It sets z to the (possibly rounded) value of the corresponding floating- point value, and returns z, the actual base b, and an error err, if any. The entire string (not just a prefix) must be consumed for success. If z's precision is 0, it is changed to 64 before rounding takes effect. The number must be of the form:</source>
          <target state="translated">z를 해당 부동 소수점 값의 반올림 값으로 설정하고 z, 실제 기준 b 및 오류 err (있는 경우)를 리턴합니다. 성공하려면 전체 문자열 (접두사뿐만 아니라)을 사용해야합니다. z의 정밀도가 0이면 반올림이 적용되기 전에 64로 변경됩니다. 숫자는 다음과 같은 형식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="4b0e67dd55e6df4a3c7132865324312cab9fb6a8" translate="yes" xml:space="preserve">
          <source>It should not be used for recursive read locking; a blocked Lock call excludes new readers from acquiring the lock. See the documentation on the RWMutex type.</source>
          <target state="translated">재귀 적 읽기 잠금에는 사용하지 않아야합니다. 차단 된 잠금 호출은 새로운 독자가 잠금을 획득하지 못하게합니다. RWMutex 유형에 대한 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ff62c59d333b6b7669c7f0b6568819a5dff0f396" translate="yes" xml:space="preserve">
          <source>Iterate calls f for the files in the file set in the order they were added until f returns false.</source>
          <target state="translated">반복은 f가 false를 리턴 할 때까지 추가 된 순서대로 파일 세트의 파일에 대해 f를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="380c384a3bc4560682612879309496ebdde5cfd3" translate="yes" xml:space="preserve">
          <source>Itoa</source>
          <target state="translated">Itoa</target>
        </trans-unit>
        <trans-unit id="aac52064292950f4b3f0337ac6b1ebbc54bd40af" translate="yes" xml:space="preserve">
          <source>Itoa is equivalent to FormatInt(int64(i), 10).</source>
          <target state="translated">Itoa는 FormatInt (int64 (i), 10)와 같습니다.</target>
        </trans-unit>
        <trans-unit id="2d1e23b725be8aad6b338015ecefbc3479bf797c" translate="yes" xml:space="preserve">
          <source>J0 returns the order-zero Bessel function of the first kind.</source>
          <target state="translated">J0은 첫 번째 종류의 0 차 베셀 함수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9b402d642da0f20c362bc1bcf6bfd3cb9482a1ee" translate="yes" xml:space="preserve">
          <source>J1 returns the order-one Bessel function of the first kind.</source>
          <target state="translated">J1은 첫 번째 종류의 1 차 베셀 함수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0a183d189787e52c86d1ff01f1f68fc26c61737d" translate="yes" xml:space="preserve">
          <source>JPEG is defined in ITU-T T.81: &lt;a href=&quot;https://www.w3.org/Graphics/JPEG/itu-t81.pdf&quot;&gt;https://www.w3.org/Graphics/JPEG/itu-t81.pdf&lt;/a&gt;.</source>
          <target state="translated">JPEG는 ITU-T T.81 : &lt;a href=&quot;https://www.w3.org/Graphics/JPEG/itu-t81.pdf&quot;&gt;https://www.w3.org/Graphics/JPEG/itu-t81.pdf에&lt;/a&gt; 정의되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bd49e7822aebcb558798ee4f0f590d63e8da7cc1" translate="yes" xml:space="preserve">
          <source>JPEG, VP8, the MPEG family and other codecs use this color model. Such codecs often use the terms YUV and Y'CbCr interchangeably, but strictly speaking, the term YUV applies only to analog video signals, and Y' (luma) is Y (luminance) after applying gamma correction.</source>
          <target state="translated">JPEG, VP8, MPEG 제품군 및 기타 코덱은이 색상 모델을 사용합니다. 이러한 코덱은 종종 YUV와 Y'CbCr이라는 용어를 서로 바꾸어 사용할 수 있지만 YUV라는 용어는 아날로그 비디오 신호에만 적용되며 Y '(루마)는 감마 보정을 적용한 후 Y (휘도)입니다.</target>
        </trans-unit>
        <trans-unit id="922b9fe605d8db0c621e15bc38a3c570a5ce91fd" translate="yes" xml:space="preserve">
          <source>JS encapsulates a known safe EcmaScript5 Expression, for example, `(x + y * z())`. Template authors are responsible for ensuring that typed expressions do not break the intended precedence and that there is no statement/expression ambiguity as when passing an expression like &quot;{ foo: bar() }\n['foo']()&quot;, which is both a valid Expression and a valid Program with a very different meaning.</source>
          <target state="translated">JS는 알려진 안전한 EcmaScript5 Expression을 캡슐화합니다 (예 :`(x + y * z ())`). 템플리트 작성자는 유형이 지정된 표현식이 의도 된 우선 순위를 위반하지 않도록하고 &quot;{foo : bar ()} \ n [ 'foo'] ()&quot;와 같은 표현식을 전달할 때와 같이 명령문 / 표현 모호성이 없는지 확인해야합니다. 유효한 Expression과 매우 다른 의미의 유효한 Program입니다.</target>
        </trans-unit>
        <trans-unit id="26cbdc0eb97f168871a53f6c7842d5c136b64697" translate="yes" xml:space="preserve">
          <source>JSEscape writes to w the escaped JavaScript equivalent of the plain text data b.</source>
          <target state="translated">JSEscape는 일반 텍스트 데이터와 동등한 이스케이프 된 JavaScript를 작성합니다. b.</target>
        </trans-unit>
        <trans-unit id="bd3faa1039cdd3fc555ce394120927a3ffbfdfd6" translate="yes" xml:space="preserve">
          <source>JSEscapeString returns the escaped JavaScript equivalent of the plain text data s.</source>
          <target state="translated">JSEscapeString은 일반 텍스트 데이터에 해당하는 이스케이프 된 JavaScript를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="0657ce896f15a5407782a5a0cb9e814dbb9243d9" translate="yes" xml:space="preserve">
          <source>JSEscaper returns the escaped JavaScript equivalent of the textual representation of its arguments.</source>
          <target state="translated">JSEscaper는 인수의 텍스트 표현과 동등한 이스케이프 된 JavaScript를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="3bd554b8109b0533f9a7bb62634a7c4956ea4b3a" translate="yes" xml:space="preserve">
          <source>JSON cannot represent cyclic data structures and Marshal does not handle them. Passing cyclic structures to Marshal will result in an infinite recursion.</source>
          <target state="translated">JSON은 순환 데이터 구조를 나타낼 수 없으며 Marshal은이를 처리하지 않습니다. 순환 구조를 원수로 전달하면 무한 재귀가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="16c95a3afe47aa9594cf8938af617a9901298497" translate="yes" xml:space="preserve">
          <source>JSStr encapsulates a sequence of characters meant to be embedded between quotes in a JavaScript expression. The string must match a series of StringCharacters:</source>
          <target state="translated">JSStr은 JavaScript 표현식에서 따옴표로 묶어야하는 일련의 문자를 캡슐화합니다. 문자열은 일련의 StringCharacter와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="7ee415a9e606531fbf364133b0de844b1078510a" translate="yes" xml:space="preserve">
          <source>JSValue implements Wrapper interface.</source>
          <target state="translated">JSValue는 래퍼 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="b800dfb6df40a19873f9dc7ec5927a93b2cfe769" translate="yes" xml:space="preserve">
          <source>Jacobi returns the Jacobi symbol (x/y), either +1, -1, or 0. The y argument must be an odd integer.</source>
          <target state="translated">Jacobi는 +1, -1 또는 0의 Jacobi 기호 (x / y)를 반환합니다. y 인수는 홀수 정수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="173acb21066734464813cc933e35bf49fb5074d7" translate="yes" xml:space="preserve">
          <source>Jar implements the http.CookieJar interface from the net/http package.</source>
          <target state="translated">Jar는 net / http 패키지에서 http.CookieJar 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="0a5f33ea0d4d273fa523aad519e0bd5003a1f2a2" translate="yes" xml:space="preserve">
          <source>Jn returns the order-n Bessel function of the first kind.</source>
          <target state="translated">Jn은 첫 번째 종류의 B 형 함수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e0d73143de80d17e82de2e017ac156ca3b9c4e01" translate="yes" xml:space="preserve">
          <source>Join</source>
          <target state="translated">Join</target>
        </trans-unit>
        <trans-unit id="b160ff3535de402a5c7113020ea1b5b48c93aaa3" translate="yes" xml:space="preserve">
          <source>Join concatenates the elements of a to create a single string. The separator string sep is placed between elements in the resulting string.</source>
          <target state="translated">Join은 a의 요소를 연결하여 단일 문자열을 만듭니다. 구분자 문자열 sep는 결과 ​​문자열의 요소 사이에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="6badcc1917f6227c17c3b5a3bb3a7ab0dac561dd" translate="yes" xml:space="preserve">
          <source>Join concatenates the elements of s to create a new byte slice. The separator sep is placed between elements in the resulting slice.</source>
          <target state="translated">Join은 s의 요소를 연결하여 새 바이트 슬라이스를 만듭니다. 분리기 (se)는 최종 슬라이스에서 요소들 사이에 배치된다.</target>
        </trans-unit>
        <trans-unit id="aa67e6029ba49c3f992d57c2d0ab202a04ec1080" translate="yes" xml:space="preserve">
          <source>Join joins any number of path elements into a single path, adding a Separator if necessary. Join calls Clean on the result; in particular, all empty strings are ignored. On Windows, the result is a UNC path if and only if the first path element is a UNC path.</source>
          <target state="translated">조인은 여러 경로 요소를 단일 경로로 결합하여 필요한 경우 구분 기호를 추가합니다. 통화 참여 결과에 대한 정리; 특히 빈 문자열은 모두 무시됩니다. Windows에서 첫 번째 경로 요소가 UNC 경로 인 경우에만 결과가 UNC 경로입니다.</target>
        </trans-unit>
        <trans-unit id="945c23e567973c47ce3562fa8cf5ef5f3d5533ea" translate="yes" xml:space="preserve">
          <source>Join joins any number of path elements into a single path, adding a separating slash if necessary. The result is Cleaned; in particular, all empty strings are ignored.</source>
          <target state="translated">조인은 여러 경로 요소를 단일 경로로 결합하여 필요한 경우 분리 슬래시를 추가합니다. 결과가 정리됩니다. 특히 빈 문자열은 모두 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="0f25f02ad0ad7ded23a0d09d8ea462e385b6164c" translate="yes" xml:space="preserve">
          <source>JoinHostPort combines host and port into a network address of the form &quot;host:port&quot;. If host contains a colon, as found in literal IPv6 addresses, then JoinHostPort returns &quot;[host]:port&quot;.</source>
          <target state="translated">JoinHostPort는 호스트와 포트를 &quot;host : port&quot;형식의 네트워크 주소로 결합합니다. 호스트에 리터럴 IPv6 주소에서와 같이 콜론이 포함 된 경우 JoinHostPort는 &quot;[host] : port&quot;를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="0cf4b24840f4e27435d8326ea5a70f3fed6a3f6e" translate="yes" xml:space="preserve">
          <source>KeepAlive marks its argument as currently reachable. This ensures that the object is not freed, and its finalizer is not run, before the point in the program where KeepAlive is called.</source>
          <target state="translated">KeepAlive는 인수가 현재 도달 가능한 것으로 표시합니다. 이렇게하면 KeepAlive가 호출되는 프로그램의 포인트 이전에 오브젝트가 해제되지 않고 종료자가 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4901b1829f2829b984a0de81f7472f13edad3727" translate="yes" xml:space="preserve">
          <source>Key returns the key of the iterator's current map entry.</source>
          <target state="translated">키는 반복자의 현재 맵 항목의 키를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="91d7c5c0cb63de8145a0cccf24bc8d2f799ffa8e" translate="yes" xml:space="preserve">
          <source>Key returns the key type of map m.</source>
          <target state="translated">키는지도 m의 키 유형을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="376426fe335e339ad2d0569150ad1299f858528e" translate="yes" xml:space="preserve">
          <source>KeyUsage represents the set of actions that are valid for a given key. It's a bitmap of the KeyUsage* constants.</source>
          <target state="translated">KeyUsage는 주어진 키에 유효한 일련의 동작을 나타냅니다. KeyUsage * 상수의 비트 맵입니다.</target>
        </trans-unit>
        <trans-unit id="096044ddbad86155a76b804e09110be8b259d0c6" translate="yes" xml:space="preserve">
          <source>KeyValue represents a single entry in a Map.</source>
          <target state="translated">KeyValue는 맵에서 단일 항목을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="054ac770f511da2fe690104026b09ee1f229a5cb" translate="yes" xml:space="preserve">
          <source>Kill causes the Process to exit immediately. Kill does not wait until the Process has actually exited. This only kills the Process itself, not any other processes it may have started.</source>
          <target state="translated">강제 종료하면 프로세스가 즉시 종료됩니다. 프로세스가 실제로 종료 될 때까지 강제 종료하지 않습니다. 이것은 프로세스가 시작되었을 때 프로세스가 아닌 프로세스 자체 만 종료시킵니다.</target>
        </trans-unit>
        <trans-unit id="e00ac23f2ac2ff73ad4f3c4b263d6c5bbfb80190" translate="yes" xml:space="preserve">
          <source>Kind</source>
          <target state="translated">Kind</target>
        </trans-unit>
        <trans-unit id="2f96efc28c6a98b35f43fa160b16237570ef8889" translate="yes" xml:space="preserve">
          <source>Kind returns the kind of basic type b.</source>
          <target state="translated">종류는 기본 유형 b의 종류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1333bd1a9ccf64ac482cd7154071753a44d2a74b" translate="yes" xml:space="preserve">
          <source>Kind returns the selection kind.</source>
          <target state="translated">종류는 선택 종류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1c89bd23580c2ae3925d134637371987fedb05e1" translate="yes" xml:space="preserve">
          <source>Kind returns v's Kind. If v is the zero Value (IsValid returns false), Kind returns Invalid.</source>
          <target state="translated">Kind는 v의 Kind를 반환합니다. v가 0 값이면 (IsValid는 false를 반환) Kind는 Invalid를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="069ade3ad94bb7d5e1d27e83fcea3337da44893d" translate="yes" xml:space="preserve">
          <source>Kind specifies the kind of value represented by a Value.</source>
          <target state="translated">종류는 값으로 표시되는 값의 종류를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="4774d947be420886f05bc80b8d7b99a878f5521e" translate="yes" xml:space="preserve">
          <source>Known networks are &quot;tcp&quot;, &quot;tcp4&quot; (IPv4-only), &quot;tcp6&quot; (IPv6-only), &quot;udp&quot;, &quot;udp4&quot; (IPv4-only), &quot;udp6&quot; (IPv6-only), &quot;ip&quot;, &quot;ip4&quot; (IPv4-only), &quot;ip6&quot; (IPv6-only), &quot;unix&quot;, &quot;unixgram&quot; and &quot;unixpacket&quot;.</source>
          <target state="translated">알려진 네트워크는 &quot;tcp&quot;, &quot;tcp4&quot;(IPv4 만), &quot;tcp6&quot;(IPv6 만), &quot;udp&quot;, &quot;udp4&quot;(IPv4 만), &quot;udp6&quot;(IPv6 만), &quot;ip&quot;입니다. , &quot;ip4&quot;(IPv4 전용), &quot;ip6&quot;(IPv6 전용), &quot;unix&quot;, &quot;unixgram&quot;및 &quot;unixpacket&quot;.</target>
        </trans-unit>
        <trans-unit id="b8b88dd6dbbf9262e1174af16ab3d22e577d2db5" translate="yes" xml:space="preserve">
          <source>Known options:</source>
          <target state="translated">알려진 옵션 :</target>
        </trans-unit>
        <trans-unit id="14eee53dd9c3bca9efa386f9ef53c298322ea056" translate="yes" xml:space="preserve">
          <source>Label returns the value of the label with the given key on ctx, and a boolean indicating whether that label exists.</source>
          <target state="translated">Label은 ctx에 제공된 키가있는 레이블 값과 해당 레이블이 존재하는지 여부를 나타내는 부울을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="17f6783a9c705de835debb13cac8a07e2f5a8b94" translate="yes" xml:space="preserve">
          <source>LabelSet is a set of labels.</source>
          <target state="translated">LabelSet은 레이블 집합입니다.</target>
        </trans-unit>
        <trans-unit id="bd752eb91afd54f78c7060bac232ea7dd334932f" translate="yes" xml:space="preserve">
          <source>Labels takes an even number of strings representing key-value pairs and makes a LabelSet containing them. A label overwrites a prior label with the same key. Currently only CPU profile utilizes labels information. See &lt;a href=&quot;https://golang.org/issue/23458&quot;&gt;https://golang.org/issue/23458&lt;/a&gt; for details.</source>
          <target state="translated">레이블은 키-값 쌍을 나타내는 짝수 개의 문자열을 가져 와서이를 포함하는 LabelSet을 만듭니다. 레이블은 동일한 키로 이전 레이블을 덮어 씁니다. 현재 CPU 프로파일 만 레이블 정보를 사용합니다. 자세한 내용은 &lt;a href=&quot;https://golang.org/issue/23458&quot;&gt;https://golang.org/issue/23458&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c80c2e659a9bc68c02557be9a6c755aeed779cd0" translate="yes" xml:space="preserve">
          <source>LastIndex</source>
          <target state="translated">LastIndex</target>
        </trans-unit>
        <trans-unit id="c2daa604f07bcb24a260e4fea3217009758689c4" translate="yes" xml:space="preserve">
          <source>LastIndex returns the index of the last instance of sep in s, or -1 if sep is not present in s.</source>
          <target state="translated">LastIndex는 s에서 sep의 마지막 인스턴스 인덱스를 반환하거나 sep가 s에 없으면 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b07643ffeaf5942b3f11986d945cbd1ca4dc0db5" translate="yes" xml:space="preserve">
          <source>LastIndex returns the index of the last instance of substr in s, or -1 if substr is not present in s.</source>
          <target state="translated">LastIndex는 s에서 substr의 마지막 인스턴스 색인을 반환하거나, substr이 s에 없으면 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a55ae6e0d05b49527c27558955cfb6017a5cb79e" translate="yes" xml:space="preserve">
          <source>LastIndexAny</source>
          <target state="translated">LastIndexAny</target>
        </trans-unit>
        <trans-unit id="c468ec7af80d497e073da5281108fc969df48a62" translate="yes" xml:space="preserve">
          <source>LastIndexAny interprets s as a sequence of UTF-8-encoded Unicode code points. It returns the byte index of the last occurrence in s of any of the Unicode code points in chars. It returns -1 if chars is empty or if there is no code point in common.</source>
          <target state="translated">LastIndexAny는 s를 UTF-8로 인코딩 된 유니 코드 코드 포인트의 시퀀스로 해석합니다. 문자의 모든 유니 코드 코드 포인트에서 s로 마지막 발생의 바이트 인덱스를 리턴합니다. 문자가 비어 있거나 공통 코드 포인트가 없으면 -1을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="f35ff2cbc15f8519c2de1c522556210dbec6f0d9" translate="yes" xml:space="preserve">
          <source>LastIndexAny returns the index of the last instance of any Unicode code point from chars in s, or -1 if no Unicode code point from chars is present in s.</source>
          <target state="translated">LastIndexAny는 s의 문자에서 유니 코드 코드 포인트의 마지막 인스턴스의 인덱스를 반환하거나, s에 유니 코드 코드 포인트가 없으면 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e5af45bb29df606a6ad9f71c5f8ffe801cf806e3" translate="yes" xml:space="preserve">
          <source>LastIndexByte</source>
          <target state="translated">LastIndexByte</target>
        </trans-unit>
        <trans-unit id="715ec7346f22f455ae3b4f77928429d6e6ea2e7d" translate="yes" xml:space="preserve">
          <source>LastIndexByte returns the index of the last instance of c in s, or -1 if c is not present in s.</source>
          <target state="translated">LastIndexByte는 s에서 c의 마지막 인스턴스 인덱스를 반환하거나 s에 c가 없으면 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0052a6c35642a0a5651d0e514c35ebcc1b001ad3" translate="yes" xml:space="preserve">
          <source>LastIndexFunc</source>
          <target state="translated">LastIndexFunc</target>
        </trans-unit>
        <trans-unit id="e9e6d245d6f60be69d3deb822ef844937727defc" translate="yes" xml:space="preserve">
          <source>LastIndexFunc interprets s as a sequence of UTF-8-encoded code points. It returns the byte index in s of the last Unicode code point satisfying f(c), or -1 if none do.</source>
          <target state="translated">LastIndexFunc는 s를 UTF-8로 인코딩 된 코드 포인트의 시퀀스로 해석합니다. f (c)를 만족하는 마지막 유니 코드 코드 포인트의 s 단위로 바이트 인덱스를 반환하고, 그렇지 않으면 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="573828a944fe303002f7c0336cac457a4d45085f" translate="yes" xml:space="preserve">
          <source>LastIndexFunc returns the index into s of the last Unicode code point satisfying f(c), or -1 if none do.</source>
          <target state="translated">LastIndexFunc는 f (c)를 만족하는 마지막 유니 코드 코드 포인트의 s로 인덱스를 반환하거나 없으면 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cdb76fffe46f91856747d3f589e0a3ea42a00f8c" translate="yes" xml:space="preserve">
          <source>Lchown changes the numeric uid and gid of the named file. If the file is a symbolic link, it changes the uid and gid of the link itself. If there is an error, it will be of type *PathError.</source>
          <target state="translated">Lchown은 명명 된 파일의 숫자 uid와 gid를 변경합니다. 파일이 기호 링크 인 경우 링크 자체의 uid 및 gid가 변경됩니다. 오류가 있으면 * PathError 유형입니다.</target>
        </trans-unit>
        <trans-unit id="9f1275e6821f8a51315e2ca81450b41140587c42" translate="yes" xml:space="preserve">
          <source>Ldexp is the inverse of Frexp. It returns frac &amp;times; 2**exp.</source>
          <target state="translated">Ldexp는 Frexp의 역수입니다. frac &amp;times; 2 ** exp를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0bfbea9fa1b1bd75227de20412ea5faba23da169" translate="yes" xml:space="preserve">
          <source>LeadingZeros returns the number of leading zero bits in x; the result is UintSize for x == 0.</source>
          <target state="translated">LeadingZeros는 x의 선행 0 비트 수를 반환합니다. 결과는 x == 0에 대한 UintSize입니다.</target>
        </trans-unit>
        <trans-unit id="e3dbef4bbdf5cce299ff063f0c95032879c3da58" translate="yes" xml:space="preserve">
          <source>LeadingZeros16</source>
          <target state="translated">LeadingZeros16</target>
        </trans-unit>
        <trans-unit id="44f8376c5ec759270046aff7d8e5b19117ded5c1" translate="yes" xml:space="preserve">
          <source>LeadingZeros16 returns the number of leading zero bits in x; the result is 16 for x == 0.</source>
          <target state="translated">LeadingZeros16은 x의 선행 0 비트 수를 반환합니다. x == 0의 경우 결과는 16입니다.</target>
        </trans-unit>
        <trans-unit id="e9ed6b4c7187930afe2c50c883fcac4812515684" translate="yes" xml:space="preserve">
          <source>LeadingZeros32</source>
          <target state="translated">LeadingZeros32</target>
        </trans-unit>
        <trans-unit id="d0f408a69a9bfc0c9d5428df849a3e3f9c88b61c" translate="yes" xml:space="preserve">
          <source>LeadingZeros32 returns the number of leading zero bits in x; the result is 32 for x == 0.</source>
          <target state="translated">LeadingZeros32는 x의 선행 0 비트 수를 반환합니다. x == 0의 경우 결과는 32입니다.</target>
        </trans-unit>
        <trans-unit id="f987ddc8abdaac6d127e5eafa8b11404f85e5b1a" translate="yes" xml:space="preserve">
          <source>LeadingZeros64</source>
          <target state="translated">LeadingZeros64</target>
        </trans-unit>
        <trans-unit id="fda83273480c3e8d70a28c2f123cbf299bd51fd9" translate="yes" xml:space="preserve">
          <source>LeadingZeros64 returns the number of leading zero bits in x; the result is 64 for x == 0.</source>
          <target state="translated">LeadingZeros64는 x의 선행 0 비트 수를 반환합니다. x == 0의 경우 결과는 64입니다.</target>
        </trans-unit>
        <trans-unit id="fda98988d92b8709dacc15db674b3e6e61682f64" translate="yes" xml:space="preserve">
          <source>LeadingZeros8</source>
          <target state="translated">LeadingZeros8</target>
        </trans-unit>
        <trans-unit id="d8a16180e08b654e4c4467808de5826069ff567a" translate="yes" xml:space="preserve">
          <source>LeadingZeros8 returns the number of leading zero bits in x; the result is 8 for x == 0.</source>
          <target state="translated">LeadingZeros8은 x의 선행 0 비트 수를 반환합니다. x == 0의 경우 결과는 8입니다.</target>
        </trans-unit>
        <trans-unit id="721bda08d146a886975a86dd204cbec756066f9e" translate="yes" xml:space="preserve">
          <source>Least Surprise Property: &quot;A developer (or code reviewer) familiar with HTML, CSS, and JavaScript, who knows that contextual autoescaping happens should be able to look at a {{.}} and correctly infer what sanitization happens.&quot;</source>
          <target state="translated">최소한의 놀람 속성 : &quot;문맥 자동 이스케이프가 발생한다는 것을 알고있는 HTML, CSS 및 JavaScript에 익숙한 개발자 (또는 코드 검토 자)는 {{.}}을 (를)보고 위생 처리를 올바르게 유추 할 수 있어야합니다.&quot;</target>
        </trans-unit>
        <trans-unit id="8d92112ff544a635650fbaf730715150d27bea5c" translate="yes" xml:space="preserve">
          <source>Len computes the number of elements in ring r. It executes in time proportional to the number of elements.</source>
          <target state="translated">Len은 링 r의 요소 수를 계산합니다. 요소 수에 비례하여 시간에 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="1399044ec4cebde1e345bfb6e7bc0665028c448d" translate="yes" xml:space="preserve">
          <source>Len returns the length of array a. A negative result indicates an unknown length.</source>
          <target state="translated">Len은 배열 a의 길이를 반환합니다. 음수 결과는 알 수없는 길이를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="93ef3e242273d75e5bb1dbc766c5fd7830570833" translate="yes" xml:space="preserve">
          <source>Len returns the minimum number of bits required to represent x; the result is 0 for x == 0.</source>
          <target state="translated">Len은 x를 나타내는 데 필요한 최소 비트 수를 반환합니다. x == 0의 경우 결과는 0입니다.</target>
        </trans-unit>
        <trans-unit id="ca5afaea7adacd073486db0f70027386a60f94b6" translate="yes" xml:space="preserve">
          <source>Len returns the number of accumulated bytes; b.Len() == len(b.String()).</source>
          <target state="translated">Len은 누적 된 바이트 수를 반환합니다. b. Len () == len (b.String ()).</target>
        </trans-unit>
        <trans-unit id="ee2f279ceb0f8a58afdf88fefe8cee3f9c31fa50" translate="yes" xml:space="preserve">
          <source>Len returns the number of bytes of the unread portion of the buffer; b.Len() == len(b.Bytes()).</source>
          <target state="translated">Len은 버퍼의 읽지 않은 부분의 바이트 수를 리턴합니다. b. Len () == len (b.Bytes ()).</target>
        </trans-unit>
        <trans-unit id="67467f9c2f5df39d1ac34826fd0579c560dedb06" translate="yes" xml:space="preserve">
          <source>Len returns the number of bytes of the unread portion of the slice.</source>
          <target state="translated">Len은 슬라이스에서 읽지 않은 부분의 바이트 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9a34422a61609509fefc4a297f2f9c07ff69ccf9" translate="yes" xml:space="preserve">
          <source>Len returns the number of bytes of the unread portion of the string.</source>
          <target state="translated">Len은 읽지 않은 문자열 부분의 바이트 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="be3ac6245438d5424b518ab2335163e6f1965692" translate="yes" xml:space="preserve">
          <source>Len returns the number of elements of list l. The complexity is O(1).</source>
          <target state="translated">Len은리스트 l의 요소 수를 반환합니다. 복잡도는 O (1)입니다.</target>
        </trans-unit>
        <trans-unit id="a7b0b1334a129ccc7a0e235fc902ddfdb01aa234" translate="yes" xml:space="preserve">
          <source>Len returns the number of methods in s.</source>
          <target state="translated">Len은 s의 메소드 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9909b01102ccbea5c34e603dc1a8df16cade5eea" translate="yes" xml:space="preserve">
          <source>Len returns the number of scope elements.</source>
          <target state="translated">Len은 범위 요소 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8315c44360f57db88aab9b44a76e81307e540e3a" translate="yes" xml:space="preserve">
          <source>Len returns the number variables of tuple t.</source>
          <target state="translated">Len은 튜플 t의 숫자 변수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ca8349640e110d5798f69868438b094ed5d5cb6c" translate="yes" xml:space="preserve">
          <source>Len returns v's length. It panics if v's Kind is not Array, Chan, Map, Slice, or String.</source>
          <target state="translated">Len은 v의 길이를 반환합니다. v의 Kind가 Array, Chan, Map, Slice 또는 String이 아닌 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b58611e03df383dbaa4dc9ba6fd2e4a6b8e52327" translate="yes" xml:space="preserve">
          <source>Len16</source>
          <target state="translated">Len16</target>
        </trans-unit>
        <trans-unit id="f5e60795826c955dcfd526c1230894564783d120" translate="yes" xml:space="preserve">
          <source>Len16 returns the minimum number of bits required to represent x; the result is 0 for x == 0.</source>
          <target state="translated">Len16은 x를 나타내는 데 필요한 최소 비트 수를 반환합니다. x == 0의 경우 결과는 0입니다.</target>
        </trans-unit>
        <trans-unit id="76efc8ef8d6465f58231c9d295309a299f1d8534" translate="yes" xml:space="preserve">
          <source>Len32</source>
          <target state="translated">Len32</target>
        </trans-unit>
        <trans-unit id="2bdd325b510dd0548fcbb4a4b3c4d52a4f66d711" translate="yes" xml:space="preserve">
          <source>Len32 returns the minimum number of bits required to represent x; the result is 0 for x == 0.</source>
          <target state="translated">Len32는 x를 나타내는 데 필요한 최소 비트 수를 반환합니다. x == 0의 경우 결과는 0입니다.</target>
        </trans-unit>
        <trans-unit id="5bed2d704a16234c65f3795d3067f97369c94923" translate="yes" xml:space="preserve">
          <source>Len64</source>
          <target state="translated">Len64</target>
        </trans-unit>
        <trans-unit id="67dd373d63df43f7c3cfe611f388cdd1def82589" translate="yes" xml:space="preserve">
          <source>Len64 returns the minimum number of bits required to represent x; the result is 0 for x == 0.</source>
          <target state="translated">Len64는 x를 나타내는 데 필요한 최소 비트 수를 반환합니다. x == 0의 경우 결과는 0입니다.</target>
        </trans-unit>
        <trans-unit id="5877dcf480cd63f747b4cd7b2e4473a4fb01962a" translate="yes" xml:space="preserve">
          <source>Len8</source>
          <target state="translated">Len8</target>
        </trans-unit>
        <trans-unit id="ead2ce671d2982c7db8677f2bb62a7b4fdd9a8e8" translate="yes" xml:space="preserve">
          <source>Len8 returns the minimum number of bits required to represent x; the result is 0 for x == 0.</source>
          <target state="translated">Len8은 x를 나타내는 데 필요한 최소 비트 수를 반환합니다. x == 0의 경우 결과는 0입니다.</target>
        </trans-unit>
        <trans-unit id="2981abdd30fd95f0ea0e0799884f920048d0fba8" translate="yes" xml:space="preserve">
          <source>Length returns the JavaScript property &quot;length&quot; of v. It panics if v is not a JavaScript object.</source>
          <target state="translated">Length는 v의 JavaScript 속성 &quot;length&quot;를 반환합니다. v가 JavaScript 객체가 아닌 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f0f51015552f0c7df8f3dcfecc5c896adfb05b7f" translate="yes" xml:space="preserve">
          <source>Length returns the column type length for variable length column types such as text and binary field types. If the type length is unbounded the value will be math.MaxInt64 (any database limits will still apply). If the column type is not variable length, such as an int, or if not supported by the driver ok is false.</source>
          <target state="translated">길이는 텍스트 및 이진 필드 유형과 같은 가변 길이 열 유형에 대한 열 유형 길이를 반환합니다. 유형 길이가 제한되지 않으면 값은 math.MaxInt64입니다 (데이터베이스 제한은 여전히 ​​적용됨). 열 유형이 int와 같이 가변 길이가 아니거나 드라이버가 지원하지 않는 경우 ok는 false입니다.</target>
        </trans-unit>
        <trans-unit id="7467b2c9a7e459bce96e4603f4b9c0fecbbea6e6" translate="yes" xml:space="preserve">
          <source>Lgamma returns the natural logarithm and sign (-1 or +1) of Gamma(x).</source>
          <target state="translated">Lgamma는 감마 (x)의 자연 로그와 부호 (-1 또는 +1)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7db120ff0add5b38c6339cbb76ef30243d16848f" translate="yes" xml:space="preserve">
          <source>Licensed under the Creative Commons Attribution License 3.0.</source>
          <target state="translated">Creative Commons Attribution License 3.0에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="7d9d345bfff5b874e03396293193a78237bde2df" translate="yes" xml:space="preserve">
          <source>Like Scanf and Fscanf, Sscanf need not consume its entire input. There is no way to recover how much of the input string Sscanf used.</source>
          <target state="translated">Scanf 및 Fscanf와 마찬가지로 Sscanf는 전체 입력을 사용할 필요가 없습니다. 사용 된 입력 문자열 Sscanf의 양을 복구 할 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="7e1cb140c6b5c5e4e4aa15375a7a581d31852d58" translate="yes" xml:space="preserve">
          <source>Like in tests, benchmark logs are accumulated during execution and dumped to standard error when done. Unlike in tests, benchmark logs are always printed, so as not to hide output whose existence may be affecting benchmark results.</source>
          <target state="translated">테스트와 마찬가지로 벤치 마크 로그는 실행 중에 누적되고 완료되면 표준 오류로 덤프됩니다. 테스트와 달리 벤치 마크 로그는 항상 인쇄되므로 벤치 마크 결과에 영향을 줄 수있는 출력을 숨기지 않습니다.</target>
        </trans-unit>
        <trans-unit id="64d7a9c098ae2cc78ad63fdda4f717ce942dd2cc" translate="yes" xml:space="preserve">
          <source>Like the RoundTripper interface, the error types returned by RoundTrip are unspecified.</source>
          <target state="translated">RoundTripper 인터페이스와 마찬가지로 RoundTrip에서 반환 된 오류 유형은 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8c3e2cc8bde5ef9c910164a74c49f21b4ecb6bc1" translate="yes" xml:space="preserve">
          <source>LimitReader</source>
          <target state="translated">LimitReader</target>
        </trans-unit>
        <trans-unit id="82f17ce7a899200e83a237fbfff2e0aec18adc46" translate="yes" xml:space="preserve">
          <source>LimitReader returns a Reader that reads from r but stops with EOF after n bytes. The underlying implementation is a *LimitedReader.</source>
          <target state="translated">LimitReader는 r에서 읽지 만 n 바이트 후에 EOF로 중지되는 Reader를 반환합니다. 기본 구현은 * LimitedReader입니다.</target>
        </trans-unit>
        <trans-unit id="dfc4ccc73713d6d0c21377e9d4eb82cf06cf9ec2" translate="yes" xml:space="preserve">
          <source>Line returns the line number for the given file position p; p must be a Pos value in that file or NoPos.</source>
          <target state="translated">Line은 주어진 파일 위치 p에 대한 행 번호를 리턴합니다. p는 해당 파일의 Pos 값이거나 NoPos 여야합니다.</target>
        </trans-unit>
        <trans-unit id="c80f69f5d4f28c6e33fd6610f08a1143f38de111" translate="yes" xml:space="preserve">
          <source>LineCount returns the number of lines in file f.</source>
          <target state="translated">LineCount는 파일 f의 줄 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8021239ce81a740af9d1126d1dcb955373ee8d6d" translate="yes" xml:space="preserve">
          <source>LineReader returns a new reader for the line table of compilation unit cu, which must be an Entry with tag TagCompileUnit.</source>
          <target state="translated">LineReader는 컴파일 단위 cu의 행 테이블에 대한 새 리더를 리턴합니다.이 태그는 TagCompileUnit 태그가있는 항목이어야합니다.</target>
        </trans-unit>
        <trans-unit id="d6e6998fd35451f00c85f965d2d22dc96e7bd958" translate="yes" xml:space="preserve">
          <source>LineStart returns the Pos value of the start of the specified line. It ignores any alternative positions set using AddLineColumnInfo. LineStart panics if the 1-based line number is invalid.</source>
          <target state="translated">LineStart는 지정된 줄 시작의 Pos 값을 반환합니다. AddLineColumnInfo를 사용하여 설정 한 대체 위치는 무시합니다. 1 기반 줄 번호가 유효하지 않으면 LineStart 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4776e3cbe12ee14e372370ae9f2a2f5ec9999059" translate="yes" xml:space="preserve">
          <source>LineToPC looks up the first program counter on the given line in the named file. It returns UnknownPathError or UnknownLineError if there is an error looking up this line.</source>
          <target state="translated">LineToPC는 명명 된 파일에서 주어진 행의 첫 번째 프로그램 카운터를 찾습니다. 이 줄을 찾는 동안 오류가 발생하면 UnknownPathError 또는 UnknownLineError를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e41c87878f5ec2dd68efcc90f4932d27c2b8d1c2" translate="yes" xml:space="preserve">
          <source>LineToPC returns the program counter for the given line number, considering only program counters before maxpc.</source>
          <target state="translated">LineToPC는 maxpc 이전의 프로그램 카운터 만 고려하여 주어진 행 번호에 대한 프로그램 카운터를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="d3ece36672b155d5080f24d88b4ef4dc56af15c6" translate="yes" xml:space="preserve">
          <source>Link connects ring r with ring s such that r.Next() becomes s and returns the original value for r.Next(). r must not be empty.</source>
          <target state="translated">Link는 r.Next ()가 s가되도록 r과 ring s를 연결하고 r.Next ()의 원래 값을 리턴합니다. r은 비워 둘 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="61bc01a247b2210bb40d4dab78269bb633df6036" translate="yes" xml:space="preserve">
          <source>Link creates newname as a hard link to the oldname file. If there is an error, it will be of type *LinkError.</source>
          <target state="translated">링크는 새 이름을 이전 이름 ​​파일에 대한 하드 링크로 만듭니다. 오류가 있으면 * LinkError 유형입니다.</target>
        </trans-unit>
        <trans-unit id="8c53bb40a220e2f4f66bfd2012a9dda9a12bc64f" translate="yes" xml:space="preserve">
          <source>LinkError records an error during a link or symlink or rename system call and the paths that caused it.</source>
          <target state="translated">LinkError는 링크 또는 심볼릭 링크 또는 시스템 호출 이름 변경 및 오류를 발생시킨 경로에서 오류를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="2ca439921c0481dec50573fdcf5a08b538a5f2a3" translate="yes" xml:space="preserve">
          <source>List represents a doubly linked list. The zero value for List is an empty list ready to use.</source>
          <target state="translated">목록은 이중 연결 목록을 나타냅니다. List의 0 값은 사용 가능한 빈 목록입니다.</target>
        </trans-unit>
        <trans-unit id="ed96ea56ffbf3b559f9c41465dc17435379898fd" translate="yes" xml:space="preserve">
          <source>ListNode holds a sequence of nodes.</source>
          <target state="translated">ListNode는 일련의 노드를 보유합니다.</target>
        </trans-unit>
        <trans-unit id="ca24c0263416d5489002e073f3f7f972b1a2c801" translate="yes" xml:space="preserve">
          <source>Listen announces on the local network address.</source>
          <target state="translated">Listen은 로컬 네트워크 주소를 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="fbc501a375c74f3f294816964a99702dd99275fe" translate="yes" xml:space="preserve">
          <source>Listen creates a TLS listener accepting connections on the given network address using net.Listen. The configuration config must be non-nil and must include at least one certificate or else set GetCertificate.</source>
          <target state="translated">Listen은 net.Listen을 사용하여 지정된 네트워크 주소에서 연결을 수락하는 TLS 수신기를 만듭니다. 구성 구성은 0이 아니어야하며 하나 이상의 인증서를 포함하거나 GetCertificate를 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="6c1bd8cd11c9c376470f7f547014d7596b4d2372" translate="yes" xml:space="preserve">
          <source>ListenAndServe</source>
          <target state="translated">ListenAndServe</target>
        </trans-unit>
        <trans-unit id="ca4b599f82e29135dc1efc68105574de3edf6ae1" translate="yes" xml:space="preserve">
          <source>ListenAndServe always returns a non-nil error.</source>
          <target state="translated">ListenAndServe는 항상 0이 아닌 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5dd294a2ba295a8af34a90f46a25099808a8e7bb" translate="yes" xml:space="preserve">
          <source>ListenAndServe always returns a non-nil error. After Shutdown or Close, the returned error is ErrServerClosed.</source>
          <target state="translated">ListenAndServe는 항상 0이 아닌 오류를 반환합니다. 종료 또는 닫기 후 반환 된 오류는 ErrServerClosed입니다.</target>
        </trans-unit>
        <trans-unit id="0e017d6f66fb57e5159203491154acdfd7f3155e" translate="yes" xml:space="preserve">
          <source>ListenAndServe listens on the TCP network address addr and then calls Serve with handler to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives.</source>
          <target state="translated">ListenAndServe는 TCP 네트워크 주소 가산기를 수신 한 다음 처리기로 Serve를 호출하여 들어오는 연결의 요청을 처리합니다. 허용 된 연결은 TCP 연결 유지를 사용하도록 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="1eb6871fd885bb71d1764b988ed8e0b1207dbd10" translate="yes" xml:space="preserve">
          <source>ListenAndServe listens on the TCP network address srv.Addr and then calls Serve to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives.</source>
          <target state="translated">ListenAndServe는 TCP 네트워크 주소 srv.Addr에서 수신 한 다음 Serve를 호출하여 들어오는 연결에 대한 요청을 처리합니다. 허용 된 연결은 TCP 연결 유지를 사용하도록 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="f672409681724db7975a81f059dabf70eb0a6552" translate="yes" xml:space="preserve">
          <source>ListenAndServe starts an HTTP server with a given address and handler. The handler is usually nil, which means to use DefaultServeMux. Handle and HandleFunc add handlers to DefaultServeMux:</source>
          <target state="translated">ListenAndServe는 주어진 주소와 핸들러로 HTTP 서버를 시작합니다. 핸들러는 일반적으로 nil이므로 DefaultServeMux를 사용합니다. Handle 및 HandleFunc는 DefaultServeMux에 핸들러를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="b1444c4d4c91aea2ff2c287b0f4c6b6c33effbc6" translate="yes" xml:space="preserve">
          <source>ListenAndServeTLS</source>
          <target state="translated">ListenAndServeTLS</target>
        </trans-unit>
        <trans-unit id="4b13ffad776ec4c1e6e622baa48939390c7f43be" translate="yes" xml:space="preserve">
          <source>ListenAndServeTLS acts identically to ListenAndServe, except that it expects HTTPS connections. Additionally, files containing a certificate and matching private key for the server must be provided. If the certificate is signed by a certificate authority, the certFile should be the concatenation of the server's certificate, any intermediates, and the CA's certificate.</source>
          <target state="translated">ListenAndServeTLS는 HTTPS 연결이 필요하다는 점을 제외하고 ListenAndServe와 동일하게 작동합니다. 또한 서버에 대한 인증서 및 일치하는 개인 키를 포함하는 파일이 제공되어야합니다. 인증 기관이 인증서에 서명 한 경우 certFile은 서버 인증서, 중간체 및 CA 인증서를 연결해야합니다.</target>
        </trans-unit>
        <trans-unit id="e993bc61c7cd05bdd6aa504a7bf534f06ff70ebd" translate="yes" xml:space="preserve">
          <source>ListenAndServeTLS always returns a non-nil error. After Shutdown or Close, the returned error is ErrServerClosed.</source>
          <target state="translated">ListenAndServeTLS는 항상 0이 아닌 오류를 반환합니다. 종료 또는 닫기 후 반환 된 오류는 ErrServerClosed입니다.</target>
        </trans-unit>
        <trans-unit id="4de6956912052ccb175eeb5c4727583b8c87a58f" translate="yes" xml:space="preserve">
          <source>ListenAndServeTLS listens on the TCP network address srv.Addr and then calls ServeTLS to handle requests on incoming TLS connections. Accepted connections are configured to enable TCP keep-alives.</source>
          <target state="translated">ListenAndServeTLS는 TCP 네트워크 주소 srv.Addr에서 수신 한 다음 ServeTLS를 호출하여 들어오는 TLS 연결에 대한 요청을 처리합니다. 허용 된 연결은 TCP 연결 유지를 사용하도록 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="2ef32140a96f71533a922e8af1a4a1287b2aa08c" translate="yes" xml:space="preserve">
          <source>ListenConfig contains options for listening to an address.</source>
          <target state="translated">ListenConfig에는 주소를 듣기위한 옵션이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="56e637fe09ab78156ad9d4b14c696af0fcd5c313" translate="yes" xml:space="preserve">
          <source>ListenIP acts like ListenPacket for IP networks.</source>
          <target state="translated">ListenIP는 IP 네트워크 용 ListenPacket처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="f21580354d675fc10d1e9ee1c4db6486064ec455" translate="yes" xml:space="preserve">
          <source>ListenMulticastUDP acts like ListenPacket for UDP networks but takes a group address on a specific network interface.</source>
          <target state="translated">ListenMulticastUDP는 UDP 네트워크 용 ListenPacket처럼 작동하지만 특정 네트워크 인터페이스에서 그룹 주소를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="867f2d87132f64efe5f8f6f86d2c98549b471fdb" translate="yes" xml:space="preserve">
          <source>ListenMulticastUDP is just for convenience of simple, small applications. There are golang.org/x/net/ipv4 and golang.org/x/net/ipv6 packages for general purpose uses.</source>
          <target state="translated">ListenMulticastUDP는 단순하고 작은 응용 프로그램의 편의를위한 것입니다. 일반적인 용도의 golang.org/x/net/ipv4 및 golang.org/x/net/ipv6 패키지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd5f6e57a541e39939141511f957be405b380471" translate="yes" xml:space="preserve">
          <source>ListenMulticastUDP listens on all available IP addresses of the local system including the group, multicast IP address. If ifi is nil, ListenMulticastUDP uses the system-assigned multicast interface, although this is not recommended because the assignment depends on platforms and sometimes it might require routing configuration. If the Port field of gaddr is 0, a port number is automatically chosen.</source>
          <target state="translated">ListenMulticastUDP는 그룹 멀티 캐스트 IP 주소를 포함하여 로컬 시스템의 사용 가능한 모든 IP 주소를 수신합니다. ifi가 nil 인 경우 ListenMulticastUDP는 시스템 할당 멀티 캐스트 인터페이스를 사용하지만 할당은 플랫폼에 따라 다르며 때로는 라우팅 구성이 필요할 수 있으므로 권장하지 않습니다. gaddr의 포트 필드가 0이면 포트 번호가 자동으로 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="468da55aa49f2b551af4d2ec242f5d19018b56ca" translate="yes" xml:space="preserve">
          <source>ListenPacket announces on the local network address.</source>
          <target state="translated">ListenPacket은 로컬 네트워크 주소를 발표합니다.</target>
        </trans-unit>
        <trans-unit id="df604088a8b978cdce196e569a7b165e976e6869" translate="yes" xml:space="preserve">
          <source>ListenTCP acts like Listen for TCP networks.</source>
          <target state="translated">ListenTCP는 TCP 네트워크 수신과 같은 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="9851cfe87c5b9ef168f40038c7d75b3a82ee3529" translate="yes" xml:space="preserve">
          <source>ListenUDP acts like ListenPacket for UDP networks.</source>
          <target state="translated">ListenUDP는 UDP 네트워크 용 ListenPacket처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="5b7757b4611e8ba6d66b663a1f48d50bfcf3ecc4" translate="yes" xml:space="preserve">
          <source>ListenUnix acts like Listen for Unix networks.</source>
          <target state="translated">ListenUnix는 Unix 네트워크 청취와 같은 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="df0abb591dbf2fca4d32aeb087ddbb3eb5bf7905" translate="yes" xml:space="preserve">
          <source>ListenUnixgram acts like ListenPacket for Unix networks.</source>
          <target state="translated">ListenUnixgram은 Unix 네트워크 용 ListenPacket처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="37ea46b5942beaeb21bb4e06a14e4f7232d2a1b0" translate="yes" xml:space="preserve">
          <source>Listener</source>
          <target state="translated">Listener</target>
        </trans-unit>
        <trans-unit id="0391fe0f913571d2818f72cca0ff528d31c4414b" translate="yes" xml:space="preserve">
          <source>LiteralPrefix returns a literal string that must begin any match of the regular expression re. It returns the boolean true if the literal string comprises the entire regular expression.</source>
          <target state="translated">LiteralPrefix는 정규 표현식 re와 일치하는 문자를 시작해야하는 리터럴 문자열을 반환합니다. 리터럴 문자열이 전체 정규식을 포함하는 경우 부울 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="ecdd85ee0de784370070e365d9f936724803e148" translate="yes" xml:space="preserve">
          <source>LittleEndian is the little-endian implementation of ByteOrder.</source>
          <target state="translated">LittleEndian은 ByteOrder의 리틀 엔디안 구현입니다.</target>
        </trans-unit>
        <trans-unit id="d5ae70e267716ec3e2a976b68757e30ee0e214a8" translate="yes" xml:space="preserve">
          <source>Load returns the value set by the most recent Store. It returns nil if there has been no call to Store for this Value.</source>
          <target state="translated">Load는 가장 최근 Store에서 설정 한 값을 반환합니다. 이 값에 대한 Store 호출이 없으면 nil을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="74c5a2d6710e8b201a98f6c2837198f613eec0fa" translate="yes" xml:space="preserve">
          <source>Load returns the value stored in the map for a key, or nil if no value is present. The ok result indicates whether value was found in the map.</source>
          <target state="translated">Load는 키에 대한 맵에 저장된 값을 반환하거나 값이 없으면 nil을 반환합니다. ok 결과는 맵에서 값을 찾았는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="881052b1a20f63445e79814467ecdb5374883ab0" translate="yes" xml:space="preserve">
          <source>LoadInt32 atomically loads *addr.</source>
          <target state="translated">LoadInt32는 * addr을 원자 적으로로드합니다.</target>
        </trans-unit>
        <trans-unit id="2ac3794cf69cbb4165a4ee85d8ea313e85610e69" translate="yes" xml:space="preserve">
          <source>LoadInt64 atomically loads *addr.</source>
          <target state="translated">LoadInt64는 * addr을 원자 적으로로드합니다.</target>
        </trans-unit>
        <trans-unit id="3cd00c96c1dde37f4e165d9dd83f094e52c09c97" translate="yes" xml:space="preserve">
          <source>LoadLocation</source>
          <target state="translated">LoadLocation</target>
        </trans-unit>
        <trans-unit id="942c4e15f8861257bc29d285e307a9855ad8da88" translate="yes" xml:space="preserve">
          <source>LoadLocation returns the Location with the given name.</source>
          <target state="translated">LoadLocation은 주어진 이름으로 Location을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="452c7f6aa0b947a115cd7ebee668ccabc28767f6" translate="yes" xml:space="preserve">
          <source>LoadLocationFromTZData returns a Location with the given name initialized from the IANA Time Zone database-formatted data. The data should be in the format of a standard IANA time zone file (for example, the content of /etc/localtime on Unix systems).</source>
          <target state="translated">LoadLocationFromTZData는 IANA 표준 시간대 데이터베이스 형식 데이터에서 초기화 된 지정된 이름의 위치를 ​​반환합니다. 데이터는 표준 IANA 표준 시간대 파일 형식이어야합니다 (예 : Unix 시스템의 / etc / localtime 내용).</target>
        </trans-unit>
        <trans-unit id="730b9fd8d031760ad2f11544687c7f3a4c32ba10" translate="yes" xml:space="preserve">
          <source>LoadOrStore returns the existing value for the key if present. Otherwise, it stores and returns the given value. The loaded result is true if the value was loaded, false if stored.</source>
          <target state="translated">LoadOrStore는 존재하는 경우 키의 기존 값을 반환합니다. 그렇지 않으면 주어진 값을 저장하고 반환합니다. 로드 된 결과는 값이로드 된 경우 true이고 저장되면 false입니다.</target>
        </trans-unit>
        <trans-unit id="16e5531718ad0441ff996bffe1bdb2f9013072b8" translate="yes" xml:space="preserve">
          <source>LoadPointer atomically loads *addr.</source>
          <target state="translated">LoadPointer는 * addr을 원자 적으로로드합니다.</target>
        </trans-unit>
        <trans-unit id="3a58860dce2950635c9b0aec0356bd0e023fcd4b" translate="yes" xml:space="preserve">
          <source>LoadUint32 atomically loads *addr.</source>
          <target state="translated">LoadUint32는 * addr을 원자 적으로로드합니다.</target>
        </trans-unit>
        <trans-unit id="ed4689d0f224e4c5a01ae1b69433a91e9f118b20" translate="yes" xml:space="preserve">
          <source>LoadUint64 atomically loads *addr.</source>
          <target state="translated">LoadUint64는 * addr을 원자 적으로로드합니다.</target>
        </trans-unit>
        <trans-unit id="9cfbde985c4614b9808e9de0d65afb5568c9c53d" translate="yes" xml:space="preserve">
          <source>LoadUintptr atomically loads *addr.</source>
          <target state="translated">LoadUintptr은 * addr을 원자 적으로로드합니다.</target>
        </trans-unit>
        <trans-unit id="e85b79501e4b543de03554e2a29fd9cbd965ec40" translate="yes" xml:space="preserve">
          <source>LoadX509KeyPair</source>
          <target state="translated">LoadX509KeyPair</target>
        </trans-unit>
        <trans-unit id="45fae6424c26a4b8eb19ae242ef820e6061dab08" translate="yes" xml:space="preserve">
          <source>LoadX509KeyPair reads and parses a public/private key pair from a pair of files. The files must contain PEM encoded data. The certificate file may contain intermediate certificates following the leaf certificate to form a certificate chain. On successful return, Certificate.Leaf will be nil because the parsed form of the certificate is not retained.</source>
          <target state="translated">LoadX509KeyPair는 한 쌍의 파일에서 공개 / 개인 키 쌍을 읽고 구문 분석합니다. 파일에는 PEM 인코딩 데이터가 포함되어야합니다. 인증서 파일에는 리프 인증서 뒤에 인증서 체인을 형성하는 중간 인증서가 포함될 수 있습니다. 성공적으로 반환되면 구문 분석 된 인증서 형식이 유지되지 않으므로 Certificate.Leaf는 0이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="1da25ed4d4f6ff8e68f5335ba8ba070399bd7f5f" translate="yes" xml:space="preserve">
          <source>Local represents the system's local time zone.</source>
          <target state="translated">로컬은 시스템의 현지 시간대를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="bd6d294473bbbfce0d1197b903b10c86fb6c3b7b" translate="yes" xml:space="preserve">
          <source>Local returns t with the location set to local time.</source>
          <target state="translated">현지 시간은 현지 시간으로 설정된 위치에서 t를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4a5ab837cb8b234abbab484d911af5705d613e13" translate="yes" xml:space="preserve">
          <source>LocalAddr returns the local network address.</source>
          <target state="translated">LocalAddr은 로컬 네트워크 주소를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c10eb870360e8baad53b9b506e944815aa5896df" translate="yes" xml:space="preserve">
          <source>LocalAddr returns the local network address. The Addr returned is shared by all invocations of LocalAddr, so do not modify it.</source>
          <target state="translated">LocalAddr은 로컬 네트워크 주소를 반환합니다. 리턴 된 Addr은 LocalAddr의 모든 호출에서 공유되므로 수정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="238b4cd4fe464f99416bb574ab9c5c6651970ad5" translate="yes" xml:space="preserve">
          <source>LocalhostCert is a PEM-encoded TLS cert with SAN IPs &quot;127.0.0.1&quot; and &quot;[::1]&quot;, expiring at Jan 29 16:00:00 2084 GMT. generated from src/crypto/tls: go run generate_cert.go --rsa-bits 1024 --host 127.0.0.1,::1,example.com --ca --start-date &quot;Jan 1 00:00:00 1970&quot; --duration=1000000h</source>
          <target state="translated">LocalhostCert는 SAN IP가 &quot;127.0.0.1&quot;및 &quot;[:: 1]&quot;인 PEM으로 인코딩 된 TLS 인증서로, 2084 년 1 월 29 일 16:00:00에 만료됩니다. src / crypto / tls에서 생성됨 : go run generate_cert.go --rsa-bits 1024 --host 127.0.0.1, :: 1, example.com --ca --start-date &quot;Jan 1 00:00:00 1970 &quot;--duration = 1000000h</target>
        </trans-unit>
        <trans-unit id="2852b827de5091ca5aa6958386fa1405befa6094" translate="yes" xml:space="preserve">
          <source>LocalhostKey is the private key for localhostCert.</source>
          <target state="translated">LocalhostKey는 localhostCert의 개인 키입니다.</target>
        </trans-unit>
        <trans-unit id="d219c68101f532de10add2cf42fb9dbeca73d3be" translate="yes" xml:space="preserve">
          <source>Location</source>
          <target state="translated">Location</target>
        </trans-unit>
        <trans-unit id="c9551a197b6ccbbe733e98e1afb44218648f365d" translate="yes" xml:space="preserve">
          <source>Location returns the URL of the response's &quot;Location&quot; header, if present. Relative redirects are resolved relative to the Response's Request. ErrNoLocation is returned if no Location header is present.</source>
          <target state="translated">Location은 응답의 &quot;Location&quot;헤더 (있는 경우)의 URL을 반환합니다. 상대 리디렉션은 응답 요청과 관련하여 해결됩니다. Location 헤더가 없으면 ErrNoLocation이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6b99376f9c15a7e92154da5850b5d13b41ab37cc" translate="yes" xml:space="preserve">
          <source>Location returns the time zone information associated with t.</source>
          <target state="translated">위치는 t와 관련된 시간대 정보를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f30d8c256e2218530f9f115302f529d73fbbff9d" translate="yes" xml:space="preserve">
          <source>Lock locks m. If the lock is already in use, the calling goroutine blocks until the mutex is available.</source>
          <target state="translated">잠금 장치 m. 잠금이 이미 사용중인 경우 호출 고 루틴은 뮤텍스를 사용할 수있을 때까지 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="c3a987424c4290a7edfb3d1d597eb0eadb3ba378" translate="yes" xml:space="preserve">
          <source>Lock locks rw for writing. If the lock is already locked for reading or writing, Lock blocks until the lock is available.</source>
          <target state="translated">쓰기를위한 잠금 잠금 rw. 읽기 또는 쓰기를 위해 잠금이 이미 잠겨 있으면 잠금을 사용할 수있을 때까지 잠금이 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="5e340916752857a7b67a505378d157d115c1dd5a" translate="yes" xml:space="preserve">
          <source>LockOSThread wires the calling goroutine to its current operating system thread. The calling goroutine will always execute in that thread, and no other goroutine will execute in it, until the calling goroutine has made as many calls to UnlockOSThread as to LockOSThread. If the calling goroutine exits without unlocking the thread, the thread will be terminated.</source>
          <target state="translated">LockOSThread는 호출 고 루틴을 현재 운영 체제 스레드에 연결합니다. 호출 goroutine은 항상 해당 스레드에서 실행되며 호출 goroutine이 LockOSThread만큼 UnlockOSThread를 호출 할 때까지 다른 goroutine은 실행되지 않습니다. 스레드를 잠금 해제하지 않고 호출 고 루틴이 종료되면 스레드가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="8bf95ea372568c7a254ba9fada5f6f1701ebc5b5" translate="yes" xml:space="preserve">
          <source>Log</source>
          <target state="translated">Log</target>
        </trans-unit>
        <trans-unit id="fef609891d98d73a3ae686771d1e86e56fc90748" translate="yes" xml:space="preserve">
          <source>Log emits a one-off event with the given category and message. Category can be empty and the API assumes there are only a handful of unique categories in the system.</source>
          <target state="translated">로그는 주어진 카테고리 및 메시지와 함께 일회성 이벤트를 생성합니다. 카테고리는 비어있을 수 있으며 API는 시스템에 소수의 고유 카테고리 만 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="2353b4e8ade1606ef5c45cccd26ad3ad6087c78a" translate="yes" xml:space="preserve">
          <source>Log emits a timestamped message to the execution trace along with additional information such as the category of the message and which goroutine called Log. The execution tracer provides UIs to filter and group goroutines using the log category and the message supplied in Log.</source>
          <target state="translated">로그는 메시지 범주 및 로그라는 goroutine과 같은 추가 정보와 함께 타임 스탬프 된 메시지를 실행 추적에 보냅니다. 실행 추적 프로그램은 로그 범주와 로그에 제공된 메시지를 사용하여 고 루틴을 필터링하고 그룹화하는 UI를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9821e0db1231d181423f2e3b3225f154baa6bcf6" translate="yes" xml:space="preserve">
          <source>Log formats its arguments using default formatting, analogous to Println, and records the text in the error log. For tests, the text will be printed only if the test fails or the -test.v flag is set. For benchmarks, the text is always printed to avoid having performance depend on the value of the -test.v flag.</source>
          <target state="translated">Log는 Println과 유사한 기본 형식을 사용하여 인수의 형식을 지정하고 텍스트를 오류 로그에 기록합니다. 테스트의 경우 테스트에 실패하거나 -test.v 플래그가 설정된 경우에만 텍스트가 인쇄됩니다. 벤치 마크의 경우, 텍스트는 항상 -test.v 플래그의 값에 따라 성능이 달라지지 않도록 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="ad88d5c498edf7ea21028a5246446ba6a3bf9e4a" translate="yes" xml:space="preserve">
          <source>Log returns the natural logarithm of x.</source>
          <target state="translated">Log는 x의 자연 로그를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="81d615cdf905d64451161a1aa0b68ae0ffb374e3" translate="yes" xml:space="preserve">
          <source>Log10</source>
          <target state="translated">Log10</target>
        </trans-unit>
        <trans-unit id="977a2b5c893e89719e9a7736a4e1f9cc525e8f11" translate="yes" xml:space="preserve">
          <source>Log10 returns the decimal logarithm of x.</source>
          <target state="translated">Log10은 x의 10 진수 로그를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8671c0c40d7db0093d8bf62e5f04cba5c99ec3ea" translate="yes" xml:space="preserve">
          <source>Log10 returns the decimal logarithm of x. The special cases are the same as for Log.</source>
          <target state="translated">Log10은 x의 10 진수 로그를 반환합니다. 특별한 경우는 Log와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="a5b2fd4cb1a8e2bb305b5672e391aef89a37298c" translate="yes" xml:space="preserve">
          <source>Log1p returns the natural logarithm of 1 plus its argument x. It is more accurate than Log(1 + x) when x is near zero.</source>
          <target state="translated">Log1p는 자연 대수 1에 인수 x를 더한 값을 반환합니다. x가 0에 가까울 때 Log (1 + x)보다 더 정확합니다.</target>
        </trans-unit>
        <trans-unit id="6687db9bf747c384bcc8d36417e42b952196b766" translate="yes" xml:space="preserve">
          <source>Log2</source>
          <target state="translated">Log2</target>
        </trans-unit>
        <trans-unit id="7a0389c8675757d7572efc0a10b125d5c66b151f" translate="yes" xml:space="preserve">
          <source>Log2 returns the binary logarithm of x. The special cases are the same as for Log.</source>
          <target state="translated">Log2는 x의 이진 로그를 반환합니다. 특별한 경우는 Log와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="5963a7c64c0149e44b174ff76b7f701d23bc3074" translate="yes" xml:space="preserve">
          <source>Logb returns the binary exponent of x.</source>
          <target state="translated">Logb는 x의 이진 지수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ea0c4052b7cdd5aadd9cd6f72174db65e462d77d" translate="yes" xml:space="preserve">
          <source>Logf formats its arguments according to the format, analogous to Printf, and records the text in the error log. A final newline is added if not provided. For tests, the text will be printed only if the test fails or the -test.v flag is set. For benchmarks, the text is always printed to avoid having performance depend on the value of the -test.v flag.</source>
          <target state="translated">Logf는 Printf와 유사한 형식에 따라 인수의 형식을 지정하고 텍스트를 오류 로그에 기록합니다. 제공되지 않으면 최종 줄 바꿈이 추가됩니다. 테스트의 경우 테스트에 실패하거나 -test.v 플래그가 설정된 경우에만 텍스트가 인쇄됩니다. 벤치 마크의 경우, 텍스트는 항상 -test.v 플래그의 값에 따라 성능이 달라지지 않도록 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="38de20acad3e04f48129d8399f6a41e7517acf40" translate="yes" xml:space="preserve">
          <source>Logf is like Log, but the value is formatted using the specified format spec.</source>
          <target state="translated">Logf는 Log와 비슷하지만 값은 지정된 형식 사양을 사용하여 형식이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="8432c24573f3f89fad60802fe8eddf1da6315768" translate="yes" xml:space="preserve">
          <source>Logger</source>
          <target state="translated">Logger</target>
        </trans-unit>
        <trans-unit id="71c466638d24f772f0edc78440c6db3a9b5a9e5d" translate="yes" xml:space="preserve">
          <source>Logger.Output</source>
          <target state="translated">Logger.Output</target>
        </trans-unit>
        <trans-unit id="00aa9c00206cc40c149f1a777f6bcbff0a6df954" translate="yes" xml:space="preserve">
          <source>Longest makes future searches prefer the leftmost-longest match. That is, when matching against text, the regexp returns a match that begins as early as possible in the input (leftmost), and among those it chooses a match that is as long as possible. This method modifies the Regexp and may not be called concurrently with any other methods.</source>
          <target state="translated">가장 길면 향후 검색에서 가장 왼쪽 일치하는 항목을 선호합니다. 즉, 텍스트와 일치하는 경우 정규 표현식은 입력 (가장 왼쪽)에서 가능한 한 빨리 시작되는 일치를 반환하며 그 중에서 가능한 한 긴 일치를 선택합니다. 이 메소드는 Regexp를 수정하며 다른 메소드와 동시에 호출 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2397e2af778033b693f99aeecb7590b807be4783" translate="yes" xml:space="preserve">
          <source>LookPath</source>
          <target state="translated">LookPath</target>
        </trans-unit>
        <trans-unit id="3feb8389b758c68212533dd8278b352dcce121bf" translate="yes" xml:space="preserve">
          <source>LookPath searches for an executable named file in the directories named by the PATH environment variable. If file contains a slash, it is tried directly and the PATH is not consulted. The result may be an absolute path or a path relative to the current directory.</source>
          <target state="translated">LookPath는 PATH 환경 변수로 명명 된 디렉토리에서 파일 명명 된 실행 파일을 검색합니다. 파일에 슬래시가 포함되어 있으면 직접 시도하고 PATH를 참조하지 않습니다. 결과는 절대 경로이거나 현재 디렉토리에 상대적인 경로 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31ab9ed47ac6872e6361cf76170e61fbc5a37449" translate="yes" xml:space="preserve">
          <source>Lookup looks up a user by username. If the user cannot be found, the returned error is of type UnknownUserError.</source>
          <target state="translated">조회는 사용자 이름으로 사용자를 찾습니다. 사용자를 찾을 수 없으면 리턴 된 오류는 UnknownUserError 유형입니다.</target>
        </trans-unit>
        <trans-unit id="2c6f1e000a822d2c47b6a21ebdd8f5f93b104795" translate="yes" xml:space="preserve">
          <source>Lookup maps an identifier to its keyword token or IDENT (if not a keyword).</source>
          <target state="translated">조회는 식별자를 키워드 토큰 또는 IDENT (키워드가 아닌 경우)에 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="e9251196227d6115352b68461b921cf61a906b43" translate="yes" xml:space="preserve">
          <source>Lookup returns an unsorted list of at most n indices where the byte string s occurs in the indexed data. If n &amp;lt; 0, all occurrences are returned. The result is nil if s is empty, s is not found, or n == 0. Lookup time is O(log(N)*len(s) + len(result)) where N is the size of the indexed data.</source>
          <target state="translated">조회는 인덱싱 된 데이터에서 바이트 문자열 s가 발생하는 최대 n 개의 인덱스로 정렬되지 않은 목록을 반환합니다. n &amp;lt;0이면 모든 발생이 반환됩니다. s가 비어 있거나 s가 없거나 n == 0이면 결과는 nil입니다. 조회 시간은 O (log (N) * len (s) + len (result))입니다. 여기서 N은 인덱싱 된 데이터의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="13380eb03660f02dbd5d025d2b74f6f24450d311" translate="yes" xml:space="preserve">
          <source>Lookup returns the Flag structure of the named command-line flag, returning nil if none exists.</source>
          <target state="translated">Lookup은 명명 된 명령 줄 플래그의 플래그 구조를 반환하고 존재하지 않는 경우 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7e5483b0c984c3a57ec759db6fb278e7b255ecf8" translate="yes" xml:space="preserve">
          <source>Lookup returns the Flag structure of the named flag, returning nil if none exists.</source>
          <target state="translated">Lookup은 명명 된 플래그의 Flag 구조를 반환하고 존재하지 않는 경우 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5b0f26aebf1133c7a9f5776675b02659900d5a6f" translate="yes" xml:space="preserve">
          <source>Lookup returns the method with matching package and name, or nil if not found.</source>
          <target state="translated">Lookup은 일치하는 패키지 및 이름을 가진 메소드를 리턴하거나 찾지 못하면 nil을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="903dddeee2a83198e7d326397e76f54d9c716c8e" translate="yes" xml:space="preserve">
          <source>Lookup returns the object in scope s with the given name if such an object exists; otherwise the result is nil.</source>
          <target state="translated">Lookup은 해당 오브젝트가 존재하는 경우 지정된 이름으로 범위의 오브젝트를 리턴합니다. 그렇지 않으면 결과는 nil입니다.</target>
        </trans-unit>
        <trans-unit id="103697c251b3570afaab5577775dc041e648c7f1" translate="yes" xml:space="preserve">
          <source>Lookup returns the object with the given name if it is found in scope s, otherwise it returns nil. Outer scopes are ignored.</source>
          <target state="translated">Lookup은 scope에서 발견 된 경우 주어진 이름의 객체를 반환하고, 그렇지 않으면 nil을 반환합니다. 외부 범위는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="85596012a102f4cba55be912c69d163f2b6f529c" translate="yes" xml:space="preserve">
          <source>Lookup returns the profile with the given name, or nil if no such profile exists.</source>
          <target state="translated">조회는 지정된 이름의 프로파일을 리턴하거나 해당 프로파일이 없으면 nil을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="38285e372c5ecf7fee79e8f5475a7ad611b07ce7" translate="yes" xml:space="preserve">
          <source>Lookup returns the template with the given name that is associated with t, or nil if there is no such template.</source>
          <target state="translated">조회는 t와 연관된 지정된 이름의 템플리트를 리턴하거나 해당 템플리트가없는 경우 nil을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="b619549e7b11c0494158ea2b89e4d841aca101b2" translate="yes" xml:space="preserve">
          <source>Lookup returns the template with the given name that is associated with t. It returns nil if there is no such template or the template has no definition.</source>
          <target state="translated">조회는 t와 연관된 지정된 이름의 템플리트를 리턴합니다. 이러한 템플릿이 없거나 템플릿에 정의가 없으면 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c7a19da9ed723c89b3a482cb521b80e66fbdef7d" translate="yes" xml:space="preserve">
          <source>Lookup returns the value associated with key in the tag string. If the key is present in the tag the value (which may be empty) is returned. Otherwise the returned value will be the empty string. The ok return value reports whether the value was explicitly set in the tag string. If the tag does not have the conventional format, the value returned by Lookup is unspecified.</source>
          <target state="translated">조회는 태그 문자열에서 키와 관련된 값을 반환합니다. 태그에 키가 있으면 값이 비어있을 수 있습니다. 그렇지 않으면 반환 된 값은 빈 문자열이됩니다. ok 반환 값은 값이 태그 문자열에 명시 적으로 설정되었는지 여부를보고합니다. 태그에 일반적인 형식이 없으면 Lookup에서 반환 된 값이 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b1ca47c6e14b4100767398ad08b18ceba8715515" translate="yes" xml:space="preserve">
          <source>Lookup searches for a symbol named symName in plugin p. A symbol is any exported variable or function. It reports an error if the symbol is not found. It is safe for concurrent use by multiple goroutines.</source>
          <target state="translated">검색은 플러그인 p에서 symName이라는 기호를 검색합니다. 심볼은 내 보낸 변수 또는 함수입니다. 기호가 없으면 오류를보고합니다. 여러 고 루틴이 동시에 사용하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="99f5d988af7e6ab773a1a6146dd567b1c079995f" translate="yes" xml:space="preserve">
          <source>LookupAddr performs a reverse lookup for the given address, returning a list of names mapping to that address.</source>
          <target state="translated">LookupAddr은 주어진 주소에 대해 역방향 조회를 수행하여 해당 주소에 매핑되는 이름 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c70e79ec87ca49562ea197d9f2381d9321d8fe1b" translate="yes" xml:space="preserve">
          <source>LookupCNAME returns the canonical name for the given host. Callers that do not care about the canonical name can call LookupHost or LookupIP directly; both take care of resolving the canonical name as part of the lookup.</source>
          <target state="translated">LookupCNAME은 지정된 호스트의 정식 이름을 반환합니다. 표준 이름을 신경 쓰지 않는 발신자는 LookupHost 또는 LookupIP를 직접 호출 할 수 있습니다. 둘 다 조회의 일부로 정식 이름을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="8f4cf5e540b2d7dc315df0e1c1d62f60bab0e907" translate="yes" xml:space="preserve">
          <source>LookupEnv</source>
          <target state="translated">LookupEnv</target>
        </trans-unit>
        <trans-unit id="1ae2ee5065be9305542647e69dc65b9fd29b64fe" translate="yes" xml:space="preserve">
          <source>LookupEnv retrieves the value of the environment variable named by the key. If the variable is present in the environment the value (which may be empty) is returned and the boolean is true. Otherwise the returned value will be empty and the boolean will be false.</source>
          <target state="translated">LookupEnv는 키로 명명 된 환경 변수의 값을 검색합니다. 변수가 환경에 존재하면 값 (비어있을 수 있음)이 리턴되고 부울 값은 true입니다. 그렇지 않으면 반환 된 값은 비어 있고 부울은 거짓입니다.</target>
        </trans-unit>
        <trans-unit id="450e346d69b1c045fb4f52550736ebb0d1d8a4f8" translate="yes" xml:space="preserve">
          <source>LookupFieldOrMethod looks up a field or method with given package and name in T and returns the corresponding *Var or *Func, an index sequence, and a bool indicating if there were any pointer indirections on the path to the field or method. If addressable is set, T is the type of an addressable variable (only matters for method lookups).</source>
          <target state="translated">LookupFieldOrMethod는 주어진 패키지와 이름이 T로 된 필드 또는 메소드를 조회하고 해당 * Var 또는 * Func, 인덱스 시퀀스 및 필드 또는 메소드의 경로에 포인터 간접 지시가 있는지를 나타내는 부울을 리턴합니다. 주소 지정 가능이 설정되면 T는 주소 지정 가능 변수의 유형입니다 (메소드 조회에만 중요 함).</target>
        </trans-unit>
        <trans-unit id="9411c991fe6ec6318c1ddadaf5239d4c8ddf419e" translate="yes" xml:space="preserve">
          <source>LookupFunc returns the text, data, or bss symbol with the given name, or nil if no such symbol is found.</source>
          <target state="translated">LookupFunc는 지정된 이름의 텍스트, 데이터 또는 bss 기호를 반환하거나 그러한 기호가 없으면 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b92e9ccf5cc37f1e202dab80af7fdd5adb2d4fdf" translate="yes" xml:space="preserve">
          <source>LookupGroup looks up a group by name. If the group cannot be found, the returned error is of type UnknownGroupError.</source>
          <target state="translated">LookupGroup은 이름별로 그룹을 찾습니다. 그룹을 찾을 수 없으면 리턴 된 오류는 UnknownGroupError 유형입니다.</target>
        </trans-unit>
        <trans-unit id="864ecbbe82138c5e60336462e2e26b9cc0321aa1" translate="yes" xml:space="preserve">
          <source>LookupGroupId looks up a group by groupid. If the group cannot be found, the returned error is of type UnknownGroupIdError.</source>
          <target state="translated">LookupGroupId는 groupid별로 그룹을 찾습니다. 그룹을 찾을 수 없으면 리턴 된 오류는 UnknownGroupIdError 유형입니다.</target>
        </trans-unit>
        <trans-unit id="b9002491d44dda33fcc5ee2b368b90bad48de6db" translate="yes" xml:space="preserve">
          <source>LookupHost looks up the given host using the local resolver. It returns a slice of that host's addresses.</source>
          <target state="translated">LookupHost는 로컬 리졸버를 사용하여 지정된 호스트를 찾습니다. 해당 호스트 주소의 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e9702748a7f19b9de210233c47deec534e3b2cf2" translate="yes" xml:space="preserve">
          <source>LookupIP looks up host using the local resolver. It returns a slice of that host's IPv4 and IPv6 addresses.</source>
          <target state="translated">LookupIP는 로컬 확인자를 사용하여 호스트를 찾습니다. 해당 호스트의 IPv4 및 IPv6 주소 조각을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f974c6e0590936cd53144b751f0c8c53e1e56f97" translate="yes" xml:space="preserve">
          <source>LookupIPAddr looks up host using the local resolver. It returns a slice of that host's IPv4 and IPv6 addresses.</source>
          <target state="translated">LookupIPAddr은 로컬 리졸버를 사용하여 호스트를 찾습니다. 해당 호스트의 IPv4 및 IPv6 주소의 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="39cfba6c5476e7337eb21e14ebf7cf0d6e5bedc2" translate="yes" xml:space="preserve">
          <source>LookupId looks up a user by userid. If the user cannot be found, the returned error is of type UnknownUserIdError.</source>
          <target state="translated">LookupId는 사용자 ID별로 사용자를 찾습니다. 사용자를 찾을 수 없으면 리턴 된 오류는 UnknownUserIdError 유형입니다.</target>
        </trans-unit>
        <trans-unit id="fa6df437374a8db7470645bbe9d4e27c81caaaeb" translate="yes" xml:space="preserve">
          <source>LookupMX returns the DNS MX records for the given domain name sorted by preference.</source>
          <target state="translated">LookupMX는 기본 도메인별로 지정된 도메인 이름에 대한 DNS MX 레코드를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="eb321dee8209258e986d88d75de6022a02c641f4" translate="yes" xml:space="preserve">
          <source>LookupNS returns the DNS NS records for the given domain name.</source>
          <target state="translated">LookupNS는 주어진 도메인 이름에 대한 DNS NS 레코드를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="74ae49fce9af1a0aa1c34cc08bb2eaff3e2f9136" translate="yes" xml:space="preserve">
          <source>LookupParent follows the parent chain of scopes starting with s until it finds a scope where Lookup(name) returns a non-nil object, and then returns that scope and object. If a valid position pos is provided, only objects that were declared at or before pos are considered. If no such scope and object exists, the result is (nil, nil).</source>
          <target state="translated">LookupParent는 Lookup (name)이 null이 아닌 개체를 반환하는 범위를 찾은 다음 해당 범위와 개체를 반환 할 때까지 s로 시작하는 범위의 부모 체인을 따릅니다. 유효한 위치 pos가 제공되면 pos 또는 pos 전에 선언 된 오브젝트 만 고려됩니다. 이러한 범위와 개체가 없으면 결과는 (nil, nil)입니다.</target>
        </trans-unit>
        <trans-unit id="0730b69dbfb75d19ecc78b2277aae489ac068a4f" translate="yes" xml:space="preserve">
          <source>LookupPort looks up the port for the given network and service.</source>
          <target state="translated">LookupPort는 주어진 네트워크 및 서비스에 대한 포트를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="f0a5a2c68645491f7f14b8ebf958dd03393284be" translate="yes" xml:space="preserve">
          <source>LookupSRV constructs the DNS name to look up following RFC 2782. That is, it looks up _service._proto.name. To accommodate services publishing SRV records under non-standard names, if both service and proto are empty strings, LookupSRV looks up name directly.</source>
          <target state="translated">LookupSRV는 RFC 2782 다음에 조회 할 DNS 이름을 구성합니다. 즉, _service._proto.name을 찾습니다. 비표준 이름으로 SRV 레코드를 게시하는 서비스를 수용하기 위해 service와 proto가 모두 빈 문자열 인 경우 LookupSRV는 이름을 직접 찾습니다.</target>
        </trans-unit>
        <trans-unit id="6b37c6078d739a1c536ea751e03fbdc7bcfb4fd9" translate="yes" xml:space="preserve">
          <source>LookupSRV tries to resolve an SRV query of the given service, protocol, and domain name. The proto is &quot;tcp&quot; or &quot;udp&quot;. The returned records are sorted by priority and randomized by weight within a priority.</source>
          <target state="translated">LookupSRV는 지정된 서비스, 프로토콜 및 도메인 이름의 SRV 쿼리를 확인하려고합니다. 프로토 타입은 &quot;tcp&quot;또는 &quot;udp&quot;입니다. 반환 된 레코드는 우선 순위별로 정렬되고 우선 순위 내에서 가중치별로 무작위로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="53adeca568bb0a57f84e1f9d5ebd3b79ee2295f0" translate="yes" xml:space="preserve">
          <source>LookupSym returns the text, data, or bss symbol with the given name, or nil if no such symbol is found.</source>
          <target state="translated">LookupSym은 주어진 이름의 텍스트, 데이터 또는 bss 기호를 반환하고, 그러한 기호가 없으면 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e3ed61b0b0e3039a19a182ecd64a64ecece699f9" translate="yes" xml:space="preserve">
          <source>LookupTXT returns the DNS TXT records for the given domain name.</source>
          <target state="translated">LookupTXT는 주어진 도메인 이름에 대한 DNS TXT 레코드를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="be0fd93650565eb4e261e38483006a0a6e96ae35" translate="yes" xml:space="preserve">
          <source>Lsh sets z = x &amp;lt;&amp;lt; n and returns z.</source>
          <target state="translated">Lsh는 z = x &amp;lt;&amp;lt; n을 설정하고 z를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8432c7185b33f226f3a96e2aaaeb0017fbd79a53" translate="yes" xml:space="preserve">
          <source>Lstat returns a FileInfo describing the named file. If the file is a symbolic link, the returned FileInfo describes the symbolic link. Lstat makes no attempt to follow the link. If there is an error, it will be of type *PathError.</source>
          <target state="translated">Lstat는 명명 된 파일을 설명하는 FileInfo를 반환합니다. 파일이 기호 링크 인 경우, 리턴 된 FileInfo는 기호 링크를 설명합니다. Lstat는 링크를 따르려고 시도하지 않습니다. 오류가 있으면 * PathError 유형입니다.</target>
        </trans-unit>
        <trans-unit id="653b7ad5571eb02f2761c383b0762a05ad1e21e9" translate="yes" xml:space="preserve">
          <source>M is a type passed to a TestMain function to run the actual tests.</source>
          <target state="translated">M은 실제 테스트를 실행하기 위해 TestMain 함수에 전달 된 유형입니다.</target>
        </trans-unit>
        <trans-unit id="6c4afe9957321d9f90932c8eebed2802a4ac1436" translate="yes" xml:space="preserve">
          <source>MD5 is cryptographically broken and should not be used for secure applications.</source>
          <target state="translated">MD5는 암호화 방식으로 손상되어 보안 응용 프로그램에 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="2c0f2626fcfbcf6f5cc06f45f9a06123950573c9" translate="yes" xml:space="preserve">
          <source>Machine is found in Header.Machine.</source>
          <target state="translated">기계는 Header.Machine에 있습니다.</target>
        </trans-unit>
        <trans-unit id="abd1aeb6203ae00a3b2e20d1890fa31ee8357446" translate="yes" xml:space="preserve">
          <source>Magic number for the elf trampoline, chosen wisely to be an immediate value.</source>
          <target state="translated">엘프 트램폴린의 마법 번호는 현명한 가치로 현명하게 선택되었습니다.</target>
        </trans-unit>
        <trans-unit id="d30cb76631db62a976ef3584c436e5f44c54006c" translate="yes" xml:space="preserve">
          <source>Mail issues a MAIL command to the server using the provided email address. If the server supports the 8BITMIME extension, Mail adds the BODY=8BITMIME parameter. This initiates a mail transaction and is followed by one or more Rcpt calls.</source>
          <target state="translated">Mail은 제공된 이메일 주소를 사용하여 서버에 MAIL 명령을 발행합니다. 서버가 8BITMIME 확장자를 지원하면 Mail은 BODY = 8BITMIME 매개 변수를 추가합니다. 이것은 메일 트랜잭션을 시작하고 하나 이상의 Rcpt 호출이 뒤 따릅니다.</target>
        </trans-unit>
        <trans-unit id="62bce9422ff2d14f69ab80a154510232fc8a9afd" translate="yes" xml:space="preserve">
          <source>Main</source>
          <target state="translated">Main</target>
        </trans-unit>
        <trans-unit id="0784ed59d6aa6164d650ee5788e4f48c9ab53ccb" translate="yes" xml:space="preserve">
          <source>Main is an internal function, part of the implementation of the &quot;go test&quot; command. It was exported because it is cross-package and predates &quot;internal&quot; packages. It is no longer used by &quot;go test&quot; but preserved, as much as possible, for other systems that simulate &quot;go test&quot; using Main, but Main sometimes cannot be updated as new functionality is added to the testing package. Systems simulating &quot;go test&quot; should be updated to use MainStart.</source>
          <target state="translated">Main은 &quot;go test&quot;명령 구현의 일부인 내부 기능입니다. 크로스 패키지이고 &quot;내부&quot;패키지보다 오래 되었기 때문에 내보냈습니다. Main을 사용하여 &quot;go test&quot;를 시뮬레이트하는 다른 시스템에서는 더 이상 &quot;go test&quot;에서 사용되지 않지만 가능한 한 많이 보존되지만 새로운 기능이 테스트 패키지에 추가되면 Main을 업데이트 할 수없는 경우가 있습니다. &quot;시작 테스트&quot;를 시뮬레이션하는 시스템은 MainStart를 사용하도록 업데이트해야합니다.</target>
        </trans-unit>
        <trans-unit id="b4948070b9137e3c4295247505827d161a1430c0" translate="yes" xml:space="preserve">
          <source>MainStart is meant for use by tests generated by 'go test'. It is not meant to be called directly and is not subject to the Go 1 compatibility document. It may change signature from release to release.</source>
          <target state="translated">MainStart는 'go test'에 의해 생성 된 테스트에 사용됩니다. 직접 호출하기위한 것이 아니며 Go 1 호환성 문서의 적용을받지 않습니다. 서명이 릴리스마다 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76f0e763aa0460d3ebdb6819d8a8618bd610502c" translate="yes" xml:space="preserve">
          <source>Make returns the Value for x.</source>
          <target state="translated">Make는 x의 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d212d37a7f555035543edd9847aa0f8944d00dd6" translate="yes" xml:space="preserve">
          <source>MakeBool returns the Bool value for b.</source>
          <target state="translated">MakeBool은 b에 대한 Bool 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1bde4b612786d9c5dc71f0124e7f5aff783bd040" translate="yes" xml:space="preserve">
          <source>MakeChan creates a new channel with the specified type and buffer size.</source>
          <target state="translated">MakeChan은 지정된 유형과 버퍼 크기로 새 채널을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="8499a9ac9172e4fd5f8c155f860005e583c8290f" translate="yes" xml:space="preserve">
          <source>MakeFloat64 returns the Float value for x. If x is not finite, the result is an Unknown.</source>
          <target state="translated">MakeFloat64는 x에 대한 Float 값을 반환합니다. x가 유한하지 않으면 결과는 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="080b5a4b73c758656574c66abecfca2800793e12" translate="yes" xml:space="preserve">
          <source>MakeFromBytes returns the Int value given the bytes of its little-endian binary representation. An empty byte slice argument represents 0.</source>
          <target state="translated">MakeFromBytes는 리틀 엔디안 이진 표현의 바이트가 주어진 Int 값을 반환합니다. 빈 바이트 슬라이스 인수는 0을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="04110b4029f3d51d7f1b1e32dfd59973aae981d8" translate="yes" xml:space="preserve">
          <source>MakeFromLiteral returns the corresponding integer, floating-point, imaginary, character, or string value for a Go literal string. The tok value must be one of token.INT, token.FLOAT, token.IMAG, token.CHAR, or token.STRING. The final argument must be zero. If the literal string syntax is invalid, the result is an Unknown.</source>
          <target state="translated">MakeFromLiteral은 Go 리터럴 문자열에 해당하는 정수, 부동 소수점, 허수, 문자 또는 문자열 값을 반환합니다. 토큰 값은 token.INT, token.FLOAT, token.IMAG, token.CHAR 또는 token.STRING 중 하나 여야합니다. 마지막 인수는 0이어야합니다. 리터럴 문자열 구문이 유효하지 않은 경우 결과는 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="07a7a52634a41aa9116fcfbf959be30745aab340" translate="yes" xml:space="preserve">
          <source>MakeFunc</source>
          <target state="translated">MakeFunc</target>
        </trans-unit>
        <trans-unit id="643c1268f2628745bb74a74c0b6210fc3a37b52e" translate="yes" xml:space="preserve">
          <source>MakeFunc returns a new function of the given Type that wraps the function fn. When called, that new function does the following:</source>
          <target state="translated">MakeFunc는 함수 fn을 래핑하는 지정된 Type의 새 함수를 반환합니다. 이 새로운 함수가 호출되면 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="e91507405a52b25c3084428772c7fd9dd85d29bc" translate="yes" xml:space="preserve">
          <source>MakeImag returns the Complex value x*i; x must be Int, Float, or Unknown. If x is Unknown, the result is Unknown.</source>
          <target state="translated">MakeImag는 복소수 값 x * i를 반환합니다. x는 Int, Float 또는 Unknown이어야합니다. x가 알 수없는 경우 결과는 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="da6ba30b4b9d9da1cda2bb8d92f1cb545785138a" translate="yes" xml:space="preserve">
          <source>MakeInt64 returns the Int value for x.</source>
          <target state="translated">MakeInt64는 x에 대한 Int 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f32c29a01762bfefeedc6eb9373c057117a43683" translate="yes" xml:space="preserve">
          <source>MakeMap creates a new map with the specified type.</source>
          <target state="translated">MakeMap은 지정된 유형의 새 맵을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="f52a4bb4c4b8bb40c53081e9faafbd87a3b197bc" translate="yes" xml:space="preserve">
          <source>MakeMapWithSize creates a new map with the specified type and initial space for approximately n elements.</source>
          <target state="translated">MakeMapWithSize는 약 n 개의 요소에 대해 지정된 유형과 초기 공간으로 새 맵을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="55769617e91451b5769c2caeaf264e53ded13fa6" translate="yes" xml:space="preserve">
          <source>MakeSlice creates a new zero-initialized slice value for the specified slice type, length, and capacity.</source>
          <target state="translated">MakeSlice는 지정된 슬라이스 유형, 길이 및 용량에 대해 새로운 0으로 초기화 된 슬라이스 값을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="fbaf52cf63ee748130cb04d59e9e62d4763220eb" translate="yes" xml:space="preserve">
          <source>MakeString returns the String value for s.</source>
          <target state="translated">MakeString은 s의 문자열 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5e3fa6d0673feb64d51f64ca41937f6da75eff62" translate="yes" xml:space="preserve">
          <source>MakeTable</source>
          <target state="translated">MakeTable</target>
        </trans-unit>
        <trans-unit id="785bab6ccfcc81c98865184a96f5abfea960b9ee" translate="yes" xml:space="preserve">
          <source>MakeTable returns a Table constructed from the specified polynomial. The contents of this Table must not be modified.</source>
          <target state="translated">MakeTable은 지정된 다항식으로 구성된 테이블을 반환합니다. 이 표의 내용을 수정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="9a7cf77039092ac36f999962d307dd473ba79848" translate="yes" xml:space="preserve">
          <source>MakeUint64 returns the Int value for x.</source>
          <target state="translated">MakeUint64는 x에 대한 Int 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e3694e34668330687dd83b2555828d28784d9456" translate="yes" xml:space="preserve">
          <source>MakeUnknown returns the Unknown value.</source>
          <target state="translated">MakeUnknown은 Unknown 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fc2df9e4256f3cab4d6220a72b883983cc586bc1" translate="yes" xml:space="preserve">
          <source>MantExp breaks x into its mantissa and exponent components and returns the exponent. If a non-nil mant argument is provided its value is set to the mantissa of x, with the same precision and rounding mode as x. The components satisfy x == mant &amp;times; 2**exp, with 0.5 &amp;lt;= |mant| &amp;lt; 1.0. Calling MantExp with a nil argument is an efficient way to get the exponent of the receiver.</source>
          <target state="translated">MantExp는 x를 가수와 지수 성분으로 나누고 지수를 반환합니다. 0이 아닌 mant 인수가 제공되면 x와 동일한 정밀도 및 반올림 모드를 사용하여 값이 x의 가수로 설정됩니다. 구성 요소는 x == mant &amp;times; 2 ** exp를 만족하며 0.5 &amp;lt;= | mant | &amp;lt;1.0. nil 인수로 MantExp를 호출하는 것은 수신자의 지수를 얻는 효율적인 방법입니다.</target>
        </trans-unit>
        <trans-unit id="ab478f3efc840eebab919dff1b9512286f70c10c" translate="yes" xml:space="preserve">
          <source>Map</source>
          <target state="translated">Map</target>
        </trans-unit>
        <trans-unit id="053e42c081459c8a8812cfba3b82d0d77adea8da" translate="yes" xml:space="preserve">
          <source>Map is a string-to-Var map variable that satisfies the Var interface.</source>
          <target state="translated">Map은 Var 인터페이스를 만족하는 string-to-Var 맵 변수입니다.</target>
        </trans-unit>
        <trans-unit id="f35fa30552bf86b6a97457f5a529f46b1ec4ac90" translate="yes" xml:space="preserve">
          <source>Map is like a Go map[interface{}]interface{} but is safe for concurrent use by multiple goroutines without additional locking or coordination. Loads, stores, and deletes run in amortized constant time.</source>
          <target state="translated">맵은 Go 맵 [interface {}] 인터페이스 {}와 유사하지만 추가 잠금이나 조정없이 여러 고 루틴이 동시에 사용할 수 있습니다. 상각 된 일정한 시간에로드, 저장 및 삭제가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="a55357ddaf2509ac1bf72db741f5c0cb32477d6c" translate="yes" xml:space="preserve">
          <source>Map returns a copy of the byte slice s with all its characters modified according to the mapping function. If mapping returns a negative value, the character is dropped from the byte slice with no replacement. The characters in s and the output are interpreted as UTF-8-encoded code points.</source>
          <target state="translated">Map은 매핑 함수에 따라 모든 문자가 수정 된 바이트 슬라이스의 복사본을 반환합니다. 매핑이 음수 값을 반환하면 문자는 대체없이 바이트 슬라이스에서 삭제됩니다. 의 문자와 출력은 UTF-8로 인코딩 된 코드 포인트로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="0c9f196c46a54d96a050fd1d4b324297d8b6bbfd" translate="yes" xml:space="preserve">
          <source>Map returns a copy of the string s with all its characters modified according to the mapping function. If mapping returns a negative value, the character is dropped from the string with no replacement.</source>
          <target state="translated">Map은 매핑 함수에 따라 모든 문자가 수정 된 문자열의 복사본을 반환합니다. 매핑이 음수 값을 반환하면 문자가 문자열에서 대체없이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="4153ac6503fd2f26b78b101383b87a23ab8757a1" translate="yes" xml:space="preserve">
          <source>Map values are deeply equal when all of the following are true: they are both nil or both non-nil, they have the same length, and either they are the same map object or their corresponding keys (matched using Go equality) map to deeply equal values.</source>
          <target state="translated">다음 값이 모두 참이면 맵 값이 완전히 동일합니다.이 값은 모두 nil 또는 0이 아닌 값이며 길이가 같으며 동일한 맵 오브젝트 또는 해당 키 (Go equality를 사용하여 일치) 맵입니다. 동일한 값.</target>
        </trans-unit>
        <trans-unit id="ff4de2d02636ff0b35d7ac62c39c77c38ada9f83" translate="yes" xml:space="preserve">
          <source>Map values encode as JSON objects. The map's key type must either be a string, an integer type, or implement encoding.TextMarshaler. The map keys are sorted and used as JSON object keys by applying the following rules, subject to the UTF-8 coercion described for string values above:</source>
          <target state="translated">맵 값은 JSON 객체로 인코딩됩니다. 지도의 키 유형은 문자열, 정수 유형이거나 encoding.TextMarshaler를 구현해야합니다. 위의 문자열 값에 대해 설명 된 UTF-8 강제에 따라 다음 규칙을 적용하여 맵 키가 정렬되어 JSON 객체 키로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b746be79a80992b182da84fae71887f2ec6be3ae" translate="yes" xml:space="preserve">
          <source>MapIndex returns the value associated with key in the map v. It panics if v's Kind is not Map. It returns the zero Value if key is not found in the map or if v represents a nil map. As in Go, the key's value must be assignable to the map's key type.</source>
          <target state="translated">MapIndex는지도 v에서 키와 관련된 값을 반환합니다. v의 종류가지도가 아닌 경우 패닉이 발생합니다. 키가 맵에 없거나 v가 nil 맵을 나타내는 경우 0 값을 리턴합니다. Go와 마찬가지로 키의 값은지도의 키 유형에 할당 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="8a8f96c2a60281e18fdf86af937035c625b23750" translate="yes" xml:space="preserve">
          <source>MapKeys returns a slice containing all the keys present in the map, in unspecified order. It panics if v's Kind is not Map. It returns an empty slice if v represents a nil map.</source>
          <target state="translated">MapKeys는지도에있는 모든 키가 포함 된 슬라이스를 지정되지 않은 순서로 반환합니다. v의 종류가지도가 아닌 경우 패닉이 발생합니다. v가 nil 맵을 나타내는 경우 빈 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="393371509edfbb2648f262a9e6f9034fb677acf3" translate="yes" xml:space="preserve">
          <source>MapOf returns the map type with the given key and element types. For example, if k represents int and e represents string, MapOf(k, e) represents map[int]string.</source>
          <target state="translated">MapOf는 주어진 키와 요소 유형을 가진지도 유형을 반환합니다. 예를 들어, k가 int를 나타내고 e가 문자열을 나타내는 경우 MapOf (k, e)는 map [int] string을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d868be238acb64c17c8f70f0fad5dbca2528fe1a" translate="yes" xml:space="preserve">
          <source>MapRange returns a range iterator for a map. It panics if v's Kind is not Map.</source>
          <target state="translated">MapRange는지도의 범위 반복자를 반환합니다. v의 종류가지도가 아닌 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="61f910b08995efdd96acb55eeb3536149a9ef35f" translate="yes" xml:space="preserve">
          <source>Mapping between XML elements and data structures is inherently flawed: an XML element is an order-dependent collection of anonymous values, while a data structure is an order-independent collection of named values. See package json for a textual representation more suitable to data structures.</source>
          <target state="translated">XML 요소와 데이터 구조 간의 매핑은 본질적으로 결함이 있습니다. XML 요소는 순서에 따라 익명 값을 수집하는 반면 데이터 구조는 순서에 관계없이 명명 된 값을 수집합니다. 데이터 구조에 더 적합한 텍스트 표현은 패키지 json을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2b32ea0b0909e5260b55a58bd4f84f53b5d1ee01" translate="yes" xml:space="preserve">
          <source>Maps are sent as an unsigned count followed by that many key, element pairs. Empty but non-nil maps are sent, so if the receiver has not allocated one already, one will always be allocated on receipt unless the transmitted map is nil and not at the top level.</source>
          <target state="translated">지도는 서명되지 않은 개수로 전송되고 그 뒤에 여러 키, 요소 쌍이 전송됩니다. 비어 있지만 넌이 아닌 맵이 전송되므로, 수신자가 아직 할당하지 않은 경우, 전송 된 맵이 nil이고 최상위 레벨이 아닌 경우 수신시 항상 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="ea8cf739cc820968d208878224615030de7ce782" translate="yes" xml:space="preserve">
          <source>MarkComplete marks a package as complete.</source>
          <target state="translated">MarkComplete는 패키지를 완료된 것으로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="9cdfbcba7d735bd862886d7bc92cdad6e808e063" translate="yes" xml:space="preserve">
          <source>Marshal</source>
          <target state="translated">Marshal</target>
        </trans-unit>
        <trans-unit id="eb880bd9042393d95106d6336ca91dc7587c2469" translate="yes" xml:space="preserve">
          <source>Marshal converts a point into the uncompressed form specified in section 4.3.6 of ANSI X9.62.</source>
          <target state="translated">Marshal은 점을 ANSI X9.62의 4.3.6 절에 지정된 비 압축 형태로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="9dcb1e980e770758d048cdbf31965108d4392cbe" translate="yes" xml:space="preserve">
          <source>Marshal handles an array or slice by marshaling each of the elements. Marshal handles a pointer by marshaling the value it points at or, if the pointer is nil, by writing nothing. Marshal handles an interface value by marshaling the value it contains or, if the interface value is nil, by writing nothing. Marshal handles all other data by writing one or more XML elements containing the data.</source>
          <target state="translated">Marshal은 각 요소를 마샬링하여 배열 또는 슬라이스를 처리합니다. Marshal은 가리키는 값을 마샬링하거나 포인터가 nil 인 경우 아무 것도 쓰지 않으면 서 포인터를 처리합니다. Marshal은 포함 된 값을 마샬링하거나 인터페이스 값이 nil 인 경우 아무 것도 쓰지 않으면 서 인터페이스 값을 처리합니다. Marshal은 데이터를 포함하는 하나 이상의 XML 요소를 작성하여 다른 모든 데이터를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="62270c3791161d9e12b821a2dd5a09da76b7d939" translate="yes" xml:space="preserve">
          <source>Marshal returns the ASN.1 encoding of val.</source>
          <target state="translated">Marshal은 val의 ASN.1 인코딩을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d0688338eb6d31b2244e733d8a38556baae70f6c" translate="yes" xml:space="preserve">
          <source>Marshal returns the JSON encoding of v.</source>
          <target state="translated">Marshal은 v의 JSON 인코딩을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fd91d49c812b62dbf02b368713f03ffdd50b3ad6" translate="yes" xml:space="preserve">
          <source>Marshal returns the XML encoding of v.</source>
          <target state="translated">Marshal은 v의 XML 인코딩을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0de0f4cea1e586ddc2b14ecaaa41c4020891c164" translate="yes" xml:space="preserve">
          <source>Marshal traverses the value v recursively. If an encountered value implements the Marshaler interface and is not a nil pointer, Marshal calls its MarshalJSON method to produce JSON. If no MarshalJSON method is present but the value implements encoding.TextMarshaler instead, Marshal calls its MarshalText method and encodes the result as a JSON string. The nil pointer exception is not strictly necessary but mimics a similar, necessary exception in the behavior of UnmarshalJSON.</source>
          <target state="translated">원수는 값 v를 재귀 적으로 순회합니다. 발견 된 값이 Marshaler 인터페이스를 구현하고 nil 포인터가 아닌 경우 Marshal은 MarshalJSON 메소드를 호출하여 JSON을 생성합니다. MarshalJSON 메서드가 없지만 값이 encoding.TextMarshaler를 구현하는 경우 Marshal은 MarshalText 메서드를 호출하고 결과를 JSON 문자열로 인코딩합니다. nil 포인터 예외는 반드시 필요한 것은 아니지만 UnmarshalJSON의 동작에서 비슷하고 필요한 예외를 모방합니다.</target>
        </trans-unit>
        <trans-unit id="fafaa1ebf620f3798cc6a8c58b669a7ea73fa6b9" translate="yes" xml:space="preserve">
          <source>Marshal will return an error if asked to marshal a channel, function, or map.</source>
          <target state="translated">채널, 함수 또는 맵을 마샬링하도록 요청하면 Marshal에서 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="db453e34c5fbd8220b129af743f7150483dd7932" translate="yes" xml:space="preserve">
          <source>MarshalBinary encodes the receiver into a binary form and returns the result.</source>
          <target state="translated">MarshalBinary는 수신자를 이진 형식으로 인코딩하고 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0bedf8f876a84577084ab2b16cacfd3254f063b2" translate="yes" xml:space="preserve">
          <source>MarshalBinary implements the encoding.BinaryMarshaler interface.</source>
          <target state="translated">MarshalBinary는 encoding.BinaryMarshaler 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="ee53c721c287cd02dbf9f92c9f5e2a991f1f615d" translate="yes" xml:space="preserve">
          <source>MarshalECPrivateKey converts an EC private key to SEC 1, ASN.1 DER form.</source>
          <target state="translated">MarshalECPrivateKey는 EC 개인 키를 SEC 1, ASN.1 DER 형식으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="f9e73b7909d7a048a7d6c9e44a0504b100446e17" translate="yes" xml:space="preserve">
          <source>MarshalIndent</source>
          <target state="translated">MarshalIndent</target>
        </trans-unit>
        <trans-unit id="42cea4e6f776e84fbd92d4a9f5ef1c3b218c54ea" translate="yes" xml:space="preserve">
          <source>MarshalIndent is like Marshal but applies Indent to format the output. Each JSON element in the output will begin on a new line beginning with prefix followed by one or more copies of indent according to the indentation nesting.</source>
          <target state="translated">MarshalIndent는 Marshal과 비슷하지만 들여 쓰기를 적용하여 출력 형식을 지정합니다. 출력의 각 JSON 요소는 접두사로 시작하고 들여 쓰기 중첩에 따라 하나 이상의 들여 쓰기 사본이 오는 새 줄에서 시작합니다.</target>
        </trans-unit>
        <trans-unit id="b93c5c2e6a3ce1b1ffab83edfd3027b2f5a958ee" translate="yes" xml:space="preserve">
          <source>MarshalIndent works like Marshal, but each XML element begins on a new indented line that starts with prefix and is followed by one or more copies of indent according to the nesting depth.</source>
          <target state="translated">MarshalIndent는 Marshal처럼 작동하지만 각 XML 요소는 접두사로 시작하고 중첩 깊이에 따라 하나 이상의 들여 쓰기 복사본이 오는 새 들여 쓰기 된 줄에서 시작합니다.</target>
        </trans-unit>
        <trans-unit id="1fe8186b542a0c93fd906dfbf1d378366d66b83e" translate="yes" xml:space="preserve">
          <source>MarshalJSON implements the json.Marshaler interface.</source>
          <target state="translated">MarshalJSON은 json.Marshaler 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="34cafb57f3bf4f148de8715aea906ddd24ca5b67" translate="yes" xml:space="preserve">
          <source>MarshalJSON implements the json.Marshaler interface. The time is a quoted string in RFC 3339 format, with sub-second precision added if present.</source>
          <target state="translated">MarshalJSON은 json.Marshaler 인터페이스를 구현합니다. 시간은 RFC 3339 형식의 따옴표로 묶인 문자열이며, 존재하는 경우 초 이하의 정밀도가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="79739908efedb1d030bbc1bed7fc419173d502bc" translate="yes" xml:space="preserve">
          <source>MarshalJSON returns m as the JSON encoding of m.</source>
          <target state="translated">MarshalJSON은 m을 JSON 인코딩으로 m을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="49c4c53b126d5e728f2103ee05aeb8456df06352" translate="yes" xml:space="preserve">
          <source>MarshalPKCS1PrivateKey converts an RSA private key to PKCS#1, ASN.1 DER form.</source>
          <target state="translated">MarshalPKCS1PrivateKey는 RSA 개인 키를 PKCS # 1, ASN.1 DER 형식으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="6dbb4afc98d66ecc773730ab53b2d3d25670dae3" translate="yes" xml:space="preserve">
          <source>MarshalPKCS1PublicKey converts an RSA public key to PKCS#1, ASN.1 DER form.</source>
          <target state="translated">MarshalPKCS1PublicKey는 RSA 공개 키를 PKCS # 1, ASN.1 DER 형식으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="de5c14e75241b3422cb105f3219299fa62dfe8b0" translate="yes" xml:space="preserve">
          <source>MarshalPKCS8PrivateKey converts an RSA private key to PKCS#8, ASN.1 DER form.</source>
          <target state="translated">MarshalPKCS8PrivateKey는 RSA 개인 키를 PKCS # 8, ASN.1 DER 형식으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="7c79ebdd42b60d7be91053c9a1161ea6d5ebbab9" translate="yes" xml:space="preserve">
          <source>MarshalPKIXPublicKey converts a public key to PKIX, ASN.1 DER form.</source>
          <target state="translated">MarshalPKIXPublicKey는 공개 키를 PKIX, ASN.1 DER 형식으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="def0005fff87679bf808d28ec17c1164d884c779" translate="yes" xml:space="preserve">
          <source>MarshalText encodes the receiver into UTF-8-encoded text and returns the result.</source>
          <target state="translated">MarshalText는 수신자를 UTF-8로 인코딩 된 텍스트로 인코딩하고 결과를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="0e6ec969b789b52d1c5120ea85c9ad182259f168" translate="yes" xml:space="preserve">
          <source>MarshalText implements the encoding.TextMarshaler interface.</source>
          <target state="translated">MarshalText는 encoding.TextMarshaler 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="e9f45c26a4b805caf1ff0c7f133453fe1405ea6f" translate="yes" xml:space="preserve">
          <source>MarshalText implements the encoding.TextMarshaler interface. Only the Float value is marshaled (in full precision), other attributes such as precision or accuracy are ignored.</source>
          <target state="translated">MarshalText는 encoding.TextMarshaler 인터페이스를 구현합니다. Float 값만 마샬링되고 (정밀도) 정밀도 또는 정확도와 같은 다른 속성은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="1fbe6f2d906b1d5948fbd9851ef463bba4786bcb" translate="yes" xml:space="preserve">
          <source>MarshalText implements the encoding.TextMarshaler interface. The encoding is the same as returned by String, with one exception: When len(ip) is zero, it returns an empty slice.</source>
          <target state="translated">MarshalText는 encoding.TextMarshaler 인터페이스를 구현합니다. 인코딩은 String이 반환 한 것과 동일하지만 한 가지 예외가 있습니다. len (ip)가 0이면 빈 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="83f43718a3654277944df9768c5af959f91ebe45" translate="yes" xml:space="preserve">
          <source>MarshalText implements the encoding.TextMarshaler interface. The time is formatted in RFC 3339 format, with sub-second precision added if present.</source>
          <target state="translated">MarshalText는 encoding.TextMarshaler 인터페이스를 구현합니다. 시간은 RFC 3339 형식으로 표시되며 초 단위 정밀도가 있으면 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="14fcaccd265e76bda57404dd966d33311a65ffc3" translate="yes" xml:space="preserve">
          <source>MarshalWithParams allows field parameters to be specified for the top-level element. The form of the params is the same as the field tags.</source>
          <target state="translated">MarshalWithParams를 사용하면 최상위 요소에 필드 매개 변수를 지정할 수 있습니다. 매개 변수의 형식은 필드 태그와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="34052c5ea18ea7495e24eea4a4d137cecba4872c" translate="yes" xml:space="preserve">
          <source>MarshalXML encodes the receiver as zero or more XML elements. By convention, arrays or slices are typically encoded as a sequence of elements, one per entry. Using start as the element tag is not required, but doing so will enable Unmarshal to match the XML elements to the correct struct field. One common implementation strategy is to construct a separate value with a layout corresponding to the desired XML and then to encode it using e.EncodeElement. Another common strategy is to use repeated calls to e.EncodeToken to generate the XML output one token at a time. The sequence of encoded tokens must make up zero or more valid XML elements.</source>
          <target state="translated">MarshalXML은 수신자를 0 개 이상의 XML 요소로 인코딩합니다. 일반적으로 배열 또는 슬라이스는 일반적으로 항목 당 하나씩 일련의 요소로 인코딩됩니다. element 태그로 start를 사용할 필요는 없지만 Unmarshal을 사용하면 XML 요소를 올바른 구조체 필드에 일치시킬 수 있습니다. 일반적인 구현 전략 중 하나는 원하는 XML에 해당하는 레이아웃으로 별도의 값을 구성한 다음 e.EncodeElement를 사용하여 인코딩하는 것입니다. 또 다른 일반적인 전략은 e.EncodeToken에 대한 반복 호출을 사용하여 한 번에 하나의 토큰으로 XML 출력을 생성하는 것입니다. 인코딩 된 토큰 시퀀스는 0 개 이상의 유효한 XML 요소를 구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="41210996386655a5e9f720c4f9e735ef866f35cb" translate="yes" xml:space="preserve">
          <source>MarshalXMLAttr returns an XML attribute with the encoded value of the receiver. Using name as the attribute name is not required, but doing so will enable Unmarshal to match the attribute to the correct struct field. If MarshalXMLAttr returns the zero attribute Attr{}, no attribute will be generated in the output. MarshalXMLAttr is used only for struct fields with the &quot;attr&quot; option in the field tag.</source>
          <target state="translated">MarshalXMLAttr은 수신자의 인코딩 된 값이있는 XML 속성을 리턴합니다. 속성 이름으로 name을 사용할 필요는 없지만, 그렇게하면 Unmarshal이 속성을 올바른 구조체 필드에 일치시킬 수 있습니다. MarshalXMLAttr이 0 속성 Attr {}을 리턴하면 출력에 속성이 생성되지 않습니다. MarshalXMLAttr은 필드 태그에 &quot;attr&quot;옵션이있는 구조체 필드에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="18fd048394e569d8195a81313b9e64f2eba7ee35" translate="yes" xml:space="preserve">
          <source>Marshaler is the interface implemented by objects that can marshal themselves into valid XML elements.</source>
          <target state="translated">Marshaler는 유효한 XML 요소로 마샬링 할 수있는 객체로 구현 된 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="47a2664e5f80a08312afe3946a74993c99143c6d" translate="yes" xml:space="preserve">
          <source>Marshaler is the interface implemented by types that can marshal themselves into valid JSON.</source>
          <target state="translated">Marshaler는 유효한 JSON으로 마샬링 할 수있는 유형으로 구현 된 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="4a00ca7b38dd0506417989c16c2542f21f4d7c58" translate="yes" xml:space="preserve">
          <source>MarshalerAttr is the interface implemented by objects that can marshal themselves into valid XML attributes.</source>
          <target state="translated">MarshalerAttr은 유효한 XML 속성으로 마샬링 할 수있는 객체로 구현 된 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="5c61140e5006502f101ce6ee77324538231946bb" translate="yes" xml:space="preserve">
          <source>Mask returns the result of masking the IP address ip with mask.</source>
          <target state="translated">마스크는 IP 주소 ip를 마스크로 마스킹 한 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0335207f5e840d81afa158c6c2bb6e3fa02653b4" translate="yes" xml:space="preserve">
          <source>Match</source>
          <target state="translated">Match</target>
        </trans-unit>
        <trans-unit id="b841b8491dab0dabb8feb21367e059b0624fa3bb" translate="yes" xml:space="preserve">
          <source>Match reports whether name matches the shell file name pattern. The pattern syntax is:</source>
          <target state="translated">일치는 이름이 쉘 파일 이름 패턴과 일치하는지 여부를보고합니다. 패턴 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="65238f3fd69244258d0fe7834a55d41fd9fdb4b5" translate="yes" xml:space="preserve">
          <source>Match reports whether name matches the shell pattern. The pattern syntax is:</source>
          <target state="translated">일치는 이름이 쉘 패턴과 일치하는지 여부를보고합니다. 패턴 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5f5677ee8a35a029aa3e90c1d56b65878192d3b4" translate="yes" xml:space="preserve">
          <source>Match reports whether the byte slice b contains any match of the regular expression pattern. More complicated queries need to use Compile and the full Regexp interface.</source>
          <target state="translated">Match는 바이트 슬라이스 b에 정규식 패턴이 일치하는지 여부를보고합니다. 더 복잡한 쿼리는 컴파일 및 전체 Regexp 인터페이스를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="269393d413e09f2ec5ba2e6fbdd662834a23a90b" translate="yes" xml:space="preserve">
          <source>Match reports whether the byte slice b contains any match of the regular expression re.</source>
          <target state="translated">Match는 바이트 슬라이스 b에 정규 표현식 re와 일치하는 항목이 있는지보고합니다.</target>
        </trans-unit>
        <trans-unit id="188538220b1d59de0ef20f48b5e9a854e7a08bec" translate="yes" xml:space="preserve">
          <source>Match requires pattern to match all of name, not just a substring. The only possible returned error is ErrBadPattern, when pattern is malformed.</source>
          <target state="translated">일치에는 패턴이 하위 문자열뿐만 아니라 모든 이름과 일치해야합니다. 패턴이 잘못되었을 때 반환 될 수있는 유일한 오류는 ErrBadPattern입니다.</target>
        </trans-unit>
        <trans-unit id="fb78f24b3584ab26ff8d868ae02c24bc3e7a84f8" translate="yes" xml:space="preserve">
          <source>MatchEmptyWidth reports whether the instruction matches an empty string between the runes before and after. It should only be called when i.Op == InstEmptyWidth.</source>
          <target state="translated">MatchEmptyWidth는 명령이 런 사이의 빈 문자열과 전후에 빈 문자열과 일치하는지 여부를보고합니다. i.Op == InstEmptyWidth 인 경우에만 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="766801810391656eb72b30e1a620adc09dc91643" translate="yes" xml:space="preserve">
          <source>MatchFile considers the name of the file and may use ctxt.OpenFile to read some or all of the file's content.</source>
          <target state="translated">MatchFile은 파일 이름을 고려하고 ctxt.OpenFile을 사용하여 파일 내용의 일부 또는 전부를 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32f23226c3beda09b3f84dfe037d9c9ada013d83" translate="yes" xml:space="preserve">
          <source>MatchFile reports whether the file with the given name in the given directory matches the context and would be included in a Package created by ImportDir of that directory.</source>
          <target state="translated">MatchFile은 주어진 디렉토리에 주어진 이름을 가진 파일이 컨텍스트와 일치하고 해당 디렉토리의 ImportDir에 의해 작성된 패키지에 포함되는지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="230e93d3f899e27c4d81d89f3ff53b1eca08bb37" translate="yes" xml:space="preserve">
          <source>MatchReader reports whether the text returned by the RuneReader contains any match of the regular expression pattern. More complicated queries need to use Compile and the full Regexp interface.</source>
          <target state="translated">MatchReader는 RuneReader가 반환 한 텍스트에 정규식 패턴이 일치하는지 여부를보고합니다. 더 복잡한 쿼리는 컴파일 및 전체 Regexp 인터페이스를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="25c8a8e56012833544924619010cf5721432e9ab" translate="yes" xml:space="preserve">
          <source>MatchReader reports whether the text returned by the RuneReader contains any match of the regular expression re.</source>
          <target state="translated">MatchReader는 RuneReader가 반환 한 텍스트에 정규 표현식 re와 일치하는 항목이 포함되어 있는지보고합니다.</target>
        </trans-unit>
        <trans-unit id="da28fa625630bc6b02e3ddab6dad208f72cd40bb" translate="yes" xml:space="preserve">
          <source>MatchRune reports whether the instruction matches (and consumes) r. It should only be called when i.Op == InstRune.</source>
          <target state="translated">MatchRune은 명령이 일치하는지 (소비되는지)를보고합니다. r. i.Op == InstRune 인 경우에만 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="c488501e6169e99f4e3f5cf4b601fce5b1d18d9c" translate="yes" xml:space="preserve">
          <source>MatchRunePos checks whether the instruction matches (and consumes) r. If so, MatchRunePos returns the index of the matching rune pair (or, when len(i.Rune) == 1, rune singleton). If not, MatchRunePos returns -1. MatchRunePos should only be called when i.Op == InstRune.</source>
          <target state="translated">MatchRunePos는 명령이 일치하는지 (및 소비)인지 확인합니다. r. 일치하면 MatchRunePos는 일치하는 룬 쌍의 색인을 반환합니다 (또는 len (i.Rune) == 1 인 경우 룬 싱글 톤). 그렇지 않으면 MatchRunePos는 -1을 반환합니다. MatchRunePos는 i.Op == InstRune 인 경우에만 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="c78293f6444063ae02b61b422c861a74ea5c0992" translate="yes" xml:space="preserve">
          <source>MatchString</source>
          <target state="translated">MatchString</target>
        </trans-unit>
        <trans-unit id="16440a205b6632a6f9ce394e96f4e30da62834e6" translate="yes" xml:space="preserve">
          <source>MatchString reports whether the string s contains any match of the regular expression pattern. More complicated queries need to use Compile and the full Regexp interface.</source>
          <target state="translated">MatchString은 문자열 s에 정규식 패턴과 일치하는 항목이 있는지보고합니다. 더 복잡한 쿼리는 컴파일 및 전체 Regexp 인터페이스를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="0b53f246428ae463a3e54d71ff6883543bf5e6b2" translate="yes" xml:space="preserve">
          <source>MatchString reports whether the string s contains any match of the regular expression re.</source>
          <target state="translated">MatchString은 문자열 s에 정규 표현식 re와 일치하는 항목이 있는지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="386301aac4b9205f957c7e2aded15dd3a3170a4d" translate="yes" xml:space="preserve">
          <source>Mathematical constants.</source>
          <target state="translated">수학 상수.</target>
        </trans-unit>
        <trans-unit id="e9339d8c2f10a09643bf33b4b293ddbf19fb634d" translate="yes" xml:space="preserve">
          <source>Mathematical interval notation such as [0, n) is used throughout the documentation for this package.</source>
          <target state="translated">[0, n)과 같은 수학적 간격 표기법은이 패키지의 설명서 전체에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b64028b7ef9651f5e0c9bf08d57c40c964fb143d" translate="yes" xml:space="preserve">
          <source>Max returns the larger of x or y.</source>
          <target state="translated">최대 값은 x 또는 y 중 큰 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6c955f951ae2dab8e6f5e54e3a98c7139c879b48" translate="yes" xml:space="preserve">
          <source>MaxBase is the largest number base accepted for string conversions.</source>
          <target state="translated">MaxBase는 문자열 변환에 허용되는 최대 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="d9d067026e10599a63c5386be336904174743560" translate="yes" xml:space="preserve">
          <source>MaxBytesReader is similar to io.LimitReader but is intended for limiting the size of incoming request bodies. In contrast to io.LimitReader, MaxBytesReader's result is a ReadCloser, returns a non-EOF error for a Read beyond the limit, and closes the underlying reader when its Close method is called.</source>
          <target state="translated">MaxBytesReader는 io.LimitReader와 유사하지만 들어오는 요청 본문의 크기를 제한하기위한 것입니다. io.LimitReader와 달리 MaxBytesReader의 결과는 ReadCloser이며, 한계를 초과하는 Read에 대해 EOF가 아닌 오류를 반환하며 Close 메서드가 호출 될 때 기본 판독기를 닫습니다.</target>
        </trans-unit>
        <trans-unit id="739ec125397a0373ef46f377effdf6be903c6fd8" translate="yes" xml:space="preserve">
          <source>MaxBytesReader prevents clients from accidentally or maliciously sending a large request and wasting server resources.</source>
          <target state="translated">MaxBytesReader는 클라이언트가 실수로 또는 악의적으로 큰 요청을 보내거나 서버 리소스를 낭비하지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="61be69d33fec3be907f4ea6e04af100d85f7675e" translate="yes" xml:space="preserve">
          <source>MaxCap walks the regexp to find the maximum capture index.</source>
          <target state="translated">MaxCap은 정규 표현식을 따라 최대 캡처 인덱스를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="df7b72cdcf2650790c955b9e993a0a0c2fbe25b4" translate="yes" xml:space="preserve">
          <source>MaxEncodedLen returns the maximum length of an encoding of n source bytes.</source>
          <target state="translated">MaxEncodedLen은 n 소스 바이트 인코딩의 최대 길이를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="89c65689a7af2cc891fbeafce261f8df625c4303" translate="yes" xml:space="preserve">
          <source>MaxVarintLenN is the maximum length of a varint-encoded N-bit integer.</source>
          <target state="translated">MaxVarintLenN은 varint 인코딩 된 N 비트 정수의 최대 길이입니다.</target>
        </trans-unit>
        <trans-unit id="1157d0585a10f5f650da7952c06f96ac83134419" translate="yes" xml:space="preserve">
          <source>MemProfile returns a profile of memory allocated and freed per allocation site.</source>
          <target state="translated">MemProfile은 할당 사이트 당 할당 및 해제 된 메모리 프로파일을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d8d6b923c77de71210013c81589eaf2c4fe10654" translate="yes" xml:space="preserve">
          <source>MemProfile returns n, the number of records in the current memory profile. If len(p) &amp;gt;= n, MemProfile copies the profile into p and returns n, true. If len(p) &amp;lt; n, MemProfile does not change p and returns n, false.</source>
          <target state="translated">MemProfile은 현재 메모리 프로파일의 레코드 수인 n을 리턴합니다. len (p)&amp;gt; = n 인 경우 MemProfile은 프로파일을 p에 복사하고 n, true를 리턴합니다. len (p) &amp;lt;n이면 MemProfile은 p를 변경하지 않고 n을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c013eb0f98db13dab8418c5c8a82f2ae00733c42" translate="yes" xml:space="preserve">
          <source>MemProfileRate controls the fraction of memory allocations that are recorded and reported in the memory profile. The profiler aims to sample an average of one allocation per MemProfileRate bytes allocated.</source>
          <target state="translated">MemProfileRate는 메모리 프로파일에 기록 및보고되는 메모리 할당 비율을 제어합니다. 프로파일 러는 할당 된 MemProfileRate 바이트 당 평균 하나의 할당을 샘플링하는 것을 목표로합니다.</target>
        </trans-unit>
        <trans-unit id="e7ca02f761fad2cef95bf22ec3a49a7a10d4d7ec" translate="yes" xml:space="preserve">
          <source>MemString returns r.AllocedBytesPerOp and r.AllocsPerOp in the same format as 'go test'.</source>
          <target state="translated">MemString은 'go test'와 동일한 형식으로 r.AllocedBytesPerOp 및 r.AllocsPerOp를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5885c324e2b06a6d3881d7dca39a2a9515c8b84e" translate="yes" xml:space="preserve">
          <source>MergeLine merges a line with the following line. It is akin to replacing the newline character at the end of the line with a space (to not change the remaining offsets). To obtain the line number, consult e.g. Position.Line. MergeLine will panic if given an invalid line number.</source>
          <target state="translated">MergeLine은 한 줄을 다음 줄과 병합합니다. 줄 끝의 줄 바꿈 문자를 공백으로 바꾸는 것과 비슷합니다 (나머지 오프셋을 변경하지 않기 위해). 라인 번호를 얻으려면 예를 들어 Position.Line을 참조하십시오. 유효하지 않은 라인 번호가 주어지면 MergeLine이 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="c56ee5f274246d4907a3f8792aa47b70201e2839" translate="yes" xml:space="preserve">
          <source>MergePackageFiles creates a file AST by merging the ASTs of the files belonging to a package. The mode flags control merging behavior.</source>
          <target state="translated">MergePackageFiles는 패키지에 속하는 파일의 AST를 병합하여 파일 AST를 만듭니다. 모드 플래그는 병합 동작을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="7f6f0438a1b28dd75bfa1675a817c685d6ecf309" translate="yes" xml:space="preserve">
          <source>Method represents a single method.</source>
          <target state="translated">방법은 단일 방법을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d5cc6ded0a12c1ea7e555fe80a4dd907a9326b65" translate="yes" xml:space="preserve">
          <source>Method returns a function value corresponding to v's i'th method. The arguments to a Call on the returned function should not include a receiver; the returned function will always use v as the receiver. Method panics if i is out of range or if v is a nil interface value.</source>
          <target state="translated">Method는 v의 i 번째 메소드에 해당하는 함수 값을 리턴합니다. 리턴 된 함수에서 호출에 대한 인수는 수신자를 포함하지 않아야합니다. 리턴 된 함수는 항상 v를 수신자로 사용합니다. i가 범위를 벗어 났거나 v가 nil 인터페이스 값인 경우 메소드 패닉.</target>
        </trans-unit>
        <trans-unit id="8580bc7cf729ccd2e220561b0a2aa0093af75313" translate="yes" xml:space="preserve">
          <source>Method returns the i'th method of interface t for 0 &amp;lt;= i &amp;lt; t.NumMethods(). The methods are ordered by their unique Id.</source>
          <target state="translated">메소드는 0 &amp;lt;= i &amp;lt;t.NumMethods ()에 대해 인터페이스 t의 i 번째 메소드를 리턴합니다. 방법은 고유 한 ID로 주문됩니다.</target>
        </trans-unit>
        <trans-unit id="0d5919064169d4fa2dfa670c5cd1d31fe4f5ec77" translate="yes" xml:space="preserve">
          <source>Method returns the i'th method of named type t for 0 &amp;lt;= i &amp;lt; t.NumMethods().</source>
          <target state="translated">메소드는 0 &amp;lt;= i &amp;lt;t.NumMethods ()에 대해 명명 된 유형 t의 i 번째 메소드를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7b406879ef1e276f5ac32d320c19bb15ff9ced44" translate="yes" xml:space="preserve">
          <source>MethodByName returns a function value corresponding to the method of v with the given name. The arguments to a Call on the returned function should not include a receiver; the returned function will always use v as the receiver. It returns the zero Value if no method was found.</source>
          <target state="translated">MethodByName은 주어진 이름을 가진 v의 메소드에 해당하는 함수 값을 리턴합니다. 리턴 된 함수에서 호출에 대한 인수는 수신자를 포함하지 않아야합니다. 리턴 된 함수는 항상 v를 수신자로 사용합니다. 메소드를 찾지 못하면 0 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="1995bb7d8a495c29ba7a59b0b373d66ee1f82142" translate="yes" xml:space="preserve">
          <source>MethodSet</source>
          <target state="translated">MethodSet</target>
        </trans-unit>
        <trans-unit id="c5e9a1bdc9129c6b25b91c69272ee11aa65ae4ac" translate="yes" xml:space="preserve">
          <source>Methods of this form typically return the incoming receiver as well, to enable simple call chaining.</source>
          <target state="translated">이 형식의 메소드는 일반적으로 간단한 호출 체인을 가능하게하기 위해 수신 수신자도 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="68e37169f0406f89039a63dc143d5a05fc9b5510" translate="yes" xml:space="preserve">
          <source>Methods which don't require a result value to be passed in (for instance, Int.Sign), simply return the result. In this case, the receiver is typically the first operand, named x:</source>
          <target state="translated">결과 값을 전달할 필요가없는 메소드 (예 : Int.Sign)는 단순히 결과를 리턴합니다. 이 경우 수신자는 일반적으로 x라는 첫 번째 피연산자입니다.</target>
        </trans-unit>
        <trans-unit id="594fd92ee6be7b72c6f8d9451d2a9f9e3bae51ed" translate="yes" xml:space="preserve">
          <source>Microseconds returns the duration as an integer microsecond count.</source>
          <target state="translated">마이크로 초는 지속 시간을 정수 마이크로 초 카운트로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c825c82257bdcbc1a135579145266c6ee484713a" translate="yes" xml:space="preserve">
          <source>Milliseconds returns the duration as an integer millisecond count.</source>
          <target state="translated">밀리 초는 지속 시간을 정수 밀리 초 카운트로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d4a6fe67a8f15c1c894bf05225db6c07db7dc926" translate="yes" xml:space="preserve">
          <source>Min returns the smaller of x or y.</source>
          <target state="translated">최소값은 x 또는 y 중 작은 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dacfaba796bce8b807113e726ae0618041c980f0" translate="yes" xml:space="preserve">
          <source>MinPrec returns the minimum precision required to represent x exactly (i.e., the smallest prec before x.SetPrec(prec) would start rounding x). The result is 0 for |x| == 0 and |x| == Inf.</source>
          <target state="translated">MinPrec은 x를 정확하게 나타내는 데 필요한 최소 정밀도를 반환합니다 (즉, x.SetPrec (prec)가 x를 반올림하기 전에 가장 작은 prec). | x |의 경우 결과는 0입니다 == 0 및 | x | == Inf.</target>
        </trans-unit>
        <trans-unit id="b959e8418a57efc341ef2ea80360e0eee71f265e" translate="yes" xml:space="preserve">
          <source>MinRead is the minimum slice size passed to a Read call by Buffer.ReadFrom. As long as the Buffer has at least MinRead bytes beyond what is required to hold the contents of r, ReadFrom will not grow the underlying buffer.</source>
          <target state="translated">MinRead는 Buffer.ReadFrom이 Read 호출에 전달한 최소 슬라이스 크기입니다. 버퍼에 r의 내용을 보유하는 데 필요한 것보다 최소한 MinRead 바이트가있는 한 ReadFrom은 기본 버퍼를 늘리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ba682b9edf600874d186945b125535bdb2fd2d00" translate="yes" xml:space="preserve">
          <source>Minute returns the minute offset within the hour specified by t, in the range [0, 59].</source>
          <target state="translated">분은 [0, 59] 범위에서 t로 지정된 시간 내에 분 오프셋을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f75dd7f0b206dbae82a8f8f0b7023bff54f3a266" translate="yes" xml:space="preserve">
          <source>Minutes returns the duration as a floating point number of minutes.</source>
          <target state="translated">분은 기간을 부동 소수점 수 (분)로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="eb3dbdbaa825e8d8a44607bf8d9e0b1911e69e12" translate="yes" xml:space="preserve">
          <source>MissingMethod returns (nil, false) if V implements T, otherwise it returns a missing method required by T and whether it is missing or just has the wrong type.</source>
          <target state="translated">V가 T를 구현하면 MissingMethod는 (nil, false)를 반환하고, 그렇지 않으면 T에 필요한 누락 된 메서드와 누락되었거나 잘못된 유형인지 여부를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="37de4657eb0dc5b3413cb095b60f3d8129f6593f" translate="yes" xml:space="preserve">
          <source>Mkdir creates a new directory with the specified name and permission bits (before umask). If there is an error, it will be of type *PathError.</source>
          <target state="translated">Mkdir은 지정된 이름과 권한 비트 (umask 이전)를 사용하여 새 디렉토리를 만듭니다. 오류가 있으면 * PathError 유형입니다.</target>
        </trans-unit>
        <trans-unit id="677ef1c770313b12ac646270f84a792125bb5633" translate="yes" xml:space="preserve">
          <source>MkdirAll creates a directory named path, along with any necessary parents, and returns nil, or else returns an error. The permission bits perm (before umask) are used for all directories that MkdirAll creates. If path is already a directory, MkdirAll does nothing and returns nil.</source>
          <target state="translated">MkdirAll은 필요한 부모와 함께 path라는 디렉토리를 작성하고 nil을 리턴하거나 그렇지 않으면 오류를 리턴합니다. 권한 비트 perm (umask 이전)은 MkdirAll이 작성하는 모든 디렉토리에 사용됩니다. path가 이미 디렉토리이면 MkdirAll은 아무 작업도 수행하지 않고 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f388dbfb78ec3e8821ae0844a947cecd488dd5ff" translate="yes" xml:space="preserve">
          <source>Mod</source>
          <target state="translated">Mod</target>
        </trans-unit>
        <trans-unit id="373154d6ec87032b198bd3426fdb98b629297d1b" translate="yes" xml:space="preserve">
          <source>Mod returns the floating-point remainder of x/y. The magnitude of the result is less than y and its sign agrees with that of x.</source>
          <target state="translated">Mod는 x / y의 부동 소수점 나머지를 반환합니다. 결과의 크기는 y보다 작으며 기호는 x의 기호와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="f2b25579075ef3b96af2a2e04dfbe27a4023e7c3" translate="yes" xml:space="preserve">
          <source>Mod returns the point q in r such that p.X-q.X is a multiple of r's width and p.Y-q.Y is a multiple of r's height.</source>
          <target state="translated">Mod는 pX-qX가 r의 너비의 배수이고 pY-qY가 r의 높이의 배수가되도록 r에서 점 q를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5301dec2851eeeadb9f8edd3bcc14178a7cc1eac" translate="yes" xml:space="preserve">
          <source>Mod sets z to the modulus x%y for y != 0 and returns z. If y == 0, a division-by-zero run-time panic occurs. Mod implements Euclidean modulus (unlike Go); see DivMod for more details.</source>
          <target state="translated">Mod는 y! = 0에 대해 z를 계수 x % y로 설정하고 z를 반환합니다. y == 0이면 0으로 나누기 런타임 패닉이 발생합니다. Mod는 Gocli와 달리 유클리드 모듈러스를 구현합니다. 자세한 내용은 DivMod를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6d74b87ee55add7bade81d22a2a4510010f96ac8" translate="yes" xml:space="preserve">
          <source>ModInverse sets z to the multiplicative inverse of g in the ring ℤ/nℤ and returns z. If g and n are not relatively prime, g has no multiplicative inverse in the ring ℤ/nℤ. In this case, z is unchanged and the return value is nil.</source>
          <target state="translated">ModInverse는 z를 링 ℤ / nℤ에서 g의 곱셈 역수로 설정하고 z를 반환합니다. g와 n이 상대적으로 소수가 아닌 경우, g는 고리 ℤ / nℤ에 곱하기 역수가 없습니다. 이 경우 z는 변경되지 않고 리턴 값은 nil입니다.</target>
        </trans-unit>
        <trans-unit id="7a4fd0d385cd06f73e61243a029e76aa018a4f23" translate="yes" xml:space="preserve">
          <source>ModSqrt sets z to a square root of x mod p if such a square root exists, and returns z. The modulus p must be an odd prime. If x is not a square mod p, ModSqrt leaves z unchanged and returns nil. This function panics if p is not an odd integer.</source>
          <target state="translated">ModSqrt는 제곱근이 존재하면 z를 x mod p의 제곱근으로 설정하고 z를 반환합니다. 계수 p는 홀수 소수 여야합니다. x가 제곱 mod p가 아닌 경우 ModSqrt는 z를 변경하지 않고 그대로두고 nil을 반환합니다. p가 홀수가 아닌 경우이 함수는 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="aac634faa69d653814bcee88f0a5dfc61028be1b" translate="yes" xml:space="preserve">
          <source>ModTime returns the modification time in UTC using the legacy ModifiedDate and ModifiedTime fields.</source>
          <target state="translated">ModTime은 레거시 ModifiedDate 및 ModifiedTime 필드를 사용하여 수정 시간을 UTC로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="aa00a628811be04815f4dd62095833b576cd8722" translate="yes" xml:space="preserve">
          <source>Mode returns the permission and mode bits for the FileHeader.</source>
          <target state="translated">Mode는 FileHeader에 대한 권한 및 모드 비트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="28a0f960b89726a468e14a8ebdf922a21170bc22" translate="yes" xml:space="preserve">
          <source>Mode returns the rounding mode of x.</source>
          <target state="translated">Mode는 x의 반올림 모드를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8b4ea19087de0202d8e6a728b310de2dbb997d4d" translate="yes" xml:space="preserve">
          <source>Mode values control the operation of New.</source>
          <target state="translated">모드 값은 New의 작동을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="ee5a2d9bea8822761c2af443e30dd8b140094e31" translate="yes" xml:space="preserve">
          <source>Model can convert any Color to one from its own color model. The conversion may be lossy.</source>
          <target state="translated">모델은 모든 색상을 자체 색상 모델에서 색상으로 변환 할 수 있습니다. 변환이 손실 될 수 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
