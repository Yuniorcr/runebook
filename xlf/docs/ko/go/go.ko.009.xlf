<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="go">
    <body>
      <group id="go">
        <trans-unit id="232f8c7f5eea097cc9451d2d90b51db6b069254d" translate="yes" xml:space="preserve">
          <source>The zero Map is empty and ready for use. A Map must not be copied after first use.</source>
          <target state="translated">제로 맵이 비어 있고 사용할 준비가되었습니다. 처음 사용한 후 맵을 복사해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="ba5155e1e3916eee99a712d5244dcde8e9982094" translate="yes" xml:space="preserve">
          <source>The zero Value represents no value. Its IsValid method returns false, its Kind method returns Invalid, its String method returns &quot;&amp;lt;invalid Value&amp;gt;&quot;, and all other methods panic. Most functions and methods never return an invalid value. If one does, its documentation states the conditions explicitly.</source>
          <target state="translated">0 값은 값이 없음을 나타냅니다. IsValid 메서드는 false를 반환하고 Kind 메서드는 Invalid를 반환하고 String 메서드는 &quot;&amp;lt;invalid Value&amp;gt;&quot;를 반환하며 다른 모든 메서드는 패닉 상태입니다. 대부분의 함수와 메소드는 유효하지 않은 값을 반환하지 않습니다. 그럴 경우 문서에 조건이 명시 적으로 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="384c750c13afaffcbd5ebf58e8afec2b8768e946" translate="yes" xml:space="preserve">
          <source>The zero value for Pos is NoPos; there is no file and line information associated with it, and NoPos.IsValid() is false. NoPos is always smaller than any other Pos value. The corresponding Position value for NoPos is the zero value for Position.</source>
          <target state="translated">Pos의 0 값은 NoPos입니다. 연관된 파일 및 행 정보가 없으며 NoPos.IsValid ()가 false입니다. NoPos는 항상 다른 Pos 값보다 작습니다. NoPos의 해당 위치 값은 위치의 0 값입니다.</target>
        </trans-unit>
        <trans-unit id="3f5973e68195ed6a7dd12c4c7dc485f8bde0523d" translate="yes" xml:space="preserve">
          <source>The zero value for an Int, Rat, or Float correspond to 0. Thus, new values can be declared in the usual ways and denote 0 without further initialization:</source>
          <target state="translated">Int, Rat 또는 Float의 0 값은 0에 해당합니다. 따라서 새로운 값은 일반적인 방법으로 선언 할 수 있으며 추가 초기화없이 0을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5d5aa4f538fd1571e15874ad0969ae7c0fda3040" translate="yes" xml:space="preserve">
          <source>The zero value for each field is equivalent to dialing without that option. Dialing with the zero value of Dialer is therefore equivalent to just calling the Dial function.</source>
          <target state="translated">각 필드의 0 값은 해당 옵션이없는 다이얼링과 같습니다. 따라서 다이얼러의 0 값을 사용한 다이얼링은 다이얼 기능을 호출하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="beb5a289f20083f1018df67115c647d61b968230" translate="yes" xml:space="preserve">
          <source>The zero value of type Time is January 1, year 1, 00:00:00.000000000 UTC. As this time is unlikely to come up in practice, the IsZero method gives a simple way of detecting a time that has not been initialized explicitly.</source>
          <target state="translated">Time 유형의 0 값은 1 년 1 월 1 일 00 : 00 : 00.000000000 UTC입니다. 이 시간은 실제로 나타나지 않을 것이므로 IsZero 방법은 명시 적으로 초기화되지 않은 시간을 간단하게 감지 할 수있는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4752552a303f0f1e8a6bd4b3555705dcb31c63a8" translate="yes" xml:space="preserve">
          <source>Then it can make a remote call:</source>
          <target state="translated">그런 다음 원격 전화를 걸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5d500f53dcbe43654b22f15924d609c47bcfc3c" translate="yes" xml:space="preserve">
          <source>Then use the pprof tool to look at the heap profile:</source>
          <target state="translated">그런 다음 pprof 도구를 사용하여 힙 프로파일을보십시오.</target>
        </trans-unit>
        <trans-unit id="d249cadab1a19289ed9fd8f524a7048ff9efb13f" translate="yes" xml:space="preserve">
          <source>There are 16 methods of Regexp that match a regular expression and identify the matched text. Their names are matched by this regular expression:</source>
          <target state="translated">정규식과 일치하고 일치하는 텍스트를 식별하는 16 가지 정규식 방법이 있습니다. 그들의 이름은이 정규식과 일치합니다 :</target>
        </trans-unit>
        <trans-unit id="089af1af9f031a6d4cb36f253f88e22a554b4d75" translate="yes" xml:space="preserve">
          <source>There are many commands available from the pprof command line. Commonly used commands include &quot;top&quot;, which prints a summary of the top program hot-spots, and &quot;web&quot;, which opens an interactive graph of hot-spots and their call graphs. Use &quot;help&quot; for information on all pprof commands.</source>
          <target state="translated">pprof 명령 행에서 사용 가능한 많은 명령이 있습니다. 일반적으로 사용되는 명령에는 최상위 프로그램 핫스팟 요약을 인쇄하는 &quot;top&quot;과 핫스팟의 대화식 그래프 및 해당 호출 그래프를 여는 &quot;web&quot;이 포함됩니다. 모든 pprof 명령에 대한 정보는 &quot;help&quot;를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6fa5b171535b7941feffabcf1c5f915fe3f02940" translate="yes" xml:space="preserve">
          <source>There are no build tags for beta or minor releases.</source>
          <target state="translated">베타 또는 부 릴리스에 대한 빌드 태그가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f4ebe0322e94e23eec9f295ca340080dec64dffd" translate="yes" xml:space="preserve">
          <source>There are three types of user annotations: log messages, regions, and tasks.</source>
          <target state="translated">사용자 주석에는 로그 메시지, 리전 및 작업의 세 가지 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="311b843be371a8c7fc9f6f81df2189e5f92e44e5" translate="yes" xml:space="preserve">
          <source>There is also a set of binary comparison operators defined as functions:</source>
          <target state="translated">함수로 정의 된 이진 비교 연산자 세트도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f5077a9bb275171893d0be52e74cbffe4b19888" translate="yes" xml:space="preserve">
          <source>There is also a standard HTTP interface to profiling data. Adding the following line will install handlers under the /debug/pprof/ URL to download live profiles:</source>
          <target state="translated">데이터 프로파일 링을위한 표준 HTTP 인터페이스도 있습니다. 다음 줄을 추가하면 / debug / pprof / URL 아래에 처리기가 설치되어 라이브 프로필을 다운로드합니다.</target>
        </trans-unit>
        <trans-unit id="f5962f465f0b5c003c4585058fcce10ec6a63c36" translate="yes" xml:space="preserve">
          <source>There is also a standard HTTP interface to trace data. Adding the following line will install a handler under the /debug/pprof/trace URL to download a live trace:</source>
          <target state="translated">데이터를 추적하기위한 표준 HTTP 인터페이스도 있습니다. 다음 행을 추가하면 라이브 추적을 다운로드하기 위해 / debug / pprof / trace URL 아래에 핸들러가 설치됩니다.</target>
        </trans-unit>
        <trans-unit id="669c09ef6ba443f4e07a76e5e520b09339b0d7ba" translate="yes" xml:space="preserve">
          <source>There is also a subset of the methods that can be applied to text read from a RuneReader:</source>
          <target state="translated">RuneReader에서 읽은 텍스트에 적용 할 수있는 메소드의 서브 세트도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5e187581cfc7675624afa1252d945d3159b9872" translate="yes" xml:space="preserve">
          <source>There is no mechanism for full case folding, that is, for characters that involve multiple runes in the input or output.</source>
          <target state="translated">대소 문자 접힘, 즉 입력 또는 출력에 여러 룬이 포함 된 문자에 대한 메커니즘은 없습니다.</target>
        </trans-unit>
        <trans-unit id="4e416754d4e74f38af1b48194c67cf3710f22527" translate="yes" xml:space="preserve">
          <source>These are predefined layouts for use in Time.Format and time.Parse. The reference time used in the layouts is the specific time:</source>
          <target state="translated">이들은 Time.Format 및 time.Parse에서 사용하기 위해 미리 정의 된 레이아웃입니다. 레이아웃에 사용 된 참조 시간은 특정 시간입니다.</target>
        </trans-unit>
        <trans-unit id="622b937b45492ef40cc6c554bb302fd36d24a9dd" translate="yes" xml:space="preserve">
          <source>These are the errors that can be returned in ParseError.Err.</source>
          <target state="translated">ParseError.Err에 반환 될 수있는 오류입니다.</target>
        </trans-unit>
        <trans-unit id="df2271a2f22e4450d78c23577801038a703976de" translate="yes" xml:space="preserve">
          <source>These assume decimal and the Go int type.</source>
          <target state="translated">이들은 10 진수 및 Go int 유형을 가정합니다.</target>
        </trans-unit>
        <trans-unit id="e44cf0ddaa746164e3256589314495380a8d22a3" translate="yes" xml:space="preserve">
          <source>These constants are copied from the flate package, so that code that imports &quot;compress/gzip&quot; does not also have to import &quot;compress/flate&quot;.</source>
          <target state="translated">이 상수는 flate 패키지에서 복사되므로 &quot;compress / gzip&quot;을 가져 오는 코드도 &quot;compress / flate&quot;을 가져올 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="9b53ffb7fd51347180d120a25b5986ecdfdf8a40" translate="yes" xml:space="preserve">
          <source>These constants are copied from the flate package, so that code that imports &quot;compress/zlib&quot; does not also have to import &quot;compress/flate&quot;.</source>
          <target state="translated">이러한 상수는 flate 패키지에서 복사되므로 &quot;compress / zlib&quot;를 가져 오는 코드도 &quot;compress / flate&quot;을 가져올 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="a6caaf07cd62c3bce0c1d44802c32e939959f7c6" translate="yes" xml:space="preserve">
          <source>These constants cause FlagSet.Parse to behave as described if the parse fails.</source>
          <target state="translated">이러한 상수로 인해 구문 분석이 실패하면 FlagSet.Parse가 설명 된대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="c3e135e518f3071cd6e6de5ee8eb8509897ca8e4" translate="yes" xml:space="preserve">
          <source>These constants define supported rounding modes.</source>
          <target state="translated">이 상수는 지원되는 반올림 모드를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="e9b81d06567b4f6ea4a134b77b7d8d68b11092d0" translate="yes" xml:space="preserve">
          <source>These examples demonstrate the basics of printing using a format string. Printf, Sprintf, and Fprintf all take a format string that specifies how to format the subsequent arguments. For example, %d (we call that a 'verb') says to print the corresponding argument, which must be an integer (or something containing an integer, such as a slice of ints) in decimal. The verb %v ('v' for 'value') always formats the argument in its default form, just how Print or Println would show it. The special verb %T ('T' for 'Type') prints the type of the argument rather than its value. The examples are not exhaustive; see the package comment for all the details.</source>
          <target state="translated">이 예는 형식 문자열을 사용한 인쇄 기본 사항을 보여줍니다. Printf, Sprintf 및 Fprintf는 모두 후속 인수의 형식을 지정하는 방법을 지정하는 형식 문자열을 사용합니다. 예를 들어, % d ( '동사'라고 함)는 해당 인수를 인쇄하라고 지시합니다.이 인수는 정수 (또는 정수 슬라이스와 같은 정수를 포함하는 것) 여야합니다. 동사 % v ( 'value'의 경우 'v')는 항상 Print 또는 Println이 표시하는 방식과 같이 기본 형식으로 인수를 형식화합니다. 특수 동사 % T ( 'Type'의 경우 'T')는 값이 아닌 인수의 유형을 인쇄합니다. 예제는 완전하지 않습니다. 자세한 내용은 패키지 주석을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1b31c3c54ac0eb3ff04d00595a12fb566e8fcf7e" translate="yes" xml:space="preserve">
          <source>These flags define which text to prefix to each log entry generated by the Logger. Bits are or'ed together to control what's printed. There is no control over the order they appear (the order listed here) or the format they present (as described in the comments). The prefix is followed by a colon only when Llongfile or Lshortfile is specified. For example, flags Ldate | Ltime (or LstdFlags) produce,</source>
          <target state="translated">이 플래그는 로거에 의해 생성 된 각 로그 항목 앞에 붙일 텍스트를 정의합니다. 비트는 인쇄되는 것을 제어하기 위해 함께 또는 결합됩니다. 표시되는 순서 (여기에 나열된 순서) 또는 표시되는 형식 (주석에 설명 된대로)은 제어 할 수 없습니다. 접 두부 뒤에는 Llongfile 또는 Lshortfile이 지정된 경우에만 콜론이옵니다. 예를 들어, 플래그 Ldate | Ltime (또는 LstdFlags)은</target>
        </trans-unit>
        <trans-unit id="eab8374633319fa49ea516b7b757172cc6a3ee35" translate="yes" xml:space="preserve">
          <source>These flags define which text to prefix to each log entry generated by the Logger. Bits are or'ed together to control what's printed. With the exception of the Lmsgprefix flag, there is no control over the order they appear (the order listed here) or the format they present (as described in the comments). The prefix is followed by a colon only when Llongfile or Lshortfile is specified. For example, flags Ldate | Ltime (or LstdFlags) produce,</source>
          <target state="translated">이러한 플래그는 Logger가 생성 한 각 로그 항목에 접두사로 지정할 텍스트를 정의합니다. 인쇄되는 내용을 제어하기 위해 비트가 함께 또는 결합됩니다. Lmsgprefix 플래그를 제외하고 표시되는 순서 (여기에 나열된 순서) 또는 표시되는 형식 (주석에 설명 된대로)에 대한 제어가 없습니다. 접두사 뒤에는 Llongfile 또는 Lshortfile이 지정된 경우에만 콜론이옵니다. 예를 들어, 플래그 Ldate | Ltime (또는 LstdFlags)은</target>
        </trans-unit>
        <trans-unit id="fc9914d5780e96c178ba8969a057705144577da8" translate="yes" xml:space="preserve">
          <source>These functions are also compatible with the &amp;ldquo;Ed25519&amp;rdquo; function defined in RFC 8032. However, unlike RFC 8032's formulation, this package's private key representation includes a public key suffix to make multiple signing operations with the same key more efficient. This package refers to the RFC 8032 private key as the &amp;ldquo;seed&amp;rdquo;.</source>
          <target state="translated">이러한 기능은 RFC 8032에 정의 된 &quot;Ed25519&quot;기능과도 호환됩니다. 그러나 RFC 8032의 공식과 달리이 패키지의 개인 키 표현에는 공개 키 접미사가 포함되어있어 동일한 키로 여러 서명 작업을보다 효율적으로 수행 할 수 있습니다. 이 패키지는 RFC 8032 개인 키를 &quot;시드&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="2034a99a91b57c3247261a1a8004621e6e0c4e1f" translate="yes" xml:space="preserve">
          <source>These functions require great care to be used correctly. Except for special, low-level applications, synchronization is better done with channels or the facilities of the sync package. Share memory by communicating; don't communicate by sharing memory.</source>
          <target state="translated">이러한 기능을 올바르게 사용하려면 세심한주의가 필요합니다. 특수한 저수준 응용 프로그램을 제외하고 동기화 패키지의 채널 또는 기능을 사용하여 동기화하는 것이 좋습니다. 통신하여 메모리를 공유하십시오. 메모리를 공유하여 통신하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="54aa9a67852a83f3350017dd1b9500c555360772" translate="yes" xml:space="preserve">
          <source>These packages are part of the Go Project but outside the main Go tree. They are developed under looser &lt;a href=&quot;https://golang.org/doc/go1compat&quot;&gt;compatibility requirements&lt;/a&gt; than the Go core. Install them with &quot;&lt;a href=&quot;https://golang.org/cmd/go/#hdr-Download_and_install_packages_and_dependencies&quot;&gt;go get&lt;/a&gt;&quot;.</source>
          <target state="translated">이 패키지는 Go 프로젝트의 일부이지만 기본 Go 트리 외부에 있습니다. Go 코어 보다 &lt;a href=&quot;https://golang.org/doc/go1compat&quot;&gt;호환성 요구 사항&lt;/a&gt; 이 더 낮은 환경에서 개발되었습니다 . &quot; &lt;a href=&quot;https://golang.org/cmd/go/#hdr-Download_and_install_packages_and_dependencies&quot;&gt;go get&lt;/a&gt; &quot;으로 설치하십시오 .</target>
        </trans-unit>
        <trans-unit id="07168c583c59c9cae9d4bb3facc94a52fb2a21e9" translate="yes" xml:space="preserve">
          <source>These predefined profiles maintain themselves and panic on an explicit Add or Remove method call.</source>
          <target state="translated">이러한 사전 정의 된 프로파일은 명시 적 Add 또는 Remove 메소드 호출에서 자체적으로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="8dc4875980e26530686b9e8a46a4183aeaf7943d" translate="yes" xml:space="preserve">
          <source>These services can help you find Open Source packages provided by the community.</source>
          <target state="translated">이러한 서비스를 통해 커뮤니티에서 제공하는 오픈 소스 패키지를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ba17173fd7e73d9151d0d7cdef890f5dd3a0a3f" translate="yes" xml:space="preserve">
          <source>These three formatting routines call the Qualifier for each package-level object O, and if the Qualifier returns a non-empty string p, the object is printed in the form p.O. If it returns an empty string, only the object name O is printed.</source>
          <target state="translated">이 세 가지 형식 지정 루틴은 각 패키지 수준 개체 O에 대해 한정자를 호출하고 한정자가 비어 있지 않은 문자열 p를 반환하면 개체는 pO 형식으로 인쇄됩니다. 빈 문자열을 반환하면 개체 이름 O 만 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="2207cae6c61d669eed106af825a6dce66aef87d1" translate="yes" xml:space="preserve">
          <source>These variables have type *RangeTable.</source>
          <target state="translated">이 변수에는 * RangeTable 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="610a8603a5a8aeac74a533f57b0c5eb7122b7d43" translate="yes" xml:space="preserve">
          <source>This cannot be done concurrent to other receives from the Timer's channel or other calls to the Timer's Stop method.</source>
          <target state="translated">이것은 Timer의 채널로부터의 다른 수신이나 Timer의 Stop 메서드에 대한 다른 호출과 동시에 수행 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1166cbd43d7ca0f544abde3cc256ae8afc9cd0b1" translate="yes" xml:space="preserve">
          <source>This cannot be done concurrent to other receives from the Timer's channel.</source>
          <target state="translated">이것은 타이머 채널에서 다른 수신과 동시에 수행 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b00ff4b1fd4c120a5db60ce99d175dd291630987" translate="yes" xml:space="preserve">
          <source>This declares an integer flag, -flagname, stored in the pointer ip, with type *int.</source>
          <target state="translated">이것은 * int 유형으로 포인터 ip에 저장된 정수 플래그 -flagname을 선언합니다.</target>
        </trans-unit>
        <trans-unit id="f1681bf43fc257c44b551cfb0077dc2be75b4283" translate="yes" xml:space="preserve">
          <source>This declares an integer flag, -n, stored in the pointer nFlag, with type *int:</source>
          <target state="translated">이것은 * int 유형으로 포인터 nFlag에 저장된 정수 플래그, -n을 선언합니다.</target>
        </trans-unit>
        <trans-unit id="631f1841cf17bb7db8a22b0767e5099ebe5b8b09" translate="yes" xml:space="preserve">
          <source>This defines two templates, T1 and T2, and a third T3 that invokes the other two when it is executed. Finally it invokes T3. If executed this template will produce the text</source>
          <target state="translated">이것은 T1과 T2의 두 템플릿과 다른 두 템플릿이 실행될 때 호출하는 세 번째 T3을 정의합니다. 마지막으로 T3을 호출합니다. 이 템플릿을 실행하면 텍스트가 생성됩니다</target>
        </trans-unit>
        <trans-unit id="07be652fe77b2bc1e633b76695cc662deba999dd" translate="yes" xml:space="preserve">
          <source>This example creates a PriorityQueue with some items, adds and manipulates an item, and then removes the items in priority order.</source>
          <target state="translated">이 예에서는 일부 항목으로 PriorityQueue를 작성하고 항목을 추가 및 조작 한 다음 우선 순위에 따라 항목을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="11e8e47e8373159f24438e9584e5f85d6b5441f2" translate="yes" xml:space="preserve">
          <source>This example demonstrates a custom function to process template text. It installs the strings.Title function and uses it to Make Title Text Look Good In Our Template's Output.</source>
          <target state="translated">이 예제는 템플릿 텍스트를 처리하는 사용자 정의 함수를 보여줍니다. 제목 기능을 설치하고 템플릿의 출력에서 ​​제목 텍스트를보기 좋게 만드는 데 사용합니다.</target>
        </trans-unit>
        <trans-unit id="dfa54d108334a66ba7ab5757d71b4364db5ae271" translate="yes" xml:space="preserve">
          <source>This example demonstrates how a value can be passed to the context and also how to retrieve it if it exists.</source>
          <target state="translated">이 예제는 값을 컨텍스트에 전달하는 방법과 값이있는 경우이를 검색하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="cbed8edb3aa3c802bdc2c523c3a0a851457324e3" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to inspect the AST of a Go program.</source>
          <target state="translated">이 예는 Go 프로그램의 AST를 검사하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="165d3019bf668cef6d1995c8165503ac097763bd" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to use big.Int to compute the smallest Fibonacci number with 100 decimal digits and to test whether it is prime.</source>
          <target state="translated">이 예는 big.Int를 사용하여 10 진수 100으로 가장 작은 피보나치 수를 계산하고 소수인지 테스트하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="0059484fefd6cd0e894a9be3837a0c3c538eda17" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to use big.Rat to compute the first 15 terms in the sequence of rational convergents for the constant e (base of natural logarithm).</source>
          <target state="translated">이 예는 big.Rat을 사용하여 상수 e (자연 로그의 밑수)에 대한 합리적인 수렴 시퀀스에서 처음 15 개의 항을 계산하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b29080504869eb07c938bd169b02dbf661e6a627" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to use one group of driver templates with distinct sets of helper templates.</source>
          <target state="translated">이 예는 고유 한 도우미 템플릿 집합과 함께 하나의 드라이버 템플릿 그룹을 사용하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="ba0650f40679135f634bca363681740adeafe34a" translate="yes" xml:space="preserve">
          <source>This example demonstrates one way to share some templates and use them in different contexts. In this variant we add multiple driver templates by hand to an existing bundle of templates.</source>
          <target state="translated">이 예제는 일부 템플릿을 공유하고 다른 컨텍스트에서 사용하는 한 가지 방법을 보여줍니다. 이 변형에서는 기존 템플릿 번들에 여러 드라이버 템플릿을 직접 추가합니다.</target>
        </trans-unit>
        <trans-unit id="0ba078883e861f3b147ecf053f6c06d8a3174cd3" translate="yes" xml:space="preserve">
          <source>This example demonstrates searching a list sorted in ascending order.</source>
          <target state="translated">이 예는 오름차순으로 정렬 된 목록을 검색하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="7888c65ff5bdcbe2c823d7d7283ee2975bf6366b" translate="yes" xml:space="preserve">
          <source>This example demonstrates searching a list sorted in descending order. The approach is the same as searching a list in ascending order, but with the condition inverted.</source>
          <target state="translated">이 예는 내림차순으로 정렬 된 목록을 검색하는 방법을 보여줍니다. 이 방법은 목록을 오름차순으로 검색하는 것과 동일하지만 조건이 반전 된 상태입니다.</target>
        </trans-unit>
        <trans-unit id="2db6a343e7f8129baf91fac5d3ebedf3e8666279" translate="yes" xml:space="preserve">
          <source>This example demonstrates the use of a cancelable context to prevent a goroutine leak. By the end of the example function, the goroutine started by gen will return without leaking.</source>
          <target state="translated">이 예는 고 루틴 누출을 방지하기 위해 취소 가능한 컨텍스트를 사용하는 방법을 보여줍니다. 예제 함수의 끝에서 gen에 의해 시작된 goroutine은 누출없이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="f5ede30ffc3c68340a6fb2445f68975fd1d677b3" translate="yes" xml:space="preserve">
          <source>This example demonstrates unmarshaling an XML excerpt into a value with some preset fields. Note that the Phone field isn't modified and that the XML &amp;lt;Company&amp;gt; element is ignored. Also, the Groups field is assigned considering the element path provided in its tag.</source>
          <target state="translated">이 예제는 미리 설정된 일부 필드를 사용하여 XML 발췌를 마샬링 해제하는 방법을 보여줍니다. 전화 필드는 수정되지 않으며 XML &amp;lt;Company&amp;gt; 요소는 무시됩니다. 또한 그룹 필드는 태그에 제공된 요소 경로를 고려하여 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="363362d5c2e9f91c6b9857ffd69fe714bafa9ced" translate="yes" xml:space="preserve">
          <source>This example fetches several URLs concurrently, using a WaitGroup to block until all the fetches are complete.</source>
          <target state="translated">이 예에서는 모든 가져 오기가 완료 될 때까지 대기 그룹을 사용하여 여러 URL을 동시에 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="06701ebad78061b44ebf3ff359db4a889929ed4c" translate="yes" xml:space="preserve">
          <source>This example illustrates how to remove a variable declaration in a Go program while maintaining correct comment association using an ast.CommentMap.</source>
          <target state="translated">이 예제는 ast.CommentMap을 사용하여 올바른 주석 연관을 유지하면서 Go 프로그램에서 변수 선언을 제거하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="5b8dbce47ef4472e55b03e0ab77f57e1bbd03498" translate="yes" xml:space="preserve">
          <source>This example illustrates how to use NewFromFiles to compute package documentation with examples.</source>
          <target state="translated">이 예제는 NewFromFiles를 사용하여 예제가있는 패키지 문서를 계산하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="a88fa5b5d7ed0c65b753c3fe2d8b6cdc87e0d250" translate="yes" xml:space="preserve">
          <source>This example inserts several ints into an IntHeap, checks the minimum, and removes them in order of priority.</source>
          <target state="translated">이 예제는 IntHeap에 여러 개의 int를 삽입하고 최소값을 확인한 후 우선 순위에 따라 제거합니다.</target>
        </trans-unit>
        <trans-unit id="e36be68d73234a9e2fb853054688b98fefd0444d" translate="yes" xml:space="preserve">
          <source>This example passes a context with a timeout to tell a blocking function that it should abandon its work after the timeout elapses.</source>
          <target state="translated">이 예는 시간 초과가 발생한 후 작업을 포기해야한다는 차단 기능을 알리기 위해 시간 초과가있는 컨텍스트를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="eac2b4a123d3756695f2f19424362998d49962a1" translate="yes" xml:space="preserve">
          <source>This example passes a context with an arbitrary deadline to tell a blocking function that it should abandon its work as soon as it gets to it.</source>
          <target state="translated">이 예제는 임의의 최종 기한이있는 컨텍스트를 전달하여 차단 기능에 도달하자마자 작업을 포기해야한다는 것을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="df7ace59807aa52b6b44602449d158b9635a420e" translate="yes" xml:space="preserve">
          <source>This example reads 10 cryptographically secure pseudorandom numbers from rand.Reader and writes them to a byte slice.</source>
          <target state="translated">이 예제는 rand.Reader에서 암호로 안전한 10 개의 의사 난수를 읽고 바이트 슬라이스에 씁니다.</target>
        </trans-unit>
        <trans-unit id="d0f63cae6959df0e63ff45ed07152e8d354e9432" translate="yes" xml:space="preserve">
          <source>This example shows how csv.Reader can be configured to handle other types of CSV files.</source>
          <target state="translated">이 예는 다른 유형의 CSV 파일을 처리하도록 csv.Reader를 구성하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="1cca172f7759e3ba0050255d1746af87f660b76a" translate="yes" xml:space="preserve">
          <source>This example shows how to encode an interface value. The key distinction from regular types is to register the concrete type that implements the interface.</source>
          <target state="translated">이 예제는 인터페이스 값을 인코딩하는 방법을 보여줍니다. 일반 유형과의 주요 차이점은 인터페이스를 구현하는 구체적 유형을 등록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a3357a230dfc48b693b3b94d9c6611698fcf1171" translate="yes" xml:space="preserve">
          <source>This example shows how to use big.Float to compute the square root of 2 with a precision of 200 bits, and how to print the result as a decimal number.</source>
          <target state="translated">이 예제는 big.Float를 사용하여 정밀도 200 비트로 2의 제곱근을 계산하는 방법과 결과를 10 진수로 인쇄하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="efe429413e771069e2a76db974f921ef42dbdd60" translate="yes" xml:space="preserve">
          <source>This example shows the basic usage of the package: Create an encoder, transmit some values, receive them with a decoder.</source>
          <target state="translated">이 예제는 패키지의 기본 사용법을 보여줍니다. 인코더를 생성하고, 일부 값을 전송하고, 디코더로이를 수신합니다.</target>
        </trans-unit>
        <trans-unit id="4e20892924831ca17c2f745e5365e20b64d74b0e" translate="yes" xml:space="preserve">
          <source>This example shows the use of each of the methods on a *Rand. The use of the global functions is the same, without the receiver.</source>
          <target state="translated">이 예는 * Rand에서 각 메소드의 사용을 보여줍니다. 전역 기능의 사용은 수신자없이 동일합니다.</target>
        </trans-unit>
        <trans-unit id="9dae51dea551843f94a869c5f0aec8bf68e765cc" translate="yes" xml:space="preserve">
          <source>This example shows what an AST looks like when printed for debugging.</source>
          <target state="translated">이 예는 디버깅을 위해 인쇄 할 때 AST의 모습을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="3d4d87b6b74c64cd8a077a3429d1b650786c492b" translate="yes" xml:space="preserve">
          <source>This example transmits a value that implements the custom encoding and decoding methods.</source>
          <target state="translated">이 예제는 사용자 정의 인코딩 및 디코딩 방법을 구현하는 값을 전송합니다.</target>
        </trans-unit>
        <trans-unit id="5ad4aea6278dc849132cadb70003c4716078bb1f" translate="yes" xml:space="preserve">
          <source>This example uses RawMessage to delay parsing part of a JSON message.</source>
          <target state="translated">이 예제는 RawMessage를 사용하여 JSON 메시지의 구문 분석 부분을 지연시킵니다.</target>
        </trans-unit>
        <trans-unit id="f3c7cd2790bc702e1c4e8248c880538aa9480232" translate="yes" xml:space="preserve">
          <source>This example uses RawMessage to use a precomputed JSON during marshal.</source>
          <target state="translated">이 예제는 RawMessage를 사용하여 마샬링 중에 사전 계산 된 JSON을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0980067335654187fe3f7c133925d1affa51d747" translate="yes" xml:space="preserve">
          <source>This example uses a Decoder to decode a stream of distinct JSON values.</source>
          <target state="translated">이 예제는 디코더를 사용하여 고유 한 JSON 값의 스트림을 디코딩합니다.</target>
        </trans-unit>
        <trans-unit id="03fbac2b83cd3991555ff62920bdc91549cc27eb" translate="yes" xml:space="preserve">
          <source>This example uses a Decoder to decode a streaming array of JSON objects.</source>
          <target state="translated">이 예제는 디코더를 사용하여 JSON 객체의 스트리밍 배열을 디코딩합니다.</target>
        </trans-unit>
        <trans-unit id="f5365f6fa06883e90b95f7b5b17bc92e07aa1a04" translate="yes" xml:space="preserve">
          <source>This function is deterministic. Thus, if the set of possible messages is small, an attacker may be able to build a map from messages to signatures and identify the signed messages. As ever, signatures provide authenticity, not confidentiality.</source>
          <target state="translated">이 기능은 결정적입니다. 따라서 가능한 메시지 집합이 작 으면 공격자가 메시지에서 서명으로 맵을 작성하고 서명 된 메시지를 식별 할 수 있습니다. 그 어느 때보 다 서명은 기밀이 아닌 진정성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2d0f1a75b2c9ccfa817de559e09c94b8dbca3151" translate="yes" xml:space="preserve">
          <source>This function will call x509.ParseCertificate unless c.Leaf is set, which can incur a significant performance cost.</source>
          <target state="translated">이 함수는 c.Leaf가 설정되어 있지 않으면 x509.ParseCertificate를 호출하여 상당한 성능 비용이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21dc4eae53c9012a7d2a049dd7f00db6a6938f5b" translate="yes" xml:space="preserve">
          <source>This function's execution time does not depend on the inputs.</source>
          <target state="translated">이 기능의 실행 시간은 입력에 의존하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="87202fef0c6c5ae187b02620dfd26b630d0392d4" translate="yes" xml:space="preserve">
          <source>This functionality should only be used with legacy web sites. RFC 2396 warns that interpreting Userinfo this way &amp;ldquo;is NOT RECOMMENDED, because the passing of authentication information in clear text (such as URI) has proven to be a security risk in almost every case where it has been used.&amp;rdquo;</source>
          <target state="translated">이 기능은 레거시 웹 사이트에서만 사용해야합니다. RFC 2396은 Userinfo를 이런 방식으로 해석하는 것은 &quot;권장되지 않습니다. 일반 텍스트 (예 : URI)로 인증 정보를 전달하는 것은 거의 모든 경우에 보안 위험으로 판명 되었기 때문입니다.&quot;</target>
        </trans-unit>
        <trans-unit id="898688304c78e7f2468d53e47407efc6f38af32f" translate="yes" xml:space="preserve">
          <source>This implementation derives the nonce from an AES-CTR CSPRNG keyed by ChopMD(256, SHA2-512(priv.D || entropy || hash)). The CSPRNG key is IRO by a result of Coron; the AES-CTR stream is IRO under standard assumptions.</source>
          <target state="translated">이 구현은 ChopMD (256, SHA2-512 (priv.D || entropy || hash))가 입력 한 AES-CTR CSPRNG에서 nonce를 파생합니다. CSPRNG 키는 Coron의 결과로 IRO입니다. AES-CTR 스트림은 표준 가정 하에서 IRO입니다.</target>
        </trans-unit>
        <trans-unit id="689c9dd99bb5162e68a9aedd41062dfeb2de0804" translate="yes" xml:space="preserve">
          <source>This implementation derives the nonce from an AES-CTR CSPRNG keyed by:</source>
          <target state="translated">이 구현은 다음에 의해 입력 된 AES-CTR CSPRNG에서 임시 값을 파생합니다.</target>
        </trans-unit>
        <trans-unit id="d67c9b0649198706841943ee7eba2049c49bcdb3" translate="yes" xml:space="preserve">
          <source>This is handled as if &quot;my:data-href&quot; was just &quot;data-href&quot; and not &quot;href&quot; as it would be if the &quot;data-&quot; prefix were to be ignored too. Thus at parse time this becomes just</source>
          <target state="translated">&quot;my : data-href&quot;가 &quot;data-&quot;접두어도 무시되는 경우처럼 &quot;href&quot;가 아니라 &quot;data-href&quot;인 것처럼 처리됩니다. 따라서 구문 분석 시간에 이것은</target>
        </trans-unit>
        <trans-unit id="d2d5c7329f986ca3d31bfdba2057014f5f44ad7d" translate="yes" xml:space="preserve">
          <source>This is only needed to install the handler in a non-standard location.</source>
          <target state="translated">비표준 위치에 핸들러를 설치하는 경우에만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="4726b7b6e93eb25607ca12b6c92e41d048948273" translate="yes" xml:space="preserve">
          <source>This is unnecessary as the next call to WriteHeader or Close will implicitly flush out the file's padding.</source>
          <target state="translated">WriteHeader 또는 Close에 대한 다음 호출이 내재적으로 파일의 패딩을 플러시하므로 이는 불필요합니다.</target>
        </trans-unit>
        <trans-unit id="8eba79d25cd0ac07c169a84af16002b1daff283c" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;EC PRIVATE KEY&quot;.</source>
          <target state="translated">이러한 종류의 키는 일반적으로 &quot;EC PRIVATE KEY&quot;유형의 PEM 블록으로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="eb1b3ed68f800415903edd6e38e6c00b58c4b66a" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;EC PRIVATE KEY&quot;. For a more flexible key format which is not EC specific, use MarshalPKCS8PrivateKey.</source>
          <target state="translated">이러한 종류의 키는 일반적으로 &quot;EC PRIVATE KEY&quot;유형의 PEM 블록으로 인코딩됩니다. EC 고유가 아닌보다 유연한 키 형식을 사용하려면 MarshalPKCS8PrivateKey를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="56bef0ed59f36389d7550a0e4c48802187b81f7d" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;EC PUBLIC KEY&quot;.</source>
          <target state="translated">이러한 종류의 키는 일반적으로 &quot;EC PUBLIC KEY&quot;유형의 PEM 블록으로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="dfe352de6a0131091f458f18e937a358eab3152e" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;PRIVATE KEY&quot;.</source>
          <target state="translated">이러한 종류의 키는 일반적으로 &quot;PRIVATE KEY&quot;유형의 PEM 블록으로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="42db7a056c64d4d64e474ea59fd1650377d9bc54" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;PUBLIC KEY&quot;.</source>
          <target state="translated">이러한 종류의 키는 일반적으로 &quot;PUBLIC KEY&quot;유형의 PEM 블록으로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="64ab07dfb34f7d2feff364506aca7067a4453b39" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;RSA PRIVATE KEY&quot;.</source>
          <target state="translated">이러한 종류의 키는 일반적으로 &quot;RSA PRIVATE KEY&quot;유형의 PEM 블록으로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="98a803d28f3224bf7891d32a0db324db326e4afd" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;RSA PRIVATE KEY&quot;. For a more flexible key format which is not RSA specific, use MarshalPKCS8PrivateKey.</source>
          <target state="translated">이러한 종류의 키는 일반적으로 &quot;RSA PRIVATE KEY&quot;유형의 PEM 블록으로 인코딩됩니다. RSA가 아닌보다 유연한 키 형식을 사용하려면 MarshalPKCS8PrivateKey를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5d8222cc13301829f5dbdc649eec16abab7d33d6" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;RSA PUBLIC KEY&quot;.</source>
          <target state="translated">이러한 종류의 키는 일반적으로 &quot;RSA PUBLIC KEY&quot;유형의 PEM 블록으로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="67c7b63689264a63777784c1588c7be8f2ebeb83" translate="yes" xml:space="preserve">
          <source>This means that, by default, command line programs will behave like typical Unix command line programs, while other programs will not crash with SIGPIPE when writing to a closed network connection.</source>
          <target state="translated">즉, 기본적으로 명령 줄 프로그램은 일반적인 Unix 명령 줄 프로그램처럼 작동하지만 다른 프로그램은 닫힌 네트워크 연결에 쓸 때 SIGPIPE와 충돌하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="53c41745078961e0cbeedf1ad29b01ea99fe7434" translate="yes" xml:space="preserve">
          <source>This mechanism can be used to cancel long operations on the server if the client has disconnected before the response is ready.</source>
          <target state="translated">응답이 준비되기 전에 클라이언트 연결이 끊어진 경우이 메커니즘을 사용하여 서버에서 긴 작업을 취소 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3191056acdbdc6fd1ca936f76914f75eb4f8098" translate="yes" xml:space="preserve">
          <source>This mechanism is intended only for trailers that are not known prior to the headers being written. If the set of trailers is fixed or known before the header is written, the normal Go trailers mechanism is preferred:</source>
          <target state="translated">이 메커니즘은 헤더를 작성하기 전에 알려지지 않은 예고편에만 사용됩니다. 예고편 세트가 고정되거나 헤더가 작성되기 전에 알려진 경우 일반적인 Go 예고편 메커니즘이 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="34dfd520d192c4e8193a79a528c0369751354149" translate="yes" xml:space="preserve">
          <source>This method consults the following fields of the response r:</source>
          <target state="translated">이 방법은 응답 r의 다음 필드를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="6857cb2d00e6efa4c19dc849fe5f85bb657fb149" translate="yes" xml:space="preserve">
          <source>This method implements crypto.Signer, which is an interface to support keys where the private part is kept in, for example, a hardware module. Common uses should use the Sign function in this package directly.</source>
          <target state="translated">이 방법은 crypto.Signer를 구현하는데, 이는 개인 부품이 보관되는 키 (예 : 하드웨어 모듈)를 지원하는 인터페이스입니다. 일반적인 용도는이 패키지의 Sign 기능을 직접 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="dca73678d958fc56a6644aad153e6b5ae346adb8" translate="yes" xml:space="preserve">
          <source>This method implements crypto.Signer, which is an interface to support keys where the private part is kept in, for example, a hardware module. Common uses should use the Sign* functions in this package directly.</source>
          <target state="translated">이 방법은 crypto.Signer를 구현하는데, 이는 개인 부품이 보관되는 키 (예 : 하드웨어 모듈)를 지원하는 인터페이스입니다. 일반적인 용도는이 패키지의 Sign * 기능을 직접 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="6162e9fff452fe7b81839fc43d5a9b956682d1db" translate="yes" xml:space="preserve">
          <source>This package assumes that template authors are trusted, that Execute's data parameter is not, and seeks to preserve the properties below in the face of untrusted data:</source>
          <target state="translated">이 패키지는 템플릿 작성자가 신뢰할 수 있고 Execute의 data 매개 변수가 신뢰할 수 없다고 가정하고 신뢰할 수없는 데이터에 직면하여 아래 속성을 유지하려고합니다.</target>
        </trans-unit>
        <trans-unit id="646741784bedcfbc50f393efbc21b4c2b803f33a" translate="yes" xml:space="preserve">
          <source>This package does not guarantee bit-identical results across architectures.</source>
          <target state="translated">이 패키지는 여러 아키텍처에서 동일한 결과를 보장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="25b183f3fa47240bd162a6084ce81041d00db47f" translate="yes" xml:space="preserve">
          <source>This package does not support disk spanning.</source>
          <target state="translated">이 패키지는 디스크 스패닝을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="917226455af3a3e84812552f61aaf5f000d19a66" translate="yes" xml:space="preserve">
          <source>This package favors simplicity over efficiency. Clients that require high-performance serialization, especially for large data structures, should look at more advanced solutions such as the encoding/gob package or protocol buffers.</source>
          <target state="translated">이 패키지는 효율성보다 단순성을 선호합니다. 특히 대규모 데이터 구조의 경우 고성능 직렬화가 필요한 클라이언트는 인코딩 / gob 패키지 또는 프로토콜 버퍼와 같은 고급 솔루션을 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="91400ec0be490a039f54a2e8ea4991f07061b72f" translate="yes" xml:space="preserve">
          <source>This package is EXPERIMENTAL. Its current scope is only to allow tests to run, but not yet to provide a comprehensive API for users. It is exempt from the Go compatibility promise.</source>
          <target state="translated">이 패키지는 실험적입니다. 현재 범위는 테스트 실행만을 허용하지만 아직 사용자에게 포괄적 인 API를 제공하지는 않습니다. Go 호환성 약속에서 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="f172ad46509f2996426e887fe6f7f5b737ccb0ba" translate="yes" xml:space="preserve">
          <source>This package is not implemented on NaCl (Native Client).</source>
          <target state="translated">이 패키지는 NaCl (Native Client)에서 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="70b7c3d76332df2a567dd4571a1dd43d36bb3d95" translate="yes" xml:space="preserve">
          <source>This package is not implemented on Plan 9.</source>
          <target state="translated">이 패키지는 플랜 9에서 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="089323f3519ab53b437d7cbe9878efc86f18d94a" translate="yes" xml:space="preserve">
          <source>This package is not implemented on Windows. As the syslog package is frozen, Windows users are encouraged to use a package outside of the standard library. For background, see &lt;a href=&quot;https://golang.org/issue/1108&quot;&gt;https://golang.org/issue/1108&lt;/a&gt;.</source>
          <target state="translated">이 패키지는 Windows에서 구현되지 않습니다. syslog 패키지가 고정되면 Windows 사용자는 표준 라이브러리 외부에서 패키지를 사용하는 것이 좋습니다. 배경은 &lt;a href=&quot;https://golang.org/issue/1108&quot;&gt;https://golang.org/issue/1108을&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="4c28db944fb8406ea70640148283b4f2b07cfe75" translate="yes" xml:space="preserve">
          <source>This package understands HTML, CSS, JavaScript, and URIs. It adds sanitizing functions to each simple action pipeline, so given the excerpt</source>
          <target state="translated">이 패키지는 HTML, CSS, JavaScript 및 URI를 이해합니다. 각 간단한 액션 파이프 라인에 살균 기능을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="63f9c654258649e0fec61304d0149ff6b7e1fac2" translate="yes" xml:space="preserve">
          <source>This package wraps package text/template so you can share its template API to parse and execute HTML templates safely.</source>
          <target state="translated">이 패키지는 패키지 텍스트 / 템플릿을 래핑하여 템플릿 API를 공유하여 HTML 템플릿을 안전하게 구문 분석하고 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="12b81feb5020b97e164b3bd1ab6605720164a33f" translate="yes" xml:space="preserve">
          <source>This palette was used in the Plan 9 Operating System, described at &lt;a href=&quot;https://9p.io/magic/man2html/6/color&quot;&gt;https://9p.io/magic/man2html/6/color&lt;/a&gt;</source>
          <target state="translated">이 팔레트는 &lt;a href=&quot;https://9p.io/magic/man2html/6/color&quot;&gt;https://9p.io/magic/man2html/6/color에&lt;/a&gt; 설명 된 Plan 9 운영 체제에서 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="53f264e60d97dda7c8e598fd892c840f64c77bcb" translate="yes" xml:space="preserve">
          <source>This returns a Writer to which the file contents should be written. The file's contents must be written to the io.Writer before the next call to Create, CreateHeader, or Close.</source>
          <target state="translated">파일 내용을 기록해야 할 라이터를 반환합니다. 다음에 Create, CreateHeader 또는 Close를 호출하기 전에 파일 내용을 io.Writer에 기록해야합니다.</target>
        </trans-unit>
        <trans-unit id="3636f2d8cb7dce3b52ad380d63ea631656bb70da" translate="yes" xml:space="preserve">
          <source>This runtime/trace package provides APIs to add equivalent tracing support to a standalone program. See the Example that demonstrates how to use this API to enable tracing.</source>
          <target state="translated">이 런타임 / 추적 패키지는 독립형 프로그램에 동등한 추적 지원을 추가하기위한 API를 제공합니다. 이 API를 사용하여 추적을 사용하는 방법을 보여주는 예제를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="eb3d7236d288f19d5e07330ec9b641abb7a1c736" translate="yes" xml:space="preserve">
          <source>This section documents the encoding, details that are not important for most users. Details are presented bottom-up.</source>
          <target state="translated">이 섹션에서는 인코딩, 대부분의 사용자에게 중요하지 않은 세부 사항에 대해 설명합니다. 세부 사항은 상향식으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="8d97dde3cffa35e96f0901463ccd21bc2b7e33d2" translate="yes" xml:space="preserve">
          <source>This set may grow. Note that regular expression matches may need to examine text beyond the text returned by a match, so the methods that match text from a RuneReader may read arbitrarily far into the input before returning.</source>
          <target state="translated">이 세트는 커질 수 있습니다. 정규식 일치는 일치에서 반환 된 텍스트 이외의 텍스트를 검사해야 할 수 있으므로 RuneReader의 텍스트와 일치하는 메서드는 반환하기 전에 입력에서 임의로 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13155ea54999e3f67a0c6d8a556ef2fb922860ce" translate="yes" xml:space="preserve">
          <source>This should not be done concurrent to other receives from the Timer's channel.</source>
          <target state="translated">이것은 타이머의 채널로부터 다른 수신과 동시에 수행되어서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="0da770375be11542fa319ca413fcc3ece2b576a4" translate="yes" xml:space="preserve">
          <source>This type should be considered identical to sql.IsolationLevel along with any values defined on it.</source>
          <target state="translated">이 유형은 sql.IsolationLevel과 정의 된 값과 동일한 것으로 간주되어야합니다.</target>
        </trans-unit>
        <trans-unit id="5cefc7416c362c1afcf6c674cc1720ba6d02139f" translate="yes" xml:space="preserve">
          <source>This type should be considered identical to sql.TxOptions.</source>
          <target state="translated">이 유형은 sql.TxOptions와 동일한 것으로 간주되어야합니다.</target>
        </trans-unit>
        <trans-unit id="23bb56893bd9c167f4933bba0f06ea209969209a" translate="yes" xml:space="preserve">
          <source>ThreadCreateProfile returns n, the number of records in the thread creation profile. If len(p) &amp;gt;= n, ThreadCreateProfile copies the profile into p and returns n, true. If len(p) &amp;lt; n, ThreadCreateProfile does not change p and returns n, false.</source>
          <target state="translated">ThreadCreateProfile은 스레드 작성 프로파일의 레코드 수인 n을 리턴합니다. len (p)&amp;gt; = n 인 경우 ThreadCreateProfile은 프로파일을 p에 복사하고 n, true를 리턴합니다. len (p) &amp;lt;n이면 ThreadCreateProfile은 p를 변경하지 않고 n을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="aeddfe22a01fc0ff5fb0fe691b08db0b2e2a26c7" translate="yes" xml:space="preserve">
          <source>Tick</source>
          <target state="translated">Tick</target>
        </trans-unit>
        <trans-unit id="26c9fc157a3f52de1aca92922ccb9a288e5fa386" translate="yes" xml:space="preserve">
          <source>Tick is a convenience wrapper for NewTicker providing access to the ticking channel only. While Tick is useful for clients that have no need to shut down the Ticker, be aware that without a way to shut it down the underlying Ticker cannot be recovered by the garbage collector; it &quot;leaks&quot;. Unlike NewTicker, Tick will return nil if d &amp;lt;= 0.</source>
          <target state="translated">Tick은 NewTicker의 편의 래퍼로서 티킹 채널에만 액세스 할 수 있습니다. Tick은 Ticker를 종료 할 필요가없는 클라이언트에게 유용하지만,이를 종료 할 수있는 방법이 없으면 기본 Ticker를 가비지 수집기에서 복구 할 수 없습니다. &quot;누설&quot;. NewTicker와 달리 Tick은 d &amp;lt;= 0이면 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="464b9c4863cbad4e03c3166e6a41a020f20219b8" translate="yes" xml:space="preserve">
          <source>Time instants can be compared using the Before, After, and Equal methods. The Sub method subtracts two instants, producing a Duration. The Add method adds a Time and a Duration, producing a Time.</source>
          <target state="translated">Before, After 및 Equal 메서드를 사용하여 시간 인스턴트를 비교할 수 있습니다. Sub 메소드는 두 개의 순간을 빼서 Duration을 생성합니다. Add 메서드는 시간과 지속 시간을 추가하여 시간을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="7e0d5fdb48c2796b9cc511f84f1969b59a9bd1cf" translate="yes" xml:space="preserve">
          <source>Time.Add</source>
          <target state="translated">Time.Add</target>
        </trans-unit>
        <trans-unit id="5c2e779ba4c8677013ab3eb4de9c1e6bf9c9924b" translate="yes" xml:space="preserve">
          <source>Time.AddDate</source>
          <target state="translated">Time.AddDate</target>
        </trans-unit>
        <trans-unit id="730b4aa03b8316a2a6c19e05b72ec5d4eb05e78c" translate="yes" xml:space="preserve">
          <source>Time.After</source>
          <target state="translated">Time.After</target>
        </trans-unit>
        <trans-unit id="d5e86b615c46a18260de62e172d7e06cc20f7083" translate="yes" xml:space="preserve">
          <source>Time.AppendFormat</source>
          <target state="translated">Time.AppendFormat</target>
        </trans-unit>
        <trans-unit id="88be4309d5e0539eff6218d7e8c02ecf0c7b2e65" translate="yes" xml:space="preserve">
          <source>Time.Before</source>
          <target state="translated">Time.Before</target>
        </trans-unit>
        <trans-unit id="480d1c53462d365532b2348e82a3f0dcb963c99e" translate="yes" xml:space="preserve">
          <source>Time.Date</source>
          <target state="translated">Time.Date</target>
        </trans-unit>
        <trans-unit id="ae2638b80e7bdac6e6725adc567cf7badedc6abe" translate="yes" xml:space="preserve">
          <source>Time.Day</source>
          <target state="translated">Time.Day</target>
        </trans-unit>
        <trans-unit id="d4766b7b3328342b5ba1a667334b95afb4c840fd" translate="yes" xml:space="preserve">
          <source>Time.Equal</source>
          <target state="translated">Time.Equal</target>
        </trans-unit>
        <trans-unit id="092fc9098aafde18e6cec288675831ee7d77f8a8" translate="yes" xml:space="preserve">
          <source>Time.Format</source>
          <target state="translated">Time.Format</target>
        </trans-unit>
        <trans-unit id="dd61b8e28117a6a8c31fd714a3696b1193538443" translate="yes" xml:space="preserve">
          <source>Time.Format (Pad)</source>
          <target state="translated">Time.Format (패드)</target>
        </trans-unit>
        <trans-unit id="3768befc26b5bc40a2c6b38ecc6f26a0656a5d40" translate="yes" xml:space="preserve">
          <source>Time.Round</source>
          <target state="translated">Time.Round</target>
        </trans-unit>
        <trans-unit id="5b138a17083c1c36c8bab2fd64e7493a32a70b68" translate="yes" xml:space="preserve">
          <source>Time.String</source>
          <target state="translated">Time.String</target>
        </trans-unit>
        <trans-unit id="e126e45961c85339227ad3c92517287507ec5152" translate="yes" xml:space="preserve">
          <source>Time.Sub</source>
          <target state="translated">Time.Sub</target>
        </trans-unit>
        <trans-unit id="d3f1777c34673ecabb71603383f8d1fd8d6be9c4" translate="yes" xml:space="preserve">
          <source>Time.Truncate</source>
          <target state="translated">Time.Truncate</target>
        </trans-unit>
        <trans-unit id="c4ee117595e7091017dcf807233ec5e3324552ac" translate="yes" xml:space="preserve">
          <source>Time.Unix</source>
          <target state="translated">Time.Unix</target>
        </trans-unit>
        <trans-unit id="f8fc7e6bb582b1829de5a848ff872dea68eff61d" translate="yes" xml:space="preserve">
          <source>TimeFormat is the time format to use when generating times in HTTP headers. It is like time.RFC1123 but hard-codes GMT as the time zone. The time being formatted must be in UTC for Format to generate the correct format.</source>
          <target state="translated">TimeFormat은 HTTP 헤더에서 시간을 생성 할 때 사용하는 시간 형식입니다. RFC1123과 같지만 GMT를 표준 시간대로 하드 코딩합니다. 형식이 올바른 형식을 생성하려면 형식 시간이 UTC 여야합니다.</target>
        </trans-unit>
        <trans-unit id="9827d1afd02311b970b1c9ab5d2482ee7f917a5d" translate="yes" xml:space="preserve">
          <source>Timeout reports whether the DNS lookup is known to have timed out. This is not always known; a DNS lookup may fail due to a timeout and return a DNSError for which Timeout returns false.</source>
          <target state="translated">시간 초과는 DNS 조회가 시간 초과 된 것으로 알려 진지 여부를보고합니다. 이것이 항상 알려진 것은 아닙니다. 시간 초과로 인해 DNS 조회가 실패하고 시간 초과가 false를 반환하는 DNSError를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="927810e8434679578bc9bf07a4312dbfd80340d4" translate="yes" xml:space="preserve">
          <source>Timeout reports whether this error represents a timeout.</source>
          <target state="translated">시간 초과는이 오류가 시간 초과를 나타내는 지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="e7860bff1be7d01a8121a71b30616b2279f825c3" translate="yes" xml:space="preserve">
          <source>TimeoutHandler returns a Handler that runs h with the given time limit.</source>
          <target state="translated">TimeoutHandler는 주어진 시간 제한으로 h를 실행하는 핸들러를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="41f375b226e7f8e10a9acde2441f73751822f0d4" translate="yes" xml:space="preserve">
          <source>TimeoutHandler supports the Flusher and Pusher interfaces but does not support the Hijacker interface.</source>
          <target state="translated">TimeoutHandler는 Flusher 및 Pusher 인터페이스를 지원하지만 Hijacker 인터페이스는 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="229f8a47d6424d21cc11a27228c5b3dd3021912d" translate="yes" xml:space="preserve">
          <source>TimeoutHandler supports the Pusher interface but does not support the Hijacker or Flusher interfaces.</source>
          <target state="translated">TimeoutHandler는 Pusher 인터페이스를 지원하지만 Hijacker 또는 Flusher 인터페이스는 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b94b20b16ca4b5f916aaa1eb8d24553f8d4b92c2" translate="yes" xml:space="preserve">
          <source>TimeoutReader returns ErrTimeout on the second read with no data. Subsequent calls to read succeed.</source>
          <target state="translated">TimeoutReader는 두 번째 읽기에서 데이터없이 ErrTimeout을 반환합니다. 후속 호출은 성공합니다.</target>
        </trans-unit>
        <trans-unit id="8bdae2bbf616fbfd5c5eefd29c8a537bd886144c" translate="yes" xml:space="preserve">
          <source>TimespecToNsec converts a Timespec value into a number of nanoseconds since the Unix epoch.</source>
          <target state="translated">TimespecToNsec는 Timespec 값을 Unix 시대 이후 수 나노초로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="71641b558817e2a09b865dac9868550ced5db039" translate="yes" xml:space="preserve">
          <source>TimevalToNsec converts a Timeval value into a number of nanoseconds since the Unix epoch.</source>
          <target state="translated">TimevalToNsec은 Timeval 값을 Unix 시대 이후 수 나노초로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="768e0c1c69573fb588f61f1308a015c11468e05f" translate="yes" xml:space="preserve">
          <source>Title</source>
          <target state="translated">Title</target>
        </trans-unit>
        <trans-unit id="ee048df59e1fe3a78061c7c9271c635869379b9b" translate="yes" xml:space="preserve">
          <source>Title returns a copy of the string s with all Unicode letters that begin words mapped to their Unicode title case.</source>
          <target state="translated">Title은 유니 코드 제목 대 / 소문자로 매핑 된 단어를 시작하는 모든 유니 코드 문자가 포함 된 문자열 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="173f12648645a6edd8fcbab7c7ed0369c007806c" translate="yes" xml:space="preserve">
          <source>Title treats s as UTF-8-encoded bytes and returns a copy with all Unicode letters that begin words mapped to their title case.</source>
          <target state="translated">Title은 s를 UTF-8로 인코딩 된 바이트로 취급하고 제목 케이스에 단어를 매핑하는 모든 유니 코드 문자가 포함 된 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ae79ea1e9c6391a9ed83a2e18a031b835feec0c9" translate="yes" xml:space="preserve">
          <source>To</source>
          <target state="translated">To</target>
        </trans-unit>
        <trans-unit id="616d61f65a9f91c650c28db92d9cb8984a1f52bd" translate="yes" xml:space="preserve">
          <source>To add equivalent profiling support to a standalone program, add code like the following to your main function:</source>
          <target state="translated">독립형 프로그램에 동등한 프로파일 링 지원을 추가하려면 다음과 같은 코드를 기본 기능에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="f6f5822190a6e77b3f6e2423fce4abac430f1e8d" translate="yes" xml:space="preserve">
          <source>To avoid denial of service attacks, the provided bufio.Reader should be reading from an io.LimitReader or similar Reader to bound the size of responses.</source>
          <target state="translated">서비스 거부 공격을 피하려면 제공된 bufio.Reader는 io.LimitReader 또는 이와 유사한 Reader에서 응답 크기를 제한해야합니다.</target>
        </trans-unit>
        <trans-unit id="87386ad5a06e96430212748899697cda9d7a3724" translate="yes" xml:space="preserve">
          <source>To avoid recursion in cases such as</source>
          <target state="translated">다음과 같은 경우 재귀를 피하기 위해</target>
        </trans-unit>
        <trans-unit id="a87f0fb7c131221874ae3b0c17104f44ee1c34bc" translate="yes" xml:space="preserve">
          <source>To be backwards compatible the FileHeader has both 32 and 64 bit Size fields. The 64 bit fields will always contain the correct value and for normal archives both fields will be the same. For files requiring the ZIP64 format the 32 bit fields will be 0xffffffff and the 64 bit fields must be used instead.</source>
          <target state="translated">하위 호환성을 위해 FileHeader에는 32 및 64 비트 크기 필드가 있습니다. 64 비트 필드는 항상 올바른 값을 포함하며 일반 아카이브의 경우 두 필드가 동일합니다. ZIP64 형식이 필요한 파일의 경우 32 비트 필드는 0xffffffff이며 64 비트 필드를 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="f0c9c2ba0d3b42114f628f0336b7d63f8138a666" translate="yes" xml:space="preserve">
          <source>To build a file only when using cgo, and only on Linux and OS X:</source>
          <target state="translated">cgo를 사용할 때만 Linux 및 OS X에서만 파일을 빌드하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="b59fa373960766ba2850aeb1bfd6ebb3acccc2d0" translate="yes" xml:space="preserve">
          <source>To build strings more efficiently, see the strings.Builder type.</source>
          <target state="translated">보다 효율적으로 문자열을 작성하려면 strings.Builder 유형을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="65822ab438826bd3303521dc362fbdb7385f9c68" translate="yes" xml:space="preserve">
          <source>To change the destination for flag messages, call CommandLine.SetOutput.</source>
          <target state="translated">플래그 메시지의 대상을 변경하려면 CommandLine.SetOutput을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="697c0150c9b1eec40f18c8aa7919a2878d3bf00a" translate="yes" xml:space="preserve">
          <source>To compare two Values, compare the results of the Interface method. Using == on two Values does not compare the underlying values they represent.</source>
          <target state="translated">두 값을 비교하려면 인터페이스 방법의 결과를 비교하십시오. 두 개의 값에 ==를 사용하면 해당 값이 나타내는 기본 값이 비교되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="26bcf90200ee4c383ef61356b62c1cde915663a4" translate="yes" xml:space="preserve">
          <source>To complete the example above, the following code tries to find the value x in an integer slice data sorted in ascending order:</source>
          <target state="translated">위의 예제를 완료하기 위해 다음 코드는 오름차순으로 정렬 된 정수 슬라이스 데이터에서 x 값을 찾으려고합니다.</target>
        </trans-unit>
        <trans-unit id="48862e3dd334f932c3f29aca76cb78295d40632d" translate="yes" xml:space="preserve">
          <source>To compute the number of allocations, the function will first be run once as a warm-up. The average number of allocations over the specified number of runs will then be measured and returned.</source>
          <target state="translated">할당 수를 계산하기 위해이 기능은 먼저 예열로 한 번 실행됩니다. 그런 다음 지정된 실행 횟수에 대한 평균 할당 수를 측정하여 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a1b4d9690ab97f466c6d326d8c742f5be1f15108" translate="yes" xml:space="preserve">
          <source>To convert an integer number of units to a Duration, multiply:</source>
          <target state="translated">정수의 단위를 Duration으로 변환하려면 다음을 곱하십시오.</target>
        </trans-unit>
        <trans-unit id="c70ea98cf5f708e17c34d681b2e9583414cbfaae" translate="yes" xml:space="preserve">
          <source>To count the number of units in a Duration, divide:</source>
          <target state="translated">지속 시간의 단위 수를 계산하려면 다음을 나누십시오.</target>
        </trans-unit>
        <trans-unit id="a8a481566ee5c9f4011b251f076b7cff25d2b336" translate="yes" xml:space="preserve">
          <source>To create a new request with a context, use NewRequestWithContext. To change the context of a request (such as an incoming) you then also want to modify to send back out, use Request.Clone. Between those two uses, it's rare to need WithContext.</source>
          <target state="translated">컨텍스트를 사용하여 새 요청을 작성하려면 NewRequestWithContext를 사용하십시오. 요청 컨텍스트 (예 : 수신)를 변경 한 후 다시 보내도록 수정하려면 Request.Clone을 사용하십시오. 이 두 가지 용도 사이에 WithContext가 필요한 경우는 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="df17ef73a333723433e10a65752b7d97c8d742ec" translate="yes" xml:space="preserve">
          <source>To create a new request with a context, use NewRequestWithContext. To change the context of a request, such as an incoming request you want to modify before sending back out, use Request.Clone. Between those two uses, it's rare to need WithContext.</source>
          <target state="translated">컨텍스트가있는 새 요청을 생성하려면 NewRequestWithContext를 사용합니다. 다시 보내기 전에 수정하려는 수신 요청과 같은 요청의 컨텍스트를 변경하려면 Request.Clone을 사용하십시오. 이 두 가지 용도 사이에 WithContext가 필요한 경우는 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="d1ce4e028f3adf6fe5e3e3ea8b7a3ce1d7c4cce0" translate="yes" xml:space="preserve">
          <source>To create the Pos value for a specific source offset (measured in bytes), first add the respective file to the current file set using FileSet.AddFile and then call File.Pos(offset) for that file. Given a Pos value p for a specific file set fset, the corresponding Position value is obtained by calling fset.Position(p).</source>
          <target state="translated">바이트 단위로 측정 된 특정 소스 오프셋에 대한 Pos 값을 만들려면 먼저 FileSet.AddFile을 사용하여 각 파일을 현재 파일 세트에 추가 한 다음 해당 파일에 대해 File.Pos (offset)를 호출하십시오. 특정 파일 세트 fset에 대해 Pos 값 p가 주어지면 해당 위치 값은 fset.Position (p)를 호출하여 얻습니다.</target>
        </trans-unit>
        <trans-unit id="ffa6362a850b5571ec14ab520e75aaa3f0b772a0" translate="yes" xml:space="preserve">
          <source>To define a type, the encoder chooses an unused, positive type id and sends the pair (-type id, encoded-type) where encoded-type is the gob encoding of a wireType description, constructed from these types:</source>
          <target state="translated">유형을 정의하기 위해 인코더는 사용되지 않은 양의 유형 ID를 선택하고 pair-type id, encode-type을 전송합니다. 여기서 encoding-type은 다음 유형으로 구성된 wireType 설명의 gob 인코딩입니다.</target>
        </trans-unit>
        <trans-unit id="da43583df08c2ff7e4692ba80d3b2cf801b80a61" translate="yes" xml:space="preserve">
          <source>To define your own format, write down what the reference time would look like formatted your way; see the values of constants like ANSIC, StampMicro or Kitchen for examples. The model is to demonstrate what the reference time looks like so that the Format and Parse methods can apply the same transformation to a general time value.</source>
          <target state="translated">자신의 형식을 정의하려면 참조 시간이 형식이 어떻게 표시되는지 기록하십시오. 예제는 ANSIC, StampMicro 또는 Kitchen과 같은 상수 값을 참조하십시오. 이 모델은 Format 및 Parse 메서드가 동일한 변환을 일반 시간 값에 적용 할 수 있도록 참조 시간이 어떻게 보이는지 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="79806cf1eaac70011a5e985d3751306c16fa37ee" translate="yes" xml:space="preserve">
          <source>To distinguish build constraints from package documentation, a series of build constraints must be followed by a blank line.</source>
          <target state="translated">빌드 제한 조건을 패키지 문서와 구별하려면 일련의 빌드 제한 조건 다음에 공백 행이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="a50607887789cbea54ccb0db0c455e312a84417e" translate="yes" xml:space="preserve">
          <source>To ensure the channel is empty after a call to Stop, check the return value and drain the channel. For example, assuming the program has not received from t.C already:</source>
          <target state="translated">Stop 호출 후 채널이 비어 있는지 확인하려면 리턴 값을 확인하고 채널을 비우십시오. 예를 들어, 프로그램이 tC로부터 이미 수신되지 않았다고 가정하면 :</target>
        </trans-unit>
        <trans-unit id="dc7659d0594b1222a7c79baf65726fd2fc8fc92f" translate="yes" xml:space="preserve">
          <source>To escape a text segment, bracket it with Escape characters. For instance, the tab in this string &quot;Ignore this tab: \xff\t\xff&quot; does not terminate a cell and constitutes a single character of width one for formatting purposes.</source>
          <target state="translated">텍스트 세그먼트를 이스케이프하려면 이스케이프 문자로 묶습니다. 예를 들어이 문자열의 탭 &quot;이 탭 무시 : \ xff \ t \ xff&quot;는 셀을 종료하지 않으며 형식화를 위해 하나의 너비 문자를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="a3866d2c65d6d17db1dce0e7ab464336a1186960" translate="yes" xml:space="preserve">
          <source>To force integer division of Int operands, use op == token.QUO_ASSIGN instead of token.QUO; the result is guaranteed to be Int in this case. Division by zero leads to a run-time panic.</source>
          <target state="translated">Int 피연산자의 정수 나누기를 강제하려면 token.QUO 대신 op == token.QUO_ASSIGN을 사용하십시오. 이 경우 결과는 Int입니다. 0으로 나누면 런타임 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="93f96dd1110bc83e45c261305087ab59ccdab5c6" translate="yes" xml:space="preserve">
          <source>To generate HTML output, see package html/template, which has the same interface as this package but automatically secures HTML output against certain attacks.</source>
          <target state="translated">HTML 출력을 생성하려면이 패키지와 인터페이스는 동일하지만 특정 공격에 대해 HTML 출력을 자동으로 보호하는 html / template 패키지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0f37e1016d8b746740d606c5f03bd61a370f62be" translate="yes" xml:space="preserve">
          <source>To generate a client HTTP request instead of a server request, see the NewRequest function in the net/http package.</source>
          <target state="translated">서버 요청 대신 클라이언트 HTTP 요청을 생성하려면 net / http 패키지의 NewRequest 함수를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="06a96f64d7d0f413489f0372ff0c9c5459591c5b" translate="yes" xml:space="preserve">
          <source>To include every allocated block in the profile, set MemProfileRate to 1. To turn off profiling entirely, set MemProfileRate to 0.</source>
          <target state="translated">프로파일에 할당 된 모든 블록을 포함하려면 MemProfileRate를 1로 설정하십시오. 프로파일 링을 완전히 해제하려면 MemProfileRate를 0으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="1cf82e7adf1a06dc5b4204dd8949c669c22a6ce1" translate="yes" xml:space="preserve">
          <source>To include every blocking event in the profile, pass rate = 1. To turn off profiling entirely, pass rate &amp;lt;= 0.</source>
          <target state="translated">프로파일에 모든 차단 이벤트를 포함 시키려면 전달 속도 = 1입니다. 프로파일 링을 완전히 끄려면 전달 속도 &amp;lt;= 0입니다.</target>
        </trans-unit>
        <trans-unit id="5634feb2ac7b66d9d403fa3ba44d3dd35de4aafa" translate="yes" xml:space="preserve">
          <source>To insert a literal $ in the output, use $$ in the template.</source>
          <target state="translated">출력에 리터럴 $를 삽입하려면 템플리트에서 $$를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fc7c25c25b23cfac629203b1f680a734ada8bcd7" translate="yes" xml:space="preserve">
          <source>To iterate over a list (where l is a *List):</source>
          <target state="translated">리스트를 반복하려면 (여기서 l은 * List 임) :</target>
        </trans-unit>
        <trans-unit id="04464b93c140cce60515e90ab741d559641a3b86" translate="yes" xml:space="preserve">
          <source>To keep a file from being considered for the build:</source>
          <target state="translated">빌드에 파일이 고려되지 않도록하려면</target>
        </trans-unit>
        <trans-unit id="b8dd565d2e14c4949f658d07fd948bd6982afd99" translate="yes" xml:space="preserve">
          <source>To make a request with custom headers, use NewRequest and Client.Do.</source>
          <target state="translated">사용자 정의 헤더를 사용하여 요청하려면 NewRequest 및 Client.Do를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5032a2d57ff9e66d730ea600879b156b0a5e02a1" translate="yes" xml:space="preserve">
          <source>To make a request with custom headers, use NewRequest and DefaultClient.Do.</source>
          <target state="translated">사용자 정의 헤더로 요청하려면 NewRequest 및 DefaultClient.Do를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="706ee8ff1d514d4082de19c46038d881341df0b9" translate="yes" xml:space="preserve">
          <source>To maps the rune to the specified case: UpperCase, LowerCase, or TitleCase.</source>
          <target state="translated">룬을 UpperCase, LowerCase 또는 TitleCase와 같이 지정된 케이스에 맵핑합니다.</target>
        </trans-unit>
        <trans-unit id="13858e1fce15a0a8116d4d08d0813cfa32d04dd1" translate="yes" xml:space="preserve">
          <source>To prevent IP spoofing, be sure to delete any pre-existing X-Forwarded-For header coming from the client or an untrusted proxy.</source>
          <target state="translated">IP 스푸핑을 방지하려면 클라이언트 또는 신뢰할 수없는 프록시에서 들어오는 기존 X-Forwarded-For 헤더를 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="16db8fa630b8ed6e5e098c9ecc986852e23449ff" translate="yes" xml:space="preserve">
          <source>To prevent duplicate operations, ErrBadConn should NOT be returned if there's a possibility that the database server might have performed the operation. Even if the server sends back an error, you shouldn't return ErrBadConn.</source>
          <target state="translated">중복 작업을 방지하기 위해 데이터베이스 서버가 작업을 수행했을 가능성이있는 경우 ErrBadConn이 반환되지 않아야합니다. 서버가 오류를 다시 보내더라도 ErrBadConn을 반환해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="367a95ef6b89677c6010e99bfe83911bb6aa0ff5" translate="yes" xml:space="preserve">
          <source>To remove a prefix, use TrimPrefix instead.</source>
          <target state="translated">접두사를 제거하려면 대신 TrimPrefix를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="651b4bc851ab5004fd129e9e0ff7675d7d666cef" translate="yes" xml:space="preserve">
          <source>To remove a suffix, use TrimSuffix instead.</source>
          <target state="translated">접미사를 제거하려면 대신 TrimSuffix를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c83bbc4183fb8f4e0540869ebe8099226ccd8816" translate="yes" xml:space="preserve">
          <source>To set custom headers, use NewRequest and Client.Do.</source>
          <target state="translated">사용자 정의 헤더를 설정하려면 NewRequest 및 Client.Do를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="71135b9f4481c76b2f670b0d39a1f656b3961a0f" translate="yes" xml:space="preserve">
          <source>To set custom headers, use NewRequest and DefaultClient.Do.</source>
          <target state="translated">사용자 정의 헤더를 설정하려면 NewRequest 및 DefaultClient.Do를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="db9b30900d9da4419f81d83d998e553e2dab25bb" translate="yes" xml:space="preserve">
          <source>To support custom data types, implement NamedValueChecker. NamedValueChecker also allows queries to accept per-query options as a parameter by returning ErrRemoveArgument from CheckNamedValue.</source>
          <target state="translated">사용자 정의 데이터 유형을 지원하려면 NamedValueChecker를 구현하십시오. 또한 NamedValueChecker는 CheckNamedValue에서 ErrRemoveArgument를 반환하여 쿼리가 쿼리 별 옵션을 매개 변수로 허용하도록합니다.</target>
        </trans-unit>
        <trans-unit id="75e0a568234c8cc832fa169bfc3c25d385870808" translate="yes" xml:space="preserve">
          <source>To translate these PCs into symbolic information such as function names and line numbers, use CallersFrames. CallersFrames accounts for inlined functions and adjusts the return program counters into call program counters. Iterating over the returned slice of PCs directly is discouraged, as is using FuncForPC on any of the returned PCs, since these cannot account for inlining or return program counter adjustment.</source>
          <target state="translated">이러한 PC를 함수 이름 및 줄 번호와 같은 기호 정보로 변환하려면 CallersFrames를 사용하십시오. CallersFrames는 인라인 함수를 설명하고 반환 프로그램 카운터를 호출 프로그램 카운터로 조정합니다. 반환 된 PC 조각을 직접 반복하는 것은 반환 된 PC에서 FuncForPC를 사용하는 것처럼 권장되지 않습니다. 이는 인라인 또는 반환 프로그램 카운터 조정을 고려할 수 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="83002d8cdc0fe4d874cff59ee6e149e3669f91df" translate="yes" xml:space="preserve">
          <source>To translate these PCs into symbolic information such as function names and line numbers, use CallersFrames. CallersFrames accounts for inlined functions and adjusts the return program counters into call program counters. Iterating over the returned slice of PCs directly is discouraged, as is using FuncForPC on any of the returned PCs, since these cannot account for inlining or return program counter adjustment. go:noinline</source>
          <target state="translated">이러한 PC를 기능 이름 및 행 번호와 같은 기호 정보로 변환하려면 CallersFrames를 사용하십시오. CallersFrames는 인라인 된 기능을 설명하고 리턴 프로그램 카운터를 호출 프로그램 카운터로 조정합니다. 반환 된 PC 슬라이스를 직접 반복하는 것은 반환 된 PC 중 하나에서 FuncForPC를 사용하는 것과 같이 인라인 또는 리턴 프로그램 카운터 조정을 설명 할 수 없으므로 권장하지 않습니다. go : noinline</target>
        </trans-unit>
        <trans-unit id="3b553336a2ed0371927e0210cc490999d6f454c6" translate="yes" xml:space="preserve">
          <source>To turn off profiling entirely, pass rate 0. To just read the current rate, pass rate &amp;lt; 0. (For n&amp;gt;1 the details of sampling may change.)</source>
          <target state="translated">프로파일 링을 완전히 끄려면 속도 0을 전달하십시오. 현재 속도를 읽으려면 속도 &amp;lt;0을 전달하십시오. (n&amp;gt; 1의 경우 샘플링 세부 사항이 변경 될 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="ec0c40fcb609291204c17f8d3e9e4a0cf0fb716d" translate="yes" xml:space="preserve">
          <source>To unmarshal JSON into a pointer, Unmarshal first handles the case of the JSON being the JSON literal null. In that case, Unmarshal sets the pointer to nil. Otherwise, Unmarshal unmarshals the JSON into the value pointed at by the pointer. If the pointer is nil, Unmarshal allocates a new value for it to point to.</source>
          <target state="translated">JSON을 포인터로 비 정렬 화하기 위해 Unmarshal은 먼저 JSON이 JSON 리터럴 널인 경우를 처리합니다. 이 경우 Unmarshal은 포인터를 nil로 설정합니다. 그렇지 않으면 Unmarshal은 포인터가 가리키는 값으로 JSON을 비 정렬 화합니다. 포인터가 nil이면 Unmarshal은 포인터가 가리 키도록 새 값을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="9ec7dbd6621b41728144a0cd3fc2c36f64948e68" translate="yes" xml:space="preserve">
          <source>To unmarshal JSON into a struct, Unmarshal matches incoming object keys to the keys used by Marshal (either the struct field name or its tag), preferring an exact match but also accepting a case-insensitive match. By default, object keys which don't have a corresponding struct field are ignored (see Decoder.DisallowUnknownFields for an alternative).</source>
          <target state="translated">JSON을 구조체로 비 정렬 화하기 위해 Unmarshal은 들어오는 객체 키를 Marshal에서 사용하는 키 (구조체 필드 이름 또는 태그)와 일치 시키며, 정확히 일치하는 것을 선호하지만 대소 문자를 구분하지 않는 일치도 허용합니다. 기본적으로 해당 구조체 필드가없는 객체 키는 무시됩니다 (대안은 Decoder.DisallowUnknownFields 참조).</target>
        </trans-unit>
        <trans-unit id="a6bdbb20d4135a3bc4596a68aa8c2c34912d504d" translate="yes" xml:space="preserve">
          <source>To unmarshal JSON into a value implementing the Unmarshaler interface, Unmarshal calls that value's UnmarshalJSON method, including when the input is a JSON null. Otherwise, if the value implements encoding.TextUnmarshaler and the input is a JSON quoted string, Unmarshal calls that value's UnmarshalText method with the unquoted form of the string.</source>
          <target state="translated">Unmarshaler 인터페이스를 구현하는 값으로 JSON을 비 정렬 화하기 위해 Unmarshal은 입력이 JSON null 인 경우를 포함하여 해당 값의 UnmarshalJSON 메서드를 호출합니다. 그렇지 않으면 값이 encoding.TextUnmarshaler를 구현하고 입력이 JSON 인용 문자열 인 경우 Unmarshal은 인용되지 않은 문자열 형식으로 해당 값의 UnmarshalText 메서드를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="c66b5ce0cf55557d8e9fd777ec15355bade4e117" translate="yes" xml:space="preserve">
          <source>To unmarshal JSON into an interface value, Unmarshal stores one of these in the interface value:</source>
          <target state="translated">Unmarshal은 JSON을 인터페이스 값으로 언 마샬링하기 위해 다음 중 하나를 인터페이스 값에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="94c1b420cdca6fe4940f209d9a41f19875bfb4e7" translate="yes" xml:space="preserve">
          <source>To unmarshal a JSON array into a Go array, Unmarshal decodes JSON array elements into corresponding Go array elements. If the Go array is smaller than the JSON array, the additional JSON array elements are discarded. If the JSON array is smaller than the Go array, the additional Go array elements are set to zero values.</source>
          <target state="translated">JSON 배열을 Go 배열로 비 정렬 화하기 위해 Unmarshal은 JSON 배열 요소를 해당 Go 배열 요소로 디코딩합니다. Go 배열이 JSON 배열보다 작은 경우 추가 JSON 배열 요소가 삭제됩니다. JSON 배열이 Go 배열보다 작은 경우 추가 Go 배열 요소가 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="ed4bdd964a47161b70a00bdaa7dc00eb114dff57" translate="yes" xml:space="preserve">
          <source>To unmarshal a JSON array into a slice, Unmarshal resets the slice length to zero and then appends each element to the slice. As a special case, to unmarshal an empty JSON array into a slice, Unmarshal replaces the slice with a new empty slice.</source>
          <target state="translated">JSON 배열을 슬라이스로 비 정렬 화하기 위해 Unmarshal은 슬라이스 길이를 0으로 재설정 한 다음 각 요소를 슬라이스에 추가합니다. 특별한 경우 빈 JSON 배열을 슬라이스로 비 정렬 화하기 위해 Unmarshal은 슬라이스를 새로운 빈 슬라이스로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="007b32960f68d5d51b318bb76ca9ea0286f4126d" translate="yes" xml:space="preserve">
          <source>To unmarshal a JSON object into a map, Unmarshal first establishes a map to use. If the map is nil, Unmarshal allocates a new map. Otherwise Unmarshal reuses the existing map, keeping existing entries. Unmarshal then stores key-value pairs from the JSON object into the map. The map's key type must either be a string, an integer, or implement encoding.TextUnmarshaler.</source>
          <target state="translated">JSON 객체를 맵에서 비 정렬 화하기 위해 Unmarshal은 먼저 사용할 맵을 설정합니다. 맵이 nil이면 Unmarshal은 새 맵을 할당합니다. 그렇지 않으면 비 정렬 화는 기존 맵을 재사용하여 기존 항목을 유지합니다. Unmarshal은 JSON 객체의 키-값 쌍을 맵에 저장합니다. 지도의 키 유형은 문자열, 정수 또는 encoding.TextUnmarshaler를 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="6d6fc53f4b0d33aa877b6d747d45b96f410c47fc" translate="yes" xml:space="preserve">
          <source>To unmarshal a JSON object into a map, Unmarshal first establishes a map to use. If the map is nil, Unmarshal allocates a new map. Otherwise Unmarshal reuses the existing map, keeping existing entries. Unmarshal then stores key-value pairs from the JSON object into the map. The map's key type must either be any string type, an integer, implement json.Unmarshaler, or implement encoding.TextUnmarshaler.</source>
          <target state="translated">JSON 객체를 맵으로 언 마샬링하기 위해 Unmarshal은 먼저 사용할 맵을 설정합니다. 맵이 nil이면 Unmarshal은 새 맵을 할당합니다. 그렇지 않으면 Unmarshal은 기존 맵을 재사용하여 기존 항목을 유지합니다. 그런 다음 비 정렬 화는 JSON 개체의 키-값 쌍을 맵에 저장합니다. 맵의 키 유형은 모든 문자열 유형, 정수, json.Unmarshaler 구현 또는 encoding.TextUnmarshaler 구현이어야합니다.</target>
        </trans-unit>
        <trans-unit id="b87bf4d25ca4624c96c72d4062afc898f384fa73" translate="yes" xml:space="preserve">
          <source>To use a Pipeline p to manage multiple clients on a connection, each client should run:</source>
          <target state="translated">파이프 라인 p를 사용하여 연결에서 여러 클라이언트를 관리하려면 각 클라이언트가 다음을 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="f6369ce890fdc06aa42e060bacdc465b9893f8d9" translate="yes" xml:space="preserve">
          <source>To use a fixed length slice, or a preallocated one, use FillBytes.</source>
          <target state="translated">고정 길이 슬라이스 또는 미리 할당 된 슬라이스를 사용하려면 FillBytes를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="800eefdd201759f89cf9257524a524d86be67a56" translate="yes" xml:space="preserve">
          <source>To use an existing prepared statement on this transaction, see Tx.Stmt.</source>
          <target state="translated">이 트랜잭션에서 기존의 준비된 명령문을 사용하려면 Tx.Stmt를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0c3bf1a32c9b769f727db4118e0b83ca4bb4efa4" translate="yes" xml:space="preserve">
          <source>To use gobs, create an Encoder and present it with a series of data items as values or addresses that can be dereferenced to values. The Encoder makes sure all type information is sent before it is needed. At the receive side, a Decoder retrieves values from the encoded stream and unpacks them into local variables.</source>
          <target state="translated">gob를 사용하려면 Encoder를 생성하고 값으로 참조 할 수있는 일련의 데이터 항목을 값 또는 주소로 표시하십시오. 인코더는 모든 유형 정보가 필요하기 전에 전송되도록합니다. 수신 측에서 디코더는 인코딩 된 스트림에서 값을 검색하여 로컬 변수에 압축을 풉니 다.</target>
        </trans-unit>
        <trans-unit id="8212c55a0bf9e12d2e296b39237ee5f72cae9d11" translate="yes" xml:space="preserve">
          <source>To use pprof, link this package into your program:</source>
          <target state="translated">pprof를 사용하려면이 패키지를 프로그램에 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="5c29e8288fd1ed9e073fe203fb55fbea12d062de" translate="yes" xml:space="preserve">
          <source>To use the operating system's file system implementation, use http.Dir:</source>
          <target state="translated">운영 체제의 파일 시스템 구현을 사용하려면 http.Dir을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="467272919dc8f37262b26b52d65afd618589f7ff" translate="yes" xml:space="preserve">
          <source>To view all available profiles, open &lt;a href=&quot;http://localhost:6060/debug/pprof/&quot;&gt;http://localhost:6060/debug/pprof/&lt;/a&gt; in your browser.</source>
          <target state="translated">사용 가능한 모든 프로필을 보려면 브라우저에서 &lt;a href=&quot;http://localhost:6060/debug/pprof/&quot;&gt;http : // localhost : 6060 / debug / pprof /&lt;/a&gt; 를 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="4193fe2d5f7ce0c7cb324cbe3968e7d5bd540d92" translate="yes" xml:space="preserve">
          <source>To write a new test suite, create a file whose name ends _test.go that contains the TestXxx functions as described here. Put the file in the same package as the one being tested. The file will be excluded from regular package builds but will be included when the &quot;go test&quot; command is run. For more detail, run &quot;go help test&quot; and &quot;go help testflag&quot;.</source>
          <target state="translated">새 테스트 스위트를 작성하려면 여기에 설명 된대로 TestXxx 함수를 포함하는 이름이 _test.go로 끝나는 파일을 작성하십시오. 테스트중인 패키지와 동일한 패키지에 파일을 넣으십시오. 파일은 일반 패키지 빌드에서 제외되지만 &quot;go test&quot;명령이 실행될 때 포함됩니다. 자세한 내용은 &quot;go help test&quot;및 &quot;go help testflag&quot;를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="f1229c7d06cb687b015bf9729398a1b9b76a455a" translate="yes" xml:space="preserve">
          <source>To write a new test suite, create a file whose name ends _test.go that contains the TestXxx functions as described here. Put the file in the same package as the one being tested. The file will be excluded from regular package builds but will be included when the &amp;ldquo;go test&amp;rdquo; command is run. For more detail, run &amp;ldquo;go help test&amp;rdquo; and &amp;ldquo;go help testflag&amp;rdquo;.</source>
          <target state="translated">새 테스트 스위트를 작성하려면 여기에 설명 된대로 TestXxx 함수를 포함하는 이름이 _test.go로 끝나는 파일을 작성하십시오. 테스트 할 파일과 동일한 패키지에 파일을 넣습니다. 파일은 일반 패키지 빌드에서 제외되지만 &quot;go test&quot;명령이 실행될 때 포함됩니다. 자세한 내용은&amp;ldquo;go help test&amp;rdquo;및&amp;ldquo;go help testflag&amp;rdquo;를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="2392dbedc5657df0a5a8c5b158593f759c811858" translate="yes" xml:space="preserve">
          <source>To16 converts the IP address ip to a 16-byte representation. If ip is not an IP address (it is the wrong length), To16 returns nil.</source>
          <target state="translated">To16은 IP 주소 ip를 16 바이트 표현으로 변환합니다. ip가 IP 주소가 아닌 경우 (잘못된 길이) To16은 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4294dda7ebb07f9702b0ce5cc1cb8bbf6e004822" translate="yes" xml:space="preserve">
          <source>To4 converts the IPv4 address ip to a 4-byte representation. If ip is not an IPv4 address, To4 returns nil.</source>
          <target state="translated">To4는 IPv4 주소 ip를 4 바이트 표현으로 변환합니다. ip가 IPv4 주소가 아닌 경우 To4는 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7deadbf704990f79d3e4df9686f8846e15431131" translate="yes" xml:space="preserve">
          <source>ToComplex converts x to a Complex value if x is representable as a Complex. Otherwise it returns an Unknown.</source>
          <target state="translated">x가 Complex로 표현 될 수있는 경우 ToComplex는 x를 Complex 값으로 변환합니다. 그렇지 않으면 알 수 없음을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="95e3b1fabb27004c6322f401e410b77c8beecafb" translate="yes" xml:space="preserve">
          <source>ToFloat converts x to a Float value if x is representable as a Float. Otherwise it returns an Unknown.</source>
          <target state="translated">x가 Float로 표현 가능한 경우 ToFloat는 x를 Float 값으로 변환합니다. 그렇지 않으면 알 수 없음을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f5e30e0ab3c38971ff0a23a0823ee7ab2da27587" translate="yes" xml:space="preserve">
          <source>ToHTML converts comment text to formatted HTML. The comment was prepared by DocReader, so it is known not to have leading, trailing blank lines nor to have trailing spaces at the end of lines. The comment markers have already been removed.</source>
          <target state="translated">ToHTML은 주석 텍스트를 형식이 지정된 HTML로 변환합니다. 주석은 DocReader에 의해 작성되었으므로 선행, 후행 공백 행이 없거나 행 끝에 후행 공백이없는 것으로 알려져 있습니다. 주석 마커가 이미 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="2f4af6e587a0b093dcea21d741f457946dac2539" translate="yes" xml:space="preserve">
          <source>ToInt converts x to an Int value if x is representable as an Int. Otherwise it returns an Unknown.</source>
          <target state="translated">x가 Int로 표현 가능한 경우 ToInt는 x를 Int 값으로 변환합니다. 그렇지 않으면 알 수 없음을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2458b21542ecbc0f90f413b7ee46521686d711b0" translate="yes" xml:space="preserve">
          <source>ToLower</source>
          <target state="translated">ToLower</target>
        </trans-unit>
        <trans-unit id="6fec192e916332e15759b9ef1699226d11bdd209" translate="yes" xml:space="preserve">
          <source>ToLower maps the rune to lower case giving priority to the special mapping.</source>
          <target state="translated">ToLower는 룬을 소문자로 매핑하여 특수 매핑에 우선 순위를 둡니다.</target>
        </trans-unit>
        <trans-unit id="0d0c9cd1331838718de8a67a4fe3f8edaf0bf598" translate="yes" xml:space="preserve">
          <source>ToLower maps the rune to lower case.</source>
          <target state="translated">ToLower는 룬을 소문자로 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="0ad2eff81c68ba7feeec4169aa737e669765ecb3" translate="yes" xml:space="preserve">
          <source>ToLower returns a copy of the byte slice s with all Unicode letters mapped to their lower case.</source>
          <target state="translated">ToLower는 모든 유니 코드 문자가 소문자로 매핑 된 바이트 슬라이스의 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9ce8fb31583c9a3f9db4dda94a7dc14fcb01df77" translate="yes" xml:space="preserve">
          <source>ToLower returns s with all Unicode letters mapped to their lower case.</source>
          <target state="translated">ToLower는 모든 유니 코드 문자를 소문자로 매핑하여을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7c6c5994143b17fa29690098b9cf21d8ab0c9626" translate="yes" xml:space="preserve">
          <source>ToLowerSpecial</source>
          <target state="translated">ToLowerSpecial</target>
        </trans-unit>
        <trans-unit id="a0c9710a46fb772958369a0897c7471714aeeeb8" translate="yes" xml:space="preserve">
          <source>ToLowerSpecial returns a copy of the string s with all Unicode letters mapped to their lower case using the case mapping specified by c.</source>
          <target state="translated">ToLowerSpecial은 c로 지정된 대소 문자 매핑을 사용하여 모든 유니 코드 문자가 소문자로 매핑 된 문자열의 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cb046f134facad4d83f3df18153937dc0992ea81" translate="yes" xml:space="preserve">
          <source>ToLowerSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their lower case, giving priority to the special casing rules.</source>
          <target state="translated">ToLowerSpecial은 s를 UTF-8로 인코딩 된 바이트로 취급하고 특수한 케이싱 규칙에 우선 순위를두고 모든 유니 코드 문자가 소문자로 매핑 된 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="494e4ed4c22e6b9204664a8671089fb351d285ee" translate="yes" xml:space="preserve">
          <source>ToRDNSequence converts n into a single RDNSequence. The following attributes are encoded as multi-value RDNs:</source>
          <target state="translated">ToRDNSequence는 n을 단일 RDNSequence로 변환합니다. 다음 속성은 다중 값 RDN으로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="2915308ca78a335773afea42473f5f868e85f100" translate="yes" xml:space="preserve">
          <source>ToSlash returns the result of replacing each separator character in path with a slash ('/') character. Multiple separators are replaced by multiple slashes.</source>
          <target state="translated">ToSlash는 경로의 각 구분 문자를 슬래시 ( '/') 문자로 바꾼 결과를 반환합니다. 여러 구분 기호는 여러 슬래시로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="ce9610dd835f1269c70383a5f4c28b5a0b063015" translate="yes" xml:space="preserve">
          <source>ToText prepares comment text for presentation in textual output. It wraps paragraphs of text to width or fewer Unicode code points and then prefixes each line with the indent. In preformatted sections (such as program text), it prefixes each non-blank line with preIndent.</source>
          <target state="translated">ToText는 텍스트 출력으로 표시 할 주석 텍스트를 준비합니다. 텍스트의 단락을 너비 이하의 유니 코드 코드 포인트로 감싸고 각 줄 앞에 들여 쓰기를 붙입니다. 미리 형식이 지정된 섹션 (예 : 프로그램 텍스트)에서는 공백이 아닌 각 줄 앞에 preIndent가 붙습니다.</target>
        </trans-unit>
        <trans-unit id="687882b6dd58f630b4dc72d2b748bc2e5e517506" translate="yes" xml:space="preserve">
          <source>ToTitle</source>
          <target state="translated">ToTitle</target>
        </trans-unit>
        <trans-unit id="16626ca02836f3e96b71ac083f67d856672bee6a" translate="yes" xml:space="preserve">
          <source>ToTitle maps the rune to title case giving priority to the special mapping.</source>
          <target state="translated">ToTitle은 룬을 제목 케이스에 매핑하여 특수 매핑에 우선 순위를 둡니다.</target>
        </trans-unit>
        <trans-unit id="82652cb33ebff96d0745bbb70b7b14b2b4f648b7" translate="yes" xml:space="preserve">
          <source>ToTitle maps the rune to title case.</source>
          <target state="translated">ToTitle은 룬을 제목 케이스에 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="b6339ce57388ab9579ed7dea7397386892cd79b3" translate="yes" xml:space="preserve">
          <source>ToTitle returns a copy of the string s with all Unicode letters mapped to their Unicode title case.</source>
          <target state="translated">ToTitle은 모든 유니 코드 문자가 유니 코드 제목 케이스에 매핑 된 문자열 s를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7c8bdbfdcd905744bd6bd92b5f2c2fe7b0b2a605" translate="yes" xml:space="preserve">
          <source>ToTitle treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their title case.</source>
          <target state="translated">ToTitle은 s를 UTF-8로 인코딩 된 바이트로 취급하고 제목 케이스에 모든 유니 코드 문자가 매핑 된 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a7e031c3da9f939af57fa1eda658027190b07385" translate="yes" xml:space="preserve">
          <source>ToTitleSpecial</source>
          <target state="translated">ToTitleSpecial</target>
        </trans-unit>
        <trans-unit id="6c2252d5e081e10993ad66199a6ce0f9c88000da" translate="yes" xml:space="preserve">
          <source>ToTitleSpecial returns a copy of the string s with all Unicode letters mapped to their Unicode title case, giving priority to the special casing rules.</source>
          <target state="translated">ToTitleSpecial은 모든 유니 코드 문자가 유니 코드 제목 케이스에 매핑되어 특수한 케이싱 규칙에 우선 순위를 둔 문자열 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="03ad764cc2cf6e71773b140dd2607d85f903d19e" translate="yes" xml:space="preserve">
          <source>ToTitleSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their title case, giving priority to the special casing rules.</source>
          <target state="translated">ToTitleSpecial은 s를 UTF-8로 인코딩 된 바이트로 취급하고 제목 케이스에 매핑 된 모든 유니 코드 문자가있는 사본을 반환하여 특수한 케이싱 규칙에 우선 순위를 둡니다.</target>
        </trans-unit>
        <trans-unit id="0c72db5394ee29e5b12a191ab1a0f08579c43c0b" translate="yes" xml:space="preserve">
          <source>ToUpper</source>
          <target state="translated">ToUpper</target>
        </trans-unit>
        <trans-unit id="8830c3933f2751182fd45204e5ac41041c190ab0" translate="yes" xml:space="preserve">
          <source>ToUpper maps the rune to upper case giving priority to the special mapping.</source>
          <target state="translated">ToUpper는 룬을 대문자로 매핑하여 특수 매핑에 우선 순위를 둡니다.</target>
        </trans-unit>
        <trans-unit id="9762b6a1a0f8f68d12efc0853373d81b1198caf9" translate="yes" xml:space="preserve">
          <source>ToUpper maps the rune to upper case.</source>
          <target state="translated">ToUpper는 룬을 대문자로 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="587e23bede12f256b7a2b187d202dc77575c043c" translate="yes" xml:space="preserve">
          <source>ToUpper returns a copy of the byte slice s with all Unicode letters mapped to their upper case.</source>
          <target state="translated">ToUpper는 모든 유니 코드 문자가 대문자로 매핑 된 바이트 슬라이스의 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1567cbaa93e2803c0387b5e052b94febf77b0dce" translate="yes" xml:space="preserve">
          <source>ToUpper returns s with all Unicode letters mapped to their upper case.</source>
          <target state="translated">ToUpper는 모든 유니 코드 문자를 대문자로 매핑하여을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e8e18cf71c085c852139f777c3a777629eaba1d4" translate="yes" xml:space="preserve">
          <source>ToUpperSpecial</source>
          <target state="translated">ToUpperSpecial</target>
        </trans-unit>
        <trans-unit id="ca298ca7f1f797ffc04335283b821c4509371407" translate="yes" xml:space="preserve">
          <source>ToUpperSpecial returns a copy of the string s with all Unicode letters mapped to their upper case using the case mapping specified by c.</source>
          <target state="translated">ToUpperSpecial은 c로 지정된 대소 문자 매핑을 사용하여 모든 유니 코드 문자가 대문자로 매핑 된 문자열의 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e092426a213e149b750e5c739fd48245f35d6f1d" translate="yes" xml:space="preserve">
          <source>ToUpperSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their upper case, giving priority to the special casing rules.</source>
          <target state="translated">ToUpperSpecial은 s를 UTF-8로 인코딩 된 바이트로 취급하고 특수한 케이싱 규칙에 우선 순위를두고 모든 유니 코드 문자가 대문자로 매핑 된 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2918f3c11590ab69ac359dd26f3078e378d4433f" translate="yes" xml:space="preserve">
          <source>ToValidUTF8 returns a copy of the string s with each run of invalid UTF-8 byte sequences replaced by the replacement string, which may be empty.</source>
          <target state="translated">ToValidUTF8은 유효하지 않은 UTF-8 바이트 시퀀스의 각 실행이 대체 문자열로 바뀌고 비어있을 수있는 문자열의 사본을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="8ddb5599f330dcf8a14e657f65440d11567b1275" translate="yes" xml:space="preserve">
          <source>ToValidUTF8 treats s as UTF-8-encoded bytes and returns a copy with each run of bytes representing invalid UTF-8 replaced with the bytes in replacement, which may be empty.</source>
          <target state="translated">ToValidUTF8은 s를 UTF-8로 인코딩 된 바이트로 취급하고 유효하지 않은 UTF-8을 나타내는 각 바이트 실행이 대체 바이트로 대체 된 사본을 리턴합니다 (비어있을 수 있음).</target>
        </trans-unit>
        <trans-unit id="0e6e43d719b59d2f4b6d64b0d7506414e902ac66" translate="yes" xml:space="preserve">
          <source>Token expands self-closing elements such as &amp;lt;br/&amp;gt; into separate start and end elements returned by successive calls.</source>
          <target state="translated">토큰은 &amp;lt;br/&amp;gt;와 같은 자체 결산 요소를 연속적인 호출에 의해 반환되는 별도의 시작 및 끝 요소로 확장합니다.</target>
        </trans-unit>
        <trans-unit id="76c580b187cf47d391aca0669ed50d6bdc842bd1" translate="yes" xml:space="preserve">
          <source>Token guarantees that the StartElement and EndElement tokens it returns are properly nested and matched: if Token encounters an unexpected end element or EOF before all expected end elements, it will return an error.</source>
          <target state="translated">토큰은 반환하는 StartElement 및 EndElement 토큰이 올바로 중첩되고 일치하도록 보장합니다. 토큰에 예상치 못한 끝 요소 또는 EOF가 예상되는 끝 요소보다 먼저 발생하면 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="20226a10555b22d829b042743665e60ca5ccfcef" translate="yes" xml:space="preserve">
          <source>Token guarantees that the delimiters [ ] { } it returns are properly nested and matched: if Token encounters an unexpected delimiter in the input, it will return an error.</source>
          <target state="translated">토큰은 반환 된 분리 문자 [] {}가 올바르게 중첩되고 일치되도록 보장합니다. 토큰에 입력에서 예기치 않은 분리 문자가 발생하면 오류가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="d280a9431f5d23758a555c6128dd19caf82e90f5" translate="yes" xml:space="preserve">
          <source>Token implements XML name spaces as described by &lt;a href=&quot;https://www.w3.org/TR/REC-xml-names/&quot;&gt;https://www.w3.org/TR/REC-xml-names/&lt;/a&gt;. Each of the Name structures contained in the Token has the Space set to the URL identifying its name space when known. If Token encounters an unrecognized name space prefix, it uses the prefix as the Space rather than report an error.</source>
          <target state="translated">토큰은 &lt;a href=&quot;https://www.w3.org/TR/REC-xml-names/&quot;&gt;https://www.w3.org/TR/REC-xml-names/에&lt;/a&gt; 설명 된대로 XML 네임 스페이스를 구현합니다 . 토큰에 포함 된 각 이름 구조에는 이름 공간을 알 수있는 URL로 설정된 공간이 있습니다. 토큰이 인식 할 수없는 네임 스페이스 접 두부를 발견하면 오류를보고하지 않고 접 두부를 스페이스로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3daac00da8a20a3986aa0fc3ba367725df5511ad" translate="yes" xml:space="preserve">
          <source>Token is the set of lexical tokens of the Go programming language.</source>
          <target state="translated">토큰은 Go 프로그래밍 언어의 어휘 토큰 세트입니다.</target>
        </trans-unit>
        <trans-unit id="347b518b7ad14bbb5cbe2525a0e1cce83a18759e" translate="yes" xml:space="preserve">
          <source>Token returns the next JSON token in the input stream. At the end of the input stream, Token returns nil, io.EOF.</source>
          <target state="translated">토큰은 입력 스트림에서 다음 JSON 토큰을 반환합니다. 입력 스트림의 끝에서 토큰은 nil, io.EOF를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fb460c5b7cbda3e107ef11644b412428d80a074a" translate="yes" xml:space="preserve">
          <source>Token returns the next XML token in the input stream. At the end of the input stream, Token returns nil, io.EOF.</source>
          <target state="translated">토큰은 입력 스트림에서 다음 XML 토큰을 반환합니다. 입력 스트림의 끝에서 토큰은 nil, io.EOF를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1f5c5f661288844b6f2ecd574998016319ee9039" translate="yes" xml:space="preserve">
          <source>TokenString returns a printable string for a token or Unicode character.</source>
          <target state="translated">TokenString은 토큰 또는 유니 코드 문자에 대해 인쇄 가능한 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1a94c716310bd537564c947b302962f8f4ba3d71" translate="yes" xml:space="preserve">
          <source>TokenText returns the string corresponding to the most recently scanned token. Valid after calling Scan and in calls of Scanner.Error.</source>
          <target state="translated">TokenText는 가장 최근에 스캔 한 토큰에 해당하는 문자열을 반환합니다. Scan을 호출 한 후 스캐너를 호출 할 때 유효합니다.</target>
        </trans-unit>
        <trans-unit id="a7a728d87ab600f19a872de7d10dd426fc51a410" translate="yes" xml:space="preserve">
          <source>ToolDir is the directory containing build tools.</source>
          <target state="translated">ToolDir은 빌드 도구가 포함 된 디렉토리입니다.</target>
        </trans-unit>
        <trans-unit id="84f632ebde53766b4762c1e662046a0bdb1f9bee" translate="yes" xml:space="preserve">
          <source>Trace responds with the execution trace in binary form. Tracing lasts for duration specified in seconds GET parameter, or for 1 second if not specified. The package initialization registers it as /debug/pprof/trace.</source>
          <target state="translated">추적은 실행 추적에 이진 형식으로 응답합니다. 추적은 GET 매개 변수 (초)로 지정된 지속 시간 동안, 또는 지정되지 않은 경우 1 초 동안 지속됩니다. 패키지 초기화는 패키지를 / debug / pprof / trace로 등록합니다.</target>
        </trans-unit>
        <trans-unit id="37fcf61c233a1ae946b84a69b2de57281c31900c" translate="yes" xml:space="preserve">
          <source>Tracing runtime activities</source>
          <target state="translated">런타임 활동 추적</target>
        </trans-unit>
        <trans-unit id="bf930f74e883c038922957814259a08b1e5e21b8" translate="yes" xml:space="preserve">
          <source>TrailerPrefix is a magic prefix for ResponseWriter.Header map keys that, if present, signals that the map entry is actually for the response trailers, and not the response headers. The prefix is stripped after the ServeHTTP call finishes and the values are sent in the trailers.</source>
          <target state="translated">TrailerPrefix는 ResponseWriter의 마술 접두사입니다. 헤더 맵 키 (있는 경우)는 맵 항목이 실제로 응답 트레일러가 아니라 응답 헤더 용임을 나타내는 신호입니다. ServeHTTP 호출이 완료된 후 접두어가 제거되고 값이 트레일러로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="d08af63de6fd07c70bf3724749899391ccd80f36" translate="yes" xml:space="preserve">
          <source>TrailingZeroBits returns the number of consecutive least significant zero bits of |x|.</source>
          <target state="translated">TrailingZeroBits는 | x |의 연속 최하위 0 비트 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="173da913d8c53620762557efaa7f685234fe0888" translate="yes" xml:space="preserve">
          <source>TrailingZeros returns the number of trailing zero bits in x; the result is UintSize for x == 0.</source>
          <target state="translated">TrailingZeros는 x의 후행 0 비트 수를 반환합니다. 결과는 x == 0에 대한 UintSize입니다.</target>
        </trans-unit>
        <trans-unit id="3880be13b458ed7d8fd6226152f09a84df60affe" translate="yes" xml:space="preserve">
          <source>TrailingZeros16</source>
          <target state="translated">TrailingZeros16</target>
        </trans-unit>
        <trans-unit id="ac0e8b17c92ec54246a916c7c60a5898e47d2440" translate="yes" xml:space="preserve">
          <source>TrailingZeros16 returns the number of trailing zero bits in x; the result is 16 for x == 0.</source>
          <target state="translated">TrailingZeros16은 x의 후행 0 비트 수를 반환합니다. x == 0의 경우 결과는 16입니다.</target>
        </trans-unit>
        <trans-unit id="9ccb48d1009c49f2458e70054ffb06de2c2e52b1" translate="yes" xml:space="preserve">
          <source>TrailingZeros32</source>
          <target state="translated">TrailingZeros32</target>
        </trans-unit>
        <trans-unit id="ef12b2bd72258ab1ea24487faaf1b36b6624d53b" translate="yes" xml:space="preserve">
          <source>TrailingZeros32 returns the number of trailing zero bits in x; the result is 32 for x == 0.</source>
          <target state="translated">TrailingZeros32는 x의 후행 0 비트 수를 반환합니다. x == 0의 경우 결과는 32입니다.</target>
        </trans-unit>
        <trans-unit id="8645dda5fc4ccfbadfe816f019759dd903a6b384" translate="yes" xml:space="preserve">
          <source>TrailingZeros64</source>
          <target state="translated">TrailingZeros64</target>
        </trans-unit>
        <trans-unit id="9c1806ac56295eeda1305a5c016e361813241700" translate="yes" xml:space="preserve">
          <source>TrailingZeros64 returns the number of trailing zero bits in x; the result is 64 for x == 0.</source>
          <target state="translated">TrailingZeros64는 x의 후행 0 비트 수를 반환합니다. x == 0의 경우 결과는 64입니다.</target>
        </trans-unit>
        <trans-unit id="56b19e298a41e007826d31fb347a4fad087efb44" translate="yes" xml:space="preserve">
          <source>TrailingZeros8</source>
          <target state="translated">TrailingZeros8</target>
        </trans-unit>
        <trans-unit id="a51f3a70d56ba40f5381588670a32ee940f76014" translate="yes" xml:space="preserve">
          <source>TrailingZeros8 returns the number of trailing zero bits in x; the result is 8 for x == 0.</source>
          <target state="translated">TrailingZeros8은 x의 후행 0 비트 수를 반환합니다. x == 0의 경우 결과는 8입니다.</target>
        </trans-unit>
        <trans-unit id="c46e526f87b0902843d5c82001fbd44e74d2f2d7" translate="yes" xml:space="preserve">
          <source>Transport is an implementation of RoundTripper that supports HTTP, HTTPS, and HTTP proxies (for either HTTP or HTTPS with CONNECT).</source>
          <target state="translated">전송은 HTTP, HTTPS 및 HTTP 프록시 (CONNECT를 사용하는 HTTP 또는 HTTPS)를 지원하는 RoundTripper의 구현입니다.</target>
        </trans-unit>
        <trans-unit id="28030ddb48df392e29b838aa75a73353cb5390cf" translate="yes" xml:space="preserve">
          <source>Transport only retries a request upon encountering a network error if the request is idempotent and either has no body or has its Request.GetBody defined. HTTP requests are considered idempotent if they have HTTP methods GET, HEAD, OPTIONS, or TRACE; or if their Header map contains an &quot;Idempotency-Key&quot; or &quot;X-Idempotency-Key&quot; entry. If the idempotency key value is a zero-length slice, the request is treated as idempotent but the header is not sent on the wire.</source>
          <target state="translated">Transport는 요청이 멱 등성이고 본문이 없거나 Request.GetBody가 정의 된 경우 네트워크 오류가 발생한 경우에만 요청을 재 시도합니다. HTTP 요청은 HTTP 메소드 GET, HEAD, OPTIONS 또는 TRACE가있는 경우 멱등으로 간주됩니다. 또는 헤더 맵에 &quot;Idempotency-Key&quot;또는 &quot;X-Idempotency-Key&quot;항목이 포함되어있는 경우. 멱 등성 키 값이 길이가 0 인 슬라이스 인 경우 요청은 멱 등성으로 처리되지만 헤더는 유선으로 전송되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3a7dd5c9993ccdafc8353b9b9fef9d118c35957f" translate="yes" xml:space="preserve">
          <source>Transport only retries a request upon encountering a network error if the request is idempotent and either has no body or has its Request.GetBody defined. HTTP requests are considered idempotent if they have HTTP methods GET, HEAD, OPTIONS, or TRACE; or if their Header map contains an &quot;Idempotency-Key&quot; or &quot;X-Idempotency-Key&quot; entry. If the idempotency key value is an zero-length slice, the request is treated as idempotent but the header is not sent on the wire.</source>
          <target state="translated">전송은 요청이 and 등원이고 본문이 없거나 Request.GetBody가 정의 된 경우 네트워크 오류가 발생하면 요청을 재 시도합니다. HTTP 요청에 HTTP 메소드 GET, HEAD, OPTIONS 또는 TRACE가있는 경우 HTTP 요청은 dem 등원으로 간주됩니다. 또는 헤더 맵에 &quot;Idempotency-Key&quot;또는 &quot;X-Idempotency-Key&quot;항목이 포함 된 경우 dem 등원 키 값이 길이가 0 인 슬라이스 인 경우 요청은 dem 등원으로 취급되지만 헤더는 유선으로 전송되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a83654a5778fc158c90c291f8461263d34090fc9" translate="yes" xml:space="preserve">
          <source>Transport uses HTTP/1.1 for HTTP URLs and either HTTP/1.1 or HTTP/2 for HTTPS URLs, depending on whether the server supports HTTP/2, and how the Transport is configured. The DefaultTransport supports HTTP/2. To explicitly enable HTTP/2 on a transport, use golang.org/x/net/http2 and call ConfigureTransport. See the package docs for more about HTTP/2.</source>
          <target state="translated">전송은 서버가 HTTP / 2를 지원하는지 여부와 전송 구성 방법에 따라 HTTP URL에 HTTP / 1.1을 사용하고 HTTPS URL에 HTTP / 1.1 또는 HTTP / 2를 사용합니다. DefaultTransport는 HTTP / 2를 지원합니다. 전송에서 HTTP / 2를 명시 적으로 사용 가능하게하려면 golang.org/x/net/http2를 사용하고 ConfigureTransport를 호출하십시오. HTTP / 2에 대한 자세한 내용은 패키지 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5cba3ebebe9967d6b406fbd61cc05ffea9ddcf56" translate="yes" xml:space="preserve">
          <source>Transports should be reused instead of created as needed. Transports are safe for concurrent use by multiple goroutines.</source>
          <target state="translated">필요에 따라 전송을 작성하는 대신 전송을 재사용해야합니다. 여러 고 루틴이 동시에 사용하기에 안전합니다.</target>
        </trans-unit>
        <trans-unit id="cf5547182a53dd7a581affea62258ee59e262b85" translate="yes" xml:space="preserve">
          <source>Tree is the representation of a single parsed template.</source>
          <target state="translated">트리는 단일 구문 분석 된 템플리트를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0266abd25371ad4670b041dda4dc487ed199d641" translate="yes" xml:space="preserve">
          <source>Trim</source>
          <target state="translated">Trim</target>
        </trans-unit>
        <trans-unit id="abb910d5bd0bd319cf1d5ef7ad6a5112dc6c0823" translate="yes" xml:space="preserve">
          <source>Trim returns a slice of the string s with all leading and trailing Unicode code points contained in cutset removed.</source>
          <target state="translated">트림은 컷셋에 포함 된 모든 선행 및 후행 유니 코드 코드 포인트가 제거 된 문자열 조각을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4f07669cc579ec14df811b3ca5fc72fde4f78f58" translate="yes" xml:space="preserve">
          <source>Trim returns a subslice of s by slicing off all leading and trailing UTF-8-encoded code points contained in cutset.</source>
          <target state="translated">Trim은 cutset에 포함 된 모든 선행 및 후행 UTF-8 인코딩 코드 포인트를 슬라이스하여 s의 하위 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ba1962dfeb4e006658709dd72ff841213f7d1db0" translate="yes" xml:space="preserve">
          <source>TrimBytes returns b without leading and trailing ASCII space.</source>
          <target state="translated">TrimBytes는 선행 및 후행 ASCII 공간없이 b를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a48987784fdcef3e797c48099ede26a7260db2de" translate="yes" xml:space="preserve">
          <source>TrimFunc</source>
          <target state="translated">TrimFunc</target>
        </trans-unit>
        <trans-unit id="03343404f4f9dd2a23fda87bf2a4805f3806059d" translate="yes" xml:space="preserve">
          <source>TrimFunc returns a slice of the string s with all leading and trailing Unicode code points c satisfying f(c) removed.</source>
          <target state="translated">TrimFunc는 f (c)를 만족하는 모든 선행 및 후행 유니 코드 코드 포인트 c가 제거 된 문자열 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="625b4a484772db3f9992725f710f3d189c47d0db" translate="yes" xml:space="preserve">
          <source>TrimFunc returns a subslice of s by slicing off all leading and trailing UTF-8-encoded code points c that satisfy f(c).</source>
          <target state="translated">TrimFunc는 f (c)를 만족하는 모든 선행 및 후행 UTF-8 인코딩 코드 포인트 c를 슬라이스하여 s의 하위 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b796ff265d1cc90c9b78c76a3f12dd8cbff027a6" translate="yes" xml:space="preserve">
          <source>TrimLeft</source>
          <target state="translated">TrimLeft</target>
        </trans-unit>
        <trans-unit id="3406f99b35b8781b2e30c5d4f1fb92b18ccfb0a0" translate="yes" xml:space="preserve">
          <source>TrimLeft returns a slice of the string s with all leading Unicode code points contained in cutset removed.</source>
          <target state="translated">TrimLeft는 컷셋에 포함 된 모든 선행 유니 코드 코드 포인트가 제거 된 문자열 조각을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b52b880dc01fa22cd46ff385a39b5609f426247b" translate="yes" xml:space="preserve">
          <source>TrimLeft returns a subslice of s by slicing off all leading UTF-8-encoded code points contained in cutset.</source>
          <target state="translated">TrimLeft는 cutset에 포함 된 모든 선행 UTF-8 인코딩 코드 포인트를 슬라이스하여 s의 하위 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0dda8e3188c1b3df6f3a5c77e5010dd280c96425" translate="yes" xml:space="preserve">
          <source>TrimLeftFunc</source>
          <target state="translated">TrimLeftFunc</target>
        </trans-unit>
        <trans-unit id="2a771ac81b0579d70a2a4390b741d5fed266d711" translate="yes" xml:space="preserve">
          <source>TrimLeftFunc returns a slice of the string s with all leading Unicode code points c satisfying f(c) removed.</source>
          <target state="translated">TrimLeftFunc는 f (c)를 만족하는 모든 선행 유니 코드 코드 포인트 c가 제거 된 문자열 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="49c15e330f226f8800b406f97802237df2f3f947" translate="yes" xml:space="preserve">
          <source>TrimLeftFunc treats s as UTF-8-encoded bytes and returns a subslice of s by slicing off all leading UTF-8-encoded code points c that satisfy f(c).</source>
          <target state="translated">TrimLeftFunc는 s를 UTF-8 인코딩 된 바이트로 취급하고 f (c)를 만족하는 모든 선행 UTF-8 인코딩 된 코드 포인트 c를 슬라이스하여 s의 하위 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f6781400f56acf5b8bc035e02b3cdac08b09ae64" translate="yes" xml:space="preserve">
          <source>TrimPrefix</source>
          <target state="translated">TrimPrefix</target>
        </trans-unit>
        <trans-unit id="0cdb8742fe0e8f96e729ab0932195bcd75f8a8b2" translate="yes" xml:space="preserve">
          <source>TrimPrefix returns s without the provided leading prefix string. If s doesn't start with prefix, s is returned unchanged.</source>
          <target state="translated">TrimPrefix는 제공된 선행 접두사 문자열없이 s를 반환합니다. s가 접두사로 시작하지 않으면 s가 변경되지 않은 상태로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3a3dc250671844d052f305fc24e91daa5dfaf78b" translate="yes" xml:space="preserve">
          <source>TrimRight</source>
          <target state="translated">TrimRight</target>
        </trans-unit>
        <trans-unit id="f36ec5b5c4656d60b56116c5bdb688d629f84c86" translate="yes" xml:space="preserve">
          <source>TrimRight returns a slice of the string s, with all trailing Unicode code points contained in cutset removed.</source>
          <target state="translated">TrimRight는 컷셋에 포함 된 모든 후행 유니 코드 코드 포인트가 제거 된 문자열 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3ca08db3862d11ac280fa859c98a5062cca7758f" translate="yes" xml:space="preserve">
          <source>TrimRight returns a subslice of s by slicing off all trailing UTF-8-encoded code points that are contained in cutset.</source>
          <target state="translated">TrimRight는 컷셋에 포함 된 모든 후행 UTF-8 인코딩 코드 포인트를 슬라이스하여 s의 하위 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2face4904f1360f377438b017515ff3c2359f581" translate="yes" xml:space="preserve">
          <source>TrimRightFunc</source>
          <target state="translated">TrimRightFunc</target>
        </trans-unit>
        <trans-unit id="91f9e348fa7e18e840cf0ac3e8dc3a6295b78762" translate="yes" xml:space="preserve">
          <source>TrimRightFunc returns a slice of the string s with all trailing Unicode code points c satisfying f(c) removed.</source>
          <target state="translated">TrimRightFunc는 f (c)를 만족하는 모든 후행 유니 코드 코드 포인트 c가 제거 된 문자열 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="af58ad241c06498d7e5d96dabf6a334e19cb450d" translate="yes" xml:space="preserve">
          <source>TrimRightFunc returns a subslice of s by slicing off all trailing UTF-8-encoded code points c that satisfy f(c).</source>
          <target state="translated">TrimRightFunc는 f (c)를 만족하는 모든 후행 UTF-8 인코딩 코드 포인트 c를 슬라이스하여 s의 하위 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3b9759ef917cd034e3fff66af6781ac1144ddf76" translate="yes" xml:space="preserve">
          <source>TrimSpace</source>
          <target state="translated">TrimSpace</target>
        </trans-unit>
        <trans-unit id="fb7131e90264c0cc3ce43bd31575b4282b5313c8" translate="yes" xml:space="preserve">
          <source>TrimSpace returns a slice of the string s, with all leading and trailing white space removed, as defined by Unicode.</source>
          <target state="translated">TrimSpace는 유니 코드로 정의 된대로 모든 선행 및 후행 공백이 제거 된 문자열 조각을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a187e5cf0dba2afc1b0487c662e640873854f7ec" translate="yes" xml:space="preserve">
          <source>TrimSpace returns a subslice of s by slicing off all leading and trailing white space, as defined by Unicode.</source>
          <target state="translated">TrimSpace는 유니 코드로 정의 된대로 모든 선행 및 후행 공백을 슬라이스하여 s의 하위 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b11fe2b91f56619862961192ca92d40d14d67c9d" translate="yes" xml:space="preserve">
          <source>TrimString returns s without leading and trailing ASCII space.</source>
          <target state="translated">TrimString은 선행 및 후행 ASCII 공간없이 s를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="31564f1b1fc10c6dcf98b0ba8f0d174cf833e697" translate="yes" xml:space="preserve">
          <source>TrimSuffix</source>
          <target state="translated">TrimSuffix</target>
        </trans-unit>
        <trans-unit id="92a8263afbc0fa4c5341e4098b039907219bbb45" translate="yes" xml:space="preserve">
          <source>TrimSuffix returns s without the provided trailing suffix string. If s doesn't end with suffix, s is returned unchanged.</source>
          <target state="translated">TrimSuffix는 제공된 후행 접미사 문자열없이 s를 리턴합니다. s가 접미사로 끝나지 않으면 s는 변경되지 않고 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="0b8272d0bb8c9199c72411e406f2643a93b7ccca" translate="yes" xml:space="preserve">
          <source>Trunc</source>
          <target state="translated">Trunc</target>
        </trans-unit>
        <trans-unit id="4ac265259166695b742658a267b27c17c43d2d87" translate="yes" xml:space="preserve">
          <source>Trunc returns the integer value of x.</source>
          <target state="translated">Trunc는 x의 정수 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a6f2f1d850d6a1bef2ab8b526d322b73779287f1" translate="yes" xml:space="preserve">
          <source>Truncate changes the size of the file. It does not change the I/O offset. If there is an error, it will be of type *PathError.</source>
          <target state="translated">자르기는 파일 크기를 변경합니다. I / O 오프셋은 변경되지 않습니다. 오류가 있으면 * PathError 유형입니다.</target>
        </trans-unit>
        <trans-unit id="062334176014417d736c93d4f00898bc3b617151" translate="yes" xml:space="preserve">
          <source>Truncate changes the size of the named file. If the file is a symbolic link, it changes the size of the link's target. If there is an error, it will be of type *PathError.</source>
          <target state="translated">잘라내 기는 명명 된 파일의 크기를 변경합니다. 파일이 심볼릭 링크 인 경우 링크 대상의 크기가 변경됩니다. 오류가 있으면 * PathError 유형입니다.</target>
        </trans-unit>
        <trans-unit id="e8c4ef35e7ba4d40ba29121e1bd589ff3e80bcb3" translate="yes" xml:space="preserve">
          <source>Truncate discards all but the first n unread bytes from the buffer but continues to use the same allocated storage. It panics if n is negative or greater than the length of the buffer.</source>
          <target state="translated">잘림은 버퍼에서 처음 n 개의 읽지 않은 바이트를 제외한 모든 메모리를 삭제하지만 동일한 할당 된 스토리지를 계속 사용합니다. n이 음수이거나 버퍼 길이보다 길면 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="32beb0b08a1549453f279d1334d844a2afaea49a" translate="yes" xml:space="preserve">
          <source>Truncate operates on the time as an absolute duration since the zero time; it does not operate on the presentation form of the time. Thus, Truncate(Hour) may return a time with a non-zero minute, depending on the time's Location.</source>
          <target state="translated">잘라내 기는 0 시간 이후의 절대 지속 시간으로 시간에 작동합니다. 시간의 프리젠 테이션 형식에서는 작동하지 않습니다. 따라서 Truncate (Hour)는 시간의 위치에 따라 0이 아닌 분으로 시간을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="71998d5a06a6fc24a70aad616e3e9f7ea3e57939" translate="yes" xml:space="preserve">
          <source>Truncate returns the result of rounding d toward zero to a multiple of m. If m &amp;lt;= 0, Truncate returns d unchanged.</source>
          <target state="translated">자르기 d를 0으로 반올림 한 결과를 m의 배수로 반환합니다. m &amp;lt;= 0이면 Truncate는 변경되지 않은 d를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="498fecdf2960f4ea8c81a3634a3c6208f18d44bd" translate="yes" xml:space="preserve">
          <source>Truncate returns the result of rounding t down to a multiple of d (since the zero time). If d &amp;lt;= 0, Truncate returns t stripped of any monotonic clock reading but otherwise unchanged.</source>
          <target state="translated">잘라내 기는 t를 d의 배수로 내림 한 결과를 리턴합니다 (제로 시간 이후). d &amp;lt;= 0 인 경우 Truncate는 단조로운 클럭 판독 값에서 t를 제거하지만 변경하지 않은 경우 t를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7a922bb8e2913cab6dcad5ba9140345fb42fa502" translate="yes" xml:space="preserve">
          <source>TruncateWriter returns a Writer that writes to w but stops silently after n bytes.</source>
          <target state="translated">TruncateWriter는 w에 쓰지만 n 바이트 후에 자동으로 중지되는 Writer를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="66617c3163f43664fa6ddb9c95a7d88a932b782b" translate="yes" xml:space="preserve">
          <source>Truthy returns the JavaScript &quot;truthiness&quot; of the value v. In JavaScript, false, 0, &quot;&quot;, null, undefined, and NaN are &quot;falsy&quot;, and everything else is &quot;truthy&quot;. See &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Truthy&quot;&gt;https://developer.mozilla.org/en-US/docs/Glossary/Truthy&lt;/a&gt;.</source>
          <target state="translated">Truthy는 값 v의 JavaScript &quot;진실성&quot;을 반환합니다. JavaScript에서 false, 0, &quot;&quot;, null, undefined 및 NaN은 &quot;거짓&quot;이고 다른 모든 것은 &quot;거짓&quot;입니다. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Truthy&quot;&gt;https://developer.mozilla.org/en-US/docs/Glossary/Truthy를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="c26728b3acc2b9a34150900b5536db30082f4043" translate="yes" xml:space="preserve">
          <source>TryRecv attempts to receive a value from the channel v but will not block. It panics if v's Kind is not Chan. If the receive delivers a value, x is the transferred value and ok is true. If the receive cannot finish without blocking, x is the zero Value and ok is false. If the channel is closed, x is the zero value for the channel's element type and ok is false.</source>
          <target state="translated">TryRecv는 채널 v에서 값을 받으려고 시도하지만 차단하지는 않습니다. v 's Kind가 Chan이 아니면 패닉 상태입니다. 수신이 값을 전달하면 x는 전송 된 값이고 ok는 true입니다. 수신이 차단없이 완료 될 수 없으면 x는 0 값이고 ok는 false입니다. 채널이 닫히면 x는 채널 요소 유형의 0 값이고 ok는 false입니다.</target>
        </trans-unit>
        <trans-unit id="febc1b0170a31256a4ba31c38646abd1c14c7afb" translate="yes" xml:space="preserve">
          <source>TrySend attempts to send x on the channel v but will not block. It panics if v's Kind is not Chan. It reports whether the value was sent. As in Go, x's value must be assignable to the channel's element type.</source>
          <target state="translated">TrySend는 채널 v에서 x를 보내려고하지만 차단하지는 않습니다. v 's Kind가 Chan이 아니면 패닉 상태입니다. 값이 전송되었는지 여부를보고합니다. Go에서와 같이 x의 값은 채널의 요소 유형에 지정 가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="7fd5a63a31a17c2aa8f2b5b0d5183f5173b04681" translate="yes" xml:space="preserve">
          <source>Two keys are only considered to have the same value if they have the same Curve value. Note that for example elliptic.P256() and elliptic.P256().Params() are different values, as the latter is a generic not constant time implementation.</source>
          <target state="translated">두 개의 키는 곡선 값이 같은 경우에만 같은 값을 갖는 것으로 간주됩니다. 예를 들어 elliptic.P256 () 및 elliptic.P256 (). Params ()는 다른 값입니다. 후자는 일반적이지 않은 일반 시간 구현이기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="ad904f452afce8318d85fd92e9c6e068ca4fed6e" translate="yes" xml:space="preserve">
          <source>Two sets of interfaces are included in this package. When a more abstract interface isn't necessary, there are functions for encrypting/decrypting with v1.5/OAEP and signing/verifying with v1.5/PSS. If one needs to abstract over the public key primitive, the PrivateKey type implements the Decrypter and Signer interfaces from the crypto package.</source>
          <target state="translated">이 패키지에는 두 세트의 인터페이스가 포함되어 있습니다. 좀 더 추상적 인 인터페이스가 필요하지 않은 경우 v1.5 / OAEP로 암호화 / 복호화하고 v1.5 / PSS로 서명 / 확인하는 기능이 있습니다. 공개 키 프리미티브를 추상화해야하는 경우 PrivateKey 유형은 암호화 패키지에서 Decrypter 및 Signer 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="042f2d498c44806f60201f1f05491910d5c73fe8" translate="yes" xml:space="preserve">
          <source>Two sets of interfaces are included in this package. When a more abstract interface isn't necessary, there are functions for encrypting/decrypting with v1.5/OAEP and signing/verifying with v1.5/PSS. If one needs to abstract over the public-key primitive, the PrivateKey struct implements the Decrypter and Signer interfaces from the crypto package.</source>
          <target state="translated">이 패키지에는 2 개의 인터페이스 세트가 포함되어 있습니다. 보다 추상적 인 인터페이스가 필요하지 않은 경우 v1.5 / OAEP로 암호화 / 복호화하고 v1.5 / PSS로 서명 / 확인하는 기능이 있습니다. 공개 키 프리미티브를 추상화해야 할 경우 PrivateKey 구조체는 암호화 패키지에서 Decrypter 및 Signer 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="021677bbd9ee4b61e5a1312cf21d452a27661c48" translate="yes" xml:space="preserve">
          <source>Tx is a transaction.</source>
          <target state="translated">Tx는 거래입니다.</target>
        </trans-unit>
        <trans-unit id="02cdcf0d841ea4d5e8abf2653c842d138120149a" translate="yes" xml:space="preserve">
          <source>Tx is an in-progress database transaction.</source>
          <target state="translated">Tx는 진행중인 데이터베이스 트랜잭션입니다.</target>
        </trans-unit>
        <trans-unit id="41b6053676814b4fe97b2c9be9a306ee614bfa3d" translate="yes" xml:space="preserve">
          <source>Tx.ExecContext</source>
          <target state="translated">Tx.ExecContext</target>
        </trans-unit>
        <trans-unit id="2825856698e10e430365413d889b83a20654a02a" translate="yes" xml:space="preserve">
          <source>Tx.Prepare</source>
          <target state="translated">Tx.Prepare</target>
        </trans-unit>
        <trans-unit id="ef76ba4edb63dbd2cd7bf54f9037e276e1229e5a" translate="yes" xml:space="preserve">
          <source>Tx.Rollback</source>
          <target state="translated">Tx.Rollback</target>
        </trans-unit>
        <trans-unit id="a83fe983647bcf7e1590d7bef39b1b437680667a" translate="yes" xml:space="preserve">
          <source>TxOptions holds the transaction options to be used in DB.BeginTx.</source>
          <target state="translated">TxOptions에는 DB.BeginTx에서 사용할 트랜잭션 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="46eaf072cf758f74571ec8685b65883630652645" translate="yes" xml:space="preserve">
          <source>TxOptions holds the transaction options.</source>
          <target state="translated">TxOptions는 트랜잭션 옵션을 보유합니다.</target>
        </trans-unit>
        <trans-unit id="68e7b01d33d203d9281e2f2dd8f3398104376276" translate="yes" xml:space="preserve">
          <source>Typ contains the predeclared *Basic types indexed by their corresponding BasicKind.</source>
          <target state="translated">Typ에는 해당 BasicKind에 의해 색인 된 사전 선언 된 * 기본 유형이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="64f24b17ea9baa36a77dc3d1afdc32b1a420fb9e" translate="yes" xml:space="preserve">
          <source>Type flags for Header.Typeflag.</source>
          <target state="translated">Header.Typeflag에 대한 유형 플래그.</target>
        </trans-unit>
        <trans-unit id="04ccb52737e3e40430c97b234b8f24e390173f8b" translate="yes" xml:space="preserve">
          <source>Type inference computes the type (Type) of every expression (ast.Expr) and checks for compliance with the language specification. Use Info.Types[expr].Type for the results of type inference.</source>
          <target state="translated">형식 유추는 모든 식 (ast.Expr)의 형식 (Type)을 계산하고 언어 사양을 준수하는지 확인합니다. 형식 유추의 결과에 Info.Types [expr] .Type을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8035b14525c84dd4e5349419c0ff657e153c1c32" translate="yes" xml:space="preserve">
          <source>Type is found in Header.Type.</source>
          <target state="translated">형식은 Header.Type에 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec7bc4958b2c43e87f98f2ef7e1adb5d065d5c5e" translate="yes" xml:space="preserve">
          <source>Type is here for the purposes of documentation only. It is a stand-in for any Go type, but represents the same type for any given function invocation.</source>
          <target state="translated">유형은 문서 목적으로 만 사용됩니다. 모든 Go 유형에 대한 스탠드 인이지만 주어진 함수 호출에 대해 동일한 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="233ac19906546712346f536e7ee3880b82162310" translate="yes" xml:space="preserve">
          <source>Type is the documentation for a type declaration.</source>
          <target state="translated">Type은 형식 선언에 대한 설명서입니다.</target>
        </trans-unit>
        <trans-unit id="d3c0b263d515209e36ac606a05719bce899addba" translate="yes" xml:space="preserve">
          <source>Type is the representation of a Go type.</source>
          <target state="translated">유형은 Go 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c3bca7d619ddc3b0ec61fb8f295216cb63f22eb4" translate="yes" xml:space="preserve">
          <source>Type reads the type at off in the DWARF &amp;ldquo;info&amp;rdquo; section.</source>
          <target state="translated">유형은 DWARF &quot;정보&quot;섹션에서 유형을 끕니다.</target>
        </trans-unit>
        <trans-unit id="1fce0b09390d2c3838db788c0cf76f63a5bf80a9" translate="yes" xml:space="preserve">
          <source>Type represents the JavaScript type of a Value.</source>
          <target state="translated">Type은 Value의 JavaScript 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e06c5701673348f2eed499aa753a2ba395d1a12d" translate="yes" xml:space="preserve">
          <source>Type returns itself and provides an easy default implementation for embedding in a Node. Embedded in all non-trivial Nodes.</source>
          <target state="translated">유형 자체를 반환하고 노드에 포함하기위한 쉬운 기본 구현을 제공합니다. 모든 사소한 노드에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="4726645469f41dd7bcb1d47132c78e582530c7e1" translate="yes" xml:space="preserve">
          <source>Type returns the JavaScript type of the value v. It is similar to JavaScript's typeof operator, except that it returns TypeNull instead of TypeObject for null.</source>
          <target state="translated">Type은 값 v의 JavaScript 유형을 반환합니다. JavaScript의 typeof 연산자와 비슷하지만 null에 대해 TypeObject 대신 TypeNull을 반환한다는 점이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="2fa9db8cb436bbb192eec5d03d6240277e6eeffd" translate="yes" xml:space="preserve">
          <source>Type returns the object's type.</source>
          <target state="translated">Type은 객체의 유형을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d1407fc8c8322906d1372dd8a45dc51e6205559f" translate="yes" xml:space="preserve">
          <source>Type returns the type of x.f, which may be different from the type of f. See Selection for more information.</source>
          <target state="translated">Type은 xf의 유형을 반환하며 f의 유형과 다를 수 있습니다. 자세한 내용은 선택을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="372fc3db84eb7f93272dcba175262aaab1565f30" translate="yes" xml:space="preserve">
          <source>Type returns v's type.</source>
          <target state="translated">타입은 v 타입을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="55dbc1b43ee6cb3b1548172b193bc2a7d3e5eca5" translate="yes" xml:space="preserve">
          <source>Type values are comparable, such as with the == operator, so they can be used as map keys. Two Type values are equal if they represent identical types.</source>
          <target state="translated">== 연산자와 같은 유형 값은 비교 가능하므로 맵 키로 사용할 수 있습니다. 두 유형 값이 동일한 유형을 나타내는 경우 동일합니다.</target>
        </trans-unit>
        <trans-unit id="7bdac7349f75285c99f4a03ea2e2de6365f45c2a" translate="yes" xml:space="preserve">
          <source>Type-checking consists of several interdependent phases:</source>
          <target state="translated">유형 검사는 여러 개의 상호 의존적 인 단계로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="26984be5e6e3b06475f717ab4d76ce6f4ff88c54" translate="yes" xml:space="preserve">
          <source>Type1 is here for the purposes of documentation only. It is a stand-in for any Go type, but represents the same type for any given function invocation.</source>
          <target state="translated">Type1은 설명서 목적으로 만 사용됩니다. 모든 Go 유형에 대한 스탠드 인이지만 주어진 함수 호출에 대해 동일한 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7ace60c9c3dbd05ce39ba29e759c6ad4a52088eb" translate="yes" xml:space="preserve">
          <source>TypeAndValue reports the type and value (for constants) of the corresponding expression.</source>
          <target state="translated">TypeAndValue는 해당 표현식의 유형과 값 (상수의 경우)을보고합니다.</target>
        </trans-unit>
        <trans-unit id="2bc75a2b4beae4c84f906bb525769e97f38f0823" translate="yes" xml:space="preserve">
          <source>TypeByExtension returns the MIME type associated with the file extension ext. The extension ext should begin with a leading dot, as in &quot;.html&quot;. When ext has no associated type, TypeByExtension returns &quot;&quot;.</source>
          <target state="translated">TypeByExtension은 파일 확장자 ext와 연관된 MIME 유형을 반환합니다. 확장자 ext는 &quot;.html&quot;과 같이 선행 점으로 시작해야합니다. ext에 연결된 유형이 없으면 TypeByExtension은 &quot;&quot;를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="263318bcaf840ab395175e373b1ab05080a86fda" translate="yes" xml:space="preserve">
          <source>TypeOf</source>
          <target state="translated">TypeOf</target>
        </trans-unit>
        <trans-unit id="94969a4aec167529cd20467de358b3733a4d1890" translate="yes" xml:space="preserve">
          <source>TypeOf returns the reflection Type that represents the dynamic type of i. If i is a nil interface value, TypeOf returns nil.</source>
          <target state="translated">TypeOf는 i의 동적 유형을 나타내는 반사 유형을 반환합니다. i가 nil 인터페이스 값인 경우 TypeOf는 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="610b14205855f95702d99da6e19e5297b1301163" translate="yes" xml:space="preserve">
          <source>TypeOf returns the type of expression e, or nil if not found. Precondition: the Types, Uses and Defs maps are populated.</source>
          <target state="translated">TypeOf는 식 e의 유형을 반환하거나 찾지 못하면 nil을 반환합니다. 전제 조건 : 유형, 용도 및 정의 맵이 채워집니다.</target>
        </trans-unit>
        <trans-unit id="af91dac9977c975dbcb45d1e0c495727ba389f89" translate="yes" xml:space="preserve">
          <source>TypeString returns the string representation of typ. The Qualifier controls the printing of package-level objects, and may be nil.</source>
          <target state="translated">TypeString은 typ의 문자열 표현을 반환합니다. 한정자는 패키지 수준 개체의 인쇄를 제어하며 nil 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70c0f61c1717bc58a510efe98bd7a3251bcbbcc7" translate="yes" xml:space="preserve">
          <source>Typed Strings</source>
          <target state="translated">입력 된 문자열</target>
        </trans-unit>
        <trans-unit id="802976d08e8f16b7d83d8d12b5129fe9e25c37e3" translate="yes" xml:space="preserve">
          <source>Types HTML, JS, URL, and others from content.go can carry safe content that is exempted from escaping.</source>
          <target state="translated">content.go의 HTML, JS, URL 및 기타 유형은 탈출이 면제 된 안전한 콘텐츠를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cea554202fc0c5ff6482d3e61417b6640fc17af4" translate="yes" xml:space="preserve">
          <source>Types and Values</source>
          <target state="translated">유형과 값</target>
        </trans-unit>
        <trans-unit id="4a237767760223207248b2b72e8a0eb1c03dbe30" translate="yes" xml:space="preserve">
          <source>Types implementing Valuer interface are able to convert themselves to a driver Value.</source>
          <target state="translated">Valuer 인터페이스를 구현하는 유형은 자신을 드라이버 Value로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="738f4e11bb80f11f67d45a4481cf366179186823" translate="yes" xml:space="preserve">
          <source>Types of signals</source>
          <target state="translated">신호의 종류</target>
        </trans-unit>
        <trans-unit id="b842957498ea8405dcbf49648de63b65b478d2cb" translate="yes" xml:space="preserve">
          <source>UDPAddr represents the address of a UDP end point.</source>
          <target state="translated">UDPAddr은 UDP 엔드 포인트의 주소를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b3b4fc6834e1c9d716c787f9ac0d161736c5f604" translate="yes" xml:space="preserve">
          <source>UDPConn is the implementation of the Conn and PacketConn interfaces for UDP network connections.</source>
          <target state="translated">UDPConn은 UDP 네트워크 연결을위한 Conn 및 PacketConn 인터페이스의 구현입니다.</target>
        </trans-unit>
        <trans-unit id="b499255e82796e4d28d962954395ad3d893bac9c" translate="yes" xml:space="preserve">
          <source>UDPConn.WriteTo</source>
          <target state="translated">UDPConn.WriteTo</target>
        </trans-unit>
        <trans-unit id="0e2d9b0777a485c1276de0803c12a7d76fbc5c39" translate="yes" xml:space="preserve">
          <source>URL</source>
          <target state="translated">URL</target>
        </trans-unit>
        <trans-unit id="2113a36dc330dedde4db70e90a71dcb67bd4a9a2" translate="yes" xml:space="preserve">
          <source>URL (Roundtrip)</source>
          <target state="translated">URL (왕복)</target>
        </trans-unit>
        <trans-unit id="a727ea70072d81d7b63c816962c8a756b508329a" translate="yes" xml:space="preserve">
          <source>URL encapsulates a known safe URL or URL substring (see RFC 3986). A URL like `javascript:checkThatFormNotEditedBeforeLeavingPage()` from a trusted source should go in the page, but by default dynamic `javascript:` URLs are filtered out since they are a frequently exploited injection vector.</source>
          <target state="translated">URL은 알려진 안전한 URL 또는 URL 하위 문자열을 캡슐화합니다 (RFC 3986 참조). 신뢰할 수있는 소스의`javascript : checkThatFormNotEditedBeforeLeavingPage ()`와 같은 URL이 페이지에 들어가야하지만 기본적으로 동적`javascript :`URL은 자주 악용되는 주입 벡터이므로 필터링됩니다.</target>
        </trans-unit>
        <trans-unit id="9f6702283d55dba63f2c15c6981885271e829853" translate="yes" xml:space="preserve">
          <source>URL's String method uses the EscapedPath method to obtain the path. See the EscapedPath method for more details.</source>
          <target state="translated">URL의 String 메소드는 EscapedPath 메소드를 사용하여 경로를 얻습니다. 자세한 내용은 EscapedPath 메서드를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a7ffebe53d073d64da891027cdca3ef31de6ee7a" translate="yes" xml:space="preserve">
          <source>URL.EscapedFragment</source>
          <target state="translated">URL.EscapedFragment</target>
        </trans-unit>
        <trans-unit id="fb15045a2812519f4e1083e5cb90b2d16bf5e0e2" translate="yes" xml:space="preserve">
          <source>URL.EscapedPath</source>
          <target state="translated">URL.EscapedPath</target>
        </trans-unit>
        <trans-unit id="4966fe66780da2ec3d10c8599e72fff7ab08a49a" translate="yes" xml:space="preserve">
          <source>URL.Hostname</source>
          <target state="translated">URL.Hostname</target>
        </trans-unit>
        <trans-unit id="93c3fa248c55505922464e5ed8d1899f54880821" translate="yes" xml:space="preserve">
          <source>URL.IsAbs</source>
          <target state="translated">URL.IsAbs</target>
        </trans-unit>
        <trans-unit id="c5ff099f399baf8e187d09b758e991f007d9fdbb" translate="yes" xml:space="preserve">
          <source>URL.MarshalBinary</source>
          <target state="translated">URL.MarshalBinary</target>
        </trans-unit>
        <trans-unit id="1f5b4a1bd876c3d2e848fa8ad0b5bcdecf59f3eb" translate="yes" xml:space="preserve">
          <source>URL.Parse</source>
          <target state="translated">URL.Parse</target>
        </trans-unit>
        <trans-unit id="df308e5c8e7a40f3e06e1c8f29546df6edd0815c" translate="yes" xml:space="preserve">
          <source>URL.Port</source>
          <target state="translated">URL.Port</target>
        </trans-unit>
        <trans-unit id="1f4af3bd8a928ef1166e58b54f440e84607bbe48" translate="yes" xml:space="preserve">
          <source>URL.Query</source>
          <target state="translated">URL.Query</target>
        </trans-unit>
        <trans-unit id="f2cbc812759bc0bcb35214d0c86a7a333cdc5ac4" translate="yes" xml:space="preserve">
          <source>URL.Redacted</source>
          <target state="translated">URL.Redacted</target>
        </trans-unit>
        <trans-unit id="2f6fe106a87daa55540bf1b3e2faa597e4637d72" translate="yes" xml:space="preserve">
          <source>URL.RequestURI</source>
          <target state="translated">URL.RequestURI</target>
        </trans-unit>
        <trans-unit id="5ef9cfae68b8e79167af493274ea7b99357dad6d" translate="yes" xml:space="preserve">
          <source>URL.ResolveReference</source>
          <target state="translated">URL.ResolveReference</target>
        </trans-unit>
        <trans-unit id="aae15178969446ff357ff699287cc769e108c1ee" translate="yes" xml:space="preserve">
          <source>URL.String</source>
          <target state="translated">URL.String</target>
        </trans-unit>
        <trans-unit id="ce84e8c5399c507871045bd05a22f805d2c4f2bd" translate="yes" xml:space="preserve">
          <source>URL.UnmarshalBinary</source>
          <target state="translated">URL.UnmarshalBinary</target>
        </trans-unit>
        <trans-unit id="ac64d1ff5ad8c8e979a983967383931627c1db93" translate="yes" xml:space="preserve">
          <source>URLEncoding is the alternate base64 encoding defined in RFC 4648. It is typically used in URLs and file names.</source>
          <target state="translated">URLEncoding은 RFC 4648에 정의 된 대체 base64 인코딩입니다. 일반적으로 URL 및 파일 이름에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c9df7bde57a8aa1d95e4f472d843c333da35563f" translate="yes" xml:space="preserve">
          <source>URLQueryEscaper returns the escaped value of the textual representation of its arguments in a form suitable for embedding in a URL query.</source>
          <target state="translated">URLQueryEscaper는 인수의 텍스트 표현에서 이스케이프 된 값을 URL 쿼리에 포함하기에 적합한 형식으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f75c8002cbe8f09b52b12100920f39a5c64e72ab" translate="yes" xml:space="preserve">
          <source>URLs in the comment text are converted into links; if the URL also appears in the words map, the link is taken from the map (if the corresponding map value is the empty string, the URL is not converted into a link).</source>
          <target state="translated">주석 텍스트의 URL은 링크로 변환됩니다. URL이 단어 map에도 나타나는 경우 맵에서 링크를 가져옵니다 (해당 맵 값이 빈 문자열 인 경우 URL은 링크로 변환되지 않음).</target>
        </trans-unit>
        <trans-unit id="66e91d3bfc1c62180f622950dd4b88caee7fb5f3" translate="yes" xml:space="preserve">
          <source>URLs that do not start with a slash after the scheme are interpreted as:</source>
          <target state="translated">구성표 이후에 슬래시로 시작하지 않는 URL은 다음과 같이 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="0809917b6f7b4556e78a9d2c239213f16de1592f" translate="yes" xml:space="preserve">
          <source>UTC represents Universal Coordinated Time (UTC).</source>
          <target state="translated">UTC는 협정 세계시 (UTC)를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2910e9336b266393bd7b3bb04c8ff09ab1ad423c" translate="yes" xml:space="preserve">
          <source>UTC returns t with the location set to UTC.</source>
          <target state="translated">UTC는 위치를 UTC로 설정하여 t를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bd4707cd474a6d0f83da094caeed9e471bb79e5c" translate="yes" xml:space="preserve">
          <source>Uint defines a uint flag with specified name, default value, and usage string. The return value is the address of a uint variable that stores the value of the flag.</source>
          <target state="translated">Uint는 지정된 이름, 기본값 및 사용 문자열로 uint 플래그를 정의합니다. 리턴 값은 플래그 값을 저장하는 uint 변수의 주소입니다.</target>
        </trans-unit>
        <trans-unit id="c10a1c74871016b345bc36d5bdb30897f19968dc" translate="yes" xml:space="preserve">
          <source>Uint returns v's underlying value, as a uint64. It panics if v's Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64.</source>
          <target state="translated">Uint는 v의 기본 값을 uint64로 반환합니다. v의 종류가 Uint, Uintptr, Uint8, Uint16, Uint32 또는 Uint64가 아닌 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8c727e75a1c262fee3ed280d320bad7f8659ca56" translate="yes" xml:space="preserve">
          <source>Uint32 returns a pseudo-random 32-bit value as a uint32 from the default Source.</source>
          <target state="translated">Uint32는 의사 난수 32 비트 값을 기본 소스에서 uint32로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e19c9ecfe9082dbf421a298c1c766023a8f7f823" translate="yes" xml:space="preserve">
          <source>Uint32 returns a pseudo-random 32-bit value as a uint32.</source>
          <target state="translated">Uint32는 의사 난수 32 비트 값을 uint32로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="030a2cb864d68ff2aba5fa883929c569cc36b65c" translate="yes" xml:space="preserve">
          <source>Uint64 defines a uint64 flag with specified name, default value, and usage string. The return value is the address of a uint64 variable that stores the value of the flag.</source>
          <target state="translated">Uint64는 지정된 이름, 기본값 및 사용 문자열로 uint64 플래그를 정의합니다. 리턴 값은 플래그 값을 저장하는 uint64 변수의 주소입니다.</target>
        </trans-unit>
        <trans-unit id="6d3dffebe2bfc2c33c20643972b94062f6925708" translate="yes" xml:space="preserve">
          <source>Uint64 returns a pseudo-random 64-bit value as a uint64 from the default Source.</source>
          <target state="translated">Uint64는 의사 난수 64 비트 값을 기본 소스에서 uint64로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4324e0d2d9e747146788fb1da362fb5053ac15fe" translate="yes" xml:space="preserve">
          <source>Uint64 returns a pseudo-random 64-bit value as a uint64.</source>
          <target state="translated">Uint64는 의사 난수 64 비트 값을 uint64로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8f4f108ba23391540c5f57a2d283a1654c92a932" translate="yes" xml:space="preserve">
          <source>Uint64 returns a value drawn from the Zipf distribution described by the Zipf object.</source>
          <target state="translated">Uint64는 Zipf 객체가 설명하는 Zipf 분포에서 가져온 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0e960db65d7bc2609ac63eaaddb18d0ce30fd34e" translate="yes" xml:space="preserve">
          <source>Uint64 returns the uint64 representation of x. If x cannot be represented in a uint64, the result is undefined.</source>
          <target state="translated">Uint64는 x의 uint64 표현을 반환합니다. x를 uint64로 표현할 수 없으면 결과는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4059a3fbb04daacbe98a3ac34acbb5b4f0511d79" translate="yes" xml:space="preserve">
          <source>Uint64 returns the unsigned integer resulting from truncating x towards zero. If 0 &amp;lt;= x &amp;lt;= math.MaxUint64, the result is Exact if x is an integer and Below otherwise. The result is (0, Above) for x &amp;lt; 0, and (math.MaxUint64, Below) for x &amp;gt; math.MaxUint64.</source>
          <target state="translated">Uint64는 x를 0으로 자른 결과 부호없는 정수를 반환합니다. 0 &amp;lt;= x &amp;lt;= math.MaxUint64 인 경우 x가 정수이면 결과는 정확하고 그렇지 않으면 아래입니다. 결과는 x &amp;lt;0의 경우 (0, Above)이고 x&amp;gt; math.MaxUint64의 경우 (math.MaxUint64, Below)입니다.</target>
        </trans-unit>
        <trans-unit id="eee8610c675fa51e59aceef9ba15ad48fc3f7656" translate="yes" xml:space="preserve">
          <source>Uint64Val returns the Go uint64 value of x and whether the result is exact; x must be an Int or an Unknown. If the result is not exact, its value is undefined. If x is Unknown, the result is (0, false).</source>
          <target state="translated">Uint64Val은 x의 Go uint64 값과 결과가 정확한지 여부를 반환합니다. x는 Int 또는 Unknown이어야합니다. 결과가 정확하지 않으면 값이 정의되지 않습니다. x가 알 수없는 경우 결과는 (0, false)입니다.</target>
        </trans-unit>
        <trans-unit id="f8a9446572ec072b0dca42654febb328f4183bda" translate="yes" xml:space="preserve">
          <source>Uint64Var defines a uint64 flag with specified name, default value, and usage string. The argument p points to a uint64 variable in which to store the value of the flag.</source>
          <target state="translated">Uint64Var는 지정된 이름, 기본값 및 사용 문자열로 uint64 플래그를 정의합니다. 인수 p는 플래그 값을 저장할 uint64 변수를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="496dd0effb0126ef9e845598a59198590bcd043e" translate="yes" xml:space="preserve">
          <source>UintSize is the size of a uint in bits.</source>
          <target state="translated">UintSize는 비트 단위의 uint 크기입니다.</target>
        </trans-unit>
        <trans-unit id="dbe3f8f6ae38a6c86be38b30cc7b136b0e0c8b33" translate="yes" xml:space="preserve">
          <source>UintVar defines a uint flag with specified name, default value, and usage string. The argument p points to a uint variable in which to store the value of the flag.</source>
          <target state="translated">UintVar는 지정된 이름, 기본값 및 사용 문자열로 uint 플래그를 정의합니다. 인수 p는 플래그 값을 저장할 uint 변수를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="70e0b7ef4850aca01e0f7f10e5400e6c9147df8c" translate="yes" xml:space="preserve">
          <source>UnaryOp</source>
          <target state="translated">UnaryOp</target>
        </trans-unit>
        <trans-unit id="07e07a445fa30cc6121d05f031b487faccb7d573" translate="yes" xml:space="preserve">
          <source>UnaryOp returns the result of the unary expression op y. The operation must be defined for the operand. If prec &amp;gt; 0 it specifies the ^ (xor) result size in bits. If y is Unknown, the result is Unknown.</source>
          <target state="translated">UnaryOp는 단항 표현식 op y의 결과를 반환합니다. 피연산자에 대한 작업을 정의해야합니다. prec&amp;gt; 0이면 ^ (xor) 결과 크기를 비트 단위로 지정합니다. y가 알 수없는 경우 결과는 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="65ac12608f350c5da84519394457136c59d339ec" translate="yes" xml:space="preserve">
          <source>Undefined returns the JavaScript value &quot;undefined&quot;.</source>
          <target state="translated">Undefined는 JavaScript 값 &quot;undefined&quot;를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9933a40ae911d6dfb846e287c51e34fc4040de25" translate="yes" xml:space="preserve">
          <source>UnescapeString</source>
          <target state="translated">UnescapeString</target>
        </trans-unit>
        <trans-unit id="d8d400b63495a426dfadc8a4f1e5fdcfa4a8e536" translate="yes" xml:space="preserve">
          <source>UnescapeString unescapes entities like &quot;&amp;amp;lt;&quot; to become &quot;&amp;lt;&quot;. It unescapes a larger range of entities than EscapeString escapes. For example, &quot;&amp;amp;aacute;&quot; unescapes to &quot;&amp;aacute;&quot;, as does &quot;&amp;amp;#225;&quot; and &quot;&amp;amp;#xE1;&quot;. UnescapeString(EscapeString(s)) == s always holds, but the converse isn't always true.</source>
          <target state="translated">UnescapeString은 &quot;&amp;amp; lt;&quot;와 같은 엔티티를 이스케이프 해제합니다. &quot;&amp;lt;&quot;가됩니다. EscapeString 이스케이프보다 더 큰 범위의 엔티티를 이스케이프하지 않습니다. 예를 들어 &quot;&amp;amp; aacute;&quot; &quot;&amp;amp; # 225;&quot;와 마찬가지로 &quot;&amp;aacute;&quot;로 이스케이프되지 않습니다. 및 &quot;&amp;amp; # xE1;&quot;. UnescapeString (EscapeString (s)) == s는 항상 유지되지만 대화가 항상 참인 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="c698e3c309a2ed8c52f6f41c34c41e2935c68bed" translate="yes" xml:space="preserve">
          <source>Uniform is an infinite-sized Image of uniform color. It implements the color.Color, color.Model, and Image interfaces.</source>
          <target state="translated">균일은 균일 한 색상의 무한 크기 이미지입니다. color.Color, color.Model 및 Image 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="c9b92cda61a2bd5ee7e67c31c67ae298972c3694" translate="yes" xml:space="preserve">
          <source>Union returns the smallest rectangle that contains both r and s.</source>
          <target state="translated">Union은 r과 s를 모두 포함하는 가장 작은 사각형을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c30c209545f6cf55ee27d591debf698152bcbfd9" translate="yes" xml:space="preserve">
          <source>Unix returns t as a Unix time, the number of seconds elapsed since January 1, 1970 UTC. The result does not depend on the location associated with t.</source>
          <target state="translated">유닉스는 UTC를 1970 년 1 월 1 일 이후 경과 한 초 수인 유닉스 시간으로 t를 반환합니다. 결과는 t와 관련된 위치에 의존하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0739141adf792995ead54a41a03b2314aaccc261" translate="yes" xml:space="preserve">
          <source>Unix returns t as a Unix time, the number of seconds elapsed since January 1, 1970 UTC. The result does not depend on the location associated with t. Unix-like operating systems often record time as a 32-bit count of seconds, but since the method here returns a 64-bit value it is valid for billions of years into the past or future.</source>
          <target state="translated">Unix는 1970 년 1 월 1 일 UTC 이후 경과 한 초 수인 Unix 시간으로 t를 반환합니다. 결과는 t와 관련된 위치에 의존하지 않습니다. Unix와 유사한 운영 체제는 시간을 32 비트 초 단위로 기록하는 경우가 많지만 여기의 메서드는 64 비트 값을 반환하므로 과거 또는 미래의 수십억 년 동안 유효합니다.</target>
        </trans-unit>
        <trans-unit id="8c849502e5926e7f6de51dcd5dae32180a6c8fc5" translate="yes" xml:space="preserve">
          <source>Unix returns the local Time corresponding to the given Unix time, sec seconds and nsec nanoseconds since January 1, 1970 UTC. It is valid to pass nsec outside the range [0, 999999999]. Not all sec values have a corresponding time value. One such value is 1&amp;lt;&amp;lt;63-1 (the largest int64 value).</source>
          <target state="translated">Unix는 1970 년 1 월 1 일 UTC 이후 지정된 Unix 시간, 초 및 nsec 나노초에 해당하는 로컬 시간을 반환합니다. nsec를 [0, 999999999] 범위를 벗어나는 것이 유효합니다. 모든 초 값에 해당하는 시간 값이있는 것은 아닙니다. 그러한 값 중 하나는 1 &amp;lt;&amp;lt; 63-1 (가장 큰 int64 값)입니다.</target>
        </trans-unit>
        <trans-unit id="7f49edfe928a8998235ec038d3202681fe6091b3" translate="yes" xml:space="preserve">
          <source>Unix returns ts as the number of seconds and nanoseconds elapsed since the Unix epoch.</source>
          <target state="translated">유닉스는 유닉스 시대 이후 초와 나노초 수로 ts를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="36e051fac71bd9f38c8bee21a4fbf639eb952b84" translate="yes" xml:space="preserve">
          <source>Unix returns tv as the number of seconds and nanoseconds elapsed since the Unix epoch.</source>
          <target state="translated">유닉스는 유닉스 시대 이후 초와 나노초의 수로 tv를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4d2a03437e4146025835f0a7a6ccd0e75af8c754" translate="yes" xml:space="preserve">
          <source>UnixAddr represents the address of a Unix domain socket end point.</source>
          <target state="translated">UnixAddr은 Unix 도메인 소켓 끝점의 주소를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="04cdae900c7738c2f31e4e0db5e46a21f1971317" translate="yes" xml:space="preserve">
          <source>UnixConn is an implementation of the Conn interface for connections to Unix domain sockets.</source>
          <target state="translated">UnixConn은 Unix 도메인 소켓에 연결하기위한 Conn 인터페이스의 구현입니다.</target>
        </trans-unit>
        <trans-unit id="fd1ae11b5100fed8de8a53db38bf7aed0bddf628" translate="yes" xml:space="preserve">
          <source>UnixCredentials encodes credentials into a socket control message for sending to another process. This can be used for authentication.</source>
          <target state="translated">UnixCredentials는 다른 프로세스로 전송하기 위해 자격 증명을 소켓 제어 메시지로 인코딩합니다. 인증에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aea7fd85f724d84dccda1e26d2c29b04dd2edf2d" translate="yes" xml:space="preserve">
          <source>UnixListener is a Unix domain socket listener. Clients should typically use variables of type Listener instead of assuming Unix domain sockets.</source>
          <target state="translated">UnixListener는 Unix 도메인 소켓 리스너입니다. 클라이언트는 일반적으로 Unix 도메인 소켓을 가정하는 대신 리스너 유형의 변수를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="2a27b45fc326b4542c26186dc68da8cc5a7e5d10" translate="yes" xml:space="preserve">
          <source>UnixNano returns t as a Unix time, the number of nanoseconds elapsed since January 1, 1970 UTC. The result is undefined if the Unix time in nanoseconds cannot be represented by an int64 (a date before the year 1678 or after 2262). Note that this means the result of calling UnixNano on the zero Time is undefined. The result does not depend on the location associated with t.</source>
          <target state="translated">UnixNano는 t를 1970 년 1 월 1 일 UTC 이후 경과 된 나노초 수인 유닉스 시간으로 반환합니다. 나노초 단위의 유닉스 시간을 int64 (1678 년 이전 또는 2262 이후 날짜)로 표시 할 수없는 경우 결과가 정의되지 않습니다. 이는 제로 시간에 UnixNano를 호출 한 결과가 정의되지 않았 음을 의미합니다. 결과는 t와 관련된 위치에 의존하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b17a6e6eff6f04c581ee8cd1e56b3e493458a9f8" translate="yes" xml:space="preserve">
          <source>UnixRights encodes a set of open file descriptors into a socket control message for sending to another process.</source>
          <target state="translated">UnixRights는 열린 파일 디스크립터 세트를 다른 프로세스로 전송하기 위해 소켓 제어 메시지로 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="dbe53cfcde936dfcaf7c8175938f51e315034103" translate="yes" xml:space="preserve">
          <source>UnknownAuthorityError results when the certificate issuer is unknown</source>
          <target state="translated">인증서 발급자를 알 수없는 경우 UnknownAuthorityError가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="81414e166f7a74fc8a4df3127afc6add584dadf1" translate="yes" xml:space="preserve">
          <source>UnknownFileError represents a failure to find the specific file in the symbol table.</source>
          <target state="translated">UnknownFileError는 기호 테이블에서 특정 파일을 찾지 못했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="71d6e61364d65cc6b10f85900b022e3a712387e7" translate="yes" xml:space="preserve">
          <source>UnknownGroupError is returned by LookupGroup when a group cannot be found.</source>
          <target state="translated">그룹을 찾을 수없는 경우 LookupGroup에서 UnknownGroupError가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="8395a289704405eac7a12dd0a91f81ec7b638b6b" translate="yes" xml:space="preserve">
          <source>UnknownGroupIdError is returned by LookupGroupId when a group cannot be found.</source>
          <target state="translated">UnknownGroupIdError는 그룹을 찾을 수 없을 때 LookupGroupId에 의해 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="ea06d94bc0ee6404fba69dbd6d9433ca16ab32bf" translate="yes" xml:space="preserve">
          <source>UnknownLineError represents a failure to map a line to a program counter, either because the line is beyond the bounds of the file or because there is no code on the given line.</source>
          <target state="translated">UnknownLineError는 행이 파일 범위를 벗어나거나 주어진 행에 코드가 없기 때문에 행을 프로그램 카운터에 매핑하지 못했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="161a93107711086546bec71b893d5cad7e7be15e" translate="yes" xml:space="preserve">
          <source>UnknownUserError is returned by Lookup when a user cannot be found.</source>
          <target state="translated">UnknownUserError는 사용자를 찾을 수 없을 때 조회에서 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6017e893f322aa54de196845bc71d4f23b1edfcb" translate="yes" xml:space="preserve">
          <source>UnknownUserIdError is returned by LookupId when a user cannot be found.</source>
          <target state="translated">UnknownUserIdError는 사용자를 찾을 수 없을 때 LookupId에 의해 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="47025f2669ef0e585c9e4472fd182fc3f82a586e" translate="yes" xml:space="preserve">
          <source>Unless an explicit codec is set up, package encoding/gob is used to transport the data.</source>
          <target state="translated">명시 적 코덱이 설정되어 있지 않으면 패키지 인코딩 / gob가 데이터 전송에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e7e8c7e799f9b4c265f8eb16ca2467638931db85" translate="yes" xml:space="preserve">
          <source>Unless otherwise noted, these are defined in RFC 7231 section 4.3.</source>
          <target state="translated">달리 명시되지 않는 한, 이들은 RFC 7231 섹션 4.3에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad0d769d8f434903817312e6a1ab62dd81dfa28b" translate="yes" xml:space="preserve">
          <source>Unless specified otherwise, all operations (including setters) that specify a *Float variable for the result (usually via the receiver with the exception of MantExp), round the numeric result according to the precision and rounding mode of the result variable.</source>
          <target state="translated">달리 지정하지 않는 한, 결과에 대해 * Float 변수를 지정하는 모든 조작 (세터 포함) (일반적으로 MantExp를 제외하고 수신자를 통해)은 결과 변수의 정밀도 및 반올림 모드에 따라 숫자 결과를 반올림합니다.</target>
        </trans-unit>
        <trans-unit id="a99463bcf73aeb4ac48f9dbe6e1c4e0ad970639e" translate="yes" xml:space="preserve">
          <source>Unlike NextPart, it does not have special handling for &quot;Content-Transfer-Encoding: quoted-printable&quot;.</source>
          <target state="translated">NextPart와 달리 &quot;Content-Transfer-Encoding : quoted-printable&quot;에 대한 특수 처리가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ce1ab5c402bafab7c2f436e8311567b966b147df" translate="yes" xml:space="preserve">
          <source>Unlike in C, it is not valid to advance a pointer just beyond the end of its original allocation:</source>
          <target state="translated">C와는 달리, 원래 할당의 끝을 넘어서 포인터를 진행시키는 것은 유효하지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="522a3a646a834223c2e98bb2c21ff8e76c01dd11" translate="yes" xml:space="preserve">
          <source>Unlike runtime.Callers, the PC values returned should, when passed to the symbolizer function, return the file/line of the call instruction. No additional subtraction is required or appropriate.</source>
          <target state="translated">runtime.Callers와 달리 리턴 된 PC 값은 symbolizer 함수에 전달 될 때 호출 명령의 파일 / 라인을 리턴해야합니다. 추가 뺄셈이 필요하지 않거나 적절하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="406ad3e57d6ca887a28b68d7deb07d96e9cd7dc1" translate="yes" xml:space="preserve">
          <source>Unlike the &quot;system&quot; library call from C and other languages, the os/exec package intentionally does not invoke the system shell and does not expand any glob patterns or handle other expansions, pipelines, or redirections typically done by shells. The package behaves more like C's &quot;exec&quot; family of functions. To expand glob patterns, either call the shell directly, taking care to escape any dangerous input, or use the path/filepath package's Glob function. To expand environment variables, use package os's ExpandEnv.</source>
          <target state="translated">C 및 다른 언어의 &quot;시스템&quot;라이브러리 호출과 달리 os / exec 패키지는 의도적으로 시스템 셸을 호출하지 않으며 글로브 패턴을 확장하거나 일반적으로 셸에서 수행되는 다른 확장, 파이프 라인 또는 리디렉션을 처리하지 않습니다. 패키지는 C의 &quot;exec&quot;기능 군과 유사하게 동작합니다. glob 패턴을 확장하려면 위험한 입력을 피하기 위해 쉘을 직접 호출하거나 path / filepath 패키지의 Glob 함수를 사용하십시오. 환경 변수를 확장하려면 package os의 ExpandEnv를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="abe91b52586dc5bbb2e6b3566c5e2c39387cbbd6" translate="yes" xml:space="preserve">
          <source>Unlink removes n % r.Len() elements from the ring r, starting at r.Next(). If n % r.Len() == 0, r remains unchanged. The result is the removed subring. r must not be empty.</source>
          <target state="translated">링크 해제는 r.Next ()에서 시작하여 링 r에서 n % r.Len () 요소를 제거합니다. n % r.Len () == 0이면 r은 변경되지 않습니다. 결과는 제거 된 서브 링입니다. r은 비워 둘 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f1750196ed6e86ab6e565436971490e6b17346e5" translate="yes" xml:space="preserve">
          <source>Unlock unlocks m. It is a run-time error if m is not locked on entry to Unlock.</source>
          <target state="translated">잠금 해제 잠금 해제 m. 잠금 해제 항목에 m이 잠겨 있지 않으면 런타임 오류입니다.</target>
        </trans-unit>
        <trans-unit id="1031b448939f378b7eec7282357fd0c8f02e0dd3" translate="yes" xml:space="preserve">
          <source>Unlock unlocks rw for writing. It is a run-time error if rw is not locked for writing on entry to Unlock.</source>
          <target state="translated">잠금 해제는 쓰기를 위해 rw를 잠금 해제합니다. 잠금 해제 항목에 쓰기 위해 rw가 잠기지 않은 경우 런타임 오류입니다.</target>
        </trans-unit>
        <trans-unit id="2769f111e84de5efeaaffb059d166476e34adffc" translate="yes" xml:space="preserve">
          <source>UnlockOSThread undoes an earlier call to LockOSThread. If this drops the number of active LockOSThread calls on the calling goroutine to zero, it unwires the calling goroutine from its fixed operating system thread. If there are no active LockOSThread calls, this is a no-op.</source>
          <target state="translated">UnlockOSThread는 LockOSThread에 대한 이전 호출을 취소합니다. 이렇게하면 호출 고 루틴의 활성 LockOSThread 호출 수가 0으로 떨어지면 고정 운영 체제 스레드에서 호출 고 루틴의 연결이 해제됩니다. 활성화 된 LockOSThread 호출이없는 경우 이는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c0c55cc87781bbcbbe014b61cd39f339918efe82" translate="yes" xml:space="preserve">
          <source>Unmarshal</source>
          <target state="translated">Unmarshal</target>
        </trans-unit>
        <trans-unit id="b902b427877022323b14bf2942e7b4318af381ef" translate="yes" xml:space="preserve">
          <source>Unmarshal converts a point, serialized by Marshal, into an x, y pair. It is an error if the point is not in uncompressed form or is not on the curve. On error, x = nil.</source>
          <target state="translated">비 정렬 화는 마셜이 직렬화 한 점을 x, y 쌍으로 변환합니다. 점이 압축되지 않은 형태가 아니거나 곡선 위에 있지 않으면 오류입니다. 오류가 발생하면 x = nil입니다.</target>
        </trans-unit>
        <trans-unit id="05d9d3d65b2b20105c2330ab2953dfbf47f42b20" translate="yes" xml:space="preserve">
          <source>Unmarshal maps an XML element or attribute value to a bool by setting it to the boolean value represented by the string. Whitespace is trimmed and ignored.</source>
          <target state="translated">비 정렬 화는 XML 요소 또는 속성 값을 문자열이 나타내는 부울 값으로 설정하여 부울에 맵핑합니다. 공백이 잘리고 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="a20ffd00f170a26037fda94503e504e8f14a2140" translate="yes" xml:space="preserve">
          <source>Unmarshal maps an XML element or attribute value to a slice by extending the length of the slice and mapping the element or attribute to the newly created value.</source>
          <target state="translated">비 정렬 화는 슬라이스의 길이를 확장하고 요소 또는 속성을 새로 작성된 값에 맵핑하여 XML 요소 또는 속성 값을 슬라이스에 맵핑합니다.</target>
        </trans-unit>
        <trans-unit id="f49e594c7cd50f427b1321468c3f00b6805b3bc7" translate="yes" xml:space="preserve">
          <source>Unmarshal maps an XML element or attribute value to an integer or floating-point field by setting the field to the result of interpreting the string value in decimal. There is no check for overflow. Whitespace is trimmed and ignored.</source>
          <target state="translated">비 정렬 화는 필드를 문자열 값을 10 진수로 해석 한 결과로 설정하여 XML 요소 또는 속성 값을 정수 또는 부동 소수점 필드에 맵핑합니다. 오버 플로우 확인이 없습니다. 공백이 잘리고 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="e3d47c5ca4b3a002e5a1a94281405e13a887e601" translate="yes" xml:space="preserve">
          <source>Unmarshal maps an XML element to a Name by recording the element name.</source>
          <target state="translated">비 정렬 화는 요소 이름을 기록하여 XML 요소를 이름에 맵핑합니다.</target>
        </trans-unit>
        <trans-unit id="96b027c2d930b698a1ed10b0bb721de215ae272f" translate="yes" xml:space="preserve">
          <source>Unmarshal maps an XML element to a pointer by setting the pointer to a freshly allocated value and then mapping the element to that value.</source>
          <target state="translated">비 정렬 화는 포인터를 새로 할당 된 값으로 설정 한 다음 요소를 해당 값에 매핑하여 XML 요소를 포인터에 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="6674f1401888e867e969567800411704118b6e15" translate="yes" xml:space="preserve">
          <source>Unmarshal maps an XML element to a string or []byte by saving the concatenation of that element's character data in the string or []byte. The saved []byte is never nil.</source>
          <target state="translated">비 정렬 화는 해당 요소의 문자 데이터 연결을 문자열 또는 [] 바이트에 저장하여 XML 요소를 문자열 또는 [] 바이트에 맵핑합니다. 저장된 [] 바이트는 절대로 0이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="a09403355ff68d791492810d3a6fdc52e5bc5f23" translate="yes" xml:space="preserve">
          <source>Unmarshal maps an XML element to a struct using the following rules. In the rules, the tag of a field refers to the value associated with the key 'xml' in the struct field's tag (see the example above).</source>
          <target state="translated">비 정렬 화는 다음 규칙을 사용하여 XML 요소를 구조체에 매핑합니다. 규칙에서 필드의 태그는 구조체 필드의 태그에서 'xml'키와 연관된 값을 나타냅니다 (위 예 참조).</target>
        </trans-unit>
        <trans-unit id="252b3357e8880736b5df5514f3757c07707118ae" translate="yes" xml:space="preserve">
          <source>Unmarshal maps an attribute value to a string or []byte by saving the value in the string or slice.</source>
          <target state="translated">비 정렬 화는 문자열 또는 슬라이스에 값을 저장하여 속성 값을 문자열 또는 [] 바이트에 맵핑합니다.</target>
        </trans-unit>
        <trans-unit id="bb18922b79397b807a3d5909559848bfe9436488" translate="yes" xml:space="preserve">
          <source>Unmarshal maps an attribute value to an Attr by saving the attribute, including its name, in the Attr.</source>
          <target state="translated">비 정렬 화는 속성을 포함하여 속성을 속성 값에 저장하여 속성 값을 속성 값에 맵핑합니다.</target>
        </trans-unit>
        <trans-unit id="daa56a09ffbf4f0b35b7c340fa9c8ae81aa1dac5" translate="yes" xml:space="preserve">
          <source>Unmarshal parses the DER-encoded ASN.1 data structure b and uses the reflect package to fill in an arbitrary value pointed at by val. Because Unmarshal uses the reflect package, the structs being written to must use upper case field names.</source>
          <target state="translated">비 정렬 화는 DER 인코딩 된 ASN.1 데이터 구조 b를 구문 분석하고 val이 가리키는 임의의 값을 채우기 위해 반사 패키지를 사용합니다. Unmarshal은 reflect 패키지를 사용하므로 작성되는 구조체는 대문자 필드 이름을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="6a9e198e98aaf9144ec031242893dd0ad5675a2b" translate="yes" xml:space="preserve">
          <source>Unmarshal parses the JSON-encoded data and stores the result in the value pointed to by v. If v is nil or not a pointer, Unmarshal returns an InvalidUnmarshalError.</source>
          <target state="translated">비 정렬은 JSON으로 인코딩 된 데이터를 구문 분석하고 결과를 v가 가리키는 값으로 저장합니다. v가 nil이거나 포인터가 아닌 경우 Unmarshal은 InvalidUnmarshalError를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ed1d87c314d03ac8a80eec05352fd3a2e828f6fd" translate="yes" xml:space="preserve">
          <source>Unmarshal parses the XML-encoded data and stores the result in the value pointed to by v, which must be an arbitrary struct, slice, or string. Well-formed data that does not fit into v is discarded.</source>
          <target state="translated">비 정렬 화는 XML로 인코딩 된 데이터를 구문 분석하고 v가 가리키는 값으로 결과를 저장합니다.이 값은 임의의 구조체, 슬라이스 또는 문자열이어야합니다. v에 맞지 않는 올바른 형식의 데이터는 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="40f5f3bf6806f78bc75f412c5c5def4697b027f5" translate="yes" xml:space="preserve">
          <source>Unmarshal uses the inverse of the encodings that Marshal uses, allocating maps, slices, and pointers as necessary, with the following additional rules:</source>
          <target state="translated">Unmarshal은 다음 추가 규칙과 함께 필요에 따라 Marshal이 사용하는 인코딩의 역수를 사용하여 맵, 슬라이스 및 포인터를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="8a48a17f3248cfe923e11a8bf58b4b7fb9c77d34" translate="yes" xml:space="preserve">
          <source>UnmarshalBinary implements the encoding.BinaryUnmarshaler interface.</source>
          <target state="translated">UnmarshalBinary는 encoding.BinaryUnmarshaler 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="3e8a767165b3da81fab334a0479c29a17b19b26e" translate="yes" xml:space="preserve">
          <source>UnmarshalBinary must be able to decode the form generated by MarshalBinary. UnmarshalBinary must copy the data if it wishes to retain the data after returning.</source>
          <target state="translated">UnmarshalBinary는 MarshalBinary에 의해 생성 된 형식을 해독 할 수 있어야합니다. UnmarshalBinary는 반환 후 데이터를 유지하려면 데이터를 복사해야합니다.</target>
        </trans-unit>
        <trans-unit id="c0f8f106115bed98d4438b712b344fc8e65ac7a2" translate="yes" xml:space="preserve">
          <source>UnmarshalCompressed converts a point, serialized by MarshalCompressed, into an x, y pair. It is an error if the point is not in compressed form or is not on the curve. On error, x = nil.</source>
          <target state="translated">UnmarshalCompressed는 MarshalCompressed에 의해 직렬화 된 점을 x, y 쌍으로 변환합니다. 점이 압축 된 형태가 아니거나 곡선에없는 경우 오류입니다. 오류시 x = nil.</target>
        </trans-unit>
        <trans-unit id="a1f2034d1f5318f262d82d2c3d3d1a1f573ff376" translate="yes" xml:space="preserve">
          <source>UnmarshalJSON implements the json.Unmarshaler interface.</source>
          <target state="translated">UnmarshalJSON은 json.Unmarshaler 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="ac481b848955fbdb07ec4ed8b1f2094acec90508" translate="yes" xml:space="preserve">
          <source>UnmarshalJSON implements the json.Unmarshaler interface. The time is expected to be a quoted string in RFC 3339 format.</source>
          <target state="translated">UnmarshalJSON은 json.Unmarshaler 인터페이스를 구현합니다. 시간은 RFC 3339 형식의 인용 문자열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="501d2e87e0671202c95a53d1a0ea534ac74ed463" translate="yes" xml:space="preserve">
          <source>UnmarshalJSON sets *m to a copy of data.</source>
          <target state="translated">UnmarshalJSON은 * m을 데이터 사본으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="766c1d65184cba1147b7a3545fa3391dee2740d7" translate="yes" xml:space="preserve">
          <source>UnmarshalText implements the encoding.TextUnmarshaler interface.</source>
          <target state="translated">UnmarshalText는 encoding.TextUnmarshaler 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="85ec5d5725d7fc8b15d01b424436803971c310f0" translate="yes" xml:space="preserve">
          <source>UnmarshalText implements the encoding.TextUnmarshaler interface. The IP address is expected in a form accepted by ParseIP.</source>
          <target state="translated">UnmarshalText는 encoding.TextUnmarshaler 인터페이스를 구현합니다. IP 주소는 ParseIP가 승인 한 형식으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="131593f7a0c50a040c83c26b3def1697240de177" translate="yes" xml:space="preserve">
          <source>UnmarshalText implements the encoding.TextUnmarshaler interface. The result is rounded per the precision and rounding mode of z. If z's precision is 0, it is changed to 64 before rounding takes effect.</source>
          <target state="translated">UnmarshalText는 encoding.TextUnmarshaler 인터페이스를 구현합니다. 결과는 z의 정밀도 및 반올림 모드에 따라 반올림됩니다. z의 정밀도가 0이면 반올림이 적용되기 전에 64로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="7b15f389f52fa3ed23e4bbf98f836b42c06e5eba" translate="yes" xml:space="preserve">
          <source>UnmarshalText implements the encoding.TextUnmarshaler interface. The time is expected to be in RFC 3339 format.</source>
          <target state="translated">UnmarshalText는 encoding.TextUnmarshaler 인터페이스를 구현합니다. 시간은 RFC 3339 형식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="6b7f1ab4fc569112930c20562985da8185544c87" translate="yes" xml:space="preserve">
          <source>UnmarshalText must be able to decode the form generated by MarshalText. UnmarshalText must copy the text if it wishes to retain the text after returning.</source>
          <target state="translated">UnmarshalText는 MarshalText에 의해 생성 된 양식을 디코딩 할 수 있어야합니다. UnmarshalText는 텍스트를 반환 한 후 텍스트를 유지하려면 텍스트를 복사해야합니다.</target>
        </trans-unit>
        <trans-unit id="bd65d49d42bce927940aedf915c377e4dd09e40d" translate="yes" xml:space="preserve">
          <source>UnmarshalWithParams allows field parameters to be specified for the top-level element. The form of the params is the same as the field tags.</source>
          <target state="translated">UnmarshalWithParams를 사용하면 최상위 요소에 필드 매개 변수를 지정할 수 있습니다. 매개 변수의 형식은 필드 태그와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="b3bf6c68384d3fb37cb6c7555cff99e7fce3bb41" translate="yes" xml:space="preserve">
          <source>UnmarshalXML decodes a single XML element beginning with the given start element. If it returns an error, the outer call to Unmarshal stops and returns that error. UnmarshalXML must consume exactly one XML element. One common implementation strategy is to unmarshal into a separate value with a layout matching the expected XML using d.DecodeElement, and then to copy the data from that value into the receiver. Another common strategy is to use d.Token to process the XML object one token at a time. UnmarshalXML may not use d.RawToken.</source>
          <target state="translated">UnmarshalXML은 주어진 시작 요소로 시작하는 단일 XML 요소를 디코딩합니다. 오류가 반환되면 Unmarshal에 대한 외부 호출이 중지되고 해당 오류가 반환됩니다. UnmarshalXML은 정확히 하나의 XML 요소를 사용해야합니다. 일반적인 구현 전략 중 하나는 d.DecodeElement를 사용하여 예상 XML과 일치하는 레이아웃을 사용하여 별도의 값으로 마샬링 해제 한 다음 해당 값의 데이터를 수신자로 복사하는 것입니다. 또 다른 일반적인 전략은 d.Token을 사용하여 한 번에 하나의 토큰으로 XML 객체를 처리하는 것입니다. UnmarshalXML은 d.RawToken을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="acecbda4c97cb520576b3b10bc8d83fa35017c1a" translate="yes" xml:space="preserve">
          <source>UnmarshalXMLAttr decodes a single XML attribute. If it returns an error, the outer call to Unmarshal stops and returns that error. UnmarshalXMLAttr is used only for struct fields with the &quot;attr&quot; option in the field tag.</source>
          <target state="translated">UnmarshalXMLAttr은 단일 XML 속성을 디코딩합니다. 오류가 반환되면 Unmarshal에 대한 외부 호출이 중지되고 해당 오류가 반환됩니다. UnmarshalXMLAttr은 필드 태그에 &quot;attr&quot;옵션이있는 구조체 필드에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="74aa3bc85e3cd4c389b5c2ee32e0f9e728ff011a" translate="yes" xml:space="preserve">
          <source>Unmarshaler is the interface implemented by objects that can unmarshal an XML element description of themselves.</source>
          <target state="translated">Unmarshaler는 자신에 대한 XML 요소 설명을 언 마샬링 할 수있는 객체로 구현 된 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="da8c67afda9119d4c5ae65e92c29582ea2cf5d56" translate="yes" xml:space="preserve">
          <source>Unmarshaler is the interface implemented by types that can unmarshal a JSON description of themselves. The input can be assumed to be a valid encoding of a JSON value. UnmarshalJSON must copy the JSON data if it wishes to retain the data after returning.</source>
          <target state="translated">Unmarshaler는 JSON 설명을 언 마샬링 할 수있는 유형으로 구현 된 인터페이스입니다. 입력은 JSON 값의 유효한 인코딩으로 가정 할 수 있습니다. UnmarshalJSON은 반환 후 데이터를 유지하려면 JSON 데이터를 복사해야합니다.</target>
        </trans-unit>
        <trans-unit id="53e6478e1491aec13688a3a1ab544532e2362899" translate="yes" xml:space="preserve">
          <source>UnmarshalerAttr is the interface implemented by objects that can unmarshal an XML attribute description of themselves.</source>
          <target state="translated">UnmarshalerAttr은 자신에 대한 XML 속성 설명을 언 마샬링 할 수있는 객체로 구현 된 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="3db9a5e29909b34e2551d8477bb97dce0e5cc013" translate="yes" xml:space="preserve">
          <source>Unquote</source>
          <target state="translated">Unquote</target>
        </trans-unit>
        <trans-unit id="d3b6eaa5a8adda6c17843b82fa332f2940b5c172" translate="yes" xml:space="preserve">
          <source>Unquote and UnquoteChar unquote Go string and rune literals.</source>
          <target state="translated">Unquote 및 UnquoteChar는 Go 문자열 및 룬 리터럴을 인용 해제합니다.</target>
        </trans-unit>
        <trans-unit id="eb183728a78695573a325619f75443a862dbd0b9" translate="yes" xml:space="preserve">
          <source>Unquote interprets s as a single-quoted, double-quoted, or backquoted Go string literal, returning the string value that s quotes. (If s is single-quoted, it would be a Go character literal; Unquote returns the corresponding one-character string.)</source>
          <target state="translated">Unquote는 s를 작은 따옴표, 큰 따옴표 또는 backquoted Go 문자열 리터럴로 해석하여 따옴표로 묶은 문자열 값을 반환합니다. s가 작은 따옴표로 묶인 경우 Go 문자 리터럴이되고 Unquote는 해당하는 한 문자 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="944cb633773df2e1ec790dd961a8146fba14fec2" translate="yes" xml:space="preserve">
          <source>UnquoteChar</source>
          <target state="translated">UnquoteChar</target>
        </trans-unit>
        <trans-unit id="29375f10dc5a5623870f8be238ab4c2e02bc8067" translate="yes" xml:space="preserve">
          <source>UnquoteChar decodes the first character or byte in the escaped string or character literal represented by the string s. It returns four values:</source>
          <target state="translated">UnquoteChar는 이스케이프 된 문자열 또는 문자열 s로 표시되는 문자 리터럴의 첫 번째 문자 또는 바이트를 디코딩합니다. 네 가지 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b53dd6b78670edea47b93cdb0a942d08f61ad422" translate="yes" xml:space="preserve">
          <source>UnquoteUsage extracts a back-quoted name from the usage string for a flag and returns it and the un-quoted usage. Given &quot;a `name` to show&quot; it returns (&quot;name&quot;, &quot;a name to show&quot;). If there are no back quotes, the name is an educated guess of the type of the flag's value, or the empty string if the flag is boolean.</source>
          <target state="translated">UnquoteUsage는 플래그의 사용법 문자열에서 역 인용 된 이름을 추출하여 인용되지 않은 사용법을 리턴합니다. &quot;표시 할 이름&quot;이 주어지면 ( &quot;이름&quot;, &quot;표시 할 이름&quot;)을 반환합니다. 역 따옴표가 없으면 이름은 플래그 값의 유형에 대한 교육 된 추측이거나 플래그가 부울 인 경우 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="31604e0bbb76d839a9e20bc3ad471c203d67835a" translate="yes" xml:space="preserve">
          <source>UnreadByte causes the next call to ReadByte to return the same byte as the previous call to ReadByte. It may be an error to call UnreadByte twice without an intervening call to ReadByte.</source>
          <target state="translated">UnreadByte는 다음 ReadByte 호출이 이전 ReadRead 호출과 동일한 바이트를 반환하게합니다. ReadByte에 대한 중간 호출없이 UnreadByte를 두 번 호출하면 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f50817f3bd6d2c35e72fde2b0a932fd55a8206aa" translate="yes" xml:space="preserve">
          <source>UnreadByte complements ReadByte in implementing the io.ByteScanner interface.</source>
          <target state="translated">UnreadByte는 io.ByteScanner 인터페이스 구현에서 ReadByte를 보완합니다.</target>
        </trans-unit>
        <trans-unit id="77c7dde06491fe4b9339041eb3796382445874b6" translate="yes" xml:space="preserve">
          <source>UnreadByte returns an error if the most recent method called on the Reader was not a read operation. Notably, Peek is not considered a read operation.</source>
          <target state="translated">Reader에서 가장 최근에 호출 된 메서드가 읽기 작업이 아닌 경우 UnreadByte는 오류를 반환합니다. 특히 Peek는 읽기 작업으로 간주되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="85bb36da753f37d1b461fc793f6153ef59c80214" translate="yes" xml:space="preserve">
          <source>UnreadByte unreads the last byte returned by the most recent successful read operation that read at least one byte. If a write has happened since the last read, if the last read returned an error, or if the read read zero bytes, UnreadByte returns an error.</source>
          <target state="translated">UnreadByte는 적어도 하나의 바이트를 읽는 가장 최근의 성공적인 읽기 작업에서 반환 된 마지막 바이트를 읽습니다. 마지막 읽기 이후에 쓰기가 발생한 경우, 마지막 읽기가 오류를 반환 한 경우 또는 읽기 읽기가 0 바이트 인 경우 UnreadByte는 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="965a6610c5d757c591de2c22877d96263eb8aa9d" translate="yes" xml:space="preserve">
          <source>UnreadByte unreads the last byte. Only the most recently read byte can be unread.</source>
          <target state="translated">UnreadByte는 마지막 바이트를 읽습니다. 가장 최근에 읽은 바이트 만 읽을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4b29ee18a300641e642a50770d2b768bae903a75" translate="yes" xml:space="preserve">
          <source>UnreadRune causes the next call to ReadRune to return the same rune as the previous call to ReadRune. It may be an error to call UnreadRune twice without an intervening call to ReadRune.</source>
          <target state="translated">UnreadRune은 ReadRune에 대한 다음 호출이 이전에 ReadRune에 대한 호출과 동일한 룬을 리턴하게합니다. ReadRune에 대한 중간 호출없이 UnreadRune을 두 번 호출하면 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53822d24e97f8bde421daa61dcb508cacfde9d9a" translate="yes" xml:space="preserve">
          <source>UnreadRune complements ReadRune in implementing the io.RuneScanner interface.</source>
          <target state="translated">UnreadRune은 io.RuneScanner 인터페이스 구현에서 ReadRune을 보완합니다.</target>
        </trans-unit>
        <trans-unit id="a4e42f86f3f39d57a5422eae590b939a777bcf43" translate="yes" xml:space="preserve">
          <source>UnreadRune unreads the last rune returned by ReadRune. If the most recent read or write operation on the buffer was not a successful ReadRune, UnreadRune returns an error. (In this regard it is stricter than UnreadByte, which will unread the last byte from any read operation.)</source>
          <target state="translated">UnreadRune은 ReadRune에서 반환 한 마지막 룬을 읽습니다. 버퍼에서 가장 최근의 읽기 또는 쓰기 작업이 성공적인 ReadRune이 아닌 경우 UnreadRune은 오류를 반환합니다. (이 점에서 UnreadByte보다 엄격하므로 모든 읽기 작업에서 마지막 바이트를 읽지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="19847ace49c568ee229c8734fba08cf124cc864f" translate="yes" xml:space="preserve">
          <source>UnreadRune unreads the last rune. If the most recent method called on the Reader was not a ReadRune, UnreadRune returns an error. (In this regard it is stricter than UnreadByte, which will unread the last byte from any read operation.)</source>
          <target state="translated">UnreadRune은 마지막 룬을 읽습니다. Reader에서 가장 최근에 호출 된 메서드가 ReadRune이 아닌 경우 UnreadRune은 오류를 반환합니다. (이 점에서 UnreadByte보다 엄격하므로 모든 읽기 작업에서 마지막 바이트를 읽지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="50c3f847c58ba55e1737c9ae778e9a6278576b57" translate="yes" xml:space="preserve">
          <source>UnsafeAddr returns a pointer to v's data. It is for advanced clients that also import the &quot;unsafe&quot; package. It panics if v is not addressable.</source>
          <target state="translated">UnsafeAddr는 v의 데이터에 대한 포인터를 반환합니다. &quot;안전하지 않은&quot;패키지를 가져 오는 것은 고급 클라이언트를위한 것입니다. v를 처리 할 수없는 경우 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="504ce26fbf37c2ede64fba6d4661638e260a1239" translate="yes" xml:space="preserve">
          <source>Unsetenv</source>
          <target state="translated">Unsetenv</target>
        </trans-unit>
        <trans-unit id="182ea105f6e57aa2c2130dff922916a82bfc3855" translate="yes" xml:space="preserve">
          <source>Unsetenv unsets a single environment variable.</source>
          <target state="translated">Unsetenv는 단일 환경 변수를 설정 해제합니다.</target>
        </trans-unit>
        <trans-unit id="5d092e34b5869cce62568374e8b69ed2285d4b5a" translate="yes" xml:space="preserve">
          <source>UnsupportedTypeError is returned when Marshal encounters a type that cannot be converted into XML.</source>
          <target state="translated">Marshal에서 XML로 변환 할 수없는 형식이 발견되면 UnsupportedTypeError가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e92f4283009858bf9a4050cedd8fe684e6e6d055" translate="yes" xml:space="preserve">
          <source>Until returns the duration until t. It is shorthand for t.Sub(time.Now()).</source>
          <target state="translated">까지 t까지 지속 시간을 반환합니다. t.Sub (time.Now ())의 약어입니다.</target>
        </trans-unit>
        <trans-unit id="90df4c2aff351c99774ec32df813be4f64cfabcd" translate="yes" xml:space="preserve">
          <source>Unwrap returns the result of calling the Unwrap method on err, if err's type contains an Unwrap method returning error. Otherwise, Unwrap returns nil.</source>
          <target state="translated">err의 유형에 오류를 리턴하는 Unwrap 메소드가 포함 된 경우 Unwrap은 err에서 Unwrap 메소드를 호출 한 결과를 리턴합니다. 그렇지 않으면 Unwrap은 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0674f5735125e15a98a0dd1cdad0bd08b0642deb" translate="yes" xml:space="preserve">
          <source>Unwrap returns the underlying error.</source>
          <target state="translated">Unwrap은 기본 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2facf8e427018a05d97ad6fa738413f526dc52de" translate="yes" xml:space="preserve">
          <source>Unwrap unpacks wrapped errors. If its argument's type has an Unwrap method, it calls the method once. Otherwise, it returns nil.</source>
          <target state="translated">랩 해제는 랩핑 된 오류를 언팩합니다. 인수 유형에 Unwrap 메소드가 있으면 메소드를 한 번 호출합니다. 그렇지 않으면 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2a313ddb07d29b1265d5875102d8b2f23477d34a" translate="yes" xml:space="preserve">
          <source>Update replaces an old node in the comment map with the new node and returns the new node. Comments that were associated with the old node are associated with the new node.</source>
          <target state="translated">업데이트는 주석 맵의 이전 노드를 새 노드로 바꾸고 새 노드를 반환합니다. 이전 노드와 연관된 주석은 새 노드와 연관됩니다.</target>
        </trans-unit>
        <trans-unit id="edb9e0c28d17431f4e5d015de98ef6d3ddc2e66d" translate="yes" xml:space="preserve">
          <source>Update returns the result of adding the bytes in p to the crc.</source>
          <target state="translated">Update는 p의 바이트를 crc에 추가 한 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="cec856deaea9fb4090c73c99e87c26b997d6e715" translate="yes" xml:space="preserve">
          <source>Usage prints a usage message documenting all defined command-line flags to CommandLine's output, which by default is os.Stderr. It is called when an error occurs while parsing flags. The function is a variable that may be changed to point to a custom function. By default it prints a simple header and calls PrintDefaults; for details about the format of the output and how to control it, see the documentation for PrintDefaults. Custom usage functions may choose to exit the program; by default exiting happens anyway as the command line's error handling strategy is set to ExitOnError.</source>
          <target state="translated">Usage는 정의 된 모든 명령 줄 플래그를 CommandLine의 출력 (기본적으로 os.Stderr)에 기록하는 사용 메시지를 인쇄합니다. 플래그를 구문 분석하는 동안 오류가 발생하면 호출됩니다. 함수는 사용자 정의 함수를 가리 키도록 변경 될 수있는 변수입니다. 기본적으로 간단한 헤더를 인쇄하고 PrintDefaults를 호출합니다. 출력 형식 및 제어 방법에 대한 자세한 내용은 PrintDefaults 설명서를 참조하십시오. 사용자 정의 사용 기능은 프로그램을 종료하도록 선택할 수 있습니다. 명령 행의 오류 처리 전략이 ExitOnError로 설정되어 있으면 기본적으로 종료가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="08b2986bb9311484289ed77e8cb011bc1a1a4415" translate="yes" xml:space="preserve">
          <source>Use GoTokens to configure the Scanner such that it accepts all Go literal tokens including Go identifiers. Comments will be skipped.</source>
          <target state="translated">Go 식별자를 포함하여 모든 Go 리터럴 토큰을 허용하도록 GoTokens를 사용하여 검사기를 구성하십시오. 댓글을 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="e7059998d0ef4d38492eb586594b1a7f2fda5597" translate="yes" xml:space="preserve">
          <source>Use a Scanner to implement a simple word-count utility by scanning the input as a sequence of space-delimited tokens.</source>
          <target state="translated">스캐너를 사용하여 공백으로 구분 된 일련의 토큰으로 입력을 스캔하여 간단한 단어 수 유틸리티를 구현하십시오.</target>
        </trans-unit>
        <trans-unit id="c7ed138fa83b46f7078f3eba45cc612903e73703" translate="yes" xml:space="preserve">
          <source>Use a Scanner with a custom split function (built by wrapping ScanWords) to validate 32-bit decimal input.</source>
          <target state="translated">32 비트 10 진수 입력의 유효성을 검사하려면 사용자 지정 분할 기능 (ScanWord를 래핑하여 구축)이있는 스캐너를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a131c39c2cc3965eeb7903a72d441b0e6edc8b39" translate="yes" xml:space="preserve">
          <source>Use a Scanner with a custom split function to parse a comma-separated list with an empty final value.</source>
          <target state="translated">사용자 정의 분할 기능이있는 스캐너를 사용하여 쉼표로 구분 된 목록을 빈 최종 값으로 구문 분석하십시오.</target>
        </trans-unit>
        <trans-unit id="3fe5cc9def42296a11d7d9a0af9fc8ea7342706f" translate="yes" xml:space="preserve">
          <source>Use context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions.</source>
          <target state="translated">선택적 매개 변수를 함수에 전달하는 것이 아니라 프로세스 및 API를 전송하는 요청 범위 데이터에만 컨텍스트 값을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b7726ad2d6a51eae4064f8abdd4f91a30451b9da" translate="yes" xml:space="preserve">
          <source>Use of this type presents a security risk: the encapsulated content should come from a trusted source, as it will be included verbatim in the template output.</source>
          <target state="translated">이 유형을 사용하면 보안 위험이 발생합니다. 캡슐화 된 콘텐츠는 템플릿 출력에 그대로 포함되므로 신뢰할 수있는 소스에서 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="34a9c66123dc40ac60f0472d60867161abcd1901" translate="yes" xml:space="preserve">
          <source>UseNumber causes the Decoder to unmarshal a number into an interface{} as a Number instead of as a float64.</source>
          <target state="translated">UseNumber는 디코더가 float64 대신 Number로 인터페이스 {}에서 숫자를 비 정렬 화합니다.</target>
        </trans-unit>
        <trans-unit id="b20930a62f52b49ee0781be625003d945b67da4b" translate="yes" xml:space="preserve">
          <source>User annotation</source>
          <target state="translated">사용자 주석</target>
        </trans-unit>
        <trans-unit id="fc3da515c7dc35d47639ea550f79310b8bc9a78e" translate="yes" xml:space="preserve">
          <source>User represents a user account.</source>
          <target state="translated">사용자는 사용자 계정을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d2b201b196f2c09ea10aa903c6f2d9d3642adbdc" translate="yes" xml:space="preserve">
          <source>User returns a Userinfo containing the provided username and no password set.</source>
          <target state="translated">사용자는 제공된 사용자 이름과 비밀번호를 설정하지 않은 Userinfo를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="68b7ed6f3fe5a5fff91e1492620a3db521e39f64" translate="yes" xml:space="preserve">
          <source>UserAgent returns the client's User-Agent, if sent in the request.</source>
          <target state="translated">UserAgent는 요청에서 전송 된 경우 클라이언트의 User-Agent를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4ea06ed977eda51c2aa11c6b438af4cabec784b4" translate="yes" xml:space="preserve">
          <source>UserCacheDir returns the default root directory to use for user-specific cached data. Users should create their own application-specific subdirectory within this one and use that.</source>
          <target state="translated">UserCacheDir은 사용자 별 캐시 데이터에 사용할 기본 루트 디렉토리를 반환합니다. 사용자는이 디렉토리 내에 고유 한 응용 프로그램 특정 서브 디렉토리를 작성하여 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="a2ed520c964d93e9ec6ba0898145eda2b4839b40" translate="yes" xml:space="preserve">
          <source>UserConfigDir returns the default root directory to use for user-specific configuration data. Users should create their own application-specific subdirectory within this one and use that.</source>
          <target state="translated">UserConfigDir은 사용자 별 구성 데이터에 사용할 기본 루트 디렉토리를 반환합니다. 사용자는이 디렉토리 내에 고유 한 응용 프로그램 특정 서브 디렉토리를 작성하여 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="28c75db53e54c3bd7c5a9e9bf84aa07645cd4dd7" translate="yes" xml:space="preserve">
          <source>UserHomeDir returns the current user's home directory.</source>
          <target state="translated">UserHomeDir은 현재 사용자의 홈 디렉토리를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e4af3b1e17fb9be937bdb3790d770684874f4388" translate="yes" xml:space="preserve">
          <source>UserPassword returns a Userinfo containing the provided username and password.</source>
          <target state="translated">UserPassword는 제공된 사용자 이름과 비밀번호가 포함 된 Userinfo를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="02f3110477b79296b9a835ccdda4c40254dba20b" translate="yes" xml:space="preserve">
          <source>UserTime returns the user CPU time of the exited process and its children.</source>
          <target state="translated">UserTime은 종료 된 프로세스 및 해당 자식의 사용자 CPU 시간을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="596b2947d671a1bd54b3952e3987a478fe9edb86" translate="yes" xml:space="preserve">
          <source>Username returns the username.</source>
          <target state="translated">사용자 이름은 사용자 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dc8f2880e32de7bce1932889e7d7d51c71d3c62a" translate="yes" xml:space="preserve">
          <source>Using GOOS=android matches build tags and files as for GOOS=linux in addition to android tags and files.</source>
          <target state="translated">GOOS = android를 사용하면 Android 태그 및 파일 외에 GOOS = linux와 마찬가지로 빌드 태그 및 파일과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="9ef58be31d291026b75b8271910eb178dd6cbe45" translate="yes" xml:space="preserve">
          <source>Using GOOS=illumos matches build tags and files as for GOOS=solaris in addition to illumos tags and files.</source>
          <target state="translated">GOOS = illumos를 사용하면 illumos 태그 및 파일 외에 GOOS = solaris와 마찬가지로 빌드 태그 및 파일을 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="c3fe6f0d858556f91b252b308d506eedd3cb2ddd" translate="yes" xml:space="preserve">
          <source>Using JS to include valid but untrusted JSON is not safe. A safe alternative is to parse the JSON with json.Unmarshal and then pass the resultant object into the template, where it will be converted to sanitized JSON when presented in a JavaScript context.</source>
          <target state="translated">JS를 사용하여 유효하지만 신뢰할 수없는 JSON을 포함하는 것은 안전하지 않습니다. 안전한 대안은 JSON을 json.Unmarshal로 구문 분석 한 다음 결과 객체를 템플릿으로 전달하면 JavaScript 컨텍스트에서 제시 될 때 위생 화 된 JSON으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="9d9125a7eed89278993fd187aca47dc4a1d76ad9" translate="yes" xml:space="preserve">
          <source>Using a nil Qualifier is equivalent to using (*Package).Path: the object is qualified by the import path, e.g., &quot;encoding/json.Marshal&quot;.</source>
          <target state="translated">nil 한정자를 사용하는 것은 (* Package) .Path를 사용하는 것과 같습니다. 경로 : 객체는 &quot;encoding / json.Marshal&quot;과 같은 가져 오기 경로로 한정됩니다.</target>
        </trans-unit>
        <trans-unit id="2513c3904b3d8adc521d8c82ea1568602dc6d76b" translate="yes" xml:space="preserve">
          <source>Uvarint</source>
          <target state="translated">Uvarint</target>
        </trans-unit>
        <trans-unit id="cd0cf1cee138a1f47260e7774925bd884f2375a8" translate="yes" xml:space="preserve">
          <source>Uvarint decodes a uint64 from buf and returns that value and the number of bytes read (&amp;gt; 0). If an error occurred, the value is 0 and the number of bytes n is &amp;lt;= 0 meaning:</source>
          <target state="translated">Uvarint는 buf에서 uint64를 디코딩하고 해당 값과 읽은 바이트 수 (&amp;gt; 0)를 반환합니다. 오류가 발생하면 값은 0이고 바이트 수 n은 &amp;lt;= 0을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="66771bf9a86898929e11d8280264a532271f941a" translate="yes" xml:space="preserve">
          <source>Val</source>
          <target state="translated">Val</target>
        </trans-unit>
        <trans-unit id="2bc81c70eb02eae4099191aef1e57849a8e8f03d" translate="yes" xml:space="preserve">
          <source>Val returns the constant's value.</source>
          <target state="translated">Val은 상수 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b0f7ad9f186c50db1236f5511239fa9e5948970e" translate="yes" xml:space="preserve">
          <source>Val returns the underlying value for a given constant. Since it returns an interface, it is up to the caller to type assert the result to the expected type. The possible dynamic return types are:</source>
          <target state="translated">Val은 주어진 상수의 기본 값을 반환합니다. 인터페이스를 반환하기 때문에 결과를 예상되는 유형으로 지정하는 것은 호출자에게 달려 있습니다. 가능한 동적 리턴 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2559cc6528d308a907426a71ef2ddf45113dcc96" translate="yes" xml:space="preserve">
          <source>Val returns the value associated with attribute Attr in Entry, or nil if there is no such attribute.</source>
          <target state="translated">Val은 항목의 속성 Attr과 관련된 값을 반환하거나 해당 속성이 없으면 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a4aefa35c3b5ad26cd56f18c500001b89f66a9ce" translate="yes" xml:space="preserve">
          <source>Valid</source>
          <target state="translated">Valid</target>
        </trans-unit>
        <trans-unit id="46c122fc5457cc399b8b858419e492a06b376755" translate="yes" xml:space="preserve">
          <source>Valid reports whether data is a valid JSON encoding.</source>
          <target state="translated">유효한 데이터가 유효한 JSON 인코딩인지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="806cc965cf7a7b71a612856c03f868243e886f5c" translate="yes" xml:space="preserve">
          <source>Valid reports whether p consists entirely of valid UTF-8-encoded runes.</source>
          <target state="translated">유효한 p가 유효한 UTF-8로 인코딩 된 룬으로 구성되어 있는지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="2c3cda690d8c1884d7b10ef8e13e38f05dfb3167" translate="yes" xml:space="preserve">
          <source>ValidRune</source>
          <target state="translated">ValidRune</target>
        </trans-unit>
        <trans-unit id="3e8899c82439ff69d29e69515b50bcac879155d8" translate="yes" xml:space="preserve">
          <source>ValidRune reports whether r can be legally encoded as UTF-8. Code points that are out of range or a surrogate half are illegal.</source>
          <target state="translated">ValidRune은 r을 UTF-8로 합법적으로 인코딩 할 수 있는지 여부를보고합니다. 범위를 벗어나거나 대리 절반이 아닌 코드 포인트는 불법입니다.</target>
        </trans-unit>
        <trans-unit id="a9473e977cedeea3732bd1f0e634158b2fc8bc9c" translate="yes" xml:space="preserve">
          <source>ValidString</source>
          <target state="translated">ValidString</target>
        </trans-unit>
        <trans-unit id="1965e2764de3dba462118d2aa14e90df90d22255" translate="yes" xml:space="preserve">
          <source>ValidString reports whether s consists entirely of valid UTF-8-encoded runes.</source>
          <target state="translated">ValidString은 s가 유효한 UTF-8로 인코딩 된 룬으로 구성되어 있는지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="c0a9babdac4db73aebddcf7c19ed25ebb45d7a5b" translate="yes" xml:space="preserve">
          <source>Validate performs basic sanity checks on the key. It returns nil if the key is valid, or else an error describing a problem.</source>
          <target state="translated">유효성 검사는 키에서 기본 상태 검사를 수행합니다. 키가 유효하면 nil을 반환하거나 문제를 설명하는 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="884a21f08ecc170ab0e83923a5cddfcafa2f19e8" translate="yes" xml:space="preserve">
          <source>Validator may be implemented by Conn to allow drivers to signal if a connection is valid or if it should be discarded.</source>
          <target state="translated">Conn은 Validator를 구현하여 드라이버가 연결이 유효한지 아니면 폐기해야하는지 신호를 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8dce170de238b1feda2ecd9674ea3ca0d068fbcb" translate="yes" xml:space="preserve">
          <source>Value</source>
          <target state="translated">Value</target>
        </trans-unit>
        <trans-unit id="f3016ae4e1764c831e22db266c9f3792b104f577" translate="yes" xml:space="preserve">
          <source>Value (Config)</source>
          <target state="translated">값 (구성)</target>
        </trans-unit>
        <trans-unit id="3b939f106840debe33fe7912aa5a94c4386c469d" translate="yes" xml:space="preserve">
          <source>Value (ReadMostly)</source>
          <target state="translated">가치 (대부분 읽기)</target>
        </trans-unit>
        <trans-unit id="2a2d06d73feadc3e81a5b950d3c3a1578785b1f4" translate="yes" xml:space="preserve">
          <source>Value implements the driver Valuer interface.</source>
          <target state="translated">Value는 드라이버 Valuer 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="dd218fab688fcead8af77b81093aadd12637b021" translate="yes" xml:space="preserve">
          <source>Value is a value that drivers must be able to handle. It is either nil, a type handled by a database driver's NamedValueChecker interface, or an instance of one of these types:</source>
          <target state="translated">값은 운전자가 처리 할 수있는 값입니다. nil, 데이터베이스 드라이버의 NamedValueChecker 인터페이스에 의해 처리되는 유형 또는 다음 유형 중 하나의 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="9752a7f3e66998d9403b579aaf11f5b93a26f7c0" translate="yes" xml:space="preserve">
          <source>Value is the documentation for a (possibly grouped) var or const declaration.</source>
          <target state="translated">값은 (그룹화 된) var 또는 const 선언에 대한 문서입니다.</target>
        </trans-unit>
        <trans-unit id="fc8bc38b52edf0162032e19caad204a132e1edc6" translate="yes" xml:space="preserve">
          <source>Value is the interface to the dynamic value stored in a flag. (The default value is represented as a string.)</source>
          <target state="translated">Value는 플래그에 저장된 동적 값에 대한 인터페이스입니다. (기본값은 문자열로 표시됩니다.)</target>
        </trans-unit>
        <trans-unit id="2c289f13fb553c52397f1f031c283edf2f75ba5d" translate="yes" xml:space="preserve">
          <source>Value is the reflection interface to a Go value.</source>
          <target state="translated">Value는 Go 값에 대한 리플렉션 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="f874cfa2eae8a5288d6bb67626a8a5b202b1f1d3" translate="yes" xml:space="preserve">
          <source>Value represents a JavaScript value. The zero value is the JavaScript value &quot;undefined&quot;.</source>
          <target state="translated">값은 JavaScript 값을 나타냅니다. 0 값은 JavaScript 값 &quot;undefined&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="12bd1222cbe13b8343d523bcfbb727dc870d622e" translate="yes" xml:space="preserve">
          <source>Value represents a JavaScript value. The zero value is the JavaScript value &quot;undefined&quot;. Values can be checked for equality with the Equal method.</source>
          <target state="translated">값은 JavaScript 값을 나타냅니다. 0 값은 JavaScript 값 &quot;정의되지 않음&quot;입니다. Equal 메서드를 사용하여 값이 같은지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bea9dc918e0d02a53c6ed34890033d051d6e5b45" translate="yes" xml:space="preserve">
          <source>Value returns an arbitrary value of the given type. If the type implements the Generator interface, that will be used. Note: To create arbitrary values for structs, all the fields must be exported.</source>
          <target state="translated">값은 주어진 유형의 임의의 값을 반환합니다. 유형이 Generator 인터페이스를 구현하는 경우 해당 유형이 사용됩니다. 참고 : 구조체에 임의의 값을 만들려면 모든 필드를 내 보내야합니다.</target>
        </trans-unit>
        <trans-unit id="010d442068b6dc0c175fb3be2478e451331b7772" translate="yes" xml:space="preserve">
          <source>Value returns the value of the iterator's current map entry.</source>
          <target state="translated">Value는 반복자의 현재 맵 항목 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4814e1e8c0abd0c5b67abd9fa764cdfa19868250" translate="yes" xml:space="preserve">
          <source>ValueConverter is the interface providing the ConvertValue method.</source>
          <target state="translated">ValueConverter는 ConvertValue 메서드를 제공하는 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="4ee806fbc08f89d25017504477016f81d87178b9" translate="yes" xml:space="preserve">
          <source>ValueOf returns a new Value initialized to the concrete value stored in the interface i. ValueOf(nil) returns the zero Value.</source>
          <target state="translated">ValueOf는 인터페이스 i에 저장된 구체적인 값으로 초기화 된 새 값을 반환합니다. ValueOf (nil)은 0 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="73fa7582a50fd6ffa7153d229b6170f753731b5a" translate="yes" xml:space="preserve">
          <source>ValueOf returns x as a JavaScript value:</source>
          <target state="translated">ValueOf는 x를 JavaScript 값으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f18975e8d6052ff98ae55792b39100c67475c7da" translate="yes" xml:space="preserve">
          <source>Valuer is the interface providing the Value method.</source>
          <target state="translated">Valuer는 Value 메소드를 제공하는 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="b1564f6b1512cbfa3cfcebc9a5badb6b239954f1" translate="yes" xml:space="preserve">
          <source>Values</source>
          <target state="translated">Values</target>
        </trans-unit>
        <trans-unit id="4c4b32df8b9b0ab6cff257dc64ed3eb643572b49" translate="yes" xml:space="preserve">
          <source>Values containing the types defined in this package should not be copied.</source>
          <target state="translated">이 패키지에 정의 된 유형을 포함하는 값은 복사하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="db0f016ee293f8c7fb961ef81d6b041a8271fcde" translate="yes" xml:space="preserve">
          <source>Values maps a string key to a list of values. It is typically used for query parameters and form values. Unlike in the http.Header map, the keys in a Values map are case-sensitive.</source>
          <target state="translated">값은 문자열 키를 값 목록에 매핑합니다. 일반적으로 쿼리 매개 변수 및 양식 값에 사용됩니다. http.Header 맵과 달리 Values ​​맵의 키는 대소 문자를 구분합니다.</target>
        </trans-unit>
        <trans-unit id="ed9ae6e1ddce7aa950c188cea7070152cbaaef3a" translate="yes" xml:space="preserve">
          <source>Values of IMAGE_FILE_HEADER.Characteristics. These can be combined together.</source>
          <target state="translated">IMAGE_FILE_HEADER.Characteristics의 값. 이들은 함께 결합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1b6d5f206af70bb39bd5fc526ef574743992a54" translate="yes" xml:space="preserve">
          <source>Values of the Image interface are created either by calling functions such as NewRGBA and NewPaletted, or by calling Decode on an io.Reader containing image data in a format such as GIF, JPEG or PNG. Decoding any particular image format requires the prior registration of a decoder function. Registration is typically automatic as a side effect of initializing that format's package so that, to decode a PNG image, it suffices to have</source>
          <target state="translated">이미지 인터페이스의 값은 NewRGBA 및 NewPaletted와 같은 함수를 호출하거나 GIF, JPEG 또는 PNG와 같은 형식으로 이미지 데이터가 포함 된 io.Reader에서 Decode를 호출하여 생성됩니다. 특정 이미지 형식을 디코딩하려면 디코더 기능을 사전에 등록해야합니다. PNG 이미지를 디코딩하기 위해서는 해당 형식의 패키지를 초기화하는 부작용으로 일반적으로 등록이 자동으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="b65743fb1655a6d5656fe5188b8219e485d45a6c" translate="yes" xml:space="preserve">
          <source>Values returns all values associated with the given key. It is case insensitive; CanonicalMIMEHeaderKey is used to canonicalize the provided key. To use non-canonical keys, access the map directly. The returned slice is not a copy.</source>
          <target state="translated">값은 주어진 키와 관련된 모든 값을 반환합니다. 대소 문자를 구분하지 않습니다. CanonicalMIMEHeaderKey는 제공된 키를 정규화하는 데 사용됩니다. 비표준 키를 사용하려면지도에 직접 액세스하세요. 반환 된 슬라이스는 복사본이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="d0f032ed754eb781ca5f1ab9c0d5896202022c92" translate="yes" xml:space="preserve">
          <source>Values returns all values associated with the given key. It is case insensitive; textproto.CanonicalMIMEHeaderKey is used to canonicalize the provided key. To use non-canonical keys, access the map directly. The returned slice is not a copy.</source>
          <target state="translated">값은 주어진 키와 관련된 모든 값을 반환합니다. 대소 문자를 구분하지 않습니다. textproto.CanonicalMIMEHeaderKey는 제공된 키를 정규화하는 데 사용됩니다. 비표준 키를 사용하려면지도에 직접 액세스하세요. 반환 된 슬라이스는 복사본이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="556542fae1b8220ad354f73db7960fdf03643304" translate="yes" xml:space="preserve">
          <source>Values that are shared by both R_PPC and R_PPC64 are prefixed with R_POWERPC_ in the ELF standard. For the R_PPC type, the relevant shared relocations have been renamed with the prefix R_PPC_. The original name follows the value in a comment.</source>
          <target state="translated">R_PPC 및 R_PPC64가 공유하는 값은 ELF 표준에서 R_POWERPC_로 시작됩니다. R_PPC 유형의 경우 관련 공유 재배치의 이름이 접두사 R_PPC_로 바뀌 었습니다. 원래 이름은 주석의 값 뒤에옵니다.</target>
        </trans-unit>
        <trans-unit id="35513df4822daf6991ea9831d940cbcb44ab9510" translate="yes" xml:space="preserve">
          <source>Values that are shared by both R_PPC and R_PPC64 are prefixed with R_POWERPC_ in the ELF standard. For the R_PPC64 type, the relevant shared relocations have been renamed with the prefix R_PPC64_. The original name follows the value in a comment.</source>
          <target state="translated">R_PPC 및 R_PPC64가 공유하는 값은 ELF 표준에서 R_POWERPC_로 시작됩니다. R_PPC64 유형의 경우 관련 공유 재배치의 이름이 접두사 R_PPC64_로 바뀌 었습니다. 원래 이름은 주석의 값 뒤에옵니다.</target>
        </trans-unit>
        <trans-unit id="5491dd2526a7b6a12fe2eb7a45fdc97e08387c1a" translate="yes" xml:space="preserve">
          <source>Var defines a flag with the specified name and usage string. The type and value of the flag are represented by the first argument, of type Value, which typically holds a user-defined implementation of Value. For instance, the caller could create a flag that turns a comma-separated string into a slice of strings by giving the slice the methods of Value; in particular, Set would decompose the comma-separated string into the slice.</source>
          <target state="translated">Var는 지정된 이름과 사용 문자열로 플래그를 정의합니다. 플래그의 유형과 값은 일반적으로 사용자 정의 Value 구현을 보유하는 Value 유형의 첫 번째 인수로 표시됩니다. 예를 들어, 호출자는 슬라이스에 Value 메서드를 제공하여 쉼표로 구분 된 문자열을 문자열 조각으로 바꾸는 플래그를 만들 수 있습니다. 특히 Set은 쉼표로 구분 된 문자열을 슬라이스로 분해합니다.</target>
        </trans-unit>
        <trans-unit id="ce2b2698fd744904596b638fadb24e9ac560ff55" translate="yes" xml:space="preserve">
          <source>Var is an abstract type for all exported variables.</source>
          <target state="translated">Var은 내 보낸 모든 변수에 대한 추상 유형입니다.</target>
        </trans-unit>
        <trans-unit id="2fe39193f9c048f94aabb561a65b8ad4ebd4664a" translate="yes" xml:space="preserve">
          <source>VariableNode holds a list of variable names, possibly with chained field accesses. The dollar sign is part of the (first) name.</source>
          <target state="translated">VariableNode는 가능한 체인 필드 액세스와 함께 변수 이름 목록을 보유합니다. 달러 기호는 (이름) 이름의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="f9c863db27e83db40f4468fc4bc690e601042fdf" translate="yes" xml:space="preserve">
          <source>Variables previously declared can also be assigned, using the syntax</source>
          <target state="translated">구문을 사용하여 이전에 선언 된 변수를 할당 할 수도 있습니다</target>
        </trans-unit>
        <trans-unit id="ca11a0cc5def9c210a74faf8ede1798e07fe2571" translate="yes" xml:space="preserve">
          <source>Variadic reports whether the signature s is variadic.</source>
          <target state="translated">Variadic는 서명이 가변적인지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="41d79747265706c0afa494f13a1d7304f4478119" translate="yes" xml:space="preserve">
          <source>Varint</source>
          <target state="translated">Varint</target>
        </trans-unit>
        <trans-unit id="f5ebfb0ae8769b5ca2188331b009d7eba5a85341" translate="yes" xml:space="preserve">
          <source>Varint decodes an int64 from buf and returns that value and the number of bytes read (&amp;gt; 0). If an error occurred, the value is 0 and the number of bytes n is &amp;lt;= 0 with the following meaning:</source>
          <target state="translated">Varint는 buf에서 int64를 해독하고 그 값과 읽은 바이트 수 (&amp;gt; 0)를 반환합니다. 오류가 발생하면 값은 0이고 바이트 수 n은 &amp;lt;= 0이며 다음과 같은 의미입니다.</target>
        </trans-unit>
        <trans-unit id="d24fa62b1d834d7cd3cd0e8882051f85d094eda3" translate="yes" xml:space="preserve">
          <source>Various errors contained in OpError.</source>
          <target state="translated">OpError에 포함 된 다양한 오류.</target>
        </trans-unit>
        <trans-unit id="1a2978dcc531a211271eca6e53e9367381806a65" translate="yes" xml:space="preserve">
          <source>Various implementations of ValueConverter are provided by the driver package to provide consistent implementations of conversions between drivers. The ValueConverters have several uses:</source>
          <target state="translated">드라이버 간 변환의 일관된 구현을 제공하기 위해 드라이버 패키지에서 다양한 ValueConverter 구현을 제공합니다. ValueConverters는 여러 용도로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="677405d5dfca724a737bda64c6dc1ddb03f2bb84" translate="yes" xml:space="preserve">
          <source>Various isolation levels that drivers may support in BeginTx. If a driver does not support a given isolation level an error may be returned.</source>
          <target state="translated">드라이버가 BeginTx에서 지원할 수있는 다양한 격리 수준. 드라이버가 지정된 격리 수준을 지원하지 않으면 오류가 반환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc21bbee9a9b0425c95545ecf2f53bc29369d55b" translate="yes" xml:space="preserve">
          <source>Various methods support conversions between strings and corresponding numeric values, and vice versa: *Int, *Rat, and *Float values implement the Stringer interface for a (default) string representation of the value, but also provide SetString methods to initialize a value from a string in a variety of supported formats (see the respective SetString documentation).</source>
          <target state="translated">* Int, * Rat 및 * Float 값은 값의 (기본) 문자열 표현을위한 Stringer 인터페이스를 구현하지만 SetString 메소드를 제공하여 값을 초기화합니다. 지원되는 다양한 형식의 문자열 (각 SetString 설명서 참조)</target>
        </trans-unit>
        <trans-unit id="fe5502979be4e45317e06e3f4bc8dea3c27b9d68" translate="yes" xml:space="preserve">
          <source>Verbose reports whether the -test.v flag is set.</source>
          <target state="translated">상세는 -test.v 플래그 설정 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="155a05e64e4d5e6d0dbf5afad455ef4b2c7d215e" translate="yes" xml:space="preserve">
          <source>Verify attempts to verify c by building one or more chains from c to a certificate in opts.Roots, using certificates in opts.Intermediates if needed. If successful, it returns one or more chains where the first element of the chain is c and the last element is from opts.Roots.</source>
          <target state="translated">필요한 경우 opts.Intermediates의 인증서를 사용하여 c에서 opts.Roots의 인증서로 하나 이상의 체인을 빌드하여 c를 확인하려는 시도를 확인하십시오. 성공하면 체인의 첫 번째 요소가 c이고 마지막 요소가 opts.Roots 인 하나 이상의 체인을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8f646662ac01cb1ef7a3f3dbe169c861f558bcfa" translate="yes" xml:space="preserve">
          <source>Verify checks the validity of an email address on the server. If Verify returns nil, the address is valid. A non-nil return does not necessarily indicate an invalid address. Many servers will not verify addresses for security reasons.</source>
          <target state="translated">확인은 서버에서 이메일 주소의 유효성을 확인합니다. Verify가 nil을 반환하면 주소가 유효합니다. 0이 아닌 리턴이 반드시 유효하지 않은 주소를 나타내는 것은 아닙니다. 많은 서버가 보안상의 이유로 주소를 확인하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5f78fb77229812b310f6d30ba2f8eeb1a758e0db" translate="yes" xml:space="preserve">
          <source>Verify reports whether sig is a valid signature of message by publicKey. It will panic if len(publicKey) is not PublicKeySize.</source>
          <target state="translated">확인은 sig가 publicKey에 의해 유효한 메시지 서명인지보고합니다. len (publicKey)이 PublicKeySize가 아닌 경우 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="afa19e9e5042f2e1366a51a651d0d42c62c9a9dc" translate="yes" xml:space="preserve">
          <source>Verify verifies the signature in r, s of hash using the public key, pub. It reports whether the signature is valid.</source>
          <target state="translated">공개 키 pub를 사용하여 해시의 r, s로 서명을 확인하십시오. 서명이 유효한지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="29e311050b6e4da19e97375079ff2944ac6c7fb5" translate="yes" xml:space="preserve">
          <source>Verify verifies the signature in r, s of hash using the public key, pub. Its return value records whether the signature is valid.</source>
          <target state="translated">공개 키 pub를 사용하여 해시의 r, s로 서명을 확인하십시오. 리턴 값은 서명이 유효한지 여부를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="145232aacf42696b4e278956de6bab24512004cd" translate="yes" xml:space="preserve">
          <source>VerifyASN1 verifies the ASN.1 encoded signature, sig, of hash using the public key, pub. Its return value records whether the signature is valid.</source>
          <target state="translated">VerifyASN1은 공개 키 pub를 사용하여 해시의 ASN.1 인코딩 서명 sig를 확인합니다. 반환 값은 서명이 유효한지 여부를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="c77ce67480dc146ec9f71541bb8eac40755f84ee" translate="yes" xml:space="preserve">
          <source>VerifyHostname checks that the peer certificate chain is valid for connecting to host. If so, it returns nil; if not, it returns an error describing the problem.</source>
          <target state="translated">VerifyHostname은 피어 인증서 체인이 호스트에 연결하기에 유효한지 확인합니다. 그렇다면 nil을 반환합니다. 그렇지 않으면 문제를 설명하는 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4d87443c0e8c5a2665736c35fe304b37073dc32e" translate="yes" xml:space="preserve">
          <source>VerifyHostname returns nil if c is a valid certificate for the named host. Otherwise it returns an error describing the mismatch.</source>
          <target state="translated">c가 명명 된 호스트에 유효한 인증서 인 경우 VerifyHostname은 nil을 반환합니다. 그렇지 않으면 불일치를 설명하는 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f86ef4530b45b573b44981bfecb27623cddb836c" translate="yes" xml:space="preserve">
          <source>VerifyOptions contains parameters for Certificate.Verify.</source>
          <target state="translated">VerifyOptions에는 Certificate.Verify에 대한 매개 변수가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3cca137a6af7f592d32076ad3b96f2dd532d13e4" translate="yes" xml:space="preserve">
          <source>VerifyOptions contains parameters for Certificate.Verify. It's a structure because other PKIX verification APIs have ended up needing many options.</source>
          <target state="translated">VerifyOptions에는 Certificate.Verify에 대한 매개 변수가 포함되어 있습니다. 다른 PKIX 검증 API에는 많은 옵션이 필요하기 때문에 구조입니다.</target>
        </trans-unit>
        <trans-unit id="904631d00687a7288866da49169708056e59b147" translate="yes" xml:space="preserve">
          <source>VerifyPKCS1v15</source>
          <target state="translated">VerifyPKCS1v15</target>
        </trans-unit>
        <trans-unit id="03648c01c4f8ec482385a7d7d5a6f43278916d7d" translate="yes" xml:space="preserve">
          <source>VerifyPKCS1v15 verifies an RSA PKCS #1 v1.5 signature. hashed is the result of hashing the input message using the given hash function and sig is the signature. A valid signature is indicated by returning a nil error. If hash is zero then hashed is used directly. This isn't advisable except for interoperability.</source>
          <target state="translated">VerifyPKCS1v15는 RSA PKCS # 1 v1.5 서명을 확인합니다. hashed는 주어진 해시 함수를 사용하여 입력 메시지를 해싱 한 결과이고 sig는 서명입니다. 유효한 서명은 nil 오류를 반환하여 표시됩니다. 해시가 0이면 해시가 직접 사용됩니다. 이것은 상호 운용성을 제외하고는 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7fac2ac8cef2b4f2fce0053008362560cd0a7f6f" translate="yes" xml:space="preserve">
          <source>VerifyPKCS1v15 verifies an RSA PKCS#1 v1.5 signature. hashed is the result of hashing the input message using the given hash function and sig is the signature. A valid signature is indicated by returning a nil error. If hash is zero then hashed is used directly. This isn't advisable except for interoperability.</source>
          <target state="translated">VerifyPKCS1v15는 RSA PKCS # 1 v1.5 서명을 확인합니다. 해시는 주어진 해시 함수를 사용하여 입력 메시지를 해시 한 결과이고 sig는 서명입니다. 유효한 서명은 nil 오류를 반환하여 표시됩니다. 해시가 0이면 해시가 직접 사용됩니다. 상호 운용성을 제외하고는 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="22849df5c99a08214a361cc786e111d1f4ddafec" translate="yes" xml:space="preserve">
          <source>VerifyPSS verifies a PSS signature.</source>
          <target state="translated">VerifyPSS는 PSS 서명을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="a12022e4f1f957db46b6ad31ae0c6d8b5b335f06" translate="yes" xml:space="preserve">
          <source>VerifyPSS verifies a PSS signature. hashed is the result of hashing the input message using the given hash function and sig is the signature. A valid signature is indicated by returning a nil error. The opts argument may be nil, in which case sensible defaults are used.</source>
          <target state="translated">VerifyPSS는 PSS 서명을 확인합니다. 해시는 주어진 해시 함수를 사용하여 입력 메시지를 해시 한 결과이고 sig는 서명입니다. 유효한 서명은 nil 오류를 반환하여 표시됩니다. opts 인수는 nil 일 수 있으며이 경우 적절한 기본값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fc50bdb16e95dd81d5ab93336a4873d743e71e10" translate="yes" xml:space="preserve">
          <source>Version is found in Header.Ident[EI_VERSION] and Header.Version.</source>
          <target state="translated">버전은 Header.Ident [EI_VERSION] 및 Header.Version에 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d5c372788d86ffb1bb307fe18c33d0d35dfaf32" translate="yes" xml:space="preserve">
          <source>Version is the Unicode edition from which the tables are derived.</source>
          <target state="translated">버전은 테이블이 파생 된 유니 코드 버전입니다.</target>
        </trans-unit>
        <trans-unit id="50de89df378f68937423c4c0b0df29cc9d671898" translate="yes" xml:space="preserve">
          <source>Version returns the Go tree's version string. It is either the commit hash and date at the time of the build or, when possible, a release tag like &quot;go1.3&quot;.</source>
          <target state="translated">Version은 Go Tree의 버전 문자열을 반환합니다. 빌드 시점의 커밋 해시 및 날짜이거나 가능한 경우 &quot;go1.3&quot;과 같은 릴리스 태그입니다.</target>
        </trans-unit>
        <trans-unit id="a9f8b9e002c84b093e85fe6340e9e2446c0f01f6" translate="yes" xml:space="preserve">
          <source>Very large values overflow to -1 or +Inf.</source>
          <target state="translated">매우 큰 값은 -1 또는 + Inf로 오버플로됩니다.</target>
        </trans-unit>
        <trans-unit id="62ec9d14e878063c7140d04d700991af277e0332" translate="yes" xml:space="preserve">
          <source>Very large values overflow to 0 or +Inf. Very small values underflow to 1.</source>
          <target state="translated">매우 큰 값은 0 또는 + Inf로 오버플로됩니다. 매우 작은 값은 1로 유입됩니다.</target>
        </trans-unit>
        <trans-unit id="548f7438120baf452d57249c7ed1e4259eddd666" translate="yes" xml:space="preserve">
          <source>Visit visits the command-line flags in lexicographical order, calling fn for each. It visits only those flags that have been set.</source>
          <target state="translated">방문은 명령 행 플래그를 사전 식 순서로 방문하고 각각에 대해 fn을 호출합니다. 설정된 플래그 만 방문합니다.</target>
        </trans-unit>
        <trans-unit id="3d71d97888658f2741fa47ca0e6dafd3ee5bd8d5" translate="yes" xml:space="preserve">
          <source>Visit visits the flags in lexicographical order, calling fn for each. It visits only those flags that have been set.</source>
          <target state="translated">방문은 사전에 순서대로 플래그를 방문하고 각각에 대해 fn을 호출합니다. 설정된 플래그 만 방문합니다.</target>
        </trans-unit>
        <trans-unit id="fe139ba7798500e37c921c3f2eca473d92def875" translate="yes" xml:space="preserve">
          <source>VisitAll visits the command-line flags in lexicographical order, calling fn for each. It visits all flags, even those not set.</source>
          <target state="translated">VisitAll은 명령 행 플래그를 사전 식 순서로 방문하고 각각에 대해 fn을 호출합니다. 설정되지 않은 플래그까지 모든 플래그를 방문합니다.</target>
        </trans-unit>
        <trans-unit id="91926cb218ad9a9f08c7f40210f9b3b594b76515" translate="yes" xml:space="preserve">
          <source>VisitAll visits the flags in lexicographical order, calling fn for each. It visits all flags, even those not set.</source>
          <target state="translated">VisitAll은 각각 fn을 호출하여 사전 순으로 플래그를 방문합니다. 설정되지 않은 플래그까지 모든 플래그를 방문합니다.</target>
        </trans-unit>
        <trans-unit id="82b27aedf84d8e8a368898854887f1a9db2938b6" translate="yes" xml:space="preserve">
          <source>VolumeName returns leading volume name. Given &quot;C:\foo\bar&quot; it returns &quot;C:&quot; on Windows. Given &quot;\\host\share\foo&quot; it returns &quot;\\host\share&quot;. On other platforms it returns &quot;&quot;.</source>
          <target state="translated">VolumeName은 선행 볼륨 이름을 반환합니다. &quot;C : \ foo \ bar&quot;가 주어지면 Windows에서 &quot;C :&quot;를 반환합니다. &quot;\\ host \ share \ foo&quot;가 주어지면 &quot;\\ host \ share&quot;를 반환합니다. 다른 플랫폼에서는 &quot;&quot;를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="116af4a220931a113874c3a9a8fb8b67e737c229" translate="yes" xml:space="preserve">
          <source>WARNING: this function doesn't do any revocation checking.</source>
          <target state="translated">경고 :이 기능은 해지 확인을 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ac3ed0238ed01e1e125ce49b809e2689db256bfa" translate="yes" xml:space="preserve">
          <source>WARNING: use of this function to encrypt plaintexts other than session keys is dangerous. Use RSA OAEP in new protocols.</source>
          <target state="translated">경고 :이 기능을 사용하여 세션 키 이외의 일반 텍스트를 암호화하는 것은 위험합니다. 새로운 프로토콜에 RSA OAEP를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d791440e471e57ef06317ea366a55351a6722e8d" translate="yes" xml:space="preserve">
          <source>Wait atomically unlocks c.L and suspends execution of the calling goroutine. After later resuming execution, Wait locks c.L before returning. Unlike in other systems, Wait cannot return unless awoken by Broadcast or Signal.</source>
          <target state="translated">대기는 원자 적으로 cL을 잠금 해제하고 호출 고 루틴의 실행을 일시 중단합니다. 나중에 실행을 다시 시작한 후 대기는 반환하기 전에 cL을 잠급니다. 다른 시스템과 달리 방송 또는 신호에 의해 깨어나지 않으면 대기는 되돌릴 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c1e4ec07809f552042a2744ebd76a1ff9cdfd927" translate="yes" xml:space="preserve">
          <source>Wait blocks until the WaitGroup counter is zero.</source>
          <target state="translated">WaitGroup 카운터가 0이 될 때까지 대기합니다.</target>
        </trans-unit>
        <trans-unit id="a2b93a450c159447eb449f1d44b9509d23d1eff8" translate="yes" xml:space="preserve">
          <source>Wait releases any resources associated with the Cmd.</source>
          <target state="translated">대기는 Cmd와 관련된 모든 리소스를 해제합니다.</target>
        </trans-unit>
        <trans-unit id="cecb6db143b18629c77edfdcfa6e40a828bd3ecd" translate="yes" xml:space="preserve">
          <source>Wait waits for the Process to exit, and then returns a ProcessState describing its status and an error, if any. Wait releases any resources associated with the Process. On most operating systems, the Process must be a child of the current process or an error will be returned.</source>
          <target state="translated">Wait는 프로세스가 종료 될 때까지 기다린 다음 해당 상태 및 오류 (있는 경우)를 설명하는 ProcessState를 반환합니다. 대기는 프로세스와 관련된 모든 자원을 해제합니다. 대부분의 운영 체제에서 프로세스는 현재 프로세스의 자식이어야합니다. 그렇지 않으면 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ef4d163f70a5558cd92581c6468ca54f951f10cb" translate="yes" xml:space="preserve">
          <source>Wait waits for the command to exit and waits for any copying to stdin or copying from stdout or stderr to complete.</source>
          <target state="translated">대기 명령이 종료 될 때까지 대기하고 stdin으로의 복사 또는 stdout 또는 stderr에서 복사가 완료 될 때까지 대기합니다.</target>
        </trans-unit>
        <trans-unit id="aea382006d640fdfa58d59c1e0ad39798008158f" translate="yes" xml:space="preserve">
          <source>Wait will close the pipe after seeing the command exit, so most callers need not close the pipe themselves. It is thus incorrect to call Wait before all reads from the pipe have completed. For the same reason, it is incorrect to call Run when using StdoutPipe. See the example for idiomatic usage.</source>
          <target state="translated">Wait는 명령 종료를 확인한 후 파이프를 닫으므로 대부분의 호출자가 파이프를 닫을 필요가 없습니다. 따라서 파이프의 모든 읽기가 완료되기 전에 Wait를 호출하는 것은 올바르지 않습니다. 같은 이유로 StdoutPipe를 사용할 때 Run을 호출하는 것은 올바르지 않습니다. 관용적 사용법에 대한 예를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4d3243a3ead84d3a842320a1e7a6c5fbcf29075e" translate="yes" xml:space="preserve">
          <source>Wait will close the pipe after seeing the command exit, so most callers need not close the pipe themselves. It is thus incorrect to call Wait before all reads from the pipe have completed. For the same reason, it is incorrect to use Run when using StderrPipe. See the StdoutPipe example for idiomatic usage.</source>
          <target state="translated">Wait는 명령 종료를 확인한 후 파이프를 닫으므로 대부분의 호출자가 파이프를 닫을 필요가 없습니다. 따라서 파이프의 모든 읽기가 완료되기 전에 Wait를 호출하는 것은 올바르지 않습니다. 같은 이유로 StderrPipe를 사용할 때 Run을 사용하는 것은 올바르지 않습니다. 관용적 사용법은 StdoutPipe 예제를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e61dcf7176445918332c5c75e515641021cd367b" translate="yes" xml:space="preserve">
          <source>Wait will close the pipe after seeing the command exit, so most callers need not close the pipe themselves; however, an implication is that it is incorrect to call Wait before all reads from the pipe have completed. For the same reason, it is incorrect to call Run when using StdoutPipe. See the example for idiomatic usage.</source>
          <target state="translated">대기는 명령 종료를 본 후 파이프를 닫을 것이므로 대부분의 호출자는 파이프 자체를 닫을 필요가 없습니다. 그러나 파이프에서 모든 읽기가 완료되기 전에 대기를 호출하는 것은 올바르지 않습니다. 같은 이유로 StdoutPipe를 사용할 때 Run을 호출하는 것은 올바르지 않습니다. 관용어 사용 예를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6e2d628a299984437542474f102b1e387913aa4f" translate="yes" xml:space="preserve">
          <source>Wait will close the pipe after seeing the command exit, so most callers need not close the pipe themselves; however, an implication is that it is incorrect to call Wait before all reads from the pipe have completed. For the same reason, it is incorrect to use Run when using StderrPipe. See the StdoutPipe example for idiomatic usage.</source>
          <target state="translated">대기는 명령 종료를 본 후 파이프를 닫을 것이므로 대부분의 호출자는 파이프 자체를 닫을 필요가 없습니다. 그러나 파이프에서 모든 읽기가 완료되기 전에 대기를 호출하는 것은 올바르지 않습니다. 같은 이유로 StderrPipe를 사용할 때 Run을 사용하는 것은 올바르지 않습니다. 관용적 사용법은 StdoutPipe 예제를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="66edd56a29d8f65f00197517346652171bdf474e" translate="yes" xml:space="preserve">
          <source>WaitGroup</source>
          <target state="translated">WaitGroup</target>
        </trans-unit>
        <trans-unit id="e0c705d18e3fae4506d7273bda6435690cdbde08" translate="yes" xml:space="preserve">
          <source>Walk</source>
          <target state="translated">Walk</target>
        </trans-unit>
        <trans-unit id="9272862a0570cd3c8a576242d0e65b3cfcf9dde3" translate="yes" xml:space="preserve">
          <source>Walk traverses an AST in depth-first order: It starts by calling v.Visit(node); node must not be nil. If the visitor w returned by v.Visit(node) is not nil, Walk is invoked recursively with visitor w for each of the non-nil children of node, followed by a call of w.Visit(nil).</source>
          <target state="translated">Walk는 AST를 깊이 우선 순서로 트래버스합니다. v.Visit (node); 노드는 0이 아니어야합니다. v.Visit (node)에 의해 리턴 된 방문자 w가 nil이 아닌 경우, 노드의 nil이 아닌 각 하위 노드에 대해 방문자 w와 함께 Walk가 재귀 적으로 호출 된 후 w.Visit (nil)가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="844997b7d380cfffe958c2b4b63e117129683358" translate="yes" xml:space="preserve">
          <source>Walk walks the file tree rooted at root, calling walkFn for each file or directory in the tree, including root. All errors that arise visiting files and directories are filtered by walkFn. The files are walked in lexical order, which makes the output deterministic but means that for very large directories Walk can be inefficient. Walk does not follow symbolic links.</source>
          <target state="translated">Walk는 루트를 기반으로하는 파일 트리를 걷고 루트를 포함하여 트리의 각 파일 또는 디렉토리에 대해 walkFn을 호출합니다. 파일 및 디렉토리 방문시 발생하는 모든 오류는 walkFn으로 필터링됩니다. 파일은 어휘 순서로 표시되므로 출력이 결정적이지만 매우 큰 디렉토리의 경우 Walk가 비효율적 일 수 있습니다. 도보는 기호 링크를 따르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ea8fd18744a5b8a94a61df0e6be7f9d622440bee" translate="yes" xml:space="preserve">
          <source>WalkFunc is the type of the function called for each file or directory visited by Walk. The path argument contains the argument to Walk as a prefix; that is, if Walk is called with &quot;dir&quot;, which is a directory containing the file &quot;a&quot;, the walk function will be called with argument &quot;dir/a&quot;. The info argument is the os.FileInfo for the named path.</source>
          <target state="translated">WalkFunc는 Walk가 방문한 각 파일 또는 디렉토리에 대해 호출되는 함수 유형입니다. path 인수에는 Walk를 접두사로 사용하는 인수가 포함됩니다. 즉, &quot;a&quot;파일을 포함하는 디렉토리 인 &quot;dir&quot;을 사용하여 Walk를 호출하면 &quot;dir / a&quot;인수를 사용하여 walk 함수가 호출됩니다. info 인수는 명명 된 경로의 os.FileInfo입니다.</target>
        </trans-unit>
        <trans-unit id="2918ed6d5c509e3ed1b93a9bceda4782bc8dd955" translate="yes" xml:space="preserve">
          <source>Warning logs a message with severity LOG_WARNING, ignoring the severity passed to New.</source>
          <target state="translated">경고는 심각도가 LOG_WARNING 인 메시지를 기록하며 심각도는 New로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="6dda0897da5609f90207d91adc268a59c4a1ed0a" translate="yes" xml:space="preserve">
          <source>We define codes for each error that manifests while escaping templates, but escaped templates may also fail at runtime.</source>
          <target state="translated">템플릿을 이스케이프하는 동안 나타나는 각 오류에 대한 코드를 정의하지만 이스케이프 된 템플릿도 런타임에 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c1d860c4500491f651fd6c28babc0fc5252a9c1" translate="yes" xml:space="preserve">
          <source>WebSafe is a 216-color palette that was popularized by early versions of Netscape Navigator. It is also known as the Netscape Color Cube.</source>
          <target state="translated">WebSafe는 초기 버전의 Netscape Navigator에서 대중화 된 216 색 팔레트입니다. Netscape Color Cube라고도합니다.</target>
        </trans-unit>
        <trans-unit id="9b612a9be3daa519fe810c831ee09c50cb694cd9" translate="yes" xml:space="preserve">
          <source>Weekday returns the day of the week specified by t.</source>
          <target state="translated">Weekday는 t로 지정된 요일을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f665bbd01fb3804e446b49c63f8771aa2a58f0dc" translate="yes" xml:space="preserve">
          <source>Well-known IPv4 addresses</source>
          <target state="translated">잘 알려진 IPv4 주소</target>
        </trans-unit>
        <trans-unit id="d1c37cf7857b91d487793e2b066aa7768c44b584" translate="yes" xml:space="preserve">
          <source>Well-known IPv6 addresses</source>
          <target state="translated">잘 알려진 IPv6 주소</target>
        </trans-unit>
        <trans-unit id="423b2ce203c11b513c12b2cf5a302bece806d9e9" translate="yes" xml:space="preserve">
          <source>When Go code is built with options like -buildmode=c-shared, it will be run as part of an existing non-Go program. The non-Go code may have already installed signal handlers when the Go code starts (that may also happen in unusual cases when using cgo or SWIG; in that case, the discussion here applies). For -buildmode=c-archive the Go runtime will initialize signals at global constructor time. For -buildmode=c-shared the Go runtime will initialize signals when the shared library is loaded.</source>
          <target state="translated">Go 코드가 -buildmode = c-shared와 같은 옵션으로 빌드되면 기존 비 Go 프로그램의 일부로 실행됩니다. Go 코드가 시작될 때 비 Go 코드에 이미 신호 처리기가 설치되어있을 수 있습니다 (cgo 또는 SWIG를 사용할 때 비정상적인 경우에도 발생할 수 있습니다.이 경우 여기에 설명 된 내용이 적용됨). -buildmode = c-archive의 경우 Go 런타임은 전역 생성자 시간에 신호를 초기화합니다. -buildmode = c-shared의 경우 Go 런타임은 공유 라이브러리가로드 될 때 신호를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="157b3f39795f3c1bb26d85adf87f02f3367ef226" translate="yes" xml:space="preserve">
          <source>When Read encounters an error or end-of-file condition after successfully reading n &amp;gt; 0 bytes, it returns the number of bytes read. It may return the (non-nil) error from the same call or return the error (and n == 0) from a subsequent call. An instance of this general case is that a Reader returning a non-zero number of bytes at the end of the input stream may return either err == EOF or err == nil. The next Read should return 0, EOF.</source>
          <target state="translated">읽기&amp;gt; n&amp;gt; 0 바이트를 읽은 후 오류 또는 파일 끝 조건이 발생하면 읽은 바이트 수를 반환합니다. 동일한 호출에서 (0이 아닌) 오류를 반환하거나 후속 호출에서 오류 (및 n == 0)를 반환 할 수 있습니다. 이 일반적인 경우의 예는 입력 스트림의 끝에서 0이 아닌 바이트 수를 리턴하는 Reader가 err == EOF 또는 err == nil을 리턴 할 수 있다는 것입니다. 다음 읽기는 0, EOF를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="d6278f9f812d1e00a798b88f0d43a4c07f1b736e" translate="yes" xml:space="preserve">
          <source>When ReadAt returns n &amp;lt; len(p), it returns a non-nil error explaining why more bytes were not returned. In this respect, ReadAt is stricter than Read.</source>
          <target state="translated">ReadAt가 n &amp;lt;len (p)를 반환하면 더 많은 바이트가 반환되지 않은 이유를 설명하는 넌이 아닌 오류를 반환합니다. 이와 관련하여 ReadAt는 Read보다 엄격합니다.</target>
        </trans-unit>
        <trans-unit id="e42e8857e0f2dbf41e5d11d0b713339895c2d306" translate="yes" xml:space="preserve">
          <source>When Shutdown is called, Serve, ListenAndServe, and ListenAndServeTLS immediately return ErrServerClosed. Make sure the program doesn't exit and waits instead for Shutdown to return.</source>
          <target state="translated">Shutdown이 호출되면 Serve, ListenAndServe 및 ListenAndServeTLS는 즉시 ErrServerClosed를 반환합니다. 프로그램이 종료되지 않고 종료가 다시 나타날 때까지 기다리십시오.</target>
        </trans-unit>
        <trans-unit id="a1346033e8cd0c36ddc0423c4dcbbce227d0c225" translate="yes" xml:space="preserve">
          <source>When TestMain is called, flag.Parse has not been run. If TestMain depends on command-line flags, including those of the testing package, it should call flag.Parse explicitly. Command line flags are always parsed by the time test or benchmark functions run.</source>
          <target state="translated">TestMain이 호출되면 flag.Parse가 실행되지 않았습니다. TestMain이 테스트 패키지의 플래그를 포함하여 명령 줄 플래그에 의존하는 경우 flag.Parse를 명시 적으로 호출해야합니다. 명령 줄 플래그는 항상 시간 테스트 또는 벤치 마크 함수가 실행될 때 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="52cedf2625524a5c08d35a591f2ee66394bc79d6" translate="yes" xml:space="preserve">
          <source>When Token encounters an error or end-of-file condition after successfully reading a token, it returns the token. It may return the (non-nil) error from the same call or return the error (and a nil token) from a subsequent call. An instance of this general case is that a TokenReader returning a non-nil token at the end of the token stream may return either io.EOF or a nil error. The next Read should return nil, io.EOF.</source>
          <target state="translated">토큰을 읽은 후 토큰에 오류 또는 파일 끝 조건이 발생하면 토큰을 리턴합니다. 동일한 호출에서 (없음이 아닌) 오류를 반환하거나 후속 호출에서 오류 (및 없음 토큰)를 반환 할 수 있습니다. 이 일반적인 경우의 예는 토큰 스트림의 끝에서 넌이 아닌 토큰을 반환하는 TokenReader가 io.EOF 또는 nil 오류를 반환 할 수 있다는 것입니다. 다음 읽기는 nil, io.EOF를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="3250a941e5738a81aa69e5097500ef947e64f456" translate="yes" xml:space="preserve">
          <source>When a Go program writes to a broken pipe, the kernel will raise a SIGPIPE signal.</source>
          <target state="translated">Go 프로그램이 깨진 파이프에 쓰면 커널은 SIGPIPE 신호를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="ed858d1cf0b08d8b30624984289eaf84deee9351" translate="yes" xml:space="preserve">
          <source>When a data value is not plain text, you can make sure it is not over-escaped by marking it with its type.</source>
          <target state="translated">데이터 값이 일반 텍스트가 아닌 경우 해당 유형으로 표시하여 과도하게 이스케이프되지 않도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dcc36ea4f1110a5d9628600e555148a98813c271" translate="yes" xml:space="preserve">
          <source>When a plugin is first opened, the init functions of all packages not already part of the program are called. The main function is not run. A plugin is only initialized once, and cannot be closed.</source>
          <target state="translated">플러그인을 처음 열면 프로그램의 일부가 아닌 모든 패키지의 init 함수가 호출됩니다. 주 기능이 실행되지 않습니다. 플러그인은 한 번만 초기화되며 닫을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="34098c7334f20e516928585d3dd596a221004580" translate="yes" xml:space="preserve">
          <source>When adding a new file, a file base must be provided. That can be any integer value that is past the end of any interval of any file already in the file set. For convenience, FileSet.Base provides such a value, which is simply the end of the Pos interval of the most recently added file, plus one. Unless there is a need to extend an interval later, using the FileSet.Base should be used as argument for FileSet.AddFile.</source>
          <target state="translated">새 파일을 추가 할 때 파일 기반을 제공해야합니다. 파일 세트에 이미있는 파일의 간격 끝을 지난 정수 값일 수 있습니다. 편의를 위해 FileSet.Base는 가장 최근에 추가 된 파일의 Pos 간격에 1을 더한 값인 이러한 값을 제공합니다. 나중에 간격을 연장 할 필요가없는 한 FileSet.Base를 사용하여 FileSet.AddFile의 인수로 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="82668902c85167e64c6f0f47b4424c5d8da33aca" translate="yes" xml:space="preserve">
          <source>When calling SetCgoTraceback, the version argument is the version number of the structs that the functions expect to receive. Currently this must be zero.</source>
          <target state="translated">SetCgoTraceback을 호출 할 때 version 인수는 함수가받을 것으로 예상되는 구조체의 버전 번호입니다. 현재 이것은 0이어야합니다.</target>
        </trans-unit>
        <trans-unit id="bb4ae77735024f9be2c837577d3897cb72653910" translate="yes" xml:space="preserve">
          <source>When cgo is available, cgo-based (libc-backed) code is used by default. This can be overridden by using osusergo build tag, which enforces the pure Go implementation.</source>
          <target state="translated">cgo를 사용할 수있는 경우 cgo 기반 (libc 지원) 코드가 기본적으로 사용됩니다. 순수한 Go 구현을 강제하는 osusergo 빌드 태그를 사용하여이를 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="752b47af0ec8b502ec7dd916b2f8679be6d9d28e" translate="yes" xml:space="preserve">
          <source>When err is nil, resp always contains a non-nil resp.Body. Caller should close resp.Body when done reading from it.</source>
          <target state="translated">err이 nil 인 경우, resp는 항상 non-nil resp.Body를 포함합니다. 호출자는 읽은 후 resp.Body를 닫아야합니다.</target>
        </trans-unit>
        <trans-unit id="01d9fbd4a2ba2cf83a0b45d054350614384bbdc9" translate="yes" xml:space="preserve">
          <source>When execution begins, $ is set to the data argument passed to Execute, that is, to the starting value of dot.</source>
          <target state="translated">실행이 시작되면 $는 Execute에 전달 된 데이터 인수, 즉 dot의 시작 값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="8919d4f071112552ffa9917647b1e1053256e035" translate="yes" xml:space="preserve">
          <source>When following redirects, the Client will forward all headers set on the initial Request except:</source>
          <target state="translated">리디렉션을 수행하면 클라이언트는 다음을 제외하고 초기 요청에 설정된 모든 헤더를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="9524b6877cae25b318411b88de97b53bfbb0506c" translate="yes" xml:space="preserve">
          <source>When matching against text, the regexp returns a match that begins as early as possible in the input (leftmost), and among those it chooses the one that a backtracking search would have found first. This so-called leftmost-first matching is the same semantics that Perl, Python, and other implementations use, although this package implements it without the expense of backtracking. For POSIX leftmost-longest matching, see CompilePOSIX.</source>
          <target state="translated">텍스트와 일치하는 경우 정규 표현식은 입력 (가장 왼쪽)에서 가능한 한 빨리 시작되는 일치 항목을 반환하며 그 중에서 역 추적 검색에서 가장 먼저 찾은 항목을 선택합니다. 이 패키지는 백 트래킹 비용없이 구현하지만 Perl, Python 및 기타 구현에서 사용하는 것과 동일한 시맨틱입니다. POSIX 가장 왼쪽 일치 항목은 CompilePOSIX를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c6e22a9991087594c0b8cf7617afd5eef2db8623" translate="yes" xml:space="preserve">
          <source>When parsing a template, another template may be defined and associated with the template being parsed. Template definitions must appear at the top level of the template, much like global variables in a Go program.</source>
          <target state="translated">템플릿을 구문 분석 할 때 다른 템플릿이 정의되어 구문 분석중인 템플릿과 연관 될 수 있습니다. 템플릿 정의는 Go 프로그램의 전역 변수와 마찬가지로 템플릿의 최상위 수준에 나타나야합니다.</target>
        </trans-unit>
        <trans-unit id="017afe59414197ba093e7c01bd629debe47b73b4" translate="yes" xml:space="preserve">
          <source>When parsing a time with a zone abbreviation like MST, if the zone abbreviation has a defined offset in the current location, then that offset is used. The zone abbreviation &quot;UTC&quot; is recognized as UTC regardless of location. If the zone abbreviation is unknown, Parse records the time as being in a fabricated location with the given zone abbreviation and a zero offset. This choice means that such a time can be parsed and reformatted with the same layout losslessly, but the exact instant used in the representation will differ by the actual zone offset. To avoid such problems, prefer time layouts that use a numeric zone offset, or use ParseInLocation.</source>
          <target state="translated">MST와 같은 영역 약어로 시간을 구문 분석 할 때 영역 약어에 현재 위치에 정의 된 오프셋이 있으면 해당 오프셋이 사용됩니다. 영역 약어 &quot;UTC&quot;는 위치에 관계없이 UTC로 인식됩니다. 구역 약어를 알 수없는 경우 구문 분석은 주어진 구역 약어와 0 오프셋을 사용하여 제작 된 위치에있는 시간을 기록합니다. 이 선택은 이러한 시간을 무손실로 동일한 레이아웃으로 구문 분석하고 다시 포맷 할 수 있지만 표현에 사용 된 정확한 순간은 실제 영역 오프셋에 따라 다릅니다. 이러한 문제를 피하려면 숫자 영역 오프셋을 사용하거나 ParseInLocation을 사용하는 시간 레이아웃을 선호하십시오.</target>
        </trans-unit>
        <trans-unit id="6cdce46cbdd242d854181ed07c3441caefe581b7" translate="yes" xml:space="preserve">
          <source>When parsing a time with a zone offset like -0700, if the offset corresponds to a time zone used by the current location (Local), then Parse uses that location and zone in the returned time. Otherwise it records the time as being in a fabricated location with time fixed at the given zone offset.</source>
          <target state="translated">-0700과 같은 영역 오프셋을 사용하여 시간을 구문 분석 할 때 오프셋이 현재 위치 (Local)에서 사용하는 시간대에 해당하는 경우 Parse는 해당 위치와 영역을 반환 된 시간에 사용합니다. 그렇지 않으면 주어진 구역 오프셋에 고정 된 시간으로 제작 된 위치에있는 시간을 기록합니다.</target>
        </trans-unit>
        <trans-unit id="67cd941accf04bdb338f577638abdd5419252ad9" translate="yes" xml:space="preserve">
          <source>When parsing multiple files with the same name in different directories, the last one mentioned will be the one that results.</source>
          <target state="translated">다른 디렉토리에서 동일한 이름을 가진 여러 파일을 구문 분석 할 때 마지막으로 언급 된 파일이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="ddcdf8b97f4b2868ce974b91b64fece54bf4c923" translate="yes" xml:space="preserve">
          <source>When parsing multiple files with the same name in different directories, the last one mentioned will be the one that results. For instance, ParseFiles(&quot;a/foo&quot;, &quot;b/foo&quot;) stores &quot;b/foo&quot; as the template named &quot;foo&quot;, while &quot;a/foo&quot; is unavailable.</source>
          <target state="translated">다른 디렉토리에서 동일한 이름을 가진 여러 파일을 구문 분석 할 때 마지막으로 언급 된 파일이 생성됩니다. 예를 들어 ParseFiles ( &quot;a / foo&quot;, &quot;b / foo&quot;)는 &quot;b / foo&quot;를 &quot;foo&quot;라는 템플릿으로 저장하지만 &quot;a / foo&quot;는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="34e29899665d5e8ad85e485fb7f40717928c9cd2" translate="yes" xml:space="preserve">
          <source>When printing a struct, fmt cannot and therefore does not invoke formatting methods such as Error or String on unexported fields.</source>
          <target state="translated">구조체를 인쇄 할 때 fmt는 내 보내지 않은 필드에서 오류 또는 문자열과 같은 형식화 방법을 호출 할 수 없으므로 호출하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="328b930d804aecf09f06d9e00e3215a83c9fe31a" translate="yes" xml:space="preserve">
          <source>When running a large set of sequential test cases, checking Coverage after each one can be useful for identifying which test cases exercise new code paths. It is not a replacement for the reports generated by 'go test -cover' and 'go tool cover'.</source>
          <target state="translated">대량의 순차적 테스트 사례를 실행할 때 각 사례마다 적용 범위를 확인하면 새 코드 경로를 사용하는 테스트 사례를 식별하는 데 유용 할 수 있습니다. 'go test -cover'및 'go tool cover'로 생성 된 보고서를 대체하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="909e63ef88f23df70a053ead84b3a43d68a17641" translate="yes" xml:space="preserve">
          <source>When template execution invokes a function with an argument list, that list must be assignable to the function's parameter types. Functions meant to apply to arguments of arbitrary type can use parameters of type interface{} or of type reflect.Value. Similarly, functions meant to return a result of arbitrary type can return interface{} or reflect.Value.</source>
          <target state="translated">템플릿 실행이 인수 목록이있는 함수를 호출 할 때 해당 목록은 함수의 매개 변수 유형에 지정 가능해야합니다. 임의 유형의 인수에 적용되는 함수는 interface {} 유형 또는 reflect.Value 유형의 매개 변수를 사용할 수 있습니다. 마찬가지로, 임의 유형의 결과를 리턴하는 함수는 interface {}를 리턴하거나 리플렉션 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05dd6446129205c413b187abb37a98c5e685666d" translate="yes" xml:space="preserve">
          <source>When unmarshaling quoted strings, invalid UTF-8 or invalid UTF-16 surrogate pairs are not treated as an error. Instead, they are replaced by the Unicode replacement character U+FFFD.</source>
          <target state="translated">인용 된 문자열을 비 정렬화할 때 유효하지 않은 UTF-8 또는 유효하지 않은 UTF-16 서로 게이트 쌍은 오류로 처리되지 않습니다. 대신 유니 코드 대체 문자 U + FFFD로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="33fa3fdb7bbbbb81e834f8787f2ce9d1e3b0b605" translate="yes" xml:space="preserve">
          <source>When using TCP, and the host in the address parameter resolves to multiple network addresses, any dial timeout (from d.Timeout or ctx) is spread over each consecutive dial, such that each is given an appropriate fraction of the time to connect. For example, if a host has 4 IP addresses and the timeout is 1 minute, the connect to each single address will be given 15 seconds to complete before trying the next one.</source>
          <target state="translated">TCP를 사용하고 address 매개 변수의 호스트가 여러 네트워크 주소로 확인되면 모든 다이얼 시간 초과 (d.Timeout 또는 ctx에서)가 각 연속 다이얼에 분산되어 각 연결 시간에 적절한 비율이 제공됩니다. 예를 들어 호스트에 4 개의 IP 주소가 있고 시간 초과가 1 분인 경우 다음 주소를 시도하기 전에 각 단일 주소에 대한 연결이 완료되는 데 15 초가 걸립니다.</target>
        </trans-unit>
        <trans-unit id="81ad3fb58a9738071410987f567b6f63ba760aad" translate="yes" xml:space="preserve">
          <source>When using the host C library resolver, at most one result will be returned. To bypass the host resolver, use a custom Resolver.</source>
          <target state="translated">호스트 C 라이브러리 리졸버를 사용하는 경우 최대 하나의 결과가 리턴됩니다. 호스트 확인자를 무시하려면 사용자 지정 확인자를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b6af75ad725ff03ac3899006f586c6815dee0ab6" translate="yes" xml:space="preserve">
          <source>Whether and how a comment is associated with a node depends on the interpretation of the syntax tree by the manipulating program: Except for Doc and Comment comments directly associated with nodes, the remaining comments are &quot;free-floating&quot; (see also issues #18593, #20744).</source>
          <target state="translated">주석이 노드와 연관되는지 여부와 방법은 조작 프로그램에 의한 구문 트리의 해석에 따라 다릅니다. 노드와 직접 연관된 Doc 및 주석 주석을 제외하고 나머지 주석은 &quot;자유 부동&quot;입니다 (문제 # 18593, # 20744).</target>
        </trans-unit>
        <trans-unit id="1761aeba17f1966adf699cab82838ede9543b2ce" translate="yes" xml:space="preserve">
          <source>While it would be correct for the context function to record a complete a stack trace whenever it is called, and simply copy that out in the traceback function, in a typical program the context function will be called many times without ever recording a traceback for that context. Recording a complete stack trace in a call to the context function is likely to be inefficient.</source>
          <target state="translated">컨텍스트 함수가 호출 될 때마다 완전한 스택 추적을 기록하고 단순히 트레이스 백 함수에서이를 복사하는 것이 올바른 반면, 일반적인 프로그램에서는 컨텍스트 함수가 트레이스 백을 기록하지 않고 여러 번 호출됩니다. 문맥. 컨텍스트 함수에 대한 호출에서 완전한 스택 추적을 기록하는 것은 비효율적 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97ac8575a01bb9731d0aacbb0c00a32106d3caac" translate="yes" xml:space="preserve">
          <source>While the FileSystem.Open method takes '/'-separated paths, a Dir's string value is a filename on the native file system, not a URL, so it is separated by filepath.Separator, which isn't necessarily '/'.</source>
          <target state="translated">FileSystem.Open 메서드는 '/'로 구분 된 경로를 사용하지만 Dir의 문자열 값은 URL이 아닌 기본 파일 시스템의 파일 이름이므로 filepath.Separator로 구분되며 반드시 '/'일 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="7d448d6e99b8642847a099da6f3145e12a69b2bf" translate="yes" xml:space="preserve">
          <source>White space is considered part of a field.</source>
          <target state="translated">공백은 필드의 일부로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="3462ed046f134fdadd9007f0e6ba397654359adc" translate="yes" xml:space="preserve">
          <source>Width and precision are measured in units of Unicode code points, that is, runes. (This differs from C's printf where the units are always measured in bytes.) Either or both of the flags may be replaced with the character '*', causing their values to be obtained from the next operand (preceding the one to format), which must be of type int.</source>
          <target state="translated">너비와 정밀도는 유니 코드 코드 포인트, 즉 룬 단위로 측정됩니다. (이것은 단위가 항상 바이트 단위로 측정되는 C의 printf와 다릅니다.) 플래그 중 하나 또는 둘 다 문자 '*'로 대체되어 다음 피연산자에서 값을 얻을 수 있습니다 (앞서 포맷해야 함). int 형식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="285e52d2a4d90abe10ddf2c19e952396f894982a" translate="yes" xml:space="preserve">
          <source>Width is interpreted in the input text but there is no syntax for scanning with a precision (no %5.2f, just %5f). If width is provided, it applies after leading spaces are trimmed and specifies the maximum number of runes to read to satisfy the verb. For example,</source>
          <target state="translated">너비는 입력 텍스트에서 해석되지만 정밀하게 스캔하기위한 구문은 없습니다 (% 5.2f 없음, % 5f 만). 너비가 제공되면 선행 공백이 트리밍 된 후 적용되며 동사를 충족시키기 위해 읽을 최대 룬 수를 지정합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="798e2836ace5e24780c7dc5d76140278c0905170" translate="yes" xml:space="preserve">
          <source>Width is specified by an optional decimal number immediately preceding the verb. If absent, the width is whatever is necessary to represent the value. Precision is specified after the (optional) width by a period followed by a decimal number. If no period is present, a default precision is used. A period with no following number specifies a precision of zero. Examples:</source>
          <target state="translated">너비는 동사 바로 앞의 선택적 10 진수로 지정됩니다. 없는 경우 너비는 값을 나타내는 데 필요한 것입니다. 정밀도는 (선택적) 너비 뒤에 마침표와 10 진수로 지정됩니다. 마침표가 없으면 기본 정밀도가 사용됩니다. 다음 숫자가없는 기간은 정밀도 0을 지정합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="26d9c28d789c254f71ea99a3463b99a7ccc2f4fa" translate="yes" xml:space="preserve">
          <source>Windows</source>
          <target state="translated">Windows</target>
        </trans-unit>
        <trans-unit id="90527ca0c17e71be4b659b364a4632417bd48fd0" translate="yes" xml:space="preserve">
          <source>With HTTP Basic Authentication the provided username and password are not encrypted.</source>
          <target state="translated">HTTP 기본 인증을 사용하면 제공된 사용자 이름과 비밀번호가 암호화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9c7242429a52b5edef337779ea090fbcc2bb6019" translate="yes" xml:space="preserve">
          <source>With the exceptions of comments, which are skipped if SkipComments is set, unrecognized tokens are not ignored. Instead, the scanner simply returns the respective individual characters (or possibly sub-tokens). For instance, if the mode is ScanIdents (not ScanStrings), the string &quot;foo&quot; is scanned as the token sequence '&quot;' Ident '&quot;'.</source>
          <target state="translated">SkipComments가 설정되어 있으면 건너 뛰는 주석을 제외하고 인식 할 수없는 토큰은 무시되지 않습니다. 대신, 스캐너는 단순히 각각의 개별 문자 (또는 하위 토큰)를 반환합니다. 예를 들어, 모드가 ScanIdents (ScanStrings 아님) 인 경우 문자열 &quot;foo&quot;는 토큰 시퀀스 ' &quot;'Ident '&quot;'로 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="cfa2b7a12432ca7dde89800a43beb434b01e3ea5" translate="yes" xml:space="preserve">
          <source>WithCancel</source>
          <target state="translated">WithCancel</target>
        </trans-unit>
        <trans-unit id="10592d7ad2855a7180469ae213405203a2d50e89" translate="yes" xml:space="preserve">
          <source>WithCancel returns a copy of parent with a new Done channel. The returned context's Done channel is closed when the returned cancel function is called or when the parent context's Done channel is closed, whichever happens first.</source>
          <target state="translated">WithCancel은 새 완료 채널이있는 상위 사본을 리턴합니다. 리턴 된 취소 기능이 호출되거나 상위 컨텍스트의 완료 채널이 닫히면 리턴 된 컨텍스트의 완료 채널이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="2261f632aeaf0a3059b969971069ca975c9ce32e" translate="yes" xml:space="preserve">
          <source>WithClientTrace returns a new context based on the provided parent ctx. HTTP client requests made with the returned context will use the provided trace hooks, in addition to any previous hooks registered with ctx. Any hooks defined in the provided trace will be called first.</source>
          <target state="translated">WithClientTrace는 제공된 상위 ctx를 기반으로 새 컨텍스트를 리턴합니다. 리턴 된 컨텍스트로 작성된 HTTP 클라이언트 요청은 ctx에 등록 된 이전 후크 외에 제공된 추적 후크를 사용합니다. 제공된 추적에 정의 된 모든 후크가 먼저 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="f1cd36566b14c3bbf36e47b0c1cd6c5053972eb6" translate="yes" xml:space="preserve">
          <source>WithContext returns a shallow copy of r with its context changed to ctx. The provided ctx must be non-nil.</source>
          <target state="translated">WithContext는 컨텍스트가 ctx로 변경된 r의 얕은 사본을 리턴합니다. 제공된 ctx는 0이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="c81570667b5d5149acbef6b90b5b11ce74038f5e" translate="yes" xml:space="preserve">
          <source>WithDeadline</source>
          <target state="translated">WithDeadline</target>
        </trans-unit>
        <trans-unit id="4330da7d2b110737e8fe5953a232fb49e41e1165" translate="yes" xml:space="preserve">
          <source>WithDeadline returns a copy of the parent context with the deadline adjusted to be no later than d. If the parent's deadline is already earlier than d, WithDeadline(parent, d) is semantically equivalent to parent. The returned context's Done channel is closed when the deadline expires, when the returned cancel function is called, or when the parent context's Done channel is closed, whichever happens first.</source>
          <target state="translated">WithDeadline은 최종 기한이 d 이하로 조정 된 상위 컨텍스트의 사본을 리턴합니다. 부모의 최종 기한이 이미 d보다 빠르면 WithDeadline (parent, d)는 의미 적으로 부모와 같습니다. 반환 된 컨텍스트의 완료 채널은 최종 기한이 만료되거나 반환 된 취소 기능이 호출되거나 상위 컨텍스트의 완료 채널이 닫힐 때 먼저 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="7a280665a50cba23581e10e39947347ff060fae9" translate="yes" xml:space="preserve">
          <source>WithLabels returns a new context.Context with the given labels added. A label overwrites a prior label with the same key.</source>
          <target state="translated">WithLabels는 주어진 레이블이 추가 된 새로운 컨텍스트를 반환합니다. 레이블은 동일한 키로 이전 레이블을 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="236c68ad351c473bc67a76a1e7d06f3261fc4a99" translate="yes" xml:space="preserve">
          <source>WithNode represents a {{with}} action and its commands.</source>
          <target state="translated">WithNode는 {{with}} 작업 및 해당 명령을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="85e6eeaf95e5aa7f5b566d2c8422da42f9a49e6b" translate="yes" xml:space="preserve">
          <source>WithPadding creates a new encoding identical to enc except with a specified padding character, or NoPadding to disable padding. The padding character must not be '\r' or '\n', must not be contained in the encoding's alphabet and must be a rune equal or below '\xff'.</source>
          <target state="translated">WithPadding은 지정된 패딩 문자를 제외하고 enc와 동일한 새로운 인코딩을 생성하거나 패딩을 비활성화하려면 NoPadding을 생성합니다. 패딩 문자는 '\ r'또는 '\ n'이 아니어야하며 인코딩의 알파벳에 포함되어서는 안되며 '\ xff'이하의 룬이어야합니다.</target>
        </trans-unit>
        <trans-unit id="5778ff939e404ecb571d1f18f70396417807a915" translate="yes" xml:space="preserve">
          <source>WithRegion starts a region associated with its calling goroutine, runs fn, and then ends the region. If the context carries a task, the region is associated with the task. Otherwise, the region is attached to the background task.</source>
          <target state="translated">WithRegion은 호출 고 루틴과 연관된 영역을 시작하고 fn을 실행 한 다음 영역을 종료합니다. 컨텍스트가 작업을 수행하면 영역이 작업과 연결됩니다. 그렇지 않으면 영역이 백그라운드 작업에 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="62be5942fce8ef05c30b8e260f8696b13a223891" translate="yes" xml:space="preserve">
          <source>WithTimeout</source>
          <target state="translated">WithTimeout</target>
        </trans-unit>
        <trans-unit id="a33c8495b67fd90d2c81864d1a61ba4ce0d40352" translate="yes" xml:space="preserve">
          <source>WithTimeout returns WithDeadline(parent, time.Now().Add(timeout)).</source>
          <target state="translated">WithTimeout은 WithDeadline (parent, time.Now (). Add (timeout))을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="279940ad9c32263d7660d6c51743f4751457b645" translate="yes" xml:space="preserve">
          <source>WithValue</source>
          <target state="translated">WithValue</target>
        </trans-unit>
        <trans-unit id="2898c9db2caddba545b8a166da25b81ca353383a" translate="yes" xml:space="preserve">
          <source>WithValue returns a copy of parent in which the value associated with key is val.</source>
          <target state="translated">WithValue는 key와 연관된 값이 val 인 parent의 사본을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="dfe12e37662d514bcaf6fcc843d9df3dde82c783" translate="yes" xml:space="preserve">
          <source>Within a quoted-field a quote character followed by a second quote character is considered a single quote.</source>
          <target state="translated">따옴표로 묶인 필드 내에서 따옴표 문자와 두 번째 따옴표 문자는 작은 따옴표로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="901066df97460a79742d81059c2788736730f5c0" translate="yes" xml:space="preserve">
          <source>Within the format string, an underscore _ represents a space that may be replaced by a digit if the following number (a day) has two digits; for compatibility with fixed-width Unix time formats.</source>
          <target state="translated">형식 문자열 내에서 밑줄 _은 다음 숫자 (하루)에 두 자리 숫자가 있으면 숫자로 대체 될 수있는 공백을 나타냅니다. 고정 폭 Unix 시간 형식과의 호환성.</target>
        </trans-unit>
        <trans-unit id="1c2c5d43029917c507b88694188d3a95ec1f427e" translate="yes" xml:space="preserve">
          <source>Within these functions, use the Error, Fail or related methods to signal failure.</source>
          <target state="translated">이러한 기능 내에서 오류, 실패 또는 관련 방법을 사용하여 오류를 알립니다.</target>
        </trans-unit>
        <trans-unit id="4fb5cfd12779f801d815c760deefde65ff5bc667" translate="yes" xml:space="preserve">
          <source>Without the KeepAlive call, the finalizer could run at the start of syscall.Read, closing the file descriptor before syscall.Read makes the actual system call.</source>
          <target state="translated">KeepAlive 호출이 없으면 종료자는 syscall.Read 시작시 실행되어 syscall.Read가 실제 시스템 호출을 수행하기 전에 파일 디스크립터를 닫을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="428a7b20bf173784e9461082a1c6c2949a2b1583" translate="yes" xml:space="preserve">
          <source>WordDecoder.Decode</source>
          <target state="translated">WordDecoder.Decode</target>
        </trans-unit>
        <trans-unit id="122969737c394ec9bcddf4fffdb9da8fe8488ec1" translate="yes" xml:space="preserve">
          <source>WordDecoder.DecodeHeader</source>
          <target state="translated">WordDecoder.DecodeHeader</target>
        </trans-unit>
        <trans-unit id="ca26286ada26b2f279a44ca503bd79bc511af845" translate="yes" xml:space="preserve">
          <source>WordEncoder.Encode</source>
          <target state="translated">WordEncoder.Encode</target>
        </trans-unit>
        <trans-unit id="9edf039575eecbdc47593f3a3127b9885c19c419" translate="yes" xml:space="preserve">
          <source>Wrapper is implemented by types that are backed by a JavaScript value.</source>
          <target state="translated">랩퍼는 JavaScript 값이 지원하는 유형으로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="4a48932789d199bbed709777e2d743ca2bafdc6c" translate="yes" xml:space="preserve">
          <source>Write</source>
          <target state="translated">Write</target>
        </trans-unit>
        <trans-unit id="44c42e5743dc2d87774645171aeb25d381fb4f87" translate="yes" xml:space="preserve">
          <source>Write (Multi)</source>
          <target state="translated">쓰기 (멀티)</target>
        </trans-unit>
        <trans-unit id="5eb828845650151ac0990caac081e2cd286fb917" translate="yes" xml:space="preserve">
          <source>Write appends the contents of p to b's buffer. Write always returns len(p), nil.</source>
          <target state="translated">Write는 p의 내용을 b의 버퍼에 추가합니다. 쓰기는 항상 len (p), nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b973088870c119f57839cb1ba17bfc298f02ce66" translate="yes" xml:space="preserve">
          <source>Write appends the contents of p to the buffer, growing the buffer as needed. The return value n is the length of p; err is always nil. If the buffer becomes too large, Write will panic with ErrTooLarge.</source>
          <target state="translated">Write는 p의 내용을 버퍼에 추가하여 필요에 따라 버퍼를 증가시킵니다. 리턴 값 n은 p의 길이입니다. err는 항상 nil입니다. 버퍼가 너무 커지면 Write는 ErrTooLarge에 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="60ad0a48218711b95918ac117d9d0d440fb89fc0" translate="yes" xml:space="preserve">
          <source>Write calls encode to serialize the file set s.</source>
          <target state="translated">쓰기 호출은 파일 세트를 직렬화하기 위해 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="4d381bda5cffa89f8c78e5e9e48f6d22b0c0fe8a" translate="yes" xml:space="preserve">
          <source>Write encodes p using quoted-printable encoding and writes it to the underlying io.Writer. It limits line length to 76 characters. The encoded bytes are not necessarily flushed until the Writer is closed.</source>
          <target state="translated">쓰기는 인용 인쇄 가능한 인코딩을 사용하여 p를 인코딩하고 기본 io.Writer에 씁니다. 줄 길이를 76 자로 제한합니다. 기록기가 닫힐 때까지 인코딩 된 바이트가 반드시 플러시되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="abed405f7389701bb0c85514b2f8df63eaba5491" translate="yes" xml:space="preserve">
          <source>Write implements http.ResponseWriter. The data in buf is written to rw.Body, if not nil.</source>
          <target state="translated">쓰기는 http.ResponseWriter를 구현합니다. buf의 데이터는 0이 아닌 경우 rw.Body에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="0dd6308ff3bf6bfd3bf539e49da279261acb0c3a" translate="yes" xml:space="preserve">
          <source>Write implements the Conn Write method.</source>
          <target state="translated">Write는 Conn Write 메소드를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="40ae3050f43a58bc383d76e5c6844f88fe681399" translate="yes" xml:space="preserve">
          <source>Write implements the standard Write interface: it writes data to the pipe, blocking until one or more readers have consumed all the data or the read end is closed. If the read end is closed with an error, that err is returned as err; otherwise err is ErrClosedPipe.</source>
          <target state="translated">Write는 표준 Write 인터페이스를 구현합니다. 파이프에 데이터를 기록하여 하나 이상의 리더가 모든 데이터를 사용하거나 읽기 끝이 닫힐 때까지 차단합니다. 읽기 종료가 오류와 함께 닫히면 해당 err이 err로 리턴됩니다. 그렇지 않으면 err은 ErrClosedPipe입니다.</target>
        </trans-unit>
        <trans-unit id="9b4e831d3734f201df9676e633bc0a291038b26a" translate="yes" xml:space="preserve">
          <source>Write sends a log message to the syslog daemon.</source>
          <target state="translated">Write는 로그 메시지를 syslog 데몬으로 보냅니다.</target>
        </trans-unit>
        <trans-unit id="fcbd0cbe7dbf34b528b9d5e4c3ddbc95f5c5bc1c" translate="yes" xml:space="preserve">
          <source>Write writes a compressed form of p to the underlying io.Writer. The compressed bytes are not necessarily flushed until the Writer is closed or explicitly flushed.</source>
          <target state="translated">Write는 압축 된 형태의 p를 기본 io.Writer에 씁니다. Writer가 닫히거나 명시 적으로 플러시 될 때까지 압축 된 바이트가 반드시 플러시되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="df6d5ec5f9e15cdd83d68aca607ef7b43da4dca2" translate="yes" xml:space="preserve">
          <source>Write writes a compressed form of p to the underlying io.Writer. The compressed bytes are not necessarily flushed until the Writer is closed.</source>
          <target state="translated">Write는 압축 된 형태의 p를 기본 io.Writer에 씁니다. 기록기가 닫힐 때까지 압축 된 바이트가 반드시 플러시되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="f5afb6da9a73d93fa35e1f17efdeec955deb05f0" translate="yes" xml:space="preserve">
          <source>Write writes a header in wire format.</source>
          <target state="translated">쓰기는 헤더를 유선 형식으로 씁니다.</target>
        </trans-unit>
        <trans-unit id="1dd8b6e982bed7434f946dd63ac00a5595f87b17" translate="yes" xml:space="preserve">
          <source>Write writes a request. An ErrPersistEOF error is returned if the connection has been closed in an HTTP keep-alive sense. If req.Close equals true, the keep-alive connection is logically closed after this request and the opposing server is informed. An ErrUnexpectedEOF indicates the remote closed the underlying TCP connection, which is usually considered as graceful close.</source>
          <target state="translated">쓰기 요청을 씁니다. 연결이 HTTP 연결 유지 의미로 닫힌 경우 ErrPersistEOF 오류가 리턴됩니다. req.Close가 true이면이 요청 후에 연결 유지 연결이 논리적으로 닫히고 상대 서버에 알립니다. ErrUnexpectedEOF는 원격이 기본 TCP 연결을 닫았 음을 나타내며 일반적으로 정상 종료로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="c84078d3fc4fa89a2b25f7737991bb090acc5be4" translate="yes" xml:space="preserve">
          <source>Write writes a single CSV record to w along with any necessary quoting. A record is a slice of strings with each string being one field. Writes are buffered, so Flush must eventually be called to ensure that the record is written to the underlying io.Writer.</source>
          <target state="translated">쓰기는 필요한 인용 부호와 함께 단일 CSV 레코드를 w에 씁니다. 레코드는 각 문자열이 하나의 필드 인 문자열 조각입니다. 쓰기는 버퍼링되므로 레코드가 기본 io.Writer에 기록되도록 Flush를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="1b1f8c7998d40b420b2a6a020d42520c0cfdb552" translate="yes" xml:space="preserve">
          <source>Write writes an HTTP/1.1 request, which is the header and body, in wire format. This method consults the following fields of the request:</source>
          <target state="translated">쓰기는 헤더 및 본문 인 HTTP / 1.1 요청을 유선 형식으로 작성합니다. 이 방법은 요청의 다음 필드를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="0668c9219aeba7077b51b78a1b8f39636f232281" translate="yes" xml:space="preserve">
          <source>Write writes buf to the writer b. The only errors returned are ones encountered while writing to the underlying output stream.</source>
          <target state="translated">작가에게 buf를 쓴다. b. 반환되는 유일한 오류는 기본 출력 스트림에 쓰는 동안 발생한 오류입니다.</target>
        </trans-unit>
        <trans-unit id="82a04e0fc25183cb5f9b91509c74fe012f744729" translate="yes" xml:space="preserve">
          <source>Write writes data to the connection.</source>
          <target state="translated">쓰기는 연결에 데이터를 씁니다.</target>
        </trans-unit>
        <trans-unit id="ec334dcff7799f1d647716dee3ecbc314693f181" translate="yes" xml:space="preserve">
          <source>Write writes data to w, which will eventually write the compressed form of data to its underlying writer.</source>
          <target state="translated">쓰기는 데이터를 w에 씁니다. 결국 압축 된 데이터 형식을 기본 작성기에 기록합니다.</target>
        </trans-unit>
        <trans-unit id="b3b5ffbd7094344c5c64fdfaaee4e1ac8b0d0d73" translate="yes" xml:space="preserve">
          <source>Write writes len(b) bytes to the File. It returns the number of bytes written and an error, if any. Write returns a non-nil error when n != len(b).</source>
          <target state="translated">쓰기는 len (b) 바이트를 파일에 씁니다. 쓴 바이트 수와 오류가있는 경우 오류를 반환합니다. n! = len (b) 인 경우 Write는 비 -nil 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bc6f468fb42c60c9aa3d3403f67792ca68e56337" translate="yes" xml:space="preserve">
          <source>Write writes len(p) bytes from p to the underlying data stream. It returns the number of bytes written from p (0 &amp;lt;= n &amp;lt;= len(p)) and any error encountered that caused the write to stop early. Write must return a non-nil error if it returns n &amp;lt; len(p). Write must not modify the slice data, even temporarily.</source>
          <target state="translated">쓰기는 len (p) 바이트를 p에서 기본 데이터 스트림으로 씁니다. p (0 &amp;lt;= n &amp;lt;= len (p))에서 쓴 바이트 수와 쓰기가 일찍 중지되게하는 오류가 발생했습니다. 쓰기는 n &amp;lt;len (p)를 반환하면 non-nil 오류를 반환해야합니다. 쓰기는 슬라이스 데이터를 일시적으로 수정하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="8d63636955bd89c2cf8a7af170c604cdce197b80" translate="yes" xml:space="preserve">
          <source>Write writes r to w in the HTTP/1.x server response format, including the status line, headers, body, and optional trailer.</source>
          <target state="translated">쓰기는 상태 표시 줄, 헤더, 본문 및 옵션 트레일러를 포함하여 HTTP / 1.x 서버 응답 형식으로 r에 w를 씁니다.</target>
        </trans-unit>
        <trans-unit id="540dcdd5a6a217068d019b75b00fcd61e7a04d31" translate="yes" xml:space="preserve">
          <source>Write writes resp in response to req. To close the connection gracefully, set the Response.Close field to true. Write should be considered operational until it returns an error, regardless of any errors returned on the Read side.</source>
          <target state="translated">요청은 req에 대한 응답으로 resp를 씁니다. 연결을 정상적으로 닫으려면 Response.Close 필드를 true로 설정하십시오. 읽기 쪽에서 반환 된 오류에 관계없이 오류가 반환 될 때까지 쓰기가 작동 가능한 것으로 간주되어야합니다.</target>
        </trans-unit>
        <trans-unit id="67e15dd48b8a4dfa3a0d9587fc9c9c38dda0a150" translate="yes" xml:space="preserve">
          <source>Write writes the binary representation of data into w. Data must be a fixed-size value or a slice of fixed-size values, or a pointer to such data. Boolean values encode as one byte: 1 for true, and 0 for false. Bytes written to w are encoded using the specified byte order and read from successive fields of the data. When writing structs, zero values are written for fields with blank (_) field names.</source>
          <target state="translated">쓰기는 데이터의 이진 표현을 w에 씁니다. 데이터는 고정 크기 값 또는 고정 크기 값 조각이거나 이러한 데이터에 대한 포인터 여야합니다. 부울 값은 1 바이트로 인코딩됩니다. 1은 true, 0은 false입니다. w에 기록 된 바이트는 지정된 바이트 순서를 사용하여 인코딩되고 데이터의 연속 필드에서 읽습니다. 구조체를 쓸 때 공백 (_) 필드 이름을 가진 필드에 대해 0 값이 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="1aedca15daa2824cc7a6db34a6e59e022ccdde6b" translate="yes" xml:space="preserve">
          <source>Write writes the contents of p into the buffer. It returns the number of bytes written. If nn &amp;lt; len(p), it also returns an error explaining why the write is short.</source>
          <target state="translated">Write는 p의 내용을 버퍼에 씁니다. 쓴 바이트 수를 반환합니다. nn &amp;lt;len (p) 인 경우 쓰기가 짧은 이유를 설명하는 오류도 반환합니다.</target>
        </trans-unit>
        <trans-unit id="979c6b0be612eaeecc0a5795d58b592f39b6a7cc" translate="yes" xml:space="preserve">
          <source>Write writes the index x to w.</source>
          <target state="translated">쓰기는 인덱스 x를 w에 씁니다.</target>
        </trans-unit>
        <trans-unit id="4bb1c277541d19952bb3d44e887bd82c7760bdb9" translate="yes" xml:space="preserve">
          <source>Write writes to the current file in the tar archive. Write returns the error ErrWriteTooLong if more than Header.Size bytes are written after WriteHeader.</source>
          <target state="translated">쓰기 tar 아카이브의 현재 파일에 씁니다. WriteHeader 다음에 Header.Size 바이트보다 많은 바이트가 기록되면 Write는 오류 ErrWriteTooLong을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0224fd253898a9aef4ac0177d7201684f5813e08" translate="yes" xml:space="preserve">
          <source>WriteAll writes multiple CSV records to w using Write and then calls Flush, returning any error from the Flush.</source>
          <target state="translated">WriteAll은 Write를 사용하여 여러 개의 CSV 레코드를 w에 쓴 다음 Flush를 호출하여 Flush에서 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="577d19fec1f13e0c1b297c086a7a9e7aaffc9552" translate="yes" xml:space="preserve">
          <source>WriteAt writes len(b) bytes to the File starting at byte offset off. It returns the number of bytes written and an error, if any. WriteAt returns a non-nil error when n != len(b).</source>
          <target state="translated">WriteAt은 len (b) 바이트를 바이트 오프셋 오프에서 시작하여 파일에 씁니다. 쓴 바이트 수와 오류가있는 경우 오류를 반환합니다. WriteAt는 n! = len (b) 인 경우 비 -nil 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="913c43952e7ba95faf4dd01c5c3386903926e88f" translate="yes" xml:space="preserve">
          <source>WriteAt writes len(p) bytes from p to the underlying data stream at offset off. It returns the number of bytes written from p (0 &amp;lt;= n &amp;lt;= len(p)) and any error encountered that caused the write to stop early. WriteAt must return a non-nil error if it returns n &amp;lt; len(p).</source>
          <target state="translated">WriteAt은 오프셋 off에서 len (p) 바이트를 p에서 기본 데이터 스트림으로 씁니다. p (0 &amp;lt;= n &amp;lt;= len (p))에서 쓴 바이트 수와 쓰기가 일찍 중지되게하는 오류가 발생했습니다. WriteAt은 n &amp;lt;len (p)를 반환하면 넌이 아닌 오류를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="299aad410b1c59608b367a7d4cb870a456df8096" translate="yes" xml:space="preserve">
          <source>WriteByte appends the byte c to b's buffer. The returned error is always nil.</source>
          <target state="translated">WriteByte는 바이트 c를 b의 버퍼에 추가합니다. 반환 된 오류는 항상 nil입니다.</target>
        </trans-unit>
        <trans-unit id="f1124aa2cccac4bc8c094488b7bc39b62c0cdd5a" translate="yes" xml:space="preserve">
          <source>WriteByte appends the byte c to the buffer, growing the buffer as needed. The returned error is always nil, but is included to match bufio.Writer's WriteByte. If the buffer becomes too large, WriteByte will panic with ErrTooLarge.</source>
          <target state="translated">WriteByte는 바이트 c를 버퍼에 추가하여 필요에 따라 버퍼를 증가시킵니다. 반환 된 오류는 항상 0이지만 bufio.Writer의 WriteByte와 일치하도록 포함됩니다. 버퍼가 너무 커지면 WriteByte는 ErrTooLarge와 함께 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="709e9a78ca951be47b51eaa8c43161a4a68b13de" translate="yes" xml:space="preserve">
          <source>WriteByte writes a single byte.</source>
          <target state="translated">WriteByte는 단일 바이트를 씁니다.</target>
        </trans-unit>
        <trans-unit id="b0fa0c9c90b10c53cd3030a178df8c5bc4b748e3" translate="yes" xml:space="preserve">
          <source>WriteCloser is the interface that groups the basic Write and Close methods.</source>
          <target state="translated">WriteCloser는 기본 Write 및 Close 메서드를 그룹화하는 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="a5b4dc8d0bfd74b6d0a363e79ed44899e4d10a7a" translate="yes" xml:space="preserve">
          <source>WriteExpr writes the (possibly shortened) string representation for x to buf. Shortened representations are suitable for user interfaces but may not necessarily follow Go syntax.</source>
          <target state="translated">WriteExpr은 x에 대한 (짧게 단축 된) 문자열 표현을 buf에 씁니다. 단축 표현은 사용자 인터페이스에 적합하지만 반드시 Go 구문을 따르지 않을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2fc53b6ae37f84446440bfa3e46d55b1daae44f" translate="yes" xml:space="preserve">
          <source>WriteField calls CreateFormField and then writes the given value.</source>
          <target state="translated">WriteField는 CreateFormField를 호출 한 다음 주어진 값을 씁니다.</target>
        </trans-unit>
        <trans-unit id="94dee2fafe1d10d5ce6db659eb0c0fcb3d5842be" translate="yes" xml:space="preserve">
          <source>WriteFile</source>
          <target state="translated">WriteFile</target>
        </trans-unit>
        <trans-unit id="f1a08dac7451fee22a938f078c0cf3128fd334ab" translate="yes" xml:space="preserve">
          <source>WriteFile writes data to a file named by filename. If the file does not exist, WriteFile creates it with permissions perm (before umask); otherwise WriteFile truncates it before writing, without changing permissions.</source>
          <target state="translated">WriteFile은 파일 이름으로 명명 된 파일에 데이터를 씁니다. 파일이 존재하지 않는 경우 WriteFile은 권한 perm (umask 이전)으로 파일을 생성합니다. 그렇지 않으면 WriteFile은 쓰기 전에 권한을 변경하지 않고 자릅니다.</target>
        </trans-unit>
        <trans-unit id="ef73f34a1517d5e481c55ca7ffbc2a25494b2019" translate="yes" xml:space="preserve">
          <source>WriteFile writes data to a file named by filename. If the file does not exist, WriteFile creates it with permissions perm; otherwise WriteFile truncates it before writing.</source>
          <target state="translated">WriteFile은 filename이라는 이름의 파일에 데이터를 씁니다. 파일이 존재하지 않으면 WriteFile은 perm 권한으로 파일을 작성합니다. 그렇지 않으면 WriteFile은 쓰기 전에이를 자릅니다.</target>
        </trans-unit>
        <trans-unit id="966a2c28275a12b7d85d4ef9e4fb4bdd7daf03b9" translate="yes" xml:space="preserve">
          <source>WriteHeader implements http.ResponseWriter.</source>
          <target state="translated">WriteHeader는 http.ResponseWriter를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="5278a175f457ff599653e584e10d0da21d75e04a" translate="yes" xml:space="preserve">
          <source>WriteHeader writes hdr and prepares to accept the file's contents. The Header.Size determines how many bytes can be written for the next file. If the current file is not fully written, then this returns an error. This implicitly flushes any padding necessary before writing the header.</source>
          <target state="translated">WriteHeader는 hdr을 작성하고 파일 내용을 받아 들일 준비를합니다. Header.Size는 다음 파일에 쓸 수있는 바이트 수를 결정합니다. 현재 파일이 완전히 작성되지 않은 경우 오류가 반환됩니다. 헤더를 작성하기 전에 필요한 패딩을 암시 적으로 플러시합니다.</target>
        </trans-unit>
        <trans-unit id="3ca8ba0518cad3338405c38e79e75e9c13b24b43" translate="yes" xml:space="preserve">
          <source>WriteHeapDump suspends the execution of all goroutines until the heap dump is completely written. Thus, the file descriptor must not be connected to a pipe or socket whose other end is in the same Go process; instead, use a temporary file or network socket.</source>
          <target state="translated">WriteHeapDump는 힙 덤프가 완전히 작성 될 때까지 모든 고 루틴 실행을 일시 중단합니다. 따라서 파일 디스크립터는 다른 쪽 끝이 동일한 Go 프로세스에있는 파이프 또는 소켓에 연결되어서는 안됩니다. 대신 임시 파일이나 네트워크 소켓을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6a06afdd85eafc1200fe0ffc3dbde0309767d7ac" translate="yes" xml:space="preserve">
          <source>WriteHeapDump writes a description of the heap and the objects in it to the given file descriptor.</source>
          <target state="translated">WriteHeapDump는 힙에 대한 설명과 그 안에있는 객체를 지정된 파일 설명자에 씁니다.</target>
        </trans-unit>
        <trans-unit id="e3abbd24fb479c9ecfc16a57b4a2dfe1f2c03f20" translate="yes" xml:space="preserve">
          <source>WriteHeapProfile is shorthand for Lookup(&quot;heap&quot;).WriteTo(w, 0). It is preserved for backwards compatibility.</source>
          <target state="translated">WriteHeapProfile은 Lookup ( &quot;heap&quot;). WriteTo (w, 0)의 줄임말입니다. 이전 버전과의 호환성을 위해 보존됩니다.</target>
        </trans-unit>
        <trans-unit id="60029a6d43efd94d3594516e2528881eb15af008" translate="yes" xml:space="preserve">
          <source>WriteMsgIP writes a message to addr via c, copying the payload from b and the associated out-of-band data from oob. It returns the number of payload and out-of-band bytes written.</source>
          <target state="translated">WriteMsgIP는 c를 통해 addr에 메시지를 작성하고 b의 페이로드와 oob의 관련 대역 외 데이터를 복사합니다. 쓰여진 페이로드 및 대역 외 바이트 수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="97f4683eac3d5fc32a65061e292f2190af0bf38c" translate="yes" xml:space="preserve">
          <source>WriteMsgUDP writes a message to addr via c if c isn't connected, or to c's remote address if c is connected (in which case addr must be nil). The payload is copied from b and the associated out-of-band data is copied from oob. It returns the number of payload and out-of-band bytes written.</source>
          <target state="translated">WriteMsgUDP는 c가 연결되어 있지 않으면 c를 통해 addr에, c가 연결되어 있으면 c의 원격 주소에 메시지를 씁니다 (이 경우 addr는 nil이어야 함). 페이로드는 b에서 복사되고 연관된 대역 외 데이터는 oob에서 복사됩니다. 쓰여진 페이로드 및 대역 외 바이트 수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="8193c21ac5c2ea950e2bde14d77250380df04e5a" translate="yes" xml:space="preserve">
          <source>WriteMsgUnix writes a message to addr via c, copying the payload from b and the associated out-of-band data from oob. It returns the number of payload and out-of-band bytes written.</source>
          <target state="translated">WriteMsgUnix는 c를 통해 addr에 메시지를 작성하고 b의 페이로드와 oob의 관련 대역 외 데이터를 복사합니다. 쓰여진 페이로드 및 대역 외 바이트 수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="05a4cbe90da51b5a60d7ce652f38c76395d34c38" translate="yes" xml:space="preserve">
          <source>WriteProxy is like Write but writes the request in the form expected by an HTTP proxy. In particular, WriteProxy writes the initial Request-URI line of the request with an absolute URI, per section 5.3 of RFC 7230, including the scheme and host. In either case, WriteProxy also writes a Host header, using either r.Host or r.URL.Host.</source>
          <target state="translated">WriteProxy는 Write와 비슷하지만 요청을 HTTP 프록시가 예상하는 형식으로 씁니다. 특히, WriteProxy는 스킴과 호스트를 포함하여 RFC 7230의 섹션 5.3에 따라 절대 URI로 요청의 초기 Request-URI 라인을 작성합니다. 두 경우 모두 WriteProxy는 r.Host 또는 r.URL.Host를 사용하여 호스트 헤더를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="c69fd535ec2a61d9f0cd55c49694d03e060751bc" translate="yes" xml:space="preserve">
          <source>WriteRune appends the UTF-8 encoding of Unicode code point r to b's buffer. It returns the length of r and a nil error.</source>
          <target state="translated">WriteRune은 유니 코드 코드 포인트 r의 UTF-8 인코딩을 b의 버퍼에 추가합니다. r의 길이와 nil 오류를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="50419d360e1454c08d1e726980bb9af5c883fdf2" translate="yes" xml:space="preserve">
          <source>WriteRune appends the UTF-8 encoding of Unicode code point r to the buffer, returning its length and an error, which is always nil but is included to match bufio.Writer's WriteRune. The buffer is grown as needed; if it becomes too large, WriteRune will panic with ErrTooLarge.</source>
          <target state="translated">WriteRune은 유니 코드 코드 포인트 r의 UTF-8 인코딩을 버퍼에 추가하여 길이와 오류를 리턴합니다.이 길이는 항상 0이지만 bufio.Writer의 WriteRune과 일치하도록 포함됩니다. 버퍼는 필요에 따라 성장합니다. 너무 커지면 WriteRune이 ErrTooLarge로 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="8539205ffda07e4fc93063bbff49ea5a24bdfb57" translate="yes" xml:space="preserve">
          <source>WriteRune writes a single Unicode code point, returning the number of bytes written and any error.</source>
          <target state="translated">WriteRune은 하나의 유니 코드 코드 포인트를 작성하여 쓴 바이트 수와 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c4cdb9aa52cc1444def4915c41a6238a5b9dce01" translate="yes" xml:space="preserve">
          <source>WriteSeeker is the interface that groups the basic Write and Seek methods.</source>
          <target state="translated">WriteSeeker는 기본 Write 및 Seek 메서드를 그룹화하는 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="4c4e530f7fc3720d0a0b9dd1699773a51975bcd0" translate="yes" xml:space="preserve">
          <source>WriteSignature writes the representation of the signature sig to buf, without a leading &quot;func&quot; keyword. The Qualifier controls the printing of package-level objects, and may be nil.</source>
          <target state="translated">WriteSignature는 주요 &quot;func&quot;키워드없이 서명 sig의 표현을 buf에 씁니다. 한정자는 패키지 수준 개체의 인쇄를 제어하며 nil 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2fafa28d75b28a484b0d11704a5f73dc2a397a9b" translate="yes" xml:space="preserve">
          <source>WriteString</source>
          <target state="translated">WriteString</target>
        </trans-unit>
        <trans-unit id="dcea71a3d2530b8c16e73859a42e5c1339cc7b3a" translate="yes" xml:space="preserve">
          <source>WriteString appends the contents of s to b's buffer. It returns the length of s and a nil error.</source>
          <target state="translated">WriteString은 s의 내용을 b의 버퍼에 추가합니다. s의 길이와 nil 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f0863225004b8002965c5f1f30cabf45ec0ce003" translate="yes" xml:space="preserve">
          <source>WriteString appends the contents of s to the buffer, growing the buffer as needed. The return value n is the length of s; err is always nil. If the buffer becomes too large, WriteString will panic with ErrTooLarge.</source>
          <target state="translated">WriteString은 s의 내용을 버퍼에 추가하여 필요에 따라 버퍼를 증가시킵니다. 리턴 값 n은 s의 길이입니다. err는 항상 nil입니다. 버퍼가 너무 커지면 WriteString은 ErrTooLarge와 함께 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="5906492d4ad1f77da2e42a5903d5b14910e74bdc" translate="yes" xml:space="preserve">
          <source>WriteString implements io.StringWriter. The data in str is written to rw.Body, if not nil.</source>
          <target state="translated">WriteString은 io.StringWriter를 구현합니다. str의 데이터는 0이 아닌 경우 rw.Body에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="2881565b760b26a4f8a2f57e00f09267df1fc3c7" translate="yes" xml:space="preserve">
          <source>WriteString is like Write, but writes the contents of string s rather than a slice of bytes.</source>
          <target state="translated">WriteString은 Write와 비슷하지만 바이트 조각이 아닌 string s의 내용을 씁니다.</target>
        </trans-unit>
        <trans-unit id="5e86374df4dcf5990aedc6d23a06ec17779ecb41" translate="yes" xml:space="preserve">
          <source>WriteString writes a string. It returns the number of bytes written. If the count is less than len(s), it also returns an error explaining why the write is short.</source>
          <target state="translated">WriteString은 문자열을 씁니다. 쓴 바이트 수를 반환합니다. 카운트가 len (s)보다 작 으면 쓰기가 왜 짧은지를 설명하는 오류도 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b06770a08018ebad1f55b3701993d6f12040309c" translate="yes" xml:space="preserve">
          <source>WriteString writes s to w with all replacements performed.</source>
          <target state="translated">WriteString은 모든 교체가 수행 된 상태에서 s를 w에 기록합니다.</target>
        </trans-unit>
        <trans-unit id="269915f1206072ee8dbb37610e3b9dfdc6260f9a" translate="yes" xml:space="preserve">
          <source>WriteString writes the contents of the string s to w, which accepts a slice of bytes. If w implements StringWriter, its WriteString method is invoked directly. Otherwise, w.Write is called exactly once.</source>
          <target state="translated">WriteString은 문자열 s의 내용을 w에 씁니다. 이는 바이트 슬라이스를 허용합니다. w가 StringWriter를 구현하면 해당 WriteString 메소드가 직접 호출됩니다. 그렇지 않으면 w.Write가 정확히 한 번 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="14e283952e32e7284849c90772991995a0d08383" translate="yes" xml:space="preserve">
          <source>WriteSubset writes a header in wire format. If exclude is not nil, keys where exclude[key] == true are not written.</source>
          <target state="translated">WriteSubset은 헤더를 유선 형식으로 씁니다. exclude가 nil이 아닌 경우 exclude [key] == true 인 키는 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d674cf2f9ed846b78f239ed6b5be115ab29ab2d6" translate="yes" xml:space="preserve">
          <source>WriteSubset writes a header in wire format. If exclude is not nil, keys where exclude[key] == true are not written. Keys are not canonicalized before checking the exclude map.</source>
          <target state="translated">WriteSubset은 와이어 형식으로 헤더를 씁니다. exclude가 nil이 아니면 exclude [key] == true 인 키는 기록되지 않습니다. 제외 맵을 확인하기 전에 키가 정규화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="049d63dec358580d0ec0653e5b3c153d3b077135" translate="yes" xml:space="preserve">
          <source>WriteTo implements io.WriterTo. This may make multiple calls to the Read method of the underlying Reader. If the underlying reader supports the WriteTo method, this calls the underlying WriteTo without buffering.</source>
          <target state="translated">WriteTo는 io.WriterTo를 구현합니다. 기본 Reader의 Read 메서드를 여러 번 호출 할 수 있습니다. 기본 리더가 WriteTo 메서드를 지원하면 버퍼링없이 기본 WriteTo를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="8139263f4318d7564d44a96fc8dbff5e63bb96fd" translate="yes" xml:space="preserve">
          <source>WriteTo implements the PacketConn WriteTo method.</source>
          <target state="translated">WriteTo는 PacketConn WriteTo 메서드를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="1dd6cb0fb603b3372044d7453914baf64dbeabc3" translate="yes" xml:space="preserve">
          <source>WriteTo implements the io.WriterTo interface.</source>
          <target state="translated">WriteTo는 io.WriterTo 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="8c7bb5378a7a840f064c83d707986b7492eb31e2" translate="yes" xml:space="preserve">
          <source>WriteTo writes a pprof-formatted snapshot of the profile to w. If a write to w returns an error, WriteTo returns that error. Otherwise, WriteTo returns nil.</source>
          <target state="translated">WriteTo는 pprof 형식의 프로파일 스냅 샷을 w에 씁니다. w에 쓰기가 오류를 리턴하면 WriteTo는 해당 오류를 리턴합니다. 그렇지 않으면 WriteTo는 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="489e07f5de5485be9543961aadd05292560f9aca" translate="yes" xml:space="preserve">
          <source>WriteTo writes a string representation of the scope to w, with the scope elements sorted by name. The level of indentation is controlled by n &amp;gt;= 0, with n == 0 for no indentation. If recurse is set, it also writes nested (children) scopes.</source>
          <target state="translated">WriteTo는 범위 요소를 이름별로 정렬하여 범위의 문자열 표현을 w에 씁니다. 들여 쓰기 레벨은 들여 쓰기가 없으면 n&amp;gt; = 0으로 n&amp;gt; = 0으로 제어됩니다. 재귀가 설정되면 중첩 (자식) 범위도 씁니다.</target>
        </trans-unit>
        <trans-unit id="d1e7dcb553ab192fce6fd288394665a1afcd3f5c" translate="yes" xml:space="preserve">
          <source>WriteTo writes data to w until the buffer is drained or an error occurs. The return value n is the number of bytes written; it always fits into an int, but it is int64 to match the io.WriterTo interface. Any error encountered during the write is also returned.</source>
          <target state="translated">WriteTo는 버퍼가 비워 지거나 오류가 발생할 때까지 데이터를 w에 기록합니다. 리턴 값 n은 쓴 바이트 수입니다. 항상 int에 맞지만 io.WriterTo 인터페이스와 일치하는 것은 int64입니다. 쓰기 중에 발생한 모든 오류도 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="675b06c215e20183689acb9dd6a02dde0ececcfe" translate="yes" xml:space="preserve">
          <source>WriteTo writes data to w until there's no more data to write or when an error occurs. The return value n is the number of bytes written. Any error encountered during the write is also returned.</source>
          <target state="translated">WriteTo는 쓸 데이터가 더 이상 없거나 오류가 발생할 때까지 w에 데이터를 씁니다. 리턴 값 n은 쓴 바이트 수입니다. 쓰기 중에 발생한 모든 오류도 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="16524feb66448f891798c4e2c2b003dede383877" translate="yes" xml:space="preserve">
          <source>WriteToIP acts like WriteTo but takes an IPAddr.</source>
          <target state="translated">WriteToIP는 WriteTo처럼 작동하지만 IPAddr을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5439ba90be07d98d78a0acbb16e701c88430c920" translate="yes" xml:space="preserve">
          <source>WriteToUDP acts like WriteTo but takes a UDPAddr.</source>
          <target state="translated">WriteToUDP는 WriteTo처럼 작동하지만 UDPAddr을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="70bfc7011539dc3fcd8cb976e79375745c81efb6" translate="yes" xml:space="preserve">
          <source>WriteToUnix acts like WriteTo but takes a UnixAddr.</source>
          <target state="translated">WriteToUnix는 WriteTo처럼 작동하지만 UnixAddr을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="bf93ade9d0116866c9989c0d6db8fe0a1790197b" translate="yes" xml:space="preserve">
          <source>WriteType writes the string representation of typ to buf. The Qualifier controls the printing of package-level objects, and may be nil.</source>
          <target state="translated">WriteType은 typ의 문자열 표현을 buf에 기록합니다. 한정자는 패키지 수준 개체의 인쇄를 제어하며 nil 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f435830a7c07f19c4072a88821b38028c3f69e6" translate="yes" xml:space="preserve">
          <source>Writer</source>
          <target state="translated">Writer</target>
        </trans-unit>
        <trans-unit id="27739d4166f1a372ecad9e26dae552acbbf96378" translate="yes" xml:space="preserve">
          <source>Writer implements a zip file writer.</source>
          <target state="translated">기록기는 zip 파일 기록기를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="0a56b3c1ebc71cca6811d5ea42cfcd61b9d39529" translate="yes" xml:space="preserve">
          <source>Writer implements buffering for an io.Writer object. If an error occurs writing to a Writer, no more data will be accepted and all subsequent writes, and Flush, will return the error. After all data has been written, the client should call the Flush method to guarantee all data has been forwarded to the underlying io.Writer.</source>
          <target state="translated">Writer는 io.Writer 객체에 대한 버퍼링을 구현합니다. Writer에 쓰는 동안 오류가 발생하면 더 이상 데이터가 허용되지 않으며 이후의 모든 쓰기 및 Flush는 오류를 반환합니다. 모든 데이터가 작성된 후 클라이언트는 Flush 메소드를 호출하여 모든 데이터가 기본 io.Writer로 전달되도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="ef9d03832983cf4b271bb5441f954111b4dc0e1e" translate="yes" xml:space="preserve">
          <source>Writer is the interface that wraps the basic Write method.</source>
          <target state="translated">Writer는 기본 Write 메서드를 래핑하는 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="427cfe70a00ca8d321faf6329909145b93655f1d" translate="yes" xml:space="preserve">
          <source>Writer provides sequential writing of a tar archive. Write.WriteHeader begins a new file with the provided Header, and then Writer can be treated as an io.Writer to supply that file's data.</source>
          <target state="translated">기록기는 tar 아카이브의 순차적 기록을 제공합니다. Write.WriteHeader는 제공된 헤더로 새 파일을 시작한 다음 Writer를 io.Writer로 처리하여 해당 파일의 데이터를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7acd853acb07fa87c4b8bfe4031a755b61ba3bf3" translate="yes" xml:space="preserve">
          <source>Writer returns the output destination for the logger.</source>
          <target state="translated">기록기는 로거의 출력 대상을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3d5fe142bef0cbbd3b816be820156528e0933482" translate="yes" xml:space="preserve">
          <source>Writer returns the output destination for the standard logger.</source>
          <target state="translated">Writer는 표준 로거의 출력 대상을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cc5f6bbc6d4441180bb267f283d2d032dc1c0a51" translate="yes" xml:space="preserve">
          <source>Writer, to write dot-encoded text blocks.</source>
          <target state="translated">Writer, 도트로 인코딩 된 텍스트 블록을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="18f7957bfe6eb1c4e6c6911f16343b2aefa987f8" translate="yes" xml:space="preserve">
          <source>Writer.Init</source>
          <target state="translated">Writer.Init</target>
        </trans-unit>
        <trans-unit id="c077ca30988f9da9fa06bdada12777468be255fd" translate="yes" xml:space="preserve">
          <source>Writer.RegisterCompressor</source>
          <target state="translated">Writer.RegisterCompressor</target>
        </trans-unit>
        <trans-unit id="52b3549fe3dc7eeb9e682e0957e12c6a11a932c4" translate="yes" xml:space="preserve">
          <source>Writer.WriteAll</source>
          <target state="translated">Writer.WriteAll</target>
        </trans-unit>
        <trans-unit id="aeee2e0685aa932cc2aaeffa26f77224718c1152" translate="yes" xml:space="preserve">
          <source>WriterAt is the interface that wraps the basic WriteAt method.</source>
          <target state="translated">WriterAt는 기본 WriteAt 메서드를 래핑하는 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="8ab71dde8a6f8d04cee549ea8541c77aaebdcab8" translate="yes" xml:space="preserve">
          <source>WriterTo is the interface that wraps the WriteTo method.</source>
          <target state="translated">WriterTo는 WriteTo 메서드를 래핑하는 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="1b39f0e4afe7201d767e5fbbce52d4c2e5b87a3a" translate="yes" xml:space="preserve">
          <source>WroteRequestInfo contains information provided to the WroteRequest hook.</source>
          <target state="translated">WroteRequestInfo에는 WroteRequest 후크에 제공된 정보가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="127aef9b4a6638a4da9d60eee45faca81817967a" translate="yes" xml:space="preserve">
          <source>X509KeyPair</source>
          <target state="translated">X509KeyPair</target>
        </trans-unit>
        <trans-unit id="512f6338fce5f83658ade589125789680e0a180a" translate="yes" xml:space="preserve">
          <source>X509KeyPair (HttpServer)</source>
          <target state="translated">X509KeyPair (HttpServer)</target>
        </trans-unit>
        <trans-unit id="eb6cfabefa86cc7130f0ceaa6c99558292a8fb32" translate="yes" xml:space="preserve">
          <source>X509KeyPair parses a public/private key pair from a pair of PEM encoded data. On successful return, Certificate.Leaf will be nil because the parsed form of the certificate is not retained.</source>
          <target state="translated">X509KeyPair는 PEM으로 인코딩 된 데이터 쌍에서 공개 / 개인 키 쌍을 구문 분석합니다. 성공적으로 반환되면 구문 분석 된 인증서 형식이 유지되지 않으므로 Certificate.Leaf는 0이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="db992a4f131e511a8d9ce5936d82355a68509183" translate="yes" xml:space="preserve">
          <source>XORKeyStream sets dst to the result of XORing src with the key stream. Dst and src must overlap entirely or not at all.</source>
          <target state="translated">XORKeyStream은 dst를 키 스트림과 함께 XORing src의 결과로 설정합니다. Dst와 src는 완전히 겹치거나 겹치지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="63c6c5be8d1c945e475df745ac44a459209b8818" translate="yes" xml:space="preserve">
          <source>Xor sets z = x ^ y and returns z.</source>
          <target state="translated">Xor는 z = x ^ y를 설정하고 z를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b579a9d9b11366f490071fb238c298157a4151d9" translate="yes" xml:space="preserve">
          <source>Y0 returns the order-zero Bessel function of the second kind.</source>
          <target state="translated">Y0은 두 번째 종류의 0 차 베셀 함수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e0b0a19d715ece09aeb410f412b0c7d445934330" translate="yes" xml:space="preserve">
          <source>Y1 returns the order-one Bessel function of the second kind.</source>
          <target state="translated">Y1은 두 번째 종류의 1 차 베셀 함수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="993c29f2dccf3899bcb16c0c3c3e58cbb4ff26a3" translate="yes" xml:space="preserve">
          <source>YCbCr is an in-memory image of Y'CbCr colors. There is one Y sample per pixel, but each Cb and Cr sample can span one or more pixels. YStride is the Y slice index delta between vertically adjacent pixels. CStride is the Cb and Cr slice index delta between vertically adjacent pixels that map to separate chroma samples. It is not an absolute requirement, but YStride and len(Y) are typically multiples of 8, and:</source>
          <target state="translated">YCbCr은 Y'CbCr 색상의 메모리 내 이미지입니다. 픽셀 당 하나의 Y 샘플이 있지만 각 Cb 및 Cr 샘플은 하나 이상의 픽셀에 걸쳐있을 수 있습니다. YStride는 세로로 인접한 픽셀 사이의 Y 슬라이스 인덱스 델타입니다. CStride는 별도의 크로마 샘플에 매핑되는 수직으로 인접한 픽셀 사이의 Cb 및 Cr 슬라이스 인덱스 델타입니다. 절대 요구 사항은 아니지만 YStride와 len (Y)는 일반적으로 8의 배수입니다.</target>
        </trans-unit>
        <trans-unit id="04b6d1d571fb2541a796ccff17941677d6e94116" translate="yes" xml:space="preserve">
          <source>YCbCr represents a fully opaque 24-bit Y'CbCr color, having 8 bits each for one luma and two chroma components.</source>
          <target state="translated">YCbCr은 완전히 불투명 한 24 비트 Y'CbCr 색상을 나타내며, 루마 1 개와 크로마 성분 2 개에 대해 각각 8 비트를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="569302883a982b6ecca1dff87d53f57a317c9e3e" translate="yes" xml:space="preserve">
          <source>YCbCrModel is the Model for Y'CbCr colors.</source>
          <target state="translated">YCbCrModel은 Y'CbCr 색상에 대한 모델입니다.</target>
        </trans-unit>
        <trans-unit id="c3eb9b9a99d34d53e98e4c42a8f496bcc27b2dd4" translate="yes" xml:space="preserve">
          <source>YCbCrSubsampleRatio is the chroma subsample ratio used in a YCbCr image.</source>
          <target state="translated">YCbCrSubsampleRatio는 YCbCr 이미지에 사용되는 크로마 서브 샘플 비율입니다.</target>
        </trans-unit>
        <trans-unit id="7c2a18a269291c4a568eeda22c7b8012ba05d3cc" translate="yes" xml:space="preserve">
          <source>YCbCrToRGB converts a Y'CbCr triple to an RGB triple.</source>
          <target state="translated">YCbCrToRGB는 Y'CbCr 트리플을 RGB 트리플로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="2cc85e17988c35ca87fe9396bebb3408abc4139c" translate="yes" xml:space="preserve">
          <source>YOffset returns the index of the first element of Y that corresponds to the pixel at (x, y).</source>
          <target state="translated">YOffset은 (x, y)의 픽셀에 해당하는 Y의 첫 번째 요소의 인덱스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0ae67455f11e2f617f0f533036db82246ea0f1ba" translate="yes" xml:space="preserve">
          <source>Year returns the year in which t occurs.</source>
          <target state="translated">Year는 t가 발생한 연도를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a0e093613a2a058d01beb5d9e83df474d4a7948e" translate="yes" xml:space="preserve">
          <source>YearDay returns the day of the year specified by t, in the range [1,365] for non-leap years, and [1,366] in leap years.</source>
          <target state="translated">YearDay는 비 윤년의 경우 [1,365], 윤년의 [1,366] 범위에서 t로 지정된 연도의 일을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fbc86f73dd0143c109fc555dff3f9f4721e59b11" translate="yes" xml:space="preserve">
          <source>Yn returns the order-n Bessel function of the second kind.</source>
          <target state="translated">Yn은 두 번째 종류의 order-n Bessel 함수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1e7f3945f480c58bbf5b45878f32cae6f3cbe3e1" translate="yes" xml:space="preserve">
          <source>ZP is the zero Point.</source>
          <target state="translated">ZP는 영점입니다.</target>
        </trans-unit>
        <trans-unit id="4bedd2eb81ef394e3788fa98b69d1ca4f77655ed" translate="yes" xml:space="preserve">
          <source>ZR is the zero Rectangle.</source>
          <target state="translated">ZR은 제로 사각형입니다.</target>
        </trans-unit>
        <trans-unit id="1c6d3d57e5f186ce1aa4706dba2af53b9ebdfe54" translate="yes" xml:space="preserve">
          <source>Zero returns a Value representing the zero value for the specified type. The result is different from the zero value of the Value struct, which represents no value at all. For example, Zero(TypeOf(42)) returns a Value with Kind Int and value 0. The returned value is neither addressable nor settable.</source>
          <target state="translated">0은 지정된 유형의 0 값을 나타내는 값을 반환합니다. 결과는 전혀 값을 나타내지 않는 Value 구조체의 0 값과 다릅니다. 예를 들어, Zero (TypeOf (42))는 Kind Int 및 값이 0 인 값을 반환합니다. 반환 된 값은 주소 지정 가능하거나 설정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5ec7a8085e409e2fdcc504c5c24961579ad364d7" translate="yes" xml:space="preserve">
          <source>Zone computes the time zone in effect at time t, returning the abbreviated name of the zone (such as &quot;CET&quot;) and its offset in seconds east of UTC.</source>
          <target state="translated">Zone은 시간 t에서 적용되는 시간대를 계산하여 해당 약어 (예 : &quot;CET&quot;)의 약어 이름과 UTC 동쪽의 초 단위 오프셋을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d95a582393c950008420678e089bcb6fb6005a66" translate="yes" xml:space="preserve">
          <source>[1] US patent 4405829 (1972, expired) [2] &lt;a href=&quot;http://www.cacr.math.uwaterloo.ca/techreports/2006/cacr2006-16.pdf&quot;&gt;http://www.cacr.math.uwaterloo.ca/techreports/2006/cacr2006-16.pdf&lt;/a&gt;</source>
          <target state="translated">[1] 미국 특허 4405829 (1972, 만료) [2] &lt;a href=&quot;http://www.cacr.math.uwaterloo.ca/techreports/2006/cacr2006-16.pdf&quot;&gt;http://www.cacr.math.uwaterloo.ca/techreports/2006/cacr2006-16.pdf&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e9ce7a3611a7e8082ceef88c829a5b4bd38a883b" translate="yes" xml:space="preserve">
          <source>a and b may be positive, zero or negative. (Before Go 1.14 both had to be &amp;gt; 0.) Regardless of the signs of a and b, z is always &amp;gt;= 0.</source>
          <target state="translated">a와 b는 양수, 0 또는 음수 일 수 있습니다. (Go 1.14 이전에는 둘 다&amp;gt; 0이어야했습니다.) a와 b의 부호에 관계없이 z는 항상&amp;gt; = 0입니다.</target>
        </trans-unit>
        <trans-unit id="c868a399ecee19d2ae9d23c5ac270d4627ec37c2" translate="yes" xml:space="preserve">
          <source>adler32</source>
          <target state="translated">adler32</target>
        </trans-unit>
        <trans-unit id="3bc4dea27b862dd8aa4e815187d2cdd3be2a75c7" translate="yes" xml:space="preserve">
          <source>adler32.Checksum()</source>
          <target state="translated">adler32.Checksum()</target>
        </trans-unit>
        <trans-unit id="fdae41220d5cd5d881fd4909d397ab172b7b713d" translate="yes" xml:space="preserve">
          <source>adler32.New()</source>
          <target state="translated">adler32.New()</target>
        </trans-unit>
        <trans-unit id="b9e516580969fb81fe1efdac7be863ede058820d" translate="yes" xml:space="preserve">
          <source>adler32.go</source>
          <target state="translated">adler32.go</target>
        </trans-unit>
        <trans-unit id="9b214a0fbc91794f9b2f7c03b2ffdadc705bb106" translate="yes" xml:space="preserve">
          <source>aes</source>
          <target state="translated">aes</target>
        </trans-unit>
        <trans-unit id="4a6e483e4c655c235bfae76e4cff3a9491b844fe" translate="yes" xml:space="preserve">
          <source>aes.KeySizeError</source>
          <target state="translated">aes.KeySizeError</target>
        </trans-unit>
        <trans-unit id="eaae49997213c0be97b3d20ac0b21bf6b5ea2211" translate="yes" xml:space="preserve">
          <source>aes.KeySizeError.Error()</source>
          <target state="translated">aes.KeySizeError.Error()</target>
        </trans-unit>
        <trans-unit id="39b985982e7b3543046a3bf2ac7d7a7b8ce71274" translate="yes" xml:space="preserve">
          <source>aes.NewCipher()</source>
          <target state="translated">aes.NewCipher()</target>
        </trans-unit>
        <trans-unit id="0fb27eee12ade1a38a95e36453c1e554b462484b" translate="yes" xml:space="preserve">
          <source>and to read that data back:</source>
          <target state="translated">그 데이터를 다시 읽으려면 :</target>
        </trans-unit>
        <trans-unit id="ebfb55f4432b592119a10592e4f26272cc72359e" translate="yes" xml:space="preserve">
          <source>archive</source>
          <target state="translated">archive</target>
        </trans-unit>
        <trans-unit id="599b006359811c99dc41f2f30a3e4da1a269aab7" translate="yes" xml:space="preserve">
          <source>archive/tar</source>
          <target state="translated">archive/tar</target>
        </trans-unit>
        <trans-unit id="36627ccd71d39d88b5319bafd6f742e95ad7efbb" translate="yes" xml:space="preserve">
          <source>archive/zip</source>
          <target state="translated">archive/zip</target>
        </trans-unit>
        <trans-unit id="5711ec9a54403a9271f1ec98d0532f337d096f48" translate="yes" xml:space="preserve">
          <source>are considered benchmarks, and are executed by the &quot;go test&quot; command when its -bench flag is provided. Benchmarks are run sequentially.</source>
          <target state="translated">벤치 마크로 간주되며 -bench 플래그가 제공 될 때 &quot;go test&quot;명령으로 실행됩니다. 벤치 마크는 순차적으로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="2f4d46fbed13b2d5ff12c543a95ead3c2d7d0b4e" translate="yes" xml:space="preserve">
          <source>ascii85</source>
          <target state="translated">ascii85</target>
        </trans-unit>
        <trans-unit id="c709c878860d1c843277aa3c7fafe85ebe2fdbbf" translate="yes" xml:space="preserve">
          <source>ascii85.CorruptInputError</source>
          <target state="translated">ascii85.CorruptInputError</target>
        </trans-unit>
        <trans-unit id="58459a79830f2fbd0ecae6834d288cc61d744b76" translate="yes" xml:space="preserve">
          <source>ascii85.CorruptInputError.Error()</source>
          <target state="translated">ascii85.CorruptInputError.Error()</target>
        </trans-unit>
        <trans-unit id="59d4f41c4d68ec4771eaba0f7e123bfcd8825ea8" translate="yes" xml:space="preserve">
          <source>ascii85.Decode()</source>
          <target state="translated">ascii85.Decode()</target>
        </trans-unit>
        <trans-unit id="8d4003545eb5e35693ca34599af4f472b3ea1e75" translate="yes" xml:space="preserve">
          <source>ascii85.Encode()</source>
          <target state="translated">ascii85.Encode()</target>
        </trans-unit>
        <trans-unit id="bf3560ccbab3bd109332df53c1a3532db455ea63" translate="yes" xml:space="preserve">
          <source>ascii85.MaxEncodedLen()</source>
          <target state="translated">ascii85.MaxEncodedLen()</target>
        </trans-unit>
        <trans-unit id="70cbc7b778e1d7ce35bd8d42cc75b6c69fc1ac8a" translate="yes" xml:space="preserve">
          <source>ascii85.NewDecoder()</source>
          <target state="translated">ascii85.NewDecoder()</target>
        </trans-unit>
        <trans-unit id="5a619b434aa961150c63a00555d9caa30389e0a7" translate="yes" xml:space="preserve">
          <source>ascii85.NewEncoder()</source>
          <target state="translated">ascii85.NewEncoder()</target>
        </trans-unit>
        <trans-unit id="5d4c0e749c8b30f76f313c377c2c53071120924c" translate="yes" xml:space="preserve">
          <source>ascii85.go</source>
          <target state="translated">ascii85.go</target>
        </trans-unit>
        <trans-unit id="9edf4240018976bf964cf31c1a24d34fde8d517d" translate="yes" xml:space="preserve">
          <source>asn1</source>
          <target state="translated">asn1</target>
        </trans-unit>
        <trans-unit id="3b25fcd0e7aac867ba1b902a9bad74c32fd06f7a" translate="yes" xml:space="preserve">
          <source>asn1.BitString</source>
          <target state="translated">asn1.BitString</target>
        </trans-unit>
        <trans-unit id="b6f72489fb5ca7587375a5bdd653f7f1df476dc4" translate="yes" xml:space="preserve">
          <source>asn1.BitString.At()</source>
          <target state="translated">asn1.BitString.At()</target>
        </trans-unit>
        <trans-unit id="4c41e6f4e9eb61025667c2d062c9558e1f1e6497" translate="yes" xml:space="preserve">
          <source>asn1.BitString.RightAlign()</source>
          <target state="translated">asn1.BitString.RightAlign()</target>
        </trans-unit>
        <trans-unit id="8cdba2268b9ac8546eddd752887146141a709a59" translate="yes" xml:space="preserve">
          <source>asn1.Enumerated</source>
          <target state="translated">asn1.Enumerated</target>
        </trans-unit>
        <trans-unit id="0bda2d2df59ae7e05b1eec034907a553d7c7a42b" translate="yes" xml:space="preserve">
          <source>asn1.Flag</source>
          <target state="translated">asn1.Flag</target>
        </trans-unit>
        <trans-unit id="b6fd1eca6f1af508581a7ec1afa96ca5c77fdcef" translate="yes" xml:space="preserve">
          <source>asn1.Marshal()</source>
          <target state="translated">asn1.Marshal()</target>
        </trans-unit>
        <trans-unit id="1dd69ab12f931e65b184412035dbdf691ef75671" translate="yes" xml:space="preserve">
          <source>asn1.MarshalWithParams()</source>
          <target state="translated">asn1.MarshalWithParams()</target>
        </trans-unit>
        <trans-unit id="967f6161afbc84e65192ed4145c8fb2886ef1b34" translate="yes" xml:space="preserve">
          <source>asn1.ObjectIdentifier</source>
          <target state="translated">asn1.ObjectIdentifier</target>
        </trans-unit>
        <trans-unit id="eb5273c3d4afff6a018248c1d3b92ecf13f1b251" translate="yes" xml:space="preserve">
          <source>asn1.ObjectIdentifier.Equal()</source>
          <target state="translated">asn1.ObjectIdentifier.Equal()</target>
        </trans-unit>
        <trans-unit id="9104208a312cff3364923b64231855dcb6182420" translate="yes" xml:space="preserve">
          <source>asn1.ObjectIdentifier.String()</source>
          <target state="translated">asn1.ObjectIdentifier.String()</target>
        </trans-unit>
        <trans-unit id="fa1326ed75bd447347a012e931b2cb50f6277993" translate="yes" xml:space="preserve">
          <source>asn1.RawContent</source>
          <target state="translated">asn1.RawContent</target>
        </trans-unit>
        <trans-unit id="11afa151ffea7be0e51569d7278af02c01d14648" translate="yes" xml:space="preserve">
          <source>asn1.RawValue</source>
          <target state="translated">asn1.RawValue</target>
        </trans-unit>
        <trans-unit id="c7e196c13ac871177aa305816ccdd2f214844f1f" translate="yes" xml:space="preserve">
          <source>asn1.StructuralError</source>
          <target state="translated">asn1.StructuralError</target>
        </trans-unit>
        <trans-unit id="ede541b4e84339ed235682099c483b8d0ea9d195" translate="yes" xml:space="preserve">
          <source>asn1.StructuralError.Error()</source>
          <target state="translated">asn1.StructuralError.Error()</target>
        </trans-unit>
        <trans-unit id="6f92f6f304a340128dbbc8d8d5d1d24bb934dd1c" translate="yes" xml:space="preserve">
          <source>asn1.SyntaxError</source>
          <target state="translated">asn1.SyntaxError</target>
        </trans-unit>
        <trans-unit id="2cc0c7c5b17f8fbf4c99fe144d21fdcb86a4e4d5" translate="yes" xml:space="preserve">
          <source>asn1.SyntaxError.Error()</source>
          <target state="translated">asn1.SyntaxError.Error()</target>
        </trans-unit>
        <trans-unit id="b4620fdf4cc070561d9028cca9eebe3527fab3bb" translate="yes" xml:space="preserve">
          <source>asn1.Unmarshal()</source>
          <target state="translated">asn1.Unmarshal()</target>
        </trans-unit>
        <trans-unit id="db2421d96b2365ce2873e4bdc3dd1b1884fb7a9e" translate="yes" xml:space="preserve">
          <source>asn1.UnmarshalWithParams()</source>
          <target state="translated">asn1.UnmarshalWithParams()</target>
        </trans-unit>
        <trans-unit id="c24c0248770ae98831f8a654310d4c2e07514c61" translate="yes" xml:space="preserve">
          <source>ast</source>
          <target state="translated">ast</target>
        </trans-unit>
        <trans-unit id="befa22645af2b2c57ff1d061bee4609e465ce151" translate="yes" xml:space="preserve">
          <source>ast.ArrayType</source>
          <target state="translated">ast.ArrayType</target>
        </trans-unit>
        <trans-unit id="3aaa1f08029690a9ad3162fe7f0aeb4221534ddc" translate="yes" xml:space="preserve">
          <source>ast.ArrayType.End()</source>
          <target state="translated">ast.ArrayType.End()</target>
        </trans-unit>
        <trans-unit id="7400ff1c7cb92a2976bfa3daf41ae2f354273958" translate="yes" xml:space="preserve">
          <source>ast.ArrayType.Pos()</source>
          <target state="translated">ast.ArrayType.Pos()</target>
        </trans-unit>
        <trans-unit id="8f7ff0499c577334d405d39760346407f6352d95" translate="yes" xml:space="preserve">
          <source>ast.AssignStmt</source>
          <target state="translated">ast.AssignStmt</target>
        </trans-unit>
        <trans-unit id="a4eadbf257f6ac901889cf9a6bb1024e24a65284" translate="yes" xml:space="preserve">
          <source>ast.AssignStmt.End()</source>
          <target state="translated">ast.AssignStmt.End()</target>
        </trans-unit>
        <trans-unit id="2d16762ab296b2e910461becfd95d333facceb3a" translate="yes" xml:space="preserve">
          <source>ast.AssignStmt.Pos()</source>
          <target state="translated">ast.AssignStmt.Pos()</target>
        </trans-unit>
        <trans-unit id="ea70196c82482d305608466884903c9a043e9178" translate="yes" xml:space="preserve">
          <source>ast.BadDecl</source>
          <target state="translated">ast.BadDecl</target>
        </trans-unit>
        <trans-unit id="8b1817d76ef00b508173afe2cfbf9777b5fb2077" translate="yes" xml:space="preserve">
          <source>ast.BadDecl.End()</source>
          <target state="translated">ast.BadDecl.End()</target>
        </trans-unit>
        <trans-unit id="4deb107b4c3af556a6324d9162f029f4f4e1ab9d" translate="yes" xml:space="preserve">
          <source>ast.BadDecl.Pos()</source>
          <target state="translated">ast.BadDecl.Pos()</target>
        </trans-unit>
        <trans-unit id="fd50cb7d9bdbcdf5cbc147580c9a8b40d97b0d06" translate="yes" xml:space="preserve">
          <source>ast.BadExpr</source>
          <target state="translated">ast.BadExpr</target>
        </trans-unit>
        <trans-unit id="d2fa322f959652eda770c38075241e33463480a5" translate="yes" xml:space="preserve">
          <source>ast.BadExpr.End()</source>
          <target state="translated">ast.BadExpr.End()</target>
        </trans-unit>
        <trans-unit id="9b83d6d18f65ed71ddfbc157d967fa64ca7fe3cc" translate="yes" xml:space="preserve">
          <source>ast.BadExpr.Pos()</source>
          <target state="translated">ast.BadExpr.Pos()</target>
        </trans-unit>
        <trans-unit id="aa7a3ebb9ae1f1a5f3082d8520b04a78ac2064d7" translate="yes" xml:space="preserve">
          <source>ast.BadStmt</source>
          <target state="translated">ast.BadStmt</target>
        </trans-unit>
        <trans-unit id="7985d77e4e120c475b0777e4460cfbd66c182a3f" translate="yes" xml:space="preserve">
          <source>ast.BadStmt.End()</source>
          <target state="translated">ast.BadStmt.End()</target>
        </trans-unit>
        <trans-unit id="611c00a04c5ad6fc35d6b2b0553c31ad6c2c9afd" translate="yes" xml:space="preserve">
          <source>ast.BadStmt.Pos()</source>
          <target state="translated">ast.BadStmt.Pos()</target>
        </trans-unit>
        <trans-unit id="a332f7650fd36f4dd02d99d3b8ec6e1a8507c809" translate="yes" xml:space="preserve">
          <source>ast.BasicLit</source>
          <target state="translated">ast.BasicLit</target>
        </trans-unit>
        <trans-unit id="a98f149f6185847f9599a498ffe20bdbe234ca79" translate="yes" xml:space="preserve">
          <source>ast.BasicLit.End()</source>
          <target state="translated">ast.BasicLit.End()</target>
        </trans-unit>
        <trans-unit id="0e3e9e0fe19152d6958f147d0962725dbce04684" translate="yes" xml:space="preserve">
          <source>ast.BasicLit.Pos()</source>
          <target state="translated">ast.BasicLit.Pos()</target>
        </trans-unit>
        <trans-unit id="9ec47fda282a56476d3ee59b3f89d74ad43722db" translate="yes" xml:space="preserve">
          <source>ast.BinaryExpr</source>
          <target state="translated">ast.BinaryExpr</target>
        </trans-unit>
        <trans-unit id="d9ca2bfa7b901986b5e133efaf148e7bfa73fda0" translate="yes" xml:space="preserve">
          <source>ast.BinaryExpr.End()</source>
          <target state="translated">ast.BinaryExpr.End()</target>
        </trans-unit>
        <trans-unit id="b540b3db7c164e96ddb28ee245b6fef0191d37eb" translate="yes" xml:space="preserve">
          <source>ast.BinaryExpr.Pos()</source>
          <target state="translated">ast.BinaryExpr.Pos()</target>
        </trans-unit>
        <trans-unit id="53ad55929540909d0e0c0c6d1a14db54405be438" translate="yes" xml:space="preserve">
          <source>ast.BlockStmt</source>
          <target state="translated">ast.BlockStmt</target>
        </trans-unit>
        <trans-unit id="2a8369a80640f3347a935c1c0c735ec709358dd1" translate="yes" xml:space="preserve">
          <source>ast.BlockStmt.End()</source>
          <target state="translated">ast.BlockStmt.End()</target>
        </trans-unit>
        <trans-unit id="851c7137cbb678223bbeb3430399d5059b29e277" translate="yes" xml:space="preserve">
          <source>ast.BlockStmt.Pos()</source>
          <target state="translated">ast.BlockStmt.Pos()</target>
        </trans-unit>
        <trans-unit id="53d494d40d484db0e354b674a369eaa485186d69" translate="yes" xml:space="preserve">
          <source>ast.BranchStmt</source>
          <target state="translated">ast.BranchStmt</target>
        </trans-unit>
        <trans-unit id="006cb666be74c0e0ee36d0e1ed3b722a9839add9" translate="yes" xml:space="preserve">
          <source>ast.BranchStmt.End()</source>
          <target state="translated">ast.BranchStmt.End()</target>
        </trans-unit>
        <trans-unit id="e624885b40ec9930e0e4fd5546fea07c4309f64a" translate="yes" xml:space="preserve">
          <source>ast.BranchStmt.Pos()</source>
          <target state="translated">ast.BranchStmt.Pos()</target>
        </trans-unit>
        <trans-unit id="d6ff240d9cd77565e3fdf528d15c0d3e77aae78a" translate="yes" xml:space="preserve">
          <source>ast.CallExpr</source>
          <target state="translated">ast.CallExpr</target>
        </trans-unit>
        <trans-unit id="8a4191ffec5d62d08911cd982b546ba76a9e5277" translate="yes" xml:space="preserve">
          <source>ast.CallExpr.End()</source>
          <target state="translated">ast.CallExpr.End()</target>
        </trans-unit>
        <trans-unit id="34bacfb498513ccfab3294638b6955e96b607eff" translate="yes" xml:space="preserve">
          <source>ast.CallExpr.Pos()</source>
          <target state="translated">ast.CallExpr.Pos()</target>
        </trans-unit>
        <trans-unit id="908cabf810e388d4f96ee3b484f6fcc63f3a633e" translate="yes" xml:space="preserve">
          <source>ast.CaseClause</source>
          <target state="translated">ast.CaseClause</target>
        </trans-unit>
        <trans-unit id="9bf625cb99111aa416d920ee5d6aa42ad53c2a20" translate="yes" xml:space="preserve">
          <source>ast.CaseClause.End()</source>
          <target state="translated">ast.CaseClause.End()</target>
        </trans-unit>
        <trans-unit id="5a4f8b1a228bb80bdb4bf93e1ba2e0372f5f4436" translate="yes" xml:space="preserve">
          <source>ast.CaseClause.Pos()</source>
          <target state="translated">ast.CaseClause.Pos()</target>
        </trans-unit>
        <trans-unit id="df184106f71e2042d31c9c581eea0f2a15d7e71a" translate="yes" xml:space="preserve">
          <source>ast.ChanDir</source>
          <target state="translated">ast.ChanDir</target>
        </trans-unit>
        <trans-unit id="d9894c3ef3fe79412fc727115570d01ffbfbe371" translate="yes" xml:space="preserve">
          <source>ast.ChanType</source>
          <target state="translated">ast.ChanType</target>
        </trans-unit>
        <trans-unit id="a2d3c384b591665fddb01c653b8cba6f42964707" translate="yes" xml:space="preserve">
          <source>ast.ChanType.End()</source>
          <target state="translated">ast.ChanType.End()</target>
        </trans-unit>
        <trans-unit id="b0d99e4fe9e408caf8079a70db85f1516d3ca640" translate="yes" xml:space="preserve">
          <source>ast.ChanType.Pos()</source>
          <target state="translated">ast.ChanType.Pos()</target>
        </trans-unit>
        <trans-unit id="afe2fe744c7228a28664b3f99a19fbe01eaab7ae" translate="yes" xml:space="preserve">
          <source>ast.CommClause</source>
          <target state="translated">ast.CommClause</target>
        </trans-unit>
        <trans-unit id="748b6c2557f1f18e86e976cbd1e96523b3b6d20f" translate="yes" xml:space="preserve">
          <source>ast.CommClause.End()</source>
          <target state="translated">ast.CommClause.End()</target>
        </trans-unit>
        <trans-unit id="76469ceeb1ed92aaa0251ce9a2f5a4d18c58e648" translate="yes" xml:space="preserve">
          <source>ast.CommClause.Pos()</source>
          <target state="translated">ast.CommClause.Pos()</target>
        </trans-unit>
        <trans-unit id="eb410c5b03c33912d6440a324168677d85ea4084" translate="yes" xml:space="preserve">
          <source>ast.Comment</source>
          <target state="translated">ast.Comment</target>
        </trans-unit>
        <trans-unit id="2f74f8850964cdea428b72cbb0bd8306188b40cc" translate="yes" xml:space="preserve">
          <source>ast.Comment.End()</source>
          <target state="translated">ast.Comment.End()</target>
        </trans-unit>
        <trans-unit id="8da5aaee99b97985300a17a57207881036cfc8a5" translate="yes" xml:space="preserve">
          <source>ast.Comment.Pos()</source>
          <target state="translated">ast.Comment.Pos()</target>
        </trans-unit>
        <trans-unit id="d482672bd74456c8614c239b9de80f42d9daf6ac" translate="yes" xml:space="preserve">
          <source>ast.CommentGroup</source>
          <target state="translated">ast.CommentGroup</target>
        </trans-unit>
        <trans-unit id="291fb0d01c213b675214864708e38aac78c965df" translate="yes" xml:space="preserve">
          <source>ast.CommentGroup.End()</source>
          <target state="translated">ast.CommentGroup.End()</target>
        </trans-unit>
        <trans-unit id="7ec5ba7e20d2f8b73cfdda6dd5a5bafef1a471ad" translate="yes" xml:space="preserve">
          <source>ast.CommentGroup.Pos()</source>
          <target state="translated">ast.CommentGroup.Pos()</target>
        </trans-unit>
        <trans-unit id="db0b452520c4081b875986a5b08603bfa7cf27db" translate="yes" xml:space="preserve">
          <source>ast.CommentGroup.Text()</source>
          <target state="translated">ast.CommentGroup.Text()</target>
        </trans-unit>
        <trans-unit id="49b8300f7bfddf0b6f0c42c6dedb29841231a049" translate="yes" xml:space="preserve">
          <source>ast.CommentMap</source>
          <target state="translated">ast.CommentMap</target>
        </trans-unit>
        <trans-unit id="138e15e3c47ac21027b750aa86d1b4d8df53eec7" translate="yes" xml:space="preserve">
          <source>ast.CommentMap.Comments()</source>
          <target state="translated">ast.CommentMap.Comments()</target>
        </trans-unit>
        <trans-unit id="2a275924c14d2d5bda8b6efa1638b2ec1b5a618b" translate="yes" xml:space="preserve">
          <source>ast.CommentMap.Filter()</source>
          <target state="translated">ast.CommentMap.Filter()</target>
        </trans-unit>
        <trans-unit id="df6eab6e6f03363da7369f68bcb68c05efd35841" translate="yes" xml:space="preserve">
          <source>ast.CommentMap.String()</source>
          <target state="translated">ast.CommentMap.String()</target>
        </trans-unit>
        <trans-unit id="0f2fc4844e739382be4a668668f79c30a8928df8" translate="yes" xml:space="preserve">
          <source>ast.CommentMap.Update()</source>
          <target state="translated">ast.CommentMap.Update()</target>
        </trans-unit>
        <trans-unit id="3a34308cd756c0e7977abc07b327473d4c5e13c9" translate="yes" xml:space="preserve">
          <source>ast.CompositeLit</source>
          <target state="translated">ast.CompositeLit</target>
        </trans-unit>
        <trans-unit id="9bb0da22db2db807a80446404d4b271a65e7aab7" translate="yes" xml:space="preserve">
          <source>ast.CompositeLit.End()</source>
          <target state="translated">ast.CompositeLit.End()</target>
        </trans-unit>
        <trans-unit id="a52feba5850623b44256bed6165f0d82ada4137b" translate="yes" xml:space="preserve">
          <source>ast.CompositeLit.Pos()</source>
          <target state="translated">ast.CompositeLit.Pos()</target>
        </trans-unit>
        <trans-unit id="9b37ee9927929c783d31dbe64e672109b3492683" translate="yes" xml:space="preserve">
          <source>ast.Decl</source>
          <target state="translated">ast.Decl</target>
        </trans-unit>
        <trans-unit id="98b759c2b999b973be88a5d07cfbab3927683195" translate="yes" xml:space="preserve">
          <source>ast.DeclStmt</source>
          <target state="translated">ast.DeclStmt</target>
        </trans-unit>
        <trans-unit id="d9c77d027698da2fc0d108e953b1083d16e69416" translate="yes" xml:space="preserve">
          <source>ast.DeclStmt.End()</source>
          <target state="translated">ast.DeclStmt.End()</target>
        </trans-unit>
        <trans-unit id="78a21564f0f1d72a43aaeb48f47154c52db3176a" translate="yes" xml:space="preserve">
          <source>ast.DeclStmt.Pos()</source>
          <target state="translated">ast.DeclStmt.Pos()</target>
        </trans-unit>
        <trans-unit id="a88c75402a7cf7a0dc33b87900e61ca2f2cb224d" translate="yes" xml:space="preserve">
          <source>ast.DeferStmt</source>
          <target state="translated">ast.DeferStmt</target>
        </trans-unit>
        <trans-unit id="56a6d8b85ed2f1106d5011cc30be75871a6f333e" translate="yes" xml:space="preserve">
          <source>ast.DeferStmt.End()</source>
          <target state="translated">ast.DeferStmt.End()</target>
        </trans-unit>
        <trans-unit id="00435a1620cdf12444d2655e5741d7351bc9d952" translate="yes" xml:space="preserve">
          <source>ast.DeferStmt.Pos()</source>
          <target state="translated">ast.DeferStmt.Pos()</target>
        </trans-unit>
        <trans-unit id="d85c5eae8637be960ca473b6d19e86f92dadc2b1" translate="yes" xml:space="preserve">
          <source>ast.Ellipsis</source>
          <target state="translated">ast.Ellipsis</target>
        </trans-unit>
        <trans-unit id="6e8302a49c68476d2a9804dff9dc78d3fa9453ff" translate="yes" xml:space="preserve">
          <source>ast.Ellipsis.End()</source>
          <target state="translated">ast.Ellipsis.End()</target>
        </trans-unit>
        <trans-unit id="aa13456258be7dfca118f86ab0d7cd8681f91663" translate="yes" xml:space="preserve">
          <source>ast.Ellipsis.Pos()</source>
          <target state="translated">ast.Ellipsis.Pos()</target>
        </trans-unit>
        <trans-unit id="83ec929cb12fbac363e83149d20e153666193591" translate="yes" xml:space="preserve">
          <source>ast.EmptyStmt</source>
          <target state="translated">ast.EmptyStmt</target>
        </trans-unit>
        <trans-unit id="1dcc01433f78cd9d1b21499a51d59136b3e66135" translate="yes" xml:space="preserve">
          <source>ast.EmptyStmt.End()</source>
          <target state="translated">ast.EmptyStmt.End()</target>
        </trans-unit>
        <trans-unit id="d15ee08589510f58fcd6aeeadb8b06acc40aae8f" translate="yes" xml:space="preserve">
          <source>ast.EmptyStmt.Pos()</source>
          <target state="translated">ast.EmptyStmt.Pos()</target>
        </trans-unit>
        <trans-unit id="429b94c0e48e600788d6c40b157d869b51271dfd" translate="yes" xml:space="preserve">
          <source>ast.Expr</source>
          <target state="translated">ast.Expr</target>
        </trans-unit>
        <trans-unit id="ddb6850692bf98131494cb5b4ea6a8c1a5257388" translate="yes" xml:space="preserve">
          <source>ast.ExprStmt</source>
          <target state="translated">ast.ExprStmt</target>
        </trans-unit>
        <trans-unit id="fd6a374b8d32132e7eb765f925013baf3fb247f0" translate="yes" xml:space="preserve">
          <source>ast.ExprStmt.End()</source>
          <target state="translated">ast.ExprStmt.End()</target>
        </trans-unit>
        <trans-unit id="3bbdc36acdb6e801295d7762e2d71d186f8ec5dc" translate="yes" xml:space="preserve">
          <source>ast.ExprStmt.Pos()</source>
          <target state="translated">ast.ExprStmt.Pos()</target>
        </trans-unit>
        <trans-unit id="fe35306cfa6c33d1e08c38078ed6418b57cc5c44" translate="yes" xml:space="preserve">
          <source>ast.Field</source>
          <target state="translated">ast.Field</target>
        </trans-unit>
        <trans-unit id="b8ce598b99eab4821c1f05610e4e7c5da11843e3" translate="yes" xml:space="preserve">
          <source>ast.Field.End()</source>
          <target state="translated">ast.Field.End()</target>
        </trans-unit>
        <trans-unit id="31f3f6875ba87eb89fd1c8f4ff6e5652a7d06d46" translate="yes" xml:space="preserve">
          <source>ast.Field.Pos()</source>
          <target state="translated">ast.Field.Pos()</target>
        </trans-unit>
        <trans-unit id="35a61eacd2d4a8d7a2086110a29c7cae70367172" translate="yes" xml:space="preserve">
          <source>ast.FieldFilter</source>
          <target state="translated">ast.FieldFilter</target>
        </trans-unit>
        <trans-unit id="a5cbb8ee53c7545ba520cd4ef0b543279f93ac51" translate="yes" xml:space="preserve">
          <source>ast.FieldList</source>
          <target state="translated">ast.FieldList</target>
        </trans-unit>
        <trans-unit id="079acca70ea605f868cb5458fcd3113961f82bf9" translate="yes" xml:space="preserve">
          <source>ast.FieldList.End()</source>
          <target state="translated">ast.FieldList.End()</target>
        </trans-unit>
        <trans-unit id="0959206159b04b0f7ba0463fe7822ba39164edbe" translate="yes" xml:space="preserve">
          <source>ast.FieldList.NumFields()</source>
          <target state="translated">ast.FieldList.NumFields()</target>
        </trans-unit>
        <trans-unit id="54e713cf18d22bb14498eefdbee876cd84643301" translate="yes" xml:space="preserve">
          <source>ast.FieldList.Pos()</source>
          <target state="translated">ast.FieldList.Pos()</target>
        </trans-unit>
        <trans-unit id="824559735927a3878ee55aa114ff909a4a761fd5" translate="yes" xml:space="preserve">
          <source>ast.File</source>
          <target state="translated">ast.File</target>
        </trans-unit>
        <trans-unit id="9c13ff5d91937bd63b024c5111fe98c16f08d0e1" translate="yes" xml:space="preserve">
          <source>ast.File.End()</source>
          <target state="translated">ast.File.End()</target>
        </trans-unit>
        <trans-unit id="908fdb94b0f7d7928c2e598e507365591a215184" translate="yes" xml:space="preserve">
          <source>ast.File.Pos()</source>
          <target state="translated">ast.File.Pos()</target>
        </trans-unit>
        <trans-unit id="6fc04c6e8365c1e2a348b8d85aea6af30f73a3e7" translate="yes" xml:space="preserve">
          <source>ast.FileExports()</source>
          <target state="translated">ast.FileExports()</target>
        </trans-unit>
        <trans-unit id="515afaadbe65dbb56510d1001b0cea4fb212985a" translate="yes" xml:space="preserve">
          <source>ast.Filter</source>
          <target state="translated">ast.Filter</target>
        </trans-unit>
        <trans-unit id="725c1315b64f2159e1d535cc17c67990c3eb9407" translate="yes" xml:space="preserve">
          <source>ast.FilterDecl()</source>
          <target state="translated">ast.FilterDecl()</target>
        </trans-unit>
        <trans-unit id="9b23fe99e5e78579edea9b2685c0beef40fc5bdf" translate="yes" xml:space="preserve">
          <source>ast.FilterFile()</source>
          <target state="translated">ast.FilterFile()</target>
        </trans-unit>
        <trans-unit id="d0077c13020f893bea04504e4f7edbf31c696173" translate="yes" xml:space="preserve">
          <source>ast.FilterPackage()</source>
          <target state="translated">ast.FilterPackage()</target>
        </trans-unit>
        <trans-unit id="010df2eadbc0b289bbb3ed3dfe1f015c9eaf7589" translate="yes" xml:space="preserve">
          <source>ast.ForStmt</source>
          <target state="translated">ast.ForStmt</target>
        </trans-unit>
        <trans-unit id="7bec230190c220ed154122611c547a4ee061a0d9" translate="yes" xml:space="preserve">
          <source>ast.ForStmt.End()</source>
          <target state="translated">ast.ForStmt.End()</target>
        </trans-unit>
        <trans-unit id="ce1b26151d92491e06fabf1a68f974b70dd064b2" translate="yes" xml:space="preserve">
          <source>ast.ForStmt.Pos()</source>
          <target state="translated">ast.ForStmt.Pos()</target>
        </trans-unit>
        <trans-unit id="9e23cc076f7fa7c25511d66eeb511d7de3fa35f8" translate="yes" xml:space="preserve">
          <source>ast.Fprint()</source>
          <target state="translated">ast.Fprint()</target>
        </trans-unit>
        <trans-unit id="bff7cf7e949bd5b1d09817c599f73bf69122daad" translate="yes" xml:space="preserve">
          <source>ast.FuncDecl</source>
          <target state="translated">ast.FuncDecl</target>
        </trans-unit>
        <trans-unit id="62fa27f1159e359248a085d818004bac79095e10" translate="yes" xml:space="preserve">
          <source>ast.FuncDecl.End()</source>
          <target state="translated">ast.FuncDecl.End()</target>
        </trans-unit>
        <trans-unit id="ca288db889162827b386d6cf407850d0256d0306" translate="yes" xml:space="preserve">
          <source>ast.FuncDecl.Pos()</source>
          <target state="translated">ast.FuncDecl.Pos()</target>
        </trans-unit>
        <trans-unit id="eaa722591c8d3bb5ec7c07884ae4d044acd81acd" translate="yes" xml:space="preserve">
          <source>ast.FuncLit</source>
          <target state="translated">ast.FuncLit</target>
        </trans-unit>
        <trans-unit id="76e1942fbc8f515400fb974985257f1f150278b2" translate="yes" xml:space="preserve">
          <source>ast.FuncLit.End()</source>
          <target state="translated">ast.FuncLit.End()</target>
        </trans-unit>
        <trans-unit id="cf7a4f37978363b411c184f235404cf42419323e" translate="yes" xml:space="preserve">
          <source>ast.FuncLit.Pos()</source>
          <target state="translated">ast.FuncLit.Pos()</target>
        </trans-unit>
        <trans-unit id="77ef0acfcbf1e91989489e4b465f7749a502cee2" translate="yes" xml:space="preserve">
          <source>ast.FuncType</source>
          <target state="translated">ast.FuncType</target>
        </trans-unit>
        <trans-unit id="8bef62cd074cbb9b8bb549f7f37fdd4c9556cec9" translate="yes" xml:space="preserve">
          <source>ast.FuncType.End()</source>
          <target state="translated">ast.FuncType.End()</target>
        </trans-unit>
        <trans-unit id="4f06513dc949b59ca3fe6fb82cf436d570af99bc" translate="yes" xml:space="preserve">
          <source>ast.FuncType.Pos()</source>
          <target state="translated">ast.FuncType.Pos()</target>
        </trans-unit>
        <trans-unit id="49e3462052836776f7475e211320d9c2f0839757" translate="yes" xml:space="preserve">
          <source>ast.GenDecl</source>
          <target state="translated">ast.GenDecl</target>
        </trans-unit>
        <trans-unit id="df8f73ecfd0e7618f102077a8d04eadb08d8aae2" translate="yes" xml:space="preserve">
          <source>ast.GenDecl.End()</source>
          <target state="translated">ast.GenDecl.End()</target>
        </trans-unit>
        <trans-unit id="ec91647151e8a76006d16cb06b8e4e4fa790d995" translate="yes" xml:space="preserve">
          <source>ast.GenDecl.Pos()</source>
          <target state="translated">ast.GenDecl.Pos()</target>
        </trans-unit>
        <trans-unit id="7c40561ab6c64f38a088066a7a0d84b95a7ca19b" translate="yes" xml:space="preserve">
          <source>ast.GoStmt</source>
          <target state="translated">ast.GoStmt</target>
        </trans-unit>
        <trans-unit id="c367671365811674fb44775dd6b4f6d17871b617" translate="yes" xml:space="preserve">
          <source>ast.GoStmt.End()</source>
          <target state="translated">ast.GoStmt.End()</target>
        </trans-unit>
        <trans-unit id="75c800281efd0cbeb0f676a13fbb76dc6b040afc" translate="yes" xml:space="preserve">
          <source>ast.GoStmt.Pos()</source>
          <target state="translated">ast.GoStmt.Pos()</target>
        </trans-unit>
        <trans-unit id="b593a228205ecc5da27ea376c37c8b0feb887b3c" translate="yes" xml:space="preserve">
          <source>ast.Ident</source>
          <target state="translated">ast.Ident</target>
        </trans-unit>
        <trans-unit id="90b434e4582522ff9fdc5e749f4a807e629845d4" translate="yes" xml:space="preserve">
          <source>ast.Ident.End()</source>
          <target state="translated">ast.Ident.End()</target>
        </trans-unit>
        <trans-unit id="330869bf46f759ab5b34542ae5e64e2a8e6d7acb" translate="yes" xml:space="preserve">
          <source>ast.Ident.IsExported()</source>
          <target state="translated">ast.Ident.IsExported()</target>
        </trans-unit>
        <trans-unit id="5880d5cb49703e46da66c8a8df06d571ca83c5a1" translate="yes" xml:space="preserve">
          <source>ast.Ident.Pos()</source>
          <target state="translated">ast.Ident.Pos()</target>
        </trans-unit>
        <trans-unit id="379a5baec0aec6967ea9fdc9a921d6518c56bfab" translate="yes" xml:space="preserve">
          <source>ast.Ident.String()</source>
          <target state="translated">ast.Ident.String()</target>
        </trans-unit>
        <trans-unit id="e8b32504ea1616bed57b72a615485e6c5bcf3eb4" translate="yes" xml:space="preserve">
          <source>ast.IfStmt</source>
          <target state="translated">ast.IfStmt</target>
        </trans-unit>
        <trans-unit id="178670415eb055924ac40df950534ad2e2cfb177" translate="yes" xml:space="preserve">
          <source>ast.IfStmt.End()</source>
          <target state="translated">ast.IfStmt.End()</target>
        </trans-unit>
        <trans-unit id="3168e394231032c60de9860d2f24dcdcf6b63f8e" translate="yes" xml:space="preserve">
          <source>ast.IfStmt.Pos()</source>
          <target state="translated">ast.IfStmt.Pos()</target>
        </trans-unit>
        <trans-unit id="bfcf544bdc28ccecfe31d3153402dfc7ba3c84e8" translate="yes" xml:space="preserve">
          <source>ast.ImportSpec</source>
          <target state="translated">ast.ImportSpec</target>
        </trans-unit>
        <trans-unit id="6520064d174144509bdcbce66766ec930bfa8221" translate="yes" xml:space="preserve">
          <source>ast.ImportSpec.End()</source>
          <target state="translated">ast.ImportSpec.End()</target>
        </trans-unit>
        <trans-unit id="1685b88851dbb057469baaa190bd21d978cbe0bc" translate="yes" xml:space="preserve">
          <source>ast.ImportSpec.Pos()</source>
          <target state="translated">ast.ImportSpec.Pos()</target>
        </trans-unit>
        <trans-unit id="9550a9427b344b71e40dd82d19c601c869a4d9cf" translate="yes" xml:space="preserve">
          <source>ast.Importer</source>
          <target state="translated">ast.Importer</target>
        </trans-unit>
        <trans-unit id="e2409ba06fc76d3584c545f92f449b798355f6f0" translate="yes" xml:space="preserve">
          <source>ast.IncDecStmt</source>
          <target state="translated">ast.IncDecStmt</target>
        </trans-unit>
        <trans-unit id="c525b2e381256702c099bdbe34dc9ce4f6ac65c9" translate="yes" xml:space="preserve">
          <source>ast.IncDecStmt.End()</source>
          <target state="translated">ast.IncDecStmt.End()</target>
        </trans-unit>
        <trans-unit id="035fb511709238ab8b28e76ac438ffe702de2d43" translate="yes" xml:space="preserve">
          <source>ast.IncDecStmt.Pos()</source>
          <target state="translated">ast.IncDecStmt.Pos()</target>
        </trans-unit>
        <trans-unit id="b0307e9b16d106daf0b035e58376cabbc9e6926c" translate="yes" xml:space="preserve">
          <source>ast.IndexExpr</source>
          <target state="translated">ast.IndexExpr</target>
        </trans-unit>
        <trans-unit id="ba7fa4f2659716219910cf4d2905f1a1b287fc30" translate="yes" xml:space="preserve">
          <source>ast.IndexExpr.End()</source>
          <target state="translated">ast.IndexExpr.End()</target>
        </trans-unit>
        <trans-unit id="2bd354950c6821edaad7739a8fcba724b547e4fa" translate="yes" xml:space="preserve">
          <source>ast.IndexExpr.Pos()</source>
          <target state="translated">ast.IndexExpr.Pos()</target>
        </trans-unit>
        <trans-unit id="369af34cd5ed40ef9cb2e2c7caefd90a2a428e6c" translate="yes" xml:space="preserve">
          <source>ast.Inspect()</source>
          <target state="translated">ast.Inspect()</target>
        </trans-unit>
        <trans-unit id="25ee0d24e4bdefca08baba42c5b499bef2631939" translate="yes" xml:space="preserve">
          <source>ast.InterfaceType</source>
          <target state="translated">ast.InterfaceType</target>
        </trans-unit>
        <trans-unit id="e7f5beaab84d5a400eb7088597b485d9c2b81693" translate="yes" xml:space="preserve">
          <source>ast.InterfaceType.End()</source>
          <target state="translated">ast.InterfaceType.End()</target>
        </trans-unit>
        <trans-unit id="9d487418673ccb980bc30730b740aa18ffd002e0" translate="yes" xml:space="preserve">
          <source>ast.InterfaceType.Pos()</source>
          <target state="translated">ast.InterfaceType.Pos()</target>
        </trans-unit>
        <trans-unit id="faf203ccf1d8661b112ef0afb394d238113f79de" translate="yes" xml:space="preserve">
          <source>ast.IsExported()</source>
          <target state="translated">ast.IsExported()</target>
        </trans-unit>
        <trans-unit id="f6e29963cd47848646766055861fb753020b2381" translate="yes" xml:space="preserve">
          <source>ast.KeyValueExpr</source>
          <target state="translated">ast.KeyValueExpr</target>
        </trans-unit>
        <trans-unit id="676038a7674ff4180b98b9c95d7f00e44e5ff675" translate="yes" xml:space="preserve">
          <source>ast.KeyValueExpr.End()</source>
          <target state="translated">ast.KeyValueExpr.End()</target>
        </trans-unit>
        <trans-unit id="a7f2488b03dc9603b5fb5ade012894c27963a348" translate="yes" xml:space="preserve">
          <source>ast.KeyValueExpr.Pos()</source>
          <target state="translated">ast.KeyValueExpr.Pos()</target>
        </trans-unit>
        <trans-unit id="d578e8b479cd8e3a67f7d13b952dbdca8d433665" translate="yes" xml:space="preserve">
          <source>ast.LabeledStmt</source>
          <target state="translated">ast.LabeledStmt</target>
        </trans-unit>
        <trans-unit id="f9fd73232548487ac9de1e96e0d63c270ef3ed95" translate="yes" xml:space="preserve">
          <source>ast.LabeledStmt.End()</source>
          <target state="translated">ast.LabeledStmt.End()</target>
        </trans-unit>
        <trans-unit id="b995ca7a0e7388a2d44edaed5a861f6522bc498f" translate="yes" xml:space="preserve">
          <source>ast.LabeledStmt.Pos()</source>
          <target state="translated">ast.LabeledStmt.Pos()</target>
        </trans-unit>
        <trans-unit id="df9495e93abd4f028fe83b85ec5d23acf6607070" translate="yes" xml:space="preserve">
          <source>ast.MapType</source>
          <target state="translated">ast.MapType</target>
        </trans-unit>
        <trans-unit id="7dcd2d302ff7af724275f98b21395263c7226284" translate="yes" xml:space="preserve">
          <source>ast.MapType.End()</source>
          <target state="translated">ast.MapType.End()</target>
        </trans-unit>
        <trans-unit id="b276b6e6eb9e5e3cc5b5890b552ee1d81c6c3143" translate="yes" xml:space="preserve">
          <source>ast.MapType.Pos()</source>
          <target state="translated">ast.MapType.Pos()</target>
        </trans-unit>
        <trans-unit id="ed54ab4ffb1b7117db7ec8c11c2036e13aa354f4" translate="yes" xml:space="preserve">
          <source>ast.MergeMode</source>
          <target state="translated">ast.MergeMode</target>
        </trans-unit>
        <trans-unit id="8a4a1c271018958b6131692bf9772b17140ab60d" translate="yes" xml:space="preserve">
          <source>ast.MergePackageFiles()</source>
          <target state="translated">ast.MergePackageFiles()</target>
        </trans-unit>
        <trans-unit id="d69af0e77986430aeba3a0af081860fe115b6cb4" translate="yes" xml:space="preserve">
          <source>ast.NewCommentMap()</source>
          <target state="translated">ast.NewCommentMap()</target>
        </trans-unit>
        <trans-unit id="5129de288f81e4c27120a9f4a90516ac8d4b5f34" translate="yes" xml:space="preserve">
          <source>ast.NewIdent()</source>
          <target state="translated">ast.NewIdent()</target>
        </trans-unit>
        <trans-unit id="c06ec5f816ad3b7780a18100eac31a6eaf527921" translate="yes" xml:space="preserve">
          <source>ast.NewObj()</source>
          <target state="translated">ast.NewObj()</target>
        </trans-unit>
        <trans-unit id="2b4163acf274523447a3956d93acc0e5781621e5" translate="yes" xml:space="preserve">
          <source>ast.NewPackage()</source>
          <target state="translated">ast.NewPackage()</target>
        </trans-unit>
        <trans-unit id="3b2efbff7f108d5a3dd7383a2f0e3a22b96a0b95" translate="yes" xml:space="preserve">
          <source>ast.NewScope()</source>
          <target state="translated">ast.NewScope()</target>
        </trans-unit>
        <trans-unit id="0adb216e4d94a3ee5529c0e5a9c370f04452e1a6" translate="yes" xml:space="preserve">
          <source>ast.Node</source>
          <target state="translated">ast.Node</target>
        </trans-unit>
        <trans-unit id="623b088bf971f65916f212c72e905cba2b1e8069" translate="yes" xml:space="preserve">
          <source>ast.NotNilFilter()</source>
          <target state="translated">ast.NotNilFilter()</target>
        </trans-unit>
        <trans-unit id="c8b5e6f4a48dae1e13b59cf334752c12dc83b6cf" translate="yes" xml:space="preserve">
          <source>ast.ObjKind</source>
          <target state="translated">ast.ObjKind</target>
        </trans-unit>
        <trans-unit id="f5c5c8806d07aa2e15518741ee67e202bf7dc08f" translate="yes" xml:space="preserve">
          <source>ast.ObjKind.String()</source>
          <target state="translated">ast.ObjKind.String()</target>
        </trans-unit>
        <trans-unit id="bae83b15a576524838f52dbcd6b8b9af033fbbc3" translate="yes" xml:space="preserve">
          <source>ast.Object</source>
          <target state="translated">ast.Object</target>
        </trans-unit>
        <trans-unit id="f9e118af1e4c93586afaf493c284454a19e8b2c2" translate="yes" xml:space="preserve">
          <source>ast.Object.Pos()</source>
          <target state="translated">ast.Object.Pos()</target>
        </trans-unit>
        <trans-unit id="567486dd6cb64bbe9c3106e27aeb037e6d45db3a" translate="yes" xml:space="preserve">
          <source>ast.Package</source>
          <target state="translated">ast.Package</target>
        </trans-unit>
        <trans-unit id="6e7c36460bfe0ea5135ce8fd31205777d5d60c12" translate="yes" xml:space="preserve">
          <source>ast.Package.End()</source>
          <target state="translated">ast.Package.End()</target>
        </trans-unit>
        <trans-unit id="ee7f2c2f5781253733dea51da1d4e081a9748e4c" translate="yes" xml:space="preserve">
          <source>ast.Package.Pos()</source>
          <target state="translated">ast.Package.Pos()</target>
        </trans-unit>
        <trans-unit id="9de5513df1193074b34ab02d7da8cb4e741796b1" translate="yes" xml:space="preserve">
          <source>ast.PackageExports()</source>
          <target state="translated">ast.PackageExports()</target>
        </trans-unit>
        <trans-unit id="139f231cb638880028d85320734757527c82ac60" translate="yes" xml:space="preserve">
          <source>ast.ParenExpr</source>
          <target state="translated">ast.ParenExpr</target>
        </trans-unit>
        <trans-unit id="d126b416ff09631be4e4c4f6c8d43bf9f7f3839b" translate="yes" xml:space="preserve">
          <source>ast.ParenExpr.End()</source>
          <target state="translated">ast.ParenExpr.End()</target>
        </trans-unit>
        <trans-unit id="04e88d4d23aafe693674ecc9cfe48d7a6c2cd129" translate="yes" xml:space="preserve">
          <source>ast.ParenExpr.Pos()</source>
          <target state="translated">ast.ParenExpr.Pos()</target>
        </trans-unit>
        <trans-unit id="fed56f5a529bbbdad3be7095347db89f91335f9e" translate="yes" xml:space="preserve">
          <source>ast.Print()</source>
          <target state="translated">ast.Print()</target>
        </trans-unit>
        <trans-unit id="ca1f91b57c98735d5e2724adaa27b0d01a506579" translate="yes" xml:space="preserve">
          <source>ast.RangeStmt</source>
          <target state="translated">ast.RangeStmt</target>
        </trans-unit>
        <trans-unit id="2b3df827347af65c5220ad0699cabf973a66c936" translate="yes" xml:space="preserve">
          <source>ast.RangeStmt.End()</source>
          <target state="translated">ast.RangeStmt.End()</target>
        </trans-unit>
        <trans-unit id="405f7515494c4809d791b345db37d8cd690219d6" translate="yes" xml:space="preserve">
          <source>ast.RangeStmt.Pos()</source>
          <target state="translated">ast.RangeStmt.Pos()</target>
        </trans-unit>
        <trans-unit id="5fc9b43eecceb9d8865e778bc56693be1bd04af5" translate="yes" xml:space="preserve">
          <source>ast.ReturnStmt</source>
          <target state="translated">ast.ReturnStmt</target>
        </trans-unit>
        <trans-unit id="3acfc24d47f39c0c780bdb543aee8a14e2f6b398" translate="yes" xml:space="preserve">
          <source>ast.ReturnStmt.End()</source>
          <target state="translated">ast.ReturnStmt.End()</target>
        </trans-unit>
        <trans-unit id="b25c08db40485d577c3cf52a7df5652307cfd082" translate="yes" xml:space="preserve">
          <source>ast.ReturnStmt.Pos()</source>
          <target state="translated">ast.ReturnStmt.Pos()</target>
        </trans-unit>
        <trans-unit id="3c4f3fcf698e11ad4ef0d1d860bc42d79c1d6335" translate="yes" xml:space="preserve">
          <source>ast.Scope</source>
          <target state="translated">ast.Scope</target>
        </trans-unit>
        <trans-unit id="a7f2353ab10d058df49025107d7f80776e4b06c2" translate="yes" xml:space="preserve">
          <source>ast.Scope.Insert()</source>
          <target state="translated">ast.Scope.Insert()</target>
        </trans-unit>
        <trans-unit id="f14b79f9fc6e1ae02e48c6c9b700065f052bd6ff" translate="yes" xml:space="preserve">
          <source>ast.Scope.Lookup()</source>
          <target state="translated">ast.Scope.Lookup()</target>
        </trans-unit>
        <trans-unit id="5b95cd8378b36dac9f7e271f67bf4ced58ac82b6" translate="yes" xml:space="preserve">
          <source>ast.Scope.String()</source>
          <target state="translated">ast.Scope.String()</target>
        </trans-unit>
        <trans-unit id="6ffc6174e0346c5eb0bd447799e285ceb2b67a7a" translate="yes" xml:space="preserve">
          <source>ast.SelectStmt</source>
          <target state="translated">ast.SelectStmt</target>
        </trans-unit>
        <trans-unit id="94ada0a282cd66c315cedca378236abe2b55e42b" translate="yes" xml:space="preserve">
          <source>ast.SelectStmt.End()</source>
          <target state="translated">ast.SelectStmt.End()</target>
        </trans-unit>
        <trans-unit id="60ab7074daf140138b422f554ad2e121cb70a88e" translate="yes" xml:space="preserve">
          <source>ast.SelectStmt.Pos()</source>
          <target state="translated">ast.SelectStmt.Pos()</target>
        </trans-unit>
        <trans-unit id="9fd58c075f3747285b6e7d6b057656caea4dfb15" translate="yes" xml:space="preserve">
          <source>ast.SelectorExpr</source>
          <target state="translated">ast.SelectorExpr</target>
        </trans-unit>
        <trans-unit id="aab656a4e3befeb695f9c09da789411215f9e81c" translate="yes" xml:space="preserve">
          <source>ast.SelectorExpr.End()</source>
          <target state="translated">ast.SelectorExpr.End()</target>
        </trans-unit>
        <trans-unit id="e24ee60e56bdb1d72f60635d1abb6a7fe6b3489c" translate="yes" xml:space="preserve">
          <source>ast.SelectorExpr.Pos()</source>
          <target state="translated">ast.SelectorExpr.Pos()</target>
        </trans-unit>
        <trans-unit id="e09be7cece8df7fea15336136ca6cd2b20b01ea0" translate="yes" xml:space="preserve">
          <source>ast.SendStmt</source>
          <target state="translated">ast.SendStmt</target>
        </trans-unit>
        <trans-unit id="8d8cfca6d27eb8024cf957aa9aab02ceb80f2a96" translate="yes" xml:space="preserve">
          <source>ast.SendStmt.End()</source>
          <target state="translated">ast.SendStmt.End()</target>
        </trans-unit>
        <trans-unit id="3cd30925ad3333b551bee09d78fdd41c6a5ce183" translate="yes" xml:space="preserve">
          <source>ast.SendStmt.Pos()</source>
          <target state="translated">ast.SendStmt.Pos()</target>
        </trans-unit>
        <trans-unit id="939932c50298b92117488c46251f13b11e7b47b9" translate="yes" xml:space="preserve">
          <source>ast.SliceExpr</source>
          <target state="translated">ast.SliceExpr</target>
        </trans-unit>
        <trans-unit id="f849fa118f03aa5fc3b7c517d60e19956c2dc69a" translate="yes" xml:space="preserve">
          <source>ast.SliceExpr.End()</source>
          <target state="translated">ast.SliceExpr.End()</target>
        </trans-unit>
        <trans-unit id="66822f43b70f862fe3d114dea48400685c5ea7be" translate="yes" xml:space="preserve">
          <source>ast.SliceExpr.Pos()</source>
          <target state="translated">ast.SliceExpr.Pos()</target>
        </trans-unit>
        <trans-unit id="4c2d369f7096af0d255334de26cf26af744bd73e" translate="yes" xml:space="preserve">
          <source>ast.SortImports()</source>
          <target state="translated">ast.SortImports()</target>
        </trans-unit>
        <trans-unit id="b05c11f1a97da11082ad9d609677eabadfeb85a6" translate="yes" xml:space="preserve">
          <source>ast.Spec</source>
          <target state="translated">ast.Spec</target>
        </trans-unit>
        <trans-unit id="647bd402923d8756230898c1ba5e288311b035c1" translate="yes" xml:space="preserve">
          <source>ast.StarExpr</source>
          <target state="translated">ast.StarExpr</target>
        </trans-unit>
        <trans-unit id="1964d6b8d522047a124104e27818c8e2359c3692" translate="yes" xml:space="preserve">
          <source>ast.StarExpr.End()</source>
          <target state="translated">ast.StarExpr.End()</target>
        </trans-unit>
        <trans-unit id="50986ca8f36ea9c3fa33e8b919d7f85757eac03f" translate="yes" xml:space="preserve">
          <source>ast.StarExpr.Pos()</source>
          <target state="translated">ast.StarExpr.Pos()</target>
        </trans-unit>
        <trans-unit id="86f0f7a23d86131b9800aa9a989271077f20efab" translate="yes" xml:space="preserve">
          <source>ast.Stmt</source>
          <target state="translated">ast.Stmt</target>
        </trans-unit>
        <trans-unit id="b0dd6f652568d7067080d2ca2b56d2c88a8de03e" translate="yes" xml:space="preserve">
          <source>ast.StructType</source>
          <target state="translated">ast.StructType</target>
        </trans-unit>
        <trans-unit id="1e930ddc8c4a5774d8053572f446cfe1f98baf5e" translate="yes" xml:space="preserve">
          <source>ast.StructType.End()</source>
          <target state="translated">ast.StructType.End()</target>
        </trans-unit>
        <trans-unit id="974d34f27a1b29932a04081b3b62b729e35d50ad" translate="yes" xml:space="preserve">
          <source>ast.StructType.Pos()</source>
          <target state="translated">ast.StructType.Pos()</target>
        </trans-unit>
        <trans-unit id="3bfefae46bec9a84aa0dcdec1fdb96fe9e8dc5e9" translate="yes" xml:space="preserve">
          <source>ast.SwitchStmt</source>
          <target state="translated">ast.SwitchStmt</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
