<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="go">
    <body>
      <group id="go">
        <trans-unit id="043f79dd25246a384c5fa68242e8b0950e54d69e" translate="yes" xml:space="preserve">
          <source>The comparison functions work on any values whose type Go defines as comparable. For basic types such as integers, the rules are relaxed: size and exact type are ignored, so any integer value, signed or unsigned, may be compared with any other integer value. (The arithmetic value is compared, not the bit pattern, so all negative integers are less than all unsigned integers.) However, as usual, one may not compare an int with a float32 and so on.</source>
          <target state="translated">비교 함수는 Go 유형이 비교 가능한 것으로 정의하는 모든 값에서 작동합니다. 정수와 같은 기본 유형의 경우 규칙이 완화됩니다. 크기와 정확한 유형은 무시되므로 부호가 있거나 부호가없는 모든 정수 값을 다른 정수 값과 비교할 수 있습니다. (비트 패턴이 아닌 산술 값이 비교되므로 모든 음의 정수는 모든 부호없는 정수보다 작습니다.) 그러나 평소와 같이 int를 float32 등과 비교할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="53528cbdfa92cb465406c07ac6068163f15d8aff" translate="yes" xml:space="preserve">
          <source>The comparison functions work on basic types only (or named basic types, such as &quot;type Celsius float32&quot;). They implement the Go rules for comparison of values, except that size and exact type are ignored, so any integer value, signed or unsigned, may be compared with any other integer value. (The arithmetic value is compared, not the bit pattern, so all negative integers are less than all unsigned integers.) However, as usual, one may not compare an int with a float32 and so on.</source>
          <target state="translated">비교 함수는 기본 유형 (또는 &quot;type Celsius float32&quot;와 같은 명명 된 기본 유형)에서만 작동합니다. 크기와 정확한 유형이 무시되는 것을 제외하고 값 비교를 위해 Go 규칙을 구현하므로 부호가 있거나 부호가없는 정수 값을 다른 정수 값과 비교할 수 있습니다. (산술 값은 비트 패턴이 아니라 비교되므로 모든 음의 정수는 부호없는 모든 정수보다 작습니다.) 그러나 평소와 같이 int를 float32 등과 비교하지 못할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3947ad8b82d2733c9797fbc944569005335da23c" translate="yes" xml:space="preserve">
          <source>The compiler handles a Pointer converted to a uintptr in the argument list of a call to a function implemented in assembly by arranging that the referenced allocated object, if any, is retained and not moved until the call completes, even though from the types alone it would appear that the object is no longer needed during the call.</source>
          <target state="translated">컴파일러는 참조 된 할당 된 객체가있는 경우 유지되고 호출이 완료 될 때까지 이동하지 않도록 배열에 구현 된 함수에 대한 호출의 인수 목록에서 uintptr로 변환 된 포인터를 처리합니다. 통화 중에 객체가 더 이상 필요하지 않은 것처럼 보입니다.</target>
        </trans-unit>
        <trans-unit id="fbe6ac33b06dc273e75926ad2490d8b3832a0214" translate="yes" xml:space="preserve">
          <source>The complex built-in function constructs a complex value from two floating-point values. The real and imaginary parts must be of the same size, either float32 or float64 (or assignable to them), and the return value will be the corresponding complex type (complex64 for float32, complex128 for float64).</source>
          <target state="translated">복합 내장 함수는 두 개의 부동 소수점 값으로 복합 값을 구성합니다. 실수와 허수 부분의 크기는 float32 또는 float64 (또는 그에 할당 가능)와 동일해야하며 반환 값은 해당 복합 유형 (float32의 경우 complex64, float64의 경우 complex128)이됩니다.</target>
        </trans-unit>
        <trans-unit id="ef38d7c2bab871a13bc3d0543cc12b1189486358" translate="yes" xml:space="preserve">
          <source>The compression level can be DefaultCompression, NoCompression, HuffmanOnly or any integer value between BestSpeed and BestCompression inclusive. The error returned will be nil if the level is valid.</source>
          <target state="translated">압축 수준은 DefaultCompression, NoCompression, HuffmanOnly 또는 BestSpeed와 BestCompression 사이의 정수 값일 수 있습니다. 수준이 유효하면 반환 된 오류는 nil입니다.</target>
        </trans-unit>
        <trans-unit id="0a1efe910d68e12343aa1a848eb28de270b6d379" translate="yes" xml:space="preserve">
          <source>The computed hash values depend only on the initial seed and the sequence of bytes provided to the Hash object, not on the way in which the bytes are provided. For example, the three sequences</source>
          <target state="translated">계산 된 해시 값은 바이트가 제공되는 방식이 아니라 Hash 객체에 제공되는 초기 시드 및 바이트 시퀀스에만 의존합니다. 예를 들어, 세 시퀀스</target>
        </trans-unit>
        <trans-unit id="351f67248e4d8a5518193363a02cfe1c83014012" translate="yes" xml:space="preserve">
          <source>The constant UpperLower has an otherwise impossible delta value.</source>
          <target state="translated">상수 UpperLower는 불가능한 델타 값을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="8c8706295858fb442cc0b27075b7f68668230e3c" translate="yes" xml:space="preserve">
          <source>The content's Seek method must work: ServeContent uses a seek to the end of the content to determine its size.</source>
          <target state="translated">콘텐츠의 Seek 메서드가 작동해야합니다. ServeContent는 콘텐츠의 끝을 탐색하여 크기를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="7a49805d773fd718112af263e9a481b6533ee15e" translate="yes" xml:space="preserve">
          <source>The context function will be called with a single argument, a pointer to a struct:</source>
          <target state="translated">컨텍스트 함수는 단일 인수, 구조체에 대한 포인터와 함께 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="d756f1871d5d4f318cef847f3f882a9119bd1f8d" translate="yes" xml:space="preserve">
          <source>The conversion rules are:</source>
          <target state="translated">변환 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8b9249f4b562855e188c8c6e04ee31f39d350295" translate="yes" xml:space="preserve">
          <source>The copy built-in function copies elements from a source slice into a destination slice. (As a special case, it also will copy bytes from a string to a slice of bytes.) The source and destination may overlap. Copy returns the number of elements copied, which will be the minimum of len(src) and len(dst).</source>
          <target state="translated">내장 복사 기능은 소스 슬라이스에서 대상 슬라이스로 요소를 복사합니다. 특수한 경우에는 문자열에서 바이트 조각으로 바이트를 복사하기도합니다. 소스와 대상이 겹칠 수 있습니다. 복사는 복사 된 요소 수를 리턴하며, 최소 len (src) 및 len (dst)입니다.</target>
        </trans-unit>
        <trans-unit id="7003f654a24cc0fe7e8417bb3241f59de9fe836b" translate="yes" xml:space="preserve">
          <source>The count determines the number of substrings to return:</source>
          <target state="translated">개수는 반환 할 부분 문자열 수를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="5dbb8e654b6fb0895661f0c315a08864e55ec239" translate="yes" xml:space="preserve">
          <source>The crypto/tls package only implements some countermeasures against Lucky13 attacks on CBC-mode encryption, and only on SHA1 variants. See &lt;a href=&quot;http://www.isg.rhul.ac.uk/tls/TLStiming.pdf&quot;&gt;http://www.isg.rhul.ac.uk/tls/TLStiming.pdf&lt;/a&gt; and &lt;a href=&quot;https://www.imperialviolet.org/2013/02/04/luckythirteen.html&quot;&gt;https://www.imperialviolet.org/2013/02/04/luckythirteen.html&lt;/a&gt;.</source>
          <target state="translated">crypto / tls 패키지는 CBC 모드 암호화 및 SHA1 변형에 대한 Lucky13 공격에 대한 일부 대책 만 구현합니다. &lt;a href=&quot;http://www.isg.rhul.ac.uk/tls/TLStiming.pdf&quot;&gt;http://www.isg.rhul.ac.uk/tls/TLStiming.pdf&lt;/a&gt; 및 &lt;a href=&quot;https://www.imperialviolet.org/2013/02/04/luckythirteen.html&quot;&gt;https://www.imperialviolet.org/2013/02/04/luckythirteen.html을&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="3df95d2be07bff158f354793704b39fa0b17441d" translate="yes" xml:space="preserve">
          <source>The cryptographic operations are implemented using constant-time algorithms.</source>
          <target state="translated">암호화 작업은 상수 시간 알고리즘을 사용하여 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="7eab6b01982b7d5d0967ad563265ae830b1ba245" translate="yes" xml:space="preserve">
          <source>The cryptographic operations do not use constant-time algorithms.</source>
          <target state="translated">암호화 작업은 상수 시간 알고리즘을 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="27e1f3bd597aed109fd98be320131ab37e282b69" translate="yes" xml:space="preserve">
          <source>The currently supported key types are *rsa.PublicKey, *ecdsa.PublicKey and ed25519.PublicKey. pub must be a supported key type, and priv must be a crypto.Signer with a supported public key.</source>
          <target state="translated">현재 지원되는 키 유형은 * rsa.PublicKey, * ecdsa.PublicKey 및 ed25519.PublicKey입니다. pub는 지원되는 키 유형이어야하며 priv는 지원되는 공개 키가있는 crypto.Signer 여야합니다.</target>
        </trans-unit>
        <trans-unit id="5f866cd795794ee9a8943b941d8f0f21dd57c5d8" translate="yes" xml:space="preserve">
          <source>The d argument is the fs.DirEntry for the named path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a6143ad908fa5d13101f2932405343a9fc3dd21" translate="yes" xml:space="preserve">
          <source>The debug parameter enables additional output. Passing debug=0 prints only the hexadecimal addresses that pprof needs. Passing debug=1 adds comments translating addresses to function names and line numbers, so that a programmer can read the profile without tools.</source>
          <target state="translated">디버그 매개 변수는 추가 출력을 가능하게합니다. debug = 0을 전달하면 pprof에 필요한 16 진 주소 만 인쇄됩니다. debug = 1을 전달하면 프로그래머가 도구없이 프로파일을 읽을 수 있도록 주소를 함수 이름 및 행 번호로 변환하는 주석을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="0fb33327b278ec03a78f307167cc6e36a7617010" translate="yes" xml:space="preserve">
          <source>The debug parameter enables additional output. Passing debug=0 writes the gzip-compressed protocol buffer described in &lt;a href=&quot;https://github.com/google/pprof/tree/master/proto#overview&quot;&gt;https://github.com/google/pprof/tree/master/proto#overview&lt;/a&gt;. Passing debug=1 writes the legacy text format with comments translating addresses to function names and line numbers, so that a programmer can read the profile without tools.</source>
          <target state="translated">디버그 매개 변수는 추가 출력을 활성화합니다. debug = 0을 전달하면 &lt;a href=&quot;https://github.com/google/pprof/tree/master/proto#overview&quot;&gt;https://github.com/google/pprof/tree/master/proto#overview에&lt;/a&gt; 설명 된 gzip 압축 프로토콜 버퍼가 작성 됩니다. debug = 1을 전달하면 프로그래머가 도구없이 프로필을 읽을 수 있도록 주소를 함수 이름과 줄 번호로 변환하는 주석이있는 레거시 텍스트 형식이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="bcfadeab38a63378303009891c62ea08d3a9f648" translate="yes" xml:space="preserve">
          <source>The decision can also be forced while building the Go source tree by setting the netgo or netcgo build tag.</source>
          <target state="translated">netgo 또는 netcgo 빌드 태그를 설정하여 Go 소스 트리를 구축하는 동안 결정을 강제 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e55a5ed5aee48109c8f556983bc2b6ba47049c1e" translate="yes" xml:space="preserve">
          <source>The decoded form returned by the Reader's Read method rewrites the &quot;\r\n&quot; line endings into the simpler &quot;\n&quot;, removes leading dot escapes if present, and stops with error io.EOF after consuming (and discarding) the end-of-sequence line.</source>
          <target state="translated">Reader의 Read 메서드에 의해 반환 된 디코딩 된 형식은 &quot;\ r \ n&quot;줄 끝을 더 간단한 &quot;\ n&quot;으로 다시 쓰고 앞의 점 이스케이프를 제거하고 오류가있는 경우 io.EOF와 함께 종료합니다. 시퀀스 라인.</target>
        </trans-unit>
        <trans-unit id="ade9eaf300f62ddbbf2f36e130c2f06e8467d26d" translate="yes" xml:space="preserve">
          <source>The decoder introduces its own buffering and may read data from r beyond the JSON values requested.</source>
          <target state="translated">디코더는 자체 버퍼링을 도입하고 요청 된 JSON 값을 넘어 r에서 데이터를 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="500a9025cc154f7f8f86d7b577b23c5a4330caf0" translate="yes" xml:space="preserve">
          <source>The default HTTP/1.x and HTTP/2 ResponseWriter implementations support Flusher, but ResponseWriter wrappers may not. Handlers should always test for this ability at runtime.</source>
          <target state="translated">기본 HTTP / 1.x 및 HTTP / 2 ResponseWriter 구현은 Flusher를 지원하지만 ResponseWriter 랩퍼는 지원하지 않을 수 있습니다. 처리기는 항상 런타임에이 기능을 테스트해야합니다.</target>
        </trans-unit>
        <trans-unit id="dbfff1190b706ff9c82ad5d939db53ac5e19b8d5" translate="yes" xml:space="preserve">
          <source>The default ResponseWriter for HTTP/1.x connections supports Hijacker, but HTTP/2 connections intentionally do not. ResponseWriter wrappers may also not support Hijacker. Handlers should always test for this ability at runtime.</source>
          <target state="translated">HTTP / 1.x 연결 용 기본 ResponseWriter는 Hijacker를 지원하지만 HTTP / 2 연결은 의도적으로 지원하지 않습니다. ResponseWriter 랩퍼도 Hijacker를 지원하지 않을 수 있습니다. 처리기는 항상 런타임에이 기능을 테스트해야합니다.</target>
        </trans-unit>
        <trans-unit id="29a4bf6e98ccc92440a0810fcad76a8019aec7ff" translate="yes" xml:space="preserve">
          <source>The default behavior is to unlink the socket file only when package net created it. That is, when the listener and the underlying socket file were created by a call to Listen or ListenUnix, then by default closing the listener will remove the socket file. but if the listener was created by a call to FileListener to use an already existing socket file, then by default closing the listener will not remove the socket file.</source>
          <target state="translated">기본 동작은 package net에서 소켓 파일을 만든 경우에만 연결 해제하는 것입니다. 즉, 리스너와 기본 소켓 파일이 Listen 또는 ListenUnix에 대한 호출로 작성되면 기본적으로 리스너를 닫으면 소켓 파일이 제거됩니다. 그러나 이미 존재하는 소켓 파일을 사용하기 위해 FileListener를 호출하여 리스너를 작성한 경우, 기본적으로 리스너를 닫으면 소켓 파일이 제거되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f3bd4ca778e016b570e20fa99bcd057793129198" translate="yes" xml:space="preserve">
          <source>The default format for %v is:</source>
          <target state="translated">% v의 기본 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e5fbfa4bdd17cdbfb6f18b5cea533902d960ee26" translate="yes" xml:space="preserve">
          <source>The default max idle connections is currently 2. This may change in a future release.</source>
          <target state="translated">기본 최대 유휴 연결은 현재 2입니다. 이것은 다음 릴리스에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="385f08ab994be40fdde70d56e38ccb63bb65d078" translate="yes" xml:space="preserve">
          <source>The default set of command-line flags is controlled by top-level functions. The FlagSet type allows one to define independent sets of flags, such as to implement subcommands in a command-line interface. The methods of FlagSet are analogous to the top-level functions for the command-line flag set.</source>
          <target state="translated">기본 명령 줄 플래그 집합은 최상위 기능에 의해 제어됩니다. FlagSet 유형을 사용하면 명령 줄 인터페이스에서 하위 명령을 구현하는 등 독립적 인 플래그 집합을 정의 할 수 있습니다. FlagSet의 메소드는 명령 행 플래그 세트의 최상위 기능과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="a05d93e44d2bb1f3518c258e77ecac2e52df5b7c" translate="yes" xml:space="preserve">
          <source>The define action names the template being created by providing a string constant. Here is a simple example:</source>
          <target state="translated">정의 조치는 문자열 상수를 제공하여 작성중인 템플리트의 이름을 지정합니다. 다음은 간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="1752a2a854e41ac9841751567fab2d2b00d5fd9e" translate="yes" xml:space="preserve">
          <source>The defined file mode bits are the most significant bits of the FileMode. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added.</source>
          <target state="translated">정의 된 파일 모드 비트는 FileMode의 최상위 비트입니다. 9 개의 최하위 비트는 표준 Unix rwxrwxrwx 권한입니다. 이 비트 값은 공개 API의 일부로 간주되어야하며 유선 프로토콜 또는 디스크 표현에 사용될 수 있습니다. 새 비트가 추가 될 수는 있지만 변경해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="5cff7ee8fa31e3f6a6739a2dee232b717a523c6f" translate="yes" xml:space="preserve">
          <source>The delete built-in function deletes the element with the specified key (m[key]) from the map. If m is nil or there is no such element, delete is a no-op.</source>
          <target state="translated">내장 기능 삭제 기능은 지정된 키 (m [key])를 가진 요소를 맵에서 삭제합니다. m이 nil이거나 그러한 요소가없는 경우 delete는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7be6f8c0500d37b62c7237cb3172e8612a1be7ae" translate="yes" xml:space="preserve">
          <source>The dictionary may be nil. If not, its contents should not be modified until the Writer is closed.</source>
          <target state="translated">사전이 없을 수 있습니다. 그렇지 않으면 기록기가 닫힐 때까지 내용을 수정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="4b0f9980f9925bb5ac741f7cd28fdb88d41be31b" translate="yes" xml:space="preserve">
          <source>The difference is that &amp;lsquo;image/*&amp;rsquo; embeds &amp;lsquo;image/.tempfile&amp;rsquo; while &amp;lsquo;image&amp;rsquo; does not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88f694bd36bf5619a0472bfb05ef008949d8b1c4" translate="yes" xml:space="preserve">
          <source>The differences between WalkDirFunc compared to filepath.WalkFunc are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc9a068b7cdbaff9efc9114bb2316dc6eaf9165d" translate="yes" xml:space="preserve">
          <source>The direction of a channel is indicated by one of these constants.</source>
          <target state="translated">채널의 방향은 이러한 상수 중 하나로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="46b217ce09d8bd67e6158257fb40490e88a671dd" translate="yes" xml:space="preserve">
          <source>The direction of a channel type is indicated by a bit mask including one or both of the following constants.</source>
          <target state="translated">채널 유형의 방향은 다음 상수 중 하나 또는 둘 다를 포함하는 비트 마스크로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="b6be0a4961d7acbc941fa11a19835445036b49c8" translate="yes" xml:space="preserve">
          <source>The directive must immediately precede a line containing the declaration of a single variable. Only blank lines and &amp;lsquo;//&amp;rsquo; line comments are permitted between the directive and the declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eee9b912ab49812886d0cf5f9ad11f8fdfc055f4" translate="yes" xml:space="preserve">
          <source>The directory and file are joined with Join, which may clean the directory name: if Walk is called with the root argument &quot;x/../dir&quot; and finds a file named &quot;a&quot; in that directory, the walk function will be called with argument &quot;dir/a&quot;, not &quot;x/../dir/a&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dfb11306d6f3241074422bcaa067904172344cc" translate="yes" xml:space="preserve">
          <source>The directory is neither guaranteed to exist nor have accessible permissions.</source>
          <target state="translated">디렉토리가 존재한다고 보증 할 수 없으며 액세스 가능한 권한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="565d684eeda7e9edb8f7bb0c103897df1854d973" translate="yes" xml:space="preserve">
          <source>The documentation for http.Request.Write details which fields of req are included in the dump.</source>
          <target state="translated">http.Request.Write에 대한 문서는 덤프에 포함 된 req 필드를 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="07211f6185f4e6de4337f341c2cdb69d4cc499c7" translate="yes" xml:space="preserve">
          <source>The documentation here focuses on the security features of the package. For information about how to program the templates themselves, see the documentation for text/template.</source>
          <target state="translated">이 문서는 패키지의 보안 기능에 중점을 둡니다. 템플릿 자체를 프로그래밍하는 방법에 대한 자세한 내용은 텍스트 / 템플릿 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="155a6f0a50ad424a0f77dec85fedb05aad3e6814" translate="yes" xml:space="preserve">
          <source>The driver interface has evolved over time. Drivers should implement Connector and DriverContext interfaces. The Connector.Connect and Driver.Open methods should never return ErrBadConn. ErrBadConn should only be returned from Validator, SessionResetter, or a query method if the connection is already in an invalid (e.g. closed) state.</source>
          <target state="translated">드라이버 인터페이스는 시간이 지남에 따라 발전했습니다. 드라이버는 Connector 및 DriverContext 인터페이스를 구현해야합니다. Connector.Connect 및 Driver.Open 메서드는 ErrBadConn을 반환하지 않아야합니다. ErrBadConn은 Validator, SessionResetter 또는 연결이 이미 유효하지 않은 (예 : 닫힌) 상태 인 경우 쿼리 메서드에서만 반환되어야합니다.</target>
        </trans-unit>
        <trans-unit id="d608ae58f506a273826ac24fbe8a6e832c7cfa18" translate="yes" xml:space="preserve">
          <source>The earlier index entries are the indices of the embedded fields implicitly traversed to get from (the type of) x to f, starting at embedding depth 0.</source>
          <target state="translated">이전 색인 항목은 임베드 깊이 0에서 시작하여 x에서 f로 유형을 가져 오기 위해 암시 적으로 순회 된 임베드 된 필드의 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="9969cd1fd12276c81b2d25b52e841cee1f38a6af" translate="yes" xml:space="preserve">
          <source>The earlier index entries are the indices of the embedded struct fields traversed to get to the found entry, starting at depth 0.</source>
          <target state="translated">이전 색인 항목은 깊이 0에서 시작하여 찾은 항목에 도달하기 위해 순회 된 임베드 된 struct 필드의 색인입니다.</target>
        </trans-unit>
        <trans-unit id="55f7215f8e7a1256ecd44a2e72424fdc36866f77" translate="yes" xml:space="preserve">
          <source>The encoded form is:</source>
          <target state="translated">인코딩 된 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="58738aa6dbb46f39a2d83f07741091a7022a1024" translate="yes" xml:space="preserve">
          <source>The encoding handles 4-byte chunks, using a special encoding for the last fragment, so Encode is not appropriate for use on individual blocks of a large data stream. Use NewEncoder() instead.</source>
          <target state="translated">인코딩은 마지막 조각에 대한 특수 인코딩을 사용하여 4 바이트 청크를 처리하므로 큰 데이터 스트림의 개별 블록에 사용하기에는 적합하지 않습니다. 대신 NewEncoder ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="352cf3ce7f63c6b9e4ef698575b243f2f7eab5f4" translate="yes" xml:space="preserve">
          <source>The encoding of each struct field can be customized by the format string stored under the &quot;json&quot; key in the struct field's tag. The format string gives the name of the field, possibly followed by a comma-separated list of options. The name may be empty in order to specify options without overriding the default field name.</source>
          <target state="translated">각 구조체 필드의 인코딩은 구조체 필드의 태그에서 &quot;json&quot;키 아래에 저장된 형식 문자열로 사용자 정의 할 수 있습니다. 형식 문자열은 필드 이름을 제공하며 쉼표로 구분 된 옵션 목록이 나옵니다. 기본 필드 이름을 재정의하지 않고 옵션을 지정하기 위해 이름이 비어있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17b6791f4c87db95fbf5fcc1580f710e0b98bcc7" translate="yes" xml:space="preserve">
          <source>The encoding pads the output to a multiple of 4 bytes, so Encode is not appropriate for use on individual blocks of a large data stream. Use NewEncoder() instead.</source>
          <target state="translated">인코딩은 출력을 4 바이트의 배수로 채 웁니다. 따라서 인코딩은 큰 데이터 스트림의 개별 블록에 사용하기에 적합하지 않습니다. 대신 NewEncoder ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f9b92d6b313993a8570c418851ae0a82ee1d08b2" translate="yes" xml:space="preserve">
          <source>The encoding pads the output to a multiple of 8 bytes, so Encode is not appropriate for use on individual blocks of a large data stream. Use NewEncoder() instead.</source>
          <target state="translated">인코딩은 출력을 8 바이트의 배수로 채 웁니다. 따라서 인코딩은 큰 데이터 스트림의 개별 블록에 사용하기에 적합하지 않습니다. 대신 NewEncoder ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f21e6b7ab20b84c2608ae859489552989b9c9ded" translate="yes" xml:space="preserve">
          <source>The entire test file is presented as the example when it contains a single example function, at least one other function, type, variable, or constant declaration, and no test or benchmark functions.</source>
          <target state="translated">전체 테스트 파일은 단일 예제 함수, 하나 이상의 다른 함수, 유형, 변수 또는 상수 선언을 포함하고 테스트 또는 벤치 마크 함수가없는 경우 예제로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="8a5b41cf040dd894c5f5818385e864bb8f5f4256" translate="yes" xml:space="preserve">
          <source>The environment values may be either a complete URL or a &quot;host[:port]&quot;, in which case the &quot;http&quot; scheme is assumed. An error is returned if the value is a different form.</source>
          <target state="translated">환경 값은 완전한 URL 또는 &quot;host [: port]&quot;일 수 있으며,이 경우 &quot;http&quot;체계가 가정됩니다. 값이 다른 형식이면 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="118f5185e20d76d2e409557c089e1ce07b52abd5" translate="yes" xml:space="preserve">
          <source>The err argument reports an error related to path, signaling that Walk will not walk into that directory. The function can decide how to handle that error; as described earlier, returning the error will cause Walk to stop walking the entire tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="282f6346653700d9616b9fe704e3acbbfd78027c" translate="yes" xml:space="preserve">
          <source>The err argument reports an error related to path, signaling that WalkDir will not walk into that directory. The function can decide how to handle that error; as described earlier, returning the error will cause WalkDir to stop walking the entire tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63d88a909a5214b04c717d2600360e2bf8c34633" translate="yes" xml:space="preserve">
          <source>The error built-in interface type is the conventional interface for representing an error condition, with the nil value representing no error.</source>
          <target state="translated">오류 내장 인터페이스 유형은 오류 조건을 나타내는 일반적인 인터페이스이며, nil 값은 오류가 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="057113f0f11fb7ab423f9c5529d153f0951fafc6" translate="yes" xml:space="preserve">
          <source>The error is EOF only if no bytes were read. If an EOF happens after reading some but not all the bytes, Read returns ErrUnexpectedEOF.</source>
          <target state="translated">읽은 바이트가없는 경우에만 오류가 EOF입니다. 일부 바이트 만 읽은 후 EOF가 발생하면 Read는 ErrUnexpectedEOF를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="eeed3acdc77455956d53c59d08490cc51e5c519c" translate="yes" xml:space="preserve">
          <source>The error result returned by the function controls how Walk continues. If the function returns the special value SkipDir, Walk skips the current directory (path if info.IsDir() is true, otherwise path's parent directory). Otherwise, if the function returns a non-nil error, Walk stops entirely and returns that error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bdf1212e16d5b6273e524308d0d3b1c562326fa" translate="yes" xml:space="preserve">
          <source>The error result returned by the function controls how WalkDir continues. If the function returns the special value SkipDir, WalkDir skips the current directory (path if d.IsDir() is true, otherwise path's parent directory). Otherwise, if the function returns a non-nil error, WalkDir stops entirely and returns that error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53b8936240ed1387970343e072546b9e5c4ce38c" translate="yes" xml:space="preserve">
          <source>The errors that ParseComplex returns have concrete type *NumError and include err.Num = s.</source>
          <target state="translated">ParseComplex가 반환하는 오류는 구체적인 유형 * NumError이고 err.Num = s를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="e19a9195a1344f79f24fd7f396a97d73332aa946" translate="yes" xml:space="preserve">
          <source>The errors that ParseFloat returns have concrete type *NumError and include err.Num = s.</source>
          <target state="translated">ParseFloat가 리턴하는 오류에는 구체적인 유형 * NumError가 있으며 err.Num = s가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="235cee0ee469905c73061c3ebbf12b0afd87e749" translate="yes" xml:space="preserve">
          <source>The errors that ParseInt returns have concrete type *NumError and include err.Num = s. If s is empty or contains invalid digits, err.Err = ErrSyntax and the returned value is 0; if the value corresponding to s cannot be represented by a signed integer of the given size, err.Err = ErrRange and the returned value is the maximum magnitude integer of the appropriate bitSize and sign.</source>
          <target state="translated">ParseInt가 리턴하는 오류에는 구체적인 유형 * NumError가 있으며 err.Num = s가 포함됩니다. s가 비어 있거나 유효하지 않은 숫자가 포함 된 경우 err.Err = ErrSyntax이며 반환 값은 0입니다. s에 해당하는 값이 지정된 크기의 부호있는 정수로 표시 될 수없는 경우 err.Err = ErrRange이며 리턴 된 값은 해당 bitSize 및 부호의 최대 크기 정수입니다.</target>
        </trans-unit>
        <trans-unit id="1079b4c215daaeaddfd42a5c24ae40421a24ca31" translate="yes" xml:space="preserve">
          <source>The exact method of division of a binary into separate Objs is an internal detail of the symbol table format.</source>
          <target state="translated">바이너리를 별도의 Objs로 나누는 정확한 방법은 심볼 테이블 형식의 내부 세부 사항입니다.</target>
        </trans-unit>
        <trans-unit id="704442846624164254cefb0621f909b9f8e7b255" translate="yes" xml:space="preserve">
          <source>The executable example for Time.Format demonstrates the working of the layout string in detail and is a good reference.</source>
          <target state="translated">Time.Format의 실행 예제는 레이아웃 문자열의 작동을 자세하게 보여 주며 좋은 참조입니다.</target>
        </trans-unit>
        <trans-unit id="d1e6774ae13e892b5b495469c8177e657ea29b91" translate="yes" xml:space="preserve">
          <source>The execution trace captures a wide range of execution events such as goroutine creation/blocking/unblocking, syscall enter/exit/block, GC-related events, changes of heap size, processor start/stop, etc. A precise nanosecond-precision timestamp and a stack trace is captured for most events. The generated trace can be interpreted using `go tool trace`.</source>
          <target state="translated">실행 추적은 고 루틴 생성 / 차단 / 차단 해제, syscall 입력 / 종료 / 차단, GC 관련 이벤트, 힙 크기 변경, 프로세서 시작 / 중지 등과 같은 광범위한 실행 이벤트를 캡처합니다. 정밀한 나노초 정밀도 타임 스탬프 및 스택 추적은 대부분의 이벤트에 대해 캡처됩니다. 생성 된 트레이스는`go tool trace`를 사용하여 해석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0bb8da556b82de3d2273cd84d139d0610336a88a" translate="yes" xml:space="preserve">
          <source>The familiar base-setting prefixes 0b (binary), 0o and 0 (octal), and 0x (hexadecimal) are accepted when scanning integers without a format or with the %v verb, as are digit-separating underscores.</source>
          <target state="translated">친숙한 기본 설정 접두사 0b (2 진), 0o 및 0 (8 진) 및 0x (16 진)는 숫자 구분 밑줄과 같이 형식이 없거나 % v 동사를 사용하여 정수를 스캔 할 때 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="f9ffee1670410a5e7cd11d5f1bee248ae5a136bc" translate="yes" xml:space="preserve">
          <source>The field semantics differ slightly between client and server usage. In addition to the notes on the fields below, see the documentation for Request.Write and RoundTripper.</source>
          <target state="translated">필드 의미는 클라이언트와 서버 사용간에 약간 다릅니다. 아래 필드에 대한 참고 사항 외에도 Request.Write 및 RoundTripper에 대한 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="055e51145f588ea85435a4c1863b09a1b1141496" translate="yes" xml:space="preserve">
          <source>The file name table of a compilation unit is not fixed. Files returns the file table as of the current position in the line table. This may contain more entries than the file table at an earlier position in the line table, though existing entries never change.</source>
          <target state="translated">컴파일 단위의 파일명 테이블은 고정되어 있지 않습니다. 파일은 라인 테이블의 현재 위치를 기준으로 파일 테이블을 반환합니다. 기존 항목은 변경되지 않지만 행 테이블의 이전 위치에있는 파일 테이블보다 더 많은 항목을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc18f2dd0c8c98e57212ed20f1a2ef2dc2747c6d" translate="yes" xml:space="preserve">
          <source>The file's data can then be read into a slice of bytes. Read and Write take their byte counts from the length of the argument slice.</source>
          <target state="translated">그런 다음 파일의 데이터를 바이트 조각으로 읽을 수 있습니다. 읽기 및 쓰기는 인수 슬라이스의 길이에서 바이트 수를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="bf3df07f08dd9391973ec022887d04b86f02f1b9" translate="yes" xml:space="preserve">
          <source>The filepath package uses either forward slashes or backslashes, depending on the operating system. To process paths such as URLs that always use forward slashes regardless of the operating system, see the path package.</source>
          <target state="translated">파일 경로 패키지는 운영 체제에 따라 슬래시 또는 백 슬래시를 사용합니다. 운영 체제와 상관없이 항상 슬래시를 사용하는 URL과 같은 경로를 처리하려면 경로 패키지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="44d9396e877785e7c01e9d43d99cf0cdefb65dc4" translate="yes" xml:space="preserve">
          <source>The files are walked in lexical order, which makes the output deterministic but requires Walk to read an entire directory into memory before proceeding to walk that directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d47cce3bdf876fa4c8fd7554f61be344c06ff401" translate="yes" xml:space="preserve">
          <source>The files are walked in lexical order, which makes the output deterministic but requires WalkDir to read an entire directory into memory before proceeding to walk that directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2a5de21556a23ce2ab6268f51afe1d5e198e5ff" translate="yes" xml:space="preserve">
          <source>The finalizer is scheduled to run at some arbitrary time after the program can no longer reach the object to which obj points. There is no guarantee that finalizers will run before a program exits, so typically they are useful only for releasing non-memory resources associated with an object during a long-running program. For example, an os.File object could use a finalizer to close the associated operating system file descriptor when a program discards an os.File without calling Close, but it would be a mistake to depend on a finalizer to flush an in-memory I/O buffer such as a bufio.Writer, because the buffer would not be flushed at program exit.</source>
          <target state="translated">종료자는 프로그램이 더 이상 obj가 가리키는 객체에 도달 할 수없는 후 임의의 시간에 실행되도록 예약됩니다. 종료자는 프로그램이 종료되기 전에 실행된다는 보장이 없으므로 일반적으로 장기 실행 프로그램 중에 오브젝트와 연관된 비 메모리 자원을 해제하는 경우에만 유용합니다. 예를 들어, os.File 객체는 프로그램이 Close를 호출하지 않고 os.File을 버릴 때 종료자를 사용하여 관련 운영 체제 파일 설명자를 닫을 수 있지만 메모리 내 I를 플러시하기 위해 종료자를 의존하는 것은 실수입니다 프로그램 종료시 버퍼가 플러시되지 않으므로 bufio.Writer와 같은 / O 버퍼</target>
        </trans-unit>
        <trans-unit id="b1e301ef4e8e6bbc26fb8b640366f5d912e010bd" translate="yes" xml:space="preserve">
          <source>The first call to ReadContinuedLine will return &quot;Line 1 continued...&quot; and the second will return &quot;Line 2&quot;.</source>
          <target state="translated">ReadContinuedLine에 대한 첫 번째 호출은 &quot;Line 1 continue ...&quot;를 반환하고 두 번째 호출은 &quot;Line 2&quot;를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="aa248e4cf567dddf42fcb3d7320a5fbdd025b032" translate="yes" xml:space="preserve">
          <source>The first call will cache the current user information. Subsequent calls will return the cached value and will not reflect changes to the current user.</source>
          <target state="translated">첫 번째 통화는 현재 사용자 정보를 캐시합니다. 후속 호출은 캐시 된 값을 반환하며 현재 사용자의 변경 사항을 반영하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="da786a1e6a510514415594e5971ba9d3b0ef0c66" translate="yes" xml:space="preserve">
          <source>The first key will be used when creating new tickets, while all keys can be used for decrypting tickets. It is safe to call this function while the server is running in order to rotate the session ticket keys. The function will panic if keys is empty.</source>
          <target state="translated">첫 번째 키는 새 티켓을 만들 때 사용되며 모든 키는 티켓 암호 해독에 사용될 수 있습니다. 세션 티켓 키를 순환시키기 위해 서버가 실행되는 동안이 함수를 호출하는 것이 안전합니다. 키가 비어 있으면 기능이 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="f9bea105d5515e425130c674b9a6d60024d04428" translate="yes" xml:space="preserve">
          <source>The first step to profiling a Go program is to enable profiling. Support for profiling benchmarks built with the standard testing package is built into go test. For example, the following command runs benchmarks in the current directory and writes the CPU and memory profiles to cpu.prof and mem.prof:</source>
          <target state="translated">Go 프로그램 프로파일 링의 첫 번째 단계는 프로파일 링을 활성화하는 것입니다. 표준 테스트 패키지로 구축 된 프로파일 링 벤치 마크 지원은 go test에 내장되어 있습니다. 예를 들어 다음 명령은 현재 디렉토리에서 벤치 마크를 실행하고 CPU 및 메모리 프로파일을 cpu.prof 및 mem.prof에 씁니다.</target>
        </trans-unit>
        <trans-unit id="436dd80ca68673a729fce026c246571c6f61d421" translate="yes" xml:space="preserve">
          <source>The first time the function is called for a particular traceback, all the fields except PC will be 0. The function should fill in the other fields if possible, setting them to 0/nil if the information is not available. The Data field may be used to store any useful information across calls. The More field should be set to non-zero if there is more information for this PC, zero otherwise. If More is set non-zero, the function will be called again with the same PC, and may return different information (this is intended for use with inlined functions). If More is zero, the function will be called with the next PC value in the traceback. When the traceback is complete, the function will be called once more with PC set to zero; this may be used to free any information. Each call will leave the fields of the struct set to the same values they had upon return, except for the PC field when the More field is zero. The function must not keep a copy of the struct pointer between calls.</source>
          <target state="translated">특정 역 추적에 대해 함수를 처음 호출하면 PC를 제외한 모든 필드가 0이됩니다. 가능하면 다른 필드를 채우고 정보를 사용할 수없는 경우 0 / nil로 설정해야합니다. 데이터 필드는 모든 통화에서 유용한 정보를 저장하는 데 사용될 수 있습니다. 이 PC에 대한 추가 정보가 있으면 More 필드를 0이 아닌 값으로 설정하고 그렇지 않으면 0을 설정해야합니다. More가 0이 아닌 값으로 설정되면 동일한 PC에서 함수가 다시 호출되고 다른 정보를 리턴 할 수 있습니다 (인라인 된 함수와 함께 사용하기위한 것임). More가 0이면이 함수는 트레이스 백에서 다음 PC 값으로 호출됩니다. 역 추적이 완료되면 PC가 0으로 설정된 상태에서 함수가 한 번 더 호출됩니다. 정보를 비우는 데 사용될 수 있습니다.More 필드가 0 일 때 PC 필드를 제외하고 각 호출은 구조체의 필드를 반환 할 때와 동일한 값으로 설정합니다. 함수는 호출 사이에 구조체 포인터의 사본을 보관해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="1c12332b1a7f816e653faac5972323a1a86f4075" translate="yes" xml:space="preserve">
          <source>The fmt package's Errorf function lets us use the package's formatting features to create descriptive error messages.</source>
          <target state="translated">fmt 패키지의 Errorf 기능을 사용하면 패키지의 포맷 기능을 사용하여 설명적인 오류 메시지를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="daed29ba07a438b86a35f4ffceadf0ee0b2962c4" translate="yes" xml:space="preserve">
          <source>The following environment variables ($name or %name%, depending on the host operating system) control the run-time behavior of Go programs. The meanings and use may change from release to release.</source>
          <target state="translated">다음 환경 변수 (호스트 운영 체제에 따라 $ name 또는 % name %)는 Go 프로그램의 런타임 동작을 제어합니다. 의미와 사용은 릴리스마다 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d76a76a5baf9188ebac1a65a2793d054e97d3403" translate="yes" xml:space="preserve">
          <source>The following example shows how to maintain a scalable frequently read, but infrequently updated data structure using copy-on-write idiom.</source>
          <target state="translated">다음 예제는 copy-on-write 관용구를 사용하여 확장 가능하고 자주 읽지 만 자주 업데이트되지 않는 데이터 구조를 유지하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="3f0a6fe70878d3ed973c5f4c4f9e11a4b37e3d2a" translate="yes" xml:space="preserve">
          <source>The following example shows how to use Value for periodic program config updates and propagation of the changes to worker goroutines.</source>
          <target state="translated">다음 예제는 주기적 프로그램 구성 업데이트 및 변경 사항을 작업자 goroutines에 전파하기 위해 Value를 사용하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="2cccb14470014df050daea92c16a16fd189e8367" translate="yes" xml:space="preserve">
          <source>The following forms are permitted:</source>
          <target state="translated">다음과 같은 형식이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="f535af253987553534ec7b604b13bea0bafaf89a" translate="yes" xml:space="preserve">
          <source>The following key types are currently supported: *rsa.PrivateKey, *ecdsa.PrivateKey and ed25519.PrivateKey. Unsupported key types result in an error.</source>
          <target state="translated">현재 지원되는 키 유형은 * rsa.PrivateKey, * ecdsa.PrivateKey 및 ed25519.PrivateKey입니다. 지원되지 않는 키 유형으로 인해 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="db7a430d5590cf9adf90b727249460131ab84e28" translate="yes" xml:space="preserve">
          <source>The following key types are currently supported: *rsa.PublicKey, *ecdsa.PublicKey and ed25519.PublicKey. Unsupported key types result in an error.</source>
          <target state="translated">현재 지원되는 키 유형은 * rsa.PublicKey, * ecdsa.PublicKey 및 ed25519.PublicKey입니다. 지원되지 않는 키 유형으로 인해 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="575dc13df3822635a20233f0d934b2828c4cbcc1" translate="yes" xml:space="preserve">
          <source>The following patterns involving Pointer are valid. Code not using these patterns is likely to be invalid today or to become invalid in the future. Even the valid patterns below come with important caveats.</source>
          <target state="translated">포인터와 관련된 다음 패턴이 유효합니다. 이러한 패턴을 사용하지 않는 코드는 현재 유효하지 않거나 향후 유효하지 않을 수 있습니다. 아래의 유효한 패턴조차도 중요한 경고와 함께 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="ea1b5d42ec809a44272262968add764fd0382aa5" translate="yes" xml:space="preserve">
          <source>The following table captures the capabilities of each format:</source>
          <target state="translated">다음 표는 각 형식의 기능을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="00ec28c9d7b575a36a11e5441e71a7350e3c8790" translate="yes" xml:space="preserve">
          <source>The following tags on struct fields have special meaning to Unmarshal:</source>
          <target state="translated">구조체 필드의 다음 태그는 비 정렬 화에 특별한 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b74a12e0ee03ebdd96a1e5698ef65e80645b4c11" translate="yes" xml:space="preserve">
          <source>The format fmt and precision prec have the same meaning as in FormatFloat. It rounds the result assuming that the original was obtained from a complex value of bitSize bits, which must be 64 for complex64 and 128 for complex128.</source>
          <target state="translated">형식 fmt 및 정밀도 prec는 FormatFloat에서와 동일한 의미를 갖습니다. 원본이 bitSize 비트의 복소 값에서 얻은 것으로 가정하여 결과를 반올림합니다. 이는 complex64의 경우 64이고 complex128의 경우 128이어야합니다.</target>
        </trans-unit>
        <trans-unit id="89924ba6250a79536c8a80bb6ca7f28f4193a60a" translate="yes" xml:space="preserve">
          <source>The format fmt is one of 'b' (-ddddp&amp;plusmn;ddd, a binary exponent), 'e' (-d.dddde&amp;plusmn;dd, a decimal exponent), 'E' (-d.ddddE&amp;plusmn;dd, a decimal exponent), 'f' (-ddd.dddd, no exponent), 'g' ('e' for large exponents, 'f' otherwise), 'G' ('E' for large exponents, 'f' otherwise), 'x' (-0xd.ddddp&amp;plusmn;ddd, a hexadecimal fraction and binary exponent), or 'X' (-0Xd.ddddP&amp;plusmn;ddd, a hexadecimal fraction and binary exponent).</source>
          <target state="translated">fmt 형식은 'b'(-ddddp &amp;plusmn; ddd, 이진 지수), 'e'(-d.dddde &amp;plusmn; dd, 십진 지수), 'E'(-d.ddddE &amp;plusmn; dd, 십진 지수) 중 하나입니다. ), 'f'(-ddd.dddd, 지수 없음), 'g'(큰 지수의 경우 'e', ​​그렇지 않은 경우 'f'), 'G'(큰 지수의 경우 'E', 그렇지 않은 경우 'f'), ' x '(-0xd.ddddp &amp;plusmn; ddd, 16 진 분수 및 이진 지수) 또는'X '(-0Xd.ddddP &amp;plusmn; ddd, 16 진 분수 및 이진 지수)</target>
        </trans-unit>
        <trans-unit id="f76288ef40c91d2e63963863e41869428543cdec" translate="yes" xml:space="preserve">
          <source>The formats 2, _2, and 02 are unpadded, space-padded, and zero-padded day of month. The formats __2 and 002 are space-padded and zero-padded three-character day of year; there is no unpadded day of year format.</source>
          <target state="translated">형식 2, _2 및 02는 채워지지 않고 공백으로 채워지며 0으로 채워진 요일입니다. __2 및 002 형식은 공백으로 채워지고 0으로 채워진 3 문자 일입니다. 패딩되지 않은 요일 형식은 없습니다.</target>
        </trans-unit>
        <trans-unit id="1f639fab95b9f7e1b599aa2a265c8aee60d79d31" translate="yes" xml:space="preserve">
          <source>The formfeed character acts like a newline but it also terminates all columns in the current line (effectively calling Flush). Tab- terminated cells in the next line start new columns. Unless found inside an HTML tag or inside an escaped text segment, formfeed characters appear as newlines in the output.</source>
          <target state="translated">폼 피드 문자는 줄 바꿈처럼 작동하지만 현재 행의 모든 ​​열을 종료합니다 (효과적으로 Flush 호출). 다음 줄의 탭으로 끝나는 셀은 새 열을 시작합니다. HTML 태그 나 이스케이프 된 텍스트 세그먼트에서 찾을 수없는 경우, 양식 공급 문자는 출력에서 ​​줄 바꿈으로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="6c966e528430f5e8f847d49a893afb0bf98faff4" translate="yes" xml:space="preserve">
          <source>The function is never called with an empty data slice unless atEOF is true. If atEOF is true, however, data may be non-empty and, as always, holds unprocessed text.</source>
          <target state="translated">atEOF가 true가 아니면 함수는 빈 데이터 조각으로 호출되지 않습니다. 그러나 atEOF가 true이면 데이터가 비어 있지 않을 수 있으며 항상 그렇듯이 처리되지 않은 텍스트를 보유합니다.</target>
        </trans-unit>
        <trans-unit id="bb0e0b68d3018d9e09f97b972052414d315bce69" translate="yes" xml:space="preserve">
          <source>The function may return early (before the entire result is written) and return a formatting error, for instance due to an incorrect AST.</source>
          <target state="translated">함수는 예를 들어 (전체 결과가 작성되기 전에) 일찍 반환되고 잘못된 AST로 인해 서식 오류가 반환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f82da77fd5615642bd9b732fd9350b4315a5dea8" translate="yes" xml:space="preserve">
          <source>The function panics if the provided interface is not a slice.</source>
          <target state="translated">제공된 인터페이스가 슬라이스가 아닌 경우 기능 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4a5f1ee976b1b1f94f517d27ee9603ea7e455c85" translate="yes" xml:space="preserve">
          <source>The function panics if z &amp;lt; 0. The value of z is undefined in that case.</source>
          <target state="translated">z &amp;lt;0 인 경우 함수 패닉이 발생합니다.이 경우 z 값이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d83c73a08df2f74bc57a61017e163cb8c0547bd2" translate="yes" xml:space="preserve">
          <source>The functions in this package allow a program to change the way Go programs handle signals.</source>
          <target state="translated">이 패키지의 기능을 통해 프로그램은 Go 프로그램이 신호를 처리하는 방식을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c621ec21270aea7b19125c0f31ddb234d896d492" translate="yes" xml:space="preserve">
          <source>The fundamental interface is called Image. An Image contains colors, which are described in the image/color package.</source>
          <target state="translated">기본 인터페이스를 이미지라고합니다. 이미지는 이미지 / 컬러 패키지에 설명 된 색상을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="3e95d4d070ede79d500e36cf5c238c24c3001c9d" translate="yes" xml:space="preserve">
          <source>The gc runtime imposes a limit of 64 kB on channel element types. If t's size is equal to or exceeds this limit, ChanOf panics.</source>
          <target state="translated">gc 런타임은 채널 요소 유형에 64KB의 제한을 부과합니다. t의 크기가이 한계와 같거나 초과하면 ChanOf 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0b2d97be3dbe373d310641088f98b283534b1dcf" translate="yes" xml:space="preserve">
          <source>The general form represented is:</source>
          <target state="translated">대표되는 일반적인 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e818a1eefc582415dc190e3c644893b44536faa0" translate="yes" xml:space="preserve">
          <source>The gzip file stores a header giving metadata about the compressed file. That header is exposed as the fields of the Writer and Reader structs.</source>
          <target state="translated">gzip 파일은 압축 파일에 대한 메타 데이터를 제공하는 헤더를 저장합니다. 이 헤더는 Writer 및 Reader 구조체의 필드로 노출됩니다.</target>
        </trans-unit>
        <trans-unit id="d55115d1e7ac93246c076c18ab9827900516047e" translate="yes" xml:space="preserve">
          <source>The handler is typically nil, in which case the DefaultServeMux is used.</source>
          <target state="translated">핸들러는 일반적으로 nil이며,이 경우 DefaultServeMux가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="19708f111db26407005495f3eafb1c4b25430791" translate="yes" xml:space="preserve">
          <source>The handling of spaces and newlines differs from that of C's scanf family: in C, newlines are treated as any other space, and it is never an error when a run of spaces in the format string finds no spaces to consume in the input.</source>
          <target state="translated">공백과 개행 처리는 C의 scanf 패밀리와 처리 방식이 다릅니다. C에서 개행은 다른 공백으로 처리되며 형식 문자열에서 공백이 입력에서 소비되는 공백을 찾지 못하면 결코 오류가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="1093dd8291a3801884d5894ab223242420be1682" translate="yes" xml:space="preserve">
          <source>The hash functions are collision-resistant but not cryptographically secure. (See crypto/sha256 and crypto/sha512 for cryptographic use.)</source>
          <target state="translated">해시 함수는 충돌에 강하지 만 암호화로 안전하지는 않습니다. (암호화 용도는 crypto / sha256 및 crypto / sha512를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="9eef6c0a2cccc47289259f60f06bd6983ba13a4d" translate="yes" xml:space="preserve">
          <source>The hash functions are not cryptographically secure. (See crypto/sha256 and crypto/sha512 for cryptographic use.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5be9b697fdd2e64517c87254bb1809a8bac3a286" translate="yes" xml:space="preserve">
          <source>The hash value of a given byte sequence is consistent within a single process, but will be different in different processes.</source>
          <target state="translated">주어진 바이트 시퀀스의 해시 값은 단일 프로세스 내에서 일관되지만 프로세스마다 다릅니다.</target>
        </trans-unit>
        <trans-unit id="e507edab6e88a1637c49a21b0db27e0ccae398e0" translate="yes" xml:space="preserve">
          <source>The heap dump format is defined at &lt;a href=&quot;https://golang.org/s/go15heapdump&quot;&gt;https://golang.org/s/go15heapdump&lt;/a&gt;.</source>
          <target state="translated">힙 덤프 형식은 &lt;a href=&quot;https://golang.org/s/go15heapdump&quot;&gt;https://golang.org/s/go15heapdump에&lt;/a&gt; 정의되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8b009325b4464d415a87b0e6547346de038d0c47" translate="yes" xml:space="preserve">
          <source>The heap profile reports statistics as of the most recently completed garbage collection; it elides more recent allocation to avoid skewing the profile away from live data and toward garbage. If there has been no garbage collection at all, the heap profile reports all known allocations. This exception helps mainly in programs running without garbage collection enabled, usually for debugging purposes.</source>
          <target state="translated">힙 프로파일은 가장 최근에 완료된 가비지 콜렉션으로 통계를보고합니다. 실시간 데이터와 가비지로 프로파일이 기울어지지 않도록 최신 할당을 생략합니다. 가비지 콜렉션이 전혀없는 경우 힙 프로파일은 알려진 모든 할당을보고합니다. 이 예외는 주로 가비지 수집을 사용하지 않고 실행중인 프로그램에서 주로 디버깅 목적으로 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="421272feeab82226233835220df71bd5575dfeaf" translate="yes" xml:space="preserve">
          <source>The heap profile tracks both the allocation sites for all live objects in the application memory and for all objects allocated since the program start. Pprof's -inuse_space, -inuse_objects, -alloc_space, and -alloc_objects flags select which to display, defaulting to -inuse_space (live objects, scaled by size).</source>
          <target state="translated">힙 프로파일은 응용 프로그램 메모리의 모든 활성 오브젝트 및 프로그램 시작 이후 할당 된 모든 오브젝트에 대한 할당 사이트를 모두 추적합니다. Pprof의 -inuse_space, -inuse_objects, -alloc_space 및 -alloc_objects 플래그는 표시 할 항목을 선택하고 기본값은 -inuse_space (실제 오브젝트, 크기별로 조정 됨)입니다.</target>
        </trans-unit>
        <trans-unit id="9054b52054ed118bba62807238e18c27e8900f1e" translate="yes" xml:space="preserve">
          <source>The http package's Transport and Server both automatically enable HTTP/2 support for simple configurations. To enable HTTP/2 for more complex configurations, to use lower-level HTTP/2 features, or to use a newer version of Go's http2 package, import &quot;golang.org/x/net/http2&quot; directly and use its ConfigureTransport and/or ConfigureServer functions. Manually configuring HTTP/2 via the golang.org/x/net/http2 package takes precedence over the net/http package's built-in HTTP/2 support.</source>
          <target state="translated">http 패키지의 전송 및 서버는 간단한 구성을 위해 HTTP / 2 지원을 자동으로 활성화합니다. 보다 복잡한 구성을 위해 HTTP / 2를 사용하도록 설정하거나,보다 낮은 수준의 HTTP / 2 기능을 사용하거나, 최신 버전의 Go http2 패키지를 사용하려면 &quot;golang.org/x/net/http2&quot;를 직접 가져와 ConfigureTransport 및 / 또는 ConfigureServer 기능. golang.org/x/net/http2 패키지를 통한 HTTP / 2 수동 구성은 net / http 패키지의 내장 HTTP / 2 지원보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="7901eb39a7a77a33e17eff2e48d2aac1d7c0d97c" translate="yes" xml:space="preserve">
          <source>The identification of global unicast addresses uses address type identification as defined in RFC 1122, RFC 4632 and RFC 4291 with the exception of IPv4 directed broadcast addresses. It returns true even if ip is in IPv4 private address space or local IPv6 unicast address space.</source>
          <target state="translated">글로벌 유니 캐스트 주소 식별은 IPv4 지정 브로드 캐스트 주소를 제외하고 RFC 1122, RFC 4632 및 RFC 4291에 정의 된 주소 유형 식별을 사용합니다. ip가 IPv4 개인 주소 공간 또는 로컬 IPv6 유니 캐스트 주소 공간에 있더라도 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b257c667cd0c9ffb7ee1c476e193cf63abc04956" translate="yes" xml:space="preserve">
          <source>The imag built-in function returns the imaginary part of the complex number c. The return value will be floating point type corresponding to the type of c.</source>
          <target state="translated">imag 내장 함수는 복소수 c의 허수 부분을 반환합니다. 리턴 값은 c의 유형에 해당하는 부동 소수점 유형입니다.</target>
        </trans-unit>
        <trans-unit id="bba6c5ec151d11520ba69091805c64672051a283" translate="yes" xml:space="preserve">
          <source>The implementation compiles a custom codec for each data type in the stream and is most efficient when a single Encoder is used to transmit a stream of values, amortizing the cost of compilation.</source>
          <target state="translated">이 구현은 스트림의 각 데이터 유형에 대한 사용자 지정 코덱을 컴파일하며 단일 인코더를 사용하여 값 스트림을 전송하여 컴파일 비용을 상쇄 할 때 가장 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="cc59eb7da6cf17b91e5a422524763e1124d23ad5" translate="yes" xml:space="preserve">
          <source>The implementation fn can assume that the argument Value slice has the number and type of arguments given by typ. If typ describes a variadic function, the final Value is itself a slice representing the variadic arguments, as in the body of a variadic function. The result Value slice returned by fn must have the number and type of results given by typ.</source>
          <target state="translated">구현 fn은 인수 Value 슬라이스에 typ에서 제공 한 인수의 수와 유형이 있다고 가정 할 수 있습니다. typ이 variadic 함수를 설명하는 경우 최종 Value 자체는 variadic 함수 본문에서와 같이 variadic 인수를 나타내는 슬라이스입니다. fn에서 반환 된 결과 값 조각에는 typ에서 제공 한 결과의 수와 유형이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="a41481e84f45a7e3719a2630303073b44edd9b5b" translate="yes" xml:space="preserve">
          <source>The implementation is sufficient for HTTP (RFC 2388) and the multipart bodies generated by popular browsers.</source>
          <target state="translated">구현은 HTTP (RFC 2388) 및 널리 사용되는 브라우저에서 생성 된 멀티 파트 바디에 충분합니다.</target>
        </trans-unit>
        <trans-unit id="bd36b82add2ec8e45a6f77ef7cf720308cbe3f24" translate="yes" xml:space="preserve">
          <source>The implementation provides filters that uncompress during reading and compress during writing. For example, to write compressed data to a buffer:</source>
          <target state="translated">이 구현에서는 읽기 중에 압축을 풀고 쓰기 중에 압축하는 필터를 제공합니다. 예를 들어, 압축 된 데이터를 버퍼에 쓰려면 :</target>
        </trans-unit>
        <trans-unit id="624abcf8f99d9c1ecd5f126ae0b1b1d2736d4655" translate="yes" xml:space="preserve">
          <source>The info argument is the fs.FileInfo for the named path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c05b349b9c7f15622f23c1c3f50e289a6f9207b" translate="yes" xml:space="preserve">
          <source>The input stream consists of basic JSON values&amp;mdash;bool, string, number, and null&amp;mdash;along with delimiters [ ] { } of type Delim to mark the start and end of arrays and objects. Commas and colons are elided.</source>
          <target state="translated">입력 스트림은 배열 및 객체의 시작과 끝을 표시하기 위해 Delim 유형의 구분 기호 [] {}와 함께 기본 JSON 값 (bool, string, number 및 null)으로 구성됩니다. 쉼표와 콜론이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="12da2b29ce7b4618ed043885dc9bb14fc4b7647d" translate="yes" xml:space="preserve">
          <source>The input text for a template is UTF-8-encoded text in any format. &quot;Actions&quot;--data evaluations or control structures--are delimited by &quot;{{&quot; and &quot;}}&quot;; all text outside actions is copied to the output unchanged. Except for raw strings, actions may not span newlines, although comments can.</source>
          <target state="translated">템플릿의 입력 텍스트는 모든 형식의 UTF-8 인코딩 텍스트입니다. 데이터 평가 또는 제어 구조 인 &quot;조치&quot;는 &quot;{{&quot;및 &quot;}}&quot;로 구분됩니다. 조치 외부의 모든 텍스트는 변경되지 않은 출력으로 복사됩니다. 원시 문자열을 제외하고 작업은 줄 바꿈에 해당하지 않지만 주석은 가능합니다.</target>
        </trans-unit>
        <trans-unit id="4540c375047525b02ad242a07ddc447e593cb543" translate="yes" xml:space="preserve">
          <source>The issuer distinguished name CRL field and authority key identifier extension are populated using the issuer certificate. issuer must have SubjectKeyId set.</source>
          <target state="translated">발급자 고유 이름 CRL 필드 및 기관 키 식별자 확장은 발급자 인증서를 사용하여 채워집니다. 발급자에는 SubjectKeyId가 설정되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="4ba307a7ab47ab6e6c8f50d8bbcb53f28f406fab" translate="yes" xml:space="preserve">
          <source>The issuer may not be nil, and the crlSign bit must be set in KeyUsage in order to use it as a CRL issuer.</source>
          <target state="translated">발급자는 nil이 아닐 수 있으며 crlSign 비트를 CRL 발급자로 사용하려면 KeyUsage에 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="0fe0f673e6c94e25d76ca7000237cacb398b340e" translate="yes" xml:space="preserve">
          <source>The key name will be used if it's a non-empty string consisting of only Unicode letters, digits, and ASCII punctuation except quotation marks, backslash, and comma.</source>
          <target state="translated">키 이름은 인용 부호, 백 슬래시 및 쉼표를 제외하고 유니 코드 문자, 숫자 및 ASCII 문장 부호로만 구성된 비어 있지 않은 문자열 인 경우에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="56c8d36b799fc9e0b2026b0edca00b49c8b68568" translate="yes" xml:space="preserve">
          <source>The keys should be in canonical form, as returned by CanonicalHeaderKey.</source>
          <target state="translated">CanonicalHeaderKey에 의해 리턴 된 키는 표준 형식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="aafd41e452c62afe966c7e13f3df11b54dbc58d9" translate="yes" xml:space="preserve">
          <source>The label parameter may contain arbitrary data that will not be encrypted, but which gives important context to the message. For example, if a given public key is used to decrypt two types of messages then distinct label values could be used to ensure that a ciphertext for one purpose cannot be used for another by an attacker. If not required it can be empty.</source>
          <target state="translated">label 매개 변수에는 암호화되지 않지만 메시지에 중요한 컨텍스트를 제공하는 임의의 데이터가 포함될 수 있습니다. 예를 들어, 주어진 공개 키가 두 가지 유형의 메시지를 해독하는 데 사용되는 경우 고유 한 레이블 값을 사용하여 한 목적의 암호 텍스트를 공격자가 다른 목적으로 사용할 수 없도록 할 수 있습니다. 필요하지 않은 경우 비어있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cac55c132cd1a101696d231efd1dd2e57c66e06" translate="yes" xml:space="preserve">
          <source>The label parameter must match the value given when encrypting. See EncryptOAEP for details.</source>
          <target state="translated">레이블 매개 변수는 암호화 할 때 제공된 값과 일치해야합니다. 자세한 내용은 EncryptOAEP를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1f23b14d8824650d5d93ee806d28aa66402f402a" translate="yes" xml:space="preserve">
          <source>The last index entry is the field or method index in the (possibly embedded) type where the entry was found, either:</source>
          <target state="translated">마지막 색인 항목은 항목이 발견 된 (포함될 수있는) 유형의 필드 또는 메소드 색인입니다.</target>
        </trans-unit>
        <trans-unit id="4b9b3d3444da612bde04769b5c20561ed18e861d" translate="yes" xml:space="preserve">
          <source>The legacy Common Name field is ignored unless it's a valid hostname, the certificate doesn't have any Subject Alternative Names, and the GODEBUG environment variable is set to &quot;x509ignoreCN=0&quot;. Support for Common Name is deprecated will be entirely removed in the future.</source>
          <target state="translated">레거시 일반 이름 필드는 유효한 호스트 이름이 아니고 인증서에 주체 대체 이름이없고 GODEBUG 환경 변수가 &quot;x509ignoreCN = 0&quot;으로 설정되어 있지 않으면 무시됩니다. Common Name에 대한 지원은 더 이상 사용되지 않으며 향후 완전히 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="feec6e46b5f96d5f768a208b14b5f1c441e6736a" translate="yes" xml:space="preserve">
          <source>The len built-in function returns the length of v, according to its type:</source>
          <target state="translated">len 내장 함수는 유형에 따라 v의 길이를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="37c7e993d252a1780b2d17b25f28b15858ed3005" translate="yes" xml:space="preserve">
          <source>The less function must satisfy the same requirements as the Interface type's Less method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67e3ff53cc19034aa94ce5014984a3863b3ceaa2" translate="yes" xml:space="preserve">
          <source>The limit controls the number of operating system threads, not the number of goroutines. A Go program creates a new thread only when a goroutine is ready to run but all the existing threads are blocked in system calls, cgo calls, or are locked to other goroutines due to use of runtime.LockOSThread.</source>
          <target state="translated">제한은 고 루틴 수가 아닌 운영 체제 스레드 수를 제어합니다. Go 프로그램은 goroutine을 실행할 준비가되었을 때만 새 스레드를 작성하지만 기존의 모든 스레드는 시스템 호출, cgo 호출에서 차단되거나 runtime.LockOSThread로 인해 다른 고 루틴에 잠겨 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7d62826dea7a7db650a9558cf682cb6d6d5b0e1" translate="yes" xml:space="preserve">
          <source>The list is sorted by ID. Note that the default cipher suites selected by this package might depend on logic that can't be captured by a static list.</source>
          <target state="translated">목록은 ID별로 정렬됩니다. 이 패키지에서 선택한 기본 암호 그룹은 정적 목록에서 캡처 할 수없는 논리에 따라 달라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61b31a135931a0a96f45c468dd4c1356b142f056" translate="yes" xml:space="preserve">
          <source>The list of possible Object kinds.</source>
          <target state="translated">가능한 객체 종류의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="f82cdeb26140d2ac8d4f27048ef361e35bc34e51" translate="yes" xml:space="preserve">
          <source>The list of tokens.</source>
          <target state="translated">토큰 목록.</target>
        </trans-unit>
        <trans-unit id="744b107073d50b7c5d979152623baf7c98836ce1" translate="yes" xml:space="preserve">
          <source>The load and store operations, implemented by the LoadT and StoreT functions, are the atomic equivalents of &quot;return *addr&quot; and &quot;*addr = val&quot;.</source>
          <target state="translated">LoadT 및 StoreT 함수로 구현 된로드 및 저장 조작은 &quot;return * addr&quot;및 &quot;* addr = val&quot;과 같은 원자입니다.</target>
        </trans-unit>
        <trans-unit id="d80346c4a6d83f0a2408ae318740b75196640a27" translate="yes" xml:space="preserve">
          <source>The lookup function is called each time the resulting importer needs to resolve an import path. In this mode the importer can only be invoked with canonical import paths (not relative or absolute ones); it is assumed that the translation to canonical import paths is being done by the client of the importer.</source>
          <target state="translated">조회 기능은 결과 임포터가 임포트 경로를 분석해야 할 때마다 호출됩니다. 이 모드에서 임포터는 정식 임포트 경로 (상대 또는 절대 경로는 아님)로만 호출 할 수 있습니다. 표준 임포트 경로로의 변환은 임포터의 클라이언트에 의해 수행되고 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="d42ee39ba69d607990bf6285f526cdb4d05cd8c5" translate="yes" xml:space="preserve">
          <source>The low bit is therefore analogous to a sign bit, but making it the complement bit instead guarantees that the largest negative integer is not a special case. For example, -129=^128=(^256&amp;gt;&amp;gt;1) encodes as (FE 01 01).</source>
          <target state="translated">따라서 낮은 비트는 부호 비트와 유사하지만,이를 보완 비트로 만들면 가장 큰 음의 정수가 특별한 경우가 아닙니다. 예를 들어, -129 = ^ 128 = (^ 256 &amp;gt;&amp;gt; 1)은 (FE 01 01)로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="e23983031d30e849dd601f8a9a147a11b178b7e1" translate="yes" xml:space="preserve">
          <source>The main use case is finding resources located relative to an executable.</source>
          <target state="translated">주요 사용 사례는 실행 파일과 관련된 리소스를 찾는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ae651dd57d8aac89d2244b121832135b42a78e22" translate="yes" xml:space="preserve">
          <source>The make built-in function allocates and initializes an object of type slice, map, or chan (only). Like new, the first argument is a type, not a value. Unlike new, make's return type is the same as the type of its argument, not a pointer to it. The specification of the result depends on the type:</source>
          <target state="translated">내장 함수 작성은 slice, map 또는 chan 유형의 오브젝트를 할당하고 초기화합니다 (전용). new와 마찬가지로 첫 번째 인수는 값이 아닌 유형입니다. new와 달리 make의 반환 유형은 포인터의 형식이 아니라 인수의 유형과 동일합니다. 결과 사양은 다음 유형에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="38a5e445a42e339cecb3a2e57e70485eff805e93" translate="yes" xml:space="preserve">
          <source>The map need not include parent directories for files contained in the map; those will be synthesized if needed. But a directory can still be included by setting the MapFile.Mode's ModeDir bit; this may be necessary for detailed control over the directory's FileInfo or to create an empty directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad15554627caa64494fe09878e570067f5641170" translate="yes" xml:space="preserve">
          <source>The meaning of the parameters fset, pkg, and pos is the same as in CheckExpr. An error is returned if expr cannot be parsed successfully, or the resulting expr AST cannot be type-checked.</source>
          <target state="translated">매개 변수 fset, pkg 및 pos의 의미는 CheckExpr과 동일합니다. expr을 성공적으로 구문 분석 할 수 없거나 결과 expr AST를 유형 검사 할 수없는 경우 오류가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="76f7a0e267f75e03932754601186fb88901bc244" translate="yes" xml:space="preserve">
          <source>The message must be no longer than the length of the public modulus minus twice the hash length, minus a further 2.</source>
          <target state="translated">메시지는 공용 모듈러스 길이에서 해시 길이의 두 배를 뺀 길이보다 길지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="f50438ca0e284cc49442d4b96ed8422098542b37" translate="yes" xml:space="preserve">
          <source>The method for resolving domain names, whether indirectly with functions like Dial or directly with functions like LookupHost and LookupAddr, varies by operating system.</source>
          <target state="translated">Dial과 같은 기능을 사용하거나 LookupHost 및 LookupAddr와 같은 기능을 사용하여 간접적으로 도메인 이름을 확인하는 방법은 운영 체제에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="fd8e3459dc1d93b8b2959d9f7ce9e888fe72a14d" translate="yes" xml:space="preserve">
          <source>The method's first argument represents the arguments provided by the caller; the second argument represents the result parameters to be returned to the caller. The method's return value, if non-nil, is passed back as a string that the client sees as if created by errors.New. If an error is returned, the reply parameter will not be sent back to the client.</source>
          <target state="translated">메소드의 첫 번째 인수는 호출자가 제공 한 인수를 나타냅니다. 두 번째 인수는 호출자에게 리턴 될 결과 매개 변수를 나타냅니다. nil이 아닌 경우, 메소드의 리턴 값은 클라이언트가 오류로 작성된 것처럼 보이는 문자열로 다시 전달됩니다. 오류가 리턴되면 응답 매개 변수가 클라이언트로 다시 전송되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eebd4cc8d1b396bccc721d19c4bd56800d60e192" translate="yes" xml:space="preserve">
          <source>The methods should behave the same as those on an *os.File.</source>
          <target state="translated">메소드는 * os.File의 메소드와 동일하게 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="3351c33da5b9bc73dd81d983421271485dd91e09" translate="yes" xml:space="preserve">
          <source>The minimal source code for a binary-only package was therefore:</source>
          <target state="translated">따라서 바이너리 전용 패키지의 최소 소스 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ba0d7c85cb07c29f22bceee0e488a79cf0a2c300" translate="yes" xml:space="preserve">
          <source>The minimum element in the tree is the root, at index 0.</source>
          <target state="translated">트리의 최소 요소는 인덱스 0의 루트입니다.</target>
        </trans-unit>
        <trans-unit id="6cf2c8c68bd743b1d5a4e29ae7301dad5d49bcb2" translate="yes" xml:space="preserve">
          <source>The mode parameter controls the amount of source text parsed and other optional parser functionality. Position information is recorded in the file set fset, which must not be nil.</source>
          <target state="translated">mode 매개 변수는 구문 분석 된 소스 텍스트의 양 및 기타 선택적 구문 분석기 기능을 제어합니다. 위치 정보는 파일 세트 fset에 기록되며 이는 0이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="7d1773f39818c5825c59e48b1236b92119b0b32e" translate="yes" xml:space="preserve">
          <source>The month, day, hour, min, sec, and nsec values may be outside their usual ranges and will be normalized during the conversion. For example, October 32 converts to November 1.</source>
          <target state="translated">월, 일,시, 최소, 초 및 nsec 값은 일반적인 범위를 벗어날 수 있으며 변환 중에 정규화됩니다. 예를 들어 10 월 32 일은 11 월 1 일로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="a5541e290e27715c3d35b2115cad871f3ab99ccb" translate="yes" xml:space="preserve">
          <source>The most common numeric conversions are Atoi (string to int) and Itoa (int to string).</source>
          <target state="translated">가장 일반적인 숫자 변환은 Atoi (string to int) 및 Itoa (int to string)입니다.</target>
        </trans-unit>
        <trans-unit id="4bbbacdbad6d2c99ac68260aad07ecb869838903" translate="yes" xml:space="preserve">
          <source>The most common use of this pattern is to access fields in a struct or elements of an array:</source>
          <target state="translated">이 패턴의 가장 일반적인 용도는 구조체의 구조체 나 배열의 요소에 액세스하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ac8cc81db3fc49af2479176c9231b929d55cdbd8" translate="yes" xml:space="preserve">
          <source>The msg parameter should be an RFC 822-style email with headers first, a blank line, and then the message body. The lines of msg should be CRLF terminated. The msg headers should usually include fields such as &quot;From&quot;, &quot;To&quot;, &quot;Subject&quot;, and &quot;Cc&quot;. Sending &quot;Bcc&quot; messages is accomplished by including an email address in the to parameter but not including it in the msg headers.</source>
          <target state="translated">msg 매개 변수는 먼저 헤더가있는 RFC 822 스타일 이메일이어야하며, 빈 줄과 메시지 본문이 있어야합니다. msg 줄은 CRLF로 종료되어야합니다. msg 헤더는 일반적으로 &quot;보낸 사람&quot;, &quot;받는 사람&quot;, &quot;제목&quot;및 &quot;Cc&quot;와 같은 필드를 포함해야합니다. &quot;숨은 참조&quot;메시지는 to 매개 변수에 전자 메일 주소를 포함하지만 msg 헤더에는 포함하지 않으면됩니다.</target>
        </trans-unit>
        <trans-unit id="410aa7b0a0304575a8915750342dc577b832f74c" translate="yes" xml:space="preserve">
          <source>The name for the XML elements is taken from, in order of preference:</source>
          <target state="translated">XML 요소의 이름은 기본 설정 순서대로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="57b088fc8d39478c2345773281e5eb271805f7ea" translate="yes" xml:space="preserve">
          <source>The naming convention to declare examples for the package, a function F, a type T and method M on type T are:</source>
          <target state="translated">패키지에 대한 예제, 함수 F, 유형 T 및 유형 T의 메소드 M을 선언하는 이름 지정 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7b9b492a2e0fbf406f8b8d17e034f78a30b6eb8c" translate="yes" xml:space="preserve">
          <source>The net, net/http, and crypto/tls packages also refer to debugging variables in GODEBUG. See the documentation for those packages for details.</source>
          <target state="translated">net, net / http 및 crypto / tls 패키지는 GODEBUG의 변수 디버깅을 참조합니다. 자세한 내용은 해당 패키지의 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="69954652d3ee14598bd31e60017ff5be6ec75582" translate="yes" xml:space="preserve">
          <source>The net/http/cookiejar package provides a CookieJar implementation.</source>
          <target state="translated">net / http / cookiejar 패키지는 CookieJar 구현을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7815d9693c2e8fba3de7740f99dda917ebde80d7" translate="yes" xml:space="preserve">
          <source>The net/rpc package is frozen and is not accepting new features.</source>
          <target state="translated">net / rpc 패키지가 정지되어 새로운 기능을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b67ec9dd23234843cefc446704be9276e0333344" translate="yes" xml:space="preserve">
          <source>The network must be &quot;tcp&quot;, &quot;tcp4&quot;, &quot;tcp6&quot;, &quot;unix&quot; or &quot;unixpacket&quot;.</source>
          <target state="translated">네트워크는 &quot;tcp&quot;, &quot;tcp4&quot;, &quot;tcp6&quot;, &quot;unix&quot;또는 &quot;unixpacket&quot;이어야합니다.</target>
        </trans-unit>
        <trans-unit id="f78c2675c0a1b78facf549c913ce29c8786aed4f" translate="yes" xml:space="preserve">
          <source>The network must be &quot;udp&quot;, &quot;udp4&quot;, &quot;udp6&quot;, &quot;unixgram&quot;, or an IP transport. The IP transports are &quot;ip&quot;, &quot;ip4&quot;, or &quot;ip6&quot; followed by a colon and a literal protocol number or a protocol name, as in &quot;ip:1&quot; or &quot;ip:icmp&quot;.</source>
          <target state="translated">네트워크는 &quot;udp&quot;, &quot;udp4&quot;, &quot;udp6&quot;, &quot;unixgram&quot;또는 IP 전송이어야합니다. IP 전송은 &quot;ip : 1&quot;또는 &quot;ip : icmp&quot;와 같이 &quot;ip&quot;, &quot;ip4&quot;또는 &quot;ip6&quot;다음에 콜론과 리터럴 프로토콜 번호 또는 프로토콜 이름이옵니다.</target>
        </trans-unit>
        <trans-unit id="f62f0c6bf3637b6bd91fbed73590e0c5ec059d67" translate="yes" xml:space="preserve">
          <source>The network must be &quot;unix&quot; or &quot;unixpacket&quot;.</source>
          <target state="translated">네트워크는 &quot;unix&quot;또는 &quot;unixpacket&quot;이어야합니다.</target>
        </trans-unit>
        <trans-unit id="961ea2a9664370be05fda243ace29bf62f0b8b14" translate="yes" xml:space="preserve">
          <source>The network must be &quot;unixgram&quot;.</source>
          <target state="translated">네트워크는 &quot;unixgram&quot;이어야합니다.</target>
        </trans-unit>
        <trans-unit id="143c1ec61594ea23a84fdfc668726a693ff1d059" translate="yes" xml:space="preserve">
          <source>The network must be a TCP network name.</source>
          <target state="translated">네트워크는 TCP 네트워크 이름이어야합니다.</target>
        </trans-unit>
        <trans-unit id="54bb9136f9b37f7468411dbae5b647c63059a3a1" translate="yes" xml:space="preserve">
          <source>The network must be a TCP network name; see func Dial for details.</source>
          <target state="translated">네트워크는 TCP 네트워크 이름이어야합니다. 자세한 내용은 func 다이얼을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a35132d711d8945bdb8b272ee67848e4c94a5a16" translate="yes" xml:space="preserve">
          <source>The network must be a UDP network name.</source>
          <target state="translated">네트워크는 UDP 네트워크 이름이어야합니다.</target>
        </trans-unit>
        <trans-unit id="89ed96066a0fbc9b6b82696daa8ba7effb94e0a8" translate="yes" xml:space="preserve">
          <source>The network must be a UDP network name; see func Dial for details.</source>
          <target state="translated">네트워크는 UDP 네트워크 이름이어야합니다. 자세한 내용은 func 다이얼을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="199d17e2fe63f354db9a6b916c396629d6b88dda" translate="yes" xml:space="preserve">
          <source>The network must be a Unix network name.</source>
          <target state="translated">네트워크는 Unix 네트워크 이름이어야합니다.</target>
        </trans-unit>
        <trans-unit id="b6cf9d29e750ed948316e5ba40edb44e452845b1" translate="yes" xml:space="preserve">
          <source>The network must be a Unix network name; see func Dial for details.</source>
          <target state="translated">네트워크는 Unix 네트워크 이름이어야합니다. 자세한 내용은 func 다이얼을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="61f5a2270318ecc8414142178aaa1a53165f97e7" translate="yes" xml:space="preserve">
          <source>The network must be an IP network name.</source>
          <target state="translated">네트워크는 IP 네트워크 이름이어야합니다.</target>
        </trans-unit>
        <trans-unit id="b881d6aafa14d5f635aad510160f9473031ecf6f" translate="yes" xml:space="preserve">
          <source>The network must be an IP network name; see func Dial for details.</source>
          <target state="translated">네트워크는 IP 네트워크 이름이어야합니다. 자세한 내용은 func 다이얼을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="882441c96cbf8f9716ac8a79d3a5eb4e3af0bcfd" translate="yes" xml:space="preserve">
          <source>The new Handler calls h.ServeHTTP to handle each request, but if a call runs for longer than its time limit, the handler responds with a 503 Service Unavailable error and the given message in its body. (If msg is empty, a suitable default message will be sent.) After such a timeout, writes by h to its ResponseWriter will return ErrHandlerTimeout.</source>
          <target state="translated">새 처리기는 h.ServeHTTP를 호출하여 각 요청을 처리하지만 호출이 시간 제한보다 오래 실행되면 처리기는 503 서비스 사용 불가능 오류와 본문에 제공된 메시지로 응답합니다. (msg가 비어 있으면 적절한 기본 메시지가 전송됩니다.) 이러한 시간 초과 후 h가 ResponseWriter에 기록하면 ErrHandlerTimeout이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3cf0c81686ac1acb508bf9e67780a55cee7159d9" translate="yes" xml:space="preserve">
          <source>The new built-in function allocates memory. The first argument is a type, not a value, and the value returned is a pointer to a newly allocated zero value of that type.</source>
          <target state="translated">새로운 내장 함수는 메모리를 할당합니다. 첫 번째 인수는 값이 아닌 유형이며 반환 된 값은 해당 유형의 새로 할당 된 0 값에 대한 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="902360dabebdea5b3a521c7b72fed85e30d4437d" translate="yes" xml:space="preserve">
          <source>The node type must be *ast.File, *printer.CommentedNode, []ast.Decl, []ast.Stmt, or assignment-compatible to ast.Expr, ast.Decl, ast.Spec, or ast.Stmt. Node does not modify node. Imports are not sorted for nodes representing partial source files (for instance, if the node is not an *ast.File or a *printer.CommentedNode not wrapping an *ast.File).</source>
          <target state="translated">노드 유형은 * ast.File, * printer.CommentedNode, [] ast.Decl, [] ast.Stmt 또는 ast.Expr, ast.Decl, ast.Spec 또는 ast.Stmt에 지정 호환 가능해야합니다. 노드는 노드를 수정하지 않습니다. 부분 소스 파일을 나타내는 노드 (예 : 노드가 * ast.File 또는 * ast.File을 랩핑하지 않은 * printer.CommentedNode가 아닌 경우)에 대해서는 가져 오기가 정렬되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="56cff2c7a026fcff6621abd1c298d8e39f80b3ef" translate="yes" xml:space="preserve">
          <source>The non-Go code should not change the signal mask on any threads created by the Go runtime. If the non-Go code starts new threads of its own, it may set the signal mask as it pleases.</source>
          <target state="translated">비 Go 코드는 Go 런타임에 의해 생성 된 스레드에서 신호 마스크를 변경해서는 안됩니다. 비 Go 코드가 자체 스레드를 새로 시작하면 원하는대로 신호 마스크를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67289d2a1e8eb416b3a82eb9f3e75a285c0158f6" translate="yes" xml:space="preserve">
          <source>The number represented by s must be of the form N, Ni, or N&amp;plusmn;Ni, where N stands for a floating-point number as recognized by ParseFloat, and i is the imaginary component. If the second N is unsigned, a + sign is required between the two components as indicated by the &amp;plusmn;. If the second N is NaN, only a + sign is accepted. The form may be parenthesized and cannot contain any spaces. The resulting complex number consists of the two components converted by ParseFloat.</source>
          <target state="translated">s로 표시되는 숫자는 N, Ni 또는 N &amp;plusmn; Ni 형식이어야합니다. 여기서 N은 ParseFloat에서 인식하는 부동 소수점 숫자를 나타내고 i는 허수 구성 요소입니다. 두 번째 N이 부호가없는 경우 &amp;plusmn;로 표시된 두 구성 요소 사이에 + 기호가 필요합니다. 두 번째 N이 NaN이면 + 기호 만 허용됩니다. 양식은 괄호로 묶을 수 있으며 공백을 포함 할 수 없습니다. 결과 복소수는 ParseFloat에 의해 변환 된 두 구성 요소로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="8ca31cdbe931eb86d33c507cac75f440d062f995" translate="yes" xml:space="preserve">
          <source>The ok result is false if the -timeout flag indicates &amp;ldquo;no timeout&amp;rdquo; (0).</source>
          <target state="translated">-timeout 플래그가 &quot;시간 종료 없음&quot;(0)을 표시하면 ok 결과는 거짓입니다.</target>
        </trans-unit>
        <trans-unit id="b32a27700c08984e10653750973205a0166116d3" translate="yes" xml:space="preserve">
          <source>The only signal values guaranteed to be present in the os package on all systems are os.Interrupt (send the process an interrupt) and os.Kill (force the process to exit). On Windows, sending os.Interrupt to a process with os.Process.Signal is not implemented; it will return an error instead of sending a signal.</source>
          <target state="translated">모든 시스템에서 os 패키지에 존재하는 것으로 보장되는 유일한 신호 값은 os.Interrupt (프로세스 중단 보내기) 및 os.Kill (프로세스 강제 종료)입니다. Windows에서는 os.Process.Signal을 사용하여 프로세스에 os.Interrupt를 보내는 것이 구현되지 않습니다. 신호를 보내는 대신 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ff422009eedfd53fa7602cbdd94de8292f5f25ce" translate="yes" xml:space="preserve">
          <source>The original specification for encryption and signatures with RSA is PKCS #1 and the terms &quot;RSA encryption&quot; and &quot;RSA signatures&quot; by default refer to PKCS #1 version 1.5. However, that specification has flaws and new designs should use version 2, usually called by just OAEP and PSS, where possible.</source>
          <target state="translated">RSA를 사용한 암호화 및 서명에 대한 원래 사양은 PKCS # 1이며 기본적으로 &quot;RSA 암호화&quot;및 &quot;RSA 서명&quot;이라는 용어는 PKCS # 1 버전 1.5를 참조합니다. 그러나 해당 사양에는 결함이 있으며 새로운 설계는 가능한 경우 일반적으로 OAEP 및 PSS에서 호출하는 버전 2를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="8c37b0a4e6fab650a215cbd5edb17eee82ff53db" translate="yes" xml:space="preserve">
          <source>The original specification for encryption and signatures with RSA is PKCS#1 and the terms &quot;RSA encryption&quot; and &quot;RSA signatures&quot; by default refer to PKCS#1 version 1.5. However, that specification has flaws and new designs should use version two, usually called by just OAEP and PSS, where possible.</source>
          <target state="translated">RSA를 사용한 암호화 및 서명의 원래 사양은 PKCS # 1이며 기본적으로 &quot;RSA 암호화&quot;및 &quot;RSA 서명&quot;이라는 용어는 PKCS # 1 버전 1.5를 나타냅니다. 그러나이 사양에는 결함이 있으며 새로운 디자인은 가능한 경우 일반적으로 OAEP 및 PSS에서 호출하는 버전 2를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="540d9d25cf4179e22c8285de7096ab16e1c12b86" translate="yes" xml:space="preserve">
          <source>The original tar format was introduced in Unix V7. Since then, there have been multiple competing formats attempting to standardize or extend the V7 format to overcome its limitations. The most common formats are the USTAR, PAX, and GNU formats, each with their own advantages and limitations.</source>
          <target state="translated">원래 tar 형식은 Unix V7에서 도입되었습니다. 그 이후로 V7 형식을 표준화하거나 확장하여 한계를 극복하려는 여러 경쟁 형식이있었습니다. 가장 일반적인 형식은 USTAR, PAX 및 GNU 형식이며 각각 고유 한 장점과 제한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="447ae61382377495d9bb3dcbc7167cc095d3d833" translate="yes" xml:space="preserve">
          <source>The os interface is intended to be uniform across all operating systems. Features not generally available appear in the system-specific package syscall.</source>
          <target state="translated">os 인터페이스는 모든 운영 체제에서 균일하도록 설계되었습니다. 일반적으로 사용할 수없는 기능은 시스템 별 패키지 syscall에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="826c8f633f039e53ad0aac6dce5e00961c47baef" translate="yes" xml:space="preserve">
          <source>The other reporting methods, such as the variations of Log and Error, may be called simultaneously from multiple goroutines.</source>
          <target state="translated">Log 및 Error의 변형과 같은 다른보고 방법은 여러 고 루틴에서 동시에 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="314818cec484a0a4f79c6a3bd12ea1e65d6a5497" translate="yes" xml:space="preserve">
          <source>The output of a command will be either one value or two values, the second of which has type error. If that second value is present and evaluates to non-nil, execution terminates and the error is returned to the caller of Execute.</source>
          <target state="translated">명령의 출력은 하나의 값 또는 두 개의 값이며, 두 번째 값에는 유형 오류가 있습니다. 해당 두 번째 값이 존재하고 nil이 아닌 것으로 평가되면 실행이 종료되고 Execute 호출자에게 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="8552b51b4b43726af9d21d2953952aab9f9eccb4" translate="yes" xml:space="preserve">
          <source>The package also exports a handler that serves execution trace data for the &quot;go tool trace&quot; command. To collect a 5-second execution trace:</source>
          <target state="translated">또한 패키지는 &quot;go tool trace&quot;명령에 대한 실행 추적 데이터를 제공하는 처리기를 내 보냅니다. 5 초 실행 추적을 수집하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="01b79b49ed9f5aef9d64418cf5de61a045616033" translate="yes" xml:space="preserve">
          <source>The package also runs and verifies example code. Example functions may include a concluding line comment that begins with &quot;Output:&quot; and is compared with the standard output of the function when the tests are run. (The comparison ignores leading and trailing space.) These are examples of an example:</source>
          <target state="translated">패키지는 또한 예제 코드를 실행하고 확인합니다. 예제 함수에는 &quot;출력 :&quot;으로 시작하고 테스트가 실행될 때 함수의 표준 출력과 비교되는 최종 행 주석이 포함될 수 있습니다. (비교는 앞뒤 공백을 무시합니다.) 다음은 예입니다.</target>
        </trans-unit>
        <trans-unit id="a842fba56dd27e8e683543ed1da0bb8ec8237f57" translate="yes" xml:space="preserve">
          <source>The package is marked as complete if no errors occurred, otherwise it is incomplete. See Config.Error for controlling behavior in the presence of errors.</source>
          <target state="translated">오류가 발생하지 않으면 패키지가 완료된 것으로 표시되고, 그렇지 않으면 완료되지 않은 패키지입니다. 오류가있을 때 동작을 제어하려면 구성 오류를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="084533be70387d373858b81e63ee3fdbb938556c" translate="yes" xml:space="preserve">
          <source>The package is sometimes only imported for the side effect of registering its HTTP handler and the above variables. To use it this way, link this package into your program:</source>
          <target state="translated">패키지는 때로는 HTTP 처리기와 위 변수를 등록 할 때의 부작용으로 만 가져옵니다. 이 방법으로 사용하려면이 패키지를 프로그램에 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="a76fef8dda549c1a3db0f0948e9255bd119d522e" translate="yes" xml:space="preserve">
          <source>The package is specified by a list of *ast.Files and corresponding file set, and the package path the package is identified with. The clean path must not be empty or dot (&quot;.&quot;).</source>
          <target state="translated">패키지는 * ast.Files 및 해당 파일 세트의 목록과 패키지가 식별 된 패키지 경로로 지정됩니다. 정리 경로는 비어 있거나 점 ( &quot;.&quot;)이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="385716c34a6382063c2f2e6bebfaff89eee0a50e" translate="yes" xml:space="preserve">
          <source>The package is specified by a list of *ast.Files and corresponding file set, which must not be nil. NewFromFiles uses all provided files when computing documentation, so it is the caller's responsibility to provide only the files that match the desired build context. &quot;go/build&quot;.Context.MatchFile can be used for determining whether a file matches a build context with the desired GOOS and GOARCH values, and other build constraints. The import path of the package is specified by importPath.</source>
          <target state="translated">패키지는 * ast.Files 및 해당 파일 세트 목록으로 지정되며 nil이 아니어야합니다. NewFromFiles는 문서를 계산할 때 제공된 모든 파일을 사용하므로 원하는 빌드 컨텍스트와 일치하는 파일 만 제공하는 것은 호출자의 책임입니다. &quot;go / build&quot;.Context.MatchFile은 파일이 원하는 GOOS 및 GOARCH 값과 기타 빌드 제약 조건이있는 빌드 컨텍스트와 일치하는지 여부를 판별하는 데 사용할 수 있습니다. 패키지의 가져 오기 경로는 importPath로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="399fd3ad30378409e2dc4bdf013d129681dab5d4" translate="yes" xml:space="preserve">
          <source>The package is typically only imported for the side effect of registering its HTTP handlers. The handled paths all begin with /debug/pprof/.</source>
          <target state="translated">패키지는 일반적으로 HTTP 핸들러 등록의 부작용으로 만 가져옵니다. 처리 된 경로는 모두 / debug / pprof /로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="1435a203fd8b96db3ad7b17b180e6f206d92f47b" translate="yes" xml:space="preserve">
          <source>The package is using the Elastic Tabstops algorithm described at &lt;a href=&quot;http://nickgravgaard.com/elastictabstops/index.html&quot;&gt;http://nickgravgaard.com/elastictabstops/index.html&lt;/a&gt;.</source>
          <target state="translated">이 패키지는 &lt;a href=&quot;http://nickgravgaard.com/elastictabstops/index.html&quot;&gt;http://nickgravgaard.com/elastictabstops/index.html에&lt;/a&gt; 설명 된 Elastic Tabstops 알고리즘을 사용하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d8c628767f33f2351dada491bfefd34f51b3140" translate="yes" xml:space="preserve">
          <source>The package provides:</source>
          <target state="translated">패키지는 다음을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fdd304cc0ffa560e98ef7d6ccf98bb51070237a4" translate="yes" xml:space="preserve">
          <source>The packages golang.org/x/net/ipv4 and golang.org/x/net/ipv6 can be used to manipulate IP-level socket options in oob.</source>
          <target state="translated">패키지 golang.org/x/net/ipv4 및 golang.org/x/net/ipv6을 사용하여 oob의 IP 레벨 소켓 옵션을 조작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e31e979e3edc39254b9a5c52d82e5a30deadc675" translate="yes" xml:space="preserve">
          <source>The panic built-in function stops normal execution of the current goroutine. When a function F calls panic, normal execution of F stops immediately. Any functions whose execution was deferred by F are run in the usual way, and then F returns to its caller. To the caller G, the invocation of F then behaves like a call to panic, terminating G's execution and running any deferred functions. This continues until all functions in the executing goroutine have stopped, in reverse order. At that point, the program is terminated with a non-zero exit code. This termination sequence is called panicking and can be controlled by the built-in function recover.</source>
          <target state="translated">패닉 내장 기능은 현재 고 루틴의 정상적인 실행을 중지합니다. 함수 F가 패닉을 호출하면 F의 정상적인 실행이 즉시 중지됩니다. F에 의해 실행이 지연된 모든 함수는 일반적인 방식으로 실행 된 다음 F가 호출자로 돌아갑니다. 호출자 G에게 F의 호출은 공황에 대한 호출처럼 행동하여 G의 실행을 종료하고 지연된 함수를 실행합니다. 실행중인 고 루틴의 모든 기능이 역순으로 중지 될 때까지 계속됩니다. 이 시점에서 프로그램은 0이 아닌 종료 코드로 종료됩니다. 이 종료 시퀀스를 패닉이라고하며 내장 함수 복구로 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af4f035528815b22e373ca233969d1eeb80da9ab" translate="yes" xml:space="preserve">
          <source>The parse functions return the widest type (float64, int64, and uint64), but if the size argument specifies a narrower width the result can be converted to that narrower type without data loss:</source>
          <target state="translated">구문 분석 함수는 가장 넓은 유형 (float64, int64 및 uint64)을 반환하지만 size 인수가 더 좁은 폭을 지정하면 결과는 데이터 손실없이 더 좁은 유형으로 변환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a18efb4bf749b7c5acc3a4bfaddc4a2e6898762f" translate="yes" xml:space="preserve">
          <source>The parser accepts a larger language than is syntactically permitted by the Go spec, for simplicity, and for improved robustness in the presence of syntax errors. For instance, in method declarations, the receiver is treated like an ordinary parameter list and thus may contain multiple entries where the spec permits exactly one. Consequently, the corresponding field in the AST (ast.FuncDecl.Recv) field is not restricted to one entry.</source>
          <target state="translated">파서는 Go 사양에 의해 구문 상 허용되는 것보다 더 큰 언어를 받아들이고, 간결하고 구문 오류가있을 때의 견고성을 향상시킵니다. 예를 들어, 메소드 선언에서 수신자는 일반 매개 변수 목록처럼 취급되므로 스펙이 정확히 하나를 허용하는 여러 항목을 포함 할 수 있습니다. 결과적으로 AST (ast.FuncDecl.Recv) 필드의 해당 필드는 하나의 항목으로 제한되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f1b15ae7c535ec21c3b3214f780b2381f7617014" translate="yes" xml:space="preserve">
          <source>The path and host are used unchanged for CONNECT requests.</source>
          <target state="translated">경로 및 호스트는 CONNECT 요청에 변경되지 않은 상태로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="623d365b943b6e8d95767b246041604e7f8848f2" translate="yes" xml:space="preserve">
          <source>The path argument contains the argument to Walk as a prefix. That is, if Walk is called with root argument &quot;dir&quot; and finds a file named &quot;a&quot; in that directory, the walk function will be called with argument &quot;dir/a&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="147552bd39d536fc2b6830c38de35cab2fd698e6" translate="yes" xml:space="preserve">
          <source>The path argument contains the argument to WalkDir as a prefix. That is, if WalkDir is called with root argument &quot;dir&quot; and finds a file named &quot;a&quot; in that directory, the walk function will be called with argument &quot;dir/a&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="185477acd3fd456d75fb7c4fc53e2fc58b8c4aaf" translate="yes" xml:space="preserve">
          <source>The path package should only be used for paths separated by forward slashes, such as the paths in URLs. This package does not deal with Windows paths with drive letters or backslashes; to manipulate operating system paths, use the path/filepath package.</source>
          <target state="translated">경로 패키지는 URL의 경로와 같이 슬래시로 구분 된 경로에만 사용해야합니다. 이 패키지는 드라이브 문자 나 백 슬래시가있는 Windows 경로를 처리하지 않습니다. 운영 체제 경로를 조작하려면 경로 / 파일 경로 패키지를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="26954c9ca56cc48a56a0453ce2488e2f260ed60b" translate="yes" xml:space="preserve">
          <source>The pkg/ directory holds installed package objects. As in the Go tree, each target operating system and architecture pair has its own subdirectory of pkg (pkg/GOOS_GOARCH).</source>
          <target state="translated">pkg / 디렉토리에는 설치된 패키지 객체가 있습니다. 이동 트리에서와 같이 각 대상 운영 체제 및 아키텍처 쌍에는 고유 한 pkg (pkg / GOOS_GOARCH) 하위 디렉토리가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a87eb4ca6fbc546df6339993053151079409112" translate="yes" xml:space="preserve">
          <source>The precision prec controls the number of digits (excluding the exponent) printed by the 'e', 'E', 'f', 'g', 'G', 'x', and 'X' formats. For 'e', 'E', 'f', 'x', and 'X', it is the number of digits after the decimal point. For 'g' and 'G' it is the maximum number of significant digits (trailing zeros are removed). The special precision -1 uses the smallest number of digits necessary such that ParseFloat will return f exactly.</source>
          <target state="translated">정밀 정밀도는 'e', ​​'E', 'f', 'g', 'G', 'x'및 'X'형식으로 인쇄 된 자릿수 (지수 제외)를 제어합니다. 'e', 'E', 'f', 'x'및 'X'의 경우 소수점 뒤의 자릿수입니다. 'g'및 'G'의 경우 최대 유효 자릿수입니다 (후행 0은 제거됨). 특수 정밀도 -1은 ParseFloat가 f를 정확하게 반환하는 데 필요한 최소 자릿수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="69078c80b7be9ecb1f89b1ab519c7b7264b1d687" translate="yes" xml:space="preserve">
          <source>The precision prec controls the number of digits (excluding the exponent) printed by the 'e', 'E', 'f', 'g', 'G', and 'x' formats. For 'e', 'E', 'f', and 'x', it is the number of digits after the decimal point. For 'g' and 'G' it is the total number of digits. A negative precision selects the smallest number of decimal digits necessary to identify the value x uniquely using x.Prec() mantissa bits. The prec value is ignored for the 'b' and 'p' formats.</source>
          <target state="translated">정밀 정밀도는 'e', ​​'E', 'f', 'g', 'G'및 'x'형식으로 인쇄 된 자릿수 (지수 제외)를 제어합니다. 'e', 'E', 'f'및 'x'의 경우 소수점 뒤의 자릿수입니다. 'g'및 'G'의 경우 총 자릿수입니다. 음의 정밀도는 x.Prec () 가수 비트를 사용하여 값 x를 고유하게 식별하는 데 필요한 최소 소수 자릿수를 선택합니다. 'b'및 'p'형식의 경우 prec 값이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="456c4a02a800a4453e3d726e233dc51ff74f0fc9" translate="yes" xml:space="preserve">
          <source>The predefined profiles may assign meaning to other debug values; for example, when printing the &quot;goroutine&quot; profile, debug=2 means to print the goroutine stacks in the same form that a Go program uses when dying due to an unrecovered panic.</source>
          <target state="translated">미리 정의 된 프로파일은 다른 디버그 값에 의미를 할당 할 수 있습니다. 예를 들어, &quot;goroutine&quot;프로파일을 인쇄 할 때 debug = 2는 복구되지 않은 패닉으로 인해 Go 프로그램이 죽을 때 사용하는 것과 같은 형식으로 고 루틴 스택을 인쇄하는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="58481973143a6de618e8538c648e764b31b42f2b" translate="yes" xml:space="preserve">
          <source>The print built-in function formats its arguments in an implementation-specific way and writes the result to standard error. Print is useful for bootstrapping and debugging; it is not guaranteed to stay in the language.</source>
          <target state="translated">인쇄 내장 함수는 인수를 구현 별 방식으로 형식화하고 결과를 표준 오류에 기록합니다. 인쇄는 부트 스트랩 및 디버깅에 유용합니다. 언어를 유지한다고 보장되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="91f04de49b9af203098665c6f8b752b5392b78a0" translate="yes" xml:space="preserve">
          <source>The println built-in function formats its arguments in an implementation-specific way and writes the result to standard error. Spaces are always added between arguments and a newline is appended. Println is useful for bootstrapping and debugging; it is not guaranteed to stay in the language.</source>
          <target state="translated">println 내장 함수는 인수를 구현 별 방식으로 형식화하고 결과를 표준 오류에 씁니다. 인수 사이에 공백이 항상 추가되고 개행이 추가됩니다. Println은 부트 스트랩 및 디버깅에 유용합니다. 언어를 유지한다고 보장되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="151eef92ef01a650c4a9036a013718d694ffc693" translate="yes" xml:space="preserve">
          <source>The provided Context must be non-nil. If the context expires before the connection is complete, an error is returned. Once successfully connected, any expiration of the context will not affect the connection.</source>
          <target state="translated">제공된 컨텍스트는 0이 아니어야합니다. 연결이 완료되기 전에 컨텍스트가 만료되면 오류가 반환됩니다. 성공적으로 연결되면 컨텍스트 만료는 연결에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0e411a42789a39be423654b810b14a1d819d3f7a" translate="yes" xml:space="preserve">
          <source>The provided TxOptions is optional and may be nil if defaults should be used. If a non-default isolation level is used that the driver doesn't support, an error will be returned.</source>
          <target state="translated">제공된 TxOptions는 선택 사항이며 기본값을 사용해야하는 경우에는 nil 일 수 있습니다. 드라이버가 지원하지 않는 기본 격리 수준이 아닌 경우 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="decd2b405e8241c6f8e12f33bd5a3bb2cc5dc04e" translate="yes" xml:space="preserve">
          <source>The provided body may be nil. If the body is of type *bytes.Reader, *strings.Reader, or *bytes.Buffer, the Request.ContentLength is set.</source>
          <target state="translated">제공된 본체가 없을 수 있습니다. 본문이 * bytes.Reader, * strings.Reader 또는 * bytes.Buffer 유형 인 경우 Request.ContentLength가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="58ddb87ccdb3a3bbf17dded9af2e6f690f9fa593" translate="yes" xml:space="preserve">
          <source>The provided code should be in the 3xx range and is usually StatusMovedPermanently, StatusFound or StatusSeeOther.</source>
          <target state="translated">제공된 코드는 3xx 범위에 있어야하며 일반적으로 StatusMovedPermanently, StatusFound 또는 StatusSeeOther입니다.</target>
        </trans-unit>
        <trans-unit id="86be20106cb95d195cb582ade394435819f24514" translate="yes" xml:space="preserve">
          <source>The provided context is used for the preparation of the statement, not for the execution of the statement.</source>
          <target state="translated">제공된 컨텍스트는 명령문 실행이 아닌 명령문 준비에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="dd14eed153c5e1b07e7490871396f032fee4f925" translate="yes" xml:space="preserve">
          <source>The provided context is used to kill the process (by calling os.Process.Kill) if the context becomes done before the command completes on its own.</source>
          <target state="translated">제공된 컨텍스트는 명령이 자체적으로 완료되기 전에 컨텍스트가 완료되면 os.Process.Kill을 호출하여 프로세스를 종료하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a4964ee167f777b88ff9017caa2a6e7f575494e2" translate="yes" xml:space="preserve">
          <source>The provided context is used until the transaction is committed or rolled back. If the context is canceled, the sql package will roll back the transaction. Tx.Commit will return an error if the context provided to BeginTx is canceled.</source>
          <target state="translated">제공된 컨텍스트는 트랜잭션이 커밋되거나 롤백 될 때까지 사용됩니다. 컨텍스트가 취소되면 SQL 패키지는 트랜잭션을 롤백합니다. BeginTx에 제공된 컨텍스트가 취소되면 Tx.Commit에서 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="08a11fcf0761deb535b1afddd2450e0cb1b073dd" translate="yes" xml:space="preserve">
          <source>The provided context will be used for the preparation of the context, not for the execution of the returned statement. The returned statement will run in the transaction context.</source>
          <target state="translated">제공된 컨텍스트는 리턴 된 명령문 실행이 아니라 컨텍스트 준비에 사용됩니다. 리턴 된 명령문은 트랜잭션 컨텍스트에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="36087efe71a5f2727d53bfdfa94ece516eb41424" translate="yes" xml:space="preserve">
          <source>The provided key must be comparable and should not be of type string or any other built-in type to avoid collisions between packages using context. Users of WithValue should define their own types for keys. To avoid allocating when assigning to an interface{}, context keys often have concrete type struct{}. Alternatively, exported context key variables' static type should be a pointer or interface.</source>
          <target state="translated">제공된 키는 비교 가능해야하며 컨텍스트를 사용하여 패키지 간 충돌을 피하기 위해 문자열 유형 또는 기타 내장 유형이 아니어야합니다. WithValue 사용자는 자신의 키 유형을 정의해야합니다. 인터페이스 {}에 할당 할 때 할당을 피하기 위해 컨텍스트 키는 종종 구체적인 유형 struct {}를 갖습니다. 또는 내 보낸 컨텍스트 키 변수의 정적 유형은 포인터 또는 인터페이스 여야합니다.</target>
        </trans-unit>
        <trans-unit id="85ad36caa7041b29ad99437d10d43da203313ed0" translate="yes" xml:space="preserve">
          <source>The race detector kills the program if it exceeds 8192 concurrent goroutines, so use care when running parallel tests with the -race flag set.</source>
          <target state="translated">경주 탐지기는 동시 고 루틴이 8192 개를 초과하면 프로그램을 종료하므로 -race 플래그가 설정된 병렬 테스트를 실행할 때는주의하십시오.</target>
        </trans-unit>
        <trans-unit id="8b5744dbc3f5965d88d3d9f6581899823cd536e1" translate="yes" xml:space="preserve">
          <source>The rand parameter is used as a source of entropy to ensure that encrypting the same message twice doesn't result in the same ciphertext.</source>
          <target state="translated">rand 매개 변수는 동일한 메시지를 두 번 암호화해도 동일한 암호문이 생성되지 않도록 엔트로피 소스로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9b3902f0d9da9da0e87784ba5652f4c8601d4919" translate="yes" xml:space="preserve">
          <source>The random parameter is used as a source of entropy to ensure that encrypting the same message twice doesn't result in the same ciphertext.</source>
          <target state="translated">무작위 매개 변수는 동일한 메시지를 두 번 암호화해도 동일한 암호문이 생성되지 않도록 엔트로피 소스로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cf169dddc14ea8341fcb30899e22a5fa61df4712" translate="yes" xml:space="preserve">
          <source>The random parameter, if not nil, is used to blind the private-key operation and avoid timing side-channel attacks. Blinding is purely internal to this function &amp;ndash; the random data need not match that used when encrypting.</source>
          <target state="translated">nil이 아닌 경우 임의의 매개 변수는 개인 키 조작을 블라인드하고 타이밍 부 채널 공격을 피하기 위해 사용됩니다. 블라인드는이 기능의 내부에 있습니다. 무작위 데이터는 암호화 할 때 사용한 데이터와 일치하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="2314ea9b04c810fb371325317bf102a02d2d59d0" translate="yes" xml:space="preserve">
          <source>The rawurl may be relative (a path, without a host) or absolute (starting with a scheme). Trying to parse a hostname and path without a scheme is invalid but may not necessarily return an error, due to parsing ambiguities.</source>
          <target state="translated">rawurl은 상대적이거나 (호스트가없는 경로) 또는 절대적입니다 (구성표로 시작). 스키마없이 호스트 이름과 경로를 구문 분석하는 것은 유효하지 않지만 모호한 구문 분석으로 인해 오류를 리턴하지 않을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="239176c955d354cb84e342df1da6a160a09d1822" translate="yes" xml:space="preserve">
          <source>The read and write halves of the connection are serialized independently, so no interlocking is required. However each half may be accessed concurrently so the implementation of conn should protect against concurrent reads or concurrent writes.</source>
          <target state="translated">연결의 읽기 및 쓰기 절반은 독립적으로 직렬화되므로 인터 로킹이 필요하지 않습니다. 그러나 각 절반에 동시에 액세스 할 수 있으므로 conn 구현은 동시 읽기 또는 동시 쓰기로부터 보호해야합니다.</target>
        </trans-unit>
        <trans-unit id="b43ec28ed349612adbaa799bb6c92934c3b075dc" translate="yes" xml:space="preserve">
          <source>The real built-in function returns the real part of the complex number c. The return value will be floating point type corresponding to the type of c.</source>
          <target state="translated">실제 내장 함수는 복소수 c의 실수 부분을 반환합니다. 리턴 값은 c의 유형에 해당하는 부동 소수점 유형입니다.</target>
        </trans-unit>
        <trans-unit id="9bb09164885f351e6fb900da553f1e63b375bfa9" translate="yes" xml:space="preserve">
          <source>The recognized day of week formats are &quot;Mon&quot; and &quot;Monday&quot;. The recognized month formats are &quot;Jan&quot; and &quot;January&quot;.</source>
          <target state="translated">인식되는 요일 형식은 &quot;월&quot;및 &quot;월요일&quot;입니다. 인식되는 월 형식은 &quot;Jan&quot;및 &quot;January&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="2c571daa54e2fb7d0c128741daf715a11d1e44fe" translate="yes" xml:space="preserve">
          <source>The recover built-in function allows a program to manage behavior of a panicking goroutine. Executing a call to recover inside a deferred function (but not any function called by it) stops the panicking sequence by restoring normal execution and retrieves the error value passed to the call of panic. If recover is called outside the deferred function it will not stop a panicking sequence. In this case, or when the goroutine is not panicking, or if the argument supplied to panic was nil, recover returns nil. Thus the return value from recover reports whether the goroutine is panicking.</source>
          <target state="translated">내장 기능 복구 기능을 통해 프로그램은 당황한 고 루틴의 동작을 관리 할 수 ​​있습니다. 지연된 함수 내에서 복구하기 위해 호출을 실행하면 (이에 의해 호출 된 함수는 아님) 정상적인 실행을 복원하여 패닉 시퀀스를 중지하고 패닉 호출에 전달 된 오류 값을 검색합니다. 지연된 함수 외부에서 recover를 호출하면 패닉 시퀀스가 ​​중지되지 않습니다. 이 경우 또는 goroutine이 당황하지 않거나 패닉에 제공된 인수가 nil 인 경우 recover는 nil을 리턴합니다. 따라서 recover의 리턴 값은 고 루틴이 당황하는지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="ff14ed6c9720c452a0294998e96d92039ec86474" translate="yes" xml:space="preserve">
          <source>The regexp implementation provided by this package is guaranteed to run in time linear in the size of the input. (This is a property not guaranteed by most open source implementations of regular expressions.) For more information about this property, see</source>
          <target state="translated">이 패키지가 제공하는 정규 표현식 구현은 입력 크기에 따라 선형으로 실행됩니다. (이것은 대부분의 정규 표현식의 오픈 소스 구현에서 보장하지 않는 속성입니다.)이 속성에 대한 자세한 내용은 다음을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e4c94cab05a4e2263ef4f912bc17e254d9de85c1" translate="yes" xml:space="preserve">
          <source>The regionType is used to classify regions, so there should be only a handful of unique region types.</source>
          <target state="translated">regionType은 지역을 분류하는 데 사용되므로 소수의 고유 지역 유형 만 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="613161bf225c19a5f2c8859dc32ad7cbf64fe341" translate="yes" xml:space="preserve">
          <source>The regular expression syntax understood by this package when parsing with the Perl flag is as follows. Parts of the syntax can be disabled by passing alternate flags to Parse.</source>
          <target state="translated">Perl 플래그로 구문 분석 할 때이 패키지가 이해하는 정규식 구문은 다음과 같습니다. 구문 분석에 대체 플래그를 전달하여 구문의 일부를 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="414d3f9a62c65f403de754cbbecda8b294ef6a05" translate="yes" xml:space="preserve">
          <source>The remaining patterns enumerate the only valid conversions from uintptr to Pointer.</source>
          <target state="translated">나머지 패턴은 uintptr에서 Pointer 로의 유효한 변환 만 열거합니다.</target>
        </trans-unit>
        <trans-unit id="f01d454f6a8093b81d93ec48391c3d15861fea72" translate="yes" xml:space="preserve">
          <source>The remaining signals are asynchronous signals. They are not triggered by program errors, but are instead sent from the kernel or from some other program.</source>
          <target state="translated">나머지 신호는 비동기 신호입니다. 그것들은 프로그램 오류에 의해 트리거되지 않지만 대신 커널이나 다른 프로그램에서 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="b6f243f72fd3fe537acd4a5fca41b95e81ce45b9" translate="yes" xml:space="preserve">
          <source>The representation of types is described below. When a type is defined on a given connection between an Encoder and Decoder, it is assigned a signed integer type id. When Encoder.Encode(v) is called, it makes sure there is an id assigned for the type of v and all its elements and then it sends the pair (typeid, encoded-v) where typeid is the type id of the encoded type of v and encoded-v is the gob encoding of the value v.</source>
          <target state="translated">유형의 표현은 아래에 설명되어 있습니다. 엔코더와 디코더 사이의 주어진 연결에서 유형이 정의되면 부호있는 정수 유형 ID가 지정됩니다. Encoder.Encode (v)가 호출되면 v 유형과 모든 요소에 지정된 ID가 있는지 확인한 다음 typeid가 인코딩 된 유형의 유형 id 인 쌍 (typeid, encrypted-v)을 보냅니다. v와 encoding-v는 값 v의 gob 인코딩입니다.</target>
        </trans-unit>
        <trans-unit id="cd667628565a5086d3e9895b56322424dc5621cd" translate="yes" xml:space="preserve">
          <source>The request Body, if non-nil, will be closed by the underlying Transport, even on errors.</source>
          <target state="translated">요청 본문이 0이 아닌 경우 기본 전송에서 오류가 발생하더라도 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="d4e026c3f59ca2f49146d499574e033e155a3b79" translate="yes" xml:space="preserve">
          <source>The resolver decision can be overridden by setting the netdns value of the GODEBUG environment variable (see package runtime) to go or cgo, as in:</source>
          <target state="translated">다음과 같이 GODEBUG 환경 변수 (패키지 런타임 참조)의 netdns 값을 go 또는 cgo로 설정하여 해결 프로그램 결정을 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85ba008f9a41b800d285074394b704f73cc09894" translate="yes" xml:space="preserve">
          <source>The rest of this package comment may be skipped on first reading; it includes details necessary to understand escaping contexts and error messages. Most users will not need to understand these details.</source>
          <target state="translated">이 패키지 주석의 나머지 부분은 처음 읽을 때 건너 뛸 수 있습니다. 이스케이프 컨텍스트 및 오류 메시지를 이해하는 데 필요한 세부 사항이 포함됩니다. 대부분의 사용자는 이러한 세부 사항을 이해할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5f29380aa9a229b911cfb4cbcef02c25951562ac" translate="yes" xml:space="preserve">
          <source>The rest of this section gives the precise details of how operations use monotonic clocks, but understanding those details is not required to use this package.</source>
          <target state="translated">이 섹션의 나머지 부분에서는 작업이 단조로운 시계를 사용하는 방법에 대한 정확한 세부 정보를 제공하지만이 패키지를 사용하기 위해 해당 세부 정보를 이해하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="b7f11101676a7b7c4f383ade5d8d3f82131c1b53" translate="yes" xml:space="preserve">
          <source>The result of Scan is one of these tokens or a Unicode character.</source>
          <target state="translated">스캔 결과는 이러한 토큰 중 하나이거나 유니 코드 문자입니다.</target>
        </trans-unit>
        <trans-unit id="4646462be207e1c8f655d521c7883b8db5be5339" translate="yes" xml:space="preserve">
          <source>The results of a benchmark run.</source>
          <target state="translated">벤치 마크 실행 결과.</target>
        </trans-unit>
        <trans-unit id="6be7e87ff9924a05b7bc2a7006d807f1fab39e3d" translate="yes" xml:space="preserve">
          <source>The returned *Float f is nil and the value of z is valid but not defined if an error is reported.</source>
          <target state="translated">리턴 된 * Float f는 nil이고 z의 값은 유효하지만 오류가보고되면 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bac86830681be1d31b72f9f7791b1c44ac2452e7" translate="yes" xml:space="preserve">
          <source>The returned Cmd's Args field is constructed from the command name followed by the elements of arg, so arg should not include the command name itself. For example, Command(&quot;echo&quot;, &quot;hello&quot;). Args[0] is always name, not the possibly resolved Path.</source>
          <target state="translated">반환 된 Cmd의 Args 필드는 명령 이름과 arg 요소로 구성되므로 arg는 명령 이름 자체를 포함하지 않아야합니다. 예를 들어 Command ( &quot;echo&quot;, &quot;hello&quot;)입니다. Args [0]은 항상 해결 된 Path가 아닌 이름입니다.</target>
        </trans-unit>
        <trans-unit id="fe921f2e96cf2be56c2bf49f4740170d8dd45071" translate="yes" xml:space="preserve">
          <source>The returned Conn, if any, will always be of type *Conn.</source>
          <target state="translated">리턴 된 Conn (있는 경우)은 항상 * Conn 유형입니다.</target>
        </trans-unit>
        <trans-unit id="3bc6a14f8ce0d88107543f9f02901b96c67b460c" translate="yes" xml:space="preserve">
          <source>The returned DB is safe for concurrent use by multiple goroutines and maintains its own pool of idle connections. Thus, the Open function should be called just once. It is rarely necessary to close a DB.</source>
          <target state="translated">반환 된 DB는 여러 고 루틴이 동시에 사용할 수 있으며 자체 유휴 연결 풀을 유지 관리합니다. 따라서 Open 함수는 한 번만 호출해야합니다. DB를 닫을 필요는 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="c94572c3b7d816968d78d57402944f7efb4246e7" translate="yes" xml:space="preserve">
          <source>The returned DB is safe for concurrent use by multiple goroutines and maintains its own pool of idle connections. Thus, the OpenDB function should be called just once. It is rarely necessary to close a DB.</source>
          <target state="translated">반환 된 DB는 여러 고 루틴이 동시에 사용할 수 있으며 자체 유휴 연결 풀을 유지 관리합니다. 따라서 OpenDB 함수는 한 번만 호출해야합니다. DB를 닫을 필요는 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="33f1666e076b57e7a3379acacb81a7ec24e7d31d" translate="yes" xml:space="preserve">
          <source>The returned RawConn only supports calling Control. Read and Write return an error.</source>
          <target state="translated">반환 된 RawConn은 Control 호출 만 지원합니다. 읽기 및 쓰기는 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="00382818b7b561dcf8c2e41afc3acbf78809ee7a" translate="yes" xml:space="preserve">
          <source>The returned Response will have at least its StatusCode, Header, Body, and optionally Trailer populated. More fields may be populated in the future, so callers should not DeepEqual the result in tests.</source>
          <target state="translated">반환 된 응답에는 최소한 StatusCode, 헤더, 본문 및 선택적으로 예고편이 채워집니다. 앞으로 더 많은 필드가 채워질 수 있으므로 호출자는 테스트에서 결과를 깊게 같지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="f4f37717fc57244b8b099472fa87f281f196d58d" translate="yes" xml:space="preserve">
          <source>The returned context is always non-nil; it defaults to the background context.</source>
          <target state="translated">돌려 주어진 문맥은 항상 비논리입니다. 기본적으로 배경 컨텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="9cbe06fbabaade2695a345469e46bbf5011eaae5" translate="yes" xml:space="preserve">
          <source>The returned end function is used to mark the task's end. The trace tool measures task latency as the time between task creation and when the end function is called, and provides the latency distribution per task type. If the end function is called multiple times, only the first call is used in the latency measurement.</source>
          <target state="translated">반환 된 종료 기능은 작업의 종료를 표시하는 데 사용됩니다. 추적 도구는 작업 생성과 종료 기능이 호출 될 때까지의 시간으로 작업 대기 시간을 측정하고 작업 유형별 대기 시간 분포를 제공합니다. 종료 기능이 여러 번 호출되면 대기 시간 측정에 첫 번째 호출 만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f0a8feeaa4dbaf36e773a52f49c0b0ac6bb7e74a" translate="yes" xml:space="preserve">
          <source>The returned error is nil if the command runs, has no problems copying stdin, stdout, and stderr, and exits with a zero exit status.</source>
          <target state="translated">명령이 실행되고 stdin, stdout 및 stderr를 복사하는 데 문제가없고 종료 상태가 0 인 경우 리턴되는 오류는 nil입니다.</target>
        </trans-unit>
        <trans-unit id="4d6b3f09dc97620be2a232fb3dc17468c15d1426" translate="yes" xml:space="preserve">
          <source>The returned list does not identify the associated interface; use Interfaces and Interface.Addrs for more detail.</source>
          <target state="translated">리턴 된 목록은 연관된 인터페이스를 식별하지 않습니다. 자세한 내용은 Interfaces and Interface.Addrs를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c6a6b1723d6bc4ac24e64af0ce75d94122db9245" translate="yes" xml:space="preserve">
          <source>The returned memory allocator statistics are up to date as of the call to ReadMemStats. This is in contrast with a heap profile, which is a snapshot as of the most recently completed garbage collection cycle.</source>
          <target state="translated">반환 된 메모리 할당 자 통계는 ReadMemStats를 호출 할 때 최신 상태입니다. 이것은 가장 최근에 완료된 가비지 콜렉션주기의 스냅 샷 인 힙 프로파일과 대조됩니다.</target>
        </trans-unit>
        <trans-unit id="a6ee6f83dacc73003b6dade23a5eca55ab60b66f" translate="yes" xml:space="preserve">
          <source>The returned os.File's file descriptor is different from the connection's. Attempting to change properties of the original using this duplicate may or may not have the desired effect.</source>
          <target state="translated">반환 된 os.File의 파일 디스크립터가 연결의 파일 디스크립터와 다릅니다. 이 복제본을 사용하여 원본의 속성을 변경하려고하면 원하는 효과가 있거나 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5927f2050b65cd29032e207117c8b2d6ca472e54" translate="yes" xml:space="preserve">
          <source>The returned path ends in a slash only if it is the root &quot;/&quot;.</source>
          <target state="translated">리턴 된 경로는 루트 &quot;/&quot;인 경우에만 슬래시로 끝납니다.</target>
        </trans-unit>
        <trans-unit id="004ac519a1c16ea761d189382ea9cc0c1b68b7d1" translate="yes" xml:space="preserve">
          <source>The returned path ends in a slash only if it represents a root directory, such as &quot;/&quot; on Unix or `C:\` on Windows.</source>
          <target state="translated">리턴 된 경로는 루트 디렉토리 (유닉스에서 &quot;/&quot;또는 Windows에서`C : \`)를 나타내는 경우에만 슬래시로 끝납니다.</target>
        </trans-unit>
        <trans-unit id="709611ccac6cb61ed7ee0c2fc8499ed7e268fed4" translate="yes" xml:space="preserve">
          <source>The returned profile may be up to two garbage collection cycles old. This is to avoid skewing the profile toward allocations; because allocations happen in real time but frees are delayed until the garbage collector performs sweeping, the profile only accounts for allocations that have had a chance to be freed by the garbage collector.</source>
          <target state="translated">리턴 된 프로파일은 최대 두 개의 가비지 콜렉션주기 이전 일 수 있습니다. 이는 프로파일이 할당쪽으로 기울어지지 않도록하기위한 것입니다. 할당은 실시간으로 발생하지만 가비지 수집기가 스위핑을 수행 할 때까지 해제가 지연되기 때문에 프로필은 가비지 수집기에 의해 해제 될 수있는 할당 만 설명합니다.</target>
        </trans-unit>
        <trans-unit id="2fcbc7cecfbd88a968cff813905d726fdf40b131" translate="yes" xml:space="preserve">
          <source>The returned slice is the certificate in DER encoding.</source>
          <target state="translated">반환 된 슬라이스는 DER 인코딩의 인증서입니다.</target>
        </trans-unit>
        <trans-unit id="01c758564c188da314abf0218bd7cfbe2c752f80" translate="yes" xml:space="preserve">
          <source>The returned slice is the certificate request in DER encoding.</source>
          <target state="translated">반환 된 슬라이스는 DER 인코딩의 인증서 요청입니다.</target>
        </trans-unit>
        <trans-unit id="56ef9da288a159e17f780d686422f0dfcfa221a7" translate="yes" xml:space="preserve">
          <source>The returned statement operates within the transaction and can no longer be used once the transaction has been committed or rolled back.</source>
          <target state="translated">리턴 된 명령문은 트랜잭션 내에서 작동하며 트랜잭션이 커미트되거나 롤백되면 더 이상 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="eaef2ac25b5ec95632c077f9297b6bf55f5dd3f6" translate="yes" xml:space="preserve">
          <source>The returned statement operates within the transaction and will be closed when the transaction has been committed or rolled back.</source>
          <target state="translated">리턴 된 명령문은 트랜잭션 내에서 작동하며 트랜잭션이 커미트되거나 롤백 될 때 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="10df7eea472cec1ead17a66cb1fdaefe2e6578cc" translate="yes" xml:space="preserve">
          <source>The returned string is meant for debugging; for a stable serialized representation, use t.MarshalText, t.MarshalBinary, or t.Format with an explicit format string.</source>
          <target state="translated">반환 된 문자열은 디버깅을위한 것입니다. 안정적인 직렬화 표현을 위해서는 명시 적 형식 문자열과 함께 t.MarshalText, t.MarshalBinary 또는 t.Format을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="48866f9aa69c2bb04dcb85d20c5a3c1d2d405ca8" translate="yes" xml:space="preserve">
          <source>The rule Title uses for word boundaries does not handle Unicode punctuation properly.</source>
          <target state="translated">제목에서 단어 경계에 사용하는 규칙은 유니 코드 문장 부호를 올바르게 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f80f01b0edf7103d5ecb8ca06eb4e22919710f70" translate="yes" xml:space="preserve">
          <source>The same Context may be passed to functions running in different goroutines; Contexts are safe for simultaneous use by multiple goroutines.</source>
          <target state="translated">동일한 컨텍스트가 다른 고 루틴에서 실행되는 함수에 전달 될 수 있습니다. 문맥은 여러 고 루틴이 동시에 사용하기에 안전합니다.</target>
        </trans-unit>
        <trans-unit id="a401c4efb67cc0055f52caa84dcf2de0d8f63cd7" translate="yes" xml:space="preserve">
          <source>The second argument, quote, specifies the type of literal being parsed and therefore which escaped quote character is permitted. If set to a single quote, it permits the sequence \' and disallows unescaped '. If set to a double quote, it permits \&quot; and disallows unescaped &quot;. If set to zero, it does not permit either escape and allows both quote characters to appear unescaped.</source>
          <target state="translated">두 번째 인수 인 quote는 구문 분석되는 리터럴의 유형을 지정하므로 이스케이프 된 인용 문자가 허용됩니다. 작은 따옴표로 설정하면 \ '시퀀스를 허용하고 이스케이프 처리되지 않은'을 허용하지 않습니다. 큰 따옴표로 설정하면 \ &quot;를 허용하고 이스케이프되지 않은&quot;을 허용하지 않습니다. 0으로 설정하면 이스케이프를 허용하지 않으며 두 인용 부호가 모두 이스케이프되지 않은 것으로 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40a1d3ecbed0bf217ec97ece1c42e914315bd313" translate="yes" xml:space="preserve">
          <source>The security model used by this package assumes that template authors are trusted, while Execute's data parameter is not. More details are provided below.</source>
          <target state="translated">이 패키지에서 사용하는 보안 모델은 템플릿 작성자가 신뢰할 수 있다고 가정하지만 Execute의 data 매개 변수는 그렇지 않습니다. 자세한 내용은 아래에 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="a70cb84ae80d93013971dc3c09e0dd11fbe3a660" translate="yes" xml:space="preserve">
          <source>The server calls (for HTTP service):</source>
          <target state="translated">서버는 (HTTP 서비스를 위해) 호출합니다 :</target>
        </trans-unit>
        <trans-unit id="4694acea63f5ebf8b8be35e4e84982505cd7d21a" translate="yes" xml:space="preserve">
          <source>The server may handle requests on a single connection by calling ServeConn. More typically it will create a network listener and call Accept or, for an HTTP listener, HandleHTTP and http.Serve.</source>
          <target state="translated">서버는 ServeConn을 호출하여 단일 연결에서 요청을 처리 할 수 ​​있습니다. 보다 일반적으로 네트워크 리스너를 작성하고 Accept 또는 HTTP 리스너의 경우 HandleHTTP 및 http.Serve를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="901fd3527b931189389dc8b05aa80a401b308de0" translate="yes" xml:space="preserve">
          <source>The set of available CPUs is checked by querying the operating system at process startup. Changes to operating system CPU allocation after process startup are not reflected.</source>
          <target state="translated">사용 가능한 CPU 세트는 프로세스 시작시 운영 체제를 조회하여 확인합니다. 프로세스 시작 후 운영 체제 CPU 할당에 대한 변경 사항은 반영되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a4ffb207191c8f11d25b769c7eab3f4bd62e8f7a" translate="yes" xml:space="preserve">
          <source>The set of metrics defined by this package may evolve as the runtime itself evolves, and also enables variation across Go implementations, whose relevant metric sets may not intersect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10e3cd17c3685da24fcde871ef4da00a080771a9" translate="yes" xml:space="preserve">
          <source>The signals SIGKILL and SIGSTOP may not be caught by a program, and therefore cannot be affected by this package.</source>
          <target state="translated">SIGKILL 및 SIGSTOP 신호는 프로그램에 의해 포착되지 않을 수 있으므로이 패키지의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7621705ac03f21ac222836c967959708135562eb" translate="yes" xml:space="preserve">
          <source>The simplest use of a Scanner, to read standard input as a set of lines.</source>
          <target state="translated">표준 입력을 라인 세트로 읽는 스캐너의 가장 간단한 사용.</target>
        </trans-unit>
        <trans-unit id="9c0657904725889b0c9ba75534abc4f635bc0b2b" translate="yes" xml:space="preserve">
          <source>The size of a CRC-32 checksum in bytes.</source>
          <target state="translated">바이트 단위의 CRC-32 체크섬 크기입니다.</target>
        </trans-unit>
        <trans-unit id="3ff608e7233df0580119a8a262ba634622895d8a" translate="yes" xml:space="preserve">
          <source>The size of a CRC-64 checksum in bytes.</source>
          <target state="translated">바이트 단위의 CRC-64 체크섬 크기입니다.</target>
        </trans-unit>
        <trans-unit id="caae8e5aad6dbb0160181390b9818b080d122c80" translate="yes" xml:space="preserve">
          <source>The size of a SHA-1 checksum in bytes.</source>
          <target state="translated">바이트 단위의 SHA-1 체크섬 크기입니다.</target>
        </trans-unit>
        <trans-unit id="cea16f97cc88534275f0e03f305d57951a36e34b" translate="yes" xml:space="preserve">
          <source>The size of a SHA224 checksum in bytes.</source>
          <target state="translated">바이트 단위의 SHA224 체크섬 크기입니다.</target>
        </trans-unit>
        <trans-unit id="3a1556147bf25a0038243a962f16bc9d44b98e20" translate="yes" xml:space="preserve">
          <source>The size of a SHA256 checksum in bytes.</source>
          <target state="translated">바이트 단위의 SHA256 체크섬 크기입니다.</target>
        </trans-unit>
        <trans-unit id="fb49c909a50ec86545c33e34c0f3d64148914e03" translate="yes" xml:space="preserve">
          <source>The size of an Adler-32 checksum in bytes.</source>
          <target state="translated">Adler-32 체크섬의 크기 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="edf1ef16cc66ffa121682ca1207ef5467651c4f4" translate="yes" xml:space="preserve">
          <source>The size of an MD5 checksum in bytes.</source>
          <target state="translated">MD5 체크섬의 크기 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="248e03e24b52c36053fea2b5fabdbb42fe255abb" translate="yes" xml:space="preserve">
          <source>The skip parameter has the same meaning as runtime.Caller's skip and controls where the stack trace begins. Passing skip=0 begins the trace in the function calling Add. For example, given this execution stack:</source>
          <target state="translated">skip 매개 변수는 런타임과 동일한 의미를 갖습니다. 건너 뛰기 및 스택 추적이 시작되는 위치를 제어합니다. skip = 0을 전달하면 Add를 호출하는 함수에서 추적이 시작됩니다. 예를 들어,이 실행 스택이 주어지면 :</target>
        </trans-unit>
        <trans-unit id="b675e8a3e2a529e23f6f667c1adf36c39ed93efb" translate="yes" xml:space="preserve">
          <source>The slice returned by this method consists of all the substrings of s not contained in the slice returned by FindAllString. When called on an expression that contains no metacharacters, it is equivalent to strings.SplitN.</source>
          <target state="translated">이 메소드에 의해 리턴 된 슬라이스는 FindAllString에 의해 리턴 된 슬라이스에 포함되지 않은 s의 모든 서브 스트링으로 구성됩니다. 메타 문자가없는 표현식에서 호출되면 strings.SplitN과 같습니다.</target>
        </trans-unit>
        <trans-unit id="37fc7946d5ac5fa1638ca298818fb97686f9142e" translate="yes" xml:space="preserve">
          <source>The smtp package is frozen and is not accepting new features. Some external packages provide more functionality. See:</source>
          <target state="translated">smtp 패키지가 정지되었으며 새 기능을 허용하지 않습니다. 일부 외부 패키지는 더 많은 기능을 제공합니다. 보다:</target>
        </trans-unit>
        <trans-unit id="37671db71f74ceff10a366ff8f17e7a0a28fae66" translate="yes" xml:space="preserve">
          <source>The sort is not guaranteed to be stable. For a stable sort, use SliceStable.</source>
          <target state="translated">정렬이 안정적으로 보장되지는 않습니다. 안정적인 정렬을 위해서는 SliceStable을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="bda42a397fbbab417ff8adfb3aa5399f5d54b818" translate="yes" xml:space="preserve">
          <source>The sort is not guaranteed to be stable: equal elements may be reversed from their original order. For a stable sort, use SliceStable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17c5e77086e67a3f2c51a48bac9596dffc360456" translate="yes" xml:space="preserve">
          <source>The source and destination values/types need not correspond exactly. For structs, fields (identified by name) that are in the source but absent from the receiving variable will be ignored. Fields that are in the receiving variable but missing from the transmitted type or value will be ignored in the destination. If a field with the same name is present in both, their types must be compatible. Both the receiver and transmitter will do all necessary indirection and dereferencing to convert between gobs and actual Go values. For instance, a gob type that is schematically,</source>
          <target state="translated">소스 및 대상 값 / 유형이 정확히 일치 할 필요는 없습니다. 구조체의 경우 소스에 있지만 수신 변수가없는 필드 (이름으로 식별)는 무시됩니다. 수신 변수에 있지만 전송 된 유형 또는 값에서 누락 된 필드는 대상에서 무시됩니다. 동일한 이름을 가진 필드가 둘 다 존재하는 경우 해당 유형이 호환 가능해야합니다. 수신기와 송신기 모두 gobs와 실제 Go 값 사이를 변환하기 위해 필요한 모든 간접 및 역 참조를 수행합니다. 예를 들어, 개략적 인 gob 유형은</target>
        </trans-unit>
        <trans-unit id="0268779129500cf4856c5f56fd67106abaf097eb" translate="yes" xml:space="preserve">
          <source>The source code could include additional Go code. That code was never compiled but would be processed by tools like godoc and might be useful as end-user documentation.</source>
          <target state="translated">소스 코드에는 추가 Go 코드가 포함될 수 있습니다. 이 코드는 컴파일되지 않았지만 godoc과 같은 도구로 처리되며 최종 사용자 문서로 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="535d0edaef1db8d5c1dc136b1a303868255bb996" translate="yes" xml:space="preserve">
          <source>The source:</source>
          <target state="translated">출처 :</target>
        </trans-unit>
        <trans-unit id="e645e5bfb164f126d92a3414aa1a585176c8e465" translate="yes" xml:space="preserve">
          <source>The sql package checks for value checkers in the following order, stopping at the first found match: Stmt.NamedValueChecker, Conn.NamedValueChecker, Stmt.ColumnConverter, DefaultParameterConverter.</source>
          <target state="translated">SQL 패키지는 Stmt.NamedValueChecker, Conn.NamedValueChecker, Stmt.ColumnConverter, DefaultParameterConverter와 같이 첫 번째 발견 된 일치 항목에서 중지하여 값 검사기를 검사합니다.</target>
        </trans-unit>
        <trans-unit id="bf35db5d84a5c59679d57c2063978bf2973a302c" translate="yes" xml:space="preserve">
          <source>The sql package creates and frees connections automatically; it also maintains a free pool of idle connections. If the database has a concept of per-connection state, such state can be reliably observed within a transaction (Tx) or connection (Conn). Once DB.Begin is called, the returned Tx is bound to a single connection. Once Commit or Rollback is called on the transaction, that transaction's connection is returned to DB's idle connection pool. The pool size can be controlled with SetMaxIdleConns.</source>
          <target state="translated">sql 패키지는 자동으로 연결을 작성하고 해제합니다. 또한 유휴 연결의 사용 가능한 풀을 유지 관리합니다. 데이터베이스에 연결 별 상태 개념이있는 경우 트랜잭션 (Tx) 또는 연결 (Conn) 내에서 이러한 상태를 안정적으로 관찰 할 수 있습니다. DB.Begin이 호출되면 반환 된 Tx는 단일 연결에 바인딩됩니다. 트랜잭션에서 커밋 또는 롤백이 호출되면 해당 트랜잭션의 연결이 DB의 유휴 연결 풀로 반환됩니다. 풀 크기는 SetMaxIdleConns로 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14c50009f306ef9ba308a3f9f45cb12ceab6e041" translate="yes" xml:space="preserve">
          <source>The sql package must be used in conjunction with a database driver. See &lt;a href=&quot;https://golang.org/s/sqldrivers&quot;&gt;https://golang.org/s/sqldrivers&lt;/a&gt; for a list of drivers.</source>
          <target state="translated">SQL 패키지는 데이터베이스 드라이버와 함께 사용해야합니다. 드라이버 목록은 &lt;a href=&quot;https://golang.org/s/sqldrivers&quot;&gt;https://golang.org/s/sqldrivers&lt;/a&gt; 를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="ff11c76849e5520b5d3c1908876a0a08249bbd90" translate="yes" xml:space="preserve">
          <source>The src/ directory holds source code. The path below 'src' determines the import path or executable name.</source>
          <target state="translated">src / 디렉토리에는 소스 코드가 있습니다. 'src'아래의 경로는 가져 오기 경로 또는 실행 파일 이름을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="51fce287253a04b9aa4e50fe0cda26970eb0eeca" translate="yes" xml:space="preserve">
          <source>The statements prepared for a transaction by calling the transaction's Prepare or Stmt methods are closed by the call to Commit or Rollback.</source>
          <target state="translated">트랜잭션의 Prepare 또는 Stmt 메소드를 호출하여 트랜잭션을 위해 준비된 명령문은 확약 또는 롤백 호출로 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="7aaae34f98e3bd969409b9d4ab9b72c26d296745" translate="yes" xml:space="preserve">
          <source>The stop function releases resources associated with it, so code should call stop as soon as the operations running in this Context complete and signals no longer need to be diverted to the context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e3f26a83995cf9b083b94337323c62f8d2e679a" translate="yes" xml:space="preserve">
          <source>The stop function unregisters the signal behavior, which, like signal.Reset, may restore the default behavior for a given signal. For example, the default behavior of a Go program receiving os.Interrupt is to exit. Calling NotifyContext(parent, os.Interrupt) will change the behavior to cancel the returned context. Future interrupts received will not trigger the default (exit) behavior until the returned stop function is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="266ee83c3a485624a9ce3be711986c42904d65df" translate="yes" xml:space="preserve">
          <source>The swap operation, implemented by the SwapT functions, is the atomic equivalent of:</source>
          <target state="translated">SwapT 함수로 구현 된 스왑 작업은 다음과 같은 원자입니다.</target>
        </trans-unit>
        <trans-unit id="78109ee602f829fc62630aa0958e0668bde1d9d0" translate="yes" xml:space="preserve">
          <source>The symbolizer function may be nil, in which case the results of the traceback function will be displayed as numbers. If the traceback function is nil, the symbolizer function will never be called. The context function may be nil, in which case the traceback function will only be called with the context field set to zero. If the context function is nil, then calls from Go to C to Go will not show a traceback for the C portion of the call stack.</source>
          <target state="translated">심볼 라이저 기능은 nil 일 수 있으며,이 경우 트레이스 백 기능의 결과가 숫자로 표시됩니다. 역 추적 기능이 nil이면 심볼 라이저 기능이 호출되지 않습니다. 컨텍스트 함수는 nil 일 수 있으며,이 경우 컨텍스트 필드가 0으로 설정된 경우에만 역 추적 함수가 호출됩니다. 컨텍스트 함수가 nil이면 Go to C에서 Go 로의 호출은 호출 스택의 C 부분에 대한 역 추적을 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7f3f65f4777096791e56d64b25eeec76abb44bfa" translate="yes" xml:space="preserve">
          <source>The symbolizer function will be called with a single argument, a pointer to a struct:</source>
          <target state="translated">심볼 라이저 함수는 구조체에 대한 포인터 인 단일 인수로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="826b161e82b6e953fc66964167887f9fb128e89d" translate="yes" xml:space="preserve">
          <source>The syntax of such definitions is to surround each template declaration with a &quot;define&quot; and &quot;end&quot; action.</source>
          <target state="translated">이러한 정의의 구문은 각 템플리트 선언을 &quot;정의&quot;및 &quot;종료&quot;조치로 둘러싸는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a896d242a72cd56df044b310d3d7e48636436044" translate="yes" xml:space="preserve">
          <source>The syntax of the regular expressions accepted is the same general syntax used by Perl, Python, and other languages. More precisely, it is the syntax accepted by RE2 and described at &lt;a href=&quot;https://golang.org/s/re2syntax&quot;&gt;https://golang.org/s/re2syntax&lt;/a&gt;, except for \C. For an overview of the syntax, run</source>
          <target state="translated">허용되는 정규 표현식의 구문은 Perl, Python 및 기타 언어에서 사용되는 것과 동일한 일반 구문입니다. 더 정확하게 말하면, 이것은 RE2에 의해 허용되고 \ C를 제외하고 &lt;a href=&quot;https://golang.org/s/re2syntax&quot;&gt;https://golang.org/s/re2syntax에&lt;/a&gt; 설명 된 구문 입니다. 구문에 대한 개요를 보려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="ba2393e2ef8002ea106da87efa718a59742fc7ac" translate="yes" xml:space="preserve">
          <source>The syslog package is frozen and is not accepting new features. Some external packages provide more functionality. See:</source>
          <target state="translated">syslog 패키지가 정지되었으며 새 기능을 허용하지 않습니다. 일부 외부 패키지는 더 많은 기능을 제공합니다. 보다:</target>
        </trans-unit>
        <trans-unit id="99e701177eab165c110f7e05395c5e3f3462fc8b" translate="yes" xml:space="preserve">
          <source>The table's lower portion shows specialized features of each format, such as supported string encodings, support for sub-second timestamps, or support for sparse files.</source>
          <target state="translated">표 하단에는 지원되는 문자열 인코딩, 1 초 미만의 타임 스탬프 지원 또는 스파 스 파일 지원과 같은 각 형식의 특수 기능이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e6cfcc2895da4e068fb4279dd7ba0aaf57b5ca4f" translate="yes" xml:space="preserve">
          <source>The table's upper portion shows the Header fields, where each format reports the maximum number of bytes allowed for each string field and the integer type used to store each numeric field (where timestamps are stored as the number of seconds since the Unix epoch).</source>
          <target state="translated">표 상단에는 헤더 필드가 표시되며, 각 형식은 각 문자열 필드에 허용되는 최대 바이트 수와 각 숫자 필드를 저장하는 데 사용되는 정수 유형 (타임 스탬프가 유닉스 시대 이후의 초 수로 저장 됨)을보고합니다.</target>
        </trans-unit>
        <trans-unit id="b0a984b621ec68366c5b1261f609a8ab7bb45ea3" translate="yes" xml:space="preserve">
          <source>The tag must be one that takes string values: DT_NEEDED, DT_SONAME, DT_RPATH, or DT_RUNPATH.</source>
          <target state="translated">태그는 문자열 값인 DT_NEEDED, DT_SONAME, DT_RPATH 또는 DT_RUNPATH를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="cbe588a5ff1a44ccc9c3b05cfac0b378253441ae" translate="yes" xml:space="preserve">
          <source>The target is the RFC 7230 &quot;request-target&quot;: it may be either a path or an absolute URL. If target is an absolute URL, the host name from the URL is used. Otherwise, &quot;example.com&quot; is used.</source>
          <target state="translated">대상은 RFC 7230 &quot;요청 대상&quot;입니다. 경로이거나 절대 URL 일 수 있습니다. 대상이 절대 URL 인 경우 URL의 호스트 이름이 사용됩니다. 그렇지 않으면 &quot;example.com&quot;이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a6f845f916ddb97993362899697ada283b05c4e3" translate="yes" xml:space="preserve">
          <source>The taskType is used to classify task instances. Analysis tools like the Go execution tracer may assume there are only a bounded number of unique task types in the system.</source>
          <target state="translated">taskType은 작업 인스턴스를 분류하는 데 사용됩니다. Go 실행 추적 프로그램과 같은 분석 도구는 시스템에 제한된 수의 고유 한 작업 유형 만 있다고 가정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="87c98cdec407269913a37379692f0119d00836f4" translate="yes" xml:space="preserve">
          <source>The template</source>
          <target state="translated">템플릿</target>
        </trans-unit>
        <trans-unit id="8dbf1659d9b474dfc6de39448622e749ace9eba6" translate="yes" xml:space="preserve">
          <source>The testing/quick package is frozen and is not accepting new features.</source>
          <target state="translated">테스트 / 빠른 패키지가 정지되었으며 새 기능을 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="450bac070fc3c1d570ed998a1290dd681976d259" translate="yes" xml:space="preserve">
          <source>The text returned from ReadLine does not include the line end (&quot;\r\n&quot; or &quot;\n&quot;). No indication or error is given if the input ends without a final line end. Calling UnreadByte after ReadLine will always unread the last byte read (possibly a character belonging to the line end) even if that byte is not part of the line returned by ReadLine.</source>
          <target state="translated">ReadLine에서 반환 된 텍스트는 줄 끝 ( &quot;\ r \ n&quot;또는 &quot;\ n&quot;)을 포함하지 않습니다. 입력이 최종 라인 끝없이 종료되면 표시 또는 오류가 발생하지 않습니다. ReadLine 이후에 UnreadByte를 호출하면 해당 바이트가 ReadLine에 의해 리턴 된 행의 일부가 아니더라도 항상 마지막 바이트 읽기 (행 끝에 속하는 문자)를 읽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e19ad8a62ebb2f930cd2d412533e63ab163f9e7f" translate="yes" xml:space="preserve">
          <source>The text/tabwriter package is frozen and is not accepting new features.</source>
          <target state="translated">텍스트 / 탭 라이터 패키지가 정지되어 새 기능을 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b8b4c6c4010154e59471f9dc5acececde45e4c79" translate="yes" xml:space="preserve">
          <source>The time zone database needed by LoadLocation may not be present on all systems, especially non-Unix systems. LoadLocation looks in the directory or uncompressed zip file named by the ZONEINFO environment variable, if any, then looks in known installation locations on Unix systems, and finally looks in $GOROOT/lib/time/zoneinfo.zip.</source>
          <target state="translated">LoadLocation에 필요한 시간대 데이터베이스가 일부 시스템, 특히 비 유닉스 시스템에 존재하지 않을 수 있습니다. LoadLocation은 ZONEINFO 환경 변수로 이름이 지정된 디렉토리 또는 압축되지 않은 zip 파일을 찾은 다음 Unix 시스템의 알려진 설치 위치를 찾은 다음 $ GOROOT / lib / time / zoneinfo.zip을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="d9d95ea8fa35077316d58a8c096d78c878d9e8de" translate="yes" xml:space="preserve">
          <source>The timeout includes name resolution, if required. When using TCP, and the host in the address parameter resolves to multiple IP addresses, the timeout is spread over each consecutive dial, such that each is given an appropriate fraction of the time to connect.</source>
          <target state="translated">필요한 경우 시간 초과에 이름 확인이 포함됩니다. TCP를 사용할 때 address 매개 변수의 호스트가 여러 IP 주소로 확인되면 각 연속 다이얼에 시간 초과가 분산되어 각 연결 시간에 적절한 비율이 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="1be65b230e905dbffd21fbadb56320938e08062d" translate="yes" xml:space="preserve">
          <source>The tools that process the memory profiles assume that the profile rate is constant across the lifetime of the program and equal to the current value. Programs that change the memory profiling rate should do so just once, as early as possible in the execution of the program (for example, at the beginning of main).</source>
          <target state="translated">메모리 프로파일을 처리하는 도구는 프로파일 수명이 프로그램 수명 동안 일정하고 현재 값과 같다고 가정합니다. 메모리 프로파일 링 속도를 변경하는 프로그램은 프로그램 실행시 가능한 한 빨리 (예 : 메인 시작시) 한 번만 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="1a177d1df849e44bddcb9ba4d4be3d9812f21f16" translate="yes" xml:space="preserve">
          <source>The trace tool computes the latency of a task by measuring the time between the task creation and the task end and provides latency distributions for each task type found in the trace.</source>
          <target state="translated">추적 도구는 작업 작성과 작업 종료 사이의 시간을 측정하여 작업의 대기 시간을 계산하고 추적에서 찾은 각 작업 유형에 대한 대기 시간 분포를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="62d0bac03a171fb89c5dd19570b301f5442565f7" translate="yes" xml:space="preserve">
          <source>The traceback and context functions may be called from a signal handler, and must therefore use only async-signal safe functions. The symbolizer function may be called while the program is crashing, and so must be cautious about using memory. None of the functions may call back into Go.</source>
          <target state="translated">역 추적 및 컨텍스트 함수는 신호 핸들러에서 호출 될 수 있으므로 비동기 신호 안전 함수 만 사용해야합니다. 프로그램이 충돌하는 동안 심볼 라이저 함수가 호출 될 수 있으므로 메모리 사용에주의해야합니다. 어떤 함수도 Go를 다시 호출 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="64b5d618701b94606e91495371f70fb5b100120e" translate="yes" xml:space="preserve">
          <source>The traceback function will be called with a single argument, a pointer to a struct:</source>
          <target state="translated">역 추적 함수는 단일 인수, 구조체에 대한 포인터와 함께 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="fbcd1af40286bdefbe9605ee1269e5d70a141d29" translate="yes" xml:space="preserve">
          <source>The two methods Network and String conventionally return strings that can be passed as the arguments to Dial, but the exact form and meaning of the strings is up to the implementation.</source>
          <target state="translated">일반적으로 Network와 String의 두 가지 방법은 Dial에 인수로 전달할 수있는 문자열을 반환하지만 문자열의 정확한 형식과 의미는 구현에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee1fff48d57b4264c60df5732fa6d287858ca513" translate="yes" xml:space="preserve">
          <source>The typ argument may be a defined (Named) type or an alias type. It may also be nil such that the returned TypeName can be used as argument for NewNamed, which will set the TypeName's type as a side- effect.</source>
          <target state="translated">typ 인수는 정의 된 (명명 된) 유형 또는 별명 유형일 수 있습니다. 반환 된 TypeName을 NewNamed에 대한 인수로 사용할 수 있도록 nil 일 수도 있습니다. 이렇게하면 TypeName의 유형이 부작용으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="626d44cfd72353f5912709705dc90b7455988913" translate="yes" xml:space="preserve">
          <source>The type of the variable must be a string type, or a slice of a byte type, or FS (or an alias of FS).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="761242af94989502320341408ab25169d28b2151" translate="yes" xml:space="preserve">
          <source>The typical use case for NewFileTransport is to register the &quot;file&quot; protocol with a Transport, as in:</source>
          <target state="translated">NewFileTransport의 일반적인 사용 사례는 다음과 같이 &quot;파일&quot;프로토콜을 Transport에 등록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c9dec8fd9ff2613dd03956d5301652519fcaec0c" translate="yes" xml:space="preserve">
          <source>The underlying filesystem may truncate or round the values to a less precise time unit. If there is an error, it will be of type *PathError.</source>
          <target state="translated">기본 파일 시스템은 값을 덜 정확한 시간 단위로 자르거나 반올림 할 수 있습니다. 오류가 있으면 * PathError 유형입니다.</target>
        </trans-unit>
        <trans-unit id="bc08db1aae610f1545a452a1bb5a7582597ab3b7" translate="yes" xml:space="preserve">
          <source>The usage message will appear on a separate line for anything but a bool flag with a one-byte name. For bool flags, the type is omitted and if the flag name is one byte the usage message appears on the same line. The parenthetical default is omitted if the default is the zero value for the type. The listed type, here int, can be changed by placing a back-quoted name in the flag's usage string; the first such item in the message is taken to be a parameter name to show in the message and the back quotes are stripped from the message when displayed. For instance, given</source>
          <target state="translated">사용법 메시지는 1 바이트 이름을 가진 부울 플래그 외에는 별도의 행에 나타납니다. bool 플래그의 경우 유형이 생략되고 플래그 이름이 1 바이트 인 경우 사용법 메시지가 동일한 행에 나타납니다. 기본값이 유형의 0 값인 경우 괄호 기본값은 생략됩니다. 열거 된 유형 (여기서 int)은 플래그의 사용 문자열에 백 따옴표로 묶은 이름을 넣어서 변경할 수 있습니다. 메시지의 첫 번째 항목은 메시지에 표시 할 매개 변수 이름으로 사용되며 표시 될 때 메시지에서 백 따옴표가 제거됩니다. 예를 들어, 주어진</target>
        </trans-unit>
        <trans-unit id="7175f6a7da0429173b6be919d1c9513e0498e3e7" translate="yes" xml:space="preserve">
          <source>The value 0xff was chosen because it cannot appear in a valid UTF-8 sequence.</source>
          <target state="translated">0xff 값은 유효한 UTF-8 순서로 표시 될 수 없으므로 선택되었습니다.</target>
        </trans-unit>
        <trans-unit id="e4328a7e24cd2970818970fe425c0b1b3c86f9d7" translate="yes" xml:space="preserve">
          <source>The variadic argument controls whether the function is variadic. FuncOf panics if the in[len(in)-1] does not represent a slice and variadic is true.</source>
          <target state="translated">variadic 인수는 함수가 variadic인지 여부를 제어합니다. in [len (in) -1]이 슬라이스를 나타내지 않고 가변성 인 경우 FuncOf 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1e72c26ccaadcb98e76249dcd1c8f3cdb175e9de" translate="yes" xml:space="preserve">
          <source>The varint functions encode and decode single integer values using a variable-length encoding; smaller values require fewer bytes. For a specification, see &lt;a href=&quot;https://developers.google.com/protocol-buffers/docs/encoding&quot;&gt;https://developers.google.com/protocol-buffers/docs/encoding&lt;/a&gt;.</source>
          <target state="translated">varint 함수는 가변 길이 인코딩을 사용하여 단일 정수 값을 인코딩 및 디코딩합니다. 값이 작을수록 더 적은 바이트가 필요합니다. 사양은 &lt;a href=&quot;https://developers.google.com/protocol-buffers/docs/encoding&quot;&gt;https://developers.google.com/protocol-buffers/docs/encoding을&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="5cdb175715a8f3e26508e589b1b8622549f73fd8" translate="yes" xml:space="preserve">
          <source>The verbs behave analogously to those of Printf. For example, %x will scan an integer as a hexadecimal number, and %v will scan the default representation format for the value. The Printf verbs %p and %T and the flags # and + are not implemented. For floating-point and complex values, all valid formatting verbs (%b %e %E %f %F %g %G %x %X and %v) are equivalent and accept both decimal and hexadecimal notation (for example: &quot;2.3e+7&quot;, &quot;0x4.5p-8&quot;) and digit-separating underscores (for example: &quot;3.14159_26535_89793&quot;).</source>
          <target state="translated">동사는 Printf의 동사와 유사하게 동작합니다. 예를 들어 % x는 정수를 16 진수로 스캔하고 % v는 기본 표현 형식을 스캔합니다. Printf 동사 % p 및 % T와 플래그 # 및 +는 구현되지 않습니다. 부동 소수점 및 복소수 값의 경우 모든 유효한 형식 동사 (% b % e % E % f % F % g % G % x % X 및 % v)는 동일하며 10 진수 및 16 진수 표기법을 모두 사용할 수 있습니다 (예 : &quot;2.3 e + 7 &quot;,&quot;0x4.5p-8 &quot;) 및 숫자 분리 밑줄 (예 :&quot;3.14159_26535_89793 &quot;).</target>
        </trans-unit>
        <trans-unit id="a6ebe1343c13ca95e202e147b7f816ef1bc435a4" translate="yes" xml:space="preserve">
          <source>The verbs:</source>
          <target state="translated">동사 :</target>
        </trans-unit>
        <trans-unit id="3ce9ac6782ffe3c2b00e6a4b78b2ec7b810f1491" translate="yes" xml:space="preserve">
          <source>The writes of individual records are buffered. After all data has been written, the client should call the Flush method to guarantee all data has been forwarded to the underlying io.Writer. Any errors that occurred should be checked by calling the Error method.</source>
          <target state="translated">개별 레코드의 쓰기가 버퍼링됩니다. 모든 데이터가 작성된 후 클라이언트는 Flush 메소드를 호출하여 모든 데이터가 기본 io.Writer로 전달되도록해야합니다. 발생한 모든 오류는 Error 메서드를 호출하여 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="c7efdce3a929526f7cd0a0a9c837645401afe311" translate="yes" xml:space="preserve">
          <source>The zero (uninitialized) value for a Float is ready to use and represents the number +0.0 exactly, with precision 0 and rounding mode ToNearestEven.</source>
          <target state="translated">Float의 0 (초기화되지 않은) 값은 사용할 준비가되었으며 정밀도 0 및 반올림 모드 ToNearestEven과 함께 +0.0을 정확하게 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0956e2f948a72c4e4d0d06cd6f921545906690fb" translate="yes" xml:space="preserve">
          <source>The zero Hash is a valid Hash ready to use. A zero Hash chooses a random seed for itself during the first call to a Reset, Write, Seed, Sum64, or Seed method. For control over the seed, use SetSeed.</source>
          <target state="translated">제로 해시는 사용할 준비가 된 유효한 해시입니다. 제로 해시는 Reset, Write, Seed, Sum64 또는 Seed 메서드를 처음 호출하는 동안 자체적으로 임의의 시드를 선택합니다. 시드를 제어하려면 SetSeed를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="232f8c7f5eea097cc9451d2d90b51db6b069254d" translate="yes" xml:space="preserve">
          <source>The zero Map is empty and ready for use. A Map must not be copied after first use.</source>
          <target state="translated">제로 맵이 비어 있고 사용할 준비가되었습니다. 처음 사용한 후 맵을 복사해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="ba5155e1e3916eee99a712d5244dcde8e9982094" translate="yes" xml:space="preserve">
          <source>The zero Value represents no value. Its IsValid method returns false, its Kind method returns Invalid, its String method returns &quot;&amp;lt;invalid Value&amp;gt;&quot;, and all other methods panic. Most functions and methods never return an invalid value. If one does, its documentation states the conditions explicitly.</source>
          <target state="translated">0 값은 값이 없음을 나타냅니다. IsValid 메서드는 false를 반환하고 Kind 메서드는 Invalid를 반환하고 String 메서드는 &quot;&amp;lt;invalid Value&amp;gt;&quot;를 반환하며 다른 모든 메서드는 패닉 상태입니다. 대부분의 함수와 메소드는 유효하지 않은 값을 반환하지 않습니다. 그럴 경우 문서에 조건이 명시 적으로 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="384c750c13afaffcbd5ebf58e8afec2b8768e946" translate="yes" xml:space="preserve">
          <source>The zero value for Pos is NoPos; there is no file and line information associated with it, and NoPos.IsValid() is false. NoPos is always smaller than any other Pos value. The corresponding Position value for NoPos is the zero value for Position.</source>
          <target state="translated">Pos의 0 값은 NoPos입니다. 연관된 파일 및 행 정보가 없으며 NoPos.IsValid ()가 false입니다. NoPos는 항상 다른 Pos 값보다 작습니다. NoPos의 해당 위치 값은 위치의 0 값입니다.</target>
        </trans-unit>
        <trans-unit id="3f5973e68195ed6a7dd12c4c7dc485f8bde0523d" translate="yes" xml:space="preserve">
          <source>The zero value for an Int, Rat, or Float correspond to 0. Thus, new values can be declared in the usual ways and denote 0 without further initialization:</source>
          <target state="translated">Int, Rat 또는 Float의 0 값은 0에 해당합니다. 따라서 새로운 값은 일반적인 방법으로 선언 할 수 있으며 추가 초기화없이 0을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5d5aa4f538fd1571e15874ad0969ae7c0fda3040" translate="yes" xml:space="preserve">
          <source>The zero value for each field is equivalent to dialing without that option. Dialing with the zero value of Dialer is therefore equivalent to just calling the Dial function.</source>
          <target state="translated">각 필드의 0 값은 해당 옵션이없는 다이얼링과 같습니다. 따라서 다이얼러의 0 값을 사용한 다이얼링은 다이얼 기능을 호출하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="beb5a289f20083f1018df67115c647d61b968230" translate="yes" xml:space="preserve">
          <source>The zero value of type Time is January 1, year 1, 00:00:00.000000000 UTC. As this time is unlikely to come up in practice, the IsZero method gives a simple way of detecting a time that has not been initialized explicitly.</source>
          <target state="translated">Time 유형의 0 값은 1 년 1 월 1 일 00 : 00 : 00.000000000 UTC입니다. 이 시간은 실제로 나타나지 않을 것이므로 IsZero 방법은 명시 적으로 초기화되지 않은 시간을 간단하게 감지 할 수있는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4752552a303f0f1e8a6bd4b3555705dcb31c63a8" translate="yes" xml:space="preserve">
          <source>Then it can make a remote call:</source>
          <target state="translated">그런 다음 원격 전화를 걸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5d500f53dcbe43654b22f15924d609c47bcfc3c" translate="yes" xml:space="preserve">
          <source>Then use the pprof tool to look at the heap profile:</source>
          <target state="translated">그런 다음 pprof 도구를 사용하여 힙 프로파일을보십시오.</target>
        </trans-unit>
        <trans-unit id="d249cadab1a19289ed9fd8f524a7048ff9efb13f" translate="yes" xml:space="preserve">
          <source>There are 16 methods of Regexp that match a regular expression and identify the matched text. Their names are matched by this regular expression:</source>
          <target state="translated">정규식과 일치하고 일치하는 텍스트를 식별하는 16 가지 정규식 방법이 있습니다. 그들의 이름은이 정규식과 일치합니다 :</target>
        </trans-unit>
        <trans-unit id="089af1af9f031a6d4cb36f253f88e22a554b4d75" translate="yes" xml:space="preserve">
          <source>There are many commands available from the pprof command line. Commonly used commands include &quot;top&quot;, which prints a summary of the top program hot-spots, and &quot;web&quot;, which opens an interactive graph of hot-spots and their call graphs. Use &quot;help&quot; for information on all pprof commands.</source>
          <target state="translated">pprof 명령 행에서 사용 가능한 많은 명령이 있습니다. 일반적으로 사용되는 명령에는 최상위 프로그램 핫스팟 요약을 인쇄하는 &quot;top&quot;과 핫스팟의 대화식 그래프 및 해당 호출 그래프를 여는 &quot;web&quot;이 포함됩니다. 모든 pprof 명령에 대한 정보는 &quot;help&quot;를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6fa5b171535b7941feffabcf1c5f915fe3f02940" translate="yes" xml:space="preserve">
          <source>There are no build tags for beta or minor releases.</source>
          <target state="translated">베타 또는 부 릴리스에 대한 빌드 태그가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f4ebe0322e94e23eec9f295ca340080dec64dffd" translate="yes" xml:space="preserve">
          <source>There are three types of user annotations: log messages, regions, and tasks.</source>
          <target state="translated">사용자 주석에는 로그 메시지, 리전 및 작업의 세 가지 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="311b843be371a8c7fc9f6f81df2189e5f92e44e5" translate="yes" xml:space="preserve">
          <source>There is also a set of binary comparison operators defined as functions:</source>
          <target state="translated">함수로 정의 된 이진 비교 연산자 세트도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f5077a9bb275171893d0be52e74cbffe4b19888" translate="yes" xml:space="preserve">
          <source>There is also a standard HTTP interface to profiling data. Adding the following line will install handlers under the /debug/pprof/ URL to download live profiles:</source>
          <target state="translated">데이터 프로파일 링을위한 표준 HTTP 인터페이스도 있습니다. 다음 줄을 추가하면 / debug / pprof / URL 아래에 처리기가 설치되어 라이브 프로필을 다운로드합니다.</target>
        </trans-unit>
        <trans-unit id="f5962f465f0b5c003c4585058fcce10ec6a63c36" translate="yes" xml:space="preserve">
          <source>There is also a standard HTTP interface to trace data. Adding the following line will install a handler under the /debug/pprof/trace URL to download a live trace:</source>
          <target state="translated">데이터를 추적하기위한 표준 HTTP 인터페이스도 있습니다. 다음 행을 추가하면 라이브 추적을 다운로드하기 위해 / debug / pprof / trace URL 아래에 핸들러가 설치됩니다.</target>
        </trans-unit>
        <trans-unit id="669c09ef6ba443f4e07a76e5e520b09339b0d7ba" translate="yes" xml:space="preserve">
          <source>There is also a subset of the methods that can be applied to text read from a RuneReader:</source>
          <target state="translated">RuneReader에서 읽은 텍스트에 적용 할 수있는 메소드의 서브 세트도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5e187581cfc7675624afa1252d945d3159b9872" translate="yes" xml:space="preserve">
          <source>There is no mechanism for full case folding, that is, for characters that involve multiple runes in the input or output.</source>
          <target state="translated">대소 문자 접힘, 즉 입력 또는 출력에 여러 룬이 포함 된 문자에 대한 메커니즘은 없습니다.</target>
        </trans-unit>
        <trans-unit id="4e416754d4e74f38af1b48194c67cf3710f22527" translate="yes" xml:space="preserve">
          <source>These are predefined layouts for use in Time.Format and time.Parse. The reference time used in the layouts is the specific time:</source>
          <target state="translated">이들은 Time.Format 및 time.Parse에서 사용하기 위해 미리 정의 된 레이아웃입니다. 레이아웃에 사용 된 참조 시간은 특정 시간입니다.</target>
        </trans-unit>
        <trans-unit id="622b937b45492ef40cc6c554bb302fd36d24a9dd" translate="yes" xml:space="preserve">
          <source>These are the errors that can be returned in ParseError.Err.</source>
          <target state="translated">ParseError.Err에 반환 될 수있는 오류입니다.</target>
        </trans-unit>
        <trans-unit id="df2271a2f22e4450d78c23577801038a703976de" translate="yes" xml:space="preserve">
          <source>These assume decimal and the Go int type.</source>
          <target state="translated">이들은 10 진수 및 Go int 유형을 가정합니다.</target>
        </trans-unit>
        <trans-unit id="e44cf0ddaa746164e3256589314495380a8d22a3" translate="yes" xml:space="preserve">
          <source>These constants are copied from the flate package, so that code that imports &quot;compress/gzip&quot; does not also have to import &quot;compress/flate&quot;.</source>
          <target state="translated">이 상수는 flate 패키지에서 복사되므로 &quot;compress / gzip&quot;을 가져 오는 코드도 &quot;compress / flate&quot;을 가져올 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="9b53ffb7fd51347180d120a25b5986ecdfdf8a40" translate="yes" xml:space="preserve">
          <source>These constants are copied from the flate package, so that code that imports &quot;compress/zlib&quot; does not also have to import &quot;compress/flate&quot;.</source>
          <target state="translated">이러한 상수는 flate 패키지에서 복사되므로 &quot;compress / zlib&quot;를 가져 오는 코드도 &quot;compress / flate&quot;을 가져올 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="a6caaf07cd62c3bce0c1d44802c32e939959f7c6" translate="yes" xml:space="preserve">
          <source>These constants cause FlagSet.Parse to behave as described if the parse fails.</source>
          <target state="translated">이러한 상수로 인해 구문 분석이 실패하면 FlagSet.Parse가 설명 된대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="c3e135e518f3071cd6e6de5ee8eb8509897ca8e4" translate="yes" xml:space="preserve">
          <source>These constants define supported rounding modes.</source>
          <target state="translated">이 상수는 지원되는 반올림 모드를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="e9b81d06567b4f6ea4a134b77b7d8d68b11092d0" translate="yes" xml:space="preserve">
          <source>These examples demonstrate the basics of printing using a format string. Printf, Sprintf, and Fprintf all take a format string that specifies how to format the subsequent arguments. For example, %d (we call that a 'verb') says to print the corresponding argument, which must be an integer (or something containing an integer, such as a slice of ints) in decimal. The verb %v ('v' for 'value') always formats the argument in its default form, just how Print or Println would show it. The special verb %T ('T' for 'Type') prints the type of the argument rather than its value. The examples are not exhaustive; see the package comment for all the details.</source>
          <target state="translated">이 예는 형식 문자열을 사용한 인쇄 기본 사항을 보여줍니다. Printf, Sprintf 및 Fprintf는 모두 후속 인수의 형식을 지정하는 방법을 지정하는 형식 문자열을 사용합니다. 예를 들어, % d ( '동사'라고 함)는 해당 인수를 인쇄하라고 지시합니다.이 인수는 정수 (또는 정수 슬라이스와 같은 정수를 포함하는 것) 여야합니다. 동사 % v ( 'value'의 경우 'v')는 항상 Print 또는 Println이 표시하는 방식과 같이 기본 형식으로 인수를 형식화합니다. 특수 동사 % T ( 'Type'의 경우 'T')는 값이 아닌 인수의 유형을 인쇄합니다. 예제는 완전하지 않습니다. 자세한 내용은 패키지 주석을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1b31c3c54ac0eb3ff04d00595a12fb566e8fcf7e" translate="yes" xml:space="preserve">
          <source>These flags define which text to prefix to each log entry generated by the Logger. Bits are or'ed together to control what's printed. There is no control over the order they appear (the order listed here) or the format they present (as described in the comments). The prefix is followed by a colon only when Llongfile or Lshortfile is specified. For example, flags Ldate | Ltime (or LstdFlags) produce,</source>
          <target state="translated">이 플래그는 로거에 의해 생성 된 각 로그 항목 앞에 붙일 텍스트를 정의합니다. 비트는 인쇄되는 것을 제어하기 위해 함께 또는 결합됩니다. 표시되는 순서 (여기에 나열된 순서) 또는 표시되는 형식 (주석에 설명 된대로)은 제어 할 수 없습니다. 접 두부 뒤에는 Llongfile 또는 Lshortfile이 지정된 경우에만 콜론이옵니다. 예를 들어, 플래그 Ldate | Ltime (또는 LstdFlags)은</target>
        </trans-unit>
        <trans-unit id="eab8374633319fa49ea516b7b757172cc6a3ee35" translate="yes" xml:space="preserve">
          <source>These flags define which text to prefix to each log entry generated by the Logger. Bits are or'ed together to control what's printed. With the exception of the Lmsgprefix flag, there is no control over the order they appear (the order listed here) or the format they present (as described in the comments). The prefix is followed by a colon only when Llongfile or Lshortfile is specified. For example, flags Ldate | Ltime (or LstdFlags) produce,</source>
          <target state="translated">이러한 플래그는 Logger가 생성 한 각 로그 항목에 접두사로 지정할 텍스트를 정의합니다. 인쇄되는 내용을 제어하기 위해 비트가 함께 또는 결합됩니다. Lmsgprefix 플래그를 제외하고 표시되는 순서 (여기에 나열된 순서) 또는 표시되는 형식 (주석에 설명 된대로)에 대한 제어가 없습니다. 접두사 뒤에는 Llongfile 또는 Lshortfile이 지정된 경우에만 콜론이옵니다. 예를 들어, 플래그 Ldate | Ltime (또는 LstdFlags)은</target>
        </trans-unit>
        <trans-unit id="fc9914d5780e96c178ba8969a057705144577da8" translate="yes" xml:space="preserve">
          <source>These functions are also compatible with the &amp;ldquo;Ed25519&amp;rdquo; function defined in RFC 8032. However, unlike RFC 8032's formulation, this package's private key representation includes a public key suffix to make multiple signing operations with the same key more efficient. This package refers to the RFC 8032 private key as the &amp;ldquo;seed&amp;rdquo;.</source>
          <target state="translated">이러한 기능은 RFC 8032에 정의 된 &quot;Ed25519&quot;기능과도 호환됩니다. 그러나 RFC 8032의 공식과 달리이 패키지의 개인 키 표현에는 공개 키 접미사가 포함되어있어 동일한 키로 여러 서명 작업을보다 효율적으로 수행 할 수 있습니다. 이 패키지는 RFC 8032 개인 키를 &quot;시드&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="2034a99a91b57c3247261a1a8004621e6e0c4e1f" translate="yes" xml:space="preserve">
          <source>These functions require great care to be used correctly. Except for special, low-level applications, synchronization is better done with channels or the facilities of the sync package. Share memory by communicating; don't communicate by sharing memory.</source>
          <target state="translated">이러한 기능을 올바르게 사용하려면 세심한주의가 필요합니다. 특수한 저수준 응용 프로그램을 제외하고 동기화 패키지의 채널 또는 기능을 사용하여 동기화하는 것이 좋습니다. 통신하여 메모리를 공유하십시오. 메모리를 공유하여 통신하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="54aa9a67852a83f3350017dd1b9500c555360772" translate="yes" xml:space="preserve">
          <source>These packages are part of the Go Project but outside the main Go tree. They are developed under looser &lt;a href=&quot;https://golang.org/doc/go1compat&quot;&gt;compatibility requirements&lt;/a&gt; than the Go core. Install them with &quot;&lt;a href=&quot;https://golang.org/cmd/go/#hdr-Download_and_install_packages_and_dependencies&quot;&gt;go get&lt;/a&gt;&quot;.</source>
          <target state="translated">이 패키지는 Go 프로젝트의 일부이지만 기본 Go 트리 외부에 있습니다. Go 코어 보다 &lt;a href=&quot;https://golang.org/doc/go1compat&quot;&gt;호환성 요구 사항&lt;/a&gt; 이 더 낮은 환경에서 개발되었습니다 . &quot; &lt;a href=&quot;https://golang.org/cmd/go/#hdr-Download_and_install_packages_and_dependencies&quot;&gt;go get&lt;/a&gt; &quot;으로 설치하십시오 .</target>
        </trans-unit>
        <trans-unit id="07168c583c59c9cae9d4bb3facc94a52fb2a21e9" translate="yes" xml:space="preserve">
          <source>These predefined profiles maintain themselves and panic on an explicit Add or Remove method call.</source>
          <target state="translated">이러한 사전 정의 된 프로파일은 명시 적 Add 또는 Remove 메소드 호출에서 자체적으로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="8dc4875980e26530686b9e8a46a4183aeaf7943d" translate="yes" xml:space="preserve">
          <source>These services can help you find Open Source packages provided by the community.</source>
          <target state="translated">이러한 서비스를 통해 커뮤니티에서 제공하는 오픈 소스 패키지를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ba17173fd7e73d9151d0d7cdef890f5dd3a0a3f" translate="yes" xml:space="preserve">
          <source>These three formatting routines call the Qualifier for each package-level object O, and if the Qualifier returns a non-empty string p, the object is printed in the form p.O. If it returns an empty string, only the object name O is printed.</source>
          <target state="translated">이 세 가지 형식 지정 루틴은 각 패키지 수준 개체 O에 대해 한정자를 호출하고 한정자가 비어 있지 않은 문자열 p를 반환하면 개체는 pO 형식으로 인쇄됩니다. 빈 문자열을 반환하면 개체 이름 O 만 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="2207cae6c61d669eed106af825a6dce66aef87d1" translate="yes" xml:space="preserve">
          <source>These variables have type *RangeTable.</source>
          <target state="translated">이 변수에는 * RangeTable 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="610a8603a5a8aeac74a533f57b0c5eb7122b7d43" translate="yes" xml:space="preserve">
          <source>This cannot be done concurrent to other receives from the Timer's channel or other calls to the Timer's Stop method.</source>
          <target state="translated">이것은 Timer의 채널로부터의 다른 수신이나 Timer의 Stop 메서드에 대한 다른 호출과 동시에 수행 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1166cbd43d7ca0f544abde3cc256ae8afc9cd0b1" translate="yes" xml:space="preserve">
          <source>This cannot be done concurrent to other receives from the Timer's channel.</source>
          <target state="translated">이것은 타이머 채널에서 다른 수신과 동시에 수행 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b00ff4b1fd4c120a5db60ce99d175dd291630987" translate="yes" xml:space="preserve">
          <source>This declares an integer flag, -flagname, stored in the pointer ip, with type *int.</source>
          <target state="translated">이것은 * int 유형으로 포인터 ip에 저장된 정수 플래그 -flagname을 선언합니다.</target>
        </trans-unit>
        <trans-unit id="f1681bf43fc257c44b551cfb0077dc2be75b4283" translate="yes" xml:space="preserve">
          <source>This declares an integer flag, -n, stored in the pointer nFlag, with type *int:</source>
          <target state="translated">이것은 * int 유형으로 포인터 nFlag에 저장된 정수 플래그, -n을 선언합니다.</target>
        </trans-unit>
        <trans-unit id="631f1841cf17bb7db8a22b0767e5099ebe5b8b09" translate="yes" xml:space="preserve">
          <source>This defines two templates, T1 and T2, and a third T3 that invokes the other two when it is executed. Finally it invokes T3. If executed this template will produce the text</source>
          <target state="translated">이것은 T1과 T2의 두 템플릿과 다른 두 템플릿이 실행될 때 호출하는 세 번째 T3을 정의합니다. 마지막으로 T3을 호출합니다. 이 템플릿을 실행하면 텍스트가 생성됩니다</target>
        </trans-unit>
        <trans-unit id="07be652fe77b2bc1e633b76695cc662deba999dd" translate="yes" xml:space="preserve">
          <source>This example creates a PriorityQueue with some items, adds and manipulates an item, and then removes the items in priority order.</source>
          <target state="translated">이 예에서는 일부 항목으로 PriorityQueue를 작성하고 항목을 추가 및 조작 한 다음 우선 순위에 따라 항목을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="11e8e47e8373159f24438e9584e5f85d6b5441f2" translate="yes" xml:space="preserve">
          <source>This example demonstrates a custom function to process template text. It installs the strings.Title function and uses it to Make Title Text Look Good In Our Template's Output.</source>
          <target state="translated">이 예제는 템플릿 텍스트를 처리하는 사용자 정의 함수를 보여줍니다. 제목 기능을 설치하고 템플릿의 출력에서 ​​제목 텍스트를보기 좋게 만드는 데 사용합니다.</target>
        </trans-unit>
        <trans-unit id="dfa54d108334a66ba7ab5757d71b4364db5ae271" translate="yes" xml:space="preserve">
          <source>This example demonstrates how a value can be passed to the context and also how to retrieve it if it exists.</source>
          <target state="translated">이 예제는 값을 컨텍스트에 전달하는 방법과 값이있는 경우이를 검색하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="cbed8edb3aa3c802bdc2c523c3a0a851457324e3" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to inspect the AST of a Go program.</source>
          <target state="translated">이 예는 Go 프로그램의 AST를 검사하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="165d3019bf668cef6d1995c8165503ac097763bd" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to use big.Int to compute the smallest Fibonacci number with 100 decimal digits and to test whether it is prime.</source>
          <target state="translated">이 예는 big.Int를 사용하여 10 진수 100으로 가장 작은 피보나치 수를 계산하고 소수인지 테스트하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="0059484fefd6cd0e894a9be3837a0c3c538eda17" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to use big.Rat to compute the first 15 terms in the sequence of rational convergents for the constant e (base of natural logarithm).</source>
          <target state="translated">이 예는 big.Rat을 사용하여 상수 e (자연 로그의 밑수)에 대한 합리적인 수렴 시퀀스에서 처음 15 개의 항을 계산하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b29080504869eb07c938bd169b02dbf661e6a627" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to use one group of driver templates with distinct sets of helper templates.</source>
          <target state="translated">이 예는 고유 한 도우미 템플릿 집합과 함께 하나의 드라이버 템플릿 그룹을 사용하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="ba0650f40679135f634bca363681740adeafe34a" translate="yes" xml:space="preserve">
          <source>This example demonstrates one way to share some templates and use them in different contexts. In this variant we add multiple driver templates by hand to an existing bundle of templates.</source>
          <target state="translated">이 예제는 일부 템플릿을 공유하고 다른 컨텍스트에서 사용하는 한 가지 방법을 보여줍니다. 이 변형에서는 기존 템플릿 번들에 여러 드라이버 템플릿을 직접 추가합니다.</target>
        </trans-unit>
        <trans-unit id="0ba078883e861f3b147ecf053f6c06d8a3174cd3" translate="yes" xml:space="preserve">
          <source>This example demonstrates searching a list sorted in ascending order.</source>
          <target state="translated">이 예는 오름차순으로 정렬 된 목록을 검색하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="7888c65ff5bdcbe2c823d7d7283ee2975bf6366b" translate="yes" xml:space="preserve">
          <source>This example demonstrates searching a list sorted in descending order. The approach is the same as searching a list in ascending order, but with the condition inverted.</source>
          <target state="translated">이 예는 내림차순으로 정렬 된 목록을 검색하는 방법을 보여줍니다. 이 방법은 목록을 오름차순으로 검색하는 것과 동일하지만 조건이 반전 된 상태입니다.</target>
        </trans-unit>
        <trans-unit id="2db6a343e7f8129baf91fac5d3ebedf3e8666279" translate="yes" xml:space="preserve">
          <source>This example demonstrates the use of a cancelable context to prevent a goroutine leak. By the end of the example function, the goroutine started by gen will return without leaking.</source>
          <target state="translated">이 예는 고 루틴 누출을 방지하기 위해 취소 가능한 컨텍스트를 사용하는 방법을 보여줍니다. 예제 함수의 끝에서 gen에 의해 시작된 goroutine은 누출없이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="f5ede30ffc3c68340a6fb2445f68975fd1d677b3" translate="yes" xml:space="preserve">
          <source>This example demonstrates unmarshaling an XML excerpt into a value with some preset fields. Note that the Phone field isn't modified and that the XML &amp;lt;Company&amp;gt; element is ignored. Also, the Groups field is assigned considering the element path provided in its tag.</source>
          <target state="translated">이 예제는 미리 설정된 일부 필드를 사용하여 XML 발췌를 마샬링 해제하는 방법을 보여줍니다. 전화 필드는 수정되지 않으며 XML &amp;lt;Company&amp;gt; 요소는 무시됩니다. 또한 그룹 필드는 태그에 제공된 요소 경로를 고려하여 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="363362d5c2e9f91c6b9857ffd69fe714bafa9ced" translate="yes" xml:space="preserve">
          <source>This example fetches several URLs concurrently, using a WaitGroup to block until all the fetches are complete.</source>
          <target state="translated">이 예에서는 모든 가져 오기가 완료 될 때까지 대기 그룹을 사용하여 여러 URL을 동시에 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="06701ebad78061b44ebf3ff359db4a889929ed4c" translate="yes" xml:space="preserve">
          <source>This example illustrates how to remove a variable declaration in a Go program while maintaining correct comment association using an ast.CommentMap.</source>
          <target state="translated">이 예제는 ast.CommentMap을 사용하여 올바른 주석 연관을 유지하면서 Go 프로그램에서 변수 선언을 제거하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="5b8dbce47ef4472e55b03e0ab77f57e1bbd03498" translate="yes" xml:space="preserve">
          <source>This example illustrates how to use NewFromFiles to compute package documentation with examples.</source>
          <target state="translated">이 예제는 NewFromFiles를 사용하여 예제가있는 패키지 문서를 계산하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="a88fa5b5d7ed0c65b753c3fe2d8b6cdc87e0d250" translate="yes" xml:space="preserve">
          <source>This example inserts several ints into an IntHeap, checks the minimum, and removes them in order of priority.</source>
          <target state="translated">이 예제는 IntHeap에 여러 개의 int를 삽입하고 최소값을 확인한 후 우선 순위에 따라 제거합니다.</target>
        </trans-unit>
        <trans-unit id="6720a93331216084a88085596ce48ea8bc49ea13" translate="yes" xml:space="preserve">
          <source>This example passes a context with a signal to tell a blocking function that it should abandon its work after a signal is received.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e36be68d73234a9e2fb853054688b98fefd0444d" translate="yes" xml:space="preserve">
          <source>This example passes a context with a timeout to tell a blocking function that it should abandon its work after the timeout elapses.</source>
          <target state="translated">이 예는 시간 초과가 발생한 후 작업을 포기해야한다는 차단 기능을 알리기 위해 시간 초과가있는 컨텍스트를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="eac2b4a123d3756695f2f19424362998d49962a1" translate="yes" xml:space="preserve">
          <source>This example passes a context with an arbitrary deadline to tell a blocking function that it should abandon its work as soon as it gets to it.</source>
          <target state="translated">이 예제는 임의의 최종 기한이있는 컨텍스트를 전달하여 차단 기능에 도달하자마자 작업을 포기해야한다는 것을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="df7ace59807aa52b6b44602449d158b9635a420e" translate="yes" xml:space="preserve">
          <source>This example reads 10 cryptographically secure pseudorandom numbers from rand.Reader and writes them to a byte slice.</source>
          <target state="translated">이 예제는 rand.Reader에서 암호로 안전한 10 개의 의사 난수를 읽고 바이트 슬라이스에 씁니다.</target>
        </trans-unit>
        <trans-unit id="d0f63cae6959df0e63ff45ed07152e8d354e9432" translate="yes" xml:space="preserve">
          <source>This example shows how csv.Reader can be configured to handle other types of CSV files.</source>
          <target state="translated">이 예는 다른 유형의 CSV 파일을 처리하도록 csv.Reader를 구성하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="1cca172f7759e3ba0050255d1746af87f660b76a" translate="yes" xml:space="preserve">
          <source>This example shows how to encode an interface value. The key distinction from regular types is to register the concrete type that implements the interface.</source>
          <target state="translated">이 예제는 인터페이스 값을 인코딩하는 방법을 보여줍니다. 일반 유형과의 주요 차이점은 인터페이스를 구현하는 구체적 유형을 등록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a3357a230dfc48b693b3b94d9c6611698fcf1171" translate="yes" xml:space="preserve">
          <source>This example shows how to use big.Float to compute the square root of 2 with a precision of 200 bits, and how to print the result as a decimal number.</source>
          <target state="translated">이 예제는 big.Float를 사용하여 정밀도 200 비트로 2의 제곱근을 계산하는 방법과 결과를 10 진수로 인쇄하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="efe429413e771069e2a76db974f921ef42dbdd60" translate="yes" xml:space="preserve">
          <source>This example shows the basic usage of the package: Create an encoder, transmit some values, receive them with a decoder.</source>
          <target state="translated">이 예제는 패키지의 기본 사용법을 보여줍니다. 인코더를 생성하고, 일부 값을 전송하고, 디코더로이를 수신합니다.</target>
        </trans-unit>
        <trans-unit id="4e20892924831ca17c2f745e5365e20b64d74b0e" translate="yes" xml:space="preserve">
          <source>This example shows the use of each of the methods on a *Rand. The use of the global functions is the same, without the receiver.</source>
          <target state="translated">이 예는 * Rand에서 각 메소드의 사용을 보여줍니다. 전역 기능의 사용은 수신자없이 동일합니다.</target>
        </trans-unit>
        <trans-unit id="9dae51dea551843f94a869c5f0aec8bf68e765cc" translate="yes" xml:space="preserve">
          <source>This example shows what an AST looks like when printed for debugging.</source>
          <target state="translated">이 예는 디버깅을 위해 인쇄 할 때 AST의 모습을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="3d4d87b6b74c64cd8a077a3429d1b650786c492b" translate="yes" xml:space="preserve">
          <source>This example transmits a value that implements the custom encoding and decoding methods.</source>
          <target state="translated">이 예제는 사용자 정의 인코딩 및 디코딩 방법을 구현하는 값을 전송합니다.</target>
        </trans-unit>
        <trans-unit id="5ad4aea6278dc849132cadb70003c4716078bb1f" translate="yes" xml:space="preserve">
          <source>This example uses RawMessage to delay parsing part of a JSON message.</source>
          <target state="translated">이 예제는 RawMessage를 사용하여 JSON 메시지의 구문 분석 부분을 지연시킵니다.</target>
        </trans-unit>
        <trans-unit id="f3c7cd2790bc702e1c4e8248c880538aa9480232" translate="yes" xml:space="preserve">
          <source>This example uses RawMessage to use a precomputed JSON during marshal.</source>
          <target state="translated">이 예제는 RawMessage를 사용하여 마샬링 중에 사전 계산 된 JSON을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0980067335654187fe3f7c133925d1affa51d747" translate="yes" xml:space="preserve">
          <source>This example uses a Decoder to decode a stream of distinct JSON values.</source>
          <target state="translated">이 예제는 디코더를 사용하여 고유 한 JSON 값의 스트림을 디코딩합니다.</target>
        </trans-unit>
        <trans-unit id="03fbac2b83cd3991555ff62920bdc91549cc27eb" translate="yes" xml:space="preserve">
          <source>This example uses a Decoder to decode a streaming array of JSON objects.</source>
          <target state="translated">이 예제는 디코더를 사용하여 JSON 객체의 스트리밍 배열을 디코딩합니다.</target>
        </trans-unit>
        <trans-unit id="f5365f6fa06883e90b95f7b5b17bc92e07aa1a04" translate="yes" xml:space="preserve">
          <source>This function is deterministic. Thus, if the set of possible messages is small, an attacker may be able to build a map from messages to signatures and identify the signed messages. As ever, signatures provide authenticity, not confidentiality.</source>
          <target state="translated">이 기능은 결정적입니다. 따라서 가능한 메시지 집합이 작 으면 공격자가 메시지에서 서명으로 맵을 작성하고 서명 된 메시지를 식별 할 수 있습니다. 그 어느 때보 다 서명은 기밀이 아닌 진정성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fd018c9debfe4b296d2cfc4264240cd8fd943b8a" translate="yes" xml:space="preserve">
          <source>This function predates errors.Is, and the notion of whether an error indicates a timeout can be ambiguous. For example, the Unix error EWOULDBLOCK sometimes indicates a timeout and sometimes does not. New code should use errors.Is with a value appropriate to the call returning the error, such as os.ErrDeadlineExceeded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b76ff62ea1ae6e83678ff4ff974ab310fb4c608" translate="yes" xml:space="preserve">
          <source>This function predates errors.Is. It only supports errors returned by the os package. New code should use errors.Is(err, os.ErrExist).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ac909599248ff292672881014f89872aa8e2750" translate="yes" xml:space="preserve">
          <source>This function predates errors.Is. It only supports errors returned by the os package. New code should use errors.Is(err, os.ErrNotExist).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4065f7f0b0bbe706f58a16388dc6fed510ded429" translate="yes" xml:space="preserve">
          <source>This function predates errors.Is. It only supports errors returned by the os package. New code should use errors.Is(err, os.ErrPermission).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d0f1a75b2c9ccfa817de559e09c94b8dbca3151" translate="yes" xml:space="preserve">
          <source>This function will call x509.ParseCertificate unless c.Leaf is set, which can incur a significant performance cost.</source>
          <target state="translated">이 함수는 c.Leaf가 설정되어 있지 않으면 x509.ParseCertificate를 호출하여 상당한 성능 비용이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21dc4eae53c9012a7d2a049dd7f00db6a6938f5b" translate="yes" xml:space="preserve">
          <source>This function's execution time does not depend on the inputs.</source>
          <target state="translated">이 기능의 실행 시간은 입력에 의존하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="87202fef0c6c5ae187b02620dfd26b630d0392d4" translate="yes" xml:space="preserve">
          <source>This functionality should only be used with legacy web sites. RFC 2396 warns that interpreting Userinfo this way &amp;ldquo;is NOT RECOMMENDED, because the passing of authentication information in clear text (such as URI) has proven to be a security risk in almost every case where it has been used.&amp;rdquo;</source>
          <target state="translated">이 기능은 레거시 웹 사이트에서만 사용해야합니다. RFC 2396은 Userinfo를 이런 방식으로 해석하는 것은 &quot;권장되지 않습니다. 일반 텍스트 (예 : URI)로 인증 정보를 전달하는 것은 거의 모든 경우에 보안 위험으로 판명 되었기 때문입니다.&quot;</target>
        </trans-unit>
        <trans-unit id="898688304c78e7f2468d53e47407efc6f38af32f" translate="yes" xml:space="preserve">
          <source>This implementation derives the nonce from an AES-CTR CSPRNG keyed by ChopMD(256, SHA2-512(priv.D || entropy || hash)). The CSPRNG key is IRO by a result of Coron; the AES-CTR stream is IRO under standard assumptions.</source>
          <target state="translated">이 구현은 ChopMD (256, SHA2-512 (priv.D || entropy || hash))가 입력 한 AES-CTR CSPRNG에서 nonce를 파생합니다. CSPRNG 키는 Coron의 결과로 IRO입니다. AES-CTR 스트림은 표준 가정 하에서 IRO입니다.</target>
        </trans-unit>
        <trans-unit id="689c9dd99bb5162e68a9aedd41062dfeb2de0804" translate="yes" xml:space="preserve">
          <source>This implementation derives the nonce from an AES-CTR CSPRNG keyed by:</source>
          <target state="translated">이 구현은 다음에 의해 입력 된 AES-CTR CSPRNG에서 임시 값을 파생합니다.</target>
        </trans-unit>
        <trans-unit id="b4c1ec8dd63ceb69c820647454432eed0e8ec308" translate="yes" xml:space="preserve">
          <source>This interface predates the fs.FS interface, which can be used instead: the FS adapter function converts an fs.FS to a FileSystem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d67c9b0649198706841943ee7eba2049c49bcdb3" translate="yes" xml:space="preserve">
          <source>This is handled as if &quot;my:data-href&quot; was just &quot;data-href&quot; and not &quot;href&quot; as it would be if the &quot;data-&quot; prefix were to be ignored too. Thus at parse time this becomes just</source>
          <target state="translated">&quot;my : data-href&quot;가 &quot;data-&quot;접두어도 무시되는 경우처럼 &quot;href&quot;가 아니라 &quot;data-href&quot;인 것처럼 처리됩니다. 따라서 구문 분석 시간에 이것은</target>
        </trans-unit>
        <trans-unit id="d2d5c7329f986ca3d31bfdba2057014f5f44ad7d" translate="yes" xml:space="preserve">
          <source>This is only needed to install the handler in a non-standard location.</source>
          <target state="translated">비표준 위치에 핸들러를 설치하는 경우에만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="4726b7b6e93eb25607ca12b6c92e41d048948273" translate="yes" xml:space="preserve">
          <source>This is unnecessary as the next call to WriteHeader or Close will implicitly flush out the file's padding.</source>
          <target state="translated">WriteHeader 또는 Close에 대한 다음 호출이 내재적으로 파일의 패딩을 플러시하므로 이는 불필요합니다.</target>
        </trans-unit>
        <trans-unit id="8eba79d25cd0ac07c169a84af16002b1daff283c" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;EC PRIVATE KEY&quot;.</source>
          <target state="translated">이러한 종류의 키는 일반적으로 &quot;EC PRIVATE KEY&quot;유형의 PEM 블록으로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="eb1b3ed68f800415903edd6e38e6c00b58c4b66a" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;EC PRIVATE KEY&quot;. For a more flexible key format which is not EC specific, use MarshalPKCS8PrivateKey.</source>
          <target state="translated">이러한 종류의 키는 일반적으로 &quot;EC PRIVATE KEY&quot;유형의 PEM 블록으로 인코딩됩니다. EC 고유가 아닌보다 유연한 키 형식을 사용하려면 MarshalPKCS8PrivateKey를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="56bef0ed59f36389d7550a0e4c48802187b81f7d" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;EC PUBLIC KEY&quot;.</source>
          <target state="translated">이러한 종류의 키는 일반적으로 &quot;EC PUBLIC KEY&quot;유형의 PEM 블록으로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="dfe352de6a0131091f458f18e937a358eab3152e" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;PRIVATE KEY&quot;.</source>
          <target state="translated">이러한 종류의 키는 일반적으로 &quot;PRIVATE KEY&quot;유형의 PEM 블록으로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="42db7a056c64d4d64e474ea59fd1650377d9bc54" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;PUBLIC KEY&quot;.</source>
          <target state="translated">이러한 종류의 키는 일반적으로 &quot;PUBLIC KEY&quot;유형의 PEM 블록으로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="64ab07dfb34f7d2feff364506aca7067a4453b39" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;RSA PRIVATE KEY&quot;.</source>
          <target state="translated">이러한 종류의 키는 일반적으로 &quot;RSA PRIVATE KEY&quot;유형의 PEM 블록으로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="98a803d28f3224bf7891d32a0db324db326e4afd" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;RSA PRIVATE KEY&quot;. For a more flexible key format which is not RSA specific, use MarshalPKCS8PrivateKey.</source>
          <target state="translated">이러한 종류의 키는 일반적으로 &quot;RSA PRIVATE KEY&quot;유형의 PEM 블록으로 인코딩됩니다. RSA가 아닌보다 유연한 키 형식을 사용하려면 MarshalPKCS8PrivateKey를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5d8222cc13301829f5dbdc649eec16abab7d33d6" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;RSA PUBLIC KEY&quot;.</source>
          <target state="translated">이러한 종류의 키는 일반적으로 &quot;RSA PUBLIC KEY&quot;유형의 PEM 블록으로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="67c7b63689264a63777784c1588c7be8f2ebeb83" translate="yes" xml:space="preserve">
          <source>This means that, by default, command line programs will behave like typical Unix command line programs, while other programs will not crash with SIGPIPE when writing to a closed network connection.</source>
          <target state="translated">즉, 기본적으로 명령 줄 프로그램은 일반적인 Unix 명령 줄 프로그램처럼 작동하지만 다른 프로그램은 닫힌 네트워크 연결에 쓸 때 SIGPIPE와 충돌하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="53c41745078961e0cbeedf1ad29b01ea99fe7434" translate="yes" xml:space="preserve">
          <source>This mechanism can be used to cancel long operations on the server if the client has disconnected before the response is ready.</source>
          <target state="translated">응답이 준비되기 전에 클라이언트 연결이 끊어진 경우이 메커니즘을 사용하여 서버에서 긴 작업을 취소 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3191056acdbdc6fd1ca936f76914f75eb4f8098" translate="yes" xml:space="preserve">
          <source>This mechanism is intended only for trailers that are not known prior to the headers being written. If the set of trailers is fixed or known before the header is written, the normal Go trailers mechanism is preferred:</source>
          <target state="translated">이 메커니즘은 헤더를 작성하기 전에 알려지지 않은 예고편에만 사용됩니다. 예고편 세트가 고정되거나 헤더가 작성되기 전에 알려진 경우 일반적인 Go 예고편 메커니즘이 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="34dfd520d192c4e8193a79a528c0369751354149" translate="yes" xml:space="preserve">
          <source>This method consults the following fields of the response r:</source>
          <target state="translated">이 방법은 응답 r의 다음 필드를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="6857cb2d00e6efa4c19dc849fe5f85bb657fb149" translate="yes" xml:space="preserve">
          <source>This method implements crypto.Signer, which is an interface to support keys where the private part is kept in, for example, a hardware module. Common uses should use the Sign function in this package directly.</source>
          <target state="translated">이 방법은 crypto.Signer를 구현하는데, 이는 개인 부품이 보관되는 키 (예 : 하드웨어 모듈)를 지원하는 인터페이스입니다. 일반적인 용도는이 패키지의 Sign 기능을 직접 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="dca73678d958fc56a6644aad153e6b5ae346adb8" translate="yes" xml:space="preserve">
          <source>This method implements crypto.Signer, which is an interface to support keys where the private part is kept in, for example, a hardware module. Common uses should use the Sign* functions in this package directly.</source>
          <target state="translated">이 방법은 crypto.Signer를 구현하는데, 이는 개인 부품이 보관되는 키 (예 : 하드웨어 모듈)를 지원하는 인터페이스입니다. 일반적인 용도는이 패키지의 Sign * 기능을 직접 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="6162e9fff452fe7b81839fc43d5a9b956682d1db" translate="yes" xml:space="preserve">
          <source>This package assumes that template authors are trusted, that Execute's data parameter is not, and seeks to preserve the properties below in the face of untrusted data:</source>
          <target state="translated">이 패키지는 템플릿 작성자가 신뢰할 수 있고 Execute의 data 매개 변수가 신뢰할 수 없다고 가정하고 신뢰할 수없는 데이터에 직면하여 아래 속성을 유지하려고합니다.</target>
        </trans-unit>
        <trans-unit id="646741784bedcfbc50f393efbc21b4c2b803f33a" translate="yes" xml:space="preserve">
          <source>This package does not guarantee bit-identical results across architectures.</source>
          <target state="translated">이 패키지는 여러 아키텍처에서 동일한 결과를 보장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="25b183f3fa47240bd162a6084ce81041d00db47f" translate="yes" xml:space="preserve">
          <source>This package does not support disk spanning.</source>
          <target state="translated">이 패키지는 디스크 스패닝을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="917226455af3a3e84812552f61aaf5f000d19a66" translate="yes" xml:space="preserve">
          <source>This package favors simplicity over efficiency. Clients that require high-performance serialization, especially for large data structures, should look at more advanced solutions such as the encoding/gob package or protocol buffers.</source>
          <target state="translated">이 패키지는 효율성보다 단순성을 선호합니다. 특히 대규모 데이터 구조의 경우 고성능 직렬화가 필요한 클라이언트는 인코딩 / gob 패키지 또는 프로토콜 버퍼와 같은 고급 솔루션을 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="91400ec0be490a039f54a2e8ea4991f07061b72f" translate="yes" xml:space="preserve">
          <source>This package is EXPERIMENTAL. Its current scope is only to allow tests to run, but not yet to provide a comprehensive API for users. It is exempt from the Go compatibility promise.</source>
          <target state="translated">이 패키지는 실험적입니다. 현재 범위는 테스트 실행만을 허용하지만 아직 사용자에게 포괄적 인 API를 제공하지는 않습니다. Go 호환성 약속에서 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="f172ad46509f2996426e887fe6f7f5b737ccb0ba" translate="yes" xml:space="preserve">
          <source>This package is not implemented on NaCl (Native Client).</source>
          <target state="translated">이 패키지는 NaCl (Native Client)에서 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="70b7c3d76332df2a567dd4571a1dd43d36bb3d95" translate="yes" xml:space="preserve">
          <source>This package is not implemented on Plan 9.</source>
          <target state="translated">이 패키지는 플랜 9에서 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="089323f3519ab53b437d7cbe9878efc86f18d94a" translate="yes" xml:space="preserve">
          <source>This package is not implemented on Windows. As the syslog package is frozen, Windows users are encouraged to use a package outside of the standard library. For background, see &lt;a href=&quot;https://golang.org/issue/1108&quot;&gt;https://golang.org/issue/1108&lt;/a&gt;.</source>
          <target state="translated">이 패키지는 Windows에서 구현되지 않습니다. syslog 패키지가 고정되면 Windows 사용자는 표준 라이브러리 외부에서 패키지를 사용하는 것이 좋습니다. 배경은 &lt;a href=&quot;https://golang.org/issue/1108&quot;&gt;https://golang.org/issue/1108을&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="37ad2d1270c390f993e16f89ffda81efa69cc5ba" translate="yes" xml:space="preserve">
          <source>This package parses both the original &amp;ldquo;// +build&amp;rdquo; syntax and the &amp;ldquo;//go:build&amp;rdquo; syntax that will be added in Go 1.17. The parser is being included in Go 1.16 to allow tools that need to process Go 1.17 source code to still be built against the Go 1.16 release. See &lt;a href=&quot;https://golang.org/design/draft-gobuild&quot;&gt;https://golang.org/design/draft-gobuild&lt;/a&gt; for details about the &amp;ldquo;//go:build&amp;rdquo; syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0a342a318c5bf238d0752ca434eaa7de9a66322" translate="yes" xml:space="preserve">
          <source>This package should normally be imported by a program's main package, not by a library. Libraries normally shouldn't decide whether to include the timezone database in a program.</source>
          <target state="translated">이 패키지는 일반적으로 라이브러리가 아닌 프로그램의 기본 패키지에서 가져와야합니다. 라이브러리는 일반적으로 프로그램에 시간대 데이터베이스를 포함할지 여부를 결정하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="6d4fcbbffc8fc9a4336682d220cd948063216551" translate="yes" xml:space="preserve">
          <source>This package supports metrics whose values have a floating-point representation. In order to improve ease-of-use, this package promises to never produce the following classes of floating-point values: NaN, infinity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c28db944fb8406ea70640148283b4f2b07cfe75" translate="yes" xml:space="preserve">
          <source>This package understands HTML, CSS, JavaScript, and URIs. It adds sanitizing functions to each simple action pipeline, so given the excerpt</source>
          <target state="translated">이 패키지는 HTML, CSS, JavaScript 및 URI를 이해합니다. 각 간단한 액션 파이프 라인에 살균 기능을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="df567a8ebe9ff3e3072f56ef8a4b9eaa7e757875" translate="yes" xml:space="preserve">
          <source>This package will be automatically imported if you build with -tags timetzdata.</source>
          <target state="translated">이 패키지는 -tags timetzdata로 빌드하면 자동으로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="63f9c654258649e0fec61304d0149ff6b7e1fac2" translate="yes" xml:space="preserve">
          <source>This package wraps package text/template so you can share its template API to parse and execute HTML templates safely.</source>
          <target state="translated">이 패키지는 패키지 텍스트 / 템플릿을 래핑하여 템플릿 API를 공유하여 HTML 템플릿을 안전하게 구문 분석하고 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="12b81feb5020b97e164b3bd1ab6605720164a33f" translate="yes" xml:space="preserve">
          <source>This palette was used in the Plan 9 Operating System, described at &lt;a href=&quot;https://9p.io/magic/man2html/6/color&quot;&gt;https://9p.io/magic/man2html/6/color&lt;/a&gt;</source>
          <target state="translated">이 팔레트는 &lt;a href=&quot;https://9p.io/magic/man2html/6/color&quot;&gt;https://9p.io/magic/man2html/6/color에&lt;/a&gt; 설명 된 Plan 9 운영 체제에서 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="53f264e60d97dda7c8e598fd892c840f64c77bcb" translate="yes" xml:space="preserve">
          <source>This returns a Writer to which the file contents should be written. The file's contents must be written to the io.Writer before the next call to Create, CreateHeader, or Close.</source>
          <target state="translated">파일 내용을 기록해야 할 라이터를 반환합니다. 다음에 Create, CreateHeader 또는 Close를 호출하기 전에 파일 내용을 io.Writer에 기록해야합니다.</target>
        </trans-unit>
        <trans-unit id="3636f2d8cb7dce3b52ad380d63ea631656bb70da" translate="yes" xml:space="preserve">
          <source>This runtime/trace package provides APIs to add equivalent tracing support to a standalone program. See the Example that demonstrates how to use this API to enable tracing.</source>
          <target state="translated">이 런타임 / 추적 패키지는 독립형 프로그램에 동등한 추적 지원을 추가하기위한 API를 제공합니다. 이 API를 사용하여 추적을 사용하는 방법을 보여주는 예제를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="eb3d7236d288f19d5e07330ec9b641abb7a1c736" translate="yes" xml:space="preserve">
          <source>This section documents the encoding, details that are not important for most users. Details are presented bottom-up.</source>
          <target state="translated">이 섹션에서는 인코딩, 대부분의 사용자에게 중요하지 않은 세부 사항에 대해 설명합니다. 세부 사항은 상향식으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="8d97dde3cffa35e96f0901463ccd21bc2b7e33d2" translate="yes" xml:space="preserve">
          <source>This set may grow. Note that regular expression matches may need to examine text beyond the text returned by a match, so the methods that match text from a RuneReader may read arbitrarily far into the input before returning.</source>
          <target state="translated">이 세트는 커질 수 있습니다. 정규식 일치는 일치에서 반환 된 텍스트 이외의 텍스트를 검사해야 할 수 있으므로 RuneReader의 텍스트와 일치하는 메서드는 반환하기 전에 입력에서 임의로 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13155ea54999e3f67a0c6d8a556ef2fb922860ce" translate="yes" xml:space="preserve">
          <source>This should not be done concurrent to other receives from the Timer's channel.</source>
          <target state="translated">이것은 타이머의 채널로부터 다른 수신과 동시에 수행되어서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="0da770375be11542fa319ca413fcc3ece2b576a4" translate="yes" xml:space="preserve">
          <source>This type should be considered identical to sql.IsolationLevel along with any values defined on it.</source>
          <target state="translated">이 유형은 sql.IsolationLevel과 정의 된 값과 동일한 것으로 간주되어야합니다.</target>
        </trans-unit>
        <trans-unit id="5cefc7416c362c1afcf6c674cc1720ba6d02139f" translate="yes" xml:space="preserve">
          <source>This type should be considered identical to sql.TxOptions.</source>
          <target state="translated">이 유형은 sql.TxOptions와 동일한 것으로 간주되어야합니다.</target>
        </trans-unit>
        <trans-unit id="23bb56893bd9c167f4933bba0f06ea209969209a" translate="yes" xml:space="preserve">
          <source>ThreadCreateProfile returns n, the number of records in the thread creation profile. If len(p) &amp;gt;= n, ThreadCreateProfile copies the profile into p and returns n, true. If len(p) &amp;lt; n, ThreadCreateProfile does not change p and returns n, false.</source>
          <target state="translated">ThreadCreateProfile은 스레드 작성 프로파일의 레코드 수인 n을 리턴합니다. len (p)&amp;gt; = n 인 경우 ThreadCreateProfile은 프로파일을 p에 복사하고 n, true를 리턴합니다. len (p) &amp;lt;n이면 ThreadCreateProfile은 p를 변경하지 않고 n을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="053a6e5ff5756153adf26636a41ad3c9d51f80be" translate="yes" xml:space="preserve">
          <source>Thus, users of this API are encouraged to sample supported metrics defined by the slice returned by All to remain compatible across Go versions. Of course, situations arise where reading specific metrics is critical. For these cases, users are encouraged to use build tags, and although metrics may be deprecated and removed, users should consider this to be an exceptional and rare event, coinciding with a very large change in a particular Go implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeddfe22a01fc0ff5fb0fe691b08db0b2e2a26c7" translate="yes" xml:space="preserve">
          <source>Tick</source>
          <target state="translated">Tick</target>
        </trans-unit>
        <trans-unit id="26c9fc157a3f52de1aca92922ccb9a288e5fa386" translate="yes" xml:space="preserve">
          <source>Tick is a convenience wrapper for NewTicker providing access to the ticking channel only. While Tick is useful for clients that have no need to shut down the Ticker, be aware that without a way to shut it down the underlying Ticker cannot be recovered by the garbage collector; it &quot;leaks&quot;. Unlike NewTicker, Tick will return nil if d &amp;lt;= 0.</source>
          <target state="translated">Tick은 NewTicker의 편의 래퍼로서 티킹 채널에만 액세스 할 수 있습니다. Tick은 Ticker를 종료 할 필요가없는 클라이언트에게 유용하지만,이를 종료 할 수있는 방법이 없으면 기본 Ticker를 가비지 수집기에서 복구 할 수 없습니다. &quot;누설&quot;. NewTicker와 달리 Tick은 d &amp;lt;= 0이면 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="464b9c4863cbad4e03c3166e6a41a020f20219b8" translate="yes" xml:space="preserve">
          <source>Time instants can be compared using the Before, After, and Equal methods. The Sub method subtracts two instants, producing a Duration. The Add method adds a Time and a Duration, producing a Time.</source>
          <target state="translated">Before, After 및 Equal 메서드를 사용하여 시간 인스턴트를 비교할 수 있습니다. Sub 메소드는 두 개의 순간을 빼서 Duration을 생성합니다. Add 메서드는 시간과 지속 시간을 추가하여 시간을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="7e0d5fdb48c2796b9cc511f84f1969b59a9bd1cf" translate="yes" xml:space="preserve">
          <source>Time.Add</source>
          <target state="translated">Time.Add</target>
        </trans-unit>
        <trans-unit id="5c2e779ba4c8677013ab3eb4de9c1e6bf9c9924b" translate="yes" xml:space="preserve">
          <source>Time.AddDate</source>
          <target state="translated">Time.AddDate</target>
        </trans-unit>
        <trans-unit id="730b4aa03b8316a2a6c19e05b72ec5d4eb05e78c" translate="yes" xml:space="preserve">
          <source>Time.After</source>
          <target state="translated">Time.After</target>
        </trans-unit>
        <trans-unit id="d5e86b615c46a18260de62e172d7e06cc20f7083" translate="yes" xml:space="preserve">
          <source>Time.AppendFormat</source>
          <target state="translated">Time.AppendFormat</target>
        </trans-unit>
        <trans-unit id="88be4309d5e0539eff6218d7e8c02ecf0c7b2e65" translate="yes" xml:space="preserve">
          <source>Time.Before</source>
          <target state="translated">Time.Before</target>
        </trans-unit>
        <trans-unit id="480d1c53462d365532b2348e82a3f0dcb963c99e" translate="yes" xml:space="preserve">
          <source>Time.Date</source>
          <target state="translated">Time.Date</target>
        </trans-unit>
        <trans-unit id="ae2638b80e7bdac6e6725adc567cf7badedc6abe" translate="yes" xml:space="preserve">
          <source>Time.Day</source>
          <target state="translated">Time.Day</target>
        </trans-unit>
        <trans-unit id="d4766b7b3328342b5ba1a667334b95afb4c840fd" translate="yes" xml:space="preserve">
          <source>Time.Equal</source>
          <target state="translated">Time.Equal</target>
        </trans-unit>
        <trans-unit id="092fc9098aafde18e6cec288675831ee7d77f8a8" translate="yes" xml:space="preserve">
          <source>Time.Format</source>
          <target state="translated">Time.Format</target>
        </trans-unit>
        <trans-unit id="dd61b8e28117a6a8c31fd714a3696b1193538443" translate="yes" xml:space="preserve">
          <source>Time.Format (Pad)</source>
          <target state="translated">Time.Format (패드)</target>
        </trans-unit>
        <trans-unit id="3768befc26b5bc40a2c6b38ecc6f26a0656a5d40" translate="yes" xml:space="preserve">
          <source>Time.Round</source>
          <target state="translated">Time.Round</target>
        </trans-unit>
        <trans-unit id="5b138a17083c1c36c8bab2fd64e7493a32a70b68" translate="yes" xml:space="preserve">
          <source>Time.String</source>
          <target state="translated">Time.String</target>
        </trans-unit>
        <trans-unit id="e126e45961c85339227ad3c92517287507ec5152" translate="yes" xml:space="preserve">
          <source>Time.Sub</source>
          <target state="translated">Time.Sub</target>
        </trans-unit>
        <trans-unit id="d3f1777c34673ecabb71603383f8d1fd8d6be9c4" translate="yes" xml:space="preserve">
          <source>Time.Truncate</source>
          <target state="translated">Time.Truncate</target>
        </trans-unit>
        <trans-unit id="c4ee117595e7091017dcf807233ec5e3324552ac" translate="yes" xml:space="preserve">
          <source>Time.Unix</source>
          <target state="translated">Time.Unix</target>
        </trans-unit>
        <trans-unit id="f8fc7e6bb582b1829de5a848ff872dea68eff61d" translate="yes" xml:space="preserve">
          <source>TimeFormat is the time format to use when generating times in HTTP headers. It is like time.RFC1123 but hard-codes GMT as the time zone. The time being formatted must be in UTC for Format to generate the correct format.</source>
          <target state="translated">TimeFormat은 HTTP 헤더에서 시간을 생성 할 때 사용하는 시간 형식입니다. RFC1123과 같지만 GMT를 표준 시간대로 하드 코딩합니다. 형식이 올바른 형식을 생성하려면 형식 시간이 UTC 여야합니다.</target>
        </trans-unit>
        <trans-unit id="9827d1afd02311b970b1c9ab5d2482ee7f917a5d" translate="yes" xml:space="preserve">
          <source>Timeout reports whether the DNS lookup is known to have timed out. This is not always known; a DNS lookup may fail due to a timeout and return a DNSError for which Timeout returns false.</source>
          <target state="translated">시간 초과는 DNS 조회가 시간 초과 된 것으로 알려 진지 여부를보고합니다. 이것이 항상 알려진 것은 아닙니다. 시간 초과로 인해 DNS 조회가 실패하고 시간 초과가 false를 반환하는 DNSError를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="927810e8434679578bc9bf07a4312dbfd80340d4" translate="yes" xml:space="preserve">
          <source>Timeout reports whether this error represents a timeout.</source>
          <target state="translated">시간 초과는이 오류가 시간 초과를 나타내는 지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="e7860bff1be7d01a8121a71b30616b2279f825c3" translate="yes" xml:space="preserve">
          <source>TimeoutHandler returns a Handler that runs h with the given time limit.</source>
          <target state="translated">TimeoutHandler는 주어진 시간 제한으로 h를 실행하는 핸들러를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="41f375b226e7f8e10a9acde2441f73751822f0d4" translate="yes" xml:space="preserve">
          <source>TimeoutHandler supports the Flusher and Pusher interfaces but does not support the Hijacker interface.</source>
          <target state="translated">TimeoutHandler는 Flusher 및 Pusher 인터페이스를 지원하지만 Hijacker 인터페이스는 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="229f8a47d6424d21cc11a27228c5b3dd3021912d" translate="yes" xml:space="preserve">
          <source>TimeoutHandler supports the Pusher interface but does not support the Hijacker or Flusher interfaces.</source>
          <target state="translated">TimeoutHandler는 Pusher 인터페이스를 지원하지만 Hijacker 또는 Flusher 인터페이스는 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b94b20b16ca4b5f916aaa1eb8d24553f8d4b92c2" translate="yes" xml:space="preserve">
          <source>TimeoutReader returns ErrTimeout on the second read with no data. Subsequent calls to read succeed.</source>
          <target state="translated">TimeoutReader는 두 번째 읽기에서 데이터없이 ErrTimeout을 반환합니다. 후속 호출은 성공합니다.</target>
        </trans-unit>
        <trans-unit id="092b95acf2f2e3d735b1b9d6eb619d6f9b285116" translate="yes" xml:space="preserve">
          <source>TimespecToNSec returns the time stored in ts as nanoseconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bdae2bbf616fbfd5c5eefd29c8a537bd886144c" translate="yes" xml:space="preserve">
          <source>TimespecToNsec converts a Timespec value into a number of nanoseconds since the Unix epoch.</source>
          <target state="translated">TimespecToNsec는 Timespec 값을 Unix 시대 이후 수 나노초로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="71641b558817e2a09b865dac9868550ced5db039" translate="yes" xml:space="preserve">
          <source>TimevalToNsec converts a Timeval value into a number of nanoseconds since the Unix epoch.</source>
          <target state="translated">TimevalToNsec은 Timeval 값을 Unix 시대 이후 수 나노초로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="88a226b5c5421dc95c12f9851cda7185d1ebf771" translate="yes" xml:space="preserve">
          <source>TimevalToNsec returns the time stored in tv as nanoseconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="768e0c1c69573fb588f61f1308a015c11468e05f" translate="yes" xml:space="preserve">
          <source>Title</source>
          <target state="translated">Title</target>
        </trans-unit>
        <trans-unit id="ee048df59e1fe3a78061c7c9271c635869379b9b" translate="yes" xml:space="preserve">
          <source>Title returns a copy of the string s with all Unicode letters that begin words mapped to their Unicode title case.</source>
          <target state="translated">Title은 유니 코드 제목 대 / 소문자로 매핑 된 단어를 시작하는 모든 유니 코드 문자가 포함 된 문자열 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="173f12648645a6edd8fcbab7c7ed0369c007806c" translate="yes" xml:space="preserve">
          <source>Title treats s as UTF-8-encoded bytes and returns a copy with all Unicode letters that begin words mapped to their title case.</source>
          <target state="translated">Title은 s를 UTF-8로 인코딩 된 바이트로 취급하고 제목 케이스에 단어를 매핑하는 모든 유니 코드 문자가 포함 된 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ae79ea1e9c6391a9ed83a2e18a031b835feec0c9" translate="yes" xml:space="preserve">
          <source>To</source>
          <target state="translated">To</target>
        </trans-unit>
        <trans-unit id="616d61f65a9f91c650c28db92d9cb8984a1f52bd" translate="yes" xml:space="preserve">
          <source>To add equivalent profiling support to a standalone program, add code like the following to your main function:</source>
          <target state="translated">독립형 프로그램에 동등한 프로파일 링 지원을 추가하려면 다음과 같은 코드를 기본 기능에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="f6f5822190a6e77b3f6e2423fce4abac430f1e8d" translate="yes" xml:space="preserve">
          <source>To avoid denial of service attacks, the provided bufio.Reader should be reading from an io.LimitReader or similar Reader to bound the size of responses.</source>
          <target state="translated">서비스 거부 공격을 피하려면 제공된 bufio.Reader는 io.LimitReader 또는 이와 유사한 Reader에서 응답 크기를 제한해야합니다.</target>
        </trans-unit>
        <trans-unit id="87386ad5a06e96430212748899697cda9d7a3724" translate="yes" xml:space="preserve">
          <source>To avoid recursion in cases such as</source>
          <target state="translated">다음과 같은 경우 재귀를 피하기 위해</target>
        </trans-unit>
        <trans-unit id="a87f0fb7c131221874ae3b0c17104f44ee1c34bc" translate="yes" xml:space="preserve">
          <source>To be backwards compatible the FileHeader has both 32 and 64 bit Size fields. The 64 bit fields will always contain the correct value and for normal archives both fields will be the same. For files requiring the ZIP64 format the 32 bit fields will be 0xffffffff and the 64 bit fields must be used instead.</source>
          <target state="translated">하위 호환성을 위해 FileHeader에는 32 및 64 비트 크기 필드가 있습니다. 64 비트 필드는 항상 올바른 값을 포함하며 일반 아카이브의 경우 두 필드가 동일합니다. ZIP64 형식이 필요한 파일의 경우 32 비트 필드는 0xffffffff이며 64 비트 필드를 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="f0c9c2ba0d3b42114f628f0336b7d63f8138a666" translate="yes" xml:space="preserve">
          <source>To build a file only when using cgo, and only on Linux and OS X:</source>
          <target state="translated">cgo를 사용할 때만 Linux 및 OS X에서만 파일을 빌드하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="b59fa373960766ba2850aeb1bfd6ebb3acccc2d0" translate="yes" xml:space="preserve">
          <source>To build strings more efficiently, see the strings.Builder type.</source>
          <target state="translated">보다 효율적으로 문자열을 작성하려면 strings.Builder 유형을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="65822ab438826bd3303521dc362fbdb7385f9c68" translate="yes" xml:space="preserve">
          <source>To change the destination for flag messages, call CommandLine.SetOutput.</source>
          <target state="translated">플래그 메시지의 대상을 변경하려면 CommandLine.SetOutput을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="697c0150c9b1eec40f18c8aa7919a2878d3bf00a" translate="yes" xml:space="preserve">
          <source>To compare two Values, compare the results of the Interface method. Using == on two Values does not compare the underlying values they represent.</source>
          <target state="translated">두 값을 비교하려면 인터페이스 방법의 결과를 비교하십시오. 두 개의 값에 ==를 사용하면 해당 값이 나타내는 기본 값이 비교되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="26bcf90200ee4c383ef61356b62c1cde915663a4" translate="yes" xml:space="preserve">
          <source>To complete the example above, the following code tries to find the value x in an integer slice data sorted in ascending order:</source>
          <target state="translated">위의 예제를 완료하기 위해 다음 코드는 오름차순으로 정렬 된 정수 슬라이스 데이터에서 x 값을 찾으려고합니다.</target>
        </trans-unit>
        <trans-unit id="48862e3dd334f932c3f29aca76cb78295d40632d" translate="yes" xml:space="preserve">
          <source>To compute the number of allocations, the function will first be run once as a warm-up. The average number of allocations over the specified number of runs will then be measured and returned.</source>
          <target state="translated">할당 수를 계산하기 위해이 기능은 먼저 예열로 한 번 실행됩니다. 그런 다음 지정된 실행 횟수에 대한 평균 할당 수를 측정하여 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a1b4d9690ab97f466c6d326d8c742f5be1f15108" translate="yes" xml:space="preserve">
          <source>To convert an integer number of units to a Duration, multiply:</source>
          <target state="translated">정수의 단위를 Duration으로 변환하려면 다음을 곱하십시오.</target>
        </trans-unit>
        <trans-unit id="c70ea98cf5f708e17c34d681b2e9583414cbfaae" translate="yes" xml:space="preserve">
          <source>To count the number of units in a Duration, divide:</source>
          <target state="translated">지속 시간의 단위 수를 계산하려면 다음을 나누십시오.</target>
        </trans-unit>
        <trans-unit id="a8a481566ee5c9f4011b251f076b7cff25d2b336" translate="yes" xml:space="preserve">
          <source>To create a new request with a context, use NewRequestWithContext. To change the context of a request (such as an incoming) you then also want to modify to send back out, use Request.Clone. Between those two uses, it's rare to need WithContext.</source>
          <target state="translated">컨텍스트를 사용하여 새 요청을 작성하려면 NewRequestWithContext를 사용하십시오. 요청 컨텍스트 (예 : 수신)를 변경 한 후 다시 보내도록 수정하려면 Request.Clone을 사용하십시오. 이 두 가지 용도 사이에 WithContext가 필요한 경우는 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="df17ef73a333723433e10a65752b7d97c8d742ec" translate="yes" xml:space="preserve">
          <source>To create a new request with a context, use NewRequestWithContext. To change the context of a request, such as an incoming request you want to modify before sending back out, use Request.Clone. Between those two uses, it's rare to need WithContext.</source>
          <target state="translated">컨텍스트가있는 새 요청을 생성하려면 NewRequestWithContext를 사용합니다. 다시 보내기 전에 수정하려는 수신 요청과 같은 요청의 컨텍스트를 변경하려면 Request.Clone을 사용하십시오. 이 두 가지 용도 사이에 WithContext가 필요한 경우는 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="d1ce4e028f3adf6fe5e3e3ea8b7a3ce1d7c4cce0" translate="yes" xml:space="preserve">
          <source>To create the Pos value for a specific source offset (measured in bytes), first add the respective file to the current file set using FileSet.AddFile and then call File.Pos(offset) for that file. Given a Pos value p for a specific file set fset, the corresponding Position value is obtained by calling fset.Position(p).</source>
          <target state="translated">바이트 단위로 측정 된 특정 소스 오프셋에 대한 Pos 값을 만들려면 먼저 FileSet.AddFile을 사용하여 각 파일을 현재 파일 세트에 추가 한 다음 해당 파일에 대해 File.Pos (offset)를 호출하십시오. 특정 파일 세트 fset에 대해 Pos 값 p가 주어지면 해당 위치 값은 fset.Position (p)를 호출하여 얻습니다.</target>
        </trans-unit>
        <trans-unit id="ffa6362a850b5571ec14ab520e75aaa3f0b772a0" translate="yes" xml:space="preserve">
          <source>To define a type, the encoder chooses an unused, positive type id and sends the pair (-type id, encoded-type) where encoded-type is the gob encoding of a wireType description, constructed from these types:</source>
          <target state="translated">유형을 정의하기 위해 인코더는 사용되지 않은 양의 유형 ID를 선택하고 pair-type id, encode-type을 전송합니다. 여기서 encoding-type은 다음 유형으로 구성된 wireType 설명의 gob 인코딩입니다.</target>
        </trans-unit>
        <trans-unit id="da43583df08c2ff7e4692ba80d3b2cf801b80a61" translate="yes" xml:space="preserve">
          <source>To define your own format, write down what the reference time would look like formatted your way; see the values of constants like ANSIC, StampMicro or Kitchen for examples. The model is to demonstrate what the reference time looks like so that the Format and Parse methods can apply the same transformation to a general time value.</source>
          <target state="translated">자신의 형식을 정의하려면 참조 시간이 형식이 어떻게 표시되는지 기록하십시오. 예제는 ANSIC, StampMicro 또는 Kitchen과 같은 상수 값을 참조하십시오. 이 모델은 Format 및 Parse 메서드가 동일한 변환을 일반 시간 값에 적용 할 수 있도록 참조 시간이 어떻게 보이는지 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="79806cf1eaac70011a5e985d3751306c16fa37ee" translate="yes" xml:space="preserve">
          <source>To distinguish build constraints from package documentation, a series of build constraints must be followed by a blank line.</source>
          <target state="translated">빌드 제한 조건을 패키지 문서와 구별하려면 일련의 빌드 제한 조건 다음에 공백 행이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="a50607887789cbea54ccb0db0c455e312a84417e" translate="yes" xml:space="preserve">
          <source>To ensure the channel is empty after a call to Stop, check the return value and drain the channel. For example, assuming the program has not received from t.C already:</source>
          <target state="translated">Stop 호출 후 채널이 비어 있는지 확인하려면 리턴 값을 확인하고 채널을 비우십시오. 예를 들어, 프로그램이 tC로부터 이미 수신되지 않았다고 가정하면 :</target>
        </trans-unit>
        <trans-unit id="dc7659d0594b1222a7c79baf65726fd2fc8fc92f" translate="yes" xml:space="preserve">
          <source>To escape a text segment, bracket it with Escape characters. For instance, the tab in this string &quot;Ignore this tab: \xff\t\xff&quot; does not terminate a cell and constitutes a single character of width one for formatting purposes.</source>
          <target state="translated">텍스트 세그먼트를 이스케이프하려면 이스케이프 문자로 묶습니다. 예를 들어이 문자열의 탭 &quot;이 탭 무시 : \ xff \ t \ xff&quot;는 셀을 종료하지 않으며 형식화를 위해 하나의 너비 문자를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="a3866d2c65d6d17db1dce0e7ab464336a1186960" translate="yes" xml:space="preserve">
          <source>To force integer division of Int operands, use op == token.QUO_ASSIGN instead of token.QUO; the result is guaranteed to be Int in this case. Division by zero leads to a run-time panic.</source>
          <target state="translated">Int 피연산자의 정수 나누기를 강제하려면 token.QUO 대신 op == token.QUO_ASSIGN을 사용하십시오. 이 경우 결과는 Int입니다. 0으로 나누면 런타임 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="93f96dd1110bc83e45c261305087ab59ccdab5c6" translate="yes" xml:space="preserve">
          <source>To generate HTML output, see package html/template, which has the same interface as this package but automatically secures HTML output against certain attacks.</source>
          <target state="translated">HTML 출력을 생성하려면이 패키지와 인터페이스는 동일하지만 특정 공격에 대해 HTML 출력을 자동으로 보호하는 html / template 패키지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0f37e1016d8b746740d606c5f03bd61a370f62be" translate="yes" xml:space="preserve">
          <source>To generate a client HTTP request instead of a server request, see the NewRequest function in the net/http package.</source>
          <target state="translated">서버 요청 대신 클라이언트 HTTP 요청을 생성하려면 net / http 패키지의 NewRequest 함수를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="06a96f64d7d0f413489f0372ff0c9c5459591c5b" translate="yes" xml:space="preserve">
          <source>To include every allocated block in the profile, set MemProfileRate to 1. To turn off profiling entirely, set MemProfileRate to 0.</source>
          <target state="translated">프로파일에 할당 된 모든 블록을 포함하려면 MemProfileRate를 1로 설정하십시오. 프로파일 링을 완전히 해제하려면 MemProfileRate를 0으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="1cf82e7adf1a06dc5b4204dd8949c669c22a6ce1" translate="yes" xml:space="preserve">
          <source>To include every blocking event in the profile, pass rate = 1. To turn off profiling entirely, pass rate &amp;lt;= 0.</source>
          <target state="translated">프로파일에 모든 차단 이벤트를 포함 시키려면 전달 속도 = 1입니다. 프로파일 링을 완전히 끄려면 전달 속도 &amp;lt;= 0입니다.</target>
        </trans-unit>
        <trans-unit id="5634feb2ac7b66d9d403fa3ba44d3dd35de4aafa" translate="yes" xml:space="preserve">
          <source>To insert a literal $ in the output, use $$ in the template.</source>
          <target state="translated">출력에 리터럴 $를 삽입하려면 템플리트에서 $$를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fc7c25c25b23cfac629203b1f680a734ada8bcd7" translate="yes" xml:space="preserve">
          <source>To iterate over a list (where l is a *List):</source>
          <target state="translated">리스트를 반복하려면 (여기서 l은 * List 임) :</target>
        </trans-unit>
        <trans-unit id="04464b93c140cce60515e90ab741d559641a3b86" translate="yes" xml:space="preserve">
          <source>To keep a file from being considered for the build:</source>
          <target state="translated">빌드에 파일이 고려되지 않도록하려면</target>
        </trans-unit>
        <trans-unit id="b8dd565d2e14c4949f658d07fd948bd6982afd99" translate="yes" xml:space="preserve">
          <source>To make a request with custom headers, use NewRequest and Client.Do.</source>
          <target state="translated">사용자 정의 헤더를 사용하여 요청하려면 NewRequest 및 Client.Do를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5032a2d57ff9e66d730ea600879b156b0a5e02a1" translate="yes" xml:space="preserve">
          <source>To make a request with custom headers, use NewRequest and DefaultClient.Do.</source>
          <target state="translated">사용자 정의 헤더로 요청하려면 NewRequest 및 DefaultClient.Do를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="706ee8ff1d514d4082de19c46038d881341df0b9" translate="yes" xml:space="preserve">
          <source>To maps the rune to the specified case: UpperCase, LowerCase, or TitleCase.</source>
          <target state="translated">룬을 UpperCase, LowerCase 또는 TitleCase와 같이 지정된 케이스에 맵핑합니다.</target>
        </trans-unit>
        <trans-unit id="13858e1fce15a0a8116d4d08d0813cfa32d04dd1" translate="yes" xml:space="preserve">
          <source>To prevent IP spoofing, be sure to delete any pre-existing X-Forwarded-For header coming from the client or an untrusted proxy.</source>
          <target state="translated">IP 스푸핑을 방지하려면 클라이언트 또는 신뢰할 수없는 프록시에서 들어오는 기존 X-Forwarded-For 헤더를 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="16db8fa630b8ed6e5e098c9ecc986852e23449ff" translate="yes" xml:space="preserve">
          <source>To prevent duplicate operations, ErrBadConn should NOT be returned if there's a possibility that the database server might have performed the operation. Even if the server sends back an error, you shouldn't return ErrBadConn.</source>
          <target state="translated">중복 작업을 방지하기 위해 데이터베이스 서버가 작업을 수행했을 가능성이있는 경우 ErrBadConn이 반환되지 않아야합니다. 서버가 오류를 다시 보내더라도 ErrBadConn을 반환해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="367a95ef6b89677c6010e99bfe83911bb6aa0ff5" translate="yes" xml:space="preserve">
          <source>To remove a prefix, use TrimPrefix instead.</source>
          <target state="translated">접두사를 제거하려면 대신 TrimPrefix를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="651b4bc851ab5004fd129e9e0ff7675d7d666cef" translate="yes" xml:space="preserve">
          <source>To remove a suffix, use TrimSuffix instead.</source>
          <target state="translated">접미사를 제거하려면 대신 TrimSuffix를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c83bbc4183fb8f4e0540869ebe8099226ccd8816" translate="yes" xml:space="preserve">
          <source>To set custom headers, use NewRequest and Client.Do.</source>
          <target state="translated">사용자 정의 헤더를 설정하려면 NewRequest 및 Client.Do를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="71135b9f4481c76b2f670b0d39a1f656b3961a0f" translate="yes" xml:space="preserve">
          <source>To set custom headers, use NewRequest and DefaultClient.Do.</source>
          <target state="translated">사용자 정의 헤더를 설정하려면 NewRequest 및 DefaultClient.Do를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="db9b30900d9da4419f81d83d998e553e2dab25bb" translate="yes" xml:space="preserve">
          <source>To support custom data types, implement NamedValueChecker. NamedValueChecker also allows queries to accept per-query options as a parameter by returning ErrRemoveArgument from CheckNamedValue.</source>
          <target state="translated">사용자 정의 데이터 유형을 지원하려면 NamedValueChecker를 구현하십시오. 또한 NamedValueChecker는 CheckNamedValue에서 ErrRemoveArgument를 반환하여 쿼리가 쿼리 별 옵션을 매개 변수로 허용하도록합니다.</target>
        </trans-unit>
        <trans-unit id="9522949e411b2165edb986c411282650712ef336" translate="yes" xml:space="preserve">
          <source>To support tools that analyze Go packages, the patterns found in //go:embed lines are available in &amp;ldquo;go list&amp;rdquo; output. See the EmbedPatterns, TestEmbedPatterns, and XTestEmbedPatterns fields in the &amp;ldquo;go help list&amp;rdquo; output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75e0a568234c8cc832fa169bfc3c25d385870808" translate="yes" xml:space="preserve">
          <source>To translate these PCs into symbolic information such as function names and line numbers, use CallersFrames. CallersFrames accounts for inlined functions and adjusts the return program counters into call program counters. Iterating over the returned slice of PCs directly is discouraged, as is using FuncForPC on any of the returned PCs, since these cannot account for inlining or return program counter adjustment.</source>
          <target state="translated">이러한 PC를 함수 이름 및 줄 번호와 같은 기호 정보로 변환하려면 CallersFrames를 사용하십시오. CallersFrames는 인라인 함수를 설명하고 반환 프로그램 카운터를 호출 프로그램 카운터로 조정합니다. 반환 된 PC 조각을 직접 반복하는 것은 반환 된 PC에서 FuncForPC를 사용하는 것처럼 권장되지 않습니다. 이는 인라인 또는 반환 프로그램 카운터 조정을 고려할 수 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="83002d8cdc0fe4d874cff59ee6e149e3669f91df" translate="yes" xml:space="preserve">
          <source>To translate these PCs into symbolic information such as function names and line numbers, use CallersFrames. CallersFrames accounts for inlined functions and adjusts the return program counters into call program counters. Iterating over the returned slice of PCs directly is discouraged, as is using FuncForPC on any of the returned PCs, since these cannot account for inlining or return program counter adjustment. go:noinline</source>
          <target state="translated">이러한 PC를 기능 이름 및 행 번호와 같은 기호 정보로 변환하려면 CallersFrames를 사용하십시오. CallersFrames는 인라인 된 기능을 설명하고 리턴 프로그램 카운터를 호출 프로그램 카운터로 조정합니다. 반환 된 PC 슬라이스를 직접 반복하는 것은 반환 된 PC 중 하나에서 FuncForPC를 사용하는 것과 같이 인라인 또는 리턴 프로그램 카운터 조정을 설명 할 수 없으므로 권장하지 않습니다. go : noinline</target>
        </trans-unit>
        <trans-unit id="3b553336a2ed0371927e0210cc490999d6f454c6" translate="yes" xml:space="preserve">
          <source>To turn off profiling entirely, pass rate 0. To just read the current rate, pass rate &amp;lt; 0. (For n&amp;gt;1 the details of sampling may change.)</source>
          <target state="translated">프로파일 링을 완전히 끄려면 속도 0을 전달하십시오. 현재 속도를 읽으려면 속도 &amp;lt;0을 전달하십시오. (n&amp;gt; 1의 경우 샘플링 세부 사항이 변경 될 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="ec0c40fcb609291204c17f8d3e9e4a0cf0fb716d" translate="yes" xml:space="preserve">
          <source>To unmarshal JSON into a pointer, Unmarshal first handles the case of the JSON being the JSON literal null. In that case, Unmarshal sets the pointer to nil. Otherwise, Unmarshal unmarshals the JSON into the value pointed at by the pointer. If the pointer is nil, Unmarshal allocates a new value for it to point to.</source>
          <target state="translated">JSON을 포인터로 비 정렬 화하기 위해 Unmarshal은 먼저 JSON이 JSON 리터럴 널인 경우를 처리합니다. 이 경우 Unmarshal은 포인터를 nil로 설정합니다. 그렇지 않으면 Unmarshal은 포인터가 가리키는 값으로 JSON을 비 정렬 화합니다. 포인터가 nil이면 Unmarshal은 포인터가 가리 키도록 새 값을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="9ec7dbd6621b41728144a0cd3fc2c36f64948e68" translate="yes" xml:space="preserve">
          <source>To unmarshal JSON into a struct, Unmarshal matches incoming object keys to the keys used by Marshal (either the struct field name or its tag), preferring an exact match but also accepting a case-insensitive match. By default, object keys which don't have a corresponding struct field are ignored (see Decoder.DisallowUnknownFields for an alternative).</source>
          <target state="translated">JSON을 구조체로 비 정렬 화하기 위해 Unmarshal은 들어오는 객체 키를 Marshal에서 사용하는 키 (구조체 필드 이름 또는 태그)와 일치 시키며, 정확히 일치하는 것을 선호하지만 대소 문자를 구분하지 않는 일치도 허용합니다. 기본적으로 해당 구조체 필드가없는 객체 키는 무시됩니다 (대안은 Decoder.DisallowUnknownFields 참조).</target>
        </trans-unit>
        <trans-unit id="a6bdbb20d4135a3bc4596a68aa8c2c34912d504d" translate="yes" xml:space="preserve">
          <source>To unmarshal JSON into a value implementing the Unmarshaler interface, Unmarshal calls that value's UnmarshalJSON method, including when the input is a JSON null. Otherwise, if the value implements encoding.TextUnmarshaler and the input is a JSON quoted string, Unmarshal calls that value's UnmarshalText method with the unquoted form of the string.</source>
          <target state="translated">Unmarshaler 인터페이스를 구현하는 값으로 JSON을 비 정렬 화하기 위해 Unmarshal은 입력이 JSON null 인 경우를 포함하여 해당 값의 UnmarshalJSON 메서드를 호출합니다. 그렇지 않으면 값이 encoding.TextUnmarshaler를 구현하고 입력이 JSON 인용 문자열 인 경우 Unmarshal은 인용되지 않은 문자열 형식으로 해당 값의 UnmarshalText 메서드를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="c66b5ce0cf55557d8e9fd777ec15355bade4e117" translate="yes" xml:space="preserve">
          <source>To unmarshal JSON into an interface value, Unmarshal stores one of these in the interface value:</source>
          <target state="translated">Unmarshal은 JSON을 인터페이스 값으로 언 마샬링하기 위해 다음 중 하나를 인터페이스 값에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="94c1b420cdca6fe4940f209d9a41f19875bfb4e7" translate="yes" xml:space="preserve">
          <source>To unmarshal a JSON array into a Go array, Unmarshal decodes JSON array elements into corresponding Go array elements. If the Go array is smaller than the JSON array, the additional JSON array elements are discarded. If the JSON array is smaller than the Go array, the additional Go array elements are set to zero values.</source>
          <target state="translated">JSON 배열을 Go 배열로 비 정렬 화하기 위해 Unmarshal은 JSON 배열 요소를 해당 Go 배열 요소로 디코딩합니다. Go 배열이 JSON 배열보다 작은 경우 추가 JSON 배열 요소가 삭제됩니다. JSON 배열이 Go 배열보다 작은 경우 추가 Go 배열 요소가 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="ed4bdd964a47161b70a00bdaa7dc00eb114dff57" translate="yes" xml:space="preserve">
          <source>To unmarshal a JSON array into a slice, Unmarshal resets the slice length to zero and then appends each element to the slice. As a special case, to unmarshal an empty JSON array into a slice, Unmarshal replaces the slice with a new empty slice.</source>
          <target state="translated">JSON 배열을 슬라이스로 비 정렬 화하기 위해 Unmarshal은 슬라이스 길이를 0으로 재설정 한 다음 각 요소를 슬라이스에 추가합니다. 특별한 경우 빈 JSON 배열을 슬라이스로 비 정렬 화하기 위해 Unmarshal은 슬라이스를 새로운 빈 슬라이스로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="007b32960f68d5d51b318bb76ca9ea0286f4126d" translate="yes" xml:space="preserve">
          <source>To unmarshal a JSON object into a map, Unmarshal first establishes a map to use. If the map is nil, Unmarshal allocates a new map. Otherwise Unmarshal reuses the existing map, keeping existing entries. Unmarshal then stores key-value pairs from the JSON object into the map. The map's key type must either be a string, an integer, or implement encoding.TextUnmarshaler.</source>
          <target state="translated">JSON 객체를 맵에서 비 정렬 화하기 위해 Unmarshal은 먼저 사용할 맵을 설정합니다. 맵이 nil이면 Unmarshal은 새 맵을 할당합니다. 그렇지 않으면 비 정렬 화는 기존 맵을 재사용하여 기존 항목을 유지합니다. Unmarshal은 JSON 객체의 키-값 쌍을 맵에 저장합니다. 지도의 키 유형은 문자열, 정수 또는 encoding.TextUnmarshaler를 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="6d6fc53f4b0d33aa877b6d747d45b96f410c47fc" translate="yes" xml:space="preserve">
          <source>To unmarshal a JSON object into a map, Unmarshal first establishes a map to use. If the map is nil, Unmarshal allocates a new map. Otherwise Unmarshal reuses the existing map, keeping existing entries. Unmarshal then stores key-value pairs from the JSON object into the map. The map's key type must either be any string type, an integer, implement json.Unmarshaler, or implement encoding.TextUnmarshaler.</source>
          <target state="translated">JSON 객체를 맵으로 언 마샬링하기 위해 Unmarshal은 먼저 사용할 맵을 설정합니다. 맵이 nil이면 Unmarshal은 새 맵을 할당합니다. 그렇지 않으면 Unmarshal은 기존 맵을 재사용하여 기존 항목을 유지합니다. 그런 다음 비 정렬 화는 JSON 개체의 키-값 쌍을 맵에 저장합니다. 맵의 키 유형은 모든 문자열 유형, 정수, json.Unmarshaler 구현 또는 encoding.TextUnmarshaler 구현이어야합니다.</target>
        </trans-unit>
        <trans-unit id="b87bf4d25ca4624c96c72d4062afc898f384fa73" translate="yes" xml:space="preserve">
          <source>To use a Pipeline p to manage multiple clients on a connection, each client should run:</source>
          <target state="translated">파이프 라인 p를 사용하여 연결에서 여러 클라이언트를 관리하려면 각 클라이언트가 다음을 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="f6369ce890fdc06aa42e060bacdc465b9893f8d9" translate="yes" xml:space="preserve">
          <source>To use a fixed length slice, or a preallocated one, use FillBytes.</source>
          <target state="translated">고정 길이 슬라이스 또는 미리 할당 된 슬라이스를 사용하려면 FillBytes를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="800eefdd201759f89cf9257524a524d86be67a56" translate="yes" xml:space="preserve">
          <source>To use an existing prepared statement on this transaction, see Tx.Stmt.</source>
          <target state="translated">이 트랜잭션에서 기존의 준비된 명령문을 사용하려면 Tx.Stmt를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2a7b3f715f9964aa312835dc3f2ae71cd3041225" translate="yes" xml:space="preserve">
          <source>To use an fs.FS implementation, use http.FS to convert it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c3bf1a32c9b769f727db4118e0b83ca4bb4efa4" translate="yes" xml:space="preserve">
          <source>To use gobs, create an Encoder and present it with a series of data items as values or addresses that can be dereferenced to values. The Encoder makes sure all type information is sent before it is needed. At the receive side, a Decoder retrieves values from the encoded stream and unpacks them into local variables.</source>
          <target state="translated">gob를 사용하려면 Encoder를 생성하고 값으로 참조 할 수있는 일련의 데이터 항목을 값 또는 주소로 표시하십시오. 인코더는 모든 유형 정보가 필요하기 전에 전송되도록합니다. 수신 측에서 디코더는 인코딩 된 스트림에서 값을 검색하여 로컬 변수에 압축을 풉니 다.</target>
        </trans-unit>
        <trans-unit id="8212c55a0bf9e12d2e296b39237ee5f72cae9d11" translate="yes" xml:space="preserve">
          <source>To use pprof, link this package into your program:</source>
          <target state="translated">pprof를 사용하려면이 패키지를 프로그램에 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="5c29e8288fd1ed9e073fe203fb55fbea12d062de" translate="yes" xml:space="preserve">
          <source>To use the operating system's file system implementation, use http.Dir:</source>
          <target state="translated">운영 체제의 파일 시스템 구현을 사용하려면 http.Dir을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="467272919dc8f37262b26b52d65afd618589f7ff" translate="yes" xml:space="preserve">
          <source>To view all available profiles, open &lt;a href=&quot;http://localhost:6060/debug/pprof/&quot;&gt;http://localhost:6060/debug/pprof/&lt;/a&gt; in your browser.</source>
          <target state="translated">사용 가능한 모든 프로필을 보려면 브라우저에서 &lt;a href=&quot;http://localhost:6060/debug/pprof/&quot;&gt;http : // localhost : 6060 / debug / pprof /&lt;/a&gt; 를 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="4193fe2d5f7ce0c7cb324cbe3968e7d5bd540d92" translate="yes" xml:space="preserve">
          <source>To write a new test suite, create a file whose name ends _test.go that contains the TestXxx functions as described here. Put the file in the same package as the one being tested. The file will be excluded from regular package builds but will be included when the &quot;go test&quot; command is run. For more detail, run &quot;go help test&quot; and &quot;go help testflag&quot;.</source>
          <target state="translated">새 테스트 스위트를 작성하려면 여기에 설명 된대로 TestXxx 함수를 포함하는 이름이 _test.go로 끝나는 파일을 작성하십시오. 테스트중인 패키지와 동일한 패키지에 파일을 넣으십시오. 파일은 일반 패키지 빌드에서 제외되지만 &quot;go test&quot;명령이 실행될 때 포함됩니다. 자세한 내용은 &quot;go help test&quot;및 &quot;go help testflag&quot;를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="f1229c7d06cb687b015bf9729398a1b9b76a455a" translate="yes" xml:space="preserve">
          <source>To write a new test suite, create a file whose name ends _test.go that contains the TestXxx functions as described here. Put the file in the same package as the one being tested. The file will be excluded from regular package builds but will be included when the &amp;ldquo;go test&amp;rdquo; command is run. For more detail, run &amp;ldquo;go help test&amp;rdquo; and &amp;ldquo;go help testflag&amp;rdquo;.</source>
          <target state="translated">새 테스트 스위트를 작성하려면 여기에 설명 된대로 TestXxx 함수를 포함하는 이름이 _test.go로 끝나는 파일을 작성하십시오. 테스트 할 파일과 동일한 패키지에 파일을 넣습니다. 파일은 일반 패키지 빌드에서 제외되지만 &quot;go test&quot;명령이 실행될 때 포함됩니다. 자세한 내용은&amp;ldquo;go help test&amp;rdquo;및&amp;ldquo;go help testflag&amp;rdquo;를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="2392dbedc5657df0a5a8c5b158593f759c811858" translate="yes" xml:space="preserve">
          <source>To16 converts the IP address ip to a 16-byte representation. If ip is not an IP address (it is the wrong length), To16 returns nil.</source>
          <target state="translated">To16은 IP 주소 ip를 16 바이트 표현으로 변환합니다. ip가 IP 주소가 아닌 경우 (잘못된 길이) To16은 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4294dda7ebb07f9702b0ce5cc1cb8bbf6e004822" translate="yes" xml:space="preserve">
          <source>To4 converts the IPv4 address ip to a 4-byte representation. If ip is not an IPv4 address, To4 returns nil.</source>
          <target state="translated">To4는 IPv4 주소 ip를 4 바이트 표현으로 변환합니다. ip가 IPv4 주소가 아닌 경우 To4는 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7deadbf704990f79d3e4df9686f8846e15431131" translate="yes" xml:space="preserve">
          <source>ToComplex converts x to a Complex value if x is representable as a Complex. Otherwise it returns an Unknown.</source>
          <target state="translated">x가 Complex로 표현 될 수있는 경우 ToComplex는 x를 Complex 값으로 변환합니다. 그렇지 않으면 알 수 없음을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="95e3b1fabb27004c6322f401e410b77c8beecafb" translate="yes" xml:space="preserve">
          <source>ToFloat converts x to a Float value if x is representable as a Float. Otherwise it returns an Unknown.</source>
          <target state="translated">x가 Float로 표현 가능한 경우 ToFloat는 x를 Float 값으로 변환합니다. 그렇지 않으면 알 수 없음을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f5e30e0ab3c38971ff0a23a0823ee7ab2da27587" translate="yes" xml:space="preserve">
          <source>ToHTML converts comment text to formatted HTML. The comment was prepared by DocReader, so it is known not to have leading, trailing blank lines nor to have trailing spaces at the end of lines. The comment markers have already been removed.</source>
          <target state="translated">ToHTML은 주석 텍스트를 형식이 지정된 HTML로 변환합니다. 주석은 DocReader에 의해 작성되었으므로 선행, 후행 공백 행이 없거나 행 끝에 후행 공백이없는 것으로 알려져 있습니다. 주석 마커가 이미 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="2f4af6e587a0b093dcea21d741f457946dac2539" translate="yes" xml:space="preserve">
          <source>ToInt converts x to an Int value if x is representable as an Int. Otherwise it returns an Unknown.</source>
          <target state="translated">x가 Int로 표현 가능한 경우 ToInt는 x를 Int 값으로 변환합니다. 그렇지 않으면 알 수 없음을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2458b21542ecbc0f90f413b7ee46521686d711b0" translate="yes" xml:space="preserve">
          <source>ToLower</source>
          <target state="translated">ToLower</target>
        </trans-unit>
        <trans-unit id="6fec192e916332e15759b9ef1699226d11bdd209" translate="yes" xml:space="preserve">
          <source>ToLower maps the rune to lower case giving priority to the special mapping.</source>
          <target state="translated">ToLower는 룬을 소문자로 매핑하여 특수 매핑에 우선 순위를 둡니다.</target>
        </trans-unit>
        <trans-unit id="0d0c9cd1331838718de8a67a4fe3f8edaf0bf598" translate="yes" xml:space="preserve">
          <source>ToLower maps the rune to lower case.</source>
          <target state="translated">ToLower는 룬을 소문자로 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="0ad2eff81c68ba7feeec4169aa737e669765ecb3" translate="yes" xml:space="preserve">
          <source>ToLower returns a copy of the byte slice s with all Unicode letters mapped to their lower case.</source>
          <target state="translated">ToLower는 모든 유니 코드 문자가 소문자로 매핑 된 바이트 슬라이스의 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9ce8fb31583c9a3f9db4dda94a7dc14fcb01df77" translate="yes" xml:space="preserve">
          <source>ToLower returns s with all Unicode letters mapped to their lower case.</source>
          <target state="translated">ToLower는 모든 유니 코드 문자를 소문자로 매핑하여을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7c6c5994143b17fa29690098b9cf21d8ab0c9626" translate="yes" xml:space="preserve">
          <source>ToLowerSpecial</source>
          <target state="translated">ToLowerSpecial</target>
        </trans-unit>
        <trans-unit id="a0c9710a46fb772958369a0897c7471714aeeeb8" translate="yes" xml:space="preserve">
          <source>ToLowerSpecial returns a copy of the string s with all Unicode letters mapped to their lower case using the case mapping specified by c.</source>
          <target state="translated">ToLowerSpecial은 c로 지정된 대소 문자 매핑을 사용하여 모든 유니 코드 문자가 소문자로 매핑 된 문자열의 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cb046f134facad4d83f3df18153937dc0992ea81" translate="yes" xml:space="preserve">
          <source>ToLowerSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their lower case, giving priority to the special casing rules.</source>
          <target state="translated">ToLowerSpecial은 s를 UTF-8로 인코딩 된 바이트로 취급하고 특수한 케이싱 규칙에 우선 순위를두고 모든 유니 코드 문자가 소문자로 매핑 된 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="494e4ed4c22e6b9204664a8671089fb351d285ee" translate="yes" xml:space="preserve">
          <source>ToRDNSequence converts n into a single RDNSequence. The following attributes are encoded as multi-value RDNs:</source>
          <target state="translated">ToRDNSequence는 n을 단일 RDNSequence로 변환합니다. 다음 속성은 다중 값 RDN으로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="2915308ca78a335773afea42473f5f868e85f100" translate="yes" xml:space="preserve">
          <source>ToSlash returns the result of replacing each separator character in path with a slash ('/') character. Multiple separators are replaced by multiple slashes.</source>
          <target state="translated">ToSlash는 경로의 각 구분 문자를 슬래시 ( '/') 문자로 바꾼 결과를 반환합니다. 여러 구분 기호는 여러 슬래시로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="ce9610dd835f1269c70383a5f4c28b5a0b063015" translate="yes" xml:space="preserve">
          <source>ToText prepares comment text for presentation in textual output. It wraps paragraphs of text to width or fewer Unicode code points and then prefixes each line with the indent. In preformatted sections (such as program text), it prefixes each non-blank line with preIndent.</source>
          <target state="translated">ToText는 텍스트 출력으로 표시 할 주석 텍스트를 준비합니다. 텍스트의 단락을 너비 이하의 유니 코드 코드 포인트로 감싸고 각 줄 앞에 들여 쓰기를 붙입니다. 미리 형식이 지정된 섹션 (예 : 프로그램 텍스트)에서는 공백이 아닌 각 줄 앞에 preIndent가 붙습니다.</target>
        </trans-unit>
        <trans-unit id="687882b6dd58f630b4dc72d2b748bc2e5e517506" translate="yes" xml:space="preserve">
          <source>ToTitle</source>
          <target state="translated">ToTitle</target>
        </trans-unit>
        <trans-unit id="16626ca02836f3e96b71ac083f67d856672bee6a" translate="yes" xml:space="preserve">
          <source>ToTitle maps the rune to title case giving priority to the special mapping.</source>
          <target state="translated">ToTitle은 룬을 제목 케이스에 매핑하여 특수 매핑에 우선 순위를 둡니다.</target>
        </trans-unit>
        <trans-unit id="82652cb33ebff96d0745bbb70b7b14b2b4f648b7" translate="yes" xml:space="preserve">
          <source>ToTitle maps the rune to title case.</source>
          <target state="translated">ToTitle은 룬을 제목 케이스에 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="b6339ce57388ab9579ed7dea7397386892cd79b3" translate="yes" xml:space="preserve">
          <source>ToTitle returns a copy of the string s with all Unicode letters mapped to their Unicode title case.</source>
          <target state="translated">ToTitle은 모든 유니 코드 문자가 유니 코드 제목 케이스에 매핑 된 문자열 s를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7c8bdbfdcd905744bd6bd92b5f2c2fe7b0b2a605" translate="yes" xml:space="preserve">
          <source>ToTitle treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their title case.</source>
          <target state="translated">ToTitle은 s를 UTF-8로 인코딩 된 바이트로 취급하고 제목 케이스에 모든 유니 코드 문자가 매핑 된 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a7e031c3da9f939af57fa1eda658027190b07385" translate="yes" xml:space="preserve">
          <source>ToTitleSpecial</source>
          <target state="translated">ToTitleSpecial</target>
        </trans-unit>
        <trans-unit id="6c2252d5e081e10993ad66199a6ce0f9c88000da" translate="yes" xml:space="preserve">
          <source>ToTitleSpecial returns a copy of the string s with all Unicode letters mapped to their Unicode title case, giving priority to the special casing rules.</source>
          <target state="translated">ToTitleSpecial은 모든 유니 코드 문자가 유니 코드 제목 케이스에 매핑되어 특수한 케이싱 규칙에 우선 순위를 둔 문자열 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="03ad764cc2cf6e71773b140dd2607d85f903d19e" translate="yes" xml:space="preserve">
          <source>ToTitleSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their title case, giving priority to the special casing rules.</source>
          <target state="translated">ToTitleSpecial은 s를 UTF-8로 인코딩 된 바이트로 취급하고 제목 케이스에 매핑 된 모든 유니 코드 문자가있는 사본을 반환하여 특수한 케이싱 규칙에 우선 순위를 둡니다.</target>
        </trans-unit>
        <trans-unit id="0c72db5394ee29e5b12a191ab1a0f08579c43c0b" translate="yes" xml:space="preserve">
          <source>ToUpper</source>
          <target state="translated">ToUpper</target>
        </trans-unit>
        <trans-unit id="8830c3933f2751182fd45204e5ac41041c190ab0" translate="yes" xml:space="preserve">
          <source>ToUpper maps the rune to upper case giving priority to the special mapping.</source>
          <target state="translated">ToUpper는 룬을 대문자로 매핑하여 특수 매핑에 우선 순위를 둡니다.</target>
        </trans-unit>
        <trans-unit id="9762b6a1a0f8f68d12efc0853373d81b1198caf9" translate="yes" xml:space="preserve">
          <source>ToUpper maps the rune to upper case.</source>
          <target state="translated">ToUpper는 룬을 대문자로 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="587e23bede12f256b7a2b187d202dc77575c043c" translate="yes" xml:space="preserve">
          <source>ToUpper returns a copy of the byte slice s with all Unicode letters mapped to their upper case.</source>
          <target state="translated">ToUpper는 모든 유니 코드 문자가 대문자로 매핑 된 바이트 슬라이스의 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1567cbaa93e2803c0387b5e052b94febf77b0dce" translate="yes" xml:space="preserve">
          <source>ToUpper returns s with all Unicode letters mapped to their upper case.</source>
          <target state="translated">ToUpper는 모든 유니 코드 문자를 대문자로 매핑하여을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e8e18cf71c085c852139f777c3a777629eaba1d4" translate="yes" xml:space="preserve">
          <source>ToUpperSpecial</source>
          <target state="translated">ToUpperSpecial</target>
        </trans-unit>
        <trans-unit id="ca298ca7f1f797ffc04335283b821c4509371407" translate="yes" xml:space="preserve">
          <source>ToUpperSpecial returns a copy of the string s with all Unicode letters mapped to their upper case using the case mapping specified by c.</source>
          <target state="translated">ToUpperSpecial은 c로 지정된 대소 문자 매핑을 사용하여 모든 유니 코드 문자가 대문자로 매핑 된 문자열의 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e092426a213e149b750e5c739fd48245f35d6f1d" translate="yes" xml:space="preserve">
          <source>ToUpperSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their upper case, giving priority to the special casing rules.</source>
          <target state="translated">ToUpperSpecial은 s를 UTF-8로 인코딩 된 바이트로 취급하고 특수한 케이싱 규칙에 우선 순위를두고 모든 유니 코드 문자가 대문자로 매핑 된 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2918f3c11590ab69ac359dd26f3078e378d4433f" translate="yes" xml:space="preserve">
          <source>ToValidUTF8 returns a copy of the string s with each run of invalid UTF-8 byte sequences replaced by the replacement string, which may be empty.</source>
          <target state="translated">ToValidUTF8은 유효하지 않은 UTF-8 바이트 시퀀스의 각 실행이 대체 문자열로 바뀌고 비어있을 수있는 문자열의 사본을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="8ddb5599f330dcf8a14e657f65440d11567b1275" translate="yes" xml:space="preserve">
          <source>ToValidUTF8 treats s as UTF-8-encoded bytes and returns a copy with each run of bytes representing invalid UTF-8 replaced with the bytes in replacement, which may be empty.</source>
          <target state="translated">ToValidUTF8은 s를 UTF-8로 인코딩 된 바이트로 취급하고 유효하지 않은 UTF-8을 나타내는 각 바이트 실행이 대체 바이트로 대체 된 사본을 리턴합니다 (비어있을 수 있음).</target>
        </trans-unit>
        <trans-unit id="0e6e43d719b59d2f4b6d64b0d7506414e902ac66" translate="yes" xml:space="preserve">
          <source>Token expands self-closing elements such as &amp;lt;br/&amp;gt; into separate start and end elements returned by successive calls.</source>
          <target state="translated">토큰은 &amp;lt;br/&amp;gt;와 같은 자체 결산 요소를 연속적인 호출에 의해 반환되는 별도의 시작 및 끝 요소로 확장합니다.</target>
        </trans-unit>
        <trans-unit id="76c580b187cf47d391aca0669ed50d6bdc842bd1" translate="yes" xml:space="preserve">
          <source>Token guarantees that the StartElement and EndElement tokens it returns are properly nested and matched: if Token encounters an unexpected end element or EOF before all expected end elements, it will return an error.</source>
          <target state="translated">토큰은 반환하는 StartElement 및 EndElement 토큰이 올바로 중첩되고 일치하도록 보장합니다. 토큰에 예상치 못한 끝 요소 또는 EOF가 예상되는 끝 요소보다 먼저 발생하면 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="20226a10555b22d829b042743665e60ca5ccfcef" translate="yes" xml:space="preserve">
          <source>Token guarantees that the delimiters [ ] { } it returns are properly nested and matched: if Token encounters an unexpected delimiter in the input, it will return an error.</source>
          <target state="translated">토큰은 반환 된 분리 문자 [] {}가 올바르게 중첩되고 일치되도록 보장합니다. 토큰에 입력에서 예기치 않은 분리 문자가 발생하면 오류가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="d280a9431f5d23758a555c6128dd19caf82e90f5" translate="yes" xml:space="preserve">
          <source>Token implements XML name spaces as described by &lt;a href=&quot;https://www.w3.org/TR/REC-xml-names/&quot;&gt;https://www.w3.org/TR/REC-xml-names/&lt;/a&gt;. Each of the Name structures contained in the Token has the Space set to the URL identifying its name space when known. If Token encounters an unrecognized name space prefix, it uses the prefix as the Space rather than report an error.</source>
          <target state="translated">토큰은 &lt;a href=&quot;https://www.w3.org/TR/REC-xml-names/&quot;&gt;https://www.w3.org/TR/REC-xml-names/에&lt;/a&gt; 설명 된대로 XML 네임 스페이스를 구현합니다 . 토큰에 포함 된 각 이름 구조에는 이름 공간을 알 수있는 URL로 설정된 공간이 있습니다. 토큰이 인식 할 수없는 네임 스페이스 접 두부를 발견하면 오류를보고하지 않고 접 두부를 스페이스로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3daac00da8a20a3986aa0fc3ba367725df5511ad" translate="yes" xml:space="preserve">
          <source>Token is the set of lexical tokens of the Go programming language.</source>
          <target state="translated">토큰은 Go 프로그래밍 언어의 어휘 토큰 세트입니다.</target>
        </trans-unit>
        <trans-unit id="347b518b7ad14bbb5cbe2525a0e1cce83a18759e" translate="yes" xml:space="preserve">
          <source>Token returns the next JSON token in the input stream. At the end of the input stream, Token returns nil, io.EOF.</source>
          <target state="translated">토큰은 입력 스트림에서 다음 JSON 토큰을 반환합니다. 입력 스트림의 끝에서 토큰은 nil, io.EOF를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fb460c5b7cbda3e107ef11644b412428d80a074a" translate="yes" xml:space="preserve">
          <source>Token returns the next XML token in the input stream. At the end of the input stream, Token returns nil, io.EOF.</source>
          <target state="translated">토큰은 입력 스트림에서 다음 XML 토큰을 반환합니다. 입력 스트림의 끝에서 토큰은 nil, io.EOF를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1f5c5f661288844b6f2ecd574998016319ee9039" translate="yes" xml:space="preserve">
          <source>TokenString returns a printable string for a token or Unicode character.</source>
          <target state="translated">TokenString은 토큰 또는 유니 코드 문자에 대해 인쇄 가능한 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1a94c716310bd537564c947b302962f8f4ba3d71" translate="yes" xml:space="preserve">
          <source>TokenText returns the string corresponding to the most recently scanned token. Valid after calling Scan and in calls of Scanner.Error.</source>
          <target state="translated">TokenText는 가장 최근에 스캔 한 토큰에 해당하는 문자열을 반환합니다. Scan을 호출 한 후 스캐너를 호출 할 때 유효합니다.</target>
        </trans-unit>
        <trans-unit id="a7a728d87ab600f19a872de7d10dd426fc51a410" translate="yes" xml:space="preserve">
          <source>ToolDir is the directory containing build tools.</source>
          <target state="translated">ToolDir은 빌드 도구가 포함 된 디렉토리입니다.</target>
        </trans-unit>
        <trans-unit id="4fa8cc860c52b268dc6a3adcde7305e9415db5bb" translate="yes" xml:space="preserve">
          <source>Tools</source>
          <target state="translated">Tools</target>
        </trans-unit>
        <trans-unit id="84f632ebde53766b4762c1e662046a0bdb1f9bee" translate="yes" xml:space="preserve">
          <source>Trace responds with the execution trace in binary form. Tracing lasts for duration specified in seconds GET parameter, or for 1 second if not specified. The package initialization registers it as /debug/pprof/trace.</source>
          <target state="translated">추적은 실행 추적에 이진 형식으로 응답합니다. 추적은 GET 매개 변수 (초)로 지정된 지속 시간 동안, 또는 지정되지 않은 경우 1 초 동안 지속됩니다. 패키지 초기화는 패키지를 / debug / pprof / trace로 등록합니다.</target>
        </trans-unit>
        <trans-unit id="37fcf61c233a1ae946b84a69b2de57281c31900c" translate="yes" xml:space="preserve">
          <source>Tracing runtime activities</source>
          <target state="translated">런타임 활동 추적</target>
        </trans-unit>
        <trans-unit id="bf930f74e883c038922957814259a08b1e5e21b8" translate="yes" xml:space="preserve">
          <source>TrailerPrefix is a magic prefix for ResponseWriter.Header map keys that, if present, signals that the map entry is actually for the response trailers, and not the response headers. The prefix is stripped after the ServeHTTP call finishes and the values are sent in the trailers.</source>
          <target state="translated">TrailerPrefix는 ResponseWriter의 마술 접두사입니다. 헤더 맵 키 (있는 경우)는 맵 항목이 실제로 응답 트레일러가 아니라 응답 헤더 용임을 나타내는 신호입니다. ServeHTTP 호출이 완료된 후 접두어가 제거되고 값이 트레일러로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="d08af63de6fd07c70bf3724749899391ccd80f36" translate="yes" xml:space="preserve">
          <source>TrailingZeroBits returns the number of consecutive least significant zero bits of |x|.</source>
          <target state="translated">TrailingZeroBits는 | x |의 연속 최하위 0 비트 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="173da913d8c53620762557efaa7f685234fe0888" translate="yes" xml:space="preserve">
          <source>TrailingZeros returns the number of trailing zero bits in x; the result is UintSize for x == 0.</source>
          <target state="translated">TrailingZeros는 x의 후행 0 비트 수를 반환합니다. 결과는 x == 0에 대한 UintSize입니다.</target>
        </trans-unit>
        <trans-unit id="3880be13b458ed7d8fd6226152f09a84df60affe" translate="yes" xml:space="preserve">
          <source>TrailingZeros16</source>
          <target state="translated">TrailingZeros16</target>
        </trans-unit>
        <trans-unit id="ac0e8b17c92ec54246a916c7c60a5898e47d2440" translate="yes" xml:space="preserve">
          <source>TrailingZeros16 returns the number of trailing zero bits in x; the result is 16 for x == 0.</source>
          <target state="translated">TrailingZeros16은 x의 후행 0 비트 수를 반환합니다. x == 0의 경우 결과는 16입니다.</target>
        </trans-unit>
        <trans-unit id="9ccb48d1009c49f2458e70054ffb06de2c2e52b1" translate="yes" xml:space="preserve">
          <source>TrailingZeros32</source>
          <target state="translated">TrailingZeros32</target>
        </trans-unit>
        <trans-unit id="ef12b2bd72258ab1ea24487faaf1b36b6624d53b" translate="yes" xml:space="preserve">
          <source>TrailingZeros32 returns the number of trailing zero bits in x; the result is 32 for x == 0.</source>
          <target state="translated">TrailingZeros32는 x의 후행 0 비트 수를 반환합니다. x == 0의 경우 결과는 32입니다.</target>
        </trans-unit>
        <trans-unit id="8645dda5fc4ccfbadfe816f019759dd903a6b384" translate="yes" xml:space="preserve">
          <source>TrailingZeros64</source>
          <target state="translated">TrailingZeros64</target>
        </trans-unit>
        <trans-unit id="9c1806ac56295eeda1305a5c016e361813241700" translate="yes" xml:space="preserve">
          <source>TrailingZeros64 returns the number of trailing zero bits in x; the result is 64 for x == 0.</source>
          <target state="translated">TrailingZeros64는 x의 후행 0 비트 수를 반환합니다. x == 0의 경우 결과는 64입니다.</target>
        </trans-unit>
        <trans-unit id="56b19e298a41e007826d31fb347a4fad087efb44" translate="yes" xml:space="preserve">
          <source>TrailingZeros8</source>
          <target state="translated">TrailingZeros8</target>
        </trans-unit>
        <trans-unit id="a51f3a70d56ba40f5381588670a32ee940f76014" translate="yes" xml:space="preserve">
          <source>TrailingZeros8 returns the number of trailing zero bits in x; the result is 8 for x == 0.</source>
          <target state="translated">TrailingZeros8은 x의 후행 0 비트 수를 반환합니다. x == 0의 경우 결과는 8입니다.</target>
        </trans-unit>
        <trans-unit id="c46e526f87b0902843d5c82001fbd44e74d2f2d7" translate="yes" xml:space="preserve">
          <source>Transport is an implementation of RoundTripper that supports HTTP, HTTPS, and HTTP proxies (for either HTTP or HTTPS with CONNECT).</source>
          <target state="translated">전송은 HTTP, HTTPS 및 HTTP 프록시 (CONNECT를 사용하는 HTTP 또는 HTTPS)를 지원하는 RoundTripper의 구현입니다.</target>
        </trans-unit>
        <trans-unit id="28030ddb48df392e29b838aa75a73353cb5390cf" translate="yes" xml:space="preserve">
          <source>Transport only retries a request upon encountering a network error if the request is idempotent and either has no body or has its Request.GetBody defined. HTTP requests are considered idempotent if they have HTTP methods GET, HEAD, OPTIONS, or TRACE; or if their Header map contains an &quot;Idempotency-Key&quot; or &quot;X-Idempotency-Key&quot; entry. If the idempotency key value is a zero-length slice, the request is treated as idempotent but the header is not sent on the wire.</source>
          <target state="translated">Transport는 요청이 멱 등성이고 본문이 없거나 Request.GetBody가 정의 된 경우 네트워크 오류가 발생한 경우에만 요청을 재 시도합니다. HTTP 요청은 HTTP 메소드 GET, HEAD, OPTIONS 또는 TRACE가있는 경우 멱등으로 간주됩니다. 또는 헤더 맵에 &quot;Idempotency-Key&quot;또는 &quot;X-Idempotency-Key&quot;항목이 포함되어있는 경우. 멱 등성 키 값이 길이가 0 인 슬라이스 인 경우 요청은 멱 등성으로 처리되지만 헤더는 유선으로 전송되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3a7dd5c9993ccdafc8353b9b9fef9d118c35957f" translate="yes" xml:space="preserve">
          <source>Transport only retries a request upon encountering a network error if the request is idempotent and either has no body or has its Request.GetBody defined. HTTP requests are considered idempotent if they have HTTP methods GET, HEAD, OPTIONS, or TRACE; or if their Header map contains an &quot;Idempotency-Key&quot; or &quot;X-Idempotency-Key&quot; entry. If the idempotency key value is an zero-length slice, the request is treated as idempotent but the header is not sent on the wire.</source>
          <target state="translated">전송은 요청이 and 등원이고 본문이 없거나 Request.GetBody가 정의 된 경우 네트워크 오류가 발생하면 요청을 재 시도합니다. HTTP 요청에 HTTP 메소드 GET, HEAD, OPTIONS 또는 TRACE가있는 경우 HTTP 요청은 dem 등원으로 간주됩니다. 또는 헤더 맵에 &quot;Idempotency-Key&quot;또는 &quot;X-Idempotency-Key&quot;항목이 포함 된 경우 dem 등원 키 값이 길이가 0 인 슬라이스 인 경우 요청은 dem 등원으로 취급되지만 헤더는 유선으로 전송되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a83654a5778fc158c90c291f8461263d34090fc9" translate="yes" xml:space="preserve">
          <source>Transport uses HTTP/1.1 for HTTP URLs and either HTTP/1.1 or HTTP/2 for HTTPS URLs, depending on whether the server supports HTTP/2, and how the Transport is configured. The DefaultTransport supports HTTP/2. To explicitly enable HTTP/2 on a transport, use golang.org/x/net/http2 and call ConfigureTransport. See the package docs for more about HTTP/2.</source>
          <target state="translated">전송은 서버가 HTTP / 2를 지원하는지 여부와 전송 구성 방법에 따라 HTTP URL에 HTTP / 1.1을 사용하고 HTTPS URL에 HTTP / 1.1 또는 HTTP / 2를 사용합니다. DefaultTransport는 HTTP / 2를 지원합니다. 전송에서 HTTP / 2를 명시 적으로 사용 가능하게하려면 golang.org/x/net/http2를 사용하고 ConfigureTransport를 호출하십시오. HTTP / 2에 대한 자세한 내용은 패키지 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5cba3ebebe9967d6b406fbd61cc05ffea9ddcf56" translate="yes" xml:space="preserve">
          <source>Transports should be reused instead of created as needed. Transports are safe for concurrent use by multiple goroutines.</source>
          <target state="translated">필요에 따라 전송을 작성하는 대신 전송을 재사용해야합니다. 여러 고 루틴이 동시에 사용하기에 안전합니다.</target>
        </trans-unit>
        <trans-unit id="cf5547182a53dd7a581affea62258ee59e262b85" translate="yes" xml:space="preserve">
          <source>Tree is the representation of a single parsed template.</source>
          <target state="translated">트리는 단일 구문 분석 된 템플리트를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0266abd25371ad4670b041dda4dc487ed199d641" translate="yes" xml:space="preserve">
          <source>Trim</source>
          <target state="translated">Trim</target>
        </trans-unit>
        <trans-unit id="abb910d5bd0bd319cf1d5ef7ad6a5112dc6c0823" translate="yes" xml:space="preserve">
          <source>Trim returns a slice of the string s with all leading and trailing Unicode code points contained in cutset removed.</source>
          <target state="translated">트림은 컷셋에 포함 된 모든 선행 및 후행 유니 코드 코드 포인트가 제거 된 문자열 조각을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4f07669cc579ec14df811b3ca5fc72fde4f78f58" translate="yes" xml:space="preserve">
          <source>Trim returns a subslice of s by slicing off all leading and trailing UTF-8-encoded code points contained in cutset.</source>
          <target state="translated">Trim은 cutset에 포함 된 모든 선행 및 후행 UTF-8 인코딩 코드 포인트를 슬라이스하여 s의 하위 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ba1962dfeb4e006658709dd72ff841213f7d1db0" translate="yes" xml:space="preserve">
          <source>TrimBytes returns b without leading and trailing ASCII space.</source>
          <target state="translated">TrimBytes는 선행 및 후행 ASCII 공간없이 b를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a48987784fdcef3e797c48099ede26a7260db2de" translate="yes" xml:space="preserve">
          <source>TrimFunc</source>
          <target state="translated">TrimFunc</target>
        </trans-unit>
        <trans-unit id="03343404f4f9dd2a23fda87bf2a4805f3806059d" translate="yes" xml:space="preserve">
          <source>TrimFunc returns a slice of the string s with all leading and trailing Unicode code points c satisfying f(c) removed.</source>
          <target state="translated">TrimFunc는 f (c)를 만족하는 모든 선행 및 후행 유니 코드 코드 포인트 c가 제거 된 문자열 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="625b4a484772db3f9992725f710f3d189c47d0db" translate="yes" xml:space="preserve">
          <source>TrimFunc returns a subslice of s by slicing off all leading and trailing UTF-8-encoded code points c that satisfy f(c).</source>
          <target state="translated">TrimFunc는 f (c)를 만족하는 모든 선행 및 후행 UTF-8 인코딩 코드 포인트 c를 슬라이스하여 s의 하위 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b796ff265d1cc90c9b78c76a3f12dd8cbff027a6" translate="yes" xml:space="preserve">
          <source>TrimLeft</source>
          <target state="translated">TrimLeft</target>
        </trans-unit>
        <trans-unit id="3406f99b35b8781b2e30c5d4f1fb92b18ccfb0a0" translate="yes" xml:space="preserve">
          <source>TrimLeft returns a slice of the string s with all leading Unicode code points contained in cutset removed.</source>
          <target state="translated">TrimLeft는 컷셋에 포함 된 모든 선행 유니 코드 코드 포인트가 제거 된 문자열 조각을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b52b880dc01fa22cd46ff385a39b5609f426247b" translate="yes" xml:space="preserve">
          <source>TrimLeft returns a subslice of s by slicing off all leading UTF-8-encoded code points contained in cutset.</source>
          <target state="translated">TrimLeft는 cutset에 포함 된 모든 선행 UTF-8 인코딩 코드 포인트를 슬라이스하여 s의 하위 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0dda8e3188c1b3df6f3a5c77e5010dd280c96425" translate="yes" xml:space="preserve">
          <source>TrimLeftFunc</source>
          <target state="translated">TrimLeftFunc</target>
        </trans-unit>
        <trans-unit id="2a771ac81b0579d70a2a4390b741d5fed266d711" translate="yes" xml:space="preserve">
          <source>TrimLeftFunc returns a slice of the string s with all leading Unicode code points c satisfying f(c) removed.</source>
          <target state="translated">TrimLeftFunc는 f (c)를 만족하는 모든 선행 유니 코드 코드 포인트 c가 제거 된 문자열 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="49c15e330f226f8800b406f97802237df2f3f947" translate="yes" xml:space="preserve">
          <source>TrimLeftFunc treats s as UTF-8-encoded bytes and returns a subslice of s by slicing off all leading UTF-8-encoded code points c that satisfy f(c).</source>
          <target state="translated">TrimLeftFunc는 s를 UTF-8 인코딩 된 바이트로 취급하고 f (c)를 만족하는 모든 선행 UTF-8 인코딩 된 코드 포인트 c를 슬라이스하여 s의 하위 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f6781400f56acf5b8bc035e02b3cdac08b09ae64" translate="yes" xml:space="preserve">
          <source>TrimPrefix</source>
          <target state="translated">TrimPrefix</target>
        </trans-unit>
        <trans-unit id="0cdb8742fe0e8f96e729ab0932195bcd75f8a8b2" translate="yes" xml:space="preserve">
          <source>TrimPrefix returns s without the provided leading prefix string. If s doesn't start with prefix, s is returned unchanged.</source>
          <target state="translated">TrimPrefix는 제공된 선행 접두사 문자열없이 s를 반환합니다. s가 접두사로 시작하지 않으면 s가 변경되지 않은 상태로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3a3dc250671844d052f305fc24e91daa5dfaf78b" translate="yes" xml:space="preserve">
          <source>TrimRight</source>
          <target state="translated">TrimRight</target>
        </trans-unit>
        <trans-unit id="f36ec5b5c4656d60b56116c5bdb688d629f84c86" translate="yes" xml:space="preserve">
          <source>TrimRight returns a slice of the string s, with all trailing Unicode code points contained in cutset removed.</source>
          <target state="translated">TrimRight는 컷셋에 포함 된 모든 후행 유니 코드 코드 포인트가 제거 된 문자열 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3ca08db3862d11ac280fa859c98a5062cca7758f" translate="yes" xml:space="preserve">
          <source>TrimRight returns a subslice of s by slicing off all trailing UTF-8-encoded code points that are contained in cutset.</source>
          <target state="translated">TrimRight는 컷셋에 포함 된 모든 후행 UTF-8 인코딩 코드 포인트를 슬라이스하여 s의 하위 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2face4904f1360f377438b017515ff3c2359f581" translate="yes" xml:space="preserve">
          <source>TrimRightFunc</source>
          <target state="translated">TrimRightFunc</target>
        </trans-unit>
        <trans-unit id="91f9e348fa7e18e840cf0ac3e8dc3a6295b78762" translate="yes" xml:space="preserve">
          <source>TrimRightFunc returns a slice of the string s with all trailing Unicode code points c satisfying f(c) removed.</source>
          <target state="translated">TrimRightFunc는 f (c)를 만족하는 모든 후행 유니 코드 코드 포인트 c가 제거 된 문자열 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="af58ad241c06498d7e5d96dabf6a334e19cb450d" translate="yes" xml:space="preserve">
          <source>TrimRightFunc returns a subslice of s by slicing off all trailing UTF-8-encoded code points c that satisfy f(c).</source>
          <target state="translated">TrimRightFunc는 f (c)를 만족하는 모든 후행 UTF-8 인코딩 코드 포인트 c를 슬라이스하여 s의 하위 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3b9759ef917cd034e3fff66af6781ac1144ddf76" translate="yes" xml:space="preserve">
          <source>TrimSpace</source>
          <target state="translated">TrimSpace</target>
        </trans-unit>
        <trans-unit id="fb7131e90264c0cc3ce43bd31575b4282b5313c8" translate="yes" xml:space="preserve">
          <source>TrimSpace returns a slice of the string s, with all leading and trailing white space removed, as defined by Unicode.</source>
          <target state="translated">TrimSpace는 유니 코드로 정의 된대로 모든 선행 및 후행 공백이 제거 된 문자열 조각을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a187e5cf0dba2afc1b0487c662e640873854f7ec" translate="yes" xml:space="preserve">
          <source>TrimSpace returns a subslice of s by slicing off all leading and trailing white space, as defined by Unicode.</source>
          <target state="translated">TrimSpace는 유니 코드로 정의 된대로 모든 선행 및 후행 공백을 슬라이스하여 s의 하위 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b11fe2b91f56619862961192ca92d40d14d67c9d" translate="yes" xml:space="preserve">
          <source>TrimString returns s without leading and trailing ASCII space.</source>
          <target state="translated">TrimString은 선행 및 후행 ASCII 공간없이 s를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="31564f1b1fc10c6dcf98b0ba8f0d174cf833e697" translate="yes" xml:space="preserve">
          <source>TrimSuffix</source>
          <target state="translated">TrimSuffix</target>
        </trans-unit>
        <trans-unit id="92a8263afbc0fa4c5341e4098b039907219bbb45" translate="yes" xml:space="preserve">
          <source>TrimSuffix returns s without the provided trailing suffix string. If s doesn't end with suffix, s is returned unchanged.</source>
          <target state="translated">TrimSuffix는 제공된 후행 접미사 문자열없이 s를 리턴합니다. s가 접미사로 끝나지 않으면 s는 변경되지 않고 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="0b8272d0bb8c9199c72411e406f2643a93b7ccca" translate="yes" xml:space="preserve">
          <source>Trunc</source>
          <target state="translated">Trunc</target>
        </trans-unit>
        <trans-unit id="4ac265259166695b742658a267b27c17c43d2d87" translate="yes" xml:space="preserve">
          <source>Trunc returns the integer value of x.</source>
          <target state="translated">Trunc는 x의 정수 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a6f2f1d850d6a1bef2ab8b526d322b73779287f1" translate="yes" xml:space="preserve">
          <source>Truncate changes the size of the file. It does not change the I/O offset. If there is an error, it will be of type *PathError.</source>
          <target state="translated">자르기는 파일 크기를 변경합니다. I / O 오프셋은 변경되지 않습니다. 오류가 있으면 * PathError 유형입니다.</target>
        </trans-unit>
        <trans-unit id="062334176014417d736c93d4f00898bc3b617151" translate="yes" xml:space="preserve">
          <source>Truncate changes the size of the named file. If the file is a symbolic link, it changes the size of the link's target. If there is an error, it will be of type *PathError.</source>
          <target state="translated">잘라내 기는 명명 된 파일의 크기를 변경합니다. 파일이 심볼릭 링크 인 경우 링크 대상의 크기가 변경됩니다. 오류가 있으면 * PathError 유형입니다.</target>
        </trans-unit>
        <trans-unit id="e8c4ef35e7ba4d40ba29121e1bd589ff3e80bcb3" translate="yes" xml:space="preserve">
          <source>Truncate discards all but the first n unread bytes from the buffer but continues to use the same allocated storage. It panics if n is negative or greater than the length of the buffer.</source>
          <target state="translated">잘림은 버퍼에서 처음 n 개의 읽지 않은 바이트를 제외한 모든 메모리를 삭제하지만 동일한 할당 된 스토리지를 계속 사용합니다. n이 음수이거나 버퍼 길이보다 길면 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="32beb0b08a1549453f279d1334d844a2afaea49a" translate="yes" xml:space="preserve">
          <source>Truncate operates on the time as an absolute duration since the zero time; it does not operate on the presentation form of the time. Thus, Truncate(Hour) may return a time with a non-zero minute, depending on the time's Location.</source>
          <target state="translated">잘라내 기는 0 시간 이후의 절대 지속 시간으로 시간에 작동합니다. 시간의 프리젠 테이션 형식에서는 작동하지 않습니다. 따라서 Truncate (Hour)는 시간의 위치에 따라 0이 아닌 분으로 시간을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="71998d5a06a6fc24a70aad616e3e9f7ea3e57939" translate="yes" xml:space="preserve">
          <source>Truncate returns the result of rounding d toward zero to a multiple of m. If m &amp;lt;= 0, Truncate returns d unchanged.</source>
          <target state="translated">자르기 d를 0으로 반올림 한 결과를 m의 배수로 반환합니다. m &amp;lt;= 0이면 Truncate는 변경되지 않은 d를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="498fecdf2960f4ea8c81a3634a3c6208f18d44bd" translate="yes" xml:space="preserve">
          <source>Truncate returns the result of rounding t down to a multiple of d (since the zero time). If d &amp;lt;= 0, Truncate returns t stripped of any monotonic clock reading but otherwise unchanged.</source>
          <target state="translated">잘라내 기는 t를 d의 배수로 내림 한 결과를 리턴합니다 (제로 시간 이후). d &amp;lt;= 0 인 경우 Truncate는 단조로운 클럭 판독 값에서 t를 제거하지만 변경하지 않은 경우 t를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7a922bb8e2913cab6dcad5ba9140345fb42fa502" translate="yes" xml:space="preserve">
          <source>TruncateWriter returns a Writer that writes to w but stops silently after n bytes.</source>
          <target state="translated">TruncateWriter는 w에 쓰지만 n 바이트 후에 자동으로 중지되는 Writer를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="66617c3163f43664fa6ddb9c95a7d88a932b782b" translate="yes" xml:space="preserve">
          <source>Truthy returns the JavaScript &quot;truthiness&quot; of the value v. In JavaScript, false, 0, &quot;&quot;, null, undefined, and NaN are &quot;falsy&quot;, and everything else is &quot;truthy&quot;. See &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Truthy&quot;&gt;https://developer.mozilla.org/en-US/docs/Glossary/Truthy&lt;/a&gt;.</source>
          <target state="translated">Truthy는 값 v의 JavaScript &quot;진실성&quot;을 반환합니다. JavaScript에서 false, 0, &quot;&quot;, null, undefined 및 NaN은 &quot;거짓&quot;이고 다른 모든 것은 &quot;거짓&quot;입니다. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Truthy&quot;&gt;https://developer.mozilla.org/en-US/docs/Glossary/Truthy를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="c26728b3acc2b9a34150900b5536db30082f4043" translate="yes" xml:space="preserve">
          <source>TryRecv attempts to receive a value from the channel v but will not block. It panics if v's Kind is not Chan. If the receive delivers a value, x is the transferred value and ok is true. If the receive cannot finish without blocking, x is the zero Value and ok is false. If the channel is closed, x is the zero value for the channel's element type and ok is false.</source>
          <target state="translated">TryRecv는 채널 v에서 값을 받으려고 시도하지만 차단하지는 않습니다. v 's Kind가 Chan이 아니면 패닉 상태입니다. 수신이 값을 전달하면 x는 전송 된 값이고 ok는 true입니다. 수신이 차단없이 완료 될 수 없으면 x는 0 값이고 ok는 false입니다. 채널이 닫히면 x는 채널 요소 유형의 0 값이고 ok는 false입니다.</target>
        </trans-unit>
        <trans-unit id="febc1b0170a31256a4ba31c38646abd1c14c7afb" translate="yes" xml:space="preserve">
          <source>TrySend attempts to send x on the channel v but will not block. It panics if v's Kind is not Chan. It reports whether the value was sent. As in Go, x's value must be assignable to the channel's element type.</source>
          <target state="translated">TrySend는 채널 v에서 x를 보내려고하지만 차단하지는 않습니다. v 's Kind가 Chan이 아니면 패닉 상태입니다. 값이 전송되었는지 여부를보고합니다. Go에서와 같이 x의 값은 채널의 요소 유형에 지정 가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="7fd5a63a31a17c2aa8f2b5b0d5183f5173b04681" translate="yes" xml:space="preserve">
          <source>Two keys are only considered to have the same value if they have the same Curve value. Note that for example elliptic.P256() and elliptic.P256().Params() are different values, as the latter is a generic not constant time implementation.</source>
          <target state="translated">두 개의 키는 곡선 값이 같은 경우에만 같은 값을 갖는 것으로 간주됩니다. 예를 들어 elliptic.P256 () 및 elliptic.P256 (). Params ()는 다른 값입니다. 후자는 일반적이지 않은 일반 시간 구현이기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="ad904f452afce8318d85fd92e9c6e068ca4fed6e" translate="yes" xml:space="preserve">
          <source>Two sets of interfaces are included in this package. When a more abstract interface isn't necessary, there are functions for encrypting/decrypting with v1.5/OAEP and signing/verifying with v1.5/PSS. If one needs to abstract over the public key primitive, the PrivateKey type implements the Decrypter and Signer interfaces from the crypto package.</source>
          <target state="translated">이 패키지에는 두 세트의 인터페이스가 포함되어 있습니다. 좀 더 추상적 인 인터페이스가 필요하지 않은 경우 v1.5 / OAEP로 암호화 / 복호화하고 v1.5 / PSS로 서명 / 확인하는 기능이 있습니다. 공개 키 프리미티브를 추상화해야하는 경우 PrivateKey 유형은 암호화 패키지에서 Decrypter 및 Signer 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="042f2d498c44806f60201f1f05491910d5c73fe8" translate="yes" xml:space="preserve">
          <source>Two sets of interfaces are included in this package. When a more abstract interface isn't necessary, there are functions for encrypting/decrypting with v1.5/OAEP and signing/verifying with v1.5/PSS. If one needs to abstract over the public-key primitive, the PrivateKey struct implements the Decrypter and Signer interfaces from the crypto package.</source>
          <target state="translated">이 패키지에는 2 개의 인터페이스 세트가 포함되어 있습니다. 보다 추상적 인 인터페이스가 필요하지 않은 경우 v1.5 / OAEP로 암호화 / 복호화하고 v1.5 / PSS로 서명 / 확인하는 기능이 있습니다. 공개 키 프리미티브를 추상화해야 할 경우 PrivateKey 구조체는 암호화 패키지에서 Decrypter 및 Signer 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="021677bbd9ee4b61e5a1312cf21d452a27661c48" translate="yes" xml:space="preserve">
          <source>Tx is a transaction.</source>
          <target state="translated">Tx는 거래입니다.</target>
        </trans-unit>
        <trans-unit id="02cdcf0d841ea4d5e8abf2653c842d138120149a" translate="yes" xml:space="preserve">
          <source>Tx is an in-progress database transaction.</source>
          <target state="translated">Tx는 진행중인 데이터베이스 트랜잭션입니다.</target>
        </trans-unit>
        <trans-unit id="41b6053676814b4fe97b2c9be9a306ee614bfa3d" translate="yes" xml:space="preserve">
          <source>Tx.ExecContext</source>
          <target state="translated">Tx.ExecContext</target>
        </trans-unit>
        <trans-unit id="2825856698e10e430365413d889b83a20654a02a" translate="yes" xml:space="preserve">
          <source>Tx.Prepare</source>
          <target state="translated">Tx.Prepare</target>
        </trans-unit>
        <trans-unit id="ef76ba4edb63dbd2cd7bf54f9037e276e1229e5a" translate="yes" xml:space="preserve">
          <source>Tx.Rollback</source>
          <target state="translated">Tx.Rollback</target>
        </trans-unit>
        <trans-unit id="a83fe983647bcf7e1590d7bef39b1b437680667a" translate="yes" xml:space="preserve">
          <source>TxOptions holds the transaction options to be used in DB.BeginTx.</source>
          <target state="translated">TxOptions에는 DB.BeginTx에서 사용할 트랜잭션 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="46eaf072cf758f74571ec8685b65883630652645" translate="yes" xml:space="preserve">
          <source>TxOptions holds the transaction options.</source>
          <target state="translated">TxOptions는 트랜잭션 옵션을 보유합니다.</target>
        </trans-unit>
        <trans-unit id="68e7b01d33d203d9281e2f2dd8f3398104376276" translate="yes" xml:space="preserve">
          <source>Typ contains the predeclared *Basic types indexed by their corresponding BasicKind.</source>
          <target state="translated">Typ에는 해당 BasicKind에 의해 색인 된 사전 선언 된 * 기본 유형이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="64f24b17ea9baa36a77dc3d1afdc32b1a420fb9e" translate="yes" xml:space="preserve">
          <source>Type flags for Header.Typeflag.</source>
          <target state="translated">Header.Typeflag에 대한 유형 플래그.</target>
        </trans-unit>
        <trans-unit id="04ccb52737e3e40430c97b234b8f24e390173f8b" translate="yes" xml:space="preserve">
          <source>Type inference computes the type (Type) of every expression (ast.Expr) and checks for compliance with the language specification. Use Info.Types[expr].Type for the results of type inference.</source>
          <target state="translated">형식 유추는 모든 식 (ast.Expr)의 형식 (Type)을 계산하고 언어 사양을 준수하는지 확인합니다. 형식 유추의 결과에 Info.Types [expr] .Type을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8035b14525c84dd4e5349419c0ff657e153c1c32" translate="yes" xml:space="preserve">
          <source>Type is found in Header.Type.</source>
          <target state="translated">형식은 Header.Type에 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec7bc4958b2c43e87f98f2ef7e1adb5d065d5c5e" translate="yes" xml:space="preserve">
          <source>Type is here for the purposes of documentation only. It is a stand-in for any Go type, but represents the same type for any given function invocation.</source>
          <target state="translated">유형은 문서 목적으로 만 사용됩니다. 모든 Go 유형에 대한 스탠드 인이지만 주어진 함수 호출에 대해 동일한 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="233ac19906546712346f536e7ee3880b82162310" translate="yes" xml:space="preserve">
          <source>Type is the documentation for a type declaration.</source>
          <target state="translated">Type은 형식 선언에 대한 설명서입니다.</target>
        </trans-unit>
        <trans-unit id="d3c0b263d515209e36ac606a05719bce899addba" translate="yes" xml:space="preserve">
          <source>Type is the representation of a Go type.</source>
          <target state="translated">유형은 Go 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c3bca7d619ddc3b0ec61fb8f295216cb63f22eb4" translate="yes" xml:space="preserve">
          <source>Type reads the type at off in the DWARF &amp;ldquo;info&amp;rdquo; section.</source>
          <target state="translated">유형은 DWARF &quot;정보&quot;섹션에서 유형을 끕니다.</target>
        </trans-unit>
        <trans-unit id="1fce0b09390d2c3838db788c0cf76f63a5bf80a9" translate="yes" xml:space="preserve">
          <source>Type represents the JavaScript type of a Value.</source>
          <target state="translated">Type은 Value의 JavaScript 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e06c5701673348f2eed499aa753a2ba395d1a12d" translate="yes" xml:space="preserve">
          <source>Type returns itself and provides an easy default implementation for embedding in a Node. Embedded in all non-trivial Nodes.</source>
          <target state="translated">유형 자체를 반환하고 노드에 포함하기위한 쉬운 기본 구현을 제공합니다. 모든 사소한 노드에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="4726645469f41dd7bcb1d47132c78e582530c7e1" translate="yes" xml:space="preserve">
          <source>Type returns the JavaScript type of the value v. It is similar to JavaScript's typeof operator, except that it returns TypeNull instead of TypeObject for null.</source>
          <target state="translated">Type은 값 v의 JavaScript 유형을 반환합니다. JavaScript의 typeof 연산자와 비슷하지만 null에 대해 TypeObject 대신 TypeNull을 반환한다는 점이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="2fa9db8cb436bbb192eec5d03d6240277e6eeffd" translate="yes" xml:space="preserve">
          <source>Type returns the object's type.</source>
          <target state="translated">Type은 객체의 유형을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d1407fc8c8322906d1372dd8a45dc51e6205559f" translate="yes" xml:space="preserve">
          <source>Type returns the type of x.f, which may be different from the type of f. See Selection for more information.</source>
          <target state="translated">Type은 xf의 유형을 반환하며 f의 유형과 다를 수 있습니다. 자세한 내용은 선택을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="55e720628bd8b49b52419d5886faf349fa86465b" translate="yes" xml:space="preserve">
          <source>Type returns type bits in m (m &amp;amp; ModeType).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="372fc3db84eb7f93272dcba175262aaab1565f30" translate="yes" xml:space="preserve">
          <source>Type returns v's type.</source>
          <target state="translated">타입은 v 타입을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="55dbc1b43ee6cb3b1548172b193bc2a7d3e5eca5" translate="yes" xml:space="preserve">
          <source>Type values are comparable, such as with the == operator, so they can be used as map keys. Two Type values are equal if they represent identical types.</source>
          <target state="translated">== 연산자와 같은 유형 값은 비교 가능하므로 맵 키로 사용할 수 있습니다. 두 유형 값이 동일한 유형을 나타내는 경우 동일합니다.</target>
        </trans-unit>
        <trans-unit id="7bdac7349f75285c99f4a03ea2e2de6365f45c2a" translate="yes" xml:space="preserve">
          <source>Type-checking consists of several interdependent phases:</source>
          <target state="translated">유형 검사는 여러 개의 상호 의존적 인 단계로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="26984be5e6e3b06475f717ab4d76ce6f4ff88c54" translate="yes" xml:space="preserve">
          <source>Type1 is here for the purposes of documentation only. It is a stand-in for any Go type, but represents the same type for any given function invocation.</source>
          <target state="translated">Type1은 설명서 목적으로 만 사용됩니다. 모든 Go 유형에 대한 스탠드 인이지만 주어진 함수 호출에 대해 동일한 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7ace60c9c3dbd05ce39ba29e759c6ad4a52088eb" translate="yes" xml:space="preserve">
          <source>TypeAndValue reports the type and value (for constants) of the corresponding expression.</source>
          <target state="translated">TypeAndValue는 해당 표현식의 유형과 값 (상수의 경우)을보고합니다.</target>
        </trans-unit>
        <trans-unit id="2bc75a2b4beae4c84f906bb525769e97f38f0823" translate="yes" xml:space="preserve">
          <source>TypeByExtension returns the MIME type associated with the file extension ext. The extension ext should begin with a leading dot, as in &quot;.html&quot;. When ext has no associated type, TypeByExtension returns &quot;&quot;.</source>
          <target state="translated">TypeByExtension은 파일 확장자 ext와 연관된 MIME 유형을 반환합니다. 확장자 ext는 &quot;.html&quot;과 같이 선행 점으로 시작해야합니다. ext에 연결된 유형이 없으면 TypeByExtension은 &quot;&quot;를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="263318bcaf840ab395175e373b1ab05080a86fda" translate="yes" xml:space="preserve">
          <source>TypeOf</source>
          <target state="translated">TypeOf</target>
        </trans-unit>
        <trans-unit id="94969a4aec167529cd20467de358b3733a4d1890" translate="yes" xml:space="preserve">
          <source>TypeOf returns the reflection Type that represents the dynamic type of i. If i is a nil interface value, TypeOf returns nil.</source>
          <target state="translated">TypeOf는 i의 동적 유형을 나타내는 반사 유형을 반환합니다. i가 nil 인터페이스 값인 경우 TypeOf는 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="610b14205855f95702d99da6e19e5297b1301163" translate="yes" xml:space="preserve">
          <source>TypeOf returns the type of expression e, or nil if not found. Precondition: the Types, Uses and Defs maps are populated.</source>
          <target state="translated">TypeOf는 식 e의 유형을 반환하거나 찾지 못하면 nil을 반환합니다. 전제 조건 : 유형, 용도 및 정의 맵이 채워집니다.</target>
        </trans-unit>
        <trans-unit id="af91dac9977c975dbcb45d1e0c495727ba389f89" translate="yes" xml:space="preserve">
          <source>TypeString returns the string representation of typ. The Qualifier controls the printing of package-level objects, and may be nil.</source>
          <target state="translated">TypeString은 typ의 문자열 표현을 반환합니다. 한정자는 패키지 수준 개체의 인쇄를 제어하며 nil 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70c0f61c1717bc58a510efe98bd7a3251bcbbcc7" translate="yes" xml:space="preserve">
          <source>Typed Strings</source>
          <target state="translated">입력 된 문자열</target>
        </trans-unit>
        <trans-unit id="802976d08e8f16b7d83d8d12b5129fe9e25c37e3" translate="yes" xml:space="preserve">
          <source>Types HTML, JS, URL, and others from content.go can carry safe content that is exempted from escaping.</source>
          <target state="translated">content.go의 HTML, JS, URL 및 기타 유형은 탈출이 면제 된 안전한 콘텐츠를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cea554202fc0c5ff6482d3e61417b6640fc17af4" translate="yes" xml:space="preserve">
          <source>Types and Values</source>
          <target state="translated">유형과 값</target>
        </trans-unit>
        <trans-unit id="4a237767760223207248b2b72e8a0eb1c03dbe30" translate="yes" xml:space="preserve">
          <source>Types implementing Valuer interface are able to convert themselves to a driver Value.</source>
          <target state="translated">Valuer 인터페이스를 구현하는 유형은 자신을 드라이버 Value로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="738f4e11bb80f11f67d45a4481cf366179186823" translate="yes" xml:space="preserve">
          <source>Types of signals</source>
          <target state="translated">신호의 종류</target>
        </trans-unit>
        <trans-unit id="4a68e8d3eb65d7282f5ff466196272be854598ae" translate="yes" xml:space="preserve">
          <source>Typical usage inside a test is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b842957498ea8405dcbf49648de63b65b478d2cb" translate="yes" xml:space="preserve">
          <source>UDPAddr represents the address of a UDP end point.</source>
          <target state="translated">UDPAddr은 UDP 엔드 포인트의 주소를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b3b4fc6834e1c9d716c787f9ac0d161736c5f604" translate="yes" xml:space="preserve">
          <source>UDPConn is the implementation of the Conn and PacketConn interfaces for UDP network connections.</source>
          <target state="translated">UDPConn은 UDP 네트워크 연결을위한 Conn 및 PacketConn 인터페이스의 구현입니다.</target>
        </trans-unit>
        <trans-unit id="b499255e82796e4d28d962954395ad3d893bac9c" translate="yes" xml:space="preserve">
          <source>UDPConn.WriteTo</source>
          <target state="translated">UDPConn.WriteTo</target>
        </trans-unit>
        <trans-unit id="0e2d9b0777a485c1276de0803c12a7d76fbc5c39" translate="yes" xml:space="preserve">
          <source>URL</source>
          <target state="translated">URL</target>
        </trans-unit>
        <trans-unit id="2113a36dc330dedde4db70e90a71dcb67bd4a9a2" translate="yes" xml:space="preserve">
          <source>URL (Roundtrip)</source>
          <target state="translated">URL (왕복)</target>
        </trans-unit>
        <trans-unit id="a727ea70072d81d7b63c816962c8a756b508329a" translate="yes" xml:space="preserve">
          <source>URL encapsulates a known safe URL or URL substring (see RFC 3986). A URL like `javascript:checkThatFormNotEditedBeforeLeavingPage()` from a trusted source should go in the page, but by default dynamic `javascript:` URLs are filtered out since they are a frequently exploited injection vector.</source>
          <target state="translated">URL은 알려진 안전한 URL 또는 URL 하위 문자열을 캡슐화합니다 (RFC 3986 참조). 신뢰할 수있는 소스의`javascript : checkThatFormNotEditedBeforeLeavingPage ()`와 같은 URL이 페이지에 들어가야하지만 기본적으로 동적`javascript :`URL은 자주 악용되는 주입 벡터이므로 필터링됩니다.</target>
        </trans-unit>
        <trans-unit id="9f6702283d55dba63f2c15c6981885271e829853" translate="yes" xml:space="preserve">
          <source>URL's String method uses the EscapedPath method to obtain the path. See the EscapedPath method for more details.</source>
          <target state="translated">URL의 String 메소드는 EscapedPath 메소드를 사용하여 경로를 얻습니다. 자세한 내용은 EscapedPath 메서드를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a7ffebe53d073d64da891027cdca3ef31de6ee7a" translate="yes" xml:space="preserve">
          <source>URL.EscapedFragment</source>
          <target state="translated">URL.EscapedFragment</target>
        </trans-unit>
        <trans-unit id="fb15045a2812519f4e1083e5cb90b2d16bf5e0e2" translate="yes" xml:space="preserve">
          <source>URL.EscapedPath</source>
          <target state="translated">URL.EscapedPath</target>
        </trans-unit>
        <trans-unit id="4966fe66780da2ec3d10c8599e72fff7ab08a49a" translate="yes" xml:space="preserve">
          <source>URL.Hostname</source>
          <target state="translated">URL.Hostname</target>
        </trans-unit>
        <trans-unit id="93c3fa248c55505922464e5ed8d1899f54880821" translate="yes" xml:space="preserve">
          <source>URL.IsAbs</source>
          <target state="translated">URL.IsAbs</target>
        </trans-unit>
        <trans-unit id="c5ff099f399baf8e187d09b758e991f007d9fdbb" translate="yes" xml:space="preserve">
          <source>URL.MarshalBinary</source>
          <target state="translated">URL.MarshalBinary</target>
        </trans-unit>
        <trans-unit id="1f5b4a1bd876c3d2e848fa8ad0b5bcdecf59f3eb" translate="yes" xml:space="preserve">
          <source>URL.Parse</source>
          <target state="translated">URL.Parse</target>
        </trans-unit>
        <trans-unit id="df308e5c8e7a40f3e06e1c8f29546df6edd0815c" translate="yes" xml:space="preserve">
          <source>URL.Port</source>
          <target state="translated">URL.Port</target>
        </trans-unit>
        <trans-unit id="1f4af3bd8a928ef1166e58b54f440e84607bbe48" translate="yes" xml:space="preserve">
          <source>URL.Query</source>
          <target state="translated">URL.Query</target>
        </trans-unit>
        <trans-unit id="f2cbc812759bc0bcb35214d0c86a7a333cdc5ac4" translate="yes" xml:space="preserve">
          <source>URL.Redacted</source>
          <target state="translated">URL.Redacted</target>
        </trans-unit>
        <trans-unit id="2f6fe106a87daa55540bf1b3e2faa597e4637d72" translate="yes" xml:space="preserve">
          <source>URL.RequestURI</source>
          <target state="translated">URL.RequestURI</target>
        </trans-unit>
        <trans-unit id="5ef9cfae68b8e79167af493274ea7b99357dad6d" translate="yes" xml:space="preserve">
          <source>URL.ResolveReference</source>
          <target state="translated">URL.ResolveReference</target>
        </trans-unit>
        <trans-unit id="aae15178969446ff357ff699287cc769e108c1ee" translate="yes" xml:space="preserve">
          <source>URL.String</source>
          <target state="translated">URL.String</target>
        </trans-unit>
        <trans-unit id="ce84e8c5399c507871045bd05a22f805d2c4f2bd" translate="yes" xml:space="preserve">
          <source>URL.UnmarshalBinary</source>
          <target state="translated">URL.UnmarshalBinary</target>
        </trans-unit>
        <trans-unit id="ac64d1ff5ad8c8e979a983967383931627c1db93" translate="yes" xml:space="preserve">
          <source>URLEncoding is the alternate base64 encoding defined in RFC 4648. It is typically used in URLs and file names.</source>
          <target state="translated">URLEncoding은 RFC 4648에 정의 된 대체 base64 인코딩입니다. 일반적으로 URL 및 파일 이름에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c9df7bde57a8aa1d95e4f472d843c333da35563f" translate="yes" xml:space="preserve">
          <source>URLQueryEscaper returns the escaped value of the textual representation of its arguments in a form suitable for embedding in a URL query.</source>
          <target state="translated">URLQueryEscaper는 인수의 텍스트 표현에서 이스케이프 된 값을 URL 쿼리에 포함하기에 적합한 형식으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f75c8002cbe8f09b52b12100920f39a5c64e72ab" translate="yes" xml:space="preserve">
          <source>URLs in the comment text are converted into links; if the URL also appears in the words map, the link is taken from the map (if the corresponding map value is the empty string, the URL is not converted into a link).</source>
          <target state="translated">주석 텍스트의 URL은 링크로 변환됩니다. URL이 단어 map에도 나타나는 경우 맵에서 링크를 가져옵니다 (해당 맵 값이 빈 문자열 인 경우 URL은 링크로 변환되지 않음).</target>
        </trans-unit>
        <trans-unit id="66e91d3bfc1c62180f622950dd4b88caee7fb5f3" translate="yes" xml:space="preserve">
          <source>URLs that do not start with a slash after the scheme are interpreted as:</source>
          <target state="translated">구성표 이후에 슬래시로 시작하지 않는 URL은 다음과 같이 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="0809917b6f7b4556e78a9d2c239213f16de1592f" translate="yes" xml:space="preserve">
          <source>UTC represents Universal Coordinated Time (UTC).</source>
          <target state="translated">UTC는 협정 세계시 (UTC)를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2910e9336b266393bd7b3bb04c8ff09ab1ad423c" translate="yes" xml:space="preserve">
          <source>UTC returns t with the location set to UTC.</source>
          <target state="translated">UTC는 위치를 UTC로 설정하여 t를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bd4707cd474a6d0f83da094caeed9e471bb79e5c" translate="yes" xml:space="preserve">
          <source>Uint defines a uint flag with specified name, default value, and usage string. The return value is the address of a uint variable that stores the value of the flag.</source>
          <target state="translated">Uint는 지정된 이름, 기본값 및 사용 문자열로 uint 플래그를 정의합니다. 리턴 값은 플래그 값을 저장하는 uint 변수의 주소입니다.</target>
        </trans-unit>
        <trans-unit id="c10a1c74871016b345bc36d5bdb30897f19968dc" translate="yes" xml:space="preserve">
          <source>Uint returns v's underlying value, as a uint64. It panics if v's Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64.</source>
          <target state="translated">Uint는 v의 기본 값을 uint64로 반환합니다. v의 종류가 Uint, Uintptr, Uint8, Uint16, Uint32 또는 Uint64가 아닌 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8c727e75a1c262fee3ed280d320bad7f8659ca56" translate="yes" xml:space="preserve">
          <source>Uint32 returns a pseudo-random 32-bit value as a uint32 from the default Source.</source>
          <target state="translated">Uint32는 의사 난수 32 비트 값을 기본 소스에서 uint32로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e19c9ecfe9082dbf421a298c1c766023a8f7f823" translate="yes" xml:space="preserve">
          <source>Uint32 returns a pseudo-random 32-bit value as a uint32.</source>
          <target state="translated">Uint32는 의사 난수 32 비트 값을 uint32로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="030a2cb864d68ff2aba5fa883929c569cc36b65c" translate="yes" xml:space="preserve">
          <source>Uint64 defines a uint64 flag with specified name, default value, and usage string. The return value is the address of a uint64 variable that stores the value of the flag.</source>
          <target state="translated">Uint64는 지정된 이름, 기본값 및 사용 문자열로 uint64 플래그를 정의합니다. 리턴 값은 플래그 값을 저장하는 uint64 변수의 주소입니다.</target>
        </trans-unit>
        <trans-unit id="6d3dffebe2bfc2c33c20643972b94062f6925708" translate="yes" xml:space="preserve">
          <source>Uint64 returns a pseudo-random 64-bit value as a uint64 from the default Source.</source>
          <target state="translated">Uint64는 의사 난수 64 비트 값을 기본 소스에서 uint64로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4324e0d2d9e747146788fb1da362fb5053ac15fe" translate="yes" xml:space="preserve">
          <source>Uint64 returns a pseudo-random 64-bit value as a uint64.</source>
          <target state="translated">Uint64는 의사 난수 64 비트 값을 uint64로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8f4f108ba23391540c5f57a2d283a1654c92a932" translate="yes" xml:space="preserve">
          <source>Uint64 returns a value drawn from the Zipf distribution described by the Zipf object.</source>
          <target state="translated">Uint64는 Zipf 객체가 설명하는 Zipf 분포에서 가져온 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1ef36be6f6e6e03fddea6aa5e34904aadf0ca3e4" translate="yes" xml:space="preserve">
          <source>Uint64 returns the internal uint64 value for the metric.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e960db65d7bc2609ac63eaaddb18d0ce30fd34e" translate="yes" xml:space="preserve">
          <source>Uint64 returns the uint64 representation of x. If x cannot be represented in a uint64, the result is undefined.</source>
          <target state="translated">Uint64는 x의 uint64 표현을 반환합니다. x를 uint64로 표현할 수 없으면 결과는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4059a3fbb04daacbe98a3ac34acbb5b4f0511d79" translate="yes" xml:space="preserve">
          <source>Uint64 returns the unsigned integer resulting from truncating x towards zero. If 0 &amp;lt;= x &amp;lt;= math.MaxUint64, the result is Exact if x is an integer and Below otherwise. The result is (0, Above) for x &amp;lt; 0, and (math.MaxUint64, Below) for x &amp;gt; math.MaxUint64.</source>
          <target state="translated">Uint64는 x를 0으로 자른 결과 부호없는 정수를 반환합니다. 0 &amp;lt;= x &amp;lt;= math.MaxUint64 인 경우 x가 정수이면 결과는 정확하고 그렇지 않으면 아래입니다. 결과는 x &amp;lt;0의 경우 (0, Above)이고 x&amp;gt; math.MaxUint64의 경우 (math.MaxUint64, Below)입니다.</target>
        </trans-unit>
        <trans-unit id="eee8610c675fa51e59aceef9ba15ad48fc3f7656" translate="yes" xml:space="preserve">
          <source>Uint64Val returns the Go uint64 value of x and whether the result is exact; x must be an Int or an Unknown. If the result is not exact, its value is undefined. If x is Unknown, the result is (0, false).</source>
          <target state="translated">Uint64Val은 x의 Go uint64 값과 결과가 정확한지 여부를 반환합니다. x는 Int 또는 Unknown이어야합니다. 결과가 정확하지 않으면 값이 정의되지 않습니다. x가 알 수없는 경우 결과는 (0, false)입니다.</target>
        </trans-unit>
        <trans-unit id="f8a9446572ec072b0dca42654febb328f4183bda" translate="yes" xml:space="preserve">
          <source>Uint64Var defines a uint64 flag with specified name, default value, and usage string. The argument p points to a uint64 variable in which to store the value of the flag.</source>
          <target state="translated">Uint64Var는 지정된 이름, 기본값 및 사용 문자열로 uint64 플래그를 정의합니다. 인수 p는 플래그 값을 저장할 uint64 변수를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="496dd0effb0126ef9e845598a59198590bcd043e" translate="yes" xml:space="preserve">
          <source>UintSize is the size of a uint in bits.</source>
          <target state="translated">UintSize는 비트 단위의 uint 크기입니다.</target>
        </trans-unit>
        <trans-unit id="dbe3f8f6ae38a6c86be38b30cc7b136b0e0c8b33" translate="yes" xml:space="preserve">
          <source>UintVar defines a uint flag with specified name, default value, and usage string. The argument p points to a uint variable in which to store the value of the flag.</source>
          <target state="translated">UintVar는 지정된 이름, 기본값 및 사용 문자열로 uint 플래그를 정의합니다. 인수 p는 플래그 값을 저장할 uint 변수를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="70e0b7ef4850aca01e0f7f10e5400e6c9147df8c" translate="yes" xml:space="preserve">
          <source>UnaryOp</source>
          <target state="translated">UnaryOp</target>
        </trans-unit>
        <trans-unit id="07e07a445fa30cc6121d05f031b487faccb7d573" translate="yes" xml:space="preserve">
          <source>UnaryOp returns the result of the unary expression op y. The operation must be defined for the operand. If prec &amp;gt; 0 it specifies the ^ (xor) result size in bits. If y is Unknown, the result is Unknown.</source>
          <target state="translated">UnaryOp는 단항 표현식 op y의 결과를 반환합니다. 피연산자에 대한 작업을 정의해야합니다. prec&amp;gt; 0이면 ^ (xor) 결과 크기를 비트 단위로 지정합니다. y가 알 수없는 경우 결과는 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="65ac12608f350c5da84519394457136c59d339ec" translate="yes" xml:space="preserve">
          <source>Undefined returns the JavaScript value &quot;undefined&quot;.</source>
          <target state="translated">Undefined는 JavaScript 값 &quot;undefined&quot;를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9933a40ae911d6dfb846e287c51e34fc4040de25" translate="yes" xml:space="preserve">
          <source>UnescapeString</source>
          <target state="translated">UnescapeString</target>
        </trans-unit>
        <trans-unit id="d8d400b63495a426dfadc8a4f1e5fdcfa4a8e536" translate="yes" xml:space="preserve">
          <source>UnescapeString unescapes entities like &quot;&amp;amp;lt;&quot; to become &quot;&amp;lt;&quot;. It unescapes a larger range of entities than EscapeString escapes. For example, &quot;&amp;amp;aacute;&quot; unescapes to &quot;&amp;aacute;&quot;, as does &quot;&amp;amp;#225;&quot; and &quot;&amp;amp;#xE1;&quot;. UnescapeString(EscapeString(s)) == s always holds, but the converse isn't always true.</source>
          <target state="translated">UnescapeString은 &quot;&amp;amp; lt;&quot;와 같은 엔티티를 이스케이프 해제합니다. &quot;&amp;lt;&quot;가됩니다. EscapeString 이스케이프보다 더 큰 범위의 엔티티를 이스케이프하지 않습니다. 예를 들어 &quot;&amp;amp; aacute;&quot; &quot;&amp;amp; # 225;&quot;와 마찬가지로 &quot;&amp;aacute;&quot;로 이스케이프되지 않습니다. 및 &quot;&amp;amp; # xE1;&quot;. UnescapeString (EscapeString (s)) == s는 항상 유지되지만 대화가 항상 참인 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="32ea3c11e3a0c9441edc34338d9ee1468d7b9e70" translate="yes" xml:space="preserve">
          <source>Unicode character classes are those in unicode.Categories and unicode.Scripts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c698e3c309a2ed8c52f6f41c34c41e2935c68bed" translate="yes" xml:space="preserve">
          <source>Uniform is an infinite-sized Image of uniform color. It implements the color.Color, color.Model, and Image interfaces.</source>
          <target state="translated">균일은 균일 한 색상의 무한 크기 이미지입니다. color.Color, color.Model 및 Image 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="c9b92cda61a2bd5ee7e67c31c67ae298972c3694" translate="yes" xml:space="preserve">
          <source>Union returns the smallest rectangle that contains both r and s.</source>
          <target state="translated">Union은 r과 s를 모두 포함하는 가장 작은 사각형을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c30c209545f6cf55ee27d591debf698152bcbfd9" translate="yes" xml:space="preserve">
          <source>Unix returns t as a Unix time, the number of seconds elapsed since January 1, 1970 UTC. The result does not depend on the location associated with t.</source>
          <target state="translated">유닉스는 UTC를 1970 년 1 월 1 일 이후 경과 한 초 수인 유닉스 시간으로 t를 반환합니다. 결과는 t와 관련된 위치에 의존하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0739141adf792995ead54a41a03b2314aaccc261" translate="yes" xml:space="preserve">
          <source>Unix returns t as a Unix time, the number of seconds elapsed since January 1, 1970 UTC. The result does not depend on the location associated with t. Unix-like operating systems often record time as a 32-bit count of seconds, but since the method here returns a 64-bit value it is valid for billions of years into the past or future.</source>
          <target state="translated">Unix는 1970 년 1 월 1 일 UTC 이후 경과 한 초 수인 Unix 시간으로 t를 반환합니다. 결과는 t와 관련된 위치에 의존하지 않습니다. Unix와 유사한 운영 체제는 시간을 32 비트 초 단위로 기록하는 경우가 많지만 여기의 메서드는 64 비트 값을 반환하므로 과거 또는 미래의 수십억 년 동안 유효합니다.</target>
        </trans-unit>
        <trans-unit id="8c849502e5926e7f6de51dcd5dae32180a6c8fc5" translate="yes" xml:space="preserve">
          <source>Unix returns the local Time corresponding to the given Unix time, sec seconds and nsec nanoseconds since January 1, 1970 UTC. It is valid to pass nsec outside the range [0, 999999999]. Not all sec values have a corresponding time value. One such value is 1&amp;lt;&amp;lt;63-1 (the largest int64 value).</source>
          <target state="translated">Unix는 1970 년 1 월 1 일 UTC 이후 지정된 Unix 시간, 초 및 nsec 나노초에 해당하는 로컬 시간을 반환합니다. nsec를 [0, 999999999] 범위를 벗어나는 것이 유효합니다. 모든 초 값에 해당하는 시간 값이있는 것은 아닙니다. 그러한 값 중 하나는 1 &amp;lt;&amp;lt; 63-1 (가장 큰 int64 값)입니다.</target>
        </trans-unit>
        <trans-unit id="416b8be7737316cebb3c9cebf5753060cd3fcb1d" translate="yes" xml:space="preserve">
          <source>Unix returns the time stored in ts as seconds plus nanoseconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="164bbe899c45be28d564c4c79dd8c5d574ad3bc8" translate="yes" xml:space="preserve">
          <source>Unix returns the time stored in tv as seconds plus nanoseconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f49edfe928a8998235ec038d3202681fe6091b3" translate="yes" xml:space="preserve">
          <source>Unix returns ts as the number of seconds and nanoseconds elapsed since the Unix epoch.</source>
          <target state="translated">유닉스는 유닉스 시대 이후 초와 나노초 수로 ts를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="36e051fac71bd9f38c8bee21a4fbf639eb952b84" translate="yes" xml:space="preserve">
          <source>Unix returns tv as the number of seconds and nanoseconds elapsed since the Unix epoch.</source>
          <target state="translated">유닉스는 유닉스 시대 이후 초와 나노초의 수로 tv를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4d2a03437e4146025835f0a7a6ccd0e75af8c754" translate="yes" xml:space="preserve">
          <source>UnixAddr represents the address of a Unix domain socket end point.</source>
          <target state="translated">UnixAddr은 Unix 도메인 소켓 끝점의 주소를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="04cdae900c7738c2f31e4e0db5e46a21f1971317" translate="yes" xml:space="preserve">
          <source>UnixConn is an implementation of the Conn interface for connections to Unix domain sockets.</source>
          <target state="translated">UnixConn은 Unix 도메인 소켓에 연결하기위한 Conn 인터페이스의 구현입니다.</target>
        </trans-unit>
        <trans-unit id="fd1ae11b5100fed8de8a53db38bf7aed0bddf628" translate="yes" xml:space="preserve">
          <source>UnixCredentials encodes credentials into a socket control message for sending to another process. This can be used for authentication.</source>
          <target state="translated">UnixCredentials는 다른 프로세스로 전송하기 위해 자격 증명을 소켓 제어 메시지로 인코딩합니다. 인증에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aea7fd85f724d84dccda1e26d2c29b04dd2edf2d" translate="yes" xml:space="preserve">
          <source>UnixListener is a Unix domain socket listener. Clients should typically use variables of type Listener instead of assuming Unix domain sockets.</source>
          <target state="translated">UnixListener는 Unix 도메인 소켓 리스너입니다. 클라이언트는 일반적으로 Unix 도메인 소켓을 가정하는 대신 리스너 유형의 변수를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="2a27b45fc326b4542c26186dc68da8cc5a7e5d10" translate="yes" xml:space="preserve">
          <source>UnixNano returns t as a Unix time, the number of nanoseconds elapsed since January 1, 1970 UTC. The result is undefined if the Unix time in nanoseconds cannot be represented by an int64 (a date before the year 1678 or after 2262). Note that this means the result of calling UnixNano on the zero Time is undefined. The result does not depend on the location associated with t.</source>
          <target state="translated">UnixNano는 t를 1970 년 1 월 1 일 UTC 이후 경과 된 나노초 수인 유닉스 시간으로 반환합니다. 나노초 단위의 유닉스 시간을 int64 (1678 년 이전 또는 2262 이후 날짜)로 표시 할 수없는 경우 결과가 정의되지 않습니다. 이는 제로 시간에 UnixNano를 호출 한 결과가 정의되지 않았 음을 의미합니다. 결과는 t와 관련된 위치에 의존하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b17a6e6eff6f04c581ee8cd1e56b3e493458a9f8" translate="yes" xml:space="preserve">
          <source>UnixRights encodes a set of open file descriptors into a socket control message for sending to another process.</source>
          <target state="translated">UnixRights는 열린 파일 디스크립터 세트를 다른 프로세스로 전송하기 위해 소켓 제어 메시지로 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="dbe53cfcde936dfcaf7c8175938f51e315034103" translate="yes" xml:space="preserve">
          <source>UnknownAuthorityError results when the certificate issuer is unknown</source>
          <target state="translated">인증서 발급자를 알 수없는 경우 UnknownAuthorityError가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="81414e166f7a74fc8a4df3127afc6add584dadf1" translate="yes" xml:space="preserve">
          <source>UnknownFileError represents a failure to find the specific file in the symbol table.</source>
          <target state="translated">UnknownFileError는 기호 테이블에서 특정 파일을 찾지 못했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="71d6e61364d65cc6b10f85900b022e3a712387e7" translate="yes" xml:space="preserve">
          <source>UnknownGroupError is returned by LookupGroup when a group cannot be found.</source>
          <target state="translated">그룹을 찾을 수없는 경우 LookupGroup에서 UnknownGroupError가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="8395a289704405eac7a12dd0a91f81ec7b638b6b" translate="yes" xml:space="preserve">
          <source>UnknownGroupIdError is returned by LookupGroupId when a group cannot be found.</source>
          <target state="translated">UnknownGroupIdError는 그룹을 찾을 수 없을 때 LookupGroupId에 의해 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="ea06d94bc0ee6404fba69dbd6d9433ca16ab32bf" translate="yes" xml:space="preserve">
          <source>UnknownLineError represents a failure to map a line to a program counter, either because the line is beyond the bounds of the file or because there is no code on the given line.</source>
          <target state="translated">UnknownLineError는 행이 파일 범위를 벗어나거나 주어진 행에 코드가 없기 때문에 행을 프로그램 카운터에 매핑하지 못했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="161a93107711086546bec71b893d5cad7e7be15e" translate="yes" xml:space="preserve">
          <source>UnknownUserError is returned by Lookup when a user cannot be found.</source>
          <target state="translated">UnknownUserError는 사용자를 찾을 수 없을 때 조회에서 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6017e893f322aa54de196845bc71d4f23b1edfcb" translate="yes" xml:space="preserve">
          <source>UnknownUserIdError is returned by LookupId when a user cannot be found.</source>
          <target state="translated">UnknownUserIdError는 사용자를 찾을 수 없을 때 LookupId에 의해 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="47025f2669ef0e585c9e4472fd182fc3f82a586e" translate="yes" xml:space="preserve">
          <source>Unless an explicit codec is set up, package encoding/gob is used to transport the data.</source>
          <target state="translated">명시 적 코덱이 설정되어 있지 않으면 패키지 인코딩 / gob가 데이터 전송에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e7e8c7e799f9b4c265f8eb16ca2467638931db85" translate="yes" xml:space="preserve">
          <source>Unless otherwise noted, these are defined in RFC 7231 section 4.3.</source>
          <target state="translated">달리 명시되지 않는 한, 이들은 RFC 7231 섹션 4.3에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad0d769d8f434903817312e6a1ab62dd81dfa28b" translate="yes" xml:space="preserve">
          <source>Unless specified otherwise, all operations (including setters) that specify a *Float variable for the result (usually via the receiver with the exception of MantExp), round the numeric result according to the precision and rounding mode of the result variable.</source>
          <target state="translated">달리 지정하지 않는 한, 결과에 대해 * Float 변수를 지정하는 모든 조작 (세터 포함) (일반적으로 MantExp를 제외하고 수신자를 통해)은 결과 변수의 정밀도 및 반올림 모드에 따라 숫자 결과를 반올림합니다.</target>
        </trans-unit>
        <trans-unit id="a99463bcf73aeb4ac48f9dbe6e1c4e0ad970639e" translate="yes" xml:space="preserve">
          <source>Unlike NextPart, it does not have special handling for &quot;Content-Transfer-Encoding: quoted-printable&quot;.</source>
          <target state="translated">NextPart와 달리 &quot;Content-Transfer-Encoding : quoted-printable&quot;에 대한 특수 처리가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ce1ab5c402bafab7c2f436e8311567b966b147df" translate="yes" xml:space="preserve">
          <source>Unlike in C, it is not valid to advance a pointer just beyond the end of its original allocation:</source>
          <target state="translated">C와는 달리, 원래 할당의 끝을 넘어서 포인터를 진행시키는 것은 유효하지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="522a3a646a834223c2e98bb2c21ff8e76c01dd11" translate="yes" xml:space="preserve">
          <source>Unlike runtime.Callers, the PC values returned should, when passed to the symbolizer function, return the file/line of the call instruction. No additional subtraction is required or appropriate.</source>
          <target state="translated">runtime.Callers와 달리 리턴 된 PC 값은 symbolizer 함수에 전달 될 때 호출 명령의 파일 / 라인을 리턴해야합니다. 추가 뺄셈이 필요하지 않거나 적절하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="406ad3e57d6ca887a28b68d7deb07d96e9cd7dc1" translate="yes" xml:space="preserve">
          <source>Unlike the &quot;system&quot; library call from C and other languages, the os/exec package intentionally does not invoke the system shell and does not expand any glob patterns or handle other expansions, pipelines, or redirections typically done by shells. The package behaves more like C's &quot;exec&quot; family of functions. To expand glob patterns, either call the shell directly, taking care to escape any dangerous input, or use the path/filepath package's Glob function. To expand environment variables, use package os's ExpandEnv.</source>
          <target state="translated">C 및 다른 언어의 &quot;시스템&quot;라이브러리 호출과 달리 os / exec 패키지는 의도적으로 시스템 셸을 호출하지 않으며 글로브 패턴을 확장하거나 일반적으로 셸에서 수행되는 다른 확장, 파이프 라인 또는 리디렉션을 처리하지 않습니다. 패키지는 C의 &quot;exec&quot;기능 군과 유사하게 동작합니다. glob 패턴을 확장하려면 위험한 입력을 피하기 위해 쉘을 직접 호출하거나 path / filepath 패키지의 Glob 함수를 사용하십시오. 환경 변수를 확장하려면 package os의 ExpandEnv를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="abe91b52586dc5bbb2e6b3566c5e2c39387cbbd6" translate="yes" xml:space="preserve">
          <source>Unlink removes n % r.Len() elements from the ring r, starting at r.Next(). If n % r.Len() == 0, r remains unchanged. The result is the removed subring. r must not be empty.</source>
          <target state="translated">링크 해제는 r.Next ()에서 시작하여 링 r에서 n % r.Len () 요소를 제거합니다. n % r.Len () == 0이면 r은 변경되지 않습니다. 결과는 제거 된 서브 링입니다. r은 비워 둘 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f1750196ed6e86ab6e565436971490e6b17346e5" translate="yes" xml:space="preserve">
          <source>Unlock unlocks m. It is a run-time error if m is not locked on entry to Unlock.</source>
          <target state="translated">잠금 해제 잠금 해제 m. 잠금 해제 항목에 m이 잠겨 있지 않으면 런타임 오류입니다.</target>
        </trans-unit>
        <trans-unit id="1031b448939f378b7eec7282357fd0c8f02e0dd3" translate="yes" xml:space="preserve">
          <source>Unlock unlocks rw for writing. It is a run-time error if rw is not locked for writing on entry to Unlock.</source>
          <target state="translated">잠금 해제는 쓰기를 위해 rw를 잠금 해제합니다. 잠금 해제 항목에 쓰기 위해 rw가 잠기지 않은 경우 런타임 오류입니다.</target>
        </trans-unit>
        <trans-unit id="2769f111e84de5efeaaffb059d166476e34adffc" translate="yes" xml:space="preserve">
          <source>UnlockOSThread undoes an earlier call to LockOSThread. If this drops the number of active LockOSThread calls on the calling goroutine to zero, it unwires the calling goroutine from its fixed operating system thread. If there are no active LockOSThread calls, this is a no-op.</source>
          <target state="translated">UnlockOSThread는 LockOSThread에 대한 이전 호출을 취소합니다. 이렇게하면 호출 고 루틴의 활성 LockOSThread 호출 수가 0으로 떨어지면 고정 운영 체제 스레드에서 호출 고 루틴의 연결이 해제됩니다. 활성화 된 LockOSThread 호출이없는 경우 이는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c0c55cc87781bbcbbe014b61cd39f339918efe82" translate="yes" xml:space="preserve">
          <source>Unmarshal</source>
          <target state="translated">Unmarshal</target>
        </trans-unit>
        <trans-unit id="b902b427877022323b14bf2942e7b4318af381ef" translate="yes" xml:space="preserve">
          <source>Unmarshal converts a point, serialized by Marshal, into an x, y pair. It is an error if the point is not in uncompressed form or is not on the curve. On error, x = nil.</source>
          <target state="translated">비 정렬 화는 마셜이 직렬화 한 점을 x, y 쌍으로 변환합니다. 점이 압축되지 않은 형태가 아니거나 곡선 위에 있지 않으면 오류입니다. 오류가 발생하면 x = nil입니다.</target>
        </trans-unit>
        <trans-unit id="05d9d3d65b2b20105c2330ab2953dfbf47f42b20" translate="yes" xml:space="preserve">
          <source>Unmarshal maps an XML element or attribute value to a bool by setting it to the boolean value represented by the string. Whitespace is trimmed and ignored.</source>
          <target state="translated">비 정렬 화는 XML 요소 또는 속성 값을 문자열이 나타내는 부울 값으로 설정하여 부울에 맵핑합니다. 공백이 잘리고 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="a20ffd00f170a26037fda94503e504e8f14a2140" translate="yes" xml:space="preserve">
          <source>Unmarshal maps an XML element or attribute value to a slice by extending the length of the slice and mapping the element or attribute to the newly created value.</source>
          <target state="translated">비 정렬 화는 슬라이스의 길이를 확장하고 요소 또는 속성을 새로 작성된 값에 맵핑하여 XML 요소 또는 속성 값을 슬라이스에 맵핑합니다.</target>
        </trans-unit>
        <trans-unit id="f49e594c7cd50f427b1321468c3f00b6805b3bc7" translate="yes" xml:space="preserve">
          <source>Unmarshal maps an XML element or attribute value to an integer or floating-point field by setting the field to the result of interpreting the string value in decimal. There is no check for overflow. Whitespace is trimmed and ignored.</source>
          <target state="translated">비 정렬 화는 필드를 문자열 값을 10 진수로 해석 한 결과로 설정하여 XML 요소 또는 속성 값을 정수 또는 부동 소수점 필드에 맵핑합니다. 오버 플로우 확인이 없습니다. 공백이 잘리고 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="e3d47c5ca4b3a002e5a1a94281405e13a887e601" translate="yes" xml:space="preserve">
          <source>Unmarshal maps an XML element to a Name by recording the element name.</source>
          <target state="translated">비 정렬 화는 요소 이름을 기록하여 XML 요소를 이름에 맵핑합니다.</target>
        </trans-unit>
        <trans-unit id="96b027c2d930b698a1ed10b0bb721de215ae272f" translate="yes" xml:space="preserve">
          <source>Unmarshal maps an XML element to a pointer by setting the pointer to a freshly allocated value and then mapping the element to that value.</source>
          <target state="translated">비 정렬 화는 포인터를 새로 할당 된 값으로 설정 한 다음 요소를 해당 값에 매핑하여 XML 요소를 포인터에 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="6674f1401888e867e969567800411704118b6e15" translate="yes" xml:space="preserve">
          <source>Unmarshal maps an XML element to a string or []byte by saving the concatenation of that element's character data in the string or []byte. The saved []byte is never nil.</source>
          <target state="translated">비 정렬 화는 해당 요소의 문자 데이터 연결을 문자열 또는 [] 바이트에 저장하여 XML 요소를 문자열 또는 [] 바이트에 맵핑합니다. 저장된 [] 바이트는 절대로 0이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="a09403355ff68d791492810d3a6fdc52e5bc5f23" translate="yes" xml:space="preserve">
          <source>Unmarshal maps an XML element to a struct using the following rules. In the rules, the tag of a field refers to the value associated with the key 'xml' in the struct field's tag (see the example above).</source>
          <target state="translated">비 정렬 화는 다음 규칙을 사용하여 XML 요소를 구조체에 매핑합니다. 규칙에서 필드의 태그는 구조체 필드의 태그에서 'xml'키와 연관된 값을 나타냅니다 (위 예 참조).</target>
        </trans-unit>
        <trans-unit id="252b3357e8880736b5df5514f3757c07707118ae" translate="yes" xml:space="preserve">
          <source>Unmarshal maps an attribute value to a string or []byte by saving the value in the string or slice.</source>
          <target state="translated">비 정렬 화는 문자열 또는 슬라이스에 값을 저장하여 속성 값을 문자열 또는 [] 바이트에 맵핑합니다.</target>
        </trans-unit>
        <trans-unit id="bb18922b79397b807a3d5909559848bfe9436488" translate="yes" xml:space="preserve">
          <source>Unmarshal maps an attribute value to an Attr by saving the attribute, including its name, in the Attr.</source>
          <target state="translated">비 정렬 화는 속성을 포함하여 속성을 속성 값에 저장하여 속성 값을 속성 값에 맵핑합니다.</target>
        </trans-unit>
        <trans-unit id="daa56a09ffbf4f0b35b7c340fa9c8ae81aa1dac5" translate="yes" xml:space="preserve">
          <source>Unmarshal parses the DER-encoded ASN.1 data structure b and uses the reflect package to fill in an arbitrary value pointed at by val. Because Unmarshal uses the reflect package, the structs being written to must use upper case field names.</source>
          <target state="translated">비 정렬 화는 DER 인코딩 된 ASN.1 데이터 구조 b를 구문 분석하고 val이 가리키는 임의의 값을 채우기 위해 반사 패키지를 사용합니다. Unmarshal은 reflect 패키지를 사용하므로 작성되는 구조체는 대문자 필드 이름을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="896b9d75411fe008ac002fa69d65a02d32ae68e8" translate="yes" xml:space="preserve">
          <source>Unmarshal parses the DER-encoded ASN.1 data structure b and uses the reflect package to fill in an arbitrary value pointed at by val. Because Unmarshal uses the reflect package, the structs being written to must use upper case field names. If val is nil or not a pointer, Unmarshal returns an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a9e198e98aaf9144ec031242893dd0ad5675a2b" translate="yes" xml:space="preserve">
          <source>Unmarshal parses the JSON-encoded data and stores the result in the value pointed to by v. If v is nil or not a pointer, Unmarshal returns an InvalidUnmarshalError.</source>
          <target state="translated">비 정렬은 JSON으로 인코딩 된 데이터를 구문 분석하고 결과를 v가 가리키는 값으로 저장합니다. v가 nil이거나 포인터가 아닌 경우 Unmarshal은 InvalidUnmarshalError를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ed1d87c314d03ac8a80eec05352fd3a2e828f6fd" translate="yes" xml:space="preserve">
          <source>Unmarshal parses the XML-encoded data and stores the result in the value pointed to by v, which must be an arbitrary struct, slice, or string. Well-formed data that does not fit into v is discarded.</source>
          <target state="translated">비 정렬 화는 XML로 인코딩 된 데이터를 구문 분석하고 v가 가리키는 값으로 결과를 저장합니다.이 값은 임의의 구조체, 슬라이스 또는 문자열이어야합니다. v에 맞지 않는 올바른 형식의 데이터는 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="40f5f3bf6806f78bc75f412c5c5def4697b027f5" translate="yes" xml:space="preserve">
          <source>Unmarshal uses the inverse of the encodings that Marshal uses, allocating maps, slices, and pointers as necessary, with the following additional rules:</source>
          <target state="translated">Unmarshal은 다음 추가 규칙과 함께 필요에 따라 Marshal이 사용하는 인코딩의 역수를 사용하여 맵, 슬라이스 및 포인터를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="8a48a17f3248cfe923e11a8bf58b4b7fb9c77d34" translate="yes" xml:space="preserve">
          <source>UnmarshalBinary implements the encoding.BinaryUnmarshaler interface.</source>
          <target state="translated">UnmarshalBinary는 encoding.BinaryUnmarshaler 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="3e8a767165b3da81fab334a0479c29a17b19b26e" translate="yes" xml:space="preserve">
          <source>UnmarshalBinary must be able to decode the form generated by MarshalBinary. UnmarshalBinary must copy the data if it wishes to retain the data after returning.</source>
          <target state="translated">UnmarshalBinary는 MarshalBinary에 의해 생성 된 형식을 해독 할 수 있어야합니다. UnmarshalBinary는 반환 후 데이터를 유지하려면 데이터를 복사해야합니다.</target>
        </trans-unit>
        <trans-unit id="c0f8f106115bed98d4438b712b344fc8e65ac7a2" translate="yes" xml:space="preserve">
          <source>UnmarshalCompressed converts a point, serialized by MarshalCompressed, into an x, y pair. It is an error if the point is not in compressed form or is not on the curve. On error, x = nil.</source>
          <target state="translated">UnmarshalCompressed는 MarshalCompressed에 의해 직렬화 된 점을 x, y 쌍으로 변환합니다. 점이 압축 된 형태가 아니거나 곡선에없는 경우 오류입니다. 오류시 x = nil.</target>
        </trans-unit>
        <trans-unit id="a1f2034d1f5318f262d82d2c3d3d1a1f573ff376" translate="yes" xml:space="preserve">
          <source>UnmarshalJSON implements the json.Unmarshaler interface.</source>
          <target state="translated">UnmarshalJSON은 json.Unmarshaler 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="ac481b848955fbdb07ec4ed8b1f2094acec90508" translate="yes" xml:space="preserve">
          <source>UnmarshalJSON implements the json.Unmarshaler interface. The time is expected to be a quoted string in RFC 3339 format.</source>
          <target state="translated">UnmarshalJSON은 json.Unmarshaler 인터페이스를 구현합니다. 시간은 RFC 3339 형식의 인용 문자열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="501d2e87e0671202c95a53d1a0ea534ac74ed463" translate="yes" xml:space="preserve">
          <source>UnmarshalJSON sets *m to a copy of data.</source>
          <target state="translated">UnmarshalJSON은 * m을 데이터 사본으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="766c1d65184cba1147b7a3545fa3391dee2740d7" translate="yes" xml:space="preserve">
          <source>UnmarshalText implements the encoding.TextUnmarshaler interface.</source>
          <target state="translated">UnmarshalText는 encoding.TextUnmarshaler 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="85ec5d5725d7fc8b15d01b424436803971c310f0" translate="yes" xml:space="preserve">
          <source>UnmarshalText implements the encoding.TextUnmarshaler interface. The IP address is expected in a form accepted by ParseIP.</source>
          <target state="translated">UnmarshalText는 encoding.TextUnmarshaler 인터페이스를 구현합니다. IP 주소는 ParseIP가 승인 한 형식으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="131593f7a0c50a040c83c26b3def1697240de177" translate="yes" xml:space="preserve">
          <source>UnmarshalText implements the encoding.TextUnmarshaler interface. The result is rounded per the precision and rounding mode of z. If z's precision is 0, it is changed to 64 before rounding takes effect.</source>
          <target state="translated">UnmarshalText는 encoding.TextUnmarshaler 인터페이스를 구현합니다. 결과는 z의 정밀도 및 반올림 모드에 따라 반올림됩니다. z의 정밀도가 0이면 반올림이 적용되기 전에 64로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="7b15f389f52fa3ed23e4bbf98f836b42c06e5eba" translate="yes" xml:space="preserve">
          <source>UnmarshalText implements the encoding.TextUnmarshaler interface. The time is expected to be in RFC 3339 format.</source>
          <target state="translated">UnmarshalText는 encoding.TextUnmarshaler 인터페이스를 구현합니다. 시간은 RFC 3339 형식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="6b7f1ab4fc569112930c20562985da8185544c87" translate="yes" xml:space="preserve">
          <source>UnmarshalText must be able to decode the form generated by MarshalText. UnmarshalText must copy the text if it wishes to retain the text after returning.</source>
          <target state="translated">UnmarshalText는 MarshalText에 의해 생성 된 양식을 디코딩 할 수 있어야합니다. UnmarshalText는 텍스트를 반환 한 후 텍스트를 유지하려면 텍스트를 복사해야합니다.</target>
        </trans-unit>
        <trans-unit id="bd65d49d42bce927940aedf915c377e4dd09e40d" translate="yes" xml:space="preserve">
          <source>UnmarshalWithParams allows field parameters to be specified for the top-level element. The form of the params is the same as the field tags.</source>
          <target state="translated">UnmarshalWithParams를 사용하면 최상위 요소에 필드 매개 변수를 지정할 수 있습니다. 매개 변수의 형식은 필드 태그와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="b3bf6c68384d3fb37cb6c7555cff99e7fce3bb41" translate="yes" xml:space="preserve">
          <source>UnmarshalXML decodes a single XML element beginning with the given start element. If it returns an error, the outer call to Unmarshal stops and returns that error. UnmarshalXML must consume exactly one XML element. One common implementation strategy is to unmarshal into a separate value with a layout matching the expected XML using d.DecodeElement, and then to copy the data from that value into the receiver. Another common strategy is to use d.Token to process the XML object one token at a time. UnmarshalXML may not use d.RawToken.</source>
          <target state="translated">UnmarshalXML은 주어진 시작 요소로 시작하는 단일 XML 요소를 디코딩합니다. 오류가 반환되면 Unmarshal에 대한 외부 호출이 중지되고 해당 오류가 반환됩니다. UnmarshalXML은 정확히 하나의 XML 요소를 사용해야합니다. 일반적인 구현 전략 중 하나는 d.DecodeElement를 사용하여 예상 XML과 일치하는 레이아웃을 사용하여 별도의 값으로 마샬링 해제 한 다음 해당 값의 데이터를 수신자로 복사하는 것입니다. 또 다른 일반적인 전략은 d.Token을 사용하여 한 번에 하나의 토큰으로 XML 객체를 처리하는 것입니다. UnmarshalXML은 d.RawToken을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="acecbda4c97cb520576b3b10bc8d83fa35017c1a" translate="yes" xml:space="preserve">
          <source>UnmarshalXMLAttr decodes a single XML attribute. If it returns an error, the outer call to Unmarshal stops and returns that error. UnmarshalXMLAttr is used only for struct fields with the &quot;attr&quot; option in the field tag.</source>
          <target state="translated">UnmarshalXMLAttr은 단일 XML 속성을 디코딩합니다. 오류가 반환되면 Unmarshal에 대한 외부 호출이 중지되고 해당 오류가 반환됩니다. UnmarshalXMLAttr은 필드 태그에 &quot;attr&quot;옵션이있는 구조체 필드에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="74aa3bc85e3cd4c389b5c2ee32e0f9e728ff011a" translate="yes" xml:space="preserve">
          <source>Unmarshaler is the interface implemented by objects that can unmarshal an XML element description of themselves.</source>
          <target state="translated">Unmarshaler는 자신에 대한 XML 요소 설명을 언 마샬링 할 수있는 객체로 구현 된 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="da8c67afda9119d4c5ae65e92c29582ea2cf5d56" translate="yes" xml:space="preserve">
          <source>Unmarshaler is the interface implemented by types that can unmarshal a JSON description of themselves. The input can be assumed to be a valid encoding of a JSON value. UnmarshalJSON must copy the JSON data if it wishes to retain the data after returning.</source>
          <target state="translated">Unmarshaler는 JSON 설명을 언 마샬링 할 수있는 유형으로 구현 된 인터페이스입니다. 입력은 JSON 값의 유효한 인코딩으로 가정 할 수 있습니다. UnmarshalJSON은 반환 후 데이터를 유지하려면 JSON 데이터를 복사해야합니다.</target>
        </trans-unit>
        <trans-unit id="53e6478e1491aec13688a3a1ab544532e2362899" translate="yes" xml:space="preserve">
          <source>UnmarshalerAttr is the interface implemented by objects that can unmarshal an XML attribute description of themselves.</source>
          <target state="translated">UnmarshalerAttr은 자신에 대한 XML 속성 설명을 언 마샬링 할 수있는 객체로 구현 된 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="3db9a5e29909b34e2551d8477bb97dce0e5cc013" translate="yes" xml:space="preserve">
          <source>Unquote</source>
          <target state="translated">Unquote</target>
        </trans-unit>
        <trans-unit id="d3b6eaa5a8adda6c17843b82fa332f2940b5c172" translate="yes" xml:space="preserve">
          <source>Unquote and UnquoteChar unquote Go string and rune literals.</source>
          <target state="translated">Unquote 및 UnquoteChar는 Go 문자열 및 룬 리터럴을 인용 해제합니다.</target>
        </trans-unit>
        <trans-unit id="eb183728a78695573a325619f75443a862dbd0b9" translate="yes" xml:space="preserve">
          <source>Unquote interprets s as a single-quoted, double-quoted, or backquoted Go string literal, returning the string value that s quotes. (If s is single-quoted, it would be a Go character literal; Unquote returns the corresponding one-character string.)</source>
          <target state="translated">Unquote는 s를 작은 따옴표, 큰 따옴표 또는 backquoted Go 문자열 리터럴로 해석하여 따옴표로 묶은 문자열 값을 반환합니다. s가 작은 따옴표로 묶인 경우 Go 문자 리터럴이되고 Unquote는 해당하는 한 문자 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="944cb633773df2e1ec790dd961a8146fba14fec2" translate="yes" xml:space="preserve">
          <source>UnquoteChar</source>
          <target state="translated">UnquoteChar</target>
        </trans-unit>
        <trans-unit id="29375f10dc5a5623870f8be238ab4c2e02bc8067" translate="yes" xml:space="preserve">
          <source>UnquoteChar decodes the first character or byte in the escaped string or character literal represented by the string s. It returns four values:</source>
          <target state="translated">UnquoteChar는 이스케이프 된 문자열 또는 문자열 s로 표시되는 문자 리터럴의 첫 번째 문자 또는 바이트를 디코딩합니다. 네 가지 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b53dd6b78670edea47b93cdb0a942d08f61ad422" translate="yes" xml:space="preserve">
          <source>UnquoteUsage extracts a back-quoted name from the usage string for a flag and returns it and the un-quoted usage. Given &quot;a `name` to show&quot; it returns (&quot;name&quot;, &quot;a name to show&quot;). If there are no back quotes, the name is an educated guess of the type of the flag's value, or the empty string if the flag is boolean.</source>
          <target state="translated">UnquoteUsage는 플래그의 사용법 문자열에서 역 인용 된 이름을 추출하여 인용되지 않은 사용법을 리턴합니다. &quot;표시 할 이름&quot;이 주어지면 ( &quot;이름&quot;, &quot;표시 할 이름&quot;)을 반환합니다. 역 따옴표가 없으면 이름은 플래그 값의 유형에 대한 교육 된 추측이거나 플래그가 부울 인 경우 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="31604e0bbb76d839a9e20bc3ad471c203d67835a" translate="yes" xml:space="preserve">
          <source>UnreadByte causes the next call to ReadByte to return the same byte as the previous call to ReadByte. It may be an error to call UnreadByte twice without an intervening call to ReadByte.</source>
          <target state="translated">UnreadByte는 다음 ReadByte 호출이 이전 ReadRead 호출과 동일한 바이트를 반환하게합니다. ReadByte에 대한 중간 호출없이 UnreadByte를 두 번 호출하면 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f50817f3bd6d2c35e72fde2b0a932fd55a8206aa" translate="yes" xml:space="preserve">
          <source>UnreadByte complements ReadByte in implementing the io.ByteScanner interface.</source>
          <target state="translated">UnreadByte는 io.ByteScanner 인터페이스 구현에서 ReadByte를 보완합니다.</target>
        </trans-unit>
        <trans-unit id="5f3d5858f8afa80b57a7c212de39d0a9aff8df3f" translate="yes" xml:space="preserve">
          <source>UnreadByte implements the io.ByteScanner interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77c7dde06491fe4b9339041eb3796382445874b6" translate="yes" xml:space="preserve">
          <source>UnreadByte returns an error if the most recent method called on the Reader was not a read operation. Notably, Peek is not considered a read operation.</source>
          <target state="translated">Reader에서 가장 최근에 호출 된 메서드가 읽기 작업이 아닌 경우 UnreadByte는 오류를 반환합니다. 특히 Peek는 읽기 작업으로 간주되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="85bb36da753f37d1b461fc793f6153ef59c80214" translate="yes" xml:space="preserve">
          <source>UnreadByte unreads the last byte returned by the most recent successful read operation that read at least one byte. If a write has happened since the last read, if the last read returned an error, or if the read read zero bytes, UnreadByte returns an error.</source>
          <target state="translated">UnreadByte는 적어도 하나의 바이트를 읽는 가장 최근의 성공적인 읽기 작업에서 반환 된 마지막 바이트를 읽습니다. 마지막 읽기 이후에 쓰기가 발생한 경우, 마지막 읽기가 오류를 반환 한 경우 또는 읽기 읽기가 0 바이트 인 경우 UnreadByte는 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="965a6610c5d757c591de2c22877d96263eb8aa9d" translate="yes" xml:space="preserve">
          <source>UnreadByte unreads the last byte. Only the most recently read byte can be unread.</source>
          <target state="translated">UnreadByte는 마지막 바이트를 읽습니다. 가장 최근에 읽은 바이트 만 읽을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4b29ee18a300641e642a50770d2b768bae903a75" translate="yes" xml:space="preserve">
          <source>UnreadRune causes the next call to ReadRune to return the same rune as the previous call to ReadRune. It may be an error to call UnreadRune twice without an intervening call to ReadRune.</source>
          <target state="translated">UnreadRune은 ReadRune에 대한 다음 호출이 이전에 ReadRune에 대한 호출과 동일한 룬을 리턴하게합니다. ReadRune에 대한 중간 호출없이 UnreadRune을 두 번 호출하면 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53822d24e97f8bde421daa61dcb508cacfde9d9a" translate="yes" xml:space="preserve">
          <source>UnreadRune complements ReadRune in implementing the io.RuneScanner interface.</source>
          <target state="translated">UnreadRune은 io.RuneScanner 인터페이스 구현에서 ReadRune을 보완합니다.</target>
        </trans-unit>
        <trans-unit id="8842945f04ec11d52129a0fe96a5f0b4f9dd3388" translate="yes" xml:space="preserve">
          <source>UnreadRune implements the io.RuneScanner interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4e42f86f3f39d57a5422eae590b939a777bcf43" translate="yes" xml:space="preserve">
          <source>UnreadRune unreads the last rune returned by ReadRune. If the most recent read or write operation on the buffer was not a successful ReadRune, UnreadRune returns an error. (In this regard it is stricter than UnreadByte, which will unread the last byte from any read operation.)</source>
          <target state="translated">UnreadRune은 ReadRune에서 반환 한 마지막 룬을 읽습니다. 버퍼에서 가장 최근의 읽기 또는 쓰기 작업이 성공적인 ReadRune이 아닌 경우 UnreadRune은 오류를 반환합니다. (이 점에서 UnreadByte보다 엄격하므로 모든 읽기 작업에서 마지막 바이트를 읽지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="19847ace49c568ee229c8734fba08cf124cc864f" translate="yes" xml:space="preserve">
          <source>UnreadRune unreads the last rune. If the most recent method called on the Reader was not a ReadRune, UnreadRune returns an error. (In this regard it is stricter than UnreadByte, which will unread the last byte from any read operation.)</source>
          <target state="translated">UnreadRune은 마지막 룬을 읽습니다. Reader에서 가장 최근에 호출 된 메서드가 ReadRune이 아닌 경우 UnreadRune은 오류를 반환합니다. (이 점에서 UnreadByte보다 엄격하므로 모든 읽기 작업에서 마지막 바이트를 읽지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="50c3f847c58ba55e1737c9ae778e9a6278576b57" translate="yes" xml:space="preserve">
          <source>UnsafeAddr returns a pointer to v's data. It is for advanced clients that also import the &quot;unsafe&quot; package. It panics if v is not addressable.</source>
          <target state="translated">UnsafeAddr는 v의 데이터에 대한 포인터를 반환합니다. &quot;안전하지 않은&quot;패키지를 가져 오는 것은 고급 클라이언트를위한 것입니다. v를 처리 할 수없는 경우 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="504ce26fbf37c2ede64fba6d4661638e260a1239" translate="yes" xml:space="preserve">
          <source>Unsetenv</source>
          <target state="translated">Unsetenv</target>
        </trans-unit>
        <trans-unit id="182ea105f6e57aa2c2130dff922916a82bfc3855" translate="yes" xml:space="preserve">
          <source>Unsetenv unsets a single environment variable.</source>
          <target state="translated">Unsetenv는 단일 환경 변수를 설정 해제합니다.</target>
        </trans-unit>
        <trans-unit id="5d092e34b5869cce62568374e8b69ed2285d4b5a" translate="yes" xml:space="preserve">
          <source>UnsupportedTypeError is returned when Marshal encounters a type that cannot be converted into XML.</source>
          <target state="translated">Marshal에서 XML로 변환 할 수없는 형식이 발견되면 UnsupportedTypeError가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e92f4283009858bf9a4050cedd8fe684e6e6d055" translate="yes" xml:space="preserve">
          <source>Until returns the duration until t. It is shorthand for t.Sub(time.Now()).</source>
          <target state="translated">까지 t까지 지속 시간을 반환합니다. t.Sub (time.Now ())의 약어입니다.</target>
        </trans-unit>
        <trans-unit id="90df4c2aff351c99774ec32df813be4f64cfabcd" translate="yes" xml:space="preserve">
          <source>Unwrap returns the result of calling the Unwrap method on err, if err's type contains an Unwrap method returning error. Otherwise, Unwrap returns nil.</source>
          <target state="translated">err의 유형에 오류를 리턴하는 Unwrap 메소드가 포함 된 경우 Unwrap은 err에서 Unwrap 메소드를 호출 한 결과를 리턴합니다. 그렇지 않으면 Unwrap은 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0674f5735125e15a98a0dd1cdad0bd08b0642deb" translate="yes" xml:space="preserve">
          <source>Unwrap returns the underlying error.</source>
          <target state="translated">Unwrap은 기본 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2facf8e427018a05d97ad6fa738413f526dc52de" translate="yes" xml:space="preserve">
          <source>Unwrap unpacks wrapped errors. If its argument's type has an Unwrap method, it calls the method once. Otherwise, it returns nil.</source>
          <target state="translated">랩 해제는 랩핑 된 오류를 언팩합니다. 인수 유형에 Unwrap 메소드가 있으면 메소드를 한 번 호출합니다. 그렇지 않으면 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2a313ddb07d29b1265d5875102d8b2f23477d34a" translate="yes" xml:space="preserve">
          <source>Update replaces an old node in the comment map with the new node and returns the new node. Comments that were associated with the old node are associated with the new node.</source>
          <target state="translated">업데이트는 주석 맵의 이전 노드를 새 노드로 바꾸고 새 노드를 반환합니다. 이전 노드와 연관된 주석은 새 노드와 연관됩니다.</target>
        </trans-unit>
        <trans-unit id="edb9e0c28d17431f4e5d015de98ef6d3ddc2e66d" translate="yes" xml:space="preserve">
          <source>Update returns the result of adding the bytes in p to the crc.</source>
          <target state="translated">Update는 p의 바이트를 crc에 추가 한 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="cec856deaea9fb4090c73c99e87c26b997d6e715" translate="yes" xml:space="preserve">
          <source>Usage prints a usage message documenting all defined command-line flags to CommandLine's output, which by default is os.Stderr. It is called when an error occurs while parsing flags. The function is a variable that may be changed to point to a custom function. By default it prints a simple header and calls PrintDefaults; for details about the format of the output and how to control it, see the documentation for PrintDefaults. Custom usage functions may choose to exit the program; by default exiting happens anyway as the command line's error handling strategy is set to ExitOnError.</source>
          <target state="translated">Usage는 정의 된 모든 명령 줄 플래그를 CommandLine의 출력 (기본적으로 os.Stderr)에 기록하는 사용 메시지를 인쇄합니다. 플래그를 구문 분석하는 동안 오류가 발생하면 호출됩니다. 함수는 사용자 정의 함수를 가리 키도록 변경 될 수있는 변수입니다. 기본적으로 간단한 헤더를 인쇄하고 PrintDefaults를 호출합니다. 출력 형식 및 제어 방법에 대한 자세한 내용은 PrintDefaults 설명서를 참조하십시오. 사용자 정의 사용 기능은 프로그램을 종료하도록 선택할 수 있습니다. 명령 행의 오류 처리 전략이 ExitOnError로 설정되어 있으면 기본적으로 종료가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="08b2986bb9311484289ed77e8cb011bc1a1a4415" translate="yes" xml:space="preserve">
          <source>Use GoTokens to configure the Scanner such that it accepts all Go literal tokens including Go identifiers. Comments will be skipped.</source>
          <target state="translated">Go 식별자를 포함하여 모든 Go 리터럴 토큰을 허용하도록 GoTokens를 사용하여 검사기를 구성하십시오. 댓글을 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="e7059998d0ef4d38492eb586594b1a7f2fda5597" translate="yes" xml:space="preserve">
          <source>Use a Scanner to implement a simple word-count utility by scanning the input as a sequence of space-delimited tokens.</source>
          <target state="translated">스캐너를 사용하여 공백으로 구분 된 일련의 토큰으로 입력을 스캔하여 간단한 단어 수 유틸리티를 구현하십시오.</target>
        </trans-unit>
        <trans-unit id="c7ed138fa83b46f7078f3eba45cc612903e73703" translate="yes" xml:space="preserve">
          <source>Use a Scanner with a custom split function (built by wrapping ScanWords) to validate 32-bit decimal input.</source>
          <target state="translated">32 비트 10 진수 입력의 유효성을 검사하려면 사용자 지정 분할 기능 (ScanWord를 래핑하여 구축)이있는 스캐너를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a131c39c2cc3965eeb7903a72d441b0e6edc8b39" translate="yes" xml:space="preserve">
          <source>Use a Scanner with a custom split function to parse a comma-separated list with an empty final value.</source>
          <target state="translated">사용자 정의 분할 기능이있는 스캐너를 사용하여 쉼표로 구분 된 목록을 빈 최종 값으로 구문 분석하십시오.</target>
        </trans-unit>
        <trans-unit id="3fe5cc9def42296a11d7d9a0af9fc8ea7342706f" translate="yes" xml:space="preserve">
          <source>Use context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions.</source>
          <target state="translated">선택적 매개 변수를 함수에 전달하는 것이 아니라 프로세스 및 API를 전송하는 요청 범위 데이터에만 컨텍스트 값을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b7726ad2d6a51eae4064f8abdd4f91a30451b9da" translate="yes" xml:space="preserve">
          <source>Use of this type presents a security risk: the encapsulated content should come from a trusted source, as it will be included verbatim in the template output.</source>
          <target state="translated">이 유형을 사용하면 보안 위험이 발생합니다. 캡슐화 된 콘텐츠는 템플릿 출력에 그대로 포함되므로 신뢰할 수있는 소스에서 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="34a9c66123dc40ac60f0472d60867161abcd1901" translate="yes" xml:space="preserve">
          <source>UseNumber causes the Decoder to unmarshal a number into an interface{} as a Number instead of as a float64.</source>
          <target state="translated">UseNumber는 디코더가 float64 대신 Number로 인터페이스 {}에서 숫자를 비 정렬 화합니다.</target>
        </trans-unit>
        <trans-unit id="b20930a62f52b49ee0781be625003d945b67da4b" translate="yes" xml:space="preserve">
          <source>User annotation</source>
          <target state="translated">사용자 주석</target>
        </trans-unit>
        <trans-unit id="fc3da515c7dc35d47639ea550f79310b8bc9a78e" translate="yes" xml:space="preserve">
          <source>User represents a user account.</source>
          <target state="translated">사용자는 사용자 계정을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d2b201b196f2c09ea10aa903c6f2d9d3642adbdc" translate="yes" xml:space="preserve">
          <source>User returns a Userinfo containing the provided username and no password set.</source>
          <target state="translated">사용자는 제공된 사용자 이름과 비밀번호를 설정하지 않은 Userinfo를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="68b7ed6f3fe5a5fff91e1492620a3db521e39f64" translate="yes" xml:space="preserve">
          <source>UserAgent returns the client's User-Agent, if sent in the request.</source>
          <target state="translated">UserAgent는 요청에서 전송 된 경우 클라이언트의 User-Agent를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4ea06ed977eda51c2aa11c6b438af4cabec784b4" translate="yes" xml:space="preserve">
          <source>UserCacheDir returns the default root directory to use for user-specific cached data. Users should create their own application-specific subdirectory within this one and use that.</source>
          <target state="translated">UserCacheDir은 사용자 별 캐시 데이터에 사용할 기본 루트 디렉토리를 반환합니다. 사용자는이 디렉토리 내에 고유 한 응용 프로그램 특정 서브 디렉토리를 작성하여 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="a2ed520c964d93e9ec6ba0898145eda2b4839b40" translate="yes" xml:space="preserve">
          <source>UserConfigDir returns the default root directory to use for user-specific configuration data. Users should create their own application-specific subdirectory within this one and use that.</source>
          <target state="translated">UserConfigDir은 사용자 별 구성 데이터에 사용할 기본 루트 디렉토리를 반환합니다. 사용자는이 디렉토리 내에 고유 한 응용 프로그램 특정 서브 디렉토리를 작성하여 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="28c75db53e54c3bd7c5a9e9bf84aa07645cd4dd7" translate="yes" xml:space="preserve">
          <source>UserHomeDir returns the current user's home directory.</source>
          <target state="translated">UserHomeDir은 현재 사용자의 홈 디렉토리를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e4af3b1e17fb9be937bdb3790d770684874f4388" translate="yes" xml:space="preserve">
          <source>UserPassword returns a Userinfo containing the provided username and password.</source>
          <target state="translated">UserPassword는 제공된 사용자 이름과 비밀번호가 포함 된 Userinfo를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="02f3110477b79296b9a835ccdda4c40254dba20b" translate="yes" xml:space="preserve">
          <source>UserTime returns the user CPU time of the exited process and its children.</source>
          <target state="translated">UserTime은 종료 된 프로세스 및 해당 자식의 사용자 CPU 시간을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="596b2947d671a1bd54b3952e3987a478fe9edb86" translate="yes" xml:space="preserve">
          <source>Username returns the username.</source>
          <target state="translated">사용자 이름은 사용자 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dc8f2880e32de7bce1932889e7d7d51c71d3c62a" translate="yes" xml:space="preserve">
          <source>Using GOOS=android matches build tags and files as for GOOS=linux in addition to android tags and files.</source>
          <target state="translated">GOOS = android를 사용하면 Android 태그 및 파일 외에 GOOS = linux와 마찬가지로 빌드 태그 및 파일과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="9ef58be31d291026b75b8271910eb178dd6cbe45" translate="yes" xml:space="preserve">
          <source>Using GOOS=illumos matches build tags and files as for GOOS=solaris in addition to illumos tags and files.</source>
          <target state="translated">GOOS = illumos를 사용하면 illumos 태그 및 파일 외에 GOOS = solaris와 마찬가지로 빌드 태그 및 파일을 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="c3fe6f0d858556f91b252b308d506eedd3cb2ddd" translate="yes" xml:space="preserve">
          <source>Using JS to include valid but untrusted JSON is not safe. A safe alternative is to parse the JSON with json.Unmarshal and then pass the resultant object into the template, where it will be converted to sanitized JSON when presented in a JavaScript context.</source>
          <target state="translated">JS를 사용하여 유효하지만 신뢰할 수없는 JSON을 포함하는 것은 안전하지 않습니다. 안전한 대안은 JSON을 json.Unmarshal로 구문 분석 한 다음 결과 객체를 템플릿으로 전달하면 JavaScript 컨텍스트에서 제시 될 때 위생 화 된 JSON으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="9d9125a7eed89278993fd187aca47dc4a1d76ad9" translate="yes" xml:space="preserve">
          <source>Using a nil Qualifier is equivalent to using (*Package).Path: the object is qualified by the import path, e.g., &quot;encoding/json.Marshal&quot;.</source>
          <target state="translated">nil 한정자를 사용하는 것은 (* Package) .Path를 사용하는 것과 같습니다. 경로 : 객체는 &quot;encoding / json.Marshal&quot;과 같은 가져 오기 경로로 한정됩니다.</target>
        </trans-unit>
        <trans-unit id="2513c3904b3d8adc521d8c82ea1568602dc6d76b" translate="yes" xml:space="preserve">
          <source>Uvarint</source>
          <target state="translated">Uvarint</target>
        </trans-unit>
        <trans-unit id="cd0cf1cee138a1f47260e7774925bd884f2375a8" translate="yes" xml:space="preserve">
          <source>Uvarint decodes a uint64 from buf and returns that value and the number of bytes read (&amp;gt; 0). If an error occurred, the value is 0 and the number of bytes n is &amp;lt;= 0 meaning:</source>
          <target state="translated">Uvarint는 buf에서 uint64를 디코딩하고 해당 값과 읽은 바이트 수 (&amp;gt; 0)를 반환합니다. 오류가 발생하면 값은 0이고 바이트 수 n은 &amp;lt;= 0을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="66771bf9a86898929e11d8280264a532271f941a" translate="yes" xml:space="preserve">
          <source>Val</source>
          <target state="translated">Val</target>
        </trans-unit>
        <trans-unit id="2bc81c70eb02eae4099191aef1e57849a8e8f03d" translate="yes" xml:space="preserve">
          <source>Val returns the constant's value.</source>
          <target state="translated">Val은 상수 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b0f7ad9f186c50db1236f5511239fa9e5948970e" translate="yes" xml:space="preserve">
          <source>Val returns the underlying value for a given constant. Since it returns an interface, it is up to the caller to type assert the result to the expected type. The possible dynamic return types are:</source>
          <target state="translated">Val은 주어진 상수의 기본 값을 반환합니다. 인터페이스를 반환하기 때문에 결과를 예상되는 유형으로 지정하는 것은 호출자에게 달려 있습니다. 가능한 동적 리턴 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2559cc6528d308a907426a71ef2ddf45113dcc96" translate="yes" xml:space="preserve">
          <source>Val returns the value associated with attribute Attr in Entry, or nil if there is no such attribute.</source>
          <target state="translated">Val은 항목의 속성 Attr과 관련된 값을 반환하거나 해당 속성이 없으면 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a4aefa35c3b5ad26cd56f18c500001b89f66a9ce" translate="yes" xml:space="preserve">
          <source>Valid</source>
          <target state="translated">Valid</target>
        </trans-unit>
        <trans-unit id="46c122fc5457cc399b8b858419e492a06b376755" translate="yes" xml:space="preserve">
          <source>Valid reports whether data is a valid JSON encoding.</source>
          <target state="translated">유효한 데이터가 유효한 JSON 인코딩인지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="806cc965cf7a7b71a612856c03f868243e886f5c" translate="yes" xml:space="preserve">
          <source>Valid reports whether p consists entirely of valid UTF-8-encoded runes.</source>
          <target state="translated">유효한 p가 유효한 UTF-8로 인코딩 된 룬으로 구성되어 있는지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="9519df7a8cc1237bbc29245d3ead17c2ceaba31e" translate="yes" xml:space="preserve">
          <source>ValidPath reports whether the given path name is valid for use in a call to Open.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c3cda690d8c1884d7b10ef8e13e38f05dfb3167" translate="yes" xml:space="preserve">
          <source>ValidRune</source>
          <target state="translated">ValidRune</target>
        </trans-unit>
        <trans-unit id="3e8899c82439ff69d29e69515b50bcac879155d8" translate="yes" xml:space="preserve">
          <source>ValidRune reports whether r can be legally encoded as UTF-8. Code points that are out of range or a surrogate half are illegal.</source>
          <target state="translated">ValidRune은 r을 UTF-8로 합법적으로 인코딩 할 수 있는지 여부를보고합니다. 범위를 벗어나거나 대리 절반이 아닌 코드 포인트는 불법입니다.</target>
        </trans-unit>
        <trans-unit id="a9473e977cedeea3732bd1f0e634158b2fc8bc9c" translate="yes" xml:space="preserve">
          <source>ValidString</source>
          <target state="translated">ValidString</target>
        </trans-unit>
        <trans-unit id="1965e2764de3dba462118d2aa14e90df90d22255" translate="yes" xml:space="preserve">
          <source>ValidString reports whether s consists entirely of valid UTF-8-encoded runes.</source>
          <target state="translated">ValidString은 s가 유효한 UTF-8로 인코딩 된 룬으로 구성되어 있는지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="c0a9babdac4db73aebddcf7c19ed25ebb45d7a5b" translate="yes" xml:space="preserve">
          <source>Validate performs basic sanity checks on the key. It returns nil if the key is valid, or else an error describing a problem.</source>
          <target state="translated">유효성 검사는 키에서 기본 상태 검사를 수행합니다. 키가 유효하면 nil을 반환하거나 문제를 설명하는 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="884a21f08ecc170ab0e83923a5cddfcafa2f19e8" translate="yes" xml:space="preserve">
          <source>Validator may be implemented by Conn to allow drivers to signal if a connection is valid or if it should be discarded.</source>
          <target state="translated">Conn은 Validator를 구현하여 드라이버가 연결이 유효한지 아니면 폐기해야하는지 신호를 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8dce170de238b1feda2ecd9674ea3ca0d068fbcb" translate="yes" xml:space="preserve">
          <source>Value</source>
          <target state="translated">Value</target>
        </trans-unit>
        <trans-unit id="f3016ae4e1764c831e22db266c9f3792b104f577" translate="yes" xml:space="preserve">
          <source>Value (Config)</source>
          <target state="translated">값 (구성)</target>
        </trans-unit>
        <trans-unit id="3b939f106840debe33fe7912aa5a94c4386c469d" translate="yes" xml:space="preserve">
          <source>Value (ReadMostly)</source>
          <target state="translated">가치 (대부분 읽기)</target>
        </trans-unit>
        <trans-unit id="2a2d06d73feadc3e81a5b950d3c3a1578785b1f4" translate="yes" xml:space="preserve">
          <source>Value implements the driver Valuer interface.</source>
          <target state="translated">Value는 드라이버 Valuer 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="dd218fab688fcead8af77b81093aadd12637b021" translate="yes" xml:space="preserve">
          <source>Value is a value that drivers must be able to handle. It is either nil, a type handled by a database driver's NamedValueChecker interface, or an instance of one of these types:</source>
          <target state="translated">값은 운전자가 처리 할 수있는 값입니다. nil, 데이터베이스 드라이버의 NamedValueChecker 인터페이스에 의해 처리되는 유형 또는 다음 유형 중 하나의 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="9752a7f3e66998d9403b579aaf11f5b93a26f7c0" translate="yes" xml:space="preserve">
          <source>Value is the documentation for a (possibly grouped) var or const declaration.</source>
          <target state="translated">값은 (그룹화 된) var 또는 const 선언에 대한 문서입니다.</target>
        </trans-unit>
        <trans-unit id="fc8bc38b52edf0162032e19caad204a132e1edc6" translate="yes" xml:space="preserve">
          <source>Value is the interface to the dynamic value stored in a flag. (The default value is represented as a string.)</source>
          <target state="translated">Value는 플래그에 저장된 동적 값에 대한 인터페이스입니다. (기본값은 문자열로 표시됩니다.)</target>
        </trans-unit>
        <trans-unit id="2c289f13fb553c52397f1f031c283edf2f75ba5d" translate="yes" xml:space="preserve">
          <source>Value is the reflection interface to a Go value.</source>
          <target state="translated">Value는 Go 값에 대한 리플렉션 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="f874cfa2eae8a5288d6bb67626a8a5b202b1f1d3" translate="yes" xml:space="preserve">
          <source>Value represents a JavaScript value. The zero value is the JavaScript value &quot;undefined&quot;.</source>
          <target state="translated">값은 JavaScript 값을 나타냅니다. 0 값은 JavaScript 값 &quot;undefined&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="12bd1222cbe13b8343d523bcfbb727dc870d622e" translate="yes" xml:space="preserve">
          <source>Value represents a JavaScript value. The zero value is the JavaScript value &quot;undefined&quot;. Values can be checked for equality with the Equal method.</source>
          <target state="translated">값은 JavaScript 값을 나타냅니다. 0 값은 JavaScript 값 &quot;정의되지 않음&quot;입니다. Equal 메서드를 사용하여 값이 같은지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="678d207a532dcdea8e626b9a2f73dbb88876a486" translate="yes" xml:space="preserve">
          <source>Value represents a metric value returned by the runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bea9dc918e0d02a53c6ed34890033d051d6e5b45" translate="yes" xml:space="preserve">
          <source>Value returns an arbitrary value of the given type. If the type implements the Generator interface, that will be used. Note: To create arbitrary values for structs, all the fields must be exported.</source>
          <target state="translated">값은 주어진 유형의 임의의 값을 반환합니다. 유형이 Generator 인터페이스를 구현하는 경우 해당 유형이 사용됩니다. 참고 : 구조체에 임의의 값을 만들려면 모든 필드를 내 보내야합니다.</target>
        </trans-unit>
        <trans-unit id="010d442068b6dc0c175fb3be2478e451331b7772" translate="yes" xml:space="preserve">
          <source>Value returns the value of the iterator's current map entry.</source>
          <target state="translated">Value는 반복자의 현재 맵 항목 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4814e1e8c0abd0c5b67abd9fa764cdfa19868250" translate="yes" xml:space="preserve">
          <source>ValueConverter is the interface providing the ConvertValue method.</source>
          <target state="translated">ValueConverter는 ConvertValue 메서드를 제공하는 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="bfff933f54248b785748322ae516a5abd89e358e" translate="yes" xml:space="preserve">
          <source>ValueKind is a tag for a metric Value which indicates its type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ee806fbc08f89d25017504477016f81d87178b9" translate="yes" xml:space="preserve">
          <source>ValueOf returns a new Value initialized to the concrete value stored in the interface i. ValueOf(nil) returns the zero Value.</source>
          <target state="translated">ValueOf는 인터페이스 i에 저장된 구체적인 값으로 초기화 된 새 값을 반환합니다. ValueOf (nil)은 0 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="73fa7582a50fd6ffa7153d229b6170f753731b5a" translate="yes" xml:space="preserve">
          <source>ValueOf returns x as a JavaScript value:</source>
          <target state="translated">ValueOf는 x를 JavaScript 값으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f18975e8d6052ff98ae55792b39100c67475c7da" translate="yes" xml:space="preserve">
          <source>Valuer is the interface providing the Value method.</source>
          <target state="translated">Valuer는 Value 메소드를 제공하는 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="b1564f6b1512cbfa3cfcebc9a5badb6b239954f1" translate="yes" xml:space="preserve">
          <source>Values</source>
          <target state="translated">Values</target>
        </trans-unit>
        <trans-unit id="4c4b32df8b9b0ab6cff257dc64ed3eb643572b49" translate="yes" xml:space="preserve">
          <source>Values containing the types defined in this package should not be copied.</source>
          <target state="translated">이 패키지에 정의 된 유형을 포함하는 값은 복사하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="db0f016ee293f8c7fb961ef81d6b041a8271fcde" translate="yes" xml:space="preserve">
          <source>Values maps a string key to a list of values. It is typically used for query parameters and form values. Unlike in the http.Header map, the keys in a Values map are case-sensitive.</source>
          <target state="translated">값은 문자열 키를 값 목록에 매핑합니다. 일반적으로 쿼리 매개 변수 및 양식 값에 사용됩니다. http.Header 맵과 달리 Values ​​맵의 키는 대소 문자를 구분합니다.</target>
        </trans-unit>
        <trans-unit id="ed9ae6e1ddce7aa950c188cea7070152cbaaef3a" translate="yes" xml:space="preserve">
          <source>Values of IMAGE_FILE_HEADER.Characteristics. These can be combined together.</source>
          <target state="translated">IMAGE_FILE_HEADER.Characteristics의 값. 이들은 함께 결합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1b6d5f206af70bb39bd5fc526ef574743992a54" translate="yes" xml:space="preserve">
          <source>Values of the Image interface are created either by calling functions such as NewRGBA and NewPaletted, or by calling Decode on an io.Reader containing image data in a format such as GIF, JPEG or PNG. Decoding any particular image format requires the prior registration of a decoder function. Registration is typically automatic as a side effect of initializing that format's package so that, to decode a PNG image, it suffices to have</source>
          <target state="translated">이미지 인터페이스의 값은 NewRGBA 및 NewPaletted와 같은 함수를 호출하거나 GIF, JPEG 또는 PNG와 같은 형식으로 이미지 데이터가 포함 된 io.Reader에서 Decode를 호출하여 생성됩니다. 특정 이미지 형식을 디코딩하려면 디코더 기능을 사전에 등록해야합니다. PNG 이미지를 디코딩하기 위해서는 해당 형식의 패키지를 초기화하는 부작용으로 일반적으로 등록이 자동으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="b65743fb1655a6d5656fe5188b8219e485d45a6c" translate="yes" xml:space="preserve">
          <source>Values returns all values associated with the given key. It is case insensitive; CanonicalMIMEHeaderKey is used to canonicalize the provided key. To use non-canonical keys, access the map directly. The returned slice is not a copy.</source>
          <target state="translated">값은 주어진 키와 관련된 모든 값을 반환합니다. 대소 문자를 구분하지 않습니다. CanonicalMIMEHeaderKey는 제공된 키를 정규화하는 데 사용됩니다. 비표준 키를 사용하려면지도에 직접 액세스하세요. 반환 된 슬라이스는 복사본이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="d0f032ed754eb781ca5f1ab9c0d5896202022c92" translate="yes" xml:space="preserve">
          <source>Values returns all values associated with the given key. It is case insensitive; textproto.CanonicalMIMEHeaderKey is used to canonicalize the provided key. To use non-canonical keys, access the map directly. The returned slice is not a copy.</source>
          <target state="translated">값은 주어진 키와 관련된 모든 값을 반환합니다. 대소 문자를 구분하지 않습니다. textproto.CanonicalMIMEHeaderKey는 제공된 키를 정규화하는 데 사용됩니다. 비표준 키를 사용하려면지도에 직접 액세스하세요. 반환 된 슬라이스는 복사본이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="556542fae1b8220ad354f73db7960fdf03643304" translate="yes" xml:space="preserve">
          <source>Values that are shared by both R_PPC and R_PPC64 are prefixed with R_POWERPC_ in the ELF standard. For the R_PPC type, the relevant shared relocations have been renamed with the prefix R_PPC_. The original name follows the value in a comment.</source>
          <target state="translated">R_PPC 및 R_PPC64가 공유하는 값은 ELF 표준에서 R_POWERPC_로 시작됩니다. R_PPC 유형의 경우 관련 공유 재배치의 이름이 접두사 R_PPC_로 바뀌 었습니다. 원래 이름은 주석의 값 뒤에옵니다.</target>
        </trans-unit>
        <trans-unit id="35513df4822daf6991ea9831d940cbcb44ab9510" translate="yes" xml:space="preserve">
          <source>Values that are shared by both R_PPC and R_PPC64 are prefixed with R_POWERPC_ in the ELF standard. For the R_PPC64 type, the relevant shared relocations have been renamed with the prefix R_PPC64_. The original name follows the value in a comment.</source>
          <target state="translated">R_PPC 및 R_PPC64가 공유하는 값은 ELF 표준에서 R_POWERPC_로 시작됩니다. R_PPC64 유형의 경우 관련 공유 재배치의 이름이 접두사 R_PPC64_로 바뀌 었습니다. 원래 이름은 주석의 값 뒤에옵니다.</target>
        </trans-unit>
        <trans-unit id="5491dd2526a7b6a12fe2eb7a45fdc97e08387c1a" translate="yes" xml:space="preserve">
          <source>Var defines a flag with the specified name and usage string. The type and value of the flag are represented by the first argument, of type Value, which typically holds a user-defined implementation of Value. For instance, the caller could create a flag that turns a comma-separated string into a slice of strings by giving the slice the methods of Value; in particular, Set would decompose the comma-separated string into the slice.</source>
          <target state="translated">Var는 지정된 이름과 사용 문자열로 플래그를 정의합니다. 플래그의 유형과 값은 일반적으로 사용자 정의 Value 구현을 보유하는 Value 유형의 첫 번째 인수로 표시됩니다. 예를 들어, 호출자는 슬라이스에 Value 메서드를 제공하여 쉼표로 구분 된 문자열을 문자열 조각으로 바꾸는 플래그를 만들 수 있습니다. 특히 Set은 쉼표로 구분 된 문자열을 슬라이스로 분해합니다.</target>
        </trans-unit>
        <trans-unit id="ce2b2698fd744904596b638fadb24e9ac560ff55" translate="yes" xml:space="preserve">
          <source>Var is an abstract type for all exported variables.</source>
          <target state="translated">Var은 내 보낸 모든 변수에 대한 추상 유형입니다.</target>
        </trans-unit>
        <trans-unit id="2fe39193f9c048f94aabb561a65b8ad4ebd4664a" translate="yes" xml:space="preserve">
          <source>VariableNode holds a list of variable names, possibly with chained field accesses. The dollar sign is part of the (first) name.</source>
          <target state="translated">VariableNode는 가능한 체인 필드 액세스와 함께 변수 이름 목록을 보유합니다. 달러 기호는 (이름) 이름의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="f9c863db27e83db40f4468fc4bc690e601042fdf" translate="yes" xml:space="preserve">
          <source>Variables previously declared can also be assigned, using the syntax</source>
          <target state="translated">구문을 사용하여 이전에 선언 된 변수를 할당 할 수도 있습니다</target>
        </trans-unit>
        <trans-unit id="ca11a0cc5def9c210a74faf8ede1798e07fe2571" translate="yes" xml:space="preserve">
          <source>Variadic reports whether the signature s is variadic.</source>
          <target state="translated">Variadic는 서명이 가변적인지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="41d79747265706c0afa494f13a1d7304f4478119" translate="yes" xml:space="preserve">
          <source>Varint</source>
          <target state="translated">Varint</target>
        </trans-unit>
        <trans-unit id="f5ebfb0ae8769b5ca2188331b009d7eba5a85341" translate="yes" xml:space="preserve">
          <source>Varint decodes an int64 from buf and returns that value and the number of bytes read (&amp;gt; 0). If an error occurred, the value is 0 and the number of bytes n is &amp;lt;= 0 with the following meaning:</source>
          <target state="translated">Varint는 buf에서 int64를 해독하고 그 값과 읽은 바이트 수 (&amp;gt; 0)를 반환합니다. 오류가 발생하면 값은 0이고 바이트 수 n은 &amp;lt;= 0이며 다음과 같은 의미입니다.</target>
        </trans-unit>
        <trans-unit id="d24fa62b1d834d7cd3cd0e8882051f85d094eda3" translate="yes" xml:space="preserve">
          <source>Various errors contained in OpError.</source>
          <target state="translated">OpError에 포함 된 다양한 오류.</target>
        </trans-unit>
        <trans-unit id="1a2978dcc531a211271eca6e53e9367381806a65" translate="yes" xml:space="preserve">
          <source>Various implementations of ValueConverter are provided by the driver package to provide consistent implementations of conversions between drivers. The ValueConverters have several uses:</source>
          <target state="translated">드라이버 간 변환의 일관된 구현을 제공하기 위해 드라이버 패키지에서 다양한 ValueConverter 구현을 제공합니다. ValueConverters는 여러 용도로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="677405d5dfca724a737bda64c6dc1ddb03f2bb84" translate="yes" xml:space="preserve">
          <source>Various isolation levels that drivers may support in BeginTx. If a driver does not support a given isolation level an error may be returned.</source>
          <target state="translated">드라이버가 BeginTx에서 지원할 수있는 다양한 격리 수준. 드라이버가 지정된 격리 수준을 지원하지 않으면 오류가 반환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc21bbee9a9b0425c95545ecf2f53bc29369d55b" translate="yes" xml:space="preserve">
          <source>Various methods support conversions between strings and corresponding numeric values, and vice versa: *Int, *Rat, and *Float values implement the Stringer interface for a (default) string representation of the value, but also provide SetString methods to initialize a value from a string in a variety of supported formats (see the respective SetString documentation).</source>
          <target state="translated">* Int, * Rat 및 * Float 값은 값의 (기본) 문자열 표현을위한 Stringer 인터페이스를 구현하지만 SetString 메소드를 제공하여 값을 초기화합니다. 지원되는 다양한 형식의 문자열 (각 SetString 설명서 참조)</target>
        </trans-unit>
        <trans-unit id="fe5502979be4e45317e06e3f4bc8dea3c27b9d68" translate="yes" xml:space="preserve">
          <source>Verbose reports whether the -test.v flag is set.</source>
          <target state="translated">상세는 -test.v 플래그 설정 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="155a05e64e4d5e6d0dbf5afad455ef4b2c7d215e" translate="yes" xml:space="preserve">
          <source>Verify attempts to verify c by building one or more chains from c to a certificate in opts.Roots, using certificates in opts.Intermediates if needed. If successful, it returns one or more chains where the first element of the chain is c and the last element is from opts.Roots.</source>
          <target state="translated">필요한 경우 opts.Intermediates의 인증서를 사용하여 c에서 opts.Roots의 인증서로 하나 이상의 체인을 빌드하여 c를 확인하려는 시도를 확인하십시오. 성공하면 체인의 첫 번째 요소가 c이고 마지막 요소가 opts.Roots 인 하나 이상의 체인을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8f646662ac01cb1ef7a3f3dbe169c861f558bcfa" translate="yes" xml:space="preserve">
          <source>Verify checks the validity of an email address on the server. If Verify returns nil, the address is valid. A non-nil return does not necessarily indicate an invalid address. Many servers will not verify addresses for security reasons.</source>
          <target state="translated">확인은 서버에서 이메일 주소의 유효성을 확인합니다. Verify가 nil을 반환하면 주소가 유효합니다. 0이 아닌 리턴이 반드시 유효하지 않은 주소를 나타내는 것은 아닙니다. 많은 서버가 보안상의 이유로 주소를 확인하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5f78fb77229812b310f6d30ba2f8eeb1a758e0db" translate="yes" xml:space="preserve">
          <source>Verify reports whether sig is a valid signature of message by publicKey. It will panic if len(publicKey) is not PublicKeySize.</source>
          <target state="translated">확인은 sig가 publicKey에 의해 유효한 메시지 서명인지보고합니다. len (publicKey)이 PublicKeySize가 아닌 경우 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="afa19e9e5042f2e1366a51a651d0d42c62c9a9dc" translate="yes" xml:space="preserve">
          <source>Verify verifies the signature in r, s of hash using the public key, pub. It reports whether the signature is valid.</source>
          <target state="translated">공개 키 pub를 사용하여 해시의 r, s로 서명을 확인하십시오. 서명이 유효한지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="29e311050b6e4da19e97375079ff2944ac6c7fb5" translate="yes" xml:space="preserve">
          <source>Verify verifies the signature in r, s of hash using the public key, pub. Its return value records whether the signature is valid.</source>
          <target state="translated">공개 키 pub를 사용하여 해시의 r, s로 서명을 확인하십시오. 리턴 값은 서명이 유효한지 여부를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="145232aacf42696b4e278956de6bab24512004cd" translate="yes" xml:space="preserve">
          <source>VerifyASN1 verifies the ASN.1 encoded signature, sig, of hash using the public key, pub. Its return value records whether the signature is valid.</source>
          <target state="translated">VerifyASN1은 공개 키 pub를 사용하여 해시의 ASN.1 인코딩 서명 sig를 확인합니다. 반환 값은 서명이 유효한지 여부를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="c77ce67480dc146ec9f71541bb8eac40755f84ee" translate="yes" xml:space="preserve">
          <source>VerifyHostname checks that the peer certificate chain is valid for connecting to host. If so, it returns nil; if not, it returns an error describing the problem.</source>
          <target state="translated">VerifyHostname은 피어 인증서 체인이 호스트에 연결하기에 유효한지 확인합니다. 그렇다면 nil을 반환합니다. 그렇지 않으면 문제를 설명하는 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4d87443c0e8c5a2665736c35fe304b37073dc32e" translate="yes" xml:space="preserve">
          <source>VerifyHostname returns nil if c is a valid certificate for the named host. Otherwise it returns an error describing the mismatch.</source>
          <target state="translated">c가 명명 된 호스트에 유효한 인증서 인 경우 VerifyHostname은 nil을 반환합니다. 그렇지 않으면 불일치를 설명하는 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f86ef4530b45b573b44981bfecb27623cddb836c" translate="yes" xml:space="preserve">
          <source>VerifyOptions contains parameters for Certificate.Verify.</source>
          <target state="translated">VerifyOptions에는 Certificate.Verify에 대한 매개 변수가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3cca137a6af7f592d32076ad3b96f2dd532d13e4" translate="yes" xml:space="preserve">
          <source>VerifyOptions contains parameters for Certificate.Verify. It's a structure because other PKIX verification APIs have ended up needing many options.</source>
          <target state="translated">VerifyOptions에는 Certificate.Verify에 대한 매개 변수가 포함되어 있습니다. 다른 PKIX 검증 API에는 많은 옵션이 필요하기 때문에 구조입니다.</target>
        </trans-unit>
        <trans-unit id="904631d00687a7288866da49169708056e59b147" translate="yes" xml:space="preserve">
          <source>VerifyPKCS1v15</source>
          <target state="translated">VerifyPKCS1v15</target>
        </trans-unit>
        <trans-unit id="03648c01c4f8ec482385a7d7d5a6f43278916d7d" translate="yes" xml:space="preserve">
          <source>VerifyPKCS1v15 verifies an RSA PKCS #1 v1.5 signature. hashed is the result of hashing the input message using the given hash function and sig is the signature. A valid signature is indicated by returning a nil error. If hash is zero then hashed is used directly. This isn't advisable except for interoperability.</source>
          <target state="translated">VerifyPKCS1v15는 RSA PKCS # 1 v1.5 서명을 확인합니다. hashed는 주어진 해시 함수를 사용하여 입력 메시지를 해싱 한 결과이고 sig는 서명입니다. 유효한 서명은 nil 오류를 반환하여 표시됩니다. 해시가 0이면 해시가 직접 사용됩니다. 이것은 상호 운용성을 제외하고는 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7fac2ac8cef2b4f2fce0053008362560cd0a7f6f" translate="yes" xml:space="preserve">
          <source>VerifyPKCS1v15 verifies an RSA PKCS#1 v1.5 signature. hashed is the result of hashing the input message using the given hash function and sig is the signature. A valid signature is indicated by returning a nil error. If hash is zero then hashed is used directly. This isn't advisable except for interoperability.</source>
          <target state="translated">VerifyPKCS1v15는 RSA PKCS # 1 v1.5 서명을 확인합니다. 해시는 주어진 해시 함수를 사용하여 입력 메시지를 해시 한 결과이고 sig는 서명입니다. 유효한 서명은 nil 오류를 반환하여 표시됩니다. 해시가 0이면 해시가 직접 사용됩니다. 상호 운용성을 제외하고는 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="22849df5c99a08214a361cc786e111d1f4ddafec" translate="yes" xml:space="preserve">
          <source>VerifyPSS verifies a PSS signature.</source>
          <target state="translated">VerifyPSS는 PSS 서명을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="a12022e4f1f957db46b6ad31ae0c6d8b5b335f06" translate="yes" xml:space="preserve">
          <source>VerifyPSS verifies a PSS signature. hashed is the result of hashing the input message using the given hash function and sig is the signature. A valid signature is indicated by returning a nil error. The opts argument may be nil, in which case sensible defaults are used.</source>
          <target state="translated">VerifyPSS는 PSS 서명을 확인합니다. 해시는 주어진 해시 함수를 사용하여 입력 메시지를 해시 한 결과이고 sig는 서명입니다. 유효한 서명은 nil 오류를 반환하여 표시됩니다. opts 인수는 nil 일 수 있으며이 경우 적절한 기본값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fc50bdb16e95dd81d5ab93336a4873d743e71e10" translate="yes" xml:space="preserve">
          <source>Version is found in Header.Ident[EI_VERSION] and Header.Version.</source>
          <target state="translated">버전은 Header.Ident [EI_VERSION] 및 Header.Version에 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d5c372788d86ffb1bb307fe18c33d0d35dfaf32" translate="yes" xml:space="preserve">
          <source>Version is the Unicode edition from which the tables are derived.</source>
          <target state="translated">버전은 테이블이 파생 된 유니 코드 버전입니다.</target>
        </trans-unit>
        <trans-unit id="50de89df378f68937423c4c0b0df29cc9d671898" translate="yes" xml:space="preserve">
          <source>Version returns the Go tree's version string. It is either the commit hash and date at the time of the build or, when possible, a release tag like &quot;go1.3&quot;.</source>
          <target state="translated">Version은 Go Tree의 버전 문자열을 반환합니다. 빌드 시점의 커밋 해시 및 날짜이거나 가능한 경우 &quot;go1.3&quot;과 같은 릴리스 태그입니다.</target>
        </trans-unit>
        <trans-unit id="a9f8b9e002c84b093e85fe6340e9e2446c0f01f6" translate="yes" xml:space="preserve">
          <source>Very large values overflow to -1 or +Inf.</source>
          <target state="translated">매우 큰 값은 -1 또는 + Inf로 오버플로됩니다.</target>
        </trans-unit>
        <trans-unit id="62ec9d14e878063c7140d04d700991af277e0332" translate="yes" xml:space="preserve">
          <source>Very large values overflow to 0 or +Inf. Very small values underflow to 1.</source>
          <target state="translated">매우 큰 값은 0 또는 + Inf로 오버플로됩니다. 매우 작은 값은 1로 유입됩니다.</target>
        </trans-unit>
        <trans-unit id="548f7438120baf452d57249c7ed1e4259eddd666" translate="yes" xml:space="preserve">
          <source>Visit visits the command-line flags in lexicographical order, calling fn for each. It visits only those flags that have been set.</source>
          <target state="translated">방문은 명령 행 플래그를 사전 식 순서로 방문하고 각각에 대해 fn을 호출합니다. 설정된 플래그 만 방문합니다.</target>
        </trans-unit>
        <trans-unit id="3d71d97888658f2741fa47ca0e6dafd3ee5bd8d5" translate="yes" xml:space="preserve">
          <source>Visit visits the flags in lexicographical order, calling fn for each. It visits only those flags that have been set.</source>
          <target state="translated">방문은 사전에 순서대로 플래그를 방문하고 각각에 대해 fn을 호출합니다. 설정된 플래그 만 방문합니다.</target>
        </trans-unit>
        <trans-unit id="fe139ba7798500e37c921c3f2eca473d92def875" translate="yes" xml:space="preserve">
          <source>VisitAll visits the command-line flags in lexicographical order, calling fn for each. It visits all flags, even those not set.</source>
          <target state="translated">VisitAll은 명령 행 플래그를 사전 식 순서로 방문하고 각각에 대해 fn을 호출합니다. 설정되지 않은 플래그까지 모든 플래그를 방문합니다.</target>
        </trans-unit>
        <trans-unit id="91926cb218ad9a9f08c7f40210f9b3b594b76515" translate="yes" xml:space="preserve">
          <source>VisitAll visits the flags in lexicographical order, calling fn for each. It visits all flags, even those not set.</source>
          <target state="translated">VisitAll은 각각 fn을 호출하여 사전 순으로 플래그를 방문합니다. 설정되지 않은 플래그까지 모든 플래그를 방문합니다.</target>
        </trans-unit>
        <trans-unit id="82b27aedf84d8e8a368898854887f1a9db2938b6" translate="yes" xml:space="preserve">
          <source>VolumeName returns leading volume name. Given &quot;C:\foo\bar&quot; it returns &quot;C:&quot; on Windows. Given &quot;\\host\share\foo&quot; it returns &quot;\\host\share&quot;. On other platforms it returns &quot;&quot;.</source>
          <target state="translated">VolumeName은 선행 볼륨 이름을 반환합니다. &quot;C : \ foo \ bar&quot;가 주어지면 Windows에서 &quot;C :&quot;를 반환합니다. &quot;\\ host \ share \ foo&quot;가 주어지면 &quot;\\ host \ share&quot;를 반환합니다. 다른 플랫폼에서는 &quot;&quot;를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="116af4a220931a113874c3a9a8fb8b67e737c229" translate="yes" xml:space="preserve">
          <source>WARNING: this function doesn't do any revocation checking.</source>
          <target state="translated">경고 :이 기능은 해지 확인을 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ac3ed0238ed01e1e125ce49b809e2689db256bfa" translate="yes" xml:space="preserve">
          <source>WARNING: use of this function to encrypt plaintexts other than session keys is dangerous. Use RSA OAEP in new protocols.</source>
          <target state="translated">경고 :이 기능을 사용하여 세션 키 이외의 일반 텍스트를 암호화하는 것은 위험합니다. 새로운 프로토콜에 RSA OAEP를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d791440e471e57ef06317ea366a55351a6722e8d" translate="yes" xml:space="preserve">
          <source>Wait atomically unlocks c.L and suspends execution of the calling goroutine. After later resuming execution, Wait locks c.L before returning. Unlike in other systems, Wait cannot return unless awoken by Broadcast or Signal.</source>
          <target state="translated">대기는 원자 적으로 cL을 잠금 해제하고 호출 고 루틴의 실행을 일시 중단합니다. 나중에 실행을 다시 시작한 후 대기는 반환하기 전에 cL을 잠급니다. 다른 시스템과 달리 방송 또는 신호에 의해 깨어나지 않으면 대기는 되돌릴 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c1e4ec07809f552042a2744ebd76a1ff9cdfd927" translate="yes" xml:space="preserve">
          <source>Wait blocks until the WaitGroup counter is zero.</source>
          <target state="translated">WaitGroup 카운터가 0이 될 때까지 대기합니다.</target>
        </trans-unit>
        <trans-unit id="a2b93a450c159447eb449f1d44b9509d23d1eff8" translate="yes" xml:space="preserve">
          <source>Wait releases any resources associated with the Cmd.</source>
          <target state="translated">대기는 Cmd와 관련된 모든 리소스를 해제합니다.</target>
        </trans-unit>
        <trans-unit id="cecb6db143b18629c77edfdcfa6e40a828bd3ecd" translate="yes" xml:space="preserve">
          <source>Wait waits for the Process to exit, and then returns a ProcessState describing its status and an error, if any. Wait releases any resources associated with the Process. On most operating systems, the Process must be a child of the current process or an error will be returned.</source>
          <target state="translated">Wait는 프로세스가 종료 될 때까지 기다린 다음 해당 상태 및 오류 (있는 경우)를 설명하는 ProcessState를 반환합니다. 대기는 프로세스와 관련된 모든 자원을 해제합니다. 대부분의 운영 체제에서 프로세스는 현재 프로세스의 자식이어야합니다. 그렇지 않으면 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ef4d163f70a5558cd92581c6468ca54f951f10cb" translate="yes" xml:space="preserve">
          <source>Wait waits for the command to exit and waits for any copying to stdin or copying from stdout or stderr to complete.</source>
          <target state="translated">대기 명령이 종료 될 때까지 대기하고 stdin으로의 복사 또는 stdout 또는 stderr에서 복사가 완료 될 때까지 대기합니다.</target>
        </trans-unit>
        <trans-unit id="aea382006d640fdfa58d59c1e0ad39798008158f" translate="yes" xml:space="preserve">
          <source>Wait will close the pipe after seeing the command exit, so most callers need not close the pipe themselves. It is thus incorrect to call Wait before all reads from the pipe have completed. For the same reason, it is incorrect to call Run when using StdoutPipe. See the example for idiomatic usage.</source>
          <target state="translated">Wait는 명령 종료를 확인한 후 파이프를 닫으므로 대부분의 호출자가 파이프를 닫을 필요가 없습니다. 따라서 파이프의 모든 읽기가 완료되기 전에 Wait를 호출하는 것은 올바르지 않습니다. 같은 이유로 StdoutPipe를 사용할 때 Run을 호출하는 것은 올바르지 않습니다. 관용적 사용법에 대한 예를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4d3243a3ead84d3a842320a1e7a6c5fbcf29075e" translate="yes" xml:space="preserve">
          <source>Wait will close the pipe after seeing the command exit, so most callers need not close the pipe themselves. It is thus incorrect to call Wait before all reads from the pipe have completed. For the same reason, it is incorrect to use Run when using StderrPipe. See the StdoutPipe example for idiomatic usage.</source>
          <target state="translated">Wait는 명령 종료를 확인한 후 파이프를 닫으므로 대부분의 호출자가 파이프를 닫을 필요가 없습니다. 따라서 파이프의 모든 읽기가 완료되기 전에 Wait를 호출하는 것은 올바르지 않습니다. 같은 이유로 StderrPipe를 사용할 때 Run을 사용하는 것은 올바르지 않습니다. 관용적 사용법은 StdoutPipe 예제를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e61dcf7176445918332c5c75e515641021cd367b" translate="yes" xml:space="preserve">
          <source>Wait will close the pipe after seeing the command exit, so most callers need not close the pipe themselves; however, an implication is that it is incorrect to call Wait before all reads from the pipe have completed. For the same reason, it is incorrect to call Run when using StdoutPipe. See the example for idiomatic usage.</source>
          <target state="translated">대기는 명령 종료를 본 후 파이프를 닫을 것이므로 대부분의 호출자는 파이프 자체를 닫을 필요가 없습니다. 그러나 파이프에서 모든 읽기가 완료되기 전에 대기를 호출하는 것은 올바르지 않습니다. 같은 이유로 StdoutPipe를 사용할 때 Run을 호출하는 것은 올바르지 않습니다. 관용어 사용 예를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6e2d628a299984437542474f102b1e387913aa4f" translate="yes" xml:space="preserve">
          <source>Wait will close the pipe after seeing the command exit, so most callers need not close the pipe themselves; however, an implication is that it is incorrect to call Wait before all reads from the pipe have completed. For the same reason, it is incorrect to use Run when using StderrPipe. See the StdoutPipe example for idiomatic usage.</source>
          <target state="translated">대기는 명령 종료를 본 후 파이프를 닫을 것이므로 대부분의 호출자는 파이프 자체를 닫을 필요가 없습니다. 그러나 파이프에서 모든 읽기가 완료되기 전에 대기를 호출하는 것은 올바르지 않습니다. 같은 이유로 StderrPipe를 사용할 때 Run을 사용하는 것은 올바르지 않습니다. 관용적 사용법은 StdoutPipe 예제를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="66edd56a29d8f65f00197517346652171bdf474e" translate="yes" xml:space="preserve">
          <source>WaitGroup</source>
          <target state="translated">WaitGroup</target>
        </trans-unit>
        <trans-unit id="e0c705d18e3fae4506d7273bda6435690cdbde08" translate="yes" xml:space="preserve">
          <source>Walk</source>
          <target state="translated">Walk</target>
        </trans-unit>
        <trans-unit id="52552b817eeffba362a3c98137f71c8293e62c3c" translate="yes" xml:space="preserve">
          <source>Walk calls the function with a non-nil err argument in two cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9374260d790571a0abca3c2ad0ee8f4b2fee093" translate="yes" xml:space="preserve">
          <source>Walk does not follow symbolic links.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29ff2f8a0272ea96bdd57633837c4d9205c5c003" translate="yes" xml:space="preserve">
          <source>Walk is less efficient than WalkDir, introduced in Go 1.16, which avoids calling os.Lstat on every visited file or directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9272862a0570cd3c8a576242d0e65b3cfcf9dde3" translate="yes" xml:space="preserve">
          <source>Walk traverses an AST in depth-first order: It starts by calling v.Visit(node); node must not be nil. If the visitor w returned by v.Visit(node) is not nil, Walk is invoked recursively with visitor w for each of the non-nil children of node, followed by a call of w.Visit(nil).</source>
          <target state="translated">Walk는 AST를 깊이 우선 순서로 트래버스합니다. v.Visit (node); 노드는 0이 아니어야합니다. v.Visit (node)에 의해 리턴 된 방문자 w가 nil이 아닌 경우, 노드의 nil이 아닌 각 하위 노드에 대해 방문자 w와 함께 Walk가 재귀 적으로 호출 된 후 w.Visit (nil)가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="448218872286b5074a9a3f4fa32510a7919bca39" translate="yes" xml:space="preserve">
          <source>Walk walks the file tree rooted at root, calling fn for each file or directory in the tree, including root.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="844997b7d380cfffe958c2b4b63e117129683358" translate="yes" xml:space="preserve">
          <source>Walk walks the file tree rooted at root, calling walkFn for each file or directory in the tree, including root. All errors that arise visiting files and directories are filtered by walkFn. The files are walked in lexical order, which makes the output deterministic but means that for very large directories Walk can be inefficient. Walk does not follow symbolic links.</source>
          <target state="translated">Walk는 루트를 기반으로하는 파일 트리를 걷고 루트를 포함하여 트리의 각 파일 또는 디렉토리에 대해 walkFn을 호출합니다. 파일 및 디렉토리 방문시 발생하는 모든 오류는 walkFn으로 필터링됩니다. 파일은 어휘 순서로 표시되므로 출력이 결정적이지만 매우 큰 디렉토리의 경우 Walk가 비효율적 일 수 있습니다. 도보는 기호 링크를 따르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3474b62445a988d8dd7132a772a85658690ff2ba" translate="yes" xml:space="preserve">
          <source>WalkDir calls the function with a non-nil err argument in two cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2909c3003cad6334b97769f490356bda189f1f4c" translate="yes" xml:space="preserve">
          <source>WalkDir does not follow symbolic links found in directories, but if root itself is a symbolic link, its target will be walked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2944078867d26e9f67caf63090c30efa8665e473" translate="yes" xml:space="preserve">
          <source>WalkDir does not follow symbolic links.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4671bbf058367649fe2ca3dc374a89674b38ba9a" translate="yes" xml:space="preserve">
          <source>WalkDir walks the file tree rooted at root, calling fn for each file or directory in the tree, including root.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71a3cdec2023da7868097ad68f8742c9c0a18055" translate="yes" xml:space="preserve">
          <source>WalkDirFunc is the type of the function called by WalkDir to visit each file or directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a839647907d9b3be60eae8967669c7e1dc729b5" translate="yes" xml:space="preserve">
          <source>WalkFunc is the type of the function called by Walk to visit each each file or directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea8fd18744a5b8a94a61df0e6be7f9d622440bee" translate="yes" xml:space="preserve">
          <source>WalkFunc is the type of the function called for each file or directory visited by Walk. The path argument contains the argument to Walk as a prefix; that is, if Walk is called with &quot;dir&quot;, which is a directory containing the file &quot;a&quot;, the walk function will be called with argument &quot;dir/a&quot;. The info argument is the os.FileInfo for the named path.</source>
          <target state="translated">WalkFunc는 Walk가 방문한 각 파일 또는 디렉토리에 대해 호출되는 함수 유형입니다. path 인수에는 Walk를 접두사로 사용하는 인수가 포함됩니다. 즉, &quot;a&quot;파일을 포함하는 디렉토리 인 &quot;dir&quot;을 사용하여 Walk를 호출하면 &quot;dir / a&quot;인수를 사용하여 walk 함수가 호출됩니다. info 인수는 명명 된 경로의 os.FileInfo입니다.</target>
        </trans-unit>
        <trans-unit id="2918ed6d5c509e3ed1b93a9bceda4782bc8dd955" translate="yes" xml:space="preserve">
          <source>Warning logs a message with severity LOG_WARNING, ignoring the severity passed to New.</source>
          <target state="translated">경고는 심각도가 LOG_WARNING 인 메시지를 기록하며 심각도는 New로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="6dda0897da5609f90207d91adc268a59c4a1ed0a" translate="yes" xml:space="preserve">
          <source>We define codes for each error that manifests while escaping templates, but escaped templates may also fail at runtime.</source>
          <target state="translated">템플릿을 이스케이프하는 동안 나타나는 각 오류에 대한 코드를 정의하지만 이스케이프 된 템플릿도 런타임에 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c1d860c4500491f651fd6c28babc0fc5252a9c1" translate="yes" xml:space="preserve">
          <source>WebSafe is a 216-color palette that was popularized by early versions of Netscape Navigator. It is also known as the Netscape Color Cube.</source>
          <target state="translated">WebSafe는 초기 버전의 Netscape Navigator에서 대중화 된 216 색 팔레트입니다. Netscape Color Cube라고도합니다.</target>
        </trans-unit>
        <trans-unit id="9b612a9be3daa519fe810c831ee09c50cb694cd9" translate="yes" xml:space="preserve">
          <source>Weekday returns the day of the week specified by t.</source>
          <target state="translated">Weekday는 t로 지정된 요일을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f665bbd01fb3804e446b49c63f8771aa2a58f0dc" translate="yes" xml:space="preserve">
          <source>Well-known IPv4 addresses</source>
          <target state="translated">잘 알려진 IPv4 주소</target>
        </trans-unit>
        <trans-unit id="d1c37cf7857b91d487793e2b066aa7768c44b584" translate="yes" xml:space="preserve">
          <source>Well-known IPv6 addresses</source>
          <target state="translated">잘 알려진 IPv6 주소</target>
        </trans-unit>
        <trans-unit id="423b2ce203c11b513c12b2cf5a302bece806d9e9" translate="yes" xml:space="preserve">
          <source>When Go code is built with options like -buildmode=c-shared, it will be run as part of an existing non-Go program. The non-Go code may have already installed signal handlers when the Go code starts (that may also happen in unusual cases when using cgo or SWIG; in that case, the discussion here applies). For -buildmode=c-archive the Go runtime will initialize signals at global constructor time. For -buildmode=c-shared the Go runtime will initialize signals when the shared library is loaded.</source>
          <target state="translated">Go 코드가 -buildmode = c-shared와 같은 옵션으로 빌드되면 기존 비 Go 프로그램의 일부로 실행됩니다. Go 코드가 시작될 때 비 Go 코드에 이미 신호 처리기가 설치되어있을 수 있습니다 (cgo 또는 SWIG를 사용할 때 비정상적인 경우에도 발생할 수 있습니다.이 경우 여기에 설명 된 내용이 적용됨). -buildmode = c-archive의 경우 Go 런타임은 전역 생성자 시간에 신호를 초기화합니다. -buildmode = c-shared의 경우 Go 런타임은 공유 라이브러리가로드 될 때 신호를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="157b3f39795f3c1bb26d85adf87f02f3367ef226" translate="yes" xml:space="preserve">
          <source>When Read encounters an error or end-of-file condition after successfully reading n &amp;gt; 0 bytes, it returns the number of bytes read. It may return the (non-nil) error from the same call or return the error (and n == 0) from a subsequent call. An instance of this general case is that a Reader returning a non-zero number of bytes at the end of the input stream may return either err == EOF or err == nil. The next Read should return 0, EOF.</source>
          <target state="translated">읽기&amp;gt; n&amp;gt; 0 바이트를 읽은 후 오류 또는 파일 끝 조건이 발생하면 읽은 바이트 수를 반환합니다. 동일한 호출에서 (0이 아닌) 오류를 반환하거나 후속 호출에서 오류 (및 n == 0)를 반환 할 수 있습니다. 이 일반적인 경우의 예는 입력 스트림의 끝에서 0이 아닌 바이트 수를 리턴하는 Reader가 err == EOF 또는 err == nil을 리턴 할 수 있다는 것입니다. 다음 읽기는 0, EOF를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="d6278f9f812d1e00a798b88f0d43a4c07f1b736e" translate="yes" xml:space="preserve">
          <source>When ReadAt returns n &amp;lt; len(p), it returns a non-nil error explaining why more bytes were not returned. In this respect, ReadAt is stricter than Read.</source>
          <target state="translated">ReadAt가 n &amp;lt;len (p)를 반환하면 더 많은 바이트가 반환되지 않은 이유를 설명하는 넌이 아닌 오류를 반환합니다. 이와 관련하여 ReadAt는 Read보다 엄격합니다.</target>
        </trans-unit>
        <trans-unit id="e42e8857e0f2dbf41e5d11d0b713339895c2d306" translate="yes" xml:space="preserve">
          <source>When Shutdown is called, Serve, ListenAndServe, and ListenAndServeTLS immediately return ErrServerClosed. Make sure the program doesn't exit and waits instead for Shutdown to return.</source>
          <target state="translated">Shutdown이 호출되면 Serve, ListenAndServe 및 ListenAndServeTLS는 즉시 ErrServerClosed를 반환합니다. 프로그램이 종료되지 않고 종료가 다시 나타날 때까지 기다리십시오.</target>
        </trans-unit>
        <trans-unit id="a1346033e8cd0c36ddc0423c4dcbbce227d0c225" translate="yes" xml:space="preserve">
          <source>When TestMain is called, flag.Parse has not been run. If TestMain depends on command-line flags, including those of the testing package, it should call flag.Parse explicitly. Command line flags are always parsed by the time test or benchmark functions run.</source>
          <target state="translated">TestMain이 호출되면 flag.Parse가 실행되지 않았습니다. TestMain이 테스트 패키지의 플래그를 포함하여 명령 줄 플래그에 의존하는 경우 flag.Parse를 명시 적으로 호출해야합니다. 명령 줄 플래그는 항상 시간 테스트 또는 벤치 마크 함수가 실행될 때 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="52cedf2625524a5c08d35a591f2ee66394bc79d6" translate="yes" xml:space="preserve">
          <source>When Token encounters an error or end-of-file condition after successfully reading a token, it returns the token. It may return the (non-nil) error from the same call or return the error (and a nil token) from a subsequent call. An instance of this general case is that a TokenReader returning a non-nil token at the end of the token stream may return either io.EOF or a nil error. The next Read should return nil, io.EOF.</source>
          <target state="translated">토큰을 읽은 후 토큰에 오류 또는 파일 끝 조건이 발생하면 토큰을 리턴합니다. 동일한 호출에서 (없음이 아닌) 오류를 반환하거나 후속 호출에서 오류 (및 없음 토큰)를 반환 할 수 있습니다. 이 일반적인 경우의 예는 토큰 스트림의 끝에서 넌이 아닌 토큰을 반환하는 TokenReader가 io.EOF 또는 nil 오류를 반환 할 수 있다는 것입니다. 다음 읽기는 nil, io.EOF를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="3250a941e5738a81aa69e5097500ef947e64f456" translate="yes" xml:space="preserve">
          <source>When a Go program writes to a broken pipe, the kernel will raise a SIGPIPE signal.</source>
          <target state="translated">Go 프로그램이 깨진 파이프에 쓰면 커널은 SIGPIPE 신호를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="ed858d1cf0b08d8b30624984289eaf84deee9351" translate="yes" xml:space="preserve">
          <source>When a data value is not plain text, you can make sure it is not over-escaped by marking it with its type.</source>
          <target state="translated">데이터 값이 일반 텍스트가 아닌 경우 해당 유형으로 표시하여 과도하게 이스케이프되지 않도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dcc36ea4f1110a5d9628600e555148a98813c271" translate="yes" xml:space="preserve">
          <source>When a plugin is first opened, the init functions of all packages not already part of the program are called. The main function is not run. A plugin is only initialized once, and cannot be closed.</source>
          <target state="translated">플러그인을 처음 열면 프로그램의 일부가 아닌 모든 패키지의 init 함수가 호출됩니다. 주 기능이 실행되지 않습니다. 플러그인은 한 번만 초기화되며 닫을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="34098c7334f20e516928585d3dd596a221004580" translate="yes" xml:space="preserve">
          <source>When adding a new file, a file base must be provided. That can be any integer value that is past the end of any interval of any file already in the file set. For convenience, FileSet.Base provides such a value, which is simply the end of the Pos interval of the most recently added file, plus one. Unless there is a need to extend an interval later, using the FileSet.Base should be used as argument for FileSet.AddFile.</source>
          <target state="translated">새 파일을 추가 할 때 파일 기반을 제공해야합니다. 파일 세트에 이미있는 파일의 간격 끝을 지난 정수 값일 수 있습니다. 편의를 위해 FileSet.Base는 가장 최근에 추가 된 파일의 Pos 간격에 1을 더한 값인 이러한 값을 제공합니다. 나중에 간격을 연장 할 필요가없는 한 FileSet.Base를 사용하여 FileSet.AddFile의 인수로 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="82668902c85167e64c6f0f47b4424c5d8da33aca" translate="yes" xml:space="preserve">
          <source>When calling SetCgoTraceback, the version argument is the version number of the structs that the functions expect to receive. Currently this must be zero.</source>
          <target state="translated">SetCgoTraceback을 호출 할 때 version 인수는 함수가받을 것으로 예상되는 구조체의 버전 번호입니다. 현재 이것은 0이어야합니다.</target>
        </trans-unit>
        <trans-unit id="bb4ae77735024f9be2c837577d3897cb72653910" translate="yes" xml:space="preserve">
          <source>When cgo is available, cgo-based (libc-backed) code is used by default. This can be overridden by using osusergo build tag, which enforces the pure Go implementation.</source>
          <target state="translated">cgo를 사용할 수있는 경우 cgo 기반 (libc 지원) 코드가 기본적으로 사용됩니다. 순수한 Go 구현을 강제하는 osusergo 빌드 태그를 사용하여이를 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d68b88a257e3f62b9428ba8c7fdd32a8b354868" translate="yes" xml:space="preserve">
          <source>When decoding an ASN.1 value with an IMPLICIT tag into a string field, Unmarshal will default to a PrintableString, which doesn't support characters such as '@' and '&amp;amp;'. To force other encodings, use the following tags:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="752b47af0ec8b502ec7dd916b2f8679be6d9d28e" translate="yes" xml:space="preserve">
          <source>When err is nil, resp always contains a non-nil resp.Body. Caller should close resp.Body when done reading from it.</source>
          <target state="translated">err이 nil 인 경우, resp는 항상 non-nil resp.Body를 포함합니다. 호출자는 읽은 후 resp.Body를 닫아야합니다.</target>
        </trans-unit>
        <trans-unit id="01d9fbd4a2ba2cf83a0b45d054350614384bbdc9" translate="yes" xml:space="preserve">
          <source>When execution begins, $ is set to the data argument passed to Execute, that is, to the starting value of dot.</source>
          <target state="translated">실행이 시작되면 $는 Execute에 전달 된 데이터 인수, 즉 dot의 시작 값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="8919d4f071112552ffa9917647b1e1053256e035" translate="yes" xml:space="preserve">
          <source>When following redirects, the Client will forward all headers set on the initial Request except:</source>
          <target state="translated">리디렉션을 수행하면 클라이언트는 다음을 제외하고 초기 요청에 설정된 모든 헤더를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="9524b6877cae25b318411b88de97b53bfbb0506c" translate="yes" xml:space="preserve">
          <source>When matching against text, the regexp returns a match that begins as early as possible in the input (leftmost), and among those it chooses the one that a backtracking search would have found first. This so-called leftmost-first matching is the same semantics that Perl, Python, and other implementations use, although this package implements it without the expense of backtracking. For POSIX leftmost-longest matching, see CompilePOSIX.</source>
          <target state="translated">텍스트와 일치하는 경우 정규 표현식은 입력 (가장 왼쪽)에서 가능한 한 빨리 시작되는 일치 항목을 반환하며 그 중에서 역 추적 검색에서 가장 먼저 찾은 항목을 선택합니다. 이 패키지는 백 트래킹 비용없이 구현하지만 Perl, Python 및 기타 구현에서 사용하는 것과 동일한 시맨틱입니다. POSIX 가장 왼쪽 일치 항목은 CompilePOSIX를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c6e22a9991087594c0b8cf7617afd5eef2db8623" translate="yes" xml:space="preserve">
          <source>When parsing a template, another template may be defined and associated with the template being parsed. Template definitions must appear at the top level of the template, much like global variables in a Go program.</source>
          <target state="translated">템플릿을 구문 분석 할 때 다른 템플릿이 정의되어 구문 분석중인 템플릿과 연관 될 수 있습니다. 템플릿 정의는 Go 프로그램의 전역 변수와 마찬가지로 템플릿의 최상위 수준에 나타나야합니다.</target>
        </trans-unit>
        <trans-unit id="017afe59414197ba093e7c01bd629debe47b73b4" translate="yes" xml:space="preserve">
          <source>When parsing a time with a zone abbreviation like MST, if the zone abbreviation has a defined offset in the current location, then that offset is used. The zone abbreviation &quot;UTC&quot; is recognized as UTC regardless of location. If the zone abbreviation is unknown, Parse records the time as being in a fabricated location with the given zone abbreviation and a zero offset. This choice means that such a time can be parsed and reformatted with the same layout losslessly, but the exact instant used in the representation will differ by the actual zone offset. To avoid such problems, prefer time layouts that use a numeric zone offset, or use ParseInLocation.</source>
          <target state="translated">MST와 같은 영역 약어로 시간을 구문 분석 할 때 영역 약어에 현재 위치에 정의 된 오프셋이 있으면 해당 오프셋이 사용됩니다. 영역 약어 &quot;UTC&quot;는 위치에 관계없이 UTC로 인식됩니다. 구역 약어를 알 수없는 경우 구문 분석은 주어진 구역 약어와 0 오프셋을 사용하여 제작 된 위치에있는 시간을 기록합니다. 이 선택은 이러한 시간을 무손실로 동일한 레이아웃으로 구문 분석하고 다시 포맷 할 수 있지만 표현에 사용 된 정확한 순간은 실제 영역 오프셋에 따라 다릅니다. 이러한 문제를 피하려면 숫자 영역 오프셋을 사용하거나 ParseInLocation을 사용하는 시간 레이아웃을 선호하십시오.</target>
        </trans-unit>
        <trans-unit id="6cdce46cbdd242d854181ed07c3441caefe581b7" translate="yes" xml:space="preserve">
          <source>When parsing a time with a zone offset like -0700, if the offset corresponds to a time zone used by the current location (Local), then Parse uses that location and zone in the returned time. Otherwise it records the time as being in a fabricated location with time fixed at the given zone offset.</source>
          <target state="translated">-0700과 같은 영역 오프셋을 사용하여 시간을 구문 분석 할 때 오프셋이 현재 위치 (Local)에서 사용하는 시간대에 해당하는 경우 Parse는 해당 위치와 영역을 반환 된 시간에 사용합니다. 그렇지 않으면 주어진 구역 오프셋에 고정 된 시간으로 제작 된 위치에있는 시간을 기록합니다.</target>
        </trans-unit>
        <trans-unit id="67cd941accf04bdb338f577638abdd5419252ad9" translate="yes" xml:space="preserve">
          <source>When parsing multiple files with the same name in different directories, the last one mentioned will be the one that results.</source>
          <target state="translated">다른 디렉토리에서 동일한 이름을 가진 여러 파일을 구문 분석 할 때 마지막으로 언급 된 파일이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="ddcdf8b97f4b2868ce974b91b64fece54bf4c923" translate="yes" xml:space="preserve">
          <source>When parsing multiple files with the same name in different directories, the last one mentioned will be the one that results. For instance, ParseFiles(&quot;a/foo&quot;, &quot;b/foo&quot;) stores &quot;b/foo&quot; as the template named &quot;foo&quot;, while &quot;a/foo&quot; is unavailable.</source>
          <target state="translated">다른 디렉토리에서 동일한 이름을 가진 여러 파일을 구문 분석 할 때 마지막으로 언급 된 파일이 생성됩니다. 예를 들어 ParseFiles ( &quot;a / foo&quot;, &quot;b / foo&quot;)는 &quot;b / foo&quot;를 &quot;foo&quot;라는 템플릿으로 저장하지만 &quot;a / foo&quot;는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="34e29899665d5e8ad85e485fb7f40717928c9cd2" translate="yes" xml:space="preserve">
          <source>When printing a struct, fmt cannot and therefore does not invoke formatting methods such as Error or String on unexported fields.</source>
          <target state="translated">구조체를 인쇄 할 때 fmt는 내 보내지 않은 필드에서 오류 또는 문자열과 같은 형식화 방법을 호출 할 수 없으므로 호출하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="328b930d804aecf09f06d9e00e3215a83c9fe31a" translate="yes" xml:space="preserve">
          <source>When running a large set of sequential test cases, checking Coverage after each one can be useful for identifying which test cases exercise new code paths. It is not a replacement for the reports generated by 'go test -cover' and 'go tool cover'.</source>
          <target state="translated">대량의 순차적 테스트 사례를 실행할 때 각 사례마다 적용 범위를 확인하면 새 코드 경로를 사용하는 테스트 사례를 식별하는 데 유용 할 수 있습니다. 'go test -cover'및 'go tool cover'로 생성 된 보고서를 대체하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="909e63ef88f23df70a053ead84b3a43d68a17641" translate="yes" xml:space="preserve">
          <source>When template execution invokes a function with an argument list, that list must be assignable to the function's parameter types. Functions meant to apply to arguments of arbitrary type can use parameters of type interface{} or of type reflect.Value. Similarly, functions meant to return a result of arbitrary type can return interface{} or reflect.Value.</source>
          <target state="translated">템플릿 실행이 인수 목록이있는 함수를 호출 할 때 해당 목록은 함수의 매개 변수 유형에 지정 가능해야합니다. 임의 유형의 인수에 적용되는 함수는 interface {} 유형 또는 reflect.Value 유형의 매개 변수를 사용할 수 있습니다. 마찬가지로, 임의 유형의 결과를 리턴하는 함수는 interface {}를 리턴하거나 리플렉션 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05dd6446129205c413b187abb37a98c5e685666d" translate="yes" xml:space="preserve">
          <source>When unmarshaling quoted strings, invalid UTF-8 or invalid UTF-16 surrogate pairs are not treated as an error. Instead, they are replaced by the Unicode replacement character U+FFFD.</source>
          <target state="translated">인용 된 문자열을 비 정렬화할 때 유효하지 않은 UTF-8 또는 유효하지 않은 UTF-16 서로 게이트 쌍은 오류로 처리되지 않습니다. 대신 유니 코드 대체 문자 U + FFFD로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="33fa3fdb7bbbbb81e834f8787f2ce9d1e3b0b605" translate="yes" xml:space="preserve">
          <source>When using TCP, and the host in the address parameter resolves to multiple network addresses, any dial timeout (from d.Timeout or ctx) is spread over each consecutive dial, such that each is given an appropriate fraction of the time to connect. For example, if a host has 4 IP addresses and the timeout is 1 minute, the connect to each single address will be given 15 seconds to complete before trying the next one.</source>
          <target state="translated">TCP를 사용하고 address 매개 변수의 호스트가 여러 네트워크 주소로 확인되면 모든 다이얼 시간 초과 (d.Timeout 또는 ctx에서)가 각 연속 다이얼에 분산되어 각 연결 시간에 적절한 비율이 제공됩니다. 예를 들어 호스트에 4 개의 IP 주소가 있고 시간 초과가 1 분인 경우 다음 주소를 시도하기 전에 각 단일 주소에 대한 연결이 완료되는 데 15 초가 걸립니다.</target>
        </trans-unit>
        <trans-unit id="81ad3fb58a9738071410987f567b6f63ba760aad" translate="yes" xml:space="preserve">
          <source>When using the host C library resolver, at most one result will be returned. To bypass the host resolver, use a custom Resolver.</source>
          <target state="translated">호스트 C 라이브러리 리졸버를 사용하는 경우 최대 하나의 결과가 리턴됩니다. 호스트 확인자를 무시하려면 사용자 지정 확인자를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b6af75ad725ff03ac3899006f586c6815dee0ab6" translate="yes" xml:space="preserve">
          <source>Whether and how a comment is associated with a node depends on the interpretation of the syntax tree by the manipulating program: Except for Doc and Comment comments directly associated with nodes, the remaining comments are &quot;free-floating&quot; (see also issues #18593, #20744).</source>
          <target state="translated">주석이 노드와 연관되는지 여부와 방법은 조작 프로그램에 의한 구문 트리의 해석에 따라 다릅니다. 노드와 직접 연관된 Doc 및 주석 주석을 제외하고 나머지 주석은 &quot;자유 부동&quot;입니다 (문제 # 18593, # 20744).</target>
        </trans-unit>
        <trans-unit id="1761aeba17f1966adf699cab82838ede9543b2ce" translate="yes" xml:space="preserve">
          <source>While it would be correct for the context function to record a complete a stack trace whenever it is called, and simply copy that out in the traceback function, in a typical program the context function will be called many times without ever recording a traceback for that context. Recording a complete stack trace in a call to the context function is likely to be inefficient.</source>
          <target state="translated">컨텍스트 함수가 호출 될 때마다 완전한 스택 추적을 기록하고 단순히 트레이스 백 함수에서이를 복사하는 것이 올바른 반면, 일반적인 프로그램에서는 컨텍스트 함수가 트레이스 백을 기록하지 않고 여러 번 호출됩니다. 문맥. 컨텍스트 함수에 대한 호출에서 완전한 스택 추적을 기록하는 것은 비효율적 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97ac8575a01bb9731d0aacbb0c00a32106d3caac" translate="yes" xml:space="preserve">
          <source>While the FileSystem.Open method takes '/'-separated paths, a Dir's string value is a filename on the native file system, not a URL, so it is separated by filepath.Separator, which isn't necessarily '/'.</source>
          <target state="translated">FileSystem.Open 메서드는 '/'로 구분 된 경로를 사용하지만 Dir의 문자열 값은 URL이 아닌 기본 파일 시스템의 파일 이름이므로 filepath.Separator로 구분되며 반드시 '/'일 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="7d448d6e99b8642847a099da6f3145e12a69b2bf" translate="yes" xml:space="preserve">
          <source>White space is considered part of a field.</source>
          <target state="translated">공백은 필드의 일부로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="3462ed046f134fdadd9007f0e6ba397654359adc" translate="yes" xml:space="preserve">
          <source>Width and precision are measured in units of Unicode code points, that is, runes. (This differs from C's printf where the units are always measured in bytes.) Either or both of the flags may be replaced with the character '*', causing their values to be obtained from the next operand (preceding the one to format), which must be of type int.</source>
          <target state="translated">너비와 정밀도는 유니 코드 코드 포인트, 즉 룬 단위로 측정됩니다. (이것은 단위가 항상 바이트 단위로 측정되는 C의 printf와 다릅니다.) 플래그 중 하나 또는 둘 다 문자 '*'로 대체되어 다음 피연산자에서 값을 얻을 수 있습니다 (앞서 포맷해야 함). int 형식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="285e52d2a4d90abe10ddf2c19e952396f894982a" translate="yes" xml:space="preserve">
          <source>Width is interpreted in the input text but there is no syntax for scanning with a precision (no %5.2f, just %5f). If width is provided, it applies after leading spaces are trimmed and specifies the maximum number of runes to read to satisfy the verb. For example,</source>
          <target state="translated">너비는 입력 텍스트에서 해석되지만 정밀하게 스캔하기위한 구문은 없습니다 (% 5.2f 없음, % 5f 만). 너비가 제공되면 선행 공백이 트리밍 된 후 적용되며 동사를 충족시키기 위해 읽을 최대 룬 수를 지정합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="798e2836ace5e24780c7dc5d76140278c0905170" translate="yes" xml:space="preserve">
          <source>Width is specified by an optional decimal number immediately preceding the verb. If absent, the width is whatever is necessary to represent the value. Precision is specified after the (optional) width by a period followed by a decimal number. If no period is present, a default precision is used. A period with no following number specifies a precision of zero. Examples:</source>
          <target state="translated">너비는 동사 바로 앞의 선택적 10 진수로 지정됩니다. 없는 경우 너비는 값을 나타내는 데 필요한 것입니다. 정밀도는 (선택적) 너비 뒤에 마침표와 10 진수로 지정됩니다. 마침표가 없으면 기본 정밀도가 사용됩니다. 다음 숫자가없는 기간은 정밀도 0을 지정합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="26d9c28d789c254f71ea99a3463b99a7ccc2f4fa" translate="yes" xml:space="preserve">
          <source>Windows</source>
          <target state="translated">Windows</target>
        </trans-unit>
        <trans-unit id="90527ca0c17e71be4b659b364a4632417bd48fd0" translate="yes" xml:space="preserve">
          <source>With HTTP Basic Authentication the provided username and password are not encrypted.</source>
          <target state="translated">HTTP 기본 인증을 사용하면 제공된 사용자 이름과 비밀번호가 암호화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9c7242429a52b5edef337779ea090fbcc2bb6019" translate="yes" xml:space="preserve">
          <source>With the exceptions of comments, which are skipped if SkipComments is set, unrecognized tokens are not ignored. Instead, the scanner simply returns the respective individual characters (or possibly sub-tokens). For instance, if the mode is ScanIdents (not ScanStrings), the string &quot;foo&quot; is scanned as the token sequence '&quot;' Ident '&quot;'.</source>
          <target state="translated">SkipComments가 설정되어 있으면 건너 뛰는 주석을 제외하고 인식 할 수없는 토큰은 무시되지 않습니다. 대신, 스캐너는 단순히 각각의 개별 문자 (또는 하위 토큰)를 반환합니다. 예를 들어, 모드가 ScanIdents (ScanStrings 아님) 인 경우 문자열 &quot;foo&quot;는 토큰 시퀀스 ' &quot;'Ident '&quot;'로 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="cfa2b7a12432ca7dde89800a43beb434b01e3ea5" translate="yes" xml:space="preserve">
          <source>WithCancel</source>
          <target state="translated">WithCancel</target>
        </trans-unit>
        <trans-unit id="10592d7ad2855a7180469ae213405203a2d50e89" translate="yes" xml:space="preserve">
          <source>WithCancel returns a copy of parent with a new Done channel. The returned context's Done channel is closed when the returned cancel function is called or when the parent context's Done channel is closed, whichever happens first.</source>
          <target state="translated">WithCancel은 새 완료 채널이있는 상위 사본을 리턴합니다. 리턴 된 취소 기능이 호출되거나 상위 컨텍스트의 완료 채널이 닫히면 리턴 된 컨텍스트의 완료 채널이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="2261f632aeaf0a3059b969971069ca975c9ce32e" translate="yes" xml:space="preserve">
          <source>WithClientTrace returns a new context based on the provided parent ctx. HTTP client requests made with the returned context will use the provided trace hooks, in addition to any previous hooks registered with ctx. Any hooks defined in the provided trace will be called first.</source>
          <target state="translated">WithClientTrace는 제공된 상위 ctx를 기반으로 새 컨텍스트를 리턴합니다. 리턴 된 컨텍스트로 작성된 HTTP 클라이언트 요청은 ctx에 등록 된 이전 후크 외에 제공된 추적 후크를 사용합니다. 제공된 추적에 정의 된 모든 후크가 먼저 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="f1cd36566b14c3bbf36e47b0c1cd6c5053972eb6" translate="yes" xml:space="preserve">
          <source>WithContext returns a shallow copy of r with its context changed to ctx. The provided ctx must be non-nil.</source>
          <target state="translated">WithContext는 컨텍스트가 ctx로 변경된 r의 얕은 사본을 리턴합니다. 제공된 ctx는 0이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="c81570667b5d5149acbef6b90b5b11ce74038f5e" translate="yes" xml:space="preserve">
          <source>WithDeadline</source>
          <target state="translated">WithDeadline</target>
        </trans-unit>
        <trans-unit id="4330da7d2b110737e8fe5953a232fb49e41e1165" translate="yes" xml:space="preserve">
          <source>WithDeadline returns a copy of the parent context with the deadline adjusted to be no later than d. If the parent's deadline is already earlier than d, WithDeadline(parent, d) is semantically equivalent to parent. The returned context's Done channel is closed when the deadline expires, when the returned cancel function is called, or when the parent context's Done channel is closed, whichever happens first.</source>
          <target state="translated">WithDeadline은 최종 기한이 d 이하로 조정 된 상위 컨텍스트의 사본을 리턴합니다. 부모의 최종 기한이 이미 d보다 빠르면 WithDeadline (parent, d)는 의미 적으로 부모와 같습니다. 반환 된 컨텍스트의 완료 채널은 최종 기한이 만료되거나 반환 된 취소 기능이 호출되거나 상위 컨텍스트의 완료 채널이 닫힐 때 먼저 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="7a280665a50cba23581e10e39947347ff060fae9" translate="yes" xml:space="preserve">
          <source>WithLabels returns a new context.Context with the given labels added. A label overwrites a prior label with the same key.</source>
          <target state="translated">WithLabels는 주어진 레이블이 추가 된 새로운 컨텍스트를 반환합니다. 레이블은 동일한 키로 이전 레이블을 덮어 씁니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
