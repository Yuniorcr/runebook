<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="go">
    <body>
      <group id="go">
        <trans-unit id="e7cf6fa65416b27793d90a051b00b5c18e902844" translate="yes" xml:space="preserve">
          <source>Other values - numbers, bools, strings, and channels - are deeply equal if they are equal using Go's == operator.</source>
          <target state="translated">다른 값 (숫자, 부울, 문자열 및 채널)은 Go의 == 연산자를 사용하여 같으면 깊이 같습니다.</target>
        </trans-unit>
        <trans-unit id="68cac93271438e6498e5c369aaaa0b2b44f4aa36" translate="yes" xml:space="preserve">
          <source>Otherwise Context will be a value previously returned by a call to the context function. The traceback function should gather a stack trace from that saved point in the program execution. The traceback function may be called from an execution thread other than the one that recorded the context, but only when the context is known to be valid and unchanging. The traceback function may also be called deeper in the call stack on the same thread that recorded the context. The traceback function may be called multiple times with the same Context value; it will usually be appropriate to cache the result, if possible, the first time this is called for a specific context value.</source>
          <target state="translated">그렇지 않으면 컨텍스트는 컨텍스트 함수 호출에 의해 이전에 리턴 된 값입니다. 역 추적 기능은 프로그램 실행의 저장된 지점에서 스택 추적을 수집해야합니다. 트레이스 백 함수는 컨텍스트를 기록한 스레드 이외의 실행 스레드에서 호출 될 수 있지만 컨텍스트가 유효하고 변경되지 않은 것으로 알려진 경우에만 가능합니다. 트레이스 백 함수는 컨텍스트를 기록한 동일한 스레드의 호출 스택에서 더 깊이 호출 될 수도 있습니다. 역 추적 함수는 동일한 컨텍스트 값으로 여러 번 호출 될 수 있습니다. 일반적으로 가능한 경우 특정 컨텍스트 값에 대해 처음 호출 할 때 결과를 캐시하는 것이 적절합니다.</target>
        </trans-unit>
        <trans-unit id="440873215b88a6b8697d85d1d64d02df4a4da93f" translate="yes" xml:space="preserve">
          <source>Otherwise, Marshal uses the following type-dependent default encodings:</source>
          <target state="translated">그렇지 않으면 Marshal은 다음과 같은 유형 종속 기본 인코딩을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="23286c7a365f916cfdea50d5123a3b0bcae1d4f3" translate="yes" xml:space="preserve">
          <source>Otherwise, the Scanner advances the input. If the token is not nil, the Scanner returns it to the user. If the token is nil, the Scanner reads more data and continues scanning; if there is no more data--if atEOF was true--the Scanner returns. If the data does not yet hold a complete token, for instance if it has no newline while scanning lines, a SplitFunc can return (0, nil, nil) to signal the Scanner to read more data into the slice and try again with a longer slice starting at the same point in the input.</source>
          <target state="translated">그렇지 않으면 스캐너가 입력을 진행시킵니다. 토큰이 0이 아닌 경우 스캐너는 사용자에게 토큰을 반환합니다. 토큰이 0이 아닌 경우 스캐너는 더 많은 데이터를 읽고 스캔을 계속합니다. atEOF가 true 인 경우 더 이상 데이터가 없으면 스캐너가 반환합니다. 데이터가 아직 완전한 토큰을 보유하지 않은 경우 (예 : 줄을 스캔하는 동안 줄 바꿈이없는 경우) SplitFunc는 (0, nil, nil)을 반환하여 스캐너가 슬라이스로 더 많은 데이터를 읽고 더 긴 시간 동안 다시 시도하도록 신호를 보냅니다. 입력에서 같은 지점에서 시작하는 슬라이스.</target>
        </trans-unit>
        <trans-unit id="c58abb3a56ad02906deb5ed411e41c1942d916f5" translate="yes" xml:space="preserve">
          <source>Otherwise, the name is taken to be a location name corresponding to a file in the IANA Time Zone database, such as &quot;America/New_York&quot;.</source>
          <target state="translated">그렇지 않으면 이름은 &quot;America / New_York&quot;와 같은 IANA 표준 시간대 데이터베이스의 파일에 해당하는 위치 이름이됩니다.</target>
        </trans-unit>
        <trans-unit id="074d0906fc55c8d6c513fa44707b8b377c627c79" translate="yes" xml:space="preserve">
          <source>Out may be used to retrieve OUTPUT value parameters from stored procedures.</source>
          <target state="translated">저장 프로 시저에서 OUTPUT 값 매개 변수를 검색하는 데 Out을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62f29f77d6256848fed5f348aeadebd7d0572e5e" translate="yes" xml:space="preserve">
          <source>Output returns the destination for usage and error messages. os.Stderr is returned if output was not set or was set to nil.</source>
          <target state="translated">출력은 사용법 및 오류 메시지의 대상을 반환합니다. 출력이 설정되지 않았거나 nil로 설정된 경우 os.Stderr가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="e449133aa4e97be80abdfc0c46f50787b1e6cc66" translate="yes" xml:space="preserve">
          <source>Output runs the command and returns its standard output. Any returned error will usually be of type *ExitError. If c.Stderr was nil, Output populates ExitError.Stderr.</source>
          <target state="translated">출력은 명령을 실행하고 표준 출력을 반환합니다. 리턴 된 오류는 일반적으로 * ExitError 유형입니다. c.Stderr이 nil이면, Output은 ExitError.Stderr를 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="7ecc8307c727787c0796f59aebc9997243dec020" translate="yes" xml:space="preserve">
          <source>Output writes the output for a logging event. The string s contains the text to print after the prefix specified by the flags of the Logger. A newline is appended if the last character of s is not already a newline. Calldepth is the count of the number of frames to skip when computing the file name and line number if Llongfile or Lshortfile is set; a value of 1 will print the details for the caller of Output.</source>
          <target state="translated">출력은 로깅 이벤트에 대한 출력을 씁니다. 문자열 s에는 로거의 플래그로 지정된 접두사 뒤에 인쇄 할 텍스트가 포함됩니다. s의 마지막 문자가 이미 개행 문자가 아닌 경우 개행 문자가 추가됩니다. Calldepth는 Llongfile 또는 Lshortfile이 설정된 경우 파일 이름과 줄 번호를 계산할 때 건너 뛸 프레임 수입니다. 값이 1이면 출력 호출자에 대한 세부 사항이 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="c217d8994a3f1426d43eb0166f8c3a35d6d34515" translate="yes" xml:space="preserve">
          <source>Output writes the output for a logging event. The string s contains the text to print after the prefix specified by the flags of the Logger. A newline is appended if the last character of s is not already a newline. Calldepth is used to recover the PC and is provided for generality, although at the moment on all pre-defined paths it will be 2.</source>
          <target state="translated">출력은 로깅 이벤트에 대한 출력을 씁니다. 문자열 s에는 로거의 플래그로 지정된 접두사 뒤에 인쇄 할 텍스트가 포함됩니다. s의 마지막 문자가 이미 개행 문자가 아닌 경우 개행 문자가 추가됩니다. Calldepth는 PC를 복구하는 데 사용되며 일반적으로 제공되지만 모든 사전 정의 된 경로에서는 현재 2입니다.</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="4fa36fa9b33d97810f39e28fc36e995589f3d560" translate="yes" xml:space="preserve">
          <source>Output: &quot;ZgotmplZ&quot; Example:</source>
          <target state="translated">출력 : &quot;ZgotmplZ&quot;예 :</target>
        </trans-unit>
        <trans-unit id="75e718b4932f1994826e9ab2559b67ffd1e17df7" translate="yes" xml:space="preserve">
          <source>Outside of those two special cases, ServeFile does not use r.URL.Path for selecting the file or directory to serve; only the file or directory provided in the name argument is used.</source>
          <target state="translated">이 두 가지 특별한 경우를 제외하고 ServeFile은 r.URL.Path를 사용하여 제공 할 파일이나 디렉토리를 선택하지 않습니다. name 인수에 제공된 파일 또는 디렉토리 만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c3a7fdb472ac14ee470a8708bdbde30a747ecc04" translate="yes" xml:space="preserve">
          <source>OverflowComplex reports whether the complex128 x cannot be represented by v's type. It panics if v's Kind is not Complex64 or Complex128.</source>
          <target state="translated">OverflowComplex는 complex128 x를 v의 유형으로 나타낼 수 없는지 여부를보고합니다. v의 Kind가 Complex64 또는 Complex128이 아닌 경우 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="b0ed609ef26db1230ec310f05f6a41e74b4a279d" translate="yes" xml:space="preserve">
          <source>OverflowFloat reports whether the float64 x cannot be represented by v's type. It panics if v's Kind is not Float32 or Float64.</source>
          <target state="translated">OverflowFloat는 float64 x를 v의 유형으로 나타낼 수 없는지 여부를보고합니다. v의 종류가 Float32 또는 Float64가 아닌 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7200bfe476f81acadc4a0ccf748e1684d1005b1a" translate="yes" xml:space="preserve">
          <source>OverflowInt reports whether the int64 x cannot be represented by v's type. It panics if v's Kind is not Int, Int8, Int16, Int32, or Int64.</source>
          <target state="translated">OverflowInt는 int64 x를 v의 유형으로 나타낼 수 없는지 여부를보고합니다. v의 종류가 Int, Int8, Int16, Int32 또는 Int64가 아닌 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2b4b5d40028c4ba9e1027f58dcb6f18125d975d5" translate="yes" xml:space="preserve">
          <source>OverflowUint reports whether the uint64 x cannot be represented by v's type. It panics if v's Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64.</source>
          <target state="translated">OverflowUint는 uint64 x를 v의 유형으로 나타낼 수 없는지 여부를보고합니다. v의 종류가 Uint, Uintptr, Uint8, Uint16, Uint32 또는 Uint64가 아닌 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2f7f8328b596e3ddecd6faa4ad494433682975d9" translate="yes" xml:space="preserve">
          <source>Overlaps reports whether r and s have a non-empty intersection.</source>
          <target state="translated">겹침은 r과 s에 비어 있지 않은 교점이 있는지보고합니다.</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="540bc829190ced5e9ba3735dc9ac84a0059b79f4" translate="yes" xml:space="preserve">
          <source>P224 returns a Curve which implements P-224 (see FIPS 186-3, section D.2.2).</source>
          <target state="translated">P224는 P-224를 구현하는 곡선을 반환합니다 (FIPS 186-3, 섹션 D.2.2 참조).</target>
        </trans-unit>
        <trans-unit id="7a02481719ad494cd5efe50d160cc7726bf135c0" translate="yes" xml:space="preserve">
          <source>P256 returns a Curve which implements NIST P-256 (FIPS 186-3, section D.2.3), also known as secp256r1 or prime256v1. The CurveParams.Name of this Curve is &quot;P-256&quot;.</source>
          <target state="translated">P256은 secp256r1 또는 prime256v1이라고도하는 NIST P-256 (FIPS 186-3, 섹션 D.2.3)을 구현하는 곡선을 반환합니다. 이 Curve의 CurveParams.Name은 &quot;P-256&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="f9ccdfec57f69f0c0af7d347e1e194be5e3da78a" translate="yes" xml:space="preserve">
          <source>P256 returns a Curve which implements P-256 (see FIPS 186-3, section D.2.3)</source>
          <target state="translated">P256은 P-256을 구현하는 곡선을 반환합니다 (FIPS 186-3, 섹션 D.2.3 참조)</target>
        </trans-unit>
        <trans-unit id="315a8a8dcda4a2d0941fe0f30068b28ba243beb9" translate="yes" xml:space="preserve">
          <source>P384 returns a Curve which implements NIST P-384 (FIPS 186-3, section D.2.4), also known as secp384r1. The CurveParams.Name of this Curve is &quot;P-384&quot;.</source>
          <target state="translated">P384는 secp384r1이라고도하는 NIST P-384 (FIPS 186-3, 섹션 D.2.4)를 구현하는 곡선을 반환합니다. 이 Curve의 CurveParams.Name은 &quot;P-384&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="0d2178f68bbde9fa3217033c113d8df97da47a28" translate="yes" xml:space="preserve">
          <source>P384 returns a Curve which implements P-384 (see FIPS 186-3, section D.2.4)</source>
          <target state="translated">P384는 P-384를 구현하는 곡선을 반환합니다 (FIPS 186-3, 섹션 D.2.4 참조)</target>
        </trans-unit>
        <trans-unit id="4cca307fc3187b85217d38451ccf6632766474b3" translate="yes" xml:space="preserve">
          <source>P521 returns a Curve which implements NIST P-521 (FIPS 186-3, section D.2.5), also known as secp521r1. The CurveParams.Name of this Curve is &quot;P-521&quot;.</source>
          <target state="translated">P521은 secp521r1이라고도하는 NIST P-521 (FIPS 186-3, 섹션 D.2.5)을 구현하는 곡선을 반환합니다. 이 Curve의 CurveParams.Name은 &quot;P-521&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="c9a508dd7c665008acf0e38e607e3196bfcd6cf9" translate="yes" xml:space="preserve">
          <source>P521 returns a Curve which implements P-521 (see FIPS 186-3, section D.2.5)</source>
          <target state="translated">P521은 P-521을 구현하는 곡선을 반환합니다 (FIPS 186-3, 섹션 D.2.5 참조)</target>
        </trans-unit>
        <trans-unit id="39161099723c9e406b69587afd22627144ad7720" translate="yes" xml:space="preserve">
          <source>PCToFunc returns the function containing the program counter pc, or nil if there is no such function.</source>
          <target state="translated">PCToFunc는 프로그램 카운터 pc를 포함하는 함수를 반환하거나 그러한 함수가 없으면 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="aabe0db5b758e9cbc954a1f7a208c14d080cb6c6" translate="yes" xml:space="preserve">
          <source>PCToLine looks up line number information for a program counter. If there is no information, it returns fn == nil.</source>
          <target state="translated">PCToLine은 프로그램 카운터에 대한 라인 번호 정보를 찾습니다. 정보가 없으면 fn == nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="841d78ecc2d24b8758f6afc447a9a64df99960bb" translate="yes" xml:space="preserve">
          <source>PCToLine returns the line number for the given program counter.</source>
          <target state="translated">PCToLine은 주어진 프로그램 카운터의 줄 번호를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9f22bb4f4b5879dcdd3ed13d36e5eadeb879d5ee" translate="yes" xml:space="preserve">
          <source>PKCS1v15DecrypterOpts is for passing options to PKCS #1 v1.5 decryption using the crypto.Decrypter interface.</source>
          <target state="translated">PKCS1v15DecrypterOpts는 crypto.Decrypter 인터페이스를 사용하여 PKCS # 1 v1.5 암호 해독에 옵션을 전달하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="d8139323c6d19479f54e5ea9ba69d4546948a8d4" translate="yes" xml:space="preserve">
          <source>PKCS1v15DecrypterOpts is for passing options to PKCS#1 v1.5 decryption using the crypto.Decrypter interface.</source>
          <target state="translated">PKCS1v15DecrypterOpts는 crypto.Decrypter 인터페이스를 사용하여 옵션을 PKCS # 1 v1.5 암호 해독으로 전달하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3010ccb1954efdb7b7065a86234a1d7d460fba48" translate="yes" xml:space="preserve">
          <source>PSSOptions contains options for creating and verifying PSS signatures.</source>
          <target state="translated">PSSOptions에는 PSS 서명을 만들고 확인하기위한 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7431e3df243c5be33cffa0b28ca2a76b93f0538c" translate="yes" xml:space="preserve">
          <source>Package</source>
          <target state="translated">Package</target>
        </trans-unit>
        <trans-unit id="6de038894baa09edba875dcb5414f5284bdf18fd" translate="yes" xml:space="preserve">
          <source>Package (Autoescaping)</source>
          <target state="translated">패키지 (자동 이스케이프)</target>
        </trans-unit>
        <trans-unit id="efd760e5022b210b4ab3b28e3b7050f4cfe5597a" translate="yes" xml:space="preserve">
          <source>Package (Basic)</source>
          <target state="translated">패키지 (기본)</target>
        </trans-unit>
        <trans-unit id="2f75473a87f737dac84d4da0d9f9f7e3db9e0c4a" translate="yes" xml:space="preserve">
          <source>Package (BinaryMarshaler)</source>
          <target state="translated">패키지 (BinaryMarshaler)</target>
        </trans-unit>
        <trans-unit id="521cf6815d29f653ce707f251cb067182d8071f5" translate="yes" xml:space="preserve">
          <source>Package (ComplexNumbers)</source>
          <target state="translated">패키지 (복합 수)</target>
        </trans-unit>
        <trans-unit id="f1ea6c4ac2e70daab523cce5ae048f3dea0d83bb" translate="yes" xml:space="preserve">
          <source>Package (CustomMarshalJSON)</source>
          <target state="translated">패키지 (CustomMarshalJSON)</target>
        </trans-unit>
        <trans-unit id="53c1354bffac6774daf658fbd5e85b47d709a40a" translate="yes" xml:space="preserve">
          <source>Package (CustomMarshalXML)</source>
          <target state="translated">패키지 (CustomMarshalXML)</target>
        </trans-unit>
        <trans-unit id="bf806559bf4e10f3c8039c45350fd1cd892af724" translate="yes" xml:space="preserve">
          <source>Package (DecodeConfig)</source>
          <target state="translated">패키지 (DecodeConfig)</target>
        </trans-unit>
        <trans-unit id="5c13dd8a74667052e5635f9f7455a54e1f9be1f3" translate="yes" xml:space="preserve">
          <source>Package (Dictionary)</source>
          <target state="translated">패키지 (사전)</target>
        </trans-unit>
        <trans-unit id="fcafbcc962aec3c3d83b146b18f61ef5463aef43" translate="yes" xml:space="preserve">
          <source>Package (EConvergents)</source>
          <target state="translated">패키지 (EConvergents)</target>
        </trans-unit>
        <trans-unit id="71630f752f5d0a16ab8b1a3c38461b76d37e5fed" translate="yes" xml:space="preserve">
          <source>Package (Elastic)</source>
          <target state="translated">패키지 (탄성)</target>
        </trans-unit>
        <trans-unit id="3dc381377e54ebe3f92f7916ec8fdf96578a8e4b" translate="yes" xml:space="preserve">
          <source>Package (EncodeDecode)</source>
          <target state="translated">패키지 (EncodeDecode)</target>
        </trans-unit>
        <trans-unit id="252573860775d14759f48467c37c1fc311083728" translate="yes" xml:space="preserve">
          <source>Package (Escape)</source>
          <target state="translated">패키지 (탈출)</target>
        </trans-unit>
        <trans-unit id="25f707cfdaffe7b9a529ff95591583c8c03bc6af" translate="yes" xml:space="preserve">
          <source>Package (Fibonacci)</source>
          <target state="translated">패키지 (피보나치)</target>
        </trans-unit>
        <trans-unit id="338a17f2623ba97dc73fc6452b147c9a5a0e8298" translate="yes" xml:space="preserve">
          <source>Package (Formats)</source>
          <target state="translated">패키지 (포맷)</target>
        </trans-unit>
        <trans-unit id="426c20e3d54491dcaa33e4dd0bebe004b79c0135" translate="yes" xml:space="preserve">
          <source>Package (IntHeap)</source>
          <target state="translated">패키지 (IntHeap)</target>
        </trans-unit>
        <trans-unit id="0c999d293b130996c88c6f0ebf97cfecc7e78201" translate="yes" xml:space="preserve">
          <source>Package (Interface)</source>
          <target state="translated">패키지 (인터페이스)</target>
        </trans-unit>
        <trans-unit id="dd11444f3f52c88a7e33585300bd5ea9526ef9c4" translate="yes" xml:space="preserve">
          <source>Package (Is)</source>
          <target state="translated">패키지</target>
        </trans-unit>
        <trans-unit id="24d024864b73227ebe67578e60455dbd5c73297f" translate="yes" xml:space="preserve">
          <source>Package (IsIdentRune)</source>
          <target state="translated">패키지 (IsIdentRune)</target>
        </trans-unit>
        <trans-unit id="748caafd5bbe2c55ebabfb05417c48bc6922ffcf" translate="yes" xml:space="preserve">
          <source>Package (Minimal)</source>
          <target state="translated">패키지 (최소)</target>
        </trans-unit>
        <trans-unit id="4c4a86eeb8002b47d70510d7c23e7eb0eeebd8db" translate="yes" xml:space="preserve">
          <source>Package (Mode)</source>
          <target state="translated">패키지 (모드)</target>
        </trans-unit>
        <trans-unit id="be479fe7812a33e53549975551961ada92e137a5" translate="yes" xml:space="preserve">
          <source>Package (OpenDBCLI)</source>
          <target state="translated">패키지 (OpenDBCLI)</target>
        </trans-unit>
        <trans-unit id="afacd609e03942d0e0a9efefefa3cc27d29c774c" translate="yes" xml:space="preserve">
          <source>Package (OpenDBService)</source>
          <target state="translated">패키지 (OpenDBService)</target>
        </trans-unit>
        <trans-unit id="867dd5ed3ca2062c464faebd1a831d2ea55231a1" translate="yes" xml:space="preserve">
          <source>Package (Printers)</source>
          <target state="translated">패키지 (프린터)</target>
        </trans-unit>
        <trans-unit id="944f7ea8e45283f6aee9c663f196d84201347430" translate="yes" xml:space="preserve">
          <source>Package (PriorityQueue)</source>
          <target state="translated">패키지 (PriorityQueue)</target>
        </trans-unit>
        <trans-unit id="e76c0b4be64237d4de2b6bc5f73a9204c1c70fde" translate="yes" xml:space="preserve">
          <source>Package (Rand)</source>
          <target state="translated">패키지 (랜드)</target>
        </trans-unit>
        <trans-unit id="a8e65e58fc97f49428772dd3c9910ec49b3603a7" translate="yes" xml:space="preserve">
          <source>Package (Reset)</source>
          <target state="translated">패키지 (재설정)</target>
        </trans-unit>
        <trans-unit id="0676e5f7c44f1428abe1688347a4a67985619798" translate="yes" xml:space="preserve">
          <source>Package (RetrievePositionInfo)</source>
          <target state="translated">패키지 (RetrievePositionInfo)</target>
        </trans-unit>
        <trans-unit id="3918e789c00aa71d83a0d25f288c82afb2e9dc19" translate="yes" xml:space="preserve">
          <source>Package (SortKeys)</source>
          <target state="translated">패키지 (SortKeys)</target>
        </trans-unit>
        <trans-unit id="fc31bf6d702c41d4e65fa2c8464a648d0253335d" translate="yes" xml:space="preserve">
          <source>Package (SortMultiKeys)</source>
          <target state="translated">패키지 (SortMultiKeys)</target>
        </trans-unit>
        <trans-unit id="be587b9c8d7d28588b076a30e4390f166b763389" translate="yes" xml:space="preserve">
          <source>Package (SortWrapper)</source>
          <target state="translated">패키지 (SortWrapper)</target>
        </trans-unit>
        <trans-unit id="039d4d77bcfce9ea65f0437ee2733cacb35d30d2" translate="yes" xml:space="preserve">
          <source>Package (Sqrt2)</source>
          <target state="translated">패키지 (Sqrt2)</target>
        </trans-unit>
        <trans-unit id="978d6874fbbc2bbed5f65358c7eadec1499de368" translate="yes" xml:space="preserve">
          <source>Package (Synchronization)</source>
          <target state="translated">패키지 (동기화)</target>
        </trans-unit>
        <trans-unit id="d74eef6782bc61ea34233345eec7439ddb2209f0" translate="yes" xml:space="preserve">
          <source>Package (TextMarshalJSON)</source>
          <target state="translated">패키지 (TextMarshalJSON)</target>
        </trans-unit>
        <trans-unit id="00ea20ac0a3062f6e781d5f03ac4f931f7e664e0" translate="yes" xml:space="preserve">
          <source>Package (TextMarshalXML)</source>
          <target state="translated">패키지 (TextMarshalXML)</target>
        </trans-unit>
        <trans-unit id="9d3479f34953d267211484567770a976cf5f7423" translate="yes" xml:space="preserve">
          <source>Package (TrailingTab)</source>
          <target state="translated">패키지 (TrailingTab)</target>
        </trans-unit>
        <trans-unit id="db41f4bcaa84e2ad0f8ea9b730005966564c99d0" translate="yes" xml:space="preserve">
          <source>Package (Whitespace)</source>
          <target state="translated">패키지 (공백)</target>
        </trans-unit>
        <trans-unit id="3fb9a413fc3704254de1eb68fffddbb472a23f33" translate="yes" xml:space="preserve">
          <source>Package (WriterReader)</source>
          <target state="translated">패키지 (WriterReader)</target>
        </trans-unit>
        <trans-unit id="92c0af89beed6181e00c988e8e650e8fbbda5fcb" translate="yes" xml:space="preserve">
          <source>Package adler32</source>
          <target state="translated">패키지 adler32</target>
        </trans-unit>
        <trans-unit id="d6bd7681a9453e693c6a651037643ef4b5bef6e4" translate="yes" xml:space="preserve">
          <source>Package adler32 implements the Adler-32 checksum.</source>
          <target state="translated">패키지 adler32는 Adler-32 체크섬을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="e90a3804ce06c2050a2cae1b40859d0d4b3dc725" translate="yes" xml:space="preserve">
          <source>Package aes</source>
          <target state="translated">패키지 AES</target>
        </trans-unit>
        <trans-unit id="d496233c286ca50cea980f949b6ce9d0a2fbee51" translate="yes" xml:space="preserve">
          <source>Package aes implements AES encryption (formerly Rijndael), as defined in U.S. Federal Information Processing Standards Publication 197.</source>
          <target state="translated">패키지 aes는 미국 연방 정보 처리 표준 간행물 197에 정의 된대로 AES 암호화 (이전의 Rijndael)를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="0d926b729b85354785bc0db2b7d8a423a023029c" translate="yes" xml:space="preserve">
          <source>Package ascii85</source>
          <target state="translated">패키지 ascii85</target>
        </trans-unit>
        <trans-unit id="e3765c8a35f98ca3f4cb583e00d1c90614882045" translate="yes" xml:space="preserve">
          <source>Package ascii85 implements the ascii85 data encoding as used in the btoa tool and Adobe's PostScript and PDF document formats.</source>
          <target state="translated">패키지 ascii85는 btoa 도구 및 Adobe의 PostScript 및 PDF 문서 형식에 사용되는 ascii85 데이터 인코딩을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="180c9a93d5ae7703f2646b742a79d37379696e26" translate="yes" xml:space="preserve">
          <source>Package asn1</source>
          <target state="translated">asn1 패키지</target>
        </trans-unit>
        <trans-unit id="cb9e56c303fa3f867a92e5ec0e898886f01abb4e" translate="yes" xml:space="preserve">
          <source>Package asn1 implements parsing of DER-encoded ASN.1 data structures, as defined in ITU-T Rec X.690.</source>
          <target state="translated">패키지 asn1은 ITU-T Rec X.690에 정의 된대로 DER로 인코딩 된 ASN.1 데이터 구조의 구문 분석을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="c08d789dfd150c497744e5eae59ce25bf42b161c" translate="yes" xml:space="preserve">
          <source>Package ast</source>
          <target state="translated">ast 패키지</target>
        </trans-unit>
        <trans-unit id="93ce17c079d14adf086a4a91c618dc024db4dcea" translate="yes" xml:space="preserve">
          <source>Package ast declares the types used to represent syntax trees for Go packages.</source>
          <target state="translated">Package ast는 Go 패키지의 구문 트리를 나타내는 데 사용되는 유형을 선언합니다.</target>
        </trans-unit>
        <trans-unit id="abc4155f0dfe705449b74dd36086fa20264918b2" translate="yes" xml:space="preserve">
          <source>Package atomic</source>
          <target state="translated">패키지 원자</target>
        </trans-unit>
        <trans-unit id="6ccbd2fd52492c5f3e2a1a498498664cb5ffa588" translate="yes" xml:space="preserve">
          <source>Package atomic provides low-level atomic memory primitives useful for implementing synchronization algorithms.</source>
          <target state="translated">패키지 원자는 동기화 알고리즘을 구현하는 데 유용한 저수준 원자 메모리 프리미티브를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4ae1e53a5fe2ac3a3b380e5791057e84bdf2fcee" translate="yes" xml:space="preserve">
          <source>Package base32</source>
          <target state="translated">패키지 base32</target>
        </trans-unit>
        <trans-unit id="3b12a0015b14e3cc130f8b62c8c17d7c8624a97a" translate="yes" xml:space="preserve">
          <source>Package base32 implements base32 encoding as specified by RFC 4648.</source>
          <target state="translated">패키지 base32는 RFC 4648에 지정된 base32 인코딩을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="38a49427af734eb5994d226888d46a2e48a7e089" translate="yes" xml:space="preserve">
          <source>Package base64</source>
          <target state="translated">패키지 base64</target>
        </trans-unit>
        <trans-unit id="2daca13cb62da6b7b33a641f5439803312f106f9" translate="yes" xml:space="preserve">
          <source>Package base64 implements base64 encoding as specified by RFC 4648.</source>
          <target state="translated">패키지 base64는 RFC 4648에 지정된대로 base64 인코딩을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="03b1336c942a57d9960d475b8b394ed19dde9d0c" translate="yes" xml:space="preserve">
          <source>Package big</source>
          <target state="translated">큰 패키지</target>
        </trans-unit>
        <trans-unit id="b4e5fa3ccf50e02964b74ff445efc105e444e505" translate="yes" xml:space="preserve">
          <source>Package big implements arbitrary-precision arithmetic (big numbers).</source>
          <target state="translated">큰 패키지는 임의의 정밀도 산술 (큰 숫자)을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="4e4c386fba82f93790e8829cc10da0258293e392" translate="yes" xml:space="preserve">
          <source>Package big implements arbitrary-precision arithmetic (big numbers). The following numeric types are supported:</source>
          <target state="translated">큰 패키지는 임의의 정밀도 산술 (큰 숫자)을 구현합니다. 다음과 같은 숫자 유형이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="c20a791c17d35561b3248e9f4e27c1fc641c805c" translate="yes" xml:space="preserve">
          <source>Package binary</source>
          <target state="translated">패키지 바이너리</target>
        </trans-unit>
        <trans-unit id="a02abb66bca85bad533ac6ecbbd5730f265b40da" translate="yes" xml:space="preserve">
          <source>Package binary implements simple translation between numbers and byte sequences and encoding and decoding of varints.</source>
          <target state="translated">패키지 바이너리는 숫자와 바이트 시퀀스 간의 간단한 변환과 varint의 인코딩 및 디코딩을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="b4585c8f5f16a7a3bbd64f720869325930c04b14" translate="yes" xml:space="preserve">
          <source>Package bits</source>
          <target state="translated">패키지 비트</target>
        </trans-unit>
        <trans-unit id="f121f6160680c1e9d47eb4f125af85e968cef0c7" translate="yes" xml:space="preserve">
          <source>Package bits implements bit counting and manipulation functions for the predeclared unsigned integer types.</source>
          <target state="translated">패키지 비트는 미리 선언 된 부호없는 정수 유형에 대한 비트 계산 및 조작 기능을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="83caad2c4e72c3c320f775fbd8a1a35e735677a9" translate="yes" xml:space="preserve">
          <source>Package bufio</source>
          <target state="translated">패키지 bufio</target>
        </trans-unit>
        <trans-unit id="880f9f9e86187c3ab9594c87162508890d92b1e0" translate="yes" xml:space="preserve">
          <source>Package bufio implements buffered I/O. It wraps an io.Reader or io.Writer object, creating another object (Reader or Writer) that also implements the interface but provides buffering and some help for textual I/O.</source>
          <target state="translated">패키지 bufio는 버퍼링 된 I / O를 구현합니다. io.Reader 또는 io.Writer 객체를 래핑하여 인터페이스를 구현하지만 버퍼링 및 텍스트 I / O에 대한 일부 도움말을 제공하는 다른 객체 (Reader 또는 Writer)를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="8f54827014010e49f148fc60f5174298cb86d1a9" translate="yes" xml:space="preserve">
          <source>Package build</source>
          <target state="translated">패키지 빌드</target>
        </trans-unit>
        <trans-unit id="044aa6ad5cb13105de3d1dfe1e14ba517afc7dc8" translate="yes" xml:space="preserve">
          <source>Package build gathers information about Go packages.</source>
          <target state="translated">패키지 빌드는 Go 패키지에 대한 정보를 수집합니다.</target>
        </trans-unit>
        <trans-unit id="47ff1a6f77a6fab0a4ec0e7b02acecd8b23bea55" translate="yes" xml:space="preserve">
          <source>Package builtin</source>
          <target state="translated">내장 패키지</target>
        </trans-unit>
        <trans-unit id="bc6082d4c1ffc50e8646c383c442de7a0853f3b7" translate="yes" xml:space="preserve">
          <source>Package builtin provides documentation for Go's predeclared identifiers. The items documented here are not actually in package builtin but their descriptions here allow godoc to present documentation for the language's special identifiers.</source>
          <target state="translated">패키지 내장은 Go의 사전 선언 된 식별자에 대한 설명서를 제공합니다. 여기에 문서화 된 항목은 실제로 패키지 기본 제공은 아니지만 여기에서 설명하면 godoc이 언어의 특수 식별자에 대한 문서를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f18adabe10f881275c2b2d516cabb008577c2f65" translate="yes" xml:space="preserve">
          <source>Package bytes</source>
          <target state="translated">패키지 바이트</target>
        </trans-unit>
        <trans-unit id="48c486630207fb1f7940fbb120ac097a31665a2b" translate="yes" xml:space="preserve">
          <source>Package bytes implements functions for the manipulation of byte slices. It is analogous to the facilities of the strings package.</source>
          <target state="translated">패키지 바이트는 바이트 슬라이스 조작을위한 기능을 구현합니다. 문자열 패키지의 기능과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="406c2304145d14ae40562458c269fc1090a1b790" translate="yes" xml:space="preserve">
          <source>Package bzip2</source>
          <target state="translated">패키지 bzip2</target>
        </trans-unit>
        <trans-unit id="8eb7c863e2530f3f68b4ee1a3003e658910e2132" translate="yes" xml:space="preserve">
          <source>Package bzip2 implements bzip2 decompression.</source>
          <target state="translated">패키지 bzip2는 bzip2 압축 해제를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="872b31b797dd9ef4b907e19e6db917bdf3d1c013" translate="yes" xml:space="preserve">
          <source>Package cgi</source>
          <target state="translated">패키지 CGI</target>
        </trans-unit>
        <trans-unit id="25ac46feb1a43e83003062fe9e6ccdab9ea2b191" translate="yes" xml:space="preserve">
          <source>Package cgi implements CGI (Common Gateway Interface) as specified in RFC 3875.</source>
          <target state="translated">패키지 cgi는 RFC 3875에 지정된대로 CGI (Common Gateway Interface)를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="25e89bccb479aa882a9bfc5409a3323ae38e9e25" translate="yes" xml:space="preserve">
          <source>Package cgo</source>
          <target state="translated">패키지 CGO</target>
        </trans-unit>
        <trans-unit id="0e3e2e5c14219e52219e14faf9778f4b602d6c0d" translate="yes" xml:space="preserve">
          <source>Package cgo contains runtime support for code generated by the cgo tool.</source>
          <target state="translated">패키지 cgo에는 cgo 도구로 생성 된 코드에 대한 런타임 지원이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e62ea60a0dd1e82f411152a3d6419b7bf76fb06" translate="yes" xml:space="preserve">
          <source>Package cgo contains runtime support for code generated by the cgo tool. See the documentation for the cgo command for details on using cgo.</source>
          <target state="translated">패키지 cgo에는 cgo 도구로 생성 된 코드에 대한 런타임 지원이 포함되어 있습니다. cgo 사용에 대한 자세한 내용은 cgo 명령 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="012f0d22cbfff5b4121f59681774b6bcdc6c8bf7" translate="yes" xml:space="preserve">
          <source>Package cipher</source>
          <target state="translated">패키지 암호</target>
        </trans-unit>
        <trans-unit id="30f3e7b90bc36d4a04ee0c6ee4fede5b412b7a90" translate="yes" xml:space="preserve">
          <source>Package cipher implements standard block cipher modes that can be wrapped around low-level block cipher implementations.</source>
          <target state="translated">패키지 암호는 저수준 블록 암호 구현으로 감싸 질 수있는 표준 블록 암호 모드를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="991a9a7de6b61fdec46bfd3e8877fa7f538b6fb2" translate="yes" xml:space="preserve">
          <source>Package cipher implements standard block cipher modes that can be wrapped around low-level block cipher implementations. See &lt;a href=&quot;https://csrc.nist.gov/groups/ST/toolkit/BCM/current_modes.html&quot;&gt;https://csrc.nist.gov/groups/ST/toolkit/BCM/current_modes.html&lt;/a&gt; and NIST Special Publication 800-38A.</source>
          <target state="translated">패키지 암호는 저수준 블록 암호 구현으로 감싸 질 수있는 표준 블록 암호 모드를 구현합니다. &lt;a href=&quot;https://csrc.nist.gov/groups/ST/toolkit/BCM/current_modes.html&quot;&gt;https://csrc.nist.gov/groups/ST/toolkit/BCM/current_modes.html&lt;/a&gt; 및 NIST Special Publication 800-38A를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="2b6816262bb29ee185f0f48249d8bc3daaf55582" translate="yes" xml:space="preserve">
          <source>Package cmplx</source>
          <target state="translated">패키지 cmplx</target>
        </trans-unit>
        <trans-unit id="baf57dd7a6b5ac4706888aba9eb1258cba96f27c" translate="yes" xml:space="preserve">
          <source>Package cmplx provides basic constants and mathematical functions for complex numbers.</source>
          <target state="translated">패키지 cmplx는 복소수에 대한 기본 상수 및 수학 함수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="cec1c5cc750dac259d8c1d78dff5abb6d6052171" translate="yes" xml:space="preserve">
          <source>Package cmplx provides basic constants and mathematical functions for complex numbers. Special case handling conforms to the C99 standard Annex G IEC 60559-compatible complex arithmetic.</source>
          <target state="translated">패키지 cmplx는 복소수에 대한 기본 상수 및 수학 함수를 제공합니다. 특수 케이스 처리는 C99 표준 Annex G IEC 60559 호환 복잡한 산술을 준수합니다.</target>
        </trans-unit>
        <trans-unit id="37d8c891f48030e536dd7b758ded3702c02139dc" translate="yes" xml:space="preserve">
          <source>Package color</source>
          <target state="translated">패키지 색상</target>
        </trans-unit>
        <trans-unit id="0c0c35fbc62909ad60418ab34664b2ed01195fb4" translate="yes" xml:space="preserve">
          <source>Package color implements a basic color library.</source>
          <target state="translated">패키지 색상은 기본 색상 라이브러리를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="1bcb3d15e235264a42cb3594781e34e58e7e4025" translate="yes" xml:space="preserve">
          <source>Package constant</source>
          <target state="translated">패키지 상수</target>
        </trans-unit>
        <trans-unit id="cc9ee19fe4a55fca4b94e371e7f50f3a89a325d9" translate="yes" xml:space="preserve">
          <source>Package constant implements Values representing untyped Go constants and their corresponding operations.</source>
          <target state="translated">패키지 상수는 형식화되지 않은 Go 상수 및 해당 작업을 나타내는 값을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="24c9a6d37d35bffec10a3bb7669106848323d2dd" translate="yes" xml:space="preserve">
          <source>Package constraint</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98b045c5225f0d57e5243e2a0fcd0b0b44b8c1a2" translate="yes" xml:space="preserve">
          <source>Package constraint implements parsing and evaluation of build constraint lines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd0d1549bfb32741dae188d59915c9f5c6bf61cb" translate="yes" xml:space="preserve">
          <source>Package constraint implements parsing and evaluation of build constraint lines. See &lt;a href=&quot;https://golang.org/cmd/go/#hdr-Build_constraints&quot;&gt;https://golang.org/cmd/go/#hdr-Build_constraints&lt;/a&gt; for documentation about build constraints themselves.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f37b57ba6586f71a43fafcb43910fbb2fb02fc3b" translate="yes" xml:space="preserve">
          <source>Package context</source>
          <target state="translated">패키지 컨텍스트</target>
        </trans-unit>
        <trans-unit id="d3934777ec3c952a9b50c31b8ba59b107a7a5d55" translate="yes" xml:space="preserve">
          <source>Package context defines the Context type, which carries deadlines, cancellation signals, and other request-scoped values across API boundaries and between processes.</source>
          <target state="translated">패키지 컨텍스트는 컨텍스트 유형을 정의하며, 이는 API 경계 및 프로세스 간 마감일, 취소 신호 및 기타 요청 범위 값을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="2959c61a1310320ade48360831ded95782ef16b3" translate="yes" xml:space="preserve">
          <source>Package cookiejar</source>
          <target state="translated">패키지 쿠키</target>
        </trans-unit>
        <trans-unit id="8c90ea9e027ef93e3a9e5e3949e57755bbbd286c" translate="yes" xml:space="preserve">
          <source>Package cookiejar implements an in-memory RFC 6265-compliant http.CookieJar.</source>
          <target state="translated">패키지 cookiejar는 메모리 내 RFC 6265 호환 http.CookieJar를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="9b8215374e5e8361fe90b06ebf351541009e3e3e" translate="yes" xml:space="preserve">
          <source>Package crc32</source>
          <target state="translated">패키지 crc32</target>
        </trans-unit>
        <trans-unit id="b3a9ccd429f36d4cdadd48a9085d7744e115a2de" translate="yes" xml:space="preserve">
          <source>Package crc32 implements the 32-bit cyclic redundancy check, or CRC-32, checksum.</source>
          <target state="translated">패키지 crc32는 32 비트 순환 중복 검사 (CRC-32) 체크섬을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="e7dea81d74d4673657a098152e4028683fa05c21" translate="yes" xml:space="preserve">
          <source>Package crc32 implements the 32-bit cyclic redundancy check, or CRC-32, checksum. See &lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&lt;/a&gt; for information.</source>
          <target state="translated">패키지 crc32는 32 비트 순환 중복 검사 (CRC-32) 체크섬을 구현합니다. 자세한 내용은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&lt;/a&gt; 를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="bd8911118f577811f18d0e59d8eb3416d753ee3d" translate="yes" xml:space="preserve">
          <source>Package crc64</source>
          <target state="translated">패키지 crc64</target>
        </trans-unit>
        <trans-unit id="3f711a93350858163dc7138684052f433c0da645" translate="yes" xml:space="preserve">
          <source>Package crc64 implements the 64-bit cyclic redundancy check, or CRC-64, checksum.</source>
          <target state="translated">패키지 crc64는 64 비트 순환 중복 검사 (CRC-64) 체크섬을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="ddff3dc011b09fe55bbaec41ef9b74c6f1146846" translate="yes" xml:space="preserve">
          <source>Package crc64 implements the 64-bit cyclic redundancy check, or CRC-64, checksum. See &lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&lt;/a&gt; for information.</source>
          <target state="translated">패키지 crc64는 64 비트 순환 중복 검사 (CRC-64) 체크섬을 구현합니다. 자세한 내용은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&lt;/a&gt; 를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="4f6d2ede86f313691ef17454cdcdea04be0dbbb5" translate="yes" xml:space="preserve">
          <source>Package crypto</source>
          <target state="translated">패키지 암호화</target>
        </trans-unit>
        <trans-unit id="50dd6822d044a230766309da5791bbd273ba8e97" translate="yes" xml:space="preserve">
          <source>Package crypto collects common cryptographic constants.</source>
          <target state="translated">패키지 암호화는 일반적인 암호화 상수를 수집합니다.</target>
        </trans-unit>
        <trans-unit id="6ce5f5b5df462bd32a5711f5f5fa215ca1b166ed" translate="yes" xml:space="preserve">
          <source>Package csv</source>
          <target state="translated">패키지 CSV</target>
        </trans-unit>
        <trans-unit id="40dd7303701bdcc70dc0c5df42eb5d6ee214e250" translate="yes" xml:space="preserve">
          <source>Package csv reads and writes comma-separated values (CSV) files.</source>
          <target state="translated">csv 패키지는 CSV (쉼표로 구분 된 값) 파일을 읽고 씁니다.</target>
        </trans-unit>
        <trans-unit id="d150a0359eb47f620b34dee9c311dced79bcede8" translate="yes" xml:space="preserve">
          <source>Package csv reads and writes comma-separated values (CSV) files. There are many kinds of CSV files; this package supports the format described in RFC 4180.</source>
          <target state="translated">csv 패키지는 CSV (쉼표로 구분 된 값) 파일을 읽고 씁니다. CSV 파일에는 여러 종류가 있습니다. 이 패키지는 RFC 4180에 설명 된 형식을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="c161780a1f5eed6cb5eacae516343d9cf53f40a2" translate="yes" xml:space="preserve">
          <source>Package debug</source>
          <target state="translated">패키지 디버그</target>
        </trans-unit>
        <trans-unit id="e18c0cfe3c81fb4f011a9c8574f9e5713e35fc2f" translate="yes" xml:space="preserve">
          <source>Package debug contains facilities for programs to debug themselves while they are running.</source>
          <target state="translated">패키지 디버그에는 프로그램이 실행되는 동안 스스로 디버깅 할 수있는 기능이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="923e094a4a23dcbdaf9a79a349be666ee4da178a" translate="yes" xml:space="preserve">
          <source>Package des</source>
          <target state="translated">패키지 데</target>
        </trans-unit>
        <trans-unit id="f4273b555bae00c756bb38c4bdb36871d156fde9" translate="yes" xml:space="preserve">
          <source>Package des implements the Data Encryption Standard (DES) and the Triple Data Encryption Algorithm (TDEA) as defined in U.S. Federal Information Processing Standards Publication 46-3.</source>
          <target state="translated">패키지 des는 미국 연방 정보 처리 표준 간행물 46-3에 정의 된대로 DES (Data Encryption Standard) 및 TDEA (Triple Data Encryption Algorithm)를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="6bf60b0613abca5907226299b84a4808f25c054a" translate="yes" xml:space="preserve">
          <source>Package doc</source>
          <target state="translated">패키지 문서</target>
        </trans-unit>
        <trans-unit id="994d342a4898c4785e34e9db0e04a8dc47ee5ddc" translate="yes" xml:space="preserve">
          <source>Package doc extracts source code documentation from a Go AST.</source>
          <target state="translated">패키지 문서는 Go AST에서 소스 코드 문서를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="5069be6dcffa96eefcc7e1232c85b45e87fe235f" translate="yes" xml:space="preserve">
          <source>Package draw</source>
          <target state="translated">패키지 추첨</target>
        </trans-unit>
        <trans-unit id="969fe7ec8173399610653b077ab51865992b53af" translate="yes" xml:space="preserve">
          <source>Package draw provides image composition functions.</source>
          <target state="translated">패키지 드로우는 이미지 합성 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b15191fdde73d73923a18606c1904389361bc1f7" translate="yes" xml:space="preserve">
          <source>Package driver</source>
          <target state="translated">패키지 드라이버</target>
        </trans-unit>
        <trans-unit id="5c56f884cb2d5a4829273b5f372f47a0c56fc3c2" translate="yes" xml:space="preserve">
          <source>Package driver defines interfaces to be implemented by database drivers as used by package sql.</source>
          <target state="translated">패키지 드라이버는 sql 패키지에서 사용되는 데이터베이스 드라이버로 구현할 인터페이스를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="75bfd93d536faf5b82f79c9e4a6af54202df462f" translate="yes" xml:space="preserve">
          <source>Package dsa</source>
          <target state="translated">패키지 dsa</target>
        </trans-unit>
        <trans-unit id="1e5b1f9060cf17d69c4113c4252756af952bfee1" translate="yes" xml:space="preserve">
          <source>Package dsa implements the Digital Signature Algorithm, as defined in FIPS 186-3.</source>
          <target state="translated">패키지 dsa는 FIPS 186-3에 정의 된대로 디지털 서명 알고리즘을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="bba8e43639aa6507cfdd4c58cc34c9fb8b2cf7ed" translate="yes" xml:space="preserve">
          <source>Package dwarf</source>
          <target state="translated">패키지 난쟁이</target>
        </trans-unit>
        <trans-unit id="14e7ceae4640d2c62b637a66be95977203616d50" translate="yes" xml:space="preserve">
          <source>Package dwarf provides access to DWARF debugging information loaded from executable files, as defined in the DWARF 2.0 Standard at &lt;a href=&quot;http://dwarfstd.org/doc/dwarf-2.0.0.pdf&quot;&gt;http://dwarfstd.org/doc/dwarf-2.0.0.pdf&lt;/a&gt;</source>
          <target state="translated">패키지 dwarf는 DWARF 2.0 표준 ( &lt;a href=&quot;http://dwarfstd.org/doc/dwarf-2.0.0.pdf&quot;&gt;http://dwarfstd.org/doc/dwarf-2.0.0.pdf)에&lt;/a&gt; 정의 된 실행 파일에서로드 된 DWARF 디버깅 정보에 대한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ccd56c1dfed1c041a4d12453cec3b05cda768eb7" translate="yes" xml:space="preserve">
          <source>Package ecdsa</source>
          <target state="translated">패키지 ecdsa</target>
        </trans-unit>
        <trans-unit id="352bd4aa5e4bbbc282580a9c214c315f78762a78" translate="yes" xml:space="preserve">
          <source>Package ecdsa implements the Elliptic Curve Digital Signature Algorithm, as defined in FIPS 186-3.</source>
          <target state="translated">ecdsa 패키지는 FIPS 186-3에 정의 된대로 타원 곡선 디지털 서명 알고리즘을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="22f041b9e4b005e5e63601ee047c6784ff58304a" translate="yes" xml:space="preserve">
          <source>Package ed25519</source>
          <target state="translated">패키지 ed25519</target>
        </trans-unit>
        <trans-unit id="fb8453c2683c8a0379237947977a4025115b54f4" translate="yes" xml:space="preserve">
          <source>Package ed25519 implements the Ed25519 signature algorithm.</source>
          <target state="translated">패키지 ed25519는 Ed25519 서명 알고리즘을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="59626533c02e37a4826df5b84fcfc9afa7203b79" translate="yes" xml:space="preserve">
          <source>Package ed25519 implements the Ed25519 signature algorithm. See &lt;a href=&quot;https://ed25519.cr.yp.to/&quot;&gt;https://ed25519.cr.yp.to/&lt;/a&gt;.</source>
          <target state="translated">패키지 ed25519는 Ed25519 서명 알고리즘을 구현합니다. &lt;a href=&quot;https://ed25519.cr.yp.to/&quot;&gt;https://ed25519.cr.yp.to/를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="22876ea6aba1d18293913d0db2521ad8767018c8" translate="yes" xml:space="preserve">
          <source>Package elf</source>
          <target state="translated">패키지 엘프</target>
        </trans-unit>
        <trans-unit id="e380ec79714ca14aed830146e07f72516490e0b8" translate="yes" xml:space="preserve">
          <source>Package elf implements access to ELF object files.</source>
          <target state="translated">Package elf는 ELF 객체 파일에 대한 액세스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="c011316b96f999a9e3cf849a36b3fc15797d8e99" translate="yes" xml:space="preserve">
          <source>Package elliptic</source>
          <target state="translated">타원 패키지</target>
        </trans-unit>
        <trans-unit id="3bab3655adc3a192a092b071bc83e45652e1d476" translate="yes" xml:space="preserve">
          <source>Package elliptic implements several standard elliptic curves over prime fields.</source>
          <target state="translated">패키지 타원은 소수 필드에 여러 표준 타원 곡선을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="50d1b2632f0717d2aa181f074409034967564a4c" translate="yes" xml:space="preserve">
          <source>Package embed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe7d97c649fe8203079542be753a5d538190fc89" translate="yes" xml:space="preserve">
          <source>Package embed provides access to files embedded in the running Go program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1b2d294cf9a0cfac69d667bd45e68644ccbf3c6" translate="yes" xml:space="preserve">
          <source>Package encoding</source>
          <target state="translated">패키지 인코딩</target>
        </trans-unit>
        <trans-unit id="ed189180f83e61e5ab517f381324404e9d31f4c0" translate="yes" xml:space="preserve">
          <source>Package encoding defines interfaces shared by other packages that convert data to and from byte-level and textual representations. Packages that check for these interfaces include encoding/gob, encoding/json, and encoding/xml. As a result, implementing an interface once can make a type useful in multiple encodings. Standard types that implement these interfaces include time.Time and net.IP. The interfaces come in pairs that produce and consume encoded data.</source>
          <target state="translated">패키지 인코딩은 데이터를 바이트 수준 및 텍스트 표현으로 변환하거나 변환하는 다른 패키지와 공유되는 인터페이스를 정의합니다. 이러한 인터페이스를 확인하는 패키지에는 인코딩 / 고브, 인코딩 / json 및 인코딩 / xml이 포함됩니다. 결과적으로 인터페이스를 한 번 구현하면 여러 인코딩에서 유형을 유용하게 만들 수 있습니다. 이러한 인터페이스를 구현하는 표준 유형에는 time.Time 및 net.IP가 있습니다. 인터페이스는 인코딩 된 데이터를 생성하고 소비하는 쌍으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="6ee23de7e1e5b835e55c54376bdadcfebe218831" translate="yes" xml:space="preserve">
          <source>Package errors</source>
          <target state="translated">패키지 오류</target>
        </trans-unit>
        <trans-unit id="4a3bda8668f0f7be8e4653eb9de5b1df5a4b72ae" translate="yes" xml:space="preserve">
          <source>Package errors implements functions to manipulate errors.</source>
          <target state="translated">패키지 오류는 오류를 조작하는 기능을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="7627f68608d0501d49a4083a780c7eb361e07f6d" translate="yes" xml:space="preserve">
          <source>Package exec</source>
          <target state="translated">패키지 exec</target>
        </trans-unit>
        <trans-unit id="ee030f10ad063000193fa361b43cfffc1bcc3c8c" translate="yes" xml:space="preserve">
          <source>Package exec runs external commands.</source>
          <target state="translated">패키지 exec는 외부 명령을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="7b3a0dfc0fae8cd217bc6e25080e713ad98645d6" translate="yes" xml:space="preserve">
          <source>Package exec runs external commands. It wraps os.StartProcess to make it easier to remap stdin and stdout, connect I/O with pipes, and do other adjustments.</source>
          <target state="translated">패키지 exec는 외부 명령을 실행합니다. os.StartProcess를 래핑하여 stdin 및 stdout을 쉽게 다시 매핑하고 I / O를 파이프와 연결하며 다른 조정을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56d612eb4d8eb6cceb1e7052a93aac6c0e863c13" translate="yes" xml:space="preserve">
          <source>Package expvar</source>
          <target state="translated">패키지 expvar</target>
        </trans-unit>
        <trans-unit id="8556b9ff068352b9cd4f96c39543b774957282c2" translate="yes" xml:space="preserve">
          <source>Package expvar provides a standardized interface to public variables, such as operation counters in servers. It exposes these variables via HTTP at /debug/vars in JSON format.</source>
          <target state="translated">패키지 expvar은 서버의 작업 카운터와 같은 공용 변수에 대한 표준화 된 인터페이스를 제공합니다. JSON 형식의 / debug / vars에서 HTTP를 통해 이러한 변수를 노출합니다.</target>
        </trans-unit>
        <trans-unit id="7753afb6ef13a60250c22070f9d8cb74aca0cdd9" translate="yes" xml:space="preserve">
          <source>Package fcgi</source>
          <target state="translated">패키지 FCGI</target>
        </trans-unit>
        <trans-unit id="2130ff15a15a985590dbae853cbc6bd5f16bc412" translate="yes" xml:space="preserve">
          <source>Package fcgi implements the FastCGI protocol.</source>
          <target state="translated">패키지 fcgi는 FastCGI 프로토콜을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="2f468670b5944c845b0cba8a76b0cc4bc25c4814" translate="yes" xml:space="preserve">
          <source>Package filepath</source>
          <target state="translated">패키지 파일 경로</target>
        </trans-unit>
        <trans-unit id="aad84fa78fc1a5621f1a8d48a9f041dd752165f9" translate="yes" xml:space="preserve">
          <source>Package filepath implements utility routines for manipulating filename paths in a way compatible with the target operating system-defined file paths.</source>
          <target state="translated">패키지 파일 경로는 대상 운영 체제 정의 파일 경로와 호환되는 방식으로 파일 이름 경로를 조작하기위한 유틸리티 루틴을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="20c64fec5374a451273360446201779aff8c1424" translate="yes" xml:space="preserve">
          <source>Package files</source>
          <target state="translated">패키지 파일</target>
        </trans-unit>
        <trans-unit id="e5471378272dfaa2efadcd1f53861518b9f099f7" translate="yes" xml:space="preserve">
          <source>Package flag</source>
          <target state="translated">패키지 플래그</target>
        </trans-unit>
        <trans-unit id="e7d9cd955d937c95fcd6a1739c4bfae5a8cbabd2" translate="yes" xml:space="preserve">
          <source>Package flag implements command-line flag parsing.</source>
          <target state="translated">패키지 플래그는 명령 줄 플래그 구문 분석을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="a337ebb67872d5c06c8e204854b5aa24937ec53e" translate="yes" xml:space="preserve">
          <source>Package flate</source>
          <target state="translated">패키지 플랫</target>
        </trans-unit>
        <trans-unit id="cd21214e87a49e1d6a376d93be54459975506452" translate="yes" xml:space="preserve">
          <source>Package flate implements the DEFLATE compressed data format, described in RFC 1951. The gzip and zlib packages implement access to DEFLATE-based file formats.</source>
          <target state="translated">패키지 플랫은 RFC 1951에 설명 된 DEFLATE 압축 데이터 형식을 구현합니다. gzip 및 zlib 패키지는 DEFLATE 기반 파일 형식에 대한 액세스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="803b763e8c63b8639017426b9ddb6efdb2934c44" translate="yes" xml:space="preserve">
          <source>Package fmt</source>
          <target state="translated">패키지 fmt</target>
        </trans-unit>
        <trans-unit id="d4c2ac9d05c1a7be572af9a00f7d2ee2c86ace0b" translate="yes" xml:space="preserve">
          <source>Package fmt implements formatted I/O with functions analogous to C's printf and scanf. The format 'verbs' are derived from C's but are simpler.</source>
          <target state="translated">패키지 fmt는 C의 printf 및 scanf와 유사한 기능을 가진 형식화 된 I / O를 구현합니다. '동사'형식은 C에서 파생되지만 더 간단합니다.</target>
        </trans-unit>
        <trans-unit id="d7f1bbda6df0adc48225339cb988bf008c879f32" translate="yes" xml:space="preserve">
          <source>Package fnv</source>
          <target state="translated">패키지 fnv</target>
        </trans-unit>
        <trans-unit id="1ed450736ae5a7fac5851c4ce48e5c295154cd82" translate="yes" xml:space="preserve">
          <source>Package fnv implements FNV-1 and FNV-1a, non-cryptographic hash functions created by Glenn Fowler, Landon Curt Noll, and Phong Vo.</source>
          <target state="translated">패키지 fnv는 Glenn Fowler, Landon Curt Noll 및 Phong Vo가 만든 비 암호 해시 함수 인 FNV-1 및 FNV-1a를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="3bfeda77f81e7eb63d4ceaa90d61b0d8cdf6c313" translate="yes" xml:space="preserve">
          <source>Package fnv implements FNV-1 and FNV-1a, non-cryptographic hash functions created by Glenn Fowler, Landon Curt Noll, and Phong Vo. See &lt;a href=&quot;https://en.wikipedia.org/wiki/Fowler-Noll-Vo_hash_function&quot;&gt;https://en.wikipedia.org/wiki/Fowler-Noll-Vo_hash_function&lt;/a&gt;.</source>
          <target state="translated">패키지 fnv는 Glenn Fowler, Landon Curt Noll 및 Phong Vo가 만든 비 암호 해시 함수 인 FNV-1 및 FNV-1a를 구현합니다. &lt;a href=&quot;https://en.wikipedia.org/wiki/Fowler-Noll-Vo_hash_function&quot;&gt;https://en.wikipedia.org/wiki/Fowler-Noll-Vo_hash_function을&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="6e1e99b0cea0f06b1bed3052795d0456203e66ac" translate="yes" xml:space="preserve">
          <source>Package format</source>
          <target state="translated">패키지 형식</target>
        </trans-unit>
        <trans-unit id="44b5a52572ad981c0279cfa1b8249c656292c37c" translate="yes" xml:space="preserve">
          <source>Package format implements standard formatting of Go source.</source>
          <target state="translated">패키지 형식은 Go 소스의 표준 형식을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="ea471709f1096aad48e7c76286e5acfe1b4f1658" translate="yes" xml:space="preserve">
          <source>Package fs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecc170182343b9acbc49399a571c0bf5cdaa286e" translate="yes" xml:space="preserve">
          <source>Package fs defines basic interfaces to a file system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48e9e53ed3536d4912df46e0962f56c550d05b56" translate="yes" xml:space="preserve">
          <source>Package fs defines basic interfaces to a file system. A file system can be provided by the host operating system but also by other packages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10794fc70844a16a1ca02980500d4bade1aabcb2" translate="yes" xml:space="preserve">
          <source>Package fstest</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="730297a3843e81d6e02a169d9ecb873ab96a3dae" translate="yes" xml:space="preserve">
          <source>Package fstest implements support for testing implementations and users of file systems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b91f9f521a74becec1958e73da770098048f55a7" translate="yes" xml:space="preserve">
          <source>Package gif</source>
          <target state="translated">패키지 gif</target>
        </trans-unit>
        <trans-unit id="10af1984ddf2d910dc561741c129eaf2fb3d93fc" translate="yes" xml:space="preserve">
          <source>Package gif implements a GIF image decoder and encoder.</source>
          <target state="translated">패키지 gif는 GIF 이미지 디코더 및 인코더를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="e3be21e16b230bb3bdb8bf1710ba144ad69deeeb" translate="yes" xml:space="preserve">
          <source>Package gob</source>
          <target state="translated">패키지 덩어리</target>
        </trans-unit>
        <trans-unit id="a418c33843d2c062092d6d7c6a4b5816c45727d5" translate="yes" xml:space="preserve">
          <source>Package gob manages streams of gobs - binary values exchanged between an Encoder (transmitter) and a Decoder (receiver).</source>
          <target state="translated">패키지 gob는 gob의 스트림을 관리합니다-인코더 (송신기)와 디코더 (수신기)간에 교환 된 이진 값.</target>
        </trans-unit>
        <trans-unit id="44cd01d964bb483f352db2a1b5d4abe8f1b01e5e" translate="yes" xml:space="preserve">
          <source>Package gob manages streams of gobs - binary values exchanged between an Encoder (transmitter) and a Decoder (receiver). A typical use is transporting arguments and results of remote procedure calls (RPCs) such as those provided by package &quot;net/rpc&quot;.</source>
          <target state="translated">패키지 gob는 gob의 스트림을 관리합니다-인코더 (송신기)와 디코더 (수신기)간에 교환 된 이진 값. &quot;net / rpc&quot;패키지에서 제공하는 것과 같은 RPC (원격 프로 시저 호출)의 인수 및 결과를 전송하는 것이 일반적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="00c000f3850e24bf28c662891a897dac5381ac6c" translate="yes" xml:space="preserve">
          <source>Package gosym</source>
          <target state="translated">패키지 gosym</target>
        </trans-unit>
        <trans-unit id="2e38d0f781b2d46a7d764ec5db29147877b83b80" translate="yes" xml:space="preserve">
          <source>Package gosym implements access to the Go symbol and line number tables embedded in Go binaries generated by the gc compilers.</source>
          <target state="translated">패키지 gosym은 gc 컴파일러가 생성 한 Go 바이너리에 포함 된 Go 기호 및 행 번호 테이블에 대한 액세스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="7a918ba298748f37d152f5cb60e30e14a28d12c9" translate="yes" xml:space="preserve">
          <source>Package gzip</source>
          <target state="translated">패키지 gzip</target>
        </trans-unit>
        <trans-unit id="29dec348206cd4001b61a9c9f0a5d0e43fd7f769" translate="yes" xml:space="preserve">
          <source>Package gzip implements reading and writing of gzip format compressed files, as specified in RFC 1952.</source>
          <target state="translated">패키지 gzip은 RFC 1952에 지정된 gzip 형식 압축 파일 읽기 및 쓰기를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="14ea7753f344ada7c0aa1963e2baed63cdc13331" translate="yes" xml:space="preserve">
          <source>Package hash</source>
          <target state="translated">패키지 해시</target>
        </trans-unit>
        <trans-unit id="a85d6200368ac18f684b218608b5fa8afb33d33f" translate="yes" xml:space="preserve">
          <source>Package hash provides interfaces for hash functions.</source>
          <target state="translated">패키지 해시는 해시 함수를위한 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3a59626485ffbd81c7d5e90634cb6e93e7c34e5b" translate="yes" xml:space="preserve">
          <source>Package heap</source>
          <target state="translated">패키지 힙</target>
        </trans-unit>
        <trans-unit id="e93c407a24d497fcea18deaab136750e41bee04c" translate="yes" xml:space="preserve">
          <source>Package heap provides heap operations for any type that implements heap.Interface. A heap is a tree with the property that each node is the minimum-valued node in its subtree.</source>
          <target state="translated">패키지 힙은 heap.Interface를 구현하는 모든 유형에 대해 힙 작업을 제공합니다. 힙은 각 노드가 하위 트리에서 최소값 노드라는 속성이있는 트리입니다.</target>
        </trans-unit>
        <trans-unit id="7b0d8dd93b6da00a5a3853f6a8971b11d3be119a" translate="yes" xml:space="preserve">
          <source>Package hex</source>
          <target state="translated">패키지 헥스</target>
        </trans-unit>
        <trans-unit id="7413aef6d1364ce17833992530bdefe998ac3dba" translate="yes" xml:space="preserve">
          <source>Package hex implements hexadecimal encoding and decoding.</source>
          <target state="translated">패키지 16 진수는 16 진 인코딩 및 디코딩을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="1ae2b94353abc10afddd7e75ff8292b5ec664627" translate="yes" xml:space="preserve">
          <source>Package hmac</source>
          <target state="translated">패키지 hmac</target>
        </trans-unit>
        <trans-unit id="5862414bf4e6f484aa549d995a6f4852a7f9b0df" translate="yes" xml:space="preserve">
          <source>Package hmac implements the Keyed-Hash Message Authentication Code (HMAC) as defined in U.S. Federal Information Processing Standards Publication 198.</source>
          <target state="translated">패키지 hmac은 US Federal Information Processing Standards Publication 198에 정의 된 HMAC (Keyed-Hash Message Authentication Code)를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="993a4c7f2aa0bc17bb821bd77a5cdca08736959a" translate="yes" xml:space="preserve">
          <source>Package hmac implements the Keyed-Hash Message Authentication Code (HMAC) as defined in U.S. Federal Information Processing Standards Publication 198. An HMAC is a cryptographic hash that uses a key to sign a message. The receiver verifies the hash by recomputing it using the same key.</source>
          <target state="translated">패키지 hmac는 US Federal Information Processing Standards Publication 198에 정의 된 HMAC (Keyed-Hash Message Authentication Code)를 구현합니다. HMAC는 키를 사용하여 메시지에 서명하는 암호화 해시입니다. 수신자는 동일한 키를 사용하여 해시를 재 계산하여 해시를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="fb848edc1bb28a05f8c5d03e75ae2933d6b8c193" translate="yes" xml:space="preserve">
          <source>Package html</source>
          <target state="translated">패키지 HTML</target>
        </trans-unit>
        <trans-unit id="ee6e4064cc07f14cce23003d26486bcbe481c4c8" translate="yes" xml:space="preserve">
          <source>Package html provides functions for escaping and unescaping HTML text.</source>
          <target state="translated">패키지 html은 HTML 텍스트를 이스케이프 및 이스케이프 해제하는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="93aded6e94d278e605519fd733984fb105ebc8cb" translate="yes" xml:space="preserve">
          <source>Package http</source>
          <target state="translated">패키지 http</target>
        </trans-unit>
        <trans-unit id="565f53df2ba05962d275cc2ddb64a0ff5b302111" translate="yes" xml:space="preserve">
          <source>Package http provides HTTP client and server implementations.</source>
          <target state="translated">패키지 http는 HTTP 클라이언트 및 서버 구현을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="60c2fddc445e71feb989d0582a02f4947d2d457d" translate="yes" xml:space="preserve">
          <source>Package httptest</source>
          <target state="translated">패키지 httptest</target>
        </trans-unit>
        <trans-unit id="aa8780d1e29dd261a3c2246607eef7a72b8bbb1d" translate="yes" xml:space="preserve">
          <source>Package httptest provides utilities for HTTP testing.</source>
          <target state="translated">패키지 httptest는 HTTP 테스트를위한 유틸리티를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0f537d98dbab242ca895592a50db6e67fd272c97" translate="yes" xml:space="preserve">
          <source>Package httptrace</source>
          <target state="translated">패키지 httptrace</target>
        </trans-unit>
        <trans-unit id="813e220dd05ef49b41ec90a3fc88de9ec143f032" translate="yes" xml:space="preserve">
          <source>Package httptrace provides mechanisms to trace the events within HTTP client requests.</source>
          <target state="translated">패키지 httptrace는 HTTP 클라이언트 요청 내에서 이벤트를 추적하는 메커니즘을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9613bdf01a4050ee78eaddb84e11fc64ec270990" translate="yes" xml:space="preserve">
          <source>Package httputil</source>
          <target state="translated">패키지 httputil</target>
        </trans-unit>
        <trans-unit id="76d80a4fa32f388098c8efd95fe330b71ff09bd9" translate="yes" xml:space="preserve">
          <source>Package httputil provides HTTP utility functions, complementing the more common ones in the net/http package.</source>
          <target state="translated">httputil 패키지는 HTTP 유틸리티 기능을 제공하여 net / http 패키지에서보다 일반적인 기능을 보완합니다.</target>
        </trans-unit>
        <trans-unit id="421a469bd8c6ddf7b1af341ec45254a3934f90ed" translate="yes" xml:space="preserve">
          <source>Package image</source>
          <target state="translated">패키지 이미지</target>
        </trans-unit>
        <trans-unit id="4aa8ef8dbcca06a643631802f3d7a141211d42b0" translate="yes" xml:space="preserve">
          <source>Package image implements a basic 2-D image library.</source>
          <target state="translated">패키지 이미지는 기본 2D 이미지 라이브러리를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="2dc8e28a838b11d0551b3a0d88ebb2a4408dab5b" translate="yes" xml:space="preserve">
          <source>Package importer</source>
          <target state="translated">패키지 수입</target>
        </trans-unit>
        <trans-unit id="420252f85bc81d5c6c24a04bcbd00100b4357969" translate="yes" xml:space="preserve">
          <source>Package importer provides access to export data importers.</source>
          <target state="translated">패키지 임포터는 익스포트 데이터 임포터에 대한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="93b91053c7ffebf57a4a0530d2af3609eb527706" translate="yes" xml:space="preserve">
          <source>Package internal</source>
          <target state="translated">내부 패키지</target>
        </trans-unit>
        <trans-unit id="ae4bbcb538c3d4b00aa18c51e1cf94d759fc3060" translate="yes" xml:space="preserve">
          <source>Package internal contains HTTP internals shared by net/http and net/http/httputil.</source>
          <target state="translated">내부 패키지에는 net / http 및 net / http / httputil이 공유하는 HTTP 내부가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9636058f09cfb43189cb98a195789b7f0f244da" translate="yes" xml:space="preserve">
          <source>Package io</source>
          <target state="translated">패키지 io</target>
        </trans-unit>
        <trans-unit id="32668f487482a47ba7dcd798b007284f2070596c" translate="yes" xml:space="preserve">
          <source>Package io provides basic interfaces to I/O primitives. Its primary job is to wrap existing implementations of such primitives, such as those in package os, into shared public interfaces that abstract the functionality, plus some other related primitives.</source>
          <target state="translated">패키지 io는 I / O 프리미티브에 대한 기본 인터페이스를 제공합니다. 주요 작업은 패키지 os에있는 것과 같은 기본 요소의 기존 구현을 기능을 추상화하는 공유 공용 인터페이스와 기타 관련 기본 요소로 랩핑하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="30cb02e7eab55914ca42d64df94b0246f5f91b46" translate="yes" xml:space="preserve">
          <source>Package iotest</source>
          <target state="translated">패키지 iotest</target>
        </trans-unit>
        <trans-unit id="2188f45ca7e2af66c7f08124940a486765a3a1d3" translate="yes" xml:space="preserve">
          <source>Package iotest implements Readers and Writers useful mainly for testing.</source>
          <target state="translated">패키지 iotest는 주로 테스트에 유용한 리더 및 라이터를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="f634706aadf3538974af07a1962d2af1e6651011" translate="yes" xml:space="preserve">
          <source>Package ioutil</source>
          <target state="translated">패키지 ioutil</target>
        </trans-unit>
        <trans-unit id="b7b8fc12300546d76dd9c8e4af13cff6a6ad7548" translate="yes" xml:space="preserve">
          <source>Package ioutil implements some I/O utility functions.</source>
          <target state="translated">패키지 ioutil은 일부 I / O 유틸리티 기능을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="c9fe1f4196a35af3e90e6bd308c01296038ce831" translate="yes" xml:space="preserve">
          <source>Package is the documentation for an entire package.</source>
          <target state="translated">패키지는 전체 패키지에 대한 설명서입니다.</target>
        </trans-unit>
        <trans-unit id="4c1d637bde171a0a8b7330b1b7e32fbe44f587a8" translate="yes" xml:space="preserve">
          <source>Package jpeg</source>
          <target state="translated">jpeg 패키지</target>
        </trans-unit>
        <trans-unit id="be891878e9ef59cdb50913b5ceb2d5944c8960f6" translate="yes" xml:space="preserve">
          <source>Package jpeg implements a JPEG image decoder and encoder.</source>
          <target state="translated">jpeg 패키지는 JPEG 이미지 디코더 및 인코더를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="5232feffa0151247920dae06a9ddd5d55973aeb8" translate="yes" xml:space="preserve">
          <source>Package js</source>
          <target state="translated">패키지 js</target>
        </trans-unit>
        <trans-unit id="8dacbfd07dd845e3d61f3d13d059dcc9341b5c76" translate="yes" xml:space="preserve">
          <source>Package js gives access to the WebAssembly host environment when using the js/wasm architecture.</source>
          <target state="translated">패키지 js는 js / wasm 아키텍처를 사용할 때 WebAssembly 호스트 환경에 대한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="455c332edf437e87334e708fb429cc6e36a5ac4c" translate="yes" xml:space="preserve">
          <source>Package js gives access to the WebAssembly host environment when using the js/wasm architecture. Its API is based on JavaScript semantics.</source>
          <target state="translated">패키지 js는 js / wasm 아키텍처를 사용할 때 WebAssembly 호스트 환경에 대한 액세스를 제공합니다. API는 JavaScript 의미를 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="3857092de217368375e6707dd2db2ce13bf5c6d4" translate="yes" xml:space="preserve">
          <source>Package json</source>
          <target state="translated">패키지 JSON</target>
        </trans-unit>
        <trans-unit id="7ba30886d6ae888888da2bc78eb7b020f20e938d" translate="yes" xml:space="preserve">
          <source>Package json implements encoding and decoding of JSON as defined in RFC 7159.</source>
          <target state="translated">패키지 json은 RFC 7159에 정의 된대로 JSON 인코딩 및 디코딩을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="87906380a06bba048f9b4e8bd43cd1fc7f064c58" translate="yes" xml:space="preserve">
          <source>Package json implements encoding and decoding of JSON as defined in RFC 7159. The mapping between JSON and Go values is described in the documentation for the Marshal and Unmarshal functions.</source>
          <target state="translated">패키지 json은 RFC 7159에 정의 된대로 JSON 인코딩 및 디코딩을 구현합니다. JSON과 Go 값 사이의 맵핑은 마셜 및 비 정렬 함수에 대한 문서에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="89d676dca8ece21fde225b9a51b937ba3f6ad6a6" translate="yes" xml:space="preserve">
          <source>Package jsonrpc</source>
          <target state="translated">jsonrpc 패키지</target>
        </trans-unit>
        <trans-unit id="1c78124a6a4761b03c5384a07f14a75cc4666f38" translate="yes" xml:space="preserve">
          <source>Package jsonrpc implements a JSON-RPC 1.0 ClientCodec and ServerCodec for the rpc package.</source>
          <target state="translated">패키지 jsonrpc는 rpc 패키지 용 JSON-RPC 1.0 ClientCodec 및 ServerCodec를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="09af982985244ee30f92c80e2ab36bc0138d5a7f" translate="yes" xml:space="preserve">
          <source>Package jsonrpc implements a JSON-RPC 1.0 ClientCodec and ServerCodec for the rpc package. For JSON-RPC 2.0 support, see &lt;a href=&quot;https://godoc.org/?q=json-rpc+2.0&quot;&gt;https://godoc.org/?q=json-rpc+2.0&lt;/a&gt;</source>
          <target state="translated">패키지 jsonrpc는 rpc 패키지 용 JSON-RPC 1.0 ClientCodec 및 ServerCodec를 구현합니다. JSON-RPC 2.0 지원에 대해서는 &lt;a href=&quot;https://godoc.org/?q=json-rpc+2.0&quot;&gt;https://godoc.org/?q=json-rpc+2.0을&lt;/a&gt; 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="329023972d7b1c502617105ef48cde0a78cc6333" translate="yes" xml:space="preserve">
          <source>Package list</source>
          <target state="translated">패키지 목록</target>
        </trans-unit>
        <trans-unit id="e56f44c63fe9d6afdfff2ff8bc53c3b472803b64" translate="yes" xml:space="preserve">
          <source>Package list implements a doubly linked list.</source>
          <target state="translated">패키지 목록은 이중 연결 목록을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="39f07fcf96398e5964be22f3a7e100e6e4714031" translate="yes" xml:space="preserve">
          <source>Package log</source>
          <target state="translated">패키지 로그</target>
        </trans-unit>
        <trans-unit id="c01d2cd8db1d9fe6fc80ae05326ed0052a2926ca" translate="yes" xml:space="preserve">
          <source>Package log implements a simple logging package. It defines a type, Logger, with methods for formatting output. It also has a predefined 'standard' Logger accessible through helper functions Print[f|ln], Fatal[f|ln], and Panic[f|ln], which are easier to use than creating a Logger manually. That logger writes to standard error and prints the date and time of each logged message. Every log message is output on a separate line: if the message being printed does not end in a newline, the logger will add one. The Fatal functions call os.Exit(1) after writing the log message. The Panic functions call panic after writing the log message.</source>
          <target state="translated">패키지 로그는 간단한 로깅 패키지를 구현합니다. 출력 형식을 지정하는 메소드를 사용하여 로거 유형을 정의합니다. 또한 헬퍼 기능 Print [f | ln], Fatal [f | ln] 및 Panic [f | ln]을 통해 액세스 할 수있는 사전 정의 된 '표준'로거가 있으며, 이는 로거를 수동으로 작성하는 것보다 사용하기가 더 쉽습니다. 해당 로거는 표준 오류에 기록하고 기록 된 각 메시지의 날짜와 시간을 인쇄합니다. 모든 로그 메시지는 별도의 줄에 출력됩니다. 인쇄중인 메시지가 줄 바꿈으로 끝나지 않으면 로거가 추가합니다. 치명적 함수는 로그 메시지를 작성한 후 os.Exit (1)을 호출합니다. 패닉 함수는 로그 메시지를 작성한 후 패닉을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="2736ca6dade93fff8e3bc211ddd7f28c53ea115b" translate="yes" xml:space="preserve">
          <source>Package lzw</source>
          <target state="translated">패키지 lzw</target>
        </trans-unit>
        <trans-unit id="c4777021f1dd4b6564d1ec41e7d3abc076b6187e" translate="yes" xml:space="preserve">
          <source>Package lzw implements the Lempel-Ziv-Welch compressed data format, described in T. A. Welch, &amp;ldquo;A Technique for High-Performance Data Compression&amp;rdquo;, Computer, 17(6) (June 1984), pp 8-19.</source>
          <target state="translated">패키지 lzw는 TA Welch,&amp;ldquo;고성능 데이터 압축 기술&amp;rdquo;, 컴퓨터, 17 (6) (1984 년 6 월), pp 8-19에 설명 된 Lempel-Ziv-Welch 압축 데이터 형식을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="0e8e7d95f57fe8be09d8faaa0ea86acf1a5fc077" translate="yes" xml:space="preserve">
          <source>Package macho</source>
          <target state="translated">패키지 사나이</target>
        </trans-unit>
        <trans-unit id="92e8c827c8c83c12e1e7b7f121d38fd11d3d6bba" translate="yes" xml:space="preserve">
          <source>Package macho implements access to Mach-O object files.</source>
          <target state="translated">패키지 macho는 Mach-O 객체 파일에 대한 액세스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="6fe93114653da182b59c5cf973ab0a06ef574c15" translate="yes" xml:space="preserve">
          <source>Package mail</source>
          <target state="translated">패키지 메일</target>
        </trans-unit>
        <trans-unit id="6f8e8eb862b5bec7f5c8edcb6c15137f3e2e3084" translate="yes" xml:space="preserve">
          <source>Package mail implements parsing of mail messages.</source>
          <target state="translated">패키지 메일은 메일 메시지의 구문 분석을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="a187699c2d623561de3c74219fd194073fc12ad0" translate="yes" xml:space="preserve">
          <source>Package maphash</source>
          <target state="translated">패키지 맵해시</target>
        </trans-unit>
        <trans-unit id="9648f416f81b26989caa5e33a93eec78f1682daa" translate="yes" xml:space="preserve">
          <source>Package maphash provides hash functions on byte sequences.</source>
          <target state="translated">패키지 맵해시는 바이트 시퀀스에 대한 해시 함수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7ccb1245d8ae5c41c54040e7ae73136e5b36abc1" translate="yes" xml:space="preserve">
          <source>Package maphash provides hash functions on byte sequences. These hash functions are intended to be used to implement hash tables or other data structures that need to map arbitrary strings or byte sequences to a uniform distribution on unsigned 64-bit integers.</source>
          <target state="translated">패키지 맵해시는 바이트 시퀀스에 대한 해시 함수를 제공합니다. 이러한 해시 함수는 임의의 문자열 또는 바이트 시퀀스를 부호없는 64 비트 정수의 균일 한 분포에 매핑해야하는 해시 테이블 또는 기타 데이터 구조를 구현하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="dbbd4bd77faa074039c44407845db0caf5578b1e" translate="yes" xml:space="preserve">
          <source>Package maphash provides hash functions on byte sequences. These hash functions are intended to be used to implement hash tables or other data structures that need to map arbitrary strings or byte sequences to a uniform distribution on unsigned 64-bit integers. Each different instance of a hash table or data structure should use its own Seed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="383fe77ace45b295ad208a38e47b35209b6b894f" translate="yes" xml:space="preserve">
          <source>Package math</source>
          <target state="translated">패키지 수학</target>
        </trans-unit>
        <trans-unit id="b6130e3233ca7fa326fe0f65160f4609452fcc5c" translate="yes" xml:space="preserve">
          <source>Package math provides basic constants and mathematical functions.</source>
          <target state="translated">패키지 수학은 기본 상수와 수학 함수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="91905953ed9b218a4bdf61f1b0e37fe7e7362ece" translate="yes" xml:space="preserve">
          <source>Package md5</source>
          <target state="translated">패키지 md5</target>
        </trans-unit>
        <trans-unit id="91e121cc95845f0e275412a014e511801fa15c71" translate="yes" xml:space="preserve">
          <source>Package md5 implements the MD5 hash algorithm as defined in RFC 1321.</source>
          <target state="translated">패키지 md5는 RFC 1321에 정의 된대로 MD5 해시 알고리즘을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="51897b2c91f40b3cb9e9cd4fd40fe158e6ab22c6" translate="yes" xml:space="preserve">
          <source>Package metrics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="530c83639110b995814f71ccaa8918d25839eefb" translate="yes" xml:space="preserve">
          <source>Package metrics provides a stable interface to access implementation-defined metrics exported by the Go runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c8e50bd95b8d24834893907762db017f6df4ef5" translate="yes" xml:space="preserve">
          <source>Package metrics provides a stable interface to access implementation-defined metrics exported by the Go runtime. This package is similar to existing functions like runtime.ReadMemStats and debug.ReadGCStats, but significantly more general.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e452f6ff2b6f89e6e2fddfc0bc47cc6ea9d38e3" translate="yes" xml:space="preserve">
          <source>Package mime</source>
          <target state="translated">패키지 마임</target>
        </trans-unit>
        <trans-unit id="fb5b7d35717be7356677497c60f984d8bae7427b" translate="yes" xml:space="preserve">
          <source>Package mime implements parts of the MIME spec.</source>
          <target state="translated">패키지 MIME은 MIME 사양의 일부를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="a4afe7ca5ec65b45429532cb822f68e7b1f969e3" translate="yes" xml:space="preserve">
          <source>Package multipart</source>
          <target state="translated">패키지 멀티 파트</target>
        </trans-unit>
        <trans-unit id="0975c17eab222919880be81a12a600e92a6d534f" translate="yes" xml:space="preserve">
          <source>Package multipart implements MIME multipart parsing, as defined in RFC 2046.</source>
          <target state="translated">패키지 멀티 파트는 RFC 2046에 정의 된대로 MIME 멀티 파트 구문 분석을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="30c5d58023a5520f3b07d9da146a5ed1519a8f7c" translate="yes" xml:space="preserve">
          <source>Package net</source>
          <target state="translated">패키지 네트</target>
        </trans-unit>
        <trans-unit id="43d696099850d935770e8f7b1c038c883c0137cb" translate="yes" xml:space="preserve">
          <source>Package net provides a portable interface for network I/O, including TCP/IP, UDP, domain name resolution, and Unix domain sockets.</source>
          <target state="translated">패키지 net은 TCP / IP, UDP, 도메인 이름 확인 및 Unix 도메인 소켓을 포함하여 네트워크 I / O를위한 휴대용 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7ab70b00aa79e1b268257a5e997962ee78d287d2" translate="yes" xml:space="preserve">
          <source>Package os</source>
          <target state="translated">패키지 OS</target>
        </trans-unit>
        <trans-unit id="c733a9fd7f2534638a02811f5ea17d1a129c8b5c" translate="yes" xml:space="preserve">
          <source>Package os provides a platform-independent interface to operating system functionality. The design is Unix-like, although the error handling is Go-like; failing calls return values of type error rather than error numbers. Often, more information is available within the error. For example, if a call that takes a file name fails, such as Open or Stat, the error will include the failing file name when printed and will be of type *PathError, which may be unpacked for more information.</source>
          <target state="translated">패키지 os는 운영 체제 기능에 플랫폼 독립적 인 인터페이스를 제공합니다. 오류 처리는 Go와 비슷하지만 디자인은 Unix와 유사합니다. 실패한 호출은 오류 번호가 아닌 오류 유형의 값을 반환합니다. 종종 오류 내에서 추가 정보를 사용할 수 있습니다. 예를 들어, 파일 이름을 사용하는 호출 (예 : Open 또는 Stat)에 실패하면 오류가 인쇄 될 때 실패한 파일 이름이 포함되며 * PathError 유형이며 자세한 정보를 위해 압축이 풀릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04c8aee5e23a788ea2bcb38b074f985eac2786a8" translate="yes" xml:space="preserve">
          <source>Package palette</source>
          <target state="translated">패키지 팔레트</target>
        </trans-unit>
        <trans-unit id="cf2f1921f30936ace0261b5025892d44ffab8eb3" translate="yes" xml:space="preserve">
          <source>Package palette provides standard color palettes.</source>
          <target state="translated">패키지 팔레트는 표준 색상 팔레트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0242c171ef1c568c8ae1ca39756ba02bb57c4a9d" translate="yes" xml:space="preserve">
          <source>Package parse</source>
          <target state="translated">패키지 파싱</target>
        </trans-unit>
        <trans-unit id="417bd6bafe4778a0805898be461125c5d876274b" translate="yes" xml:space="preserve">
          <source>Package parse builds parse trees for templates as defined by text/template and html/template.</source>
          <target state="translated">패키지 구문 분석은 text / template 및 html / template에 의해 정의 된 템플리트에 대한 구문 분석 트리를 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="9c526058ffd19e7a03ef67d38acb87f2af58bf19" translate="yes" xml:space="preserve">
          <source>Package parse builds parse trees for templates as defined by text/template and html/template. Clients should use those packages to construct templates rather than this one, which provides shared internal data structures not intended for general use.</source>
          <target state="translated">패키지 구문 분석은 text / template 및 html / template에 의해 정의 된 템플리트에 대한 구문 분석 트리를 빌드합니다. 고객은이 패키지 대신이 패키지를 사용하여 템플릿을 구성해야합니다.이 패키지는 일반적인 용도가 아닌 공유 내부 데이터 구조를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="66cc9b613eb8bc3269dbf5d021ee51da1590e18b" translate="yes" xml:space="preserve">
          <source>Package parser</source>
          <target state="translated">패키지 파서</target>
        </trans-unit>
        <trans-unit id="6de3fe85bffa2dfbd3030929ab437e9f7594c3fc" translate="yes" xml:space="preserve">
          <source>Package parser implements a parser for Go source files. Input may be provided in a variety of forms (see the various Parse* functions); the output is an abstract syntax tree (AST) representing the Go source. The parser is invoked through one of the Parse* functions.</source>
          <target state="translated">패키지 파서는 Go 소스 파일에 대한 파서를 구현합니다. 입력은 다양한 형태로 제공 될 수 있습니다 (다양한 구문 분석 * 기능 참조). 출력은 Go 소스를 나타내는 추상 구문 트리 (AST)입니다. 파서는 Parse * 함수 중 하나를 통해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="3373a46035bdd1245ec67bf0a2c65e10dfd0f4ad" translate="yes" xml:space="preserve">
          <source>Package path</source>
          <target state="translated">패키지 경로</target>
        </trans-unit>
        <trans-unit id="db836e38d040774081537fe657365110292aec91" translate="yes" xml:space="preserve">
          <source>Package path implements utility routines for manipulating slash-separated paths.</source>
          <target state="translated">패키지 경로는 슬래시로 구분 된 경로를 조작하기위한 유틸리티 루틴을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="9d24a47a68584686a4df522a7f5e3f005ddc259f" translate="yes" xml:space="preserve">
          <source>Package pe</source>
          <target state="translated">패키지 PE</target>
        </trans-unit>
        <trans-unit id="ce301de224be1f8c3d1c1c5dfcb12d983b03bd77" translate="yes" xml:space="preserve">
          <source>Package pe implements access to PE (Microsoft Windows Portable Executable) files.</source>
          <target state="translated">패키지 pe는 PE (Microsoft Windows Portable Executable) 파일에 대한 액세스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="e152e56cf87bc67e469bb5da6106c6e936b14368" translate="yes" xml:space="preserve">
          <source>Package pem</source>
          <target state="translated">패키지 pem</target>
        </trans-unit>
        <trans-unit id="f41f7d23d767dfe9afe9b6e7dfc54ee5c677365e" translate="yes" xml:space="preserve">
          <source>Package pem implements the PEM data encoding, which originated in Privacy Enhanced Mail.</source>
          <target state="translated">패키지 pem은 Privacy Enhanced Mail에서 시작된 PEM 데이터 인코딩을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="0d4c900b99f74302177b2bea20055842f0e52c09" translate="yes" xml:space="preserve">
          <source>Package pem implements the PEM data encoding, which originated in Privacy Enhanced Mail. The most common use of PEM encoding today is in TLS keys and certificates. See RFC 1421.</source>
          <target state="translated">패키지 pem은 Privacy Enhanced Mail에서 시작된 PEM 데이터 인코딩을 구현합니다. 오늘날 PEM 인코딩의 가장 일반적인 용도는 TLS 키 및 인증서입니다. RFC 1421을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="38d910b9de0ef4ae8b19f042eb74647af6042913" translate="yes" xml:space="preserve">
          <source>Package pkix</source>
          <target state="translated">패키지 pkix</target>
        </trans-unit>
        <trans-unit id="dc33e58126376b6213633925214424947582c3a3" translate="yes" xml:space="preserve">
          <source>Package pkix contains shared, low level structures used for ASN.1 parsing and serialization of X.509 certificates, CRL and OCSP.</source>
          <target state="translated">패키지 pkix에는 X.509 인증서, CRL 및 OCSP의 ASN.1 구문 분석 및 직렬화에 사용되는 공유 하위 레벨 구조가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="67b226d60325490b566c70691138cd1c6d21b193" translate="yes" xml:space="preserve">
          <source>Package plan9obj</source>
          <target state="translated">패키지 계획</target>
        </trans-unit>
        <trans-unit id="4665855b57b9b8af3bee702ebd462244986f00bf" translate="yes" xml:space="preserve">
          <source>Package plan9obj implements access to Plan 9 a.out object files.</source>
          <target state="translated">패키지 plan9obj는 Plan 9 a.out 오브젝트 파일에 대한 액세스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="3cd1d7122e8b0e42817d81ce5dc7226d253ae194" translate="yes" xml:space="preserve">
          <source>Package plugin</source>
          <target state="translated">패키지 플러그인</target>
        </trans-unit>
        <trans-unit id="723391b754af075d19bf19a6d72b4aca8b612706" translate="yes" xml:space="preserve">
          <source>Package plugin implements loading and symbol resolution of Go plugins.</source>
          <target state="translated">패키지 플러그인은 Go 플러그인의 로딩 및 심볼 분석을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="18f40a30c66d89382a5e8d5c5fa97aad2d850e59" translate="yes" xml:space="preserve">
          <source>Package png</source>
          <target state="translated">패키지 png</target>
        </trans-unit>
        <trans-unit id="7d75e3a56a64d92564c27a07179bd65f150fd42a" translate="yes" xml:space="preserve">
          <source>Package png implements a PNG image decoder and encoder.</source>
          <target state="translated">패키지 png는 PNG 이미지 디코더 및 인코더를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="bbb9e684e1674ad5ea70ff8d94149cfba70c0322" translate="yes" xml:space="preserve">
          <source>Package pprof</source>
          <target state="translated">패키지 pprof</target>
        </trans-unit>
        <trans-unit id="6b696f2047997085f203f8e5ea4ab96764716e57" translate="yes" xml:space="preserve">
          <source>Package pprof serves via its HTTP server runtime profiling data in the format expected by the pprof visualization tool.</source>
          <target state="translated">pprof 패키지는 HTTP 서버 런타임 프로파일 링 데이터를 통해 pprof 시각화 도구에 필요한 형식으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="f35eefcb5de07eee157ab4d725a5a9c718348ce1" translate="yes" xml:space="preserve">
          <source>Package pprof writes runtime profiling data in the format expected by the pprof visualization tool.</source>
          <target state="translated">pprof 패키지는 pprof 시각화 도구가 예상하는 형식으로 런타임 프로파일 링 데이터를 씁니다.</target>
        </trans-unit>
        <trans-unit id="bd0a361bc1df19412b2288989fa693bf033d1e94" translate="yes" xml:space="preserve">
          <source>Package printer</source>
          <target state="translated">패키지 프린터</target>
        </trans-unit>
        <trans-unit id="7508f680f0bd7ace72d4e37d8bf4124dd8618769" translate="yes" xml:space="preserve">
          <source>Package printer implements printing of AST nodes.</source>
          <target state="translated">패키지 프린터는 AST 노드의 인쇄를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="5a2f6f777ac49a0a6e1a6283c8172aaf45ada261" translate="yes" xml:space="preserve">
          <source>Package quick</source>
          <target state="translated">빠른 패키지</target>
        </trans-unit>
        <trans-unit id="b11b2a9f0787ff668038fd60730c27709091efd5" translate="yes" xml:space="preserve">
          <source>Package quick implements utility functions to help with black box testing.</source>
          <target state="translated">패키지 빠른 기능은 블랙 박스 테스트에 도움이되는 유틸리티 기능을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="5a939d420f6017187bd02b98ed377adb9120365c" translate="yes" xml:space="preserve">
          <source>Package quotedprintable</source>
          <target state="translated">인용 가능한 패키지</target>
        </trans-unit>
        <trans-unit id="195c159d436820f6a7d39ac4579d1905b0c74821" translate="yes" xml:space="preserve">
          <source>Package quotedprintable implements quoted-printable encoding as specified by RFC 2045.</source>
          <target state="translated">패키지 인용 인쇄 가능은 RFC 2045에 의해 지정된 인용 인쇄 가능 인코딩을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="d7dd09c477f4383baa2235b2b5f02beab77e4389" translate="yes" xml:space="preserve">
          <source>Package race</source>
          <target state="translated">패키지 레이스</target>
        </trans-unit>
        <trans-unit id="a5c1c2be3bea40e10437334b0813837bf205008a" translate="yes" xml:space="preserve">
          <source>Package race implements data race detection logic.</source>
          <target state="translated">패키지 레이스는 데이터 레이스 감지 로직을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="96ff3f6524e366a1f85999a9889633b5758b7e5b" translate="yes" xml:space="preserve">
          <source>Package race implements data race detection logic. No public interface is provided. For details about the race detector see &lt;a href=&quot;https://golang.org/doc/articles/race_detector.html&quot;&gt;https://golang.org/doc/articles/race_detector.html&lt;/a&gt;</source>
          <target state="translated">패키지 레이스는 데이터 레이스 감지 로직을 구현합니다. 공개 인터페이스가 제공되지 않습니다. 레이스 탐지기에 대한 자세한 내용은 &lt;a href=&quot;https://golang.org/doc/articles/race_detector.html&quot;&gt;https://golang.org/doc/articles/race_detector.html을&lt;/a&gt; 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="83c163892e45f479d6597f9c22d2df740381ff44" translate="yes" xml:space="preserve">
          <source>Package rand</source>
          <target state="translated">패키지 랜드</target>
        </trans-unit>
        <trans-unit id="cc752fea52bb25978322b7eaf4569384e9741709" translate="yes" xml:space="preserve">
          <source>Package rand implements a cryptographically secure random number generator.</source>
          <target state="translated">패키지 랜드는 암호로 안전한 난수 생성기를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="b3b18e540dfae96ee4bfa44eff2fe6364db2a649" translate="yes" xml:space="preserve">
          <source>Package rand implements pseudo-random number generators.</source>
          <target state="translated">패키지 랜드는 의사 난수 생성기를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="d31a1689b285cdf109ef7adc6ecc82f9e08e66cb" translate="yes" xml:space="preserve">
          <source>Package rc4</source>
          <target state="translated">패키지 rc4</target>
        </trans-unit>
        <trans-unit id="9d9070b30c94fbd8ece92c972cff45482e84ea73" translate="yes" xml:space="preserve">
          <source>Package rc4 implements RC4 encryption, as defined in Bruce Schneier's Applied Cryptography.</source>
          <target state="translated">패키지 rc4는 Bruce Schneier의 Applied Cryptography에 정의 된대로 RC4 암호화를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="16eeac7c41dd94aba1ce95ebc38efce516d7ede5" translate="yes" xml:space="preserve">
          <source>Package reflect</source>
          <target state="translated">패키지 반영</target>
        </trans-unit>
        <trans-unit id="ea99463dc27a541bcea8f216ce8b537d53c786f4" translate="yes" xml:space="preserve">
          <source>Package reflect implements run-time reflection, allowing a program to manipulate objects with arbitrary types. The typical use is to take a value with static type interface{} and extract its dynamic type information by calling TypeOf, which returns a Type.</source>
          <target state="translated">패키지 반영은 런타임 반영을 구현하여 프로그램이 임의 유형의 객체를 조작 할 수 있도록합니다. 일반적으로 정적 유형 인터페이스 {}로 값을 가져 와서 TypeOf를 호출하여 동적 유형 정보를 추출하여 Type을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f6906a6b73a6d72eeebe325c95a7fd2b66657106" translate="yes" xml:space="preserve">
          <source>Package reflect's Value methods named Pointer and UnsafeAddr return type uintptr instead of unsafe.Pointer to keep callers from changing the result to an arbitrary type without first importing &quot;unsafe&quot;. However, this means that the result is fragile and must be converted to Pointer immediately after making the call, in the same expression:</source>
          <target state="translated">Package reflect의 Pointer 및 UnsafeAddr라는 Value 메소드는 unsafe 대신 uintptr 유형을 반환합니다. 그러나 이것은 결과가 깨지기 쉬우 며 같은 식으로 호출 한 직후에 포인터로 변환되어야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="296c31de17cebe68d7ff50dd54df6ff57cb7cdbd" translate="yes" xml:space="preserve">
          <source>Package regexp</source>
          <target state="translated">정규식 패키지</target>
        </trans-unit>
        <trans-unit id="8db88ff2fae80db5efc49abe986d69219c995b2a" translate="yes" xml:space="preserve">
          <source>Package regexp implements regular expression search.</source>
          <target state="translated">패키지 정규 표현식은 정규 표현식 검색을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="8f3fe52956764f5ab5a7617348d70f67990e27be" translate="yes" xml:space="preserve">
          <source>Package ring</source>
          <target state="translated">패키지 링</target>
        </trans-unit>
        <trans-unit id="24781dde0d3396b2f7a5d8de96bf17e6c6511838" translate="yes" xml:space="preserve">
          <source>Package ring implements operations on circular lists.</source>
          <target state="translated">패키지 링은 순환 목록에 대한 작업을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="4ac8d28b6f5f90e5f57c49bd02cae6ff1cc3103e" translate="yes" xml:space="preserve">
          <source>Package rpc</source>
          <target state="translated">패키지 RPC</target>
        </trans-unit>
        <trans-unit id="29c7a976ba21e5e3d539285fcef131a0900d481a" translate="yes" xml:space="preserve">
          <source>Package rpc provides access to the exported methods of an object across a network or other I/O connection.</source>
          <target state="translated">패키지 rpc는 네트워크 또는 다른 I / O 연결을 통해 객체의 내 보낸 메소드에 대한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="89036cae903feb95d9bf22ecb370849d3856aa14" translate="yes" xml:space="preserve">
          <source>Package rpc provides access to the exported methods of an object across a network or other I/O connection. A server registers an object, making it visible as a service with the name of the type of the object. After registration, exported methods of the object will be accessible remotely. A server may register multiple objects (services) of different types but it is an error to register multiple objects of the same type.</source>
          <target state="translated">패키지 rpc는 네트워크 또는 다른 I / O 연결을 통해 객체의 내 보낸 메소드에 대한 액세스를 제공합니다. 서버는 객체를 등록하여 객체 유형의 이름을 가진 서비스로 표시합니다. 등록 후에는 객체의 내 보낸 메소드에 원격으로 액세스 할 수 있습니다. 서버가 다른 유형의 여러 객체 (서비스)를 등록 할 수 있지만 동일한 유형의 여러 객체를 등록하는 것은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="3dd9b23cfd1948413bbf148dd0474b59ad766e9f" translate="yes" xml:space="preserve">
          <source>Package rsa</source>
          <target state="translated">패키지 RSA</target>
        </trans-unit>
        <trans-unit id="e8ee0119074c7588f25b970331b4e7b4a2623cbf" translate="yes" xml:space="preserve">
          <source>Package rsa implements RSA encryption as specified in PKCS #1 and RFC 8017.</source>
          <target state="translated">패키지 rsa는 PKCS # 1 및 RFC 8017에 지정된대로 RSA 암호화를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="9ba02848b97a1b268666b78b127c28a6770b462d" translate="yes" xml:space="preserve">
          <source>Package rsa implements RSA encryption as specified in PKCS#1.</source>
          <target state="translated">패키지 rsa는 PKCS # 1에 지정된 RSA 암호화를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="4ebd8f5b99b65c7601e3f5f2bad88bd7ec2de054" translate="yes" xml:space="preserve">
          <source>Package runtime</source>
          <target state="translated">패키지 런타임</target>
        </trans-unit>
        <trans-unit id="469b95dee031c267f910a82eae21961d70838630" translate="yes" xml:space="preserve">
          <source>Package runtime contains operations that interact with Go's runtime system, such as functions to control goroutines. It also includes the low-level type information used by the reflect package; see reflect's documentation for the programmable interface to the run-time type system.</source>
          <target state="translated">패키지 런타임에는 고 루틴을 제어하는 ​​기능과 같이 Go의 런타임 시스템과 상호 작용하는 작업이 포함되어 있습니다. 또한 reflect 패키지가 사용하는 하위 레벨 유형 정보도 포함합니다. 런타임 유형 시스템에 대한 프로그래밍 가능 인터페이스에 대한 reflect 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="82776b2ed593a3609079c4ab84f51091ff8daaf8" translate="yes" xml:space="preserve">
          <source>Package scanner</source>
          <target state="translated">패키지 스캐너</target>
        </trans-unit>
        <trans-unit id="37829fd57a47182e751d5d54158a385e61ab833d" translate="yes" xml:space="preserve">
          <source>Package scanner implements a scanner for Go source text. It takes a []byte as source which can then be tokenized through repeated calls to the Scan method.</source>
          <target state="translated">패키지 스캐너는 Go 소스 텍스트 용 스캐너를 구현합니다. [] 바이트를 소스로 사용하여 Scan 메소드에 대한 반복 호출을 통해 토큰화할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cff89fb02b03b32b0811fa214e2e7a1126ee135b" translate="yes" xml:space="preserve">
          <source>Package scanner provides a scanner and tokenizer for UTF-8-encoded text. It takes an io.Reader providing the source, which then can be tokenized through repeated calls to the Scan function. For compatibility with existing tools, the NUL character is not allowed. If the first character in the source is a UTF-8 encoded byte order mark (BOM), it is discarded.</source>
          <target state="translated">패키지 스캐너는 UTF-8로 인코딩 된 텍스트를위한 스캐너 및 토크 나이저를 제공합니다. 소스를 제공하는 io.Reader가 필요하며 스캔 기능에 대한 반복 호출을 통해 토큰화할 수 있습니다. 기존 도구와의 호환성을 위해 NUL 문자는 허용되지 않습니다. 소스의 첫 번째 문자가 UTF-8 인코딩 된 바이트 순서 표시 (BOM) 인 경우 버려집니다.</target>
        </trans-unit>
        <trans-unit id="6e0759392e3584cd8a2a3d2a6c4931673b5e35b2" translate="yes" xml:space="preserve">
          <source>Package sha1</source>
          <target state="translated">패키지 sha1</target>
        </trans-unit>
        <trans-unit id="db1a6662e07e0565a4b3c55f6347a0baeacc49fb" translate="yes" xml:space="preserve">
          <source>Package sha1 implements the SHA-1 hash algorithm as defined in RFC 3174.</source>
          <target state="translated">패키지 sha1은 RFC 3174에 정의 된 SHA-1 해시 알고리즘을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="f6ad23ee3ab99920af8ac5cfc82080a0e1b3b09f" translate="yes" xml:space="preserve">
          <source>Package sha256</source>
          <target state="translated">패키지 sha256</target>
        </trans-unit>
        <trans-unit id="c9317efee8c5fefb81226a055344cf996daf2874" translate="yes" xml:space="preserve">
          <source>Package sha256 implements the SHA224 and SHA256 hash algorithms as defined in FIPS 180-4.</source>
          <target state="translated">sha256 패키지는 FIPS 180-4에 정의 된 SHA224 및 SHA256 해시 알고리즘을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="4e4623212d4095d72a62997c9796888b7d1b95c9" translate="yes" xml:space="preserve">
          <source>Package sha512</source>
          <target state="translated">패키지 sha512</target>
        </trans-unit>
        <trans-unit id="65d83f8c0979c324f75579653a6e20dcc05fc8a1" translate="yes" xml:space="preserve">
          <source>Package sha512 implements the SHA-384, SHA-512, SHA-512/224, and SHA-512/256 hash algorithms as defined in FIPS 180-4.</source>
          <target state="translated">패키지 sha512는 FIPS 180-4에 정의 된 SHA-384, SHA-512, SHA-512 / 224 및 SHA-512 / 256 해시 알고리즘을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="80e54559e475073190cfed119c9847e346d01634" translate="yes" xml:space="preserve">
          <source>Package signal</source>
          <target state="translated">패키지 신호</target>
        </trans-unit>
        <trans-unit id="59f2e9e157e5e2c56d4bb35edf223ce0a7c75cdf" translate="yes" xml:space="preserve">
          <source>Package signal implements access to incoming signals.</source>
          <target state="translated">패키지 신호는 들어오는 신호에 대한 액세스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="0e49eafb9bb1f34b1ff3d2c9a1f4a0ec52ecdba3" translate="yes" xml:space="preserve">
          <source>Package signal will not block sending to c: the caller must ensure that c has sufficient buffer space to keep up with the expected signal rate. For a channel used for notification of just one signal value, a buffer of size 1 is sufficient.</source>
          <target state="translated">패키지 신호는 c 로의 전송을 차단하지 않습니다. 호출자는 c가 예상 신호 속도를 유지할 수있는 충분한 버퍼 공간을 확보해야합니다. 단 하나의 신호 값을 알리는 데 사용되는 채널의 경우 크기 1의 버퍼로 충분합니다.</target>
        </trans-unit>
        <trans-unit id="fc75b3c455c2cde737da3fcce8266dd282fe7922" translate="yes" xml:space="preserve">
          <source>Package smtp</source>
          <target state="translated">smtp 패키지</target>
        </trans-unit>
        <trans-unit id="b50b30b8ea306091fbb446aaa4ed61109401fff0" translate="yes" xml:space="preserve">
          <source>Package smtp implements the Simple Mail Transfer Protocol as defined in RFC 5321.</source>
          <target state="translated">smtp 패키지는 RFC 5321에 정의 된대로 단순 메일 전송 프로토콜을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="1fe6e79dac787b0d56b7abea30c16ebab918d57e" translate="yes" xml:space="preserve">
          <source>Package smtp implements the Simple Mail Transfer Protocol as defined in RFC 5321. It also implements the following extensions:</source>
          <target state="translated">smtp 패키지는 RFC 5321에 정의 된대로 단순 메일 전송 프로토콜을 구현합니다. 또한 다음 확장을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="71f7fab9acf61b6109216266ded759b751fdf3ba" translate="yes" xml:space="preserve">
          <source>Package sort</source>
          <target state="translated">패키지 정렬</target>
        </trans-unit>
        <trans-unit id="0962324992fa79918c2dd6cf47c8b372c511e5ff" translate="yes" xml:space="preserve">
          <source>Package sort provides primitives for sorting slices and user-defined collections.</source>
          <target state="translated">패키지 정렬은 슬라이스 및 사용자 정의 컬렉션을 정렬하기위한 프리미티브를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9bd1b867b8811e4a5059325426012d1ac3fbe070" translate="yes" xml:space="preserve">
          <source>Package sql</source>
          <target state="translated">패키지 SQL</target>
        </trans-unit>
        <trans-unit id="9e262166973b441cf1a6b45fe03044818008c94a" translate="yes" xml:space="preserve">
          <source>Package sql provides a generic interface around SQL (or SQL-like) databases.</source>
          <target state="translated">패키지 sql은 SQL (또는 SQL과 같은) 데이터베이스에 대한 일반적인 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8b57c7d54ee7ea7e0a45d8c13b8a29358c7a1a59" translate="yes" xml:space="preserve">
          <source>Package strconv</source>
          <target state="translated">패키지 strconv</target>
        </trans-unit>
        <trans-unit id="3c44c13248967ffe512eec5e12e0ac2d83aaabcb" translate="yes" xml:space="preserve">
          <source>Package strconv implements conversions to and from string representations of basic data types.</source>
          <target state="translated">패키지 strconv는 기본 데이터 유형의 문자열 표현과의 변환을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="28ec3487bac9bff1cd40dd5bfdaac3e5f0f7e66b" translate="yes" xml:space="preserve">
          <source>Package strings</source>
          <target state="translated">패키지 문자열</target>
        </trans-unit>
        <trans-unit id="30f2d5d3c8bcd3201c529ed7194820953f047942" translate="yes" xml:space="preserve">
          <source>Package strings implements simple functions to manipulate UTF-8 encoded strings.</source>
          <target state="translated">패키지 문자열은 UTF-8로 인코딩 된 문자열을 조작하는 간단한 기능을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="5f3a2aafe35539648afeeb350719fa852f88f7f2" translate="yes" xml:space="preserve">
          <source>Package subtle</source>
          <target state="translated">미묘한 패키지</target>
        </trans-unit>
        <trans-unit id="af533feda0fe1c8229caece2fdfd190444424ea5" translate="yes" xml:space="preserve">
          <source>Package subtle implements functions that are often useful in cryptographic code but require careful thought to use correctly.</source>
          <target state="translated">미묘한 패키지는 종종 암호화 코드에 유용하지만 올바르게 사용하려면 신중한 생각이 필요한 기능을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="39d17df25323190f4cc53202e597d56f35dfee6b" translate="yes" xml:space="preserve">
          <source>Package suffixarray</source>
          <target state="translated">패키지 접미사</target>
        </trans-unit>
        <trans-unit id="7980bb666cc38cba6c4aaf92417db33415ccfaa1" translate="yes" xml:space="preserve">
          <source>Package suffixarray implements substring search in logarithmic time using an in-memory suffix array.</source>
          <target state="translated">패키지 접미어는 메모리 내 접미사 배열을 사용하여 로그 시간에 하위 문자열 검색을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="346a1d63b09ad3c0b05c14691bf67091b87cabe5" translate="yes" xml:space="preserve">
          <source>Package sync</source>
          <target state="translated">패키지 동기화</target>
        </trans-unit>
        <trans-unit id="aea6d23bbc4ed584bf5042d03479be247cbf1087" translate="yes" xml:space="preserve">
          <source>Package sync provides basic synchronization primitives such as mutual exclusion locks. Other than the Once and WaitGroup types, most are intended for use by low-level library routines. Higher-level synchronization is better done via channels and communication.</source>
          <target state="translated">패키지 동기화는 상호 배제 잠금과 같은 기본 동기화 기본 요소를 제공합니다. Once 및 WaitGroup 유형 이외의 대부분은 하위 수준 라이브러리 루틴에서 사용하기위한 것입니다. 높은 수준의 동기화는 채널과 통신을 통해 더 잘 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="fe4c913bf7c7c5e8773000f095ebe490accad3a2" translate="yes" xml:space="preserve">
          <source>Package syntax</source>
          <target state="translated">패키지 구문</target>
        </trans-unit>
        <trans-unit id="a713eae229dc7c92d21e8a224e10ceffb09512c2" translate="yes" xml:space="preserve">
          <source>Package syntax parses regular expressions into parse trees and compiles parse trees into programs.</source>
          <target state="translated">패키지 구문은 정규식을 구문 분석 트리로 구문 분석하고 구문 분석 트리를 프로그램으로 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="a70c7eb9cc685b98a0a5536eddbf6dbc0cba4ac8" translate="yes" xml:space="preserve">
          <source>Package syntax parses regular expressions into parse trees and compiles parse trees into programs. Most clients of regular expressions will use the facilities of package regexp (such as Compile and Match) instead of this package.</source>
          <target state="translated">패키지 구문은 정규식을 구문 분석 트리로 구문 분석하고 구문 분석 트리를 프로그램으로 컴파일합니다. 대부분의 정규 표현식 클라이언트는이 패키지 대신 정규식 패키지 (예 : 컴파일 및 일치) 기능을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="11e76797e8363318c05ceb15b2d2b47e39353883" translate="yes" xml:space="preserve">
          <source>Package sys</source>
          <target state="translated">패키지 시스템</target>
        </trans-unit>
        <trans-unit id="d21a124cf49a1b492319130693efdb9b8a34c61d" translate="yes" xml:space="preserve">
          <source>Package syscall</source>
          <target state="translated">패키지 시스템 콜</target>
        </trans-unit>
        <trans-unit id="0f53f1418ab827df34bf754bfae7d8d0c010c7cc" translate="yes" xml:space="preserve">
          <source>Package syscall contains an interface to the low-level operating system primitives. The details vary depending on the underlying system, and by default, godoc will display the syscall documentation for the current system. If you want godoc to display syscall documentation for another system, set $GOOS and $GOARCH to the desired system. For example, if you want to view documentation for freebsd/arm on linux/amd64, set $GOOS to freebsd and $GOARCH to arm. The primary use of syscall is inside other packages that provide a more portable interface to the system, such as &quot;os&quot;, &quot;time&quot; and &quot;net&quot;. Use those packages rather than this one if you can. For details of the functions and data types in this package consult the manuals for the appropriate operating system. These calls return err == nil to indicate success; otherwise err is an operating system error describing the failure. On most systems, that error has type syscall.Errno.</source>
          <target state="translated">패키지 syscall에는 저수준 운영 체제 프리미티브에 대한 인터페이스가 포함되어 있습니다. 세부 사항은 기본 시스템에 따라 다르며 기본적으로 godoc은 현재 시스템에 대한 syscall 문서를 표시합니다. godoc이 다른 시스템에 대한 syscall 문서를 표시하도록하려면 $ GOOS 및 $ GOARCH를 원하는 시스템으로 설정하십시오. 예를 들어 linux / amd64에서 freebsd / arm에 대한 설명서를 보려면 $ GOOS를 freebsd로, $ GOARCH를 arm으로 설정하십시오. syscall의 주요 용도는 &quot;os&quot;, &quot;time&quot;및 &quot;net&quot;과 같이 시스템에보다 이식 가능한 인터페이스를 제공하는 다른 패키지에서 사용됩니다. 가능하면이 패키지 대신 해당 패키지를 사용하십시오. 이 패키지의 기능 및 데이터 유형에 대한 자세한 내용은 해당 운영 체제의 설명서를 참조하십시오. 이 호출은 성공을 표시하기 위해 err == nil을 리턴합니다.그렇지 않으면 err는 실패를 설명하는 운영 체제 오류입니다. 대부분의 시스템에서이 오류는 syscall.Errno 유형입니다.</target>
        </trans-unit>
        <trans-unit id="f90ba2ae4e2d681143f3d41fb43a2f79b7c3197e" translate="yes" xml:space="preserve">
          <source>Package syslog</source>
          <target state="translated">패키지 syslog</target>
        </trans-unit>
        <trans-unit id="396038b0a959cfae15beae20a0f48bc80b80cf43" translate="yes" xml:space="preserve">
          <source>Package syslog provides a simple interface to the system log service.</source>
          <target state="translated">패키지 syslog는 시스템 로그 서비스에 대한 간단한 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d1f55ec1734bdf22b075380ad35ee09a577ec002" translate="yes" xml:space="preserve">
          <source>Package syslog provides a simple interface to the system log service. It can send messages to the syslog daemon using UNIX domain sockets, UDP or TCP.</source>
          <target state="translated">패키지 syslog는 시스템 로그 서비스에 대한 간단한 인터페이스를 제공합니다. UNIX 도메인 소켓, UDP 또는 TCP를 사용하여 syslog 디먼에 메시지를 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="007cb2c9dc06f8f699c331e9716d599817f048b5" translate="yes" xml:space="preserve">
          <source>Package tabwriter</source>
          <target state="translated">패키지 타자기</target>
        </trans-unit>
        <trans-unit id="f7841eb33056b73d4a3597207ce6dc7e384c846d" translate="yes" xml:space="preserve">
          <source>Package tabwriter implements a write filter (tabwriter.Writer) that translates tabbed columns in input into properly aligned text.</source>
          <target state="translated">패키지 탭 작성기는 입력의 탭 열을 올바르게 정렬 된 텍스트로 변환하는 쓰기 필터 (tabwriter.Writer)를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="bec4ed72f4fd10dfa620d0e5687ebc626dc193a1" translate="yes" xml:space="preserve">
          <source>Package tar</source>
          <target state="translated">패키지 타르</target>
        </trans-unit>
        <trans-unit id="b3d0f0f238631cf9655cf5816e9f94b6db370098" translate="yes" xml:space="preserve">
          <source>Package tar implements access to tar archives.</source>
          <target state="translated">패키지 tar는 tar 아카이브에 대한 액세스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="7ac2ec5b1841ff39f85ad1d4687cc3abfa906a39" translate="yes" xml:space="preserve">
          <source>Package template</source>
          <target state="translated">패키지 템플릿</target>
        </trans-unit>
        <trans-unit id="aba87a8492b37ccf916bdea97ed3b469ce8125f0" translate="yes" xml:space="preserve">
          <source>Package template (html/template) implements data-driven templates for generating HTML output safe against code injection.</source>
          <target state="translated">패키지 템플릿 (html / template)은 코드 삽입에 대해 안전한 HTML 출력을 생성하기 위해 데이터 기반 템플릿을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="9776451c8a221b1dfd29d6efbaff6d2de3fbf0aa" translate="yes" xml:space="preserve">
          <source>Package template (html/template) implements data-driven templates for generating HTML output safe against code injection. It provides the same interface as package text/template and should be used instead of text/template whenever the output is HTML.</source>
          <target state="translated">패키지 템플릿 (html / template)은 코드 삽입에 대해 안전한 HTML 출력을 생성하기 위해 데이터 기반 템플릿을 구현합니다. 패키지 텍스트 / 템플릿과 동일한 인터페이스를 제공하며 출력이 HTML 일 때마다 텍스트 / 템플릿 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="12fb252e998414c68ff5f9998dbcdff046a0fe8f" translate="yes" xml:space="preserve">
          <source>Package template implements data-driven templates for generating textual output.</source>
          <target state="translated">패키지 템플릿은 텍스트 출력을 생성하기위한 데이터 기반 템플릿을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="8f2f8d22daa6bdd34d84049e31c95592348695b8" translate="yes" xml:space="preserve">
          <source>Package testing</source>
          <target state="translated">패키지 테스트</target>
        </trans-unit>
        <trans-unit id="4387ddd6a0700cb89e62a2fdffa74807135c1d64" translate="yes" xml:space="preserve">
          <source>Package testing provides support for automated testing of Go packages. It is intended to be used in concert with the &quot;go test&quot; command, which automates execution of any function of the form</source>
          <target state="translated">패키지 테스트는 Go 패키지의 자동화 된 테스트를 지원합니다. 양식의 모든 기능 실행을 자동화하는 &quot;go test&quot;명령과 함께 사용하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="9c91ae9ffc226daabd50a55612fc0b4ce9280216" translate="yes" xml:space="preserve">
          <source>Package testing provides support for automated testing of Go packages. It is intended to be used in concert with the &amp;ldquo;go test&amp;rdquo; command, which automates execution of any function of the form</source>
          <target state="translated">패키지 테스트는 Go 패키지의 자동 테스트를 지원합니다. &quot;go test&quot;명령과 함께 사용하여 양식의 모든 기능을 자동으로 실행합니다.</target>
        </trans-unit>
        <trans-unit id="10fa2d9109fabc6fd9b96730e5f6c29a2ec7c36f" translate="yes" xml:space="preserve">
          <source>Package textproto</source>
          <target state="translated">패키지 텍스트</target>
        </trans-unit>
        <trans-unit id="3dc8f07b5e53239f3d16cf68abc4c177c52d10af" translate="yes" xml:space="preserve">
          <source>Package textproto implements generic support for text-based request/response protocols in the style of HTTP, NNTP, and SMTP.</source>
          <target state="translated">패키지 textproto는 HTTP, NNTP 및 SMTP 스타일의 텍스트 기반 요청 / 응답 프로토콜에 대한 일반적인 지원을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="e0896056124ecab0339d61326880bfb542bc907f" translate="yes" xml:space="preserve">
          <source>Package time</source>
          <target state="translated">패키지 시간</target>
        </trans-unit>
        <trans-unit id="5305dc12a988a4ce552cf3341269cdd34206dbc0" translate="yes" xml:space="preserve">
          <source>Package time provides functionality for measuring and displaying time.</source>
          <target state="translated">패키지 시간은 시간을 측정하고 표시하는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2870bb3df8e650dbc1e60be06a2c5ae58d30789e" translate="yes" xml:space="preserve">
          <source>Package tls</source>
          <target state="translated">패키지 tls</target>
        </trans-unit>
        <trans-unit id="7f75931d43fdfef0a07153ddf14ad51258da3f69" translate="yes" xml:space="preserve">
          <source>Package tls partially implements TLS 1.2, as specified in RFC 5246, and TLS 1.3, as specified in RFC 8446.</source>
          <target state="translated">패키지 tls는 RFC 5246에 지정된대로 TLS 1.2 및 RFC 8446에 지정된대로 TLS 1.3을 부분적으로 구현합니다.</target>
        </trans-unit>
        <trans-unit id="71cf571a2e2d9b69987d70384e5e0a349bbf13f6" translate="yes" xml:space="preserve">
          <source>Package token</source>
          <target state="translated">패키지 토큰</target>
        </trans-unit>
        <trans-unit id="3de5e73d48412b9fa410e9f04a2075f5ec3be3f1" translate="yes" xml:space="preserve">
          <source>Package token defines constants representing the lexical tokens of the Go programming language and basic operations on tokens (printing, predicates).</source>
          <target state="translated">패키지 토큰은 Go 프로그래밍 언어의 어휘 토큰 및 토큰에 대한 기본 연산 (인쇄, 술어)을 나타내는 상수를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="7e450a321c355f3612aca2e34d0a073905f6e6ac" translate="yes" xml:space="preserve">
          <source>Package trace</source>
          <target state="translated">패키지 추적</target>
        </trans-unit>
        <trans-unit id="025720b70dde0a472ee8ed25e4b132eb460e89d0" translate="yes" xml:space="preserve">
          <source>Package trace contains facilities for programs to generate traces for the Go execution tracer.</source>
          <target state="translated">패키지 추적에는 Go 실행 추적 프로그램에 대한 추적을 생성하는 프로그램 기능이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e63d422df1350bbdcfb3a251a3dd0dcdbbc02d1" translate="yes" xml:space="preserve">
          <source>Package trace provides user annotation APIs that can be used to log interesting events during execution.</source>
          <target state="translated">패키지 추적은 실행 중에 흥미로운 이벤트를 기록하는 데 사용할 수있는 사용자 주석 API를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b954397c4a071e1cc2e5aec57815cae94675ccf5" translate="yes" xml:space="preserve">
          <source>Package types</source>
          <target state="translated">패키지 유형</target>
        </trans-unit>
        <trans-unit id="046779ebad1597aa59c89817459594972c347086" translate="yes" xml:space="preserve">
          <source>Package types declares the data types and implements the algorithms for type-checking of Go packages. Use Config.Check to invoke the type checker for a package. Alternatively, create a new type checker with NewChecker and invoke it incrementally by calling Checker.Files.</source>
          <target state="translated">패키지 유형은 데이터 유형을 선언하고 Go 패키지의 유형 확인 알고리즘을 구현합니다. Config.Check를 사용하여 패키지의 유형 검사기를 호출하십시오. 또는 NewChecker로 새 유형 검사기를 작성하고 Checker.Files를 호출하여 점진적으로 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="813dcf6547764f2f968934a11d3c4a86a0407f1c" translate="yes" xml:space="preserve">
          <source>Package tzdata</source>
          <target state="translated">tzdata 패키지</target>
        </trans-unit>
        <trans-unit id="5a8f4d83bd9a090f2188b9855b65bbac117a7f9e" translate="yes" xml:space="preserve">
          <source>Package tzdata provides an embedded copy of the timezone database.</source>
          <target state="translated">패키지 tzdata는 시간대 데이터베이스의 내장 된 사본을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6a7aa1b6a03b1ea3399574248eee32f7c7d186f6" translate="yes" xml:space="preserve">
          <source>Package tzdata provides an embedded copy of the timezone database. If this package is imported anywhere in the program, then if the time package cannot find tzdata files on the system, it will use this embedded information.</source>
          <target state="translated">패키지 tzdata는 시간대 데이터베이스의 내장 된 사본을 제공합니다. 이 패키지를 프로그램의 어느 곳에서나 가져 오면 시간 패키지가 시스템에서 tzdata 파일을 찾을 수없는 경우이 포함 된 정보를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ab9e4b9642ec1eafa3034c351ee1c61944a1812d" translate="yes" xml:space="preserve">
          <source>Package unicode</source>
          <target state="translated">패키지 유니 코드</target>
        </trans-unit>
        <trans-unit id="1d363f9997c96fdcfdb92764e225e66454bc7d90" translate="yes" xml:space="preserve">
          <source>Package unicode provides data and functions to test some properties of Unicode code points.</source>
          <target state="translated">패키지 유니 코드는 유니 코드 코드 포인트의 일부 속성을 테스트하기위한 데이터 및 함수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ed360d93d2eb692bc3647fbb297fd557060587f2" translate="yes" xml:space="preserve">
          <source>Package unsafe</source>
          <target state="translated">안전하지 않은 패키지</target>
        </trans-unit>
        <trans-unit id="f3779d5060271e804458c7a976ac1ca5792c1c2a" translate="yes" xml:space="preserve">
          <source>Package unsafe contains operations that step around the type safety of Go programs.</source>
          <target state="translated">안전하지 않은 패키지에는 Go 프로그램의 유형 안전을 둘러싼 작업이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7fd4c1e0c59a537b7729289d4b67c4a3c1f81ee5" translate="yes" xml:space="preserve">
          <source>Package url</source>
          <target state="translated">패키지 URL</target>
        </trans-unit>
        <trans-unit id="4387dda0da368c99a229d78b0b38d344b8ddba79" translate="yes" xml:space="preserve">
          <source>Package url parses URLs and implements query escaping.</source>
          <target state="translated">패키지 URL은 URL을 구문 분석하고 쿼리 이스케이프를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="fa2e3df3b1c8d0f2ae6af8b9831692e368e35553" translate="yes" xml:space="preserve">
          <source>Package user</source>
          <target state="translated">패키지 사용자</target>
        </trans-unit>
        <trans-unit id="36a98acad58d4786ee6c07f69161ac71cff79f1c" translate="yes" xml:space="preserve">
          <source>Package user allows user account lookups by name or id.</source>
          <target state="translated">패키지 사용자는 이름 또는 ID별로 사용자 계정을 조회 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="950f17b07369b94da04e57b90cd290ee5b7ab329" translate="yes" xml:space="preserve">
          <source>Package utf16</source>
          <target state="translated">패키지 utf16</target>
        </trans-unit>
        <trans-unit id="a91481384b6ca45acef08e50a0a602f6b354aa0d" translate="yes" xml:space="preserve">
          <source>Package utf16 implements encoding and decoding of UTF-16 sequences.</source>
          <target state="translated">패키지 utf16은 UTF-16 시퀀스의 인코딩 및 디코딩을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="82c84de36eee3827503136824453e15f86291f2b" translate="yes" xml:space="preserve">
          <source>Package utf8</source>
          <target state="translated">패키지 utf8</target>
        </trans-unit>
        <trans-unit id="2d558781d2038e750681faba06d532094ebcdee0" translate="yes" xml:space="preserve">
          <source>Package utf8 implements functions and constants to support text encoded in UTF-8.</source>
          <target state="translated">패키지 utf8은 UTF-8로 인코딩 된 텍스트를 지원하기 위해 함수와 상수를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="c4336946f769b3e34f747cb0c522858f6f2bca8f" translate="yes" xml:space="preserve">
          <source>Package utf8 implements functions and constants to support text encoded in UTF-8. It includes functions to translate between runes and UTF-8 byte sequences.</source>
          <target state="translated">패키지 utf8은 UTF-8로 인코딩 된 텍스트를 지원하기 위해 함수와 상수를 구현합니다. 룬과 UTF-8 바이트 시퀀스 사이를 변환하는 기능이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="09fcd10fda7e23015ec9957b448561783febe505" translate="yes" xml:space="preserve">
          <source>Package utf8 implements functions and constants to support text encoded in UTF-8. It includes functions to translate between runes and UTF-8 byte sequences. See &lt;a href=&quot;https://en.wikipedia.org/wiki/UTF-8&quot;&gt;https://en.wikipedia.org/wiki/UTF-8&lt;/a&gt;</source>
          <target state="translated">패키지 utf8은 UTF-8로 인코딩 된 텍스트를 지원하는 함수와 상수를 구현합니다. 룬과 UTF-8 바이트 시퀀스 사이를 번역하는 함수가 포함되어 있습니다. 보다&lt;a href=&quot;https://en.wikipedia.org/wiki/UTF-8&quot;&gt; https://en.wikipedia.org/wiki/UTF-8를&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e005285bbb9f85e9b954bed4a6e12999ae03a672" translate="yes" xml:space="preserve">
          <source>Package x509</source>
          <target state="translated">패키지 x509</target>
        </trans-unit>
        <trans-unit id="90de220d2bc052deab02c2c4de98a3e71c3ef316" translate="yes" xml:space="preserve">
          <source>Package x509 parses X.509-encoded keys and certificates.</source>
          <target state="translated">패키지 x509는 X.509로 인코딩 된 키와 인증서를 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="10ff4b7cfdffba3a4767c605c3ebace89b42f92c" translate="yes" xml:space="preserve">
          <source>Package xml</source>
          <target state="translated">패키지 XML</target>
        </trans-unit>
        <trans-unit id="93a9b657d94cd318e7ad743005d8b996f9595c6e" translate="yes" xml:space="preserve">
          <source>Package xml implements a simple XML 1.0 parser that understands XML name spaces.</source>
          <target state="translated">패키지 xml은 XML 네임 스페이스를 이해하는 간단한 XML 1.0 파서를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="c19f04e6d6be831ab25449a487f0756316b351f6" translate="yes" xml:space="preserve">
          <source>Package zip</source>
          <target state="translated">패키지 지퍼</target>
        </trans-unit>
        <trans-unit id="dfaad266283daad5d81fc0dfbfdf6760dc866668" translate="yes" xml:space="preserve">
          <source>Package zip provides support for reading and writing ZIP archives.</source>
          <target state="translated">패키지 zip은 ZIP 아카이브를 읽고 쓰는 기능을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="588377b14974d4da962ee44fcd3a951c7da0ddbc" translate="yes" xml:space="preserve">
          <source>Package zlib</source>
          <target state="translated">패키지 zlib</target>
        </trans-unit>
        <trans-unit id="b8d40d3cbcb305861fd98b2ba9ad33cfda1fe2f6" translate="yes" xml:space="preserve">
          <source>Package zlib implements reading and writing of zlib format compressed data, as specified in RFC 1950.</source>
          <target state="translated">패키지 zlib는 RFC 1950에 지정된대로 zlib 형식 압축 데이터 읽기 및 쓰기를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="e6ebfcdbe4d41913bba3eb021c5e2f7faa2a5af8" translate="yes" xml:space="preserve">
          <source>PackageExports reports whether there are exported declarations; it returns false otherwise.</source>
          <target state="translated">PackageExports는 내 보낸 선언이 있는지보고합니다. 그렇지 않으면 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d9ae56929a397151dd71c50540c8ba9f7a374f8b" translate="yes" xml:space="preserve">
          <source>PackageExports trims the AST for a Go package in place such that only exported nodes remain. The pkg.Files list is not changed, so that file names and top-level package comments don't get lost.</source>
          <target state="translated">PackageExports는 내 보낸 노드 만 남아 있도록 Go 패키지의 AST를 잘라냅니다. pkg.Files 목록은 변경되지 않으므로 파일 이름과 최상위 패키지 주석이 손실되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="74867f01a0f6f645509d530ed289df047c6ca5df" translate="yes" xml:space="preserve">
          <source>PackageName returns the package part of the symbol name, or the empty string if there is none.</source>
          <target state="translated">PackageName은 심볼 이름의 패키지 부분을 반환하거나 존재하지 않는 경우 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="17c03b27b19d3b24962032b7096b91392545e063" translate="yes" xml:space="preserve">
          <source>Packages that import unsafe may be non-portable and are not protected by the Go 1 compatibility guidelines.</source>
          <target state="translated">안전하지 않은 패키지는 이식 할 수 없으며 Go 1 호환성 지침에 의해 보호되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="85b5ee2819eb33cd78762cf51c0b4a5dd5523cb8" translate="yes" xml:space="preserve">
          <source>PacketConn is a generic packet-oriented network connection.</source>
          <target state="translated">PacketConn은 일반적인 패킷 지향 네트워크 연결입니다.</target>
        </trans-unit>
        <trans-unit id="a0ac68089bb018405a8a46934512cae685b010b0" translate="yes" xml:space="preserve">
          <source>Palette is a palette of colors.</source>
          <target state="translated">팔레트는 색상 팔레트입니다.</target>
        </trans-unit>
        <trans-unit id="8345eec10c921c39ee65aec65372e629adf963d0" translate="yes" xml:space="preserve">
          <source>Paletted is an in-memory image of uint8 indices into a given palette.</source>
          <target state="translated">팔레트는 주어진 팔레트에 대한 uint8 인덱스의 메모리 내 이미지입니다.</target>
        </trans-unit>
        <trans-unit id="811857fbbfb6bbe0a3457e5ca72c3cf06e353567" translate="yes" xml:space="preserve">
          <source>PalettedImage is an image whose colors may come from a limited palette. If m is a PalettedImage and m.ColorModel() returns a color.Palette p, then m.At(x, y) should be equivalent to p[m.ColorIndexAt(x, y)]. If m's color model is not a color.Palette, then ColorIndexAt's behavior is undefined.</source>
          <target state="translated">PalettedImage는 색상이 제한된 팔레트에서 나올 수있는 이미지입니다. m이 PalettedImage이고 m.ColorModel ()이 color.Palette p를 반환하면 m.At (x, y)는 p [m.ColorIndexAt (x, y)]와 동일해야합니다. m의 색상 모델이 color.Palette가 아닌 경우 ColorIndexAt의 동작은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a512c7d0f9809b6517eee35249de666659ba9bfb" translate="yes" xml:space="preserve">
          <source>Panic is equivalent to Print() followed by a call to panic().</source>
          <target state="translated">Panic은 Print ()와 동일하며 panic ()을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="70327e98d175663a82976707da91eda94bf1b6a7" translate="yes" xml:space="preserve">
          <source>Panic is equivalent to l.Print() followed by a call to panic().</source>
          <target state="translated">패닉은 l.Print ()와 동일하며 panic ()을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="acc202ec50a5ea3772bacf3218be7877d69941fa" translate="yes" xml:space="preserve">
          <source>Panicf is equivalent to Printf() followed by a call to panic().</source>
          <target state="translated">Panicf는 Printf ()와 동일하며 panic ()을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="609a5ff18403fc4ba9beec643b7a217eafb712bf" translate="yes" xml:space="preserve">
          <source>Panicf is equivalent to l.Printf() followed by a call to panic().</source>
          <target state="translated">Panicf는 l.Printf () 다음에 panic ()을 호출하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="de496f946eb01de54aacea36389a2930b2b5fea9" translate="yes" xml:space="preserve">
          <source>Panicln is equivalent to Println() followed by a call to panic().</source>
          <target state="translated">Panicln은 Println ()과 동일하며 panic ()을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="42b6fefdbb3fe1d6cc946346feb02780fc4954d4" translate="yes" xml:space="preserve">
          <source>Panicln is equivalent to l.Println() followed by a call to panic().</source>
          <target state="translated">Panicln은 l.Println ()과 동일하며 panic ()을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="3f233f952852726c76f955efdb8cfad2984864f8" translate="yes" xml:space="preserve">
          <source>Panics if x is not one of the expected types.</source>
          <target state="translated">x가 예상 유형 중 하나가 아닌 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2656e6fe95970497f2da4ae50b709bea0cd1bc5b" translate="yes" xml:space="preserve">
          <source>Parallel signals that this test is to be run in parallel with (and only with) other parallel tests. When a test is run multiple times due to use of -test.count or -test.cpu, multiple instances of a single test never run in parallel with each other.</source>
          <target state="translated">이 테스트가 다른 병렬 테스트와 함께 병렬로 실행되어야한다는 병렬 신호. -test.count 또는 -test.cpu를 사용하여 테스트를 여러 번 실행하면 단일 테스트의 여러 인스턴스가 서로 병렬로 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2ff45dda694203612652ce58eb32539f9ea39636" translate="yes" xml:space="preserve">
          <source>ParameterSizes is an enumeration of the acceptable bit lengths of the primes in a set of DSA parameters. See FIPS 186-3, section 4.2.</source>
          <target state="translated">ParameterSizes는 소수의 DSA 매개 변수 세트에서 소수의 허용 가능한 비트 길이를 열거 한 것입니다. FIPS 186-3, 섹션 4.2를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a38d6c7adf0ef721d51b09e9ef7d3dab505e3376" translate="yes" xml:space="preserve">
          <source>Parameters represents the domain parameters for a key. These parameters can be shared across many keys. The bit length of Q must be a multiple of 8.</source>
          <target state="translated">매개 변수는 키의 도메인 매개 변수를 나타냅니다. 이러한 매개 변수는 많은 키에서 공유 할 수 있습니다. Q의 비트 길이는 8의 배수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="f2a595a7d8c4b648ee6f267ac2a444e5bcc46523" translate="yes" xml:space="preserve">
          <source>Params returns the parameters of signature s, or nil.</source>
          <target state="translated">Params는 signatures 또는 nil의 매개 변수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="21b514799f92100d51f5995498a76d50a6591d7f" translate="yes" xml:space="preserve">
          <source>Parent returns the scope in which the object is declared. The result is nil for methods and struct fields.</source>
          <target state="translated">Parent는 객체가 선언 된 범위를 반환합니다. 메소드 및 구조체 필드의 경우 결과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6d2ab1d9170cbc23bb71b0003b207c4504e77bc1" translate="yes" xml:space="preserve">
          <source>Parent returns the scope's containing (parent) scope.</source>
          <target state="translated">Parent는 스코프의 포함 (부모) 범위를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b7e45a36ff3610e06a3801fd14fa6c1e6b89312f" translate="yes" xml:space="preserve">
          <source>Parse</source>
          <target state="translated">Parse</target>
        </trans-unit>
        <trans-unit id="eadd3db51adcf33e03ef4c729d1f1d357ded94ad" translate="yes" xml:space="preserve">
          <source>Parse may be called multiple times to assemble the various associated templates; see the ParseFiles and ParseGlob functions and methods for simple ways to parse related templates stored in files.</source>
          <target state="translated">다양한 관련 템플릿을 조립하기 위해 구문 분석을 여러 번 호출 할 수 있습니다. 파일에 저장된 관련 템플릿을 구문 분석하는 간단한 방법은 ParseFiles 및 ParseGlob 함수 및 메소드를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8d5c1289f5e01bfdc5e745aca9c64851f068edc1" translate="yes" xml:space="preserve">
          <source>Parse parses a URL in the context of the receiver. The provided URL may be relative or absolute. Parse returns nil, err on parse failure, otherwise its return value is the same as ResolveReference.</source>
          <target state="translated">구문 분석은 수신자의 컨텍스트에서 URL을 구문 분석합니다. 제공된 URL은 상대적이거나 절대적 일 수 있습니다. 구문 분석은 nil을 리턴하고 구문 분석 실패시 오류를 리턴합니다. 그렇지 않으면 리턴 값은 ResolveReference와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="8516fe9b2b0e681b5f1a19c09c598e09f76c0a92" translate="yes" xml:space="preserve">
          <source>Parse parses a formatted string and returns the time value it represents. The layout defines the format by showing how the reference time, defined to be</source>
          <target state="translated">구문 분석은 형식화 된 문자열을 구문 분석하고 해당 문자열이 나타내는 시간 값을 리턴합니다. 레이아웃은 기준 시간이 다음과 같이 정의 된 방식을 보여줌으로써 형식을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="db84b44056db6c0589142cb550f7685b84290b5a" translate="yes" xml:space="preserve">
          <source>Parse parses a regular expression string s, controlled by the specified Flags, and returns a regular expression parse tree. The syntax is described in the top-level comment.</source>
          <target state="translated">구문 분석은 지정된 플래그에 의해 제어되는 정규식 문자열을 구문 분석하고 정규식 구문 분석 트리를 리턴합니다. 구문은 최상위 주석에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="be0cb24027bbf7f03a0c792dd455fd65c8a881c5" translate="yes" xml:space="preserve">
          <source>Parse parses a single RFC 5322 address of the form &quot;Gogh Fir &amp;lt;gf@example.com&amp;gt;&quot; or &quot;foo@example.com&quot;.</source>
          <target state="translated">구문 분석은 &quot;Gogh Fir &amp;lt;gf@example.com&amp;gt;&quot;또는 &quot;foo@example.com&quot;형식의 단일 RFC 5322 주소를 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="752dc6bd0eac2233d3708db7188652b9f75b7d68" translate="yes" xml:space="preserve">
          <source>Parse parses a single build constraint line of the form &amp;ldquo;//go:build ...&amp;rdquo; or &amp;ldquo;// +build ...&amp;rdquo; and returns the corresponding boolean expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6329cd5d9d98d1f00f6752cb84cd2b25ccb27456" translate="yes" xml:space="preserve">
          <source>Parse parses flag definitions from the argument list, which should not include the command name. Must be called after all flags in the FlagSet are defined and before flags are accessed by the program. The return value will be ErrHelp if -help or -h were set but not defined.</source>
          <target state="translated">구문 분석은 명령 목록을 포함하지 않아야하는 인수 목록에서 플래그 정의를 구문 분석합니다. FlagSet의 모든 플래그가 정의 된 후 그리고 프로그램이 플래그에 액세스하기 전에 호출해야합니다. -help 또는 -h가 설정되었지만 정의되지 않은 경우 리턴 값은 ErrHelp입니다.</target>
        </trans-unit>
        <trans-unit id="18bad4ea2cc97c8a9f4948e0f21e613e7890178a" translate="yes" xml:space="preserve">
          <source>Parse parses rawurl into a URL structure.</source>
          <target state="translated">구문 분석은 rawurl을 URL 구조로 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="68237f10d24bed5fb80b0763ff0184c661ba1727" translate="yes" xml:space="preserve">
          <source>Parse parses s which must contain a text representation of a floating- point number with a mantissa in the given conversion base (the exponent is always a decimal number), or a string representing an infinite value.</source>
          <target state="translated">구문 분석 제공된 변환 기준에서 가수가있는 부동 소수점 숫자 (지수는 항상 10 진수) 또는 무한 값을 나타내는 문자열의 텍스트 표현을 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="36bbed9dac5fc81c047e065b17ee658b65e3a5a6" translate="yes" xml:space="preserve">
          <source>Parse parses text as a template body for t. Named template definitions ({{define ...}} or {{block ...}} statements) in text define additional templates associated with t and are removed from the definition of t itself.</source>
          <target state="translated">구문 분석 텍스트를 t의 템플리트 본문으로 구문 분석합니다. 텍스트에서 명명 된 템플릿 정의 ({{define ...}} 또는 {{block ...}} 문)는 t와 관련된 추가 템플릿을 정의하며 t 자체의 정의에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="b0827d39a9b548f4f8b5bce9dee6cdaa918b52e5" translate="yes" xml:space="preserve">
          <source>Parse parses the command-line flags from os.Args[1:]. Must be called after all flags are defined and before flags are accessed by the program.</source>
          <target state="translated">구문 분석은 os.Args [1 :]에서 명령 행 플래그를 구문 분석합니다. 모든 플래그가 정의되고 프로그램이 플래그에 액세스하기 전에 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="b42efe8079bb64df560c33d7d830ca75ae8ed877" translate="yes" xml:space="preserve">
          <source>Parse parses the template definition string to construct a representation of the template for execution. If either action delimiter string is empty, the default (&quot;{{&quot; or &quot;}}&quot;) is used. Embedded template definitions are added to the treeSet map.</source>
          <target state="translated">구문 분석은 템플리트 정의 문자열을 구문 분석하여 실행할 템플리트의 표현을 구성합니다. 조치 분리 문자 문자열이 비어 있으면 기본값 ( &quot;{{&quot;또는 &quot;}}&quot;)이 사용됩니다. 포함 된 템플릿 정의가 treeSet 맵에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="45783abf61a9fbf7fb39991bfe339c1b46133bb7" translate="yes" xml:space="preserve">
          <source>Parse returns a map from template name to parse.Tree, created by parsing the templates described in the argument string. The top-level template will be given the specified name. If an error is encountered, parsing stops and an empty map is returned with the error.</source>
          <target state="translated">Parse는 템플릿 이름에서 parse.Tree 로의 맵을 반환하며 인수 문자열에 설명 된 템플릿을 구문 분석하여 생성됩니다. 최상위 템플릿에는 지정된 이름이 지정됩니다. 오류가 발생하면 구문 분석이 중지되고 오류와 함께 빈 맵이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="66daff607d3735d4a8218dfbf123ab6dbc3c14bd" translate="yes" xml:space="preserve">
          <source>ParseAddress</source>
          <target state="translated">ParseAddress</target>
        </trans-unit>
        <trans-unit id="845f64c05cb52df568c8a8ad63c74420b1248668" translate="yes" xml:space="preserve">
          <source>ParseAddress parses a single RFC 5322 address, e.g. &quot;Barry Gibbs &amp;lt;bg@example.com&amp;gt;&quot;</source>
          <target state="translated">ParseAddress는 단일 RFC 5322 주소를 구문 분석합니다 (예 : &quot;Barry Gibbs &amp;lt;bg@example.com&amp;gt;&quot;).</target>
        </trans-unit>
        <trans-unit id="ff9201bea61c197b726cdbdba040febe1fb6e8d1" translate="yes" xml:space="preserve">
          <source>ParseAddressList</source>
          <target state="translated">ParseAddressList</target>
        </trans-unit>
        <trans-unit id="ac5ae9b34b3307e496577d3e37b7a87a645c4e1d" translate="yes" xml:space="preserve">
          <source>ParseAddressList parses the given string as a list of addresses.</source>
          <target state="translated">ParseAddressList는 주어진 문자열을 주소 목록으로 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="6a0560d771cdd8a3e81f49597b77c74c345d99ff" translate="yes" xml:space="preserve">
          <source>ParseBool</source>
          <target state="translated">ParseBool</target>
        </trans-unit>
        <trans-unit id="48e4dd268460af7ff4ba4ae65e2a683e5e2d3f52" translate="yes" xml:space="preserve">
          <source>ParseBool returns the boolean value represented by the string. It accepts 1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False. Any other value returns an error.</source>
          <target state="translated">ParseBool은 문자열로 표시되는 부울 값을 반환합니다. 1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False를 허용합니다. 다른 값은 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="22e1b2e318d4e5834961059fa9d10ad0bddc3198" translate="yes" xml:space="preserve">
          <source>ParseBool, ParseFloat, ParseInt, and ParseUint convert strings to values:</source>
          <target state="translated">ParseBool, ParseFloat, ParseInt 및 ParseUint는 문자열을 값으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="b287ba3d9ab143c06c570eef216327abbf80cd22" translate="yes" xml:space="preserve">
          <source>ParseCIDR</source>
          <target state="translated">ParseCIDR</target>
        </trans-unit>
        <trans-unit id="753119985829ad20f5fb77b43aff8f713890c2d1" translate="yes" xml:space="preserve">
          <source>ParseCIDR parses s as a CIDR notation IP address and prefix length, like &quot;192.0.2.0/24&quot; or &quot;2001:db8::/32&quot;, as defined in RFC 4632 and RFC 4291.</source>
          <target state="translated">ParseCIDR은 RFC 4632 및 RFC 4291에 정의 된대로 &quot;192.0.2.0/24&quot;또는 &quot;2001 : db8 :: / 32&quot;와 같은 CIDR 표기법 IP 주소 및 접두사 길이로 s를 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="3db7887ddb0dc9836c9d867b0da11217386b066e" translate="yes" xml:space="preserve">
          <source>ParseCRL parses a CRL from the given bytes. It's often the case that PEM encoded CRLs will appear where they should be DER encoded, so this function will transparently handle PEM encoding as long as there isn't any leading garbage.</source>
          <target state="translated">ParseCRL은 주어진 바이트에서 CRL을 구문 분석합니다. PEM으로 인코딩 된 CRL이 DER로 인코딩되어야하는 곳에 나타나는 경우가 많으므로이 함수는 선행 가비지가없는 한 PEM 인코딩을 투명하게 처리합니다.</target>
        </trans-unit>
        <trans-unit id="13bcfda4565f496b59a919b4e59789ae5fb7deb1" translate="yes" xml:space="preserve">
          <source>ParseCertificate parses a single certificate from the given ASN.1 DER data.</source>
          <target state="translated">ParseCertificate는 지정된 ASN.1 DER 데이터에서 단일 인증서를 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="d4b98b2809a870dbc00f34abcb696de9660e20f1" translate="yes" xml:space="preserve">
          <source>ParseCertificateRequest parses a single certificate request from the given ASN.1 DER data.</source>
          <target state="translated">ParseCertificateRequest는 지정된 ASN.1 DER 데이터에서 단일 인증서 요청을 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="9d2d10677b59853b34c04edbc18da2141f6ef823" translate="yes" xml:space="preserve">
          <source>ParseCertificates parses one or more certificates from the given ASN.1 DER data. The certificates must be concatenated with no intermediate padding.</source>
          <target state="translated">ParseCertificates는 지정된 ASN.1 DER 데이터에서 하나 이상의 인증서를 구문 분석합니다. 인증서는 중간 패딩없이 연결해야합니다.</target>
        </trans-unit>
        <trans-unit id="2cab629150d21e9f3c9fe4049ab7a14ed1660bb2" translate="yes" xml:space="preserve">
          <source>ParseComplex converts the string s to a complex number with the precision specified by bitSize: 64 for complex64, or 128 for complex128. When bitSize=64, the result still has type complex128, but it will be convertible to complex64 without changing its value.</source>
          <target state="translated">ParseComplex는 문자열 s를 bitSize (complex64의 경우 64, complex128의 경우 128)로 지정된 정밀도로 복소수로 변환합니다. bitSize = 64 인 경우 결과에는 여전히 complex128 유형이 있지만 값을 변경하지 않고 complex64로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fa30c63d37bc2001c3a764872c0890c61f8acf6" translate="yes" xml:space="preserve">
          <source>ParseDERCRL parses a DER encoded CRL from the given bytes.</source>
          <target state="translated">ParseDERCRL은 지정된 바이트에서 DER로 인코딩 된 CRL을 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="f3ec2edc0774eff41258539b91058f5d4cf9cd35" translate="yes" xml:space="preserve">
          <source>ParseDate parses an RFC 5322 date string.</source>
          <target state="translated">ParseDate는 RFC 5322 날짜 문자열을 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="758fe9e9cbf2d56e3666f652d8acda7c98141564" translate="yes" xml:space="preserve">
          <source>ParseDir calls ParseFile for all files with names ending in &quot;.go&quot; in the directory specified by path and returns a map of package name -&amp;gt; package AST with all the packages found.</source>
          <target state="translated">ParseDir는 path로 지정된 디렉토리에서 이름이 &quot;.go&quot;로 끝나는 모든 파일에 대해 ParseFile을 호출하고 모든 패키지가있는 패키지 이름-&amp;gt; 패키지 AST의 맵을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="047621ddb91e82c184423e2a73f8e0cee328837e" translate="yes" xml:space="preserve">
          <source>ParseDirent parses up to max directory entries in buf, appending the names to names. It returns the number of bytes consumed from buf, the number of entries added to names, and the new names slice.</source>
          <target state="translated">ParseDirent는 buf의 최대 디렉토리 항목을 구문 분석하여 이름에 이름을 추가합니다. buf에서 소비 한 바이트 수, 이름에 추가 된 항목 수 및 새 이름 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ba15ad44a0d5b5aa5c04df3157000d88065b3088" translate="yes" xml:space="preserve">
          <source>ParseDuration</source>
          <target state="translated">ParseDuration</target>
        </trans-unit>
        <trans-unit id="0ccdc47cbfb062465c3ce4028258bbb8cace970b" translate="yes" xml:space="preserve">
          <source>ParseDuration parses a duration string. A duration string is a possibly signed sequence of decimal numbers, each with optional fraction and a unit suffix, such as &quot;300ms&quot;, &quot;-1.5h&quot; or &quot;2h45m&quot;. Valid time units are &quot;ns&quot;, &quot;us&quot; (or &quot;&amp;micro;s&quot;), &quot;ms&quot;, &quot;s&quot;, &quot;m&quot;, &quot;h&quot;.</source>
          <target state="translated">ParseDuration은 기간 문자열을 구문 분석합니다. 기간 문자열은 부호있는 10 진수 시퀀스이며, 각각 선택적 분수 및 &quot;300ms&quot;, &quot;-1.5h&quot;또는 &quot;2h45m&quot;과 같은 단위 접미사를 갖습니다. 유효한 시간 단위는 &quot;ns&quot;, &quot;us&quot;(또는 &quot;&amp;micro;s&quot;), &quot;ms&quot;, &quot;s&quot;, &quot;m&quot;, &quot;h&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="67fb1e245593c79c4ca873f961b0227d64ccfe30" translate="yes" xml:space="preserve">
          <source>ParseECPrivateKey parses an EC private key in SEC 1, ASN.1 DER form.</source>
          <target state="translated">ParseECPrivateKey는 SEC 1, ASN.1 DER 형식의 EC 개인 키를 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="6665378bb888147fd38985161b70b786f3c21803" translate="yes" xml:space="preserve">
          <source>ParseECPrivateKey parses an EC public key in SEC 1, ASN.1 DER form.</source>
          <target state="translated">ParseECPrivateKey는 SEC 1, ASN.1 DER 형식의 EC 공개 키를 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="892fbba930b3566d06f9df2030763cda6ce95827" translate="yes" xml:space="preserve">
          <source>ParseError describes a problem parsing a time string.</source>
          <target state="translated">ParseError는 시간 문자열을 구문 분석하는 중 문제점을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="9a582c1b02184d48074757655b946996d9f55882" translate="yes" xml:space="preserve">
          <source>ParseExpr is a convenience function for obtaining the AST of an expression x. The position information recorded in the AST is undefined. The filename used in error messages is the empty string.</source>
          <target state="translated">ParseExpr은 표현식 x의 AST를 얻는 편리한 함수입니다. AST에 기록 된 위치 정보는 정의되어 있지 않습니다. 오류 메시지에 사용 된 파일 이름은 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="4fb56e49503c8edcde61d5f7c76a772eeec3484c" translate="yes" xml:space="preserve">
          <source>ParseExprFrom is a convenience function for parsing an expression. The arguments have the same meaning as for ParseFile, but the source must be a valid Go (type or value) expression. Specifically, fset must not be nil.</source>
          <target state="translated">ParseExprFrom은 표현식을 구문 분석하기위한 편리한 함수입니다. 인수는 ParseFile과 동일한 의미를 갖지만 소스는 유효한 Go (유형 또는 값) 표현식이어야합니다. 특히, fset은 nil이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="952e5591ef32d1313e1d0274155bf47019e78eb9" translate="yes" xml:space="preserve">
          <source>ParseFS is like ParseFiles or ParseGlob but reads from the file system fs instead of the host operating system's file system. It accepts a list of glob patterns. (Note that most file names serve as glob patterns matching only themselves.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3f721297f1ca751ee9487c4af009140afa4a6a0" translate="yes" xml:space="preserve">
          <source>ParseFS is like ParseFiles or ParseGlob but reads from the file system fsys instead of the host operating system's file system. It accepts a list of glob patterns. (Note that most file names serve as glob patterns matching only themselves.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1451f0a6821c5b4b2901efe0f3d53819e7c6a483" translate="yes" xml:space="preserve">
          <source>ParseFile</source>
          <target state="translated">ParseFile</target>
        </trans-unit>
        <trans-unit id="8e9f94dbd4c4295f5a413cdec1747ee6881cd1da" translate="yes" xml:space="preserve">
          <source>ParseFile parses the source code of a single Go source file and returns the corresponding ast.File node. The source code may be provided via the filename of the source file, or via the src parameter.</source>
          <target state="translated">ParseFile은 단일 Go 소스 파일의 소스 코드를 구문 분석하고 해당 ast.File 노드를 리턴합니다. 소스 코드는 소스 파일의 파일 이름 또는 src 매개 변수를 통해 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af492bad6c90c31471d746324ef2632bf8eb772d" translate="yes" xml:space="preserve">
          <source>ParseFiles creates a new Template and parses the template definitions from the named files. The returned template's name will have the (base) name and (parsed) contents of the first file. There must be at least one file. If an error occurs, parsing stops and the returned *Template is nil.</source>
          <target state="translated">ParseFiles는 새 템플리트를 작성하고 이름 지정된 파일에서 템플리트 정의를 구문 분석합니다. 반환 된 템플릿 이름은 첫 번째 파일의 (기본) 이름과 (구문 분석 된) 내용을 갖습니다. 파일이 하나 이상 있어야합니다. 오류가 발생하면 구문 분석이 중지되고 리턴 된 * Template이 nil입니다.</target>
        </trans-unit>
        <trans-unit id="8327ff213ed2179b27e0e16f606053c1fb04d28d" translate="yes" xml:space="preserve">
          <source>ParseFiles creates a new Template and parses the template definitions from the named files. The returned template's name will have the base name and parsed contents of the first file. There must be at least one file. If an error occurs, parsing stops and the returned *Template is nil.</source>
          <target state="translated">ParseFiles는 새 템플리트를 작성하고 이름 지정된 파일에서 템플리트 정의를 구문 분석합니다. 반환 된 템플릿 이름은 기본 이름과 첫 번째 파일의 구문 분석 된 내용을 갖습니다. 파일이 하나 이상 있어야합니다. 오류가 발생하면 구문 분석이 중지되고 리턴 된 * Template이 nil입니다.</target>
        </trans-unit>
        <trans-unit id="ce6f3fc6adf60ff33bcdf40a608ef536cc90aa22" translate="yes" xml:space="preserve">
          <source>ParseFiles parses the named files and associates the resulting templates with t. If an error occurs, parsing stops and the returned template is nil; otherwise it is t. There must be at least one file.</source>
          <target state="translated">ParseFiles는 명명 된 파일을 구문 분석하고 결과 템플릿을 t와 연결합니다. 오류가 발생하면 구문 분석이 중지되고 리턴 된 템플리트는 nil입니다. 그렇지 않으면 t입니다. 파일이 하나 이상 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="79c733c837a6ce524269772c4ef5bf48fb11ea5a" translate="yes" xml:space="preserve">
          <source>ParseFiles parses the named files and associates the resulting templates with t. If an error occurs, parsing stops and the returned template is nil; otherwise it is t. There must be at least one file. Since the templates created by ParseFiles are named by the base names of the argument files, t should usually have the name of one of the (base) names of the files. If it does not, depending on t's contents before calling ParseFiles, t.Execute may fail. In that case use t.ExecuteTemplate to execute a valid template.</source>
          <target state="translated">ParseFiles는 명명 된 파일을 구문 분석하고 결과 템플릿을 t와 연결합니다. 오류가 발생하면 구문 분석이 중지되고 리턴 된 템플리트는 nil입니다. 그렇지 않으면 t입니다. 파일이 하나 이상 있어야합니다. ParseFiles로 작성된 템플리트는 인수 파일의 기본 이름으로 이름이 지정되므로 t는 일반적으로 파일의 (기본) 이름 중 하나의 이름을 가져야합니다. 그렇지 않으면 ParseFiles를 호출하기 전에 t의 내용에 따라 t.Execute가 실패 할 수 있습니다. 이 경우 t.ExecuteTemplate을 사용하여 유효한 템플릿을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="91b51eccc60ebf92659e48c7256549a53f281cf8" translate="yes" xml:space="preserve">
          <source>ParseFiles returns an error if t or any associated template has already been executed.</source>
          <target state="translated">t 또는 관련 템플릿이 이미 실행 된 경우 ParseFiles는 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6b854a59dfcaea7000b265f3f7af7b0441340249" translate="yes" xml:space="preserve">
          <source>ParseFloat</source>
          <target state="translated">ParseFloat</target>
        </trans-unit>
        <trans-unit id="a968f6b35cbd445c2c3e17a676a673ab0f036e6d" translate="yes" xml:space="preserve">
          <source>ParseFloat accepts decimal and hexadecimal floating-point number syntax. If s is well-formed and near a valid floating-point number, ParseFloat returns the nearest floating-point number rounded using IEEE754 unbiased rounding. (Parsing a hexadecimal floating-point value only rounds when there are more bits in the hexadecimal representation than will fit in the mantissa.)</source>
          <target state="translated">ParseFloat는 10 진수 및 16 진수 부동 소수점 숫자 구문을 허용합니다. s의 형식이 올 바르고 유효한 부동 소수점 숫자에 가까우면 ParseFloat는 IEEE754 바이어스되지 않은 반올림을 사용하여 반올림 된 가장 가까운 부동 소수점 숫자를 반환합니다. 16 진 부동 소수점 값을 구문 분석하면 16 진 표현에 가수에 맞는 것보다 많은 비트가있는 경우에만 반올림됩니다.</target>
        </trans-unit>
        <trans-unit id="af48529cc69b2749ba1cfbd0072a925bc4216cca" translate="yes" xml:space="preserve">
          <source>ParseFloat converts the string s to a floating-point number with the precision specified by bitSize: 32 for float32, or 64 for float64. When bitSize=32, the result still has type float64, but it will be convertible to float32 without changing its value.</source>
          <target state="translated">ParseFloat는 bitSize에 의해 지정된 정밀도 (float32의 경우 32, float64의 경우 64)로 문자열 s를 부동 소수점 숫자로 변환합니다. bitSize = 32 인 경우 결과에는 여전히 float64 유형이 있지만 값을 변경하지 않고 float32로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8f279e3e47cdc9cf9d872e61192822459d62d17" translate="yes" xml:space="preserve">
          <source>ParseFloat is like f.Parse(s, base) with f set to the given precision and rounding mode.</source>
          <target state="translated">ParseFloat는 f가 주어진 정밀도 및 반올림 모드로 설정된 f.Parse (s, base)와 같습니다.</target>
        </trans-unit>
        <trans-unit id="fd5ce5b41aa64ac617d720e123321224a7f4d140" translate="yes" xml:space="preserve">
          <source>ParseFloat recognizes the strings &quot;NaN&quot;, &quot;+Inf&quot;, and &quot;-Inf&quot; as their respective special floating point values. It ignores case when matching.</source>
          <target state="translated">ParseFloat는 문자열 &quot;NaN&quot;, &quot;+ Inf&quot;및 &quot;-Inf&quot;를 각각의 특수 부동 소수점 값으로 인식합니다. 일치하는 경우 대소 문자를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="8650e12cd7045e56563668c7ff1087423737dd23" translate="yes" xml:space="preserve">
          <source>ParseFloat recognizes the strings &quot;NaN&quot;, and the (possibly signed) strings &quot;Inf&quot; and &quot;Infinity&quot; as their respective special floating point values. It ignores case when matching.</source>
          <target state="translated">ParseFloat는 문자열 &quot;NaN&quot;과 (부호 된) 문자열 &quot;Inf&quot;및 &quot;Infinity&quot;를 각각의 특수 부동 소수점 값으로 인식합니다. 일치 할 때 대소 문자를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="7da060a59d225b78f860ce3acdb64ab957496796" translate="yes" xml:space="preserve">
          <source>ParseForm populates r.Form and r.PostForm.</source>
          <target state="translated">ParseForm은 r.Form 및 r.PostForm을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="07f8973752a66d43b70ef7fb0a84b494aed23663" translate="yes" xml:space="preserve">
          <source>ParseGlob creates a new Template and parses the template definitions from the files identified by the pattern. The files are matched according to the semantics of filepath.Match, and the pattern must match at least one file. The returned template will have the (base) name and (parsed) contents of the first file matched by the pattern. ParseGlob is equivalent to calling ParseFiles with the list of files matched by the pattern.</source>
          <target state="translated">ParseGlob은 새 템플리트를 작성하고 패턴으로 식별 된 파일에서 템플리트 정의를 구문 분석합니다. 파일은 filepath.Match의 의미에 따라 일치하며 패턴은 하나 이상의 파일과 일치해야합니다. 반환 된 템플릿은 패턴과 일치하는 첫 번째 파일의 (기본) 이름과 (구문 분석 된) 내용을 갖습니다. ParseGlob은 패턴과 일치하는 파일 목록으로 ParseFiles를 호출하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0041d2aedbde4c39f613a021a871fa8b33bebd33" translate="yes" xml:space="preserve">
          <source>ParseGlob parses the template definitions in the files identified by the pattern and associates the resulting templates with t. The files are matched according to the semantics of filepath.Match, and the pattern must match at least one file. ParseGlob is equivalent to calling t.ParseFiles with the list of files matched by the pattern.</source>
          <target state="translated">ParseGlob은 패턴으로 식별 된 파일에서 템플리트 정의를 구문 분석하고 결과 템플리트를 t와 연관시킵니다. 파일은 filepath.Match의 의미에 따라 일치하며 패턴은 하나 이상의 파일과 일치해야합니다. ParseGlob은 패턴과 일치하는 파일 목록으로 t.ParseFiles를 호출하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="57508561e68db8f352026127277c4527c06f1494" translate="yes" xml:space="preserve">
          <source>ParseGlob returns an error if t or any associated template has already been executed.</source>
          <target state="translated">t 또는 관련 템플릿이 이미 실행 된 경우 ParseGlob은 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1c95736c9372d59f539bafb6f91f3448c1e25ac0" translate="yes" xml:space="preserve">
          <source>ParseHTTPVersion parses a HTTP version string. &quot;HTTP/1.0&quot; returns (1, 0, true).</source>
          <target state="translated">ParseHTTPVersion은 HTTP 버전 문자열을 구문 분석합니다. &quot;HTTP / 1.0&quot;은 (1, 0, true)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d7d53bd1e0c1908e14a24fac95a6c063838225ad" translate="yes" xml:space="preserve">
          <source>ParseHTTPVersion parses an HTTP version string. &quot;HTTP/1.0&quot; returns (1, 0, true).</source>
          <target state="translated">ParseHTTPVersion은 HTTP 버전 문자열을 구문 분석합니다. &quot;HTTP / 1.0&quot;은 (1, 0, true)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6238bd01ff6944e78dfd936bd2b841304ebe18fe" translate="yes" xml:space="preserve">
          <source>ParseIP</source>
          <target state="translated">ParseIP</target>
        </trans-unit>
        <trans-unit id="571efae0ba53198c7ce6853ee4da1a9ca8b3d31b" translate="yes" xml:space="preserve">
          <source>ParseIP parses s as an IP address, returning the result. The string s can be in IPv4 dotted decimal (&quot;192.0.2.1&quot;), IPv6 (&quot;2001:db8::68&quot;), or IPv4-mapped IPv6 (&quot;::ffff:192.0.2.1&quot;) form. If s is not a valid textual representation of an IP address, ParseIP returns nil.</source>
          <target state="translated">ParseIP는를 IP 주소로 구문 분석하여 결과를 반환합니다. 문자열 s는 점으로 구분 된 IPv4 십진수 ( &quot;192.0.2.1&quot;), IPv6 ( &quot;2001 : db8 :: 68&quot;) 또는 IPv4 매핑 IPv6 ( &quot;:: ffff : 192.0.2.1&quot;) 형식 일 수 있습니다. s가 IP 주소의 유효한 텍스트 표현이 아니면 ParseIP는 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e5c3f7806dc6261b34a424f0eac37be19bc2181d" translate="yes" xml:space="preserve">
          <source>ParseIP parses s as an IP address, returning the result. The string s can be in dotted decimal (&quot;192.0.2.1&quot;) or IPv6 (&quot;2001:db8::68&quot;) form. If s is not a valid textual representation of an IP address, ParseIP returns nil.</source>
          <target state="translated">ParseIP는 s를 IP 주소로 구문 분석하여 결과를 반환합니다. 문자열은 점으로 구분 된 10 진수 ( &quot;192.0.2.1&quot;) 또는 IPv6 ( &quot;2001 : db8 :: 68&quot;) 형식 일 수 있습니다. s가 유효한 IP 주소의 텍스트 표현이 아닌 경우 ParseIP는 nil을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c329eecfda46c75a2f5a9732976e5ca2eab67b96" translate="yes" xml:space="preserve">
          <source>ParseInLocation</source>
          <target state="translated">ParseInLocation</target>
        </trans-unit>
        <trans-unit id="b946980b6995c0bdde650965df500396097ee47e" translate="yes" xml:space="preserve">
          <source>ParseInLocation is like Parse but differs in two important ways. First, in the absence of time zone information, Parse interprets a time as UTC; ParseInLocation interprets the time as in the given location. Second, when given a zone offset or abbreviation, Parse tries to match it against the Local location; ParseInLocation uses the given location.</source>
          <target state="translated">ParseInLocation은 구문 분석과 비슷하지만 두 가지 중요한 차이점이 있습니다. 첫째, 시간대 정보가없는 경우 Parse는 시간을 UTC로 해석합니다. ParseInLocation은 주어진 위치에서 시간을 해석합니다. 둘째, 구역 오프셋이나 약어가 주어지면 Parse는 지역 위치와 일치 시키려고 시도합니다. ParseInLocation은 주어진 위치를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="fd43b39f1cc6436ed26bf5ddd12e6461d48a315e" translate="yes" xml:space="preserve">
          <source>ParseInt</source>
          <target state="translated">ParseInt</target>
        </trans-unit>
        <trans-unit id="da8e97b7f44fd2f5e3e7756990fdef1ef6036785" translate="yes" xml:space="preserve">
          <source>ParseInt interprets a string s in the given base (0, 2 to 36) and bit size (0 to 64) and returns the corresponding value i.</source>
          <target state="translated">ParseInt는 주어진 기본 (0, 2 ~ 36) 및 비트 크기 (0 ~ 64)의 문자열 s를 해석하고 해당 값 i를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="da7fc45328cc9114fb2744e73272d12d929fea5f" translate="yes" xml:space="preserve">
          <source>ParseList parses the given string as a list of comma-separated addresses of the form &quot;Gogh Fir &amp;lt;gf@example.com&amp;gt;&quot; or &quot;foo@example.com&quot;.</source>
          <target state="translated">ParseList는 주어진 문자열을 &quot;Gogh Fir &amp;lt;gf@example.com&amp;gt;&quot;또는 &quot;foo@example.com&quot;형식의 쉼표로 구분 된 주소 목록으로 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="721a0c1b5d6d1ee41cb2e1ce2ccd8399686328dd" translate="yes" xml:space="preserve">
          <source>ParseMAC parses s as an IEEE 802 MAC-48, EUI-48, EUI-64, or a 20-octet IP over InfiniBand link-layer address using one of the following formats:</source>
          <target state="translated">ParseMAC는 다음 형식 중 하나를 사용하여 IEEE 802 MAC-48, EUI-48, EUI-64 또는 20 옥텟 IP over InfiniBand 링크 계층 주소로 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="c4421efbff2b17851a18162d590161832e04ac88" translate="yes" xml:space="preserve">
          <source>ParseMediaType</source>
          <target state="translated">ParseMediaType</target>
        </trans-unit>
        <trans-unit id="76d8884907e134cde6d1ae2f450cf0d83b8102aa" translate="yes" xml:space="preserve">
          <source>ParseMediaType parses a media type value and any optional parameters, per RFC 1521. Media types are the values in Content-Type and Content-Disposition headers (RFC 2183). On success, ParseMediaType returns the media type converted to lowercase and trimmed of white space and a non-nil map. If there is an error parsing the optional parameter, the media type will be returned along with the error ErrInvalidMediaParameter. The returned map, params, maps from the lowercase attribute to the attribute value with its case preserved.</source>
          <target state="translated">ParseMediaType은 RFC 1521에 따라 미디어 유형 값과 선택적 매개 변수를 구문 분석합니다. 미디어 유형은 Content-Type 및 Content-Disposition 헤더 (RFC 2183)의 값입니다. 성공하면 ParseMediaType은 소문자로 변환되고 공백과 0이 아닌 맵으로 트리밍 된 미디어 유형을 반환합니다. 선택적 매개 변수를 구문 분석하는 동안 오류가 발생하면 미디어 유형이 오류 ErrInvalidMediaParameter와 함께 반환됩니다. 반환 된 맵 params는 대소 문자를 유지하면서 소문자 속성에서 속성 값으로 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="bb8befc3cebb8742e6d50cfeac64769f0a3fff7a" translate="yes" xml:space="preserve">
          <source>ParseMultipartForm calls ParseForm automatically. ParseForm is idempotent.</source>
          <target state="translated">ParseMultipartForm은 ParseForm을 자동으로 호출합니다. ParseForm은 dem 등원입니다.</target>
        </trans-unit>
        <trans-unit id="4205ffb0814fbcba9218830e9ad58589fcb016f6" translate="yes" xml:space="preserve">
          <source>ParseMultipartForm parses a request body as multipart/form-data. The whole request body is parsed and up to a total of maxMemory bytes of its file parts are stored in memory, with the remainder stored on disk in temporary files. ParseMultipartForm calls ParseForm if necessary. After one call to ParseMultipartForm, subsequent calls have no effect.</source>
          <target state="translated">ParseMultipartForm은 요청 본문을 multipart / form-data로 구문 분석합니다. 전체 요청 본문이 구문 분석되고 파일 부분의 최대 maxMemory 바이트가 메모리에 저장되고 나머지는 디스크에 임시 파일로 저장됩니다. 필요한 경우 ParseMultipartForm은 ParseForm을 호출합니다. ParseMultipartForm을 한 번 호출 한 후에는 후속 호출이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eecdedc3b85cbbe7f7cb2f75d45c36832c9b2317" translate="yes" xml:space="preserve">
          <source>ParseNetlinkMessage parses b as an array of netlink messages and returns the slice containing the NetlinkMessage structures.</source>
          <target state="translated">ParseNetlinkMessage는 b를 넷 링크 메시지의 배열로 구문 분석하고 NetlinkMessage 구조를 포함하는 슬라이스를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="2f0d8e60be2a0b26156f23d2b913830f42953f1b" translate="yes" xml:space="preserve">
          <source>ParseNetlinkRouteAttr parses m's payload as an array of netlink route attributes and returns the slice containing the NetlinkRouteAttr structures.</source>
          <target state="translated">ParseNetlinkRouteAttr은 m의 페이로드를 netlink 라우트 속성의 배열로 구문 분석하고 NetlinkRouteAttr 구조를 포함하는 슬라이스를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="a52b587a767bf1c632bedd738233c237df6d3c78" translate="yes" xml:space="preserve">
          <source>ParsePKCS1PrivateKey parses an RSA private key in PKCS #1, ASN.1 DER form.</source>
          <target state="translated">ParsePKCS1PrivateKey는 PKCS # 1, ASN.1 DER 형식의 RSA 개인 키를 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="ca8ea4136f1532755b07a48dc5268d78ecf1507c" translate="yes" xml:space="preserve">
          <source>ParsePKCS1PrivateKey parses an RSA private key in PKCS#1, ASN.1 DER form.</source>
          <target state="translated">ParsePKCS1PrivateKey는 PKCS # 1, ASN.1 DER 형식의 RSA 개인 키를 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="619bab7e2604776223fd615db8a092b41e8c25c2" translate="yes" xml:space="preserve">
          <source>ParsePKCS1PublicKey parses an RSA public key in PKCS #1, ASN.1 DER form.</source>
          <target state="translated">ParsePKCS1PublicKey는 PKCS # 1, ASN.1 DER 형식의 RSA 공개 키를 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="37bf10698677a842cf4d973614d5f0307c9b4ece" translate="yes" xml:space="preserve">
          <source>ParsePKCS1PublicKey parses an RSA public key in PKCS#1, ASN.1 DER form.</source>
          <target state="translated">ParsePKCS1PublicKey는 PKCS # 1, ASN.1 DER 형식의 RSA 공개 키를 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="b68e3b8c9444e28652781f01507938e01d6187fc" translate="yes" xml:space="preserve">
          <source>ParsePKCS8PrivateKey parses an unencrypted private key in PKCS #8, ASN.1 DER form.</source>
          <target state="translated">ParsePKCS8PrivateKey는 PKCS # 8, ASN.1 DER 형식으로 암호화되지 않은 개인 키를 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="585855469081df34619bcab57c0395b99ac9b879" translate="yes" xml:space="preserve">
          <source>ParsePKCS8PrivateKey parses an unencrypted private key in PKCS#8, ASN.1 DER form.</source>
          <target state="translated">ParsePKCS8PrivateKey는 암호화되지 않은 개인 키를 PKCS # 8, ASN.1 DER 형식으로 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="53e14792de36ed6cd3349fb2645358e6cd29fbb8" translate="yes" xml:space="preserve">
          <source>ParsePKIXPublicKey</source>
          <target state="translated">ParsePKIXPublicKey</target>
        </trans-unit>
        <trans-unit id="6a4599b4f783a30e67850f302db74a263e5ed679" translate="yes" xml:space="preserve">
          <source>ParsePKIXPublicKey parses a public key in PKIX, ASN.1 DER form.</source>
          <target state="translated">ParsePKIXPublicKey는 공개 키를 PKIX, ASN.1 DER 형식으로 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="e7171526935278226200717c1ff03247778459d2" translate="yes" xml:space="preserve">
          <source>ParsePKIXPublicKey parses a public key in PKIX, ASN.1 DER form. The encoded public key is a SubjectPublicKeyInfo structure (see RFC 5280, Section 4.1).</source>
          <target state="translated">ParsePKIXPublicKey는 PKIX, ASN.1 DER 형식의 공개 키를 구문 분석합니다. 인코딩 된 공개 키는 SubjectPublicKeyInfo 구조입니다 (RFC 5280, 섹션 4.1 참조).</target>
        </trans-unit>
        <trans-unit id="9e247d1a303dadeb36ebb627b0c5ca3e52bc27fd" translate="yes" xml:space="preserve">
          <source>ParseQuery</source>
          <target state="translated">ParseQuery</target>
        </trans-unit>
        <trans-unit id="7c00812498355c3d782c270a326950a437297e57" translate="yes" xml:space="preserve">
          <source>ParseQuery parses the URL-encoded query string and returns a map listing the values specified for each key. ParseQuery always returns a non-nil map containing all the valid query parameters found; err describes the first decoding error encountered, if any.</source>
          <target state="translated">ParseQuery는 URL 인코딩 된 쿼리 문자열을 구문 분석하고 각 키에 지정된 값을 나열하는 맵을 반환합니다. ParseQuery는 항상 발견 된 모든 유효한 쿼리 매개 변수를 포함하는 넌이 아닌 맵을 반환합니다. err은 발생한 첫 번째 디코딩 오류를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="3d5fafc8859915dea1eca90debdb2203d7081d9e" translate="yes" xml:space="preserve">
          <source>ParseRequestURI parses rawurl into a URL structure. It assumes that rawurl was received in an HTTP request, so the rawurl is interpreted only as an absolute URI or an absolute path. The string rawurl is assumed not to have a #fragment suffix. (Web browsers strip #fragment before sending the URL to a web server.)</source>
          <target state="translated">ParseRequestURI는 rawurl을 URL 구조로 구문 분석합니다. rawurl이 HTTP 요청에서 수신되었다고 가정하므로 rawurl은 절대 URI 또는 ​​절대 경로로만 해석됩니다. rawurl 문자열은 #fragment 접미사가없는 것으로 가정합니다. (웹 브라우저는 URL을 웹 서버로 보내기 전에 #fragment를 제거합니다.)</target>
        </trans-unit>
        <trans-unit id="303cbaa0aec4b7b4cb545ea3bdd253a60da46165" translate="yes" xml:space="preserve">
          <source>ParseSocketControlMessage parses b as an array of socket control messages.</source>
          <target state="translated">ParseSocketControlMessage는 b를 소켓 제어 메시지의 배열로 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="68f8375ee4255e9bdd0c3030df2260150e5493b0" translate="yes" xml:space="preserve">
          <source>ParseTime parses a time header (such as the Date: header), trying each of the three formats allowed by HTTP/1.1: TimeFormat, time.RFC850, and time.ANSIC.</source>
          <target state="translated">ParseTime은 HTTP / 1.1에서 허용하는 세 가지 형식 (TimeFormat, time.RFC850 및 time.ANSIC)을 시도하여 시간 헤더 (예 : Date : 헤더)를 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="d09c9d04f1ff3f62cff402b66559957826b67ae1" translate="yes" xml:space="preserve">
          <source>ParseUint</source>
          <target state="translated">ParseUint</target>
        </trans-unit>
        <trans-unit id="7c5c32fd6cd92c39f679dc5ed50b80a4f8a1e92b" translate="yes" xml:space="preserve">
          <source>ParseUint is like ParseInt but for unsigned numbers.</source>
          <target state="translated">ParseUint는 ParseInt와 비슷하지만 부호없는 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="5bf4d74ce6c1b340caf3e896ab5b84ef49cf1719" translate="yes" xml:space="preserve">
          <source>ParseUnixCredentials decodes a socket control message that contains credentials in a Ucred structure. To receive such a message, the SO_PASSCRED option must be enabled on the socket.</source>
          <target state="translated">ParseUnixCredentials는 Ucred 구조의 자격 증명이 포함 된 소켓 제어 메시지를 디코딩합니다. 이러한 메시지를 받으려면 소켓에서 SO_PASSCRED 옵션을 활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="f2cd01c6af8de29d78551fd8726d012bba380c6c" translate="yes" xml:space="preserve">
          <source>ParseUnixRights decodes a socket control message that contains an integer array of open file descriptors from another process.</source>
          <target state="translated">ParseUnixRights는 다른 프로세스에서 열린 파일 디스크립터의 정수 배열을 포함하는 소켓 제어 메시지를 디코딩합니다.</target>
        </trans-unit>
        <trans-unit id="32ac0722953b3173953c3c4db2a050c68e2bace4" translate="yes" xml:space="preserve">
          <source>Parsed reports whether f.Parse has been called.</source>
          <target state="translated">구문 분석은 f.Parse가 호출되었는지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="3448f815420bc7428adf585d197c1f125467f90e" translate="yes" xml:space="preserve">
          <source>Parsed reports whether the command-line flags have been parsed.</source>
          <target state="translated">구문 분석은 명령 행 플래그가 구문 분석되었는지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="dc2eb8678f8e8ede0972857e44c6282f328cc1fa" translate="yes" xml:space="preserve">
          <source>Passing skip=0 begins the stack trace at the call to Add inside rpc.NewClient. Passing skip=1 begins the stack trace at the call to NewClient inside mypkg.Run.</source>
          <target state="translated">skip = 0을 전달하면 rpc.NewClient에서 Add를 호출 할 때 스택 추적이 시작됩니다. skip = 1을 전달하면 mypkg.Run 내에서 NewClient를 호출 할 때 스택 추적이 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="bc137142636c80e92c407f2aa46fcdf54313c790" translate="yes" xml:space="preserve">
          <source>Password returns the password in case it is set, and whether it is set.</source>
          <target state="translated">비밀번호는 설정 한 경우와 설정 여부에 따라 비밀번호를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f13ee82061477b5d5f181659b252f63dfd901dcb" translate="yes" xml:space="preserve">
          <source>Path names passed to open are UTF-8-encoded, unrooted, slash-separated sequences of path elements, like &amp;ldquo;x/y/z&amp;rdquo;. Path names must not contain an element that is &amp;ldquo;.&amp;rdquo; or &amp;ldquo;..&amp;rdquo; or the empty string, except for the special case that the root directory is named &amp;ldquo;.&amp;rdquo;. Paths must not start or end with a slash: &amp;ldquo;/x&amp;rdquo; and &amp;ldquo;x/&amp;rdquo; are invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c6302867f847fe663bbe8d220f8e92a48796687" translate="yes" xml:space="preserve">
          <source>Path returns the package path.</source>
          <target state="translated">경로는 패키지 경로를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d0506b7bdb505a3150b81c4c616dee83d176fcfa" translate="yes" xml:space="preserve">
          <source>PathError records an error and the operation and file path that caused it.</source>
          <target state="translated">PathError는 오류와 그 원인이 된 작업 및 파일 경로를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="e7599081a40b17f0e8c56bbb5dfa806da5a30888" translate="yes" xml:space="preserve">
          <source>PathEscape escapes the string so it can be safely placed inside a URL path segment, replacing special characters (including /) with %XX sequences as needed.</source>
          <target state="translated">PathEscape는 문자열을 이스케이프하여 URL 경로 세그먼트 내에 안전하게 배치 할 수 있으며 필요에 따라 특수 문자 (/ 포함)를 % XX 시퀀스로 대체합니다.</target>
        </trans-unit>
        <trans-unit id="5c3a77b47b5350edac8b6dbc79888f216cc42e3c" translate="yes" xml:space="preserve">
          <source>PathUnescape does the inverse transformation of PathEscape, converting each 3-byte encoded substring of the form &quot;%AB&quot; into the hex-decoded byte 0xAB. It returns an error if any % is not followed by two hexadecimal digits.</source>
          <target state="translated">PathUnescape는 PathEscape의 역변환을 수행하여 &quot;% AB&quot;형식의 각 3 바이트 인코딩 된 하위 문자열을 16 진 디코딩 된 바이트 0xAB로 변환합니다. % 뒤에 두 개의 16 진수가 없으면 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="40463bc26e83c862cf3b0e60286130df1ab877d6" translate="yes" xml:space="preserve">
          <source>PathUnescape is identical to QueryUnescape except that it does not unescape '+' to ' ' (space).</source>
          <target state="translated">PathUnescape는 '+'를 ''(공백)로 이스케이프 처리하지 않는다는 점을 제외하고 QueryUnescape와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="cda78fe9f7d0595a1e181ce1981b7483036ab29c" translate="yes" xml:space="preserve">
          <source>Patterns may optionally begin with a host name, restricting matches to URLs on that host only. Host-specific patterns take precedence over general patterns, so that a handler might register for the two patterns &quot;/codesearch&quot; and &quot;codesearch.google.com/&quot; without also taking over requests for &quot;&lt;a href=&quot;http://www.google.com/&quot;&gt;http://www.google.com/&lt;/a&gt;&quot;.</source>
          <target state="translated">패턴은 선택적으로 호스트 이름으로 시작하여 해당 호스트의 URL로만 일치를 제한 할 수 있습니다. 호스트 별 패턴은 일반 패턴보다 우선하므로 처리기는 &quot; &lt;a href=&quot;http://www.google.com/&quot;&gt;http://www.google.com/&lt;/a&gt; 요청을 인계하지 않고&quot;/ codesearch &quot;및&quot;codesearch.google.com/ &quot;두 패턴을 등록 할 수 있습니다 . &quot;.</target>
        </trans-unit>
        <trans-unit id="9a97ef77b7d4a4a34405a8ad58960e3185e5b856" translate="yes" xml:space="preserve">
          <source>Patterns may optionally begin with a host name, restricting matches to URLs on that host only. Host-specific patterns take precedence over general patterns, so that a handler might register for the two patterns &quot;/codesearch&quot; and &quot;codesearch.google.com/&quot; without also taking over requests for &quot;&lt;a href=&quot;https://www.google.com/&quot;&gt;http://www.google.com/&lt;/a&gt;&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35bc941d4ad694a76b17fe9da3d7ad2fa01041f0" translate="yes" xml:space="preserve">
          <source>Patterns must not match files outside the package's module, such as &amp;lsquo;.git/*&amp;rsquo; or symbolic links. Matches for empty directories are ignored. After that, each pattern in a //go:embed line must match at least one file or non-empty directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c47c55adf239beb3a291abbb9f63d307ef60c16f" translate="yes" xml:space="preserve">
          <source>Patterns name fixed, rooted paths, like &quot;/favicon.ico&quot;, or rooted subtrees, like &quot;/images/&quot; (note the trailing slash). Longer patterns take precedence over shorter ones, so that if there are handlers registered for both &quot;/images/&quot; and &quot;/images/thumbnails/&quot;, the latter handler will be called for paths beginning &quot;/images/thumbnails/&quot; and the former will receive requests for any other paths in the &quot;/images/&quot; subtree.</source>
          <target state="translated">패턴 이름은 &quot;/favicon.ico&quot;와 같은 고정 된 루트 경로 또는 &quot;/ images /&quot;와 같은 루트 하위 트리 (후행 슬래시 참고)입니다. &quot;/ images /&quot;및 &quot;/ images / thumbnails /&quot;모두에 대해 등록 된 핸들러가있는 경우 &quot;/ images / thumbnails /&quot;및 이전의 경로에 대해 후자의 핸들러가 호출되도록 더 긴 패턴이 더 짧은 패턴보다 우선합니다. &quot;/ images /&quot;하위 트리의 다른 경로에 대한 요청을받습니다.</target>
        </trans-unit>
        <trans-unit id="f28eb62c201920349ad82fd89183cea2a77fc0ce" translate="yes" xml:space="preserve">
          <source>Peek returns the next Unicode character in the source without advancing the scanner. It returns EOF if the scanner's position is at the last character of the source.</source>
          <target state="translated">Peek는 스캐너를 진행하지 않고 소스에서 다음 유니 코드 문자를 반환합니다. 스캐너 위치가 소스의 마지막 문자 인 경우 EOF를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2959c1935503c7a46c0b1958e9d8a81763a0ed6a" translate="yes" xml:space="preserve">
          <source>Peek returns the next n bytes without advancing the reader. The bytes stop being valid at the next read call. If Peek returns fewer than n bytes, it also returns an error explaining why the read is short. The error is ErrBufferFull if n is larger than b's buffer size.</source>
          <target state="translated">Peek는 리더를 진행시키지 않고 다음 n 바이트를 반환합니다. 바이트는 다음 읽기 호출에서 유효하지 않습니다. Peek가 n 바이트 미만을 반환하면 읽기가 짧은 이유를 설명하는 오류도 반환합니다. n이 b의 버퍼 크기보다 큰 경우 오류는 ErrBufferFull입니다.</target>
        </trans-unit>
        <trans-unit id="eb621fcca2c83af4eb20df9787fc904ec33fe0d9" translate="yes" xml:space="preserve">
          <source>Pending returns the number of unanswered requests that have been received on the connection.</source>
          <target state="translated">보류 중은 연결에서 수신 한 응답하지 않은 요청 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c6855a32465d5bf0f448eaa4af31e378ea6b4379" translate="yes" xml:space="preserve">
          <source>Pending returns the number of unanswered requests that have been sent on the connection.</source>
          <target state="translated">보류 중은 연결에서 전송 된 응답하지 않은 요청 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c7ceccb01b416098f13eef5c65da35dd4ef29c59" translate="yes" xml:space="preserve">
          <source>Perl character classes (all ASCII-only):</source>
          <target state="translated">펄 문자 클래스 (모든 ASCII 전용) :</target>
        </trans-unit>
        <trans-unit id="327a2b8cad2b9a6ef158a641755a49d69b9cc93f" translate="yes" xml:space="preserve">
          <source>Perm</source>
          <target state="translated">Perm</target>
        </trans-unit>
        <trans-unit id="3a2d3439b42d65bbd3e91c5161e12b3e5af6e212" translate="yes" xml:space="preserve">
          <source>Perm returns the Unix permission bits in m (m &amp;amp; ModePerm).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4cbc1d379695fc60a43435dd6614970bc7cf1c8" translate="yes" xml:space="preserve">
          <source>Perm returns the Unix permission bits in m.</source>
          <target state="translated">Perm은 Unix 권한 비트를 m 단위로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6ed0eddcb867d78e7678ca142786b03c98fcc1cf" translate="yes" xml:space="preserve">
          <source>Perm returns, as a slice of n ints, a pseudo-random permutation of the integers [0,n) from the default Source.</source>
          <target state="translated">Perm은 기본 소스에서 정수 [0, n)의 의사 난수 순열을 n int 조각으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="62a4f6eab662c10e8c22fcd7a13a5adce4b9aeef" translate="yes" xml:space="preserve">
          <source>Perm returns, as a slice of n ints, a pseudo-random permutation of the integers [0,n).</source>
          <target state="translated">Perm은 정수 [0, n)의 의사 난수 순열을 n 개의 정수로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2eb6560251a01ddeba6819d546ca94bf5106de3c" translate="yes" xml:space="preserve">
          <source>Phase returns the phase (also called the argument) of x. The returned value is in the range [-Pi, Pi].</source>
          <target state="translated">Phase는 x의 위상 (인수라고도 함)을 반환합니다. 반환 된 값은 [-Pi, Pi] 범위에 있습니다.</target>
        </trans-unit>
        <trans-unit id="c62187a44c4849f243c0d01a0cd965d235c59c18" translate="yes" xml:space="preserve">
          <source>Pid returns the process id of the exited process.</source>
          <target state="translated">Pid는 종료 된 프로세스의 프로세스 ID를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="aaf942e54daedd7cb953cee036ee4e01d73e3a05" translate="yes" xml:space="preserve">
          <source>Ping verifies a connection to the database is still alive, establishing a connection if necessary.</source>
          <target state="translated">Ping은 데이터베이스에 대한 연결이 아직 활성 상태인지 확인하고 필요한 경우 연결을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="1616a118fdcaf54f337c10d117d16aaa99fd0b14" translate="yes" xml:space="preserve">
          <source>PingContext verifies a connection to the database is still alive, establishing a connection if necessary.</source>
          <target state="translated">PingContext는 데이터베이스에 대한 연결이 아직 활성 상태인지 확인하고 필요한 경우 연결을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="8c943ad1575fde013a5e267aa7a5a04d105d169b" translate="yes" xml:space="preserve">
          <source>PingContext verifies the connection to the database is still alive.</source>
          <target state="translated">PingContext는 데이터베이스와의 연결이 여전히 유효한지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="7a788a1af96c8d9977c69732be97c930615c2f24" translate="yes" xml:space="preserve">
          <source>Pinger is an optional interface that may be implemented by a Conn.</source>
          <target state="translated">Pinger는 Conn에 의해 구현 될 수있는 선택적 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="00dae071c082bb73eaed17b4bb3429280e110e8c" translate="yes" xml:space="preserve">
          <source>Pipe</source>
          <target state="translated">Pipe</target>
        </trans-unit>
        <trans-unit id="e40f59609b56b44e5054b6b92f52ff52a16d5fa3" translate="yes" xml:space="preserve">
          <source>Pipe creates a synchronous in-memory pipe. It can be used to connect code expecting an io.Reader with code expecting an io.Writer.</source>
          <target state="translated">파이프는 동기식 인 메모리 파이프를 만듭니다. io.Reader가 필요한 코드와 io.Writer가 필요한 코드를 연결하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da50f6a47a89e9218a08186e61e447aeaa977683" translate="yes" xml:space="preserve">
          <source>Pipe creates a synchronous, in-memory, full duplex network connection; both ends implement the Conn interface. Reads on one end are matched with writes on the other, copying data directly between the two; there is no internal buffering.</source>
          <target state="translated">파이프는 동기식 메모리 내 전이중 네트워크 연결을 생성합니다. 양쪽 끝은 Conn 인터페이스를 구현합니다. 한쪽 끝의 읽기는 다른 쪽의 쓰기와 일치하며 두 쪽 사이에 데이터를 직접 복사합니다. 내부 버퍼링이 없습니다.</target>
        </trans-unit>
        <trans-unit id="2a31ea2b0e32b3e571d1bceba86196d7bad1fcb8" translate="yes" xml:space="preserve">
          <source>Pipe returns a connected pair of Files; reads from r return bytes written to w. It returns the files and an error, if any.</source>
          <target state="translated">파이프는 연결된 파일 쌍을 반환합니다. r에서 w에 쓴 바이트를 읽습니다. 파일과 오류가있는 경우 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="20f3a37d20161b0046bc712fcc1c973a57a664dc" translate="yes" xml:space="preserve">
          <source>PipeNode holds a pipeline with optional declaration</source>
          <target state="translated">PipeNode는 선택적 선언이있는 파이프 라인을 보유합니다.</target>
        </trans-unit>
        <trans-unit id="f28715a2c22fba2d801918b67be067614e3917c8" translate="yes" xml:space="preserve">
          <source>Pipeline, to manage pipelined requests and responses in a client.</source>
          <target state="translated">파이프 라인 : 클라이언트에서 파이프 라인 요청 및 응답을 관리합니다.</target>
        </trans-unit>
        <trans-unit id="c5df1e14fdba13b1a3f9690f736bcb2aac132e72" translate="yes" xml:space="preserve">
          <source>Pipelines</source>
          <target state="translated">Pipelines</target>
        </trans-unit>
        <trans-unit id="06fc1a48588c809599455a2829c6d8c93dab2807" translate="yes" xml:space="preserve">
          <source>PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y).</source>
          <target state="translated">PixOffset은 (x, y)의 픽셀에 해당하는 Pix의 첫 번째 요소의 인덱스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bf14eb94c114379d054dbd030d4c5c1a50c1bc82" translate="yes" xml:space="preserve">
          <source>Pkg returns the package to which the object belongs. The result is nil for labels and objects in the Universe scope.</source>
          <target state="translated">Pkg는 객체가 속한 패키지를 반환합니다. 유니버스 범위의 레이블 및 개체에는 결과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6b25672d57f482ab04e1df337de0aebb92458d0d" translate="yes" xml:space="preserve">
          <source>PlainAuth</source>
          <target state="translated">PlainAuth</target>
        </trans-unit>
        <trans-unit id="0e0cce6c4e84e3f28344ac03eb2bbf3c7be04c28" translate="yes" xml:space="preserve">
          <source>PlainAuth returns an Auth that implements the PLAIN authentication mechanism as defined in RFC 4616. The returned Auth uses the given username and password to authenticate to host and act as identity. Usually identity should be the empty string, to act as username.</source>
          <target state="translated">PlainAuth는 RFC 4616에 정의 된대로 PLAIN 인증 메커니즘을 구현하는 Auth를 반환합니다. 반환 된 Auth는 지정된 사용자 이름과 암호를 사용하여 호스트하고 ID로 작동하도록 인증합니다. 일반적으로 아이디는 사용자 이름 역할을하는 빈 문자열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="32488aca0b25b337080ddc28faef0ad97faab0e7" translate="yes" xml:space="preserve">
          <source>PlainAuth will only send the credentials if the connection is using TLS or is connected to localhost. Otherwise authentication will fail with an error, without sending the credentials.</source>
          <target state="translated">연결이 TLS를 사용 중이거나 로컬 호스트에 연결된 경우 PlainAuth는 자격 증명을 보냅니다. 그렇지 않으면 자격 증명을 보내지 않고 오류와 함께 인증이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="b8996c869faa8282ed1dc0af722f7f384a441369" translate="yes" xml:space="preserve">
          <source>Plan 9</source>
          <target state="translated">계획 9</target>
        </trans-unit>
        <trans-unit id="fcc50dd97b375efa9e5795002087751fd071d726" translate="yes" xml:space="preserve">
          <source>Plan9 is a 256-color palette that partitions the 24-bit RGB space into 4&amp;times;4&amp;times;4 subdivision, with 4 shades in each subcube. Compared to the WebSafe, the idea is to reduce the color resolution by dicing the color cube into fewer cells, and to use the extra space to increase the intensity resolution. This results in 16 gray shades (4 gray subcubes with 4 samples in each), 13 shades of each primary and secondary color (3 subcubes with 4 samples plus black) and a reasonable selection of colors covering the rest of the color cube. The advantage is better representation of continuous tones.</source>
          <target state="translated">Plan9는 24 비트 RGB 공간을 4x4x4 세분으로 분할하고 각 서브 큐브에 4 개의 음영을 갖는 256 색 팔레트입니다. WebSafe와 비교하여, 아이디어는 컬러 큐브를 더 적은 수의 셀로 나누어 컬러 해상도를 줄이고 여분의 공간을 사용하여 강도 해상도를 높이는 것입니다. 그 결과 16 개의 회색 음영 (각각 4 개의 샘플이있는 4 개의 회색 서브 큐브), 각 1 차 및 2 차 색상의 13 개의 음영 (4 개의 샘플 + 검정이있는 3 개의 서브 큐브) 및 나머지 색상 큐브를 덮는 합리적인 색상 선택이 가능합니다. 연속 톤을 더 잘 표현할 수 있다는 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d8a06b24fa70984798bf322daaec557c2b6f1b4" translate="yes" xml:space="preserve">
          <source>Playable Examples must be in a package whose name ends in &quot;_test&quot;. An Example is &quot;playable&quot; (the Play field is non-nil) in either of these circumstances:</source>
          <target state="translated">재생 가능한 예제는 이름이 &quot;_test&quot;로 끝나는 패키지에 있어야합니다. 다음 상황 중 하나에 대한 예는 &quot;재생 가능&quot;(재생 필드는 0이 아님)입니다.</target>
        </trans-unit>
        <trans-unit id="2c6beabd4a6c27d664359314bb0b7be1a4bee461" translate="yes" xml:space="preserve">
          <source>Plugin is a loaded Go plugin.</source>
          <target state="translated">플러그인은로드 된 Go 플러그인입니다.</target>
        </trans-unit>
        <trans-unit id="7e76b66514ee8b4bc312a760611a574aac64892b" translate="yes" xml:space="preserve">
          <source>PlusBuildLines returns a sequence of &amp;ldquo;// +build&amp;rdquo; lines that evaluate to the build expression x. If the expression is too complex to convert directly to &amp;ldquo;// +build&amp;rdquo; lines, PlusBuildLines returns an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79d975c909286257ed2dc841463cf2221331b8a7" translate="yes" xml:space="preserve">
          <source>Pointer represents a pointer to an arbitrary type. There are four special operations available for type Pointer that are not available for other types:</source>
          <target state="translated">포인터는 임의 유형에 대한 포인터를 나타냅니다. 다른 유형에는 사용할 수없는 포인터 유형에 사용할 수있는 네 가지 특수 작업이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0c031e92d2b285f06539e450cbc88db48ddddac" translate="yes" xml:space="preserve">
          <source>Pointer returns v's value as a uintptr. It returns uintptr instead of unsafe.Pointer so that code using reflect cannot obtain unsafe.Pointers without importing the unsafe package explicitly. It panics if v's Kind is not Chan, Func, Map, Ptr, Slice, or UnsafePointer.</source>
          <target state="translated">포인터는 v의 값을 uintptr로 반환합니다. unsafe.Pointer 대신 uintptr을 리턴하므로 reflect를 사용하는 코드는 unsafe.Pointer를 안전하지 않은 패키지를 명시 적으로 가져 오지 않고 가져올 수 없습니다. v의 종류가 Chan, Func, Map, Ptr, Slice 또는 UnsafePointer가 아닌 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="baef0ef34fa58ab846963eb42f08d22cc0916958" translate="yes" xml:space="preserve">
          <source>Pointer therefore allows a program to defeat the type system and read and write arbitrary memory. It should be used with extreme care.</source>
          <target state="translated">따라서 포인터는 프로그램이 형식 시스템을 무시하고 임의의 메모리를 읽고 쓸 수 있도록합니다. 매우주의해서 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="c228a838e9e7815109b6016259a9375cc32a3ee5" translate="yes" xml:space="preserve">
          <source>Pointer values are deeply equal if they are equal using Go's == operator or if they point to deeply equal values.</source>
          <target state="translated">Go의 == 연산자를 사용하여 포인터 값이 같거나 값이 매우 같으면 포인터 값이 매우 같습니다.</target>
        </trans-unit>
        <trans-unit id="ab46185459d2a7d78c59879c795ee53dd26dd358" translate="yes" xml:space="preserve">
          <source>Pointer values encode as the value pointed to. A nil pointer encodes as the null JSON value.</source>
          <target state="translated">포인터 값은 지정된 값으로 인코딩됩니다. nil 포인터는 null JSON 값으로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="d2cde07b059e3c084c9da753efae9fdd148fa375" translate="yes" xml:space="preserve">
          <source>Pointer:</source>
          <target state="translated">Pointer:</target>
        </trans-unit>
        <trans-unit id="b64fba6378c386a82e71d5a623e279c432da4e08" translate="yes" xml:space="preserve">
          <source>Polar</source>
          <target state="translated">Polar</target>
        </trans-unit>
        <trans-unit id="a5fb429c2bb667a352c2046e02293fc421f8310b" translate="yes" xml:space="preserve">
          <source>Polar returns the absolute value r and phase &amp;theta; of x, such that x = r * e**&amp;theta;i. The phase is in the range [-Pi, Pi].</source>
          <target state="translated">극좌표는 x = r * e ** &amp;theta;i가되도록 절대 값 r과 x의 위상 &amp;theta;를 반환합니다. 위상은 [-Pi, Pi] 범위에 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e6bda38a58104dfd742e2b251475f4fc7ad35e0" translate="yes" xml:space="preserve">
          <source>Polynomials are represented in LSB-first form also known as reversed representation.</source>
          <target state="translated">다항식은 역 표현으로도 알려진 LSB- 첫 번째 형식으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="778627418cb4b30cdfe47281afdbf30f1a173700" translate="yes" xml:space="preserve">
          <source>Pool</source>
          <target state="translated">Pool</target>
        </trans-unit>
        <trans-unit id="62976d6c6dce665baf19823706626b87a619028b" translate="yes" xml:space="preserve">
          <source>Pool's purpose is to cache allocated but unused items for later reuse, relieving pressure on the garbage collector. That is, it makes it easy to build efficient, thread-safe free lists. However, it is not suitable for all free lists.</source>
          <target state="translated">풀의 목적은 나중에 재사용하기 위해 할당되었지만 사용하지 않는 항목을 캐시하여 가비지 수집기의 압력을 완화하는 것입니다. 즉, 효율적이고 스레드로부터 안전한 목록을 쉽게 작성할 수 있습니다. 그러나 모든 무료 목록에 적합하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="a894961424546348d9d455a430167c6470d0b453" translate="yes" xml:space="preserve">
          <source>Pop removes and returns the minimum element (according to Less) from the heap. The complexity is O(log n) where n = h.Len(). Pop is equivalent to Remove(h, 0).</source>
          <target state="translated">Pop은 힙에서 최소 요소 (적어짐에 따라)를 제거하고 반환합니다. 복잡도는 O (log n)이며 여기서 n = h.Len ()입니다. 팝은 제거 (h, 0)와 같습니다.</target>
        </trans-unit>
        <trans-unit id="1c331ce3bd04c4d21d66fc2ae1a5de46dd73eec8" translate="yes" xml:space="preserve">
          <source>Port returns the port part of u.Host, without the leading colon.</source>
          <target state="translated">포트는 선행 콜론없이 u.Host의 포트 부분을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="42cb37e41618d46d1d0e8d0bf5e059552b858cb3" translate="yes" xml:space="preserve">
          <source>Portable analogs of some common system call errors.</source>
          <target state="translated">일반적인 시스템 호출 오류의 휴대용 아날로그.</target>
        </trans-unit>
        <trans-unit id="97e4fd0d08cb7c58f4698b53bcfb9441c857ebec" translate="yes" xml:space="preserve">
          <source>Pos and End describe the scope's source code extent [pos, end). The results are guaranteed to be valid only if the type-checked AST has complete position information. The extent is undefined for Universe and package scopes.</source>
          <target state="translated">Pos 및 End는 스코프의 소스 ​​코드 범위 [pos, end)를 설명합니다. 형식 확인 AST에 전체 위치 정보가있는 경우에만 결과가 유효합니다. 유니버스 및 패키지 범위에 대해서는 범위가 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4c60ba97a8cb410a549bfe181eeaa63408b55cba" translate="yes" xml:space="preserve">
          <source>Pos computes the source position of the declaration of an object name. The result may be an invalid position if it cannot be computed (obj.Decl may be nil or not correct).</source>
          <target state="translated">Pos는 객체 이름 선언의 소스 위치를 계산합니다. 계산할 수없는 경우 결과가 유효하지 않을 수 있습니다 (obj.Decl이 nil이거나 올바르지 않을 수 있음).</target>
        </trans-unit>
        <trans-unit id="a0ec3702b899c2917ee8242be4cbe0bff05b9658" translate="yes" xml:space="preserve">
          <source>Pos is a compact encoding of a source position within a file set. It can be converted into a Position for a more convenient, but much larger, representation.</source>
          <target state="translated">Pos는 파일 세트 내에서 소스 위치의 컴팩트 인코딩입니다. 보다 편리하지만 훨씬 더 큰 표현을 위해 위치로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b9fa7b2eba24dae9008da03956b9fa4fe5bac8a" translate="yes" xml:space="preserve">
          <source>Pos represents a byte position in the original input text from which this template was parsed.</source>
          <target state="translated">Pos는이 템플리트가 구문 분석 된 원래 입력 텍스트의 바이트 위치를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="edf92f1280756c43fc75532da3d73537cdede740" translate="yes" xml:space="preserve">
          <source>Pos returns the Pos value for the given file offset; the offset must be &amp;lt;= f.Size(). f.Pos(f.Offset(p)) == p.</source>
          <target state="translated">Pos는 주어진 파일 오프셋에 대한 Pos 값을 반환합니다. 오프셋은 &amp;lt;= f.Size () 여야합니다. f. 위치 (f. 오프셋 (p)) == p.</target>
        </trans-unit>
        <trans-unit id="5ff010dde5f69bdb9f99370ef921975c8f9209ff" translate="yes" xml:space="preserve">
          <source>Pos returns the declaration position of the object's identifier.</source>
          <target state="translated">Pos는 객체 식별자의 선언 위치를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cd367287d957f8b0726b9d88a222f0d52b30fd66" translate="yes" xml:space="preserve">
          <source>Pos returns the position of the character immediately after the character or token returned by the last call to Next or Scan. Use the Scanner's Position field for the start position of the most recently scanned token.</source>
          <target state="translated">Pos는 다음 또는 스캔에 대한 마지막 호출에서 리턴 된 문자 또는 토큰 바로 다음에 문자의 위치를 ​​리턴합니다. 가장 최근에 스캔 한 토큰의 시작 위치에 스캐너 위치 필드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e31be0876f71b9f08f689f98e0ab92c2ffe225b9" translate="yes" xml:space="preserve">
          <source>Pos values can be compared directly with the usual comparison operators: If two Pos values p and q are in the same file, comparing p and q is equivalent to comparing the respective source file offsets. If p and q are in different files, p &amp;lt; q is true if the file implied by p was added to the respective file set before the file implied by q.</source>
          <target state="translated">Pos 값은 일반적인 비교 연산자와 직접 비교할 수 있습니다. 두 Pos 값 p와 q가 동일한 파일에 있으면 p와 q를 비교하는 것은 각 소스 파일 오프셋을 비교하는 것과 같습니다. p와 q가 서로 다른 파일에있는 경우, p가 암시하는 파일이 q가 암시하는 파일 전에 각 파일 세트에 추가 된 경우 p &amp;lt;q는 true입니다.</target>
        </trans-unit>
        <trans-unit id="5fc2fa994bbd914263ceb34efcf25eb956fe5e38" translate="yes" xml:space="preserve">
          <source>Position converts a Pos p in the fileset into a Position value. Calling s.Position(p) is equivalent to calling s.PositionFor(p, true).</source>
          <target state="translated">위치는 파일 세트의 위치 p를 위치 값으로 변환합니다. s.Position (p) 호출은 s.PositionFor (p, true) 호출과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="b93209a85028bf6019382a8729f55ac8145e29b1" translate="yes" xml:space="preserve">
          <source>Position describes an arbitrary source position including the file, line, and column location. A Position is valid if the line number is &amp;gt; 0.</source>
          <target state="translated">위치는 파일, 행 및 열 위치를 포함한 임의의 소스 위치를 나타냅니다. 행 번호가 0보다 크면 위치가 유효합니다.</target>
        </trans-unit>
        <trans-unit id="d1086db7e34e995911902270435427be7e528699" translate="yes" xml:space="preserve">
          <source>Position returns the Position value for the given file position p. Calling f.Position(p) is equivalent to calling f.PositionFor(p, true).</source>
          <target state="translated">위치는 주어진 파일 위치 p에 대한 위치 값을 반환합니다. f.Position (p) 호출은 f.PositionFor (p, true) 호출과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9bee67f02828c19ef6ab2c5867d78daacd16a5b6" translate="yes" xml:space="preserve">
          <source>PositionFor converts a Pos p in the fileset into a Position value. If adjusted is set, the position may be adjusted by position-altering //line comments; otherwise those comments are ignored. p must be a Pos value in s or NoPos.</source>
          <target state="translated">PositionFor는 파일 세트의 Pos p를 위치 값으로 변환합니다. 조정이 설정되면 위치 변경 // 줄 설명;을 통해 위치를 조정할 수 있습니다. 그렇지 않으면 해당 주석은 무시됩니다. p는 s 또는 NoPos의 Pos 값이어야합니다.</target>
        </trans-unit>
        <trans-unit id="3d4ffd5f491d5a7cdece709329d95542f519d748" translate="yes" xml:space="preserve">
          <source>PositionFor returns the Position value for the given file position p. If adjusted is set, the position may be adjusted by position-altering //line comments; otherwise those comments are ignored. p must be a Pos value in f or NoPos.</source>
          <target state="translated">PositionFor는 주어진 파일 위치 p에 대한 위치 값을 반환합니다. 조정이 설정되면 위치 변경 // 줄 설명;을 통해 위치를 조정할 수 있습니다. 그렇지 않으면 해당 주석은 무시됩니다. p는 f 또는 NoPos의 Pos 값이어야합니다.</target>
        </trans-unit>
        <trans-unit id="9ac52c588d2d22788d46da883fda78a4165f3071" translate="yes" xml:space="preserve">
          <source>Possible values for the EncryptPEMBlock encryption algorithm.</source>
          <target state="translated">EncryptPEMBlock 암호화 알고리즘에 가능한 값입니다.</target>
        </trans-unit>
        <trans-unit id="e039b08aed18ef386a63d77f040148c0406ea827" translate="yes" xml:space="preserve">
          <source>Post is a wrapper around DefaultClient.Post.</source>
          <target state="translated">Post는 DefaultClient.Post 주위의 래퍼입니다.</target>
        </trans-unit>
        <trans-unit id="4ccc94f360bffe8b14b21c70371bc08f8fc85aba" translate="yes" xml:space="preserve">
          <source>Post issues a POST to the specified URL.</source>
          <target state="translated">Post는 지정된 URL에 POST를 발행합니다.</target>
        </trans-unit>
        <trans-unit id="cf67d20c1f3d564f229d45c7bbe51d8dd1d5c4f9" translate="yes" xml:space="preserve">
          <source>PostForm is a wrapper around DefaultClient.PostForm.</source>
          <target state="translated">PostForm은 DefaultClient.PostForm을 감싸는 래퍼입니다.</target>
        </trans-unit>
        <trans-unit id="44be7db278a3bb23e34b6df9cf0308f04a22ef65" translate="yes" xml:space="preserve">
          <source>PostForm issues a POST to the specified URL, with data's keys and values URL-encoded as the request body.</source>
          <target state="translated">PostForm은 데이터의 키와 값을 요청 본문으로 URL 인코딩하여 지정된 URL에 POST를 발행합니다.</target>
        </trans-unit>
        <trans-unit id="be4e82ca926447e7fa579fe9a0de6822470bae52" translate="yes" xml:space="preserve">
          <source>PostFormValue returns the first value for the named component of the POST, PATCH, or PUT request body. URL query parameters are ignored. PostFormValue calls ParseMultipartForm and ParseForm if necessary and ignores any errors returned by these functions. If key is not present, PostFormValue returns the empty string.</source>
          <target state="translated">PostFormValue는 POST, PATCH 또는 PUT 요청 본문의 명명 된 구성 요소에 대한 첫 번째 값을 반환합니다. URL 쿼리 매개 변수는 무시됩니다. PostFormValue는 필요한 경우 ParseMultipartForm 및 ParseForm을 호출하고 이러한 함수에서 반환 된 오류를 무시합니다. 키가 없으면 PostFormValue는 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="be28cb761efe315e0e552f0578874dbad93fb2dd" translate="yes" xml:space="preserve">
          <source>Pow</source>
          <target state="translated">Pow</target>
        </trans-unit>
        <trans-unit id="f475da806450b4216a6a39ef8f751e26584a0aa3" translate="yes" xml:space="preserve">
          <source>Pow returns x**y, the base-x exponential of y.</source>
          <target state="translated">Pow는 y의 기본 x 지수 인 x ** y를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6d31ee5908c32da0243ccfa92f5fe1c7b3e3aeaf" translate="yes" xml:space="preserve">
          <source>Pow returns x**y, the base-x exponential of y. For generalized compatibility with math.Pow:</source>
          <target state="translated">Pow는 y의 기본 x 지수 인 x ** y를 반환합니다. math.Pow와의 일반적인 호환성 :</target>
        </trans-unit>
        <trans-unit id="f348c46b140ea99d08517640a0cfa8eff3f40986" translate="yes" xml:space="preserve">
          <source>Pow10</source>
          <target state="translated">Pow10</target>
        </trans-unit>
        <trans-unit id="aee903bac5380775ed6f4d539640fd38f8839815" translate="yes" xml:space="preserve">
          <source>Pow10 returns 10**n, the base-10 exponential of n.</source>
          <target state="translated">Pow10은 기본 10 지수 n의 10 ** n을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5411be6b25a0cd127e0815f04ee1c12c71a3cf9d" translate="yes" xml:space="preserve">
          <source>Prec returns the mantissa precision of x in bits. The result may be 0 for |x| == 0 and |x| == Inf.</source>
          <target state="translated">Prec는 x의 가수 정밀도를 비트 단위로 반환합니다. | x |의 경우 결과는 0 일 수 있습니다. == 0 및 | x | == Inf.</target>
        </trans-unit>
        <trans-unit id="012c1f9cb43bafa38c87d810c24d42b2a0e95129" translate="yes" xml:space="preserve">
          <source>Precedence returns the operator precedence of the binary operator op. If op is not a binary operator, the result is LowestPrecedence.</source>
          <target state="translated">우선 순위는 2 진 연산자 op의 연산자 우선 순위를 리턴합니다. op가 이항 연산자가 아닌 경우 결과는 LowestPrecedence입니다.</target>
        </trans-unit>
        <trans-unit id="06b7f0534bb083dff059cb7b1d374b3c3f1e0a29" translate="yes" xml:space="preserve">
          <source>Precompute performs some calculations that speed up private key operations in the future.</source>
          <target state="translated">사전 계산은 향후 개인 키 작업 속도를 높이는 일부 계산을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="34240aca8e0c8b909225cdb2f4dfdd60a5391649" translate="yes" xml:space="preserve">
          <source>Precondition: the Uses and Defs maps are populated.</source>
          <target state="translated">전제 조건 : Uses 및 Defs 맵이 채워집니다.</target>
        </trans-unit>
        <trans-unit id="7070c5f6250bbd470fe7f73bafbee45d2955ddb3" translate="yes" xml:space="preserve">
          <source>Predefined global functions are named as follows.</source>
          <target state="translated">미리 정의 된 전역 함수의 이름은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e21e54618fe5bb45663e64ef56fb6717d24f3e6f" translate="yes" xml:space="preserve">
          <source>Predefined layouts ANSIC, UnixDate, RFC3339 and others describe standard and convenient representations of the reference time. For more information about the formats and the definition of the reference time, see the documentation for ANSIC and the other constants defined by this package.</source>
          <target state="translated">미리 정의 된 레이아웃 ANSIC, UnixDate, RFC3339 및 기타는 표준 시간 및 참조 시간의 편리한 표현을 설명합니다. 참조 시간의 형식과 정의에 대한 자세한 내용은 ANSIC 설명서 및이 패키지에서 정의한 기타 상수를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="19d40016f56bfc80ec50dda03a3f66d54afe65d3" translate="yes" xml:space="preserve">
          <source>Predefined layouts ANSIC, UnixDate, RFC3339 and others describe standard and convenient representations of the reference time. For more information about the formats and the definition of the reference time, see the documentation for ANSIC and the other constants defined by this package. Also, the executable example for Time.Format demonstrates the working of the layout string in detail and is a good reference.</source>
          <target state="translated">미리 정의 된 레이아웃 ANSIC, UnixDate, RFC3339 및 기타는 표준 시간 및 참조 시간의 편리한 표현을 설명합니다. 참조 시간의 형식과 정의에 대한 자세한 내용은 ANSIC 설명서 및이 패키지에서 정의한 기타 상수를 참조하십시오. 또한 Time.Format의 실행 예제는 레이아웃 문자열의 작동을 자세하게 보여 주며 좋은 참조입니다.</target>
        </trans-unit>
        <trans-unit id="019d3598b39c078722d988d313bff8da4d9cf574" translate="yes" xml:space="preserve">
          <source>Predefined mode bits to control recognition of tokens. For instance, to configure a Scanner such that it only recognizes (Go) identifiers, integers, and skips comments, set the Scanner's Mode field to:</source>
          <target state="translated">토큰 인식을 제어하기위한 사전 정의 된 모드 비트. 예를 들어 식별자, 정수만 인식하고 주석을 건너 뛰도록 검사기를 구성하려면 검사기 모드 필드를 다음과 같이 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="0eea29821ab0f93a1960c9475350fbefcdab3d2f" translate="yes" xml:space="preserve">
          <source>Predefined polynomials.</source>
          <target state="translated">미리 정의 된 다항식.</target>
        </trans-unit>
        <trans-unit id="0d4a9c1b8dc6a14ced81402c9c52d4cba69192f5" translate="yes" xml:space="preserve">
          <source>Prefix returns a literal string that all matches for the regexp must start with. Complete is true if the prefix is the entire match.</source>
          <target state="translated">접두사는 정규 표현식과 일치하는 모든 문자로 시작해야하는 리터럴 문자열을 리턴합니다. 접두사가 전체 일치 인 경우 완료입니다.</target>
        </trans-unit>
        <trans-unit id="07aedbb616a135989fac4d8d72b5c4a5c5d60c82" translate="yes" xml:space="preserve">
          <source>Prefix returns the output prefix for the logger.</source>
          <target state="translated">접두사는 로거의 출력 접 두부를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="d115a4bd5d23f67905e010343d63485a225c3e87" translate="yes" xml:space="preserve">
          <source>Prefix returns the output prefix for the standard logger.</source>
          <target state="translated">접두사는 표준 로거의 출력 접 두부를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="8a0ad1efe973aa121d35889249f93a7d412bb0f0" translate="yes" xml:space="preserve">
          <source>Prepare creates a prepared statement for later queries or executions. Multiple queries or executions may be run concurrently from the returned statement. The caller must call the statement's Close method when the statement is no longer needed.</source>
          <target state="translated">준비는 이후 쿼리 또는 실행을 위해 준비된 문을 만듭니다. 리턴 된 명령문에서 여러 쿼리 또는 실행이 동시에 실행될 수 있습니다. 명령문이 더 이상 필요하지 않으면 호출자는 명령문의 Close 메소드를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="a2f69751c5da712872417f2a510b17bd5264a134" translate="yes" xml:space="preserve">
          <source>Prepare creates a prepared statement for use within a transaction.</source>
          <target state="translated">준비는 트랜잭션 내에서 사용할 준비된 명령문을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="19c3c9a0f98a28102c0e736d9c3bf4d64087898f" translate="yes" xml:space="preserve">
          <source>PrepareContext creates a prepared statement for later queries or executions. Multiple queries or executions may be run concurrently from the returned statement. The caller must call the statement's Close method when the statement is no longer needed.</source>
          <target state="translated">PrepareContext는 이후 쿼리 나 실행을 위해 준비된 명령문을 작성합니다. 리턴 된 명령문에서 여러 쿼리 또는 실행이 동시에 실행될 수 있습니다. 명령문이 더 이상 필요하지 않으면 호출자는 명령문의 Close 메소드를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="a6597b9664b9651bf9f54fe07c6db1a86396a5f0" translate="yes" xml:space="preserve">
          <source>PrepareContext creates a prepared statement for use within a transaction.</source>
          <target state="translated">PrepareContext는 트랜잭션 내에서 사용할 준비된 명령문을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="152856201f7dfb04864788231e3dca46c0bc77c0" translate="yes" xml:space="preserve">
          <source>Prev returns the previous list element or nil.</source>
          <target state="translated">이전은 이전 목록 요소 또는 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c4d145ba4ec6ded69ec8461fe1ea7b2b7ec58ca2" translate="yes" xml:space="preserve">
          <source>Prev returns the previous ring element. r must not be empty.</source>
          <target state="translated">이전은 이전 링 요소를 반환합니다. r은 비워 둘 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="88971ab7b2fead8d5aa7c50c15f575453db641e4" translate="yes" xml:space="preserve">
          <source>Prime returns a number, p, of the given size, such that p is prime with high probability. Prime will return error for any error returned by rand.Read or if bits &amp;lt; 2.</source>
          <target state="translated">소수는 주어진 크기의 숫자 p를 반환하므로 p는 확률이 높은 소수입니다. 프라임은 rand.Read 또는 비트 &amp;lt;2 인 경우 반환 된 오류에 대해 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5b221e9c2a451799d8f37e2b9874409d5e03ab05" translate="yes" xml:space="preserve">
          <source>Print</source>
          <target state="translated">Print</target>
        </trans-unit>
        <trans-unit id="f10e9ffa0b7bfc2f4378fe30b103cef0c696cbab" translate="yes" xml:space="preserve">
          <source>Print calls Output to print to the standard logger. Arguments are handled in the manner of fmt.Print.</source>
          <target state="translated">인쇄는 표준 로거로 인쇄하기 위해 출력을 호출합니다. 인수는 fmt.Print 방식으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="da7a32afaab2e92c2ad95514fe5016080d044d92" translate="yes" xml:space="preserve">
          <source>Print calls l.Output to print to the logger. Arguments are handled in the manner of fmt.Print.</source>
          <target state="translated">인쇄 호출 l. 로거로 인쇄하기위한 출력. 인수는 fmt.Print 방식으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="ef0199bdcf8fc8fa33bd7d6ab92875f9706a01bd" translate="yes" xml:space="preserve">
          <source>Print formats using the default formats for its operands and writes to standard output. Spaces are added between operands when neither is a string. It returns the number of bytes written and any write error encountered.</source>
          <target state="translated">피연산자의 기본 형식을 사용하여 형식을 인쇄하고 표준 출력에 씁니다. 문자열이 아닌 경우 피연산자 사이에 공백이 추가됩니다. 쓴 바이트 수와 발생한 쓰기 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5d837aa33f1404ff26202e67efb03427b1d31566" translate="yes" xml:space="preserve">
          <source>Print prints x to standard output, skipping nil fields. Print(fset, x) is the same as Fprint(os.Stdout, fset, x, NotNilFilter).</source>
          <target state="translated">인쇄는 nil 필드를 건너 뛰고 x를 표준 출력으로 인쇄합니다. 인쇄 (fset, x)는 Fprint (os.Stdout, fset, x, NotNilFilter)와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="fff8914dcd8a6ac6b5cf34d89aeea00386da1b24" translate="yes" xml:space="preserve">
          <source>Print, Println, and Printf lay out their arguments differently. In this example we can compare their behaviors. Println always adds blanks between the items it prints, while Print adds blanks only between non-string arguments and Printf does exactly what it is told. Sprint, Sprintln, Sprintf, Fprint, Fprintln, and Fprintf behave the same as their corresponding Print, Println, and Printf functions shown here.</source>
          <target state="translated">Print, Println 및 Printf는 서로 다른 주장을 제시합니다. 이 예에서는 동작을 비교할 수 있습니다. Println은 항상 인쇄하는 항목 사이에 공백을 추가하는 반면 Print는 문자열이 아닌 인수 사이에만 공백을 추가하고 Printf는 정확히 알려줍니다. Sprint, Sprintln, Sprintf, Fprint, Fprintln 및 Fprintf는 여기에 표시된 해당 Print, Println 및 Printf 기능과 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="809bcd004fc9b80aebb7cc5d33f0d171da74d5a1" translate="yes" xml:space="preserve">
          <source>PrintDefaults prints, to standard error unless configured otherwise, a usage message showing the default settings of all defined command-line flags. For an integer valued flag x, the default output has the form</source>
          <target state="translated">PrintDefaults는 달리 정의되지 않은 경우 정의 된 모든 명령 줄 플래그의 기본 설정을 보여주는 사용 메시지를 표준 오류로 인쇄합니다. 정수 값 플래그 x의 경우 기본 출력 형식은</target>
        </trans-unit>
        <trans-unit id="66f194d8340d19b81ae4cbbaf04b180769f0bc50" translate="yes" xml:space="preserve">
          <source>PrintDefaults prints, to standard error unless configured otherwise, the default values of all defined command-line flags in the set. See the documentation for the global function PrintDefaults for more information.</source>
          <target state="translated">PrintDefaults는 달리 구성하지 않는 한 세트에 정의 된 모든 명령 행 플래그의 기본값을 표준 오류로 인쇄합니다. 자세한 내용은 전역 함수 PrintDefaults 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0413304ebeab6806f19cc2877f7f0a8ff6c54cbc" translate="yes" xml:space="preserve">
          <source>PrintError is a utility function that prints a list of errors to w, one error per line, if the err parameter is an ErrorList. Otherwise it prints the err string.</source>
          <target state="translated">PrintError는 err 매개 변수가 ErrorList 인 경우 오류 목록을 한 줄에 하나씩 w에 인쇄하는 유틸리티 함수입니다. 그렇지 않으면 오류 문자열을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="ebb2a34b39577c89ac6bbac4cad20176461fcd0b" translate="yes" xml:space="preserve">
          <source>PrintRanges defines the set of printable characters according to Go. ASCII space, U+0020, is handled separately.</source>
          <target state="translated">PrintRanges는 Go에 따라 인쇄 가능한 문자 세트를 정의합니다. ASCII 공간 U + 0020은 별도로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="e979fdd38cfa18a2850ab6725519f82f13a4893f" translate="yes" xml:space="preserve">
          <source>PrintStack prints to standard error the stack trace returned by runtime.Stack.</source>
          <target state="translated">PrintStack은 runtime.Stack에 의해 리턴 된 스택 추적을 표준 오류로 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="49c6710eb43a270c0d99f60d369594f6b1f09d42" translate="yes" xml:space="preserve">
          <source>Printf</source>
          <target state="translated">Printf</target>
        </trans-unit>
        <trans-unit id="d092eac8d8c7315f01318a4675b38dcda90f6b2f" translate="yes" xml:space="preserve">
          <source>Printf calls Output to print to the standard logger. Arguments are handled in the manner of fmt.Printf.</source>
          <target state="translated">Printf는 출력을 호출하여 표준 로거로 인쇄합니다. 인수는 fmt.Printf 방식으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="d34579b37294eb8c93cd5f76572f924816678d0e" translate="yes" xml:space="preserve">
          <source>Printf calls l.Output to print to the logger. Arguments are handled in the manner of fmt.Printf.</source>
          <target state="translated">Printf는 로거에 인쇄하기 위해 l.Output을 호출합니다. 인수는 fmt.Printf 방식으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="e063c30289e6b7981e882f4697ef852c1f482795" translate="yes" xml:space="preserve">
          <source>Printf formats according to a format specifier and writes to standard output. It returns the number of bytes written and any write error encountered.</source>
          <target state="translated">형식 지정자에 따라 형식을 인쇄하고 표준 출력에 씁니다. 쓴 바이트 수와 발생한 쓰기 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="28fa9c40e9ffd74bb5b4f094116329456de9f692" translate="yes" xml:space="preserve">
          <source>PrintfLine writes the formatted output followed by \r\n.</source>
          <target state="translated">PrintfLine은 형식화 된 출력 뒤에 \ r \ n을 씁니다.</target>
        </trans-unit>
        <trans-unit id="f16eadab2a72ff13044cc806dbcf2c117b32244f" translate="yes" xml:space="preserve">
          <source>Printing</source>
          <target state="translated">Printing</target>
        </trans-unit>
        <trans-unit id="9be957a1debff697aafdc7801a3e8785262f0c15" translate="yes" xml:space="preserve">
          <source>Println</source>
          <target state="translated">Println</target>
        </trans-unit>
        <trans-unit id="29f11f56c6deffe1a15f67edc9a4aa4f5e39f28b" translate="yes" xml:space="preserve">
          <source>Println calls Output to print to the standard logger. Arguments are handled in the manner of fmt.Println.</source>
          <target state="translated">Println은 출력을 호출하여 표준 로거로 인쇄합니다. 인수는 fmt.Println 방식으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="cddfe7aeafd7792bfbbf9d5f8715705f967fa901" translate="yes" xml:space="preserve">
          <source>Println calls l.Output to print to the logger. Arguments are handled in the manner of fmt.Println.</source>
          <target state="translated">Println은 l.Output을 호출하여 로거에 인쇄합니다. 인수는 fmt.Println 방식으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="811e4464a94616bb8d26e71f2e575488ec162b1d" translate="yes" xml:space="preserve">
          <source>Println formats using the default formats for its operands and writes to standard output. Spaces are always added between operands and a newline is appended. It returns the number of bytes written and any write error encountered.</source>
          <target state="translated">피연산자에 대한 기본 형식을 사용하여 Println 형식을 지정하고 표준 출력에 씁니다. 피연산자 사이에 공백이 항상 추가되고 줄 바꾸기가 추가됩니다. 쓴 바이트 수와 발생한 쓰기 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ca8881cd0811d2e92d6c86ae2702d8e81b20152f" translate="yes" xml:space="preserve">
          <source>PrivateKey is the type of Ed25519 private keys. It implements crypto.Signer.</source>
          <target state="translated">PrivateKey는 Ed25519 개인 키의 유형입니다. crypto.Signer를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="0a4394946d56678a7614480ff518a3bad620dfd6" translate="yes" xml:space="preserve">
          <source>PrivateKey represents a DSA private key.</source>
          <target state="translated">PrivateKey는 DSA 개인 키를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5828291a45f65d96ddf669061359c25c2c15c6d0" translate="yes" xml:space="preserve">
          <source>PrivateKey represents a private key using an unspecified algorithm.</source>
          <target state="translated">PrivateKey는 지정되지 않은 알고리즘을 사용하여 개인 키를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6a98b6c2702640d21b9c48b8d270c3e30325339a" translate="yes" xml:space="preserve">
          <source>PrivateKey represents an ECDSA private key.</source>
          <target state="translated">PrivateKey는 ECDSA 개인 키를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5d801231cb01d152413f0eb3fd1b96b8b8b32f86" translate="yes" xml:space="preserve">
          <source>ProbablyPrime is 100% accurate for inputs less than 2⁶⁴. See Menezes et al., Handbook of Applied Cryptography, 1997, pp. 145-149, and FIPS 186-4 Appendix F for further discussion of the error probabilities.</source>
          <target state="translated">아마도 Prime은 2⁶⁴ 미만의 입력에 대해 100 % 정확합니다. 오류 확률에 대한 자세한 내용은 Menezes 등, Applied Cryptography Handbook, 1997, 145-149 및 FIPS 186-4 부록 F를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="442fffca41b5ff8be9e7d3c5a0d5bb3bcdd79c79" translate="yes" xml:space="preserve">
          <source>ProbablyPrime is not suitable for judging primes that an adversary may have crafted to fool the test.</source>
          <target state="translated">아마도 Prime은 공격자가 시험을 속이려고 만든 프라임을 판단하는 데 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c5acf5649dd4748b450f268e217b8fc03d7e5d83" translate="yes" xml:space="preserve">
          <source>ProbablyPrime reports whether x is probably prime, applying the Miller-Rabin test with n pseudorandomly chosen bases as well as a Baillie-PSW test.</source>
          <target state="translated">ProbablyPrime은 x가 아마도 소수인지를보고, 무작위로 선택된 n 개의 염기와 Baillie-PSW 테스트로 Miller-Rabin 테스트를 적용합니다.</target>
        </trans-unit>
        <trans-unit id="f565348ea6c07ff9cfffba23f4ddef524854d6c5" translate="yes" xml:space="preserve">
          <source>ProcAttr holds attributes that will be applied to a new process started by StartProcess.</source>
          <target state="translated">ProcAttr에는 StartProcess에 의해 시작된 새 프로세스에 적용되는 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e12810a35fd4b52423e92a433b314e79f5156c70" translate="yes" xml:space="preserve">
          <source>ProcAttr holds the attributes that will be applied to a new process started by StartProcess.</source>
          <target state="translated">ProcAttr은 StartProcess에 의해 시작된 새 프로세스에 적용될 속성을 보유합니다.</target>
        </trans-unit>
        <trans-unit id="5373df2ffeb91866eef2c38e2502d77f1e33d970" translate="yes" xml:space="preserve">
          <source>Process stores the information about a process created by StartProcess.</source>
          <target state="translated">Process는 StartProcess에 의해 생성 된 프로세스에 대한 정보를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="7be9488d8073639c8b5c8f975d63715a76c9482d" translate="yes" xml:space="preserve">
          <source>ProcessEnv returns FastCGI environment variables associated with the request r for which no effort was made to be included in the request itself - the data is hidden in the request's context. As an example, if REMOTE_USER is set for a request, it will not be found anywhere in r, but it will be included in ProcessEnv's response (via r's context).</source>
          <target state="translated">ProcessEnv는 요청 자체에 포함되지 않은 요청 r과 연관된 FastCGI 환경 변수를 리턴합니다. 데이터는 요청 컨텍스트에 숨겨져 있습니다. 예를 들어, REMOTE_USER가 요청에 대해 설정된 경우 r의 어느 곳에서도 찾을 수 없지만 r의 컨텍스트를 통해 ProcessEnv의 응답에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="9471e4ecfd3d8f84d8e198229a6e563cc60bb5bd" translate="yes" xml:space="preserve">
          <source>ProcessState stores information about a process, as reported by Wait.</source>
          <target state="translated">ProcessState는 Wait에 의해보고 된대로 프로세스에 대한 정보를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="1ccb21389489c4ce498c4e53d4d69158c5c216b7" translate="yes" xml:space="preserve">
          <source>Profile responds with the pprof-formatted cpu profile. Profiling lasts for duration specified in seconds GET parameter, or for 30 seconds if not specified. The package initialization registers it as /debug/pprof/profile.</source>
          <target state="translated">프로파일은 pprof 형식의 CPU 프로파일로 응답합니다. 프로파일 링은 GET 매개 변수 (초)로 지정된 지속 시간 동안, 또는 지정되지 않은 경우 30 초 동안 지속됩니다. 패키지 초기화는 / debug / pprof / profile로 등록합니다.</target>
        </trans-unit>
        <trans-unit id="a111deba4cb386ad7d27a3a5da110f46f90e53f3" translate="yes" xml:space="preserve">
          <source>Profiles are only as good as the kernel support used to generate them. See &lt;a href=&quot;https://golang.org/issue/13841&quot;&gt;https://golang.org/issue/13841&lt;/a&gt; for details about known problems.</source>
          <target state="translated">프로파일은 프로파일을 생성하는 데 사용 된 커널 지원만큼 우수합니다. 알려진 문제점에 대한 자세한 내용은 &lt;a href=&quot;https://golang.org/issue/13841&quot;&gt;https://golang.org/issue/13841&lt;/a&gt; 을 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="f633a064ff1568b947a4aec717cb8ff7b8d5f4c3" translate="yes" xml:space="preserve">
          <source>Profiles can then be visualized with the pprof tool:</source>
          <target state="translated">그런 다음 pprof 도구를 사용하여 프로파일을 시각화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f43cf39e026d58fac3cfa9c9d78bd864d77127ed" translate="yes" xml:space="preserve">
          <source>Profiles returns a slice of all the known profiles, sorted by name.</source>
          <target state="translated">프로파일은 알려진 모든 프로파일의 슬라이스를 이름별로 정렬하여 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e204c80d31036e0e024c0b7ffd8999a887af815c" translate="yes" xml:space="preserve">
          <source>Profiling a Go program</source>
          <target state="translated">Go 프로그램 프로파일 링</target>
        </trans-unit>
        <trans-unit id="cd24f23a82cfebc48d38726d6b4c3ec7db051af8" translate="yes" xml:space="preserve">
          <source>Prog.Flag</source>
          <target state="translated">Prog.Flag</target>
        </trans-unit>
        <trans-unit id="48f3611555518363414a9b1db2fa49f474f76e67" translate="yes" xml:space="preserve">
          <source>Prog.Type</source>
          <target state="translated">Prog.Type</target>
        </trans-unit>
        <trans-unit id="2301ced48f29c8456865c04cd47334c707828d9b" translate="yes" xml:space="preserve">
          <source>Programs that use Contexts should follow these rules to keep interfaces consistent across packages and enable static analysis tools to check context propagation:</source>
          <target state="translated">컨텍스트를 사용하는 프로그램은 다음 규칙을 따라 패키지 간 인터페이스의 일관성을 유지하고 정적 분석 도구가 컨텍스트 전파를 점검 할 수 있도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="3ac27ec45d4018361c7d594bf7eaa91a1292edd0" translate="yes" xml:space="preserve">
          <source>Programs using times should typically store and pass them as values, not pointers. That is, time variables and struct fields should be of type time.Time, not *time.Time.</source>
          <target state="translated">시간을 사용하는 프로그램은 일반적으로 포인터가 아닌 값으로 저장하고 전달해야합니다. 즉, 시간 변수 및 구조체 필드는 * time.Time이 아니라 time.Time 유형이어야합니다.</target>
        </trans-unit>
        <trans-unit id="c9ee0039dcc32da9c4cde1d419e8461ac1dfbdc7" translate="yes" xml:space="preserve">
          <source>Properties is the set of Unicode property tables.</source>
          <target state="translated">속성은 유니 코드 속성 테이블 집합입니다.</target>
        </trans-unit>
        <trans-unit id="8768305a872da3684ae4bda3f68612735ba56c08" translate="yes" xml:space="preserve">
          <source>Properties of basic types.</source>
          <target state="translated">기본 유형의 속성.</target>
        </trans-unit>
        <trans-unit id="8a0d90b2918aadcefa0c95820abf21b6534492f2" translate="yes" xml:space="preserve">
          <source>ProtoAtLeast reports whether the HTTP protocol used in the request is at least major.minor.</source>
          <target state="translated">ProtoAtLeast는 요청에 사용 된 HTTP 프로토콜이 major.minor 이상인지보고합니다.</target>
        </trans-unit>
        <trans-unit id="ff9e390e5de482119dc42236df206efa900791fc" translate="yes" xml:space="preserve">
          <source>ProtoAtLeast reports whether the HTTP protocol used in the response is at least major.minor.</source>
          <target state="translated">ProtoAtLeast는 응답에 사용 된 HTTP 프로토콜이 major.minor 이상인지보고합니다.</target>
        </trans-unit>
        <trans-unit id="5829d5d1675f9485036e8bdae05dd67dac955b66" translate="yes" xml:space="preserve">
          <source>ProtocolError represents an HTTP protocol error.</source>
          <target state="translated">ProtocolError는 HTTP 프로토콜 오류를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c78f3a99754e80287f834beff8dcfd502a6d93a8" translate="yes" xml:space="preserve">
          <source>Provided that T2 is no larger than T1 and that the two share an equivalent memory layout, this conversion allows reinterpreting data of one type as data of another type. An example is the implementation of math.Float64bits:</source>
          <target state="translated">T2가 T1보다 크지 않고 둘이 동등한 메모리 레이아웃을 공유하는 경우이 변환을 통해 한 유형의 데이터를 다른 유형의 데이터로 재 해석 할 수 있습니다. 예는 math.Float64bits의 구현입니다.</target>
        </trans-unit>
        <trans-unit id="2667527e2309cea50315245bf9e96ef013a2321b" translate="yes" xml:space="preserve">
          <source>ProxyFromEnvironment returns the URL of the proxy to use for a given request, as indicated by the environment variables HTTP_PROXY, HTTPS_PROXY and NO_PROXY (or the lowercase versions thereof). HTTPS_PROXY takes precedence over HTTP_PROXY for https requests.</source>
          <target state="translated">ProxyFromEnvironment는 환경 변수 HTTP_PROXY, HTTPS_PROXY 및 NO_PROXY (또는 소문자 버전)로 표시되는 지정된 요청에 사용할 프록시의 URL을 반환합니다. https 요청의 경우 HTTPS_PROXY가 HTTP_PROXY보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="ce1c8acc8d3a18105ad805c3050485bfd7af1196" translate="yes" xml:space="preserve">
          <source>ProxyURL returns a proxy function (for use in a Transport) that always returns the same URL.</source>
          <target state="translated">ProxyURL은 항상 동일한 URL을 반환하는 프록시 함수 (전송에 사용)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="256df6693e9938b002805ef141a169ee9b0517c0" translate="yes" xml:space="preserve">
          <source>Pt is shorthand for Point{X, Y}.</source>
          <target state="translated">Pt는 Point {X, Y}의 줄임말입니다.</target>
        </trans-unit>
        <trans-unit id="72df9c957a8f34680bd544544cf16bd450f7c686" translate="yes" xml:space="preserve">
          <source>PtrTo returns the pointer type with element t. For example, if t represents type Foo, PtrTo(t) represents *Foo.</source>
          <target state="translated">PtrTo는 요소 t와 함께 포인터 유형을 리턴합니다. 예를 들어, t가 Foo 유형을 나타내는 경우 PtrTo (t)는 * Foo를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1b89d49d722a1ef7d3c4ddfb234a1400f1a92cf6" translate="yes" xml:space="preserve">
          <source>Public returns the PublicKey corresponding to priv.</source>
          <target state="translated">Public은 priv에 해당하는 PublicKey를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2649f0278f57fd7af2dbdfb64c901b42e9d9789a" translate="yes" xml:space="preserve">
          <source>Public returns the public key corresponding to priv.</source>
          <target state="translated">공개는 개인에 해당하는 공개 키를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0d04adf8945e312c7d47fec2108c21b2684c9af5" translate="yes" xml:space="preserve">
          <source>PublicKey is the type of Ed25519 public keys.</source>
          <target state="translated">PublicKey는 Ed25519 공개 키의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="5001eedc91686ba11ee390e67cd1a676465f5d14" translate="yes" xml:space="preserve">
          <source>PublicKey represents a DSA public key.</source>
          <target state="translated">PublicKey는 DSA 공개 키를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3acd186c84de8cd73322d4669ae9a4bf40b59d13" translate="yes" xml:space="preserve">
          <source>PublicKey represents a public key using an unspecified algorithm.</source>
          <target state="translated">PublicKey는 지정되지 않은 알고리즘을 사용하여 공개 키를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2f28570f8dc7131bd19dca1ee8af4ed1f0eeb1b5" translate="yes" xml:space="preserve">
          <source>PublicKey represents an ECDSA public key.</source>
          <target state="translated">PublicKey는 ECDSA 공개 키를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b2140dd5a5a558ac28d58aa5d36d6a21620f906f" translate="yes" xml:space="preserve">
          <source>PublicSuffixList provides the public suffix of a domain. For example:</source>
          <target state="translated">PublicSuffixList는 도메인의 공개 접미사를 제공합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="edb82c4a8bbcf78c8a1448e29c8d98e501e15f1e" translate="yes" xml:space="preserve">
          <source>Publish declares a named exported variable. This should be called from a package's init function when it creates its Vars. If the name is already registered then this will log.Panic.</source>
          <target state="translated">게시는 명명 된 내 보낸 변수를 선언합니다. 이것은 Var을 생성 할 때 패키지의 init 함수에서 호출되어야합니다. 이름이 이미 등록되어 있으면 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="2bf5378cf82463ae57e7e9a30e9ba5b326dba3d6" translate="yes" xml:space="preserve">
          <source>Push pushes the element x onto the heap. The complexity is O(log n) where n = h.Len().</source>
          <target state="translated">푸시는 요소 x를 힙으로 푸시합니다. 복잡도는 O (log n)이며 여기서 n = h.Len ()입니다.</target>
        </trans-unit>
        <trans-unit id="f4b202999ae2b93ddb6f5cd751aefdf3cb3293cf" translate="yes" xml:space="preserve">
          <source>PushBack inserts a new element e with value v at the back of list l and returns e.</source>
          <target state="translated">푸시 백은리스트 l의 뒤에 값 v를 가진 새로운 요소 e를 삽입하고 e를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="a50f3f664eb834d0bdb9f4d025dcb754c041066d" translate="yes" xml:space="preserve">
          <source>PushBackList inserts a copy of an other list at the back of list l. The lists l and other may be the same. They must not be nil.</source>
          <target state="translated">PushBackList는 목록 l의 뒷면에 다른 목록의 사본을 삽입합니다. 리스트 l 및 기타는 동일 할 수있다. 그들은 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="041686901c1ec554a5144a12f7885b83447ca8ec" translate="yes" xml:space="preserve">
          <source>PushBackList inserts a copy of another list at the back of list l. The lists l and other may be the same. They must not be nil.</source>
          <target state="translated">PushBackList는 목록 l의 뒤에 다른 목록의 사본을 삽입합니다. 목록 l 및 기타는 동일 할 수 있습니다. nil이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="a8c99a25179d82d5afa3406e22b548a0252f1474" translate="yes" xml:space="preserve">
          <source>PushFront inserts a new element e with value v at the front of list l and returns e.</source>
          <target state="translated">PushFront는 목록 l 앞에 v 값을 가진 새로운 요소 e를 삽입하고 e를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="13a7ef38dc8b3d5639e9784f576b7dc8f0a8b795" translate="yes" xml:space="preserve">
          <source>PushFrontList inserts a copy of an other list at the front of list l. The lists l and other may be the same. They must not be nil.</source>
          <target state="translated">PushFrontList는 목록 l 앞에 다른 목록의 사본을 삽입합니다. 리스트 l 및 기타는 동일 할 수있다. 그들은 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="f3e24593e7558d1391736c35c920af73f9fb3935" translate="yes" xml:space="preserve">
          <source>PushFrontList inserts a copy of another list at the front of list l. The lists l and other may be the same. They must not be nil.</source>
          <target state="translated">PushFrontList는 목록 l의 앞에 다른 목록의 복사본을 삽입합니다. 목록 l 및 기타는 동일 할 수 있습니다. nil이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="5520408cb4fcced642940bef6746727866edb323" translate="yes" xml:space="preserve">
          <source>PushOptions describes options for Pusher.Push.</source>
          <target state="translated">PushOptions는 Pusher.Push에 대한 옵션을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="192422b7c0ce1637e319052ddc27aa0f79641ec0" translate="yes" xml:space="preserve">
          <source>Pusher is the interface implemented by ResponseWriters that support HTTP/2 server push. For more background, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7540#section-8.2&quot;&gt;https://tools.ietf.org/html/rfc7540#section-8.2&lt;/a&gt;.</source>
          <target state="translated">Pusher는 HTTP / 2 서버 푸시를 지원하는 ResponseWriter가 구현 한 인터페이스입니다. 자세한 배경은 &lt;a href=&quot;https://tools.ietf.org/html/rfc7540#section-8.2&quot;&gt;https://tools.ietf.org/html/rfc7540#section-8.2를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="5810d2cea2c4c839a1cbc6f93eed06050e059bdc" translate="yes" xml:space="preserve">
          <source>Put adds x to the pool.</source>
          <target state="translated">Put은 풀에 x를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="6b32dae99e29878f191b30318e13ee160e3e9c11" translate="yes" xml:space="preserve">
          <source>PutUvarint</source>
          <target state="translated">PutUvarint</target>
        </trans-unit>
        <trans-unit id="d471216e431bf21e4cd2b9153a740d7d8a93b34a" translate="yes" xml:space="preserve">
          <source>PutUvarint encodes a uint64 into buf and returns the number of bytes written. If the buffer is too small, PutUvarint will panic.</source>
          <target state="translated">PutUvarint는 uint64를 buf로 인코딩하고 쓴 바이트 수를 반환합니다. 버퍼가 너무 작 으면 PutUvarint가 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="88299e1b8aa44f2b22e86375ae77e2d6a8112536" translate="yes" xml:space="preserve">
          <source>PutVarint</source>
          <target state="translated">PutVarint</target>
        </trans-unit>
        <trans-unit id="bd00eee1df8f0b67019e2ad70e9156e5fa1de99c" translate="yes" xml:space="preserve">
          <source>PutVarint encodes an int64 into buf and returns the number of bytes written. If the buffer is too small, PutVarint will panic.</source>
          <target state="translated">PutVarint는 int64를 buf로 인코딩하고 쓴 바이트 수를 반환합니다. 버퍼가 너무 작 으면 PutVarint가 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="95ab58079356ed9aa8893c2df192745f32d71297" translate="yes" xml:space="preserve">
          <source>Quantizer produces a palette for an image.</source>
          <target state="translated">양자화 기는 이미지의 팔레트를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="05437837ec4647b7c23a7c5944b51f3ac43e58c7" translate="yes" xml:space="preserve">
          <source>Query executes a prepared query statement with the given arguments and returns the query results as a *Rows.</source>
          <target state="translated">Query는 주어진 인수로 준비된 쿼리 문을 실행하고 쿼리 결과를 * Rows로 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="d610ca285b8521b4fbaa375322142cf95d05446a" translate="yes" xml:space="preserve">
          <source>Query executes a query that returns rows, typically a SELECT.</source>
          <target state="translated">쿼리는 행 (일반적으로 SELECT)을 반환하는 쿼리를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="e1388b391779ee3280bdae6ba4b75470fb85b182" translate="yes" xml:space="preserve">
          <source>Query executes a query that returns rows, typically a SELECT. The args are for any placeholder parameters in the query.</source>
          <target state="translated">쿼리는 행 (일반적으로 SELECT)을 반환하는 쿼리를 실행합니다. 인수는 쿼리의 자리 표시 자 매개 변수에 대한 것입니다.</target>
        </trans-unit>
        <trans-unit id="73ccd82bfd6eca331cabb2dba278895a7773c1c8" translate="yes" xml:space="preserve">
          <source>Query is expected to be a list of key=value settings separated by ampersands or semicolons. A setting without an equals sign is interpreted as a key set to an empty value.</source>
          <target state="translated">쿼리는 앰퍼샌드 또는 세미콜론으로 구분 된 키 = 값 설정 목록이어야합니다. 등호가없는 설정은 빈 값으로 설정된 키로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="4501151d792df2b730db74682f29db9657ef7ffb" translate="yes" xml:space="preserve">
          <source>Query may return ErrSkip.</source>
          <target state="translated">쿼리가 ErrSkip을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1b497d6ece5d419609d5ec0635dc46c1d21b395" translate="yes" xml:space="preserve">
          <source>Query parses RawQuery and returns the corresponding values. It silently discards malformed value pairs. To check errors use ParseQuery.</source>
          <target state="translated">쿼리는 RawQuery를 구문 분석하고 해당 값을 반환합니다. 잘못된 값 쌍을 자동으로 버립니다. 오류를 확인하려면 ParseQuery를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8a08387889457a5be56952e049ecbbf787ca1008" translate="yes" xml:space="preserve">
          <source>QueryContext executes a prepared query statement with the given arguments and returns the query results as a *Rows.</source>
          <target state="translated">QueryContext는 주어진 인수로 준비된 쿼리 문을 실행하고 쿼리 결과를 * Rows로 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="90f64cb7930640d89ee4991b926e5cee52278a6e" translate="yes" xml:space="preserve">
          <source>QueryContext executes a query that returns rows, typically a SELECT.</source>
          <target state="translated">QueryContext는 행 (일반적으로 SELECT)을 반환하는 쿼리를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="610270ccdd5f9415ac6596bb377b874f11fadbf3" translate="yes" xml:space="preserve">
          <source>QueryContext executes a query that returns rows, typically a SELECT. The args are for any placeholder parameters in the query.</source>
          <target state="translated">QueryContext는 행 (일반적으로 SELECT)을 반환하는 쿼리를 실행합니다. 인수는 쿼리의 자리 표시 자 매개 변수에 대한 것입니다.</target>
        </trans-unit>
        <trans-unit id="7370d9d4f8639b69a2498dbee7578b05f64c38fb" translate="yes" xml:space="preserve">
          <source>QueryEscape escapes the string so it can be safely placed inside a URL query.</source>
          <target state="translated">QueryEscape는 문자열을 이스케이프하여 URL 쿼리 내에 안전하게 배치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ddc8a6f5079b6c63ba14548ae3605122eaf2692" translate="yes" xml:space="preserve">
          <source>QueryRow executes a prepared query statement with the given arguments. If an error occurs during the execution of the statement, that error will be returned by a call to Scan on the returned *Row, which is always non-nil. If the query selects no rows, the *Row's Scan will return ErrNoRows. Otherwise, the *Row's Scan scans the first selected row and discards the rest.</source>
          <target state="translated">QueryRow는 주어진 인수로 준비된 쿼리 문을 실행합니다. 명령문을 실행하는 동안 오류가 발생하면 리턴 된 * Row에서 Scan을 호출하여 해당 오류가 리턴되며 이는 항상 0이 아닙니다. 조회가 행을 선택하지 않으면 * Row의 스캔은 ErrNoRows를 리턴합니다. 그렇지 않으면 * 행 스캔은 선택된 첫 번째 행을 스캔하고 나머지는 버립니다.</target>
        </trans-unit>
        <trans-unit id="0573144afbb38c9c195cafc127ff8c5f7fcc98f1" translate="yes" xml:space="preserve">
          <source>QueryRow executes a query that is expected to return at most one row. QueryRow always returns a non-nil value. Errors are deferred until Row's Scan method is called. If the query selects no rows, the *Row's Scan will return ErrNoRows. Otherwise, the *Row's Scan scans the first selected row and discards the rest.</source>
          <target state="translated">QueryRow는 최대 하나의 행을 반환 할 것으로 예상되는 쿼리를 실행합니다. QueryRow는 항상 0이 아닌 값을 반환합니다. Row의 Scan 메서드가 호출 될 때까지 오류가 지연됩니다. 조회가 행을 선택하지 않으면 * Row의 스캔은 ErrNoRows를 리턴합니다. 그렇지 않으면 * 행 스캔은 선택된 첫 번째 행을 스캔하고 나머지는 버립니다.</target>
        </trans-unit>
        <trans-unit id="5b9f01963f310c9b55f64de5af1de9e922ab703a" translate="yes" xml:space="preserve">
          <source>QueryRowContext executes a prepared query statement with the given arguments. If an error occurs during the execution of the statement, that error will be returned by a call to Scan on the returned *Row, which is always non-nil. If the query selects no rows, the *Row's Scan will return ErrNoRows. Otherwise, the *Row's Scan scans the first selected row and discards the rest.</source>
          <target state="translated">QueryRowContext는 주어진 인수로 준비된 쿼리 문을 실행합니다. 명령문을 실행하는 동안 오류가 발생하면 리턴 된 * Row에서 Scan을 호출하여 해당 오류가 리턴되며 이는 항상 0이 아닙니다. 조회가 행을 선택하지 않으면 * Row의 스캔은 ErrNoRows를 리턴합니다. 그렇지 않으면 * 행 스캔은 선택된 첫 번째 행을 스캔하고 나머지는 버립니다.</target>
        </trans-unit>
        <trans-unit id="297d4c57ac1fe022d65f3f9afe2a0b04f607cea7" translate="yes" xml:space="preserve">
          <source>QueryRowContext executes a query that is expected to return at most one row. QueryRowContext always returns a non-nil value. Errors are deferred until Row's Scan method is called. If the query selects no rows, the *Row's Scan will return ErrNoRows. Otherwise, the *Row's Scan scans the first selected row and discards the rest.</source>
          <target state="translated">QueryRowContext는 최대 하나의 행을 리턴 할 것으로 예상되는 쿼리를 실행합니다. QueryRowContext는 항상 0이 아닌 값을 리턴합니다. Row의 Scan 메서드가 호출 될 때까지 오류가 지연됩니다. 조회가 행을 선택하지 않으면 * Row의 스캔은 ErrNoRows를 리턴합니다. 그렇지 않으면 * 행 스캔은 선택된 첫 번째 행을 스캔하고 나머지는 버립니다.</target>
        </trans-unit>
        <trans-unit id="dcdd15a746401ad098faa59578b02f667ab6f1ed" translate="yes" xml:space="preserve">
          <source>QueryUnescape does the inverse transformation of QueryEscape, converting each 3-byte encoded substring of the form &quot;%AB&quot; into the hex-decoded byte 0xAB. It returns an error if any % is not followed by two hexadecimal digits.</source>
          <target state="translated">QueryUnescape는 QueryEscape의 역변환을 수행하여 &quot;% AB&quot;형식의 각 3 바이트 인코딩 서브 스트링을 16 진 디코딩 된 바이트 0xAB로 변환합니다. % 뒤에 두 개의 16 진수가 없으면 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="02d2728197191f99f0589563ffe142aff0d31057" translate="yes" xml:space="preserve">
          <source>Queryer is an optional interface that may be implemented by a Conn.</source>
          <target state="translated">Queryer는 Conn에 의해 구현 될 수있는 선택적 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="1c47ac983cb47637ae28fbb6e2c18b4b8c42e06e" translate="yes" xml:space="preserve">
          <source>QueryerContext is an optional interface that may be implemented by a Conn.</source>
          <target state="translated">QueryerContext는 Conn에 의해 구현 될 수있는 선택적 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="0013523fcda039d68ac4ad5f69b453c942a978cf" translate="yes" xml:space="preserve">
          <source>QueryerContext may return ErrSkip.</source>
          <target state="translated">QueryerContext는 ErrSkip을 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c63975c9274fd71acb9468b157e86657fe44318f" translate="yes" xml:space="preserve">
          <source>QueryerContext must honor the context timeout and return when the context is canceled.</source>
          <target state="translated">QueryerContext는 컨텍스트 제한 시간을 준수하고 컨텍스트가 취소되면 리턴해야합니다.</target>
        </trans-unit>
        <trans-unit id="9769d5fe0c55a8ef8d81aaad984f657373379c37" translate="yes" xml:space="preserve">
          <source>Quit sends the QUIT command and closes the connection to the server.</source>
          <target state="translated">종료는 QUIT 명령을 전송하고 서버에 대한 연결을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="ef7d2daa6720a5dcac943446fb8685f517730120" translate="yes" xml:space="preserve">
          <source>Quo sets z to the quotient x/y and returns z. If y == 0, Quo panics.</source>
          <target state="translated">Quo는 z를 몫 x / y로 설정하고 z를 반환합니다. y == 0이면 Quo 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7e1aae2dbf075bb68d93d724ad6566e5e4a1c5e3" translate="yes" xml:space="preserve">
          <source>Quo sets z to the quotient x/y and returns z. If y == 0, a division-by-zero run-time panic occurs.</source>
          <target state="translated">Quo는 z를 몫 x / y로 설정하고 z를 반환합니다. y == 0이면 0으로 나누기 런타임 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a7929eb506dd3242d50cf4b52d276a4b8cb9c07b" translate="yes" xml:space="preserve">
          <source>Quo sets z to the quotient x/y for y != 0 and returns z. If y == 0, a division-by-zero run-time panic occurs. Quo implements truncated division (like Go); see QuoRem for more details.</source>
          <target state="translated">Quo는 y! = 0에 대해 z를 몫 x / y로 설정하고 z를 반환합니다. y == 0이면 0으로 나누기 런타임 패닉이 발생합니다. Quo는 Go와 같은 잘린 나누기를 구현합니다. 자세한 내용은 QuoRem을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1572bc36f1694a28504f4543686c15ca4cc42af5" translate="yes" xml:space="preserve">
          <source>Quo sets z to the rounded quotient x/y and returns z. Precision, rounding, and accuracy reporting are as for Add. Quo panics with ErrNaN if both operands are zero or infinities. The value of z is undefined in that case.</source>
          <target state="translated">Quo는 z를 둥근 몫 x / y로 설정하고 z를 반환합니다. 정밀도, 반올림 및 정확도보고는 추가와 같습니다. 두 피연산자가 모두 0이거나 무한대 인 경우 ErrNaN을 사용한 쿼터 패닉. 이 경우 z 값은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="99e212957f2d4b215b9b3d9954ca4d24b4f7b7f8" translate="yes" xml:space="preserve">
          <source>QuoRem implements T-division and modulus (like Go):</source>
          <target state="translated">QuoRem은 T- 분할과 모듈러스 (Go와 같은)를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="c9ddbdd15bfd376c21e0a62b9370cde6334dc1f4" translate="yes" xml:space="preserve">
          <source>QuoRem sets z to the quotient x/y and r to the remainder x%y and returns the pair (z, r) for y != 0. If y == 0, a division-by-zero run-time panic occurs.</source>
          <target state="translated">QuoRem은 z를 몫 x / y로 설정하고 r을 나머지 x % y로 설정하고 y! = 0에 대한 쌍 (z, r)을 반환합니다. y == 0이면 0으로 나누기 런타임 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="309028a9e01273ac7a88142bf26446f3f2a8f06c" translate="yes" xml:space="preserve">
          <source>Quote</source>
          <target state="translated">Quote</target>
        </trans-unit>
        <trans-unit id="02a6b721c3cbad5a2ac35c25089d53ad320899bd" translate="yes" xml:space="preserve">
          <source>Quote and QuoteToASCII convert strings to quoted Go string literals. The latter guarantees that the result is an ASCII string, by escaping any non-ASCII Unicode with \u:</source>
          <target state="translated">Quote 및 QuoteToASCII는 문자열을 인용 된 Go 문자열 리터럴로 변환합니다. 후자는 ASCII가 아닌 유니 코드를 \ u로 이스케이프 처리하여 결과가 ASCII 문자열임을 보증합니다.</target>
        </trans-unit>
        <trans-unit id="3617a988d68c2550b56a0533be32b6f532f0c980" translate="yes" xml:space="preserve">
          <source>Quote returns a double-quoted Go string literal representing s. The returned string uses Go escape sequences (\t, \n, \xFF, \u0100) for control characters and non-printable characters as defined by IsPrint.</source>
          <target state="translated">Quote는 s를 나타내는 큰 따옴표로 묶인 Go 문자열 리터럴을 반환합니다. 반환 된 문자열은 제어 문자 및 IsPrint에 의해 정의 된 인쇄 할 수없는 문자에 Go 이스케이프 시퀀스 (\ t, \ n, \ xFF, \ u0100)를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6f31dc77f679cfa7aaf16ecb978ab9c3d8982f6f" translate="yes" xml:space="preserve">
          <source>QuoteMeta</source>
          <target state="translated">QuoteMeta</target>
        </trans-unit>
        <trans-unit id="37da03d2f50ceab91ce8002d89f395e8b70d32e3" translate="yes" xml:space="preserve">
          <source>QuoteMeta returns a string that escapes all regular expression metacharacters inside the argument text; the returned string is a regular expression matching the literal text.</source>
          <target state="translated">QuoteMeta는 인수 텍스트 내부의 모든 정규식 메타 문자를 이스케이프하는 문자열을 반환합니다. 반환 된 문자열은 리터럴 텍스트와 일치하는 정규식입니다.</target>
        </trans-unit>
        <trans-unit id="e4b2ad9113103116d841b51eb9a5a4bb79d43dd5" translate="yes" xml:space="preserve">
          <source>QuoteRune</source>
          <target state="translated">QuoteRune</target>
        </trans-unit>
        <trans-unit id="642db102936be1179d9fd316324babf33d424684" translate="yes" xml:space="preserve">
          <source>QuoteRune and QuoteRuneToASCII are similar but accept runes and return quoted Go rune literals.</source>
          <target state="translated">QuoteRune 및 QuoteRuneToASCII는 유사하지만 룬을 허용하고 인용 된 Go 룬 리터럴을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="279cda9da221d3eced1baaee13fb941915b0ad94" translate="yes" xml:space="preserve">
          <source>QuoteRune returns a single-quoted Go character literal representing the rune. The returned string uses Go escape sequences (\t, \n, \xFF, \u0100) for control characters and non-printable characters as defined by IsPrint.</source>
          <target state="translated">QuoteRune은 룬을 나타내는 작은 따옴표로 묶인 Go 문자 리터럴을 리턴합니다. 반환 된 문자열은 제어 문자 및 IsPrint에 의해 정의 된 인쇄 할 수없는 문자에 Go 이스케이프 시퀀스 (\ t, \ n, \ xFF, \ u0100)를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c3b760977eead2353634f7488bfbfd8e6f53c7d3" translate="yes" xml:space="preserve">
          <source>QuoteRuneToASCII</source>
          <target state="translated">QuoteRuneToASCII</target>
        </trans-unit>
        <trans-unit id="53e2d039ada874ffb648eee9f937362314f5598e" translate="yes" xml:space="preserve">
          <source>QuoteRuneToASCII returns a single-quoted Go character literal representing the rune. The returned string uses Go escape sequences (\t, \n, \xFF, \u0100) for non-ASCII characters and non-printable characters as defined by IsPrint.</source>
          <target state="translated">QuoteRuneToASCII는 룬을 나타내는 작은 따옴표 Go 문자 리터럴을 리턴합니다. 반환 된 문자열은 IsPrint에 의해 정의 된 비 ASCII 문자 및 인쇄 할 수없는 문자에 Go 이스케이프 시퀀스 (\ t, \ n, \ xFF, \ u0100)를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0b7fc6950d658f88c7fbca21f506d8678210ba4b" translate="yes" xml:space="preserve">
          <source>QuoteRuneToGraphic</source>
          <target state="translated">QuoteRuneToGraphic</target>
        </trans-unit>
        <trans-unit id="6df82b7440744d392453e7ffacfb94618d53a85f" translate="yes" xml:space="preserve">
          <source>QuoteRuneToGraphic returns a single-quoted Go character literal representing the rune. If the rune is not a Unicode graphic character, as defined by IsGraphic, the returned string will use a Go escape sequence (\t, \n, \xFF, \u0100).</source>
          <target state="translated">QuoteRuneToGraphic은 룬을 나타내는 작은 따옴표 Go 문자 리터럴을 반환합니다. 룬이 IsGraphic에 정의 된대로 유니 코드 그래픽 문자가 아닌 경우 반환 된 문자열은 Go 이스케이프 시퀀스 (\ t, \ n, \ xFF, \ u0100)를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d7acc4ec0f4c890982546aed330f635d958aaa08" translate="yes" xml:space="preserve">
          <source>QuoteRuneToGraphic returns a single-quoted Go character literal representing the rune. The returned string uses Go escape sequences (\t, \n, \xFF, \u0100) for non-ASCII characters and non-printable characters as defined by IsGraphic.</source>
          <target state="translated">QuoteRuneToGraphic은 룬을 나타내는 작은 따옴표 Go 문자 리터럴을 리턴합니다. 반환 된 문자열은 IsGraphic에서 정의한 비 ASCII 문자 및 인쇄 할 수없는 문자에 Go 이스케이프 시퀀스 (\ t, \ n, \ xFF, \ u0100)를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1c5941bc9d5a3819ff2354cecea7900bb16d81ce" translate="yes" xml:space="preserve">
          <source>QuoteToASCII</source>
          <target state="translated">QuoteToASCII</target>
        </trans-unit>
        <trans-unit id="1903845d523cb092b2910db9e417c9681642b306" translate="yes" xml:space="preserve">
          <source>QuoteToASCII returns a double-quoted Go string literal representing s. The returned string uses Go escape sequences (\t, \n, \xFF, \u0100) for non-ASCII characters and non-printable characters as defined by IsPrint.</source>
          <target state="translated">QuoteToASCII는 s를 나타내는 큰 따옴표로 묶인 Go 문자열 리터럴을 반환합니다. 반환 된 문자열은 IsPrint에 의해 정의 된 비 ASCII 문자 및 인쇄 할 수없는 문자에 Go 이스케이프 시퀀스 (\ t, \ n, \ xFF, \ u0100)를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4621ad4d6c0a75793529926b49a9e0ff472d7a25" translate="yes" xml:space="preserve">
          <source>QuoteToGraphic</source>
          <target state="translated">QuoteToGraphic</target>
        </trans-unit>
        <trans-unit id="989eba63a51b2ee78ebbd70a94ce50a7d2a7dea9" translate="yes" xml:space="preserve">
          <source>QuoteToGraphic returns a double-quoted Go string literal representing s. The returned string leaves Unicode graphic characters, as defined by IsGraphic, unchanged and uses Go escape sequences (\t, \n, \xFF, \u0100) for non-graphic characters.</source>
          <target state="translated">QuoteToGraphic은 s를 나타내는 큰 따옴표로 묶인 Go 문자열 리터럴을 반환합니다. 반환 된 문자열은 IsGraphic에서 정의한 유니 코드 그래픽 문자를 변경하지 않고 그대로두고 그래픽이 아닌 문자에 Go 이스케이프 시퀀스 (\ t, \ n, \ xFF, \ u0100)를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="29d4d4e582c2a53b8be9f8063c3bfb0f71cbfd71" translate="yes" xml:space="preserve">
          <source>QuoteToGraphic returns a double-quoted Go string literal representing s. The returned string uses Go escape sequences (\t, \n, \xFF, \u0100) for non-ASCII characters and non-printable characters as defined by IsGraphic.</source>
          <target state="translated">QuoteToGraphic은 s를 나타내는 큰 따옴표로 묶인 Go 문자열 리터럴을 반환합니다. 반환 된 문자열은 IsGraphic에서 정의한 비 ASCII 문자 및 인쇄 할 수없는 문자에 Go 이스케이프 시퀀스 (\ t, \ n, \ xFF, \ u0100)를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="fd12f86a63d23d37e2246e2c7fa6e414286f5f3b" translate="yes" xml:space="preserve">
          <source>RC4 is cryptographically broken and should not be used for secure applications.</source>
          <target state="translated">RC4는 암호화 방식으로 손상되어 안전한 응용 프로그램에 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="bc475e86eb000cdc90e36723f96df5f3d9198891" translate="yes" xml:space="preserve">
          <source>RGBA is an in-memory image whose At method returns color.RGBA values.</source>
          <target state="translated">RGBA는 At 메서드가 color.RGBA 값을 반환하는 메모리 내 이미지입니다.</target>
        </trans-unit>
        <trans-unit id="04d387f558acb0866f18159db1f3ea813711e9ce" translate="yes" xml:space="preserve">
          <source>RGBA represents a traditional 32-bit alpha-premultiplied color, having 8 bits for each of red, green, blue and alpha.</source>
          <target state="translated">RGBA는 빨강, 녹색, 파랑 및 알파 각각에 대해 8 비트를 갖는 기존의 32 비트 알파 사전 곱셈 색상을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="46da93f2d89b5f7316108ef78fe128ccbb04c72c" translate="yes" xml:space="preserve">
          <source>RGBA64 is an in-memory image whose At method returns color.RGBA64 values.</source>
          <target state="translated">RGBA64는 At 메서드가 color.RGBA64 값을 반환하는 메모리 내 이미지입니다.</target>
        </trans-unit>
        <trans-unit id="dd5b935255bb5c16c695e848211ad0d21f5142a6" translate="yes" xml:space="preserve">
          <source>RGBA64 represents a 64-bit alpha-premultiplied color, having 16 bits for each of red, green, blue and alpha.</source>
          <target state="translated">RGBA64는 64 비트 알파 사전 곱셈 색상을 나타내며 빨강, 녹색, 파랑 및 알파 각각에 대해 16 비트를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="33f4c44fe26c52f4a8501dd0d6638972bee0c02a" translate="yes" xml:space="preserve">
          <source>RGBToCMYK converts an RGB triple to a CMYK quadruple.</source>
          <target state="translated">RGBToCMYK는 RGB 트리플을 CMYK 쿼드로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="b770a15a910f2bcdc5fe9614ef9593fa435bc817" translate="yes" xml:space="preserve">
          <source>RGBToYCbCr converts an RGB triple to a Y'CbCr triple.</source>
          <target state="translated">RGBToYCbCr은 RGB 트리플을 Y'CbCr 트리플로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="80bfa68e1e388f84eb032cb18125580dfa1ad40c" translate="yes" xml:space="preserve">
          <source>RLock locks rw for reading.</source>
          <target state="translated">RLock은 읽기를 위해 rw를 잠급니다.</target>
        </trans-unit>
        <trans-unit id="437fa597804ed80cc48e0b7bbfe7afd323e52a8f" translate="yes" xml:space="preserve">
          <source>RLocker returns a Locker interface that implements the Lock and Unlock methods by calling rw.RLock and rw.RUnlock.</source>
          <target state="translated">RLocker는 rw.RLock 및 rw.RUnlock을 호출하여 Lock 및 Unlock 메서드를 구현하는 Locker 인터페이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e9e1378ed0c7150ba139600e4e6dab65e5c1015c" translate="yes" xml:space="preserve">
          <source>RSA is a single, fundamental operation that is used in this package to implement either public-key encryption or public-key signatures.</source>
          <target state="translated">RSA는이 패키지에서 공개 키 암호화 또는 공개 키 서명을 구현하는 데 사용되는 단일의 기본 작업입니다.</target>
        </trans-unit>
        <trans-unit id="ea29bda7df062dd06d2efdde6aa5df97bda09cc0" translate="yes" xml:space="preserve">
          <source>RSA is able to encrypt only a very limited amount of data. In order to encrypt reasonable amounts of data a hybrid scheme is commonly used: RSA is used to encrypt a key for a symmetric primitive like AES-GCM. Before encrypting, data is &amp;ldquo;padded&amp;rdquo; by embedding it in a known structure. This is done for a number of reasons, but the most obvious is to ensure that the value is large enough that the exponentiation is larger than the modulus. (Otherwise it could be decrypted with a square-root.) In these designs, when using PKCS #1 v1.5, it's vitally important to avoid disclosing whether the received RSA message was well-formed (that is, whether the result of decrypting is a correctly padded message) because this leaks secret information. DecryptPKCS1v15SessionKey is designed for this situation and copies the decrypted, symmetric key (if well-formed) in constant-time over a buffer that contains a random key. Thus, if the RSA result isn't well-formed, the implementation uses a random key in constant time.</source>
          <target state="translated">RSA는 매우 제한된 양의 데이터 만 암호화 할 수 있습니다. 합리적인 양의 데이터를 암호화하기 위해 일반적으로 하이브리드 방식이 사용됩니다. RSA는 AES-GCM과 같은 대칭형 프리미티브의 키를 암호화하는 데 사용됩니다. 암호화하기 전에 데이터는 알려진 구조에 포함하여 &quot;패딩&quot;됩니다. 이것은 여러 가지 이유로 수행되지만 가장 분명한 것은 지수가 계수보다 클만큼 값이 충분히 큰지 확인하는 것입니다. (그렇지 않으면 제곱근으로 복호화 할 수 있습니다.) 이러한 설계에서 PKCS # 1 v1.5를 사용할 때 수신 된 RSA 메시지의 형식이 올바른지 (즉, 복호화 결과인지 여부)를 공개하지 않는 것이 매우 중요합니다. 이것은 비밀 정보를 유출하기 때문입니다. DecryptPKCS1v15SessionKey는 이러한 상황을 위해 설계되었으며 복호화 된,임의의 키를 포함하는 버퍼를 통해 일정한 시간에 대칭 키 (잘 구성된 경우). 따라서 RSA 결과가 제대로 구성되지 않은 경우 구현은 일정한 시간에 임의의 키를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c5491899defb867c4967ebbebdd0bd5970a6aab7" translate="yes" xml:space="preserve">
          <source>RSA is able to encrypt only a very limited amount of data. In order to encrypt reasonable amounts of data a hybrid scheme is commonly used: RSA is used to encrypt a key for a symmetric primitive like AES-GCM. Before encrypting, data is &amp;ldquo;padded&amp;rdquo; by embedding it in a known structure. This is done for a number of reasons, but the most obvious is to ensure that the value is large enough that the exponentiation is larger than the modulus. (Otherwise it could be decrypted with a square-root.) In these designs, when using PKCS#1 v1.5, it's vitally important to avoid disclosing whether the received RSA message was well-formed (that is, whether the result of decrypting is a correctly padded message) because this leaks secret information. DecryptPKCS1v15SessionKey is designed for this situation and copies the decrypted, symmetric key (if well-formed) in constant-time over a buffer that contains a random key. Thus, if the RSA result isn't well-formed, the implementation uses a random key in constant time.</source>
          <target state="translated">RSA는 매우 제한된 양의 데이터 만 암호화 할 수 있습니다. 합리적인 양의 데이터를 암호화하기 위해 하이브리드 체계가 일반적으로 사용됩니다. RSA는 AES-GCM과 같은 대칭 기본 요소의 키를 암호화하는 데 사용됩니다. 암호화하기 전에 데이터를 알려진 구조에 포함시켜 데이터를 &quot;패딩&quot;합니다. 이것은 여러 가지 이유로 수행되지만 가장 명백한 것은 지수가 계수보다 큰 값이 충분히 큰지 확인하는 것입니다. (그렇지 않으면 제곱근으로 해독 할 수 있습니다.) 이러한 설계에서 PKCS # 1 v1.5를 사용할 때는 수신 된 RSA 메시지의 형식이 올바른지 (즉, 해독 결과의 여부)를 공개하지 않는 것이 매우 중요합니다. 은 비밀 정보를 유출하기 때문에 올바르게 채워진 메시지입니다. DecryptPKCS1v15SessionKey는이 상황을 위해 설계되었으며 해독 된임의의 키를 포함하는 버퍼를 통해 일정 시간 동안 대칭 키 (성공한 경우). 따라서 RSA 결과가 제대로 구성되지 않으면 구현시 일정한 시간에 임의의 키를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0d73a3a42eb35fcb3f1a5896de985a3713b16b03" translate="yes" xml:space="preserve">
          <source>RUnlock undoes a single RLock call; it does not affect other simultaneous readers. It is a run-time error if rw is not locked for reading on entry to RUnlock.</source>
          <target state="translated">RUnlock은 단일 RLock 호출을 취소합니다. 다른 동시 독자에게는 영향을 미치지 않습니다. RUnlock 시작시 읽기를 위해 rw가 잠기지 않은 경우 런타임 오류입니다.</target>
        </trans-unit>
        <trans-unit id="b74aed63ef335b4d50b7ff503e63deda9fc37c24" translate="yes" xml:space="preserve">
          <source>Rand sets z to a pseudo-random number in [0, n) and returns z.</source>
          <target state="translated">Rand는 z를 [0, n)의 의사 난수로 설정하고 z를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cd54bd9d380c9fc6a34adb64461692fb6d87443f" translate="yes" xml:space="preserve">
          <source>Random numbers are generated by a Source. Top-level functions, such as Float64 and Int, use a default shared Source that produces a deterministic sequence of values each time a program is run. Use the Seed function to initialize the default Source if different behavior is required for each run. The default Source is safe for concurrent use by multiple goroutines, but Sources created by NewSource are not.</source>
          <target state="translated">난수는 소스에서 생성됩니다. Float64 및 Int와 같은 최상위 기능은 프로그램이 실행될 때마다 결정적인 값 시퀀스를 생성하는 기본 공유 소스를 사용합니다. 각 실행마다 다른 동작이 필요한 경우 Seed 기능을 사용하여 기본 소스를 초기화하십시오. 기본 소스는 여러 고 루틴에서 동시에 사용하기에 안전하지만 NewSource에서 만든 소스는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8185befebe4b99fc7f08cc0f98bec64eff9d397b" translate="yes" xml:space="preserve">
          <source>Range calls f sequentially for each key and value present in the map. If f returns false, range stops the iteration.</source>
          <target state="translated">범위는 맵에있는 각 키와 값에 대해 순차적으로 f를 호출합니다. f가 false를 반환하면 range는 반복을 중지합니다.</target>
        </trans-unit>
        <trans-unit id="e20ffc43a19a831487646a9ec91a15662b93326d" translate="yes" xml:space="preserve">
          <source>Range does not necessarily correspond to any consistent snapshot of the Map's contents: no key will be visited more than once, but if the value for any key is stored or deleted concurrently, Range may reflect any mapping for that key from any point during the Range call.</source>
          <target state="translated">범위는 맵 내용의 일관된 스냅 샷과 반드시 ​​일치하지는 않습니다. 키를 두 번 이상 방문하지 않지만, 키 값이 동시에 저장되거나 삭제되면 Range는 Range 동안 어떤 시점에서든 해당 키에 대한 매핑을 반영 할 수 있습니다 요구.</target>
        </trans-unit>
        <trans-unit id="faec537bfdedcf391dd6afc93a601559afbe0c69" translate="yes" xml:space="preserve">
          <source>Range may be O(N) with the number of elements in the map even if f returns false after a constant number of calls.</source>
          <target state="translated">일정 횟수의 호출 후 f가 false를 반환하더라도 맵의 요소 수와 함께 범위는 O (N) 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc094bef8459881bcfd6a354dcd57e410a9ea71d" translate="yes" xml:space="preserve">
          <source>Range16 represents of a range of 16-bit Unicode code points. The range runs from Lo to Hi inclusive and has the specified stride.</source>
          <target state="translated">Range16은 16 비트 유니 코드 코드 포인트 범위를 나타냅니다. 범위는 Lo에서 Hi까지 포함되며 지정된 보폭을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="8ceb0b8d7c66b188254058f3e47e0188e8c2c9ca" translate="yes" xml:space="preserve">
          <source>Range32 represents of a range of Unicode code points and is used when one or more of the values will not fit in 16 bits. The range runs from Lo to Hi inclusive and has the specified stride. Lo and Hi must always be &amp;gt;= 1&amp;lt;&amp;lt;16.</source>
          <target state="translated">Range32는 유니 코드 코드 포인트 범위를 나타내며 하나 이상의 값이 16 비트에 맞지 않을 때 사용됩니다. 범위는 Lo에서 Hi까지 포함되며 지정된 보폭을 갖습니다. Lo와 Hi는 항상&amp;gt; = 1 &amp;lt;&amp;lt; 16이어야합니다.</target>
        </trans-unit>
        <trans-unit id="3c231e0e20b34ad9b3302a62e18606f8e55490f0" translate="yes" xml:space="preserve">
          <source>RangeNode represents a {{range}} action and its commands.</source>
          <target state="translated">RangeNode는 {{range}} 작업 및 해당 명령을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="abf434f30dd2288f852577f0e6ac91164ff1a3d8" translate="yes" xml:space="preserve">
          <source>RangeTable defines a set of Unicode code points by listing the ranges of code points within the set. The ranges are listed in two slices to save space: a slice of 16-bit ranges and a slice of 32-bit ranges. The two slices must be in sorted order and non-overlapping. Also, R32 should contain only values &amp;gt;= 0x10000 (1&amp;lt;&amp;lt;16).</source>
          <target state="translated">RangeTable은 세트 내의 코드 포인트 범위를 나열하여 유니 코드 코드 포인트 세트를 정의합니다. 범위는 공간을 절약하기 위해 두 개의 슬라이스로 나열됩니다. 16 비트 범위의 슬라이스와 32 비트 범위의 슬라이스. 두 슬라이스는 정렬 순서와 겹치지 않아야합니다. 또한 R32는&amp;gt; = 0x10000 (1 &amp;lt;&amp;lt; 16) 값만 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="c2ee87a3ff54a0745b9a4a39ad5daff79dc82bc0" translate="yes" xml:space="preserve">
          <source>Ranges returns the PC ranges covered by e, a slice of [low,high) pairs. Only some entry types, such as TagCompileUnit or TagSubprogram, have PC ranges; for others, this will return nil with no error.</source>
          <target state="translated">Ranges는 [낮음, 높음] 쌍의 조각 인 e로 덮여있는 PC 범위를 반환합니다. TagCompileUnit 또는 TagSubprogram과 같은 일부 항목 유형에만 PC 범위가 있습니다. 다른 사람들에게는 오류없이 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="81de462dc83f2812dc32eb06897fa3d4b38ae7e7" translate="yes" xml:space="preserve">
          <source>Rat returns the rational number corresponding to x; or nil if x is an infinity. The result is Exact if x is not an Inf. If a non-nil *Rat argument z is provided, Rat stores the result in z instead of allocating a new Rat.</source>
          <target state="translated">Rat는 x에 해당하는 유리수를 반환합니다. x가 무한대이면 nil. x가 Inf가 아닌 경우 결과는 정확합니다. 0이 아닌 * Rat 인수 z가 제공되면 Rat는 새 Rat을 할당하는 대신 z에 결과를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="50ea5863423e0f2515585dcf8c4cb2e31c788a51" translate="yes" xml:space="preserve">
          <source>Rat.Scan</source>
          <target state="translated">Rat.Scan</target>
        </trans-unit>
        <trans-unit id="c5f08baa94ad88996a91c67be38be8fe61b40881" translate="yes" xml:space="preserve">
          <source>Rat.SetString</source>
          <target state="translated">Rat.SetString</target>
        </trans-unit>
        <trans-unit id="ef746adb638d3b60d53628e5d2f1455b1d2e8157" translate="yes" xml:space="preserve">
          <source>RatString returns a string representation of x in the form &quot;a/b&quot; if b != 1, and in the form &quot;a&quot; if b == 1.</source>
          <target state="translated">RatString은 b! = 1 인 경우 &quot;a / b&quot;형식으로, b == 1 인 경우 &quot;a&quot;형식으로 x의 문자열 표현을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="641d010f14e2f18c1619afc2268deaff20c97455" translate="yes" xml:space="preserve">
          <source>Raw executes f exposing the underlying driver connection for the duration of f. The driverConn must not be used outside of f.</source>
          <target state="translated">Raw는 f 동안 기본 드라이버 연결을 노출하여 f를 실행합니다. driverConn을 f 외부에서 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="26c83b72700cdd4952e72476a8d6589b2a87a210" translate="yes" xml:space="preserve">
          <source>RawBytes is a byte slice that holds a reference to memory owned by the database itself. After a Scan into a RawBytes, the slice is only valid until the next call to Next, Scan, or Close.</source>
          <target state="translated">RawBytes는 데이터베이스 자체가 소유 한 메모리에 대한 참조를 보유하는 바이트 슬라이스입니다. RawBytes로 스캔 한 후 슬라이스는 다음, 다음 스캔 또는 닫기를 호출 할 때까지만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="3e2984f789eabe0509843f2607db31c184bddf19" translate="yes" xml:space="preserve">
          <source>RawContent is used to signal that the undecoded, DER data needs to be preserved for a struct. To use it, the first field of the struct must have this type. It's an error for any of the other fields to have this type.</source>
          <target state="translated">RawContent는 구조체에 대해 디코딩되지 않은 DER 데이터를 보존해야한다는 신호를 보내는 데 사용됩니다. 이를 사용하려면 구조체의 첫 번째 필드에이 유형이 있어야합니다. 다른 필드가이 유형을 갖는 것은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="40ee0825120347a6625b948e8e5d6cf21e430f3f" translate="yes" xml:space="preserve">
          <source>RawMessage (Marshal)</source>
          <target state="translated">RawMessage (마셜)</target>
        </trans-unit>
        <trans-unit id="d988676cc711a8df55ed7c79d1c3ecdfedc6d2cd" translate="yes" xml:space="preserve">
          <source>RawMessage (Unmarshal)</source>
          <target state="translated">RawMessage (비 정렬)</target>
        </trans-unit>
        <trans-unit id="1b6da1274d970ef16e862ce3a549bfc22e374a82" translate="yes" xml:space="preserve">
          <source>RawMessage is a raw encoded JSON value. It implements Marshaler and Unmarshaler and can be used to delay JSON decoding or precompute a JSON encoding.</source>
          <target state="translated">RawMessage는 원시 인코딩 된 JSON 값입니다. Marshaler 및 Unmarshaler를 구현하며 JSON 디코딩을 지연 시키거나 JSON 인코딩을 사전 계산하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b92ccd29d9bf661a3766af996d8af025383bbfe8" translate="yes" xml:space="preserve">
          <source>RawStdEncoding is the standard raw, unpadded base64 encoding, as defined in RFC 4648 section 3.2. This is the same as StdEncoding but omits padding characters.</source>
          <target state="translated">RawStdEncoding은 RFC 4648 섹션 3.2에 정의 된 표준 원시, 패딩되지 않은 base64 인코딩입니다. 이것은 StdEncoding과 동일하지만 패딩 문자는 생략합니다.</target>
        </trans-unit>
        <trans-unit id="6e753058a412394f90ee90228dcf31c4e858e385" translate="yes" xml:space="preserve">
          <source>RawToken is like Token but does not verify that start and end elements match and does not translate name space prefixes to their corresponding URLs.</source>
          <target state="translated">RawToken은 토큰과 비슷하지만 시작 및 끝 요소가 일치하는지 확인하지 않으며 네임 스페이스 접두어를 해당 URL로 변환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="166fbd6be28a6fdfe4f94b440b329268727101a8" translate="yes" xml:space="preserve">
          <source>RawURLEncoding is the unpadded alternate base64 encoding defined in RFC 4648. It is typically used in URLs and file names. This is the same as URLEncoding but omits padding characters.</source>
          <target state="translated">RawURLEncoding은 RFC 4648에 정의 된 패딩되지 않은 대체 base64 인코딩입니다. 일반적으로 URL 및 파일 이름에 사용됩니다. URLEncoding과 동일하지만 패딩 문자는 생략합니다.</target>
        </trans-unit>
        <trans-unit id="b05c645148a5f30bf1ff0257be7322f1e5b30562" translate="yes" xml:space="preserve">
          <source>Rcpt issues a RCPT command to the server using the provided email address. A call to Rcpt must be preceded by a call to Mail and may be followed by a Data call or another Rcpt call.</source>
          <target state="translated">Rcpt는 제공된 이메일 주소를 사용하여 RCPT 명령을 서버에 발행합니다. Rcpt 호출은 Mail 호출 앞에 와야하며 데이터 호출 또는 다른 Rcpt 호출이 이어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="852b438f91ad9eb2cdd84419a675a216d543c687" translate="yes" xml:space="preserve">
          <source>Read</source>
          <target state="translated">Read</target>
        </trans-unit>
        <trans-unit id="1fab142ac33b47994d5f7bd4bebd0d391e21aa89" translate="yes" xml:space="preserve">
          <source>Read (Multi)</source>
          <target state="translated">읽기 (멀티)</target>
        </trans-unit>
        <trans-unit id="4616684d2875f90666103e0a2381658c802ee8fa" translate="yes" xml:space="preserve">
          <source>Read (ReadingAllMetrics)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="056841d4c802087a4a98816675796eebe48b69ab" translate="yes" xml:space="preserve">
          <source>Read (ReadingOneMetric)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d9a4bfe253412dcb5fa31eea7ed6b71a69c4521" translate="yes" xml:space="preserve">
          <source>Read calls decode to deserialize a file set into s; s must not be nil.</source>
          <target state="translated">읽기 호출은 파일 세트를 s로 직렬화 해제하기 위해 디코드합니다. s는 0이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="cf8ca129127382252f21178b2e38598c4c8bdae5" translate="yes" xml:space="preserve">
          <source>Read can be made to time out and return a net.Error with Timeout() == true after a fixed time limit; see SetDeadline and SetReadDeadline.</source>
          <target state="translated">시간 제한을 읽은 후 net을 반환 할 수 있습니다. 고정 시간 제한 후 Timeout () == true 인 경우 오류; SetDeadline 및 SetReadDeadline을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f1410843edc88c2b9c942b455b313f9ec9a6aa42" translate="yes" xml:space="preserve">
          <source>Read generates len(p) random bytes and writes them into p. It always returns len(p) and a nil error. Read should not be called concurrently with any other Rand method.</source>
          <target state="translated">읽기는 len (p) 임의의 바이트를 생성하여 p에 씁니다. 항상 len (p) 및 nil 오류를 반환합니다. 다른 Rand 메소드와 동시에 읽기를 호출하면 안됩니다.</target>
        </trans-unit>
        <trans-unit id="1059017001f226c432850be91279c7915ab436ce" translate="yes" xml:space="preserve">
          <source>Read generates len(p) random bytes from the default Source and writes them into p. It always returns len(p) and a nil error. Read, unlike the Rand.Read method, is safe for concurrent use.</source>
          <target state="translated">읽기는 기본 소스에서 len (p) 임의 바이트를 생성하여 p에 씁니다. 항상 len (p) 및 nil 오류를 반환합니다. Rand.Read 방법과 달리 읽기는 동시 사용에 안전합니다.</target>
        </trans-unit>
        <trans-unit id="a6208c052d923f9826a6caa2665b94a206f4ce81" translate="yes" xml:space="preserve">
          <source>Read implements io.Reader, reading uncompressed bytes from its underlying Reader.</source>
          <target state="translated">Read는 io.Reader를 구현하여 기본 Reader에서 압축되지 않은 바이트를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="702bfd00bb1c14225a9197a21d99befbae954266" translate="yes" xml:space="preserve">
          <source>Read implements the Conn Read method.</source>
          <target state="translated">Read는 Conn Read 메서드를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="516c851188aa6fc002db294d7651c5ec750120d8" translate="yes" xml:space="preserve">
          <source>Read implements the io.Reader interface.</source>
          <target state="translated">읽기는 io.Reader 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="13632ff4ca176eb49e2ded2120c8bd44145f6430" translate="yes" xml:space="preserve">
          <source>Read implements the standard Read interface: it reads data from the pipe, blocking until a writer arrives or the write end is closed. If the write end is closed with an error, that error is returned as err; otherwise err is EOF.</source>
          <target state="translated">읽기는 표준 읽기 인터페이스를 구현합니다. 파이프에서 데이터를 읽고 기록기가 도착하거나 쓰기 끝이 닫힐 때까지 차단합니다. 쓰기 종료가 오류와 함께 닫히면 해당 오류가 err로 리턴됩니다. 그렇지 않으면 err는 EOF입니다.</target>
        </trans-unit>
        <trans-unit id="852b19fc6db1a887a68fe0a33719da8f3df7f6a7" translate="yes" xml:space="preserve">
          <source>Read is a helper function that calls Reader.Read using io.ReadFull. On return, n == len(b) if and only if err == nil.</source>
          <target state="translated">Read는 io.ReadFull을 사용하여 Reader.Read를 호출하는 도우미 함수입니다. 리턴시, err == nil 인 경우에만 n == len (b).</target>
        </trans-unit>
        <trans-unit id="b67213600ee7c7c65b18452fd9f7225abb869291" translate="yes" xml:space="preserve">
          <source>Read populates each Value field in the given slice of metric samples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6027400201b1aeffebb229f97e47437dd5103716" translate="yes" xml:space="preserve">
          <source>Read reads and decodes quoted-printable data from the underlying reader.</source>
          <target state="translated">읽기는 기본 판독기에서 인용 인쇄 가능한 데이터를 읽고 디코딩합니다.</target>
        </trans-unit>
        <trans-unit id="e39e4192f44c501e67a65cfba45076430efcd47a" translate="yes" xml:space="preserve">
          <source>Read reads data from the connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="099ba490bf08acc0d4ea27ba7af0e8caf12990cd" translate="yes" xml:space="preserve">
          <source>Read reads data into p. It returns the number of bytes read into p. The bytes are taken from at most one Read on the underlying Reader, hence n may be less than len(p). To read exactly len(p) bytes, use io.ReadFull(b, p). At EOF, the count will be zero and err will be io.EOF.</source>
          <target state="translated">읽기는 p로 데이터를 읽습니다. p로 읽은 바이트 수를 리턴합니다. 바이트는 기본 Reader에서 최대 하나의 읽기에서 가져 오므로 n은 len (p)보다 작을 수 있습니다. 정확히 len (p) 바이트를 읽으려면 io.ReadFull (b, p)를 사용하십시오. EOF에서 카운트는 0이되고 err는 io.EOF가됩니다.</target>
        </trans-unit>
        <trans-unit id="16ce634004d504a55e55d47a3800c80b22768a4e" translate="yes" xml:space="preserve">
          <source>Read reads from the current file in the tar archive. It returns (0, io.EOF) when it reaches the end of that file, until Next is called to advance to the next file.</source>
          <target state="translated">tar 아카이브의 현재 파일에서 읽습니다. 다음 파일로 진행하기 위해 Next가 호출 될 때까지 해당 파일의 끝에 도달하면 (0, io.EOF)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8672c69a1ddaf5ba6848a36cbea552f79e4309ae" translate="yes" xml:space="preserve">
          <source>Read reads one record (a slice of fields) from r. If the record has an unexpected number of fields, Read returns the record along with the error ErrFieldCount. Except for that case, Read always returns either a non-nil record or a non-nil error, but not both. If there is no data left to be read, Read returns nil, io.EOF. If ReuseRecord is true, the returned slice may be shared between multiple calls to Read.</source>
          <target state="translated">읽기 r에서 하나의 레코드 (한 조각의 필드)를 읽습니다. 레코드에 예기치 않은 수의 필드가 있으면 Read는 오류 ErrFieldCount와 함께 레코드를 반환합니다. 이 경우를 제외하고 Read는 항상 넌이 아닌 레코드 또는 넌이 아닌 오류를 반환하지만 둘 다를 반환하지는 않습니다. 읽을 데이터가 남아 있지 않으면 Read는 nil, io.EOF를 반환합니다. ReuseRecord가 true 인 경우 반환 된 슬라이스는 여러 번의 읽기 호출간에 공유 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a7ebad97783211e0c50dee195a81d2fcc00a21a" translate="yes" xml:space="preserve">
          <source>Read reads structured binary data from r into data. Data must be a pointer to a fixed-size value or a slice of fixed-size values. Bytes read from r are decoded using the specified byte order and written to successive fields of the data. When decoding boolean values, a zero byte is decoded as false, and any other non-zero byte is decoded as true. When reading into structs, the field data for fields with blank (_) field names is skipped; i.e., blank field names may be used for padding. When reading into a struct, all non-blank fields must be exported or Read may panic.</source>
          <target state="translated">읽기는 r에서 데이터로 구조화 된 이진 데이터를 읽습니다. 데이터는 고정 크기 값 또는 고정 크기 값 조각에 대한 포인터 여야합니다. r에서 읽은 바이트는 지정된 바이트 순서를 사용하여 디코딩되어 데이터의 연속 필드에 기록됩니다. 부울 값을 디코딩 할 때 0 바이트는 false로 디코딩되고 0이 아닌 다른 바이트는 true로 디코딩됩니다. 구조체를 읽을 때 공백 (_) 필드 이름을 가진 필드의 필드 데이터는 건너 뜁니다. 즉, 빈 필드 이름이 패딩에 사용될 수 있습니다. 구조체를 읽을 때 모든 비 공백 필드를 내보내거나 읽기 패닉 상태 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13d3208ebb1aa7a1ba1e0de8a255452e3b6f8318" translate="yes" xml:space="preserve">
          <source>Read reads the body of a part, after its headers and before the next part (if any) begins.</source>
          <target state="translated">읽기는 헤더 뒤 및 다음 파트 (있는 경우)가 시작되기 전에 파트의 본문을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="bbca8871624a3fc59330b4b25dd8f3ecce95f77a" translate="yes" xml:space="preserve">
          <source>Read reads the index from r into x; x must not be nil.</source>
          <target state="translated">읽기 r에서 x로 색인을 읽습니다. x는 0이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="f50cd5c21ed9fed72a69eacf7363def3849c51d8" translate="yes" xml:space="preserve">
          <source>Read reads the next len(p) bytes from the buffer or until the buffer is drained. The return value n is the number of bytes read. If the buffer has no data to return, err is io.EOF (unless len(p) is zero); otherwise it is nil.</source>
          <target state="translated">읽기는 버퍼에서 또는 버퍼가 비워 질 때까지 다음 len (p) 바이트를 읽습니다. 리턴 값 n은 읽은 바이트 수입니다. 버퍼에 반환 할 데이터가 없으면 err는 io.EOF입니다 (len (p)가 0이 아닌 경우). 그렇지 않으면 0입니다.</target>
        </trans-unit>
        <trans-unit id="dd7574617c7b02af539a5115f14c74adf24afa51" translate="yes" xml:space="preserve">
          <source>Read reads the next response from the wire. A valid response might be returned together with an ErrPersistEOF, which means that the remote requested that this be the last request serviced. Read can be called concurrently with Write, but not with another Read.</source>
          <target state="translated">읽기는 와이어에서 다음 응답을 읽습니다. 유효한 응답이 ErrPersistEOF와 함께 리턴 될 수 있습니다. 이는 리모트가 요청 된 마지막 요청임을 원격에 요청했음을 의미합니다. Read는 Write와 동시에 호출 될 수 있지만 다른 Read와는 호출 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e877852fb33acd1c13bf6498df79e2e968ae525c" translate="yes" xml:space="preserve">
          <source>Read reads up to len(b) bytes from the File. It returns the number of bytes read and any error encountered. At end of file, Read returns 0, io.EOF.</source>
          <target state="translated">읽기는 파일에서 len (b) 바이트까지 읽습니다. 읽은 바이트 수와 발생한 오류를 반환합니다. 파일 끝에서 Read는 0, io.EOF를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5d839b22857eca34207c84ba0a055c6ee9c74ec5" translate="yes" xml:space="preserve">
          <source>Read reads up to len(p) bytes into p. It returns the number of bytes read (0 &amp;lt;= n &amp;lt;= len(p)) and any error encountered. Even if Read returns n &amp;lt; len(p), it may use all of p as scratch space during the call. If some data is available but not len(p) bytes, Read conventionally returns what is available instead of waiting for more.</source>
          <target state="translated">읽기는 최대 len (p) 바이트를 p로 읽습니다. 읽은 바이트 수 (0 &amp;lt;= n &amp;lt;= len (p)) 및 발생한 오류를 반환합니다. Read가 n &amp;lt;len (p)를 반환하더라도 호출 중에 모든 p를 스크래치 공간으로 사용할 수 있습니다. 일부 데이터를 사용할 수 있지만 len (p) 바이트는 사용할 수없는 경우 Read는 일반적으로 더 많은 것을 기다리는 대신 사용 가능한 것을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="232135a13eb14d8c77efc7e8763b8a54f14d853d" translate="yes" xml:space="preserve">
          <source>Read returns the next request on the wire. An ErrPersistEOF is returned if it is gracefully determined that there are no more requests (e.g. after the first request on an HTTP/1.0 connection, or after a Connection:close on a HTTP/1.1 connection).</source>
          <target state="translated">읽기는 와이어에서 다음 요청을 반환합니다. ErrPersistEOF는 더 이상 요청이 없다고 판단되면 (예 : HTTP / 1.0 연결에서 첫 번째 요청 후 또는 HTTP / 1.1 연결에서 Connection : close 후) 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="8577ab4df6483a129452d0551a62e50aac1ada00" translate="yes" xml:space="preserve">
          <source>ReadAll</source>
          <target state="translated">ReadAll</target>
        </trans-unit>
        <trans-unit id="c220dc4ba473358c1d6061cf0c9c7708ee93e92a" translate="yes" xml:space="preserve">
          <source>ReadAll reads all the remaining records from r. Each record is a slice of fields. A successful call returns err == nil, not err == io.EOF. Because ReadAll is defined to read until EOF, it does not treat end of file as an error to be reported.</source>
          <target state="translated">ReadAll은 r에서 나머지 모든 레코드를 읽습니다. 각 레코드는 한 조각의 필드입니다. 성공적인 호출은 err == io.EOF가 아니라 err == nil을 리턴합니다. ReadAll은 EOF까지 읽도록 정의되므로 파일 끝을보고 할 오류로 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a2e746d4cfb2608d3ae0cefc64ac787887ba2c28" translate="yes" xml:space="preserve">
          <source>ReadAll reads from r until an error or EOF and returns the data it read. A successful call returns err == nil, not err == EOF. Because ReadAll is defined to read from src until EOF, it does not treat an EOF from Read as an error to be reported.</source>
          <target state="translated">ReadAll은 오류 또는 EOF가 될 때까지 r에서 읽고 읽은 데이터를 반환합니다. 성공적인 호출은 err == EOF가 아니라 err == nil을 리턴합니다. ReadAll은 EOF까지 src에서 읽도록 정의되므로 Read의 EOF를보고 할 오류로 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f4cbf689398d7442e9b49d9483e3d4cc75c10fd1" translate="yes" xml:space="preserve">
          <source>ReadAt implements the io.ReaderAt interface.</source>
          <target state="translated">ReadAt은 io.ReaderAt 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="64ae50d9b868e0114af3da28a0f440e42207678f" translate="yes" xml:space="preserve">
          <source>ReadAt reads len(b) bytes from the File starting at byte offset off. It returns the number of bytes read and the error, if any. ReadAt always returns a non-nil error when n &amp;lt; len(b). At end of file, that error is io.EOF.</source>
          <target state="translated">ReadAt은 바이트 오프셋 오프에서 시작하여 파일에서 len (b) 바이트를 읽습니다. 읽은 바이트 수와 오류 (있는 경우)를 반환합니다. n &amp;lt;len (b) 인 경우 ReadAt는 항상 non-nil 오류를 반환합니다. 파일 끝에서 해당 오류는 io.EOF입니다.</target>
        </trans-unit>
        <trans-unit id="c0bb2352984c400f258aa80aba0c3141b53cce96" translate="yes" xml:space="preserve">
          <source>ReadAt reads len(p) bytes into p starting at offset off in the underlying input source. It returns the number of bytes read (0 &amp;lt;= n &amp;lt;= len(p)) and any error encountered.</source>
          <target state="translated">ReadAt은 기본 입력 소스에서 오프셋 off에서 시작하여 len (p) 바이트를 p로 읽습니다. 읽은 바이트 수 (0 &amp;lt;= n &amp;lt;= len (p)) 및 발생한 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e76e529805447d2ff346a5397f1147a3e02108f4" translate="yes" xml:space="preserve">
          <source>ReadAtLeast</source>
          <target state="translated">ReadAtLeast</target>
        </trans-unit>
        <trans-unit id="dde64f711702d58fa68344cc075ded7169e93092" translate="yes" xml:space="preserve">
          <source>ReadAtLeast reads from r into buf until it has read at least min bytes. It returns the number of bytes copied and an error if fewer bytes were read. The error is EOF only if no bytes were read. If an EOF happens after reading fewer than min bytes, ReadAtLeast returns ErrUnexpectedEOF. If min is greater than the length of buf, ReadAtLeast returns ErrShortBuffer. On return, n &amp;gt;= min if and only if err == nil. If r returns an error having read at least min bytes, the error is dropped.</source>
          <target state="translated">ReadAtLeast는 최소 최소 바이트를 읽을 때까지 r에서 buf로 읽습니다. 적은 바이트를 읽은 경우 복사 된 바이트 수와 오류를 반환합니다. 읽은 바이트가없는 경우에만 오류가 EOF입니다. 최소 바이트 미만을 읽은 후 EOF가 발생하면 ReadAtLeast는 ErrUnexpectedEOF를 반환합니다. min이 buf의 길이보다 크면 ReadAtLeast는 ErrShortBuffer를 반환합니다. 리턴시, err == nil 인 경우에만 n&amp;gt; = min. r이 최소 최소 바이트를 읽은 오류를 리턴하면 오류가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="5eb984a81bf137b794c952d3bb6893f123d7859e" translate="yes" xml:space="preserve">
          <source>ReadBuildInfo returns the build information embedded in the running binary. The information is available only in binaries built with module support.</source>
          <target state="translated">ReadBuildInfo는 실행중인 바이너리에 포함 된 빌드 정보를 반환합니다. 이 정보는 모듈 지원으로 빌드 된 바이너리에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b60f1ee86705e93ab48e53804a8b6eaae8d1a5a6" translate="yes" xml:space="preserve">
          <source>ReadByte implements the io.ByteReader interface.</source>
          <target state="translated">ReadByte는 io.ByteReader 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="d432106a1ae20b1859bbefe8636f0c563d8fc86f" translate="yes" xml:space="preserve">
          <source>ReadByte provides an efficient interface for byte-at-time processing. A Reader that does not implement ByteReader can be wrapped using bufio.NewReader to add this method.</source>
          <target state="translated">ReadByte는 바이트 단위 처리를위한 효율적인 인터페이스를 제공합니다. ByteReader를 구현하지 않는 리더는 bufio.NewReader를 사용하여이 메서드를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88fc89f806641e6821f93c159732d09d121182a0" translate="yes" xml:space="preserve">
          <source>ReadByte reads and returns a single byte. If no byte is available, returns an error.</source>
          <target state="translated">ReadByte는 단일 바이트를 읽고 반환합니다. 사용 가능한 바이트가 없으면 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8ccc7f3f4551a8da89db7d7f4659a2bcc7f6f5b1" translate="yes" xml:space="preserve">
          <source>ReadByte reads and returns the next byte from the buffer. If no byte is available, it returns error io.EOF.</source>
          <target state="translated">ReadByte는 버퍼에서 다음 바이트를 읽고 반환합니다. 사용 가능한 바이트가 없으면 오류 io.EOF를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="159679671477045d937418ced34fc2e8ac5df5f4" translate="yes" xml:space="preserve">
          <source>ReadByte reads and returns the next byte from the input or any error encountered. If ReadByte returns an error, no input byte was consumed, and the returned byte value is undefined.</source>
          <target state="translated">ReadByte는 입력 또는 발생한 오류에서 다음 바이트를 읽고 반환합니다. ReadByte가 오류를 반환하면 입력 바이트가 사용되지 않고 반환 된 바이트 값이 정의되지 않은 것입니다.</target>
        </trans-unit>
        <trans-unit id="3d347b2a2e7f91e4c72a8f8310b1aba11bc78e6c" translate="yes" xml:space="preserve">
          <source>ReadBytes reads until the first occurrence of delim in the input, returning a slice containing the data up to and including the delimiter. If ReadBytes encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often io.EOF). ReadBytes returns err != nil if and only if the returned data does not end in delim.</source>
          <target state="translated">ReadBytes는 입력에서 delim이 처음 나타날 때까지 읽고 구분 기호까지 포함 된 데이터를 포함하는 슬라이스를 반환합니다. 구분 기호를 찾기 전에 ReadBytes에서 오류가 발생하면 오류 이전에 읽은 데이터와 오류 자체 (종종 io.EOF)를 반환합니다. ReadBytes는 반환 된 데이터가 delim로 끝나지 않는 경우에만 err! = nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="aba4d297566c98e6e0d191f056016ef94b731d93" translate="yes" xml:space="preserve">
          <source>ReadBytes reads until the first occurrence of delim in the input, returning a slice containing the data up to and including the delimiter. If ReadBytes encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often io.EOF). ReadBytes returns err != nil if and only if the returned data does not end in delim. For simple uses, a Scanner may be more convenient.</source>
          <target state="translated">ReadBytes는 입력에서 delim이 처음 나타날 때까지 읽고 구분 기호까지 포함 된 데이터를 포함하는 슬라이스를 반환합니다. 구분 기호를 찾기 전에 ReadBytes에서 오류가 발생하면 오류 이전에 읽은 데이터와 오류 자체 (종종 io.EOF)를 반환합니다. ReadBytes는 반환 된 데이터가 delim로 끝나지 않는 경우에만 err! = nil을 반환합니다. 간단한 사용을 위해 스캐너가 더 편리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="2f66b132ca8c3970b58c8bfa0ea1a17d65ac03b4" translate="yes" xml:space="preserve">
          <source>ReadCloser is the interface that groups the basic Read and Close methods.</source>
          <target state="translated">ReadCloser는 기본 Read 및 Close 메서드를 그룹화하는 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="db676df84bb4b6b56dfdcd9f6b6ecaede84207b6" translate="yes" xml:space="preserve">
          <source>ReadCodeLine reads a response code line of the form</source>
          <target state="translated">ReadCodeLine은 양식의 응답 코드 행을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="8ff6713d1fd28b36b70ff99ddd8c0b4506ace228" translate="yes" xml:space="preserve">
          <source>ReadContinuedLine reads a possibly continued line from r, eliding the final trailing ASCII white space. Lines after the first are considered continuations if they begin with a space or tab character. In the returned data, continuation lines are separated from the previous line only by a single space: the newline and leading white space are removed.</source>
          <target state="translated">ReadContinuedLine은 r에서 가능한 연속적인 행을 읽고 마지막 후행 ASCII 공백을 제거합니다. 공백이나 탭 문자로 시작하면 첫 번째 이후의 줄은 연속으로 간주됩니다. 반환 된 데이터에서 연속 줄은 단일 줄로만 이전 줄과 구분됩니다. 줄 바꿈과 선행 공백은 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="1e5b6ed6dd4e790ba932357704f154ece64c0736" translate="yes" xml:space="preserve">
          <source>ReadContinuedLineBytes is like ReadContinuedLine but returns a []byte instead of a string.</source>
          <target state="translated">ReadContinuedLineBytes는 ReadContinuedLine과 유사하지만 문자열 대신 [] 바이트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5967a3c48bcceae8eab866aea588318eebdf12d2" translate="yes" xml:space="preserve">
          <source>ReadDir</source>
          <target state="translated">ReadDir</target>
        </trans-unit>
        <trans-unit id="e3ffdfb2e99d8ad0f3e485d4bfcbe96628fa0f98" translate="yes" xml:space="preserve">
          <source>ReadDir reads and returns the entire named directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d24fd481881b94b17a7c225ebe811c636d045c9c" translate="yes" xml:space="preserve">
          <source>ReadDir reads the contents of the directory associated with the file f and returns a slice of DirEntry values in directory order. Subsequent calls on the same file will yield later DirEntry records in the directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72f7f069b44009fbb8ef194258dfcf70cde80055" translate="yes" xml:space="preserve">
          <source>ReadDir reads the directory named by dirname and returns a list of directory entries sorted by filename.</source>
          <target state="translated">ReadDir은 dirname으로 이름이 지정된 디렉토리를 읽고 filename별로 정렬 된 디렉토리 항목 목록을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="a117bc89ee7a58ce94a7bd20601b8394f08f3bdd" translate="yes" xml:space="preserve">
          <source>ReadDir reads the directory named by dirname and returns a list of fs.FileInfo for the directory's contents, sorted by filename. If an error occurs reading the directory, ReadDir returns no directory entries along with the error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b9ccff86903ac2da4f4f24340c2c76e4d2a37b1" translate="yes" xml:space="preserve">
          <source>ReadDir reads the named directory and returns a list of directory entries sorted by filename.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ac52331cecfd61e77a64c6ed3e845672b840901" translate="yes" xml:space="preserve">
          <source>ReadDir reads the named directory, returning all its directory entries sorted by filename. If an error occurs reading the directory, ReadDir returns the entries it was able to read before the error, along with the error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="901b3974155e855f8ae85e1ccd9e42646ec0dfe6" translate="yes" xml:space="preserve">
          <source>ReadDirFS is the interface implemented by a file system that provides an optimized implementation of ReadDir.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e66536e5f97de59d6908b95e869d13fc9d1ef4b6" translate="yes" xml:space="preserve">
          <source>ReadDotBytes reads a dot-encoding and returns the decoded data.</source>
          <target state="translated">ReadDotBytes는 도트 인코딩을 읽고 디코딩 된 데이터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9fa4950dafc4de63dd721dcb4ac0ca1c8418dcbe" translate="yes" xml:space="preserve">
          <source>ReadDotLines reads a dot-encoding and returns a slice containing the decoded lines, with the final \r\n or \n elided from each.</source>
          <target state="translated">ReadDotLines는 도트 인코딩을 읽고 마지막 \ r \ n 또는 \ n을 각각 빼고 디코딩 된 라인을 포함하는 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d7fd01a502310e8357802950d90a33ad1c88b094" translate="yes" xml:space="preserve">
          <source>ReadFile</source>
          <target state="translated">ReadFile</target>
        </trans-unit>
        <trans-unit id="ba2198b4c615c842eb050dcdc8f047c40682d77b" translate="yes" xml:space="preserve">
          <source>ReadFile reads and returns the content of the named file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3227226a36d1c67d762cccdcef04ee8eaa0dc15" translate="yes" xml:space="preserve">
          <source>ReadFile reads the file named by filename and returns the contents. A successful call returns err == nil, not err == EOF. Because ReadFile reads the whole file, it does not treat an EOF from Read as an error to be reported.</source>
          <target state="translated">ReadFile은 filename으로 이름이 지정된 파일을 읽고 내용을 반환합니다. 성공적인 호출은 err == EOF가 아니라 err == nil을 리턴합니다. ReadFile은 전체 파일을 읽으므로 Read의 EOF를보고 할 오류로 취급하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0184ee306277f6406b88bfbf30c84725887b7b06" translate="yes" xml:space="preserve">
          <source>ReadFile reads the named file and returns the contents. A successful call returns err == nil, not err == EOF. Because ReadFile reads the whole file, it does not treat an EOF from Read as an error to be reported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42ecfa7b59855d0a3784c20dd698c25d1d040885" translate="yes" xml:space="preserve">
          <source>ReadFile reads the named file from the file system fs and returns its contents. A successful call returns a nil error, not io.EOF. (Because ReadFile reads the whole file, the expected EOF from the final Read is not treated as an error to be reported.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c42b448471c62ad479643716bab34e4001debe6" translate="yes" xml:space="preserve">
          <source>ReadFileFS is the interface implemented by a file system that provides an optimized implementation of ReadFile.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af2c9d5288821671fae0d9ea11877f8aa4dfd64b" translate="yes" xml:space="preserve">
          <source>ReadForm parses an entire multipart message whose parts have a Content-Disposition of &quot;form-data&quot;. It stores up to maxMemory bytes + 10MB (reserved for non-file parts) in memory. File parts which can't be stored in memory will be stored on disk in temporary files. It returns ErrMessageTooLarge if all non-file parts can't be stored in memory.</source>
          <target state="translated">ReadForm은 파트가 &quot;form-data&quot;의 Content-Disposition을 갖는 전체 멀티 파트 메시지를 구문 분석합니다. 최대 maxMemory 바이트 + 10MB (비 파일 부분 용으로 예약 됨)를 메모리에 저장합니다. 메모리에 저장할 수없는 파일 부분은 디스크에 임시 파일로 저장됩니다. 파일이 아닌 모든 부분을 메모리에 저장할 수 없으면 ErrMessageTooLarge를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1ca77a9c7966395af7bb282b824bc2b56b183684" translate="yes" xml:space="preserve">
          <source>ReadFrom implements io.ReaderFrom.</source>
          <target state="translated">ReadFrom은 io.ReaderFrom을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="0e93b4927342ab7184e8df9a62d919ab56aa652d" translate="yes" xml:space="preserve">
          <source>ReadFrom implements io.ReaderFrom. If the underlying writer supports the ReadFrom method, and b has no buffered data yet, this calls the underlying ReadFrom without buffering.</source>
          <target state="translated">ReadFrom은 io.ReaderFrom을 구현합니다. 기본 작성기가 ReadFrom 메소드를 지원하고 b에 아직 버퍼링 된 데이터가없는 경우 버퍼링없이 기본 ReadFrom을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="deeb7efc315fb646ef56c6fc1f93867b106373b0" translate="yes" xml:space="preserve">
          <source>ReadFrom implements the PacketConn ReadFrom method.</source>
          <target state="translated">ReadFrom은 PacketConn ReadFrom 메소드를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="f608142e8cc80b99bfcbe865eecfbb0322dd6e96" translate="yes" xml:space="preserve">
          <source>ReadFrom implements the io.ReaderFrom ReadFrom method.</source>
          <target state="translated">ReadFrom은 io.ReaderFrom ReadFrom 메소드를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="00b3806bd8fc8bcfbcad0f6f7f7286cb5b8785f4" translate="yes" xml:space="preserve">
          <source>ReadFrom reads data from r until EOF and appends it to the buffer, growing the buffer as needed. The return value n is the number of bytes read. Any error except io.EOF encountered during the read is also returned. If the buffer becomes too large, ReadFrom will panic with ErrTooLarge.</source>
          <target state="translated">ReadFrom은 r에서 EOF까지 데이터를 읽고 버퍼에 추가하여 필요에 따라 버퍼를 증가시킵니다. 리턴 값 n은 읽은 바이트 수입니다. 읽기 중에 발생한 io.EOF를 제외한 모든 오류도 반환됩니다. 버퍼가 너무 커지면 ReadFrom은 ErrTooLarge와 함께 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="6cc11523bdab806a0f9e0e27c50d4a9d778ad3ce" translate="yes" xml:space="preserve">
          <source>ReadFrom reads data from r until EOF or error. The return value n is the number of bytes read. Any error except EOF encountered during the read is also returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="454fdea2d34a8c45cb668b5c543dbc3f7058787c" translate="yes" xml:space="preserve">
          <source>ReadFrom reads data from r until EOF or error. The return value n is the number of bytes read. Any error except io.EOF encountered during the read is also returned.</source>
          <target state="translated">ReadFrom은 r에서 EOF 또는 오류까지 데이터를 읽습니다. 리턴 값 n은 읽은 바이트 수입니다. 읽기 중에 발생한 io.EOF를 제외한 모든 오류도 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ea32f98cbdf74be7e58789bf5c2555022985c09b" translate="yes" xml:space="preserve">
          <source>ReadFromIP acts like ReadFrom but returns an IPAddr.</source>
          <target state="translated">ReadFromIP는 ReadFrom처럼 작동하지만 IPAddr을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="95ff932341b82ae81f7960462c1442dddf49af3c" translate="yes" xml:space="preserve">
          <source>ReadFromUDP acts like ReadFrom but returns a UDPAddr.</source>
          <target state="translated">ReadFromUDP는 ReadFrom처럼 작동하지만 UDPAddr을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="715d754a562178b348b7a0a9528cfbf66635230e" translate="yes" xml:space="preserve">
          <source>ReadFromUnix acts like ReadFrom but returns a UnixAddr.</source>
          <target state="translated">ReadFromUnix는 ReadFrom처럼 작동하지만 UnixAddr을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6b877746bfc4fdb60829d292eb383e9e72074e71" translate="yes" xml:space="preserve">
          <source>ReadFull</source>
          <target state="translated">ReadFull</target>
        </trans-unit>
        <trans-unit id="f41363ee55bdca4d655d8c43955b9b66f37cac52" translate="yes" xml:space="preserve">
          <source>ReadFull reads exactly len(buf) bytes from r into buf. It returns the number of bytes copied and an error if fewer bytes were read. The error is EOF only if no bytes were read. If an EOF happens after reading some but not all the bytes, ReadFull returns ErrUnexpectedEOF. On return, n == len(buf) if and only if err == nil. If r returns an error having read at least len(buf) bytes, the error is dropped.</source>
          <target state="translated">ReadFull은 r에서 buf로 정확히 len (buf) 바이트를 읽습니다. 적은 바이트를 읽은 경우 복사 된 바이트 수와 오류를 반환합니다. 읽은 바이트가없는 경우에만 오류가 EOF입니다. 일부 바이트 만 읽은 후 EOF가 발생하면 ReadFull은 ErrUnexpectedEOF를 반환합니다. 리턴시, err == nil 인 경우에만 n == len (buf). r이 len (buf) 바이트 이상을 읽은 오류를 리턴하면 오류가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="4528be7d31ac119b15adb0d44e8e10acc6a61277" translate="yes" xml:space="preserve">
          <source>ReadGCStats reads statistics about garbage collection into stats. The number of entries in the pause history is system-dependent; stats.Pause slice will be reused if large enough, reallocated otherwise. ReadGCStats may use the full capacity of the stats.Pause slice. If stats.PauseQuantiles is non-empty, ReadGCStats fills it with quantiles summarizing the distribution of pause time. For example, if len(stats.PauseQuantiles) is 5, it will be filled with the minimum, 25%, 50%, 75%, and maximum pause times.</source>
          <target state="translated">ReadGCStats는 가비지 수집에 대한 통계를 통계로 읽습니다. 일시 정지 내역의 항목 수는 시스템에 따라 다릅니다. 일시 정지 슬라이스는 충분히 큰 경우 재사용되고, 그렇지 않으면 재 할당됩니다. ReadGCStats는 통계의 전체 용량을 사용할 수 있습니다. stats.PauseQuantiles가 비어 있지 않으면 ReadGCStats는 일시 정지 시간의 분포를 요약 한 Quantile로 채 웁니다. 예를 들어 len (stats.PauseQuantiles)이 5 인 경우 최소, 25 %, 50 %, 75 % 및 최대 일시 정지 시간으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="a6882fab97e53a8d3c4b1deb078269fff567ed19" translate="yes" xml:space="preserve">
          <source>ReadLine is a low-level line-reading primitive. Most callers should use ReadBytes('\n') or ReadString('\n') instead or use a Scanner.</source>
          <target state="translated">ReadLine은 저수준 라인 판독 프리미티브입니다. 대부분의 호출자는 대신 ReadBytes ( '\ n') 또는 ReadString ( '\ n')을 사용하거나 스캐너를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="70e3e4d68a5bd26786fe6816067d028f52581c71" translate="yes" xml:space="preserve">
          <source>ReadLine reads a single line from r, eliding the final \n or \r\n from the returned string.</source>
          <target state="translated">ReadLine은 r에서 단일 행을 읽고 리턴 된 문자열에서 최종 \ n 또는 \ r \ n을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="d5bdeff155b2aec65cb49ea2eabeba1181d7c31c" translate="yes" xml:space="preserve">
          <source>ReadLine tries to return a single line, not including the end-of-line bytes. If the line was too long for the buffer then isPrefix is set and the beginning of the line is returned. The rest of the line will be returned from future calls. isPrefix will be false when returning the last fragment of the line. The returned buffer is only valid until the next call to ReadLine. ReadLine either returns a non-nil line or it returns an error, never both.</source>
          <target state="translated">ReadLine은 행 끝 바이트를 포함하지 않고 단일 행을 리턴하려고합니다. 행이 버퍼에 비해 너무 길면 isPrefix가 설정되고 행의 시작이 리턴됩니다. 나머지 회선은 향후 통화에서 반환됩니다. 줄의 마지막 조각을 반환하면 isPrefix는 false입니다. 반환 된 버퍼는 다음에 ReadLine을 호출 할 때까지만 유효합니다. ReadLine은 0이 아닌 라인을 리턴하거나 오류를 리턴합니다 (둘다는 아님).</target>
        </trans-unit>
        <trans-unit id="30af98b166430a4d07ac11a60a37dce8c9897d44" translate="yes" xml:space="preserve">
          <source>ReadLineBytes is like ReadLine but returns a []byte instead of a string.</source>
          <target state="translated">ReadLineBytes는 ReadLine과 유사하지만 문자열 대신 [] 바이트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="34955aedc1edab445c06914ea85435c83aa1659d" translate="yes" xml:space="preserve">
          <source>ReadMIMEHeader reads a MIME-style header from r. The header is a sequence of possibly continued Key: Value lines ending in a blank line. The returned map m maps CanonicalMIMEHeaderKey(key) to a sequence of values in the same order encountered in the input.</source>
          <target state="translated">ReadMIMEHeader는 r에서 MIME 스타일 헤더를 읽습니다. 헤더는 가능한 연속 키입니다. 빈 줄로 끝나는 값 줄. 리턴 된 맵 m은 CanonicalMIMEHeaderKey (key)를 입력에서 발견 된 것과 동일한 순서로 일련의 값으로 맵핑합니다.</target>
        </trans-unit>
        <trans-unit id="e81ba86f59e436daff158e41fbec08f65b2c4f42" translate="yes" xml:space="preserve">
          <source>ReadMemStats populates m with memory allocator statistics.</source>
          <target state="translated">ReadMemStats는 m을 메모리 할당 자 통계로 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="acb49a6f36fe4a7034527475afbfe7647980d6b9" translate="yes" xml:space="preserve">
          <source>ReadMessage</source>
          <target state="translated">ReadMessage</target>
        </trans-unit>
        <trans-unit id="1551b34da55e8d458cfae44e4a334da9f414dea8" translate="yes" xml:space="preserve">
          <source>ReadMessage reads a message from r. The headers are parsed, and the body of the message will be available for reading from msg.Body.</source>
          <target state="translated">ReadMessage는 r에서 메시지를 읽습니다. 헤더가 구문 분석되고 메시지 본문을 msg.Body에서 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f05b0c16954598270f35347bda5383a6c522b11" translate="yes" xml:space="preserve">
          <source>ReadMsgIP reads a message from c, copying the payload into b and the associated out-of-band data into oob. It returns the number of bytes copied into b, the number of bytes copied into oob, the flags that were set on the message and the source address of the message.</source>
          <target state="translated">ReadMsgIP는 c에서 메시지를 읽고 페이로드를 b에 복사하고 연관된 대역 외 데이터를 oob에 복사합니다. b에 복사 된 바이트 수, oob에 복사 된 바이트 수, 메시지에 설정된 플래그 및 메시지의 소스 주소를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="47bd88248b7a6aeb9fe7003935965fcbc4c14b6e" translate="yes" xml:space="preserve">
          <source>ReadMsgUDP reads a message from c, copying the payload into b and the associated out-of-band data into oob. It returns the number of bytes copied into b, the number of bytes copied into oob, the flags that were set on the message and the source address of the message.</source>
          <target state="translated">ReadMsgUDP는 c에서 메시지를 읽고 페이로드를 b에 복사하고 연관된 대역 외 데이터를 oob에 복사합니다. b에 복사 된 바이트 수, oob에 복사 된 바이트 수, 메시지에 설정된 플래그 및 메시지의 소스 주소를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="f80f0770ba07805dfad9fed9021802994b16c79f" translate="yes" xml:space="preserve">
          <source>ReadMsgUnix reads a message from c, copying the payload into b and the associated out-of-band data into oob. It returns the number of bytes copied into b, the number of bytes copied into oob, the flags that were set on the message and the source address of the message.</source>
          <target state="translated">ReadMsgUnix는 c에서 메시지를 읽고 페이로드를 b에 복사하고 연관된 대역 외 데이터를 oob에 복사합니다. b에 복사 된 바이트 수, oob에 복사 된 바이트 수, 메시지에 설정된 플래그 및 메시지의 소스 주소를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="25bb46ad3055b508b0608be3bcb05d4dc7a218ac" translate="yes" xml:space="preserve">
          <source>ReadRequest is a low-level function and should only be used for specialized applications; most code should use the Server to read requests and handle them via the Handler interface. ReadRequest only supports HTTP/1.x requests. For HTTP/2, use golang.org/x/net/http2.</source>
          <target state="translated">ReadRequest는 저수준 기능이며 특수 응용 프로그램에만 사용해야합니다. 대부분의 코드는 서버를 사용하여 요청을 읽고 처리기 인터페이스를 통해 처리해야합니다. ReadRequest는 HTTP / 1.x 요청 만 지원합니다. HTTP / 2의 경우 golang.org/x/net/http2를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b1b66f29f0f459c92aabcbebb68a77d5a6970744" translate="yes" xml:space="preserve">
          <source>ReadRequest reads and parses an incoming request from b.</source>
          <target state="translated">ReadRequest는 b에서 들어오는 요청을 읽고 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="25d27159145d0774b1fadc397fe48b995c46c5de" translate="yes" xml:space="preserve">
          <source>ReadResponse reads a multi-line response of the form:</source>
          <target state="translated">ReadResponse는 다음 형식의 여러 줄 응답을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="ee99ce8c11934415337cdc7bec2e604ef18e71ae" translate="yes" xml:space="preserve">
          <source>ReadResponse reads and returns an HTTP response from r. The req parameter optionally specifies the Request that corresponds to this Response. If nil, a GET request is assumed. Clients must call resp.Body.Close when finished reading resp.Body. After that call, clients can inspect resp.Trailer to find key/value pairs included in the response trailer.</source>
          <target state="translated">ReadResponse는 r에서 HTTP 응답을 읽고 리턴합니다. req 매개 변수는 선택적으로이 응답에 해당하는 요청을 지정합니다. nil 인 경우 GET 요청이 가정됩니다. resp.Body를 읽었 으면 클라이언트는 resp.Body.Close를 호출해야합니다. 이 호출 후 고객은 응답 트레일러에 포함 된 키 / 값 쌍을 찾기 위해 resp.Trailer를 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="476255423e82d011c96cc157a1f2c1336b3b2a0a" translate="yes" xml:space="preserve">
          <source>ReadRune implements the io.RuneReader interface.</source>
          <target state="translated">ReadRune은 io.RuneReader 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="2149703d832b9af2c76dd9abfe510fdf6ec21b40" translate="yes" xml:space="preserve">
          <source>ReadRune reads a single UTF-8 encoded Unicode character and returns the rune and its size in bytes. If no character is available, err will be set.</source>
          <target state="translated">ReadRune은 UTF-8로 인코딩 된 단일 유니 코드 문자를 읽고 룬과 크기를 바이트 단위로 반환합니다. 사용 가능한 문자가 없으면 err이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="6414ea883495287275cdc53b35ffd14e0008ac3b" translate="yes" xml:space="preserve">
          <source>ReadRune reads a single UTF-8 encoded Unicode character and returns the rune and its size in bytes. If the encoded rune is invalid, it consumes one byte and returns unicode.ReplacementChar (U+FFFD) with a size of 1.</source>
          <target state="translated">ReadRune은 UTF-8로 인코딩 된 단일 유니 코드 문자를 읽고 룬과 크기를 바이트 단위로 반환합니다. 인코딩 된 룬이 유효하지 않은 경우 1 바이트를 소비하고 크기가 1 인 unicode.ReplacementChar (U + FFFD)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6486828e56b295be35e03a3674dd21e96b49a79c" translate="yes" xml:space="preserve">
          <source>ReadRune reads and returns the next UTF-8-encoded Unicode code point from the buffer. If no bytes are available, the error returned is io.EOF. If the bytes are an erroneous UTF-8 encoding, it consumes one byte and returns U+FFFD, 1.</source>
          <target state="translated">ReadRune은 버퍼에서 다음 UTF-8로 인코딩 된 유니 코드 코드 포인트를 읽고 리턴합니다. 사용 가능한 바이트가 없으면 반환 된 오류는 io.EOF입니다. 바이트가 잘못된 UTF-8 인코딩 인 경우 1 바이트를 소비하고 U + FFFD, 1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="27b545019c29fef4339b5d0234bb596b1ca821e9" translate="yes" xml:space="preserve">
          <source>ReadSeekCloser is the interface that groups the basic Read, Seek and Close methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78176debea1a291ba3e7ca916182c7ec7d43ab66" translate="yes" xml:space="preserve">
          <source>ReadSeeker is the interface that groups the basic Read and Seek methods.</source>
          <target state="translated">ReadSeeker는 기본 Read 및 Seek 메소드를 그룹화하는 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="6f83dddca1aa94fb6e401f10df5bd11c4e328c97" translate="yes" xml:space="preserve">
          <source>ReadSlice reads until the first occurrence of delim in the input, returning a slice pointing at the bytes in the buffer. The bytes stop being valid at the next read. If ReadSlice encounters an error before finding a delimiter, it returns all the data in the buffer and the error itself (often io.EOF). ReadSlice fails with error ErrBufferFull if the buffer fills without a delim. Because the data returned from ReadSlice will be overwritten by the next I/O operation, most clients should use ReadBytes or ReadString instead. ReadSlice returns err != nil if and only if line does not end in delim.</source>
          <target state="translated">ReadSlice는 입력에서 delim이 처음 나타날 때까지 읽고 버퍼의 바이트를 가리키는 슬라이스를 반환합니다. 바이트는 다음에 읽을 때 유효하지 않습니다. 분리 문자를 찾기 전에 ReadSlice에서 오류가 발생하면 버퍼의 모든 데이터와 오류 자체 (종종 io.EOF)를 리턴합니다. 버퍼가 제한없이 채워지면 ReadSlice가 오류 ErrBufferFull과 함께 실패합니다. ReadSlice에서 반환 된 데이터는 다음 I / O 작업으로 덮어 쓰므로 대부분의 클라이언트는 ReadBytes 또는 ReadString을 대신 사용해야합니다. 라인이 delim로 끝나지 않는 경우에만 ReadSlice가 err! = nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="396715e6dd5c32bdbbf83af9027e47c30dc1faa8" translate="yes" xml:space="preserve">
          <source>ReadString reads until the first occurrence of delim in the input, returning a string containing the data up to and including the delimiter. If ReadString encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often io.EOF). ReadString returns err != nil if and only if the returned data does not end in delim.</source>
          <target state="translated">ReadString은 입력에서 delim이 처음 나타날 때까지 읽고 구분 기호까지 포함 된 데이터를 포함하는 문자열을 반환합니다. 구분 기호를 찾기 전에 ReadString에서 오류가 발생하면 오류 이전에 읽은 데이터와 오류 자체 (종종 io.EOF)를 반환합니다. ReadString은 반환 된 데이터가 delim로 끝나지 않는 경우에만 err! = nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="aaa3e0c7b34f04c5ff175180dbf3748d0757b57f" translate="yes" xml:space="preserve">
          <source>ReadString reads until the first occurrence of delim in the input, returning a string containing the data up to and including the delimiter. If ReadString encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often io.EOF). ReadString returns err != nil if and only if the returned data does not end in delim. For simple uses, a Scanner may be more convenient.</source>
          <target state="translated">ReadString은 입력에서 delim이 처음 나타날 때까지 읽고 구분 기호까지 포함 된 데이터를 포함하는 문자열을 반환합니다. 구분 기호를 찾기 전에 ReadString에서 오류가 발생하면 오류 이전에 읽은 데이터와 오류 자체 (종종 io.EOF)를 반환합니다. ReadString은 반환 된 데이터가 delim로 끝나지 않는 경우에만 err! = nil을 반환합니다. 간단한 사용을 위해 스캐너가 더 편리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="24714d7c8185be718fff60550f6b7e029b2b159c" translate="yes" xml:space="preserve">
          <source>ReadTrace returns the next chunk of binary tracing data, blocking until data is available. If tracing is turned off and all the data accumulated while it was on has been returned, ReadTrace returns nil. The caller must copy the returned data before calling ReadTrace again. ReadTrace must be called from one goroutine at a time.</source>
          <target state="translated">ReadTrace는 다음 이진 추적 데이터 청크를 반환하여 데이터를 사용할 수있을 때까지 차단합니다. 추적이 꺼져 있고 켜져있는 동안 누적 된 모든 데이터가 반환되면 ReadTrace는 nil을 반환합니다. 호출자는 ReadTrace를 다시 호출하기 전에 반환 된 데이터를 복사해야합니다. 한 번에 하나의 고 루틴에서 ReadTrace를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="989bf43b9a2dfe020990e99dd409325328b3ade3" translate="yes" xml:space="preserve">
          <source>ReadUvarint reads an encoded unsigned integer from r and returns it as a uint64.</source>
          <target state="translated">ReadUvarint는 r에서 인코딩 된 부호없는 정수를 읽고 uint64로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="675541f596de4c802da653f83b46f8b7718858d0" translate="yes" xml:space="preserve">
          <source>ReadVarint reads an encoded signed integer from r and returns it as an int64.</source>
          <target state="translated">ReadVarint는 r에서 인코딩 된 부호있는 정수를 읽고 int64로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="069fcaa32c060bf9bd8bfac5e82274aaead1bc50" translate="yes" xml:space="preserve">
          <source>ReadWriteCloser is the interface that groups the basic Read, Write and Close methods.</source>
          <target state="translated">ReadWriteCloser는 기본 Read, Write 및 Close 메서드를 그룹화하는 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="341b30c9c3b78089bcaa44b8a26a94b9bc0c8ea6" translate="yes" xml:space="preserve">
          <source>ReadWriteSeeker is the interface that groups the basic Read, Write and Seek methods.</source>
          <target state="translated">ReadWriteSeeker는 기본 Read, Write 및 Seek 메서드를 그룹화하는 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="eb7ce11fb3f6f0101cd6b5288463e8de90a96b51" translate="yes" xml:space="preserve">
          <source>ReadWriter is the interface that groups the basic Read and Write methods.</source>
          <target state="translated">ReadWriter는 기본 Read 및 Write 메서드를 그룹화하는 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="dfaac4087d8cb10eb5b8f29ddefebdcafd42a5af" translate="yes" xml:space="preserve">
          <source>ReadWriter stores pointers to a Reader and a Writer. It implements io.ReadWriter.</source>
          <target state="translated">ReadWriter는 Reader 및 Writer에 대한 포인터를 저장합니다. io.ReadWriter를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="79f16a4d9874784deac866dfbd0ce6545be6e239" translate="yes" xml:space="preserve">
          <source>Readdir reads the contents of the directory associated with file and returns a slice of up to n FileInfo values, as would be returned by Lstat, in directory order. Subsequent calls on the same file will yield further FileInfos.</source>
          <target state="translated">Readdir은 파일과 연관된 디렉토리의 내용을 읽고 Lstat에 의해 리턴되는 최대 n 개의 FileInfo 값의 슬라이스를 디렉토리 순서로 리턴합니다. 동일한 파일에 대한 후속 호출은 추가 FileInfo를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="501d22e73b2af73a4cd2cda27f0147a879d2d29f" translate="yes" xml:space="preserve">
          <source>Readdirnames reads the contents of the directory associated with file and returns a slice of up to n names of files in the directory, in directory order. Subsequent calls on the same file will yield further names.</source>
          <target state="translated">Readdirnames는 파일과 연관된 디렉토리의 내용을 읽고 디렉토리에있는 디렉토리에서 최대 n 개의 파일 이름 슬라이스를 디렉토리 순서로 리턴합니다. 동일한 파일에 대한 후속 호출은 추가 이름을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="ac5bbe8292ed1b69e0f95e5bdaa035569a295fd7" translate="yes" xml:space="preserve">
          <source>Reader</source>
          <target state="translated">Reader</target>
        </trans-unit>
        <trans-unit id="a764e12131a971febc3401d23317f0234b4049b8" translate="yes" xml:space="preserve">
          <source>Reader (Options)</source>
          <target state="translated">리더 (옵션)</target>
        </trans-unit>
        <trans-unit id="df3472ca3dd5a57262b56d74dcad15e820ebf2eb" translate="yes" xml:space="preserve">
          <source>Reader implements buffering for an io.Reader object.</source>
          <target state="translated">Reader는 io.Reader 객체에 대한 버퍼링을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="96784a034a712bc8c815b4587872dbfdfd0582a9" translate="yes" xml:space="preserve">
          <source>Reader is a global, shared instance of a cryptographically secure random number generator.</source>
          <target state="translated">Reader는 암호로 안전한 난수 생성기의 글로벌 공유 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="bf613e0e0a803852368392b2dfe7b4682657c458" translate="yes" xml:space="preserve">
          <source>Reader is a quoted-printable decoder.</source>
          <target state="translated">Reader는 인용 인쇄 가능한 디코더입니다.</target>
        </trans-unit>
        <trans-unit id="b49691ad8407ed7de43e614957e75ec4095c4b28" translate="yes" xml:space="preserve">
          <source>Reader is an iterator over parts in a MIME multipart body. Reader's underlying parser consumes its input as needed. Seeking isn't supported.</source>
          <target state="translated">Reader는 MIME 멀티 파트 바디의 파트에 대한 반복자입니다. Reader의 기본 파서는 필요에 따라 입력을 사용합니다. 검색이 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="21dadd14b38a36c18741cf2c47ad38cb0675eedf" translate="yes" xml:space="preserve">
          <source>Reader is the interface that wraps the basic Read method.</source>
          <target state="translated">Reader는 기본 Read 메서드를 래핑하는 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="9bdf18ff83881db62f68bf47e6ac4c6f41d55f66" translate="yes" xml:space="preserve">
          <source>Reader provides sequential access to the contents of a tar archive. Reader.Next advances to the next file in the archive (including the first), and then Reader can be treated as an io.Reader to access the file's data.</source>
          <target state="translated">Reader는 tar 아카이브의 내용에 순차적으로 액세스 할 수 있습니다. Reader.Next는 아카이브의 다음 파일 (첫 번째 파일 포함)로 진행 한 다음 Reader를 io.Reader로 처리하여 파일 데이터에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cac70aa62b26f1281fbe4d19090a262412eed7e3" translate="yes" xml:space="preserve">
          <source>Reader returns a new Reader for Data. The reader is positioned at byte offset 0 in the DWARF &amp;ldquo;info&amp;rdquo; section.</source>
          <target state="translated">Reader는 새로운 Reader for Data를 반환합니다. 리더는 DWARF&amp;ldquo;정보&amp;rdquo;섹션에서 바이트 오프셋 0에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="8049ec93e81c7083091b44ed801d9d9d92c309d9" translate="yes" xml:space="preserve">
          <source>Reader, to read numeric response code lines, key: value headers, lines wrapped with leading spaces on continuation lines, and whole text blocks ending with a dot on a line by itself.</source>
          <target state="translated">숫자 응답 코드 행을 읽는 판독기, 키 : 값 헤더, 연속 행의 선행 공백으로 줄 바꿈 된 행 및 행 자체로 점으로 끝나는 전체 텍스트 블록</target>
        </trans-unit>
        <trans-unit id="d0009a603321ffa4322fc5ace74c08013f3502dc" translate="yes" xml:space="preserve">
          <source>Reader.Len</source>
          <target state="translated">Reader.Len</target>
        </trans-unit>
        <trans-unit id="52b9ae6b2c685e2a877bd9bbf8defead7e5d5ac7" translate="yes" xml:space="preserve">
          <source>Reader.Multistream</source>
          <target state="translated">Reader.Multistream</target>
        </trans-unit>
        <trans-unit id="23e9cef150e9609032f02dcc6e3ec9a05ca806c3" translate="yes" xml:space="preserve">
          <source>Reader.ReadAll</source>
          <target state="translated">Reader.ReadAll</target>
        </trans-unit>
        <trans-unit id="976c7b59d336efab6bbe07f071aa8d432cb7a047" translate="yes" xml:space="preserve">
          <source>ReaderAt is the interface that wraps the basic ReadAt method.</source>
          <target state="translated">ReaderAt는 기본 ReadAt 메소드를 래핑하는 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="29ae6f40e1ba95a55db0a9760f63eada1ab4e398" translate="yes" xml:space="preserve">
          <source>ReaderFrom is the interface that wraps the ReadFrom method.</source>
          <target state="translated">ReaderFrom은 ReadFrom 메서드를 래핑하는 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="b5bdadfe357edf2d398dc3767642063de731a14c" translate="yes" xml:space="preserve">
          <source>Readlink returns the destination of the named symbolic link. If there is an error, it will be of type *PathError.</source>
          <target state="translated">Readlink는 명명 된 심볼릭 링크의 대상을 반환합니다. 오류가 있으면 * PathError 유형입니다.</target>
        </trans-unit>
        <trans-unit id="3680e45cb759e7b231139c55beb835dcb36f290f" translate="yes" xml:space="preserve">
          <source>Reads and Writes on the pipe are matched one to one except when multiple Reads are needed to consume a single Write. That is, each Write to the PipeWriter blocks until it has satisfied one or more Reads from the PipeReader that fully consume the written data. The data is copied directly from the Write to the corresponding Read (or Reads); there is no internal buffering.</source>
          <target state="translated">파이프의 읽기 및 쓰기는 단일 쓰기를 소비하기 위해 여러 읽기가 필요한 경우를 제외하고 일대일로 일치합니다. 즉, PipeWriter에 대한 각 쓰기는 작성된 데이터를 완전히 소비하는 PipeReader에서 하나 이상의 읽기를 충족 할 때까지 차단됩니다. 데이터는 쓰기에서 해당 읽기 (또는 읽기)로 직접 복사됩니다. 내부 버퍼링이 없습니다.</target>
        </trans-unit>
        <trans-unit id="96964e0a893395e3b89017fa3370fe50203e0f58" translate="yes" xml:space="preserve">
          <source>Real returns the real part of x, which must be a numeric or unknown value. If x is Unknown, the result is Unknown.</source>
          <target state="translated">실수는 x의 실수 부분을 반환하며, 숫자 또는 알 수없는 값이어야합니다. x가 알 수없는 경우 결과는 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a4e7e73832091a1dd0eb45c5e3535f9fc0bb0385" translate="yes" xml:space="preserve">
          <source>ReceiverName returns the receiver type name of this symbol, or the empty string if there is none.</source>
          <target state="translated">ReceiverName은이 심볼의 수신자 유형 이름을 반환하거나 존재하지 않는 경우 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="76042968d1a5f484d7ec99013213446b06dc9be8" translate="yes" xml:space="preserve">
          <source>Receivers should be careful to use Equal to compare MACs in order to avoid timing side-channels:</source>
          <target state="translated">수신기는 타이밍 사이드 채널을 피하기 위해 Equal을 사용하여 MAC을 비교하도록주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="baede57b4fd75bbaf39e019c76771e5b57cbf06e" translate="yes" xml:space="preserve">
          <source>RecordHeaderError is returned when a TLS record header is invalid.</source>
          <target state="translated">TLS 레코드 헤더가 유효하지 않으면 RecordHeaderError가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="2614b13193f400f1a9992deddc528f2f896c1029" translate="yes" xml:space="preserve">
          <source>Rect is shorthand for Rectangle{Pt(x0, y0), Pt(x1, y1)}. The returned rectangle has minimum and maximum coordinates swapped if necessary so that it is well-formed.</source>
          <target state="translated">Rectangle {Pt (x0, y0), Pt (x1, y1)}의 약어입니다. 반환 된 사각형에는 필요한 경우 올바른 최소값과 최대 좌표가 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="1937bfd09178388c39ec43cf08d134d3d9d1898f" translate="yes" xml:space="preserve">
          <source>Rect returns the complex number x with polar coordinates r, &amp;theta;.</source>
          <target state="translated">Rect는 극좌표 r, &amp;theta;를 갖는 복소수 x를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="94dab483158e13564ee6a455c353913588b6dbd1" translate="yes" xml:space="preserve">
          <source>Recv receives and returns a value from the channel v. It panics if v's Kind is not Chan. The receive blocks until a value is ready. The boolean value ok is true if the value x corresponds to a send on the channel, false if it is a zero value received because the channel is closed.</source>
          <target state="translated">Recv는 채널 v에서 값을 받아서 반환합니다. v의 Kind가 Chan이 아닌 경우 패닉이 발생합니다. 값이 준비 될 때까지 수신이 차단됩니다. 부울 값 ok는 값 x가 채널의 전송에 해당하면 true이고, 채널이 닫혀서 수신 된 0 값이면 false입니다.</target>
        </trans-unit>
        <trans-unit id="03b8f406324956c22ef3f439d41bfd0bef6159ba" translate="yes" xml:space="preserve">
          <source>Recv returns the receiver of signature s (if a method), or nil if a function. It is ignored when comparing signatures for identity.</source>
          <target state="translated">Recv는 서명의 수신자 (메소드 인 경우) 또는 함수 인 경우 nil을 리턴합니다. 신원에 대한 서명을 비교할 때는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="5ae5c546dd23f367221f8f4d367950523d9cf3bb" translate="yes" xml:space="preserve">
          <source>Recv returns the type of x in x.f.</source>
          <target state="translated">Recv는 xf의 x 유형을 반환합니다</target>
        </trans-unit>
        <trans-unit id="b921a74df750022333aabad842917542b9bf6fc4" translate="yes" xml:space="preserve">
          <source>Redacted is like String but replaces any password with &quot;xxxxx&quot;. Only the password in u.URL is redacted.</source>
          <target state="translated">수정 됨은 문자열과 같지만 모든 비밀번호를 &quot;xxxxx&quot;로 바꿉니다. u.URL의 비밀번호 만 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="9250d7c2a971eb24cc4eedcfff481ae3439946cf" translate="yes" xml:space="preserve">
          <source>Redirect replies to the request with a redirect to url, which may be a path relative to the request path.</source>
          <target state="translated">리디렉션은 요청 경로에 상대적인 경로 일 수있는 url로 리디렉션하여 요청에 응답합니다.</target>
        </trans-unit>
        <trans-unit id="c909a75a26a89b05691be1108e0ab3c2e1bcdb1a" translate="yes" xml:space="preserve">
          <source>RedirectHandler returns a request handler that redirects each request it receives to the given url using the given status code.</source>
          <target state="translated">RedirectHandler는 주어진 상태 코드를 사용하여 수신 한 각 요청을 지정된 URL로 경로 재지 정하는 요청 핸들러를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="9d1e4e7d27b519b1da3d7266c9c87d7861741080" translate="yes" xml:space="preserve">
          <source>References:</source>
          <target state="translated">References:</target>
        </trans-unit>
        <trans-unit id="d6ec8155461c38d823e4b635ac46022ba360bb68" translate="yes" xml:space="preserve">
          <source>Referer is misspelled as in the request itself, a mistake from the earliest days of HTTP. This value can also be fetched from the Header map as Header[&quot;Referer&quot;]; the benefit of making it available as a method is that the compiler can diagnose programs that use the alternate (correct English) spelling req.Referrer() but cannot diagnose programs that use Header[&quot;Referrer&quot;].</source>
          <target state="translated">요청 자체에서와 같이 리퍼러의 철자가 잘못되었습니다. HTTP 초기 시절의 실수입니다. 이 값은 헤더 맵에서 Header [ &quot;Referer&quot;]로 가져올 수도 있습니다. 메소드로 사용 가능하게하는 이점은 컴파일러에서 대체 (올바른 영어) 철자 req.Referrer ()를 사용하는 프로그램은 진단 할 수 있지만 Header [ &quot;Referrer&quot;]를 사용하는 프로그램은 진단 할 수 없다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="07d5e3dfcd70520a1bbdb2fa9dbe2bae91c99a57" translate="yes" xml:space="preserve">
          <source>Referer returns the referring URL, if sent in the request.</source>
          <target state="translated">리퍼러는 요청에 전송 된 경우 참조 URL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6ac251dfde6b7c655d39dbc21c40c658e7f0e5ba" translate="yes" xml:space="preserve">
          <source>Regardless of the verb, if an operand is an interface value, the internal concrete value is used, not the interface itself. Thus:</source>
          <target state="translated">동사에 관계없이 피연산자가 인터페이스 값이면 인터페이스 자체가 아니라 내부 콘크리트 값이 사용됩니다. 그러므로:</target>
        </trans-unit>
        <trans-unit id="ae8b91c59ed7a48ada5b7396ec353e27cc7c57cd" translate="yes" xml:space="preserve">
          <source>Regexp is the representation of a compiled regular expression. A Regexp is safe for concurrent use by multiple goroutines, except for configuration methods, such as Longest.</source>
          <target state="translated">정규 표현식은 컴파일 된 정규 표현식을 나타냅니다. Regexp는 Longest와 같은 구성 방법을 제외하고 여러 고 루틴이 동시에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b84f40722bc57d5dce890a8a11e5c4fee08f3c9c" translate="yes" xml:space="preserve">
          <source>Regexp.Expand</source>
          <target state="translated">Regexp.Expand</target>
        </trans-unit>
        <trans-unit id="3dd017106e6cb747b2a0cd305e5bb9fdade3a8d1" translate="yes" xml:space="preserve">
          <source>Regexp.ExpandString</source>
          <target state="translated">Regexp.ExpandString</target>
        </trans-unit>
        <trans-unit id="ec3956758c005d81eaf9415a4c61a2390b4ec0f2" translate="yes" xml:space="preserve">
          <source>Regexp.Find</source>
          <target state="translated">Regexp.Find</target>
        </trans-unit>
        <trans-unit id="5a4d1168fbbea65dfa0185be8ce3c71cdc597f4b" translate="yes" xml:space="preserve">
          <source>Regexp.FindAll</source>
          <target state="translated">Regexp.FindAll</target>
        </trans-unit>
        <trans-unit id="c5811b80e718b804e1204a3871c02f744194e46b" translate="yes" xml:space="preserve">
          <source>Regexp.FindAllIndex</source>
          <target state="translated">Regexp.FindAllIndex</target>
        </trans-unit>
        <trans-unit id="9a7a55d789a0b84db34a38b56a2f4242a4cf127c" translate="yes" xml:space="preserve">
          <source>Regexp.FindAllString</source>
          <target state="translated">Regexp.FindAllString</target>
        </trans-unit>
        <trans-unit id="f7e56583e4dcc297ccf2aa23c322191411764c7e" translate="yes" xml:space="preserve">
          <source>Regexp.FindAllStringSubmatch</source>
          <target state="translated">Regexp.FindAllStringSubmatch</target>
        </trans-unit>
        <trans-unit id="e4337ecbd053cf4beaa55b4111d3d25165c547a3" translate="yes" xml:space="preserve">
          <source>Regexp.FindAllStringSubmatchIndex</source>
          <target state="translated">Regexp.FindAllStringSubmatchIndex</target>
        </trans-unit>
        <trans-unit id="55182b4c005261d0e66f0c8c4df35946648e43bd" translate="yes" xml:space="preserve">
          <source>Regexp.FindAllSubmatch</source>
          <target state="translated">Regexp.FindAllSubmatch</target>
        </trans-unit>
        <trans-unit id="752406799d805cf76b21ac4473155fcd9c435cf1" translate="yes" xml:space="preserve">
          <source>Regexp.FindAllSubmatchIndex</source>
          <target state="translated">Regexp.FindAllSubmatchIndex</target>
        </trans-unit>
        <trans-unit id="ca21e70b0b76817fc6bc10e7f6cc4170f855d5aa" translate="yes" xml:space="preserve">
          <source>Regexp.FindIndex</source>
          <target state="translated">Regexp.FindIndex</target>
        </trans-unit>
        <trans-unit id="21fdf1e48587944dc1c11b68645cfe5138e0b116" translate="yes" xml:space="preserve">
          <source>Regexp.FindString</source>
          <target state="translated">Regexp.FindString</target>
        </trans-unit>
        <trans-unit id="dc52dbc2324ccd5021b173c341b811e2472a4206" translate="yes" xml:space="preserve">
          <source>Regexp.FindStringIndex</source>
          <target state="translated">Regexp.FindStringIndex</target>
        </trans-unit>
        <trans-unit id="a2b5fabc1cf5de45d659c3142098c4fde4339cdc" translate="yes" xml:space="preserve">
          <source>Regexp.FindStringSubmatch</source>
          <target state="translated">Regexp.FindStringSubmatch</target>
        </trans-unit>
        <trans-unit id="e27002b196cee520413e84f76c97dc77b353b852" translate="yes" xml:space="preserve">
          <source>Regexp.FindSubmatch</source>
          <target state="translated">Regexp.FindSubmatch</target>
        </trans-unit>
        <trans-unit id="fec6de782af8c1c02211813d203aef224fcb0882" translate="yes" xml:space="preserve">
          <source>Regexp.FindSubmatchIndex</source>
          <target state="translated">Regexp.FindSubmatchIndex</target>
        </trans-unit>
        <trans-unit id="9a2ff01cdd93ba73a6c7e52b6f4aa5baac4a6940" translate="yes" xml:space="preserve">
          <source>Regexp.Longest</source>
          <target state="translated">Regexp.Longest</target>
        </trans-unit>
        <trans-unit id="0008582d6bb9067aadd263f03da910a66e6e0e19" translate="yes" xml:space="preserve">
          <source>Regexp.Match</source>
          <target state="translated">Regexp.Match</target>
        </trans-unit>
        <trans-unit id="2c0eada8b9cfbb5d24aadca2e8fa445cbe3b7e2b" translate="yes" xml:space="preserve">
          <source>Regexp.MatchString</source>
          <target state="translated">Regexp.MatchString</target>
        </trans-unit>
        <trans-unit id="a15c3526305a73e97c8461348cc47b4634011556" translate="yes" xml:space="preserve">
          <source>Regexp.NumSubexp</source>
          <target state="translated">Regexp.NumSubexp</target>
        </trans-unit>
        <trans-unit id="add2b36777d2133814845c70e8cb4211b4283aa6" translate="yes" xml:space="preserve">
          <source>Regexp.ReplaceAll</source>
          <target state="translated">Regexp.ReplaceAll</target>
        </trans-unit>
        <trans-unit id="4c687a2a42e7f3d60c9f98f0993362b9c2735490" translate="yes" xml:space="preserve">
          <source>Regexp.ReplaceAllLiteralString</source>
          <target state="translated">Regexp.ReplaceAllLiteralString</target>
        </trans-unit>
        <trans-unit id="9fececaf13096d7dc9ffe3d2d93e25169cf762e1" translate="yes" xml:space="preserve">
          <source>Regexp.ReplaceAllString</source>
          <target state="translated">Regexp.ReplaceAllString</target>
        </trans-unit>
        <trans-unit id="5f97458d8e33d7f5f2c52b953c172d5ccb890b23" translate="yes" xml:space="preserve">
          <source>Regexp.ReplaceAllStringFunc</source>
          <target state="translated">Regexp.ReplaceAllStringFunc</target>
        </trans-unit>
        <trans-unit id="60f05fd13196ffa4dd89663cf41abb4f862a263c" translate="yes" xml:space="preserve">
          <source>Regexp.Split</source>
          <target state="translated">Regexp.Split</target>
        </trans-unit>
        <trans-unit id="4cd159d81359cd6aaae754a6f32c4b3350801c2a" translate="yes" xml:space="preserve">
          <source>Regexp.SubexpIndex</source>
          <target state="translated">Regexp.SubexpIndex</target>
        </trans-unit>
        <trans-unit id="b36b7852ff6e5f89fe309ce0324c7c9f6dac2ab6" translate="yes" xml:space="preserve">
          <source>Regexp.SubexpNames</source>
          <target state="translated">Regexp.SubexpNames</target>
        </trans-unit>
        <trans-unit id="96a2105b6d183387bea55013dc84567e629210a2" translate="yes" xml:space="preserve">
          <source>Region is a region of code whose execution time interval is traced.</source>
          <target state="translated">Region은 실행 시간 간격이 추적되는 코드 영역입니다.</target>
        </trans-unit>
        <trans-unit id="95c213e4f5521f3f5195554245abca05424ff590" translate="yes" xml:space="preserve">
          <source>Register makes a database driver available by the provided name. If Register is called twice with the same name or if driver is nil, it panics.</source>
          <target state="translated">등록하면 제공된 이름으로 데이터베이스 드라이버를 사용할 수 있습니다. 같은 이름으로 Register를 두 번 호출하거나 드라이버가 nil이면 패닉 상태입니다.</target>
        </trans-unit>
        <trans-unit id="64aef767785d208425e3e70c5d2194fcd9c84c85" translate="yes" xml:space="preserve">
          <source>Register publishes in the server the set of methods of the receiver value that satisfy the following conditions:</source>
          <target state="translated">레지스터는 다음 조건을 만족하는 수신자 값의 메소드 세트를 서버에 공개합니다.</target>
        </trans-unit>
        <trans-unit id="cbe295e9d864bc0bca7f28c205cb5395eba55d05" translate="yes" xml:space="preserve">
          <source>Register publishes the receiver's methods in the DefaultServer.</source>
          <target state="translated">Register는 DefaultServer에 수신자의 메소드를 공개합니다.</target>
        </trans-unit>
        <trans-unit id="c181d095749a9fa33757c1798befea770ef8d4eb" translate="yes" xml:space="preserve">
          <source>Register records a type, identified by a value for that type, under its internal type name. That name will identify the concrete type of a value sent or received as an interface variable. Only types that will be transferred as implementations of interface values need to be registered. Expecting to be used only during initialization, it panics if the mapping between types and names is not a bijection.</source>
          <target state="translated">Register는 내부 유형 이름 아래 해당 유형의 값으로 식별되는 유형을 기록합니다. 이 이름은 인터페이스 변수로 보내거나받는 값의 구체적인 유형을 식별합니다. 인터페이스 값의 구현으로 전송 될 유형 만 등록하면됩니다. 초기화 중에 만 사용될 것으로 예상되는 경우 유형과 이름 사이의 매핑이 생략이 아닌 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fceb2cf0f9b16aaaaa6d86b667b93fcaf25ae6c9" translate="yes" xml:space="preserve">
          <source>RegisterCompressor registers custom compressors for a specified method ID. The common methods Store and Deflate are built in.</source>
          <target state="translated">RegisterCompressor는 지정된 메소드 ID에 대한 사용자 지정 압축기를 등록합니다. Store 및 Deflate의 일반적인 방법이 내장되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a803c7a9e0d15c2a5bd92b06180759964dddc4a" translate="yes" xml:space="preserve">
          <source>RegisterCompressor registers or overrides a custom compressor for a specific method ID. If a compressor for a given method is not found, Writer will default to looking up the compressor at the package level.</source>
          <target state="translated">RegisterCompressor는 특정 방법 ID에 대한 사용자 지정 압축기를 등록하거나 무시합니다. 주어진 방법에 대한 압축기를 찾을 수없는 경우 기본적으로 Writer는 패키지 수준에서 압축기를 조회하도록 기본 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="75b2829cabbf108c3c7f621e80ccf782333f2745" translate="yes" xml:space="preserve">
          <source>RegisterCover records the coverage data accumulators for the tests. NOTE: This function is internal to the testing infrastructure and may change. It is not covered (yet) by the Go 1 compatibility guidelines.</source>
          <target state="translated">RegisterCover는 테스트를위한 커버리지 데이터 누산기를 기록합니다. 참고 :이 기능은 테스트 인프라 내부에 있으며 변경 될 수 있습니다. Go 1 호환성 가이드 라인은 아직 다루지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0efe5941ddd4024eca3486bcfdaa1b04b1d68c96" translate="yes" xml:space="preserve">
          <source>RegisterDecompressor allows custom decompressors for a specified method ID. The common methods Store and Deflate are built in.</source>
          <target state="translated">RegisterDecompressor는 지정된 메소드 ID에 대한 사용자 정의 압축 해제기를 허용합니다. Store 및 Deflate의 일반적인 방법이 내장되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8201de27600ded04eed1497b03a93af78ab1356" translate="yes" xml:space="preserve">
          <source>RegisterDecompressor registers or overrides a custom decompressor for a specific method ID. If a decompressor for a given method is not found, Reader will default to looking up the decompressor at the package level.</source>
          <target state="translated">RegisterDecompressor는 특정 메소드 ID에 대한 사용자 정의 압축 풀기를 등록하거나 재정의합니다. 주어진 방법에 대한 압축 해제기를 찾을 수 없으면 Reader는 기본적으로 압축 해제기를 패키지 수준에서 조회합니다.</target>
        </trans-unit>
        <trans-unit id="9306a2a96e5923311a823aa140641259832a6493" translate="yes" xml:space="preserve">
          <source>RegisterFormat registers an image format for use by Decode. Name is the name of the format, like &quot;jpeg&quot; or &quot;png&quot;. Magic is the magic prefix that identifies the format's encoding. The magic string can contain &quot;?&quot; wildcards that each match any one byte. Decode is the function that decodes the encoded image. DecodeConfig is the function that decodes just its configuration.</source>
          <target state="translated">RegisterFormat은 Decode에서 사용할 이미지 형식을 등록합니다. 이름은 &quot;jpeg&quot;또는 &quot;png&quot;와 같은 형식의 이름입니다. Magic은 형식의 인코딩을 식별하는 마법 접두사입니다. 매직 스트링에는 &quot;?&quot;가 포함될 수 있습니다. 각각 1 바이트와 일치하는 와일드 카드 디코딩은 인코딩 된 이미지를 디코딩하는 기능입니다. DecodeConfig는 해당 구성 만 디코딩하는 기능입니다.</target>
        </trans-unit>
        <trans-unit id="d2728f688707b63db693060d8790bf4683f92102" translate="yes" xml:space="preserve">
          <source>RegisterHash registers a function that returns a new instance of the given hash function. This is intended to be called from the init function in packages that implement hash functions.</source>
          <target state="translated">RegisterHash는 주어진 해시 함수의 새 인스턴스를 반환하는 함수를 등록합니다. 이것은 해시 함수를 구현하는 패키지의 init 함수에서 호출하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="f205fffb3fe13999a49ce9f8f1c25ec589135c4d" translate="yes" xml:space="preserve">
          <source>RegisterName is like Register but uses the provided name for the type instead of the receiver's concrete type.</source>
          <target state="translated">RegisterName은 Register와 비슷하지만 수신자의 구체적 유형 대신 유형에 제공된 이름을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="25332b231573649cd9dd5719e7982ea3f0248d42" translate="yes" xml:space="preserve">
          <source>RegisterName is like Register but uses the provided name rather than the type's default.</source>
          <target state="translated">RegisterName은 Register와 비슷하지만 유형의 기본값 대신 제공된 이름을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="080e1d8d3669508473b55784b1056c2f096d29a9" translate="yes" xml:space="preserve">
          <source>RegisterOnShutdown registers a function to call on Shutdown. This can be used to gracefully shutdown connections that have undergone ALPN protocol upgrade or that have been hijacked. This function should start protocol-specific graceful shutdown, but should not wait for shutdown to complete.</source>
          <target state="translated">RegisterOnShutdown은 Shutdown에서 호출 할 함수를 등록합니다. 이것은 ALPN 프로토콜 업그레이드를 받았거나 하이재킹 된 연결을 정상적으로 종료하는 데 사용할 수 있습니다. 이 기능은 프로토콜 별 정상 종료를 시작해야하지만 종료가 완료 될 때까지 기다리면 안됩니다.</target>
        </trans-unit>
        <trans-unit id="50c9507f9819b5006da79dc0a05071eebeda3b66" translate="yes" xml:space="preserve">
          <source>RegisterOnShutdown registers a function to call on Shutdown. This can be used to gracefully shutdown connections that have undergone NPN/ALPN protocol upgrade or that have been hijacked. This function should start protocol-specific graceful shutdown, but should not wait for shutdown to complete.</source>
          <target state="translated">RegisterOnShutdown은 종료시 호출 할 기능을 등록합니다. 이것은 NPN / ALPN 프로토콜 업그레이드가 진행 중이거나 하이재킹 된 연결을 정상적으로 종료하는 데 사용할 수 있습니다. 이 기능은 프로토콜 별 정상 종료를 시작해야하지만 종료가 완료 될 때까지 기다리지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="f09b3e8729145f382cce24a789165716e1f6f581" translate="yes" xml:space="preserve">
          <source>RegisterProtocol can be used by other packages to provide implementations of protocol schemes like &quot;ftp&quot; or &quot;file&quot;.</source>
          <target state="translated">RegisterProtocol은 &quot;ftp&quot;또는 &quot;file&quot;과 같은 프로토콜 체계의 구현을 제공하기 위해 다른 패키지에서 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbed30c09a7f4317da85a08f890897f3a240daa9" translate="yes" xml:space="preserve">
          <source>RegisterProtocol registers a new protocol with scheme. The Transport will pass requests using the given scheme to rt. It is rt's responsibility to simulate HTTP request semantics.</source>
          <target state="translated">RegisterProtocol은 체계를 사용하여 새 프로토콜을 등록합니다. 전송은 주어진 체계를 사용하여 요청을 rt로 전달합니다. HTTP 요청 시맨틱을 시뮬레이션하는 것은 RT의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="95f136e8903a5338ba8f8a6eba4b4b48f4b69ff6" translate="yes" xml:space="preserve">
          <source>Regs386 is the Mach-O 386 register structure.</source>
          <target state="translated">Regs386은 Mach-O 386 레지스터 구조입니다.</target>
        </trans-unit>
        <trans-unit id="2fcecaafbea673f4dcd43eda2b8e308980d372b2" translate="yes" xml:space="preserve">
          <source>RegsAMD64 is the Mach-O AMD64 register structure.</source>
          <target state="translated">RegsAMD64는 Mach-O AMD64 레지스터 구조입니다.</target>
        </trans-unit>
        <trans-unit id="e042b10a368397c92fb60dbef856be3d5a1c4f5c" translate="yes" xml:space="preserve">
          <source>Rel</source>
          <target state="translated">Rel</target>
        </trans-unit>
        <trans-unit id="1fb867ac152e76d351e8dfda8aca4022a73396b3" translate="yes" xml:space="preserve">
          <source>Rel returns a relative path that is lexically equivalent to targpath when joined to basepath with an intervening separator. That is, Join(basepath, Rel(basepath, targpath)) is equivalent to targpath itself. On success, the returned path will always be relative to basepath, even if basepath and targpath share no elements. An error is returned if targpath can't be made relative to basepath or if knowing the current working directory would be necessary to compute it. Rel calls Clean on the result.</source>
          <target state="translated">Rel은 중간 구분 기호를 사용하여 기본 경로에 결합 된 경우 targpath와 어휘 적으로 동등한 상대 경로를 반환합니다. 즉, Join (basepath, Rel (basepath, targpath))은 targpath 자체와 동일합니다. 성공하면 반환 된 경로는 basepath와 targpath가 요소를 공유하지 않더라도 항상 basepath에 상대적입니다. targpath를 기준 경로와 관련하여 만들 수 없거나 현재 작업 디렉토리를 알고 있어야 계산할 경우 오류가 리턴됩니다. Rel은 결과에 대해 Clean을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="c91ec177ba02dafca5c024ef643b47566dd89ce7" translate="yes" xml:space="preserve">
          <source>Relationship between Tok value and Specs element type:</source>
          <target state="translated">Tok 값과 Specs 요소 유형의 관계 :</target>
        </trans-unit>
        <trans-unit id="b6abe7b7ff14b910183c9aec85ce50c4ba39a8a2" translate="yes" xml:space="preserve">
          <source>RelativeTo returns a Qualifier that fully qualifies members of all packages other than pkg.</source>
          <target state="translated">RelativeTo는 pkg 이외의 모든 패키지 멤버를 완전히 규정하는 규정자를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="97b37138ea9a73172899c8018d830214258b5899" translate="yes" xml:space="preserve">
          <source>Release frees up resources allocated for the function. The function must not be invoked after calling Release.</source>
          <target state="translated">릴리스는 기능에 할당 된 자원을 해제합니다. Release를 호출 한 후 함수를 호출해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="6414caed589f7d3548350fb30719f67f7cc3b1cd" translate="yes" xml:space="preserve">
          <source>Release frees up resources allocated for the function. The function must not be invoked after calling Release. It is allowed to call Release while the function is still running.</source>
          <target state="translated">릴리스는 기능에 할당 된 리소스를 해제합니다. Release를 호출 한 후 함수를 호출하면 안됩니다. 함수가 실행되는 동안 Release를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c955e9bb05dd10804916da733d223f9b35d93831" translate="yes" xml:space="preserve">
          <source>Release releases any resources associated with the Process p, rendering it unusable in the future. Release only needs to be called if Wait is not.</source>
          <target state="translated">릴리스는 프로세스 p와 연관된 모든 자원을 릴리스하여 나중에 사용할 수 없게합니다. 대기가 아닌 경우에만 릴리스를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="74b4353ac8d321669700f92b4b41fd9bf3c282ea" translate="yes" xml:space="preserve">
          <source>Reloc represents a PE COFF relocation. Each section contains its own relocation list.</source>
          <target state="translated">재배치는 PE COFF 재배치를 나타냅니다. 각 섹션에는 자체 재배치 목록이 있습니다.</target>
        </trans-unit>
        <trans-unit id="06f15fe6a2a2d8aaac59472278e750857f76ab13" translate="yes" xml:space="preserve">
          <source>Relocation types for 386.</source>
          <target state="translated">386의 재배치 유형</target>
        </trans-unit>
        <trans-unit id="d75a9d4eea543b3382ef4c2ebb9e3847ab91fd45" translate="yes" xml:space="preserve">
          <source>Relocation types for 64-bit PowerPC or Power Architecture processors.</source>
          <target state="translated">64 비트 PowerPC 또는 Power Architecture 프로세서의 재배치 유형</target>
        </trans-unit>
        <trans-unit id="cf64299a5f4f83507314f139a3920dac3975ef27" translate="yes" xml:space="preserve">
          <source>Relocation types for AArch64 (aka arm64)</source>
          <target state="translated">AArch64 (일명 arm64)의 재배치 유형</target>
        </trans-unit>
        <trans-unit id="ef97dc2ae262d8f689d2dbae4ceb64c7c62edcc6" translate="yes" xml:space="preserve">
          <source>Relocation types for ARM.</source>
          <target state="translated">ARM의 재배치 유형</target>
        </trans-unit>
        <trans-unit id="2557c954121a635ff74fb9af9fe06dc80e27b715" translate="yes" xml:space="preserve">
          <source>Relocation types for Alpha.</source>
          <target state="translated">알파의 재배치 유형.</target>
        </trans-unit>
        <trans-unit id="1a1e40660756b62ef3239b6ced113d0caf0dbeda" translate="yes" xml:space="preserve">
          <source>Relocation types for MIPS.</source>
          <target state="translated">MIPS의 재배치 유형.</target>
        </trans-unit>
        <trans-unit id="37b372c8b8cafc23d3fe71c2d91eeb8c48e4e130" translate="yes" xml:space="preserve">
          <source>Relocation types for PowerPC.</source>
          <target state="translated">PowerPC의 재배치 유형.</target>
        </trans-unit>
        <trans-unit id="515822ec7faf1b82351dd8cb58bc45abc27332b8" translate="yes" xml:space="preserve">
          <source>Relocation types for RISC-V processors.</source>
          <target state="translated">RISC-V 프로세서의 재배치 유형.</target>
        </trans-unit>
        <trans-unit id="28595645ef003fbc741125cd77426e420a3c93bb" translate="yes" xml:space="preserve">
          <source>Relocation types for SPARC.</source>
          <target state="translated">SPARC의 재배치 유형.</target>
        </trans-unit>
        <trans-unit id="c8eeb8ad932e590ca3c9a184613db792a1b7d221" translate="yes" xml:space="preserve">
          <source>Relocation types for s390x processors.</source>
          <target state="translated">s390x 프로세서의 재배치 유형.</target>
        </trans-unit>
        <trans-unit id="65d84f2017b766a2f893b1d9391a10aba054030c" translate="yes" xml:space="preserve">
          <source>Relocation types for x86-64.</source>
          <target state="translated">x86-64의 재배치 유형</target>
        </trans-unit>
        <trans-unit id="255e665567383d4dd16b956acc5187ba8c43936a" translate="yes" xml:space="preserve">
          <source>Rem returns the remainder of (hi, lo) divided by y. Rem panics for y == 0 (division by zero) but, unlike Div, it doesn't panic on a quotient overflow.</source>
          <target state="translated">Rem은 (hi, lo)의 나머지를 y로 나눈 값을 반환합니다. y == 0 (0으로 나누기)에 대한 Rem 패닉이지만 Div와 달리 몫 오버플로에 대해 패닉하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f46f12d749f237f3883c4c5a62ab9b4f4409ae12" translate="yes" xml:space="preserve">
          <source>Rem sets z to the remainder x%y for y != 0 and returns z. If y == 0, a division-by-zero run-time panic occurs. Rem implements truncated modulus (like Go); see QuoRem for more details.</source>
          <target state="translated">Rem은 y! = 0에 대해 z를 나머지 x % y로 설정하고 z를 반환합니다. y == 0이면 0으로 나누기 런타임 패닉이 발생합니다. Rem은 Go와 같은 잘린 모듈러스를 구현합니다. 자세한 내용은 QuoRem을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7e9a6ae202c8dd3bb17cb040fe5aad5564198eb2" translate="yes" xml:space="preserve">
          <source>Rem32 returns the remainder of (hi, lo) divided by y. Rem32 panics for y == 0 (division by zero) but, unlike Div32, it doesn't panic on a quotient overflow.</source>
          <target state="translated">Rem32는 (hi, lo)의 나머지를 y로 나눈 값을 반환합니다. Rem32는 y == 0 (0으로 나누기)에 대해 패닉하지만 Div32와 달리 몫 오버플로에 대해 패닉하지 않습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
