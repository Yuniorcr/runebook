<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="vuex">
    <body>
      <group id="vuex">
        <trans-unit id="74ae1a27792287a53f632864ec413cb560452e7e" translate="yes" xml:space="preserve">
          <source>&quot;createLogger&quot; function is exported from the core module</source>
          <target state="translated">코어 모듈에서 &quot;createLogger&quot;기능을 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="a9b529393c3179a77a9306c183468564863d0ff0" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2015&amp;ndash;present Evan You</source>
          <target state="translated">&amp;copy; 2015&amp;ndash; 현재 Evan You</target>
        </trans-unit>
        <trans-unit id="3dbca386b3bf4c0c03ea3c64d065f726c26a64b7" translate="yes" xml:space="preserve">
          <source>1. Installation</source>
          <target state="translated">1. 설치</target>
        </trans-unit>
        <trans-unit id="7644d763c0c7ace9ff19d36e4552b445a389efe0" translate="yes" xml:space="preserve">
          <source>10. Strict Mode</source>
          <target state="translated">10. 엄격한 모드</target>
        </trans-unit>
        <trans-unit id="290258555d6677c0ac84626e214aa009f8a85e64" translate="yes" xml:space="preserve">
          <source>11. Form Handling</source>
          <target state="translated">11. 양식 처리</target>
        </trans-unit>
        <trans-unit id="4129c08ad5f758bb8883f75f714cc03d6b8724d7" translate="yes" xml:space="preserve">
          <source>12. Testing</source>
          <target state="translated">12. 테스트</target>
        </trans-unit>
        <trans-unit id="528a3b9b2d03ca80ea557ac5c60aa567789512ff" translate="yes" xml:space="preserve">
          <source>13. Hot Reloading</source>
          <target state="translated">13. 핫 리로딩</target>
        </trans-unit>
        <trans-unit id="dbc8b357691409e9c4daf2c6428dbe68446dc47c" translate="yes" xml:space="preserve">
          <source>2. Getting Started</source>
          <target state="translated">2. 시작하기</target>
        </trans-unit>
        <trans-unit id="999bcc9c65f419d4177fbc85fb43d8d53350ea26" translate="yes" xml:space="preserve">
          <source>3. State</source>
          <target state="translated">3. 상태</target>
        </trans-unit>
        <trans-unit id="86901adbf99889e89f6fb5664ba644ee179d5895" translate="yes" xml:space="preserve">
          <source>4. Getters</source>
          <target state="translated">4. 게터</target>
        </trans-unit>
        <trans-unit id="f5dd21d6df4b83ebbdd0d793bd18c24ecafd3d6a" translate="yes" xml:space="preserve">
          <source>5. Mutations</source>
          <target state="translated">5. 돌연변이</target>
        </trans-unit>
        <trans-unit id="d2db7e791345bd3756bb20faaf9a14d8b1ca6e1d" translate="yes" xml:space="preserve">
          <source>6. Actions</source>
          <target state="translated">6. 행동</target>
        </trans-unit>
        <trans-unit id="311b202ab670d27bdcb3786803bee13f6ac0dd04" translate="yes" xml:space="preserve">
          <source>7. Modules</source>
          <target state="translated">7. 모듈</target>
        </trans-unit>
        <trans-unit id="5b2c110974e654cf654a583f99f4466b77ffad4a" translate="yes" xml:space="preserve">
          <source>8. Application Structure</source>
          <target state="translated">8. 응용 구조</target>
        </trans-unit>
        <trans-unit id="35fca60c7ce35ec44954758baa9845c6764c93f3" translate="yes" xml:space="preserve">
          <source>9. Plugins</source>
          <target state="translated">9. 플러그인</target>
        </trans-unit>
        <trans-unit id="e491a21fa71516f2b26e081f14ece268b038b5c2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://unpkg.com&quot;&gt;Unpkg.com&lt;/a&gt; provides NPM-based CDN links. The above link will always point to the latest release on NPM. You can also use a specific version/tag via URLs like &lt;code&gt;https://unpkg.com/vuex@2.0.0&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://unpkg.com&quot;&gt;Unpkg.com&lt;/a&gt; 은 NPM 기반 CDN 링크를 제공합니다. 위의 링크는 항상 NPM의 최신 릴리스를 가리 킵니다. &lt;code&gt;https://unpkg.com/vuex@2.0.0&lt;/code&gt; 과 같은 URL을 통해 특정 버전 / 태그를 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c0ab7dbdd7961ea625457c4f71c2a103e97577e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;createLogger&lt;/code&gt; function is exported from the core module</source>
          <target state="translated">&lt;code&gt;createLogger&lt;/code&gt; 함수가 코어 모듈에서 내보내집니다.</target>
        </trans-unit>
        <trans-unit id="140249cc0098c39ea9eee2f348b83aec84aeaea9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;options&lt;/code&gt; can have &lt;code&gt;preserveState: true&lt;/code&gt; that allows to preserve the previous state. Useful with Server Side Rendering.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 는 &lt;code&gt;preserveState: true&lt;/code&gt; 를 가질 수 있으며 , 이전 상태를 보존 할 수 있습니다. 서버 측 렌더링에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="1d43392242421ea5926dd1b8219417091c58e5ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;subscribeAction&lt;/code&gt; can also specify an &lt;code&gt;error&lt;/code&gt; handler to catch an error thrown when an action is dispatched. The function will receive an &lt;code&gt;error&lt;/code&gt; object as the third argument.</source>
          <target state="translated">&lt;code&gt;subscribeAction&lt;/code&gt; 은 작업이 전달 될 때 발생하는 오류를 포착하기 위해 &lt;code&gt;error&lt;/code&gt; 처리기를 지정할 수도 있습니다 . 함수는 세 번째 인수로 &lt;code&gt;error&lt;/code&gt; 개체를 받습니다 .</target>
        </trans-unit>
        <trans-unit id="efda1a76b4931ed64f56c475099103b6b342e77a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;subscribeAction&lt;/code&gt; can also specify whether the subscribe handler should be called &lt;em&gt;before&lt;/em&gt; or &lt;em&gt;after&lt;/em&gt; an action dispatch (the default behavior is &lt;em&gt;before&lt;/em&gt;):</source>
          <target state="translated">&lt;code&gt;subscribeAction&lt;/code&gt; 은 구독 핸들러를 액션 디스패치 &lt;em&gt;전&lt;/em&gt; 또는 &lt;em&gt;후에&lt;/em&gt; 호출할지 여부를 지정할 수도 있습니다 (기본 동작은 &lt;em&gt;before입니다&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="93bc29b6324b7d1ed0dc681c2aa882c85b026c76" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Do not enable strict mode when deploying for production!&lt;/strong&gt; Strict mode runs a synchronous deep watcher on the state tree for detecting inappropriate mutations, and it can be quite expensive when you make large amount of mutations to the state. Make sure to turn it off in production to avoid the performance cost.</source>
          <target state="translated">&lt;strong&gt;프로덕션 환경에 배포 할 때 엄격 모드를 사용하지 마십시오! &lt;/strong&gt;엄격 모드는 부적절한 돌연변이를 탐지하기 위해 상태 트리에서 동기식 심층 감시자를 실행하며 상태에 많은 양의 돌연변이를 만들 때 비용이 많이들 수 있습니다. 성능 비용을 피하려면 프로덕션 환경에서 끄십시오.</target>
        </trans-unit>
        <trans-unit id="9f9016c15f9b85d16a456b0a8fed9e60d27f0c18" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE:&lt;/strong&gt; We will be using ES2015 syntax for code examples for the rest of the docs. If you haven't picked it up, &lt;a href=&quot;https://babeljs.io/docs/learn-es2015/&quot;&gt;you should&lt;/a&gt;!</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 나머지 문서의 코드 예제에는 ES2015 구문을 사용합니다. 당신이 그것을 집어 들지 않았다면, &lt;a href=&quot;https://babeljs.io/docs/learn-es2015/&quot;&gt;당신은해야합니다&lt;/a&gt; !</target>
        </trans-unit>
        <trans-unit id="543738af7550fb2b326fb4aec1d84822e5d85d47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Plugins that take state snapshots should be used only during development.&lt;/strong&gt; When using webpack or Browserify, we can let our build tools handle that for us:</source>
          <target state="translated">&lt;strong&gt;상태 스냅 샷을 생성하는 플러그인은 개발 중에 만 사용해야합니다. &lt;/strong&gt;웹팩 또는 Browserify를 사용할 때 빌드 도구가 다음을 처리하도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="152494aaef0de9abdd755c1e397ccd919faab73b" translate="yes" xml:space="preserve">
          <source>A more practical example of real-world actions would be an action to checkout a shopping cart, which involves &lt;strong&gt;calling an async API&lt;/strong&gt; and &lt;strong&gt;committing multiple mutations&lt;/strong&gt;:</source>
          <target state="translated">실제 작업의 실제적인 예는 포함 쇼핑 카트, 체크 아웃 할 작업이 될 것입니다 &lt;strong&gt;비동기 API를 호출&lt;/strong&gt; 하고 &lt;strong&gt;여러 돌연변이를 저지르고를&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="b276f94cd8d0e74a21de6e5939b8c10ca9a975d6" translate="yes" xml:space="preserve">
          <source>API Reference</source>
          <target state="translated">API 참조</target>
        </trans-unit>
        <trans-unit id="5f613656881e083dfef9e6ff61f4361ce0a8891f" translate="yes" xml:space="preserve">
          <source>Accessing Global Assets in Namespaced Modules</source>
          <target state="translated">네임 스페이스 모듈에서 글로벌 자산에 액세스</target>
        </trans-unit>
        <trans-unit id="a6ab98e7c5d9fe16cce79fc5b58d4c6a0bb97528" translate="yes" xml:space="preserve">
          <source>Accessing Mutations and Actions</source>
          <target state="translated">뮤 테이션과 액션에 접근하기</target>
        </trans-unit>
        <trans-unit id="18d2c21a5e764fa3068b12a662b48a445b54e874" translate="yes" xml:space="preserve">
          <source>Accessing State and Getters</source>
          <target state="translated">상태 및 게터에 액세스</target>
        </trans-unit>
        <trans-unit id="0d5c235f81dfbc7a38598e493ee1ecf48d2948cf" translate="yes" xml:space="preserve">
          <source>Action handlers receive a context object which exposes the same set of methods/properties on the store instance, so you can call &lt;code&gt;context.commit&lt;/code&gt; to commit a mutation, or access the state and getters via &lt;code&gt;context.state&lt;/code&gt; and &lt;code&gt;context.getters&lt;/code&gt;. We can even call other actions with &lt;code&gt;context.dispatch&lt;/code&gt;. We will see why this context object is not the store instance itself when we introduce &lt;a href=&quot;modules&quot;&gt;Modules&lt;/a&gt; later.</source>
          <target state="translated">조치 핸들러는 상점 인스턴스에서 동일한 메소드 / 특성 세트를 노출하는 컨텍스트 오브젝트를 수신하므로 &lt;code&gt;context.commit&lt;/code&gt; 을 호출 하여 돌연변이를 커미트하거나 &lt;code&gt;context.state&lt;/code&gt; 및 &lt;code&gt;context.getters&lt;/code&gt; 를 통해 상태 및 게터에 액세스 할 수 있습니다 . &lt;code&gt;context.dispatch&lt;/code&gt; 사용 하여 다른 작업을 호출 할 수도 있습니다 . 나중에이 &lt;a href=&quot;modules&quot;&gt;모듈&lt;/a&gt; 을 소개 할 때이 컨텍스트 오브젝트가 스토어 인스턴스 자체가 아닌 이유를 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3cd636a585b20c40ac2df5ffb403e83cb2eef51" translate="yes" xml:space="preserve">
          <source>Actions</source>
          <target state="translated">Actions</target>
        </trans-unit>
        <trans-unit id="fd2b38844159f4c8bd1a540f724142f21bcb2783" translate="yes" xml:space="preserve">
          <source>Actions are often asynchronous, so how do we know when an action is done? And more importantly, how can we compose multiple actions together to handle more complex async flows?</source>
          <target state="translated">동작은 종종 비동기 적이므로 동작이 수행되는 시점을 어떻게 알 수 있습니까? 더 중요한 것은 더 복잡한 비동기 흐름을 처리하기 위해 여러 작업을 함께 구성하는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="eebbe3f939d0e7eb5a702bddfd2a09d58662a331" translate="yes" xml:space="preserve">
          <source>Actions are similar to mutations, the differences being that:</source>
          <target state="translated">행동은 돌연변이와 유사하지만 차이점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2fb7f3eefbb910c724298c1fe2f73e2dd2775642" translate="yes" xml:space="preserve">
          <source>Actions are triggered with the &lt;code&gt;store.dispatch&lt;/code&gt; method:</source>
          <target state="translated">&lt;code&gt;store.dispatch&lt;/code&gt; 메소드로 조치가 트리거됩니다 .</target>
        </trans-unit>
        <trans-unit id="e0710bf63012535b6c8d8716b3dcac5cf1237306" translate="yes" xml:space="preserve">
          <source>Actions can be a bit more tricky because they may call out to external APIs. When testing actions, we usually need to do some level of mocking - for example, we can abstract the API calls into a service and mock that service inside our tests. In order to easily mock dependencies, we can use webpack and &lt;a href=&quot;https://github.com/plasticine/inject-loader&quot;&gt;inject-loader&lt;/a&gt; to bundle our test files.</source>
          <target state="translated">외부 API를 호출 할 수 있으므로 작업이 좀 더 까다로울 수 있습니다. 작업을 테스트 할 때는 일반적으로 일정 수준의 조롱을 수행해야합니다. 예를 들어 API 호출을 서비스로 추상화하고 테스트 내에서 해당 서비스를 조롱 할 수 있습니다. 의존성을 쉽게 조롱하기 위해 webpack과 &lt;a href=&quot;https://github.com/plasticine/inject-loader&quot;&gt;inject-loader&lt;/a&gt; 를 사용하여 테스트 파일을 묶을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b7eca18a813d34c8aa01e8ef07ee7519aaf8e37" translate="yes" xml:space="preserve">
          <source>Actions can contain arbitrary asynchronous operations.</source>
          <target state="translated">작업에는 임의의 비동기 작업이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20c41c87b2101245945eb4d510d08709af6ca47f" translate="yes" xml:space="preserve">
          <source>Actions from different views may need to mutate the same piece of state.</source>
          <target state="translated">다른보기의 조치는 동일한 상태를 변경해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc658d581fafc63b17159bbd703e4b6ae9e6654d" translate="yes" xml:space="preserve">
          <source>Actions support the same payload format and object-style dispatch:</source>
          <target state="translated">액션은 동일한 페이로드 형식과 객체 스타일 디스패치를 ​​지원합니다.</target>
        </trans-unit>
        <trans-unit id="e6f1f5e24996a891b4012e435efadfe597fd76af" translate="yes" xml:space="preserve">
          <source>Admittedly, the above is quite a bit more verbose than &lt;code&gt;v-model&lt;/code&gt; + local state, and we lose some of the useful features from &lt;code&gt;v-model&lt;/code&gt; as well. An alternative approach is using a two-way computed property with a setter:</source>
          <target state="translated">틀림없이, 위는 꽤 이상 장황 &lt;code&gt;v-model&lt;/code&gt; + 로컬 상태, 우리는에서 유용한 기능 중 일부 손실 &lt;code&gt;v-model&lt;/code&gt; 도 있습니다. 다른 방법은 setter와 함께 양방향 계산 속성을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1202f0740ed7d8ae90a711fe902caaa8f08e09b3" translate="yes" xml:space="preserve">
          <source>After &lt;a href=&quot;../installation&quot;&gt;installing&lt;/a&gt; Vuex, let's create a store. It is pretty straightforward - just provide an initial state object, and some mutations:</source>
          <target state="translated">Vuex를 &lt;a href=&quot;../installation&quot;&gt;설치&lt;/a&gt; 한 후 상점을 만들어 봅시다. 그것은 매우 간단합니다-초기 상태 객체와 일부 돌연변이를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="a38a6afdb72dbde1dead2d25ed43a801e44eeba7" translate="yes" xml:space="preserve">
          <source>Again, the reason we are committing a mutation instead of changing &lt;code&gt;store.state.count&lt;/code&gt; directly, is because we want to explicitly track it. This simple convention makes your intention more explicit, so that you can reason about state changes in your app better when reading the code. In addition, this gives us the opportunity to implement tools that can log every mutation, take state snapshots, or even perform time travel debugging.</source>
          <target state="translated">다시 &lt;code&gt;store.state.count&lt;/code&gt; 를 직접 변경하는 대신 돌연변이를 저지른 이유는 명시 적으로 추적하기 때문입니다. 이 간단한 규칙은 의도를보다 명확하게 해주므로 코드를 읽을 때 앱의 상태 변경에 대해 더 잘 추론 할 수 있습니다. 또한 모든 돌연변이를 기록하고 상태 스냅 샷을 만들거나 시간 여행 디버깅을 수행 할 수있는 도구를 구현할 수있는 기회를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="eab081c4e733f3e8e7fc4113e3a4c3e9822d6e7f" translate="yes" xml:space="preserve">
          <source>Almost all Vuex 4 APIs have remained unchanged from Vuex 3. However, there are still a few breaking changes that you must fix.</source>
          <target state="translated">거의 모든 Vuex 4 API는 Vuex 3에서 변경되지 않았습니다. 그러나 수정해야 할 몇 가지 주요 변경 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="321cdc14e97d2ee50f5d65dc4d313dcb119e79c0" translate="yes" xml:space="preserve">
          <source>Also, inside module getters, the root state will be exposed as their 3rd argument:</source>
          <target state="translated">또한 모듈 게터 내에서 루트 상태는 세 번째 인수로 노출됩니다.</target>
        </trans-unit>
        <trans-unit id="2eee5b4fbbc1f54a27e6412f36e8fc0250ed0ca4" translate="yes" xml:space="preserve">
          <source>An alternative way to commit a mutation is by directly using an object that has a &lt;code&gt;type&lt;/code&gt; property:</source>
          <target state="translated">돌연변이를 저지르는 다른 방법은 &lt;code&gt;type&lt;/code&gt; 속성 이있는 객체를 직접 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="c5bfc0baa5cb6ec7b1c1c279caffbe5d5b8218a2" translate="yes" xml:space="preserve">
          <source>An array of plugin functions to be applied to the store. The plugin simply receives the store as the only argument and can either listen to mutations (for outbound data persistence, logging, or debugging) or dispatch mutations (for inbound data e.g. websockets or observables).</source>
          <target state="translated">상점에 적용 할 플러그인 기능의 배열입니다. 플러그인은 단순히 스토어를 유일한 인수로 수신하며 돌연변이 (아웃 바운드 데이터 지속성, 로깅 또는 디버깅 용) 또는 디스패치 돌연변이 (인바운드 데이터 (예 : 웹 소켓 또는 관찰 가능))를 수신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b626f3c447742f2fad682725d05b28250d88b5f" translate="yes" xml:space="preserve">
          <source>An object containing sub modules to be merged into the store, in the shape of:</source>
          <target state="translated">다음과 같은 형태로 상점에 병합 할 서브 모듈을 포함하는 오브젝트입니다.</target>
        </trans-unit>
        <trans-unit id="dc46a43c367676022711c845ac16cc5387d782f6" translate="yes" xml:space="preserve">
          <source>And also in another action:</source>
          <target state="translated">그리고 또 다른 행동으로 :</target>
        </trans-unit>
        <trans-unit id="4db792123502a659fd37a4ca852f43e15ee1ef57" translate="yes" xml:space="preserve">
          <source>And also receives a second &lt;code&gt;payload&lt;/code&gt; argument if there is one.</source>
          <target state="translated">또한 두 번째 &lt;code&gt;payload&lt;/code&gt; 인수가 있으면이를 받습니다 .</target>
        </trans-unit>
        <trans-unit id="6eb1eaafd8f229821b275541a054f723a80d42bf" translate="yes" xml:space="preserve">
          <source>And can be used like this:</source>
          <target state="translated">다음과 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe2969186d8cff2f758236d5c540ae4e48a2d751" translate="yes" xml:space="preserve">
          <source>And here's the mutation handler:</source>
          <target state="translated">그리고 돌연변이 처리기는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d71de8152541f4a1b7fda48b87f3fe315656e14c" translate="yes" xml:space="preserve">
          <source>Application Structure</source>
          <target state="translated">응용 프로그램 구조</target>
        </trans-unit>
        <trans-unit id="2ba5dece67f8efdf3c81bb9be56daf28e8655190" translate="yes" xml:space="preserve">
          <source>Application-level state is centralized in the store.</source>
          <target state="translated">애플리케이션 레벨 상태는 상점에서 중앙 집중화됩니다.</target>
        </trans-unit>
        <trans-unit id="710522a05d77912ddae3e734e0a2d1d370529418" translate="yes" xml:space="preserve">
          <source>As a reference, check out the &lt;a href=&quot;https://github.com/vuejs/vuex/tree/4.0/examples/classic/shopping-cart&quot;&gt;Shopping Cart Example&lt;/a&gt;.</source>
          <target state="translated">참고로 &lt;a href=&quot;https://github.com/vuejs/vuex/tree/4.0/examples/classic/shopping-cart&quot;&gt;쇼핑 카트 예를&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="84a169df16a0c175be12b4d7b1cd59df717591a1" translate="yes" xml:space="preserve">
          <source>As a reference, check out the &lt;a href=&quot;https://github.com/vuejs/vuex/tree/dev/examples/shopping-cart&quot;&gt;Shopping Cart Example&lt;/a&gt;.</source>
          <target state="translated">참고로 &lt;a href=&quot;https://github.com/vuejs/vuex/tree/dev/examples/shopping-cart&quot;&gt;쇼핑 카트 예를&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="90a44e426a7e60755b1c84d1d390da1cb4f500d2" translate="yes" xml:space="preserve">
          <source>As long as you follow these rules, it's up to you how to structure your project. If your store file gets too big, simply start splitting the actions, mutations and getters into separate files.</source>
          <target state="translated">이 규칙을 따르는 한 프로젝트를 구성하는 방법은 사용자에게 달려 있습니다. 상점 파일이 너무 커지면 조치, 돌연변이 및 게터를 별도의 파일로 분할하기 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="fc6ed90023b96fb6043edbdf30e42cf5dd8527fd" translate="yes" xml:space="preserve">
          <source>As of Vue 3.0, the getter's result is &lt;strong&gt;not cached&lt;/strong&gt; as the computed property does. This is a known issue that requires Vue 3.1 to be released. You can learn more at &lt;a href=&quot;https://github.com/vuejs/vuex/pull/1883&quot;&gt;PR #1878&lt;/a&gt;.</source>
          <target state="translated">Vue 3.0부터 getter의 결과는 계산 된 속성처럼 &lt;strong&gt;캐시&lt;/strong&gt; 되지 않습니다. 이는 Vue 3.1을 출시해야하는 알려진 문제입니다. &lt;a href=&quot;https://github.com/vuejs/vuex/pull/1883&quot;&gt;PR # 1878&lt;/a&gt; 에서 자세히 알아볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5dfd062060191d75d85aa467d9473a70ac205ad2" translate="yes" xml:space="preserve">
          <source>Assuming &lt;code&gt;obj&lt;/code&gt; is a computed property that returns an Object from the store, the &lt;code&gt;v-model&lt;/code&gt; here will attempt to directly mutate &lt;code&gt;obj.message&lt;/code&gt; when the user types in the input. In strict mode, this will result in an error because the mutation is not performed inside an explicit Vuex mutation handler.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 가 상점에서 Object를 반환하는 계산 된 속성 이라고 가정하면 여기서 &lt;code&gt;v-model&lt;/code&gt; 은 사용자가 입력을 입력 할 때 &lt;code&gt;obj.message&lt;/code&gt; 를 직접 변경하려고 시도합니다 . 엄격 모드에서는 명시적인 Vuex 돌연변이 처리기 내에서 돌연변이가 수행되지 않기 때문에 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6d84d9b230182d02f5132507784662fee81bd183" translate="yes" xml:space="preserve">
          <source>Asynchronicity combined with state mutation can make your program very hard to reason about. For example, when you call two methods both with async callbacks that mutate the state, how do you know when they are called and which callback was called first? This is exactly why we want to separate the two concepts. In Vuex, &lt;strong&gt;mutations are synchronous transactions&lt;/strong&gt;:</source>
          <target state="translated">상태 변이와 결합 된 비동기 성은 프로그램을 추론하기 매우 어렵게 만들 수 있습니다. 예를 들어 상태를 변경하는 비동기 콜백을 사용하여 두 가지 메소드를 모두 호출하면 언제 호출되고 어떤 콜백이 처음 호출되었는지 어떻게 알 수 있습니까? 이것이 바로 두 개념을 분리하려는 이유입니다. Vuex에서 &lt;strong&gt;돌연변이는 동기식 트랜잭션입니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="b626c6a5b4f21b273497b11b0696d3709db0b3b9" translate="yes" xml:space="preserve">
          <source>Asynchronous logic should be encapsulated in, and can be composed with &lt;strong&gt;actions&lt;/strong&gt;.</source>
          <target state="translated">비동기 로직은 캡슐화되어야하며 &lt;strong&gt;action&lt;/strong&gt; 으로 구성 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b24ba5aae3b57ed131c31fce3d9e7c01ee0a8934" translate="yes" xml:space="preserve">
          <source>At the center of every Vuex application is the &lt;strong&gt;store&lt;/strong&gt;. A &quot;store&quot; is basically a container that holds your application &lt;strong&gt;state&lt;/strong&gt;. There are two things that make a Vuex store different from a plain global object:</source>
          <target state="translated">모든 Vuex 응용 프로그램의 중심에는 &lt;strong&gt;상점&lt;/strong&gt; 이 &lt;strong&gt;있습니다&lt;/strong&gt; . &quot;저장소&quot;는 기본적으로 응용 프로그램 &lt;strong&gt;상태&lt;/strong&gt; 를 유지하는 컨테이너입니다 . Vuex 스토어를 일반 전역 객체와 다르게 만드는 두 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7d1a78232de1c9a47af6445001c58c1d1a7ff3f" translate="yes" xml:space="preserve">
          <source>Binding Helpers with Namespace</source>
          <target state="translated">네임 스페이스와 헬퍼 바인딩</target>
        </trans-unit>
        <trans-unit id="8f6f50fe6a684e36f2680d1b1f0d995148104f1b" translate="yes" xml:space="preserve">
          <source>Breaking Changes</source>
          <target state="translated">브레이킹 체인지</target>
        </trans-unit>
        <trans-unit id="2b82d0b3ff29a71b23bd07d252bf2496be796144" translate="yes" xml:space="preserve">
          <source>Built-in Logger Plugin</source>
          <target state="translated">내장 로거 플러그인</target>
        </trans-unit>
        <trans-unit id="308a059e768af3165c20d5c89a88a895db34b5d3" translate="yes" xml:space="preserve">
          <source>Bundles are now aligned with Vue 3</source>
          <target state="translated">번들은 이제 Vue 3과 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="9b63c58271c9e6140433eb13c24cac57c216ef45" translate="yes" xml:space="preserve">
          <source>By committing mutations, a plugin can be used to sync a data source to the store. For example, to sync a websocket data source to the store (this is just a contrived example, in reality the &lt;code&gt;createWebSocketPlugin&lt;/code&gt; function can take some additional options for more complex tasks):</source>
          <target state="translated">돌연변이를 저지르면 플러그인을 사용하여 데이터 소스를 상점에 동기화 할 수 있습니다. 예를 들어, 웹 소켓 데이터 소스를 상점에 동기화하려면 (이것은 단지 고안된 예일뿐입니다. 실제로 &lt;code&gt;createWebSocketPlugin&lt;/code&gt; 함수는보다 복잡한 태스크를 위해 몇 가지 추가 옵션을 사용할 수 있습니다) :</target>
        </trans-unit>
        <trans-unit id="54e6c17c9d96ae95deebc44ddbbdf708643bcdb6" translate="yes" xml:space="preserve">
          <source>By default, actions and mutations are still registered under the &lt;strong&gt;global namespace&lt;/strong&gt; - this allows multiple modules to react to the same action/mutation type. Getters are also registered in the global namespace by default. However, this currently has no functional purpose (it's as is to avoid breaking changes). You must be careful not to define two getters with the same name in different, non-namespaced modules, resulting in an error.</source>
          <target state="translated">기본적으로 액션과 변형은 여전히 &lt;strong&gt;전역 네임 스페이스&lt;/strong&gt; 아래에 등록되어 있습니다. 따라서 여러 모듈이 동일한 액션 / 변이 유형에 반응 할 수 있습니다. Getter는 기본적으로 전역 네임 스페이스에도 등록됩니다. 그러나 이것은 현재 기능적인 목적이 없습니다 (중단 변경을 피하기위한 것입니다). 네임 스페이스가 지정되지 않은 다른 모듈에서 동일한 이름을 가진 두 개의 getter를 정의하지 않도록주의해야합니다.이 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f6129d443ac8169bdc5fb7a33f1a6e3a49e6acbc" translate="yes" xml:space="preserve">
          <source>By default, actions, mutations and getters inside modules are still registered under the &lt;strong&gt;global namespace&lt;/strong&gt; - this allows multiple modules to react to the same mutation/action type.</source>
          <target state="translated">기본적으로 모듈 내부의 액션, 돌연변이 및 게터는 여전히 &lt;strong&gt;전역 네임 스페이스&lt;/strong&gt; 아래에 등록됩니다. 이를 통해 여러 모듈이 동일한 돌연변이 / 액션 유형에 반응 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5c047ce83c6997dc7276f84aba1f5edb7e54735" translate="yes" xml:space="preserve">
          <source>By default, new handler is added to the end of the chain, so it will be executed after other handlers that were added before. This can be overridden by adding &lt;code&gt;prepend: true&lt;/code&gt; to &lt;code&gt;options&lt;/code&gt;, which will add the handler to the beginning of the chain.</source>
          <target state="translated">기본적으로 새 핸들러는 체인 끝에 추가되므로 이전에 추가 된 다른 핸들러 이후에 실행됩니다. &lt;code&gt;prepend: true&lt;/code&gt; 를 &lt;code&gt;options&lt;/code&gt; 에 추가하여 재정의 할 수 있습니다 . 그러면 체인 시작 부분에 핸들러가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="51ce5306c9b50098f499e2c37705e5ca375897a5" translate="yes" xml:space="preserve">
          <source>By defining and separating the concepts involved in state management and enforcing rules that maintain independence between views and states, we give our code more structure and maintainability.</source>
          <target state="translated">상태 관리와 관련된 개념을 정의하고 분리하고 뷰와 상태 간의 독립성을 유지하는 규칙을 시행함으로써 코드의 구조와 유지 관리 성을 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="5f057ce6f76c7748c97610c88355154f282ad2c0" translate="yes" xml:space="preserve">
          <source>By providing the &lt;code&gt;store&lt;/code&gt; option to the root instance, the store will be injected into all child components of the root and will be available on them as &lt;code&gt;this.$store&lt;/code&gt;. Let's update our &lt;code&gt;Counter&lt;/code&gt; implementation:</source>
          <target state="translated">&lt;code&gt;store&lt;/code&gt; 옵션을 루트 인스턴스에 제공하면 저장소 는 루트의 모든 하위 구성 요소에 주입되며 &lt;code&gt;this.$store&lt;/code&gt; 으로 이것 에서 사용할 수 있습니다 . &lt;code&gt;Counter&lt;/code&gt; 구현을 업데이트하겠습니다 :</target>
        </trans-unit>
        <trans-unit id="afbfca3e9562078c83014d5d713ed214293086dc" translate="yes" xml:space="preserve">
          <source>Caveat for Plugin Developers</source>
          <target state="translated">플러그인 개발자를위한주의 사항</target>
        </trans-unit>
        <trans-unit id="b802f993bec634c517b9f6ea60df4c1f6d0862f1" translate="yes" xml:space="preserve">
          <source>Change the &lt;code&gt;entry&lt;/code&gt; from the webpack config above to &lt;code&gt;'mocha-loader!babel-loader!./test.js'&lt;/code&gt;.</source>
          <target state="translated">변경 &lt;code&gt;entry&lt;/code&gt; 에 위의 웹팩 설정에서을 &lt;code&gt;'mocha-loader!babel-loader!./test.js'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad552703e8fdce0a6e99ce76eff171c7cb0b2e6e" translate="yes" xml:space="preserve">
          <source>Check if the module with the given name is already registered. &lt;a href=&quot;../guide/modules#dynamic-module-registration&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">주어진 이름의 모듈이 이미 등록되어 있는지 확인하십시오. &lt;a href=&quot;../guide/modules#dynamic-module-registration&quot;&gt;세부&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="74a64ba9ebedb4fb168b3e805adfe8c5b4531bcc" translate="yes" xml:space="preserve">
          <source>Check out the &lt;a href=&quot;https://github.com/vuejs/vuex/tree/4.0/examples/composition&quot;&gt;Composition API example&lt;/a&gt; to see example applications utilising Vuex and Vue's Composition API.</source>
          <target state="translated">아웃 확인 &lt;a href=&quot;https://github.com/vuejs/vuex/tree/4.0/examples/composition&quot;&gt;조성 API 예&lt;/a&gt; Vuex 및 뷰의 구성 API를 활용 한 예제 응용 프로그램을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dce2cc7e2a5aca96dce40c7472c844313c6128f9" translate="yes" xml:space="preserve">
          <source>Checkout the &lt;a href=&quot;https://github.com/vuejs/vuex/tree/dev/examples/counter-hot&quot;&gt;counter-hot example&lt;/a&gt; to play with hot-reload.</source>
          <target state="translated">핫 리로드로 재생 하려면 &lt;a href=&quot;https://github.com/vuejs/vuex/tree/dev/examples/counter-hot&quot;&gt;카운터 핫 예&lt;/a&gt; 를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="4fa10bacb249d780150d867ebb85a6f26364c8f3" translate="yes" xml:space="preserve">
          <source>Commit a mutation. &lt;code&gt;options&lt;/code&gt; can have &lt;code&gt;root: true&lt;/code&gt; that allows to commit root mutations in &lt;a href=&quot;../guide/modules#namespacing&quot;&gt;namespaced modules&lt;/a&gt;. &lt;a href=&quot;../guide/mutations&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">돌연변이를 저 지르십시오. &lt;code&gt;options&lt;/code&gt; 은 &lt;code&gt;root: true&lt;/code&gt; 를 가질 수 있으며 &lt;a href=&quot;../guide/modules#namespacing&quot;&gt;네임 스페이스 모듈&lt;/a&gt; 에서 루트 돌연변이를 커밋 할 수 있습니다 . &lt;a href=&quot;../guide/mutations&quot;&gt;세부&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="abb9b61bf1bcc0d24bf3814462346ec637d49ab2" translate="yes" xml:space="preserve">
          <source>Commit with Payload</source>
          <target state="translated">페이로드로 커밋</target>
        </trans-unit>
        <trans-unit id="ed6c4a7e621ba1c9ba60ff20a8e8dcf01877ef46" translate="yes" xml:space="preserve">
          <source>Committing Mutations Inside Plugins</source>
          <target state="translated">플러그인 내부의 돌연변이 커밋</target>
        </trans-unit>
        <trans-unit id="ace0d08016e7028b4da846721e8e8ac868a1df57" translate="yes" xml:space="preserve">
          <source>Committing Mutations in Components</source>
          <target state="translated">컴포넌트에서 돌연변이 커밋</target>
        </trans-unit>
        <trans-unit id="1f6dc35fce777380808e0419957ee6d4ef776d2a" translate="yes" xml:space="preserve">
          <source>Component Binding Helpers</source>
          <target state="translated">컴포넌트 바인딩 헬퍼</target>
        </trans-unit>
        <trans-unit id="4d8cf2331522b00be9ba0f265b611e2039ac37bf" translate="yes" xml:space="preserve">
          <source>Components Can Still Have Local State</source>
          <target state="translated">구성 요소가 여전히 로컬 상태 일 수 있음</target>
        </trans-unit>
        <trans-unit id="c21ad08c0baf7033efdd17f3b90986ad6f2a3b53" translate="yes" xml:space="preserve">
          <source>Composable Functions</source>
          <target state="translated">구성 가능한 함수</target>
        </trans-unit>
        <trans-unit id="b15cc8250e54a4e4e49adf02d259f1fa59279242" translate="yes" xml:space="preserve">
          <source>Composing Actions</source>
          <target state="translated">작성 작업</target>
        </trans-unit>
        <trans-unit id="612f6427c9092a5834602047d990b4384c86915b" translate="yes" xml:space="preserve">
          <source>Composition API</source>
          <target state="translated">구성 API</target>
        </trans-unit>
        <trans-unit id="ede404da36f4056ccf7af05d460f44cb9c43066f" translate="yes" xml:space="preserve">
          <source>Consult the setup in &lt;a href=&quot;https://vue-loader.vuejs.org/en/workflow/testing.html&quot;&gt;vue-loader documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://vue-loader.vuejs.org/en/workflow/testing.html&quot;&gt;vue-loader documentation&lt;/a&gt; 의 설정을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fdf30dd4ea6fdb8cb2d048ae6de2346d62859fba" translate="yes" xml:space="preserve">
          <source>Contains hard-coded prod/dev branches and the prod build is pre-minified. Use the &lt;code&gt;.prod.js&lt;/code&gt; files for production.</source>
          <target state="translated">하드 코딩 된 prod / dev 브랜치를 포함하며 prod 빌드는 미리 축소됩니다. 프로덕션에 &lt;code&gt;.prod.js&lt;/code&gt; 파일을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="da10239b688b761162ce39505c1fb91b8a0f2cff" translate="yes" xml:space="preserve">
          <source>Create component computed options that return the evaluated value of a getter. &lt;a href=&quot;../guide/getters#the-mapgetters-helper&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">평가 된 getter 값을 리턴하는 컴포넌트 계산 옵션을 작성하십시오. &lt;a href=&quot;../guide/getters#the-mapgetters-helper&quot;&gt;세부&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="31bb75db599ebdfdee4a1705ea2cde4fc02ae7e9" translate="yes" xml:space="preserve">
          <source>Create component computed options that return the sub tree of the Vuex store. &lt;a href=&quot;../guide/state#the-mapstate-helper&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">Vuex 저장소의 하위 트리를 리턴하는 컴포넌트 계산 옵션을 작성하십시오. &lt;a href=&quot;../guide/state#the-mapstate-helper&quot;&gt;세부&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3dbfc6c00c0be1ce1d1c67ae2ab7ad29e56233ee" translate="yes" xml:space="preserve">
          <source>Create component methods options that commit a mutation. &lt;a href=&quot;../guide/mutations#committing-mutations-in-components&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">돌연변이를 일으키는 구성 요소 방법 옵션을 만듭니다. &lt;a href=&quot;../guide/mutations#committing-mutations-in-components&quot;&gt;세부&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="abafed37072bae96880b76a80729da6f20135f55" translate="yes" xml:space="preserve">
          <source>Create component methods options that dispatch an action. &lt;a href=&quot;../guide/actions#dispatching-actions-in-components&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">조치를 전달하는 컴포넌트 메소드 옵션을 작성하십시오. &lt;a href=&quot;../guide/actions#dispatching-actions-in-components&quot;&gt;세부&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9e2d6b72bf5a70877397f0095b2d65aff35b1892" translate="yes" xml:space="preserve">
          <source>Create namespaced component binding helpers. The returned object contains &lt;code&gt;mapState&lt;/code&gt;, &lt;code&gt;mapGetters&lt;/code&gt;, &lt;code&gt;mapActions&lt;/code&gt; and &lt;code&gt;mapMutations&lt;/code&gt; that are bound with the given namespace. &lt;a href=&quot;../guide/modules#binding-helpers-with-namespace&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">네임 스페이스 구성 요소 바인딩 도우미를 만듭니다. 반환 된 객체에는 지정된 네임 스페이스에 바인딩 된 &lt;code&gt;mapState&lt;/code&gt; , &lt;code&gt;mapGetters&lt;/code&gt; , &lt;code&gt;mapActions&lt;/code&gt; 및 &lt;code&gt;mapMutations&lt;/code&gt; 가 포함됩니다. &lt;a href=&quot;../guide/modules#binding-helpers-with-namespace&quot;&gt;세부&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e9ad68aa689b0ae8f0f0130cf5684aa9556b2ca9" translate="yes" xml:space="preserve">
          <source>Create the following webpack config (together with proper &lt;a href=&quot;https://babeljs.io/docs/usage/babelrc/&quot;&gt;&lt;code&gt;.babelrc&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">적절한 &lt;a href=&quot;https://babeljs.io/docs/usage/babelrc/&quot;&gt; &lt;code&gt;.babelrc&lt;/code&gt; &lt;/a&gt; 와 함께 다음 웹팩 구성을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="6d783b874c20d56d3f40a248f291e37048c0af28" translate="yes" xml:space="preserve">
          <source>Creates a new store.</source>
          <target state="translated">새 상점을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="9105fc825a43c6d4845f7a03ee377cd299c7a10e" translate="yes" xml:space="preserve">
          <source>Creating multiple stores that use the same module (e.g. To &lt;a href=&quot;https://ssr.vuejs.org/en/structure.html#avoid-stateful-singletons&quot;&gt;avoid stateful singletons in the SSR&lt;/a&gt; when the &lt;code&gt;runInNewContext&lt;/code&gt; option is &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;'once'&lt;/code&gt;);</source>
          <target state="translated">동일한 모듈을 사용하는 여러 상점 작성 (예 : &lt;code&gt;runInNewContext&lt;/code&gt; 옵션이 &lt;code&gt;false&lt;/code&gt; 또는 &lt;code&gt;'once'&lt;/code&gt; 인 경우 &lt;a href=&quot;https://ssr.vuejs.org/en/structure.html#avoid-stateful-singletons&quot;&gt;SSR에서 상태 저장 싱글 톤&lt;/a&gt; 을 피하기 위해 );</target>
        </trans-unit>
        <trans-unit id="21eac18e2c98912ec301de36518dcca3257d3520" translate="yes" xml:space="preserve">
          <source>Define the typed &lt;code&gt;InjectionKey&lt;/code&gt;.</source>
          <target state="translated">유형이 지정된 &lt;code&gt;InjectionKey&lt;/code&gt; 를 정의하십시오 .</target>
        </trans-unit>
        <trans-unit id="dc3decbb93847518f1a049dcf49d0d7c6560bcc6" translate="yes" xml:space="preserve">
          <source>Details</source>
          <target state="translated">Details</target>
        </trans-unit>
        <trans-unit id="40d9b9f619dbd27ad649a2fb2ed512704a8498dc" translate="yes" xml:space="preserve">
          <source>Dev Build</source>
          <target state="translated">개발 빌드</target>
        </trans-unit>
        <trans-unit id="500633464b5e072d2c92585f64d2a894aa70607e" translate="yes" xml:space="preserve">
          <source>Development vs. Production</source>
          <target state="translated">개발 대 생산</target>
        </trans-unit>
        <trans-unit id="3802d9202faed1ee478163e33ce9ddf939795ae9" translate="yes" xml:space="preserve">
          <source>Direct Download / CDN</source>
          <target state="translated">직접 다운로드 / CDN</target>
        </trans-unit>
        <trans-unit id="ea82e3864abf2011a82f27aa87646711a6dde792" translate="yes" xml:space="preserve">
          <source>Dispatch an action. &lt;code&gt;options&lt;/code&gt; can have &lt;code&gt;root: true&lt;/code&gt; that allows to dispatch root actions in &lt;a href=&quot;../guide/modules#namespacing&quot;&gt;namespaced modules&lt;/a&gt;. Returns a Promise that resolves all triggered action handlers. &lt;a href=&quot;../guide/actions&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">액션을 전달하십시오. &lt;code&gt;options&lt;/code&gt; 은 &lt;code&gt;root: true&lt;/code&gt; 를 가질 수 있으며 &lt;a href=&quot;../guide/modules#namespacing&quot;&gt;네임 스페이스 모듈&lt;/a&gt; 에서 루트 작업을 디스패치 할 수 있습니다 . 모든 트리거 된 조치 핸들러를 해결하는 약속을 리턴합니다. &lt;a href=&quot;../guide/actions&quot;&gt;세부&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c5de1b3bf84cda5dd071c256e4397b905445d1ed" translate="yes" xml:space="preserve">
          <source>Dispatching Actions</source>
          <target state="translated">파견 조치</target>
        </trans-unit>
        <trans-unit id="7bbf007bb6622957664e35e62427c33b4787bbb3" translate="yes" xml:space="preserve">
          <source>Dispatching Actions in Components</source>
          <target state="translated">구성 요소에서 작업 전달</target>
        </trans-unit>
        <trans-unit id="e84816ed7caab86d4177979788d92260896d7646" translate="yes" xml:space="preserve">
          <source>Does not ship minified builds (to be done together with the rest of the code after bundling).</source>
          <target state="translated">축소 된 빌드를 제공하지 않습니다 (번들링 후 나머지 코드와 함께 수행).</target>
        </trans-unit>
        <trans-unit id="18d9131cd512bae245202d7fdc5bab5cceca6887" translate="yes" xml:space="preserve">
          <source>Due to using a single state tree, all state of our application is contained inside one big object. However, as our application grows in scale, the store can get really bloated.</source>
          <target state="translated">단일 상태 트리를 사용하기 때문에 응용 프로그램의 모든 상태가 하나의 큰 객체 안에 포함됩니다. 그러나 응용 프로그램의 규모가 커짐에 따라 매장이 부풀어 올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e37126c9ff488c45faa7f6c167a21e521222db0b" translate="yes" xml:space="preserve">
          <source>Due to using a single state tree, all states of our application are contained inside one big object. However, as our application grows in scale, the store can get really bloated.</source>
          <target state="translated">단일 상태 트리를 사용하기 때문에 애플리케이션의 모든 상태가 하나의 큰 객체 안에 포함됩니다. 그러나 우리의 응용 프로그램이 규모가 커짐에 따라 저장소가 실제로 부풀어 질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e38587c029f9616f99732e5fadca02a9d8f2a6d2" translate="yes" xml:space="preserve">
          <source>Dynamic Module Registration</source>
          <target state="translated">동적 모듈 등록</target>
        </trans-unit>
        <trans-unit id="cc0be31613baaad452c149bb9c4e8586cb8a8114" translate="yes" xml:space="preserve">
          <source>Dynamic module hot reloading</source>
          <target state="translated">동적 모듈 핫 리로딩</target>
        </trans-unit>
        <trans-unit id="2eff12ca8da9deedbd39f6bb9fd354742d118c9c" translate="yes" xml:space="preserve">
          <source>Dynamic module registration makes it possible for other Vue plugins to also leverage Vuex for state management by attaching a module to the application's store. For example, the &lt;a href=&quot;https://github.com/vuejs/vuex-router-sync&quot;&gt;&lt;code&gt;vuex-router-sync&lt;/code&gt;&lt;/a&gt; library integrates vue-router with vuex by managing the application's route state in a dynamically attached module.</source>
          <target state="translated">동적 모듈 등록을 통해 다른 Vue 플러그인도 모듈을 애플리케이션의 저장소에 연결하여 상태 관리를 위해 Vuex를 활용할 수 있습니다. 예를 들어, &lt;a href=&quot;https://github.com/vuejs/vuex-router-sync&quot;&gt; &lt;code&gt;vuex-router-sync&lt;/code&gt; &lt;/a&gt; 라이브러리는 동적으로 연결된 모듈에서 애플리케이션의 라우트 상태를 관리하여 vue-router를 vuex와 통합합니다.</target>
        </trans-unit>
        <trans-unit id="9e3580cb8f8917bfac5059a2f1b0b379d39800d4" translate="yes" xml:space="preserve">
          <source>Each module can contain &lt;code&gt;state&lt;/code&gt; and &lt;code&gt;mutations&lt;/code&gt; similar to the root options. A module's state will be attached to the store's root state using the module's key. A module's mutations and getters will only receives the module's local state as the first argument instead of the root state, and module actions' &lt;code&gt;context.state&lt;/code&gt; will also point to the local state.</source>
          <target state="translated">각 모듈에는 루트 옵션과 유사한 &lt;code&gt;state&lt;/code&gt; 및 &lt;code&gt;mutations&lt;/code&gt; 가 포함될 수 있습니다. 모듈 상태는 모듈 키를 사용하여 상점의 루트 상태에 연결됩니다. 모듈의 변이와 getter는 루트 상태 대신 첫 번째 인수로 모듈의 로컬 상태 만 수신하며 모듈 조치의 &lt;code&gt;context.state&lt;/code&gt; 도 로컬 상태를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="f41155bdc10bb27f60f1da2c63993929e366cfa2" translate="yes" xml:space="preserve">
          <source>Edit this page on GitHub</source>
          <target state="translated">GitHub에서이 페이지 편집</target>
        </trans-unit>
        <trans-unit id="d6af0b4fa90bb496d791139a634a4d2d65a25408" translate="yes" xml:space="preserve">
          <source>Example testing a getter:</source>
          <target state="translated">게터 테스트 예제 :</target>
        </trans-unit>
        <trans-unit id="dd8e6bd0108987b857bb2a736cd9e6e1f11f7746" translate="yes" xml:space="preserve">
          <source>Example testing a mutation using Mocha + Chai (you can use any framework/assertion libraries you like):</source>
          <target state="translated">Mocha + Chai를 사용하여 돌연변이 테스트 예 (원하는 프레임 워크 / 어설 션 라이브러리를 사용할 수 있음) :</target>
        </trans-unit>
        <trans-unit id="4dadb731f14e104d4245f8a4e7627c9bb1d8c139" translate="yes" xml:space="preserve">
          <source>Example testing an async action:</source>
          <target state="translated">비동기 동작 테스트 예 :</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="cd172f61d02f40968010ccf686bd62765d497609" translate="yes" xml:space="preserve">
          <source>Exposes registered getters. Read only.</source>
          <target state="translated">등록 된 게터를 노출합니다. 읽기 전용.</target>
        </trans-unit>
        <trans-unit id="6a0705ebf0c44ae72129e31b63faf83cc8385e86" translate="yes" xml:space="preserve">
          <source>Fetches the injected store when called inside the &lt;code&gt;setup&lt;/code&gt; hook. When using the Composition API, you can retrieve the store by calling this method.</source>
          <target state="translated">&lt;code&gt;setup&lt;/code&gt; 후크 내부에서 호출 될 때 삽입 된 저장소를 가져옵니다 . Composition API를 사용하는 경우이 메서드를 호출하여 저장소를 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7e1190595d9109275e6d9d5c10a089a3981a13d" translate="yes" xml:space="preserve">
          <source>Finally, if we make use of &lt;a href=&quot;https://tc39.github.io/ecmascript-asyncawait/&quot;&gt;async / await&lt;/a&gt;, we can compose our actions like this:</source>
          <target state="translated">마지막으로 &lt;a href=&quot;https://tc39.github.io/ecmascript-asyncawait/&quot;&gt;async / await를&lt;/a&gt; 사용 하면 다음과 같이 작업을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ecf5f38fd7c4dac49ef3d463f17a75ccd2d813ac" translate="yes" xml:space="preserve">
          <source>Finally, you can pass the key to the &lt;code&gt;useStore&lt;/code&gt; method to retrieve the typed store instance.</source>
          <target state="translated">마지막으로 키를 &lt;code&gt;useStore&lt;/code&gt; 메소드에 전달 하여 유형이 지정된 스토어 인스턴스를 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d9fcf80576ac0f89837fff4eaee1452a5292cce8" translate="yes" xml:space="preserve">
          <source>Finally, you can pass the key to the &lt;code&gt;useStore&lt;/code&gt; method to retrieve the typed store.</source>
          <target state="translated">마지막으로 키를 &lt;code&gt;useStore&lt;/code&gt; 메소드에 전달 하여 입력 된 저장소를 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0760cb8d91e6272575ced160dd4e33845f64e540" translate="yes" xml:space="preserve">
          <source>First, declare the injection key using Vue's &lt;code&gt;InjectionKey&lt;/code&gt; interface.</source>
          <target state="translated">먼저 Vue의 &lt;code&gt;InjectionKey&lt;/code&gt; 인터페이스를 사용하여 주입 키를 선언합니다 .</target>
        </trans-unit>
        <trans-unit id="841c8a4f0fbdf7bd78d33837ca0ec3734ac74a01" translate="yes" xml:space="preserve">
          <source>Flux libraries are like glasses: you&amp;rsquo;ll know when you need them.</source>
          <target state="translated">플럭스 라이브러리는 안경과 같습니다. 필요할 때 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38238c24d7f78b5d636a16e313302582a752f404" translate="yes" xml:space="preserve">
          <source>For any non-trivial app, we will likely need to leverage modules. Here's an example project structure:</source>
          <target state="translated">사소하지 않은 앱의 경우 모듈을 사용해야합니다. 프로젝트 구조의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a300dd270b0c9c1a922b569511c43841912d4bc3" translate="yes" xml:space="preserve">
          <source>For direct use with &lt;code&gt;&amp;lt;script src=&quot;...&quot;&amp;gt;&lt;/code&gt; in the browser. Exposes the Vuex global.</source>
          <target state="translated">브라우저에서 &lt;code&gt;&amp;lt;script src=&quot;...&quot;&amp;gt;&lt;/code&gt; 와 함께 직접 사용 합니다. Vuex 전역을 노출합니다.</target>
        </trans-unit>
        <trans-unit id="033826f9380de6f34a8b452670d3506eb71f91c9" translate="yes" xml:space="preserve">
          <source>For mutations and modules, you need to use the &lt;code&gt;store.hotUpdate()&lt;/code&gt; API method:</source>
          <target state="translated">돌연변이 및 모듈의 경우 &lt;code&gt;store.hotUpdate()&lt;/code&gt; API 메소드 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="52511d0a336b3eb2bef841ae607141d7cff1fb7f" translate="yes" xml:space="preserve">
          <source>For problem one, passing props can be tedious for deeply nested components, and simply doesn't work for sibling components. For problem two, we often find ourselves resorting to solutions such as reaching for direct parent/child instance references or trying to mutate and synchronize multiple copies of the state via events. Both of these patterns are brittle and quickly lead to unmaintainable code.</source>
          <target state="translated">문제 1의 경우, 깊게 중첩 된 구성 요소에는 소품을 전달하는 것이 지루할 수 있으며 형제 구성 요소에는 작동하지 않습니다. 문제 2의 경우, 직접적인 부모 / 자식 인스턴스 참조에 도달하거나 이벤트를 통해 상태의 여러 복사본을 변경 및 동기화하는 등의 솔루션에 의존하는 경우가 많습니다. 이 두 패턴 모두 취하기 쉽고 빠르게 유지 관리 할 수없는 코드로 이어집니다.</target>
        </trans-unit>
        <trans-unit id="2a82f8d5ce145c881352007d801685ce832abbc7" translate="yes" xml:space="preserve">
          <source>For use in Node.js server-side rendering with &lt;code&gt;require()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;require()&lt;/code&gt; 를 사용하여 Node.js 서버 측 렌더링에 사용 합니다 .</target>
        </trans-unit>
        <trans-unit id="424e49071bb58b22df700b0f0b42bc3fdfc8d652" translate="yes" xml:space="preserve">
          <source>For use with bundlers such as &lt;code&gt;webpack&lt;/code&gt;, &lt;code&gt;rollup&lt;/code&gt; and &lt;code&gt;parcel&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;webpack&lt;/code&gt; , &lt;code&gt;rollup&lt;/code&gt; 및 &lt;code&gt;parcel&lt;/code&gt; 과 같은 번 들러 와 함께 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="dd780fa7ac6288608638eda9123dd968783ffa71" translate="yes" xml:space="preserve">
          <source>For use with native ES module imports (including module supporting browsers via &lt;code&gt;&amp;lt;script type=&quot;module&quot;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">네이티브 ES와 함께 사용하기위한 모듈을 통해 지원하는 브라우저를 포함 수입 (모듈 &lt;code&gt;&amp;lt;script type=&quot;module&quot;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bea63837c28f9e496db300536e9f97becac0fe11" translate="yes" xml:space="preserve">
          <source>Force the Vuex store into strict mode. In strict mode any mutations to Vuex state outside of mutation handlers will throw an Error.</source>
          <target state="translated">Vuex 저장소를 엄격 모드로 설정하십시오. 엄격 모드에서 돌연변이 처리기 외부의 Vuex 상태로의 돌연변이는 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="320e36f6db4da7afda899f2251cea1a84a74c2fd" translate="yes" xml:space="preserve">
          <source>Form Handling</source>
          <target state="translated">양식 처리</target>
        </trans-unit>
        <trans-unit id="8f92675b7ffe5ac821405fab6ddb6dee755e7a33" translate="yes" xml:space="preserve">
          <source>Furthermore, add the below line into anywhere in your code before using Vuex:</source>
          <target state="translated">또한 Vuex를 사용하기 전에 코드의 아무 곳에 나 아래 줄을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="e156a94f2c9e52e0ddb1f3009ed07dd2abf8f227" translate="yes" xml:space="preserve">
          <source>Furthermore, you can create namespaced helpers by using &lt;code&gt;createNamespacedHelpers&lt;/code&gt;. It returns an object having new component binding helpers that are bound with the given namespace value:</source>
          <target state="translated">또한 &lt;code&gt;createNamespacedHelpers&lt;/code&gt; 를 사용하여 네임 스페이스 헬퍼를 작성할 수 있습니다 . 주어진 네임 스페이스 값으로 바인딩 된 새로운 구성 요소 바인딩 도우미가있는 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3bbbe89e1bf4029f9a507d85d668e0d1d5478d40" translate="yes" xml:space="preserve">
          <source>Getters</source>
          <target state="translated">Getters</target>
        </trans-unit>
        <trans-unit id="a2c7b1aaac2b0cd5b5c8cf82e9116fb532a36719" translate="yes" xml:space="preserve">
          <source>Getters will also receive other getters as the 2nd argument:</source>
          <target state="translated">Getter는 또한 두 번째 인수로 다른 Getter를받습니다.</target>
        </trans-unit>
        <trans-unit id="d5976d58530e9ba51288bd1c3ba468cfba584344" translate="yes" xml:space="preserve">
          <source>Getters will receive the state as their 1st argument:</source>
          <target state="translated">Getters는 첫 번째 인수로 상태를받습니다.</target>
        </trans-unit>
        <trans-unit id="010b85ad56b34c34c7c2a3b2436c740e30428ed5" translate="yes" xml:space="preserve">
          <source>Getting Started</source>
          <target state="translated">시작하기</target>
        </trans-unit>
        <trans-unit id="fca659dd312a705a6e05d1f829f26c05b73a3925" translate="yes" xml:space="preserve">
          <source>Getting Vuex State into Vue Components</source>
          <target state="translated">Vuex 상태를 Vue 구성 요소로 가져 오기</target>
        </trans-unit>
        <trans-unit id="4277a56d46a56f9393fef01ea88a4610c015a3f2" translate="yes" xml:space="preserve">
          <source>Global build is built as IIFE, and not UMD, and is only meant for direct use with &lt;code&gt;&amp;lt;script src=&quot;...&quot;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">글로벌 빌드는 UMD가 아닌 IIFE로 빌드되며 &lt;code&gt;&amp;lt;script src=&quot;...&quot;&amp;gt;&lt;/code&gt; 와 함께 직접 사용하기위한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="722346bbd4db03c1c92c2a13e486f0e957996d98" translate="yes" xml:space="preserve">
          <source>Go to &lt;code&gt;localhost:8080/webpack-dev-server/test-bundle&lt;/code&gt;.</source>
          <target state="translated">이동 &lt;code&gt;localhost:8080/webpack-dev-server/test-bundle&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf073fae640ded81eeb7a4cee70faff4a623c16c" translate="yes" xml:space="preserve">
          <source>Guide</source>
          <target state="translated">Guide</target>
        </trans-unit>
        <trans-unit id="f6642ec74afc236ede9f28e965753353dfeeed2c" translate="yes" xml:space="preserve">
          <source>Having to import &lt;code&gt;InjectionKey&lt;/code&gt; and passing it to &lt;code&gt;useStore&lt;/code&gt; everywhere it's used can quickly become a repetitive task. To simplify matters, you can define your own composable function to retrieve a typed store:</source>
          <target state="translated">&lt;code&gt;InjectionKey&lt;/code&gt; 를 가져 와서 사용되는 모든 곳 에서 &lt;code&gt;useStore&lt;/code&gt; 에 전달 해야하는 것은 빠르게 반복적 인 작업이 될 수 있습니다. 문제를 단순화하기 위해 직접 구성 가능한 함수를 정의하여 입력 된 저장소를 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45a02043733710be9556d86b3bc87f17a5cbb0c2" translate="yes" xml:space="preserve">
          <source>Here's an example of the &lt;a href=&quot;https://jsfiddle.net/n9jmu5v7/1269/&quot;&gt;most basic Vuex counter app&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://jsfiddle.net/n9jmu5v7/1269/&quot;&gt;가장 기본적인 Vuex 카운터 앱&lt;/a&gt; 의 예는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="7e74485fd2af89802a7ce36b6ae42c0bfcc32ed2" translate="yes" xml:space="preserve">
          <source>Hot Reloading</source>
          <target state="translated">핫 리로딩</target>
        </trans-unit>
        <trans-unit id="c75202151698b65793216f709dd23fa91c67ca82" translate="yes" xml:space="preserve">
          <source>Hot swap new actions and mutations. &lt;a href=&quot;../guide/hot-reload&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">새로운 행동과 변이 핫스왑. &lt;a href=&quot;../guide/hot-reload&quot;&gt;세부&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="adbb8bac10b93929c10b60c23f56b5f8139a3463" translate="yes" xml:space="preserve">
          <source>However, if you're writing your Vue components in TypeScript, there're a few steps to follow that require for you to correctly provide typings for a store.</source>
          <target state="translated">그러나 TypeScript로 Vue 구성 요소를 작성하는 경우 상점에 대한 타이핑을 올바르게 제공해야하는 몇 가지 단계가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a9fe831345a6e109e78580913b99472521a13a7" translate="yes" xml:space="preserve">
          <source>However, the simplicity quickly breaks down when we have &lt;strong&gt;multiple components that share a common state&lt;/strong&gt;:</source>
          <target state="translated">그러나 &lt;strong&gt;공통 상태를 공유하는 여러 구성 요소&lt;/strong&gt; 가 있으면 단순성이 빠르게 분해됩니다 .</target>
        </trans-unit>
        <trans-unit id="c5371d6ce87417e1b9eefdc865251be6386c405f" translate="yes" xml:space="preserve">
          <source>However, this pattern causes the component to rely on the global store singleton. When using a module system, it requires importing the store in every component that uses store state, and also requires mocking when testing the component.</source>
          <target state="translated">그러나이 패턴은 구성 요소가 글로벌 상점 싱글 톤에 의존하게합니다. 모듈 시스템을 사용할 때는 상점 상태를 사용하는 모든 구성 요소에서 상점을 가져와야하며 구성 요소를 테스트 할 때 조롱해야합니다.</target>
        </trans-unit>
        <trans-unit id="b36b5bee1a64a661bc0d45de384b9124cbd72bfe" translate="yes" xml:space="preserve">
          <source>If more than one component needs to make use of this, we have to either duplicate the function, or extract it into a shared helper and import it in multiple places - both are less than ideal.</source>
          <target state="translated">둘 이상의 구성 요소가 이것을 사용해야 할 경우 함수를 복제하거나 공유 도우미로 추출하여 여러 위치로 가져와야합니다. 둘 다 이상적이지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="bcd403966a8c64a6cc2f12e14145c0930fd23c8f" translate="yes" xml:space="preserve">
          <source>If we use a plain object to declare the state of the module, then that state object will be shared by reference and cause cross store/module state pollution when it's mutated.</source>
          <target state="translated">일반 객체를 사용하여 모듈의 상태를 선언하면 해당 상태 객체는 참조로 공유되며 변경 될 때 교차 저장 / 모듈 상태 오염이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b7ec52a51a8cf587b9d439ecdf520d3332d63b46" translate="yes" xml:space="preserve">
          <source>If you are using &lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;vue-devtools&lt;/a&gt; you probably don't need this.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;vue-devtools&lt;/a&gt; 를 사용하고 있다면 아마도 이것이 필요하지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="cee9eac37fcab09966f32a737634f82881a4edd4" translate="yes" xml:space="preserve">
          <source>If you have spies available in your testing environment (for example via &lt;a href=&quot;http://sinonjs.org/&quot;&gt;Sinon.JS&lt;/a&gt;), you can use them instead of the &lt;code&gt;testAction&lt;/code&gt; helper:</source>
          <target state="translated">테스트 환경에서 스파이를 사용할 수있는 경우 (예 : &lt;a href=&quot;http://sinonjs.org/&quot;&gt;Sinon.JS&lt;/a&gt; ) &lt;code&gt;testAction&lt;/code&gt; 도우미 대신 스파이를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="99253187df56aff1e087c7f8349702f7e584c5c0" translate="yes" xml:space="preserve">
          <source>If you pass a function that returns an object, the returned object is used as the root state. This is useful when you want to reuse the state object especially for module reuse. &lt;a href=&quot;../guide/modules#module-reuse&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">객체를 반환하는 함수를 전달하면 반환 된 객체가 루트 상태로 사용됩니다. 이것은 특히 모듈 재사용을 위해 상태 객체를 재사용하려는 경우에 유용합니다. &lt;a href=&quot;../guide/modules#module-reuse&quot;&gt;세부&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="09433d887f39cc66b122d2113ece04bd4c9edb90" translate="yes" xml:space="preserve">
          <source>If you prefer using a package manager such as NPM or Yarn, install it with the following commands:</source>
          <target state="translated">NPM 또는 Yarn과 같은 패키지 관리자를 사용하려면 다음 명령을 사용하여 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="c818e621900aa5c6ea1f6dea69d53344a7ed6a02" translate="yes" xml:space="preserve">
          <source>If you use modules exclusively, you can use &lt;code&gt;require.context&lt;/code&gt; to load and hot reload all modules dynamically.</source>
          <target state="translated">모듈을 독점적으로 사용하는 경우 &lt;code&gt;require.context&lt;/code&gt; 를 사용 하여 모든 모듈을 동적으로로드하고 핫 리로드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d3c23688fd4c0302fe8a3ccf68a85702b829cacd" translate="yes" xml:space="preserve">
          <source>If you want to learn Vuex in an interactive way you can check out this &lt;a href=&quot;https://scrimba.com/g/gvuex&quot;&gt;Vuex course on Scrimba&lt;/a&gt;, which gives you a mix of screencast and code playground that you can pause and play around with anytime.</source>
          <target state="translated">대화식으로 Vuex를 배우고 싶다면 Scrimba에서이 &lt;a href=&quot;https://scrimba.com/g/gvuex&quot;&gt;Vuex 코스를&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="f3eb7c190d4d6d7796c724c80957f823f5be66cc" translate="yes" xml:space="preserve">
          <source>If you want to map a getter to a different name, use an object:</source>
          <target state="translated">게터를 다른 이름으로 매핑하려면 객체를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="20e00848ec8ade0a6824f9de7344231d1bfc9ba4" translate="yes" xml:space="preserve">
          <source>If you want to register global actions in namespaced modules, you can mark it with &lt;code&gt;root: true&lt;/code&gt; and place the action definition to function &lt;code&gt;handler&lt;/code&gt;. For example:</source>
          <target state="translated">네임 스페이스가있는 모듈에 전역 작업을 등록하려면 &lt;code&gt;root: true&lt;/code&gt; 표시 하고 작업 정의를 함수 &lt;code&gt;handler&lt;/code&gt; 에 배치 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4f4b8e63a24cc27e082d0c2aea79d7dec7762531" translate="yes" xml:space="preserve">
          <source>If you want to use global state and getters, &lt;code&gt;rootState&lt;/code&gt; and &lt;code&gt;rootGetters&lt;/code&gt; are passed as the 3rd and 4th arguments to getter functions, and also exposed as properties on the &lt;code&gt;context&lt;/code&gt; object passed to action functions.</source>
          <target state="translated">전역 상태 및 게터를 사용하려는 경우 &lt;code&gt;rootState&lt;/code&gt; 및 &lt;code&gt;rootGetters&lt;/code&gt; 는 세 번째 및 네 번째 인수로 getter 함수에 전달되며 동작 함수에 전달 된 &lt;code&gt;context&lt;/code&gt; 객체의 속성으로 노출됩니다 .</target>
        </trans-unit>
        <trans-unit id="6fcf9a3ab85ce67825ec590efb360c383d7dfca6" translate="yes" xml:space="preserve">
          <source>If you want your modules to be more self-contained or reusable, you can mark it as namespaced with &lt;code&gt;namespaced: true&lt;/code&gt;. When the module is registered, all of its getters, actions and mutations will be automatically namespaced based on the path the module is registered at. For example:</source>
          <target state="translated">모듈을보다 독립적으로 사용하거나 재사용 할 수있게하려면 네임 스페이스를 사용하여 &lt;code&gt;namespaced: true&lt;/code&gt; 스페이스가있는 것으로 표시 할 수 있습니다 : true . 모듈이 등록되면 모든 게터, 액션 및 변이는 모듈이 등록 된 경로에 따라 자동으로 네임 스페이스가 지정됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="09a871b493d3905657b3f74ae734baad18e2aaf1" translate="yes" xml:space="preserve">
          <source>If you've never built a large-scale SPA and jump right into Vuex, it may feel verbose and daunting. That's perfectly normal - if your app is simple, you will most likely be fine without Vuex. A simple &lt;a href=&quot;https://v3.vuejs.org/guide/state-management.html#simple-state-management-from-scratch&quot;&gt;store pattern&lt;/a&gt; may be all you need. But if you are building a medium-to-large-scale SPA, chances are you have run into situations that make you think about how to better handle state outside of your Vue components, and Vuex will be the natural next step for you. There's a good quote from Dan Abramov, the author of Redux:</source>
          <target state="translated">대규모 SPA를 구축 한 적이없고 Vuex로 바로 뛰어 들어 본 적이 없다면 장황하고 벅 스러울 수 있습니다. 이는 완벽하게 정상입니다. 앱이 단순하다면 Vuex 없이도 괜찮을 것입니다. 간단한 &lt;a href=&quot;https://v3.vuejs.org/guide/state-management.html#simple-state-management-from-scratch&quot;&gt;상점 패턴 만&lt;/a&gt; 있으면됩니다. 그러나 중대형 SPA를 구축하는 경우 Vue 구성 요소 외부에서 상태를 더 잘 처리하는 방법에 대해 생각하게 만드는 상황에 직면했을 가능성이 있으며 Vuex는 자연스러운 다음 단계가 될 것입니다. Redux의 저자 인 Dan Abramov의 좋은 인용문이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5c0c63467aaecb0aa7b51168b383f900b5a513b" translate="yes" xml:space="preserve">
          <source>If you've never built a large-scale SPA and jump right into Vuex, it may feel verbose and daunting. That's perfectly normal - if your app is simple, you will most likely be fine without Vuex. A simple &lt;a href=&quot;https://vuejs.org/v2/guide/state-management.html#Simple-State-Management-from-Scratch&quot;&gt;store pattern&lt;/a&gt; may be all you need. But if you are building a medium-to-large-scale SPA, chances are you have run into situations that make you think about how to better handle state outside of your Vue components, and Vuex will be the natural next step for you. There's a good quote from Dan Abramov, the author of Redux:</source>
          <target state="translated">대규모 SPA를 구축하지 않고 Vuex로 바로 들어가면 장황하고 까다로울 수 있습니다. 앱이 단순하다면 Vuex가 없으면 괜찮을 것입니다. 간단한 &lt;a href=&quot;https://vuejs.org/v2/guide/state-management.html#Simple-State-Management-from-Scratch&quot;&gt;상점 패턴 만&lt;/a&gt; 있으면됩니다. 그러나 중간 규모에서 대규모 규모의 SPA를 구축하는 경우 Vue 구성 요소 외부의 상태를보다 잘 처리하는 방법에 대해 생각할 수있는 상황이 발생할 가능성이 있으며 Vuex는 다음 단계로 자연스럽게 나아갈 것입니다. Redux의 저자 Dan Abramov의 좋은 인용문이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6537ddc12952ad16232d8a921be6b7d5a76a6d6" translate="yes" xml:space="preserve">
          <source>If your getters have complicated computation, it is worth testing them. Getters are also very straightforward to test for the same reason as mutations.</source>
          <target state="translated">게터가 복잡한 계산을하는 경우 테스트 할 가치가 있습니다. 게터는 돌연변이와 같은 이유로 테스트하기도 매우 간단합니다.</target>
        </trans-unit>
        <trans-unit id="4de758dad2a92aec248785ac4d6dbc0ff778d9aa" translate="yes" xml:space="preserve">
          <source>If your mutations and actions are written properly, the tests should have no direct dependency on Browser APIs after proper mocking. Thus you can simply bundle the tests with webpack and run it directly in Node. Alternatively, you can use &lt;code&gt;mocha-loader&lt;/code&gt; or Karma + &lt;code&gt;karma-webpack&lt;/code&gt; to run the tests in real browsers.</source>
          <target state="translated">돌연변이와 동작이 올바르게 작성된 경우 테스트는 적절한 조롱 후 브라우저 API에 직접 의존하지 않아야합니다. 따라서 테스트를 webpack과 함께 번들로 묶어 Node에서 직접 실행할 수 있습니다. 또는 &lt;code&gt;mocha-loader&lt;/code&gt; 또는 Karma + &lt;code&gt;karma-webpack&lt;/code&gt; 을 사용하여 실제 브라우저에서 테스트를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ee31c41647a54af22ae141a98d0fec5c96154f7" translate="yes" xml:space="preserve">
          <source>In Vuex 3, &lt;code&gt;createLogger&lt;/code&gt; function was exported from &lt;code&gt;vuex/dist/logger&lt;/code&gt; but it's now included in the core package. The function should be imported directly from the &lt;code&gt;vuex&lt;/code&gt; package.</source>
          <target state="translated">Vuex 3에서는 &lt;code&gt;createLogger&lt;/code&gt; 함수가 &lt;code&gt;vuex/dist/logger&lt;/code&gt; 에서 내보내 졌지만 이제 핵심 패키지에 포함되었습니다. 이 함수는 &lt;code&gt;vuex&lt;/code&gt; 패키지 에서 직접 가져와야 합니다.</target>
        </trans-unit>
        <trans-unit id="7a410e66d911dd3ae0a50e7b80b34a4ce49f0e9c" translate="yes" xml:space="preserve">
          <source>In a Vue component, you can access the store as &lt;code&gt;this.$store&lt;/code&gt;. Now we can commit a mutation using a component method:</source>
          <target state="translated">Vue 컴포넌트에서 &lt;code&gt;this.$store&lt;/code&gt; 로 스토어에 액세스 할 수 있습니다 . 이제 컴포넌트 메소드를 사용하여 뮤 테이션을 커밋 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b21dc6e7af159e44f13e61d052a381cc5930fcfa" translate="yes" xml:space="preserve">
          <source>In most cases, the payload should be an object so that it can contain multiple fields, and the recorded mutation will also be more descriptive:</source>
          <target state="translated">대부분의 경우, 페이로드는 여러 필드를 포함 할 수있는 객체 여야하며 기록 된 돌연변이도보다 설명 적입니다.</target>
        </trans-unit>
        <trans-unit id="c8e693418938cacbff5b768a895b5e05008f1bcd" translate="yes" xml:space="preserve">
          <source>In order to access state and getters, you will want to create &lt;code&gt;computed&lt;/code&gt; references to retain reactivity. This is the equivalent of creating computed properties using the Option API.</source>
          <target state="translated">상태 및 게터에 액세스하려면 반응성을 유지 하기 위해 &lt;code&gt;computed&lt;/code&gt; 참조를 만들어야 합니다. 이것은 Option API를 사용하여 계산 된 속성을 만드는 것과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="b379a9de19b6c2947713c2e819c098b0d0414341" translate="yes" xml:space="preserve">
          <source>In practice, we often use ES2015 &lt;a href=&quot;https://github.com/lukehoban/es6features#destructuring&quot;&gt;argument destructuring&lt;/a&gt; to simplify the code a bit (especially when we need to call &lt;code&gt;commit&lt;/code&gt; multiple times):</source>
          <target state="translated">실제로 ES2015 &lt;a href=&quot;https://github.com/lukehoban/es6features#destructuring&quot;&gt;인수 소멸&lt;/a&gt; 을 사용하여 코드를 약간 단순화합니다 (특히 &lt;code&gt;commit&lt;/code&gt; 여러 번 호출해야하는 경우 ).</target>
        </trans-unit>
        <trans-unit id="3857e213dc0f7b8c7391de2df6fe7f4ad9600a0c" translate="yes" xml:space="preserve">
          <source>In strict mode, whenever Vuex state is mutated outside of mutation handlers, an error will be thrown. This ensures that all state mutations can be explicitly tracked by debugging tools.</source>
          <target state="translated">엄격 모드에서는 Vuex 상태가 변이 핸들러 외부에서 변이 될 때마다 오류가 발생합니다. 이를 통해 디버깅 도구를 통해 모든 상태 돌연변이를 명시 적으로 추적 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f605f46f5b670a253f694d77a6479a46bf60c051" translate="yes" xml:space="preserve">
          <source>In such cases, you can pass the module namespace string as the first argument to the helpers so that all bindings are done using that module as the context. The above can be simplified to:</source>
          <target state="translated">이러한 경우 모듈 네임 스페이스 문자열을 도우미에 대한 첫 번째 인수로 전달하여 해당 모듈을 컨텍스트로 사용하여 모든 바인딩을 수행 할 수 있습니다. 위와 같이 단순화 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="fb4ca597574fefd3c18365a4df91a07d3925f51b" translate="yes" xml:space="preserve">
          <source>Include &lt;code&gt;vuex&lt;/code&gt; after Vue and it will install itself automatically:</source>
          <target state="translated">Vue 뒤에 &lt;code&gt;vuex&lt;/code&gt; 를 포함 시키면 자동으로 설치됩니다 :</target>
        </trans-unit>
        <trans-unit id="4edd5883cfc0f50d6093450192a5526d804c388e" translate="yes" xml:space="preserve">
          <source>Inside a module's mutations and getters, the first argument received will be &lt;strong&gt;the module's local state&lt;/strong&gt;.</source>
          <target state="translated">모듈의 변이와 게터 안에서 가장 먼저받는 인수 &lt;strong&gt;는 모듈의 로컬 상태&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="457ba19288441fafbf211b7b6c88681a0845bc6a" translate="yes" xml:space="preserve">
          <source>Install &lt;code&gt;mocha-loader&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mocha-loader&lt;/code&gt; 를 설치하십시오 .</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="cddc92ee3266aa27b7cb36a384142725c9edaa5f" translate="yes" xml:space="preserve">
          <source>Installation process</source>
          <target state="translated">설치 과정</target>
        </trans-unit>
        <trans-unit id="9d0fe35d22060e945e08d2b96b5abfd85eb87e88" translate="yes" xml:space="preserve">
          <source>Instead of mutating the state, actions commit mutations.</source>
          <target state="translated">상태를 변경하는 대신 작업이 돌연변이를 저지 릅니다.</target>
        </trans-unit>
        <trans-unit id="fb1e51da35f8b4fc5e80bad74fa44c9f09edf0fe" translate="yes" xml:space="preserve">
          <source>It is a commonly seen pattern to use constants for mutation types in various Flux implementations. This allows the code to take advantage of tooling like linters, and putting all constants in a single file allows your collaborators to get an at-a-glance view of what mutations are possible in the entire application:</source>
          <target state="translated">다양한 Flux 구현에서 돌연변이 유형에 상수를 사용하는 것이 일반적으로 보이는 패턴입니다. 이를 통해 코드는 린터와 같은 툴링을 활용할 수 있으며 모든 상수를 단일 파일에 배치하면 공동 작업자가 전체 응용 프로그램에서 어떤 돌연변이가 가능한지 한 눈에 파악할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3f113c6b42082f72c3757fb134ac642d34ef542" translate="yes" xml:space="preserve">
          <source>It is a self-contained app with the following parts:</source>
          <target state="translated">다음과 같은 부분이 포함 된 독립형 앱입니다.</target>
        </trans-unit>
        <trans-unit id="3ed4288f050eb852b800df4047f36461f3b17cbb" translate="yes" xml:space="preserve">
          <source>It may be likely that you want to preserve the previous state when registering a new module, such as preserving state from a Server Side Rendered app. You can achieve this with &lt;code&gt;preserveState&lt;/code&gt; option: &lt;code&gt;store.registerModule('a', module, { preserveState: true })&lt;/code&gt;</source>
          <target state="translated">서버 측 렌더링 앱에서 상태 유지와 같은 새 모듈을 등록 할 때 이전 상태를 유지하려고 할 수 있습니다. &lt;code&gt;preserveState&lt;/code&gt; 옵션을 사용 하여이를 달성 할 수 있습니다 . &lt;code&gt;store.registerModule('a', module, { preserveState: true })&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="35dface9e340cb4e3bddcda3e4f2453cf5b8832e" translate="yes" xml:space="preserve">
          <source>It's possible for a &lt;code&gt;store.dispatch&lt;/code&gt; to trigger multiple action handlers in different modules. In such a case the returned value will be a Promise that resolves when all triggered handlers have been resolved.</source>
          <target state="translated">A에 대한이 가능 &lt;code&gt;store.dispatch&lt;/code&gt; 가 다른 모듈에서 여러 액션 핸들러를 트리거 할 수 있습니다. 이러한 경우 반환 된 값은 모든 트리거 된 처리기가 해결되면 해결되는 약속입니다.</target>
        </trans-unit>
        <trans-unit id="c26d954c51975d2534551b78c8a2337962fddd24" translate="yes" xml:space="preserve">
          <source>Last Updated:</source>
          <target state="translated">마지막 업데이트 :</target>
        </trans-unit>
        <trans-unit id="dea187f850a75f522b6507857c44f2cc66982153" translate="yes" xml:space="preserve">
          <source>Leaves prod/dev branches with &lt;code&gt;process.&lt;wbr/&gt;env.NODE_ENV&lt;/code&gt; guards (must be replaced by bundler).</source>
          <target state="translated">prod / dev 브랜치를 &lt;code&gt;process.&lt;wbr/&gt;env.NODE_ENV&lt;/code&gt; 남겨 둡니다 . env.NODE_ENV 가드 ( 번 들러 로 교체해야 함).</target>
        </trans-unit>
        <trans-unit id="fad0c3d2dd4948e1dc7eca7ef59267b9baf27c8d" translate="yes" xml:space="preserve">
          <source>Leaves prod/dev branches with &lt;code&gt;process.env.NODE_ENV&lt;/code&gt; guards (must be replaced by bundler).</source>
          <target state="translated">prod / dev 분기를 &lt;code&gt;process.env.NODE_ENV&lt;/code&gt; 가드로 남겨 둡니다 (번 들러로 대체해야 함).</target>
        </trans-unit>
        <trans-unit id="d9285043eca58d77420a4ea528c9c0140b7f99e5" translate="yes" xml:space="preserve">
          <source>Let's register a simple action:</source>
          <target state="translated">간단한 행동을 등록합시다 :</target>
        </trans-unit>
        <trans-unit id="e58183fe873032e36b18fd13feeb2f3de6adac51" translate="yes" xml:space="preserve">
          <source>Let's start with a simple Vue counter app:</source>
          <target state="translated">간단한 Vue 카운터 앱으로 시작해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="c7d28df54f0ee7bb49a6c375079257b9e2ce533e" translate="yes" xml:space="preserve">
          <source>Let's tackle this step by step. First, define the key using Vue's &lt;code&gt;InjectionKey&lt;/code&gt; interface along with your own store typing definition:</source>
          <target state="translated">이 단계를 단계별로 해결해 봅시다. 먼저 Vue의 &lt;code&gt;InjectionKey&lt;/code&gt; 인터페이스를 사용하여 자신의 상점 유형 정의와 함께 키를 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">MIT 라이센스에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="3c4e2ff1708a0052c627ff0c7963ae29daba2c37" translate="yes" xml:space="preserve">
          <source>Method-Style Access</source>
          <target state="translated">메소드 스타일 액세스</target>
        </trans-unit>
        <trans-unit id="c2e90d9f7d5710359410a2feb78df1c412eb56ec" translate="yes" xml:space="preserve">
          <source>Migrating to 4.0 from 3.x</source>
          <target state="translated">3.x에서 4.0으로 마이그레이션</target>
        </trans-unit>
        <trans-unit id="64f4a0ce2e411202b8f65d464a7de482b8f37081" translate="yes" xml:space="preserve">
          <source>Module Local State</source>
          <target state="translated">모듈 로컬 상태</target>
        </trans-unit>
        <trans-unit id="da07abb5f2f59744fb9d34a53f63697e0f2d1603" translate="yes" xml:space="preserve">
          <source>Module Reuse</source>
          <target state="translated">모듈 재사용</target>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="f4e46025da22a7ac6c15f6c0d760b1ec96373a5b" translate="yes" xml:space="preserve">
          <source>Most commonly used in plugins. &lt;a href=&quot;../guide/plugins&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">플러그인에서 가장 일반적으로 사용됩니다. &lt;a href=&quot;../guide/plugins&quot;&gt;세부&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="415ace164c00364e28e4d1cc0b1dea319d4e4fe4" translate="yes" xml:space="preserve">
          <source>Multiple views may depend on the same piece of state.</source>
          <target state="translated">여러 뷰는 동일한 상태에 따라 달라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00a7fb731451c41a484b7591ece27f55c474ec0e" translate="yes" xml:space="preserve">
          <source>Mutations</source>
          <target state="translated">Mutations</target>
        </trans-unit>
        <trans-unit id="104200b8a17f6d972a707d856a1247d4c7c79f01" translate="yes" xml:space="preserve">
          <source>Mutations Follow Vue's Reactivity Rules</source>
          <target state="translated">돌연변이는 Vue의 반응성 규칙을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="1c4ca77f8cfecf119f2abce71ca721d4bcfe55b6" translate="yes" xml:space="preserve">
          <source>Mutations Must Be Synchronous</source>
          <target state="translated">돌연변이는 동 기적이어야한다</target>
        </trans-unit>
        <trans-unit id="654ac141ada51cc2648d26957205d691ce5cdaec" translate="yes" xml:space="preserve">
          <source>Mutations are very straightforward to test, because they are just functions that completely rely on their arguments. One trick is that if you are using ES2015 modules and put your mutations inside your &lt;code&gt;store.js&lt;/code&gt; file, in addition to the default export, you should also export the mutations as a named export:</source>
          <target state="translated">돌연변이는 인수에 완전히 의존하는 함수일 뿐이므로 테스트하기가 매우 간단합니다. 하나의 트릭은 ES2015 모듈을 사용 하고 기본 내보내기 외에 돌연변이를 &lt;code&gt;store.js&lt;/code&gt; 파일에 넣는 경우 돌연변이를 명명 된 내보내기로 내 보내야한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a8ad860c15810cce0e7beac1c91da3ab2cb22c47" translate="yes" xml:space="preserve">
          <source>NOTE</source>
          <target state="translated">NOTE</target>
        </trans-unit>
        <trans-unit id="7d94ebbf07f5417771d7c7fd06f208703494bf50" translate="yes" xml:space="preserve">
          <source>NPM</source>
          <target state="translated">NPM</target>
        </trans-unit>
        <trans-unit id="f0146eaf3d75ae19152beec5a891e0df9b9d3793" translate="yes" xml:space="preserve">
          <source>Namespaced getters and actions will receive localized &lt;code&gt;getters&lt;/code&gt;, &lt;code&gt;dispatch&lt;/code&gt; and &lt;code&gt;commit&lt;/code&gt;. In other words, you can use the module assets without writing prefix in the same module. Toggling between namespaced or not does not affect the code inside the module.</source>
          <target state="translated">네임 스페이스가있는 게터와 액션은 현지화 된 &lt;code&gt;getters&lt;/code&gt; 를 받고 , &lt;code&gt;dispatch&lt;/code&gt; 및 &lt;code&gt;commit&lt;/code&gt; 합니다. 즉, 동일한 모듈에서 접두사를 쓰지 않고 모듈 자산을 사용할 수 있습니다. 네임 스페이스 또는 네임 스페이스 간을 전환해도 모듈 내부의 코드에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="362b423baafd1e7b201b94eb4694146a945d2f27" translate="yes" xml:space="preserve">
          <source>Namespacing</source>
          <target state="translated">Namespacing</target>
        </trans-unit>
        <trans-unit id="156e3db7d7ff24a58bfd4733460906ddcf9c82d6" translate="yes" xml:space="preserve">
          <source>New &quot;useStore&quot; composition function</source>
          <target state="translated">새로운 &quot;useStore&quot;구성 기능</target>
        </trans-unit>
        <trans-unit id="a71d5762c0258836841ff5df622a89af0d09ccba" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;useStore&lt;/code&gt; composition function</source>
          <target state="translated">새로운 &lt;code&gt;useStore&lt;/code&gt; 구성 기능</target>
        </trans-unit>
        <trans-unit id="025519ea3f483eb11a3c8608b8a731eee0947b1b" translate="yes" xml:space="preserve">
          <source>New Features</source>
          <target state="translated">새로운 기능</target>
        </trans-unit>
        <trans-unit id="4820b6a8eaff4049273790823038a2d97641ee6b" translate="yes" xml:space="preserve">
          <source>New in 2.5.0</source>
          <target state="translated">2.5.0의 새로운 기능</target>
        </trans-unit>
        <trans-unit id="ee5b92286bff361e6506cbde70ab9d79b67f9e22" translate="yes" xml:space="preserve">
          <source>New in 3.1.0</source>
          <target state="translated">3.1.0의 새로운 기능</target>
        </trans-unit>
        <trans-unit id="f603edae1429a95385a9e96dce7eed555212b05b" translate="yes" xml:space="preserve">
          <source>Next, pass the defined injection key when installing the store to the Vue app:</source>
          <target state="translated">다음으로 Vue 앱에 스토어를 설치할 때 정의 된 주입 키를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="94cbec932a3607b921845482469e8e3e43a2cef8" translate="yes" xml:space="preserve">
          <source>Next, we will discuss each core concept in much finer details, starting with &lt;a href=&quot;state&quot;&gt;State&lt;/a&gt;.</source>
          <target state="translated">다음으로 &lt;a href=&quot;state&quot;&gt;State&lt;/a&gt; 부터 시작하여 각 핵심 개념에 대해보다 자세히 설명 합니다.</target>
        </trans-unit>
        <trans-unit id="8a19151987fbe02547ee0f70513d32dd282c4ac0" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;mapState&lt;/code&gt; returns an object. How do we use it in combination with other local computed properties? Normally, we'd have to use a utility to merge multiple objects into one so that we can pass the final object to &lt;code&gt;computed&lt;/code&gt;. However with the &lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread&quot;&gt;object spread operator&lt;/a&gt; (which is a stage-4 ECMAScript proposal), we can greatly simplify the syntax:</source>
          <target state="translated">참고 &lt;code&gt;mapState&lt;/code&gt; 가 개체를 반환합니다. 다른 로컬 계산 속성과 함께 어떻게 사용합니까? 일반적으로 유틸리티를 사용하여 여러 객체를 하나로 병합해야 최종 객체를 &lt;code&gt;computed&lt;/code&gt; 에 전달할 수 있습니다 . 그러나 &lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread&quot;&gt;객체 확산 연산자&lt;/a&gt; (4 단계 ECMAScript 제안)를 사용하면 구문을 크게 단순화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8fdd2db4fff8fb671f8b5b5304c69fa03718c6bb" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;mapState&lt;/code&gt; returns an object. How do we use it in combination with other local computed properties? Normally, we'd have to use a utility to merge multiple objects into one so that we can pass the final object to &lt;code&gt;computed&lt;/code&gt;. However with the &lt;a href=&quot;https://github.com/tc39/proposal-object-rest-spread&quot;&gt;object spread operator&lt;/a&gt;, we can greatly simplify the syntax:</source>
          <target state="translated">참고 &lt;code&gt;mapState&lt;/code&gt; 가 개체를 반환합니다. 다른 로컬 계산 속성과 함께 어떻게 사용합니까? 일반적으로 우리는 최종 객체를 &lt;code&gt;computed&lt;/code&gt; 에 전달할 수 있도록 여러 객체를 하나로 병합하는 유틸리티를 사용해야합니다 . 그러나 &lt;a href=&quot;https://github.com/tc39/proposal-object-rest-spread&quot;&gt;객체 확산 연산자를&lt;/a&gt; 사용하면 구문을 크게 단순화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="383f040aea7fdc521540d519355364a1d7f735a8" translate="yes" xml:space="preserve">
          <source>Note that getters accessed as properties are cached as part of Vue's reactivity system.</source>
          <target state="translated">속성으로 액세스 된 게터는 Vue의 반응성 시스템의 일부로 캐시됩니다.</target>
        </trans-unit>
        <trans-unit id="ee0bf46abe7c412da05c2c7e1afee2ada212118c" translate="yes" xml:space="preserve">
          <source>Note that getters accessed via methods will run each time you call them, and the result is not cached.</source>
          <target state="translated">메소드를 통해 액세스 된 getter는 호출 할 때마다 실행되며 결과는 캐시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d5717e27426eb7a2d5c1747c90156711ec9ef26a" translate="yes" xml:space="preserve">
          <source>Note that you may check if the module is already registered to the store or not via &lt;code&gt;store.hasModule(moduleName)&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;store.hasModule(moduleName)&lt;/code&gt; 메서드 를 통해 모듈이 이미 스토어에 등록되었는지 여부를 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="93fca34876045ca8e7715e28c6d04cb4373157ba" translate="yes" xml:space="preserve">
          <source>Note the logger plugin takes state snapshots, so use it only during development.</source>
          <target state="translated">로거 플러그인은 상태 스냅 샷을 작성하므로 개발 중에 만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="11f45dfd75b6d4fbcfd55b7ac788bd4b130224b1" translate="yes" xml:space="preserve">
          <source>Note we are performing a flow of asynchronous operations, and recording the side effects (state mutations) of the action by committing them.</source>
          <target state="translated">비동기 작업의 흐름을 수행하고 작업의 부작용 (상태 돌연변이)을 커밋하여 기록합니다.</target>
        </trans-unit>
        <trans-unit id="ab293ff1751dac6b50aacc1c946da9ff9bd12a5a" translate="yes" xml:space="preserve">
          <source>Now imagine we are debugging the app and looking at the devtool's mutation logs. For every mutation logged, the devtool will need to capture a &quot;before&quot; and &quot;after&quot; snapshots of the state. However, the asynchronous callback inside the example mutation above makes that impossible: the callback is not called yet when the mutation is committed, and there's no way for the devtool to know when the callback will actually be called - any state mutation performed in the callback is essentially un-trackable!</source>
          <target state="translated">이제 앱을 디버깅하고 devtool의 돌연변이 로그를보고 있다고 상상해보십시오. 기록 된 모든 돌연변이에 대해 devtool은 상태의 &quot;이전&quot;및 &quot;이후&quot;스냅 샷을 캡처해야합니다. 그러나 위의 예제 돌연변이 내부의 비동기 콜백은 불가능합니다. 돌연변이가 커밋되었을 때 콜백이 아직 호출되지 않고 콜백이 실제로 언제 호출되는지 devtool이 알 수있는 방법이 없습니다-콜백에서 수행 된 상태 돌연변이 본질적으로 추적 할 수 없습니다!</target>
        </trans-unit>
        <trans-unit id="93b9e7a0a6529c120d308e3a9afc60556aa4685a" translate="yes" xml:space="preserve">
          <source>Now you can do:</source>
          <target state="translated">이제 할 수있는 일 :</target>
        </trans-unit>
        <trans-unit id="a5bc280bd65d97298b6a537bbd98ca0fca61ada2" translate="yes" xml:space="preserve">
          <source>Now, by importing your own composable function, you can retrieve the typed store &lt;strong&gt;without&lt;/strong&gt; having to provide the injection key and it's typing:</source>
          <target state="translated">이제 자신의 구성 가능한 함수를 가져 와서 주입 키를 제공 &lt;strong&gt;하지 않고도&lt;/strong&gt; 입력 된 저장소 &lt;strong&gt;를&lt;/strong&gt; 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cab930ccc32a830cf1b2daffb710e302771e1ccf" translate="yes" xml:space="preserve">
          <source>Now, you can access the state object as &lt;code&gt;store.state&lt;/code&gt;, and trigger a state change with the &lt;code&gt;store.commit&lt;/code&gt; method:</source>
          <target state="translated">이제 상태 객체를 &lt;code&gt;store.state&lt;/code&gt; 로 액세스 하고 &lt;code&gt;store.commit&lt;/code&gt; 메소드를 사용하여 상태 변경을 트리거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ace4a2b4fe085d950494ad9721a19fbdb4b869ed" translate="yes" xml:space="preserve">
          <source>Object Spread Operator</source>
          <target state="translated">객체 확산 연산자</target>
        </trans-unit>
        <trans-unit id="4e55a0d58d5e1d3dd2c370978eeab3967aadea55" translate="yes" xml:space="preserve">
          <source>Object-Style Commit</source>
          <target state="translated">객체 스타일 커밋</target>
        </trans-unit>
        <trans-unit id="af6888b6f45f7db98c78eb748575fc0a520bf758" translate="yes" xml:space="preserve">
          <source>On to Actions</source>
          <target state="translated">행동으로</target>
        </trans-unit>
        <trans-unit id="be28144bfe8196f5de9245ef24f38b80c1795631" translate="yes" xml:space="preserve">
          <source>One important rule to remember is that &lt;strong&gt;mutation handler functions must be synchronous&lt;/strong&gt;. Why? Consider the following example:</source>
          <target state="translated">기억 &lt;strong&gt;해야 할&lt;/strong&gt; 중요한 규칙 중 하나는 &lt;strong&gt;변이 핸들러 함수가 동기식이어야한다는 것&lt;/strong&gt; 입니다. 왜? 다음 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="0a517ce6f632f361387aae43f330fac6b9ff2fb5" translate="yes" xml:space="preserve">
          <source>Pass the typed &lt;code&gt;InjectionKey&lt;/code&gt; to the &lt;code&gt;useStore&lt;/code&gt; method.</source>
          <target state="translated">typed &lt;code&gt;InjectionKey&lt;/code&gt; 를 &lt;code&gt;useStore&lt;/code&gt; 메소드에 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="b2228a15359ec1787af59c5da6ce5e371da06846" translate="yes" xml:space="preserve">
          <source>Place the following code in your project to allow &lt;code&gt;this.$store&lt;/code&gt; to be typed correctly:</source>
          <target state="translated">&lt;code&gt;this.$store&lt;/code&gt; 를 올바르게 입력 할 수 있도록 프로젝트에 다음 코드를 배치 합니다.</target>
        </trans-unit>
        <trans-unit id="ab2e26dd8b8868a3969cb3321e0c983c0d9d67d4" translate="yes" xml:space="preserve">
          <source>Plugins</source>
          <target state="translated">Plugins</target>
        </trans-unit>
        <trans-unit id="22f632f9f25219b387e3b3f91a16935bbf27d29a" translate="yes" xml:space="preserve">
          <source>Plugins are not allowed to directly mutate state - similar to your components, they can only trigger changes by committing mutations.</source>
          <target state="translated">플러그인은 상태를 직접 변경하는 것이 허용되지 않습니다. 구성 요소와 유사하게, 변경 사항을 적용하여 변경 사항을 트리거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="184f9c5d6a512ea46935550bc3405af620cc2aa9" translate="yes" xml:space="preserve">
          <source>Prefer initializing your store's initial state with all desired fields upfront.</source>
          <target state="translated">원하는 모든 필드를 사전에 저장하여 상점의 초기 상태를 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="e7e706a353f493baa85f48336645f1af9ce6a62b" translate="yes" xml:space="preserve">
          <source>Preserving state</source>
          <target state="translated">보존 상태</target>
        </trans-unit>
        <trans-unit id="fe5671922bc7f67cfabfa60ab97a9542ac21f39f" translate="yes" xml:space="preserve">
          <source>Promise</source>
          <target state="translated">Promise</target>
        </trans-unit>
        <trans-unit id="8dc7952272c26facc9a2c5604edbd77344108471" translate="yes" xml:space="preserve">
          <source>Property-Style Access</source>
          <target state="translated">부동산 스타일 액세스</target>
        </trans-unit>
        <trans-unit id="f3080b3597ce40f7b3c7da14211527d0235807a1" translate="yes" xml:space="preserve">
          <source>Provide the typed &lt;code&gt;InjectionKey&lt;/code&gt; when installing a store to the Vue app.</source>
          <target state="translated">Vue 앱에 스토어를 설치할 때 입력 한 &lt;code&gt;InjectionKey&lt;/code&gt; 를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="5fffd76e54cabe19ee1677cc2622cd23e6e275e9" translate="yes" xml:space="preserve">
          <source>Reactively watch &lt;code&gt;fn&lt;/code&gt;'s return value, and call the callback when the value changes. &lt;code&gt;fn&lt;/code&gt; receives the store's state as the first argument, and getters as the second argument. Accepts an optional options object that takes the same options as &lt;a href=&quot;https://vuejs.org/v2/api/#vm-watch&quot;&gt;Vue's &lt;code&gt;vm.$watch&lt;/code&gt; method&lt;/a&gt;.</source>
          <target state="translated">반응 적보고 &lt;code&gt;fn&lt;/code&gt; 의 반환 값을, 값이 변경 될 때 콜백을 호출합니다. &lt;code&gt;fn&lt;/code&gt; 은 저장소의 상태를 첫 번째 인수로 받고 getter는 두 번째 인수로받습니다. &lt;a href=&quot;https://vuejs.org/v2/api/#vm-watch&quot;&gt;Vue의 &lt;code&gt;vm.$watch&lt;/code&gt; 메소드&lt;/a&gt; 와 동일한 옵션을 사용하는 선택적 옵션 오브젝트를 승인합니다 .</target>
        </trans-unit>
        <trans-unit id="75e4ab33b7b5dc7455e9eadf2e7119121508fb6e" translate="yes" xml:space="preserve">
          <source>Register Global Action in Namespaced Modules</source>
          <target state="translated">네임 스페이스가있는 모듈에서 전역 작업 등록</target>
        </trans-unit>
        <trans-unit id="de6210ec05f575ccd3825af5410dca87db3c1a7e" translate="yes" xml:space="preserve">
          <source>Register a dynamic module. &lt;a href=&quot;../guide/modules#dynamic-module-registration&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">동적 모듈을 등록하십시오. &lt;a href=&quot;../guide/modules#dynamic-module-registration&quot;&gt;세부&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ad2bb0219d3b7cad70e9aeaf8b370461d8c5f459" translate="yes" xml:space="preserve">
          <source>Register actions on the store. The handler function receives a &lt;code&gt;context&lt;/code&gt; object that exposes the following properties:</source>
          <target state="translated">상점에 조치를 등록하십시오. 핸들러 함수는 다음 특성을 노출 하는 &lt;code&gt;context&lt;/code&gt; 오브젝트를 수신 합니다.</target>
        </trans-unit>
        <trans-unit id="0c3c4cb0360b08ab239d9d6ce7ef5979c7bd75c9" translate="yes" xml:space="preserve">
          <source>Register getters on the store. The getter function receives the following arguments:</source>
          <target state="translated">상점에 게터를 등록하십시오. getter 함수는 다음 인수를받습니다.</target>
        </trans-unit>
        <trans-unit id="b656445541eada906150dd7ca28e7277b3f8ac2d" translate="yes" xml:space="preserve">
          <source>Register mutations on the store. The handler function always receives &lt;code&gt;state&lt;/code&gt; as the first argument (will be module local state if defined in a module), and receives a second &lt;code&gt;payload&lt;/code&gt; argument if there is one.</source>
          <target state="translated">상점에 돌연변이를 등록하십시오. 핸들러 함수는 항상 &lt;code&gt;state&lt;/code&gt; 를 첫 번째 인수로 받고 (모듈에 정의 된 경우 모듈 로컬 상태가 됨) 두 번째 &lt;code&gt;payload&lt;/code&gt; 인수가 있으면 이를받습니다 .</target>
        </trans-unit>
        <trans-unit id="17a6292e850aa27ddd8a69f3670d7bf427ff4201" translate="yes" xml:space="preserve">
          <source>Register the same module multiple times in the same store.</source>
          <target state="translated">동일한 상점에서 동일한 모듈을 여러 번 등록하십시오.</target>
        </trans-unit>
        <trans-unit id="9adccc4f4e3ee229d76671c447375a4b4430cf1a" translate="yes" xml:space="preserve">
          <source>Registered getters are exposed on &lt;code&gt;store.getters&lt;/code&gt;.</source>
          <target state="translated">등록 된 게터는 &lt;code&gt;store.getters&lt;/code&gt; 에 노출됩니다 .</target>
        </trans-unit>
        <trans-unit id="e74661ca249919f9eff75810910ad50f600b9f27" translate="yes" xml:space="preserve">
          <source>Replace that Object with a fresh one. For example, using the &lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread&quot;&gt;object spread syntax&lt;/a&gt; we can write it like this:</source>
          <target state="translated">해당 객체를 새 것으로 교체하십시오. 예를 들어, &lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread&quot;&gt;오브젝트 스프레드 구문을&lt;/a&gt; 사용하여 다음 과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfc7d1d9a1abac11e07fd8298b3033a2dd367be4" translate="yes" xml:space="preserve">
          <source>Replace the store's root state. Use this only for state hydration / time-travel purposes.</source>
          <target state="translated">상점의 루트 상태를 바꾸십시오. 상태 수화 / 시간 여행 목적으로 만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7ec9eede60ad8e8637510a86e616531533ada02f" translate="yes" xml:space="preserve">
          <source>Running Tests</source>
          <target state="translated">테스트 실행</target>
        </trans-unit>
        <trans-unit id="11b20f83f47c6fa0a2ecb66cf17c37a8bf3312ce" translate="yes" xml:space="preserve">
          <source>Running in Browser</source>
          <target state="translated">브라우저에서 실행</target>
        </trans-unit>
        <trans-unit id="27b89784a5a88ae4dea9d0fe0a57d6ac83db22be" translate="yes" xml:space="preserve">
          <source>Running in Browser with Karma + karma-webpack</source>
          <target state="translated">Karma + karma-webpack으로 브라우저에서 실행</target>
        </trans-unit>
        <trans-unit id="cbd1c1641d5f61fff635a6b95f6786707cdb60a6" translate="yes" xml:space="preserve">
          <source>Running in Node</source>
          <target state="translated">노드에서 실행</target>
        </trans-unit>
        <trans-unit id="b7a73f532334578b3a16beb74895158fa37aca37" translate="yes" xml:space="preserve">
          <source>Similar to plugins, we can let the build tools handle that:</source>
          <target state="translated">플러그인과 마찬가지로 빌드 도구가 다음을 처리하도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6440404824fd3c3690de22244c1449cd72882e79" translate="yes" xml:space="preserve">
          <source>Similarly, inside module actions, &lt;code&gt;context.state&lt;/code&gt; will expose the local state, and root state will be exposed as &lt;code&gt;context.rootState&lt;/code&gt;:</source>
          <target state="translated">마찬가지로 모듈 작업 내에서 &lt;code&gt;context.state&lt;/code&gt; 는 로컬 상태를 노출하고 루트 상태는 &lt;code&gt;context.rootState&lt;/code&gt; 로 노출됩니다 .</target>
        </trans-unit>
        <trans-unit id="ca9c5e520923e6214e6e652479441ba757527ff7" translate="yes" xml:space="preserve">
          <source>Simplifying &lt;code&gt;useStore&lt;/code&gt; usage</source>
          <target state="translated">&lt;code&gt;useStore&lt;/code&gt; 사용 단순화</target>
        </trans-unit>
        <trans-unit id="025e718449a36bec79871ddaaf94c1265848b2f1" translate="yes" xml:space="preserve">
          <source>Since 3.1.0, &lt;code&gt;subscribeAction&lt;/code&gt; can also specify whether the subscribe handler should be called &lt;em&gt;before&lt;/em&gt; or &lt;em&gt;after&lt;/em&gt; an action dispatch (the default behavior is &lt;em&gt;before&lt;/em&gt;):</source>
          <target state="translated">3.1.0부터 &lt;code&gt;subscribeAction&lt;/code&gt; 은 구독 핸들러가 조치 디스패치 &lt;em&gt;이전&lt;/em&gt; 또는 &lt;em&gt;이후에&lt;/em&gt; 호출되어야하는지 여부를 지정할 수도 있습니다 (기본 동작은 &lt;em&gt;before&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="f3fd68e0c5995c6798e0356b50e929c10917b3a4" translate="yes" xml:space="preserve">
          <source>Since a Vuex store's state is made reactive by Vue, when we mutate the state, Vue components observing the state will update automatically. This also means Vuex mutations are subject to the same reactivity caveats when working with plain Vue:</source>
          <target state="translated">Vuex 스토어의 상태는 Vue에 의해 반응하므로 상태를 변경하면 상태를 관찰하는 Vue 구성 요소가 자동으로 업데이트됩니다. 이것은 또한 Vuex 돌연변이가 일반 Vue로 작업 할 때 동일한 반응성 경고에 노출됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="92041cc87d58be0a729eade29063235fe14b3c9c" translate="yes" xml:space="preserve">
          <source>Single State Tree</source>
          <target state="translated">단일 상태 트리</target>
        </trans-unit>
        <trans-unit id="5f6ffb7192daf8fe93bcac0572129c5101463336" translate="yes" xml:space="preserve">
          <source>So how do we display state inside the store in our Vue components? Since Vuex stores are reactive, the simplest way to &quot;retrieve&quot; state from it is simply returning some store state from within a &lt;a href=&quot;https://vuejs.org/guide/computed.html&quot;&gt;computed property&lt;/a&gt;:</source>
          <target state="translated">Vue 구성 요소의 매장 내부 상태를 어떻게 표시합니까? Vuex 매장은 반응 형이므로 상태를 &quot;검색&quot;하는 가장 간단한 방법은 &lt;a href=&quot;https://vuejs.org/guide/computed.html&quot;&gt;계산 된 속성&lt;/a&gt; 내에서 일부 매장 상태를 반환하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="54d205729e342259f235761f9ebec2b225fe9abb" translate="yes" xml:space="preserve">
          <source>So why don't we extract the shared state out of the components, and manage it in a global singleton? With this, our component tree becomes a big &quot;view&quot;, and any component can access the state or trigger actions, no matter where they are in the tree!</source>
          <target state="translated">그렇다면 컴포넌트에서 공유 상태를 추출하여 글로벌 싱글 톤으로 관리하지 않는 이유는 무엇입니까? 이를 통해 컴포넌트 트리는 큰 &quot;보기&quot;가되며, 트리의 어느 위치에 있더라도 모든 컴포넌트가 상태에 액세스하거나 액션을 트리거 할 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="f9f500529b87d6c41aa1c9ce2a53ab85b0f73f09" translate="yes" xml:space="preserve">
          <source>Sometimes a plugin may want to receive &quot;snapshots&quot; of the state, and also compare the post-mutation state with pre-mutation state. To achieve that, you will need to perform a deep-copy on the state object:</source>
          <target state="translated">때때로 플러그인은 상태의 &quot;스냅 샷&quot;을 수신하고 변이 후 상태와 변이 전 상태를 비교할 수 있습니다. 이를 위해서는 상태 객체에 대한 심층 복사를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="ae8a5bdac2cd3270ab81602ae7fc6131bdbc35db" translate="yes" xml:space="preserve">
          <source>Sometimes we may need to compute derived state based on store state, for example filtering through a list of items and counting them:</source>
          <target state="translated">경우에 따라 상점 상태를 기반으로 파생 된 상태를 계산해야 할 수도 있습니다 (예 : 항목 목록을 통한 필터링 및 계산).</target>
        </trans-unit>
        <trans-unit id="35ae76006ac7e393b8d6ac1ac6f19a1ddefd3da2" translate="yes" xml:space="preserve">
          <source>Sometimes we may need to create multiple instances of a module, for example:</source>
          <target state="translated">때로는 다음과 같이 모듈의 여러 인스턴스를 만들어야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="13e4487543b6d8b06a46672cfa73442042e5fe18" translate="yes" xml:space="preserve">
          <source>Specific when defined in a module</source>
          <target state="translated">모듈에 정의 된 경우 특정</target>
        </trans-unit>
        <trans-unit id="aabf420288f022d987bce3f9558b9c31ba749e69" translate="yes" xml:space="preserve">
          <source>Start &lt;code&gt;webpack-dev-server&lt;/code&gt; using the config.</source>
          <target state="translated">구성을 사용하여 &lt;code&gt;webpack-dev-server&lt;/code&gt; 를 시작하십시오 .</target>
        </trans-unit>
        <trans-unit id="a72502067518684f9deeec70cf119fd26326cd33" translate="yes" xml:space="preserve">
          <source>State</source>
          <target state="translated">State</target>
        </trans-unit>
        <trans-unit id="0d8a7046c8d39d9cbd86abcdfb704b161a601f9e" translate="yes" xml:space="preserve">
          <source>Store</source>
          <target state="translated">Store</target>
        </trans-unit>
        <trans-unit id="cc646793e5a188b7dfed3c624e7ab770f511a330" translate="yes" xml:space="preserve">
          <source>Store Constructor Options</source>
          <target state="translated">스토어 생성자 옵션</target>
        </trans-unit>
        <trans-unit id="4f3918202b47796e149a1504576be44f9c797b67" translate="yes" xml:space="preserve">
          <source>Store Instance Methods</source>
          <target state="translated">인스턴스 메소드 저장</target>
        </trans-unit>
        <trans-unit id="78960d483bd318512b15157254083d90ec1e70bb" translate="yes" xml:space="preserve">
          <source>Store Instance Properties</source>
          <target state="translated">인스턴스 속성 저장</target>
        </trans-unit>
        <trans-unit id="9e2f83ae922aab27ffe541f2875e43e6786c6d9f" translate="yes" xml:space="preserve">
          <source>StoreOptions.actions</source>
          <target state="translated">StoreOptions.actions</target>
        </trans-unit>
        <trans-unit id="7c2fb974fe6ac37076408fe6492caf0b5a840a6c" translate="yes" xml:space="preserve">
          <source>StoreOptions.devtools</source>
          <target state="translated">StoreOptions.devtools</target>
        </trans-unit>
        <trans-unit id="27bc45330a80e26b40635dc4a8b8fc17abc36877" translate="yes" xml:space="preserve">
          <source>StoreOptions.getters</source>
          <target state="translated">StoreOptions.getters</target>
        </trans-unit>
        <trans-unit id="13d89889e279cf3f4db38944cc0e1b9022ac7e5b" translate="yes" xml:space="preserve">
          <source>StoreOptions.modules</source>
          <target state="translated">StoreOptions.modules</target>
        </trans-unit>
        <trans-unit id="f35c2bfcf842e192031830ea98d80cec6e137cc2" translate="yes" xml:space="preserve">
          <source>StoreOptions.mutations</source>
          <target state="translated">StoreOptions.mutations</target>
        </trans-unit>
        <trans-unit id="9b08c590c8720def20c8cc4d49a23a43f356dabe" translate="yes" xml:space="preserve">
          <source>StoreOptions.plugins</source>
          <target state="translated">StoreOptions.plugins</target>
        </trans-unit>
        <trans-unit id="249ab110bf5289e564529ec006774bd6849ef3fa" translate="yes" xml:space="preserve">
          <source>StoreOptions.state</source>
          <target state="translated">StoreOptions.state</target>
        </trans-unit>
        <trans-unit id="057f939fdf0b4897b3dea09feff450cb50fdf3a3" translate="yes" xml:space="preserve">
          <source>StoreOptions.strict</source>
          <target state="translated">StoreOptions.strict</target>
        </trans-unit>
        <trans-unit id="7c183131363f4251f89993f5090afc10d8f0caad" translate="yes" xml:space="preserve">
          <source>Strict Mode</source>
          <target state="translated">엄격한 모드</target>
        </trans-unit>
        <trans-unit id="cf363d0f2bd89c65219cc88d7452d61570ae39f4" translate="yes" xml:space="preserve">
          <source>Subscribe to store actions. The &lt;code&gt;handler&lt;/code&gt; is called for every dispatched action and receives the action descriptor and current store state as arguments. The &lt;code&gt;subscribe&lt;/code&gt; method will return an &lt;code&gt;unsubscribe&lt;/code&gt; function, which should be called when the subscription is no longer needed. For example, when unregistering a Vuex module or before destroying a Vue component.</source>
          <target state="translated">스토어 활동을 구독하십시오. &lt;code&gt;handler&lt;/code&gt; 모든 파견 행동을 촉구하고 인자로 작용 기술자 및 현재 상태를 저장을 받는다. &lt;code&gt;subscribe&lt;/code&gt; 방법은 반환 &lt;code&gt;unsubscribe&lt;/code&gt; 구독이 더 이상 필요하지 않을 때 호출되어야 기능을. 예를 들어 Vuex 모듈 등록을 취소하거나 Vue 구성 요소를 제거하기 전에.</target>
        </trans-unit>
        <trans-unit id="cb4be8ac142fac6db9e88ed567eba8eb3225184f" translate="yes" xml:space="preserve">
          <source>Subscribe to store actions. The &lt;code&gt;handler&lt;/code&gt; is called for every dispatched action and receives the action descriptor and current store state as arguments:</source>
          <target state="translated">상점 조치를 구독하십시오. &lt;code&gt;handler&lt;/code&gt; 모든 조치를 파견 인수로 동작 설명 및 현재 상태를 저장를 수신 호출됩니다 :</target>
        </trans-unit>
        <trans-unit id="120d63b068274dc6942d114c566d657d42c319d8" translate="yes" xml:space="preserve">
          <source>Subscribe to store mutations. The &lt;code&gt;handler&lt;/code&gt; is called after every mutation and receives the mutation descriptor and post-mutation state as arguments.</source>
          <target state="translated">상점 돌연변이를 구독하십시오. &lt;code&gt;handler&lt;/code&gt; 모든 돌연변이 후 호출 및 인수로 돌연변이 설명 및 사후 돌연변이 상태를 받는다.</target>
        </trans-unit>
        <trans-unit id="cf1e862a182cd71e72218de4a57d6428ba414773" translate="yes" xml:space="preserve">
          <source>Subscribe to store mutations. The &lt;code&gt;handler&lt;/code&gt; is called after every mutation and receives the mutation descriptor and post-mutation state as arguments:</source>
          <target state="translated">돌연변이를 저장하기 위해 구독하십시오. &lt;code&gt;handler&lt;/code&gt; 모든 돌연변이 후 호출 및 인수로 돌연변이 설명 및 사후 돌연변이 상태를 받는다 :</target>
        </trans-unit>
        <trans-unit id="4a190c880575f8d6d89a23b4172d04f0a311e4e6" translate="yes" xml:space="preserve">
          <source>Taking State Snapshots</source>
          <target state="translated">상태 스냅 샷 작성</target>
        </trans-unit>
        <trans-unit id="0820b32b206b7352858e8903a838ed14319acdfd" translate="yes" xml:space="preserve">
          <source>Testing</source>
          <target state="translated">Testing</target>
        </trans-unit>
        <trans-unit id="c59410bf3ca2f20fd8b0393728deccf2dc47f93a" translate="yes" xml:space="preserve">
          <source>Testing Actions</source>
          <target state="translated">테스트 동작</target>
        </trans-unit>
        <trans-unit id="34e8d11332da2e378672d0a243a1d14c5129d499" translate="yes" xml:space="preserve">
          <source>Testing Getters</source>
          <target state="translated">게터 테스트</target>
        </trans-unit>
        <trans-unit id="97aad71ba2619e15a2576f93a06f963d9f14710f" translate="yes" xml:space="preserve">
          <source>Testing Mutations</source>
          <target state="translated">돌연변이 테스트</target>
        </trans-unit>
        <trans-unit id="9c06adb3a316efc06559622690345fb618cbaf08" translate="yes" xml:space="preserve">
          <source>The &quot;Vuex way&quot; to deal with it is binding the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;'s value and call a method on the &lt;code&gt;input&lt;/code&gt; or &lt;code&gt;change&lt;/code&gt; event:</source>
          <target state="translated">이를 처리하는 &quot;Vuex 방식&quot;은 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 의 값을 바인딩 하고 &lt;code&gt;input&lt;/code&gt; 또는 &lt;code&gt;change&lt;/code&gt; 이벤트 에 대한 메서드를 호출하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="75a5f0cdaf9e2b8de2bd8a7b0367c1b182465746" translate="yes" xml:space="preserve">
          <source>The &quot;Vuex way&quot; to deal with it is binding the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;'s value and call an action on the &lt;code&gt;input&lt;/code&gt; or &lt;code&gt;change&lt;/code&gt; event:</source>
          <target state="translated">이를 처리하는 &quot;Vuex 방식&quot;은 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 값을 바인딩 하고 &lt;code&gt;input&lt;/code&gt; 또는 &lt;code&gt;change&lt;/code&gt; 이벤트 에 대한 조치를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="7f04c49ca29bd705949d5268ee1592e8506b75b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;createLogger&lt;/code&gt; function takes a few options:</source>
          <target state="translated">&lt;code&gt;createLogger&lt;/code&gt; 의 기능은 몇 가지 옵션을합니다 :</target>
        </trans-unit>
        <trans-unit id="7f82a0b0f64bd49ff203795584f21da841843a62" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mapGetters&lt;/code&gt; Helper</source>
          <target state="translated">&lt;code&gt;mapGetters&lt;/code&gt; 도우미</target>
        </trans-unit>
        <trans-unit id="98e2bb1175bd22373105493a5a1bff66a0f61906" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mapGetters&lt;/code&gt; helper simply maps store getters to local computed properties:</source>
          <target state="translated">&lt;code&gt;mapGetters&lt;/code&gt; 단순히 지역의 계산 된 속성에 저장 게터 매핑 도우미 :</target>
        </trans-unit>
        <trans-unit id="1c64da128ff2a5fa70401dea47d5ef1a1c1ebe06" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mapState&lt;/code&gt; Helper</source>
          <target state="translated">&lt;code&gt;mapState&lt;/code&gt; 도우미</target>
        </trans-unit>
        <trans-unit id="4ed23a0b581ae30af2dc1a6fb0ab9dd6e2a32e58" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;subscribe&lt;/code&gt; method will return an &lt;code&gt;unsubscribe&lt;/code&gt; function, which should be called when the subscription is no longer needed. For example, you might subscribe to a Vuex Module and unsubscribe when you unregister the module. Or you might call &lt;code&gt;subscribe&lt;/code&gt; from inside a Vue Component and then destroy the component later. In these cases, you should remember to unsubscribe the subscription manually.</source>
          <target state="translated">&lt;code&gt;subscribe&lt;/code&gt; 방법은 반환 &lt;code&gt;unsubscribe&lt;/code&gt; 구독이 더 이상 필요하지 않을 때 호출되어야 기능을. 예를 들어 Vuex 모듈을 구독하고 모듈을 등록 취소 할 때 구독을 취소 할 수 있습니다. 또는 Vue 구성 요소 내에서 &lt;code&gt;subscribe&lt;/code&gt; 를 호출 한 다음 나중에 구성 요소를 삭제할 수 있습니다. 이 경우 구독을 수동으로 구독 취소해야합니다.</target>
        </trans-unit>
        <trans-unit id="d697d8557ee6fc852c1e6a6fc7993902dd98d06b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;subscribeAction&lt;/code&gt; method is most commonly used in plugins. &lt;a href=&quot;../guide/plugins&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;subscribeAction&lt;/code&gt; 의 방법은 가장 일반적으로 플러그인에 사용됩니다. &lt;a href=&quot;../guide/plugins&quot;&gt;세부&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0b142924d441d0b8c053ee3a0c60776db52d2668" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;subscribeAction&lt;/code&gt; method will return an &lt;code&gt;unsubscribe&lt;/code&gt; function, which should be called when the subscription is no longer needed. For example, you might subscribe to a Vuex Module and unsubscribe when you unregister the module. Or you might call &lt;code&gt;subscribeAction&lt;/code&gt; from inside a Vue Component and then destroy the component later. In these cases, you should remember to unsubscribe the subscription manually.</source>
          <target state="translated">&lt;code&gt;subscribeAction&lt;/code&gt; 의 방법은 반환 &lt;code&gt;unsubscribe&lt;/code&gt; 구독이 더 이상 필요하지 않을 때 호출되어야 기능을. 예를 들어 Vuex 모듈을 구독하고 모듈을 등록 취소 할 때 구독을 취소 할 수 있습니다. 또는 Vue 구성 요소 내부에서 &lt;code&gt;subscribeAction&lt;/code&gt; 을 호출 한 다음 나중에 구성 요소를 삭제할 수 있습니다. 이 경우 구독을 수동으로 구독 취소해야합니다.</target>
        </trans-unit>
        <trans-unit id="536ee7b8ae92c527384d1572270e55ace22c2cdd" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;actions&lt;/strong&gt;, the possible ways the state could change in reaction to user inputs from the &lt;strong&gt;view&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;조치는&lt;/strong&gt; , 가능한 방법은 상태로부터 사용자 입력에 대한 반응에서 변경 될 수 있습니다 &lt;strong&gt;보기&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="44d7e5a292944a9b8f0f212a5769200231c994ce" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;state&lt;/strong&gt;, the source of truth that drives our app;</source>
          <target state="translated">&lt;strong&gt;상태&lt;/strong&gt; , 우리의 응용 프로그램을 구동 진리의 소스;</target>
        </trans-unit>
        <trans-unit id="c7a29052af8d9c9885446ea356702c7246ba9728" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;view&lt;/strong&gt;, a declarative mapping of the &lt;strong&gt;state&lt;/strong&gt;;</source>
          <target state="translated">&lt;strong&gt;보기&lt;/strong&gt; ,의 선언적 매핑 &lt;strong&gt;상태&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="6efff60c6e384f46bfee8d934ae7afa0e3123d5a" translate="yes" xml:space="preserve">
          <source>The Simplest Store</source>
          <target state="translated">가장 간단한 상점</target>
        </trans-unit>
        <trans-unit id="65dc52e6fb3379afbda779041f713e48286fc0aa" translate="yes" xml:space="preserve">
          <source>The data you store in Vuex follows the same rules as the &lt;code&gt;data&lt;/code&gt; in a Vue instance, ie the state object must be plain. &lt;strong&gt;See also:&lt;/strong&gt;&lt;a href=&quot;https://v3.vuejs.org/api/options-data.html#data-2&quot;&gt;Vue#data&lt;/a&gt;.</source>
          <target state="translated">Vuex에 저장하는 &lt;code&gt;data&lt;/code&gt; 는 Vue 인스턴스 의 데이터 와 동일한 규칙을 따릅니다. 즉, 상태 개체는 일반이어야합니다. &lt;strong&gt;참조 : &lt;/strong&gt;&lt;a href=&quot;https://v3.vuejs.org/api/options-data.html#data-2&quot;&gt;Vue # data&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bad57ff3f59fd1cdbd6a9c2eb4f3c380f8789e16" translate="yes" xml:space="preserve">
          <source>The data you store in Vuex follows the same rules as the &lt;code&gt;data&lt;/code&gt; in a Vue instance, ie the state object must be plain. &lt;strong&gt;See also:&lt;/strong&gt;&lt;a href=&quot;https://vuejs.org/v2/api/#data&quot;&gt;Vue#data&lt;/a&gt;.</source>
          <target state="translated">Vuex에 저장하는 &lt;code&gt;data&lt;/code&gt; 는 Vue 인스턴스 의 데이터 와 동일한 규칙을 따릅니다. 즉 상태 객체는 평범해야합니다. &lt;a href=&quot;https://vuejs.org/v2/api/#data&quot;&gt;Vue # data &lt;/a&gt;&lt;strong&gt;도 참조하십시오&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="2b279e03c4074677e1ff56b9ff66e460fb14fa89" translate="yes" xml:space="preserve">
          <source>The first argument can optionally be a namespace string. &lt;a href=&quot;../guide/modules#binding-helpers-with-namespace&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">첫 번째 인수는 선택적으로 네임 스페이스 문자열 일 수 있습니다. &lt;a href=&quot;../guide/modules#binding-helpers-with-namespace&quot;&gt;세부&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3bcb1f41246213850c11b36c10d1fea79e5d77bc" translate="yes" xml:space="preserve">
          <source>The first thing to know is that &lt;code&gt;store.dispatch&lt;/code&gt; can handle Promise returned by the triggered action handler and it also returns Promise:</source>
          <target state="translated">가장 먼저 알아야 할 것은 &lt;code&gt;store.dispatch&lt;/code&gt; 가 트리거 된 조치 핸들러에 의해 리턴 된 Promise를 처리 할 수 ​​있으며 Promise도 리턴한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="dcebb29ecfe7deb0999fa8e584b599cd2758454e" translate="yes" xml:space="preserve">
          <source>The following bundles are generated to align with Vue 3 bundles:</source>
          <target state="translated">다음 번들은 Vue 3 번들에 맞게 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="33d9183239b6fa2ab9370efe48b42def65630f59" translate="yes" xml:space="preserve">
          <source>The getters will be exposed on the &lt;code&gt;store.getters&lt;/code&gt; object, and you access values as properties:</source>
          <target state="translated">게터는 &lt;code&gt;store.getters&lt;/code&gt; 객체 에 노출 되며 속성으로 값에 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="188d06901f5c54b49ca05463c758d45fe516d6f3" translate="yes" xml:space="preserve">
          <source>The logger file can also be included directly via a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag, and will expose the &lt;code&gt;createVuexLogger&lt;/code&gt; function globally.</source>
          <target state="translated">로거 파일은 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그 를 통해 직접 포함될 수도 있으며 &lt;code&gt;createVuexLogger&lt;/code&gt; 함수를 전체적으로 노출합니다 .</target>
        </trans-unit>
        <trans-unit id="7f53ab8729ac1f593a9e9d471a3a3f15e2c84ca7" translate="yes" xml:space="preserve">
          <source>The main parts we want to unit test in Vuex are mutations and actions.</source>
          <target state="translated">Vuex에서 단위 테스트를 수행하려는 주요 부분은 돌연변이와 행동입니다.</target>
        </trans-unit>
        <trans-unit id="5f7f524307005481f2e4aca2c93d29527f99f1e2" translate="yes" xml:space="preserve">
          <source>The module's state will be exposed as &lt;code&gt;store.state.myModule&lt;/code&gt; and &lt;code&gt;store.state.nested.myModule&lt;/code&gt;.</source>
          <target state="translated">모듈의 상태는 &lt;code&gt;store.state.myModule&lt;/code&gt; 및 &lt;code&gt;store.state.nested.myModule&lt;/code&gt; 로 노출됩니다 .</target>
        </trans-unit>
        <trans-unit id="fbed472d8720aba4f0e28e8c80ccedb98ce30b99" translate="yes" xml:space="preserve">
          <source>The only way to actually change state in a Vuex store is by committing a mutation. Vuex mutations are very similar to events: each mutation has a string &lt;strong&gt;type&lt;/strong&gt; and a &lt;strong&gt;handler&lt;/strong&gt;. The handler function is where we perform actual state modifications, and it will receive the state as the first argument:</source>
          <target state="translated">Vuex 스토어에서 실제로 상태를 변경하는 유일한 방법은 돌연변이를 저지르는 것입니다. Vuex 돌연변이는 이벤트와 매우 유사합니다. 각 돌연변이에는 문자열 &lt;strong&gt;유형&lt;/strong&gt; 과 &lt;strong&gt;핸들러가&lt;/strong&gt; 있습니다. 핸들러 함수는 실제 상태 수정을 수행하는 위치이며 첫 번째 인수로 상태를 수신합니다.</target>
        </trans-unit>
        <trans-unit id="a6a0b4e8e1721ea8c21549fafae87877e2734097" translate="yes" xml:space="preserve">
          <source>The only way to mutate the state is by committing &lt;strong&gt;mutations&lt;/strong&gt;, which are synchronous transactions.</source>
          <target state="translated">상태를 변경하는 유일한 방법 은 동기 트랜잭션 인 &lt;strong&gt;mutation&lt;/strong&gt; 을 커밋 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="dcbcf8b9a2e6b42000823c0ebf624eaedbb9d653" translate="yes" xml:space="preserve">
          <source>The plugin will be used by default. For production, you will need &lt;a href=&quot;https://webpack.js.org/plugins/define-plugin/&quot;&gt;DefinePlugin&lt;/a&gt; for webpack or &lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;envify&lt;/a&gt; for Browserify to convert the value of &lt;code&gt;process.&lt;wbr/&gt;env.NODE_ENV !== 'production'&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; for the final build.</source>
          <target state="translated">기본적으로 플러그인이 사용됩니다. 프로덕션 의 경우 &lt;code&gt;process.&lt;wbr/&gt;env.NODE_ENV !== 'production'&lt;/code&gt; 의 가치를 변환하려면 웹 팩용 DefinePlugin 또는 &lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;Browserify&lt;/a&gt; 용 envify 가 필요합니다. &lt;a href=&quot;https://webpack.js.org/plugins/define-plugin/&quot;&gt;ㅇㅇ&lt;/a&gt; ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ env.NODE_ENV! == '생산' 에 대한 &lt;code&gt;false&lt;/code&gt; 최종 빌드합니다.&lt;wbr/&gt;</target>
        </trans-unit>
        <trans-unit id="46e235aa33469d6967a6809446c33b1593819a40" translate="yes" xml:space="preserve">
          <source>The plugin will be used by default. For production, you will need &lt;a href=&quot;https://webpack.js.org/plugins/define-plugin/&quot;&gt;DefinePlugin&lt;/a&gt; for webpack or &lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;envify&lt;/a&gt; for Browserify to convert the value of &lt;code&gt;process.env.NODE_ENV !== 'production'&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; for the final build.</source>
          <target state="translated">플러그인이 기본적으로 사용됩니다. &lt;code&gt;process.env.NODE_ENV !== 'production'&lt;/code&gt; 경우 최종 빌드 에서 process.env.NODE_ENV! == 'production'값 을 &lt;code&gt;false&lt;/code&gt; 로 변환 하려면 &lt;a href=&quot;https://webpack.js.org/plugins/define-plugin/&quot;&gt;webpack&lt;/a&gt; 용 DefinePlugin 또는 &lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;Browserify&lt;/a&gt; 용 envify 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="f01042e3fecd699c90149ef1ee5ae1c35a436639" translate="yes" xml:space="preserve">
          <source>The root state object for the Vuex store. &lt;a href=&quot;../guide/state&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">Vuex 저장소의 루트 상태 객체입니다. &lt;a href=&quot;../guide/state&quot;&gt;세부&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0280fc5ea89ec8da31027d69c613be9a3c9680dc" translate="yes" xml:space="preserve">
          <source>The root state. Read only.</source>
          <target state="translated">루트 상태 읽기 전용.</target>
        </trans-unit>
        <trans-unit id="2c3de3def96fcc05fedc5eb419a984266aa2428b" translate="yes" xml:space="preserve">
          <source>The second object argument's members can be a function. &lt;code&gt;function(commit: function, ...args: any[])&lt;/code&gt;</source>
          <target state="translated">두 번째 객체 인수의 멤버는 함수일 수 있습니다. &lt;code&gt;function(commit: function, ...args: any[])&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="26cd7f1bcabc21254ac5b9199d279b0ef8555a89" translate="yes" xml:space="preserve">
          <source>The second object argument's members can be a function. &lt;code&gt;function(dispatch: function, ...args: any[])&lt;/code&gt;</source>
          <target state="translated">두 번째 객체 인수의 멤버는 함수일 수 있습니다. &lt;code&gt;function(dispatch: function, ...args: any[])&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7fdcb9da7768a075ddd1fe33f0287a0514029824" translate="yes" xml:space="preserve">
          <source>The second object argument's members can be a function. &lt;code&gt;function(state: any)&lt;/code&gt;</source>
          <target state="translated">두 번째 객체 인수의 멤버는 함수일 수 있습니다. &lt;code&gt;function(state: any)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="038cb5b264feb5642de1de9d5ce3def91138027b" translate="yes" xml:space="preserve">
          <source>The single state tree does not conflict with modularity - in later chapters we will discuss how to split your state and mutations into sub modules.</source>
          <target state="translated">단일 상태 트리는 모듈 성과 충돌하지 않습니다. 이후 장에서는 상태와 돌연변이를 하위 모듈로 나누는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="b7e90dfde3eb455667e93149720981dac77b8e85" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;window.Promise&lt;/code&gt; will be available automatically.</source>
          <target state="translated">그러면 &lt;code&gt;window.Promise&lt;/code&gt; 가 자동으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="3b8439ab3ba17300e601fb8e0cd832d27c3875b1" translate="yes" xml:space="preserve">
          <source>Then, pass the defined key as the second argument for the &lt;code&gt;app.use&lt;/code&gt; method.</source>
          <target state="translated">그런 다음 정의 된 키를 &lt;code&gt;app.use&lt;/code&gt; 메서드 의 두 번째 인수로 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="2304d640a16ae9bfebc931161006126d186e787e" translate="yes" xml:space="preserve">
          <source>Then:</source>
          <target state="translated">Then:</target>
        </trans-unit>
        <trans-unit id="66d594b0f1f59f13c4f1fb32be8056b70d5a1027" translate="yes" xml:space="preserve">
          <source>This is a simple representation of the concept of &quot;one-way data flow&quot;:</source>
          <target state="translated">다음은 &quot;단방향 데이터 흐름&quot;개념을 간단하게 표현한 것입니다.</target>
        </trans-unit>
        <trans-unit id="e5b6185e9c9c13a311c71ea345f0a1bcffe543f2" translate="yes" xml:space="preserve">
          <source>This is actually the exact same problem with &lt;code&gt;data&lt;/code&gt; inside Vue components. So the solution is also the same - use a function for declaring module state (supported in 2.3.0+):</source>
          <target state="translated">이것은 실제로 Vue 구성 요소 내부의 &lt;code&gt;data&lt;/code&gt; 와 동일한 문제입니다 . 따라서 솔루션도 동일합니다-모듈 상태를 선언하는 함수를 사용하십시오 (2.3.0 이상에서 지원됨).</target>
        </trans-unit>
        <trans-unit id="32e874b1aade463ecb43dfd8a24212e0197c777b" translate="yes" xml:space="preserve">
          <source>This is an simple representation of the concept of &quot;one-way data flow&quot;:</source>
          <target state="translated">이것은 &quot;단방향 데이터 흐름&quot;개념을 간단히 표현한 것입니다.</target>
        </trans-unit>
        <trans-unit id="4784799e1632043ab612568498af4698285efa24" translate="yes" xml:space="preserve">
          <source>This is the basic idea behind Vuex, inspired by &lt;a href=&quot;https://facebook.github.io/flux/docs/overview&quot;&gt;Flux&lt;/a&gt;, &lt;a href=&quot;http://redux.js.org/&quot;&gt;Redux&lt;/a&gt; and &lt;a href=&quot;https://guide.elm-lang.org/architecture/&quot;&gt;The Elm Architecture&lt;/a&gt;. Unlike the other patterns, Vuex is also a library implementation tailored specifically for Vue.js to take advantage of its granular reactivity system for efficient updates.</source>
          <target state="translated">이것은 &lt;a href=&quot;https://facebook.github.io/flux/docs/overview&quot;&gt;Flux&lt;/a&gt; , &lt;a href=&quot;http://redux.js.org/&quot;&gt;Redux&lt;/a&gt; 및 &lt;a href=&quot;https://guide.elm-lang.org/architecture/&quot;&gt;The Elm Architecture&lt;/a&gt; 에서 영감을 얻은 Vuex의 기본 아이디어 입니다. 다른 패턴과 달리 Vuex는 효율적인 업데이트를 위해 세분화 된 반응 시스템을 활용하기 위해 Vue.js를 위해 특별히 맞춤화 된 라이브러리 구현이기도합니다.</target>
        </trans-unit>
        <trans-unit id="e4ae803eb94d79146b96a33ead3a2a7574ab90f7" translate="yes" xml:space="preserve">
          <source>This is the basic idea behind Vuex, inspired by &lt;a href=&quot;https://facebook.github.io/flux/docs/overview.html&quot;&gt;Flux&lt;/a&gt;, &lt;a href=&quot;http://redux.js.org/&quot;&gt;Redux&lt;/a&gt; and &lt;a href=&quot;https://guide.elm-lang.org/architecture/&quot;&gt;The Elm Architecture&lt;/a&gt;. Unlike the other patterns, Vuex is also a library implementation tailored specifically for Vue.js to take advantage of its granular reactivity system for efficient updates.</source>
          <target state="translated">이것은 &lt;a href=&quot;https://facebook.github.io/flux/docs/overview.html&quot;&gt;Flux&lt;/a&gt; , &lt;a href=&quot;http://redux.js.org/&quot;&gt;Redux&lt;/a&gt; 및 &lt;a href=&quot;https://guide.elm-lang.org/architecture/&quot;&gt;The Elm Architecture&lt;/a&gt; 에서 영감을 얻은 Vuex의 기본 아이디어 입니다. 다른 패턴과 달리 Vuex는 Vue.js가 효율적인 업데이트를 위해 세분화 된 반응성 시스템을 활용할 수 있도록 특별히 설계된 라이브러리 구현입니다.</target>
        </trans-unit>
        <trans-unit id="01d82844153a1e06b9ed0ac7a7deee86d8194f29" translate="yes" xml:space="preserve">
          <source>This is the docs for Vuex 4, which works with Vue 3. If you're looking for docs for Vuex 3, which works with Vue 2, &lt;a href=&quot;https://vuex.vuejs.org/&quot;&gt;please check it out here&lt;/a&gt;.</source>
          <target state="translated">Vue 3에서 작동하는 Vuex 4 용 문서입니다. Vue 2에서 작동하는 Vuex 3 용 문서를 찾고 있다면 &lt;a href=&quot;https://vuex.vuejs.org/&quot;&gt;여기에서 확인하세요&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6765e94633afe8dfabe4c196fd106659f3711625" translate="yes" xml:space="preserve">
          <source>This may look silly at first sight: if we want to increment the count, why don't we just call &lt;code&gt;store.commit('increment')&lt;/code&gt; directly? Remember that &lt;strong&gt;mutations have to be synchronous&lt;/strong&gt;. Actions don't. We can perform &lt;strong&gt;asynchronous&lt;/strong&gt; operations inside an action:</source>
          <target state="translated">이것은 처음에는 어리석게 보일 수 있습니다. 카운트를 &lt;code&gt;store.commit('increment')&lt;/code&gt; 직접 호출하지 않는 이유는 무엇입니까? &lt;strong&gt;변이는 동 기적이어야 함을&lt;/strong&gt; 기억하십시오 . 행동은 그렇지 않습니다. 작업 내에서 &lt;strong&gt;비동기&lt;/strong&gt; 작업을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1ac43b405b6b649d36442b0894b012509c8256f1" translate="yes" xml:space="preserve">
          <source>This may look silly at first sight: if we want to increment the count, why don't we just call &lt;code&gt;store.commit('increment')&lt;/code&gt; directly? Remember that &lt;strong&gt;mutations have to be synchronous&lt;/strong&gt;? Actions don't. We can perform &lt;strong&gt;asynchronous&lt;/strong&gt; operations inside an action:</source>
          <target state="translated">첫눈에 어리석은 것처럼 보일 수 있습니다. 카운트를 늘리려면 &lt;code&gt;store.commit('increment')&lt;/code&gt; 를 직접 호출하지 않겠 습니까? &lt;strong&gt;돌연변이는 동 기적이어야&lt;/strong&gt; 한다는 것을 기억 하는가? 행동하지 않습니다. 액션 내부에서 &lt;strong&gt;비동기&lt;/strong&gt; 작업을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0e6ac10721f7dad6b0d54424ccab8e328eca8722" translate="yes" xml:space="preserve">
          <source>To access the store within the &lt;code&gt;setup&lt;/code&gt; hook, you can call the &lt;code&gt;useStore&lt;/code&gt; function. This is the equivalent of retrieving &lt;code&gt;this.$store&lt;/code&gt; within a component using the Option API.</source>
          <target state="translated">&lt;code&gt;setup&lt;/code&gt; 후크 내에서 저장소에 액세스하려면 &lt;code&gt;useStore&lt;/code&gt; 함수를 호출 할 수 있습니다 . 이것은 Option API를 사용하여 구성 요소 내에서 &lt;code&gt;this.$store&lt;/code&gt; 를 검색하는 것과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="2cdbc54a1defb978e6cf0175dfb530c6313ce51a" translate="yes" xml:space="preserve">
          <source>To align with the new Vue 3 initialization process, the installation process of Vuex has changed. To create a new store, users are now encouraged to use the newly introduced createStore function.</source>
          <target state="translated">새로운 Vue 3 초기화 프로세스에 맞추기 위해 Vuex의 설치 프로세스가 변경되었습니다. 새 상점을 만들려면 이제 새로 도입 된 createStore 기능을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="2fad06b8194c84f29399e28d3869f1cd5156e9bf" translate="yes" xml:space="preserve">
          <source>To dispatch actions or commit mutations in the global namespace, pass &lt;code&gt;{ root: true }&lt;/code&gt; as the 3rd argument to &lt;code&gt;dispatch&lt;/code&gt; and &lt;code&gt;commit&lt;/code&gt;.</source>
          <target state="translated">글로벌 네임 스페이스에서 조치 또는 커밋 돌연변이를 전달하려면 dispatch 및 &lt;code&gt;commit&lt;/code&gt; 의 세 번째 인수로 &lt;code&gt;{ root: true }&lt;/code&gt; 를 &lt;code&gt;dispatch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c0e5afb99acb54f27fa2c4dc5de58b64ac70359" translate="yes" xml:space="preserve">
          <source>To do so, declare custom typings for Vue's &lt;code&gt;ComponentCustomProperties&lt;/code&gt; by adding a declaration file in your project folder:</source>
          <target state="translated">이렇게하려면 프로젝트 폴더에 선언 파일을 추가하여 Vue의 &lt;code&gt;ComponentCustomProperties&lt;/code&gt; 에 대한 사용자 지정 입력을 선언합니다.</target>
        </trans-unit>
        <trans-unit id="c9a17f7fd54b6a036cf2a11b136e992ee23b897e" translate="yes" xml:space="preserve">
          <source>To enable strict mode, simply pass in &lt;code&gt;strict: true&lt;/code&gt; when creating a Vuex store:</source>
          <target state="translated">엄격 모드를 사용하려면 Vuex 상점을 작성할 때 &lt;code&gt;strict: true&lt;/code&gt; 를 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="b4555cdaed64feb01f23395f68a87fbe45b67dce" translate="yes" xml:space="preserve">
          <source>To handle asynchronous operations, let's introduce &lt;a href=&quot;actions&quot;&gt;Actions&lt;/a&gt;.</source>
          <target state="translated">비동기 작업을 처리하기 위해 &lt;a href=&quot;actions&quot;&gt;Actions를&lt;/a&gt; 소개하겠습니다 .</target>
        </trans-unit>
        <trans-unit id="4195b1d72692d3750d2a410e7d9981a761f2d655" translate="yes" xml:space="preserve">
          <source>To help with that, Vuex allows us to divide our store into &lt;strong&gt;modules&lt;/strong&gt;. Each module can contain its own state, mutations, actions, getters, and even nested modules - it's fractal all the way down:</source>
          <target state="translated">이를 돕기 위해 Vuex는 매장을 &lt;strong&gt;모듈&lt;/strong&gt; 로 나눌 수 있습니다 . 각 모듈은 자체 상태, 변이, 액션, 게터 및 심지어 중첩 된 모듈을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69ba8fbdd0f126138d738eba7ba3e25ab721058c" translate="yes" xml:space="preserve">
          <source>To install Vuex to a Vue instance, pass the &lt;code&gt;store&lt;/code&gt; instead of Vuex.</source>
          <target state="translated">Vuex를 Vue 인스턴스에 설치하려면 Vuex 대신 &lt;code&gt;store&lt;/code&gt; 를 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="47c12dedfc5d2ae19c1382030d2827746c9b159b" translate="yes" xml:space="preserve">
          <source>To stop subscribing, call the returned unsubscribe function.</source>
          <target state="translated">구독을 중지하려면 반환 된 구독 취소 기능을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="b38919feb133ed92197ba6b4d1ca2851ce856830" translate="yes" xml:space="preserve">
          <source>To stop watching, call the returned unwatch function.</source>
          <target state="translated">시청을 중지하려면 반환 된 unwatch 함수를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="d01a4f9ab1ff7fae7cb3dedf5ed58a422558aa71" translate="yes" xml:space="preserve">
          <source>Try this lesson on Scrimba</source>
          <target state="translated">Scrimba에서이 강의를 시도해보십시오</target>
        </trans-unit>
        <trans-unit id="812241cb367543e758bb2d6b8d6eb7df0bca334e" translate="yes" xml:space="preserve">
          <source>Turn the devtools on or off for a particular Vuex instance. For instance, passing &lt;code&gt;false&lt;/code&gt; tells the Vuex store to not subscribe to devtools plugin. Useful when you have multiple stores on a single page.</source>
          <target state="translated">특정 Vuex 인스턴스에 대해 devtools를 켜거나 끕니다. 예를 들어, &lt;code&gt;false&lt;/code&gt; 를 전달 하면 Vuex 스토어가 devtools 플러그인을 구독하지 않도록 지시합니다. 한 페이지에 여러 상점이있을 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="eb9df75c2e4aa99920a38d6895f257e82c103c0e" translate="yes" xml:space="preserve">
          <source>Turn the devtools on or off for a particular vuex instance. For instance passing false tells the Vuex store to not subscribe to devtools plugin. Useful for if you have multiple stores on a single page.</source>
          <target state="translated">특정 vuex 인스턴스에 대해 devtools를 켜거나 끕니다. 예를 들어 false를 전달하면 Vuex 저장소가 devtools 플러그인을 구독하지 않도록 지시합니다. 단일 페이지에 여러 상점이있는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="6d53cb5abedd0ebe3cd4c7395842755f71c30dbc" translate="yes" xml:space="preserve">
          <source>Two-way Computed Property</source>
          <target state="translated">양방향 계산 속성</target>
        </trans-unit>
        <trans-unit id="aec373f2c6104f4e0717f76308cbda4cbd9ffa55" translate="yes" xml:space="preserve">
          <source>TypeScript Support</source>
          <target state="translated">TypeScript 지원</target>
        </trans-unit>
        <trans-unit id="fdea23efbec9c8bf6ee85ec63b78ab2e12f528cd" translate="yes" xml:space="preserve">
          <source>TypeScript support</source>
          <target state="translated">TypeScript 지원</target>
        </trans-unit>
        <trans-unit id="50d095b72c23ae6ff8f64d6304776100771251da" translate="yes" xml:space="preserve">
          <source>TypeScript users can use an injection key to retrieve a typed store. In order for this to work, you must define the injection key and pass it along with the store when installing the store instance to the Vue app.</source>
          <target state="translated">TypeScript 사용자는 주입 키를 사용하여 입력 된 저장소를 검색 할 수 있습니다. 이것이 작동하려면 Vue 앱에 스토어 인스턴스를 설치할 때 주입 키를 정의하고 스토어와 함께 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="a035bd5d610b0e0f578980487f3e136c53e9a2df" translate="yes" xml:space="preserve">
          <source>Typing &lt;code&gt;$store&lt;/code&gt; Property in Vue Component</source>
          <target state="translated">Vue 구성 요소에 &lt;code&gt;$store&lt;/code&gt; 속성 입력</target>
        </trans-unit>
        <trans-unit id="1f301538ed68fe96d60ca381f974527cc0892825" translate="yes" xml:space="preserve">
          <source>Typing &lt;code&gt;useStore&lt;/code&gt; Composition Function</source>
          <target state="translated">&lt;code&gt;useStore&lt;/code&gt; 구성 기능 입력</target>
        </trans-unit>
        <trans-unit id="88625f6fb2e47a984fc469839b246cc1bbd39a3d" translate="yes" xml:space="preserve">
          <source>Under the hood, Vuex installs the store to the Vue app using Vue's &lt;a href=&quot;https://v3.vuejs.org/api/composition-api.html#provide-inject&quot;&gt;Provide/Inject&lt;/a&gt; feature which is why the injection key is an important factor.</source>
          <target state="translated">내부적으로 Vuex는 Vue의 &lt;a href=&quot;https://v3.vuejs.org/api/composition-api.html#provide-inject&quot;&gt;Provide / Inject&lt;/a&gt; 기능을 사용하여 Vue 앱에 스토어를 설치 하므로 주입 키가 중요한 요소입니다.</target>
        </trans-unit>
        <trans-unit id="58a34f2bdebff21a52c61f411732c8009ceffd74" translate="yes" xml:space="preserve">
          <source>Unregister a dynamic module. &lt;a href=&quot;../guide/modules#dynamic-module-registration&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">동적 모듈을 등록 취소하십시오. &lt;a href=&quot;../guide/modules#dynamic-module-registration&quot;&gt;세부&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0e189823fb0c39c232d21cb4f56d5d5263ffa4a9" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;Vue.set(obj, 'newProp', 123)&lt;/code&gt;, or</source>
          <target state="translated">사용 &lt;code&gt;Vue.set(obj, 'newProp', 123)&lt;/code&gt; , 또는</target>
        </trans-unit>
        <trans-unit id="b49c80c66c6311a904333a467355c7e6bf1e59e1" translate="yes" xml:space="preserve">
          <source>Using Constants for Mutation Types</source>
          <target state="translated">돌연변이 유형에 상수 사용</target>
        </trans-unit>
        <trans-unit id="2a3ef6422ba574dc83a7da5c0294678dde94d811" translate="yes" xml:space="preserve">
          <source>Using Vuex doesn't mean you should put &lt;strong&gt;all&lt;/strong&gt; the state in Vuex. Although putting more state into Vuex makes your state mutations more explicit and debuggable, sometimes it could also make the code more verbose and indirect. If a piece of state strictly belongs to a single component, it could be just fine leaving it as local state. You should weigh the trade-offs and make decisions that fit the development needs of your app.</source>
          <target state="translated">Vuex를 사용한다고해서 &lt;strong&gt;모든&lt;/strong&gt; 상태를 Vuex에 두어야한다는 의미는 아닙니다 . Vuex에 더 많은 상태를 넣으면 상태 돌연변이가 더 명확하고 디버깅 가능해 지지만 때로는 코드를 더 자세하고 간접적으로 만들 수도 있습니다. 상태 조각이 단일 구성 요소에 엄격하게 속하는 경우 로컬 상태로 남겨두면됩니다. 트레이드 오프의 무게를 측정하고 앱의 개발 요구에 맞는 결정을 내려야합니다.</target>
        </trans-unit>
        <trans-unit id="0c1ee6f0263ee019fc5e3fcd7fa266eb225b6cc7" translate="yes" xml:space="preserve">
          <source>Using store state in a component simply involves returning the state within a computed property, because the store state is reactive. Triggering changes simply means committing mutations in component methods.</source>
          <target state="translated">구성 요소에서 상점 상태를 사용하는 것은 상점 상태가 반응 적이므로 계산 된 특성 내에서 상태를 리턴하는 것만 관련됩니다. 변경 트리거는 단순히 구성 요소 방법에서 돌연변이를 저지르는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="de0b33121be26507e3433bd94203e17aa9b5f222" translate="yes" xml:space="preserve">
          <source>Vuex</source>
          <target state="translated">Vuex</target>
        </trans-unit>
        <trans-unit id="03cbaaf12cf9de839a6ef24add75f70804c3bd36" translate="yes" xml:space="preserve">
          <source>Vuex &quot;injects&quot; the store into all child components from the root component through Vue's plugin system, and will be available on them as &lt;code&gt;this.$store&lt;/code&gt;. Let's update our &lt;code&gt;Counter&lt;/code&gt; implementation:</source>
          <target state="translated">Vuex는 Vue의 플러그인 시스템을 통해 루트 구성 요소의 모든 하위 구성 요소에 저장소를 &quot;주입&quot;하며 &lt;code&gt;this.$store&lt;/code&gt; 로 사용할 수 있습니다 . &lt;code&gt;Counter&lt;/code&gt; 구현을 업데이트 해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="0b8cd4f61d900f72acb2af9c3655c9d0d3121feb" translate="yes" xml:space="preserve">
          <source>Vuex 4 introduces a new API to interact with the store in Composition API. You can use the &lt;code&gt;useStore&lt;/code&gt; composition function to retrieve the store within the component &lt;code&gt;setup&lt;/code&gt; hook.</source>
          <target state="translated">Vuex 4는 Composition API에서 상점과 상호 작용하는 새로운 API를 도입합니다. &lt;code&gt;useStore&lt;/code&gt; 컴포지션 함수를 사용하여 컴포넌트 &lt;code&gt;setup&lt;/code&gt; 후크 내에서 상점을 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="aa60c01f6f8d53bbb571c7cc4c0e43d605867024" translate="yes" xml:space="preserve">
          <source>Vuex 4 removes its global typings for &lt;code&gt;this.$store&lt;/code&gt; within a Vue component to solve &lt;a href=&quot;https://github.com/vuejs/vuex/issues/994&quot;&gt;issue #994&lt;/a&gt;. When used with TypeScript, you must declare your own module augmentation.</source>
          <target state="translated">Vuex 4는 Vue 구성 요소 내에서 &lt;code&gt;this.$store&lt;/code&gt; 대한 전역 타이핑을 제거하여 &lt;a href=&quot;https://github.com/vuejs/vuex/issues/994&quot;&gt;문제 # 994&lt;/a&gt; 를 해결 합니다. TypeScript와 함께 사용하는 경우 고유 한 모듈 기능 보강을 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="c5043b9867f4c1f3c2a241e7e15f0309bf2b67e5" translate="yes" xml:space="preserve">
          <source>Vuex allows us to define &quot;getters&quot; in the store. You can think of them as computed properties for stores.</source>
          <target state="translated">Vuex를 사용하면 상점에서 &quot;getters&quot;를 정의 할 수 있습니다. 상점에 대한 계산 된 속성으로 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0d6f301a857638a6008e626f1c08e4b841279dd" translate="yes" xml:space="preserve">
          <source>Vuex allows us to define &quot;getters&quot; in the store. You can think of them as computed properties for stores. Like computed properties, a getter's result is cached based on its dependencies, and will only re-evaluate when some of its dependencies have changed.</source>
          <target state="translated">Vuex를 통해 매장에서 &quot;게터&quot;를 정의 할 수 있습니다. 상점의 계산 된 특성으로 생각할 수 있습니다. 계산 된 속성과 마찬가지로 getter의 결과는 해당 종속성을 기반으로 캐시되며 일부 종속성이 변경된 경우에만 다시 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="0e2cd15820316b9d525f31489d6930bdf8394d91" translate="yes" xml:space="preserve">
          <source>Vuex comes with a logger plugin for common debugging usage:</source>
          <target state="translated">Vuex에는 일반적인 디버깅 사용법을위한 로거 플러그인이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="7a50b771f48dfa484820de4fbf6edb422dbc1306" translate="yes" xml:space="preserve">
          <source>Vuex doesn't provide typings for &lt;code&gt;this.$store&lt;/code&gt; property out of the box. When used with TypeScript, you must declare your own module augmentation.</source>
          <target state="translated">Vuex는 &lt;code&gt;this.$store&lt;/code&gt; 속성에 대한 입력을 즉시 제공하지 않습니다 . TypeScript와 함께 사용하는 경우 고유 한 모듈 기능 보강을 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="97c7149a09097949a0cfcc2fbe94537dc69fb1ce" translate="yes" xml:space="preserve">
          <source>Vuex doesn't really restrict how you structure your code. Rather, it enforces a set of high-level principles:</source>
          <target state="translated">Vuex는 코드 구성 방식을 실제로 제한하지 않습니다. 오히려 다음과 같은 일련의 고급 원칙을 시행합니다.</target>
        </trans-unit>
        <trans-unit id="d17df34d062fc479eb107a94c88abf9ec059beae" translate="yes" xml:space="preserve">
          <source>Vuex helps us deal with shared state management with the cost of more concepts and boilerplate. It's a trade-off between short term and long term productivity.</source>
          <target state="translated">Vuex는 더 많은 개념과 상용구 비용으로 공유 상태 관리를 처리하도록 도와줍니다. 단기 생산성과 장기 생산성 간의 균형을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="685c1dd978a181fa797afacac4d6f9601b7d5fda" translate="yes" xml:space="preserve">
          <source>Vuex is a &lt;strong&gt;state management pattern + library&lt;/strong&gt; for Vue.js applications. It serves as a centralized store for all the components in an application, with rules ensuring that the state can only be mutated in a predictable fashion.</source>
          <target state="translated">Vuex는 Vue.js 애플리케이션을위한 &lt;strong&gt;상태 관리 패턴 + 라이브러리&lt;/strong&gt; 입니다. 상태가 예측 가능한 방식으로 만 변경 될 수 있도록하는 규칙과 함께 애플리케이션의 모든 구성 요소에 대한 중앙 집중식 저장소 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="4865c12b8c32edd994472010e09de64c7196db52" translate="yes" xml:space="preserve">
          <source>Vuex is a &lt;strong&gt;state management pattern + library&lt;/strong&gt; for Vue.js applications. It serves as a centralized store for all the components in an application, with rules ensuring that the state can only be mutated in a predictable fashion. It also integrates with Vue's official &lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;devtools extension&lt;/a&gt; to provide advanced features such as zero-config time-travel debugging and state snapshot export / import.</source>
          <target state="translated">Vuex는 Vue.js 애플리케이션을위한 &lt;strong&gt;상태 관리 패턴 + 라이브러리&lt;/strong&gt; 입니다. 상태를 예측 가능한 방식으로 만 변경할 수 있도록하는 규칙을 사용하여 응용 프로그램의 모든 구성 요소에 대한 중앙 저장소 역할을합니다. 또한 Vue의 공식 &lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;devtools 확장&lt;/a&gt; 기능과 통합되어 제로 구성 시간 이동 디버깅 및 상태 스냅 샷 내보내기 / 가져 오기와 같은 고급 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0ab5b1ceae85cef3c7070700973eed24ddceb3f1" translate="yes" xml:space="preserve">
          <source>Vuex provides a mechanism to &quot;inject&quot; the store into all child components from the root component with the &lt;code&gt;store&lt;/code&gt; option (enabled by &lt;code&gt;Vue.use(Vuex)&lt;/code&gt;):</source>
          <target state="translated">Vuex는 &lt;code&gt;store&lt;/code&gt; 옵션을 사용 하여 루트 구성 요소에서 모든 하위 구성 요소에 상점을 &quot;주입&quot;하는 메커니즘을 제공합니다 ( &lt;code&gt;Vue.use(Vuex)&lt;/code&gt; 의해 활성화 됨 ).</target>
        </trans-unit>
        <trans-unit id="13c8b9558d25a74364d073902412ab0e29b9c7d8" translate="yes" xml:space="preserve">
          <source>Vuex provides its typings so you can use TypeScript to write a store definition. You don't need any special TypeScript configuration for Vuex. Please follow &lt;a href=&quot;https://v3.vuejs.org/guide/typescript-support.html&quot;&gt;Vue's basic TypeScript setup&lt;/a&gt; to configure your project.</source>
          <target state="translated">Vuex는 TypeScript를 사용하여 저장소 정의를 작성할 수 있도록 타이핑을 제공합니다. Vuex에는 특별한 TypeScript 구성이 필요하지 않습니다. 프로젝트를 구성 하려면 &lt;a href=&quot;https://v3.vuejs.org/guide/typescript-support.html&quot;&gt;Vue의 기본 TypeScript 설정&lt;/a&gt; 을 따르십시오 .</target>
        </trans-unit>
        <trans-unit id="29e6083d0ea2da692697abc408390a78b3fbb6a1" translate="yes" xml:space="preserve">
          <source>Vuex requires &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises&quot;&gt;Promise&lt;/a&gt;. If your supporting browsers do not implement Promise (e.g. IE), you can use a polyfill library, such as &lt;a href=&quot;https://github.com/stefanpenner/es6-promise&quot;&gt;es6-promise&lt;/a&gt;.</source>
          <target state="translated">Vuex에는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises&quot;&gt;약속이&lt;/a&gt; 필요합니다 . 지원하는 브라우저가 Promise (예 : IE)를 구현하지 않으면 &lt;a href=&quot;https://github.com/stefanpenner/es6-promise&quot;&gt;es6-promise&lt;/a&gt; 와 같은 폴리 필 라이브러리를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a7c44a44a893f704da779f2a6753cb99fdabc86c" translate="yes" xml:space="preserve">
          <source>Vuex stores accept the &lt;code&gt;plugins&lt;/code&gt; option that exposes hooks for each mutation. A Vuex plugin is simply a function that receives the store as the only argument:</source>
          <target state="translated">Vuex 스토어 는 각 돌연변이에 대한 후크를 노출시키는 &lt;code&gt;plugins&lt;/code&gt; 옵션을 허용합니다 . Vuex 플러그인은 스토어를 유일한 인수로받는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="f9de6b1a8f9893aec2c24f2eb638d08f8c27963a" translate="yes" xml:space="preserve">
          <source>Vuex stores are reactive. When Vue components retrieve state from it, they will reactively and efficiently update if the store's state changes.</source>
          <target state="translated">Vuex 매장은 반응이 있습니다. Vue 구성 요소는 상태를 검색 할 때 상점의 상태가 변경되면 반응 형으로 효율적으로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="d1005b8dfed9f5da523d44fa0408fb96e863b48e" translate="yes" xml:space="preserve">
          <source>Vuex supports hot-reloading mutations, modules, actions and getters during development, using webpack's &lt;a href=&quot;https://webpack.js.org/guides/hot-module-replacement/&quot;&gt;Hot Module Replacement API&lt;/a&gt;. You can also use it in Browserify with the &lt;a href=&quot;https://github.com/AgentME/browserify-hmr/&quot;&gt;browserify-hmr&lt;/a&gt; plugin.</source>
          <target state="translated">Vuex는 웹팩의 &lt;a href=&quot;https://webpack.js.org/guides/hot-module-replacement/&quot;&gt;Hot Module Replacement API를&lt;/a&gt; 사용하여 개발 중에 핫 리로드 돌연변이, 모듈, 동작 및 게터를 지원 합니다 . browserify &lt;a href=&quot;https://github.com/AgentME/browserify-hmr/&quot;&gt;-hmr&lt;/a&gt; 플러그인을 사용하여 Browserify에서 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1c91ec10df2bcecd2b18c0eb4c34783559fcaf6b" translate="yes" xml:space="preserve">
          <source>Vuex uses a &lt;strong&gt;single state tree&lt;/strong&gt; - that is, this single object contains all your application level state and serves as the &quot;single source of truth&quot;. This also means usually you will have only one store for each application. A single state tree makes it straightforward to locate a specific piece of state, and allows us to easily take snapshots of the current app state for debugging purposes.</source>
          <target state="translated">Vuex는 &lt;strong&gt;단일 상태 트리를&lt;/strong&gt; 사용합니다. 즉,이 단일 객체는 모든 애플리케이션 레벨 상태를 포함하고 &quot;단일 진실 소스&quot;역할을합니다. 이것은 또한 일반적으로 각 애플리케이션마다 하나의 상점 만 갖게됨을 의미합니다. 단일 상태 트리를 사용하면 특정 상태를 쉽게 찾을 수 있으며 디버깅을 위해 현재 앱 상태의 스냅 샷을 쉽게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38d7ee9ea99de16acff8c72ca2947db3c8964cfb" translate="yes" xml:space="preserve">
          <source>Vuex uses a &lt;strong&gt;single state tree&lt;/strong&gt; - that is, this single object contains all your application level state and serves as the &quot;single source of truth.&quot; This also means usually you will have only one store for each application. A single state tree makes it straightforward to locate a specific piece of state, and allows us to easily take snapshots of the current app state for debugging purposes.</source>
          <target state="translated">Vuex는 &lt;strong&gt;단일 상태 트리를&lt;/strong&gt; 사용합니다. 즉,이 단일 개체는 모든 애플리케이션 수준 상태를 포함하고 &quot;단일 진실 소스&quot;역할을합니다. 이것은 또한 일반적으로 각 응용 프로그램에 대해 하나의 저장소 만 있음을 의미합니다. 단일 상태 트리를 사용하면 특정 상태를 쉽게 찾을 수 있으며 디버깅 목적으로 현재 앱 상태의 스냅 샷을 쉽게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="daddb132dbb693223d1a8285c450a768b5e90526" translate="yes" xml:space="preserve">
          <source>Vuex.Store</source>
          <target state="translated">Vuex.Store</target>
        </trans-unit>
        <trans-unit id="e27d6d35e937e025eb96c09b1248e5c2676afd99" translate="yes" xml:space="preserve">
          <source>Vuex.Store Constructor Options</source>
          <target state="translated">Vuex.Store 생성자 옵션</target>
        </trans-unit>
        <trans-unit id="a12ddea81e37a47b9cf92721a2c3b3dce724518b" translate="yes" xml:space="preserve">
          <source>Vuex.Store Instance Methods</source>
          <target state="translated">Vuex.Store 인스턴스 메소드</target>
        </trans-unit>
        <trans-unit id="bf2e5bd997aabdf6407575808a7810ae806bc168" translate="yes" xml:space="preserve">
          <source>Vuex.Store Instance Properties</source>
          <target state="translated">Vuex.Store 인스턴스 속성</target>
        </trans-unit>
        <trans-unit id="f9f831a5e0694e0c14522dd98fa88137c445d453" translate="yes" xml:space="preserve">
          <source>Vuex.Store.commit()</source>
          <target state="translated">Vuex.Store.commit()</target>
        </trans-unit>
        <trans-unit id="6525945e6ceed925f1b32505317c836dca657a7b" translate="yes" xml:space="preserve">
          <source>Vuex.Store.dispatch()</source>
          <target state="translated">Vuex.Store.dispatch()</target>
        </trans-unit>
        <trans-unit id="875eca0d2c435721934d6e21026feaf2c458121e" translate="yes" xml:space="preserve">
          <source>Vuex.Store.getters</source>
          <target state="translated">Vuex.Store.getters</target>
        </trans-unit>
        <trans-unit id="36f6be1d986b4f405099f5f30b602d52e9e30867" translate="yes" xml:space="preserve">
          <source>Vuex.Store.hotUpdate()</source>
          <target state="translated">Vuex.Store.hotUpdate()</target>
        </trans-unit>
        <trans-unit id="da4335e82262f6f8d6790534c7ad0926cc4745e2" translate="yes" xml:space="preserve">
          <source>Vuex.Store.registerModule()</source>
          <target state="translated">Vuex.Store.registerModule()</target>
        </trans-unit>
        <trans-unit id="94ac4b985f66595cf0a6092e1a82c5ad38bbb16b" translate="yes" xml:space="preserve">
          <source>Vuex.Store.replaceState()</source>
          <target state="translated">Vuex.Store.replaceState()</target>
        </trans-unit>
        <trans-unit id="4f304b4fdb3bf5548021e12438f19b8a3c837429" translate="yes" xml:space="preserve">
          <source>Vuex.Store.state</source>
          <target state="translated">Vuex.Store.state</target>
        </trans-unit>
        <trans-unit id="646d93a6768d3e6602cdefd17248482210916c01" translate="yes" xml:space="preserve">
          <source>Vuex.Store.subscribe()</source>
          <target state="translated">Vuex.Store.subscribe()</target>
        </trans-unit>
        <trans-unit id="f3e660b4b4bcbf28c208b2cb1849c08db1e4a864" translate="yes" xml:space="preserve">
          <source>Vuex.Store.subscribeAction()</source>
          <target state="translated">Vuex.Store.subscribeAction()</target>
        </trans-unit>
        <trans-unit id="ae9d201aeec49d5494691627724de63760974852" translate="yes" xml:space="preserve">
          <source>Vuex.Store.unregisterModule()</source>
          <target state="translated">Vuex.Store.unregisterModule()</target>
        </trans-unit>
        <trans-unit id="a78a21d356c3413617b93e60de03e3c4c85613bf" translate="yes" xml:space="preserve">
          <source>Vuex.Store.watch()</source>
          <target state="translated">Vuex.Store.watch()</target>
        </trans-unit>
        <trans-unit id="fd3edc641024a335a508fdacefb5f51ded5905cc" translate="yes" xml:space="preserve">
          <source>WARNING</source>
          <target state="translated">WARNING</target>
        </trans-unit>
        <trans-unit id="972f097fe8de7d9024e0cac7324df8bc2bd5d8a7" translate="yes" xml:space="preserve">
          <source>We can also pass a string array to &lt;code&gt;mapState&lt;/code&gt; when the name of a mapped computed property is the same as a state sub tree name.</source>
          <target state="translated">매핑 된 계산 속성의 이름이 상태 하위 트리 이름과 같은 경우 문자열 배열을 &lt;code&gt;mapState&lt;/code&gt; 에 전달할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="62a0d6990ce81e2c8fb572ac1e1a0f61bc100c86" translate="yes" xml:space="preserve">
          <source>We can now easily make use of it inside any component:</source>
          <target state="translated">이제 모든 구성 요소 내에서 쉽게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8745c67924f31017daab7ed40bb8f21170388cd9" translate="yes" xml:space="preserve">
          <source>We will be using ES2015 syntax for code examples for the rest of the docs. If you haven't picked it up, &lt;a href=&quot;https://babeljs.io/docs/learn-es2015/&quot;&gt;you should&lt;/a&gt;!</source>
          <target state="translated">나머지 문서의 코드 예제에는 ES2015 구문을 사용할 것입니다. 당신이 그것을 집어 들지 않았다면, &lt;a href=&quot;https://babeljs.io/docs/learn-es2015/&quot;&gt;당신은해야합니다&lt;/a&gt; !</target>
        </trans-unit>
        <trans-unit id="4e679c86924ed36ac40c73653131acb30c335823" translate="yes" xml:space="preserve">
          <source>What is Vuex?</source>
          <target state="translated">Vuex 란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="4f7cb23fbc792a907900b6c227a08a9ce44bbb08" translate="yes" xml:space="preserve">
          <source>What is a &quot;State Management Pattern&quot;?</source>
          <target state="translated">&quot;상태 관리 패턴&quot;이란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="bfb57f97eebc790fb0f996df58cf05c904d765fe" translate="yes" xml:space="preserve">
          <source>When Should I Use It?</source>
          <target state="translated">언제 사용해야합니까?</target>
        </trans-unit>
        <trans-unit id="7049f8d400f975057b510f35754e4b4a55b8a447" translate="yes" xml:space="preserve">
          <source>When a component needs to make use of multiple store state properties or getters, declaring all these computed properties can get repetitive and verbose. To deal with this we can make use of the &lt;code&gt;mapState&lt;/code&gt; helper which generates computed getter functions for us, saving us some keystrokes:</source>
          <target state="translated">구성 요소가 여러 상점 상태 특성 또는 게터를 사용해야하는 경우 이러한 모든 계산 된 특성을 선언하면 반복적이고 자세한 정보를 얻을 수 있습니다. 이를 처리하기 위해 계산 된 getter 함수를 생성 하는 &lt;code&gt;mapState&lt;/code&gt; 헬퍼를 사용하여 키 입력을 줄일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b0e91b1a6d070c61fac000b9d3b95342ccf2db46" translate="yes" xml:space="preserve">
          <source>When accessing mutations and actions, you can simply provide the &lt;code&gt;commit&lt;/code&gt; and &lt;code&gt;dispatch&lt;/code&gt; function inside the &lt;code&gt;setup&lt;/code&gt; hook.</source>
          <target state="translated">뮤 테이션 및 액션에 액세스 할 때 &lt;code&gt;setup&lt;/code&gt; 후크 내에 &lt;code&gt;commit&lt;/code&gt; 및 &lt;code&gt;dispatch&lt;/code&gt; 기능을 제공하기 만하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="c17e29a6e47a7d53eb7540fe5f43fd3c7ec25ef4" translate="yes" xml:space="preserve">
          <source>When adding new properties to an Object, you should either:</source>
          <target state="translated">객체에 새 속성을 추가 할 때 다음 중 하나를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="efff342070587a8120ff0a0f2a1a6c593581e9da" translate="yes" xml:space="preserve">
          <source>When binding a namespaced module to components with the &lt;code&gt;mapState&lt;/code&gt;, &lt;code&gt;mapGetters&lt;/code&gt;, &lt;code&gt;mapActions&lt;/code&gt; and &lt;code&gt;mapMutations&lt;/code&gt; helpers, it can get a bit verbose:</source>
          <target state="translated">&lt;code&gt;mapState&lt;/code&gt; , &lt;code&gt;mapGetters&lt;/code&gt; , &lt;code&gt;mapActions&lt;/code&gt; 및 &lt;code&gt;mapMutations&lt;/code&gt; 헬퍼 를 사용하여 네임 스페이스가있는 모듈을 컴포넌트에 바인딩하면 약간의 자세한 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99195dc5710842be6bed30d96a1def16fb32d71c" translate="yes" xml:space="preserve">
          <source>When used with a module system, you must explicitly install Vuex via &lt;code&gt;Vue.use()&lt;/code&gt;:</source>
          <target state="translated">모듈 시스템과 함께 사용하는 경우 &lt;code&gt;Vue.use()&lt;/code&gt; 를 통해 Vuex를 명시 적으로 설치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="77c1ff3694c93e3a5898ebf5b137f7620c5e12dd" translate="yes" xml:space="preserve">
          <source>When using Vuex in strict mode, it could be a bit tricky to use &lt;code&gt;v-model&lt;/code&gt; on a piece of state that belongs to Vuex:</source>
          <target state="translated">엄격 모드에서 Vuex를 사용할 때 Vuex에 속하는 상태에서 &lt;code&gt;v-model&lt;/code&gt; 을 사용하는 것은 약간 까다로울 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fd5fb9660a82033a1f5e0bdd5e988d5fee11ea79" translate="yes" xml:space="preserve">
          <source>When using object-style commit, the entire object will be passed as the payload to mutation handlers, so the handler remains the same:</source>
          <target state="translated">객체 스타일 커밋을 사용하면 전체 객체가 페이로드로 변이 핸들러로 전달되므로 핸들러는 동일하게 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="4c9c007e95ce7e90fdef65d514914f8a48ea50fc" translate="yes" xml:space="preserve">
          <source>When you set &lt;code&gt;preserveState: true&lt;/code&gt;, the module is registered, actions, mutations and getters are added to the store, but the state is not. It's assumed that your store state already contains state for that module and you don't want to overwrite it.</source>
          <target state="translated">&lt;code&gt;preserveState: true&lt;/code&gt; 를 설정 하면 모듈이 등록되고 작업, 변형 및 getter가 저장소에 추가되지만 상태는 그렇지 않습니다. 상점 상태에 해당 모듈에 대한 상태가 이미 포함되어 있고 덮어 쓰지 않는다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="64b97d35575f008d89a5abcf758506366a1df6c9" translate="yes" xml:space="preserve">
          <source>When you set &lt;code&gt;preserveState: true&lt;/code&gt;, the module is registered, actions, mutations and getters are added to the store, but the state not. It's assumed that your store state already contains state for that module and you don't want to overwrite it.</source>
          <target state="translated">&lt;code&gt;preserveState: true&lt;/code&gt; 를 설정 하면 모듈이 등록되고 조치, 돌연변이 및 게터가 상점에 추가되지만 상태는 추가되지 않습니다. 상점 상태에 이미 해당 모듈의 상태가 포함되어 있으며이를 덮어 쓰고 싶지 않다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="b67645573519bd6745c7692e115ca001bffedc35" translate="yes" xml:space="preserve">
          <source>When you're writing your Vue component in Composition API, you will most likely want &lt;code&gt;useStore&lt;/code&gt; to return the typed store. For &lt;code&gt;useStore&lt;/code&gt; to correctly return the typed store, you must:</source>
          <target state="translated">Composition API에서 Vue 구성 요소를 작성할 때 &lt;code&gt;useStore&lt;/code&gt; 가 입력 된 저장소를 반환하기를 원할 것 입니다. 들어 &lt;code&gt;useStore&lt;/code&gt; 가 올바르게 입력 상점을 반환하려면 다음을 수행해야합니다</target>
        </trans-unit>
        <trans-unit id="e0672c57fbbf8e8ecf0e7b63699f5a7c92edcd4d" translate="yes" xml:space="preserve">
          <source>Whenever &lt;code&gt;store.state.count&lt;/code&gt; changes, it will cause the computed property to re-evaluate, and trigger associated DOM updates.</source>
          <target state="translated">&lt;code&gt;store.state.count&lt;/code&gt; 가 변경 될 때마다 계산 된 특성이 다시 평가되고 연관된 DOM 업데이트가 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="a085ea0f1aa78bea832392da9c502369be0887a2" translate="yes" xml:space="preserve">
          <source>Whether to use constants is largely a preference - it can be helpful in large projects with many developers, but it's totally optional if you don't like them.</source>
          <target state="translated">상수를 사용할지 여부는 기본적으로 선호됩니다. 많은 개발자가있는 대규모 프로젝트에서 유용 할 수 있지만 마음에 들지 않으면 완전히 선택적입니다.</target>
        </trans-unit>
        <trans-unit id="4c08b16ee1dc63cbfb31d2273bccaca063856191" translate="yes" xml:space="preserve">
          <source>Whilst this is not technically a breaking change, you may still use the &lt;code&gt;new Store(...)&lt;/code&gt; syntax, we recommend this approach to align with Vue 3 and Vue Router Next.</source>
          <target state="translated">이것은 기술적으로 주요 변경 사항은 아니지만 &lt;code&gt;new Store(...)&lt;/code&gt; 구문을 사용할 수 있지만 이 접근 방식을 Vue 3 및 Vue Router Next에 맞추는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4de67a4d313139fb2f1d0ad9d2c13d0921ddb131" translate="yes" xml:space="preserve">
          <source>Yarn</source>
          <target state="translated">Yarn</target>
        </trans-unit>
        <trans-unit id="63134a6d55a8d86ebefa1d7e28dd4e4938a617f5" translate="yes" xml:space="preserve">
          <source>You can also pass arguments to getters by returning a function. This is particularly useful when you want to query an array in the store:</source>
          <target state="translated">함수를 반환하여 getter에 인수를 전달할 수도 있습니다. 이것은 상점에서 배열을 조회 할 때 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="23de97b968754adb5c8071394c94800b27c8ebc7" translate="yes" xml:space="preserve">
          <source>You can also remove a dynamically registered module with &lt;code&gt;store.unregisterModule(moduleName)&lt;/code&gt;. Note you cannot remove static modules (declared at store creation) with this method.</source>
          <target state="translated">&lt;code&gt;store.unregisterModule(moduleName)&lt;/code&gt; 사용하여 동적으로 등록 된 모듈을 제거 할 수도 있습니다 . 이 방법으로는 정적 모듈 (상점 작성시 선언)을 제거 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d29c54157aed563d47280cf164e51dba16933038" translate="yes" xml:space="preserve">
          <source>You can commit mutations in components with &lt;code&gt;this.$store.commit('xxx')&lt;/code&gt;, or use the &lt;code&gt;mapMutations&lt;/code&gt; helper which maps component methods to &lt;code&gt;store.commit&lt;/code&gt; calls (requires root &lt;code&gt;store&lt;/code&gt; injection):</source>
          <target state="translated">&lt;code&gt;this.$store.commit('xxx')&lt;/code&gt; 를 사용하여 컴포넌트에서 돌연변이를 커밋 하거나 &lt;code&gt;mapMutations&lt;/code&gt; 헬퍼를 사용하여 컴포넌트 메소드를 &lt;code&gt;store.commit&lt;/code&gt; 호출 에 맵핑 합니다 (루트 &lt;code&gt;store&lt;/code&gt; 삽입 필요 ).</target>
        </trans-unit>
        <trans-unit id="1215721038a305c2ecee17f52181bc37f1909ea8" translate="yes" xml:space="preserve">
          <source>You can dispatch actions in components with &lt;code&gt;this.$store.dispatch('xxx')&lt;/code&gt;, or use the &lt;code&gt;mapActions&lt;/code&gt; helper which maps component methods to &lt;code&gt;store.dispatch&lt;/code&gt; calls (requires root &lt;code&gt;store&lt;/code&gt; injection):</source>
          <target state="translated">&lt;code&gt;this.$store.dispatch('xxx')&lt;/code&gt; 를 사용하여 컴포넌트에서 조치를 디스패치 하거나 컴포넌트 메소드를 &lt;code&gt;store.dispatch&lt;/code&gt; 호출에 맵핑 하는 &lt;code&gt;mapActions&lt;/code&gt; 헬퍼를 사용할 수 있습니다 (루트 &lt;code&gt;store&lt;/code&gt; 삽입 필요 ).</target>
        </trans-unit>
        <trans-unit id="8881848045fd86241cc9c9d7d92edbe765adb62d" translate="yes" xml:space="preserve">
          <source>You can include it via CDN:</source>
          <target state="translated">CDN을 통해 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ad1656a1ce03c34ec4d07184a92309aa7cbeafd" translate="yes" xml:space="preserve">
          <source>You can learn more in the &lt;a href=&quot;composition-api&quot;&gt;Composition API&lt;/a&gt; section.</source>
          <target state="translated">&lt;a href=&quot;composition-api&quot;&gt;Composition API&lt;/a&gt; 섹션 에서 자세히 알아볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8fc0fa46dba60197b55bd958d17dd6ccb01559a1" translate="yes" xml:space="preserve">
          <source>You can learn more in the &lt;a href=&quot;typescript-support&quot;&gt;TypeScript Support&lt;/a&gt; section.</source>
          <target state="translated">&lt;a href=&quot;typescript-support&quot;&gt;TypeScript 지원&lt;/a&gt; 섹션 에서 자세히 알아볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="25c0fe7b987a059291687c75ef24f147484cb473" translate="yes" xml:space="preserve">
          <source>You can pass an additional argument to &lt;code&gt;store.commit&lt;/code&gt;, which is called the &lt;strong&gt;payload&lt;/strong&gt; for the mutation:</source>
          <target state="translated">&lt;code&gt;store.commit&lt;/code&gt; 에 추가 인수를 전달할 수 있는데 ,이를 돌연변이 의 &lt;strong&gt;페이로드&lt;/strong&gt; 라고합니다 .</target>
        </trans-unit>
        <trans-unit id="3669fc0f4547fc417e6184797578f0ae3a315436" translate="yes" xml:space="preserve">
          <source>You can register a module &lt;strong&gt;after&lt;/strong&gt; the store has been created with the &lt;code&gt;store.registerModule&lt;/code&gt; method:</source>
          <target state="translated">&lt;code&gt;store.registerModule&lt;/code&gt; 메소드를 사용하여 상점을 작성한 &lt;strong&gt;후&lt;/strong&gt; 모듈 &lt;strong&gt;을&lt;/strong&gt; 등록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="535a2512801117d140454c6e5cb378ba940f4b23" translate="yes" xml:space="preserve">
          <source>You cannot directly call a mutation handler. Think of it more like event registration: &quot;When a mutation with type &lt;code&gt;increment&lt;/code&gt; is triggered, call this handler.&quot; To invoke a mutation handler, you need to call &lt;code&gt;store.commit&lt;/code&gt; with its type:</source>
          <target state="translated">돌연변이 처리기를 직접 호출 할 수 없습니다. &quot;이벤트 유형 &lt;code&gt;increment&lt;/code&gt; 가 있는 돌연변이 가 트리거되면이 핸들러를 호출하십시오.&quot; 돌연변이 핸들러를 호출하려면 다음 유형으로 &lt;code&gt;store.commit&lt;/code&gt; 을 호출해야 합니다.</target>
        </trans-unit>
        <trans-unit id="daa96a4f6ba2541961bc6b0ba61ad44c19c2cd8d" translate="yes" xml:space="preserve">
          <source>You cannot directly mutate the store's state. The only way to change a store's state is by explicitly &lt;strong&gt;committing mutations&lt;/strong&gt;. This ensures every state change leaves a track-able record, and enables tooling that helps us better understand our applications.</source>
          <target state="translated">상점 상태를 직접 변경할 수 없습니다. 상점의 상태를 변경하는 유일한 방법은 명시 적으로 &lt;strong&gt;돌연변이를 커밋하는 것&lt;/strong&gt; 입니다. 이를 통해 모든 상태 변경이 추적 가능한 레코드를 남기고 애플리케이션을 더 잘 이해하는 데 도움이되는 툴링이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="360fc60f946b0e1fb46441c21ec094cefc382a47" translate="yes" xml:space="preserve">
          <source>You don't need to do this when using global script tags.</source>
          <target state="translated">전역 스크립트 태그를 사용할 때는이 작업을 수행 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c70f3011e5bb2100175201538c23d3b8d06c1f46" translate="yes" xml:space="preserve">
          <source>You may care about unpredictable namespacing for your modules when you create a &lt;a href=&quot;plugins&quot;&gt;plugin&lt;/a&gt; that provides the modules and let users add them to a Vuex store. Your modules will be also namespaced if the plugin users add your modules under a namespaced module. To adapt this situation, you may need to receive a namespace value via your plugin option:</source>
          <target state="translated">모듈 을 제공 하는 &lt;a href=&quot;plugins&quot;&gt;플러그인&lt;/a&gt; 을 생성하고 사용자가 Vuex 저장소에 추가 할 수있게하면 모듈 에 예측할 수없는 이름 공간 이 필요할 수 있습니다. 플러그인 사용자가 네임 스페이스가있는 모듈 아래에 모듈을 추가하면 모듈도 네임 스페이스가됩니다. 이 상황을 적응 시키려면 플러그인 옵션을 통해 네임 스페이스 값을 받아야합니다.</target>
        </trans-unit>
        <trans-unit id="3f63bbd45ca0e396d20716f1a9faff811b1810cb" translate="yes" xml:space="preserve">
          <source>You will have to clone directly from GitHub and build &lt;code&gt;vuex&lt;/code&gt; yourself if you want to use the latest dev build.</source>
          <target state="translated">최신 개발 빌드를 사용하려면 GitHub에서 직접 복제하고 &lt;code&gt;vuex&lt;/code&gt; 를 직접 빌드해야합니다.</target>
        </trans-unit>
        <trans-unit id="326b426f9ac7a96ed6baf62f8838565416d27df8" translate="yes" xml:space="preserve">
          <source>actions</source>
          <target state="translated">actions</target>
        </trans-unit>
        <trans-unit id="4015b57a143aec5156fd1444a017a32137a3fd0f" translate="yes" xml:space="preserve">
          <source>commit</source>
          <target state="translated">commit</target>
        </trans-unit>
        <trans-unit id="c0b7cc8520ca125ff38dd308c300837ea02ab867" translate="yes" xml:space="preserve">
          <source>createNamespacedHelpers</source>
          <target state="translated">createNamespacedHelpers</target>
        </trans-unit>
        <trans-unit id="59211592ba313c330272b3b02e6654aaf2030698" translate="yes" xml:space="preserve">
          <source>createNamespacedHelpers()</source>
          <target state="translated">createNamespacedHelpers()</target>
        </trans-unit>
        <trans-unit id="d2d86ff5a0cd4d9837f7acff55b3a7cd9d364ab3" translate="yes" xml:space="preserve">
          <source>createStore</source>
          <target state="translated">createStore</target>
        </trans-unit>
        <trans-unit id="b853518a7253a67751993712323af2afe8d26a75" translate="yes" xml:space="preserve">
          <source>default: &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">기본값 : &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="154cfec6bb116856227577921ae39f8885428eb2" translate="yes" xml:space="preserve">
          <source>devtools</source>
          <target state="translated">devtools</target>
        </trans-unit>
        <trans-unit id="05b145cfb6fbc24d08a8e01155c0aa2bf8460c87" translate="yes" xml:space="preserve">
          <source>dispatch</source>
          <target state="translated">dispatch</target>
        </trans-unit>
        <trans-unit id="6ec8d967f553282c8a0b78d6540dfc8d420a3ef0" translate="yes" xml:space="preserve">
          <source>getters</source>
          <target state="translated">getters</target>
        </trans-unit>
        <trans-unit id="7035b5cff18dc8c3847faa85107fdff08894d5e1" translate="yes" xml:space="preserve">
          <source>hasModule</source>
          <target state="translated">hasModule</target>
        </trans-unit>
        <trans-unit id="191d360d6e9259ceda69018c10b131806a257339" translate="yes" xml:space="preserve">
          <source>hotUpdate</source>
          <target state="translated">hotUpdate</target>
        </trans-unit>
        <trans-unit id="7f3c4da8402c9feb0a967e99e24a689f07ad9538" translate="yes" xml:space="preserve">
          <source>mapActions</source>
          <target state="translated">mapActions</target>
        </trans-unit>
        <trans-unit id="1c9faade8425f6bc337e39a55a39ae4126bc894c" translate="yes" xml:space="preserve">
          <source>mapActions()</source>
          <target state="translated">mapActions()</target>
        </trans-unit>
        <trans-unit id="c5092a452ac716aa7395be56d5a3e111411ab603" translate="yes" xml:space="preserve">
          <source>mapGetters</source>
          <target state="translated">mapGetters</target>
        </trans-unit>
        <trans-unit id="4bed8eb971d49de14d01396cd2061d4908c28770" translate="yes" xml:space="preserve">
          <source>mapGetters()</source>
          <target state="translated">mapGetters()</target>
        </trans-unit>
        <trans-unit id="a837f5acfc97cfd8166f5f0c59fcbb7dfc666465" translate="yes" xml:space="preserve">
          <source>mapMutations</source>
          <target state="translated">mapMutations</target>
        </trans-unit>
        <trans-unit id="80e0f1f5c3583f0fd0d207c7f3df5c3aba3bd7ec" translate="yes" xml:space="preserve">
          <source>mapMutations()</source>
          <target state="translated">mapMutations()</target>
        </trans-unit>
        <trans-unit id="e5461d7d29007a5a5aa44df5c418d146a0695054" translate="yes" xml:space="preserve">
          <source>mapState</source>
          <target state="translated">mapState</target>
        </trans-unit>
        <trans-unit id="2d1ce243674082e4c821c3525927a44e71d4d016" translate="yes" xml:space="preserve">
          <source>mapState()</source>
          <target state="translated">mapState()</target>
        </trans-unit>
        <trans-unit id="4580485d482a9037af94f68af98adf23819cbdf4" translate="yes" xml:space="preserve">
          <source>modules</source>
          <target state="translated">modules</target>
        </trans-unit>
        <trans-unit id="3db5c1d36e4a153d7b5cda1e2d65b175222ccf09" translate="yes" xml:space="preserve">
          <source>mutations</source>
          <target state="translated">mutations</target>
        </trans-unit>
        <trans-unit id="440c3339cb056522cd1edf391e616ceb636e1a08" translate="yes" xml:space="preserve">
          <source>plugins</source>
          <target state="translated">plugins</target>
        </trans-unit>
        <trans-unit id="3f170c2be21627360e728ba4b0f15e0c20cc0126" translate="yes" xml:space="preserve">
          <source>registerModule</source>
          <target state="translated">registerModule</target>
        </trans-unit>
        <trans-unit id="eb49199248380da5116beeb5a5bdf9606ac21f82" translate="yes" xml:space="preserve">
          <source>replaceState</source>
          <target state="translated">replaceState</target>
        </trans-unit>
        <trans-unit id="aa4a5f8125f234182e2dea92805afdfb747a86be" translate="yes" xml:space="preserve">
          <source>state</source>
          <target state="translated">state</target>
        </trans-unit>
        <trans-unit id="41eaab877ca3a0e3aa14f5a4b7981f590e3c2bd6" translate="yes" xml:space="preserve">
          <source>strict</source>
          <target state="translated">strict</target>
        </trans-unit>
        <trans-unit id="4c91330c57b1f26f16a92bbcb0653bc2a60a5b88" translate="yes" xml:space="preserve">
          <source>subscribe</source>
          <target state="translated">subscribe</target>
        </trans-unit>
        <trans-unit id="c8be9eb77e0a063aa55220d426f0169f12707d24" translate="yes" xml:space="preserve">
          <source>subscribeAction</source>
          <target state="translated">subscribeAction</target>
        </trans-unit>
        <trans-unit id="575fade49b23c513149d6cbd60de79f6715e014d" translate="yes" xml:space="preserve">
          <source>type: &lt;code&gt;Array&amp;lt;Function&amp;gt;&lt;/code&gt;</source>
          <target state="translated">유형 : &lt;code&gt;Array&amp;lt;Function&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="501ad78bfb628eb307d521b862f9d31d47e25be6" translate="yes" xml:space="preserve">
          <source>type: &lt;code&gt;Boolean&lt;/code&gt;</source>
          <target state="translated">유형 : &lt;code&gt;Boolean&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7f896effac2d60505acabced97b30bbb769a74db" translate="yes" xml:space="preserve">
          <source>type: &lt;code&gt;Object | Function&lt;/code&gt;</source>
          <target state="translated">유형 : &lt;code&gt;Object | Function&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="459de9ab6bbb747b424aa86431b8923f3e3cebed" translate="yes" xml:space="preserve">
          <source>type: &lt;code&gt;Object&lt;/code&gt;</source>
          <target state="translated">유형 : &lt;code&gt;Object&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e0800374f05dce7addc4f97d5a68d2e7b35b3ef4" translate="yes" xml:space="preserve">
          <source>type: &lt;code&gt;boolean&lt;/code&gt;</source>
          <target state="translated">유형 : &lt;code&gt;boolean&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0adf6137f83fccfe39fef3d4143300d0f0d7953d" translate="yes" xml:space="preserve">
          <source>type: &lt;code&gt;{ [key: string]: Function }&lt;/code&gt;</source>
          <target state="translated">유형 : &lt;code&gt;{ [key: string]: Function }&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="116a5df420232cc247b1f0bf6bbbec8667db410b" translate="yes" xml:space="preserve">
          <source>type: &lt;code&gt;{ [type: string]: Function }&lt;/code&gt;</source>
          <target state="translated">유형 : &lt;code&gt;{ [type: string]: Function }&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a69e7241a5b047759b4617f9a2bc7130db75edc" translate="yes" xml:space="preserve">
          <source>unregisterModule</source>
          <target state="translated">unregisterModule</target>
        </trans-unit>
        <trans-unit id="53c05e9fd370dfe1efd890820e99c7a18b9c5414" translate="yes" xml:space="preserve">
          <source>useStore</source>
          <target state="translated">useStore</target>
        </trans-unit>
        <trans-unit id="292b0901993f7e9d9a0d9b80542f9e59505ba5be" translate="yes" xml:space="preserve">
          <source>watch</source>
          <target state="translated">watch</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
