<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="bluebird">
    <body>
      <group id="bluebird">
        <trans-unit id="f76b9571c2fa26f1c9c053453e48baf3102b175e" translate="yes" xml:space="preserve">
          <source>Implement &lt;a href=&quot;api/reflect&quot;&gt;&lt;code&gt;.reflect()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;api/reflect&quot;&gt; &lt;code&gt;.reflect()&lt;/code&gt; &lt;/a&gt; 구현</target>
        </trans-unit>
        <trans-unit id="0de27db7a173e23bc1b1a951c986b9e75189651d" translate="yes" xml:space="preserve">
          <source>Implement &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#promisecoroutineaddyieldhandlerfunction-handler---void&quot;&gt;&lt;code&gt;Promise.coroutine.addYieldHandler()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#promisecoroutineaddyieldhandlerfunction-handler---void&quot;&gt; &lt;code&gt;Promise.coroutine.addYieldHandler()&lt;/code&gt; &lt;/a&gt; 구현</target>
        </trans-unit>
        <trans-unit id="debaea1257108cf0777761addbfa5ec8ad866a63" translate="yes" xml:space="preserve">
          <source>Implement &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#tapfunction-handler---promise&quot;&gt;&lt;code&gt;Promise.prototype.tap()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#tapfunction-handler---promise&quot;&gt; &lt;code&gt;Promise.prototype.tap()&lt;/code&gt; &lt;/a&gt; 구현</target>
        </trans-unit>
        <trans-unit id="5a1c43a24101780f93b51137f52374d22e70596b" translate="yes" xml:space="preserve">
          <source>Implement &lt;code&gt;.bind&lt;/code&gt; and &lt;code&gt;Promise.bind&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;.bind&lt;/code&gt; 및 &lt;code&gt;Promise.bind&lt;/code&gt; 구현</target>
        </trans-unit>
        <trans-unit id="0f380a273aee2d6cf970a6fe45244632c5d9b4cc" translate="yes" xml:space="preserve">
          <source>Implement &lt;code&gt;.return()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;.return()&lt;/code&gt; 구현</target>
        </trans-unit>
        <trans-unit id="b4c72d943e49cf756fcbd5f12144b514c9e719f9" translate="yes" xml:space="preserve">
          <source>Implement &lt;code&gt;.throw()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;.throw()&lt;/code&gt; 구현</target>
        </trans-unit>
        <trans-unit id="ae49e6671f17e74abdd91283eaaa890a378ca81b" translate="yes" xml:space="preserve">
          <source>Implement &lt;code&gt;Promise.method()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Promise.method()&lt;/code&gt; 구현</target>
        </trans-unit>
        <trans-unit id="1d181fb40191fdf3fe9541cbc7a61c14dc076b35" translate="yes" xml:space="preserve">
          <source>Implement RejectionError wrapping and &lt;code&gt;.error()&lt;/code&gt; method</source>
          <target state="translated">RejectionError 줄 바꿈 및 &lt;code&gt;.error()&lt;/code&gt; 메소드 구현</target>
        </trans-unit>
        <trans-unit id="ff1c32750ed475d16c2e3d6ee2570476a4351b7a" translate="yes" xml:space="preserve">
          <source>Implemented &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#global-rejection-events&quot;&gt;global rejection events&lt;/a&gt; (&lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/428&quot;&gt;#428&lt;/a&gt;, &lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/357&quot;&gt;#357&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#global-rejection-events&quot;&gt;글로벌 거부 이벤트&lt;/a&gt; 구현 ( &lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/428&quot;&gt;# 428&lt;/a&gt; , &lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/357&quot;&gt;# 357&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="6677e178a6bc2ac6cc38cee7e51212de4486b2b2" translate="yes" xml:space="preserve">
          <source>Implementing general progress interfaces like in C#:</source>
          <target state="translated">C #과 같은 일반적인 진행 인터페이스 구현</target>
        </trans-unit>
        <trans-unit id="733eea0f9f3a4d9f23332caa166015a4f890c124" translate="yes" xml:space="preserve">
          <source>Implementing the example from &lt;a href=&quot;https://github.com/caolan/async#waterfalltasks-callback&quot;&gt;async homepage&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/caolan/async#waterfalltasks-callback&quot;&gt;비동기 홈페이지&lt;/a&gt; 에서 예제 구현</target>
        </trans-unit>
        <trans-unit id="97ecdd3f427cfc303e767bb0913667606529c860" translate="yes" xml:space="preserve">
          <source>Implicit &lt;code&gt;Promise.all()&lt;/code&gt; when yielding an array from generators</source>
          <target state="translated">생성기에서 배열을 생성 할 때 암시 적 &lt;code&gt;Promise.all()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1dd411a1bd6013312e12e897a0c51cd4f4318ca0" translate="yes" xml:space="preserve">
          <source>Improve &lt;code&gt;promisifyAll&lt;/code&gt; detection of functions that are class constructors. Fixes mongodb 2.x promisification.</source>
          <target state="translated">개선 &lt;code&gt;promisifyAll&lt;/code&gt; 의 클래스 생성자있는 기능을 감지. mongodb 2.x 약속을 수정합니다.</target>
        </trans-unit>
        <trans-unit id="213e96bdfb4a128bc3bd87f532efaf90f14c5e6a" translate="yes" xml:space="preserve">
          <source>Improve output of reporting unhandled non-errors</source>
          <target state="translated">처리되지 않은 비 오류보고의 출력 향상</target>
        </trans-unit>
        <trans-unit id="21437ff0b7933ce8b58f0d38d668c7b9602b5664" translate="yes" xml:space="preserve">
          <source>Improve overall performance when not using &lt;code&gt;.bind()&lt;/code&gt; or cancellation.</source>
          <target state="translated">&lt;code&gt;.bind()&lt;/code&gt; 또는 취소를 사용하지 않을 때 전반적인 성능을 향상시킵니다 .</target>
        </trans-unit>
        <trans-unit id="a3cd986d15205ea786fe95cf148b685b17a4a66b" translate="yes" xml:space="preserve">
          <source>Improve overall performance.</source>
          <target state="translated">전반적인 성능을 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="d91321dac872eb3a4ecd05762060d481636fa793" translate="yes" xml:space="preserve">
          <source>Improve overall performance. Be able to sustain infinite recursion when using promises.</source>
          <target state="translated">전반적인 성능을 향상시킵니다. 약속을 사용할 때 무한 재귀를 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23dc55298841549083703a0dc975bff9f3e5d5fc" translate="yes" xml:space="preserve">
          <source>Improve performance of .finally.</source>
          <target state="translated">.finally의 성능을 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="b5cef6dcb86b0975f111f8f1d79bf5d753600cad" translate="yes" xml:space="preserve">
          <source>Improve performance of &lt;code&gt;.props()&lt;/code&gt; and collection methods when used with immediate values</source>
          <target state="translated">즉각적인 값과 함께 사용될 때 &lt;code&gt;.props()&lt;/code&gt; 및 콜렉션 메소드의 성능 향상</target>
        </trans-unit>
        <trans-unit id="6533fb39d2c4b52d57bf0b0080357de93b567761" translate="yes" xml:space="preserve">
          <source>Improve performance of &lt;code&gt;.reduce()&lt;/code&gt; when &lt;code&gt;initialValue&lt;/code&gt; can be synchronously cast to a value</source>
          <target state="translated">&lt;code&gt;initialValue&lt;/code&gt; 를 동 기적으로 값으로 캐스트 할 수있을 때 &lt;code&gt;.reduce()&lt;/code&gt; 성능 향상</target>
        </trans-unit>
        <trans-unit id="b79e5ce64b3cc6df23f96da6189a55cda2f3a24b" translate="yes" xml:space="preserve">
          <source>Improve performance of &lt;code&gt;.some()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;.some()&lt;/code&gt; 성능 향상</target>
        </trans-unit>
        <trans-unit id="6605838414ae4861872117f11458f4f7c032e53b" translate="yes" xml:space="preserve">
          <source>Improve performance of &lt;code&gt;Promise.method&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Promise.method&lt;/code&gt; 의 성능 향상</target>
        </trans-unit>
        <trans-unit id="1801c2ab62399342798816e151c62d526a208232" translate="yes" xml:space="preserve">
          <source>Improve performance of &lt;code&gt;Promise.race&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Promise.race&lt;/code&gt; 의 성능 향상</target>
        </trans-unit>
        <trans-unit id="b47c1066dd0e09e1dc6291709e049b1a62126113" translate="yes" xml:space="preserve">
          <source>Improve performance of &lt;code&gt;Promise.try&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Promise.try&lt;/code&gt; 의 성능 향상</target>
        </trans-unit>
        <trans-unit id="f0221a27976575e573ab343e0c7bf4e30199750e" translate="yes" xml:space="preserve">
          <source>Improve performance of all collection methods</source>
          <target state="translated">모든 수집 방법의 성능 향상</target>
        </trans-unit>
        <trans-unit id="69bc40cef74e6b8ed6de0d57bc11088841731b08" translate="yes" xml:space="preserve">
          <source>Improve performance of catch filters.</source>
          <target state="translated">캐치 필터의 성능을 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="493b04565b586c443227bda9dba7b5733786d595" translate="yes" xml:space="preserve">
          <source>Improve performance of collection methods</source>
          <target state="translated">수집 방법의 성능 향상</target>
        </trans-unit>
        <trans-unit id="f3e709b44915764f7a5d40fc9df801ca2e482471" translate="yes" xml:space="preserve">
          <source>Improve performance of generators</source>
          <target state="translated">발전기 성능 향상</target>
        </trans-unit>
        <trans-unit id="f2f07a6efaf7192742177f90f38e34f5cffb946a" translate="yes" xml:space="preserve">
          <source>Improve performance of promise chains</source>
          <target state="translated">약속 체인의 성능 향상</target>
        </trans-unit>
        <trans-unit id="ab32070153659d73fbda42374c3ef4d00f9c1281" translate="yes" xml:space="preserve">
          <source>Improve performance of promisified functions on V8</source>
          <target state="translated">V8에서 약속 된 기능의 성능 향상</target>
        </trans-unit>
        <trans-unit id="9c964cafe501b6c71e57bfaecc51d7213a1f33ad" translate="yes" xml:space="preserve">
          <source>Improve performance of promisified functions.</source>
          <target state="translated">약속 된 기능의 성능을 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="d0964ce694308926e6cce53db966d728b2dd5ab4" translate="yes" xml:space="preserve">
          <source>Improved performance and readability</source>
          <target state="translated">성능 및 가독성 향상</target>
        </trans-unit>
        <trans-unit id="70e80457a02f473b417d800f6ebe8e2a3e15d72c" translate="yes" xml:space="preserve">
          <source>In 2.x, promise cancellation looked very differently. Promise cancellation received a major overhaul for version 3 in order to create a sound variant of cancellable promises. You can still use 2.x cancellation with bluebird 2.x (which is still supported - but not recommended). See &lt;a href=&quot;http://bluebirdjs.com/cancellation.html&quot;&gt;Cancellation&lt;/a&gt; for more details. The 2.x docs are &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/2.x/API.md&quot;&gt;still accessible under the 2.x branch&lt;/a&gt;.</source>
          <target state="translated">2.x에서 약속 취소는 매우 다르게 보였습니다. 약속 취소는 취소 가능한 약속의 소리 변형을 만들기 위해 버전 3에 대한 주요 점검을 받았습니다. 블루 버드 2.x에서는 여전히 2.x 취소를 사용할 수 있습니다 (여전히 지원되지만 권장되지는 않음). 자세한 내용은 &lt;a href=&quot;http://bluebirdjs.com/cancellation.html&quot;&gt;취소&lt;/a&gt; 를 참조하십시오. 2.x 문서는 &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/2.x/API.md&quot;&gt;2.x 분기에서 계속 액세스 할 수 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e8fc7d5be5578254c3c3ba0dde3ab83e463051fa" translate="yes" xml:space="preserve">
          <source>In Node.js you may configure warnings and long stack traces for the entire process using environment variables:</source>
          <target state="translated">Node.js에서 환경 변수를 사용하여 전체 프로세스에 대해 경고 및 긴 스택 추적을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="361446f42424e75edad97d144b32a1e290e72cc3" translate="yes" xml:space="preserve">
          <source>In Node/io.js most APIs follow a convention of &lt;a href=&quot;https://gist.github.com/CrabDude/10907185&quot;&gt;'error-first, single-parameter'&lt;/a&gt; as such:</source>
          <target state="translated">Node / io.js에서 대부분의 API는 다음과 같이 &lt;a href=&quot;https://gist.github.com/CrabDude/10907185&quot;&gt;'오류 우선, 단일 매개 변수'&lt;/a&gt; 규칙을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="20a81f38445f0a6f17f84f7b1c945721cfb38a3e" translate="yes" xml:space="preserve">
          <source>In Web Workers you may use &lt;code&gt;self.addEventListener&lt;/code&gt;.</source>
          <target state="translated">웹 워커에서는 &lt;code&gt;self.addEventListener&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6b759cd2431b6c3f52be7951a07c24cc5f5b3b96" translate="yes" xml:space="preserve">
          <source>In addition promises are always unwrapped. A promise implicitly has &lt;code&gt;Task.Unwrap&lt;/code&gt; called on it - that is, promises perform recursive assimilation of promises within them.</source>
          <target state="translated">또한 약속은 항상 풀립니다. 약속에는 암시 적으로 &lt;code&gt;Task.Unwrap&lt;/code&gt; 가 있습니다 .Unwrap 은 그 약속을 되풀이 했습니다.</target>
        </trans-unit>
        <trans-unit id="da70284ad0b5f811fe8223b6b3d83e713568a28f" translate="yes" xml:space="preserve">
          <source>In addition promises are always unwrapped. That is, promises perform recursive assimilation of promises within them. You can't have a &lt;code&gt;Promise&amp;lt;Promise&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; where a &lt;code&gt;Future[Future[T]]&lt;/code&gt; is valid in Scala.</source>
          <target state="translated">또한 약속은 항상 풀립니다. 즉, 약속은 약속 내에서 반복되는 약속의 동화를 수행합니다. 당신은 할 수없는 &lt;code&gt;Promise&amp;lt;Promise&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; &lt;code&gt;Future[Future[T]]&lt;/code&gt; 스칼라에서 유효합니다.</target>
        </trans-unit>
        <trans-unit id="b3db467e4305c26c33d91d438b39bab7913a7d8d" translate="yes" xml:space="preserve">
          <source>In all of the above cases the library made its classes available in one way or another. If this is not the case, you can still promisify by creating a throwaway instance:</source>
          <target state="translated">위의 모든 경우에 라이브러리는 클래스를 어떤 방식 으로든 사용할 수있게 만들었습니다. 그렇지 않은 경우에도 인스턴스를 생성하여 약속 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a37bb782f65c2292150ec12a9ec0ac667bbafa9d" translate="yes" xml:space="preserve">
          <source>In bluebird we've chosen to do the latter because resources are typically scarce. For example, if a database connection cannot be disposed of and Bluebird ignores that, the connection pool will be quickly depleted and the process will become unusable (all requests that query the database will wait forever). Since Bluebird doesn't know how to handle that, the only sensible default is to crash the process. That way, rather than getting a useless process that cannot fulfill more requests, we can swap the faulty worker with a new one letting the OS clean up the resources for us.</source>
          <target state="translated">블루 버드에서는 리소스가 일반적으로 부족하기 때문에 후자를 선택했습니다. 예를 들어, 데이터베이스 연결을 폐기 할 수없고 Bluebird가이를 무시하면 연결 풀이 빨리 고갈되고 프로세스를 사용할 수 없게됩니다 (데이터베이스를 쿼리하는 모든 요청은 영구적으로 대기 함). Bluebird는이를 처리하는 방법을 모르기 때문에 유일하게 합리적인 기본값은 프로세스를 중단하는 것입니다. 이렇게하면 더 많은 요청을 처리 할 수없는 쓸모없는 프로세스를 얻는 대신 결함있는 작업자를 새로운 프로세스로 교체하여 OS가 리소스를 정리할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca0b3dbad60939fa3e3338aec5bf46570e2d8a1a" translate="yes" xml:space="preserve">
          <source>In conjunction with &lt;a href=&quot;disposer&quot;&gt;&lt;code&gt;.disposer&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;using&lt;/code&gt; will make sure that no matter what, the specified disposer will be called when the promise returned by the callback passed to &lt;code&gt;using&lt;/code&gt; has settled. The disposer is necessary because there is no standard interface in node for disposing resources.</source>
          <target state="translated">&lt;a href=&quot;disposer&quot;&gt; &lt;code&gt;.disposer&lt;/code&gt; &lt;/a&gt; 와 함께 를 &lt;code&gt;using&lt;/code&gt; 하면 사용 하면 콜백에 의해 반환 된 약속이 &lt;code&gt;using&lt;/code&gt; 전달되었을 때 지정된 처리기가 호출됩니다 . 노드에 자원을 폐기하기위한 표준 인터페이스가 없기 때문에 처리기가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="879b1a8e6173fcc0fe684d08d132ce1871ae3253" translate="yes" xml:space="preserve">
          <source>In general, the usage of &lt;a href=&quot;api/promise.promisifyall&quot;&gt;&lt;code&gt;Promise.promisifyAll&lt;/code&gt;&lt;/a&gt; is along the lines of &lt;code&gt;var fs = Promise.promisifyAll(require(&quot;fs&quot;))&lt;/code&gt;.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;api/promise.promisifyall&quot;&gt; &lt;code&gt;Promise.promisifyAll&lt;/code&gt; &lt;/a&gt; 의 사용법은 &lt;code&gt;var fs = Promise.promisifyAll(require(&quot;fs&quot;))&lt;/code&gt; 라인을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="8efb8cf18cab76bf61b065fcc2def10c9ed9fac9" translate="yes" xml:space="preserve">
          <source>In our dialog example perhaps we want to differentiate between a rejected promise because of some problem (bad AJAX, programming error, etc.) or because the user pressed the cancel button.</source>
          <target state="translated">우리의 대화 예제에서 우리는 어떤 문제 (나쁜 AJAX, 프로그래밍 오류 등)로 인해 또는 사용자가 취소 버튼을 눌렀 기 때문에 거부 된 약속을 구별하려고합니다.</target>
        </trans-unit>
        <trans-unit id="b6bbd69af3538cceaf0f293038d0f3eaed462ca8" translate="yes" xml:space="preserve">
          <source>In practice:</source>
          <target state="translated">실제로:</target>
        </trans-unit>
        <trans-unit id="21b9f4a2f2ffcaff8935b98b291fdfb43db81e8c" translate="yes" xml:space="preserve">
          <source>In recent versions generator libraries started abandoning old ideas of special tokens passed to callbacks and started using promises for what's being yielded.</source>
          <target state="translated">최근 버전에서 생성기 라이브러리는 콜백에 전달 된 특수 토큰에 대한 오래된 아이디어를 포기하기 시작했으며 산출량에 대한 약속을 사용하기 시작했습니다.</target>
        </trans-unit>
        <trans-unit id="90361caad2f10101ee0f756a8ebd2978182891e3" translate="yes" xml:space="preserve">
          <source>In the above example, the connection returned by &lt;code&gt;getConnection&lt;/code&gt; can only be used via &lt;code&gt;Promise.using&lt;/code&gt;, like so:</source>
          <target state="translated">위의 예에서 &lt;code&gt;getConnection&lt;/code&gt; 이 반환 한 연결은 다음과 같이 &lt;code&gt;Promise.using&lt;/code&gt; 을 통해서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cb64939e278ff57bb52a7c44ea2a2cbd428cb81a" translate="yes" xml:space="preserve">
          <source>In the explicit construction anti-pattern, promise objects are created for no reason, complicating code.</source>
          <target state="translated">명시 적 구조 안티 패턴에서, 약속 객체는 아무 이유없이 생성되어 코드를 복잡하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="b0070e87ecff77ecb23ce611e38aac089e617332" translate="yes" xml:space="preserve">
          <source>In the following example you might want to handle just the &lt;code&gt;SyntaxError&lt;/code&gt; from JSON.parse and Filesystem errors from &lt;code&gt;fs&lt;/code&gt; but let programmer errors bubble as unhandled rejections:</source>
          <target state="translated">다음 예제에서는 JSON.parse 의 &lt;code&gt;SyntaxError&lt;/code&gt; 및 &lt;code&gt;fs&lt;/code&gt; 의 파일 시스템 오류 만 처리하고 프로그래머 오류는 처리되지 않은 거부로 버블 링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73d3bed94715ad4383569042f35e985547cd7283" translate="yes" xml:space="preserve">
          <source>In the latter the indentation stays flat no matter how many previous variables you need, whereas with the former each additional previous value would require an additional nesting level.</source>
          <target state="translated">후자는 들여 쓰기가 필요한 이전 변수의 수에 관계없이 평평하게 유지되는 반면, 전자의 경우 이전의 각 추가 이전 값에는 추가 중첩 수준이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="dd6afd7e774c8e6fdacd9e8f55a35e835be8f939" translate="yes" xml:space="preserve">
          <source>In this case, the promise resolves with itself which was is not intended.</source>
          <target state="translated">이 경우 약속은 의도하지 않은 자체로 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="30b4d4283864d46d2836b690ac2cbfeafa74746b" translate="yes" xml:space="preserve">
          <source>Individual promisifcation uses current &lt;code&gt;this&lt;/code&gt; if no explicit receiver is given</source>
          <target state="translated">명백한 수신자가 제공되지 않은 경우 개별 약속은 현재 &lt;code&gt;this&lt;/code&gt; 사용합니다.</target>
        </trans-unit>
        <trans-unit id="68c8caa0f2f33563e5d4c95632e8edaafba86244" translate="yes" xml:space="preserve">
          <source>Initially the Dialog class sets the two callbacks to &lt;em&gt;noop&lt;/em&gt; functions. It is up to the child class to call them when necessary. We break down the promise creation to one function &lt;code&gt;waitForUser()&lt;/code&gt; that sets the callbacks and returns a promise. At this level the &lt;code&gt;show()&lt;/code&gt; and &lt;code&gt;hide()&lt;/code&gt; are just &lt;em&gt;noop&lt;/em&gt; functions as well and will be implemented by the child classes.</source>
          <target state="translated">처음에 Dialog 클래스는 두 콜백을 &lt;em&gt;noop&lt;/em&gt; 함수로 설정합니다 . 필요할 때 전화하는 것은 어린이 수업에 달려 있습니다. 우리는 약속 생성을 콜백을 설정하고 약속을 반환하는 하나의 함수 &lt;code&gt;waitForUser()&lt;/code&gt; 로 분류합니다. 이 수준에서 &lt;code&gt;show()&lt;/code&gt; 및 &lt;code&gt;hide()&lt;/code&gt; 는 단지 &lt;em&gt;noop&lt;/em&gt; 함수일 뿐이며 자식 클래스에 의해 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="d84677d86357a2c0115e2ed2adb5f6ec133b7f26" translate="yes" xml:space="preserve">
          <source>Instead of using the Deferred anti-pattern, the code should simply return the promise it already has and propagate values using &lt;code&gt;return&lt;/code&gt;:</source>
          <target state="translated">Deferred anti-pattern을 사용하는 대신, 코드는 단순히 약속을 리턴하고 &lt;code&gt;return&lt;/code&gt; 을 사용하여 값을 전파해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1aed780a746f68d28a85c473dd835c234712b990" translate="yes" xml:space="preserve">
          <source>Instead, use &lt;a href=&quot;api/promise.promisifyall&quot;&gt;&lt;code&gt;Promise.promisifyAll&lt;/code&gt;&lt;/a&gt; :</source>
          <target state="translated">대신 &lt;a href=&quot;api/promise.promisifyall&quot;&gt; &lt;code&gt;Promise.promisifyAll&lt;/code&gt; 을&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="659525747c675f26d0d0761f93182ab5228cbc26" translate="yes" xml:space="preserve">
          <source>Into this:</source>
          <target state="translated">이것으로 :</target>
        </trans-unit>
        <trans-unit id="a66cb4039287c802cdc27ed98f34dc1c2d5d9411" translate="yes" xml:space="preserve">
          <source>It also works on singletons or specific instances:</source>
          <target state="translated">또한 싱글 톤 또는 특정 인스턴스에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="6b5d95eeedfe49016755274286b46a188fd09776" translate="yes" xml:space="preserve">
          <source>It comes in two variants. - A tapCatch-all variant similar to &lt;a href=&quot;catch&quot;&gt;&lt;code&gt;.catch&lt;/code&gt;&lt;/a&gt; block. This variant is compatible with native promises. - A filtered variant (like other non-JS languages typically have) that lets you only handle specific errors. &lt;strong&gt;This variant is usually preferable&lt;/strong&gt;.</source>
          <target state="translated">두 가지 변형이 있습니다. &lt;a href=&quot;catch&quot;&gt; &lt;code&gt;.catch&lt;/code&gt; &lt;/a&gt; 블록 과 유사한 tapCatch-all 변형 . 이 변형은 기본 약속과 호환됩니다. -특정 오류 만 처리 할 수있는 필터링 된 변형 (일반적으로 다른 비 JS 언어와 마찬가지로) &lt;strong&gt;이 변형이 일반적으로 바람직&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="e2a3866a72ba04bc9a62fa718c486091a65f59f8" translate="yes" xml:space="preserve">
          <source>It is equivalent to the following &lt;a href=&quot;catch&quot;&gt;&lt;code&gt;.catch&lt;/code&gt;&lt;/a&gt; pattern:</source>
          <target state="translated">다음 &lt;a href=&quot;catch&quot;&gt; &lt;code&gt;.catch&lt;/code&gt; &lt;/a&gt; 패턴 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="0b0ded67bc5c7c35daa1f171d80dccf1a33e74e4" translate="yes" xml:space="preserve">
          <source>It is essentially an efficient shortcut for doing a &lt;a href=&quot;map&quot;&gt;&lt;code&gt;.map&lt;/code&gt;&lt;/a&gt; and then &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter&quot;&gt;&lt;code&gt;Array#filter&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">본질적으로 &lt;a href=&quot;map&quot;&gt; &lt;code&gt;.map&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter&quot;&gt; &lt;code&gt;Array#filter&lt;/code&gt; &lt;/a&gt; 수행을위한 효율적인 바로 가기입니다 .</target>
        </trans-unit>
        <trans-unit id="67ad0cadb6c3a5671744781f608f9a02e1c5a392" translate="yes" xml:space="preserve">
          <source>It is more likely that you would write this instead in the sync world:</source>
          <target state="translated">동기화 세계에서 대신 이것을 작성할 가능성이 큽니다.</target>
        </trans-unit>
        <trans-unit id="53a01add8c2bcb3ae05a334c130487578987c686" translate="yes" xml:space="preserve">
          <source>It is often said that promises cannot be cancellable because they can have multiple consumers.</source>
          <target state="translated">약속은 여러 소비자를 가질 수 있기 때문에 취소 할 수 없다고 종종 말합니다.</target>
        </trans-unit>
        <trans-unit id="6b0e7d44695db980a8f0ed40ee055bb11d90c7f7" translate="yes" xml:space="preserve">
          <source>It is very subtle but over time this code will exhaust the entire connection pool and the server needs to be restarted. This is because reading the file may fail and then of course &lt;code&gt;.spread&lt;/code&gt; is not called at all and thus the connection is not closed.</source>
          <target state="translated">매우 미묘하지만 시간이 지남에 따라이 코드는 전체 연결 풀을 소모하므로 서버를 다시 시작해야합니다. 파일을 읽는 데 실패하고 &lt;code&gt;.spread&lt;/code&gt; 가 전혀 호출되지 않아 연결이 닫히지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="25e4aad38b66ae4f579919e5442c2f87282d298e" translate="yes" xml:space="preserve">
          <source>It might look like this:</source>
          <target state="translated">다음과 같이 보일 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="f3201aa0565e8be1e1547bcb52a2f64c00b2bc44" translate="yes" xml:space="preserve">
          <source>It should be noted that there is no real need to attach the handlers asynchronously. Exactly the same effect can be achieved with:</source>
          <target state="translated">처리기를 비동기 적으로 연결할 필요는 없습니다. 다음과 같은 효과를 얻을 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="f25d9aa71a1aef724d7f8d933c376e203e6ccfd0" translate="yes" xml:space="preserve">
          <source>It's also possible to use a disposer pattern (but not actual disposers) for transaction management:</source>
          <target state="translated">트랜잭션 관리에 Disposer 패턴 (실제 Disposers는 아님)을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3b38a83ae257f40976a60195f877e73b38d539c" translate="yes" xml:space="preserve">
          <source>Iterate over an array, or a promise of an array, which contains promises (or a mix of promises and values) with the given &lt;code&gt;iterator&lt;/code&gt; function with the signature &lt;code&gt;(value, index, length)&lt;/code&gt; where &lt;code&gt;value&lt;/code&gt; is the resolved value of a respective promise in the input array. &lt;strong&gt;Iteration happens serially&lt;/strong&gt;. If the iterator function returns a promise or a thenable, then the result of the promise is awaited before continuing with next iteration. If any promise in the input array is rejected, then the returned promise is rejected as well.</source>
          <target state="translated">반복 처리 지정된 된 배열 또는 약속을 포함하는 배열 (또는 약속과 값의 조합)의 약속 위에 &lt;code&gt;iterator&lt;/code&gt; 서명과 함수 &lt;code&gt;(value, index, length)&lt;/code&gt; &lt;code&gt;value&lt;/code&gt; 각각 약속의 해결 값이며 입력 배열 &lt;strong&gt;반복적으로 발생합니다&lt;/strong&gt; . 반복자 함수가 promise 또는 thenable을 반환하면 다음 반복을 계속하기 전에 promise의 결과가 기다립니다. 입력 배열의 약속이 거부되면 반환 된 약속도 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="d889900760cbb5576feda8db1d4c5015016f6e85" translate="yes" xml:space="preserve">
          <source>Iterate over an array, or a promise of an array, which contains promises (or a mix of promises and values) with the given &lt;code&gt;iterator&lt;/code&gt; function with the signature &lt;code&gt;(value, index, length)&lt;/code&gt; where &lt;code&gt;value&lt;/code&gt; is the resolved value of a respective promise in the input array. Iteration happens serially. If any promise in the input array is rejected the returned promise is rejected as well.</source>
          <target state="translated">반복 처리 지정된 된 배열 또는 약속을 포함하는 배열 (또는 약속과 값의 조합)의 약속 위에 &lt;code&gt;iterator&lt;/code&gt; 서명과 함수 &lt;code&gt;(value, index, length)&lt;/code&gt; &lt;code&gt;value&lt;/code&gt; 각각 약속의 해결 값이며 입력 배열 반복적으로 발생합니다. 입력 배열의 약속이 거부되면 반환 된 약속도 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="e027e57610f85225767aafbbf23fed7457e55828" translate="yes" xml:space="preserve">
          <source>Java</source>
          <target state="translated">Java</target>
        </trans-unit>
        <trans-unit id="769460330d98abc38d4f157088d641889b8e080c" translate="yes" xml:space="preserve">
          <source>Just like a future, a promise represents a value over time. The value can resolve to either a fulfilled (ok completion) or rejected (error completion) state.</source>
          <target state="translated">미래와 마찬가지로 약속은 시간이 지남에 따른 가치를 나타냅니다. 값은 완료 (완료) 또는 거부 (오류 완료) 상태로 해석 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">MIT 라이센스에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="d2b04d056ad9ef4e9bfb796dceb8c12c3d2724b7" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;all&quot;&gt;&lt;code&gt;.all&lt;/code&gt;&lt;/a&gt; but for object properties or &lt;code&gt;Map&lt;/code&gt;s* entries instead of iterated values. Returns a promise that is fulfilled when all the properties of the object or the &lt;code&gt;Map&lt;/code&gt;'s' values** are fulfilled. The promise's fulfillment value is an object or a &lt;code&gt;Map&lt;/code&gt; with fulfillment values at respective keys to the original object or a &lt;code&gt;Map&lt;/code&gt;. If any promise in the object or &lt;code&gt;Map&lt;/code&gt; rejects, the returned promise is rejected with the rejection reason.</source>
          <target state="translated">반복되는 값 대신 객체 속성 또는 &lt;code&gt;Map&lt;/code&gt; s * 항목을 제외하고 &lt;a href=&quot;all&quot;&gt; &lt;code&gt;.all&lt;/code&gt; &lt;/a&gt; 과 유사 합니다. 오브젝트의 모든 특성 또는 &lt;code&gt;Map&lt;/code&gt; 's'값 **이 충족 될 때 이행되는 약속을 리턴합니다 . promise의 이행 값은 각각의 키에서 원래 오브젝트 또는 &lt;code&gt;Map&lt;/code&gt; 에 대한 이행 값이있는 오브젝트 또는 &lt;code&gt;Map&lt;/code&gt; 입니다. 오브젝트 또는 &lt;code&gt;Map&lt;/code&gt; 약속이 거부되면 거부 이유와 함께 리턴 된 약속이 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="0868022eae9754566ebce8819ba10c34f00156c4" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;catch&quot;&gt;&lt;code&gt;.catch&lt;/code&gt;&lt;/a&gt; but instead of catching all types of exceptions, it only catches operational errors.</source>
          <target state="translated">&lt;a href=&quot;catch&quot;&gt; &lt;code&gt;.catch&lt;/code&gt; &lt;/a&gt; 와 비슷 하지만 모든 유형의 예외를 포착하는 대신 작동 오류 만 포착합니다.</target>
        </trans-unit>
        <trans-unit id="f7724ecb2f95d5397a59e0da7c44a35554300566" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;finally&quot;&gt;&lt;code&gt;.finally&lt;/code&gt;&lt;/a&gt; that is not called for fulfillments.</source>
          <target state="translated">. &lt;a href=&quot;finally&quot;&gt; &lt;code&gt;.finally&lt;/code&gt; &lt;/a&gt; 그것은 성취를 요구하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4b705bae03f08f49a3c59a2a4c3c23676360ce32" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;promise.some&quot;&gt;&lt;code&gt;Promise.some&lt;/code&gt;&lt;/a&gt;, with 1 as &lt;code&gt;count&lt;/code&gt;. However, if the promise fulfills, the fulfillment value is not an array of 1 but the value directly.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;promise.some&quot;&gt; &lt;code&gt;Promise.some&lt;/code&gt; &lt;/a&gt; 로 1, &lt;code&gt;count&lt;/code&gt; . 그러나 약속이 이행되면 이행 값은 1의 배열이 아니라 직접 값입니다.</target>
        </trans-unit>
        <trans-unit id="a0572842c5b510f6b6c6d450ffa47af7bfa19546" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;then&quot;&gt;&lt;code&gt;.then&lt;/code&gt;&lt;/a&gt;, but any unhandled rejection that ends up here will crash the process (in node) or be thrown as an error (in browsers). The use of this method is heavily discouraged and it only exists for historical reasons.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;then&quot;&gt; &lt;code&gt;.then&lt;/code&gt; &lt;/a&gt; , 그러나 여기에서 끝 업 (노드) 과정을 충돌거나 (브라우저에서) 오류로 던져 질 것을 처리되지 않은 거부. 이 방법의 사용은 권장하지 않으며 역사적 이유로 만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="1d64e920d46f5914cb7b3fc3949b2df8768d761d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;.map&lt;/code&gt; and &lt;code&gt;.filter&lt;/code&gt;, &lt;code&gt;.reduce&lt;/code&gt; now allows returning promises and thenables from the iteration function.</source>
          <target state="translated">마찬가지로 &lt;code&gt;.map&lt;/code&gt; 및 &lt;code&gt;.filter&lt;/code&gt; , &lt;code&gt;.reduce&lt;/code&gt; 이제 반복 기능에서 약속과 thenables를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9b88079f4caa0345add2b49d7a0be51ed016806" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;.then()&lt;/code&gt;, but any unhandled rejection that ends up here will be thrown as an error. Again, only the variant with the progression handler is deprecated here. &lt;code&gt;.done&lt;/code&gt; is still fully supported.</source>
          <target state="translated">마찬가지로 &lt;code&gt;.then()&lt;/code&gt; , 그러나 여기에서 끝까지가 오류로 발생합니다 것을 처리되지 않은 거부. 여기서도 프로그레시브 핸들러가있는 변형 만 더 이상 사용되지 않습니다. &lt;code&gt;.done&lt;/code&gt; 은 여전히 ​​완벽하게 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="eaab59843408be17f1182d2a7ba7d498c9751120" translate="yes" xml:space="preserve">
          <source>Like calling &lt;code&gt;.then&lt;/code&gt;, but the fulfillment value &lt;em&gt;must be&lt;/em&gt; an array, which is flattened to the formal parameters of the fulfillment handler.</source>
          <target state="translated">&lt;code&gt;.then&lt;/code&gt; 을 호출하는 것과 같지만 이행 값 &lt;em&gt;은&lt;/em&gt; 이행 핸들러의 형식 매개 변수로 병합되는 배열 &lt;em&gt;이어야&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="4d46fec21cdff120fbce1d5c81043ed187891e17" translate="yes" xml:space="preserve">
          <source>Local rejection events</source>
          <target state="translated">지역 거부 이벤트</target>
        </trans-unit>
        <trans-unit id="57003616863fe634c645e342ee9080681e419c5f" translate="yes" xml:space="preserve">
          <source>Logging</source>
          <target state="translated">Logging</target>
        </trans-unit>
        <trans-unit id="25c9bdc07ce0dfdf61f61c6ce40dbedeb1c6dd8e" translate="yes" xml:space="preserve">
          <source>Logging after the promise became GCd (requires a native node.js module)</source>
          <target state="translated">약속이 GCd가 된 후 로깅 (기본 node.js 모듈 필요)</target>
        </trans-unit>
        <trans-unit id="44413342754143aa1961f15d95ef6db04a6b6098" translate="yes" xml:space="preserve">
          <source>Long stack traces</source>
          <target state="translated">긴 스택 추적</target>
        </trans-unit>
        <trans-unit id="4d0119ac596cae5eba4e7c9ece07c3d282260f3e" translate="yes" xml:space="preserve">
          <source>Long stack traces are enabled by default in the debug build.</source>
          <target state="translated">긴 스택 추적은 디버그 빌드에서 기본적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5585738e86f015af086921d0b41e009a6fb65e3d" translate="yes" xml:space="preserve">
          <source>Long stack traces are only supported in Chrome, recent Firefoxes and Internet Explorer 10+</source>
          <target state="translated">긴 스택 추적은 Chrome, 최신 Firefox 및 Internet Explorer 10 이상에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="9aba1e438bce5b03f5ff76a06150c5afd0f112d5" translate="yes" xml:space="preserve">
          <source>Long stack traces are supported now in IE10+</source>
          <target state="translated">IE10 +에서 긴 스택 추적이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="0d4e72958bdd71df94bdc91c2471299f772d9de9" translate="yes" xml:space="preserve">
          <source>Long stack traces have been re-designed. They are now much more readable, succint, relevant and consistent across bluebird features.</source>
          <target state="translated">긴 스택 추적이 다시 설계되었습니다. 이제는 블루 버드 기능에서 훨씬 더 읽기 쉽고 간결하며 관련성 및 일관성이 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="4d32bb2f1ca24d68c701d853a17b879746200c1e" translate="yes" xml:space="preserve">
          <source>Major debuggability improvements:</source>
          <target state="translated">주요 디버깅 가능성 향상 :</target>
        </trans-unit>
        <trans-unit id="4e7cd8e3e2364f713fb55eb6da548439b6487c93" translate="yes" xml:space="preserve">
          <source>Major internal refactoring related to testing code and source code file layout</source>
          <target state="translated">테스트 코드 및 소스 코드 파일 레이아웃과 관련된 주요 내부 리팩토링</target>
        </trans-unit>
        <trans-unit id="7d05db1f390d07e6c3780eb841599459e0bc86db" translate="yes" xml:space="preserve">
          <source>Make .race() and Promise.race() forever pending on empty collections</source>
          <target state="translated">빈 컬렉션에 .race () 및 Promise.race ()를 계속 보류</target>
        </trans-unit>
        <trans-unit id="f545f488c8e51d1bcb95f6e96e06f76a78762db7" translate="yes" xml:space="preserve">
          <source>Make build script's output work without TTY</source>
          <target state="translated">TTY없이 빌드 스크립트의 출력 작업</target>
        </trans-unit>
        <trans-unit id="6de105dd31451a68ffa7b10edcdad659c72911a0" translate="yes" xml:space="preserve">
          <source>Make progress a core feature. Fixes &lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/535&quot;&gt;&lt;code&gt;#535&lt;/code&gt;&lt;/a&gt; Note that progress has been removed in 3.x - this is only a fix necessary for 2.x custom builds.</source>
          <target state="translated">진행을 핵심 기능으로 만듭니다. 수정 사항 &lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/535&quot;&gt; &lt;code&gt;#535&lt;/code&gt; &lt;/a&gt; 진행률이 3.x에서 제거되었습니다. 이것은 2.x 사용자 지정 빌드에 필요한 수정 사항 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="d25de34f144aaa815f7ee100219c0875ec327f00" translate="yes" xml:space="preserve">
          <source>Make tests pass Internet Explorer 8</source>
          <target state="translated">Internet Explorer 8을 통과 한 테스트</target>
        </trans-unit>
        <trans-unit id="2ae67022300ef1cd200bf479b96deb439531bc00" translate="yes" xml:space="preserve">
          <source>Managing resources properly without leaks can be challenging. Simply using &lt;code&gt;.finally&lt;/code&gt; is not enough as the following example demonstrates:</source>
          <target state="translated">누출없이 자원을 올바르게 관리하는 것은 어려울 수 있습니다. 다음 예제에서 볼 수 있듯이 &lt;code&gt;.finally&lt;/code&gt; 를 사용하는 것만으로 는 충분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="107b1032597492e8483d652c4a4ce608f171eba8" translate="yes" xml:space="preserve">
          <source>Map Option: concurrency</source>
          <target state="translated">지도 옵션 : 동시성</target>
        </trans-unit>
        <trans-unit id="a50a46e16b741d58429e4aa0f944bc0391ee46f8" translate="yes" xml:space="preserve">
          <source>Methods of &lt;code&gt;Promise&lt;/code&gt; instances and core static methods of the Promise class to deal with collections of promises or mixed promises and values.</source>
          <target state="translated">Promise 클래스 의 &lt;code&gt;Promise&lt;/code&gt; 인스턴스 및 핵심 정적 메소드는 약속 또는 혼합 된 약속 및 값의 모음을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="ae38184c5e1cc02a77f22646c0e9e6fb64bf94fd" translate="yes" xml:space="preserve">
          <source>Methods on &lt;code&gt;Function.prototype&lt;/code&gt; are no longer promisified (&lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/680&quot;&gt;&lt;code&gt;#680&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;Function.prototype&lt;/code&gt; 의 메소드 는 더 이상 약속되지 않습니다 ( &lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/680&quot;&gt; &lt;code&gt;#680&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="af7ee6528f585594a5d8dbab3c9c2ad5078d7461" translate="yes" xml:space="preserve">
          <source>Minified source file meant to be used in production. Warnings and long straces are disabled. The gzipped size is 17.76KB.</source>
          <target state="translated">프로덕션에 사용하기 위해 축소 된 소스 파일. 경고 및 긴 변형이 비활성화됩니다. zip 크기는 17.76KB입니다.</target>
        </trans-unit>
        <trans-unit id="cddf33528c938c1495240e1ee5dc6ea07a8ea077" translate="yes" xml:space="preserve">
          <source>Misc:</source>
          <target state="translated">Misc:</target>
        </trans-unit>
        <trans-unit id="cbb2eaaf602b7e2cec410e3a49e5f52907359976" translate="yes" xml:space="preserve">
          <source>Mongoose works with persistent connections and the driver takes care of reconnections/disposals. For this reason using &lt;code&gt;using&lt;/code&gt; with it isn't required - instead connect on server startup and use promisification to expose promises.</source>
          <target state="translated">몽구스는 지속적인 연결로 작동하며 드라이버는 재 연결 / 처리를 처리합니다. 이러한 이유로 함께 사용 &lt;code&gt;using&lt;/code&gt; 것은 필요하지 않습니다. 대신 서버 시작시 연결하고 약속을 사용하여 약속을 노출하십시오.</target>
        </trans-unit>
        <trans-unit id="bc8341442a59c4454f469778737b7b06e02ad229" translate="yes" xml:space="preserve">
          <source>Mongoose/MongoDB</source>
          <target state="translated">Mongoose/MongoDB</target>
        </trans-unit>
        <trans-unit id="331f3f9f6d3697a3169ac32b4263f8b1778c3e97" translate="yes" xml:space="preserve">
          <source>More Common Examples</source>
          <target state="translated">더 일반적인 예</target>
        </trans-unit>
        <trans-unit id="5623f76074955ea9ab1db3ab04c9bff15d87a6c2" translate="yes" xml:space="preserve">
          <source>More common examples</source>
          <target state="translated">더 일반적인 예</target>
        </trans-unit>
        <trans-unit id="eb77d4b0690c471c302bf76046f4c7afa76f3db6" translate="yes" xml:space="preserve">
          <source>More performance improvements when long stack traces are enabled</source>
          <target state="translated">긴 스택 추적을 사용하는 경우 성능 향상</target>
        </trans-unit>
        <trans-unit id="3a7a86c3c7bb6f061ed4b7dd4612a07ea2e55494" translate="yes" xml:space="preserve">
          <source>More reading:</source>
          <target state="translated">더 많은 독서 :</target>
        </trans-unit>
        <trans-unit id="deaa0c393a6613972aaccbf1fecfdad67aa21e88" translate="yes" xml:space="preserve">
          <source>MySQL</source>
          <target state="translated">MySQL</target>
        </trans-unit>
        <trans-unit id="63cd8ad40499d81ac4cfa72cb023f0f0e2a46fc4" translate="yes" xml:space="preserve">
          <source>New in bluebird 3.0</source>
          <target state="translated">블루 버드 3.0의 새로운 기능</target>
        </trans-unit>
        <trans-unit id="4c06116ec441fcbe51fa98c044bc02e5a87998c7" translate="yes" xml:space="preserve">
          <source>New method: &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#promiseonunhandledrejectionhandledfunction-handler---undefined&quot;&gt;&lt;code&gt;Promise.onUnhandledRejectionHandled()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">새로운 방법 : &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#promiseonunhandledrejectionhandledfunction-handler---undefined&quot;&gt; &lt;code&gt;Promise.onUnhandledRejectionHandled()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="98ef7df279344d4e364f9fc4312d95513017e539" translate="yes" xml:space="preserve">
          <source>New method: &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#reason---dynamic&quot;&gt;&lt;code&gt;.reason()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">새로운 방법 : &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#reason---dynamic&quot;&gt; &lt;code&gt;.reason()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7244a976bd562fa5bdab260bfa92ffb53b2f75df" translate="yes" xml:space="preserve">
          <source>New method: &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#value---dynamic&quot;&gt;&lt;code&gt;.value()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">새로운 방법 : &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#value---dynamic&quot;&gt; &lt;code&gt;.value()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3e97753de8b2fb704fe13fb56eee1b6956901e28" translate="yes" xml:space="preserve">
          <source>Node environment detection can no longer be fooled</source>
          <target state="translated">더 이상 노드 환경 감지를 속일 수 없습니다</target>
        </trans-unit>
        <trans-unit id="36f139c394850c9c9489f54e55411c65c03b1e5e" translate="yes" xml:space="preserve">
          <source>Node installation</source>
          <target state="translated">노드 설치</target>
        </trans-unit>
        <trans-unit id="10b3493287f831e81a438811a1ffba01f8cec4b7" translate="yes" xml:space="preserve">
          <source>Node.js</source>
          <target state="translated">Node.js</target>
        </trans-unit>
        <trans-unit id="973a79d67e462fcd740058903de5ac75c5e42ed4" translate="yes" xml:space="preserve">
          <source>Node.js performance: promisified functions try to check amount of passed arguments in most optimal order</source>
          <target state="translated">Node.js 성능 : 약속 된 함수는 전달 된 인수의 양을 가장 최적의 순서로 확인하려고합니다.</target>
        </trans-unit>
        <trans-unit id="21d569f35ecd5c10a6a6f1ab8aec8e1753640885" translate="yes" xml:space="preserve">
          <source>Node.js promisified functions will have same &lt;code&gt;.length&lt;/code&gt; as the original function minus one (for the callback parameter)</source>
          <target state="translated">Node.js 약속 함수는 원래 함수에서 1을 뺀 것과 같은 &lt;code&gt;.length&lt;/code&gt; 를 갖습니다 (콜백 매개 변수의 경우)</target>
        </trans-unit>
        <trans-unit id="6c8c6cfa65668d483f7a4b264c38fc353e937af3" translate="yes" xml:space="preserve">
          <source>Nodeify doesn't pass second argument to the callback if the promise is fulfilled with &lt;code&gt;undefined&lt;/code&gt;</source>
          <target state="translated">약속이 &lt;code&gt;undefined&lt;/code&gt; 경우 Nodeify는 콜백에 두 번째 인수를 전달하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b5673141cf57847c5379b8f84249704a24a566a4" translate="yes" xml:space="preserve">
          <source>None of the collection methods modify the original input. Holes in arrays are treated as if they were defined with the value &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">수집 방법 중 어느 것도 원래 입력을 수정하지 않습니다. 배열의 구멍은 값이 &lt;code&gt;undefined&lt;/code&gt; 로 정의 된 것처럼 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="7e35ac0a9b7c71da68e4e0db0a51a9c2cf39da4d" translate="yes" xml:space="preserve">
          <source>Normal callbacks:</source>
          <target state="translated">일반적인 콜백 :</target>
        </trans-unit>
        <trans-unit id="0d7e35c7b10d9ccf8a2e395ca44cbdd4ab1c9fb3" translate="yes" xml:space="preserve">
          <source>Normally stack traces don't go beyond asynchronous boundaries so their utility is greatly reduced in asynchronous code:</source>
          <target state="translated">일반적으로 스택 추적은 비동기 경계를 넘어 가지 않으므로 비동기 코드에서 유틸리티가 크게 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="5bbef690c10dd98cdafb9fad511260630850d165" translate="yes" xml:space="preserve">
          <source>Not only is the code shorter but more importantly, if there is any error it will propagate properly to the final consumer.</source>
          <target state="translated">코드가 짧을뿐만 아니라 오류가있을 경우 최종 소비자에게 올바르게 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="601e20ca34667b0a121fe532f625d50ac9e32a89" translate="yes" xml:space="preserve">
          <source>Note - in order to get full stack traces with warnings in Node 6.x+ you need to enable to &lt;code&gt;--trace-warnings&lt;/code&gt; flag which will give you a full stack trace of where the warning is coming from.</source>
          <target state="translated">참고 &lt;code&gt;--trace-warnings&lt;/code&gt; 6.x +에서 경고가 포함 된 전체 스택 추적을 얻으려면 --trace-warnings 플래그 를 활성화 하여 경고가 발생한 위치에 대한 전체 스택 추적을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="14f4f32d734d4dde2357de9c28aa2e9db4f442b8" translate="yes" xml:space="preserve">
          <source>Note about disposers in node</source>
          <target state="translated">노드의 디스 포저에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="628368b01a8c147d7adbe65259137f54770d74df" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;spread&quot;&gt;&lt;code&gt;.spread()&lt;/code&gt;&lt;/a&gt; implicitly does &lt;a href=&quot;all&quot;&gt;&lt;code&gt;.all()&lt;/code&gt;&lt;/a&gt; but the ES6 destructuring syntax doesn't, hence the manual &lt;code&gt;.all()&lt;/code&gt; call in the above code.</source>
          <target state="translated">참고 &lt;a href=&quot;spread&quot;&gt; &lt;code&gt;.spread()&lt;/code&gt; &lt;/a&gt; 암시하지 &lt;a href=&quot;all&quot;&gt; &lt;code&gt;.all()&lt;/code&gt; &lt;/a&gt; 하지만 ES6의 destructuring 구문하지 않습니다, 따라서 수동 &lt;code&gt;.all()&lt;/code&gt; 위의 코드에서 호출.</target>
        </trans-unit>
        <trans-unit id="4f4cc52a9da922cd3c5be1d218aeb2480ead589e" translate="yes" xml:space="preserve">
          <source>Note that Mongoose already ships with promise support but the promises it offers are significantly slower and don't report unhandled rejections so it is recommended to use automatic promisification with it anyway:</source>
          <target state="translated">Mongoose는 이미 약속 지원을 제공하지만 제공되는 약속은 상당히 느리고 처리되지 않은 거부를보고하지 않으므로 어쨌든 자동 약속을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="29e8a3550207f0693fbe258a0b408370b65284bd" translate="yes" xml:space="preserve">
          <source>Note that bind is only propagated with promise transformation. If you create new promise chains inside a handler, those chains are not bound to the &quot;upper&quot; &lt;code&gt;this&lt;/code&gt;:</source>
          <target state="translated">바인드는 약속 변환으로 만 전파됩니다. 당신이 핸들러 안에 새로운 약속 체인을 작성하는 경우, 그 체인은 &quot;위&quot;에 바인딩되지 않습니다 &lt;code&gt;this&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e18ae6fc287a535de54a7ef47226f40baba44a5f" translate="yes" xml:space="preserve">
          <source>Note that if the node function is a method of some object, you can pass the object as the second argument like so:</source>
          <target state="translated">노드 함수가 일부 객체의 메소드 인 경우 다음과 같이 객체를 두 번째 인수로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="049b2f103da24d1cdf9b651db0f13464d2a62368" translate="yes" xml:space="preserve">
          <source>Note that if using ES6, the above can be replaced with &lt;a href=&quot;then&quot;&gt;&lt;code&gt;.then()&lt;/code&gt;&lt;/a&gt; and destructuring:</source>
          <target state="translated">ES6을 사용하는 경우 위의 내용을 &lt;a href=&quot;then&quot;&gt; &lt;code&gt;.then()&lt;/code&gt; &lt;/a&gt; 으로 대체 하고 파괴 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e0a368b621b24c61956a2d40d7353ec38ebe9f4e" translate="yes" xml:space="preserve">
          <source>Note that if you have no use for the result object other than retrieving the properties, it is more convenient to use &lt;a href=&quot;promise.join&quot;&gt;&lt;code&gt;Promise.join&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">속성을 검색하는 것 이외의 결과 개체를 사용하지 않는 경우 &lt;a href=&quot;promise.join&quot;&gt; &lt;code&gt;Promise.join&lt;/code&gt; &lt;/a&gt; 을 사용하는 것이 더 편리합니다 .</target>
        </trans-unit>
        <trans-unit id="3de0bd0db4f60bc1b355d5d97bda28262272a5e5" translate="yes" xml:space="preserve">
          <source>Note that it is an error to consume an already cancelled promise, doing such a thing will give you a promise that is rejected with &lt;code&gt;new CancellationError(&quot;late cancellation observer&quot;)&lt;/code&gt; as the rejection reason.</source>
          <target state="translated">이미 취소 된 약속을 사용하는 것은 오류입니다. 이러한 작업을 수행 하면 거부 사유로 &lt;code&gt;new CancellationError(&quot;late cancellation observer&quot;)&lt;/code&gt; cancel observer&quot;) 를 사용하여 거부 된 약속이 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="7fba6dfbb297631502284b27e815e4abd333271d" translate="yes" xml:space="preserve">
          <source>Note that promises model a &lt;em&gt;single value through time&lt;/em&gt;, they only resolve &lt;em&gt;once&lt;/em&gt; - so while they're a good fit for a single event, they are not recommended for multiple event APIs.</source>
          <target state="translated">약속 &lt;em&gt;은 시간이 지남에&lt;/em&gt; 따라 &lt;em&gt;단일 값을&lt;/em&gt; 약속하며 &lt;em&gt;한 &lt;/em&gt;&lt;em&gt;번만&lt;/em&gt; 해결 되므로 단일 이벤트에 적합하지만 여러 이벤트 API에는 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6c0a18493f92a9cdbebf344b13ce97703f7982f1" translate="yes" xml:space="preserve">
          <source>Note that the 3.0.1 update is strictly speaking backward-incompatible with 3.0.0. Version 3.0.0 changed the previous behavior of the &lt;code&gt;.each&lt;/code&gt; method and made it work more same as the new &lt;code&gt;.mapSeries&lt;/code&gt; - 3.0.1 unrolls this change by reverting to the &lt;code&gt;.tap&lt;/code&gt;-like behavior found in 2.x However, this would only affect users who updated to 3.0.0 during the short time that it wasn't deprecated and started relying on the new &lt;code&gt;.each&lt;/code&gt; behavior. This seems unlikely, and therefore the major version was not changed.</source>
          <target state="translated">3.0.1 업데이트는 3.0.0과 호환되지 않습니다. 버전 3.0.0은 &lt;code&gt;.each&lt;/code&gt; 메소드 의 이전 동작을 변경했으며 새 &lt;code&gt;.mapSeries&lt;/code&gt; -3.0.1 과 동일하게 작동하도록 만들었습니다 . 2.x에서 발견 된 &lt;code&gt;.tap&lt;/code&gt; -like 동작으로 되돌려 서이 변경 사항을 해제 합니다. 더 이상 사용되지 않고 새로운 &lt;code&gt;.each&lt;/code&gt; 동작 에 의존하기 시작한 짧은 시간 동안 3.0.0으로 업데이트 한 사용자에게 영향을 미칩니다 . 이것은 거의 보이지 않으므로 주 버전은 변경되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="ddb0ec4c290533d8d13b5512c50f3aff8444246e" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;onCancel&lt;/code&gt; hook is really an optional disconnected optimization, there is no real requirement to register any cancellation hooks for cancellation to work. As such, any errors that may occur while inside the &lt;code&gt;onCancel&lt;/code&gt; callback are not caught and turned into rejections.</source>
          <target state="translated">점을 유의 &lt;code&gt;onCancel&lt;/code&gt; 작업을 취소 모든 취소 훅을 등록 할 실제 요구 사항은 없다, 후크 정말 옵션이 끊긴 최적화입니다. 따라서 &lt;code&gt;onCancel&lt;/code&gt; 콜백 내부에서 발생할 수있는 오류 는 포착되지 않고 거부로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="1635db28b0639fbcd8af0cf2d7a5c771bbc04b90" translate="yes" xml:space="preserve">
          <source>Note that the above is an exceptional case because &lt;code&gt;fs&lt;/code&gt; is a singleton instance. Most libraries can be promisified by requiring the library's classes (constructor functions) and calling promisifyAll on the &lt;code&gt;.prototype&lt;/code&gt;. This only needs to be done once in the entire application's lifetime and after that you may use the library's methods exactly as they are documented, except by appending the &lt;code&gt;&quot;Async&quot;&lt;/code&gt;-suffix to method calls and using the promise interface instead of the callback interface.</source>
          <target state="translated">&lt;code&gt;fs&lt;/code&gt; 는 싱글 톤 인스턴스 이므로 위의 예외는 예외 입니다. 대부분의 라이브러리는 라이브러리의 클래스 (생성자 함수)를 요구하고 .prototype에서 promisifyAll을 호출하여 &lt;code&gt;.prototype&lt;/code&gt; 있습니다. 이 작업은 전체 응용 프로그램 수명 동안 한 번만 수행하면됩니다. 그런 다음 &lt;code&gt;&quot;Async&quot;&lt;/code&gt; - 접미어를 메서드 호출 에 추가 하고 콜백 인터페이스 대신 promise 인터페이스를 사용하는 것을 제외하고는 라이브러리 메서드를 문서화 된 그대로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="684fbd25281e8e786735f4d9605ff396ce6c04e1" translate="yes" xml:space="preserve">
          <source>Note that the original methods on the object are not overwritten but new methods are created with the &lt;code&gt;Async&lt;/code&gt;-suffix. For example, if you &lt;code&gt;promisifyAll&lt;/code&gt; the node.js &lt;code&gt;fs&lt;/code&gt; object use &lt;code&gt;fs.statAsync&lt;/code&gt; to call the promisified &lt;code&gt;stat&lt;/code&gt; method.</source>
          <target state="translated">개체의 원래 메서드는 덮어 쓰지 않지만 &lt;code&gt;Async&lt;/code&gt; -suffix를 사용하여 새 메서드를 만듭니다. 예를 들어, node.js &lt;code&gt;fs&lt;/code&gt; 객체 를 모두 &lt;code&gt;promisifyAll&lt;/code&gt; 하면 &lt;code&gt;fs.statAsync&lt;/code&gt; 를 사용 하여 약속 된 &lt;code&gt;stat&lt;/code&gt; 메소드 를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="8918cb785368659b0f7041103fcbbc46ea52e50b" translate="yes" xml:space="preserve">
          <source>Note that you can mix promises and disposers, so that you can acquire all the things you need in parallel instead of sequentially</source>
          <target state="translated">약속과 Disposers를 혼합하여 필요한 것이 아니라 순차적으로 필요한 모든 것을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2203e249f5db0b7bf8e8cc90b06047ef5edc44d9" translate="yes" xml:space="preserve">
          <source>Note the new method is suffixed with &lt;code&gt;Async&lt;/code&gt;, as in &lt;code&gt;fs.readFileAsync&lt;/code&gt;. It did not replace the &lt;code&gt;fs.readFile&lt;/code&gt; function. Single functions can also be promisified for example:</source>
          <target state="translated">새로운 방법은 접미사 참고 &lt;code&gt;Async&lt;/code&gt; 같이 &lt;code&gt;fs.readFileAsync&lt;/code&gt; . &lt;code&gt;fs.readFile&lt;/code&gt; 함수를 대체하지 않았습니다 . 예를 들어 단일 기능을 약속 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1642a8259cf0bac4672e4af1533d8b457f9d5a0" translate="yes" xml:space="preserve">
          <source>Notice that use of &lt;code&gt;return this;&lt;/code&gt; in most of the functions? That pattern will allow method chaining as you'll see shortly.</source>
          <target state="translated">를 사용 &lt;code&gt;return this;&lt;/code&gt; 대부분의 기능에서? 이 패턴은 곧 보게 될 메소드 체인을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="28b7a468a3970ae2784b6d1486ec7ed0a21533b5" translate="yes" xml:space="preserve">
          <source>Now if someone uses this function, they will catch all errors in their Promise &lt;code&gt;.catch&lt;/code&gt; handlers instead of having to handle both synchronous and asynchronous exception flows.</source>
          <target state="translated">이제 &lt;code&gt;.catch&lt;/code&gt; 함수를 사용하면 동기 및 비동기 예외 흐름을 처리 할 필요없이 Promise .catch 처리기 에서 모든 오류를 포착합니다 .</target>
        </trans-unit>
        <trans-unit id="ae7be4be424720d6a240c42d8e70d90f0de37f8e" translate="yes" xml:space="preserve">
          <source>Now the animation is hidden but, unless it throws an exception, the function has no effect on the fulfilled or rejected value of the returned promise. This is similar to how the synchronous &lt;code&gt;finally&lt;/code&gt; keyword behaves.</source>
          <target state="translated">이제 애니메이션이 숨겨 지지만 예외가 발생하지 않는 한 함수는 반환 된 약속의 이행 또는 거부 된 값에 영향을 미치지 않습니다. 이것은 동 기적 &lt;code&gt;finally&lt;/code&gt; 키워드의 작동 방식과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="fdea957426d725edc153e2fdbdd6516cd7a9e40a" translate="yes" xml:space="preserve">
          <source>Now to the fun part. For this tutorial we will &lt;em&gt;fake&lt;/em&gt; a lengthy file upload by using &lt;code&gt;setTimeout&lt;/code&gt;. The intent is to provide a promise and to allow a progress to be periodically ticked away. We will expect a function to be passed which is called whenever the progress needs updating. And it returns a promise.</source>
          <target state="translated">이제 재미있는 부분입니다. 이 튜토리얼에서는 &lt;code&gt;setTimeout&lt;/code&gt; 을 사용하여 긴 파일 업로드를 &lt;em&gt;위조&lt;/em&gt; 합니다 . 의도는 약속을 제공하고 진행 상황을 주기적으로 똑딱 거리게하는 것입니다. 진행 상황을 업데이트해야 할 때마다 호출되는 함수가 전달 될 것으로 예상합니다. 그리고 약속을 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="f511b5b4eefa1fbd39717d9bca91d08c89eb55c8" translate="yes" xml:space="preserve">
          <source>Now we can add a &lt;code&gt;cancel()&lt;/code&gt; reject with this in our event listener:</source>
          <target state="translated">이제 이벤트 리스너에서 &lt;code&gt;cancel()&lt;/code&gt; 거부를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dd58dca3cb5c00590780331e30aa954b4d6ecb97" translate="yes" xml:space="preserve">
          <source>Now when the user presses the &lt;strong&gt;Set Name&lt;/strong&gt; button the clock continues to update while the dialog is visible.</source>
          <target state="translated">이제 사용자가 &lt;strong&gt;이름 설정&lt;/strong&gt; 버튼을 누르면 대화 상자가 보이는 동안 시계가 계속 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="c1c4edbd07c221b59e680f6880827ab56a3c246a" translate="yes" xml:space="preserve">
          <source>Now, because there is no catch-all handler, if you typed &lt;code&gt;console.lag&lt;/code&gt; (causes an error you don't expect), you will see:</source>
          <target state="translated">이제 catch-all 핸들러가 없으므로 &lt;code&gt;console.lag&lt;/code&gt; 를 입력 하면 (예상치 못한 오류가 발생 함) 다음과 같은 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="9cf4af30df052d80876381f9ec0e05811ecd3d08" translate="yes" xml:space="preserve">
          <source>Objective-C</source>
          <target state="translated">Objective-C</target>
        </trans-unit>
        <trans-unit id="d1d56bab874d88dafd718a2b7e212040a9f0e45f" translate="yes" xml:space="preserve">
          <source>Of course you could use hacks like monkey patching or domains but these break down when something can't be monkey patched or new apis are introduced.</source>
          <target state="translated">물론 원숭이 패치 또는 도메인과 같은 핵을 사용할 수 있지만 원숭이 패치를 할 수 없거나 새로운 api가 도입되면 이러한 것들이 손상됩니다.</target>
        </trans-unit>
        <trans-unit id="f9466283542f875b75d8d6a69434fd428fb07f65" translate="yes" xml:space="preserve">
          <source>Often browser APIs are nonstandard and automatic promisification will fail for them. If you're running into an API that you can't promisify with &lt;a href=&quot;api/promisify&quot;&gt;&lt;code&gt;promisify&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;api/promisifyall&quot;&gt;&lt;code&gt;promisifyAll&lt;/code&gt;&lt;/a&gt; - please consult the &lt;a href=&quot;#working-with-any-other-apis&quot;&gt;working with other APIs section&lt;/a&gt;</source>
          <target state="translated">종종 브라우저 API는 비표준이며 자동 약속이 실패합니다. 당신은 당신이 promisify 수 없다는 API로 실행중인 경우 &lt;a href=&quot;api/promisify&quot;&gt; &lt;code&gt;promisify&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;api/promisifyall&quot;&gt; &lt;code&gt;promisifyAll&lt;/code&gt; &lt;/a&gt; - 문의를하시기 바랍니다 &lt;a href=&quot;#working-with-any-other-apis&quot;&gt;다른 API 섹션으로 작업을&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="09c49c4361b267a50eb7359cfbbb3c119709f70d" translate="yes" xml:space="preserve">
          <source>Often it is known in certain code paths that a promise is guaranteed to be fulfilled at that point - it would then be extremely inconvenient to use &lt;a href=&quot;api/then&quot;&gt;&lt;code&gt;.then&lt;/code&gt;&lt;/a&gt; to get at the promise's value as the callback is always called asynchronously.</source>
          <target state="translated">종종 특정 코드 경로에서 약속이 그 시점에 이행되도록 보장되는 것으로 알려져 있습니다 . 콜백이 항상 비동기 적으로 호출되므로 약속의 가치를 얻는 데 &lt;a href=&quot;api/then&quot;&gt; &lt;code&gt;.then&lt;/code&gt; &lt;/a&gt; 을 사용하는 것이 매우 불편합니다 .</target>
        </trans-unit>
        <trans-unit id="ba70c55cb182e14f7aec5abbfd219d10161351d3" translate="yes" xml:space="preserve">
          <source>Often it is known in certain code paths that a promise is guaranteed to be fulfilled at that point - it would then be extremely inconvenient to use &lt;a href=&quot;then&quot;&gt;&lt;code&gt;.then&lt;/code&gt;&lt;/a&gt; to get at the promise's value as the callback is always called asynchronously.</source>
          <target state="translated">종종 특정 코드 경로에서 약속이 그 시점에 이행되도록 보장되는 것으로 알려져 있습니다 . 콜백이 항상 비동기 적으로 호출되므로 약속의 가치를 얻는 데 &lt;a href=&quot;then&quot;&gt; &lt;code&gt;.then&lt;/code&gt; &lt;/a&gt; 을 사용하는 것이 매우 불편합니다 .</target>
        </trans-unit>
        <trans-unit id="fb455bed4997b8d29dbd05a23ac828990139aad3" translate="yes" xml:space="preserve">
          <source>Old Promise Cancellation</source>
          <target state="translated">구약 취소</target>
        </trans-unit>
        <trans-unit id="c2882dbf534ae9b61f7574e530dc35a635e26a00" translate="yes" xml:space="preserve">
          <source>On client side, long stack traces currently only work in recent Firefoxes, Chrome and Internet Explorer 10+.</source>
          <target state="translated">클라이언트 측에서 긴 스택 추적은 현재 최신 Firefox, Chrome 및 Internet Explorer 10 이상에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="4e5a14a36dfaaeaed4f8ef85cfc8efef0579501d" translate="yes" xml:space="preserve">
          <source>One could solve this by either reading the file first or connecting first, and only proceeding if the first step succeeds. However, this would lose a lot of the benefits of using asynchronity and we might almost as well go back to using simple synchronous code.</source>
          <target state="translated">파일을 먼저 읽거나 먼저 연결하고 첫 번째 단계가 성공한 경우에만 진행하여이 문제를 해결할 수 있습니다. 그러나 이것은 비동기 성을 사용하면 많은 이점을 잃게되며 간단한 동기 코드를 사용하는 것으로 거의 되돌아 갈 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d2c6e796751446bf03d009641c4f94308285962" translate="yes" xml:space="preserve">
          <source>One possible cause is using &lt;code&gt;.indexOf&lt;/code&gt; which returns &lt;code&gt;-1&lt;/code&gt; when it doesn't find the value being searched for.</source>
          <target state="translated">가능한 원인 중 하나는 &lt;code&gt;.indexOf&lt;/code&gt; 를 사용하여 검색중인 값을 찾지 못하면 &lt;code&gt;-1&lt;/code&gt; 을 반환 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3bebf09d62dbf5ff3d0ee7b594d24983d9fecce2" translate="yes" xml:space="preserve">
          <source>OperationalError</source>
          <target state="translated">OperationalError</target>
        </trans-unit>
        <trans-unit id="5b01979a9cdca6e73817895c6a9c23e60230c14d" translate="yes" xml:space="preserve">
          <source>OperationalError()</source>
          <target state="translated">OperationalError()</target>
        </trans-unit>
        <trans-unit id="104370c5891b8b4ba98b88fdedf6b3dd37566a91" translate="yes" xml:space="preserve">
          <source>Option: filter</source>
          <target state="translated">옵션 : 필터</target>
        </trans-unit>
        <trans-unit id="fd4d82f7dc12888a6113e02d99a1cd1ae6480faa" translate="yes" xml:space="preserve">
          <source>Option: multiArgs</source>
          <target state="translated">옵션 : multiArgs</target>
        </trans-unit>
        <trans-unit id="c7fb7b92da5e81c452b72cf73b9e7e606a4be8c6" translate="yes" xml:space="preserve">
          <source>Option: promisifier</source>
          <target state="translated">옵션 : 약속</target>
        </trans-unit>
        <trans-unit id="739bd13df9b75cbacc926456c2659db41a7a2e16" translate="yes" xml:space="preserve">
          <source>Option: spread</source>
          <target state="translated">옵션 : 스프레드</target>
        </trans-unit>
        <trans-unit id="c86f01917e960f8cf0838c6de23ce3408a649b20" translate="yes" xml:space="preserve">
          <source>Option: suffix</source>
          <target state="translated">옵션 : 접미사</target>
        </trans-unit>
        <trans-unit id="ad34d2a8ce003a253f94ae6e4eb935a9468f0f43" translate="yes" xml:space="preserve">
          <source>Optionally, you can define a custom filter through the options object:</source>
          <target state="translated">선택적으로 options 객체를 통해 사용자 정의 필터를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8110acd1b3d0f8ca4e9e279edf4604f42dc6b48b" translate="yes" xml:space="preserve">
          <source>Optionally, you can define a custom promisifier, so you could promisifyAll e.g. the chrome APIs used in Chrome extensions.</source>
          <target state="translated">선택적으로 맞춤식 약속을 정의 할 수 있으므로 Chrome 확장 프로그램에 사용되는 크롬 API 등 모든 것을 약속 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="889a0e5ec1b3411c0cd35c6e73319943162df789" translate="yes" xml:space="preserve">
          <source>Optionally, you can define a custom suffix through the options object:</source>
          <target state="translated">선택적으로 options 객체를 통해 사용자 정의 접미사를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d850b7adaa397dfa33c1141f5bb572b4b4cee8d2" translate="yes" xml:space="preserve">
          <source>Or to use &lt;a href=&quot;api/promise.coroutine.addyieldhandler&quot;&gt;&lt;code&gt;Promise.coroutine.addYieldHandler`&lt;/code&gt;&lt;/a&gt; to teach &lt;a href=&quot;api/promise.coroutine&quot;&gt;&lt;code&gt;Promise.coroutine&lt;/code&gt;&lt;/a&gt; to accept these sort of values.</source>
          <target state="translated">또는 사용하는 &lt;a href=&quot;api/promise.coroutine.addyieldhandler&quot;&gt; &lt;code&gt;Promise.coroutine.addYieldHandler`&lt;/code&gt; 을&lt;/a&gt; 가르치는 &lt;a href=&quot;api/promise.coroutine&quot;&gt; &lt;code&gt;Promise.coroutine&lt;/code&gt; &lt;/a&gt; 값이 종류에 동의.</target>
        </trans-unit>
        <trans-unit id="24ea190190a1068b342fd38d88b87afd5b7878ff" translate="yes" xml:space="preserve">
          <source>Or you could take advantage of the fact that if we reach password validation, then the user promise must be fulfilled:</source>
          <target state="translated">또는 비밀번호 확인에 도달하면 사용자 약속을 이행해야한다는 사실을 활용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b17d6ff961144643224165079cbd11a9c6bc25a" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;PromptDialog&lt;/code&gt; class is responsible for inheriting from &lt;code&gt;Dialog&lt;/code&gt; and setting up the required DOM scaffolding and eventually call &lt;code&gt;this._okCallback&lt;/code&gt; or &lt;code&gt;this._cancelCallback&lt;/code&gt; as appropriate.</source>
          <target state="translated">우리의 &lt;code&gt;PromptDialog&lt;/code&gt; 클래스는 &lt;code&gt;Dialog&lt;/code&gt; 에서 상속 하고 필요한 DOM 스캐 폴딩을 설정하고 결국 &lt;code&gt;this._okCallback&lt;/code&gt; 또는 &lt;code&gt;this._cancelCallback&lt;/code&gt; 을 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="57cb5629649d7407a80d8544726571004c96c657" translate="yes" xml:space="preserve">
          <source>PascalCase the suffix</source>
          <target state="translated">접미사 파스칼</target>
        </trans-unit>
        <trans-unit id="feee47953c269413e18b8e3f8b2d28f42be54e4a" translate="yes" xml:space="preserve">
          <source>Pass a handler that will be called regardless of this promise's fate. Returns a new promise chained from this promise. There are special semantics for &lt;a href=&quot;finally&quot;&gt;&lt;code&gt;.finally&lt;/code&gt;&lt;/a&gt; in that the final value cannot be modified from the handler.</source>
          <target state="translated">이 약속의 운명에 관계없이 호출 될 핸들러를 전달하십시오. 이 약속과 연결된 새로운 약속을 반환합니다. 처리기에서 최종 값을 수정할 수 없다는 점에서 &lt;a href=&quot;finally&quot;&gt; &lt;code&gt;.finally&lt;/code&gt; &lt;/a&gt; 에 대한 특수 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b4b02b67bed0ffe4b0b1b17a183e58f6d178ecc" translate="yes" xml:space="preserve">
          <source>Pass it a constructor that inherits from &lt;code&gt;Error&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Error&lt;/code&gt; 에서 상속받은 생성자를 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="ef62afb0d13c7501004b9f7402ac0fe34f1df36d" translate="yes" xml:space="preserve">
          <source>Passing no value or a non-function will have the effect of removing any kind of handling for possibly unhandled rejections.</source>
          <target state="translated">값이 없거나 기능이 없으면 전달되지 않은 거부에 대한 처리를 제거하는 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="14a1550a1e49d7c4df7b61809151dec155b9464f" translate="yes" xml:space="preserve">
          <source>Performance improvements when long stack traces are enabled</source>
          <target state="translated">긴 스택 추적을 사용하는 경우 성능 향상</target>
        </trans-unit>
        <trans-unit id="f6d83e264c56100a2c68d859c185e245cdf12d6c" translate="yes" xml:space="preserve">
          <source>Perhaps the greatest thing about promises is that it unifies all error handling into one mechanism where errors propagate automatically and have to be explicitly ignored.</source>
          <target state="translated">아마도 약속에서 가장 큰 것은 오류를 자동으로 전파하고 명시 적으로 무시해야하는 하나의 메커니즘으로 모든 오류 처리를 통합한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="13bc9fc907ba93237d886bb7661f405dca851032" translate="yes" xml:space="preserve">
          <source>Playing with the first example with and without limits, and seeing how it affects the duration when reading 20 files:</source>
          <target state="translated">제한이 있거나없는 첫 번째 예제로 재생하고 20 개의 파일을 읽을 때 지속 시간에 어떤 영향을 미치는지 확인 :</target>
        </trans-unit>
        <trans-unit id="5e982889494e481131cdc4a0b26924bfa22d7d53" translate="yes" xml:space="preserve">
          <source>Please consider reading about &lt;a href=&quot;api/new-promise&quot;&gt;&lt;code&gt;new Promise&lt;/code&gt;&lt;/a&gt; and also consider checking out automatic &lt;a href=&quot;api/promisification&quot;&gt;&lt;code&gt;promisification&lt;/code&gt;&lt;/a&gt; as well as &lt;a href=&quot;api/promise.method&quot;&gt;&lt;code&gt;Promise.method&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;api/new-promise&quot;&gt; &lt;code&gt;new Promise&lt;/code&gt; &lt;/a&gt; 에 대해 읽고 &lt;a href=&quot;api/promisification&quot;&gt; &lt;code&gt;promisification&lt;/code&gt; &lt;/a&gt; 뿐만 아니라 자동 약속 도 확인 &lt;a href=&quot;api/promise.method&quot;&gt; &lt;code&gt;Promise.method&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3b51c4c13d41d7852eb369e20c236af48cef84cc" translate="yes" xml:space="preserve">
          <source>Please consider reading more about &lt;a href=&quot;api/synchronous-inspection&quot;&gt;&lt;code&gt;synchronous inspection&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;api/synchronous-inspection&quot;&gt; &lt;code&gt;synchronous inspection&lt;/code&gt; &lt;/a&gt; 에 대해 자세히 읽어보십시오</target>
        </trans-unit>
        <trans-unit id="1e14f1308fe5c8dea2b2ef541f7aee826d27d5e0" translate="yes" xml:space="preserve">
          <source>Please consider reading the API docs for &lt;a href=&quot;api/some&quot;&gt;&lt;code&gt;.some&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;api/some&quot;&gt; &lt;code&gt;.some&lt;/code&gt; 에&lt;/a&gt; 대한 API 문서를 읽어보십시오.</target>
        </trans-unit>
        <trans-unit id="c5ef6b96fc3e88fc35fff339fde30327dde1a698" translate="yes" xml:space="preserve">
          <source>Please refer to the relevant section in the documentation about &lt;a href=&quot;api/generators&quot;&gt;&lt;code&gt;Generators&lt;/code&gt;&lt;/a&gt; in order to get usage instructions:</source>
          <target state="translated">사용법 지침을 얻으려면 &lt;a href=&quot;api/generators&quot;&gt; &lt;code&gt;Generators&lt;/code&gt; &lt;/a&gt; 관련 문서에서 관련 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5ad1bb14fb0bdc68c8977349fd048e917d0e042c" translate="yes" xml:space="preserve">
          <source>Please see the API docs of &lt;a href=&quot;api/catch&quot;&gt;&lt;code&gt;.catch()&lt;/code&gt;&lt;/a&gt; on how to use predicate catches.</source>
          <target state="translated">술어 캐치를 사용하는 방법에 대해서는 &lt;a href=&quot;api/catch&quot;&gt; &lt;code&gt;.catch()&lt;/code&gt; &lt;/a&gt; 의 API 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7c7ed98d6ff8cb1bb3beee177d5536fda218b9d6" translate="yes" xml:space="preserve">
          <source>Possibly unhandled rejection handler will always get a stack trace, even if the rejection or thrown error was not an error</source>
          <target state="translated">처리되지 않은 거부 처리기는 거부 또는 발생한 오류가 오류가 아니더라도 항상 스택 추적을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="24fd6c2d1150de6a47543209150ff4c2a2d3104f" translate="yes" xml:space="preserve">
          <source>PostgreSQL</source>
          <target state="translated">PostgreSQL</target>
        </trans-unit>
        <trans-unit id="642cccd7308199d6f0935637f8e1d6bddc7a7f5d" translate="yes" xml:space="preserve">
          <source>Predicate functions that only check properties have a handy shorthand. In place of a predicate function, you can pass an object, and its properties will be checked against the error object for a match:</source>
          <target state="translated">속성 만 검사하는 조건 자 함수에는 편리한 속기가 있습니다. 술어 함수 대신 객체를 전달할 수 있으며 해당 객체의 속성은 오류 객체와 비교하여 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="ef29f5e7937f710796c69d5f2e8ef62b93259503" translate="yes" xml:space="preserve">
          <source>Predicates should allow for very fine grained control over caught errors: pattern matching, error-type sets with set operations and many other techniques can be implemented on top of them.</source>
          <target state="translated">술어는 포착 된 오류에 대해 매우 세분화 된 제어를 허용해야합니다. 패턴 일치, 세트 조작이있는 오류 유형 세트 및 기타 많은 기술을 그 위에 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="966e683ff73ac6a6ff53e83d6497f2f1ad6da22d" translate="yes" xml:space="preserve">
          <source>Preserve bound-with-promise promises across the entire chain (&lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/702&quot;&gt;&lt;code&gt;#702&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">전체 체인에서 약속 약속을 유지하십시오 ( &lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/702&quot;&gt; &lt;code&gt;#702&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="b1d7cb674f49e0b746c342035d00a2302db4c737" translate="yes" xml:space="preserve">
          <source>Progress bar</source>
          <target state="translated">진행 표시 줄</target>
        </trans-unit>
        <trans-unit id="51674123623b6ab6e8ea7ca7250debfd7286bf63" translate="yes" xml:space="preserve">
          <source>Progress the underlying promise with &lt;code&gt;value&lt;/code&gt; as the progression value.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; 를 진행 가치로 하여 기본 약속을 진행하십시오 .</target>
        </trans-unit>
        <trans-unit id="685e262241d88a216ab9353d6e8f0939b5803641" translate="yes" xml:space="preserve">
          <source>Progression</source>
          <target state="translated">Progression</target>
        </trans-unit>
        <trans-unit id="25eee37f31e0eba9807d8e531ecf239e4d0cd542" translate="yes" xml:space="preserve">
          <source>Progression has been removed as there are composability and chaining issues with APIs that use promise progression handlers. Implementing the common use case of progress bars can be accomplished using a pattern similar to &lt;a href=&quot;http://blogs.msdn.com/b/dotnet/archive/2012/06/06/async-in-4-5-enabling-progress-and-cancellation-in-async-apis.aspx&quot;&gt;IProgress&lt;/a&gt; in C#.</source>
          <target state="translated">약속 진행률 처리기를 사용하는 API와의 호환성 및 체인 문제가 발생하여 진행이 제거되었습니다. C #에서 &lt;a href=&quot;http://blogs.msdn.com/b/dotnet/archive/2012/06/06/async-in-4-5-enabling-progress-and-cancellation-in-async-apis.aspx&quot;&gt;IProgress&lt;/a&gt; 와 유사한 패턴을 사용하여 진행률 표시 줄의 일반적인 사용 사례를 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3248b463906e068e9fcc220b46e1a5d372a78fb1" translate="yes" xml:space="preserve">
          <source>Progression migration</source>
          <target state="translated">진행 마이그레이션</target>
        </trans-unit>
        <trans-unit id="be45959fa7407eeadb36fe64732e21bc44a21868" translate="yes" xml:space="preserve">
          <source>Promise config returns reference to Bluebird library</source>
          <target state="translated">약속 구성은 Bluebird 라이브러리에 대한 참조를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fb6113ea309f0d5b9bec49fc1796cd040f492643" translate="yes" xml:space="preserve">
          <source>Promise exception handling mirrors native exception handling in JavaScript. A synchronous function &lt;code&gt;throw&lt;/code&gt;ing is similar to a promise rejecting. Here is an example to illustrate it:</source>
          <target state="translated">약속 예외 처리는 JavaScript에서 기본 예외 처리를 미러링합니다. 동기 함수 &lt;code&gt;throw&lt;/code&gt; 약속 거부와 유사합니다. 다음은이를 설명하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="8782a387409c7a9a87576a85d07c1e64505c1544" translate="yes" xml:space="preserve">
          <source>Promise monitoring</source>
          <target state="translated">약속 모니터링</target>
        </trans-unit>
        <trans-unit id="4dbc67ef437634d86ab184513509ef1b7aec9846" translate="yes" xml:space="preserve">
          <source>Promise nuggets</source>
          <target state="translated">약속 너겟</target>
        </trans-unit>
        <trans-unit id="cd4139a3b1a43d871cf4ddb3e7a6d5193448c48c" translate="yes" xml:space="preserve">
          <source>Promise progression has been completely removed.</source>
          <target state="translated">약속 진행이 완전히 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="7726aabf1843e710a9f37fd6b562d6f56faa7e88" translate="yes" xml:space="preserve">
          <source>Promise resolution</source>
          <target state="translated">약속 해상도</target>
        </trans-unit>
        <trans-unit id="65f81fcc4877a1e4dd84dd9b0c2863d1631025a9" translate="yes" xml:space="preserve">
          <source>Promise returning functions &lt;em&gt;should never throw&lt;/em&gt;, they should always successfully return a promise which is rejected in the case of an error. Throwing from a promise returning function will force you to use both a &lt;code&gt;} catch {&lt;/code&gt;&lt;em&gt;and&lt;/em&gt; a &lt;code&gt;.catch&lt;/code&gt;. People using promisified APIs do not expect promises to throw. If you're not sure how async APIs work in JS - please &lt;a href=&quot;http://stackoverflow.com/questions/14220321/how-to-return-the-response-from-an-asynchronous-call/16825593#16825593&quot;&gt;see this answer&lt;/a&gt; first.</source>
          <target state="translated">약속 반환 함수 &lt;em&gt;는 절대 던져서는 안되며&lt;/em&gt; , 오류가 발생하면 거부되는 약속을 항상 성공적으로 반환해야합니다. 약속 반환 함수에서 던지는 것은 모두 사용하도록 강제 &lt;code&gt;} catch {&lt;/code&gt; &lt;em&gt;및 &lt;/em&gt; &lt;code&gt;.catch&lt;/code&gt; 을 . 약속 된 API를 사용하는 사람들은 약속을 던질 것으로 기대하지 않습니다. JS에서 비동기 API가 어떻게 작동하는지 잘 모르겠다면 먼저이 &lt;a href=&quot;http://stackoverflow.com/questions/14220321/how-to-return-the-response-from-an-asynchronous-call/16825593#16825593&quot;&gt;답변을 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="32c88e7c01a53d5b288b9de6a6aab20cb547871d" translate="yes" xml:space="preserve">
          <source>Promise.all</source>
          <target state="translated">Promise.all</target>
        </trans-unit>
        <trans-unit id="a6755a6ad2728b869d475dc11ace6f3bf5ea4871" translate="yes" xml:space="preserve">
          <source>Promise.all()</source>
          <target state="translated">Promise.all()</target>
        </trans-unit>
        <trans-unit id="8a9f46eacb22a3bbe6409bdb49b4254651eff678" translate="yes" xml:space="preserve">
          <source>Promise.any</source>
          <target state="translated">Promise.any</target>
        </trans-unit>
        <trans-unit id="59a3e9eecb28443ad28e7c96175567acc96c62f3" translate="yes" xml:space="preserve">
          <source>Promise.any()</source>
          <target state="translated">Promise.any()</target>
        </trans-unit>
        <trans-unit id="380ddbb670a463da41bcb2f09102155dde8e708e" translate="yes" xml:space="preserve">
          <source>Promise.bind</source>
          <target state="translated">Promise.bind</target>
        </trans-unit>
        <trans-unit id="c504dbf7b03cd885ada0adc0180bde1c542f6ff6" translate="yes" xml:space="preserve">
          <source>Promise.bind()</source>
          <target state="translated">Promise.bind()</target>
        </trans-unit>
        <trans-unit id="94cffff23a1082b260d53b460f0199319830c332" translate="yes" xml:space="preserve">
          <source>Promise.config</source>
          <target state="translated">Promise.config</target>
        </trans-unit>
        <trans-unit id="14cca1b3fd91fce3c7d78898b9b8ab87641cd45f" translate="yes" xml:space="preserve">
          <source>Promise.config()</source>
          <target state="translated">Promise.config()</target>
        </trans-unit>
        <trans-unit id="0281c083d21b56d693df7c85bdc8760d5a153cb3" translate="yes" xml:space="preserve">
          <source>Promise.coroutine</source>
          <target state="translated">Promise.coroutine</target>
        </trans-unit>
        <trans-unit id="417c8a52e78b52649cc8c0d1a4a5c72e470fba46" translate="yes" xml:space="preserve">
          <source>Promise.coroutine()</source>
          <target state="translated">Promise.coroutine()</target>
        </trans-unit>
        <trans-unit id="1c7ffab7487989ed4fab5bf27ffc68d6a9e83f84" translate="yes" xml:space="preserve">
          <source>Promise.coroutine.addYieldHandler</source>
          <target state="translated">Promise.coroutine.addYieldHandler</target>
        </trans-unit>
        <trans-unit id="b32e1c4e626c99ffd6f0e20eaa5f3f6e5768bfd5" translate="yes" xml:space="preserve">
          <source>Promise.coroutine.addYieldHandler()</source>
          <target state="translated">Promise.coroutine.addYieldHandler()</target>
        </trans-unit>
        <trans-unit id="0eaf3c7722c589dfef45cece747a91a4f63eb1c4" translate="yes" xml:space="preserve">
          <source>Promise.delay</source>
          <target state="translated">Promise.delay</target>
        </trans-unit>
        <trans-unit id="b0fcfeaf123206f651b32c45d020a06c0161b597" translate="yes" xml:space="preserve">
          <source>Promise.delay()</source>
          <target state="translated">Promise.delay()</target>
        </trans-unit>
        <trans-unit id="58c05c22c80b95286ff97a890b8a711ca2bc4455" translate="yes" xml:space="preserve">
          <source>Promise.each</source>
          <target state="translated">Promise.each</target>
        </trans-unit>
        <trans-unit id="a620ec9f632f36f8a08e631069c08191868f6916" translate="yes" xml:space="preserve">
          <source>Promise.each()</source>
          <target state="translated">Promise.each()</target>
        </trans-unit>
        <trans-unit id="36ed6ee5c85807e4301bf69d782f38ceb4470326" translate="yes" xml:space="preserve">
          <source>Promise.filter</source>
          <target state="translated">Promise.filter</target>
        </trans-unit>
        <trans-unit id="86054f183176a3f69e770d2c34d2bdeae915a41e" translate="yes" xml:space="preserve">
          <source>Promise.filter()</source>
          <target state="translated">Promise.filter()</target>
        </trans-unit>
        <trans-unit id="98d41166fbaafb718942a7d54eb7a52ea584c71b" translate="yes" xml:space="preserve">
          <source>Promise.fromCallback</source>
          <target state="translated">Promise.fromCallback</target>
        </trans-unit>
        <trans-unit id="3f0b67925c3695da1eb2886d38a30665c003a3b1" translate="yes" xml:space="preserve">
          <source>Promise.fromCallback()</source>
          <target state="translated">Promise.fromCallback()</target>
        </trans-unit>
        <trans-unit id="fd3f3e356627367a0a1deb529a31724afae6adf2" translate="yes" xml:space="preserve">
          <source>Promise.getNewLibraryCopy</source>
          <target state="translated">Promise.getNewLibraryCopy</target>
        </trans-unit>
        <trans-unit id="89fb5dda745c6bafe6968a6f413760af47aceae1" translate="yes" xml:space="preserve">
          <source>Promise.getNewLibraryCopy()</source>
          <target state="translated">Promise.getNewLibraryCopy()</target>
        </trans-unit>
        <trans-unit id="40fdb4632aedb0a1797f0c8a54579a1fde171242" translate="yes" xml:space="preserve">
          <source>Promise.join</source>
          <target state="translated">Promise.join</target>
        </trans-unit>
        <trans-unit id="23d8f43c5ac526250cf76c302ad4119a7b1ab47b" translate="yes" xml:space="preserve">
          <source>Promise.join()</source>
          <target state="translated">Promise.join()</target>
        </trans-unit>
        <trans-unit id="7978c060e1559749beb237c1e2cd848a0c8c4d0d" translate="yes" xml:space="preserve">
          <source>Promise.map</source>
          <target state="translated">Promise.map</target>
        </trans-unit>
        <trans-unit id="ca13a4d72f15f0ca07d5d50979466ec8d5754e56" translate="yes" xml:space="preserve">
          <source>Promise.map()</source>
          <target state="translated">Promise.map()</target>
        </trans-unit>
        <trans-unit id="4228fbfb6f0c4ca7c03f7f3fe02a32213a675bb6" translate="yes" xml:space="preserve">
          <source>Promise.mapSeries</source>
          <target state="translated">Promise.mapSeries</target>
        </trans-unit>
        <trans-unit id="e726d78ebf8fa9e8d4dd4170765a788187160409" translate="yes" xml:space="preserve">
          <source>Promise.mapSeries()</source>
          <target state="translated">Promise.mapSeries()</target>
        </trans-unit>
        <trans-unit id="02c686952be30df3ceda356456842c51ca54d6b6" translate="yes" xml:space="preserve">
          <source>Promise.method</source>
          <target state="translated">Promise.method</target>
        </trans-unit>
        <trans-unit id="745df198c177406843ab6f0aef1a0ee5dfc83def" translate="yes" xml:space="preserve">
          <source>Promise.method()</source>
          <target state="translated">Promise.method()</target>
        </trans-unit>
        <trans-unit id="84f80dd435e5e59f09d00da45ff238df86a37a40" translate="yes" xml:space="preserve">
          <source>Promise.noConflict</source>
          <target state="translated">Promise.noConflict</target>
        </trans-unit>
        <trans-unit id="7531a2c2c6b7c98ad21e08d5e3ae1c19a0b22683" translate="yes" xml:space="preserve">
          <source>Promise.noConflict()</source>
          <target state="translated">Promise.noConflict()</target>
        </trans-unit>
        <trans-unit id="71c980a14f65b0a2704a085acb674ac28a814685" translate="yes" xml:space="preserve">
          <source>Promise.onPossiblyUnhandledRejection</source>
          <target state="translated">Promise.onPossiblyUnhandledRejection</target>
        </trans-unit>
        <trans-unit id="c371d88740f13aaaca5694582d4b3f1c2be33ab4" translate="yes" xml:space="preserve">
          <source>Promise.onPossiblyUnhandledRejection()</source>
          <target state="translated">Promise.onPossiblyUnhandledRejection()</target>
        </trans-unit>
        <trans-unit id="829674402143cb4c85191f62c464c46f218abca2" translate="yes" xml:space="preserve">
          <source>Promise.onUnhandledRejectionHandled</source>
          <target state="translated">Promise.onUnhandledRejectionHandled</target>
        </trans-unit>
        <trans-unit id="9c2cbfa68db14a1011a8bf225d1d930825635838" translate="yes" xml:space="preserve">
          <source>Promise.onUnhandledRejectionHandled()</source>
          <target state="translated">Promise.onUnhandledRejectionHandled()</target>
        </trans-unit>
        <trans-unit id="1bd4c78395725232fde1b79374d6efc9908e559c" translate="yes" xml:space="preserve">
          <source>Promise.promisify</source>
          <target state="translated">Promise.promisify</target>
        </trans-unit>
        <trans-unit id="1713f0d05877ab5fe29b2ac17f3c75196afacdff" translate="yes" xml:space="preserve">
          <source>Promise.promisify()</source>
          <target state="translated">Promise.promisify()</target>
        </trans-unit>
        <trans-unit id="97bebc26a4bce522904a06ed52ef00804ef373fc" translate="yes" xml:space="preserve">
          <source>Promise.promisifyAll</source>
          <target state="translated">Promise.promisifyAll</target>
        </trans-unit>
        <trans-unit id="582205a63795dfa2ded431e29909f2b0510003b9" translate="yes" xml:space="preserve">
          <source>Promise.promisifyAll()</source>
          <target state="translated">Promise.promisifyAll()</target>
        </trans-unit>
        <trans-unit id="27847ed541d9e1eeb76f5dbeb0044fcdbf775d18" translate="yes" xml:space="preserve">
          <source>Promise.props</source>
          <target state="translated">Promise.props</target>
        </trans-unit>
        <trans-unit id="4f38df349b880a0f534b640b3a8136437dece180" translate="yes" xml:space="preserve">
          <source>Promise.props now takes a &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/f41edac61b7c421608ff439bb5a09b7cffeadcf9/test/mocha/props.js#L197-L217&quot;&gt;thenable-for-collection&lt;/a&gt;</source>
          <target state="translated">Promise.props는 이제 &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/f41edac61b7c421608ff439bb5a09b7cffeadcf9/test/mocha/props.js#L197-L217&quot;&gt;수집이 가능합니다&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9db0fa212e5a187e62cb941c0f3eb586f29ed38d" translate="yes" xml:space="preserve">
          <source>Promise.props()</source>
          <target state="translated">Promise.props()</target>
        </trans-unit>
        <trans-unit id="6196396df0252ad4dc6749ba58e4f523ddc5109d" translate="yes" xml:space="preserve">
          <source>Promise.race</source>
          <target state="translated">Promise.race</target>
        </trans-unit>
        <trans-unit id="c805ba00efdcb8c7baa42fe61c954261ddd4c775" translate="yes" xml:space="preserve">
          <source>Promise.race()</source>
          <target state="translated">Promise.race()</target>
        </trans-unit>
        <trans-unit id="09422a77b11ac9569156f52e83edb0002c26642c" translate="yes" xml:space="preserve">
          <source>Promise.reduce</source>
          <target state="translated">Promise.reduce</target>
        </trans-unit>
        <trans-unit id="3036bc3d125176ce64d7f9e3b21c3e0d47ea6b85" translate="yes" xml:space="preserve">
          <source>Promise.reduce()</source>
          <target state="translated">Promise.reduce()</target>
        </trans-unit>
        <trans-unit id="783910d23dd1b1558a9b16d71c0ed4b397115fd3" translate="yes" xml:space="preserve">
          <source>Promise.reject</source>
          <target state="translated">Promise.reject</target>
        </trans-unit>
        <trans-unit id="8a2f2af4e6e3d7ca0c77296866bcfff0749f0dd9" translate="yes" xml:space="preserve">
          <source>Promise.reject()</source>
          <target state="translated">Promise.reject()</target>
        </trans-unit>
        <trans-unit id="0a3c75bb1d9e15c9996579992a0721a69da28c55" translate="yes" xml:space="preserve">
          <source>Promise.resolve</source>
          <target state="translated">Promise.resolve</target>
        </trans-unit>
        <trans-unit id="3cf132f388e7330298717bcc33a49e9f948aa7e5" translate="yes" xml:space="preserve">
          <source>Promise.resolve and PromiseResolver.resolve follow thenables too.</source>
          <target state="translated">Promise.resolve 및 PromiseResolver.resolve도 그 다음에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="47b038849d964f2910c38df87756eeab2c33c845" translate="yes" xml:space="preserve">
          <source>Promise.resolve()</source>
          <target state="translated">Promise.resolve()</target>
        </trans-unit>
        <trans-unit id="2bd5fccacac7e4b32307e5e90275cc00e52adab2" translate="yes" xml:space="preserve">
          <source>Promise.setScheduler</source>
          <target state="translated">Promise.setScheduler</target>
        </trans-unit>
        <trans-unit id="4f357c9ea9b4ced021695eb3da83abef0f53a5bc" translate="yes" xml:space="preserve">
          <source>Promise.setScheduler()</source>
          <target state="translated">Promise.setScheduler()</target>
        </trans-unit>
        <trans-unit id="b2b14953357fd6fd7061ee19d3a46165592f8187" translate="yes" xml:space="preserve">
          <source>Promise.some</source>
          <target state="translated">Promise.some</target>
        </trans-unit>
        <trans-unit id="a7f83b619aac204250fe4b4b48cffc16048afd2a" translate="yes" xml:space="preserve">
          <source>Promise.some()</source>
          <target state="translated">Promise.some()</target>
        </trans-unit>
        <trans-unit id="bcaec27b9cbb2228f24361eaa259b8fadc6e76b0" translate="yes" xml:space="preserve">
          <source>Promise.try</source>
          <target state="translated">Promise.try</target>
        </trans-unit>
        <trans-unit id="285c74e7f15b5592587b905c39313a8c4c3631cd" translate="yes" xml:space="preserve">
          <source>Promise.try()</source>
          <target state="translated">Promise.try()</target>
        </trans-unit>
        <trans-unit id="54ae20ee3d30d8a4d9a8c3f51ddc74ab08078bce" translate="yes" xml:space="preserve">
          <source>Promise.using</source>
          <target state="translated">Promise.using</target>
        </trans-unit>
        <trans-unit id="d12fa97fde3870925fdf7d6a0ac552e0c8c9b94a" translate="yes" xml:space="preserve">
          <source>Promise.using()</source>
          <target state="translated">Promise.using()</target>
        </trans-unit>
        <trans-unit id="1a5d11d2f1ddb5249c87ef7bd69381bb0b693272" translate="yes" xml:space="preserve">
          <source>PromiseInspection</source>
          <target state="translated">PromiseInspection</target>
        </trans-unit>
        <trans-unit id="868dfb6858e3ed48b9b873232bb97b0244d9d0bf" translate="yes" xml:space="preserve">
          <source>Promises are a concurrency primitive with a proven track record and language integration in most modern programming languages. They have been extensively studied since the 80s and will make your life much easier.</source>
          <target state="translated">약속은 대부분의 최신 프로그래밍 언어에서 입증 된 실적과 언어 통합을 갖춘 동시성 기본 요소입니다. 그들은 80 년대 이후 광범위하게 연구되어 왔으며 당신의 인생을 훨씬 더 쉽게 만들어 줄 것입니다.</target>
        </trans-unit>
        <trans-unit id="4979e5d38a5edf382533cb2038c51eb19a4dee6f" translate="yes" xml:space="preserve">
          <source>Promises are now not cancellable by default. This is backwards incompatible change - see &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#cancellable---promise&quot;&gt;&lt;code&gt;.cancellable()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이제 약속은 기본적으로 취소 할 수 없습니다. 이전 버전과 호환되지 않는 변경입니다. &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#cancellable---promise&quot;&gt; &lt;code&gt;.cancellable()&lt;/code&gt; &lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="ed5dd788dfd2194a43ab6fd8c2d1b84eb1ecc96e" translate="yes" xml:space="preserve">
          <source>Promises can be rejected with falsy values (or no value at all, equal to rejecting with &lt;code&gt;undefined&lt;/code&gt;), however &lt;code&gt;.asCallback&lt;/code&gt; will call the callback with an &lt;code&gt;Error&lt;/code&gt; object if the promise's rejection reason is a falsy value. You can retrieve the original falsy value from the error's &lt;code&gt;.cause&lt;/code&gt; property.</source>
          <target state="translated">허위 값으로 약속을 거부 할 수 있습니다 (또는 &lt;code&gt;undefined&lt;/code&gt; 으로 거부하는 것과 같은 값이 전혀 없음 ). &lt;code&gt;.asCallback&lt;/code&gt; 는 으로 콜백을 호출 &lt;code&gt;Error&lt;/code&gt; 약속의 거부 이유는 falsy 값인 경우 개체. 오류의 &lt;code&gt;.cause&lt;/code&gt; 속성 에서 원래 잘못된 값을 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="51f657ce6a52627dea6e94af335b6ca122d8163b" translate="yes" xml:space="preserve">
          <source>Promises can have a steep learning curve and it doesn't help that promise standards go out of their way to make it even harder. Bluebird works around the limitations by providing warnings where the standards disallow throwing errors when incorrect usage is detected. See &lt;a href=&quot;warning-explanations&quot;&gt;Warning Explanations&lt;/a&gt; for the possible warnings that bluebird covers.</source>
          <target state="translated">약속에는 가파른 학습 곡선이있을 수 있으며 약속 표준이 더 어려워 질 것을 약속하는 것은 도움이되지 않습니다. Bluebird는 잘못된 사용이 감지 될 때 표준에서 오류 발생을 허용하지 않는 경고를 제공하여 제한 사항을 해결합니다. 블루 버드가 다룰 수있는 경고에 대해서는 &lt;a href=&quot;warning-explanations&quot;&gt;경고 설명&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3be96f5495c2d83069fb9e4fe84ca585a4ab5539" translate="yes" xml:space="preserve">
          <source>Promises do not aim to solve such live updating problems directly. One option would be to use an intermediate promise - for example a &lt;code&gt;.loaded&lt;/code&gt; property on the model that fulfills with nothing.</source>
          <target state="translated">약속은 그러한 실시간 업데이트 문제를 직접 해결하는 것을 목표로하지 않습니다. 하나의 옵션은 중간 약속을 사용하는 것입니다. 예를 들어 아무것도 수행하지 않는 모델 의 &lt;code&gt;.loaded&lt;/code&gt; 속성.</target>
        </trans-unit>
        <trans-unit id="63104f36ddfde5f398242d3c9a325847a623a94b" translate="yes" xml:space="preserve">
          <source>Promises have state, they start as pending and can settle to:</source>
          <target state="translated">약속에는 상태가 있으며 보류 중으로 시작하여 다음과 같이 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc07d53901ac77bfe4d99f439fd922d98f514777" translate="yes" xml:space="preserve">
          <source>Promises now clean up all references (to handlers, child promises etc) as soon as possible.</source>
          <target state="translated">약속은 이제 가능한 빨리 모든 참조 (핸들러, 자식 약속 등)를 정리합니다.</target>
        </trans-unit>
        <trans-unit id="4f7e995a45e8a7aa84e5616f32bd9b6d2f616aeb" translate="yes" xml:space="preserve">
          <source>Promises now delete references to handlers attached to them as soon as possible</source>
          <target state="translated">약속은 이제 가능한 빨리 첨부 된 처리기에 대한 참조를 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="85f84a547296b83c2cd9be954bf35fa432933967" translate="yes" xml:space="preserve">
          <source>Promises perform a role similar to &lt;code&gt;IO&lt;/code&gt; in that they allow for easy chaining of asynchronous non-blocking operations. &lt;code&gt;Promise.coroutine&lt;/code&gt; can be seen as similar to &lt;code&gt;do&lt;/code&gt; notation although in practice it's not an accurate comparison.</source>
          <target state="translated">약속 은 비동기 비 차단 작업을 쉽게 연결할 수 있다는 점에서 &lt;code&gt;IO&lt;/code&gt; 와 유사한 역할을 수행 합니다. &lt;code&gt;Promise.coroutine&lt;/code&gt; 는 유사로 볼 수있다 &lt;code&gt;do&lt;/code&gt; 실제로는 정확한 비교하지 비록 표기법을.</target>
        </trans-unit>
        <trans-unit id="3e8ddebed649b44e7a85d5ae2af303397fa7ea81" translate="yes" xml:space="preserve">
          <source>Promises provide a lot of really cool and powerful guarantees like throw safety which are hard to provide when manually converting APIs to use promises. Thus, whenever it is possible to use the &lt;code&gt;Promise.promisify&lt;/code&gt; and &lt;code&gt;Promise.promisifyAll&lt;/code&gt; methods - we recommend you use them. Not only are they the safest form of conversion - they also use techniques of dynamic recompilation to introduce very little overhead.</source>
          <target state="translated">약속은 API를 수동으로 변환하여 약속을 사용할 때 제공하기 어려운 던지기 안전과 같은 정말 훌륭하고 강력한 보장을 많이 제공합니다. 따라서 &lt;code&gt;Promise.promisify&lt;/code&gt; 및 &lt;code&gt;Promise.promisifyAll&lt;/code&gt; 메소드 를 사용할 수있을 때마다 사용하는 것이 좋습니다. 가장 안전한 변환 형식 일뿐 아니라 동적 재 컴파일 기술을 사용하여 오버 헤드를 거의 발생시키지 않습니다.</target>
        </trans-unit>
        <trans-unit id="45fe5ca98fd7d2bd4d25dbf8138ba708e64fdca4" translate="yes" xml:space="preserve">
          <source>Promises returned by the &lt;code&gt;mapper&lt;/code&gt; function are awaited for and the returned promise doesn't fulfill until all mapped promises have fulfilled as well. If any promise in the array is rejected, or any promise returned by the &lt;code&gt;mapper&lt;/code&gt; function is rejected, the returned promise is rejected as well.</source>
          <target state="translated">&lt;code&gt;mapper&lt;/code&gt; 함수에 의해 리턴 된 약속 이 기다리고 있으며 맵핑 된 약속이 모두 이행 될 때까지 리턴 된 약속이 이행되지 않습니다. 배열의 약속이 거부되거나 &lt;code&gt;mapper&lt;/code&gt; 함수가 반환 한 약속이 거부되면 반환 된 약속도 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="7e30cdf817cbb4a8901ddafd58155a4d7d146650" translate="yes" xml:space="preserve">
          <source>Promises:</source>
          <target state="translated">Promises:</target>
        </trans-unit>
        <trans-unit id="7bdd89f28407b699d8b7e554f8c4f6ce47ea6c46" translate="yes" xml:space="preserve">
          <source>Promisification</source>
          <target state="translated">Promisification</target>
        </trans-unit>
        <trans-unit id="590f705f9b259c4f0eb3b51eea47cea46ae9c547" translate="yes" xml:space="preserve">
          <source>Promisification API changes</source>
          <target state="translated">약속 API 변경</target>
        </trans-unit>
        <trans-unit id="1a75c237f8187352ba7d075c4badc17c24ae0667" translate="yes" xml:space="preserve">
          <source>Promisification means converting an existing promise-unaware API to a promise-returning API.</source>
          <target state="translated">약속은 기존 약속을 모르는 API를 약속을 반환하는 API로 변환하는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="f53b14543d28697f9e7972521e017a85547d2532" translate="yes" xml:space="preserve">
          <source>Promisification now consider all functions on the object and its prototype chain</source>
          <target state="translated">약속은 이제 객체와 프로토 타입 체인의 모든 기능을 고려합니다.</target>
        </trans-unit>
        <trans-unit id="0968c7924c5fa044c0bc32de590809b8b7a0237f" translate="yes" xml:space="preserve">
          <source>Promisification on steroids</source>
          <target state="translated">스테로이드에 대한 약속</target>
        </trans-unit>
        <trans-unit id="f0fa280902593381c17c8ba3cc647f71fd36f85f" translate="yes" xml:space="preserve">
          <source>Promisified methods from promisifyAll no longer call the original method when it is overriden</source>
          <target state="translated">promisifyAll의 약속 된 메소드가 더 이상 원래 메소드를 호출하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="852dd44380a8f2d2fa9332abfb43753326f8154b" translate="yes" xml:space="preserve">
          <source>Promisifier APIs.</source>
          <target state="translated">약속의 API.</target>
        </trans-unit>
        <trans-unit id="b7ec2af376bac24219fefb48cbd2c962d80ace5d" translate="yes" xml:space="preserve">
          <source>Promisifies the entire object by going through the object's properties and creating an async equivalent of each function on the object and its prototype chain. The promisified method name will be the original method name suffixed with &lt;code&gt;suffix&lt;/code&gt; (default is &lt;code&gt;&quot;Async&quot;&lt;/code&gt;). Any class properties of the object (which is the case for the main export of many modules) are also promisified, both static and instance methods. Class property is a property with a function value that has a non-empty &lt;code&gt;.prototype&lt;/code&gt; object. Returns the input object.</source>
          <target state="translated">객체의 속성을 살펴보고 객체와 프로토 타입 체인에서 각 기능에 해당하는 비동기 비동기식을 만들어 전체 객체를 약속합니다. promisified 방법 이름 접미사 원래의 방법 이름이됩니다 &lt;code&gt;suffix&lt;/code&gt; (기본값은 &lt;code&gt;&quot;Async&quot;&lt;/code&gt; ). 정적 및 인스턴스 메소드 모두 객체의 모든 클래스 속성 (많은 모듈의 주요 내보내기의 경우)도 약속됩니다. 클래스 속성은 비어 있지 않은 &lt;code&gt;.prototype&lt;/code&gt; 을 가진 함수 값을 가진 속성입니다. 객체 . 입력 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7adb5806d2a6c639cdca0db8fdac9403bca0bc03" translate="yes" xml:space="preserve">
          <source>Promisifying multiple classes in one go</source>
          <target state="translated">한 번에 여러 클래스 약속</target>
        </trans-unit>
        <trans-unit id="6e3604888c4b4ec08e2837913d012fe2834ffa83" translate="yes" xml:space="preserve">
          <source>Python</source>
          <target state="translated">Python</target>
        </trans-unit>
        <trans-unit id="4177920eedb2d8d91fca3384f4b40aec4d20dcd2" translate="yes" xml:space="preserve">
          <source>Q and bluebird share a lot of common methods that nevertheless have different names:</source>
          <target state="translated">Q와 블루 버드는 이름이 다른 일반적인 방법을 많이 공유합니다.</target>
        </trans-unit>
        <trans-unit id="e9f05aa2c47c6bff64cd5f9cf0a523af4429924d" translate="yes" xml:space="preserve">
          <source>Rate Limiting</source>
          <target state="translated">속도 제한</target>
        </trans-unit>
        <trans-unit id="161ffbbe54e77d4760152fa5b4074a0a6142966a" translate="yes" xml:space="preserve">
          <source>Read given files sequentially while summing their contents as an integer. Each file contains just the text &lt;code&gt;10&lt;/code&gt;.</source>
          <target state="translated">내용을 정수로 합산하면서 주어진 파일을 순차적으로 읽습니다. 각 파일에는 텍스트 &lt;code&gt;10&lt;/code&gt; 만 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="26bb4a571dec15958b5bf88436f13b472b9923db" translate="yes" xml:space="preserve">
          <source>Real example 2:</source>
          <target state="translated">실제 예 2 :</target>
        </trans-unit>
        <trans-unit id="cf7056b7cac2c0b2ad06995c1808b40114dc8624" translate="yes" xml:space="preserve">
          <source>Real example:</source>
          <target state="translated">실제 예 :</target>
        </trans-unit>
        <trans-unit id="ede0567a2a6e0fddab65269f6559f8f6dd06aeb3" translate="yes" xml:space="preserve">
          <source>Rebinding can also be abused to do something gratuitous like this:</source>
          <target state="translated">리 바인딩은 또한 다음과 같은 무언가를하기 위해 남용 될 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="bf87a9a8812fbf363e857266207b8e2473838eca" translate="yes" xml:space="preserve">
          <source>Reduce minified full browser build file size by not including unused code generation functionality.</source>
          <target state="translated">사용하지 않는 코드 생성 기능을 포함하지 않아 축소 된 전체 브라우저 빌드 파일 크기가 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="aef1e9eebf3f426cee92bf8ff691ff6719cedbd1" translate="yes" xml:space="preserve">
          <source>Register a node-style callback on this promise. When this promise is either fulfilled or rejected, the node callback will be called back with the node.js convention where error reason is the first argument and success value is the second argument. The error argument will be &lt;code&gt;null&lt;/code&gt; in case of success.</source>
          <target state="translated">이 약속에 노드 스타일 콜백을 등록하십시오. 이 약속이 이행되거나 거부되면 오류 이유가 첫 번째 인수이고 성공 값이 두 번째 인수 인 node.js 규칙으로 노드 콜백이 다시 호출됩니다. 성공 하면 error 인수는 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e8d6efc26ea6904bda20ba7769db8ea12c079f56" translate="yes" xml:space="preserve">
          <source>Reject the underlying promise with &lt;code&gt;reason&lt;/code&gt; as the rejection reason.</source>
          <target state="translated">&lt;code&gt;reason&lt;/code&gt; 를 거부 이유로 하여 기본 약속을 거부하십시오 .</target>
        </trans-unit>
        <trans-unit id="3368ac8416e6d7cbc9d06211f6a676de253db2de" translate="yes" xml:space="preserve">
          <source>Rejections originating from &lt;code&gt;Promise.reject&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Promise.reject&lt;/code&gt; 에서 발생하는 거부</target>
        </trans-unit>
        <trans-unit id="8b0dba4404c73e60c9ff9e9453523c35331ea038" translate="yes" xml:space="preserve">
          <source>Rejections originating from &lt;code&gt;PromiseResolver&lt;/code&gt; where &lt;code&gt;.reject()&lt;/code&gt; method is called explicitly</source>
          <target state="translated">유래 거부 &lt;code&gt;PromiseResolver&lt;/code&gt; &lt;code&gt;.reject()&lt;/code&gt; 메소드가 명시 적으로 호출 될</target>
        </trans-unit>
        <trans-unit id="41142268db768fb66fa944cf61f77fd9b9826e36" translate="yes" xml:space="preserve">
          <source>Rejections originating from &lt;code&gt;new Promise&lt;/code&gt; constructor where the &lt;code&gt;reject&lt;/code&gt; callback is called explicitly</source>
          <target state="translated">&lt;code&gt;reject&lt;/code&gt; 콜백이 명시 적으로 호출 되는 &lt;code&gt;new Promise&lt;/code&gt; 생성자에서 발생하는 거부</target>
        </trans-unit>
        <trans-unit id="4fe2d523f67748538641074127a1db6157d74f6a" translate="yes" xml:space="preserve">
          <source>Rejections originating from promisified callbacks which use the &lt;code&gt;errback&lt;/code&gt; argument</source>
          <target state="translated">&lt;code&gt;errback&lt;/code&gt; 인수 를 사용하는 약속 된 콜백에서 발생하는 거부</target>
        </trans-unit>
        <trans-unit id="8eec88d2942215a1433216bd7c1c773ddcf67d09" translate="yes" xml:space="preserve">
          <source>Rejections originating from thenables using the &lt;code&gt;reject&lt;/code&gt; callback</source>
          <target state="translated">&lt;code&gt;reject&lt;/code&gt; 콜백을 사용하여 그 이후에 생성 된 거부</target>
        </trans-unit>
        <trans-unit id="198141ba7b56bcf3bec5a18ddd355c8adf68088b" translate="yes" xml:space="preserve">
          <source>Release control of the &lt;code&gt;Promise&lt;/code&gt; namespace to whatever it was before this library was loaded. Returns a reference to the library namespace so you can attach it to something else.</source>
          <target state="translated">&lt;code&gt;Promise&lt;/code&gt; 네임 스페이스의 제어권을 이 라이브러리가로드되기 전의 상태로 해제하십시오. 라이브러리 네임 스페이스에 대한 참조를 리턴하여 다른 것에 첨부 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0181ee2fe3f8479b72a162b35eb3977b69562275" translate="yes" xml:space="preserve">
          <source>Remove dependency of es5-shim and es5-sham when using ES3.</source>
          <target state="translated">ES3를 사용할 때 es5-shim 및 es5-sham의 종속성을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="e444431ea8965e36418e87f29f232d6f066fbe6e" translate="yes" xml:space="preserve">
          <source>Remove kew from benchmarks due to bugs in the library breaking the benchmark</source>
          <target state="translated">라이브러리의 버그로 인해 벤치 마크에서 kew 제거 벤치 마크</target>
        </trans-unit>
        <trans-unit id="1a4dd4da1213db0bc986ba8e811f9173d4dfd37c" translate="yes" xml:space="preserve">
          <source>Remove memoization of thenables</source>
          <target state="translated">thenables의 메모를 제거</target>
        </trans-unit>
        <trans-unit id="851f4336d464dd91890330239ecdcbcd3eede50c" translate="yes" xml:space="preserve">
          <source>Remove uses of dynamic evaluation (&lt;code&gt;new Function&lt;/code&gt;, &lt;code&gt;eval&lt;/code&gt; etc) when strictly not necessary. Use feature detection to use static evaluation to avoid errors when dynamic evaluation is prohibited.</source>
          <target state="translated">엄격하게 필요하지 않은 경우 동적 평가 ( &lt;code&gt;new Function&lt;/code&gt; , &lt;code&gt;eval&lt;/code&gt; 등) 사용을 제거하십시오 . 동적 평가가 금지 된 경우 오류를 피하기 위해 정적 감지를 사용하려면 기능 감지를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="963bc143de16fd9c36ff8020e48785b4de1b5fa2" translate="yes" xml:space="preserve">
          <source>Removed the &lt;code&gt;.inspect()&lt;/code&gt; method</source>
          <target state="translated">&lt;code&gt;.inspect()&lt;/code&gt; 메소드 제거</target>
        </trans-unit>
        <trans-unit id="73c105dee9adb30dced75f9d53b912f789492799" translate="yes" xml:space="preserve">
          <source>Rename PromiseResolver#asCallback to PromiseResolver#callback</source>
          <target state="translated">PromiseResolver # asCallback을 PromiseResolver # callback으로 이름 바꾸기</target>
        </trans-unit>
        <trans-unit id="a93b7a7d13386c2b9229d1b2d9f532763ef7e300" translate="yes" xml:space="preserve">
          <source>Report unhandled rejections even when long stack traces are disabled</source>
          <target state="translated">긴 스택 추적이 비활성화 된 경우에도 처리되지 않은 거부보고</target>
        </trans-unit>
        <trans-unit id="212187c4ba067f96c7eec7538c40788ae9024465" translate="yes" xml:space="preserve">
          <source>Represents an error is an explicit promise rejection as opposed to a thrown error. For example, if an error is errbacked by a callback API promisified through &lt;a href=&quot;promise.promisify&quot;&gt;&lt;code&gt;Promise.promisify&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;promise.promisifyall&quot;&gt;&lt;code&gt;Promise.promisifyAll&lt;/code&gt;&lt;/a&gt; and is not a typed error, it will be converted to a &lt;code&gt;OperationalError&lt;/code&gt; which has the original error in the &lt;code&gt;.cause&lt;/code&gt; property.</source>
          <target state="translated">오류는 발생 된 오류와 달리 명시 적 약속 거부임을 나타냅니다. 오류 관통 promisified 콜백 API에 의해 errbacked되는 경우, 예를 들어 &lt;a href=&quot;promise.promisify&quot;&gt; &lt;code&gt;Promise.promisify&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;promise.promisifyall&quot;&gt; &lt;code&gt;Promise.promisifyAll&lt;/code&gt; &lt;/a&gt; 및 입력 된 오류 아니라,이 변환 될 &lt;code&gt;OperationalError&lt;/code&gt; 원래 오류 갖는다 &lt;code&gt;.cause&lt;/code&gt; 의 속성.</target>
        </trans-unit>
        <trans-unit id="f957ddaaf86217c5ba862399d723b49b7e0b15cb" translate="yes" xml:space="preserve">
          <source>Requires a statement so cannot be used in an expression context</source>
          <target state="translated">명령문이 필요하므로 표현식 컨텍스트에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9c076f55ca621ae470e8e6540a2f2547c25d4dbe" translate="yes" xml:space="preserve">
          <source>Resolve the underlying promise with &lt;code&gt;value&lt;/code&gt; as the resolution value. If &lt;code&gt;value&lt;/code&gt; is a thenable or a promise, the underlying promise will assume its state.</source>
          <target state="translated">기본 약속을 해결 &lt;code&gt;value&lt;/code&gt; 으로 사용하여 해결하십시오. 경우 &lt;code&gt;value&lt;/code&gt; thenable 또는 약속이며, 기본 약속은 그 상태를 가정합니다.</target>
        </trans-unit>
        <trans-unit id="78389e9ab495397e98445c046d321313be7d1269" translate="yes" xml:space="preserve">
          <source>Resolves to the original array unmodified, this method is meant to be used for side effects. If the iterator function returns a promise or a thenable, then the result of the promise is awaited, before continuing with next iteration.</source>
          <target state="translated">수정되지 않은 원래 배열로 해결되며이 방법은 부작용에 사용됩니다. 반복자 함수가 promise 또는 thenable을 반환하면 다음 반복을 계속하기 전에 promise의 결과가 기다립니다.</target>
        </trans-unit>
        <trans-unit id="ce09507134e744cff09a805076e969ccb76e51c1" translate="yes" xml:space="preserve">
          <source>Resolves to the original array unmodified. This method is meant to be used for side effects.</source>
          <target state="translated">수정되지 않은 원래 배열로 확인합니다. 이 방법은 부작용에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9e392aa0bd224f1b62eea587068fd172df50f2e7" translate="yes" xml:space="preserve">
          <source>Resource management</source>
          <target state="translated">자원 관리</target>
        </trans-unit>
        <trans-unit id="0d5055e26e1fb07ecf2ddfcb210895ed4ebe7ce8" translate="yes" xml:space="preserve">
          <source>Rethink already uses Bluebird promises internally and has promise returning APIs. Use those.</source>
          <target state="translated">Rethink는 이미 내부적으로 Bluebird 약속을 사용하고 API를 반환 할 것을 약속했습니다. 그것들을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="89ddb5cfb70d8bad46dda602a6ccbd88515a58d8" translate="yes" xml:space="preserve">
          <source>RethinkDB</source>
          <target state="translated">RethinkDB</target>
        </trans-unit>
        <trans-unit id="48ceb22a9c112e78b0de9c59218daa18a395591e" translate="yes" xml:space="preserve">
          <source>Returns a Disposer object which encapsulates both the resource as well as the method to clean it up. The user can pass this object to &lt;code&gt;Promise.using&lt;/code&gt; to get access to the resource when it becomes available, as well as to ensure it's automatically cleaned up.</source>
          <target state="translated">리소스와 정리 방법을 모두 캡슐화하는 Disposer 객체를 반환합니다. 사용자는이 개체를 &lt;code&gt;Promise.using&lt;/code&gt; 에 전달하여 사용할 수있을 때 리소스에 액세스하고 자동으로 정리되도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f6f3eb0a331057a9ce7728d16275ef0f0403798" translate="yes" xml:space="preserve">
          <source>Returns a function that can use &lt;code&gt;yield&lt;/code&gt; to yield promises. Control is returned back to the generator when the yielded promise settles. This can lead to less verbose code when doing lots of sequential async calls with minimal processing in between. Requires node.js 0.12+, io.js 1.0+ or Google Chrome 40+.</source>
          <target state="translated">&lt;code&gt;yield&lt;/code&gt; 를 사용 하여 promise를 산출 할 수있는 함수를 반환합니다 . 산출 된 약속이 확정되면 제어는 발전기로 다시 돌아갑니다. 이로 인해 사이에 최소한의 처리만으로 많은 순차적 비동기 호출을 수행 할 때 자세한 코드가 줄어들 수 있습니다. node.js 0.12 이상, io.js 1.0 이상 또는 Chrome 40 이상이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="0f8e633d273655fa3f1e81f2818120962168742f" translate="yes" xml:space="preserve">
          <source>Returns a function that will wrap the given &lt;code&gt;nodeFunction&lt;/code&gt;. Instead of taking a callback, the returned function will return a promise whose fate is decided by the callback behavior of the given node function. The node function should conform to node.js convention of accepting a callback as last argument and calling that callback with error as the first argument and success value on the second argument.</source>
          <target state="translated">지정된 &lt;code&gt;nodeFunction&lt;/code&gt; 을 랩핑하는 함수를 리턴합니다 . 콜백을 수행하는 대신 반환 된 함수는 주어진 노드 함수의 콜백 동작에 의해 운명이 결정되는 약속을 반환합니다. 노드 함수는 마지막 인수로 콜백을 수락하고 첫 번째 인수로 오류와 두 번째 인수의 성공 값으로 콜백을 호출하는 node.js 규칙을 준수해야합니다.</target>
        </trans-unit>
        <trans-unit id="77302444e8cc66fc3523da337688a121188e8a8c" translate="yes" xml:space="preserve">
          <source>Returns a new function that wraps the given function &lt;code&gt;fn&lt;/code&gt;. The new function will always return a promise that is fulfilled with the original functions return values or rejected with thrown exceptions from the original function.</source>
          <target state="translated">주어진 함수 &lt;code&gt;fn&lt;/code&gt; 을 감싸는 새로운 함수를 반환합니다 . 새로운 함수는 항상 원래 함수 반환 값으로 충족되거나 원래 함수에서 예외가 발생하여 거부 된 약속을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d0084f22c144f601402343afe0d33d4fb7f3e903" translate="yes" xml:space="preserve">
          <source>Returns a new independent copy of the Bluebird library.</source>
          <target state="translated">Bluebird 라이브러리의 새로운 독립 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1b966690c369fe4ac468c8b47b2a688522f4806f" translate="yes" xml:space="preserve">
          <source>Returns a promise for an array that contains the values returned by the &lt;code&gt;iterator&lt;/code&gt; function in their respective positions. The iterator won't be called for an item until its previous item, and the promise returned by the iterator for that item are fulfilled. This results in a &lt;code&gt;mapSeries&lt;/code&gt; kind of utility but it can also be used simply as a side effect iterator similar to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt;&lt;code&gt;Array#forEach&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;iterator&lt;/code&gt; 함수가 반환 한 값을 해당 위치에 포함하는 배열에 대한 약속을 반환합니다 . 반복자는 이전 항목까지 항목에 대해 호출되지 않으며 해당 항목에 대해 반복자가 리턴 한 약속이 이행됩니다. 이로 인해 &lt;code&gt;mapSeries&lt;/code&gt; 종류의 유틸리티가 생성되지만 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt; &lt;code&gt;Array#forEach&lt;/code&gt; &lt;/a&gt; 와 유사한 부작용 반복자로 간단히 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9fa83662ab7e1494742b674953702f77f5f38fa1" translate="yes" xml:space="preserve">
          <source>Returns a promise that is resolved by a node style callback function. This is the most fitting way to do on the fly promisification when libraries don't expose classes for automatic promisification by undefined.</source>
          <target state="translated">노드 스타일 콜백 함수로 해결 된 약속을 반환합니다. 라이브러리가 정의되지 않은 자동 약속에 대한 클래스를 공개하지 않는 경우 이는 즉시 약속에 가장 적합한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="4da867e8cf20d6ea986a5fd922cf7a1fb8f17c8a" translate="yes" xml:space="preserve">
          <source>Returns a promise that will be fulfilled with this promise's fulfillment value or rejection reason. However, if this promise is not fulfilled or rejected within &lt;code&gt;ms&lt;/code&gt; milliseconds, the returned promise is rejected with a &lt;a href=&quot;timeouterror&quot;&gt;&lt;code&gt;TimeoutError&lt;/code&gt;&lt;/a&gt; or the &lt;code&gt;error&lt;/code&gt; as the reason.</source>
          <target state="translated">이 약속의 이행 가치 또는 거부 사유로 이행 될 약속을 반환합니다. 그러나이 약속이 &lt;code&gt;ms&lt;/code&gt; 밀리 초 내에 이행되거나 거부되지 않으면 반환 된 약속은 &lt;a href=&quot;timeouterror&quot;&gt; &lt;code&gt;TimeoutError&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;error&lt;/code&gt; 로 인해 거부됩니다 .</target>
        </trans-unit>
        <trans-unit id="dd6aed551657efa53d35002ee36b6a3e0c3755d8" translate="yes" xml:space="preserve">
          <source>Returns a promise that will be resolved with &lt;code&gt;value&lt;/code&gt; (or &lt;code&gt;undefined&lt;/code&gt;) after given &lt;code&gt;ms&lt;/code&gt; milliseconds. If &lt;code&gt;value&lt;/code&gt; is a promise, the delay will start counting down when it is fulfilled and the returned promise will be fulfilled with the fulfillment value of the &lt;code&gt;value&lt;/code&gt; promise. If &lt;code&gt;value&lt;/code&gt; is a rejected promise, the resulting promise will be rejected immediately.</source>
          <target state="translated">지정된 &lt;code&gt;ms&lt;/code&gt; 밀리 초 후에 &lt;code&gt;value&lt;/code&gt; (또는 &lt;code&gt;undefined&lt;/code&gt; ) 으로 해결 될 약속을 반환합니다 . 경우 &lt;code&gt;value&lt;/code&gt; 약속이다, 지연이 성취되고 반환 약속이 성취 값으로 성취 될 때 카운트 다운이 시작됩니다 &lt;code&gt;value&lt;/code&gt; 약속. 경우 &lt;code&gt;value&lt;/code&gt; 거부 된 약속, 결과 약속은 즉시 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="0baaeaec06f70621397f1ef99fcbfb8ddf084acc" translate="yes" xml:space="preserve">
          <source>Returns back this promise instead of creating a new one. If the &lt;code&gt;callback&lt;/code&gt; argument is not a function, this method does not do anything.</source>
          <target state="translated">새로운 약속을 만드는 대신이 약속을 되돌립니다. 경우 &lt;code&gt;callback&lt;/code&gt; 인수가 함수가 아닙니다,이 메소드는 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f7778ce7c8366fce862636b34420e6d9618d48dd" translate="yes" xml:space="preserve">
          <source>Revert monitoring feature due to crash in browser</source>
          <target state="translated">브라우저 충돌로 인한 모니터링 기능 되돌리기</target>
        </trans-unit>
        <trans-unit id="48334a9d7741c7c5b6ebf7eef29195609c38e705" translate="yes" xml:space="preserve">
          <source>Rollback non-working multiple fresh copies feature</source>
          <target state="translated">작동하지 않는 여러 개의 새 사본 기능 롤백</target>
        </trans-unit>
        <trans-unit id="af2379a3b3b95738bc09586b8c9af459a812b070" translate="yes" xml:space="preserve">
          <source>Run example on JSBin</source>
          <target state="translated">JSBin에서 예제 실행</target>
        </trans-unit>
        <trans-unit id="080508f70cca7834ce2ef4eef4f37dd98ffff2b4" translate="yes" xml:space="preserve">
          <source>Running the example:</source>
          <target state="translated">예제 실행 :</target>
        </trans-unit>
        <trans-unit id="e2fa217fe73b363a41e739397cee0e3ca1933591" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;promise.all&quot;&gt;&lt;code&gt;Promise.all(this)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;promise.all&quot;&gt; &lt;code&gt;Promise.all(this)&lt;/code&gt; &lt;/a&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="2b23caad0148511b77a2cf241f932d7c6709a7d3" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;promise.any&quot;&gt;&lt;code&gt;Promise.any(this)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;promise.any&quot;&gt; &lt;code&gt;Promise.any(this)&lt;/code&gt; &lt;/a&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="580ea88db97d01930313a97fceee680b30d45b7d" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;promise.filter&quot;&gt;&lt;code&gt;Promise.filter(this, filterer, options)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;promise.filter&quot;&gt; &lt;code&gt;Promise.filter(this, filterer, options)&lt;/code&gt; &lt;/a&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="975ef8a2ddc0a473b966c6a5cf58d6b15ce60290" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;promise.map&quot;&gt;&lt;code&gt;Promise.map(this, mapper, options)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;promise.map&quot;&gt; &lt;code&gt;Promise.map(this, mapper, options)&lt;/code&gt; &lt;/a&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="c6801edeea7902bcdcddad94e4e019a39b6cf35a" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;promise.mapseries&quot;&gt;&lt;code&gt;Promise.mapSeries(this, iterator)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;promise.mapseries&quot;&gt; &lt;code&gt;Promise.mapSeries(this, iterator)&lt;/code&gt; &lt;/a&gt; 와 동일 합니다 .</target>
        </trans-unit>
        <trans-unit id="b8c55e09fe61d7950e9b369ac035513826c1d2a6" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;promise.props&quot;&gt;&lt;code&gt;Promise.props(this)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;promise.props&quot;&gt; &lt;code&gt;Promise.props(this)&lt;/code&gt; &lt;/a&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="8a380c08b4944e2caae2cd146735f961151b5e6e" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;promise.reduce&quot;&gt;&lt;code&gt;Promise.reduce(this, reducer, initialValue)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;promise.reduce&quot;&gt; &lt;code&gt;Promise.reduce(this, reducer, initialValue)&lt;/code&gt; &lt;/a&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="a356dad7c25106bdfd17533e6d57d965a40a5a84" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;promise.some&quot;&gt;&lt;code&gt;Promise.some(this, count)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;promise.some&quot;&gt; &lt;code&gt;Promise.some(this, count)&lt;/code&gt; &lt;/a&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="f6cc344c16a1e8b60323a0d888ae481c9928a8ab" translate="yes" xml:space="preserve">
          <source>Same as calling &lt;a href=&quot;promise.bind&quot;&gt;&lt;code&gt;Promise.bind(thisArg, thisPromise)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;promise.bind&quot;&gt; &lt;code&gt;Promise.bind(thisArg, thisPromise)&lt;/code&gt; &lt;/a&gt; 호출과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="e458385af15b3281d6aad96024285a33aab42f7e" translate="yes" xml:space="preserve">
          <source>Same as calling &lt;a href=&quot;promise.delay&quot;&gt;&lt;code&gt;Promise.delay(ms, this)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;promise.delay&quot;&gt; &lt;code&gt;Promise.delay(ms, this)&lt;/code&gt; &lt;/a&gt; 호출과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="c2c078b3023463c3ffc03ea245f314b93b9997db" translate="yes" xml:space="preserve">
          <source>Same limitations regarding to the binding time of &lt;code&gt;reason&lt;/code&gt; to apply as with &lt;a href=&quot;return&quot;&gt;&lt;code&gt;.return&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;return&quot;&gt; &lt;code&gt;.return&lt;/code&gt; &lt;/a&gt; 과 마찬가지로 적용 할 &lt;code&gt;reason&lt;/code&gt; 의 바인딩 시간에 관한 동일한 제한 사항 .</target>
        </trans-unit>
        <trans-unit id="c5f6c90a1ad0cebcb9beb15aafa1cb6735ec4a6f" translate="yes" xml:space="preserve">
          <source>Same limitations regarding to the binding time of &lt;code&gt;value&lt;/code&gt; to apply as with &lt;a href=&quot;return&quot;&gt;&lt;code&gt;.return&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;return&quot;&gt; &lt;code&gt;.return&lt;/code&gt; &lt;/a&gt; 과 마찬가지로 적용 할 &lt;code&gt;value&lt;/code&gt; 의 바인딩 시간에 대한 동일한 제한 사항 .</target>
        </trans-unit>
        <trans-unit id="7b7e70bcf209a5323526033a9cbf768a3ae70c2c" translate="yes" xml:space="preserve">
          <source>Scala</source>
          <target state="translated">Scala</target>
        </trans-unit>
        <trans-unit id="4c8d353832617594b0903e9beaf0a3bc9414fd0a" translate="yes" xml:space="preserve">
          <source>Scheduler should be a function that asynchronously schedules the calling of the passed in function:</source>
          <target state="translated">스케줄러는 전달 된 함수의 호출을 비동기 적으로 스케줄하는 함수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="b6e22d4f13d0bc08ae5171b4f3faa591b3854aba" translate="yes" xml:space="preserve">
          <source>Scoped prototypes</source>
          <target state="translated">범위가 지정된 프로토 타입</target>
        </trans-unit>
        <trans-unit id="1e4c2c805f8ac17da444424c8f8bf077911b3260" translate="yes" xml:space="preserve">
          <source>Second example is creating a function that does nothing but manually wrap a callback API and doing a poor job at that:</source>
          <target state="translated">두 번째 예는 콜백 API를 수동으로 랩핑하고 그 작업을 제대로 수행하지 않는 함수를 만드는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c651da6b87ea51d587627a0d63283b28e42fd9e4" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#map-option-concurrency&quot;&gt;Map Option: concurrency&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#map-option-concurrency&quot;&gt;맵 옵션 : 동시성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3fc2fab79463362dbab8dbab63714a6f37b5961f" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#promisification&quot;&gt;promisification&lt;/a&gt; for more examples.</source>
          <target state="translated">더 많은 예는 &lt;a href=&quot;#promisification&quot;&gt;약속&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="23a68335a77ae0704a80f59d32facaab6ffbdba9" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;api/cancellation&quot;&gt;&lt;code&gt;Cancellation&lt;/code&gt;&lt;/a&gt; for how to use cancellation.</source>
          <target state="translated">&lt;a href=&quot;api/cancellation&quot;&gt; &lt;code&gt;Cancellation&lt;/code&gt; &lt;/a&gt; 사용 방법 은 취소 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5f52e149e8a0803d7f7b841c33681f919e936364" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;api/environment-variables&quot;&gt;&lt;code&gt;Environment Variables&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;api/environment-variables&quot;&gt; &lt;code&gt;Environment Variables&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ab38b0ca0dbd1886ea0aa3b5d41ba2fd2e703bb5" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;api/error-management-configuration#global-rejection-events&quot;&gt;global rejection events&lt;/a&gt; to learn more about the hooks.</source>
          <target state="translated">후크에 대한 자세한 내용은 &lt;a href=&quot;api/error-management-configuration#global-rejection-events&quot;&gt;전역 거부 이벤트&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="06395aee9e31cf27b400d0aac841e6752959ba6e" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;api/progression-migration&quot;&gt;Progression Migration&lt;/a&gt; for migration assistance and examples of how to convert APIs that use progression to ones that do not.</source>
          <target state="translated">마이그레이션 지원 및 진행을 사용하는 API를 사용하지 않는 API로 변환하는 방법에 대한 예제는 &lt;a href=&quot;api/progression-migration&quot;&gt;진행 마이그레이션&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="68ba78b1d14da78646ebff542d287d69dbc5a960" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://stackoverflow.com/a/17891099/227176&quot;&gt;this StackOverflow answer&lt;/a&gt; for a more detailed and feature complete way to make custom errors.</source>
          <target state="translated">사용자 지정 오류를 만드는 더 자세하고 기능적인 완전한 방법 은 &lt;a href=&quot;http://stackoverflow.com/a/17891099/227176&quot;&gt;이 StackOverflow 답변&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="06706fc1eca556ceadf36cdc2fed09eb5719e880" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://stackoverflow.com/questions/22724883/js-deferred-promise-future-compared-to-functional-languages-like-scala&quot;&gt;this question on StackOverflow&lt;/a&gt; for more differences.</source>
          <target state="translated">더 많은 차이점 &lt;a href=&quot;http://stackoverflow.com/questions/22724883/js-deferred-promise-future-compared-to-functional-languages-like-scala&quot;&gt;은 StackOverflow에서이 질문을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="87f924e288cbca74d9deadff4feb3964dc20a0cb" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://stackoverflow.com/questions/26136389/how-can-i-realize-pattern-promise-deffered&quot;&gt;this question on StackOverflow&lt;/a&gt; for more differences.</source>
          <target state="translated">더 많은 차이점 &lt;a href=&quot;http://stackoverflow.com/questions/26136389/how-can-i-realize-pattern-promise-deffered&quot;&gt;은 StackOverflow에서이 질문을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6b47ded2bd3e84b6a1d18b1f7005536f6c95a4c4" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;install&quot;&gt;installation&lt;/a&gt; on how to enable long stack traces in your environment.</source>
          <target state="translated">환경에서 긴 스택 추적을 활성화하는 방법에 대한 &lt;a href=&quot;install&quot;&gt;설치&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="40938884818bf7e771e25611b0ecc72ecf13d826" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;install&quot;&gt;installation&lt;/a&gt; on how to enable warnings in your environment.</source>
          <target state="translated">환경에서 경고를 활성화하는 방법에 대한 &lt;a href=&quot;install&quot;&gt;설치&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fd18968e9220ec2edbcb69219a62b308e07af8ca" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;new-in-bluebird-3&quot;&gt;New in 3.0&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;new-in-bluebird-3&quot;&gt;3.0의 새로운 기능을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a128fef004cd14934d7a35ae580447b292348acd" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;api/promise.promisifyall&quot;&gt;&lt;code&gt;Promise.promisifyAll&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;api/promise.promisifyall&quot;&gt; &lt;code&gt;Promise.promisifyAll&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4c964d6768cfba0357dc178ad5c1c5b834096887" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;promise.promisifyall&quot;&gt;&lt;code&gt;Promise.promisifyAll&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;promise.promisifyall&quot;&gt; &lt;code&gt;Promise.promisifyAll&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ec633a7c6034c365e8ffcaf57fd91b71d7eba69d" translate="yes" xml:space="preserve">
          <source>See if this &lt;code&gt;promise&lt;/code&gt; has been cancelled.</source>
          <target state="translated">이 &lt;code&gt;promise&lt;/code&gt; 이 취소되었는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="e2ba106a736de3c98da11dcab4e39f4c475860bf" translate="yes" xml:space="preserve">
          <source>See if this &lt;code&gt;promise&lt;/code&gt; is pending (not fulfilled or rejected or cancelled).</source>
          <target state="translated">이 &lt;code&gt;promise&lt;/code&gt; 이 보류 중인지 확인하십시오 (완료 또는 거부 또는 취소되지 않음).</target>
        </trans-unit>
        <trans-unit id="43f5e31f9196af8cf21954e2abe72267402aeb61" translate="yes" xml:space="preserve">
          <source>See if this promise has been fulfilled.</source>
          <target state="translated">이 약속이 성취되었는지보십시오.</target>
        </trans-unit>
        <trans-unit id="a4923f987cce26c1b5f0647eecfad58c0130790b" translate="yes" xml:space="preserve">
          <source>See if this promise has been rejected.</source>
          <target state="translated">이 약속이 거절되었는지보십시오.</target>
        </trans-unit>
        <trans-unit id="00853e3a835e9b91810aba99eb34ee3eaa60c4cf" translate="yes" xml:space="preserve">
          <source>See the API on &lt;a href=&quot;api/synchronous-inspection&quot;&gt;&lt;code&gt;synchronous inspection&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">자세한 정보 는 &lt;a href=&quot;api/synchronous-inspection&quot;&gt; &lt;code&gt;synchronous inspection&lt;/code&gt; &lt;/a&gt; 대한 API 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b6d3dd68401ad34ac91e21bd296d96dcc691d3a3" translate="yes" xml:space="preserve">
          <source>See the API page about &lt;a href=&quot;api/promise.longstacktraces&quot;&gt;&lt;code&gt;Promise.longStackTraces&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;api/promise.longstacktraces&quot;&gt; &lt;code&gt;Promise.longStackTraces&lt;/code&gt; &lt;/a&gt; 에 대한 API 페이지를 참조하십시오</target>
        </trans-unit>
        <trans-unit id="32248b4544c4dacee860f46416e5a89b6310bc5c" translate="yes" xml:space="preserve">
          <source>Sequelize</source>
          <target state="translated">Sequelize</target>
        </trans-unit>
        <trans-unit id="0353c268d6003a0b1d6e372faa2ae4914cf1ab42" translate="yes" xml:space="preserve">
          <source>Sequelize already uses Bluebird promises internally and has promise returning APIs. Use those.</source>
          <target state="translated">Sequelize는 이미 내부적으로 Bluebird 약속을 사용하고 API를 반환 할 것을 약속했습니다. 그것들을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0477fce5eb6ea953b269e6b50843ad48931e59dd" translate="yes" xml:space="preserve">
          <source>Setting &lt;code&gt;multiArgs&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; means the resulting promise will always fulfill with an array of the callback's success value(s). This is needed because promises only support a single success value while some callback API's have multiple success value. The default is to ignore all but the first success value of a callback function.</source>
          <target state="translated">&lt;code&gt;multiArgs&lt;/code&gt; 를 &lt;code&gt;true&lt;/code&gt; 로 설정 하면 결과 약속이 항상 콜백의 성공 값 배열로 이행됩니다. 약속은 단일 성공 값만 지원하는 반면 일부 콜백 API에는 여러 성공 값이 있기 때문에 필요합니다. 기본값은 콜백 함수의 첫 번째 성공 값을 제외한 모든 것을 무시하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9d87c38ef9cdbe40b70787a797d9e70b16e2a6cd" translate="yes" xml:space="preserve">
          <source>Setting a custom scheduler could be necessary when you need a faster way to schedule functions than bluebird does by default. It also makes bluebird possible to use in platforms where normal timing constructs like &lt;code&gt;setTimeout&lt;/code&gt; and &lt;code&gt;process.nextTick&lt;/code&gt; are not available (like Nashhorn).</source>
          <target state="translated">블루 버드보다 기능을보다 빠르게 예약하는 방법이 필요한 경우 사용자 지정 스케줄러를 설정해야 할 수 있습니다. 또한 &lt;code&gt;setTimeout&lt;/code&gt; 및 &lt;code&gt;process.nextTick&lt;/code&gt; 과 같은 일반 타이밍 구성을 사용할 수없는 플랫폼 (예 : Nashhorn) 에서 블루 버드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3932ebbf539f8a931c6f13cf255530da552644ed" translate="yes" xml:space="preserve">
          <source>Setting the environment variable &lt;code&gt;NODE_ENV&lt;/code&gt; to &lt;code&gt;&quot;development&quot;&lt;/code&gt; also automatically enables long stack traces.</source>
          <target state="translated">환경 변수 &lt;code&gt;NODE_ENV&lt;/code&gt; 를 &lt;code&gt;&quot;development&quot;&lt;/code&gt; 로 설정하면 긴 스택 추적이 자동으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="4742ee0d05bf00094d42512b9006ce355572faaf" translate="yes" xml:space="preserve">
          <source>Several examples of databases follow.</source>
          <target state="translated">다음은 데이터베이스의 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="6e704260c9c34a30c1e1c6e9cc96dcbaba23b9e4" translate="yes" xml:space="preserve">
          <source>Several popular Android libraries use promises - for example the Parse Java API returns &lt;code&gt;Task&lt;/code&gt;s which are similar to JavaScript promises.</source>
          <target state="translated">여러 유명한 Android 라이브러리는 약속을 사용합니다. 예를 들어 Parse Java API는 JavaScript 약속과 유사한 &lt;code&gt;Task&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="79948cec8617f2b258642406e788e89df84d104b" translate="yes" xml:space="preserve">
          <source>Shorthand for &lt;code&gt;.then(null, null, handler);&lt;/code&gt;. Attach a progress handler that will be called if this promise is progressed. Returns a new promise chained from this promise.</source>
          <target state="translated">속기 대한 &lt;code&gt;.then(null, null, handler);&lt;/code&gt; . 이 약속이 진행될 때 호출 될 진행 처리기를 첨부하십시오. 이 약속과 연결된 새로운 약속을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d2d63e7d6731c58944766cb081aef40963e6cb50" translate="yes" xml:space="preserve">
          <source>Showing a live list of rejected promises</source>
          <target state="translated">거부 된 약속의 라이브 목록 표시</target>
        </trans-unit>
        <trans-unit id="8bbe005c943c12fa6ff0d2f8cafd5ad98bc70211" translate="yes" xml:space="preserve">
          <source>Signals that an operation has been aborted or cancelled. The default reason used by &lt;a href=&quot;cancel&quot;&gt;&lt;code&gt;.cancel&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">작업이 중단되었거나 취소되었음을 알립니다. &lt;a href=&quot;cancel&quot;&gt; &lt;code&gt;.cancel&lt;/code&gt; 이&lt;/a&gt; 사용하는 기본 이유 .</target>
        </trans-unit>
        <trans-unit id="299f23dc5dcc08c7bfee7c8ae781aacf85c196cb" translate="yes" xml:space="preserve">
          <source>Signals that an operation has timed out. Used as a custom cancellation reason in &lt;a href=&quot;timeout&quot;&gt;&lt;code&gt;.timeout&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">작업 시간이 초과되었음을 알립니다. &lt;a href=&quot;timeout&quot;&gt; &lt;code&gt;.timeout&lt;/code&gt; &lt;/a&gt; 에서 사용자 지정 취소 이유로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="46bf40da88360ad7bbfcf32d9dd42056cd2f6ff3" translate="yes" xml:space="preserve">
          <source>Significantly improve parallel promise performance and memory usage (+50% faster, -50% less memory)</source>
          <target state="translated">병렬 약속 성능 및 메모리 사용량을 크게 개선합니다 (+ 50 % 더 빠름, -50 % 더 적은 메모리)</target>
        </trans-unit>
        <trans-unit id="d63c65ce4045c196a80e2036ef184d1e29767129" translate="yes" xml:space="preserve">
          <source>Significantly improve performance of foreign bluebird thenables</source>
          <target state="translated">외국 블루 버드 그때의 성능을 대폭 향상</target>
        </trans-unit>
        <trans-unit id="730519283954b4569cc72648083ced3012f2475e" translate="yes" xml:space="preserve">
          <source>Similarly, with promises:</source>
          <target state="translated">마찬가지로 약속과 함께 :</target>
        </trans-unit>
        <trans-unit id="e16c84188a248cb435f2ade69bfef7f54bb36e8f" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;api/promise.all&quot;&gt;&lt;code&gt;Promise.all&lt;/code&gt;&lt;/a&gt; takes promises, it must also take jQuery deferreds, so the above can be shortened to:</source>
          <target state="translated">이후 &lt;a href=&quot;api/promise.all&quot;&gt; &lt;code&gt;Promise.all&lt;/code&gt; 이&lt;/a&gt; 약속을 소요 위를 단축 할 수 있도록, 또한, jQuery를의 deferreds를 취해야합니다 :</target>
        </trans-unit>
        <trans-unit id="71d62301257a57ffc03da0d5c42ed2549e221316" translate="yes" xml:space="preserve">
          <source>Since all objects support having properties you might still wonder why exactly does it have to be an error object and not just any object. In addition to supporting properties, an equally important feature necessary for values that are automatically propagated is the stack trace property (&lt;code&gt;.stack&lt;/code&gt;). A stack trace allows you easily find where an error originated from as it gives the code's call stack - along with line numbers for reference in code files.</source>
          <target state="translated">모든 객체가 속성을 지원하기 때문에 왜 객체가 아닌 오류 객체 여야 하는지를 여전히 궁금 할 것입니다. 속성을 지원하는 것 외에도 자동으로 전파되는 값에 필요한 똑같이 중요한 기능은 스택 추적 속성 ( &lt;code&gt;.stack&lt;/code&gt; )입니다. 스택 추적을 사용하면 코드의 호출 스택을 제공 할 때 오류가 발생한 위치를 코드 파일의 참조 번호와 함께 쉽게 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92d019d6c6f872eca710a5e9fe46091f1e234c2c" translate="yes" xml:space="preserve">
          <source>Since in bluebird &lt;a href=&quot;api/promisification&quot;&gt;&lt;code&gt;promisification&lt;/code&gt;&lt;/a&gt; is made trivial, you can get long stack traces all the time:</source>
          <target state="translated">블루 버드 &lt;a href=&quot;api/promisification&quot;&gt; &lt;code&gt;promisification&lt;/code&gt; &lt;/a&gt; 은 사소한 것이기 때문에 항상 긴 스택 추적을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd8d850f23fc1a81c14cb9cdd8a5e00431fefc26" translate="yes" xml:space="preserve">
          <source>Since the array passed to waterfall is static (always the same 3 functions) a plain old promise chain is used:</source>
          <target state="translated">워터 폴로 전달 된 배열은 정적이므로 (항상 동일한 3 개의 함수) 일반 오래된 약속 체인이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ead75c8725f0a9530a5abc673013177ab974cfdf" translate="yes" xml:space="preserve">
          <source>Small performance improvements for all collection methods</source>
          <target state="translated">모든 수집 방법에 대한 작은 성능 개선</target>
        </trans-unit>
        <trans-unit id="dc101ed1f69471502ee81d7871e2413721d60887" translate="yes" xml:space="preserve">
          <source>So how then could we represent a progress bar like dialog? Well the answer is to manage the progress through callbacks outside the promise API. Bluebird has since &lt;a href=&quot;deprecated-apis#progression&quot;&gt;deprecated the progression feature&lt;/a&gt; and offers an alternative which I hope to illustrate here.</source>
          <target state="translated">그렇다면 어떻게 대화 상자와 같은 진행 표시 줄을 나타낼 수 있습니까? 약속 API 외부의 콜백을 통해 진행 상황을 관리하는 것이 정답입니다. Bluebird는 이후 &lt;a href=&quot;deprecated-apis#progression&quot;&gt;진행 기능을 더 이상 사용하지 않으며&lt;/a&gt; 여기서 설명하고자하는 대안을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e1ae1ffa70bbe4990a8964de54d99ecd7b5fd6b5" translate="yes" xml:space="preserve">
          <source>So please write the same when using promises too:</source>
          <target state="translated">따라서 약속을 사용할 때도 똑같이 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="e0e6caa4611dfebbc5e6e21fabaf9c486084de89" translate="yes" xml:space="preserve">
          <source>Some examples of the above practice applied to some popular libraries:</source>
          <target state="translated">위 관행의 일부 예는 일부 인기있는 라이브러리에 적용되었습니다.</target>
        </trans-unit>
        <trans-unit id="328f2682f2d41aa9dcab87997132944918cfc2f4" translate="yes" xml:space="preserve">
          <source>Some nodebacks expect more than 1 success value but there is no mapping for this in the promise world. You may specify the option &lt;code&gt;spread&lt;/code&gt; to call the nodeback with multiple values when the fulfillment value is an array:</source>
          <target state="translated">일부 노드 백은 하나 이상의 성공 가치를 기대하지만 약속 세계에서는 이에 대한 매핑이 없습니다. 이행 값이 배열 인 경우 여러 값으로 노드 백을 호출하도록 &lt;code&gt;spread&lt;/code&gt; 옵션을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d38c75cc8957e65c44573a2e27f3885375d06448" translate="yes" xml:space="preserve">
          <source>Something missing from the above example is proper error handling. When it comes to promises it is a best practise to always &lt;em&gt;reject a promise with an Error&lt;/em&gt; and not with plain data such as an object, string, number, or null/undefined. The reasoning for this is promises are best used as a way to regain some of the syntax you have with the standard &lt;code&gt;try {} catch() {}&lt;/code&gt; blocks with asynchronous code.</source>
          <target state="translated">위 예제에서 누락 된 것은 올바른 오류 처리입니다. 약속에 관해서는 객체, 문자열, 숫자 또는 null / undefined와 같은 일반 데이터가 아닌 &lt;em&gt;오류가있는 약속&lt;/em&gt; 을 항상 &lt;em&gt;거부&lt;/em&gt; 하는 것이 가장 좋습니다 . 이를위한 추론은 비동기 코드를 사용하여 표준 &lt;code&gt;try {} catch() {}&lt;/code&gt; 블록으로 가지고있는 구문 중 일부를 다시 얻는 방법으로 가장 잘 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="f5366b89baa9bf31993646740e57cd8f67859925" translate="yes" xml:space="preserve">
          <source>Sometimes we want to find out when a single one time event has finished. For example - a stream is done. For this we can use &lt;a href=&quot;api/new-promise&quot;&gt;&lt;code&gt;new Promise&lt;/code&gt;&lt;/a&gt;. Note that this option should be considered only if &lt;a href=&quot;#working-with-callback-apis-using-the-node-convention&quot;&gt;automatic conversion&lt;/a&gt; isn't possible.</source>
          <target state="translated">때때로 우리는 한 번의 이벤트가 언제 끝났는지 알고 싶어합니다. 예를 들어 스트림이 완료됩니다. 이를 위해 우리는 &lt;a href=&quot;api/new-promise&quot;&gt; &lt;code&gt;new Promise&lt;/code&gt; &lt;/a&gt; 사용할 수 있습니다 . 이 옵션은 &lt;a href=&quot;#working-with-callback-apis-using-the-node-convention&quot;&gt;자동 변환&lt;/a&gt; 이 불가능한 경우에만 고려해야 합니다.</target>
        </trans-unit>
        <trans-unit id="c0b9d85f33b2e758641f19550f5a9be3023ea242" translate="yes" xml:space="preserve">
          <source>Sometimes you have to work with APIs that are inconsistent and do not follow a common convention.</source>
          <target state="translated">일관성이없고 일반적인 규칙을 따르지 않는 API로 작업해야하는 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="47f7595fc4eaf9c4327785c6f28cc0a3cb93f37a" translate="yes" xml:space="preserve">
          <source>Sparse array holes are not skipped by collection methods but treated as existing elements with &lt;code&gt;undefined&lt;/code&gt; value</source>
          <target state="translated">희소 배열 구멍은 수집 방법으로 건너 뛰지 않고 &lt;code&gt;undefined&lt;/code&gt; 값을 가진 기존 요소로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="334f0f329646de4898c801e89bc81110c62b9723" translate="yes" xml:space="preserve">
          <source>Start the chain of promises with &lt;code&gt;Promise.try&lt;/code&gt;. Any synchronous exceptions will be turned into rejections on the returned promise.</source>
          <target state="translated">&lt;code&gt;Promise.try&lt;/code&gt; 로 약속 체인을 시작하십시오 . 모든 동기 예외는 반환 된 약속에서 거부로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="7544908a62ca43e11724d7886c37028c419b528e" translate="yes" xml:space="preserve">
          <source>Starting from 2.7.0 all bluebird instances also fire rejection events globally so that applications can register one universal hook for them.</source>
          <target state="translated">2.7.0부터 모든 블루 버드 인스턴스는 전역 적으로 거부 이벤트를 발생시켜 애플리케이션이 하나의 범용 후크를 등록 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="3603ca6749bcc3136f65ac99d1a525e581f1708b" translate="yes" xml:space="preserve">
          <source>Stream libraries tend to serve a different purpose than promise libraries. Unlike promise libraries streams can represent multiple values.</source>
          <target state="translated">스트림 라이브러리는 약속 라이브러리와 다른 목적으로 사용되는 경향이 있습니다. promise 라이브러리와 달리 스트림은 여러 값을 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a8475ec2272fa6b1c6b05f2bd678210b89009cf" translate="yes" xml:space="preserve">
          <source>Such a constructor can be minimally created like so:</source>
          <target state="translated">이러한 생성자는 다음과 같이 최소한으로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d58681e9c8fb0c509a2cfc71f3a1d6ba692e9b25" translate="yes" xml:space="preserve">
          <source>Such policies could include:</source>
          <target state="translated">이러한 정책에는 다음이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f1919f0096a6b3087e18c842a5097f047b54d80" translate="yes" xml:space="preserve">
          <source>Such wrappers should be rare, if they're common for the reason that the promise library cannot generically promisify them, you should file an issue.</source>
          <target state="translated">그러한 랩퍼는 약속 라이브러리가 일반적으로 약속 할 수없는 이유로 흔하다면 문제를 제기해야합니다.</target>
        </trans-unit>
        <trans-unit id="0158596539b88e3d14cfe51fe82aba75fca71681" translate="yes" xml:space="preserve">
          <source>Summary of breaking changes</source>
          <target state="translated">주요 변경 사항 요약</target>
        </trans-unit>
        <trans-unit id="c1e51f0164b5bdc44f9880dc21c2988e1430f473" translate="yes" xml:space="preserve">
          <source>Support primitives in catch filters</source>
          <target state="translated">캐치 필터에서 프리미티브 지원</target>
        </trans-unit>
        <trans-unit id="34c6c2ddc426343eed559ce47d4c777df69eba0c" translate="yes" xml:space="preserve">
          <source>Supported platforms</source>
          <target state="translated">지원되는 플랫폼</target>
        </trans-unit>
        <trans-unit id="f02259e275f481a7fdda40736a24df99f0cd3a67" translate="yes" xml:space="preserve">
          <source>Surfacing unhandled errors</source>
          <target state="translated">처리되지 않은 오류 표시</target>
        </trans-unit>
        <trans-unit id="a3f9e4820c3b2f7bbea724b622595d004feda9b4" translate="yes" xml:space="preserve">
          <source>Swallowing all errors (challenge your debugging skills)</source>
          <target state="translated">모든 오류를 삼키기 (디버깅 기술에 도전)</target>
        </trans-unit>
        <trans-unit id="9d4e83066087dd1079c656c148313dafa0d0a48a" translate="yes" xml:space="preserve">
          <source>Synchronous inspection</source>
          <target state="translated">동기 검사</target>
        </trans-unit>
        <trans-unit id="560cd166df807614aa93c9f2544b674451945594" translate="yes" xml:space="preserve">
          <source>Synchronous inspection allows you to retrieve the fulfillment value of an already fulfilled promise or the rejection reason of an already rejected promise synchronously.</source>
          <target state="translated">동기 검사를 통해 이미 이행 된 약속의 이행 값 또는 이미 거부 된 약속의 거부 사유를 동 기적으로 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f22a0a957f0468c0084e1e9ae07dd450cc45ad2" translate="yes" xml:space="preserve">
          <source>That is, you can return either a promise &lt;em&gt;or a plain value&lt;/em&gt; from a &lt;code&gt;then&lt;/code&gt; without wrapping it.</source>
          <target state="translated">그것은 당신이 약속 중 하나를 반환 할 수 있습니다 &lt;em&gt;또는 일반 값을&lt;/em&gt; A로부터 &lt;code&gt;then&lt;/code&gt; 을 포장하지 않고.</target>
        </trans-unit>
        <trans-unit id="34bb1fab188a923aeae77d6108a07ce0c4ce134b" translate="yes" xml:space="preserve">
          <source>That means &lt;code&gt;value&lt;/code&gt; is bound at the time of calling &lt;a href=&quot;return&quot;&gt;&lt;code&gt;.return&lt;/code&gt;&lt;/a&gt; so this will not work as expected:</source>
          <target state="translated">즉 , &lt;a href=&quot;return&quot;&gt; &lt;code&gt;.return&lt;/code&gt; &lt;/a&gt; 을 호출 할 때 &lt;code&gt;value&lt;/code&gt; 이 바인딩 되어 예상대로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6e5c6863d3d57d6db5e4a2e948905db8b10466ee" translate="yes" xml:space="preserve">
          <source>That means when you have a problem there probably isn't an existing function tailored exactly to that problem but instead you can just combine the existing utilities to arrive at a solution. The upside of this is that you don't need to come up with all these different functions to solve problems that are not that different from each other. The most important thing to do when migrating from async to bluebird is this profound shift in philosophy.</source>
          <target state="translated">즉, 문제가 발생했을 때 해당 문제에 정확히 맞게 조정 된 기존 기능이 아니라 기존 유틸리티를 결합하여 솔루션에 도달 할 수 있습니다. 이것의 장점은 서로 다르지 않은 문제를 해결하기 위해 이러한 모든 기능을 사용할 필요가 없다는 것입니다. 비동기에서 블루 버드로 마이그레이션 할 때해야 할 가장 중요한 일은 철학의이 중대한 변화입니다.</target>
        </trans-unit>
        <trans-unit id="c31fbbf769a579d258b6c345c7359a66afd6aa22" translate="yes" xml:space="preserve">
          <source>That said, if you have code written using jQuery deferred methods, such as &lt;code&gt;.then&lt;/code&gt;, &lt;code&gt;.done&lt;/code&gt; and so on, you cannot drop-in replace the jQuery deferred with a bluebird promise in that code. Despite having the same names, jQuery deferred methods have different semantics than bluebird promise methods. These differences are due to the completely different goals of the implementations. Bluebird is &lt;a href=&quot;http://en.wikipedia.org/wiki/Domain-specific_language&quot;&gt;an internal DSL&lt;/a&gt; for the domain of asynchronous control flow while jQuery deferreds are a callback aggregator utility (&quot;glorified event emitters&quot;).</source>
          <target state="translated">즉, &lt;code&gt;.then&lt;/code&gt; , &lt;code&gt;.done&lt;/code&gt; 등과 같은 jQuery 지연 메소드를 사용하여 작성된 코드가 있으면 해당 코드에서 블루 버드 약속으로 지연된 jQuery를 대체 할 수 없습니다. 이름은 동일하지만 jQuery 지연 메소드는 블루 버드 약속 메소드와 다른 의미를 갖습니다. 이러한 차이점은 구현의 목표가 완전히 다르기 때문입니다. Bluebird는 비동기 제어 흐름 도메인을위한 &lt;a href=&quot;http://en.wikipedia.org/wiki/Domain-specific_language&quot;&gt;내부 DSL&lt;/a&gt; 이며 jQuery 지연은 콜백 애그리 게이터 유틸리티 ( &quot;Glorified Event Emitter&quot;)입니다.</target>
        </trans-unit>
        <trans-unit id="9576ae41ed6c2fc691cc3233977df2602674a9e5" translate="yes" xml:space="preserve">
          <source>The &quot;a promise was created in a handler but not returned from it&quot; warning now adds the bluebird API method used to create the non-returned promise at the top of the warning stack</source>
          <target state="translated">&quot;핸들러에서 약속이 생성되었지만 반환되지 않음&quot;경고에 경고 스택 맨 위에 반환되지 않은 약속을 만드는 데 사용되는 블루 버드 API 메서드가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="2387bf8a5eec038b8dc1d6a136dd30eb885c69f6" translate="yes" xml:space="preserve">
          <source>The &quot;a promise was created in a handler but not returned from it&quot; warning now highlights the file, line and column where the return statement is missing.</source>
          <target state="translated">&quot;핸들러에서 핸들러가 작성되었지만 리턴되지 않음&quot;경고는 이제 리턴 명령문이 누락 된 파일, 행 및 열을 강조 표시합니다.</target>
        </trans-unit>
        <trans-unit id="9172632794382321ca96b52eb375dcf229573bb4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;reflect&quot;&gt;&lt;code&gt;.reflect&lt;/code&gt;&lt;/a&gt; method returns a promise that is always successful when this promise is settled. Its fulfillment value is an object that implements the &lt;a href=&quot;promiseinspection&quot;&gt;&lt;code&gt;PromiseInspection&lt;/code&gt;&lt;/a&gt; interface and reflects the resolution of this promise.</source>
          <target state="translated">&lt;a href=&quot;reflect&quot;&gt; &lt;code&gt;.reflect&lt;/code&gt; &lt;/a&gt; 방법은이 약속이 정착 될 때 항상 성공 약속을 반환합니다. 이행 가치는 &lt;a href=&quot;promiseinspection&quot;&gt; &lt;code&gt;PromiseInspection&lt;/code&gt; &lt;/a&gt; 인터페이스 를 구현 하고이 약속의 해결을 반영 하는 객체입니다 .</target>
        </trans-unit>
        <trans-unit id="dcc5097b492ec34ac1dac37541df7fa6d5523657" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.props&lt;/code&gt; method expects to receive an object.</source>
          <target state="translated">&lt;code&gt;.props&lt;/code&gt; 의 방법은 객체를받을 것으로 기대하고있다.</target>
        </trans-unit>
        <trans-unit id="b0eb698af924dfb32cf54d281b02888c506ead09" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.then(success, fail)&lt;/code&gt; anti-pattern</source>
          <target state="translated">&lt;code&gt;.then(success, fail)&lt;/code&gt; 안티 패턴</target>
        </trans-unit>
        <trans-unit id="0fcdb3492bd1cc7aa9ff1b548b88ce52afafa5d5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.then&lt;/code&gt; signature is mostly about interop, there is &lt;em&gt;almost&lt;/em&gt; never a reason to use &lt;code&gt;.then(success, fail)&lt;/code&gt; in application code. It is even awkward to express it in the sync parallel:</source>
          <target state="translated">&lt;code&gt;.then&lt;/code&gt; 서명이 없습니다 대부분 상호 운용성에 관한 &lt;em&gt;거의&lt;/em&gt; 사용하는 이유는 결코 &lt;code&gt;.then(success, fail)&lt;/code&gt; 응용 프로그램 코드에서가. 동기화 병렬로 표현하는 것도 어색합니다.</target>
        </trans-unit>
        <trans-unit id="e944db85ee16051290ad72f2026b7a41fb2a4813" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;map&lt;/code&gt; operation is expecting an array here (or a promise on one) and instead gets the number &lt;code&gt;5&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;map&lt;/code&gt; 작업은 여기에 배열을 기대하고있다 (또는 하나에 약속) 대신 숫자 얻는 &lt;code&gt;5&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f752091c174b33d9da17500cd7d1d3ae7eb2bd9" translate="yes" xml:space="preserve">
          <source>The Explicit Construction Anti-Pattern</source>
          <target state="translated">명백한 구성 안티 패턴</target>
        </trans-unit>
        <trans-unit id="7ae99b6910e577d7be696210c2dbfc212e81ffa5" translate="yes" xml:space="preserve">
          <source>The JavaScript is the same as the &lt;code&gt;PromptDialog&lt;/code&gt; only we will add a &lt;code&gt;setProgress()&lt;/code&gt; method:</source>
          <target state="translated">JavaScript는 &lt;code&gt;PromptDialog&lt;/code&gt; 와 동일 하며 &lt;code&gt;setProgress()&lt;/code&gt; 메소드를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="987db8ad0cd3c6e2880ebfda0417324d809a8643" translate="yes" xml:space="preserve">
          <source>The above calls the function &lt;code&gt;processImage()&lt;/code&gt;&lt;em&gt;immediately&lt;/em&gt; and passes the result to &lt;a href=&quot;api/then&quot;&gt;&lt;code&gt;.then()&lt;/code&gt;&lt;/a&gt; (which is most likely &lt;code&gt;undefined&lt;/code&gt; - the default return value when a function doesn't return anything).</source>
          <target state="translated">위의 함수는 &lt;code&gt;processImage()&lt;/code&gt; 함수를 &lt;em&gt;즉시&lt;/em&gt; 호출하고 결과를 &lt;a href=&quot;api/then&quot;&gt; &lt;code&gt;.then()&lt;/code&gt; &lt;/a&gt; 전달합니다 (이것은 &lt;code&gt;undefined&lt;/code&gt; -함수가 아무것도 반환하지 않을 때의 기본 반환 값).</target>
        </trans-unit>
        <trans-unit id="1c5b45d618d205b79bdd2339e1eb511e0597ceee" translate="yes" xml:space="preserve">
          <source>The above can also be written as (with a caveat, see below)</source>
          <target state="translated">위의 내용은 다음과 같이 쓸 수도 있습니다 (주의 사항은 아래 참조).</target>
        </trans-unit>
        <trans-unit id="b9d96d94c20e29d7be811aad09d5f2fc69d847ac" translate="yes" xml:space="preserve">
          <source>The above does a &lt;code&gt;console.log&lt;/code&gt; of &lt;code&gt;my-element&lt;/code&gt;. Doing it this way is necessary because neither of the methods (&lt;code&gt;getElementById&lt;/code&gt;, &lt;code&gt;console.log&lt;/code&gt;) can be called as stand-alone methods.</source>
          <target state="translated">위의 내용은 &lt;code&gt;console.log&lt;/code&gt; of &lt;code&gt;my-element&lt;/code&gt; 입니다. 메소드 ( &lt;code&gt;getElementById&lt;/code&gt; , &lt;code&gt;console.log&lt;/code&gt; )를 독립형 메소드로 호출 할 수 없으므로이 방법 을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="4ff51746636ecc3655cfcaa3b14edb8e79b82038" translate="yes" xml:space="preserve">
          <source>The above ensures &lt;code&gt;getConnection&lt;/code&gt; fulfills the contract of a promise-returning function of never throwing a synchronous exception. Also see &lt;a href=&quot;promise.try&quot;&gt;&lt;code&gt;Promise.try&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;promise.method&quot;&gt;&lt;code&gt;Promise.method&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">위의 내용은 &lt;code&gt;getConnection&lt;/code&gt; 이 동기 예외를 발생시키지 않는 약속 반환 기능의 계약을 이행 하도록 보장합니다 . &lt;a href=&quot;promise.try&quot;&gt; &lt;code&gt;Promise.try&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;promise.method&quot;&gt; &lt;code&gt;Promise.method&lt;/code&gt; &lt;/a&gt; 도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ec563887821c925f0b9a15bbaeb4d94ba4967bb9" translate="yes" xml:space="preserve">
          <source>The above function can then make everyone happy.</source>
          <target state="translated">위의 기능은 모든 사람을 행복하게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb5a0fcd51c35945773869b7451e685e33fe2b5b" translate="yes" xml:space="preserve">
          <source>The above has a direct translation:</source>
          <target state="translated">위의 직접 번역이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="be3a5d7ac08554519f84fa1292d020a1294faf0a" translate="yes" xml:space="preserve">
          <source>The above without &lt;a href=&quot;bind&quot;&gt;&lt;code&gt;.bind&lt;/code&gt;&lt;/a&gt; could be achieved with:</source>
          <target state="translated">&lt;a href=&quot;bind&quot;&gt; &lt;code&gt;.bind&lt;/code&gt; &lt;/a&gt; 가 없는 위의 내용 은 다음과 같이 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6770726e6458fe58ea6b5f4fd62bd9042424df5" translate="yes" xml:space="preserve">
          <source>The actual subscription API depends on the environment.</source>
          <target state="translated">실제 구독 API는 환경에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="f16cc25950a83115317503e4adef79079d08a456" translate="yes" xml:space="preserve">
          <source>The advantage of using &lt;code&gt;.suppressUnhandledRejections()&lt;/code&gt; over &lt;code&gt;.catch(function(){})&lt;/code&gt; is that it doesn't increment the branch count of the promise. Branch counts matter when using cancellation because a promise will only be cancelled if all of its branches want to cancel it.</source>
          <target state="translated">&lt;code&gt;.catch(function(){})&lt;/code&gt; &lt;code&gt;.suppressUnhandledRejections()&lt;/code&gt; 비해 .suppressUnhandledRejections () 를 사용하는 이점은 약속의 분기 수를 늘리지 않는다는 것입니다. 약속은 모든 지점에서 취소하려는 경우에만 취소되므로 취소를 사용할 때 지점 수는 중요합니다.</target>
        </trans-unit>
        <trans-unit id="9c56f54fb10413e626d1f27ae289fc09dbb6d933" translate="yes" xml:space="preserve">
          <source>The advantages of the new cancellation compared to the old cancellation are:</source>
          <target state="translated">기존 취소와 비교하여 새 취소의 장점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f38af64a279ce9559ab9430fe352d1985725b5b6" translate="yes" xml:space="preserve">
          <source>The cancellation feature is &lt;strong&gt;by default turned off&lt;/strong&gt;, you can enable it using &lt;a href=&quot;promise.config&quot;&gt;&lt;code&gt;Promise.config&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">취소 기능은 &lt;strong&gt;기본적으로 해제되어&lt;/strong&gt; 있으며 &lt;a href=&quot;promise.config&quot;&gt; &lt;code&gt;Promise.config&lt;/code&gt; 를&lt;/a&gt; 사용하여 활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6200a8a72cc85fe3cd189630a2f941b849b20c71" translate="yes" xml:space="preserve">
          <source>The concurrency limit applies to Promises returned by the mapper function and it basically limits the number of Promises created. For example, if &lt;code&gt;concurrency&lt;/code&gt; is &lt;code&gt;3&lt;/code&gt; and the mapper callback has been called enough so that there are three returned Promises currently pending, no further callbacks are called until one of the pending Promises resolves. So the mapper function will be called three times and it will be called again only after at least one of the Promises resolves.</source>
          <target state="translated">동시성 제한은 매퍼 함수가 반환하는 약속에 적용되며 기본적으로 생성 된 약속 수를 제한합니다. 예를 들어, &lt;code&gt;concurrency&lt;/code&gt; 이 &lt;code&gt;3&lt;/code&gt; 이고 매퍼 콜백이 충분히 호출되어 현재 보류중인 반환 된 약속 3 개가있을 경우 보류중인 약속 중 하나가 해결 될 때까지 더 이상 콜백이 호출되지 않습니다. 따라서 매퍼 기능이 세 번 호출되고 약속 중 하나 이상이 해결 된 후에 만 ​​다시 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="31ab830fa32b91594137493c8717fb7b7a2afbf7" translate="yes" xml:space="preserve">
          <source>The default approach of bluebird is to immediately log the stack trace when there is an unhandled rejection. This is similar to how uncaught exceptions cause the stack trace to be logged so that you have something to work with when something is not working as expected.</source>
          <target state="translated">블루 버드의 기본 접근 방식은 처리되지 않은 거부가있을 때 스택 추적을 즉시 기록하는 것입니다. 이는 catch되지 않은 예외로 인해 스택 추적이 기록되어 예상대로 작동하지 않을 때 작업 할 수있는 방법과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="79301b912f99cabfc6b1d506271ff79825a49941" translate="yes" xml:space="preserve">
          <source>The default filter function will ignore properties that start with a leading underscore, properties that are not valid JavaScript identifiers and constructor functions (function which have enumerable properties in their &lt;code&gt;.prototype&lt;/code&gt;).</source>
          <target state="translated">기본 필터 함수는 밑줄로 시작하는 속성, 유효한 JavaScript 식별자가 아닌 속성 및 생성자 함수 ( &lt;code&gt;.prototype&lt;/code&gt; 에 열거 가능한 속성이있는 함수)를 무시 합니다.</target>
        </trans-unit>
        <trans-unit id="fb7c7d829660ad1b607e4ff44a0e6cb994eacdf1" translate="yes" xml:space="preserve">
          <source>The dialog interface might look like this:</source>
          <target state="translated">대화 상자 인터페이스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2ec7326b7197ff7aa9ec6904e534048cbee04708" translate="yes" xml:space="preserve">
          <source>The difference between a &lt;code&gt;Task&lt;/code&gt; and a promise are that a task might not be started and might require a &lt;code&gt;.Start&lt;/code&gt; call where a promise always represents an already started operation.</source>
          <target state="translated">&lt;code&gt;Task&lt;/code&gt; 과 약속 의 차이점은 작업이 시작되지 않았고 약속이 항상 이미 시작된 작업을 나타내는 &lt;code&gt;.Start&lt;/code&gt; 호출 이 필요할 수 있다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="801933290ac764cce3fee90e0b881f138a330a0e" translate="yes" xml:space="preserve">
          <source>The entire prototype chain of the object is promisified on the object. Only enumerable are considered. If the object already has a promisified version of the method, it will be skipped. The target methods are assumed to conform to node.js callback convention of accepting a callback as last argument and calling that callback with error as the first argument and success value on the second argument. If the node method calls its callback with multiple success values, the fulfillment value will be an array of them.</source>
          <target state="translated">객체의 전체 프로토 타입 체인이 객체에서 약속됩니다. 열거 가능한 것만 고려됩니다. 객체에 이미 약속 된 버전의 메소드가있는 경우 건너 뜁니다. 대상 메소드는 마지막 인수로 콜백을 수락하고 첫 번째 인수로 오류가 있고 두 번째 인수의 성공 값으로 콜백을 호출하는 node.js 콜백 규칙을 따르는 것으로 가정합니다. 노드 메소드가 여러 성공 값으로 콜백을 호출하는 경우 이행 값은 이들의 배열입니다.</target>
        </trans-unit>
        <trans-unit id="d6be4df893a1137d6b3ab84348ff99be431c883e" translate="yes" xml:space="preserve">
          <source>The explicit construction anti-pattern</source>
          <target state="translated">명시 적 구성 반 패턴</target>
        </trans-unit>
        <trans-unit id="40e45891046aa649e068bb199da2efeaca661dda" translate="yes" xml:space="preserve">
          <source>The following lifecycle events are available:</source>
          <target state="translated">다음과 같은 수명주기 이벤트를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b55e86c0fc753c356970890234eaa0b0ce6daee6" translate="yes" xml:space="preserve">
          <source>The function being called expects a Promise, but is given something different. There are two main reasons why this may occur.</source>
          <target state="translated">호출되는 함수에는 약속이 필요하지만 다른 것이 제공됩니다. 이것이 발생할 수있는 두 가지 주요 이유가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fa7caae49fcd453bbf69746e24b32d9fbb6ba35" translate="yes" xml:space="preserve">
          <source>The generic promisification is likely to be faster because it can use internals directly but also handles edge cases like &lt;code&gt;libraryFunction&lt;/code&gt; throwing synchronously or using multiple success values.</source>
          <target state="translated">일반적인 약속은 내부를 직접 사용할 수 있기 때문에 더 빠를 것 &lt;code&gt;libraryFunction&lt;/code&gt; 이 동기식으로 던지거나 여러 성공 값을 사용하는 등의 경우도 처리 합니다.</target>
        </trans-unit>
        <trans-unit id="7b2748080c6d9715db0ad2710e45478c0f7c5d34" translate="yes" xml:space="preserve">
          <source>The global events are:</source>
          <target state="translated">글로벌 이벤트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ac6f6a9e8f68d43e290c78abcefdf4dfcc31bc80" translate="yes" xml:space="preserve">
          <source>The handler functions are now closures, thus less efficient and not reusable</source>
          <target state="translated">핸들러 함수는 이제 클로저이므로 덜 효율적이며 재사용 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="578ba1114aa6fcded1f091d1702ddf63eaf4722c" translate="yes" xml:space="preserve">
          <source>The implementations for this benchmark are found in &lt;a href=&quot;https://github.com/petkaantonov/bluebird/tree/master/benchmark/doxbee-sequential&quot;&gt;&lt;code&gt;benchmark/doxbee-sequential&lt;/code&gt;&lt;/a&gt; directory.</source>
          <target state="translated">이 벤치 마크에 대한 구현은 &lt;a href=&quot;https://github.com/petkaantonov/bluebird/tree/master/benchmark/doxbee-sequential&quot;&gt; &lt;code&gt;benchmark/doxbee-sequential&lt;/code&gt; &lt;/a&gt; 디렉토리에 있습니다.</target>
        </trans-unit>
        <trans-unit id="2beec3e3018a687405477c67e8972c8a6a40dae3" translate="yes" xml:space="preserve">
          <source>The implementations for this benchmark are found in &lt;a href=&quot;https://github.com/petkaantonov/bluebird/tree/master/benchmark/madeup-parallel&quot;&gt;&lt;code&gt;benchmark/madeup-parallel&lt;/code&gt;&lt;/a&gt; directory.</source>
          <target state="translated">이 벤치 마크에 대한 구현은 &lt;a href=&quot;https://github.com/petkaantonov/bluebird/tree/master/benchmark/madeup-parallel&quot;&gt; &lt;code&gt;benchmark/madeup-parallel&lt;/code&gt; &lt;/a&gt; 디렉토리에 있습니다.</target>
        </trans-unit>
        <trans-unit id="9448500cacb1ff64a30efd5b0e2bea57a588d796" translate="yes" xml:space="preserve">
          <source>The mapper function for a given item is called as soon as possible, that is, when the promise for that item's index in the input array is fulfilled. This doesn't mean that the result array has items in random order, it means that &lt;code&gt;.map&lt;/code&gt; can be used for concurrency coordination unlike &lt;code&gt;.all&lt;/code&gt;.</source>
          <target state="translated">주어진 항목에 대한 매퍼 함수는 가능한 빨리, 즉 입력 배열에서 해당 항목의 인덱스에 대한 약속이 이행 될 때 호출됩니다. 이것은 결과 배열에 임의의 순서로 항목이 있음을 의미하지는 않으며 &lt;code&gt;.all&lt;/code&gt; 은 과 달리 동시성 조정에 &lt;code&gt;.map&lt;/code&gt; 을 사용할 수 있음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="6416948697e16aeabbf92ec68782960804a2782d" translate="yes" xml:space="preserve">
          <source>The methods of a &lt;code&gt;PromiseResolver&lt;/code&gt; have no effect if the fate of the underlying promise is already decided (follow, reject, fulfill).</source>
          <target state="translated">기본 약속의 운명이 이미 결정된 경우 &lt;code&gt;PromiseResolver&lt;/code&gt; 의 방법 은 아무런 영향을 미치지 않습니다 (추종, 거부, 이행).</target>
        </trans-unit>
        <trans-unit id="666da53e9ba5fafe397413f91312c555ed1b2845" translate="yes" xml:space="preserve">
          <source>The mortals that can handle it may now release Zalgo by &lt;code&gt;require(&quot;bluebird/zalgo&quot;);&lt;/code&gt;</source>
          <target state="translated">그것을 다룰 수있는 필사자들은 이제 &lt;code&gt;require(&quot;bluebird/zalgo&quot;);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="788c3f097a42e7ff06bdab38fdaf7df400494dfe" translate="yes" xml:space="preserve">
          <source>The new cancellation has &quot;don't care&quot; semantics while the old cancellation had abort semantics. Cancelling a promise simply means that its handler callbacks will not be called.</source>
          <target state="translated">새로운 취소는 의미를 &quot;무관&quot;하는 반면, 오래된 취소는 의미를 중단했습니다. 약속을 취소한다는 것은 단순히 핸들러 콜백이 호출되지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="9a98aedc50b84c7ebb0badc2de651f3ecf8937b9" translate="yes" xml:space="preserve">
          <source>The object predicate passed to &lt;code&gt;.catch&lt;/code&gt; in the above code (&lt;code&gt;{code: 'ENOENT'}&lt;/code&gt;) is shorthand for a predicate function &lt;code&gt;function predicate(e) { return isObject(e) &amp;amp;&amp;amp; e.code == 'ENOENT' }&lt;/code&gt;, I.E. loose equality is used.</source>
          <target state="translated">위 코드에서 &lt;code&gt;.catch&lt;/code&gt; 에 전달 된 오브젝트 술어 ( &lt;code&gt;{code: 'ENOENT'}&lt;/code&gt; )는 술어 함수 &lt;code&gt;function predicate(e) { return isObject(e) &amp;amp;&amp;amp; e.code == 'ENOENT' }&lt;/code&gt; 이며 IE는 느슨합니다. 평등이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="25c421b7ad33c6aa4c4ac1a5b06c22ec76d37875" translate="yes" xml:space="preserve">
          <source>The old progression API was meant to be used for tracking the progress of promise resolution. In retrospect, it did not work or compose very well. We understand that problem better now and the use case could be better solved without it.</source>
          <target state="translated">이전 진행 API는 약속 해결 진행률을 추적하는 데 사용되었습니다. 돌이켜 보면 제대로 작동하지 않았거나 잘 작성되지 않았습니다. 우리는 이제 문제가 더 잘 이해되고 유스 케이스가 없으면 더 잘 해결할 수 있음을 이해합니다.</target>
        </trans-unit>
        <trans-unit id="090f1f6fbdfbd7a3e0db64396e47bb24d64eb73a" translate="yes" xml:space="preserve">
          <source>The order &lt;code&gt;map&lt;/code&gt; calls the mapper function on the array elements is not specified, there is no guarantee on the order in which it'll execute the &lt;code&gt;map&lt;/code&gt;er on the elements. For order guarantee in sequential execution - see &lt;a href=&quot;promise.mapseries&quot;&gt;&lt;code&gt;Promise.mapSeries&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">순서 &lt;code&gt;map&lt;/code&gt; 은 배열 요소가 지정되지 않은 맵퍼 함수를 ​​호출하므로 요소에서 &lt;code&gt;map&lt;/code&gt; 실행하는 순서는 보장되지 않습니다 . 순차적 실행에서의 주문 보장은 &lt;a href=&quot;promise.mapseries&quot;&gt; &lt;code&gt;Promise.mapSeries&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="22323bb03a1bb54a462c5535aaf1a55e597ca564" translate="yes" xml:space="preserve">
          <source>The problem with the above is that &lt;code&gt;getConnection&lt;/code&gt; itself might throw for some reason and if it does we'll get a synchronous rejection. An asynchronous operation should always be asynchronous to prevent double guarding and race conditions so it's best to always put the sync parts inside the promise constructor as such:</source>
          <target state="translated">위의 문제는 &lt;code&gt;getConnection&lt;/code&gt; 자체가 어떤 이유로 던질 수 있으며 동기화되지 않으면 동기 거부가 발생한다는 것입니다. 비동기식 작업은 이중 보호 및 경쟁 조건을 방지하기 위해 항상 비동기식이어야하므로 약속 부분 생성자 안에 항상 동기화 파트를 배치하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="5b81307bb00a714d49523b7e191e0b6160f8ce58" translate="yes" xml:space="preserve">
          <source>The promisifier gets a reference to the original method and should return a function which returns a promise.</source>
          <target state="translated">약속은 원래 방법에 대한 참조를 얻고 약속을 반환하는 함수를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="1a87fc5ef703ad3003e186be301223055a0f1187" translate="yes" xml:space="preserve">
          <source>The resolver function is passed a callback that expects to be called back according to error-first node conventions.</source>
          <target state="translated">리졸버 함수에는 오류 우선 노드 규칙에 따라 콜백 될 것으로 예상되는 콜백이 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="db5aac58e5c09043c491849101f61a81a5b4d12d" translate="yes" xml:space="preserve">
          <source>The resolver is called synchronously (the following is for documentation purposes and not idiomatic code):</source>
          <target state="translated">리졸버는 동기식으로 호출됩니다 (다음은 관용적 코드가 아닌 문서 목적으로 사용됨).</target>
        </trans-unit>
        <trans-unit id="fa4bfc9835f1db3d068610dc3f23387d9b6dbcae" translate="yes" xml:space="preserve">
          <source>The same can also be written more concisely with &lt;code&gt;Function.prototype.bind&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Function.prototype.bind&lt;/code&gt; 를 사용 하여 동일하게 더 간결하게 작성할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e4d032a40184c01ff45a4fcd6a47f5f6ed12cc2d" translate="yes" xml:space="preserve">
          <source>The same thing can be done with less code using jQuery's &lt;a href=&quot;https://api.jquery.com/on/#event-names&quot;&gt;event namespacing&lt;/a&gt;.</source>
          <target state="translated">jQuery의 &lt;a href=&quot;https://api.jquery.com/on/#event-names&quot;&gt;이벤트 네임 스페이스를&lt;/a&gt; 사용하여 적은 코드로 동일한 작업을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3c2a20abb7e468fc73f206d7f17b3365726ea73c" translate="yes" xml:space="preserve">
          <source>The second argument passed to a disposer is the result promise of the using block, which you can inspect synchronously.</source>
          <target state="translated">Disposer에 전달되는 두 번째 인수는 using 블록의 결과 약속이며 동 기적으로 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e1062ee61728ebe80f9bce80f90c97c30f5a642" translate="yes" xml:space="preserve">
          <source>The situation can be fixed with &lt;code&gt;.finally&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;.finally&lt;/code&gt; 로 상황을 해결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d8cfd5d14e8e321897ce3ab8e2b61c1f01768a60" translate="yes" xml:space="preserve">
          <source>The solution is to either convert it to a promise by calling &lt;code&gt;Promise.resolve&lt;/code&gt; on it or &lt;code&gt;Promise.promisify&lt;/code&gt; if it's a callback:</source>
          <target state="translated">이 솔루션 중 하나를 호출하여 약속로 변환하는 것입니다 &lt;code&gt;Promise.resolve&lt;/code&gt; 를 그것은 나에 &lt;code&gt;Promise.promisify&lt;/code&gt; 가 콜백의 경우 :</target>
        </trans-unit>
        <trans-unit id="a959d4cee575b4382df36392cd8df64e24184dbc" translate="yes" xml:space="preserve">
          <source>The stack trace for &lt;a href=&quot;warning-explanations#warning-a-promise-was-created-in-a-handler-but-none-were-returned-from-it&quot;&gt;forgotten return warnings&lt;/a&gt; is more useful now.</source>
          <target state="translated">&lt;a href=&quot;warning-explanations#warning-a-promise-was-created-in-a-handler-but-none-were-returned-from-it&quot;&gt;잊혀진 리턴 경고에&lt;/a&gt; 대한 스택 추적 이 이제 더 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b7cfeae4442044317b39c717825ad07af88a84b2" translate="yes" xml:space="preserve">
          <source>The standard &lt;a href=&quot;http://promises-aplus.github.io/promises-spec/&quot;&gt;Promises/A+ &lt;code&gt;.then()&lt;/code&gt;&lt;/a&gt; is still supported by Bluebird and support for it will continue indefinitely . However, the variant accepting a third &lt;code&gt;progressHandler&lt;/code&gt; argument is no longer supported.</source>
          <target state="translated">표준 &lt;a href=&quot;http://promises-aplus.github.io/promises-spec/&quot;&gt;Promises / A + &lt;code&gt;.then()&lt;/code&gt; &lt;/a&gt; 은 여전히 ​​블루 버드에서 지원되며 이에 대한 지원은 무한정 계속됩니다. 그러나 세 번째 &lt;code&gt;progressHandler&lt;/code&gt; 인수를 허용하는 변형 은 더 이상 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0578afb0e805324fd3d6ef6661225daacb79ec32" translate="yes" xml:space="preserve">
          <source>The suffix must be a valid JavaScript identifier using ASCII letters</source>
          <target state="translated">접미사는 ASCII 문자를 사용하는 유효한 JavaScript 식별자 여야합니다.</target>
        </trans-unit>
        <trans-unit id="51e5ddd442738d3ba0fcf36bd1580ce1e7b6558a" translate="yes" xml:space="preserve">
          <source>The usage pattern is similar to the PostgreSQL example above. You can also use a disposer pattern (but not an actual .disposer). See the PostgreSQL example above for instructions.</source>
          <target state="translated">사용 패턴은 위의 PostgreSQL 예제와 유사합니다. 디스 포저 패턴을 사용할 수도 있습니다 (실제 .disposer는 아님). 지침은 위의 PostgreSQL 예제를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="28bb7fa145553052b5508efe6d9bb705def39d86" translate="yes" xml:space="preserve">
          <source>The usual way to use promises in node is to &lt;a href=&quot;api/promise.promisifyall&quot;&gt;&lt;code&gt;Promise.promisifyAll&lt;/code&gt;&lt;/a&gt; some API and start exclusively calling promise returning versions of the APIs methods. E.g.</source>
          <target state="translated">노드에서 약속을 사용하는 일반적인 방법은 &lt;a href=&quot;api/promise.promisifyall&quot;&gt; &lt;code&gt;Promise.promisifyAll&lt;/code&gt; &lt;/a&gt; API를 사용하고 API를 반환하는 버전의 API 메서드를 독점적으로 호출하는 것입니다. 예 :</target>
        </trans-unit>
        <trans-unit id="9d0826c3236c309fa1a8bb247d52444104239f26" translate="yes" xml:space="preserve">
          <source>The usual way to use promises in node is to &lt;a href=&quot;promise.promisifyall&quot;&gt;&lt;code&gt;Promise.promisifyAll&lt;/code&gt;&lt;/a&gt; some API and start exclusively calling promise returning versions of the APIs methods. E.g.</source>
          <target state="translated">노드에서 약속을 사용하는 일반적인 방법은 &lt;a href=&quot;promise.promisifyall&quot;&gt; &lt;code&gt;Promise.promisifyAll&lt;/code&gt; &lt;/a&gt; API를 사용하고 API를 반환하는 버전의 API 메서드를 독점적으로 호출하는 것입니다. 예 :</target>
        </trans-unit>
        <trans-unit id="2304d640a16ae9bfebc931161006126d186e787e" translate="yes" xml:space="preserve">
          <source>Then:</source>
          <target state="translated">Then:</target>
        </trans-unit>
        <trans-unit id="12dfbb41929f3ee02dc34311b3347fac9dec5515" translate="yes" xml:space="preserve">
          <source>There are many third party promise libraries available for JavaScript and even the standard library contains a promise implementation in newer versions of browsers and node/io.js. This page will explore why one might use bluebird promises over other third party or the standard library implementations. For reasons why to use promises in general, see the &lt;a href=&quot;why-promises&quot;&gt;Why Promises?&lt;/a&gt; article.</source>
          <target state="translated">JavaScript에 사용할 수있는 많은 타사 약속 라이브러리가 있으며 표준 라이브러리에도 최신 버전의 브라우저 및 node / io.js에서 약속 구현이 포함되어 있습니다. 이 페이지에서는 타사 또는 표준 라이브러리 구현에 블루 버드 약속을 사용할 수있는 이유를 살펴 봅니다. 일반적으로 약속을 사용해야하는 &lt;a href=&quot;why-promises&quot;&gt;이유는 약속&lt;/a&gt; 의 이유를 참조하십시오 . 조.</target>
        </trans-unit>
        <trans-unit id="0016f6e7c65d90d1ef2d07a4adbd7695a74d6216" translate="yes" xml:space="preserve">
          <source>There are many ways to use bluebird in browsers:</source>
          <target state="translated">브라우저에서 블루 버드를 사용하는 방법에는 여러 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="acfa8f7a74926d5b3e71d319fe2e3737e67b4a45" translate="yes" xml:space="preserve">
          <source>There are still a few problems with the earlier code example. It feels like it is doing too much. A &lt;em&gt;squint&lt;/em&gt; test reveals behavior for showing the dialog, set the dialog's message, attach two DOM events, construct a promise, event delegation, hide the dialog, and finally detach DOM events. That is a lot for one little function. A refactoring can help.</source>
          <target state="translated">이전 코드 예제에는 여전히 몇 가지 문제가 있습니다. 너무 많은 일을하고있는 것 같습니다. &lt;em&gt;사시&lt;/em&gt; 검사, 대화 상자의 메시지를 설정 대화 상자를 표시하기위한 행동을 보여 대화 상자를 숨기고, 두 개의 DOM 이벤트, 약속, 이벤트 위임을 구성을 첨부하고, 마지막으로 분리 DOM 이벤트. 그것은 하나의 작은 기능에 많은 것입니다. 리팩토링이 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2d9fdb7b10a480524179ca553be134c2cab93bd" translate="yes" xml:space="preserve">
          <source>There are two primary methods of converting callback based APIs into promise based ones. You can either manually map the API calls to promise returning functions or you can let the bluebird do it for you. We &lt;strong&gt;strongly&lt;/strong&gt; recommend the latter.</source>
          <target state="translated">콜백 기반 API를 약속 기반 API로 변환하는 두 가지 기본 방법이 있습니다. API 호출을 수동으로 매핑하여 반환 기능을 약속하거나 블루 버드가이를 수행하도록 할 수 있습니다. 우리는 &lt;strong&gt;강력하게&lt;/strong&gt; 후자를 추천합니다.</target>
        </trans-unit>
        <trans-unit id="f594978f8f4cce365338daa917338cba030de34d" translate="yes" xml:space="preserve">
          <source>There is also &lt;a href=&quot;http://stackoverflow.com/questions/22519784/how-do-i-convert-an-existing-callback-api-to-promises&quot;&gt;this more general StackOverflow question&lt;/a&gt; about conversion of callback APIs to promises. If you find anything missing in this guide however, please do open an issue or pull request.</source>
          <target state="translated">콜백 API를 약속으로 변환하는 방법에 대한 &lt;a href=&quot;http://stackoverflow.com/questions/22519784/how-do-i-convert-an-existing-callback-api-to-promises&quot;&gt;더 일반적인 StackOverflow 질문&lt;/a&gt; 도 있습니다 . 그러나이 안내서에 누락 된 내용이 있으면 문제를 열거 나 풀 요청을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="82ffbfbc41fe53312b41cce044330748666500e8" translate="yes" xml:space="preserve">
          <source>There is an &lt;a href=&quot;https://www.promisejs.org/generators/&quot;&gt;excellent article&lt;/a&gt; on promisejs.org detailing how to combine promises with generators to achieve much cleaner code. Instead of the &lt;code&gt;async&lt;/code&gt; function the article proposes, you can use &lt;a href=&quot;api/promise.coroutine&quot;&gt;&lt;code&gt;Promise.coroutine&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;https://www.promisejs.org/generators/&quot;&gt;우수한 기사&lt;/a&gt; 훨씬 청소기 코드를 달성하기 위해 발전기와 약속을 결합하는 방법을 자세히 promisejs.org에가. 기사에서 제안 하는 &lt;code&gt;async&lt;/code&gt; 함수 대신 &lt;a href=&quot;api/promise.coroutine&quot;&gt; &lt;code&gt;Promise.coroutine&lt;/code&gt; &lt;/a&gt; 을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ccd6b50860623f70756069f499d23f01b6d13e5c" translate="yes" xml:space="preserve">
          <source>There is no effect on performance if the user doesn't actually pass a node-style callback function.</source>
          <target state="translated">사용자가 실제로 노드 스타일 콜백 함수를 전달하지 않으면 성능에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a899a39eea077d35fbd555f33e92cdecfa97e0f3" translate="yes" xml:space="preserve">
          <source>There is no need to convert timeouts/delays to a bluebird API, bluebird already ships with the &lt;a href=&quot;api/promise.delay&quot;&gt;&lt;code&gt;Promise.delay&lt;/code&gt;&lt;/a&gt; function for this use case. Please consult the &lt;a href=&quot;api/timers&quot;&gt;&lt;code&gt;timers&lt;/code&gt;&lt;/a&gt; section of the docs on usage and examples.</source>
          <target state="translated">시간 초과 / 지연을 블루 버드 API로 변환 할 필요가 없습니다. 블루 버드는 이미이 사용 사례에 대한 &lt;a href=&quot;api/promise.delay&quot;&gt; &lt;code&gt;Promise.delay&lt;/code&gt; &lt;/a&gt; 함수 와 함께 제공됩니다 . 사용법과 예제에 대해서는 문서 의 &lt;a href=&quot;api/timers&quot;&gt; &lt;code&gt;timers&lt;/code&gt; &lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="816256e371a68e0a4e42cc5d7e31e59e968b1550" translate="yes" xml:space="preserve">
          <source>This APIs are what most core modules in Node/io use and bluebird comes with a fast and efficient way to convert them to promise based APIs through the &lt;code&gt;Promise.promisify&lt;/code&gt; and &lt;code&gt;Promise.promisifyAll&lt;/code&gt; function calls.</source>
          <target state="translated">이 API는 Node / io에서 대부분의 핵심 모듈이 사용하는 것으로 &lt;code&gt;Promise.promisify&lt;/code&gt; 는 Promise.promisify 및 &lt;code&gt;Promise.promisifyAll&lt;/code&gt; 함수 호출을 통해 약속 기반 API로 변환 할 수있는 빠르고 효율적인 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3d88bc0890f9955d9aafd69e5e422f7404df8670" translate="yes" xml:space="preserve">
          <source>This abstraction can be expanded on in other ways. For example a notification dialog:</source>
          <target state="translated">이 추상화는 다른 방식으로 확장 될 수 있습니다. 예를 들어 알림 대화 상자 :</target>
        </trans-unit>
        <trans-unit id="4ef92d2a854bbe01523868d53a897ee9b600001a" translate="yes" xml:space="preserve">
          <source>This also happens when implementing live-updating models with a &lt;code&gt;.then&lt;/code&gt; method that indicates when the model is &quot;ready&quot;. A promise is a process, it starts and it ends.</source>
          <target state="translated">이는 모델이 &quot;준비&quot;된시기를 나타내는 &lt;code&gt;.then&lt;/code&gt; 메소드를 사용하여 라이브 업데이트 모델을 구현할 때도 발생합니다 . 약속은 과정이며 시작하고 끝납니다.</target>
        </trans-unit>
        <trans-unit id="1d9ddcdc77c9d4a96e7a508b17988600ecaa73fc" translate="yes" xml:space="preserve">
          <source>This also means that disposers should not contain code that does anything other than resource disposal. For example, you cannot write code inside a disposer to commit or rollback a transaction, because there is no mechanism for the disposer to signal a failure of the commit or rollback action without crashing the process.</source>
          <target state="translated">이는 또한 처분 자에게 자원 폐기 이외의 작업을 수행하는 코드를 포함해서는 안됨을 의미합니다. 예를 들어, Disposer가 프로세스 중단없이 커밋 또는 롤백 작업의 실패를 알리는 메커니즘이 없으므로 트랜잭션을 커밋 또는 롤백하기 위해 Disposer 내부에 코드를 작성할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="66b2c8b4731b0f7ba7e6bf98e67448082824c523" translate="yes" xml:space="preserve">
          <source>This article is partially or completely unfinished. You are welcome to create &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/api/promise.each.md&quot;&gt;pull requests&lt;/a&gt; to help completing this article.</source>
          <target state="translated">이 기사는 부분적으로 또는 완전히 완료되지 않았습니다. 이 기사를 완성하는 데 도움이되는 &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/api/promise.each.md&quot;&gt;끌어 오기 요청&lt;/a&gt; 을 작성하실 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9b70a0a7654e551108da4764c9f005aab32644aa" translate="yes" xml:space="preserve">
          <source>This article is partially or completely unfinished. You are welcome to create &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/async-dialogs.md&quot;&gt;pull requests&lt;/a&gt; to help completing this article.</source>
          <target state="translated">이 기사는 부분적으로 또는 완전히 완료되지 않았습니다. 이 기사를 완성하는 데 도움이되는 &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/async-dialogs.md&quot;&gt;끌어 오기 요청&lt;/a&gt; 을 작성하실 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e1c525d7a299f5e8e85d4de9a717c3aacb38e9c7" translate="yes" xml:space="preserve">
          <source>This article is partially or completely unfinished. You are welcome to create &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/beginners-guide.md&quot;&gt;pull requests&lt;/a&gt; to help completing this article.</source>
          <target state="translated">이 기사는 부분적으로 또는 완전히 완료되지 않았습니다. 이 기사를 완성하는 데 도움이되는 &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/beginners-guide.md&quot;&gt;끌어 오기 요청&lt;/a&gt; 을 작성하실 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c52f9c032871178393d4fecda1b976e39b1a06b1" translate="yes" xml:space="preserve">
          <source>This article is partially or completely unfinished. You are welcome to create &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/deprecated-apis.md&quot;&gt;pull requests&lt;/a&gt; to help completing this article.</source>
          <target state="translated">이 기사는 부분적으로 또는 완전히 완료되지 않았습니다. 이 기사를 완성하는 데 도움이되는 &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/deprecated-apis.md&quot;&gt;끌어 오기 요청&lt;/a&gt; 을 작성하실 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b6f8fae1cd767c72257bf951d6fae38ca4750167" translate="yes" xml:space="preserve">
          <source>This article is partially or completely unfinished. You are welcome to create &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/features.md&quot;&gt;pull requests&lt;/a&gt; to help completing this article.</source>
          <target state="translated">이 기사는 부분적으로 또는 완전히 완료되지 않았습니다. 이 기사를 완성하는 데 도움이되는 &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/features.md&quot;&gt;끌어 오기 요청&lt;/a&gt; 을 작성하실 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0b80a141eb9286b1bcd67d018003d3e43d4ca6b1" translate="yes" xml:space="preserve">
          <source>This article is partially or completely unfinished. You are welcome to create &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/getting-started.md&quot;&gt;pull requests&lt;/a&gt; to help completing this article.</source>
          <target state="translated">이 기사는 부분적으로 또는 완전히 완료되지 않았습니다. 이 기사를 완성하는 데 도움이되는 &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/getting-started.md&quot;&gt;끌어 오기 요청&lt;/a&gt; 을 작성하실 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c9d9ce5a1a1cedf3cd3c1bf2b642c4920ce3d476" translate="yes" xml:space="preserve">
          <source>This article is partially or completely unfinished. You are welcome to create &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/warning-explanations.md&quot;&gt;pull requests&lt;/a&gt; to help completing this article.</source>
          <target state="translated">이 기사는 부분적으로 또는 완전히 완료되지 않았습니다. 이 기사를 완성하는 데 도움이되는 &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/warning-explanations.md&quot;&gt;끌어 오기 요청&lt;/a&gt; 을 작성하실 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="01153e43a1c1cb6db13e7e38cfc4a7ca277baf87" translate="yes" xml:space="preserve">
          <source>This article is partially or completely unfinished. You are welcome to create &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/what-about-generators.md&quot;&gt;pull requests&lt;/a&gt; to help completing this article.</source>
          <target state="translated">이 기사는 부분적으로 또는 완전히 완료되지 않았습니다. 이 기사를 완성하는 데 도움이되는 &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/what-about-generators.md&quot;&gt;끌어 오기 요청&lt;/a&gt; 을 작성하실 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3b2b6fdf4dc9492f2c92f1362815d504f5b44c1e" translate="yes" xml:space="preserve">
          <source>This article is partially or completely unfinished. You are welcome to create &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/why-performance.md&quot;&gt;pull requests&lt;/a&gt; to help completing this article.</source>
          <target state="translated">이 기사는 부분적으로 또는 완전히 완료되지 않았습니다. 이 기사를 완성하는 데 도움이되는 &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/why-performance.md&quot;&gt;끌어 오기 요청&lt;/a&gt; 을 작성하실 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7a69f82bc8c73af862fe6ee2765641d403ac8822" translate="yes" xml:space="preserve">
          <source>This can be used to create APIs that both accept node-style callbacks and return promises:</source>
          <target state="translated">이는 노드 스타일 콜백을 수락하고 약속을 반환하는 API를 만드는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2af698572346d77b6e2820e63d397c65adf61bf3" translate="yes" xml:space="preserve">
          <source>This can be useful if a function returns a promise (say into a chain) but can optionally return a static value. Say, for a lazy-loaded value. Example:</source>
          <target state="translated">이것은 함수가 약속 (체인으로)을 리턴하지만 선택적으로 정적 값을 리턴 할 수있는 경우에 유용 할 수 있습니다. 게으른로드 값에 대해 말해보십시오. 예:</target>
        </trans-unit>
        <trans-unit id="01154032238ce0a62f38ce2edfeea44425f1609e" translate="yes" xml:space="preserve">
          <source>This can happen when you are calling &lt;a href=&quot;api/promise.promisifyall&quot;&gt;&lt;code&gt;Promise.promisifyAll&lt;/code&gt;&lt;/a&gt; on a function and invoking it instead of passing it.</source>
          <target state="translated">함수에서 &lt;a href=&quot;api/promise.promisifyall&quot;&gt; &lt;code&gt;Promise.promisifyAll&lt;/code&gt; &lt;/a&gt; 을 호출하고 전달하는 대신 호출 할 때 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b7e20e128e0a8a57b67f7c7c358d05477f3c5d61" translate="yes" xml:space="preserve">
          <source>This can happen when you tried to do something like:</source>
          <target state="translated">이것은 다음과 같은 일을 시도했을 때 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="caac030e0f988203bfd2f85f66f13be073b83988" translate="yes" xml:space="preserve">
          <source>This doesn't add much much using &lt;code&gt;window.prompt&lt;/code&gt;; however, one advantage is the API that promises provide. In the case where we call &lt;code&gt;promptPromise(&amp;hellip;)&lt;/code&gt; we can easily react to the result of the dialog without having to worry about how it is implemented. In our example we've implemented the &lt;code&gt;window.prompt&lt;/code&gt; but our call to &lt;code&gt;promptPromise()&lt;/code&gt; doesn't care. This makes a change to an &lt;em&gt;asynchronous&lt;/em&gt; dialog a little more future proof.</source>
          <target state="translated">이것은 &lt;code&gt;window.prompt&lt;/code&gt; 를 사용하여 많이 추가하지 않습니다 . 그러나 한 가지 장점은 약속하는 API입니다. 우리가 &lt;code&gt;promptPromise(&amp;hellip;)&lt;/code&gt; 호출하는 경우, 어떻게 구현되는지에 대해 걱정할 필요없이 대화 상자의 결과에 쉽게 반응 할 수 있습니다. 이 예에서는 &lt;code&gt;window.prompt&lt;/code&gt; 를 구현 했지만 &lt;code&gt;promptPromise()&lt;/code&gt; 대한 호출은 중요 하지 않습니다. 이를 통해 &lt;em&gt;비동기&lt;/em&gt; 대화 상자를 조금 더 미래에 대비할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="71b6120513a7366580cee8aba7b9480ac2cf93a2" translate="yes" xml:space="preserve">
          <source>This error indicates you have tried to call &lt;a href=&quot;api/promise.promisifyall&quot;&gt;&lt;code&gt;Promise.promisifyAll&lt;/code&gt;&lt;/a&gt; on an object that already has a property with the &lt;code&gt;Async&lt;/code&gt; suffix:</source>
          <target state="translated">이 오류는 &lt;code&gt;Async&lt;/code&gt; 접미사 가있는 속성이 이미있는 개체에서 &lt;a href=&quot;api/promise.promisifyall&quot;&gt; &lt;code&gt;Promise.promisifyAll&lt;/code&gt; &lt;/a&gt; 을 호출하려고했음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="a572d9a56addbf0b78e49d060a13678d16002f76" translate="yes" xml:space="preserve">
          <source>This example doesn't work as intended because the &lt;code&gt;then&lt;/code&gt; handler actually swallows the exception and returns &lt;code&gt;undefined&lt;/code&gt; for any further chainers.</source>
          <target state="translated">&lt;code&gt;then&lt;/code&gt; 핸들러는 실제로 예외를 삼키고 더 이상의 chainer에 대해 &lt;code&gt;undefined&lt;/code&gt; 를 반환 하기 때문에이 예제는 의도 한대로 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7c54ec4bcf6b3320c0e8ec781b0cb320bbd68320" translate="yes" xml:space="preserve">
          <source>This example pings 4 nameservers, and logs the fastest 2 on console:</source>
          <target state="translated">이 예제는 4 개의 네임 서버를 ping하고 콘솔에서 가장 빠른 2를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="2b07ce3ee1a174adcf4f487506a3c9e336575eaf" translate="yes" xml:space="preserve">
          <source>This feature enables subscription to promise lifecycle events via standard global events mechanisms in browsers and Node.js.</source>
          <target state="translated">이 기능을 통해 구독은 브라우저 및 Node.js의 표준 글로벌 이벤트 메커니즘을 통해 수명주기 이벤트를 약속 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="876ee350821244d6855a5b5648beee14fb439673" translate="yes" xml:space="preserve">
          <source>This feature has to be explicitly enabled by calling &lt;a href=&quot;api/promise.config&quot;&gt;&lt;code&gt;Promise.config&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;monitoring: true&lt;/code&gt;.</source>
          <target state="translated">이 기능은 &lt;code&gt;monitoring: true&lt;/code&gt; &lt;a href=&quot;api/promise.config&quot;&gt; &lt;code&gt;Promise.config&lt;/code&gt; &lt;/a&gt; 를 호출하여 명시 적으로 활성화해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="ca7179462cda9a709541b309d7c01bbb585212a4" translate="yes" xml:space="preserve">
          <source>This file contains documentation for APIs that are no longer supported by Bluebird. These APIs still work in Bluebird but will be removed at a future version of the library.</source>
          <target state="translated">이 파일에는 Bluebird에서 더 이상 지원하지 않는 API에 대한 설명서가 포함되어 있습니다. 이 API는 여전히 Bluebird에서 작동하지만 이후 버전의 라이브러리에서는 제거 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="4e1d1e209b1192c78f57f02dae0b2d4bf136ca53" translate="yes" xml:space="preserve">
          <source>This happens when a non object value or a promise that resolves with something that is not an object is being passed instead.</source>
          <target state="translated">이는 오브젝트가 아닌 값으로 또는 오브젝트가 아닌 것으로 해석되는 약속이 대신 전달 될 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fb3b4bfaeb441a21b0068d6c2bb1331473c59ffc" translate="yes" xml:space="preserve">
          <source>This happens when you call &lt;code&gt;.some&lt;/code&gt; passing it a negative value or a non-integer.</source>
          <target state="translated">이것은 &lt;code&gt;.some&lt;/code&gt; 를 호출 하면 음수 값 또는 정수가 아닌 값을 전달할 때 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="361cf2ec170969184f8f35c3d2c58d91c88e0978" translate="yes" xml:space="preserve">
          <source>This inherits from &lt;code&gt;Dialog&lt;/code&gt; and stores references to the required DOM elements that this dialog uses. It then attaches the require DOM events (&lt;code&gt;attachDomEvents()&lt;/code&gt;) which eventually call the callbacks. Then it implements the &lt;code&gt;show()&lt;/code&gt; and &lt;code&gt;hide()&lt;/code&gt; methods. Its usage is more flexible and verbose:</source>
          <target state="translated">이것은 &lt;code&gt;Dialog&lt;/code&gt; 에서 상속되며이 대화 상자가 사용하는 필수 DOM 요소에 대한 참조를 저장합니다. 그런 다음 콜백을 호출하는 필수 DOM 이벤트 ( &lt;code&gt;attachDomEvents()&lt;/code&gt; ) 를 첨부합니다 . 그런 다음 &lt;code&gt;show()&lt;/code&gt; 및 &lt;code&gt;hide()&lt;/code&gt; 메소드를 구현합니다 . 사용법이 더 유연하고 자세합니다.</target>
        </trans-unit>
        <trans-unit id="1c40c501429304b951f3e9a1e618216d7da3fae9" translate="yes" xml:space="preserve">
          <source>This interface is implemented by &lt;code&gt;Promise&lt;/code&gt; instances as well as the &lt;code&gt;PromiseInspection&lt;/code&gt; result given by &lt;a href=&quot;reflect&quot;&gt;&lt;code&gt;.reflect()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 인터페이스는 &lt;code&gt;Promise&lt;/code&gt; 인스턴스와 &lt;a href=&quot;reflect&quot;&gt; &lt;code&gt;.reflect()&lt;/code&gt; &lt;/a&gt; 제공된 &lt;code&gt;PromiseInspection&lt;/code&gt; 결과 로 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="1625642eae18357d2f9d1a1405e4d5fa15c5195c" translate="yes" xml:space="preserve">
          <source>This is Gorki Kosev's benchmark used in the article &lt;a href=&quot;http://spion.github.io/posts/analysis-generators-and-other-async-patterns-node.html&quot;&gt;Analysis of generators and other async patterns in node&lt;/a&gt;. The benchmark emulates a situation where N=10000 requests are being made concurrently to execute some mixed async/sync action with fast I/O response times.</source>
          <target state="translated">이것은 Gorki Kosev의 벤치 마크로 &lt;a href=&quot;http://spion.github.io/posts/analysis-generators-and-other-async-patterns-node.html&quot;&gt;node의 생성기 및 기타 비동기 패턴 분석&lt;/a&gt; 기사에 사용되었습니다 . 벤치 마크는 빠른 I / O 응답 시간으로 혼합 된 비동기 / 동기화 작업을 실행하기 위해 N = 10000 요청이 동시에 이루어지는 상황을 에뮬레이션합니다.</target>
        </trans-unit>
        <trans-unit id="c49dfefe9b869fa007a2d85f8deb59c16587b42f" translate="yes" xml:space="preserve">
          <source>This is a catch-all exception handler, shortcut for calling &lt;a href=&quot;then&quot;&gt;&lt;code&gt;.then(null, handler)&lt;/code&gt;&lt;/a&gt; on this promise. Any exception happening in a &lt;code&gt;.then&lt;/code&gt;-chain will propagate to nearest &lt;code&gt;.catch&lt;/code&gt; handler.</source>
          <target state="translated">이것은 이 약속에 따라 &lt;a href=&quot;then&quot;&gt; &lt;code&gt;.then(null, handler)&lt;/code&gt; &lt;/a&gt; 를 호출하기위한 바로 가기 예외 처리기 입니다. &lt;code&gt;.then&lt;/code&gt; 에서 발생하는 모든 예외 는 가장 가까운 &lt;code&gt;.catch&lt;/code&gt; 핸들러로 전파됩니다 .</target>
        </trans-unit>
        <trans-unit id="41cc0d7fb9773615b0a72dbe0951bb7f568b688b" translate="yes" xml:space="preserve">
          <source>This is a convenience method for doing:</source>
          <target state="translated">이것은 편리한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="ab45ed2cecaf14b1bbcc736ecc5d3c6da77d3562" translate="yes" xml:space="preserve">
          <source>This is a throughput benchmark.</source>
          <target state="translated">이것은 처리량 벤치 마크입니다.</target>
        </trans-unit>
        <trans-unit id="0bb50cb46856cf19733b9b720a91a5dbcedf8961" translate="yes" xml:space="preserve">
          <source>This is an extension to &lt;a href=&quot;catch&quot;&gt;&lt;code&gt;.catch&lt;/code&gt;&lt;/a&gt; to work more like catch-clauses in languages like Java or C#. Instead of manually checking &lt;code&gt;instanceof&lt;/code&gt; or &lt;code&gt;.name === &quot;SomeError&quot;&lt;/code&gt;, you may specify a number of error constructors which are eligible for this catch handler. The catch handler that is first met that has eligible constructors specified, is the one that will be called.</source>
          <target state="translated">이것은 Java 또는 C #과 같은 언어에서 catch-clauses와 유사하게 작동 하도록 &lt;a href=&quot;catch&quot;&gt; &lt;code&gt;.catch&lt;/code&gt; &lt;/a&gt; 의 확장 입니다. &lt;code&gt;instanceof&lt;/code&gt; 또는 &lt;code&gt;.name === &quot;SomeError&quot;&lt;/code&gt; 를 수동으로 확인하는 대신 이 catch 핸들러에 적합한 다수의 오류 생성자를 지정할 수 있습니다. 적합한 생성자가 지정된 캐치 핸들러가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="4e6f1e1654fff47bb7489453d9f0b688afc82574" translate="yes" xml:space="preserve">
          <source>This is an extension to &lt;a href=&quot;tapcatch&quot;&gt;&lt;code&gt;.tapCatch&lt;/code&gt;&lt;/a&gt; to filter exceptions similarly to languages like Java or C#. Instead of manually checking &lt;code&gt;instanceof&lt;/code&gt; or &lt;code&gt;.name === &quot;SomeError&quot;&lt;/code&gt;, you may specify a number of error constructors which are eligible for this tapCatch handler. The tapCatch handler that is first met that has eligible constructors specified, is the one that will be called.</source>
          <target state="translated">이것은 &lt;a href=&quot;tapcatch&quot;&gt; &lt;code&gt;.tapCatch&lt;/code&gt; &lt;/a&gt; 의 확장으로 Java 또는 C #과 같은 언어와 유사하게 예외를 필터링합니다. &lt;code&gt;instanceof&lt;/code&gt; 또는 &lt;code&gt;.name === &quot;SomeError&quot;&lt;/code&gt; 를 수동으로 확인하는 대신 이 tapCatch 핸들러에 적합한 다수의 오류 생성자를 지정할 수 있습니다. 적합한 생성자가 지정된 tapCatch 핸들러가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="de9b1d19482e049c5d2755c5328d90634cf4cf49" translate="yes" xml:space="preserve">
          <source>This is because Bluebird adds the &lt;code&gt;Async&lt;/code&gt; suffix to distinguish the original method from the promisified one, so &lt;code&gt;fooAsync&lt;/code&gt; would have been overridden. In order to avoid this - either rename &lt;code&gt;fooAsync&lt;/code&gt; before promisifying the API, or call &lt;a href=&quot;api/promise.promisify&quot;&gt;&lt;code&gt;Promise.promisify&lt;/code&gt;&lt;/a&gt; manually on select properties.</source>
          <target state="translated">이는 Bluebird가 원래 방법을 약속 된 방법과 구별하기 위해 &lt;code&gt;Async&lt;/code&gt; 접미사를 추가하기 때문에 &lt;code&gt;fooAsync&lt;/code&gt; 가 재정의 되었기 때문 입니다. 이를 피 하려면 API를 &lt;code&gt;fooAsync&lt;/code&gt; 하기 전에 fooAsync의 이름을 바꾸 거나 선택된 속성에서 수동으로 &lt;a href=&quot;api/promise.promisify&quot;&gt; &lt;code&gt;Promise.promisify&lt;/code&gt; 를&lt;/a&gt; 호출 하십시오.</target>
        </trans-unit>
        <trans-unit id="fb04140a6d6f4216a6dfa405bfd92da440efbba0" translate="yes" xml:space="preserve">
          <source>This is exactly like the synchronous code:</source>
          <target state="translated">이것은 동기 코드와 정확히 같습니다.</target>
        </trans-unit>
        <trans-unit id="bfb76de6040fe50d520474f7810629da738b7706" translate="yes" xml:space="preserve">
          <source>This is far more readable when done with promises:</source>
          <target state="translated">이것은 약속으로 끝나면 훨씬 더 읽기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="618293c3c21f06bb90993a614c9db3abe676ad93" translate="yes" xml:space="preserve">
          <source>This is reinventing the square wheel because any callback API wrapping can and should be done immediately using the promise library's promisification methods:</source>
          <target state="translated">약속 라이브러리의 약속 방법을 사용하여 모든 콜백 API 래핑을 즉시 수행 할 수 있고 수행해야하기 때문에 이것은 스퀘어 휠을 재창조합니다.</target>
        </trans-unit>
        <trans-unit id="278f2f5f91e65aca9cba986cd298d5b80d084994" translate="yes" xml:space="preserve">
          <source>This is relevant to browser environments with no module loader.</source>
          <target state="translated">이것은 모듈 로더가없는 브라우저 환경과 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="72dacc01b0328b9bb5e5b49e4a3b2f09a68d5835" translate="yes" xml:space="preserve">
          <source>This is the most common anti-pattern. It is easy to fall into this when you don't really understand promises and think of them as glorified event emitters or callback utility. It's also sometimes called the promise constructor anti-pattern. Let's recap: promises are about making asynchronous code retain most of the lost properties of synchronous code such as flat indentation and one exception channel. This pattern is also called the deferred anti-pattern.</source>
          <target state="translated">이것은 가장 일반적인 안티 패턴입니다. 약속을 실제로 이해하지 못하고 약속을 영광스러운 이벤트 이미 터 또는 콜백 유틸리티로 생각할 때 여기에 빠지기 쉽습니다. 또한 약속 생성자 안티 패턴이라고도합니다. 요점은 비동기 코드가 플랫 들여 쓰기 및 하나의 예외 채널과 같은 동기 코드의 손실 된 속성을 대부분 유지하도록하는 것입니다. 이 패턴을 지연 방지 패턴이라고도합니다.</target>
        </trans-unit>
        <trans-unit id="83310ff097e8beff42467f80b6885cac44a4a774" translate="yes" xml:space="preserve">
          <source>This is the point&amp;mdash;to have something that works like &lt;code&gt;return&lt;/code&gt; and &lt;code&gt;throw&lt;/code&gt; in synchronous code.</source>
          <target state="translated">요점 은 동기 코드에서 &lt;code&gt;return&lt;/code&gt; and &lt;code&gt;throw&lt;/code&gt; 와 같은 기능을하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="158db758d5ef9e5d2ebee4458ff60d03b8698f8f" translate="yes" xml:space="preserve">
          <source>This is to enable better stack trace support and to have more consistent and logical code.</source>
          <target state="translated">이는 더 나은 스택 추적 지원을 가능하게하고보다 일관되고 논리적 인 코드를 갖기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="eb2cd71a05d06d1a123d046c307b240be60c02ec" translate="yes" xml:space="preserve">
          <source>This made-up scenario runs 25 shimmed queries in parallel per each request (N=10000) with fast I/O response times.</source>
          <target state="translated">이 구성 시나리오는 빠른 I / O 응답 시간으로 각 요청 (N = 10000) 당 25 개의 shim 쿼리를 병렬로 실행합니다.</target>
        </trans-unit>
        <trans-unit id="3c0de91929a03e3312c7e239b95e998f29ef038e" translate="yes" xml:space="preserve">
          <source>This method also supports predicate-based filters. If you pass a predicate function instead of an error constructor, the predicate will receive the error as an argument. The return result of the predicate will be used determine whether the error handler should be called.</source>
          <target state="translated">이 방법은 술어 기반 필터도 지원합니다. 오류 생성자 대신 술어 함수를 전달하면 술어는 오류를 인수로받습니다. 술어의 리턴 결과는 오류 핸들러 호출 여부를 결정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b9befc4f3f3a5debf1bc48e96cdc0758b3d6448b" translate="yes" xml:space="preserve">
          <source>This method is compatible with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all&quot;&gt;&lt;code&gt;Promise.all&lt;/code&gt;&lt;/a&gt; from native promises.</source>
          <target state="translated">이 방법은 기본 약속의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all&quot;&gt; &lt;code&gt;Promise.all&lt;/code&gt; &lt;/a&gt; 과 호환됩니다 .</target>
        </trans-unit>
        <trans-unit id="a0481512ec7eb9822880d2eb57c4e1770159cdaa" translate="yes" xml:space="preserve">
          <source>This method is convenient when a function can sometimes return synchronously or throw synchronously.</source>
          <target state="translated">이 메소드는 함수가 때때로 동기식으로 리턴되거나 동 기적으로 throw 될 수있는 경우에 편리합니다.</target>
        </trans-unit>
        <trans-unit id="05db19a6c7c0e842cae324b6edc66273dd337537" translate="yes" xml:space="preserve">
          <source>This method is deprecated. Use &lt;a href=&quot;promise.config&quot;&gt;Promise.config&lt;/a&gt; instead.</source>
          <target state="translated">이 방법은 더 이상 사용되지 않습니다. 대신 &lt;a href=&quot;promise.config&quot;&gt;Promise.config&lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f63178b611e277d3437aa6cb79a370492a0a4d4d" translate="yes" xml:space="preserve">
          <source>This method is only implemented because it's in the ES6 standard. If you want to race promises to fulfillment the &lt;a href=&quot;any&quot;&gt;&lt;code&gt;.any&lt;/code&gt;&lt;/a&gt; method is more appropriate as it doesn't qualify a rejected promise as the winner. It also has less surprises: &lt;code&gt;.race&lt;/code&gt; must become infinitely pending if an empty array is passed but passing an empty array to &lt;a href=&quot;any&quot;&gt;&lt;code&gt;.any&lt;/code&gt;&lt;/a&gt; is more usefully a &lt;code&gt;RangeError&lt;/code&gt;</source>
          <target state="translated">이 방법은 ES6 표준에 있기 때문에 구현됩니다. 약속을 이행하기 로 약속 한 경우 거부 된 약속을 승자로 인정하지 않으므로 &lt;a href=&quot;any&quot;&gt; &lt;code&gt;.any&lt;/code&gt; &lt;/a&gt; 방법이 더 적합합니다. 또한 적은 놀라움을 가지고 &lt;code&gt;.race&lt;/code&gt; 는 하늘의 배열이 전달 이에 빈 배열을 전달하면 대기중인 무한이되어야 &lt;a href=&quot;any&quot;&gt; &lt;code&gt;.any&lt;/code&gt; &lt;/a&gt; 더 유용하게입니다 &lt;code&gt;RangeError&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="17f763d4342a3b00b5440e744954545f7480822a" translate="yes" xml:space="preserve">
          <source>This method is useful for when you want to wait for more than one promise to complete.</source>
          <target state="translated">이 방법은 하나 이상의 약속이 완료되기를 기다리는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e13b547a51d6973b8e8ea8229673f31834f1a93d" translate="yes" xml:space="preserve">
          <source>This method should be used before you use any of the methods which would otherwise alter the global &lt;code&gt;Bluebird&lt;/code&gt; object - to avoid polluting global state.</source>
          <target state="translated">글로벌 &lt;code&gt;Bluebird&lt;/code&gt; 객체를 달리 변경하는 메소드를 사용하기 전에이 메소드를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="bb88a06a14951217dbf7da64e1c214d581435513" translate="yes" xml:space="preserve">
          <source>This page describes parallels of using promises in other languages. Promises as a pattern are very common in other languages and knowing what they map to in other languages might help you with grasping them conceptually</source>
          <target state="translated">이 페이지는 다른 언어로 된 약속 사용의 유사점을 설명합니다. 패턴으로서의 약속은 다른 언어에서 매우 흔하며 다른 언어로 매핑되는 것을 아는 것은 개념적으로 이해하는 데 도움이 될 수 있습니다</target>
        </trans-unit>
        <trans-unit id="f8caafd4bd28c25bbaa9e7e7281f27609e085879" translate="yes" xml:space="preserve">
          <source>This page explains how to interface your code with existing callback APIs and libraries you're using. We'll see that making bluebird work with callback APIs is not only easy - it's also fast.</source>
          <target state="translated">이 페이지에서는 사용중인 기존 콜백 API 및 라이브러리와 코드를 인터페이스하는 방법에 대해 설명합니다. 콜백 API로 블루 버드를 작동시키는 것은 쉬운 일일뿐만 아니라 빠르다는 것을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31362f3d4d915353baa5045a042087f3f740de15" translate="yes" xml:space="preserve">
          <source>This page is a reference for migrating to bluebird from other flow control or promise libraries. See &lt;a href=&quot;install&quot;&gt;installation&lt;/a&gt; on how to use bluebird in your environment.</source>
          <target state="translated">이 페이지는 다른 흐름 제어 또는 약속 라이브러리에서 블루 버드로 마이그레이션하기위한 참조 자료입니다. 환경에서 블루 버드를 사용하는 방법에 대한 &lt;a href=&quot;install&quot;&gt;설치&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7a9a982268e14e003930e216d5e26566cf85c426" translate="yes" xml:space="preserve">
          <source>This page will contain common promise anti-patterns that are exercised in the wild.</source>
          <target state="translated">이 페이지에는 야생에서 사용되는 일반적인 안티 패턴이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa9be090a3976e3bdcf5c7d5ffe1e9f09746eddc" translate="yes" xml:space="preserve">
          <source>This section lists the most common async module replacements.</source>
          <target state="translated">이 섹션에는 가장 일반적인 비동기 모듈 교체가 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbbc8fd10030426b3463e06d9b5b51c19c29316d" translate="yes" xml:space="preserve">
          <source>This section only applies to node.js or io.js.</source>
          <target state="translated">이 섹션은 node.js 또는 io.js에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="dde97755fad5f67be03bd6d1c4049a9360dedd37" translate="yes" xml:space="preserve">
          <source>This superfluous wrapping is also dangerous, any kind of errors and rejections are swallowed and not propagated to the caller of this function.</source>
          <target state="translated">이 불필요한 랩핑도 위험하며, 모든 종류의 오류와 거부는 삼켜 서이 함수의 호출자에게 전파되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="12297c68c5f136df52d6d18d4a5ba1ec592d81f8" translate="yes" xml:space="preserve">
          <source>This usually happens when you have a promise that resolves or rejects with itself.</source>
          <target state="translated">이것은 일반적으로 스스로 해결하거나 거부하는 약속이있을 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="22c09fd50a68a2d3dd2ca54a203b3e20039f8ff5" translate="yes" xml:space="preserve">
          <source>This usually means that you simply forgot a &lt;code&gt;return&lt;/code&gt; statement somewhere, which will cause a runaway promise that is not connected to any promise chain.</source>
          <target state="translated">이것은 일반적으로 어딘가에 &lt;code&gt;return&lt;/code&gt; 문을 잊어 버렸기 때문에 약속 체인에 연결되지 않은 런 어웨이 약속을 유발합니다.</target>
        </trans-unit>
        <trans-unit id="641aada61fdf6b191fac4681998d3181bd3d099f" translate="yes" xml:space="preserve">
          <source>This will ensure that &lt;code&gt;connection.close()&lt;/code&gt; will be called once the promise returned from the &lt;code&gt;Promise.using&lt;/code&gt; closure is resolved or if an exception was thrown in the closure body.</source>
          <target state="translated">이렇게하면 &lt;code&gt;Promise.using&lt;/code&gt; 클로저 에서 반환 된 약속 이 해결되거나 클로저 본문에 예외가 발생한 경우 &lt;code&gt;connection.close()&lt;/code&gt; 가 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="d1caca18b80550e74fc714f5129356a12216a1b3" translate="yes" xml:space="preserve">
          <source>This works because the array acts as a &quot;module&quot; where the indices are the &quot;module&quot;'s properties for classes.</source>
          <target state="translated">배열이 인덱스가 클래스에 대한 &quot;모듈&quot;의 속성 인 &quot;모듈&quot;의 역할을하기 때문에 작동합니다.</target>
        </trans-unit>
        <trans-unit id="642f5108aa274866c1da99279aa0b6d98b1fdf21" translate="yes" xml:space="preserve">
          <source>Through the use of &lt;a href=&quot;api/each&quot;&gt;&lt;code&gt;.each&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;api/map&quot;&gt;&lt;code&gt;.map&lt;/code&gt;&lt;/a&gt; doing things just at the right concurrency level becomes a breeze.</source>
          <target state="translated">&lt;a href=&quot;api/each&quot;&gt; &lt;code&gt;.each&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;api/map&quot;&gt; &lt;code&gt;.map&lt;/code&gt; &lt;/a&gt; 을 사용 하면 올바른 동시성 수준에서 작업을 수행하는 것이 바람이됩니다.</target>
        </trans-unit>
        <trans-unit id="22a4ad2c60d9b1a4a4ab47810c732e12faec00b0" translate="yes" xml:space="preserve">
          <source>TimeoutError</source>
          <target state="translated">TimeoutError</target>
        </trans-unit>
        <trans-unit id="ae5a9ed10e48f39a8b693714bce92b1291ca1c8b" translate="yes" xml:space="preserve">
          <source>TimeoutError()</source>
          <target state="translated">TimeoutError()</target>
        </trans-unit>
        <trans-unit id="841cd03a97cd854590864d79ae48ee749c5e902e" translate="yes" xml:space="preserve">
          <source>Timers</source>
          <target state="translated">Timers</target>
        </trans-unit>
        <trans-unit id="23658960168be8cdbfbe275f17c4c761b8a8f3e9" translate="yes" xml:space="preserve">
          <source>To do this we will have two &lt;code&gt;catch()&lt;/code&gt; functions one for &lt;code&gt;UserCanceledError&lt;/code&gt; and one for any other &lt;code&gt;Error&lt;/code&gt;. We can make a custom error like so:</source>
          <target state="translated">이를 위해 &lt;code&gt;UserCanceledError&lt;/code&gt; 와 다른 &lt;code&gt;Error&lt;/code&gt; 를 위한 두 개의 &lt;code&gt;catch()&lt;/code&gt; 함수가 있습니다. 다음과 같이 맞춤 오류를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1a3ce42d2f42f9c24273b4cda598b33af25fce3" translate="yes" xml:space="preserve">
          <source>To drive home the synchronous nature of the &lt;code&gt;window.prompt&lt;/code&gt; notice that the time stops ticking when the prompt dialog is displayed. Let's fix that by making our own prompt. Since our dialog is just DOM manipulation the page won't be blocked while waiting for user input.</source>
          <target state="translated">&lt;code&gt;window.prompt&lt;/code&gt; 의 동기 특성을 홈으로 구동하려면 프롬프트 대화 상자가 표시 될 때 시간이 멈춘다는 점에 유의하십시오. 우리 자신의 프롬프트를 만들어서 고쳐 봅시다. 대화 상자는 DOM 조작이므로 사용자 입력을 기다리는 동안 페이지가 차단되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a7035efe5121276c8995557c4e8d8404d5096469" translate="yes" xml:space="preserve">
          <source>To enable long stack traces and warnings in node development:</source>
          <target state="translated">노드 개발에서 긴 스택 추적 및 경고를 사용하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="0e38679fea7f9ddcf16ac2341ac48ffb3d6a13cd" translate="yes" xml:space="preserve">
          <source>To enable long stack traces and warnings in node production:</source>
          <target state="translated">노드 프로덕션에서 긴 스택 추적 및 경고를 활성화하려면</target>
        </trans-unit>
        <trans-unit id="302b55ad14f02d86e137c0363366e824866304b7" translate="yes" xml:space="preserve">
          <source>To enable them in all instances of bluebird in node.js, use the environment variable &lt;code&gt;BLUEBIRD_DEBUG&lt;/code&gt;:</source>
          <target state="translated">node.js의 모든 블루 버드 인스턴스에서 활성화하려면 환경 변수 &lt;code&gt;BLUEBIRD_DEBUG&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6a347bd13a256b214fb6fa7d0dff43a0c457c811" translate="yes" xml:space="preserve">
          <source>To fix it, simply pass the function reference to &lt;a href=&quot;api/then&quot;&gt;&lt;code&gt;.then()&lt;/code&gt;&lt;/a&gt; as is:</source>
          <target state="translated">수정하려면 함수 참조를 &lt;a href=&quot;api/then&quot;&gt; &lt;code&gt;.then()&lt;/code&gt; &lt;/a&gt; 그대로 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="1ab4b669048933cdcafeed010c60563bc2fd72dd" translate="yes" xml:space="preserve">
          <source>To fix it, you need to &lt;code&gt;return&lt;/code&gt; the promise:</source>
          <target state="translated">문제를 해결하려면 약속 을 &lt;code&gt;return&lt;/code&gt; 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="67cb18d088b9f1e447cdd241d432d091a17f83ef" translate="yes" xml:space="preserve">
          <source>To fix, simply remember to add &lt;code&gt;return&lt;/code&gt; in front of your promise-complying function:</source>
          <target state="translated">수정하려면 약속 준수 기능 앞에 &lt;code&gt;return&lt;/code&gt; 을 추가 해야합니다.</target>
        </trans-unit>
        <trans-unit id="9dfea82804728489558d139da2f0b772571e485c" translate="yes" xml:space="preserve">
          <source>To make sure a function that returns a promise is following the implicit but critically important contract of promises, you can start a function with &lt;code&gt;new Promise&lt;/code&gt; if you cannot start a chain immediately:</source>
          <target state="translated">약속을 반환하는 함수가 암시 적이지만 매우 중요한 약속 계약을 따르도록하려면 즉시 체인을 시작할 수없는 경우 &lt;code&gt;new Promise&lt;/code&gt; 으로 함수를 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f45ac1d08d953780ed4fe1af6ee2f1aafa55655" translate="yes" xml:space="preserve">
          <source>Together with &lt;code&gt;onPossiblyUnhandledRejection&lt;/code&gt; these hooks can be used to implement a debugger that will show a list of unhandled promise rejections updated in real time as promises become handled.</source>
          <target state="translated">&lt;code&gt;onPossiblyUnhandledRejection&lt;/code&gt; 과 함께이 후크를 사용하여 약속이 처리 될 때 실시간으로 업데이트 된 처리되지 않은 약속 거부 목록을 표시하는 디버거를 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cffb3821e2781468cd3c381c1dd88d7da75f44e5" translate="yes" xml:space="preserve">
          <source>Typically &lt;em&gt;promises&lt;/em&gt; are used in conjunction with asynchronous tasks such as a network request or a &lt;code&gt;setTimeout&lt;/code&gt;; a lesser explored use is dealing with user input. Since a program has to wait for a user to continue some actions it makes sense to consider it an asynchronous event.</source>
          <target state="translated">일반적으로 &lt;em&gt;약속&lt;/em&gt; 은 네트워크 요청 또는 &lt;code&gt;setTimeout&lt;/code&gt; 과 같은 비동기 작업과 함께 사용됩니다 . 덜 탐색적인 사용은 사용자 입력을 처리합니다. 프로그램은 사용자가 일부 작업을 계속할 때까지 기다려야하므로 비동기 이벤트로 간주하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="95e39893849d27ccdda4985a773f9d1a23141d52" translate="yes" xml:space="preserve">
          <source>Unhandled errors are not silently swallowed by default but reported along with helpful stack traces where applicable. All of this is of course configurable.</source>
          <target state="translated">처리되지 않은 오류는 기본적으로 자동으로 삼키지 않지만 해당되는 경우 유용한 스택 추적과 함께보고됩니다. 이 모든 것은 물론 구성 가능합니다.</target>
        </trans-unit>
        <trans-unit id="3a34c30705919f5365483a84e6ffe973cf51a891" translate="yes" xml:space="preserve">
          <source>Unhandled rejections are tracked per promise, not per error. So if you create multiple branches from a single ancestor and that ancestor gets rejected, each branch with no error handler with the end will cause a possibly unhandled rejection handler invocation</source>
          <target state="translated">처리되지 않은 거부는 오류가 아닌 약속마다 추적됩니다. 따라서 단일 상위 항목에서 여러 분기를 작성하고 해당 상위 항목이 거부되는 경우 오류 처리기가없는 각 분기는 처리되지 않은 거부 핸들러 호출을 야기 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c350ad9142ecaab016e03c764abcb7074c45e90" translate="yes" xml:space="preserve">
          <source>Unless an AMD loader is installed, the script tag installation exposes the library in the &lt;code&gt;Promise&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt; namespaces. If you want to restore the &lt;code&gt;Promise&lt;/code&gt; namespace, use &lt;code&gt;var Bluebird = Promise.noConflict()&lt;/code&gt;.</source>
          <target state="translated">AMD 로더가 설치되지 않은 경우 스크립트 태그 설치는 라이브러리를 &lt;code&gt;Promise&lt;/code&gt; 및 &lt;code&gt;P&lt;/code&gt; 네임 스페이스 에 노출시킵니다 . &lt;code&gt;Promise&lt;/code&gt; 네임 스페이스 를 복원 하려면 &lt;code&gt;var Bluebird = Promise.noConflict()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="44e42a41d2a20532fa9a5c2908e1e8626e2a7e8e" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;finally&quot;&gt;&lt;code&gt;.finally&lt;/code&gt;&lt;/a&gt; this is not called for rejections.</source>
          <target state="translated">&lt;a href=&quot;finally&quot;&gt; &lt;code&gt;.finally&lt;/code&gt; &lt;/a&gt; 와 달리 이것은 거부를 요구하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8371d8f357f54bfda7d7c8677986ada6f8fa2ae9" translate="yes" xml:space="preserve">
          <source>Unminified source file meant to be used in development. Warnings and long stack traces are enabled which are taxing on performance.</source>
          <target state="translated">개발에 사용되는 축소되지 않은 소스 파일. 성능에 부담을주는 경고 및 긴 스택 추적이 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="42a8536e189c405379021d94a1e8532ff836496d" translate="yes" xml:space="preserve">
          <source>Updated logo</source>
          <target state="translated">업데이트 된 로고</target>
        </trans-unit>
        <trans-unit id="08b6f1fdb58d25854a37bb391362fd81dc049478" translate="yes" xml:space="preserve">
          <source>Usage examples include:</source>
          <target state="translated">사용 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eb4421a3da2485be27f4aababc58c8de5da2c8d7" translate="yes" xml:space="preserve">
          <source>Use setImmediate if available</source>
          <target state="translated">가능한 경우 setImmediate를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="289a45d725e898c1ca06ab7fa01837771482ed99" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;api/promise.all&quot;&gt;&lt;code&gt;Promise.all&lt;/code&gt;&lt;/a&gt; to implement the example from &lt;a href=&quot;https://github.com/caolan/async#parallel&quot;&gt;async homepage&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;api/promise.all&quot;&gt; &lt;code&gt;Promise.all&lt;/code&gt; &lt;/a&gt; 을 사용하여 &lt;a href=&quot;https://github.com/caolan/async#parallel&quot;&gt;비동기 홈페이지&lt;/a&gt; 에서 예제를 구현하십시오 .</target>
        </trans-unit>
        <trans-unit id="d609f610f666b772e57874290c0b6739f1e46b91" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;api/promise.each&quot;&gt;&lt;code&gt;Promise.each&lt;/code&gt;&lt;/a&gt; to implement the example from &lt;a href=&quot;https://github.com/caolan/async#maparr-iterator-callback&quot;&gt;async homepage&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;api/promise.each&quot;&gt; &lt;code&gt;Promise.each&lt;/code&gt; &lt;/a&gt; 를 사용하여 &lt;a href=&quot;https://github.com/caolan/async#maparr-iterator-callback&quot;&gt;비동기 홈페이지&lt;/a&gt; 에서 예제를 구현하십시오 .</target>
        </trans-unit>
        <trans-unit id="7b37cc52da759eea0a61e35010724d1f98be048a" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;api/promise.map&quot;&gt;&lt;code&gt;Promise.map&lt;/code&gt;&lt;/a&gt; to implement the example from &lt;a href=&quot;https://github.com/caolan/async#maparr-iterator-callback&quot;&gt;async homepage&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;api/promise.map&quot;&gt; &lt;code&gt;Promise.map&lt;/code&gt; &lt;/a&gt; 을 사용하여 &lt;a href=&quot;https://github.com/caolan/async#maparr-iterator-callback&quot;&gt;비동기 홈페이지&lt;/a&gt; 에서 예제를 구현하십시오 .</target>
        </trans-unit>
        <trans-unit id="87872433fa3fca67fb5bcea17254b8b45dc74c5d" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;api/promise.mapseries&quot;&gt;&lt;code&gt;Promise.mapSeries&lt;/code&gt;&lt;/a&gt; to implement the example from &lt;a href=&quot;https://github.com/caolan/async#seriestasks-callback&quot;&gt;async homepage&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;api/promise.mapseries&quot;&gt; &lt;code&gt;Promise.mapSeries&lt;/code&gt; &lt;/a&gt; 를 사용하여 &lt;a href=&quot;https://github.com/caolan/async#seriestasks-callback&quot;&gt;비동기 홈페이지&lt;/a&gt; 에서 예제를 구현하십시오 .</target>
        </trans-unit>
        <trans-unit id="5a34d8c3d20da73e7fdd61d0a9cd7e9a530150eb" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;.reflect()&lt;/code&gt; to implement &lt;code&gt;settleAll&lt;/code&gt; (wait until all promises in an array are either rejected or fulfilled) functionality</source>
          <target state="translated">사용 &lt;code&gt;.reflect()&lt;/code&gt; 구현 &lt;code&gt;settleAll&lt;/code&gt; (배열의 모든 약속 중 하나를 거부하거나 이행 될 때까지 대기) 기능을</target>
        </trans-unit>
        <trans-unit id="a030f13931277422b23a2b7aa92804eba9dbfca1" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;.reflect()&lt;/code&gt; to implement &lt;code&gt;settleProps&lt;/code&gt; (like settleAll for an object's properties) functionality</source>
          <target state="translated">사용 &lt;code&gt;.reflect()&lt;/code&gt; 구현하는 &lt;code&gt;settleProps&lt;/code&gt; (객체의 속성에 대한 settleAll 등) 기능</target>
        </trans-unit>
        <trans-unit id="510bd1d1748aa6be73d0b3f164f968144ae8f326" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;defaultPromisifier&lt;/code&gt; parameter to add enhancements on top of normal node promisification:</source>
          <target state="translated">&lt;code&gt;defaultPromisifier&lt;/code&gt; 매개 변수를 사용하여 일반 노드 약속 위에 개선 사항을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="a7f32ad8c97706d5425fc98083d499e4e2b0f38a" translate="yes" xml:space="preserve">
          <source>Using CoffeeScript's &lt;code&gt;class&lt;/code&gt; for the same:</source>
          <target state="translated">같은 목적으로 CoffeeScript &lt;code&gt;class&lt;/code&gt; 하기 :</target>
        </trans-unit>
        <trans-unit id="39b2fb1fa487e5be55b2254cc478460136f04a5f" translate="yes" xml:space="preserve">
          <source>Using DOM3 &lt;code&gt;addEventListener&lt;/code&gt; APIs (support starting from IE9+):</source>
          <target state="translated">DOM3 &lt;code&gt;addEventListener&lt;/code&gt; API 사용 (IE9 +부터 지원) :</target>
        </trans-unit>
        <trans-unit id="0031ac8ff26e8b6b8c4fa9f5d7c7a8c5ff06fc8d" translate="yes" xml:space="preserve">
          <source>Using ECMAScript6 generators feature to implement C# 5.0 &lt;code&gt;async/await&lt;/code&gt; like syntax.</source>
          <target state="translated">ECMAScript6 생성기 기능을 사용하여 C # 5.0 &lt;code&gt;async/await&lt;/code&gt; 구문과 같은 구문 을 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="acac6fbc07a16dd7002db7cd3b214125856ce811" translate="yes" xml:space="preserve">
          <source>Using an abstraction like this the &lt;code&gt;promisePrompt&lt;/code&gt; no longer needs to know anything about the DOM and concentrates on just providing a promise. This will also make things easier to create a promised version of a progress bar or confirmation dialog or any other type of UI that we want to have a value for. All we will need to do is write a class for that dialog type with the same interface and just pass that class into our promise making method.</source>
          <target state="translated">이와 같은 추상화를 사용하여 &lt;code&gt;promisePrompt&lt;/code&gt; 는 더 이상 DOM에 대해 아무것도 알 필요가 없으며 단지 약속을 제공하는 데 집중합니다. 또한 약속 된 버전의 진행률 표시 줄이나 확인 대화 상자 또는 우리가 가치를 원하는 다른 유형의 UI를 쉽게 만들 수 있습니다. 우리가해야 할 일은 동일한 인터페이스로 대화 상자 유형에 대한 클래스를 작성하고 해당 클래스를 약속 작성 메소드에 전달하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="92e2993e6dea235a7dcb1db5bb36202c8485dbc9" translate="yes" xml:space="preserve">
          <source>Using it:</source>
          <target state="translated">그것을 사용 :</target>
        </trans-unit>
        <trans-unit id="d829b44477e34c8358b0978984bdca898183bed9" translate="yes" xml:space="preserve">
          <source>Using jQuery after:</source>
          <target state="translated">다음 후 jQuery 사용 :</target>
        </trans-unit>
        <trans-unit id="c991e6de4c7c9ecea657f843e9921caf549f2112" translate="yes" xml:space="preserve">
          <source>Using jQuery before:</source>
          <target state="translated">전에 jQuery를 사용하여 :</target>
        </trans-unit>
        <trans-unit id="ee10eda3c3f21aee43203ae597d2c13cd07e6eea" translate="yes" xml:space="preserve">
          <source>Using legacy APIs (support starting from IE6+):</source>
          <target state="translated">레거시 API 사용 (IE6 +부터 지원) :</target>
        </trans-unit>
        <trans-unit id="51f995a28f75764b72a6c79dc89d54dd724921f6" translate="yes" xml:space="preserve">
          <source>Using manual resolver:</source>
          <target state="translated">수동 리졸버 사용하기 :</target>
        </trans-unit>
        <trans-unit id="d99578b7705756deffc2aa58f6ae34fb2dbdb0c2" translate="yes" xml:space="preserve">
          <source>Using multiple resources:</source>
          <target state="translated">여러 리소스 사용 :</target>
        </trans-unit>
        <trans-unit id="a3f65738b0a1c42c2a41e0b59a0029999f986703" translate="yes" xml:space="preserve">
          <source>Using no hooks and using &lt;a href=&quot;api/done&quot;&gt;&lt;code&gt;.done&lt;/code&gt;&lt;/a&gt; to manually to mark end points where rejections will not be handled</source>
          <target state="translated">후크를 사용하지 않고 &lt;a href=&quot;api/done&quot;&gt; &lt;code&gt;.done&lt;/code&gt; &lt;/a&gt; 을 사용하여 거부가 처리되지 않는 엔드 포인트를 수동으로 표시</target>
        </trans-unit>
        <trans-unit id="678ad3a7449dc9211f664a6a26c9f4eeb83dd91e" translate="yes" xml:space="preserve">
          <source>Using no hooks and using &lt;a href=&quot;done&quot;&gt;&lt;code&gt;.done&lt;/code&gt;&lt;/a&gt; to manually to mark end points where rejections will not be handled</source>
          <target state="translated">후크를 사용하지 않고 &lt;a href=&quot;done&quot;&gt; &lt;code&gt;.done&lt;/code&gt; &lt;/a&gt; 을 사용하여 거부가 처리되지 않는 엔드 포인트를 수동으로 표시</target>
        </trans-unit>
        <trans-unit id="7de8d54140fb8771440fc81fb18f3d53f9f6bb4f" translate="yes" xml:space="preserve">
          <source>Using recursion to implement the example from &lt;a href=&quot;https://github.com/caolan/async#whilsttest-fn-callback&quot;&gt;async homepage&lt;/a&gt;:</source>
          <target state="translated">재귀를 사용하여 &lt;a href=&quot;https://github.com/caolan/async#whilsttest-fn-callback&quot;&gt;비동기 홈페이지&lt;/a&gt; 에서 예제를 구현하십시오 .</target>
        </trans-unit>
        <trans-unit id="40c7e148244964ef32867f708db116db37aa2e23" translate="yes" xml:space="preserve">
          <source>Using the same function &lt;code&gt;Promise.method&lt;/code&gt;, there is no need to manually wrap direct return or throw values into a promise:</source>
          <target state="translated">동일한 함수 &lt;code&gt;Promise.method&lt;/code&gt; 를 사용하면 직접 반환 값을 던지거나 약속에 값을 던질 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="fdf3b6cb551f8ba0a6b556e915881b1d2f0aa867" translate="yes" xml:space="preserve">
          <source>Using the value &lt;code&gt;0&lt;/code&gt; will explicitly disable a feature despite debug environment otherwise activating it:</source>
          <target state="translated">값 &lt;code&gt;0&lt;/code&gt; 을 사용하면 디버그 환경에도 불구하고 기능이 명시 적으로 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="89189507b2a074e98b2e877227343a6e1f27b3ab" translate="yes" xml:space="preserve">
          <source>Utility</source>
          <target state="translated">Utility</target>
        </trans-unit>
        <trans-unit id="02024b434dc6bfc227f2288a4656819d24c77710" translate="yes" xml:space="preserve">
          <source>Warn when &lt;a href=&quot;api/then&quot;&gt;&lt;code&gt;.then()&lt;/code&gt;&lt;/a&gt; is passed non-functions</source>
          <target state="translated">&lt;a href=&quot;api/then&quot;&gt; &lt;code&gt;.then()&lt;/code&gt; &lt;/a&gt; 이 비 기능으로 전달 될 때 경고</target>
        </trans-unit>
        <trans-unit id="76bc85fbac802c9c28a4f34074f76273aa28dba3" translate="yes" xml:space="preserve">
          <source>Warning Explanations</source>
          <target state="translated">경고 설명</target>
        </trans-unit>
        <trans-unit id="e326d603e8ef33a0ace61e8bd45d1476027c27c7" translate="yes" xml:space="preserve">
          <source>Warning: .then() only accepts functions</source>
          <target state="translated">경고 : .then ()은 함수 만 허용합니다.</target>
        </trans-unit>
        <trans-unit id="2f253a4ff30df6ead65cd95ca2db9916033eb9d8" translate="yes" xml:space="preserve">
          <source>Warning: a promise was created in a handler but was not returned from it</source>
          <target state="translated">경고 : 약속이 핸들러에서 작성되었지만 리턴되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="5f19b7cfb75065744f09c3f3dbd1dd8602fb5742" translate="yes" xml:space="preserve">
          <source>Warning: a promise was rejected with a non-error</source>
          <target state="translated">경고 : 약속은 오류가 아닌 것으로 거부되었습니다</target>
        </trans-unit>
        <trans-unit id="1430f976c596795274458abcfbc4f280cbfcebac" translate="yes" xml:space="preserve">
          <source>Warnings</source>
          <target state="translated">Warnings</target>
        </trans-unit>
        <trans-unit id="f9b093958e9b93291eee426980c6f76c2af8380b" translate="yes" xml:space="preserve">
          <source>Warnings about created promises that are not returned are no longer given if the handler promise has not been chained. This should reduce the amount of false positives with this warning.</source>
          <target state="translated">핸들러 약속이 체인되지 않은 경우 리턴되지 않은 작성된 약속에 대한 경고가 더 이상 제공되지 않습니다. 이 경고로 오 탐지 양을 줄여야합니다.</target>
        </trans-unit>
        <trans-unit id="987519cc8247ea08d785b3bed0d0edba12ab4768" translate="yes" xml:space="preserve">
          <source>Warnings have been added to report usages which are very likely to be programmer errors. See &lt;a href=&quot;api/promise.config&quot;&gt;&lt;code&gt;Promise.config&lt;/code&gt;&lt;/a&gt; for how to enable warnings. See &lt;a href=&quot;warning-explanations&quot;&gt;Warning Explanations&lt;/a&gt; for list of the warnings and their explanations.</source>
          <target state="translated">프로그래머 오류 일 가능성이 높은 사용량을보고하기 위해 경고가 추가되었습니다. 경고를 활성화하는 방법 은 &lt;a href=&quot;api/promise.config&quot;&gt; &lt;code&gt;Promise.config&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 . &lt;a href=&quot;warning-explanations&quot;&gt;경고&lt;/a&gt; 목록 및 설명 은 경고 설명 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2346b64bd2ceb68b2dd0fe9b356367b311b6a6a1" translate="yes" xml:space="preserve">
          <source>We can do better, retaining concurrency and not leaking resources, by using:</source>
          <target state="translated">다음을 사용하여 동시성을 유지하고 리소스를 유출하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d449d2a1898fdf6171ab397563a248fe80459a1d" translate="yes" xml:space="preserve">
          <source>We can use the promise constructor to convert it to a promise returning function:</source>
          <target state="translated">promise 생성자를 사용하여 promise 반환 함수로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0998ac30de0c1580642c82716276399b1c613149" translate="yes" xml:space="preserve">
          <source>We will want to keep the same API so our change will be only to the &lt;code&gt;promisePrompt&lt;/code&gt;. It will find the dialog DOM elements, attach events to the elements, show the dialog box, return a promise that is resolved based on the attached events, and finally detaches the events and cleans up after itself (hiding the dialog box for another use later).</source>
          <target state="translated">우리는 동일한 API를 유지하여 &lt;code&gt;promisePrompt&lt;/code&gt; 에만 변경 사항을 적용하려고합니다 . 대화 상자 DOM 요소를 찾고, 요소에 이벤트를 첨부하고, 대화 상자를 표시하고, 첨부 된 이벤트를 기반으로 해결 된 약속을 반환하고, 마지막으로 이벤트를 분리하고 자체적으로 정리합니다 (나중에 사용하기 위해 대화 상자를 숨 깁니다) ).</target>
        </trans-unit>
        <trans-unit id="86974e9cfd94347a9d8035a721441882b61e40c8" translate="yes" xml:space="preserve">
          <source>We'll cover several subjects. If you want to get the tl;dr what you need is likely the &lt;a href=&quot;#working-with-callback-apis-using-the-node-convention&quot;&gt;Working with callback APIs using the Node convention&lt;/a&gt; section.</source>
          <target state="translated">몇 가지 주제를 다룰 것입니다. tl; dr를 얻으려면 &lt;a href=&quot;#working-with-callback-apis-using-the-node-convention&quot;&gt;노드 규칙을 사용하여 콜백 API로 작업&lt;/a&gt; 섹션이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="41b24863fa5a051446f6f2ae3860594cb7d071eb" translate="yes" xml:space="preserve">
          <source>Well simply, when you have to.</source>
          <target state="translated">간단하게, 당신이해야 할 때.</target>
        </trans-unit>
        <trans-unit id="f8c4fdd7823278887156d018b49c43e024631c27" translate="yes" xml:space="preserve">
          <source>What About Generators?</source>
          <target state="translated">발전기는 어떻습니까?</target>
        </trans-unit>
        <trans-unit id="30a484e5211183ba2cee4378c92b44d3105eeaf7" translate="yes" xml:space="preserve">
          <source>What about promises that have multiple consumers?</source>
          <target state="translated">소비자가 여러 명인 약속은 어떻습니까?</target>
        </trans-unit>
        <trans-unit id="6b7c4ebe4c5f3bfe7fb62f4c2a84779817b88487" translate="yes" xml:space="preserve">
          <source>What actually happens is that &lt;code&gt;result&lt;/code&gt; keeps track of how many consumers it has, in this case 2, and only if all the consumers signal cancel will the request be aborted. However, as far as &lt;code&gt;firstConsumer&lt;/code&gt; can tell, the promise was successfully cancelled and its handlers will not be called.</source>
          <target state="translated">실제로 발생하는 &lt;code&gt;result&lt;/code&gt; 는 소비자 수 (이 경우 2)를 추적하며 모든 소비자 신호 취소가 요청을 중단 한 경우에만 추적합니다. 그러나 &lt;code&gt;firstConsumer&lt;/code&gt; 가 알 수있는 한, 약속이 성공적으로 취소되었으며 처리기가 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="07c519ceae2b771a7ddeac59daf39ed209a19525" translate="yes" xml:space="preserve">
          <source>What is the the point of promises</source>
          <target state="translated">약속의 요점은 무엇입니까</target>
        </trans-unit>
        <trans-unit id="56aab8af41c28bb5f9c760d67856cb60689f1c68" translate="yes" xml:space="preserve">
          <source>What's new in 2.0</source>
          <target state="translated">2.0의 새로운 기능</target>
        </trans-unit>
        <trans-unit id="b2223542269901e7186ce7f97c69174f8009c3e4" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;NODE_ENV&lt;/code&gt; environment variable is &lt;code&gt;&quot;development&quot;&lt;/code&gt; setting &lt;code&gt;BLUEBIRD_DEBUG&lt;/code&gt; environment variable to &lt;code&gt;0&lt;/code&gt; can now be used to disable debug mode</source>
          <target state="translated">때 &lt;code&gt;NODE_ENV&lt;/code&gt; 의 환경 변수는 &lt;code&gt;&quot;development&quot;&lt;/code&gt; 설정 &lt;code&gt;BLUEBIRD_DEBUG&lt;/code&gt; 의 에 환경 변수 &lt;code&gt;0&lt;/code&gt; 은 이제 비활성화 디버그 모드로 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="268de3a5addf552f9cb9505acf541fb1a6c7d1c4" translate="yes" xml:space="preserve">
          <source>When called, the coroutine function will start an instance of the generator and returns a promise for its final value.</source>
          <target state="translated">호출되면 코 루틴 함수는 생성기 인스턴스를 시작하고 최종 값에 대한 약속을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="abcda78ef2264e69cff0163a190c8f4b357591ac" translate="yes" xml:space="preserve">
          <source>When chaining &lt;code&gt;.spread&lt;/code&gt;, returning an array of promises also works:</source>
          <target state="translated">&lt;code&gt;.spread&lt;/code&gt; 를 연결할 때 약속 배열을 반환하면 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b6c0e36e057ee58c2317285366278f58808242b8" translate="yes" xml:space="preserve">
          <source>When debugging or performing a one-time operation on a variable before passing it to a function, a return variable is forgotten.</source>
          <target state="translated">변수를 함수에 전달하기 전에 변수에 대해 디버깅 또는 일회성 작업을 수행 할 때 반환 변수를 잊어 버립니다.</target>
        </trans-unit>
        <trans-unit id="64d8621b03578f1c94ccc629a4cc7c4de3a568ed" translate="yes" xml:space="preserve">
          <source>When there are asynchronous tasks that have the ability to notify progress as they complete it can be tempting to want that in the promise that represents that task. Unfortunately this is a bit of an anti-pattern. That is because the point of promises is to represent a value as if it was natural (like it is in normal synchronous code) and not to be over glorified callback management.</source>
          <target state="translated">진행 상황을 완료 할 때 알릴 수있는 비동기 작업이있는 경우 해당 작업을 나타내는 약속에서 원하는 작업을 원할 수 있습니다. 불행히도 이것은 약간의 반 패턴입니다. 약속의 요점은 자연적인 것처럼 (일반 동기 코드처럼) 값을 표현하고 과장된 콜백 관리가 아닌 값을 나타내는 것이기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="b3f5f46aab39a3a9a507394c2c440bab65f0ea48" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;longStackTraces&lt;/code&gt; the first line in your code after requiring Bluebird should be:</source>
          <target state="translated">&lt;code&gt;longStackTraces&lt;/code&gt; 를 사용할 때 블루 버드를 요구 한 후 코드의 첫 번째 행은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="b9be79b81b6d65c3ed9b6fe0e6688b7fd74367ea" translate="yes" xml:space="preserve">
          <source>When using script tags the global variables &lt;code&gt;Promise&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt; (alias for &lt;code&gt;Promise&lt;/code&gt;) become available. Bluebird runs on a wide variety of browsers including older versions. We'd like to thank BrowserStack for giving us a free account which helps us test that.</source>
          <target state="translated">스크립트 태그를 사용하는 경우 전역 변수 &lt;code&gt;Promise&lt;/code&gt; 과 &lt;code&gt;P&lt;/code&gt; (별칭 &lt;code&gt;Promise&lt;/code&gt; ) 사용할 수있게됩니다. Bluebird는 이전 버전을 포함한 다양한 브라우저에서 실행됩니다. 테스트를 도와주는 무료 계정을 제공해 주신 BrowserStack에 감사의 말씀을 전합니다.</target>
        </trans-unit>
        <trans-unit id="4a2fe4cb42752a52e254b8a6bf3ceb42b7e1ac55" translate="yes" xml:space="preserve">
          <source>When using the first signature, you may specify a custom error message with the &lt;code&gt;message&lt;/code&gt; parameter.</source>
          <target state="translated">첫 번째 서명을 사용할 때 &lt;code&gt;message&lt;/code&gt; 매개 변수를 사용하여 사용자 지정 오류 메시지를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="25f41737292fcc0beb27bde5ba12d4c02e4d5a28" translate="yes" xml:space="preserve">
          <source>When we construct our &lt;code&gt;ProgressDialog&lt;/code&gt; we use the &lt;code&gt;waitForUser()&lt;/code&gt; method to capture the user interaction promise and then use &lt;code&gt;delayedPromise()&lt;/code&gt; to capture the fake network promise and finally &lt;code&gt;Promise.reace()&lt;/code&gt; to manage the two simultaneously and end with a single promise as usual.</source>
          <target state="translated">우리가 건설되면 &lt;code&gt;ProgressDialog&lt;/code&gt; 우리가 사용 &lt;code&gt;waitForUser()&lt;/code&gt; 사용 후 사용자 상호 작용 약속을 캡처하는 방법을 &lt;code&gt;delayedPromise()&lt;/code&gt; 가짜 네트워크 약속을 포착하고 마지막으로 &lt;code&gt;Promise.reace()&lt;/code&gt; 평소와 같이 하나의 약속과 동시에 끝이를 관리 할 수 .</target>
        </trans-unit>
        <trans-unit id="294f81c22475eef4fbaab8c79a52c780d37a7f28" translate="yes" xml:space="preserve">
          <source>When working with promises the philosophy is basically a complete opposite than when using &lt;code&gt;async&lt;/code&gt;. Async provides a huge bag of uncomposable helper functions that work at a very low level of abstraction. When using promises you can get the utility otherwise provided by uncountable amount of inflexible helper functions by just combining and composing a few existing functions and concepts.</source>
          <target state="translated">약속과 함께 일할 때 철학은 기본적으로 &lt;code&gt;async&lt;/code&gt; 사용할 때와 완전히 반대 입니다. Async는 매우 낮은 수준의 추상화에서 작동하는 구성 불가능한 도우미 기능을 제공합니다. 약속을 사용할 때 몇 가지 기존 함수와 개념을 결합하고 구성하여 셀 수없는 융통성없는 도우미 함수가 제공하는 유틸리티를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa0d63ddeca860f4dd0ee04e6e6dfb59036ec440" translate="yes" xml:space="preserve">
          <source>Where blocking on a Future in scala is discouraged, in JavaScript it's downright impossible.</source>
          <target state="translated">스칼라에서 미래에 대한 차단이 권장되지 않는 경우 JavaScript에서는 완전히 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="a04b5cdd0c9e7373883bf0306180ab9eff2c21cc" translate="yes" xml:space="preserve">
          <source>Which is needed in case error handlers are attached asynchronously to the promise later, which would otherwise result in premature unhandled rejection reporting.</source>
          <target state="translated">오류 처리기가 나중에 약속에 비동기식으로 연결되어 처리되지 않은 거부보고가 조기에 발생하는 경우에 필요합니다.</target>
        </trans-unit>
        <trans-unit id="eee12cfe2d4a58cb2a6fc803d3775440ef97f722" translate="yes" xml:space="preserve">
          <source>Which would allow you to use:</source>
          <target state="translated">다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35d4fe62a5e87bc7beed2b0eec9121835e2b2243" translate="yes" xml:space="preserve">
          <source>Which would let you do:</source>
          <target state="translated">당신이 할 수있는 것 :</target>
        </trans-unit>
        <trans-unit id="048203462f9f2ccf893052bbc1b4ea9379b53188" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;cancel().&lt;/code&gt; is synchronous - &lt;code&gt;onCancel()&lt;/code&gt; is called asynchronously (in the next turn) just like &lt;code&gt;then&lt;/code&gt; handlers.</source>
          <target state="translated">&lt;code&gt;cancel().&lt;/code&gt; 동안 . 동기식 &lt;code&gt;onCancel()&lt;/code&gt; 은 &lt;code&gt;then&lt;/code&gt; 처리기 와 같이 비동기식으로 (다음 번에) 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="50051d4da0ca7d94943f9fa9969394e5949e12c1" translate="yes" xml:space="preserve">
          <source>While with long stack traces disabled, you would get:</source>
          <target state="translated">긴 스택 추적을 비활성화하면 다음과 같은 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a448f3eb7ee54eee8b460fbecc359153bf18d65f" translate="yes" xml:space="preserve">
          <source>Why I am switching to promises</source>
          <target state="translated">내가 약속으로 바꾸는 이유</target>
        </trans-unit>
        <trans-unit id="1472dbb2e195b22057a90d66f7a65b38461e79ba" translate="yes" xml:space="preserve">
          <source>Why Performance?</source>
          <target state="translated">왜 성능?</target>
        </trans-unit>
        <trans-unit id="103997b340ba267b74ce431e1b85c8fb216b7d7d" translate="yes" xml:space="preserve">
          <source>Why Promises?</source>
          <target state="translated">약속하는 이유</target>
        </trans-unit>
        <trans-unit id="7eed14a899fe9a4d5bf8f80b6404d95efa7b1db8" translate="yes" xml:space="preserve">
          <source>Why bluebird?</source>
          <target state="translated">왜 블루 버드인가?</target>
        </trans-unit>
        <trans-unit id="0f975858c19a385aa9526530dd08a5074375be2f" translate="yes" xml:space="preserve">
          <source>With the use of abstract classes can the similarities between &lt;code&gt;PromptDialog&lt;/code&gt; and &lt;code&gt;NotifyDialog&lt;/code&gt; be abstracted? Make a sub class of &lt;code&gt;Dialog&lt;/code&gt; that abstracts the common DOM code (&lt;code&gt;DOMDialog&lt;/code&gt;). Then refactor the &lt;code&gt;PromptDialog&lt;/code&gt; and &lt;code&gt;NotifyDialog&lt;/code&gt; to inherate from &lt;code&gt;DOMDialog&lt;/code&gt; but references the correct DOM selectors.</source>
          <target state="translated">추상 클래스를 사용하면 &lt;code&gt;PromptDialog&lt;/code&gt; 와 &lt;code&gt;NotifyDialog&lt;/code&gt; 의 유사성을 추상화 할 수 있습니까? 공통 DOM 코드를 추상화하는 &lt;code&gt;Dialog&lt;/code&gt; 의 하위 클래스를 만듭니다 ( &lt;code&gt;DOMDialog&lt;/code&gt; ). 그런 다음 &lt;code&gt;PromptDialog&lt;/code&gt; 및 &lt;code&gt;NotifyDialog&lt;/code&gt; 를 리팩터링하여 DOMDialog 에서 &lt;code&gt;DOMDialog&lt;/code&gt; 하지만 올바른 DOM 선택기를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b389c6872f328b7947b20ae5c017fe2c10bb9526" translate="yes" xml:space="preserve">
          <source>Without arrow functions that provide lexical &lt;code&gt;this&lt;/code&gt;, the correspondence between async and sync code breaks down when writing object-oriented code. &lt;a href=&quot;bind&quot;&gt;&lt;code&gt;.bind&lt;/code&gt;&lt;/a&gt; alleviates this.</source>
          <target state="translated">어휘 제공 화살표 기능이없는 &lt;code&gt;this&lt;/code&gt; , 객체 지향 코드를 작성할 때 아래로 비동기와 동기 코드 휴식의 대응. &lt;a href=&quot;bind&quot;&gt; &lt;code&gt;.bind&lt;/code&gt; 는이를&lt;/a&gt; 완화합니다.</target>
        </trans-unit>
        <trans-unit id="673b91ef144006953b2d0d3e1f31a66ba0a792bd" translate="yes" xml:space="preserve">
          <source>Working with Callbacks</source>
          <target state="translated">콜백 작업</target>
        </trans-unit>
        <trans-unit id="4814f16d83ce4c03a7697dffe837dd35ff625c3c" translate="yes" xml:space="preserve">
          <source>Working with any other APIs</source>
          <target state="translated">다른 API로 작업</target>
        </trans-unit>
        <trans-unit id="d5431ac75df408d5c9ffc310217a12d8d9dcbf00" translate="yes" xml:space="preserve">
          <source>Working with browser APIs</source>
          <target state="translated">브라우저 API 작업</target>
        </trans-unit>
        <trans-unit id="e3c2aac0738162450c1ba5ec6b637d0caf73d2e1" translate="yes" xml:space="preserve">
          <source>Working with callback APIs using the Node convention</source>
          <target state="translated">노드 규칙을 사용하여 콜백 API 작업</target>
        </trans-unit>
        <trans-unit id="37dd709d1ccc2e12457cf6c183d0dbd315ee98c2" translate="yes" xml:space="preserve">
          <source>Working with databases</source>
          <target state="translated">데이터베이스 작업</target>
        </trans-unit>
        <trans-unit id="f06f929d4baa5a3ecf78b00957e3722d031a73c3" translate="yes" xml:space="preserve">
          <source>Working with delays</source>
          <target state="translated">지연 작업</target>
        </trans-unit>
        <trans-unit id="5122dff991374514454140bce7e200af64069d8d" translate="yes" xml:space="preserve">
          <source>Working with delays/setTimeout</source>
          <target state="translated">지연 / setTimeout 작업</target>
        </trans-unit>
        <trans-unit id="a1c7659f3ee1ffff84437f6bd7a29c13e55a9375" translate="yes" xml:space="preserve">
          <source>Working with one time events</source>
          <target state="translated">일회성 이벤트 작업</target>
        </trans-unit>
        <trans-unit id="37316c9a58ae41ce75652d0e2a54b3a2feb756f2" translate="yes" xml:space="preserve">
          <source>Working with one time events.</source>
          <target state="translated">일회성 이벤트 작업.</target>
        </trans-unit>
        <trans-unit id="8b04f9b661548e262a9e539e7d756bac07782fea" translate="yes" xml:space="preserve">
          <source>Write a function that takes a &lt;code&gt;Dialog&lt;/code&gt; instance and a default value. Have it return a promise that resolves to the default value if the user clicks cancel.</source>
          <target state="translated">&lt;code&gt;Dialog&lt;/code&gt; 인스턴스와 기본값 을 취하는 함수를 작성하십시오 . 사용자가 취소를 클릭하면 기본값으로 해석되는 약속을 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="0cf07d9d6990a0b3a8a806a431339f0ecf271176" translate="yes" xml:space="preserve">
          <source>Yield handlers are called when you yield something that is not supported by default. The first yield handler to return a promise or a thenable will be used. If no yield handler returns a promise or a thenable then an error is raised.</source>
          <target state="translated">기본적으로 지원되지 않는 항목을 생성하면 양보 핸들러가 호출됩니다. promise 또는 thenable을 반환하는 첫 번째 yield 핸들러가 사용됩니다. yield 핸들러가 promise 또는 thenable을 반환하지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="cb668cd94f8eca0b469371342b38d09219dbd2d0" translate="yes" xml:space="preserve">
          <source>Yielding an array from a coroutine is not supported by default. You can use &lt;a href=&quot;api/coroutine.addyieldhandler&quot;&gt;&lt;code&gt;coroutine.addYieldHandler()&lt;/code&gt;&lt;/a&gt; to configure the old behavior (or any behavior you want).</source>
          <target state="translated">코 루틴에서 배열을 생성하는 것은 기본적으로 지원되지 않습니다. &lt;a href=&quot;api/coroutine.addyieldhandler&quot;&gt; &lt;code&gt;coroutine.addYieldHandler()&lt;/code&gt; &lt;/a&gt; 를 사용하여 이전 동작 (또는 원하는 동작 ) 을 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b43584c4df9052974185d0f13b0565b92e014095" translate="yes" xml:space="preserve">
          <source>You are able to yield non-promise values by adding your own yield handler using &lt;a href=&quot;promise.coroutine.addyieldhandler&quot;&gt;&lt;code&gt;Promise.coroutine.addYieldHandler&lt;/code&gt;&lt;/a&gt; or calling &lt;code&gt;Promise.coroutine()&lt;/code&gt; with a yield handler function as &lt;code&gt;options.yieldHandler&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;promise.coroutine.addyieldhandler&quot;&gt; &lt;code&gt;Promise.coroutine.addYieldHandler&lt;/code&gt; 를&lt;/a&gt; 사용 하거나 yield . 함수 함수를 &lt;code&gt;options.yieldHandler&lt;/code&gt; 로 사용하여 &lt;code&gt;Promise.coroutine()&lt;/code&gt; 을 호출 하여 약속 없음 값을 생성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e127999f42b63c2eddd476b0efc6c0cd617fe5c2" translate="yes" xml:space="preserve">
          <source>You are getting this error because you are enabling long stack traces after a promise has already been created.</source>
          <target state="translated">약속이 이미 작성된 후 긴 스택 추적을 사용 가능하게하므로이 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bf62350a61d792a4742ad486033ffd83aaf0f56d" translate="yes" xml:space="preserve">
          <source>You are getting this error because you have tried to &lt;code&gt;yield&lt;/code&gt; something in a coroutine without a yield handler, for example:</source>
          <target state="translated">수익률 처리기가없는 코 루틴에서 무언가 를 &lt;code&gt;yield&lt;/code&gt; 하려고했기 때문에이 오류가 발생 합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="66ca93bb6eb46f59e659c6e2ebfd242ff1f0e6ac" translate="yes" xml:space="preserve">
          <source>You are getting this error when trying to use &lt;a href=&quot;api/promise.coroutine&quot;&gt;&lt;code&gt;Promise.coroutine&lt;/code&gt;&lt;/a&gt; and not passing it a generator function as a parameter. For example:</source>
          <target state="translated">&lt;a href=&quot;api/promise.coroutine&quot;&gt; &lt;code&gt;Promise.coroutine&lt;/code&gt; &lt;/a&gt; 을 사용하려고 시도 하고 생성기 함수를 매개 변수로 전달하지 않으면 이 오류 가 발생합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="91785a774efe083e20f0a926f490793891f37e71" translate="yes" xml:space="preserve">
          <source>You can also pass the resources in an array in the first argument. In this case the handler function will only be called with one argument that is the array containing the resolved resources in respective positions in the array. Example:</source>
          <target state="translated">첫 번째 인수에서 배열의 리소스를 전달할 수도 있습니다. 이 경우 처리기 함수는 배열의 각 위치에서 확인 된 리소스를 포함하는 배열 인 하나의 인수로만 호출됩니다. 예:</target>
        </trans-unit>
        <trans-unit id="e1e28c9edbfac1286ca67380518a1038c18f9339" translate="yes" xml:space="preserve">
          <source>You can also refactor some looping patterns to a more natural form that would &lt;a href=&quot;https://github.com/promises-aplus/promises-spec/issues/179&quot;&gt;leak memory when using native promises&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/promises-aplus/promises-spec/issues/179&quot;&gt;기본 약속을 사용할 때 메모리를 누수&lt;/a&gt; 하는보다 자연스러운 형태로 일부 루핑 패턴을 리팩터링 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="437864fc7461809f33ab9ef10e2c5d258352b129" translate="yes" xml:space="preserve">
          <source>You can also use it as a hook:</source>
          <target state="translated">후크로 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c5b397ce7d92f145be04aede9a7905dd3a775cc" translate="yes" xml:space="preserve">
          <source>You can also use promises to improve code that was written with callbacks:</source>
          <target state="translated">콜백으로 작성된 코드를 개선하기 위해 약속을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="283713c3baaf7fbedb1d299415d2545b4024ca50" translate="yes" xml:space="preserve">
          <source>You can change bluebird behavior globally with various environment variables. These global variables affect all instances of bluebird that are running in your environment, rather than just the one you have &lt;code&gt;require&lt;/code&gt;d in your application. The effect an environment variable has depends on the bluebird version.</source>
          <target state="translated">다양한 환경 변수를 사용하여 블루 버드 동작을 전체적으로 변경할 수 있습니다. 이러한 전역 변수는 응용 프로그램에서 d 가 &lt;code&gt;require&lt;/code&gt; 것만이 아니라 사용자 환경에서 실행중인 모든 블루 버드 인스턴스에 영향을줍니다 . 환경 변수의 영향은 블루 버드 버전에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="06b2e22d4bf3505ebf9bddb84ee0510239a546e0" translate="yes" xml:space="preserve">
          <source>You can configure the warning for checking forgotten return statements with &lt;code&gt;wForgottenReturn&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;wForgottenReturn&lt;/code&gt; 으로 잊어 버린 리턴 명령문을 확인하기위한 경고를 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f5a9baad84a48a76541ea70044c4acc58a16ccf2" translate="yes" xml:space="preserve">
          <source>You can correct this by doing:</source>
          <target state="translated">다음을 수행하여이를 정정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81293703b0f372c4f1dd8c1c5f5f64e0b6876c85" translate="yes" xml:space="preserve">
          <source>You can get a reference to &lt;a href=&quot;aggregateerror&quot;&gt;&lt;code&gt;AggregateError&lt;/code&gt;&lt;/a&gt; from &lt;code&gt;Promise.AggregateError&lt;/code&gt;.</source>
          <target state="translated">당신에 대한 참조를 얻을 수 있습니다 &lt;a href=&quot;aggregateerror&quot;&gt; &lt;code&gt;AggregateError&lt;/code&gt; &lt;/a&gt; 에서 &lt;code&gt;Promise.AggregateError&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="1fa9ba97c4236ec4af4790e170f1a3227c61dec4" translate="yes" xml:space="preserve">
          <source>You can get this error for several reasons:</source>
          <target state="translated">여러 가지 이유로이 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef442967cec8981710fc742773b5611ef039af93" translate="yes" xml:space="preserve">
          <source>You can get this error when you're trying to call &lt;code&gt;.value&lt;/code&gt; or &lt;code&gt;.error&lt;/code&gt; when inspecting a promise where the promise has not been fulfilled or rejected yet.</source>
          <target state="translated">약속이 아직 이행되지 않았거나 거부되지 않은 약속을 검사 할 때 &lt;code&gt;.value&lt;/code&gt; 또는 &lt;code&gt;.error&lt;/code&gt; 를 호출하려고 할 때이 오류가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6f5a4a44a59a1f96bff1bedb0c04a482fd574dd1" translate="yes" xml:space="preserve">
          <source>You can promisify multiple classes in one go by constructing an array out of the classes and passing it to &lt;code&gt;promisifyAll&lt;/code&gt;:</source>
          <target state="translated">클래스 밖으로 배열을 구성하고이를 &lt;code&gt;promisifyAll&lt;/code&gt; 에 전달하여 여러 클래스를 한 번에 약속 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a9fb5d736e0ab6fce975e6a9b34a4fef475d7bc7" translate="yes" xml:space="preserve">
          <source>You got this error because you used &lt;code&gt;new Promise()&lt;/code&gt; or &lt;code&gt;new Promise(something)&lt;/code&gt; without passing a function as the parameter.</source>
          <target state="translated">매개 변수로 함수를 전달하지 않고 &lt;code&gt;new Promise()&lt;/code&gt; 또는 &lt;code&gt;new Promise(something)&lt;/code&gt; 를 사용했기 때문에이 오류가 발생했습니다 .</target>
        </trans-unit>
        <trans-unit id="a4d97ed3b9b528f072b3b9ef916af019f8c658c3" translate="yes" xml:space="preserve">
          <source>You got this this error because you've used &lt;code&gt;Promise.promisify&lt;/code&gt; on an object, for example:</source>
          <target state="translated">예를 들어 개체에서 &lt;code&gt;Promise.promisify&lt;/code&gt; 를 사용했기 때문에이 오류가 발생했습니다 .</target>
        </trans-unit>
        <trans-unit id="9ca3543e4c8b58e9db66720a46ab1377349e2f9b" translate="yes" xml:space="preserve">
          <source>You may also add multiple filters for a catch handler:</source>
          <target state="translated">캐치 핸들러에 여러 필터를 추가 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="83847d072bb765ac14ac4e083fdf4b485ddcd196" translate="yes" xml:space="preserve">
          <source>You may also use the custom suffix option to choose another suffix that doesn't result in conflicts.</source>
          <target state="translated">사용자 정의 접미사 옵션을 사용하여 충돌을 일으키지 않는 다른 접미사를 선택할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6624c3c603bb59caba6a82386be7841487cbe7f2" translate="yes" xml:space="preserve">
          <source>You may now return promises and thenables from the filterer function used in &lt;code&gt;Promise.filter&lt;/code&gt; and &lt;code&gt;Promise.prototype.filter&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Promise.filter&lt;/code&gt; 및 &lt;code&gt;Promise.prototype.filter&lt;/code&gt; 에 사용 된 filterer 함수에서 promise 및 thenables를 반환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="05e60416b3790827596a6ef7f2cab94aae07bff3" translate="yes" xml:space="preserve">
          <source>You may optionally prepend one predicate function or ErrorClass to pattern match the error (the generic &lt;a href=&quot;catch&quot;&gt;&lt;code&gt;.catch&lt;/code&gt;&lt;/a&gt; methods accepts multiple)</source>
          <target state="translated">선택적으로 하나의 술어 함수 또는 ErrorClass를 추가하여 오류와 패턴을 일치시킬 수 있습니다 (일반 &lt;a href=&quot;catch&quot;&gt; &lt;code&gt;.catch&lt;/code&gt; &lt;/a&gt; 메소드는 여러 개를 허용 함)</target>
        </trans-unit>
        <trans-unit id="4dea303545fcf8fcdea34efebeca4ef1c0a6fbdc" translate="yes" xml:space="preserve">
          <source>You may optionally specify a concurrency limit:</source>
          <target state="translated">선택적으로 동시성 제한을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f96ba6d073dbbb822c6dc38156f5d2c778c3e34" translate="yes" xml:space="preserve">
          <source>You may register an optional cancellation hook at a root promise by using the &lt;code&gt;onCancel&lt;/code&gt; argument that is passed to the executor function when cancellation is enabled:</source>
          <target state="translated">취소가 활성화 된 경우 실행기 함수에 전달 되는 &lt;code&gt;onCancel&lt;/code&gt; 인수를 사용하여 루트 약속에 선택적 취소 후크를 등록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="da7c4c4ceabe5cd66746addf080121cd0177cb25" translate="yes" xml:space="preserve">
          <source>You may use &lt;a href=&quot;api/promise.setscheduler&quot;&gt;&lt;code&gt;Promise.setScheduler&lt;/code&gt;&lt;/a&gt; to pass a custom scheduler that your environment supports. For example in DukTape:</source>
          <target state="translated">&lt;a href=&quot;api/promise.setscheduler&quot;&gt; &lt;code&gt;Promise.setScheduler&lt;/code&gt; &lt;/a&gt; 를 사용 하여 환경에서 지원하는 사용자 지정 스케줄러를 전달할 수 있습니다 . 예를 들어 DukTape에서 :</target>
        </trans-unit>
        <trans-unit id="72d529e0be153c472000cf98a0b7d4552852d11f" translate="yes" xml:space="preserve">
          <source>You may use browserify on the main export</source>
          <target state="translated">메인 내보내기에서 browserify를 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="5178ce348175a2d6a2e16b69f6aa6c59ef943a40" translate="yes" xml:space="preserve">
          <source>You may use the &lt;a href=&quot;http://bower.io&quot;&gt;bower&lt;/a&gt; package.</source>
          <target state="translated">&lt;a href=&quot;http://bower.io&quot;&gt;바우어&lt;/a&gt; 패키지를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="79662f72fb448baebdf8a6c7d0131a375dff4095" translate="yes" xml:space="preserve">
          <source>You might have to use a deferred object when wrapping a callback API that doesn't follow the standard convention. Like &lt;code&gt;setTimeout&lt;/code&gt;:</source>
          <target state="translated">표준 규칙을 따르지 않는 콜백 API를 래핑 할 때 지연된 객체를 사용해야 할 수도 있습니다. &lt;code&gt;setTimeout&lt;/code&gt; 처럼 :</target>
        </trans-unit>
        <trans-unit id="c2ac050d03d9c2bd58543cfcee398d79f07ec7bc" translate="yes" xml:space="preserve">
          <source>You might notice that the promise approach looks very similar to using synchronous I/O:</source>
          <target state="translated">약속 방식은 동기식 I / O를 사용하는 것과 매우 유사하게 보일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a07914b7b08162442f33327417b0ff4a50f4409e" translate="yes" xml:space="preserve">
          <source>You passed a non-function where a function was expected.</source>
          <target state="translated">함수가 예상 된 함수가 아닌 함수를 전달했습니다.</target>
        </trans-unit>
        <trans-unit id="cc81677e43359861a52ce63568e3d792c6bcee22" translate="yes" xml:space="preserve">
          <source>You should check if this promise is &lt;a href=&quot;isfulfilled&quot;&gt;&lt;code&gt;.isFulfilled()&lt;/code&gt;&lt;/a&gt; in code paths where it's not guaranteed that this promise is fulfilled.</source>
          <target state="translated">이 약속이 이행되었다고 보장되지 않는 코드 경로 에서이 약속이 &lt;a href=&quot;isfulfilled&quot;&gt; &lt;code&gt;.isFulfilled()&lt;/code&gt; &lt;/a&gt; 인지 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="88143ae7a4624ccb7145716c9f902897a88d096d" translate="yes" xml:space="preserve">
          <source>You should check if this promise is &lt;a href=&quot;isrejected&quot;&gt;&lt;code&gt;.isRejected()&lt;/code&gt;&lt;/a&gt; in code paths where it's guaranteed that this promise is rejected.</source>
          <target state="translated">이 약속이 거부되었음을 보장하는 코드 경로 에서이 약속이 &lt;a href=&quot;isrejected&quot;&gt; &lt;code&gt;.isRejected()&lt;/code&gt; &lt;/a&gt; 인지 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a5bc1b292604f8a755bedb0d6bdc5baa78c79e97" translate="yes" xml:space="preserve">
          <source>You should enabled long stack traces if you want better debugging experience. For example:</source>
          <target state="translated">더 나은 디버깅 경험을 원하면 긴 스택 추적을 활성화해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9389a4bd5323ad51b671d2380af345d329495a0f" translate="yes" xml:space="preserve">
          <source>You should heed this warning because rejecting a promise with a non-error makes debugging extremely hard and costly. Additionally, if you reject with simple primitives such as &lt;code&gt;undefined&lt;/code&gt; (commonly caused by simply calling &lt;code&gt;reject()&lt;/code&gt;) you cannot handle errors at all because it's impossible to tell from &lt;code&gt;undefined&lt;/code&gt; what exactly went wrong. All you can tell the user is that &quot;something went wrong&quot; and lose them forever.</source>
          <target state="translated">오류가없는 약속을 거부하면 디버깅이 매우 어렵고 비용이 많이 들기 때문에이 경고에 유의해야합니다. 또한 &lt;code&gt;undefined&lt;/code&gt; (보통 &lt;code&gt;reject()&lt;/code&gt; 를 호출하여 발생) 와 같은 간단한 프리미티브로 거부하는 경우 &lt;code&gt;undefined&lt;/code&gt; 내용을 정확히 잘못 알 수 없으므로 오류를 전혀 처리 할 수 ​​없습니다 . 사용자에게 &quot;무언가 잘못되었다&quot;는 말만하면 영원히 잃게됩니다.</target>
        </trans-unit>
        <trans-unit id="ee7d769e258faced0824e928a0c2037e1a245676" translate="yes" xml:space="preserve">
          <source>You should use promises to turn this:</source>
          <target state="translated">이것을 설정하려면 약속을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="3801444ae548127f53972d4de9db926d35147429" translate="yes" xml:space="preserve">
          <source>Your library can then use &lt;code&gt;var Promise = require(&quot;bluebird-extended&quot;);&lt;/code&gt; and do whatever it wants with it. Then if the application or other library uses their own bluebird promises they will all play well together because of Promises/A+ thenable assimilation magic.</source>
          <target state="translated">그러면 라이브러리에서 &lt;code&gt;var Promise = require(&quot;bluebird-extended&quot;);&lt;/code&gt; 원하는대로하세요 그런 다음 응용 프로그램이나 다른 라이브러리가 자체 블루 버드 약속을 사용하는 경우 약속 / A + 그때 가능한 동화 마법 때문에 모두 함께 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="2ea5d7794d32ab52b93c85c9e6c21b1aea324d24" translate="yes" xml:space="preserve">
          <source>because &lt;code&gt;data&lt;/code&gt; is &lt;code&gt;undefined&lt;/code&gt; at the time &lt;code&gt;.return&lt;/code&gt; is called.</source>
          <target state="translated">&lt;code&gt;.return&lt;/code&gt; 이 호출 될 때 &lt;code&gt;data&lt;/code&gt; 가 &lt;code&gt;undefined&lt;/code&gt; 않았기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="2c304689dc11138fde5d03ea645ecb41953e1334" translate="yes" xml:space="preserve">
          <source>bugfix</source>
          <target state="translated">bugfix</target>
        </trans-unit>
        <trans-unit id="321ef65dd8e0fe725eb1aefadf1bd87479757769" translate="yes" xml:space="preserve">
          <source>composes with other bluebird features, like &lt;a href=&quot;promise.all&quot;&gt;&lt;code&gt;Promise.all&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;promise.all&quot;&gt; &lt;code&gt;Promise.all&lt;/code&gt; &lt;/a&gt; 과 같은 다른 블루 버드 기능으로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="4b7615dce52c4c05ce4e1d374e9c61a13717ac7c" translate="yes" xml:space="preserve">
          <source>feature</source>
          <target state="translated">feature</target>
        </trans-unit>
        <trans-unit id="03e02ad7e48448605c30956ca4071a16aaf4bf8b" translate="yes" xml:space="preserve">
          <source>in the case where &lt;code&gt;value&lt;/code&gt; doesn't change its value because its binding time is different than when using a closure.</source>
          <target state="translated">경우에 &lt;code&gt;value&lt;/code&gt; 그 바인딩 시간 클로저를 사용할 때보 다 다르기 때문에 그 값을 변경하지 않는다.</target>
        </trans-unit>
        <trans-unit id="fdb19623519a22b9149620557f13925f7b42fd29" translate="yes" xml:space="preserve">
          <source>new Promise</source>
          <target state="translated">새로운 약속</target>
        </trans-unit>
        <trans-unit id="afbedb8dbf47bdab5c49c2b9d92015b7b3581a43" translate="yes" xml:space="preserve">
          <source>new Promise()</source>
          <target state="translated">새로운 약속 ()</target>
        </trans-unit>
        <trans-unit id="558916e0aef77e0a7a2bbe15ca31648114109299" translate="yes" xml:space="preserve">
          <source>no setup code required to make cancellation work</source>
          <target state="translated">취소 작업을하기 위해 설치 코드가 필요하지 않습니다</target>
        </trans-unit>
        <trans-unit id="4397a4d17f5c537ce4e705bcaf7b0efdd50c51d6" translate="yes" xml:space="preserve">
          <source>reasonable semantics for multiple consumer cancellation</source>
          <target state="translated">여러 소비자 취소에 대한 합리적인 의미</target>
        </trans-unit>
        <trans-unit id="748bc7560ff57854e11d5ab937864f0ff100bb12" translate="yes" xml:space="preserve">
          <source>resolving it with itself tells it &quot;it is done when it is done&quot;</source>
          <target state="translated">자체적으로 해결하면 &quot;완료되면 완료됩니다&quot;</target>
        </trans-unit>
        <trans-unit id="9379d4b4f4ef9775cb3c71402acd9e3e7970ea7f" translate="yes" xml:space="preserve">
          <source>throw TypeError when thenable resolves with itself</source>
          <target state="translated">thenable이 스스로 해결되면 TypeError를 던집니다.</target>
        </trans-unit>
        <trans-unit id="44176cf9434e38d37133324ac3fb90ae6fc35afd" translate="yes" xml:space="preserve">
          <source>~~Promise.longStackTraces~~</source>
          <target state="translated">~~Promise.longStackTraces~~</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
