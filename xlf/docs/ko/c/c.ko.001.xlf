<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="c">
    <body>
      <group id="c">
        <trans-unit id="d7164dee528e4af4171ce8e950bcb08c96acf10a" translate="yes" xml:space="preserve">
          <source>&quot;sequenced-before&quot; is an asymmetric, transitive, pair-wise relationship between evaluations within the same thread (it may extend across threads if atomic types and memory barriers are involved).</source>
          <target state="translated">&quot;시퀀스 이전&quot;은 동일한 스레드 내에서 평가간에 비대칭적이고 전이적인 쌍 방식 관계입니다 (원자 유형과 메모리 장벽이 포함 된 경우 스레드에 걸쳐 확장 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="eab27d51477a98912b7a12e287985652dd3aefca" translate="yes" xml:space="preserve">
          <source>#define - # - ##</source>
          <target state="translated"># 정의-#-##</target>
        </trans-unit>
        <trans-unit id="c1c8996a2b733fc70c1d5de67c09757269caec0b" translate="yes" xml:space="preserve">
          <source>#define directive</source>
          <target state="translated">#define 지시어</target>
        </trans-unit>
        <trans-unit id="955d9903c867672c445416826ac30c43abd1412d" translate="yes" xml:space="preserve">
          <source>#error directive</source>
          <target state="translated"># 오류 지시문</target>
        </trans-unit>
        <trans-unit id="90c15549724b2e95496eecca533328f69c79aa96" translate="yes" xml:space="preserve">
          <source>#if - #ifdef - #ifndef</source>
          <target state="translated">#if-#ifdef-#ifndef</target>
        </trans-unit>
        <trans-unit id="8702bf7bcf4f2a6c5c8ce91801bb4556314c7b7f" translate="yes" xml:space="preserve">
          <source>#include directive</source>
          <target state="translated">#include 지시문</target>
        </trans-unit>
        <trans-unit id="ee70983af3214fb9cb1c6c8bb031767586301e34" translate="yes" xml:space="preserve">
          <source>#line directive</source>
          <target state="translated">#line 지시어</target>
        </trans-unit>
        <trans-unit id="bd0df645673226466fc0eeda93f44ae1b4045f7f" translate="yes" xml:space="preserve">
          <source>#pragma directive</source>
          <target state="translated">#pragma 지시어</target>
        </trans-unit>
        <trans-unit id="51b62af02eb36fc9cf7725157e073948b56c90ed" translate="yes" xml:space="preserve">
          <source>#pragma once</source>
          <target state="translated">#pragma once</target>
        </trans-unit>
        <trans-unit id="94cec3bffa70f4ecc7e350695d60ca6f78a80312" translate="yes" xml:space="preserve">
          <source>#pragma pack</source>
          <target state="translated">#pragma pack</target>
        </trans-unit>
        <trans-unit id="fcbadf523c66f28967c5d79ec1bc2351140a8c38" translate="yes" xml:space="preserve">
          <source>&amp;copy; cppreference.com</source>
          <target state="translated">&amp;copy; cppreference.com</target>
        </trans-unit>
        <trans-unit id="f5687bed7280a56132e645e396836a7f85274f85" translate="yes" xml:space="preserve">
          <source>&amp;infin;) of the imaginary axis.</source>
          <target state="translated">허수의 &amp;infin;).</target>
        </trans-unit>
        <trans-unit id="61d747903dc6174ea868880eaa9d5c82b887cdfe" translate="yes" xml:space="preserve">
          <source>&amp;infin;,-</source>
          <target state="translated">&amp;infin;,-</target>
        </trans-unit>
        <trans-unit id="c41d83b1879caf75d3ccecb6a5198a9dcb08e4a9" translate="yes" xml:space="preserve">
          <source>&amp;int;&amp;infin;</source>
          <target state="translated">&amp;int;&amp;infin;</target>
        </trans-unit>
        <trans-unit id="3b65e0883c49d9a21d18c5fd488a526423198cf9" translate="yes" xml:space="preserve">
          <source>&amp;int;arg</source>
          <target state="translated">&amp;int;arg</target>
        </trans-unit>
        <trans-unit id="9a824a821fcd92546fd0f52e503da96fd2e6e8a0" translate="yes" xml:space="preserve">
          <source>&amp;minus;yv</source>
          <target state="translated">&amp;minus;yv</target>
        </trans-unit>
        <trans-unit id="da651efdffe8bace867b517b9b6aaa9028245da5" translate="yes" xml:space="preserve">
          <source>&amp;pi;</source>
          <target state="translated">&amp;pi;</target>
        </trans-unit>
        <trans-unit id="877392257bef230331f596c89268b8d8744067a3" translate="yes" xml:space="preserve">
          <source>&amp;pi; +</source>
          <target state="translated">&amp;pi; +</target>
        </trans-unit>
        <trans-unit id="a6aeb70dc40fa4a742dfaea4246f957644103376" translate="yes" xml:space="preserve">
          <source>&amp;pi; ;</source>
          <target state="translated">&amp;pi;;</target>
        </trans-unit>
        <trans-unit id="2473dcfb90d02e521917bf709207a5ae2bd16ca6" translate="yes" xml:space="preserve">
          <source>&amp;pi;] along the imaginary axis.</source>
          <target state="translated">&amp;pi;]를 가상의 축을 따라.</target>
        </trans-unit>
        <trans-unit id="dce88036edca5f362180f2a96ddfbc7f3bfc6366" translate="yes" xml:space="preserve">
          <source>&amp;plusmn;d</source>
          <target state="translated">&amp;plusmn;d</target>
        </trans-unit>
        <trans-unit id="e6e3d1af9ac765f337b0711b7cf30deb7ffcdc25" translate="yes" xml:space="preserve">
          <source>&amp;plusmn;dd</source>
          <target state="translated">&amp;plusmn;dd</target>
        </trans-unit>
        <trans-unit id="2fce89049bb9943b33def8dd01bb117b9055e7b0" translate="yes" xml:space="preserve">
          <source>&amp;plusmn;u + i(y &amp;plusmn; v)</source>
          <target state="translated">&amp;plusmn; u + i (y &amp;plusmn; v)</target>
        </trans-unit>
        <trans-unit id="5cce3de67be1794154451c873a09d78f6fa27ae6" translate="yes" xml:space="preserve">
          <source>&amp;plusmn;u + iy</source>
          <target state="translated">&amp;plusmn; u + iy</target>
        </trans-unit>
        <trans-unit id="4b14e48b18475db702f82fa6db96cbada4b7ef65" translate="yes" xml:space="preserve">
          <source>&amp;radic;&amp;pi;</source>
          <target state="translated">&amp;radic;&amp;pi;</target>
        </trans-unit>
        <trans-unit id="d8ea96571a5c9178d29e08ca82df79ecb3cc4c85" translate="yes" xml:space="preserve">
          <source>&amp;radic;1-z</source>
          <target state="translated">&amp;radic;1-z</target>
        </trans-unit>
        <trans-unit id="978455560355b4a8cb833b28c9db958268a6a0c1" translate="yes" xml:space="preserve">
          <source>&amp;radic;z-1</source>
          <target state="translated">&amp;radic;z-1</target>
        </trans-unit>
        <trans-unit id="01eca34bb9b17d1b03d0e3387ce08e23f3093325" translate="yes" xml:space="preserve">
          <source>&amp;sigma;&amp;radic;2</source>
          <target state="translated">&amp;sigma;&amp;radic;2</target>
        </trans-unit>
        <trans-unit id="c272d9c4cf1097a8b57dae2c23670565752b8463" translate="yes" xml:space="preserve">
          <source>(&amp;minus;yv) + i(xv)</source>
          <target state="translated">(&amp;minus;yv) + i (xv)</target>
        </trans-unit>
        <trans-unit id="9b39e23a2f345048fa780d8d0186234fd05bc153" translate="yes" xml:space="preserve">
          <source>(&amp;minus;yv) + i(yu)</source>
          <target state="translated">(&amp;minus;yv) + i (yu)</target>
        </trans-unit>
        <trans-unit id="ed6616dfd4625d08375f75e42d054cea464326b4" translate="yes" xml:space="preserve">
          <source>(1)</source>
          <target state="translated">(1)</target>
        </trans-unit>
        <trans-unit id="0916e9c38635a2a046dd2b3f1118cc17eec9d36d" translate="yes" xml:space="preserve">
          <source>(10)</source>
          <target state="translated">(10)</target>
        </trans-unit>
        <trans-unit id="e6d7bb8c1a4abf8e85622893d4e781d0d544d01b" translate="yes" xml:space="preserve">
          <source>(11)</source>
          <target state="translated">(11)</target>
        </trans-unit>
        <trans-unit id="41e278e691e64d2c1bbca7c929e681050ea2a211" translate="yes" xml:space="preserve">
          <source>(12)</source>
          <target state="translated">(12)</target>
        </trans-unit>
        <trans-unit id="0902ac4af971870547e03b039a7e5fcecf60148a" translate="yes" xml:space="preserve">
          <source>(2)</source>
          <target state="translated">(2)</target>
        </trans-unit>
        <trans-unit id="d77df6f4a77bbd6aa02c6035a0267d136736336a" translate="yes" xml:space="preserve">
          <source>(3)</source>
          <target state="translated">(3)</target>
        </trans-unit>
        <trans-unit id="10720c7cfed258d6a1fa627a781799fd12b2cc6a" translate="yes" xml:space="preserve">
          <source>(4)</source>
          <target state="translated">(4)</target>
        </trans-unit>
        <trans-unit id="28bd264a290377b8124b9b0b38bde400148a500d" translate="yes" xml:space="preserve">
          <source>(5)</source>
          <target state="translated">(5)</target>
        </trans-unit>
        <trans-unit id="d531ab20079dd9771b54bfab648528904866b8b4" translate="yes" xml:space="preserve">
          <source>(6)</source>
          <target state="translated">(6)</target>
        </trans-unit>
        <trans-unit id="f0b422b67ebefe17c506ae529e6f54d8ccea5242" translate="yes" xml:space="preserve">
          <source>(7)</source>
          <target state="translated">(7)</target>
        </trans-unit>
        <trans-unit id="630d9ccc0aa5428d4f10037c8cbdf0d7bec5cfb3" translate="yes" xml:space="preserve">
          <source>(8)</source>
          <target state="translated">(8)</target>
        </trans-unit>
        <trans-unit id="f565b2b5f3419cfa729b792b5d948992be0d69f1" translate="yes" xml:space="preserve">
          <source>(9)</source>
          <target state="translated">(9)</target>
        </trans-unit>
        <trans-unit id="0e3f1656c84b4ea9143ca7b420c95d10ebf29ef7" translate="yes" xml:space="preserve">
          <source>(&lt;a href=&quot;translation_phases&quot;&gt;the 96 characters&lt;/a&gt; that are required to be single-byte). C supports bytes of sizes 8 bits and greater.</source>
          <target state="translated">( 1 바이트 여야 &lt;a href=&quot;translation_phases&quot;&gt;하는 96 자&lt;/a&gt; ). C는 8 비트 이상의 크기의 바이트를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="60d68fea4b2f4f05989693f836ee86356812d0ef" translate="yes" xml:space="preserve">
          <source>(&lt;code&gt;float&lt;/code&gt; for &lt;code&gt;float &lt;a href=&quot;../numeric/complex/imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt; for &lt;code&gt;double &lt;a href=&quot;../numeric/complex/imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;long double&lt;/code&gt; for &lt;code&gt;long double &lt;a href=&quot;../numeric/complex/imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">( &lt;code&gt;float&lt;/code&gt; 에 대한 &lt;code&gt;float &lt;a href=&quot;../numeric/complex/imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; 에 &lt;code&gt;double &lt;a href=&quot;../numeric/complex/imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;long double&lt;/code&gt; 에 &lt;code&gt;long double &lt;a href=&quot;../numeric/complex/imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9c2ccc8a68bc5dd89871d5dcd185ea0a3ea3b6b6" translate="yes" xml:space="preserve">
          <source>(C11)</source>
          <target state="translated">(C11)</target>
        </trans-unit>
        <trans-unit id="c733a4fca9e6ae664ecf1dc62d189d462f57e7ba" translate="yes" xml:space="preserve">
          <source>(C11)(C11)</source>
          <target state="translated">(C11)(C11)</target>
        </trans-unit>
        <trans-unit id="39dda49007c9a46bef6ac72bec5f7b3383b64e32" translate="yes" xml:space="preserve">
          <source>(C11)(C11)(C11)</source>
          <target state="translated">(C11)(C11)(C11)</target>
        </trans-unit>
        <trans-unit id="5b5a3567d544847574d3028f0b72adbfe679c444" translate="yes" xml:space="preserve">
          <source>(C11)(deprecated in C17)</source>
          <target state="translated">(C11) (C17에서 더 이상 사용되지 않음)</target>
        </trans-unit>
        <trans-unit id="417acfaa59d4e6db98963a403c8972a9761cfaa2" translate="yes" xml:space="preserve">
          <source>(C95)</source>
          <target state="translated">(C95)</target>
        </trans-unit>
        <trans-unit id="27cf384f4bf7952ee84c42124381aac403a0f9c6" translate="yes" xml:space="preserve">
          <source>(C95)(C11)</source>
          <target state="translated">(C95)(C11)</target>
        </trans-unit>
        <trans-unit id="34512a7955c26c291d5939c6fb76ab3669faec94" translate="yes" xml:space="preserve">
          <source>(C95)(C95)(C95)(C11)(C11)(C11)</source>
          <target state="translated">(C95)(C95)(C95)(C11)(C11)(C11)</target>
        </trans-unit>
        <trans-unit id="08acaf1e208899a13717016cb9d28e40ef26e9c6" translate="yes" xml:space="preserve">
          <source>(C95)(C95)(C95)(C11)(C11)(C11)(C11)</source>
          <target state="translated">(C95)(C95)(C95)(C11)(C11)(C11)(C11)</target>
        </trans-unit>
        <trans-unit id="6391810db1e52cf600d149700061c68d08fbd302" translate="yes" xml:space="preserve">
          <source>(C95)(C99)</source>
          <target state="translated">(C95)(C99)</target>
        </trans-unit>
        <trans-unit id="1121c46b1b0ec2f8186203fd54f693a169618586" translate="yes" xml:space="preserve">
          <source>(C99)</source>
          <target state="translated">(C99)</target>
        </trans-unit>
        <trans-unit id="08752d6e74ba32f4122f7b9d54940d42daf1842d" translate="yes" xml:space="preserve">
          <source>(C99) If it is a declaration, it is in scope in the entire loop body, including the remainder of init_clause, the entire cond_expression, the entire iteration_expression and the entire loop_statement. Only &lt;code&gt;auto&lt;/code&gt; and &lt;code&gt;register&lt;/code&gt;&lt;a href=&quot;storage_duration&quot;&gt;storage classes&lt;/a&gt; are allowed for the variables declared in this declaration.</source>
          <target state="translated">(C99) 선언 인 경우, 나머지 init_clause, 전체 cond_expression, 전체 iteration_expression 및 전체 loop_statement를 포함하여 전체 루프 본문에 포함됩니다. 만 &lt;code&gt;auto&lt;/code&gt; 및 &lt;code&gt;register&lt;/code&gt; &lt;a href=&quot;storage_duration&quot;&gt;스토리지 클래스는&lt;/a&gt; 이 선언에서 선언 된 변수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a195d4ac88b9257c28b520fefc6c334a6d57e11d" translate="yes" xml:space="preserve">
          <source>(C99)(C11)(C11)(C11)(C11)</source>
          <target state="translated">(C99)(C11)(C11)(C11)(C11)</target>
        </trans-unit>
        <trans-unit id="0ce6a7be5fa0b91aee2f9258614410ace8a1cbb6" translate="yes" xml:space="preserve">
          <source>(C99)(C95)(C99)</source>
          <target state="translated">(C99)(C95)(C99)</target>
        </trans-unit>
        <trans-unit id="026b68c3ad63a7f1546d27ed9fd3c227058da37e" translate="yes" xml:space="preserve">
          <source>(C99)(C99)</source>
          <target state="translated">(C99)(C99)</target>
        </trans-unit>
        <trans-unit id="e74bc70942ad0ce04f76e6a18f905c69af5eb09c" translate="yes" xml:space="preserve">
          <source>(C99)(C99)(C99)</source>
          <target state="translated">(C99)(C99)(C99)</target>
        </trans-unit>
        <trans-unit id="a5c103871af2eb0d422705736f6067b2c14d768e" translate="yes" xml:space="preserve">
          <source>(C99)(C99)(C99)(C11)(C11)(C11)</source>
          <target state="translated">(C99)(C99)(C99)(C11)(C11)(C11)</target>
        </trans-unit>
        <trans-unit id="23bf161681c87bfb9eb48dec5230e86f57b44d3a" translate="yes" xml:space="preserve">
          <source>(C99)(C99)(C99)(C99)(C99)</source>
          <target state="translated">(C99)(C99)(C99)(C99)(C99)</target>
        </trans-unit>
        <trans-unit id="ce17267f7c19e5b543a4f025e94a7c9cf1c2db3c" translate="yes" xml:space="preserve">
          <source>(C99)(C99)(C99)(C99)(C99)(C99)</source>
          <target state="translated">(C99)(C99)(C99)(C99)(C99)(C99)</target>
        </trans-unit>
        <trans-unit id="f737f6bdebe988c3bd5b2f301e1913bfdafcac6f" translate="yes" xml:space="preserve">
          <source>(C99)(C99)(C99)(C99)(C99)(C99)(C99)(C99)(C99)</source>
          <target state="translated">(C99)(C99)(C99)(C99)(C99)(C99)(C99)(C99)(C99)</target>
        </trans-unit>
        <trans-unit id="ff6b4e7aab6f29d8bc022c1f4cc74fffdae634c9" translate="yes" xml:space="preserve">
          <source>(C99).</source>
          <target state="translated">(C99).</target>
        </trans-unit>
        <trans-unit id="3d59ea93dc58890ee949404da3e2e1c2d3025311" translate="yes" xml:space="preserve">
          <source>(C99)&lt;a href=&quot;compound_literal&quot;&gt;compound literals&lt;/a&gt;</source>
          <target state="translated">(C99) &lt;a href=&quot;compound_literal&quot;&gt;복합 리터럴&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f8b6ba8c4e646dd42451faf0f5949db160be3855" translate="yes" xml:space="preserve">
          <source>(C99)if one is declared with a tag, the other must also be declared with the same tag.</source>
          <target state="translated">(C99) 하나가 태그로 선언 된 경우 다른 태그도 동일한 태그로 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="77a5f5dc457de31934706abafc141b2e19bd509f" translate="yes" xml:space="preserve">
          <source>(Euler's number, &lt;code&gt;2.7182818&lt;/code&gt;) raised to the given power &lt;code&gt;arg&lt;/code&gt;, minus &lt;code&gt;1.0&lt;/code&gt;. This function is more accurate than the expression &lt;code&gt;&lt;a href=&quot;exp&quot;&gt;exp&lt;/a&gt;(arg)-1.0&lt;/code&gt; if &lt;code&gt;arg&lt;/code&gt; is close to zero.</source>
          <target state="translated">(Euler 's number, &lt;code&gt;2.7182818&lt;/code&gt; ) 주어진 주어진 전력 &lt;code&gt;arg&lt;/code&gt; - 마이너스 &lt;code&gt;1.0&lt;/code&gt; 으로 올림 . &lt;code&gt;arg&lt;/code&gt; 가 0에 가까우 면 이 함수는 &lt;code&gt;&lt;a href=&quot;exp&quot;&gt;exp&lt;/a&gt;(arg)-1.0&lt;/code&gt; 보다 더 정확 합니다.</target>
        </trans-unit>
        <trans-unit id="e59d7f1fa1e61b0e07ef5287b731aeafc70f540b" translate="yes" xml:space="preserve">
          <source>(Euler's number, &lt;code&gt;2.7182818&lt;/code&gt;) raised to the given power &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="translated">(Euler 's number, &lt;code&gt;2.7182818&lt;/code&gt; ) 주어진 힘 &lt;code&gt;arg&lt;/code&gt; 로 올렸습니다 .</target>
        </trans-unit>
        <trans-unit id="4edd6a587d4dd003f2013d97709b966836330b9f" translate="yes" xml:space="preserve">
          <source>(NaN), which does not compare equal with anything (including itself). Multiple bit patterns represent NaNs, see &lt;code&gt;&lt;a href=&quot;../numeric/math/nan.2&quot;&gt;nan&lt;/a&gt;&lt;/code&gt;, &lt;a href=&quot;../numeric/math/nan&quot;&gt;&lt;code&gt;NAN&lt;/code&gt;&lt;/a&gt;. Note that C takes no special notice of signalling NaNs (specified by IEEE-754), and treates all NaNs as quiet.</source>
          <target state="translated">(NaN)은 (자체를 포함하여) 다른 것과 동등하지 않습니다. 다중 비트 패턴은 NaN을 나타냅니다 ( &lt;code&gt;&lt;a href=&quot;../numeric/math/nan.2&quot;&gt;nan&lt;/a&gt;&lt;/code&gt; , &lt;a href=&quot;../numeric/math/nan&quot;&gt; &lt;code&gt;NAN&lt;/code&gt; &lt;/a&gt; 참조) . C는 NaN (IEEE-754에 의해 지정됨) 신호에 특별한주의를 기울이지 않으며 모든 NaN을 조용한 것으로 취급합니다.</target>
        </trans-unit>
        <trans-unit id="718c9a952212037934b9931393d8af18b620370b" translate="yes" xml:space="preserve">
          <source>(Note: &lt;a href=&quot;conformance&quot;&gt;Strictly conforming&lt;/a&gt; programs do not depend on any unspecified, undefined, or implementation-defined behavior).</source>
          <target state="translated">(참고 : &lt;a href=&quot;conformance&quot;&gt;엄격하게 준수하는&lt;/a&gt; 프로그램은 지정되지 않은, 정의되지 않은 또는 구현 정의 된 동작에 의존하지 않습니다).</target>
        </trans-unit>
        <trans-unit id="a2defffadabf94277e88495a362e6e04c50f5b8d" translate="yes" xml:space="preserve">
          <source>(POWER, Sparc, Itanium) and</source>
          <target state="translated">(POWER, Sparc, Itanium) 및</target>
        </trans-unit>
        <trans-unit id="2841c6db45aa1a109c8739facf1fe8ee6ae6e97a" translate="yes" xml:space="preserve">
          <source>(a value is the meaning of the contents of an object, when interpreted as having a specific &lt;a href=&quot;compatible_type&quot;&gt;type&lt;/a&gt;).</source>
          <target state="translated">(값은 특정 &lt;a href=&quot;compatible_type&quot;&gt;유형&lt;/a&gt; 을 갖는 것으로 해석 될 때 객체의 내용의 의미입니다 ).</target>
        </trans-unit>
        <trans-unit id="c6bf7dc1758c2eb741fb9d8e032fef809be283bd" translate="yes" xml:space="preserve">
          <source>(arg), or arcosh(arg)) on the interval [0, +&amp;infin;], is returned.</source>
          <target state="translated">간격 [0, + &amp;infin;]에서 (arg) 또는 arcosh (arg))가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="11a4fbe41a9d18dd973e5dd71e62cb1c18a60e2d" translate="yes" xml:space="preserve">
          <source>(arg), or arsinh(arg)), is returned.</source>
          <target state="translated">(arg) 또는 arsinh (arg))가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="9fd36d7a2124812bda35cc828fa3192dcba7683b" translate="yes" xml:space="preserve">
          <source>(arg), or artanh(arg)), is returned.</source>
          <target state="translated">(arg) 또는 artanh (arg))가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="67c957a5c36d0bcbc76def9f13b445d557deac80" translate="yes" xml:space="preserve">
          <source>(as with relational operators, pointers to objects that aren't elements of any array behave as pointers to elements of arrays of size 1).</source>
          <target state="translated">관계 연산자와 마찬가지로 배열의 요소가 아닌 객체에 대한 포인터는 크기가 1 인 배열의 요소에 대한 포인터로 동작합니다.</target>
        </trans-unit>
        <trans-unit id="4bdece1e9dc9d76a30e62baf68885afa25466405" translate="yes" xml:space="preserve">
          <source>(class)</source>
          <target state="translated">(class)</target>
        </trans-unit>
        <trans-unit id="5065a725ae1556e223b1e0a38fc5cd8619ef05e2" translate="yes" xml:space="preserve">
          <source>(constant)</source>
          <target state="translated">(constant)</target>
        </trans-unit>
        <trans-unit id="ac957d7960f9c4da26f8337848f7582cc0a87ae5" translate="yes" xml:space="preserve">
          <source>(cos(y) + i sin(y)).</source>
          <target state="translated">(cos (y) + i sin (y))입니다.</target>
        </trans-unit>
        <trans-unit id="dc11ef8438c2a43129c2b72cdf1be00c7ed27750" translate="yes" xml:space="preserve">
          <source>(deprecated in C17)</source>
          <target state="translated">(C17에서 더 이상 사용되지 않음)</target>
        </trans-unit>
        <trans-unit id="952b250384597c909ce5e439dd2223ad8acd846d" translate="yes" xml:space="preserve">
          <source>(dynamic memory TR)</source>
          <target state="translated">(동적 메모리 TR)</target>
        </trans-unit>
        <trans-unit id="5566fa76456a1a91a12eef14ca044076c12ac048" translate="yes" xml:space="preserve">
          <source>(e.g. in &lt;code&gt;1+2*3&lt;/code&gt;, the operands of operator+ are the subexpression &lt;code&gt;2*3&lt;/code&gt; and the primary expression &lt;code&gt;1&lt;/code&gt;).</source>
          <target state="translated">(예 : &lt;code&gt;1+2*3&lt;/code&gt; 에서 operator +의 피연산자는 하위 표현식 &lt;code&gt;2*3&lt;/code&gt; 및 기본 표현식 &lt;code&gt;1&lt;/code&gt; 입니다 ).</target>
        </trans-unit>
        <trans-unit id="263e4445ee6e8a9b5ffbc3ad4fdafc9fa40f62d7" translate="yes" xml:space="preserve">
          <source>(enum)</source>
          <target state="translated">(enum)</target>
        </trans-unit>
        <trans-unit id="cdcfe4ea535829168aec01a8bb7e96fe367a58c4" translate="yes" xml:space="preserve">
          <source>(follows) &lt;code&gt;rhs&lt;/code&gt;.</source>
          <target state="translated">(따라) &lt;code&gt;rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22a4704e45064ecaff2d60805ed3e3ee871d2009" translate="yes" xml:space="preserve">
          <source>(for &lt;code&gt;sprintf_s&lt;/code&gt; only), the string to be stored in &lt;code&gt;buffer&lt;/code&gt; (including the trailing null) would be exceed &lt;code&gt;bufsz&lt;/code&gt;</source>
          <target state="translated">( &lt;code&gt;sprintf_s&lt;/code&gt; 만 해당) &lt;code&gt;buffer&lt;/code&gt; 저장 될 문자열 (후미 널 포함)은 &lt;code&gt;bufsz&lt;/code&gt; 를 초과 합니다.</target>
        </trans-unit>
        <trans-unit id="7bbd84c5c39800ff7d84476ea2104f1e8331688e" translate="yes" xml:space="preserve">
          <source>(for &lt;code&gt;vsprintf_s&lt;/code&gt; only), the string to be stored in &lt;code&gt;buffer&lt;/code&gt; (including the trailing null)) would be exceed &lt;code&gt;bufsz&lt;/code&gt;</source>
          <target state="translated">( &lt;code&gt;vsprintf_s&lt;/code&gt; 만 해당) &lt;code&gt;buffer&lt;/code&gt; 저장 될 문자열 (후미 널 포함)은 &lt;code&gt;bufsz&lt;/code&gt; 를 초과 합니다.</target>
        </trans-unit>
        <trans-unit id="d5426ff48c08217b237357d25b0aeeec3096d246" translate="yes" xml:space="preserve">
          <source>(for &lt;code&gt;vswprintf_s&lt;/code&gt; only), the string to be stored in &lt;code&gt;buffer&lt;/code&gt; (including the trailing wide null) would be exceed &lt;code&gt;bufsz&lt;/code&gt;</source>
          <target state="translated">( &lt;code&gt;vswprintf_s&lt;/code&gt; 만 해당) &lt;code&gt;buffer&lt;/code&gt; 저장 될 문자열 (후미 널 포함)은 &lt;code&gt;bufsz&lt;/code&gt; 를 초과 합니다.</target>
        </trans-unit>
        <trans-unit id="8a12c15cdf4eff28ac4acc67fb2d6770e85d42c2" translate="yes" xml:space="preserve">
          <source>(for example, both parameters of &lt;code&gt;&lt;a href=&quot;math/pow&quot;&gt;pow&lt;/a&gt;&lt;/code&gt; are generic parameters, but only the first parameter of &lt;code&gt;&lt;a href=&quot;math/scalbn&quot;&gt;scalbn&lt;/a&gt;&lt;/code&gt; is a generic parameter).</source>
          <target state="translated">예를 들어, &lt;code&gt;&lt;a href=&quot;math/pow&quot;&gt;pow&lt;/a&gt;&lt;/code&gt; 의 두 매개 변수는 모두 일반 매개 변수이지만 &lt;code&gt;&lt;a href=&quot;math/scalbn&quot;&gt;scalbn&lt;/a&gt;&lt;/code&gt; 의 첫 번째 매개 변수 만 일반 매개 변수입니다.</target>
        </trans-unit>
        <trans-unit id="bbe03abe60df3921bf1b1dabe87cd3538fa41617" translate="yes" xml:space="preserve">
          <source>(function macro)</source>
          <target state="translated">(기능 매크로)</target>
        </trans-unit>
        <trans-unit id="d720d1479fef9c06c2fa4729f4fff424550c2ed8" translate="yes" xml:space="preserve">
          <source>(function)</source>
          <target state="translated">(function)</target>
        </trans-unit>
        <trans-unit id="ed7dcdaf04f0e96a1116bec307ad86fcff52b6ef" translate="yes" xml:space="preserve">
          <source>(if present in the translation unit) or the</source>
          <target state="translated">(번역 단위에있는 경우) 또는</target>
        </trans-unit>
        <trans-unit id="c2858a7af676acf1586a51e91e4359d7ba6ce7a6" translate="yes" xml:space="preserve">
          <source>(keyword macro)</source>
          <target state="translated">(키워드 매크로)</target>
        </trans-unit>
        <trans-unit id="74c30a64a845fec0504be78d754393306a373980" translate="yes" xml:space="preserve">
          <source>(macro constant)</source>
          <target state="translated">(매크로 상수)</target>
        </trans-unit>
        <trans-unit id="cfcb76465321134e894b8c3083d0b2a7929cd09d" translate="yes" xml:space="preserve">
          <source>(macro variable)</source>
          <target state="translated">(매크로 변수)</target>
        </trans-unit>
        <trans-unit id="ab5acdcc0fb6bbbfc118091779c8e2b261fea6e4" translate="yes" xml:space="preserve">
          <source>(no macro)</source>
          <target state="translated">(매크로 없음)</target>
        </trans-unit>
        <trans-unit id="3c6b183d348f955357b33a3fba45083e98ab8125" translate="yes" xml:space="preserve">
          <source>(none)</source>
          <target state="translated">(none)</target>
        </trans-unit>
        <trans-unit id="8ad5520ebd97d40c8e86735b481554753b1f56e3" translate="yes" xml:space="preserve">
          <source>(none).</source>
          <target state="translated">(none).</target>
        </trans-unit>
        <trans-unit id="70a2349ef433c293c653733e8acd91ff4351ce20" translate="yes" xml:space="preserve">
          <source>(on platforms where null pointers and floating zeroes have all-bit-zero representations, this form of initialization for statics is normally implemented by allocating them in the .bss section of the program image)</source>
          <target state="translated">(널 포인터와 부동 영 (0)이 모두 비트 0으로 표현되는 플랫폼에서 정적에 대한이 초기화 형식은 일반적으로 프로그램 이미지의 .bss 섹션에 할당하여 구현됩니다)</target>
        </trans-unit>
        <trans-unit id="38112942068b45b814445b63ea6dc3430b339f9f" translate="yes" xml:space="preserve">
          <source>(only for &lt;code&gt;swprintf_s&lt;/code&gt;) the number of wide characters to be written, including the null, would exceed &lt;code&gt;bufsz&lt;/code&gt;.</source>
          <target state="translated">( &lt;code&gt;swprintf_s&lt;/code&gt; 만 해당 ) 널을 포함하여 쓸 와이드 문자 수는 &lt;code&gt;bufsz&lt;/code&gt; 를 초과 합니다 .</target>
        </trans-unit>
        <trans-unit id="5698533a10e4551451a486a8ea1006fd414990b0" translate="yes" xml:space="preserve">
          <source>(only when declaring functions), zero or more function specifiers: &lt;a href=&quot;inline&quot;&gt;inline&lt;/a&gt;, &lt;a href=&quot;_noreturn&quot;&gt;_Noreturn&lt;/a&gt;</source>
          <target state="translated">(함수 선언시에만), 0 개 이상의 함수 지정자 : &lt;a href=&quot;inline&quot;&gt;inline&lt;/a&gt; , &lt;a href=&quot;_noreturn&quot;&gt;_Noreturn&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8b0163568bbc6f5414868ce09fde7187008bb0b0" translate="yes" xml:space="preserve">
          <source>(operator macro)</source>
          <target state="translated">(연산자 매크로)</target>
        </trans-unit>
        <trans-unit id="b16c7ac6faff07d7e255da685e52bd66d3bf1575" translate="yes" xml:space="preserve">
          <source>(optional)</source>
          <target state="translated">(optional)</target>
        </trans-unit>
        <trans-unit id="deb1825933fe3c9bf66d3dfb59330dd59f24957d" translate="yes" xml:space="preserve">
          <source>(optional) assignment-suppressing character &lt;code&gt;*&lt;/code&gt;. If this option is present, the function does not assign the result of the conversion to any receiving argument.</source>
          <target state="translated">(선택 사항) 지정 억제 문자 &lt;code&gt;*&lt;/code&gt; . 이 옵션이 있으면 함수는 변환 결과를 수신 인수에 지정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="87c3fc6b1ace0350438c728ae7dad2fd114adeb1" translate="yes" xml:space="preserve">
          <source>(optional) integer number (greater than zero) that specifies</source>
          <target state="translated">(선택 사항) 다음을 지정하는 정수 (0보다 큼)</target>
        </trans-unit>
        <trans-unit id="e0f6d81c2c3b1516e07c96f573ffe432220feae7" translate="yes" xml:space="preserve">
          <source>(optional) integer value or &lt;code&gt;*&lt;/code&gt; that specifies minimum field width. The result is padded with</source>
          <target state="translated">(선택 사항) 정수 필드 또는 최소 필드 너비를 지정하는 &lt;code&gt;*&lt;/code&gt; 결과는</target>
        </trans-unit>
        <trans-unit id="1df32ec6c02c37e8aad95b2c28acdb57c3cbd370" translate="yes" xml:space="preserve">
          <source>(optional) one or more flags that modify the behavior of the conversion:</source>
          <target state="translated">(선택 사항) 변환 동작을 수정하는 하나 이상의 플래그 :</target>
        </trans-unit>
        <trans-unit id="1f62635b50cfad604832a862363b696dfc559781" translate="yes" xml:space="preserve">
          <source>(optional) plus or minus sign</source>
          <target state="translated">(선택 사항) 더하기 또는 빼기 기호</target>
        </trans-unit>
        <trans-unit id="6753603453b7e70457c252ee87431112718d0fe3" translate="yes" xml:space="preserve">
          <source>(optional) prefix (&lt;code&gt;0&lt;/code&gt;) indicating octal base (applies only when the base is &lt;code&gt;8&lt;/code&gt; or &lt;code&gt;​0​&lt;/code&gt;)</source>
          <target state="translated">(선택적) 프리픽스 ( &lt;code&gt;0&lt;/code&gt; 진수베이스를 나타내는)의 (기지 인 경우에만 적용 &lt;code&gt;8&lt;/code&gt; 또는 &lt;code&gt;​0​&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="38a0344380df2361cbf6a9087734211fbab33629" translate="yes" xml:space="preserve">
          <source>(optional) prefix (&lt;code&gt;0x&lt;/code&gt; or &lt;code&gt;0X&lt;/code&gt;) indicating hexadecimal base (applies only when the base is &lt;code&gt;16&lt;/code&gt; or &lt;code&gt;​0​&lt;/code&gt;)</source>
          <target state="translated">(선택적) 프리픽스 ( &lt;code&gt;0x&lt;/code&gt; 또는 &lt;code&gt;0X&lt;/code&gt; ) 진수를 나타내는베이스 (베이스 인 경우에만 적용된다 &lt;code&gt;16&lt;/code&gt; 또는 &lt;code&gt;​0​&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="329760e773c6af94aa67c37c019abf1407c04a37" translate="yes" xml:space="preserve">
          <source>(optional)&lt;code&gt;.&lt;/code&gt; followed by integer number or &lt;code&gt;*&lt;/code&gt;, or neither that specifies</source>
          <target state="translated">(선택 사항) &lt;code&gt;.&lt;/code&gt; 그 뒤에 정수 또는 &lt;code&gt;*&lt;/code&gt; 가 오거나</target>
        </trans-unit>
        <trans-unit id="e6dd0268ccf821e4b1344a05da773ab9781732f2" translate="yes" xml:space="preserve">
          <source>(optional)&lt;code&gt;e&lt;/code&gt; or &lt;code&gt;E&lt;/code&gt; followed with optional minus or plus sign and nonempty sequence of decimal digits (defines exponent)</source>
          <target state="translated">(선택적) &lt;code&gt;e&lt;/code&gt; 또는 &lt;code&gt;E&lt;/code&gt; 다음에 선택적 마이너스 또는 더하기 부호 및 비어 있지 않은 10 진 숫자 시퀀스 (지수 정의)</target>
        </trans-unit>
        <trans-unit id="94025850ea5a02c849e26f51c369ad4ae1907a4f" translate="yes" xml:space="preserve">
          <source>(optional)&lt;code&gt;p&lt;/code&gt; or &lt;code&gt;P&lt;/code&gt; followed with optional minus or plus sign and nonempty sequence of decimal digits (defines exponent)</source>
          <target state="translated">(선택적) &lt;code&gt;p&lt;/code&gt; 또는 &lt;code&gt;P&lt;/code&gt; 다음에 선택적 마이너스 또는 더하기 부호 및 비어 있지 않은 10 진 숫자 시퀀스 (지수 정의)</target>
        </trans-unit>
        <trans-unit id="e38d649253dd48ff2f57d808ee23787436ac9022" translate="yes" xml:space="preserve">
          <source>(positive and negative), see &lt;a href=&quot;../numeric/math/infinity&quot;&gt;&lt;code&gt;INFINITY&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">(긍정적 및 부정적), &lt;a href=&quot;../numeric/math/infinity&quot;&gt; &lt;code&gt;INFINITY&lt;/code&gt; &lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="0b1d3698459345ff4fa76e7e4d4193b72278d212" translate="yes" xml:space="preserve">
          <source>(precedes) &lt;code&gt;rhs&lt;/code&gt;.</source>
          <target state="translated">(가) &lt;code&gt;rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="62d62242636e37f9222ae8775fd68ef0d989cdb3" translate="yes" xml:space="preserve">
          <source>(provided only if the implementation directly supports the type)</source>
          <target state="translated">(구현이 직접 유형을 지원하는 경우에만 제공됨)</target>
        </trans-unit>
        <trans-unit id="796614b6db3defa8f6626d01fccd06a3767b301e" translate="yes" xml:space="preserve">
          <source>(public member object)</source>
          <target state="translated">(공개 멤버 개체)</target>
        </trans-unit>
        <trans-unit id="d469ed89d723e8a9c5a844983dd536fc2d41ace6" translate="yes" xml:space="preserve">
          <source>(removed in C11)</source>
          <target state="translated">(C11에서 제거됨)</target>
        </trans-unit>
        <trans-unit id="357aed91b4096f126f6eadd482cc2ac031962810" translate="yes" xml:space="preserve">
          <source>(removed in C11)(since C11)</source>
          <target state="translated">(C11에서 제거됨) (C11부터)</target>
        </trans-unit>
        <trans-unit id="6a5392a822cc666c6892359a5edf283295ae8bb3" translate="yes" xml:space="preserve">
          <source>(see &lt;a href=&quot;declarations&quot;&gt;declarations&lt;/a&gt;) as would be used to declare a single object or function of this type, except that the identifier is omitted:</source>
          <target state="translated">식별자가 생략 된 것을 제외하고이 유형의 단일 객체 또는 함수를 선언하는 데 사용되는 ( &lt;a href=&quot;declarations&quot;&gt;선언&lt;/a&gt; 참조 ) :</target>
        </trans-unit>
        <trans-unit id="528b4d2cec744d88391d5ec0b5975b6c8265a2f5" translate="yes" xml:space="preserve">
          <source>(see above)</source>
          <target state="translated">(위 참조)</target>
        </trans-unit>
        <trans-unit id="a4b2afe3f8a4473cdca5cbdb0fc7a2144ba8b049" translate="yes" xml:space="preserve">
          <source>(see below) is implicitly converted to the type of the operand with the greater</source>
          <target state="translated">(아래 참조)는 더 큰 피연산자 유형으로 암시 적으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="7f9fb955327929bf88648f76040f736dc149e29b" translate="yes" xml:space="preserve">
          <source>(see below), and each argument of type &lt;code&gt;float&lt;/code&gt; is implicitly converted to the type &lt;code&gt;double&lt;/code&gt;.</source>
          <target state="translated">(아래 참조) &lt;code&gt;float&lt;/code&gt; 유형의 각 인수 는 암시 적으로 &lt;code&gt;double&lt;/code&gt; 유형으로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="8c5332d4d62d8b27fd936cafd05bfd71f38b8cf6" translate="yes" xml:space="preserve">
          <source>(see below), which includes the values of explicitly named constants (</source>
          <target state="translated">(아래 참조), 여기에는 명시 적으로 명명 된 상수 (</target>
        </trans-unit>
        <trans-unit id="3dbd8f694ee5f7d827b82f06e9ded015648c4ad7" translate="yes" xml:space="preserve">
          <source>(see below). Then</source>
          <target state="translated">(아래 참조). 그때</target>
        </trans-unit>
        <trans-unit id="f5d6cc2174db4f7905a73730e867e020dfcacecd" translate="yes" xml:space="preserve">
          <source>(see discussion below). That default can hurt performance, but the library's atomic operations can be given an additional &lt;code&gt;memory_order&lt;/code&gt; argument to specify the exact constraints, beyond atomicity, that the compiler and processor must enforce for that operation.</source>
          <target state="translated">(아래 논의 참조). 이 기본값은 성능을 저하시킬 수 있지만 라이브러리의 원 자성 연산에는 추가 &lt;code&gt;memory_order&lt;/code&gt; 인수 가 주어져 원 자성 이외의 정확한 제약 조건을 지정하여 컴파일러와 프로세서가 해당 연산에 적용해야합니다.</target>
        </trans-unit>
        <trans-unit id="9a3881cc1036ec5d39ed0c327f4f7f0894869e69" translate="yes" xml:space="preserve">
          <source>(since C11)</source>
          <target state="translated">(C11부터)</target>
        </trans-unit>
        <trans-unit id="210d241929a18f0618a56dca1b5a8b7a5a4435b5" translate="yes" xml:space="preserve">
          <source>(since C17)</source>
          <target state="translated">(C17부터)</target>
        </trans-unit>
        <trans-unit id="183332ea175af61cdda6a3d19fb711fb961d96fc" translate="yes" xml:space="preserve">
          <source>(since C2x)</source>
          <target state="translated">(C2x부터)</target>
        </trans-unit>
        <trans-unit id="bea96c38cfa69424ce16fd91c7d115847e5e4e71" translate="yes" xml:space="preserve">
          <source>(since C95)</source>
          <target state="translated">(C95부터)</target>
        </trans-unit>
        <trans-unit id="682264754722334fb98dbc7659ca6ca033b487f7" translate="yes" xml:space="preserve">
          <source>(since C99)</source>
          <target state="translated">(C99 이후)</target>
        </trans-unit>
        <trans-unit id="6891bed26da97134f76780399ac9476603236e7b" translate="yes" xml:space="preserve">
          <source>(space)</source>
          <target state="translated">(space)</target>
        </trans-unit>
        <trans-unit id="6f4d2a86f4c0ce3992eda24b7569c5cdfc27a172" translate="yes" xml:space="preserve">
          <source>(struct)</source>
          <target state="translated">(struct)</target>
        </trans-unit>
        <trans-unit id="9c1ef87795af2d4ef28a2187320bc14c504e1d4c" translate="yes" xml:space="preserve">
          <source>(that is, may be used) only in some possibly discontiguous portion of the source code called its</source>
          <target state="translated">(즉, 사용될 수 있음) 소스 코드의 불연속적인 부분에서만</target>
        </trans-unit>
        <trans-unit id="79fc13844267884559168ec5969f69e8858db0f0" translate="yes" xml:space="preserve">
          <source>(typedef)</source>
          <target state="translated">(typedef)</target>
        </trans-unit>
        <trans-unit id="4abe2ade558dafde255b1ded803dfb56c35f482d" translate="yes" xml:space="preserve">
          <source>(until C++11)</source>
          <target state="translated">(C ++ 11까지)</target>
        </trans-unit>
        <trans-unit id="021488cb3e37c324d85d81aa9a23cbe85e7b25a0" translate="yes" xml:space="preserve">
          <source>(until C11)</source>
          <target state="translated">(C11까지)</target>
        </trans-unit>
        <trans-unit id="3e9eb9c63f0d7cc5b97f9f6a9e55d7577fcb0806" translate="yes" xml:space="preserve">
          <source>(until C99)</source>
          <target state="translated">(C99까지)</target>
        </trans-unit>
        <trans-unit id="bf90d29f81215404327eb9f0cc8b68ce99ddb106" translate="yes" xml:space="preserve">
          <source>(where n=base) integer number representation and converts them to an integer value. The valid integer value consists of the following parts:</source>
          <target state="translated">(여기서 n = base) 정수를 나타내고 정수 값으로 변환합니다. 유효한 정수 값은 다음 부분으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="7e37541dd44682c81f7171ff351e8c0af1da91a5" translate="yes" xml:space="preserve">
          <source>(where n=base) unsigned integer number representation and converts them to an integer value. The valid unsigned integer value consists of the following parts:</source>
          <target state="translated">(여기서 n = base) 부호없는 정수를 나타내고 정수 값으로 변환합니다. 유효한 부호없는 정수 값은 다음 부분으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="3953c43313ea14f06960efcff7e18cd5de15cebc" translate="yes" xml:space="preserve">
          <source>(which may be a multibyte character set such as UTF-8, as long as all 96 characters from the</source>
          <target state="translated">(이것은 UTF-8과 같은 멀티 바이트 문자 집합 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3135ef3353dac478238a85ec1d309782466e1667" translate="yes" xml:space="preserve">
          <source>(which may be any type other than array or function type), and the</source>
          <target state="translated">(배열 또는 함수 유형 이외의 다른 유형일 수 있음) 및</target>
        </trans-unit>
        <trans-unit id="4c44b571d54369fd08ac2c0437f712eddc1c78f3" translate="yes" xml:space="preserve">
          <source>(which must be a complete object type), and the</source>
          <target state="translated">(완전한 객체 유형이어야 함) 및</target>
        </trans-unit>
        <trans-unit id="38b7c53f11449649cd2d812642cdbccf0a48f654" translate="yes" xml:space="preserve">
          <source>(x &amp;plusmn; u) &amp;plusmn; iv</source>
          <target state="translated">(x &amp;plusmn; u) &amp;plusmn; iv</target>
        </trans-unit>
        <trans-unit id="f0d30473e944699150bfb7c5cc78d82d160494e1" translate="yes" xml:space="preserve">
          <source>(x &amp;plusmn; u) + i(y &amp;plusmn; v)</source>
          <target state="translated">(x &amp;plusmn; u) + i (y &amp;plusmn; v)</target>
        </trans-unit>
        <trans-unit id="6405638c61de281da67d67e62ec8df3581aa92f4" translate="yes" xml:space="preserve">
          <source>(x &amp;plusmn; u) + iy</source>
          <target state="translated">(x &amp;plusmn; u) + iy</target>
        </trans-unit>
        <trans-unit id="15fbe2a6877c34c6c89d32bb49714706aeb341c6" translate="yes" xml:space="preserve">
          <source>(x/u) + i(y/u)</source>
          <target state="translated">(x / u) + i (y / u)</target>
        </trans-unit>
        <trans-unit id="424e0c30779bc969b12dd822363cb2d4ca5473eb" translate="yes" xml:space="preserve">
          <source>(x86, x86_64): a big-endian platform stores the most significant byte at the lowest address of the region of storage occupied by the integer, a little-endian platform stores the least significant byte at the lowest address. See &lt;a href=&quot;https://en.wikipedia.org/wiki/Endianness&quot;&gt;Endianness&lt;/a&gt; for detail. See also example below.</source>
          <target state="translated">(x86, x86_64) : 빅 엔디안 플랫폼은 정수가 차지하는 스토리지 영역의 가장 낮은 주소에 최상위 바이트를 저장하고 리틀 엔디안 플랫폼은 가장 낮은 바이트에 최하위 바이트를 저장합니다. 자세한 내용은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Endianness&quot;&gt;엔디안&lt;/a&gt; 을 참조하십시오 . 아래의 예도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="815979045b8907176a7e884f5bfa1c6d9cc4749d" translate="yes" xml:space="preserve">
          <source>(xu) + i(xv)</source>
          <target state="translated">(xu) + i (xv)</target>
        </trans-unit>
        <trans-unit id="193cf4948a69b12c45551425a0efa2b1c12cce2f" translate="yes" xml:space="preserve">
          <source>(xu) + i(yu)</source>
          <target state="translated">(xu) + i (yu)</target>
        </trans-unit>
        <trans-unit id="de059407122eda63c84f99856f0f4738bda94130" translate="yes" xml:space="preserve">
          <source>(y/v) + i(&amp;minus;x/v)</source>
          <target state="translated">(y / v) + i (&amp;minus;x / v)</target>
        </trans-unit>
        <trans-unit id="e7064f0b80f61dbc65915311032d27baa569ae2a" translate="yes" xml:space="preserve">
          <source>)</source>
          <target state="translated">)</target>
        </trans-unit>
        <trans-unit id="9b43fc75ffa2875ad5c3474c826211b5ec1a072c" translate="yes" xml:space="preserve">
          <source>)  For any z, asin(z) = acos(-z) -</source>
          <target state="translated">) 모든 z에 대해 asin (z) = acos (-z)-</target>
        </trans-unit>
        <trans-unit id="4276c449b12076a975a340699186df77099a32e6" translate="yes" xml:space="preserve">
          <source>)  For any z, asinh(z) =</source>
          <target state="translated">) 모든 z에 대해 asinh (z) =</target>
        </trans-unit>
        <trans-unit id="2e16a8a8ba911a78e3c2011c810d8169be2b6ab4" translate="yes" xml:space="preserve">
          <source>) and (</source>
          <target state="translated">) 및 (</target>
        </trans-unit>
        <trans-unit id="fab479966c182da11ddf2d25a440ef6fc3d8e951" translate="yes" xml:space="preserve">
          <source>) compares equal to 0. The repetition occurs regardless of whether the loop body is entered normally or by a &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; into the middle of statement.</source>
          <target state="translated">)는 반복이없이 환상 체는 일반적으로 입력하거나 여부 발생 0 동등 비교 &lt;a href=&quot;goto&quot;&gt;고토&lt;/a&gt; 문장의 중간에.</target>
        </trans-unit>
        <trans-unit id="cca8bc240378ad066c91d75749b84f54e6dd594f" translate="yes" xml:space="preserve">
          <source>) compares equal to zero. The repetition occurs regardless of whether the loop body is entered normally or by a &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; into the middle of statement.</source>
          <target state="translated">)는 0과 같습니다. 반복 횟수에 상관없이 루프 본체가 정상적으로 또는가 입력되어 있는지의 발생 &lt;a href=&quot;goto&quot;&gt;고토&lt;/a&gt; 문장의 중간에.</target>
        </trans-unit>
        <trans-unit id="381af632661038d250fa49a0a1fc80a618828820" translate="yes" xml:space="preserve">
          <source>) has higher priority than its case or variant. Within an equivalence class, lowercase characters collate before their uppercase equivalents and locale-specific order may apply to the characters with diacritics. In some locales, groups of characters compare as single</source>
          <target state="translated">)이 사례 또는 변형보다 우선 순위가 높습니다. 동등성 클래스 내에서 소문자는 대문자에 해당하는 문자보다 먼저 정렬되며 로케일 별 순서는 분음 부호가있는 문자에 적용될 수 있습니다. 일부 로케일에서 문자 그룹은 단일으로 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="e0b1cc4d603c473338dcd2684c1e9caff9c233db" translate="yes" xml:space="preserve">
          <source>) is returned.</source>
          <target state="translated">)가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4f9a8c9e517dc4f5af60a3efda74d8deb6d583a5" translate="yes" xml:space="preserve">
          <source>) is the probability that a measurement whose errors are subject to a normal distribution with standard deviation &amp;sigma; is less than x away from the mean value.</source>
          <target state="translated">)는 오차가 표준 편차 &amp;sigma; 인 정규 분포를 따르는 측정 값이 평균값에서 x 미만인 확률입니다.</target>
        </trans-unit>
        <trans-unit id="5b51135a2add737344ecb05586782727da2f8e19" translate="yes" xml:space="preserve">
          <source>) logarithm (ln(x))</source>
          <target state="translated">) 로그 (ln (x))</target>
        </trans-unit>
        <trans-unit id="af1aa3ea6cfef390696609a7ad53159e28f9a72a" translate="yes" xml:space="preserve">
          <source>) logarithm (log&lt;sub&gt;10&lt;/sub&gt;(x))</source>
          <target state="translated">) 로그 (로그 &lt;sub&gt;10&lt;/sub&gt; (x))</target>
        </trans-unit>
        <trans-unit id="e0ce3f516c3fe71021bc31ec17cb9d473f8e2047" translate="yes" xml:space="preserve">
          <source>) logarithm of 1 plus the given number (ln(1+x))</source>
          <target state="translated">) 1에 주어진 수를 더한 로그 (ln (1 + x))</target>
        </trans-unit>
        <trans-unit id="561ca0daa1737d7479e576210d7d40aa84e07390" translate="yes" xml:space="preserve">
          <source>) logarithm of &lt;code&gt;arg&lt;/code&gt; (ln(arg) or log</source>
          <target state="translated">) &lt;code&gt;arg&lt;/code&gt; 의 로그 (ln (arg) 또는 log</target>
        </trans-unit>
        <trans-unit id="3caeb7b0b56525a5824137176a20888279cb6a65" translate="yes" xml:space="preserve">
          <source>) logarithm of &lt;code&gt;arg&lt;/code&gt; (log</source>
          <target state="translated">) &lt;code&gt;arg&lt;/code&gt; 의 로그</target>
        </trans-unit>
        <trans-unit id="f8ffe2623f614106cc901cdc10bdea82d232b402" translate="yes" xml:space="preserve">
          <source>) logarithm of &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="translated">) &lt;code&gt;arg&lt;/code&gt; 의 로그 .</target>
        </trans-unit>
        <trans-unit id="949f932f9e9f0c6dbba5ba6372d11a42630c5b31" translate="yes" xml:space="preserve">
          <source>) logarithm of &lt;code&gt;z&lt;/code&gt; with branch cut along the negative real axis.</source>
          <target state="translated">) 음의 실수 축을 따라 분기 절단 된 &lt;code&gt;z&lt;/code&gt; 의 로그 .</target>
        </trans-unit>
        <trans-unit id="6a786e1db684c32b3aaf659ddc53bfeeede49839" translate="yes" xml:space="preserve">
          <source>) logarithm of the gamma function</source>
          <target state="translated">) 감마 함수의 로그</target>
        </trans-unit>
        <trans-unit id="302862f149d9171a887c667d9aae807fe5a7afe9" translate="yes" xml:space="preserve">
          <source>) to be executed repeatedly until the expression (also called</source>
          <target state="translated">)는 표현식 (또는</target>
        </trans-unit>
        <trans-unit id="86f9feb04688f1b85b7fe6b32d8878ce89606ed2" translate="yes" xml:space="preserve">
          <source>)) in the range [-&amp;pi; ; +&amp;pi;] radians, is returned.</source>
          <target state="translated">)) 범위 [-&amp;pi;; + &amp;pi;] 라디안이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b2a62dc7cea8d4e84b5ddb6e1652611e8ab1dc44" translate="yes" xml:space="preserve">
          <source>), and |x+iy| = &amp;radic;x2</source>
          <target state="translated">) 및 | x + iy | = &amp;radic;x2</target>
        </trans-unit>
        <trans-unit id="2212203767ff4b769464feb44407fb2b22b49579" translate="yes" xml:space="preserve">
          <source>), as the programmer assumes the responsibility of limiting the range of the operands and dealing with the infinities.</source>
          <target state="translated">), 프로그래머가 피연산자의 범위를 제한하고 무한대를 처리해야 할 책임이 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="1ea1572fd4aad9b1896018924a46090b39b3d665" translate="yes" xml:space="preserve">
          <source>), the behavior is undefined if.</source>
          <target state="translated">) 인 경우 동작은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="053fc5f6bb0cc49c7870d803a719e1ee1e0cd680" translate="yes" xml:space="preserve">
          <source>). Function declarations (unlike &lt;a href=&quot;function_definition&quot;&gt;definitions&lt;/a&gt;) may appear at block scope as well as file scope.</source>
          <target state="translated">). &lt;a href=&quot;function_definition&quot;&gt;정의&lt;/a&gt; 와 달리 함수 선언 은 파일 범위뿐만 아니라 블록 범위에도 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31bb25d10b9a89356f8b9f13339946ddb8b94755" translate="yes" xml:space="preserve">
          <source>). If the size of the new type is larger than the size of the last-written type, the contents of the excess bytes are unspecified (and may be a trap representation).</source>
          <target state="translated">). 새 유형의 크기가 마지막으로 작성된 유형의 크기보다 큰 경우 초과 바이트의 내용은 지정되지 않으며 트랩 표현 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eca00657b49826bd41febafa46889b0acfc34800" translate="yes" xml:space="preserve">
          <source>). The pointers &lt;code&gt;argv[1] .. argv[argc-1]&lt;/code&gt; point at the first characters in each of these strings. &lt;code&gt;argv[0]&lt;/code&gt; is the pointer to the initial character of a null-terminated multibyte strings that represents the name used to invoke the program itself (or, if this is not supported by the host environment, argv[0][0] is guaranteed to be zero).</source>
          <target state="translated">). 포인터는 &lt;code&gt;argv[1] .. argv[argc-1]&lt;/code&gt; 이러한 문자열의 각 문자에 제 포인트. &lt;code&gt;argv[0]&lt;/code&gt; 은 프로그램 자체를 호출하는 데 사용되는 이름을 나타내는 널 종료 멀티 바이트 문자열의 초기 문자에 대한 포인터입니다 (또는 호스트 환경에서 지원하지 않는 경우 argv [0] [0]). 0으로 설정).</target>
        </trans-unit>
        <trans-unit id="df58248c414f342c81e056b40bee12d17a08bf61" translate="yes" xml:space="preserve">
          <source>*</source>
          <target state="translated">*</target>
        </trans-unit>
        <trans-unit id="4ab516c76f3bdbf08541a0f8c2b8f862aa246bb5" translate="yes" xml:space="preserve">
          <source>* A &lt;code&gt;wchar_t&lt;/code&gt; was found that does not correspond to a valid character in the current C locale.</source>
          <target state="translated">* 현재 C 로케일의 유효한 문자와 일치하지 않는 &lt;code&gt;wchar_t&lt;/code&gt; 가 발견되었습니다.</target>
        </trans-unit>
        <trans-unit id="364c7a704a404f39e09935349036f231114109ef" translate="yes" xml:space="preserve">
          <source>* A &lt;code&gt;wchar_t&lt;/code&gt; was found that does not correspond to a valid character in the current C locale. &lt;code&gt;*src&lt;/code&gt; is set to point at the first unconverted wide character.</source>
          <target state="translated">* 현재 C 로케일의 유효한 문자와 일치하지 않는 &lt;code&gt;wchar_t&lt;/code&gt; 가 발견되었습니다. &lt;code&gt;*src&lt;/code&gt; 는 변환되지 않은 첫 번째 넓은 문자를 가리 키도록 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="fbab1f01885ef6754602b76714437f21b435baf0" translate="yes" xml:space="preserve">
          <source>* An invalid (in the current C locale) multibyte character was encountered.</source>
          <target state="translated">* 유효하지 않은 (현재 C 로케일에서) 멀티 바이트 문자가 발견되었습니다.</target>
        </trans-unit>
        <trans-unit id="5bb4dd0a6b9d32792e8058f601a982fd5ca47c20" translate="yes" xml:space="preserve">
          <source>* An invalid multibyte character (according to the current C locale) was encountered. &lt;code&gt;*src&lt;/code&gt; is set to point at the beginning of the first unconverted multibyte character.</source>
          <target state="translated">* 현재 C 로케일에 따라 유효하지 않은 멀티 바이트 문자가 발견되었습니다. &lt;code&gt;*src&lt;/code&gt; 는 변환되지 않은 첫 번째 멀티 바이트 문자의 시작을 가리 키도록 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="f5126dc66253e898dec1426fb9aff733b85696b3" translate="yes" xml:space="preserve">
          <source>* If &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;dst&lt;/code&gt; overlap, the behavior is unspecified.</source>
          <target state="translated">* 경우 &lt;code&gt;src&lt;/code&gt; 와 &lt;code&gt;dst&lt;/code&gt; 중복, 동작은 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="36bf6834136369c35471557a4051b7dbe2cb87e2" translate="yes" xml:space="preserve">
          <source>* The multibyte null character was converted and stored.</source>
          <target state="translated">* 멀티 바이트 널 문자가 변환되어 저장되었습니다.</target>
        </trans-unit>
        <trans-unit id="bdfa5f7b108263e04405358077b7c75e111ec0ce" translate="yes" xml:space="preserve">
          <source>* The multibyte null character was converted and stored. &lt;code&gt;*src&lt;/code&gt; is set to &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;*ps&lt;/code&gt; represents the initial shift state.</source>
          <target state="translated">* 멀티 바이트 널 문자가 변환되어 저장되었습니다. &lt;code&gt;*src&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 로 설정 되며 &lt;code&gt;*ps&lt;/code&gt; 는 초기 시프트 상태를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="834f17c7f120bcb1a300de8f6df858e07e90f8b0" translate="yes" xml:space="preserve">
          <source>* The next multibyte character to be stored would exceed &lt;code&gt;len&lt;/code&gt;.</source>
          <target state="translated">* 저장 될 다음 멀티 바이트 문자는 &lt;code&gt;len&lt;/code&gt; 을 초과 합니다.</target>
        </trans-unit>
        <trans-unit id="dd26f35187988e3fd49cb0e70979eec351055319" translate="yes" xml:space="preserve">
          <source>* The next wide character to be stored would exceed &lt;code&gt;len&lt;/code&gt;.</source>
          <target state="translated">* 저장 될 다음 와이드 문자는 &lt;code&gt;len&lt;/code&gt; 을 초과 합니다.</target>
        </trans-unit>
        <trans-unit id="4da1d0803dbd2e6490f012c9dd70a0c5c6a515ea" translate="yes" xml:space="preserve">
          <source>* The null character &lt;code&gt;L'\0'&lt;/code&gt; was converted and stored. The bytes stored in this case are the unshift sequence (if necessary) followed by &lt;code&gt;'\0'&lt;/code&gt;,</source>
          <target state="translated">* 널 문자 &lt;code&gt;L'\0'&lt;/code&gt; 이 변환되어 저장되었습니다. 다음은이 경우에 저장 바이트 (필요한 경우) 다음에 취소] 서열이다 &lt;code&gt;'\0'&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="3e9e1fb41eb2cf2c487da727ae16b9b81c9e0988" translate="yes" xml:space="preserve">
          <source>* The null character &lt;code&gt;L'\0'&lt;/code&gt; was converted and stored. The bytes stored in this case are the unshift sequence (if necessary) followed by &lt;code&gt;'\0'&lt;/code&gt;, &lt;code&gt;*src&lt;/code&gt; is set to &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;*ps&lt;/code&gt; represents the initial shift state.</source>
          <target state="translated">* 널 문자 &lt;code&gt;L'\0'&lt;/code&gt; 이 변환되어 저장되었습니다. 이 경우에 저장된 바이트는 언 시프트 시퀀스 (필요한 경우) 뒤에 &lt;code&gt;'\0'&lt;/code&gt; 이며 &lt;code&gt;*src&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 로 설정 되며 &lt;code&gt;*ps&lt;/code&gt; 는 초기 시프트 상태를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="dee2144d7fd70d4bcba806aa427b19a704d491d8" translate="yes" xml:space="preserve">
          <source>* conversion is as-if by &lt;code&gt;&lt;a href=&quot;mbrtowc&quot;&gt;mbrtowc&lt;/a&gt;&lt;/code&gt;, not &lt;code&gt;&lt;a href=&quot;mbtowc&quot;&gt;mbtowc&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">* &lt;code&gt;&lt;a href=&quot;mbtowc&quot;&gt;mbtowc&lt;/a&gt;&lt;/code&gt; 가 아닌 &lt;code&gt;&lt;a href=&quot;mbrtowc&quot;&gt;mbrtowc&lt;/a&gt;&lt;/code&gt; 에 의한 변환</target>
        </trans-unit>
        <trans-unit id="e8b64366c800cd8e8dfc2fccd006a232d6e5d7fb" translate="yes" xml:space="preserve">
          <source>* conversion is as-if by &lt;code&gt;&lt;a href=&quot;wcrtomb&quot;&gt;wcrtomb&lt;/a&gt;&lt;/code&gt;, not &lt;code&gt;&lt;a href=&quot;wctomb&quot;&gt;wctomb&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">* &lt;code&gt;&lt;a href=&quot;wctomb&quot;&gt;wctomb&lt;/a&gt;&lt;/code&gt; 가 아닌 &lt;code&gt;&lt;a href=&quot;wcrtomb&quot;&gt;wcrtomb&lt;/a&gt;&lt;/code&gt; 에 의한 변환</target>
        </trans-unit>
        <trans-unit id="5dddb9454567355972780e53d90b4db9c3cf72a7" translate="yes" xml:space="preserve">
          <source>* if &lt;code&gt;dst&lt;/code&gt; is a null pointer, the number of bytes that would be produced is stored in &lt;code&gt;*retval&lt;/code&gt;</source>
          <target state="translated">* &lt;code&gt;dst&lt;/code&gt; 가 널 포인터 인 경우 생성되는 바이트 수는 &lt;code&gt;*retval&lt;/code&gt; 에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="81581e17ddac35e7f300dbab9c08485fa44856fc" translate="yes" xml:space="preserve">
          <source>* if &lt;code&gt;dst&lt;/code&gt; is a null pointer, the number of wide characters that would be produced is stored in &lt;code&gt;*retval&lt;/code&gt;</source>
          <target state="translated">* &lt;code&gt;dst&lt;/code&gt; 가 널 포인터 인 경우 생성되는 와이드 문자 수는 &lt;code&gt;*retval&lt;/code&gt; 에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="be8bb5000a5daf788ad5d862dc45ffef4d647ccd" translate="yes" xml:space="preserve">
          <source>* if no null character was written to &lt;code&gt;dst&lt;/code&gt; after &lt;code&gt;len&lt;/code&gt; wide characters were written, then &lt;code&gt;L'\0'&lt;/code&gt; is stored in &lt;code&gt;dst[len]&lt;/code&gt;, which means len+1 total wide characters are written</source>
          <target state="translated">* &lt;code&gt;len&lt;/code&gt; 와이드 문자가 작성된 후 &lt;code&gt;dst&lt;/code&gt; 에 널 문자가 기록되지 않은 경우 &lt;code&gt;L'\0'&lt;/code&gt; 은 &lt;code&gt;dst[len]&lt;/code&gt; 저장됩니다 . 이는 len + 1 총 와이드 문자가 기록됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="92b3d3b2534e505ec2cd5a10c2ee035d6a6b6109" translate="yes" xml:space="preserve">
          <source>* if the conversion stops without writing a null character, the function will store &lt;code&gt;'\0'&lt;/code&gt; in the next byte in &lt;code&gt;dst&lt;/code&gt;, which may be &lt;code&gt;dst[len]&lt;/code&gt; or &lt;code&gt;dst[dstsz]&lt;/code&gt;, whichever comes first (meaning up to len+1/dstsz+1 total bytes may be written). In this case, there may be no unshift sequence written before the terminating null.</source>
          <target state="translated">* 널 문자를 쓰지 않고 변환이 중지되면, 함수는 &lt;code&gt;dst&lt;/code&gt; 의 다음 바이트에 &lt;code&gt;'\0'&lt;/code&gt; 을 저장 합니다. &lt;code&gt;dst[len]&lt;/code&gt; 또는 &lt;code&gt;dst[dstsz]&lt;/code&gt; 중 먼저 오는 것 (len + 1 /까지) dstsz + 1 총 바이트가 기록 될 수 있습니다). 이 경우, 종료 널 전에 기록 된 언 시프트 시퀀스가 ​​없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29d55a5927ef5eb2fd9e5d517c2eb90df247c2e4" translate="yes" xml:space="preserve">
          <source>* the following errors are detected at runtime and call the currently installed &lt;a href=&quot;../../error/set_constraint_handler_s&quot;&gt;constraint handler&lt;/a&gt; function:</source>
          <target state="translated">* 런타임시 다음 오류가 감지되고 현재 설치된 &lt;a href=&quot;../../error/set_constraint_handler_s&quot;&gt;제약 조건 처리기&lt;/a&gt; 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="c47429fda0b87a9c600b9ae240c30a865bd3fb3d" translate="yes" xml:space="preserve">
          <source>* the function clobbers the destination array from the terminating null and until &lt;code&gt;dstsz&lt;/code&gt;</source>
          <target state="translated">* 함수는 종료 널에서 &lt;code&gt;dstsz&lt;/code&gt; 까지 대상 배열을 클로버합니다.</target>
        </trans-unit>
        <trans-unit id="d009a3dd9b322b988861b11e447b8d92a2d690bb" translate="yes" xml:space="preserve">
          <source>* the function returns its result as an out-parameter &lt;code&gt;retval&lt;/code&gt;</source>
          <target state="translated">* 함수는 결과를 매개 변수를 벗어난 &lt;code&gt;retval&lt;/code&gt; 로 반환합니다</target>
        </trans-unit>
        <trans-unit id="961390a750d281bc04739c59491b178e395dcfd8" translate="yes" xml:space="preserve">
          <source>* the next multibyte character to be stored would exceed &lt;code&gt;len&lt;/code&gt;. &lt;code&gt;*src&lt;/code&gt; is set to point at the first unconverted wide character. This condition is not checked if &lt;code&gt;dst==&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">* 저장 될 다음 멀티 바이트 문자는 &lt;code&gt;len&lt;/code&gt; 을 초과 합니다. &lt;code&gt;*src&lt;/code&gt; 는 변환되지 않은 첫 번째 넓은 문자를 가리 키도록 설정됩니다. &lt;code&gt;dst==&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 경우이 조건을 확인하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3c6590e4f5723e83efef06a912e6fb16d0204b4d" translate="yes" xml:space="preserve">
          <source>* the next wide character to be stored would exceed &lt;code&gt;len&lt;/code&gt;. &lt;code&gt;*src&lt;/code&gt; is set to point at the beginning of the first unconverted multibyte character. This condition is not checked if &lt;code&gt;dst==&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">* 저장 될 다음 와이드 문자는 &lt;code&gt;len&lt;/code&gt; 을 초과 합니다. &lt;code&gt;*src&lt;/code&gt; 는 변환되지 않은 첫 번째 멀티 바이트 문자의 시작을 가리 키도록 설정됩니다. &lt;code&gt;dst==&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 경우이 조건을 확인하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="5af890528c0bc07f3ddb7506b6871aa13ef93e0f" translate="yes" xml:space="preserve">
          <source>+ or -</source>
          <target state="translated">+ 또는-</target>
        </trans-unit>
        <trans-unit id="10237625c4038078366f0ba301062e26b0a292b7" translate="yes" xml:space="preserve">
          <source>+e-arg</source>
          <target state="translated">+e-arg</target>
        </trans-unit>
        <trans-unit id="646a59a5040c633be59638f0b9236c74b2d4b10e" translate="yes" xml:space="preserve">
          <source>+e-iz</source>
          <target state="translated">+e-iz</target>
        </trans-unit>
        <trans-unit id="34a1e35776739ce4dc04bce6c9ebf045e0e6d5cd" translate="yes" xml:space="preserve">
          <source>+e-z</source>
          <target state="translated">+e-z</target>
        </trans-unit>
        <trans-unit id="e658a5f32f2900a22bb92bff52a9aae37a38fc16" translate="yes" xml:space="preserve">
          <source>+eiz</source>
          <target state="translated">+eiz</target>
        </trans-unit>
        <trans-unit id="bd70b4e8a931f2e78f56e98d763ca24203c62e75" translate="yes" xml:space="preserve">
          <source>+v2</source>
          <target state="translated">+v2</target>
        </trans-unit>
        <trans-unit id="52ec0e2168e6e479e68b2919cf6142e08ffe7ec9" translate="yes" xml:space="preserve">
          <source>+y2</source>
          <target state="translated">+y2</target>
        </trans-unit>
        <trans-unit id="5c10b5b2cd673a0616d529aa5234b12ee7153808" translate="yes" xml:space="preserve">
          <source>,</source>
          <target state="translated">,</target>
        </trans-unit>
        <trans-unit id="ea99f2c99dab0ae4b94573e70409b74914f3d75e" translate="yes" xml:space="preserve">
          <source>, &lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt;, and, for pointers to object types, &lt;a href=&quot;restrict&quot;&gt;restrict&lt;/a&gt; qualifiers. This page describes the effects of the</source>
          <target state="translated">, &lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt; 및 객체 유형에 대한 포인터의 경우 한정자를 &lt;a href=&quot;restrict&quot;&gt;제한&lt;/a&gt; 합니다. 이 페이지는</target>
        </trans-unit>
        <trans-unit id="267c692f9e342c44644a1c3c855829a39c44371b" translate="yes" xml:space="preserve">
          <source>, &lt;code&gt;-0.0&lt;/code&gt;. It compares equal to the positive zero, but is meaningful in some arithmetic operations, e.g. &lt;code&gt;1.0/0.0 == INFINITY&lt;/code&gt;, but &lt;code&gt;1.0/-0.0 == -INFINITY&lt;/code&gt;)</source>
          <target state="translated">, &lt;code&gt;-0.0&lt;/code&gt; . 양의 0과 같지만 일부 산술 연산에서 의미가 있습니다 (예 : &lt;code&gt;1.0/0.0 == INFINITY&lt;/code&gt; , &lt;code&gt;1.0/-0.0 == -INFINITY&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e150b1788dd9f7e5e7ac789ea46e43edb1ebffbd" translate="yes" xml:space="preserve">
          <source>, a store performs a</source>
          <target state="translated">상점은</target>
        </trans-unit>
        <trans-unit id="fe5c90235b636a3479741a3510eaceea07ddce9c" translate="yes" xml:space="preserve">
          <source>, and read-modify-write performs both an</source>
          <target state="translated">및 읽기-수정-쓰기는</target>
        </trans-unit>
        <trans-unit id="6a2c01681df2cda12ce7497be0662428aa1cce6b" translate="yes" xml:space="preserve">
          <source>, and therefore,</source>
          <target state="translated">, 따라서,</target>
        </trans-unit>
        <trans-unit id="f488f61b816c99ddff3a7a72d11d62edd3fca7df" translate="yes" xml:space="preserve">
          <source>, and, for pointers to object types, &lt;a href=&quot;restrict&quot;&gt;restrict&lt;/a&gt; qualifiers. This page describes the effects of the</source>
          <target state="translated">객체 유형에 대한 포인터의 경우 한정자를 &lt;a href=&quot;restrict&quot;&gt;제한&lt;/a&gt; 합니다. 이 페이지는</target>
        </trans-unit>
        <trans-unit id="7c04ddce60e88eb81512a7bb2474b737f3648041" translate="yes" xml:space="preserve">
          <source>, by providing a name followed by a colon before the statement itself.</source>
          <target state="translated">, 명령문 자체 앞에 이름과 콜론을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e0fd782cf495a2cb134bf86538aa83c2ba0b3eef" translate="yes" xml:space="preserve">
          <source>, consists of two stages:</source>
          <target state="translated">, 두 단계로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="5d4f70dfafcb16a063c6caca45514bf3f6f403f7" translate="yes" xml:space="preserve">
          <source>, defined as follows:</source>
          <target state="translated">다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="d0326c2af02477004d0e9cb81da31109edab9e6b" translate="yes" xml:space="preserve">
          <source>, despite the possibility of intermediate overflow. In other words, the programmer guarantees that the range of the values that will be passed to those function is limited. The default value is &lt;code&gt;OFF&lt;/code&gt;</source>
          <target state="translated">중간 오버플로 가능성에도 불구하고. 다시 말해, 프로그래머는 해당 기능에 전달 될 값의 범위가 제한되어 있음을 보증합니다. 기본값은 &lt;code&gt;OFF&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7e197dd42d137ab00a4af956b2be83a89414b88e" translate="yes" xml:space="preserve">
          <source>, each of which declares identifier to be a label name, which must be unique within the enclosing function (in other words, label names have &lt;a href=&quot;scope&quot;&gt;function scope&lt;/a&gt;).</source>
          <target state="translated">, 각각은 식별자를 레이블 이름으로 선언합니다. 레이블 이름은 묶는 함수 내에서 고유해야합니다 (즉, 레이블 이름에는 &lt;a href=&quot;scope&quot;&gt;함수 범위가 있습니다&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="98e97cc3b8644e377d56e1913ed68ca827ee1c37" translate="yes" xml:space="preserve">
          <source>, followed by the</source>
          <target state="translated">다음에</target>
        </trans-unit>
        <trans-unit id="b402a081f1fd2ed0d93364392f8a9e1971f2a0ba" translate="yes" xml:space="preserve">
          <source>, i.e. not an infinity, subnormal, not-a-number or zero</source>
          <target state="translated">즉, 무한대, 비정규, 숫자가 아니거나 0이 아님</target>
        </trans-unit>
        <trans-unit id="3f9ea48a3566ba015dc5cf19f3c91e36adc1bfa0" translate="yes" xml:space="preserve">
          <source>, is a brace-enclosed sequence of statements and declarations.</source>
          <target state="translated">은 중괄호로 묶은 문장과 선언의 순서입니다.</target>
        </trans-unit>
        <trans-unit id="4d352140499bee91bd8fa0478761dbe5c330ea43" translate="yes" xml:space="preserve">
          <source>, is returned.</source>
          <target state="translated">가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6749438cbd3963dcc7dbd80916ea8bcec3d16fe2" translate="yes" xml:space="preserve">
          <source>, is returned. If a range error occurs due to underflow, the correct result (after rounding), that is</source>
          <target state="translated">가 반환됩니다. 언더 플로로 인해 범위 오류가 발생하면 올바른 결과 (올림 후), 즉</target>
        </trans-unit>
        <trans-unit id="ff0d5b022985210ca1620c154fb6685e6c163e15" translate="yes" xml:space="preserve">
          <source>, non-lvalue object expressions are the expressions of object types that do not designate objects, but rather values that have no object identity or storage location. The address of a non-lvalue object expression cannot be taken.</source>
          <target state="translated">값이 아닌 객체 표현식은 객체를 지정하지 않고 객체 ID 또는 저장 위치가없는 값을 나타내는 객체 유형의 표현식입니다. lvalue가 아닌 객체 표현식의 주소를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b366d1a229ec84d93ba42e7ecafb33db5b7b9b39" translate="yes" xml:space="preserve">
          <source>, or</source>
          <target state="translated">또는</target>
        </trans-unit>
        <trans-unit id="ca2b3f2f28d5107c14b1c6e606f4cad76bdae7f8" translate="yes" xml:space="preserve">
          <source>, plus a single total order exists in which all threads observe all modifications in the same order (see &lt;a href=&quot;memory_order#Sequentially-consistent_ordering&quot;&gt;Sequentially-consistent ordering&lt;/a&gt; below)</source>
          <target state="translated">, 모든 스레드가 동일한 순서로 모든 수정 사항을 관찰하는 단일 전체 순서가 존재합니다 (아래의 &lt;a href=&quot;memory_order#Sequentially-consistent_ordering&quot;&gt;순서가 일관된 순서&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="aff77aea9f4970a4a314e522de797997bd16c998" translate="yes" xml:space="preserve">
          <source>, reduced modulo maximum value of the return type plus 1 (that is, bitwise left shift is performed and the bits that get shifted out of the destination type are discarded). For signed lhs with nonnegative values, the value of &lt;code&gt;LHS &amp;lt;&amp;lt; RHS&lt;/code&gt; is LHS * 2RHS</source>
          <target state="translated">, 리턴 타입의 모듈로 최대 값에 1을 더한 값에 1을 더한 값. 음수가 아닌 부호있는 lh 의 경우 &lt;code&gt;LHS &amp;lt;&amp;lt; RHS&lt;/code&gt; 의 값 은 LHS * 2RHS입니다.</target>
        </trans-unit>
        <trans-unit id="12f9d68c8ac0662752f77069df21f228d60ed8e3" translate="yes" xml:space="preserve">
          <source>, that is, calculated as if all intermediate results have infinite range and precision (unless &lt;a href=&quot;../../preprocessor/impl&quot;&gt;#pragma&lt;/a&gt;&lt;code&gt;STDC FP_CONTRACT&lt;/code&gt; is off).</source>
          <target state="translated">즉, &lt;a href=&quot;../../preprocessor/impl&quot;&gt;#pragma &lt;/a&gt; &lt;code&gt;STDC FP_CONTRACT&lt;/code&gt; 가 꺼져 있지 않은 경우 모든 중간 결과의 범위와 정밀도가 무한한 것처럼 계산됩니다 .</target>
        </trans-unit>
        <trans-unit id="e0f8c5176100dd1b018a5ea57406a86131e3643c" translate="yes" xml:space="preserve">
          <source>, that is, calculated as if all intermediate values have infinite range and precision, see &lt;a href=&quot;../preprocessor/impl#Standard_pragmas&quot;&gt;#pragma STDC FP_CONTRACT&lt;/a&gt;.</source>
          <target state="translated">즉, 모든 중간 값이 무한 범위와 정밀도를 갖는 것처럼 계산됩니다 . &lt;a href=&quot;../preprocessor/impl#Standard_pragmas&quot;&gt;#pragma STDC FP_CONTRACT를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b3371f39b4d25c3614398ae687dd3c157715ecb1" translate="yes" xml:space="preserve">
          <source>, that is, once the atomic load is completed, those operators and functions in thread B that use the value obtained from the load are guaranteed to see what thread A wrote to memory.</source>
          <target state="translated">즉, 일단 원자로드가 완료되면,로드에서 얻은 값을 사용하는 스레드 B의 해당 연산자와 함수는 스레드 A가 메모리에 쓴 것을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5600d38f6522d0aee934bd46349d724c084a653b" translate="yes" xml:space="preserve">
          <source>, that is, the maximum number of characters that the function is allowed to consume when doing the conversion specified by the current conversion specification. Note that %s and %[ may lead to buffer overflow if the width is not provided.</source>
          <target state="translated">즉, 현재 변환 스펙에 지정된 변환을 수행 할 때 함수가 사용할 수있는 최대 문자 수입니다. 너비가 제공되지 않으면 % s 및 % [이 (가) 버퍼 오버 플로우로 이어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b3a0b7a765f6f37929babea162b22721cf97b06" translate="yes" xml:space="preserve">
          <source>, that specifies a computation.</source>
          <target state="translated">계산을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="3bfb6dca948f74883bbf3286851c95ba57be31f4" translate="yes" xml:space="preserve">
          <source>, the conversion is with style &lt;code&gt;f&lt;/code&gt; or &lt;code&gt;F&lt;/code&gt; and precision</source>
          <target state="translated">, 스타일 &lt;code&gt;f&lt;/code&gt; 또는 &lt;code&gt;F&lt;/code&gt; 및 정밀도로 변환</target>
        </trans-unit>
        <trans-unit id="bd7c569c621504bf55a91f8729d2723c01ac26ea" translate="yes" xml:space="preserve">
          <source>, the significand is interpreted as a decimal rational number, and the digit-sequence of the exponent is interpreted as the integer power of 10 to which the significand has to be scaled.</source>
          <target state="translated">, significand는 10 진수 유리수로 해석되고 지수의 숫자 순서는 significand가 스케일되어야하는 10의 정수 제곱으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="44a3bdf0df71922d83bab0be27d9b6a00c2bbf00" translate="yes" xml:space="preserve">
          <source>, the significand is interpreted as a hexadecimal rational number, and the digit-sequence of the exponent is interpreted as the integer power of 2 to which the significand has to be scaled.</source>
          <target state="translated">, significand는 16 진수 유리수로 해석되며 지수의 숫자 순서는 significand가 스케일되어야하는 정수 2의 정수로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="669df684f6ddfffabfe6e91745480e6fb99a25db" translate="yes" xml:space="preserve">
          <source>, where b is the number of bits in the target type, is repeatedly subtracted or added to the source value until the result fits in the target type. In other words, unsigned integers implement modulo arithmetic.</source>
          <target state="translated">여기서 b는 대상 유형의 비트 수이며 결과가 대상 유형에 맞을 때까지 반복적으로 빼거나 소스 값에 추가됩니다. 즉, 부호없는 정수는 모듈로 산술을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="b36060bf4e5c97ae4963af3a59f16af4bf50b242" translate="yes" xml:space="preserve">
          <source>, which are initialized from the</source>
          <target state="translated">에서 초기화되는</target>
        </trans-unit>
        <trans-unit id="79b6f044da56feb83046377b165ab2ff1d4ff00c" translate="yes" xml:space="preserve">
          <source>, which are the following</source>
          <target state="translated">, 다음은</target>
        </trans-unit>
        <trans-unit id="8b91eb803cc38f188a6868c2ee6f424d2b9fd012" translate="yes" xml:space="preserve">
          <source>, which determines the interpretation of the binary value stored in an object or evaluated by the expression.</source>
          <target state="translated">객체에 저장되거나 표현식으로 평가 된 이진 값의 해석을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="1b173196ee717e359310e93adc804fc79bdd0006" translate="yes" xml:space="preserve">
          <source>, which determines which &lt;a href=&quot;value_category&quot;&gt;lvalue&lt;/a&gt; accesses are valid and which violate the strict aliasing rules.</source>
          <target state="translated">유효한 &lt;a href=&quot;value_category&quot;&gt;lvalue&lt;/a&gt; 액세스와 엄격한 앨리어싱 규칙을 위반 하는 결정 .</target>
        </trans-unit>
        <trans-unit id="cb7863f012a0b7ddb1cc926f4798abeb35fb1c4a" translate="yes" xml:space="preserve">
          <source>, which is</source>
          <target state="translated">입니다.</target>
        </trans-unit>
        <trans-unit id="3dc830b832f7ab1bcea6753db5f39eb45c155405" translate="yes" xml:space="preserve">
          <source>, which is a total order of modifications made to that object. If, from some thread's point of view, modification &lt;code&gt;A&lt;/code&gt; of some atomic M &lt;a href=&quot;../atomic/memory_order&quot;&gt;happens-before&lt;/a&gt; modification &lt;code&gt;B&lt;/code&gt; of the same atomic M, then in the modification order of M, A occurs before B.</source>
          <target state="translated">이는 해당 개체에 대한 총 수정 순서입니다. 경우도 어떤 스레드의 관점에서 수정 일부 원자 M의가 &lt;a href=&quot;../atomic/memory_order&quot;&gt;일어나도 전에&lt;/a&gt; 변형 &lt;code&gt;B&lt;/code&gt; 동일한 원자 M의 다음 M의 수정 위해, B.이 발생하기 전에 &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="50054d86c86c1fe8890e739e39147cf1941c6375" translate="yes" xml:space="preserve">
          <source>, which is an expression of any arithmetic type that consists of</source>
          <target state="translated">로 구성되는 모든 산술 유형의 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="2acb97861aa5bd19b226dba59d742f4818171c04" translate="yes" xml:space="preserve">
          <source>, which is an integer value of type &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;size_t&lt;/a&gt;&lt;/code&gt; representing the number of bytes between successive addresses at which objects of this type can be allocated. The valid alignment values are non-negative integral powers of two.</source>
          <target state="translated">이 유형의 오브젝트가 할당 될 수있는 연속 주소 사이의 바이트 수를 나타내는 &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;size_t&lt;/a&gt;&lt;/code&gt; 유형의 정수 값입니다 . 유효한 정렬 값은 음이 아닌 적분 2입니다.</target>
        </trans-unit>
        <trans-unit id="15ccd90a60013a6993e1e3c4287149ef445f0f4e" translate="yes" xml:space="preserve">
          <source>, which is the type in which the calculation is performed:</source>
          <target state="translated">계산이 수행되는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="71aba55ae2a5c3a44e113fd434e125cca6f81106" translate="yes" xml:space="preserve">
          <source>, which limits the object &lt;a href=&quot;lifetime&quot;&gt;lifetime&lt;/a&gt;. There are four kinds of storage duration in C:</source>
          <target state="translated">개체 &lt;a href=&quot;lifetime&quot;&gt;수명&lt;/a&gt; 을 제한합니다 . C에는 4 가지 종류의 저장 기간이 있습니다.</target>
        </trans-unit>
        <trans-unit id="87d6bcaebb5cfcdbe3b69b42858edeb099dcf057" translate="yes" xml:space="preserve">
          <source>, which may end with an &lt;a href=&quot;variadic&quot;&gt;ellipsis parameter&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;variadic&quot;&gt;줄임표 매개 변수로&lt;/a&gt; 끝날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="71dff1d53f0b36db28ba7f5675828f35ddb509b1" translate="yes" xml:space="preserve">
          <source>, with branch cut for the first parameter along the negative real axis.</source>
          <target state="translated">음의 실수 축을 따라 첫 번째 매개 변수에 대한 분기 컷이있는</target>
        </trans-unit>
        <trans-unit id="3bc15c8aae3e4124dd409035f32ea2fd6835efc9" translate="yes" xml:space="preserve">
          <source>-</source>
          <target state="translated">-</target>
        </trans-unit>
        <trans-unit id="34f1a5523f7daf985cb06805569ec7fafb521ccd" translate="yes" xml:space="preserve">
          <source>- A conforming hosted implementation shall accept any strictly conforming program. A conforming freestanding implementation shall accept any strictly conforming program in which the use of the features specified in the library clause (clause 7) is confined to the contents of the standard headers &amp;lt;float.h&amp;gt;, &amp;lt;iso646.h&amp;gt;, &amp;lt;limits.h&amp;gt;, &amp;lt;stdalign.h&amp;gt;, &amp;lt;stdarg.h&amp;gt;, &amp;lt;stdbool.h&amp;gt;, &amp;lt;stddef.h&amp;gt;, &amp;lt;stdint.h&amp;gt;, and &amp;lt;stdnoreturn.h&amp;gt;. A conforming implementation may have extensions (including additional library functions), provided they do not alter the behavior of any strictly conforming program.</source>
          <target state="translated">-적합한 호스팅 구현은 엄격하게 준수하는 모든 프로그램을 수락해야합니다. 준수하는 독립형 구현은 라이브러리 절 (7 절)에 명시된 기능의 사용이 표준 헤더 &amp;lt;float.h&amp;gt;, &amp;lt;iso646.h&amp;gt;, &amp;lt;limits의 내용으로 제한되는 엄격한 준수 프로그램을 수용해야합니다. h&amp;gt;, &amp;lt;stdalign.h&amp;gt;, &amp;lt;stdarg.h&amp;gt;, &amp;lt;stdbool.h&amp;gt;, &amp;lt;stddef.h&amp;gt;, &amp;lt;stdint.h&amp;gt; 및 &amp;lt;stdnoreturn.h&amp;gt;. 적합한 구현은 엄격하게 준수하는 프로그램의 동작을 변경하지 않는 한 확장 (추가 라이브러리 기능 포함)을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="074be1607cf61a3e8404e6d2b18a87fc937ba85d" translate="yes" xml:space="preserve">
          <source>- acceptable to a conforming implementation.</source>
          <target state="translated">-적합한 구현에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="16c49dca8c6497169c3f8dd2fdd7603b00d658e4" translate="yes" xml:space="preserve">
          <source>- implementation-defined behavior that depends on the &lt;a href=&quot;../locale/setlocale&quot;&gt;currently chosen locale&lt;/a&gt;. For example, whether &lt;code&gt;&lt;a href=&quot;../string/byte/islower&quot;&gt;islower&lt;/a&gt;&lt;/code&gt; returns true for any character other than the 26 lowercase Latin letters.</source>
          <target state="translated">- &lt;a href=&quot;../locale/setlocale&quot;&gt;현재 선택된 로케일&lt;/a&gt; 에 의존하는 구현 정의 동작 . 예를 들어 &lt;code&gt;&lt;a href=&quot;../string/byte/islower&quot;&gt;islower&lt;/a&gt;&lt;/code&gt; 가 26 개의 라틴 라틴 문자 이외의 문자에 대해 true를 반환 하는지 여부 입니다.</target>
        </trans-unit>
        <trans-unit id="96847337e2605434130bd96f5f2d7ca493a59146" translate="yes" xml:space="preserve">
          <source>- there are no restrictions on the behavior of the program. Examples of undefined behavior are memory accesses outside of array bounds, signed integer overflow, null pointer dereference, modification of the same scalar &lt;a href=&quot;eval_order&quot;&gt;more than once&lt;/a&gt; in an expression without sequence points, access to an object through a pointer of a different type, etc. Compilers are not required to diagnose undefined behavior (although many simple situations are diagnosed), and the compiled program is not required to do anything meaningful.</source>
          <target state="translated">-프로그램의 동작에는 제한이 없습니다. 정의되지 않은 동작의 예는 배열 범위 외부의 메모리 액세스, 부호있는 정수 오버 플로우, 널 포인터 역 참조, 시퀀스 포인트가없는 표현식에서 동일한 스칼라를 &lt;a href=&quot;eval_order&quot;&gt;두 번 이상&lt;/a&gt; 수정 , 다른 유형의 포인터를 통한 객체 액세스 등입니다. 정의되지 않은 동작을 진단 할 필요는 없지만 (많은 간단한 상황이 진단되지만) 컴파일 된 프로그램은 의미있는 작업을 수행하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="b4090cbd99792300c3be6967223eb7e4f2ebd39d" translate="yes" xml:space="preserve">
          <source>- two or more behaviors are permitted and the implementation is not required to document the effects of each behavior. For example, &lt;a href=&quot;eval_order&quot;&gt;order of evaluation&lt;/a&gt;, whether identical &lt;a href=&quot;string_literal&quot;&gt;string literals&lt;/a&gt; are distinct, etc. Each unspecified behavior results in one of a set of valid results and may produce a different result when repeated in the same program.</source>
          <target state="translated">-두 가지 이상의 행동이 허용되며 각 행동의 영향을 문서화하기 위해 구현이 필요하지 않습니다. 예를 들어, 동일한 &lt;a href=&quot;string_literal&quot;&gt;문자열 리터럴&lt;/a&gt; 의 구별 여부 등 &lt;a href=&quot;eval_order&quot;&gt;의 평가 순서&lt;/a&gt; . 지정되지 않은 각 동작은 유효한 결과 집합 중 하나를 초래하며 동일한 프로그램에서 반복 될 때 다른 결과를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0cb651905aba72cbf1f6b2c14e971e8e7b2f89c" translate="yes" xml:space="preserve">
          <source>- unspecified behavior where each implementation documents how the choice is made. For example, number of bits in a byte, or whether signed integer right shift is arithmetic or logical.</source>
          <target state="translated">-각 구현이 선택 방법을 문서화하는 지정되지 않은 동작. 예를 들어, 바이트의 비트 수 또는 부호있는 정수 오른쪽 시프트가 산술인지 논리인지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="b02040b96325a522dcde128f5a746a1d1f567dd4" translate="yes" xml:space="preserve">
          <source>- uses only well-defined language constructs, that is constructs with a single behavior. It excludes unspecified, undefined, or implementation-defined behavior, and does not exceed any minimum implementation limit.</source>
          <target state="translated">-잘 정의 된 언어 구성 만 사용합니다. 즉, 단일 동작으로 구성됩니다. 지정되지 않은, 정의되지 않은 또는 구현 정의 된 동작을 제외하고 최소 구현 제한을 초과하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="efbd6839532c28207854ecf019b87bf92b7e1582" translate="yes" xml:space="preserve">
          <source>-1 can be expressed as &lt;code&gt;&lt;a href=&quot;expm1&quot;&gt;expm1&lt;/a&gt;(n * log1p(x))&lt;/code&gt;. These functions also simplify writing accurate inverse hyperbolic functions.</source>
          <target state="translated">-1은 &lt;code&gt;&lt;a href=&quot;expm1&quot;&gt;expm1&lt;/a&gt;(n * log1p(x))&lt;/code&gt; 로 표현할 수 있습니다 . 이 함수는 또한 정확한 역 쌍곡 함수 작성을 단순화합니다.</target>
        </trans-unit>
        <trans-unit id="2226e058fc35d2f8f97985e1816070b5eb589cc7" translate="yes" xml:space="preserve">
          <source>-1 can be expressed as &lt;code&gt;expm1(n * &lt;a href=&quot;log1p&quot;&gt;log1p&lt;/a&gt;(x))&lt;/code&gt;. These functions also simplify writing accurate inverse hyperbolic functions.</source>
          <target state="translated">-1은 &lt;code&gt;expm1(n * &lt;a href=&quot;log1p&quot;&gt;log1p&lt;/a&gt;(x))&lt;/code&gt; 로 표현할 수 있습니다 . 이 함수는 또한 정확한 역 쌍곡 함수 작성을 단순화합니다.</target>
        </trans-unit>
        <trans-unit id="3305ff5f9e6888f00e265722318e8540b7b5945e" translate="yes" xml:space="preserve">
          <source>-1 is returned.</source>
          <target state="translated">-1이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="16372868051b38c9793bfcfb1bab9865824a7cf8" translate="yes" xml:space="preserve">
          <source>-e-arg</source>
          <target state="translated">-e-arg</target>
        </trans-unit>
        <trans-unit id="36105b9bc31e91d70aff56af9dcd73894e1e5181" translate="yes" xml:space="preserve">
          <source>-e-iz</source>
          <target state="translated">-e-iz</target>
        </trans-unit>
        <trans-unit id="c6ea641826a7102b4cb61da3fbe5c8784257cca9" translate="yes" xml:space="preserve">
          <source>-e-z</source>
          <target state="translated">-e-z</target>
        </trans-unit>
        <trans-unit id="af8605005221d6158480c209167abfb0fad20613" translate="yes" xml:space="preserve">
          <source>-eiz</source>
          <target state="translated">-eiz</target>
        </trans-unit>
        <trans-unit id="3a52ce780950d4d969792a2559cd519d7ee8c727" translate="yes" xml:space="preserve">
          <source>.</source>
          <target state="translated">.</target>
        </trans-unit>
        <trans-unit id="858e49b217359edfde089556fcb3a0afd53dff9d" translate="yes" xml:space="preserve">
          <source>. A program that has two conflicting evaluations has a</source>
          <target state="translated">. 두 개의 상충되는 평가가있는 프로그램에는</target>
        </trans-unit>
        <trans-unit id="cbbb5f1992507694eac424a4f3fd057df1fe433d" translate="yes" xml:space="preserve">
          <source>. A struct or union type whose member has extended alignment is an</source>
          <target state="translated">. 멤버가 정렬을 확장 한 구조체 또는 공용체 유형은</target>
        </trans-unit>
        <trans-unit id="10d5784d2f0ad622c7826278af7b5d1e2dbdfa67" translate="yes" xml:space="preserve">
          <source>. Accessing a trap representation in any way other than reading it through an lvalue expression of character type is undefined behavior. The value of a structure or union is never a trap representation even if any particular member is one.</source>
          <target state="translated">. 문자 유형의 lvalue 표현식을 통해 읽는 것 이외의 방법으로 트랩 표현에 액세스하는 것은 정의되지 않은 동작입니다. 특정 멤버가 하나라도 구조체 또는 공용체의 값은 트랩 표현이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="40cdcbb4fcaaf112141529b2f4aa097584351c61" translate="yes" xml:space="preserve">
          <source>. Always stores a null character in addition to the characters matched (so the argument array must have room for at least</source>
          <target state="translated">. 일치하는 문자 외에 항상 널 문자를 저장합니다 (따라서 인수 배열에는 최소한 공간이 있어야합니다)</target>
        </trans-unit>
        <trans-unit id="a1b0da760b32f18ba3fc29ea2034487403e7abfa" translate="yes" xml:space="preserve">
          <source>. Each byte in memory has a unique</source>
          <target state="translated">. 메모리의 각 바이트는 고유합니다</target>
        </trans-unit>
        <trans-unit id="05d1e5049ce9332e42685d5c8f52a086ff3e92f9" translate="yes" xml:space="preserve">
          <source>. Every member of an anonymous struct is considered to be a member of the enclosing struct or union. This applies recursively if the enclosing struct or union is also anonymous.</source>
          <target state="translated">. 익명 구조체의 모든 멤버는 둘러싸는 구조체 또는 공용체의 멤버로 간주됩니다. 둘러싸는 구조체 또는 공용체도 익명 인 경우 재귀 적으로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="da6b2d39ee77d5ede52703551bff148703366c7b" translate="yes" xml:space="preserve">
          <source>. Every member of an anonymous union is considered to be a member of the enclosing struct or union. This applies recursively if the enclosing struct or union is also anonymous.</source>
          <target state="translated">. 익명 공용체의 모든 구성원은 둘러싸는 구조체 또는 공용체의 구성원으로 간주됩니다. 둘러싸는 구조체 또는 공용체도 익명 인 경우 재귀 적으로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="bdbadb9492e1aaa923f351b943afd53e801082db" translate="yes" xml:space="preserve">
          <source>. For example, &lt;code&gt;&quot;ch&quot;&lt;/code&gt; in Czech follows &lt;code&gt;&quot;h&quot;&lt;/code&gt; and precedes &lt;code&gt;&quot;i&quot;&lt;/code&gt;, and &lt;code&gt;&quot;dzs&quot;&lt;/code&gt; in Hungarian follows &lt;code&gt;&quot;dz&quot;&lt;/code&gt; and precedes &lt;code&gt;&quot;g&quot;&lt;/code&gt;.</source>
          <target state="translated">. 예를 들어, &lt;code&gt;&quot;ch&quot;&lt;/code&gt; 체코 다음 &lt;code&gt;&quot;h&quot;&lt;/code&gt; 와 선행 &lt;code&gt;&quot;i&quot;&lt;/code&gt; , 및 &lt;code&gt;&quot;dzs&quot;&lt;/code&gt; 헝가리어 다음에 &lt;code&gt;&quot;dz&quot;&lt;/code&gt; 및 선행 &lt;code&gt;&quot;g&quot;&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="156efcd84b6ab49b763489ee2fc1517f4c5109ad" translate="yes" xml:space="preserve">
          <source>. For negative &lt;code&gt;LHS&lt;/code&gt;, the value of &lt;code&gt;LHS &amp;gt;&amp;gt; RHS&lt;/code&gt; is implementation-defined where in most implementations, this performs arithmetic right shift (so that the result remains negative). Thus in most implementations, right shifting a signed &lt;code&gt;LHS&lt;/code&gt; fills the new higher-order bits with the original sign bit (i.e. with 0 if it was non-negative and 1 if it was negative).</source>
          <target state="translated">. 음수 &lt;code&gt;LHS&lt;/code&gt; 의 경우, &lt;code&gt;LHS &amp;gt;&amp;gt; RHS&lt;/code&gt; 의 값은 대부분의 구현에서 산술 오른쪽 이동을 수행하여 결과가 음수로 유지되는 구현 정의입니다. 따라서 대부분의 구현에서 부호있는 &lt;code&gt;LHS&lt;/code&gt; 를 오른쪽으로 이동 하면 새로운 상위 비트가 원래 부호 비트로 채워집니다 (즉, 음이 아닌 경우 0, 음의 경우 1).</target>
        </trans-unit>
        <trans-unit id="d82d917e197ae463a094b584241f35f782aec1e5" translate="yes" xml:space="preserve">
          <source>. Four data models found wide acceptance:</source>
          <target state="translated">. 네 가지 데이터 모델이 폭넓게 수용되었습니다.</target>
        </trans-unit>
        <trans-unit id="99a683fd566c429de6986c8efcc6c2533955f501" translate="yes" xml:space="preserve">
          <source>. In particular, OS-dependent end-of-line indicators are replaced by newline characters. The</source>
          <target state="translated">. 특히 OS 종속 행 끝 표시기는 줄 바꾸기 문자로 대체됩니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="46fe2196ee1aed1eb16e860162ec02435b582476" translate="yes" xml:space="preserve">
          <source>. In particular, they are not assignable:</source>
          <target state="translated">. 특히 다음과 같이 지정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c653a9440d372d986f9a22fb459288136c558018" translate="yes" xml:space="preserve">
          <source>. It cannot be used with function declarations. If it is used on a declaration of an object, it must be present on every declaration of the same object. If it is used on a block-scope declaration, it must be combined with either &lt;code&gt;static&lt;/code&gt; or &lt;code&gt;extern&lt;/code&gt; to decide linkage.</source>
          <target state="translated">. 함수 선언과 함께 사용할 수 없습니다. 객체 선언에 사용되는 경우 동일한 객체의 모든 선언에 있어야합니다. 블록 범위 선언에서 사용되는 경우 링크를 결정하기 위해 &lt;code&gt;static&lt;/code&gt; 또는 &lt;code&gt;extern&lt;/code&gt; 과 결합되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="efcbee607982b2aa771b1583feadbc2da72281ea" translate="yes" xml:space="preserve">
          <source>. It is implementation-defined if over-aligned types are supported, and their support may be different in each kind of &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt;.</source>
          <target state="translated">. 과도하게 정렬 된 유형이 지원되는 경우 구현에 따라 정의되며 각 유형의 &lt;a href=&quot;storage_duration&quot;&gt;스토리지 기간&lt;/a&gt; 마다 지원이 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e473702a4a933416fe504d91f5daab2c6f1c4d4a" translate="yes" xml:space="preserve">
          <source>. It is often used to provide an empty body to a &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt; or &lt;a href=&quot;while&quot;&gt;while&lt;/a&gt; loop. It can also be used to carry a label in the end of a compound statement or before a declaration:</source>
          <target state="translated">. 종종 &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt; 또는 &lt;a href=&quot;while&quot;&gt;while&lt;/a&gt; 루프에 빈 바디를 제공하는 데 사용됩니다 . 또한 복합 명령문의 끝이나 선언 전에 레이블을 전달하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fd05493594e79b94be80621c509c9e737da3b3c" translate="yes" xml:space="preserve">
          <source>. No memory reads or writes in the current thread can be reordered before or after this store. All writes in other threads that release the same atomic variable are visible before the modification and the modification is visible in other threads that acquire the same atomic variable.</source>
          <target state="translated">. 이 스레드 전후에 현재 스레드에서 메모리 읽기 또는 쓰기를 다시 정렬 할 수 없습니다. 동일한 원자 변수를 해제하는 다른 스레드의 모든 쓰기는 수정 전에 볼 수 있으며 수정은 동일한 원자 변수를 얻는 다른 스레드에서 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="270b00af5338320e1ae8a0e716a624795aadd17f" translate="yes" xml:space="preserve">
          <source>. One external definition must exist in the program if the name of the function with external linkage is used in an expression, see &lt;a href=&quot;extern#One_definition_rule&quot;&gt;one definition rule&lt;/a&gt;.</source>
          <target state="translated">. 외부 연결이있는 함수의 이름이 표현식에 사용되는 경우 하나의 외부 정의가 프로그램에 존재해야합니다 ( &lt;a href=&quot;extern#One_definition_rule&quot;&gt;하나의 정의 규칙&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="9ec6034a0a3e4f26898f4f03914a189bcae87c10" translate="yes" xml:space="preserve">
          <source>. Only then &lt;code&gt;feof&lt;/code&gt; returns non-zero.</source>
          <target state="translated">. 그런 다음에 만 &lt;code&gt;feof&lt;/code&gt; 는 0이 아닌 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f7c05934e49017a55ffd7f8db5e6be448b7c6949" translate="yes" xml:space="preserve">
          <source>. Otherwise, it is a</source>
          <target state="translated">. 그렇지 않으면, 그것은</target>
        </trans-unit>
        <trans-unit id="4ee5e750f90c1a9b7b4fab6d56ee4fd4da4ddf59" translate="yes" xml:space="preserve">
          <source>. Same applies to function calls and lvalue accesses; argument types must be</source>
          <target state="translated">. 함수 호출 및 lvalue 액세스에도 동일하게 적용됩니다. 인수 유형은</target>
        </trans-unit>
        <trans-unit id="f2ff0599118c160cd812ea9c4d11954873276237" translate="yes" xml:space="preserve">
          <source>. See &lt;a href=&quot;struct&quot;&gt;struct&lt;/a&gt; for details:</source>
          <target state="translated">. 자세한 내용은 &lt;a href=&quot;struct&quot;&gt;구조체&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="21418531aab799fd1c9004344d71da3f5022f447" translate="yes" xml:space="preserve">
          <source>. Temporary lifetime begins when the expression that refers to such object is evaluated and ends at the next &lt;a href=&quot;eval_order&quot;&gt;sequence point&lt;/a&gt;(until C11)when the containing full expression or full declarator ends(since C11).</source>
          <target state="translated">. 임시 수명은 그러한 객체를 참조하는 표현식이 평가 될 때 시작되고 포함 &lt;a href=&quot;eval_order&quot;&gt;시퀀스&lt;/a&gt; 전체 선언 또는 전체 선언자가 종료 될 때 (C11 이후) 다음 시퀀스 포인트 에서 종료됩니다 (C11까지).</target>
        </trans-unit>
        <trans-unit id="3cb17b45da870b7ec9baaca006a81afb0e3f404f" translate="yes" xml:space="preserve">
          <source>. The function then searches from that point on for the first character that</source>
          <target state="translated">. 그런 다음 함수는 그 시점부터 첫 번째 문자를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="2923ece4a0bd3546cfdc4f62787758294b263ad1" translate="yes" xml:space="preserve">
          <source>. The function then searches from that point on for the first wide character that</source>
          <target state="translated">. 그런 다음 함수는 그 시점부터 첫 번째 넓은 문자를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="b32bdd7e11f2f4d8b46b2592db4c68dc65ad8f8a" translate="yes" xml:space="preserve">
          <source>. The identifier can be referred to from all scopes in the current translation unit. All &lt;code&gt;static&lt;/code&gt; file-scope identifiers (both functions and variables) have this linkage.</source>
          <target state="translated">. 식별자는 현재 번역 단위의 모든 범위에서 참조 될 수 있습니다. 모든 &lt;code&gt;static&lt;/code&gt; 파일 범위 식별자 (함수와 변수 모두)에는이 연결이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d87917fae1af4f4aab36a5eae7fc7ecbf1051535" translate="yes" xml:space="preserve">
          <source>. The identifier can be referred to from any other translation units in the entire program. All non-&lt;code&gt;static&lt;/code&gt; functions, all &lt;code&gt;extern&lt;/code&gt; variables (unless earlier declared &lt;code&gt;static&lt;/code&gt;), and all file-scope non-&lt;code&gt;static&lt;/code&gt; variables have this linkage.</source>
          <target state="translated">. 식별자는 전체 프로그램의 다른 번역 단위에서 참조 할 수 있습니다. 모든 비 &lt;code&gt;static&lt;/code&gt; 함수, 모든 &lt;code&gt;extern&lt;/code&gt; 변수 (이전에 &lt;code&gt;static&lt;/code&gt; 으로 선언되지 않은 경우 ) 및 모든 파일 범위 비 &lt;code&gt;static&lt;/code&gt; 변수에는이 연결이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4fe68dc3d44eb94fc2705ac07d81921b98a9811" translate="yes" xml:space="preserve">
          <source>. The identifier can be referred to only from the scope it is in. All function parameters and all non-&lt;code&gt;extern&lt;/code&gt; block-scope variables (including the ones declared &lt;code&gt;static&lt;/code&gt;) have this linkage.</source>
          <target state="translated">. 식별자는 그 범위 내에서만 참조 할 수 있습니다. 모든 함수 매개 변수 및 모든 비 &lt;code&gt;extern&lt;/code&gt; 블록 범위 변수 ( &lt;code&gt;static&lt;/code&gt; 으로 선언 된 변수 포함 )에는이 연결이 있습니다.</target>
        </trans-unit>
        <trans-unit id="199a71d4fe5f266ce5c976edc3091a2497b673a9" translate="yes" xml:space="preserve">
          <source>. The members of the current object are initialized in their natural order, unless designators are used(since C99): array elements in subscript order, struct members in declaration order, only the first declared member of any union. The subobjects within the current object that aren't explicitly initialized by the closing brace are &lt;a href=&quot;initialization#Implicit_initialization&quot;&gt;implicitly initialized&lt;/a&gt;.</source>
          <target state="translated">. 지정자가 사용되지 않는 한 현재 객체의 멤버는 자연 순서로 초기화됩니다 (C99 이후) : 첨자 순서로 배열 요소, 선언 순서로 구조체 멤버, 모든 공용체의 첫 번째 선언 멤버 만. 닫는 중괄호로 명시 적으로 초기화되지 않은 현재 객체 내의 하위 객체는 &lt;a href=&quot;initialization#Implicit_initialization&quot;&gt;암시 적으로 초기화&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="bd1533b5c76faaff962a16812c24ba77289b8b1c" translate="yes" xml:space="preserve">
          <source>. The name of this value category (&quot;left value&quot;) is historic and reflects the use of lvalue expressions as the left-hand operand of the assignment operator in the CPL programming language.</source>
          <target state="translated">. 이 값 범주의 이름 ( &quot;왼쪽 값&quot;)은 역사적이며 CPL 프로그래밍 언어에서 할당 연산자의 왼쪽 피연산자로 lvalue 표현식을 사용하는 것을 반영합니다.</target>
        </trans-unit>
        <trans-unit id="70afa199f9e454e592094e63f04435db313ca692" translate="yes" xml:space="preserve">
          <source>. The number of those objects (the array size) never changes during the array lifetime.</source>
          <target state="translated">. 이러한 개체 수 (배열 크기)는 배열 수명 동안 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6eae3a5b062c6d0d79f070c26e6d62486b40cb46" translate="yes" xml:space="preserve">
          <source>...</source>
          <target state="translated">...</target>
        </trans-unit>
        <trans-unit id="42099b4af021e53fd8fd4e056c2568d7c2e3ffa8" translate="yes" xml:space="preserve">
          <source>/</source>
          <target state="translated">/</target>
        </trans-unit>
        <trans-unit id="b6589fc6ab0dc82cf12099d1c2d40ab994e8410c" translate="yes" xml:space="preserve">
          <source>0</source>
          <target state="translated">0</target>
        </trans-unit>
        <trans-unit id="a0bd242d4e9823dde121cf81241caa8cb18b052a" translate="yes" xml:space="preserve">
          <source>0&amp;ndash;8</source>
          <target state="translated">0&amp;ndash;8</target>
        </trans-unit>
        <trans-unit id="356a192b7913b04c54574d18c28d46e6395428ab" translate="yes" xml:space="preserve">
          <source>1</source>
          <target state="translated">1</target>
        </trans-unit>
        <trans-unit id="83ea50c76bc44cdd9e4f766c317db5c2037df0e1" translate="yes" xml:space="preserve">
          <source>1) (none)</source>
          <target state="translated">1) (없음)</target>
        </trans-unit>
        <trans-unit id="11d9b8b52ebd3e1a3a024e6ccd57926c21a2e926" translate="yes" xml:space="preserve">
          <source>1) &lt;code&gt;​0​&lt;/code&gt; on success, non-zero otherwise.</source>
          <target state="translated">1) &lt;code&gt;​0​&lt;/code&gt; 성공 달리 비는 제로.</target>
        </trans-unit>
        <trans-unit id="db4fdc7ee8919c52d9ff62ab1d23e4f526ff796f" translate="yes" xml:space="preserve">
          <source>1) A copy of &lt;code&gt;dest&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;dest&lt;/code&gt; 사본</target>
        </trans-unit>
        <trans-unit id="9cf81edb2a0296bfb9bc51419dde4d268c15d114" translate="yes" xml:space="preserve">
          <source>1) A copy of the value of &lt;code&gt;stream&lt;/code&gt; on success, null pointer on failure.</source>
          <target state="translated">1) 성공시 &lt;code&gt;stream&lt;/code&gt; 값의 사본 , 실패시 널 포인터.</target>
        </trans-unit>
        <trans-unit id="fd67aae7670ce9feb6c456fa4c2bd3f355bc3610" translate="yes" xml:space="preserve">
          <source>1) A prototype for this function cannot be supplied by the program</source>
          <target state="translated">1)이 기능의 프로토 타입은 프로그램에서 제공 할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="a06bae56366c0365ad6bbfb4ad7f6ef6a73924b7" translate="yes" xml:space="preserve">
          <source>1) All characters and &lt;a href=&quot;escape&quot;&gt;escape sequences&lt;/a&gt; in &lt;a href=&quot;character_constant&quot;&gt;character constants&lt;/a&gt; and &lt;a href=&quot;string_literal&quot;&gt;string literals&lt;/a&gt; are converted from</source>
          <target state="translated">1) 모든 문자와 &lt;a href=&quot;escape&quot;&gt;이스케이프 시퀀스&lt;/a&gt; 에서 &lt;a href=&quot;character_constant&quot;&gt;문자 상수&lt;/a&gt; 와 &lt;a href=&quot;string_literal&quot;&gt;문자열 리터럴이&lt;/a&gt; 변환됩니다</target>
        </trans-unit>
        <trans-unit id="f4c27bcea4b3aa21b616a6c85befb0ea0ba672b6" translate="yes" xml:space="preserve">
          <source>1) Appends a copy of the null-terminated byte string pointed to by &lt;code&gt;src&lt;/code&gt; to the end of the null-terminated byte string pointed to by &lt;code&gt;dest&lt;/code&gt;. The character &lt;code&gt;src[0]&lt;/code&gt; replaces the null terminator at the end of &lt;code&gt;dest&lt;/code&gt;. The resulting byte string is null-terminated.</source>
          <target state="translated">1) &lt;code&gt;src&lt;/code&gt; 가 가리키는 널 종료 바이트 문자열의 사본을 &lt;code&gt;dest&lt;/code&gt; 가 가리키는 널 종료 바이트 문자열의 끝에 추가합니다 . &lt;code&gt;src[0]&lt;/code&gt; 문자 는 &lt;code&gt;dest&lt;/code&gt; 끝에서 널 종료 자를 대체합니다 . 결과 바이트 문자열은 null로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="08031e1a5a9b737bab0ed454a3f52b54d4de06f5" translate="yes" xml:space="preserve">
          <source>1) Appends a copy of the wide string pointed to by &lt;code&gt;src&lt;/code&gt; to the end of the wide string pointed to by &lt;code&gt;dest&lt;/code&gt;. The wide character &lt;code&gt;src[0]&lt;/code&gt; replaces the null terminator at the end of &lt;code&gt;dest&lt;/code&gt;. The resulting wide string is null-terminated. The behavior is undefined if the destination array is not large enough for the contents of both &lt;code&gt;str&lt;/code&gt; and &lt;code&gt;dest&lt;/code&gt; and the terminating null wide character. The behavior is undefined if the strings overlap.</source>
          <target state="translated">1) &lt;code&gt;src&lt;/code&gt; 가 가리키는 넓은 문자열의 사본을 &lt;code&gt;dest&lt;/code&gt; 가 가리키는 넓은 문자열의 끝에 추가합니다 . 넓은 문자 &lt;code&gt;src[0]&lt;/code&gt; 은 &lt;code&gt;dest&lt;/code&gt; 끝에서 널 종료 자를 대체합니다 . 넓은 문자열 결과는 null로 종료됩니다. 대상 배열이 &lt;code&gt;str&lt;/code&gt; 및 &lt;code&gt;dest&lt;/code&gt; 및 종료 널 와이드 문자 의 내용에 비해 충분히 크지 않은 경우 동작이 정의되지 않습니다 . 문자열이 겹치는 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b99941872ecc3e15229952c1e253cc3f757e0b3f" translate="yes" xml:space="preserve">
          <source>1) Appends at most &lt;code&gt;count&lt;/code&gt; characters from the character array pointed to by &lt;code&gt;src&lt;/code&gt;, stopping if the null character is found, to the end of the null-terminated byte string pointed to by &lt;code&gt;dest&lt;/code&gt;. The character &lt;code&gt;src[0]&lt;/code&gt; replaces the null terminator at the end of &lt;code&gt;dest&lt;/code&gt;. The terminating null character is always appended in the end (so the maximum number of bytes the function may write is &lt;code&gt;count+1&lt;/code&gt;).</source>
          <target state="translated">1) 대부분에 추가합니다 &lt;code&gt;count&lt;/code&gt; 문자 배열을 가리키는에서 문자 &lt;code&gt;src&lt;/code&gt; 널 문자가 발견되는 경우가 가리키는 널 종료 바이트 문자열의 끝에, 중지, &lt;code&gt;dest&lt;/code&gt; . &lt;code&gt;src[0]&lt;/code&gt; 문자 는 &lt;code&gt;dest&lt;/code&gt; 끝에서 널 종료 자를 대체합니다 . 종료 널 문자는 항상 끝에 추가됩니다 (따라서 함수가 작성할 수있는 최대 바이트 수는 &lt;code&gt;count+1&lt;/code&gt; 입니다 ).</target>
        </trans-unit>
        <trans-unit id="c18345579796716674aabf25842f580fad0d9342" translate="yes" xml:space="preserve">
          <source>1) Appends at most &lt;code&gt;count&lt;/code&gt; wide characters from the wide string pointed to by &lt;code&gt;src&lt;/code&gt;, stopping if the null terminator is copied, to the end of the character string pointed to by &lt;code&gt;dest&lt;/code&gt;. The wide character &lt;code&gt;src[0]&lt;/code&gt; replaces the null terminator at the end of &lt;code&gt;dest&lt;/code&gt;. The null terminator is always appended in the end (so the maximum number of wide characters the function may write is &lt;code&gt;count+1&lt;/code&gt;).</source>
          <target state="translated">1) 널 종료 문자가 복사되면 중지되고 &lt;code&gt;dest&lt;/code&gt; 가 가리키는 문자열의 끝까지 &lt;code&gt;src&lt;/code&gt; 가 가리키는 넓은 문자열 에서 최대 &lt;code&gt;count&lt;/code&gt; 넓은 문자를 추가 합니다. 넓은 문자 &lt;code&gt;src[0]&lt;/code&gt; 은 &lt;code&gt;dest&lt;/code&gt; 끝에서 널 종료 자를 대체합니다 . 널 종료자는 항상 끝에 추가됩니다 (따라서 함수가 작성할 수있는 최대 와이드 문자 수는 &lt;code&gt;count+1&lt;/code&gt; 입니다 ).</target>
        </trans-unit>
        <trans-unit id="2cf951793fb3601a461222562ec10cec2c5a2f31" translate="yes" xml:space="preserve">
          <source>1) Attempts to establish the floating-point rounding direction equal to the argument &lt;code&gt;round&lt;/code&gt;, which is expected to be one of the &lt;a href=&quot;fe_round&quot;&gt;floating-point rounding macros&lt;/a&gt;.</source>
          <target state="translated">1) 부동 소수점 반올림 방향을 인수 &lt;code&gt;round&lt;/code&gt; 와 같고 &lt;a href=&quot;fe_round&quot;&gt;부동 소수점 반올림 매크로&lt;/a&gt; 중 하나가 될 것으로 예상 합니다 .</target>
        </trans-unit>
        <trans-unit id="7e3a5800b099aa0f75fced4ac6f2262d5f08936e" translate="yes" xml:space="preserve">
          <source>1) Attempts to obtain the full contents of the floating-point exception flags that are listed in the bitmask argument &lt;code&gt;excepts&lt;/code&gt;, which is a bitwise OR of the &lt;a href=&quot;fe_exceptions&quot;&gt;floating point exception macros&lt;/a&gt;.</source>
          <target state="translated">1) 비트 마스크 인수에 나와있는 부동 소수점 예외 플래그의 전체 내용을 얻기 위해 시도 &lt;code&gt;excepts&lt;/code&gt; 비트 단위 OR의이다, &lt;a href=&quot;fe_exceptions&quot;&gt;부동 소수점 예외 매크로&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="76935444316711f1ef025f07ccf80865f5a71493" translate="yes" xml:space="preserve">
          <source>1) Attempts to store the status of the floating-point environment in the object pointed to by &lt;code&gt;envp&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;envp&lt;/code&gt; 가 가리키는 객체에 부동 소수점 환경의 상태를 저장하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="3b24745626bd03a2ab5efc63b5854099ebde7df1" translate="yes" xml:space="preserve">
          <source>1) Behaves in an implementation-defined manner (unless pragma_params is one of the standard pragmas shown below.</source>
          <target state="translated">1) pragma_params가 아래에 표시된 표준 pragma 중 하나가 아닌 한 구현 정의 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="138c1b3894139574f948bc1c61f3212b9d87e826" translate="yes" xml:space="preserve">
          <source>1) Calls function &lt;code&gt;func&lt;/code&gt; exactly once, even if invoked from several threads. The completion of the function &lt;code&gt;func&lt;/code&gt; synchronizes with all previous or subsequent calls to &lt;code&gt;call_once&lt;/code&gt; with the same &lt;code&gt;flag&lt;/code&gt; variable.</source>
          <target state="translated">1) 여러 스레드에서 호출 된 경우에도 함수 &lt;code&gt;func&lt;/code&gt; 를 정확히 한 번 호출합니다. &lt;code&gt;func&lt;/code&gt; 함수가 완료되면 동일한 &lt;code&gt;flag&lt;/code&gt; 변수를 사용하여 &lt;code&gt;call_once&lt;/code&gt; 에 대한 모든 이전 또는 후속 호출과 동기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="e983fa94e9bc0fa6eb7fb9a5ff2433f9ef36483b" translate="yes" xml:space="preserve">
          <source>1) Changes the current preprocessor line number to lineno. Occurrences of the macro &lt;code&gt;__LINE__&lt;/code&gt; beyond this point will expand to lineno plus the number of actual source code lines encountered since.</source>
          <target state="translated">1) 현재 전 처리기 행 번호를 lineno로 변경합니다. 이 시점을 넘어 매크로 &lt;code&gt;__LINE__&lt;/code&gt; 이 발생 하면 lineno와 그 이후에 발생한 실제 소스 코드 행 수를 더한 값으로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="d5ed3f255f6b9b3c5f5fa5c30070ea9c33ab2c83" translate="yes" xml:space="preserve">
          <source>1) Constants and literals (e.g. &lt;code&gt;2&lt;/code&gt; or &lt;code&gt;&quot;Hello, world&quot;&lt;/code&gt;)</source>
          <target state="translated">1) 상수 및 리터럴 (예 : &lt;code&gt;2&lt;/code&gt; 또는 &lt;code&gt;&quot;Hello, world&quot;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="26f875ec4a5353d8ecd54b7cbbdee1a952c7e0ba" translate="yes" xml:space="preserve">
          <source>1) Converts a multibyte character string from the array whose first element is pointed to by &lt;code&gt;src&lt;/code&gt; to its wide character representation. Converted characters are stored in the successive elements of the array pointed to by &lt;code&gt;dst&lt;/code&gt;. No more than &lt;code&gt;len&lt;/code&gt; wide characters are written to the destination array.</source>
          <target state="translated">1) 첫 번째 요소가 &lt;code&gt;src&lt;/code&gt; 로 가리키는 배열에서 멀티 바이트 문자열을 와이드 문자 표현으로 변환합니다. 변환 된 문자는 &lt;code&gt;dst&lt;/code&gt; 가 가리키는 배열의 연속 요소에 저장됩니다 . &lt;code&gt;len&lt;/code&gt; 배열 이상의 문자는 대상 배열에 기록 되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a8c4295d066a7eee1c6ec3ec4bc022057c919c29" translate="yes" xml:space="preserve">
          <source>1) Converts a null-terminated multibyte character sequence, which begins in the conversion state described by &lt;code&gt;*ps&lt;/code&gt;, from the array whose first element is pointed to by &lt;code&gt;*src&lt;/code&gt; to its wide character representation. If &lt;code&gt;dst&lt;/code&gt; is not null, converted characters are stored in the successive elements of the wchar_t array pointed to by &lt;code&gt;dst&lt;/code&gt;. No more than &lt;code&gt;len&lt;/code&gt; wide characters are written to the destination array. Each multibyte character is converted as if by a call to &lt;code&gt;&lt;a href=&quot;mbrtowc&quot;&gt;mbrtowc&lt;/a&gt;&lt;/code&gt;. The conversion stops if:</source>
          <target state="translated">1) &lt;code&gt;*ps&lt;/code&gt; 로 설명 된 변환 상태에서 시작되는 널 종료 멀티 바이트 문자 시퀀스 를 첫 번째 요소가 &lt;code&gt;*src&lt;/code&gt; 가 가리키는 배열에서 와이드 문자 표시로 변환합니다. 경우 &lt;code&gt;dst&lt;/code&gt; null는 아니고, 변환 된 문자가 가리키는 wchar_t를 배열의 연속 요소에 저장됩니다 &lt;code&gt;dst&lt;/code&gt; . &lt;code&gt;len&lt;/code&gt; 배열 이상의 문자는 대상 배열에 기록 되지 않습니다 . 각 멀티 바이트 문자는 &lt;code&gt;&lt;a href=&quot;mbrtowc&quot;&gt;mbrtowc&lt;/a&gt;&lt;/code&gt; 를 호출하는 것처럼 변환됩니다 . 다음과 같은 경우 변환이 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="9f93e58e321a3860c1682a47646bc77c313d5564" translate="yes" xml:space="preserve">
          <source>1) Converts a sequence of wide characters from the array whose first element is pointed to by &lt;code&gt;*src&lt;/code&gt; to its narrow multibyte representation that begins in the conversion state described by &lt;code&gt;*ps&lt;/code&gt;. If &lt;code&gt;dst&lt;/code&gt; is not null, converted characters are stored in the successive elements of the char array pointed to by &lt;code&gt;dst&lt;/code&gt;. No more than &lt;code&gt;len&lt;/code&gt; bytes are written to the destination array.</source>
          <target state="translated">1) 첫 번째 요소가 &lt;code&gt;*src&lt;/code&gt; 로 가리키는 배열에서 와이드 문자 시퀀스를 &lt;code&gt;*ps&lt;/code&gt; 로 설명 된 변환 상태에서 시작하는 좁은 멀티 바이트 표현으로 변환 합니다. 경우 &lt;code&gt;dst&lt;/code&gt; null는 아니고, 변환 된 문자가 가리키는 char 배열의 연속 요소에 저장됩니다 &lt;code&gt;dst&lt;/code&gt; . 대상 배열에 &lt;code&gt;len&lt;/code&gt; 바이트 만 쓰지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ba625a1ebaeadb1d6253272f6f21258cafb64d31" translate="yes" xml:space="preserve">
          <source>1) Converts a sequence of wide characters from the array whose first element is pointed to by &lt;code&gt;src&lt;/code&gt; to its narrow multibyte representation that begins in the initial shift state. Converted characters are stored in the successive elements of the char array pointed to by &lt;code&gt;dst&lt;/code&gt;. No more than &lt;code&gt;len&lt;/code&gt; bytes are written to the destination array.</source>
          <target state="translated">1) 첫 번째 요소가 &lt;code&gt;src&lt;/code&gt; 로 가리키는 배열에서 와이드 문자 시퀀스를 초기 시프트 상태에서 시작하는 좁은 멀티 바이트 표현으로 변환합니다. 변환 된 문자는 &lt;code&gt;dst&lt;/code&gt; 가 가리키는 char 배열의 연속 요소에 저장됩니다 . 대상 배열에 &lt;code&gt;len&lt;/code&gt; 바이트 만 쓰지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="742ed9e76e2e160f70177e7d4aac7c94023ca13f" translate="yes" xml:space="preserve">
          <source>1) Converts a wide character &lt;code&gt;wc&lt;/code&gt; to multibyte encoding and stores it (including any shift sequences) in the char array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;. No more than &lt;code&gt;MB_CUR_MAX&lt;/code&gt; characters are stored.</source>
          <target state="translated">1) 와이드 문자 &lt;code&gt;wc&lt;/code&gt; 를 멀티 바이트 인코딩으로 변환하고 첫 번째 요소가 &lt;code&gt;s&lt;/code&gt; 로 가리키는 char 배열에 저장합니다 (모든 시프트 시퀀스 포함) . &lt;code&gt;MB_CUR_MAX&lt;/code&gt; 자를 초과 하여 저장 하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ac819900e9b8a74bb53dee492bfaff8a7341bcee" translate="yes" xml:space="preserve">
          <source>1) Converts given calendar time &lt;code&gt;&lt;a href=&quot;tm&quot;&gt;tm&lt;/a&gt;&lt;/code&gt; to a textual representation of the following fixed 25-character form: &lt;code&gt;Www Mmm dd hh:mm:ss yyyy\n&lt;/code&gt;</source>
          <target state="translated">1) 주어진 달력 시간 &lt;code&gt;&lt;a href=&quot;tm&quot;&gt;tm&lt;/a&gt;&lt;/code&gt; 을 다음과 같은 고정 된 25 자 형태의 텍스트 표현으로 변환 합니다. &lt;code&gt;Www Mmm dd hh:mm:ss yyyy\n&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="be400bf1c11f227aed0d43b3234b3ce9f4ab1874" translate="yes" xml:space="preserve">
          <source>1) Converts given time since epoch (a &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;time_t&lt;/a&gt;&lt;/code&gt; value pointed to by &lt;code&gt;time&lt;/code&gt;) into calendar time, expressed in Coordinated Universal Time (UTC) in the &lt;a href=&quot;tm&quot;&gt;struct tm&lt;/a&gt; format. The result is stored in static storage and a pointer to that static storage is returned.</source>
          <target state="translated">1) 에포크 (a 때문에 주어진 시간 변환 &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;time_t&lt;/a&gt;&lt;/code&gt; 값이 가리키는 &lt;code&gt;time&lt;/code&gt; 에서 협정 세계시 (UTC 표현 일정 시간에)) &lt;a href=&quot;tm&quot;&gt;구조체 TM의&lt;/a&gt; 포맷. 결과는 정적 저장소에 저장되고 해당 정적 저장소에 대한 포인터가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="720c7e0c7407653d5a17b2390efef16373b73e84" translate="yes" xml:space="preserve">
          <source>1) Converts given time since epoch (a &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;time_t&lt;/a&gt;&lt;/code&gt; value pointed to by &lt;code&gt;time&lt;/code&gt;) into calendar time, expressed in local time, in the &lt;a href=&quot;tm&quot;&gt;struct tm&lt;/a&gt; format. The result is stored in static storage and a pointer to that static storage is returned.</source>
          <target state="translated">1) 에포크 이후의 특정 시간 ( &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;time_t&lt;/a&gt;&lt;/code&gt; 값이 &lt;code&gt;time&lt;/code&gt; 으로 가리키는 값 )을 현지 시간으로 표현 된 &lt;a href=&quot;tm&quot;&gt;struct tm&lt;/a&gt; 형식의 달력 시간으로 변환 합니다. 결과는 정적 저장소에 저장되고 해당 정적 저장소에 대한 포인터가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="70c6b5e08bb0f4691eb13e9edbb42cc49ce887fc" translate="yes" xml:space="preserve">
          <source>1) Converts given time since epoch to a calendar local time and then to a textual representation, as if by calling &lt;code&gt;&lt;a href=&quot;asctime&quot;&gt;asctime&lt;/a&gt;(&lt;a href=&quot;localtime&quot;&gt;localtime&lt;/a&gt;(&lt;a href=&quot;time&quot;&gt;time&lt;/a&gt;))&lt;/code&gt;.</source>
          <target state="translated">1) 에포크 이후의 주어진 시간을 &lt;code&gt;&lt;a href=&quot;asctime&quot;&gt;asctime&lt;/a&gt;(&lt;a href=&quot;localtime&quot;&gt;localtime&lt;/a&gt;(&lt;a href=&quot;time&quot;&gt;time&lt;/a&gt;))&lt;/code&gt; 을 호출하는 것처럼 달력 현지 시간으로 변환 한 다음 텍스트 표현으로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="57b1fe8bdc9c8a0e3c4dba38a5aa9a884691a635" translate="yes" xml:space="preserve">
          <source>1) Copies &lt;code&gt;count&lt;/code&gt; characters from the object pointed to by &lt;code&gt;src&lt;/code&gt; to the object pointed to by &lt;code&gt;dest&lt;/code&gt;. Both objects are interpreted as arrays of &lt;code&gt;unsigned char&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;src&lt;/code&gt; 가 가리키는 객체에서 &lt;code&gt;dest&lt;/code&gt; 가 가리키는 객체까지 문자 &lt;code&gt;count&lt;/code&gt; 복사 합니다 . 두 객체 모두 &lt;code&gt;unsigned char&lt;/code&gt; 배열로 해석됩니다 .</target>
        </trans-unit>
        <trans-unit id="6e4f836ea862dfbbf74c4fb83ee893f724f6e7a7" translate="yes" xml:space="preserve">
          <source>1) Copies &lt;code&gt;count&lt;/code&gt; characters from the object pointed to by &lt;code&gt;src&lt;/code&gt; to the object pointed to by &lt;code&gt;dest&lt;/code&gt;. Both objects are interpreted as arrays of &lt;code&gt;unsigned char&lt;/code&gt;. The objects may overlap: copying takes place as if the characters were copied to a temporary character array and then the characters were copied from the array to &lt;code&gt;dest&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;src&lt;/code&gt; 가 가리키는 객체에서 &lt;code&gt;dest&lt;/code&gt; 가 가리키는 객체까지 문자 &lt;code&gt;count&lt;/code&gt; 복사 합니다 . 두 객체 모두 &lt;code&gt;unsigned char&lt;/code&gt; 배열로 해석됩니다 . 객체는 겹칠 수 있습니다. 문자가 임시 문자 배열로 복사 된 다음 문자가 배열에서 &lt;code&gt;dest&lt;/code&gt; 로 복사 된 것처럼 복사가 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="172cb9c7358f412aba13d2b339b46d572713ebe4" translate="yes" xml:space="preserve">
          <source>1) Copies at most &lt;code&gt;count&lt;/code&gt; characters of the character array pointed to by &lt;code&gt;src&lt;/code&gt; (including the terminating null character, but not any of the characters that follow the null character) to character array pointed to by &lt;code&gt;dest&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;src&lt;/code&gt; (널링 문자를 포함하지만 널 문자 뒤에 오는 문자는 포함하지 않음)가 가리키는 문자 배열의 최대 &lt;code&gt;count&lt;/code&gt; 문자를 &lt;code&gt;dest&lt;/code&gt; 가 가리키는 문자 배열에 복사 합니다.</target>
        </trans-unit>
        <trans-unit id="d1e35a404f49962ccbce6ddc3130c0228ad1eadb" translate="yes" xml:space="preserve">
          <source>1) Copies at most &lt;code&gt;count&lt;/code&gt; characters of the wide string pointed to by &lt;code&gt;src&lt;/code&gt; (including the terminating null wide character) to wide character array pointed to by &lt;code&gt;dest&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;src&lt;/code&gt; (종료 널 와이드 문자 포함)가 가리키는 와이드 문자열의 최대 &lt;code&gt;count&lt;/code&gt; 문자를 &lt;code&gt;dest&lt;/code&gt; 가 가리키는 와이드 문자 배열에 복사 합니다.</target>
        </trans-unit>
        <trans-unit id="447755db4ad329acc0727c1837ba83cd9d154adf" translate="yes" xml:space="preserve">
          <source>1) Copies exactly &lt;code&gt;count&lt;/code&gt; successive wide characters from the wide character array pointed to by &lt;code&gt;src&lt;/code&gt; to the wide character array pointed to by &lt;code&gt;dest&lt;/code&gt;. If &lt;code&gt;count&lt;/code&gt; is zero, the function does nothing. The arrays may overlap: copying takes place as if the wide characters were copied to a temporary wide character array and then copied from the temporary array to &lt;code&gt;dest&lt;/code&gt;.</source>
          <target state="translated">1) 사본 은 &lt;code&gt;src&lt;/code&gt; 가 가리키는 넓은 문자 배열에서 &lt;code&gt;dest&lt;/code&gt; 가 가리키는 넓은 문자 배열 까지 연속적인 넓은 문자를 정확하게 &lt;code&gt;count&lt;/code&gt; 합니다. 경우 &lt;code&gt;count&lt;/code&gt; 제로,이 함수는 작동하지 않습니다. 배열은 겹칠 수 있습니다. 와이드 문자가 임시 와이드 문자 배열로 복사 된 다음 임시 배열에서 &lt;code&gt;dest&lt;/code&gt; 로 복사 된 것처럼 복사가 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="78b1d607326b01639aaefc137474111c344cb563" translate="yes" xml:space="preserve">
          <source>1) Copies exactly &lt;code&gt;count&lt;/code&gt; successive wide characters from the wide character array pointed to by &lt;code&gt;src&lt;/code&gt; to the wide character array pointed to by &lt;code&gt;dest&lt;/code&gt;. If the objects overlap, the behavior is undefined. If &lt;code&gt;count&lt;/code&gt; is zero, the function does nothing.</source>
          <target state="translated">1) 사본 은 &lt;code&gt;src&lt;/code&gt; 가 가리키는 넓은 문자 배열에서 &lt;code&gt;dest&lt;/code&gt; 가 가리키는 넓은 문자 배열 까지 연속적인 넓은 문자를 정확하게 &lt;code&gt;count&lt;/code&gt; 합니다. 객체가 겹치는 경우 동작이 정의되지 않습니다. 경우 &lt;code&gt;count&lt;/code&gt; 제로,이 함수는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b408a74f2a7d5bade4157133f5249ec3f18a9377" translate="yes" xml:space="preserve">
          <source>1) Copies the null-terminated byte string pointed to by &lt;code&gt;src&lt;/code&gt;, including the null terminator, to the character array whose first element is pointed to by &lt;code&gt;dest&lt;/code&gt;.</source>
          <target state="translated">1) 널 종료자를 포함하여 &lt;code&gt;src&lt;/code&gt; 가 가리키는 널 종료 바이트 문자열 을 첫 번째 요소가 &lt;code&gt;dest&lt;/code&gt; 에 의해 가리키는 문자 배열에 복사합니다 .</target>
        </trans-unit>
        <trans-unit id="a7590c8dfe7f9f4f0cba2d3d1e496da4894b3aeb" translate="yes" xml:space="preserve">
          <source>1) Copies the value &lt;code&gt;ch&lt;/code&gt; (after conversion to &lt;code&gt;unsigned char&lt;/code&gt; as if by &lt;code&gt;(unsigned char)ch&lt;/code&gt;) into each of the first &lt;code&gt;count&lt;/code&gt; characters of the object pointed to by &lt;code&gt;dest&lt;/code&gt;.</source>
          <target state="translated">1) 값 &lt;code&gt;ch&lt;/code&gt; 를 ( &lt;code&gt;unsigned char&lt;/code&gt; 로 변환 한 것처럼 부호없는 char 로 변환 한 후 &lt;code&gt;(unsigned char)ch&lt;/code&gt; &lt;code&gt;dest&lt;/code&gt; 가 가리키는 오브젝트 의 첫 번째 &lt;code&gt;count&lt;/code&gt; 문자 각각에 복사합니다 .</target>
        </trans-unit>
        <trans-unit id="0a598e9d9f0eae6c9aaa034d118598f831f0996f" translate="yes" xml:space="preserve">
          <source>1) Copies the wide string pointed to by &lt;code&gt;src&lt;/code&gt; (including the terminating null wide character) to wide character array pointed to by &lt;code&gt;dest&lt;/code&gt;. The behavior is undefined if the &lt;code&gt;dest&lt;/code&gt; array is not large enough. The behavior is undefined if the strings overlap.</source>
          <target state="translated">1) &lt;code&gt;src&lt;/code&gt; (종료 널 와이드 문자 포함)가 가리키는 와이드 문자열 을 &lt;code&gt;dest&lt;/code&gt; 가 가리키는 와이드 문자 배열에 복사합니다 . &lt;code&gt;dest&lt;/code&gt; 배열이 충분히 크지 않은 경우 동작이 정의되지 않습니다. 문자열이 겹치는 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bc33ce23c66c43a112a6fd473b5df3ee03f9aa62" translate="yes" xml:space="preserve">
          <source>1) Creates a unique valid file name (no longer than &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;L_tmpnam&lt;/a&gt;&lt;/code&gt; in length) and stores it in character string pointed to by &lt;code&gt;filename&lt;/code&gt;. The function is capable of generating up to &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;TMP_MAX&lt;/a&gt;&lt;/code&gt; of unique filenames, but some or all of them may be in use in the filesystem and thus not suitable return values.</source>
          <target state="translated">1) 고유 한 유효한 파일 이름 ( 길이 가 &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;L_tmpnam&lt;/a&gt;&lt;/code&gt; 보다 길지 않음 )을 만들어 &lt;code&gt;filename&lt;/code&gt; 에서 가리키는 문자열에 저장합니다 . 이 함수는 고유 한 파일 이름을 최대 &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;TMP_MAX&lt;/a&gt;&lt;/code&gt; 까지 생성 할 수 있지만 파일 시스템에서 일부 또는 전부가 사용 중일 수 있으므로 반환 값이 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="55f638de3b0da14f27a625d260567dbe037f11ee" translate="yes" xml:space="preserve">
          <source>1) Creates and opens a temporary file. The file is opened as binary file for update (as if by &lt;code&gt;&lt;a href=&quot;fopen&quot;&gt;fopen&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&quot;wb+&quot;&lt;/code&gt; mode). The filename of the file is guaranteed to be unique within the filesystem. At least &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;TMP_MAX&lt;/a&gt;&lt;/code&gt; files may be opened during the lifetime of a program (this limit may be shared with &lt;code&gt;&lt;a href=&quot;tmpnam&quot;&gt;tmpnam&lt;/a&gt;&lt;/code&gt; and may be further limited by &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;FOPEN_MAX&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">1) 임시 파일을 작성하고 엽니 다. 파일은 업데이트를 위해 이진 파일로 열립니다 ( &lt;code&gt;&quot;wb+&quot;&lt;/code&gt; 모드 로 &lt;code&gt;&lt;a href=&quot;fopen&quot;&gt;fopen&lt;/a&gt;&lt;/code&gt; 을 사용 하는 것처럼 ). 파일의 파일 이름은 파일 시스템 내에서 고유해야합니다. 프로그램 수명 동안 &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;TMP_MAX&lt;/a&gt;&lt;/code&gt; 파일 이상 이 열릴 수 있습니다 (이 제한은 &lt;code&gt;&lt;a href=&quot;tmpnam&quot;&gt;tmpnam&lt;/a&gt;&lt;/code&gt; 과 공유 될 수 있으며 &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;FOPEN_MAX&lt;/a&gt;&lt;/code&gt; 에 의해 더 제한 될 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="53849604c2e9473ad0645ee83bab501495cb04a8" translate="yes" xml:space="preserve">
          <source>1) Decimal integer constant (base 10, the first digit is the most significant).</source>
          <target state="translated">1) 10 진 정수 상수 (밑수 10, 첫 번째 숫자가 가장 중요).</target>
        </trans-unit>
        <trans-unit id="9a5efcbbb43fa701e56024a892d293c44222e230" translate="yes" xml:space="preserve">
          <source>1) Evaluates the expression, terminates the current function and returns the result of the expression to the caller (the value returned becomes the value of the function call expression). Only valid if the function return type is not &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">1) 표현식을 평가하고 현재 함수를 종료하고 표현식 결과를 호출자에게 리턴합니다 (반환 된 값은 함수 호출 표현식의 값이 됨). 함수 반환 유형이 &lt;code&gt;void&lt;/code&gt; 가 아닌 경우에만 유효합니다 .</target>
        </trans-unit>
        <trans-unit id="85934375f27aaa70f99a44c6b142870191b8a181" translate="yes" xml:space="preserve">
          <source>1) Finds an element equal to element pointed to by &lt;code&gt;key&lt;/code&gt; in an array pointed to by &lt;code&gt;ptr&lt;/code&gt;. The array contains &lt;code&gt;count&lt;/code&gt; elements of &lt;code&gt;size&lt;/code&gt; bytes and must be partitioned with respect to &lt;code&gt;key&lt;/code&gt;, that is, all the elements that compare less than must appear before all the elements that compare equal to, and those must appear before all the elements that compare greater than the key object. A fully sorted array satisfies these requirements. The elements are compared using function pointed to by &lt;code&gt;comp&lt;/code&gt;. The behavior is undefined if the array is not already partitioned with respect to &lt;code&gt;*key&lt;/code&gt; in ascending order according to the same criterion that &lt;code&gt;comp&lt;/code&gt; uses.</source>
          <target state="translated">1) &lt;code&gt;ptr&lt;/code&gt; 이 가리키는 배열에서 &lt;code&gt;key&lt;/code&gt; 가 가리키는 요소와 동일한 요소를 찾습니다 . 배열은 바이트 &lt;code&gt;size&lt;/code&gt; &lt;code&gt;count&lt;/code&gt; 요소를 포함 하며 &lt;code&gt;key&lt;/code&gt; 와 관련하여 분할 되어야합니다. 키 객체 완전히 정렬 된 어레이는 이러한 요구 사항을 충족시킵니다. &lt;code&gt;comp&lt;/code&gt; 가 가리키는 함수를 사용하여 요소를 비교 합니다. 배열이 &lt;code&gt;comp&lt;/code&gt; 와 동일한 기준에 따라 오름차순으로 &lt;code&gt;*key&lt;/code&gt; 에 대해 분할되지 않은 경우 동작이 정의되지 않습니다. 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6d6f25a9143a91bfa3ed301ee58dd20270248762" translate="yes" xml:space="preserve">
          <source>1) Finds the next token in a null-terminated byte string pointed to by &lt;code&gt;str&lt;/code&gt;. The separator characters are identified by null-terminated byte string pointed to by &lt;code&gt;delim&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;str&lt;/code&gt; 로 가리키는 null로 끝나는 바이트 문자열에서 다음 토큰을 찾습니다 . 구분 기호 문자는 &lt;code&gt;delim&lt;/code&gt; 이 가리키는 null로 끝나는 바이트 문자열로 식별됩니다 .</target>
        </trans-unit>
        <trans-unit id="786e81f2c0e06f1c0b7efb389173f5f4babe9795" translate="yes" xml:space="preserve">
          <source>1) Finds the next token in a null-terminated wide string pointed to by &lt;code&gt;str&lt;/code&gt;. The separator characters are identified by null-terminated wide string pointed to by &lt;code&gt;delim&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;str&lt;/code&gt; 로 가리키는 null로 끝나는 넓은 문자열에서 다음 토큰을 찾습니다 . 구분 기호 문자는 &lt;code&gt;delim&lt;/code&gt; 이 가리키는 널로 끝나는 와이드 문자열로 식별됩니다 .</target>
        </trans-unit>
        <trans-unit id="0351622cdad32bce5a071af4db799f10d569f4b4" translate="yes" xml:space="preserve">
          <source>1) First, attempts to close the file associated with &lt;code&gt;stream&lt;/code&gt;, ignoring any errors. Then, if &lt;code&gt;filename&lt;/code&gt; is not null, attempts to open the file specified by &lt;code&gt;filename&lt;/code&gt; using &lt;code&gt;mode&lt;/code&gt; as if by &lt;code&gt;&lt;a href=&quot;fopen&quot;&gt;fopen&lt;/a&gt;&lt;/code&gt;, and associates that file with the file stream pointed to by &lt;code&gt;stream&lt;/code&gt;. If &lt;code&gt;filename&lt;/code&gt; is a null pointer, then the function attempts to reopen the file that is already associated with &lt;code&gt;stream&lt;/code&gt; (it is implementation defined which mode changes are allowed in this case).</source>
          <target state="translated">1) 먼저, &lt;code&gt;stream&lt;/code&gt; 과 관련된 파일을 닫으려고 시도 하고 오류를 무시합니다. 경우, &lt;code&gt;filename&lt;/code&gt; null이 아닌, 시도에 의해 지정된 파일 열려면 &lt;code&gt;filename&lt;/code&gt; 사용하여 &lt;code&gt;mode&lt;/code&gt; 마치로 &lt;code&gt;&lt;a href=&quot;fopen&quot;&gt;fopen&lt;/a&gt;&lt;/code&gt; 을 하고, 동료 파일 스트림과 파일이 가리키는 것을 &lt;code&gt;stream&lt;/code&gt; . 경우 &lt;code&gt;filename&lt;/code&gt; NULL 포인터이고, 그 기능이 이미 시도와 연관되는 파일 재개 &lt;code&gt;stream&lt;/code&gt; (는 모드 변경이 경우 허용 정의 구현).</target>
        </trans-unit>
        <trans-unit id="dba3d667f792058cf65d572a0620cbdb5af5fa31" translate="yes" xml:space="preserve">
          <source>1) First, evaluates condition. There is a &lt;a href=&quot;eval_order&quot;&gt;sequence point&lt;/a&gt; after this evaluation.</source>
          <target state="translated">1) 먼저 상태를 평가합니다. 이 평가 후 &lt;a href=&quot;eval_order&quot;&gt;시퀀스 포인트&lt;/a&gt; 가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d78a3decd423f46a78e173a02493597b86b082dd" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;s&lt;/code&gt; is not a null pointer, returns the number of bytes that are contained in the multibyte representation of &lt;code&gt;wc&lt;/code&gt; or &lt;code&gt;-1&lt;/code&gt; if &lt;code&gt;wc&lt;/code&gt; is not a valid character.</source>
          <target state="translated">경우 1) &lt;code&gt;s&lt;/code&gt; NULL 포인터 아니다의 멀티 표시에 포함 된 바이트의 수를 반환 &lt;code&gt;wc&lt;/code&gt; 또는 &lt;code&gt;-1&lt;/code&gt; 경우 &lt;code&gt;wc&lt;/code&gt; 유효한 문자가 아니다.</target>
        </trans-unit>
        <trans-unit id="f9f3e5ae1b7f0a53b206e1c11ce692da23fdcc37" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;s&lt;/code&gt; is not a null pointer, the function determines the number of bytes necessary to store the multibyte character representation of &lt;code&gt;wc&lt;/code&gt; (including any shift sequences, and taking into account the current multibyte conversion state &lt;code&gt;*ps&lt;/code&gt;), and stores the multibyte character representation in the character array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;, updating &lt;code&gt;*ps&lt;/code&gt; as necessary. At most &lt;code&gt;MB_CUR_MAX&lt;/code&gt; bytes can be written by this function.</source>
          <target state="translated">1) &lt;code&gt;s&lt;/code&gt; 가 널 포인터가 아닌 경우 , 함수는 &lt;code&gt;wc&lt;/code&gt; 의 멀티 바이트 문자 표현을 저장하는 데 필요한 바이트 수 (모든 시프트 시퀀스 포함 및 현재 멀티 바이트 변환 상태 &lt;code&gt;*ps&lt;/code&gt; 고려 )를 결정하고 멀티 바이트 문자를 저장합니다. 첫 번째 요소가 &lt;code&gt;s&lt;/code&gt; 로 가리키는 문자 배열의 표현은 필요에 따라 &lt;code&gt;*ps&lt;/code&gt; 를 업데이트 합니다. 이 함수는 최대 &lt;code&gt;MB_CUR_MAX&lt;/code&gt; 바이트를 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46c99ccee207b51900c82c3893653cc70908800e" translate="yes" xml:space="preserve">
          <source>1) If a side effect on a scalar object is unsequenced relative to another side effect on the same scalar object, the &lt;a href=&quot;behavior#UB_and_optimization&quot;&gt;behavior is undefined&lt;/a&gt;.</source>
          <target state="translated">1) 스칼라 객체의 부작용이 동일한 스칼라 객체의 다른 부작용에 비해 순서가 맞지 않으면 &lt;a href=&quot;behavior#UB_and_optimization&quot;&gt;동작이 정의되지 않습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="91d6223e0fb21f8ab7ecfe4a6fb9d912ccf60686" translate="yes" xml:space="preserve">
          <source>1) If one operand is &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;long double &lt;a href=&quot;../numeric/complex/complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;long double &lt;a href=&quot;../numeric/complex/imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt;, the other operand is implicitly converted as follows:</source>
          <target state="translated">1) 한 피연산자가 &lt;code&gt;long double&lt;/code&gt; , &lt;code&gt;long double &lt;a href=&quot;../numeric/complex/complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;long double &lt;a href=&quot;../numeric/complex/imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt; 인 경우 다른 피연산자는 다음과 같이 암시 적으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="ec76cf635ed5977262cf9ddcc3fb5fe13eaaff7b" translate="yes" xml:space="preserve">
          <source>1) If set to &lt;code&gt;ON&lt;/code&gt;, informs the compiler that the program will access or modify &lt;a href=&quot;../numeric/fenv&quot;&gt;floating-point environment&lt;/a&gt;, which means that optimizations that could subvert flag tests and mode changes (e.g., global common subexpression elimination, code motion, and constant folding) are prohibited. The default value is implementation-defined, usually &lt;code&gt;OFF&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;ON&lt;/code&gt; 으로 설정 하면 프로그램이 &lt;a href=&quot;../numeric/fenv&quot;&gt;부동 소수점 환경에&lt;/a&gt; 액세스하거나 수정한다는 것을 컴파일러에 알립니다. 즉 플래그 테스트 및 모드 변경 (예 : 전역 공통 하위 표현식 제거, 코드 모션 및 상수 폴딩)을 방해 할 수있는 최적화는 다음과 같습니다. 금지되어 있습니다. 기본값은 구현 정의이며 일반적으로 &lt;code&gt;OFF&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a0cf2c0001ae474c7b0f9c8c6c0f587b7e9f3836" translate="yes" xml:space="preserve">
          <source>1) If successful, returns a pointer to the new file stream. The stream is fully buffered unless &lt;code&gt;filename&lt;/code&gt; refers to an interactive device. On error, returns a &lt;code&gt;null pointer&lt;/code&gt;. &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/fopen.html&quot;&gt;POSIX requires&lt;/a&gt; that &lt;code&gt;&lt;a href=&quot;../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; be set in this case.</source>
          <target state="translated">1) 성공하면 새 파일 스트림에 대한 포인터를 반환합니다. &lt;code&gt;filename&lt;/code&gt; 은 대화식 장치를 참조 하지 않는 한 스트림이 완전히 버퍼링됩니다 . 오류가 발생하면 &lt;code&gt;null pointer&lt;/code&gt; 반환합니다 . &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/fopen.html&quot;&gt;POSIX에서는&lt;/a&gt; 이 경우 &lt;code&gt;&lt;a href=&quot;../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; 를 설정 해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="678a432113140bb176afb353e0215e0dd0e83b04" translate="yes" xml:space="preserve">
          <source>1) If successful, returns a pointer to the new file stream. The stream is fully buffered unless &lt;code&gt;filename&lt;/code&gt; refers to an interactive device. On error, returns a &lt;code&gt;null pointer&lt;/code&gt;. &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/fopen.html&quot;&gt;POSIX requires&lt;/a&gt; that &lt;code&gt;&lt;a href=&quot;../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; be set in this case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df848c0233b65d01ab4e94194e65cb1e2e5c9a8d" translate="yes" xml:space="preserve">
          <source>1) Label name space: all identifiers declared as &lt;a href=&quot;statements#Labels&quot;&gt;labels&lt;/a&gt;.</source>
          <target state="translated">1) 레이블 네임 스페이스 : 모든 식별자는 &lt;a href=&quot;statements#Labels&quot;&gt;레이블로&lt;/a&gt; 선언됩니다 .</target>
        </trans-unit>
        <trans-unit id="b4d4a07c3e9c08b33a7bc0ef807e6a32d16bcca5" translate="yes" xml:space="preserve">
          <source>1) Modifies the &lt;code&gt;timespec&lt;/code&gt; object pointed to by &lt;code&gt;ts&lt;/code&gt; to hold the current calendar time in the time base &lt;code&gt;base&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;ts&lt;/code&gt; 가 가리키는 &lt;code&gt;timespec&lt;/code&gt; 객체를 수정하여 현재 달력 시간을 시간 기준으로 유지 &lt;code&gt;base&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20f9ff3f6e5a39bcfee25590249459245502cafe" translate="yes" xml:space="preserve">
          <source>1) New-style (C89) function declaration. This declaration both introduces the function designator itself and also serves as a function prototype for any future &lt;a href=&quot;operator_other#Function_call&quot;&gt;function call expressions&lt;/a&gt;, forcing conversions from argument expressions to the declared parameter types and compile-time checks for the number of arguments.</source>
          <target state="translated">1) 새로운 스타일 (C89) 함수 선언. 이 선언은 함수 지정자 자체를 소개하고 미래의 모든 &lt;a href=&quot;operator_other#Function_call&quot;&gt;함수 호출 표현식에&lt;/a&gt; 대한 함수 프로토 타입 역할을하여 인수 표현식에서 선언 된 매개 변수 유형으로의 변환 및 인수 수에 대한 컴파일 타임 점검을 강제합니다.</target>
        </trans-unit>
        <trans-unit id="d9fe2d5e0e3ecf062558f4356a18e383d4f1140d" translate="yes" xml:space="preserve">
          <source>1) New-style (C89) function definition. This definition both introduces the function itself and serves as a function prototype for any future &lt;a href=&quot;operator_other#Function_call&quot;&gt;function call expressions&lt;/a&gt;, forcing conversions from argument expressions to the declared parameter types.</source>
          <target state="translated">1) 새로운 스타일 (C89) 기능 정의. 이 정의는 함수 자체를 소개하고 향후 &lt;a href=&quot;operator_other#Function_call&quot;&gt;함수 호출 표현식&lt;/a&gt; 의 함수 프로토 타입으로 사용 되어 인수 표현식에서 선언 된 매개 변수 유형으로 강제 변환합니다.</target>
        </trans-unit>
        <trans-unit id="63c030571149d7aea7d192bb60285199d1752b0e" translate="yes" xml:space="preserve">
          <source>1) Often known as &quot;C-style&quot; or &quot;multi-line&quot; comments.</source>
          <target state="translated">1) 종종 &quot;C 스타일&quot;또는 &quot;멀티 라인&quot;주석으로 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="618609ec58109330b21aa98482fa0b1f3fdb692b" translate="yes" xml:space="preserve">
          <source>1) On success, returns the number of bytes (including any shift sequences) written to the character array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">1) 성공하면 첫 번째 요소가 &lt;code&gt;s&lt;/code&gt; 로 가리키는 문자 배열에 기록 된 바이트 수 (모든 시프트 시퀀스 포함)를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="5a49e17bb0fade32a7ad0c238222f23cfe1981cc" translate="yes" xml:space="preserve">
          <source>1) On success, returns the number of bytes (including any shift sequences, but excluding the terminating &lt;code&gt;'\0'&lt;/code&gt;) written to the character array whose first element is pointed to by &lt;code&gt;dst&lt;/code&gt;. If &lt;code&gt;dst==&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, returns the number of bytes that would have been written. On conversion error (if invalid wide character was encountered), returns &lt;code&gt;(&lt;a href=&quot;../../types/size_t&quot;&gt;size_t&lt;/a&gt;)-1&lt;/code&gt;, stores &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;EILSEQ&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt;, and leaves &lt;code&gt;*ps&lt;/code&gt; in unspecified state.</source>
          <target state="translated">1) 성공하면 첫 번째 요소가 &lt;code&gt;dst&lt;/code&gt; 로 가리키는 문자 배열에 기록 된 바이트 수 (모든 시프트 시퀀스를 포함하지만 종료 &lt;code&gt;'\0'&lt;/code&gt; 제외)를 반환합니다 . &lt;code&gt;dst==&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt; 인 경우 기록 된 바이트 수를 반환합니다. 변환 오류 (잘못된 유효 문자가 발생한 경우)에서 &lt;code&gt;(&lt;a href=&quot;../../types/size_t&quot;&gt;size_t&lt;/a&gt;)-1&lt;/code&gt; &lt;a href=&quot;../../types/size_t&quot;&gt;size_t&lt;/a&gt; ) -1을 반환하고 &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;EILSEQ&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; 에 저장 하고 &lt;code&gt;*ps&lt;/code&gt; 를 지정되지 않은 상태로 둡니다 .</target>
        </trans-unit>
        <trans-unit id="4d830e1d99b8f831039a165207fe794fc611d54c" translate="yes" xml:space="preserve">
          <source>1) On success, returns the number of bytes (including any shift sequences, but excluding the terminating &lt;code&gt;'\0'&lt;/code&gt;) written to the character array whose first element is pointed to by &lt;code&gt;dst&lt;/code&gt;. On conversion error (if invalid wide character was encountered), returns &lt;code&gt;(&lt;a href=&quot;../../types/size_t&quot;&gt;size_t&lt;/a&gt;)-1&lt;/code&gt;.</source>
          <target state="translated">1) 성공하면 첫 번째 요소가 &lt;code&gt;dst&lt;/code&gt; 로 가리키는 문자 배열에 기록 된 바이트 수 (모든 시프트 시퀀스를 포함하지만 종료 &lt;code&gt;'\0'&lt;/code&gt; 제외)를 반환합니다 . 변환 오류 (잘못된 와이드 문자가 발생한 경우)에서 &lt;code&gt;(&lt;a href=&quot;../../types/size_t&quot;&gt;size_t&lt;/a&gt;)-1&lt;/code&gt; &lt;a href=&quot;../../types/size_t&quot;&gt;size_t&lt;/a&gt; ) -1을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="de9c4bcef2e1e84210683c18666370b7ce24c719" translate="yes" xml:space="preserve">
          <source>1) On success, returns the number of wide characters, excluding the terminating &lt;code&gt;L'\0'&lt;/code&gt;, written to the character array. If &lt;code&gt;dst==&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, returns the number of wide characters that would have been written given unlimited length. On conversion error (if invalid multibyte character was encountered), returns &lt;code&gt;(&lt;a href=&quot;../../types/size_t&quot;&gt;size_t&lt;/a&gt;)-1&lt;/code&gt;, stores &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;EILSEQ&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt;, and leaves &lt;code&gt;*ps&lt;/code&gt; in unspecified state.</source>
          <target state="translated">1) 성공 하면 문자 배열에 쓰여지 는 종료 &lt;code&gt;L'\0'&lt;/code&gt; 제외한 와이드 문자 수를 반환합니다 . &lt;code&gt;dst==&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 인 경우 무제한 길이로 작성된 와이드 문자 수를 리턴합니다. 변환 오류 (잘못된 멀티 바이트 문자가 발생한 경우)에서 &lt;code&gt;(&lt;a href=&quot;../../types/size_t&quot;&gt;size_t&lt;/a&gt;)-1&lt;/code&gt; 을 반환하고 &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;EILSEQ&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; 에 저장 하고 &lt;code&gt;*ps&lt;/code&gt; 를 지정되지 않은 상태로 둡니다 .</target>
        </trans-unit>
        <trans-unit id="8604dac40270f6af3aa4c8c004f44d45895d6bd2" translate="yes" xml:space="preserve">
          <source>1) On success, returns the number of wide characters, excluding the terminating &lt;code&gt;L'\0'&lt;/code&gt;, written to the destination array. On conversion error (if invalid multibyte character was encountered), returns &lt;code&gt;(&lt;a href=&quot;../../types/size_t&quot;&gt;size_t&lt;/a&gt;)-1&lt;/code&gt;.</source>
          <target state="translated">1) 성공 하면 대상 배열에 쓰여지 는 종료 &lt;code&gt;L'\0'&lt;/code&gt; 제외한 넓은 문자 수를 반환합니다 . 변환 오류 (잘못된 멀티 바이트 문자가 발생한 경우)에서 &lt;code&gt;(&lt;a href=&quot;../../types/size_t&quot;&gt;size_t&lt;/a&gt;)-1&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f1122cd4916c8156186c6800d0b3a7e214a3648e" translate="yes" xml:space="preserve">
          <source>1) Opens a file indicated by &lt;code&gt;filename&lt;/code&gt; and returns a pointer to the file stream associated with that file. &lt;code&gt;mode&lt;/code&gt; is used to determine the file access mode.</source>
          <target state="translated">1) 파일 &lt;code&gt;filename&lt;/code&gt; 표시된 파일을 열고 해당 파일 과 관련된 파일 스트림에 대한 포인터를 반환합니다. &lt;code&gt;mode&lt;/code&gt; 는 파일 액세스 모드를 결정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="908e9f6935601f7cbb00a16c4508358af74f208e" translate="yes" xml:space="preserve">
          <source>1) Pointer to a null-terminated byte string corresponding to the &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; error code &lt;code&gt;errnum&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; 오류 코드 &lt;code&gt;errnum&lt;/code&gt; 에 해당하는 널 종료 바이트 문자열을 가리키는 포인터 .</target>
        </trans-unit>
        <trans-unit id="6c23a2c6874fd62c8ab9b2fe53ad53e1659a4c3c" translate="yes" xml:space="preserve">
          <source>1) Pointer to an element in the array that compares equal to &lt;code&gt;*key&lt;/code&gt;, or null pointer if such element has not been found.</source>
          <target state="translated">1) &lt;code&gt;*key&lt;/code&gt; 와 같은 것을 비교하는 배열의 요소를 가리키는 포인터, 또는 그러한 요소를 찾지 못하면 널 포인터.</target>
        </trans-unit>
        <trans-unit id="4fc80b1327582e6508e5c2e8fec2976d3e59a155" translate="yes" xml:space="preserve">
          <source>1) Pointer to the file stream associated with the file or null pointer if an error has occurred.</source>
          <target state="translated">1) 파일과 연관된 파일 스트림을 가리키는 포인터 또는 오류가 발생한 경우 널 포인터.</target>
        </trans-unit>
        <trans-unit id="72c18cc82e2e9fe645873ce5ef810c70c042f2fa" translate="yes" xml:space="preserve">
          <source>1) Reads &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; into the character array pointed to by &lt;code&gt;str&lt;/code&gt; until a newline character is found or end-of-file occurs. A null character is written immediately after the last character read into the array. The newline character is discarded but not stored in the buffer.</source>
          <target state="translated">1) 줄 바꿈 문자가 발견되거나 파일 끝이 발생할 때까지 &lt;code&gt;str&lt;/code&gt; 이 가리키는 문자 배열로 &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 을 읽 습니다 . 배열에 마지막 문자를 읽은 직후 널 문자가 작성됩니다. 개행 문자는 버려지지만 버퍼에는 저장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="457d7137f3961272494ff359e8028d91f5281869" translate="yes" xml:space="preserve">
          <source>1) Reads the data from &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 에서 데이터를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="ff832e13be6d84237e2403d654d7cf393293441e" translate="yes" xml:space="preserve">
          <source>1) Reads the data from &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 에서 데이터를 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="af9b3b718c2c35f25ec8a4df26cc4b30870708b8" translate="yes" xml:space="preserve">
          <source>1) Returns a copy of &lt;code&gt;dest&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;dest&lt;/code&gt; 사본을 반환</target>
        </trans-unit>
        <trans-unit id="42a07d7a92b332fbb593ac78f03cd9a056d91422" translate="yes" xml:space="preserve">
          <source>1) Returns a pointer to the textual description of the system error code &lt;code&gt;errnum&lt;/code&gt;, identical to the description that would be printed by &lt;code&gt;&lt;a href=&quot;../../io/perror&quot;&gt;perror()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;&lt;a href=&quot;../../io/perror&quot;&gt;perror()&lt;/a&gt;&lt;/code&gt; 로 인쇄되는 설명과 동일하게 시스템 오류 코드 &lt;code&gt;errnum&lt;/code&gt; 의 텍스트 설명에 대한 포인터를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="280dff4ad08fdb9742dfa018410e0992128f67d8" translate="yes" xml:space="preserve">
          <source>1) Returns the length of a wide string, that is the number of non-null wide characters that precede the terminating null wide character.</source>
          <target state="translated">1) 넓은 문자열의 길이, 즉 널 (NULL)이 아닌 널 (null) 문자 앞에 오는 널이 아닌 와이드 문자 수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="18368307aaa1767f1bf0f4665c28c93ab590aa16" translate="yes" xml:space="preserve">
          <source>1) Returns the length of the given null-terminated byte string, that is, the number of characters in a character array whose first element is pointed to by &lt;code&gt;str&lt;/code&gt; up to and not including the first null character.</source>
          <target state="translated">1) 주어진 널 종료 바이트 문자열의 길이, 즉 첫 번째 요소가 &lt;code&gt;str&lt;/code&gt; 에 의해 첫 번째 요소를 가리키는 문자 배열의 문자 수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7db6d0997997d535a72c6ac6ed0105500518f47c" translate="yes" xml:space="preserve">
          <source>1) Returns the size, in bytes, of the &lt;a href=&quot;object#Object_representation&quot;&gt;object representation&lt;/a&gt; of type</source>
          <target state="translated">1) 유형 의 &lt;a href=&quot;object#Object_representation&quot;&gt;객체 표현&lt;/a&gt; 의 크기를 바이트 단위로 반환합니다</target>
        </trans-unit>
        <trans-unit id="fc21fd11a3c988cbb57f351df76f43bdc0a8e7de" translate="yes" xml:space="preserve">
          <source>1) Searches for an environmental variable with name &lt;code&gt;name&lt;/code&gt; in the host-specified environment list and returns a pointer to the string that is associated with the matched environment variable. The set of environmental variables and methods of altering it are implementation-defined.</source>
          <target state="translated">1) 호스트 지정 환경 목록에서 이름이 &lt;code&gt;name&lt;/code&gt; 인 환경 변수를 검색 하고 일치하는 환경 변수와 연관된 문자열에 대한 포인터를 리턴합니다. 환경 변수 세트 및 변경 방법은 구현 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="3c9b60d20817d9dc8664bdd29847776bc1e84582" translate="yes" xml:space="preserve">
          <source>1) Searches for the file in implementation-defined manner. The intent of this syntax is to search for the files under control of the implementation. Typical implementations search only standard include directories. The standard C++ library and the standard C library are implicitly included in these standard include directories. The standard include directories usually can be controlled by the user through compiler options.</source>
          <target state="translated">1) 구현 정의 방식으로 파일을 검색합니다. 이 구문의 목적은 구현을 제어하는 ​​파일을 검색하는 것입니다. 일반적인 구현은 표준 include 디렉토리 만 검색합니다. 표준 C ++ 라이브러리 및 표준 C 라이브러리는 이러한 표준 포함 디렉토리에 내재적으로 포함됩니다. 표준 포함 디렉토리는 보통 컴파일러 옵션을 통해 사용자가 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cec97d806d38682726c4b14cdf22e26e9e67c620" translate="yes" xml:space="preserve">
          <source>1) Sorts the given array pointed to by &lt;code&gt;ptr&lt;/code&gt; in ascending order. The array contains &lt;code&gt;count&lt;/code&gt; elements of &lt;code&gt;size&lt;/code&gt; bytes. Function pointed to by &lt;code&gt;comp&lt;/code&gt; is used for object comparison.</source>
          <target state="translated">1) &lt;code&gt;ptr&lt;/code&gt; 이 가리키는 지정된 배열 을 오름차순으로 정렬합니다. 배열에는 &lt;code&gt;size&lt;/code&gt; 바이트 의 &lt;code&gt;count&lt;/code&gt; 요소가 포함 됩니다. &lt;code&gt;comp&lt;/code&gt; 가 가리키는 기능은 객체 비교에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9e30aead83f3eef8647ad87d7def4801f02a5d88" translate="yes" xml:space="preserve">
          <source>1) Struct definition: introduces the new type struct name and defines its meaning</source>
          <target state="translated">1) 구조 정의 : 새로운 유형의 구조체 이름을 소개하고 그 의미를 정의</target>
        </trans-unit>
        <trans-unit id="a19254646d106e1d346f8bd45aef0e905f2d5c30" translate="yes" xml:space="preserve">
          <source>1) Target for &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;.</source>
          <target state="translated">1) &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; 대상 .</target>
        </trans-unit>
        <trans-unit id="5ec6ad030a4e5dbc722f96475550b4194e003b4a" translate="yes" xml:space="preserve">
          <source>1) The &lt;code&gt;auto&lt;/code&gt; specifier is only allowed for objects declared at block scope (except function parameter lists). It indicates automatic storage duration and no linkage, which are the defaults for these kinds of declarations.</source>
          <target state="translated">1) &lt;code&gt;auto&lt;/code&gt; 지정자는 블록 범위에서 선언 된 객체에 대해서만 허용됩니다 (함수 매개 변수 목록 제외). 자동 저장 기간과 연결 없음을 나타내며 이러한 선언의 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="b050abed834e6886d7b9e8336d68084472c7912e" translate="yes" xml:space="preserve">
          <source>1) The arguments are evaluated &lt;a href=&quot;eval_order&quot;&gt;in unspecified order and without sequencing&lt;/a&gt;.</source>
          <target state="translated">1) 인수는 &lt;a href=&quot;eval_order&quot;&gt;지정되지 않은 순서로 시퀀싱없이&lt;/a&gt; 평가 됩니다 .</target>
        </trans-unit>
        <trans-unit id="9b9773880120c17001b80fa106a7e9df656c53a7" translate="yes" xml:space="preserve">
          <source>1) The exponent syntax for a decimal floating-point constant</source>
          <target state="translated">1) 십진 부동 소수점 상수의 지수 구문</target>
        </trans-unit>
        <trans-unit id="22eb595fe64321b5fa9b0a4672c1c5b9a50be3a0" translate="yes" xml:space="preserve">
          <source>1) The identifiers that are &lt;a href=&quot;../keyword&quot;&gt;keywords&lt;/a&gt; cannot be used for other purposes. In particular #define or #undef of an identifier that is identical to a keyword is not allowed.</source>
          <target state="translated">1) &lt;a href=&quot;../keyword&quot;&gt;키워드 인&lt;/a&gt; 식별자는 다른 용도로 사용할 수 없습니다. 특히 키워드와 동일한 식별자의 #define 또는 #undef는 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5115294268c974ed2fb60ba62aab8eb53bc8a7a1" translate="yes" xml:space="preserve">
          <source>1) The individual bytes of the source code file (which is generally a text file in some multibyte encoding such as UTF-8) are mapped, in implementation defined manner, to the characters of the</source>
          <target state="translated">1) 소스 코드 파일의 개별 바이트 (일반적으로 UTF-8과 같은 일부 멀티 바이트 인코딩의 텍스트 파일)는 구현에서 정의 된 방식으로</target>
        </trans-unit>
        <trans-unit id="d4c77a85b0f493d9a1f3abe2e195f0681a4d812a" translate="yes" xml:space="preserve">
          <source>1) The length of the null-terminated byte string &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">1) 널 종료 바이트 문자열 &lt;code&gt;str&lt;/code&gt; 의 길이 .</target>
        </trans-unit>
        <trans-unit id="f83e99ba442596269803061a06189dbc53399520" translate="yes" xml:space="preserve">
          <source>1) The length of the null-terminated wide string &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">1) 널 종료 와이드 스트링 &lt;code&gt;str&lt;/code&gt; 의 길이 .</target>
        </trans-unit>
        <trans-unit id="a084cdd2239b71155ebdd96ca5239a8cad4333f2" translate="yes" xml:space="preserve">
          <source>1) The number of parameters must equal the number of arguments (unless the ellipsis parameter is used).</source>
          <target state="translated">1) 생략 부호 매개 변수를 사용하지 않는 한 매개 변수의 수는 인수의 수와 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="68af2515487778be00d587b192cce547fe709ce4" translate="yes" xml:space="preserve">
          <source>1) The source file is decomposed into &lt;a href=&quot;../comment&quot;&gt;comments&lt;/a&gt;, sequences of whitespace characters (space, horizontal tab, new-line, vertical tab, and form-feed), and</source>
          <target state="translated">1) 소스 파일은 &lt;a href=&quot;../comment&quot;&gt;주석&lt;/a&gt; , 일련의 공백 문자 (공백, 가로 탭, 줄 바꿈, 세로 탭 및 용지 공급) 로 분해 되고</target>
        </trans-unit>
        <trans-unit id="1804f540be0df55334d3972f03fe91f9cf90ba1c" translate="yes" xml:space="preserve">
          <source>1) There is a sequence point after the evaluation of all function arguments and of the function designator, and before the actual function call.</source>
          <target state="translated">1) 모든 함수 인수와 함수 지정자의 평가 후 및 실제 함수 호출 전에 시퀀스 포인트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5dbd9a12935e34ab227f492e5b9bc1ac950dbdab" translate="yes" xml:space="preserve">
          <source>1) Use as a type specifier; this designates a new atomic type</source>
          <target state="translated">1) 형식 지정자로 사용하십시오. 이것은 새로운 원자 유형을 지정합니다</target>
        </trans-unit>
        <trans-unit id="226dddaf427d6d8e2424ad6d2b508917703a9bff" translate="yes" xml:space="preserve">
          <source>1) Whenever backslash appears at the end of a line (immediately followed by the newline character), both backslash and newline are deleted, combining two physical source lines into one logical source line. This is a single-pass operation: a line ending in two backslashes followed by an empty line does not combine three lines into one.</source>
          <target state="translated">1) 줄 끝에 백 슬래시가 나타날 때마다 (즉시 줄 바꿈 문자 바로 뒤에) 백 슬래시와 줄 바꿈이 모두 삭제되어 두 개의 실제 소스 행이 하나의 논리 소스 행으로 결합됩니다. 이것은 단일 패스 작업입니다. 두 개의 백 슬래시로 끝나고 빈 줄이 오는 줄은 세 줄을 하나로 결합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="487a5bbea51ecfc00ee95a9593427dda69554210" translate="yes" xml:space="preserve">
          <source>1) Writes the results to &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">1) 결과를 &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; 에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="d3f29720e18edb0e19950e4a194d25091ae7befb" translate="yes" xml:space="preserve">
          <source>1) Writes the results to the output stream &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">1) 결과를 출력 스트림 &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; 에 기록 합니다.</target>
        </trans-unit>
        <trans-unit id="19aef5c6e3a8340b10f8c1cbe62faa12cf60c919" translate="yes" xml:space="preserve">
          <source>1) a &lt;a href=&quot;function_declaration&quot;&gt;function without a prototype&lt;/a&gt;</source>
          <target state="translated">1) &lt;a href=&quot;function_declaration&quot;&gt;프로토 타입이없는 기능&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="25dca83efb65c8bd4e04da09f3580ec3bfb3c378" translate="yes" xml:space="preserve">
          <source>1) addition: lhs and rhs must be one of the following</source>
          <target state="translated">1) 추가 : lhs 및 rhs는 다음 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="abeb32c1f3640410888ad60b7c9db0d4e2b48273" translate="yes" xml:space="preserve">
          <source>1) address of a function</source>
          <target state="translated">1) 기능의 주소</target>
        </trans-unit>
        <trans-unit id="40a8653a0d3236909f145d472c49940dd109766a" translate="yes" xml:space="preserve">
          <source>1) as soon as atomic operations that are not tagged &lt;code&gt;memory_order_seq_cst&lt;/code&gt; enter the picture, the sequential consistency is lost</source>
          <target state="translated">1) &lt;code&gt;memory_order_seq_cst&lt;/code&gt; 태그가없는 원자 연산이 그림에 들어가 자마자 순차 일관성이 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="cb41c99c432b78323d4f377b74a0c397256353fa" translate="yes" xml:space="preserve">
          <source>1) bitwise NOT</source>
          <target state="translated">1) 비트 NOT</target>
        </trans-unit>
        <trans-unit id="a5c4eb068ddbed14cdec7bfed116012173c4eb9f" translate="yes" xml:space="preserve">
          <source>1) character string identifying the value of the environmental variable or null pointer if such variable is not found.</source>
          <target state="translated">1) 환경 변수의 값을 식별하는 문자열 또는 그러한 변수가 없으면 널 포인터.</target>
        </trans-unit>
        <trans-unit id="bcd432da28db454a04c5521200c0c8acca5a755e" translate="yes" xml:space="preserve">
          <source>1) compound statements</source>
          <target state="translated">1) 복합 진술</target>
        </trans-unit>
        <trans-unit id="25e76c36e2ae3683079592703d839a13a3ee3588" translate="yes" xml:space="preserve">
          <source>1) equal-to expression</source>
          <target state="translated">1) 등식</target>
        </trans-unit>
        <trans-unit id="8d9b8bd79df06297796e16e2b60bf3da31a61598" translate="yes" xml:space="preserve">
          <source>1) identifier appearing as the operand of a &lt;a href=&quot;goto&quot;&gt;goto statement&lt;/a&gt; is looked up in the label name space.</source>
          <target state="translated">1) 레이블 이름 공간에서 &lt;a href=&quot;goto&quot;&gt;goto 문의&lt;/a&gt; 피연산자로 나타나는 식별자를 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="0c39ad40da198d4086d01e5009475920ac42d80c" translate="yes" xml:space="preserve">
          <source>1) if the expressions have arithmetic type, the common type is the type after &lt;a href=&quot;conversion#Usual_arithmetic_conversions&quot;&gt;usual arithmetic conversions&lt;/a&gt;</source>
          <target state="translated">1) 표현식에 산술 유형이있는 경우 일반 유형은 &lt;a href=&quot;conversion#Usual_arithmetic_conversions&quot;&gt;일반적인 산술 변환&lt;/a&gt; 후 유형입니다.</target>
        </trans-unit>
        <trans-unit id="f08aa13ffd87bf5b57bd2b5c39f8fe2c531e8de4" translate="yes" xml:space="preserve">
          <source>1) left shift of lhs by rhs bits</source>
          <target state="translated">1) rhs 비트에 의한 lhs의 왼쪽 시프트</target>
        </trans-unit>
        <trans-unit id="5a4bee23927627b309d490ee1c564271b77131e0" translate="yes" xml:space="preserve">
          <source>1) less-than expression</source>
          <target state="translated">1)보다 적은 표현</target>
        </trans-unit>
        <trans-unit id="e67fda6fb2705cb05d8d8619b1774a9c81847f72" translate="yes" xml:space="preserve">
          <source>1) multiplication. lhs and rhs must have &lt;a href=&quot;arithmetic_types&quot;&gt;arithmetic types&lt;/a&gt;</source>
          <target state="translated">1) 곱셈. lhs 및 rhs는 &lt;a href=&quot;arithmetic_types&quot;&gt;산술 유형을&lt;/a&gt; 가져야 합니다</target>
        </trans-unit>
        <trans-unit id="4eeb5ca4abaf93d3cd3e7d468d8dcbd0091888b1" translate="yes" xml:space="preserve">
          <source>1) pointer to a static internal &lt;code&gt;&lt;a href=&quot;tm&quot;&gt;tm&lt;/a&gt;&lt;/code&gt; object on success, or null pointer otherwise. The structure may be shared between &lt;code&gt;&lt;a href=&quot;gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;localtime&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ctime&quot;&gt;ctime&lt;/a&gt;&lt;/code&gt; and may be overwritten on each invocation.</source>
          <target state="translated">1) 성공 하면 정적 내부 &lt;code&gt;&lt;a href=&quot;tm&quot;&gt;tm&lt;/a&gt;&lt;/code&gt; 객체에 대한 포인터, 그렇지 않으면 null 포인터. 구조는 &lt;code&gt;&lt;a href=&quot;gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;localtime&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ctime&quot;&gt;ctime&lt;/a&gt;&lt;/code&gt; 간에 공유 될 수 있으며 각 호출에서 겹쳐 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77a22f2c003682c7542353884c5912023ee1cf14" translate="yes" xml:space="preserve">
          <source>1) pointer to a static internal &lt;code&gt;&lt;a href=&quot;tm&quot;&gt;tm&lt;/a&gt;&lt;/code&gt; object on success, or null pointer otherwise. The structure may be shared between &lt;code&gt;gmtime&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ctime&quot;&gt;ctime&lt;/a&gt;&lt;/code&gt; and may be overwritten on each invocation.</source>
          <target state="translated">1) 성공 하면 정적 내부 &lt;code&gt;&lt;a href=&quot;tm&quot;&gt;tm&lt;/a&gt;&lt;/code&gt; 객체에 대한 포인터, 그렇지 않으면 null 포인터. 구조는 &lt;code&gt;gmtime&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ctime&quot;&gt;ctime&lt;/a&gt;&lt;/code&gt; 간에 공유 될 수 있으며 각 호출에서 겹쳐 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfe7b906cc1ee9ec716b40da5b8700cad2d21f96" translate="yes" xml:space="preserve">
          <source>1) pointer to a static null-terminated character string holding the textual representation of date and time as described above. The string may be shared between &lt;code&gt;asctime&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ctime&quot;&gt;ctime&lt;/a&gt;&lt;/code&gt;, and may be overwritten on each invocation of any of those functions.</source>
          <target state="translated">1) 위에서 설명한대로 날짜 및 시간의 텍스트 표현을 보유한 정적 널 종료 문자열에 대한 포인터. 문자열은 &lt;code&gt;asctime&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;ctime&quot;&gt;ctime&lt;/a&gt;&lt;/code&gt; 간에 공유 될 수 있으며 해당 함수를 호출 할 때마다 덮어 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5095a6d20497cd3f302cda1fca918ff4048ce380" translate="yes" xml:space="preserve">
          <source>1) pointer to a static null-terminated character string holding the textual representation of date and time. The string may be shared between &lt;code&gt;asctime&lt;/code&gt; and &lt;code&gt;ctime&lt;/code&gt;, and may be overwritten on each invocation of any of those functions.</source>
          <target state="translated">1) 날짜 및 시간의 텍스트 표현을 보유한 정적 널 종료 문자열에 대한 포인터. 문자열은 &lt;code&gt;asctime&lt;/code&gt; 과 &lt;code&gt;ctime&lt;/code&gt; 간에 공유 될 수 있으며 해당 함수를 호출 할 때마다 덮어 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b1937df5d97d513eb74d968a764798b979f3a53" translate="yes" xml:space="preserve">
          <source>1) pointer to character string that describes the error</source>
          <target state="translated">1) 오류를 설명하는 문자열에 대한 포인터</target>
        </trans-unit>
        <trans-unit id="bbb123035f2a14d67a45da76c00c106d372e43aa" translate="yes" xml:space="preserve">
          <source>1) reads the data from &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 에서 데이터를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="a32798de36139374c63446cf3fe7120829db8365" translate="yes" xml:space="preserve">
          <source>1) returns a copy of &lt;code&gt;dest&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;dest&lt;/code&gt; 의 사본을 반환</target>
        </trans-unit>
        <trans-unit id="477c654e3248bdeac06ad1d32868d3f1f786932d" translate="yes" xml:space="preserve">
          <source>1) single-byte integer character constant, e.g. &lt;code&gt;'a'&lt;/code&gt; or &lt;code&gt;'\n'&lt;/code&gt; or &lt;code&gt;'\13'&lt;/code&gt;. Such constant has type &lt;code&gt;int&lt;/code&gt; and a value equal to the representation of c-char in the execution character set as a value of type &lt;code&gt;char&lt;/code&gt; mapped to &lt;code&gt;int&lt;/code&gt;. If c-char is not representable as a single byte in the execution character set, the value is implementation-defined.</source>
          <target state="translated">1) 단일 - 바이트 정수 문자 상수, 예를 들면 &lt;code&gt;'a'&lt;/code&gt; 또는 &lt;code&gt;'\n'&lt;/code&gt; 또는 &lt;code&gt;'\13'&lt;/code&gt; . 이러한 상수는 &lt;code&gt;int&lt;/code&gt; 유형 과 &lt;code&gt;int&lt;/code&gt; 에 매핑 된 &lt;code&gt;char&lt;/code&gt; 유형의 값으로 실행 문자 세트의 c-char 표현과 동일한 값을 갖습니다 . c-char가 실행 문자 세트에서 단일 바이트로 표현할 수없는 경우 값은 구현 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="90d1f78ed7461b36a81ff2b1ff2c9cbd3546c6c9" translate="yes" xml:space="preserve">
          <source>1) string literal initializer for character and wide character arrays</source>
          <target state="translated">1) 문자 및 넓은 문자 배열을위한 문자열 리터럴 이니셜 라이저</target>
        </trans-unit>
        <trans-unit id="0ee9168f93a2879767e08fcc412682b1be67da16" translate="yes" xml:space="preserve">
          <source>1) the identifier that this declarator introduces.</source>
          <target state="translated">1)이 선언자가 소개하는 식별자.</target>
        </trans-unit>
        <trans-unit id="a673b6776355a818d38cede9e48e75678c00f825" translate="yes" xml:space="preserve">
          <source>1) the ranks of all signed integer types are different and increase with their precision: rank of signed char &amp;lt; rank of short &amp;lt; rank of int &amp;lt; rank of long int &amp;lt; rank of long long int</source>
          <target state="translated">1) 부호있는 모든 정수 유형의 순위가 다르고 정밀도가 높아집니다. 부호있는 문자 순위 &amp;lt;짧은 순위 &amp;lt;int 순위 &amp;lt;long int &amp;lt;긴 long int 순위</target>
        </trans-unit>
        <trans-unit id="7d4fd8e6643d5e1207570d762ff147612f50ae1b" translate="yes" xml:space="preserve">
          <source>1) the result of the expression, unless it is zero</source>
          <target state="translated">1)식이 0이 아닌 경우의 결과</target>
        </trans-unit>
        <trans-unit id="bc5e060dc470b927342212aaafa0e89ac968357f" translate="yes" xml:space="preserve">
          <source>1) unary plus (promotion)</source>
          <target state="translated">1) 단항 플러스 (프로모션)</target>
        </trans-unit>
        <trans-unit id="b09518e8b5551fe4600062b1ecd5c385b61cd6df" translate="yes" xml:space="preserve">
          <source>1) value transformation (if applicable)</source>
          <target state="translated">1) 가치 변환 (해당되는 경우)</target>
        </trans-unit>
        <trans-unit id="9cbd2c90f862af5bbf15f0fdc461e461b24ed0e4" translate="yes" xml:space="preserve">
          <source>1)(C95) Character width: unset, narrow, or wide</source>
          <target state="translated">1) (C95) 문자 너비 : 설정되지 않거나 좁거나 넓음</target>
        </trans-unit>
        <trans-unit id="544586f3a0a092f5bbcec5cdc6560837e125403e" translate="yes" xml:space="preserve">
          <source>1)&lt;a href=&quot;../preprocessor&quot;&gt;Preprocessor&lt;/a&gt; is executed.</source>
          <target state="translated">1) &lt;a href=&quot;../preprocessor&quot;&gt;전처리 기가&lt;/a&gt; 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="459d93416f3a7fe456f375bc9904e3600ac24151" translate="yes" xml:space="preserve">
          <source>1)&lt;a href=&quot;break&quot;&gt;break&lt;/a&gt; statement</source>
          <target state="translated">1) &lt;a href=&quot;break&quot;&gt;브레이크&lt;/a&gt; 선언</target>
        </trans-unit>
        <trans-unit id="f89dbd79f4d8971ec3ac21b786416f808a4baaaa" translate="yes" xml:space="preserve">
          <source>1)&lt;a href=&quot;if&quot;&gt;if&lt;/a&gt; statement</source>
          <target state="translated">1) &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt; 문</target>
        </trans-unit>
        <trans-unit id="07b8e9b9816b30735de981a2880084a892285189" translate="yes" xml:space="preserve">
          <source>1)&lt;a href=&quot;static_storage_duration&quot;&gt;static&lt;/a&gt;&lt;code&gt;volatile&lt;/code&gt; objects model memory-mapped I/O ports, and &lt;code&gt;static&lt;/code&gt;&lt;code&gt;const&lt;/code&gt;&lt;code&gt;volatile&lt;/code&gt; objects model memory-mapped input ports, such as a real-time clock:</source>
          <target state="translated">1) &lt;a href=&quot;static_storage_duration&quot;&gt;정적 &lt;/a&gt; &lt;code&gt;volatile&lt;/code&gt; 객체는 메모리 매핑 된 I / O 포트를 모델링 하고 &lt;code&gt;static&lt;/code&gt; &lt;code&gt;const&lt;/code&gt; &lt;code&gt;volatile&lt;/code&gt; 객체는 실시간 클럭과 같은 메모리 매핑 된 입력 포트를 모델링합니다.</target>
        </trans-unit>
        <trans-unit id="fe435b6509bb017cac34a34cd990555811ddde06" translate="yes" xml:space="preserve">
          <source>1)&lt;a href=&quot;while&quot;&gt;while&lt;/a&gt; loop</source>
          <target state="translated">1) &lt;a href=&quot;while&quot;&gt;while&lt;/a&gt; 루프</target>
        </trans-unit>
        <trans-unit id="6bc629d6e02fd75040100ba65f909e806582a43e" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;filename&lt;/code&gt; if &lt;code&gt;filename&lt;/code&gt; was not a null pointer. Otherwise a pointer to an internal static buffer is returned. If no suitable filename can be generated, null pointer is returned.</source>
          <target state="translated">1) &lt;code&gt;filename&lt;/code&gt; 이 &lt;code&gt;filename&lt;/code&gt; 이 널 포인터가 아닌 경우 filename . 그렇지 않으면 내부 정적 버퍼에 대한 포인터가 리턴됩니다. 적합한 파일 이름을 생성 할 수 없으면 널 포인터가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="ce15eef362e478877c8e3611aa792c5988df605f" translate="yes" xml:space="preserve">
          <source>1,2) General array declarator syntax</source>
          <target state="translated">1,2) 일반 배열 선언자 구문</target>
        </trans-unit>
        <trans-unit id="f9a36e8936e92662180ea3acf2c3df7b18f6e4d3" translate="yes" xml:space="preserve">
          <source>1,2) Number of wide characters written if successful or negative value if an error occurred.</source>
          <target state="translated">1,2) 성공시 기록 된 와이드 문자 수 또는 오류 발생시 음수 값.</target>
        </trans-unit>
        <trans-unit id="ba43862f88a88267f3ece2ce7c3f4a09d0e5698c" translate="yes" xml:space="preserve">
          <source>1,2) number of characters transmitted to the output stream or negative value if an output error or an encoding error (for string and character conversion specifiers) occurred</source>
          <target state="translated">1,2) 출력 스트림으로 전송 된 문자 수 또는 출력 오류 또는 인코딩 오류 (문자열 및 문자 변환 지정자)가 발생한 경우 음수 값</target>
        </trans-unit>
        <trans-unit id="0fb3c464483c04558978ff1fe117799e7f6c93e2" translate="yes" xml:space="preserve">
          <source>1-3) Composes a floating point value with the magnitude of &lt;code&gt;x&lt;/code&gt; and the sign of &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">1-3) &lt;code&gt;x&lt;/code&gt; 의 크기 와 &lt;code&gt;y&lt;/code&gt; 의 부호로 부동 소수점 값을 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="fcde828507f9f6058ae73d6cd3b2b9026e0f50ef" translate="yes" xml:space="preserve">
          <source>1-3) Computes 2 raised to the given power &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">1-3) 주어진 전력 &lt;code&gt;n&lt;/code&gt; 으로 올린 2를 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="0b10a66a66532d88bb36cf5fe638ed44244ef518" translate="yes" xml:space="preserve">
          <source>1-3) Computes &lt;code&gt;(x*y) + z&lt;/code&gt; as if to infinite precision and rounded only once to fit the result type.</source>
          <target state="translated">1-3) 무한 정밀도 인 것처럼 &lt;code&gt;(x*y) + z&lt;/code&gt; 를 계산 하고 결과 유형에 맞게 한 번만 반올림합니다.</target>
        </trans-unit>
        <trans-unit id="391463a3800cd96169a13d8b4dece9dae4d27979" translate="yes" xml:space="preserve">
          <source>1-3) Computes complex arc hyperbolic cosine of a complex value &lt;code&gt;z&lt;/code&gt; with branch cut at values less than 1 along the real axis.</source>
          <target state="translated">1-3) 실수 축을 따라 1보다 작은 값으로 분기 절단 된 복소수 값 &lt;code&gt;z&lt;/code&gt; 의 복소 아크 쌍곡 코사인을 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="33d189527983196a05f8badc2ce605f47898ef16" translate="yes" xml:space="preserve">
          <source>1-3) Computes hyperbolic sine of &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="translated">1-3) &lt;code&gt;arg&lt;/code&gt; 의 쌍곡 사인을 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="31768a26b0bb7d42a533db6c8b10df547bfd7cdc" translate="yes" xml:space="preserve">
          <source>1-3) Computes square root of &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="translated">1-3) &lt;code&gt;arg&lt;/code&gt; 의 제곱근을 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="28ec09da0b6641bd12fea6733e03810bd776a300" translate="yes" xml:space="preserve">
          <source>1-3) Computes the</source>
          <target state="translated">1-3) 계산</target>
        </trans-unit>
        <trans-unit id="16ce8bee01b9891d115239a7477107ac295d8027" translate="yes" xml:space="preserve">
          <source>1-3) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Complementary_error_function&quot;&gt;complementary error function&lt;/a&gt; of &lt;code&gt;arg&lt;/code&gt;, that is &lt;code&gt;1.0-erf(arg)&lt;/code&gt;, but without loss of precision for large &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="translated">1-3)를 계산 &lt;a href=&quot;https://en.wikipedia.org/wiki/Complementary_error_function&quot;&gt;상보 오차 함수&lt;/a&gt; 의 &lt;code&gt;arg&lt;/code&gt; , 즉 &lt;code&gt;1.0-erf(arg)&lt;/code&gt; , 그러나 큰 정밀도의 손실없이 &lt;code&gt;arg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a46bba6cb124ad9fac9c675733896ed48e0f9cca" translate="yes" xml:space="preserve">
          <source>1-3) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Complex_conjugate&quot;&gt;complex conjugate&lt;/a&gt; of &lt;code&gt;z&lt;/code&gt; by reversing the sign of the imaginary part.</source>
          <target state="translated">1-3) 허수 부의 부호를 바꾸어 &lt;code&gt;z&lt;/code&gt; 의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Complex_conjugate&quot;&gt;복소 공액&lt;/a&gt; 을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="97251e58129990d405a20b926849ead40fb0049e" translate="yes" xml:space="preserve">
          <source>1-3) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Error_function&quot;&gt;error function&lt;/a&gt; of &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="translated">1-3) &lt;code&gt;arg&lt;/code&gt; 의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Error_function&quot;&gt;오류 함수&lt;/a&gt; 를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="f537c5d69e850d077ca503d3ae6dc365cd7f23e0" translate="yes" xml:space="preserve">
          <source>1-3) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Gamma_function&quot;&gt;gamma function&lt;/a&gt; of &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="translated">1-3) &lt;code&gt;arg&lt;/code&gt; 의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Gamma_function&quot;&gt;감마 함수&lt;/a&gt; 를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="06fb2522f313d7443f8ff5ed057df67c62229bb0" translate="yes" xml:space="preserve">
          <source>1-3) Computes the IEEE remainder of the floating point division operation &lt;code&gt;x/y&lt;/code&gt;.</source>
          <target state="translated">1-3) 부동 소수점 나누기 연산 &lt;code&gt;x/y&lt;/code&gt; 의 IEEE 나머지를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="be3d24e66d81f8bbcc04cf24d5cb3c0f59f63fb1" translate="yes" xml:space="preserve">
          <source>1-3) Computes the absolute value of a floating point value &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="translated">1-3) 부동 소수점 값 &lt;code&gt;arg&lt;/code&gt; 의 절대 값을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="c81dd03c2b6fc6f836c4d892752e7e2ab9381fd1" translate="yes" xml:space="preserve">
          <source>1-3) Computes the arc tangent of &lt;code&gt;y/x&lt;/code&gt; using the signs of arguments to determine the correct quadrant.</source>
          <target state="translated">1-3) 올바른 사분면을 결정하기 위해 인수 부호를 사용하여 &lt;code&gt;y/x&lt;/code&gt; 의 아크 탄젠트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="06750d9cc7c32e7e6bfcfcbafd570e2cc591f0fd" translate="yes" xml:space="preserve">
          <source>1-3) Computes the argument (also called phase angle) of &lt;code&gt;z&lt;/code&gt;, with a branch cut along the negative real axis.</source>
          <target state="translated">1-3) 음의 실수 축을 따라 브랜치 컷을 사용하여 &lt;code&gt;z&lt;/code&gt; 의 인수 (위상 각도라고도 함)를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="ee5f36ceb4351ae31b628964437c4ea71c05d2af" translate="yes" xml:space="preserve">
          <source>1-3) Computes the base &lt;code&gt;2&lt;/code&gt; logarithm of &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="translated">1-3) &lt;code&gt;arg&lt;/code&gt; 의 밑이 &lt;code&gt;2&lt;/code&gt; 인 로그를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="5c8f047806cca3758bc70d1feb8b6bd1e2f2df15" translate="yes" xml:space="preserve">
          <source>1-3) Computes the common (base-</source>
          <target state="translated">1-3) 공통을 계산합니다 (기본-</target>
        </trans-unit>
        <trans-unit id="60333cf3aa9043e0315748ab7e2b62403e94f0ed" translate="yes" xml:space="preserve">
          <source>1-3) Computes the complex absolute value (also known as norm, modulus, or magnitude) of &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">1-3) &lt;code&gt;z&lt;/code&gt; 의 복소 절대 값 (표준, 모듈러스 또는 크기라고도 함)을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="b24df078afb55898bc4d0378e599aed92d5acbb0" translate="yes" xml:space="preserve">
          <source>1-3) Computes the complex arc cosine of &lt;code&gt;z&lt;/code&gt; with branch cuts outside the interval [&amp;minus;1,+1] along the real axis.</source>
          <target state="translated">1-3) 실수 축을 따라 [-1, + 1] 간격을 벗어난 분기 컷 으로 &lt;code&gt;z&lt;/code&gt; 의 복소수 코사인을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="ac2e2376f4a51f777c7892ba6ae4d3e81638bf93" translate="yes" xml:space="preserve">
          <source>1-3) Computes the complex arc hyperbolic sine of &lt;code&gt;z&lt;/code&gt; with branch cuts outside the interval [&amp;minus;i; +i] along the imaginary axis.</source>
          <target state="translated">1-3) 구간 [-i] 밖에서 브랜치 컷을 사용 하여 &lt;code&gt;z&lt;/code&gt; 의 복소 아크 쌍곡 사인을 계산합니다 . + i] 가상 축을 따라.</target>
        </trans-unit>
        <trans-unit id="c6da26ae6668a03fcc7355b5d6b740f8da661f51" translate="yes" xml:space="preserve">
          <source>1-3) Computes the complex arc hyperbolic tangent of &lt;code&gt;z&lt;/code&gt; with branch cuts outside the interval [&amp;minus;1; +1] along the real axis.</source>
          <target state="translated">1-3) 구간 [-1에서 벗어난 가지 컷 으로 &lt;code&gt;z&lt;/code&gt; 의 복소 아크 쌍곡 탄젠트를 계산합니다 . 실제 축을 따라 +1].</target>
        </trans-unit>
        <trans-unit id="cec456ea00710068c385ca571810a82e406902f8" translate="yes" xml:space="preserve">
          <source>1-3) Computes the complex arc sine of &lt;code&gt;z&lt;/code&gt; with branch cuts outside the interval [&amp;minus;1,+1] along the real axis.</source>
          <target state="translated">1-3) 실수 축을 따라 [-1, + 1] 간격을 벗어난 분기 컷 으로 &lt;code&gt;z&lt;/code&gt; 의 복소수 아크 사인을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="ddec1cfe87aa90c715aba4048b304433c0c7acf0" translate="yes" xml:space="preserve">
          <source>1-3) Computes the complex arc tangent of &lt;code&gt;z&lt;/code&gt; with branch cuts outside the interval [&amp;minus;i,+i] along the imaginary axis.</source>
          <target state="translated">1-3) 가상 축을 따라 간격 [-i, + i] 외부에서 브랜치 컷을 사용 하여 &lt;code&gt;z&lt;/code&gt; 의 복소 아크 탄젠트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="37a5f4e8ee29f4770c1b428a6ae1e2af970549f0" translate="yes" xml:space="preserve">
          <source>1-3) Computes the complex base-</source>
          <target state="translated">1-3) 복소수베이스 계산</target>
        </trans-unit>
        <trans-unit id="2a4970febdd81e1ce65fb63d9d4255a5d110644c" translate="yes" xml:space="preserve">
          <source>1-3) Computes the complex cosine of &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">1-3) &lt;code&gt;z&lt;/code&gt; 의 복소 코사인을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="91fb694afb20262940799c2898a8f8fe0462b8a6" translate="yes" xml:space="preserve">
          <source>1-3) Computes the complex hyperbolic cosine of &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">1-3) &lt;code&gt;z&lt;/code&gt; 의 복합 쌍곡 코사인을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="71ffa777c19ae6318370f72b88388f1c5cdd336b" translate="yes" xml:space="preserve">
          <source>1-3) Computes the complex hyperbolic sine of &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">1-3) &lt;code&gt;z&lt;/code&gt; 의 복합 쌍곡 사인을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="6e454b759ec87b387a40ce69ac1d6e4d3c51d742" translate="yes" xml:space="preserve">
          <source>1-3) Computes the complex hyperbolic tangent of &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">1-3) &lt;code&gt;z&lt;/code&gt; 의 복소 쌍곡 탄젠트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="d6525555de756109fec8457d147c2a5ecb28dd84" translate="yes" xml:space="preserve">
          <source>1-3) Computes the complex natural (base-</source>
          <target state="translated">1-3) 복합 자연 계산 (기본</target>
        </trans-unit>
        <trans-unit id="b424a84895d56e8650a908d854526b42620a89c8" translate="yes" xml:space="preserve">
          <source>1-3) Computes the complex power function xy</source>
          <target state="translated">1-3) 복소수 전력 함수 xy 계산</target>
        </trans-unit>
        <trans-unit id="6db3670778af6b7d6734a660afcf51674b73a868" translate="yes" xml:space="preserve">
          <source>1-3) Computes the complex sine of &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">1-3) &lt;code&gt;z&lt;/code&gt; 의 복소 사인을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="463f874ab13935fe53826f00eb409464a609d5f0" translate="yes" xml:space="preserve">
          <source>1-3) Computes the complex square root of &lt;code&gt;z&lt;/code&gt; with branch cut along the negative real axis.</source>
          <target state="translated">1-3) 음의 실수 축을 따라 분기 절단 된 &lt;code&gt;z&lt;/code&gt; 의 복소 제곱근을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="5ff4551aadbb7748533181ffadb04f2a88602bb3" translate="yes" xml:space="preserve">
          <source>1-3) Computes the complex tangent of &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">1-3) &lt;code&gt;z&lt;/code&gt; 의 복소 탄젠트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="65d8a20bcbf6a9507496a6f8360d5d0ce58b7891" translate="yes" xml:space="preserve">
          <source>1-3) Computes the cosine of &lt;code&gt;arg&lt;/code&gt; (measured in radians).</source>
          <target state="translated">1-3) &lt;code&gt;arg&lt;/code&gt; 의 코사인을 계산합니다 (라디안 단위로 측정).</target>
        </trans-unit>
        <trans-unit id="0a04ca7b947ef0432a97ce2c9c9402dd97bf3715" translate="yes" xml:space="preserve">
          <source>1-3) Computes the cubic root of &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="translated">1-3) &lt;code&gt;arg&lt;/code&gt; 의 세제곱근을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="7fecb384f372f5695adad30217b637f35cd1f434" translate="yes" xml:space="preserve">
          <source>1-3) Computes the floating-point remainder of the division operation &lt;code&gt;x/y&lt;/code&gt; as the &lt;code&gt;&lt;a href=&quot;remainder&quot;&gt;remainder()&lt;/a&gt;&lt;/code&gt; function does. Additionally, the sign and at least the three of the last bits of &lt;code&gt;x/y&lt;/code&gt; will be stored in &lt;code&gt;quo&lt;/code&gt;, sufficient to determine the octant of the result within a period.</source>
          <target state="translated">1-3) &lt;code&gt;&lt;a href=&quot;remainder&quot;&gt;remainder()&lt;/a&gt;&lt;/code&gt; 함수 와 같이 나누기 연산 &lt;code&gt;x/y&lt;/code&gt; 의 부동 소수점 나머지를 계산합니다 . 또한, 기호 및 마지막 비트의 적어도 세 개의 &lt;code&gt;x/y&lt;/code&gt; 저장한다 &lt;code&gt;quo&lt;/code&gt; 이내에 결과의 팔분의를 결정하기에 충분.</target>
        </trans-unit>
        <trans-unit id="da7e6ba39e7925b467e308b04f0b0774e301062b" translate="yes" xml:space="preserve">
          <source>1-3) Computes the floating-point remainder of the division operation &lt;code&gt;x/y&lt;/code&gt;.</source>
          <target state="translated">1-3) 나누기 연산 &lt;code&gt;x/y&lt;/code&gt; 의 나머지 부동 소수점을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="4ca94a69ba418098c40a0bd9ebaead1ba5b3073e" translate="yes" xml:space="preserve">
          <source>1-3) Computes the hyperbolic cosine of &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="translated">1-3) &lt;code&gt;arg&lt;/code&gt; 의 쌍곡 코사인을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="fae7a10dc4f39ad3a3c3ccc7d443ba77adec426c" translate="yes" xml:space="preserve">
          <source>1-3) Computes the hyperbolic tangent of &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="translated">1-3) &lt;code&gt;arg&lt;/code&gt; 의 쌍곡 탄젠트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="75dd9fa119e02d6efb8298dc297ba4d969160f1d" translate="yes" xml:space="preserve">
          <source>1-3) Computes the inverse hyperbolic cosine of &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="translated">1-3) &lt;code&gt;arg&lt;/code&gt; 의 역 쌍곡 코사인을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="834472b18c2a6549ef22068e323b56d7df86c118" translate="yes" xml:space="preserve">
          <source>1-3) Computes the inverse hyperbolic sine of &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="translated">1-3) &lt;code&gt;arg&lt;/code&gt; 의 역 쌍곡 사인을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="061964416b59b2bac46fda851482e538336e320e" translate="yes" xml:space="preserve">
          <source>1-3) Computes the inverse hyperbolic tangent of &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="translated">1-3) &lt;code&gt;arg&lt;/code&gt; 의 역 쌍곡 탄젠트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="2ff20a5ce239fd62c651f7088bfbe37c43a76e82" translate="yes" xml:space="preserve">
          <source>1-3) Computes the largest integer value not greater than &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="translated">1-3) &lt;code&gt;arg&lt;/code&gt; 보다 크지 않은 가장 큰 정수 값을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="ca11cec96c81f740aceb07d08e88e13130955fa0" translate="yes" xml:space="preserve">
          <source>1-3) Computes the natural (base</source>
          <target state="translated">1-3) 자연 계산 (기본</target>
        </trans-unit>
        <trans-unit id="26586ed25b8bd539d8e17dd4231ade0054ffa519" translate="yes" xml:space="preserve">
          <source>1-3) Computes the natural (base &lt;code&gt;e&lt;/code&gt;) logarithm of &lt;code&gt;1+arg&lt;/code&gt;. This function is more precise than the expression &lt;code&gt;&lt;a href=&quot;log&quot;&gt;log&lt;/a&gt;(1+arg)&lt;/code&gt; if &lt;code&gt;arg&lt;/code&gt; is close to zero.</source>
          <target state="translated">1-3) &lt;code&gt;1+arg&lt;/code&gt; 의 자연 (기수 &lt;code&gt;e&lt;/code&gt; ) 로그를 계산합니다 . &lt;code&gt;arg&lt;/code&gt; 가 0에 가까우 면 이 함수는 표현식 &lt;code&gt;&lt;a href=&quot;log&quot;&gt;log&lt;/a&gt;(1+arg)&lt;/code&gt; (1 + arg) 보다 정확 합니다.</target>
        </trans-unit>
        <trans-unit id="78bc85fc60cecfd077905bc98c8fc75c8b80e9fe" translate="yes" xml:space="preserve">
          <source>1-3) Computes the natural logarithm of the absolute value of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Gamma_function&quot;&gt;gamma function&lt;/a&gt; of &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="translated">1-3) &lt;code&gt;arg&lt;/code&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Gamma_function&quot;&gt;감마 함수&lt;/a&gt; 의 절대 값에 대한 자연 로그를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="e5f87e9d17da829e68c77738b3536c97f08431e1" translate="yes" xml:space="preserve">
          <source>1-3) Computes the nearest integer not greater in magnitude than &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="translated">1-3) &lt;code&gt;arg&lt;/code&gt; 보다 크지 않은 가장 가까운 정수를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="592c69fdc8890478a9283f23c8d6cc4832e08a4d" translate="yes" xml:space="preserve">
          <source>1-3) Computes the nearest integer value to &lt;code&gt;arg&lt;/code&gt; (in floating-point format), rounding halfway cases away from zero, regardless of the current rounding mode.</source>
          <target state="translated">1-3) 현재 반올림 모드와 상관없이 반올림 사례를 0에서 반올림 하여 가장 가까운 정수 값을 &lt;code&gt;arg&lt;/code&gt; (부동 소수점 형식 )로 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="b724fc6b26effea7849a37c77bd9f1fe241356f1" translate="yes" xml:space="preserve">
          <source>1-3) Computes the principal value of the arc cosine of &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="translated">1-3) &lt;code&gt;arg&lt;/code&gt; 의 아크 코사인의 주요 값을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="cd335a4b19869242d7cc1ccd4742edeb1d4ef287" translate="yes" xml:space="preserve">
          <source>1-3) Computes the principal value of the arc tangent of &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="translated">1-3) &lt;code&gt;arg&lt;/code&gt; 의 아크 탄젠트의 주요 값을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="d87acf2ae3c76490381c676082b3142a86102f61" translate="yes" xml:space="preserve">
          <source>1-3) Computes the principal values of the arc sine of &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="translated">1-3) &lt;code&gt;arg&lt;/code&gt; 의 아크 사인의 주요 값을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="540ed8dff7dce27f5ba2b71c411a0a9f2e83888a" translate="yes" xml:space="preserve">
          <source>1-3) Computes the projection of &lt;code&gt;z&lt;/code&gt; on the Riemann sphere.</source>
          <target state="translated">1-3) 리만 구체 에서 &lt;code&gt;z&lt;/code&gt; 의 투영을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="234a4abe0e39e12e87ad70ddc22021c4aa7f7aa8" translate="yes" xml:space="preserve">
          <source>1-3) Computes the sine of &lt;code&gt;arg&lt;/code&gt; (measured in radians).</source>
          <target state="translated">1-3) &lt;code&gt;arg&lt;/code&gt; 의 사인 값을 계산합니다 (라디안 단위로 측정).</target>
        </trans-unit>
        <trans-unit id="38ca1671920427cd5061c6d3d3e1596c6b200aee" translate="yes" xml:space="preserve">
          <source>1-3) Computes the smallest integer value not less than &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="translated">1-3) &lt;code&gt;arg&lt;/code&gt; 이상의 최소 정수 값을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="52fe3cd1edb0f6f4d94f1a5135012afcaf3f8eb9" translate="yes" xml:space="preserve">
          <source>1-3) Computes the square root of the sum of the squares of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, without undue overflow or underflow at intermediate stages of the computation.</source>
          <target state="translated">1-3) 계산의 중간 단계에서 과도한 오버플로 또는 언더 플로없이 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 제곱의 합의 제곱근을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="acf8ca598ce6912683ef9734a50ee2d61d8080d8" translate="yes" xml:space="preserve">
          <source>1-3) Computes the tangent of &lt;code&gt;arg&lt;/code&gt; (measured in radians).</source>
          <target state="translated">1-3) &lt;code&gt;arg&lt;/code&gt; 의 탄젠트를 계산합니다 (라디안 단위로 측정).</target>
        </trans-unit>
        <trans-unit id="8d8a16fc976c2ce1f472177c04c6a89b2269086f" translate="yes" xml:space="preserve">
          <source>1-3) Computes the value of &lt;code&gt;base&lt;/code&gt; raised to the power &lt;code&gt;exponent&lt;/code&gt;.</source>
          <target state="translated">1-3) &lt;code&gt;exponent&lt;/code&gt; 제곱으로 올린 &lt;code&gt;base&lt;/code&gt; 값을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="3326fd3d52ccf4e6f3ae199343f9af675f7cc378" translate="yes" xml:space="preserve">
          <source>1-3) Decomposes given floating point value &lt;code&gt;arg&lt;/code&gt; into integral and fractional parts, each having the same type and sign as &lt;code&gt;arg&lt;/code&gt;. The integral part (in floating-point format) is stored in the object pointed to by &lt;code&gt;iptr&lt;/code&gt;.</source>
          <target state="translated">1-3) 포인트 값 분해 부동 주어진 &lt;code&gt;arg&lt;/code&gt; 각각 동일한 종류 및 기호 갖는 적분 소수부로 &lt;code&gt;arg&lt;/code&gt; . 정수 부분 (부동 소수점 형식)은 &lt;code&gt;iptr&lt;/code&gt; 이 가리키는 오브젝트에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="c0545ff1914e5ab464e273d829249e18ec123846" translate="yes" xml:space="preserve">
          <source>1-3) Decomposes given floating point value &lt;code&gt;x&lt;/code&gt; into a normalized fraction and an integral power of two.</source>
          <target state="translated">1-3) 주어진 부동 소수점 값 &lt;code&gt;x&lt;/code&gt; 를 정규화 된 분수와 2의 정수로 분해 합니다.</target>
        </trans-unit>
        <trans-unit id="582c6b5e653a5d4a4058e4cabe9c009bd17e9fb4" translate="yes" xml:space="preserve">
          <source>1-3) Extracts the value of the unbiased exponent from the floating-point argument &lt;code&gt;arg&lt;/code&gt;, and returns it as a signed integer value.</source>
          <target state="translated">1-3) 부동 소수점 인수 &lt;code&gt;arg&lt;/code&gt; 에서 바이어스되지 않은 지수 값을 추출하여 부호있는 정수 값으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9e3866612d444afc9e9ee7f5249625e36cd8bec3" translate="yes" xml:space="preserve">
          <source>1-3) Extracts the value of the unbiased radix-independent exponent from the floating-point argument &lt;code&gt;arg&lt;/code&gt;, and returns it as a floating-point value.</source>
          <target state="translated">1-3) 부동 소수점 인수 &lt;code&gt;arg&lt;/code&gt; 에서 바이어스되지 않은 기수 독립 지수의 값을 추출하여 부동 소수점 값으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="11bff0857ca7525ca5d6d04cceca75ebbb2b5a41" translate="yes" xml:space="preserve">
          <source>1-3) First, converts both arguments to the type of the function, then returns the next representable value of &lt;code&gt;from&lt;/code&gt; in the direction of &lt;code&gt;to&lt;/code&gt;. If &lt;code&gt;from&lt;/code&gt; equals to &lt;code&gt;to&lt;/code&gt;, &lt;code&gt;to&lt;/code&gt; is returned.</source>
          <target state="translated">1-3) 우선,이 함수의 형태로 두 인수로 변환 한 후, 다음의 표현 가능한 값을 반환 &lt;code&gt;from&lt;/code&gt; 의 방향 &lt;code&gt;to&lt;/code&gt; . 경우 &lt;code&gt;from&lt;/code&gt; 같음에 &lt;code&gt;to&lt;/code&gt; , &lt;code&gt;to&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3de14fd604ef8c418f13c96f962a1934c50a0a99" translate="yes" xml:space="preserve">
          <source>1-3) Multiplies a floating point value &lt;code&gt;arg&lt;/code&gt; by the number 2 raised to the &lt;code&gt;exp&lt;/code&gt; power.</source>
          <target state="translated">1-3) 부동 소수점 값 &lt;code&gt;arg&lt;/code&gt; 에 &lt;code&gt;exp&lt;/code&gt; 2를 곱한 숫자를 곱합니다 .</target>
        </trans-unit>
        <trans-unit id="b12ba0f21ec633604f7832d9e78142004b2a572f" translate="yes" xml:space="preserve">
          <source>1-3) Number of receiving arguments successfully assigned (which may be zero in case a matching failure occurred before the first receiving argument was assigned), or &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; if input failure occurs before the first receiving argument was assigned.</source>
          <target state="translated">1-3) 성공적으로 할당 된 수신 인수의 수 (첫 번째 수신 인수가 지정되기 전에 일치하는 실패가 발생한 경우 0 일 수 있음) 또는 첫 번째 수신 인수가 지정되기 전에 입력 실패가 발생한 경우 &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bcec5083366c8d916b1a40bb3f845c6c8f65772c" translate="yes" xml:space="preserve">
          <source>1-3) Number of receiving arguments successfully assigned, or &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; if read failure occurs before the first receiving argument was assigned.</source>
          <target state="translated">1-3) 성공적으로 할당 된 수신 인수 수 또는 첫 수신 인수가 할당되기 전에 읽기 실패가 발생한 경우 &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="085575d166af0ee114a59aad1964f0d2c9534f64" translate="yes" xml:space="preserve">
          <source>1-3) Returns the imaginary part of &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">1-3) &lt;code&gt;z&lt;/code&gt; 의 허수 부분을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="30511373a100b70eedd0984e5b99b132d27cf88b" translate="yes" xml:space="preserve">
          <source>1-3) Returns the larger of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen).</source>
          <target state="translated">1-3) NaN을 누락 된 데이터로 처리하여 NaN과 숫자 값 사이에서 숫자 값이 선택되는 두 개의 부동 소수점 인수 중 큰 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="aea61ec34824bf54b309b57e957c3428d8a0fa6e" translate="yes" xml:space="preserve">
          <source>1-3) Returns the positive difference between &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, that is, if &lt;code&gt;x&amp;gt;y&lt;/code&gt;, returns &lt;code&gt;x-y&lt;/code&gt;, otherwise (if &lt;code&gt;x&amp;le;y&lt;/code&gt;), returns +0.</source>
          <target state="translated">1-3) &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 사이의 양의 차이를 반환합니다 . 즉, &lt;code&gt;x&amp;gt;y&lt;/code&gt; 인 경우 &lt;code&gt;x-y&lt;/code&gt; 반환하고 , 그렇지 않으면 ( &lt;code&gt;x&amp;le;y&lt;/code&gt; 인 경우 ) +0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dd0804951b688b9038680ca365aba91fb289b8d8" translate="yes" xml:space="preserve">
          <source>1-3) Returns the real part of &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">1-3) &lt;code&gt;z&lt;/code&gt; 의 실수 부분을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="04a0ed18e69adafddaac5f84f47894523c5ceaf1" translate="yes" xml:space="preserve">
          <source>1-3) Returns the smaller of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen).</source>
          <target state="translated">1-3) NaN을 누락 된 데이터로 처리하여 NaN과 숫자 값 사이에서 숫자 값이 선택되는 두 개의 부동 소수점 인수 중 작은 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="abbd4d43d5a4a4562512e8a550b98d9521bfa824" translate="yes" xml:space="preserve">
          <source>1-3) Rounds the floating-point argument &lt;code&gt;arg&lt;/code&gt; to an integer value in floating-point format, using the &lt;a href=&quot;../fenv/fe_round&quot;&gt;current rounding mode&lt;/a&gt;.</source>
          <target state="translated">1-3) &lt;a href=&quot;../fenv/fe_round&quot;&gt;현재 반올림 모드를&lt;/a&gt; 사용하여 부동 소수점 인수 &lt;code&gt;arg&lt;/code&gt; 를 부동 소수점 형식의 정수 값으로 반올림합니다 .</target>
        </trans-unit>
        <trans-unit id="d5eb4d19e2ca8f567034661421c8fea195af14d1" translate="yes" xml:space="preserve">
          <source>1-3) Rounds the floating-point argument &lt;code&gt;arg&lt;/code&gt; to an integer value in floating-point format, using the current rounding mode.</source>
          <target state="translated">1-3) 현재 반올림 모드를 사용하여 부동 소수점 인수 &lt;code&gt;arg&lt;/code&gt; 를 부동 소수점 형식의 정수 값으로 반올림합니다.</target>
        </trans-unit>
        <trans-unit id="2d6f62f499427c6405dbc2607cdf66cf2360b35d" translate="yes" xml:space="preserve">
          <source>1-3) The number of characters written if successful or negative value if an error occurred.</source>
          <target state="translated">1-3) 성공한 경우 쓰여진 문자 수 또는 오류가 발생한 경우 음수 값.</target>
        </trans-unit>
        <trans-unit id="772c27656100ecc244e49c0a4400d3b22af70b85" translate="yes" xml:space="preserve">
          <source>1-3) The number of wide characters written if successful or negative value if an error occurred.</source>
          <target state="translated">1-3) 성공한 경우 기록 된 와이드 문자 수 또는 오류가 발생한 경우 음수 값.</target>
        </trans-unit>
        <trans-unit id="678e921e8a67c0205096966f4f3946cfea18d860" translate="yes" xml:space="preserve">
          <source>1-3,5-7) Multiplies a floating point value &lt;code&gt;arg&lt;/code&gt; by &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;FLT_RADIX&lt;/a&gt;&lt;/code&gt; raised to power &lt;code&gt;exp&lt;/code&gt;.</source>
          <target state="translated">1-3,5-7) 부동 소수점 곱셈 값 &lt;code&gt;arg&lt;/code&gt; 의해 &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;FLT_RADIX&lt;/a&gt;&lt;/code&gt; 는 전력을 발생 &lt;code&gt;exp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8dd6cc8534c457c984670f2dc8ec666ffd306890" translate="yes" xml:space="preserve">
          <source>1.6 DEFINITIONS OF TERMS</source>
          <target state="translated">1.6 용어의 정의</target>
        </trans-unit>
        <trans-unit id="6a3196d4803ac7d8544b7deb8f961dda2634d8cf" translate="yes" xml:space="preserve">
          <source>1.6 Definitions of terms</source>
          <target state="translated">1.6 용어의 정의</target>
        </trans-unit>
        <trans-unit id="55fe8c9dad930630cf239af507c3ba46a832c1c4" translate="yes" xml:space="preserve">
          <source>1.7 Compliance</source>
          <target state="translated">1.7 준수</target>
        </trans-unit>
        <trans-unit id="b1d5781111d84f7b3fe45a0852e59758cd7a87e5" translate="yes" xml:space="preserve">
          <source>10</source>
          <target state="translated">10</target>
        </trans-unit>
        <trans-unit id="761c7d9564da680efcd56d0447d489c0f65429ab" translate="yes" xml:space="preserve">
          <source>10&amp;ndash;13</source>
          <target state="translated">10&amp;ndash;13</target>
        </trans-unit>
        <trans-unit id="d59099024c16138c9a6bd83c7561d5c5ddabb8f7" translate="yes" xml:space="preserve">
          <source>10(arg) or lg(arg)) is returned.</source>
          <target state="translated">10 (arg) 또는 lg (arg))가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="14c2aefa1a30429da9ef973aa865f36df58777f1" translate="yes" xml:space="preserve">
          <source>1024 macro identifiers simultaneously defined in one preprocessing translation unit</source>
          <target state="translated">하나의 전처리 번역 단위에 동시에 정의 된 1024 개의 매크로 식별자</target>
        </trans-unit>
        <trans-unit id="358e3e257d91345963ad9b9cf5abf2fa4957d9b9" translate="yes" xml:space="preserve">
          <source>103&amp;ndash;122</source>
          <target state="translated">103&amp;ndash;122</target>
        </trans-unit>
        <trans-unit id="17ba0791499db908433b80f37c5fbc89b870084b" translate="yes" xml:space="preserve">
          <source>11</source>
          <target state="translated">11</target>
        </trans-unit>
        <trans-unit id="7b52009b64fd0a2a49e6d8a939753077792b0554" translate="yes" xml:space="preserve">
          <source>12</source>
          <target state="translated">12</target>
        </trans-unit>
        <trans-unit id="d57a1b91b05af98b51640f6b9c68c46e24ce46aa" translate="yes" xml:space="preserve">
          <source>123&amp;ndash;126</source>
          <target state="translated">123&amp;ndash;126</target>
        </trans-unit>
        <trans-unit id="008451a05e1e7aa32c75119df950d405265e0904" translate="yes" xml:space="preserve">
          <source>127</source>
          <target state="translated">127</target>
        </trans-unit>
        <trans-unit id="abf2223d2057fbddb0a77ca7deae766518c549b4" translate="yes" xml:space="preserve">
          <source>127 identifiers with block scope declared in one block</source>
          <target state="translated">한 블록에 선언 된 블록 범위를 가진 127 개의 식별자</target>
        </trans-unit>
        <trans-unit id="bd307a3ec329e10a2cff8fb87480823da114f8f4" translate="yes" xml:space="preserve">
          <source>13</source>
          <target state="translated">13</target>
        </trans-unit>
        <trans-unit id="2b76195c910d81ae1ae417ba1c3fe23e28cfc96f" translate="yes" xml:space="preserve">
          <source>14&amp;ndash;31</source>
          <target state="translated">14&amp;ndash;31</target>
        </trans-unit>
        <trans-unit id="1f951f0262f343dfbac4797f73cfa1288934f1a8" translate="yes" xml:space="preserve">
          <source>14&lt;sup id=&quot;cite_ref-4&quot;&gt;&lt;a href=&quot;operator_precedence#cite_note-4&quot;&gt;[note 4]&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">14 &lt;sup id=&quot;cite_ref-4&quot;&gt;&lt;a href=&quot;operator_precedence#cite_note-4&quot;&gt;[주 4]&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="f1abd670358e036c31296e66b3b66c382ac00812" translate="yes" xml:space="preserve">
          <source>15</source>
          <target state="translated">15</target>
        </trans-unit>
        <trans-unit id="1574bddb75c78a6fd2251d61e2993b5146201319" translate="yes" xml:space="preserve">
          <source>16</source>
          <target state="translated">16</target>
        </trans-unit>
        <trans-unit id="2dfe9ee4a3855461ae1cacf808d8866abcd2538a" translate="yes" xml:space="preserve">
          <source>16-bit wide character type</source>
          <target state="translated">16 비트 와이드 문자 유형</target>
        </trans-unit>
        <trans-unit id="da4b9237bacccdf19c0760cab7aec4a8359010b0" translate="yes" xml:space="preserve">
          <source>2</source>
          <target state="translated">2</target>
        </trans-unit>
        <trans-unit id="22db22f450e69ca5b0810cc1a70e1fc7de838404" translate="yes" xml:space="preserve">
          <source>2(arg) or lb(arg)) is returned.</source>
          <target state="translated">2 (arg) 또는 lb (arg))가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4c4c353359e293b69b3f655b6bbdd1f9ae0de720" translate="yes" xml:space="preserve">
          <source>2) 16-bit wide character constant, e.g. &lt;code&gt;u'貓'&lt;/code&gt;, but not &lt;code&gt;u'🍌'&lt;/code&gt; (&lt;code&gt;u'\U0001f34c'&lt;/code&gt;). Such constant has type &lt;code&gt;char16_t&lt;/code&gt; and a value equal to the value of c-char in the 16-bit encoding produced by &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbrtoc16&quot;&gt;mbrtoc16&lt;/a&gt;&lt;/code&gt; (normally UTF-16). If c-char is not representable or maps to more than one 16-bit character, the behavior is implementation-defined.</source>
          <target state="translated">2) 16 비트 와이드 문자 상수, 예를 들어 &lt;code&gt;u'貓'&lt;/code&gt; 이지만 &lt;code&gt;u'🍌'&lt;/code&gt; ( &lt;code&gt;u'\U0001f34c'&lt;/code&gt; )는 아닙니다 . 이러한 상수는 &lt;code&gt;char16_t&lt;/code&gt; 유형 과 &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbrtoc16&quot;&gt;mbrtoc16&lt;/a&gt;&lt;/code&gt; (일반적으로 UTF-16)에 의해 생성 된 16 비트 인코딩의 c-char 값과 동일한 값을 갖습니다 . c-char를 표현할 수 없거나 하나 이상의 16 비트 문자에 매핑되면 동작이 구현 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="f70da394bcbd77532392273d7c1d439bf45f54dc" translate="yes" xml:space="preserve">
          <source>2) All external identifiers that begin with an underscore.</source>
          <target state="translated">2) 밑줄로 시작하는 모든 외부 식별자.</target>
        </trans-unit>
        <trans-unit id="7f44984da5db1fd60cd2103f4527f0231f2ca221" translate="yes" xml:space="preserve">
          <source>2) Allows</source>
          <target state="translated">2) 허용</target>
        </trans-unit>
        <trans-unit id="b3173e9a7b43519646112843dc09948bc06417bb" translate="yes" xml:space="preserve">
          <source>2) Also changes the current preprocessor file name to filename. Occurrences of the macro &lt;code&gt;__FILE__&lt;/code&gt; beyond this point will produce filename.</source>
          <target state="translated">2) 또한 현재 전 처리기 파일 이름을 filename으로 변경합니다. 이 시점을 넘어 매크로 &lt;code&gt;__FILE__&lt;/code&gt; 이 발생 하면 파일 이름이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="083501d5f7cc6d6983a2c593fdbddfdc67ca236c" translate="yes" xml:space="preserve">
          <source>2) Attempts to copy the full contents of the floating-point exception flags that are listed in &lt;code&gt;excepts&lt;/code&gt; from &lt;code&gt;flagp&lt;/code&gt; into the floating-point environment. Does not raise any exceptions, only modifies the flags.</source>
          <target state="translated">2) &lt;code&gt;flagp&lt;/code&gt; 에서 부동 소수점 환경으로 &lt;code&gt;excepts&lt;/code&gt; 하고 나열된 부동 소수점 예외 플래그의 전체 내용을 복사하려고 시도 합니다. 예외를 발생시키지 않고 플래그 만 수정합니다.</target>
        </trans-unit>
        <trans-unit id="0a19fca90a0f81d74089d60ea91bdf0afa94f79d" translate="yes" xml:space="preserve">
          <source>2) Attempts to establish the floating-point environment from the object pointed to by &lt;code&gt;envp&lt;/code&gt;. The value of that object must be previously obtained by a call to &lt;code&gt;&lt;a href=&quot;feholdexcept&quot;&gt;feholdexcept&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;fegetenv&lt;/code&gt; or be a floating-point macro constant. If any of the floating-point status flags are set in &lt;code&gt;envp&lt;/code&gt;, they become set in the environment (and are then testable with &lt;code&gt;&lt;a href=&quot;fetestexcept&quot;&gt;fetestexcept&lt;/a&gt;&lt;/code&gt;), but the corresponding floating-point exceptions are not raised (execution continues uninterrupted).</source>
          <target state="translated">2) &lt;code&gt;envp&lt;/code&gt; 가 가리키는 객체에서 부동 소수점 환경을 설정하려고 시도합니다 . 해당 객체의 값은 &lt;code&gt;&lt;a href=&quot;feholdexcept&quot;&gt;feholdexcept&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;fegetenv&lt;/code&gt; 를 호출 하거나 부동 소수점 매크로 상수 로 미리 얻어야합니다 . 부동 소수점 상태 플래그가 &lt;code&gt;envp&lt;/code&gt; 에 설정되어 있으면 환경에서 설정되고 &lt;code&gt;&lt;a href=&quot;fetestexcept&quot;&gt;fetestexcept&lt;/a&gt;&lt;/code&gt; 로 테스트 가능 하지만 해당 부동 소수점 예외는 발생하지 않습니다 (실행은 중단되지 않고 계속됩니다).</target>
        </trans-unit>
        <trans-unit id="dc5b38c01f0d2e9890fdc3240aa88a05f30b5277" translate="yes" xml:space="preserve">
          <source>2) Buffering state: unbuffered, line-buffered, fully buffered.</source>
          <target state="translated">2) 버퍼링 상태 : 버퍼링되지 않은, 라인 버퍼링 된, 완전히 버퍼링 된.</target>
        </trans-unit>
        <trans-unit id="70a6e6ec90420e7617673a3ac63c6be00fe3b14d" translate="yes" xml:space="preserve">
          <source>2) Case label in a &lt;a href=&quot;switch&quot;&gt;switch&lt;/a&gt; statement.</source>
          <target state="translated">2) &lt;a href=&quot;switch&quot;&gt;스위치&lt;/a&gt; 명세서 에 케이스 라벨 .</target>
        </trans-unit>
        <trans-unit id="446b2488707cc7ce466c1e9b5b324d510325b6ab" translate="yes" xml:space="preserve">
          <source>2) Complete object type capable of holding a flag used by &lt;code&gt;call_once&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;call_once&lt;/code&gt; 가 사용하는 플래그를 보유 할 수있는 완전한 객체 유형</target>
        </trans-unit>
        <trans-unit id="4ffcf24e33caf6947e48d30d4201e7f2f800017e" translate="yes" xml:space="preserve">
          <source>2) Each comment is replaced by one space character</source>
          <target state="translated">2) 각 주석은 하나의 공백 문자로 대체됩니다</target>
        </trans-unit>
        <trans-unit id="bef04165f115d32e32dc4b99b87d1f943101dfc4" translate="yes" xml:space="preserve">
          <source>2) Each file introduced with the &lt;a href=&quot;../preprocessor/include&quot;&gt;#include&lt;/a&gt; directive goes through phases 1 through 4, recursively.</source>
          <target state="translated">2) &lt;a href=&quot;../preprocessor/include&quot;&gt;#include&lt;/a&gt; 지시문으로 소개 된 각 파일은 1 단계부터 4 단계까지 반복적으로 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="e00104b2d04dbc49da52f100fe09e59879a7e788" translate="yes" xml:space="preserve">
          <source>2) Expands to a value suitable for use as the &lt;code&gt;base&lt;/code&gt; argument of &lt;code&gt;timespec_get&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;timespec_get&lt;/code&gt; 의 &lt;code&gt;base&lt;/code&gt; 인수 로 사용하기에 적합한 값으로 확장</target>
        </trans-unit>
        <trans-unit id="2bb1605234570f393885f9095b3262520a63ff6e" translate="yes" xml:space="preserve">
          <source>2) If a non-empty source file does not end with a newline character after this step (whether it had no newline originally, or it ended with a backslash), the behavior is undefined.</source>
          <target state="translated">2) 비어 있지 않은 소스 파일이이 단계 후에 줄 바꿈 문자로 끝나지 않는 경우 (원래 줄 바꿈이 없었거나 백 슬래시로 끝나 든), 동작은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="671eacb6c5d2dd8a71c7f3d193d6d2c821222ba3" translate="yes" xml:space="preserve">
          <source>2) If a side effect on a scalar object is unsequenced relative to a value computation using the value of the same scalar object, the behavior is undefined.</source>
          <target state="translated">2) 동일한 스칼라 오브젝트의 값을 사용한 값 계산과 관련하여 스칼라 오브젝트의 부작용이 순서가 지정되지 않으면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9991b91e1b202d1bc33494aacea89cdd7f63d384" translate="yes" xml:space="preserve">
          <source>2) If successful, returns zero and a pointer to the new file stream is written to &lt;code&gt;*streamptr&lt;/code&gt;. On error, returns a non-zero error code and writes the null pointer to &lt;code&gt;*streamptr&lt;/code&gt; (unless &lt;code&gt;streamptr&lt;/code&gt; is a null pointer itself).</source>
          <target state="translated">2) 성공하면 0을 리턴하고 새 파일 스트림에 대한 포인터가 &lt;code&gt;*streamptr&lt;/code&gt; 에 기록됩니다 . 오류가 발생하면 0이 아닌 오류 코드를 리턴하고 널 포인터를 &lt;code&gt;*streamptr&lt;/code&gt; 에 씁니다 ( &lt;code&gt;streamptr&lt;/code&gt; 이 널 포인터 자체가 아닌 경우 ).</target>
        </trans-unit>
        <trans-unit id="e18efc1f713f7ceda7e0acfb4464d1dc211a15a4" translate="yes" xml:space="preserve">
          <source>2) If the result of condition compares unequal to zero, executes expression-true, otherwise executes expression-false</source>
          <target state="translated">2) 조건 결과가 0과 같지 않으면 expression-true를 실행하고, 그렇지 않으면 expression-false를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="2434d5537665839e1e637279076d6e391b0851ce" translate="yes" xml:space="preserve">
          <source>2) If the return type of the main function is &lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;compatible&lt;/a&gt; with &lt;code&gt;int&lt;/code&gt;, then the return from the initial call to main (but not the return from any subsequent, recursive, call) is equivalent to executing the &lt;code&gt;&lt;a href=&quot;../program/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; function, with the value that the main function is returning passed as the argument (which then calls the functions registered with &lt;code&gt;&lt;a href=&quot;../program/atexit&quot;&gt;atexit&lt;/a&gt;&lt;/code&gt;, flushes and closes all streams, and deletes the files created with &lt;code&gt;&lt;a href=&quot;../io/tmpfile&quot;&gt;tmpfile&lt;/a&gt;&lt;/code&gt;, and returns control to the execution environment).</source>
          <target state="translated">2) 메인 함수의 반환 유형이 &lt;code&gt;int&lt;/code&gt; 와 &lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;호환&lt;/a&gt; 되는 경우 초기 호출에서 메인으로의 리턴 (그러나 후속, 재귀 호출에서 리턴되지 않음)은 &lt;code&gt;&lt;a href=&quot;../program/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; 함수 를 실행하는 것과 같습니다 . main 함수는 인수로 전달되어 리턴됩니다 (그런 다음 &lt;code&gt;&lt;a href=&quot;../program/atexit&quot;&gt;atexit&lt;/a&gt;&lt;/code&gt; 에 등록 된 함수를 호출하고 모든 스트림을 플러시 및 닫고 &lt;code&gt;&lt;a href=&quot;../io/tmpfile&quot;&gt;tmpfile&lt;/a&gt;&lt;/code&gt; 로 작성된 파일을 삭제 한 후 실행 환경으로 제어를 리턴 함).</target>
        </trans-unit>
        <trans-unit id="591949fd8b4069ee4a35d387975513f7fdff49a5" translate="yes" xml:space="preserve">
          <source>2) If used on a line of its own, as in &lt;code&gt;struct&lt;/code&gt;name&lt;code&gt;;&lt;/code&gt;,</source>
          <target state="translated">2) &lt;code&gt;struct&lt;/code&gt; name 과 같이 자체 라인에 사용될 경우 &lt;code&gt;;&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="c83ffd5a998b69365207954c7598a5459bff3467" translate="yes" xml:space="preserve">
          <source>2) Octal integer constant (base 8, the first digit is the most significant).</source>
          <target state="translated">2) 8 진 정수 상수 (기수 8, 첫 번째 숫자가 가장 중요).</target>
        </trans-unit>
        <trans-unit id="14e556c2bbc89528d34020b0e1e9d25e48e71a8f" translate="yes" xml:space="preserve">
          <source>2) Often known as &quot;C++-style&quot; or &quot;single-line&quot; comments.</source>
          <target state="translated">2) &quot;C ++ 스타일&quot;또는 &quot;한 줄&quot;주석이라고도합니다.</target>
        </trans-unit>
        <trans-unit id="e116306f4d4c3b4ff13b695d397cbcd60b0538d7" translate="yes" xml:space="preserve">
          <source>2) Old-style (K&amp;amp;R) function declaration. This declaration does not behave as a prototype and any future &lt;a href=&quot;operator_other#Function_call&quot;&gt;function call expressions&lt;/a&gt; will perform default argument promotions and will invoke undefined behavior if the number of arguments doesn't match the number of parameters.</source>
          <target state="translated">2) 구식 (K &amp;amp; R) 함수 선언. 이 선언은 프로토 타입으로 작동하지 않으며 향후 &lt;a href=&quot;operator_other#Function_call&quot;&gt;함수 호출 표현식&lt;/a&gt; 은 기본 인수 승격을 수행하고 인수 수가 매개 변수 수와 일치하지 않으면 정의되지 않은 동작을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="44c9d7e381e39cd9f77710a9c451d0fd24bc4bb5" translate="yes" xml:space="preserve">
          <source>2) Old-style (K&amp;amp;R) function definition. This definition does not behave as a prototype and any future &lt;a href=&quot;operator_other#Function_call&quot;&gt;function call expressions&lt;/a&gt; will perform default argument promotions.</source>
          <target state="translated">2) 구식 (K &amp;amp; R) 기능 정의. 이 정의는 프로토 타입으로 작동하지 않으며 향후 &lt;a href=&quot;operator_other#Function_call&quot;&gt;함수 호출 표현식&lt;/a&gt; 은 기본 인수 승격을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="4db7c3f8481b8975142752ee194ebec2642413f6" translate="yes" xml:space="preserve">
          <source>2) Otherwise, if one operand is &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;double &lt;a href=&quot;../numeric/complex/complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;double &lt;a href=&quot;../numeric/complex/imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt;, the other operand is implicitly converted as follows:</source>
          <target state="translated">2) 그렇지 않으면, 한 피연산자가 &lt;code&gt;double&lt;/code&gt; , &lt;code&gt;double &lt;a href=&quot;../numeric/complex/complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;double &lt;a href=&quot;../numeric/complex/imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt; 인 경우 다른 피연산자는 다음과 같이 내재적으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="50e3bb676a81f74576a8c24566dd3ab974745007" translate="yes" xml:space="preserve">
          <source>2) Reads characters from &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; until a newline is found or end-of-file occurs. Writes only at most &lt;code&gt;n-1&lt;/code&gt; characters into the array pointed to by &lt;code&gt;str&lt;/code&gt;, and always writes the terminating null character (unless str is a null pointer). The newline character, if found, is discarded and does not count toward the number of characters written to the buffer.</source>
          <target state="translated">2) 줄 바꿈이 발견되거나 파일 끝이 발생할 때까지 &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 에서 문자를 읽습니다 . &lt;code&gt;str&lt;/code&gt; 이 가리키는 배열 에 최대 &lt;code&gt;n-1&lt;/code&gt; 개의 문자 만 쓰고 str은 null 포인터가 아닌 한 항상 종료 null 문자를 씁니다. 줄 바꿈 문자가 있으면 버리고 버퍼에 쓴 문자 수에는 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ba089e56c0fe260a3393a9b9d292f9ecbfc2dd36" translate="yes" xml:space="preserve">
          <source>2) Reads the data from file stream &lt;code&gt;stream&lt;/code&gt;</source>
          <target state="translated">2) 파일 스트림 &lt;code&gt;stream&lt;/code&gt; 에서 데이터를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="4d1bc2ff6d34ef1f0cddd654c6245002d15bfb4c" translate="yes" xml:space="preserve">
          <source>2) Reads the data from file stream &lt;code&gt;stream&lt;/code&gt;.</source>
          <target state="translated">2) 파일 스트림 &lt;code&gt;stream&lt;/code&gt; 에서 데이터를 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="dd9f271c706cf05a945ce84f304cab17f33c436b" translate="yes" xml:space="preserve">
          <source>2) Removes the encoding prefix (if any), the outer quotes, and leading/trailing whitespace from string-literal, replaces each &lt;code&gt;\&quot;&lt;/code&gt; with &lt;code&gt;&quot;&lt;/code&gt; and each &lt;code&gt;\\&lt;/code&gt; with &lt;code&gt;\&lt;/code&gt;, then tokenizes the result (as in &lt;a href=&quot;../language/translation_phases&quot;&gt;translation stage 3&lt;/a&gt;), and then uses the result as if the input to &lt;code&gt;#pragma&lt;/code&gt; in (1).</source>
          <target state="translated">2) 문자열 리터럴에서 인코딩 접두어 (있는 경우), 외부 따옴표 및 선행 / 후행 공백을 제거하고 각 &lt;code&gt;\&quot;&lt;/code&gt; 를 &lt;code&gt;&quot;&lt;/code&gt; 로 바꾸고 각 &lt;code&gt;\\&lt;/code&gt; 를 &lt;code&gt;\&lt;/code&gt; 로 바꾸고 결과를 토큰 화합니다 ( &lt;a href=&quot;../language/translation_phases&quot;&gt;번역 단계 3&lt;/a&gt; 에서와 같이 ). (1)에서 &lt;code&gt;#pragma&lt;/code&gt; 에 입력 한 것처럼 결과를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="d7f98971954fa5439a7d5ca2b49c4b1dd4aad016" translate="yes" xml:space="preserve">
          <source>2) Returns the size, in bytes, of the object representation of the type of expression. No implicit conversions are applied to expression.</source>
          <target state="translated">2) 표현식 유형의 오브젝트 표시 크기 (바이트)를 리턴합니다. 암시 적 변환은 식에 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3c4c5b3f78da8fb3e6f9ea941221ca29db87dd90" translate="yes" xml:space="preserve">
          <source>2) Returns the value of the &lt;a href=&quot;fe_round&quot;&gt;floating-point rounding macro&lt;/a&gt; that corresponds to the current rounding direction.</source>
          <target state="translated">2) 현재 반올림 방향에 해당하는 &lt;a href=&quot;fe_round&quot;&gt;부동 소수점 반올림 매크로&lt;/a&gt; 의 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="3edd1107b68ee88c5c26098f2177c3f8c4535128" translate="yes" xml:space="preserve">
          <source>2) Returns zero and writes the file name to &lt;code&gt;filename_s&lt;/code&gt; on success. On error, returns non-zero and writes the null character to &lt;code&gt;filename_s[0]&lt;/code&gt; (only if &lt;code&gt;filename_s&lt;/code&gt; is not null and &lt;code&gt;maxsize&lt;/code&gt; is not zero and is not greater than &lt;code&gt;RSIZE_MAX&lt;/code&gt;).</source>
          <target state="translated">2) 성공 하면 0을 반환하고 파일 이름을 &lt;code&gt;filename_s&lt;/code&gt; 에 씁니다 . 오류가 발생하면 0이 아닌 값을 반환하고 null 문자를 &lt;code&gt;filename_s[0]&lt;/code&gt; 씁니다 ( &lt;code&gt;filename_s&lt;/code&gt; 가 null 이 아니고 &lt;code&gt;maxsize&lt;/code&gt; 가 0이 아니고 &lt;code&gt;RSIZE_MAX&lt;/code&gt; 보다 크지 않은 경우 에만 ).</target>
        </trans-unit>
        <trans-unit id="6bd2623ce7b54ff7d6e16f87f58330cc2c44a526" translate="yes" xml:space="preserve">
          <source>2) Returns zero on success (in which case the number of bytes excluding terminating zero that were, or would be written to &lt;code&gt;dst&lt;/code&gt;, is stored in &lt;code&gt;*retval&lt;/code&gt;), non-zero on error. In case of a runtime constraint violation, stores &lt;code&gt;(&lt;a href=&quot;../../types/size_t&quot;&gt;size_t&lt;/a&gt;)-1&lt;/code&gt; in &lt;code&gt;*retval&lt;/code&gt; (unless &lt;code&gt;retval&lt;/code&gt; is null) and sets &lt;code&gt;dst[0]&lt;/code&gt; to &lt;code&gt;'\0'&lt;/code&gt; (unless &lt;code&gt;dst&lt;/code&gt; is null or &lt;code&gt;dstmax&lt;/code&gt; is zero or greater than &lt;code&gt;RSIZE_MAX&lt;/code&gt;)</source>
          <target state="translated">2) 성공하면 0을 리턴하고 (이 경우 &lt;code&gt;dst&lt;/code&gt; 에 기록되거나 종료되는 0을 제외한 바이트 수는 &lt;code&gt;*retval&lt;/code&gt; 에 저장 됨 ), 0이 아닌 오류를 리턴합니다 . 런타임 제한 조건 위반의 경우, &lt;code&gt;(&lt;a href=&quot;../../types/size_t&quot;&gt;size_t&lt;/a&gt;)-1&lt;/code&gt; &lt;code&gt;retval&lt;/code&gt; 이 널이 아닌 한) &lt;code&gt;*retval&lt;/code&gt; 에 ( size_t ) -1 을 저장 하고 &lt;code&gt;dst[0]&lt;/code&gt; 을 &lt;code&gt;'\0'&lt;/code&gt; ( &lt;code&gt;dst&lt;/code&gt; 가 널이거나 &lt;code&gt;dstmax&lt;/code&gt; 가 0이거나 &lt;code&gt;RSIZE_MAX&lt;/code&gt; 보다 크지 않은 경우 )</target>
        </trans-unit>
        <trans-unit id="50c39314a085c823d92699a0d70cce3a7fa99684" translate="yes" xml:space="preserve">
          <source>2) Returns zero on success and non-zero on failure, in which case, &lt;code&gt;s[0]&lt;/code&gt; is set to &lt;code&gt;'\0'&lt;/code&gt; (unless &lt;code&gt;s&lt;/code&gt; is null or &lt;code&gt;ssz&lt;/code&gt; is zero or greater than &lt;code&gt;RSIZE_MAX&lt;/code&gt;) and &lt;code&gt;*retval&lt;/code&gt; is set to &lt;code&gt;(&lt;a href=&quot;../../types/size_t&quot;&gt;size_t&lt;/a&gt;)-1&lt;/code&gt; (unless &lt;code&gt;retval&lt;/code&gt; is null)</source>
          <target state="translated">2) 성공하면 0을, 실패하면 0이 아닌 값을 반환합니다.이 경우 &lt;code&gt;s[0]&lt;/code&gt; 은 &lt;code&gt;'\0'&lt;/code&gt; 설정되고 ( &lt;code&gt;s&lt;/code&gt; 가 null이거나 &lt;code&gt;ssz&lt;/code&gt; 가 0이거나 &lt;code&gt;RSIZE_MAX&lt;/code&gt; 보다 크지 않은 경우 ) &lt;code&gt;*retval&lt;/code&gt; 이 &lt;code&gt;(&lt;a href=&quot;../../types/size_t&quot;&gt;size_t&lt;/a&gt;)-1&lt;/code&gt; 설정 되지 않은 경우 ) ) -1 ( &lt;code&gt;retval&lt;/code&gt; 이 null이 아닌 경우 )</target>
        </trans-unit>
        <trans-unit id="b9767b04c84b00d4c16686db56f4924326cbcd49" translate="yes" xml:space="preserve">
          <source>2) Returns zero on success and non-zero value on error. Also on error, if &lt;code&gt;dest&lt;/code&gt; is not a null pointer and &lt;code&gt;destsz&lt;/code&gt; is valid, writes &lt;code&gt;destsz&lt;/code&gt; zero bytes in to the destination array.</source>
          <target state="translated">2) 성공시 0을, 에러시 0이 아닌 값을 반환합니다. 또한 오류가 발생하면 &lt;code&gt;dest&lt;/code&gt; 가 널 포인터가 아니고 &lt;code&gt;destsz&lt;/code&gt; 가 유효한 경우 대상 배열에 &lt;code&gt;destsz&lt;/code&gt; 0 바이트를 씁니다 .</target>
        </trans-unit>
        <trans-unit id="114b6bf255d5ee91a58e10aafdbd3c1edfe36420" translate="yes" xml:space="preserve">
          <source>2) Returns zero on success, returns non-zero on error. Also, on error, fills the entire &lt;code&gt;dst&lt;/code&gt; up to and not including &lt;code&gt;dst+dstsz&lt;/code&gt; with null wide characters, &lt;code&gt;L'\0'&lt;/code&gt; (unless &lt;code&gt;dest&lt;/code&gt; is null or &lt;code&gt;destsz&lt;/code&gt; is greater than &lt;code&gt;RSIZE_MAX/sizeof(wchar_t)&lt;/code&gt;)</source>
          <target state="translated">2) 성공하면 0을 반환하고, 에러이면 0이 아닌 값을 반환합니다. 또한 오류가 발생하면 &lt;code&gt;dst+dstsz&lt;/code&gt; 를 포함하지 않고 널 와이드 문자 &lt;code&gt;L'\0'&lt;/code&gt; 까지 전체 &lt;code&gt;dst&lt;/code&gt; 를 채 웁니다 ( &lt;code&gt;dest&lt;/code&gt; 가 null이거나 &lt;code&gt;destsz&lt;/code&gt; 가 &lt;code&gt;RSIZE_MAX/sizeof(wchar_t)&lt;/code&gt; 보다 큰 경우 제외 )</target>
        </trans-unit>
        <trans-unit id="547a8c34339f669a1dac34bd53ab4623d04ba24f" translate="yes" xml:space="preserve">
          <source>2) Same as (1), except that</source>
          <target state="translated">2) (1)과 동일하지만</target>
        </trans-unit>
        <trans-unit id="2f6fb0385742aaebea3aa43a2c7f716b6222a2c8" translate="yes" xml:space="preserve">
          <source>2) Same as (1), except that &lt;code&gt;mode&lt;/code&gt; is treated as in &lt;code&gt;fopen_s&lt;/code&gt; and that the pointer to the file stream is written to &lt;code&gt;newstreamptr&lt;/code&gt; and the following errors are detected at runtime and call the currently installed &lt;a href=&quot;../error/set_constraint_handler_s&quot;&gt;constraint handler&lt;/a&gt; function:</source>
          <target state="translated">2) &lt;code&gt;mode&lt;/code&gt; 가 &lt;code&gt;fopen_s&lt;/code&gt; 에서 처리되고 파일 스트림에 대한 포인터가 &lt;code&gt;newstreamptr&lt;/code&gt; 에 기록 되고 런타임에 다음 오류가 감지되고 현재 설치된 &lt;a href=&quot;../error/set_constraint_handler_s&quot;&gt;제한 조건 핸들러&lt;/a&gt; 함수를 호출 한다는 점을 제외하고는 (1)과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="40543886106703355edd112e7aedc0af7a5cf480" translate="yes" xml:space="preserve">
          <source>2) Same as (1), except that at least &lt;code&gt;TMP_MAX_S&lt;/code&gt; files may be opened (the limit may be shared with &lt;code&gt;tmpnam_s&lt;/code&gt;), and if &lt;code&gt;streamptr&lt;/code&gt; is a null pointer, the currently installed &lt;a href=&quot;../error/set_constraint_handler_s&quot;&gt;constraint handler&lt;/a&gt; function is called. As with all bounds-checked functions, &lt;code&gt;tmpfile_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdio.h&lt;/code&gt;.</source>
          <target state="translated">2) 최소한 &lt;code&gt;TMP_MAX_S&lt;/code&gt; 파일을 열 수 있고 (제한은 &lt;code&gt;tmpnam_s&lt;/code&gt; 와 공유 될 수 있음 ), &lt;code&gt;streamptr&lt;/code&gt; 이 널 포인터 인 경우 현재 설치된 &lt;a href=&quot;../error/set_constraint_handler_s&quot;&gt;제한 조건 핸들러&lt;/a&gt; 함수가 호출 된다는 점을 제외하고는 (1)과 동일합니다 . 모든 경계 검사 함수와 &lt;code&gt;tmpfile_s&lt;/code&gt; 는 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 이 구현에 의해 정의되고 사용자가 &lt;code&gt;stdio.h&lt;/code&gt; 를 포함하기 전에 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 을 정수 상수 1 로 정의한 경우에만 사용 가능하도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="4c03c6ec97ab1859822eb170bfe6fdbe06bf71fb" translate="yes" xml:space="preserve">
          <source>2) Same as (1), except that it may clobber the rest of the destination array (from the last character written to &lt;code&gt;destsz&lt;/code&gt;) with unspecified values and that the following errors are detected at runtime and call the currently installed &lt;a href=&quot;../../error/set_constraint_handler_s&quot;&gt;constraint handler&lt;/a&gt; function:</source>
          <target state="translated">2) 지정되지 않은 값으로 나머지 대상 배열 ( &lt;code&gt;destsz&lt;/code&gt; 에 작성된 마지막 문자부터 ) 을 방해 하고 런타임에 다음 오류가 감지되고 현재 설치된 &lt;a href=&quot;../../error/set_constraint_handler_s&quot;&gt;제약 조건 처리기&lt;/a&gt; 함수를 호출 한다는 점을 제외하고는 (1)과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="47d0173b55dbfa21cfac70882a3549f3f8064b31" translate="yes" xml:space="preserve">
          <source>2) Same as (1), except that it may clobber the rest of the destination array with unspecified values and that the following errors are detected at runtime and call the currently installed &lt;a href=&quot;../../error/set_constraint_handler_s&quot;&gt;constraint handler&lt;/a&gt; function:</source>
          <target state="translated">2) (1)과 동일하지만 나머지 대상 배열이 지정되지 않은 값으로 클로버 될 수 있으며 런타임에 다음 오류가 감지되고 현재 설치된 &lt;a href=&quot;../../error/set_constraint_handler_s&quot;&gt;제약 조건 처리기&lt;/a&gt; 함수를 호출한다는 점이 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="30d8122e8306e198cdf133a75b01bbc23d47becd" translate="yes" xml:space="preserve">
          <source>2) Same as (1), except that on every step, writes the number of characters left to see in &lt;code&gt;str&lt;/code&gt; into &lt;code&gt;*strmax&lt;/code&gt; and writes the tokenizer's internal state to &lt;code&gt;*ptr&lt;/code&gt;. Repeat calls (with null &lt;code&gt;str&lt;/code&gt;) must pass &lt;code&gt;strmax&lt;/code&gt; and &lt;code&gt;ptr&lt;/code&gt; with the values stored by the previous call. Also, the following errors are detected at runtime and call the currently installed &lt;a href=&quot;../../error/set_constraint_handler_s&quot;&gt;constraint handler&lt;/a&gt; function, without storing anything in the object pointed to by &lt;code&gt;ptr&lt;/code&gt;</source>
          <target state="translated">2) 모든 단계에서 &lt;code&gt;str&lt;/code&gt; 에서 볼 수있는 문자 수 를 &lt;code&gt;*strmax&lt;/code&gt; 에 기록하고 토크 나이저의 내부 상태를 &lt;code&gt;*ptr&lt;/code&gt; 에 기록한다는 점을 제외하고는 (1)과 동일합니다 . 반복 호출 (null &lt;code&gt;str&lt;/code&gt; 포함 )은 이전 호출에 저장된 값으로 &lt;code&gt;strmax&lt;/code&gt; 및 &lt;code&gt;ptr&lt;/code&gt; 을 전달해야합니다 . 또한 다음 오류가 런타임에 감지 되어 &lt;code&gt;ptr&lt;/code&gt; 이 가리키는 객체에 아무것도 저장하지 않고 현재 설치된 &lt;a href=&quot;../../error/set_constraint_handler_s&quot;&gt;제약 조건 핸들러&lt;/a&gt; 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="e852165758ffadae76a35ebd1112fe5ed051e29d" translate="yes" xml:space="preserve">
          <source>2) Same as (1), except that on every step, writes the number of characters left to see in &lt;code&gt;str&lt;/code&gt; into &lt;code&gt;*strmax&lt;/code&gt;. Repeat calls (with null &lt;code&gt;str&lt;/code&gt;) must pass both &lt;code&gt;strmax&lt;/code&gt; and &lt;code&gt;ptr&lt;/code&gt; with the values stored by the previous call. Also, the following errors are detected at runtime and call the currently installed &lt;a href=&quot;../../error/set_constraint_handler_s&quot;&gt;constraint handler&lt;/a&gt; function, without storing anything in the object pointed to by &lt;code&gt;ptr&lt;/code&gt;</source>
          <target state="translated">2) 모든 단계에서 &lt;code&gt;str&lt;/code&gt; 에서 볼 수있는 문자 수 를 &lt;code&gt;*strmax&lt;/code&gt; 에 쓴다는 점을 제외하고 (1)과 동일합니다 . 반복 호출 (null &lt;code&gt;str&lt;/code&gt; 포함 )은 이전 호출에 저장된 값으로 &lt;code&gt;strmax&lt;/code&gt; 및 &lt;code&gt;ptr&lt;/code&gt; 을 모두 전달해야합니다 . 또한 다음 오류가 런타임에 감지 되어 &lt;code&gt;ptr&lt;/code&gt; 이 가리키는 객체에 아무것도 저장하지 않고 현재 설치된 &lt;a href=&quot;../../error/set_constraint_handler_s&quot;&gt;제약 조건 핸들러&lt;/a&gt; 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="90774e34bc883c29dc31aa98ee21c44523780407" translate="yes" xml:space="preserve">
          <source>2) Same as (1), except that the additional context argument &lt;code&gt;context&lt;/code&gt; is passed to &lt;code&gt;comp&lt;/code&gt; and that the following errors are detected at runtime and call the currently installed &lt;a href=&quot;../error/set_constraint_handler_s&quot;&gt;constraint handler&lt;/a&gt; function:</source>
          <target state="translated">2) 추가 컨텍스트 인수 &lt;code&gt;context&lt;/code&gt; 가 &lt;code&gt;comp&lt;/code&gt; 에 전달 되고 런타임에 다음 오류가 감지되고 현재 설치된 &lt;a href=&quot;../error/set_constraint_handler_s&quot;&gt;제한 조건 핸들러&lt;/a&gt; 함수를 호출 한다는 점을 제외하고는 (1)과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="1afd94921d0d9e6bca352f2b4f59e9d1ac47e83e" translate="yes" xml:space="preserve">
          <source>2) Same as (1), except that the additional context parameter &lt;code&gt;context&lt;/code&gt; is passed to &lt;code&gt;comp&lt;/code&gt; and that the following errors are detected at runtime and call the currently installed &lt;a href=&quot;../error/set_constraint_handler_s&quot;&gt;constraint handler&lt;/a&gt; function:</source>
          <target state="translated">2) 추가 컨텍스트 매개 변수 &lt;code&gt;context&lt;/code&gt; 가 &lt;code&gt;comp&lt;/code&gt; 에 전달 되고 런타임에 다음 오류가 감지되고 현재 설치된 &lt;a href=&quot;../error/set_constraint_handler_s&quot;&gt;제약 조건 처리기&lt;/a&gt; 함수를 호출 한다는 점을 제외하고 (1)과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="94a8b6ef731a4c7b5698778bd71ae4805a1289a3" translate="yes" xml:space="preserve">
          <source>2) Same as (1), except that the following errors are detected at runtime and call the currently installed &lt;a href=&quot;../../error/set_constraint_handler_s&quot;&gt;constraint handler&lt;/a&gt; function after storing &lt;code&gt;ch&lt;/code&gt; in every location of the destination range &lt;code&gt;[dest, dest+destsz)&lt;/code&gt; if &lt;code&gt;dest&lt;/code&gt; and &lt;code&gt;destsz&lt;/code&gt; are themselves valid:</source>
          <target state="translated">2) 런타임에 다음 오류가 감지되고 &lt;code&gt;dest&lt;/code&gt; 및 &lt;code&gt;destsz&lt;/code&gt; 가 유효한 경우 대상 범위 &lt;code&gt;[dest, dest+destsz)&lt;/code&gt; 의 모든 위치에 &lt;code&gt;ch&lt;/code&gt; 를 저장 한 후 현재 설치된 &lt;a href=&quot;../../error/set_constraint_handler_s&quot;&gt;제약 조건 처리기&lt;/a&gt; 함수를 호출한다는 점을 제외하고 (1)과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="08724c50a06e459326e417edb851382d6768d6d3" translate="yes" xml:space="preserve">
          <source>2) Same as (1), except that the following errors are detected at runtime and call the currently installed &lt;a href=&quot;../../error/set_constraint_handler_s&quot;&gt;constraint handler&lt;/a&gt; function:</source>
          <target state="translated">2) 런타임시 다음 오류가 감지되고 현재 설치된 &lt;a href=&quot;../../error/set_constraint_handler_s&quot;&gt;제한 조건 핸들러&lt;/a&gt; 함수를 호출한다는 점을 제외하고 (1)과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="ab2f7c9dd806b0e55237afe5a1fc5e4b6c69debd" translate="yes" xml:space="preserve">
          <source>2) Same as (1), except that the following errors are detected at runtime and cause the entire destination range &lt;code&gt;[dest, dest+destsz)&lt;/code&gt; to be zeroed out (if both &lt;code&gt;dest&lt;/code&gt; and &lt;code&gt;destsz&lt;/code&gt; are valid), as well as call the currently installed &lt;a href=&quot;../../error/set_constraint_handler_s&quot;&gt;constraint handler&lt;/a&gt; function:</source>
          <target state="translated">2) 동일 다음 오류 런타임 검출 전체 대상 범위 원인 것 이외에는 (1)과 같은 &lt;code&gt;[dest, dest+destsz)&lt;/code&gt; (두 경우에 제로 - 아웃 될 &lt;code&gt;dest&lt;/code&gt; 하고 &lt;code&gt;destsz&lt;/code&gt; 가 유효)뿐만 아니라, 현재 전화 설치된 &lt;a href=&quot;../../error/set_constraint_handler_s&quot;&gt;제약 조건 처리기&lt;/a&gt; 기능 :</target>
        </trans-unit>
        <trans-unit id="8a2cda47ee4e3d60e44c8feb12db05af541bf83a" translate="yes" xml:space="preserve">
          <source>2) Same as (1), except that the function does not continue writing zeroes into the destination array to pad up to &lt;code&gt;count&lt;/code&gt;, it stops after writing the terminating null character (if there was no null in the source, it writes one at &lt;code&gt;dest[count]&lt;/code&gt; and then stops). Also, the following errors are detected at runtime and call the currently installed &lt;a href=&quot;../../error/set_constraint_handler_s&quot;&gt;constraint handler&lt;/a&gt; function:</source>
          <target state="translated">2) (1)과 동일하지만 함수가 &lt;code&gt;count&lt;/code&gt; 를 채우기 위해 대상 배열에 0을 계속 쓰지 않는다는 점을 제외하고 종료 널 문자를 쓴 후 중지합니다 (소스에 null이 없으면 &lt;code&gt;dest[count]&lt;/code&gt; 1을 씁니다) [카운트] 후 중지). 또한 런타임시 다음 오류가 감지되고 현재 설치된 &lt;a href=&quot;../../error/set_constraint_handler_s&quot;&gt;제한 조건 핸들러&lt;/a&gt; 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="0469b696d360226dd903fe002dd49474023b1ddf" translate="yes" xml:space="preserve">
          <source>2) Same as (1), except that the function is equivalent to &lt;code&gt;asctime_s(buffer, bufsz, localtime_s(&lt;a href=&quot;time&quot;&gt;time&lt;/a&gt;, &amp;amp;(struct &lt;a href=&quot;tm&quot;&gt;tm&lt;/a&gt;){0}))&lt;/code&gt;, and the following errors are detected at runtime and call the currently installed &lt;a href=&quot;../error/set_constraint_handler_s&quot;&gt;constraint handler&lt;/a&gt; function:</source>
          <target state="translated">2) 함수가 &lt;code&gt;asctime_s(buffer, bufsz, localtime_s(&lt;a href=&quot;time&quot;&gt;time&lt;/a&gt;, &amp;amp;(struct &lt;a href=&quot;tm&quot;&gt;tm&lt;/a&gt;){0}))&lt;/code&gt; 와 동일하고 런타임에 다음 오류가 감지되고 현재 설치된 &lt;a href=&quot;../error/set_constraint_handler_s&quot;&gt;제한 조건을&lt;/a&gt; 호출 한다는 점을 제외하고는 (1)과 동일합니다. 핸들러 기능 :</target>
        </trans-unit>
        <trans-unit id="9519711c055d895452102ec342c7b479666bc4bd" translate="yes" xml:space="preserve">
          <source>2) Same as (1), except that the function returns zero if &lt;code&gt;str&lt;/code&gt; is a null pointer and returns &lt;code&gt;strsz&lt;/code&gt; if the null character was not found in the first &lt;code&gt;strsz&lt;/code&gt; bytes of &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;str&lt;/code&gt; 인 경우 함수가 0을 반환한다는 점을 제외하고 (1)과 동일 NULL 포인터이고 반환 &lt;code&gt;strsz&lt;/code&gt; 가 널 문자가 처음에 발견되지 않은 경우 &lt;code&gt;strsz&lt;/code&gt; 바이트 &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d98a1799635aba6125a9e92539d4e20d823ded24" translate="yes" xml:space="preserve">
          <source>2) Same as (1), except that the function returns zero if &lt;code&gt;str&lt;/code&gt; is a null pointer and returns &lt;code&gt;strsz&lt;/code&gt; if the null wide character was not found in the first &lt;code&gt;strsz&lt;/code&gt; wide characters of &lt;code&gt;src&lt;/code&gt; As with all bounds-checked functions, &lt;code&gt;wcslen_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdio.h&lt;/code&gt;..</source>
          <target state="translated">2) &lt;code&gt;str&lt;/code&gt; 이 널 포인터 인 경우 함수가 0을 리턴 하고 &lt;code&gt;src&lt;/code&gt; 의 첫 번째 &lt;code&gt;strsz&lt;/code&gt; 와이드 문자 에서 널 와이드 문자를 찾을 수없는 경우 &lt;code&gt;strsz&lt;/code&gt; 를 리턴한다는 점을 제외하고는 (1)과 동일합니다. 모든 경계 점검 함수 &lt;code&gt;wcslen_s&lt;/code&gt; 는 가능한 경우 보장 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 가 사용자 정의와 구현 정의 경우 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 포함 전에 정수 상수 1 &lt;code&gt;stdio.h&lt;/code&gt; ..</target>
        </trans-unit>
        <trans-unit id="607e92f3f27408de38eba281e698ff1222b22934" translate="yes" xml:space="preserve">
          <source>2) Same as (1), except that the function uses user-provided storage &lt;code&gt;result&lt;/code&gt; for the result and that the following errors are detected at runtime and call the currently installed &lt;a href=&quot;../error/set_constraint_handler_s&quot;&gt;constraint handler&lt;/a&gt; function:</source>
          <target state="translated">2) 함수가 &lt;code&gt;result&lt;/code&gt; 에 사용자 제공 스토리지 결과 를 사용하고 런타임시 다음 오류가 감지되고 현재 설치된 &lt;a href=&quot;../error/set_constraint_handler_s&quot;&gt;제한 조건 핸들러&lt;/a&gt; 함수를 호출 한다는 점을 제외하고 (1)과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="b2868c98006c63b6b57c763a935de43bf2490190" translate="yes" xml:space="preserve">
          <source>2) Same as (1), except that the message is copied into user-provided storage &lt;code&gt;buf&lt;/code&gt;, which is guaranteed to be null-terminated, and the following errors are detected at runtime and call the currently installed &lt;a href=&quot;../error/set_constraint_handler_s&quot;&gt;constraint handler&lt;/a&gt; function:</source>
          <target state="translated">2) 메시지가 사용자 제공 스토리지에 복사된다는 점을 제외하고 (1)과 동일 &lt;code&gt;buf&lt;/code&gt; 에 널 종료가 보장되고 런타임에 다음 오류가 감지되고 현재 설치된 &lt;a href=&quot;../error/set_constraint_handler_s&quot;&gt;제한 조건 핸들러&lt;/a&gt; 함수를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="224ce90209d0bf8e36b21272f6406dbe2b2e7679" translate="yes" xml:space="preserve">
          <source>2) Same as (1), except that the message is copied into user-provided storage &lt;code&gt;buf&lt;/code&gt;. No more than &lt;code&gt;bufsz-1&lt;/code&gt; bytes are written, the buffer is always null-terminated. If the message had to be truncated to fit the buffer and &lt;code&gt;bufsz&lt;/code&gt; is greater than 3, then only &lt;code&gt;bufsz-4&lt;/code&gt; bytes are written, and the characters &lt;code&gt;&quot;...&quot;&lt;/code&gt; are appended before the null terminator. In addition, the following errors are detected at runtime and call the currently installed &lt;a href=&quot;../../error/set_constraint_handler_s&quot;&gt;constraint handler&lt;/a&gt; function:</source>
          <target state="translated">2) 메시지가 사용자 제공 스토리지 &lt;code&gt;buf&lt;/code&gt; 에 복사된다는 점을 제외하고 (1)과 동일합니다 . 더 이상 &lt;code&gt;bufsz-1&lt;/code&gt; 바이트 버퍼는 항상 null로 종료하고, 기록되지 않습니다. 버퍼에 맞추기 위해 메시지를 잘라야하고 &lt;code&gt;bufsz&lt;/code&gt; 가 3보다 큰 경우 &lt;code&gt;bufsz-4&lt;/code&gt; 바이트 만 작성되고 문자는 &lt;code&gt;&quot;...&quot;&lt;/code&gt; 가 널 종료 자 앞에 추가됩니다. 또한 런타임시 다음 오류가 감지되고 현재 설치된 &lt;a href=&quot;../../error/set_constraint_handler_s&quot;&gt;제한 조건 핸들러&lt;/a&gt; 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="857206a2318612da3748645e781819b440c3aec2" translate="yes" xml:space="preserve">
          <source>2) Same as (1), except that the null pointer is also returned on runtime constraints violations.</source>
          <target state="translated">2) 런타임 제약 조건 위반시 널 포인터도 반환된다는 점을 제외하고 (1)과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="48bbbfc109301db8c552032fd94d34c065d99580" translate="yes" xml:space="preserve">
          <source>2) Same as (1), except that the pointer to the file stream is written to &lt;code&gt;streamptr&lt;/code&gt; and the following errors are detected at runtime and call the currently installed &lt;a href=&quot;../error/set_constraint_handler_s&quot;&gt;constraint handler&lt;/a&gt; function:</source>
          <target state="translated">2) 파일 스트림에 대한 포인터가 &lt;code&gt;streamptr&lt;/code&gt; 에 기록된다는 점을 제외하고 (1)과 동일 되고 런타임에 다음 오류가 감지되고 현재 설치된 &lt;a href=&quot;../error/set_constraint_handler_s&quot;&gt;제한 조건 핸들러&lt;/a&gt; 함수를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="72c033e435b10ef2cffa5938e09c68e185909383" translate="yes" xml:space="preserve">
          <source>2) Same as (1), except that the result is returned in the out-parameter &lt;code&gt;status&lt;/code&gt; and the following errors are detected at runtime and call the currently installed &lt;a href=&quot;../../error/set_constraint_handler_s&quot;&gt;constraint handler&lt;/a&gt; function:</source>
          <target state="translated">2) 결과가 매개 변수를 벗어난 &lt;code&gt;status&lt;/code&gt; 로 반환 되고 런타임에 다음 오류가 감지되고 현재 설치된 호출을 제외하고 (1)과 동일&lt;a href=&quot;../../error/set_constraint_handler_s&quot;&gt; 제한 조건 핸들러&lt;/a&gt; 함수를 합니다.</target>
        </trans-unit>
        <trans-unit id="69f8bed32015a035c1aa25609d8d3b6cb2ba85ba" translate="yes" xml:space="preserve">
          <source>2) Same as (1), except that the values of the environment variable is written to the user-provided buffer &lt;code&gt;value&lt;/code&gt; (unless null) and the number of bytes written is stored in the user-provided location &lt;code&gt;*len&lt;/code&gt; (unless null). If the environment variable is not set in the environment, zero is written to &lt;code&gt;*len&lt;/code&gt; (unless null) and &lt;code&gt;'\0'&lt;/code&gt; is written to &lt;code&gt;value[0]&lt;/code&gt; (unless null). In addition, the following errors are detected at runtime and call the currently installed &lt;a href=&quot;../error/set_constraint_handler_s&quot;&gt;constraint handler&lt;/a&gt; function:</source>
          <target state="translated">2) 환경 변수의 값이 사용자 제공 버퍼 &lt;code&gt;value&lt;/code&gt; 기록되고 (널 (NULL)이 아닌 경우) 기록 된 바이트 수가 사용자 제공 위치 &lt;code&gt;*len&lt;/code&gt; (널 (null)이 아닌)에 저장 된다는 점을 제외하고는 (1)과 동일합니다 . 환경에 환경 변수가 설정되지 않은 경우 0은 &lt;code&gt;*len&lt;/code&gt; (널이 아닌 경우)에 기록되고 &lt;code&gt;'\0'&lt;/code&gt; 은 &lt;code&gt;value[0]&lt;/code&gt; (널이 아닌 경우)에 기록됩니다. 또한 런타임시 다음 오류가 감지되어 현재 설치된 호출&lt;a href=&quot;../error/set_constraint_handler_s&quot;&gt; 제한 조건 핸들러&lt;/a&gt; 함수를 .</target>
        </trans-unit>
        <trans-unit id="7640c3fdb352d2a3f2b5db118f49fdf931b3c07b" translate="yes" xml:space="preserve">
          <source>2) Same as (1), except that this function may clobber the remainder of the destination array (from the last byte written to &lt;code&gt;destsz&lt;/code&gt;) and that the following errors are detected at runtime and call the currently installed &lt;a href=&quot;../../error/set_constraint_handler_s&quot;&gt;constraint handler&lt;/a&gt; function:</source>
          <target state="translated">2) (1)과 동일하지만이 함수는 대상 배열의 나머지 부분을 &lt;code&gt;destsz&lt;/code&gt; 할 수 있으며 (destsz에 작성된 마지막 바이트부터 ) 런타임에 다음 오류가 감지되고 현재 설치된 &lt;a href=&quot;../../error/set_constraint_handler_s&quot;&gt;제약 조건 처리기&lt;/a&gt; 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="999904dd2773adf7c5c8e238d6903818e01d69df" translate="yes" xml:space="preserve">
          <source>2) Same as (1), except that this function may clobber the remainder of the destination array (from the last wide character written to &lt;code&gt;destsz&lt;/code&gt;) and that the following errors are detected at runtime and call the currently installed &lt;a href=&quot;../../error/set_constraint_handler_s&quot;&gt;constraint handler&lt;/a&gt; function:</source>
          <target state="translated">2) (1)과 동일하지만이 함수는 대상 배열의 나머지 부분을 &lt;code&gt;destsz&lt;/code&gt; 할 수 있고 (destsz에 작성된 마지막 와이드 문자 에서) 런타임에 다음 오류가 감지되고 현재 설치된 &lt;a href=&quot;../../error/set_constraint_handler_s&quot;&gt;제약 조건 처리기&lt;/a&gt; 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="7ab3c24ca29fcf24acdaa2148ba0ad25c2df2cc7" translate="yes" xml:space="preserve">
          <source>2) Same as (1), except that up to &lt;code&gt;TMP_MAX_S&lt;/code&gt; names may be generated, no longer than &lt;code&gt;L_tmpnam_s&lt;/code&gt; in length, and the following errors are detected at runtime and call the currently installed &lt;a href=&quot;../error/set_constraint_handler_s&quot;&gt;constraint handler&lt;/a&gt; function:</source>
          <target state="translated">2) 최대 &lt;code&gt;TMP_MAX_S&lt;/code&gt; 이름을 &lt;code&gt;L_tmpnam_s&lt;/code&gt; 이하 의 길이 로 생성 할 수 있고 런타임에 다음 오류가 감지되어 현재 설치된 호출을 제외하고 (1)과 동일&lt;a href=&quot;../error/set_constraint_handler_s&quot;&gt; 제한 조건 핸들러&lt;/a&gt; 함수를 .</target>
        </trans-unit>
        <trans-unit id="fe638f9ef0d1cccbd6ce21e200e5100d8bd9cd65" translate="yes" xml:space="preserve">
          <source>2) Same as (1), except when detecting the following errors at runtime, it zeroes out the entire destination range &lt;code&gt;[dest, dest+destsz)&lt;/code&gt; (if both &lt;code&gt;dest&lt;/code&gt; and &lt;code&gt;destsz&lt;/code&gt; are valid) and calls the currently installed &lt;a href=&quot;../../error/set_constraint_handler_s&quot;&gt;constraint handler&lt;/a&gt; function:</source>
          <target state="translated">런타임시 다음의 에러를 검출 할 때 2) (1)과 동일 제외하고는, 전체 대상 범위 밖으로 까진 0 &lt;code&gt;[dest, dest+destsz)&lt;/code&gt; (두 경우 &lt;code&gt;dest&lt;/code&gt; 하고 &lt;code&gt;destsz&lt;/code&gt; 가 유효) 및 현재 인스톨 호출 &lt;a href=&quot;../../error/set_constraint_handler_s&quot;&gt;제약 핸들러&lt;/a&gt; 함수 :</target>
        </trans-unit>
        <trans-unit id="6d22cf7ab9fd315890290eaf83df26949f2ed10d" translate="yes" xml:space="preserve">
          <source>2) Searches for the file in implementation-defined manner. The intent of this syntax is to search for the files that are not controlled by the implementation. Typical implementations first search the directory where the current file resides and, only if the file is not found, search the standard include directories as with (1).</source>
          <target state="translated">2) 구현 정의 방식으로 파일을 검색합니다. 이 구문의 목적은 구현에 의해 제어되지 않는 파일을 검색하는 것입니다. 일반적인 구현에서는 먼저 현재 파일이있는 디렉토리를 검색하고 파일을 찾을 수없는 경우에만 (1)과 같이 표준 포함 디렉토리를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="4b088ef2082bcedcbb634bd0afbcd95c324f53db" translate="yes" xml:space="preserve">
          <source>2) Suitably declared &lt;a href=&quot;identifier&quot;&gt;identifiers&lt;/a&gt; (e.g. &lt;code&gt;n&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../io/fprintf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">2) 적절하게 선언 &lt;a href=&quot;identifier&quot;&gt;된 식별자&lt;/a&gt; (예 : &lt;code&gt;n&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../io/fprintf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="4f80b51fe03accf362cbf4f988f40b760b66b124" translate="yes" xml:space="preserve">
          <source>2) Tag names: all identifiers declared as names of &lt;a href=&quot;struct&quot;&gt;structs&lt;/a&gt;, &lt;a href=&quot;union&quot;&gt;unions&lt;/a&gt; and &lt;a href=&quot;enum&quot;&gt;enumerated types&lt;/a&gt;. Note that all three kinds of tags share one name space.</source>
          <target state="translated">2) 태그 이름 : &lt;a href=&quot;struct&quot;&gt;구조체&lt;/a&gt; , &lt;a href=&quot;union&quot;&gt;공용체&lt;/a&gt; 및 &lt;a href=&quot;enum&quot;&gt;열거 형의&lt;/a&gt; 이름으로 선언 된 모든 식별자 . 세 종류의 태그는 모두 하나의 네임 스페이스를 공유합니다.</target>
        </trans-unit>
        <trans-unit id="618fa5ad57b4ad9fe40b9249f3d702d6814e08cc" translate="yes" xml:space="preserve">
          <source>2) Terminates the current function. Only valid if the function return type is &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">2) 현재 기능을 종료합니다. 함수 반환 유형이 &lt;code&gt;void&lt;/code&gt; 인 경우에만 유효합니다 .</target>
        </trans-unit>
        <trans-unit id="6283e606193c2ef2763fe854fea8988ef7c395ba" translate="yes" xml:space="preserve">
          <source>2) The &lt;code&gt;register&lt;/code&gt; specifier is only allowed for objects declared at block scope, including function parameter lists. It indicates automatic storage duration and no linkage (which is the default for these kinds of declarations), but additionally hints the optimizer to store the value of this variable in a CPU register if possible. Regardless of whether this optimization takes place or not, variables declared &lt;code&gt;register&lt;/code&gt; cannot be used as arguments to the &lt;a href=&quot;operator_member_access&quot;&gt;address-of operator&lt;/a&gt;, cannot use &lt;a href=&quot;alignas&quot;&gt;alignas&lt;/a&gt;(since C11), and &lt;code&gt;register&lt;/code&gt; arrays are not convertible to pointers.</source>
          <target state="translated">2) &lt;code&gt;register&lt;/code&gt; 지정자는 함수 매개 변수 목록을 포함하여 블록 범위에서 선언 된 객체에만 허용됩니다. 자동 저장 기간과 연결 없음 (이러한 종류의 선언에 대한 기본값 임)을 나타내지 만 가능하면 최적화 프로그램이이 변수의 값을 CPU 레지스터에 저장하도록 암시합니다. 이 최적화가 수행되는지 여부에 관계없이 &lt;code&gt;register&lt;/code&gt; 로 선언 된 변수는 &lt;a href=&quot;operator_member_access&quot;&gt;address-of 연산자&lt;/a&gt; 에 대한 인수로 사용할 수 없으며 &lt;a href=&quot;alignas&quot;&gt;alignas&lt;/a&gt; (C11 이후)를 사용할 수 없으며 &lt;code&gt;register&lt;/code&gt; 배열은 포인터로 변환 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="763440d161086da99dbeb1811286aa979573d097" translate="yes" xml:space="preserve">
          <source>2) The exponent syntax for hexadecimal floating-point constant</source>
          <target state="translated">2) 16 진 부동 소수점 상수의 지수 구문</target>
        </trans-unit>
        <trans-unit id="95f291708652ee62cf3fc9edbaa429a7c702a117" translate="yes" xml:space="preserve">
          <source>2) The length of the null-terminated byte string &lt;code&gt;str&lt;/code&gt; on success, zero if &lt;code&gt;str&lt;/code&gt; is a null pointer, &lt;code&gt;strsz&lt;/code&gt; if the null character was not found.</source>
          <target state="translated">2) 성공시 널 종료 바이트 문자열 &lt;code&gt;str&lt;/code&gt; 의 길이. &lt;code&gt;str&lt;/code&gt; 이 널 포인터 인 경우 0, 널 문자를 찾을 수없는 경우 &lt;code&gt;strsz&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="43707a7608113962572d6d82b5bc49cb58b58918" translate="yes" xml:space="preserve">
          <source>2) The length of the null-terminated wide string &lt;code&gt;str&lt;/code&gt; on success, zero if &lt;code&gt;str&lt;/code&gt; is a null pointer, &lt;code&gt;strsz&lt;/code&gt; if the null wide character was not found.</source>
          <target state="translated">2) 성공시 널 종료 와이드 문자열 &lt;code&gt;str&lt;/code&gt; 의 길이. &lt;code&gt;str&lt;/code&gt; 이 널 포인터 인 경우 0, 널 와이드 문자를 찾을 수없는 경우 &lt;code&gt;strsz&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7d63a1e1ea9c2cbdf95c4ea445386db61b0ff9aa" translate="yes" xml:space="preserve">
          <source>2) The type of each parameter must be a type such that &lt;a href=&quot;conversion&quot;&gt;implicit conversion as if by assignment&lt;/a&gt; exists that converts the unqualified type of the corresponding argument to the type of the parameter.</source>
          <target state="translated">2) 각 매개 변수의 유형은 &lt;a href=&quot;conversion&quot;&gt;지정&lt;/a&gt; 에 의해 해당 인수의 규정되지 않은 유형을 매개 변수 유형으로 변환하는 것처럼 내재적으로 변환 되는 유형이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="cdc6adf55e0843a22c3cfd31c81db0d09b30f50c" translate="yes" xml:space="preserve">
          <source>2) There is a sequence point after evaluation of the first (left) operand and before evaluation of the second (right) operand of the following binary operators: &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; (logical AND), &lt;code&gt;||&lt;/code&gt; (logical OR), and &lt;code&gt;,&lt;/code&gt; (comma).</source>
          <target state="translated">2) 다음 2 진 연산자의 첫 번째 (왼쪽) 피연산자 평가 후와 두 번째 (오른쪽) 피연산자 평가 전에 순서 점이 있습니다. &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; (logical AND), &lt;code&gt;||&lt;/code&gt; (논리적 OR) 및 &lt;code&gt;,&lt;/code&gt; (쉼표).</target>
        </trans-unit>
        <trans-unit id="e501329036dc6b0206dd1ba3b1430c8b615ac34c" translate="yes" xml:space="preserve">
          <source>2) Use as a type qualifier; this designates the atomic version of type-name. In this role, it may be mixed with &lt;a href=&quot;const&quot;&gt;const&lt;/a&gt;, &lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt;, and &lt;a href=&quot;restrict&quot;&gt;restrict&lt;/a&gt;), although unlike other qualifiers, the atomic version of type-name may have a different size, alignment, and object representation.</source>
          <target state="translated">2) 형식 한정자로 사용하십시오. 이것은 type-name의 원자 버전을 지정합니다. 이러한 역할에서, 함께 혼합 할 수있다 &lt;a href=&quot;const&quot;&gt;CONST&lt;/a&gt; , &lt;a href=&quot;volatile&quot;&gt;휘발성&lt;/a&gt; 및 &lt;a href=&quot;restrict&quot;&gt;제한&lt;/a&gt; 다른 한정어 달리 타입 이름의 원 버전이 다른 크기, 배향 및 객체의 표현을 가질 수 있지만).</target>
        </trans-unit>
        <trans-unit id="fb68e180bc5c9076b0953a9a46e57364a26f7b3a" translate="yes" xml:space="preserve">
          <source>2) Writes the results to a file stream &lt;code&gt;stream&lt;/code&gt;.</source>
          <target state="translated">2) 결과를 파일 스트림 &lt;code&gt;stream&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d1f88e1cc5fcc14e31775a112e11927e2c4fc13" translate="yes" xml:space="preserve">
          <source>2) Writes the results to the output stream &lt;code&gt;stream&lt;/code&gt;.</source>
          <target state="translated">2) 결과를 출력 스트림 &lt;code&gt;stream&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4df3b04794d77cd8efbe12ea962694f4c92eade4" translate="yes" xml:space="preserve">
          <source>2) Zero if the entire message was successfully stored in &lt;code&gt;buf&lt;/code&gt;, non-zero otherwise.</source>
          <target state="translated">2) 전체 메시지가 &lt;code&gt;buf&lt;/code&gt; 에 성공적으로 저장되면 0이고, 그렇지 않으면 0이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e9d5c906c7a9a8ecaf618e8990b642f6328916cd" translate="yes" xml:space="preserve">
          <source>2) Zero if the file was created and open successfully, non-zero if the file was not created or open or if &lt;code&gt;streamptr&lt;/code&gt; was a null pointer. In addition, pointer to the associated file stream is stored in &lt;code&gt;*streamptr&lt;/code&gt; on success, and a null pointer value is stored in &lt;code&gt;*streamptr&lt;/code&gt; on error.</source>
          <target state="translated">2) 파일이 작성되어 성공적으로 열리면 0, 파일이 작성되지 않았거나 열리지 않았거나 &lt;code&gt;streamptr&lt;/code&gt; 이 널 포인터 인 경우 0이 아닙니다 . 또한 연관된 ​​파일 스트림에 대한 포인터는 성공시 &lt;code&gt;*streamptr&lt;/code&gt; 에 저장되고 널 포인터 값은 오류시 &lt;code&gt;*streamptr&lt;/code&gt; 에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="4e755c3160558147f739e761d836ad2b22b1820a" translate="yes" xml:space="preserve">
          <source>2) a &lt;a href=&quot;variadic&quot;&gt;variadic function&lt;/a&gt;, where the argument expression is one of the trailing arguments that are matched against the ellipsis parameter</source>
          <target state="translated">2) &lt;a href=&quot;variadic&quot;&gt;variadic 함수&lt;/a&gt; . 인수 인수는 생략 매개 변수와 일치하는 후행 인수 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="82b3c110d5788b5d0d4bc22d99707cd441e7a5a9" translate="yes" xml:space="preserve">
          <source>2) address of an object</source>
          <target state="translated">2) 객체의 주소</target>
        </trans-unit>
        <trans-unit id="999abacf637406bb9cbb5aa419f897e87f73fa72" translate="yes" xml:space="preserve">
          <source>2) any declarator may be enclosed in parentheses; this is required to introduce pointers to arrays and pointers to functions.</source>
          <target state="translated">2) 모든 선언자는 괄호로 묶을 수 있습니다. 이것은 배열에 대한 포인터와 함수에 대한 포인터를 도입하는 데 필요합니다.</target>
        </trans-unit>
        <trans-unit id="2cf7ae39809692ef985348cfe0b01a2972cbd32b" translate="yes" xml:space="preserve">
          <source>2) bitwise AND</source>
          <target state="translated">2) 비트 AND</target>
        </trans-unit>
        <trans-unit id="bdd3268c08768f192ffe9591a68f62ed3c3c1d33" translate="yes" xml:space="preserve">
          <source>2) comma-separated list of constant(until C99) expressions that are initializers for array elements, optionally using array designators of the form &lt;code&gt;[&lt;/code&gt;constant-expression&lt;code&gt;]&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;(since C99)</source>
          <target state="translated">2) 선택적으로 &lt;code&gt;[&lt;/code&gt; constant-expression &lt;code&gt;]&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; (C99 이후) 형식의 배열 지정자를 사용하여 배열 요소의 이니셜 라이저 인 쉼표로 구분 된 상수 (C99까지) 표현식 목록</target>
        </trans-unit>
        <trans-unit id="134680780d38fe4e22fbb58d97d652e3459f4b8c" translate="yes" xml:space="preserve">
          <source>2) copy of the &lt;code&gt;result&lt;/code&gt; pointer, or null pointer on error (which may be a runtime constraint violation or a failure to convert the specified time to UTC)</source>
          <target state="translated">2) &lt;code&gt;result&lt;/code&gt; 포인터의 사본 또는 오류에 대한 널 포인터 (런타임 제약 조건 위반 또는 지정된 시간을 UTC로 변환하지 못할 수 있음)</target>
        </trans-unit>
        <trans-unit id="f71105595b8011ea6e8f7bd15c7a2e76a739cdc3" translate="yes" xml:space="preserve">
          <source>2) copy of the &lt;code&gt;result&lt;/code&gt; pointer, or null pointer on error (which may be a runtime constraint violation or a failure to convert the specified time to local calendar time)</source>
          <target state="translated">2) &lt;code&gt;result&lt;/code&gt; 포인터의 사본 또는 오류에 대한 널 포인터 (런타임 제약 조건 위반 또는 지정된 시간을 로컬 달력 시간으로 변환하지 못할 수 있음)</target>
        </trans-unit>
        <trans-unit id="58ee80b52a49292c1843b570a27cc3a5814159e6" translate="yes" xml:space="preserve">
          <source>2) division. lhs and rhs must have &lt;a href=&quot;arithmetic_types&quot;&gt;arithmetic types&lt;/a&gt;</source>
          <target state="translated">2) 구분. lhs 및 rhs는 &lt;a href=&quot;arithmetic_types&quot;&gt;산술 유형을&lt;/a&gt; 가져야 합니다</target>
        </trans-unit>
        <trans-unit id="867a50a15839025479c87f4da8c6d7216a47b44b" translate="yes" xml:space="preserve">
          <source>2) expression statements</source>
          <target state="translated">2) 표현 문</target>
        </trans-unit>
        <trans-unit id="e6216eb37a5d2944ccc641bd6bfab9e93c2bf565" translate="yes" xml:space="preserve">
          <source>2) greater-than expression</source>
          <target state="translated">2)보다 큰 표현</target>
        </trans-unit>
        <trans-unit id="ffaf06ba809ceb6702e0c25b4a39b8610abca71d" translate="yes" xml:space="preserve">
          <source>2) identifier that follows the keyword &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt;, or &lt;code&gt;enum&lt;/code&gt; is looked up in the tag name space.</source>
          <target state="translated">2) 키워드 &lt;code&gt;struct&lt;/code&gt; , &lt;code&gt;union&lt;/code&gt; 또는 &lt;code&gt;enum&lt;/code&gt; 뒤에 오는 식별자가 태그 네임 스페이스에서 조회됩니다.</target>
        </trans-unit>
        <trans-unit id="dc271a0aa95cc490903976a92015dea1fc98e516" translate="yes" xml:space="preserve">
          <source>2) if the expressions have struct/union type, the common type is that struct/union type</source>
          <target state="translated">2) 표현식에 struct / union 유형이있는 경우 공통 유형은 struct / union 유형입니다.</target>
        </trans-unit>
        <trans-unit id="e73faa75cda5e5a957e5e0dfa9fc6ef291b0d89b" translate="yes" xml:space="preserve">
          <source>2) not equal to expression</source>
          <target state="translated">2) 표현과 같지 않음</target>
        </trans-unit>
        <trans-unit id="369908471775913420c6be7cb7aafc60c059ddcc" translate="yes" xml:space="preserve">
          <source>2) one of the conversions listed below (if it can produce the target type)</source>
          <target state="translated">2) 아래에 나열된 전환 중 하나 (타겟 유형을 생성 할 수있는 경우)</target>
        </trans-unit>
        <trans-unit id="00290af7166d0999d4ff3f63754916581d0a4d88" translate="yes" xml:space="preserve">
          <source>2) pointer to a pointer that will be updated by this function call</source>
          <target state="translated">2)이 함수 호출에 의해 업데이트 될 포인터에 대한 포인터</target>
        </trans-unit>
        <trans-unit id="8ded236acfeb176c8a27a38f3c48d21d4c1a070d" translate="yes" xml:space="preserve">
          <source>2) pointer to an implementation-defined object or a null pointer. Examples of implementation-defined objects are objects that give the name of the function that detected the violation and the line number when the violation was detected</source>
          <target state="translated">2) 구현 정의 객체 또는 널 포인터에 대한 포인터. 구현 정의 객체의 예는 위반을 감지 한 함수의 이름과 위반이 감지 된 줄 번호를 제공하는 객체입니다.</target>
        </trans-unit>
        <trans-unit id="b1230b872f5d1c9899499fe1b0506c99f08aaf8f" translate="yes" xml:space="preserve">
          <source>2) reads the data from file stream &lt;code&gt;stream&lt;/code&gt;</source>
          <target state="translated">2) 파일 스트림 &lt;code&gt;stream&lt;/code&gt; 에서 데이터를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="fa40c8a869185c28d1cfcbd01169839777843e3e" translate="yes" xml:space="preserve">
          <source>2) returns zero on success, returns non-zero on error. Also, on error, fills the entire &lt;code&gt;dst&lt;/code&gt; up to and not including &lt;code&gt;dst+dstsz&lt;/code&gt; with null wide characters, &lt;code&gt;L'\0'&lt;/code&gt; (unless &lt;code&gt;dest&lt;/code&gt; is null or &lt;code&gt;destsz&lt;/code&gt; is greater than &lt;code&gt;RSIZE_MAX/sizeof(wchar_t)&lt;/code&gt;)</source>
          <target state="translated">2) 성공하면 0을 반환하고, 에러이면 0이 아닌 값을 반환합니다. 또한 오류가 발생하면 &lt;code&gt;dst+dstsz&lt;/code&gt; 를 포함하지 않고 널 와이드 문자 &lt;code&gt;L'\0'&lt;/code&gt; 까지 전체 &lt;code&gt;dst&lt;/code&gt; 를 채 웁니다 ( &lt;code&gt;dest&lt;/code&gt; 가 null이거나 &lt;code&gt;destsz&lt;/code&gt; 가 &lt;code&gt;RSIZE_MAX/sizeof(wchar_t)&lt;/code&gt; 보다 큰 경우 제외 )</target>
        </trans-unit>
        <trans-unit id="e0ee68d4234e10e0450337de7679e7e9b97f05b8" translate="yes" xml:space="preserve">
          <source>2) returns zero on success, returns non-zero on error. Also, on error, writes &lt;code&gt;L'\0'&lt;/code&gt; to &lt;code&gt;dest[0]&lt;/code&gt; (unless &lt;code&gt;dest&lt;/code&gt; is a null pointer or &lt;code&gt;destsz&lt;/code&gt; is zero or greater than &lt;code&gt;RMAX_SIZE / sizeof(wchar_t)&lt;/code&gt;).</source>
          <target state="translated">2) 성공하면 0을 반환하고, 오류는 0이 아닌 값을 반환합니다. 또한 오류가 발생하면 &lt;code&gt;L'\0'&lt;/code&gt; 을 &lt;code&gt;dest[0]&lt;/code&gt; 씁니다 ( &lt;code&gt;dest&lt;/code&gt; 가 널 포인터이거나 &lt;code&gt;destsz&lt;/code&gt; 가 0이거나 &lt;code&gt;RMAX_SIZE / sizeof(wchar_t)&lt;/code&gt; 보다 크지 않은 경우 ).</target>
        </trans-unit>
        <trans-unit id="adc2980bf5377d391c34585c064660feb2c1bbac" translate="yes" xml:space="preserve">
          <source>2) returns zero on success, returns non-zero on error. Also, on error, writes &lt;code&gt;L'\0'&lt;/code&gt; to &lt;code&gt;dest[0]&lt;/code&gt; (unless &lt;code&gt;dest&lt;/code&gt; is a null pointer or &lt;code&gt;destsz&lt;/code&gt; is zero or greater than &lt;code&gt;RSIZE_MAX/sizeof(wchar_t)&lt;/code&gt;) and may clobber the rest of the destination array with unspecified values.</source>
          <target state="translated">2) 성공하면 0을 반환하고, 오류는 0이 아닌 값을 반환합니다. 또한 오류가 발생하면 &lt;code&gt;L'\0'&lt;/code&gt; 을 &lt;code&gt;dest[0]&lt;/code&gt; 씁니다 ( &lt;code&gt;dest&lt;/code&gt; 가 null 포인터이거나 &lt;code&gt;destsz&lt;/code&gt; 가 0이거나 &lt;code&gt;RSIZE_MAX/sizeof(wchar_t)&lt;/code&gt; 보다 크지 않은 경우). 지정되지 않은 값으로 대상 배열의 나머지 부분을 방해 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25d1b1a9f5247e4d8c8b4a9096535988e04d5a2b" translate="yes" xml:space="preserve">
          <source>2) returns zero on success, returns non-zero on error. Also, on error, writes &lt;code&gt;L'\0'&lt;/code&gt; to &lt;code&gt;dest[0]&lt;/code&gt; (unless &lt;code&gt;dest&lt;/code&gt; is a null pointer or &lt;code&gt;destsz&lt;/code&gt; is zero or greater than &lt;code&gt;RSIZE_MAX/sizeof(wchar_t)&lt;/code&gt;).</source>
          <target state="translated">2) 성공하면 0을 반환하고, 오류는 0이 아닌 값을 반환합니다. 또한 오류가 발생하면 &lt;code&gt;L'\0'&lt;/code&gt; 을 &lt;code&gt;dest[0]&lt;/code&gt; 씁니다 ( &lt;code&gt;dest&lt;/code&gt; 가 널 포인터이거나 &lt;code&gt;destsz&lt;/code&gt; 가 0이거나 &lt;code&gt;RSIZE_MAX/sizeof(wchar_t)&lt;/code&gt; 보다 크지 않은 경우 ).</target>
        </trans-unit>
        <trans-unit id="a6cefa1a44bd52d1e6b2d0bfe74baa7b2b6b966d" translate="yes" xml:space="preserve">
          <source>2) returns zero on success, returns non-zero on error. Also, on error, writes zero to &lt;code&gt;dest[0]&lt;/code&gt; (unless &lt;code&gt;dest&lt;/code&gt; is a null pointer or &lt;code&gt;destsz&lt;/code&gt; is zero or greater than &lt;code&gt;RSIZE_MAX&lt;/code&gt;) and may clobber the rest of the destination array with unspecified values.</source>
          <target state="translated">2) 성공하면 0을 반환하고, 오류는 0이 아닌 값을 반환합니다. 또한 오류가 발생하면 &lt;code&gt;dest[0]&lt;/code&gt; 0을 씁니다 ( &lt;code&gt;dest&lt;/code&gt; 가 null 포인터이거나 &lt;code&gt;destsz&lt;/code&gt; 가 0이거나 &lt;code&gt;RSIZE_MAX&lt;/code&gt; 보다 크지 않은 경우 ) 지정되지 않은 값으로 대상 배열의 나머지 부분을 방해 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a34a12a1beac0a884c61ff4955fefbff0480f75" translate="yes" xml:space="preserve">
          <source>2) returns zero on success, returns non-zero on error. Also, on error, writes zero to &lt;code&gt;dest[0]&lt;/code&gt; (unless &lt;code&gt;dest&lt;/code&gt; is a null pointer or &lt;code&gt;destsz&lt;/code&gt; is zero or greater than &lt;code&gt;RSIZE_MAX&lt;/code&gt;).</source>
          <target state="translated">2) 성공하면 0을 반환하고, 오류는 0이 아닌 값을 반환합니다. 또한 오류가 발생하면 &lt;code&gt;dest[0]&lt;/code&gt; 0을 씁니다 ( &lt;code&gt;dest&lt;/code&gt; 가 널 포인터이거나 &lt;code&gt;destsz&lt;/code&gt; 가 0이거나 &lt;code&gt;RSIZE_MAX&lt;/code&gt; 보다 큰 경우 제외 ).</target>
        </trans-unit>
        <trans-unit id="72cef41fc2856e5795da50c38e552f85c1551ef4" translate="yes" xml:space="preserve">
          <source>2) right shift of lhs by rhs bits</source>
          <target state="translated">2) rhs 비트에 의한 lh의 우측 시프트</target>
        </trans-unit>
        <trans-unit id="fb5dfecdc049499bf00070e274042539e6184836" translate="yes" xml:space="preserve">
          <source>2) subtraction: lhs and rhs must be one of the following</source>
          <target state="translated">2) 빼기 : lhs 및 rhs는 다음 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="031b215e8ed2c220f0171f283d2c5722d99bcca7" translate="yes" xml:space="preserve">
          <source>2) the &lt;a href=&quot;fe_round&quot;&gt;floating-point rounding macro&lt;/a&gt; describing the current rounding direction or a negative value if the direction cannot be determined.</source>
          <target state="translated">2) 현재 반올림 방향을 설명 하는 &lt;a href=&quot;fe_round&quot;&gt;부동 소수점 반올림 매크로&lt;/a&gt; 또는 방향을 결정할 수없는 경우 음수 값.</target>
        </trans-unit>
        <trans-unit id="280fd5df9c2a6bd3c2e8634c77d2f212dd167532" translate="yes" xml:space="preserve">
          <source>2) the null pointer constant &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">2) 널 포인터 상수 &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dc74ca063da0b80eaa6fb5ad3814836afce1dfef" translate="yes" xml:space="preserve">
          <source>2) the ranks of all signed integer types equal the ranks of the corresponding unsigned integer types</source>
          <target state="translated">2) 모든 부호있는 정수 유형의 순위는 해당하는 부호없는 정수 유형의 순위와 같습니다.</target>
        </trans-unit>
        <trans-unit id="44940e7b5e5b1a6cebd6d7933ee859beb2a9d6cf" translate="yes" xml:space="preserve">
          <source>2) the sequentially-consistent fences are only establishing total ordering for the fences themselves, not for the atomic operations in the general case (</source>
          <target state="translated">2) 순차적으로 일관된 울타리는 일반적인 경우 원자 작업이 아닌 울타리 자체에 대한 전체 주문 만 설정합니다.</target>
        </trans-unit>
        <trans-unit id="07940043869fafd1cbffb85551f4f68927175c3e" translate="yes" xml:space="preserve">
          <source>2) to the alignment requirement of type, that is, to &lt;code&gt;alignof(type)&lt;/code&gt;</source>
          <target state="translated">2) 유형의 정렬 요구 사항, 즉 &lt;code&gt;alignof(type)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="74b247560e4a1938b189620c2b0110b4f8fc1df8" translate="yes" xml:space="preserve">
          <source>2) unary minus (negation)</source>
          <target state="translated">2) 단항 빼기 (음수)</target>
        </trans-unit>
        <trans-unit id="10c8c571dfa775fd95490650b8eab4100d1ba54f" translate="yes" xml:space="preserve">
          <source>2) zero if the environment variable was found, non-zero if it was not found of if a runtime constrant violation occurred. On any error, writes zero to &lt;code&gt;*len&lt;/code&gt; (unless &lt;code&gt;len&lt;/code&gt; is a null pointer).</source>
          <target state="translated">2) 환경 변수가 발견되면 0, 런타임 제한 위반이 발생한 경우 0이 아닙니다. 오류가 발생하면 &lt;code&gt;len&lt;/code&gt; 이 널 포인터가 아닌 한 &lt;code&gt;*len&lt;/code&gt; 에 0을 씁니다 .</target>
        </trans-unit>
        <trans-unit id="531276e5d35d8197265b5cd072ee873c7642baa8" translate="yes" xml:space="preserve">
          <source>2) zero on success (and a copy of the value of &lt;code&gt;stream&lt;/code&gt; is written to &lt;code&gt;*newstreamptr&lt;/code&gt;, non-zero on error (and null pointer is written to &lt;code&gt;*newstreamptr&lt;/code&gt; unless &lt;code&gt;newstreamptr&lt;/code&gt; is itself a null pointer).</source>
          <target state="translated">2) 성공시 0 (및 &lt;code&gt;stream&lt;/code&gt; 값의 사본은 &lt;code&gt;*newstreamptr&lt;/code&gt; 에 기록되고 오류시 0이 &lt;code&gt;newstreamptr&lt;/code&gt; ) ( newstreamptr 자체가 널 포인터가 아닌 경우 널 포인터가 &lt;code&gt;*newstreamptr&lt;/code&gt; 에 기록됨 )</target>
        </trans-unit>
        <trans-unit id="92364cfa2b1b1ce6a7421a5e8fa6da21b7b36037" translate="yes" xml:space="preserve">
          <source>2) zero on success (in which case the number of wide characters excluding terminating zero that were, or would be written to &lt;code&gt;dst&lt;/code&gt;, is stored in &lt;code&gt;*retval&lt;/code&gt;), non-sero on error. In case of a runtime constraint violation, stores &lt;code&gt;(&lt;a href=&quot;../../types/size_t&quot;&gt;size_t&lt;/a&gt;)-1&lt;/code&gt; in &lt;code&gt;*retval&lt;/code&gt; (unless &lt;code&gt;retval&lt;/code&gt; is null) and sets &lt;code&gt;dst[0]&lt;/code&gt; to &lt;code&gt;L'\0'&lt;/code&gt; (unless &lt;code&gt;dst&lt;/code&gt; is null or &lt;code&gt;dstmax&lt;/code&gt; is zero or greater than &lt;code&gt;RSIZE_MAX&lt;/code&gt;)</source>
          <target state="translated">2) 성공시 0 (이 경우 &lt;code&gt;dst&lt;/code&gt; 에 쓰 이거나 종료되는 0을 제외하고 넓은 문자 수가 &lt;code&gt;*retval&lt;/code&gt; 에 저장 됨 ), 오류시 세로가 아님. 런타임 제약 조건 위반의 경우, 점포 &lt;code&gt;(&lt;a href=&quot;../../types/size_t&quot;&gt;size_t&lt;/a&gt;)-1&lt;/code&gt; 에서 &lt;code&gt;*retval&lt;/code&gt; (않는 &lt;code&gt;retval&lt;/code&gt; 널) 및 집합 &lt;code&gt;dst[0]&lt;/code&gt; 에 &lt;code&gt;L'\0'&lt;/code&gt; (않으면 &lt;code&gt;dst&lt;/code&gt; 널이거나 &lt;code&gt;dstmax&lt;/code&gt; 가 제로보다 큰 경우 &lt;code&gt;RSIZE_MAX&lt;/code&gt; 를 )</target>
        </trans-unit>
        <trans-unit id="3e07e61b99111cc46b842fc5800231accfd87e13" translate="yes" xml:space="preserve">
          <source>2) zero on success (in which case the number of wide characters excluding terminating zero that were, or would be written to &lt;code&gt;dst&lt;/code&gt;, is stored in &lt;code&gt;*retval&lt;/code&gt;), non-zero on error. In case of a runtime constraint violation, stores &lt;code&gt;(&lt;a href=&quot;../../types/size_t&quot;&gt;size_t&lt;/a&gt;)-1&lt;/code&gt; in &lt;code&gt;*retval&lt;/code&gt; (unless &lt;code&gt;retval&lt;/code&gt; is null) and sets &lt;code&gt;dst[0]&lt;/code&gt; to &lt;code&gt;L'\0'&lt;/code&gt; (unless &lt;code&gt;dst&lt;/code&gt; is null or &lt;code&gt;dstmax&lt;/code&gt; is zero or greater than &lt;code&gt;RSIZE_MAX&lt;/code&gt;)</source>
          <target state="translated">2) 성공시 0 (이 경우 &lt;code&gt;dst&lt;/code&gt; 에 쓰거나 종료되는 0을 제외한 넓은 문자의 수는 &lt;code&gt;*retval&lt;/code&gt; 에 저장 됨 ), 오류시 0이 아님. 런타임 제약 조건 위반의 경우, 점포 &lt;code&gt;(&lt;a href=&quot;../../types/size_t&quot;&gt;size_t&lt;/a&gt;)-1&lt;/code&gt; 에서 &lt;code&gt;*retval&lt;/code&gt; (않는 &lt;code&gt;retval&lt;/code&gt; 널) 및 집합 &lt;code&gt;dst[0]&lt;/code&gt; 에 &lt;code&gt;L'\0'&lt;/code&gt; (않으면 &lt;code&gt;dst&lt;/code&gt; 널이거나 &lt;code&gt;dstmax&lt;/code&gt; 가 제로보다 큰 경우 &lt;code&gt;RSIZE_MAX&lt;/code&gt; 를 )</target>
        </trans-unit>
        <trans-unit id="b515ed12286378e0786143a5319bc690afc9895b" translate="yes" xml:space="preserve">
          <source>2) zero on success (in which case the string representation of time has been written out to the array pointed to by &lt;code&gt;buffer&lt;/code&gt;), or non-zero on failure (in which case, the terminating null character is always written to &lt;code&gt;buffer[0]&lt;/code&gt; unless &lt;code&gt;buffer&lt;/code&gt; is a null pointer or &lt;code&gt;bufsz&lt;/code&gt; is zero or greater than RSIZE_MAX.</source>
          <target state="translated">2) 성공시 0 (이 경우 문자열이 시간이 나타내는 배열에 &lt;code&gt;buffer&lt;/code&gt; 로 기록됨 ) 또는 실패시 0이 아닌 경우 (이 경우 종료 널 문자는 항상 &lt;code&gt;buffer[0]&lt;/code&gt; 기록됨 [0] 않는 &lt;code&gt;buffer&lt;/code&gt; NULL 포인터 또는 &lt;code&gt;bufsz&lt;/code&gt; 가 없거나 RSIZE_MAX보다 크다.</target>
        </trans-unit>
        <trans-unit id="802b39deab785fd2a26d4ecf259607d610fada68" translate="yes" xml:space="preserve">
          <source>2) zero on success, in which case the multibyte representation of &lt;code&gt;wc&lt;/code&gt; is stored in &lt;code&gt;s&lt;/code&gt; and its length is stored in &lt;code&gt;*status&lt;/code&gt;, or, if &lt;code&gt;s&lt;/code&gt; is null, the shift sequence status is stored in &lt;code&gt;status&lt;/code&gt;). Non-zero on encoding error or runtime constraint violation, in which case &lt;code&gt;(&lt;a href=&quot;../../types/size_t&quot;&gt;size_t&lt;/a&gt;)-1&lt;/code&gt; is stored in &lt;code&gt;*status&lt;/code&gt;. The value stored in &lt;code&gt;*status&lt;/code&gt; never exceeds &lt;code&gt;MB_CUR_MAX&lt;/code&gt;</source>
          <target state="translated">2) 성공시 0,이 경우 &lt;code&gt;wc&lt;/code&gt; 의 멀티 바이트 표현은 &lt;code&gt;s&lt;/code&gt; 에 저장되고 길이는 &lt;code&gt;*status&lt;/code&gt; 에 저장 되거나 &lt;code&gt;s&lt;/code&gt; 가 널인 경우 시프트 시퀀스 상태는 &lt;code&gt;status&lt;/code&gt; )에 저장됩니다 . 인코딩 오류 또는 런타임 제한 조건 위반에서 0이 아닌 경우 &lt;code&gt;(&lt;a href=&quot;../../types/size_t&quot;&gt;size_t&lt;/a&gt;)-1&lt;/code&gt; 이 &lt;code&gt;*status&lt;/code&gt; 에 저장됩니다 . &lt;code&gt;*status&lt;/code&gt; 에 저장된 값은 &lt;code&gt;MB_CUR_MAX&lt;/code&gt; 를 초과하지 않습니다</target>
        </trans-unit>
        <trans-unit id="f14227c0853cfbd0b1c1b4fdb388fc5f15ba00be" translate="yes" xml:space="preserve">
          <source>2) zero on success, non-zero if a runtime constraints violation was detected</source>
          <target state="translated">2) 성공시 0, 런타임 제약 조건 위반이 감지되면 0이 아님</target>
        </trans-unit>
        <trans-unit id="aefb6adf652cac14b2acf90c28f81954f307190b" translate="yes" xml:space="preserve">
          <source>2) zero on success, non-zero on error. Also on error, if &lt;code&gt;dest&lt;/code&gt; is not a null pointer and &lt;code&gt;destsz&lt;/code&gt; is valid, writes &lt;code&gt;destsz&lt;/code&gt; fill bytes &lt;code&gt;ch&lt;/code&gt; to the destination array.</source>
          <target state="translated">2) 성공시 0, 에러시 0이 아님. 또한 오류가 발생하면 &lt;code&gt;dest&lt;/code&gt; 가 널 포인터가 아니고 &lt;code&gt;destsz&lt;/code&gt; 가 유효한 경우 대상 배열에 &lt;code&gt;destsz&lt;/code&gt; fill bytes &lt;code&gt;ch&lt;/code&gt; 를 씁니다 .</target>
        </trans-unit>
        <trans-unit id="829fa46fb637f3df06b12dce694dd672b04e44c4" translate="yes" xml:space="preserve">
          <source>2) zero on success, non-zero on failure, in which case &lt;code&gt;buf[0]&lt;/code&gt; is set to zero (unless &lt;code&gt;buf&lt;/code&gt; is a null pointer or &lt;code&gt;bufsz&lt;/code&gt; is zero or greater than &lt;code&gt;RSIZE_MAX&lt;/code&gt;).</source>
          <target state="translated">2) 성공시 0, 실패시 0이 아닌 경우 &lt;code&gt;buf[0]&lt;/code&gt; 이 0 으로 설정됩니다 ( &lt;code&gt;buf&lt;/code&gt; 가 널 포인터이거나 &lt;code&gt;bufsz&lt;/code&gt; 가 0이거나 &lt;code&gt;RSIZE_MAX&lt;/code&gt; 보다 큰 경우 제외 ).</target>
        </trans-unit>
        <trans-unit id="405efe28a8f5bd51960417b6aaba5705c8199d4b" translate="yes" xml:space="preserve">
          <source>2)&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt; statement</source>
          <target state="translated">2) &lt;a href=&quot;continue&quot;&gt;계속&lt;/a&gt; 진술</target>
        </trans-unit>
        <trans-unit id="9e90011fcacb9996488d9b4a73af2e39d9f91399" translate="yes" xml:space="preserve">
          <source>2)&lt;a href=&quot;conversion#Default_argument_promotions&quot;&gt;Default argument promotions&lt;/a&gt; are performed on every argument expression.</source>
          <target state="translated">2) &lt;a href=&quot;conversion#Default_argument_promotions&quot;&gt;기본 인수 승격&lt;/a&gt; 은 모든 인수 표현식에서 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="e7e98d5ad0f8903f076205ea9692b5296340016c" translate="yes" xml:space="preserve">
          <source>2)&lt;a href=&quot;do&quot;&gt;do-while&lt;/a&gt; loop</source>
          <target state="translated">2) &lt;a href=&quot;do&quot;&gt;do-while&lt;/a&gt; 루프</target>
        </trans-unit>
        <trans-unit id="eab9ae9710f3df51c477c8fc8eba1535e4579efb" translate="yes" xml:space="preserve">
          <source>2)&lt;a href=&quot;if&quot;&gt;if&lt;/a&gt; statement with an else clause</source>
          <target state="translated">2) else 절이있는 &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt; 문</target>
        </trans-unit>
        <trans-unit id="ea9c2e4c31b566c508333139ebb8aebc89c4fef4" translate="yes" xml:space="preserve">
          <source>2)&lt;a href=&quot;operator_alternative&quot;&gt;Trigraph sequences&lt;/a&gt; are replaced by corresponding single-character representations.</source>
          <target state="translated">2) &lt;a href=&quot;operator_alternative&quot;&gt;Trigraph 시퀀스&lt;/a&gt; 는 해당 단일 문자 표현으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="eb3e9785854e958e1ddcaa6bf0e41e71477971c5" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;static&lt;/code&gt;&lt;code&gt;volatile&lt;/code&gt; objects of type &lt;code&gt;&lt;a href=&quot;../program/sig_atomic_t&quot;&gt;sig_atomic_t&lt;/a&gt;&lt;/code&gt; are used for communication with &lt;code&gt;&lt;a href=&quot;../program/signal&quot;&gt;signal&lt;/a&gt;&lt;/code&gt; handlers.</source>
          <target state="translated">2) &lt;code&gt;&lt;a href=&quot;../program/sig_atomic_t&quot;&gt;sig_atomic_t&lt;/a&gt;&lt;/code&gt; 유형의 &lt;code&gt;static&lt;/code&gt; &lt;code&gt;volatile&lt;/code&gt; 객체는 &lt;code&gt;&lt;a href=&quot;../program/signal&quot;&gt;signal&lt;/a&gt;&lt;/code&gt; 처리기 와 통신하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="ccbc1bba81b28ef9c3dc15ca80a9ef2fa5bf6618" translate="yes" xml:space="preserve">
          <source>2*arg</source>
          <target state="translated">2*arg</target>
        </trans-unit>
        <trans-unit id="2994817287f5113c2c93461c53ebec8f3635c2b8" translate="yes" xml:space="preserve">
          <source>2.1.1.2 Translation phases</source>
          <target state="translated">2.1.1.2 번역 단계</target>
        </trans-unit>
        <trans-unit id="cc32c9ee3c93f145dc4db3af7ca9df1471944ed4" translate="yes" xml:space="preserve">
          <source>2.2.1 Character sets</source>
          <target state="translated">2.2.1 문자 세트</target>
        </trans-unit>
        <trans-unit id="e1ff3d5aafd1e9fd983949643b6e122f7bcf5e45" translate="yes" xml:space="preserve">
          <source>2.2.2 Character display semantics</source>
          <target state="translated">2.2.2 문자 표시 의미</target>
        </trans-unit>
        <trans-unit id="e1679ba522ffcdb1dab3a33259b60785779298cf" translate="yes" xml:space="preserve">
          <source>2.2.4.1 Translation limits</source>
          <target state="translated">2.2.4.1 번역 한계</target>
        </trans-unit>
        <trans-unit id="7eb05f281d790790f78faabeb621483c68bf74dd" translate="yes" xml:space="preserve">
          <source>2i</source>
          <target state="translated">2i</target>
        </trans-unit>
        <trans-unit id="77de68daecd823babbb58edb1c8e14d7106e83bb" translate="yes" xml:space="preserve">
          <source>3</source>
          <target state="translated">3</target>
        </trans-unit>
        <trans-unit id="266c2b8b573d0a0d612140e53720836d812e3f6d" translate="yes" xml:space="preserve">
          <source>3) 16-bit wide string literal: The type of the literal is &lt;code&gt;char16_t[N]&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is the size of the string in code units of implementation-defined 16-bit encoding (typically UTF-16), including the null terminator. Each &lt;code&gt;char16_t&lt;/code&gt; element in the array is initialized as if by executing &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbrtoc16&quot;&gt;mbrtoc16&lt;/a&gt;&lt;/code&gt; in implementation-defined locale.</source>
          <target state="translated">3) 16 비트 와이드 문자열 리터럴 : 리터럴의 유형은 &lt;code&gt;char16_t[N]&lt;/code&gt; 이며, 여기서 &lt;code&gt;N&lt;/code&gt; 은 널 종료 자를 포함 하여 구현 정의 된 16 비트 인코딩 (일반적으로 UTF-16)의 코드 단위로 문자열의 크기입니다. . 배열의 각 &lt;code&gt;char16_t&lt;/code&gt; 요소는 구현 정의 로케일에서 &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbrtoc16&quot;&gt;mbrtoc16&lt;/a&gt;&lt;/code&gt; 을 실행하는 것처럼 초기화 됩니다.</target>
        </trans-unit>
        <trans-unit id="3b6cf36c871a0884959965e2b31a0a8f8a9799d9" translate="yes" xml:space="preserve">
          <source>3) 32-bit wide character constant, e.g. &lt;code&gt;U'貓'&lt;/code&gt; or &lt;code&gt;U'🍌'&lt;/code&gt;. Such constant has type &lt;code&gt;char32_t&lt;/code&gt; and a value equal to the value of c-char in in the 32-bit encoding produced by &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbrtoc32&quot;&gt;mbrtoc32&lt;/a&gt;&lt;/code&gt; (normally UTF-32). If c-char is not representable or maps to more than one 32-bit character, the behavior is implementation-defined.</source>
          <target state="translated">3) 32 비트 와이드 문자 상수 (예 : &lt;code&gt;U'貓'&lt;/code&gt; 또는 &lt;code&gt;U'🍌'&lt;/code&gt; . 이러한 상수는 &lt;code&gt;char32_t&lt;/code&gt; 유형 과 &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbrtoc32&quot;&gt;mbrtoc32&lt;/a&gt;&lt;/code&gt; 에 의해 생성 된 32 비트 인코딩 (일반적으로 UTF-32) 에서 c-char 값과 동일한 값을 갖습니다 . c-char를 표현할 수 없거나 둘 이상의 32 비트 문자에 매핑되면 동작이 구현 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="b2693e421cb959cf47981e03486f30a94904f4d2" translate="yes" xml:space="preserve">
          <source>3) All identifiers that begin with an underscore followed by a capital letter or by another underscore (these reserved identifiers allow the library to use numerous behind-the-scenes non-external macros and functions)</source>
          <target state="translated">3) 밑줄로 시작하고 대문자 또는 다른 밑줄로 시작하는 모든 식별자 (이 예약 된 식별자는 라이브러리가 많은 비 장면 비 외부 매크로 및 함수를 사용할 수 있도록합니다)</target>
        </trans-unit>
        <trans-unit id="72455795a2eb56051b09bfa5eae38d55c9855cf4" translate="yes" xml:space="preserve">
          <source>3) At the end of this phase, all preprocessor directives are removed from the source.</source>
          <target state="translated">3)이 단계가 끝나면 모든 전 처리기 지시문이 소스에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="29b20ad2c249b860f2be6a356e8c47c77a48deb5" translate="yes" xml:space="preserve">
          <source>3) Computes the length of the untruncated locale-specific error message that &lt;code&gt;strerror_s&lt;/code&gt; would write if it were called with &lt;code&gt;errnum&lt;/code&gt;. The length does not include the null terminator. As with all bounds-checked functions, &lt;code&gt;strerror_s&lt;/code&gt; and &lt;code&gt;strerrorlen_s&lt;/code&gt; are only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;string.h&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;strerror_s&lt;/code&gt; 가 &lt;code&gt;errnum&lt;/code&gt; 으로 호출 된 경우 쓸 수 있는 잘리지 않은 로케일 특정 오류 메시지의 길이를 계산합니다 . 길이에는 널 종결자가 포함되지 않습니다. 모든 경계 검사 함수와 마찬가지로 &lt;code&gt;strerror_s&lt;/code&gt; 및 &lt;code&gt;strerrorlen_s&lt;/code&gt; 는 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 이 구현에 의해 정의되고 사용자가 &lt;code&gt;string.h&lt;/code&gt; 를 포함하기 전에 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 을 정수 상수 1 로 정의한 경우에만 사용 가능하도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="dd43cfb78903d5f1a897dd65a271db3a4ca8daeb" translate="yes" xml:space="preserve">
          <source>3) Declarator for VLA of unspecified size (can appear in function prototype scope only) where</source>
          <target state="translated">3) 지정되지 않은 크기의 VLA 선언자 (함수 프로토 타입 범위에만 나타날 수 있음)</target>
        </trans-unit>
        <trans-unit id="6a672345c7d337689c23d38a65427bcf157b8fcc" translate="yes" xml:space="preserve">
          <source>3) Default label in a &lt;a href=&quot;switch&quot;&gt;switch&lt;/a&gt; statement.</source>
          <target state="translated">3) &lt;a href=&quot;switch&quot;&gt;스위치&lt;/a&gt; 설명의 기본 레이블 .</target>
        </trans-unit>
        <trans-unit id="d57dfef2b908cf6b7099061e9a9eaa3db4c55d12" translate="yes" xml:space="preserve">
          <source>3) Expands to a value that can be used to initialize an object of type &lt;code&gt;once_flag&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;once_flag&lt;/code&gt; 유형의 객체를 초기화하는 데 사용할 수있는 값으로 확장됩니다 .</target>
        </trans-unit>
        <trans-unit id="5bc955c645fb332677115a707fbd7e2c319b470e" translate="yes" xml:space="preserve">
          <source>3) Hexadecimal integer constant (base 16, the first digit is the most significant, the letters 'a' through 'f' represent the decimal values 10 through 15).</source>
          <target state="translated">3) 16 진 정수 상수 (기수 16, 첫 번째 숫자가 가장 중요하고 문자 'a'- 'f'는 10-15의 10 진수 값을 나타냄)</target>
        </trans-unit>
        <trans-unit id="5ea77eaabad761a7cf22bc8a47a9406df1bc77c4" translate="yes" xml:space="preserve">
          <source>3) If &lt;code&gt;bufsz&lt;/code&gt; is greater than zero, writes the results to a wide string &lt;code&gt;buffer&lt;/code&gt;. At most &lt;code&gt;bufsz-1&lt;/code&gt; wide characters are written followed by null wide character. If &lt;code&gt;bufsz&lt;/code&gt; is zero, nothing is written (and &lt;code&gt;buffer&lt;/code&gt; may be a null pointer), however the return value (number of wide characters that would be written) is still calculated and returned.</source>
          <target state="translated">3) &lt;code&gt;bufsz&lt;/code&gt; 가 0보다 크면 결과를 넓은 문자열 &lt;code&gt;buffer&lt;/code&gt; 씁니다 . 최대 &lt;code&gt;bufsz-1&lt;/code&gt; 와이드 문자는 널 와이드 문자로 작성됩니다. 경우 &lt;code&gt;bufsz&lt;/code&gt; 는 제로, 아무것도 기록되지 않습니다 (그리고 &lt;code&gt;buffer&lt;/code&gt; 널 포인터가 될 수있다), 그러나 반환 값을 (기록 될 것이다 와이드 문자의 수) 아직 계산 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ab655fee316e27400bec8121994a361b2d320ee2" translate="yes" xml:space="preserve">
          <source>3) Informs the compiler that multiplication, division, and absolute value of complex numbers may use simplified mathematical formulas (x+iy)&amp;times;(u+iv) = (xu-yv)+i(yu+xv), (x+iy)/(u+iv) = [(xu+yv)+i(yu-xv)]/(u2</source>
          <target state="translated">3) 복소수의 곱셈, 나눗셈 및 절대 값이 단순화 된 수학 공식 (x + iy) &amp;times; (u + iv) = (xu-yv) + i (yu + xv), (x + iy)를 사용할 수 있음을 컴파일러에 알립니다. ) / (u + iv) = [(xu + yv) + i (yu-xv)] / (u2</target>
        </trans-unit>
        <trans-unit id="ace3fd4e44cb1887db1aa3437a5b5d2746fc7edf" translate="yes" xml:space="preserve">
          <source>3) Length (not including the null terminator) of the message that &lt;code&gt;strerror_s&lt;/code&gt; would return</source>
          <target state="translated">3) &lt;code&gt;strerror_s&lt;/code&gt; 가 리턴 할 메시지의 길이 (널 종결 자를 포함하지 않음)</target>
        </trans-unit>
        <trans-unit id="0293ac9d2bf02d3b0bda679f186ef51e3cb43b49" translate="yes" xml:space="preserve">
          <source>3) Member names: all identifiers declared as members of any one &lt;a href=&quot;struct&quot;&gt;struct&lt;/a&gt; or &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt;. Every struct and union introduces its own name space of this kind.</source>
          <target state="translated">3) 멤버 이름 : 하나의 &lt;a href=&quot;struct&quot;&gt;구조체&lt;/a&gt; 또는 &lt;a href=&quot;union&quot;&gt;공용체의&lt;/a&gt; 멤버로 선언 된 모든 식별자 . 모든 구조체와 공용체는 이런 종류의 네임 스페이스를 도입합니다.</target>
        </trans-unit>
        <trans-unit id="de88b82b934b0dc3a57bd49380a6dbc407b3d266" translate="yes" xml:space="preserve">
          <source>3) Newlines are kept, and it's implementation-defined whether non-newline whitespace sequences may be collapsed into single space characters.</source>
          <target state="translated">3) 줄 바꿈이 유지되며 줄 바꿈이 아닌 공백 시퀀스가 ​​단일 공백 ​​문자로 축소 될 수 있는지 여부는 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="4992765e27fb99e6f3fbdd2ac617b21f20f92375" translate="yes" xml:space="preserve">
          <source>3) Number of wide characters written (not counting the terminating null wide character) if successful or negative value if an encoding error occurred or if the number of characters to be generated was equal or greater than &lt;code&gt;size&lt;/code&gt; (including when &lt;code&gt;size&lt;/code&gt; is zero).</source>
          <target state="translated">3) 인코딩 오류가 발생한 경우 또는 생성 될 문자 수가 &lt;code&gt;size&lt;/code&gt; 보다 크거나 같은 경우 ( &lt;code&gt;size&lt;/code&gt; 가 0 인 경우 포함 ) 기록 된 와이드 문자 수 (종료 널 와이드 문자를 계산하지 않음 ).</target>
        </trans-unit>
        <trans-unit id="eb396cac1b027057cf81569a74313b294cbd6939" translate="yes" xml:space="preserve">
          <source>3) Otherwise, if one operand is &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;float &lt;a href=&quot;../numeric/complex/complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;float &lt;a href=&quot;../numeric/complex/imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt;, the other operand is implicitly converted as follows:</source>
          <target state="translated">3) 그렇지 않으면, 한 피연산자가 &lt;code&gt;float&lt;/code&gt; , &lt;code&gt;float &lt;a href=&quot;../numeric/complex/complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;float &lt;a href=&quot;../numeric/complex/imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt; 인 경우 다른 피연산자는 다음과 같이 암시 적으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="c7d707443d59ff2127ac1eea8be2ee1742850b04" translate="yes" xml:space="preserve">
          <source>3) Performs a &lt;a href=&quot;conversion&quot;&gt;conversion&lt;/a&gt; from the result of the evaluation to the</source>
          <target state="translated">3) 수행 &lt;a href=&quot;conversion&quot;&gt;전환&lt;/a&gt; 받는 평가 결과를 행</target>
        </trans-unit>
        <trans-unit id="82bee8266b37e716412421d4bc6f9b3049ba3d7c" translate="yes" xml:space="preserve">
          <source>3) Reads the data from null-terminated character string &lt;code&gt;buffer&lt;/code&gt;. Reaching the end of the string is equivalent to reaching the end-of-file condition for &lt;code&gt;fscanf&lt;/code&gt;</source>
          <target state="translated">3) null로 끝나는 문자열 &lt;code&gt;buffer&lt;/code&gt; 에서 데이터를 읽습니다 . 문자열의 끝에 도달하는 것은 &lt;code&gt;fscanf&lt;/code&gt; 의 파일 끝 조건에 도달하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ab3574d0b68587f3cf85948d03f166d82c963385" translate="yes" xml:space="preserve">
          <source>3) Reads the data from null-terminated wide string &lt;code&gt;buffer&lt;/code&gt;. Reaching the end of the string is equivalent to reaching the end-of-file condition for &lt;code&gt;fwscanf&lt;/code&gt;</source>
          <target state="translated">3) 널 종료 와이드 스트링 &lt;code&gt;buffer&lt;/code&gt; 에서 데이터를 읽습니다 . 문자열의 끝에 도달하는 것은 &lt;code&gt;fwscanf&lt;/code&gt; 에 대한 파일의 끝 조건에 도달하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b49c7c43563cbc9d5c7264c765e736f5e16f959b" translate="yes" xml:space="preserve">
          <source>3) The &lt;code&gt;static&lt;/code&gt; specifier specifies both static storage duration (unless combined with &lt;code&gt;_Thread_local&lt;/code&gt;)(since C11) and internal linkage (unless used at block scope). It can be used with functions at file scope and with variables at both file and block scope, but not in function parameter lists.</source>
          <target state="translated">3) &lt;code&gt;static&lt;/code&gt; 지정자는 정적 저장 기간 ( &lt;code&gt;_Thread_local&lt;/code&gt; 과 결합되지 않은 경우 ) (C11 이후)과 내부 링크 (블록 범위에서 사용되지 않는 한)를 모두 지정합니다 . 파일 범위의 함수 및 파일 및 블록 범위의 변수와 함께 사용할 수 있지만 함수 매개 변수 목록에는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="98244fd6dd2cac4f83cbbb429d185521b36afc3e" translate="yes" xml:space="preserve">
          <source>3) The above rules apply as long as at least one allowable ordering of subexpressions permits such an unsequenced side-effect.</source>
          <target state="translated">3) 상기 표현 된 규칙들은 적어도 하나의 허용 가능한 하위 표현 순서가 그러한 순서없는 부작용을 허용하는 한 적용된다.</target>
        </trans-unit>
        <trans-unit id="087de3f302ae38f32ae597b193180e09c580d936" translate="yes" xml:space="preserve">
          <source>3) The arguments are evaluated &lt;a href=&quot;eval_order&quot;&gt;in unspecified order and without sequencing&lt;/a&gt;.</source>
          <target state="translated">3) 인수는 &lt;a href=&quot;eval_order&quot;&gt;지정되지 않은 순서로 시퀀싱없이&lt;/a&gt; 평가 됩니다 .</target>
        </trans-unit>
        <trans-unit id="99a25d1bfda3ab89fd10b1a019376ed17dbddf19" translate="yes" xml:space="preserve">
          <source>3) The buffer, which may be replaced by an external, user-provided buffer.</source>
          <target state="translated">3) 버퍼는 외부 사용자 제공 버퍼로 대체 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0108bb1e192b0832c95a18591ce8a43eef60903" translate="yes" xml:space="preserve">
          <source>3) There is a sequence point after evaluation of the first (left) operand and before evaluation of the second or third operand (whichever is evaluated) of the conditional operator &lt;code&gt;?:&lt;/code&gt;</source>
          <target state="translated">3) 조건 연산자 &lt;code&gt;?:&lt;/code&gt; 의 첫 번째 (왼쪽) 피연산자 평가 후와 두 번째 또는 세 번째 피연산자 (평가 된 것 중 하나)의 평가 전 순서 점이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="295654c8321ff1ec4c4e8a96eac87a6e3ed5f21e" translate="yes" xml:space="preserve">
          <source>3) Writes the results to a character string &lt;code&gt;buffer&lt;/code&gt;.</source>
          <target state="translated">3) 결과를 문자열 &lt;code&gt;buffer&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="5809fc7d6999ce52ea11ffe3db1d51ecc57a75e8" translate="yes" xml:space="preserve">
          <source>3) Writes the results to a character string &lt;code&gt;buffer&lt;/code&gt;. The behavior is undefined if the string to be written (plus the terminating null character) exceeds the size of the array pointed to by &lt;code&gt;buffer&lt;/code&gt;.</source>
          <target state="translated">3) 결과를 문자열 &lt;code&gt;buffer&lt;/code&gt; 합니다. 쓰려는 문자열 (및 종료 널 문자)이 &lt;code&gt;buffer&lt;/code&gt; 가 가리키는 배열의 크기를 초과하면 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b5d7e4c42a23c9ad0d074e4c713cf363915fb9a0" translate="yes" xml:space="preserve">
          <source>3) Writes the results to a wide string &lt;code&gt;buffer&lt;/code&gt;. At most &lt;code&gt;bufsz-1&lt;/code&gt; wide characters are written followed by null wide character. The resulting wide character string will be terminated with a null wide character, unless &lt;code&gt;bufsz&lt;/code&gt; is zero.</source>
          <target state="translated">3) 결과를 넓은 문자열 &lt;code&gt;buffer&lt;/code&gt; 합니다. 최대 &lt;code&gt;bufsz-1&lt;/code&gt; 와이드 문자는 널 와이드 문자로 작성됩니다. &lt;code&gt;bufsz&lt;/code&gt; 가 0이 아닌 경우 결과 와이드 문자 스트링은 널 와이드 문자로 종료 됩니다.</target>
        </trans-unit>
        <trans-unit id="04a489ba555c6fcc3c9976d9b52269cfe1cff7db" translate="yes" xml:space="preserve">
          <source>3) bitwise OR</source>
          <target state="translated">3) 비트 OR</target>
        </trans-unit>
        <trans-unit id="7070b86841fe1b8f07d7b3d7a5f388f9fa62ddfb" translate="yes" xml:space="preserve">
          <source>3) identifier that follows the &lt;a href=&quot;operator_member_access&quot;&gt;member access&lt;/a&gt; or member access through pointer operator is looked up in the name space of members of the type determined by the left-hand operand of the member access operator.</source>
          <target state="translated">3) 포인터 액세스를 통한 &lt;a href=&quot;operator_member_access&quot;&gt;멤버 액세스&lt;/a&gt; 또는 멤버 액세스를 따르는 식별자는 멤버 액세스 연산자의 왼쪽 피연산자에 의해 결정된 유형의 멤버의 네임 스페이스에서 조회됩니다.</target>
        </trans-unit>
        <trans-unit id="8cd88d44e9c257314ba2d5ddf6d1513e401f7a2e" translate="yes" xml:space="preserve">
          <source>3) if the expressions are both void, the entire conditional operator expression is a void expression</source>
          <target state="translated">3) 표현식이 모두 void 인 경우 전체 조건부 연산자 표현식이 void 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="2de6178bd332c11188520b24f394b6a8d4c87064" translate="yes" xml:space="preserve">
          <source>3) less or equal expression</source>
          <target state="translated">3) 덜 또는 동등한 표현</target>
        </trans-unit>
        <trans-unit id="f44c6c040dddb70ec82576ab6267822df142415a" translate="yes" xml:space="preserve">
          <source>3) number of characters written to &lt;code&gt;buffer&lt;/code&gt; (not counting the terminating null character), or a negative value if an encoding error (for string and character conversion specifiers) occurred</source>
          <target state="translated">3) &lt;code&gt;buffer&lt;/code&gt; 기록 된 문자 수 (종료 널 문자는 제외) 또는 인코딩 오류 (문자열 및 문자 변환 지정자)가 발생한 경우 음수 값</target>
        </trans-unit>
        <trans-unit id="42f13d0affb282d878d26225489ea73773609cf5" translate="yes" xml:space="preserve">
          <source>3) reads the data from null-terminated character string &lt;code&gt;buffer&lt;/code&gt;. Reaching the end of the string is equivalent to reaching the end-of-file condition for &lt;code&gt;fscanf&lt;/code&gt;</source>
          <target state="translated">3) null로 끝나는 문자열 &lt;code&gt;buffer&lt;/code&gt; 에서 데이터를 읽습니다 . 문자열의 끝에 도달하는 것은 &lt;code&gt;fscanf&lt;/code&gt; 의 파일 끝 조건에 도달하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="88f00f853e307dbc21420f2431f69bd720529b43" translate="yes" xml:space="preserve">
          <source>3) remainder. lhs and rhs must have &lt;a href=&quot;arithmetic_types&quot;&gt;integer types&lt;/a&gt;</source>
          <target state="translated">3) 나머지. lhs 및 rhs는 &lt;a href=&quot;arithmetic_types&quot;&gt;정수 유형&lt;/a&gt; 이어야합니다</target>
        </trans-unit>
        <trans-unit id="0986437470f6ffae4dc9336b670e19309ac17169" translate="yes" xml:space="preserve">
          <source>3) selection statements</source>
          <target state="translated">3) 선택문</target>
        </trans-unit>
        <trans-unit id="e70e88b75520ba3b14d556e5e63d379c0f490d43" translate="yes" xml:space="preserve">
          <source>3) special case: &amp;amp; and * cancel each other, neither one is evaluated</source>
          <target state="translated">3) 특별한 경우 : &amp;amp; 및 * 서로 취소, 둘 다 평가되지 않음</target>
        </trans-unit>
        <trans-unit id="7712853cfa053b3e725230cb507b69f6db7d6baf" translate="yes" xml:space="preserve">
          <source>3) the error about to be returned by the calling function, if it happens to be one of the functions that return &lt;code&gt;errno_t&lt;/code&gt;</source>
          <target state="translated">3) &lt;code&gt;errno_t&lt;/code&gt; 를 리턴하는 함수 중 하나 인 경우 호출 함수에 의해 리턴 될 오류</target>
        </trans-unit>
        <trans-unit id="bcee1e8a3478816b6de7145f029b94e945d5254b" translate="yes" xml:space="preserve">
          <source>3) the rank of any standard integer type is greater than the rank of any extended integer type of the same size (that is, rank of __int64 &amp;lt; rank of long long int, but rank of long long &amp;lt; rank of __int128 due to the rule (1))</source>
          <target state="translated">3) 표준 정수 유형의 순위가 동일한 크기의 확장 정수 유형의 순위보다 큽니다 (즉, __int64 &amp;lt;long long int의 순위이지만 규칙으로 인해 long long의 순위는 __int128입니다). (1))</target>
        </trans-unit>
        <trans-unit id="8ae0ffc38993d8d21256e9209dc22929644d9707" translate="yes" xml:space="preserve">
          <source>3)&lt;a href=&quot;for&quot;&gt;for&lt;/a&gt; loop</source>
          <target state="translated">3) &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt; 루프</target>
        </trans-unit>
        <trans-unit id="bddf507414424214b896ab9e9051dea30ca769e4" translate="yes" xml:space="preserve">
          <source>3)&lt;a href=&quot;generic&quot;&gt;Generic selections&lt;/a&gt;</source>
          <target state="translated">3) &lt;a href=&quot;generic&quot;&gt;일반 선택&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="09be665a43ff233923d1e952627db38e76c238d5" translate="yes" xml:space="preserve">
          <source>3)&lt;a href=&quot;operator_assignment&quot;&gt;Assignment&lt;/a&gt;(until C11)&lt;a href=&quot;initialization&quot;&gt;Initialization&lt;/a&gt;(since C11) is performed to copy the value of each argument to the corresponding function parameter.</source>
          <target state="translated">3) &lt;a href=&quot;operator_assignment&quot;&gt;할당&lt;/a&gt; (C11까지) &lt;a href=&quot;initialization&quot;&gt;초기화&lt;/a&gt; (C11 이후)는 각 인수의 값을 해당 함수 매개 변수에 복사하기 위해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="76a5aebbf4450e00e2a1852f7fc59763596ea344" translate="yes" xml:space="preserve">
          <source>3)&lt;a href=&quot;pointer&quot;&gt;pointer declarator&lt;/a&gt;: the declaration &lt;code&gt;S * cvr D&lt;/code&gt;; declares &lt;code&gt;D&lt;/code&gt; as a cvr-qualified pointer to the type determined by &lt;code&gt;S&lt;/code&gt;.</source>
          <target state="translated">3) &lt;a href=&quot;pointer&quot;&gt;포인터 선언자&lt;/a&gt; : 선언 &lt;code&gt;S * cvr D&lt;/code&gt; ; &lt;code&gt;S&lt;/code&gt; 가 결정한 유형에 대한 cvr 한정 포인터로 &lt;code&gt;D&lt;/code&gt; 를 선언합니다 .</target>
        </trans-unit>
        <trans-unit id="79fb62f404a5738654e316eeeab8c5ebe700960b" translate="yes" xml:space="preserve">
          <source>3)&lt;a href=&quot;return&quot;&gt;return&lt;/a&gt; statement with an optional expression</source>
          <target state="translated">3) 선택적 표현식을 포함한 &lt;a href=&quot;return&quot;&gt;리턴&lt;/a&gt; 문</target>
        </trans-unit>
        <trans-unit id="c81e8c670bf9ead00a5d6c1c9fe196d08a965dd9" translate="yes" xml:space="preserve">
          <source>3)&lt;a href=&quot;switch&quot;&gt;switch&lt;/a&gt; statement</source>
          <target state="translated">3) &lt;a href=&quot;switch&quot;&gt;스위치&lt;/a&gt; 설명</target>
        </trans-unit>
        <trans-unit id="afe19fcba7ae0cdcb65b70484d85cfeb9cd02b6f" translate="yes" xml:space="preserve">
          <source>3)&lt;code&gt;volatile&lt;/code&gt; variables that are local to a function that contains an invocation of the &lt;code&gt;&lt;a href=&quot;../program/setjmp&quot;&gt;setjmp&lt;/a&gt;&lt;/code&gt; macro are the only local variables guaranteed to retain their values after &lt;code&gt;&lt;a href=&quot;../program/longjmp&quot;&gt;longjmp&lt;/a&gt;&lt;/code&gt; returns.</source>
          <target state="translated">3) &lt;code&gt;&lt;a href=&quot;../program/setjmp&quot;&gt;setjmp&lt;/a&gt;&lt;/code&gt; 매크로 의 호출을 포함하는 함수에 로컬 인 &lt;code&gt;volatile&lt;/code&gt; 변수는 &lt;code&gt;&lt;a href=&quot;../program/longjmp&quot;&gt;longjmp&lt;/a&gt;&lt;/code&gt; 리턴 후에 값을 유지하도록 보장되는 유일한 로컬 변수 입니다.</target>
        </trans-unit>
        <trans-unit id="2b3436dbf6dcfedcb8aae6f43b748b15d781c38b" translate="yes" xml:space="preserve">
          <source>3.1 Lexical elements</source>
          <target state="translated">3.1 어휘 요소</target>
        </trans-unit>
        <trans-unit id="aa23d608ab598bf5c82cb15f916c962be2d3f1c1" translate="yes" xml:space="preserve">
          <source>3.1.1 Keywords</source>
          <target state="translated">3.1.1 키워드</target>
        </trans-unit>
        <trans-unit id="35f2b78a7d39e51f2b229238eaac9dc19a3a8957" translate="yes" xml:space="preserve">
          <source>3.1.2 Identifiers</source>
          <target state="translated">3.1.2 식별자</target>
        </trans-unit>
        <trans-unit id="69bb3daff55b0aa6f139fdcfc0d1b561f9c73d8d" translate="yes" xml:space="preserve">
          <source>3.1.2.1 Scopes of identifiers</source>
          <target state="translated">3.1.2.1 식별자의 범위</target>
        </trans-unit>
        <trans-unit id="053917ec57d4bb610630756c05366bafa4dc4a6f" translate="yes" xml:space="preserve">
          <source>3.1.2.2 Linkages of identifiers</source>
          <target state="translated">3.1.2.2 식별자의 연결</target>
        </trans-unit>
        <trans-unit id="c16e7d8c541e2fcda369edfebc9735f09af6f243" translate="yes" xml:space="preserve">
          <source>3.1.2.3 Name spaces of identifiers</source>
          <target state="translated">식별자의 네임 스페이스</target>
        </trans-unit>
        <trans-unit id="6ad4470b91e8cb6ef9aa189835b62494d6821bd5" translate="yes" xml:space="preserve">
          <source>3.1.2.4 Storage durations of objects</source>
          <target state="translated">3.1.2.4 객체의 저장 기간</target>
        </trans-unit>
        <trans-unit id="693ae4f49d6cb492368f42e0a653d007189f80e0" translate="yes" xml:space="preserve">
          <source>3.1.2.5 Types</source>
          <target state="translated">3.1.2.5 유형</target>
        </trans-unit>
        <trans-unit id="6e4a0687a12139db1517807b70a32a763a58b472" translate="yes" xml:space="preserve">
          <source>3.1.2.6 Compatible type and composite type</source>
          <target state="translated">3.1.2.6 호환 유형 및 복합 유형</target>
        </trans-unit>
        <trans-unit id="46d3abd3853f75316b2251ebeebf8565fb53a1ce" translate="yes" xml:space="preserve">
          <source>3.1.3.1 Floating constants</source>
          <target state="translated">부동 상수</target>
        </trans-unit>
        <trans-unit id="49432d6d1c54f5c0e993d15db7428d4a32c726bf" translate="yes" xml:space="preserve">
          <source>3.1.3.2 Integer constants</source>
          <target state="translated">3.1.3.2 정수 상수</target>
        </trans-unit>
        <trans-unit id="38d2a99222e11d82ab3c7059149486bff4538b2e" translate="yes" xml:space="preserve">
          <source>3.1.3.4 Character constants</source>
          <target state="translated">3.1.3.4 문자 상수</target>
        </trans-unit>
        <trans-unit id="009e43a6939dbd0e635e3626636d88e41f3c3926" translate="yes" xml:space="preserve">
          <source>3.1.4 String literals</source>
          <target state="translated">3.1.4 문자열 리터럴</target>
        </trans-unit>
        <trans-unit id="c83b17993430bc6414639087a7c16f3cca127e9e" translate="yes" xml:space="preserve">
          <source>3.1.9 Comments</source>
          <target state="translated">3.1.9 코멘트</target>
        </trans-unit>
        <trans-unit id="1d3cd2d64ff696dd403e1b5b61d2545b717c75b5" translate="yes" xml:space="preserve">
          <source>3.14 memory location (p: 5)</source>
          <target state="translated">3.14 메모리 위치 (p : 5)</target>
        </trans-unit>
        <trans-unit id="44f6c943165d32b1da0989e5035d03939edeeed4" translate="yes" xml:space="preserve">
          <source>3.14 object (p: 5)</source>
          <target state="translated">3.14 대상 (p : 5)</target>
        </trans-unit>
        <trans-unit id="a8b713a7ab44f55836b09d74af0d4189af1abf3b" translate="yes" xml:space="preserve">
          <source>3.15 object (p: 6)</source>
          <target state="translated">3.15 객체 (p : 6)</target>
        </trans-unit>
        <trans-unit id="cbf8f9e9df4ffc9461bbb22d125674a380a6099b" translate="yes" xml:space="preserve">
          <source>3.2 Conversions</source>
          <target state="translated">3.2 전환</target>
        </trans-unit>
        <trans-unit id="867d71616611d1346c597166e6a33509b104fd76" translate="yes" xml:space="preserve">
          <source>3.2 alignment (p: 3)</source>
          <target state="translated">3.2 정렬 (p : 3)</target>
        </trans-unit>
        <trans-unit id="7128668c707a8c23be42f991f4b21ead64b568d4" translate="yes" xml:space="preserve">
          <source>3.2.2.1 Lvalues and function designators</source>
          <target state="translated">3.2.2.1 L 값과 함수 지정자</target>
        </trans-unit>
        <trans-unit id="1e4aab47ee4c5fed87a687344db69553cdc2ef06" translate="yes" xml:space="preserve">
          <source>3.3 EXPRESSIONS</source>
          <target state="translated">3.3 표현</target>
        </trans-unit>
        <trans-unit id="5ba67778c27000fb60aba8ee5b8fa080d6476d96" translate="yes" xml:space="preserve">
          <source>3.3.10 Bitwise AND operator</source>
          <target state="translated">비트 AND 연산자</target>
        </trans-unit>
        <trans-unit id="245fbf15c4e5116335baf25524423e4b14362299" translate="yes" xml:space="preserve">
          <source>3.3.11 Bitwise exclusive OR operator</source>
          <target state="translated">비트 배타적 OR 연산자</target>
        </trans-unit>
        <trans-unit id="671f55bc53c88c3c0adaa53dda6121e67acfc35a" translate="yes" xml:space="preserve">
          <source>3.3.12 Bitwise inclusive OR operator</source>
          <target state="translated">비트 단위의 OR 연산자</target>
        </trans-unit>
        <trans-unit id="81f6c0f1537a5e52c6a8f60ff54ee31eb892193b" translate="yes" xml:space="preserve">
          <source>3.3.13 Logical AND operator</source>
          <target state="translated">논리 AND 연산자</target>
        </trans-unit>
        <trans-unit id="b0ed3543f8231c3bab455b6193d443f0bba59d3e" translate="yes" xml:space="preserve">
          <source>3.3.14 Logical OR operator</source>
          <target state="translated">논리 OR 연산자</target>
        </trans-unit>
        <trans-unit id="a5dab4b48a06f39398ce9c3f44c37404b9cd649f" translate="yes" xml:space="preserve">
          <source>3.3.15 Conditional operator</source>
          <target state="translated">3.3.15 조건부 연산자</target>
        </trans-unit>
        <trans-unit id="e2568624bafc6fc575edc3bd40d39cf349778cb1" translate="yes" xml:space="preserve">
          <source>3.3.16 Assignment operators</source>
          <target state="translated">할당 연산자</target>
        </trans-unit>
        <trans-unit id="2fb56ecae51be110565d70d098eaa63dcd633d8e" translate="yes" xml:space="preserve">
          <source>3.3.17 Comma operator</source>
          <target state="translated">쉼표 연산자</target>
        </trans-unit>
        <trans-unit id="8fad8b5742570f27e7d76575d000d851ed1025e0" translate="yes" xml:space="preserve">
          <source>3.3.2.1 Array subscripting</source>
          <target state="translated">3.3.2.1 배열 첨자</target>
        </trans-unit>
        <trans-unit id="b30a05bbc8bba699fd34d0c538ea05d388506f8c" translate="yes" xml:space="preserve">
          <source>3.3.2.2 Function calls</source>
          <target state="translated">3.3.2.2 함수 호출</target>
        </trans-unit>
        <trans-unit id="37b578598525a526f46c0bc9cff22a80c55be73a" translate="yes" xml:space="preserve">
          <source>3.3.2.3 Structure and union members</source>
          <target state="translated">3.3.2.3 구조와 노조원</target>
        </trans-unit>
        <trans-unit id="83b935639f53991d667857491ffe96b4b9ec7b24" translate="yes" xml:space="preserve">
          <source>3.3.2.4 Postfix increment and decrement operators</source>
          <target state="translated">3.3.2.4 접미사 증가 및 감소 연산자</target>
        </trans-unit>
        <trans-unit id="6a1f3964bb47c00a0313f5d1e24e75c55d3eb6cf" translate="yes" xml:space="preserve">
          <source>3.3.3.1 Prefix increment and decrement operators</source>
          <target state="translated">접두사 증가 및 감소 연산자</target>
        </trans-unit>
        <trans-unit id="c0fa37d710b7e31f2526aacb78104a801fbc700f" translate="yes" xml:space="preserve">
          <source>3.3.3.2 Address and indirection operators</source>
          <target state="translated">3.3.3.2 주소 및 간접 연산자</target>
        </trans-unit>
        <trans-unit id="d86e5c85cec88c41bbf84caeebe7ae700d5097de" translate="yes" xml:space="preserve">
          <source>3.3.3.3 Unary arithmetic operators</source>
          <target state="translated">단항 산술 연산자</target>
        </trans-unit>
        <trans-unit id="c8d89bb11e1be89a06d2ee545e6bf1657d18138a" translate="yes" xml:space="preserve">
          <source>3.3.3.4 The sizeof operator</source>
          <target state="translated">3.3.3.4 연산자의 크기</target>
        </trans-unit>
        <trans-unit id="59361dc2a7cc51cec129447be682cf17fe15b17f" translate="yes" xml:space="preserve">
          <source>3.3.4 Cast operators</source>
          <target state="translated">3.3.4 캐스트 연산자</target>
        </trans-unit>
        <trans-unit id="36da0772702b6cd80542d8768c10faed0962a575" translate="yes" xml:space="preserve">
          <source>3.3.5 Multiplicative operators</source>
          <target state="translated">3.3.5 곱하기 연산자</target>
        </trans-unit>
        <trans-unit id="03f710804c2df0e833878cc8516e3fa73e052d6d" translate="yes" xml:space="preserve">
          <source>3.3.6 Additive operators</source>
          <target state="translated">3.3.6 가산 연산자</target>
        </trans-unit>
        <trans-unit id="2e487adc7718096e68e3d672ae2ddf706204f757" translate="yes" xml:space="preserve">
          <source>3.3.7 Bitwise shift operators</source>
          <target state="translated">비트 시프트 연산자</target>
        </trans-unit>
        <trans-unit id="333c3885b46c7f03c63150a6ce62e5cd85706955" translate="yes" xml:space="preserve">
          <source>3.3.8 Relational operators</source>
          <target state="translated">3.3.8 관계 연산자</target>
        </trans-unit>
        <trans-unit id="ec41a6586c4f97c0dbe5f09344f06d840884277c" translate="yes" xml:space="preserve">
          <source>3.3.9 Equality operators</source>
          <target state="translated">3.3.9 평등 연산자</target>
        </trans-unit>
        <trans-unit id="10dbea6b4db6473daef948da832d6fe6def84bbc" translate="yes" xml:space="preserve">
          <source>3.4 Behavior (p: 3-4)</source>
          <target state="translated">3.4 행동 (p : 3-4)</target>
        </trans-unit>
        <trans-unit id="621a53d66b32379b698d08874e6e491ce1ee41d4" translate="yes" xml:space="preserve">
          <source>3.4 CONSTANT EXPRESSIONS</source>
          <target state="translated">3.4 상수 표현</target>
        </trans-unit>
        <trans-unit id="6f123c074dabed3b04908f1b204fa1b057f2c701" translate="yes" xml:space="preserve">
          <source>3.5 Declarations</source>
          <target state="translated">3.5 선언</target>
        </trans-unit>
        <trans-unit id="d02d8b23cc7cc0687bf094e6449e12f893cc4592" translate="yes" xml:space="preserve">
          <source>3.5.1 Storage-class specifiers</source>
          <target state="translated">3.5.1 스토리지 클래스 지정자</target>
        </trans-unit>
        <trans-unit id="4ea5468a9f777545da30f0aa50f3c66e64a9e29d" translate="yes" xml:space="preserve">
          <source>3.5.2.1 Structure and union specifiers</source>
          <target state="translated">3.5.2.1 구조와 공용체 지정자</target>
        </trans-unit>
        <trans-unit id="cde3b08fffd8937ec2997b4294022e8d488c084d" translate="yes" xml:space="preserve">
          <source>3.5.2.2 Enumeration specifiers</source>
          <target state="translated">3.5.2.2 열거 형 지정자</target>
        </trans-unit>
        <trans-unit id="66f6433b945e8bed23a00be202c9616504f5db74" translate="yes" xml:space="preserve">
          <source>3.5.3 Type qualifiers</source>
          <target state="translated">3.5.3 타입 한정자</target>
        </trans-unit>
        <trans-unit id="c9ef31821bf865df3a3c32ff038f42d3ad3c3e9f" translate="yes" xml:space="preserve">
          <source>3.5.4.1 Pointer declarators</source>
          <target state="translated">3.5.4.1 포인터 선언자</target>
        </trans-unit>
        <trans-unit id="91fc4de5c1c8638e96b45045217083b6e16b45b8" translate="yes" xml:space="preserve">
          <source>3.5.4.2 Array declarators</source>
          <target state="translated">3.5.4.2 배열 선언자</target>
        </trans-unit>
        <trans-unit id="9454a74b9fba2774496cc2714a24c180e161fcf4" translate="yes" xml:space="preserve">
          <source>3.5.4.3 Function declarators (including prototypes)</source>
          <target state="translated">3.5.4.3 함수 선언자 (시제품 포함)</target>
        </trans-unit>
        <trans-unit id="5fa9d3cc8c91f86cc2fb8ed5538d29397114ac50" translate="yes" xml:space="preserve">
          <source>3.5.4.3/5 Function declarators (including prototypes)</source>
          <target state="translated">3.5.4.3/5 함수 선언자 (시제품 포함)</target>
        </trans-unit>
        <trans-unit id="15c84b5f4ca339bcdebb101c9bb2208d258c2d05" translate="yes" xml:space="preserve">
          <source>3.5.6 Type definitions</source>
          <target state="translated">3.5.6 타입 정의</target>
        </trans-unit>
        <trans-unit id="92da4d9e083e0b6b8c4dbadb3d208f9d2930891f" translate="yes" xml:space="preserve">
          <source>3.6 STATEMENTS</source>
          <target state="translated">3.6 진술</target>
        </trans-unit>
        <trans-unit id="0da2b15a7f16be29e2c30b5ccc26f248b5beed38" translate="yes" xml:space="preserve">
          <source>3.6 byte (p: 4)</source>
          <target state="translated">3.6 바이트 (p : 4)</target>
        </trans-unit>
        <trans-unit id="a04d8c10d5b6f12d5409f66240f68fea7f2967f3" translate="yes" xml:space="preserve">
          <source>3.6.4.1 The if statement</source>
          <target state="translated">3.6.4.1 if 문</target>
        </trans-unit>
        <trans-unit id="84c405ff47c1823b1986d69a0317d3fc753b1a87" translate="yes" xml:space="preserve">
          <source>3.6.4.2 The switch statement</source>
          <target state="translated">3.6.4.2 스위치 설명</target>
        </trans-unit>
        <trans-unit id="b184b74a9a3bd7e0ae3da1d9dc1ad66a2fd46cb6" translate="yes" xml:space="preserve">
          <source>3.6.5.1 The while statement</source>
          <target state="translated">3.6.5.1 while 서술문</target>
        </trans-unit>
        <trans-unit id="8fe64ddeb6f75ed97b0c76292fbee6919273ce81" translate="yes" xml:space="preserve">
          <source>3.6.5.2 The do statement</source>
          <target state="translated">3.6.5.2 do 문</target>
        </trans-unit>
        <trans-unit id="652267cefb5a361c6d9a10e587b8f9ac7c93d7f8" translate="yes" xml:space="preserve">
          <source>3.6.5.3 The for statement</source>
          <target state="translated">3.6.5.3 for 문</target>
        </trans-unit>
        <trans-unit id="2fbb79f170ab9f4a8ce31d6ef2d123a9a454decc" translate="yes" xml:space="preserve">
          <source>3.6.6.1 The goto statement</source>
          <target state="translated">3.6.6.1 goto 선언문</target>
        </trans-unit>
        <trans-unit id="4989e665bf653d26d78e6bf2ca2ad1172e0eb834" translate="yes" xml:space="preserve">
          <source>3.6.6.2 The continue statement</source>
          <target state="translated">3.6.6.2 continue 문</target>
        </trans-unit>
        <trans-unit id="747e4fdc75c141d50d5270f9f02237dd0b9894f7" translate="yes" xml:space="preserve">
          <source>3.6.6.3 The break statement</source>
          <target state="translated">3.6.6.3 중단 진술</target>
        </trans-unit>
        <trans-unit id="96f4bfef731d39e6a5a0ade365aee094e5b8b8bf" translate="yes" xml:space="preserve">
          <source>3.6.6.4 The return statement</source>
          <target state="translated">3.6.6.4 반환 진술</target>
        </trans-unit>
        <trans-unit id="fb53ee844dd1f04b882aee7b6e5b91e743eeea84" translate="yes" xml:space="preserve">
          <source>3.7 EXTERNAL DEFINITIONS</source>
          <target state="translated">3.7 외부 정의</target>
        </trans-unit>
        <trans-unit id="919b920bc34add8d1fa979a68f145fd0b5da394a" translate="yes" xml:space="preserve">
          <source>3.7.1 Function definitions</source>
          <target state="translated">3.7.1 기능 정의</target>
        </trans-unit>
        <trans-unit id="a0760c0282abb1f6c104ef8913c4daa2ebb9965d" translate="yes" xml:space="preserve">
          <source>3.8 PREPROCESSING DIRECTIVES</source>
          <target state="translated">3.8 사전 처리 지시어</target>
        </trans-unit>
        <trans-unit id="479e1f767a55fb61f6833b4dea58c5816020bc97" translate="yes" xml:space="preserve">
          <source>3.8.1 Conditional inclusion</source>
          <target state="translated">3.8.1 조건부 포함</target>
        </trans-unit>
        <trans-unit id="4404fc10f9ba26fabfdb15bd4deea6e185402fd1" translate="yes" xml:space="preserve">
          <source>3.8.2 Source file inclusion</source>
          <target state="translated">3.8.2 소스 파일 포함</target>
        </trans-unit>
        <trans-unit id="5ce893f6c9ecd4a5dbe75cf7cf3a90948b11c8aa" translate="yes" xml:space="preserve">
          <source>3.8.3 Macro replacement</source>
          <target state="translated">3.8.3 매크로 교체</target>
        </trans-unit>
        <trans-unit id="077e2c11d5f1e129e85fd9c2c15827ba00165988" translate="yes" xml:space="preserve">
          <source>3.8.4 Line control</source>
          <target state="translated">3.8.4 라인 제어</target>
        </trans-unit>
        <trans-unit id="3a5172789b93cdbb5e63e2756004b632a0adf775" translate="yes" xml:space="preserve">
          <source>3.8.5 Error directive</source>
          <target state="translated">오류 지시어</target>
        </trans-unit>
        <trans-unit id="12bec98cf661dbd4b72b014110dbed9268259826" translate="yes" xml:space="preserve">
          <source>3.8.6 Pragma directive</source>
          <target state="translated">3.8.6 Pragma 지시어</target>
        </trans-unit>
        <trans-unit id="539a2d888497fc54dadc01afdbe7ef1ee669face" translate="yes" xml:space="preserve">
          <source>3.8.8 Predefined macro names</source>
          <target state="translated">3.8.8 사전 정의 된 매크로 이름</target>
        </trans-unit>
        <trans-unit id="9bfad27ebb3e7aa32f85e15bc4734fc3cfedf0b8" translate="yes" xml:space="preserve">
          <source>31 significant initial characters in an external identifier</source>
          <target state="translated">외부 식별자에서 31 개의 중요한 초기 문자</target>
        </trans-unit>
        <trans-unit id="dce46547e7a48e8acbf29462c258a56a5357b094" translate="yes" xml:space="preserve">
          <source>31 significant initial characters in an internal identifier or a macro name</source>
          <target state="translated">내부 식별자 또는 매크로 이름에 31 개의 중요한 초기 문자</target>
        </trans-unit>
        <trans-unit id="cb4e5208b4cd87268b208e49452ed6e89a68e0b8" translate="yes" xml:space="preserve">
          <source>32</source>
          <target state="translated">32</target>
        </trans-unit>
        <trans-unit id="06e6c1113c2f4580d7903420158b27e7b8a665dc" translate="yes" xml:space="preserve">
          <source>32 bit systems:</source>
          <target state="translated">32 비트 시스템 :</target>
        </trans-unit>
        <trans-unit id="089741c85f4bf039e8852907ba7ef67b37a404cd" translate="yes" xml:space="preserve">
          <source>32-bit wide character type</source>
          <target state="translated">32 비트 와이드 문자 유형</target>
        </trans-unit>
        <trans-unit id="8d722ddc76a98c8bd0825292353d73caeec2bfca" translate="yes" xml:space="preserve">
          <source>33&amp;ndash;47</source>
          <target state="translated">33&amp;ndash;47</target>
        </trans-unit>
        <trans-unit id="1b6453892473a467d07372d45eb05abc2031647a" translate="yes" xml:space="preserve">
          <source>4</source>
          <target state="translated">4</target>
        </trans-unit>
        <trans-unit id="cd67d4bcff32d45711fc0c9f76515c5cdbaa93c3" translate="yes" xml:space="preserve">
          <source>4 Conformance (p: 7-8)</source>
          <target state="translated">4 적합성 (p : 7-8)</target>
        </trans-unit>
        <trans-unit id="9778299467a48895f04c6592b05bd1f73fad80a4" translate="yes" xml:space="preserve">
          <source>4 Conformance (p: 8-9)</source>
          <target state="translated">4 적합성 (p : 8-9)</target>
        </trans-unit>
        <trans-unit id="c4ba61ba8a5398897deba4f21a58252002daa2b5" translate="yes" xml:space="preserve">
          <source>4 LIBRARY</source>
          <target state="translated">4 라이브러리</target>
        </trans-unit>
        <trans-unit id="d8e96dd55455d60ce34fafac1d569222c1890081" translate="yes" xml:space="preserve">
          <source>4) 32-bit wide string literal: The type of the literal is &lt;code&gt;char32_t[N]&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is the size of the string in code units of implementation-defined 32-bit encoding (typically UTF-32), including the null terminator. Each &lt;code&gt;char32_t&lt;/code&gt; element in the array is initialized as if by executing &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbrtoc32&quot;&gt;mbrtoc32&lt;/a&gt;&lt;/code&gt; in implementation-defined locale.</source>
          <target state="translated">4) 32 비트 와이드 문자열 리터럴 : 리터럴의 유형은 &lt;code&gt;char32_t[N]&lt;/code&gt; 이며, 여기서 &lt;code&gt;N&lt;/code&gt; 은 널 종료 자를 포함 하여 구현 정의 된 32 비트 인코딩 (일반적으로 UTF-32)의 코드 단위로 문자열의 크기입니다. . 배열의 각 &lt;code&gt;char32_t&lt;/code&gt; 요소는 구현 정의 로케일에서 &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbrtoc32&quot;&gt;mbrtoc32&lt;/a&gt;&lt;/code&gt; 를 실행하는 것처럼 초기화 됩니다.</target>
        </trans-unit>
        <trans-unit id="61a00821ee36a8decdad7ae747b95cb632e17bd9" translate="yes" xml:space="preserve">
          <source>4) All external identifiers defined by the standard library (in hosted environment). This means that no user-supplied external names are allowed to match any library names, not even if declaring a function that is identical to a library function.</source>
          <target state="translated">4) 호스트 라이브러리에서 표준 라이브러리에 의해 정의 된 모든 외부 식별자. 이는 사용자가 제공 한 외부 이름이 라이브러리 기능과 동일한 기능을 선언하더라도 라이브러리 이름과 일치 할 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="cdab1f245c751325e7566b1fe206dfefcaefa5b4" translate="yes" xml:space="preserve">
          <source>4) All other identifiers, called</source>
          <target state="translated">4) 다른 모든 식별자</target>
        </trans-unit>
        <trans-unit id="2350b87dbcb1d0a81491976620232316b99b2598" translate="yes" xml:space="preserve">
          <source>4) Function is executed, and the value it returns becomes the value of the function call expression (if the function returns void, the function call expression is a void expression)</source>
          <target state="translated">4) 함수가 실행되고 반환되는 값이 함수 호출 표현식의 값이됩니다 (함수가 void를 리턴하면 함수 호출 표현식이 void 표현식 임)</target>
        </trans-unit>
        <trans-unit id="7eb38e23bbbfb5f8495a1647b223c0ca85fa4348" translate="yes" xml:space="preserve">
          <source>4) I/O mode: input, output, or update (both input and output).</source>
          <target state="translated">4) I / O 모드 : 입력, 출력 또는 업데이트 (입력 및 출력 모두).</target>
        </trans-unit>
        <trans-unit id="9074f5dbd5633608b3a29f3a861f1899d5ced878" translate="yes" xml:space="preserve">
          <source>4) In addition, volatile variables can be used to disable certain forms of optimization, e.g. to disable dead store elimination or constant folding for microbenchmarks.</source>
          <target state="translated">4) 또한 휘발성 변수를 사용하여 특정 형태의 최적화를 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d986890f2e5d0ce2f108ff350c5d122253bc2416" translate="yes" xml:space="preserve">
          <source>4) Otherwise, both operands are integers. In that case, First of all, both operands undergo</source>
          <target state="translated">4) 그렇지 않으면 두 피연산자가 모두 정수입니다. 이 경우, 우선 두 피연산자가 모두</target>
        </trans-unit>
        <trans-unit id="b06acd39eb731c8675a54e7171445d587e271e97" translate="yes" xml:space="preserve">
          <source>4) The &lt;code&gt;extern&lt;/code&gt; specifier specifies static storage duration (unless combined with &lt;code&gt;_Thread_local&lt;/code&gt;)(since C11) and external linkage. It can be used with function and object declarations in both file and block scope (excluding function parameter lists). If &lt;code&gt;extern&lt;/code&gt; appears on a redeclaration of an identifier that was already declared with internal linkage, the linkage remains internal. Otherwise (if the prior declaration was external, no-linkage, or is not in scope), the linkage is external.</source>
          <target state="translated">4) &lt;code&gt;extern&lt;/code&gt; 지정자는 정적 저장 기간 ( &lt;code&gt;_Thread_local&lt;/code&gt; 이후) 과 _Thread_local 과 결합되지 않은 경우 와 외부 연결을 지정합니다. 파일 및 블록 범위 모두에서 함수 및 객체 선언과 함께 사용할 수 있습니다 (함수 매개 변수 목록 제외). 내부 연결로 이미 선언 된 식별자의 재 선언에 &lt;code&gt;extern&lt;/code&gt; 이 나타나는 경우 연결은 내부로 유지됩니다. 그렇지 않으면 (사전 선언이 외부 적이거나 연계가 없거나 범위 내에 있지 않은 경우) 연계는 외부 적입니다.</target>
        </trans-unit>
        <trans-unit id="727d7e12a4fb3e05a7633abcfa4c18bd53b4732a" translate="yes" xml:space="preserve">
          <source>4) The number of characters written if successful or negative value if an error occurred. If the resulting string gets truncated due to &lt;code&gt;buf_size&lt;/code&gt; limit, function returns the total number of characters (not including the terminating null-byte) which would have been written, if the limit was not imposed.</source>
          <target state="translated">4) 성공한 경우 쓰여진 문자 수 또는 오류가 발생한 경우 음수 값. &lt;code&gt;buf_size&lt;/code&gt; 한계 로 인해 결과 문자열이 잘리는 경우 함수는 한계가 적용되지 않은 경우 쓰여질 총 문자 수 (종료 널 바이트 제외)를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="831b4f844595f3594e52f73186d7764c10de8287" translate="yes" xml:space="preserve">
          <source>4) The number of wide characters written if successful or negative value if an error occurred. If the resulting string gets truncated due to &lt;code&gt;bufsz&lt;/code&gt; limit, function returns the total number of characters (not including the terminating null wide character) which would have been written, if the limit were not imposed.</source>
          <target state="translated">4) 성공한 경우 기록 된 와이드 문자 수 또는 오류가 발생한 경우 음수 값. &lt;code&gt;bufsz&lt;/code&gt; limit 으로 인해 결과 문자열이 잘 리면 함수는 제한이 적용되지 않은 경우 쓰여질 총 문자 수 (종료 널 와이드 문자 제외)를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="90ee93cccda86447fccbdcf2b7eece99c8b69a57" translate="yes" xml:space="preserve">
          <source>4) There is a sequence point after the evaluation of a full expression (an expression that is not a subexpression: typically something that ends with a semicolon or a controlling statement of if/switch/while/do) and before the next full expression.</source>
          <target state="translated">4) 전체 표현식 (하위 표현식이 아닌 표현식 : 일반적으로 세미콜론 또는 if / switch / while / do에 대한 제어문으로 끝나는 표현식)을 평가 한 후 다음 전체 표현식 앞에 시퀀스 포인트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c8c3b8b8f9cb107aff7b974376a8d21993c5377" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If &lt;code&gt;arg&lt;/code&gt; has type &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;cbrtl&lt;/code&gt; is called. Otherwise, if &lt;code&gt;arg&lt;/code&gt; has integer type or the type &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;cbrt&lt;/code&gt; is called. Otherwise, &lt;code&gt;cbrtf&lt;/code&gt; is called.</source>
          <target state="translated">4) 형 제네릭 매크로 : 경우 &lt;code&gt;arg&lt;/code&gt; 유형이 &lt;code&gt;long double&lt;/code&gt; , &lt;code&gt;cbrtl&lt;/code&gt; 가 호출된다. 그렇지 않으면, &lt;code&gt;arg&lt;/code&gt; 가 정수 유형이거나 &lt;code&gt;double&lt;/code&gt; 유형 인 경우 &lt;code&gt;cbrt&lt;/code&gt; 가 호출됩니다. 그렇지 않으면 &lt;code&gt;cbrtf&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="bfa0b79abdfa71fa35ea31a5dcf5c5fb590cb813" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If &lt;code&gt;arg&lt;/code&gt; has type &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;ceill&lt;/code&gt; is called. Otherwise, if &lt;code&gt;arg&lt;/code&gt; has integer type or the type &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;ceil&lt;/code&gt; is called. Otherwise, &lt;code&gt;ceilf&lt;/code&gt; is called.</source>
          <target state="translated">4) 타입-일반 매크로 : &lt;code&gt;arg&lt;/code&gt; 가 &lt;code&gt;long double&lt;/code&gt; 타입을 가지고 있다면 , &lt;code&gt;ceill&lt;/code&gt; 이 호출됩니다. 그렇지 않으면, &lt;code&gt;arg&lt;/code&gt; 가 정수 유형이거나 &lt;code&gt;double&lt;/code&gt; 유형 인 경우 &lt;code&gt;ceil&lt;/code&gt; 이 호출됩니다. 그렇지 않으면 &lt;code&gt;ceilf&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="b7be00b1a553ea64b81f1cd3e1b3669c536096cf" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If &lt;code&gt;arg&lt;/code&gt; has type &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;erfcl&lt;/code&gt; is called. Otherwise, if &lt;code&gt;arg&lt;/code&gt; has integer type or the type &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;erfc&lt;/code&gt; is called. Otherwise, &lt;code&gt;erfcf&lt;/code&gt; is called.</source>
          <target state="translated">4) 형 제네릭 매크로 : 경우 &lt;code&gt;arg&lt;/code&gt; 유형이 &lt;code&gt;long double&lt;/code&gt; , &lt;code&gt;erfcl&lt;/code&gt; 가 호출된다. 그렇지 않으면, &lt;code&gt;arg&lt;/code&gt; 가 정수 유형이거나 &lt;code&gt;double&lt;/code&gt; 유형 인 경우 &lt;code&gt;erfc&lt;/code&gt; 가 호출됩니다. 그렇지 않으면 &lt;code&gt;erfcf&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="5b3e6813f666bc2533e23dd0a7a4b9ab8d91e0c1" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If &lt;code&gt;arg&lt;/code&gt; has type &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;erfl&lt;/code&gt; is called. Otherwise, if &lt;code&gt;arg&lt;/code&gt; has integer type or the type &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;erf&lt;/code&gt; is called. Otherwise, &lt;code&gt;erff&lt;/code&gt; is called.</source>
          <target state="translated">4) 형 제네릭 매크로 : 경우 &lt;code&gt;arg&lt;/code&gt; 유형이 &lt;code&gt;long double&lt;/code&gt; , &lt;code&gt;erfl&lt;/code&gt; 가 호출된다. 그렇지 않으면, &lt;code&gt;arg&lt;/code&gt; 가 정수 유형이거나 &lt;code&gt;double&lt;/code&gt; 유형 인 경우 &lt;code&gt;erf&lt;/code&gt; 가 호출됩니다. 그렇지 않으면, &lt;code&gt;erff&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="2086091599eb9ae9a6e611781c8ea07157f1282e" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If &lt;code&gt;arg&lt;/code&gt; has type &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;expl&lt;/code&gt; is called. Otherwise, if &lt;code&gt;arg&lt;/code&gt; has integer type or the type &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;exp&lt;/code&gt; is called. Otherwise, &lt;code&gt;expf&lt;/code&gt; is called. If &lt;code&gt;arg&lt;/code&gt; is complex or imaginary, then the macro invokes the corresponding complex function (&lt;code&gt;&lt;a href=&quot;../complex/cexp&quot;&gt;cexpf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../complex/cexp&quot;&gt;cexp&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../complex/cexp&quot;&gt;cexpl&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">4) 형 제네릭 매크로 : 경우 &lt;code&gt;arg&lt;/code&gt; 유형이 &lt;code&gt;long double&lt;/code&gt; , &lt;code&gt;expl&lt;/code&gt; 라고합니다. 그렇지 않은 경우, &lt;code&gt;arg&lt;/code&gt; 정수 유형 또는 유형이 &lt;code&gt;double&lt;/code&gt; , &lt;code&gt;exp&lt;/code&gt; 호출된다. 그렇지 않으면 &lt;code&gt;expf&lt;/code&gt; 가 호출됩니다. 경우 &lt;code&gt;arg&lt;/code&gt; 복잡하거나 허수이고, 다음 매크로 호출 대응 복잡한 함수 ( &lt;code&gt;&lt;a href=&quot;../complex/cexp&quot;&gt;cexpf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../complex/cexp&quot;&gt;cexp&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../complex/cexp&quot;&gt;cexpl&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e0104a1e21a2395f2661d66ee4879235cf1acd4c" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If &lt;code&gt;arg&lt;/code&gt; has type &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;expm1l&lt;/code&gt; is called. Otherwise, if &lt;code&gt;arg&lt;/code&gt; has integer type or the type &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;expm1&lt;/code&gt; is called. Otherwise, &lt;code&gt;expm1f&lt;/code&gt; is called.</source>
          <target state="translated">4) 형 제네릭 매크로 : 경우 &lt;code&gt;arg&lt;/code&gt; 유형이 &lt;code&gt;long double&lt;/code&gt; , &lt;code&gt;expm1l&lt;/code&gt; 가 호출된다. 그렇지 않으면, &lt;code&gt;arg&lt;/code&gt; 가 정수 유형이거나 &lt;code&gt;double&lt;/code&gt; 유형 인 경우 &lt;code&gt;expm1&lt;/code&gt; 이 호출됩니다. 그렇지 않으면 &lt;code&gt;expm1f&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="3e562a9f4d84ca8fad2fb39b87dff3a3e05fd927" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If &lt;code&gt;arg&lt;/code&gt; has type &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;floorl&lt;/code&gt; is called. Otherwise, if &lt;code&gt;arg&lt;/code&gt; has integer type or the type &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;floor&lt;/code&gt; is called. Otherwise, &lt;code&gt;floorf&lt;/code&gt; is called.</source>
          <target state="translated">4) 형 제네릭 매크로 : 경우 &lt;code&gt;arg&lt;/code&gt; 유형이 &lt;code&gt;long double&lt;/code&gt; , &lt;code&gt;floorl&lt;/code&gt; 가 호출된다. 그렇지 않으면, &lt;code&gt;arg&lt;/code&gt; 가 integer 유형이거나 &lt;code&gt;double&lt;/code&gt; 유형 인 경우 &lt;code&gt;floor&lt;/code&gt; 가 호출됩니다. 그렇지 않으면 &lt;code&gt;floorf&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="a280c0d25b78a477af01793894a8836c3d81ee24" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If &lt;code&gt;arg&lt;/code&gt; has type &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;frexpl&lt;/code&gt; is called. Otherwise, if &lt;code&gt;arg&lt;/code&gt; has integer type or the type &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;frexp&lt;/code&gt; is called. Otherwise, &lt;code&gt;frexpf&lt;/code&gt; is called, respectively.</source>
          <target state="translated">4) 형 제네릭 매크로 : 경우 &lt;code&gt;arg&lt;/code&gt; 유형이 &lt;code&gt;long double&lt;/code&gt; , &lt;code&gt;frexpl&lt;/code&gt; 가 호출된다. 그렇지 않으면, &lt;code&gt;arg&lt;/code&gt; 가 정수 유형이거나 &lt;code&gt;double&lt;/code&gt; 유형 인 경우 &lt;code&gt;frexp&lt;/code&gt; 가 호출됩니다. 그렇지 않으면 &lt;code&gt;frexpf&lt;/code&gt; 가 각각 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="6a01dc2ec3688b33694a7fda78f3d4e446487fb7" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If &lt;code&gt;arg&lt;/code&gt; has type &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;ldexpl&lt;/code&gt; is called. Otherwise, if &lt;code&gt;arg&lt;/code&gt; has integer type or the type &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;ldexp&lt;/code&gt; is called. Otherwise, &lt;code&gt;ldexpf&lt;/code&gt; is called, respectively.</source>
          <target state="translated">4) 형 제네릭 매크로 : 경우 &lt;code&gt;arg&lt;/code&gt; 유형이 &lt;code&gt;long double&lt;/code&gt; , &lt;code&gt;ldexpl&lt;/code&gt; 가 호출된다. 그렇지 않은 경우, &lt;code&gt;arg&lt;/code&gt; 정수 유형 또는 유형이 &lt;code&gt;double&lt;/code&gt; , &lt;code&gt;ldexp&lt;/code&gt; 가 호출된다. 그렇지 않으면 &lt;code&gt;ldexpf&lt;/code&gt; 가 각각 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="cf62b8c5b50f7b9e69a275fa855de83c405b0d15" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If &lt;code&gt;arg&lt;/code&gt; has type &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;lgammal&lt;/code&gt; is called. Otherwise, if &lt;code&gt;arg&lt;/code&gt; has integer type or the type &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;lgamma&lt;/code&gt; is called. Otherwise, &lt;code&gt;lgammaf&lt;/code&gt; is called.</source>
          <target state="translated">4) 형 제네릭 매크로 : 경우 &lt;code&gt;arg&lt;/code&gt; 유형이 &lt;code&gt;long double&lt;/code&gt; , &lt;code&gt;lgammal&lt;/code&gt; 가 호출된다. 그렇지 않은 경우, &lt;code&gt;arg&lt;/code&gt; 정수 유형 또는 유형이 &lt;code&gt;double&lt;/code&gt; , &lt;code&gt;lgamma&lt;/code&gt; 가 호출된다. 그렇지 않으면 &lt;code&gt;lgammaf&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="df5a295f826a1f89edb5472314e13ca3233bfcc8" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If &lt;code&gt;arg&lt;/code&gt; has type &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;log10l&lt;/code&gt; is called. Otherwise, if &lt;code&gt;arg&lt;/code&gt; has integer type or the type &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;log10&lt;/code&gt; is called. Otherwise, &lt;code&gt;log10f&lt;/code&gt; is called.</source>
          <target state="translated">4) 형 제네릭 매크로 : 경우 &lt;code&gt;arg&lt;/code&gt; 유형이 &lt;code&gt;long double&lt;/code&gt; , &lt;code&gt;log10l&lt;/code&gt; 가 호출된다. 그렇지 않으면, &lt;code&gt;arg&lt;/code&gt; 가 정수 유형이거나 &lt;code&gt;double&lt;/code&gt; 유형 인 경우 &lt;code&gt;log10&lt;/code&gt; 이 호출됩니다. 그렇지 않으면 &lt;code&gt;log10f&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="1ec125396ad42df56eacb96ce4622e1e4fdacd03" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If &lt;code&gt;arg&lt;/code&gt; has type &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;log1pl&lt;/code&gt; is called. Otherwise, if &lt;code&gt;arg&lt;/code&gt; has integer type or the type &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;log1p&lt;/code&gt; is called. Otherwise, &lt;code&gt;log1pf&lt;/code&gt; is called.</source>
          <target state="translated">4) 형 제네릭 매크로 : 경우 &lt;code&gt;arg&lt;/code&gt; 유형이 &lt;code&gt;long double&lt;/code&gt; , &lt;code&gt;log1pl&lt;/code&gt; 가 호출된다. 그렇지 않으면, &lt;code&gt;arg&lt;/code&gt; 가 정수 유형이거나 &lt;code&gt;double&lt;/code&gt; 유형 인 경우 &lt;code&gt;log1p&lt;/code&gt; 가 호출됩니다. 그렇지 않으면 &lt;code&gt;log1pf&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="e8de498b9bbb344cef905b7f917171a4c6071b0c" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If &lt;code&gt;arg&lt;/code&gt; has type &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;log2l&lt;/code&gt; is called. Otherwise, if &lt;code&gt;arg&lt;/code&gt; has integer type or the type &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;log2&lt;/code&gt; is called. Otherwise, &lt;code&gt;log2f&lt;/code&gt; is called.</source>
          <target state="translated">4) 형 제네릭 매크로 : 경우 &lt;code&gt;arg&lt;/code&gt; 유형이 &lt;code&gt;long double&lt;/code&gt; , &lt;code&gt;log2l&lt;/code&gt; 가 호출된다. 그렇지 않으면, &lt;code&gt;arg&lt;/code&gt; 가 정수 유형이거나 &lt;code&gt;double&lt;/code&gt; 유형 인 경우 &lt;code&gt;log2&lt;/code&gt; 가 호출됩니다. 그렇지 않으면 &lt;code&gt;log2f&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="330e476af4f3f3e81d117653dbc0a98ff3ccb995" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If &lt;code&gt;arg&lt;/code&gt; has type &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;logl&lt;/code&gt; is called. Otherwise, if &lt;code&gt;arg&lt;/code&gt; has integer type or the type &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;log&lt;/code&gt; is called. Otherwise, &lt;code&gt;logf&lt;/code&gt; is called. If &lt;code&gt;arg&lt;/code&gt; is complex or imaginary, then the macro invokes the corresponding complex function (&lt;code&gt;&lt;a href=&quot;../complex/clog&quot;&gt;clogf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../complex/clog&quot;&gt;clog&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../complex/clog&quot;&gt;clogl&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">4) 형 제네릭 매크로 : 경우 &lt;code&gt;arg&lt;/code&gt; 유형이 &lt;code&gt;long double&lt;/code&gt; , &lt;code&gt;logl&lt;/code&gt; 가 호출된다. 그렇지 않으면, &lt;code&gt;arg&lt;/code&gt; 가 정수 유형이거나 &lt;code&gt;double&lt;/code&gt; 유형 인 경우 &lt;code&gt;log&lt;/code&gt; 가 호출됩니다. 그렇지 않으면 &lt;code&gt;logf&lt;/code&gt; 가 호출됩니다. 경우 &lt;code&gt;arg&lt;/code&gt; 복잡하거나 허수이고, 다음 매크로 호출 대응 복잡한 함수 ( &lt;code&gt;&lt;a href=&quot;../complex/clog&quot;&gt;clogf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../complex/clog&quot;&gt;clog&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../complex/clog&quot;&gt;clogl&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="584dda2301d8ea101f45e39db35dc5000b732793" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If &lt;code&gt;arg&lt;/code&gt; has type &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;nearbyintl&lt;/code&gt; is called. Otherwise, if &lt;code&gt;arg&lt;/code&gt; has integer type or the type &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;nearbyint&lt;/code&gt; is called. Otherwise, &lt;code&gt;nearbyintf&lt;/code&gt; is called, respectively.</source>
          <target state="translated">4) 형 제네릭 매크로 : 경우 &lt;code&gt;arg&lt;/code&gt; 유형이 &lt;code&gt;long double&lt;/code&gt; , &lt;code&gt;nearbyintl&lt;/code&gt; 가 호출된다. 그렇지 않으면, &lt;code&gt;arg&lt;/code&gt; 가 정수 유형이거나 &lt;code&gt;double&lt;/code&gt; 유형 인 경우 &lt;code&gt;nearbyint&lt;/code&gt; 가 호출됩니다. 그렇지 않으면 &lt;code&gt;nearbyintf&lt;/code&gt; 가 각각 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="131b453f380309ba0c3a3da175c3344926dfcfbe" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If &lt;code&gt;arg&lt;/code&gt; has type &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;sqrtl&lt;/code&gt; is called. Otherwise, if &lt;code&gt;arg&lt;/code&gt; has integer type or the type &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;sqrt&lt;/code&gt; is called. Otherwise, &lt;code&gt;sqrtf&lt;/code&gt; is called. If &lt;code&gt;arg&lt;/code&gt; is complex or imaginary, then the macro invokes the corresponding complex function (&lt;code&gt;&lt;a href=&quot;../complex/csqrt&quot;&gt;csqrtf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../complex/csqrt&quot;&gt;csqrt&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../complex/csqrt&quot;&gt;csqrtl&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">4) 형 제네릭 매크로 : 경우 &lt;code&gt;arg&lt;/code&gt; 유형이 &lt;code&gt;long double&lt;/code&gt; , &lt;code&gt;sqrtl&lt;/code&gt; 가 호출된다. 그렇지 않으면, &lt;code&gt;arg&lt;/code&gt; 가 정수 유형이거나 &lt;code&gt;double&lt;/code&gt; 유형 인 경우 &lt;code&gt;sqrt&lt;/code&gt; 가 호출됩니다. 그렇지 않으면 &lt;code&gt;sqrtf&lt;/code&gt; 가 호출됩니다. 경우 &lt;code&gt;arg&lt;/code&gt; 복잡하거나 허수이고, 다음 매크로 호출 대응 복잡한 함수 ( &lt;code&gt;&lt;a href=&quot;../complex/csqrt&quot;&gt;csqrtf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../complex/csqrt&quot;&gt;csqrt&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../complex/csqrt&quot;&gt;csqrtl&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a716a491b346df27249a1aa664c42f912de182dc" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If &lt;code&gt;arg&lt;/code&gt; has type &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;tgammal&lt;/code&gt; is called. Otherwise, if &lt;code&gt;arg&lt;/code&gt; has integer type or the type &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;tgamma&lt;/code&gt; is called. Otherwise, &lt;code&gt;tgammaf&lt;/code&gt; is called.</source>
          <target state="translated">4) 형 제네릭 매크로 : 경우 &lt;code&gt;arg&lt;/code&gt; 유형이 &lt;code&gt;long double&lt;/code&gt; , &lt;code&gt;tgammal&lt;/code&gt; 가 호출된다. 그렇지 않은 경우, &lt;code&gt;arg&lt;/code&gt; 정수 유형 또는 유형이 &lt;code&gt;double&lt;/code&gt; , &lt;code&gt;tgamma&lt;/code&gt; 가 호출된다. 그렇지 않으면, &lt;code&gt;tgammaf&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="1d99ff583c2e62cefff9b8c17bf5c8a2b1a2a989" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If &lt;code&gt;arg&lt;/code&gt; has type &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;truncl&lt;/code&gt; is called. Otherwise, if &lt;code&gt;arg&lt;/code&gt; has integer type or the type &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;trunc&lt;/code&gt; is called. Otherwise, &lt;code&gt;truncf&lt;/code&gt; is called.</source>
          <target state="translated">4) 형 제네릭 매크로 : 경우 &lt;code&gt;arg&lt;/code&gt; 유형이 &lt;code&gt;long double&lt;/code&gt; , &lt;code&gt;truncl&lt;/code&gt; 가 호출된다. 그렇지 않으면, &lt;code&gt;arg&lt;/code&gt; 가 정수 유형이거나 &lt;code&gt;double&lt;/code&gt; 유형 인 경우 &lt;code&gt;trunc&lt;/code&gt; 가 호출됩니다. 그렇지 않으면 &lt;code&gt;truncf&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="ab5537e17e23a66b7df468d13530e942d1cacddf" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If &lt;code&gt;n&lt;/code&gt; has type &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;exp2l&lt;/code&gt; is called. Otherwise, if &lt;code&gt;n&lt;/code&gt; has integer type or the type &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;exp2&lt;/code&gt; is called. Otherwise, &lt;code&gt;exp2f&lt;/code&gt; is called.</source>
          <target state="translated">4) 형 제네릭 매크로 : 경우 &lt;code&gt;n&lt;/code&gt; 유형이 &lt;code&gt;long double&lt;/code&gt; , &lt;code&gt;exp2l&lt;/code&gt; 가 호출된다. 그렇지 않으면, &lt;code&gt;n&lt;/code&gt; 이 정수 유형이거나 &lt;code&gt;double&lt;/code&gt; 유형 인 경우 &lt;code&gt;exp2&lt;/code&gt; 가 호출됩니다. 그렇지 않으면 &lt;code&gt;exp2f&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="972a8b5212eaa22b9b7e85e1778b5ad0ed639892" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;long double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;cacoshl&lt;/code&gt; is called. if &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;cacosh&lt;/code&gt; is called, if &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;float &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;cacoshf&lt;/code&gt; is called. If &lt;code&gt;z&lt;/code&gt; is real or integer, then the macro invokes the corresponding real function (&lt;code&gt;acoshf&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../math/acosh&quot;&gt;acosh&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;acoshl&lt;/code&gt;). If &lt;code&gt;z&lt;/code&gt; is imaginary, then the macro invokes the corresponding complex number version and the return type is complex.</source>
          <target state="translated">4) 형 제네릭 매크로 : 경우에 &lt;code&gt;z&lt;/code&gt; 는 입력이 &lt;code&gt;long double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;cacoshl&lt;/code&gt; 가 호출된다. 만약 &lt;code&gt;z&lt;/code&gt; 입력 갖는 &lt;code&gt;double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;cacosh&lt;/code&gt; 을 하면이라고 &lt;code&gt;z&lt;/code&gt; 는 입력 보유 &lt;code&gt;float &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;cacoshf&lt;/code&gt; 가 호출된다. 경우 &lt;code&gt;z&lt;/code&gt; 실제 또는 정수이고, 다음 매크로 호출 대응하는 실제 기능 ( &lt;code&gt;acoshf&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../math/acosh&quot;&gt;acosh&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;acoshl&lt;/code&gt; ). 경우 &lt;code&gt;z&lt;/code&gt; 허수이고, 다음 매크로 해당 복소수 버전을 호출 및 리턴 타입 복잡하다.</target>
        </trans-unit>
        <trans-unit id="b0b385142ddd798431624e5734e2e9b099e47412" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;long double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;cacosl&lt;/code&gt; is called. if &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;cacos&lt;/code&gt; is called, if &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;float &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;cacosf&lt;/code&gt; is called. If &lt;code&gt;z&lt;/code&gt; is real or integer, then the macro invokes the corresponding real function (&lt;code&gt;acosf&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../math/acos&quot;&gt;acos&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;acosl&lt;/code&gt;). If &lt;code&gt;z&lt;/code&gt; is imaginary, then the macro invokes the corresponding complex number version.</source>
          <target state="translated">4) 형 제네릭 매크로 : 경우에 &lt;code&gt;z&lt;/code&gt; 는 입력이 &lt;code&gt;long double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;cacosl&lt;/code&gt; 가 호출된다. 만약 &lt;code&gt;z&lt;/code&gt; 입력 갖는 &lt;code&gt;double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;cacos&lt;/code&gt; 을 하면이라고 &lt;code&gt;z&lt;/code&gt; 는 입력 보유 &lt;code&gt;float &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;cacosf&lt;/code&gt; 가 호출된다. 경우 &lt;code&gt;z&lt;/code&gt; 실제 또는 정수이고, 다음 매크로 대응하는 실제 기능 (호출 &lt;code&gt;acosf&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../math/acos&quot;&gt;acos&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;acosl&lt;/code&gt; 을 ). 경우 &lt;code&gt;z&lt;/code&gt; 허수이고, 다음 매크로 해당 복소수 버전을 호출한다.</target>
        </trans-unit>
        <trans-unit id="c85ee4298d1f06ad45cfb87d38262a10bbcbd6da" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;long double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;casinhl&lt;/code&gt; is called. if &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;casinh&lt;/code&gt; is called, if &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;float &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;casinhf&lt;/code&gt; is called. If &lt;code&gt;z&lt;/code&gt; is real or integer, then the macro invokes the corresponding real function (&lt;code&gt;asinhf&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../math/asinh&quot;&gt;asinh&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;asinhl&lt;/code&gt;). If &lt;code&gt;z&lt;/code&gt; is imaginary, then the macro invokes the corresponding real version of the function &lt;code&gt;&lt;a href=&quot;../math/asin&quot;&gt;asin&lt;/a&gt;&lt;/code&gt;, implementing the formula asinh(iy) = i asin(y), and the return type is imaginary.</source>
          <target state="translated">4) 형 제네릭 매크로 : 경우에 &lt;code&gt;z&lt;/code&gt; 는 입력이 &lt;code&gt;long double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;casinhl&lt;/code&gt; 가 호출된다. 만약 &lt;code&gt;z&lt;/code&gt; 입력 갖는 &lt;code&gt;double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;casinh&lt;/code&gt; 이 경우라고하며, &lt;code&gt;z&lt;/code&gt; 는 입력 보유 &lt;code&gt;float &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;casinhf&lt;/code&gt; 가 호출된다. 경우 &lt;code&gt;z&lt;/code&gt; 실제 또는 정수이고, 다음 매크로 호출 대응하는 실제 기능 ( &lt;code&gt;asinhf&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../math/asinh&quot;&gt;asinh&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;asinhl&lt;/code&gt; ). 경우 &lt;code&gt;z&lt;/code&gt; 허수이고, 다음 매크로 함수의 대응하는 실제 버전 호출 &lt;code&gt;&lt;a href=&quot;../math/asin&quot;&gt;asin&lt;/a&gt;&lt;/code&gt; 수식 asinh (iy) = i asin (y)를 구현하면 반환 유형은 가상입니다.</target>
        </trans-unit>
        <trans-unit id="3033851cfcd16beca4702852a42f6593677d575e" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;long double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;casinl&lt;/code&gt; is called. if &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;casin&lt;/code&gt; is called, if &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;float &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;casinf&lt;/code&gt; is called. If &lt;code&gt;z&lt;/code&gt; is real or integer, then the macro invokes the corresponding real function (&lt;code&gt;asinf&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../math/asin&quot;&gt;asin&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;asinl&lt;/code&gt;). If &lt;code&gt;z&lt;/code&gt; is imaginary, then the macro invokes the corresponding real version of the function &lt;code&gt;&lt;a href=&quot;../math/asinh&quot;&gt;asinh&lt;/a&gt;&lt;/code&gt;, implementing the formula asin(iy) = i asinh(y), and the return type of the macro is imaginary.</source>
          <target state="translated">4) 형 제네릭 매크로 : 경우에 &lt;code&gt;z&lt;/code&gt; 는 입력이 &lt;code&gt;long double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;casinl&lt;/code&gt; 가 호출된다. 만약 &lt;code&gt;z&lt;/code&gt; 입력 갖는 &lt;code&gt;double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;casin&lt;/code&gt; 경우라고하며, &lt;code&gt;z&lt;/code&gt; 는 입력 보유 &lt;code&gt;float &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;casinf&lt;/code&gt; 가 호출된다. 경우 &lt;code&gt;z&lt;/code&gt; 실제 또는 정수이고, 다음 매크로 호출 대응하는 실제 기능 ( &lt;code&gt;asinf&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../math/asin&quot;&gt;asin&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;asinl&lt;/code&gt; ). 경우 &lt;code&gt;z&lt;/code&gt; 허수이고, 다음 매크로 함수의 대응하는 실제 버전 호출 &lt;code&gt;&lt;a href=&quot;../math/asinh&quot;&gt;asinh&lt;/a&gt;&lt;/code&gt; 수식 asin (iy) = i asinh (y)를 구현하면 매크로의 반환 유형은 가상입니다.</target>
        </trans-unit>
        <trans-unit id="5167d1de50aa9694bf09031a3a76a4ffe86fb60b" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;long double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;catanhl&lt;/code&gt; is called. if &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;catanh&lt;/code&gt; is called, if &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;float &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;catanhf&lt;/code&gt; is called. If &lt;code&gt;z&lt;/code&gt; is real or integer, then the macro invokes the corresponding real function (&lt;code&gt;atanhf&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../math/atanh&quot;&gt;atanh&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;atanhl&lt;/code&gt;). If &lt;code&gt;z&lt;/code&gt; is imaginary, then the macro invokes the corresponding real version of &lt;code&gt;&lt;a href=&quot;../math/atan&quot;&gt;atan&lt;/a&gt;&lt;/code&gt;, implementing the formula atanh(iy) = i atan(y), and the return type is imaginary.</source>
          <target state="translated">4) 형 제네릭 매크로 : 경우에 &lt;code&gt;z&lt;/code&gt; 는 입력이 &lt;code&gt;long double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;catanhl&lt;/code&gt; 가 호출된다. 만약 &lt;code&gt;z&lt;/code&gt; 입력 갖는 &lt;code&gt;double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;catanh&lt;/code&gt; 이 경우라고하며, &lt;code&gt;z&lt;/code&gt; 는 입력 보유 &lt;code&gt;float &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;catanhf&lt;/code&gt; 가 호출된다. 경우 &lt;code&gt;z&lt;/code&gt; 실제 또는 정수이고, 다음 매크로 호출 대응하는 실제 기능 ( &lt;code&gt;atanhf&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../math/atanh&quot;&gt;atanh&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;atanhl&lt;/code&gt; ). 경우 &lt;code&gt;z&lt;/code&gt; 허수이고, 다음 매크로의 대응하는 실제 버전 호출 &lt;code&gt;&lt;a href=&quot;../math/atan&quot;&gt;atan&lt;/a&gt;&lt;/code&gt; atanh (iy) = i atan (y) 수식을 구현하면 반환 유형은 가상입니다.</target>
        </trans-unit>
        <trans-unit id="23d4006c1a5a26e366a7d148fb9ef5f028188987" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;long double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;catanl&lt;/code&gt; is called. if &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;catan&lt;/code&gt; is called, if &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;float &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;catanf&lt;/code&gt; is called. If &lt;code&gt;z&lt;/code&gt; is real or integer, then the macro invokes the corresponding real function (&lt;code&gt;atanf&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../math/atan&quot;&gt;atan&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;atanl&lt;/code&gt;). If &lt;code&gt;z&lt;/code&gt; is imaginary, then the macro invokes the corresponding real version of the function &lt;code&gt;&lt;a href=&quot;../math/atanh&quot;&gt;atanh&lt;/a&gt;&lt;/code&gt;, implementing the formula atan(iy) = i atanh(y), and the return type of the macro is imaginary.</source>
          <target state="translated">4) 형 제네릭 매크로 : 경우에 &lt;code&gt;z&lt;/code&gt; 는 입력이 &lt;code&gt;long double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;catanl&lt;/code&gt; 가 호출된다. 만약 &lt;code&gt;z&lt;/code&gt; 입력 갖는 &lt;code&gt;double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;catan&lt;/code&gt; 경우라고하며, &lt;code&gt;z&lt;/code&gt; 는 입력 보유 &lt;code&gt;float &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;catanf&lt;/code&gt; 가 호출된다. 경우 &lt;code&gt;z&lt;/code&gt; 실제 또는 정수이고, 다음 매크로 호출 대응하는 실제 기능 ( &lt;code&gt;atanf&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../math/atan&quot;&gt;atan&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;atanl&lt;/code&gt; ). 경우 &lt;code&gt;z&lt;/code&gt; 허수이고, 다음 매크로 함수의 대응하는 실제 버전 호출 &lt;code&gt;&lt;a href=&quot;../math/atanh&quot;&gt;atanh&lt;/a&gt;&lt;/code&gt; atan (iy) = i atanh (y) 수식을 구현하면 매크로의 반환 유형은 가상입니다.</target>
        </trans-unit>
        <trans-unit id="c7f22f15d8e840cb95650c47c8138eaf1c6a73e2" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;long double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;ccoshl&lt;/code&gt; is called. if &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;ccosh&lt;/code&gt; is called, if &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;float &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;ccoshf&lt;/code&gt; is called. If &lt;code&gt;z&lt;/code&gt; is real or integer, then the macro invokes the corresponding real function (&lt;code&gt;coshf&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../math/cosh&quot;&gt;cosh&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;coshl&lt;/code&gt;). If &lt;code&gt;z&lt;/code&gt; is imaginary, then the macro invokes the corresponding real version of the function &lt;code&gt;&lt;a href=&quot;../math/cos&quot;&gt;cos&lt;/a&gt;&lt;/code&gt;, implementing the formula cosh(iy) = cos(y), and the return type is real.</source>
          <target state="translated">4) 형 제네릭 매크로 : 경우에 &lt;code&gt;z&lt;/code&gt; 는 입력이 &lt;code&gt;long double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;ccoshl&lt;/code&gt; 가 호출된다. 만약 &lt;code&gt;z&lt;/code&gt; 입력 갖는 &lt;code&gt;double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;ccosh&lt;/code&gt; 을 하면이라고 &lt;code&gt;z&lt;/code&gt; 는 입력 보유 &lt;code&gt;float &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;ccoshf&lt;/code&gt; 가 호출된다. 경우 &lt;code&gt;z&lt;/code&gt; 실제 또는 정수이고, 다음 매크로 대응하는 실제 기능 (호출 &lt;code&gt;coshf&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../math/cosh&quot;&gt;cosh&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;coshl&lt;/code&gt; 을 ). 경우 &lt;code&gt;z&lt;/code&gt; 허수이고, 다음 매크로 함수의 대응하는 실제 버전 호출 &lt;code&gt;&lt;a href=&quot;../math/cos&quot;&gt;cos&lt;/a&gt;&lt;/code&gt; 수식 cosh (iy) = cos (y)를 구현하면 반환 유형은 실제입니다.</target>
        </trans-unit>
        <trans-unit id="3242d0a1a2d49ca0c5f33af424067527aa5060fc" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;long double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;ccosl&lt;/code&gt; is called. if &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;ccos&lt;/code&gt; is called, if &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;float &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;ccosf&lt;/code&gt; is called. If &lt;code&gt;z&lt;/code&gt; is real or integer, then the macro invokes the corresponding real function (&lt;code&gt;cosf&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../math/cos&quot;&gt;cos&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;cosl&lt;/code&gt;). If &lt;code&gt;z&lt;/code&gt; is imaginary, then the macro invokes the corresponding real version of the function &lt;code&gt;&lt;a href=&quot;../math/cosh&quot;&gt;cosh&lt;/a&gt;&lt;/code&gt;, implementing the formula cos(iy) = cosh(y), and the return type is real.</source>
          <target state="translated">4) 형 제네릭 매크로 : 경우에 &lt;code&gt;z&lt;/code&gt; 는 입력이 &lt;code&gt;long double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;ccosl&lt;/code&gt; 가 호출된다. 만약 &lt;code&gt;z&lt;/code&gt; 입력 갖는 &lt;code&gt;double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;ccos&lt;/code&gt; 을 하면이라고 &lt;code&gt;z&lt;/code&gt; 는 입력 보유 &lt;code&gt;float &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;ccosf&lt;/code&gt; 가 호출된다. 경우 &lt;code&gt;z&lt;/code&gt; 실제 또는 정수이고, 다음 매크로 대응하는 실제 기능 (호출 &lt;code&gt;cosf&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../math/cos&quot;&gt;cos&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;cosl&lt;/code&gt; ). 경우 &lt;code&gt;z&lt;/code&gt; 허수이고, 다음 매크로 함수의 대응하는 실제 버전 호출 &lt;code&gt;&lt;a href=&quot;../math/cosh&quot;&gt;cosh&lt;/a&gt;&lt;/code&gt; 수식 cos (iy) = cosh (y)를 구현하면 반환 유형은 실수입니다.</target>
        </trans-unit>
        <trans-unit id="042acf1305354be04c1abcef332229fdc2a326f7" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;long double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;cexpl&lt;/code&gt; is called. if &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;cexp&lt;/code&gt; is called, if &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;float &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;cexpf&lt;/code&gt; is called. If &lt;code&gt;z&lt;/code&gt; is real or integer, then the macro invokes the corresponding real function (&lt;code&gt;expf&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../math/exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;expl&lt;/code&gt;). If &lt;code&gt;z&lt;/code&gt; is imaginary, the corresponding complex argument version is called.</source>
          <target state="translated">4) 형 제네릭 매크로 : 경우에 &lt;code&gt;z&lt;/code&gt; 는 입력이 &lt;code&gt;long double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;cexpl&lt;/code&gt; 가 호출된다. 만약 &lt;code&gt;z&lt;/code&gt; 입력 갖는 &lt;code&gt;double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;cexp&lt;/code&gt; 을 하면이라고 &lt;code&gt;z&lt;/code&gt; 는 입력 보유 &lt;code&gt;float &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;cexpf&lt;/code&gt; 가 호출된다. 경우 &lt;code&gt;z&lt;/code&gt; 실제 또는 정수이고, 다음 매크로 호출 대응하는 실제 기능 ( &lt;code&gt;expf&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../math/exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;expl&lt;/code&gt; ). 경우 &lt;code&gt;z&lt;/code&gt; 허수이고, 대응하는 복합 인자 판이라고한다.</target>
        </trans-unit>
        <trans-unit id="2d28e9d6173465a2cb36bf553cf67dd94b7c5e4b" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;long double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;clogl&lt;/code&gt; is called. if &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;clog&lt;/code&gt; is called, if &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;float &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;clogf&lt;/code&gt; is called. If &lt;code&gt;z&lt;/code&gt; is real or integer, then the macro invokes the corresponding real function (&lt;code&gt;logf&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../math/log&quot;&gt;log&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;logl&lt;/code&gt;). If &lt;code&gt;z&lt;/code&gt; is imaginary, the corresponding complex number version is called.</source>
          <target state="translated">4) 형 제네릭 매크로 : 경우에 &lt;code&gt;z&lt;/code&gt; 는 입력이 &lt;code&gt;long double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;clogl&lt;/code&gt; 가 호출된다. 만약 &lt;code&gt;z&lt;/code&gt; 입력 갖는 &lt;code&gt;double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;clog&lt;/code&gt; 있는 경우라고하며, &lt;code&gt;z&lt;/code&gt; 는 입력 보유 &lt;code&gt;float &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;clogf&lt;/code&gt; 가 호출된다. 경우 &lt;code&gt;z&lt;/code&gt; 실제 또는 정수이고, 다음 매크로 호출 대응하는 실제 기능 ( &lt;code&gt;logf&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../math/log&quot;&gt;log&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;logl&lt;/code&gt; ). 경우 &lt;code&gt;z&lt;/code&gt; 허수이고, 대응하는 복소수 버전 불린다.</target>
        </trans-unit>
        <trans-unit id="c676101e9ce0b8a4c04065675ae34b89b5c61f28" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;long double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;csinhl&lt;/code&gt; is called. if &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;csinh&lt;/code&gt; is called, if &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;float &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;csinhf&lt;/code&gt; is called. If &lt;code&gt;z&lt;/code&gt; is real or integer, then the macro invokes the corresponding real function (&lt;code&gt;sinhf&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../math/sinh&quot;&gt;sinh&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;sinhl&lt;/code&gt;). If &lt;code&gt;z&lt;/code&gt; is imaginary, then the macro invokes the corresponding real version of the function &lt;code&gt;&lt;a href=&quot;../math/sin&quot;&gt;sin&lt;/a&gt;&lt;/code&gt;, implementing the formula sinh(iy) = i sin(y), and the return type is imaginary.</source>
          <target state="translated">4) 형 제네릭 매크로 : 경우에 &lt;code&gt;z&lt;/code&gt; 는 입력이 &lt;code&gt;long double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;csinhl&lt;/code&gt; 가 호출된다. 만약 &lt;code&gt;z&lt;/code&gt; 입력 갖는 &lt;code&gt;double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;csinh&lt;/code&gt; 을 하면이라고 &lt;code&gt;z&lt;/code&gt; 는 입력 보유 &lt;code&gt;float &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;csinhf&lt;/code&gt; 가 호출된다. 경우 &lt;code&gt;z&lt;/code&gt; 실제 또는 정수이고, 다음 매크로 호출 대응하는 실제 기능 ( &lt;code&gt;sinhf&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../math/sinh&quot;&gt;sinh&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;sinhl&lt;/code&gt; ). 경우 &lt;code&gt;z&lt;/code&gt; 허수이고, 다음 매크로 함수의 대응하는 실제 버전 호출 &lt;code&gt;&lt;a href=&quot;../math/sin&quot;&gt;sin&lt;/a&gt;&lt;/code&gt; 수식 sinh (iy) = i sin (y)를 구현하면 반환 유형은 가상입니다.</target>
        </trans-unit>
        <trans-unit id="326111ee431cdc6f395580d72e3d1743fbeef7cf" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;long double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;csinl&lt;/code&gt; is called. if &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;csin&lt;/code&gt; is called, if &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;float &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;csinf&lt;/code&gt; is called. If &lt;code&gt;z&lt;/code&gt; is real or integer, then the macro invokes the corresponding real function (&lt;code&gt;sinf&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../math/sin&quot;&gt;sin&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;sinl&lt;/code&gt;). If &lt;code&gt;z&lt;/code&gt; is imaginary, then the macro invokes the corresponding real version of the function &lt;code&gt;&lt;a href=&quot;../math/sinh&quot;&gt;sinh&lt;/a&gt;&lt;/code&gt;, implementing the formula sin(iy) = i sinh(y), and the return type of the macro is imaginary.</source>
          <target state="translated">4) 형 제네릭 매크로 : 경우에 &lt;code&gt;z&lt;/code&gt; 는 입력이 &lt;code&gt;long double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;csinl&lt;/code&gt; 가 호출된다. 만약 &lt;code&gt;z&lt;/code&gt; 입력 갖는 &lt;code&gt;double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;csin&lt;/code&gt; 이 경우라고하며, &lt;code&gt;z&lt;/code&gt; 는 입력 보유 &lt;code&gt;float &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;csinf&lt;/code&gt; 가 호출된다. 경우 &lt;code&gt;z&lt;/code&gt; 실제 또는 정수이고, 다음 매크로 호출 대응하는 실제 기능 ( &lt;code&gt;sinf&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../math/sin&quot;&gt;sin&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;sinl&lt;/code&gt; ). 경우 &lt;code&gt;z&lt;/code&gt; 허수이고, 다음 매크로 함수의 대응하는 실제 버전 호출 &lt;code&gt;&lt;a href=&quot;../math/sinh&quot;&gt;sinh&lt;/a&gt;&lt;/code&gt; 수식 sin (iy) = i sinh (y)를 구현하면 매크로의 반환 유형은 가상입니다.</target>
        </trans-unit>
        <trans-unit id="7cfac821827cf52071f707529d8cc711a8614e22" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;long double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;csqrtl&lt;/code&gt; is called. if &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;csqrt&lt;/code&gt; is called, if &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;float &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;csqrtf&lt;/code&gt; is called. If &lt;code&gt;z&lt;/code&gt; is real or integer, then the macro invokes the corresponding real function (&lt;code&gt;sqrtf&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../math/sqrt&quot;&gt;sqrt&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;sqrtl&lt;/code&gt;). If &lt;code&gt;z&lt;/code&gt; is imaginary, the corresponding complex number version is called.</source>
          <target state="translated">4) 형 제네릭 매크로 : 경우에 &lt;code&gt;z&lt;/code&gt; 는 입력이 &lt;code&gt;long double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;csqrtl&lt;/code&gt; 가 호출된다. 만약 &lt;code&gt;z&lt;/code&gt; 입력 갖는 &lt;code&gt;double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;csqrt&lt;/code&gt; 을 하면이라고 &lt;code&gt;z&lt;/code&gt; 는 입력 보유 &lt;code&gt;float &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;csqrtf&lt;/code&gt; 가 호출된다. 경우 &lt;code&gt;z&lt;/code&gt; 실제 또는 정수이고, 다음 매크로 호출 대응하는 실제 기능 ( &lt;code&gt;sqrtf&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../math/sqrt&quot;&gt;sqrt&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;sqrtl&lt;/code&gt; ). 경우 &lt;code&gt;z&lt;/code&gt; 허수이고, 대응하는 복소수 버전 불린다.</target>
        </trans-unit>
        <trans-unit id="19ea9e6fbdd5f8fccf16a6f4524074bea2e0760c" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;long double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;ctanhl&lt;/code&gt; is called. if &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;ctanh&lt;/code&gt; is called, if &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;float &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;ctanhf&lt;/code&gt; is called. If &lt;code&gt;z&lt;/code&gt; is real or integer, then the macro invokes the corresponding real function (&lt;code&gt;tanhf&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../math/tanh&quot;&gt;tanh&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;tanhl&lt;/code&gt;). If &lt;code&gt;z&lt;/code&gt; is imaginary, then the macro invokes the corresponding real version of the function &lt;code&gt;&lt;a href=&quot;../math/tan&quot;&gt;tan&lt;/a&gt;&lt;/code&gt;, implementing the formula tanh(iy) = i tan(y), and the return type is imaginary.</source>
          <target state="translated">4) 형 제네릭 매크로 : 경우에 &lt;code&gt;z&lt;/code&gt; 는 입력이 &lt;code&gt;long double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;ctanhl&lt;/code&gt; 가 호출된다. 만약 &lt;code&gt;z&lt;/code&gt; 입력 갖는 &lt;code&gt;double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;ctanh&lt;/code&gt; 을 하면이라고 &lt;code&gt;z&lt;/code&gt; 는 입력 보유 &lt;code&gt;float &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;ctanhf&lt;/code&gt; 가 호출된다. 경우 &lt;code&gt;z&lt;/code&gt; 실제 또는 정수이고, 다음 매크로 대응하는 실제 기능 (호출 &lt;code&gt;tanhf&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../math/tanh&quot;&gt;tanh&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;tanhl&lt;/code&gt; 을 ). 경우 &lt;code&gt;z&lt;/code&gt; 허수이고, 다음 매크로 함수의 대응하는 실제 버전 호출 &lt;code&gt;&lt;a href=&quot;../math/tan&quot;&gt;tan&lt;/a&gt;&lt;/code&gt; 수식 tanh (iy) = i tan (y)를 구현하면 반환 유형은 가상입니다.</target>
        </trans-unit>
        <trans-unit id="162fdffe50a365579872eb53de379df38f0d362f" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;long double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;ctanl&lt;/code&gt; is called. if &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;ctan&lt;/code&gt; is called, if &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;float &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;ctanf&lt;/code&gt; is called. If &lt;code&gt;z&lt;/code&gt; is real or integer, then the macro invokes the corresponding real function (&lt;code&gt;tanf&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../math/tan&quot;&gt;tan&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;tanl&lt;/code&gt;). If &lt;code&gt;z&lt;/code&gt; is imaginary, then the macro invokes the corresponding real version of the function &lt;code&gt;&lt;a href=&quot;../math/tanh&quot;&gt;tanh&lt;/a&gt;&lt;/code&gt;, implementing the formula tan(iy) = i tanh(y), and the return type is imaginary.</source>
          <target state="translated">4) 형 제네릭 매크로 : 경우에 &lt;code&gt;z&lt;/code&gt; 는 입력이 &lt;code&gt;long double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;ctanl&lt;/code&gt; 가 호출된다. 만약 &lt;code&gt;z&lt;/code&gt; 입력 갖는 &lt;code&gt;double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;ctan&lt;/code&gt; 경우라고하며, &lt;code&gt;z&lt;/code&gt; 는 입력 보유 &lt;code&gt;float &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;ctanf&lt;/code&gt; 가 호출된다. 경우 &lt;code&gt;z&lt;/code&gt; 실제 또는 정수이고, 다음 매크로 대응하는 실제 기능 (호출 &lt;code&gt;tanf&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../math/tan&quot;&gt;tan&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;tanl&lt;/code&gt; 을 ). 경우 &lt;code&gt;z&lt;/code&gt; 허수이고, 다음 매크로 함수의 대응하는 실제 버전 호출 &lt;code&gt;&lt;a href=&quot;../math/tanh&quot;&gt;tanh&lt;/a&gt;&lt;/code&gt; 수식 tan (iy) = i tanh (y)를 구현하면 반환 유형은 가상입니다.</target>
        </trans-unit>
        <trans-unit id="5ec71c36d347db4c5cae6bf1aa118eabd794819c" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If any argument has type &lt;code&gt;long double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;cpowl&lt;/code&gt; is called. if any argument has type &lt;code&gt;double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;cpow&lt;/code&gt; is called, if any argument has type &lt;code&gt;float &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;cpowf&lt;/code&gt; is called. If the arguments are real or integer, then the macro invokes the corresponding real function (&lt;code&gt;powf&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../math/pow&quot;&gt;pow&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;powl&lt;/code&gt;). If any argument is imaginary, the corresponding complex number version is called.</source>
          <target state="translated">4) 형 제네릭 매크로 : 인수가 입력되어있는 경우 &lt;code&gt;long double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;cpowl&lt;/code&gt; 가 호출된다. 인수가 입력 할 경우 &lt;code&gt;double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;cpow&lt;/code&gt; 는 인수가 형이있는 경우,라고 &lt;code&gt;float &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;cpowf&lt;/code&gt; 가 호출된다. 인수가 실수 또는 정수이면 매크로는 해당 실제 함수 ( &lt;code&gt;powf&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../math/pow&quot;&gt;pow&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;powl&lt;/code&gt; )를 호출합니다 . 인수가 허구 인 경우 해당 복소수 버전이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="bf1a1306ce29496e6ee1e4e2e0762bdb01ac8e51" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If any argument has type &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;copysignl&lt;/code&gt; is called. Otherwise, if any argument has integer type or has type &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;copysign&lt;/code&gt; is called. Otherwise, &lt;code&gt;copysignf&lt;/code&gt; is called.</source>
          <target state="translated">4) 형 제네릭 매크로 : 인수가 유형이있는 경우 &lt;code&gt;long double&lt;/code&gt; , &lt;code&gt;copysignl&lt;/code&gt; 가 호출된다. 그렇지 않으면, 인수가 정수 유형이거나 &lt;code&gt;double&lt;/code&gt; 유형 인 경우 &lt;code&gt;copysign&lt;/code&gt; 이 호출됩니다. 그렇지 않으면 &lt;code&gt;copysignf&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="9e1c538243aa78375d05576673d78cb2ea50863b" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If any argument has type &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;fdiml&lt;/code&gt; is called. Otherwise, if any argument has integer type or has type &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;fdim&lt;/code&gt; is called. Otherwise, &lt;code&gt;fdimf&lt;/code&gt; is called.</source>
          <target state="translated">4) 형 제네릭 매크로 : 인수가 유형이있는 경우 &lt;code&gt;long double&lt;/code&gt; , &lt;code&gt;fdiml&lt;/code&gt; 가 호출된다. 그렇지 않으면, 인수가 정수 유형이거나 &lt;code&gt;double&lt;/code&gt; 유형 인 경우 &lt;code&gt;fdim&lt;/code&gt; 이 호출됩니다. 그렇지 않으면 &lt;code&gt;fdimf&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="6bc6d069dccb788f5e5263c23ba50509b40be4d5" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If any argument has type &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;fmaxl&lt;/code&gt; is called. Otherwise, if any argument has integer type or has type &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;fmax&lt;/code&gt; is called. Otherwise, &lt;code&gt;fmaxf&lt;/code&gt; is called.</source>
          <target state="translated">4) 타입-일반 매크로 : 인자가 &lt;code&gt;long double&lt;/code&gt; 타입을 갖는 경우 , &lt;code&gt;fmaxl&lt;/code&gt; 이 호출됩니다. 그렇지 않으면, 인수가 정수 유형이거나 유형이 &lt;code&gt;double&lt;/code&gt; 인 경우 &lt;code&gt;fmax&lt;/code&gt; 가 호출됩니다. 그렇지 않으면 &lt;code&gt;fmaxf&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="2826258f5fc508caad4aa1bcbadb570a845f4250" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If any argument has type &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;fminl&lt;/code&gt; is called. Otherwise, if any argument has integer type or has type &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;fmin&lt;/code&gt; is called. Otherwise, &lt;code&gt;fminf&lt;/code&gt; is called.</source>
          <target state="translated">4) 형 제네릭 매크로 : 인수가 유형이있는 경우 &lt;code&gt;long double&lt;/code&gt; , &lt;code&gt;fminl&lt;/code&gt; 가 호출된다. 그렇지 않으면 인수에 정수 유형이 있거나 유형이 &lt;code&gt;double&lt;/code&gt; 인 경우 &lt;code&gt;fmin&lt;/code&gt; 이 호출됩니다. 그렇지 않으면 &lt;code&gt;fminf&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="9a200a6181ec8a987eb003c3c38ed43d102292ca" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If any argument has type &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;fmodl&lt;/code&gt; is called. Otherwise, if any argument has integer type or has type &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;fmod&lt;/code&gt; is called. Otherwise, &lt;code&gt;fmodf&lt;/code&gt; is called.</source>
          <target state="translated">4) 형 제네릭 매크로 : 인수가 유형이있는 경우 &lt;code&gt;long double&lt;/code&gt; , &lt;code&gt;fmodl&lt;/code&gt; 가 호출된다. 그렇지 않으면, 인수가 정수 유형이거나 &lt;code&gt;double&lt;/code&gt; 유형 인 경우 &lt;code&gt;fmod&lt;/code&gt; 가 호출됩니다. 그렇지 않으면 &lt;code&gt;fmodf&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="f6c22f75f0d642897267206dc3a8df65e5b72ce5" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If any argument has type &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;powl&lt;/code&gt; is called. Otherwise, if any argument has integer type or has type &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;pow&lt;/code&gt; is called. Otherwise, &lt;code&gt;powf&lt;/code&gt; is called. If at least one argument is complex or imaginary, then the macro invokes the corresponding complex function (&lt;code&gt;&lt;a href=&quot;../complex/cpow&quot;&gt;cpowf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../complex/cpow&quot;&gt;cpow&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../complex/cpow&quot;&gt;cpowl&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">4) 형 제네릭 매크로 : 인수가 유형이있는 경우 &lt;code&gt;long double&lt;/code&gt; , &lt;code&gt;powl&lt;/code&gt; 가 호출된다. 그렇지 않으면, 인수가 정수 유형이거나 유형이 &lt;code&gt;double&lt;/code&gt; 인 경우 &lt;code&gt;pow&lt;/code&gt; 가 호출됩니다. 그렇지 않으면 &lt;code&gt;powf&lt;/code&gt; 가 호출됩니다. 하나 이상의 인수가 복소수 또는 허수 인 경우 매크로는 해당 복소수 함수 ( &lt;code&gt;&lt;a href=&quot;../complex/cpow&quot;&gt;cpowf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../complex/cpow&quot;&gt;cpow&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../complex/cpow&quot;&gt;cpowl&lt;/a&gt;&lt;/code&gt; )를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="7b4daf3863aade2d9ccd70286cd72b49a2143dcf" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If any argument has type &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;remainderl&lt;/code&gt; is called. Otherwise, if any argument has integer type or has type &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;remainder&lt;/code&gt; is called. Otherwise, &lt;code&gt;remainderf&lt;/code&gt; is called.</source>
          <target state="translated">4) 타입-일반 매크로 : 인자가 &lt;code&gt;long double&lt;/code&gt; 타입을 갖는 경우 , &lt;code&gt;remainderl&lt;/code&gt; 가 호출됩니다. 그렇지 않으면, 인수가 정수 유형이거나 &lt;code&gt;double&lt;/code&gt; 유형 인 경우 &lt;code&gt;remainder&lt;/code&gt; 가 호출됩니다. 그렇지 않으면 &lt;code&gt;remainderf&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="881106fe48a13e788ec0b76b98b406ec65dcfb8c" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If any argument has type &lt;code&gt;long double&lt;/code&gt;, the long double version of the function is called. Otherwise, if any argument has integer type or has type &lt;code&gt;double&lt;/code&gt;, the double version of the function is called. Otherwise, the &lt;code&gt;float&lt;/code&gt; version of the function is called.</source>
          <target state="translated">4) 형식 일반 매크로 : 인수에 &lt;code&gt;long double&lt;/code&gt; 형식이있는 경우 long double 버전의 함수가 호출됩니다. 그렇지 않으면 인수에 정수 유형이 있거나 유형이 &lt;code&gt;double&lt;/code&gt; 인 경우 함수의 이중 버전이 호출됩니다. 그렇지 않으면 &lt;code&gt;float&lt;/code&gt; 버전의 함수가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="f246991df195f60af01c9a2feda665c912856a0d" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If any non-pointer argument has type &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;remquol&lt;/code&gt; is called. Otherwise, if any non-pointer argument has integer type or has type &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;remquo&lt;/code&gt; is called. Otherwise, &lt;code&gt;remquof&lt;/code&gt; is called.</source>
          <target state="translated">4) 형 제네릭 매크로 : 비 포인터 인수 유형이있는 경우 &lt;code&gt;long double&lt;/code&gt; , &lt;code&gt;remquol&lt;/code&gt; 가 호출된다. 그렇지 않으면, 포인터가 아닌 인수가 정수 유형이거나 &lt;code&gt;double&lt;/code&gt; 유형 인 경우 &lt;code&gt;remquo&lt;/code&gt; 가 호출됩니다. 그렇지 않으면 &lt;code&gt;remquof&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="cea7774bf8dbd4f866e0c68415f8e6ea99d2fdc8" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If the argument has type &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;acoshl&lt;/code&gt; is called. Otherwise, if the argument has integer type or the type &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;acosh&lt;/code&gt; is called. Otherwise, &lt;code&gt;acoshf&lt;/code&gt; is called. If the argument is complex, then the macro invokes the corresponding complex function (&lt;code&gt;&lt;a href=&quot;../complex/cacosh&quot;&gt;cacoshf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../complex/cacosh&quot;&gt;cacosh&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../complex/cacosh&quot;&gt;cacoshl&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">4) 형 제네릭 매크로 : 인수 유형이있는 경우 &lt;code&gt;long double&lt;/code&gt; , &lt;code&gt;acoshl&lt;/code&gt; 가 호출된다. 인수가 정수 유형 또는 유형이있는 경우 그렇지 않으면, &lt;code&gt;double&lt;/code&gt; , &lt;code&gt;acosh&lt;/code&gt; 호출된다. 그렇지 않으면 &lt;code&gt;acoshf&lt;/code&gt; 가 호출됩니다. 인수가 복잡한 경우 매크로는 해당 복합 함수 ( &lt;code&gt;&lt;a href=&quot;../complex/cacosh&quot;&gt;cacoshf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../complex/cacosh&quot;&gt;cacosh&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../complex/cacosh&quot;&gt;cacoshl&lt;/a&gt;&lt;/code&gt; )를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="9745de5739d522b568206a096dacb42984dfb6b0" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If the argument has type &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;acosl&lt;/code&gt; is called. Otherwise, if the argument has integer type or the type &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;acos&lt;/code&gt; is called. Otherwise, &lt;code&gt;acosf&lt;/code&gt; is called. If the argument is complex, then the macro invokes the corresponding complex function (&lt;code&gt;&lt;a href=&quot;../complex/cacos&quot;&gt;cacosf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../complex/cacos&quot;&gt;cacos&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../complex/cacos&quot;&gt;cacosl&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">4) 형 제네릭 매크로 : 인수 유형이있는 경우 &lt;code&gt;long double&lt;/code&gt; , &lt;code&gt;acosl&lt;/code&gt; 가 호출된다. 인수가 정수 유형 또는 유형이있는 경우 그렇지 않은 경우, &lt;code&gt;double&lt;/code&gt; , &lt;code&gt;acos&lt;/code&gt; 호출된다. 그렇지 않으면 &lt;code&gt;acosf&lt;/code&gt; 가 호출됩니다. 인수가 복잡한 경우 매크로는 해당 복합 함수 ( &lt;code&gt;&lt;a href=&quot;../complex/cacos&quot;&gt;cacosf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../complex/cacos&quot;&gt;cacos&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../complex/cacos&quot;&gt;cacosl&lt;/a&gt;&lt;/code&gt; )를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="c3d4bcc29c2f39d3e935684b0c659c20ad0b623c" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If the argument has type &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;asinhl&lt;/code&gt; is called. Otherwise, if the argument has integer type or the type &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;asinh&lt;/code&gt; is called. Otherwise, &lt;code&gt;asinhf&lt;/code&gt; is called. If the argument is complex, then the macro invokes the corresponding complex function (&lt;code&gt;&lt;a href=&quot;../complex/casinh&quot;&gt;casinhf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../complex/casinh&quot;&gt;casinh&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../complex/casinh&quot;&gt;casinhl&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">4) 형 제네릭 매크로 : 인수 유형이있는 경우 &lt;code&gt;long double&lt;/code&gt; , &lt;code&gt;asinhl&lt;/code&gt; 이라고합니다. 인수가 정수 유형 또는 유형이있는 경우 그렇지 않은 경우, &lt;code&gt;double&lt;/code&gt; , &lt;code&gt;asinh&lt;/code&gt; 이라고합니다. 그렇지 않으면 &lt;code&gt;asinhf&lt;/code&gt; 가 호출됩니다. 인수가 복잡한 경우 매크로는 해당 복합 함수 ( &lt;code&gt;&lt;a href=&quot;../complex/casinh&quot;&gt;casinhf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../complex/casinh&quot;&gt;casinh&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../complex/casinh&quot;&gt;casinhl&lt;/a&gt;&lt;/code&gt; )를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="4bfb61ffffdd35bb33e005f8c5056995a803d94e" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If the argument has type &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;asinl&lt;/code&gt; is called. Otherwise, if the argument has integer type or the type &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;asin&lt;/code&gt; is called. Otherwise, &lt;code&gt;asinf&lt;/code&gt; is called. If the argument is complex, then the macro invokes the corresponding complex function (&lt;code&gt;&lt;a href=&quot;../complex/casin&quot;&gt;casinf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../complex/casin&quot;&gt;casin&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../complex/casin&quot;&gt;casinl&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">4) 형 제네릭 매크로 : 인수 유형이있는 경우 &lt;code&gt;long double&lt;/code&gt; , &lt;code&gt;asinl&lt;/code&gt; 이라고합니다. 인수가 정수 유형 또는 유형이있는 경우 그렇지 않은 경우, &lt;code&gt;double&lt;/code&gt; , &lt;code&gt;asin&lt;/code&gt; 이라고합니다. 그렇지 않으면 &lt;code&gt;asinf&lt;/code&gt; 가 호출됩니다. 인수가 복잡한 경우 매크로는 해당 복합 함수 ( &lt;code&gt;&lt;a href=&quot;../complex/casin&quot;&gt;casinf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../complex/casin&quot;&gt;casin&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../complex/casin&quot;&gt;casinl&lt;/a&gt;&lt;/code&gt; )를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="5b82933c6f2e9b31923c8148287b2b802d9182ac" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If the argument has type &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;atan2l&lt;/code&gt; is called. Otherwise, if the argument has integer type or the type &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;atan2&lt;/code&gt; is called. Otherwise, &lt;code&gt;atan2f&lt;/code&gt; is called.</source>
          <target state="translated">4) 형 제네릭 매크로 : 인수 유형이있는 경우 &lt;code&gt;long double&lt;/code&gt; , &lt;code&gt;atan2l&lt;/code&gt; 가 호출된다. 인수가 정수 유형 또는 유형이있는 경우 그렇지 않으면, &lt;code&gt;double&lt;/code&gt; , &lt;code&gt;atan2&lt;/code&gt; 호출된다. 그렇지 않으면 &lt;code&gt;atan2f&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="1b5412903d643312f8a7a8881a7febf7f4501a02" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If the argument has type &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;atanhl&lt;/code&gt; is called. Otherwise, if the argument has integer type or the type &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;atanh&lt;/code&gt; is called. Otherwise, &lt;code&gt;atanhf&lt;/code&gt; is called. If the argument is complex, then the macro invokes the corresponding complex function (&lt;code&gt;&lt;a href=&quot;../complex/catanh&quot;&gt;catanhf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../complex/catanh&quot;&gt;catanh&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../complex/catanh&quot;&gt;catanhl&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">4) 형 제네릭 매크로 : 인수 유형이있는 경우 &lt;code&gt;long double&lt;/code&gt; , &lt;code&gt;atanhl&lt;/code&gt; 가 호출된다. 인수가 정수 유형 또는 유형이있는 경우 그렇지 않으면, &lt;code&gt;double&lt;/code&gt; , &lt;code&gt;atanh&lt;/code&gt; 호출된다. 그렇지 않으면 &lt;code&gt;atanhf&lt;/code&gt; 가 호출됩니다. 인수가 복잡한 경우 매크로는 해당 복합 함수 ( &lt;code&gt;&lt;a href=&quot;../complex/catanh&quot;&gt;catanhf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../complex/catanh&quot;&gt;catanh&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../complex/catanh&quot;&gt;catanhl&lt;/a&gt;&lt;/code&gt; )를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="dfa286026584aee4333c5ad3b806d51ebe96edaa" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If the argument has type &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;atanl&lt;/code&gt; is called. Otherwise, if the argument has integer type or the type &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;atan&lt;/code&gt; is called. Otherwise, &lt;code&gt;atanf&lt;/code&gt; is called. If the argument is complex, then the macro invokes the corresponding complex function (&lt;code&gt;&lt;a href=&quot;../complex/catan&quot;&gt;catanf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../complex/catan&quot;&gt;catan&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../complex/catan&quot;&gt;catanl&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">4) 형 제네릭 매크로 : 인수 유형이있는 경우 &lt;code&gt;long double&lt;/code&gt; , &lt;code&gt;atanl&lt;/code&gt; 가 호출된다. 인수가 정수 유형 또는 유형이있는 경우 그렇지 않으면, &lt;code&gt;double&lt;/code&gt; , &lt;code&gt;atan&lt;/code&gt; 라고합니다. 그렇지 않으면, &lt;code&gt;atanf&lt;/code&gt; 가 호출됩니다. 인수가 복잡한 경우 매크로는 해당 복합 함수 ( &lt;code&gt;&lt;a href=&quot;../complex/catan&quot;&gt;catanf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../complex/catan&quot;&gt;catan&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../complex/catan&quot;&gt;catanl&lt;/a&gt;&lt;/code&gt; )를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="889add64ce717d2d86c2c68b5c36cf2a24534035" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If the argument has type &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;coshl&lt;/code&gt; is called. Otherwise, if the argument has integer type or the type &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;cosh&lt;/code&gt; is called. Otherwise, &lt;code&gt;coshf&lt;/code&gt; is called. If the argument is complex, then the macro invokes the corresponding complex function (&lt;code&gt;&lt;a href=&quot;../complex/ccosh&quot;&gt;ccoshf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../complex/ccosh&quot;&gt;ccosh&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../complex/ccosh&quot;&gt;ccoshl&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">4) 형 제네릭 매크로 : 인수 유형이있는 경우 &lt;code&gt;long double&lt;/code&gt; , &lt;code&gt;coshl&lt;/code&gt; 가 호출된다. 인수가 정수 유형 또는 유형이있는 경우 그렇지 않으면, &lt;code&gt;double&lt;/code&gt; , &lt;code&gt;cosh&lt;/code&gt; 호출된다. 그렇지 않으면 &lt;code&gt;coshf&lt;/code&gt; 가 호출됩니다. 인수가 복잡한 경우 매크로는 해당 복합 함수 ( &lt;code&gt;&lt;a href=&quot;../complex/ccosh&quot;&gt;ccoshf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../complex/ccosh&quot;&gt;ccosh&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../complex/ccosh&quot;&gt;ccoshl&lt;/a&gt;&lt;/code&gt; )를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="07cbdfad8c67e2fa7365a228f24d83a0dc85c70a" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If the argument has type &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;cosl&lt;/code&gt; is called. Otherwise, if the argument has integer type or the type &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;cos&lt;/code&gt; is called. Otherwise, &lt;code&gt;cosf&lt;/code&gt; is called. If the argument is complex, then the macro invokes the corresponding complex function (&lt;code&gt;&lt;a href=&quot;../complex/ccos&quot;&gt;ccosf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../complex/ccos&quot;&gt;ccos&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../complex/ccos&quot;&gt;ccosl&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">4) 형 제네릭 매크로 : 인수 유형이있는 경우 &lt;code&gt;long double&lt;/code&gt; , &lt;code&gt;cosl&lt;/code&gt; 라고합니다. 인수가 정수 유형 또는 유형이있는 경우 그렇지 않은 경우, &lt;code&gt;double&lt;/code&gt; , &lt;code&gt;cos&lt;/code&gt; 호출된다. 그렇지 않으면 &lt;code&gt;cosf&lt;/code&gt; 가 호출됩니다. 인수가 복잡한 경우 매크로는 해당 복합 함수 ( &lt;code&gt;&lt;a href=&quot;../complex/ccos&quot;&gt;ccosf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../complex/ccos&quot;&gt;ccos&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../complex/ccos&quot;&gt;ccosl&lt;/a&gt;&lt;/code&gt; )를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="4d64443b360e3a0e2a46c1dbebf6bd528d20482f" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If the argument has type &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;fabsl&lt;/code&gt; is called. Otherwise, if the argument has integer type or has type &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;fabs&lt;/code&gt; is called. Otherwise, &lt;code&gt;fabsf&lt;/code&gt; is called. If the argument is complex, then the macro invokes the corresponding complex function (&lt;code&gt;&lt;a href=&quot;../complex/cabs&quot;&gt;cabsf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../complex/cabs&quot;&gt;cabs&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../complex/cabs&quot;&gt;cabsl&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">4) 형 제네릭 매크로 : 인수 유형이있는 경우 &lt;code&gt;long double&lt;/code&gt; , &lt;code&gt;fabsl&lt;/code&gt; 가 호출된다. 인수 유형 정수가 있거나 입력 할 경우 그렇지 않으면, &lt;code&gt;double&lt;/code&gt; , &lt;code&gt;fabs&lt;/code&gt; 라고합니다. 그렇지 않으면 &lt;code&gt;fabsf&lt;/code&gt; 가 호출됩니다. 인수가 복잡한 경우 매크로는 해당 복합 함수 ( &lt;code&gt;&lt;a href=&quot;../complex/cabs&quot;&gt;cabsf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../complex/cabs&quot;&gt;cabs&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../complex/cabs&quot;&gt;cabsl&lt;/a&gt;&lt;/code&gt; )를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="3c8338b5e884a4c54f9b4bbc59caf4e199cb5a7b" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If the argument has type &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;sinhl&lt;/code&gt; is called. Otherwise, if the argument has integer type or the type &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;sinh&lt;/code&gt; is called. Otherwise, &lt;code&gt;sinhf&lt;/code&gt; is called. If the argument is complex, then the macro invokes the corresponding complex function (&lt;code&gt;&lt;a href=&quot;../complex/csinh&quot;&gt;csinhf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../complex/csinh&quot;&gt;csinh&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../complex/csinh&quot;&gt;csinhl&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">4) 형 제네릭 매크로 : 인수 유형이있는 경우 &lt;code&gt;long double&lt;/code&gt; , &lt;code&gt;sinhl&lt;/code&gt; 가 호출된다. 인수가 정수 유형 또는 유형이있는 경우 그렇지 않으면, &lt;code&gt;double&lt;/code&gt; , &lt;code&gt;sinh&lt;/code&gt; 호출된다. 그렇지 않으면 &lt;code&gt;sinhf&lt;/code&gt; 가 호출됩니다. 인수가 복잡한 경우 매크로는 해당 복합 함수 ( &lt;code&gt;&lt;a href=&quot;../complex/csinh&quot;&gt;csinhf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../complex/csinh&quot;&gt;csinh&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../complex/csinh&quot;&gt;csinhl&lt;/a&gt;&lt;/code&gt; )를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="049ccd0355bff3623027dd800aec381b1ccb415a" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If the argument has type &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;sinl&lt;/code&gt; is called. Otherwise, if the argument has integer type or the type &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;sin&lt;/code&gt; is called. Otherwise, &lt;code&gt;sinf&lt;/code&gt; is called. If the argument is complex, then the macro invokes the corresponding complex function (&lt;code&gt;&lt;a href=&quot;../complex/csin&quot;&gt;csinf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../complex/csin&quot;&gt;csin&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../complex/csin&quot;&gt;csinl&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">4) 형 제네릭 매크로 : 인수 유형이있는 경우 &lt;code&gt;long double&lt;/code&gt; , &lt;code&gt;sinl&lt;/code&gt; 가 호출된다. 인수가 정수 유형 또는 유형이있는 경우 그렇지 않으면, &lt;code&gt;double&lt;/code&gt; , &lt;code&gt;sin&lt;/code&gt; 호출된다. 그렇지 않으면 &lt;code&gt;sinf&lt;/code&gt; 가 호출됩니다. 인수가 복잡한 경우 매크로는 해당 복합 함수 ( &lt;code&gt;&lt;a href=&quot;../complex/csin&quot;&gt;csinf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../complex/csin&quot;&gt;csin&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../complex/csin&quot;&gt;csinl&lt;/a&gt;&lt;/code&gt; )를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="131f301b6ec6668d466a39d5a21c0b5dccaf5749" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If the argument has type &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;tanhl&lt;/code&gt; is called. Otherwise, if the argument has integer type or the type &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;tanh&lt;/code&gt; is called. Otherwise, &lt;code&gt;tanhf&lt;/code&gt; is called. If the argument is complex, then the macro invokes the corresponding complex function (&lt;code&gt;&lt;a href=&quot;../complex/ctanh&quot;&gt;ctanhf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../complex/ctanh&quot;&gt;ctanh&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../complex/ctanh&quot;&gt;ctanhl&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">4) 형 제네릭 매크로 : 인수 유형이있는 경우 &lt;code&gt;long double&lt;/code&gt; , &lt;code&gt;tanhl&lt;/code&gt; 가 호출된다. 인수가 정수 유형 또는 유형이있는 경우 그렇지 않으면, &lt;code&gt;double&lt;/code&gt; , &lt;code&gt;tanh&lt;/code&gt; 이라고합니다. 그렇지 않으면 &lt;code&gt;tanhf&lt;/code&gt; 가 호출됩니다. 인수가 복잡한 경우 매크로는 해당 복합 함수 ( &lt;code&gt;&lt;a href=&quot;../complex/ctanh&quot;&gt;ctanhf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../complex/ctanh&quot;&gt;ctanh&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../complex/ctanh&quot;&gt;ctanhl&lt;/a&gt;&lt;/code&gt; )를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="3dc570e1fdeaaa49641c33784dcdb144ac322d16" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: If the argument has type &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;tanl&lt;/code&gt; is called. Otherwise, if the argument has integer type or the type &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;tan&lt;/code&gt; is called. Otherwise, &lt;code&gt;tanf&lt;/code&gt; is called. If the argument is complex, then the macro invokes the corresponding complex function (&lt;code&gt;&lt;a href=&quot;../complex/ctan&quot;&gt;ctanf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../complex/ctan&quot;&gt;ctan&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../complex/ctan&quot;&gt;ctanl&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">4) 형 제네릭 매크로 : 인수 유형이있는 경우 &lt;code&gt;long double&lt;/code&gt; , &lt;code&gt;tanl&lt;/code&gt; 가 호출된다. 인수가 정수 유형 또는 유형이있는 경우 그렇지 않은 경우, &lt;code&gt;double&lt;/code&gt; , &lt;code&gt;tan&lt;/code&gt; 라고합니다. 그렇지 않으면 &lt;code&gt;tanf&lt;/code&gt; 가 호출됩니다. 인수가 복잡한 경우 매크로는 해당 복합 함수 ( &lt;code&gt;&lt;a href=&quot;../complex/ctan&quot;&gt;ctanf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../complex/ctan&quot;&gt;ctan&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../complex/ctan&quot;&gt;ctanl&lt;/a&gt;&lt;/code&gt; )를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="555fdc61d9284f807c4faa86a7b50de7ee4dc8da" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: if &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;long double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;long double &lt;a href=&quot;imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;cabsl&lt;/code&gt; is called. If &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;float &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;float &lt;a href=&quot;imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;cabsf&lt;/code&gt; is called. If &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;double &lt;a href=&quot;imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;cabs&lt;/code&gt; is called. For real and integer types, the corresponding version of &lt;code&gt;&lt;a href=&quot;../math/fabs&quot;&gt;fabs&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="translated">4) 형 제네릭 매크로 : 경우에 &lt;code&gt;z&lt;/code&gt; 는 유형이 &lt;code&gt;long double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; 하거나 &lt;code&gt;long double &lt;a href=&quot;imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;cabsl&lt;/code&gt; 가 호출된다. 경우 &lt;code&gt;z&lt;/code&gt; 입력 보유 &lt;code&gt;float &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;float &lt;a href=&quot;imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;cabsf&lt;/code&gt; 가 호출된다. 경우 &lt;code&gt;z&lt;/code&gt; 는 종류가 &lt;code&gt;double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;double &lt;a href=&quot;imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;cabs&lt;/code&gt; 호출된다. 실수 및 정수 유형의 경우 해당 버전의 &lt;code&gt;&lt;a href=&quot;../math/fabs&quot;&gt;fabs&lt;/a&gt;&lt;/code&gt; 이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="5eaeed607463b223520f11bc760cd02a8acb3bdd" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: if &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;long double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;long double &lt;a href=&quot;imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;cargl&lt;/code&gt; is called. If &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;float &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;float &lt;a href=&quot;imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;cargf&lt;/code&gt; is called. If &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;double &lt;a href=&quot;imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, or any integer type, &lt;code&gt;carg&lt;/code&gt; is called.</source>
          <target state="translated">4) 형 제네릭 매크로 : 경우에 &lt;code&gt;z&lt;/code&gt; 는 유형이 &lt;code&gt;long double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;long double &lt;a href=&quot;imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt; , 또는 &lt;code&gt;long double&lt;/code&gt; , &lt;code&gt;cargl&lt;/code&gt; 가 호출된다. 경우 &lt;code&gt;z&lt;/code&gt; 입력 보유 &lt;code&gt;float &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;float &lt;a href=&quot;imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;float&lt;/code&gt; , &lt;code&gt;cargf&lt;/code&gt; 가 호출된다. 경우 &lt;code&gt;z&lt;/code&gt; 입력 갖는 &lt;code&gt;double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;double &lt;a href=&quot;imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; , 또는 임의의 정수형, &lt;code&gt;carg&lt;/code&gt; 가 호출된다.</target>
        </trans-unit>
        <trans-unit id="e253e5ad8c4e7bf07207416cc1d84d776cac27d4" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: if &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;long double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;long double &lt;a href=&quot;imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;cimagl&lt;/code&gt; is called. If &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;float &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;float &lt;a href=&quot;imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;cimagf&lt;/code&gt; is called. If &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;double &lt;a href=&quot;imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, or any integer type, &lt;code&gt;cimag&lt;/code&gt; is called.</source>
          <target state="translated">4) 형 제네릭 매크로 : 경우에 &lt;code&gt;z&lt;/code&gt; 는 유형이 &lt;code&gt;long double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;long double &lt;a href=&quot;imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt; , 또는 &lt;code&gt;long double&lt;/code&gt; , &lt;code&gt;cimagl&lt;/code&gt; 가 호출된다. 경우 &lt;code&gt;z&lt;/code&gt; 입력 보유 &lt;code&gt;float &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;float &lt;a href=&quot;imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;float&lt;/code&gt; , &lt;code&gt;cimagf&lt;/code&gt; 가 호출된다. 경우 &lt;code&gt;z&lt;/code&gt; 입력 갖는 &lt;code&gt;double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;double &lt;a href=&quot;imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; , 또는 임의의 정수형, &lt;code&gt;cimag&lt;/code&gt; 가 호출된다.</target>
        </trans-unit>
        <trans-unit id="d269a74e0faf2661ee416134452eedf856f6b39a" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: if &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;long double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;long double &lt;a href=&quot;imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;conjl&lt;/code&gt; is called. If &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;float &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;float &lt;a href=&quot;imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;conjf&lt;/code&gt; is called. If &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;double &lt;a href=&quot;imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, or any integer type, &lt;code&gt;conj&lt;/code&gt; is called.</source>
          <target state="translated">4) 형 제네릭 매크로 : 경우에 &lt;code&gt;z&lt;/code&gt; 는 유형이 &lt;code&gt;long double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;long double &lt;a href=&quot;imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt; , 또는 &lt;code&gt;long double&lt;/code&gt; , &lt;code&gt;conjl&lt;/code&gt; 가 호출된다. 경우 &lt;code&gt;z&lt;/code&gt; 입력 보유 &lt;code&gt;float &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;float &lt;a href=&quot;imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;float&lt;/code&gt; , &lt;code&gt;conjf&lt;/code&gt; 가 호출된다. 경우 &lt;code&gt;z&lt;/code&gt; 입력 갖는 &lt;code&gt;double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;double &lt;a href=&quot;imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; , 또는 임의의 정수형, &lt;code&gt;conj&lt;/code&gt; 호출된다.</target>
        </trans-unit>
        <trans-unit id="673bf9520de5e6d2d5dd7c039a570b5370ea2d74" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: if &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;long double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;long double &lt;a href=&quot;imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;cprojl&lt;/code&gt; is called. If &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;float &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;float &lt;a href=&quot;imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;cprojf&lt;/code&gt; is called. If &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;double &lt;a href=&quot;imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, or any integer type, &lt;code&gt;cproj&lt;/code&gt; is called.</source>
          <target state="translated">4) 형 제네릭 매크로 : 경우에 &lt;code&gt;z&lt;/code&gt; 는 유형이 &lt;code&gt;long double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;long double &lt;a href=&quot;imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt; , 또는 &lt;code&gt;long double&lt;/code&gt; , &lt;code&gt;cprojl&lt;/code&gt; 가 호출된다. 경우 &lt;code&gt;z&lt;/code&gt; 입력 보유 &lt;code&gt;float &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;float &lt;a href=&quot;imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;float&lt;/code&gt; , &lt;code&gt;cprojf&lt;/code&gt; 가 호출된다. 경우 &lt;code&gt;z&lt;/code&gt; 입력 갖는 &lt;code&gt;double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;double &lt;a href=&quot;imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; , 또는 임의의 정수형, &lt;code&gt;cproj&lt;/code&gt; 가 호출된다.</target>
        </trans-unit>
        <trans-unit id="c09215a092b8cd6f3f872fe6f6effa76fef2c382" translate="yes" xml:space="preserve">
          <source>4) Type-generic macro: if &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;long double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;long double &lt;a href=&quot;imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;creall&lt;/code&gt; is called. If &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;float &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;float &lt;a href=&quot;imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;crealf&lt;/code&gt; is called. If &lt;code&gt;z&lt;/code&gt; has type &lt;code&gt;double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;double &lt;a href=&quot;imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, or any integer type, &lt;code&gt;creal&lt;/code&gt; is called.</source>
          <target state="translated">4) 형 제네릭 매크로 : 경우에 &lt;code&gt;z&lt;/code&gt; 는 유형이 &lt;code&gt;long double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;long double &lt;a href=&quot;imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt; , 또는 &lt;code&gt;long double&lt;/code&gt; , &lt;code&gt;creall&lt;/code&gt; 가 호출된다. 경우 &lt;code&gt;z&lt;/code&gt; 입력 보유 &lt;code&gt;float &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;float &lt;a href=&quot;imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;float&lt;/code&gt; , &lt;code&gt;crealf&lt;/code&gt; 가 호출된다. 경우 &lt;code&gt;z&lt;/code&gt; 입력 갖는 &lt;code&gt;double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;double &lt;a href=&quot;imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; , 또는 임의의 정수형, &lt;code&gt;creal&lt;/code&gt; 호출된다.</target>
        </trans-unit>
        <trans-unit id="b9483849390d9f6244b1b1ec26d1fc94e54044e9" translate="yes" xml:space="preserve">
          <source>4) Type-generic macros: If &lt;code&gt;arg&lt;/code&gt; has type &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;ilogbl&lt;/code&gt; is called. Otherwise, if &lt;code&gt;arg&lt;/code&gt; has integer type or the type &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;ilogb&lt;/code&gt; is called. Otherwise, &lt;code&gt;ilogbf&lt;/code&gt; is called.</source>
          <target state="translated">4) 형 제네릭 매크로 : 경우 &lt;code&gt;arg&lt;/code&gt; 유형이 &lt;code&gt;long double&lt;/code&gt; , &lt;code&gt;ilogbl&lt;/code&gt; 이 라고합니다. 그렇지 않으면, &lt;code&gt;arg&lt;/code&gt; 가 정수 유형이거나 &lt;code&gt;double&lt;/code&gt; 유형 인 경우 &lt;code&gt;ilogb&lt;/code&gt; 가 호출됩니다. 그렇지 않으면 &lt;code&gt;ilogbf&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="1b54b38041fa7db6b10d95246f06ea6435ccd0c4" translate="yes" xml:space="preserve">
          <source>4) Type-generic macros: If &lt;code&gt;arg&lt;/code&gt; has type &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;logbl&lt;/code&gt; is called. Otherwise, if &lt;code&gt;arg&lt;/code&gt; has integer type or the type &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;logb&lt;/code&gt; is called. Otherwise, &lt;code&gt;logbf&lt;/code&gt; is called.</source>
          <target state="translated">4) 형 제네릭 매크로 : 경우 &lt;code&gt;arg&lt;/code&gt; 유형이 &lt;code&gt;long double&lt;/code&gt; , &lt;code&gt;logbl&lt;/code&gt; 가 호출된다. 그렇지 않으면, &lt;code&gt;arg&lt;/code&gt; 가 정수 유형이거나 &lt;code&gt;double&lt;/code&gt; 유형 인 경우 &lt;code&gt;logb&lt;/code&gt; 가 호출됩니다. 그렇지 않으면 &lt;code&gt;logbf&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="e652f0dc8ebcd9420c0ec312d1fa4939f6e2c14d" translate="yes" xml:space="preserve">
          <source>4) Writes the results to a character string &lt;code&gt;buffer&lt;/code&gt;. At most &lt;code&gt;buf_size - 1&lt;/code&gt; characters are written. The resulting character string will be terminated with a null character, unless &lt;code&gt;buf_size&lt;/code&gt; is zero. If &lt;code&gt;buf_size&lt;/code&gt; is zero, nothing is written and &lt;code&gt;buffer&lt;/code&gt; may be a null pointer, however the return value (number of bytes that would be written not including the null terminator) is still calculated and returned.</source>
          <target state="translated">4) 결과를 문자열 &lt;code&gt;buffer&lt;/code&gt; 합니다. 최대 &lt;code&gt;buf_size - 1&lt;/code&gt; 자가 기록됩니다. &lt;code&gt;buf_size&lt;/code&gt; 가 0이 아니면 결과 문자열은 널 문자로 종료 됩니다. 경우 &lt;code&gt;buf_size&lt;/code&gt; 제로, 아무것도 기록되지 않고 &lt;code&gt;buffer&lt;/code&gt; 널 포인터, 그러나 반환 값 아직 계산 반환 (널 종료를 포함하지 않는 기록 될 것입니다 바이트 수) 일 수도있다.</target>
        </trans-unit>
        <trans-unit id="a6a2dd5d594f496c61670676cb961bd1505420c2" translate="yes" xml:space="preserve">
          <source>4) Writes the results to a character string &lt;code&gt;buffer&lt;/code&gt;. At most &lt;code&gt;bufsz&lt;/code&gt; - 1 characters are written. The resulting character string will be terminated with a null character, unless &lt;code&gt;bufsz&lt;/code&gt; is zero. If &lt;code&gt;bufsz&lt;/code&gt; is zero, nothing is written and &lt;code&gt;buffer&lt;/code&gt; may be a null pointer, however the return value (number of bytes that would be written not including the null terminator) is still calculated and returned.</source>
          <target state="translated">4) 결과를 문자열 &lt;code&gt;buffer&lt;/code&gt; 합니다. 최대 &lt;code&gt;bufsz&lt;/code&gt; -1 개의 문자가 작성됩니다. &lt;code&gt;bufsz&lt;/code&gt; 가 0이 아니면 결과 문자열은 널 문자로 종료 됩니다. 경우 &lt;code&gt;bufsz&lt;/code&gt; 는 제로, 아무것도 기록되지 않고 &lt;code&gt;buffer&lt;/code&gt; 널 포인터, 그러나 반환 값 아직 계산 반환 (널 종료를 포함하지 않는 기록 될 것입니다 바이트 수) 일 수도있다.</target>
        </trans-unit>
        <trans-unit id="a332acbb84d6d176b1d94227467c38f3a77490a4" translate="yes" xml:space="preserve">
          <source>4) all other identifiers are looked up in the name space of ordinary identifiers.</source>
          <target state="translated">4) 다른 모든 식별자는 일반 식별자의 네임 스페이스에서 조회됩니다.</target>
        </trans-unit>
        <trans-unit id="e8a471c794cf3ac2f6db73e86d13e5c4b53b8ca0" translate="yes" xml:space="preserve">
          <source>4) bitwise XOR</source>
          <target state="translated">4) 비트 XOR</target>
        </trans-unit>
        <trans-unit id="e87ee9f337558f535872130a6f6861b7d7cc2399" translate="yes" xml:space="preserve">
          <source>4) greater or equal expression</source>
          <target state="translated">4) 크거나 같은 표현</target>
        </trans-unit>
        <trans-unit id="9fb0cea03035ef4760ed2a09d395810eb7dbbcc3" translate="yes" xml:space="preserve">
          <source>4) if one is a pointer and the other is a null pointer constant, the type is the type of that pointer</source>
          <target state="translated">4) 하나가 포인터이고 다른 하나가 널 포인터 상수 인 경우 유형은 해당 포인터의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="debc48fd1454176bb35ee7e5bea39f542341bc79" translate="yes" xml:space="preserve">
          <source>4) iteration statements</source>
          <target state="translated">4) 반복문</target>
        </trans-unit>
        <trans-unit id="801c4f0af4bbbd03d78638c0bb722a0afe226e59" translate="yes" xml:space="preserve">
          <source>4) number of characters (not including the terminating null character) which would have been written to &lt;code&gt;buffer&lt;/code&gt; if &lt;code&gt;bufsz&lt;/code&gt; was ignored, or a negative value if an encoding error (for string and character conversion specifiers) occurred</source>
          <target state="translated">4) &lt;code&gt;bufsz&lt;/code&gt; 가 무시 된 경우 &lt;code&gt;buffer&lt;/code&gt; 에 기록 된 문자 수 (종료 널 문자 제외) 또는 인코딩 오류 (문자열 및 문자 변환 지정자)가 발생한 경우 음수 값</target>
        </trans-unit>
        <trans-unit id="f13e6d6be4c86ea31a7f824c05538a9cded97caa" translate="yes" xml:space="preserve">
          <source>4) rank of char equals rank of signed char and rank of unsigned char</source>
          <target state="translated">4) char의 순위는 signed char의 순위와 unsigned char의 순위와 같습니다.</target>
        </trans-unit>
        <trans-unit id="8b95ede6bb45607d5df79e44dfff65f1d643196d" translate="yes" xml:space="preserve">
          <source>4) special case: &amp;amp; and the * that is implied in [] cancel each other, only the addition implied in [] is evaluated</source>
          <target state="translated">4) 특수한 경우 : &amp;amp;와 []에 포함 된 *는 서로를 취소하고 []에 포함 된 추가 만 평가합니다.</target>
        </trans-unit>
        <trans-unit id="a8b97756c5320629120afcd36fdc9ed98682b255" translate="yes" xml:space="preserve">
          <source>4) wide character constant, e.g. &lt;code&gt;L'&amp;beta;'&lt;/code&gt; or &lt;code&gt;L'貓&lt;/code&gt;. Such constant has type &lt;code&gt;wchar_t&lt;/code&gt; and a value equal to the value of c-char in the execution wide character set (that is, the value that would be produced by &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbtowc&quot;&gt;mbtowc&lt;/a&gt;&lt;/code&gt;). If c-char is not representable or maps to more than one wide character (e.g. a non-BMP value on Windows where wchar_t is 16-bit), the behavior is implementation-defined .</source>
          <target state="translated">4) 넓은 문자 상수, 예를 들어 &lt;code&gt;L'&amp;beta;'&lt;/code&gt; 또는 &lt;code&gt;L'貓&lt;/code&gt; . 이러한 상수는 &lt;code&gt;wchar_t&lt;/code&gt; 유형 과 실행 와이드 문자 세트의 c-char 값 (즉, &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbtowc&quot;&gt;mbtowc&lt;/a&gt;&lt;/code&gt; 에 의해 생성 된 값)과 동일한 값을 갖습니다 . c-char를 표현할 수 없거나 하나 이상의 와이드 문자 (예 : wchar_t가 16 비트 인 Windows의 BMP 이외의 값)에 맵핑되는 경우 작동은 구현 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="2a84156b1e5d2b8dfd5bfcccc94c601e1d033fcc" translate="yes" xml:space="preserve">
          <source>4)&lt;a href=&quot;array&quot;&gt;array declarator&lt;/a&gt;: the declaration &lt;code&gt;S D[N]&lt;/code&gt; declares &lt;code&gt;D&lt;/code&gt; as an array of &lt;code&gt;N&lt;/code&gt; objects of the type determined by &lt;code&gt;S&lt;/code&gt;. noptr-declarator is any other declarator except unparenthesized pointer declarator.</source>
          <target state="translated">4) &lt;a href=&quot;array&quot;&gt;배열 선언자&lt;/a&gt; : 선언 &lt;code&gt;S D[N]&lt;/code&gt; 은 &lt;code&gt;D&lt;/code&gt; 를 &lt;code&gt;S&lt;/code&gt; 에 의해 결정된 유형 의 &lt;code&gt;N&lt;/code&gt; 개 오브젝트의 배열로 선언합니다 . noptr-declarator는 괄호로 묶지 않은 포인터 선언자를 제외한 다른 선언자입니다.</target>
        </trans-unit>
        <trans-unit id="616eb196220428421265e5f8738b09b808f13656" translate="yes" xml:space="preserve">
          <source>4)&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; statement</source>
          <target state="translated">4) &lt;a href=&quot;goto&quot;&gt;고토&lt;/a&gt; 진술</target>
        </trans-unit>
        <trans-unit id="3a07a9dfd75b47f48588a149875e9da08571018f" translate="yes" xml:space="preserve">
          <source>4)&lt;a href=&quot;operator_assignment&quot;&gt;Assignment&lt;/a&gt;(until C11)&lt;a href=&quot;initialization&quot;&gt;Initialization&lt;/a&gt;(since C11) is performed to copy the value of each argument to the corresponding function parameter (note; the function can modify its parameters, and those changes do not affect the arguments; C function calls are only call-by-value).</source>
          <target state="translated">4) &lt;a href=&quot;operator_assignment&quot;&gt;지정&lt;/a&gt; (C11까지) &lt;a href=&quot;initialization&quot;&gt;초기화&lt;/a&gt; (C11 이후)는 각 인수의 값을 해당 함수 매개 변수에 복사하기 위해 수행됩니다 (주 : 함수는 매개 변수를 수정할 수 있으며 이러한 변경 사항은 인수에 영향을 미치지 않습니다 .C 함수 호출 만 값별 통화).</target>
        </trans-unit>
        <trans-unit id="61fc5e0d1832ba696c0a1a7138eb93c59f168e63" translate="yes" xml:space="preserve">
          <source>4,5) Number of wide characters written if successful or negative value if an error occurred.</source>
          <target state="translated">4,5) 성공시 기록 된 와이드 문자 수 또는 오류 발생시 음수 값.</target>
        </trans-unit>
        <trans-unit id="6b819074d99c835cfa627632287a0d21a703a16b" translate="yes" xml:space="preserve">
          <source>4,8) Type-generic macros: If &lt;code&gt;arg&lt;/code&gt; has type &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;scalbnl&lt;/code&gt; or &lt;code&gt;scalblnl&lt;/code&gt; is called. Otherwise, if &lt;code&gt;arg&lt;/code&gt; has integer type or the type &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;scalbn&lt;/code&gt; or &lt;code&gt;scalbln&lt;/code&gt; is called. Otherwise, &lt;code&gt;scalbnf&lt;/code&gt; or &lt;code&gt;scalblnf&lt;/code&gt; is called, respectively.</source>
          <target state="translated">4,8) 타입-일반 매크로 : &lt;code&gt;arg&lt;/code&gt; 가 &lt;code&gt;long double&lt;/code&gt; 타입을 가지고 있다면 , &lt;code&gt;scalbnl&lt;/code&gt; 또는 &lt;code&gt;scalblnl&lt;/code&gt; 이 호출됩니다. 그렇지 않으면, &lt;code&gt;arg&lt;/code&gt; 가 정수 유형이거나 &lt;code&gt;double&lt;/code&gt; 유형 인 경우 &lt;code&gt;scalbn&lt;/code&gt; 또는 &lt;code&gt;scalbln&lt;/code&gt; 이 호출됩니다. 그렇지 않으면 &lt;code&gt;scalbnf&lt;/code&gt; 또는 &lt;code&gt;scalblnf&lt;/code&gt; 가 각각 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="701b9bd6f3e085e1eff47f7f9b618514d8124e44" translate="yes" xml:space="preserve">
          <source>4,8,12) Type-generic macros: If &lt;code&gt;arg&lt;/code&gt; has type &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;rintl&lt;/code&gt;, &lt;code&gt;lrintl&lt;/code&gt;, &lt;code&gt;llrintl&lt;/code&gt; is called. Otherwise, if &lt;code&gt;arg&lt;/code&gt; has integer type or the type &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;rint&lt;/code&gt;, &lt;code&gt;lrint&lt;/code&gt;, &lt;code&gt;llrint&lt;/code&gt; is called. Otherwise, &lt;code&gt;rintf&lt;/code&gt;, &lt;code&gt;lrintf&lt;/code&gt;, &lt;code&gt;llrintf&lt;/code&gt; is called, respectively.</source>
          <target state="translated">4,8,12) 형 제네릭 매크로 : 경우 &lt;code&gt;arg&lt;/code&gt; 유형이 &lt;code&gt;long double&lt;/code&gt; , &lt;code&gt;rintl&lt;/code&gt; , &lt;code&gt;lrintl&lt;/code&gt; 을 , &lt;code&gt;llrintl&lt;/code&gt; 가 호출된다. 그렇지 않은 경우, &lt;code&gt;arg&lt;/code&gt; 정수 유형 또는 유형이 &lt;code&gt;double&lt;/code&gt; , &lt;code&gt;rint&lt;/code&gt; , &lt;code&gt;lrint&lt;/code&gt; 을 , &lt;code&gt;llrint&lt;/code&gt; 가 호출된다. 그렇지 않으면 &lt;code&gt;rintf&lt;/code&gt; , &lt;code&gt;lrintf&lt;/code&gt; , &lt;code&gt;llrintf&lt;/code&gt; 가 각각 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="f5feea8142b580a120f0974c769432c82741037c" translate="yes" xml:space="preserve">
          <source>4,8,12) Type-generic macros: If &lt;code&gt;arg&lt;/code&gt; has type &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;roundl&lt;/code&gt;, &lt;code&gt;lroundl&lt;/code&gt;, &lt;code&gt;llroundl&lt;/code&gt; is called. Otherwise, if &lt;code&gt;arg&lt;/code&gt; has integer type or the type &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;round&lt;/code&gt;, &lt;code&gt;lround&lt;/code&gt;, &lt;code&gt;llround&lt;/code&gt; is called. Otherwise, &lt;code&gt;roundf&lt;/code&gt;, &lt;code&gt;lroundf&lt;/code&gt;, &lt;code&gt;llroundf&lt;/code&gt; is called, respectively.</source>
          <target state="translated">4,8,12) 형 제네릭 매크로 : 경우 &lt;code&gt;arg&lt;/code&gt; 유형이 &lt;code&gt;long double&lt;/code&gt; , &lt;code&gt;roundl&lt;/code&gt; , &lt;code&gt;lroundl&lt;/code&gt; 을 , &lt;code&gt;llroundl&lt;/code&gt; 가 호출된다. 그렇지 않은 경우, &lt;code&gt;arg&lt;/code&gt; 유형 또는 유형의 정수가 &lt;code&gt;double&lt;/code&gt; , &lt;code&gt;round&lt;/code&gt; , &lt;code&gt;lround&lt;/code&gt; , &lt;code&gt;llround&lt;/code&gt; 가 호출된다. 그렇지 않으면 &lt;code&gt;roundf&lt;/code&gt; , &lt;code&gt;lroundf&lt;/code&gt; , &lt;code&gt;llroundf&lt;/code&gt; 가 각각 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="bfedcba93ea8a1094d2f2b0c37492578e1d12812" translate="yes" xml:space="preserve">
          <source>4-6) First, converts the first argument to the type of the function, then returns the next representable value of &lt;code&gt;from&lt;/code&gt; in the direction of &lt;code&gt;to&lt;/code&gt;. If &lt;code&gt;from&lt;/code&gt; equals to &lt;code&gt;to&lt;/code&gt;, &lt;code&gt;to&lt;/code&gt; is returned, converted from &lt;code&gt;long double&lt;/code&gt; to the return type of the function without loss of range or precision.</source>
          <target state="translated">4-6) 우선,이 함수의 형태로 첫 번째 인수로 변환 한 후, 다음의 표현 가능한 값을 반환 &lt;code&gt;from&lt;/code&gt; 의 방향 &lt;code&gt;to&lt;/code&gt; . 경우 &lt;code&gt;from&lt;/code&gt; 같음에 &lt;code&gt;to&lt;/code&gt; , &lt;code&gt;to&lt;/code&gt; 반환, 변환 &lt;code&gt;long double&lt;/code&gt; 범위 또는 정밀도의 손실없이 함수의 반환 유형.</target>
        </trans-unit>
        <trans-unit id="8511a4a4d97ef7a294876b5fcaa24a29639ddd7d" translate="yes" xml:space="preserve">
          <source>4-6) If the macro constants &lt;code&gt;FP_FAST_FMAF&lt;/code&gt;, &lt;code&gt;FP_FAST_FMA&lt;/code&gt;, or &lt;code&gt;FP_FAST_FMAL&lt;/code&gt; are defined, the corresponding function &lt;code&gt;fmaf&lt;/code&gt;, &lt;code&gt;fma&lt;/code&gt;, or &lt;code&gt;fmal&lt;/code&gt; evaluates faster (in addition to being more precise) than the expression &lt;code&gt;x*y+z&lt;/code&gt; for &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, and &lt;code&gt;long double&lt;/code&gt; arguments, respectively. If defined, these macros evaluate to integer &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">4-6) 매크로 상수 경우 &lt;code&gt;FP_FAST_FMAF&lt;/code&gt; , &lt;code&gt;FP_FAST_FMA&lt;/code&gt; 또는 &lt;code&gt;FP_FAST_FMAL&lt;/code&gt; 가 정의되어, 해당 기능 &lt;code&gt;fmaf&lt;/code&gt; , &lt;code&gt;fma&lt;/code&gt; 또는 &lt;code&gt;fmal&lt;/code&gt; 표현보다 더 빨리 (또한 평가하여보다 정확한되기 위해서는) &lt;code&gt;x*y+z&lt;/code&gt; 위한 &lt;code&gt;float&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; 및 &lt;code&gt;long double&lt;/code&gt; 인수. 정의 된 경우 이러한 매크로는 정수 &lt;code&gt;1&lt;/code&gt; 로 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="c2b2b0244e4070858aa2c0d94b59c8757cefc5dc" translate="yes" xml:space="preserve">
          <source>4-6) Same as (1-3), except that &lt;code&gt;%c&lt;/code&gt;, &lt;code&gt;%s&lt;/code&gt;, and &lt;code&gt;%[&lt;/code&gt; conversion specifiers each expect two arguments (the usual pointer and a value of type &lt;code&gt;rsize_t&lt;/code&gt; indicating the size of the receiving array, which may be 1 when reading with a %c into a single char) and except that the following errors are detected at runtime and call the currently installed &lt;a href=&quot;../error/set_constraint_handler_s&quot;&gt;constraint handler&lt;/a&gt; function:</source>
          <target state="translated">4-6) &lt;code&gt;%c&lt;/code&gt; , &lt;code&gt;%s&lt;/code&gt; 및 &lt;code&gt;%[&lt;/code&gt; 변환 지정자는 각각 두 개의 인수 (일반 포인터 및 수신 배열의 크기를 나타내는 &lt;code&gt;rsize_t&lt;/code&gt; 유형의 값)를 예상 한다는 점을 제외하고는 (1-3)과 동일 합니다. 단일 문자로 % c를 사용하여 읽을 때 1) 런타임에 다음 오류가 감지되고 현재 설치된 &lt;a href=&quot;../error/set_constraint_handler_s&quot;&gt;제한 조건 핸들러&lt;/a&gt; 함수를 호출하는 것을 제외하고 :</target>
        </trans-unit>
        <trans-unit id="7eff0ec5e8365825b937886c714c3c2a08d41f33" translate="yes" xml:space="preserve">
          <source>4-6) Same as (1-3), except that &lt;code&gt;%c&lt;/code&gt;, &lt;code&gt;%s&lt;/code&gt;, and &lt;code&gt;%[&lt;/code&gt; conversion specifiers each expect two arguments (the usual pointer and a value of type &lt;code&gt;rsize_t&lt;/code&gt; indicating the size of the receiving array, which may be 1 when reading with a %lc into a single wide character) and except that the following errors are detected at runtime and call the currently installed &lt;a href=&quot;../error/set_constraint_handler_s&quot;&gt;constraint handler&lt;/a&gt; function:</source>
          <target state="translated">4-6) &lt;code&gt;%c&lt;/code&gt; , &lt;code&gt;%s&lt;/code&gt; 및 &lt;code&gt;%[&lt;/code&gt; 변환 지정자는 각각 두 개의 인수 (일반 포인터 및 수신 배열의 크기를 나타내는 &lt;code&gt;rsize_t&lt;/code&gt; 유형의 값)를 예상 한다는 점을 제외하고는 (1-3)과 동일 합니다. 1을 넓은 문자 하나로 % lc로 읽을 때) 런타임에 다음 오류가 감지되고 현재 설치된 &lt;a href=&quot;../error/set_constraint_handler_s&quot;&gt;제약 조건 처리기&lt;/a&gt; 함수를 호출하는 경우를 제외하고</target>
        </trans-unit>
        <trans-unit id="aecfa6df319d46099718cc295ad11722aa91e3e5" translate="yes" xml:space="preserve">
          <source>4-6) Same as (1-3), except that &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; is also returned if there is a runtime constraint violation.</source>
          <target state="translated">4-6) 런타임 제약 조건 위반이있는 경우 &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; 도 반환 된다는 점을 제외하고 (1-3)과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="1a78fa3daf845ac3d1ef397d31f8f4edd73a5b84" translate="yes" xml:space="preserve">
          <source>4-6) Same as (1-3), except that the following errors are detected at runtime and call the currently installed &lt;a href=&quot;../error/set_constraint_handler_s&quot;&gt;constraint handler&lt;/a&gt; function:</source>
          <target state="translated">4-6) 런타임에 다음 오류가 감지되고 현재 설치된 &lt;a href=&quot;../error/set_constraint_handler_s&quot;&gt;제약 조건 처리기&lt;/a&gt; 함수를 호출한다는 점을 제외하고 (1-3)과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="11850ea3ac2098b560e44d65b926ee2bdebf3302" translate="yes" xml:space="preserve">
          <source>4.1.3 Errors &amp;lt;errno.h&amp;gt;</source>
          <target state="translated">4.1.3 오류 &amp;lt;errno.h&amp;gt;</target>
        </trans-unit>
        <trans-unit id="f57505d8dcc40b41eb1c92dce3c7690507dd06c9" translate="yes" xml:space="preserve">
          <source>4.1.4 Limits &amp;lt;float.h&amp;gt; and &amp;lt;limits.h&amp;gt;</source>
          <target state="translated">4.1.4 한계 &amp;lt;float.h&amp;gt; 및 &amp;lt;limits.h&amp;gt;</target>
        </trans-unit>
        <trans-unit id="6fa17ced5ba223238303d436fea119166891d914" translate="yes" xml:space="preserve">
          <source>4.1.5 Common definitions &amp;lt;stddef.h&amp;gt;</source>
          <target state="translated">4.1.5 공통 정의 &amp;lt;stddef.h&amp;gt;</target>
        </trans-unit>
        <trans-unit id="7353b09a616a01b4219c5ded32bdbd81497d87c0" translate="yes" xml:space="preserve">
          <source>4.10 GENERAL UTILITIES &amp;lt;stdlib.h&amp;gt;</source>
          <target state="translated">4.10 일반 유틸리티 &amp;lt;stdlib.h&amp;gt;</target>
        </trans-unit>
        <trans-unit id="5d0707f3ebf5e09557f771518fcb52a988e29451" translate="yes" xml:space="preserve">
          <source>4.10 General utilities &amp;lt;stdlib.h&amp;gt;</source>
          <target state="translated">4.10 일반 유틸리티 &amp;lt;stdlib.h&amp;gt;</target>
        </trans-unit>
        <trans-unit id="030b7816c78d179a6a891b8e59beeb90698513a5" translate="yes" xml:space="preserve">
          <source>4.10 div_t, ldiv_t</source>
          <target state="translated">4.10 div_t, ldiv_t</target>
        </trans-unit>
        <trans-unit id="73ac77713d660c44f4961c725de06fcb8a7a3151" translate="yes" xml:space="preserve">
          <source>4.10.1.1 The atof function</source>
          <target state="translated">4.10.1.1 atof 기능</target>
        </trans-unit>
        <trans-unit id="ffb26e23a3238b8eaa67fce988e27a78ba2e637f" translate="yes" xml:space="preserve">
          <source>4.10.1.2 The atoi function</source>
          <target state="translated">4.10.1.2 아토이 기능</target>
        </trans-unit>
        <trans-unit id="34ce89943a3d6555ac388310044b6eb7d19997a9" translate="yes" xml:space="preserve">
          <source>4.10.1.3 The atol function</source>
          <target state="translated">4.10.1.3 아톨 함수</target>
        </trans-unit>
        <trans-unit id="f1639fee6f36aa9c32e6a673576bfa2fc8f40ee4" translate="yes" xml:space="preserve">
          <source>4.10.1.4 The strtod function</source>
          <target state="translated">4.10.1.4 strtod 함수</target>
        </trans-unit>
        <trans-unit id="67a881370facf5aa93a7f648a1344a38dc27b775" translate="yes" xml:space="preserve">
          <source>4.10.1.5 The strtol function</source>
          <target state="translated">4.10.1.5 strtol 함수</target>
        </trans-unit>
        <trans-unit id="4194394d5c1363fff08d1d2d955bd897fb681f87" translate="yes" xml:space="preserve">
          <source>4.10.1.6 The strtoul function</source>
          <target state="translated">4.10.1.6 strtoul 함수</target>
        </trans-unit>
        <trans-unit id="25c1094c4460904df01563515105f981cebe5b9c" translate="yes" xml:space="preserve">
          <source>4.10.2 Pseudo-random sequence generation functions</source>
          <target state="translated">4.10.2 의사 랜덤 시퀀스 생성 기능</target>
        </trans-unit>
        <trans-unit id="308b34386a77545bf507a3ab9ad4c2b4cfa36e1f" translate="yes" xml:space="preserve">
          <source>4.10.2.1 The rand function</source>
          <target state="translated">rand 함수</target>
        </trans-unit>
        <trans-unit id="74b4e68ffdb31be7c46beef94e0b499f67907642" translate="yes" xml:space="preserve">
          <source>4.10.2.2 The srand function</source>
          <target state="translated">4.10.2.2 사란 기능</target>
        </trans-unit>
        <trans-unit id="8a71c4c89aca219e515900109e4ff7057d613639" translate="yes" xml:space="preserve">
          <source>4.10.3.1 The calloc function</source>
          <target state="translated">4.10.3.1 calloc 함수</target>
        </trans-unit>
        <trans-unit id="fcc698a751f01ffc79949ed06dcf6544be370eca" translate="yes" xml:space="preserve">
          <source>4.10.3.2 The free function</source>
          <target state="translated">4.10.3.2 자유 기능</target>
        </trans-unit>
        <trans-unit id="b5f3ba525ddbcc4eb2cddd39e44b63523542cf83" translate="yes" xml:space="preserve">
          <source>4.10.3.3 The malloc function</source>
          <target state="translated">4.10.3.3 malloc 함수</target>
        </trans-unit>
        <trans-unit id="efe4719098c6fa7cab388133ed0a98f5d48aa581" translate="yes" xml:space="preserve">
          <source>4.10.3.4 The realloc function</source>
          <target state="translated">4.10.3.4 realloc 함수</target>
        </trans-unit>
        <trans-unit id="20d28119c10803fb0141489bfef1e262dd8d717b" translate="yes" xml:space="preserve">
          <source>4.10.4.1 The abort function</source>
          <target state="translated">4.10.4.1 중단 기능</target>
        </trans-unit>
        <trans-unit id="4556d095d4b19ef9e85f0e2986260fcea040099f" translate="yes" xml:space="preserve">
          <source>4.10.4.2 The atexit function</source>
          <target state="translated">4.10.4.2 atexit 함수</target>
        </trans-unit>
        <trans-unit id="c53931011335c38c14d0aba40426c0b769fe2aed" translate="yes" xml:space="preserve">
          <source>4.10.4.3 The exit function</source>
          <target state="translated">4.10.4.3 종료 기능</target>
        </trans-unit>
        <trans-unit id="1162417de596d412e1c5aff5d52d636284d1c19b" translate="yes" xml:space="preserve">
          <source>4.10.4.4 The getenv function</source>
          <target state="translated">getenv 함수</target>
        </trans-unit>
        <trans-unit id="2f51cb245b45e70adbf95eb64e997ae326005b8f" translate="yes" xml:space="preserve">
          <source>4.10.4.5 The system function</source>
          <target state="translated">4.10.4.5 시스템 기능</target>
        </trans-unit>
        <trans-unit id="bb1f10b3e5bc0ec95785db4501e117609e541b60" translate="yes" xml:space="preserve">
          <source>4.10.5 Searching and sorting utilities</source>
          <target state="translated">4.10.5 검색 및 정렬 유틸리티</target>
        </trans-unit>
        <trans-unit id="7ef419c7aac1e72480552fe294570b622a050423" translate="yes" xml:space="preserve">
          <source>4.10.5.1 The bsearch function</source>
          <target state="translated">4.10.5.1 검색 기능</target>
        </trans-unit>
        <trans-unit id="965ae84d15b829fb612775ef6017644db1a921f3" translate="yes" xml:space="preserve">
          <source>4.10.5.2 The qsort function</source>
          <target state="translated">4.10.5.2 qsort 함수</target>
        </trans-unit>
        <trans-unit id="4d0f5a12e2a7b77b70c380d5d015e05a8e81f486" translate="yes" xml:space="preserve">
          <source>4.10.6.1 The abs function</source>
          <target state="translated">4.10.6.1 abs 기능</target>
        </trans-unit>
        <trans-unit id="94e625c17206edf0cf1ebe956ab5a6b995ff522a" translate="yes" xml:space="preserve">
          <source>4.10.6.2 The div function</source>
          <target state="translated">div 함수</target>
        </trans-unit>
        <trans-unit id="662929a6fbf43674fc9cc4edc5ffd22eb94ca280" translate="yes" xml:space="preserve">
          <source>4.10.6.3 The labs function</source>
          <target state="translated">4.10.6.3 실험실 기능</target>
        </trans-unit>
        <trans-unit id="2d3c27e0f1ea58155133b63f93402d8beb0a1e7f" translate="yes" xml:space="preserve">
          <source>4.10.6.4 The ldiv function</source>
          <target state="translated">4.10.6.4 ldiv 함수</target>
        </trans-unit>
        <trans-unit id="e9e45ca8d87fcb8818ba82e59efd66ad0455fa57" translate="yes" xml:space="preserve">
          <source>4.10.7.1 The mblen function</source>
          <target state="translated">4.10.7.1 상징적 인 기능</target>
        </trans-unit>
        <trans-unit id="dddb7edba70c1ae83e46c74e17dc5b2be50589d3" translate="yes" xml:space="preserve">
          <source>4.10.7.2 The mbtowc function</source>
          <target state="translated">4.10.7.2 mbtowc 함수</target>
        </trans-unit>
        <trans-unit id="a3e464d202a0d2a508f27813e6316ed7dc6d5794" translate="yes" xml:space="preserve">
          <source>4.10.7.3 The wctomb function</source>
          <target state="translated">4.10.7.3 wctomb 기능</target>
        </trans-unit>
        <trans-unit id="ea3bafb1a88da3617856633ae48e3a6253ac9a98" translate="yes" xml:space="preserve">
          <source>4.10.8.1 The mbstowcs function</source>
          <target state="translated">mbstowcs 기능</target>
        </trans-unit>
        <trans-unit id="0b64f13e1aaccfd591daa38518ef7895f7f03153" translate="yes" xml:space="preserve">
          <source>4.10.8.2 The wcstombs function</source>
          <target state="translated">4.10.8.2 wcstombs 함수</target>
        </trans-unit>
        <trans-unit id="397aaa3c657d4e1812ea4859df77a07bfcef863e" translate="yes" xml:space="preserve">
          <source>4.11 STRING HANDLING &amp;lt;string.h&amp;gt;</source>
          <target state="translated">4.11 문자열 처리 &amp;lt;string.h&amp;gt;</target>
        </trans-unit>
        <trans-unit id="27982b73a2fe5acd81b1c0a5b28a1b7a75158eb5" translate="yes" xml:space="preserve">
          <source>4.11.2.1 The memcpy function</source>
          <target state="translated">4.11.2.1 memcpy 함수</target>
        </trans-unit>
        <trans-unit id="cf0c0722bf7c311c75c0af939e03487916bb77d4" translate="yes" xml:space="preserve">
          <source>4.11.2.2 The memmove function</source>
          <target state="translated">4.11.2.2 memmove 기능</target>
        </trans-unit>
        <trans-unit id="cb3e7be0f8376b2a0191e780825fb8cae1dee869" translate="yes" xml:space="preserve">
          <source>4.11.2.3 The strcpy function</source>
          <target state="translated">4.11.2.3 strcpy 함수</target>
        </trans-unit>
        <trans-unit id="3a44bccbd5814cffcdb2af127773763f1cf1c134" translate="yes" xml:space="preserve">
          <source>4.11.2.4 The strncpy function</source>
          <target state="translated">4.11.2.4 strncpy 함수</target>
        </trans-unit>
        <trans-unit id="35851af97d147704325927462592492a63707f05" translate="yes" xml:space="preserve">
          <source>4.11.3.1 The strcat function</source>
          <target state="translated">strcat 함수</target>
        </trans-unit>
        <trans-unit id="b0d9f7aade5bef14f572098acfe4acb002f64534" translate="yes" xml:space="preserve">
          <source>4.11.3.2 The strncat function</source>
          <target state="translated">4.11.3.2 strncat 함수</target>
        </trans-unit>
        <trans-unit id="147d8a2da1e57b6ccff764009d826a8391ddd931" translate="yes" xml:space="preserve">
          <source>4.11.4.1 The memcmp function</source>
          <target state="translated">4.11.4.1 memcmp 함수</target>
        </trans-unit>
        <trans-unit id="53d87c7e3caad5b33a9a123ce5dc888f9c673267" translate="yes" xml:space="preserve">
          <source>4.11.4.2 The strcmp function</source>
          <target state="translated">4.11.4.2 strcmp 함수</target>
        </trans-unit>
        <trans-unit id="679e9fbaef3755a6ad5c4934181d919155cf43a9" translate="yes" xml:space="preserve">
          <source>4.11.4.3 The strcoll function</source>
          <target state="translated">strcoll 함수</target>
        </trans-unit>
        <trans-unit id="cd87758b1e25b66f096070792cc18a253d0ab609" translate="yes" xml:space="preserve">
          <source>4.11.4.4 The strncmp function</source>
          <target state="translated">strncmp 함수</target>
        </trans-unit>
        <trans-unit id="b5ada7a99dcaa406eaa4536ec287ec9dda88c4b1" translate="yes" xml:space="preserve">
          <source>4.11.4.5 The strxfrm function</source>
          <target state="translated">4.11.4.5 strxfrm 함수</target>
        </trans-unit>
        <trans-unit id="5335f3ff77d892c688b47e8fbf14d9a0b683a3f4" translate="yes" xml:space="preserve">
          <source>4.11.5.1 The memchr function</source>
          <target state="translated">4.11.5.1 memchr 함수</target>
        </trans-unit>
        <trans-unit id="b2945ecc8b4c0a5ffcf07b1a3396be7c548aa5c1" translate="yes" xml:space="preserve">
          <source>4.11.5.2 The strchr function</source>
          <target state="translated">4.11.5.2 strchr 함수</target>
        </trans-unit>
        <trans-unit id="12ca01a712a2591c805b2170bbdb0ef7e19340c6" translate="yes" xml:space="preserve">
          <source>4.11.5.3 The strcspn function</source>
          <target state="translated">4.11.5.3 strcspn 함수</target>
        </trans-unit>
        <trans-unit id="3dd380dea09ff137b225a4181a003f3a29d13d5f" translate="yes" xml:space="preserve">
          <source>4.11.5.4 The strpbrk function</source>
          <target state="translated">strpbrk 함수</target>
        </trans-unit>
        <trans-unit id="094d819d3e43e822accc6d4e4e9468e1b32a7071" translate="yes" xml:space="preserve">
          <source>4.11.5.5 The strrchr function</source>
          <target state="translated">4.11.5.5 strrchr 기능</target>
        </trans-unit>
        <trans-unit id="407104944c85150c7190d18dd19aaacbe8236383" translate="yes" xml:space="preserve">
          <source>4.11.5.6 The strspn function</source>
          <target state="translated">strspn 함수</target>
        </trans-unit>
        <trans-unit id="bc991a55ac1077572e23d39657f2bd6892e542d8" translate="yes" xml:space="preserve">
          <source>4.11.5.7 The strstr function</source>
          <target state="translated">4.11.5.7 strstr 함수</target>
        </trans-unit>
        <trans-unit id="ba55690f2781fddda30887ffdb570108655e38be" translate="yes" xml:space="preserve">
          <source>4.11.5.8 The strtok function</source>
          <target state="translated">4.11.5.8 strtok 기능</target>
        </trans-unit>
        <trans-unit id="e52849b5d3a6b14ae56d47e2705623866ee31e69" translate="yes" xml:space="preserve">
          <source>4.11.6.1 The memset function</source>
          <target state="translated">4.11.6.1 memset 함수</target>
        </trans-unit>
        <trans-unit id="2f6bb626000eeb23b96b313ed0392e5fb5d1d6e0" translate="yes" xml:space="preserve">
          <source>4.11.6.2 The strerror function</source>
          <target state="translated">4.11.6.2 strerror 기능</target>
        </trans-unit>
        <trans-unit id="e0713e6a6f9737ffcce9dffd1ddc75d5e69588e2" translate="yes" xml:space="preserve">
          <source>4.11.6.3 The strlen function</source>
          <target state="translated">4.11.6.3 strlen 함수</target>
        </trans-unit>
        <trans-unit id="c8fa872f6c4ed97120307f2cffd80d508aeb5503" translate="yes" xml:space="preserve">
          <source>4.12 DATE AND TIME &amp;lt;time.h&amp;gt;</source>
          <target state="translated">4.12 날짜 및 시간 &amp;lt;time.h&amp;gt;</target>
        </trans-unit>
        <trans-unit id="dfa11d10bcc0ca629480802f166596ebe158a4f2" translate="yes" xml:space="preserve">
          <source>4.12.1 Components of time</source>
          <target state="translated">4.12.1 시간의 구성 요소</target>
        </trans-unit>
        <trans-unit id="0d2c621f8d1b1d310ed83aad92d102746117dc44" translate="yes" xml:space="preserve">
          <source>4.12.2.1 The clock function</source>
          <target state="translated">4.12.2.1 시계 기능</target>
        </trans-unit>
        <trans-unit id="6cd5b7a26547a230206ac2251de8cd0c13874208" translate="yes" xml:space="preserve">
          <source>4.12.2.2 The difftime function</source>
          <target state="translated">4.12.2.2 difftime 함수</target>
        </trans-unit>
        <trans-unit id="4bab5e67834ef29ee5c2677b4ba3a50ab1b9a97a" translate="yes" xml:space="preserve">
          <source>4.12.2.3 The mktime function</source>
          <target state="translated">mktime 함수</target>
        </trans-unit>
        <trans-unit id="b6fe040a736eec6979dcdf33a7ea16c45bf1d74c" translate="yes" xml:space="preserve">
          <source>4.12.2.4 The time function</source>
          <target state="translated">4.12.2.4 시간 함수</target>
        </trans-unit>
        <trans-unit id="258d0badaf5254fd466f8045e9c91ca11548405d" translate="yes" xml:space="preserve">
          <source>4.12.3.1 The asctime function</source>
          <target state="translated">4.12.3.1 상승 시간 기능</target>
        </trans-unit>
        <trans-unit id="1f46d782acc5b674a592a38c822f758ea6e4e95e" translate="yes" xml:space="preserve">
          <source>4.12.3.2 The ctime function</source>
          <target state="translated">4.12.3.2 ctime 함수</target>
        </trans-unit>
        <trans-unit id="517643c3f09bc482dab30e1b3c3a737594d96de9" translate="yes" xml:space="preserve">
          <source>4.12.3.3 The gmtime function</source>
          <target state="translated">4.12.3.3 gmtime 함수</target>
        </trans-unit>
        <trans-unit id="da6eb3692250fbbca9fb590f0319b236cd18087d" translate="yes" xml:space="preserve">
          <source>4.12.3.4 The localtime function</source>
          <target state="translated">4.12.3.4 현지 시간 기능</target>
        </trans-unit>
        <trans-unit id="b24e8fabba7f7dd0ecb8519898450f45a59cec3e" translate="yes" xml:space="preserve">
          <source>4.12.3.5 The strftime function</source>
          <target state="translated">4.12.3.5 strftime 함수</target>
        </trans-unit>
        <trans-unit id="da54ca62b7c81d53f05bf7add442845e944ffb97" translate="yes" xml:space="preserve">
          <source>4.13.1 Errors &amp;lt;errno.h&amp;gt;</source>
          <target state="translated">4.13.1 오류 &amp;lt;errno.h&amp;gt;</target>
        </trans-unit>
        <trans-unit id="77e2c1b6ec248a4db886ef1796882996176f08f2" translate="yes" xml:space="preserve">
          <source>4.13.2 Character handling &amp;lt;ctype.h&amp;gt;</source>
          <target state="translated">4.13.2 문자 처리 &amp;lt;ctype.h&amp;gt;</target>
        </trans-unit>
        <trans-unit id="9408ed012574d1d0fce06cc4f173abd4097c7eee" translate="yes" xml:space="preserve">
          <source>4.13.3 Localization &amp;lt;locale.h&amp;gt;</source>
          <target state="translated">4.13.3 현지화 &amp;lt;locale.h&amp;gt;</target>
        </trans-unit>
        <trans-unit id="f7c5715bbeac4ce6482e5cd4785e20fa5b1c555a" translate="yes" xml:space="preserve">
          <source>4.13.4 Mathematics &amp;lt;math.h&amp;gt;</source>
          <target state="translated">4.13.4 수학 &amp;lt;math.h&amp;gt;</target>
        </trans-unit>
        <trans-unit id="599f8be04701d314ef111b73888815b46ec2cf02" translate="yes" xml:space="preserve">
          <source>4.13.5 Signal handling &amp;lt;signal.h&amp;gt;</source>
          <target state="translated">4.13.5 신호 처리 &amp;lt;signal.h&amp;gt;</target>
        </trans-unit>
        <trans-unit id="8466ce7c1321e122ffcb931b4a7c30a41f12822a" translate="yes" xml:space="preserve">
          <source>4.13.6 Input/output &amp;lt;stdio.h&amp;gt;</source>
          <target state="translated">4.13.6 입출력 &amp;lt;stdio.h&amp;gt;</target>
        </trans-unit>
        <trans-unit id="624b4b36d59fdb10155952434856bbec754f0bb2" translate="yes" xml:space="preserve">
          <source>4.13.7 General utilities &amp;lt;stdlib.h&amp;gt;</source>
          <target state="translated">4.13.7 일반 유틸리티 &amp;lt;stdlib.h&amp;gt;</target>
        </trans-unit>
        <trans-unit id="94bc150a9b0afce7ce512254112a5960da56f8bc" translate="yes" xml:space="preserve">
          <source>4.13.8 String handling &amp;lt;string.h&amp;gt;</source>
          <target state="translated">4.13.8 문자열 처리 &amp;lt;string.h&amp;gt;</target>
        </trans-unit>
        <trans-unit id="c8722942f8e9080d47a848e3ffe01acb0269701b" translate="yes" xml:space="preserve">
          <source>4.2 DIAGNOSTICS &amp;lt;assert.h&amp;gt;</source>
          <target state="translated">4.2 진단 &amp;lt;assert.h&amp;gt;</target>
        </trans-unit>
        <trans-unit id="085dba060f31ee413b801b9c029abce9861ee8a3" translate="yes" xml:space="preserve">
          <source>4.2.1.1 The assert macro</source>
          <target state="translated">4.2.1.1 주장 매크로</target>
        </trans-unit>
        <trans-unit id="cdb2641b55040c6466fa39dfee2b63ba3a496cfd" translate="yes" xml:space="preserve">
          <source>4.3 CHARACTER HANDLING &amp;lt;ctype.h&amp;gt;</source>
          <target state="translated">4.3 문자 처리 &amp;lt;ctype.h&amp;gt;</target>
        </trans-unit>
        <trans-unit id="556542a246575ae145f055a7282106037b951137" translate="yes" xml:space="preserve">
          <source>4.3.1.1 The isalnum function</source>
          <target state="translated">4.3.1.1 isalnum 함수</target>
        </trans-unit>
        <trans-unit id="1ea2245f4b70e53f2bd484a69c98f4ebb50a0607" translate="yes" xml:space="preserve">
          <source>4.3.1.10 The isupper function</source>
          <target state="translated">4.3.1.10 isupper 기능</target>
        </trans-unit>
        <trans-unit id="277e6e86e917986ef47644dc2734d74a207bad40" translate="yes" xml:space="preserve">
          <source>4.3.1.11 The isxdigit function</source>
          <target state="translated">4.3.1.11 isxdigit 함수</target>
        </trans-unit>
        <trans-unit id="3f7dfc0a581a5a365d1d6958b6f6f8508f5a05c9" translate="yes" xml:space="preserve">
          <source>4.3.1.2 The isalpha function</source>
          <target state="translated">4.3.1.2 isalpha 함수</target>
        </trans-unit>
        <trans-unit id="4a170d03817e3153e2542944466dae640e227ef0" translate="yes" xml:space="preserve">
          <source>4.3.1.3 The iscntrl function</source>
          <target state="translated">4.3.1.3 iscntrl 함수</target>
        </trans-unit>
        <trans-unit id="d9215b471115373d7bcd5e77713cab4ea98dd636" translate="yes" xml:space="preserve">
          <source>4.3.1.4 The isdigit function</source>
          <target state="translated">4.3.1.4 isdigit 함수</target>
        </trans-unit>
        <trans-unit id="0ec4ce03b1a16746ba757cce1d83f967636872ce" translate="yes" xml:space="preserve">
          <source>4.3.1.5 The isgraph function</source>
          <target state="translated">4.3.1.5 isgraph 기능</target>
        </trans-unit>
        <trans-unit id="a9c7245dd5f7943ad123334827a4b40f2787addf" translate="yes" xml:space="preserve">
          <source>4.3.1.6 The islower function</source>
          <target state="translated">4.3.1.6 더 낮은 기능</target>
        </trans-unit>
        <trans-unit id="f39396d1fa2302b58e04299733c245658fc5d29e" translate="yes" xml:space="preserve">
          <source>4.3.1.7 The isprint function</source>
          <target state="translated">4.3.1.7 isprint 기능</target>
        </trans-unit>
        <trans-unit id="633e47aef746edde6bd9bb57d4a0980410bf2b0d" translate="yes" xml:space="preserve">
          <source>4.3.1.8 The ispunct function</source>
          <target state="translated">4.3.1.8 ispunct 함수</target>
        </trans-unit>
        <trans-unit id="8489ae1644ea0f86d79a89e8797bc37a10b2f3c1" translate="yes" xml:space="preserve">
          <source>4.3.1.9 The isspace function</source>
          <target state="translated">4.3.1.9 isspace 함수</target>
        </trans-unit>
        <trans-unit id="81f2b6e4c8e528ad232541aa46337f270c1c45e6" translate="yes" xml:space="preserve">
          <source>4.3.2.1 The tolower function</source>
          <target state="translated">4.3.2.1 더 낮은 기능</target>
        </trans-unit>
        <trans-unit id="e8cdcfda19f9ddd1cc4f76537380c18aec556653" translate="yes" xml:space="preserve">
          <source>4.3.2.2 The toupper function</source>
          <target state="translated">4.3.2.2 상부 기능</target>
        </trans-unit>
        <trans-unit id="bb2c23d547b7ce525ea46dec7e1199fd78fa67a6" translate="yes" xml:space="preserve">
          <source>4.4 LOCALIZATION &amp;lt;locale.h&amp;gt;</source>
          <target state="translated">4.4 현지화 &amp;lt;locale.h&amp;gt;</target>
        </trans-unit>
        <trans-unit id="9ba0b99904ed9d2acef6ef5a3c7545e43f88060c" translate="yes" xml:space="preserve">
          <source>4.4.1.1 The setlocale function</source>
          <target state="translated">4.4.1.1 setlocale 함수</target>
        </trans-unit>
        <trans-unit id="184b69358121e587dc0780132edf3872e883f359" translate="yes" xml:space="preserve">
          <source>4.4.2.1 The localeconv function</source>
          <target state="translated">4.4.2.1 localeconv 기능</target>
        </trans-unit>
        <trans-unit id="d73f5427b1e5bc637ac33676e0b4de20edf9190b" translate="yes" xml:space="preserve">
          <source>4.5 HUGE_VAL</source>
          <target state="translated">4.5 HUGE_VAL</target>
        </trans-unit>
        <trans-unit id="51a77b0e722c07612111867a4e873b8601697621" translate="yes" xml:space="preserve">
          <source>4.5 MATHEMATICS &amp;lt;math.h&amp;gt;</source>
          <target state="translated">4.5 수학 &amp;lt;math.h&amp;gt;</target>
        </trans-unit>
        <trans-unit id="183d8f5ab9fd98b9b30e2fb5e92607ea7d68288b" translate="yes" xml:space="preserve">
          <source>4.5.2.1 The acos function</source>
          <target state="translated">4.5.2.1 acos 함수</target>
        </trans-unit>
        <trans-unit id="0975d72c7a852056c272179a3b167d0a6c72a21f" translate="yes" xml:space="preserve">
          <source>4.5.2.2 The asin function</source>
          <target state="translated">4.5.2.2 asin 함수</target>
        </trans-unit>
        <trans-unit id="67f3bd75b0ebd7e120fdf909d63b779b70bb66c5" translate="yes" xml:space="preserve">
          <source>4.5.2.3 The atan function</source>
          <target state="translated">4.5.2.3 아탄 기능</target>
        </trans-unit>
        <trans-unit id="7e75a2b7776c4f3fd5280f15156d5c04603790f4" translate="yes" xml:space="preserve">
          <source>4.5.2.4 The atan2 function</source>
          <target state="translated">4.5.2.4 atan2 기능</target>
        </trans-unit>
        <trans-unit id="427ac686faf8c8757e77bde9887260ebf3f394fd" translate="yes" xml:space="preserve">
          <source>4.5.2.5 The cos function</source>
          <target state="translated">4.5.2.5 cos 함수</target>
        </trans-unit>
        <trans-unit id="10017d99aefdcbc03f4387a25a7e64cb2e8055ea" translate="yes" xml:space="preserve">
          <source>4.5.2.6 The sin function</source>
          <target state="translated">4.5.2.6 죄 함수</target>
        </trans-unit>
        <trans-unit id="9e38985cb84c9172466faefb0c08626d31f2e8b9" translate="yes" xml:space="preserve">
          <source>4.5.2.7 The tan function</source>
          <target state="translated">4.5.2.7 tan 함수</target>
        </trans-unit>
        <trans-unit id="58fe075e8cf53c66ecc31005edf2ab95476b314a" translate="yes" xml:space="preserve">
          <source>4.5.3.1 The cosh function</source>
          <target state="translated">코쉬 함수</target>
        </trans-unit>
        <trans-unit id="0a880a7bc51c21e6080342df0c72aafa45dc8631" translate="yes" xml:space="preserve">
          <source>4.5.3.2 The sinh function</source>
          <target state="translated">4.5.3.2 sinh 함수</target>
        </trans-unit>
        <trans-unit id="93e4cebb8fe3931cd406f2e4bb416f83b6368447" translate="yes" xml:space="preserve">
          <source>4.5.3.3 The tanh function</source>
          <target state="translated">4.5.3.3 tanh 함수</target>
        </trans-unit>
        <trans-unit id="6494b776167f1a02b02e0fdea214f93889841de5" translate="yes" xml:space="preserve">
          <source>4.5.4.1 The exp function</source>
          <target state="translated">4.5.4.1 exp 함수</target>
        </trans-unit>
        <trans-unit id="63c49ceab931657153a1b024233e3cf7d6b4fd0f" translate="yes" xml:space="preserve">
          <source>4.5.4.2 The frexp function</source>
          <target state="translated">frexp 함수</target>
        </trans-unit>
        <trans-unit id="df096a60c5ac414da77859920531d0f42939b445" translate="yes" xml:space="preserve">
          <source>4.5.4.3 The ldexp function</source>
          <target state="translated">4.5.4.3 ldexp 함수</target>
        </trans-unit>
        <trans-unit id="d1e2982b3f95c55d04c12f63badd65a0b3e7c874" translate="yes" xml:space="preserve">
          <source>4.5.4.4 The log function</source>
          <target state="translated">4.5.4.4 로그 기능</target>
        </trans-unit>
        <trans-unit id="958f3fa1be493389984fc5faf62ccd83d439a0d8" translate="yes" xml:space="preserve">
          <source>4.5.4.5 The log10 function</source>
          <target state="translated">4.5.4.5 log10 기능</target>
        </trans-unit>
        <trans-unit id="772036150891750d4894b85623ba83a1817f17c7" translate="yes" xml:space="preserve">
          <source>4.5.4.6 The modf function</source>
          <target state="translated">4.5.4.6 modf 함수</target>
        </trans-unit>
        <trans-unit id="fea14decbd4592957ebf8a40f8e8fe9dd40a80fc" translate="yes" xml:space="preserve">
          <source>4.5.5.1 The pow function</source>
          <target state="translated">4.5.5.1 pow 함수</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
