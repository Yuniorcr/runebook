<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="c">
    <body>
      <group id="c">
        <trans-unit id="c893ac9cadbf00f7e9ef1a77d5a304aa079fc5b5" translate="yes" xml:space="preserve">
          <source>The case where the argument is infinite is not specified to be a domain error in C, but it is defined as a &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/tan.html&quot;&gt;domain error in POSIX&lt;/a&gt;.</source>
          <target state="translated">인수가 무한 인 경우 C에서는 도메인 오류로 지정되지 않지만 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/tan.html&quot;&gt;POSIX&lt;/a&gt; 에서는 도메인 오류 로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="b37eb2e5b0429777b4f0099246b03892d2c779ed" translate="yes" xml:space="preserve">
          <source>The case where the argument is infinite is not specified to be a domain error in C, but it is defined as a &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/cos.html&quot;&gt;domain error in POSIX&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85ce9f78e3a22b71278921e72f9f1d3621f8283f" translate="yes" xml:space="preserve">
          <source>The case where the argument is infinite is not specified to be a domain error in C, but it is defined as a &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/sin.html&quot;&gt;domain error in POSIX&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e55db8436986b99e3fbfd5f966d066276dfeccdd" translate="yes" xml:space="preserve">
          <source>The case where the argument is infinite is not specified to be a domain error in C, but it is defined as a &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/tan.html&quot;&gt;domain error in POSIX&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b194103418cca6cbbfda4929c3c1041036b43cf0" translate="yes" xml:space="preserve">
          <source>The cast to void is sometimes useful to silence compiler warnings about unused results.</source>
          <target state="translated">무효로 캐스트는 사용되지 않은 결과에 대한 컴파일러 경고를 끄는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="cb15aa2e205da76a53c99fdb5dd46d7ca6c8252c" translate="yes" xml:space="preserve">
          <source>The characters &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;!&lt;/code&gt; are invariant under ISO-646, but alternatives are provided for the operators that use these characters anyway to accommodate even more restrictive historical charsets.</source>
          <target state="translated">문자 &lt;code&gt;&amp;amp;&lt;/code&gt; 및 &lt;code&gt;!&lt;/code&gt; ISO-646에 따라 변하지 않지만 이러한 문자를 사용하는 운영자를 위해 대안이 제공되어 훨씬 더 제한적인 역사적 문자 세트를 수용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4035fa4f0afd21a7666c6150be01fe027d08712b" translate="yes" xml:space="preserve">
          <source>The characters of the C-strings pointed to by &lt;code&gt;grouping&lt;/code&gt; and &lt;code&gt;mon_grouping&lt;/code&gt; are interpreted according to their numeric values. When the terminating &lt;code&gt;'\0'&lt;/code&gt; is encountered, the last value seen is assumed to repeat for the remainder of digits. If &lt;code&gt;&lt;a href=&quot;../types/limits&quot;&gt;CHAR_MAX&lt;/a&gt;&lt;/code&gt; is encountered, no further digits are grouped. the typical grouping of three digits at a time is &lt;code&gt;&quot;\003&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;grouping&lt;/code&gt; 및 &lt;code&gt;mon_grouping&lt;/code&gt; 으로 가리키는 C- 문자열의 문자는 숫자 값에 따라 해석됩니다. 종료 &lt;code&gt;'\0'&lt;/code&gt; 이 발생하면 마지막으로 본 값이 나머지 숫자에 대해 반복되는 것으로 가정합니다. 경우 &lt;code&gt;&lt;a href=&quot;../types/limits&quot;&gt;CHAR_MAX&lt;/a&gt;&lt;/code&gt; 가 발생, 더 이상의 숫자가 그룹화되지 않습니다. 한 번에 3 자리 숫자의 일반적인 그룹은 &lt;code&gt;&quot;\003&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="389756ed6e9c288a5d7721af8a052706a08051ec" translate="yes" xml:space="preserve">
          <source>The choices made by each implementation about the sizes of the fundamental types are collectively known as</source>
          <target state="translated">기본 유형의 크기에 대해 각 구현에서 선택한 사항을 통칭하여</target>
        </trans-unit>
        <trans-unit id="639291a4f3c29237da353a25b118487f41eb6c93" translate="yes" xml:space="preserve">
          <source>The comma operator expression has the form.</source>
          <target state="translated">쉼표 연산자 식의 형식이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d4d04275fd3986990614e795bf7dee50a7571a4" translate="yes" xml:space="preserve">
          <source>The comma operator may be lvalue in C++, but never in C.</source>
          <target state="translated">쉼표 연산자는 C ++에서는 lvalue 일 수 있지만 C에서는 절대로 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d6fc3f2fb9c171bbd01b3b6dc85f4ee9561d08bf" translate="yes" xml:space="preserve">
          <source>The comma operator may return a struct (the only other expressions that return structs are compound literals, function calls, assignments, and the conditional operator).</source>
          <target state="translated">쉼표 연산자는 구조체를 반환 할 수 있습니다 (구조체를 반환하는 다른 식은 복합 리터럴, 함수 호출, 대입 및 조건 연산자).</target>
        </trans-unit>
        <trans-unit id="b7dee580f11aef5ebe6c5e769d0ef339e265bedd" translate="yes" xml:space="preserve">
          <source>The compiler is free to ignore any or all aliasing implications of uses of &lt;code&gt;restrict&lt;/code&gt;.</source>
          <target state="translated">컴파일러는 &lt;code&gt;restrict&lt;/code&gt; 사용에 대한 앨리어싱 관련 의미를 무시해도 됩니다 .</target>
        </trans-unit>
        <trans-unit id="f5b3b0d4b525dd97c5a4869a198616c5154957d5" translate="yes" xml:space="preserve">
          <source>The compilers are required to issue diagnostic messages (either errors or warnings) for any programs that violates any C syntax rule or semantic constraint, even if its behavior is specified as undefined or implementation-defined or if the compiler provides a language extension that allows it to accept such program. Diagnostics for undefined behavior are not otherwise required.</source>
          <target state="translated">컴파일러는 C 구문 규칙 또는 시맨틱 제약 조건을 위반하는 프로그램에 대해 동작이 정의되지 않았거나 구현 정의로 지정되었거나 컴파일러에서 언어 확장을 제공하는 경우에도 진단 메시지 (오류 또는 경고)를 발행해야합니다. 그러한 프로그램을 수락합니다. 달리 정의되지 않은 동작에 대한 진단은 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="055be4235172d10af24ff6290ec130255293bd45" translate="yes" xml:space="preserve">
          <source>The completion of this function</source>
          <target state="translated">이 기능의 완성</target>
        </trans-unit>
        <trans-unit id="a6dbfec61e3424ffae4ae18efa158e9aeaf2271e" translate="yes" xml:space="preserve">
          <source>The complex arc hyperbolic cosine of &lt;code&gt;z&lt;/code&gt; in the interval [0; &amp;infin;) along the real axis and in the interval [&amp;minus;i&amp;pi;; +i&amp;pi;] along the imaginary axis.</source>
          <target state="translated">간격 [0;에서 &lt;code&gt;z&lt;/code&gt; 의 복소 아크 쌍곡 코사인 &amp;infin;) 실제 축을 따라 간격 [&amp;minus;i&amp;pi;; 가상 축을 따라 + i&amp;pi;].</target>
        </trans-unit>
        <trans-unit id="473d434a9b1e1fa3c3fa95983b0cf370022ebc41" translate="yes" xml:space="preserve">
          <source>The complex conjugate of &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;z&lt;/code&gt; 의 켤레 복소수입니다 .</target>
        </trans-unit>
        <trans-unit id="82c5651398368fa9194c75ad0cd42b27eaccd0a5" translate="yes" xml:space="preserve">
          <source>The complex exponential function ez</source>
          <target state="translated">복잡한 지수 함수 ez</target>
        </trans-unit>
        <trans-unit id="f4a8bb4e0bd6e80ede57c9b2a0ef2ec124631eca" translate="yes" xml:space="preserve">
          <source>The compound assignment operator expressions have the form.</source>
          <target state="translated">복합 할당 연산자 표현식의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7df263ae0e0ab175c4cedd3b99f705f4c1dd852a" translate="yes" xml:space="preserve">
          <source>The compound literal expression constructs an unnamed object of the type specified by type and initializes it as specified by initializer-list.</source>
          <target state="translated">복합 리터럴 표현식은 type으로 지정된 유형의 이름없는 오브젝트를 구성하고 initializer-list로 지정된대로 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="4fbd0a48bc1fb7914fb073b18a7045d1a7fe29e4" translate="yes" xml:space="preserve">
          <source>The compound statement allows a set of declarations and statements to be grouped into one unit that can be used anywhere a single statement is expected (for example, in an &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt; statement or an iteration statement):</source>
          <target state="translated">복합 명령문을 사용하면 단일 명령문이 예상되는 모든 위치 (예 : &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt; 문 또는 반복문) 에서 사용할 수있는 선언 및 명령문 세트를 하나의 단위로 그룹화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8abc060166b36e799feb998e7f4939e28b8ecdbf" translate="yes" xml:space="preserve">
          <source>The conditional operator expression has the form.</source>
          <target state="translated">조건부 연산자 표현식의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="35c8621167c53476a1a98fe938c3c174cc4134ee" translate="yes" xml:space="preserve">
          <source>The conditional operator is never an &lt;a href=&quot;value_category&quot;&gt;lvalue expression&lt;/a&gt;, although it may return objects of struct/union type. The only other expressions that may return stucts are &lt;a href=&quot;operator_assignment&quot;&gt;assignment&lt;/a&gt;, &lt;a href=&quot;operator_other#Comma_operator&quot;&gt;comma&lt;/a&gt;, &lt;a href=&quot;operator_other#Function_call&quot;&gt;function call&lt;/a&gt;, and &lt;a href=&quot;compound_literal&quot;&gt;compound literal&lt;/a&gt;.</source>
          <target state="translated">조건부 연산자는 struct / union 유형의 객체를 반환 할 수 있지만 &lt;a href=&quot;value_category&quot;&gt;lvalue 식은&lt;/a&gt; 아닙니다 . stucts를 리턴 할 수있는 다른 표현식은 &lt;a href=&quot;operator_assignment&quot;&gt;할당&lt;/a&gt; , &lt;a href=&quot;operator_other#Comma_operator&quot;&gt;쉼표&lt;/a&gt; , &lt;a href=&quot;operator_other#Function_call&quot;&gt;함수 호출&lt;/a&gt; 및 &lt;a href=&quot;compound_literal&quot;&gt;복합 리터럴&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fadd419c227bb685e0a0582aff80f1b5ba7a551d" translate="yes" xml:space="preserve">
          <source>The conditional preprocessing block starts with &lt;code&gt;#if&lt;/code&gt;, &lt;code&gt;#ifdef&lt;/code&gt; or &lt;code&gt;#ifndef&lt;/code&gt; directive, then optionally includes any number of &lt;code&gt;#elif&lt;/code&gt; directives, then optionally includes at most one &lt;code&gt;#else&lt;/code&gt; directive and is terminated with the &lt;code&gt;#endif&lt;/code&gt; directive. Any inner conditional preprocessing blocks are processed separately.</source>
          <target state="translated">조건부 전처리 블록은 &lt;code&gt;#if&lt;/code&gt; , &lt;code&gt;#ifdef&lt;/code&gt; 또는 &lt;code&gt;#ifndef&lt;/code&gt; 지시문으로 시작한 다음 선택적으로 여러 개의 &lt;code&gt;#elif&lt;/code&gt; 지시문을 포함하고 선택적으로 최대 하나의 &lt;code&gt;#else&lt;/code&gt; 지시문을 포함하며 &lt;code&gt;#endif&lt;/code&gt; 지시문으로 종료됩니다 . 내부 조건부 전처리 블록은 개별적으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="4ff37d62089a6b5f6e494aef62b9015866607221" translate="yes" xml:space="preserve">
          <source>The constant expression is evaluated at compile time and compared to zero. If it compares equal to zero, a compile-time error occurs and the compiler must display message (if provided) as part of the error message (except that characters not in &lt;a href=&quot;translation_phases&quot;&gt;basic source character set&lt;/a&gt; aren't required to be displayed).</source>
          <target state="translated">상수 표현식은 컴파일 타임에 평가되어 0과 비교됩니다. 0과 비교하면 컴파일 타임 오류가 발생하고 컴파일러는 오류 메시지의 일부로 메시지 (제공된 경우)를 표시해야합니다 ( &lt;a href=&quot;translation_phases&quot;&gt;기본 소스 문자 세트&lt;/a&gt; 에없는 문자 는 표시하지 않아도 됨).</target>
        </trans-unit>
        <trans-unit id="7733c072d8eb0d24e0b88f6986f86f0fb8a35998" translate="yes" xml:space="preserve">
          <source>The controlling-expression and the expressions of the selections that are not chosen are never evaluated.</source>
          <target state="translated">선택되지 않은 선택의 제어식 및 표현은 평가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0eba86b24f08a5313c7cce0d40bb40425a6f3985" translate="yes" xml:space="preserve">
          <source>The conversion specifiers &lt;code&gt;lc&lt;/code&gt;, &lt;code&gt;ls&lt;/code&gt;, and &lt;code&gt;l[&lt;/code&gt; perform multibyte-to-wide character conversion as if by calling &lt;a href=&quot;../string/multibyte/mbrtowc&quot;&gt;&lt;code&gt;mbrtowc()&lt;/code&gt;&lt;/a&gt; with an &lt;a href=&quot;../string/multibyte/mbstate_t&quot;&gt;&lt;code&gt;mbstate_t&lt;/code&gt;&lt;/a&gt; object initialized to zero before the first character is converted.</source>
          <target state="translated">변환 지정자 &lt;code&gt;lc&lt;/code&gt; , &lt;code&gt;ls&lt;/code&gt; 및 &lt;code&gt;l[&lt;/code&gt; 은 첫 번째 문자가 변환되기 전에 &lt;a href=&quot;../string/multibyte/mbstate_t&quot;&gt; &lt;code&gt;mbstate_t&lt;/code&gt; &lt;/a&gt; 객체가 0으로 초기화 된 &lt;a href=&quot;../string/multibyte/mbrtowc&quot;&gt; &lt;code&gt;mbrtowc()&lt;/code&gt; &lt;/a&gt; 를 호출하는 것처럼 멀티 바이트에서 문자 전체로의 문자 변환을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="10d720fad8838ce447569443ee37666195d1db03" translate="yes" xml:space="preserve">
          <source>The conversion specifiers &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;[&lt;/code&gt; always store the null terminator in addition to the matched characters. The size of the destination array must be at least one greater than the specified field width. The use of &lt;code&gt;%s&lt;/code&gt; or &lt;code&gt;%[&lt;/code&gt;, without specifying the destination array size, is as unsafe as &lt;code&gt;&lt;a href=&quot;gets&quot;&gt;gets&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">변환 지정자 &lt;code&gt;s&lt;/code&gt; 와 &lt;code&gt;[&lt;/code&gt; 는 항상 일치하는 문자 외에 널 종료자를 저장합니다. 대상 배열의 크기는 지정된 필드 너비보다 하나 이상 커야합니다. 사용 &lt;code&gt;%s&lt;/code&gt; 또는 &lt;code&gt;%[&lt;/code&gt; 대상 배열 크기를 지정하지 않고,뿐만 불안전 &lt;code&gt;&lt;a href=&quot;gets&quot;&gt;gets&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac471b8f3e3680d0aea88efb3834381526f7e2d3" translate="yes" xml:space="preserve">
          <source>The conversions &lt;code&gt;F&lt;/code&gt;, &lt;code&gt;E&lt;/code&gt;, &lt;code&gt;G&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; output &lt;code&gt;INF&lt;/code&gt;, &lt;code&gt;INFINITY&lt;/code&gt;, &lt;code&gt;NAN&lt;/code&gt; instead.</source>
          <target state="translated">변환 &lt;code&gt;F&lt;/code&gt; , &lt;code&gt;E&lt;/code&gt; , &lt;code&gt;G&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; 출력 &lt;code&gt;INF&lt;/code&gt; , &lt;code&gt;INFINITY&lt;/code&gt; , &lt;code&gt;NAN&lt;/code&gt; 대신에.</target>
        </trans-unit>
        <trans-unit id="6d126e7074c1cecdf337f1c334c8340ee765b367" translate="yes" xml:space="preserve">
          <source>The conversions not listed here are not allowed. In particular,</source>
          <target state="translated">여기에 나열되지 않은 변환은 허용되지 않습니다. 특히,</target>
        </trans-unit>
        <trans-unit id="fc8e08acb16e81fb66cf54c1031e76e0b8784b0f" translate="yes" xml:space="preserve">
          <source>The correct conversion specifications for the &lt;a href=&quot;../types/integer&quot;&gt;fixed-width integer types&lt;/a&gt; (&lt;code&gt;int8_t&lt;/code&gt;, etc) are defined in the header &lt;a href=&quot;../types/integer&quot;&gt;&amp;lt;inttypes.h&amp;gt;&lt;/a&gt; (although &lt;a href=&quot;../types/integer&quot;&gt;&lt;code&gt;SCNdMAX&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../types/integer&quot;&gt;&lt;code&gt;SCNuMAX&lt;/code&gt;&lt;/a&gt;, etc is synonymous with &lt;code&gt;%jd&lt;/code&gt;, &lt;code&gt;%ju&lt;/code&gt;, etc).</source>
          <target state="translated">&lt;a href=&quot;../types/integer&quot;&gt;고정 폭 정수 유형&lt;/a&gt; ( &lt;code&gt;int8_t&lt;/code&gt; 등)에 대한 올바른 변환 스펙은 &lt;a href=&quot;../types/integer&quot;&gt;&amp;lt;inttypes.h&amp;gt;&lt;/a&gt; 헤더에 정의되어 있습니다 ( &lt;a href=&quot;../types/integer&quot;&gt; &lt;code&gt;SCNdMAX&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../types/integer&quot;&gt; &lt;code&gt;SCNuMAX&lt;/code&gt; &lt;/a&gt; 등은 &lt;code&gt;%jd&lt;/code&gt; , &lt;code&gt;%ju&lt;/code&gt; 등과 동의어 임).</target>
        </trans-unit>
        <trans-unit id="0a0aa617af0af8a4ff0e8b9f43a4c9fad55a2792" translate="yes" xml:space="preserve">
          <source>The correct conversion specifications for the fixed-width character types (&lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;int8_t&lt;/a&gt;&lt;/code&gt;, etc) are defined in the header &lt;a href=&quot;../types/integer&quot;&gt;&amp;lt;inttypes.h&amp;gt;&lt;/a&gt; (although &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;PRIdMAX&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;PRIuMAX&lt;/a&gt;&lt;/code&gt;, etc is synonymous with &lt;code&gt;%jd&lt;/code&gt;, &lt;code&gt;%ju&lt;/code&gt;, etc).</source>
          <target state="translated">고정 너비 문자 유형 ( &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;int8_t&lt;/a&gt;&lt;/code&gt; 등)에 대한 올바른 변환 스펙은 &lt;a href=&quot;../types/integer&quot;&gt;&amp;lt;inttypes.h&amp;gt;&lt;/a&gt; 헤더에 정의되어 있습니다 ( &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;PRIdMAX&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;PRIuMAX&lt;/a&gt;&lt;/code&gt; 등은 &lt;code&gt;%jd&lt;/code&gt; , &lt;code&gt;%ju&lt;/code&gt; 등과 동의어 임).</target>
        </trans-unit>
        <trans-unit id="7f9b4026c72463dbf7e53d38e204b4285cee0558" translate="yes" xml:space="preserve">
          <source>The correct length of the buffer that can receive the entire transformed string is &lt;code&gt;1+strxfrm(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, src, 0)&lt;/code&gt;.</source>
          <target state="translated">변환 된 전체 문자열을 수신 할 수있는 버퍼의 올바른 길이는 &lt;code&gt;1+strxfrm(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, src, 0)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2a72dc1f2a9cfd3fbe819a915b266b2d90a2d9e5" translate="yes" xml:space="preserve">
          <source>The correct length of the buffer that can receive the entire transformed string is &lt;code&gt;1+wcsxfrm(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, src, 0)&lt;/code&gt;.</source>
          <target state="translated">변환 된 전체 문자열을 수신 할 수있는 버퍼의 올바른 길이는 &lt;code&gt;1+wcsxfrm(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, src, 0)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d5a730e98fa4ae44b9e24fcf843d261fd0bdf207" translate="yes" xml:space="preserve">
          <source>The correct result can be represented as &lt;code&gt;int&lt;/code&gt; on all known implementations. For overflow to occur, &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; must be less than &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;LDBL_MAX_EXP&lt;/a&gt;*log2(&lt;a href=&quot;../../types/limits&quot;&gt;FLT_RADIX&lt;/a&gt;)&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt; must be greater than &lt;code&gt;LDBL_MIN_EXP-&lt;a href=&quot;../../types/limits&quot;&gt;LDBL_MANT_DIG&lt;/a&gt;)*log2(&lt;a href=&quot;../../types/limits&quot;&gt;FLT_RADIX&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">모든 알려진 구현에서 올바른 결과를 &lt;code&gt;int&lt;/code&gt; 로 표시 할 수 있습니다 . 발생하는 오버 플로우, &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; 는 이하이어야 &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;LDBL_MAX_EXP&lt;/a&gt;*log2(&lt;a href=&quot;../../types/limits&quot;&gt;FLT_RADIX&lt;/a&gt;)&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt; 가 보다 커야 &lt;code&gt;LDBL_MIN_EXP-&lt;a href=&quot;../../types/limits&quot;&gt;LDBL_MANT_DIG&lt;/a&gt;)*log2(&lt;a href=&quot;../../types/limits&quot;&gt;FLT_RADIX&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="942cf9ae9a6d3badc39db24111513090bfb3dd85" translate="yes" xml:space="preserve">
          <source>The cosine is an entire function on the complex plane, and has no branch cuts.  Mathematical definition of the cosine is cos z =</source>
          <target state="translated">코사인은 복잡한 평면에서 전체 기능이며 분기 컷이 없습니다. 코사인의 수학적 정의는 cos z =</target>
        </trans-unit>
        <trans-unit id="333d83e6dc8a3ed3cddeaf85bad80a985040ae63" translate="yes" xml:space="preserve">
          <source>The current &lt;a href=&quot;../fenv/fe_round&quot;&gt;rounding mode&lt;/a&gt; has no effect.</source>
          <target state="translated">현재 &lt;a href=&quot;../fenv/fe_round&quot;&gt;반올림 모드&lt;/a&gt; 는 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="df76dc533f4832695e4faabdf4a21cf982bfbb46" translate="yes" xml:space="preserve">
          <source>The current &lt;a href=&quot;http://en.cppreference.com/w/cpp/numeric/fenv/FE_round.html&quot;&gt;rounding mode&lt;/a&gt; has no effect.</source>
          <target state="translated">현재 &lt;a href=&quot;http://en.cppreference.com/w/cpp/numeric/fenv/FE_round.html&quot;&gt;반올림 모드&lt;/a&gt; 는 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="dcd990c0fc482fb45b1d3492d0748ec8b63e5c22" translate="yes" xml:space="preserve">
          <source>The current rounding mode affects the following:</source>
          <target state="translated">현재 반올림 모드는 다음에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="430695fef50ce6b9934160789eacb1237ee74fd7" translate="yes" xml:space="preserve">
          <source>The current rounding mode does NOT affect the following:</source>
          <target state="translated">현재 반올림 모드는 다음에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d5f32fa1d98982e1738b953b2dd2b57c9e693298" translate="yes" xml:space="preserve">
          <source>The current rounding mode, reflecting the effects of the most recent &lt;code&gt;fesetround&lt;/code&gt;, can also be queried with &lt;code&gt;&lt;a href=&quot;../../types/limits/flt_rounds&quot;&gt;FLT_ROUNDS&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">가장 최근 &lt;code&gt;fesetround&lt;/code&gt; 의 효과를 반영하는 현재 반올림 모드 도 &lt;code&gt;&lt;a href=&quot;../../types/limits/flt_rounds&quot;&gt;FLT_ROUNDS&lt;/a&gt;&lt;/code&gt; 로 쿼리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="45ddc6fce10286bba6c1f8beb847e588ed427ba1" translate="yes" xml:space="preserve">
          <source>The current value of the atomic variable pointed to by &lt;code&gt;obj&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 가 가리키는 원자 변수의 현재 값 .</target>
        </trans-unit>
        <trans-unit id="cd998795c1cd4032dd66b9872287706842aa61a2" translate="yes" xml:space="preserve">
          <source>The data storage (memory) available to a C program is one or more contiguous sequences of</source>
          <target state="translated">C 프로그램에 사용 가능한 데이터 스토리지 (메모리)는 다음 중 하나 이상의 연속 시퀀스입니다.</target>
        </trans-unit>
        <trans-unit id="c8994a846037bbc39e1e65a3a929f7e6a5d07984" translate="yes" xml:space="preserve">
          <source>The decimal point specified by &lt;code&gt;&lt;a href=&quot;../locale/setlocale&quot;&gt;setlocale&lt;/a&gt;&lt;/code&gt; has no effect on the syntax of floating constants: the decimal point character is always the period.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../locale/setlocale&quot;&gt;setlocale&lt;/a&gt;&lt;/code&gt; 로 지정된 소수점 은 부동 상수 구문에 영향을 미치지 않습니다. 소수점 문자는 항상 마침표입니다.</target>
        </trans-unit>
        <trans-unit id="b79072e7b56ba6659da6f87106f63e08064df5b7" translate="yes" xml:space="preserve">
          <source>The declaration of a variadic function uses an ellipsis as the last parameter, e.g. &lt;code&gt;int &lt;a href=&quot;io/fprintf&quot;&gt;printf&lt;/a&gt;(const char* format, ...);&lt;/code&gt;. See &lt;a href=&quot;language/variadic&quot;&gt;variadic arguments&lt;/a&gt; for additional detail on the syntax and automatic argument conversions.</source>
          <target state="translated">variadic 함수 선언은 생략을 마지막 매개 변수로 사용합니다 &lt;code&gt;int &lt;a href=&quot;io/fprintf&quot;&gt;printf&lt;/a&gt;(const char* format, ...);&lt;/code&gt; 예 : int &lt;a href=&quot;io/fprintf&quot;&gt;printf&lt;/a&gt; (const char * 형식, ...); . 구문과 자동 인수 변환에 대한 추가 세부 사항 은 &lt;a href=&quot;language/variadic&quot;&gt;가변 인수&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="51b207b37e6bcac2f107504e9d723a780830b61a" translate="yes" xml:space="preserve">
          <source>The default behavior of all atomic operations in the &lt;a href=&quot;../language/atomic&quot;&gt;language&lt;/a&gt; and the library provides for</source>
          <target state="translated">&lt;a href=&quot;../language/atomic&quot;&gt;언어&lt;/a&gt; 및 라이브러리 에서 모든 원자 연산의 기본 동작 은 다음을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4587bcdbb1b6bc9e3b5e438494b4e72f8dd1c68a" translate="yes" xml:space="preserve">
          <source>The default buffer size &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;BUFSIZ&lt;/a&gt;&lt;/code&gt; is expected to be the most efficient buffer size for file I/O on the implementation, but POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/fstat.html&quot;&gt;fstat&lt;/a&gt; often provides a better estimate.</source>
          <target state="translated">기본 버퍼 크기 &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;BUFSIZ&lt;/a&gt;&lt;/code&gt; 는 구현시 파일 I / O에 가장 효율적인 버퍼 크기 일 것으로 예상되지만 POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/fstat.html&quot;&gt;fstat는&lt;/a&gt; 종종 더 나은 추정치를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="704cfed41634169a037643744dd48b4ba86f41ca" translate="yes" xml:space="preserve">
          <source>The default buffer size &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;BUFSIZ&lt;/a&gt;&lt;/code&gt; is expected to be the most efficient buffer size for file I/O on the implementation, but POSIX &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/fstat.html&quot;&gt;fstat&lt;/a&gt; often provides a better estimate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="627832562bf8dd374b20ff048dfc37aaca313b99" translate="yes" xml:space="preserve">
          <source>The definition of the macro &lt;code&gt;assert&lt;/code&gt; depends on another macro, &lt;code&gt;NDEBUG&lt;/code&gt;, which is not defined by the standard library.</source>
          <target state="translated">매크로 &lt;code&gt;assert&lt;/code&gt; 정의는 표준 라이브러리에 의해 정의되지 않은 다른 매크로 &lt;code&gt;NDEBUG&lt;/code&gt; 에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="aeb40399c9bd04128464837d331638d1fc355f39" translate="yes" xml:space="preserve">
          <source>The description is formed by concatenating the following components:</source>
          <target state="translated">설명은 다음 구성 요소를 연결하여 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="db81ed6a406de31b6ca65d95bdd037c70cc38728" translate="yes" xml:space="preserve">
          <source>The destructor, if available, is not invoked.</source>
          <target state="translated">사용 가능한 경우 소멸자가 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fb97a7284cd296528abb21877065aef28175aa34" translate="yes" xml:space="preserve">
          <source>The destructor, if one was registered by &lt;code&gt;&lt;a href=&quot;tss_create&quot;&gt;tss_create&lt;/a&gt;&lt;/code&gt;, is not called (they are only called at thread exit, either by &lt;code&gt;&lt;a href=&quot;thrd_exit&quot;&gt;thrd_exit&lt;/a&gt;&lt;/code&gt; or by returning from the thread function), it is the responsibility of the programmer to ensure that every thread that is aware of &lt;code&gt;tss_id&lt;/code&gt; performed all necessary cleanup, before the call to &lt;code&gt;tss_delete&lt;/code&gt; is made.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;tss_create&quot;&gt;tss_create&lt;/a&gt;&lt;/code&gt; 에 의해 등록 된 소멸자 는 호출되지 않습니다 ( &lt;code&gt;&lt;a href=&quot;thrd_exit&quot;&gt;thrd_exit&lt;/a&gt;&lt;/code&gt; 또는 스레드 함수에서 리턴하여 스레드 종료시 에만 호출 됨 ),이를 인식하는 모든 스레드를 확인하는 것은 프로그래머의 책임입니다. &lt;code&gt;tss_id&lt;/code&gt; 를 호출하기 전에 &lt;code&gt;tss_delete&lt;/code&gt; 가 필요한 정리를 모두 수행했습니다 .</target>
        </trans-unit>
        <trans-unit id="b2599aff3e1997c8bce0ea2079154bc10d116fd7" translate="yes" xml:space="preserve">
          <source>The double version of fmod behaves as if implemented as follows:</source>
          <target state="translated">fmod의 이중 버전은 다음과 같이 구현 된 것처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="d33813bc0fb85e40f1c26903767c91afaf907f09" translate="yes" xml:space="preserve">
          <source>The effect of calling &lt;code&gt;&lt;a href=&quot;../types/offsetof&quot;&gt;offsetof&lt;/a&gt;&lt;/code&gt; on a bit field</source>
          <target state="translated">비트 필드에서 &lt;code&gt;&lt;a href=&quot;../types/offsetof&quot;&gt;offsetof&lt;/a&gt;&lt;/code&gt; 를 호출하는 효과</target>
        </trans-unit>
        <trans-unit id="529673770ff976d50ee9f358bf474740d57d7b6c" translate="yes" xml:space="preserve">
          <source>The element type of the composite type is the composite type of the two element types.</source>
          <target state="translated">복합 유형의 요소 유형은 두 요소 유형의 복합 유형입니다.</target>
        </trans-unit>
        <trans-unit id="c50a1fc3f7b297bdcca890f9bac6d5dd553d12f8" translate="yes" xml:space="preserve">
          <source>The encoding of calendar time in &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;time_t&lt;/a&gt;&lt;/code&gt; is unspecified, but most systems conform to &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/time.html&quot;&gt;POSIX specification&lt;/a&gt; and return a value of integral type holding the number of seconds since &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_15&quot;&gt;the Epoch&lt;/a&gt;. Implementations in which &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;time_t&lt;/a&gt;&lt;/code&gt; is a 32-bit signed integer (many historical implementations) fail in the year &lt;a href=&quot;http://en.wikipedia.org/wiki/Year_2038_problem&quot;&gt;2038&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;time_t&lt;/a&gt;&lt;/code&gt; 의 달력 시간 인코딩 은 지정되지 않았지만 대부분의 시스템은 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/time.html&quot;&gt;POSIX 사양을&lt;/a&gt; 준수 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_15&quot;&gt;하며 Epoch&lt;/a&gt; 이후 초 수를 보유한 정수 유형의 값을 리턴합니다 . 구현에 &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;time_t&lt;/a&gt;&lt;/code&gt; 는 32 비트 정수 (많은 과거 구현) 해 실패 인 &lt;a href=&quot;http://en.wikipedia.org/wiki/Year_2038_problem&quot;&gt;2,038&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="46c62e849f85f3a4ba03d516978379effedf794e" translate="yes" xml:space="preserve">
          <source>The encoding of calendar time in &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;time_t&lt;/a&gt;&lt;/code&gt; is unspecified, but most systems conform to &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/time.html&quot;&gt;POSIX specification&lt;/a&gt; and return a value of integral type holding the number of seconds since &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_15&quot;&gt;the Epoch&lt;/a&gt;. Implementations in which &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;time_t&lt;/a&gt;&lt;/code&gt; is a 32-bit signed integer (many historical implementations) fail in the year &lt;a href=&quot;https://en.wikipedia.org/wiki/Year_2038_problem&quot;&gt;2038&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="824493ebacf0d3370672a682b01bf74e21675169" translate="yes" xml:space="preserve">
          <source>The encoding of character string literals (1) and wide string literals (5) is implementation-defined. For example, gcc selects them with the &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/cpp/Invocation.html&quot;&gt;commandline options&lt;/a&gt;&lt;code&gt;-fexec-charset&lt;/code&gt; and &lt;code&gt;-fwide-exec-charset&lt;/code&gt;.</source>
          <target state="translated">문자열 리터럴 (1) 및 넓은 문자열 리터럴 (5)의 인코딩은 구현 정의되어 있습니다. 예를 들어, gcc는 &lt;code&gt;-fexec-charset&lt;/code&gt; 및 &lt;code&gt;-fwide-exec-charset&lt;/code&gt; &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/cpp/Invocation.html&quot;&gt;명령 행 옵션을&lt;/a&gt; 사용하여 선택합니다 .</target>
        </trans-unit>
        <trans-unit id="1b539c63cb55edb7e1383ca8e128aa52c2118d3c" translate="yes" xml:space="preserve">
          <source>The end of every declarator that is not part of another declarator is a &lt;a href=&quot;eval_order&quot;&gt;sequence point&lt;/a&gt;.</source>
          <target state="translated">다른 선언자에 속하지 않는 모든 선언자의 끝은 &lt;a href=&quot;eval_order&quot;&gt;시퀀스 포인트&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2b400103ba5ae8e95fc269d363832185de644a92" translate="yes" xml:space="preserve">
          <source>The entire program may have zero or one external definition of every identifier (other than an &lt;a href=&quot;inline&quot;&gt;inline&lt;/a&gt; function)(since C99) with &lt;a href=&quot;storage_duration&quot;&gt;external linkage&lt;/a&gt;.</source>
          <target state="translated">전체 프로그램은 &lt;a href=&quot;storage_duration&quot;&gt;외부 연결을&lt;/a&gt; 가진 ( &lt;a href=&quot;inline&quot;&gt;인라인&lt;/a&gt; 함수 이외의) 모든 식별자의 외부 정의가 없거나 하나 일 수 있습니다 (C99 이후) .</target>
        </trans-unit>
        <trans-unit id="f7a14859a09bf56dbf34fa38ebabd0a0cfc01622" translate="yes" xml:space="preserve">
          <source>The equality operator expressions have the form.</source>
          <target state="translated">항등 연산자 식의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="61830cacc4ca90b758c92dfcb68fdc8c2624ac72" translate="yes" xml:space="preserve">
          <source>The evaluation of expression takes place after each execution of statement (whether entered normally or by a goto). If the controlling expression needs to be evaluated before the loop body, the &lt;a href=&quot;while&quot;&gt;while loop&lt;/a&gt; or the &lt;a href=&quot;for&quot;&gt;for loop&lt;/a&gt; may be used.</source>
          <target state="translated">표현 평가는 명령문이 실행될 때마다 수행됩니다 (정상적으로 입력 했든 goto에 의해 입력 되었든). 제어식을 루프 본문보다 먼저 평가해야하는 경우 &lt;a href=&quot;while&quot;&gt;while 루프&lt;/a&gt; 또는 &lt;a href=&quot;for&quot;&gt;for 루프를&lt;/a&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ac201da533f6480e174bf7db981da799dd3201b" translate="yes" xml:space="preserve">
          <source>The evaluation of expression takes place before each execution of statement (unless entered by a goto). If the controlling expression needs to be evaluated after the loop body, the &lt;a href=&quot;do&quot;&gt;do-while loop&lt;/a&gt; may be used.</source>
          <target state="translated">표현 평가는 각 명령문 실행 전에 수행됩니다 (goto에 의해 입력되지 않은 경우). 루프 바디 이후에 제어식을 평가해야하는 경우, &lt;a href=&quot;do&quot;&gt;do-while 루프&lt;/a&gt; 가 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e4a670e9ee4d8164f867b068f256b475e0334b4" translate="yes" xml:space="preserve">
          <source>The evaluations of expression that designates the function to be called and all arguments are &lt;a href=&quot;eval_order&quot;&gt;unsequenced&lt;/a&gt; with respect to each other (but there is a sequence point before the body of the function begins executing).</source>
          <target state="translated">호출 할 함수를 지정하는 표현 평가와 모든 인수는 서로에 대해 순서 가 지정 &lt;a href=&quot;eval_order&quot;&gt;되지 않습니다&lt;/a&gt; (그러나 함수 본문이 실행되기 전에 시퀀스 포인트가 있습니다).</target>
        </trans-unit>
        <trans-unit id="88a06ff6d6b5a3ba4276cee42336251cadd1cd73" translate="yes" xml:space="preserve">
          <source>The exact behavior of this function depends on the implementation, in particular on the mechanics of the OS scheduler in use and the state of the system. For example, a first-in-first-out realtime scheduler (&lt;code&gt;SCHED_FIFO&lt;/code&gt; in Linux) would suspend the current thread and put it on the back of the queue of the same-priority threads that are ready to run (and if there are no other threads at the same priority, &lt;code&gt;yield&lt;/code&gt; has no effect).</source>
          <target state="translated">이 기능의 정확한 동작은 구현, 특히 사용중인 OS 스케줄러의 메커니즘 및 시스템 상태에 따라 다릅니다. 예를 들어, &lt;code&gt;SCHED_FIFO&lt;/code&gt; 선출 실시간 스케줄러 ( Linux의 SCHED_FIFO )는 현재 스레드를 일시 중단하고 실행할 준비가 된 동일한 우선 순위 스레드의 큐 뒷면에 배치합니다 (다른 스레드가없는 경우). 우선 순위가 같은 스레드는 &lt;code&gt;yield&lt;/code&gt; 에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3afa03179e588e1c757bb671479e9343d010308a" translate="yes" xml:space="preserve">
          <source>The exponent contains at least two digits, more digits are used only if necessary. If the value is &lt;code&gt;​0​&lt;/code&gt;, the exponent is also &lt;code&gt;​0​&lt;/code&gt;.</source>
          <target state="translated">지수에는 두 자리 이상의 숫자가 포함되며 필요한 경우에만 더 많은 숫자가 사용됩니다. 값이면 &lt;code&gt;​0​&lt;/code&gt; , 지수는 또한 &lt;code&gt;​0​&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8bbac353ed3f45f6cc4a964a51c439a96d66dd22" translate="yes" xml:space="preserve">
          <source>The exponent has the form.</source>
          <target state="translated">지수는 형식이 있습니다.</target>
        </trans-unit>
        <trans-unit id="04028f66e9c71c2bd75f830dc82f30f80377d676" translate="yes" xml:space="preserve">
          <source>The exponential function is an</source>
          <target state="translated">지수 함수는</target>
        </trans-unit>
        <trans-unit id="3e9f12f2ca6ab5279914c37234b56437596c602d" translate="yes" xml:space="preserve">
          <source>The expression cannot be a &lt;a href=&quot;operator_other#Comma_operator&quot;&gt;comma operator&lt;/a&gt; (unless parenthesized) because the comma at the top level would be interpreted as the beginning of the next declarator.</source>
          <target state="translated">최상위 수준의 쉼표가 다음 선언자의 시작으로 해석되므로 표현식은 &lt;a href=&quot;operator_other#Comma_operator&quot;&gt;쉼표 연산자&lt;/a&gt; (괄호 안에 있지 않은 경우) 일 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="25d8b1cc309b61a3a19bc6577131254cb18609f3" translate="yes" xml:space="preserve">
          <source>The expression following &lt;a href=&quot;../preprocessor/conditional&quot;&gt;#if or #elif&lt;/a&gt; must expand to.</source>
          <target state="translated">&lt;a href=&quot;../preprocessor/conditional&quot;&gt;#if 또는 #elif&lt;/a&gt; 뒤에 오는 표현식 은 확장되어야합니다.</target>
        </trans-unit>
        <trans-unit id="fd397bb5ad1c715271d852321a59468dac4bf8e0" translate="yes" xml:space="preserve">
          <source>The expression in the middle of the conditional operator (between &lt;code&gt;?&lt;/code&gt; and &lt;code&gt;:&lt;/code&gt;) is parsed as if parenthesized: its precedence relative to &lt;code&gt;?:&lt;/code&gt; is ignored.</source>
          <target state="translated">조건 연산자 ( &lt;code&gt;?&lt;/code&gt; 와 &lt;code&gt;:&lt;/code&gt; 사이)의 중간에있는 표현식은 괄호로 묶인 것처럼 구문 분석됩니다 . &lt;code&gt;?:&lt;/code&gt; 대한 우선 순위 는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="6e6d20b10db31ec88b3330e05c431cfea6a343c7" translate="yes" xml:space="preserve">
          <source>The expression is a constant expression, using only &lt;a href=&quot;../language/expressions#Constants_and_literals&quot;&gt;constants&lt;/a&gt; and identifiers, defined using &lt;a href=&quot;replace&quot;&gt;&lt;code&gt; #define&lt;/code&gt;&lt;/a&gt; directive. Any identifier, which is not literal, non defined using &lt;a href=&quot;replace&quot;&gt;&lt;code&gt; #define&lt;/code&gt;&lt;/a&gt; directive, evaluates to</source>
          <target state="translated">식은 &lt;a href=&quot;replace&quot;&gt; &lt;code&gt; #define&lt;/code&gt; &lt;/a&gt; 지시문을 사용하여 정의 된 &lt;a href=&quot;../language/expressions#Constants_and_literals&quot;&gt;상수&lt;/a&gt; 와 식별자 만 사용하는 상수 식 입니다. &lt;a href=&quot;replace&quot;&gt; &lt;code&gt; #define&lt;/code&gt; &lt;/a&gt; 지시문을 사용하여 정의되지 않은 리터럴이 아닌 모든 식별자는 다음 과 같이 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="7442fe2fa76c716226a44ca97bfdfc72037a2ef9" translate="yes" xml:space="preserve">
          <source>The expression is evaluated, and its value, after &lt;a href=&quot;conversion&quot;&gt;conversion as if by assignment&lt;/a&gt; to the type of the object, becomes the initial value of the object being initialized.</source>
          <target state="translated">표현식은 평가 되고 객체의 유형 &lt;a href=&quot;conversion&quot;&gt;에 할당 된 것처럼 변환 된&lt;/a&gt; 후의 값은 초기화되는 객체의 초기 값이됩니다.</target>
        </trans-unit>
        <trans-unit id="324047fb5be1cb1232a316ce7dc9176cf6e8bad8" translate="yes" xml:space="preserve">
          <source>The expression lhs@=rhs is exactly the same as lhs&lt;code&gt;=&lt;/code&gt;lhs@&lt;code&gt;(&lt;/code&gt;rhs&lt;code&gt;)&lt;/code&gt;, except that lhs is evaluated only once.</source>
          <target state="translated">lhs @ = rhs 표현식 은 lhs가 한 번만 평가된다는 점을 제외하고 lhs &lt;code&gt;=&lt;/code&gt; lhs @ &lt;code&gt;(&lt;/code&gt; rhs &lt;code&gt;)&lt;/code&gt; 와 정확히 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="38f1c8c6b8733ef70e33511479b521ed6c4d5325" translate="yes" xml:space="preserve">
          <source>The expression may contain unary operators in form &lt;code&gt;defined&lt;/code&gt;identifier or &lt;code&gt;defined (&lt;/code&gt;identifier&lt;code&gt;)&lt;/code&gt; which return &lt;code&gt;1&lt;/code&gt; if the identifier was defined using &lt;a href=&quot;replace&quot;&gt;&lt;code&gt; #define&lt;/code&gt;&lt;/a&gt; directive and</source>
          <target state="translated">이 식은 &lt;a href=&quot;replace&quot;&gt; &lt;code&gt; #define&lt;/code&gt; &lt;/a&gt; 지시문을 사용하여 식별자를 정의한 경우 &lt;code&gt;1&lt;/code&gt; 을 반환하는 &lt;code&gt;defined (&lt;/code&gt; &lt;code&gt;defined&lt;/code&gt; 식별자 또는 정의 된 ( identifier &lt;code&gt;)&lt;/code&gt; 형식의 단항 연산자를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="609021b59f47fefb50869c57b0c8813d6a53f9c6" translate="yes" xml:space="preserve">
          <source>The expression statement used as loop_statement establishes its own block scope, distinct from the scope of init_clause, unlike in C++:</source>
          <target state="translated">loop_statement로 사용 된 표현식 명령문은 C ++에서와 달리 init_clause의 범위와는 다른 자체 블록 범위를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="6e7851beccfe29b18d64f37c7c39bb8359a74916" translate="yes" xml:space="preserve">
          <source>The expressions are suitable for use as initializers for objects with static or thread storage duration, as long as the expressions &lt;code&gt;real&lt;/code&gt; and &lt;code&gt;imag&lt;/code&gt; are also suitable.</source>
          <target state="translated">표현식은 &lt;code&gt;real&lt;/code&gt; 및 &lt;code&gt;imag&lt;/code&gt; 표현식이 적합한 한 정적 또는 스레드 저장 기간이있는 객체의 초기화 프로그램으로 사용하기에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="5e8e4ef756882f2ecb926b4da6aad7ade4184995" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;count&lt;/code&gt; characters of the transformed string are written to destination, including the terminating null character, and the length of the full transformed string is returned, excluding the terminating null character.</source>
          <target state="translated">변환 된 문자열 의 첫 번째 &lt;code&gt;count&lt;/code&gt; 문자는 종료 널 문자를 포함하여 대상에 기록되고 종료 널 문자를 제외하고 전체 변환 된 문자열의 길이가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="097166e604623ecf948a99098da8c5eddd704203" translate="yes" xml:space="preserve">
          <source>The first argument of &lt;code&gt;_Static_assert&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;_Static_assert&lt;/code&gt; 의 첫 번째 인수</target>
        </trans-unit>
        <trans-unit id="59d42cf5c59ef03d9f21e976e9211c12f3707cda" translate="yes" xml:space="preserve">
          <source>The first hexadecimal digit is not &lt;code&gt;0&lt;/code&gt; if the argument is a normalized floating point value. If the value is &lt;code&gt;​0​&lt;/code&gt;, the exponent is also &lt;code&gt;​0​&lt;/code&gt;.</source>
          <target state="translated">인수가 정규화 된 부동 소수점 값인 경우 첫 16 진 숫자는 &lt;code&gt;0&lt;/code&gt; 이 아닙니다 . 값이면 &lt;code&gt;​0​&lt;/code&gt; , 지수는 또한 &lt;code&gt;​0​&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="85aefccf8c9b3c2cd0c976b63196e9f569cb09b9" translate="yes" xml:space="preserve">
          <source>The first of the following that applies:</source>
          <target state="translated">다음 중 첫 번째가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="1993f25515fdf5cf77175e2613e17a42e6c910c0" translate="yes" xml:space="preserve">
          <source>The first version orders memory accesses according to &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;, the second version orders memory accesses according to &lt;code&gt;order&lt;/code&gt;. &lt;code&gt;order&lt;/code&gt; must be one of &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_relaxed&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_consume&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_acquire&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;. Otherwise the behavior is undefined.</source>
          <target state="translated">첫 번째 버전은 &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; 에 따라 메모리 액세스를 주문 하고 두 번째 버전은 order에 따라 메모리 액세스를 &lt;code&gt;order&lt;/code&gt; 합니다. &lt;code&gt;order&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_relaxed&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_consume&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_acquire&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; 중 하나 여야합니다 . 그렇지 않으면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3c052bc3e94706d81a135a07eebf60e086497cbe" translate="yes" xml:space="preserve">
          <source>The first version orders memory accesses according to &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;, the second version orders memory accesses according to &lt;code&gt;order&lt;/code&gt;. &lt;code&gt;order&lt;/code&gt; must be one of &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_relaxed&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_release&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;. Otherwise the behavior is undefined.</source>
          <target state="translated">첫 번째 버전은 &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; 에 따라 메모리 액세스를 주문 하고 두 번째 버전은 order에 따라 메모리 액세스를 &lt;code&gt;order&lt;/code&gt; 합니다. &lt;code&gt;order&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_relaxed&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_release&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; 중 하나 여야합니다 . 그렇지 않으면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b7b4a6419bf1a2819ede3d443e7b61a16bea4d0c" translate="yes" xml:space="preserve">
          <source>The first write to that object through an lvalue that has a type other than character type, at which time the type of that lvalue becomes this object's</source>
          <target state="translated">문자 유형 이외의 유형을 가진 lvalue를 통해 해당 객체에 처음 쓰는 경우 해당 lvalue의 유형이이 객체의</target>
        </trans-unit>
        <trans-unit id="ea51a875efb11ad49d51139f65a4fbab7c5f7404" translate="yes" xml:space="preserve">
          <source>The floating point conversion functions convert infinity to &lt;code&gt;inf&lt;/code&gt; or &lt;code&gt;infinity&lt;/code&gt;. Which one is used is implementation defined.</source>
          <target state="translated">부동 소수점 변환 함수는 무한대를 &lt;code&gt;inf&lt;/code&gt; 또는 &lt;code&gt;infinity&lt;/code&gt; 로 변환 합니다 . 사용되는 것은 구현 정의입니다.</target>
        </trans-unit>
        <trans-unit id="7a6247fea33eba71fac61a2b7cb4727c8281a459" translate="yes" xml:space="preserve">
          <source>The floating-point environment access and modification is only meaningful when &lt;a href=&quot;http://en.cppreference.com/w/cpp/preprocessor/impl.html&quot;&gt;&lt;code&gt; #pragma STDC FENV_ACCESS&lt;/code&gt;&lt;/a&gt; is set to &lt;code&gt;ON&lt;/code&gt;. Otherwise the implementation is free to assume that floating-point control modes are always the default ones and that floating-point status flags are never tested or modified. In practice, few current compilers, such as HP aCC, Oracle Studio, and IBM XL, support the &lt;code&gt;#pragma&lt;/code&gt; explicitly, but most compilers allow meaningful access to the floating-point environment anyway.</source>
          <target state="translated">부동 소수점 환경 액세스 및 수정은 &lt;a href=&quot;http://en.cppreference.com/w/cpp/preprocessor/impl.html&quot;&gt; &lt;code&gt; #pragma STDC FENV_ACCESS&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;ON&lt;/code&gt; 으로 설정된 경우에만 의미가 있습니다. 그렇지 않으면 구현시 부동 소수점 제어 모드가 항상 기본 모드이고 부동 소수점 상태 플래그는 테스트 또는 수정되지 않는다고 가정 할 수 있습니다. 실제로 HP aCC, Oracle Studio 및 IBM XL과 같은 현재 컴파일러는 &lt;code&gt;#pragma&lt;/code&gt; 를 명시 적으로 지원 하지만 대부분의 컴파일러는 부동 소수점 환경에 대한 의미있는 액세스를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="d88a487f9a81a8c43facb1ab36c14a9792a2394f" translate="yes" xml:space="preserve">
          <source>The floating-point environment is the set of floating-point status flags and control modes supported by the implementation. It is thread-local, each thread inherits the initial state of its floating-point environment from the parent thread. Floating-point operations modify the floating-point status flags to indicate abnormal results or auxiliary information. The state of floating-point control modes affects the outcomes of some floating-point operations.</source>
          <target state="translated">부동 소수점 환경은 구현에서 지원하는 부동 소수점 상태 플래그 및 제어 모드 세트입니다. 스레드 로컬이며 각 스레드는 상위 스레드에서 부동 소수점 환경의 초기 상태를 상속합니다. 부동 소수점 연산은 부동 소수점 상태 플래그를 수정하여 비정상 결과 또는 보조 정보를 나타냅니다. 부동 소수점 제어 모드의 상태는 일부 부동 소수점 연산의 결과에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="1f30dcca8094f65496cbe7b9cb343a1867b9353f" translate="yes" xml:space="preserve">
          <source>The floating-point remainder of the division operation &lt;code&gt;x/y&lt;/code&gt; calculated by this function is exactly the value &lt;code&gt;x - n*y&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is &lt;code&gt;x/y&lt;/code&gt; with its fractional part truncated.</source>
          <target state="translated">이 함수로 계산 된 나누기 연산 &lt;code&gt;x/y&lt;/code&gt; 의 부동 소수점 나머지 는 정확히 &lt;code&gt;x - n*y&lt;/code&gt; 값입니다 . 여기서 &lt;code&gt;n&lt;/code&gt; 은 소수 부분이 잘린 상태에서 &lt;code&gt;x/y&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9c564c91cc056f54f98f41b5fb84e49fa91ab18b" translate="yes" xml:space="preserve">
          <source>The following additional keywords are classified as extensions and conditionally-supported:</source>
          <target state="translated">다음 추가 키워드는 확장으로 분류되며 조건부 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="01d1b47f4e938983cec3203a558177551122e45b" translate="yes" xml:space="preserve">
          <source>The following additional macro names may be predefined by an implementation:</source>
          <target state="translated">구현에 의해 다음과 같은 추가 매크로 이름이 사전 정의 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53267feddb0a903c8317f2f0976951442dab290e" translate="yes" xml:space="preserve">
          <source>The following alternative tokens are part of the core language, and, in all respects of the language, each alternative token behaves exactly the same as its primary token, except for its spelling (the &lt;a href=&quot;../preprocessor/replace&quot;&gt;stringification operator&lt;/a&gt; can make the spelling visible). The two-letter alternative tokens are sometimes called &quot;digraphs&quot;</source>
          <target state="translated">다음 대체 토큰은 핵심 언어의 일부이며, 언어와 관련하여 모든 대체 토큰은 철자를 제외하고 기본 토큰과 정확히 동일하게 작동합니다 ( &lt;a href=&quot;../preprocessor/replace&quot;&gt;문자열 연산자&lt;/a&gt; 는 철자를 표시 할 수 있음). 2 글자 대체 토큰은 때때로 &quot;digraphs&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="2314e69040372621d3d5adf2b163840d6d43e0d3" translate="yes" xml:space="preserve">
          <source>The following aspects of the preprocessor can be controlled:</source>
          <target state="translated">전 처리기의 다음 측면을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf5ea285c72c7d87a0b9f0ab566e300cf0d96f2e" translate="yes" xml:space="preserve">
          <source>The following chart contains all 128 ASCII decimal &lt;b&gt;(dec)&lt;/b&gt;, octal &lt;b&gt;(oct)&lt;/b&gt;, hexadecimal &lt;b&gt;(hex)&lt;/b&gt; and character &lt;b&gt;(ch)&lt;/b&gt; codes.</source>
          <target state="translated">다음 차트에는 128 개의 ASCII 10 진수 &lt;b&gt;(dec)&lt;/b&gt; , 8 진수 &lt;b&gt;(oct)&lt;/b&gt; , 16 진수 &lt;b&gt;(16 진수)&lt;/b&gt; 및 문자 &lt;b&gt;(ch)&lt;/b&gt; 코드가 모두 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="96fdf8bcc92fd6fc1514e41f0d3d41b7c151059a" translate="yes" xml:space="preserve">
          <source>The following code redirects &lt;code&gt;stdout&lt;/code&gt; to a file.</source>
          <target state="translated">다음 코드는 &lt;code&gt;stdout&lt;/code&gt; 을 파일로 리디렉션 합니다.</target>
        </trans-unit>
        <trans-unit id="ffbdf2342c1f96b0209b527d82df9863ea30a28c" translate="yes" xml:space="preserve">
          <source>The following code sets and resets the stream orientation.</source>
          <target state="translated">다음 코드는 스트림 방향을 설정하고 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="02b64fd2a82723acdd75ab79f9a274ca5cba5ba7" translate="yes" xml:space="preserve">
          <source>The following errors are detected at runtime and call the currently installed &lt;a href=&quot;../error/set_constraint_handler_s&quot;&gt;constraint handler&lt;/a&gt; function:</source>
          <target state="translated">런타임시 다음 오류가 감지되고 현재 설치된 &lt;a href=&quot;../error/set_constraint_handler_s&quot;&gt;제한 조건 핸들러&lt;/a&gt; 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="3f0df48cae22b33977db026831f1533dc1eac83e" translate="yes" xml:space="preserve">
          <source>The following escape sequences are available. ISO C requires a diagnostic if the backslash is followed by any character not listed here:</source>
          <target state="translated">다음과 같은 이스케이프 시퀀스를 사용할 수 있습니다. 백 슬래시 다음에 여기에 나열되지 않은 문자가 있으면 ISO C에서 진단이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="0463db8b7489f2f607fc0fb87c855f442b9abbeb" translate="yes" xml:space="preserve">
          <source>The following example demonstrates alternative operator spellings from the &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt; header as well as use of digraphs and trigraphs. The space character in the first command-line argument, argv[1], requires the quotation marks: &quot;, World!&quot;.</source>
          <target state="translated">다음 예는 &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt; 헤더 의 대체 연산자 철자법과 digraphs 및 trigraphs의 사용법을 보여줍니다 . 첫 번째 명령 줄 인수 argv [1]의 공백 문자에는 &quot;, World!&quot;따옴표가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="287a73bdcb331ffbabd28ac365a0f69ce0862305" translate="yes" xml:space="preserve">
          <source>The following expressions are lvalues:</source>
          <target state="translated">다음 표현식은 lvalue입니다.</target>
        </trans-unit>
        <trans-unit id="829cc0f70c42a8b870ad4b5e87e195960641456e" translate="yes" xml:space="preserve">
          <source>The following expressions are non-lvalue object expressions:</source>
          <target state="translated">다음 표현식은 값이 아닌 객체 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="2cfaf8e14e19bf31aee96ca79b4b825e2d169ca6" translate="yes" xml:space="preserve">
          <source>The following floating-point error conditions are recognized:</source>
          <target state="translated">다음과 같은 부동 소수점 오류 조건이 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="bd4f90abfd9c4aaea62c390400d56b7eb617f8af" translate="yes" xml:space="preserve">
          <source>The following format specifiers are available:</source>
          <target state="translated">다음 형식 지정자를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c8aa77024587faa413de9da508229e9cf4a51fc" translate="yes" xml:space="preserve">
          <source>The following function names are reserved for future addition to &lt;code&gt;complex.h&lt;/code&gt; and are not available for use in the programs that include that header: &lt;code&gt;cerf&lt;/code&gt;, &lt;code&gt;cerfc&lt;/code&gt;, &lt;code&gt;cexp2&lt;/code&gt;, &lt;code&gt;cexpm1&lt;/code&gt;, &lt;code&gt;clog10&lt;/code&gt;, &lt;code&gt;clog1p&lt;/code&gt;, &lt;code&gt;clog2&lt;/code&gt;, &lt;code&gt;clgamma&lt;/code&gt;, and &lt;code&gt;ctgamma&lt;/code&gt;, along with their -f and -l suffixed variants.</source>
          <target state="translated">다음 함수 이름은 향후 추가 예약되어 &lt;code&gt;complex.h&lt;/code&gt; 그 헤더 포함 프로그램에서 사용할 수 없습니다 : &lt;code&gt;cerf&lt;/code&gt; , &lt;code&gt;cerfc&lt;/code&gt; , &lt;code&gt;cexp2&lt;/code&gt; , &lt;code&gt;cexpm1&lt;/code&gt; , &lt;code&gt;clog10&lt;/code&gt; , &lt;code&gt;clog1p&lt;/code&gt; , &lt;code&gt;clog2&lt;/code&gt; , &lt;code&gt;clgamma&lt;/code&gt; 및 &lt;code&gt;ctgamma&lt;/code&gt; 그와 함께를 - f 및 -l 접미사 변형.</target>
        </trans-unit>
        <trans-unit id="2f18389086be3ef835c51e9ad36c08bb8badaac5" translate="yes" xml:space="preserve">
          <source>The following functions are &lt;code&gt;noreturn&lt;/code&gt; in the standard library:</source>
          <target state="translated">다음 기능은 표준 라이브러리에서 &lt;code&gt;noreturn&lt;/code&gt; 되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c5a591d9fa5638aac9fa2b83e82338a91618a78a" translate="yes" xml:space="preserve">
          <source>The following functions manage program termination and resource cleanup.</source>
          <target state="translated">다음 기능은 프로그램 종료 및 리소스 정리를 관리합니다.</target>
        </trans-unit>
        <trans-unit id="7f554e67755443645ddea4d0c9f686b445b59a7f" translate="yes" xml:space="preserve">
          <source>The following functions should not be called from multiple threads without synchronization with the &lt;code&gt;mbstate_t*&lt;/code&gt; argument of &lt;code&gt;NULL&lt;/code&gt; due to possible data races: &lt;code&gt;&lt;a href=&quot;mbrlen&quot;&gt;mbrlen&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;mbrtowc&quot;&gt;mbrtowc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;mbsrtowcs&quot;&gt;mbsrtowcs&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;mbtowc&quot;&gt;mbtowc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;wcrtomb&quot;&gt;wcrtomb&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;wcsrtombs&quot;&gt;wcsrtombs&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;wctomb&quot;&gt;wctomb&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">다음 기능은 함께 동기화없이 여러 스레드에서 호출 할 수 없습니다 &lt;code&gt;mbstate_t*&lt;/code&gt; 의 인수를 &lt;code&gt;NULL&lt;/code&gt; : 때문에 가능한 데이터 레이스에 &lt;code&gt;&lt;a href=&quot;mbrlen&quot;&gt;mbrlen&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;mbrtowc&quot;&gt;mbrtowc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;mbsrtowcs&quot;&gt;mbsrtowcs&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;mbtowc&quot;&gt;mbtowc&lt;/a&gt;&lt;/code&gt; 는 , &lt;code&gt;&lt;a href=&quot;wcrtomb&quot;&gt;wcrtomb&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;wcsrtombs&quot;&gt;wcsrtombs&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;wctomb&quot;&gt;wctomb&lt;/a&gt;&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="1674823b2b9c702abeb414373c5461775fcadedb" translate="yes" xml:space="preserve">
          <source>The following identifiers are</source>
          <target state="translated">다음 식별자는</target>
        </trans-unit>
        <trans-unit id="52747f8b268619d42bfc41249c2443bf02dfb375" translate="yes" xml:space="preserve">
          <source>The following limitations are imposed on the user-defined function that is installed as a signal handler.</source>
          <target state="translated">신호 처리기로 설치되는 사용자 정의 함수에는 다음과 같은 제한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="60a246baccbe5a74a2372f3123a79e57ab1d8a6e" translate="yes" xml:space="preserve">
          <source>The following macro names are predefined in any translation unit:</source>
          <target state="translated">다음 매크로 이름은 모든 번역 단위에서 사전 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="760cdc8623d4deb346e101e369ccc8511374acd9" translate="yes" xml:space="preserve">
          <source>The following program computes the number of seconds that have passed since the beginning of the month.</source>
          <target state="translated">다음 프로그램은 월초 이후 경과 된 시간 (초)을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="9ff275c825fa1a87d99185f365a34ebec03469ef" translate="yes" xml:space="preserve">
          <source>The following properties of bit fields are</source>
          <target state="translated">비트 필드의 다음 속성은</target>
        </trans-unit>
        <trans-unit id="50ffe5d9875553429026debf7cff7fd09bf924b6" translate="yes" xml:space="preserve">
          <source>The following table lists the precedence and associativity of C operators. Operators are listed top to bottom, in descending precedence.</source>
          <target state="translated">다음 표는 C 연산자의 우선 순위 및 연관성을 나열합니다. 연산자는 내림차순으로 위에서 아래로 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="8aa536e53d4635c03c483d42ad9b70a227480cbe" translate="yes" xml:space="preserve">
          <source>The following table provides a reference for the limits of common numeric representations. As the C Standard allows any signed integer representation, the table gives both the minimum guaranteed requirements (which correspond to the limits of &lt;a href=&quot;https://en.wikipedia.org/wiki/One%27s_complement&quot;&gt;one's complement&lt;/a&gt; or &lt;a href=&quot;https://en.wikipedia.org/wiki/Signed_number_representations#Sign-and-magnitude_method&quot;&gt;sign-and-magnitude&lt;/a&gt;) and the limits of the most commonly used implementation, &lt;a href=&quot;https://en.wikipedia.org/wiki/Two%27s_complement&quot;&gt;two's complement&lt;/a&gt;. All popular data models (including all of ILP32, LP32, LP64, LLP64) use two's complement representation, though.</source>
          <target state="translated">다음 표는 일반적인 숫자 표현의 한계에 대한 참조를 제공합니다. C 표준은 부호있는 정수 표현을 허용하므로 표는 최소 보장 요구 사항 ( &lt;a href=&quot;https://en.wikipedia.org/wiki/One%27s_complement&quot;&gt;보완&lt;/a&gt; 또는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Signed_number_representations#Sign-and-magnitude_method&quot;&gt;부호 및 크기&lt;/a&gt; 의 한계에 해당)과 가장 일반적으로 사용되는 구현 한계 인 &lt;a href=&quot;https://en.wikipedia.org/wiki/Two%27s_complement&quot;&gt;2의 보수를 모두 제공&lt;/a&gt; 합니다. 그러나 모든 인기있는 데이터 모델 (모든 ILP32, LP32, LP64, LLP64 포함)은 2의 보수 표현을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a901e9b7792340a20dc3a26c920d9911c931da64" translate="yes" xml:space="preserve">
          <source>The following table summarizes all available integer types and their properties:</source>
          <target state="translated">다음 표는 사용 가능한 모든 정수 유형 및 해당 속성을 요약합니다.</target>
        </trans-unit>
        <trans-unit id="3f6d452f86036275cf545aa6c2fd879d6ea70e67" translate="yes" xml:space="preserve">
          <source>The following three pragmas are defined by the language standard:</source>
          <target state="translated">다음 세 가지 pragma는 언어 표준에 의해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="acc57bf9778baf29a073665323a0c5976c6a1f23" translate="yes" xml:space="preserve">
          <source>The following three-character groups (trigraphs) are &lt;a href=&quot;translation_phases&quot;&gt;parsed before comments and string literals are recognized&lt;/a&gt;, and each appearance of a trigraph is replaced by the corresponding primary character:</source>
          <target state="translated">&lt;a href=&quot;translation_phases&quot;&gt;주석과 문자열 리터럴이 인식되기 전에&lt;/a&gt; 다음 3 자로 된 그룹 (3 자)이 구문 분석 되고 3 자 모양의 각 모양이 해당 기본 문자로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="e2546fbb06c0a729787bc6cd7125e1b5361e4578" translate="yes" xml:space="preserve">
          <source>The following tokens are recognized by the &lt;a href=&quot;preprocessor&quot;&gt;preprocessor&lt;/a&gt; when they are used</source>
          <target state="translated">다음 토큰 은 사용될 때 &lt;a href=&quot;preprocessor&quot;&gt;전처리기에&lt;/a&gt; 의해 인식 됩니다</target>
        </trans-unit>
        <trans-unit id="4f3e2b4ce9621498219d1ebd6d8fb04d675b973c" translate="yes" xml:space="preserve">
          <source>The following tokens are recognized by the preprocessor when they are used</source>
          <target state="translated">다음 토큰은 사용될 때 전처리기에 의해 인식됩니다</target>
        </trans-unit>
        <trans-unit id="259ef24e493d7f7eee6e3b99062deb09c3faa2fa" translate="yes" xml:space="preserve">
          <source>The following two declarations declare the same function:</source>
          <target state="translated">다음 두 선언은 동일한 기능을 선언합니다.</target>
        </trans-unit>
        <trans-unit id="05238738a8d9e70dab6db4701b54bdcd606eef3b" translate="yes" xml:space="preserve">
          <source>The following types are incomplete:</source>
          <target state="translated">다음 유형이 불완전합니다.</target>
        </trans-unit>
        <trans-unit id="05263cedaa87adae4404e0d5d0d5c6012425b488" translate="yes" xml:space="preserve">
          <source>The following values of &lt;code&gt;str&lt;/code&gt; are supported in all C locales:</source>
          <target state="translated">모든 C 로케일에서 다음 &lt;code&gt;str&lt;/code&gt; 값 이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="5c29167a05bd707a804eef66e8a46280899a02a0" translate="yes" xml:space="preserve">
          <source>The following variables are initialized to the same value:</source>
          <target state="translated">다음 변수는 동일한 값으로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="f68fcc28a98f3dfdaf45ebc2e1785811a6a9fe23" translate="yes" xml:space="preserve">
          <source>The format of &lt;code&gt;filename&lt;/code&gt; is implementation-defined, and does not necessarily refer to a file (e.g. it may be the console or another device accessible though filesystem API). On platforms that support them, &lt;code&gt;filename&lt;/code&gt; may include absolute or relative filesystem path.</source>
          <target state="translated">&lt;code&gt;filename&lt;/code&gt; 의 형식 은 구현에 따라 정의되며 반드시 파일을 참조 할 필요는 없습니다 (예 : 파일 시스템 API를 통해 액세스 할 수있는 콘솔 또는 다른 장치 일 수 있음). 이를 지원하는 플랫폼에서 &lt;code&gt;filename&lt;/code&gt; 은 절대 또는 상대 파일 시스템 경로를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="93ac56cdaeeb6de79fc364f4fe683f408e59c3e6" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../string/byte/strtof&quot;&gt;&lt;code&gt;strtof()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">숫자의 형식은 &lt;a href=&quot;../string/byte/strtof&quot;&gt; &lt;code&gt;strtof()&lt;/code&gt; &lt;/a&gt; 예상 한 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="8f0ad27913f478ab70d1cc2d0e0549d118103730" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../string/byte/strtol&quot;&gt;&lt;code&gt;strtol()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;10&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument.</source>
          <target state="translated">숫자의 형식은 &lt;code&gt;base&lt;/code&gt; 인수에 대해 값 &lt;code&gt;10&lt;/code&gt; 을 갖는 &lt;a href=&quot;../string/byte/strtol&quot;&gt; &lt;code&gt;strtol()&lt;/code&gt; &lt;/a&gt; 에서 예상 한 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="671556fcedcbcc40a3b072fd7bffc45f2fbccd26" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../string/byte/strtol&quot;&gt;&lt;code&gt;strtol()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;​0​&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument (base is determined by the first characters parsed).</source>
          <target state="translated">숫자의 형식은 예상과 동일하다 &lt;a href=&quot;../string/byte/strtol&quot;&gt; &lt;code&gt;strtol()&lt;/code&gt; &lt;/a&gt; 값과 &lt;code&gt;​0​&lt;/code&gt; 위한 &lt;code&gt;base&lt;/code&gt; (베이스 파싱 첫 문자에 의해 결정된다) 인수.</target>
        </trans-unit>
        <trans-unit id="b7b4201164d0bc303ec63a1d04f289d249202a0f" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../string/byte/strtoul&quot;&gt;&lt;code&gt;strtoul()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;10&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument.</source>
          <target state="translated">숫자의 형식은 예상과 동일하다 &lt;a href=&quot;../string/byte/strtoul&quot;&gt; &lt;code&gt;strtoul()&lt;/code&gt; &lt;/a&gt; 값으로 &lt;code&gt;10&lt;/code&gt; 위한 &lt;code&gt;base&lt;/code&gt; 인수.</target>
        </trans-unit>
        <trans-unit id="1b718549b02c9a87887915199e47e1a005bfae44" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../string/byte/strtoul&quot;&gt;&lt;code&gt;strtoul()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;16&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument.</source>
          <target state="translated">숫자의 형식은 예상과 동일하다 &lt;a href=&quot;../string/byte/strtoul&quot;&gt; &lt;code&gt;strtoul()&lt;/code&gt; &lt;/a&gt; 값으로 &lt;code&gt;16&lt;/code&gt; 위한 &lt;code&gt;base&lt;/code&gt; 인수.</target>
        </trans-unit>
        <trans-unit id="2555a9003a37354d6399908418d0705063de50cf" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../string/byte/strtoul&quot;&gt;&lt;code&gt;strtoul()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;8&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument.</source>
          <target state="translated">숫자의 형식은 예상과 동일하다 &lt;a href=&quot;../string/byte/strtoul&quot;&gt; &lt;code&gt;strtoul()&lt;/code&gt; &lt;/a&gt; 값으로 &lt;code&gt;8&lt;/code&gt; 위한 &lt;code&gt;base&lt;/code&gt; 인수.</target>
        </trans-unit>
        <trans-unit id="92789305795f1eb56d034465a61e558a6506280d" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../string/wide/wcstof&quot;&gt;&lt;code&gt;wcstof()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">숫자의 형식은 &lt;a href=&quot;../string/wide/wcstof&quot;&gt; &lt;code&gt;wcstof()&lt;/code&gt; &lt;/a&gt; 예상 한 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="51860d6c8145c8370c4b642d4fc1c22a2186f998" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../string/wide/wcstol&quot;&gt;&lt;code&gt;wcstol()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;10&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument.</source>
          <target state="translated">숫자의 형식은 &lt;a href=&quot;../string/wide/wcstol&quot;&gt; &lt;code&gt;wcstol()&lt;/code&gt; &lt;/a&gt; 에서 예상 한 것과 &lt;code&gt;base&lt;/code&gt; 인수 의 값이 &lt;code&gt;10&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="b523e0c8748ab9c5e972ec8245b3621fc4041002" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../string/wide/wcstol&quot;&gt;&lt;code&gt;wcstol()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;​0​&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument (base is determined by the first characters parsed).</source>
          <target state="translated">숫자의 형식은 예상과 동일하다 &lt;a href=&quot;../string/wide/wcstol&quot;&gt; &lt;code&gt;wcstol()&lt;/code&gt; &lt;/a&gt; 값과 &lt;code&gt;​0​&lt;/code&gt; 위한 &lt;code&gt;base&lt;/code&gt; (베이스 파싱 첫 문자에 의해 결정된다) 인수.</target>
        </trans-unit>
        <trans-unit id="f0aa77172a8536624fd5ee996fa4b09d9c154130" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../string/wide/wcstoul&quot;&gt;&lt;code&gt;wcstoul()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;10&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument.</source>
          <target state="translated">숫자의 형식은 &lt;a href=&quot;../string/wide/wcstoul&quot;&gt; &lt;code&gt;wcstoul()&lt;/code&gt; &lt;/a&gt; 에서 &lt;code&gt;base&lt;/code&gt; 인수 의 값 &lt;code&gt;10&lt;/code&gt; 을 사용하여 예상 한 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="76408fd6762baa6a334ed1b0697b3874e7fb1be4" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../string/wide/wcstoul&quot;&gt;&lt;code&gt;wcstoul()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;16&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument.</source>
          <target state="translated">숫자의 형식은 &lt;a href=&quot;../string/wide/wcstoul&quot;&gt; &lt;code&gt;wcstoul()&lt;/code&gt; &lt;/a&gt; 에서 &lt;code&gt;base&lt;/code&gt; 인수 의 값이 &lt;code&gt;16&lt;/code&gt; 인 것과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="a9b9db29e262a1c1455a0e82dbd508a761aa0601" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../string/wide/wcstoul&quot;&gt;&lt;code&gt;wcstoul()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;8&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument.</source>
          <target state="translated">숫자의 형식은 &lt;a href=&quot;../string/wide/wcstoul&quot;&gt; &lt;code&gt;wcstoul()&lt;/code&gt; &lt;/a&gt; 에서 &lt;code&gt;base&lt;/code&gt; 인수 의 값 &lt;code&gt;8&lt;/code&gt; 을 사용하여 예상 한 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="3d9e18bdb76f0cfc72cfc7220ca845cba830ae2b" translate="yes" xml:space="preserve">
          <source>The format string consists of ordinary multibyte characters (except &lt;code&gt;%&lt;/code&gt;), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:</source>
          <target state="translated">형식 문자열은 일반 멀티 바이트 문자 ( &lt;code&gt;%&lt;/code&gt; 제외 )로 변경되지 않고 출력 스트림으로 복사되며 변환 사양으로 구성됩니다. 각 변환 사양의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="978f5198d804b9a4148d59f23d49bd19f235af7b" translate="yes" xml:space="preserve">
          <source>The format string consists of ordinary wide characters (except &lt;code&gt;%&lt;/code&gt;), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:</source>
          <target state="translated">형식 문자열은 일반 와이드 문자 ( &lt;code&gt;%&lt;/code&gt; 제외 )로 구성되며 출력 스트림으로 변경되지 않고 복사되며 변환 사양입니다. 각 변환 사양의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="77ae2a1ebbf9dfc51f6f5d5f89c9ab7a18fe650c" translate="yes" xml:space="preserve">
          <source>The format string consists of zero or more conversion specifiers and ordinary characters (except &lt;code&gt;%&lt;/code&gt;). All ordinary characters, including the terminating null character, are copied to the output string without modification. Each conversion specification begins with &lt;code&gt;%&lt;/code&gt; character, optionally followed by &lt;code&gt;E&lt;/code&gt; or &lt;code&gt;O&lt;/code&gt; modifier (ignored if unsupported by the locale), followed by the character that determines the behavior of the specifier. The following format specifiers are available:</source>
          <target state="translated">형식 문자열은 0 개 이상의 변환 지정자와 일반 문자 ( &lt;code&gt;%&lt;/code&gt; 제외 )로 구성됩니다. 종료 널 문자를 포함하여 모든 일반 문자는 수정하지 않고 출력 문자열에 복사됩니다. 각 변환 스펙은 &lt;code&gt;%&lt;/code&gt; 문자로 시작하고 선택적으로 &lt;code&gt;E&lt;/code&gt; 또는 &lt;code&gt;O&lt;/code&gt; 수정 자 (로케일이 지원하지 않는 경우 무시 됨)가오고 그 뒤에 지정자의 동작을 결정하는 문자가옵니다. 다음 형식 지정자를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d35574333561b6d7197206a894209f7b4dca21b" translate="yes" xml:space="preserve">
          <source>The format string consists of.</source>
          <target state="translated">형식 문자열은 다음으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="ed94452fd5320f29fe790ddccc946a60d3be8519" translate="yes" xml:space="preserve">
          <source>The fractional part is discarded (truncated towards zero).</source>
          <target state="translated">소수 부분은 버려집니다 (0쪽으로 잘림).</target>
        </trans-unit>
        <trans-unit id="f1e777bed230647173e4ad51c340e8839794d4c2" translate="yes" xml:space="preserve">
          <source>The full contents of a floating-point exception flag is not necessarily a boolean value indicating whether the exception is raised or cleared. For example, it may be a struct which includes the boolean status and the address of the code that triggered the exception. These functions obtain all such content and obtain/store it in &lt;code&gt;flagp&lt;/code&gt; in implementation-defined format.</source>
          <target state="translated">부동 소수점 예외 플래그의 전체 내용이 예외가 발생했는지 또는 지워 졌는지 여부를 나타내는 부울 값일 필요는 없습니다. 예를 들어, 부울 상태 및 예외를 트리거 한 코드의 주소를 포함하는 구조체 일 수 있습니다. 이러한 함수는 이러한 모든 컨텐츠를 가져 &lt;code&gt;flagp&lt;/code&gt; 구현 정의 형식으로 플래그로 가져 오거나 저장 합니다.</target>
        </trans-unit>
        <trans-unit id="96e76a18348bd7140463f4991aabb39103dce3cf" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;frexp&lt;/code&gt;, together with its dual, &lt;code&gt;&lt;a href=&quot;ldexp&quot;&gt;ldexp&lt;/a&gt;&lt;/code&gt;, can be used to manipulate the representation of a floating-point number without direct bit manipulations.</source>
          <target state="translated">&lt;code&gt;frexp&lt;/code&gt; 함수 는 듀얼 &lt;code&gt;&lt;a href=&quot;ldexp&quot;&gt;ldexp&lt;/a&gt;&lt;/code&gt; 와 함께 직접 비트 조작없이 부동 소수점 숫자의 표현을 조작하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17196b905a44e0edee51205b99ccb0d4ea314cc3" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;ldexp&lt;/code&gt; (&quot;load exponent&quot;), together with its dual, &lt;code&gt;&lt;a href=&quot;frexp&quot;&gt;frexp&lt;/a&gt;&lt;/code&gt;, can be used to manipulate the representation of a floating-point number without direct bit manipulations.</source>
          <target state="translated">함수 &lt;code&gt;ldexp&lt;/code&gt; ( &quot;load exponent&quot;)와 이중 &lt;code&gt;&lt;a href=&quot;frexp&quot;&gt;frexp&lt;/a&gt;&lt;/code&gt; 는 직접 비트 조작없이 부동 소수점 숫자의 표현을 조작하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ffdf9ae1184af0302bbd32d7e4f00be8f426782" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;strcat_s&lt;/code&gt; is similar to the BSD function &lt;code&gt;strlcat&lt;/code&gt;, except that.</source>
          <target state="translated">&lt;code&gt;strcat_s&lt;/code&gt; 함수 는 BSD 함수 &lt;code&gt;strlcat&lt;/code&gt; 과 비슷 합니다.</target>
        </trans-unit>
        <trans-unit id="0efd9ecc68a30f292c27629dda09e33a1b504eaf" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;strcpy_s&lt;/code&gt; is similar to the BSD function &lt;code&gt;strlcpy&lt;/code&gt;, except that.</source>
          <target state="translated">&lt;code&gt;strcpy_s&lt;/code&gt; 함수 는 BSD 함수 &lt;code&gt;strlcpy&lt;/code&gt; 와 유사 합니다.</target>
        </trans-unit>
        <trans-unit id="720e67ae7cff5823d2274d70efa49b7c85aa1156" translate="yes" xml:space="preserve">
          <source>The function accepts (and does nothing with) the null pointer to reduce the amount of special-casing. Whether allocation succeeds or not, the pointer returned by an allocation function can be passed to &lt;code&gt;free()&lt;/code&gt;.</source>
          <target state="translated">이 함수는 널 케이싱을 받아들이고 특수 케이스의 양을 줄입니다. 할당 성공 여부에 관계없이 할당 함수에 의해 반환 된 포인터는 &lt;code&gt;free()&lt;/code&gt; 로 전달 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4c8b1015abb293307d6cda96134dccb409db2cd8" translate="yes" xml:space="preserve">
          <source>The function call expression has the form.</source>
          <target state="translated">함수 호출 표현식의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="126f425397cb45dc94e0836b07e8eefad9995278" translate="yes" xml:space="preserve">
          <source>The function does not support localization, and the newline character cannot be removed.</source>
          <target state="translated">이 기능은 지역화를 지원하지 않으며 개행 문자를 제거 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="072cec0bee6f6155df5b228611698b2538fe2d6d" translate="yes" xml:space="preserve">
          <source>The function does not support localization.</source>
          <target state="translated">이 기능은 현지화를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d3171de1fa826c9d265134dad86a77ff176be6f3" translate="yes" xml:space="preserve">
          <source>The function drops any effects from previous calls to &lt;code&gt;&lt;a href=&quot;ungetc&quot;&gt;ungetc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;ungetc&quot;&gt;ungetc&lt;/a&gt;&lt;/code&gt; 에 대한 이전 호출에서 모든 효과를 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="23ccd8cd43cb3d597e337e15d54fe5c87828b3ec" translate="yes" xml:space="preserve">
          <source>The function has mathematical poles at &amp;pi;(1/2 + n); however no common floating-point representation is able to represent &amp;pi;/2 exactly, thus there is no value of the argument for which a pole error occurs.</source>
          <target state="translated">이 함수는 &amp;pi; (1/2 + n)에 수학적 극점이 있습니다. 그러나 일반적인 부동 소수점 표현은 &amp;pi; / 2를 정확하게 표현할 수 없으므로 폴 오류가 발생하는 인수 값이 없습니다.</target>
        </trans-unit>
        <trans-unit id="af880fe541df16b2fd4a74d41e9903882d62887d" translate="yes" xml:space="preserve">
          <source>The function is continuous onto the branch cut taking into account the sign of imaginary part</source>
          <target state="translated">이 기능은 가상 부분의 부호를 고려하여 분기 컷에서 연속적입니다.</target>
        </trans-unit>
        <trans-unit id="e2fe121470076dfe7dca9614b38a83d97b455692" translate="yes" xml:space="preserve">
          <source>The function is equivalent to &lt;code&gt;&lt;a href=&quot;fseek&quot;&gt;fseek&lt;/a&gt;(stream, 0, &lt;a href=&quot;../io&quot;&gt;SEEK_SET&lt;/a&gt;);&lt;/code&gt;, except that end-of-file and error indicators are cleared.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;fseek&quot;&gt;fseek&lt;/a&gt;(stream, 0, &lt;a href=&quot;../io&quot;&gt;SEEK_SET&lt;/a&gt;);&lt;/code&gt; 을 제외하고 파일 끝 및 오류 표시기가 지워집니다.</target>
        </trans-unit>
        <trans-unit id="89f55932afa3e6e418ba772b0aaec318f66a0359" translate="yes" xml:space="preserve">
          <source>The function is implemented as a macro. &lt;code&gt;A&lt;/code&gt; is the type of &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">이 기능은 매크로로 구현됩니다. &lt;code&gt;A&lt;/code&gt; 는 &lt;code&gt;y&lt;/code&gt; 의 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="15af0ce237ff3b3144c6a868b8ee125006a14e71" translate="yes" xml:space="preserve">
          <source>The function modifies static storage and is not thread-safe.</source>
          <target state="translated">이 함수는 정적 저장소를 수정하며 스레드로부터 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bc27df1dece75c7950d8306c4124d7ab25b1a17f" translate="yes" xml:space="preserve">
          <source>The function must not modify the objects passed to it and must return consistent results when called for the same objects, regardless of their positions in the array.</source>
          <target state="translated">이 함수는 전달 된 객체를 수정해서는 안되며 배열의 위치에 관계없이 동일한 객체를 호출 할 때 일관된 결과를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="08d9155e7bdfa1ab71dea3775710a903a49a673c" translate="yes" xml:space="preserve">
          <source>The function name stands for &quot;complementary span&quot; because the function searches for characters not found in &lt;code&gt;src&lt;/code&gt;, that is the complement of &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="translated">함수는 &lt;code&gt;src&lt;/code&gt; 에 없는 문자 , 즉 &lt;code&gt;src&lt;/code&gt; 를 보완하는 문자를 검색하기 때문에 &quot;상보 적 스팬&quot;을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="58af6034860fd87af855232a56a774834e007602" translate="yes" xml:space="preserve">
          <source>The function simply returns to the caller without performing any other action.</source>
          <target state="translated">이 함수는 다른 작업을 수행하지 않고 단순히 호출자에게 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7c3559ff21a7ec0a87fd87249ee0c6ee1ced4a14" translate="yes" xml:space="preserve">
          <source>The function then returns the pointer to the beginning of the token</source>
          <target state="translated">그런 다음 함수는 토큰의 시작 부분에 대한 포인터를 반환합니다</target>
        </trans-unit>
        <trans-unit id="9c5eafec853997f8ec44f631d7a03573e4237d1e" translate="yes" xml:space="preserve">
          <source>The function to call is determined as follows:</source>
          <target state="translated">호출 할 함수는 다음과 같이 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="6257fd0e7140666f722f4b319f1c0f01eedf826a" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;&lt;a href=&quot;expm1&quot;&gt;expm1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;log1p&lt;/code&gt; are useful for financial calculations, for example, when calculating small daily interest rates: (1+x)n</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;expm1&quot;&gt;expm1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;log1p&lt;/code&gt; 함수 는 작은 일일 이자율을 계산할 때와 같이 재무 계산에 유용합니다. (1 + x) n</target>
        </trans-unit>
        <trans-unit id="0bac96adb11f232384a0a833a8c3ab44e75559c8" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;expm1&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;log1p&quot;&gt;log1p&lt;/a&gt;&lt;/code&gt; are useful for financial calculations, for example, when calculating small daily interest rates: (1+x)n</source>
          <target state="translated">&lt;code&gt;expm1&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;log1p&quot;&gt;log1p&lt;/a&gt;&lt;/code&gt; 함수 는 작은 일일 이자율을 계산할 때와 같이 재무 계산에 유용합니다. (1 + x) n</target>
        </trans-unit>
        <trans-unit id="ecc38b545ed39f36edc888e0a1aadedeb651989b" translate="yes" xml:space="preserve">
          <source>The functions registered with &lt;code&gt;&lt;a href=&quot;at_quick_exit&quot;&gt;at_quick_exit&lt;/a&gt;&lt;/code&gt; are not called.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;at_quick_exit&quot;&gt;at_quick_exit&lt;/a&gt;&lt;/code&gt; 에 등록 된 함수 는 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3db16cc57db5dbc928e64b1b6ac3975c579a8b6a" translate="yes" xml:space="preserve">
          <source>The functions sets the pointer pointed to by &lt;code&gt;endptr&lt;/code&gt; to point to the character past the last character interpreted. If &lt;code&gt;endptr&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, it is ignored.</source>
          <target state="translated">이 함수는 &lt;code&gt;endptr&lt;/code&gt; 이 가리키는 포인터가 해석 된 마지막 문자를 지나는 문자를 가리 키도록 설정합니다. 경우 &lt;code&gt;endptr&lt;/code&gt; 가 있다 &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; , 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="79e95f56658767e1e470d9215d4b6600bf8174e3" translate="yes" xml:space="preserve">
          <source>The functions sets the pointer pointed to by &lt;code&gt;endptr&lt;/code&gt; to point to the wide character past the last character interpreted. If &lt;code&gt;endptr&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, it is ignored.</source>
          <target state="translated">이 함수는 &lt;code&gt;endptr&lt;/code&gt; 이 가리키는 포인터가 해석 된 마지막 문자를지나 넓은 문자를 가리 키도록 설정합니다. 경우 &lt;code&gt;endptr&lt;/code&gt; 가 있다 &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; , 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="69ad6824d6f8c048fddeb1809adb4e0dadf9dc71" translate="yes" xml:space="preserve">
          <source>The functions sets the pointer pointed to by &lt;code&gt;str_end&lt;/code&gt; to point to the character past the last character interpreted. If &lt;code&gt;str_end&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, it is ignored.</source>
          <target state="translated">이 함수는 &lt;code&gt;str_end&lt;/code&gt; 가 가리키는 포인터를 해석 된 마지막 문자를 지나는 문자를 가리 키도록 설정합니다. 경우 &lt;code&gt;str_end&lt;/code&gt; 가 있다 &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; , 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="9c7ec7a3aab98e1d97256af5eb3cd5dd8ac9ef4b" translate="yes" xml:space="preserve">
          <source>The functions sets the pointer pointed to by &lt;code&gt;str_end&lt;/code&gt; to point to the wide character past the last character interpreted. If &lt;code&gt;str_end&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, it is ignored.</source>
          <target state="translated">이 함수는 &lt;code&gt;str_end&lt;/code&gt; 가 가리키는 포인터를 해석 된 마지막 문자 이후의 넓은 문자를 가리 키도록 설정합니다. 경우 &lt;code&gt;str_end&lt;/code&gt; 가 있다 &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; , 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="64603c7c7d2bc52bc986d70787386849f4ce71ed" translate="yes" xml:space="preserve">
          <source>The handler must be a pointer to function of type &lt;code&gt;constraint_handler_t&lt;/code&gt;, which is defined as.</source>
          <target state="translated">핸들러 는 다음과 같이 정의 된 &lt;code&gt;constraint_handler_t&lt;/code&gt; 유형의 함수에 대한 포인터 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="2b274cb694448d1bfa9bf6c931f75319a1e0a7aa" translate="yes" xml:space="preserve">
          <source>The header &lt;code&gt;&amp;lt;stdatomic.h&amp;gt;&lt;/code&gt; defines &lt;a href=&quot;../atomic&quot;&gt;37 convenience macros&lt;/a&gt;, from &lt;code&gt;&lt;a href=&quot;../atomic&quot;&gt;atomic_bool&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;../atomic&quot;&gt;atomic_uintmax_t&lt;/a&gt;&lt;/code&gt;, which simplify the use of this keyword with built-in and library types.</source>
          <target state="translated">헤더 &lt;code&gt;&amp;lt;stdatomic.h&amp;gt;&lt;/code&gt; 을 정의 &lt;a href=&quot;../atomic&quot;&gt;37 편리한 매크로&lt;/a&gt; 에서, &lt;code&gt;&lt;a href=&quot;../atomic&quot;&gt;atomic_bool&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;../atomic&quot;&gt;atomic_uintmax_t&lt;/a&gt;&lt;/code&gt; 에 내장 라이브러리 유형이 키워드의 사용을 단순화.</target>
        </trans-unit>
        <trans-unit id="74ddd8d38d4b8564e2c354808a42090ee373e9e1" translate="yes" xml:space="preserve">
          <source>The header &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; includes the headers &lt;code&gt;&amp;lt;math.h&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt; and defines several type-generic macros that determine which real or, when applicable, complex function to call based on the types of the arguments.</source>
          <target state="translated">헤더 &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; 헤더 포함 &lt;code&gt;&amp;lt;math.h&amp;gt;&lt;/code&gt; 와 &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt; 을 하고 결정하는 여러 유형의 제네릭 매크로를 정의하고 실제하는 또는 해당 복잡한 함수는 인수의 유형에 따라 호출 할 때.</target>
        </trans-unit>
        <trans-unit id="93ad7272aaadf98b5dfc20eafa318d853f619946" translate="yes" xml:space="preserve">
          <source>The header &lt;code&gt;complex.h&lt;/code&gt; provides types and functions about &lt;a href=&quot;numeric/complex&quot;&gt;complex numbers&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;complex.h&lt;/code&gt; 헤더 는 &lt;a href=&quot;numeric/complex&quot;&gt;복소수&lt;/a&gt; 에 대한 타입과 함수를 제공 합니다 .</target>
        </trans-unit>
        <trans-unit id="388aaf76829951120a17be67c04fd86012fafcdd" translate="yes" xml:space="preserve">
          <source>The header &lt;code&gt;fenv.h&lt;/code&gt; defines &lt;a href=&quot;numeric/fenv&quot;&gt;flags and functions related to exceptional floating-point state&lt;/a&gt;, such as overflow and division by zero.</source>
          <target state="translated">&lt;code&gt;fenv.h&lt;/code&gt; 헤더 는 오버플로 및 0으로 나누기와 같은 &lt;a href=&quot;numeric/fenv&quot;&gt;예외적 인 부동 소수점 상태와 관련된 플래그 및 함수를&lt;/a&gt; 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="07cc9e76a5e563d564e013252f3f732aeac63c6e" translate="yes" xml:space="preserve">
          <source>The header &lt;code&gt;math.h&lt;/code&gt; provides &lt;a href=&quot;numeric/math&quot;&gt;standard C library mathematical functions&lt;/a&gt; such as &lt;code&gt;&lt;a href=&quot;numeric/math/fabs&quot;&gt;fabs&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;numeric/math/sqrt&quot;&gt;sqrt&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;numeric/math/sin&quot;&gt;sin&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;math.h&lt;/code&gt; 헤더 는 &lt;code&gt;&lt;a href=&quot;numeric/math/fabs&quot;&gt;fabs&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;numeric/math/sqrt&quot;&gt;sqrt&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;numeric/math/sin&quot;&gt;sin&lt;/a&gt;&lt;/code&gt; 과 같은 &lt;a href=&quot;numeric/math&quot;&gt;표준 C 라이브러리 수학 함수를&lt;/a&gt; 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="79610cd72ab9bda5e0cc9559f891b46b03619e71" translate="yes" xml:space="preserve">
          <source>The header &lt;code&gt;stdlib.h&lt;/code&gt; also includes C-style random number generation via &lt;code&gt;&lt;a href=&quot;numeric/random/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;numeric/random/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;stdlib.h&lt;/code&gt; 헤더 에는 &lt;code&gt;&lt;a href=&quot;numeric/random/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;numeric/random/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; 를 통한 C 스타일 난수 생성도 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="9fc356d62136302dae71ff7d5b64387ba61e65f6" translate="yes" xml:space="preserve">
          <source>The header &lt;code&gt;tgmath.h&lt;/code&gt; provides some macros for a function which names XXX:</source>
          <target state="translated">&lt;code&gt;tgmath.h&lt;/code&gt; 헤더 는 XXX라는 함수에 대한 매크로를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="024bdd2fc5e7f5dd7775a84e539446cdbb9cc19a" translate="yes" xml:space="preserve">
          <source>The identifier itself, if used, becomes the name of the enumerated type in the tags &lt;a href=&quot;name_space&quot;&gt;name space&lt;/a&gt; and requires the use of the keyword enum (unless typedef'd into the ordinary name space).</source>
          <target state="translated">사용되는 경우 식별자 자체는 태그 &lt;a href=&quot;name_space&quot;&gt;네임 스페이스&lt;/a&gt; 에서 열거 된 유형의 이름 이되며 키워드 enum을 사용해야합니다 (일반적인 네임 스페이스로 typedef되지 않은 경우).</target>
        </trans-unit>
        <trans-unit id="037a292514cf5762093c51f94e41b9f7f76bc8ff" translate="yes" xml:space="preserve">
          <source>The identifier of the calling thread.</source>
          <target state="translated">호출 스레드의 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="9f2ec11eb7cd3993bbc0fbdd3a84fd4d32466d57" translate="yes" xml:space="preserve">
          <source>The imaginary constant</source>
          <target state="translated">허수</target>
        </trans-unit>
        <trans-unit id="9e1eb1c62e8a76621e675ea472f278a7a95b40c1" translate="yes" xml:space="preserve">
          <source>The imaginary numbers make it possible to express all complex numbers using the natural notation &lt;code&gt;x + I*y&lt;/code&gt; (where &lt;code&gt;I&lt;/code&gt; is defined as &lt;code&gt;&lt;a href=&quot;../numeric/complex/imaginary_i&quot;&gt;_Imaginary_I&lt;/a&gt;&lt;/code&gt;). Without imaginary types, certain special complex values cannot be created naturally. For example, if &lt;code&gt;I&lt;/code&gt; is defined as &lt;code&gt;&lt;a href=&quot;../numeric/complex/complex_i&quot;&gt;_Complex_I&lt;/a&gt;&lt;/code&gt;, then writing &lt;code&gt;0.0 + I*INFINITY&lt;/code&gt; gives NaN as the real part, and &lt;code&gt;&lt;a href=&quot;../numeric/complex/cmplx&quot;&gt;CMPLX&lt;/a&gt;(0.0, INFINITY)&lt;/code&gt; must be used instead. Same goes for the numbers with the negative zero imaginary component, which are meaningful when working with the library functions with branch cuts, such as &lt;code&gt;&lt;a href=&quot;../numeric/complex/csqrt&quot;&gt;csqrt&lt;/a&gt;&lt;/code&gt;: &lt;code&gt;1.0 - 0.0*I&lt;/code&gt; results in the positive zero imaginary component if &lt;code&gt;I&lt;/code&gt; is defined as &lt;code&gt;&lt;a href=&quot;../numeric/complex/complex_i&quot;&gt;_Complex_I&lt;/a&gt;&lt;/code&gt; and the negative zero imaginary part requires the use of &lt;code&gt;&lt;a href=&quot;../numeric/complex/cmplx&quot;&gt;CMPLX&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../numeric/complex/conj&quot;&gt;conj&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">허수는 자연 표기법 &lt;code&gt;x + I*y&lt;/code&gt; ( &lt;code&gt;I&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../numeric/complex/imaginary_i&quot;&gt;_Imaginary_I&lt;/a&gt;&lt;/code&gt; 로 정의 됨 )를 사용하여 모든 복소수를 표현할 수 있습니다 . 허수 유형이 없으면 특정 특수 복합 값을 자연스럽게 만들 수 없습니다. 예를 들어, &lt;code&gt;I&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;../numeric/complex/complex_i&quot;&gt;_Complex_I&lt;/a&gt;&lt;/code&gt; 로 정의 된 경우 &lt;code&gt;0.0 + I*INFINITY&lt;/code&gt; 를 쓰면 NaN이 실제 부분 으로 사용되며 대신 &lt;code&gt;&lt;a href=&quot;../numeric/complex/cmplx&quot;&gt;CMPLX&lt;/a&gt;(0.0, INFINITY)&lt;/code&gt; 사용해야합니다. &lt;code&gt;&lt;a href=&quot;../numeric/complex/csqrt&quot;&gt;csqrt&lt;/a&gt;&lt;/code&gt; : 1.0-0.0 &lt;code&gt;1.0 - 0.0*I&lt;/code&gt; 와 같은 브랜치 컷으로 라이브러리 함수를 사용할 때 의미가있는 음의 0의 가상 성분이있는 숫자도 마찬가지입니다 . &lt;code&gt;I&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;../numeric/complex/complex_i&quot;&gt;_Complex_I&lt;/a&gt;&lt;/code&gt; 로 정의되고 음의 제로 허수 부가 &lt;code&gt;&lt;a href=&quot;../numeric/complex/cmplx&quot;&gt;CMPLX&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../numeric/complex/conj&quot;&gt;conj&lt;/a&gt;&lt;/code&gt; 를 사용해야하는 경우 양의 제로 허수 성분 이됩니다 .</target>
        </trans-unit>
        <trans-unit id="b55efabcd8849ef60ae8f5ea3a08febcffd5cd21" translate="yes" xml:space="preserve">
          <source>The imaginary part is discarded</source>
          <target state="translated">허수 부분은 버려집니다</target>
        </trans-unit>
        <trans-unit id="597104ddba845ce9bd24aa6877ef6907f2382360" translate="yes" xml:space="preserve">
          <source>The imaginary part of &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">의 허수 부 &lt;code&gt;z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20a99abb7396bbd40ee3b035ec1eb049a07d6192" translate="yes" xml:space="preserve">
          <source>The imaginary part of the result follows the conversion rules for the corresponding real types</source>
          <target state="translated">결과의 허수 부분은 해당 실제 유형에 대한 변환 규칙을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="09714acfb208e9f9b257f3045c35d573a30525df" translate="yes" xml:space="preserve">
          <source>The imaginary part of the result is positive zero (or unsigned zero on non-IEEE systems)</source>
          <target state="translated">결과의 허수 부분은 양의 0입니다 (IEEE 이외의 시스템에서는 부호없는 0).</target>
        </trans-unit>
        <trans-unit id="dc1a01ff9f1f5abac042b758d317c3db71ae72ed" translate="yes" xml:space="preserve">
          <source>The implementation is guaranteed to support the registration of at least &lt;code&gt;32&lt;/code&gt; functions. The exact limit is implementation-defined.</source>
          <target state="translated">이 구현은 &lt;code&gt;32&lt;/code&gt; 개 이상의 기능 등록을 지원합니다 . 정확한 한도는 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="d883b4e1722e4a8d3caa8bc74366a237fa4929ec" translate="yes" xml:space="preserve">
          <source>The implementation may define additional macro constants in &lt;code&gt;&amp;lt;fenv.h&amp;gt;&lt;/code&gt; to identify additional floating-point exceptions. All such constants begin with &lt;code&gt;FE_&lt;/code&gt; followed by at least one uppercase letter.</source>
          <target state="translated">구현시 &lt;code&gt;&amp;lt;fenv.h&amp;gt;&lt;/code&gt; 에 추가 매크로 상수를 정의하여 추가 부동 소수점 예외를 식별 할 수 있습니다. 이러한 모든 상수는 &lt;code&gt;FE_&lt;/code&gt; 로 시작하고 그 뒤에 하나 이상의 대문자가옵니다.</target>
        </trans-unit>
        <trans-unit id="eee59aa77f4b166942e6841c23ab435c8ebfde79" translate="yes" xml:space="preserve">
          <source>The implicit conversion from floating-point to integral types also rounds towards zero, but is limited to the values that can be represented by the target type.</source>
          <target state="translated">부동 소수점에서 정수 유형으로의 암시 적 변환도 0으로 반올림되지만 대상 유형으로 표시 할 수있는 값으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="d244055efbceb9cd116b307d0068bd03d7ccf1f4" translate="yes" xml:space="preserve">
          <source>The index in an &lt;a href=&quot;array_initialization&quot;&gt;array designator&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;array_initialization&quot;&gt;배열 지정자&lt;/a&gt; 의 색인</target>
        </trans-unit>
        <trans-unit id="5e82d0a49cb26cac8606496f3b74019e4f5bd7ab" translate="yes" xml:space="preserve">
          <source>The initial value of atomic object of automatic storage duration that is not explicitly initialized using this macro(until C17) is indeterminate. The default (zero) initialization of static and thread-local variables produces a valid value however.</source>
          <target state="translated">이 매크로 (C17까지)를 사용하여 명시 적으로 초기화되지 않은 자동 저장 기간의 원자 객체의 초기 값은 미정입니다. 정적 및 스레드 로컬 변수의 기본 (0) 초기화는 유효한 값을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="c14bd019aca2383204e2ad83d047789a2c7ba54e" translate="yes" xml:space="preserve">
          <source>The initial values of function parameters are established as if by assignment from the arguments of a &lt;a href=&quot;operator_other#Function_call&quot;&gt;function call&lt;/a&gt;, rather than by initialization.</source>
          <target state="translated">함수 매개 변수의 초기 값은 초기화가 아닌 &lt;a href=&quot;operator_other#Function_call&quot;&gt;함수 호출&lt;/a&gt; 의 인수에서 지정하는 것처럼 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="f79095678450b261a7d4377d1d69bb99aef817af" translate="yes" xml:space="preserve">
          <source>The initializer for a scalar (an object of integer type including booleans and enumerated types, floating type including complex and imaginary, and pointer type including pointer to function) must be a single expression, optionally enclosed in braces:</source>
          <target state="translated">스칼라의 이니셜 라이저 (부울과 열거 형을 포함하는 정수형, 복소수와 허수를 포함하는 부동 형, 함수에 대한 포인터를 포함하는 포인터 형)의 객체는 선택적으로 중괄호로 묶어야합니다.</target>
        </trans-unit>
        <trans-unit id="051643a6443136c90c153854e9479f16f32a9c1c" translate="yes" xml:space="preserve">
          <source>The initializer list may have a trailing comma, which is ignored.</source>
          <target state="translated">초기화 목록에는 후행 쉼표가있을 수 있으며 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="a21f21c29b1dd53223eceae658fd8c0f4adf0abb" translate="yes" xml:space="preserve">
          <source>The initializer specifies the initial value stored in an object.</source>
          <target state="translated">이니셜 라이저는 객체에 저장된 초기 값을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="5dc8e20b4e5a968131b73c499de88baceffe7987" translate="yes" xml:space="preserve">
          <source>The initializers of the variables with automatic &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt; declared inside a block and the VLA declarators are executed when flow of control passes over these declarations in order, as if they were statements:</source>
          <target state="translated">블록 내에서 선언 된 자동 &lt;a href=&quot;storage_duration&quot;&gt;저장 기간&lt;/a&gt; 이있는 변수의 이니셜 라이저 와 VLA 선언자는 제어 흐름이 명령문처럼 순서대로 이러한 선언을 통과 할 때 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="3d0d426c073cbcb4ac70cff904892f38bd7c72ae" translate="yes" xml:space="preserve">
          <source>The integer argument of &lt;code&gt;_Alignas&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;_Alignas&lt;/code&gt; 의 정수 인수</target>
        </trans-unit>
        <trans-unit id="c052ad8a76feca9c20921855c2130e125e23b1b8" translate="yes" xml:space="preserve">
          <source>The intended use of the restrict qualifier (like the register storage class) is to promote optimization, and deleting all instances of the qualifier from all preprocessing translation units composing a conforming program does not change its meaning (i.e., observable behavior).</source>
          <target state="translated">제한 규정 자 (레지스터 저장 클래스와 같은)의 의도 된 사용은 최적화를 촉진하는 것이며, 규정을 준수하는 프로그램을 구성하는 모든 사전 처리 변환 단위에서 규정 자의 모든 인스턴스를 삭제해도 의미가 변경되지 않습니다 (즉, 관찰 가능한 동작).</target>
        </trans-unit>
        <trans-unit id="3461dd13d361fb9e7a46ff0b4396f48813e4b6bc" translate="yes" xml:space="preserve">
          <source>The intent of the &lt;code&gt;inline&lt;/code&gt; specifier is to serve as a hint for the compiler to perform optimizations, such as function inlining, which require the definition of a function to be visible at the call site. The compilers can (and usually do) ignore presence or absence of the &lt;code&gt;inline&lt;/code&gt; specifier for the purpose of optimization.</source>
          <target state="translated">&lt;code&gt;inline&lt;/code&gt; 지정자 의 목적은 컴파일러가 함수 인라인과 같은 최적화를 수행하기위한 힌트 역할을하며, 함수 정의는 호출 사이트에서 볼 수 있어야합니다. 컴파일러는 최적화를 위해 &lt;code&gt;inline&lt;/code&gt; 지정자의 유무를 무시할 수 있습니다 (보통) .</target>
        </trans-unit>
        <trans-unit id="c6924d561fcec2a25cafd9f30b6ce9d38cd1a4d2" translate="yes" xml:space="preserve">
          <source>The introduction of // comments in C99 was a breaking change in some rare circumstances:</source>
          <target state="translated">C99에 // 주석을 도입 한 것은 드문 상황에서 큰 변화였습니다.</target>
        </trans-unit>
        <trans-unit id="94b5c297f476b2d4707fabdba8af9c74ed678810" translate="yes" xml:space="preserve">
          <source>The invocation of &lt;code&gt;setjmp&lt;/code&gt; must appear only in one of the following contexts:</source>
          <target state="translated">&lt;code&gt;setjmp&lt;/code&gt; 의 호출은 다음 컨텍스트 중 하나에 만 나타나야합니다.</target>
        </trans-unit>
        <trans-unit id="df73dd5056e900e6ab07fe7d785f7316167ce7e1" translate="yes" xml:space="preserve">
          <source>The iteration statements repeatedly execute a statement.</source>
          <target state="translated">반복문은 반복적으로 명령문을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="5cbe65a328ae1a1725e46d04473058103fa2038a" translate="yes" xml:space="preserve">
          <source>The jump statements unconditionally transfer flow control.</source>
          <target state="translated">점프 문은 무조건 전송 제어를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="f512905bc0e7bcf8e0a06a3d543ae75331a9386b" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;_Thread_local&lt;/code&gt; is usually used through the convenience macro &lt;code&gt;&lt;a href=&quot;../thread/thread_local&quot;&gt;thread_local&lt;/a&gt;&lt;/code&gt;, defined in the header &lt;code&gt;threads.h&lt;/code&gt;.</source>
          <target state="translated">키워드 &lt;code&gt;_Thread_local&lt;/code&gt; 은 보통 편의 매크로를 사용 &lt;code&gt;&lt;a href=&quot;../thread/thread_local&quot;&gt;thread_local&lt;/a&gt;&lt;/code&gt; 헤더에 정의 &lt;code&gt;threads.h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c10772b161d3dd40c9407a3fdf1ba40e6710ac1e" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;typedef&lt;/code&gt; is used in a &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt;, in the grammatical position of a &lt;a href=&quot;storage_duration&quot;&gt;storage-class specifier&lt;/a&gt;, except that it does not affect storage or linkage:</source>
          <target state="translated">키워드 &lt;code&gt;typedef&lt;/code&gt; 는 &lt;a href=&quot;storage_duration&quot;&gt;스토리지 클래스 지정자&lt;/a&gt; 의 문법적 위치에서 &lt;a href=&quot;declarations&quot;&gt;선언&lt;/a&gt; 또는 저장소에 사용되지 않는 것을 제외하고 는 선언에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="38e6ce2423b10435fec95359cfc7871356cc7655" translate="yes" xml:space="preserve">
          <source>The largest representable floating-point values are exact integers in all standard floating-point formats, so &lt;code&gt;nearbyint&lt;/code&gt; never overflows on its own; however the result may overflow any integer type (including &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;intmax_t&lt;/a&gt;&lt;/code&gt;), when stored in an integer variable.</source>
          <target state="translated">표현할 수있는 가장 큰 부동 소수점 값은 모든 표준 부동 소수점 형식의 정확한 정수이므로 &lt;code&gt;nearbyint&lt;/code&gt; 자체가 오버플로하지 않습니다. 그러나 정수 변수에 저장된 경우 정수 형식 ( &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;intmax_t&lt;/a&gt;&lt;/code&gt; 포함 ) 이 오버플로 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b5db95457fd00b5137fae42ae0ad03c02ab7b1d9" translate="yes" xml:space="preserve">
          <source>The largest representable floating-point values are exact integers in all standard floating-point formats, so &lt;code&gt;rint&lt;/code&gt; never overflows on its own; however the result may overflow any integer type (including &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;intmax_t&lt;/a&gt;&lt;/code&gt;), when stored in an integer variable.</source>
          <target state="translated">표현할 수있는 가장 큰 부동 소수점 값은 모든 표준 부동 소수점 형식의 정확한 정수이므로 &lt;code&gt;rint&lt;/code&gt; 자체가 오버플로하지 않습니다. 그러나 정수 변수에 저장된 경우 정수 형식 ( &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;intmax_t&lt;/a&gt;&lt;/code&gt; 포함 ) 이 오버플로 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="32f6d5a8dd3178b9f5f93350efdb40176e9f37c4" translate="yes" xml:space="preserve">
          <source>The largest representable floating-point values are exact integers in all standard floating-point formats, so &lt;code&gt;round&lt;/code&gt; never overflows on its own; however the result may overflow any integer type (including &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;intmax_t&lt;/a&gt;&lt;/code&gt;), when stored in an integer variable.</source>
          <target state="translated">표현할 수있는 가장 큰 부동 소수점 값은 모든 표준 부동 소수점 형식의 정확한 정수이므로 &lt;code&gt;round&lt;/code&gt; 자체가 오버플로되지 않습니다. 그러나 정수 변수에 저장된 경우 정수 형식 ( &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;intmax_t&lt;/a&gt;&lt;/code&gt; 포함 ) 이 오버플로 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2394bacc13a55aabca9c891a3369daa891fec410" translate="yes" xml:space="preserve">
          <source>The largest representable floating-point values are exact integers in all standard floating-point formats, so this function never overflows on its own; however the result may overflow any integer type (including &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;intmax_t&lt;/a&gt;&lt;/code&gt;), when stored in an integer variable.</source>
          <target state="translated">표현할 수있는 가장 큰 부동 소수점 값은 모든 표준 부동 소수점 형식의 정확한 정수이므로이 함수는 절대 오버플로되지 않습니다. 그러나 정수 변수에 저장된 경우 정수 형식 ( &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;intmax_t&lt;/a&gt;&lt;/code&gt; 포함 ) 이 오버플로 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c4390732ceb72a7d86e32c5b0b0e5852ccc329b7" translate="yes" xml:space="preserve">
          <source>The length of the maximum initial segment that contains only characters from the null-terminated byte string pointed to by &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 가 가리키는 널 종료 바이트 문자열의 문자 만 포함하는 최대 초기 세그먼트의 길이입니다 .</target>
        </trans-unit>
        <trans-unit id="63de454d6ebc822ff35b5de2988085c7a2c0e23c" translate="yes" xml:space="preserve">
          <source>The length of the maximum initial segment that contains only characters from wide string pointed to by &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 가 가리키는 넓은 문자열의 문자 만 포함하는 최대 초기 세그먼트의 길이입니다 .</target>
        </trans-unit>
        <trans-unit id="5f772a2bec6f10a883f7267bd67367b712ef3954" translate="yes" xml:space="preserve">
          <source>The length of the maximum initial segment that contains only characters not found in the character string pointed to by &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 가 가리키는 문자열에서 찾을 수없는 문자 만 포함하는 최대 초기 세그먼트의 길이입니다 .</target>
        </trans-unit>
        <trans-unit id="6ba41a49e5fa46c983e71aed0b7bf8c8cf2bcd61" translate="yes" xml:space="preserve">
          <source>The length of the maximum initial segment that contains only characters not found in the null-terminated byte string pointed to by &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 가 가리키는 널 종료 바이트 문자열에서 찾을 수없는 문자 만 포함하는 최대 초기 세그먼트 길이 .</target>
        </trans-unit>
        <trans-unit id="593d216bcb63cbce0afb160433d1ab015cf4835d" translate="yes" xml:space="preserve">
          <source>The length of the transformed string, not including the terminating null-character.</source>
          <target state="translated">종료 널 문자를 포함하지 않는 변환 된 문자열의 길이입니다.</target>
        </trans-unit>
        <trans-unit id="e3b3ec34feef4d29ba71c02ffc289279c3d65e7e" translate="yes" xml:space="preserve">
          <source>The length of the transformed wide string, not including the terminating null-character.</source>
          <target state="translated">종료 널 문자를 포함하지 않고 변환 된 넓은 문자열의 길이입니다.</target>
        </trans-unit>
        <trans-unit id="049923770e49e0dc29c177e486ea5da1a8510445" translate="yes" xml:space="preserve">
          <source>The library type &lt;code&gt;&lt;a href=&quot;../program/sig_atomic_t&quot;&gt;sig_atomic_t&lt;/a&gt;&lt;/code&gt; does not provide inter-thread synchronization or memory ordering, only atomicity.</source>
          <target state="translated">라이브러리 유형 &lt;code&gt;&lt;a href=&quot;../program/sig_atomic_t&quot;&gt;sig_atomic_t&lt;/a&gt;&lt;/code&gt; 는 스레드 간 동기화 또는 메모리 순서를 제공하지 않으며 원 자성 만 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6e7074b32735e8bf688f9281dcebfc831011f3a5" translate="yes" xml:space="preserve">
          <source>The line number following the directive &lt;code&gt;#line __LINE__&lt;/code&gt; is implementation-defined (there are two possible values that __LINE__ can expand to in this case: number of endlines seen so far, or number of endlines seen so far plus the endline that ends the #line directive).</source>
          <target state="translated">지시문 &lt;code&gt;#line __LINE__&lt;/code&gt; 다음에 나오는 줄 번호 는 구현에 따라 정의됩니다 (이 경우 __LINE__에서 확장 할 수있는 두 가지 가능한 값이 있습니다 : 지금까지 본 줄 끝 수 또는 지금까지 본 줄 끝 수에 #line을 끝내는 끝 줄 지령).</target>
        </trans-unit>
        <trans-unit id="784e7ee73ce693765b5c5ba90815e9b87d11972a" translate="yes" xml:space="preserve">
          <source>The logical AND expression has the form.</source>
          <target state="translated">논리 AND 표현식의 형식이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d04b7b384fbd368de9e9b44a07a158efbdffa63" translate="yes" xml:space="preserve">
          <source>The logical NOT expression has the form.</source>
          <target state="translated">논리 NOT 표현식의 형식이 있습니다.</target>
        </trans-unit>
        <trans-unit id="00f39c867b0308cf432ff2ac9d19a03a4ddb3431" translate="yes" xml:space="preserve">
          <source>The logical NOT operator has type &lt;code&gt;int&lt;/code&gt;. Its value is &lt;code&gt;​0​&lt;/code&gt; if expression evaluates to a value that compares unequal to zero. Its value is &lt;code&gt;1&lt;/code&gt; if expression evaluates to a value that compares equal to zero. (so &lt;code&gt;!E&lt;/code&gt; is the same as &lt;code&gt;(0==E)&lt;/code&gt;).</source>
          <target state="translated">논리 NOT 연산자의 유형은 &lt;code&gt;int&lt;/code&gt; 입니다. 그 값은 &lt;code&gt;​0​&lt;/code&gt; 식 제로 불균등 비교 값으로 평가되는 경우. expression이 0과 비교되는 값으로 평가되면 값은 &lt;code&gt;1&lt;/code&gt; 입니다. 따라서 &lt;code&gt;!E&lt;/code&gt; 는 &lt;code&gt;(0==E)&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="fa0017b25e29a52a58370b61f25df5eb44b294a7" translate="yes" xml:space="preserve">
          <source>The logical OR expression has the form.</source>
          <target state="translated">논리 OR 식의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8cfbb57750fb5f7112ff7e65f25d43235885b786" translate="yes" xml:space="preserve">
          <source>The logical-AND operator has type &lt;code&gt;int&lt;/code&gt; and the value &lt;code&gt;1&lt;/code&gt; if both lhs and rhs compare unequal to zero. It has the value &lt;code&gt;​0​&lt;/code&gt; otherwise (if either lhs or rhs or both compare equal to zero).</source>
          <target state="translated">논리 AND 연산자는 lhs와 rhs가 모두 0이 아닌 경우 &lt;code&gt;int&lt;/code&gt; 와 값 &lt;code&gt;1&lt;/code&gt; 을 갖습니다. 이 값을 가지고 &lt;code&gt;​0​&lt;/code&gt; (좌 또는 우 하나 또는 둘 모두가 0과 비교하는 경우), 그렇지.</target>
        </trans-unit>
        <trans-unit id="5b1edfa9d60b658de6c633aadb9fa593c4e1a912" translate="yes" xml:space="preserve">
          <source>The logical-OR operator has type &lt;code&gt;int&lt;/code&gt; and the value &lt;code&gt;1&lt;/code&gt; if either lhs or rhs compare unequal to zero. It has value &lt;code&gt;​0​&lt;/code&gt; otherwise (if both lhs and rhs compare equal to zero).</source>
          <target state="translated">논리 OR 연산자의 유형은 &lt;code&gt;int&lt;/code&gt; 이며 lhs 또는 rhs가 0이 아닌 경우 값 &lt;code&gt;1&lt;/code&gt; 입니다. 이 값을 가지고 &lt;code&gt;​0​&lt;/code&gt; (모두 LHS와 RHS가 0과 비교하는 경우), 그렇지.</target>
        </trans-unit>
        <trans-unit id="1a2eca04fbdbfa85ffa013854d23cfd7ee4c2242" translate="yes" xml:space="preserve">
          <source>The lvalue expressions that designate objects of const-qualified type and the lvalue expressions that designate objects of struct or union type with at least one member of const-qualified type (including members of recursively contained aggregates or unions), are not</source>
          <target state="translated">const 한정 형식의 개체를 지정하는 lvalue 식과 const 한정 형식의 멤버 (재귀 적으로 포함 된 집계 또는 공용체의 멤버 포함)를 하나 이상 가진 구조체 또는 공용체 형식의 개체를 지정하는 lvalue 식은</target>
        </trans-unit>
        <trans-unit id="44ca3a77c674e6760cefc2d99377e4d887b83ff7" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;I&lt;/code&gt; is often used to form complex numbers, with expressions such as &lt;code&gt;x + y*I&lt;/code&gt;. If &lt;code&gt;I&lt;/code&gt; is defined as &lt;code&gt;&lt;a href=&quot;complex_i&quot;&gt;_Complex_I&lt;/a&gt;&lt;/code&gt;, then such expression may create a value with imaginary component &lt;code&gt;+0.0&lt;/code&gt; even when &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;-0.0&lt;/code&gt;, which is significant for complex number functions with branch cuts. The macro &lt;code&gt;&lt;a href=&quot;cmplx&quot;&gt;CMPLX&lt;/a&gt;&lt;/code&gt; provides a way to construct a complex number precisely.</source>
          <target state="translated">매크로 &lt;code&gt;I&lt;/code&gt; 는 종종 &lt;code&gt;x + y*I&lt;/code&gt; 와 같은 표현식으로 복소수를 형성하는 데 사용됩니다 . &lt;code&gt;I&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;complex_i&quot;&gt;_Complex_I&lt;/a&gt;&lt;/code&gt; 로 정의 된 경우 , &lt;code&gt;y&lt;/code&gt; 가 &lt;code&gt;-0.0&lt;/code&gt; 일 때에도 이러한 표현식은 허수 &lt;code&gt;+0.0&lt;/code&gt; 을 사용하여 값을 작성할 수 있으며 , 이는 분기 컷이있는 복소수 함수에 중요합니다. 매크로 &lt;code&gt;&lt;a href=&quot;cmplx&quot;&gt;CMPLX&lt;/a&gt;&lt;/code&gt; 는 복소수를 정확하게 구성하는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a80e1699fb25e0be7eaf64d7cde6fed39109e343" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;NAN&lt;/code&gt; expands to constant expression of type &lt;code&gt;float&lt;/code&gt; which evaluates to a quiet not-a-number (QNaN) value. If the implementation does not support QNaNs, this macro constant is not defined.</source>
          <target state="translated">매크로 &lt;code&gt;NAN&lt;/code&gt; 은 &lt;code&gt;float&lt;/code&gt; 형식의 상수 표현으로 확장되어 조용한 비 숫자 (QNaN) 값으로 평가됩니다. 구현이 QNaN을 지원하지 않는 경우이 매크로 상수는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="511bc44ac64af1c05b670d54015e303e4e44b53b" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;NULL&lt;/code&gt; is an implementation-defined null pointer constant, which may be.</source>
          <target state="translated">매크로 &lt;code&gt;NULL&lt;/code&gt; 은 구현-정의 된 널 포인터 상수 일 수있다.</target>
        </trans-unit>
        <trans-unit id="3b57be3ca2436b3c7e80915f52102e2654815419" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;offsetof&lt;/code&gt; expands to an &lt;a href=&quot;../language/constant_expression#Integer_constant_expression&quot;&gt;integer constant expression&lt;/a&gt; of type &lt;code&gt;&lt;a href=&quot;size_t&quot;&gt;size_t&lt;/a&gt;&lt;/code&gt;, the value of which is the offset, in bytes, from the beginning of an object of specified type to its specified member, including padding if any.</source>
          <target state="translated">매크로 &lt;code&gt;offsetof&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;size_t&quot;&gt;size_t&lt;/a&gt;&lt;/code&gt; 유형 의 &lt;a href=&quot;../language/constant_expression#Integer_constant_expression&quot;&gt;정수 상수 표현식&lt;/a&gt; 으로 확장되며 , 값은 지정된 유형의 오브젝트 시작에서 지정된 멤버 (있는 경우)를 포함하여 지정된 멤버까지의 오프셋 (바이트 단위)입니다.</target>
        </trans-unit>
        <trans-unit id="a5a472a05b4e53b9216f7fc0c3e059710e59c4a4" translate="yes" xml:space="preserve">
          <source>The macro constant &lt;code&gt;FE_ALL_EXCEPT&lt;/code&gt;, which expands to the bitwise OR of all other &lt;code&gt;FE_*&lt;/code&gt;, is always defined and is zero if floating-point exceptions are not supported by the implementation.</source>
          <target state="translated">다른 모든 &lt;code&gt;FE_*&lt;/code&gt; 의 비트 단위 OR로 확장되는 매크로 상수 &lt;code&gt;FE_ALL_EXCEPT&lt;/code&gt; 는 항상 정의되며 구현에서 부동 소수점 예외가 지원되지 않으면 0입니다.</target>
        </trans-unit>
        <trans-unit id="8841799ce4f61109365c940ff69b8b7ec719c836" translate="yes" xml:space="preserve">
          <source>The macro constant &lt;code&gt;FE_DFL_ENV&lt;/code&gt; expands to an expression of type &lt;code&gt;const fenv_t*&lt;/code&gt;, which points to a full copy of the default floating-point environment, that is, the environment as loaded at program startup.</source>
          <target state="translated">매크로 상수 &lt;code&gt;FE_DFL_ENV&lt;/code&gt; 는 &lt;code&gt;const fenv_t*&lt;/code&gt; 유형의 표현식으로 확장되어 기본 부동 소수점 환경의 전체 사본, 즉 프로그램 시작시로드 된 환경을 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="4e6484c8cfd3a1b8d998f588b04075f3f3fb6a9f" translate="yes" xml:space="preserve">
          <source>The macro constant &lt;code&gt;math_errhandling&lt;/code&gt; expands to an expression of type &lt;code&gt;int&lt;/code&gt; that is either equal to &lt;code&gt;MATH_ERRNO&lt;/code&gt;, or equal to &lt;code&gt;MATH_ERREXCEPT&lt;/code&gt;, or equal to their bitwise OR (&lt;code&gt;MATH_ERRNO | MATH_ERREXCEPT&lt;/code&gt;).</source>
          <target state="translated">매크로 상수 &lt;code&gt;math_errhandling&lt;/code&gt; 은 &lt;code&gt;MATH_ERRNO&lt;/code&gt; 와 같거나 &lt;code&gt;MATH_ERREXCEPT&lt;/code&gt; 와 같거나 비트 OR ( &lt;code&gt;MATH_ERRNO | MATH_ERREXCEPT&lt;/code&gt; ) 인 &lt;code&gt;int&lt;/code&gt; 유형의 표현식으로 확장됩니다 .</target>
        </trans-unit>
        <trans-unit id="0e0067abc6a159712bb56dd3f2aea66ef110adc4" translate="yes" xml:space="preserve">
          <source>The macro is not named &lt;code&gt;i&lt;/code&gt;, which is the name of the imaginary unit in mathematics, because the name &lt;code&gt;i&lt;/code&gt; was already used in many C programs, e.g. as a loop counter variable.</source>
          <target state="translated">매크로는 &lt;code&gt;i&lt;/code&gt; 라는 이름이 아니며 수학에서 허수 단위의 이름입니다. 이름 &lt;code&gt;i&lt;/code&gt; 는 많은 C 프로그램에서 이미 루프 카운터 변수로 사용 되었기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="c798130b9170a560fc1a663c486665854f217b8c" translate="yes" xml:space="preserve">
          <source>The mapped value of &lt;code&gt;wc&lt;/code&gt; using the mapping identified by &lt;code&gt;desc&lt;/code&gt; in LC_CTYPE facet of the current C locale.</source>
          <target state="translated">현재 C 로케일의 LC_CTYPE 패싯에서 &lt;code&gt;desc&lt;/code&gt; 로 식별 된 맵핑을 사용하여 &lt;code&gt;wc&lt;/code&gt; 의 맵핑 된 값</target>
        </trans-unit>
        <trans-unit id="030e1db264f4cf63958d4ac7eff5a182391b9628" translate="yes" xml:space="preserve">
          <source>The mathematical definition of the principal value of arc sine is asin z = -</source>
          <target state="translated">아크 사인의 주요 값의 수학적 정의는 다음과 같습니다. asin z =-</target>
        </trans-unit>
        <trans-unit id="97d3912b761a5766d76f8e019b7647d3c28a58a9" translate="yes" xml:space="preserve">
          <source>The mathematical definition of the principal value of the inverse hyperbolic cosine is acosh z = ln(z + &amp;radic;z+1&amp;radic;z-1)  For any z, acosh(z) =</source>
          <target state="translated">역 쌍곡 코사인의 주요 값의 수학적 정의는 acosh z = ln (z + &amp;radic;z + 1&amp;radic;z-1)입니다. z에 대해 acosh (z) =</target>
        </trans-unit>
        <trans-unit id="2ee0c302057514ba3aa0f5c20f8146065a6d4cf3" translate="yes" xml:space="preserve">
          <source>The mathematical definition of the principal value of the inverse hyperbolic sine is asinh z = ln(z + &amp;radic;1+z2</source>
          <target state="translated">역 쌍곡 사인의 주요 값의 수학적 정의는 asinh z = ln (z + &amp;radic;1 + z2</target>
        </trans-unit>
        <trans-unit id="329fc6fceaa5447c01dd9f62cafecf085e1ff466" translate="yes" xml:space="preserve">
          <source>The member access expression designates the named member of the &lt;a href=&quot;struct&quot;&gt;struct&lt;/a&gt; or &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt; designated by its left operand. It has the same &lt;a href=&quot;value_category&quot;&gt;value category&lt;/a&gt; as its left operand.</source>
          <target state="translated">멤버 액세스 표현식 은 왼쪽 피연산자가 지정한 &lt;a href=&quot;struct&quot;&gt;구조체&lt;/a&gt; 또는 &lt;a href=&quot;union&quot;&gt;공용체&lt;/a&gt; 의 명명 된 멤버를 지정합니다 . 왼쪽 피연산자 와 동일한 &lt;a href=&quot;value_category&quot;&gt;값 범주&lt;/a&gt; 를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="c5122e1449ef0335505c57e5253a964f45fcdf79" translate="yes" xml:space="preserve">
          <source>The member access expression has the form.</source>
          <target state="translated">멤버 액세스 식의 형식이 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa318493dd5c2f458fec0ccc1d6f9c59afaab4fd" translate="yes" xml:space="preserve">
          <source>The member access through pointer expression designates the named member of the &lt;a href=&quot;struct&quot;&gt;struct&lt;/a&gt; or &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt; type pointed to by its left operand. Its value category is always &lt;a href=&quot;value_category&quot;&gt;lvalue&lt;/a&gt;.</source>
          <target state="translated">포인터 표현식을 통한 멤버 액세스 는 왼쪽 피연산자가 가리키는 &lt;a href=&quot;struct&quot;&gt;구조체&lt;/a&gt; 또는 &lt;a href=&quot;union&quot;&gt;공용체&lt;/a&gt; 유형 의 명명 된 멤버를 지정합니다 . 값 범주는 항상 &lt;a href=&quot;value_category&quot;&gt;lvalue&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6d6e0885b44b0d2f2e93a7131b908d31fa827da7" translate="yes" xml:space="preserve">
          <source>The memory models for the read-modify-write and load operations are &lt;code&gt;succ&lt;/code&gt; and &lt;code&gt;fail&lt;/code&gt; respectively. The (1-2) versions use &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; by default.</source>
          <target state="translated">읽기-수정-쓰기 및로드 작업을위한 메모리 모델은 각각 &lt;code&gt;succ&lt;/code&gt; 및 &lt;code&gt;fail&lt;/code&gt; 입니다. (1-2) 버전 은 기본적으로 &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; 를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="6f83b6ed70462af18ce1b14250e467f4f95844bf" translate="yes" xml:space="preserve">
          <source>The memory-writing conversion specifier &lt;code&gt;%n&lt;/code&gt; is a common target of security exploits where format strings depend on user input and is not supported by the bounds-checked &lt;code&gt;printf_s&lt;/code&gt; family of functions.</source>
          <target state="translated">메모리 쓰기 변환 지정자 &lt;code&gt;%n&lt;/code&gt; 은 형식 문자열이 사용자 입력에 의존하고 경계 확인 &lt;code&gt;printf_s&lt;/code&gt; 함수 계열에서 지원되지 않는 보안 악용의 일반적인 대상입니다 .</target>
        </trans-unit>
        <trans-unit id="98877038e2ba0fac0c119a38c0522d0619de0c17" translate="yes" xml:space="preserve">
          <source>The most common keywords that begin with an underscore are generally used through their convenience macros:</source>
          <target state="translated">밑줄로 시작하는 가장 일반적인 키워드는 일반적으로 편의 매크로를 통해 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="45bbb14be1144d08570d1c46bcac519c4ca04a16" translate="yes" xml:space="preserve">
          <source>The most popular use case for restrict-qualified pointers is the use as function parameters.</source>
          <target state="translated">제한 규정 포인터의 가장 보편적 인 사용 사례는 함수 매개 변수로 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b1f3d7cdd9264d99f9f78cc280cd57b23e748c7e" translate="yes" xml:space="preserve">
          <source>The name stands for &quot;string pointer break&quot;, because it returns a pointer to the first of the separator (&quot;break&quot;) characters.</source>
          <target state="translated">이름은 &quot;문자열 포인터 나누기&quot;를 나타내며, 첫 번째 구분 기호 ( &quot;break&quot;) 문자에 대한 포인터를 반환하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="1ee1404e6d3d16d932267176149d19223296bb12" translate="yes" xml:space="preserve">
          <source>The names &lt;code&gt;argc&lt;/code&gt; and &lt;code&gt;argv&lt;/code&gt; are arbitrary, as well as the representation of the types of the parameters: &lt;code&gt;int main(int ac, char** av)&lt;/code&gt; is equally valid.</source>
          <target state="translated">&lt;code&gt;argc&lt;/code&gt; 와 &lt;code&gt;argv&lt;/code&gt; 라는 이름 은 임의적이며 매개 변수 유형의 표현입니다. &lt;code&gt;int main(int ac, char** av)&lt;/code&gt; 도 똑같이 유효합니다.</target>
        </trans-unit>
        <trans-unit id="1bb2ce61596e9a9e2acbc1daec6dd4f31667f9c0" translate="yes" xml:space="preserve">
          <source>The names of &lt;a href=&quot;../preprocessor/replace&quot;&gt;macros&lt;/a&gt; are not part of any name space because they are replaced by the preprocessor prior to semantic analysis.</source>
          <target state="translated">&lt;a href=&quot;../preprocessor/replace&quot;&gt;매크로&lt;/a&gt; 의 이름은 의미 분석 전에 전처리기로 대체되므로 이름 공간의 일부가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="da3734864c7a6f4ae8da4b63030befa1148f5321" translate="yes" xml:space="preserve">
          <source>The natural logarithm of a complex number z with polar coordinate components (r,&amp;theta;) equals ln r + i(&amp;theta;+2n&amp;pi;), with the principal value ln r + i&amp;theta;</source>
          <target state="translated">극좌표 성분 (r, &amp;theta;)을 갖는 복소수 z의 자연 로그는 ln r + i (&amp;theta; + 2n&amp;pi;)이며, 주값은 ln r + i&amp;theta;입니다.</target>
        </trans-unit>
        <trans-unit id="3e1f12a369d7befe692c93f44687eb7110ca778a" translate="yes" xml:space="preserve">
          <source>The nearest integer value to &lt;code&gt;arg&lt;/code&gt;, according to the &lt;a href=&quot;../fenv/fe_round&quot;&gt;current rounding mode&lt;/a&gt;, is returned.</source>
          <target state="translated">&lt;a href=&quot;../fenv/fe_round&quot;&gt;현재 반올림 모드&lt;/a&gt; 에 따라 &lt;code&gt;arg&lt;/code&gt; 에 가장 가까운 정수 값 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f6eccb49cbb94feecde36ffadd4ba34340c519c4" translate="yes" xml:space="preserve">
          <source>The new-line character &lt;code&gt;\n&lt;/code&gt; has special meaning when used in &lt;a href=&quot;../io&quot;&gt;text mode I/O&lt;/a&gt;: it is converted to the OS-specific newline byte or byte sequence.</source>
          <target state="translated">개행 문자 &lt;code&gt;\n&lt;/code&gt; 은 &lt;a href=&quot;../io&quot;&gt;텍스트 모드 I / O&lt;/a&gt; 에서 사용될 때 특별한 의미를 갖 습니다. OS 별 개행 바이트 또는 바이트 시퀀스로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="61b9c57e3af3e967b10eb352639b13192c618556" translate="yes" xml:space="preserve">
          <source>The next wide character from the stream or &lt;code&gt;WEOF&lt;/code&gt; on failure.</source>
          <target state="translated">스트림의 다음 와이드 문자 또는 실패시 &lt;code&gt;WEOF&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c07d16928e24253bdda00754b26c48658241a00d" translate="yes" xml:space="preserve">
          <source>The null directive (&lt;code&gt;#&lt;/code&gt; followed by a line break) is allowed and has no effect.</source>
          <target state="translated">널 지시문 ( &lt;code&gt;#&lt;/code&gt; 뒤에 줄 바꿈)이 허용되며 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="04d92f701b5c07543e4ab84377a0c9414fa7a320" translate="yes" xml:space="preserve">
          <source>The number of arguments must be the same as the number of arguments in the macro definition (parameters) or the program is ill-formed. If the identifier is not in functional-notation, i.e. does not have parentheses after itself, it is not replaced at all.</source>
          <target state="translated">인수 수는 매크로 정의 (매개 변수)의 인수 수와 같아야합니다. 그렇지 않으면 프로그램이 잘못 구성됩니다. 식별자가 기능적 표기법에 있지 않은 경우, 즉 그 뒤에 괄호가 없으면 전혀 대체되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1b02eec6dc83ccdd83bcea1a56eb671b42ec3a69" translate="yes" xml:space="preserve">
          <source>The number of bytes written into the character array pointed to by &lt;code&gt;str&lt;/code&gt; not including the terminating &lt;code&gt;'\0'&lt;/code&gt; on success. If &lt;code&gt;count&lt;/code&gt; was reached before the entire string could be stored, &lt;code&gt;​0​&lt;/code&gt; is returned and the contents are undefined.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 이 가리키는 문자 배열에 쓰여진 바이트 수는 성공시 종료 &lt;code&gt;'\0'&lt;/code&gt; 을 포함하지 않습니다 . 경우 &lt;code&gt;count&lt;/code&gt; 전체 문자열이 저장되기 전에 도달 한, &lt;code&gt;​0​&lt;/code&gt; 반환되고 내용이 정의되지 않은 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9e0726f8dc98eb74868d9afc85bf0df3317f165" translate="yes" xml:space="preserve">
          <source>The number of objects written successfully, which may be less than &lt;code&gt;count&lt;/code&gt; if an error occurs.</source>
          <target state="translated">성공적으로 기록 된 개체 &lt;code&gt;count&lt;/code&gt; , 오류가 발생하는 경우 개수 보다 적을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="807035c9e6b0ffb0f3a70e237d402f9009cdef78" translate="yes" xml:space="preserve">
          <source>The obtained character on success or &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; on failure.</source>
          <target state="translated">성공시 획득 한 문자 또는 실패시 &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b873fe3bdfab61293a8ea3488d6ce55e2f2befb5" translate="yes" xml:space="preserve">
          <source>The only difference between &lt;code&gt;nearbyint&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;rint&quot;&gt;rint&lt;/a&gt;&lt;/code&gt; is that &lt;code&gt;nearbyint&lt;/code&gt; never raises &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;nearbyint&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;rint&quot;&gt;rint&lt;/a&gt;&lt;/code&gt; 의 유일한 차이점은 가까이 에있는 &lt;code&gt;nearbyint&lt;/code&gt; 결코 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; 를 발생 시키지 않는다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="12dd6a69e521621a23e516eeff24b5d905692137" translate="yes" xml:space="preserve">
          <source>The only difference between &lt;code&gt;rint&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;nearbyint&quot;&gt;nearbyint&lt;/a&gt;&lt;/code&gt; is that &lt;code&gt;&lt;a href=&quot;nearbyint&quot;&gt;nearbyint&lt;/a&gt;&lt;/code&gt; never raises &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;rint&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;nearbyint&quot;&gt;nearbyint&lt;/a&gt;&lt;/code&gt; 의 유일한 차이점은 nearint 가 절대 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;&lt;a href=&quot;nearbyint&quot;&gt;nearbyint&lt;/a&gt;&lt;/code&gt; 시키지 않는다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="0ff53dd2216bc51a0d7bbb3c32825f9455bce0ac" translate="yes" xml:space="preserve">
          <source>The operand expr of both prefix and postfix increment or decrement must be a &lt;a href=&quot;value_category&quot;&gt;modifiable lvalue&lt;/a&gt; of &lt;a href=&quot;compatible_type&quot;&gt;integer type&lt;/a&gt; (including &lt;code&gt;_Bool&lt;/code&gt; and enums), real floating type, or a pointer type. It may be cvr-qualified, unqualified, or &lt;a href=&quot;atomic&quot;&gt;atomic&lt;/a&gt;.</source>
          <target state="translated">의 피연산자 EXPR 모두 접두사와 접미사 증가 또는 감소가 있어야합니다 &lt;a href=&quot;value_category&quot;&gt;수정 좌변&lt;/a&gt; 의 &lt;a href=&quot;compatible_type&quot;&gt;정수형&lt;/a&gt; (포함 &lt;code&gt;_Bool&lt;/code&gt; 및 열거), 실제 부동 유형 또는 포인터 타입. cvr-qualified, unqualified 또는 &lt;a href=&quot;atomic&quot;&gt;atomic&lt;/a&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="18275d066ab2586011d304d388724f3ba9519b5f" translate="yes" xml:space="preserve">
          <source>The operand is not evaluated (so external identifiers used in the operand do not have to be defined).</source>
          <target state="translated">피연산자가 평가되지 않으므로 피연산자에 사용 된 외부 식별자를 정의 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="37137d3854c9080efa5ba737cb6b214274865b11" translate="yes" xml:space="preserve">
          <source>The operand of &lt;code&gt;sizeof&lt;/code&gt; can't be a type cast: the expression &lt;code&gt;sizeof (int) * p&lt;/code&gt; is unambiguously interpreted as &lt;code&gt;(sizeof(int)) * p&lt;/code&gt;, but not &lt;code&gt;sizeof((int)*p)&lt;/code&gt;.</source>
          <target state="translated">의 피연산자 &lt;code&gt;sizeof&lt;/code&gt; 타입 캐스트 할 수 없습니다 발현 &lt;code&gt;sizeof (int) * p&lt;/code&gt; 명확하게 해석된다 &lt;code&gt;(sizeof(int)) * p&lt;/code&gt; 아니라 &lt;code&gt;sizeof((int)*p)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b4163fdf5ba90cadb97f17282331d38484360c2" translate="yes" xml:space="preserve">
          <source>The operand of prefix &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; can't be a type cast. This rule grammatically forbids some expressions that would be semantically invalid anyway. Some compilers ignore this rule and detect the invalidity semantically.</source>
          <target state="translated">접두사 &lt;code&gt;++&lt;/code&gt; 및 &lt;code&gt;--&lt;/code&gt; 의 피연산자 는 유형 캐스트 ​​일 수 없습니다. 이 규칙은 어쨌든 의미 상 유효하지 않은 일부 표현식을 문법적으로 금지합니다. 일부 컴파일러는이 규칙을 무시하고 의미를 무효로 감지합니다.</target>
        </trans-unit>
        <trans-unit id="73662db4f86c916723ec8e38855bae82c65cb635" translate="yes" xml:space="preserve">
          <source>The operands of any operator may be other expressions or they may be</source>
          <target state="translated">연산자의 피연산자는 다른 표현식 일 수도 있고</target>
        </trans-unit>
        <trans-unit id="b31ff6e872519cb01b42793b5610377a28df7a92" translate="yes" xml:space="preserve">
          <source>The operands of the &lt;a href=&quot;sizeof&quot;&gt;sizeof operator&lt;/a&gt;, the &lt;a href=&quot;alignof&quot;&gt;_Alignof operator&lt;/a&gt;, and the controlling expression of a &lt;a href=&quot;generic&quot;&gt;generic selection&lt;/a&gt;,(since C11) are expressions that are not evaluated (unless they are VLAs)(since C99). Thus, &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;size_t&lt;/a&gt; n = sizeof(&lt;a href=&quot;../io/fprintf&quot;&gt;printf&lt;/a&gt;(&quot;%d&quot;, 4));&lt;/code&gt; does not perform console output.</source>
          <target state="translated">&lt;a href=&quot;sizeof&quot;&gt;sizeof 연산자&lt;/a&gt; 의 피연산자 , &lt;a href=&quot;alignof&quot;&gt;_Alignof 연산자&lt;/a&gt; 및 &lt;a href=&quot;generic&quot;&gt;일반 선택&lt;/a&gt; 제어 식 (C11부터)은 평가되지 않은 식입니다 (CLA 이후가 아닌 경우) (C99 이후). 따라서 &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;size_t&lt;/a&gt; n = sizeof(&lt;a href=&quot;../io/fprintf&quot;&gt;printf&lt;/a&gt;(&quot;%d&quot;, 4));&lt;/code&gt; 콘솔 출력을 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d297e1f23cc8859be5bde831c7d9be6c7bf9a287" translate="yes" xml:space="preserve">
          <source>The order of bit fields within an allocation unit (on some platforms, bit fields are packed left-to-right, on others right-to-left)</source>
          <target state="translated">할당 단위 내의 비트 필드 순서 (일부 플랫폼에서는 비트 필드가 왼쪽에서 오른쪽으로, 다른 필드에서 오른쪽에서 왼쪽으로 압축 됨)</target>
        </trans-unit>
        <trans-unit id="0cc9aa93e9756b28627ee99925b99df10b1ad6c5" translate="yes" xml:space="preserve">
          <source>The order of evaluation of # and ## operators is unspecified.</source>
          <target state="translated"># 및 ## 연산자의 평가 순서는 지정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="e5a0f335326728b6cca410047346d8dea887e482" translate="yes" xml:space="preserve">
          <source>The other use of the keyword &lt;code&gt;static&lt;/code&gt; is &lt;a href=&quot;file_scope&quot;&gt;file scope&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;static&lt;/code&gt; 키워드의 다른 용도 는 &lt;a href=&quot;file_scope&quot;&gt;파일 범위&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="69f26538f800d4e9dfa396f5f3af68d5b600733f" translate="yes" xml:space="preserve">
          <source>The parameters in a declaration that is not part of a &lt;a href=&quot;function_definition&quot;&gt;function definition&lt;/a&gt; do not need to be named:</source>
          <target state="translated">&lt;a href=&quot;function_definition&quot;&gt;함수 정의의&lt;/a&gt; 일부가 아닌 선언의 매개 변수는 이름을 지정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="467dc40c372e73f0c2c12405d62c7e8ef32d3367" translate="yes" xml:space="preserve">
          <source>The parameters of the two-parameter form of the main function allow arbitrary multibyte character strings to be passed from the execution environment (these are typically known as</source>
          <target state="translated">main 함수의 두 매개 변수 형식의 매개 변수를 사용하면 임의의 멀티 바이트 문자열을 실행 환경에서 전달할 수 있습니다 (일반적으로</target>
        </trans-unit>
        <trans-unit id="bcaa687493b6df88d7a017675ddb9c620e6ecde2" translate="yes" xml:space="preserve">
          <source>The pragma directive controls implementation-specific behavior of the compiler, such as disabling compiler warnings or changing alignment requirements. Any pragma that is not recognized is ignored.</source>
          <target state="translated">pragma 지시문은 컴파일러 경고 비활성화 또는 정렬 요구 사항 변경과 같은 컴파일러의 구현 별 동작을 제어합니다. 인식되지 않는 pragma는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="5c545f4e65d9a240009138753e3771a06a41dbc9" translate="yes" xml:space="preserve">
          <source>The predefined variable &lt;code&gt;__func__&lt;/code&gt; (see &lt;a href=&quot;../language/function_definition#func&quot;&gt;function definition&lt;/a&gt; for details) is not a preprocessor macro, even though it is sometimes used together with &lt;code&gt;__FILE__&lt;/code&gt; and &lt;code&gt;__LINE__&lt;/code&gt;, e.g. by &lt;code&gt;&lt;a href=&quot;../error/assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">사전 정의 된 변수 &lt;code&gt;__func__&lt;/code&gt; (자세한 내용은 &lt;a href=&quot;../language/function_definition#func&quot;&gt;함수 정의&lt;/a&gt; 참조)은 예를 들어 &lt;code&gt;&lt;a href=&quot;../error/assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt; 와 같이 &lt;code&gt;__FILE__&lt;/code&gt; 및 &lt;code&gt;__LINE__&lt;/code&gt; 과 함께 사용되는 경우에도 전 처리기 매크로가 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="05a52076d2dc5c8b894927a5e244dc4ac56fe7ce" translate="yes" xml:space="preserve">
          <source>The preprocessing directives control the behavior of the preprocessor. Each directive occupies one line and has the following format:</source>
          <target state="translated">전처리 지시문은 전 처리기의 동작을 제어합니다. 각 지시문은 한 줄을 차지하며 다음 형식을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="cb413a6249ff3f9ad8dd052d27dcc328f60aee81" translate="yes" xml:space="preserve">
          <source>The preprocessor has the source file translation capabilities:</source>
          <target state="translated">전처리기에는 소스 파일 변환 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6aa350ea11bb9c5aa25e6e5ec9306cca0035172c" translate="yes" xml:space="preserve">
          <source>The preprocessor is executed at &lt;a href=&quot;language/translation_phases&quot;&gt;translation phase 4&lt;/a&gt;, before the compilation. The result of preprocessing is a single file which is then passed to the actual compiler.</source>
          <target state="translated">프리 프로세서는 컴파일 &lt;a href=&quot;language/translation_phases&quot;&gt;단계 4의 변환 단계&lt;/a&gt; 에서 실행됩니다 . 전처리 결과는 단일 파일이며 실제 컴파일러로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="bc4687c98781e74fbe3189f89c48b78e9e171beb" translate="yes" xml:space="preserve">
          <source>The preprocessor supports conditional compilation of parts of a source file. This behavior is controlled by &lt;code&gt;#if&lt;/code&gt;, &lt;code&gt;#else&lt;/code&gt;, &lt;code&gt;#elif&lt;/code&gt;, &lt;code&gt;#ifdef&lt;/code&gt;, &lt;code&gt;#ifndef&lt;/code&gt; and &lt;code&gt;#endif&lt;/code&gt; directives.</source>
          <target state="translated">전처리 기는 소스 파일의 일부에 대한 조건부 컴파일을 지원합니다. 이 동작은 &lt;code&gt;#if&lt;/code&gt; , &lt;code&gt;#else&lt;/code&gt; , &lt;code&gt;#elif&lt;/code&gt; , &lt;code&gt;#ifdef&lt;/code&gt; , &lt;code&gt;#ifndef&lt;/code&gt; 및 &lt;code&gt;#endif&lt;/code&gt; 지시문에 의해 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="27574a8faae48a163d31765e56cbbeb67aa3ad8a" translate="yes" xml:space="preserve">
          <source>The preprocessor supports text macro replacement and function-like text macro replacement.</source>
          <target state="translated">전처리 기는 텍스트 매크로 교체 및 기능과 유사한 텍스트 매크로 교체를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="f3d1a0ebd42aa1b39b4a03a00bbf88d9f00ef744" translate="yes" xml:space="preserve">
          <source>The previous value held by the atomic flag pointed to by &lt;code&gt;obj&lt;/code&gt;.</source>
          <target state="translated">원자 플래그가 보유한 이전 값은 &lt;code&gt;obj&lt;/code&gt; 가 가리 킵니다 .</target>
        </trans-unit>
        <trans-unit id="b415c1df8056a8b60b1fe0e4eaabdb03213a23ff" translate="yes" xml:space="preserve">
          <source>The projection of &lt;code&gt;z&lt;/code&gt; on the Riemann sphere.</source>
          <target state="translated">리만 구체 에서 &lt;code&gt;z&lt;/code&gt; 의 투영 .</target>
        </trans-unit>
        <trans-unit id="39ca745a924bb9137959b139a9ffdc062119f806" translate="yes" xml:space="preserve">
          <source>The qualifiers that appear between &lt;code&gt;*&lt;/code&gt; and the identifier (or other nested declarator) qualify the type of the pointer that is being declared:</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; 와 식별자 (또는 다른 중첩 선언자) 사이에 나타나는 한정자는 선언되는 포인터의 유형을 한정합니다.</target>
        </trans-unit>
        <trans-unit id="e80a3e01ac05bea47ec62aef3af475352cd5d29f" translate="yes" xml:space="preserve">
          <source>The question mark escape sequence &lt;code&gt;\?&lt;/code&gt; is used to prevent &lt;a href=&quot;operator_alternative&quot;&gt;trigraphs&lt;/a&gt; from being interpreted inside string literals: a string such as &lt;code&gt;&quot;??/&quot;&lt;/code&gt; is compiled as &lt;code&gt;&quot;\&quot;&lt;/code&gt;, but if the second question mark is escaped, as in &lt;code&gt;&quot;?\?/&quot;&lt;/code&gt;, it becomes &lt;code&gt;&quot;??/&quot;&lt;/code&gt;</source>
          <target state="translated">물음표 이스케이프 시퀀스 &lt;code&gt;\?&lt;/code&gt; 방지하기 위해 사용 &lt;a href=&quot;operator_alternative&quot;&gt;trigraph를&lt;/a&gt; 문자열 리터럴 내에서 해석되는 것을을 : 같은 문자열 &lt;code&gt;&quot;??/&quot;&lt;/code&gt; 같은 컴파일 &lt;code&gt;&quot;\&quot;&lt;/code&gt; 두 번째 질문 마크가 탈출되는 경우, 그러나 같이 &lt;code&gt;&quot;?\?/&quot;&lt;/code&gt; , 그것은된다 &lt;code&gt;&quot;??/&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="20eb771689c7638596c471df8669135309db406f" translate="yes" xml:space="preserve">
          <source>The quiet NaN value that corresponds to the identifying string &lt;code&gt;arg&lt;/code&gt; or zero if the implementation does not support quiet NaNs.</source>
          <target state="translated">식별 문자열 &lt;code&gt;arg&lt;/code&gt; 에 해당하는 자동 NaN 값 또는 구현에서 자동 NaN을 지원하지 않는 경우 0입니다.</target>
        </trans-unit>
        <trans-unit id="8a3d414a29f86b002434e0375d474e5453d360f9" translate="yes" xml:space="preserve">
          <source>The real part is converted following the rules for the real floating types</source>
          <target state="translated">실수 부분은 실수 부동 유형의 규칙에 따라 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="3d332d998b707cad080166fabcdd3ca82e157e01" translate="yes" xml:space="preserve">
          <source>The real part is discarded</source>
          <target state="translated">실제 부분은 버려집니다</target>
        </trans-unit>
        <trans-unit id="d2fb212acc87955b594f7e2f071c1ac0ec5aa798" translate="yes" xml:space="preserve">
          <source>The real part of &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;z&lt;/code&gt; 의 실제 부분 .</target>
        </trans-unit>
        <trans-unit id="4346c79f063102e016ae364fb68f3f8bb2758d57" translate="yes" xml:space="preserve">
          <source>The real part of the result is determined by the conversion rules for the real floating types</source>
          <target state="translated">결과의 실제 부분은 실제 부동 유형에 대한 변환 규칙에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="3d3101c9f33fc2be7ee330e9f087611a76f132bd" translate="yes" xml:space="preserve">
          <source>The real part of the result is the positive zero</source>
          <target state="translated">결과의 실제 부분은 양의 0입니다.</target>
        </trans-unit>
        <trans-unit id="ad324bd2c8bc22b00758a73ea2fd6b6e48382778" translate="yes" xml:space="preserve">
          <source>The reallocation is done by either:</source>
          <target state="translated">재 할당은 다음 중 하나에 의해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="c91a538270dcd320d3a898adcd71a4e8cf52f99d" translate="yes" xml:space="preserve">
          <source>The reason &lt;code&gt;tss_delete&lt;/code&gt; never calls destructors is that the destructors (called at thread exit) are normally intended to be executed by the same thread that originally set the value (via &lt;code&gt;&lt;a href=&quot;tss_set&quot;&gt;tss_set&lt;/a&gt;&lt;/code&gt;) that the destructor will be dealing with, and may even rely on the values of that or other thread-specific data as seen by that thread. The thread executing &lt;code&gt;tss_delete&lt;/code&gt; has no access to other threads' TSS. Even if it were possible to call the destructor for each thread's own value associated with &lt;code&gt;tss_id&lt;/code&gt;, &lt;code&gt;tss_delete&lt;/code&gt; would have to synchronize with every thread if only to examine whether the value of this TSS in that thread is null (destructors are only called against non-null values).</source>
          <target state="translated">&lt;code&gt;tss_delete&lt;/code&gt; 가 소멸자를 호출하지 않는 이유 는 소멸자 (스레드 종료에서 호출 &lt;code&gt;&lt;a href=&quot;tss_set&quot;&gt;tss_set&lt;/a&gt;&lt;/code&gt; )가 소멸자가 처리 할 값 ( tss_set을 통해 )을 원래 설정 한 동일한 스레드에서 실행되도록 의도 되었기 때문에 값에 의존하기 때문입니다. 해당 스레드에서 볼 수있는 해당 스레드 또는 기타 스레드 특정 데이터 &lt;code&gt;tss_delete&lt;/code&gt; 를 실행하는 스레드 는 다른 스레드의 TSS에 액세스 할 수 없습니다. 그것과 관련된 각 스레드의 고유 값에 대한 소멸자를 호출하는 것이 가능하더라도 &lt;code&gt;tss_id&lt;/code&gt; 을 , &lt;code&gt;tss_delete&lt;/code&gt; 는 해당 스레드에서이 TSS의 값이 null인지 여부를 검사하는 경우에만 모든 스레드와 동기화해야합니다 (소멸자은 null이 아닌에 대해라고 값).</target>
        </trans-unit>
        <trans-unit id="c7248ba66e1897d995063b1acf5aa812b6ba0952" translate="yes" xml:space="preserve">
          <source>The reasoning behind this syntax is that when the identifier declared by the declarator appears in an expression of the same form as the declarator, it would have the type specified by the type specifier sequence.</source>
          <target state="translated">이 구문의 이유는 선언자가 선언 한 식별자가 선언자와 동일한 형식의 표현식으로 나타날 때 형식 지정자 시퀀스에 의해 지정된 형식을 갖기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="2e11489a7a30fc1b23c96dca40b2ff8e966f4c67" translate="yes" xml:space="preserve">
          <source>The related POSIX function &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/popen.html&quot;&gt;popen&lt;/a&gt; makes the output generated by &lt;code&gt;command&lt;/code&gt; available to the caller.</source>
          <target state="translated">관련 POSIX 함수 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/popen.html&quot;&gt;popen&lt;/a&gt; 은 &lt;code&gt;command&lt;/code&gt; 생성 된 출력 을 호출자가 사용할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="882b56e07684c56a82fb47ac99ca4f95e58df12c" translate="yes" xml:space="preserve">
          <source>The related POSIX function &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/popen.html&quot;&gt;popen&lt;/a&gt; makes the output generated by &lt;code&gt;command&lt;/code&gt; available to the caller.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="748eabde86f4be7c00894966086a057656832218" translate="yes" xml:space="preserve">
          <source>The related function &lt;code&gt;&lt;a href=&quot;puts&quot;&gt;puts&lt;/a&gt;&lt;/code&gt; appends a newline character to the output, while &lt;code&gt;fputs&lt;/code&gt; writes the string unmodified.</source>
          <target state="translated">관련 기능 &lt;code&gt;&lt;a href=&quot;puts&quot;&gt;puts&lt;/a&gt;&lt;/code&gt; 동안, 출력에 개행 문자를 추가 &lt;code&gt;fputs&lt;/code&gt; 는 문자열이 수정되지 않은 씁니다.</target>
        </trans-unit>
        <trans-unit id="b4fca208bdd61aeb00fb518a1b586c85e37c17e7" translate="yes" xml:space="preserve">
          <source>The relational operator expressions have the form.</source>
          <target state="translated">관계 연산자 식의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7e9510a237cd6950e335a276b93cd34d804cbc1a" translate="yes" xml:space="preserve">
          <source>The result is</source>
          <target state="translated">결과는</target>
        </trans-unit>
        <trans-unit id="37ef1943a699e87ee70990285ed8c7f6d3a1bc80" translate="yes" xml:space="preserve">
          <source>The result is an integer constant of type &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;size_t&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">결과는 &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;size_t&lt;/a&gt;&lt;/code&gt; 유형의 정수 상수입니다 .</target>
        </trans-unit>
        <trans-unit id="a957f8ea1f391e7935ddb74dad2e1448951ecef7" translate="yes" xml:space="preserve">
          <source>The result may have little or no significance if the magnitude of &lt;code&gt;arg&lt;/code&gt; is large.</source>
          <target state="translated">&lt;code&gt;arg&lt;/code&gt; 의 크기 가 크면 결과에 유의성이 없거나 거의 없을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="622a039faf91ba533c61ef9a103fa3595c187ec2" translate="yes" xml:space="preserve">
          <source>The result of evaluating a floating constant is either the nearest representable value or the larger or smaller representable value immediately adjacent to the nearest representable value, chosen in an implementation-defined manner (in other words, &lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;default rounding direction&lt;/a&gt; during translation is implementation-defined).</source>
          <target state="translated">부동 상수를 평가 한 결과는 구현 정의 방식으로 선택한 가장 가까운 표현 가능 값 또는 가장 가까운 표현 가능 값에 바로 인접한 더 크거나 작은 표현 가능 값입니다 (즉, 변환 중 &lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;기본 반올림 방향&lt;/a&gt; 이 구현 정의 됨) .</target>
        </trans-unit>
        <trans-unit id="95074b83d96838fbb0176f8d997b7f5d8c7e69fb" translate="yes" xml:space="preserve">
          <source>The result of evaluating a hexadecimal floating constant, if FLT_RADIX is 2, is the exact value represented by the floating constant, correctly rounded to the target type.</source>
          <target state="translated">FLT_RADIX가 2 인 경우 16 진 부동 상수를 평가 한 결과는 대상 유형으로 올바르게 반올림 된 부동 상수로 표시된 정확한 값입니다.</target>
        </trans-unit>
        <trans-unit id="b8eb097162eccdf968f91720477290428716a2d9" translate="yes" xml:space="preserve">
          <source>The result of the comparison: &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;*obj&lt;/code&gt; was equal to &lt;code&gt;*exp&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">비교의 결과, &lt;code&gt;true&lt;/code&gt; 경우 &lt;code&gt;*obj&lt;/code&gt; 동등했다 &lt;code&gt;*exp&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="cc90b9c6aca8e99ddaa9a7c76d3df7f7c89550ed" translate="yes" xml:space="preserve">
          <source>The result of the postfix increment and decrement operators is the value of expr.</source>
          <target state="translated">접미사 증가 및 감소 연산자의 결과는 expr의 값입니다.</target>
        </trans-unit>
        <trans-unit id="fe87173b6111d916a794c69de4b3db44d02ad43d" translate="yes" xml:space="preserve">
          <source>The result of the prefix increment operator is the result of adding the value &lt;code&gt;1&lt;/code&gt; to the value of expr: the expression &lt;code&gt;++e&lt;/code&gt; is equivalent to &lt;code&gt;e+=1&lt;/code&gt;. The result of the prefix decrement operator is the result of subtracting the value &lt;code&gt;1&lt;/code&gt; from the value of expr: the expression &lt;code&gt;--e&lt;/code&gt; is equivalent to &lt;code&gt;e-=1&lt;/code&gt;.</source>
          <target state="translated">접두어 증가 연산자의 결과 는 expr 값에 값 &lt;code&gt;1&lt;/code&gt; 을 추가 한 결과입니다 . &lt;code&gt;++e&lt;/code&gt; 표현식 은 &lt;code&gt;e+=1&lt;/code&gt; 과 같습니다 . 접두사 감소 연산자의 결과 는 expr 값에서 값 &lt;code&gt;1&lt;/code&gt; 을 뺀 결과입니다 . 식 &lt;code&gt;--e&lt;/code&gt; 는 &lt;code&gt;e-=1&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="051e09522f14a201c152465dc43e09f778fe0395" translate="yes" xml:space="preserve">
          <source>The result of this conversion may have greater range and precision than its target type indicates (see &lt;code&gt;&lt;a href=&quot;../types/limits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 변환의 결과는 대상 유형이 나타내는 것보다 더 큰 범위와 정밀도를 가질 수 있습니다 ( &lt;code&gt;&lt;a href=&quot;../types/limits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="370e8414fd327899a4b199af9a10f347fd8f9909" translate="yes" xml:space="preserve">
          <source>The result type is determined as follows:</source>
          <target state="translated">결과 유형은 다음과 같이 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="6d0defe1a2c0ecb1ad124d49279ffb47529db4f8" translate="yes" xml:space="preserve">
          <source>The resulting string has the following format:</source>
          <target state="translated">결과 문자열의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="480df78ac4c637eafab6deaf07efb2edc33ecdf4" translate="yes" xml:space="preserve">
          <source>The return type of a function cannot be cvr-qualified: any qualified return type is adjusted to its unqualified version for the purpose of constructing the function type:</source>
          <target state="translated">함수의 반환 유형은 cvr-qualified가 될 수 없습니다. 정규화 된 반환 유형은 함수 유형 구성을 위해 규정되지 않은 버전으로 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="ab7dcf423f1c6746845ea395c4d29680d8249cb3" translate="yes" xml:space="preserve">
          <source>The return type of the function, determined by the type specifier in specifiers-and-qualifiers and possibly modified by the declarator as usual in &lt;a href=&quot;declarations&quot;&gt;declarations&lt;/a&gt;, must be a complete non-array object type or the type &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">지정자 앤 예선 타입 지시자에 의해 결정된 가능성이 평소와 선언자 의해 변경 함수의 리턴 형 &lt;a href=&quot;declarations&quot;&gt;선언은&lt;/a&gt; 완전한 비 배열 객체 유형 또는 유형이어야 &lt;code&gt;void&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be7ba042cf486f9205da2c739695a1dd6890e1f2" translate="yes" xml:space="preserve">
          <source>The returned string must not be modified by the program, but may be overwritten by a subsequent call to the &lt;code&gt;strerror&lt;/code&gt; function. &lt;code&gt;strerror&lt;/code&gt; is not required to be thread-safe. Implementations may be returning different pointers to static read-only string literals or may be returning the same pointer over and over, pointing at a static buffer in which strerror places the string.</source>
          <target state="translated">반환 된 문자열은 프로그램에서 수정해서는 &lt;code&gt;strerror&lt;/code&gt; 이후에 strerror 함수를 호출하면 덮어 쓸 수 있습니다 . &lt;code&gt;strerror&lt;/code&gt; 는 스레드로부터 안전하지 않아도됩니다. 구현시 정적 읽기 전용 문자열 리터럴에 대한 다른 포인터를 반환하거나 strerror가 문자열을 배치하는 정적 버퍼를 가리키는 동일한 포인터를 반복해서 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6cfe8cddaf67890ed027e912f162eac09c9f502" translate="yes" xml:space="preserve">
          <source>The returned value has the same sign as &lt;code&gt;x&lt;/code&gt; and is less or equal to &lt;code&gt;y&lt;/code&gt; in magnitude.</source>
          <target state="translated">반환 된 값은 &lt;code&gt;x&lt;/code&gt; 와 같은 부호를 가지며 크기 가 &lt;code&gt;y&lt;/code&gt; 보다 작거나 같습니다 .</target>
        </trans-unit>
        <trans-unit id="d9cdb2a3429ed04aaceb9e604669e39a56f8c661" translate="yes" xml:space="preserve">
          <source>The returned value is exact (&lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; is never raised) and independent of the current &lt;a href=&quot;../fenv/fe_round&quot;&gt;rounding mode&lt;/a&gt;.</source>
          <target state="translated">반환 된 값은 정확하고 ( &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; 는 발생하지 않음) 현재 &lt;a href=&quot;../fenv/fe_round&quot;&gt;반올림 모드&lt;/a&gt; 와 무관 합니다 .</target>
        </trans-unit>
        <trans-unit id="724b8307d3008dac328f6b273599dff3480427e3" translate="yes" xml:space="preserve">
          <source>The returned value is exact, &lt;a href=&quot;../fenv/fe_round&quot;&gt;the current rounding mode&lt;/a&gt; is ignored</source>
          <target state="translated">반환 된 값이 정확 &lt;a href=&quot;../fenv/fe_round&quot;&gt;하고 현재 반올림 모드&lt;/a&gt; 는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="26627005fd8f0f998000eb5ad42f45195facac69" translate="yes" xml:space="preserve">
          <source>The rounding mode can be changed with &lt;code&gt;&lt;a href=&quot;../../numeric/fenv/feround&quot;&gt;fesetround&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;FLT_ROUNDS&lt;/code&gt; reflects that change.</source>
          <target state="translated">반올림 모드를 변경할 수 있습니다 &lt;code&gt;&lt;a href=&quot;../../numeric/fenv/feround&quot;&gt;fesetround&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;FLT_ROUNDS&lt;/code&gt; 는 그 변화를 반영한다.</target>
        </trans-unit>
        <trans-unit id="1208e3c0bd83fd14a6cdf867c21125c8a325392a" translate="yes" xml:space="preserve">
          <source>The same function may be registered more than once.</source>
          <target state="translated">동일한 기능이 두 번 이상 등록 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36cca19123f3e3aecba38855a6236bf8a3be39e0" translate="yes" xml:space="preserve">
          <source>The scope of a name introduced in the parameter list of a &lt;a href=&quot;function_declaration&quot;&gt;function declaration&lt;/a&gt; that is not a definition ends at the end of the function &lt;a href=&quot;declarations&quot;&gt;declarator&lt;/a&gt;.</source>
          <target state="translated">이름의 범위 (A)의 파라미터리스트 도입 &lt;a href=&quot;function_declaration&quot;&gt;함수 선언&lt;/a&gt; 되지 정의 단부 함수의 끝에 &lt;a href=&quot;declarations&quot;&gt;선언자&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="08f9e9e6e1ccdae243de6a8dd152c835a4814d19" translate="yes" xml:space="preserve">
          <source>The scope of any identifier declared inside a &lt;a href=&quot;statements#Compound_statements&quot;&gt;compound statement&lt;/a&gt;, including function bodies, or in any expression, declaration, or statement appearing in &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt;, &lt;a href=&quot;switch&quot;&gt;switch&lt;/a&gt;, &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt;, &lt;a href=&quot;while&quot;&gt;while&lt;/a&gt;, or &lt;a href=&quot;do&quot;&gt;do-while&lt;/a&gt; statement(since C99), or within the parameter list of a &lt;a href=&quot;function_definition&quot;&gt;function definition&lt;/a&gt; begins at the point of declaration and ends at the end of the block or statement in which it was declared.</source>
          <target state="translated">함수 본문을 포함 하여 &lt;a href=&quot;statements#Compound_statements&quot;&gt;복합 명령문&lt;/a&gt; 내에 선언되거나 &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt; , &lt;a href=&quot;switch&quot;&gt;switch&lt;/a&gt; , &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt; , &lt;a href=&quot;while&quot;&gt;while&lt;/a&gt; 또는 &lt;a href=&quot;do&quot;&gt;do-while&lt;/a&gt; 명령문 (C99 이후) 또는 &lt;a href=&quot;function_definition&quot;&gt;함수 정의&lt;/a&gt; 가 선언 된 블록 또는 문장의 끝에서 선언되고 끝나는 시점에서 시작한다.</target>
        </trans-unit>
        <trans-unit id="0da26ef01f7800f45aa5282d2dba502de493ec7e" translate="yes" xml:space="preserve">
          <source>The scope of any identifier declared outside of any block or parameter list begins at the point of declaration and ends at the end of the translation unit.</source>
          <target state="translated">블록 또는 매개 변수 목록 외부에서 선언 된 식별자의 범위는 선언 지점에서 시작하여 변환 단위의 끝에서 끝납니다.</target>
        </trans-unit>
        <trans-unit id="1a55802911a29a7c84471e338e2b3d8f2f2258f6" translate="yes" xml:space="preserve">
          <source>The scope of any other identifier begins just after the end of its declarator and before the initializer, if any:</source>
          <target state="translated">다른 식별자의 범위는 선언자의 끝 직후와 이니셜 라이저 전에 시작됩니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="cc8bc4ca47ab86782b6ebc508ebe6dfdcefc5516" translate="yes" xml:space="preserve">
          <source>The scope of enumeration constant begins immediately after the appearance of its defining enumerator in an enumerator list.</source>
          <target state="translated">열거 상수의 범위는 열거 목록에 정의 열거자가 나타난 직후에 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="57eacece4f9fbc810d3e12053a65d86114435d0a" translate="yes" xml:space="preserve">
          <source>The scope of structure, union, and enumeration tags begins immediately after the appearance of the tag in a type specifier that declares the tag.</source>
          <target state="translated">구조, 공용체 및 열거 태그의 범위는 태그를 선언하는 유형 지정자에서 태그가 나타난 직후에 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="1e1af425a408607461b9f2fb850e37301a9a085a" translate="yes" xml:space="preserve">
          <source>The scope of the aliasing assertion made by a restrict-qualified pointer that is a member of a struct is the scope of the identifier used to access the struct.</source>
          <target state="translated">구조체의 멤버 인 제한 한정 포인터로 만든 별칭 어설 션의 범위는 구조체에 액세스하는 데 사용되는 식별자의 범위입니다.</target>
        </trans-unit>
        <trans-unit id="7a691571a758bb7696344431b9bfb2790b337304" translate="yes" xml:space="preserve">
          <source>The selection statements choose between one of several statements depending on the value of an expression.</source>
          <target state="translated">선택문은 표현식의 값에 따라 여러 명령문 중 하나를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="6f77a16398df99646e30617c7408e24bfd96747a" translate="yes" xml:space="preserve">
          <source>The semantics of &lt;a href=&quot;const&quot;&gt;const&lt;/a&gt;/&lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt;/&lt;a href=&quot;restrict&quot;&gt;restrict&lt;/a&gt;-qualifiers and &lt;a href=&quot;atomic&quot;&gt;atomic&lt;/a&gt; types apply to lvalues only (lvalue conversion strips the qualifiers and removes atomicity).</source>
          <target state="translated">의 의미 &lt;a href=&quot;const&quot;&gt;CONST&lt;/a&gt; / &lt;a href=&quot;volatile&quot;&gt;휘발성&lt;/a&gt; / &lt;a href=&quot;restrict&quot;&gt;제한&lt;/a&gt; -qualifiers 및 &lt;a href=&quot;atomic&quot;&gt;원자&lt;/a&gt; 유형은 (좌변 변환 한정어 및 제거합니다 자성 스트립) lvalues 적용된다.</target>
        </trans-unit>
        <trans-unit id="e3b735a300b426d2245b4cf296a3150fc21a63b1" translate="yes" xml:space="preserve">
          <source>The set of valid values for base is {0,2,3,...,36}. The set of valid digits for base-2 integers is &lt;code&gt;{0,1&lt;/code&gt;}, for base-3 integers is &lt;code&gt;{0,1,2&lt;/code&gt;}, and so on. For bases larger than &lt;code&gt;10&lt;/code&gt;, valid digits include alphabetic characters, starting from &lt;code&gt;Aa&lt;/code&gt; for base-11 integer, to &lt;code&gt;Zz&lt;/code&gt; for base-36 integer. The case of the characters is ignored.</source>
          <target state="translated">base에 유효한 값 세트는 {0,2,3, ..., 36}입니다. 기수 -2 정수의 유효한 자릿수는 &lt;code&gt;{0,1&lt;/code&gt; }이고 기수 -3 정수의 경우 &lt;code&gt;{0,1,2&lt;/code&gt; } 등입니다. &lt;code&gt;10&lt;/code&gt; 보다 큰 밑수의 경우 유효한 숫자에는 11 진수의 경우 &lt;code&gt;Aa&lt;/code&gt; 에서 36 자리의 정수의 경우 &lt;code&gt;Zz&lt;/code&gt; 까지의 알파벳 문자가 포함됩니다 . 문자의 경우는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="017c5419328af904a55edc0a14ee95f01cd1e984" translate="yes" xml:space="preserve">
          <source>The side effect of updating lhs is &lt;a href=&quot;eval_order&quot;&gt;sequenced after&lt;/a&gt; the value computations, but not the side effects of lhs and rhs themselves and the evaluations of the operands are, as usual, unsequenced relative to each other (so the expressions such as &lt;code&gt;i=++i&lt;/code&gt;; are undefined).</source>
          <target state="translated">lhs 업데이트의 부작용 은 값 계산 &lt;a href=&quot;eval_order&quot;&gt;후에 순서화&lt;/a&gt; 되지만 lhs 및 rhs 자체의 부작용은 아니며 피연산자의 평가는 평소와 같이 서로에 대해 순서가 지정되지 않습니다 (따라서 &lt;code&gt;i=++i&lt;/code&gt; 와 같은 표현식) ; 정의되지 않음).</target>
        </trans-unit>
        <trans-unit id="aa84b13f6c6f705a05056a0bda3d55f618faac49" translate="yes" xml:space="preserve">
          <source>The sign of the remainder is defined in such a way that if the quotient &lt;code&gt;a/b&lt;/code&gt; is representable in the result type, then &lt;code&gt;(a/b)*b + a%b == a&lt;/code&gt;.</source>
          <target state="translated">나머지의 부호는 몫 &lt;code&gt;a/b&lt;/code&gt; 가 결과 유형으로 표현 가능하면 &lt;code&gt;(a/b)*b + a%b == a&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="35d03624f1f46c34b182260c7be6e91d340366f1" translate="yes" xml:space="preserve">
          <source>The sign of the result is the sign of the difference between the values of the first pair of bytes (both interpreted as &lt;code&gt;unsigned char&lt;/code&gt;) that differ in the objects being compared.</source>
          <target state="translated">결과의 부호는 비교되는 객체가 다른 첫 번째 바이트 쌍 ( &lt;code&gt;unsigned char&lt;/code&gt; 로 해석 됨 ) 의 값 차이의 부호입니다 .</target>
        </trans-unit>
        <trans-unit id="bdf14ae5b468472769becbdbf9c46a2eef5effb8" translate="yes" xml:space="preserve">
          <source>The sign of the result is the sign of the difference between the values of the first pair of characters (both interpreted as &lt;code&gt;unsigned char&lt;/code&gt;) that differ in the arrays being compared.</source>
          <target state="translated">결과의 부호는 비교할 배열이 다른 첫 번째 문자 쌍 ( &lt;code&gt;unsigned char&lt;/code&gt; 로 해석 됨 ) 의 값 차이의 부호입니다 .</target>
        </trans-unit>
        <trans-unit id="e97cc12d1f3f2487de1b90ed0cc2090797374f8e" translate="yes" xml:space="preserve">
          <source>The sign of the result is the sign of the difference between the values of the first pair of characters (both interpreted as &lt;code&gt;unsigned char&lt;/code&gt;) that differ in the strings being compared.</source>
          <target state="translated">결과의 부호는 비교되는 문자열이 다른 첫 번째 문자 쌍 ( &lt;code&gt;unsigned char&lt;/code&gt; 로 해석 됨 ) 의 값 차이의 부호입니다 .</target>
        </trans-unit>
        <trans-unit id="cde6f3dc011075607068991f0904ec95fd72723b" translate="yes" xml:space="preserve">
          <source>The sign of the result is the sign of the difference between the values of the first pair of wide characters that differ in the arrays being compared.</source>
          <target state="translated">결과의 부호는 비교할 배열이 다른 첫 번째 넓은 문자 쌍의 값 사이의 차이의 부호입니다.</target>
        </trans-unit>
        <trans-unit id="f67aeb4832459c9bfc7aeb9f457a87aa921f1247" translate="yes" xml:space="preserve">
          <source>The sign of the result is the sign of the difference between the values of the first pair of wide characters that differ in the strings being compared.</source>
          <target state="translated">결과의 부호는 비교되는 문자열이 다른 첫 번째 넓은 문자 쌍의 값 차이의 부호입니다.</target>
        </trans-unit>
        <trans-unit id="4d5cf620ffd0c069fb09e6109069ba28e165d978" translate="yes" xml:space="preserve">
          <source>The signature of the comparison function should be equivalent to the following:</source>
          <target state="translated">비교 함수의 서명은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="cc273ef773a3a7c0899e6fca6178c1d007bc2d9a" translate="yes" xml:space="preserve">
          <source>The simple assignment operator expressions have the form.</source>
          <target state="translated">간단한 대입 연산자 식의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d18977a380068b230c78baa2354437eff8114c95" translate="yes" xml:space="preserve">
          <source>The sine is an entire function on the complex plane, and has no branch cuts.  Mathematical definition of the sine is sin z =</source>
          <target state="translated">사인은 복잡한 평면에서 전체 기능이며 분기 컷이 없습니다. 사인의 수학적 정의는 sin z =</target>
        </trans-unit>
        <trans-unit id="17ebf122a1a6ba9d02af71043c41ad40d0313167" translate="yes" xml:space="preserve">
          <source>The size of a  non-VLA(since C99) array</source>
          <target state="translated">비 VLA (C99 이후) 배열의 크기</target>
        </trans-unit>
        <trans-unit id="f653bb8a005764d6896a4c10b9fa21fa24e60bf7" translate="yes" xml:space="preserve">
          <source>The size of a &lt;a href=&quot;bit_field&quot;&gt;bit field&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;bit_field&quot;&gt;비트 필드&lt;/a&gt; 의 크기입니다 .</target>
        </trans-unit>
        <trans-unit id="e75b385c7daf43a9926f6adaeac9cb65f13d6dfe" translate="yes" xml:space="preserve">
          <source>The size of the array pointed to by &lt;code&gt;argv&lt;/code&gt; is at least &lt;code&gt;argc+1&lt;/code&gt;, and the last element, &lt;code&gt;argv[argc]&lt;/code&gt;, is guaranteed to be a null pointer.</source>
          <target state="translated">&lt;code&gt;argv&lt;/code&gt; 가 가리키는 배열의 크기는 적어도 &lt;code&gt;argc+1&lt;/code&gt; 이며 마지막 요소 인 &lt;code&gt;argv[argc]&lt;/code&gt; 는 null 포인터임을 보증합니다.</target>
        </trans-unit>
        <trans-unit id="3facb159d302e57398e2b32d50c748002ccee995" translate="yes" xml:space="preserve">
          <source>The size of the pushback buffer varies in practice from 4k (Linux, MacOS) to as little as 4 (Solaris) or the guaranteed minimum 1 (HPUX, AIX).</source>
          <target state="translated">푸시 백 버퍼의 크기는 실제로 4k (Linux, MacOS)에서 최소 4 (Solaris) 또는 보장 된 최소 1 (HPUX, AIX)까지 다양합니다.</target>
        </trans-unit>
        <trans-unit id="1f06f6c9c240dd4e69a113d08da04d2bb7994431" translate="yes" xml:space="preserve">
          <source>The sleep may resume earlier if a &lt;code&gt;&lt;a href=&quot;../program/signal&quot;&gt;signal&lt;/a&gt;&lt;/code&gt; that is not ignored is received. In such case, if &lt;code&gt;remaining&lt;/code&gt; is not &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, the remaining time duration is stored into the object pointed to by &lt;code&gt;remaining&lt;/code&gt;.</source>
          <target state="translated">무시되지 않은 &lt;code&gt;&lt;a href=&quot;../program/signal&quot;&gt;signal&lt;/a&gt;&lt;/code&gt; 가 수신 되면 수면이 더 일찍 재개 될 수 있습니다 . 경우 이러한 경우에, &lt;code&gt;remaining&lt;/code&gt; 하지 &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 객체가 가리키는으로, 남은 시간 기간은 저장되어 &lt;code&gt;remaining&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c68bd152d82f0003bda7516721387df0de4bf1c" translate="yes" xml:space="preserve">
          <source>The sole exception to the maximal munch rule is:</source>
          <target state="translated">최대 뭉크 규칙에 대한 유일한 예외는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2cb0a56eaaaa4fbc79add39c3ae2bbcedba7c991" translate="yes" xml:space="preserve">
          <source>The special</source>
          <target state="translated">스페셜</target>
        </trans-unit>
        <trans-unit id="e98e17952a5eb1144c7a18093ec87f2dc42631df" translate="yes" xml:space="preserve">
          <source>The standard &lt;a href=&quot;../preprocessor/impl&quot;&gt;#pragmas&lt;/a&gt;&lt;code&gt;FENV_ACCESS&lt;/code&gt;, &lt;code&gt;FP_CONTRACT&lt;/code&gt;, and &lt;code&gt;CX_LIMITED_RANGE&lt;/code&gt; as well as the &lt;a href=&quot;../types/limits/flt_eval_method&quot;&gt;floating-point evaluation precision&lt;/a&gt; and &lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;rounding direction&lt;/a&gt; control the way floating-point expressions are executed.</source>
          <target state="translated">표준 &lt;a href=&quot;../preprocessor/impl&quot;&gt;#pragmas &lt;/a&gt; &lt;code&gt;FENV_ACCESS&lt;/code&gt; , &lt;code&gt;FP_CONTRACT&lt;/code&gt; 및 &lt;code&gt;CX_LIMITED_RANGE&lt;/code&gt; 는 물론 &lt;a href=&quot;../types/limits/flt_eval_method&quot;&gt;부동 소수점 평가 정밀도&lt;/a&gt; 및 &lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;반올림 방향&lt;/a&gt; 은 부동 소수점식이 실행되는 방식을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="0875738ad89941cbe8ee8aded99ef6d23319611f" translate="yes" xml:space="preserve">
          <source>The standard does not define any minimum implementation limit on translation units. A hosted environment has an operating system; a freestanding environment does not. A program running in a hosted environment may use all features described in the library clause (clause 7); a program running in a freestanding environment may use a subset of library features required by clause 4.</source>
          <target state="translated">이 표준은 번역 단위에 대한 최소 구현 제한을 정의하지 않습니다. 호스팅 된 환경에는 운영 체제가 있습니다. 독립 환경은 그렇지 않습니다. 호스팅 환경에서 실행되는 프로그램은 라이브러리 조항 (7 항)에 설명 된 모든 기능을 사용할 수 있습니다. 독립 환경에서 실행되는 프로그램은 조항 4에 필요한 라이브러리 기능의 서브 세트를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ea76ab6562da741fc1f1f80fa940f195cc6f7f0" translate="yes" xml:space="preserve">
          <source>The standard itself doesn't specify precedence levels. They are derived from the grammar.</source>
          <target state="translated">표준 자체는 우선 순위 수준을 지정하지 않습니다. 그것들은 문법에서 파생됩니다.</target>
        </trans-unit>
        <trans-unit id="0bdb3b500d50c7ecf224dc0445855ec04f49c235" translate="yes" xml:space="preserve">
          <source>The standard library offers convenience typedefs for the &lt;a href=&quot;language/atomic&quot;&gt;core language atomic types&lt;/a&gt;.</source>
          <target state="translated">표준 라이브러리는 &lt;a href=&quot;language/atomic&quot;&gt;핵심 언어 원자 유형에&lt;/a&gt; 편리한 typedef를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="19d78e0ab7d39ff1a14d8db8179cd35f2c750911" translate="yes" xml:space="preserve">
          <source>The standard library provides bounds-checked versions of some existing functions (&lt;code&gt;&lt;a href=&quot;io/gets&quot;&gt;gets_s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;io/fopen&quot;&gt;fopen_s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;io/fprintf&quot;&gt;printf_s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;string/byte/strcpy&quot;&gt;strcpy_s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;string/wide/wcscpy&quot;&gt;wcscpy_s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;string/multibyte/mbstowcs&quot;&gt;mbstowcs_s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;algorithm/qsort&quot;&gt;qsort_s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;program/getenv&quot;&gt;getenv_s&lt;/a&gt;&lt;/code&gt;, etc). This functionality is</source>
          <target state="translated">표준 라이브러리는 일부 기존 함수의 범위 검사 버전 ( &lt;code&gt;&lt;a href=&quot;io/gets&quot;&gt;gets_s&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;io/fopen&quot;&gt;fopen_s&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;io/fprintf&quot;&gt;printf_s&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;string/byte/strcpy&quot;&gt;strcpy_s&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;string/wide/wcscpy&quot;&gt;wcscpy_s&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;string/multibyte/mbstowcs&quot;&gt;mbstowcs_s&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;algorithm/qsort&quot;&gt;qsort_s&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;program/getenv&quot;&gt;getenv_s&lt;/a&gt;&lt;/code&gt; 등)을 제공합니다. 이 기능은</target>
        </trans-unit>
        <trans-unit id="2ac1ff28429f739a4cc4c3cff8e4e5165e074955" translate="yes" xml:space="preserve">
          <source>The standard uses the term</source>
          <target state="translated">표준은 용어를 사용합니다</target>
        </trans-unit>
        <trans-unit id="0a3c7c787747b239e731a6608e43e2c196135b2e" translate="yes" xml:space="preserve">
          <source>The strings are modifiable, and any modifications made persist until program termination, although these modifications do not propagate back to the host environment: they can be used, for example, with &lt;code&gt;&lt;a href=&quot;../string/byte/strtok&quot;&gt;strtok&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">문자열은 수정 가능하며 모든 수정은 프로그램 종료까지 지속되지만 이러한 수정은 호스트 환경으로 다시 전파되지 않습니다 . 예를 들어 &lt;code&gt;&lt;a href=&quot;../string/byte/strtok&quot;&gt;strtok&lt;/a&gt;&lt;/code&gt; 과 함께 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a9716a65dc5ff30cff1eae2da273ac1d3064db74" translate="yes" xml:space="preserve">
          <source>The struct &lt;code&gt;lconv&lt;/code&gt; contains numeric and monetary formatting rules as defined by a C locale. Objects of this struct may be obtained with &lt;code&gt;&lt;a href=&quot;localeconv&quot;&gt;localeconv&lt;/a&gt;&lt;/code&gt;. The members of &lt;code&gt;lconv&lt;/code&gt; are values of type &lt;code&gt;char&lt;/code&gt; and of type &lt;code&gt;char*&lt;/code&gt;. Each &lt;code&gt;char*&lt;/code&gt; member except &lt;code&gt;decimal_point&lt;/code&gt; may be pointing at a null character (that is, at an empty C-string). The members of type &lt;code&gt;char&lt;/code&gt; are all non-negative numbers, any of which may be &lt;code&gt;&lt;a href=&quot;../types/limits&quot;&gt;CHAR_MAX&lt;/a&gt;&lt;/code&gt; if the corresponding value is not available in the current C locale.</source>
          <target state="translated">struct &lt;code&gt;lconv&lt;/code&gt; 는 C 로케일로 정의 된 숫자 및 통화 형식화 규칙을 포함합니다. 이 구조체의 객체는 &lt;code&gt;&lt;a href=&quot;localeconv&quot;&gt;localeconv&lt;/a&gt;&lt;/code&gt; 로 얻을 수 있습니다 . &lt;code&gt;lconv&lt;/code&gt; 의 멤버는 &lt;code&gt;char&lt;/code&gt; 유형 및 &lt;code&gt;char*&lt;/code&gt; 유형의 값입니다 . &lt;code&gt;decimal_point&lt;/code&gt; 를 제외한 각 &lt;code&gt;char*&lt;/code&gt; 멤버 는 null 문자 (즉, 빈 C- 문자열)를 가리킬 수 있습니다. &lt;code&gt;char&lt;/code&gt; 유형의 멤버 는 모두 음수가 아닌 숫자이며 , 현재 C 로케일에서 해당 값을 사용할 수없는 경우 &lt;code&gt;&lt;a href=&quot;../types/limits&quot;&gt;CHAR_MAX&lt;/a&gt;&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bb3a4a16886cf1ac48a851932de21f81c40cea6b" translate="yes" xml:space="preserve">
          <source>The style used to print a NaN is implementation defined.</source>
          <target state="translated">NaN을 인쇄하는 데 사용되는 스타일은 구현 정의입니다.</target>
        </trans-unit>
        <trans-unit id="21517d748a5bfd69cdd8f8ab9d477a543e017a3d" translate="yes" xml:space="preserve">
          <source>The style used to print an infinity is implementation defined.</source>
          <target state="translated">무한대를 인쇄하는 데 사용되는 스타일은 구현 정의입니다.</target>
        </trans-unit>
        <trans-unit id="ad5440ec13a92105f54304efe3535cd3756f2e59" translate="yes" xml:space="preserve">
          <source>The subscript operator expression is an &lt;a href=&quot;value_category&quot;&gt;lvalue expression&lt;/a&gt; whose type is the type of the object pointed to by pointer-expression.</source>
          <target state="translated">아래 첨자 연산자 표현식은 type이 pointer-expression이 가리키는 오브젝트의 유형 인 &lt;a href=&quot;value_category&quot;&gt;lvalue 표현식&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1a8e214981c3b158eea8b2d5e47dd47f41913a7c" translate="yes" xml:space="preserve">
          <source>The sum of the returned value and the value stored in &lt;code&gt;*iptr&lt;/code&gt; gives &lt;code&gt;arg&lt;/code&gt; (allowing for rounding).</source>
          <target state="translated">리턴 된 값과 &lt;code&gt;*iptr&lt;/code&gt; 에 저장된 값의 합 은 &lt;code&gt;arg&lt;/code&gt; (반올림 허용)를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="21c84344f10b85ba83941112b65c0b80df28cba9" translate="yes" xml:space="preserve">
          <source>The synchronization is established only between the threads</source>
          <target state="translated">스레드간에 만 동기화가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="a1fafb7379abc511f3f59880d1048edc9085d42e" translate="yes" xml:space="preserve">
          <source>The syntax of a function-like macro invocation is similar to the syntax of a function call: each instance of the macro name followed by a ( as the next preprocessing token introduces the sequence of tokens that is replaced by the replacement-list. The sequence is terminated by the matching ) token, skipping intervening matched pairs of left and right parentheses.</source>
          <target state="translated">함수와 유사한 매크로 호출의 구문은 함수 호출의 구문과 유사합니다. 매크로 이름의 각 인스턴스 뒤에 (다음 전처리 토큰이 대체 목록으로 대체되는 토큰 시퀀스를 소개하므로) 일치하는) 토큰으로 종료되고 일치하는 왼쪽 및 오른쪽 괄호 쌍을 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="927fb804cb2eaeff9acfcfdf70d5c596b423f6da" translate="yes" xml:space="preserve">
          <source>The temporary file created by this function is closed and deleted when the program exits normally. Whether it's deleted on abnormal termination is implementation-defined.</source>
          <target state="translated">이 기능으로 생성 된 임시 파일은 프로그램이 정상적으로 종료되면 닫히고 삭제됩니다. 비정상 종료시 삭제 여부는 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="d35cf85afe81dba05bfcd30078a13ec4b61a6248" translate="yes" xml:space="preserve">
          <source>The terminating null character from &lt;code&gt;str&lt;/code&gt; is not written.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 의 종료 널 문자 는 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7e942509d6816ccf9d123b1cf1595fd4cb7dbdb4" translate="yes" xml:space="preserve">
          <source>The terminating null wide character from &lt;code&gt;str&lt;/code&gt; is not written.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 의 종료 널 와이드 문자 는 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="241931c273ba7378188c003511f787a3f07e8c4b" translate="yes" xml:space="preserve">
          <source>The termination of the thread</source>
          <target state="translated">스레드 종료</target>
        </trans-unit>
        <trans-unit id="dd5115b93d33b078df682a05c54e3833b8a2ca89" translate="yes" xml:space="preserve">
          <source>The thread identifiers may be reused for new threads once the thread has finished and joined or detached.</source>
          <target state="translated">스레드 식별자는 스레드가 완료되고 결합되거나 분리되면 새 스레드에 재사용 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1296acc3dd7bffb8fff38e6c9ab05728e64b068e" translate="yes" xml:space="preserve">
          <source>The three complex types are.</source>
          <target state="translated">세 가지 복잡한 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="37b60758934aabf8d3da266bd1b4b57e82722056" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;&lt;a href=&quot;../thread&quot;&gt;thrd_start_t&lt;/a&gt;&lt;/code&gt; is a typedef of &lt;code&gt;int(*)(void*)&lt;/code&gt;, which differs from the POSIX equivalent &lt;code&gt;void*(*)(void*)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../thread&quot;&gt;thrd_start_t&lt;/a&gt;&lt;/code&gt; 유형 은 &lt;code&gt;int(*)(void*)&lt;/code&gt; 의 typedef이며 POSIX와 동등한 &lt;code&gt;void*(*)(void*)&lt;/code&gt; 와 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="a5d45e719006a644d4efb5b5f7ec023e503421b2" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;char&lt;/code&gt; is not compatible with &lt;code&gt;signed char&lt;/code&gt; and not compatible with &lt;code&gt;unsigned char&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; 유형 은 &lt;code&gt;signed char&lt;/code&gt; 와 호환되지 않으며 &lt;code&gt;unsigned char&lt;/code&gt; 와 호환되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="18f576269346b3fd8946fd4e3da2eb80a4056c88" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;mbstate_t&lt;/code&gt; is a trivial non-array type that can represent any of the conversion states that can occur in an implementation-defined set of supported multibyte character encoding rules. Zero-initialized value of &lt;code&gt;mbstate_t&lt;/code&gt; represents the initial conversion state, although other values of &lt;code&gt;mbstate_t&lt;/code&gt; may exist that also represent the initial conversion state.</source>
          <target state="translated">타입 &lt;code&gt;mbstate_t&lt;/code&gt; 는 지원 멀티 바이트 문자 인코딩 규칙의 구현 정의 세트에서 발생할 수있는 변환의 상태 중 하나를 나타낼 수있는 사소한 비 어레이 형이다. &lt;code&gt;mbstate_t&lt;/code&gt; 의 0으로 초기화 된 값은 초기 변환 상태를 나타내지 만, &lt;code&gt;mbstate_t&lt;/code&gt; 의 다른 값은 초기 변환 상태를 나타내기도합니다.</target>
        </trans-unit>
        <trans-unit id="bc4d74ec38eba7b867e7d4d689b5241938a4d1b3" translate="yes" xml:space="preserve">
          <source>The type after conversion is compared with type-names from the list of associations.</source>
          <target state="translated">변환 후 유형은 연관 목록의 유형 이름과 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="83ef2bff6850ff84da9eceaeb8081fce468a3423" translate="yes" xml:space="preserve">
          <source>The type of any equality operator expression is &lt;code&gt;int&lt;/code&gt;, and its value (which is not an lvalue) is &lt;code&gt;1&lt;/code&gt; when the specified relationship holds true and &lt;code&gt;​0​&lt;/code&gt; when the specified relationship does not hold.</source>
          <target state="translated">어떤 항등 연산자 표현식의 타입이 &lt;code&gt;int&lt;/code&gt; , 그 값은 (좌변는되지 않음) 인 &lt;code&gt;1&lt;/code&gt; 지정된 관계가 성립 때 &lt;code&gt;​0​&lt;/code&gt; 지정된 관계는 유지되지 않는다.</target>
        </trans-unit>
        <trans-unit id="d31a9fe37a49aeb320a1d46d51c8f069e7627c13" translate="yes" xml:space="preserve">
          <source>The type of any relational operator expression is &lt;code&gt;int&lt;/code&gt;, and its value (which is not an lvalue) is &lt;code&gt;1&lt;/code&gt; when the specified relationship holds true and &lt;code&gt;​0​&lt;/code&gt; when the specified relationship does not hold.</source>
          <target state="translated">관계형 오퍼레이터 식의 형태는 &lt;code&gt;int&lt;/code&gt; , 그 값은 (좌변는되지 않음) 인 &lt;code&gt;1&lt;/code&gt; 지정된 관계가 성립 할 때와 &lt;code&gt;​0​&lt;/code&gt; 지정된 관계가 유지되지 않는 경우.</target>
        </trans-unit>
        <trans-unit id="811237a08cfbebd18d4367ab827711b9115f6d3d" translate="yes" xml:space="preserve">
          <source>The type of each identifier introduced in a declaration is determined by a combination of the type specified by the type specifier and the type modifications applied by its declarator.</source>
          <target state="translated">선언에 도입 된 각 식별자의 타입은 타입 지정자에 의해 지정된 타입과 선언자에 의해 적용된 타입 수정의 조합에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="d71eed56481373e458e0b94319f5f5bf3221d2ca" translate="yes" xml:space="preserve">
          <source>The type of the compound literal is type (except when type is an array of unknown size; its size is deduced from the initializer-list as in &lt;a href=&quot;array_initialization&quot;&gt;array initialization&lt;/a&gt;).</source>
          <target state="translated">복합 리터럴의 유형은 유형입니다 (유형이 알 수없는 크기의 배열 인 경우 제외; 크기는 &lt;a href=&quot;array_initialization&quot;&gt;배열 초기화&lt;/a&gt; 에서와 같이 초기화 목록에서 추론 됨 ).</target>
        </trans-unit>
        <trans-unit id="63e1afdcfba845cebcfec884ec5a8ac155768c26" translate="yes" xml:space="preserve">
          <source>The type of the expression is the type after promotion, and the &lt;a href=&quot;value_category&quot;&gt;value category&lt;/a&gt; is non-lvalue.</source>
          <target state="translated">표현식의 유형은 승격 후 유형이며 &lt;a href=&quot;value_category&quot;&gt;값 카테고리&lt;/a&gt; 는 lvalue가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e98e4102e24f34077fe9171371257f25c10edbfd" translate="yes" xml:space="preserve">
          <source>The type of the integer constant</source>
          <target state="translated">정수 상수의 유형</target>
        </trans-unit>
        <trans-unit id="2680965a70e519d3207938fce242cd69e5be4916" translate="yes" xml:space="preserve">
          <source>The type of the integer constant is the first type in which the value can fit, from the list of types which depends on which numeric base and which integer-suffix was used.</source>
          <target state="translated">정수 상수의 유형은 사용 된 숫자 기반과 정수 접미사에 따라 유형 목록에서 값이 들어갈 수있는 첫 번째 유형입니다.</target>
        </trans-unit>
        <trans-unit id="829b1b1c6864595e1de1d8e5d9152081192a921a" translate="yes" xml:space="preserve">
          <source>The type of the lhs may be &lt;code&gt;void&lt;/code&gt; (that is, it may be a call to a function that returns &lt;code&gt;void&lt;/code&gt;, or it can be an expression &lt;a href=&quot;cast&quot;&gt;cast&lt;/a&gt; to &lt;code&gt;void&lt;/code&gt;).</source>
          <target state="translated">좌변의 형태 일 수있다 &lt;code&gt;void&lt;/code&gt; (즉, 그것이 그 반환하는 함수를 호출 할 수있다 &lt;code&gt;void&lt;/code&gt; , 또는 발현 될 수 &lt;a href=&quot;cast&quot;&gt;캐스트&lt;/a&gt; 에 &lt;code&gt;void&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="447849d54c1d67d6b61329201208de7c3155cd27" translate="yes" xml:space="preserve">
          <source>The type representing all floating-point status flags collectively</source>
          <target state="translated">모든 부동 소수점 상태 플래그를 집합 적으로 나타내는 유형</target>
        </trans-unit>
        <trans-unit id="66cad8bd68a6349c324c8b818f25bd23910481f3" translate="yes" xml:space="preserve">
          <source>The type representing the entire floating-point environment</source>
          <target state="translated">전체 부동 소수점 환경을 나타내는 유형</target>
        </trans-unit>
        <trans-unit id="0cffaa40c40ebaf49e36b504549168d080b200aa" translate="yes" xml:space="preserve">
          <source>The type-generic macros are as follows:</source>
          <target state="translated">유형이 일반적인 매크로는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3596eb5ea91c2633e1f6227c5debdbd1c9d68bf6" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; are compatible, if.</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 와 &lt;code&gt;U&lt;/code&gt; 는 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="ac4bdd032acdf24d44472ac4ff1c101e18823b80" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;float_t&lt;/code&gt; and &lt;code&gt;double_t&lt;/code&gt; are floating types at least as wide as &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;double&lt;/code&gt;, respectively, and such that &lt;code&gt;double_t&lt;/code&gt; is at least as wide as &lt;code&gt;float_t&lt;/code&gt;. The value of &lt;code&gt;&lt;a href=&quot;../../types/limits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt; determines the types of &lt;code&gt;float_t&lt;/code&gt; and &lt;code&gt;double_t&lt;/code&gt;.</source>
          <target state="translated">종류는 &lt;code&gt;float_t&lt;/code&gt; 및 &lt;code&gt;double_t&lt;/code&gt; 폭만큼 최소한 타입 부동 &lt;code&gt;float&lt;/code&gt; 와 &lt;code&gt;double&lt;/code&gt; 각각 및되도록 &lt;code&gt;double_t&lt;/code&gt; 은 같은 폭으로 적어도하다 &lt;code&gt;float_t&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;../../types/limits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt; 값은 &lt;code&gt;float_t&lt;/code&gt; 및 &lt;code&gt;double_t&lt;/code&gt; 의 유형을 결정합니다 .</target>
        </trans-unit>
        <trans-unit id="8b6e26a516b34b7af57fc7012be60e25328df076" translate="yes" xml:space="preserve">
          <source>The unary arithmetic operator expressions have the form.</source>
          <target state="translated">단항 산술 연산자 식의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1c3a2c1487d550c3fde0d68fbc12ecebb306ba75" translate="yes" xml:space="preserve">
          <source>The unary minus invokes undefined behavior due to signed integer overflow when applied to &lt;code&gt;&lt;a href=&quot;../types/limits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../types/limits&quot;&gt;LONG_MIN&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../types/limits&quot;&gt;LLONG_MIN&lt;/a&gt;&lt;/code&gt;, on typical (2's complement) platforms.</source>
          <target state="translated">단항 빼기는 일반적인 (2의 보수) 플랫폼 에서 &lt;code&gt;&lt;a href=&quot;../types/limits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../types/limits&quot;&gt;LONG_MIN&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../types/limits&quot;&gt;LLONG_MIN&lt;/a&gt;&lt;/code&gt; 에 적용될 때 부호있는 정수 오버플로로 인해 정의되지 않은 동작을 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="f88c0e3c533664fbb73db04c0a5c2f3e03a61631" translate="yes" xml:space="preserve">
          <source>The union is only as big as necessary to hold its largest member (additional unnamed trailing padding may also be added). The other members are allocated in the same bytes as part of that largest member.</source>
          <target state="translated">노조는 최대 회원을 유지하는 데 필요한만큼만 규모가 커집니다 (추가 이름없는 후행 패딩도 추가 될 수 있음). 다른 멤버는 가장 큰 멤버의 일부와 동일한 바이트로 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="9dee7b9a492616febe6c3fc4efadefd3ada5e33b" translate="yes" xml:space="preserve">
          <source>The unnamed object to which the compound literal evaluates has static &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt; if the compound literal occurs at file scope and automatic &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt; if the compound literal occurs at block scope (in which case the object's &lt;a href=&quot;lifetime&quot;&gt;lifetime&lt;/a&gt; ends at the end of the enclosing block).</source>
          <target state="translated">복합 리터럴이 평가하는 이름이없는 오브젝트 는 파일 리터럴에서 복합 리터럴이 발생하면 정적 &lt;a href=&quot;storage_duration&quot;&gt;저장 기간을&lt;/a&gt; , 블록 리터럴에서 복합 리터럴이 발생하면 자동 &lt;a href=&quot;storage_duration&quot;&gt;저장 기간을&lt;/a&gt; 갖습니다 (이 경우 오브젝트의 &lt;a href=&quot;lifetime&quot;&gt;수명&lt;/a&gt; 이 둘러싸는 블록의 끝에서 종료 됨).</target>
        </trans-unit>
        <trans-unit id="0abb6094d96df27f0d637760f1d1f17013caac08" translate="yes" xml:space="preserve">
          <source>The use of alignof with expressions is allowed by some C compilers as a non-standard extension.</source>
          <target state="translated">일부 C 컴파일러에서는 alignof를 표현식과 함께 사용하여 비표준 확장으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b44666438f2ec28588f661880af1a91734f0eee" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; is associated with the newly created key in all existing threads, and upon thread creation, the values associated with all TSS keys is initialized to &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 값 은 모든 기존 스레드에서 새로 작성된 키와 연관되며 스레드 작성시 모든 TSS 키와 연관된 값은 &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 로 초기화 됩니다 .</target>
        </trans-unit>
        <trans-unit id="a983788a30d253bace1a068a44d1826dc47d6596" translate="yes" xml:space="preserve">
          <source>The value category of a compound literal is &lt;a href=&quot;value_category&quot;&gt;lvalue&lt;/a&gt; (its address can be taken).</source>
          <target state="translated">복합 리터럴의 값 범주는 &lt;a href=&quot;value_category&quot;&gt;lvalue입니다&lt;/a&gt; (주소를 가져올 수 있음).</target>
        </trans-unit>
        <trans-unit id="ae6d7ff00e83423b304179c97fa6160b61c7d16c" translate="yes" xml:space="preserve">
          <source>The value computed by this function is the length of the hypotenuse of a right-angled triangle with sides of length &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, or the distance of the point &lt;code&gt;(x,y)&lt;/code&gt; from the origin &lt;code&gt;(0,0)&lt;/code&gt;, or the magnitude of a complex number &lt;code&gt;x+&lt;i&gt;i&lt;/i&gt;y&lt;/code&gt;.</source>
          <target state="translated">이 함수에 의해 계산 된 값은 길이 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 의 변을 가진 직각 삼각형의 빗변의 길이 또는 원점 &lt;code&gt;(0,0)&lt;/code&gt; 에서 점 &lt;code&gt;(x,y)&lt;/code&gt; 의 거리 또는 복소수 &lt;code&gt;x+&lt;i&gt;i&lt;/i&gt;y&lt;/code&gt; &lt;i&gt;i&lt;/i&gt; y .&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="8db27de9a2c14b5c36e77ac11db7b1e6b539ddf4" translate="yes" xml:space="preserve">
          <source>The value held previously be the atomic object pointed to by &lt;code&gt;obj&lt;/code&gt;.</source>
          <target state="translated">이전에 보유한 값은 &lt;code&gt;obj&lt;/code&gt; 가 가리키는 원자 객체 입니다.</target>
        </trans-unit>
        <trans-unit id="7044fe5027fd6004978c59ea869f2af588568b11" translate="yes" xml:space="preserve">
          <source>The value held previously by the atomic object pointed to by &lt;code&gt;obj&lt;/code&gt;.</source>
          <target state="translated">이전에 &lt;code&gt;obj&lt;/code&gt; 가 가리키는 원자 객체가 보유한 값 입니다.</target>
        </trans-unit>
        <trans-unit id="74363b0d87e71eb3303d92bd255f435d2a3c664f" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;base&lt;/code&gt; if successful, zero otherwise.</source>
          <target state="translated">성공하면 &lt;code&gt;base&lt;/code&gt; 값 , 그렇지 않으면 0</target>
        </trans-unit>
        <trans-unit id="56ee130795a5dbf75897c6a6783296c3ad1b779f" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;errno&lt;/code&gt; is &lt;code&gt;​0​&lt;/code&gt; at program startup, and although library functions are allowed to write positive integers to &lt;code&gt;errno&lt;/code&gt; whether or not an error occurred, library functions never store &lt;code&gt;​0​&lt;/code&gt; in &lt;code&gt;errno&lt;/code&gt;.</source>
          <target state="translated">값 &lt;code&gt;errno&lt;/code&gt; 것이다 &lt;code&gt;​0​&lt;/code&gt; 프로그램을 시작할 때, 라이브러리 함수는 양의 정수로 쓸 수있다하더라도 &lt;code&gt;errno&lt;/code&gt; 에 에러가 발생하는지 여부를, 라이브러리 함수는 결코 저장되지 &lt;code&gt;​0​&lt;/code&gt; 에서 &lt;code&gt;errno&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da2294d8108c3a6f801f89b03514268af0f31351" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;math_errhandling&lt;/code&gt; indicates the type of error handling that is performed by the floating-point operators and &lt;a href=&quot;../math&quot;&gt;functions&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;math_errhandling&lt;/code&gt; 값은 부동 소수점 연산자 및 &lt;a href=&quot;../math&quot;&gt;함수&lt;/a&gt; 가 수행하는 오류 처리 유형을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="3ce421ed8122dc0c953b3daa7401767634d485f5" translate="yes" xml:space="preserve">
          <source>The value of a floating-point static initializer is never less accurate than the value of the same expression executed at run time, but it may be better.</source>
          <target state="translated">부동 소수점 정적 이니셜 라이저의 값은 런타임에 실행 된 동일한 표현식의 값보다 정확하지 않지만 더 나을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="adea83a39e96975099582b35000c5f6ef163b872" translate="yes" xml:space="preserve">
          <source>The value of an &lt;a href=&quot;enum&quot;&gt;enumeration constant&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;enum&quot;&gt;열거 상수&lt;/a&gt; 의 값</target>
        </trans-unit>
        <trans-unit id="2319cb95fe6c4140766f25ba6aceff81797d3bc7" translate="yes" xml:space="preserve">
          <source>The value of the exponent returned by &lt;code&gt;ilogb&lt;/code&gt; is always 1 less than the exponent retuned by &lt;code&gt;&lt;a href=&quot;frexp&quot;&gt;frexp&lt;/a&gt;&lt;/code&gt; because of the different normalization requirements: for the exponent &lt;code&gt;e&lt;/code&gt; returned by &lt;code&gt;ilogb&lt;/code&gt;, |arg*r-e</source>
          <target state="translated">&lt;code&gt;ilogb&lt;/code&gt; 에 의해 리턴 된 지수의 값은 다른 정규화 요구 사항으로 인해 &lt;code&gt;&lt;a href=&quot;frexp&quot;&gt;frexp&lt;/a&gt;&lt;/code&gt; 에 의해 재조정 된 지수보다 항상 1보다 작습니다. &lt;code&gt;ilogb&lt;/code&gt; 에 의해 리턴 된 지수 &lt;code&gt;e&lt;/code&gt; 의 경우 , | arg * re</target>
        </trans-unit>
        <trans-unit id="9ae0f9145d3f54ff503856e7f95a6dee62b616ad" translate="yes" xml:space="preserve">
          <source>The value of the exponent returned by &lt;code&gt;logb&lt;/code&gt; is always 1 less than the exponent retuned by &lt;code&gt;&lt;a href=&quot;frexp&quot;&gt;frexp&lt;/a&gt;&lt;/code&gt; because of the different normalization requirements: for the exponent &lt;code&gt;e&lt;/code&gt; returned by &lt;code&gt;logb&lt;/code&gt;, |arg*r-e</source>
          <target state="translated">&lt;code&gt;logb&lt;/code&gt; 에 의해 리턴 된 지수의 값은 다른 정규화 요구 사항으로 인해 &lt;code&gt;&lt;a href=&quot;frexp&quot;&gt;frexp&lt;/a&gt;&lt;/code&gt; 에 의해 재조정 된 지수보다 항상 1보다 작습니다. &lt;code&gt;logb&lt;/code&gt; 에 의해 리턴 된 지수 &lt;code&gt;e&lt;/code&gt; 의 경우 , | arg * re</target>
        </trans-unit>
        <trans-unit id="1c338856b102032dd7454b82d3852e88916b004c" translate="yes" xml:space="preserve">
          <source>The value on success, &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; on failure.</source>
          <target state="translated">성공시의 값, 실패시 &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cc1839c6dd4f14d95b9fec518dce3cd0ccd9859a" translate="yes" xml:space="preserve">
          <source>The value returned by &lt;code&gt;clock()&lt;/code&gt; may wrap around on some implementations. For example, on a machine with 32-bit &lt;code&gt;&lt;a href=&quot;clock_t&quot;&gt;clock_t&lt;/a&gt;&lt;/code&gt;, it wraps after 2147 seconds or 36 minutes.</source>
          <target state="translated">&lt;code&gt;clock()&lt;/code&gt; 의해 리턴 된 값 은 일부 구현에서 랩 어라운드 될 수 있습니다. 예를 들어 32 비트 &lt;code&gt;&lt;a href=&quot;clock_t&quot;&gt;clock_t&lt;/a&gt;&lt;/code&gt; 가 있는 시스템에서는 2147 초 또는 36 분 후에 랩핑됩니다.</target>
        </trans-unit>
        <trans-unit id="7a76aed414f920671ac2d5636063f80c02930b91" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;p_sep_by_space&lt;/code&gt;, &lt;code&gt;n_sep_by_space&lt;/code&gt;, &lt;code&gt;int_p_sep_by_space&lt;/code&gt;, &lt;code&gt;int_n_sep_by_space&lt;/code&gt; are interpreted as follows:</source>
          <target state="translated">&lt;code&gt;p_sep_by_space&lt;/code&gt; , &lt;code&gt;n_sep_by_space&lt;/code&gt; , &lt;code&gt;int_p_sep_by_space&lt;/code&gt; , &lt;code&gt;int_n_sep_by_space&lt;/code&gt; 의 값은 다음과 같이 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="77672f917a9b339a086c2698e191450e19cf6727" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;p_sign_posn&lt;/code&gt;, &lt;code&gt;n_sign_posn&lt;/code&gt;, &lt;code&gt;int_p_sign_posn&lt;/code&gt;, &lt;code&gt;int_n_sign_posn&lt;/code&gt; are interpreted as follows:</source>
          <target state="translated">&lt;code&gt;p_sign_posn&lt;/code&gt; , &lt;code&gt;n_sign_posn&lt;/code&gt; , &lt;code&gt;int_p_sign_posn&lt;/code&gt; , &lt;code&gt;int_n_sign_posn&lt;/code&gt; 의 값은 다음과 같이 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="e9fe6d1f76a572b29a8d3484a98866cb41ec603b" translate="yes" xml:space="preserve">
          <source>The values of these macros (except for &lt;code&gt;__FILE__&lt;/code&gt; and &lt;code&gt;__LINE__&lt;/code&gt;) remain constant throughout the translation unit. Attempts to redefine or undefine these macros result in undefined behavior.</source>
          <target state="translated">이러한 매크로의 값 ( &lt;code&gt;__FILE__&lt;/code&gt; 및 &lt;code&gt;__LINE__&lt;/code&gt; 제외 )은 변환 단위 전체에서 일정하게 유지됩니다. 이러한 매크로를 재정의하거나 정의를 취소하면 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8eb246d2ead310c8f059b8b86885fc138b2913d2" translate="yes" xml:space="preserve">
          <source>The weak forms ((2) and (4)) of the functions are allowed to fail spuriously, that is, act as if &lt;code&gt;*obj != *expected&lt;/code&gt; even if they are equal. When a compare-and-exchange is in a loop, the weak version will yield better performance on some platforms. When a weak compare-and-exchange would require a loop and a strong one would not, the strong one is preferable.</source>
          <target state="translated">함수의 약한 형태 ((2) 및 (4))는 허위로 실패 할 수 있습니다. 즉, &lt;code&gt;*obj != *expected&lt;/code&gt; 가 같더라도 예상대로 작동 합니다. 비교 및 교환이 반복되는 경우 약한 버전은 일부 플랫폼에서 더 나은 성능을 제공합니다. 약한 비교 및 ​​교환에 루프가 필요하고 강한 루프가 필요하지 않은 경우에는 강한 것이 바람직합니다.</target>
        </trans-unit>
        <trans-unit id="1afb1ba711265f6de0e35e414290ff85c3a2ad0f" translate="yes" xml:space="preserve">
          <source>Then, a &lt;a href=&quot;eval_order&quot;&gt;sequence point&lt;/a&gt; takes place, so that all side effects of lhs are complete.</source>
          <target state="translated">그런 다음 &lt;a href=&quot;eval_order&quot;&gt;시퀀스 포인트&lt;/a&gt; 가 발생하여 lhs의 모든 부작용이 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="cb90fa2576c7925b07f1e1ac9159668e2bf9b053" translate="yes" xml:space="preserve">
          <source>Then, the corresponding binary logic operators are applied bitwise; that is, each bit of the result is set or cleared according to the logic operation (NOT, AND, OR, or XOR), applied to the corresponding bits of the operands.</source>
          <target state="translated">그런 다음 해당 이진 논리 연산자가 비트 단위로 적용됩니다. 즉, 결과의 각 비트는 피연산자의 해당 비트에 적용되는 논리 연산 (NOT, AND, OR 또는 XOR)에 따라 설정되거나 지워집니다.</target>
        </trans-unit>
        <trans-unit id="f7078c4d1c98d55c4bc04aaeacb070077101e980" translate="yes" xml:space="preserve">
          <source>Then, the right operand, rhs, is evaluated and its result is returned by the comma operator as a &lt;a href=&quot;value_category&quot;&gt;non-lvalue&lt;/a&gt;.</source>
          <target state="translated">그런 다음 오른쪽 피연산자 rhs가 평가되고 그 결과는 쉼표 연산자에 의해 &lt;a href=&quot;value_category&quot;&gt;비 lvalue&lt;/a&gt; 로 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="7b3f137a362c8e821a1e6b9a4948bb2c26de27af" translate="yes" xml:space="preserve">
          <source>There are alternative spellings for the operators that use non-ISO646 characters, defined in &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt; as macros:</source>
          <target state="translated">&lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt; 에 매크로로 정의 된 비 ISO646 문자를 사용하는 연산자에 대한 다른 철자가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eba25eb602283568b271842c052f8b74fae72c6c" translate="yes" xml:space="preserve">
          <source>There are five types of statements:</source>
          <target state="translated">다섯 가지 유형의 진술이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6772e38914753165f4023b86ef3b645e638c1de8" translate="yes" xml:space="preserve">
          <source>There are four coherences that are guaranteed for all atomic operations:</source>
          <target state="translated">모든 원자 연산에 대해 보장되는 네 가지 일관성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="beccd582c554354fe97bf6fe8f530cf6be9b9156" translate="yes" xml:space="preserve">
          <source>There are many different NaN values with different sign bits and payloads, see &lt;code&gt;&lt;a href=&quot;nan.2&quot;&gt;nan&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">부호 비트와 페이로드가 다른 여러 NaN 값이 있습니다 ( &lt;code&gt;&lt;a href=&quot;nan.2&quot;&gt;nan&lt;/a&gt;&lt;/code&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="7e03334de5cfa0b9f96707c08d7bef755bc11a3c" translate="yes" xml:space="preserve">
          <source>There are many different NaN values, differentiated by their payloads and their sign bits. The contents of the payload and the sign bit of the NaN generated by the macro &lt;code&gt;NAN&lt;/code&gt; are implementation-defined.</source>
          <target state="translated">페이로드와 부호 비트로 구별되는 다양한 NaN 값이 있습니다. 매크로 &lt;code&gt;NAN&lt;/code&gt; 에 의해 생성 된 페이로드의 내용 및 NaN의 부호 비트 는 구현 정의된다.</target>
        </trans-unit>
        <trans-unit id="59b96aea907cb0b6e15b2cdf641639fef1154954" translate="yes" xml:space="preserve">
          <source>There are no conversions (implicit or explicit) between pointers to functions and pointers to objects (including void*) or integers.</source>
          <target state="translated">함수에 대한 포인터와 객체에 대한 포인터 (void * 포함) 또는 정수 사이에는 변환 (암시 적 또는 명시 적)이 없습니다.</target>
        </trans-unit>
        <trans-unit id="b92ddc58d5de1bff3b780dc60945b52fcda99d6e" translate="yes" xml:space="preserve">
          <source>There are no guarantees as to the quality of the random sequence produced. In the past, some implementations of &lt;code&gt;rand()&lt;/code&gt; have had serious shortcomings in the randomness, distribution and period of the sequence produced (in one well-known example, the low-order bit simply alternated between &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;0&lt;/code&gt; between calls). &lt;code&gt;rand()&lt;/code&gt; is not recommended for serious random-number generation needs, like cryptography.</source>
          <target state="translated">생성 된 랜덤 시퀀스의 품질에 대한 보장은 없습니다. 과거에는 &lt;code&gt;rand()&lt;/code&gt; 의 일부 구현 에서 생성 된 시퀀스의 무작위성, 분포 및 기간에 심각한 결점이있었습니다 (잘 알려진 한 예에서 하위 비트는 단순히 호출 간에 &lt;code&gt;1&lt;/code&gt; 과 &lt;code&gt;0&lt;/code&gt; 사이에서 번갈아 나타남). &lt;code&gt;rand()&lt;/code&gt; 는 암호화와 같은 심각한 난수 생성 요구에 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="588bd29754314126c33aee156a614a561e64c447" translate="yes" xml:space="preserve">
          <source>There are no negative floating constants; an expression such as &lt;code&gt;-1.2&lt;/code&gt; is the &lt;a href=&quot;operator_arithmetic&quot;&gt;arithmetic operator&lt;/a&gt; unary minus applied to the floating constant &lt;code&gt;1.2&lt;/code&gt;. Note that the special value negative zero may be constructed with &lt;code&gt;-0.0&lt;/code&gt;.</source>
          <target state="translated">음의 부동 상수는 없습니다. 식 등이 &lt;code&gt;-1.2&lt;/code&gt; 은 IS &lt;a href=&quot;operator_arithmetic&quot;&gt;연산기&lt;/a&gt; 플로팅 일정한인가 단항 &lt;code&gt;1.2&lt;/code&gt; . 특수 값 음수 0은 &lt;code&gt;-0.0&lt;/code&gt; 으로 구성 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bdca7722c2b3b18ea7c62a79f1fda46ad671b715" translate="yes" xml:space="preserve">
          <source>There are no negative integer constants. Expressions such as &lt;code&gt;-1&lt;/code&gt; apply the &lt;a href=&quot;operator_arithmetic&quot;&gt;unary minus operator&lt;/a&gt; to the value represented by the constant, which may involve implicit &lt;a href=&quot;conversion&quot;&gt;type conversions&lt;/a&gt;.</source>
          <target state="translated">음의 정수 상수가 없습니다. &lt;code&gt;-1&lt;/code&gt; 과 같은 표현식 은 상수로 표시되는 값에 &lt;a href=&quot;operator_arithmetic&quot;&gt;단항 빼기 연산자&lt;/a&gt; 를 적용합니다 . 여기에는 암시 적 &lt;a href=&quot;conversion&quot;&gt;유형 변환&lt;/a&gt; 이 포함될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9a3b42ee7caccbfb7868142d55eb631f71011dee" translate="yes" xml:space="preserve">
          <source>There are no nested functions (except where allowed through non-standard compiler extensions): each function definition must appear at file scope, and functions have no access to the local variables from the caller:</source>
          <target state="translated">중첩 된 함수가 없습니다 (비표준 컴파일러 확장을 통해 허용되는 경우 제외) : 각 함수 정의는 파일 범위에 나타나야하며 함수는 호출자의 로컬 변수에 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6c2d3c4f220b5494a67a0f9953dc898467eabcbd" translate="yes" xml:space="preserve">
          <source>There are several common usage patterns for restrict-qualified pointers:</source>
          <target state="translated">제한 규정 포인터에 대한 몇 가지 일반적인 사용 패턴이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3adc61e5da640a9ba91547c50c8ab6dddb0048c4" translate="yes" xml:space="preserve">
          <source>There are several variations of array types: arrays of known constant size, variable-length arrays, and arrays of unknown size.</source>
          <target state="translated">알려진 일정한 크기의 배열, 가변 길이 배열 및 알 수없는 크기의 배열 등 여러 배열 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4997b02e62e6a0e4ec89133d02261fc0ce72b438" translate="yes" xml:space="preserve">
          <source>There are two kinds of evaluations performed by the compiler for each expression or subexpression (both of which are optional):</source>
          <target state="translated">컴파일러는 각 표현식 또는 하위 표현식에 대해 두 가지 종류의 평가를 수행합니다 (둘 다 선택 사항 임).</target>
        </trans-unit>
        <trans-unit id="d6fabe6d44b488b86750b5227d2a79c424b55dd2" translate="yes" xml:space="preserve">
          <source>There is a &lt;a href=&quot;../language/eval_order&quot;&gt;sequence point&lt;/a&gt; after the action of each conversion specifier; this permits storing multiple &lt;code&gt;%n&lt;/code&gt; results in the same variable or, as an edge case, printing a string modified by an earlier &lt;code&gt;%n&lt;/code&gt; within the same call.</source>
          <target state="translated">각 변환 지정자의 동작 이후에 &lt;a href=&quot;../language/eval_order&quot;&gt;시퀀스 포인트&lt;/a&gt; 가 있습니다 . 이렇게하면 여러 &lt;code&gt;%n&lt;/code&gt; 결과를 동일한 변수에 저장하거나 가장자리의 경우 같은 호출 내에서 이전 &lt;code&gt;%n&lt;/code&gt; 의해 수정 된 문자열을 인쇄 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52984a17b30b0d82af603d64b3c7eb96ca2c2d00" translate="yes" xml:space="preserve">
          <source>There is a &lt;a href=&quot;../language/eval_order&quot;&gt;sequence point&lt;/a&gt; after the action of each conversion specifier; this permits storing multiple fields in the same &quot;sink&quot; variable.</source>
          <target state="translated">각 변환 지정자의 동작 이후에 &lt;a href=&quot;../language/eval_order&quot;&gt;시퀀스 포인트&lt;/a&gt; 가 있습니다 . 이를 통해 동일한 &quot;싱크&quot;변수에 여러 필드를 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d70af8d031e1e84898b1b7b8ee0619e430a9744d" translate="yes" xml:space="preserve">
          <source>There is a &lt;a href=&quot;eval_order&quot;&gt;sequence point&lt;/a&gt; after the evaluation of lhs. If the result of lhs compares equal to zero, then rhs is not evaluated at all (so-called</source>
          <target state="translated">lhs 평가 후 &lt;a href=&quot;eval_order&quot;&gt;시퀀스 포인트&lt;/a&gt; 가 있습니다 . lhs의 결과가 0과 비교되면 rhs는 전혀 평가되지 않습니다 (소위</target>
        </trans-unit>
        <trans-unit id="14abb1fb6e2bfb562fbb9a6e6989215e9fd7c48f" translate="yes" xml:space="preserve">
          <source>There is a &lt;a href=&quot;eval_order&quot;&gt;sequence point&lt;/a&gt; after the evaluation of lhs. If the result of lhs compares unequal to zero, then rhs is not evaluated at all (so-called</source>
          <target state="translated">lhs 평가 후 &lt;a href=&quot;eval_order&quot;&gt;시퀀스 포인트&lt;/a&gt; 가 있습니다 . lhs의 결과가 0과 같지 않으면 rhs는 전혀 평가되지 않습니다 (소위</target>
        </trans-unit>
        <trans-unit id="ab3c5acf0d5e4ba77cc962cd2ce83a7c967eb424" translate="yes" xml:space="preserve">
          <source>There is a non-standard function named &lt;code&gt;gamma&lt;/code&gt; in various implementations, but its definition is inconsistent. For example, glibc and 4.2BSD version of &lt;code&gt;gamma&lt;/code&gt; executes &lt;code&gt;lgamma&lt;/code&gt;, but 4.4BSD version of &lt;code&gt;gamma&lt;/code&gt; executes &lt;code&gt;tgamma&lt;/code&gt;.</source>
          <target state="translated">다양한 구현에 &lt;code&gt;gamma&lt;/code&gt; 라는 비표준 함수가 있지만 그 정의가 일치하지 않습니다. 예를 들어, glibc 및 4.2BSD 버전의 &lt;code&gt;gamma&lt;/code&gt; &lt;code&gt;lgamma&lt;/code&gt; 를 실행 하지만 4.4BSD 버전의 &lt;code&gt;gamma&lt;/code&gt; &lt;code&gt;tgamma&lt;/code&gt; 를 실행 합니다.</target>
        </trans-unit>
        <trans-unit id="b717a5566f4d275ca27affef23f0b5a37db23c45" translate="yes" xml:space="preserve">
          <source>There is no alternative spelling (such as &lt;code&gt;eq&lt;/code&gt;) for the equality operator &lt;code&gt;==&lt;/code&gt; because the character &lt;code&gt;=&lt;/code&gt; was present in all supported charsets.</source>
          <target state="translated">문자 &lt;code&gt;=&lt;/code&gt; 가 지원되는 모든 문자 세트에 있기 때문에 등호 연산자 &lt;code&gt;==&lt;/code&gt; 에 대한 대체 철자 (예 : &lt;code&gt;eq&lt;/code&gt; ) 는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="6eb84e3cfc1155e6d27b4d15b2eca66bb1cb86c9" translate="yes" xml:space="preserve">
          <source>There is no concept of left-to-right or right-to-left evaluation in C, which is not to be confused with left-to-right and right-to-left associativity of operators: the expression &lt;code&gt;f1() + f2() + f3()&lt;/code&gt; is parsed as &lt;code&gt;(f1() + f2()) + f3()&lt;/code&gt; due to left-to-right associativity of operator+, but the function call to &lt;code&gt;f3&lt;/code&gt; may be evaluated first, last, or between &lt;code&gt;f1()&lt;/code&gt; or &lt;code&gt;f2()&lt;/code&gt; at run time.</source>
          <target state="translated">C에는 왼쪽에서 오른쪽 또는 오른쪽에서 왼쪽으로 평가하는 개념이 없으며 연산자의 왼쪽에서 오른쪽 및 오른쪽에서 왼쪽으로의 연관성과 혼동하지 마십시오. 식 &lt;code&gt;f1() + f2() + f3()&lt;/code&gt; 은 operator +의 왼쪽에서 오른쪽으로의 연관성으로 인해 &lt;code&gt;(f1() + f2()) + f3()&lt;/code&gt; 으로 구문 분석 되지만 &lt;code&gt;f3&lt;/code&gt; 에 대한 함수 호출 은 첫 번째, 마지막 또는 &lt;code&gt;f1()&lt;/code&gt; 사이에서 평가 될 수 있습니다. 또는 런타임시 &lt;code&gt;f2()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a78979596616d979924aa8f0a7856f4ca21bc39" translate="yes" xml:space="preserve">
          <source>There is no null character in the first &lt;code&gt;dstsz&lt;/code&gt; multibyte characters in the &lt;code&gt;*src&lt;/code&gt; array and &lt;code&gt;len&lt;/code&gt; is greater than &lt;code&gt;dstsz&lt;/code&gt; (unless &lt;code&gt;dst&lt;/code&gt; is null)</source>
          <target state="translated">&lt;code&gt;*src&lt;/code&gt; 배열 의 첫 번째 &lt;code&gt;dstsz&lt;/code&gt; 멀티 바이트 문자 에는 널 문자가 없으며 &lt;code&gt;len&lt;/code&gt; 은 &lt;code&gt;dstsz&lt;/code&gt; 보다 큽니다 ( &lt;code&gt;dst&lt;/code&gt; 가 널이 아닌 경우 )</target>
        </trans-unit>
        <trans-unit id="9850a4c4e290745723f4fc213c3322632b4431ed" translate="yes" xml:space="preserve">
          <source>There is no null character in the first &lt;code&gt;dstsz&lt;/code&gt; multibyte characters in the &lt;code&gt;src&lt;/code&gt; array and &lt;code&gt;len&lt;/code&gt; is greater than &lt;code&gt;dstsz&lt;/code&gt; (unless &lt;code&gt;dst&lt;/code&gt; is null)</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 배열 의 첫 번째 &lt;code&gt;dstsz&lt;/code&gt; 멀티 바이트 문자에 널 문자가없고 &lt;code&gt;len&lt;/code&gt; 이 &lt;code&gt;dstsz&lt;/code&gt; 보다 큽니다 ( &lt;code&gt;dst&lt;/code&gt; 가 널이 아닌 경우 )</target>
        </trans-unit>
        <trans-unit id="642998dca69feddbb7005ae57f38e02a160cbb21" translate="yes" xml:space="preserve">
          <source>These are the directives defined by the standard. The standard does not define behavior for other directives: they might be ignored, have some useful meaning, or make the program ill-formed. Even if otherwise ignored, they are removed from the source code when the preprocessor is done. A common non-standard extension is the directive &lt;code&gt;#warning&lt;/code&gt; which emits a user-defined message during compilation.</source>
          <target state="translated">이것들은 표준에 의해 정의 된 지시어입니다. 이 표준은 다른 지시어에 대한 동작을 정의하지 않습니다.이 지시어는 무시되거나 유용한 의미가 있거나 프로그램이 잘못 작성 될 수 있습니다. 달리 무시하더라도, 전처리 기가 완료되면 소스 코드에서 제거됩니다. 일반적인 비표준 확장은 컴파일 중 사용자 정의 메시지를 생성하는 지시문 &lt;code&gt;#warning&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c34a994ae2744a9c70d2624d0339c7d60e48fac7" translate="yes" xml:space="preserve">
          <source>These macros are implemented as if the imaginary types are supported (even if they are otherwise not supported and &lt;code&gt;&lt;a href=&quot;imaginary_i&quot;&gt;_Imaginary_I&lt;/a&gt;&lt;/code&gt; is actually undefined) and as if defined as follows:</source>
          <target state="translated">이 매크로는 가상 유형이 지원되는 것처럼 (그렇지 않으면 지원되지 않고 &lt;code&gt;&lt;a href=&quot;imaginary_i&quot;&gt;_Imaginary_I&lt;/a&gt;&lt;/code&gt; 가 실제로 정의되지 않은 경우에도) 다음과 같이 정의 된 것처럼 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="a4070e09555e3c6b6233a56d9b2a60f748e63343" translate="yes" xml:space="preserve">
          <source>These rules apply recursively to the types from which the two types are derived.</source>
          <target state="translated">이 규칙은 두 유형이 파생 된 유형에 재귀 적으로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="18430fdedd8d39e1faff6417927ee373baccbc33" translate="yes" xml:space="preserve">
          <source>These rules control whether a function that receives two pointers must re-read one after writing through another:</source>
          <target state="translated">이 규칙은 두 개의 포인터를받는 함수가 다른 포인터를 통해 쓴 후 하나를 다시 읽어야하는지 여부를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="9c584adee26a0f194a4221931b8f5c6cd4324020" translate="yes" xml:space="preserve">
          <source>These rules simplify the use of header files.</source>
          <target state="translated">이러한 규칙은 헤더 파일 사용을 단순화합니다.</target>
        </trans-unit>
        <trans-unit id="6da00a198d25ed4a99c4e2cfacbe9f6df3d8c0b0" translate="yes" xml:space="preserve">
          <source>They can even avoid using the tag name space at all:</source>
          <target state="translated">태그 네임 스페이스를 전혀 사용하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="88450ca53b9705996636f46ab82f85909cd9ffd6" translate="yes" xml:space="preserve">
          <source>They can have postfix form:</source>
          <target state="translated">그들은 후위 형식을 가질 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="cfe69ffd880071fd0df6c53ec20b12147145bf12" translate="yes" xml:space="preserve">
          <source>This allows structs that refer to each other:</source>
          <target state="translated">이것은 서로를 참조하는 구조체를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="d2ed7fa74d34f8de0d1eaf468b8712c8f649e605" translate="yes" xml:space="preserve">
          <source>This constant is equivalent to the POSIX &lt;code&gt;PTHREAD_DESTRUCTOR_ITERATIONS&lt;/code&gt;.</source>
          <target state="translated">이 상수는 POSIX &lt;code&gt;PTHREAD_DESTRUCTOR_ITERATIONS&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="b50860f0a9733ec87d616cbc629bfd04dd2d57a1" translate="yes" xml:space="preserve">
          <source>This convenience macro expands to the keyword &lt;a href=&quot;../keyword/_static_assert&quot;&gt;_Static_assert&lt;/a&gt;.</source>
          <target state="translated">이 편의 매크로는 키워드 &lt;a href=&quot;../keyword/_static_assert&quot;&gt;_Static_assert로&lt;/a&gt; 확장됩니다 .</target>
        </trans-unit>
        <trans-unit id="b69559dc667ea9ee00a61f5b0fa74edf96266446" translate="yes" xml:space="preserve">
          <source>This conversion models the memory load of the value of the object from its location.</source>
          <target state="translated">이 변환은 위치에서 객체 값의 메모리로드를 모델링합니다.</target>
        </trans-unit>
        <trans-unit id="7411fcb845dcaee0f13e9cd4e36b67d0ac9d7fab" translate="yes" xml:space="preserve">
          <source>This directive is used by some automatic code generation tools which produce C source files from a file written in another language. In that case, &lt;code&gt;#line&lt;/code&gt; directives may be inserted in the generated C file referencing line numbers and the file name of the original (human-editable) source file.</source>
          <target state="translated">이 지시문은 다른 언어로 작성된 파일에서 C 소스 파일을 생성하는 일부 자동 코드 생성 도구에서 사용됩니다. 이 경우 &lt;code&gt;#line&lt;/code&gt; 지시문은 생성 된 C 파일 참조 행 번호 및 원본 (사람이 편집 가능한) 소스 파일의 파일 이름에 삽입 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="076b866beacb08cccde9a7cbeb026a03c41cdec2" translate="yes" xml:space="preserve">
          <source>This example demonstrates the difference between clock() time and real time.</source>
          <target state="translated">이 예제는 clock () 시간과 실시간의 차이를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="0244ac28d2447894c8661b2de1ddf4c14a2a9959" translate="yes" xml:space="preserve">
          <source>This example shows how to read a file twice.</source>
          <target state="translated">이 예제는 파일을 두 번 읽는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="0c7a11a8d6d19389f0abbac4fa34ba46bd07ad35" translate="yes" xml:space="preserve">
          <source>This function</source>
          <target state="translated">이 기능</target>
        </trans-unit>
        <trans-unit id="0f912b3d69a2d64099faca61cd00f39d6e484909" translate="yes" xml:space="preserve">
          <source>This function (for double argument) behaves as if (except for the freedom to not raise &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt;) implemented by.</source>
          <target state="translated">이 함수 (이중 인수의 경우 )는 구현 된 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; 를 발생시키지 않는 자유 제외) 동작 합니다.</target>
        </trans-unit>
        <trans-unit id="fc3c34a0198ac33575e10015adc37a15fd3102be" translate="yes" xml:space="preserve">
          <source>This function &lt;code&gt;gmtime&lt;/code&gt; may not be thread-safe.</source>
          <target state="translated">이 기능 &lt;code&gt;gmtime&lt;/code&gt; 은 스레드로부터 안전하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b50d9318428e6b56bb64ec1ee9a5392761dc1191" translate="yes" xml:space="preserve">
          <source>This function &lt;code&gt;localtime&lt;/code&gt; may not be thread-safe.</source>
          <target state="translated">이 함수 &lt;code&gt;localtime&lt;/code&gt; 은 스레드로부터 안전하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56dabe59df1e13c9e7227a371ae542e03583d74a" translate="yes" xml:space="preserve">
          <source>This function behaves as if implemented as follows:</source>
          <target state="translated">이 기능은 다음과 같이 구현 된 것처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e024c278b12913b9314d8bc74236e17366fbdd60" translate="yes" xml:space="preserve">
          <source>This function behaves as if it reads the characters sequentially and stops as soon as a matching character is found: if the array pointed to by &lt;code&gt;ptr&lt;/code&gt; is smaller than &lt;code&gt;count&lt;/code&gt;, but the match is found within the array, the behavior is well-defined.</source>
          <target state="translated">이 함수는 문자를 순차적으로 읽고 일치하는 문자를 찾 자마자 멈추는 것처럼 동작합니다. &lt;code&gt;ptr&lt;/code&gt; 이 가리키는 배열 이 &lt;code&gt;count&lt;/code&gt; 보다 작지만 일치하는 것이 배열 내에 있으면 동작이 잘 정의 된 것입니다.</target>
        </trans-unit>
        <trans-unit id="db0f3821e4deee5da8554e13cdcbbb92c017d0a9" translate="yes" xml:space="preserve">
          <source>This function is designed to be called multiples times to obtain successive tokens from the same string.</source>
          <target state="translated">이 함수는 동일한 문자열에서 연속적인 토큰을 얻기 위해 여러 번 호출되도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="4e6efd938fea60e8a8ba4cf09b50c3ce4deac15d" translate="yes" xml:space="preserve">
          <source>This function is destructive: it writes the &lt;code&gt;'\0'&lt;/code&gt; characters in the elements of the string &lt;code&gt;str&lt;/code&gt;. In particular, a string literal cannot be used as the first argument of &lt;code&gt;strtok&lt;/code&gt;.</source>
          <target state="translated">이 함수는 파괴적입니다 : 문자열 &lt;code&gt;str&lt;/code&gt; 의 요소에 &lt;code&gt;'\0'&lt;/code&gt; 문자를 씁니다 . 특히 문자열 리터럴을 &lt;code&gt;strtok&lt;/code&gt; 의 첫 번째 인수로 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c153eac4de71030a581d492d74631860a8a74df0" translate="yes" xml:space="preserve">
          <source>This function is destructive: it writes the &lt;code&gt;L'\0'&lt;/code&gt; characters in the elements of the string &lt;code&gt;str&lt;/code&gt;. In particular, a wide string literal cannot be used as the first argument of &lt;code&gt;wcstok&lt;/code&gt;.</source>
          <target state="translated">이 함수는 파괴적입니다 : 문자열 &lt;code&gt;str&lt;/code&gt; 의 요소에 &lt;code&gt;L'\0'&lt;/code&gt; 문자를 씁니다 . 특히, 넓은 문자열 리터럴을 &lt;code&gt;wcstok&lt;/code&gt; 의 첫 번째 인수로 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="4fced0fa7f525bd304cf4a0df7503105cd2c0150" translate="yes" xml:space="preserve">
          <source>This function is equivalent to the call &lt;code&gt;&lt;a href=&quot;mbrtowc&quot;&gt;mbrtowc&lt;/a&gt;(nullptr, s, n, ps?ps:&amp;amp;internal)&lt;/code&gt; for some hidden object &lt;code&gt;internal&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;mbstate_t&lt;/a&gt;&lt;/code&gt;, except that the expression &lt;code&gt;ps&lt;/code&gt; is evaluated only once.</source>
          <target state="translated">이 함수 호출에 상당 &lt;code&gt;&lt;a href=&quot;mbrtowc&quot;&gt;mbrtowc&lt;/a&gt;(nullptr, s, n, ps?ps:&amp;amp;internal)&lt;/code&gt; 일부 숨겨진 개체 &lt;code&gt;internal&lt;/code&gt; 유형의 &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;mbstate_t&lt;/a&gt;&lt;/code&gt; 발현하는 것을 제외하고, &lt;code&gt;ps&lt;/code&gt; 한번만 평가된다.</target>
        </trans-unit>
        <trans-unit id="231a0871c75740128f3a8e900a16eece62f9a755" translate="yes" xml:space="preserve">
          <source>This function is equivalent to the call &lt;code&gt;&lt;a href=&quot;mbtowc&quot;&gt;mbtowc&lt;/a&gt;((wchar_t*)0, s, n)&lt;/code&gt;, except that conversion state of &lt;code&gt;&lt;a href=&quot;mbtowc&quot;&gt;mbtowc&lt;/a&gt;&lt;/code&gt; is unaffected.</source>
          <target state="translated">이 함수 호출에 상당 &lt;code&gt;&lt;a href=&quot;mbtowc&quot;&gt;mbtowc&lt;/a&gt;((wchar_t*)0, s, n)&lt;/code&gt; 을 제외하고 그 변환 상태 &lt;code&gt;&lt;a href=&quot;mbtowc&quot;&gt;mbtowc&lt;/a&gt;&lt;/code&gt; 는이 영향을받지 않는다.</target>
        </trans-unit>
        <trans-unit id="289cf9d190604844c33bb4b2eed7d07fca8b2a3c" translate="yes" xml:space="preserve">
          <source>This function is fully specified for all possible inputs and is not subject to any errors described in &lt;a href=&quot;../math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;.</source>
          <target state="translated">이 함수는 가능한 모든 입력에 대해 완전히 지정되었으며 &lt;a href=&quot;../math/math_errhandling&quot;&gt;math_errhandling에&lt;/a&gt; 설명 된 오류의 영향을받지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="bf2280640237c525c2d62eefb26aff9f2856c11f" translate="yes" xml:space="preserve">
          <source>This function is not locale-sensitive and pays no attention to the values of the &lt;code&gt;wchar_t&lt;/code&gt; objects it copies: nulls as well as invalid characters are copied too.</source>
          <target state="translated">이 함수는 로케일에 민감하지 않으며 복사 하는 &lt;code&gt;wchar_t&lt;/code&gt; 오브젝트 의 값에주의를 기울이지 않습니다. 유효하지 않은 문자뿐만 아니라 널도 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="67fe14d7992c12e6d5c157b600ec2cde52ad0774" translate="yes" xml:space="preserve">
          <source>This function is not locale-sensitive and pays no attention to the values of the &lt;code&gt;wchar_t&lt;/code&gt; objects it examines: nulls as well as invalid wide characters are compared too.</source>
          <target state="translated">이 함수는 로케일에 민감하지 않으며 검사 하는 &lt;code&gt;wchar_t&lt;/code&gt; 오브젝트 의 값에주의를 기울이지 않습니다 . 널 (NULL) 및 유효하지 않은 와이드 문자도 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="9c3cb718222d314cabd06a082b4892a3a4ab3e26" translate="yes" xml:space="preserve">
          <source>This function is not locale-sensitive and pays no attention to the values of the &lt;code&gt;wchar_t&lt;/code&gt; objects it writes: nulls as well as invalid wide characters are written too.</source>
          <target state="translated">이 함수는 로케일에 민감하지 않으며 작성 하는 &lt;code&gt;wchar_t&lt;/code&gt; 오브젝트 의 값에주의를 기울이지 않습니다 . 널 (NULL) 및 유효하지 않은 와이드 문자도 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="7fd9eb1ebb9f64fc35b5dd954c1ec8fde9ee2bc0" translate="yes" xml:space="preserve">
          <source>This function is not locale-sensitive, unlike &lt;code&gt;&lt;a href=&quot;strcoll&quot;&gt;strcoll&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;strxfrm&quot;&gt;strxfrm&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;strcoll&quot;&gt;strcoll&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;strxfrm&quot;&gt;strxfrm&lt;/a&gt;&lt;/code&gt; 과 달리 로케일에 민감하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="62bdb6519f660463d2b94beeadb5dcc88cb10b36" translate="yes" xml:space="preserve">
          <source>This function is not locale-sensitive, unlike &lt;code&gt;&lt;a href=&quot;wcscoll&quot;&gt;wcscoll&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;wcsxfrm&quot;&gt;wcsxfrm&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수는 달리, 로케일에 의존하지 &lt;code&gt;&lt;a href=&quot;wcscoll&quot;&gt;wcscoll&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;wcsxfrm&quot;&gt;wcsxfrm&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="927a55b81991e753e70085ac5fc65b5e5213d7eb" translate="yes" xml:space="preserve">
          <source>This function is not locale-sensitive, unlike &lt;code&gt;&lt;a href=&quot;wcscoll&quot;&gt;wcscoll&lt;/a&gt;&lt;/code&gt;, and the order may not be meaningful when characters from different Unicode blocks are used together or when the order of code units does not match any collation order.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;wcscoll&quot;&gt;wcscoll&lt;/a&gt;&lt;/code&gt; 과 달리 로케일에 민감 하지 않으며 다른 유니 코드 블록의 문자를 함께 사용하거나 코드 단위의 순서가 데이터 정렬 순서와 일치하지 않으면 순서가 의미가 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3b72d4451a67b0f8e9ff04bab97998d9cac5a6e" translate="yes" xml:space="preserve">
          <source>This function is not required to be sensitive to the sign of zero, although some implementations additionally enforce that if one argument is +0 and the other is -0, then +0 is returned.</source>
          <target state="translated">일부 구현에서는 한 인수가 +0이고 다른 인수가 -0이면 +0이 리턴되도록 추가로 시행하지만이 함수는 0의 부호에 민감하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="1e7653f07d484a2f1a2819f2a881f15b3743184c" translate="yes" xml:space="preserve">
          <source>This function is not required to be sensitive to the sign of zero, although some implementations additionally enforce that if one argument is +0 and the other is -0, then -0 is returned.</source>
          <target state="translated">일부 구현에서는 한 인수가 +0이고 다른 인수가 -0이면 -0이 리턴되도록 추가로 시행하지만이 함수는 0의 부호에 민감하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="63ff1f7a80d3a2498f6c2c57080a31e1fe86d34e" translate="yes" xml:space="preserve">
          <source>This function is not required to be thread-safe. Another call to getenv, as well as a call to the POSIX functions &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/setenv.html&quot;&gt;setenv()&lt;/a&gt;, &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/unsetenv.html&quot;&gt;unsetenv()&lt;/a&gt;, and &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/putenv.html&quot;&gt;putenv()&lt;/a&gt; may invalidate the pointer returned by a previous call or modify the string obtained from a previous call.</source>
          <target state="translated">이 기능은 스레드로부터 안전하지 않아도됩니다. getenv에 대한 다른 호출과 POSIX 함수 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/setenv.html&quot;&gt;setenv ()&lt;/a&gt; , &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/unsetenv.html&quot;&gt;unsetenv ()&lt;/a&gt; 및 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/putenv.html&quot;&gt;putenv ()&lt;/a&gt; 에 대한 호출은 이전 호출에서 리턴 된 포인터를 무효화하거나 이전 호출에서 얻은 문자열을 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="681d635b8b9b9b5848473256fcd251c20f009b9c" translate="yes" xml:space="preserve">
          <source>This function is not required to be thread-safe. Another call to getenv, as well as a call to the POSIX functions &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/setenv.html&quot;&gt;setenv()&lt;/a&gt;, &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/unsetenv.html&quot;&gt;unsetenv()&lt;/a&gt;, and &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/putenv.html&quot;&gt;putenv()&lt;/a&gt; may invalidate the pointer returned by a previous call or modify the string obtained from a previous call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c18c3327a1bb9aff722e27566d40c0f5a2e03ab6" translate="yes" xml:space="preserve">
          <source>This function is not subject to any errors specified in &lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;.</source>
          <target state="translated">이 함수에는 &lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling에&lt;/a&gt; 지정된 오류가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="a6683742f8d4669b99ea5d2493ece7dd4bf9163f" translate="yes" xml:space="preserve">
          <source>This function is not subject to any of the error conditions specified in &lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;.</source>
          <target state="translated">이 함수에는 &lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling에&lt;/a&gt; 지정된 오류 조건이 적용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a709e4cf707eedac9654ec2bb76727de164f9448" translate="yes" xml:space="preserve">
          <source>This function is not subject to any of the errors specified in &lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;.</source>
          <target state="translated">이 함수에는 &lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling에&lt;/a&gt; 지정된 오류가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="ee72f094fe13a8766f016ade2b2b9b07bf2aa390" translate="yes" xml:space="preserve">
          <source>This function is used when making multiple locale-dependent comparisons using the same string or set of strings, because it is more efficient to use &lt;code&gt;strxfrm&lt;/code&gt; to transform all the strings just once, and subsequently compare the transformed strings with &lt;code&gt;&lt;a href=&quot;strcmp&quot;&gt;strcmp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;strxfrm&lt;/code&gt; 을 사용 하여 모든 문자열을 한 번만 변환 한 다음 변환 된 문자열을 &lt;code&gt;&lt;a href=&quot;strcmp&quot;&gt;strcmp&lt;/a&gt;&lt;/code&gt; 와 비교하는 것이 더 효율적이므로 동일한 문자열 또는 문자열 세트를 사용하여 여러 로케일 종속 비교를 수행 할 때 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="a65b542fcd908db7b072f90fe956dd83e5f184b9" translate="yes" xml:space="preserve">
          <source>This function is used when making multiple locale-dependent comparisons using the same wide string or set of wide strings, because it is more efficient to use &lt;code&gt;wcsxfrm&lt;/code&gt; to transform all the strings just once, and subsequently compare the transformed wide strings with &lt;code&gt;&lt;a href=&quot;wcscmp&quot;&gt;wcscmp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;wcsxfrm&lt;/code&gt; 을 사용 하여 모든 문자열을 한 번만 변환 한 다음 변환 된 넓은 문자열을 &lt;code&gt;&lt;a href=&quot;wcscmp&quot;&gt;wcscmp&lt;/a&gt;&lt;/code&gt; 와 비교하는 것이 더 효율적이므로 동일한 와이드 문자열 또는 와이드 문자열 세트를 사용하여 여러 로케일 종속 비교를 수행 할 때 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e03d3793ab454e8128b5c58da21acb181e05d455" translate="yes" xml:space="preserve">
          <source>This function is useful when implementing periodic functions with the period exactly representable as a floating-point value: when calculating sin(&amp;pi;x) for a very large &lt;code&gt;x&lt;/code&gt;, calling &lt;code&gt;&lt;a href=&quot;sin&quot;&gt;sin&lt;/a&gt;&lt;/code&gt; directly may result in a large error, but if the function argument is first reduced with &lt;code&gt;remquo&lt;/code&gt;, he low-order bits of the quotient may be used to determine the sign and the octant of the result within the period, while the remainder may be used to calculate the value with high precision.</source>
          <target state="translated">이 함수는주기를 부동 소수점 값으로 정확하게 표현할 수있는주기 함수를 구현할 때 유용합니다. 매우 큰 &lt;code&gt;x&lt;/code&gt; 에 대해 sin (&amp;pi;x)을 계산할 때 &lt;code&gt;&lt;a href=&quot;sin&quot;&gt;sin&lt;/a&gt;&lt;/code&gt; 을 직접 호출 하면 큰 오류가 발생할 수 있지만 함수 인수가 먼저 감소 된 경우 &lt;code&gt;remquo&lt;/code&gt; 를 사용하면 몫의 하위 비트를 사용하여 기간 내 결과의 부호 와 옥탄트 를 결정할 수 있으며 나머지는 높은 정밀도로 값을 계산하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c35c12e20abb3630d4e436c000152934a2b3212d" translate="yes" xml:space="preserve">
          <source>This function may be used in the beginning of a subroutine that must hide the floating-point exceptions it may raise from the caller. If only some exceptions must be suppressed, while others must be reported, the non-stop mode is usually ended with a call to &lt;code&gt;&lt;a href=&quot;feupdateenv&quot;&gt;feupdateenv&lt;/a&gt;&lt;/code&gt; after clearing the unwanted exceptions.</source>
          <target state="translated">이 함수는 호출자로부터 발생할 수있는 부동 소수점 예외를 숨겨야하는 서브 루틴의 시작에서 사용될 수 있습니다. 일부 예외 만 억제해야하고 다른 예외 만보고해야하는 경우 비 정지 모드는 일반적으로 원하지 않는 예외를 지운 후 &lt;code&gt;&lt;a href=&quot;feupdateenv&quot;&gt;feupdateenv&lt;/a&gt;&lt;/code&gt; 를 호출하여 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="c90c1d681d31741a20a83a505d3bfb6598bed15c" translate="yes" xml:space="preserve">
          <source>This function may be used to end the non-stop mode established by an earlier call to &lt;code&gt;&lt;a href=&quot;feholdexcept&quot;&gt;feholdexcept&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 기능은 이전에 &lt;code&gt;&lt;a href=&quot;feholdexcept&quot;&gt;feholdexcept&lt;/a&gt;&lt;/code&gt; 호출로 설정된 논스톱 모드를 종료하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eba5a1fa5d6bf34dbc8e4aa1de43f17b83ab0d16" translate="yes" xml:space="preserve">
          <source>This function may only be used after &lt;code&gt;stream&lt;/code&gt; has been associated with an open file, but before any other operation (other than a failed call to &lt;code&gt;&lt;a href=&quot;setbuf&quot;&gt;setbuf&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;setvbuf&lt;/code&gt;).</source>
          <target state="translated">이 함수는 &lt;code&gt;stream&lt;/code&gt; 이 열린 파일과 연관되고 다른 작업 ( &lt;code&gt;&lt;a href=&quot;setbuf&quot;&gt;setbuf&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;setvbuf&lt;/code&gt; 호출 실패 이외) 전에 만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="96689986a9f996a280e4c757957f55a81eb0fb31" translate="yes" xml:space="preserve">
          <source>This function may only be used after &lt;code&gt;stream&lt;/code&gt; has been associated with an open file, but before any other operation (other than a failed call to &lt;code&gt;setbuf&lt;/code&gt;/&lt;code&gt;setvbuf&lt;/code&gt;).</source>
          <target state="translated">이 함수는 &lt;code&gt;stream&lt;/code&gt; 이 열린 파일과 연관되고 다른 작업 ( &lt;code&gt;setbuf&lt;/code&gt; / &lt;code&gt;setvbuf&lt;/code&gt; 호출 실패 이외) 전에 만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c67c60121c3003570bb2cb1cae4c32a23903e49f" translate="yes" xml:space="preserve">
          <source>This function only reports the stream state as reported by the most recent I/O operation, it does not examine the associated data source. For example, if the most recent I/O was a &lt;code&gt;&lt;a href=&quot;fgetc&quot;&gt;fgetc&lt;/a&gt;&lt;/code&gt;, which returned the last byte of a file, &lt;code&gt;feof&lt;/code&gt; returns zero. The next &lt;code&gt;&lt;a href=&quot;fgetc&quot;&gt;fgetc&lt;/a&gt;&lt;/code&gt; fails and changes the stream state to</source>
          <target state="translated">이 기능은 가장 최근의 I / O 작업에서보고 된 스트림 상태 만보고하며 연결된 데이터 소스는 검사하지 않습니다. 예를 들어, 가장 최근의 I / O가 파일의 마지막 바이트를 리턴 한 &lt;code&gt;&lt;a href=&quot;fgetc&quot;&gt;fgetc&lt;/a&gt;&lt;/code&gt; 이면 &lt;code&gt;feof&lt;/code&gt; 는 0을 리턴합니다. 다음 &lt;code&gt;&lt;a href=&quot;fgetc&quot;&gt;fgetc&lt;/a&gt;&lt;/code&gt; 가 실패하고 스트림 상태를</target>
        </trans-unit>
        <trans-unit id="5497fdd666555fbd47980c9e891c896338ff075a" translate="yes" xml:space="preserve">
          <source>This function reads &lt;a href=&quot;../../language/object&quot;&gt;object representations&lt;/a&gt;, not the object values, and is typically meaningful for byte arrays only: structs may have padding bytes whose values are indeterminate, the values of any bytes beyond the last stored member in a union are indeterminate, and a type may have two or more representations for the same value (different encodings for +0 and -0 or for +0.0 and &amp;ndash;0.0, indeterminate padding bits within the type).</source>
          <target state="translated">이 함수 는 객체 값이 아닌 &lt;a href=&quot;../../language/object&quot;&gt;객체 표현을&lt;/a&gt; 읽으며 일반적으로 바이트 배열에만 의미가 있습니다. 구조체에는 값이 결정되지 않는 패딩 바이트가있을 수 있으며 공용체에서 마지막으로 저장된 멤버를 넘어서는 바이트 값은 미정이며 유형은 동일한 값에 대해 두 개 이상의 표현을 갖습니다 (유형 내에서 불확실한 패딩 비트 +0 및 -0 또는 +0.0 및 &amp;ndash;0.0에 대한 다른 인코딩).</target>
        </trans-unit>
        <trans-unit id="a9bf69b22ca337dadc2c824c35f9f63e828aff82" translate="yes" xml:space="preserve">
          <source>This function returns a pointer to static data and is not thread-safe. POSIX marks this function obsolete and recommends &lt;code&gt;&lt;a href=&quot;strftime&quot;&gt;strftime&lt;/a&gt;&lt;/code&gt; instead. The C standard also recommends &lt;code&gt;&lt;a href=&quot;strftime&quot;&gt;strftime&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;asctime&lt;/code&gt; and &lt;code&gt;asctime_s&lt;/code&gt; because &lt;code&gt;strftime&lt;/code&gt; is more flexible and locale-sensitive.</source>
          <target state="translated">이 함수는 정적 데이터에 대한 포인터를 반환하며 스레드로부터 안전하지 않습니다. POSIX는이 기능을 더 이상 사용 하지 않으며 대신 &lt;code&gt;&lt;a href=&quot;strftime&quot;&gt;strftime&lt;/a&gt;&lt;/code&gt; 을 권장 합니다. &lt;code&gt;strftime&lt;/code&gt; 이 더 유연하고 로케일에 민감 하므로 C 표준 에서는 &lt;code&gt;asctime&lt;/code&gt; 및 &lt;code&gt;asctime_s&lt;/code&gt; 대신 &lt;code&gt;&lt;a href=&quot;strftime&quot;&gt;strftime&lt;/a&gt;&lt;/code&gt; 을 권장 합니다.</target>
        </trans-unit>
        <trans-unit id="2f2be7af8e841f9575c6ea1a25f265a05a0d98bc" translate="yes" xml:space="preserve">
          <source>This function's analog for byte strings is &lt;code&gt;&lt;a href=&quot;../byte/strncpy&quot;&gt;strncpy&lt;/a&gt;&lt;/code&gt;, not &lt;code&gt;&lt;a href=&quot;../byte/strcpy&quot;&gt;strcpy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">바이트 문자열이 기능의 아날로그은 &lt;code&gt;&lt;a href=&quot;../byte/strncpy&quot;&gt;strncpy&lt;/a&gt;&lt;/code&gt; 에서 ,하지 &lt;code&gt;&lt;a href=&quot;../byte/strcpy&quot;&gt;strcpy&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7e4ea005b5c762b68b78e66cb478bbb9f15f5ca" translate="yes" xml:space="preserve">
          <source>This is a &lt;a href=&quot;../language/generic&quot;&gt;generic function&lt;/a&gt; defined for all &lt;a href=&quot;../language/atomic&quot;&gt;atomic object types&lt;/a&gt;&lt;code&gt;A&lt;/code&gt;. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and &lt;a href=&quot;../language/volatile&quot;&gt;volatile&lt;/a&gt; (e.g. memory-mapped I/O) atomic variables.</source>
          <target state="translated">이것은 모든 &lt;a href=&quot;../language/atomic&quot;&gt;원자 객체 유형 &lt;/a&gt; &lt;code&gt;A&lt;/code&gt; 에 대해 정의 된 &lt;a href=&quot;../language/generic&quot;&gt;일반 함수&lt;/a&gt; 입니다. 이 인수는 비 휘발성 및 &lt;a href=&quot;../language/volatile&quot;&gt;휘발성&lt;/a&gt; (예 : 메모리 매핑 된 I / O) 원자 변수의 주소를 허용하는 휘발성 원자 유형에 대한 포인터 입니다.</target>
        </trans-unit>
        <trans-unit id="e181a8038634b4136f7fdead9b63de0740a42ba9" translate="yes" xml:space="preserve">
          <source>This is a &lt;a href=&quot;../language/generic&quot;&gt;generic function&lt;/a&gt; defined for all &lt;a href=&quot;../language/atomic&quot;&gt;atomic object types&lt;/a&gt;&lt;code&gt;A&lt;/code&gt;. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and &lt;a href=&quot;../language/volatile&quot;&gt;volatile&lt;/a&gt; (e.g. memory-mapped I/O) atomic variables.&lt;code&gt;C&lt;/code&gt; is the non-atomic type corresponding to &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">이것은 모든 &lt;a href=&quot;../language/atomic&quot;&gt;원자 객체 유형 &lt;/a&gt; &lt;code&gt;A&lt;/code&gt; 에 대해 정의 된 &lt;a href=&quot;../language/generic&quot;&gt;일반 함수&lt;/a&gt; 입니다. 이 인수는 비 휘발성 및 &lt;a href=&quot;../language/volatile&quot;&gt;휘발성&lt;/a&gt; (예 : 메모리 매핑 된 I / O) 원자 변수의 주소를 허용하는 휘발성 원자 유형에 대한 포인터 입니다. &lt;code&gt;C&lt;/code&gt; 는 &lt;code&gt;A&lt;/code&gt; 에 해당하는 비 원자 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="c9ced58fc25709f23b54d5a8febf8951bc9cad14" translate="yes" xml:space="preserve">
          <source>This is a &lt;a href=&quot;../language/generic&quot;&gt;generic function&lt;/a&gt; defined for all &lt;a href=&quot;../language/atomic&quot;&gt;atomic object types&lt;/a&gt;&lt;code&gt;A&lt;/code&gt;. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and &lt;a href=&quot;../language/volatile&quot;&gt;volatile&lt;/a&gt; (e.g. memory-mapped I/O) atomic variables.&lt;code&gt;C&lt;/code&gt; is the non-atomic type corresponding to &lt;code&gt;A&lt;/code&gt;..</source>
          <target state="translated">이것은 모든 &lt;a href=&quot;../language/atomic&quot;&gt;원자 객체 유형 &lt;/a&gt; &lt;code&gt;A&lt;/code&gt; 에 대해 정의 된 &lt;a href=&quot;../language/generic&quot;&gt;일반 함수&lt;/a&gt; 입니다. 이 인수는 비 휘발성 및 &lt;a href=&quot;../language/volatile&quot;&gt;휘발성&lt;/a&gt; (예 : 메모리 매핑 된 I / O) 원자 변수의 주소를 허용하는 휘발성 원자 유형에 대한 포인터 입니다. &lt;code&gt;C&lt;/code&gt; 는 &lt;code&gt;A&lt;/code&gt; 에 해당하는 비 원자 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="e969750390e2bd7552b0c9939a42fffba170be3a" translate="yes" xml:space="preserve">
          <source>This is a &lt;a href=&quot;../language/generic&quot;&gt;generic function&lt;/a&gt; defined for all &lt;a href=&quot;../language/atomic&quot;&gt;atomic object types&lt;/a&gt;&lt;code&gt;A&lt;/code&gt;. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and &lt;a href=&quot;../language/volatile&quot;&gt;volatile&lt;/a&gt; (e.g. memory-mapped I/O) atomic variables.&lt;code&gt;M&lt;/code&gt; is either the non-atomic type corresponding to &lt;code&gt;A&lt;/code&gt; if &lt;code&gt;A&lt;/code&gt; is atomic integer type, or &lt;code&gt;&lt;a href=&quot;../types/ptrdiff_t&quot;&gt;ptrdiff_t&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;A&lt;/code&gt; is atomic pointer type.</source>
          <target state="translated">이것은 모든 &lt;a href=&quot;../language/atomic&quot;&gt;원자 객체 유형 &lt;/a&gt; &lt;code&gt;A&lt;/code&gt; 에 정의 된 &lt;a href=&quot;../language/generic&quot;&gt;일반 함수&lt;/a&gt; 입니다. 인수는 비 휘발성 및 &lt;a href=&quot;../language/volatile&quot;&gt;휘발성&lt;/a&gt; (예 : 메모리 매핑 된 I / O) 원자 변수의 주소를 허용하는 휘발성 원자 유형에 대한 포인터 입니다. &lt;code&gt;M&lt;/code&gt; 은 하나에 대응하는 비 원자 타입 경우 &lt;code&gt;A&lt;/code&gt; 는 원자 정수형이거나, &lt;code&gt;&lt;a href=&quot;../types/ptrdiff_t&quot;&gt;ptrdiff_t&lt;/a&gt;&lt;/code&gt; 경우 &lt;code&gt;A&lt;/code&gt; 는 원자 포인터 타입이다. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f2b809c781f1dd40ccaa7e9909384069fc16d953" translate="yes" xml:space="preserve">
          <source>This is a convenience macro that makes it possible to use &lt;code&gt;float imaginary&lt;/code&gt;, &lt;code&gt;double imaginary&lt;/code&gt;, and &lt;code&gt;long double imaginary&lt;/code&gt; as an alternative way to write the three pure imaginary C types &lt;code&gt;float _Imaginary&lt;/code&gt;, &lt;code&gt;double _Imaginary&lt;/code&gt;, and &lt;code&gt;long double _Imaginary&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;float imaginary&lt;/code&gt; , &lt;code&gt;double imaginary&lt;/code&gt; 및 &lt;code&gt;long double imaginary&lt;/code&gt; 를 3 개의 순수 허수 C 유형 &lt;code&gt;float _Imaginary&lt;/code&gt; , &lt;code&gt;double _Imaginary&lt;/code&gt; 및 &lt;code&gt;long double _Imaginary&lt;/code&gt; 를 작성하는 대안으로 사용할 수있는 편의 매크로입니다 .</target>
        </trans-unit>
        <trans-unit id="e4229ef0621d5243c8579b95063d0e32f80e2588" translate="yes" xml:space="preserve">
          <source>This is a list of reserved keywords in C. Since they are used by the language, these keywords are not available for re-definition.</source>
          <target state="translated">이 키워드는 C로 예약 된 키워드의 목록입니다. 언어에서 사용되므로이 키워드를 다시 정의 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="db09d9c40cfbd787606a59adeb9a502f7781cbba" translate="yes" xml:space="preserve">
          <source>This is a reference of the core C language constructs.</source>
          <target state="translated">이것은 핵심 C 언어 구문에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="86a43046ffec5125bc8767c2110f2dc6b326902d" translate="yes" xml:space="preserve">
          <source>This is commonly used with the &lt;a href=&quot;restrict&quot;&gt;restrict&lt;/a&gt; type qualifier:</source>
          <target state="translated">이것은 일반적으로 &lt;a href=&quot;restrict&quot;&gt;제한&lt;/a&gt; 유형 한정자 와 함께 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="0d36f9177dcf527b56588facf919e3ece4cf5e27" translate="yes" xml:space="preserve">
          <source>This is the most optimal integer type for the platform, and is guaranteed to be at least 16 bits. Most current systems use 32 bits (see Data models below).</source>
          <target state="translated">이는 플랫폼에 가장 적합한 정수 유형이며 16 비트 이상이어야합니다. 대부분의 최신 시스템은 32 비트를 사용합니다 (아래 데이터 모델 참조).</target>
        </trans-unit>
        <trans-unit id="812af2a36c3f95774b9b7221df53591bbffef4a8" translate="yes" xml:space="preserve">
          <source>This is typically possible for the characters from the ASCII character set, since most multibyte encodings (such as UTF-8) use single bytes to encode those characters.</source>
          <target state="translated">UTF-8과 같은 대부분의 멀티 바이트 인코딩은 단일 문자를 사용하여 해당 문자를 인코딩하므로 일반적으로 ASCII 문자 집합의 문자에 가능합니다.</target>
        </trans-unit>
        <trans-unit id="a8a90074bad3bc54e82f4f7ddf4763be591f8a47" translate="yes" xml:space="preserve">
          <source>This keyword is also available as convenience macro &lt;a href=&quot;../error/static_assert&quot;&gt;&lt;code&gt;static_assert&lt;/code&gt;&lt;/a&gt;, available in the header &lt;code&gt;&amp;lt;assert.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이 키워드는 &lt;code&gt;&amp;lt;assert.h&amp;gt;&lt;/code&gt; 헤더에서 사용 가능한 편의 매크로 &lt;a href=&quot;../error/static_assert&quot;&gt; &lt;code&gt;static_assert&lt;/code&gt; &lt;/a&gt; 로도 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="8f3818c60dd5ef1e3857dbc5128a82d394bd645c" translate="yes" xml:space="preserve">
          <source>This keyword is also available as convenience macro &lt;a href=&quot;../types&quot;&gt;&lt;code&gt;alignas&lt;/code&gt;&lt;/a&gt;, available in the header &lt;code&gt;&amp;lt;stdalign.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이 키워드는 &lt;code&gt;&amp;lt;stdalign.h&amp;gt;&lt;/code&gt; 헤더에있는 편리한 매크로 &lt;a href=&quot;../types&quot;&gt; &lt;code&gt;alignas&lt;/code&gt; &lt;/a&gt; 로도 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="15e8ecfd0675839a3db53a82395e130694339dcc" translate="yes" xml:space="preserve">
          <source>This macro allows for the precise way to assemble a complex number from its real and imaginary components, e.g. with &lt;code&gt;(double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;)((double)x + _Imaginary_I * (double)y)&lt;/code&gt;. This pattern was standardized in C11 as the macro &lt;code&gt;&lt;a href=&quot;cmplx&quot;&gt;CMPLX&lt;/a&gt;&lt;/code&gt;. Note that if &lt;code&gt;&lt;a href=&quot;complex_i&quot;&gt;_Complex_I&lt;/a&gt;&lt;/code&gt; is used instead, this expression is allowed to convert negative zero to positive zero in the imaginary position.</source>
          <target state="translated">이 매크로를 사용하면 &lt;code&gt;(double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;)((double)x + _Imaginary_I * (double)y)&lt;/code&gt; 와 같이 실수 및 허수의 구성 요소에서 복소수를 정확하게 조립할 수 있습니다 . 이 패턴은 C11에서 매크로 &lt;code&gt;&lt;a href=&quot;cmplx&quot;&gt;CMPLX&lt;/a&gt;&lt;/code&gt; 로 표준화되었습니다 . 경우주의 &lt;code&gt;&lt;a href=&quot;complex_i&quot;&gt;_Complex_I&lt;/a&gt;&lt;/code&gt; 가 대신 사용됩니다,이 표현은 가상의 위치에 정의 제로에 부의 제로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="023f0d845cc1e4d3a0cf1393352c3051de4551a4" translate="yes" xml:space="preserve">
          <source>This macro detects the sign bit of zeroes, infinities, and NaNs. Along with &lt;code&gt;&lt;a href=&quot;copysign&quot;&gt;copysign&lt;/a&gt;&lt;/code&gt;, this macro is one of the only two portable ways to examine the sign of a NaN.</source>
          <target state="translated">이 매크로는 0, 무한대 및 NaN의 부호 비트를 감지합니다. 함께 &lt;code&gt;&lt;a href=&quot;copysign&quot;&gt;copysign&lt;/a&gt;&lt;/code&gt; ,이 매크로는 NaN이의 부호를 검사 할 수있는 두 개의 휴대용 방법 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="a3cb93fa29a939ad1bd07999da84e45d8cb15f21" translate="yes" xml:space="preserve">
          <source>This macro expands to a type specifier used to identify &lt;a href=&quot;../../language/arithmetic_types#Complex_floating_types&quot;&gt;complex types&lt;/a&gt;.</source>
          <target state="translated">이 매크로는 &lt;a href=&quot;../../language/arithmetic_types#Complex_floating_types&quot;&gt;복잡한 유형&lt;/a&gt; 을 식별하는 데 사용되는 유형 지정자로 확장됩니다 .</target>
        </trans-unit>
        <trans-unit id="6aae5edaddb18393f98f243eeeef3dce5c87a470" translate="yes" xml:space="preserve">
          <source>This macro expands to the keyword &lt;a href=&quot;../../keyword/_imaginary&quot;&gt;_Imaginary&lt;/a&gt;.</source>
          <target state="translated">이 매크로는 키워드 &lt;a href=&quot;../../keyword/_imaginary&quot;&gt;_Imaginary로&lt;/a&gt; 확장됩니다 .</target>
        </trans-unit>
        <trans-unit id="4eb4294230f13b4be30e04365483aa72ed1a0d15" translate="yes" xml:space="preserve">
          <source>This macro may be used when &lt;code&gt;I&lt;/code&gt; is not available, such as when it has been undefined by the application.</source>
          <target state="translated">때이 매크로를 사용할 수있다 &lt;code&gt;I&lt;/code&gt; 등이 응용 프로그램에 의해 정의되지 않은 된 경우와 같이 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="18ace75fad1f360f4336a3771cfb8db911e37fa5" translate="yes" xml:space="preserve">
          <source>This macro was a part of early draft design for C11 atomic types. It is not needed in C11, and is deprecated in C17 with plans to be removed in C2x.</source>
          <target state="translated">이 매크로는 C11 원자 유형에 대한 초기 초안 디자인의 일부였습니다. C11에서는 필요하지 않으며 C2x에서 제거 될 예정이므로 C17에서는 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a1e32004ae8fed464e4a25960c2972f60263328f" translate="yes" xml:space="preserve">
          <source>This operation is commonly implemented in hardware as &lt;a href=&quot;https://en.wikipedia.org/wiki/Multiply%E2%80%93accumulate_operation&quot;&gt;fused multiply-add&lt;/a&gt; CPU instruction. If supported by hardware, the appropriate FP_FAST_FMA* macros are expected to be defined, but many implementations make use of the CPU instruction even when the macros are not defined.</source>
          <target state="translated">이 작업은 일반적으로 하드웨어에 &lt;a href=&quot;https://en.wikipedia.org/wiki/Multiply%E2%80%93accumulate_operation&quot;&gt;fused multiply-add&lt;/a&gt; CPU 명령 으로 구현됩니다 . 하드웨어가 지원하는 경우 적절한 FP_FAST_FMA * 매크로가 정의 될 것으로 예상되지만 매크로가 정의되지 않은 경우에도 많은 구현에서 CPU 명령어를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9e79fdb6054a98950180ec5dde4644fc50b541ce" translate="yes" xml:space="preserve">
          <source>This operator is typically used through the convenience macro &lt;a href=&quot;../types&quot;&gt;&lt;code&gt;alignof&lt;/code&gt;&lt;/a&gt;, which is provided in the header &lt;code&gt;stdalign.h&lt;/code&gt;.</source>
          <target state="translated">이 오퍼레이터는 일반적으로 편리하게 사용 매크로 통해 &lt;a href=&quot;../types&quot;&gt; &lt;code&gt;alignof&lt;/code&gt; &lt;/a&gt; 헤더에 제공된다 &lt;code&gt;stdalign.h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce8f6e8c9fd40e6e31833711dbbb781eb59ce111" translate="yes" xml:space="preserve">
          <source>This optional extension to the C language limits the potential results of executing some forms of undefined behavior, which improves the effectiveness of static analysis of such programs. Analyzability is only guaranteed to be enabled if the &lt;a href=&quot;../preprocessor/replace&quot;&gt;predefined macro constant&lt;/a&gt;&lt;code&gt;__STDC_ANALYZABLE__&lt;/code&gt;(C11) is defined by the compiler.</source>
          <target state="translated">C 언어에 대한이 선택적 확장은 정의되지 않은 동작의 일부 형식을 실행할 때 발생할 수있는 결과를 제한하여 이러한 프로그램의 정적 분석 효과를 향상시킵니다. &lt;a href=&quot;../preprocessor/replace&quot;&gt;사전 정의 된 매크로 상수 &lt;/a&gt; &lt;code&gt;__STDC_ANALYZABLE__&lt;/code&gt; (C11)이 컴파일러에 의해 정의 된 경우에만 분석이 활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="74321edc083fa8a6c39f9d431ba4d565efc66119" translate="yes" xml:space="preserve">
          <source>This section provides definitions for the specific terminology and the concepts used when describing the C programming language.</source>
          <target state="translated">이 절에서는 특정 용어에 대한 정의와 C 프로그래밍 언어를 설명 할 때 사용되는 개념을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="94a2219ff6590395a027f7654f7033a84e305390" translate="yes" xml:space="preserve">
          <source>This special identifier is sometimes used in combination with the &lt;a href=&quot;../preprocessor/replace&quot;&gt;predefined macro constants&lt;/a&gt;&lt;code&gt;__FILE__&lt;/code&gt; and &lt;code&gt;__LINE__&lt;/code&gt;, for example, by &lt;code&gt;&lt;a href=&quot;../error/assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 특수 식별자는 &lt;a href=&quot;../preprocessor/replace&quot;&gt;사전 정의 된 매크로 상수 &lt;/a&gt; &lt;code&gt;__FILE__&lt;/code&gt; 및 &lt;code&gt;__LINE__&lt;/code&gt; 과 함께 사용되는 경우가 있습니다 (예 : &lt;code&gt;&lt;a href=&quot;../error/assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="a566611cbefba4805ca4f4043cbf2b2282bebff9" translate="yes" xml:space="preserve">
          <source>This specifier is typically used through the convenience macro &lt;a href=&quot;../types&quot;&gt;&lt;code&gt;noreturn&lt;/code&gt;&lt;/a&gt;, which is provided in the header &lt;code&gt;stdnoreturn.h&lt;/code&gt;.</source>
          <target state="translated">이 지정자는 일반적으로 편의 매크로 &lt;a href=&quot;../types&quot;&gt; &lt;code&gt;noreturn&lt;/code&gt; 을&lt;/a&gt; 통해 사용되며 , 이는 &lt;code&gt;stdnoreturn.h&lt;/code&gt; 헤더에 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="c7c6ad17c59c0162dbceca8860dddec46556c891" translate="yes" xml:space="preserve">
          <source>Thread library</source>
          <target state="translated">스레드 라이브러리</target>
        </trans-unit>
        <trans-unit id="859e6e5a070908c070449630fc5c93ccc9de646c" translate="yes" xml:space="preserve">
          <source>Thread storage duration</source>
          <target state="translated">스레드 저장 기간</target>
        </trans-unit>
        <trans-unit id="604ac3e54d45a1053374b3b32afdb7b25fbf1ed4" translate="yes" xml:space="preserve">
          <source>Thread support</source>
          <target state="translated">스레드 지원</target>
        </trans-unit>
        <trans-unit id="e2d8ff11421f3eaf1af17a9be19957f5569bce89" translate="yes" xml:space="preserve">
          <source>Thread support library</source>
          <target state="translated">스레드 지원 라이브러리</target>
        </trans-unit>
        <trans-unit id="ccd9cecfbe050ef8f7199536919145c98a9ee01e" translate="yes" xml:space="preserve">
          <source>Thread-local storage</source>
          <target state="translated">스레드 로컬 스토리지</target>
        </trans-unit>
        <trans-unit id="bb12e8aaaecc434fd51e448fe7669bced1bdd107" translate="yes" xml:space="preserve">
          <source>Threads</source>
          <target state="translated">Threads</target>
        </trans-unit>
        <trans-unit id="e7a80c12335015336479b7097a8b8db3ed660872" translate="yes" xml:space="preserve">
          <source>Threads and data races</source>
          <target state="translated">스레드와 데이터 레이스</target>
        </trans-unit>
        <trans-unit id="c43feecba43a30ac9fc0c134e6e8cb0382c660f2" translate="yes" xml:space="preserve">
          <source>Time manipulation</source>
          <target state="translated">시간 조작</target>
        </trans-unit>
        <trans-unit id="4f5801c83faefb52d8b0b1d0165948b2acc652f4" translate="yes" xml:space="preserve">
          <source>Time/date utilities</source>
          <target state="translated">시간 / 날짜 유틸리티</target>
        </trans-unit>
        <trans-unit id="3638c034bf7f420ee37fdfda08e7287a4fde3110" translate="yes" xml:space="preserve">
          <source>To avoid undefined behavior, the programmer must ensure that the aliasing assertions made by the restrict-qualified pointers are not violated.</source>
          <target state="translated">정의되지 않은 동작을 피하려면 프로그래머는 제한 규정 포인터로 작성된 앨리어싱 어설 션을 위반하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="0308792871c141a4861984782de04d99ed007497" translate="yes" xml:space="preserve">
          <source>To initialize a pointer to null or to assign the null value to an existing pointer, a null pointer constant (&lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, or any other integer constant with the value zero) may be used. &lt;a href=&quot;initialization&quot;&gt;static initialization&lt;/a&gt; also initializes pointers to their null values.</source>
          <target state="translated">널 (null)에 대한 포인터를 초기화하거나 널 (NULL) 값을 기존 포인터에 지정하기 위해 널 (null) 포인터 상수 ( &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 또는 값이 0 인 다른 정수 상수)를 사용할 수 있습니다. &lt;a href=&quot;initialization&quot;&gt;정적 초기화&lt;/a&gt; 는 또한 null 값에 대한 포인터를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="4a15bb607a0d9f65c2250157e2a839ed92b437f9" translate="yes" xml:space="preserve">
          <source>Top-level comma operator is also disallowed in array bounds.</source>
          <target state="translated">최상위 쉼표 연산자도 배열 범위에서 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="00914541a4417609db5b497e533746eecb783cd5" translate="yes" xml:space="preserve">
          <source>Total sequential ordering requires a full memory fence CPU instruction on all multi-core systems. This may become a performance bottleneck since it forces the affected memory accesses to propagate to every core.</source>
          <target state="translated">전체 순차 주문에는 모든 멀티 코어 시스템에서 전체 메모리 펜스 CPU 명령이 필요합니다. 영향을받는 메모리 액세스가 모든 코어에 전파되도록하기 때문에 성능 병목 현상이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46e6b018bf6b11f9dba2a0941a7aa6b16ebcda66" translate="yes" xml:space="preserve">
          <source>Transfers control unconditionally to the desired location.</source>
          <target state="translated">무조건 제어를 원하는 위치로 전송합니다.</target>
        </trans-unit>
        <trans-unit id="b482437ed63f1df61cce8a2acd92481bf3131a5e" translate="yes" xml:space="preserve">
          <source>Transforms the null-terminated byte string pointed to by &lt;code&gt;src&lt;/code&gt; into the implementation-defined form such that comparing two transformed strings with &lt;code&gt;&lt;a href=&quot;strcmp&quot;&gt;strcmp&lt;/a&gt;&lt;/code&gt; gives the same result as comparing the original strings with &lt;code&gt;&lt;a href=&quot;strcoll&quot;&gt;strcoll&lt;/a&gt;&lt;/code&gt;, in the current C locale.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 가 가리키는 널 종료 바이트 문자열을 구현 정의 양식으로 변환하여 두 개의 변환 된 문자열을 &lt;code&gt;&lt;a href=&quot;strcmp&quot;&gt;strcmp&lt;/a&gt;&lt;/code&gt; 와 비교 하면 현재 C 로케일에서 원래 문자열을 &lt;code&gt;&lt;a href=&quot;strcoll&quot;&gt;strcoll&lt;/a&gt;&lt;/code&gt; 과 비교하는 것과 동일한 결과를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="13e434293d4a04a3d618635cca12fbe14a8e43a1" translate="yes" xml:space="preserve">
          <source>Transforms the null-terminated wide string pointed to by &lt;code&gt;src&lt;/code&gt; into the implementation-defined form such that comparing two transformed strings with &lt;code&gt;&lt;a href=&quot;wcscmp&quot;&gt;wcscmp&lt;/a&gt;&lt;/code&gt; gives the same result as comparing the original strings with &lt;code&gt;&lt;a href=&quot;wcscoll&quot;&gt;wcscoll&lt;/a&gt;&lt;/code&gt;, in the current C locale.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 가 가리키는 널 종료 와이드 문자열을 구현 정의 양식으로 변환하여 두 개의 변환 된 문자열을 &lt;code&gt;&lt;a href=&quot;wcscmp&quot;&gt;wcscmp&lt;/a&gt;&lt;/code&gt; 와 비교 하면 현재 C 로케일에서 원래 문자열을 &lt;code&gt;&lt;a href=&quot;wcscoll&quot;&gt;wcscoll&lt;/a&gt;&lt;/code&gt; 과 비교하는 것과 동일한 결과를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4a101021db9dbdc21787f5f05cdb78df394c7c59" translate="yes" xml:space="preserve">
          <source>Translation limits</source>
          <target state="translated">번역 한도</target>
        </trans-unit>
        <trans-unit id="97ae6e6ddfa14e2bb949e4821dfd339e832124c2" translate="yes" xml:space="preserve">
          <source>Translation phases</source>
          <target state="translated">번역 단계</target>
        </trans-unit>
        <trans-unit id="9b1b19c48da84c8f1d5f977c8442d8b7f1fe8d0f" translate="yes" xml:space="preserve">
          <source>Tries to lock the mutex pointed to by &lt;code&gt;mutex&lt;/code&gt; without blocking. Returns immediately if the mutex is already locked.</source>
          <target state="translated">시도가 가리키는 뮤텍스 잠글 &lt;code&gt;mutex&lt;/code&gt; 차단하지 않고. 뮤텍스가 이미 잠겨 있으면 즉시 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b9e4c026492c440bf32166e0789393487d03b254" translate="yes" xml:space="preserve">
          <source>Trigonometric functions</source>
          <target state="translated">삼각 함수</target>
        </trans-unit>
        <trans-unit id="e719a16c184c9946c83f511d812044089e2e21c9" translate="yes" xml:space="preserve">
          <source>Trigraph</source>
          <target state="translated">Trigraph</target>
        </trans-unit>
        <trans-unit id="f08a08292325f4a3e0a8098c439550809ff5abe5" translate="yes" xml:space="preserve">
          <source>Trigraphs</source>
          <target state="translated">Trigraphs</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="f530d91391a69a7f0a5ffca3ec89a0e5873ccb85" translate="yes" xml:space="preserve">
          <source>Type cast</source>
          <target state="translated">캐스트</target>
        </trans-unit>
        <trans-unit id="6c1aa9cebe6e183271d6415c7410657e8ccc6473" translate="yes" xml:space="preserve">
          <source>Type classification</source>
          <target state="translated">타입 분류</target>
        </trans-unit>
        <trans-unit id="3903d0a0100dacebf5dcf7dd9edaed2ca7445692" translate="yes" xml:space="preserve">
          <source>Type groups</source>
          <target state="translated">유형 그룹</target>
        </trans-unit>
        <trans-unit id="39b26b192c35ccdbf713808e6519a061718950de" translate="yes" xml:space="preserve">
          <source>Type names</source>
          <target state="translated">타입 이름</target>
        </trans-unit>
        <trans-unit id="a612c634eb324c2736b08815ac8a0a1461bc8c70" translate="yes" xml:space="preserve">
          <source>Type names are used in the following situations:</source>
          <target state="translated">다음과 같은 상황에서 유형 이름이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5c3dec20e8df5a43918b8faf39633e46723561db" translate="yes" xml:space="preserve">
          <source>Type specifier</source>
          <target state="translated">타입 지정자</target>
        </trans-unit>
        <trans-unit id="ebdbe0be2297808a43109ed1cd29e12d3786ec7d" translate="yes" xml:space="preserve">
          <source>Type support</source>
          <target state="translated">타입 지원</target>
        </trans-unit>
        <trans-unit id="9877feb39d3467fd548f9afcf785d1120971dc32" translate="yes" xml:space="preserve">
          <source>Type-generic expression</source>
          <target state="translated">유형-일반 표현</target>
        </trans-unit>
        <trans-unit id="b0b12fc7b6daa3215c051192f5645eb17e2ae21a" translate="yes" xml:space="preserve">
          <source>Type-generic macro</source>
          <target state="translated">유형-일반 매크로</target>
        </trans-unit>
        <trans-unit id="dcd459fca026aec411accf6605fd9657b34f539e" translate="yes" xml:space="preserve">
          <source>Type-generic math</source>
          <target state="translated">유형-일반 수학</target>
        </trans-unit>
        <trans-unit id="667570999a748e91a3ca2389e2391bc9f38d4223" translate="yes" xml:space="preserve">
          <source>Typedef declaration</source>
          <target state="translated">Typedef 선언</target>
        </trans-unit>
        <trans-unit id="2efbc0a48c2cf8824f893117ca1ec4d3510f7e9e" translate="yes" xml:space="preserve">
          <source>Typedef name</source>
          <target state="translated">Typedef 이름</target>
        </trans-unit>
        <trans-unit id="9de7d443ce78183570b348b13d6fa7a62f5e82c3" translate="yes" xml:space="preserve">
          <source>Typedef names are also commonly used to simplify the syntax of complex declarations:</source>
          <target state="translated">Typedef 이름은 일반적으로 복잡한 선언의 구문을 단순화하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="93b9e289e2842469d001eccf7ad5d79f3c302dc9" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>
        </trans-unit>
        <trans-unit id="f2c7f86e6a072a5ffe548bdbdb59c9f7a208dd8a" translate="yes" xml:space="preserve">
          <source>Types allowed for integer constants</source>
          <target state="translated">정수 상수에 허용되는 유형</target>
        </trans-unit>
        <trans-unit id="1b555741394ae9339e15f18c3b6d7121a3052b4c" translate="yes" xml:space="preserve">
          <source>Typical use cases for this ordering involve read access to rarely written concurrent data structures (routing tables, configuration, security policies, firewall rules, etc) and publisher-subscriber situations with pointer-mediated publication, that is, when the producer publishes a pointer through which the consumer can access information: there is no need to make everything else the producer wrote to memory visible to the consumer (which may be an expensive operation on weakly-ordered architectures). An example of such scenario is &lt;a href=&quot;https://en.wikipedia.org/wiki/Read-copy-update&quot;&gt;rcu_dereference&lt;/a&gt;.</source>
          <target state="translated">이 순서의 일반적인 사용 사례에는 거의 작성되지 않은 동시 데이터 구조 (라우팅 테이블, 구성, 보안 정책, 방화벽 규칙 등)에 대한 읽기 액세스와 포인터가 중재 된 게시, 즉 생산자가 포인터를 통해 게시하는 게시자-구독자 상황이 포함됩니다. 소비자가 정보에 액세스 할 수 있음 : 생산자가 메모리에 작성한 다른 모든 것을 소비자가 볼 수 있도록 할 필요는 없습니다 (약한 순서의 아키텍처에서는 값 비싼 작업 일 수 있음). 이러한 시나리오의 예는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Read-copy-update&quot;&gt;rcu_dereference&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e9516dc93be7c971fcd17049638de54d997ca4a8" translate="yes" xml:space="preserve">
          <source>Typical use for relaxed memory ordering is incrementing counters, such as the reference counters , since this only requires atomicity, but not ordering or synchronization (note that decrementing the shared_ptr counters requires acquire-release synchronization with the destructor).</source>
          <target state="translated">완화 메모리 순서의 일반적인 사용은 참조 카운터와 같은 카운터 증가입니다. 이는 원 자성을 필요로하지만 순서 나 동기화는 필요하지 않기 때문에 (공유 _ptr 카운터를 감소 시키려면 소멸자와의 획득-릴리스 동기화가 필요합니다).</target>
        </trans-unit>
        <trans-unit id="b8eea246e8bae9254ad685bd7b3a0d93181f6ef8" translate="yes" xml:space="preserve">
          <source>Typically TSS is used to store pointers to blocks of dynamically allocated memory that have been reserved for use by the calling thread.</source>
          <target state="translated">일반적으로 TSS는 호출 스레드에서 사용하도록 예약 된 동적으로 할당 된 메모리 블록에 대한 포인터를 저장하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="57e2c95f58f57dd2510b427e263653b73348604c" translate="yes" xml:space="preserve">
          <source>U-prefixed wide string literals can be used to initialize arrays of any type compatible with (ignoring cv-qualifications &lt;code&gt;char32_t&lt;/code&gt;</source>
          <target state="translated">U 접두사 와이드 문자열 리터럴을 사용하여 호환 가능한 모든 유형의 배열을 초기화 할 수 있습니다 (cv-qualifications &lt;code&gt;char32_t&lt;/code&gt; 무시)</target>
        </trans-unit>
        <trans-unit id="02625f3ba5ef5ecc340624e8cdbc7bbea1792597" translate="yes" xml:space="preserve">
          <source>UB and optimization</source>
          <target state="translated">UB 및 최적화</target>
        </trans-unit>
        <trans-unit id="fc4cea3d19213a9f2ad0bf9e1d25fcd42a13416e" translate="yes" xml:space="preserve">
          <source>UCHAR_MAXUSHRT_MAXUINT_MAXULONG_MAXULLONG_MAX</source>
          <target state="translated">UCHAR_MAXUSHRT_MAXUINT_MAXULONG_MAXULLONG_MAX</target>
        </trans-unit>
        <trans-unit id="b326c17ee1a8eb3c225550246d3d3c78e82f8b2f" translate="yes" xml:space="preserve">
          <source>UINT8_CUINT16_CUINT32_CUINT64_C</source>
          <target state="translated">UINT8_CUINT16_CUINT32_CUINT64_C</target>
        </trans-unit>
        <trans-unit id="6fc76eff0c2b7cb02126a9c106ac3442a9727995" translate="yes" xml:space="preserve">
          <source>UINT8_MAXUINT16_MAXUINT32_MAXUINT64_MAX</source>
          <target state="translated">UINT8_MAXUINT16_MAXUINT32_MAXUINT64_MAX</target>
        </trans-unit>
        <trans-unit id="9ba6e74bce3dda604b2bb3467dd7e8066580c7b5" translate="yes" xml:space="preserve">
          <source>UINTMAX_C</source>
          <target state="translated">UINTMAX_C</target>
        </trans-unit>
        <trans-unit id="5b83709ee00794f8873850a1d8ed0fb42b4fb169" translate="yes" xml:space="preserve">
          <source>UINTMAX_MAX</source>
          <target state="translated">UINTMAX_MAX</target>
        </trans-unit>
        <trans-unit id="ce620a4e99af76df2964e767b6f8444400deb8ca" translate="yes" xml:space="preserve">
          <source>UINTPTR_MAX</source>
          <target state="translated">UINTPTR_MAX</target>
        </trans-unit>
        <trans-unit id="bfda17e335d33e8db92bdb55c45171d922a6859c" translate="yes" xml:space="preserve">
          <source>UINT_FAST8_MAXUINT_FAST16_MAXUINT_FAST32_MAXUINT_FAST64_MAX</source>
          <target state="translated">UINT_FAST8_MAXUINT_FAST16_MAXUINT_FAST32_MAXUINT_FAST64_MAX</target>
        </trans-unit>
        <trans-unit id="ad74c7ce12e14f74c8c414a0ec98ea6351f500a5" translate="yes" xml:space="preserve">
          <source>UINT_LEAST8_MAXUINT_LEAST16_MAXUINT_LEAST32_MAXUINT_LEAST64_MAX</source>
          <target state="translated">UINT_LEAST8_MAXUINT_LEAST16_MAXUINT_LEAST32_MAXUINT_LEAST64_MAX</target>
        </trans-unit>
        <trans-unit id="978310885d0047a2bbf93710be46a9692c211868" translate="yes" xml:space="preserve">
          <source>UTF-16 and UTF-32 character utilities</source>
          <target state="translated">UTF-16 및 UTF-32 문자 유틸리티</target>
        </trans-unit>
        <trans-unit id="e3121f2da5238f5445bc35f88607eb1340cef35d" translate="yes" xml:space="preserve">
          <source>UTF-8 string literal</source>
          <target state="translated">UTF-8 문자열 리터럴</target>
        </trans-unit>
        <trans-unit id="5f3e0d667a999aa457338ffa317c4bbb126755c9" translate="yes" xml:space="preserve">
          <source>Unary arithmetic</source>
          <target state="translated">단항 산술</target>
        </trans-unit>
        <trans-unit id="262592c99ae87d664d104863b6a975a077ca3383" translate="yes" xml:space="preserve">
          <source>Unary plus and minus</source>
          <target state="translated">단항 더하기 및 빼기</target>
        </trans-unit>
        <trans-unit id="de34c09eb59e18282b0464bd0bc5cfe7ba5ad888" translate="yes" xml:space="preserve">
          <source>Unblocks all thread that currently wait on condition variable pointed to by &lt;code&gt;cond&lt;/code&gt;. If no threads are blocked, does nothing and returns &lt;code&gt;thrd_success&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;cond&lt;/code&gt; 가 가리키는 조건 변수에서 현재 대기중인 모든 스레드를 차단 해제합니다 . 스레드가 차단되지 않으면 아무것도하지 않고 &lt;code&gt;thrd_success&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="9f7e568fb8b3fa778750d4687284053585644562" translate="yes" xml:space="preserve">
          <source>Unblocks one thread that currently waits on condition variable pointed to by &lt;code&gt;cond&lt;/code&gt;. If no threads are blocked, does nothing and returns &lt;code&gt;thrd_success&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;cond&lt;/code&gt; 가 가리키는 조건 변수에서 현재 대기중인 하나의 스레드를 차단 해제 합니다. 스레드가 차단되지 않으면 아무것도하지 않고 &lt;code&gt;thrd_success&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="ae22d7da41718d2107d501afa593d0dc097c049a" translate="yes" xml:space="preserve">
          <source>Undefined Behavior and Fermat&amp;rsquo;s Last Theorem</source>
          <target state="translated">정의되지 않은 행동과 페르마의 마지막 정리</target>
        </trans-unit>
        <trans-unit id="ebb35fed37a359f87ca6b9131bfd7b210eb81cd6" translate="yes" xml:space="preserve">
          <source>Undefined behavior</source>
          <target state="translated">정의되지 않은 동작</target>
        </trans-unit>
        <trans-unit id="675cd8702b8351b311d54416e35e1e88d24ddc83" translate="yes" xml:space="preserve">
          <source>Undefined behavior can result in time travel (among other things, but time travel is the funkiest)</source>
          <target state="translated">정의되지 않은 동작으로 인해 시간 여행이 발생할 수 있습니다 (다른 것들 중에서도 시간 여행이 가장 재미 있습니다)</target>
        </trans-unit>
        <trans-unit id="629edcbcf75dfc7ce2bd6d903269c3ab902f3f25" translate="yes" xml:space="preserve">
          <source>Underflow is guaranteed if &lt;code&gt;|arg| &amp;lt; &lt;a href=&quot;../../types/limits&quot;&gt;DBL_MIN&lt;/a&gt;*(&lt;a href=&quot;sqrt&quot;&gt;sqrt&lt;/a&gt;(&amp;pi;)/2)&lt;/code&gt;.  erf(</source>
          <target state="translated">언더 플로가있는 경우 보장 &lt;code&gt;|arg| &amp;lt; &lt;a href=&quot;../../types/limits&quot;&gt;DBL_MIN&lt;/a&gt;*(&lt;a href=&quot;sqrt&quot;&gt;sqrt&lt;/a&gt;(&amp;pi;)/2)&lt;/code&gt; . erf (</target>
        </trans-unit>
        <trans-unit id="5b4fe0953f656d5c3e07304963135e1851f6e5c7" translate="yes" xml:space="preserve">
          <source>Understanding Integer Overflow in C/C++</source>
          <target state="translated">C / C ++의 정수 오버플로 이해</target>
        </trans-unit>
        <trans-unit id="5e6066d0264c25a17abb92da4543d5a1bb3137db" translate="yes" xml:space="preserve">
          <source>Unevaluated expressions</source>
          <target state="translated">평가되지 않은 표현</target>
        </trans-unit>
        <trans-unit id="123f1fcb3edd17ce760e7f03ab6319443c344106" translate="yes" xml:space="preserve">
          <source>Unformatted input/output</source>
          <target state="translated">형식화되지 않은 입력 / 출력</target>
        </trans-unit>
        <trans-unit id="a1a52383b2bc722ac899de02954f212432e3b35b" translate="yes" xml:space="preserve">
          <source>Uninitialized scalar</source>
          <target state="translated">초기화되지 않은 스칼라</target>
        </trans-unit>
        <trans-unit id="669a8f132f6da5ef9c5ce154e361c127d5e3b34d" translate="yes" xml:space="preserve">
          <source>Union declaration</source>
          <target state="translated">연합 선언</target>
        </trans-unit>
        <trans-unit id="43b3c1af3450df3cd0e1ac52c9b04b756ccd01b6" translate="yes" xml:space="preserve">
          <source>Unix and Unix-like systems (Linux, Mac OS X)</source>
          <target state="translated">유닉스 및 유닉스 계열 시스템 (Linux, Mac OS X)</target>
        </trans-unit>
        <trans-unit id="fc9481ccc42310377001eaf4b65f0ba7f43291d9" translate="yes" xml:space="preserve">
          <source>Unless</source>
          <target state="translated">Unless</target>
        </trans-unit>
        <trans-unit id="b94d3063db2e039c2fe617cac39f892f9945b2d8" translate="yes" xml:space="preserve">
          <source>Unless &lt;a href=&quot;../preprocessor/impl&quot;&gt;&lt;code&gt; #pragma STDC FP_CONTRACT&lt;/code&gt;&lt;/a&gt; is set to &lt;code&gt;OFF&lt;/code&gt;, all floating-point arithmetic may be performed as if the intermediate results have infinite range and precision, that is optimizations that omit rounding errors and floating-point exceptions that would be observed if the expression was evaluated exactly as written. For example, allows the implementation of &lt;code&gt;(x*y) + z&lt;/code&gt; with a single fused multiply-add CPU instruction or optimization of &lt;code&gt;a = x*x*x*x;&lt;/code&gt; as &lt;code&gt;tmp = x*x; a = tmp*tmp&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../preprocessor/impl&quot;&gt; &lt;code&gt; #pragma STDC FP_CONTRACT&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;OFF&lt;/code&gt; 로 설정되어 있지 않으면 중간 결과에 무한 범위 및 정밀도가있는 것처럼 모든 부동 소수점 산술이 수행 될 수 있습니다. 즉, 반올림 오류를 생략하는 최적화 및 표현식을 평가할 때 관찰되는 부동 소수점 예외 쓰여진 그대로. 예를 들어, 단일의 융합 곱셈 추가 CPU 명령어 로 &lt;code&gt;(x*y) + z&lt;/code&gt; 를 구현 하거나 &lt;code&gt;a = x*x*x*x;&lt;/code&gt; 최적화 할 수 있습니다. 같은 &lt;code&gt;tmp = x*x; a = tmp*tmp&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b15a066b3b603647166b0b65f64183254893ada5" translate="yes" xml:space="preserve">
          <source>Unless a range error occurs, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; is never raised (the result is exact)</source>
          <target state="translated">범위 오류가 발생하지 않으면 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; 가 발생 하지 않습니다 (결과는 정확함 )</target>
        </trans-unit>
        <trans-unit id="9cb361932c4949b97f983057f3dae3e641beb697" translate="yes" xml:space="preserve">
          <source>Unless a range error occurs, the &lt;a href=&quot;../fenv/fe_round&quot;&gt;current rounding mode&lt;/a&gt; is ignored</source>
          <target state="translated">범위 오류가 발생하지 않으면 &lt;a href=&quot;../fenv/fe_round&quot;&gt;현재 반올림 모드&lt;/a&gt; 는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="a58fabd46910e7bcf45330fb949c04b6b27dee2e" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;function_declaration&quot;&gt;function declarations&lt;/a&gt;, unnamed formal parameters are not allowed, they must be named even if they are not used within the function. The only exception is the special parameter list &lt;code&gt;(void)&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;function_declaration&quot;&gt;함수 선언&lt;/a&gt; 과 달리 명명되지 않은 형식 매개 변수는 허용되지 않으며 함수 내에서 사용되지 않더라도 이름을 지정해야합니다. 유일한 예외는 특수 매개 변수 목록 &lt;code&gt;(void)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="59590d273656ea53ab0c485190687185f59c87d4" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;integer_constant&quot;&gt;integer constants&lt;/a&gt;, a character constant may have a negative value if &lt;code&gt;char&lt;/code&gt; is signed: on such implementations &lt;code&gt;'\xFF'&lt;/code&gt; is an &lt;code&gt;int&lt;/code&gt; with the value &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;integer_constant&quot;&gt;정수 상수&lt;/a&gt; 와 달리 &lt;code&gt;char&lt;/code&gt; 상수 가 서명 된 경우 문자 상수는 음수 값을 가질 수 있습니다 . 이러한 구현에서 &lt;code&gt;'\xFF'&lt;/code&gt; 는 값이 &lt;code&gt;-1&lt;/code&gt; 인 &lt;code&gt;int&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="d5893b9d3c3844337b6f481ce45fa24bcaf49949" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct&quot;&gt;struct&lt;/a&gt; or &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt;, there are no forward-declared enums in C:</source>
          <target state="translated">&lt;a href=&quot;struct&quot;&gt;struct&lt;/a&gt; 또는 &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt; 과 달리 C에는 앞으로 선언 된 열거 형이 없습니다.</target>
        </trans-unit>
        <trans-unit id="349921c60cca86b52b79297f58eff9fe42b04e26" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../byte/strtok&quot;&gt;strtok&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;wcstok&lt;/code&gt; does not update static storage: it stores the parser state in the user-provided location.</source>
          <target state="translated">달리 &lt;code&gt;&lt;a href=&quot;../byte/strtok&quot;&gt;strtok&lt;/a&gt;&lt;/code&gt; 를 , &lt;code&gt;wcstok&lt;/code&gt; 는 정적 저장 장치를 업데이트하지 않는다 : 이는 사용자 제공 위치에 파서 상태를 저장한다.</target>
        </trans-unit>
        <trans-unit id="4736d68a5eefa333a2087043cb0199117cb95803" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;imaginary_i&quot;&gt;_Imaginary_I&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;cmplx&quot;&gt;CMPLX&lt;/a&gt;&lt;/code&gt;, use of this macro to construct a complex number may lose the sign of zero on the imaginary component.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;imaginary_i&quot;&gt;_Imaginary_I&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;cmplx&quot;&gt;CMPLX&lt;/a&gt;&lt;/code&gt; 와 달리이 매크로를 사용하여 복소수를 구성하면 허수 부 구성 요소에서 0의 부호가 없어 질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="651147d7ee29a364b3441c1d65b4a589a7d4d5b1" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;strncpy&lt;/code&gt;, &lt;code&gt;strncpy_s&lt;/code&gt; does not pad the destination array with zeroes, This is a common source of errors when converting existing code to the bounds-checked version.</source>
          <target state="translated">달리 &lt;code&gt;strncpy&lt;/code&gt; , &lt;code&gt;strncpy_s&lt;/code&gt; 는 경계 - 체크 버전 기존 코드 변환하지 않을 때는 제로 패드와 대상 배열을 수행이 에러의 공통 소스이다.</target>
        </trans-unit>
        <trans-unit id="1809f65a8ac2a536dcff46fc36c71372570caec2" translate="yes" xml:space="preserve">
          <source>Unlike C++ (and some implementations of C), the increment/decrement expressions are never themselves lvalues: &lt;code&gt;&amp;amp;++a&lt;/code&gt; is invalid.</source>
          <target state="translated">C ++ (및 일부 C 구현)과 달리 증가 / 감소 표현식은 그 자체로 l 값이 아닙니다. &lt;code&gt;&amp;amp;++a&lt;/code&gt; 는 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="12d3be48bbe8c1161c3b11cb7b674b4d820d5f30" translate="yes" xml:space="preserve">
          <source>Unlike C++, C has no struct scope: names declared within a struct/union/enum declaration are in the same scope as the struct declaration (except that data members are in their own &lt;a href=&quot;name_space&quot;&gt;member name space&lt;/a&gt;):</source>
          <target state="translated">C ++와 달리 C에는 구조체 범위가 없습니다. struct / union / enum 선언 내에 선언 된 이름은 구조체 선언과 동일한 범위에 있습니다 (데이터 멤버가 자체 &lt;a href=&quot;name_space&quot;&gt;멤버 네임 스페이스에&lt;/a&gt; 있음을 제외하고 ).</target>
        </trans-unit>
        <trans-unit id="356cd0e4f851521f00fbf0ecd9e4515ffc02b0ad" translate="yes" xml:space="preserve">
          <source>Unlike functions, pointers to functions are objects and thus can be stored in arrays, copied, assigned, passed to other functions as arguments, etc.</source>
          <target state="translated">함수와 달리 함수에 대한 포인터는 객체이므로 배열에 저장, 복사, 할당, 인수 등의 다른 함수에 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fc1a9b3bf127389b70df7d40bbc2018c53338a0" translate="yes" xml:space="preserve">
          <source>Unlike header guards, this pragma makes it impossible to erroneously use the same macro name in more than one file. On the other hand, since with &lt;code&gt;#pragma once&lt;/code&gt; files are excluded based on their filesystem-level identity, this can't protect against including a header twice if it exists in more than one location in a project.</source>
          <target state="translated">헤더 보호와 달리이 pragma를 사용하면 둘 이상의 파일에서 동일한 매크로 이름을 잘못 사용할 수 없습니다. 반면, &lt;code&gt;#pragma once&lt;/code&gt; 파일 시스템 수준의 ID를 기반으로 파일이 제외되면 프로젝트에서 둘 이상의 위치에 존재하는 경우 헤더를 두 번 포함하는 것을 방지 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0ca9eab5e0c8d0f26634d969a4302dfd4432c351" translate="yes" xml:space="preserve">
          <source>Unlike in C++, enumeration constants are not struct members, and their name space is the name space of ordinary identifiers, and since there is no struct scope in C, their scope is the scope in which the struct declaration appears:</source>
          <target state="translated">C ++에서와 달리 열거 상수는 구조체 멤버가 아니며 네임 스페이스는 일반 식별자의 네임 스페이스이며 C에는 구조체 범위가 없으므로 해당 범위는 구조체 선언이 나타나는 범위입니다.</target>
        </trans-unit>
        <trans-unit id="7c5a2ac59cc1ae8f5f6a004185b87a1191bb07cb" translate="yes" xml:space="preserve">
          <source>Unlike in C++, the declarators &lt;code&gt;f()&lt;/code&gt; and &lt;code&gt;f(void)&lt;/code&gt; have different meaning: the declarator &lt;code&gt;f(void)&lt;/code&gt; is a new-style (prototype) declarator that declares a function that takes no parameters. The declarator &lt;code&gt;f()&lt;/code&gt; is an old-style (K&amp;amp;R) declarator that declares a function that takes</source>
          <target state="translated">C ++에서와 달리 선언자 &lt;code&gt;f()&lt;/code&gt; 와 &lt;code&gt;f(void)&lt;/code&gt; 는 다른 의미를 갖습니다. 선언자 &lt;code&gt;f(void)&lt;/code&gt; 는 매개 변수를 사용하지 않는 함수를 선언하는 새로운 스타일 (시제품) 선언자입니다. 선언자 &lt;code&gt;f()&lt;/code&gt; 는 구식 (K &amp;amp; R) 선언자이며,</target>
        </trans-unit>
        <trans-unit id="33e51c28a36bb5692baf427b5a9efad5cb27763c" translate="yes" xml:space="preserve">
          <source>Unlike in a &lt;a href=&quot;function_definition&quot;&gt;function definition&lt;/a&gt;, the parameter list may be inherited from a typedef.</source>
          <target state="translated">&lt;a href=&quot;function_definition&quot;&gt;함수 정의&lt;/a&gt; 와 달리 매개 변수 목록은 typedef에서 상속 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad19b0dd608c2e4f48c9ccaf5ff2ce720f3cee01" translate="yes" xml:space="preserve">
          <source>Unlike integers, not every floating value can be represented directly by decimal or even hexadecimal constant syntax: macros &lt;a href=&quot;../numeric/math/nan&quot;&gt;NAN&lt;/a&gt; and &lt;a href=&quot;../numeric/math/infinity&quot;&gt;INFINITY&lt;/a&gt; as well as functions such as &lt;code&gt;&lt;a href=&quot;../numeric/math/nan.2&quot;&gt;nan&lt;/a&gt;&lt;/code&gt; offer ways to generate those special values. Note that &lt;code&gt;0x1.FFFFFEp128f&lt;/code&gt;, which might appear to be an IEEE float NaN, in fact overflows to an infinity in that format.</source>
          <target state="translated">정수와 달리 모든 부동 값을 10 진수 또는 16 진 상수 구문으로 직접 표현할 수있는 것은 아닙니다. 매크로 &lt;a href=&quot;../numeric/math/nan&quot;&gt;NAN&lt;/a&gt; 및 &lt;a href=&quot;../numeric/math/infinity&quot;&gt;INFINITY&lt;/a&gt; 는 물론 &lt;code&gt;&lt;a href=&quot;../numeric/math/nan.2&quot;&gt;nan&lt;/a&gt;&lt;/code&gt; 과 같은 함수 는 이러한 특수 값을 생성하는 방법을 제공합니다. 하는 것으로 &lt;code&gt;0x1.FFFFFEp128f&lt;/code&gt; 표시 될 수 NaN의 사실에 해당 형식에 무한대로 오버 플로우는 IEEE 부동 소수점 수있다.</target>
        </trans-unit>
        <trans-unit id="69ccd347acbb0fdbbb094496aea02f3e7e062a71" translate="yes" xml:space="preserve">
          <source>Unlike most bounds-checked functions, &lt;code&gt;wctomb_s&lt;/code&gt; does not null-terminate its output, because it is designed to be used in loops that process strings character-by-character.</source>
          <target state="translated">대부분의 바운드 검사 기능과 달리 &lt;code&gt;wctomb_s&lt;/code&gt; 는 출력을 널 (null)로 종료하지 않습니다. 이는 문자별로 문자열을 처리하는 루프에서 사용되도록 설계 되었기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="c348ec3650d4d97ed9bc09e83c2572c81d376d68" translate="yes" xml:space="preserve">
          <source>Unlike most other tokenizers, the delimiters in &lt;code&gt;strtok&lt;/code&gt; can be different for each subsequent token, and can even depend on the contents of the previous tokens.</source>
          <target state="translated">대부분의 다른 토크 나이저와 달리 &lt;code&gt;strtok&lt;/code&gt; 의 구분 기호는 각 후속 토큰마다 다를 수 있으며 이전 토큰의 내용에 따라 달라질 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="06aee15412aa0900def31255838a5e2cad48a89e" translate="yes" xml:space="preserve">
          <source>Unlike most other tokenizers, the delimiters in &lt;code&gt;wcstok&lt;/code&gt; can be different for each subsequent token, and can even depend on the contents of the previous tokens.</source>
          <target state="translated">대부분의 다른 토크 나이저와 달리 &lt;code&gt;wcstok&lt;/code&gt; 의 구분 기호는 각 후속 토큰마다 다를 수 있으며 이전 토큰의 내용에 따라 달라질 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="550d0e8f0b2b95fd2ac25cd6e94e1fb04406548e" translate="yes" xml:space="preserve">
          <source>Unlike other bounds-checked functions, &lt;code&gt;bsearch_s&lt;/code&gt; does not treat arrays of zero size as a runtime constraint violation and instead indicates element not found (the other function that accepts arrays of zero size is &lt;code&gt;qsort_s&lt;/code&gt;).</source>
          <target state="translated">다른 경계 검사 함수와 달리 &lt;code&gt;bsearch_s&lt;/code&gt; 는 0 크기의 배열을 런타임 제약 조건 위반으로 취급하지 않고 대신 요소를 찾을 수 없음을 나타냅니다 (0 크기의 배열을 허용하는 다른 함수는 &lt;code&gt;qsort_s&lt;/code&gt; 입니다 ).</target>
        </trans-unit>
        <trans-unit id="32d3f5c043019688f561e38eab05f0332818d6f4" translate="yes" xml:space="preserve">
          <source>Unlike other bounds-checked functions, &lt;code&gt;qsort_s&lt;/code&gt; does not treat arrays of zero size as a runtime constraint violation and instead returns successfully without altering the array (the other function that accepts arrays of zero size is &lt;code&gt;bsearch_s&lt;/code&gt;).</source>
          <target state="translated">다른 경계 검사 함수와 달리 &lt;code&gt;qsort_s&lt;/code&gt; 는 크기가 0 인 배열을 런타임 제약 조건 위반으로 처리하지 않고 대신 배열을 변경하지 않고 성공적으로 반환합니다 (0 크기의 배열을 허용하는 다른 함수는 &lt;code&gt;bsearch_s&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="984a93ca0ecf9fa1964f4d81ad49bb3ad5b9d8cf" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;a href=&quot;storage_duration&quot;&gt;extern&lt;/a&gt; declarations, which don't change the linkage of an identifier if a previous declaration established it, tentative definitions may disagree in linkage with another declaration of the same identifier. If two declarations for the same identifier are in scope and have different linkage, the behavior is undefined:</source>
          <target state="translated">이전 선언에서 설정 한 경우 식별자의 연결을 변경하지 않는 &lt;a href=&quot;storage_duration&quot;&gt;extern&lt;/a&gt; 선언 과 달리 임시 정의는 동일한 식별자의 다른 선언과 연관되지 않을 수 있습니다. 동일한 식별자에 대한 두 개의 선언이 범위 내에 있고 서로 다른 연결이있는 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7d1d42fef2cdf2c3dc389a3d7fa95ed1b3f519b3" translate="yes" xml:space="preserve">
          <source>Unlike with integer constant expressions, static initializer expressions are not required to be evaluated at compile time; the compiler is at liberty to turn such initializers into executable code which is invoked prior to program startup.</source>
          <target state="translated">정수 상수 표현식과 달리 정적 초기화 표현식은 컴파일 타임에 평가할 필요가 없습니다. 컴파일러는 이러한 초기화 프로그램을 실행 가능한 코드로 전환하여 프로그램 시작 전에 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a515ca56a7b59ccaaa0047994f7aaf01c66be46c" translate="yes" xml:space="preserve">
          <source>Unlocks the mutex pointed to by &lt;code&gt;mutex&lt;/code&gt;.</source>
          <target state="translated">뮤텍스 잠금 해제가 가리키는 &lt;code&gt;mutex&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6106cd24d3eb45fe60ce901f8033bf3f6920c45" translate="yes" xml:space="preserve">
          <source>Unrelated to contracting, intermediate results of floating-point arithmetic may have range and precision that is different from the one indicated by its type, see &lt;code&gt;&lt;a href=&quot;../types/limits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">계약과 관련이없는 부동 소수점 산술의 중간 결과는 해당 유형으로 표시된 것과 다른 범위와 정밀도를 가질 수 있습니다 ( &lt;code&gt;&lt;a href=&quot;../types/limits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="e58bf16bb4075ebd2ecdad4cd86deb15d7942bb7" translate="yes" xml:space="preserve">
          <source>Unsigned integer arithmetic is always performed modulo 2n</source>
          <target state="translated">부호없는 정수 산술은 항상 모듈로 2n을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="1569ce9087643318f5b374c7177d610cac24614f" translate="yes" xml:space="preserve">
          <source>Unsigned integers : maximum value</source>
          <target state="translated">부호없는 정수 : 최대 값</target>
        </trans-unit>
        <trans-unit id="c72090771977fd06391926398abf4a074c68cada" translate="yes" xml:space="preserve">
          <source>Until &lt;code&gt;bsearch_s&lt;/code&gt;, users of &lt;code&gt;bsearch&lt;/code&gt; often used global variables to pass additional context to the comparison function.</source>
          <target state="translated">까지 &lt;code&gt;bsearch_s&lt;/code&gt; , 사용자 &lt;code&gt;bsearch&lt;/code&gt; 는 종종 비교 함수에 추가 컨텍스트를 전달하는 글로벌 변수를 사용했다.</target>
        </trans-unit>
        <trans-unit id="6714c3477fc3d9e9c5f8289c7130549e931d78ed" translate="yes" xml:space="preserve">
          <source>Until &lt;code&gt;qsort_s&lt;/code&gt;, users of &lt;code&gt;qsort&lt;/code&gt; often used global variables to pass additional context to the comparison function.</source>
          <target state="translated">&lt;code&gt;qsort_s&lt;/code&gt; 까지 , &lt;code&gt;qsort&lt;/code&gt; 사용자는 종종 전역 변수를 사용하여 추가 컨텍스트를 비교 함수에 전달했습니다.</target>
        </trans-unit>
        <trans-unit id="4775c7ec33060fa8ab3b09a08a0e950ff95cd91b" translate="yes" xml:space="preserve">
          <source>Until C99, selection and iteration statements did not establish their own block scopes (although if a compound statement was used in the statement, it had its usual block scope):</source>
          <target state="translated">C99까지는 선택 및 반복문이 자체 블록 범위를 설정하지 않았습니다 (문에서 복합 명령문이 사용되었지만 일반적인 블록 범위를 가짐).</target>
        </trans-unit>
        <trans-unit id="9655f2afef6652d4bb5e5cdc7b77f082cd7603dd" translate="yes" xml:space="preserve">
          <source>Until C99, the rounding direction of the quotient and the sign of the remainder in the built-in division and remainder operators was implementation-defined if either of the operands was negative, but it was well-defined in &lt;code&gt;div&lt;/code&gt; and &lt;code&gt;ldiv&lt;/code&gt;.</source>
          <target state="translated">C99까지, 내장 분할 및 나머지 연산자에서 몫의 반올림 방향과 나머지의 부호는 피연산자 중 하나가 음수 인 경우 구현에 따라 정의되었지만 &lt;code&gt;div&lt;/code&gt; 및 &lt;code&gt;ldiv&lt;/code&gt; 에 잘 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8694ee78b82e3c86eff19bc94b95dd11e5aef085" translate="yes" xml:space="preserve">
          <source>Until standardized as &lt;code&gt;CLOCKS_PER_SEC&lt;/code&gt; in C89, this macro was sometimes known by its IEEE std 1003.1-1988 name &lt;code&gt;CLK_TCK&lt;/code&gt;: that name was not included in C89 and was removed from POSIX itself in 1996 over ambiguity with &lt;code&gt;_SC_CLK_TCK&lt;/code&gt;, which gives number of clocks per second for the function &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/times.html&quot;&gt;times()&lt;/a&gt;).</source>
          <target state="translated">C89에서 &lt;code&gt;CLOCKS_PER_SEC&lt;/code&gt; 로 표준화 될 때까지이 매크로는 IEEE std 1003.1-1988 이름 &lt;code&gt;CLK_TCK&lt;/code&gt; 에 의해 알려진 경우가 있습니다 .이 이름은 C89에 포함되지 않았으며 1996 년 POSIX 자체에서 &lt;code&gt;_SC_CLK_TCK&lt;/code&gt; 와의 모호성으로 제거되어 초당 클럭 수를 제공합니다. 함수 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/times.html&quot;&gt;times ()&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8226abfb543f59ee6038e13aaa63641c200612b9" translate="yes" xml:space="preserve">
          <source>Until standardized as &lt;code&gt;CLOCKS_PER_SEC&lt;/code&gt; in C89, this macro was sometimes known by its IEEE std 1003.1-1988 name &lt;code&gt;CLK_TCK&lt;/code&gt;: that name was not included in C89 and was removed from POSIX itself in 1996 over ambiguity with &lt;code&gt;_SC_CLK_TCK&lt;/code&gt;, which gives number of clocks per second for the function &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/times.html&quot;&gt;times()&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b89113dfc8c9140feeca3a6303fca59eb658148" translate="yes" xml:space="preserve">
          <source>Upon return to the scope of setjmp, all accessible objects, floating-point status flags, and other components of the abstract machine have the same values as they had when longjmp was executed, except for the non-&lt;a href=&quot;../language/volatile&quot;&gt;volatile&lt;/a&gt; local variables in setjmp's scope, whose values are indeterminate if they have been changed since the setjmp invocation.</source>
          <target state="translated">setjmp의 범위로 돌아 오면 액세스 가능한 모든 객체, 부동 소수점 상태 플래그 및 추상 기계의 기타 구성 요소는 setjmp 범위 의 비 &lt;a href=&quot;../language/volatile&quot;&gt;휘발성&lt;/a&gt; 로컬 변수를 제외하고 longjmp가 실행될 때와 동일한 값을 갖습니다 . setjmp 호출 이후에 값이 변경되면 값이 결정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="30e91e701960bb8a2f2ddc9e70cec3e0f356f152" translate="yes" xml:space="preserve">
          <source>Uppercase version of &lt;code&gt;ch&lt;/code&gt; or unmodified &lt;code&gt;ch&lt;/code&gt; if no uppercase version is listed in the current C locale.</source>
          <target state="translated">의 대문자 버전 &lt;code&gt;ch&lt;/code&gt; 또는 수정되지 않은 &lt;code&gt;ch&lt;/code&gt; 더 대문자 버전은 현재 C 로케일에 표시되지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="59fdbe5f2786a81f9155555038f8f7073977bb9a" translate="yes" xml:space="preserve">
          <source>Uppercase version of &lt;code&gt;wc&lt;/code&gt; or unmodified &lt;code&gt;wc&lt;/code&gt; if no uppercase version is listed in the current C locale.</source>
          <target state="translated">현재 C 로케일에 대문자 버전이 나열 되지 않으면 &lt;code&gt;wc&lt;/code&gt; 의 대문자 버전 또는 수정되지 않은 &lt;code&gt;wc&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="c7a274cde92cd914ce94247b07c6f39a38fa46a4" translate="yes" xml:space="preserve">
          <source>Usage patterns</source>
          <target state="translated">사용 패턴</target>
        </trans-unit>
        <trans-unit id="7806efb19f32242dcbb9bc5ad35692f5e2036028" translate="yes" xml:space="preserve">
          <source>Used as a shorter equivalent of &lt;a href=&quot;while&quot;&gt;while loop&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;while&quot;&gt;while 루프&lt;/a&gt; 보다 짧은 것으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="5a1c568d8c824c8779a7fbd4ddf0353bf241da96" translate="yes" xml:space="preserve">
          <source>Used fields</source>
          <target state="translated">중고 필드</target>
        </trans-unit>
        <trans-unit id="0411cff330fe1f926e098add76bac8d23f3a24cd" translate="yes" xml:space="preserve">
          <source>Used when actual size of the object must be known.</source>
          <target state="translated">객체의 실제 크기를 알아야 할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cd3a7677f14605e188f81a1607ce0b998a59e8fc" translate="yes" xml:space="preserve">
          <source>Used when it is otherwise awkward to ignore the remaining portion of the loop using conditional statements.</source>
          <target state="translated">조건문을 사용하여 루프의 나머지 부분을 무시하는 것이 어색한 경우에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="73641814b8ae560f3493eb824a0db1bde1f528d6" translate="yes" xml:space="preserve">
          <source>Used when it is otherwise awkward to terminate the loop using the condition expression and conditional statements.</source>
          <target state="translated">조건 표현식과 조건문을 사용하여 루프를 종료하는 것이 어색한 경우에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="eb04de0c41b2213edcba796ec880d9c69993d1a3" translate="yes" xml:space="preserve">
          <source>Used when it is otherwise impossible to transfer control to the desired location using conventional constructs.</source>
          <target state="translated">그렇지 않으면 기존 구성을 사용하여 원하는 위치로 제어를 전달할 수없는 경우에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="90fd08578221610e26a4e01b9e26db5ba6dd2586" translate="yes" xml:space="preserve">
          <source>Used where code needs to be executed only if some condition is true.</source>
          <target state="translated">어떤 조건이 참인 경우에만 코드를 실행해야하는 경우에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1036c46b05784fbc159479e3e12914f6c0a3dc61" translate="yes" xml:space="preserve">
          <source>Used where one or several out of many branches of code need to be executed according to an integral value.</source>
          <target state="translated">많은 코드 분기 중 하나 또는 여러 개가 정수 값에 따라 실행되어야하는 경우에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="817c84df09ec7c700161033133b1b1abc3ba7ae7" translate="yes" xml:space="preserve">
          <source>Uses of volatile</source>
          <target state="translated">휘발성의 사용</target>
        </trans-unit>
        <trans-unit id="4466cb0f0bd2e7e6b18e73876fb3869a2080fc6d" translate="yes" xml:space="preserve">
          <source>Usual arithmetic conversions</source>
          <target state="translated">일반적인 산술 변환</target>
        </trans-unit>
        <trans-unit id="268e0f35a1a78a980e701fb4508175cad117353e" translate="yes" xml:space="preserve">
          <source>VLA must have automatic storage duration. Pointers to VLA, but not VLA themselves may also have static storage duration. No VM type may have linkage.</source>
          <target state="translated">VLA에는 자동 저장 기간이 있어야합니다. VLA 자체가 아닌 VLA에 대한 포인터도 고정 저장 기간을 가질 수 있습니다. VM 유형에 연결이 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8dce170de238b1feda2ecd9674ea3ca0d068fbcb" translate="yes" xml:space="preserve">
          <source>Value</source>
          <target state="translated">Value</target>
        </trans-unit>
        <trans-unit id="de0430a56abae1a9c8cca4fd7a8b8906769e0636" translate="yes" xml:space="preserve">
          <source>Value categories</source>
          <target state="translated">가치 범주</target>
        </trans-unit>
        <trans-unit id="44ee88d7a37283ed3f2e5c6bb77a69fd4b4ff443" translate="yes" xml:space="preserve">
          <source>Value of &lt;code&gt;str&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 의 가치</target>
        </trans-unit>
        <trans-unit id="1c7cea36bd22384e74ce5693b3a96747824e4406" translate="yes" xml:space="preserve">
          <source>Value range</source>
          <target state="translated">가치 범위</target>
        </trans-unit>
        <trans-unit id="af99e0d3d72b238f81c500119ae328f4acda13dc" translate="yes" xml:space="preserve">
          <source>Value transformations</source>
          <target state="translated">가치 변환</target>
        </trans-unit>
        <trans-unit id="6366acbba5e8e95bc0cae7ccba336b43ea8e9f5e" translate="yes" xml:space="preserve">
          <source>Variable arguments</source>
          <target state="translated">변수 인수</target>
        </trans-unit>
        <trans-unit id="1f5bf7a8e6972b2c8450b8b839e8d800d7313ad1" translate="yes" xml:space="preserve">
          <source>Variable-length arrays</source>
          <target state="translated">가변 길이 배열</target>
        </trans-unit>
        <trans-unit id="1967c897d235fbf77628efaec62c3448c89e2dfc" translate="yes" xml:space="preserve">
          <source>Variable-length arrays and the types derived from them (pointers to them, etc) are commonly known as &quot;variably-modified types&quot; (VM). Objects of any variably-modified type may only be declared at block scope or function prototype scope.</source>
          <target state="translated">가변 길이 배열과 그로부터 파생 된 유형 (포인터 등)은 일반적으로 &quot;가변 수정 유형&quot;(VM)으로 알려져 있습니다. 가변적으로 수정 된 유형의 객체는 블록 범위 또는 함수 프로토 타입 범위에서만 선언 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80cfadcd9fc8de8f2c49c35c4acd3c1d59f3d7ba" translate="yes" xml:space="preserve">
          <source>Variably-modified types cannot be members of structs or unions.</source>
          <target state="translated">다양하게 수정 된 유형은 구조체 또는 공용체의 멤버 일 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a8548e5a783f6964c2b71215ac2f1cf031c3e8a0" translate="yes" xml:space="preserve">
          <source>Variadic arguments</source>
          <target state="translated">잡색의 주장</target>
        </trans-unit>
        <trans-unit id="8e36a4956d4555b32607f272180c87deea209898" translate="yes" xml:space="preserve">
          <source>Variadic functions</source>
          <target state="translated">다양한 기능</target>
        </trans-unit>
        <trans-unit id="e3e170f0844bb573f925b5d4be5d7e11b8f4fb62" translate="yes" xml:space="preserve">
          <source>Variadic functions are functions (e.g. &lt;code&gt;&lt;a href=&quot;io/fprintf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;) which take a variable number of arguments.</source>
          <target state="translated">가변 함수는 가변 개수의 인수를 취하는 함수 (예 : &lt;code&gt;&lt;a href=&quot;io/fprintf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="b4932fa91d3f1b70f0c1d88911a981d4f9befca2" translate="yes" xml:space="preserve">
          <source>Variadic functions are functions that may be called with different number of arguments.</source>
          <target state="translated">가변 함수는 다른 수의 인수로 호출 될 수있는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="5519001c19e39db626b1e56d5b3636ed5b38cb6f" translate="yes" xml:space="preserve">
          <source>Version (2) of the &lt;code&gt;#define&lt;/code&gt; directive defines a simple function-like macro.</source>
          <target state="translated">&lt;code&gt;#define&lt;/code&gt; 지시문 의 버전 (2) 는 간단한 함수형 매크로를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="6478ed6591675d0474d581d305bfaf13be93f411" translate="yes" xml:space="preserve">
          <source>Version (3) of the &lt;code&gt;#define&lt;/code&gt; directive defines a function-like macro with variable number of arguments. The additional arguments can be accessed using &lt;code&gt;__VA_ARGS__&lt;/code&gt; identifier, which is then replaced with arguments, supplied with the identifier to be replaced.</source>
          <target state="translated">&lt;code&gt;#define&lt;/code&gt; 지시문 의 버전 (3)은 가변 개수의 인수로 함수형 매크로를 정의합니다. 추가 인수는 &lt;code&gt;__VA_ARGS__&lt;/code&gt; 식별자를 사용하여 액세스 할 수 있으며 , 대체 식별자와 함께 제공된 인수로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="60259716427bec2d4678682eccad9fa820f8bb67" translate="yes" xml:space="preserve">
          <source>Version (4) of the &lt;code&gt;#define&lt;/code&gt; directive defines a function-like macro with variable number of arguments, but no regular arguments. The arguments can be accessed only with &lt;code&gt;__VA_ARGS__&lt;/code&gt; identifier, which is then replaced with arguments, supplied with identifier to be replaced.</source>
          <target state="translated">&lt;code&gt;#define&lt;/code&gt; 지시문 의 버전 (4)는 가변 개수의 인수를 사용하지만 정규 인수는없는 함수형 매크로를 정의합니다. 인수는 &lt;code&gt;__VA_ARGS__&lt;/code&gt; 식별자 로만 액세스 할 수 있으며 ,이 식별자는 인수로 대체되고 대체 할 식별자가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="c0bc38123ad63ab545d3b75627acdac77e9b79a6" translate="yes" xml:space="preserve">
          <source>WCHAR_MAX</source>
          <target state="translated">WCHAR_MAX</target>
        </trans-unit>
        <trans-unit id="04ea5fdfa0eae316269a47c7f10e8316337146a4" translate="yes" xml:space="preserve">
          <source>WCHAR_MIN</source>
          <target state="translated">WCHAR_MIN</target>
        </trans-unit>
        <trans-unit id="c37a74a6f2d73286ec534a439a5c059b13230ec6" translate="yes" xml:space="preserve">
          <source>WEOF</source>
          <target state="translated">WEOF</target>
        </trans-unit>
        <trans-unit id="8d070188c9052ddde44bc280e3aced3c983ed8c7" translate="yes" xml:space="preserve">
          <source>WINT_MAX</source>
          <target state="translated">WINT_MAX</target>
        </trans-unit>
        <trans-unit id="cb08e31a881a0bd7697665afb678cdce175c2f59" translate="yes" xml:space="preserve">
          <source>WINT_MIN</source>
          <target state="translated">WINT_MIN</target>
        </trans-unit>
        <trans-unit id="f82be68a7fb4e7dec88f27463de94ad355242ee5" translate="yes" xml:space="preserve">
          <source>Week</source>
          <target state="translated">Week</target>
        </trans-unit>
        <trans-unit id="17a74d187c8a04abdcb5c0a680b6e9d660e85fba" translate="yes" xml:space="preserve">
          <source>What Every C Programmer Should Know About Undefined Behavior #1/3</source>
          <target state="translated">정의되지 않은 행동 # 1 / 3에 대해 모든 C 프로그래머가 알아야 할 사항</target>
        </trans-unit>
        <trans-unit id="8b7904dfab491b34141248cdfa81f76b99500ce8" translate="yes" xml:space="preserve">
          <source>What Every C Programmer Should Know About Undefined Behavior #2/3</source>
          <target state="translated">정의되지 않은 행동 # 2 / 3에 대해 모든 C 프로그래머가 알아야 할 사항</target>
        </trans-unit>
        <trans-unit id="faec1f8b604ae7cb007c3f28c6244f78ba75f633" translate="yes" xml:space="preserve">
          <source>What Every C Programmer Should Know About Undefined Behavior #3/3</source>
          <target state="translated">정의되지 않은 행동 # 3 / 3에 대해 모든 C 프로그래머가 알아야 할 사항</target>
        </trans-unit>
        <trans-unit id="459f3e0733d6888e3e209b8bb7e51c8223f8fd00" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;initialization&quot;&gt;initializing&lt;/a&gt; an object of &lt;a href=&quot;array&quot;&gt;array&lt;/a&gt; type, the initializer must be either a &lt;a href=&quot;string_literal&quot;&gt;string literal&lt;/a&gt; (optionally enclosed in braces) or be a brace-enclosed list of initialized for array members:</source>
          <target state="translated">&lt;a href=&quot;array&quot;&gt;배열&lt;/a&gt; 유형 의 객체를 &lt;a href=&quot;initialization&quot;&gt;초기화&lt;/a&gt; 할 때 이니셜 라이저 는 &lt;a href=&quot;string_literal&quot;&gt;문자열 리터럴&lt;/a&gt; (선택적으로 중괄호로 묶음)이거나 중괄호로 묶인 배열 멤버 목록이어야합니다.</target>
        </trans-unit>
        <trans-unit id="fa50f94c71d27a1f5893686568c6c5949625b9d7" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;initialization&quot;&gt;initializing&lt;/a&gt; an object of &lt;a href=&quot;compatible_type#Type_groups&quot;&gt;scalar type&lt;/a&gt;, the initializer must be a single expression.</source>
          <target state="translated">&lt;a href=&quot;compatible_type#Type_groups&quot;&gt;스칼라 유형&lt;/a&gt; 의 객체를 &lt;a href=&quot;initialization&quot;&gt;초기화&lt;/a&gt; 할 때 이니셜 라이저 는 단일 표현식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="a6cf5af2f39d3cc2baf225fdca0f325b4a6eeec7" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;initialization&quot;&gt;initializing&lt;/a&gt; an object of &lt;a href=&quot;struct&quot;&gt;struct&lt;/a&gt; or &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt; type, the initializer must be a non-empty, brace-enclosed, comma-separated list of initializers for the members:</source>
          <target state="translated">&lt;a href=&quot;struct&quot;&gt;구조체&lt;/a&gt; 또는 &lt;a href=&quot;union&quot;&gt;공용체&lt;/a&gt; 유형 의 객체를 &lt;a href=&quot;initialization&quot;&gt;초기화&lt;/a&gt; 할 때 이니셜 라이저 는 비어 있지 않고 중괄호로 묶고 쉼표로 구분 된 멤버의 이니셜 라이저 목록이어야합니다.</target>
        </trans-unit>
        <trans-unit id="cc0170dca8716eb24882edf591a81dee83e562ee" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;#&lt;/code&gt; appears before &lt;code&gt;__VA_ARGS__&lt;/code&gt;, the entire expanded __VA_ARGS__ is enclosed in quotes:</source>
          <target state="translated">시 &lt;code&gt;#&lt;/code&gt; 이 나타납니다 전에 &lt;code&gt;__VA_ARGS__&lt;/code&gt; , 전체 확장 __VA_ARGS__은 따옴표로 묶여 :</target>
        </trans-unit>
        <trans-unit id="af346b85b4a3c47e96376bfa441357b9915299c0" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; macro is used the types of the arguments passed to the generic parameters determine which function is selected by the macro as described below. If the types of the arguments are not &lt;a href=&quot;../language/compatible_type#Compatible_types&quot;&gt;compatible&lt;/a&gt; with the parameter types of the selected function, the behavior is undefined (e.g. if a complex argument is passed into a real-only tgmath macro: &lt;code&gt;float &lt;a href=&quot;complex/complex&quot;&gt;complex&lt;/a&gt; fc; &lt;a href=&quot;math/ceil&quot;&gt;ceil&lt;/a&gt;(fc)&lt;/code&gt; or &lt;code&gt;double &lt;a href=&quot;complex/complex&quot;&gt;complex&lt;/a&gt; dc; double d; &lt;a href=&quot;math/fmax&quot;&gt;fmax&lt;/a&gt;(dc, d)&lt;/code&gt; are examples of undefined behavior).</source>
          <target state="translated">때 &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; 매크로 일반적인 매개 변수로 전달 된 인자의 종류를 사용하는 후술하는 바와 같이 매크로에 의해 선택되는 기능을 결정한다. 인수 유형이 선택한 함수의 매개 변수 유형과 &lt;a href=&quot;../language/compatible_type#Compatible_types&quot;&gt;호환&lt;/a&gt; 되지 않는 경우 동작이 정의되지 않습니다 (예 : 복합 인수가 실제 전용 tgmath 매크로에 전달되는 경우 : &lt;code&gt;float &lt;a href=&quot;complex/complex&quot;&gt;complex&lt;/a&gt; fc; &lt;a href=&quot;math/ceil&quot;&gt;ceil&lt;/a&gt;(fc)&lt;/code&gt; 또는 &lt;code&gt;double &lt;a href=&quot;complex/complex&quot;&gt;complex&lt;/a&gt; dc; double d; &lt;a href=&quot;math/fmax&quot;&gt;fmax&lt;/a&gt;(dc, d)&lt;/code&gt; 는 정의되지 않은 동작의 예입니다).</target>
        </trans-unit>
        <trans-unit id="4811bf90215855de12be0a426e5fdd66ceff8757" translate="yes" xml:space="preserve">
          <source>When a thread reads a value from a memory location, it may see the initial value, the value written in the same thread, or the value written in another thread. See &lt;code&gt;&lt;a href=&quot;../atomic/memory_order&quot;&gt;memory_order&lt;/a&gt;&lt;/code&gt; for details on the order in which writes made from threads become visible to other threads.</source>
          <target state="translated">스레드가 메모리 위치에서 값을 읽으면 초기 값, 동일한 스레드에 기록 된 값 또는 다른 스레드에 기록 된 값을 볼 수 있습니다. 스레드에서 &lt;code&gt;&lt;a href=&quot;../atomic/memory_order&quot;&gt;memory_order&lt;/a&gt;&lt;/code&gt; 쓰기가 다른 스레드에 표시되는 순서에 대한 자세한 내용 은 memory_order 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dbe54944a43bccf5cf205c899d78217a14037efa" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;eval_order&quot;&gt;evaluation&lt;/a&gt; of an expression writes to a memory location and another evaluation reads or modifies the same memory location, the expressions are said to</source>
          <target state="translated">표현식 의 &lt;a href=&quot;eval_order&quot;&gt;평가&lt;/a&gt; 가 메모리 위치에 쓰고 다른 평가가 동일한 메모리 위치를 읽거나 수정하는 경우 표현식은</target>
        </trans-unit>
        <trans-unit id="4d2d9b5843b2b14f889c96a5ed077d795aec2e22" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;identifier&quot;&gt;identifier&lt;/a&gt; is encountered in a C program, a lookup is performed to locate the &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt; that introduced that identifier and that is currently &lt;a href=&quot;scope&quot;&gt;in scope&lt;/a&gt;. C allows more than one declaration for the same identifier to be in scope simultaneously if these identifiers belong to different categories, called</source>
          <target state="translated">C 프로그램에서 &lt;a href=&quot;identifier&quot;&gt;식별자&lt;/a&gt; 가 발견 되면 해당 식별자 를 소개하고 현재 &lt;a href=&quot;scope&quot;&gt;범위에&lt;/a&gt; 있는 &lt;a href=&quot;declarations&quot;&gt;선언&lt;/a&gt; 을 찾기 위해 검색이 수행됩니다 . C는 이러한 식별자가 다른 범주에 속하는 경우 동일한 식별자에 대한 둘 이상의 선언이 동시에 범위 내에있을 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="e89dee51109e2fa03d1d15f4098f1b184fdd3f34" translate="yes" xml:space="preserve">
          <source>When an array is initialized with a brace-enclosed list of initializers, the first initializer in the list initializes the array element at index zero (unless a designator is specified)(since C99), and each subsequent initializer without a designator (since C99)initializes the array element at index one greater than the one initialized by the previous initializer.</source>
          <target state="translated">배열이 중괄호로 묶인 이니셜 라이저 목록으로 초기화되면 목록의 첫 번째 이니셜 라이저는 지정자가 지정되지 않은 한 (지정자가 지정되지 않은 경우) (C99 이후) 및 지정자가없는 각 후속 이니셜 라이저 (C99 이후)에서 배열 요소를 초기화합니다. 이전 이니셜 라이저가 초기화 한 것보다 하나 더 큰 인덱스의 배열 요소를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="a3ca42c383f5f0e2bd3033657dc8530a9eba5d3b" translate="yes" xml:space="preserve">
          <source>When an array type is used in a function parameter list, it is transformed to the corresponding pointer type: &lt;code&gt;int f(int a[2])&lt;/code&gt; and &lt;code&gt;int f(int* a)&lt;/code&gt; declare the same function. Since the function's actual parameter type is pointer type, a function call with an array argument performs array-to-pointer conversion; the size of the argument array is not available to the called function and must be passed explicitly:</source>
          <target state="translated">배열 매개 변수가 함수 매개 변수 목록에 사용되면 해당 포인터 유형으로 변환됩니다. &lt;code&gt;int f(int a[2])&lt;/code&gt; 및 &lt;code&gt;int f(int* a)&lt;/code&gt; 는 동일한 함수를 선언합니다. 함수의 실제 매개 변수 유형은 포인터 유형이므로 배열 인수를 사용한 함수 호출은 배열 간 포인터 변환을 수행합니다. 인수 배열의 크기는 호출 된 함수에서 사용할 수 없으며 명시 적으로 전달되어야합니다.</target>
        </trans-unit>
        <trans-unit id="a8cc939c2091fa611fac1f51ee6f986940b00b89" translate="yes" xml:space="preserve">
          <source>When an expression is used in the context where a value of a different type is expected,</source>
          <target state="translated">다른 유형의 값이 필요한 컨텍스트에서 표현식이 사용될 때,</target>
        </trans-unit>
        <trans-unit id="5c83a5d985c2238792f08da0fa782f6fc397cae6" translate="yes" xml:space="preserve">
          <source>When applied to an operand that has &lt;a href=&quot;struct&quot;&gt;structure&lt;/a&gt; or &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt; type, the result is the total number of bytes in such an object, including internal and trailing padding. The trailing padding is such that if the object were an element of an array, the alignment requirement of the next element of this array would be satisfied, in other words, sizeof(T) returns the size of an element of a T[] array.</source>
          <target state="translated">&lt;a href=&quot;struct&quot;&gt;구조&lt;/a&gt; 또는 &lt;a href=&quot;union&quot;&gt;공용체&lt;/a&gt; 유형 이있는 피연산자에 적용되면 결과는 내부 및 후행 패딩을 포함하여 이러한 오브젝트의 총 바이트 수입니다. 후행 패딩은 객체가 배열의 요소 인 경우이 배열의 다음 요소의 정렬 요구 사항이 충족되도록하는 것입니다. 즉, sizeof (T)는 T [] 배열의 요소 크기를 반환합니다. .</target>
        </trans-unit>
        <trans-unit id="cc704db980837263518025b9214e71556fed57f0" translate="yes" xml:space="preserve">
          <source>When casting between pointers (either object or function), if the original value is a null pointer value of its type, the result is the correct null pointer value for the target type.</source>
          <target state="translated">포인터 (객체 또는 함수)간에 캐스트 할 때 원래 값이 해당 유형의 널 포인터 값이면 결과는 대상 유형에 대한 올바른 널 포인터 값입니다.</target>
        </trans-unit>
        <trans-unit id="ec13aa43d382edec81c71f93b1f833341dd32db6" translate="yes" xml:space="preserve">
          <source>When designators are nested, the designators for the members follow the designators for the enclosing structs/unions/arrays. Within any nested bracketed initializer list, the outermost designator refers to the</source>
          <target state="translated">지정자가 내포 될 때 멤버의 지정자는 둘러싸는 구조체 / 연합 / 배열의 지정자를 따릅니다. 중첩 된 대괄호 이니셜 라이저 목록에서 가장 바깥 쪽 지정자는</target>
        </trans-unit>
        <trans-unit id="d3ec0511a34972ef6c3100af3407ac58d0149968" translate="yes" xml:space="preserve">
          <source>When initializing a &lt;a href=&quot;struct&quot;&gt;struct&lt;/a&gt;, the first initializer in the list initializes the first declared member (unless a designator is specified)(since C99), and all subsequent initializers without designators (since C99)initialize the struct members declared after the one initialized by the previous expression.</source>
          <target state="translated">&lt;a href=&quot;struct&quot;&gt;구조체를&lt;/a&gt; 초기화 할 때 목록의 첫 번째 이니셜 라이저는 첫 번째 선언 된 멤버를 지정합니다 (지정자가 지정되지 않은 한) (C99 이후), 지정자가없는 모든 후속 이니셜 라이저 (C99 이후)는 이전에 의해 초기화 된 구조체 멤버를 초기화합니다 표현.</target>
        </trans-unit>
        <trans-unit id="22e4620e60947af9c0a473fb0a8baeabfee382e6" translate="yes" xml:space="preserve">
          <source>When initializing a &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt;, the initializer list must have only one member, which initializes the first member of the union unless a designated initializer is used(since C99).</source>
          <target state="translated">&lt;a href=&quot;union&quot;&gt;공용체를&lt;/a&gt; 초기화 할 때 이니셜 라이저 목록에는 하나의 멤버 만 있어야하며, 지정된 이니셜 라이저가 사용되지 않는 한 (C99 이후) 공용체의 첫 번째 멤버를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="2b3a780fd7c8398e52211c025dc25e8366b96122" translate="yes" xml:space="preserve">
          <source>When initializing an array of unknown size, the largest subscript for which an initializer is specified determines the size of the array being declared.</source>
          <target state="translated">알 수없는 크기의 배열을 초기화 할 때 이니셜 라이저가 지정되는 가장 큰 아래 첨자는 선언되는 배열의 크기를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="6349ec69327a41a7f34afff23548abbfde4de09e" translate="yes" xml:space="preserve">
          <source>When initializing an atomic variable, any concurrent access, even through an atomic operation, is a data race (it may happen if the address is immediately passed to another thread with a &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_relaxed&lt;/a&gt;&lt;/code&gt; operation).</source>
          <target state="translated">원자 변수를 초기화 할 때 원자 연산을 통한 모든 동시 액세스는 데이터 레이스입니다 (주소가 &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_relaxed&lt;/a&gt;&lt;/code&gt; 연산 으로 다른 스레드로 즉시 전달되는 경우 발생할 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="4db3e8dc56995aba80c1b48bd4c3d6ff9b4e8eb7" translate="yes" xml:space="preserve">
          <source>When initializing an object of static or thread-local &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt;, every expression in the initializer must be a &lt;a href=&quot;constant_expression&quot;&gt;constant expression&lt;/a&gt; or &lt;a href=&quot;string_literal&quot;&gt;string literal&lt;/a&gt;.</source>
          <target state="translated">정적 또는 스레드 로컬 &lt;a href=&quot;storage_duration&quot;&gt;저장 기간&lt;/a&gt; 의 객체를 초기화 할 때 이니셜 라이저의 모든 표현식은 &lt;a href=&quot;constant_expression&quot;&gt;상수 표현식&lt;/a&gt; 또는 &lt;a href=&quot;string_literal&quot;&gt;문자열 리터럴&lt;/a&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="3fade3dd9c6dd385455b642a26cd93ce6d453eb8" translate="yes" xml:space="preserve">
          <source>When initializing objects of floating-point type, all computations for the objects with automatic &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt; are done as-if at execution time and are affected by the &lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;current rounding&lt;/a&gt;; floating-point errors are reported as specified in &lt;a href=&quot;../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;. For objects of static and thread-local storage duration, computations are done as-if at compile time, and no exceptions are raised:</source>
          <target state="translated">부동 소수점 유형의 객체를 초기화 할 때 자동 &lt;a href=&quot;storage_duration&quot;&gt;저장 시간&lt;/a&gt; 이 있는 객체의 모든 계산 은 실행시 그대로 수행되며 &lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;현재 반올림의&lt;/a&gt; 영향을받습니다 . 부동 소수점 오류는 &lt;a href=&quot;../numeric/math/math_errhandling&quot;&gt;math_errhandling에&lt;/a&gt; 지정된대로보고됩니다 . 정적 및 스레드 로컬 스토리지 지속 기간의 오브젝트의 경우 컴파일시 그대로 계산이 수행되며 예외는 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2fa8650712efe659cc0dd0339ead9630668b0570" translate="yes" xml:space="preserve">
          <source>When multiple alignas specifiers appear in the same declaration, the strictest one is used.</source>
          <target state="translated">여러 개의 alignas 지정자가 동일한 선언에 나타날 때 가장 엄격한 것이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8c1fe3bbe944df7601e6e76ed048cf63122a0a2d" translate="yes" xml:space="preserve">
          <source>When objects of &lt;a href=&quot;arithmetic_types#Integer_types&quot;&gt;integer types&lt;/a&gt; (short, int, long, long long) occupy multiple bytes, the use of those bytes is implementation-defined, but the two dominant implementations are</source>
          <target state="translated">&lt;a href=&quot;arithmetic_types#Integer_types&quot;&gt;정수 유형&lt;/a&gt; (short, int, long, long long)의 객체 가 여러 바이트를 차지하는 경우 해당 바이트 사용은 구현 정의되지만 두 가지 주요 구현은</target>
        </trans-unit>
        <trans-unit id="c0fcdf6257c6f5b63f77499931a12401e55fd130" translate="yes" xml:space="preserve">
          <source>When parsing an expression, an operator which is listed on some row will be bound tighter (as if by parentheses) to its arguments than any operator that is listed on a row further below it. For example, the expression &lt;code&gt;*p++&lt;/code&gt; is parsed as &lt;code&gt;*(p++)&lt;/code&gt;, and not as &lt;code&gt;(*p)++&lt;/code&gt;.</source>
          <target state="translated">식을 구문 분석 할 때 일부 행에 나열된 연산자는 그 아래 행에 나열된 연산자보다 괄호로 묶인 것처럼 인수에 더 밀접하게 바인딩됩니다. 예를 들어 &lt;code&gt;*p++&lt;/code&gt; 표현식 은 &lt;code&gt;(*p)++&lt;/code&gt; 가 아닌 &lt;code&gt;*(p++)&lt;/code&gt; 로 구문 분석됩니다 .</target>
        </trans-unit>
        <trans-unit id="f8b48f697df0e524fccfbe77ccb0c6aefdae765c" translate="yes" xml:space="preserve">
          <source>When parsing an incomplete floating-point value that ends in the exponent with no digits, such as parsing &lt;code&gt;&quot;100er&quot;&lt;/code&gt; with the conversion specifier &lt;code&gt;%f&lt;/code&gt;, the sequence &lt;code&gt;&quot;100e&quot;&lt;/code&gt; (the longest prefix of a possibly valid floating-point number) is consumed, resulting in a matching error (the consumed sequence cannot be converted to a floating-point number), with &lt;code&gt;&quot;r&quot;&lt;/code&gt; remaining. Some existing implementations do not follow this rule and roll back to consume only &lt;code&gt;&quot;100&quot;&lt;/code&gt;, leaving &lt;code&gt;&quot;er&quot;&lt;/code&gt;, e.g. &lt;a href=&quot;https://sourceware.org/bugzilla/show_bug.cgi?id=1765&quot;&gt;glibc bug 1765&lt;/a&gt;.</source>
          <target state="translated">변환 지정자 &lt;code&gt;%f&lt;/code&gt; &lt;code&gt;&quot;100er&quot;&lt;/code&gt; 구문 분석과 같이 숫자없이 지수로 끝나는 불완전한 부동 소수점 값을 구문 분석 할 때 &lt;code&gt;&quot;100e&quot;&lt;/code&gt; 시퀀스 (유효한 부동 소수점 숫자의 가장 긴 접 두부)가 사용됩니다. &lt;code&gt;&quot;r&quot;&lt;/code&gt; 이 남아 있으면 일치하는 오류 (소비 된 시퀀스를 부동 소수점 숫자로 변환 할 수 없음)가 발생합니다 . 일부 기존 구현은이 규칙을 따르지 않고 &lt;code&gt;&quot;100&quot;&lt;/code&gt; 만 소비하도록 롤백 하여 &lt;code&gt;&quot;er&quot;&lt;/code&gt; (예 : &lt;a href=&quot;https://sourceware.org/bugzilla/show_bug.cgi?id=1765&quot;&gt;glibc 버그 1765)를&lt;/a&gt; 남겨 둡니다 .</target>
        </trans-unit>
        <trans-unit id="7bd54443661e6fdf7c87f18bb32eddd2dd26a027" translate="yes" xml:space="preserve">
          <source>When passed to &lt;code&gt;&lt;a href=&quot;mtx_init&quot;&gt;mtx_init&lt;/a&gt;&lt;/code&gt;, identifies the type of a mutex to create.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mtx_init&quot;&gt;mtx_init&lt;/a&gt;&lt;/code&gt; 에 전달되면 작성할 뮤텍스의 유형을 식별합니다.</target>
        </trans-unit>
        <trans-unit id="e72802fb982f6c1ad80ec2312e0bb0f8ad1c000e" translate="yes" xml:space="preserve">
          <source>When signal handler is set to a function and a signal occurs, it is implementation defined whether &lt;code&gt;signal(sig, &lt;a href=&quot;sig_strategies&quot;&gt;SIG_DFL&lt;/a&gt;)&lt;/code&gt; will be executed immediately before the start of signal handler. Also, the implementation can prevent some implementation-defined set of signals from occurring while the signal handler runs.</source>
          <target state="translated">신호 처리기가 함수로 설정되고 신호가 발생하면 신호 처리기가 시작되기 직전에 &lt;code&gt;signal(sig, &lt;a href=&quot;sig_strategies&quot;&gt;SIG_DFL&lt;/a&gt;)&lt;/code&gt; 이 실행 될지 여부가 정의 된 구현 입니다. 또한 구현시 신호 처리기가 실행되는 동안 구현 정의 된 일부 신호 집합이 발생하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a82c7324d6d1f526ac5299ac166aafff69e4a350" translate="yes" xml:space="preserve">
          <source>When signed integer arithmetic operation overflows (the result does not fit in the result type), the behavior is undefined: it may wrap around according to the rules of the representation (typically 2's complement), it may trap on some platforms or due to compiler options (e.g. &lt;code&gt;-ftrapv&lt;/code&gt; in GCC and Clang), or may be completely &lt;a href=&quot;http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_14.html&quot;&gt;optimized out by the compiler&lt;/a&gt;.</source>
          <target state="translated">부호있는 정수 산술 연산이 오버플로되면 (결과가 결과 유형에 맞지 않음) 동작이 정의되지 않습니다. 표현 규칙 (일반적으로 2의 보수)에 따라 줄 바꿈 될 수 있으며 일부 플랫폼에서 또는 컴파일러로 인해 트랩 될 수 있습니다. 옵션 (예 &lt;code&gt;-ftrapv&lt;/code&gt; GCC와 연타)에, 또는 완전히 될 수도 &lt;a href=&quot;http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_14.html&quot;&gt;컴파일러에 의해 최적화&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5f0cf9abe0b614f53329302ad0d6b53be9c5214c" translate="yes" xml:space="preserve">
          <source>When the element type of an array is another array, it is said that the array is multidimensional:</source>
          <target state="translated">배열의 요소 유형이 다른 배열 인 경우 배열이 다차원이라고합니다.</target>
        </trans-unit>
        <trans-unit id="682985610ed3813bc3f241e4a1e4f302bb45d4c6" translate="yes" xml:space="preserve">
          <source>When used in a controlling expression of &lt;a href=&quot;../preprocessor/conditional&quot;&gt;#if&lt;/a&gt; or &lt;a href=&quot;../preprocessor/conditional&quot;&gt;#elif&lt;/a&gt;, all signed integer constants act as if they have type &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;intmax_t&lt;/a&gt;&lt;/code&gt; and all unsigned integer constants act as if they have type &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;uintmax_t&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../preprocessor/conditional&quot;&gt;#if&lt;/a&gt; 또는 &lt;a href=&quot;../preprocessor/conditional&quot;&gt;#elif&lt;/a&gt; 의 제어 표현식에 사용될 경우, 부호있는 모든 정수 상수는 마치 &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;intmax_t&lt;/a&gt;&lt;/code&gt; 유형 &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;uintmax_t&lt;/a&gt;&lt;/code&gt; 것처럼 작동하고 부호없는 정수는 모두 uintmax_t 유형 인 것처럼 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="d3fab87f570b0cb58044fb50de98b795acaec288" translate="yes" xml:space="preserve">
          <source>When used in a controlling expression of &lt;a href=&quot;../preprocessor/conditional&quot;&gt;#if&lt;/a&gt; or &lt;a href=&quot;../preprocessor/conditional&quot;&gt;#elif&lt;/a&gt;, character constants may be interpreted in terms of the source character set, the execution character set, or some other implementation-defined character set.</source>
          <target state="translated">&lt;a href=&quot;../preprocessor/conditional&quot;&gt;#if&lt;/a&gt; 또는 &lt;a href=&quot;../preprocessor/conditional&quot;&gt;#elif&lt;/a&gt; 의 제어 표현식에 사용될 때 문자 상수는 소스 문자 세트, 실행 문자 세트 또는 기타 구현 정의 문자 세트와 관련하여 해석 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dcf6e07c969001d8800b90077c7110e069a53418" translate="yes" xml:space="preserve">
          <source>When used in a declaration, the declared object will have its &lt;a href=&quot;object#Alignment&quot;&gt;alignment requirement&lt;/a&gt; set to.</source>
          <target state="translated">선언에 사용하면 선언 된 객체의 &lt;a href=&quot;object#Alignment&quot;&gt;정렬 요구 사항이&lt;/a&gt; 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="bc35db4c35982640cd7a0636a9c639111c104e41" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;fopen_s&lt;/code&gt; or &lt;code&gt;freopen_s&lt;/code&gt;, file access permissions for any file created with &quot;w&quot; or &quot;a&quot; prevents other users from accessing it. File access mode flag &lt;code&gt;&quot;u&quot;&lt;/code&gt; can optionally be prepended to any specifier that begins with &quot;w&quot; or &quot;a&quot;, to enable the default &lt;code&gt;fopen&lt;/code&gt; permissions. (C11)</source>
          <target state="translated">사용하는 경우 &lt;code&gt;fopen_s&lt;/code&gt; 또는 &lt;code&gt;freopen_s&lt;/code&gt; 를 액세스하는 또는 &quot;A&quot;방지 다른 사용자 &quot;w&quot;로 만든 파일, 파일 액세스 권한을. 파일 액세스 모드 플래그 &lt;code&gt;&quot;u&quot;&lt;/code&gt; 는 선택적으로 &quot;w&quot;또는 &quot;a&quot;로 시작하는 지정자 앞에 추가하여 기본 &lt;code&gt;fopen&lt;/code&gt; 권한 을 사용할 수 있습니다. (C11)</target>
        </trans-unit>
        <trans-unit id="9e95324a6a7f1f1327a0ab19897537cb091cc4e8" translate="yes" xml:space="preserve">
          <source>Where &lt;a href=&quot;../../language/object#Strict_aliasing&quot;&gt;strict aliasing&lt;/a&gt; prohibits examining the same memory as values of two different types, &lt;code&gt;memcpy&lt;/code&gt; may be used to convert the values.</source>
          <target state="translated">어디 &lt;a href=&quot;../../language/object#Strict_aliasing&quot;&gt;엄격한 앨리어싱이&lt;/a&gt; 두 가지 유형의 값과 동일한 메모리를 검사 금지, &lt;code&gt;memcpy&lt;/code&gt; 값을 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="452f408de6a7cd8281856de8e1f092cf8d55601a" translate="yes" xml:space="preserve">
          <source>Where &lt;a href=&quot;../../language/object#Strict_aliasing&quot;&gt;strict aliasing&lt;/a&gt; prohibits examining the same memory as values of two different types, &lt;code&gt;memmove&lt;/code&gt; may be used to convert the values.</source>
          <target state="translated">어디 &lt;a href=&quot;../../language/object#Strict_aliasing&quot;&gt;엄격한 앨리어싱이&lt;/a&gt; 두 가지 유형의 값과 동일한 메모리를 검사 금지, &lt;code&gt;memmove&lt;/code&gt; 는이 값을 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21adf3b284d45513b5e5712dbeaf87c035585467" translate="yes" xml:space="preserve">
          <source>Where the significand has the form.</source>
          <target state="translated">의의가있는 곳.</target>
        </trans-unit>
        <trans-unit id="27f62a551f15ff9c032031f756f94d148b497948" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; is raised by the mathematical library functions is unspecified in general, but may be explicitly specified in the description of the function (e.g. &lt;code&gt;&lt;a href=&quot;rint&quot;&gt;rint&lt;/a&gt;&lt;/code&gt; vs &lt;code&gt;&lt;a href=&quot;nearbyint&quot;&gt;nearbyint&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">수학적 라이브러리 함수에 의해 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; 가 발생 하는지 여부 는 일반적으로 지정되지 않지만 함수 설명에 명시 적으로 지정 될 수 있습니다 (예 : &lt;code&gt;&lt;a href=&quot;rint&quot;&gt;rint&lt;/a&gt;&lt;/code&gt; vs &lt;code&gt;&lt;a href=&quot;nearbyint&quot;&gt;nearbyint&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="01eb3e966dcce36b733ea8791c56e49db1a6416a" translate="yes" xml:space="preserve">
          <source>Whether a bit field can straddle an allocation unit boundary</source>
          <target state="translated">비트 필드가 할당 단위 경계를 넘어갈 수 있는지 여부</target>
        </trans-unit>
        <trans-unit id="ee54caa15a743254b67ada9f78d6f5a91a66fe21" translate="yes" xml:space="preserve">
          <source>Whether atomic types are permitted</source>
          <target state="translated">원자 유형이 허용되는지 여부</target>
        </trans-unit>
        <trans-unit id="edf5c52a70df7191bd2b181d0777b7c9622b6038" translate="yes" xml:space="preserve">
          <source>Whether bit fields of type &lt;code&gt;int&lt;/code&gt; are treated as signed or unsigned</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; 유형의 비트 필드가 부호있는 것으로 처리 되는지 또는 부호없는 것으로 처리 되는지</target>
        </trans-unit>
        <trans-unit id="feffb1ebd739adca8c1acd723648ceb50bfb3246" translate="yes" xml:space="preserve">
          <source>Whether or not the operation succeeds, the stream is no longer associated with a file, and the buffer allocated by &lt;code&gt;&lt;a href=&quot;setbuf&quot;&gt;setbuf&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;setvbuf&lt;/a&gt;&lt;/code&gt;, if any, is also disassociated and deallocated if automatic allocation was used.</source>
          <target state="translated">작업의 성공 여부에 관계없이 스트림은 더 이상 파일과 연결되지 않으며 자동 할당이 사용 된 경우 &lt;code&gt;&lt;a href=&quot;setbuf&quot;&gt;setbuf&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;setvbuf&lt;/a&gt;&lt;/code&gt; 에 의해 할당 된 버퍼 도 연결 해제되고 할당 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="f4fd7a2e9a399af45240637c0eda092aecfbc9a0" translate="yes" xml:space="preserve">
          <source>Whether types other than int, signed int, unsigned int, and _Bool are permitted</source>
          <target state="translated">int, signed int, unsigned int 및 _Bool 이외의 유형이 허용되는지 여부</target>
        </trans-unit>
        <trans-unit id="7259a07c162a5980a03092d887024ac563145697" translate="yes" xml:space="preserve">
          <source>While narrow strings provide &lt;code&gt;&lt;a href=&quot;fprintf&quot;&gt;snprintf&lt;/a&gt;&lt;/code&gt;, which makes it possible to determine the required output buffer size, there is no equivalent for wide strings (until C11's snwprintf_s), and in order to determine the buffer size, the program may need to call &lt;code&gt;swprintf&lt;/code&gt;, check the result value, and reallocate a larger buffer, trying again until successful.</source>
          <target state="translated">좁은 문자열은 &lt;code&gt;&lt;a href=&quot;fprintf&quot;&gt;snprintf&lt;/a&gt;&lt;/code&gt; 를 제공 하여 필요한 출력 버퍼 크기를 결정할 수 있지만 넓은 문자열 (C11의 snwprintf_s까지)에는 해당하지 않으며 버퍼 크기를 결정하려면 프로그램에서 &lt;code&gt;swprintf&lt;/code&gt; 를 호출해야 합니다. 결과 값을 얻고 더 큰 버퍼를 재 할당하여 성공할 때까지 다시 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="a5c61c737d0b53e6e2f5ec4314c3a6438910987b" translate="yes" xml:space="preserve">
          <source>While narrow strings provide &lt;code&gt;&lt;a href=&quot;vfprintf&quot;&gt;vsnprintf&lt;/a&gt;&lt;/code&gt;, which makes it possible to determine the required output buffer size, there is no equivalent for wide strings (until C11's vsnwprintf_s), and in order to determine the buffer size, the program may need to call &lt;code&gt;vswprintf&lt;/code&gt;, check the result value, and reallocate a larger buffer, trying again until successful.</source>
          <target state="translated">좁은 문자열은 &lt;code&gt;&lt;a href=&quot;vfprintf&quot;&gt;vsnprintf&lt;/a&gt;&lt;/code&gt; 를 제공 하여 필요한 출력 버퍼 크기를 결정할 수 있지만 넓은 문자열 (C11의 vsnwprintf_s까지)에는 해당하지 않으며 버퍼 크기를 결정하기 위해 프로그램은 &lt;code&gt;vswprintf&lt;/code&gt; 를 호출해야 합니다. 결과 값을 얻고 더 큰 버퍼를 재 할당하여 성공할 때까지 다시 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="b7402781ffeb31aaf9f29177f61c8ff4a0f44050" translate="yes" xml:space="preserve">
          <source>Wide character</source>
          <target state="translated">넓은 캐릭터</target>
        </trans-unit>
        <trans-unit id="1fb55327ce03b4f2af732e3d187f25baf551cf61" translate="yes" xml:space="preserve">
          <source>Wide character array manipulation</source>
          <target state="translated">넓은 문자 배열 조작</target>
        </trans-unit>
        <trans-unit id="f8ed0c5da0ad503c6f172f824d7c17ff8675a795" translate="yes" xml:space="preserve">
          <source>Widens a single-byte character &lt;code&gt;c&lt;/code&gt; (reinterpreted as &lt;code&gt;unsigned char&lt;/code&gt;) to its wide character equivalent.</source>
          <target state="translated">1 바이트 문자 &lt;code&gt;c&lt;/code&gt; ( &lt;code&gt;unsigned char&lt;/code&gt; 로 해석 됨 )를 넓은 문자로 확장합니다.</target>
        </trans-unit>
        <trans-unit id="3cf16972858ec6c71abfb6fa6d539bdbe451dbf6" translate="yes" xml:space="preserve">
          <source>Width in bits by data model</source>
          <target state="translated">데이터 모델 별 비트 폭</target>
        </trans-unit>
        <trans-unit id="0352671572d548b1b50beb4586216b4e3764d488" translate="yes" xml:space="preserve">
          <source>Win16 API</source>
          <target state="translated">Win16 API</target>
        </trans-unit>
        <trans-unit id="ae7fc6d8171e0e405ed2e200f1d2b5056d479b80" translate="yes" xml:space="preserve">
          <source>Win32 API</source>
          <target state="translated">Win32 API</target>
        </trans-unit>
        <trans-unit id="50f72286ea0c96bccbea595ccc66e3982412d267" translate="yes" xml:space="preserve">
          <source>Win64 API</source>
          <target state="translated">Win64 API</target>
        </trans-unit>
        <trans-unit id="84a4a9dac26edeb0330a247c9af1446aecf202e8" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;#pragma once&lt;/code&gt;, the same header appears as.</source>
          <target state="translated">으로 &lt;code&gt;#pragma once&lt;/code&gt; 같은 헤더로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="859458ff8d7a2c1367626ec3e6f5fe580dc0d8be" translate="yes" xml:space="preserve">
          <source>Within a &lt;a href=&quot;struct&quot;&gt;struct&lt;/a&gt; definition, an array of unknown size may appear as the last member (as long as there is at least one other named member), in which case it is a special case known as</source>
          <target state="translated">&lt;a href=&quot;struct&quot;&gt;구조체&lt;/a&gt; 정의 내에서 알 수없는 크기의 배열은 마지막 멤버로 나타날 수 있습니다 (다른 하나 이상의 명명 된 멤버가있는 경우).</target>
        </trans-unit>
        <trans-unit id="28e069819f560fd884671902093491d5e9bb760b" translate="yes" xml:space="preserve">
          <source>Within a scope, an identifier may designate more than one entity only if the entities are in different &lt;a href=&quot;name_space&quot;&gt;name spaces&lt;/a&gt;.</source>
          <target state="translated">범위 내에서, 엔티티가 다른 &lt;a href=&quot;name_space&quot;&gt;이름 공간에&lt;/a&gt; 있는 경우에만 식별자가 둘 이상의 엔티티를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4f799cd56e5a2e4e20f4f65e7ce12eb8f9226308" translate="yes" xml:space="preserve">
          <source>Within a struct object, addresses of its elements (and the addresses of the bit field allocation units) increase in order in which the members were defined. A pointer to a struct can be cast to a pointer to its first member (or, if the member is a bit field, to its allocation unit). Likewise, a pointer to the first member of a struct can be cast to a pointer to the enclosing struct. There may be unnamed padding between any two members of a struct or after the last member, but not before the first member. The size of a struct is at least as large as the sum of the sizes of its members.</source>
          <target state="translated">구조체 객체 내에서 요소의 주소 (및 비트 필드 할당 단위의 주소)는 멤버가 정의 된 순서대로 증가합니다. 구조체에 대한 포인터는 첫 번째 멤버 (또는 멤버가 비트 필드 인 경우 할당 단위)에 대한 포인터로 캐스트 될 수 있습니다. 마찬가지로, 구조체의 첫 번째 멤버에 대한 포인터는 둘러싸는 구조체에 대한 포인터로 캐스트 될 수 있습니다. 구조체의 두 멤버 사이 또는 마지막 멤버 뒤에 이름이없는 패딩이있을 수 있지만 첫 번째 멤버 앞에는 안됩니다. 구조체의 크기는 최소한 멤버 크기의 합보다 큽니다.</target>
        </trans-unit>
        <trans-unit id="c312de86feff370bca491c752177547a6ed543f3" translate="yes" xml:space="preserve">
          <source>Within a thread of execution, accesses (reads and writes) through &lt;a href=&quot;../language/volatile&quot;&gt;volatile lvalues&lt;/a&gt; cannot be reordered past observable side-effects (including other volatile accesses) that are separated by a sequence point within the same thread, but this order is not guaranteed to be observed by another thread, since volatile access does not establish inter-thread synchronization.</source>
          <target state="translated">실행 스레드 내에서 &lt;a href=&quot;../language/volatile&quot;&gt;휘발성 lvalue를&lt;/a&gt; 통한 액세스 (읽기 및 쓰기) 는 동일한 스레드 내에서 시퀀스 포인트로 분리 된 관찰 가능한 부작용 (다른 휘발성 액세스 포함)을 지나서 다시 정렬 할 수 없지만이 순서는 보장되지 않습니다. 휘발성 액세스는 스레드 간 동기화를 설정하지 않기 때문에 다른 스레드에 의해</target>
        </trans-unit>
        <trans-unit id="969826a89b84b4e4d551c53334e30be5ab3cd356" translate="yes" xml:space="preserve">
          <source>Within every function-body, the special predefined variable &lt;code&gt;__func__&lt;/code&gt; with block scope and static storage duration is available, as if defined immediately after the opening brace by.</source>
          <target state="translated">모든 함수 본문 내에서 블록 범위와 정적 저장 기간이 있는 특수 사전 정의 된 변수 &lt;code&gt;__func__&lt;/code&gt; 를 여는 중괄호 바로 다음에 정의 된 것처럼 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8023499cb58c4c109815a2d79ac5650829ddeda6" translate="yes" xml:space="preserve">
          <source>Within the body of a function that uses variadic arguments, the values of these arguments may be accessed using the &lt;a href=&quot;../variadic&quot;&gt;&amp;lt;stdarg.h&amp;gt; library facilities&lt;/a&gt;:</source>
          <target state="translated">variadic 인수를 사용하는 함수 본문에서 이러한 인수의 값은 &lt;a href=&quot;../variadic&quot;&gt;&amp;lt;stdarg.h&amp;gt; 라이브러리 기능을&lt;/a&gt; 사용하여 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="703acf324f8116b8c498a56c14125e1a93f6ae46" translate="yes" xml:space="preserve">
          <source>Within the function body, every parameter is an &lt;a href=&quot;value_category&quot;&gt;lvalue&lt;/a&gt; expression, they have automatic &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt; and &lt;a href=&quot;scope&quot;&gt;block scope&lt;/a&gt;. The layout of the parameters in memory (or if they are stored in memory at all) is unspecified: it is a part of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Calling_convention&quot;&gt;calling convention&lt;/a&gt;.</source>
          <target state="translated">함수 본문 내에서 모든 매개 변수는 &lt;a href=&quot;value_category&quot;&gt;lvalue&lt;/a&gt; 표현식이며 자동 &lt;a href=&quot;storage_duration&quot;&gt;저장 기간&lt;/a&gt; 및 &lt;a href=&quot;scope&quot;&gt;블록 범위가&lt;/a&gt; 있습니다. 메모리의 매개 변수 레이아웃 (또는 메모리에 저장되어있는 경우)은 지정되어 있지 않습니다. 이는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Calling_convention&quot;&gt;호출 규칙&lt;/a&gt; 의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="49fbad2db57b58d46114fa10a3190f7deba0831b" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;count&lt;/code&gt; of objects from the given array &lt;code&gt;buffer&lt;/code&gt; to the output stream &lt;code&gt;stream&lt;/code&gt;. The objects are written as if by reinterpreting each object as an array of &lt;code&gt;unsigned char&lt;/code&gt; and calling &lt;code&gt;&lt;a href=&quot;fputc&quot;&gt;fputc&lt;/a&gt;&lt;/code&gt;&lt;code&gt;size&lt;/code&gt; times for each object to write those &lt;code&gt;unsigned char&lt;/code&gt;s into &lt;code&gt;stream&lt;/code&gt;, in order. The file position indicator for the stream is advanced by the number of characters written.</source>
          <target state="translated">지정된 배열 &lt;code&gt;buffer&lt;/code&gt; 로부터 출력 스트림 에 객체 &lt;code&gt;count&lt;/code&gt; 를 기입 &lt;code&gt;stream&lt;/code&gt; . 각 객체는 &lt;code&gt;unsigned char&lt;/code&gt; 배열로 재 해석하고 각 객체에 대해 &lt;code&gt;&lt;a href=&quot;fputc&quot;&gt;fputc&lt;/a&gt;&lt;/code&gt; &lt;code&gt;size&lt;/code&gt; 시간을 호출 하여 &lt;code&gt;unsigned char&lt;/code&gt; 을 &lt;code&gt;stream&lt;/code&gt; 에 순서대로 기록함으로써 객체를 작성합니다 . 스트림의 파일 위치 표시기는 쓴 문자 수만큼 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="e87fd10313099f92edd69106267a002d4e8466a1" translate="yes" xml:space="preserve">
          <source>Writes a character &lt;code&gt;ch&lt;/code&gt; to &lt;code&gt;stdout&lt;/code&gt;. Internally, the character is converted to &lt;code&gt;unsigned char&lt;/code&gt; just before being written.</source>
          <target state="translated">문자 &lt;code&gt;ch&lt;/code&gt; 를 &lt;code&gt;stdout&lt;/code&gt; 에 씁니다 . 내부적으로 문자는 쓰기 직전 에 &lt;code&gt;unsigned char&lt;/code&gt; 문자로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="5869a84e9848e943c8c5fd069a261d745ada80d5" translate="yes" xml:space="preserve">
          <source>Writes a character &lt;code&gt;ch&lt;/code&gt; to the given output stream &lt;code&gt;stream&lt;/code&gt;. &lt;code&gt;putc()&lt;/code&gt; may be implemented as a macro and evaluate &lt;code&gt;stream&lt;/code&gt; more than once, so the corresponding argument should never be an expression with side effects.</source>
          <target state="translated">지정된 출력 스트림 &lt;code&gt;stream&lt;/code&gt; 문자 &lt;code&gt;ch&lt;/code&gt; 를 기입 합니다 . &lt;code&gt;putc()&lt;/code&gt; 는 매크로로 구현되어 &lt;code&gt;stream&lt;/code&gt; 두 번 이상 평가할 수 있으므로 해당 인수는 부작용이있는 표현식이되어서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="628a432848d3d2a0f439ca52671452d1eec4d9ff" translate="yes" xml:space="preserve">
          <source>Writes a wide character &lt;code&gt;ch&lt;/code&gt; to &lt;code&gt;stdout&lt;/code&gt;.</source>
          <target state="translated">넓은 문자 &lt;code&gt;ch&lt;/code&gt; 를 &lt;code&gt;stdout&lt;/code&gt; 에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="a61cc5af43d9f51fcd06a3cacfeb3348c1595940" translate="yes" xml:space="preserve">
          <source>Writes a wide character &lt;code&gt;ch&lt;/code&gt; to the given output stream &lt;code&gt;stream&lt;/code&gt;. &lt;code&gt;putwc()&lt;/code&gt; may be implemented as a macro and may evaluate &lt;code&gt;stream&lt;/code&gt; more than once.</source>
          <target state="translated">지정된 출력 스트림에 와이드 문자 &lt;code&gt;ch&lt;/code&gt; 를 기입 &lt;code&gt;stream&lt;/code&gt; . &lt;code&gt;putwc()&lt;/code&gt; 는 매크로로 구현 될 수 있으며 &lt;code&gt;stream&lt;/code&gt; 두 번 이상 평가할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c2f81c0bcaf9b63cee02a0581c7178cf0890849f" translate="yes" xml:space="preserve">
          <source>Writes an implementation-defined message to &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; which must include the string pointed to by &lt;code&gt;msg&lt;/code&gt; and calls &lt;code&gt;&lt;a href=&quot;../program/abort&quot;&gt;abort()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;msg&lt;/code&gt; 가 가리키는 문자열을 포함하고 &lt;code&gt;&lt;a href=&quot;../program/abort&quot;&gt;abort()&lt;/a&gt;&lt;/code&gt; 호출 해야하는 구현 정의 메시지를 &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; 에 기록합니다 .</target>
        </trans-unit>
        <trans-unit id="77fbd50411d6315927f25422863e722e33834996" translate="yes" xml:space="preserve">
          <source>Writes every character from the null-terminated string &lt;code&gt;str&lt;/code&gt; and one additional newline character &lt;code&gt;'\n'&lt;/code&gt; to the output stream &lt;code&gt;stdout&lt;/code&gt;, as if by repeatedly executing &lt;code&gt;&lt;a href=&quot;fputc&quot;&gt;fputc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;fputc&quot;&gt;fputc&lt;/a&gt;&lt;/code&gt; 를 반복적으로 실행하는 것처럼 null로 끝나는 문자열 &lt;code&gt;str&lt;/code&gt; 의 모든 문자 와 하나의 추가 줄 바꿈 문자 &lt;code&gt;'\n'&lt;/code&gt; 을 출력 스트림 &lt;code&gt;stdout&lt;/code&gt; 에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="9b38a38e83b8d315adcafdff09da46681f69740a" translate="yes" xml:space="preserve">
          <source>Writes every character from the null-terminated string &lt;code&gt;str&lt;/code&gt; to the output stream &lt;code&gt;stream&lt;/code&gt;, as if by repeatedly executing &lt;code&gt;&lt;a href=&quot;fputc&quot;&gt;fputc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;fputc&quot;&gt;fputc&lt;/a&gt;&lt;/code&gt; 를 반복적으로 실행하는 것처럼 널 종료 문자열 &lt;code&gt;str&lt;/code&gt; 에서 출력 스트림 &lt;code&gt;stream&lt;/code&gt; 모든 문자를 씁니다 .</target>
        </trans-unit>
        <trans-unit id="b28d781181727277b71446dfb72cdeed8c73d3e4" translate="yes" xml:space="preserve">
          <source>Writes every character from the null-terminated wide string &lt;code&gt;str&lt;/code&gt; to the output stream &lt;code&gt;stream&lt;/code&gt;, as if by repeatedly executing &lt;code&gt;&lt;a href=&quot;fputwc&quot;&gt;fputwc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;fputwc&quot;&gt;fputwc&lt;/a&gt;&lt;/code&gt; 를 반복적으로 실행하는 것처럼 null로 끝나는 와이드 문자열 &lt;code&gt;str&lt;/code&gt; 에서 출력 스트림 &lt;code&gt;stream&lt;/code&gt; 모든 문자를 씁니다 .</target>
        </trans-unit>
        <trans-unit id="d60cdb3a38da8a130cf91abef198ed0c8df65943" translate="yes" xml:space="preserve">
          <source>X and X appears before B in the Single Total Order</source>
          <target state="translated">단일 총 주문에서 X와 X가 B 앞에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="2f3f27dde1e0deeab004667545a65bef35394ab9" translate="yes" xml:space="preserve">
          <source>X argument</source>
          <target state="translated">X 논쟁</target>
        </trans-unit>
        <trans-unit id="6db6535836e6c904498ebb911985cfb1ab6cbadf" translate="yes" xml:space="preserve">
          <source>X, Y is</source>
          <target state="translated">X, Y는</target>
        </trans-unit>
        <trans-unit id="6ba655c53b7c6f7ad109ea6e30e446c19a1740b7" translate="yes" xml:space="preserve">
          <source>Y argument</source>
          <target state="translated">Y 논쟁</target>
        </trans-unit>
        <trans-unit id="879e32326c5217968ac8e3a14e4a8a5214957264" translate="yes" xml:space="preserve">
          <source>Year</source>
          <target state="translated">Year</target>
        </trans-unit>
        <trans-unit id="8152a5497cccb550fed6c13df95ac1947ae757e7" translate="yes" xml:space="preserve">
          <source>Zero if &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; compare equal, or if count is zero.</source>
          <target state="translated">제로 경우 &lt;code&gt;lhs&lt;/code&gt; 와 &lt;code&gt;rhs&lt;/code&gt; 동일한 비교 경우, 또는 카운트는 0이다.</target>
        </trans-unit>
        <trans-unit id="51c939bb7f5f0758dd76abfc0b3c05c623bebff7" translate="yes" xml:space="preserve">
          <source>Zero if &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; compare equal.</source>
          <target state="translated">&lt;code&gt;lhs&lt;/code&gt; 와 &lt;code&gt;rhs&lt;/code&gt; 가 동일한 경우 0 입니다.</target>
        </trans-unit>
        <trans-unit id="431ba1f7d46a244cebe6c0d684ca1e39d75e6ab0" translate="yes" xml:space="preserve">
          <source>Zero-length array declarations are not allowed, even though some compilers offer them as extensions (typically as a pre-C99 implementation of &lt;a href=&quot;struct&quot;&gt;flexible array members&lt;/a&gt;).</source>
          <target state="translated">길이가 0 인 배열 선언은 일부 컴파일러가이를 확장 (일반적으로 &lt;a href=&quot;struct&quot;&gt;유연한 배열 멤버&lt;/a&gt; 의 C99 이전 구현)으로 제공하더라도 허용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ca77598d8983f14f3898f59c121fdcf1e9e18087" translate="yes" xml:space="preserve">
          <source>[-]d.ddd</source>
          <target state="translated">[-]d.ddd</target>
        </trans-unit>
        <trans-unit id="913e7afee46c7a822906ed5749ddbb4805cee7d2" translate="yes" xml:space="preserve">
          <source>[-]ddd.ddd</source>
          <target state="translated">[-]ddd.ddd</target>
        </trans-unit>
        <trans-unit id="8c2b29412829eefb22455e55f53e2c249d24e11a" translate="yes" xml:space="preserve">
          <source>[-]dddd</source>
          <target state="translated">[-]dddd</target>
        </trans-unit>
        <trans-unit id="36886f5ee53771548cf5c86e4853a8dcf06d3e14" translate="yes" xml:space="preserve">
          <source>] radians, is returned.</source>
          <target state="translated">] 라디안이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="12ec352745ee599586db13a925319fe87a988295" translate="yes" xml:space="preserve">
          <source>], is returned.</source>
          <target state="translated">]가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3cb3417ca91352ca5e5ad839596b7b62a28b6c17" translate="yes" xml:space="preserve">
          <source>_Alignas</source>
          <target state="translated">_Alignas</target>
        </trans-unit>
        <trans-unit id="f7008bc87a6929c330fb4f709f0a2e6b754d59c3" translate="yes" xml:space="preserve">
          <source>_Alignas specifier</source>
          <target state="translated">_Alignas 지정자</target>
        </trans-unit>
        <trans-unit id="bda6adb87ec6691221ed73213de332b2c9474ce6" translate="yes" xml:space="preserve">
          <source>_Alignof</source>
          <target state="translated">_Alignof</target>
        </trans-unit>
        <trans-unit id="e7ddc52003557bd694ed510e05d8ffa47bfc7849" translate="yes" xml:space="preserve">
          <source>_Alignof operator</source>
          <target state="translated">_Alignof 연산자</target>
        </trans-unit>
        <trans-unit id="048effd77189bf393076ca1fcf73e53aaeff6d6d" translate="yes" xml:space="preserve">
          <source>_Atomic</source>
          <target state="translated">_Atomic</target>
        </trans-unit>
        <trans-unit id="3bd5f76b0997fbede5e7b3a7dad72c9e8f31308b" translate="yes" xml:space="preserve">
          <source>_Bool</source>
          <target state="translated">_Bool</target>
        </trans-unit>
        <trans-unit id="c20ed3009ec2e03e51793cfd518f6e77ee0fc814" translate="yes" xml:space="preserve">
          <source>_Complex</source>
          <target state="translated">_Complex</target>
        </trans-unit>
        <trans-unit id="403449942a1d68cb22e3a2df541b687d5192f4f7" translate="yes" xml:space="preserve">
          <source>_Complex_I</source>
          <target state="translated">_Complex_I</target>
        </trans-unit>
        <trans-unit id="5903c0497b4b6110dd3051a9b31ef948bae78c64" translate="yes" xml:space="preserve">
          <source>_Exit</source>
          <target state="translated">_Exit</target>
        </trans-unit>
        <trans-unit id="0fa07fc2f45d73e6843828483db383cbb81e135c" translate="yes" xml:space="preserve">
          <source>_Generic</source>
          <target state="translated">_Generic</target>
        </trans-unit>
        <trans-unit id="a86d3649d1b2b72954d70aa40f94f98858c527ba" translate="yes" xml:space="preserve">
          <source>_IOFBF_IOLBF_IONBF</source>
          <target state="translated">_IOFBF_IOLBF_IONBF</target>
        </trans-unit>
        <trans-unit id="b81882d762d1caccc4812c0eaa31886b66e6d1d9" translate="yes" xml:space="preserve">
          <source>_Imaginary</source>
          <target state="translated">_Imaginary</target>
        </trans-unit>
        <trans-unit id="b28c3530ddb62124dba16492b0964cb3e6186e5a" translate="yes" xml:space="preserve">
          <source>_Imaginary_I</source>
          <target state="translated">_Imaginary_I</target>
        </trans-unit>
        <trans-unit id="deb8ccf25fe4c28454012c03785eb57ded7283e7" translate="yes" xml:space="preserve">
          <source>_Noreturn</source>
          <target state="translated">_Noreturn</target>
        </trans-unit>
        <trans-unit id="ef06032cc9ad497cbe9512a26000e41f2e236bf4" translate="yes" xml:space="preserve">
          <source>_Noreturn function specifier</source>
          <target state="translated">_ 노턴 함수 지정자</target>
        </trans-unit>
        <trans-unit id="ccfa477ead56b2c88345b8173962b5f15db933a3" translate="yes" xml:space="preserve">
          <source>_Static_assert</source>
          <target state="translated">_Static_assert</target>
        </trans-unit>
        <trans-unit id="b796d6cb075e66b2fec2b6e79a80b0ede26d4cd1" translate="yes" xml:space="preserve">
          <source>_Thread_local</source>
          <target state="translated">_Thread_local</target>
        </trans-unit>
        <trans-unit id="1b22c1d687dc7c54339d14d0aa2284796291aec8" translate="yes" xml:space="preserve">
          <source>__DATE__</source>
          <target state="translated">__DATE__</target>
        </trans-unit>
        <trans-unit id="9d5d8995523b8b8951428baa81ea663ff0bd2c77" translate="yes" xml:space="preserve">
          <source>__FILE__</source>
          <target state="translated">__FILE__</target>
        </trans-unit>
        <trans-unit id="a51b95694c81c92580bff6f580f8e200ecf86661" translate="yes" xml:space="preserve">
          <source>__LINE__</source>
          <target state="translated">__LINE__</target>
        </trans-unit>
        <trans-unit id="a6d131d3c4073efb4f54ca94b64fdf5ebf0001ec" translate="yes" xml:space="preserve">
          <source>__STDC_ANALYZABLE__</source>
          <target state="translated">__STDC_ANALYZABLE__</target>
        </trans-unit>
        <trans-unit id="51f3c9479afc9737ac0812162dcb10cc18fbbd51" translate="yes" xml:space="preserve">
          <source>__STDC_HOSTED__</source>
          <target state="translated">__STDC_HOSTED__</target>
        </trans-unit>
        <trans-unit id="9b62494894b2be9bf94a226b2a93df702d06518d" translate="yes" xml:space="preserve">
          <source>__STDC_IEC_559_COMPLEX__</source>
          <target state="translated">__STDC_IEC_559_COMPLEX__</target>
        </trans-unit>
        <trans-unit id="1f0d02915700fe3497cf0ffb2cb5539415b60c57" translate="yes" xml:space="preserve">
          <source>__STDC_IEC_559__</source>
          <target state="translated">__STDC_IEC_559__</target>
        </trans-unit>
        <trans-unit id="aa16038a596c275e6fffc69644dbad7ec1a3ceb3" translate="yes" xml:space="preserve">
          <source>__STDC_ISO_10646__</source>
          <target state="translated">__STDC_ISO_10646__</target>
        </trans-unit>
        <trans-unit id="5ffa704ce725aadaecae2a04eb767b6de640c9ec" translate="yes" xml:space="preserve">
          <source>__STDC_LIB_EXT1__</source>
          <target state="translated">__STDC_LIB_EXT1__</target>
        </trans-unit>
        <trans-unit id="230648d096a182990dad2c93fa8e616a0bed8465" translate="yes" xml:space="preserve">
          <source>__STDC_MB_MIGHT_NEQ_WC__</source>
          <target state="translated">__STDC_MB_MIGHT_NEQ_WC__</target>
        </trans-unit>
        <trans-unit id="fc7e5fe991a21e7e3d1f456399d4028544f5c6da" translate="yes" xml:space="preserve">
          <source>__STDC_NO_ATOMICS__</source>
          <target state="translated">__STDC_NO_ATOMICS__</target>
        </trans-unit>
        <trans-unit id="ff500cb34558d344640792adb24dac70e376b23d" translate="yes" xml:space="preserve">
          <source>__STDC_NO_COMPLEX__</source>
          <target state="translated">__STDC_NO_COMPLEX__</target>
        </trans-unit>
        <trans-unit id="ae78398cf4324ce5250a638c6222cfae5fcbd1ec" translate="yes" xml:space="preserve">
          <source>__STDC_NO_THREADS__</source>
          <target state="translated">__STDC_NO_THREADS__</target>
        </trans-unit>
        <trans-unit id="8004a029922d7533c64a5198c26202855b45a447" translate="yes" xml:space="preserve">
          <source>__STDC_NO_VLA__</source>
          <target state="translated">__STDC_NO_VLA__</target>
        </trans-unit>
        <trans-unit id="aec164fb4da1e304eadad72b50ba5910b1144c03" translate="yes" xml:space="preserve">
          <source>__STDC_UTF_16__</source>
          <target state="translated">__STDC_UTF_16__</target>
        </trans-unit>
        <trans-unit id="92432151980d707704b3ddfa392fde3ab589eb6c" translate="yes" xml:space="preserve">
          <source>__STDC_UTF_32__</source>
          <target state="translated">__STDC_UTF_32__</target>
        </trans-unit>
        <trans-unit id="04202f9ce8c923e1e74ba2bfa78f2696041116d2" translate="yes" xml:space="preserve">
          <source>__STDC_VERSION__</source>
          <target state="translated">__STDC_VERSION__</target>
        </trans-unit>
        <trans-unit id="e7fe05e43de55659e13d860cf51adc28583a4875" translate="yes" xml:space="preserve">
          <source>__STDC__</source>
          <target state="translated">__STDC__</target>
        </trans-unit>
        <trans-unit id="cf716a68ef036dac529946b2640a330f562725fe" translate="yes" xml:space="preserve">
          <source>__TIME__</source>
          <target state="translated">__TIME__</target>
        </trans-unit>
        <trans-unit id="9c3e29639fd2bfaa4db627da53f4d56eac9f0ec0" translate="yes" xml:space="preserve">
          <source>__alignas_is_defined</source>
          <target state="translated">__alignas_is_defined</target>
        </trans-unit>
        <trans-unit id="9d36c35d5289d86c7318369c0ebda5c58db23714" translate="yes" xml:space="preserve">
          <source>__alignof_is_defined</source>
          <target state="translated">__alignof_is_defined</target>
        </trans-unit>
        <trans-unit id="d8db95cc58ad2925bc93429910aec8cf2d80ad01" translate="yes" xml:space="preserve">
          <source>__func__</source>
          <target state="translated">__func__</target>
        </trans-unit>
        <trans-unit id="ed05f3a1b388032bead330257ae7557f50fb23b8" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;compatible_type#Type_names&quot;&gt;type name&lt;/a&gt; specifying any complete object type or an array of unknown size, but not a VLA</source>
          <target state="translated">완전한 객체 유형 또는 알 수없는 크기의 배열을 지정하지만 VLA는 지정하지 않는 &lt;a href=&quot;compatible_type#Type_names&quot;&gt;유형 이름&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bf12ce76466b152fd371b60da373fcc004cd34e1" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;statements#Compound_statements&quot;&gt;compound statement&lt;/a&gt;, that is a brace-enclosed sequence of declarations and statements, that is executed whenever this function is called</source>
          <target state="translated">중괄호로 묶은 선언 및 명령문 의 &lt;a href=&quot;statements#Compound_statements&quot;&gt;복합&lt;/a&gt; 문인이 명령문은이 함수가 호출 될 때마다 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="22334f752f416e871ad26a7973293f511dbb1117" translate="yes" xml:space="preserve">
          <source>a call to &lt;code&gt;aligned_alloc&lt;/code&gt; that allocates the same or a part of the same region of memory. This synchronization occurs after any access to the memory by the deallocating function and before any access to the memory by &lt;code&gt;aligned_alloc&lt;/code&gt;. There is a single total order of all allocation and deallocation functions operating on each particular region of memory.</source>
          <target state="translated">동일한 메모리 영역의 동일 또는 일부를 할당하는 &lt;code&gt;aligned_alloc&lt;/code&gt; 에 대한 호출 이 동기화는 할당 해제 기능에 의해 메모리에 액세스 한 후 및 &lt;code&gt;aligned_alloc&lt;/code&gt; 의해 메모리에 액세스하기 전에 발생합니다 . 각 특정 메모리 영역에서 작동하는 모든 할당 및 할당 해제 기능의 단일 순서가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c0b56ef24d3ffabf7a12df45d7bbc0049a40b25" translate="yes" xml:space="preserve">
          <source>a call to &lt;code&gt;calloc&lt;/code&gt; that allocates the same or a part of the same region of memory. This synchronization occurs after any access to the memory by the deallocating function and before any access to the memory by &lt;code&gt;calloc&lt;/code&gt;. There is a single total order of all allocation and deallocation functions operating on each particular region of memory.</source>
          <target state="translated">동일하거나 동일한 메모리 영역의 일부를 할당하는 &lt;code&gt;calloc&lt;/code&gt; 호출 이 동기화는 할당 해제 기능에 의해 메모리에 액세스 한 후와 &lt;code&gt;calloc&lt;/code&gt; 에 의해 메모리에 액세스하기 전에 발생합니다 . 각 특정 메모리 영역에서 작동하는 모든 할당 및 할당 해제 기능의 단일 순서가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a1dfede2161933a15a2d59057794b27ad7f32c0" translate="yes" xml:space="preserve">
          <source>a call to &lt;code&gt;malloc&lt;/code&gt; that allocates the same or a part of the same region of memory. This synchronization occurs after any access to the memory by the deallocating function and before any access to the memory by &lt;code&gt;malloc&lt;/code&gt;. There is a single total order of all allocation and deallocation functions operating on each particular region of memory.</source>
          <target state="translated">동일한 메모리 영역의 동일 또는 일부를 할당하는 &lt;code&gt;malloc&lt;/code&gt; 호출 . 이 동기화는 할당 해제 기능으로 메모리에 액세스 한 후와 &lt;code&gt;malloc&lt;/code&gt; 으로 메모리에 액세스하기 전에 발생합니다 . 각 특정 메모리 영역에서 작동하는 모든 할당 및 할당 해제 기능의 단일 순서가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c7964245d6375ae1a1b7aa7777bd609529d1b41" translate="yes" xml:space="preserve">
          <source>a call to any allocation function, including &lt;code&gt;realloc&lt;/code&gt; that allocates the same or a part of the same region of memory. This synchronization occurs after any access to the memory by the deallocating function and before any access to the memory by &lt;code&gt;realloc&lt;/code&gt;. There is a single total order of all allocation and deallocation functions operating on each particular region of memory.</source>
          <target state="translated">동일한 메모리 영역의 동일 또는 일부를 할당하는 &lt;code&gt;realloc&lt;/code&gt; 을 포함한 모든 할당 기능에 대한 호출 . 이 동기화는 할당 해제 기능에 의해 메모리에 액세스 한 후와 &lt;code&gt;realloc&lt;/code&gt; 에 의해 메모리에 액세스하기 전에 발생합니다 . 각 특정 메모리 영역에서 작동하는 모든 할당 및 할당 해제 기능의 단일 순서가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c2b3caaac6f4495fa04fefe591d34d3404c9be0" translate="yes" xml:space="preserve">
          <source>a call to any subsequent allocation function that allocates the same or a part of the same region of memory. This synchronization occurs after any access to the memory by the deallocating function and before any access to the memory by the allocation function. There is a single total order of all allocation and deallocation functions operating on each particular region of memory.</source>
          <target state="translated">동일한 메모리 영역의 동일 또는 일부를 할당하는 후속 할당 함수에 대한 호출 이 동기화는 할당 해제 기능으로 메모리에 액세스 한 후와 할당 기능으로 메모리에 액세스하기 전에 발생합니다. 각 특정 메모리 영역에서 작동하는 모든 할당 및 할당 해제 기능의 단일 순서가 있습니다.</target>
        </trans-unit>
        <trans-unit id="37f124f55b3ba6f47f47e94dddf3560a78205e93" translate="yes" xml:space="preserve">
          <source>a character from the basic source character set minus single-quote (&lt;code&gt;'&lt;/code&gt;), backslash (&lt;code&gt;\&lt;/code&gt;), or the newline character.</source>
          <target state="translated">기본 소스 문자 세트에서 작은 따옴표 ( &lt;code&gt;'&lt;/code&gt; ), 백 슬래시 ( &lt;code&gt;\&lt;/code&gt; ) 또는 개행 문자를 뺀 문자</target>
        </trans-unit>
        <trans-unit id="b3e20e256d4371f9eda62db761cfe929f36364f0" translate="yes" xml:space="preserve">
          <source>a combination of</source>
          <target state="translated">~의 조합</target>
        </trans-unit>
        <trans-unit id="97556c5ee84f06d4c9e6e31d96e3be1f6a10cee5" translate="yes" xml:space="preserve">
          <source>a declarator for a function type which uses a &lt;a href=&quot;function_declaration&quot;&gt;identifier list&lt;/a&gt; to designate function parameters</source>
          <target state="translated">&lt;a href=&quot;function_declaration&quot;&gt;식별자 목록&lt;/a&gt; 을 사용하여 함수 매개 변수를 지정 하는 함수 유형의 선언자</target>
        </trans-unit>
        <trans-unit id="aaad00c729007943609a1f99403a9854100c7ae7" translate="yes" xml:space="preserve">
          <source>a declarator for a function type which uses a &lt;a href=&quot;function_declaration&quot;&gt;parameter list&lt;/a&gt; to designate function parameters</source>
          <target state="translated">&lt;a href=&quot;function_declaration&quot;&gt;매개 변수리스트&lt;/a&gt; 를 사용하여 기능 매개 변수를 지정 하는 함수 유형의 선언자</target>
        </trans-unit>
        <trans-unit id="4d6273559dfdc3c5cc36c5e5eef22e8820ec4422" translate="yes" xml:space="preserve">
          <source>a list of C Standard Library header files</source>
          <target state="translated">C 표준 라이브러리 헤더 파일 목록</target>
        </trans-unit>
        <trans-unit id="123d2f34da2c9eb6022f14f7a955c26bfe59be30" translate="yes" xml:space="preserve">
          <source>a name earlier introduced by a &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; declaration</source>
          <target state="translated">이전에 &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; 선언에 의해 도입 된 이름</target>
        </trans-unit>
        <trans-unit id="0504278be6e31ecdf6a05b32909135da1f2b6e21" translate="yes" xml:space="preserve">
          <source>a non-character value of type wint_t used to indicate errors</source>
          <target state="translated">오류를 나타내는 데 사용되는 wint_t 유형의 문자가 아닌 값</target>
        </trans-unit>
        <trans-unit id="5dc9f3ea46b0a8a1ead292f1ee45735eb0a6f74f" translate="yes" xml:space="preserve">
          <source>a null pointer</source>
          <target state="translated">널 포인터</target>
        </trans-unit>
        <trans-unit id="2683ca29bdfef4cfd8048b11187a792b0ee2e2e2" translate="yes" xml:space="preserve">
          <source>a pointer to an object that is not an element of an array is treated as if it were pointing to an element of an array with one element</source>
          <target state="translated">배열의 요소가 아닌 객체에 대한 포인터는 마치 하나의 요소를 가진 배열의 요소를 가리키는 것처럼 취급됩니다</target>
        </trans-unit>
        <trans-unit id="642ef2320577c98feaf2f935169ad215e1202ed9" translate="yes" xml:space="preserve">
          <source>a positive integer value if the first argument is</source>
          <target state="translated">첫 번째 인수가 양수인 경우 양의 정수 값</target>
        </trans-unit>
        <trans-unit id="62ce867551f081be316dd4eace049a5f95b2fe17" translate="yes" xml:space="preserve">
          <source>a positive value of type errno_t</source>
          <target state="translated">errno_t 유형의 양수</target>
        </trans-unit>
        <trans-unit id="492a0055d77ea0e7979cf99d3b9100bf9e6853bf" translate="yes" xml:space="preserve">
          <source>a sequence of digits</source>
          <target state="translated">일련의 숫자</target>
        </trans-unit>
        <trans-unit id="092e5d5910cd24daae23118a07aa91b2b252f93d" translate="yes" xml:space="preserve">
          <source>a store in one thread becomes a</source>
          <target state="translated">한 스레드에있는 상점은</target>
        </trans-unit>
        <trans-unit id="425bf9812e28d908720f162b8a9d1517a6cc2c8d" translate="yes" xml:space="preserve">
          <source>a string used to indicate negative monetary quantity</source>
          <target state="translated">음의 통화량을 나타내는 데 사용되는 문자열</target>
        </trans-unit>
        <trans-unit id="757d7a97b6240cce0f9fe837451991e14db0783e" translate="yes" xml:space="preserve">
          <source>a string used to indicate non-negative monetary quantity</source>
          <target state="translated">음이 아닌 통화량을 나타내는 데 사용되는 문자열</target>
        </trans-unit>
        <trans-unit id="3b9575d67efdbcb362fb37d3399a2d1499fafcd8" translate="yes" xml:space="preserve">
          <source>a string whose elements indicate the sizes of digit groups</source>
          <target state="translated">요소가 숫자 그룹의 크기를 나타내는 문자열</target>
        </trans-unit>
        <trans-unit id="f858a6b266d4e30454cc89ef983dd5a2590b03ee" translate="yes" xml:space="preserve">
          <source>a type with alignment requirement as great as any other scalar type</source>
          <target state="translated">다른 스칼라 유형만큼 정렬 요구 사항이 큰 유형</target>
        </trans-unit>
        <trans-unit id="18069b9a8678c1f8291708c89d8b9c4d0252afe5" translate="yes" xml:space="preserve">
          <source>a typedef for the same type as &lt;code&gt;&lt;a href=&quot;types/size_t&quot;&gt;size_t&lt;/a&gt;&lt;/code&gt;, used to self-document functions that range-check their parameters at runtime</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;types/size_t&quot;&gt;size_t&lt;/a&gt;&lt;/code&gt; 와 동일한 유형의 typedef . 런타임시 매개 변수의 범위를 검사하는 함수를 자체 문서화하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="09f017c999f517934019ede8a1bf4373b242d073" translate="yes" xml:space="preserve">
          <source>a typedef for the type &lt;code&gt;int&lt;/code&gt;, used to self-document functions that return &lt;code&gt;&lt;a href=&quot;error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; values</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; 값 을 리턴하는 함수를 자체 문서화하는 데 사용되는 &lt;code&gt;int&lt;/code&gt; 유형의 typedef</target>
        </trans-unit>
        <trans-unit id="407f7616399e225a63ca52c79ae317571cf373f3" translate="yes" xml:space="preserve">
          <source>a typedef of the function pointer type &lt;code&gt;int(*)(void*)&lt;/code&gt;, used by &lt;code&gt;&lt;a href=&quot;thread/thrd_create&quot;&gt;thrd_create&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;thread/thrd_create&quot;&gt;thrd_create&lt;/a&gt;&lt;/code&gt; 가 사용 하는 함수 포인터 유형 &lt;code&gt;int(*)(void*)&lt;/code&gt; typedef</target>
        </trans-unit>
        <trans-unit id="7533040d36d9a8ffca93129287587122b0c1b376" translate="yes" xml:space="preserve">
          <source>a value computation B of M, then the evaluation B takes its value from X or from a side effect Y that appears after X in the modification order of M.</source>
          <target state="translated">M의 값 계산 B이면, 평가 B는 X로부터 또는 X의 수정 순서에서 X 다음에 나타나는 부작용 Y로부터 그 값을 취한다.</target>
        </trans-unit>
        <trans-unit id="b7f70cb2bc562eb0488f01aebc9ebd032140296e" translate="yes" xml:space="preserve">
          <source>a) 5 whitespace characters (space, horizontal tab, vertical tab, form feed, new-line)</source>
          <target state="translated">a) 5 개의 공백 문자 (공백, 가로 탭, 세로 탭, 용지 공급, 줄 바꿈)</target>
        </trans-unit>
        <trans-unit id="a57ad183139e2466db24858c2f6b437736f099b1" translate="yes" xml:space="preserve">
          <source>a) expanding or contracting the existing area pointed to by &lt;code&gt;ptr&lt;/code&gt;, if possible. The contents of the area remain unchanged up to the lesser of the new and old sizes. If the area is expanded, the contents of the new part of the array are undefined.</source>
          <target state="translated">a) 가능한 경우 &lt;code&gt;ptr&lt;/code&gt; 이 가리키는 기존 영역을 확장 또는 축소 합니다. 이 영역의 내용은 새로운 크기와 오래된 크기 중 작은 크기로 변경되지 않습니다. 영역이 확장되면 배열의 새 부분 내용이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="848db1c7f35ec7d54618e653c42ac58dc864e10f" translate="yes" xml:space="preserve">
          <source>a) header names: &lt;code&gt;&amp;lt;stdio.h&amp;gt;&lt;/code&gt; or &lt;code&gt;&quot;myfile.h&quot;&lt;/code&gt;</source>
          <target state="translated">a) 헤더 이름 : &lt;code&gt;&amp;lt;stdio.h&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&quot;myfile.h&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0f00aadd58815891ba18ffc68b4e53f080f7c07a" translate="yes" xml:space="preserve">
          <source>abnormal termination condition, as is e.g. initiated by &lt;code&gt;&lt;a href=&quot;abort&quot;&gt;abort()&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">비정상 종료 조건 &lt;code&gt;&lt;a href=&quot;abort&quot;&gt;abort()&lt;/a&gt;&lt;/code&gt; 예 : abort ()에 의해 시작됨 )</target>
        </trans-unit>
        <trans-unit id="b61646f016483b318b49a910668a966b6ce09ede" translate="yes" xml:space="preserve">
          <source>abort</source>
          <target state="translated">abort</target>
        </trans-unit>
        <trans-unit id="97de44dce82a940a13b9f4994b57f07a99108566" translate="yes" xml:space="preserve">
          <source>abort callback for the bounds-checked functions</source>
          <target state="translated">경계 검사 함수에 대한 콜백 중단</target>
        </trans-unit>
        <trans-unit id="f904e02a1a8fcc03536537b036685a2c755fb46c" translate="yes" xml:space="preserve">
          <source>abort_handler_s</source>
          <target state="translated">abort_handler_s</target>
        </trans-unit>
        <trans-unit id="7923a997e5ef7f7635917efd7303a93b2c10c23a" translate="yes" xml:space="preserve">
          <source>aborts the program if the user-specified condition is not &lt;code&gt;true&lt;/code&gt;. May be disabled for release builds</source>
          <target state="translated">사용자 지정 조건이 &lt;code&gt;true&lt;/code&gt; 가 아닌 경우 프로그램을 중단 합니다 . 릴리스 빌드에 대해 비활성화 될 수 있음</target>
        </trans-unit>
        <trans-unit id="164bfc66d0623cf4e44cafa362512a824d7e8d82" translate="yes" xml:space="preserve">
          <source>above is a property of every &lt;a href=&quot;compatible_type&quot;&gt;integer type&lt;/a&gt; and is defined as follows:</source>
          <target state="translated">위는 모든 &lt;a href=&quot;compatible_type&quot;&gt;정수 유형&lt;/a&gt; 의 속성이며 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="5094c70ca393f26707dd39d316fccaaf5f18c594" translate="yes" xml:space="preserve">
          <source>abs, labs, llabs, imaxabs</source>
          <target state="translated">복근, 실험실, llabs, imaxabs</target>
        </trans-unit>
        <trans-unit id="b198eb4b50fdd6b5832a36287b1acdc5b1c03d47" translate="yes" xml:space="preserve">
          <source>abslabsllabs</source>
          <target state="translated">abslabsllabs</target>
        </trans-unit>
        <trans-unit id="19a8e3d6209d1f620f09754c72b881fd910c1f0c" translate="yes" xml:space="preserve">
          <source>access member &lt;b&gt;b&lt;/b&gt; of &lt;a href=&quot;struct&quot;&gt;struct&lt;/a&gt; or &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt; pointed to by &lt;b&gt;a&lt;/b&gt;</source>
          <target state="translated">액세스 멤버 &lt;b&gt;B&lt;/b&gt; 의 &lt;a href=&quot;struct&quot;&gt;구조체&lt;/a&gt; 또는 &lt;a href=&quot;union&quot;&gt;노조&lt;/a&gt; 가 가리키는&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e77e10629f557a3bc65645a9ca4c3a8bf8fd7940" translate="yes" xml:space="preserve">
          <source>access member &lt;b&gt;b&lt;/b&gt; of &lt;a href=&quot;struct&quot;&gt;struct&lt;/a&gt; or &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt;&lt;b&gt;a&lt;/b&gt;</source>
          <target state="translated">접속 부재 &lt;b&gt;B&lt;/b&gt; 의 &lt;a href=&quot;struct&quot;&gt;구조체&lt;/a&gt; 또는 &lt;a href=&quot;union&quot;&gt;조합&lt;/a&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8d2d225128f456bf497712bea851d5e0ab2b7e6c" translate="yes" xml:space="preserve">
          <source>access the &lt;b&gt;b&lt;/b&gt;th element of array &lt;b&gt;a&lt;/b&gt;</source>
          <target state="translated">액세스 &lt;b&gt;b를&lt;/b&gt; 어레이의 일 소자&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fd6cc7542529dd7354ae281d8012983cdc5fce31" translate="yes" xml:space="preserve">
          <source>access to an object outside of its &lt;a href=&quot;lifetime&quot;&gt;lifetime&lt;/a&gt; (e.g. through a dangling pointer)</source>
          <target state="translated">&lt;a href=&quot;lifetime&quot;&gt;수명&lt;/a&gt; 이외의 개체에 대한 액세스 (예 : 매달려있는 포인터를 통한)</target>
        </trans-unit>
        <trans-unit id="fb4e35cb551b39ac5df3d0f5c072966de7e0bc5c" translate="yes" xml:space="preserve">
          <source>access to the list of environment variables</source>
          <target state="translated">환경 변수 목록에 액세스</target>
        </trans-unit>
        <trans-unit id="7c24822cdeb7c5c6b787dbc0cfccf8c9b4d0844f" translate="yes" xml:space="preserve">
          <source>accesses the next variadic function argument</source>
          <target state="translated">다음 가변 함수 인수에 액세스</target>
        </trans-unit>
        <trans-unit id="328f0742cf74e8ffdb253376b1803615055e215b" translate="yes" xml:space="preserve">
          <source>acos</source>
          <target state="translated">acos</target>
        </trans-unit>
        <trans-unit id="147d0b37b30b50556b9e55d6a8ce932951fad569" translate="yes" xml:space="preserve">
          <source>acos(z), or simply i acos(z) in the upper half of the complex plane.</source>
          <target state="translated">acos (z), 또는 간단히 복잡한 평면의 상단에있는 acos (z).</target>
        </trans-unit>
        <trans-unit id="4f6845fe659bed6637eedb661a4b4fda8a803d03" translate="yes" xml:space="preserve">
          <source>acos, acosf, acosl</source>
          <target state="translated">acos, acosf, acosl</target>
        </trans-unit>
        <trans-unit id="7065e6c51c4483cfded5cc061fbccd9a93bc104c" translate="yes" xml:space="preserve">
          <source>acosacosfacosl</source>
          <target state="translated">acosacosfacosl</target>
        </trans-unit>
        <trans-unit id="5df0277ec86f188e0c797c5782ceb42dc25bb36a" translate="yes" xml:space="preserve">
          <source>acosh</source>
          <target state="translated">acosh</target>
        </trans-unit>
        <trans-unit id="589a4621c7cf6dcff6a469151b23cd30ce08cce9" translate="yes" xml:space="preserve">
          <source>acosh, acoshf, acoshl</source>
          <target state="translated">아코 쉬, acoshf, acoshl</target>
        </trans-unit>
        <trans-unit id="1824220df1c196fec7eafe8955123ab045039cc2" translate="yes" xml:space="preserve">
          <source>acoshacoshfacoshl</source>
          <target state="translated">acoshacoshfacoshl</target>
        </trans-unit>
        <trans-unit id="a90390361d9b0316110b5eee0023ea52e6598545" translate="yes" xml:space="preserve">
          <source>acoshl</source>
          <target state="translated">acoshl</target>
        </trans-unit>
        <trans-unit id="304e4d7ae71d38f68561c83b5cdefd5c197713fc" translate="yes" xml:space="preserve">
          <source>acosl</source>
          <target state="translated">acosl</target>
        </trans-unit>
        <trans-unit id="1c52002b743e4db150df31d4c92e7f8849bd4395" translate="yes" xml:space="preserve">
          <source>acquire operation</source>
          <target state="translated">수술을 받다</target>
        </trans-unit>
        <trans-unit id="4ef76fa8e24cfa0361d135d67b2541d876650e36" translate="yes" xml:space="preserve">
          <source>acquiring</source>
          <target state="translated">acquiring</target>
        </trans-unit>
        <trans-unit id="c3805175370d19c334b59f45b87343b9f2b7f5e1" translate="yes" xml:space="preserve">
          <source>addition</source>
          <target state="translated">addition</target>
        </trans-unit>
        <trans-unit id="1ea3777754d6be1f3458ef90dda1cf54a1ddb440" translate="yes" xml:space="preserve">
          <source>addition assignment</source>
          <target state="translated">추가 과제</target>
        </trans-unit>
        <trans-unit id="feccbd79efdd23843e4995d7af810032b227dbbc" translate="yes" xml:space="preserve">
          <source>additional information (e.g., collating sequence), passed to &lt;code&gt;comp&lt;/code&gt; as the third argument</source>
          <target state="translated">세 번째 인수 로 &lt;code&gt;comp&lt;/code&gt; 에 전달 된 추가 정보 (예 : 조합 순서)</target>
        </trans-unit>
        <trans-unit id="9d50eddef9262e79d2047b13e4d6d3daf024d3ec" translate="yes" xml:space="preserve">
          <source>additionally, if they are enumerations, corresponding members must also have the same values.</source>
          <target state="translated">또한 열거 형인 경우 해당 멤버도 같은 값을 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="f3241e56e78b25a62f11b23b96ec570f0735ce1d" translate="yes" xml:space="preserve">
          <source>additionally, if they are structures or unions,</source>
          <target state="translated">또한, 그들이 구조 나 노조라면</target>
        </trans-unit>
        <trans-unit id="c662180230cad14787d4ab7e77aa08681ce783fa" translate="yes" xml:space="preserve">
          <source>address</source>
          <target state="translated">address</target>
        </trans-unit>
        <trans-unit id="556049da8cc10fac75ab14efc978eeeeb3ea2692" translate="yes" xml:space="preserve">
          <source>address constant expression</source>
          <target state="translated">주소 상수 표현</target>
        </trans-unit>
        <trans-unit id="0c17e45ca56ec6ed4a705f824c8aca1c8f4e8e77" translate="yes" xml:space="preserve">
          <source>address of</source>
          <target state="translated">주소</target>
        </trans-unit>
        <trans-unit id="4457c5c7ef8ebc7b3a1f299072c7fb0729c67a6a" translate="yes" xml:space="preserve">
          <source>aggregate types</source>
          <target state="translated">집계 유형</target>
        </trans-unit>
        <trans-unit id="062f903e7a5b5fa5dd018873a2aa70adfb2020bd" translate="yes" xml:space="preserve">
          <source>alignas</source>
          <target state="translated">alignas</target>
        </trans-unit>
        <trans-unit id="0d80ec85b39f8b9faf623f44b5b53e8f41051306" translate="yes" xml:space="preserve">
          <source>aligned_alloc</source>
          <target state="translated">aligned_alloc</target>
        </trans-unit>
        <trans-unit id="05dfeae5db3ff37e5e9f1f43350a95604f04689b" translate="yes" xml:space="preserve">
          <source>alignment</source>
          <target state="translated">alignment</target>
        </trans-unit>
        <trans-unit id="7a5e5f751184b7bff89789dac0da42a54bbc4cb6" translate="yes" xml:space="preserve">
          <source>alignment requirement</source>
          <target state="translated">정렬 요구 사항</target>
        </trans-unit>
        <trans-unit id="2b0a9a63b400f56ea64f1dc5c76adcfc41fa151d" translate="yes" xml:space="preserve">
          <source>alignment requirement (can be determined by &lt;a href=&quot;alignof&quot;&gt;alignof&lt;/a&gt;)(since C11)</source>
          <target state="translated">정렬 요구 사항 ( &lt;a href=&quot;alignof&quot;&gt;alignof에&lt;/a&gt; 의해 결정될 수 있음 ) (C11부터)</target>
        </trans-unit>
        <trans-unit id="867318e23a3e63655204aafd2975563685ee0462" translate="yes" xml:space="preserve">
          <source>alignof</source>
          <target state="translated">alignof</target>
        </trans-unit>
        <trans-unit id="d87c448044defb778f33158d8ccf94a20531d600" translate="yes" xml:space="preserve">
          <source>all</source>
          <target state="translated">all</target>
        </trans-unit>
        <trans-unit id="3e7c1609043c1941c605866ab35e26dad2ab85fc" translate="yes" xml:space="preserve">
          <source>all C streams are flushed and closed</source>
          <target state="translated">모든 C 스트림이 플러시되고 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="df4172a5a7b30962538b9ec831d1b1de58d48654" translate="yes" xml:space="preserve">
          <source>all arithmetic, relational, logical, and bitwise operators</source>
          <target state="translated">모든 산술, 관계, 논리 및 비트 연산자</target>
        </trans-unit>
        <trans-unit id="cdb708b79dfd7d3f13e68022e4110062dda87cf2" translate="yes" xml:space="preserve">
          <source>all operations and constants evaluate in the range and precision of &lt;code&gt;double&lt;/code&gt;. Additionally, both &lt;code&gt;float_t&lt;/code&gt; and &lt;code&gt;double_t&lt;/code&gt; are equivalent to &lt;code&gt;double&lt;/code&gt;</source>
          <target state="translated">모든 연산과 상수는 &lt;code&gt;double&lt;/code&gt; 의 범위와 정밀도로 평가됩니다 . 또한 &lt;code&gt;float_t&lt;/code&gt; 와 &lt;code&gt;double_t&lt;/code&gt; 는 &lt;code&gt;double&lt;/code&gt; 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a3353ab95ebb14131e875c614b1df72dfe1c566c" translate="yes" xml:space="preserve">
          <source>all operations and constants evaluate in the range and precision of &lt;code&gt;long double&lt;/code&gt;. Additionally, both &lt;code&gt;float_t&lt;/code&gt; and &lt;code&gt;double_t&lt;/code&gt; are equivalent to &lt;code&gt;long double&lt;/code&gt;</source>
          <target state="translated">모든 연산과 상수는 &lt;code&gt;long double&lt;/code&gt; 의 범위와 정밀도로 평가됩니다 . 또한 &lt;code&gt;float_t&lt;/code&gt; 와 &lt;code&gt;double_t&lt;/code&gt; 는 &lt;code&gt;long double&lt;/code&gt; 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="977083d5e09600da9c4eccd257809269b4c94c59" translate="yes" xml:space="preserve">
          <source>all operations and constants evaluate in the range and precision of the type used. Additionally, &lt;code&gt;float_t&lt;/code&gt; and &lt;code&gt;double_t&lt;/code&gt; are equivalent to &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;double&lt;/code&gt; respectively</source>
          <target state="translated">모든 연산과 상수는 사용 된 유형의 범위와 정밀도로 평가됩니다. 또한 &lt;code&gt;float_t&lt;/code&gt; 및 &lt;code&gt;double_t&lt;/code&gt; 는 각각 &lt;code&gt;float&lt;/code&gt; 및 &lt;code&gt;double&lt;/code&gt; 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7780d84b84c9142aa89e31966605e1441d783bee" translate="yes" xml:space="preserve">
          <source>all operators not specified to return lvalues, including</source>
          <target state="translated">다음을 포함하여 lvalue를 반환하도록 지정되지 않은 모든 연산자</target>
        </trans-unit>
        <trans-unit id="68630f1665f7e74a806f82115917b348ff54806d" translate="yes" xml:space="preserve">
          <source>all other pointer comparisons invoke undefined behavior</source>
          <target state="translated">다른 모든 포인터 비교는 정의되지 않은 동작을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="400375aeabf668f2340ea3b379d803b6b8b255fe" translate="yes" xml:space="preserve">
          <source>allocate a copy of a string</source>
          <target state="translated">문자열의 사본을 할당</target>
        </trans-unit>
        <trans-unit id="bb337ce8a028a4cee827132b68f54b4907c60e86" translate="yes" xml:space="preserve">
          <source>allocate a copy of a string up to specified size</source>
          <target state="translated">지정된 크기까지 문자열의 사본을 할당</target>
        </trans-unit>
        <trans-unit id="5f3e8f3c8913ee0556612ac56f1100bdc54d4b6b" translate="yes" xml:space="preserve">
          <source>allocates aligned memory</source>
          <target state="translated">정렬 된 메모리 할당</target>
        </trans-unit>
        <trans-unit id="8454d15e4c9c8e6f3a57a97cf499f9a12a5b9c45" translate="yes" xml:space="preserve">
          <source>allocates and zeroes memory</source>
          <target state="translated">메모리 할당 및 제로</target>
        </trans-unit>
        <trans-unit id="b8a8fad17819140ae5245db5e27c1653353c978b" translate="yes" xml:space="preserve">
          <source>allocates memory</source>
          <target state="translated">메모리를 할당</target>
        </trans-unit>
        <trans-unit id="91a0b05ea8f965ae4bee50cde10d4c446a1e3b17" translate="yes" xml:space="preserve">
          <source>allowed). The permitted implicit conversions remain implicit conversions as if by assignment since that's what &lt;a href=&quot;initialization&quot;&gt;initialization&lt;/a&gt; also uses.</source>
          <target state="translated">허용됨). 허용 된 암시 적 변환은 &lt;a href=&quot;initialization&quot;&gt;초기화&lt;/a&gt; 도 사용하기 때문에 할당에 의한 것처럼 암시 적 변환으로 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="57fc2642d89ce1e097c263a684eb5a024daeebb1" translate="yes" xml:space="preserve">
          <source>already exists</source>
          <target state="translated">이미 존재 함</target>
        </trans-unit>
        <trans-unit id="a66468d63e91e596a97d876019fbaff6d95089c8" translate="yes" xml:space="preserve">
          <source>alternative form</source>
          <target state="translated">대체 형태</target>
        </trans-unit>
        <trans-unit id="e8af47c361b758726325c4a5d8f6d520db8f84f6" translate="yes" xml:space="preserve">
          <source>alternative implementation</source>
          <target state="translated">대체 구현</target>
        </trans-unit>
        <trans-unit id="7a3889426121edfa53717bdb3ef97045d05ffc26" translate="yes" xml:space="preserve">
          <source>alternative representation</source>
          <target state="translated">대체 표현</target>
        </trans-unit>
        <trans-unit id="1dd1a6dc80c5ec13ed0bab7c3efae29474bb9c3c" translate="yes" xml:space="preserve">
          <source>an &lt;a href=&quot;expressions&quot;&gt;expression&lt;/a&gt; of any pointer type</source>
          <target state="translated">포인터 타입 의 &lt;a href=&quot;expressions&quot;&gt;표현&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6fcaeef60c578753f96c537b6021c9f8ba0f4005" translate="yes" xml:space="preserve">
          <source>an &lt;a href=&quot;expressions&quot;&gt;expression&lt;/a&gt; of integer type</source>
          <target state="translated">정수형 의 &lt;a href=&quot;expressions&quot;&gt;표현&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c3c63cd915fa58503257713ad4a99a2388d7cf0c" translate="yes" xml:space="preserve">
          <source>an &lt;a href=&quot;expressions&quot;&gt;expression&lt;/a&gt; of type pointer to complete object</source>
          <target state="translated">객체를 완성하기위한 포인터 타입 의 &lt;a href=&quot;expressions&quot;&gt;표현&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0ffd31cdd3fc478fb8aa298268d403b7671713aa" translate="yes" xml:space="preserve">
          <source>an &lt;a href=&quot;identifier&quot;&gt;identifier&lt;/a&gt; that names a member of the struct or union designated by expression</source>
          <target state="translated">식으로 지정된 구조체 또는 공용체의 멤버를 명명 하는 &lt;a href=&quot;identifier&quot;&gt;식별자&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c770b10bd3283310dfe735741609cc3e6a12bf2a" translate="yes" xml:space="preserve">
          <source>an &lt;a href=&quot;identifier&quot;&gt;identifier&lt;/a&gt; that names a member of the struct or union pointed by expression</source>
          <target state="translated">식으로 가리키는 구조체 또는 공용체의 멤버 이름을 지정 하는 &lt;a href=&quot;identifier&quot;&gt;식별자&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="26834c673eb6eae28680be23c0c387a56f2be791" translate="yes" xml:space="preserve">
          <source>an &lt;a href=&quot;value_category&quot;&gt;lvalue&lt;/a&gt; expression of any type that is not a &lt;a href=&quot;bit_field&quot;&gt;bit field&lt;/a&gt; and does not have &lt;a href=&quot;storage_duration&quot;&gt;register&lt;/a&gt; storage class</source>
          <target state="translated">&lt;a href=&quot;bit_field&quot;&gt;비트 필드&lt;/a&gt; 가 아니고 &lt;a href=&quot;storage_duration&quot;&gt;레지스터&lt;/a&gt; 스토리지 클래스 가없는 유형 의 &lt;a href=&quot;value_category&quot;&gt;lvalue&lt;/a&gt; 표현식</target>
        </trans-unit>
        <trans-unit id="8d25a5eab78f6eda49ce05aa4731693cd80db5ed" translate="yes" xml:space="preserve">
          <source>an expression of &lt;a href=&quot;struct&quot;&gt;struct&lt;/a&gt; or &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt; type</source>
          <target state="translated">&lt;a href=&quot;struct&quot;&gt;구조체&lt;/a&gt; 또는 &lt;a href=&quot;union&quot;&gt;공용체&lt;/a&gt; 유형 의 표현</target>
        </trans-unit>
        <trans-unit id="e9ca9f074bef452e68d74671c6b7e41ad6718dbe" translate="yes" xml:space="preserve">
          <source>an expression of any &lt;a href=&quot;compatible_type#Type_groups&quot;&gt;scalar type&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;compatible_type#Type_groups&quot;&gt;스칼라 타입&lt;/a&gt; 의 표현</target>
        </trans-unit>
        <trans-unit id="e482a6714eaafb0e24be84f63888929f38a20ed1" translate="yes" xml:space="preserve">
          <source>an expression of any scalar type</source>
          <target state="translated">스칼라 타입의 표현</target>
        </trans-unit>
        <trans-unit id="c5091785e0504e641a8e3af5496c6028197b862f" translate="yes" xml:space="preserve">
          <source>an expression of any scalar type, which is only evaluated if lhs compares equal to &lt;code&gt;​0​&lt;/code&gt;</source>
          <target state="translated">스칼라 유형의 표현으로, lhs가 &lt;code&gt;​0​&lt;/code&gt; 과 비교되는 경우에만 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="9c30acc345d35d3998440b6088bf19963caa6a35" translate="yes" xml:space="preserve">
          <source>an expression of any scalar type, which is only evaluated if lhs does not compare equal to &lt;code&gt;​0​&lt;/code&gt;</source>
          <target state="translated">스칼라 형식의 표현으로, lhs가 &lt;code&gt;​0​&lt;/code&gt; 과 비교되지 않는 경우에만 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="b2daf35100d05a24b08066e28b51c0c00f1cce17" translate="yes" xml:space="preserve">
          <source>an expression of scalar type</source>
          <target state="translated">스칼라 타입의 표현</target>
        </trans-unit>
        <trans-unit id="1466d8b4e35f4f83ca75b50de808d2ca1cce841e" translate="yes" xml:space="preserve">
          <source>an expression of type &lt;a href=&quot;pointer&quot;&gt;pointer&lt;/a&gt; to &lt;a href=&quot;struct&quot;&gt;struct&lt;/a&gt; or &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt;</source>
          <target state="translated">형의 표현 &lt;a href=&quot;pointer&quot;&gt;포인터&lt;/a&gt; 로 &lt;a href=&quot;struct&quot;&gt;구조체&lt;/a&gt; 또는 &lt;a href=&quot;union&quot;&gt;조합&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5a67874112f3e299e468f90df2277215d12f553a" translate="yes" xml:space="preserve">
          <source>an instance of the &lt;code&gt;va_list&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;va_list&lt;/code&gt; 타입 의 인스턴스</target>
        </trans-unit>
        <trans-unit id="86abb14241dbb7db0bb13b74e8edde69e450c9e5" translate="yes" xml:space="preserve">
          <source>an instance of the &lt;code&gt;va_list&lt;/code&gt; type to clean up</source>
          <target state="translated">정리할 &lt;code&gt;va_list&lt;/code&gt; 유형 의 인스턴스</target>
        </trans-unit>
        <trans-unit id="30e295867a522c67c41499b0529da42173f1d4c0" translate="yes" xml:space="preserve">
          <source>an instance of the &lt;code&gt;va_list&lt;/code&gt; type to initialize</source>
          <target state="translated">초기화 할 &lt;code&gt;va_list&lt;/code&gt; 유형 의 인스턴스</target>
        </trans-unit>
        <trans-unit id="ce9512a3c405db5a107feba3b473178c36d74968" translate="yes" xml:space="preserve">
          <source>an integer &lt;a href=&quot;../language/constant_expression#Integer_constant_expression&quot;&gt;constant expression&lt;/a&gt; with the value &lt;code&gt;​0​&lt;/code&gt;</source>
          <target state="translated">값이 &lt;code&gt;​0​&lt;/code&gt; 인 정수 &lt;a href=&quot;../language/constant_expression#Integer_constant_expression&quot;&gt;상수 표현식&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d51b1b56486d192e084f8901036bb0c35812c943" translate="yes" xml:space="preserve">
          <source>an integer &lt;a href=&quot;constant_expression&quot;&gt;constant expression&lt;/a&gt; with a value greater or equal to zero and less or equal the number of bits in the underlying type. When greater than zero, this is the number of bits that this bit field will occupy. The value zero is only allowed for nameless bit fields and has special meaning: it specifies that the next bit field in the class definition will begin at an allocation unit's boundary.</source>
          <target state="translated">정수 &lt;a href=&quot;constant_expression&quot;&gt;상수 식&lt;/a&gt; 값보다 또는 제로와 같거나 작은 내부 형식의 비트 수와 동일. 0보다 크면이 비트 필드가 차지할 비트 수입니다. 값 0은 이름없는 비트 필드에만 허용되며 특별한 의미를 갖습니다. 클래스 정의의 다음 비트 필드가 할당 단위의 경계에서 시작되도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="b382c31b00d864a5cbeb230e9e1412baa05f78a4" translate="yes" xml:space="preserve">
          <source>an integer constant expression with the value 0 &lt;a href=&quot;../language/conversion#Pointer_conversions&quot;&gt;cast to the type&lt;/a&gt;&lt;code&gt;void*&lt;/code&gt;</source>
          <target state="translated">값이 0 인 정수 상수 표현식은 &lt;code&gt;void*&lt;/code&gt; &lt;a href=&quot;../language/conversion#Pointer_conversions&quot;&gt;유형으로 캐스트됩니다.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0b08993b08f9159ab8acc22acd5919bddd34e9c0" translate="yes" xml:space="preserve">
          <source>an object of &lt;a href=&quot;compatible_type#Type_groups&quot;&gt;scalar type&lt;/a&gt; (arithmetic type, pointer type, enumeration type)</source>
          <target state="translated">&lt;a href=&quot;compatible_type#Type_groups&quot;&gt;스칼라 타입&lt;/a&gt; 의 객체 (산술 타입, 포인터 타입, 열거 타입)</target>
        </trans-unit>
        <trans-unit id="9fc8d05fff2d4a9fdbb558a1197ea598e431dfb8" translate="yes" xml:space="preserve">
          <source>an operation B on M, then A takes its value from a side effect X on M, where X appears before B in the modification order of M.</source>
          <target state="translated">M에 대한 연산 B, A는 M의 부작용 X에서 값을 가져옵니다. 여기서 X는 M의 수정 순서로 B 앞에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="8dde5d5482f9f390a32371e3f89da7b3284eda61" translate="yes" xml:space="preserve">
          <source>an operation B that modifies M, then A appears earlier than B in the modification order of M.</source>
          <target state="translated">M을 수정하는 조작 B, M의 수정 순서에서 A가 B보다 먼저 나타납니다.</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="04f3ea1263fe354b1a1abaea9c1143c043077794" translate="yes" xml:space="preserve">
          <source>and a</source>
          <target state="translated">그리고</target>
        </trans-unit>
        <trans-unit id="96e2a753ba36c7df2d9c9572a980d973b1fb8650" translate="yes" xml:space="preserve">
          <source>and is only available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined. The following macros and functions support this functionality.</source>
          <target state="translated">&lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 이 정의 된 경우에만 사용 가능합니다 . 다음 매크로 및 기능이이 기능을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="40fd560f32f29d04963d416d75047a6cfeb92dbe" translate="yes" xml:space="preserve">
          <source>and may not be declared in a program (doing so invokes undefined behavior):</source>
          <target state="translated">프로그램에서 선언되지 않을 수 있습니다 (정의되지 않은 동작이 발생 함).</target>
        </trans-unit>
        <trans-unit id="6f5c1ef50816d102d59e8dddcc9ac547607b50fd" translate="yes" xml:space="preserve">
          <source>and selects the subobject to be initialized within the</source>
          <target state="translated">그 안에서 초기화 될 하위 객체를 선택합니다</target>
        </trans-unit>
        <trans-unit id="a93345ebb64aeba932c32ab7d854638997d5ef19" translate="yes" xml:space="preserve">
          <source>and the standard library provides one definition of this constant as the macro &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; .</source>
          <target state="translated">표준 라이브러리는이 상수의 하나의 정의를 매크로 &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 로 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="9fd29300b85768a1234d6f664159b64c48c91452" translate="yes" xml:space="preserve">
          <source>and their</source>
          <target state="translated">그리고 그들의</target>
        </trans-unit>
        <trans-unit id="fb0416aa14d74afde308590f0e07546abbf5c866" translate="yes" xml:space="preserve">
          <source>and.</source>
          <target state="translated">and.</target>
        </trans-unit>
        <trans-unit id="1fba2da8434660e3c85122283402e6dd020f0ee9" translate="yes" xml:space="preserve">
          <source>anonymous struct</source>
          <target state="translated">익명의 구조체</target>
        </trans-unit>
        <trans-unit id="80a011b32fef63606811d73e091cc0b24ee0357f" translate="yes" xml:space="preserve">
          <source>anonymous union</source>
          <target state="translated">익명의 연합</target>
        </trans-unit>
        <trans-unit id="0f6794e2c132cc20741c7a6f05c99a28077f81c0" translate="yes" xml:space="preserve">
          <source>another (see &lt;code&gt;&lt;a href=&quot;../atomic/memory_order&quot;&gt;memory_order&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">다른 ( &lt;code&gt;&lt;a href=&quot;../atomic/memory_order&quot;&gt;memory_order&lt;/a&gt;&lt;/code&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="809318b0f32018415dfddab521f3e13842ec38e4" translate="yes" xml:space="preserve">
          <source>any &lt;a href=&quot;../string/byte&quot;&gt;string&lt;/a&gt; or &lt;a href=&quot;../string/wide&quot;&gt;wide string&lt;/a&gt; library function accesses an array out of bounds</source>
          <target state="translated">모든 &lt;a href=&quot;../string/byte&quot;&gt;문자열&lt;/a&gt; 또는 &lt;a href=&quot;../string/wide&quot;&gt;넓은 문자열&lt;/a&gt; 라이브러리 함수는 범위를 벗어난 배열에 액세스</target>
        </trans-unit>
        <trans-unit id="548db24dda99e960bd75dbe694826c0574978efb" translate="yes" xml:space="preserve">
          <source>any &lt;a href=&quot;compatible_type#Type_names&quot;&gt;type name&lt;/a&gt;</source>
          <target state="translated">모든 &lt;a href=&quot;compatible_type#Type_names&quot;&gt;유형 이름&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d0567d76c391930bf6159349a1feb7c3e0f6b493" translate="yes" xml:space="preserve">
          <source>any &lt;a href=&quot;constant_expression&quot;&gt;integer constant expression&lt;/a&gt;</source>
          <target state="translated">모든 &lt;a href=&quot;constant_expression&quot;&gt;정수 상수 표현식&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c86de59cb451b567943008ac77b5019b11450cd9" translate="yes" xml:space="preserve">
          <source>any &lt;a href=&quot;constant_expression&quot;&gt;integer constant expression&lt;/a&gt; whose value is a valid &lt;a href=&quot;object#Alignment&quot;&gt;alignment&lt;/a&gt; or zero</source>
          <target state="translated">어떤 &lt;a href=&quot;constant_expression&quot;&gt;정수 상수 표현&lt;/a&gt; 그 값이 유효 &lt;a href=&quot;object#Alignment&quot;&gt;배향&lt;/a&gt; 제로</target>
        </trans-unit>
        <trans-unit id="6240ff52b9d414b02e19da67fc0afce850b89a7c" translate="yes" xml:space="preserve">
          <source>any &lt;a href=&quot;declarations#Declarators&quot;&gt;declarator&lt;/a&gt; except unparenthesized pointer declarator. The identifier that is contained in this declarator is the identifier that becomes the function designator.</source>
          <target state="translated">괄호 안에없는 포인터 &lt;a href=&quot;declarations#Declarators&quot;&gt;선언자를&lt;/a&gt; 제외한 모든 선언자 이 선언에 포함 된 식별자는 함수 지정자가되는 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="c3b874c873f2146b6463b682d297176c153f579b" translate="yes" xml:space="preserve">
          <source>any &lt;a href=&quot;expressions&quot;&gt;expression&lt;/a&gt; of &lt;a href=&quot;compatible_type#Type_groups&quot;&gt;integer type&lt;/a&gt; (char, signed or unsigned integer, or enumeration)</source>
          <target state="translated">어떤 &lt;a href=&quot;expressions&quot;&gt;식&lt;/a&gt; 의 &lt;a href=&quot;compatible_type#Type_groups&quot;&gt;정수 유형&lt;/a&gt; (문자, 부호 또는 부호없는 정수, 또는 열거)</target>
        </trans-unit>
        <trans-unit id="be8381985b79c4f4f883852f84f08e64e5da8fc7" translate="yes" xml:space="preserve">
          <source>any &lt;a href=&quot;expressions&quot;&gt;expression&lt;/a&gt; of &lt;a href=&quot;compatible_type#Type_groups&quot;&gt;scalar type&lt;/a&gt; (unless type-name is void, in which case it can be anything)</source>
          <target state="translated">어떤 &lt;a href=&quot;expressions&quot;&gt;식&lt;/a&gt; 의 &lt;a href=&quot;compatible_type#Type_groups&quot;&gt;스칼라 타입&lt;/a&gt; (type-name을 무효하지 않는 한,이 경우에 아무것도 할 수 있습니다)</target>
        </trans-unit>
        <trans-unit id="06f41d2a748f820ab4b0d60d234ee6447b5c7b2a" translate="yes" xml:space="preserve">
          <source>any &lt;a href=&quot;expressions&quot;&gt;expression&lt;/a&gt; of &lt;a href=&quot;compatible_type#Type_groups&quot;&gt;scalar type&lt;/a&gt;. This expression is evaluated after each iteration, and if it compares equal to zero, the loop is exited.</source>
          <target state="translated">어떤 &lt;a href=&quot;expressions&quot;&gt;식&lt;/a&gt; 의 &lt;a href=&quot;compatible_type#Type_groups&quot;&gt;스칼라 유형&lt;/a&gt; . 이 표현식은 각 반복 후에 평가되며 0과 비교하면 루프가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="274e302869fbb27c30f2b86fea297b58e8fe8144" translate="yes" xml:space="preserve">
          <source>any &lt;a href=&quot;expressions&quot;&gt;expression&lt;/a&gt; of &lt;a href=&quot;compatible_type#Type_groups&quot;&gt;scalar type&lt;/a&gt;. This expression is evaluated before each iteration, and if it compares equal to zero, the loop is exited.</source>
          <target state="translated">어떤 &lt;a href=&quot;expressions&quot;&gt;식&lt;/a&gt; 의 &lt;a href=&quot;compatible_type#Type_groups&quot;&gt;스칼라 유형&lt;/a&gt; . 이 표현식은 각 반복 전에 평가되며, 0과 비교하면 루프가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="289a2cbed49e869ef41824f6c67f9fe6d378b421" translate="yes" xml:space="preserve">
          <source>any &lt;a href=&quot;statements&quot;&gt;statement&lt;/a&gt; (typically a compound statement). &lt;code&gt;case:&lt;/code&gt; and &lt;code&gt;default:&lt;/code&gt; labels are permitted in statement, and &lt;code&gt;break;&lt;/code&gt; statement has special meaning.</source>
          <target state="translated">모든 &lt;a href=&quot;statements&quot;&gt;진술&lt;/a&gt; (일반적으로 복합 진술). &lt;code&gt;case:&lt;/code&gt; 및 &lt;code&gt;default:&lt;/code&gt; 레이블은 명령문에 허용되며 &lt;code&gt;break;&lt;/code&gt; 진술에는 특별한 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff8f57a6fc50c3b928eca64028a6f3e218dfa5cd" translate="yes" xml:space="preserve">
          <source>any &lt;a href=&quot;statements&quot;&gt;statement&lt;/a&gt;, typically a compound statement, which is the body of the loop</source>
          <target state="translated">모든 &lt;a href=&quot;statements&quot;&gt;문장&lt;/a&gt; , 일반적으로 복합 문장, 루프의 본문</target>
        </trans-unit>
        <trans-unit id="6160f2d70f309150cc39956b7333bdabe9e3c566" translate="yes" xml:space="preserve">
          <source>any &lt;a href=&quot;statements&quot;&gt;statement&lt;/a&gt;, typically a compound statement, which serves as the body of the loop</source>
          <target state="translated">루프의 본문으로 사용되는 모든 &lt;a href=&quot;statements&quot;&gt;statement&lt;/a&gt; , 일반적으로 복합 명령문</target>
        </trans-unit>
        <trans-unit id="d5f530d35571677a796141f3d891df4b848b98e2" translate="yes" xml:space="preserve">
          <source>any &lt;a href=&quot;string_literal&quot;&gt;string literal&lt;/a&gt;</source>
          <target state="translated">모든 &lt;a href=&quot;string_literal&quot;&gt;문자열 리터럴&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c3a06491365351f3135fa57adca77cdbb5bb55da" translate="yes" xml:space="preserve">
          <source>any cast expression (note that compound literals, which look similar, are lvalues)</source>
          <target state="translated">모든 캐스트 표현식 (유사하게 보이는 복합 리터럴은 lvalue 임)</target>
        </trans-unit>
        <trans-unit id="edf8667431a1e779cde6bdce47ba00aaaafd8be3" translate="yes" xml:space="preserve">
          <source>any combination of &lt;a href=&quot;const&quot;&gt;const&lt;/a&gt;, &lt;a href=&quot;restrict&quot;&gt;restrict&lt;/a&gt;, or &lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt; qualifiers, only allowed in function parameter lists; this qualifies the pointer type to which this array parameter is transformed</source>
          <target state="translated">의 조합 &lt;a href=&quot;const&quot;&gt;CONST는&lt;/a&gt; , &lt;a href=&quot;restrict&quot;&gt;제한&lt;/a&gt; , 또는 &lt;a href=&quot;volatile&quot;&gt;휘발성&lt;/a&gt; 예선 만 함수 매개 변수 목록에서 허용; 이 배열 매개 변수가 변환되는 포인터 유형을 규정합니다.</target>
        </trans-unit>
        <trans-unit id="cbe45f6357925029ecee21a95f05d973c784b3fa" translate="yes" xml:space="preserve">
          <source>any complete &lt;a href=&quot;compatible_type&quot;&gt;object type&lt;/a&gt; that isn't variably-modified (that is, not VLA or pointer to VLA).</source>
          <target state="translated">가변적으로 수정되지 않은 완전한 &lt;a href=&quot;compatible_type&quot;&gt;객체 유형&lt;/a&gt; (즉, VLA 또는 VLA에 대한 포인터가 아님)</target>
        </trans-unit>
        <trans-unit id="d364f2a845a6f4b4da77a65cd5239650881109ee" translate="yes" xml:space="preserve">
          <source>any expression</source>
          <target state="translated">어떤 표현</target>
        </trans-unit>
        <trans-unit id="efae355cfebbfc312e651b7bece35ca4f1afee8f" translate="yes" xml:space="preserve">
          <source>any expression (except for the &lt;a href=&quot;operator_other#Comma_operator&quot;&gt;comma operator&lt;/a&gt;) of any type and value category</source>
          <target state="translated">모든 유형 및 값 범주의 모든 표현식 ( &lt;a href=&quot;operator_other#Comma_operator&quot;&gt;쉼표 연산자&lt;/a&gt; 제외 )</target>
        </trans-unit>
        <trans-unit id="e4266fde639a4ad2a2c6e4530bc1873de5bec3c9" translate="yes" xml:space="preserve">
          <source>any expression (except for the &lt;a href=&quot;operator_other#Comma_operator&quot;&gt;comma operator&lt;/a&gt;) whose type must be compatible with one of the type-names if the &lt;code&gt;default&lt;/code&gt; association is not used</source>
          <target state="translated">&lt;code&gt;default&lt;/code&gt; 연관이 사용되지 않는 경우 유형이 유형 이름 중 하나와 호환되어야 하는 모든 표현식 ( &lt;a href=&quot;operator_other#Comma_operator&quot;&gt;쉼표 연산자&lt;/a&gt; 제외 )</target>
        </trans-unit>
        <trans-unit id="ae479c7422b7687a645ec839ada30bfea7332b70" translate="yes" xml:space="preserve">
          <source>any expression of pointer-to-function type (after &lt;a href=&quot;conversion#Lvalue_conversions&quot;&gt;lvalue conversions&lt;/a&gt;)</source>
          <target state="translated">포인터-함수 유형의 표현 ( &lt;a href=&quot;conversion#Lvalue_conversions&quot;&gt;lvalue 변환&lt;/a&gt; 후 )</target>
        </trans-unit>
        <trans-unit id="baffd80eccda4b18e67a2afbc7b772a872267bab" translate="yes" xml:space="preserve">
          <source>any expression other than &lt;a href=&quot;operator_other#Comma_operator&quot;&gt;comma operator&lt;/a&gt;, designates the number of elements in the array</source>
          <target state="translated">&lt;a href=&quot;operator_other#Comma_operator&quot;&gt;쉼표 연산자&lt;/a&gt; 이외의 모든 표현식 은 배열의 요소 수를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="c84440a43394480ce95b6f58815357f35ade0d15" translate="yes" xml:space="preserve">
          <source>any expression other than another comma operator (in other words, comma operator's &lt;a href=&quot;operator_precedence&quot;&gt;associativity&lt;/a&gt; is left-to-right)</source>
          <target state="translated">다른 쉼표 연산자 이외의 표현 (즉, 쉼표 연산자의 &lt;a href=&quot;operator_precedence&quot;&gt;연관성&lt;/a&gt; 은 왼쪽에서 오른쪽으로)</target>
        </trans-unit>
        <trans-unit id="eed48d916d76a9379a8f2ebc1afbce301f417fd2" translate="yes" xml:space="preserve">
          <source>any function call expression</source>
          <target state="translated">모든 함수 호출 표현식</target>
        </trans-unit>
        <trans-unit id="b0848b3f1b7b548a5a86bee48ad1b2613e0ed23f" translate="yes" xml:space="preserve">
          <source>any identifier that appears in a parameter list that could be treated as a typedef name or as a parameter name is treated as a typedef name: &lt;code&gt;int f(&lt;a href=&quot;../types/size_t&quot;&gt;size_t&lt;/a&gt;, &lt;a href=&quot;../types/integer&quot;&gt;uintptr_t&lt;/a&gt;)&lt;/code&gt; is parsed as a new-style declarator for a function taking two unnamed parameters of type size_t and uintptr_t, not an old-style declarator that begins the definition of a function taking two parameters named &quot;size_t&quot; and &quot;uintptr_t&quot;</source>
          <target state="translated">타입 정의의 이름 또는 매개 변수 이름으로 처리 될 수있는 파라미터의리스트에 표시가 타입 정의의 이름으로 처리되는 임의의 식별자 : &lt;code&gt;int f(&lt;a href=&quot;../types/size_t&quot;&gt;size_t&lt;/a&gt;, &lt;a href=&quot;../types/integer&quot;&gt;uintptr_t&lt;/a&gt;)&lt;/code&gt; 두 이름 파라미터를 취하는 함수에 대한 새로운 스타일 선언자로 파싱 size_t 및 uintptr_t 유형으로, &quot;size_t&quot;및 &quot;uintptr_t&quot;라는 두 개의 매개 변수를 사용하는 함수의 정의를 시작하는 구식 선언자가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="faab3a1343209dbb605e46853e2150f406236f5f" translate="yes" xml:space="preserve">
          <source>any integer &lt;a href=&quot;constant_expression&quot;&gt;constant expression&lt;/a&gt;</source>
          <target state="translated">모든 정수 &lt;a href=&quot;constant_expression&quot;&gt;상수 표현식&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0a42a9b8586a31a43c72b8b3bf40ccd35bf216d0" translate="yes" xml:space="preserve">
          <source>any number of variable declarations, &lt;a href=&quot;bit_field&quot;&gt;bit field&lt;/a&gt; declarations, and &lt;a href=&quot;static_assert&quot;&gt;static assert&lt;/a&gt; declarations. Members of incomplete type and members of function type are not allowed (except for the flexible array member described below)</source>
          <target state="translated">변수 선언, &lt;a href=&quot;bit_field&quot;&gt;비트 필드&lt;/a&gt; 선언 및 &lt;a href=&quot;static_assert&quot;&gt;정적 어설 션&lt;/a&gt; 선언 불완전한 유형의 멤버 및 함수 유형의 멤버는 허용되지 않습니다 (아래 설명 된 가변 배열 멤버 제외).</target>
        </trans-unit>
        <trans-unit id="3c6a297d6eb7cf8a88b76ca1cdba0c369a078b9a" translate="yes" xml:space="preserve">
          <source>any number of variable declarations, bit field declarations, and static assert declarations. Members of incomplete type and members of function type are not allowed.</source>
          <target state="translated">변수 선언, 비트 필드 선언 및 정적 어설 션 선언 불완전한 유형의 멤버 및 함수 유형의 멤버는 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="991db7190ce90937e5272c02ff09f8c835ed6bb6" translate="yes" xml:space="preserve">
          <source>any of the arguments corresponding to &lt;code&gt;%s&lt;/code&gt; is a null pointer</source>
          <target state="translated">&lt;code&gt;%s&lt;/code&gt; 해당하는 인수 는 널 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="b9761fa8c99d6412896030019b9e1f7238a8ecc1" translate="yes" xml:space="preserve">
          <source>any of the arguments of pointer type is a null pointer</source>
          <target state="translated">포인터 유형의 인수는 널 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="c931b47c239c4cdb5b5676505bab2ff58278d90b" translate="yes" xml:space="preserve">
          <source>any other expression that may be accepted by the currently installed C &lt;code&gt;locale&lt;/code&gt;</source>
          <target state="translated">현재 설치된 C &lt;code&gt;locale&lt;/code&gt; 에서 허용 할 수있는 다른 표현식</target>
        </trans-unit>
        <trans-unit id="ee46d10ed7aeb7823d65780e2d60186ac6dbd911" translate="yes" xml:space="preserve">
          <source>any parameter of array type is adjusted to the corresponding pointer type, which may be qualified if there are qualifiers between the square brackets of the array declarator(since C99)</source>
          <target state="translated">배열 유형의 모든 매개 변수는 해당 포인터 유형으로 조정되며 배열 선언자의 대괄호 사이에 한정자가있는 경우 자격이 될 수 있습니다 (C99 이후)</target>
        </trans-unit>
        <trans-unit id="9616ae7c6d96ecd7803690f307d2d3795f91f219" translate="yes" xml:space="preserve">
          <source>any parameter of function type is adjusted to the corresponding pointer type</source>
          <target state="translated">함수 유형의 모든 매개 변수는 해당 포인터 유형으로 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="da817154a673bbb68947705f741c46db2b6e0eb1" translate="yes" xml:space="preserve">
          <source>any type other than array or function. For (1), type-name also cannot be atomic or cvr-qualified</source>
          <target state="translated">배열이나 함수 이외의 모든 유형 (1)의 경우, type-name도 원자 또는 cvr 규정이 될 수 없습니다</target>
        </trans-unit>
        <trans-unit id="831fce60a83f5aaa718757021717e0ba1f826a53" translate="yes" xml:space="preserve">
          <source>any use of the pointer that was deallocated by &lt;code&gt;&lt;a href=&quot;../memory/free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../memory/realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../memory/free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../memory/realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt; 에 의해 할당 해제 된 포인터 사용</target>
        </trans-unit>
        <trans-unit id="ac78b022715c5b8357b4dca8045e8463b4de2124" translate="yes" xml:space="preserve">
          <source>ap</source>
          <target state="translated">ap</target>
        </trans-unit>
        <trans-unit id="db43bff34c78044870bc6b1ae2aa16902bb1bb8a" translate="yes" xml:space="preserve">
          <source>append</source>
          <target state="translated">append</target>
        </trans-unit>
        <trans-unit id="4bfbd9f07437718b73115a6a0356598c7d27a84a" translate="yes" xml:space="preserve">
          <source>append extended</source>
          <target state="translated">확장 추가</target>
        </trans-unit>
        <trans-unit id="cea4e18dac8b6b256584c24f08f1c66e6c79b375" translate="yes" xml:space="preserve">
          <source>appends a certain amount of wide characters from one wide string to another</source>
          <target state="translated">하나의 넓은 문자열에서 다른 넓은 문자열로 일정한 양의 넓은 문자를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="1975c46fbfd68df17ca6344eed23e3a6512c750c" translate="yes" xml:space="preserve">
          <source>appends a copy of one wide string to another</source>
          <target state="translated">하나의 넓은 문자열의 복사본을 다른 문자열에 추가</target>
        </trans-unit>
        <trans-unit id="df903074f885f1f15c3daa6ce45002105c249232" translate="yes" xml:space="preserve">
          <source>arbitrary hexadecimal value</source>
          <target state="translated">임의의 16 진수 값</target>
        </trans-unit>
        <trans-unit id="4369a0f24ae39fbe536286ba71dd880472aa2770" translate="yes" xml:space="preserve">
          <source>arbitrary octal value</source>
          <target state="translated">임의의 8 진수 값</target>
        </trans-unit>
        <trans-unit id="04d6e2b300911995efa37b6707fdc02975a3021c" translate="yes" xml:space="preserve">
          <source>arg</source>
          <target state="translated">arg</target>
        </trans-unit>
        <trans-unit id="8e52a50224511e55b3cb5a078473fdd0e08a5b1e" translate="yes" xml:space="preserve">
          <source>arg-1</source>
          <target state="translated">arg-1</target>
        </trans-unit>
        <trans-unit id="da7228e374c9c5c17ac8a45e24698a76423635ad" translate="yes" xml:space="preserve">
          <source>argc</source>
          <target state="translated">argc</target>
        </trans-unit>
        <trans-unit id="846a4bbd93bdd85706d5de7416afac88a45f8ae8" translate="yes" xml:space="preserve">
          <source>argument list in a function call</source>
          <target state="translated">함수 호출의 인수 목록</target>
        </trans-unit>
        <trans-unit id="9d12281d0d35ef85c73f95929507c005a2287e93" translate="yes" xml:space="preserve">
          <source>argument to fseek() indicating seeking from beginning of the file</source>
          <target state="translated">파일의 처음부터 탐색을 나타내는 fseek ()의 ​​인수</target>
        </trans-unit>
        <trans-unit id="72786d66722ca4b98208afbe41b8eb11812480a7" translate="yes" xml:space="preserve">
          <source>argument to fseek() indicating seeking from end of the file</source>
          <target state="translated">파일 끝에서 탐색을 나타내는 fseek ()의 ​​인수</target>
        </trans-unit>
        <trans-unit id="d32b6d5580bb50f023a54f00203dfa3201f6ec89" translate="yes" xml:space="preserve">
          <source>argument to fseek() indicating seeking from the current file position</source>
          <target state="translated">현재 파일 위치에서 탐색을 나타내는 fseek ()의 ​​인수</target>
        </trans-unit>
        <trans-unit id="8d8716aaf8f6527ddb092f5a0c7a3b4f6d8fb6e3" translate="yes" xml:space="preserve">
          <source>argument to pass to the function</source>
          <target state="translated">함수에 전달할 인수</target>
        </trans-unit>
        <trans-unit id="d3bea05ca57a72f813079e31c799c8fa9aec7206" translate="yes" xml:space="preserve">
          <source>argument to setvbuf() indicating fully buffered I/O</source>
          <target state="translated">완전히 버퍼링 된 I / O를 나타내는 setvbuf () 인수</target>
        </trans-unit>
        <trans-unit id="9eb617945b0b4d913edf162e7b8270404a7289c2" translate="yes" xml:space="preserve">
          <source>argument to setvbuf() indicating line buffered I/O</source>
          <target state="translated">라인 버퍼 입출력을 나타내는 setvbuf ()의 인수</target>
        </trans-unit>
        <trans-unit id="7602f5fc169b6cee652722ddadfdd64b78e9e442" translate="yes" xml:space="preserve">
          <source>argument to setvbuf() indicating unbuffered I/O</source>
          <target state="translated">버퍼되지 않은 I / O를 나타내는 setvbuf ()의 인수</target>
        </trans-unit>
        <trans-unit id="cfb1965acdbb56f90805167da69ff708224ab176" translate="yes" xml:space="preserve">
          <source>argument-list</source>
          <target state="translated">argument-list</target>
        </trans-unit>
        <trans-unit id="536f158f6dfd529865dcb865a97bb16804e34d70" translate="yes" xml:space="preserve">
          <source>arguments</source>
          <target state="translated">arguments</target>
        </trans-unit>
        <trans-unit id="6a0f14dd3cb378d1b2fb76510dc53f503afdcc59" translate="yes" xml:space="preserve">
          <source>arguments (depends on the instruction)</source>
          <target state="translated">인수 (명령에 따라 다름)</target>
        </trans-unit>
        <trans-unit id="e2dac687442a0397e2099f1e6330fa3064360636" translate="yes" xml:space="preserve">
          <source>arguments specifying data to print. If any argument after &lt;a href=&quot;../language/conversion#Default_argument_promotions&quot;&gt;default argument promotions&lt;/a&gt; is not the type expected by the corresponding conversion specifier, or if there are fewer arguments than required by &lt;code&gt;format&lt;/code&gt;, the behavior is undefined. If there are more arguments than required by &lt;code&gt;format&lt;/code&gt;, the extraneous arguments are evaluated and ignored</source>
          <target state="translated">인쇄 할 데이터를 지정하는 인수. &lt;a href=&quot;../language/conversion#Default_argument_promotions&quot;&gt;기본 인수 승격&lt;/a&gt; 후 인수 가 해당 변환 지정자에 의해 예상되는 유형이 아니거나 &lt;code&gt;format&lt;/code&gt; 에 필요한 것보다 적은 수의 인수가있는 경우 동작이 정의되지 않습니다. &lt;code&gt;format&lt;/code&gt; 에 필요한 것보다 많은 인수가 있으면 관련 없는 인수가 평가되고 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="ded1eaca9edf12b71d324d9950a6c8f3e3d7ec9a" translate="yes" xml:space="preserve">
          <source>arguments specifying data to print. If any argument after &lt;a href=&quot;../language/conversion#Default_argument_promotions&quot;&gt;default argument promotions&lt;/a&gt; is not the type expected by the corresponding conversion specifier, or if there are fewer arguments than required by &lt;code&gt;format&lt;/code&gt;, the behavior is undefined. If there are more arguments than required by &lt;code&gt;format&lt;/code&gt;, the extraneous arguments are evaluated and ignored.</source>
          <target state="translated">인쇄 할 데이터를 지정하는 인수. &lt;a href=&quot;../language/conversion#Default_argument_promotions&quot;&gt;기본 인수 승격&lt;/a&gt; 후 인수 가 해당 변환 지정자에 의해 예상되는 유형이 아니거나 &lt;code&gt;format&lt;/code&gt; 에 필요한 것보다 적은 수의 인수가있는 경우 동작이 정의되지 않습니다. &lt;code&gt;format&lt;/code&gt; 에 필요한 것보다 많은 인수가 있으면 관련 없는 인수가 평가되고 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="44fa84e333f3362a12273e855dca2caf2666100b" translate="yes" xml:space="preserve">
          <source>argv</source>
          <target state="translated">argv</target>
        </trans-unit>
        <trans-unit id="18ca194aa0f608d645500c4f2354facbbde0a13e" translate="yes" xml:space="preserve">
          <source>arithmetic</source>
          <target state="translated">arithmetic</target>
        </trans-unit>
        <trans-unit id="54fbc403ddb9a8535eac7d7846e5a6e72e05c26e" translate="yes" xml:space="preserve">
          <source>arithmetic constant expression</source>
          <target state="translated">산술 상수 표현</target>
        </trans-unit>
        <trans-unit id="d90b72b26be74b12d744b60937fa2f214a9d2d22" translate="yes" xml:space="preserve">
          <source>array subscript</source>
          <target state="translated">배열 첨자</target>
        </trans-unit>
        <trans-unit id="7cd3365ec5cd3b7bc71721ba577abbedc1bb1832" translate="yes" xml:space="preserve">
          <source>array type of unknown size. It can be completed by a later declaration that specifies the size.</source>
          <target state="translated">알 수없는 크기의 배열 유형 크기를 지정하는 나중에 선언하여 완료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="583b8fc652f8ec109f2a1271c77b0892a560a1c2" translate="yes" xml:space="preserve">
          <source>array types</source>
          <target state="translated">배열 유형</target>
        </trans-unit>
        <trans-unit id="9c5cf9e25955aafadeb0fc934da621efb22c50c4" translate="yes" xml:space="preserve">
          <source>as a single-byte subset, consisting of the following 96 characters:</source>
          <target state="translated">다음 96 문자로 구성된 단일 바이트 서브 세트로서</target>
        </trans-unit>
        <trans-unit id="37066ddedc42722c4e146de881569c7f636156bc" translate="yes" xml:space="preserve">
          <source>as if</source>
          <target state="translated">마치</target>
        </trans-unit>
        <trans-unit id="e4e8f5522c763f7aac74293d814587b7b51ff770" translate="yes" xml:space="preserve">
          <source>as if by assignment</source>
          <target state="translated">과제에 의한 것처럼</target>
        </trans-unit>
        <trans-unit id="64ea9d4459e813837e6b2d6170a333da47079360" translate="yes" xml:space="preserve">
          <source>as part of</source>
          <target state="translated">의 일부로</target>
        </trans-unit>
        <trans-unit id="4d520093947381fd24996c7c477fa5ad1a40de0f" translate="yes" xml:space="preserve">
          <source>as the left-hand operand of the &lt;a href=&quot;operator_assignment&quot;&gt;assignment and compound assignment&lt;/a&gt; operators.</source>
          <target state="translated">&lt;a href=&quot;operator_assignment&quot;&gt;대입 및 복합 대입&lt;/a&gt; 연산자 의 왼쪽 피연산자로 .</target>
        </trans-unit>
        <trans-unit id="4ec04b9d73f6eba21c4562d845ad4aa147fdd3a1" translate="yes" xml:space="preserve">
          <source>as the left-hand operand of the &lt;a href=&quot;operator_member_access&quot;&gt;member access&lt;/a&gt; (dot) operator.</source>
          <target state="translated">&lt;a href=&quot;operator_member_access&quot;&gt;멤버 액세스&lt;/a&gt; (도트) 연산자 의 왼쪽 피연산자로 .</target>
        </trans-unit>
        <trans-unit id="e32116980421df3eac0e9a887ff55708bc31c675" translate="yes" xml:space="preserve">
          <source>as the operand of &lt;a href=&quot;alignof&quot;&gt;_Alignof&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;alignof&quot;&gt;_Alignof&lt;/a&gt; 의 피연산자로</target>
        </trans-unit>
        <trans-unit id="01ab613c21670dea20248904a5545953ef13d684" translate="yes" xml:space="preserve">
          <source>as the operand of &lt;a href=&quot;sizeof&quot;&gt;sizeof&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;sizeof&quot;&gt;sizeof&lt;/a&gt; 의 피연산자로</target>
        </trans-unit>
        <trans-unit id="ee0201522cbd2f212d3fe577bf15df3825cc8ff2" translate="yes" xml:space="preserve">
          <source>as the operand of the &lt;a href=&quot;operator_member_access&quot;&gt;address-of operator&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;operator_member_access&quot;&gt;주소&lt;/a&gt; 연산자의 피연산자로</target>
        </trans-unit>
        <trans-unit id="0ccde22a39f66d23bee179ee345a3f26a32ed97f" translate="yes" xml:space="preserve">
          <source>as the operand of the &lt;a href=&quot;operator_member_access&quot;&gt;address-of operator&lt;/a&gt; (except if the lvalue designates a &lt;a href=&quot;bit_field&quot;&gt;bit field&lt;/a&gt; or was declared &lt;a href=&quot;storage_duration&quot;&gt;register&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;operator_member_access&quot;&gt;주소&lt;/a&gt; 연산자의 피연산자로 (lvalue가 &lt;a href=&quot;bit_field&quot;&gt;비트 필드를&lt;/a&gt; 지정 하거나 &lt;a href=&quot;storage_duration&quot;&gt;register&lt;/a&gt; 로 선언 된 경우 제외 ).</target>
        </trans-unit>
        <trans-unit id="61981e5cabd311f63537d72c30f35aa168dcd3f1" translate="yes" xml:space="preserve">
          <source>as the operand of the &lt;a href=&quot;operator_member_access&quot;&gt;address-of operator&lt;/a&gt; (if allowed)</source>
          <target state="translated">&lt;a href=&quot;operator_member_access&quot;&gt;주소&lt;/a&gt; 연산자의 피연산자로 (허용 된 경우)</target>
        </trans-unit>
        <trans-unit id="f8ff5014bfefda97f58711957a14dd50eb553afd" translate="yes" xml:space="preserve">
          <source>as the operand of the pre/post &lt;a href=&quot;operator_incdec&quot;&gt;increment and decrement operators&lt;/a&gt;.</source>
          <target state="translated">사전 / 사후 &lt;a href=&quot;operator_incdec&quot;&gt;증가 및 감소 연산자&lt;/a&gt; 의 피연산자로 .</target>
        </trans-unit>
        <trans-unit id="edbd39f8302a9536a17e0200de5a48a17788a7f2" translate="yes" xml:space="preserve">
          <source>as the string literal used for &lt;a href=&quot;array_initialization&quot;&gt;array initialization&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;array_initialization&quot;&gt;배열 초기화에&lt;/a&gt; 사용되는 문자열 리터럴로</target>
        </trans-unit>
        <trans-unit id="7fd4ec431b19760a17e098545249b59de85e86b2" translate="yes" xml:space="preserve">
          <source>as the type specifier in the &lt;a href=&quot;declarations&quot;&gt;declaration grammar&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;declarations&quot;&gt;선언 문법&lt;/a&gt; 에서 형식 지정자로 :</target>
        </trans-unit>
        <trans-unit id="10b28a347a252156b936f911d1cc72e64542d263" translate="yes" xml:space="preserve">
          <source>asctime, asctime_s</source>
          <target state="translated">asctime, asctime_s</target>
        </trans-unit>
        <trans-unit id="42142bd98fb9dd05c15c3597bae5919f33b72f04" translate="yes" xml:space="preserve">
          <source>asctime_s</source>
          <target state="translated">asctime_s</target>
        </trans-unit>
        <trans-unit id="2344ecbfe0be5e18554e8a8e920e86bed313503e" translate="yes" xml:space="preserve">
          <source>asctimeasctime_s</source>
          <target state="translated">asctimeasctime_s</target>
        </trans-unit>
        <trans-unit id="f6b3e9a1435d3f432e7a6b9003583871fcb26de3" translate="yes" xml:space="preserve">
          <source>asin</source>
          <target state="translated">asin</target>
        </trans-unit>
        <trans-unit id="87ef31809f8e6b00b30d4d5688627671939aeffb" translate="yes" xml:space="preserve">
          <source>asin(iz)</source>
          <target state="translated">asin(iz)</target>
        </trans-unit>
        <trans-unit id="c5ba758985d5a60f7caa44c3627a9bdad1ebbe2c" translate="yes" xml:space="preserve">
          <source>asin, asinf, asinl</source>
          <target state="translated">asin, asinf, asinl</target>
        </trans-unit>
        <trans-unit id="cc750b867f9dc58a4f03be277005b693adb6882e" translate="yes" xml:space="preserve">
          <source>asinasinfasinl</source>
          <target state="translated">asinasinfasinl</target>
        </trans-unit>
        <trans-unit id="d7d3dd685f3472024a78ef2982b478006acd6afc" translate="yes" xml:space="preserve">
          <source>asinh</source>
          <target state="translated">asinh</target>
        </trans-unit>
        <trans-unit id="98f5c9543105e3c4710f893fe6513249d1460b35" translate="yes" xml:space="preserve">
          <source>asinh, asinhf, asinhl</source>
          <target state="translated">asinh, asinhf, asinhl</target>
        </trans-unit>
        <trans-unit id="c992c5efc8f80141b44689f0e07c943fb9a30aa8" translate="yes" xml:space="preserve">
          <source>asinhasinhfasinhl</source>
          <target state="translated">asinhasinhfasinhl</target>
        </trans-unit>
        <trans-unit id="48cf2dd5233a6f36a4e6889905ffcff6691267da" translate="yes" xml:space="preserve">
          <source>asinhl</source>
          <target state="translated">asinhl</target>
        </trans-unit>
        <trans-unit id="e64a2f83388bdb9b16130ec9cd1a83a7f7338b24" translate="yes" xml:space="preserve">
          <source>asinl</source>
          <target state="translated">asinl</target>
        </trans-unit>
        <trans-unit id="64b5daad5073849378993ba34e058d7008293097" translate="yes" xml:space="preserve">
          <source>assert</source>
          <target state="translated">assert</target>
        </trans-unit>
        <trans-unit id="f26b63d628c9b5679c54e6f8f5ee244932da2d7d" translate="yes" xml:space="preserve">
          <source>assignment</source>
          <target state="translated">assignment</target>
        </trans-unit>
        <trans-unit id="f494b88f97fbaa7c60689f58dce7974ecb8e3e4c" translate="yes" xml:space="preserve">
          <source>assignment and compound assignment operators (note: they are lvalues in C++)</source>
          <target state="translated">대입 및 복합 대입 연산자 (참고 : C ++에서는 lvalue 임)</target>
        </trans-unit>
        <trans-unit id="7d752f2c5e9504352a8b5051da82d8c592e4d092" translate="yes" xml:space="preserve">
          <source>asynchronous</source>
          <target state="translated">asynchronous</target>
        </trans-unit>
        <trans-unit id="b4e380389a774a586c5fa16ad6f747ccd0f5dd49" translate="yes" xml:space="preserve">
          <source>at least</source>
          <target state="translated">적어도</target>
        </trans-unit>
        <trans-unit id="575f12d548b9fd6af3f0619c3c5f99b4dc5da351" translate="yes" xml:space="preserve">
          <source>at least 8, 16, 32 and 64 bits respectively</source>
          <target state="translated">각각 8, 16, 32 및 64 비트 이상</target>
        </trans-unit>
        <trans-unit id="4b3167c14955e1f3fea9853d7148dcb75a62f7ab" translate="yes" xml:space="preserve">
          <source>at_quick_exit</source>
          <target state="translated">at_quick_exit</target>
        </trans-unit>
        <trans-unit id="f077504d04fa1bc96b042497b434fd33fabdf43d" translate="yes" xml:space="preserve">
          <source>atan</source>
          <target state="translated">atan</target>
        </trans-unit>
        <trans-unit id="fd281638c28da6a30c5b0c730c9b9ec0d88cba4c" translate="yes" xml:space="preserve">
          <source>atan(iz)</source>
          <target state="translated">atan(iz)</target>
        </trans-unit>
        <trans-unit id="df7e2494fec8f83d2e63521682db3853590fe40a" translate="yes" xml:space="preserve">
          <source>atan, atanf, atanl</source>
          <target state="translated">아탄, 아탄 프, 아탄</target>
        </trans-unit>
        <trans-unit id="b1a7357ef61ecd1781b4633dc3e33a383686041c" translate="yes" xml:space="preserve">
          <source>atan2</source>
          <target state="translated">atan2</target>
        </trans-unit>
        <trans-unit id="208f110d2774b4f5fad38662ea6cc831171dabd6" translate="yes" xml:space="preserve">
          <source>atan2, atan2f, atan2l</source>
          <target state="translated">atan2, atan2f, atan2l</target>
        </trans-unit>
        <trans-unit id="b957cefd959bb1c4b5fdb50a314397923487008a" translate="yes" xml:space="preserve">
          <source>atan2atan2fatan2l</source>
          <target state="translated">atan2atan2fatan2l</target>
        </trans-unit>
        <trans-unit id="a02e2f7a37d63971c98216ff7f3b3373699aed5f" translate="yes" xml:space="preserve">
          <source>atan2l</source>
          <target state="translated">atan2l</target>
        </trans-unit>
        <trans-unit id="1cbecfd27a902ae767327ccf26fc508a471b1941" translate="yes" xml:space="preserve">
          <source>atanatanfatanl</source>
          <target state="translated">atanatanfatanl</target>
        </trans-unit>
        <trans-unit id="7684baa497f7669edce3de05984655b59aa5aa40" translate="yes" xml:space="preserve">
          <source>atanh</source>
          <target state="translated">atanh</target>
        </trans-unit>
        <trans-unit id="b065796585ecb12f9248b5ff7df8c24a8b656516" translate="yes" xml:space="preserve">
          <source>atanh, atanhf, atanhl</source>
          <target state="translated">atanh, atanhf, atanhl</target>
        </trans-unit>
        <trans-unit id="0b67f8cc63e7d4d66ac6071e6d9132e68a8b95f5" translate="yes" xml:space="preserve">
          <source>atanhatanhfatanhl</source>
          <target state="translated">atanhatanhfatanhl</target>
        </trans-unit>
        <trans-unit id="61a1ff3103217455c2b8717c437b50d092665e93" translate="yes" xml:space="preserve">
          <source>atanhl</source>
          <target state="translated">atanhl</target>
        </trans-unit>
        <trans-unit id="7beedb8b23716296e0856ec53d68f95fd1f612b5" translate="yes" xml:space="preserve">
          <source>atanl</source>
          <target state="translated">atanl</target>
        </trans-unit>
        <trans-unit id="3853b2fd4c89603fc8835e3e1228e431622c9270" translate="yes" xml:space="preserve">
          <source>atexit</source>
          <target state="translated">atexit</target>
        </trans-unit>
        <trans-unit id="6017383f8fbd1471aeeef3234b4ca0a2acb5156d" translate="yes" xml:space="preserve">
          <source>atof</source>
          <target state="translated">atof</target>
        </trans-unit>
        <trans-unit id="a8abc8e1d18caf883d0fd33d6b1b317350c0f37c" translate="yes" xml:space="preserve">
          <source>atoi, atol, atoll</source>
          <target state="translated">아토이, 아톨, 아톨</target>
        </trans-unit>
        <trans-unit id="c6ad2fc918927ced018e6fe7d948a7ec0fc7ebff" translate="yes" xml:space="preserve">
          <source>atoiatolatoll</source>
          <target state="translated">atoiatolatoll</target>
        </trans-unit>
        <trans-unit id="e154f040d1ad0ab5670d0c3b9dbdf20b2124451d" translate="yes" xml:space="preserve">
          <source>atoll</source>
          <target state="translated">atoll</target>
        </trans-unit>
        <trans-unit id="d20a53d0c79d0d5837445d462c94138fc6bdcc80" translate="yes" xml:space="preserve">
          <source>atomic addition</source>
          <target state="translated">원자 첨가</target>
        </trans-unit>
        <trans-unit id="88e6625eb34f1cb363273fcd051629eb11f3189c" translate="yes" xml:space="preserve">
          <source>atomic bitwise AND</source>
          <target state="translated">원자 비트 AND</target>
        </trans-unit>
        <trans-unit id="5abaebd8a55922cfeed40c417f35cf1942167bdc" translate="yes" xml:space="preserve">
          <source>atomic bitwise OR</source>
          <target state="translated">원자 비트 OR</target>
        </trans-unit>
        <trans-unit id="56f9564609953b60799326151b1ff80328fe5b5f" translate="yes" xml:space="preserve">
          <source>atomic bitwise exclusive OR</source>
          <target state="translated">원자 비트 배타적 OR</target>
        </trans-unit>
        <trans-unit id="922ee459c2e6d7d2fbf1dfd8439b5ffa40fe41b9" translate="yes" xml:space="preserve">
          <source>atomic functions from &lt;a href=&quot;../atomic&quot;&gt;stdatomic.h&lt;/a&gt; if the atomic arguments are lock-free</source>
          <target state="translated">원자 인수에 잠금이없는 경우 &lt;a href=&quot;../atomic&quot;&gt;stdatomic.h의&lt;/a&gt; 원자 함수</target>
        </trans-unit>
        <trans-unit id="a7a9594db0c1ccde731b4b620cec456ded6b35b4" translate="yes" xml:space="preserve">
          <source>atomic subtraction</source>
          <target state="translated">원자 빼기</target>
        </trans-unit>
        <trans-unit id="054e1dc1b63cbf780ada25cf4b64c89fc6cada8b" translate="yes" xml:space="preserve">
          <source>atomic type specifier and qualifier</source>
          <target state="translated">원자 유형 지정자 및 한정자</target>
        </trans-unit>
        <trans-unit id="b5e5e6ab0f5460b564fd920ffd02d7dda388fdc6" translate="yes" xml:space="preserve">
          <source>atomic types</source>
          <target state="translated">원자 유형</target>
        </trans-unit>
        <trans-unit id="5aa17b861e9de9a72a9231f8e499e91b8c772f38" translate="yes" xml:space="preserve">
          <source>atomic_compare_exchange_strongatomic_compare_exchange_strong_explicitatomic_compare_exchange_weakatomic_compare_exchange_weak_explicit</source>
          <target state="translated">atomic_compare_exchange_strongatomic_compare_exchange_strong_explicitatomic_compare_exchange_weakatomic_compare_exchange_weak_explicit</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
