<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="c">
    <body>
      <group id="c">
        <trans-unit id="46bf7c32b091bac31f177b6538a857bc4f99a593" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt; other&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; other&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="537b1d1edf82aeba0b417c8ba71838968c5a62b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;isalnum&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;isalnum&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9f9eb092cbcfe95bdcd0259dd8a630d5021ccbbe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;isalpha&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;isalpha&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f9ce04988731330541a991eb5e7d06dccb14ef08" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;isblank&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;isblank&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3a1eaa994d3269906b2a47c32a8e547fa6acd48b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;iscntrl&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;iscntrl&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c6c38fada3181e93f98fd6a5cc64d639bb008f4f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;isdigit&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;isdigit&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9ee2ff1dcd24794fdc2eeb658a043d3eddab9f4c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;isgraph&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;isgraph&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cc805695234d5269f3894979b9d4d5055e0e4e03" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;islower&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;islower&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7d368a53b3e50cbe2b60f751d23c615e71f69a2f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;isprint&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;isprint&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="edf5be6051afddc9d51019cf62964a443b980d31" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;ispunct&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;ispunct&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0dab79137a8c3f41f95cb2fdba1f4f613fc1cba2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;isspace&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;isspace&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2547b4f8a0a99767af9245458421d60678dfee26" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;isupper&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;isupper&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="92651ef970d99cc14c98cd615af602f9a84c504b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;iswalnum&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;iswalnum&lt;/code&gt;&lt;/strong&gt;.</target>
        </trans-unit>
        <trans-unit id="a9721c714438e2959a6b2dd93edc8f3f8d158f25" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;iswalpha&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;iswalpha&lt;/code&gt;&lt;/strong&gt;.</target>
        </trans-unit>
        <trans-unit id="63cf242f16b8eed04f50e80e12b7fe53c7b60e96" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;iswblank&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;iswblank&lt;/code&gt;&lt;/strong&gt;.</target>
        </trans-unit>
        <trans-unit id="ef1646ab343b83d122b0efbf0b1327ad179544ae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;iswcntrl&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;iswcntrl&lt;/code&gt;&lt;/strong&gt;.</target>
        </trans-unit>
        <trans-unit id="57132c82e4d7dd23822d5e2b00c1360c20c46cad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;iswdigit&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;iswdigit&lt;/code&gt;&lt;/strong&gt;.</target>
        </trans-unit>
        <trans-unit id="eaaeeeb6bf702b4f78258a052af4452dc2690218" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;iswgraph&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;iswgraph&lt;/code&gt;&lt;/strong&gt;.</target>
        </trans-unit>
        <trans-unit id="eef504bf43cd6c27be30cb125fbc497a56a78de2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;iswlower&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;iswlower&lt;/code&gt;&lt;/strong&gt;.</target>
        </trans-unit>
        <trans-unit id="de60e8e30084fb3e157dd6de773b4737e7169d88" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;iswprint&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;iswprint&lt;/code&gt;&lt;/strong&gt;.</target>
        </trans-unit>
        <trans-unit id="4615b2011e8d972dea535045f94bc13827ee65bc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;iswpunct&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;iswpunct&lt;/code&gt;&lt;/strong&gt;.</target>
        </trans-unit>
        <trans-unit id="c5fdebcc026d6a68db49f4b74165ce7f0d912453" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;iswspace&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;iswspace&lt;/code&gt;&lt;/strong&gt;.</target>
        </trans-unit>
        <trans-unit id="20e51610dd3a8beabcd2f164c21da31478eafe74" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;iswupper&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;iswupper&lt;/code&gt;&lt;/strong&gt;.</target>
        </trans-unit>
        <trans-unit id="375e0bd774ab74de342f79f6cb82415b12d14f35" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;iswxdigit&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;iswxdigit&lt;/code&gt;&lt;/strong&gt;.</target>
        </trans-unit>
        <trans-unit id="d84d8f51eeb0c0fa8768438cbf4a31a1157bc640" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;isxdigit&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;isxdigit&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="81c351228e8e2cb7718bc5af2c6012b6ddb15f26" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;-t2&lt;br/&gt;&lt;/sup&gt;d</source>
          <target state="translated">&lt;sup&gt;-t2&lt;br/&gt;&lt;/sup&gt;d</target>
        </trans-unit>
        <trans-unit id="06084185252914fb80c48390ac42871dd29d6c0a" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;-t&lt;/sup&gt; d</source>
          <target state="translated">&lt;sup&gt;-t&lt;/sup&gt; d</target>
        </trans-unit>
        <trans-unit id="ecb9d9cc5013291f759497f08cec925224751c83" translate="yes" xml:space="preserve">
          <source>=arg.</source>
          <target state="translated">=arg.</target>
        </trans-unit>
        <trans-unit id="6dcd4ce23d88e2ee9568ba546c007c63d9131c1b" translate="yes" xml:space="preserve">
          <source>A</source>
          <target state="translated">A</target>
        </trans-unit>
        <trans-unit id="2e3f231a0c0c357ef29a27a75e01c5f0f830c0dc" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt; of an object may provide its initial value through the process known as</source>
          <target state="translated">객체 의 &lt;a href=&quot;declarations&quot;&gt;선언&lt;/a&gt; 은 다음과 같은 프로세스를 통해 초기 값을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f3a3af6eca5ee659c499270442d0bea16af329c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;statements#Labels&quot;&gt;label (and only a label)&lt;/a&gt; declared inside a function is in scope everywhere in that function, in all nested blocks, before and after its own declaration. Note: a label is declared implicitly, by using an otherwise unused identifier before the colon character before any statement.</source>
          <target state="translated">함수 내부에 선언 된 &lt;a href=&quot;statements#Labels&quot;&gt;레이블 (및 레이블 만)&lt;/a&gt; 은 해당 함수의 모든 위치, 모든 중첩 된 블록에서 자체 선언 전후에 적용됩니다. 참고 : 레이블은 명령문 앞에 콜론 문자 앞에 사용되지 않은 식별자를 사용하여 암시 적으로 선언됩니다.</target>
        </trans-unit>
        <trans-unit id="603d648e12123df5062789b6c9b530a246514f04" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;##&lt;/code&gt; operator between any two successive identifiers in the replacement-list runs parameter replacement on the two identifiers and then concatenates the result. This operation is called &quot;concatenation&quot; or &quot;token pasting&quot;. Only tokens that form a valid token together may be pasted: identifiers that form a longer identifier, digits that form a number, or operators &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;=&lt;/code&gt; that form a &lt;code&gt;+=&lt;/code&gt;. A comment cannot be created by pasting &lt;code&gt;/&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt; because comments are removed from text before macro substitution is considered. If the result of concatenation is not a valid token, the behavior is undefined.</source>
          <target state="translated">replacement-list의 두 연속 식별자 사이 의 &lt;code&gt;##&lt;/code&gt; 연산자는 두 식별자에 대해 매개 변수 교체를 실행 한 다음 결과를 연결합니다. 이 작업을 &quot;연결&quot;또는 &quot;토큰 붙여 넣기&quot;라고합니다. 유효한 토큰을 구성하는 토큰 만 붙여 넣을 수 있습니다. 더 긴 식별자를 구성하는 식별자, 숫자를 구성하는 숫자 또는 &lt;code&gt;+&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; 를 구성하는 연산자 + 및 &lt;code&gt;+=&lt;/code&gt; . &lt;code&gt;/&lt;/code&gt; 및 &lt;code&gt;*&lt;/code&gt; 를 붙여서 댓글을 작성할 수 없습니다.매크로 대체를 고려하기 전에 텍스트에서 주석이 제거되므로 . 연결 결과가 유효한 토큰이 아닌 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f47fde5c22af25ab0ffba150ed15a83e7199e428" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;do-while&lt;/code&gt; statement causes the statement (also called</source>
          <target state="translated">A는 &lt;code&gt;do-while&lt;/code&gt; 문은 문을 유발 (또한</target>
        </trans-unit>
        <trans-unit id="3f288f6fc591d96442bb174583cfa9db05dbe91d" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;while&lt;/code&gt; statement causes the statement (also called</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; 문은 문을 유발 (또한</target>
        </trans-unit>
        <trans-unit id="b3f6ff76b0a886129453c93b5f0c76da0cfdd30b" translate="yes" xml:space="preserve">
          <source>A C program is a sequence of text files (typically header and source files) that contain &lt;a href=&quot;declarations&quot;&gt;declarations&lt;/a&gt;. They undergo &lt;a href=&quot;translation_phases&quot;&gt;translation&lt;/a&gt; to become an executable program, which is executed when the OS calls its &lt;a href=&quot;main_function&quot;&gt;main function&lt;/a&gt; (unless it is itself the OS or another</source>
          <target state="translated">AC 프로그램은 &lt;a href=&quot;declarations&quot;&gt;선언&lt;/a&gt; 을 포함하는 일련의 텍스트 파일 (일반적으로 헤더 및 소스 파일)입니다 . 그들은 받아야 &lt;a href=&quot;translation_phases&quot;&gt;번역&lt;/a&gt; 운영체제가 호출 할 때 실행되는 실행 프로그램을, 될 &lt;a href=&quot;main_function&quot;&gt;주요 기능을&lt;/a&gt; (그 자체를하지 않는 한 OS 나 다른</target>
        </trans-unit>
        <trans-unit id="8feba51dfd70e75bb34dad80e127aae9226924af" translate="yes" xml:space="preserve">
          <source>A C++-style comment may appear within a C-style comment; this is a mechanism for excluding a small block of source code:</source>
          <target state="translated">C ++ 스타일 주석은 C 스타일 주석 내에 나타날 수 있습니다. 이것은 작은 소스 코드 블록을 제외하기위한 메커니즘입니다.</target>
        </trans-unit>
        <trans-unit id="361abe056c46779921476d60896b385658ec3cd3" translate="yes" xml:space="preserve">
          <source>A C-style comment may appear within a C++-style comment:</source>
          <target state="translated">C 스타일 주석은 C ++ 스타일 주석 내에 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c38d4f0fff6ac9b2c2295060922485f792b04682" translate="yes" xml:space="preserve">
          <source>A bit field declaration is a &lt;a href=&quot;struct&quot;&gt;struct&lt;/a&gt; or &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt; member declaration which uses the following &lt;a href=&quot;declarations&quot;&gt;declarator&lt;/a&gt;:</source>
          <target state="translated">비트 필드 선언은 다음 &lt;a href=&quot;declarations&quot;&gt;선언자&lt;/a&gt; 를 사용 하는 &lt;a href=&quot;struct&quot;&gt;구조체&lt;/a&gt; 또는 &lt;a href=&quot;union&quot;&gt;공용체&lt;/a&gt; 멤버 선언입니다 .</target>
        </trans-unit>
        <trans-unit id="ecea6dbeee94545ded8e32b6cbfdc17fbe02cdaf" translate="yes" xml:space="preserve">
          <source>A block scope restrict-qualified pointer makes an aliasing assertion that is limited to its block. It allows local assertions that apply only to important blocks, such as tight loops. It also makes it possible to convert a function that takes restrict-qualified pointers into a macro:</source>
          <target state="translated">블록 범위 제한 한정 포인터는 블록으로 제한되는 앨리어싱 명제를 만듭니다. 타이트 루프와 같은 중요한 블록에만 적용되는 로컬 어설 션을 허용합니다. 또한 제한 규정 포인터를 사용하는 함수를 매크로로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e25a945c48cf6f76f2a11977d7e5d96d55161783" translate="yes" xml:space="preserve">
          <source>A break statement cannot be used to break out of multiple nested loops. The &lt;a href=&quot;goto&quot;&gt;goto statement&lt;/a&gt; may be used for this purpose.</source>
          <target state="translated">여러 개의 중첩 된 루프를 중단하는 데 break 문을 사용할 수 없습니다. &lt;a href=&quot;goto&quot;&gt;GOTO 문은&lt;/a&gt; 이 목적을 위해 사용할 수있다.</target>
        </trans-unit>
        <trans-unit id="a7a8603933603ca5102eeb32e317c1c1d5b2f58d" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;free&lt;/code&gt; that deallocates a region of memory</source>
          <target state="translated">메모리 영역을 할당 해제하는 &lt;code&gt;free&lt;/code&gt; 통화</target>
        </trans-unit>
        <trans-unit id="8c457728c5c90222ee97d0a5a9c7631536f84aa6" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;tss_create&lt;/code&gt; from within a thread-specific storage destructor results in undefined behavior.</source>
          <target state="translated">스레드 특정 스토리지 소멸자 내 에서 &lt;code&gt;tss_create&lt;/code&gt; 를 호출하면 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fcaf9a5650cbd2811245352e71e1d893dc23de9d" translate="yes" xml:space="preserve">
          <source>A cast of a non-volatile value to a volatile type has no effect. To access a non-volatile object using volatile semantics, its address must be cast to a pointer-to-volatile and then the access must be made through that pointer.</source>
          <target state="translated">비 휘발성 값을 휘발성 유형으로 캐스트해도 효과가 없습니다. 휘발성 시맨틱을 사용하여 비 휘발성 오브젝트에 액세스하려면 해당 주소를 포인터 대 휘발성으로 캐스트 한 다음 해당 포인터를 통해 액세스해야합니다.</target>
        </trans-unit>
        <trans-unit id="266435bc7e1c5eddbff33669084fc6a3cc68bc0f" translate="yes" xml:space="preserve">
          <source>A collection of operators that do not fit into any of the other major categories.</source>
          <target state="translated">다른 주요 범주에 맞지 않는 연산자 모음.</target>
        </trans-unit>
        <trans-unit id="a0e39b90a6cb653ffa38cbd92a158bb59c3fe2b6" translate="yes" xml:space="preserve">
          <source>A common error is setting the buffer of stdin or stdout to an array whose lifetime ends before the program terminates:</source>
          <target state="translated">일반적인 오류는 stdin 또는 stdout의 버퍼를 프로그램이 종료되기 전에 수명이 끝나는 배열로 설정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="043e96d2c063cdcc5eb90afe38b71a1e2aa56a23" translate="yes" xml:space="preserve">
          <source>A common implementation-defined form of main is &lt;code&gt;int main(int argc, char *argv[], char *envp[])&lt;/code&gt;, where a third argument, of type &lt;code&gt;char*[]&lt;/code&gt;, points at &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/exec.html&quot;&gt;an array of pointers to the host environment variables&lt;/a&gt;.</source>
          <target state="translated">main의 일반적인 구현 정의 형식은 &lt;code&gt;int main(int argc, char *argv[], char *envp[])&lt;/code&gt; . 여기서 &lt;code&gt;char*[]&lt;/code&gt; 유형의 세 번째 인수 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/exec.html&quot;&gt;는 호스트 환경에 대한 포인터 배열을&lt;/a&gt; 가리 킵니다. 변수 .</target>
        </trans-unit>
        <trans-unit id="cfa9c8d2b42454344333fc69a8715babdf4fa1d7" translate="yes" xml:space="preserve">
          <source>A compiler that defines &lt;code&gt;__STDC_IEC_559_COMPLEX__&lt;/code&gt; is not required to support imaginary numbers. POSIX recommends checking if the macro &lt;code&gt;&lt;a href=&quot;imaginary_i&quot;&gt;_Imaginary_I&lt;/a&gt;&lt;/code&gt; is defined to identify imaginary number support.</source>
          <target state="translated">허수를 지원하기 위해 &lt;code&gt;__STDC_IEC_559_COMPLEX__&lt;/code&gt; 를 정의하는 컴파일러 는 필요하지 않습니다. POSIX는 매크로 &lt;code&gt;&lt;a href=&quot;imaginary_i&quot;&gt;_Imaginary_I&lt;/a&gt;&lt;/code&gt; 가 허수 지원을 식별하도록 정의되어 있는지 확인하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="081399ac6b5e4a28bc7390d1cdebdd865a0f239c" translate="yes" xml:space="preserve">
          <source>A compiler that defines &lt;code&gt;__STDC_IEC_559_COMPLEX__&lt;/code&gt; is not required to support imaginary numbers. POSIX recommends checking if the macro &lt;code&gt;_Imaginary_I&lt;/code&gt; is defined to identify imaginary number support.</source>
          <target state="translated">허수를 지원하기 위해 &lt;code&gt;__STDC_IEC_559_COMPLEX__&lt;/code&gt; 를 정의하는 컴파일러 는 필요하지 않습니다. POSIX는 매크로 &lt;code&gt;_Imaginary_I&lt;/code&gt; 가 허수 지원을 식별하도록 정의되어 있는지 확인하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="e7d53908cdda0d9e9b4f6a93e7e463f1fefd5fad" translate="yes" xml:space="preserve">
          <source>A compiler that defines &lt;code&gt;__STDC_IEC_559_COMPLEX__&lt;/code&gt; is recommended, but not required to support imaginary numbers. POSIX recommends checking if the macro &lt;code&gt;&lt;a href=&quot;../numeric/complex/imaginary_i&quot;&gt;_Imaginary_I&lt;/a&gt;&lt;/code&gt; is defined to identify imaginary number support.</source>
          <target state="translated">&lt;code&gt;__STDC_IEC_559_COMPLEX__&lt;/code&gt; 를 정의하는 컴파일러 가 권장되지만 허수를 지원할 필요는 없습니다. POSIX는 매크로 &lt;code&gt;&lt;a href=&quot;../numeric/complex/imaginary_i&quot;&gt;_Imaginary_I&lt;/a&gt;&lt;/code&gt; 가 허수 지원을 식별하도록 정의되어 있는지 확인하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="4402e6f9ef027c378a2aa72fb2a92313d0d247bd" translate="yes" xml:space="preserve">
          <source>A compiler that defines &lt;code&gt;__STDC_IEC_559_COMPLEX__&lt;/code&gt; is recommended, but not required to support imaginary numbers. POSIX recommends checking if the macro &lt;code&gt;&lt;a href=&quot;complex/imaginary_i&quot;&gt;_Imaginary_I&lt;/a&gt;&lt;/code&gt; is defined to identify imaginary number support.</source>
          <target state="translated">&lt;code&gt;__STDC_IEC_559_COMPLEX__&lt;/code&gt; 를 정의하는 컴파일러 가 권장되지만 허수를 지원할 필요는 없습니다. POSIX는 매크로 &lt;code&gt;&lt;a href=&quot;complex/imaginary_i&quot;&gt;_Imaginary_I&lt;/a&gt;&lt;/code&gt; 가 허수 지원을 식별하도록 정의되어 있는지 확인하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="ea77b12b7e2407a17d07af2cbebb15373a1a510a" translate="yes" xml:space="preserve">
          <source>A complex number composed of &lt;code&gt;real&lt;/code&gt; and &lt;code&gt;imag&lt;/code&gt; as the real and imaginary parts.</source>
          <target state="translated">구성 복소수 &lt;code&gt;real&lt;/code&gt; 및 &lt;code&gt;imag&lt;/code&gt; 실수 부와 허수 부분으로.</target>
        </trans-unit>
        <trans-unit id="e64cb23c6cd4a39b1bb7384aaf3e5f0fc40dfca2" translate="yes" xml:space="preserve">
          <source>A complex or imaginary number is a zero if both components are positive or negative zeroes.</source>
          <target state="translated">두 성분 모두 양수 또는 음수 0 인 경우 복소수 또는 허수는 0입니다.</target>
        </trans-unit>
        <trans-unit id="dce1f09c28a8705473a0f7651c9a4b9f78234952" translate="yes" xml:space="preserve">
          <source>A complex or imaginary number is finite if both components are neither infinities nor NaNs.</source>
          <target state="translated">두 성분이 모두 무한대 나 NaN이 아닌 경우 복소수 또는 허수는 유한합니다.</target>
        </trans-unit>
        <trans-unit id="652b9c238709c7d35d2b6d1f52d70d79d08c5684" translate="yes" xml:space="preserve">
          <source>A complex or imaginary number is infinite if one of its components is infinite, even if the other component is NaN.</source>
          <target state="translated">다른 구성 요소가 NaN 인 경우에도 구성 요소 중 하나가 무한한 경우 복소수 또는 허수는 무한합니다.</target>
        </trans-unit>
        <trans-unit id="dfd35d143007cd2afa97becb2a970fcb61fba85f" translate="yes" xml:space="preserve">
          <source>A composite type can be constructed from two types that are compatible; it is a type that is compatible with both of the two types and satisfies the following conditions:</source>
          <target state="translated">복합 유형은 호환 가능한 두 가지 유형으로 구성 할 수 있습니다. 두 유형 모두와 호환되며 다음 조건을 충족시키는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="7840d5c37ff1db5e5e182c7d433c55ae950c092a" translate="yes" xml:space="preserve">
          <source>A compound statement, or</source>
          <target state="translated">복합 진술 또는</target>
        </trans-unit>
        <trans-unit id="fd3c6deaad4f149d8821441e3aeb7cf41936bcd5" translate="yes" xml:space="preserve">
          <source>A copy of the returned string along with the category used in this call to &lt;code&gt;setlocale&lt;/code&gt; may be used later in the program to restore the locale back to the state at the end of this call.</source>
          <target state="translated">&lt;code&gt;setlocale&lt;/code&gt; 호출에 사용 된 카테고리와 함께 리턴 된 문자열의 사본은 프로그램에서 나중에이 호출의 끝에서 로케일을 복원하기 위해 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80b81ef2621bd9443a4bf04efe123ee3d6ed6faf" translate="yes" xml:space="preserve">
          <source>A declaration cannot introduce an identifier if another declaration for the same identifier in the same &lt;a href=&quot;scope&quot;&gt;scope&lt;/a&gt; appears earlier, except that.</source>
          <target state="translated">동일한 &lt;a href=&quot;scope&quot;&gt;범위&lt;/a&gt; 에서 동일한 식별자에 대한 다른 선언이이를 제외하고 일찍 나타나는 경우 선언에서 식별자를 소개 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="3c1639813cef172042dde9fb318ca556d46fc2fb" translate="yes" xml:space="preserve">
          <source>A declaration of the following form.</source>
          <target state="translated">다음 형식의 선언.</target>
        </trans-unit>
        <trans-unit id="a960e4e1d8427b6d3fda100fb6c241d0a214d14b" translate="yes" xml:space="preserve">
          <source>A designator causes the following initializer to initialize of the array element described by the designator. Initialization then continues forward in order, beginning with the next element after the one described by the designator.</source>
          <target state="translated">지정자는 다음 초기화자가 지정자가 설명하는 배열 요소를 초기화하게합니다. 그런 다음 지정자가 설명한 요소 다음에 오는 요소부터 시작하여 순서대로 계속 진행합니다.</target>
        </trans-unit>
        <trans-unit id="4da5ccc11d8af999bc9357c8da2a60aea20aab2d" translate="yes" xml:space="preserve">
          <source>A designator causes the following initializer to initialize the struct member described by the designator. Initialization then continues forward in order of declaration, beginning with the next element declared after the one described by the designator.</source>
          <target state="translated">지정자는 다음 초기화 프로그램이 지정자가 설명하는 구조체 멤버를 초기화하게합니다. 그런 다음 지정자가 지정한 요소 다음에 선언 된 다음 요소부터 시작하여 선언 순서대로 계속 진행합니다.</target>
        </trans-unit>
        <trans-unit id="089c028655f5931200be1bc3ff6ad58ddd4abdfd" translate="yes" xml:space="preserve">
          <source>A domain error or range error may occur if &lt;code&gt;arg&lt;/code&gt; is zero, infinite, or NaN.</source>
          <target state="translated">&lt;code&gt;arg&lt;/code&gt; 가 0, 무한 또는 NaN 이면 도메인 오류 또는 범위 오류가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0004144516b9e50c31b57af7a9296890e6e2c03c" translate="yes" xml:space="preserve">
          <source>A file-scope restrict-qualified pointer has to point into a single array object for the duration of the program. That array object may not be referenced both through the restricted pointer and through either its declared name (if it has one) or another restricted pointer.</source>
          <target state="translated">파일 범위 제한 한정 포인터는 프로그램 기간 동안 단일 배열 객체를 가리켜 야합니다. 해당 배열 객체는 제한된 포인터와 선언 된 이름 (있는 경우) 또는 다른 제한된 포인터를 통해 참조 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="976825cd6143668bd0fe398a656fa05a307069b2" translate="yes" xml:space="preserve">
          <source>A finite value of any real floating type can be implicitly converted to any integer type. Except where covered by boolean conversion above, the rules are:</source>
          <target state="translated">실제 부동 유형의 유한 값은 암시 적으로 임의의 정수 유형으로 변환 될 수 있습니다. 위의 부울 변환이 적용되는 경우를 제외하고 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0ed079bc5d103eb53c8e9924fed905c90fdd8aab" translate="yes" xml:space="preserve">
          <source>A floating constant is a &lt;a href=&quot;value_category&quot;&gt;non-lvalue&lt;/a&gt; expression having the form:</source>
          <target state="translated">부동 상수는 다음 과 같은 형식 의 &lt;a href=&quot;value_category&quot;&gt;비 가치&lt;/a&gt; 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="377954a1c6c62bc023f38ea913ffa855f5cdcee9" translate="yes" xml:space="preserve">
          <source>A function call expression where expression consists entirely of an identifier and that identifier is undeclared acts as though the identifier is declared as.</source>
          <target state="translated">expression이 전적으로 식별자로 구성되고 식별자가 선언되지 않은 함수 호출 표현식은 마치 식별자가 선언 된 것처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="602a406df52d4cd1f2b9ef189b37d9f3edc65dbd" translate="yes" xml:space="preserve">
          <source>A function declaration introduces an &lt;a href=&quot;identifier&quot;&gt;identifier&lt;/a&gt; that designates a function and, optionally, specifies the types of the function parameters (the</source>
          <target state="translated">함수 선언은 도입 &lt;a href=&quot;identifier&quot;&gt;식별자&lt;/a&gt; 선택적 기능을 지정하고 함수 파라미터의 유형 (지정</target>
        </trans-unit>
        <trans-unit id="ec213a1d70975b73f03ef6fb6555f8cf9ab8d93a" translate="yes" xml:space="preserve">
          <source>A function definition associates the function body (a sequence of declarations and statements) with the function name and parameter list. Unlike &lt;a href=&quot;function_declaration&quot;&gt;function declaration&lt;/a&gt;, function definitions are allowed at file scope only (there are no nested functions).</source>
          <target state="translated">함수 정의는 함수 본문 (일련의 선언 및 명령문)을 함수 이름 및 매개 변수 목록과 연관시킵니다. &lt;a href=&quot;function_declaration&quot;&gt;함수 선언&lt;/a&gt; 과 달리 , 함수 정의는 파일 범위에서만 허용됩니다 (중첩 함수는 없습니다).</target>
        </trans-unit>
        <trans-unit id="3703acc891d3a7d6dbd5125eb673a5d5f0dab4f4" translate="yes" xml:space="preserve">
          <source>A function designator (the identifier introduced by a &lt;a href=&quot;function_declaration&quot;&gt;function declaration&lt;/a&gt;) is an expression of function type. When used in any context other than the address-of operator, &lt;a href=&quot;sizeof&quot;&gt;sizeof&lt;/a&gt;, and &lt;a href=&quot;alignof&quot;&gt;_Alignof&lt;/a&gt; (the last two generate compile errors when applied to functions), the function designator is always converted to a non-lvalue pointer to function. Note that the function-call operator is defined for pointers to functions and not for function designators themselves.</source>
          <target state="translated">함수 지정자 ( &lt;a href=&quot;function_declaration&quot;&gt;함수 선언에&lt;/a&gt; 의해 도입 된 식별자 )는 함수 유형의 표현식입니다. address-of 연산자, &lt;a href=&quot;sizeof&quot;&gt;sizeof&lt;/a&gt; 및 &lt;a href=&quot;alignof&quot;&gt;_Alignof&lt;/a&gt; (마지막 두 개는 함수에 적용될 때 컴파일 오류를 생성 함) 이외의 컨텍스트에서 사용될 때 함수 지정자는 항상 함수가 아닌 값이 아닌 포인터로 변환됩니다. 함수 호출 연산자는 함수 지정자 자체가 아니라 함수에 대한 포인터에 대해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="2865a2d6eb5df117f629cdfeaf9bd05dfbbfb70e" translate="yes" xml:space="preserve">
          <source>A function is a C language construct that associates a &lt;a href=&quot;statements#Compound_statements&quot;&gt;compound statement&lt;/a&gt; (the function body) with an &lt;a href=&quot;identifier&quot;&gt;identifier&lt;/a&gt; (the function name). Every C program begins execution from the &lt;a href=&quot;main_function&quot;&gt;main function&lt;/a&gt;, which either terminates, or invokes other, user-defined or library functions.</source>
          <target state="translated">함수는 &lt;a href=&quot;statements#Compound_statements&quot;&gt;복합 명령문&lt;/a&gt; (함수 본문)을 &lt;a href=&quot;identifier&quot;&gt;식별자&lt;/a&gt; (함수 이름) 와 연관시키는 C 언어 구문입니다 . 모든 C 프로그램은 &lt;a href=&quot;main_function&quot;&gt;main 함수&lt;/a&gt; 에서 실행을 시작하여 다른 사용자 정의 또는 라이브러리 함수를 종료하거나 호출합니다.</target>
        </trans-unit>
        <trans-unit id="8751c52383848fc3922df72d6d9844aebc4d6beb" translate="yes" xml:space="preserve">
          <source>A label is an identifier followed by a colon (:) and a statement. Labels are the only identifiers that have</source>
          <target state="translated">레이블은 식별자 다음에 콜론 (:)과 명령문이 있습니다. 라벨은</target>
        </trans-unit>
        <trans-unit id="970388d0171fba77b4f60c1b13ea5429bb78c066" translate="yes" xml:space="preserve">
          <source>A load operation with this memory order performs a</source>
          <target state="translated">이 메모리 순서로로드 조작은</target>
        </trans-unit>
        <trans-unit id="04adb94f807f9fc41a4b16df95c597991972fc35" translate="yes" xml:space="preserve">
          <source>A load operation with this memory order performs an</source>
          <target state="translated">이 메모리 순서로로드 조작은</target>
        </trans-unit>
        <trans-unit id="3b21ef2a1cadb419bb1ba1c86579963e83c28347" translate="yes" xml:space="preserve">
          <source>A load operation with this memory order performs the</source>
          <target state="translated">이 메모리 순서로로드 조작은</target>
        </trans-unit>
        <trans-unit id="1abbd3840931ab83b239511b97b8e829d4c22039" translate="yes" xml:space="preserve">
          <source>A member of a const-qualified structure or union type acquires the qualification of the type it belongs to (both when accessed using the &lt;code&gt;.&lt;/code&gt; operator or the &lt;code&gt;-&amp;gt;&lt;/code&gt; operator).</source>
          <target state="translated">const 한정 구조 또는 공용체 형식의 멤버는 자신이 속한 형식의 자격을 얻습니다 (둘 다 &lt;code&gt;.&lt;/code&gt; 연산자 또는 &lt;code&gt;-&amp;gt;&lt;/code&gt; 연산자를 사용하여 액세스 할 때 ).</target>
        </trans-unit>
        <trans-unit id="264b98c249a9fc7f51bdfe1129cff98f9c148f21" translate="yes" xml:space="preserve">
          <source>A member of a volatile-qualified structure or union type acquires the qualification of the type it belongs to (both when accessed using the &lt;code&gt;.&lt;/code&gt; operator or the &lt;code&gt;-&amp;gt;&lt;/code&gt; operator):</source>
          <target state="translated">휘발성 정규화 구조 또는 공용체 유형의 멤버는 자신이 속한 유형의 규정을 획득합니다 ( &lt;code&gt;.&lt;/code&gt; 연산자 또는 &lt;code&gt;-&amp;gt;&lt;/code&gt; 연산자를 사용하여 액세스 할 때 ).</target>
        </trans-unit>
        <trans-unit id="01857fa2944d04e325044693ba2bf63f5a8cbfe2" translate="yes" xml:space="preserve">
          <source>A multibyte character string is layout-compatible with &lt;a href=&quot;byte&quot;&gt;null-terminated byte string&lt;/a&gt; (NTBS), that is, can be stored, copied, and examined using the same facilities, except for calculating the number of characters. If the correct locale is in effect, I/O functions also handle multibyte strings. Multibyte strings can be converted to and from wide strings using the following locale-dependent conversion functions:</source>
          <target state="translated">멀티 바이트 문자열은 &lt;a href=&quot;byte&quot;&gt;널 종료 바이트 문자열&lt;/a&gt; (NTBS) 과 레이아웃 호환 가능 합니다. 즉, 문자 수 계산을 제외하고 동일한 기능을 사용하여 저장, 복사 및 검사 할 수 있습니다. 올바른 로케일이 유효하면 I / O 함수는 멀티 바이트 문자열도 처리합니다. 다음 로케일 종속 변환 함수를 사용하여 멀티 바이트 문자열을 와이드 문자열로 변환하거나 와이드 문자열에서 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2f7608097bdd67a3d19cac0cace329c7258c084" translate="yes" xml:space="preserve">
          <source>A negative value of &lt;code&gt;time-&amp;gt;tm_isdst&lt;/code&gt; causes &lt;code&gt;mktime&lt;/code&gt; to attempt to determine if Daylight Saving Time was in effect in the specified time.</source>
          <target state="translated">&lt;code&gt;time-&amp;gt;tm_isdst&lt;/code&gt; 의 음수 값 은 &lt;code&gt;mktime&lt;/code&gt; 이 지정된 시간에 일광 절약 시간 제가 유효한지 판별하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="d9811e282e7ba765c54d3daa670df15207f42b43" translate="yes" xml:space="preserve">
          <source>A newly opened stream has no orientation. The first call to &lt;code&gt;fwide&lt;/code&gt; or to any I/O function establishes the orientation: a wide I/O function makes the stream wide-oriented, a narrow I/O function makes the stream narrow-oriented. Once set, the orientation can only be changed with &lt;code&gt;&lt;a href=&quot;io/freopen&quot;&gt;freopen&lt;/a&gt;&lt;/code&gt;. Narrow I/O functions cannot be called on a wide-oriented stream; wide I/O functions cannot be called on a narrow-oriented stream. Wide I/O functions convert between wide and multibyte characters as if by calling &lt;code&gt;&lt;a href=&quot;string/multibyte/mbrtowc&quot;&gt;mbrtowc&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;string/multibyte/wcrtomb&quot;&gt;wcrtomb&lt;/a&gt;&lt;/code&gt;. Unlike the multibyte character strings that are valid in a program, multibyte character sequences in the file may contain embedded nulls and do not have to begin or end in the initial shift state.</source>
          <target state="translated">새로 열린 스트림에는 방향이 없습니다. &lt;code&gt;fwide&lt;/code&gt; 또는 I / O 함수에 대한 첫 번째 호출 은 방향을 설정합니다. 넓은 I / O 함수는 스트림을 넓은 방향으로 만들고, 좁은 I / O 기능은 스트림을 좁은 방향으로 만듭니다. 설정된 후에는 &lt;code&gt;&lt;a href=&quot;io/freopen&quot;&gt;freopen&lt;/a&gt;&lt;/code&gt; 을 통해서만 방향을 변경할 수 있습니다 . 좁은 I / O 함수는 광범위한 스트림에서 호출 할 수 없습니다. 폭이 좁은 스트림에서는 넓은 I / O 함수를 호출 할 수 없습니다. 와이드 I / O 함수는 &lt;code&gt;&lt;a href=&quot;string/multibyte/mbrtowc&quot;&gt;mbrtowc&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;string/multibyte/wcrtomb&quot;&gt;wcrtomb&lt;/a&gt;&lt;/code&gt; 를 호출하여 와이드 및 멀티 바이트 문자를 변환 합니다. 프로그램에서 유효한 멀티 바이트 문자열과 달리 파일의 멀티 바이트 문자 시퀀스에는 포함 된 null이 포함되어있을 수 있으며 초기 시프트 상태에서 시작하거나 끝낼 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f93966d91f05c405ffd7170387e12fc185074d8c" translate="yes" xml:space="preserve">
          <source>A non-static inline function cannot define a non-const function-local static and cannot refer to a file-scope static.</source>
          <target state="translated">정적이 아닌 인라인 함수는 상수가 아닌 함수 로컬 정적을 정의 할 수 없으며 파일 범위 정적을 참조 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="98bb6fdcc52028ba6a8a94a78329f5f014ffb21e" translate="yes" xml:space="preserve">
          <source>A null pointer constant may be &lt;a href=&quot;../language/conversion#Pointer_conversions&quot;&gt;converted&lt;/a&gt; to any pointer type; such conversion results in the null pointer value of that type.</source>
          <target state="translated">널 포인터 상수는 모든 포인터 유형 으로 &lt;a href=&quot;../language/conversion#Pointer_conversions&quot;&gt;변환&lt;/a&gt; 될 수 있습니다 . 이러한 변환은 해당 유형의 널 포인터 값이됩니다.</target>
        </trans-unit>
        <trans-unit id="406f28c4d8ce54f26f886b6cecc24c77951f4ac6" translate="yes" xml:space="preserve">
          <source>A null-terminated byte string (NTBS) is a sequence of nonzero bytes followed by a byte with value zero (the terminating null character). Each byte in a byte string encodes one character of some character set. For example, the character array &lt;code&gt;{'\x63','\x61','\x74','\0'&lt;/code&gt;} is an NTBS holding the string &lt;code&gt;&quot;cat&quot;&lt;/code&gt; in ASCII encoding.</source>
          <target state="translated">NTBS (Null-terminated byte string)는 0이 아닌 바이트 시퀀스이며 값이 0 인 바이트 (종료 null 문자)입니다. 바이트 문자열의 각 바이트는 일부 문자 집합의 한 문자를 인코딩합니다. 예를 들어, 문자 배열 &lt;code&gt;{'\x63','\x61','\x74','\0'&lt;/code&gt; }은 ASCII 인코딩에서 &lt;code&gt;&quot;cat&quot;&lt;/code&gt; 문자열을 보유하는 NTBS 입니다.</target>
        </trans-unit>
        <trans-unit id="3b3fe15454343ce4cbfa8b2d64edd72623154c83" translate="yes" xml:space="preserve">
          <source>A null-terminated multibyte string (NTMBS), or &quot;multibyte string&quot;, is a sequence of nonzero bytes followed by a byte with value zero (the terminating null character).</source>
          <target state="translated">NTMBS (null-terminated multibyte string) 또는 &quot;multibyte string&quot;은 0이 아닌 바이트 시퀀스이며 값이 0 인 바이트 (종료 null 문자)입니다.</target>
        </trans-unit>
        <trans-unit id="0ff0edea7748873d38d10264d61ada446ff85e77" translate="yes" xml:space="preserve">
          <source>A null-terminated wide string is a sequence of valid wide characters, ending with a null-character.</source>
          <target state="translated">널 종료 와이드 문자열은 유효한 와이드 문자 시퀀스이며 널 문자로 끝납니다.</target>
        </trans-unit>
        <trans-unit id="cd957d3196cf2aa0f452a3d6985d383e4ba9d369" translate="yes" xml:space="preserve">
          <source>A pointer to &lt;code&gt;void&lt;/code&gt; can be implicitly converted to and from any pointer to object type with the following semantics:</source>
          <target state="translated">포인터 &lt;code&gt;void&lt;/code&gt; 암시 적으로 다음과 같은 의미를 가진 개체 유형에 대한 포인터로 변환 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="de2d527f4dc091dd493b9a8f9868ef42f64eef36" translate="yes" xml:space="preserve">
          <source>A pointer to a non-volatile type can be implicitly converted to a pointer to the volatile-qualified version of the same or &lt;a href=&quot;compatible_type&quot;&gt;compatible type&lt;/a&gt;. The reverse conversion can be performed with a cast expression.</source>
          <target state="translated">비 휘발성 유형에 대한 포인터는 암시 적으로 동일하거나 &lt;a href=&quot;compatible_type&quot;&gt;호환 가능한 유형&lt;/a&gt; 의 휘발성 규정 버전에 대한 포인터로 암시 적으로 변환 될 수 있습니다 . 역변환은 캐스트 표현식으로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c1876354dd24b2af7bddabb8049a8d468d3ce0c" translate="yes" xml:space="preserve">
          <source>A pointer to a union can be cast to a pointer to each of its members (if a union has bit field members, the pointer to a union can be cast to the pointer to the bit field's underlying type). Likewise, a pointer to any member of a union can be cast to a pointer to the enclosing union.</source>
          <target state="translated">공용체에 대한 포인터는 각 멤버에 대한 포인터로 캐스트 될 수 있습니다. 공용체에 비트 필드 멤버가있는 경우 공용체에 대한 포인터는 비트 필드의 기본 유형에 대한 포인터로 캐스트 될 수 있습니다. 마찬가지로 공용체의 멤버에 대한 포인터를 둘러싸는 공용체에 대한 포인터로 캐스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="268a4e779dda486b15b5e5f3b72d38b0d1eaba3e" translate="yes" xml:space="preserve">
          <source>A pointer to an non-const type can be implicitly converted to a pointer to const-qualified version of the same or &lt;a href=&quot;compatible_type&quot;&gt;compatible type&lt;/a&gt;. The reverse conversion can be performed with a cast expression.</source>
          <target state="translated">비 const 유형에 대한 포인터는 암시 적으로 동일하거나 &lt;a href=&quot;compatible_type&quot;&gt;호환 가능한 유형&lt;/a&gt; 의 const 한정 버전에 대한 포인터로 암시 적으로 변환 될 수 있습니다 . 역변환은 캐스트 표현식으로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82585af59f0bb594a7902f0e32b95152542a8077" translate="yes" xml:space="preserve">
          <source>A pointer to an object (or one past the object) whose lifetime ended has indeterminate value.</source>
          <target state="translated">수명이 종료 된 객체 (또는 객체를 지나친 객체)에 대한 포인터는 값이 결정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bf50860af56aa1252b085a89c9df0b2ec34aa52c" translate="yes" xml:space="preserve">
          <source>A pointer to an unqualified type may be implicitly converted to the pointer to qualified version of that type (in other words, &lt;a href=&quot;const&quot;&gt;const&lt;/a&gt;, &lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt;, and &lt;a href=&quot;restrict&quot;&gt;restrict&lt;/a&gt; qualifiers can be added. The original pointer and the result compare equal.</source>
          <target state="translated">규정되지 않은 유형에 대한 포인터는 해당 유형의 규정 된 버전에 대한 포인터로 내재적으로 변환 될 수 있습니다 (즉, &lt;a href=&quot;const&quot;&gt;const&lt;/a&gt; , &lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt; 및 &lt;a href=&quot;restrict&quot;&gt;제한&lt;/a&gt; 규정 자를 추가 할 수 있음) 원래 포인터와 결과가 동일합니다.</target>
        </trans-unit>
        <trans-unit id="a75bb699e6da13526f0dc68a72d5b021bc5756cb" translate="yes" xml:space="preserve">
          <source>A pointer to function can be initialized with an address of a function. Because of the &lt;a href=&quot;conversion&quot;&gt;function-to-pointer&lt;/a&gt; conversion, the address-of operator is optional:</source>
          <target state="translated">함수에 대한 포인터는 함수의 주소로 초기화 될 수 있습니다. 왜냐하면의 &lt;a href=&quot;conversion&quot;&gt;함수에 대한 포인터&lt;/a&gt; 변환은 주소의 오퍼레이터는 선택적이다 :</target>
        </trans-unit>
        <trans-unit id="9a672c3a635d605d46cb900dc367b14fe6337810" translate="yes" xml:space="preserve">
          <source>A pointer to function can be used on the left-hand side of the &lt;a href=&quot;operator_other#Function_call&quot;&gt;function call operator&lt;/a&gt;; this invokes the pointed-to function:</source>
          <target state="translated">함수에 대한 포인터는 &lt;a href=&quot;operator_other#Function_call&quot;&gt;함수 호출 연산자&lt;/a&gt; 의 왼쪽에서 사용할 수 있습니다 . 이것은 뾰족한 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="bbc12ed44a0708299938681bbc78649632564ce2" translate="yes" xml:space="preserve">
          <source>A pointer to object can be initialized with the result of the &lt;a href=&quot;operator_member_access&quot;&gt;address-of operator&lt;/a&gt; applied to an expression of object type (which may be incomplete):</source>
          <target state="translated">객체에 대한 포인터 는 객체 유형의 표현식에 불완전한 &lt;a href=&quot;operator_member_access&quot;&gt;주소 연산자를&lt;/a&gt; 적용하여 초기화 할 수 있습니다 (불완전 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="e75b4fd545bf145657eb8864911b4552c5e00b3f" translate="yes" xml:space="preserve">
          <source>A pointer to the previously-installed runtime constraints handler. (note: this pointer is never a null pointer because calling &lt;code&gt;set_constraint_handler_s(&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;)&lt;/code&gt; sets up the system default handler).</source>
          <target state="translated">이전에 설치된 런타임 제약 조건 처리기에 대한 포인터 (참고 : &lt;code&gt;set_constraint_handler_s(&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;)&lt;/code&gt; 호출 하면 시스템 기본 핸들러가 설정 되므로이 포인터는 절대 널 포인터가 아닙니다 .)</target>
        </trans-unit>
        <trans-unit id="1e0960972641b3c0a03c6a7b75123a8d844b3797" translate="yes" xml:space="preserve">
          <source>A pointer to this function can be passed to &lt;a href=&quot;set_constraint_handler_s&quot;&gt;set_constraint_handler_s&lt;/a&gt; to establish a runtime constraints violation handler that does nothing.  As with all bounds-checked functions, &lt;code&gt;ignore_handler_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant &lt;code&gt;1&lt;/code&gt; before including &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수에 대한 포인터는 &lt;a href=&quot;set_constraint_handler_s&quot;&gt;set_constraint_handler_s&lt;/a&gt; 에 전달하여 아무것도하지 않는 런타임 제약 조건 위반 처리기를 설정할 수 있습니다 . 모든 경계 검사 함수와 &lt;code&gt;ignore_handler_s&lt;/code&gt; 는 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 이 구현에 의해 정의되고 사용자가 &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt; &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; &amp;gt; 를 포함하기 전에 __STDC_WANT_LIB_EXT1__ 을 정수 상수 &lt;code&gt;1&lt;/code&gt; 로 정의한 경우에만 사용 가능하도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="93cf80347c7d11084a2a6667157a9584d0768c8f" translate="yes" xml:space="preserve">
          <source>A pointer to this function can be passed to &lt;a href=&quot;set_constraint_handler_s&quot;&gt;set_constraint_handler_s&lt;/a&gt; to establish a runtime constraints violation handler.  As with all bounds-checked functions, &lt;code&gt;abort_handler_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant &lt;code&gt;1&lt;/code&gt; before including &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수에 대한 포인터는 &lt;a href=&quot;set_constraint_handler_s&quot;&gt;set_constraint_handler_s&lt;/a&gt; 에 전달하여 런타임 제한 조건 위반 핸들러를 설정할 수 있습니다 . 모든 경계 검사 함수와 &lt;code&gt;abort_handler_s&lt;/code&gt; 는 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 이 구현에 의해 정의되고 사용자가 &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt; &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; &amp;gt; 를 포함하기 전에 __STDC_WANT_LIB_EXT1__ 을 정수 상수 &lt;code&gt;1&lt;/code&gt; 로 정의한 경우에만 사용 가능하도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="dc6f29c561783d3fd50e7713005eb570a71543db" translate="yes" xml:space="preserve">
          <source>A post-C11 defect report DR 427 changes the semantics of preparing function parameters when calling a function with a prototype from assignment to initialization from their corresponding arguments, in order to allow parameters of const-qualified type (which are</source>
          <target state="translated">C11 이후 결함 보고서 DR 427은 const 한정 유형의 매개 변수를 허용하기 위해 프로토 타입을 사용하여 할당에서 초기화까지 해당 인수에서 초기화로 함수를 호출 할 때 함수 매개 변수 준비의 의미를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="306aa42e0fc0f9009433757fb90b670651e295cb" translate="yes" xml:space="preserve">
          <source>A previous call to &lt;code&gt;&lt;a href=&quot;free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt; that deallocates a region of memory</source>
          <target state="translated">에 대한 이전 호출 &lt;code&gt;&lt;a href=&quot;free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt; 을 메모리 영역의 할당을 해제</target>
        </trans-unit>
        <trans-unit id="13ef2ca779cb61f44381f5a039956356e16db10c" translate="yes" xml:space="preserve">
          <source>A previous call to &lt;code&gt;&lt;a href=&quot;free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;realloc&lt;/code&gt; that deallocates a region of memory</source>
          <target state="translated">에 대한 이전 호출 &lt;code&gt;&lt;a href=&quot;free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;realloc&lt;/code&gt; 을 메모리 영역의 할당을 해제</target>
        </trans-unit>
        <trans-unit id="369395da987013876caff2dc1e6f3dc1c78f2dfd" translate="yes" xml:space="preserve">
          <source>A program may undefine and perhaps then redefine the &lt;code&gt;complex&lt;/code&gt; macro.</source>
          <target state="translated">프로그램은 &lt;code&gt;complex&lt;/code&gt; 매크로 를 정의 해제 한 다음 다시 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dfbb31de52784bd58fab9c555b2dcef326c6957c" translate="yes" xml:space="preserve">
          <source>A program may undefine and perhaps then redefine the macro &lt;code&gt;I&lt;/code&gt;.</source>
          <target state="translated">프로그램은 정의되지 않은 다음 매크로 &lt;code&gt;I&lt;/code&gt; 를 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="673ac82817b0262ffc8e60c6ab8111db0abf125a" translate="yes" xml:space="preserve">
          <source>A program may undefine and perhaps then redefine the macros &lt;code&gt;bool&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">프로그램은 정의되지 않은 다음 매크로를 &lt;code&gt;bool&lt;/code&gt; , &lt;code&gt;true&lt;/code&gt; 및 &lt;code&gt;false&lt;/code&gt; 로 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b4493cdd2ed11153441d87177f02ce56356d9390" translate="yes" xml:space="preserve">
          <source>A program with an endless loop has undefined behavior if the loop has no observable behavior (I/O, volatile accesses, atomic or synchronization operation) in any part of its cond_expression, iteration_expression or loop_statement. This allows the compilers to optimize out all unobservable loops without proving that they terminate. The only exceptions are the loops where cond_expression is omitted or is a constant expression; &lt;code&gt;for(;;)&lt;/code&gt; is always an endless loop.</source>
          <target state="translated">루프에 cond_expression, iteration_expression 또는 loop_statement의 일부에서 관찰 가능한 동작 (I / O, 휘발성 액세스, 원자 또는 동기화 작업)이없는 경우 무한 루프가있는 프로그램은 정의되지 않은 동작을 갖습니다. 이를 통해 컴파일러는 관찰 할 수없는 모든 루프를 종료하지 않고 최적화 할 수 있습니다. cond_expression이 생략되거나 상수 표현식 인 루프는 예외입니다. &lt;code&gt;for(;;)&lt;/code&gt; 는 항상 무한 루프입니다.</target>
        </trans-unit>
        <trans-unit id="d4dba07d0b12ec49c823d74b635737a662d716b7" translate="yes" xml:space="preserve">
          <source>A program with an endless loop has undefined behavior if the loop has no observable behavior (I/O, volatile accesses, atomic or synchronization operation) in any part of its statement or expression. This allows the compilers to optimize out all unobservable loops without proving that they terminate. The only exceptions are the loops where expression is a constant expression; &lt;code&gt;do {...} while(true);&lt;/code&gt; is always an endless loop.</source>
          <target state="translated">루프에 명령문 또는 표현식의 일부에서 관찰 가능한 동작 (I / O, 휘발성 액세스, 원자 또는 동기화 작업)이없는 경우 무한 루프가있는 프로그램은 정의되지 않은 동작을 갖습니다. 이를 통해 컴파일러는 관찰 할 수없는 모든 루프를 종료하지 않고 최적화 할 수 있습니다. 유일한 예외는 expression이 상수 표현식 인 루프입니다. &lt;code&gt;do {...} while(true);&lt;/code&gt; 항상 무한 루프입니다.</target>
        </trans-unit>
        <trans-unit id="d9fe083c28287027ff137fe873714315c88575d5" translate="yes" xml:space="preserve">
          <source>A program with an endless loop has undefined behavior if the loop has no observable behavior (I/O, volatile accesses, atomic or synchronization operation) in any part of its statement or expression. This allows the compilers to optimize out all unobservable loops without proving that they terminate. The only exceptions are the loops where expression is a constant expression; &lt;code&gt;while(true)&lt;/code&gt; is always an endless loop.</source>
          <target state="translated">루프에 명령문 또는 표현식의 일부에서 관찰 가능한 동작 (I / O, 휘발성 액세스, 원자 또는 동기화 작업)이없는 경우 무한 루프가있는 프로그램은 정의되지 않은 동작을 갖습니다. 이를 통해 컴파일러는 관찰 할 수없는 모든 루프를 종료하지 않고 최적화 할 수 있습니다. 유일한 예외는 expression이 상수 표현식 인 루프입니다. &lt;code&gt;while(true)&lt;/code&gt; 는 항상 무한 루프입니다.</target>
        </trans-unit>
        <trans-unit id="a987fe5116d16dac6c986d15e44866f1f2950023" translate="yes" xml:space="preserve">
          <source>A read-modify-write operation with this memory order is both an</source>
          <target state="translated">이 메모리 순서를 사용한 읽기-수정-쓰기 작업은</target>
        </trans-unit>
        <trans-unit id="78127daba885f04d8c232a3a0e396aee55e69e02" translate="yes" xml:space="preserve">
          <source>A store operation with this memory order performs the</source>
          <target state="translated">이 메모리 순서로 저장 조작은</target>
        </trans-unit>
        <trans-unit id="e387542d0812c72e59ffd89517785f1df0b879db" translate="yes" xml:space="preserve">
          <source>A string literal is not necessarily a string; if a string literal has embedded null characters, it represents an array which contains more than one string:</source>
          <target state="translated">문자열 리터럴은 반드시 문자열 일 필요는 없습니다. 문자열 리터럴에 널 문자가 포함 된 경우 둘 이상의 문자열을 포함하는 배열을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b83731486e3b698aa10bc6f537bc54d6e1c7fe80" translate="yes" xml:space="preserve">
          <source>A struct is a type consisting of a sequence of members whose storage is allocated in an ordered sequence (as opposed to union, which is a type consisting of a sequence of members whose storage overlaps).</source>
          <target state="translated">구조체는 스토리지가 순서대로 정렬 된 멤버 시퀀스로 구성되는 유형입니다 (유니온과 반대로, 스토리지가 겹치는 멤버 시퀀스로 구성된 유형).</target>
        </trans-unit>
        <trans-unit id="62857b5de9b7091adab212bbe55a64fe6f96c3d8" translate="yes" xml:space="preserve">
          <source>A successful call to &lt;code&gt;ungetc&lt;/code&gt; clears the end of file status flag &lt;code&gt;&lt;a href=&quot;feof&quot;&gt;feof&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ungetc&lt;/code&gt; 를 성공적으로 호출하면 파일 상태 플래그 &lt;code&gt;&lt;a href=&quot;feof&quot;&gt;feof&lt;/a&gt;&lt;/code&gt; 의 끝이 지워 집니다.</target>
        </trans-unit>
        <trans-unit id="2f18b9828e8cbe5f820c7f00f14018c93e63c261" translate="yes" xml:space="preserve">
          <source>A successful call to &lt;code&gt;ungetc&lt;/code&gt; on a binary stream decrements the stream position indicator by one (the behavior is indeterminate if the stream position indicator was zero).</source>
          <target state="translated">이진 스트림 에서 &lt;code&gt;ungetc&lt;/code&gt; 를 성공적으로 호출 하면 스트림 위치 표시기가 1 씩 감소합니다 (스트림 위치 표시기가 0이면 동작이 결정되지 않음).</target>
        </trans-unit>
        <trans-unit id="ca4337b8d12737a6a022afbf7eb03368caa77b5b" translate="yes" xml:space="preserve">
          <source>A successful call to &lt;code&gt;ungetc&lt;/code&gt; on a text stream modifies the stream position indicator in unspecified manner but guarantees that after all pushed-back characters are retrieved with a read operation, the stream position indicator is equal to its value before &lt;code&gt;ungetc&lt;/code&gt;.</source>
          <target state="translated">텍스트 스트림 에서 &lt;code&gt;ungetc&lt;/code&gt; 를 성공적으로 호출 하면 스트림 위치 표시기가 지정되지 않은 방식으로 수정되지만 모든 푸시 백 문자가 읽기 조작으로 검색된 후 스트림 위치 표시기는 &lt;code&gt;ungetc&lt;/code&gt; 이전의 값과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="ac874b9b5964dc5760d3a6f5c96e7d5268fa82e0" translate="yes" xml:space="preserve">
          <source>A successful call to &lt;code&gt;ungetwc&lt;/code&gt; clears the end of file status flag &lt;code&gt;&lt;a href=&quot;feof&quot;&gt;feof&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ungetwc&lt;/code&gt; 를 성공적으로 호출하면 파일 상태 플래그 &lt;code&gt;&lt;a href=&quot;feof&quot;&gt;feof&lt;/a&gt;&lt;/code&gt; 의 끝이 지워 집니다.</target>
        </trans-unit>
        <trans-unit id="96bde972d314cd8969488c09d04edcb68d3e8cec" translate="yes" xml:space="preserve">
          <source>A successful call to &lt;code&gt;ungetwc&lt;/code&gt; on a stream (whether text or binary) modifies the stream position indicator in unspecified manner but guarantees that after all pushed-back wide characters are retrieved with a read operation, the stream position indicator is equal to its value before &lt;code&gt;ungetwc&lt;/code&gt;.</source>
          <target state="translated">스트림 (텍스트 또는 2 진) 에서 &lt;code&gt;ungetwc&lt;/code&gt; 를 성공적으로 호출 하면 스트림 위치 표시기가 지정되지 않은 방식으로 수정되지만 모든 푸시 백 와이드 문자가 읽기 조작으로 검색된 후 스트림 위치 표시기는 &lt;code&gt;ungetwc&lt;/code&gt; 이전의 값과 동일합니다. .</target>
        </trans-unit>
        <trans-unit id="ae28ba5e02f8f525383bb9b4fdd4379afafef790" translate="yes" xml:space="preserve">
          <source>A tentative definition with internal linkage must have complete type.</source>
          <target state="translated">내부 연결이있는 임시 정의에는 완전한 유형이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="734b0e8555885421cd88b9f937f8a5a91f954a94" translate="yes" xml:space="preserve">
          <source>A thread of execution is a flow of control within a program that begins with the invocation of a top-level function by &lt;code&gt;&lt;a href=&quot;../thread/thrd_create&quot;&gt;thrd_create&lt;/a&gt;&lt;/code&gt; or other means.</source>
          <target state="translated">실행 스레드는 &lt;code&gt;&lt;a href=&quot;../thread/thrd_create&quot;&gt;thrd_create&lt;/a&gt;&lt;/code&gt; 또는 다른 방법 으로 최상위 함수를 호출하는 것으로 시작하는 프로그램 내의 제어 흐름입니다 .</target>
        </trans-unit>
        <trans-unit id="83494c42dbcc847aa1ff217c1fe7f8283385dd00" translate="yes" xml:space="preserve">
          <source>A type may have to be named in context other than the &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt;. In these situations,</source>
          <target state="translated">&lt;a href=&quot;declarations&quot;&gt;선언&lt;/a&gt; 이외의 컨텍스트에서 형식의 이름을 지정해야 할 수도 있습니다 . 이러한 상황에서</target>
        </trans-unit>
        <trans-unit id="89da242d1eea5250f1f3146f1bc7040bd1b23fbb" translate="yes" xml:space="preserve">
          <source>A type name may introduce a new type:</source>
          <target state="translated">타입 이름은 새로운 타입을 도입 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="0ded4b2c0ade545ee92678f87004b8c5310458e0" translate="yes" xml:space="preserve">
          <source>A typedef for a VLA can only appear at block scope. The length of the array is evaluated each time the flow of control passes over the typedef declaration, as opposed to the declaration of the array itself:</source>
          <target state="translated">VLA의 typedef는 블록 범위에서만 나타날 수 있습니다. 배열의 길이는 배열 자체의 선언과 달리 제어 흐름이 typedef 선언을 통과 할 때마다 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="ea6b56408c3f67fe3e4cd9bb8c98bda8cd2227a2" translate="yes" xml:space="preserve">
          <source>A typical cause of failure for &lt;code&gt;puts&lt;/code&gt; is running out of space on the file system, when stdout is redirected to a file.</source>
          <target state="translated">&lt;code&gt;puts&lt;/code&gt; 실패의 일반적인 원인은 stdout이 파일로 경로 재 지정 될 때 파일 시스템의 공간이 부족하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="6f0adfae1100114c8248488bd9e46306cf3169dd" translate="yes" xml:space="preserve">
          <source>A union is a type consisting of a sequence of members whose storage overlaps (as opposed to struct, which is a type consisting of a sequence of members whose storage is allocated in an ordered sequence). The value of at most one of the members can be stored in a union at any one time.</source>
          <target state="translated">공용체는 스토리지와 겹치는 멤버 시퀀스로 구성된 유형입니다 (스트럭처와 반대로, 순서가 지정된 스토리지에 멤버가 할당 된 멤버 시퀀스로 구성된 유형 임). 최대 하나의 멤버 값을 한 번에 공용체에 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b72fa34edde9b7a760e2ca9a63cea91e1b555145" translate="yes" xml:space="preserve">
          <source>A universal character name in a narrow string literal or a 16-bit string literal may map to more than one character, e.g. &lt;code&gt;\U0001f34c&lt;/code&gt; is 4 &lt;code&gt;char&lt;/code&gt; code units in UTF-8 (&lt;code&gt;\xF0\x9F\x8D\x8C&lt;/code&gt;) and 2 &lt;code&gt;char16_t&lt;/code&gt; code units in UTF-16 (&lt;code&gt;\uD83C\uDF4C&lt;/code&gt;).</source>
          <target state="translated">좁은 문자열 리터럴 또는 16 비트 문자열 리터럴의 범용 문자 이름은 둘 이상의 문자에 맵핑 될 수 있습니다. 예를 들어 &lt;code&gt;\U0001f34c&lt;/code&gt; 는 UTF-8 ( &lt;code&gt;\xF0\x9F\x8D\x8C&lt;/code&gt; ) 및 2 개의 &lt;code&gt;char16_t&lt;/code&gt; 코드 에서 4 개의 &lt;code&gt;char&lt;/code&gt; 코드 단위입니다. UTF-16 단위 ( &lt;code&gt;\uD83C\uDF4C&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="15de7dbea993ba11f5f4400e4c3b5596b766e0df" translate="yes" xml:space="preserve">
          <source>A valid C program must not depend on whether the inline version or the external version of a function is called.</source>
          <target state="translated">유효한 C 프로그램은 함수의 인라인 버전 또는 외부 버전의 호출 여부에 의존해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="d626b3d232c881f5c4b8b1ea2e9f96008808e88d" translate="yes" xml:space="preserve">
          <source>A value of any complex type can be implicitly converted to any imaginary type.</source>
          <target state="translated">모든 복합 유형의 값은 내재적으로 임의의 가상 유형으로 변환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c88d24cc4ec994d46157d83290ad8af83a11e69" translate="yes" xml:space="preserve">
          <source>A value of any complex type can be implicitly converted to any other complex type. The real part and the imaginary part individually follow the conversion rules for the real floating types.</source>
          <target state="translated">모든 복합 유형의 값은 암시 적으로 다른 복합 유형으로 변환 될 수 있습니다. 실수 부와 허수 부는 각각 실제 부동 유형에 대한 변환 규칙을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="045b19c719d2ce31e6c3fc2dbb610a034ab82f27" translate="yes" xml:space="preserve">
          <source>A value of any complex type can be implicitly converted to any real floating type.</source>
          <target state="translated">모든 복합 유형의 값은 암시 적으로 실제 부동 유형으로 변환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="523b4bcf3df5def7bdb173f6da2f1c669d5ffd10" translate="yes" xml:space="preserve">
          <source>A value of any imaginary type can be implicitly converted to any complex type.</source>
          <target state="translated">가상 유형의 값은 내재적으로 임의의 복합 유형으로 변환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4bba57f46ad248ddc356b6653b3a832c38ef932" translate="yes" xml:space="preserve">
          <source>A value of any imaginary type can be implicitly converted to any other imaginary type. The imaginary part follows the conversion rules for the real floating types.</source>
          <target state="translated">허수 유형의 값은 암시 적으로 다른 허수 유형으로 변환 될 수 있습니다. 허수 부분은 실제 부동 유형에 대한 변환 규칙을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="3eeda2e376d925bd595e8ae9c46012cbc5e846d4" translate="yes" xml:space="preserve">
          <source>A value of any imaginary type can be implicitly converted to any real type (integer or floating-point). The result is always a positive (or unsigned) zero, except when the target type is _Bool, in which case boolean conversion rules apply.</source>
          <target state="translated">가상 유형의 값은 암시 적으로 임의의 실제 유형 (정수 또는 부동 소수점)으로 변환 될 수 있습니다. 대상 유형이 _Bool 인 경우를 제외하고 결과는 항상 양수 (또는 부호없는) 0입니다.이 경우 부울 변환 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="b1043e27727b5859c73d6368abb56140d9c8c4df" translate="yes" xml:space="preserve">
          <source>A value of any integer type can be implicitly converted to any other integer type. Except where covered by promotions and boolean conversions above, the rules are:</source>
          <target state="translated">모든 정수 유형의 값은 암시 적으로 다른 정수 유형으로 변환 될 수 있습니다. 위의 프로모션 및 부울 변환이 적용되는 경우를 제외하고 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d48506c225a6b698b81ca8310a86f4f65be3e2ca" translate="yes" xml:space="preserve">
          <source>A value of any integer type can be implicitly converted to any real floating type.</source>
          <target state="translated">모든 정수 유형의 값은 암시 적으로 실제 부동 유형으로 변환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="026d85487a9bfd120f0733b4a332d6f7183d4b83" translate="yes" xml:space="preserve">
          <source>A value of any real floating type can be implicitly converted to any complex type.</source>
          <target state="translated">실제 부동 유형의 값은 암시 적으로 임의의 복합 유형으로 변환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1850c152b30508607de5e5ce9465d153d7482b90" translate="yes" xml:space="preserve">
          <source>A value of any real floating type can be implicitly converted to any other real floating type.</source>
          <target state="translated">실제 부동 유형의 값은 암시 적으로 다른 실제 부동 유형으로 변환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ddbeeb9abdb8bf97e248ee8a8c3ed50c8646e45" translate="yes" xml:space="preserve">
          <source>A value of any real type can be implicitly converted to any imaginary type. The result is always a positive imaginary zero.</source>
          <target state="translated">실제 유형의 값은 내재적으로 임의의 가상 유형으로 변환 될 수 있습니다. 결과는 항상 양의 허수입니다.</target>
        </trans-unit>
        <trans-unit id="542b0b974643a87f82bdfb9069328ad0a228dd34" translate="yes" xml:space="preserve">
          <source>A value of any scalar type can be implicitly converted to _Bool. The values that compare equal to zero are converted to &lt;code&gt;​0​&lt;/code&gt;, all other values are converted to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">모든 스칼라 유형의 값은 암시 적으로 _Bool로 변환 될 수 있습니다. 0과 동일하게 비교 값이 변환된다 &lt;code&gt;​0​&lt;/code&gt; , 모든 다른 값으로 변환되어 &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa3584dfc017c837cf1f146d7c3bfa22f920a495" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;void (*)(int)&lt;/code&gt;. When returned by &lt;code&gt;&lt;a href=&quot;signal&quot;&gt;signal&lt;/a&gt;&lt;/code&gt;, indicates that an error has occurred.</source>
          <target state="translated">&lt;code&gt;void (*)(int)&lt;/code&gt; 유형의 값입니다 . &lt;code&gt;&lt;a href=&quot;signal&quot;&gt;signal&lt;/a&gt;&lt;/code&gt; 로 반환되면 오류가 발생했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e43f5b4e5dab83ce22f20cdda8ca8c5befbdfb54" translate="yes" xml:space="preserve">
          <source>A well-known example of the same identifier being used across two name spaces is the identifier &lt;code&gt;stat&lt;/code&gt; from the POSIX header &lt;code&gt;sys/stat.h&lt;/code&gt;. It &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/&quot;&gt;names a function&lt;/a&gt; when used as an ordinary identifier and &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;indicates a struct&lt;/a&gt; when used as a tag.</source>
          <target state="translated">두 네임 스페이스에서 사용되는 동일한 식별자의 잘 알려진 예 는 POSIX 헤더 &lt;code&gt;sys/stat.h&lt;/code&gt; 의 식별자 &lt;code&gt;stat&lt;/code&gt; 입니다 . 그 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/&quot;&gt;이름 기능&lt;/a&gt; 일반 ID로 사용 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;구조체를 나타내는&lt;/a&gt; 태그로서 사용했을 때.</target>
        </trans-unit>
        <trans-unit id="47e9ca7eeeecd01f720a4c3ebefa8b5b579f496b" translate="yes" xml:space="preserve">
          <source>A.1.2.1 Expressions</source>
          <target state="translated">A.1.2.1 표현</target>
        </trans-unit>
        <trans-unit id="9fa96a046c7129ab706b3906b3b75c43d0b3b41e" translate="yes" xml:space="preserve">
          <source>A.2.1 Expressions</source>
          <target state="translated">A.2.1 표현</target>
        </trans-unit>
        <trans-unit id="187459c12cbce645deb52d74f3d6152a7a9a17fc" translate="yes" xml:space="preserve">
          <source>ASCII Chart</source>
          <target state="translated">ASCII 차트</target>
        </trans-unit>
        <trans-unit id="6b85275355e86325dde0c35693852c2d7820c750" translate="yes" xml:space="preserve">
          <source>ASCII chart</source>
          <target state="translated">ASCII 차트</target>
        </trans-unit>
        <trans-unit id="6ff2c765d8c7f7f1624b70244d10913facb7ae0b" translate="yes" xml:space="preserve">
          <source>ASCII values</source>
          <target state="translated">ASCII 값</target>
        </trans-unit>
        <trans-unit id="741d25da837c7eedcbdbd90d0d949bbad6187038" translate="yes" xml:space="preserve">
          <source>ATOMIC_*_LOCK_FREE</source>
          <target state="translated">ATOMIC_*_LOCK_FREE</target>
        </trans-unit>
        <trans-unit id="1120084929ffa752eeda2469d9c594dc3612e485" translate="yes" xml:space="preserve">
          <source>ATOMIC_BOOL_LOCK_FREEATOMIC_CHAR_LOCK_FREEATOMIC_CHAR16_T_LOCK_FREEATOMIC_CHAR32_T_LOCK_FREEATOMIC_WCHAR_T_LOCK_FREEATOMIC_SHORT_LOCK_FREEATOMIC_INT_LOCK_FREEATOMIC_LONG_LOCK_FREEATOMIC_LLONG_LOCK_FREEATOMIC_POINTER_LOCK_FREE</source>
          <target state="translated">ATOMIC_BOOL_LOCK_FREEATOMIC_CHAR_LOCK_FREEATOMIC_CHAR16_T_LOCK_FREEATOMIC_CHAR32_T_LOCK_FREEATOMIC_WCHAR_T_LOCK_FREEATOMIC_SHORT_LOCK_FREEATOMIC_INT_LOCK_FREEATOMIC_LONG_LOCK_FREEATOMIC_LLONG_LOCK_FREEATOMIC_POINTER_LOCK_FREE</target>
        </trans-unit>
        <trans-unit id="63e21a0c9c10fbf518b0166eb437a67f1ed962cd" translate="yes" xml:space="preserve">
          <source>ATOMIC_FLAG_INIT</source>
          <target state="translated">ATOMIC_FLAG_INIT</target>
        </trans-unit>
        <trans-unit id="0b0620452fea1cd6ef04952a1260146f273e310f" translate="yes" xml:space="preserve">
          <source>ATOMIC_VAR_INIT</source>
          <target state="translated">ATOMIC_VAR_INIT</target>
        </trans-unit>
        <trans-unit id="9de67dfb6d06413cdc219824a0f3f88445b9f32c" translate="yes" xml:space="preserve">
          <source>Access out of bounds</source>
          <target state="translated">범위를 벗어난 액세스</target>
        </trans-unit>
        <trans-unit id="1632238dd01e0d2949d4e0ad89257742628b773a" translate="yes" xml:space="preserve">
          <source>Access to pointer passed to realloc</source>
          <target state="translated">realloc에 ​​전달 된 포인터에 대한 액세스</target>
        </trans-unit>
        <trans-unit id="c14ddd2129de76c2ada1aa7e78baf410f83de4be" translate="yes" xml:space="preserve">
          <source>Accessing a member of an atomic struct/union is undefined behavior.</source>
          <target state="translated">원자 구조체 / 연합의 멤버에 액세스하는 것은 정의되지 않은 동작입니다.</target>
        </trans-unit>
        <trans-unit id="f576e8c8e33a749329570e7a77b007df382e969e" translate="yes" xml:space="preserve">
          <source>Accessing an object outside of its lifetime is undefined behavior.</source>
          <target state="translated">수명 이외의 개체에 액세스하는 것은 정의되지 않은 동작입니다.</target>
        </trans-unit>
        <trans-unit id="b720069db01e986b09ea45ae4ab2aa8008f5f98c" translate="yes" xml:space="preserve">
          <source>Accessing the variadic arguments from the function body uses the following library facilities:</source>
          <target state="translated">함수 본문에서 가변 인수에 액세스하면 다음 라이브러리 기능이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="894e0d0ca601136dd7488a48cc4e246850d2e574" translate="yes" xml:space="preserve">
          <source>Action if file</source>
          <target state="translated">파일 인 경우 조치</target>
        </trans-unit>
        <trans-unit id="48911a7386b2baa20a76ef9e342562ca04e9c341" translate="yes" xml:space="preserve">
          <source>Addition and subtraction</source>
          <target state="translated">더하기와 빼기</target>
        </trans-unit>
        <trans-unit id="283ec445be98c579864590d0e92c5442ed90be08" translate="yes" xml:space="preserve">
          <source>Additional basic types and convenience macros</source>
          <target state="translated">추가 기본 유형 및 편의 매크로</target>
        </trans-unit>
        <trans-unit id="c33da322e780907896acfdbb397c70d360f6b9ec" translate="yes" xml:space="preserve">
          <source>Additional implementation-defined types may be acceptable. It is also implementation-defined whether a bit field may have &lt;a href=&quot;atomic&quot;&gt;atomic&lt;/a&gt; type.(since C11) The number of bits in a bit field (width) sets the limit to the range of values it can hold:</source>
          <target state="translated">추가 구현 정의 유형이 허용 될 수 있습니다. 비트 필드가 &lt;a href=&quot;atomic&quot;&gt;원자&lt;/a&gt; 유형을 가질 수 있는지 여부는 구현에서 정의됩니다 . (C11부터) 비트 필드의 비트 수 (너비)는 제한을 보유 할 수있는 값의 범위로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="0d1029ad60405084db977e479c06f25f269c8a36" translate="yes" xml:space="preserve">
          <source>Additional macro constants, with names that begin with &lt;code&gt;LC_&lt;/code&gt; followed by at least one uppercase letter, may be defined in &lt;code&gt;locale.h&lt;/code&gt;. For example, the POSIX specification requires LC_MESSAGES (which controls, among other things, &lt;code&gt;&lt;a href=&quot;../io/perror&quot;&gt;perror&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../string/byte/strerror&quot;&gt;strerror&lt;/a&gt;&lt;/code&gt;), ISO/IEC 30112:2014 (&lt;a href=&quot;http://www.open-std.org/JTC1/SC35/WG5/docs/30112d10.pdf&quot;&gt;2014 draft&lt;/a&gt;) additionally defines LC_IDENTIFICATION, LC_XLITERATE, LC_NAME, LC_ADDRESS, LC_TELEPHONE, LC_PAPER, LC_MEASUREMENT, and LC_KEYBOARD, which are supported by the GNU C library (except for LC_XLITERATE).</source>
          <target state="translated">&lt;code&gt;LC_&lt;/code&gt; 로 시작하고 그 뒤에 대문자가 하나 이상인 추가 매크로 상수 는 &lt;code&gt;locale.h&lt;/code&gt; 에 정의 될 수 있습니다 . 예를 들어, POSIX 사양에는 LC_MESSAGES (특히 &lt;code&gt;&lt;a href=&quot;../io/perror&quot;&gt;perror&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../string/byte/strerror&quot;&gt;strerror&lt;/a&gt;&lt;/code&gt; 제어 ), ISO / IEC 30112 : 2014 ( &lt;a href=&quot;http://www.open-std.org/JTC1/SC35/WG5/docs/30112d10.pdf&quot;&gt;2014 draft&lt;/a&gt; )에 LC_IDENTIFICATION, LC_XLITERATE, LC_NAME, LC_ADDRESS, LC_TELEPHONE, LC_PAPER, LC_MEASUREMENT 및 LC_KEYBOARD가 추가로 정의되어 있어야합니다. 이것은 GNU C 라이브러리에서 지원합니다 (LC_XLITERATE 제외).</target>
        </trans-unit>
        <trans-unit id="764a28584542378b58ffc1460c2f5cd3c32d60ca" translate="yes" xml:space="preserve">
          <source>Additional macros that begin with &lt;code&gt;FE_&lt;/code&gt; followed by uppercase letters, and have the type &lt;code&gt;const fenv_t*&lt;/code&gt;, may be supported by an implementation.</source>
          <target state="translated">&lt;code&gt;FE_&lt;/code&gt; 로 시작하고 대문자가오고 &lt;code&gt;const fenv_t*&lt;/code&gt; 유형의 추가 매크로가 구현에 의해 지원 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef3d826dd03b81e684d86b842e89e92269929ee7" translate="yes" xml:space="preserve">
          <source>Additional numeric formats may be accepted by the currently installed C &lt;code&gt;&lt;a href=&quot;../../locale/setlocale&quot;&gt;locale&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">현재 설치된 C &lt;code&gt;&lt;a href=&quot;../../locale/setlocale&quot;&gt;locale&lt;/a&gt;&lt;/code&gt; 에서 추가 숫자 형식을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e8146529cfa6fa203e23e61b37cbdf2d37d4634b" translate="yes" xml:space="preserve">
          <source>Additional rounding modes may be supported by an implementation.</source>
          <target state="translated">추가적인 반올림 모드는 구현에 의해 지원 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb9fec43e4640236adc94f7a637b3f0160e148fc" translate="yes" xml:space="preserve">
          <source>Additionally, for every parameter of &lt;a href=&quot;array&quot;&gt;array type&lt;/a&gt; that uses the keyword &lt;code&gt;static&lt;/code&gt; between &lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt;, the argument expression must designate a pointer to the element of an array with at least that many elements as specified in the size expression of the parameter.</source>
          <target state="translated">또한 &lt;code&gt;[&lt;/code&gt; 와 &lt;code&gt;]&lt;/code&gt; 사이에 키워드 &lt;code&gt;static&lt;/code&gt; 을 사용하는 &lt;a href=&quot;array&quot;&gt;배열 유형&lt;/a&gt; 의 모든 매개 변수에 대해 인수 표현식은 매개 변수의 크기 표현식에 지정된 수 이상의 요소를 가진 배열의 요소에 대한 포인터를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="76be74594d0a3f6f1c23004ef8fbefa453574daa" translate="yes" xml:space="preserve">
          <source>Additive operators</source>
          <target state="translated">첨가제 연산자</target>
        </trans-unit>
        <trans-unit id="576276822a153883d3d9699e768d5b4ee811a461" translate="yes" xml:space="preserve">
          <source>Address of</source>
          <target state="translated">주소</target>
        </trans-unit>
        <trans-unit id="9377e4719dc070a5dfa0119a44583c6b5ae07578" translate="yes" xml:space="preserve">
          <source>Address-of</source>
          <target state="translated">Address-of</target>
        </trans-unit>
        <trans-unit id="458e4498a6e12a40a95f335b3f81898cfd748b12" translate="yes" xml:space="preserve">
          <source>Adjacent &lt;a href=&quot;string_literal&quot;&gt;string literals&lt;/a&gt; are concatenated.</source>
          <target state="translated">인접한 &lt;a href=&quot;string_literal&quot;&gt;문자열 리터럴&lt;/a&gt; 이 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="1fb3e0e585b7b35a447a3da6d3ae0da5248da92b" translate="yes" xml:space="preserve">
          <source>After encountering the &lt;code&gt;#error&lt;/code&gt; directive, an implementation displays the diagnostic message error_message and renders the program ill-formed (the compilation stops).</source>
          <target state="translated">&lt;code&gt;#error&lt;/code&gt; 지시문을 만나면 구현시 진단 메시지 error_message가 표시되고 프로그램이 잘못된 형식으로 표시됩니다 (컴파일이 중지됨).</target>
        </trans-unit>
        <trans-unit id="37697aac1a5eff809b30503e048e426d91ee09c0" translate="yes" xml:space="preserve">
          <source>After seeking to a non-end position in a wide stream, the next call to any output function may render the remainder of the file undefined, e.g. by outputting a multibyte sequence of a different length.</source>
          <target state="translated">넓은 스트림에서 비 종료 위치를 찾은 후, 임의의 출력 함수에 대한 다음 호출은 예를 들어, 다른 길이의 멀티 바이트 시퀀스를 출력함으로써 파일의 나머지를 정의되지 않을 수있다.</target>
        </trans-unit>
        <trans-unit id="8942a31efdd7fa2a68a933b01b212ddbca06e0f0" translate="yes" xml:space="preserve">
          <source>After this statement the control is transferred to the statement or declaration immediately following the enclosing loop or switch, as if by &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;.</source>
          <target state="translated">이 명령문 이후에 제어는 마치 &lt;a href=&quot;goto&quot;&gt;goto에&lt;/a&gt; 의한 것처럼 둘러싼 루프 또는 스위치 바로 다음의 명령문 또는 선언으로 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="67e15eb99dc0e473c962d6a494d00e048e9f6fc6" translate="yes" xml:space="preserve">
          <source>Algorithms</source>
          <target state="translated">Algorithms</target>
        </trans-unit>
        <trans-unit id="d72f31b2f308ee63f6def08b39a4b92ac993f430" translate="yes" xml:space="preserve">
          <source>Alignas specifier only needs to appear on the &lt;a href=&quot;declarations#Definitions&quot;&gt;definition&lt;/a&gt; of an object, but if any declaration uses alignas, it must specify the same alignment as the alignas on the definition. The behavior is undefined if different translation units specify different alignments for the same object.</source>
          <target state="translated">Alignas 지정자는 객체 의 &lt;a href=&quot;declarations#Definitions&quot;&gt;정의&lt;/a&gt; 에만 나타나야 하지만 선언에서 alignas를 사용하는 경우 정의의 alignas와 동일한 정렬을 지정해야합니다. 다른 변환 단위가 동일한 객체에 대해 다른 정렬을 지정하면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7f8c5176c3f03b97659161923f2b6492f7de7e73" translate="yes" xml:space="preserve">
          <source>Alignment</source>
          <target state="translated">Alignment</target>
        </trans-unit>
        <trans-unit id="998eaf2c199d6e6c5ec4ea687761747f4ea20894" translate="yes" xml:space="preserve">
          <source>Alignment of the allocation unit that holds a bit field</source>
          <target state="translated">비트 필드를 보유하는 할당 단위의 정렬</target>
        </trans-unit>
        <trans-unit id="6a874fb4ad2b87c17e904b10d9366720c6d119fa" translate="yes" xml:space="preserve">
          <source>Alignment requirement(C11)</source>
          <target state="translated">정렬 요구 사항 (C11)</target>
        </trans-unit>
        <trans-unit id="60417779e7300dcc151a6eb620dfb95350289093" translate="yes" xml:space="preserve">
          <source>All &lt;a href=&quot;value_category&quot;&gt;value categories&lt;/a&gt;, including function designators and void expressions, are allowed as expressions in a generic selection, and if selected, the generic selection itself has the same value category.</source>
          <target state="translated">함수 지정자 및 void 표현식을 포함한 모든 &lt;a href=&quot;value_category&quot;&gt;값 카테고리&lt;/a&gt; 는 일반 선택에서 표현식으로 허용되며, 선택되면 일반 선택 자체는 동일한 값 카테고리를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="4f9ee5d352b4270a148f5665caeb9006b6fbb7b5" translate="yes" xml:space="preserve">
          <source>All array elements that are not initialized explicitly are &lt;a href=&quot;initialization&quot;&gt;initialized implicitly&lt;/a&gt; the same way as objects that have static storage duration.</source>
          <target state="translated">명시 적으로 &lt;a href=&quot;initialization&quot;&gt;초기화&lt;/a&gt; 되지 않은 모든 배열 요소 는 정적 저장 시간이있는 객체와 같은 방식으로 암시 적으로 초기화 됩니다.</target>
        </trans-unit>
        <trans-unit id="4c15cf3f5d785f05b074208b892da42654f696fb" translate="yes" xml:space="preserve">
          <source>All comments are removed from the program at &lt;a href=&quot;language/translation_phases&quot;&gt;translation phase 3&lt;/a&gt; by replacing each comment with a single whitespace character.</source>
          <target state="translated">각 주석을 단일 공백 ​​문자로 바꾸면 &lt;a href=&quot;language/translation_phases&quot;&gt;번역 단계 3&lt;/a&gt; 에서 모든 주석이 프로그램에서 제거됩니다 .</target>
        </trans-unit>
        <trans-unit id="a33a0daa0c6f810f1da4bed7e4f886f7a3fa028a" translate="yes" xml:space="preserve">
          <source>All conversion specifiers other than &lt;code&gt;[&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, and &lt;code&gt;n&lt;/code&gt; consume and discard all leading whitespace characters (determined as if by calling &lt;a href=&quot;../string/byte/isspace&quot;&gt;&lt;code&gt;isspace&lt;/code&gt;&lt;/a&gt;) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.</source>
          <target state="translated">&lt;code&gt;[&lt;/code&gt; , &lt;code&gt;c&lt;/code&gt; 및 &lt;code&gt;n&lt;/code&gt; 이외의 모든 변환 지정 자는 입력 구문 분석을 시도하기 전에 모든 선행 공백 문자 ( &lt;a href=&quot;../string/byte/isspace&quot;&gt; &lt;code&gt;isspace&lt;/code&gt; &lt;/a&gt; 를 호출하는 것처럼 판별 됨)를 소비하고 버립니다 . 소비 된 문자는 지정된 최대 필드 너비에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e7cb57b66d2139c6b332fa6e8e17ae9b77fdde8b" translate="yes" xml:space="preserve">
          <source>All conversion specifiers other than &lt;code&gt;[&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, and &lt;code&gt;n&lt;/code&gt; consume and discard all leading whitespace characters (determined as if by calling &lt;a href=&quot;../string/wide/iswspace&quot;&gt;&lt;code&gt;iswspace&lt;/code&gt;&lt;/a&gt;) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.</source>
          <target state="translated">&lt;code&gt;[&lt;/code&gt; , &lt;code&gt;c&lt;/code&gt; 및 &lt;code&gt;n&lt;/code&gt; 이외의 모든 변환 지정 자는 입력 구문 분석을 시도하기 전에 모든 선행 공백 문자 ( &lt;a href=&quot;../string/wide/iswspace&quot;&gt; &lt;code&gt;iswspace&lt;/code&gt; &lt;/a&gt; 를 호출하는 것처럼 판별 됨)를 소비하고 버립니다 . 소비 된 문자는 지정된 최대 필드 너비에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="170e9e40346b4676af2c9543c1315fbdba1de3af" translate="yes" xml:space="preserve">
          <source>All members that are not initialized explicitly are &lt;a href=&quot;initialization#Implicit_initialization&quot;&gt;initialized implicitly&lt;/a&gt; the same way as objects that have static storage duration.</source>
          <target state="translated">명시 적으로 &lt;a href=&quot;initialization#Implicit_initialization&quot;&gt;초기화&lt;/a&gt; 되지 않은 모든 멤버 는 정적 저장 시간이있는 객체와 같은 방식으로 암시 적으로 초기화 됩니다.</target>
        </trans-unit>
        <trans-unit id="237d36367069e4b8c7a44d2afc03a5597429cd9e" translate="yes" xml:space="preserve">
          <source>All other identifiers are available, with no fear of unexpected collisions when moving programs from one compiler and library to another.</source>
          <target state="translated">하나의 컴파일러와 라이브러리에서 다른 컴파일러와 라이브러리로 프로그램을 옮길 때 예기치 않은 충돌에 대한 두려움없이 다른 모든 식별자를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fbacfcbc3bb83e6594a5426d07a776d016ded8e" translate="yes" xml:space="preserve">
          <source>All these functions invoke &lt;code&gt;va_arg&lt;/code&gt; at least once, the value of &lt;code&gt;arg&lt;/code&gt; is indeterminate after the return. These functions do not invoke &lt;code&gt;va_end&lt;/code&gt;, and it must be done by the caller.</source>
          <target state="translated">이 모든 함수는 &lt;code&gt;va_arg&lt;/code&gt; 를 한 번 이상 호출 합니다. &lt;code&gt;arg&lt;/code&gt; 의 값은 반환 후 결정되지 않습니다. 이 함수는 &lt;code&gt;va_end&lt;/code&gt; 를 호출하지 않으며 호출자가 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="11b370485f04e9782b3074994340dd54b2c413b7" translate="yes" xml:space="preserve">
          <source>All these functions invoke &lt;code&gt;va_arg&lt;/code&gt; at least once, the value of &lt;code&gt;arg&lt;/code&gt; is indeterminate after the return. These functions to not invoke &lt;code&gt;va_end&lt;/code&gt;, and it must be done by the caller.</source>
          <target state="translated">이 모든 함수는 &lt;code&gt;va_arg&lt;/code&gt; 를 한 번 이상 호출 합니다. &lt;code&gt;arg&lt;/code&gt; 의 값은 반환 후 결정되지 않습니다. 이 함수는 &lt;code&gt;va_end&lt;/code&gt; 를 호출하지 않으며 호출자가 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="35959593fb331ed044f2bd60520abb9932e2098b" translate="yes" xml:space="preserve">
          <source>All these functions may invoke &lt;code&gt;va_arg&lt;/code&gt;, the value of &lt;code&gt;arg&lt;/code&gt; is indeterminate after the return. These functions to not invoke &lt;code&gt;va_end&lt;/code&gt;, and it must be done by the caller.</source>
          <target state="translated">이 모든 함수는 &lt;code&gt;va_arg&lt;/code&gt; 를 호출 할 수 있으며 , &lt;code&gt;arg&lt;/code&gt; 값은 반환 후 결정되지 않습니다. 이 함수는 &lt;code&gt;va_end&lt;/code&gt; 를 호출하지 않으며 호출자가 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="b0490d0cb63a327b1645f25c31bcc6482c7608ed" translate="yes" xml:space="preserve">
          <source>All these macro constants (except &lt;code&gt;FE_ALL_EXCEPT&lt;/code&gt;) expand to integer constant expressions that are distinct powers of 2, which uniquely identify all supported floating-point exceptions. Each macro is only defined if it is supported.</source>
          <target state="translated">이러한 모든 매크로 상수 ( &lt;code&gt;FE_ALL_EXCEPT&lt;/code&gt; 제외 )는 2의 고유 한 제곱 인 정수 상수 표현식으로 확장되어 지원되는 모든 부동 소수점 예외를 고유하게 식별합니다. 각 매크로는 지원되는 경우에만 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="4b26e5fb8ce8c48af69f0f82512b4e4d3a9cb87e" translate="yes" xml:space="preserve">
          <source>All thread-specific storage values (see &lt;code&gt;&lt;a href=&quot;tss_create&quot;&gt;tss_create&lt;/a&gt;&lt;/code&gt;) are initialized to &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">모든 스레드 특정 스토리지 값 ( &lt;code&gt;&lt;a href=&quot;tss_create&quot;&gt;tss_create&lt;/a&gt;&lt;/code&gt; 참조 )은 &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 로 초기화 됩니다 .</target>
        </trans-unit>
        <trans-unit id="bb8fdb32122bd65cf5d7c325d5377fe22c226fe9" translate="yes" xml:space="preserve">
          <source>All undefined behavior not listed as critical is bounded, including</source>
          <target state="translated">다음과 같이 중요하지 않은 것으로 정의되지 않은 모든 동작이 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="7b8e5641e2d8cbf1a2bdfdaf4f5a52ae7c538b20" translate="yes" xml:space="preserve">
          <source>Allocate &lt;code&gt;size&lt;/code&gt; bytes of uninitialized storage whose alignment is specified by &lt;code&gt;alignment&lt;/code&gt;. The &lt;code&gt;size&lt;/code&gt; parameter must be an integral multiple of &lt;code&gt;alignment&lt;/code&gt;.</source>
          <target state="translated">할당 &lt;code&gt;size&lt;/code&gt; 정렬에 의해 지정된 초기화 저장 바이트 &lt;code&gt;alignment&lt;/code&gt; . &lt;code&gt;size&lt;/code&gt; 매개 변수의 정수 배가되어야합니다 &lt;code&gt;alignment&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="575bf26e9df794dbd1383b334ef663788e920b7e" translate="yes" xml:space="preserve">
          <source>Allocates &lt;code&gt;size&lt;/code&gt; bytes of uninitialized storage.</source>
          <target state="translated">초기화되지 않은 스토리지의 &lt;code&gt;size&lt;/code&gt; 바이트를 할당 합니다 .</target>
        </trans-unit>
        <trans-unit id="eaf6e4d87daf82411e96d7b40d5b5e9337ffd24d" translate="yes" xml:space="preserve">
          <source>Allocates memory for an array of &lt;code&gt;num&lt;/code&gt; objects of size &lt;code&gt;size&lt;/code&gt; and initializes all bytes in the allocated storage to zero.</source>
          <target state="translated">크기가 &lt;code&gt;size&lt;/code&gt; 인 &lt;code&gt;num&lt;/code&gt; 개의 객체 배열에 메모리를 할당 하고 할당 된 저장소의 모든 바이트를 0으로 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="dfab2da001a1d62544447fa5f9f2ca3eaeb8861b" translate="yes" xml:space="preserve">
          <source>Allows values of floating type to be used directly in expressions.</source>
          <target state="translated">부동 유형의 값을 표현식에서 직접 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccb54e9be1a4c6bc9837fefd7cc02f1997a12f3c" translate="yes" xml:space="preserve">
          <source>Allows values of integer type to be used in expressions directly.</source>
          <target state="translated">정수 유형의 값을 표현식에서 직접 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c630eed84e53f9bda6e9f3acef1d7440aafcdd63" translate="yes" xml:space="preserve">
          <source>Also, each name that begins with a double underscore __ or an underscore followed by an uppercase letter is reserved: see &lt;a href=&quot;language/identifier#Reserved_identifiers&quot;&gt;identifier&lt;/a&gt; for details.</source>
          <target state="translated">또한 이중 밑줄 __ 또는 밑줄과 대문자로 시작하는 각 이름은 예약되어 있습니다. 자세한 내용은 &lt;a href=&quot;language/identifier#Reserved_identifiers&quot;&gt;식별자&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7d26d9b99ae9e352859532e801512a8d171f666b" translate="yes" xml:space="preserve">
          <source>Also, in C89, functions returning &lt;code&gt;int&lt;/code&gt; may be implicitly declared by the &lt;a href=&quot;operator_other#Function_call&quot;&gt;function call operator&lt;/a&gt; and function parameters of type &lt;code&gt;int&lt;/code&gt; do not have to be declared when using old-style &lt;a href=&quot;function_definition&quot;&gt;function definitions&lt;/a&gt;.</source>
          <target state="translated">또한 C89에서 &lt;code&gt;int&lt;/code&gt; 를 반환 하는 &lt;a href=&quot;operator_other#Function_call&quot;&gt;함수&lt;/a&gt; 는 함수 호출 연산자에 의해 암시 적으로 선언 될 수 있으며 이전 스타일 &lt;a href=&quot;function_definition&quot;&gt;함수 정의를&lt;/a&gt; 사용할 때는 &lt;code&gt;int&lt;/code&gt; 유형의 함수 매개 변수를 선언 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="3b74e96e489cf616e54374e5e92ff3290101f441" translate="yes" xml:space="preserve">
          <source>Alternative</source>
          <target state="translated">Alternative</target>
        </trans-unit>
        <trans-unit id="3c2e302cecd8e724ebefc4430def999e1f422931" translate="yes" xml:space="preserve">
          <source>Alternative operator spellings</source>
          <target state="translated">대체 연산자 철자</target>
        </trans-unit>
        <trans-unit id="29b586a7316da5dd137563369a7689b456379b04" translate="yes" xml:space="preserve">
          <source>Alternative operators and tokens</source>
          <target state="translated">대체 연산자 및 토큰</target>
        </trans-unit>
        <trans-unit id="4169be2060a4f8c4d585658039b95f12303e8c2e" translate="yes" xml:space="preserve">
          <source>Alternative tokens(C95)</source>
          <target state="translated">대체 토큰 (C95)</target>
        </trans-unit>
        <trans-unit id="a40e532bb9001ffd6cd51359a18af099b40b59fc" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;pow&lt;/code&gt; cannot be used to obtain a root of a negative number, &lt;code&gt;&lt;a href=&quot;cbrt&quot;&gt;cbrt&lt;/a&gt;&lt;/code&gt; is provided for the common case where &lt;code&gt;exponent&lt;/code&gt; is 1/3.</source>
          <target state="translated">비록 &lt;code&gt;pow&lt;/code&gt; 음수의 루트를 취득 할 수없는, &lt;code&gt;&lt;a href=&quot;cbrt&quot;&gt;cbrt&lt;/a&gt;&lt;/code&gt; 일반적인 경우를 위해 제공된다 &lt;code&gt;exponent&lt;/code&gt; 1/3이다.</target>
        </trans-unit>
        <trans-unit id="2d8e94ab087764ac5aa30f64f41b3a370e564193" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;scalbn&lt;/code&gt; and &lt;code&gt;scalbln&lt;/code&gt; are specified to perform the operation efficiently, on many implementations they are less efficient than multiplication or division by a power of two using arithmetic operators.</source>
          <target state="translated">&lt;code&gt;scalbn&lt;/code&gt; 과 &lt;code&gt;scalbln&lt;/code&gt; 은 연산을 효율적으로 수행하도록 지정 되었지만 많은 구현에서 산술 연산자를 사용하여 2의 거듭 제곱으로 곱하거나 나누는 것보다 덜 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="0137da8668a196cbd69268350977f203b3e7ba1a" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;strcat_s&lt;/code&gt; prohibits truncation due to potential security risks, it's possible to truncate a string using bounds-checked &lt;code&gt;&lt;a href=&quot;strncat&quot;&gt;strncat_s&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;strcat_s&lt;/code&gt; 는 잠재적 인 보안 위험으로 인해 잘림을 금지 하지만 경계 검사 &lt;code&gt;&lt;a href=&quot;strncat&quot;&gt;strncat_s&lt;/a&gt;&lt;/code&gt; 를 사용하여 문자열을 잘릴 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="01379ffb327aca2e2965c17285601b164531b9d3" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;strcpy_s&lt;/code&gt; prohibits truncation due to potential security risks, it's possible to truncate a string using bounds-checked &lt;code&gt;&lt;a href=&quot;strncpy&quot;&gt;strncpy_s&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;strcpy_s&lt;/code&gt; 는 잠재적 인 보안 위험으로 인해 잘림을 금지 하지만 대신 경계 검사 &lt;code&gt;&lt;a href=&quot;strncpy&quot;&gt;strncpy_s&lt;/a&gt;&lt;/code&gt; 를 사용하여 문자열을 잘릴 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c5b70b90ff2e7a517d78bb25ef1bb2546d9ba464" translate="yes" xml:space="preserve">
          <source>Although a zero-initialized &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;mbstate_t&lt;/a&gt;&lt;/code&gt; always represents the initial conversion state, there may be other values of &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;mbstate_t&lt;/a&gt;&lt;/code&gt; that also represent the initial conversion state.</source>
          <target state="translated">초기화되지 않은 &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;mbstate_t&lt;/a&gt;&lt;/code&gt; 는 항상 초기 변환 상태 를 나타내지 만 &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;mbstate_t&lt;/a&gt;&lt;/code&gt; 의 다른 값이 초기 변환 상태를 나타낼 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="521f97be29caaa78fcaf410bee9ae92c160ecbf8" translate="yes" xml:space="preserve">
          <source>Although any non-initialized subobjects are initialized implicitly, implicit initialization of a subobject never overrides explicit initialization of the same subobject if it appeared earlier in the initializer list:</source>
          <target state="translated">초기화되지 않은 서브 오브젝트는 내재적으로 초기화되지만 서브 오브젝트의 내재적 초기화는 동일한 서브 오브젝트가 이니셜 라이저 목록의 앞부분에 나타난 경우 명시적인 초기화를 대체하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9f867aad644439954e9498b489992312dc0bfdc5" translate="yes" xml:space="preserve">
          <source>Although any pointer to object &lt;a href=&quot;cast&quot;&gt;can be cast&lt;/a&gt; to pointer to object of a different type, dereferencing a pointer to the type different from the declared type of the object is almost always undefined behavior. See &lt;a href=&quot;object#Strict_aliasing&quot;&gt;strict aliasing&lt;/a&gt; for details.</source>
          <target state="translated">객체에 대한 포인터가 있지만 &lt;a href=&quot;cast&quot;&gt;캐스트 할 수 있습니다&lt;/a&gt; 개체의 선언 된 유형에서 유형의 다른 포인터를 역 참조, 다른 유형의 객체에 대한 포인터에 거의 항상 정의되지 않은 동작입니다. 자세한 내용은 &lt;a href=&quot;object#Strict_aliasing&quot;&gt;엄격한 앨리어싱&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="782db2506e8b16f17d55cc92953bb6895f994beb" translate="yes" xml:space="preserve">
          <source>Although arrays are not assignable, an array wrapped in a struct is assignable to another object of the same (or compatible) struct type.</source>
          <target state="translated">배열을 할당 할 수는 없지만 구조체에 래핑 된 배열은 동일한 (또는 호환 가능한) 구조체 유형의 다른 객체에 할당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="430fe03afb1283d4323b38c44acf81ba027f8497" translate="yes" xml:space="preserve">
          <source>Although function call is only defined for pointers to functions, it works with function designators due to the &lt;a href=&quot;conversion#Function_to_pointer_conversion&quot;&gt;function-to-pointer implicit conversion&lt;/a&gt;.</source>
          <target state="translated">함수 호출은 함수에 대한 포인터에 대해서만 정의되지만 함수 &lt;a href=&quot;conversion#Function_to_pointer_conversion&quot;&gt;에서 포인터로의 암시 적 변환&lt;/a&gt; 으로 인해 함수 지정자와 함께 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="f95c1167e4e765bd871f83860e20dc43744490fd" translate="yes" xml:space="preserve">
          <source>Although most implementations do not allow trap representations, padding bits, or multiple representations for integer types, there are exceptions; for example a value of an integer type on Itanium &lt;a href=&quot;https://blogs.msdn.microsoft.com/oldnewthing/20040119-00/?p=41003&quot;&gt;may be a trap representation&lt;/a&gt;.</source>
          <target state="translated">대부분의 구현에서는 트랩 표현, 패딩 비트 또는 정수 유형에 대한 다중 표현을 허용하지 않지만 예외는 있습니다. 예를 들어 Itanium의 정수 유형 값은 &lt;a href=&quot;https://blogs.msdn.microsoft.com/oldnewthing/20040119-00/?p=41003&quot;&gt;트랩 표현 일 수 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ee0f85d5b5f4455a1b40b55fabe7b08d4d7be13b" translate="yes" xml:space="preserve">
          <source>Although not defined by the C standard, this is almost always an integral value holding the number of seconds (not counting leap seconds) since 00:00, Jan 1 1970 UTC, corresponding to &lt;a href=&quot;https://en.wikipedia.org/wiki/Unix_time&quot;&gt; POSIX time&lt;/a&gt;.</source>
          <target state="translated">비록 C 표준에 의해 정의되지는 않았지만, 이것은 1970 년 1 월 1 일 UTC 00:00 이후 &lt;a href=&quot;https://en.wikipedia.org/wiki/Unix_time&quot;&gt;POSIX 시간에&lt;/a&gt; 해당하는 초 수를 포함하는 정수 값 (거의 초를 세지 않음) 입니다.</target>
        </trans-unit>
        <trans-unit id="a46ea2cf03738e87c00f27d14c8aeeab6336c94e" translate="yes" xml:space="preserve">
          <source>Although old-style (prototype-less) &lt;a href=&quot;function_declaration&quot;&gt;function declarations&lt;/a&gt; allow the subsequent function calls to use any number of arguments, they are not allowed to be variadic (as of C89). The definition of such function must specify a fixed number of parameters and cannot use the &lt;code&gt;stdarg.h&lt;/code&gt; macros.</source>
          <target state="translated">구식 (프로토 타입이없는) &lt;a href=&quot;function_declaration&quot;&gt;함수 선언&lt;/a&gt; 으로 후속 함수 호출에서 여러 개의 인수를 사용할 수 있지만 가변적 일 수는 없습니다 (C89 기준). 이러한 함수의 정의는 고정 된 수의 매개 변수를 지정해야하며 &lt;code&gt;stdarg.h&lt;/code&gt; 매크로를 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="183d193e98a51645be957397dbe1157096e4898e" translate="yes" xml:space="preserve">
          <source>Although signed integer overflow in any arithmetic operator is undefined behavior, overflowing a signed integer type in an integer conversion is merely unspecified behavior.</source>
          <target state="translated">산술 연산자의 부호있는 정수 오버플로는 정의되지 않은 동작이지만 정수 변환에서 부호있는 정수 유형을 오버플로하는 것은 지정되지 않은 동작입니다.</target>
        </trans-unit>
        <trans-unit id="c610559acf57d5e13360168218d35087e3133418" translate="yes" xml:space="preserve">
          <source>Although the C standard names the inverse hyperbolics with &quot;complex arc hyperbolic sine&quot; etc., the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct names are &quot;complex inverse hyperbolic sine&quot; etc. Some authors use &quot;complex area hyperbolic sine&quot; etc.</source>
          <target state="translated">C 표준은 &quot;복합 아크 쌍곡 사인&quot;등으로 역 쌍곡선을 명명하지만 쌍곡선 함수의 역함수는 영역 함수입니다. 그들의 논증은 호가 아닌 쌍곡선 영역의 영역입니다. 올바른 이름은 &quot;복합 역 쌍곡 사인&quot;등입니다. 일부 저자는 &quot;복합 영역 쌍곡 사인&quot;등을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="53eb2f193d1ece133e78496ed9e6ccf150600d5c" translate="yes" xml:space="preserve">
          <source>Although the C standard names this function &quot;arc hyperbolic cosine&quot;, the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is &quot;inverse hyperbolic cosine&quot; (used by POSIX) or &quot;area hyperbolic cosine&quot;.</source>
          <target state="translated">C 표준에서는이 함수의 이름을 &quot;arc hyperbolic cosine&quot;으로 지정하지만 쌍곡선 함수의 역함수는 영역 함수입니다. 그들의 논증은 호가 아닌 쌍곡선 영역의 영역입니다. 올바른 이름은 &quot;역 쌍곡 코사인&quot;(POSIX에서 사용) 또는 &quot;영역 쌍곡 코사인&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="9cc69d890735ff86a139ac61024682374f6710b3" translate="yes" xml:space="preserve">
          <source>Although the C standard names this function &quot;arc hyperbolic sine&quot;, the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is &quot;inverse hyperbolic sine&quot; (used by POSIX) or &quot;area hyperbolic sine&quot;.</source>
          <target state="translated">C 표준에서는이 기능을 &quot;아크 쌍곡 사인&quot;이라고 명명하지만 쌍곡선 함수의 역함수는 영역 함수입니다. 그들의 논증은 호가 아닌 쌍곡선 영역의 영역입니다. 올바른 이름은 &quot;역 쌍곡 사인&quot;(POSIX에서 사용) 또는 &quot;영역 쌍곡 사인&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="1c9639606a887095dbb5eeca1ccea8904ebf0979" translate="yes" xml:space="preserve">
          <source>Although the C standard names this function &quot;arc hyperbolic tangent&quot;, the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is &quot;inverse hyperbolic tangent&quot; (used by POSIX) or &quot;area hyperbolic tangent&quot;.</source>
          <target state="translated">C 표준에서는이 함수를 &quot;아크 쌍곡 탄젠트&quot;라고 명명하지만 쌍곡선 함수의 역함수는 영역 함수입니다. 그들의 논증은 호가 아닌 쌍곡선 영역의 영역입니다. 올바른 이름은 &quot;역 쌍곡 탄젠트&quot;(POSIX에서 사용) 또는 &quot;면 쌍곡 탄젠트&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="a42f4b1a642341cb7f5490a130fadc09495ae219" translate="yes" xml:space="preserve">
          <source>Although the C standard names this function &quot;complex arc hyperbolic cosine&quot;, the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is &quot;complex inverse hyperbolic cosine&quot;, and, less common, &quot;complex area hyperbolic cosine&quot;.</source>
          <target state="translated">C 표준에서는이 기능을 &quot;복합 아크 쌍곡 코사인&quot;이라고 명명하지만 쌍곡선 함수의 역함수는 영역 함수입니다. 그들의 논증은 호가 아닌 쌍곡선 영역의 영역입니다. 올바른 이름은 &quot;복합 역 쌍곡 코사인&quot;이며 덜 일반적으로는 &quot;복합 영역 쌍곡 코사인&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="627b752f245ff7b1c7740db9d2b8d3d303af20f5" translate="yes" xml:space="preserve">
          <source>Although the C standard names this function &quot;complex arc hyperbolic sine&quot;, the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is &quot;complex inverse hyperbolic sine&quot;, and, less common, &quot;complex area hyperbolic sine&quot;.</source>
          <target state="translated">C 표준에서는이 기능을 &quot;복합 아크 쌍곡 사인&quot;이라고 명명하지만 쌍곡선 함수의 역함수는 영역 함수입니다. 그들의 논증은 호가 아닌 쌍곡선 영역의 영역입니다. 올바른 이름은 &quot;복합 역 쌍곡 사인&quot;이며 덜 일반적으로는 &quot;복합 영역 쌍곡 사인&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="36d2388b219b1a45a5fcef0d0ad2e1d71bd9c5f1" translate="yes" xml:space="preserve">
          <source>Although the C standard names this function &quot;complex arc hyperbolic tangent&quot;, the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is &quot;complex inverse hyperbolic tangent&quot;, and, less common, &quot;complex area hyperbolic tangent&quot;.</source>
          <target state="translated">C 표준에서는이 기능을 &quot;복합 아크 쌍곡 탄젠트&quot;라고 명명하지만 쌍곡선 함수의 역함수는 영역 함수입니다. 그들의 논증은 호가 아닌 쌍곡선 영역의 영역입니다. 올바른 이름은 &quot;복합 역 쌍곡 탄젠트&quot;이고 덜 일반적으로 &quot;복합 영역 쌍곡 탄젠트&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="e55c4c08037504cff68121796bbc9e46b8ee6db3" translate="yes" xml:space="preserve">
          <source>Although the names generated by &lt;code&gt;tmpnam&lt;/code&gt; are difficult to guess, it is possible that a file with that name is created by another process between the moment &lt;code&gt;tmpnam&lt;/code&gt; returns and the moment this program attempts to use the returned name to create a file. The standard function &lt;code&gt;&lt;a href=&quot;tmpfile&quot;&gt;tmpfile&lt;/a&gt;&lt;/code&gt; and the POSIX function &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/mkdtemp.html&quot;&gt;mkstemp&lt;/a&gt; do not have this problem (creating a unique directory using only the standard C library still requires the use of &lt;code&gt;tmpnam&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;tmpnam&lt;/code&gt; 에 의해 생성 된 이름 은 추측하기 어렵지만, 해당 이름을 가진 파일은 &lt;code&gt;tmpnam&lt;/code&gt; 이 리턴하는 순간과이 프로그램이 리턴 된 이름을 사용하여 파일을 작성하려고하는 순간 사이에 다른 프로세스에 의해 작성 될 수 있습니다. 표준 함수 &lt;code&gt;&lt;a href=&quot;tmpfile&quot;&gt;tmpfile&lt;/a&gt;&lt;/code&gt; 및 POSIX 함수 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/mkdtemp.html&quot;&gt;mkstemp&lt;/a&gt; 에는이 문제가 없습니다 (표준 C 라이브러리 만 사용하여 고유 한 디렉토리를 작성하려면 여전히 &lt;code&gt;tmpnam&lt;/code&gt; 을 사용해야합니다 ).</target>
        </trans-unit>
        <trans-unit id="a8a747e33a10c6fa21c941b73f1438fc704b6283" translate="yes" xml:space="preserve">
          <source>Although the return type is &lt;code&gt;char*&lt;/code&gt;, modifying the pointed-to characters is undefined behavior.</source>
          <target state="translated">리턴 유형이 &lt;code&gt;char*&lt;/code&gt; 이지만, 지정된 문자를 수정하는 것은 정의되지 않은 동작입니다.</target>
        </trans-unit>
        <trans-unit id="5d77d3b4837e50c32db090517b15b7c3f0e6e611" translate="yes" xml:space="preserve">
          <source>Although the standard specification is ambiguous in the case where &lt;code&gt;count==1&lt;/code&gt;, common implementations read no characters, store zero in &lt;code&gt;str[0]&lt;/code&gt;, and report success (return &lt;code&gt;str&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;count==1&lt;/code&gt; 인 경우 표준 사양이 모호하지만 일반적인 구현은 문자를 읽지 않고 &lt;code&gt;str[0]&lt;/code&gt; 에 0을 저장 하며 성공을보고합니다 (반환 &lt;code&gt;str&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="643daeb4adeff0fcce44a0450dc2ccf13dec660b" translate="yes" xml:space="preserve">
          <source>Although the syntax of a compound literal is similar to a &lt;a href=&quot;cast&quot;&gt;cast&lt;/a&gt;, the important distinction is that a cast is a non-lvalue expression while a compound literal is an lvalue.</source>
          <target state="translated">복합 리터럴의 구문은 &lt;a href=&quot;cast&quot;&gt;cast&lt;/a&gt; 와 유사하지만 중요한 차이점은 캐스트는 lvalue가 아닌 표현식이고 복합 리터럴은 lvalue입니다.</target>
        </trans-unit>
        <trans-unit id="524b5a64840b79d1a2de79e908e1ff895523c4a5" translate="yes" xml:space="preserve">
          <source>Although truncation to fit the destination buffer is a security risk and therefore a runtime constraints violation for &lt;code&gt;strncat_s&lt;/code&gt;, it is possible to get the truncating behavior by specifying &lt;code&gt;count&lt;/code&gt; equal to the size of the destination array minus one: it will copy the first &lt;code&gt;count&lt;/code&gt; bytes and append the null terminator as always: &lt;code&gt;strncat_s(dst, sizeof dst, src, (sizeof dst)-strnlen_s(dst, sizeof dst)-1);&lt;/code&gt;</source>
          <target state="translated">대상 버퍼에 맞추기위한 잘림은 보안 위험이므로 &lt;code&gt;strncat_s&lt;/code&gt; 에 대한 런타임 제한 조건 위반 이지만 대상 배열의 크기에서 1을 뺀 것과 같은 &lt;code&gt;count&lt;/code&gt; 를 지정하여 잘림 동작을 얻을 수 있습니다 . 첫 번째 &lt;code&gt;count&lt;/code&gt; 바이트를 복사 하고 항상 널 종료 &lt;code&gt;strncat_s(dst, sizeof dst, src, (sizeof dst)-strnlen_s(dst, sizeof dst)-1);&lt;/code&gt; 추가하십시오. strncat_s (dst, sizeof dst, src, (sizeof dst) -strnlen_s (dst, sizeof dst) -1);</target>
        </trans-unit>
        <trans-unit id="31058475f488e9122376b4823fdbfa19cec13f95" translate="yes" xml:space="preserve">
          <source>Although truncation to fit the destination buffer is a security risk and therefore a runtime constraints violation for &lt;code&gt;strncpy_s&lt;/code&gt;, it is possible to get the truncating behavior by specifying &lt;code&gt;count&lt;/code&gt; equal to the size of the destination array minus one: it will copy the first &lt;code&gt;count&lt;/code&gt; bytes and append the null terminator as always: &lt;code&gt;strncpy_s(dst, sizeof dst, src, (sizeof dst)-1);&lt;/code&gt;</source>
          <target state="translated">대상 버퍼에 맞추기위한 잘림이 보안 위험이므로 &lt;code&gt;strncpy_s&lt;/code&gt; 에 대한 런타임 제한 조건 위반 이지만 대상 배열의 크기에서 1을 뺀 것과 같은 &lt;code&gt;count&lt;/code&gt; 를 지정하여 잘림 동작을 얻을 수 있습니다 . 첫 번째 &lt;code&gt;count&lt;/code&gt; 바이트를 복사 하고 항상 널 종료 &lt;code&gt;strncpy_s(dst, sizeof dst, src, (sizeof dst)-1);&lt;/code&gt; 추가하십시오. strncpy_s (dst, sizeof dst, src, (sizeof dst) -1);</target>
        </trans-unit>
        <trans-unit id="ed3455470f39d87a62eebd7b7029aa61541270b7" translate="yes" xml:space="preserve">
          <source>Although truncation to fit the destination buffer is a security risk and therefore a runtime constraints violation for &lt;code&gt;wcsncat_s&lt;/code&gt;, it is possible to get the truncating behavior by specifying &lt;code&gt;count&lt;/code&gt; equal to the size of the destination array minus one: it will copy the first &lt;code&gt;count&lt;/code&gt; wide characters and append the null terminator as always: &lt;code&gt;wcsncat_s(dst, sizeof dst/sizeof *dst, src, (sizeof dst/sizeof *dst)-wcsnlen_s(dst, sizeof dst/sizeof *dst)-1);&lt;/code&gt;</source>
          <target state="translated">대상 버퍼에 맞추기위한 잘림이 보안 위험이므로 &lt;code&gt;wcsncat_s&lt;/code&gt; 에 대한 런타임 제한 조건 위반 이지만 대상 배열의 크기에서 1을 뺀 것과 같은 &lt;code&gt;count&lt;/code&gt; 를 지정하여 잘림 동작을 얻을 &lt;code&gt;count&lt;/code&gt; 있습니다 . 첫 번째 수의 넓은 문자를 복사합니다. 항상 널 종료 &lt;code&gt;wcsncat_s(dst, sizeof dst/sizeof *dst, src, (sizeof dst/sizeof *dst)-wcsnlen_s(dst, sizeof dst/sizeof *dst)-1);&lt;/code&gt; 추가하십시오. wcsncat_s (dst, sizeof dst / sizeof * dst, src, (sizeof dst / sizeof * dst) -wcsnlen_s (dst, sizeof dst / sizeof * dst) -1);</target>
        </trans-unit>
        <trans-unit id="91cbd8326b7ebc58c195548dc89d276533889261" translate="yes" xml:space="preserve">
          <source>Although truncation to fit the destination buffer is a security risk and therefore a runtime constraints violation for &lt;code&gt;wcsncpy_s&lt;/code&gt;, it is possible to get the truncating behavior by specifying &lt;code&gt;count&lt;/code&gt; equal to the size of the destination array minus one: it will copy the first &lt;code&gt;count&lt;/code&gt; wide characters and append the null wide terminator as always: &lt;code&gt;wcsncpy_s(dst, sizeof dst / sizeof *dst, src, (sizeof dst / sizeof *dst)-1);&lt;/code&gt;</source>
          <target state="translated">대상 버퍼에 맞추기위한 잘림이 보안 위험이므로 &lt;code&gt;wcsncpy_s&lt;/code&gt; 에 대한 런타임 제한 조건 위반 이지만 대상 배열의 크기에서 1을 뺀 것과 같은 &lt;code&gt;count&lt;/code&gt; 를 지정하여 잘림 동작을 얻을 &lt;code&gt;count&lt;/code&gt; 있습니다 . 첫 번째 수의 넓은 문자를 복사합니다. 항상 널 와이드 종결 &lt;code&gt;wcsncpy_s(dst, sizeof dst / sizeof *dst, src, (sizeof dst / sizeof *dst)-1);&lt;/code&gt; 추가하십시오. wcsncpy_s (dst, sizeof dst / sizeof * dst, src, (sizeof dst / sizeof * dst) -1);</target>
        </trans-unit>
        <trans-unit id="99690d58d4abd10cd0938a7adcb56ded08ef66ad" translate="yes" xml:space="preserve">
          <source>An</source>
          <target state="translated">An</target>
        </trans-unit>
        <trans-unit id="e95121f45a467fe30f9e9b9421b8414b5dc9b5a8" translate="yes" xml:space="preserve">
          <source>An exception to the above rule is the &lt;code&gt;fabs&lt;/code&gt; macro (see the table below).</source>
          <target state="translated">위 규칙의 예외는 &lt;code&gt;fabs&lt;/code&gt; 매크로입니다 (아래 표 참조).</target>
        </trans-unit>
        <trans-unit id="34f74cee143d788f51fcc25acc797aea92c197b8" translate="yes" xml:space="preserve">
          <source>An expression followed by a semicolon is a statement.</source>
          <target state="translated">세미콜론 뒤에 오는 표현식은 명령문입니다.</target>
        </trans-unit>
        <trans-unit id="c5756e59953f27f7802c2879dfb5bf8b2ef537aa" translate="yes" xml:space="preserve">
          <source>An expression is a sequence of</source>
          <target state="translated">식은 일련의</target>
        </trans-unit>
        <trans-unit id="8582e3c88de4617441467faab5ff600afdf1bfb6" translate="yes" xml:space="preserve">
          <source>An expression statement without an expression is called a</source>
          <target state="translated">표현식이없는 표현식 문을</target>
        </trans-unit>
        <trans-unit id="e88ff614d33ada21febd8f65027f3a4ddd6534c8" translate="yes" xml:space="preserve">
          <source>An incomplete type is an object type that lacks sufficient information to determine the size of the objects of that type. An incomplete type may be completed at some point in the translation unit.</source>
          <target state="translated">불완전한 유형은 해당 유형의 객체 크기를 결정하기에 충분한 정보가없는 객체 유형입니다. 번역 단위의 어느 시점에서 불완전한 유형이 완성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="922cdb3f2c9cb3526b3e2d10c81d2dfe51f98e18" translate="yes" xml:space="preserve">
          <source>An integer constant expression is an expression that consists only of.</source>
          <target state="translated">정수 상수 표현식은로만 구성된 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="f10b2455ca40601e84b6c671226ded817e8d0567" translate="yes" xml:space="preserve">
          <source>An integer constant is a &lt;a href=&quot;value_category&quot;&gt;non-lvalue&lt;/a&gt; expression of the form.</source>
          <target state="translated">정수 상수는 양식 이 &lt;a href=&quot;value_category&quot;&gt;아닌&lt;/a&gt; 값이 아닌 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="4fbb0b241c865dd210a0103cf5d2af8c3a3e8a71" translate="yes" xml:space="preserve">
          <source>An integer greater than zero if the stream is wide-oriented after this call, less than zero if the stream is byte-oriented after this call, and zero if the stream has no orientation.</source>
          <target state="translated">이 호출 이후에 스트림의 방향이 넓은 경우는 0보다 큰 정수,이 호출의 뒤에 스트림이 바이트 방향 인 경우는 0 미만, 스트림에 방향이없는 경우는 0</target>
        </trans-unit>
        <trans-unit id="22296b3029f90df1ec990b3a781242c55d5beaa6" translate="yes" xml:space="preserve">
          <source>An integer type which can be accessed as an atomic entity even in the presence of asynchronous interrupts made by signals.</source>
          <target state="translated">신호에 의한 비동기 인터럽트가있는 경우에도 원자 엔티티로 액세스 할 수있는 정수 유형입니다.</target>
        </trans-unit>
        <trans-unit id="509428cacc9180cadada492e5a97d331536c77bb" translate="yes" xml:space="preserve">
          <source>An object whose identifier is declared with the storage-class specifier &lt;code&gt;_Thread_local&lt;/code&gt;(since C11) has thread storage duration. Its lifetime is the entire execution of the thread for which it is created, and its stored value is initialized when the thread is started. There is a distinct object per thread, and use of the declared name in an expression refers to the object associated with the thread evaluating the expression. The result of attempting to indirectly access an object with thread storage duration from a thread other than the one with which the object is associated is implementation-defined.</source>
          <target state="translated">스토리지 클래스 지정자 &lt;code&gt;_Thread_local&lt;/code&gt; (C11 이후) 로 식별자가 선언 된 오브젝트 에는 스레드 스토리지 기간이 있습니다. 수명은 생성 된 스레드의 전체 실행이며 스레드가 시작될 때 저장된 값이 초기화됩니다. 스레드마다 고유 한 개체가 있으며 식에서 선언 된 이름을 사용하면 식을 평가하는 스레드와 관련된 개체를 나타냅니다. 객체와 관련된 스레드 이외의 스레드에서 스레드 저장 기간이있는 객체에 간접적으로 액세스하려고 시도한 결과는 구현 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="ca6829296f71df282c1b4376c48afbb797f79121" translate="yes" xml:space="preserve">
          <source>An object whose identifier is declared without the storage-class specifier &lt;code&gt;_Thread_local&lt;/code&gt;, and either with external or internal &lt;a href=&quot;storage_duration#Linkage&quot;&gt;linkage&lt;/a&gt; or with the storage-class specifier &lt;code&gt;static&lt;/code&gt;, has static storage duration. Its lifetime is the entire execution of the program and its stored value is initialized only once, prior to program startup.</source>
          <target state="translated">스토리지 클래스 지정자 &lt;code&gt;_Thread_local&lt;/code&gt; 없이, 외부 또는 내부 &lt;a href=&quot;storage_duration#Linkage&quot;&gt;연결&lt;/a&gt; 또는 스토리지 클래스 지정자 &lt;code&gt;static&lt;/code&gt; 으로 식별자가 선언 된 오브젝트 는 정적 스토리지 지속 기간을 갖습니다. 수명은 프로그램의 전체 실행이며 저장된 값은 프로그램 시작 전에 한 번만 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="ac3869f4a5a82462e5b3c6903ccb04495bd9eeec" translate="yes" xml:space="preserve">
          <source>An object, in C, is region of &lt;a href=&quot;memory_model&quot;&gt;data storage&lt;/a&gt; in the execution environment, the contents of which can represent</source>
          <target state="translated">C에서 오브젝트 는 실행 환경에서 &lt;a href=&quot;memory_model&quot;&gt;데이터 스토리지&lt;/a&gt; 영역이며 컨텐츠는이를 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78ade4e82af0b35312ea1cf340af57aa22d18fa0" translate="yes" xml:space="preserve">
          <source>An unsuffixed floating constant has type &lt;code&gt;double&lt;/code&gt;. If suffix is the letter &lt;code&gt;f&lt;/code&gt; or &lt;code&gt;F&lt;/code&gt;, the floating constant has type &lt;code&gt;float&lt;/code&gt;. If suffix is the letter &lt;code&gt;l&lt;/code&gt; or &lt;code&gt;L&lt;/code&gt;, the floating constant has type &lt;code&gt;long double&lt;/code&gt;.</source>
          <target state="translated">접미사가없는 부동 상수에는 &lt;code&gt;double&lt;/code&gt; 유형이 있습니다. 접미사가 문자 &lt;code&gt;f&lt;/code&gt; 또는 &lt;code&gt;F&lt;/code&gt; 인 경우 부동 상수의 유형은 &lt;code&gt;float&lt;/code&gt; 입니다. 접미사가 문자 &lt;code&gt;l&lt;/code&gt; 또는 &lt;code&gt;L&lt;/code&gt; 인 경우 부동 상수의 유형은 &lt;code&gt;long double&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6af0fd01a43835edcca93cfea6189ce121e3b7bc" translate="yes" xml:space="preserve">
          <source>Analyzability</source>
          <target state="translated">Analyzability</target>
        </trans-unit>
        <trans-unit id="1224aba20bea722a32d03ea6e039ef1fe32002ee" translate="yes" xml:space="preserve">
          <source>Analyzability extension permits, as a form of implementation-defined behavior, for the &lt;a href=&quot;../error/set_constraint_handler_s&quot;&gt;runtime constraint handler&lt;/a&gt; to be invoked when a trap occurs.</source>
          <target state="translated">분석 가능성 확장은 구현 정의 동작의 형태로 트랩이 발생할 때 &lt;a href=&quot;../error/set_constraint_handler_s&quot;&gt;런타임 제한 조건 핸들러&lt;/a&gt; 가 호출 될 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="88fad02460e9c399ee6de569a0dbe485d36f0c20" translate="yes" xml:space="preserve">
          <source>Annex G (informative) IEC 60559-compatible complex arithmetic (p: 467-480)</source>
          <target state="translated">부록 G (정보) IEC 60559 호환 복소수 연산 (p : 467-480)</target>
        </trans-unit>
        <trans-unit id="363c4a1ac12e80d5822b10c88a28ccf2c8e5db57" translate="yes" xml:space="preserve">
          <source>Annex G (normative) IEC 60559-compatible complex arithmetic (p: 532-545)</source>
          <target state="translated">부록 G (규정) IEC 60559 호환 복소수 연산 (p : 532-545)</target>
        </trans-unit>
        <trans-unit id="b05eeba32030c7db8c4ce96b39a5db85c6475ff5" translate="yes" xml:space="preserve">
          <source>Annex L Analyzability (p: 652-653)</source>
          <target state="translated">부속서 L 분석 가능성 (p : 652-653)</target>
        </trans-unit>
        <trans-unit id="899d67ebfae429b08b8eebcf8e8c9e086747304a" translate="yes" xml:space="preserve">
          <source>Another way to test if a floating-point value is NaN is to compare it with itself: &lt;code&gt;bool is_nan(double x) { return x != x; }&lt;/code&gt;</source>
          <target state="translated">부동 소수점 값이 NaN인지 테스트하는 또 다른 방법은 값을 자체와 비교하는 것입니다. &lt;code&gt;bool is_nan(double x) { return x != x; }&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9ce38c932d44d15a1b772dcde23f9e877b670097" translate="yes" xml:space="preserve">
          <source>Any &lt;a href=&quot;value_category&quot;&gt;lvalue expression&lt;/a&gt; of &lt;a href=&quot;array&quot;&gt;array type&lt;/a&gt;, when used in any context other than.</source>
          <target state="translated">상관 &lt;a href=&quot;value_category&quot;&gt;좌변 식&lt;/a&gt; 의 &lt;a href=&quot;array&quot;&gt;어레이 형&lt;/a&gt; 이외의 문맥에서 사용.</target>
        </trans-unit>
        <trans-unit id="3ada2b7aff782859a1770ce5c125b8fc47b51105" translate="yes" xml:space="preserve">
          <source>Any &lt;a href=&quot;value_category&quot;&gt;lvalue expression&lt;/a&gt; of any non-array type, when used in any context other than.</source>
          <target state="translated">상관 &lt;a href=&quot;value_category&quot;&gt;좌변 식&lt;/a&gt; 이외의 문맥에 사용 된 비 배열 유형의.</target>
        </trans-unit>
        <trans-unit id="b32b22200862e7a1d98c59831163dac931baf00f" translate="yes" xml:space="preserve">
          <source>Any &lt;a href=&quot;value_category&quot;&gt;lvalue expression&lt;/a&gt; of array type, when used in any context other than.</source>
          <target state="translated">이외의 컨텍스트에서 사용될 때 배열 유형의 모든 &lt;a href=&quot;value_category&quot;&gt;lvalue 표현식&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f119a4c0c577a8422656ad60e3f009df6812696f" translate="yes" xml:space="preserve">
          <source>Any attempt to modify an object whose type is const-qualified results in undefined behavior.</source>
          <target state="translated">형식이 한정된 객체를 수정하려고하면 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="866f91766b87953ad8edd681c9682a8e938a7503" translate="yes" xml:space="preserve">
          <source>Any attempt to modify an object with temporary lifetime results in undefined behavior.</source>
          <target state="translated">수명이 일시적인 개체를 수정하려고하면 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8749d31d9b04cec89cefa681f64da614302dca60" translate="yes" xml:space="preserve">
          <source>Any attempt to read or write to an object whose type is volatile-qualified through a non-volatile lvalue results in undefined behavior:</source>
          <target state="translated">비 휘발성 lvalue를 통해 유형이 휘발성으로 한정된 객체를 읽거나 쓰려고하면 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6de4873dedcbff8007c22dcc38d613721f09e7f5" translate="yes" xml:space="preserve">
          <source>Any declaration with internal linkage that appears in a header file results in a separate and distinct object in each translation unit that includes that file.</source>
          <target state="translated">헤더 파일에 표시되는 내부 링크가있는 선언은 해당 파일을 포함하는 각 변환 단위에서 별도의 개별 오브젝트를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="bd4ac1ef0bc8d5c87b738bd4653ebf9c1c653d80" translate="yes" xml:space="preserve">
          <source>Any expression in parentheses is also classified as a primary expression: this guarantees that the parentheses have higher precedence than any operator.</source>
          <target state="translated">괄호 안의 모든 표현은 기본 표현으로 분류됩니다. 이렇게하면 괄호가 어떤 연산자보다 우선 순위가 높습니다.</target>
        </trans-unit>
        <trans-unit id="dfcadc42c0ec036402e088068ff0c3bc13ca677e" translate="yes" xml:space="preserve">
          <source>Any function designator expression, when used in any context other than.</source>
          <target state="translated">이외의 컨텍스트에서 사용될 경우 함수 지정자 표현식</target>
        </trans-unit>
        <trans-unit id="4a02555a36d9834685af7a35630f001d24e0aeb2" translate="yes" xml:space="preserve">
          <source>Any function with internal linkage may be declared &lt;code&gt;static inline&lt;/code&gt; with no other restrictions.</source>
          <target state="translated">내부 연결이있는 함수는 다른 제한없이 &lt;code&gt;static inline&lt;/code&gt; 으로 선언 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f085377b18d48b26df1584fd15c220308ad01b5c" translate="yes" xml:space="preserve">
          <source>Any integer &lt;a href=&quot;constant_expression&quot;&gt;constant expression&lt;/a&gt; with value &lt;code&gt;​0​&lt;/code&gt; as well as integer pointer expression with value zero cast to the type &lt;code&gt;void*&lt;/code&gt; can be implicitly converted to any pointer type (both pointer to object and pointer to function). The result is the null pointer value of its type, guaranteed to compare unequal to any non-null pointer value of that type. This integer or void* expression is known as</source>
          <target state="translated">모든 정수 &lt;a href=&quot;constant_expression&quot;&gt;상수 식&lt;/a&gt; 값 &lt;code&gt;​0​&lt;/code&gt; 유형에 제로 값을 가진 캐스트뿐만 아니라 정수 포인터 식 &lt;code&gt;void*&lt;/code&gt; 내재적 어떤 포인터 타입 (객체 함수와 포인터 모두 포인터)로 전환 될 수있다. 결과는 해당 유형의 널 포인터 값이며 해당 유형의 널이 아닌 포인터 값과 같지 않습니다. 이 정수 또는 void * 표현식은</target>
        </trans-unit>
        <trans-unit id="f6aa9cfe41886fda825befd70140c82f188e05c0" translate="yes" xml:space="preserve">
          <source>Any integer can be cast to any pointer type. Except for the null pointer constants such as &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; (which &lt;a href=&quot;conversion&quot;&gt;doesn't need a cast&lt;/a&gt;), the result is implementation-defined, may not be correctly aligned, may not point to an object of the referenced type, and may be a &lt;a href=&quot;object&quot;&gt;trap representation&lt;/a&gt;.</source>
          <target state="translated">모든 정수는 모든 포인터 유형으로 캐스트 될 수 있습니다. &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; ( &lt;a href=&quot;conversion&quot;&gt;캐스트가 필요하지 않음)&lt;/a&gt; 과 같은 널 포인터 상수를 제외하고 결과는 구현에 따라 정의되고 올바르게 정렬되지 않을 수 있으며 참조 된 유형의 오브젝트를 가리 키지 않을 수 있으며 &lt;a href=&quot;object&quot;&gt;트랩 표현&lt;/a&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d27e4acb04a2d9fbbd446c13740539aaa280d88f" translate="yes" xml:space="preserve">
          <source>Any other access to the object with no declared type, the effective type is the type of the lvalue used for the access.</source>
          <target state="translated">선언 된 유형이없는 객체에 대한 다른 모든 액세스에서 유효 유형은 액세스에 사용 된 lvalue의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="1fce6ca708ece38a43d4cfdb4978f4ad32568af6" translate="yes" xml:space="preserve">
          <source>Any pointer to function can be cast to a pointer to any other function type. If the resulting pointer is converted back to the original type, it compares equal to the original value. If the converted pointer is used to make a function call, the behavior is undefined (unless the function types are &lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;compatible&lt;/a&gt;)</source>
          <target state="translated">함수에 대한 포인터는 다른 함수 유형에 대한 포인터로 캐스트 될 수 있습니다. 결과 포인터가 원래 유형으로 다시 변환되면 원래 값과 같습니다. 변환 된 포인터를 사용하여 함수를 호출하면 동작이 정의되지 않습니다 (함수 유형이 &lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;호환&lt;/a&gt; 되지 않는 한 )</target>
        </trans-unit>
        <trans-unit id="b5144273b9cff24a19477ce9d36d363c89d3f02e" translate="yes" xml:space="preserve">
          <source>Any pointer to object can be cast to any other pointer to object. If the value is not correctly aligned for the target type, the behavior is undefined. Otherwise, if the value is converted back to the original type, it compares equal to the original value. If a pointer to object is cast to pointer to any character type, the result points at the lowest byte of the object and may be incremented up to sizeof the target type (in other words, can be used to examine &lt;a href=&quot;object&quot;&gt;object representation&lt;/a&gt; or to make a copy via &lt;code&gt;&lt;a href=&quot;../string/byte/memcpy&quot;&gt;memcpy&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;memmove&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">객체에 대한 모든 포인터는 객체에 대한 다른 포인터로 캐스트 될 수 있습니다. 대상 유형에 대해 값이 올바르게 정렬되지 않은 경우 동작이 정의되지 않습니다. 그렇지 않으면 값이 원래 유형으로 다시 변환되면 원래 값과 비교됩니다. 객체에 대한 포인터가 임의의 문자 유형에 대한 포인터로 캐스트되는 경우 결과는 객체의 가장 낮은 바이트를 가리키고 대상 유형의 크기까지 증가 할 수 있습니다 (즉, &lt;a href=&quot;object&quot;&gt;객체 표현&lt;/a&gt; 을 검사 하거나 &lt;code&gt;&lt;a href=&quot;../string/byte/memcpy&quot;&gt;memcpy&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;memmove&lt;/a&gt;&lt;/code&gt; 를 통해 복사 ).</target>
        </trans-unit>
        <trans-unit id="53b27419880a23d059eebd1b3c848f2b6b494f5f" translate="yes" xml:space="preserve">
          <source>Any pointer type can be cast to any integer type. The result is implementation-defined, even for null pointer values (they do not necessarily result in the value zero). If the result cannot be represented in the target type, the behavior is undefined (unsigned integers do not implement modulo arithmetic on a cast from pointer)</source>
          <target state="translated">모든 포인터 유형은 모든 정수 유형으로 캐스트 될 수 있습니다. 널 포인터 값의 경우에도 결과는 구현에 따라 정의됩니다 (값이 반드시 0이 아님). 결과를 대상 유형으로 표현할 수없는 경우 동작이 정의되지 않습니다 (서명되지 않은 정수는 포인터에서 캐스트 할 때 모듈로 산술을 구현하지 않습니다)</target>
        </trans-unit>
        <trans-unit id="52919eaf1eb62c0854fdd694ccfd8a6c2a0705b3" translate="yes" xml:space="preserve">
          <source>Any preprocessing tokens (macro constants or expressions) are permitted as arguments to &lt;code&gt;#line&lt;/code&gt; as long as they expand to a valid decimal integer optionally following a valid character string.</source>
          <target state="translated">전처리 토큰 (매크로 상수 또는 표현식)은 선택적으로 유효한 문자열 뒤에 오는 유효한 십진 정수로 확장되는 한 &lt;code&gt;#line&lt;/code&gt; 에 대한 인수로 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="9f4fa7ee728ee63a75e7d354408e9febd14b9e02" translate="yes" xml:space="preserve">
          <source>Any statement (but not a declaration) may be preceded by any number of</source>
          <target state="translated">모든 진술 (선언은 아님) 앞에는</target>
        </trans-unit>
        <trans-unit id="594a9e7004e035507b2faafb30d5238be37f382a" translate="yes" xml:space="preserve">
          <source>Any statement can be</source>
          <target state="translated">모든 진술은</target>
        </trans-unit>
        <trans-unit id="9d8ddff307f484a3b8ee7169c75629627b1b6b4a" translate="yes" xml:space="preserve">
          <source>Any thread can potentially access any object in the program (objects with automatic and thread-local &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt; may still be accessed by another thread through a pointer).</source>
          <target state="translated">모든 스레드는 프로그램의 모든 개체에 잠재적으로 액세스 할 수 있습니다 (자동 및 스레드 로컬 &lt;a href=&quot;storage_duration&quot;&gt;저장 기간&lt;/a&gt; 이있는 개체 는 포인터를 통해 다른 스레드에서 계속 액세스 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="1ecdb25ac5e949980efec1665ec8ea0a080e3051" translate="yes" xml:space="preserve">
          <source>Appears in the &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt; syntax as one of the type specifiers to modify the &lt;a href=&quot;object#Alignment&quot;&gt;alignment requirement&lt;/a&gt; of the object being declared.</source>
          <target state="translated">&lt;a href=&quot;declarations&quot;&gt;선언&lt;/a&gt; 구문 에 선언되고있는 객체 의 &lt;a href=&quot;object#Alignment&quot;&gt;정렬 요구 사항&lt;/a&gt; 을 수정하기 위해 형식 지정자 중 하나로 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="8469bf011f6ccd77c6945c6cf345649aa9cff6e9" translate="yes" xml:space="preserve">
          <source>Appears only within the statement of a loop body (&lt;a href=&quot;while&quot;&gt;while&lt;/a&gt;, &lt;a href=&quot;do&quot;&gt;do&lt;/a&gt;, &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt;) or within the statement of a &lt;a href=&quot;switch&quot;&gt;switch&lt;/a&gt;.</source>
          <target state="translated">루프 본문 문 ( &lt;a href=&quot;while&quot;&gt;while&lt;/a&gt; , &lt;a href=&quot;do&quot;&gt;do&lt;/a&gt; , &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt; ) 또는 &lt;a href=&quot;switch&quot;&gt;스위치&lt;/a&gt; 문 내 에서만 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="1f41b36bd2867522723d540cbaf10ea09210fdf2" translate="yes" xml:space="preserve">
          <source>Append to a file</source>
          <target state="translated">파일에 추가</target>
        </trans-unit>
        <trans-unit id="10adbbd3a7c36a43cb9fa85a79d28613edb0183c" translate="yes" xml:space="preserve">
          <source>Application code:</source>
          <target state="translated">응용 프로그램 코드 :</target>
        </trans-unit>
        <trans-unit id="4da3e84107ea6402ad05595526acce55c364845f" translate="yes" xml:space="preserve">
          <source>Approximate</source>
          <target state="translated">Approximate</target>
        </trans-unit>
        <trans-unit id="ce5e5792e97fe5c7861d6ae9b29cf5a25cc0e70a" translate="yes" xml:space="preserve">
          <source>Argument</source>
          <target state="translated">Argument</target>
        </trans-unit>
        <trans-unit id="def2bf62b424e602e225d5df7086bbc94649ceb1" translate="yes" xml:space="preserve">
          <source>Argument type</source>
          <target state="translated">인수 유형</target>
        </trans-unit>
        <trans-unit id="7dfad58bef64485ffe28abdf14805afc5997a006" translate="yes" xml:space="preserve">
          <source>Arithmetic addition and subtraction</source>
          <target state="translated">산술 덧셈과 뺄셈</target>
        </trans-unit>
        <trans-unit id="86e9c4d92306ef176b1e643c9083d4f239172d17" translate="yes" xml:space="preserve">
          <source>Arithmetic constant expressions of floating-point types that are not used in static initializers are always evaluated as-if during run-time and are affected by the &lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;current rounding&lt;/a&gt; (if &lt;a href=&quot;../preprocessor/impl&quot;&gt;FENV_ACCESS&lt;/a&gt; is on) and report errors as specified in &lt;a href=&quot;../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;.</source>
          <target state="translated">런타임 동안 것처럼-과에 의해 영향을받는 정적 초기화에 사용하지 않는 부동 소수점 형식의 산술 상수 표현식은 항상 평가된다 &lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;현재 반올림&lt;/a&gt; (경우 &lt;a href=&quot;../preprocessor/impl&quot;&gt;FENV_ACCESS가&lt;/a&gt; 에 명시된대로 켜져) 및 보고서 오류 &lt;a href=&quot;../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d077356b7b5076ff62409f2fbd19527762e29c71" translate="yes" xml:space="preserve">
          <source>Arithmetic operators</source>
          <target state="translated">산술 연산자</target>
        </trans-unit>
        <trans-unit id="fcb531b953dd45da5064b2d52a06c231157ccecd" translate="yes" xml:space="preserve">
          <source>Arithmetic operators apply standard mathematical operations to their operands.</source>
          <target state="translated">산술 연산자는 표준 수학 연산을 피연산자에 적용합니다.</target>
        </trans-unit>
        <trans-unit id="3a96c27ea8acc41f84ccf2e2e957611cc9d4cd07" translate="yes" xml:space="preserve">
          <source>Arithmetic types</source>
          <target state="translated">산술 유형</target>
        </trans-unit>
        <trans-unit id="8de00b1bedff8647aff0425d6be471519b1d3a5a" translate="yes" xml:space="preserve">
          <source>Arithmetic(until C11)Real(since C11) type capable of representing the processor time used by a process. It has implementation-defined range and precision.</source>
          <target state="translated">프로세스에서 사용하는 프로세서 시간을 나타낼 수있는 산술 (C11까지) 실제 (C11 이후) 유형. 구현 정의 범위와 정밀도가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba5ba905dbea6b631aa488beea4ac4accbaf54e2" translate="yes" xml:space="preserve">
          <source>Arithmetic(until C11)Real(since C11) type capable of representing times.</source>
          <target state="translated">시간을 표현할 수있는 산술 (C11까지) 실제 (C11 이후) 유형.</target>
        </trans-unit>
        <trans-unit id="107004472b7ba4e5e31f3082ee1fb5a1239eec61" translate="yes" xml:space="preserve">
          <source>Array</source>
          <target state="translated">Array</target>
        </trans-unit>
        <trans-unit id="3fb125cc9e54d7ed417b90f1b586cad673b24cc3" translate="yes" xml:space="preserve">
          <source>Array declaration</source>
          <target state="translated">배열 선언</target>
        </trans-unit>
        <trans-unit id="9c4ba2b7b1b1387eaf59bf743fda8372525a2456" translate="yes" xml:space="preserve">
          <source>Array designators may be nested; the bracketed constant expression for nested arrays follows the bracketed constant expression for the outer array:</source>
          <target state="translated">배열 지정자는 중첩 될 수 있습니다. 중첩 배열의 대괄호 상수 표현식은 외부 배열의 대괄호 상수 표현식을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="26c32b01062e2317d553f15f1ba72bc158531ca8" translate="yes" xml:space="preserve">
          <source>Array initialization</source>
          <target state="translated">배열 초기화</target>
        </trans-unit>
        <trans-unit id="bfd2acbfa3c1379c40dc654a37044a389ab75f2a" translate="yes" xml:space="preserve">
          <source>Array is a type consisting of a contiguously allocated nonempty sequence of objects with a particular</source>
          <target state="translated">배열은 연속적으로 할당 된 비어 있지 않은 일련의 객체로 구성된 유형입니다.</target>
        </trans-unit>
        <trans-unit id="d09c1ccc6ebe2f642530d449ea6ccaeedb110eac" translate="yes" xml:space="preserve">
          <source>Array subscripting</source>
          <target state="translated">배열 첨자</target>
        </trans-unit>
        <trans-unit id="66b8cc3bf902fd9199bad14788d8e22184391a03" translate="yes" xml:space="preserve">
          <source>Array to pointer conversion</source>
          <target state="translated">배열에서 포인터로의 변환</target>
        </trans-unit>
        <trans-unit id="6a7e5d35200e14f310ad5bf8188982d14b575993" translate="yes" xml:space="preserve">
          <source>Arrays of constant known size</source>
          <target state="translated">알려진 일정한 크기의 배열</target>
        </trans-unit>
        <trans-unit id="8adb4effb7772ea8daa524a9b231c7b9d3f96d17" translate="yes" xml:space="preserve">
          <source>Arrays of constant known size can use &lt;a href=&quot;array_initialization&quot;&gt;array initializers&lt;/a&gt; to provide their initial values:</source>
          <target state="translated">알려진 일정한 크기의 배열은 &lt;a href=&quot;array_initialization&quot;&gt;배열 이니셜 라이저&lt;/a&gt; 를 사용하여 초기 값을 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c16aa1d8479c8c45ec23435b290a59e102e675bf" translate="yes" xml:space="preserve">
          <source>Arrays of known size and arrays of unknown size may be initialized, but not VLAs.(since C99).</source>
          <target state="translated">알려진 크기의 배열과 알 수없는 크기의 배열은 초기화 될 수 있지만 VLA는 초기화되지 않을 수 있습니다 (C99 이후).</target>
        </trans-unit>
        <trans-unit id="b3b90eb627e1832afbdc43f763aa56429f97f87e" translate="yes" xml:space="preserve">
          <source>Arrays of unknown size</source>
          <target state="translated">알 수없는 크기의 배열</target>
        </trans-unit>
        <trans-unit id="52d93df12c32edd74ceb73ae81bde3e78921ac55" translate="yes" xml:space="preserve">
          <source>As a special case, expressions of type &lt;code&gt;void&lt;/code&gt; are assumed to be non-lvalue object expressions that yield a value which has no representation and requires no storage.</source>
          <target state="translated">특수한 경우, &lt;code&gt;void&lt;/code&gt; 유형의 표현식은 표현이없고 저장이 필요없는 값을 생성하는 lvalue 이외의 객체 표현식으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="44cd20de173d4164462fd0aaa64643a2d830c5e9" translate="yes" xml:space="preserve">
          <source>As a special case, the scope of a &lt;a href=&quot;compatible_type&quot;&gt;type name&lt;/a&gt; that is not a declaration of an identifier is considered to begin just after the place within the type name where the identifier would appear were it not omitted.</source>
          <target state="translated">특별한 경우로, 식별자의 선언이 아닌 &lt;a href=&quot;compatible_type&quot;&gt;타입 이름&lt;/a&gt; 의 범위 는 식별자가 나타날 타입 이름 내의 위치 바로 다음부터 시작되는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="8798ee2306ff028fd41c00f00bf32102a67a4ded" translate="yes" xml:space="preserve">
          <source>As all bounds-checked functions, &lt;code&gt;wcstok_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant &lt;code&gt;1&lt;/code&gt; before including &lt;code&gt;wchar.h&lt;/code&gt;.</source>
          <target state="translated">모든 경계 점검 함수로서, &lt;code&gt;wcstok_s&lt;/code&gt; 는 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 이 구현에 의해 정의되고 사용자가 &lt;code&gt;wchar.h&lt;/code&gt; 를 포함하기 전에 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 을 정수 상수 &lt;code&gt;1&lt;/code&gt; 로 정의한 경우에만 사용 가능하도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="70096e3d69911704a0669dccced895bd18198eb0" translate="yes" xml:space="preserve">
          <source>As all bounds-checked functions, &lt;code&gt;wscanf_s&lt;/code&gt;, &lt;code&gt;fwscanf_s&lt;/code&gt;, and &lt;code&gt;swscanf_s&lt;/code&gt; are only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant &lt;code&gt;1&lt;/code&gt; before including &lt;code&gt;&amp;lt;wchar.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">모든 바운드 검사 기능인 &lt;code&gt;wscanf_s&lt;/code&gt; , &lt;code&gt;fwscanf_s&lt;/code&gt; 및 &lt;code&gt;swscanf_s&lt;/code&gt; 는 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 이 구현에 의해 정의되고 사용자가 &lt;code&gt;&amp;lt;wchar.h&amp;gt;&lt;/code&gt; 를 포함하기 전에 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 을 정수 상수 &lt;code&gt;1&lt;/code&gt; 로 정의한 경우에만 사용 가능하도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="4a59d494eef6850f05e5c90b41b98a771ff1630a" translate="yes" xml:space="preserve">
          <source>As always, the result of a floating-point operator may have greater range and precision than is indicated by its type (see &lt;code&gt;&lt;a href=&quot;../types/limits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">항상 그렇듯이 부동 소수점 연산자의 결과는 유형으로 표시되는 것보다 더 큰 범위와 정밀도를 가질 수 있습니다 ( &lt;code&gt;&lt;a href=&quot;../types/limits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="49ef5aefbc07c5fe187539b0875fc885f8b4e782" translate="yes" xml:space="preserve">
          <source>As an example of the &quot;supported by the implementation&quot; requirement, POSIX function &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_memalign.html&quot;&gt;posix_memalign&lt;/a&gt; accepts any &lt;code&gt;alignment&lt;/code&gt; that is a power of two and a multiple of &lt;code&gt;sizeof(void *)&lt;/code&gt;, and POSIX-based implementations of &lt;code&gt;aligned_alloc&lt;/code&gt; inherit this requirements.</source>
          <target state="translated">은 &quot;구현에 의해 지원되는&quot;요구의 예로서, POSIX 함수 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_memalign.html&quot;&gt;posix_memalign는&lt;/a&gt; 모든 허용 &lt;code&gt;alignment&lt;/code&gt; 2의 제곱과의 배수 &lt;code&gt;sizeof(void *)&lt;/code&gt; , 그리고 POSIX 기반 구현 &lt;code&gt;aligned_alloc&lt;/code&gt; 이 요구 상속.</target>
        </trans-unit>
        <trans-unit id="99f5ca70997618b72580ada00f15b0f1727adfd5" translate="yes" xml:space="preserve">
          <source>As corrected by the post-C11 DR 468, &lt;code&gt;strncpy_s&lt;/code&gt;, unlike &lt;code&gt;&lt;a href=&quot;strcpy&quot;&gt;strcpy_s&lt;/a&gt;&lt;/code&gt;, is only allowed to clobber the remainder of the destination array if an error occurs.</source>
          <target state="translated">post-C11 DR 468에 의해 수정 된 &lt;code&gt;&lt;a href=&quot;strcpy&quot;&gt;strcpy_s&lt;/a&gt;&lt;/code&gt; 는 strcpy_s 와 달리 오류가 발생할 경우 대상 배열의 나머지 부분 만 &lt;code&gt;strncpy_s&lt;/code&gt; 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e771c5a735f9e7c913c11ab6dfc5e9daf44f9f28" translate="yes" xml:space="preserve">
          <source>As initially published, C11 does not allow alignas specifiers in structure and union members; this was corrected by DR 444.</source>
          <target state="translated">C11은 처음 게시 된대로 구조 및 공용체 멤버에서 alignas 지정자를 허용하지 않습니다. 이것은 DR 444에 의해 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="0f24a8d064b195b6edf9eee27733591a5c27bd20" translate="yes" xml:space="preserve">
          <source>As specified in &lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; may be (but isn't required to be on non-IEEE floating-point platforms) raised by &lt;code&gt;rint&lt;/code&gt; when rounding a non-integer finite value.</source>
          <target state="translated">에 따른다 &lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt; , &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; 가 될 수있다 (그러나 비 IEEE 부동 소수점 플랫폼에있을 필요는 없다)에 의해 발생 &lt;code&gt;rint&lt;/code&gt; 정수가 아닌 유한 한 값을 반올림 때.</target>
        </trans-unit>
        <trans-unit id="a33a2a6a1dbc72097e5ee50f7c236b5234435165" translate="yes" xml:space="preserve">
          <source>As well as the prefix form:</source>
          <target state="translated">접두사 형식뿐만 아니라</target>
        </trans-unit>
        <trans-unit id="cf5967493a41546d32b0ca92f03818e35ddbf753" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;function_declaration&quot;&gt;function declarations&lt;/a&gt;, if the return type would be cvr-qualified, it is adjusted to its unqualified version for the purpose of constructing the function type.</source>
          <target state="translated">&lt;a href=&quot;function_declaration&quot;&gt;함수 선언&lt;/a&gt; 과 마찬가지로 반환 유형이 cvr로 규정 된 경우 함수 유형을 구성하기 위해 규정되지 않은 버전으로 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="3a13d3a1b158eacc4ae78930d86fe860ceec91a1" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;function_declaration&quot;&gt;function declarations&lt;/a&gt;, the return type of the function, determined by the type specifier in specifiers-and-qualifiers and possibly modified by the declarator as usual in &lt;a href=&quot;declarations&quot;&gt;declarations&lt;/a&gt;, must be a complete non-array object type or the type &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">와 같이 &lt;a href=&quot;function_declaration&quot;&gt;함수 선언&lt;/a&gt; 함수의 리턴 타입이 지정자 앤 예선 타입 지시자에 의해 결정된 가능성이 평소와 선언자 의해 수정 &lt;a href=&quot;declarations&quot;&gt;선언&lt;/a&gt; 완전한 배열이 아닌 개체 유형 또는 유형이어야 &lt;code&gt;void&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="931b6f6952da18dd1c23c7c06b62eafdf4a75919" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;function_declaration&quot;&gt;function declarations&lt;/a&gt;, the types of the parameters are adjusted from functions to pointers and from arrays to pointers for the purpose of constructing the function type and the top-level cvr-qualifiers of all parameter types are ignored for the purpose of determining &lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;compatible function type&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;function_declaration&quot;&gt;함수 선언&lt;/a&gt; 과 마찬가지로 함수 유형을 구성하기 위해 매개 변수 유형이 함수에서 포인터로, 배열에서 포인터로 조정되며 &lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;호환 가능한 함수&lt;/a&gt; 를 결정하기 위해 모든 매개 변수 유형의 최상위 cvr 한정자가 무시됩니다. 을 입력하십시오 .</target>
        </trans-unit>
        <trans-unit id="79ccd71b90196278405a314330eeaa2631ba1185" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;struct&quot;&gt;struct&lt;/a&gt; or &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt;, a declaration that introduced an enumerated type and one or more enumeration constants may also declare one or more objects of that type or type derived from it.</source>
          <target state="translated">&lt;a href=&quot;struct&quot;&gt;struct&lt;/a&gt; 또는 &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt; 과 마찬가지로 열거 유형과 하나 이상의 열거 상수를 도입 한 선언에서도 해당 유형 또는 유형에서 파생 된 하나 이상의 객체를 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="437ed49708f86a6f35c86cdb9207ea49adcc2e2c" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;asctime_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;time.h&lt;/code&gt;.</source>
          <target state="translated">모든 경계 검사 함수와 &lt;code&gt;asctime_s&lt;/code&gt; 는 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 이 구현에 의해 정의되고 사용자가 &lt;code&gt;time.h&lt;/code&gt; 를 포함하기 전에 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 을 정수 상수 1 로 정의한 경우에만 사용 가능하도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="7466d344d3f71775f4c9996f0aefd336b865cd97" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;bsearch_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdlib.h&lt;/code&gt;.</source>
          <target state="translated">모든 경계 검사 함수와 &lt;code&gt;bsearch_s&lt;/code&gt; 는 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 이 구현에 의해 정의되고 사용자가 &lt;code&gt;stdlib.h&lt;/code&gt; 를 포함하기 전에 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 을 정수 상수 1 로 정의한 경우에만 사용 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="4fc791ea25b5ba32faad862e9c23a50a7c997e69" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;ctime_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;time.h&lt;/code&gt;.</source>
          <target state="translated">모든 경계 검사 함수와 &lt;code&gt;ctime_s&lt;/code&gt; 는 구현에 의해 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 이 정의되고 사용자가 &lt;code&gt;time.h&lt;/code&gt; 를 포함하기 전에 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 을 정수 상수 1 로 정의한 경우에만 사용 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="68c3240515eb99689624b2605905ba8bc7986315" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;fopen_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdio.h&lt;/code&gt;.</source>
          <target state="translated">모든 경계 검사 함수와 &lt;code&gt;fopen_s&lt;/code&gt; 는 구현에 의해 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 이 정의되고 사용자가 &lt;code&gt;stdio.h&lt;/code&gt; 를 포함하기 전에 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 을 정수 상수 1 로 정의한 경우에만 사용 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="5a2b6b4c82c23c016f116aa791f39d37f445e46a" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;freopen_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdio.h&lt;/code&gt;.</source>
          <target state="translated">모든 경계 검사 기능과 &lt;code&gt;freopen_s&lt;/code&gt; 는 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 이 구현에 의해 정의되고 사용자가 &lt;code&gt;stdio.h&lt;/code&gt; 를 포함하기 전에 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 을 정수 상수 1 로 정의한 경우에만 사용 가능하도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="36d2edb3de2b41575170995e94495de51af70c2c" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;getenv_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdlib.h&lt;/code&gt;.</source>
          <target state="translated">모든 범위 검사 함수와 마찬가지로, &lt;code&gt;getenv_s&lt;/code&gt; 는 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 이 구현에 의해 정의되고 사용자가 &lt;code&gt;stdlib.h&lt;/code&gt; 를 포함하기 전에 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 을 정수 상수 1 로 정의한 경우에만 사용 가능하도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="91dfec9c8791e4208d084cc59b7b36777275f675" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;gets_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdio.h&lt;/code&gt;.</source>
          <target state="translated">모든 경계 검사 함수와 마찬가지로, &lt;code&gt;gets_s&lt;/code&gt; 이 구현에 의해 정의되고 사용자가 &lt;code&gt;stdio.h&lt;/code&gt; 를 포함하기 전에 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 을 정수 상수 1 로 정의한 경우에만 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b587147fa6c4a23c653092469c541f0564737fd7" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;gmtime_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;time.h&lt;/code&gt;.</source>
          <target state="translated">모든 경계 검사 함수와 &lt;code&gt;gmtime_s&lt;/code&gt; 는 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 이 구현에 의해 정의되고 사용자가 &lt;code&gt;time.h&lt;/code&gt; 를 포함하기 전에 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 을 정수 상수 1 로 정의한 경우에만 사용 가능하도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="1a3089753e59df348badd488426b5efcd28f163e" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;localtime_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;time.h&lt;/code&gt;.</source>
          <target state="translated">모든 경계 검사 함수와 마찬가지로 &lt;code&gt;localtime_s&lt;/code&gt; 는 구현에 의해 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 이 정의되고 사용자가 &lt;code&gt;time.h&lt;/code&gt; 를 포함하기 전에 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 을 정수 상수 1 로 정의한 경우에만 사용 가능하도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="6ddab0b0f139e7b59eefb4230266da1ed9d87056" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;mbsrtowcs_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;wchar.h&lt;/code&gt;.</source>
          <target state="translated">모든 경계 점검 함수와 &lt;code&gt;mbsrtowcs_s&lt;/code&gt; 는 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 이 구현에 의해 정의되고 사용자가 &lt;code&gt;wchar.h&lt;/code&gt; 를 포함하기 전에 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 을 정수 상수 1 로 정의한 경우에만 사용 가능하도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="37428501d369894f1c0e8fe3487182869130402b" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;mbstowcs_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdlib.h&lt;/code&gt;.</source>
          <target state="translated">모든 경계 검사 함수와 마찬가지로 &lt;code&gt;mbstowcs_s&lt;/code&gt; 는 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 이 구현에 의해 정의되고 사용자가 &lt;code&gt;stdlib.h&lt;/code&gt; 를 포함하기 전에 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 을 정수 상수 1 로 정의한 경우에만 사용 가능하도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="484ec756538b4c4710eb92aa17bd6c656a7c5da9" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;printf_s&lt;/code&gt; , &lt;code&gt;fprintf_s&lt;/code&gt;, &lt;code&gt;sprintf_s&lt;/code&gt;, and &lt;code&gt;snprintf_s&lt;/code&gt; are only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdio.h&lt;/code&gt;.</source>
          <target state="translated">모든 경계 검사 함수와 마찬가지로 &lt;code&gt;printf_s&lt;/code&gt; , &lt;code&gt;fprintf_s&lt;/code&gt; , &lt;code&gt;sprintf_s&lt;/code&gt; 및 &lt;code&gt;snprintf_s&lt;/code&gt; 는 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 이 구현에 의해 정의되고 사용자가 &lt;code&gt;stdio.h&lt;/code&gt; 를 포함하기 전에 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 을 정수 상수 1 로 정의한 경우에만 사용 가능하도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="abea34893c8e6d78d3a467d161201fce0dcd31ca" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;qsort_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdlib.h&lt;/code&gt;.</source>
          <target state="translated">모든 경계 검사 기능과 &lt;code&gt;qsort_s&lt;/code&gt; 는 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 이 구현에 의해 정의되고 사용자가 &lt;code&gt;stdlib.h&lt;/code&gt; 를 포함하기 전에 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 을 정수 상수 1 로 정의한 경우에만 사용 가능하도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="cfaac44b328f0d9ecaecc16c135720ab79c8b975" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;scanf_s&lt;/code&gt; , &lt;code&gt;fscanf_s&lt;/code&gt;, and &lt;code&gt;sscanf_s&lt;/code&gt; are only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdio.h&lt;/code&gt;.</source>
          <target state="translated">모든 경계 검사 기능과 &lt;code&gt;scanf_s&lt;/code&gt; , &lt;code&gt;fscanf_s&lt;/code&gt; 및 &lt;code&gt;sscanf_s&lt;/code&gt; 는 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 이 구현에 의해 정의되고 사용자가 &lt;code&gt;stdio.h&lt;/code&gt; 를 포함하기 전에 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 을 정수 상수 1 로 정의한 경우에만 사용 가능하도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="d7a73a8def345c13bbf6d30289221e860585c258" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;tmpnam_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdio.h&lt;/code&gt;.</source>
          <target state="translated">모든 경계 검사 함수와 &lt;code&gt;tmpnam_s&lt;/code&gt; 는 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 이 구현에 의해 정의되고 사용자가 &lt;code&gt;stdio.h&lt;/code&gt; 를 포함하기 전에 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 을 정수 상수 1 로 정의한 경우에만 사용 가능하도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="918e04c9c4c5035b488768dc881c956dc6d6fce9" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;vprintf_s&lt;/code&gt; , &lt;code&gt;vfprintf_s&lt;/code&gt;, &lt;code&gt;vsprintf_s&lt;/code&gt;, and &lt;code&gt;vsnprintf_s&lt;/code&gt; are only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdio.h&lt;/code&gt;.</source>
          <target state="translated">모든 경계 검사 함수와 마찬가지로, &lt;code&gt;vprintf_s&lt;/code&gt; , &lt;code&gt;vfprintf_s&lt;/code&gt; , &lt;code&gt;vsprintf_s&lt;/code&gt; 및 &lt;code&gt;vsnprintf_s&lt;/code&gt; 는 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 이 구현에 의해 정의되고 사용자가 &lt;code&gt;stdio.h&lt;/code&gt; 를 포함하기 전에 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 을 정수 상수 1 로 정의한 경우에만 사용 가능하도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="073801d18c716edf19a5d56736c3e0cfe5310c1a" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;vscanf_s&lt;/code&gt; , &lt;code&gt;vfscanf_s&lt;/code&gt;, and &lt;code&gt;vsscanf_s&lt;/code&gt; are only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdio.h&lt;/code&gt;.</source>
          <target state="translated">모든 경계 검사 함수와 마찬가지로, &lt;code&gt;vscanf_s&lt;/code&gt; , &lt;code&gt;vfscanf_s&lt;/code&gt; 및 &lt;code&gt;vsscanf_s&lt;/code&gt; 는 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 이 구현에 의해 정의되고 사용자가 &lt;code&gt;stdio.h&lt;/code&gt; 를 포함하기 전에 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 을 정수 상수 1 로 정의한 경우에만 사용 가능하도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="859462c768d6d2e1180f63c1e98789651af7d933" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;vwscanf_s&lt;/code&gt; , &lt;code&gt;vfwscanf_s&lt;/code&gt;, and &lt;code&gt;vswscanf_s&lt;/code&gt; are only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdio.h&lt;/code&gt;.</source>
          <target state="translated">모든 경계 검사 기능과 &lt;code&gt;vwscanf_s&lt;/code&gt; , &lt;code&gt;vfwscanf_s&lt;/code&gt; 및 &lt;code&gt;vswscanf_s&lt;/code&gt; 는 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 이 구현에 의해 정의되고 사용자가 &lt;code&gt;stdio.h&lt;/code&gt; 를 포함하기 전에 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 을 정수 상수 1 로 정의한 경우에만 사용 가능하도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="f4160e65b4073508722290e386b7ac737418adee" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;wcrtomb_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;wchar.h&lt;/code&gt;.</source>
          <target state="translated">모든 경계 점검 함수와 &lt;code&gt;wcrtomb_s&lt;/code&gt; 는 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 이 구현에 의해 정의되고 사용자가 &lt;code&gt;wchar.h&lt;/code&gt; 를 포함하기 전에 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 을 정수 상수 1 로 정의한 경우에만 사용 가능하도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="8852dd0c727422973b312a38cfafc412436b854a" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;wcscat_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;wchar.h&lt;/code&gt;.</source>
          <target state="translated">모든 경계 점검 함수와 &lt;code&gt;wcscat_s&lt;/code&gt; 는 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 이 구현에 의해 정의되고 사용자가 &lt;code&gt;wchar.h&lt;/code&gt; 를 포함하기 전에 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 을 정수 상수 1 로 정의한 경우에만 사용 가능하도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="94da776eb17b12e2e76b744201263fafce234bf0" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;wcscpy_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;wchar.h&lt;/code&gt;.</source>
          <target state="translated">모든 경계 점검 기능과 &lt;code&gt;wcscpy_s&lt;/code&gt; 는 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 이 구현에 의해 정의되고 사용자가 &lt;code&gt;wchar.h&lt;/code&gt; 를 포함하기 전에 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 을 정수 상수 1 로 정의한 경우에만 사용 가능하도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="602e2723ae28915ea4b6c0d0d485677759ec2846" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;wcsncat_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;wchar.h&lt;/code&gt;.</source>
          <target state="translated">모든 경계 점검 기능과 &lt;code&gt;wcsncat_s&lt;/code&gt; 는 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 이 구현에 의해 정의되고 사용자가 &lt;code&gt;wchar.h&lt;/code&gt; 를 포함하기 전에 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 을 정수 상수 1 로 정의한 경우에만 사용 가능하도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="eb04e05d2e03a1529216895dcf8b417f85fadc7d" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;wcsncpy_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;wchar.h&lt;/code&gt;.</source>
          <target state="translated">모든 경계 점검 기능과 &lt;code&gt;wcsncpy_s&lt;/code&gt; 는 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 이 구현에 의해 정의되고 사용자가 &lt;code&gt;wchar.h&lt;/code&gt; 를 포함하기 전에 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 을 정수 상수 1 로 정의한 경우에만 사용 가능하도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="59166256df368db6ea11d9dcca1c76c58f684e8f" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;wcsrtombs_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant &lt;code&gt;1&lt;/code&gt; before including &lt;code&gt;wchar.h&lt;/code&gt;.</source>
          <target state="translated">모든 경계 점검 기능과 마찬가지로 &lt;code&gt;wcsrtombs_s&lt;/code&gt; 는 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 이 구현에 의해 정의되고 사용자가 &lt;code&gt;wchar.h&lt;/code&gt; 를 포함하기 전에 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 을 정수 상수 &lt;code&gt;1&lt;/code&gt; 로 정의한 경우에만 사용 가능하도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="10f1e3f209cb87b74ba077e0b12ebc217f85756f" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;wcstombs_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdlib.h&lt;/code&gt;.</source>
          <target state="translated">모든 경계 점검 기능과 마찬가지로 &lt;code&gt;wcstombs_s&lt;/code&gt; 는 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 이 구현에 의해 정의되고 사용자가 &lt;code&gt;stdlib.h&lt;/code&gt; 를 포함하기 전에 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 을 정수 상수 1 로 정의한 경우에만 사용 가능하도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="197a0ff717c052db762139e2134727533937a435" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;wctomb_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdlib.h&lt;/code&gt;.</source>
          <target state="translated">모든 경계 점검 기능과 &lt;code&gt;wctomb_s&lt;/code&gt; 는 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 이 구현에 의해 정의되고 사용자가 &lt;code&gt;stdlib.h&lt;/code&gt; 를 포함하기 전에 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 을 정수 상수 1 로 정의한 경우에만 사용 가능하도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="8de73d3e3aed35fe5e7155d1d6d37204911c0756" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;wmemcpy_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;wchar.h&lt;/code&gt;.</source>
          <target state="translated">모든 범위 검사 함수와 &lt;code&gt;wmemcpy_s&lt;/code&gt; 는 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 이 구현에 의해 정의되고 사용자가 &lt;code&gt;wchar.h&lt;/code&gt; 를 포함하기 전에 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 을 정수 상수 1 로 정의한 경우에만 사용 가능하도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="78f5af5ac1a7ed15c5c5e17dc8795818a3aa33e2" translate="yes" xml:space="preserve">
          <source>As with all floating-point expressions, the expression &lt;code&gt;(x*y) + z&lt;/code&gt; may be compiled as a fused mutiply-add unless the &lt;a href=&quot;../../preprocessor/impl&quot;&gt;#pragma&lt;/a&gt;&lt;code&gt;STDC FP_CONTRACT&lt;/code&gt; is off.</source>
          <target state="translated">모든 부동 소수점 식과 마찬가지로 &lt;a href=&quot;../../preprocessor/impl&quot;&gt;#pragma &lt;/a&gt; &lt;code&gt;STDC FP_CONTRACT&lt;/code&gt; 가 해제되어 있지 않으면 식 &lt;code&gt;(x*y) + z&lt;/code&gt; 가 융합 된 추가로 컴파일 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="325da3015b4ad8b300bd2748d36c41a38bb66f31" translate="yes" xml:space="preserve">
          <source>As with all other &lt;a href=&quot;initialization&quot;&gt;initialization&lt;/a&gt;, every expression in the initializer list must be a &lt;a href=&quot;constant_expression&quot;&gt;constant expression&lt;/a&gt; when initializing aggregates of static or thread-local(since C11)&lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt;:</source>
          <target state="translated">다른 모든 &lt;a href=&quot;initialization&quot;&gt;초기화&lt;/a&gt; 와 마찬가지로 초기화 목록의 모든 표현식 은 정적 또는 스레드 로컬 (C11 이후) &lt;a href=&quot;storage_duration&quot;&gt;저장 기간의&lt;/a&gt; 집계를 초기화 할 때 &lt;a href=&quot;constant_expression&quot;&gt;상수 표현식&lt;/a&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="c4829062a1808034ce1d2399df876ce3ea658359" translate="yes" xml:space="preserve">
          <source>As with all other &lt;a href=&quot;initialization&quot;&gt;initialization&lt;/a&gt;, every expression in the initializer list must be a &lt;a href=&quot;constant_expression&quot;&gt;constant expression&lt;/a&gt; when initializing arrays of static or thread-local &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt;:</source>
          <target state="translated">다른 모든 &lt;a href=&quot;initialization&quot;&gt;초기화&lt;/a&gt; 와 마찬가지로 초기화 목록의 모든 표현식 은 정적 또는 스레드 로컬 &lt;a href=&quot;storage_duration&quot;&gt;스토리지 기간의&lt;/a&gt; 배열을 초기화 할 때 &lt;a href=&quot;constant_expression&quot;&gt;상수 표현식&lt;/a&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="3d74ed1ea6e40942992fbfb06d0ee0b9763fc886" translate="yes" xml:space="preserve">
          <source>As with all other initializations, expression must be a &lt;a href=&quot;constant_expression&quot;&gt;constant expression&lt;/a&gt; when initializing objects of static or thread-local &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt;.</source>
          <target state="translated">다른 모든 초기화와 마찬가지로 정적 또는 스레드 로컬 &lt;a href=&quot;storage_duration&quot;&gt;저장 기간의&lt;/a&gt; 객체를 초기화 할 때 &lt;a href=&quot;constant_expression&quot;&gt;expression&lt;/a&gt; 은 상수 표현식이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="e555bf0a6d0cba4d524cadbdf2533b3abff34b33" translate="yes" xml:space="preserve">
          <source>As with all other selection and iteration statements, the do-while statement establishes &lt;a href=&quot;scope&quot;&gt;block scope&lt;/a&gt;: any identifier introduced in the expression goes out of scope after the statement.</source>
          <target state="translated">다른 모든 선택 및 반복문과 마찬가지로 do-while 문은 &lt;a href=&quot;scope&quot;&gt;블록 범위를&lt;/a&gt; 설정 합니다. 표현식에 도입 된 식별자는 명령문 다음에 범위를 벗어납니다.</target>
        </trans-unit>
        <trans-unit id="f545ee7b22d4db083dbeb46229553bde0b39d74f" translate="yes" xml:space="preserve">
          <source>As with all other selection and iteration statements, the entire if-statement has its own block scope:</source>
          <target state="translated">다른 모든 선택 및 반복문과 마찬가지로 전체 if 문에는 자체 블록 범위가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7bfa427f06539b7b10237b67a6680af8d74b410" translate="yes" xml:space="preserve">
          <source>As with all other selection and iteration statements, the for statement establishes &lt;a href=&quot;scope&quot;&gt;block scope&lt;/a&gt;: any identifier introduced in the init_clause, cond_expression, or iteration_expression goes out of scope after the loop_statement.</source>
          <target state="translated">다른 모든 선택 및 반복 문과 마찬가지로 for 문은 &lt;a href=&quot;scope&quot;&gt;블록 범위를&lt;/a&gt; 설정 합니다. init_clause, cond_expression 또는 iteration_expression에 도입 된 식별자는 loop_statement 이후 범위를 벗어납니다.</target>
        </trans-unit>
        <trans-unit id="7c3290e5179ae7df55fad67d5932bc9569640162" translate="yes" xml:space="preserve">
          <source>As with all other selection and iteration statements, the switch statement establishes &lt;a href=&quot;scope&quot;&gt;block scope&lt;/a&gt;: any identifier introduced in the expression goes out of scope after the statement.</source>
          <target state="translated">다른 모든 선택 및 반복문과 마찬가지로 switch 문은 &lt;a href=&quot;scope&quot;&gt;블록 범위를&lt;/a&gt; 설정 합니다. 표현식에 도입 된 식별자는 명령문 다음에 범위를 벗어납니다.</target>
        </trans-unit>
        <trans-unit id="bf1b641a79fe3bd85fdc3087658eae1ee87d7b5c" translate="yes" xml:space="preserve">
          <source>As with all other selection and iteration statements, the while statement establishes &lt;a href=&quot;scope&quot;&gt;block scope&lt;/a&gt;: any identifier introduced in the expression goes out of scope after the statement.</source>
          <target state="translated">다른 모든 선택 및 반복문과 마찬가지로 while 문은 &lt;a href=&quot;scope&quot;&gt;블록 범위를&lt;/a&gt; 설정 합니다. 표현식에 도입 된 식별자는 명령문 다음에 범위를 벗어납니다.</target>
        </trans-unit>
        <trans-unit id="a3219f037624b3a59d32f19972411fe565f772da" translate="yes" xml:space="preserve">
          <source>As with any &lt;a href=&quot;../fenv&quot;&gt;floating-point environment&lt;/a&gt; functionality, rounding is only guaranteed if &lt;code&gt;#pragma STDC FENV_ACCESS ON&lt;/code&gt; is set.</source>
          <target state="translated">모든 &lt;a href=&quot;../fenv&quot;&gt;부동 소수점 환경&lt;/a&gt; 기능 과 마찬가지로 반올림은 &lt;code&gt;#pragma STDC FENV_ACCESS ON&lt;/code&gt; 이 설정된 경우에만 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="6c92fb474ab2bb51f893b5f74babbd3f0c831976" translate="yes" xml:space="preserve">
          <source>As with any pure imaginary number support in C, this macro is only defined if the imaginary numbers are supported.</source>
          <target state="translated">C에서 순수한 허수 지원과 마찬가지로이 매크로는 허수가 지원되는 경우에만 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="79bc029ba48a0820eb9af6de0ebd1ea7e6ea9789" translate="yes" xml:space="preserve">
          <source>As-if rule</source>
          <target state="translated">그대로 규칙</target>
        </trans-unit>
        <trans-unit id="49bf55dc112eb3597726ba8ecf785a4fae4cbce0" translate="yes" xml:space="preserve">
          <source>Assertions</source>
          <target state="translated">Assertions</target>
        </trans-unit>
        <trans-unit id="e55df441e8955746182110c3946288f381520e83" translate="yes" xml:space="preserve">
          <source>Assignment</source>
          <target state="translated">Assignment</target>
        </trans-unit>
        <trans-unit id="18d0c3fe9dc939e8b90006e867d3849538ad2f89" translate="yes" xml:space="preserve">
          <source>Assignment also returns the same value as what was stored in &lt;code&gt;lhs&lt;/code&gt; (so that expressions such as &lt;code&gt;a = b = c&lt;/code&gt; are possible). The &lt;a href=&quot;value_category&quot;&gt;value category&lt;/a&gt; of the assignment operator is non-lvalue (so that expressions such as &lt;code&gt;(a=b)=c&lt;/code&gt; are invalid).</source>
          <target state="translated">대입은 &lt;code&gt;lhs&lt;/code&gt; 에 저장된 것과 동일한 값을 반환 하므로 &lt;code&gt;a = b = c&lt;/code&gt; 와 같은식이 가능합니다. 대입 연산자 의 &lt;a href=&quot;value_category&quot;&gt;값 범주&lt;/a&gt; 는 lvalue가 아니므로 &lt;code&gt;(a=b)=c&lt;/code&gt; 와 같은 표현식 이 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a5b50d74ba4665e5019dfafa81c1cee577573309" translate="yes" xml:space="preserve">
          <source>Assignment and compound assignment operators are binary operators that modify the variable to their left using the value to their right.</source>
          <target state="translated">대입 및 복합 대입 연산자는 오른쪽 값을 사용하여 변수를 왼쪽으로 수정하는 이진 연산자입니다.</target>
        </trans-unit>
        <trans-unit id="fc3a7306a4dbd9aaf7c8e7df511d8c165f52fd3d" translate="yes" xml:space="preserve">
          <source>Assignment by bitwise AND, XOR, and OR</source>
          <target state="translated">비트 AND, XOR 및 OR로 지정</target>
        </trans-unit>
        <trans-unit id="e5c86c40b5df7019866344018e45e57f50e118be" translate="yes" xml:space="preserve">
          <source>Assignment by bitwise left shift and right shift</source>
          <target state="translated">비트 단위 왼쪽 시프트 및 오른쪽 시프트로 할당</target>
        </trans-unit>
        <trans-unit id="bea5586663c5a711fbc4d3e72c59f91bc6283914" translate="yes" xml:space="preserve">
          <source>Assignment by product, quotient, and remainder</source>
          <target state="translated">제품, 몫 및 나머지로 할당</target>
        </trans-unit>
        <trans-unit id="bc417bc1271d1dd6a46931fd1dfa61093c858524" translate="yes" xml:space="preserve">
          <source>Assignment by sum and difference</source>
          <target state="translated">합계와 차이에 의한 할당</target>
        </trans-unit>
        <trans-unit id="171497ff060aefbcfe056d741c42de9e42533588" translate="yes" xml:space="preserve">
          <source>Assignment from one restricted pointer to another is undefined behavior, except when assigning from a pointer to an object in some outer block to a pointer in some inner block (including using a restricted pointer argument when calling a function with a restricted pointer parameter) or when returning from a function (and otherwise when the block of the from-pointer ended):</source>
          <target state="translated">하나의 제한된 포인터에서 다른 포인터로의 할당은 정의되지 않은 동작입니다. 일부 외부 블록의 객체에 대한 포인터에서 일부 내부 블록의 포인터에 할당 할 때 (제한된 포인터 매개 변수로 함수를 호출 할 때 제한된 포인터 인수 사용 포함) 함수에서 반환 (그렇지 않으면 시작 포인터의 블록이 종료 된 경우) :</target>
        </trans-unit>
        <trans-unit id="aa098245c1ec6b3b4a9cec4ec49f68bc2b3dc905" translate="yes" xml:space="preserve">
          <source>Assignment operators</source>
          <target state="translated">할당 연산자</target>
        </trans-unit>
        <trans-unit id="83ac53a63cca418f24852c024f95f35335391074" translate="yes" xml:space="preserve">
          <source>Assignment operators' left operands must be unary (level-2 non-cast) expressions. This rule grammatically forbids some expressions that would be semantically invalid anyway. Many compilers ignore this rule and detect the invalidity semantically. For example, &lt;code&gt;e = a &amp;lt; d ? a++ : a = d&lt;/code&gt; is an expression that cannot be parsed because of this rule. However, many compilers ignore this rule and parse it as &lt;code&gt;e = ( ((a &amp;lt; d) ? (a++) : a) = d )&lt;/code&gt;, and then give an error because it is semantically invalid.</source>
          <target state="translated">대입 연산자의 왼쪽 피연산자는 단항 (레벨 2 비 캐스트) 식이어야합니다. 이 규칙은 어쨌든 의미 상 유효하지 않은 일부 표현식을 문법적으로 금지합니다. 많은 컴파일러가이 규칙을 무시하고 의미를 무효로 감지합니다. 예를 들어, &lt;code&gt;e = a &amp;lt; d ? a++ : a = d&lt;/code&gt; 는이 규칙으로 인해 구문 분석 할 수없는 표현식입니다. 그러나 많은 컴파일러는이 규칙을 무시하고 &lt;code&gt;e = ( ((a &amp;lt; d) ? (a++) : a) = d )&lt;/code&gt; 로 구문 분석 한 다음 의미 상 유효하지 않기 때문에 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="77dd21d24ad4cb9c785289515583c49d1df5693e" translate="yes" xml:space="preserve">
          <source>Assignment performs &lt;a href=&quot;conversion&quot;&gt;implicit conversion&lt;/a&gt; from the value of rhs to the type of rhs and then replaces the value in the object designated by lhs with the converted value of rhs.</source>
          <target state="translated">할당은 rhs 값에서 rhs 유형으로의 &lt;a href=&quot;conversion&quot;&gt;암시 적 변환&lt;/a&gt; 을 수행 한 다음 lhs로 지정된 객체의 값을 변환 된 rhs 값으로 대체합니다.</target>
        </trans-unit>
        <trans-unit id="269f718e42738bd37518148d39e5b7196b62a1ed" translate="yes" xml:space="preserve">
          <source>Assignment strips extra range and precision from floating-point expressions (see &lt;code&gt;&lt;a href=&quot;../types/limits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">할당은 부동 소수점 식에서 추가 범위와 정밀도를 제거합니다 ( &lt;code&gt;&lt;a href=&quot;../types/limits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="d20b5a26a1cdf631954b50a5206246dff93d9c8a" translate="yes" xml:space="preserve">
          <source>Associativity</source>
          <target state="translated">Associativity</target>
        </trans-unit>
        <trans-unit id="f4d8655658394fa66d40386dc42cf98fdf4372dd" translate="yes" xml:space="preserve">
          <source>Associativity specification is redundant for unary operators and is only shown for completeness: unary prefix operators always associate right-to-left (&lt;code&gt;sizeof ++*p&lt;/code&gt; is &lt;code&gt;sizeof(++(*p))&lt;/code&gt;) and unary postfix operators always associate left-to-right (&lt;code&gt;a[1][2]++&lt;/code&gt; is &lt;code&gt;((a[1])[2])++&lt;/code&gt;). Note that the associativity is meaningful for member access operators, even though they are grouped with unary postfix operators: &lt;code&gt;a.b++&lt;/code&gt; is parsed &lt;code&gt;(a.b)++&lt;/code&gt; and not &lt;code&gt;a.(b++)&lt;/code&gt;.</source>
          <target state="translated">연관성 사양은 단항 연산자에 대해 중복되며 완전성을 위해 표시됩니다. 단항 접두사 연산자는 항상 오른쪽에서 왼쪽으로 연결하고 ( &lt;code&gt;sizeof ++*p&lt;/code&gt; is &lt;code&gt;sizeof(++(*p))&lt;/code&gt; ) 단항 접두어 연산자는 항상 왼쪽에서 연결합니다 -right ( &lt;code&gt;a[1][2]++&lt;/code&gt; 는 &lt;code&gt;((a[1])[2])++&lt;/code&gt; )입니다. &lt;code&gt;a.b++&lt;/code&gt; 는 a &lt;code&gt;a.(b++)&lt;/code&gt; 아니라 구문 분석 된 &lt;code&gt;(a.b)++&lt;/code&gt; 이며, 단항 접두사 연산자로 그룹화되어 있어도 멤버 액세스 연산자에는 연관성이 의미가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4154e96428077efddaaf47a2b96af21e7a346bb0" translate="yes" xml:space="preserve">
          <source>At the &lt;a href=&quot;operator_other#Function_call&quot;&gt;function call&lt;/a&gt;, each argument that is a part of the variable argument list undergoes special implicit conversions known as &lt;a href=&quot;conversion#Default_argument_promotions&quot;&gt;default argument promotions&lt;/a&gt;.</source>
          <target state="translated">상기 &lt;a href=&quot;operator_other#Function_call&quot;&gt;함수 호출&lt;/a&gt; , 변수 인수 목록의 일부입니다 각각의 인자로 알려진 특별한 암시 적 변환 거쳐 &lt;a href=&quot;conversion#Default_argument_promotions&quot;&gt;기본 인수 프로모션을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6a4ba3822726fee4dc63d69beec4022ac36809bf" translate="yes" xml:space="preserve">
          <source>At the point of lookup, the name space of an identifier is determined by the manner in which it is used:</source>
          <target state="translated">조회 시점에서 식별자의 네임 스페이스는 사용 방식에 따라 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="78f6940e1dbc39015dcd262184b3438c2502859e" translate="yes" xml:space="preserve">
          <source>At the top level of a &lt;a href=&quot;translation_phases&quot;&gt;translation unit&lt;/a&gt; (that is, a source file with all the #includes after the preprocessor), every C program is a sequence of &lt;a href=&quot;declarations&quot;&gt;declarations&lt;/a&gt;, which declare functions and objects with &lt;a href=&quot;storage_duration&quot;&gt;external linkage&lt;/a&gt;. These declarations are known as</source>
          <target state="translated">&lt;a href=&quot;translation_phases&quot;&gt;변환 단위&lt;/a&gt; (즉, 전 처리기 뒤에 모든 #include가 포함 된 소스 파일) 의 최상위 레벨 에서 모든 C 프로그램은 일련의 &lt;a href=&quot;declarations&quot;&gt;선언으로&lt;/a&gt; , 함수와 객체를 &lt;a href=&quot;storage_duration&quot;&gt;외부 연결로&lt;/a&gt; 선언합니다 . 이러한 선언은</target>
        </trans-unit>
        <trans-unit id="fb34ad6782840b3609292d56d50524837de11852" translate="yes" xml:space="preserve">
          <source>Atomic operations</source>
          <target state="translated">원자력 운영</target>
        </trans-unit>
        <trans-unit id="ec45a74e461d6d1f9a6d6860119c9137a6fed5b2" translate="yes" xml:space="preserve">
          <source>Atomic operations library</source>
          <target state="translated">원자력 운영 라이브러리</target>
        </trans-unit>
        <trans-unit id="ac1cfc02a52dba8b178a48b4597760d28fb77ccd" translate="yes" xml:space="preserve">
          <source>Atomic operations tagged &lt;code&gt;memory_order_relaxed&lt;/code&gt; are not synchronization operations; they do not impose an order among concurrent memory accesses. They only guarantee atomicity and modification order consistency.</source>
          <target state="translated">&lt;code&gt;memory_order_relaxed&lt;/code&gt; 태그가 붙은 원자 작업 은 동기화 작업이 아닙니다. 동시 메모리 액세스간에 순서를 부과하지 않습니다. 원 자성 및 수정 순서 일관성 만 보장합니다.</target>
        </trans-unit>
        <trans-unit id="4f6d4f2c68a571824e3f43d98c75cbda9d541c52" translate="yes" xml:space="preserve">
          <source>Atomic operations tagged &lt;code&gt;memory_order_seq_cst&lt;/code&gt; not only order memory the same way as release/acquire ordering (everything that</source>
          <target state="translated">&lt;code&gt;memory_order_seq_cst&lt;/code&gt; 태그가 지정된 원자 연산 은 릴리스 / 취득 순서와 동일한 방식으로 메모리를 주문할뿐만 아니라</target>
        </trans-unit>
        <trans-unit id="e93772d4bf7c4f3b7583aab6a0265189369c6fdd" translate="yes" xml:space="preserve">
          <source>Atomic properties are only meaningful for &lt;a href=&quot;value_category&quot;&gt;lvalue expressions&lt;/a&gt;. Lvalue-to-rvalue conversion (which models a memory read from an atomic location to a CPU register) strips atomicity along with other qualifiers.</source>
          <target state="translated">원자 속성은 &lt;a href=&quot;value_category&quot;&gt;lvalue 표현식&lt;/a&gt; 에만 의미가 있습니다. Lvalue-to-rvalue 변환 (원자 위치에서 CPU 레지스터로의 메모리 읽기를 모델링)은 다른 규정 자와 함께 원 자성을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="6bd53298c2672a3d3501c1b3d668970f3f55e051" translate="yes" xml:space="preserve">
          <source>Atomic types</source>
          <target state="translated">원자 유형</target>
        </trans-unit>
        <trans-unit id="389fbb07de335e1a903a5217f5d069d302e09807" translate="yes" xml:space="preserve">
          <source>Atomically changes the state of a &lt;code&gt;atomic_flag&lt;/code&gt; pointed to by &lt;code&gt;obj&lt;/code&gt; to clear (&lt;code&gt;false&lt;/code&gt;). The first version orders memory accesses according to &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;, the second version orders memory accesses according to &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 가 가리키는 &lt;code&gt;atomic_flag&lt;/code&gt; 의 상태를 원자 적으로 변경하여 clear ( &lt;code&gt;false&lt;/code&gt; )로 변경합니다. 첫 번째 버전은 &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; 에 따라 메모리 액세스를 주문 하고 두 번째 버전은 order에 따라 메모리 액세스를 &lt;code&gt;order&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="c3718979e2b9ad32f9d807868c9664bc02a4706d" translate="yes" xml:space="preserve">
          <source>Atomically changes the state of a &lt;code&gt;atomic_flag&lt;/code&gt; pointed to by &lt;code&gt;obj&lt;/code&gt; to set (&lt;code&gt;true&lt;/code&gt;) and returns the previous value. The first version orders memory accesses according to &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;, the second version orders memory accesses according to &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 가 가리키는 &lt;code&gt;atomic_flag&lt;/code&gt; 의 상태를 원자 적으로 변경하여 설정 ( &lt;code&gt;true&lt;/code&gt; )하고 이전 값을 반환합니다. 첫 번째 버전은 &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; 에 따라 메모리 액세스를 주문 하고 두 번째 버전은 order에 따라 메모리 액세스를 &lt;code&gt;order&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="685cd023c278ffbba93acf26685c796a80ffd6b1" translate="yes" xml:space="preserve">
          <source>Atomically compares the contents of memory pointed to by &lt;code&gt;obj&lt;/code&gt; with the contents of memory pointed to by &lt;code&gt;expected&lt;/code&gt;, and if those are bitwise equal, replaces the former with &lt;code&gt;desired&lt;/code&gt; (performs read-modify-write operation). Otherwise, loads the actual contents of memory pointed to by &lt;code&gt;obj&lt;/code&gt; into &lt;code&gt;*expected&lt;/code&gt; (performs load operation).</source>
          <target state="translated">원자 메모리의 내용이 가리키는 비교 &lt;code&gt;obj&lt;/code&gt; 메모리에 의해 지시의 내용이 &lt;code&gt;expected&lt;/code&gt; 그 비트가 동일한 경우, 및 대체와 전 &lt;code&gt;desired&lt;/code&gt; (행한다 읽기 - 수정 - 쓰기 동작). 그렇지 않으면 &lt;code&gt;obj&lt;/code&gt; 가 가리키는 메모리의 실제 내용 을 &lt;code&gt;*expected&lt;/code&gt; (로드 작업 수행)에로드합니다.</target>
        </trans-unit>
        <trans-unit id="df0174a476c2f8736237beae3e21b905656296c6" translate="yes" xml:space="preserve">
          <source>Atomically loads and returns the current value of the atomic variable pointed to by &lt;code&gt;obj&lt;/code&gt;. The operation is atomic read operation.</source>
          <target state="translated">원자 적으로 &lt;code&gt;obj&lt;/code&gt; 가 가리키는 원자 변수의 현재 값을로드하고 반환합니다 . 작업은 원자 읽기 작업입니다.</target>
        </trans-unit>
        <trans-unit id="4dc9ad67c097c1b7227ead6a0ab401fe229b6c4e" translate="yes" xml:space="preserve">
          <source>Atomically replaces the value of the atomic variable pointed to by &lt;code&gt;obj&lt;/code&gt; with &lt;code&gt;desired&lt;/code&gt;. The operation is atomic write operation.</source>
          <target state="translated">원자 가리키는 원자 변수 값 대체 &lt;code&gt;obj&lt;/code&gt; 와 &lt;code&gt;desired&lt;/code&gt; . 작업은 원자 쓰기 작업입니다.</target>
        </trans-unit>
        <trans-unit id="e9a886ccb54785d3678b91318357ed8aa2ecb513" translate="yes" xml:space="preserve">
          <source>Atomically replaces the value pointed by &lt;code&gt;obj&lt;/code&gt; with &lt;code&gt;desired&lt;/code&gt; and returns the value &lt;code&gt;obj&lt;/code&gt; held previously. The operation is read-modify-write operation. The first version orders memory accesses according to &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;, the second version orders memory accesses according to &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 가 가리키는 값 을 &lt;code&gt;desired&lt;/code&gt; 것으로 원자 적으로 대체하고 이전에 보유한 &lt;code&gt;obj&lt;/code&gt; 값을 반환합니다 . 작업은 읽기-수정-쓰기 작업입니다. 첫 번째 버전은 &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; 에 따라 메모리 액세스를 주문 하고 두 번째 버전은 order에 따라 메모리 액세스를 &lt;code&gt;order&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="0d0a6f30b29e80519fc1b75f03c103695e80bc2f" translate="yes" xml:space="preserve">
          <source>Atomically replaces the value pointed by &lt;code&gt;obj&lt;/code&gt; with the result of addition of &lt;code&gt;arg&lt;/code&gt; to the old value of &lt;code&gt;obj&lt;/code&gt;, and returns the value &lt;code&gt;obj&lt;/code&gt; held previously. The operation is read-modify-write operation. The first version orders memory accesses according to &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;, the second version orders memory accesses according to &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 가 가리키는 값을 &lt;code&gt;obj&lt;/code&gt; 의 이전 값에 &lt;code&gt;arg&lt;/code&gt; 를 추가 한 결과를 원자 적으로 대체하고 이전에 보유한 &lt;code&gt;obj&lt;/code&gt; 값을 반환합니다 . 작업은 읽기-수정-쓰기 작업입니다. 첫 번째 버전은 &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; 에 따라 메모리 액세스를 주문 하고 두 번째 버전은 order에 따라 메모리 액세스를 &lt;code&gt;order&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="720b64c8705ff9f12adca3f0ac1074a4d0557da4" translate="yes" xml:space="preserve">
          <source>Atomically replaces the value pointed by &lt;code&gt;obj&lt;/code&gt; with the result of bitwise AND between the old value of &lt;code&gt;obj&lt;/code&gt; and &lt;code&gt;arg&lt;/code&gt;, and returns the value &lt;code&gt;obj&lt;/code&gt; held previously. The operation is read-modify-write operation. The first version orders memory accesses according to &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;, the second version orders memory accesses according to &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 가 가리키는 값을 &lt;code&gt;obj&lt;/code&gt; 와 &lt;code&gt;arg&lt;/code&gt; 의 이전 값 사이의 비트 AND 결과로 원자 적으로 대체하고 이전에 보유한 &lt;code&gt;obj&lt;/code&gt; 값을 반환합니다 . 작업은 읽기-수정-쓰기 작업입니다. 첫 번째 버전은 &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; 에 따라 메모리 액세스를 주문 하고 두 번째 버전은 order에 따라 메모리 액세스를 &lt;code&gt;order&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="783b0416c25a72626756ad2801575cf30aa6b7c4" translate="yes" xml:space="preserve">
          <source>Atomically replaces the value pointed by &lt;code&gt;obj&lt;/code&gt; with the result of bitwise OR between the old value of &lt;code&gt;obj&lt;/code&gt; and &lt;code&gt;arg&lt;/code&gt;, and returns the value &lt;code&gt;obj&lt;/code&gt; held previously. The operation is read-modify-write operation. The first version orders memory accesses according to &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;, the second version orders memory accesses according to &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 가 가리키는 값을 &lt;code&gt;obj&lt;/code&gt; 와 &lt;code&gt;arg&lt;/code&gt; 의 이전 값 사이의 비트 단위 OR 결과로 원자 적으로 대체하고 이전에 보유한 &lt;code&gt;obj&lt;/code&gt; 값을 반환합니다 . 작업은 읽기-수정-쓰기 작업입니다. 첫 번째 버전은 &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; 에 따라 메모리 액세스를 주문 하고 두 번째 버전은 order에 따라 메모리 액세스를 &lt;code&gt;order&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="bdda98d653801da68179d56534d72790cd58233c" translate="yes" xml:space="preserve">
          <source>Atomically replaces the value pointed by &lt;code&gt;obj&lt;/code&gt; with the result of bitwise XOR between the old value of &lt;code&gt;obj&lt;/code&gt; and &lt;code&gt;arg&lt;/code&gt;, and returns the value &lt;code&gt;obj&lt;/code&gt; held previously. The operation is read-modify-write operation. The first version orders memory accesses according to &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;, the second version orders memory accesses according to &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 가 가리키는 값을 &lt;code&gt;obj&lt;/code&gt; 와 &lt;code&gt;arg&lt;/code&gt; 의 이전 값 사이의 비트 XOR 결과로 원자 적으로 대체하고 이전에 보유한 &lt;code&gt;obj&lt;/code&gt; 값을 반환합니다 . 작업은 읽기-수정-쓰기 작업입니다. 첫 번째 버전은 &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; 에 따라 메모리 액세스를 주문 하고 두 번째 버전은 order에 따라 메모리 액세스를 &lt;code&gt;order&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="7460f1e114e6e22f0145a7afeb4678b75fefd6c5" translate="yes" xml:space="preserve">
          <source>Atomically replaces the value pointed by &lt;code&gt;obj&lt;/code&gt; with the result of subtraction of &lt;code&gt;arg&lt;/code&gt; from the old value of &lt;code&gt;obj&lt;/code&gt;, and returns the value &lt;code&gt;obj&lt;/code&gt; held previously. The operation is read-modify-write operation. The first version orders memory accesses according to &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;, the second version orders memory accesses according to &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 가 가리키는 값을 &lt;code&gt;obj&lt;/code&gt; 의 이전 값에서 &lt;code&gt;arg&lt;/code&gt; 를 뺀 결과로 원자 적으로 대체하고 이전에 보유한 &lt;code&gt;obj&lt;/code&gt; 값을 반환합니다 . 작업은 읽기-수정-쓰기 작업입니다. 첫 번째 버전은 &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; 에 따라 메모리 액세스를 주문 하고 두 번째 버전은 order에 따라 메모리 액세스를 &lt;code&gt;order&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="a07f5da57143cfac7db707b777023caeb735d1c3" translate="yes" xml:space="preserve">
          <source>Atomically unlocks the mutex pointed to by &lt;code&gt;mutex&lt;/code&gt; and blocks on the condition variable pointed to by &lt;code&gt;cond&lt;/code&gt; until the thread is signalled by &lt;code&gt;&lt;a href=&quot;cnd_signal&quot;&gt;cnd_signal&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;cnd_broadcast&quot;&gt;cnd_broadcast&lt;/a&gt;&lt;/code&gt;, or until a spurious wake-up occurs. The mutex is locked again before the function returns.</source>
          <target state="translated">원자 뮤텍스가 가리키는 잠금 해제 &lt;code&gt;mutex&lt;/code&gt; 가 조건 변수를 차단 지적 &lt;code&gt;cond&lt;/code&gt; 스레드에 의해 신호를 때까지 &lt;code&gt;&lt;a href=&quot;cnd_signal&quot;&gt;cnd_signal&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;cnd_broadcast&quot;&gt;cnd_broadcast&lt;/a&gt;&lt;/code&gt; , 또는 가짜 웨이크 업이 발생할 때까지. 함수가 반환되기 전에 뮤텍스가 다시 잠 깁니다.</target>
        </trans-unit>
        <trans-unit id="ddabf926a852b8875d5dc026bfa320aee942ddb7" translate="yes" xml:space="preserve">
          <source>Atomically unlocks the mutex pointed to by &lt;code&gt;mutex&lt;/code&gt; and blocks on the condition variable pointed to by &lt;code&gt;cond&lt;/code&gt; until the thread is signalled by &lt;code&gt;&lt;a href=&quot;cnd_signal&quot;&gt;cnd_signal&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;cnd_broadcast&quot;&gt;cnd_broadcast&lt;/a&gt;&lt;/code&gt;, or until the &lt;code&gt;TIME_UTC&lt;/code&gt; based time point pointed to by &lt;code&gt;time_point&lt;/code&gt; has been reached, or until a spurious wake-up occurs. The mutex is locked again before the function returns.</source>
          <target state="translated">스레드가 &lt;code&gt;&lt;a href=&quot;cnd_signal&quot;&gt;cnd_signal&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;cnd_broadcast&quot;&gt;cnd_broadcast&lt;/a&gt;&lt;/code&gt; 에 의해 신호 될 때까지 또는 &lt;code&gt;time_point&lt;/code&gt; 에 의해 지정된 &lt;code&gt;TIME_UTC&lt;/code&gt; 기반 시점 에 도달 할 때까지 또는 스퓨리어스 웨이크 업이 될 때까지 뮤텍스가 가리키는 &lt;code&gt;mutex&lt;/code&gt; 를 원자로 잠금 해제하고 &lt;code&gt;cond&lt;/code&gt; 가 가리키는 조건 변수를 차단 합니다. 발생합니다. 함수가 반환되기 전에 뮤텍스가 다시 잠 깁니다.</target>
        </trans-unit>
        <trans-unit id="baca3810d2cde4b7e1025b84062248c5223beff5" translate="yes" xml:space="preserve">
          <source>Attempts to clear the floating-point exceptions that are listed in the bitmask argument &lt;code&gt;excepts&lt;/code&gt;, which is a bitwise OR of the &lt;a href=&quot;fe_exceptions&quot;&gt;floating point exception macros&lt;/a&gt;.</source>
          <target state="translated">시도는 비트 마스크 인수에 나와있는 부동 소수점 예외 웁니다 &lt;code&gt;excepts&lt;/code&gt; 비트 단위 OR의이다, &lt;a href=&quot;fe_exceptions&quot;&gt;부동 소수점 예외 매크로&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="80ba342b8785a08804a333bbfedec341d6d1c9c0" translate="yes" xml:space="preserve">
          <source>Attempts to raise all floating point exceptions listed in &lt;code&gt;excepts&lt;/code&gt; (a bitwise OR of the &lt;a href=&quot;fe_exceptions&quot;&gt;floating point exception macros&lt;/a&gt;). If one of the exceptions is &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_OVERFLOW&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_UNDERFLOW&lt;/a&gt;&lt;/code&gt;, this function may additionally raise &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt;. The order in which the exceptions are raised is unspecified, except that &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_OVERFLOW&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_UNDERFLOW&lt;/a&gt;&lt;/code&gt; are always raised before &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">시도에 나열된 모든 부동 소수점 예외 올리는 &lt;code&gt;excepts&lt;/code&gt; (또는의 비트 &lt;a href=&quot;fe_exceptions&quot;&gt;부동 소수점 예외 매크로&lt;/a&gt; ). 예외 중 하나가 &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_OVERFLOW&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_UNDERFLOW&lt;/a&gt;&lt;/code&gt; 이면이 함수는 &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; 를 추가로 발생시킬 수 있습니다 . &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_OVERFLOW&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_UNDERFLOW&lt;/a&gt;&lt;/code&gt; 가 항상 &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; 전에 발생 한다는 점을 제외하고 예외가 발생하는 순서는 지정되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="fc28f53619db61ee68c4c2b6467d93002c47863a" translate="yes" xml:space="preserve">
          <source>B and A appears before Y in the Single Total Order</source>
          <target state="translated">단일 총 주문에서 B와 A가 Y 앞에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="403422f66cba2adadb0da593596292864fb30e29" translate="yes" xml:space="preserve">
          <source>B within thread 1 and C is</source>
          <target state="translated">스레드 1 내의 B와 C는</target>
        </trans-unit>
        <trans-unit id="4e54499211164f4b65d4e8324b3d4ca2593386d6" translate="yes" xml:space="preserve">
          <source>B, and X appears before Y in the Single Total Order, then B observes either:</source>
          <target state="translated">B와 X가 단일 총 주문에서 Y 앞에 나타나면 B는 다음 중 하나를 관찰합니다.</target>
        </trans-unit>
        <trans-unit id="45e5662cbbb3c35284b81863cd8050953ac79093" translate="yes" xml:space="preserve">
          <source>B, and X appears before Y in the Single Total Order.</source>
          <target state="translated">B와 X는 단일 총 주문에서 Y 앞에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="b23fad0d216b95f70509ee04aeb30c3631070eb7" translate="yes" xml:space="preserve">
          <source>B, then B observes one of the following:</source>
          <target state="translated">B이면 B는 다음 중 하나를 관찰합니다.</target>
        </trans-unit>
        <trans-unit id="b5eb64aad8ea6fe11cd7f656c010af32479eca9f" translate="yes" xml:space="preserve">
          <source>B.2 Complex &amp;lt;complex.h&amp;gt; (p: 419-420)</source>
          <target state="translated">B.2 콤플렉스 &amp;lt;complex.h&amp;gt; (p : 419-420)</target>
        </trans-unit>
        <trans-unit id="24529c2b713b938df14dfb7e1f8995742508e674" translate="yes" xml:space="preserve">
          <source>B.2 Complex &amp;lt;complex.h&amp;gt; (p: 475-477)</source>
          <target state="translated">B.2 콤플렉스 &amp;lt;complex.h&amp;gt; (p : 475-477)</target>
        </trans-unit>
        <trans-unit id="6909406a48bd13f476c9416147defba89909eee5" translate="yes" xml:space="preserve">
          <source>BUFSIZ</source>
          <target state="translated">BUFSIZ</target>
        </trans-unit>
        <trans-unit id="e4e7ae591b0abd861a75d3fa39a7cab907d2a5c8" translate="yes" xml:space="preserve">
          <source>Basic concepts</source>
          <target state="translated">기본 개념</target>
        </trans-unit>
        <trans-unit id="beb8cd5e0f8e7a06f8d36dc83c4364f7f79078fa" translate="yes" xml:space="preserve">
          <source>Basic operations</source>
          <target state="translated">기본 조작</target>
        </trans-unit>
        <trans-unit id="3fc431b29bb2c2516db706b2f480a558166eba6d" translate="yes" xml:space="preserve">
          <source>Basic types</source>
          <target state="translated">기본 유형</target>
        </trans-unit>
        <trans-unit id="72e7594e1a0833654a97aa88a5c1fd93e77d5daa" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;compatibility of function types&lt;/a&gt; ignores top-level qualifiers of the function parameters, pointers to functions whose parameters only differ in their top-level qualifiers are interchangeable:</source>
          <target state="translated">때문에 &lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;함수 종류의 호환성&lt;/a&gt; 파라미터 그들의 최상위 한정자 다를 교환 가능 기능 최상위 함수 파라미터들의 규정 포인터 무시 :</target>
        </trans-unit>
        <trans-unit id="a4b1b6fcc1d9042bd28e210a0d53c1bd7a9ab8da" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;const&quot;&gt;const&lt;/a&gt;, &lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt;, &lt;a href=&quot;restrict&quot;&gt;restrict&lt;/a&gt;, and &lt;a href=&quot;atomic&quot;&gt;atomic&lt;/a&gt; qualifiers have effect on &lt;a href=&quot;value_category&quot;&gt;lvalues only&lt;/a&gt;, a cast to a cvr-qualified or atomic type is exactly equivalent to the cast to the corresponding unqualified type.</source>
          <target state="translated">때문에 &lt;a href=&quot;const&quot;&gt;CONST는&lt;/a&gt; , &lt;a href=&quot;volatile&quot;&gt;휘발성&lt;/a&gt; , &lt;a href=&quot;restrict&quot;&gt;제한&lt;/a&gt; 및 &lt;a href=&quot;atomic&quot;&gt;원자&lt;/a&gt; 한정자에 효과가 &lt;a href=&quot;value_category&quot;&gt;lvalues 만&lt;/a&gt; 하는 CVR 자격 또는 원자 유형에 대한 캐스트는 해당 자격이없는 유형으로 캐스트 정확히 동일합니다.</target>
        </trans-unit>
        <trans-unit id="09d7dc408004444ec94c2fabf4134d0cd224a49d" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;setlocale&lt;/code&gt; modifies global state which affects execution of locale-dependent functions, it is undefined behavior to call it from one thread, while another thread is executing any of the following functions: &lt;code&gt;&lt;a href=&quot;../io/fprintf&quot;&gt;fprintf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/isprint&quot;&gt;isprint&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswdigit&quot;&gt;iswdigit&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;localeconv&quot;&gt;localeconv&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/tolower&quot;&gt;tolower&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../io/fscanf&quot;&gt;fscanf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/ispunct&quot;&gt;ispunct&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswgraph&quot;&gt;iswgraph&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/multibyte/mblen&quot;&gt;mblen&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/toupper&quot;&gt;toupper&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/isalnum&quot;&gt;isalnum&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/isspace&quot;&gt;isspace&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswlower&quot;&gt;iswlower&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbstowcs&quot;&gt;mbstowcs&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/towlower&quot;&gt;towlower&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/isalpha&quot;&gt;isalpha&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/isupper&quot;&gt;isupper&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswprint&quot;&gt;iswprint&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbtowc&quot;&gt;mbtowc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/towupper&quot;&gt;towupper&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/isblank&quot;&gt;isblank&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswalnum&quot;&gt;iswalnum&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswpunct&quot;&gt;iswpunct&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;setlocale&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/wcscoll&quot;&gt;wcscoll&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/iscntrl&quot;&gt;iscntrl&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswalpha&quot;&gt;iswalpha&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswspace&quot;&gt;iswspace&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/strcoll&quot;&gt;strcoll&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/wcstof&quot;&gt;wcstod&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/isdigit&quot;&gt;isdigit&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswblank&quot;&gt;iswblank&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswupper&quot;&gt;iswupper&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/strerror&quot;&gt;strerror&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/multibyte/wcstombs&quot;&gt;wcstombs&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/isgraph&quot;&gt;isgraph&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswcntrl&quot;&gt;iswcntrl&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswxdigit&quot;&gt;iswxdigit&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/strtof&quot;&gt;strtod&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/wcsxfrm&quot;&gt;wcsxfrm&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/islower&quot;&gt;islower&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswctype&quot;&gt;iswctype&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/isxdigit&quot;&gt;isxdigit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">때문에 &lt;code&gt;setlocale&lt;/code&gt; 에 로케일 종속 함수의 실행에 영향을 수정 글로벌 상태, 또 다른 스레드는 다음 기능을 실행하는 동안 정의되지 않은 동작들이 하나 개의 스레드에서 호출하는 것이다 &lt;code&gt;&lt;a href=&quot;../io/fprintf&quot;&gt;fprintf&lt;/a&gt;&lt;/code&gt; 와 , &lt;code&gt;&lt;a href=&quot;../string/byte/isprint&quot;&gt;isprint&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswdigit&quot;&gt;iswdigit&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;localeconv&quot;&gt;localeconv&lt;/a&gt;&lt;/code&gt; 에 , &lt;code&gt;&lt;a href=&quot;../string/byte/tolower&quot;&gt;tolower&lt;/a&gt;&lt;/code&gt; 를 , &lt;code&gt;&lt;a href=&quot;../io/fscanf&quot;&gt;fscanf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/byte/ispunct&quot;&gt;ispunct&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswgraph&quot;&gt;iswgraph&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/multibyte/mblen&quot;&gt;mblen&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/byte/toupper&quot;&gt;toupper&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/byte/isalnum&quot;&gt;isalnum&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/byte/isspace&quot;&gt;isspace&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswlower&quot;&gt;iswlower&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbstowcs&quot;&gt;mbstowcs&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/towlower&quot;&gt;towlower&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/byte/isalpha&quot;&gt;isalpha&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/byte/isupper&quot;&gt;isupper&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswprint&quot;&gt;iswprint&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbtowc&quot;&gt;mbtowc&lt;/a&gt;&lt;/code&gt; 는 , &lt;code&gt;&lt;a href=&quot;../string/wide/towupper&quot;&gt;towupper&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/byte/isblank&quot;&gt;isblank&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswalnum&quot;&gt;iswalnum&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswpunct&quot;&gt;iswpunct&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;setlocale&lt;/code&gt; 에 , &lt;code&gt;&lt;a href=&quot;../string/wide/wcscoll&quot;&gt;wcscoll&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/byte/iscntrl&quot;&gt;iscntrl&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswalpha&quot;&gt;iswalpha&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswspace&quot;&gt;iswspace&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/byte/strcoll&quot;&gt;strcoll&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/wcstof&quot;&gt;wcstod&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/byte/isdigit&quot;&gt;isdigit&lt;/a&gt;&lt;/code&gt; 에 , &lt;code&gt;&lt;a href=&quot;../string/wide/iswblank&quot;&gt;iswblank&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswupper&quot;&gt;iswupper&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/byte/strerror&quot;&gt;strerror&lt;/a&gt;&lt;/code&gt; 는 , &lt;code&gt;&lt;a href=&quot;../string/multibyte/wcstombs&quot;&gt;wcstombs&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/byte/isgraph&quot;&gt;isgraph&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswcntrl&quot;&gt;iswcntrl&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswxdigit&quot;&gt;iswxdigit&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/byte/strtof&quot;&gt;strtod&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/wcsxfrm&quot;&gt;wcsxfrm&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/byte/islower&quot;&gt;islower&lt;/a&gt;&lt;/code&gt; 와 , &lt;code&gt;&lt;a href=&quot;../string/wide/iswctype&quot;&gt;iswctype&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/byte/isxdigit&quot;&gt;isxdigit&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="677c92c867af65c403f0e0b4ec228f7d426c2613" translate="yes" xml:space="preserve">
          <source>Because a struct declaration does not establish &lt;a href=&quot;scope&quot;&gt;scope&lt;/a&gt;, nested types, enumerations and enumerators introduced by declarations within struct-declaration-list are visible in the surrounding scope where the struct is defined.</source>
          <target state="translated">구조체 선언은 &lt;a href=&quot;scope&quot;&gt;scope을&lt;/a&gt; 설정하지 않기 때문에 struct-declaration-list 내의 선언에 의해 도입 된 중첩 형식, 열거 및 열거자는 구조체가 정의 된 주변 범위에서 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80a31a1dd2f3b7679f827332e33a29fac7702466" translate="yes" xml:space="preserve">
          <source>Because bit fields do not necessarily begin at the beginning of a byte, address of a bit field cannot be taken. Pointers to bit fields are not possible. Bit fields cannot be used with &lt;a href=&quot;sizeof&quot;&gt;sizeof&lt;/a&gt;and &lt;a href=&quot;alignas&quot;&gt;alignas&lt;/a&gt;(since C11).</source>
          <target state="translated">비트 필드는 반드시 바이트의 시작 부분에서 시작하지 않아도되므로 비트 필드의 주소를 가져올 수 없습니다. 비트 필드에 대한 포인터는 불가능합니다. 비트 필드는 &lt;a href=&quot;sizeof&quot;&gt;sizeof&lt;/a&gt; 및 &lt;a href=&quot;alignas&quot;&gt;alignas&lt;/a&gt; 와 함께 사용할 수 없습니다 (C11부터).</target>
        </trans-unit>
        <trans-unit id="b5ebf1a72c58aab22e302945eaa39d0cb80ef7c4" translate="yes" xml:space="preserve">
          <source>Because comments &lt;a href=&quot;language/translation_phases&quot;&gt;are removed&lt;/a&gt; before the preprocessor stage, a macro cannot be used to form a comment and an unterminated C-style comment doesn't spill over from an #include'd file.</source>
          <target state="translated">전 처리기 단계 전에 주석 &lt;a href=&quot;language/translation_phases&quot;&gt;이 제거&lt;/a&gt; 되므로 매크로를 사용하여 주석을 구성 할 수 없으며 종료되지 않은 C 스타일 주석이 # include'd 파일에서 넘겨지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1e0e557c9045c92f011c14de73fcb46d729716ba" translate="yes" xml:space="preserve">
          <source>Because compound literals are unnamed, a compound literal cannot reference itself (a named struct can include a pointer to itself).</source>
          <target state="translated">복합 리터럴은 이름이 지정되지 않기 때문에 복합 리터럴은 자체를 참조 할 수 없습니다 (이름 지정된 구조체는 자신에 대한 포인터를 포함 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="d0f24847824ec8fc762ee7f7da8ed9ef3192123c" translate="yes" xml:space="preserve">
          <source>Because correct C programs are free of undefined behavior, compilers may produce unexpected results when a program that actually has UB is compiled with optimization enabled:</source>
          <target state="translated">올바른 C 프로그램에는 정의되지 않은 동작이 없으므로 실제로 UB가있는 프로그램을 최적화가 활성화 된 상태로 컴파일하면 컴파일러에서 예기치 않은 결과가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75a3b82067fe04c5e544992bcd1de5079a905d52" translate="yes" xml:space="preserve">
          <source>Because declarations are not statements, a label before a declaration must use a null statement (a semicolon immediately after the colon). Same applies to a label before the end of a block.</source>
          <target state="translated">선언은 명령문이 아니므로 선언 앞의 레이블은 널 명령문 (콜론 바로 다음의 세미콜론)을 사용해야합니다. 블록이 끝나기 전에 레이블에도 동일하게 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="1c99db21460e6186678ebd629bae9336a41554f4" translate="yes" xml:space="preserve">
          <source>Because in C, any &lt;a href=&quot;arithmetic_types&quot;&gt;complex value&lt;/a&gt; with at least one infinite part as an infinity even if its other part is a NaN, the usual arithmetic rules do not apply to complex-complex division. Other combinations of floating operands follow the following table:</source>
          <target state="translated">C에서 다른 부품이 NaN 인 경우에도 무한 부품으로 하나 이상의 무한 부품이 있는 &lt;a href=&quot;arithmetic_types&quot;&gt;복소수 값&lt;/a&gt; 이므로 복잡한 산술 분할에는 일반적인 산술 규칙이 적용되지 않습니다. 부동 피연산자의 다른 조합은 다음 표를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="c3eb0806ea4c877ddbfd4e6e05950c4f3566ab2f" translate="yes" xml:space="preserve">
          <source>Because in C, any &lt;a href=&quot;arithmetic_types&quot;&gt;complex value&lt;/a&gt; with at least one infinite part as an infinity even if its other part is a NaN, the usual arithmetic rules do not apply to complex-complex multiplication. Other combinations of floating operands follow the following table:</source>
          <target state="translated">C에서는 다른 부분이 NaN 인 경우에도 하나 이상의 무한 부분이 무한대 인 &lt;a href=&quot;arithmetic_types&quot;&gt;복소수 값&lt;/a&gt; 이므로 복잡한 산술 곱셈에는 일반적인 산술 규칙이 적용되지 않습니다. 부동 피연산자의 다른 조합은 다음 표를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="224dd2f76f1fe545b11d30d1241dfab1984d9c00" translate="yes" xml:space="preserve">
          <source>Because members of incomplete type are not allowed, and a struct type is not complete until the end of the definition, a struct cannot have a member of its own type. A pointer to its own type is allowed, and is commonly used to implement nodes in linked lists or trees.</source>
          <target state="translated">불완전한 유형의 멤버는 허용되지 않으며 정의가 끝날 때까지 구조체 유형이 완료되지 않기 때문에 구조체는 자체 유형의 멤버를 가질 수 없습니다. 자체 유형에 대한 포인터가 허용되며 일반적으로 링크 된 목록 또는 트리에서 노드를 구현하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bad967f19eac295089f2fac67901872b755b210a" translate="yes" xml:space="preserve">
          <source>Because most conversion specifiers first consume all consecutive whitespace, code such as.</source>
          <target state="translated">대부분의 변환 지정자는 먼저 모든 연속 공백을 소비하므로 다음과 같은 코드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="39db9801ee2b85598d8ae1a1a46079d1e8fc3c5a" translate="yes" xml:space="preserve">
          <source>Because of the &lt;a href=&quot;array&quot;&gt;array-to-pointer&lt;/a&gt; implicit conversion, pointer to the first element of an array can be initialized with an expression of array type:</source>
          <target state="translated">왜냐하면의 &lt;a href=&quot;array&quot;&gt;배열에 포인터&lt;/a&gt; 암시 적 변환, 어레이의 첫 번째 요소의 포인터는 어레이 형의 식으로 초기화 될 수있다 :</target>
        </trans-unit>
        <trans-unit id="0ef3d7a594c0b241d8f8e7bcd0f19c06711e02ca" translate="yes" xml:space="preserve">
          <source>Because of the lvalue conversions, &lt;code&gt;&quot;abc&quot;&lt;/code&gt; matches &lt;code&gt;char*&lt;/code&gt; and not &lt;code&gt;char[4]&lt;/code&gt; and &lt;code&gt;(int const){0}&lt;/code&gt; matches &lt;code&gt;int&lt;/code&gt;, and not &lt;code&gt;const int&lt;/code&gt;. This was specified by the C17 DR 481 (which applies retroactively to C11).</source>
          <target state="translated">lvalue 변환으로 인해 &lt;code&gt;&quot;abc&quot;&lt;/code&gt; 는 &lt;code&gt;char*&lt;/code&gt; &lt;code&gt;char[4]&lt;/code&gt; 아닌 char * 와 일치 하고 &lt;code&gt;(int const){0}&lt;/code&gt; 은 &lt;code&gt;int&lt;/code&gt; 가 아니라 &lt;code&gt;const int&lt;/code&gt; 와 일치 합니다. 이것은 C17 DR 481 (C11에 소급 적용됨)에 의해 지정되었습니다.</target>
        </trans-unit>
        <trans-unit id="921ed4a61ba3faaabd04a1761190de01805d8c37" translate="yes" xml:space="preserve">
          <source>Because of the rules that apply to conversions as if by assignment, &lt;a href=&quot;const&quot;&gt;const&lt;/a&gt; and &lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt; qualifiers on the declared type are ignored when determining which type to convert the expression to.</source>
          <target state="translated">할당에 의한 것처럼 변환에 적용되는 규칙 으로 인해 식을 변환 할 형식을 결정할 때 선언 된 형식의 &lt;a href=&quot;const&quot;&gt;const&lt;/a&gt; 및 &lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt; 한정자가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="e4778b72ab7bad66e8f08db4718675bdd369485f" translate="yes" xml:space="preserve">
          <source>Because of the side-effects involved, increment and decrement operators must be used with care to avoid undefined behavior due to violations of &lt;a href=&quot;eval_order&quot;&gt;sequencing rules&lt;/a&gt;.</source>
          <target state="translated">관련된 부작용으로 인해 &lt;a href=&quot;eval_order&quot;&gt;시퀀싱 규칙&lt;/a&gt; 위반으로 인해 정의되지 않은 동작이 발생하지 않도록 증분 및 감소 연산자를주의해서 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7dd28ff65248ebaad3755cb5b7e5ed66cc093d74" translate="yes" xml:space="preserve">
          <source>Because pointer comparison works with pointers to void, the macro &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; may be defined as &lt;code&gt;(void*)0&lt;/code&gt; in C, although that would be invalid in C++ where void pointers do not implicitly convert to typed pointers.</source>
          <target state="translated">포인터 비교는 void에 대한 포인터와 함께 작동하기 때문에 매크로 &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 은 C에서 &lt;code&gt;(void*)0&lt;/code&gt; 으로 정의 될 수 있지만 void 포인터가 암시 적으로 유형이 지정된 포인터로 변환되지 않는 C ++에서는 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="61e9e83dfb4480f034d0715c389293dc26f2bd68" translate="yes" xml:space="preserve">
          <source>Because trigraphs are processed early, a comment such as &lt;code&gt;// Will the next line be executed?????/&lt;/code&gt; will effectively comment out the following line, and the string literal such as &lt;code&gt;&quot;What's going on??!&quot;&lt;/code&gt; is parsed as &lt;code&gt;&quot;What's going on|&quot;&lt;/code&gt;.</source>
          <target state="translated">trigraphs는 일찍 처리되기 때문에 &lt;code&gt;// Will the next line be executed?????/&lt;/code&gt; 와 같은 주석은 다음 줄이 실행됩니까 ????? / 와 같은 주석은 효과적으로 다음 줄을 주석으로 처리하고 &lt;code&gt;&quot;What's going on??!&quot;&lt;/code&gt; 로 분석된다 &lt;code&gt;&quot;What's going on|&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b3a49bfbe489269815a0377a9238ed94b4143cdf" translate="yes" xml:space="preserve">
          <source>Before C99, floating-point exceptions were not specified, &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;EDOM&lt;/a&gt;&lt;/code&gt; was required for any domain error, &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;ERANGE&lt;/a&gt;&lt;/code&gt; was required for overflows and implementation-defined for underflows.</source>
          <target state="translated">C99 이전에는 부동 소수점 예외가 지정되지 않았으며 도메인 오류에 &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;EDOM&lt;/a&gt;&lt;/code&gt; 이 필요했으며 오버플로에 &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;ERANGE&lt;/a&gt;&lt;/code&gt; 가 필요했으며 언더 플로에 대해 구현 정의가 필요했습니다.</target>
        </trans-unit>
        <trans-unit id="9b5450db704d0d2728817fd478cd80ea4e486aaf" translate="yes" xml:space="preserve">
          <source>Behaves as follows:</source>
          <target state="translated">다음과 같이 동작합니다 :</target>
        </trans-unit>
        <trans-unit id="bc3469b596bd7c770cc8387fa1d5a39905eb53ce" translate="yes" xml:space="preserve">
          <source>Besides &lt;code&gt;abort&lt;/code&gt; and &lt;code&gt;raise&lt;/code&gt;, POSIX specifies that &lt;code&gt;kill&lt;/code&gt;, &lt;code&gt;pthread_kill&lt;/code&gt;, and &lt;code&gt;sigqueue&lt;/code&gt; generate synchronous signals.</source>
          <target state="translated">POSIX는 &lt;code&gt;abort&lt;/code&gt; 및 &lt;code&gt;raise&lt;/code&gt; 외에도 &lt;code&gt;kill&lt;/code&gt; , &lt;code&gt;pthread_kill&lt;/code&gt; 및 &lt;code&gt;sigqueue&lt;/code&gt; 가 동기 신호를 생성하도록 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="eabc9a356af19096008509b653054fc8a10ae1b7" translate="yes" xml:space="preserve">
          <source>Besides commenting out, other mechanisms used for source code exclusion are:</source>
          <target state="translated">주석 처리 외에도 소스 코드 제외에 사용되는 다른 메커니즘은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="55b4de0c95564ebdd3f273d704de6fbc4cc33b7a" translate="yes" xml:space="preserve">
          <source>Besides establishing new parse state and position, a call to this function undoes the effects of &lt;code&gt;&lt;a href=&quot;ungetc&quot;&gt;ungetc&lt;/a&gt;&lt;/code&gt; and clears the end-of-file state, if it is set.</source>
          <target state="translated">새로운 구문 분석 상태와 위치를 설정하는 것 외에도이 함수를 호출하면 &lt;code&gt;&lt;a href=&quot;ungetc&quot;&gt;ungetc&lt;/a&gt;&lt;/code&gt; 의 효과가 취소되고 파일 끝 상태가 설정되어 있으면 지워집니다.</target>
        </trans-unit>
        <trans-unit id="93b85166ca8a42b63bd840ea2f796b2c221ddb71" translate="yes" xml:space="preserve">
          <source>Besides infinity handling, complex division is not allowed to overflow intermediate results, except when &lt;a href=&quot;../preprocessor/impl&quot;&gt;&lt;code&gt; #pragma STDC CX_LIMITED_RANGE&lt;/code&gt;&lt;/a&gt; is set to &lt;code&gt;ON&lt;/code&gt;, in which case the value may be calculated as if by (x+iy)/(u+iv) = [(xu+yv)+i(yu-xv)]/(u2</source>
          <target state="translated">무한대 처리 외에도 &lt;a href=&quot;../preprocessor/impl&quot;&gt; &lt;code&gt; #pragma STDC CX_LIMITED_RANGE&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;ON&lt;/code&gt; 으로 설정된 경우를 제외하고 복잡한 나눗셈이 중간 결과를 오버플로 할 수 없습니다 .이 경우 값은 (x + iy) / (u + iv) = [( xu + yv) + i (yu-xv)] / (u2</target>
        </trans-unit>
        <trans-unit id="e3c4ad2940bc363a4f3c8811d9bf42503eadc813" translate="yes" xml:space="preserve">
          <source>Besides infinity handling, complex multiplication is not allowed to overflow intermediate results, except when &lt;a href=&quot;../preprocessor/impl&quot;&gt;&lt;code&gt; #pragma STDC CX_LIMITED_RANGE&lt;/code&gt;&lt;/a&gt; is set to &lt;code&gt;ON&lt;/code&gt;, in which case the value may be calculated as if by (x+iy)&amp;times;(u+iv) = (xu-yv)+i(yu+xv), as the programmer assumes the responsibility of limiting the range of the operands and dealing with the infinities.</source>
          <target state="translated">무한대 처리 외에도 &lt;a href=&quot;../preprocessor/impl&quot;&gt; &lt;code&gt; #pragma STDC CX_LIMITED_RANGE&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;ON&lt;/code&gt; 으로 설정된 경우를 제외하고는 복잡한 곱셈이 중간 결과를 오버플로 할 수 없습니다 .이 경우 값은 (x + iy) &amp;times; (u + iv) = (xu -yv) + i (yu + xv). 프로그래머가 피연산자의 범위를 제한하고 무한대를 처리해야 할 책임이 있습니다.</target>
        </trans-unit>
        <trans-unit id="94e54a4d4ecea696ecc0d61df156f5a02b183b99" translate="yes" xml:space="preserve">
          <source>Besides the minimal bit counts, the C Standard guarantees that  &lt;code&gt;1 == sizeof(char) &amp;lt;= sizeof(short) &amp;lt;= sizeof(int) &amp;lt;= sizeof(long) &amp;lt;= sizeof(long long)&lt;/code&gt;.</source>
          <target state="translated">최소 비트 수 외에도 C 표준은 &lt;code&gt;1 == sizeof(char) &amp;lt;= sizeof(short) &amp;lt;= sizeof(int) &amp;lt;= sizeof(long) &amp;lt;= sizeof(long long)&lt;/code&gt; 보장합니다 .</target>
        </trans-unit>
        <trans-unit id="0f9b2ba53360a3d77f0974e715c014901e8f2e24" translate="yes" xml:space="preserve">
          <source>Besides the system-specific information necessary to access the device (e.g. a POSIX file descriptor), each stream object holds the following:</source>
          <target state="translated">장치에 액세스하는 데 필요한 시스템 특정 정보 (예 : POSIX 파일 설명자) 외에도 각 스트림 개체에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="c460d3f926dfc813742e2a51770def855d27f159" translate="yes" xml:space="preserve">
          <source>Binary and text modes</source>
          <target state="translated">이진 및 텍스트 모드</target>
        </trans-unit>
        <trans-unit id="b045376f837c7f5b36378c8f4a5c40a869f8ef92" translate="yes" xml:space="preserve">
          <source>Bit fields</source>
          <target state="translated">비트 필드</target>
        </trans-unit>
        <trans-unit id="f0ec1f622a02737f146bdf2f91db5413c9e7432c" translate="yes" xml:space="preserve">
          <source>Bit fields can have only one of four types (possibly &lt;a href=&quot;const&quot;&gt;const&lt;/a&gt; or &lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt; qualified):</source>
          <target state="translated">비트 필드는 다음 네 가지 유형 중 하나만 가질 수 있습니다 ( &lt;a href=&quot;const&quot;&gt;const&lt;/a&gt; 또는 &lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt; Qualified).</target>
        </trans-unit>
        <trans-unit id="17e80e5f71e9b85954b350f117d4dfeb3c5cf70a" translate="yes" xml:space="preserve">
          <source>Bitwise AND</source>
          <target state="translated">비트 AND</target>
        </trans-unit>
        <trans-unit id="fbb0e5521fb64d3242c180ccb874fe7d8cabed01" translate="yes" xml:space="preserve">
          <source>Bitwise OR (inclusive or)</source>
          <target state="translated">비트 단위 OR (또는 포함)</target>
        </trans-unit>
        <trans-unit id="306fd7520aac5bd6625750560fd55f52696ffa54" translate="yes" xml:space="preserve">
          <source>Bitwise OR of the floating-point exception macros that are both included in &lt;code&gt;excepts&lt;/code&gt; and correspond to floating-point exceptions currently set.</source>
          <target state="translated">모두에 포함 된 부동 소수점 예외 매크로의 비트 단위 OR &lt;code&gt;excepts&lt;/code&gt; 부동 소수점 예외 및 대응은 현재 설정합니다.</target>
        </trans-unit>
        <trans-unit id="8d05bc7de5edbe8f8035db15389ae0302c380410" translate="yes" xml:space="preserve">
          <source>Bitwise XOR (exclusive or)</source>
          <target state="translated">비트 XOR (독점 또는)</target>
        </trans-unit>
        <trans-unit id="fabd2c95e5b0d98f2f600ccc655473c06c0c3640" translate="yes" xml:space="preserve">
          <source>Bitwise left shift and right shift</source>
          <target state="translated">비트 왼쪽 시프트 및 오른쪽 시프트</target>
        </trans-unit>
        <trans-unit id="8ff25d34bc5859088f94cfed2068dfc1ae2009f5" translate="yes" xml:space="preserve">
          <source>Bitwise logic</source>
          <target state="translated">비트 논리</target>
        </trans-unit>
        <trans-unit id="e681513340338ab189ae37b3a82732813788fc1e" translate="yes" xml:space="preserve">
          <source>Block scope</source>
          <target state="translated">블록 범위</target>
        </trans-unit>
        <trans-unit id="fd7d7dbe313bf74de7d4c75ebe6415d2612deaec" translate="yes" xml:space="preserve">
          <source>Block-scope variables have &lt;a href=&quot;storage_duration&quot;&gt;no linkage&lt;/a&gt; and &lt;a href=&quot;storage_duration&quot;&gt;automatic storage duration&lt;/a&gt; by default. Note that storage duration for non-VLA local variables begins when the block is entered, but until the declaration is seen, the variable is not in scope and cannot be accessed.</source>
          <target state="translated">블록 범위 변수에는 기본적 &lt;a href=&quot;storage_duration&quot;&gt;으로 &lt;/a&gt;&lt;a href=&quot;storage_duration&quot;&gt;연결&lt;/a&gt; 및 자동 저장 기간 이 없습니다 . VLA가 아닌 로컬 변수의 저장 기간은 블록을 입력 할 때 시작되지만 선언이 표시 될 때까지 변수는 범위 내에 있지 않으며 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="60cac622b229066c1c92084b1e1084cffd5fba0c" translate="yes" xml:space="preserve">
          <source>Blocks the current thread until the mutex pointed to by &lt;code&gt;mutex&lt;/code&gt; is locked or until the &lt;code&gt;TIME_UTC&lt;/code&gt; based time point pointed to by &lt;code&gt;time_point&lt;/code&gt; has been reached.</source>
          <target state="translated">뮤텍스가 가리키는 &lt;code&gt;mutex&lt;/code&gt; 가 잠길 때까지 또는 &lt;code&gt;time_point&lt;/code&gt; 가 가리키는 &lt;code&gt;TIME_UTC&lt;/code&gt; 기반 시점 에 도달 할 때까지 현재 스레드를 차단합니다 .</target>
        </trans-unit>
        <trans-unit id="66bacdd3e696d27ee3c9031e8264d87687cb2c86" translate="yes" xml:space="preserve">
          <source>Blocks the current thread until the mutex pointed to by &lt;code&gt;mutex&lt;/code&gt; is locked.</source>
          <target state="translated">뮤텍스가 가리키는 &lt;code&gt;mutex&lt;/code&gt; 가 잠길 때까지 현재 스레드를 차단합니다 .</target>
        </trans-unit>
        <trans-unit id="f10a288344857812105308b56f4f2cba321e7a11" translate="yes" xml:space="preserve">
          <source>Blocks the current thread until the thread identified by &lt;code&gt;thr&lt;/code&gt; finishes execution.</source>
          <target state="translated">&lt;code&gt;thr&lt;/code&gt; 로 식별 된 스레드 가 실행을 완료 할 때까지 현재 스레드를 차단합니다 .</target>
        </trans-unit>
        <trans-unit id="6e00d4fd15cea4053d3d66470eca6ff8a4eb81f0" translate="yes" xml:space="preserve">
          <source>Blocks the execution of the current thread for</source>
          <target state="translated">현재 스레드의 실행을 차단합니다.</target>
        </trans-unit>
        <trans-unit id="c40226a362762d0bc6ce1da464fd4cab15481c00" translate="yes" xml:space="preserve">
          <source>Boolean and pointer expressions are often used as loop controlling expressions. The boolean value &lt;code&gt;false&lt;/code&gt; and the null pointer value of any pointer type compare equal to zero.</source>
          <target state="translated">부울 및 포인터 표현식은 종종 루프 제어 표현식으로 사용됩니다. 부울 값 &lt;code&gt;false&lt;/code&gt; 와 포인터 유형의 널 포인터 값은 0과 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="0764deddbcf93612e5cc2cfe340f015993c796ea" translate="yes" xml:space="preserve">
          <source>Boolean conversion</source>
          <target state="translated">부울 변환</target>
        </trans-unit>
        <trans-unit id="49f29c844f200eead7503c6d10737135d242ba2b" translate="yes" xml:space="preserve">
          <source>Boolean type</source>
          <target state="translated">부울 타입</target>
        </trans-unit>
        <trans-unit id="89e600a56a479c724d49fe8d5ef9759ca18de8f7" translate="yes" xml:space="preserve">
          <source>Boolean type support library</source>
          <target state="translated">부울 유형 지원 라이브러리</target>
        </trans-unit>
        <trans-unit id="e7015f95fbaa798e33d1af7e54e15189c43d90fc" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; and the value zero indicate successful program execution status (see &lt;code&gt;&lt;a href=&quot;exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt;), although it is not required that &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; equals zero.</source>
          <target state="translated">&lt;code&gt;EXIT_SUCCESS&lt;/code&gt; 와 0 값은 모두 성공적인 프로그램 실행 상태를 나타냅니다 ( &lt;code&gt;&lt;a href=&quot;exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; 참조 ) . &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; 가 0 일 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="5406302f58397cc6547f5253fa2bd90d63f7aaf4" translate="yes" xml:space="preserve">
          <source>Both unary plus and unary minus first apply &lt;a href=&quot;conversion&quot;&gt;integral promotions&lt;/a&gt; to their operand, and then.</source>
          <target state="translated">단항 더하기 및 단항 빼기 모두 먼저 피연산자에 &lt;a href=&quot;conversion&quot;&gt;필수 승격&lt;/a&gt; 을 적용 합니다.</target>
        </trans-unit>
        <trans-unit id="f61c46711ac1d50bd575498533838ae1e8abac1d" translate="yes" xml:space="preserve">
          <source>Both versions return a value of type &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;size_t&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">두 버전 모두 &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;size_t&lt;/a&gt;&lt;/code&gt; 유형의 값을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="97a1527874168667ead2b1d8d5b5b282f24fe01a" translate="yes" xml:space="preserve">
          <source>Bounded UB is undefined behavior that cannot perform an illegal memory write, although it may trap and may produce or store indeterminate values.</source>
          <target state="translated">바운딩 된 UB는 정의되지 않은 값을 생성하거나 저장할 수 있지만 잘못된 메모리 쓰기를 수행 할 수없는 정의되지 않은 동작입니다.</target>
        </trans-unit>
        <trans-unit id="79873d72bb63ec6416a942c808c710c67586e841" translate="yes" xml:space="preserve">
          <source>Bounded undefined behavior</source>
          <target state="translated">바운드 정의되지 않은 동작</target>
        </trans-unit>
        <trans-unit id="4f10d11dd9987b9a9fd4e790ba2d77d5cde0dc75" translate="yes" xml:space="preserve">
          <source>Bounded undefined behavior disables certain optimizations: compilation with analyzability enabled preserves source-code causality, which &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=c/language/as_if&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;may be violated&lt;/a&gt; by undefined behavior otherwise.</source>
          <target state="translated">경계가 정의되지 않은 동작은 특정 최적화를 비활성화합니다. 분석 기능이 활성화 된 컴파일은 소스 코드 인과 관계를 유지하며, 그렇지 않으면 정의되지 않은 동작에 의해 &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=c/language/as_if&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;위반 될 수 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="008db50859187c03368a21b5b9915c65cb9f1ec8" translate="yes" xml:space="preserve">
          <source>Bounds checking</source>
          <target state="translated">경계 확인</target>
        </trans-unit>
        <trans-unit id="400d9c7e5fe4086bae3b1862358d354ae9938c57" translate="yes" xml:space="preserve">
          <source>Built-in &lt;a href=&quot;operator_incdec&quot;&gt;increment and decrement operators&lt;/a&gt; and &lt;a href=&quot;operator_assignment&quot;&gt;compound assignment&lt;/a&gt; are read-modify-write atomic operations with total sequentially consistent ordering (as if using &lt;code&gt;&lt;a href=&quot;../atomic/memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;). If less strict synchronization semantics are desired, the &lt;a href=&quot;../atomic&quot;&gt;standard library functions&lt;/a&gt; may be used instead.</source>
          <target state="translated">내장 &lt;a href=&quot;operator_incdec&quot;&gt;증가 및 감소 연산자&lt;/a&gt; 와 &lt;a href=&quot;operator_assignment&quot;&gt;복합 할당&lt;/a&gt; 은 총 순차로 일관된 순서를 갖는 읽기-수정-쓰기 원자 연산입니다 ( &lt;code&gt;&lt;a href=&quot;../atomic/memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; 사용하는 것처럼 ). 덜 엄격한 동기화 의미론이 필요한 경우 &lt;a href=&quot;../atomic&quot;&gt;표준 라이브러리 함수를&lt;/a&gt; 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f96307b93964d75b23f02f58a7c3a35fcfb5fa45" translate="yes" xml:space="preserve">
          <source>By definition, the subscript operator &lt;code&gt;E1[E2]&lt;/code&gt; is exactly identical to &lt;code&gt;*((E1)+(E2))&lt;/code&gt;. If pointer-expression is an array expression, it undergoes &lt;a href=&quot;conversion&quot;&gt;lvalue-to-rvalue conversion&lt;/a&gt; and becomes a pointer to the first element of the array.</source>
          <target state="translated">정의에 따르면 아래 첨자 연산자 &lt;code&gt;E1[E2]&lt;/code&gt; 는 &lt;code&gt;*((E1)+(E2))&lt;/code&gt; 와 정확히 동일합니다 . pointer-expression이 배열 표현식 인 경우 &lt;a href=&quot;conversion&quot;&gt;lvalue에서 rvalue로 변환&lt;/a&gt; 되어 배열의 첫 번째 요소에 대한 포인터가됩니다.</target>
        </trans-unit>
        <trans-unit id="7803ee252527503b67d1eeb0deb252622746cebd" translate="yes" xml:space="preserve">
          <source>Byte</source>
          <target state="translated">Byte</target>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="c58c36c53f42fd7c600c76110fd52d5783cea7d0" translate="yes" xml:space="preserve">
          <source>C Operator Precedence</source>
          <target state="translated">C 연산자 우선 순위</target>
        </trans-unit>
        <trans-unit id="eb6caef1589eb4b1a6590767aba0af5ac987e71a" translate="yes" xml:space="preserve">
          <source>C Programming Language</source>
          <target state="translated">C 프로그래밍 언어</target>
        </trans-unit>
        <trans-unit id="c94ec5437a5532816a0317782c7e7642602f22e2" translate="yes" xml:space="preserve">
          <source>C adopted the</source>
          <target state="translated">C는 채택</target>
        </trans-unit>
        <trans-unit id="5ca10313f99c78244c06862b7b8b7d340b4225b4" translate="yes" xml:space="preserve">
          <source>C also treats multiple infinities so as to preserve directional information where possible, despite the inherent limitations of the Cartesian representation:</source>
          <target state="translated">C는 직교 표현의 고유 한 한계에도 불구하고 가능한 경우 방향 정보를 보존하기 위해 여러 무한대를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="3ba06175a7b6689b39e35ea5131adbda2127a365" translate="yes" xml:space="preserve">
          <source>C has four kinds of scopes:</source>
          <target state="translated">C에는 네 가지 범위가 있습니다.</target>
        </trans-unit>
        <trans-unit id="fba12a9f5cc269fdeb5b6fbe79b42205d52cb74c" translate="yes" xml:space="preserve">
          <source>C has three types for representing real floating-point values:</source>
          <target state="translated">C에는 실수 부동 소수점 값을 나타내는 세 가지 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5206547c9adf534ccbc26e9a7e7f81e1243117db" translate="yes" xml:space="preserve">
          <source>C keywords</source>
          <target state="translated">C 키워드</target>
        </trans-unit>
        <trans-unit id="d3aabd7f1f341fa399600a1b2214223083e8c94a" translate="yes" xml:space="preserve">
          <source>C keywords: _Alignas (since C11)</source>
          <target state="translated">C 키워드 : _Alignas (C11부터)</target>
        </trans-unit>
        <trans-unit id="944615bbeed64b2d9fae2675cefd548984ef900c" translate="yes" xml:space="preserve">
          <source>C keywords: _Alignof (since C11)</source>
          <target state="translated">C 키워드 : _Alignof (C11부터)</target>
        </trans-unit>
        <trans-unit id="84b2eb329e4d92e0a4d384006f50861ce715cae6" translate="yes" xml:space="preserve">
          <source>C keywords: _Atomic</source>
          <target state="translated">C 키워드 : _Atomic</target>
        </trans-unit>
        <trans-unit id="8a05296f252eb2181406137c31f219059b31c674" translate="yes" xml:space="preserve">
          <source>C keywords: _Bool</source>
          <target state="translated">C 키워드 : _Bool</target>
        </trans-unit>
        <trans-unit id="1e0909bfead1f9cc1a889db650a2c563f189037c" translate="yes" xml:space="preserve">
          <source>C keywords: _Complex</source>
          <target state="translated">C 키워드 : _Complex</target>
        </trans-unit>
        <trans-unit id="b56eb0a972eae24c452dd3dcde43c102fa3f07b4" translate="yes" xml:space="preserve">
          <source>C keywords: _Generic</source>
          <target state="translated">C 키워드 : _Generic</target>
        </trans-unit>
        <trans-unit id="9ba2ce8143036dcefc339b168b7b9fdbf87a205e" translate="yes" xml:space="preserve">
          <source>C keywords: _Imaginary</source>
          <target state="translated">C 키워드 : _Imaginary</target>
        </trans-unit>
        <trans-unit id="c11f113e7aff3dde192c1e959a04c03b4117ed2d" translate="yes" xml:space="preserve">
          <source>C keywords: _Noreturn (since C11)</source>
          <target state="translated">C 키워드 : _Noreturn (C11부터)</target>
        </trans-unit>
        <trans-unit id="8155ee80a4c48fc49f561116f5e6c2e3aa9d145d" translate="yes" xml:space="preserve">
          <source>C keywords: _Static_assert</source>
          <target state="translated">C 키워드 : _Static_assert</target>
        </trans-unit>
        <trans-unit id="aa7ef9b71b6ab728b88e72b4e10aa644b34019fe" translate="yes" xml:space="preserve">
          <source>C keywords: _Thread_local (since C11)</source>
          <target state="translated">C 키워드 : _Thread_local (C11부터)</target>
        </trans-unit>
        <trans-unit id="49dc63ea16b8f8707b9b0e51cbd56a1d901d7ac4" translate="yes" xml:space="preserve">
          <source>C keywords: auto</source>
          <target state="translated">C 키워드 : 자동</target>
        </trans-unit>
        <trans-unit id="6de6b71cc705dbd2d56a38c0c394178db20754eb" translate="yes" xml:space="preserve">
          <source>C keywords: break</source>
          <target state="translated">C 키워드 : 휴식</target>
        </trans-unit>
        <trans-unit id="fb048e1990277a1b5c4c58f92576121302524116" translate="yes" xml:space="preserve">
          <source>C keywords: case</source>
          <target state="translated">C 키워드 : 사례</target>
        </trans-unit>
        <trans-unit id="6f8e3ab600fea3b9d2310e503fc9d7066ff7e26b" translate="yes" xml:space="preserve">
          <source>C keywords: char</source>
          <target state="translated">C 키워드 : char</target>
        </trans-unit>
        <trans-unit id="4b30efaadabace2d9f3caf304fb5da46109165d9" translate="yes" xml:space="preserve">
          <source>C keywords: const</source>
          <target state="translated">C 키워드 : const</target>
        </trans-unit>
        <trans-unit id="838724dbf3de5ca09bb9955c0ee37433b11370c3" translate="yes" xml:space="preserve">
          <source>C keywords: continue</source>
          <target state="translated">C 키워드 : 계속</target>
        </trans-unit>
        <trans-unit id="f798b0c0f90f69264c05dbb4746eb22431241a29" translate="yes" xml:space="preserve">
          <source>C keywords: default</source>
          <target state="translated">C 키워드 : 기본</target>
        </trans-unit>
        <trans-unit id="c3d42e0deed9be4fc77cafc32457174fa359ea25" translate="yes" xml:space="preserve">
          <source>C keywords: do</source>
          <target state="translated">C 키워드 : do</target>
        </trans-unit>
        <trans-unit id="a9d0b771025dc99314e2f0637bddf7cbf7602aac" translate="yes" xml:space="preserve">
          <source>C keywords: double</source>
          <target state="translated">C 키워드 : 더블</target>
        </trans-unit>
        <trans-unit id="3a6a0ba8f0aed6dd0bdbf1e28ba0cd8d4c096062" translate="yes" xml:space="preserve">
          <source>C keywords: else</source>
          <target state="translated">C 키워드 : else</target>
        </trans-unit>
        <trans-unit id="0d59e8885a30cf2c404b067251a56a9686c4680a" translate="yes" xml:space="preserve">
          <source>C keywords: enum</source>
          <target state="translated">C 키워드 : 열거 형</target>
        </trans-unit>
        <trans-unit id="7312b6a2fe886db62c316f52372b66d28c823610" translate="yes" xml:space="preserve">
          <source>C keywords: extern</source>
          <target state="translated">C 키워드 : extern</target>
        </trans-unit>
        <trans-unit id="bc94431cf882574a779c0aec755a45a2f7b530c7" translate="yes" xml:space="preserve">
          <source>C keywords: float</source>
          <target state="translated">C 키워드 : 플로트</target>
        </trans-unit>
        <trans-unit id="6fc96909e96bd7935bb3a7616bd5d016d59c942f" translate="yes" xml:space="preserve">
          <source>C keywords: for</source>
          <target state="translated">C 키워드 :</target>
        </trans-unit>
        <trans-unit id="ff6a74f8e86fbd66745ead6b6ba3ebe93f43ac4b" translate="yes" xml:space="preserve">
          <source>C keywords: fortran</source>
          <target state="translated">C 키워드 : 포트란</target>
        </trans-unit>
        <trans-unit id="c574828ab89e283f89de7b5bc3bbf68c09a59fb5" translate="yes" xml:space="preserve">
          <source>C keywords: goto</source>
          <target state="translated">C 키워드 : goto</target>
        </trans-unit>
        <trans-unit id="62c420a3462399a2cdf4f878f761c8b8c278f61a" translate="yes" xml:space="preserve">
          <source>C keywords: if</source>
          <target state="translated">C 키워드 : if</target>
        </trans-unit>
        <trans-unit id="a97f823dd318fa21c2e97fe8be7e1dc7baed6dc0" translate="yes" xml:space="preserve">
          <source>C keywords: inline (since C99)</source>
          <target state="translated">C 키워드 : 인라인 (C99 이후)</target>
        </trans-unit>
        <trans-unit id="8df78b5fefdedc92ad106a538884aa77670d7509" translate="yes" xml:space="preserve">
          <source>C keywords: int</source>
          <target state="translated">C 키워드 : int</target>
        </trans-unit>
        <trans-unit id="4767637f37a0721fc583dd82533e0558b32fb5b6" translate="yes" xml:space="preserve">
          <source>C keywords: long</source>
          <target state="translated">C 키워드 : long</target>
        </trans-unit>
        <trans-unit id="4572d75f6a5ebfe96ce22c33079dc976094359ee" translate="yes" xml:space="preserve">
          <source>C keywords: register</source>
          <target state="translated">C 키워드 : 등록</target>
        </trans-unit>
        <trans-unit id="79764e4605e47e7f696421a4847119c754498c27" translate="yes" xml:space="preserve">
          <source>C keywords: restrict</source>
          <target state="translated">C 키워드 : 제한</target>
        </trans-unit>
        <trans-unit id="b36253fa50e39d05465466d0a6c51414fdedd520" translate="yes" xml:space="preserve">
          <source>C keywords: return</source>
          <target state="translated">C 키워드 : 반환</target>
        </trans-unit>
        <trans-unit id="117fc03fbbb1cd95e26ffade247dccfa551447f3" translate="yes" xml:space="preserve">
          <source>C keywords: short</source>
          <target state="translated">C 키워드 : 짧은</target>
        </trans-unit>
        <trans-unit id="4b9aae1b69e8290c6dcab6888c6d586ef3ea3599" translate="yes" xml:space="preserve">
          <source>C keywords: signed</source>
          <target state="translated">C 키워드 : 서명</target>
        </trans-unit>
        <trans-unit id="f2bb9a6bd3b2fbdbf5168937c43676fb31e1477d" translate="yes" xml:space="preserve">
          <source>C keywords: sizeof</source>
          <target state="translated">C 키워드 : sizeof</target>
        </trans-unit>
        <trans-unit id="8880827f2b81e7d64ed4a6fc04f86f9143bbd556" translate="yes" xml:space="preserve">
          <source>C keywords: static</source>
          <target state="translated">C 키워드 : 정적</target>
        </trans-unit>
        <trans-unit id="9d9e13c529fbaad7b136eeb51c9b93b5db4d574c" translate="yes" xml:space="preserve">
          <source>C keywords: struct</source>
          <target state="translated">C 키워드 : 구조체</target>
        </trans-unit>
        <trans-unit id="dafb3dc8cd252155d1d8f47dca6de15d26cd2a22" translate="yes" xml:space="preserve">
          <source>C keywords: switch</source>
          <target state="translated">C 키워드 : 스위치</target>
        </trans-unit>
        <trans-unit id="087358aba6a590b2ab90404b3247ed15247ce47f" translate="yes" xml:space="preserve">
          <source>C keywords: typedef</source>
          <target state="translated">C 키워드 : typedef</target>
        </trans-unit>
        <trans-unit id="1e04d799c3d9b84d0ec0266cbc6e1aa14a3ba94d" translate="yes" xml:space="preserve">
          <source>C keywords: union</source>
          <target state="translated">C 키워드 : 연합</target>
        </trans-unit>
        <trans-unit id="fb99b9e2646fbf1e9d1fbfa9d08bfe0a806de934" translate="yes" xml:space="preserve">
          <source>C keywords: unsigned</source>
          <target state="translated">C 키워드 : 서명되지 않은</target>
        </trans-unit>
        <trans-unit id="195c0ae7f588efea965831acf345c1c17ac39c63" translate="yes" xml:space="preserve">
          <source>C keywords: void</source>
          <target state="translated">C 키워드 : 무효</target>
        </trans-unit>
        <trans-unit id="8e4da6553c62486c5c52bbab3dee8e34b64fee5d" translate="yes" xml:space="preserve">
          <source>C keywords: volatile</source>
          <target state="translated">C 키워드 : 휘발성</target>
        </trans-unit>
        <trans-unit id="b6c53e021f376fc8c0be266bf6434bd53837c1ce" translate="yes" xml:space="preserve">
          <source>C keywords: while</source>
          <target state="translated">C 키워드 : while</target>
        </trans-unit>
        <trans-unit id="91b79becc58238099e37212d187dd35b169ba357" translate="yes" xml:space="preserve">
          <source>C language</source>
          <target state="translated">C 언어</target>
        </trans-unit>
        <trans-unit id="f247a737aad973565e0ba61f676327ab62c8b7fc" translate="yes" xml:space="preserve">
          <source>C memory management library</source>
          <target state="translated">C 메모리 관리 라이브러리</target>
        </trans-unit>
        <trans-unit id="f546b4aa9a28fb61a154855a5ca4c09f150dc10e" translate="yes" xml:space="preserve">
          <source>C programs create, destroy, access, and manipulate objects.</source>
          <target state="translated">C 프로그램은 객체를 생성, 파괴, 액세스 및 조작합니다.</target>
        </trans-unit>
        <trans-unit id="577cba1265a06af20d2b556740cf4e6f66296754" translate="yes" xml:space="preserve">
          <source>C source code may be written in any 8-bit character set that includes the &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_646&quot;&gt;ISO 646:1983&lt;/a&gt; invariant character set, even non-ASCII ones. However, several C operators and punctuators require characters that are outside of the ISO 646 codeset: &lt;code&gt;{, }, [, ], #, \, ^, |, ~&lt;/code&gt;. To be able to use character encodings where some or all of these symbols do not exist (such as the German &lt;a href=&quot;http://de.wikipedia.org/wiki/DIN_66003&quot;&gt;DIN 66003&lt;/a&gt;), there are two possibilities: alternative spellings of operators that use these characters or special combinations of two or three ISO 646 compatible characters that are interpreted as if they were a single non-ISO 646 character.</source>
          <target state="translated">C 소스 코드는 &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_646&quot;&gt;ISO 646 : 1983&lt;/a&gt; 불변 문자 세트, 심지어 비 ASCII 문자 세트를 포함하는 8 비트 문자 세트로 작성 될 수 있습니다 . 그러나 여러 C 연산자와 문장 부호에는 ISO 646 코드 세트 ( &lt;code&gt;{, }, [, ], #, \, ^, |, ~&lt;/code&gt; 외부의 문자가 필요합니다 . 이러한 기호 중 일부 또는 전부가 존재하지 않는 경우 (예 : 독일어 &lt;a href=&quot;http://de.wikipedia.org/wiki/DIN_66003&quot;&gt;DIN 66003&lt;/a&gt; ) 문자 인코딩을 사용하려면 두 가지 가능성이 있습니다. 이러한 문자를 사용하는 연산자의 대체 철자 또는 두 개 또는 세 개의 ISO 646 호환 문자의 특수 조합 마치 ISO 646이 아닌 단일 문자 인 것으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="d88a29df1d30dee79bf5cbde0b208d4dfe6c6510" translate="yes" xml:space="preserve">
          <source>C standard</source>
          <target state="translated">C 표준</target>
        </trans-unit>
        <trans-unit id="79c384f1ba053ea6a78d8c958d790e56d9052ca1" translate="yes" xml:space="preserve">
          <source>C string holding the name of the desired category</source>
          <target state="translated">원하는 카테고리의 이름을 보유한 C 문자열</target>
        </trans-unit>
        <trans-unit id="437c617752c611b36293355138fcbc5720307f88" translate="yes" xml:space="preserve">
          <source>C string holding the name of the desired mapping.</source>
          <target state="translated">원하는 맵핑 이름을 보유한 C 문자열.</target>
        </trans-unit>
        <trans-unit id="2426cb4ee79941311c0b2e401e3e16727f45af56" translate="yes" xml:space="preserve">
          <source>C supports two different forms of function definitions:</source>
          <target state="translated">C는 두 가지 다른 형태의 함수 정의를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="ed49d634ae356d7361bc64d793e6736fa4d6bcfc" translate="yes" xml:space="preserve">
          <source>C++ imposes additional limitations on the &lt;code&gt;goto&lt;/code&gt; statement, but allows labels before declarations (which are statements in C++).</source>
          <target state="translated">C ++는 &lt;code&gt;goto&lt;/code&gt; 문 에 추가 제한을 부과 하지만 선언 앞에 레이블 (C ++의 문)을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="27007198c75e9f26b239199b91632e30ae50d365" translate="yes" xml:space="preserve">
          <source>C++ pragmas in Visual Studio 2010</source>
          <target state="translated">Visual Studio 2010의 C ++ pragma</target>
        </trans-unit>
        <trans-unit id="59267432adf8c9336c020edab8c6d1687c5a8555" translate="yes" xml:space="preserve">
          <source>C++-style</source>
          <target state="translated">C++-style</target>
        </trans-unit>
        <trans-unit id="3c67bb4ebdd2ba43c17681cb6c05aab34159eee9" translate="yes" xml:space="preserve">
          <source>C++-style comments are usually used to comment single lines of text or code; however, they can be placed together to form multi-line comments. To insert text as a C++-style comment, simply precede the text with &lt;code&gt;//&lt;/code&gt; and follow the text with the new line character. C++-style comments tell the compiler to ignore all content between &lt;code&gt;//&lt;/code&gt; and a new line.</source>
          <target state="translated">C ++ 스타일 주석은 일반적으로 한 줄의 텍스트 나 코드에 주석을다는 데 사용됩니다. 그러나 여러 줄 주석을 만들기 위해 함께 배치 할 수 있습니다. C ++ 스타일 주석으로 텍스트를 삽입하려면 텍스트 앞에 &lt;code&gt;//&lt;/code&gt; 를 붙이고 텍스트 뒤에 줄 바꿈 문자를 붙이십시오. C ++ 스타일 주석은 &lt;code&gt;//&lt;/code&gt; 와 줄 바꿈 사이의 모든 내용을 무시하도록 컴파일러에 지시 합니다.</target>
        </trans-unit>
        <trans-unit id="bd39761895022d52ef2184edffb0689497519cb3" translate="yes" xml:space="preserve">
          <source>C-style</source>
          <target state="translated">C-style</target>
        </trans-unit>
        <trans-unit id="0b9b1d01ffcd7c91aa5db3dfba413b80ea8d1087" translate="yes" xml:space="preserve">
          <source>C-style comments are usually used to comment large blocks of text or small fragments of code; however, they can be used to comment single lines. To insert text as a C-style comment, simply surround the text with &lt;code&gt;/*&lt;/code&gt; and &lt;code&gt;*/&lt;/code&gt;. C-style comments tell the compiler to ignore all content between &lt;code&gt;/*&lt;/code&gt; and &lt;code&gt;*/&lt;/code&gt;. Although it is not part of the C standard, &lt;code&gt;/**&lt;/code&gt; and &lt;code&gt;*/&lt;/code&gt; are often used to indicate documentation blocks; this is legal because the second asterisk is simply treated as part of the comment.</source>
          <target state="translated">C 스타일 주석은 일반적으로 큰 텍스트 블록이나 작은 코드 조각을 주석으로 처리하는 데 사용됩니다. 그러나 한 줄을 주석 처리하는 데 사용할 수 있습니다. C 스타일 주석으로 텍스트를 삽입하려면 &lt;code&gt;/*&lt;/code&gt; 및 &lt;code&gt;*/&lt;/code&gt; 로 텍스트를 둘러싸십시오 . C 스타일 주석은 컴파일러에게 &lt;code&gt;/*&lt;/code&gt; 와 &lt;code&gt;*/&lt;/code&gt; 사이의 모든 내용을 무시하도록 지시 합니다. C 표준의 일부는 아니지만 &lt;code&gt;/**&lt;/code&gt; 및 &lt;code&gt;*/&lt;/code&gt; 는 종종 문서 블록을 나타내는 데 사용됩니다. 이것은 두 번째 별표가 단순히 주석의 일부로 취급되기 때문에 합법적입니다.</target>
        </trans-unit>
        <trans-unit id="261d0f1299c6d923d77533902d4aaab0184c41c8" translate="yes" xml:space="preserve">
          <source>C11 standard (ISO/IEC 9899:2011):</source>
          <target state="translated">C11 표준 (ISO / IEC 9899 : 2011) :</target>
        </trans-unit>
        <trans-unit id="9cd19e0c483895b4c4dca1dfee6e5ff438628642" translate="yes" xml:space="preserve">
          <source>C11, as published, specified that this function is per-object, not per-type. This was corrected by DR 465.</source>
          <target state="translated">공개 된 C11은이 기능이 유형별이 아니라 객체 별임을 지정했습니다. 이것은 DR 465에 의해 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="dc6cecb4527f2e14095c486e78d7793077fa54f6" translate="yes" xml:space="preserve">
          <source>C17 standard (ISO/IEC 9899:2018):</source>
          <target state="translated">C17 표준 (ISO / IEC 9899 : 2018) :</target>
        </trans-unit>
        <trans-unit id="65819a01f96020ce9b84e3f226d24b0b43cc98ec" translate="yes" xml:space="preserve">
          <source>C89/C90 standard (ISO/IEC 9899:1990):</source>
          <target state="translated">C89 / C90 표준 (ISO / IEC 9899 : 1990) :</target>
        </trans-unit>
        <trans-unit id="4950e31032ac031befcea4756381cc9748081edb" translate="yes" xml:space="preserve">
          <source>C99 standard (ISO/IEC 9899:1999):</source>
          <target state="translated">C99 표준 (ISO / IEC 9899 : 1999) :</target>
        </trans-unit>
        <trans-unit id="24fc58ea2f98cd20a27008421ec7f7e3dfc35435" translate="yes" xml:space="preserve">
          <source>CHAR_BIT</source>
          <target state="translated">CHAR_BIT</target>
        </trans-unit>
        <trans-unit id="725f72738449b33d5ed2db35158ace2f646b043c" translate="yes" xml:space="preserve">
          <source>CHAR_MAX</source>
          <target state="translated">CHAR_MAX</target>
        </trans-unit>
        <trans-unit id="b30c9342a5465cef0a56934460b3bfa4e2e74c49" translate="yes" xml:space="preserve">
          <source>CHAR_MIN</source>
          <target state="translated">CHAR_MIN</target>
        </trans-unit>
        <trans-unit id="789b032a45d264e7a02138bff69b47aacb370fca" translate="yes" xml:space="preserve">
          <source>CLOCKS_PER_SEC</source>
          <target state="translated">CLOCKS_PER_SEC</target>
        </trans-unit>
        <trans-unit id="d03fa4788d162e10e0a9157c0182737d266d25dd" translate="yes" xml:space="preserve">
          <source>CMPLXCMPLXFCMPLXL</source>
          <target state="translated">CMPLXCMPLXFCMPLXL</target>
        </trans-unit>
        <trans-unit id="33cd69fa90839e408dab31b3614bbcdf87603f0c" translate="yes" xml:space="preserve">
          <source>CMPLXF, CMPLX, CMPLXL</source>
          <target state="translated">CMPLXF, CMPLX, CMPLXL</target>
        </trans-unit>
        <trans-unit id="b31dcd4d9874928426f6c96cb8a45435ad4f4f43" translate="yes" xml:space="preserve">
          <source>CMPLXL</source>
          <target state="translated">CMPLXL</target>
        </trans-unit>
        <trans-unit id="77ea7aa743c8ae5ceebe6476bf7df6ad49a72839" translate="yes" xml:space="preserve">
          <source>Call once</source>
          <target state="translated">한 번 전화</target>
        </trans-unit>
        <trans-unit id="4880a798b93c1b0de51af512420e2ef8cc83ab95" translate="yes" xml:space="preserve">
          <source>Call to a function with a prototype</source>
          <target state="translated">프로토 타입으로 함수 호출</target>
        </trans-unit>
        <trans-unit id="3901637e234ca0b63b4410c0ce6911729acd8c78" translate="yes" xml:space="preserve">
          <source>Call to a function without a prototype</source>
          <target state="translated">프로토 타입이없는 함수 호출</target>
        </trans-unit>
        <trans-unit id="f514aa0539c8746a97d9256b1f83110e75de13e4" translate="yes" xml:space="preserve">
          <source>Call, Comma, Ternary</source>
          <target state="translated">전화, 쉼표, 3 차</target>
        </trans-unit>
        <trans-unit id="ddde78f62d1b14d42265185475cdd0f871ebd9eb" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;snprintf&lt;/code&gt; with zero &lt;code&gt;bufsz&lt;/code&gt; and null pointer for &lt;code&gt;buffer&lt;/code&gt; is useful to determine the necessary buffer size to contain the output:</source>
          <target state="translated">&lt;code&gt;bufsz&lt;/code&gt; 가 0 이고 &lt;code&gt;buffer&lt;/code&gt; 널 포인터가있는 &lt;code&gt;snprintf&lt;/code&gt; 를 호출 하면 출력을 포함하는 데 필요한 버퍼 크기를 결정하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="1590423ec88dccd74976d9c0b4a15cd539e5de0f" translate="yes" xml:space="preserve">
          <source>Calling the function from several threads does not induce a data race. The implementation shall support the registration of at least &lt;code&gt;32&lt;/code&gt; functions.</source>
          <target state="translated">여러 스레드에서 함수를 호출해도 데이터 경쟁이 발생하지 않습니다. 이 구현은 &lt;code&gt;32&lt;/code&gt; 개 이상의 기능 등록을 지원해야 합니다.</target>
        </trans-unit>
        <trans-unit id="69c9c5c35564ca07b6ae1737d8a6eff19ce6279f" translate="yes" xml:space="preserve">
          <source>Calls the host environment's command processor with the parameter &lt;code&gt;command&lt;/code&gt;. Returns an implementation-defined value (usually the value that the invoked program returns).</source>
          <target state="translated">parameter &lt;code&gt;command&lt;/code&gt; 사용하여 호스트 환경의 명령 프로세서를 호출합니다 . 구현 정의 값 (보통 호출 된 프로그램이 반환하는 값)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ca09c54bff74a82bae543ebe259f7452ee8c5293" translate="yes" xml:space="preserve">
          <source>Capabilities</source>
          <target state="translated">Capabilities</target>
        </trans-unit>
        <trans-unit id="6ccd1e19a995de897833876a1022c105f3fdec2a" translate="yes" xml:space="preserve">
          <source>Care must be taken when comparing floating-point values for equality, because the results of many operations cannot be represented exactly and must be rounded. In practice, floating-point numbers are usually compared allowing for the difference of one or more units of the last place.</source>
          <target state="translated">많은 연산의 결과를 정확하게 표현할 수없고 반올림해야하므로 부동 소수점 값이 동일한 지 비교할 때는주의를 기울여야합니다. 실제로, 부동 소수점 숫자는 일반적으로 마지막 장소의 하나 이상의 단위 차이를 허용하도록 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="74473f63620ac45f2911b86a7f11c6501a7660cd" translate="yes" xml:space="preserve">
          <source>Cast and assignment strip away any extraneous range and precision: this models the action of storing a value from an extended-precision FPU register into a standard-sized memory location.</source>
          <target state="translated">캐스트 및 할당은 불필요한 범위와 정밀도를 제거합니다. 이는 확장 정밀 FPU 레지스터의 값을 표준 크기의 메모리 위치에 저장하는 동작을 모델링합니다.</target>
        </trans-unit>
        <trans-unit id="97ba68fc56a3efba444f7c6353ffce14d1fabcb2" translate="yes" xml:space="preserve">
          <source>Cast operator</source>
          <target state="translated">캐스트 연산자</target>
        </trans-unit>
        <trans-unit id="97fa7d1aa53dee3582d247166c0630bb95546ab9" translate="yes" xml:space="preserve">
          <source>Cast operators</source>
          <target state="translated">캐스트 연산자</target>
        </trans-unit>
        <trans-unit id="65d75a1f3269b2efa27b067212f26c8863bd9bf8" translate="yes" xml:space="preserve">
          <source>Categorizes floating point value &lt;code&gt;arg&lt;/code&gt; into the following categories: zero, subnormal, normal, infinite, NAN, or implementation-defined category. The macro returns an integral value.</source>
          <target state="translated">부동 소수점 값 &lt;code&gt;arg&lt;/code&gt; 를 0, subnormal, normal, infinite, NAN 또는 구현 정의 범주로 분류합니다. 매크로는 정수 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1e425fda009fc1318071c020b813ea73240be6c9" translate="yes" xml:space="preserve">
          <source>Causes abnormal program termination unless &lt;code&gt;&lt;a href=&quot;sig_types&quot;&gt;SIGABRT&lt;/a&gt;&lt;/code&gt; is being caught by a signal handler passed to signal and the handler does not return.</source>
          <target state="translated">신호에 전달 된 신호 처리기에 의해 &lt;code&gt;&lt;a href=&quot;sig_types&quot;&gt;SIGABRT&lt;/a&gt;&lt;/code&gt; 가 포착되지 않고 처리기가 리턴하지 않으면 비정상적인 프로그램 종료가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="a5fc98a179eaefefc7383473561adf59469b047c" translate="yes" xml:space="preserve">
          <source>Causes normal program termination to occur without completely cleaning the resources.</source>
          <target state="translated">리소스를 완전히 정리하지 않고 정상적인 프로그램 종료가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="03d84237d77c18a1ea9454f00c0d5a2c4def6e6a" translate="yes" xml:space="preserve">
          <source>Causes normal program termination to occur.</source>
          <target state="translated">정상적인 프로그램 종료가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="405fa0979a11ab8b89968a0b69245a9c1cfe58b8" translate="yes" xml:space="preserve">
          <source>Causes the enclosing &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt;, &lt;a href=&quot;while&quot;&gt;while&lt;/a&gt; or &lt;a href=&quot;do&quot;&gt;do-while&lt;/a&gt; loop or &lt;a href=&quot;switch&quot;&gt; switch statement&lt;/a&gt; to terminate.</source>
          <target state="translated">&lt;a href=&quot;for&quot;&gt;for&lt;/a&gt; , &lt;a href=&quot;while&quot;&gt;while&lt;/a&gt; 또는 &lt;a href=&quot;do&quot;&gt;do-while&lt;/a&gt; 루프 또는 &lt;a href=&quot;switch&quot;&gt;switch 문&lt;/a&gt; 을 둘러 쌉니다 .</target>
        </trans-unit>
        <trans-unit id="aac02b11ecaab94b12608001eae57b3a907465aa" translate="yes" xml:space="preserve">
          <source>Causes the remaining portion of the enclosing &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt;, &lt;a href=&quot;while&quot;&gt;while&lt;/a&gt; or &lt;a href=&quot;do&quot;&gt; do-while&lt;/a&gt; loop body to be skipped.</source>
          <target state="translated">&lt;a href=&quot;for&quot;&gt;for&lt;/a&gt; , &lt;a href=&quot;while&quot;&gt;while&lt;/a&gt; 또는 &lt;a href=&quot;do&quot;&gt;do-while&lt;/a&gt; 루프 본문 의 나머지 부분을 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="580812cfd060f7d050c66b73bd05ae797afde816" translate="yes" xml:space="preserve">
          <source>Certain &lt;a href=&quot;operator_arithmetic&quot;&gt;addition, subtraction&lt;/a&gt;, &lt;a href=&quot;operator_assignment&quot;&gt;compound assignment&lt;/a&gt;, &lt;a href=&quot;operator_incdec&quot;&gt;increment, and decrement&lt;/a&gt; operators are defined for pointers to elements of arrays.</source>
          <target state="translated">특정 &lt;a href=&quot;operator_arithmetic&quot;&gt;더하기, 빼기&lt;/a&gt; , &lt;a href=&quot;operator_assignment&quot;&gt;복합 할당&lt;/a&gt; , &lt;a href=&quot;operator_incdec&quot;&gt;증분 및 감소&lt;/a&gt; 연산자는 배열 요소에 대한 포인터에 대해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="f422128bf228bfdfc5c9bb732010edf878de2dd7" translate="yes" xml:space="preserve">
          <source>Certain words in a C program have special meaning, they are &lt;a href=&quot;../keyword&quot;&gt;keywords&lt;/a&gt;. Others can be used as &lt;a href=&quot;identifier&quot;&gt;identifiers&lt;/a&gt;, which may be used to identify &lt;a href=&quot;object&quot;&gt;objects&lt;/a&gt;, &lt;a href=&quot;functions&quot;&gt;functions&lt;/a&gt;, &lt;a href=&quot;struct&quot;&gt;struct&lt;/a&gt;, &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt;, or &lt;a href=&quot;enum&quot;&gt;enumeration&lt;/a&gt; tags, their members, &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; names, &lt;a href=&quot;statements#Labels&quot;&gt;labels&lt;/a&gt;, or &lt;a href=&quot;../preprocessor/replace&quot;&gt;macros&lt;/a&gt;.</source>
          <target state="translated">C 프로그램의 특정 단어는 특별한 의미를 가지며 &lt;a href=&quot;../keyword&quot;&gt;키워드&lt;/a&gt; 입니다. 다른 것들은 &lt;a href=&quot;identifier&quot;&gt;식별자&lt;/a&gt; 로 사용될 수 있으며 , &lt;a href=&quot;object&quot;&gt;객체&lt;/a&gt; , &lt;a href=&quot;functions&quot;&gt;함수&lt;/a&gt; , &lt;a href=&quot;struct&quot;&gt;구조체&lt;/a&gt; , &lt;a href=&quot;union&quot;&gt;공용체&lt;/a&gt; 또는 &lt;a href=&quot;enum&quot;&gt;열거&lt;/a&gt; 태그, 그 멤버, &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; 이름, &lt;a href=&quot;statements#Labels&quot;&gt;레이블&lt;/a&gt; 또는 &lt;a href=&quot;../preprocessor/replace&quot;&gt;매크로&lt;/a&gt; 를 식별하는 데 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a3614333e503e3f84b18d0f8a9ccba18b5aa755e" translate="yes" xml:space="preserve">
          <source>Changes the current line number and file name in the preprocessor.</source>
          <target state="translated">전 처리기에서 현재 줄 번호와 파일 이름을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="bcd3bc7bc25f117f48576a1067f3eab87dc09962" translate="yes" xml:space="preserve">
          <source>Changes the filename of a file. The file is identified by character string pointed to by &lt;code&gt;old_filename&lt;/code&gt;. The new filename is identified by character string pointed to by &lt;code&gt;new_filename&lt;/code&gt;.</source>
          <target state="translated">파일의 파일 이름을 변경합니다. 파일은 &lt;code&gt;old_filename&lt;/code&gt; 이 가리키는 문자열로 식별됩니다 . 새 파일 이름은 &lt;code&gt;new_filename&lt;/code&gt; 이 가리키는 문자열로 식별됩니다 .</target>
        </trans-unit>
        <trans-unit id="9f1702f311546e930d8f583ff60c5b7dafb56f91" translate="yes" xml:space="preserve">
          <source>Changes the the buffering mode of the given file stream &lt;code&gt;stream&lt;/code&gt; as indicated by the argument &lt;code&gt;mode&lt;/code&gt;. In addition,</source>
          <target state="translated">인수 &lt;code&gt;mode&lt;/code&gt; 로 표시되는 지정된 파일 스트림 &lt;code&gt;stream&lt;/code&gt; 의 버퍼링 모드를 변경 합니다 . 게다가,</target>
        </trans-unit>
        <trans-unit id="6512adfeb2b6b71a8085a0b4569a9025105f6ea1" translate="yes" xml:space="preserve">
          <source>Character array manipulation</source>
          <target state="translated">문자 배열 조작</target>
        </trans-unit>
        <trans-unit id="11a965778572465b297760373bc0ab9a5fe50dd4" translate="yes" xml:space="preserve">
          <source>Character classification</source>
          <target state="translated">문자 분류</target>
        </trans-unit>
        <trans-unit id="fb797cfcfb3f8dadf93dcc6665528c24781954df" translate="yes" xml:space="preserve">
          <source>Character constants</source>
          <target state="translated">문자 상수</target>
        </trans-unit>
        <trans-unit id="34a7ab398acc718f6548cdc2f8cf73c1cb95496f" translate="yes" xml:space="preserve">
          <source>Character constants, when evaluated in &lt;code&gt;#if&lt;/code&gt;-expressions, may be interpreted in the source character set, the execution character set, or some other implementation-defined character set.</source>
          <target state="translated">&lt;code&gt;#if&lt;/code&gt; -expressions 에서 평가 될 때 문자 상수 는 소스 문자 세트, 실행 문자 세트 또는 기타 구현 정의 문자 세트에서 해석 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="71abf6f6cdd425368811b306d03c5406b82396a5" translate="yes" xml:space="preserve">
          <source>Character manipulation</source>
          <target state="translated">캐릭터 조작</target>
        </trans-unit>
        <trans-unit id="ce6ddaa694e2a7b4942fbc87cf18e8f64d26f9b2" translate="yes" xml:space="preserve">
          <source>Character types</source>
          <target state="translated">문자 종류</target>
        </trans-unit>
        <trans-unit id="7583a23f352a0114e03ecd5b421ac82f127e76d4" translate="yes" xml:space="preserve">
          <source>Checks if the end of the given file stream has been reached.</source>
          <target state="translated">주어진 파일 스트림의 끝에 도달했는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="a80411bf63939bb5325e4f8c8df73adae4f03bdc" translate="yes" xml:space="preserve">
          <source>Checks if the given character can be printed, i.e. it is either a number (&lt;code&gt;0123456789&lt;/code&gt;), an uppercase letter (&lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;), a lowercase letter (&lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;), a punctuation character(&lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt;), or space, or any character classified as printable by the current C locale.</source>
          <target state="translated">주어진 문자를 인쇄 할 수 있는지 확인합니다. 즉, 숫자 ( &lt;code&gt;0123456789&lt;/code&gt; ), 대문자 ( &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; ), 소문자 ( &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; ), 문장 부호 문자 ( &lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt; ) 또는 공백 또는 현재 C 로케일로 인쇄 가능한 것으로 분류 된 문자</target>
        </trans-unit>
        <trans-unit id="5cd50516db04d878a383e0474cbd44271fb0cbcd" translate="yes" xml:space="preserve">
          <source>Checks if the given character has a graphical representation, i.e. it is either a number (&lt;code&gt;0123456789&lt;/code&gt;), an uppercase letter (&lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;), a lowercase letter (&lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;), or a punctuation character(&lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt;), or any graphical character specific to the current C locale.</source>
          <target state="translated">주어진 문자가 그래픽으로 표현되는지 확인합니다. 즉, 숫자 ( &lt;code&gt;0123456789&lt;/code&gt; ), 대문자 ( &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; ), 소문자 ( &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; ) 또는 문장 부호 문자 ( &lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt; ) 또는 현재 C 로케일에 특정한 그래픽 문자입니다.</target>
        </trans-unit>
        <trans-unit id="a9eb05afb3b38c63c5335df9e7e4ec728a94a143" translate="yes" xml:space="preserve">
          <source>Checks if the given character is a blank character in the current C locale. In the default C locale, only space (&lt;code&gt;0x20&lt;/code&gt;) and horizontal tab (&lt;code&gt;0x09&lt;/code&gt;) are classified as blank.</source>
          <target state="translated">주어진 문자가 현재 C 로캘에서 빈 문자인지 확인합니다. 기본 C 로캘에서는 공백 ( &lt;code&gt;0x20&lt;/code&gt; )과 가로 탭 ( &lt;code&gt;0x09&lt;/code&gt; ) 만 공백으로 분류됩니다.</target>
        </trans-unit>
        <trans-unit id="33fe2d2ab596854468dce386087d212e312337e6" translate="yes" xml:space="preserve">
          <source>Checks if the given character is a control character, i.e. codes &lt;code&gt;0x00-0x1F&lt;/code&gt; and &lt;code&gt;0x7F&lt;/code&gt;.</source>
          <target state="translated">주어진 문자가 제어 문자인지 확인합니다 (예 : 코드 &lt;code&gt;0x00-0x1F&lt;/code&gt; 및 &lt;code&gt;0x7F&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="b81bc3069e91e958c3b48b56b856e7a064d982cb" translate="yes" xml:space="preserve">
          <source>Checks if the given character is a hexadecimal numeric character (&lt;code&gt;0123456789abcdefABCDEF&lt;/code&gt;) or is classified as a hexadecimal character.</source>
          <target state="translated">주어진 문자가 16 진 숫자 ( &lt;code&gt;0123456789abcdefABCDEF&lt;/code&gt; )인지 16 진 문자로 분류 되는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="5ca278746bc9e114b2661e67e9d27426ef8645a2" translate="yes" xml:space="preserve">
          <source>Checks if the given character is a numeric character (&lt;code&gt;0123456789&lt;/code&gt;).</source>
          <target state="translated">주어진 문자가 숫자 문자인지 확인합니다 ( &lt;code&gt;0123456789&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="837e27bbd4c4f9b720edba791bc0a1c76ee5a46e" translate="yes" xml:space="preserve">
          <source>Checks if the given character is a punctuation character in the current C locale. The default C locale classifies the characters &lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt; as punctuation.</source>
          <target state="translated">지정된 문자가 현재 C 로캘의 문장 부호 문자인지 확인합니다. 기본 C 로케일은 &lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt; 문자를 문장 부호로 분류합니다.</target>
        </trans-unit>
        <trans-unit id="175dc8fef53c9b8998a48bfa272af43d8ca70a35" translate="yes" xml:space="preserve">
          <source>Checks if the given character is a whitespace character, i.e. either space (&lt;code&gt;0x20&lt;/code&gt;), form feed (&lt;code&gt;0x0c&lt;/code&gt;), line feed (&lt;code&gt;0x0a&lt;/code&gt;), carriage return (&lt;code&gt;0x0d&lt;/code&gt;), horizontal tab (&lt;code&gt;0x09&lt;/code&gt;) or vertical tab (&lt;code&gt;0x0b&lt;/code&gt;).</source>
          <target state="translated">주어진 문자가 공백 문자인지 확인합니다 (예 : 공백 ( &lt;code&gt;0x20&lt;/code&gt; ), 폼 피드 ( &lt;code&gt;0x0c&lt;/code&gt; ), 줄 바꿈 ( &lt;code&gt;0x0a&lt;/code&gt; ), 캐리지 리턴 ( &lt;code&gt;0x0d&lt;/code&gt; ), 가로 탭 ( &lt;code&gt;0x09&lt;/code&gt; ) 또는 세로 탭 ( &lt;code&gt;0x0b&lt;/code&gt; ))</target>
        </trans-unit>
        <trans-unit id="707e4e9ff428a06747d7018e5e02fddc801826d0" translate="yes" xml:space="preserve">
          <source>Checks if the given character is an alphabetic character, i.e. either an uppercase letter (&lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;), or a lowercase letter (&lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;).</source>
          <target state="translated">주어진 문자가 알파벳 문자인지, 즉 대문자 ( &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; ) 또는 소문자 ( &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; )인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="8460053f4f6257cbef25ff160120cc6c7e959e75" translate="yes" xml:space="preserve">
          <source>Checks if the given character is an alphanumeric character as classified by the current C locale. In the default locale, the following characters are alphanumeric:</source>
          <target state="translated">주어진 문자가 현재 C 로케일로 분류 된 영숫자 문자인지 확인합니다. 기본 로케일에서 다음 문자는 영숫자입니다.</target>
        </trans-unit>
        <trans-unit id="72a25eda93d278cea5691863e59bd4331e5ca8e4" translate="yes" xml:space="preserve">
          <source>Checks if the given character is an uppercase character according to the current C locale. In the default &quot;C&quot; locale, &lt;code&gt;isupper&lt;/code&gt; returns true only for the uppercase letters (&lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;).</source>
          <target state="translated">주어진 문자가 현재 C 로케일에 따라 대문자인지 확인합니다. 기본 &quot;C&quot;로케일에서 &lt;code&gt;isupper&lt;/code&gt; 는 대문자 ( &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; )에 대해서만 true를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="9fe61f7d08ea23e640364b8edb24f7095af3e4b6" translate="yes" xml:space="preserve">
          <source>Checks if the given character is classified as a lowercase character according to the current C locale. In the default &quot;C&quot; locale, &lt;code&gt;islower&lt;/code&gt; returns true only for the lowercase letters (&lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;).</source>
          <target state="translated">주어진 문자가 현재 C 로케일에 따라 소문자로 분류되는지 확인합니다. 기본 &quot;C&quot;로케일에서 &lt;code&gt;islower&lt;/code&gt; 는 소문자 ( &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; )에 대해서만 true를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="86e15e5f001ace8d5ed732d67f679b17b8027345" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character can be printed, i.e. it is either a number (&lt;code&gt;0123456789&lt;/code&gt;), an uppercase letter (&lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;), a lowercase letter (&lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;), a punctuation character(&lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt;), space or any printable character specific to the current C locale.</source>
          <target state="translated">지정된 넓은 문자를 인쇄 할 수 있는지 확인합니다. 즉, 숫자 ( &lt;code&gt;0123456789&lt;/code&gt; ), 대문자 ( &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; ), 소문자 ( &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; ), 문장 부호 문자 ( &lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt; ), 공백 또는 현재 C 로케일에 특정한 인쇄 가능한 문자.</target>
        </trans-unit>
        <trans-unit id="6ddf1d4606203515c454d3cbf72c353c2b7a5550" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character corresponds (if narrowed) to a hexadecimal numeric character, i.e. one of &lt;code&gt;0123456789abcdefABCDEF&lt;/code&gt;.</source>
          <target state="translated">주어진 넓은 문자가 16 진수 (예 : &lt;code&gt;0123456789abcdefABCDEF&lt;/code&gt; 중 하나)에 해당하는지 (좁은 경우) 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="d54601d6790c54f44a419455b6b691579d6df40d" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character corresponds (if narrowed) to one of the ten decimal digit characters 0123456789.</source>
          <target state="translated">주어진 넓은 문자가 10 진수 10 진수 0123456789 중 하나에 해당하는지 (좁은 경우) 확인합니다.</target>
        </trans-unit>
        <trans-unit id="901c321d30a4b9e0c1bb0f4ce4f0b7f3fc5086ff" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character has a graphical representation, i.e. it is either a number (&lt;code&gt;0123456789&lt;/code&gt;), an uppercase letter (&lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;), a lowercase letter (&lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;), a punctuation character(&lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt;) or any graphical character specific to the current C locale.</source>
          <target state="translated">주어진 넓은 문자가 그래픽 표현인지, 즉 숫자 ( &lt;code&gt;0123456789&lt;/code&gt; ), 대문자 ( &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; ), 소문자 ( &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; ), 문장 부호 문자 ( &lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt; ) 또는 현재 C 로케일에 특정한 그래픽 문자.</target>
        </trans-unit>
        <trans-unit id="69347e858d3166f00f30fe95f9dd5f5ae37bc816" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is a control character, i.e. codes &lt;code&gt;0x00-0x1F&lt;/code&gt; and &lt;code&gt;0x7F&lt;/code&gt; and any control characters specific to the current locale.</source>
          <target state="translated">지정된 와이드 문자가 제어 문자 (예 : 코드 &lt;code&gt;0x00-0x1F&lt;/code&gt; 및 &lt;code&gt;0x7F&lt;/code&gt; ) 및 현재 로케일에 특정한 제어 문자인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="f75e93760224f49060fa9daae484b93562cec26c" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is a lowercase letter, i.e. one of &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; or any lowercase letter specific to the current locale.</source>
          <target state="translated">주어진 넓은 문자가 소문자인지, 즉 &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; 또는 현재 로케일에 특정한 소문자인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="d3bc1df8c65e55dc36b4066a3cfbf00b5eb6d139" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is a punctuation character, i.e. it is one of &lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt; or any punctuation character specific to the current locale.</source>
          <target state="translated">주어진 넓은 문자가 구두점 문자인지 확인합니다. 즉, &lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt; 또는 현재 로케일에 고유 한 문장 부호 문자입니다.</target>
        </trans-unit>
        <trans-unit id="298e43db40ce5c6ddedf760c6d9d06385fec714f" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is a whitespace character, i.e. either space (&lt;code&gt;0x20&lt;/code&gt;), form feed (&lt;code&gt;0x0c&lt;/code&gt;), line feed (&lt;code&gt;0x0a&lt;/code&gt;), carriage return (&lt;code&gt;0x0d&lt;/code&gt;), horizontal tab (&lt;code&gt;0x09&lt;/code&gt;), vertical tab (&lt;code&gt;0x0b&lt;/code&gt;) or any whitespace character specific to the current locale.</source>
          <target state="translated">주어진 넓은 문자가 공백 문자인지 확인합니다. 즉 공백 ( &lt;code&gt;0x20&lt;/code&gt; ), 폼 피드 ( &lt;code&gt;0x0c&lt;/code&gt; ), 줄 바꿈 ( &lt;code&gt;0x0a&lt;/code&gt; ), 캐리지 리턴 ( &lt;code&gt;0x0d&lt;/code&gt; ), 가로 탭 ( &lt;code&gt;0x09&lt;/code&gt; ), 세로 탭 ( &lt;code&gt;0x0b&lt;/code&gt; ) 또는 공백 현재 로케일에 특정한 문자.</target>
        </trans-unit>
        <trans-unit id="ecee395d873139c5f79bbced8e5ab2094298ef99" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is an alphabetic character, i.e. either an uppercase letter (&lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;), a lowercase letter (&lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;) or any alphabetic character specific to the current locale.</source>
          <target state="translated">주어진 넓은 문자가 알파벳 문자인지, 즉 대문자 ( &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; ), 소문자 ( &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; ) 또는 현재 로케일에 특정한 알파벳 문자인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="5467527cb982943f926960fa171baeacafcc85de" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is an alphanumeric character, i.e. either a number (&lt;code&gt;0123456789&lt;/code&gt;), an uppercase letter (&lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;), a lowercase letter (&lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;) or any alphanumeric character specific to the current locale.</source>
          <target state="translated">주어진 넓은 문자가 영숫자 문자인지, 즉 숫자 ( &lt;code&gt;0123456789&lt;/code&gt; ), 대문자 ( &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; ), 소문자 ( &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; ) 또는 현재 로케일에 특정한 영숫자 문자인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="43c33322c3d3cfbcbf8bd68f060fd927a3eb782d" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is an uppercase letter, i.e. one of &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; or any uppercase letter specific to the current locale.</source>
          <target state="translated">지정된 와이드 문자가 대문자인지 (즉, &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; 또는 현재 로케일에 특정한 대문자)인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="1541b6076382859c29bdb454303ad0411f5bf188" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is classified as blank character (that is, a whitespace character used to separate words in a sentence) by the current C locale. In the default C locale, only space (&lt;code&gt;0x20&lt;/code&gt;) and horizontal tab (&lt;code&gt;0x09&lt;/code&gt;) are blank characters.</source>
          <target state="translated">주어진 와이드 문자가 현재 C 로케일에 의해 공백 문자 (문에서 단어를 구분하는 데 사용되는 공백 문자)로 분류되는지 확인합니다. 기본 C 로캘에서는 공백 ( &lt;code&gt;0x20&lt;/code&gt; )과 가로 탭 ( &lt;code&gt;0x09&lt;/code&gt; ) 만 공백 문자입니다.</target>
        </trans-unit>
        <trans-unit id="25148b32afeb099d72b04e72e49e95c2dd911646" translate="yes" xml:space="preserve">
          <source>Checks if the identifier was defined using &lt;a href=&quot;replace&quot;&gt;&lt;code&gt; #define&lt;/code&gt;&lt;/a&gt; directive.</source>
          <target state="translated">&lt;a href=&quot;replace&quot;&gt; &lt;code&gt; #define&lt;/code&gt; &lt;/a&gt; 지시문을 사용하여 식별자가 정의되었는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="587976447f530aa6d25584b121ecdd151dbddd88" translate="yes" xml:space="preserve">
          <source>Checks the given stream for errors.</source>
          <target state="translated">주어진 스트림에 오류가 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="2941dd6b2ef28d38e387c7f18e6f1d84f133699d" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; refer to the same thread.</source>
          <target state="translated">&lt;code&gt;lhs&lt;/code&gt; 와 &lt;code&gt;rhs&lt;/code&gt; 가 동일한 스레드를 나타내는 지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="34eb3f9df1785987205174d978835deeb45e94ad" translate="yes" xml:space="preserve">
          <source>Choose clang to observe the output shown.</source>
          <target state="translated">표시된 출력을 관찰하려면 clang을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="94c2a3189e7f7885455350c4c7a8df2d0d6ad1d1" translate="yes" xml:space="preserve">
          <source>Classification</source>
          <target state="translated">Classification</target>
        </trans-unit>
        <trans-unit id="86c73ff296a69ebbcae03a6a87d277af954ca095" translate="yes" xml:space="preserve">
          <source>Classification and comparison</source>
          <target state="translated">분류 및 비교</target>
        </trans-unit>
        <trans-unit id="678a1418d0dca4dfa7d114655cc6c809563626e4" translate="yes" xml:space="preserve">
          <source>Classifies the wide character &lt;code&gt;wc&lt;/code&gt; using the current C locale's LC_CTYPE category identified by &lt;code&gt;desc&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;desc&lt;/code&gt; 로 식별 된 현재 C 로케일의 LC_CTYPE 범주를 사용하여 와이드 문자 &lt;code&gt;wc&lt;/code&gt; 를 분류합니다 .</target>
        </trans-unit>
        <trans-unit id="4f846d9e8e5a959a36bfa1fbc2c8184ff034cead" translate="yes" xml:space="preserve">
          <source>Closes the given file stream. Any unwritten buffered data are flushed to the OS. Any unread buffered data are discarded.</source>
          <target state="translated">주어진 파일 스트림을 닫습니다. 쓰지 않은 버퍼링 된 데이터는 OS로 플러시됩니다. 읽지 않은 버퍼링 된 데이터는 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="60ce571e9fd40583067484c63f2febcaa5424e29" translate="yes" xml:space="preserve">
          <source>Collation order is the dictionary order: the position of the letter in the national alphabet (its</source>
          <target state="translated">데이터 정렬 순서는 사전 순서입니다. 국가 알파벳 문자의 위치</target>
        </trans-unit>
        <trans-unit id="9f9c3302a6454b216eade45c792066892cae6eab" translate="yes" xml:space="preserve">
          <source>Colloquially known as</source>
          <target state="translated">구어 적으로 알려진</target>
        </trans-unit>
        <trans-unit id="b9ee3deaae2695cf53cbcebec20aed5fb9b594e3" translate="yes" xml:space="preserve">
          <source>Comma</source>
          <target state="translated">Comma</target>
        </trans-unit>
        <trans-unit id="b506b24efb6525b0ee356cf0162e2de834afe47c" translate="yes" xml:space="preserve">
          <source>Comma operator</source>
          <target state="translated">쉼표 연산자</target>
        </trans-unit>
        <trans-unit id="f9d837147551d84676f75bd72ce6ad24312cb2bd" translate="yes" xml:space="preserve">
          <source>Comma operator is not allowed in &lt;a href=&quot;constant_expression&quot;&gt;constant expressions&lt;/a&gt;, regardless of whether it's on the top level or not.</source>
          <target state="translated">쉼표 연산자는 최상위 레벨에 관계없이 &lt;a href=&quot;constant_expression&quot;&gt;상수 표현식에&lt;/a&gt; 허용 되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fce06e20e5f7f74aacccab40b59b75a56c8f7305" translate="yes" xml:space="preserve">
          <source>Comments</source>
          <target state="translated">Comments</target>
        </trans-unit>
        <trans-unit id="77dc6eb02cb1c62d942bb34b9b074bf78c09d78f" translate="yes" xml:space="preserve">
          <source>Comments serve as a sort of in-code documentation. When inserted into a program, they are effectively ignored by the compiler; they are solely intended to be used as notes by the humans that read source code.</source>
          <target state="translated">주석은 일종의 코드 내 문서 역할을합니다. 프로그램에 삽입되면 컴파일러에서 효과적으로 무시합니다. 그것들은 오직 소스 코드를 읽는 사람에 의해 노트로 사용되도록 의도 된 것입니다.</target>
        </trans-unit>
        <trans-unit id="3058ce23e65f21dc5cbd24c26f57bcb910e0857c" translate="yes" xml:space="preserve">
          <source>Common macro definitions</source>
          <target state="translated">일반적인 매크로 정의</target>
        </trans-unit>
        <trans-unit id="300b7ca7537f6f7e544d83703decea74261de072" translate="yes" xml:space="preserve">
          <source>Common mathematical functions</source>
          <target state="translated">일반적인 수학 함수</target>
        </trans-unit>
        <trans-unit id="d05b85b9373c028c966baf6f72eacf6afdf95cd7" translate="yes" xml:space="preserve">
          <source>Common mathematics functions</source>
          <target state="translated">일반적인 수학 함수</target>
        </trans-unit>
        <trans-unit id="044d38e8939c8f6fc027ea1c90729d6aca7109d3" translate="yes" xml:space="preserve">
          <source>Common operators</source>
          <target state="translated">일반적인 연산자</target>
        </trans-unit>
        <trans-unit id="ed62bc28035976769130c4128738e35c18c296a6" translate="yes" xml:space="preserve">
          <source>Communicating with the environment</source>
          <target state="translated">환경과의 커뮤니케이션</target>
        </trans-unit>
        <trans-unit id="35e8aa2bb22045b3aaa2abc8b9c19086e5217942" translate="yes" xml:space="preserve">
          <source>Compares at most &lt;code&gt;count&lt;/code&gt; characters of two possibly null-terminated arrays. The comparison is done lexicographically.</source>
          <target state="translated">null로 끝나는 두 배열의 최대 &lt;code&gt;count&lt;/code&gt; 문자를 비교 합니다. 사전은 사전 식으로 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="0727eb4b9d940361cfe3eeafe56df0bb6ceff1b1" translate="yes" xml:space="preserve">
          <source>Compares at most &lt;code&gt;count&lt;/code&gt; wide characters of two null-terminated wide strings. The comparison is done lexicographically.</source>
          <target state="translated">널로 끝나는 두 개의 넓은 문자열의 최대 &lt;code&gt;count&lt;/code&gt; 의 문자를 비교 합니다. 사전은 사전 식으로 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="a146ec971b1d93c0eca122d627ff96be93cae780" translate="yes" xml:space="preserve">
          <source>Compares different floating-point decomposition functions.</source>
          <target state="translated">다른 부동 소수점 분해 함수를 비교합니다.</target>
        </trans-unit>
        <trans-unit id="505981e95799fb74b00a3bcd6545a539962db24a" translate="yes" xml:space="preserve">
          <source>Compares the first &lt;code&gt;count&lt;/code&gt; characters of the objects pointed to by &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. The comparison is done lexicographically.</source>
          <target state="translated">&lt;code&gt;lhs&lt;/code&gt; 및 &lt;code&gt;rhs&lt;/code&gt; 가 가리키는 객체 의 첫 번째 &lt;code&gt;count&lt;/code&gt; 문자를 비교합니다 . 사전은 사전 식으로 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="8081695a2902e2182377570f6d2fb36eb8232444" translate="yes" xml:space="preserve">
          <source>Compares the first &lt;code&gt;count&lt;/code&gt; wide characters of the wide character (or compatible integer type) arrays pointed to by &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. The comparison is done lexicographically.</source>
          <target state="translated">&lt;code&gt;lhs&lt;/code&gt; 및 &lt;code&gt;rhs&lt;/code&gt; 가 가리키는 와이드 문자 (또는 호환 가능한 정수 유형) 배열 의 첫 번째 &lt;code&gt;count&lt;/code&gt; 와이드 문자를 비교합니다 . 사전은 사전 식으로 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="0e00c63c41d94e64efbb2ed0a1eb306b8443cef2" translate="yes" xml:space="preserve">
          <source>Compares two null-terminated byte strings according to the current locale as defined by the &lt;code&gt;&lt;a href=&quot;../../locale/lc_categories&quot;&gt;LC_COLLATE&lt;/a&gt;&lt;/code&gt; category.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../locale/lc_categories&quot;&gt;LC_COLLATE&lt;/a&gt;&lt;/code&gt; 범주에 의해 정의 된 현재 로케일에 따라 두 개의 널 종료 바이트 문자열을 비교 합니다.</target>
        </trans-unit>
        <trans-unit id="3d96fd82bc5cfecc84e4ec5ba54d1dce1db99f1b" translate="yes" xml:space="preserve">
          <source>Compares two null-terminated byte strings lexicographically.</source>
          <target state="translated">사 전적으로 두 개의 널 종료 바이트 문자열을 비교합니다.</target>
        </trans-unit>
        <trans-unit id="15950bd77b78269b905c3c5c5ba78145e13631f4" translate="yes" xml:space="preserve">
          <source>Compares two null-terminated wide strings according to the collation order defined by the &lt;code&gt;&lt;a href=&quot;../../locale/lc_categories&quot;&gt;LC_COLLATE&lt;/a&gt;&lt;/code&gt; category of the currently installed locale.</source>
          <target state="translated">현재 설치된 로케일 의 &lt;code&gt;&lt;a href=&quot;../../locale/lc_categories&quot;&gt;LC_COLLATE&lt;/a&gt;&lt;/code&gt; 범주로 정의 된 데이터 정렬 순서에 따라 두 개의 널 종료 와이드 문자열을 비교 합니다.</target>
        </trans-unit>
        <trans-unit id="425c0ed5bb7057b86419e94b1e93f2ea4b7b2de1" translate="yes" xml:space="preserve">
          <source>Compares two null-terminated wide strings lexicographically.</source>
          <target state="translated">널로 끝나는 두 개의 넓은 문자열을 사전 식으로 비교합니다.</target>
        </trans-unit>
        <trans-unit id="9461d4c9f916ad7df5538225ed552fb6e7e3284b" translate="yes" xml:space="preserve">
          <source>Comparison operators</source>
          <target state="translated">비교 연산자</target>
        </trans-unit>
        <trans-unit id="181e8d4d8e85dc949aeb0b7a2e7684136d886553" translate="yes" xml:space="preserve">
          <source>Comparison operators are binary operators that test a condition and return &lt;b&gt;1&lt;/b&gt; if that condition is logically &lt;b&gt;true&lt;/b&gt; and &lt;b&gt;0&lt;/b&gt; if that condition is &lt;b&gt;false&lt;/b&gt;.</source>
          <target state="translated">비교 연산자는 조건을 테스트하고 해당 조건이 논리적으로 &lt;b&gt;true 인&lt;/b&gt; 경우 &lt;b&gt;1을&lt;/b&gt; 반환 하고 해당 조건이 &lt;b&gt;false 인&lt;/b&gt; 경우 &lt;b&gt;0&lt;/b&gt; 을 반환하는 이진 연산자입니다 .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="580eefdb317ca1980517ce814ac757d8de1a082e" translate="yes" xml:space="preserve">
          <source>Compatible types</source>
          <target state="translated">호환 가능한 유형</target>
        </trans-unit>
        <trans-unit id="6e5b2b0dca46a4ad21f4296d9b1bc8179a4d98ec" translate="yes" xml:space="preserve">
          <source>Compilation takes place: the tokens are syntactically and semantically analyzed and translated as a translation unit.</source>
          <target state="translated">컴파일이 수행됩니다. 토큰은 구문 및 의미 론적으로 분석되고 번역 단위로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="3b17b76f2f8c8bd9e9381ee9ce3fb90ff874e220" translate="yes" xml:space="preserve">
          <source>Complex and imaginary addition and subtraction are defined as follows (note the result type is imaginary if both operands are imaginary and complex if one operand is real and the other imaginary, as specified by the usual arithmetic conversions):</source>
          <target state="translated">복소수와 허수의 덧셈과 뺄셈은 다음과 같이 정의됩니다 (보통 산술 변환에 의해 지정된 것처럼 한 피연산자가 실수이고 다른 피연산자이면 두 피연산자가 모두 허수이고 결과 유형은 허수 임).</target>
        </trans-unit>
        <trans-unit id="44dd33fc6270732559d77c0f49e48c52d2052437" translate="yes" xml:space="preserve">
          <source>Complex floating types</source>
          <target state="translated">복잡한 부동 유형</target>
        </trans-unit>
        <trans-unit id="9abb4134e20e54cbe39b6d903f1af3c82407a19d" translate="yes" xml:space="preserve">
          <source>Complex floating types model the mathematical &lt;a href=&quot;https://en.wikipedia.org/wiki/Complex_number&quot;&gt;complex numbers&lt;/a&gt;, that is the numbers that can be written as a sum of a real number and a real number multiplied by the imaginary unit: a + bi.</source>
          <target state="translated">복소수 부동 소수는 수학적 &lt;a href=&quot;https://en.wikipedia.org/wiki/Complex_number&quot;&gt;복소수를&lt;/a&gt; 모델링합니다 . 즉, 실수와 허수의 합으로 곱할 수있는 숫자는 a + bi입니다.</target>
        </trans-unit>
        <trans-unit id="4dbbf2b2a08a0bd32712455c3831413cb3be33b6" translate="yes" xml:space="preserve">
          <source>Complex function</source>
          <target state="translated">복잡한 기능</target>
        </trans-unit>
        <trans-unit id="588968aece6ec2967902b0c8debd814af1beab35" translate="yes" xml:space="preserve">
          <source>Complex number arithmetic</source>
          <target state="translated">복소수 산술</target>
        </trans-unit>
        <trans-unit id="c33f3e884f8ee47e82b79abb3d7ac7ecc6d16cf0" translate="yes" xml:space="preserve">
          <source>Complex numbers may be used with &lt;a href=&quot;operator_arithmetic&quot;&gt;arithmetic operators&lt;/a&gt; + - * and /, possibly mixed with imaginary and real numbers. There are many mathematical functions defined for complex numbers in &lt;a href=&quot;../numeric/complex&quot;&gt;complex.h&lt;/a&gt;. Both built-in operators and library functions may raise floating-point exceptions and set &lt;code&gt;&lt;a href=&quot;../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; as described in &lt;a href=&quot;../numeric/math/math_errhandling&quot;&gt;&lt;code&gt;math_errhandling&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">복소수는 &lt;a href=&quot;operator_arithmetic&quot;&gt;산술 연산자&lt;/a&gt; +-* 및 / 와 함께 사용될 수 있으며 , 허수와 실수와 혼합 될 수 있습니다. &lt;a href=&quot;../numeric/complex&quot;&gt;complex.h&lt;/a&gt; 에 복소수에 대해 정의 된 많은 수학적 함수가 있습니다 . 내장 연산자와 라이브러리 함수는 &lt;a href=&quot;../numeric/math/math_errhandling&quot;&gt; &lt;code&gt;math_errhandling&lt;/code&gt; 에&lt;/a&gt; 설명 된대로 부동 소수점 예외를 발생시키고 &lt;code&gt;&lt;a href=&quot;../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; 를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="986de770a77674f7fac27990f9489f0625e4e838" translate="yes" xml:space="preserve">
          <source>Complex type conversions</source>
          <target state="translated">복잡한 유형 변환</target>
        </trans-unit>
        <trans-unit id="c03daa5c814cb456a3684f1ad69e17b36c0d48db" translate="yes" xml:space="preserve">
          <source>Complex-imaginary conversions</source>
          <target state="translated">복잡한 가상 변환</target>
        </trans-unit>
        <trans-unit id="5881b1c904d7b7259dd04943175ea48e1e428f2b" translate="yes" xml:space="preserve">
          <source>Complex-only functions</source>
          <target state="translated">복합 전용 기능</target>
        </trans-unit>
        <trans-unit id="c2380af577316c38820427372c14161206c8131e" translate="yes" xml:space="preserve">
          <source>Complex/real type-generic macros</source>
          <target state="translated">복잡하고 실제적인 유형의 매크로</target>
        </trans-unit>
        <trans-unit id="537187710d8643593965aef2a7a923121f09907a" translate="yes" xml:space="preserve">
          <source>Composite types</source>
          <target state="translated">복합 유형</target>
        </trans-unit>
        <trans-unit id="f1378b286398f88adfddc67ea372070620098f37" translate="yes" xml:space="preserve">
          <source>Compound assignment</source>
          <target state="translated">복합 과제</target>
        </trans-unit>
        <trans-unit id="1f90e942ffc2b35ee9b3e4218cfd0172a5f1958a" translate="yes" xml:space="preserve">
          <source>Compound literal(C99)</source>
          <target state="translated">복합 리터럴 (C99)</target>
        </trans-unit>
        <trans-unit id="9d48e2cbfc2e7a620861605b5a2d55bac9d2711b" translate="yes" xml:space="preserve">
          <source>Compound literals of const-qualified character or wide character array types may share storage with &lt;a href=&quot;string_literal&quot;&gt;string literals&lt;/a&gt;.</source>
          <target state="translated">const 한정 문자 또는 와이드 문자 배열 유형의 복합 리터럴은 &lt;a href=&quot;string_literal&quot;&gt;문자열 리터럴&lt;/a&gt; 과 스토리지를 공유 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="557ac2424c5366dd0727ffe7e7cd646b1ea065fd" translate="yes" xml:space="preserve">
          <source>Compound statements</source>
          <target state="translated">복합 문장</target>
        </trans-unit>
        <trans-unit id="181b2c5fdb89e27a6008d489d216495b9acd968b" translate="yes" xml:space="preserve">
          <source>Computes both the quotient and the remainder of the division of the numerator &lt;code&gt;x&lt;/code&gt; by the denominator &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">분자 &lt;code&gt;x&lt;/code&gt; 의 분모 &lt;code&gt;y&lt;/code&gt; 에 의한 나눗셈의 몫과 나머지를 모두 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="e9444ce94d568a16c9c8dae23ae1d2d6125ac8fc" translate="yes" xml:space="preserve">
          <source>Computes difference between two calendar times as &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;time_t&lt;/a&gt;&lt;/code&gt; objects (&lt;code&gt;time_end - time_beg&lt;/code&gt;) in seconds. If &lt;code&gt;time_end&lt;/code&gt; refers to time point before &lt;code&gt;time_beg&lt;/code&gt; then the result is negative.</source>
          <target state="translated">두 달력 시간의 차이 를 초 단위의 &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;time_t&lt;/a&gt;&lt;/code&gt; 객체 ( &lt;code&gt;time_end - time_beg&lt;/code&gt; ) 로 계산 합니다. 경우 &lt;code&gt;time_end&lt;/code&gt; 전에 시점을 의미 &lt;code&gt;time_beg&lt;/code&gt; 결과는 부정적이다.</target>
        </trans-unit>
        <trans-unit id="509eb0b7cc06400c9a23de5f72ecc0de165b85e5" translate="yes" xml:space="preserve">
          <source>Computes quotient and remainder simultaneously. The quotient is the algebraic quotient with any fractional part discarded (truncated towards zero). The remainder is such that &lt;code&gt;quot * y + rem == x&lt;/code&gt;.</source>
          <target state="translated">몫과 나머지를 동시에 계산합니다. 몫은 소수 부분을 버린 대수 몫입니다 (0쪽으로 잘림). 나머지는 &lt;code&gt;quot * y + rem == x&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fada816f8d77fb81d9ff5b692bd2596860aa718e" translate="yes" xml:space="preserve">
          <source>Computes the absolute value of an integer number. The behavior is undefined if the result cannot be represented by the return type.</source>
          <target state="translated">정수의 절대 값을 계산합니다. 결과가 리턴 유형으로 표시 될 수없는 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dca8bdeece135120987218c0e8c574bf0369c8f5" translate="yes" xml:space="preserve">
          <source>Computes the quotient (the result of the expression &lt;code&gt;x/y&lt;/code&gt;) and remainder (the result of the expression &lt;code&gt;x%y&lt;/code&gt;) simultaneously.</source>
          <target state="translated">몫 (표현식 &lt;code&gt;x/y&lt;/code&gt; 의 결과)과 나머지 (표현식 &lt;code&gt;x%y&lt;/code&gt; 의 결과 )를 동시에 계산합니다.</target>
        </trans-unit>
        <trans-unit id="2f4979324e03e4571b1d7eba701226670c2ee2da" translate="yes" xml:space="preserve">
          <source>Condition</source>
          <target state="translated">Condition</target>
        </trans-unit>
        <trans-unit id="c9310d3b540cdb7701ecb54cf6be827f8499b99f" translate="yes" xml:space="preserve">
          <source>Condition variables</source>
          <target state="translated">조건 변수</target>
        </trans-unit>
        <trans-unit id="6df92750a0f9ea5c7e0fdf367810b34c51dfc8b0" translate="yes" xml:space="preserve">
          <source>Conditional evaluation</source>
          <target state="translated">조건부 평가</target>
        </trans-unit>
        <trans-unit id="ae382767cc8004ef63f077e5c30b8fcc609af876" translate="yes" xml:space="preserve">
          <source>Conditional inclusion</source>
          <target state="translated">조건부 포함</target>
        </trans-unit>
        <trans-unit id="86d8c4f438a64027d9c179cbd6cac7228180ae16" translate="yes" xml:space="preserve">
          <source>Conditional operator</source>
          <target state="translated">조건부 연산자</target>
        </trans-unit>
        <trans-unit id="f0e3da472ae92d2102d21d061ce57f244b5a5c0e" translate="yes" xml:space="preserve">
          <source>Conditional operator has right-to-left associativity, which allows chaining.</source>
          <target state="translated">조건부 연산자에는 오른쪽에서 왼쪽으로 연결되므로 체인을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5c5b712f5b77396fc4520f5a9049d95172e4471" translate="yes" xml:space="preserve">
          <source>Conditionally compiled macro that compares its argument to zero</source>
          <target state="translated">인수를 0과 비교하는 조건부 컴파일 된 매크로</target>
        </trans-unit>
        <trans-unit id="1ce1caed837c07a48f6a88d0ea42bd39f49a6272" translate="yes" xml:space="preserve">
          <source>Conditionally executes code.</source>
          <target state="translated">조건부로 코드를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="5829addbd65734c4f2d8dad3852c632235ce06d4" translate="yes" xml:space="preserve">
          <source>Configures the handler to be called by all &lt;a href=&quot;../error#Bounds_checking&quot;&gt;bounds-checked functions&lt;/a&gt; on a runtime constraint violation or restores the default handler (if &lt;code&gt;handler&lt;/code&gt; is a null pointer).</source>
          <target state="translated">런타임 제약 조건 위반에서 모든 &lt;a href=&quot;../error#Bounds_checking&quot;&gt;범위 검사 함수&lt;/a&gt; 가 핸들러를 호출하도록 구성 하거나 기본 핸들러를 복원합니다 ( &lt;code&gt;handler&lt;/code&gt; 가 널 포인터 인 경우).</target>
        </trans-unit>
        <trans-unit id="24dbea7a3dbb1c93c581fc08dcbaae936c7b5b98" translate="yes" xml:space="preserve">
          <source>Conformance</source>
          <target state="translated">Conformance</target>
        </trans-unit>
        <trans-unit id="733fd2b4c4e1bca4c7d0e3c2e1c341bcd1d34269" translate="yes" xml:space="preserve">
          <source>Constant</source>
          <target state="translated">Constant</target>
        </trans-unit>
        <trans-unit id="01f3d0f48081336b622122d8a98fa589e08cae6c" translate="yes" xml:space="preserve">
          <source>Constant expressions</source>
          <target state="translated">상수 표현식</target>
        </trans-unit>
        <trans-unit id="b1b91cf185f43f995ea5e1bbd7b583d233b1e42c" translate="yes" xml:space="preserve">
          <source>Constant values of certain types may be embedded in the source code of a C program using specialized expressions known as literals (for lvalue expressions) and constants (for non-lvalue expressions).</source>
          <target state="translated">리터럴 (lvalue 표현식의 경우) 및 상수 (lvalue가 아닌 표현식의 경우)로 알려진 특수 표현식을 사용하여 특정 유형의 상수 값을 C 프로그램의 소스 코드에 임베드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f386d7e7881b32fa39cb7b62bdb15c0f3a4c0e1" translate="yes" xml:space="preserve">
          <source>Constants</source>
          <target state="translated">Constants</target>
        </trans-unit>
        <trans-unit id="87c4159a742ed8e414ffd5bae72f84a5d574be41" translate="yes" xml:space="preserve">
          <source>Constants and literals</source>
          <target state="translated">상수와 리터럴</target>
        </trans-unit>
        <trans-unit id="625f65880cedb4712e1d5945dc325c138ae5abe2" translate="yes" xml:space="preserve">
          <source>Constructs a value of type &lt;code&gt;wctrans_t&lt;/code&gt; that describes a LC_CTYPE category of wide character mapping. It may be one of the standard mappings, or a locale-specific mapping, such as &lt;code&gt;&quot;tojhira&quot;&lt;/code&gt; or &lt;code&gt;&quot;tojkana&quot;&lt;/code&gt;.</source>
          <target state="translated">LC_CTYPE 와이드 문자 맵핑 범주를 설명하는 &lt;code&gt;wctrans_t&lt;/code&gt; 유형의 값을 구성합니다 . 표준 맵핑 중 하나이거나 &lt;code&gt;&quot;tojhira&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;tojkana&quot;&lt;/code&gt; 와 같은 로케일 특정 맵핑 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccc1814324121e43fbfd9c7fd0178bbe7dcfb1f9" translate="yes" xml:space="preserve">
          <source>Constructs a value of type &lt;code&gt;wctype_t&lt;/code&gt; that describes a LC_CTYPE category of wide character classification. It may be one of the standard classification categories, or a locale-specific category, such as &lt;code&gt;&quot;jkanji&quot;&lt;/code&gt;.</source>
          <target state="translated">와이드 문자 분류의 LC_CTYPE 범주를 설명하는 &lt;code&gt;wctype_t&lt;/code&gt; 유형의 값을 구성합니다 . 표준 분류 범주 중 하나이거나 &lt;code&gt;&quot;jkanji&quot;&lt;/code&gt; 와 같은 로케일 특정 범주 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0c8168c0cfbada2990dd2ad8b3fe0fafbfb373f" translate="yes" xml:space="preserve">
          <source>Constructs an unnamed object of specified character array type in-place, used when a character string needs to be embedded in source code.</source>
          <target state="translated">문자열을 소스 코드에 임베드해야 할 때 사용되는 지정된 문자 배열 유형의 이름없는 오브젝트를 내부에서 구성합니다.</target>
        </trans-unit>
        <trans-unit id="7144d435c6f6eed65fdfb01892ed2517b9a5f780" translate="yes" xml:space="preserve">
          <source>Constructs an unnamed object of specified type in-place, used when a variable of array, struct, or union type would be needed only once.</source>
          <target state="translated">배열, 구조체 또는 공용체 유형의 변수가 한 번만 필요할 때 사용되는 지정된 형식의 명명되지 않은 개체를 내부에서 구성합니다.</target>
        </trans-unit>
        <trans-unit id="94ba0441a632d1d40b442b189f4d839da4c6f833" translate="yes" xml:space="preserve">
          <source>Convenience macro which can be used to specify that an object has &lt;a href=&quot;../language/storage_duration&quot;&gt;thread-local storage duration&lt;/a&gt;.</source>
          <target state="translated">물체가 있는지를 지정하는 데 사용될 수 간이 매크로 &lt;a href=&quot;../language/storage_duration&quot;&gt;스레드 로컬 저장 지속 시간&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9151f8433f795cb0f0b5b6743aeb7de77ec49f00" translate="yes" xml:space="preserve">
          <source>Conversion</source>
          <target state="translated">Conversion</target>
        </trans-unit>
        <trans-unit id="c984c12517b0136cf8b6803f48a375cfb48f60b5" translate="yes" xml:space="preserve">
          <source>Conversion as if by assignment</source>
          <target state="translated">과제에 의한 것처럼 변환</target>
        </trans-unit>
        <trans-unit id="5980eba8f0b4f2f1cc9d2b0ed71af9f29a9903b9" translate="yes" xml:space="preserve">
          <source>Conversion of a value of any type to any &lt;a href=&quot;types#Compatible_types&quot;&gt;compatible type&lt;/a&gt; is always a no-op and does not change the representation.</source>
          <target state="translated">모든 유형의 값을 &lt;a href=&quot;types#Compatible_types&quot;&gt;호환 가능한 유형&lt;/a&gt; 으로 변환하는 것은 항상 작동하지 않으며 표현을 변경하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b08eaadf77cfdba7944ddcaf69eee5a983b74af3" translate="yes" xml:space="preserve">
          <source>Conversions</source>
          <target state="translated">Conversions</target>
        </trans-unit>
        <trans-unit id="78181f4b075c67c1b93d70dd04f6600b3ede87c6" translate="yes" xml:space="preserve">
          <source>Conversions between pointers and integers (except from pointer to _Bool and from integer constant expression with the value zero to pointer), between pointers to objects (except where either to or from is a pointer to void) and conversions between pointers to functions (except when the functions have compatible types) are never implicit and require a &lt;a href=&quot;cast&quot;&gt;cast operator&lt;/a&gt;.</source>
          <target state="translated">포인터와 정수 사이의 변환 (포인터에서 _Bool로, 정수 값에서 0으로 포인터로의 정수 상수에서 제외), 객체로의 포인터 간 (포인터에서 빈 공간에 대한 포인터 제외) 및 함수에 대한 포인터 간 변환 (언제든지 제외) 함수는 호환되는 유형을가집니다) 절대로 암시 적이 지 않으며 &lt;a href=&quot;cast&quot;&gt;캐스트 연산자가&lt;/a&gt; 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="82a308da2fa6926a6b6c6dd2f205fd8788bcad75" translate="yes" xml:space="preserve">
          <source>Conversions take place in the following situations:</source>
          <target state="translated">다음 상황에서 변환이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="b33060b95c6156e56397175f292d4d45c6d6b5b4" translate="yes" xml:space="preserve">
          <source>Conversions to numeric formats</source>
          <target state="translated">숫자 형식으로 변환</target>
        </trans-unit>
        <trans-unit id="69cac274e6b28bb335c35746d6cf8b2fc73bbb4f" translate="yes" xml:space="preserve">
          <source>Converts a multibyte character whose first byte is pointed to by &lt;code&gt;s&lt;/code&gt; to a wide character, written to &lt;code&gt;*pwc&lt;/code&gt; if &lt;code&gt;pwc&lt;/code&gt; is not null.</source>
          <target state="translated">&lt;code&gt;pwc&lt;/code&gt; 가 널이 아닌 경우 첫 번째 바이트가 &lt;code&gt;s&lt;/code&gt; 로 가리키는 멀티 바이트 문자를 와이드 문자로 변환하고 &lt;code&gt;*pwc&lt;/code&gt; 에 기록합니다 .</target>
        </trans-unit>
        <trans-unit id="f7e9a446c5b84278a0ced9cb286227ee420c1a0a" translate="yes" xml:space="preserve">
          <source>Converts a narrow multibyte character to its wide character representation.</source>
          <target state="translated">좁은 멀티 바이트 문자를 넓은 문자 표현으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="7438601c837acb2baa4f7b08761be638767a0fb4" translate="yes" xml:space="preserve">
          <source>Converts a single code point from its narrow multibyte character representation to its variable-length 16-bit wide character representation (typically, UTF-16).</source>
          <target state="translated">단일 코드 포인트를 좁은 멀티 바이트 문자 표현에서 가변 길이 16 비트 와이드 문자 표현 (일반적으로 UTF-16)으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="0ffd99b88e90d43a9dbbf14daf8d8252d500de2c" translate="yes" xml:space="preserve">
          <source>Converts a single code point from its narrow multibyte character representation to its variable-length 32-bit wide character representation (but typically, UTF-32).</source>
          <target state="translated">단일 코드 포인트를 좁은 멀티 바이트 문자 표현에서 가변 길이 32 비트 와이드 문자 표현 (그러나 일반적으로 UTF-32)으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="cb96eb234a6e56a369a809859f2f3dd01677ca1d" translate="yes" xml:space="preserve">
          <source>Converts a single code point from its variable-length 16-bit wide character representation (typically, UTF-16) to its narrow multibyte character representation.</source>
          <target state="translated">단일 코드 포인트를 가변 길이 16 비트 와이드 문자 표시 (일반적으로 UTF-16)에서 좁은 멀티 바이트 문자 표시로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="d96f0b90ea4f0c064b3c16639100cb4890c75aa0" translate="yes" xml:space="preserve">
          <source>Converts a single code point from its variable-length 32-bit wide character representation (but typically, UTF-32) to its narrow multibyte character representation.</source>
          <target state="translated">단일 코드 포인트를 가변 길이 32 비트 와이드 문자 표시 (일반적으로 UTF-32)에서 좁은 멀티 바이트 문자 표시로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="712188da508186849026fb3c8bd4c53083239bd2" translate="yes" xml:space="preserve">
          <source>Converts a wide character to its narrow multibyte representation.</source>
          <target state="translated">넓은 문자를 좁은 멀티 바이트 표현으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="20aba8933b1ce3e51b50d19af2bb5cd6151f383b" translate="yes" xml:space="preserve">
          <source>Converts the date and time information from a given calendar time &lt;code&gt;time&lt;/code&gt; to a null-terminated multibyte character string &lt;code&gt;str&lt;/code&gt; according to format string &lt;code&gt;format&lt;/code&gt;. Up to &lt;code&gt;count&lt;/code&gt; bytes are written.</source>
          <target state="translated">지정된 string time &lt;code&gt;time&lt;/code&gt; 에서 format string &lt;code&gt;format&lt;/code&gt; 에 따라 널 종료 멀티 바이트 문자열 &lt;code&gt;str&lt;/code&gt; 로 날짜 및 시간 정보를 변환 합니다 . 최대 &lt;code&gt;count&lt;/code&gt; 바이트가 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="84c9055ae6194fffb1394c02ee65a491c7f3c9ac" translate="yes" xml:space="preserve">
          <source>Converts the date and time information from a given calendar time &lt;code&gt;time&lt;/code&gt; to a null-terminated wide character string &lt;code&gt;str&lt;/code&gt; according to format string &lt;code&gt;format&lt;/code&gt;. Up to &lt;code&gt;count&lt;/code&gt; bytes are written.</source>
          <target state="translated">지정된 달력 시간 &lt;code&gt;time&lt;/code&gt; 에서 날짜 및 시간 정보 를 형식 문자열 &lt;code&gt;format&lt;/code&gt; 에 따라 널로 끝나는 넓은 문자열 &lt;code&gt;str&lt;/code&gt; 로 변환합니다 . 최대 &lt;code&gt;count&lt;/code&gt; 바이트가 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="519b80c3038fd902484f3879ce4d6e40b47a488a" translate="yes" xml:space="preserve">
          <source>Converts the given character to lowercase according to the character conversion rules defined by the currently installed C locale.</source>
          <target state="translated">현재 설치된 C 로케일로 정의 된 문자 변환 규칙에 따라 지정된 문자를 소문자로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="f569145b51d5c5bd1a8f3f9cda6c230ee4a033fa" translate="yes" xml:space="preserve">
          <source>Converts the given character to uppercase according to the character conversion rules defined by the currently installed C locale.</source>
          <target state="translated">현재 설치된 C 로케일로 정의 된 문자 변환 규칙에 따라 지정된 문자를 대문자로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="4e2c2190b4ebc6c640c23909d4015a7b7c92b75c" translate="yes" xml:space="preserve">
          <source>Converts the given wide character to lowercase, if possible.</source>
          <target state="translated">가능한 경우 주어진 넓은 문자를 소문자로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="9a302cdd09a562f6faf8a71da6652ad5c7071026" translate="yes" xml:space="preserve">
          <source>Converts the given wide character to uppercase, if possible.</source>
          <target state="translated">가능한 경우 주어진 넓은 문자를 대문자로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="379c410318b1052040824f4b78e1f453a2e061b8" translate="yes" xml:space="preserve">
          <source>Converts the implementation-defined character string &lt;code&gt;arg&lt;/code&gt; into the corresponding quiet NaN value, as if by calling &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;strtof&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;strtod&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;strtold&lt;/a&gt;&lt;/code&gt;, respectively, as follows:</source>
          <target state="translated">다음과 같이 &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;strtof&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;strtod&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;strtold&lt;/a&gt;&lt;/code&gt; 를 각각 호출 하여 구현 정의 문자열 &lt;code&gt;arg&lt;/code&gt; 를 해당 조용한 NaN 값 으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="d3125c64cd58a8e8c4a1e00a8a7f5cca65c1f3db" translate="yes" xml:space="preserve">
          <source>Copies the wide character &lt;code&gt;ch&lt;/code&gt; into each of the first &lt;code&gt;count&lt;/code&gt; wide characters of the wide character array (or integer array of compatible type) pointed to by &lt;code&gt;dest&lt;/code&gt;.</source>
          <target state="translated">와이드 문자 &lt;code&gt;ch&lt;/code&gt; 를 &lt;code&gt;dest&lt;/code&gt; 가 가리키는 와이드 문자 배열 (또는 호환 가능한 유형의 정수 배열)의 첫 번째 &lt;code&gt;count&lt;/code&gt; 와이드 문자 각각에 복사합니다 .</target>
        </trans-unit>
        <trans-unit id="a1a972dceff401c8f705084b99291771aca6d4f0" translate="yes" xml:space="preserve">
          <source>Corresponding bit fields must have the same widths.</source>
          <target state="translated">해당 비트 필드의 너비는 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="c7655b56c64b8e8974eef2a42e2f7caf3220ca70" translate="yes" xml:space="preserve">
          <source>Corresponding members must be declared in the same order (structures only)</source>
          <target state="translated">해당 멤버는 동일한 순서로 선언해야합니다 (구조 만)</target>
        </trans-unit>
        <trans-unit id="6ee0a78dc7e88cdbfe34cb24cb35cc308d3ce55a" translate="yes" xml:space="preserve">
          <source>Create a file for read/write</source>
          <target state="translated">읽기 / 쓰기를위한 파일 만들기</target>
        </trans-unit>
        <trans-unit id="3f00954c254e5e03c34d4c5d0355138a84dcbd5e" translate="yes" xml:space="preserve">
          <source>Create a file for writing</source>
          <target state="translated">쓰기위한 파일 만들기</target>
        </trans-unit>
        <trans-unit id="d7fab829ef004b63b0ae817164eec26b76e27830" translate="yes" xml:space="preserve">
          <source>Creates a new mutex object with &lt;code&gt;type&lt;/code&gt;. The object pointed to by &lt;code&gt;mutex&lt;/code&gt; is set to an identifier of the newly created mutex.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 을 사용 하여 새 mutex 객체를 만듭니다 . &lt;code&gt;mutex&lt;/code&gt; 가 가리키는 객체는 새로 생성 된 뮤텍스의 식별자로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="9b06bf69a45cd02d25cf20b979aa35310bf22a78" translate="yes" xml:space="preserve">
          <source>Creates a new thread executing the function &lt;code&gt;func&lt;/code&gt;. The function is invoked as &lt;code&gt;func(arg)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;func&lt;/code&gt; 함수를 실행하는 새 스레드를 작성합니다 . 이 함수는 &lt;code&gt;func(arg)&lt;/code&gt; 로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="571e4e2856d60889cd6291a7b577569ac1fb4093" translate="yes" xml:space="preserve">
          <source>Creates new thread-specific storage key and stores it in the object pointed to by &lt;code&gt;tss_key&lt;/code&gt;. Although the same key value may be used by different threads, the values bound to the key by &lt;code&gt;&lt;a href=&quot;tss_set&quot;&gt;tss_set&lt;/a&gt;&lt;/code&gt; are maintained on a per-thread basis and persist for the life of the calling thread.</source>
          <target state="translated">새로운 스레드 특정 스토리지 키를 작성하고 &lt;code&gt;tss_key&lt;/code&gt; 가 가리키는 오브젝트에 저장합니다 . 동일한 키 값이 다른 스레드에서 사용될 수 있지만 &lt;code&gt;&lt;a href=&quot;tss_set&quot;&gt;tss_set&lt;/a&gt;&lt;/code&gt; 에 의해 키에 바인드 된 값 은 스레드별로 유지되며 호출 스레드의 수명 동안 지속됩니다.</target>
        </trans-unit>
        <trans-unit id="b3301d9d8a5f4cade27f8ed51c3e2eb33faf2bb3" translate="yes" xml:space="preserve">
          <source>Critical UB is undefined behavior that might perform a memory write or a volatile memory read out of bounds of any object. A program that has critical undefined behavior may be susceptible to security exploits.</source>
          <target state="translated">Critical UB는 정의되지 않은 동작으로, 객체의 경계에서 메모리 쓰기 또는 휘발성 메모리 읽기를 수행 할 수 있습니다. 정의되지 않은 중요한 동작을 가진 프로그램은 보안 악용에 취약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48d3d0e79fd065ba50641549dc0f31bdbbbabe14" translate="yes" xml:space="preserve">
          <source>Critical undefined behavior</source>
          <target state="translated">중요하지 않은 행동</target>
        </trans-unit>
        <trans-unit id="cde75a84c505736a639dce4f3db8eb94d6550d9e" translate="yes" xml:space="preserve">
          <source>Current calendar time encoded as &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;time_t&lt;/a&gt;&lt;/code&gt; object on success, &lt;code&gt;(&lt;a href=&quot;time_t&quot;&gt;time_t&lt;/a&gt;)(-1)&lt;/code&gt; on error. If &lt;code&gt;arg&lt;/code&gt; is not a null pointer, the return value is also stored in the object pointed to by &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="translated">성공시 &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;time_t&lt;/a&gt;&lt;/code&gt; 객체 로 인코딩 된 현재 달력 시간 , 오류시 &lt;code&gt;(&lt;a href=&quot;time_t&quot;&gt;time_t&lt;/a&gt;)(-1)&lt;/code&gt; &lt;code&gt;arg&lt;/code&gt; 가 null 포인터가 아닌 경우 반환 값은 &lt;code&gt;arg&lt;/code&gt; 가 가리키는 객체에도 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="d1a550d08342a0a1a6248c5f115bf82d6658049a" translate="yes" xml:space="preserve">
          <source>D within thread 2, nothing prevents D from appearing before A in the modification order of y, and B from appearing before C in the modification order of x. The side-effect of D on y could be visible to the load A in thread 1 while the side effect of B on x could be visible to the load C in thread 2. In particular, this may occur if D is completed before C in thread 2, either due to compiler reordering or at runtime.</source>
          <target state="translated">스레드 2 내에서 D는 y의 수정 순서에서 D 앞에 D가 나타나고 x의 수정 순서에서 B 앞에 C가 나타나지 않습니다. y에 대한 D의 부작용은 나사산 1의 하중 A에서 볼 수 있지만 x에 대한 B의 부작용은 나사산 2의 하중 C에서 볼 수 있습니다. 특히 C in 컴파일러 재정렬로 인해 또는 런타임에 스레드 2</target>
        </trans-unit>
        <trans-unit id="12130df9add30c0ad6c8facc749f7941f22cb5a0" translate="yes" xml:space="preserve">
          <source>DECIMAL_DIG</source>
          <target state="translated">DECIMAL_DIG</target>
        </trans-unit>
        <trans-unit id="2d1df1e76038d57ea00e3dd0686a5e2fe8b90691" translate="yes" xml:space="preserve">
          <source>Data models</source>
          <target state="translated">데이터 모델</target>
        </trans-unit>
        <trans-unit id="cedc7364b9c54060c8937af16ca1f7f300c926d1" translate="yes" xml:space="preserve">
          <source>Data read in from a text stream is guaranteed to compare equal to the data that were earlier written out to that stream only if all of the following is true:</source>
          <target state="translated">텍스트 스트림에서 읽은 데이터는 다음 사항이 모두 해당되는 경우에만 해당 스트림에 이전에 작성된 데이터와 동일하게 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="07c9c3a5e0d97aef72f69b7e5ba94a6765f2a6d3" translate="yes" xml:space="preserve">
          <source>Date and time</source>
          <target state="translated">날짜와 시간</target>
        </trans-unit>
        <trans-unit id="5b0b556cd60211a5522983788620b6746c7543cf" translate="yes" xml:space="preserve">
          <source>Date and time utilities</source>
          <target state="translated">날짜 및 시간 유틸리티</target>
        </trans-unit>
        <trans-unit id="a2dfedeffd1ead187411349e305b1fe627303452" translate="yes" xml:space="preserve">
          <source>Day of the week</source>
          <target state="translated">요일</target>
        </trans-unit>
        <trans-unit id="1efe459545896a080ea552260e3ba2caa4f8d75e" translate="yes" xml:space="preserve">
          <source>Day of the year/month</source>
          <target state="translated">년 / 월의 일</target>
        </trans-unit>
        <trans-unit id="8fa7848b2be3ca4b1659ed978010f39a06d41489" translate="yes" xml:space="preserve">
          <source>Daylight Saving Time flag. The value is positive if DST is in effect, zero if not and negative if no information is available</source>
          <target state="translated">일광 절약 시간제 플래그입니다. DST가 유효하면 값은 양수이고, 정보가 없으면 0이고, 정보가없는 경우 음수입니다.</target>
        </trans-unit>
        <trans-unit id="d3e6f22a4ad377eca5934960c8545c3f833b1707" translate="yes" xml:space="preserve">
          <source>Deallocates the space previously allocated by &lt;code&gt;&lt;a href=&quot;malloc&quot;&gt;malloc()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;calloc&quot;&gt;calloc()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;aligned_alloc&lt;/code&gt;,(since C11) or &lt;code&gt;&lt;a href=&quot;realloc&quot;&gt;realloc()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;malloc&quot;&gt;malloc()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;calloc&quot;&gt;calloc()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;aligned_alloc&lt;/code&gt; , (C11 이후) 또는 &lt;code&gt;&lt;a href=&quot;realloc&quot;&gt;realloc()&lt;/a&gt;&lt;/code&gt; 의해 이전에 할당 된 공간을 할당 해제합니다 .</target>
        </trans-unit>
        <trans-unit id="b9b846963186dedc9a34aab11fab9a0a092e2d1b" translate="yes" xml:space="preserve">
          <source>Declarations</source>
          <target state="translated">Declarations</target>
        </trans-unit>
        <trans-unit id="749ccabedd0701c0c9714d9c1cdd4f12526e6e72" translate="yes" xml:space="preserve">
          <source>Declarations may appear in any scope. Each declaration ends with a semicolon (just like &lt;a href=&quot;statements&quot;&gt;a statement&lt;/a&gt;) and consists of two distinct parts:</source>
          <target state="translated">선언은 모든 범위에서 나타날 수 있습니다. 각 선언은 세미콜론으로 끝나고 ( &lt;a href=&quot;statements&quot;&gt;문장&lt;/a&gt; 처럼 ) 두 개의 고유 한 부분으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="498a79c2f403d3ef0ef459653265dbe039de60f8" translate="yes" xml:space="preserve">
          <source>Declarations of any variably-modified types may appear only at &lt;a href=&quot;scope&quot;&gt;block scope&lt;/a&gt; or function prototype scope and cannot be members of structs or unions. Although &lt;a href=&quot;array&quot;&gt;VLA&lt;/a&gt; can only have automatic &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt;, a VM type such as a pointer to a VLA may be static. There are other restrictions on the use of VM types, see &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;, &lt;a href=&quot;switch&quot;&gt;switch&lt;/a&gt;. &lt;code&gt;&lt;a href=&quot;../program/longjmp&quot;&gt;longjmp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">가변적으로 수정 된 유형의 선언은 &lt;a href=&quot;scope&quot;&gt;블록 범위&lt;/a&gt; 또는 함수 프로토 타입 범위 에만 나타날 수 있으며 구조체 또는 공용체의 멤버가 될 수 없습니다. &lt;a href=&quot;array&quot;&gt;VLA&lt;/a&gt; 는 자동 &lt;a href=&quot;storage_duration&quot;&gt;스토리지 기간&lt;/a&gt; 만 가질 수 있지만 VLA에 대한 포인터와 같은 VM 유형은 정적 일 수 있습니다. VM 유형 사용에 대한 다른 제한 사항이 있습니다 ( &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; , &lt;a href=&quot;switch&quot;&gt;switch&lt;/a&gt; 참조) . &lt;code&gt;&lt;a href=&quot;../program/longjmp&quot;&gt;longjmp&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="65fb5fdee4b95dce48f2a6be467d4b66c9cfaed7" translate="yes" xml:space="preserve">
          <source>Declarations of objects &lt;a href=&quot;storage_duration&quot;&gt;with linkage&lt;/a&gt; (external or internal) can be repeated:</source>
          <target state="translated">&lt;a href=&quot;storage_duration&quot;&gt;연결&lt;/a&gt; (외부 또는 내부)이있는 객체의 선언을 반복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50dd433317470a03afe915a58adaf99026617f03" translate="yes" xml:space="preserve">
          <source>Declarations with external linkage are commonly made available in header files so that all translation units that &lt;a href=&quot;../preprocessor/include&quot;&gt;#include&lt;/a&gt; the file may refer to the same identifier that are defined elsewhere.</source>
          <target state="translated">모든 번역 단위 있도록 외부 링크 선언은 일반적으로 헤더 파일에서 사용할 수 있습니다 &lt;a href=&quot;../preprocessor/include&quot;&gt;#include를&lt;/a&gt; 파일이 다른 곳에서 정의 된 동일한 식별자를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2487e41670058d63f8493da3e66e37364b0bb53c" translate="yes" xml:space="preserve">
          <source>Declarators</source>
          <target state="translated">Declarators</target>
        </trans-unit>
        <trans-unit id="a438543b4e82bf4692dd52fa11185961f695d7cf" translate="yes" xml:space="preserve">
          <source>Declares a member with explicit width, in bits. Adjacent bit field members may be packed to share and straddle the individual bytes.</source>
          <target state="translated">명시 적 너비를 가진 멤버를 비트 단위로 선언합니다. 인접 비트 필드 멤버는 개별 바이트를 공유하고 스트래핑하도록 압축 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b76d52d6a4f58b1756dbf7dc7ed7c25dc32036e0" translate="yes" xml:space="preserve">
          <source>Declares an &lt;a href=&quot;https://en.wikipedia.org/wiki/inline_function&quot;&gt;inline function&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/inline_function&quot;&gt;인라인 함수를&lt;/a&gt; 선언합니다 .</target>
        </trans-unit>
        <trans-unit id="479af35b0f110787bdde80cea52483776eb082c3" translate="yes" xml:space="preserve">
          <source>Default &lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;rounding direction&lt;/a&gt; and &lt;a href=&quot;../types/limits/flt_eval_method&quot;&gt;precision&lt;/a&gt; are in effect when the floating constants are converted into internal representations, and &lt;a href=&quot;../numeric/fenv/fe_exceptions&quot;&gt;floating-point exceptions&lt;/a&gt; are not raised even if &lt;a href=&quot;../preprocessor/impl&quot;&gt;&lt;code&gt; #pragma STDC FENV_ACCESS&lt;/code&gt;&lt;/a&gt; is in effect (for execution-time conversion of character strings, &lt;code&gt;&lt;a href=&quot;../string/byte/strtof&quot;&gt;strtod&lt;/a&gt;&lt;/code&gt; can be used). Note that this differs from &lt;a href=&quot;constant_expression&quot;&gt;arithmetic constant expressions&lt;/a&gt; of floating type.</source>
          <target state="translated">부동 소수점 상수가 내부 표현으로 변환 될 때 기본 &lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;반올림 방향&lt;/a&gt; 및 &lt;a href=&quot;../types/limits/flt_eval_method&quot;&gt;정밀도&lt;/a&gt; 가 적용되며 &lt;a href=&quot;../preprocessor/impl&quot;&gt; &lt;code&gt; #pragma STDC FENV_ACCESS&lt;/code&gt; &lt;/a&gt; 가 적용 되더라도 &lt;a href=&quot;../numeric/fenv/fe_exceptions&quot;&gt;부동 소수점 예외&lt;/a&gt; 가 발생하지 않습니다 (문자열의 실행 시간 변환을 위해 &lt;code&gt;&lt;a href=&quot;../string/byte/strtof&quot;&gt;strtod&lt;/a&gt;&lt;/code&gt; 를 사용할 수 있음) . 이것은 부동 유형의 &lt;a href=&quot;constant_expression&quot;&gt;산술 상수 표현식&lt;/a&gt; 과 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="21463b49a73f80192975053d7c51b6766c28139a" translate="yes" xml:space="preserve">
          <source>Default argument promotions</source>
          <target state="translated">기본 인수 프로모션</target>
        </trans-unit>
        <trans-unit id="d51786c7e25b0e6dca93c44db2e6620c91b5706f" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;assert.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">헤더 &lt;code&gt;&amp;lt;assert.h&amp;gt;&lt;/code&gt; 에 정의</target>
        </trans-unit>
        <trans-unit id="53b12cc0a64e5997f555f4552d8c0f5a1798ae66" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">헤더 &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt; 에 정의 됨</target>
        </trans-unit>
        <trans-unit id="90f2a795c1a351609a312fd95460d08cf184bd87" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;ctype.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">헤더 &lt;code&gt;&amp;lt;ctype.h&amp;gt;&lt;/code&gt; 에 정의 됨</target>
        </trans-unit>
        <trans-unit id="b76614d13fbb267406c567200d837b24b3fde09b" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;errno.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">헤더 &lt;code&gt;&amp;lt;errno.h&amp;gt;&lt;/code&gt; 에 정의</target>
        </trans-unit>
        <trans-unit id="80bf26c3624bf6ce9697ecba933de914daf63a5a" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;fenv.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">헤더 &lt;code&gt;&amp;lt;fenv.h&amp;gt;&lt;/code&gt; 에 정의 됨</target>
        </trans-unit>
        <trans-unit id="cd9bc4c7f48e74e44b5198fbf6ade033d2ef3214" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;float.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">헤더 &lt;code&gt;&amp;lt;float.h&amp;gt;&lt;/code&gt; 에 정의</target>
        </trans-unit>
        <trans-unit id="f9c7c1c3d49935948c03fc2e9d9fd5cb0acf7b6e" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;inttypes.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">헤더 &lt;code&gt;&amp;lt;inttypes.h&amp;gt;&lt;/code&gt; 에 정의 됨</target>
        </trans-unit>
        <trans-unit id="c5df25381e8feefe92fdd8b28465b19ae2f4972c" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">헤더 &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt; 에 정의 됨</target>
        </trans-unit>
        <trans-unit id="4ad2bbe9040c61764f1bfc89807c753f787521d0" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;limits.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">헤더 &lt;code&gt;&amp;lt;limits.h&amp;gt;&lt;/code&gt; 에 정의 됨</target>
        </trans-unit>
        <trans-unit id="acbd16aaad15089951f12b998aa7ea0853e93e93" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;locale.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">헤더 &lt;code&gt;&amp;lt;locale.h&amp;gt;&lt;/code&gt; 에 정의</target>
        </trans-unit>
        <trans-unit id="7025b36c2c07b19a8d8e66c935fb4f80ce6c1685" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;math.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">헤더 &lt;code&gt;&amp;lt;math.h&amp;gt;&lt;/code&gt; 에 정의</target>
        </trans-unit>
        <trans-unit id="705fca3e55ebf8cbefec135f8a856278153e2ce5" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;setjmp.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">헤더 &lt;code&gt;&amp;lt;setjmp.h&amp;gt;&lt;/code&gt; 에 정의</target>
        </trans-unit>
        <trans-unit id="ecd6850fd735cc0f8846abbf1075afdf10ec94f2" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;signal.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">헤더 &lt;code&gt;&amp;lt;signal.h&amp;gt;&lt;/code&gt; 에 정의</target>
        </trans-unit>
        <trans-unit id="53031c947e0190bfa35551ccad1808f03a3dc551" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;stdalign.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">헤더 &lt;code&gt;&amp;lt;stdalign.h&amp;gt;&lt;/code&gt; 에 정의</target>
        </trans-unit>
        <trans-unit id="245dc9819128f99f4333f72f1e35680c85852dbb" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;stdarg.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">헤더 &lt;code&gt;&amp;lt;stdarg.h&amp;gt;&lt;/code&gt; 에 정의 됨</target>
        </trans-unit>
        <trans-unit id="3e2f62efdddd63721d81b871af155dbbf79a1a53" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;stdatomic.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">헤더 &lt;code&gt;&amp;lt;stdatomic.h&amp;gt;&lt;/code&gt; 에 정의 됨</target>
        </trans-unit>
        <trans-unit id="2bd2583ed48877fab6813145157134c03b0da7df" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">헤더 &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt; 에 정의</target>
        </trans-unit>
        <trans-unit id="b70a61b2efac85d947d63495a0dbd17f5e7eb999" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">헤더 &lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt; 에 정의</target>
        </trans-unit>
        <trans-unit id="7b92b8bfeac671700e767b6a63a2a1467e903324" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;stdio.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">헤더 &lt;code&gt;&amp;lt;stdio.h&amp;gt;&lt;/code&gt; 에 정의 됨</target>
        </trans-unit>
        <trans-unit id="8f4d9d59d3d7d5aef5cc1ea4c46ea799408a374d" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">헤더 &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt; 에 정의 됨</target>
        </trans-unit>
        <trans-unit id="521fccfa0e87c453cf2e8f167e2684f7ed7209d0" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;stdnoreturn.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">헤더 &lt;code&gt;&amp;lt;stdnoreturn.h&amp;gt;&lt;/code&gt; 에 정의 됨</target>
        </trans-unit>
        <trans-unit id="f5fa73f7f3a4335015f1f23a0732c950803d482b" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;string.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">헤더 &lt;code&gt;&amp;lt;string.h&amp;gt;&lt;/code&gt; 에 정의</target>
        </trans-unit>
        <trans-unit id="1bbdc0981bd66c81cf104210dcd830723ba381c4" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">헤더 &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; 에 정의 됨</target>
        </trans-unit>
        <trans-unit id="555423c73974a949e00ecd09ae4522ff177b6ba3" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;threads.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">헤더 &lt;code&gt;&amp;lt;threads.h&amp;gt;&lt;/code&gt; 에 정의</target>
        </trans-unit>
        <trans-unit id="4048cff46ea43962575dde93962f1b588433080f" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;time.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">헤더 &lt;code&gt;&amp;lt;time.h&amp;gt;&lt;/code&gt; 에 정의</target>
        </trans-unit>
        <trans-unit id="6dfcc0c8bd903cf2bdcde1e66a702128ff94fbfa" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;uchar.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">헤더 &lt;code&gt;&amp;lt;uchar.h&amp;gt;&lt;/code&gt; 에 정의</target>
        </trans-unit>
        <trans-unit id="ecb0715cadd781ce84b451ce8e4acdd4dc7d0232" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;wchar.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">헤더 &lt;code&gt;&amp;lt;wchar.h&amp;gt;&lt;/code&gt; 에 정의</target>
        </trans-unit>
        <trans-unit id="eb6e4f42471d8124c8cf9d17dd195e977e3849ff" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;wctype.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">헤더 &lt;code&gt;&amp;lt;wctype.h&amp;gt;&lt;/code&gt; 에 정의 됨</target>
        </trans-unit>
        <trans-unit id="ab42660565c96e634b99d6325eb1b11da87c3efc" translate="yes" xml:space="preserve">
          <source>Defines the semantics of computer memory storage for the purpose of the C abstract machine.</source>
          <target state="translated">C 추상 머신의 목적으로 컴퓨터 메모리 스토리지의 의미를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="bf1be2b7ad07bae2fe92475d10173eb638774def" translate="yes" xml:space="preserve">
          <source>Definition</source>
          <target state="translated">Definition</target>
        </trans-unit>
        <trans-unit id="15225baac48fc3d689cb2b0f74b936eff4339ff7" translate="yes" xml:space="preserve">
          <source>Definitions</source>
          <target state="translated">Definitions</target>
        </trans-unit>
        <trans-unit id="b9f352ac1857e844fd93783413696f5ee3b91411" translate="yes" xml:space="preserve">
          <source>Definitions of functions include sequences of &lt;a href=&quot;statements&quot;&gt;statements&lt;/a&gt; and &lt;a href=&quot;declarations&quot;&gt;declarations&lt;/a&gt;, some of which include &lt;a href=&quot;expressions&quot;&gt;expressions&lt;/a&gt;, which specify the computations to be performed by the program.</source>
          <target state="translated">함수의 정의에는 일련의 &lt;a href=&quot;statements&quot;&gt;명령문&lt;/a&gt; 과 &lt;a href=&quot;declarations&quot;&gt;선언&lt;/a&gt; 이 포함되며, 그 중 일부에는 &lt;a href=&quot;expressions&quot;&gt;표현식&lt;/a&gt; 이 포함 되며,이 표현식 에는 프로그램에서 수행 할 계산을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="d5c2f3b1691c162974666c6b32fe851f22334bf1" translate="yes" xml:space="preserve">
          <source>Deletes the file identified by character string pointed to by &lt;code&gt;fname&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fname&lt;/code&gt; 이 가리키는 문자열로 식별 된 파일을 삭제합니다 .</target>
        </trans-unit>
        <trans-unit id="6821f0c7515e1af2b09d1caee8e7ee8be55d23ff" translate="yes" xml:space="preserve">
          <source>Demonstrates how to inform a program about where to find its input and where to write its results. Invocation: ./a.out indatafile outdatafile.</source>
          <target state="translated">입력 내용을 찾을 수있는 위치와 결과를 기록 할 위치를 프로그램에 알리는 방법을 보여줍니다. 호출 : ./a.out indatafile outdatafile.</target>
        </trans-unit>
        <trans-unit id="107363e042b2a4793f67270f98d3c7305ba956f9" translate="yes" xml:space="preserve">
          <source>Demonstrates the use of isalnum() with different locales (OS-specific).</source>
          <target state="translated">다른 로케일 (OS 특정)과 함께 isalnum ()을 사용하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="8bec99b36261ae64217d042ec118a2c264d9ce33" translate="yes" xml:space="preserve">
          <source>Demonstrates the use of isalpha() with different locales (OS-specific).</source>
          <target state="translated">다른 로케일 (OS 특정)과 함께 isalpha () 사용을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="7b2ffabd65a5c6d55404aee122640dc7ff1e1395" translate="yes" xml:space="preserve">
          <source>Depending on the computer architecture, a &lt;a href=&quot;https://en.wikipedia.org/wiki/Byte&quot;&gt;byte&lt;/a&gt; may consist of 8 or more bits, the exact number provided as &lt;code&gt;&lt;a href=&quot;../types/limits&quot;&gt;CHAR_BIT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">컴퓨터 아키텍처에 따라 &lt;a href=&quot;https://en.wikipedia.org/wiki/Byte&quot;&gt;바이트&lt;/a&gt; 는 8 개 이상의 비트로 구성 될 수 있으며 정확한 숫자는 &lt;code&gt;&lt;a href=&quot;../types/limits&quot;&gt;CHAR_BIT&lt;/a&gt;&lt;/code&gt; 로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="dec3b6d46e827cc481476ff03cd71af78767baf0" translate="yes" xml:space="preserve">
          <source>Dereference</source>
          <target state="translated">Dereference</target>
        </trans-unit>
        <trans-unit id="b61f3c0aeb3cddcd6eafde1041344977a1b7e38d" translate="yes" xml:space="preserve">
          <source>Dereferencing a function pointer yields the function designator for the pointed-to function:</source>
          <target state="translated">함수 포인터를 역 참조하면 지정된 함수에 대한 함수 지정자가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="443e0815b33ce17780b995cb60837ff3ec40c823" translate="yes" xml:space="preserve">
          <source>Dereferencing a null pointer, a pointer to an object outside of its lifetime (a dangling pointer), a misaligned pointer, or a pointer with indeterminate value is undefined behavior, except when the dereference operator is nullified by applying the address-of operator to its result, as in &lt;code&gt;&amp;amp;*E&lt;/code&gt;.</source>
          <target state="translated">널 포인터, 수명이 아닌 객체에 대한 포인터 (댕글 링 포인터), 잘못 정렬 된 포인터 또는 불확실한 값을 가진 포인터를 참조 해제하는 경우 참조 주소 연산자를 적용하여 역 참조 연산자를 무효화하는 경우를 제외하고는 정의되지 않은 동작입니다. &lt;code&gt;&amp;amp;*E&lt;/code&gt; 와 같은 결과 .</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="d6ebeef73eef6a80573532642182d125a4f29dce" translate="yes" xml:space="preserve">
          <source>Despite being specified &quot;as if&quot; a temporary buffer is used, actual implementations of this function do not incur the overhead or double copying or extra memory. A common approach (glibc and bsd libc) is to copy bytes forwards from the beginning of the buffer if the destination starts before the source, and backwards from the end otherwise, with a fall back to the more efficient &lt;code&gt;&lt;a href=&quot;memcpy&quot;&gt;memcpy&lt;/a&gt;&lt;/code&gt; when there is no overlap at all.</source>
          <target state="translated">임시 버퍼가 &quot;있는 것처럼&quot;지정되어 있지만이 기능의 실제 구현에는 오버 헤드 나 이중 복사 또는 추가 메모리가 발생하지 않습니다. 일반적인 방법 (glibc에와 BSD libc의)이 더 효율적으로 하강 위로와 달리 단부로부터 목적지 소스 전에 시작되고 뒤쪽 경우 버퍼의 개시로부터 전방 바이트 복사하는 &lt;code&gt;&lt;a href=&quot;memcpy&quot;&gt;memcpy&lt;/a&gt;&lt;/code&gt; 가 중첩에 없을 때 모두.</target>
        </trans-unit>
        <trans-unit id="c5fec379b7553188ac34cec8b46773b82ab3ed04" translate="yes" xml:space="preserve">
          <source>Despite disallowing undue overflow, complex division may raise spurious floating-point exceptions (otherwise it is prohibitively difficult to implement non-overflowing versions).</source>
          <target state="translated">과도한 오버플로를 허용하지 않더라도 복잡한 분할은 잘못된 부동 소수점 예외를 발생시킬 수 있습니다 (그렇지 않으면 오버플로되지 않는 버전을 구현하는 것이 엄청나게 어렵습니다).</target>
        </trans-unit>
        <trans-unit id="15633e8db8c39a0171fc7ddfc24df220b416124e" translate="yes" xml:space="preserve">
          <source>Despite disallowing undue overflow, complex multiplication may raise spurious floating-point exceptions (otherwise it is prohibitively difficult to implement non-overflowing versions).</source>
          <target state="translated">과도한 오버플로를 허용하지 않더라도 복잡한 곱셈은 잘못된 부동 소수점 예외를 발생시킬 수 있습니다 (그렇지 않으면 오버플로가 아닌 버전을 구현하는 것은 엄청나게 어렵습니다).</target>
        </trans-unit>
        <trans-unit id="855ca2056b63174a0ddd49fc8dda9ca42caba924" translate="yes" xml:space="preserve">
          <source>Despite the name, neither C nor POSIX standards require this function to be implemented using &lt;a href=&quot;https://en.wikipedia.org/wiki/Quicksort&quot;&gt;quicksort&lt;/a&gt; or make any complexity or stability guarantees.</source>
          <target state="translated">이름에도 불구하고 C 또는 POSIX 표준은이 기능을 &lt;a href=&quot;https://en.wikipedia.org/wiki/Quicksort&quot;&gt;퀵 정렬을&lt;/a&gt; 사용하여 구현 하거나 복잡성 또는 안정성을 보장 할 것을 요구하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b78d139cdf486e1acc85058934b061d098dfdcab" translate="yes" xml:space="preserve">
          <source>Despite the name, neither C nor POSIX standards require this function to be implemented using binary search or make any complexity guarantees.</source>
          <target state="translated">이름에도 불구하고 C 또는 POSIX 표준에서는이 기능을 이진 검색을 사용하여 구현하거나 복잡성을 보장 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e759a1fb34e3f73a71f0a598c5a332119a8f59d1" translate="yes" xml:space="preserve">
          <source>Destroys the condition variable pointed to by &lt;code&gt;cond&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;cond&lt;/code&gt; 가 가리키는 조건 변수를 삭제합니다 .</target>
        </trans-unit>
        <trans-unit id="30db72753f6da400421d2bf7435f8d3d3aff73f5" translate="yes" xml:space="preserve">
          <source>Destroys the mutex pointed to by &lt;code&gt;mutex&lt;/code&gt;.</source>
          <target state="translated">mutex가 가리키는 &lt;code&gt;mutex&lt;/code&gt; 를 제거 합니다.</target>
        </trans-unit>
        <trans-unit id="1d86774c24e1a6900373ea2ea0eabca1cef9aefb" translate="yes" xml:space="preserve">
          <source>Destroys the thread-specific storage identified by &lt;code&gt;tss_id&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tss_id&lt;/code&gt; 로 식별 된 스레드 특정 스토리지를 삭제 합니다.</target>
        </trans-unit>
        <trans-unit id="e8ac19debfbe59f4081df2e1735171ca5f3762c9" translate="yes" xml:space="preserve">
          <source>Detaches the thread identified by &lt;code&gt;thr&lt;/code&gt; from the current environment. The resources held by the thread will be freed automatically once the thread exits.</source>
          <target state="translated">현재 환경에서 &lt;code&gt;thr&lt;/code&gt; 로 식별 된 스레드를 분리 합니다. 스레드가 보유한 자원은 스레드가 종료되면 자동으로 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="c3457bc8babb6145a4d1a3fb89cd5528841f3468" translate="yes" xml:space="preserve">
          <source>Determines if the atomic operations on all objects of the type &lt;code&gt;A&lt;/code&gt; (the type of the object pointed to by &lt;code&gt;obj&lt;/code&gt;) are lock-free. In any given program execution, the result of calling &lt;code&gt;atomic_is_lock_free&lt;/code&gt; is the same for all pointers of the same type.</source>
          <target state="translated">유형 &lt;code&gt;A&lt;/code&gt; 의 모든 객체 ( &lt;code&gt;obj&lt;/code&gt; 가 가리키는 객체의 유형)에 대한 원자 연산에 잠금이 없는지 확인합니다. 주어진 프로그램 실행에서 &lt;code&gt;atomic_is_lock_free&lt;/code&gt; 호출의 결과 는 동일한 유형의 모든 포인터에 대해 동일합니다.</target>
        </trans-unit>
        <trans-unit id="42961033930dd9b0cb31b3f60a0b7da407759c76" translate="yes" xml:space="preserve">
          <source>Determines if the floating point number &lt;code&gt;x&lt;/code&gt; is greater than or equal to the floating-point number &lt;code&gt;y&lt;/code&gt;, without setting floating-point exceptions.</source>
          <target state="translated">결정 부동 소수점 수의 경우 &lt;code&gt;x&lt;/code&gt; 보다 큰 또는 부동 소수점 수와 동일한 &lt;code&gt;y&lt;/code&gt; 부동 소수점 예외를 설정하지 않고.</target>
        </trans-unit>
        <trans-unit id="06ba39a9361411a3c82420f68b56c98e752e8285" translate="yes" xml:space="preserve">
          <source>Determines if the floating point number &lt;code&gt;x&lt;/code&gt; is greater than the floating-point number (&lt;code&gt;y&lt;/code&gt;), without setting floating-point exceptions.</source>
          <target state="translated">부동 소수점 예외를 설정하지 않고 부동 소수점 숫자 &lt;code&gt;x&lt;/code&gt; 가 부동 소수점 숫자 ( &lt;code&gt;y&lt;/code&gt; ) 보다 큰지를 판별합니다 .</target>
        </trans-unit>
        <trans-unit id="8f2c82d270fa552f3d9599b39ceefe0ab66e42be" translate="yes" xml:space="preserve">
          <source>Determines if the floating point number &lt;code&gt;x&lt;/code&gt; is less than or equal to the floating-point number &lt;code&gt;y&lt;/code&gt;, without setting floating-point exceptions.</source>
          <target state="translated">결정 부동 소수점 수의 경우 &lt;code&gt;x&lt;/code&gt; 보다 작거나 부동 소수점 수와 동일한 &lt;code&gt;y&lt;/code&gt; 부동 소수점 예외를 설정하지 않고.</target>
        </trans-unit>
        <trans-unit id="61cc741f2ceb8f899fe8f8a8102fd65dfe1cdb1b" translate="yes" xml:space="preserve">
          <source>Determines if the floating point number &lt;code&gt;x&lt;/code&gt; is less than or greater than the floating-point number &lt;code&gt;y&lt;/code&gt;, without setting floating-point exceptions.</source>
          <target state="translated">결정 부동 소수점 수의 경우 &lt;code&gt;x&lt;/code&gt; 보다 작거나 부동 소수점 숫자보다 크다 &lt;code&gt;y&lt;/code&gt; 부동 소수점 예외를 설정하지 않고.</target>
        </trans-unit>
        <trans-unit id="cc4f23eed57a50e680bbd714ba24c1ae9b04715c" translate="yes" xml:space="preserve">
          <source>Determines if the floating point number &lt;code&gt;x&lt;/code&gt; is less than the floating-point number &lt;code&gt;y&lt;/code&gt;, without setting floating-point exceptions.</source>
          <target state="translated">부동 소수점 예외를 설정하지 않고 부동 소수점 숫자 &lt;code&gt;x&lt;/code&gt; 가 부동 소수점 숫자 &lt;code&gt;y&lt;/code&gt; 보다 작은 지를 판별합니다 .</target>
        </trans-unit>
        <trans-unit id="12a023deb0e25da717685baee738b5001df78e3a" translate="yes" xml:space="preserve">
          <source>Determines if the floating point numbers &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are unordered, that is, one or both are NaN and thus cannot be meaningfully compared with each other.</source>
          <target state="translated">부동 소수점 숫자 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 가 순서가 없는지 여부 , 즉 하나 또는 둘 다 NaN이므로 서로 의미있게 비교할 수 없는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="1673883c418a37012138fdc6e721d284c1d37177" translate="yes" xml:space="preserve">
          <source>Determines if the given floating point number &lt;code&gt;arg&lt;/code&gt; has finite value i.e. it is normal, subnormal or zero, but not infinite or NaN. The macro returns an integral value.</source>
          <target state="translated">주어진 부동 소수점 숫자 &lt;code&gt;arg&lt;/code&gt; 에 유한 값이 있는지 여부를 판별합니다. 즉, 정상, 비정규 또는 0이지만 무한 또는 NaN이 아닙니다. 매크로는 정수 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f01a2032ba2b4ae13adc4724b8eac8696393ffb1" translate="yes" xml:space="preserve">
          <source>Determines if the given floating point number &lt;code&gt;arg&lt;/code&gt; is a not-a-number (NaN) value. The macro returns an integral value.</source>
          <target state="translated">주어진 부동 소수점 숫자 &lt;code&gt;arg&lt;/code&gt; 가 숫자 가 아닌 (NaN) 값 인지 판별 합니다. 매크로는 정수 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7ab9c686b97ad7bf5476551370095e04426a01d8" translate="yes" xml:space="preserve">
          <source>Determines if the given floating point number &lt;code&gt;arg&lt;/code&gt; is negative. The macro returns an integral value.</source>
          <target state="translated">주어진 부동 소수점 숫자 &lt;code&gt;arg&lt;/code&gt; 가 음수 인지 확인합니다 . 매크로는 정수 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c71330c3e714777dd145b0fec831b8fa8ff04aa4" translate="yes" xml:space="preserve">
          <source>Determines if the given floating point number &lt;code&gt;arg&lt;/code&gt; is normal, i.e. is neither zero, subnormal, infinite, nor &lt;code&gt;NaN&lt;/code&gt;. The macro returns an integral value.</source>
          <target state="translated">주어진 부동 소수점 수 &lt;code&gt;arg&lt;/code&gt; 가 정상인지, 즉 0, subnormal, 무한 또는 &lt;code&gt;NaN&lt;/code&gt; 이 아닌지 확인합니다 . 매크로는 정수 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="42bececa62b5cdaaf1bea284ccc4761215f18797" translate="yes" xml:space="preserve">
          <source>Determines if the given floating point number &lt;code&gt;arg&lt;/code&gt; is positive or negative infinity. The macro returns an integral value.</source>
          <target state="translated">주어진 부동 소수점 숫자 &lt;code&gt;arg&lt;/code&gt; 가 양의 무한대인지 음의 무한대 인지를 결정합니다 . 매크로는 정수 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d9abcfdbe740f7564155ea43385bb7b128ce45b2" translate="yes" xml:space="preserve">
          <source>Determines the size, in bytes, of the multibyte character whose first byte is pointed to by &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">첫 번째 바이트가 &lt;code&gt;s&lt;/code&gt; 로 가리키는 멀티 바이트 문자의 크기 (바이트)를 결정합니다 .</target>
        </trans-unit>
        <trans-unit id="4507028cacf93c00d5ae52796f91e29ec21b8e82" translate="yes" xml:space="preserve">
          <source>Determines the size, in bytes, of the representation of a multibyte character.</source>
          <target state="translated">멀티 바이트 문자 표현의 크기 (바이트)를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="c69c802d70e0e3f6788cfc1779895445bfc77a31" translate="yes" xml:space="preserve">
          <source>Determines which of the specified subset of the floating point exceptions are currently set. The argument &lt;code&gt;excepts&lt;/code&gt; is a bitwise OR of the &lt;a href=&quot;fe_exceptions&quot;&gt;floating point exception macros&lt;/a&gt;.</source>
          <target state="translated">부동 소수점 예외의 지정된 서브 세트 중 현재 설정되어있는 것을 판별합니다. &lt;code&gt;excepts&lt;/code&gt; 인수 는 &lt;a href=&quot;fe_exceptions&quot;&gt;부동 소수점 예외 매크로&lt;/a&gt; 의 비트 단위 OR입니다 .</target>
        </trans-unit>
        <trans-unit id="0d3a3771d727fe204d2df32971206ca839fb6ce3" translate="yes" xml:space="preserve">
          <source>Difference between two times in seconds.</source>
          <target state="translated">두 번의 초 차이.</target>
        </trans-unit>
        <trans-unit id="6170f244847af7dbbce945574fb4f39ec9c7c16b" translate="yes" xml:space="preserve">
          <source>Different implementations return different non-negative numbers: some return the last character written, some return the number of characters written (or INT_MAX if the string was longer than that), some simply return a non-negative constant such as zero.</source>
          <target state="translated">다른 구현은 음수가 아닌 다른 숫자를 반환합니다. 어떤 것은 마지막으로 쓴 문자를, 어떤 것은 쓴 문자의 수를 반환합니다 (또는 문자열이 그보다 긴 경우 INT_MAX를 반환), 어떤 것은 단순히 0과 같은 음이 아닌 상수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d3663230bcd568fa0f0bc0c99c9ad42d7948fb50" translate="yes" xml:space="preserve">
          <source>Different implementations return different non-negative numbers: some return the last character written, some return the number of characters written (or INT_MAX if the string was longer than that), some simply return a non-negative constant.</source>
          <target state="translated">다른 구현은 음수가 아닌 다른 숫자를 반환합니다. 어떤 것은 마지막으로 쓴 문자를, 어떤 것은 쓴 문자의 수를 반환합니다 (또는 문자열이 그보다 긴 경우 INT_MAX를 반환), 일부는 음이 아닌 상수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4cec1e48ed8268246c17cdf0e9f5b5116725afd5" translate="yes" xml:space="preserve">
          <source>Different threads of execution are always allowed to access (read and modify) different</source>
          <target state="translated">다른 실행 스레드는 항상 다른 액세스 (읽기 및 수정)가 가능합니다</target>
        </trans-unit>
        <trans-unit id="f347c23fb94afe99ca29d2298bd820db7bf1c6f2" translate="yes" xml:space="preserve">
          <source>Direct input/output</source>
          <target state="translated">직접 입출력</target>
        </trans-unit>
        <trans-unit id="28c82071e940360118b0611d5c912a71c32a0100" translate="yes" xml:space="preserve">
          <source>Directives</source>
          <target state="translated">Directives</target>
        </trans-unit>
        <trans-unit id="2df36c679013c753c1824914229ac0e9ed0ef85a" translate="yes" xml:space="preserve">
          <source>Discards any whitespace characters (as identified by calling &lt;code&gt;isspace()&lt;/code&gt;) until the first non-whitespace character is found, then takes as many characters as possible to form a valid</source>
          <target state="translated">공백이 아닌 첫 번째 문자를 찾을 때까지 공백 문자 ( &lt;code&gt;isspace()&lt;/code&gt; 를 호출하여 식별)를 버린 다음 가능한 한 많은 문자를 사용하여 유효한 문자를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="3f47e884dde353c0a64ae183f652592cd28d42e5" translate="yes" xml:space="preserve">
          <source>Discards any whitespace characters until the first non-whitespace character is found, then takes as many characters as possible to form a valid integer number representation and converts them to an integer value. The valid integer value consists of the following parts:</source>
          <target state="translated">공백이 아닌 첫 번째 문자가 발견 될 때까지 공백 문자를 버린 다음 가능한 한 많은 문자를 사용하여 유효한 정수 숫자 표현을 만들고 정수 값으로 변환합니다. 유효한 정수 값은 다음 부분으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="2b95cdc5966f0cb8891c7e9e0d564b397089da15" translate="yes" xml:space="preserve">
          <source>Dividing 0.0 by 0.0 gives NaN and &lt;code&gt;&lt;a href=&quot;../numeric/fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">0.0을 0.0으로 나누면 NaN이되고 &lt;code&gt;&lt;a href=&quot;../numeric/fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b155ca10158e241e3d1fad0c3aba4fd35761c88e" translate="yes" xml:space="preserve">
          <source>Dividing a non-zero number by &amp;plusmn;0.0 gives the correctly-signed infinity and &lt;code&gt;&lt;a href=&quot;../numeric/fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">0이 아닌 숫자를 &amp;plusmn; 0.0으로 나누면 올바르게 서명 된 무한대가 제공되고 &lt;code&gt;&lt;a href=&quot;../numeric/fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; 가 상승합니다.</target>
        </trans-unit>
        <trans-unit id="bbbec44416269797757a1579d0b1247911acd066" translate="yes" xml:space="preserve">
          <source>Division</source>
          <target state="translated">Division</target>
        </trans-unit>
        <trans-unit id="26c986c0b2a8c981af75cc9b323e96898b596d78" translate="yes" xml:space="preserve">
          <source>Domain error</source>
          <target state="translated">도메인 오류</target>
        </trans-unit>
        <trans-unit id="683ae4a82c0162283d391c1cde234ae848eeb039" translate="yes" xml:space="preserve">
          <source>Domain error may occur if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are both zero.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 가 모두 0 이면 도메인 오류가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="209a993b5d06ebc1189ef12bc6140d9643c1f5b5" translate="yes" xml:space="preserve">
          <source>Domain error may occur if &lt;code&gt;y&lt;/code&gt; is zero.</source>
          <target state="translated">&lt;code&gt;y&lt;/code&gt; 가 0 이면 도메인 오류가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f953ae32bdac16ba6277a0e47315c5bfadd7dae5" translate="yes" xml:space="preserve">
          <source>Domain error occurs if &lt;code&gt;arg&lt;/code&gt; is less than -1.</source>
          <target state="translated">&lt;code&gt;arg&lt;/code&gt; 가 -1보다 작은 경우 도메인 오류가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="1b2c79d3977fa1e82c68257e4ee3be3430c9d49f" translate="yes" xml:space="preserve">
          <source>Domain error occurs if &lt;code&gt;arg&lt;/code&gt; is less than zero.</source>
          <target state="translated">&lt;code&gt;arg&lt;/code&gt; 가 0보다 작은 경우 도메인 오류가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="206bd3375d61b90cec57754711bf77b10e8308ff" translate="yes" xml:space="preserve">
          <source>Domain error occurs if &lt;code&gt;arg&lt;/code&gt; is outside the range &lt;code&gt;[-1.0; 1.0]&lt;/code&gt;.</source>
          <target state="translated">만약 도메인 오류가 발생 &lt;code&gt;arg&lt;/code&gt; 범위 밖에 &lt;code&gt;[-1.0; 1.0]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="30b1970ca78476223062c512a821c8789e06506b" translate="yes" xml:space="preserve">
          <source>Domain or range error may occur if &lt;code&gt;arg&lt;/code&gt; is zero.</source>
          <target state="translated">&lt;code&gt;arg&lt;/code&gt; 가 0 이면 도메인 또는 범위 오류가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b1ca39980d3cc90251635580f9d046def1437b32" translate="yes" xml:space="preserve">
          <source>Due to &lt;a href=&quot;translation_phases#maximal_munch&quot;&gt;maximal munch&lt;/a&gt;, hexadecimal integer constants ending in &lt;code&gt;e&lt;/code&gt; and &lt;code&gt;E&lt;/code&gt;, when followed by the operators &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt;, must be separated from the operator with whitespace or parentheses in the source:</source>
          <target state="translated">&lt;a href=&quot;translation_phases#maximal_munch&quot;&gt;최대 munch&lt;/a&gt; 로 인해 &lt;code&gt;e&lt;/code&gt; 및 &lt;code&gt;E&lt;/code&gt; 로 끝나는 16 진 정수 상수는 뒤에 연산자 &lt;code&gt;+&lt;/code&gt; 또는 &lt;code&gt;-&lt;/code&gt; 가 오는 경우 소스에서 공백 또는 괄호로 연산자와 분리해야합니다.</target>
        </trans-unit>
        <trans-unit id="fbad71c32e999acfe150dcd28476b81eeb49a324" translate="yes" xml:space="preserve">
          <source>Due to its infinite intermediate precision, &lt;code&gt;fma&lt;/code&gt; is a common building block of other correctly-rounded mathematical operations, such as &lt;code&gt;&lt;a href=&quot;sqrt&quot;&gt;sqrt&lt;/a&gt;&lt;/code&gt; or even the division (where not provided by the CPU, e.g. Itanium).</source>
          <target state="translated">중간 정밀도가 무한하기 때문에 &lt;code&gt;fma&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;sqrt&quot;&gt;sqrt&lt;/a&gt;&lt;/code&gt; 또는 나눗셈 (예 : CPU에서 제공하지 않는 Itanium) 과 같은 올바르게 반올림 된 수학적 연산의 공통 빌딩 블록입니다 .</target>
        </trans-unit>
        <trans-unit id="a8edf7aed52e22273ca006dc7586e6c5a889a81c" translate="yes" xml:space="preserve">
          <source>Due to the alignment requirements, the number of allocated bytes is not necessarily equal to &lt;code&gt;num*size&lt;/code&gt;.</source>
          <target state="translated">정렬 요구 사항으로 인해 할당 된 바이트 수가 반드시 &lt;code&gt;num*size&lt;/code&gt; 와 같을 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="1ada3669ea0e73f0cca2ed0c6e2ffff046545a5e" translate="yes" xml:space="preserve">
          <source>Due to the definition of the &lt;a href=&quot;operator_arithmetic&quot;&gt;addition between a pointer and an integer&lt;/a&gt;, the result is the element of the array with the index equal to the result of integer-expression (or, if pointer-expression was pointing at ith element of some array, the index of the result is i plus the result of integer-expression).</source>
          <target state="translated">&lt;a href=&quot;operator_arithmetic&quot;&gt;포인터와 integer 사이&lt;/a&gt; 의 덧셈 의 정의로 인해 결과는 integer-expression의 결과와 동일한 인덱스를 가진 배열의 요소입니다 (또는 pointer-expression이 일부 배열의 i 번째 요소를 가리키는 경우 결과의 색인은 i + integer-expression의 결과입니다.</target>
        </trans-unit>
        <trans-unit id="6ca450ab66cc4bceeefc245e894ea6b43911af90" translate="yes" xml:space="preserve">
          <source>During each execution of a block in which a restricted pointer &lt;code&gt;P&lt;/code&gt; is declared (typically each execution of a function body in which &lt;code&gt;P&lt;/code&gt; is a function parameter), if some object that is accessible through &lt;code&gt;P&lt;/code&gt; (directly or indirectly) is modified, by any means, then all accesses to that object (both reads and writes) in that block must occur through &lt;code&gt;P&lt;/code&gt; (directly or indirectly), otherwise the behavior is undefined:</source>
          <target state="translated">제한된 포인터되는 블록마다 실행되는 동안 &lt;code&gt;P&lt;/code&gt; 는 (일반적하는 기능 체의 각각의 실행 선언 &lt;code&gt;P&lt;/code&gt; 는 함수 파라미터이다)를 통해 액세스하는 오브젝트 경우 &lt;code&gt;P&lt;/code&gt; 는 직간접 적으로 변형되어, 어떠한 방법으로 그런 다음 해당 블록의 해당 객체에 대한 모든 액세스 (읽기 및 쓰기)는 &lt;code&gt;P&lt;/code&gt; 를 통해 (직접 또는 간접적으로) 발생해야합니다 . 그렇지 않으면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="07293fea74c54774179ebe1157890c6ede5445d9" translate="yes" xml:space="preserve">
          <source>During program startup, the equivalent of &lt;code&gt;setlocale(&lt;a href=&quot;lc_categories&quot;&gt;LC_ALL&lt;/a&gt;, &quot;C&quot;);&lt;/code&gt; is executed before any user code is run.</source>
          <target state="translated">프로그램 시작 중 &lt;code&gt;setlocale(&lt;a href=&quot;lc_categories&quot;&gt;LC_ALL&lt;/a&gt;, &quot;C&quot;);&lt;/code&gt; 사용자 코드가 실행되기 전에 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="27eaec4864e4b466246e5081a68f0b07f10aafac" translate="yes" xml:space="preserve">
          <source>Dynamic memory management</source>
          <target state="translated">동적 메모리 관리</target>
        </trans-unit>
        <trans-unit id="7c3cba5cfb875c54a838f8fb7c062f2ab636df56" translate="yes" xml:space="preserve">
          <source>E2BIG, EACCES, ..., EXDEV</source>
          <target state="translated">E2BIG, EACCES, ..., EXDEV</target>
        </trans-unit>
        <trans-unit id="4a50ae31fdb1876dd49f36fd10696a265ad4f349" translate="yes" xml:space="preserve">
          <source>EDOM</source>
          <target state="translated">EDOM</target>
        </trans-unit>
        <trans-unit id="bafb9dc439b47e39a5166a169171eda5a0ccd069" translate="yes" xml:space="preserve">
          <source>EILSEQ</source>
          <target state="translated">EILSEQ</target>
        </trans-unit>
        <trans-unit id="cda4aab5bcbd0ed38717196ad5a3684cd59490a3" translate="yes" xml:space="preserve">
          <source>EOF</source>
          <target state="translated">EOF</target>
        </trans-unit>
        <trans-unit id="027a5d6bd60d44a140b125f5e6c684b7bb796a30" translate="yes" xml:space="preserve">
          <source>ERANGE</source>
          <target state="translated">ERANGE</target>
        </trans-unit>
        <trans-unit id="c1f146ea81ae03fae7db256856fdde169c5d5e44" translate="yes" xml:space="preserve">
          <source>EXIT_SUCCESS</source>
          <target state="translated">EXIT_SUCCESS</target>
        </trans-unit>
        <trans-unit id="5c2b8a61f8fe437d39117db5b2fb0b332818fd1a" translate="yes" xml:space="preserve">
          <source>EXIT_SUCCESS, EXIT_FAILURE</source>
          <target state="translated">EXIT_SUCCESS, EXIT_FAILURE</target>
        </trans-unit>
        <trans-unit id="69fa19d78ab53209ccdb3bf9ac261f7db68a9cbc" translate="yes" xml:space="preserve">
          <source>EXIT_SUCCESSEXIT_FAILURE</source>
          <target state="translated">EXIT_SUCCESSEXIT_FAILURE</target>
        </trans-unit>
        <trans-unit id="c354b3028bd8c5a1179ea67b0fa0ac0c52287a14" translate="yes" xml:space="preserve">
          <source>Each &lt;a href=&quot;expressions&quot;&gt;expression&lt;/a&gt; in C (an operator with its arguments, a function call, a constant, a variable name, etc) is characterized by two independent properties: a &lt;a href=&quot;compatible_type#Type&quot;&gt;type&lt;/a&gt; and a &lt;a href=&quot;expressions#General&quot;&gt;value category&lt;/a&gt;.</source>
          <target state="translated">C의 각 &lt;a href=&quot;expressions&quot;&gt;표현식&lt;/a&gt; (인수, 함수 호출, 상수, 변수 이름 등이있는 연산자)은 &lt;a href=&quot;compatible_type#Type&quot;&gt;유형&lt;/a&gt; 과 &lt;a href=&quot;expressions#General&quot;&gt;값 범주의&lt;/a&gt; 두 가지 독립적 인 특성으로 특성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="1f85f8ed086a86eb382bf3f36ce72b1f255a1a54" translate="yes" xml:space="preserve">
          <source>Each &lt;a href=&quot;identifier&quot;&gt;identifier&lt;/a&gt; that appears in a C program is</source>
          <target state="translated">C 프로그램에 나타나는 각 &lt;a href=&quot;identifier&quot;&gt;식별자&lt;/a&gt; 는</target>
        </trans-unit>
        <trans-unit id="034551eb33d55611bebf58f023be8399816d5832" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;memory_order_seq_cst&lt;/code&gt; operation B that loads from atomic variable M, observes one of the following:</source>
          <target state="translated">원자 변수 M에서로드되는 각 &lt;code&gt;memory_order_seq_cst&lt;/code&gt; 작업 B는 다음 중 하나를 관찰합니다.</target>
        </trans-unit>
        <trans-unit id="50ed6669658b1fc844a09041da527dd57c316058" translate="yes" xml:space="preserve">
          <source>Each argument of integer type undergoes</source>
          <target state="translated">정수형의 각 인수는</target>
        </trans-unit>
        <trans-unit id="9ebf5b751176ac260f746f693298237e7da46d0e" translate="yes" xml:space="preserve">
          <source>Each atomic object has its own associated</source>
          <target state="translated">각 원자 개체에는 자체 관련이 있습니다</target>
        </trans-unit>
        <trans-unit id="df6cd15388cf4a32a59a55dc9d5c90813f45174a" translate="yes" xml:space="preserve">
          <source>Each call to &lt;code&gt;mblen&lt;/code&gt; updates the internal global conversion state (a static object of type &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;mbstate_t&lt;/a&gt;&lt;/code&gt;, only known to this function). If the multibyte encoding uses shift states, care must be taken to avoid backtracking or multiple scans. In any case, multiple threads should not call &lt;code&gt;mblen&lt;/code&gt; without synchronization: &lt;code&gt;&lt;a href=&quot;mbrlen&quot;&gt;mbrlen&lt;/a&gt;&lt;/code&gt; may be used instead.</source>
          <target state="translated">&lt;code&gt;mblen&lt;/code&gt; 을 호출 할 때 마다 내부 전역 변환 상태 ( 이 함수에만 알려진 &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;mbstate_t&lt;/a&gt;&lt;/code&gt; 유형의 정적 객체 )가 업데이트됩니다. 멀티 바이트 인코딩이 시프트 상태를 사용하는 경우 역 추적 또는 여러 스캔을 피하기 위해주의를 기울여야합니다. 어쨌든 여러 스레드가 동기화없이 &lt;code&gt;mblen&lt;/code&gt; 을 호출해서는 안됩니다 . 대신 &lt;code&gt;&lt;a href=&quot;mbrlen&quot;&gt;mbrlen&lt;/a&gt;&lt;/code&gt; 을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73d303af5fb3c8b993bba7231f1a0f5f58ccb4f1" translate="yes" xml:space="preserve">
          <source>Each call to &lt;code&gt;mbtowc&lt;/code&gt; updates the internal global conversion state (a static object of type &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;mbstate_t&lt;/a&gt;&lt;/code&gt;, known only to this function). If the multibyte encoding uses shift states, care must be taken to avoid backtracking or multiple scans. In any case, multiple threads should not call &lt;code&gt;mbtowc&lt;/code&gt; without synchronization: &lt;code&gt;&lt;a href=&quot;mbrtowc&quot;&gt;mbrtowc&lt;/a&gt;&lt;/code&gt; may be used instead.</source>
          <target state="translated">&lt;code&gt;mbtowc&lt;/code&gt; 를 호출 할 때 마다 내부 전역 변환 상태 ( 이 함수에만 알려진 &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;mbstate_t&lt;/a&gt;&lt;/code&gt; 유형의 정적 객체 )가 업데이트됩니다. 멀티 바이트 인코딩이 시프트 상태를 사용하는 경우 역 추적 또는 여러 스캔을 피하기 위해주의를 기울여야합니다. 어쨌든 여러 스레드가 동기화없이 &lt;code&gt;mbtowc&lt;/code&gt; 를 호출하면 안됩니다 . 대신 &lt;code&gt;&lt;a href=&quot;mbrtowc&quot;&gt;mbrtowc&lt;/a&gt;&lt;/code&gt; 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a26487bbc956d044f713cce85b0df2b15bb37d5" translate="yes" xml:space="preserve">
          <source>Each call to &lt;code&gt;strtok&lt;/code&gt; modifies a static variable: is not thread safe.</source>
          <target state="translated">&lt;code&gt;strtok&lt;/code&gt; 에 대한 각 호출 은 정적 변수를 수정합니다. 스레드 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dbb07f43c006809f998028ea3a3213eba702b907" translate="yes" xml:space="preserve">
          <source>Each call to &lt;code&gt;wctomb&lt;/code&gt; updates the internal global conversion state (a static object of type &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;mbstate_t&lt;/a&gt;&lt;/code&gt;, known only to this function). If the multibyte encoding uses shift states, this function is not reentrant. In any case, multiple threads should not call &lt;code&gt;wctomb&lt;/code&gt; without synchronization: &lt;code&gt;&lt;a href=&quot;wcrtomb&quot;&gt;wcrtomb&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;wctomb_s&lt;/code&gt; may be used instead.</source>
          <target state="translated">&lt;code&gt;wctomb&lt;/code&gt; 를 호출 할 때마다 내부 글로벌 변환 상태 ( 이 함수에만 알려진 &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;mbstate_t&lt;/a&gt;&lt;/code&gt; 유형의 정적 오브젝트 )가 업데이트됩니다. 멀티 바이트 인코딩이 시프트 상태를 사용하는 경우이 기능은 재진입되지 않습니다. 어쨌든 여러 스레드가 동기화없이 &lt;code&gt;wctomb&lt;/code&gt; 를 호출하면 안됩니다 . 대신 &lt;code&gt;&lt;a href=&quot;wcrtomb&quot;&gt;wcrtomb&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;wctomb_s&lt;/code&gt; 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10c116fe99e7e4c63d5874a29e18cc77b07208ef" translate="yes" xml:space="preserve">
          <source>Each character is converted as if by a call to &lt;code&gt;&lt;a href=&quot;mbtowc&quot;&gt;mbtowc&lt;/a&gt;&lt;/code&gt;, except that the mbtowc conversion state is unaffected. The conversion stops if:</source>
          <target state="translated">각 문자의 호출에 의해 것처럼 변환된다 &lt;code&gt;&lt;a href=&quot;mbtowc&quot;&gt;mbtowc&lt;/a&gt;&lt;/code&gt; 는 의 mbtowc는 변환 상태가 영향을받지 않는 것을 제외하고. 다음과 같은 경우 변환이 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="8fdcfb8ea34567f6c07db16c3fdb8c247a630ac9" translate="yes" xml:space="preserve">
          <source>Each character is converted as if by a call to &lt;code&gt;&lt;a href=&quot;wcrtomb&quot;&gt;wcrtomb&lt;/a&gt;&lt;/code&gt;. The conversion stops if:</source>
          <target state="translated">각 문자는 &lt;code&gt;&lt;a href=&quot;wcrtomb&quot;&gt;wcrtomb&lt;/a&gt;&lt;/code&gt; 를 호출하는 것처럼 변환됩니다 . 다음과 같은 경우 변환이 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="b6a6b4bfe71a06eb1a9c2dcd04975303c04aa0c0" translate="yes" xml:space="preserve">
          <source>Each character is converted as if by a call to &lt;code&gt;&lt;a href=&quot;wctomb&quot;&gt;wctomb&lt;/a&gt;&lt;/code&gt;, except that the wctomb's conversion state is unaffected. The conversion stops if:</source>
          <target state="translated">각 문자의 호출에 의해 것처럼 변환된다 &lt;code&gt;&lt;a href=&quot;wctomb&quot;&gt;wctomb&lt;/a&gt;&lt;/code&gt; 는 wctomb를의 변환 상태가 영향을받지 않는 것을 제외하고. 다음과 같은 경우 변환이 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="139407327b9bb5d3c3d7c2958d54f12ce1b02006" translate="yes" xml:space="preserve">
          <source>Each character stored in the string may occupy more than one byte. The encoding used to represent characters in a multibyte character string is locale-specific: it may be UTF-8, GB18030, EUC-JP, Shift-JIS, etc. For example, the char array &lt;code&gt;{'\xe4','\xbd','\xa0','\xe5','\xa5','\xbd','\0'&lt;/code&gt;} is an NTMBS holding the string &lt;code&gt;&quot;你好&quot;&lt;/code&gt; in UTF-8 multibyte encoding: the first three bytes encode the character 你, the next three bytes encode the character 好. The same string encoded in GB18030 is the char array &lt;code&gt;{'\xc4', '\xe3', '\xba', '\xc3', '\0'&lt;/code&gt;}, where each of the two characters is encoded as a two-byte sequence.</source>
          <target state="translated">문자열에 저장된 각 문자는 둘 이상의 바이트를 차지할 수 있습니다. 멀티 바이트 문자열에서 문자를 나타내는 데 사용되는 인코딩은 로케일마다 다릅니다 (UTF-8, GB18030, EUC-JP, Shift-JIS 등). 예를 들어 char 배열 &lt;code&gt;{'\xe4','\xbd','\xa0','\xe5','\xa5','\xbd','\0'&lt;/code&gt; }은 UTF-8 멀티 바이트 인코딩으로 문자열 &lt;code&gt;&quot;你好&quot;&lt;/code&gt; 를 보유하는 NTMBS입니다 . 첫 3 바이트는 문자 你, 다음 3 바이트는 문자 好를 인코딩합니다. GB18030으로 인코딩 된 동일한 문자열은 문자 배열 &lt;code&gt;{'\xc4', '\xe3', '\xba', '\xc3', '\0'&lt;/code&gt; }입니다. 여기서 두 문자는 각각 2 바이트로 인코딩됩니다. 순서.</target>
        </trans-unit>
        <trans-unit id="68890a6b98ff2345efa51a151d230b6d6d04308c" translate="yes" xml:space="preserve">
          <source>Each complex type has the same &lt;a href=&quot;object&quot;&gt;object representation&lt;/a&gt; and &lt;a href=&quot;object&quot;&gt;alignment requirements&lt;/a&gt; as an &lt;a href=&quot;array&quot;&gt;array&lt;/a&gt; of two elements of the corresponding real type (&lt;code&gt;float&lt;/code&gt; for &lt;code&gt;float &lt;a href=&quot;../numeric/complex/complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt; for &lt;code&gt;double &lt;a href=&quot;../numeric/complex/complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;long double&lt;/code&gt; for &lt;code&gt;long double &lt;a href=&quot;../numeric/complex/complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;). The first element of the array holds the real part, and the second element of the array holds the imaginary component.</source>
          <target state="translated">각 복잡한 유형은 동일한 갖는 &lt;a href=&quot;object&quot;&gt;객체의 표현&lt;/a&gt; 과 &lt;a href=&quot;object&quot;&gt;정렬 요구&lt;/a&gt; 가 AS &lt;a href=&quot;array&quot;&gt;어레이&lt;/a&gt; (대응하는 실 형태의 두 요소의 &lt;code&gt;float&lt;/code&gt; 대 &lt;code&gt;float &lt;a href=&quot;../numeric/complex/complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; 대 &lt;code&gt;double &lt;a href=&quot;../numeric/complex/complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;long double&lt;/code&gt; 위한 &lt;code&gt;long double &lt;a href=&quot;../numeric/complex/complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; ). 배열의 첫 번째 요소는 실수 부분을 유지하고 배열의 두 번째 요소는 허수 구성 요소를 보유합니다.</target>
        </trans-unit>
        <trans-unit id="137efba0894a7ebae4cd21d84f7d4f31559eb6c4" translate="yes" xml:space="preserve">
          <source>Each compound literal creates only a single object in its scope:</source>
          <target state="translated">각 복합 리터럴은 해당 범위에서 단일 객체 만 만듭니다.</target>
        </trans-unit>
        <trans-unit id="a9df8d8eee431c451d6fc1af48d35c03f7433a26" translate="yes" xml:space="preserve">
          <source>Each compound statement introduces its own &lt;a href=&quot;scope&quot;&gt;block scope&lt;/a&gt;.</source>
          <target state="translated">각 복합 명령문은 자체 &lt;a href=&quot;scope&quot;&gt;블록 범위를&lt;/a&gt; 소개합니다 .</target>
        </trans-unit>
        <trans-unit id="d9b8fc8e52076ec7b7c61bffc9ddc3474662c826" translate="yes" xml:space="preserve">
          <source>Each declarator is one of the following:</source>
          <target state="translated">각 선언자는 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="79a901de123f9c94830f0127ef29a5f9dcf4d060" translate="yes" xml:space="preserve">
          <source>Each enumerated type is &lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;compatible&lt;/a&gt; with one of: &lt;code&gt;char&lt;/code&gt;, a signed integer type, or an unsigned integer type. It is implementation-defined which type is compatible with any given enumerated type, but whatever it is, it must be capable of representing all enumerator values of that enumeration.</source>
          <target state="translated">열거 된 각 유형은 &lt;code&gt;char&lt;/code&gt; , 부호있는 정수 유형 또는 부호없는 정수 유형 중 하나와 &lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;호환&lt;/a&gt; 됩니다 . 주어진 열거 형식과 호환되는 형식은 구현에 따라 정의되지만 형식에 관계없이 해당 열거의 모든 열거 자 값을 나타낼 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="e20b07c2f013df7b88017bc74253d151a6997995" translate="yes" xml:space="preserve">
          <source>Each enumerator that appears in the body of an enumeration specifier becomes an &lt;a href=&quot;constant_expression&quot;&gt;integer constant&lt;/a&gt; with type &lt;code&gt;int&lt;/code&gt; in the enclosing scope and can be used whenever integer constants are required (e.g. as a case label or as a non-VLA array size).</source>
          <target state="translated">열거 지정자의 본체에 표시가된다 각 열거 &lt;a href=&quot;constant_expression&quot;&gt;정수 상수&lt;/a&gt; 형으로 &lt;code&gt;int&lt;/code&gt; 클로징 범위 및 정수 상수가 요구 될 때마다 사용될 수있다 (예를 들어,이 경우 라벨이나 비 VLA 어레이 크기).</target>
        </trans-unit>
        <trans-unit id="b14993a86ee9276479d81f8deeff73026cd0493b" translate="yes" xml:space="preserve">
          <source>Each identifier (other than macro) is only valid within a part of the program called its &lt;a href=&quot;scope&quot;&gt;scope&lt;/a&gt; and belongs to one of four kinds of &lt;a href=&quot;name_space&quot;&gt;name spaces&lt;/a&gt;. Some identifiers have &lt;a href=&quot;storage_duration&quot;&gt;linkage&lt;/a&gt; which makes them refer to the same entities when they appear in different scopes or translation units.</source>
          <target state="translated">매크로 이외의 각 식별자는 해당 &lt;a href=&quot;scope&quot;&gt;범위&lt;/a&gt; 라는 프로그램의 일부 내에서만 유효하며 네 종류의 &lt;a href=&quot;name_space&quot;&gt;네임 스페이스&lt;/a&gt; 중 하나에 속합니다 . 일부 식별자에는 서로 다른 범위 나 변환 단위에 나타날 때 동일한 엔터티를 참조하도록하는 &lt;a href=&quot;storage_duration&quot;&gt;링크&lt;/a&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad4634fb5579a12854af07426a363d2ae6653fef" translate="yes" xml:space="preserve">
          <source>Each individual type in the C &lt;a href=&quot;compatible_type&quot;&gt;type system&lt;/a&gt; has several</source>
          <target state="translated">는 C의 각 개별 형 &lt;a href=&quot;compatible_type&quot;&gt;타입 시스템은&lt;/a&gt; 여러 가지가 있습니다</target>
        </trans-unit>
        <trans-unit id="b778434a270ebe1a3642fbd59833ce5e585f867f" translate="yes" xml:space="preserve">
          <source>Each member is allocated as if it were the only member of the union, which is why &lt;code&gt;s.c&lt;/code&gt; in the example above aliases the first byte of &lt;code&gt;s.s[0]&lt;/code&gt;.</source>
          <target state="translated">각 멤버는 공용체의 유일한 멤버 인 것처럼 할당되므로 위의 예에서 &lt;code&gt;s.c&lt;/code&gt; 는 &lt;code&gt;s.s[0]&lt;/code&gt; 의 첫 번째 바이트를 별명으로 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="1b6ef3be237b3fe7d1168941fc3d1dec86cd9c78" translate="yes" xml:space="preserve">
          <source>Each object type imposes its alignment requirement on every object of that type. The strictest (largest) fundamental alignment of any type is the alignment of &lt;code&gt;&lt;a href=&quot;../types/max_align_t&quot;&gt;max_align_t&lt;/a&gt;&lt;/code&gt;. The weakest (smallest) alignment is the alignment of the types &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;signed char&lt;/code&gt;, and &lt;code&gt;unsigned char&lt;/code&gt;, and equals 1.</source>
          <target state="translated">각 객체 유형은 해당 유형의 모든 객체에 대한 정렬 요구 사항을 부과합니다. 모든 유형의 가장 엄격한 (가장 큰) 기본 정렬은 &lt;code&gt;&lt;a href=&quot;../types/max_align_t&quot;&gt;max_align_t&lt;/a&gt;&lt;/code&gt; 의 정렬입니다 . 가장 약한 (가장 작은) 정렬은 &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;signed char&lt;/code&gt; 및 &lt;code&gt;unsigned char&lt;/code&gt; 유형의 정렬이며 1과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3bce51722d6b62312c671c879d5a6de1f802d8fe" translate="yes" xml:space="preserve">
          <source>Each of &lt;code&gt;#if&lt;/code&gt;, &lt;code&gt;#elif&lt;/code&gt;, &lt;code&gt;#else&lt;/code&gt;, &lt;code&gt;#ifdef&lt;/code&gt; and &lt;code&gt;#ifndef&lt;/code&gt; directives control a code block until the first &lt;code&gt;#elif&lt;/code&gt;, &lt;code&gt;#else&lt;/code&gt;, &lt;code&gt;#endif&lt;/code&gt; directive not belonging to any inner conditional preprocessing blocks.</source>
          <target state="translated">각 &lt;code&gt;#if&lt;/code&gt; , &lt;code&gt;#elif&lt;/code&gt; , &lt;code&gt;#else&lt;/code&gt; , &lt;code&gt;#ifdef&lt;/code&gt; 및 &lt;code&gt;#ifndef&lt;/code&gt; 지시문은 첫 번째 &lt;code&gt;#elif&lt;/code&gt; , &lt;code&gt;#else&lt;/code&gt; , &lt;code&gt;#endif&lt;/code&gt; 지시문이 내부 조건부 전처리 블록에 속하지 않을 때까지 코드 블록을 제어합니다 .</target>
        </trans-unit>
        <trans-unit id="13255e60126e8e8da26f8a162427af0c4a34405d" translate="yes" xml:space="preserve">
          <source>Each of the above macro constants expand to integer constant expressions with distinct values that are suitable for use as the first argument of &lt;code&gt;&lt;a href=&quot;setlocale&quot;&gt;setlocale&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">위의 각 매크로 상수는 &lt;code&gt;&lt;a href=&quot;setlocale&quot;&gt;setlocale&lt;/a&gt;&lt;/code&gt; 의 첫 번째 인수로 사용하기에 적합한 고유 값을 갖는 정수 상수 표현식으로 확장됩니다 .</target>
        </trans-unit>
        <trans-unit id="47dec134a6d556ab62aff5d62d028d693acc8498" translate="yes" xml:space="preserve">
          <source>Each of the above macro constants expands to an integer constant expression with distinct values, which represent different signals sent to the program.</source>
          <target state="translated">위의 각 매크로 상수는 고유 한 값을 갖는 정수 상수 표현식으로 확장되며, 이는 프로그램으로 전송되는 다른 신호를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f6863b3780b12fcd68451d2943aa34bb1600f54a" translate="yes" xml:space="preserve">
          <source>Each of the macros defined in &lt;code&gt;&amp;lt;errno.h&amp;gt;&lt;/code&gt; expands to an integer constant expression with type &lt;code&gt;int&lt;/code&gt; and with a unique positive value. The following constants are defined by ISO C. The implementation may define more, as long as they begin with &lt;code&gt;'E'&lt;/code&gt; followed by digits or uppercase letters.</source>
          <target state="translated">&lt;code&gt;&amp;lt;errno.h&amp;gt;&lt;/code&gt; 에 정의 된 각 매크로 는 &lt;code&gt;int&lt;/code&gt; 유형 과 고유 한 양수 값 을 갖는 정수 상수 표현식으로 확장됩니다 . 다음 상수는 ISO C에 의해 정의됩니다. 구현은 &lt;code&gt;'E'&lt;/code&gt; 로 시작하고 숫자 나 대문자가 오는 한 더 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="72f1807990ff12b536de30461fba27cc15d7e01f" translate="yes" xml:space="preserve">
          <source>Each of the three imaginary types has the same &lt;a href=&quot;object&quot;&gt;object representation&lt;/a&gt; and &lt;a href=&quot;object&quot;&gt;alignment requirement&lt;/a&gt; as its</source>
          <target state="translated">세 가지 가상 유형 각각은 동일한 &lt;a href=&quot;object&quot;&gt;객체 표현&lt;/a&gt; 및 &lt;a href=&quot;object&quot;&gt;정렬 요구 사항&lt;/a&gt; 을 갖 습니다.</target>
        </trans-unit>
        <trans-unit id="0edc9c873627a243af8d00da93f274ccae0173ff" translate="yes" xml:space="preserve">
          <source>Each of these macro constants expands to a nonnegative integer constant expression, which can be used with &lt;code&gt;&lt;a href=&quot;feround&quot;&gt;fesetround&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;feround&quot;&gt;fegetround&lt;/a&gt;&lt;/code&gt; to indicate one of the supported floating-point rounding modes. The implementation may define additional rounding mode constants in &lt;code&gt;&amp;lt;fenv.h&amp;gt;&lt;/code&gt;, which should all begin with &lt;code&gt;FE_&lt;/code&gt; followed by at least one uppercase letter. Each macro is only defined if it is supported.</source>
          <target state="translated">이러한 매크로 상수 각각은 음이 아닌 정수 상수 식으로 확장되며, &lt;code&gt;&lt;a href=&quot;feround&quot;&gt;fesetround&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;feround&quot;&gt;fegetround&lt;/a&gt;&lt;/code&gt; 와 함께 사용 하여 지원되는 부동 소수점 반올림 모드 중 하나를 나타냅니다. 구현시 &lt;code&gt;&amp;lt;fenv.h&amp;gt;&lt;/code&gt; 에서 추가 반올림 모드 상수를 정의 할 수 있으며 ,이 경우 모두 &lt;code&gt;FE_&lt;/code&gt; 로 시작하고 그 뒤에 하나 이상의 대문자가 와야합니다. 각 매크로는 지원되는 경우에만 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="c91547b3a6ee45d95762b25dda3cd9d3dac5ed28" translate="yes" xml:space="preserve">
          <source>Each of these macros expands to an expression that evaluates to the value of the specified complex type, with the real part having the value of &lt;code&gt;real&lt;/code&gt; (converted to the specified argument type) and the imaginary part having the value of &lt;code&gt;imag&lt;/code&gt; (converted to the specified argument type).</source>
          <target state="translated">이러한 각 매크로는 지정된 복소수 유형의 값으로 평가되는 표현식으로 확장되며, 실수 부분은 &lt;code&gt;real&lt;/code&gt; 값 (지정된 인수 유형으로 변환 됨)과 허수 부분은 &lt;code&gt;imag&lt;/code&gt; 값 (지정된 것으로 변환 됨)을 갖습니다. 인수 유형).</target>
        </trans-unit>
        <trans-unit id="daa18891fe69c786653bbe8101a0ff0d31ff1a44" translate="yes" xml:space="preserve">
          <source>Each parameter in a parameter-list is a &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt; that introduced a single variable, with the following additional properties:</source>
          <target state="translated">parameter-list의 각 매개 변수는 다음과 같은 추가 특성이있는 단일 변수를 도입 한 &lt;a href=&quot;declarations&quot;&gt;선언&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7b2f6db2798b2b2d64fe6857e20c316d195be57c" translate="yes" xml:space="preserve">
          <source>Each time &lt;code&gt;rand()&lt;/code&gt; is seeded with the same &lt;code&gt;seed&lt;/code&gt;, it must produce the same sequence of values.</source>
          <target state="translated">&lt;code&gt;rand()&lt;/code&gt; 에 동일한 &lt;code&gt;seed&lt;/code&gt; 가 시드 될 때마다 동일한 값 시퀀스를 생성해야합니다.</target>
        </trans-unit>
        <trans-unit id="8c7893661e60dbd1dacc8ed252ed6eaf9b8c2f87" translate="yes" xml:space="preserve">
          <source>Each time the flow of control passes over the declaration, expression is evaluated (and it must always evaluate to a value greater than zero), and the array is allocated (correspondingly, &lt;a href=&quot;lifetime&quot;&gt;lifetime&lt;/a&gt; of a VLA ends when the declaration goes out of scope). The size of each VLA instance does not change during its lifetime, but on another pass over the same code, it may be allocated with a different size.</source>
          <target state="translated">제어 흐름이 선언을 통과 할 때마다 표현식이 평가되고 (항상 0보다 큰 값으로 평가되어야 함) 배열이 할당됩니다 (해당 선언이 범위를 벗어나면 VLA의 &lt;a href=&quot;lifetime&quot;&gt;수명&lt;/a&gt; 이 종료 됨). 각 VLA 인스턴스의 크기는 수명 동안 변경되지 않지만 동일한 코드를 통한 다른 패스에서는 다른 크기로 할당 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d2d2ec1c54af1bd7f51aa9bb54b8cab4a5b8234" translate="yes" xml:space="preserve">
          <source>Each translation unit may have zero or one external definition of every identifier with &lt;a href=&quot;storage_duration&quot;&gt;internal linkage&lt;/a&gt; (a &lt;code&gt;static&lt;/code&gt; global).</source>
          <target state="translated">각 번역 단위에는 &lt;a href=&quot;storage_duration&quot;&gt;내부 연결&lt;/a&gt; ( &lt;code&gt;static&lt;/code&gt; 전역)이 있는 모든 식별자의 외부 정의가 없거나 하나만있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="720b5dbc53190f0e13902f7885ccaf43bb9991de" translate="yes" xml:space="preserve">
          <source>Effect</source>
          <target state="translated">Effect</target>
        </trans-unit>
        <trans-unit id="e462a3162644e49e48fa52678a61c2c86777646c" translate="yes" xml:space="preserve">
          <source>Effective type</source>
          <target state="translated">효과적인 유형</target>
        </trans-unit>
        <trans-unit id="7e8faa87b0aa2cac770e9abb0f6c2733e6104d24" translate="yes" xml:space="preserve">
          <source>Empty declarators are prohibited; a declaration must be a &lt;a href=&quot;static_assert&quot;&gt;static_assert&lt;/a&gt; declaration or (since C11) have at least one declarator or declare at least one struct/union/enum tag, or introduce at least one enumeration constant.</source>
          <target state="translated">빈 선언자는 금지됩니다. 선언은 &lt;a href=&quot;static_assert&quot;&gt;static_assert&lt;/a&gt; 선언이거나 (C11부터) 하나 이상의 선언자가 있거나 하나 이상의 struct / union / enum 태그를 선언하거나 하나 이상의 열거 상수를 도입해야합니다.</target>
        </trans-unit>
        <trans-unit id="8354d856832ccb717132df4747df0b697bdada66" translate="yes" xml:space="preserve">
          <source>Entering the scope of a non-variably modified variable is permitted:</source>
          <target state="translated">가변적으로 수정되지 않은 변수의 범위를 입력하는 것이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="cce45ab49aa862f3c61dbc001925b96425c01c53" translate="yes" xml:space="preserve">
          <source>Enumerated type is declared using the following</source>
          <target state="translated">열거 형은 다음을 사용하여 선언됩니다.</target>
        </trans-unit>
        <trans-unit id="b85c029cc85bf41632bef2658cfd560e45013841" translate="yes" xml:space="preserve">
          <source>Enumerated types are integer types, and as such can be used anywhere other integer types can, including in &lt;a href=&quot;conversion&quot;&gt;implicit conversions&lt;/a&gt; and &lt;a href=&quot;operator_arithmetic&quot;&gt;arithmetic operators&lt;/a&gt;.</source>
          <target state="translated">열거 유형은 정수 유형이므로 &lt;a href=&quot;conversion&quot;&gt;암시 적 변환&lt;/a&gt; 및 &lt;a href=&quot;operator_arithmetic&quot;&gt;산술 연산자를&lt;/a&gt; 포함하여 다른 정수 유형이 사용될 수있는 모든 곳에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="413e9110db4f37157b581483ed8d7133f5021d89" translate="yes" xml:space="preserve">
          <source>Enumerations</source>
          <target state="translated">Enumerations</target>
        </trans-unit>
        <trans-unit id="f88783e04a87a739f9d3e33a3937c9a19a386846" translate="yes" xml:space="preserve">
          <source>Enumerations permit the declaration of named constants in a more convenient and structured fashion than does &lt;code&gt;#define&lt;/code&gt;; they are visible in the debugger, obey scope rules, and participate in the type system.</source>
          <target state="translated">열거 형은 명명 된 상수를 &lt;code&gt;#define&lt;/code&gt; 보다 더 편리하고 구조화 된 방식으로 선언 할 수 있습니다 . 그것들은 디버거에서 볼 수 있고 범위 규칙을 준수하며 형식 시스템에 참여합니다.</target>
        </trans-unit>
        <trans-unit id="2a6aa35f8013684cff4ad26bb51395662e2921e2" translate="yes" xml:space="preserve">
          <source>Equality operators</source>
          <target state="translated">평등 연산자</target>
        </trans-unit>
        <trans-unit id="1f55cac8623bcd3e718c002528aa20c26ca69289" translate="yes" xml:space="preserve">
          <source>Equivalent</source>
          <target state="translated">Equivalent</target>
        </trans-unit>
        <trans-unit id="c0c4f8d56bcbf00282cc105e43dd3c5e2278f8e5" translate="yes" xml:space="preserve">
          <source>Equivalent of</source>
          <target state="translated">등가</target>
        </trans-unit>
        <trans-unit id="0d5a1140e6675b099ff86f62e1a9eab77af23453" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;fgetc&quot;&gt;getc&lt;/a&gt;(&lt;a href=&quot;../io&quot;&gt;stdin&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;fgetc&quot;&gt;getc&lt;/a&gt;(&lt;a href=&quot;../io&quot;&gt;stdin&lt;/a&gt;)&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="c4437d42fc6fd03749f5eff27c4e2e72ba49870e" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;fmax&quot;&gt;fmax&lt;/a&gt;(x-y, 0)&lt;/code&gt; except for the NaN handling requirements.</source>
          <target state="translated">등가 &lt;code&gt;&lt;a href=&quot;fmax&quot;&gt;fmax&lt;/a&gt;(x-y, 0)&lt;/code&gt; NaN의 처리 요건을 제외.</target>
        </trans-unit>
        <trans-unit id="04012d0d49a9a54dad1dc682a3e125bd8fa3f90a" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;fputc&quot;&gt;putc&lt;/a&gt;(ch, &lt;a href=&quot;../io&quot;&gt;stdout&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;fputc&quot;&gt;putc&lt;/a&gt;(ch, &lt;a href=&quot;../io&quot;&gt;stdout&lt;/a&gt;)&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="3afb8f001e247060377e8e5e40c5712afc040c31" translate="yes" xml:space="preserve">
          <source>Equivalent type</source>
          <target state="translated">동등한 유형</target>
        </trans-unit>
        <trans-unit id="9fc37eb09ee0018dcccc12a37a104dbad90d4bbf" translate="yes" xml:space="preserve">
          <source>Error and gamma functions</source>
          <target state="translated">오류 및 감마 기능</target>
        </trans-unit>
        <trans-unit id="5343729b1e8d28fc4392758181e1915608251253" translate="yes" xml:space="preserve">
          <source>Error directive</source>
          <target state="translated">오류 지시어</target>
        </trans-unit>
        <trans-unit id="73631d7f0356fdbdeaa36f8e5dbad89c6aa15dc4" translate="yes" xml:space="preserve">
          <source>Error handling</source>
          <target state="translated">오류 처리</target>
        </trans-unit>
        <trans-unit id="f9c4c6711618f251c4a454ba58410243568d56b8" translate="yes" xml:space="preserve">
          <source>Error handling and special values</source>
          <target state="translated">오류 처리 및 특수 값</target>
        </trans-unit>
        <trans-unit id="a70dcd4b1cc80d9067639e0fc5853ef1c8bcd9a3" translate="yes" xml:space="preserve">
          <source>Error numbers</source>
          <target state="translated">오류 번호</target>
        </trans-unit>
        <trans-unit id="9b7991b8ea4ab2716507d16d0d5014effed9479c" translate="yes" xml:space="preserve">
          <source>Errors and special cases are handled as if the function is implemented as &lt;code&gt;&lt;a href=&quot;../math/atan2&quot;&gt;atan2&lt;/a&gt;(&lt;a href=&quot;cimag&quot;&gt;cimag&lt;/a&gt;(z), &lt;a href=&quot;creal&quot;&gt;creal&lt;/a&gt;(z))&lt;/code&gt;.</source>
          <target state="translated">함수가 &lt;code&gt;&lt;a href=&quot;../math/atan2&quot;&gt;atan2&lt;/a&gt;(&lt;a href=&quot;cimag&quot;&gt;cimag&lt;/a&gt;(z), &lt;a href=&quot;creal&quot;&gt;creal&lt;/a&gt;(z))&lt;/code&gt; 로 구현 된 것처럼 오류와 특수한 경우가 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="29f3fbec0914aad4f195e9f22c13389761f4eda3" translate="yes" xml:space="preserve">
          <source>Errors and special cases are handled as if the function is implemented as &lt;code&gt;&lt;a href=&quot;../math/hypot&quot;&gt;hypot&lt;/a&gt;(&lt;a href=&quot;creal&quot;&gt;creal&lt;/a&gt;(z), &lt;a href=&quot;cimag&quot;&gt;cimag&lt;/a&gt;(z))&lt;/code&gt;.</source>
          <target state="translated">함수가 &lt;code&gt;&lt;a href=&quot;../math/hypot&quot;&gt;hypot&lt;/a&gt;(&lt;a href=&quot;creal&quot;&gt;creal&lt;/a&gt;(z), &lt;a href=&quot;cimag&quot;&gt;cimag&lt;/a&gt;(z))&lt;/code&gt; 로 구현 된 것처럼 오류 및 특수 사례가 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="9f8ce90616fde10146b8dfeb4286e7484aadd29d" translate="yes" xml:space="preserve">
          <source>Errors and special cases are handled as if the operation is implemented by &lt;code&gt;-I * &lt;a href=&quot;casinh&quot;&gt;casinh&lt;/a&gt;(I*z)&lt;/code&gt;.</source>
          <target state="translated">조작이 &lt;code&gt;-I * &lt;a href=&quot;casinh&quot;&gt;casinh&lt;/a&gt;(I*z)&lt;/code&gt; 의해 구현되는 것처럼 오류 및 특수 사례가 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="c2ad0fbbd2e9144d24b0206f35348f9eb15a8311" translate="yes" xml:space="preserve">
          <source>Errors and special cases are handled as if the operation is implemented by &lt;code&gt;-I * &lt;a href=&quot;catanh&quot;&gt;catanh&lt;/a&gt;(I*z)&lt;/code&gt;.</source>
          <target state="translated">조작이 &lt;code&gt;-I * &lt;a href=&quot;catanh&quot;&gt;catanh&lt;/a&gt;(I*z)&lt;/code&gt; 의해 구현되는 것처럼 오류 및 특수 사례가 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="6535634d0df324c4614ac7796d64c3f99bbff78e" translate="yes" xml:space="preserve">
          <source>Errors and special cases are handled as if the operation is implemented by &lt;code&gt;-I * &lt;a href=&quot;csinh&quot;&gt;csinh&lt;/a&gt;(I*z)&lt;/code&gt;.</source>
          <target state="translated">조작이 &lt;code&gt;-I * &lt;a href=&quot;csinh&quot;&gt;csinh&lt;/a&gt;(I*z)&lt;/code&gt; 의해 구현되는 것처럼 오류 및 특수 경우가 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="48bd51bf26820b80bd7f413a44a3c11a3b8a5518" translate="yes" xml:space="preserve">
          <source>Errors and special cases are handled as if the operation is implemented by &lt;code&gt;-i * &lt;a href=&quot;ctanh&quot;&gt;ctanh&lt;/a&gt;(i*z)&lt;/code&gt;, where &lt;code&gt;i&lt;/code&gt; is the imaginary unit.</source>
          <target state="translated">오류와 특수한 경우는 &lt;code&gt;-i * &lt;a href=&quot;ctanh&quot;&gt;ctanh&lt;/a&gt;(i*z)&lt;/code&gt; 의해 작업이 구현되는 것처럼 처리됩니다 . 여기서 &lt;code&gt;i&lt;/code&gt; 는 허수 단위입니다.</target>
        </trans-unit>
        <trans-unit id="ddccf748db358f35c8fb537b8295656e86fda50d" translate="yes" xml:space="preserve">
          <source>Errors and special cases are handled as if the operation is implemented by &lt;code&gt;&lt;a href=&quot;ccosh&quot;&gt;ccosh&lt;/a&gt;(I*z)&lt;/code&gt;.</source>
          <target state="translated">조작이 &lt;code&gt;&lt;a href=&quot;ccosh&quot;&gt;ccosh&lt;/a&gt;(I*z)&lt;/code&gt; 의해 구현되는 것처럼 오류 및 특수 사례가 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="015370df3b3d878085ca7e1b0df922c105e8a2f7" translate="yes" xml:space="preserve">
          <source>Errors and special cases are handled as if the operation is implemented by &lt;code&gt;&lt;a href=&quot;cexp&quot;&gt;cexp&lt;/a&gt;(y*&lt;a href=&quot;clog&quot;&gt;clog&lt;/a&gt;(x))&lt;/code&gt;, except that the implementation is allowed to treat special cases more carefully.</source>
          <target state="translated">구현이 특수한 경우를보다 신중하게 처리 할 수 ​​있다는 점을 제외하고 &lt;code&gt;&lt;a href=&quot;cexp&quot;&gt;cexp&lt;/a&gt;(y*&lt;a href=&quot;clog&quot;&gt;clog&lt;/a&gt;(x))&lt;/code&gt; 작업이 구현되는 것처럼 오류 및 특수한 경우가 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="5664fd51a61bce212813ac45ba91c49cd919c4bb" translate="yes" xml:space="preserve">
          <source>Errors are reported as specified in &lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling에&lt;/a&gt; 지정된대로 오류가보고됩니다 .</target>
        </trans-unit>
        <trans-unit id="7331ffbc406cc972b5f70c046e3dc2cb4171b6f9" translate="yes" xml:space="preserve">
          <source>Errors are reported consistent with &lt;a href=&quot;../math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt; 과 일치하는 오류가보고됩니다 .</target>
        </trans-unit>
        <trans-unit id="b4cfe1f435f06beaae8e7d7c6d43e5dddbe640bb" translate="yes" xml:space="preserve">
          <source>Escape</source>
          <target state="translated">Escape</target>
        </trans-unit>
        <trans-unit id="aa094bf265d4ea86b5f894d7a380cedfb2baed9e" translate="yes" xml:space="preserve">
          <source>Escape sequences</source>
          <target state="translated">이스케이프 시퀀스</target>
        </trans-unit>
        <trans-unit id="85839c11b208637a83e2015db29c3b0304d083b7" translate="yes" xml:space="preserve">
          <source>Escape sequences are used to represent certain special characters within &lt;a href=&quot;string_literal&quot;&gt;string literals&lt;/a&gt; and &lt;a href=&quot;character_constant&quot;&gt;character constants&lt;/a&gt;.</source>
          <target state="translated">이스케이프 시퀀스는 &lt;a href=&quot;string_literal&quot;&gt;문자열 리터럴&lt;/a&gt; 및 &lt;a href=&quot;character_constant&quot;&gt;문자 상수&lt;/a&gt; 내에서 특정 특수 문자를 나타내는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="47781613c9e738b50e8ae9c4be68dba24be3e79d" translate="yes" xml:space="preserve">
          <source>Establishes memory synchronization ordering of non-atomic and relaxed atomic accesses, as instructed by &lt;code&gt;order&lt;/code&gt;, between a thread and a signal handler executed on the same thread. This is equivalent to &lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;atomic_thread_fence&lt;/a&gt;&lt;/code&gt;, except no CPU instructions for memory ordering are issued. Only reordering of the instructions by the compiler is suppressed as &lt;code&gt;order&lt;/code&gt; instructs. For example, a fence with release semantics prevents reads or writes from being moved past subsequent writes and a fence with acquire semantics prevents reads or writes from being moved ahead of preceding reads.</source>
          <target state="translated">스레드와 동일한 스레드에서 실행되는 신호 처리기 사이 에 &lt;code&gt;order&lt;/code&gt; 에 지시 된 대로 원자 적이 지 않고 완화 된 원자 액세스의 메모리 동기화 순서를 설정합니다. 메모리 순서 지정을위한 CPU 명령어가 발행되지 않는다는 점을 제외하고 &lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;atomic_thread_fence&lt;/a&gt;&lt;/code&gt; 와 같습니다 . 만 컴파일러에 의해 지시의 재정렬이 억제되는 &lt;code&gt;order&lt;/code&gt; 에 지시합니다. 예를 들어 릴리스 의미 체계가있는 펜스는 읽기 또는 쓰기가 후속 쓰기를 지나서 이동하는 것을 방지하고 획득 의미 체계가있는 펜스는 읽기 또는 쓰기가 이전 읽기보다 먼저 이동하는 것을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="048318643abdfe7a81cc91065c11083e88436879" translate="yes" xml:space="preserve">
          <source>Establishes memory synchronization ordering of non-atomic and relaxed atomic accesses, as instructed by &lt;code&gt;order&lt;/code&gt;, without an associated atomic operation. For example, all non-atomic and relaxed atomic stores that happen before a &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_release&lt;/a&gt;&lt;/code&gt; fence in thread A will be synchronized with non-atomic and relaxed atomic loads from the same locations made in thread B after an &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_acquire&lt;/a&gt;&lt;/code&gt; fence.</source>
          <target state="translated">원자 단위 조작없이 &lt;code&gt;order&lt;/code&gt; 에 의해 지시 된 대로 원자 적이 지 않고 완화 된 원자 액세스의 메모리 동기화 순서를 설정 합니다. 예를 들어, 스레드 A 의 &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_release&lt;/a&gt;&lt;/code&gt; 펜스 이전에 발생하는 모든 비 원자 및 완화 원자 저장소는 memory_order_acquire 펜스 다음에 스레드 B에서 &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_acquire&lt;/a&gt;&lt;/code&gt; 동일한 위치에서 원자가 아닌 완화 원자로드와 동기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="da7594d31984baf99a077013f0aee618827920d2" translate="yes" xml:space="preserve">
          <source>Evaluation order and sequencing</source>
          <target state="translated">평가 순서 및 시퀀싱</target>
        </trans-unit>
        <trans-unit id="88a2bca2793ae8a8d628ac99dc40807e8857f907" translate="yes" xml:space="preserve">
          <source>Evaluations</source>
          <target state="translated">Evaluations</target>
        </trans-unit>
        <trans-unit id="36ee6d82a71221af57f6cb7a03ba7685ffbfddc0" translate="yes" xml:space="preserve">
          <source>Even if the struct is declared at file scope, when the identifier used to access the struct has block scope, the aliasing assertions in the struct also have block scope; the aliasing assertions are only in effect within a block execution or a function call, depending on how the object of this struct type was created:</source>
          <target state="translated">구조체가 파일 범위에서 선언 되더라도 구조체에 액세스하는 데 사용 된 식별자에 블록 범위가있는 경우 구조체의 앨리어싱 어설 션에도 블록 범위가 있습니다. 앨리어싱 어설 션은이 구조체 유형의 객체가 생성 된 방식에 따라 블록 실행 또는 함수 호출 내에서만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="4d9633b8291e518788e5b04c3307f8044e23b7cb" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;%c&lt;/code&gt; expects &lt;code&gt;int&lt;/code&gt; argument, it is safe to pass a &lt;code&gt;char&lt;/code&gt; because of the integer promotion that takes place when a variadic function is called.</source>
          <target state="translated">&lt;code&gt;%c&lt;/code&gt; 는 &lt;code&gt;int&lt;/code&gt; 인수를 기대 하지만 변수 가 variadic 함수가 호출 될 때 발생하는 정수 승격 때문에 &lt;code&gt;char&lt;/code&gt; 을 전달하는 것이 안전합니다 .</target>
        </trans-unit>
        <trans-unit id="5b93cdea25ae5893703b1e0c9f4bb48b32e72ce3" translate="yes" xml:space="preserve">
          <source>Even though the number of bits in the object representation of &lt;code&gt;_Bool&lt;/code&gt; is at least &lt;code&gt;&lt;a href=&quot;../types/limits&quot;&gt;CHAR_BIT&lt;/a&gt;&lt;/code&gt;, the width of the bit field of type &lt;code&gt;_Bool&lt;/code&gt; cannot be greater than 1.</source>
          <target state="translated">&lt;code&gt;_Bool&lt;/code&gt; 의 객체 표현에서 비트 수가 최소한 &lt;code&gt;&lt;a href=&quot;../types/limits&quot;&gt;CHAR_BIT&lt;/a&gt;&lt;/code&gt; 이지만 &lt;code&gt;_Bool&lt;/code&gt; 유형의 비트 필드 너비는 1보다 클 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="10fd3c8aba749cc32d306face2dcaddfb71e36f1" translate="yes" xml:space="preserve">
          <source>Even though there is no specific limit on the length of identifiers, early compilers had limits on the number of significant initial characters in identifiers and the linkers imposed stricter limits on the names with &lt;a href=&quot;storage_duration&quot;&gt;external linkage&lt;/a&gt;. C requires that at least the following limits are supported by any standard-compliant implementation:</source>
          <target state="translated">식별자 길이에는 특정 제한이 없지만 초기 컴파일러는 식별자의 중요한 초기 문자 수에 제한이 있었고 링커는 &lt;a href=&quot;storage_duration&quot;&gt;외부 연결&lt;/a&gt; 을 사용하는 이름에 대해 더 엄격한 제한을 부과했습니다 . C는 표준 준수 구현에서 최소한 다음 제한을 지원해야합니다.</target>
        </trans-unit>
        <trans-unit id="34f56d64ef5c3ff1c58a58a3f028aec046f7ad01" translate="yes" xml:space="preserve">
          <source>Every &lt;a href=&quot;conversion&quot;&gt;implicit conversion as if by assignment&lt;/a&gt; is allowed.</source>
          <target state="translated">&lt;a href=&quot;conversion&quot;&gt;할당&lt;/a&gt; 에 의한 것처럼 모든 암시 적 변환 이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="0552d54ca99d47b5775e0a8174d152fba75dddd0" translate="yes" xml:space="preserve">
          <source>Every &lt;a href=&quot;object&quot;&gt;object&lt;/a&gt; has a property called</source>
          <target state="translated">모든 &lt;a href=&quot;object&quot;&gt;객체&lt;/a&gt; 에는</target>
        </trans-unit>
        <trans-unit id="79fb7987aac6f001bd1913612f374a0a305f404f" translate="yes" xml:space="preserve">
          <source>Every &lt;a href=&quot;object&quot;&gt;object&lt;/a&gt; in C exists, has a constant address, retains its last-stored value (except when the value is indeterminate), and, for VLA, retains its size(since C99) over a portion of program execution known as this object's</source>
          <target state="translated">C의 모든 &lt;a href=&quot;object&quot;&gt;객체&lt;/a&gt; 는 존재하며, 일정한 주소를 가지며, 마지막으로 저장된 값을 유지하고 (값이 결정되지 않은 경우 제외) VLA의 경우이 객체의 것으로 알려진 프로그램 실행 부분에 대해 크기 (C99 이후)를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="d8cff106094b582cf23eb28cf52ff54b75ae2920" translate="yes" xml:space="preserve">
          <source>Every C program coded to run in a hosted execution environment contains the definition (not the prototype) of a function called &lt;code&gt;main&lt;/code&gt;, which is the designated start of the program.</source>
          <target state="translated">호스팅 된 실행 환경에서 실행되도록 코딩 된 모든 C 프로그램에는 프로그램의 지정된 시작 인 &lt;code&gt;main&lt;/code&gt; 이라는 함수의 정의 (시제품이 아님)가 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cae676f55ead9bfd321ee42d49211710fc97d787" translate="yes" xml:space="preserve">
          <source>Every access (both read and write) made through an lvalue expression of volatile-qualified type is considered an observable side effect for the purpose of optimization and is evaluated strictly according to the rules of the abstract machine (that is, all writes are completed at some time before the next sequence point). This means that within a single thread of execution, a volatile access cannot be optimized out or reordered relative to another visible side effect that is separated by a &lt;a href=&quot;eval_order&quot;&gt;sequence point&lt;/a&gt; from the volatile access.</source>
          <target state="translated">volatile-qualified type의 lvalue 표현식을 통해 수행 된 모든 액세스 (읽기 및 쓰기)는 최적화 목적으로 관찰 가능한 부작용으로 간주되며 추상 기계의 규칙에 따라 엄격하게 평가됩니다 (즉, 모든 쓰기는 다음 시퀀스 포인트 이전의 시간). 즉, 단일 실행 스레드 내에서 휘발성 액세스는 &lt;a href=&quot;eval_order&quot;&gt;시퀀스 포인트에&lt;/a&gt; 의해 휘발성 액세스에서 분리 된 다른 가시적 부작용에 대해 최적화되거나 재정렬 될 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="df1932660c52d52e2e26dcedc3c43bd56fad8d39" translate="yes" xml:space="preserve">
          <source>Every complete &lt;a href=&quot;types#Type_groups&quot;&gt;object type&lt;/a&gt; has a property called</source>
          <target state="translated">모든 완전한 &lt;a href=&quot;types#Type_groups&quot;&gt;객체 유형&lt;/a&gt; 에는</target>
        </trans-unit>
        <trans-unit id="e8fde6683e1cba2eec62200fcab6dfb05315c256" translate="yes" xml:space="preserve">
          <source>Every declaration of an &lt;a href=&quot;enum&quot;&gt;enum&lt;/a&gt; or a &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; is a definition.</source>
          <target state="translated">&lt;a href=&quot;enum&quot;&gt;열거 형&lt;/a&gt; 또는 &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; 의 모든 선언은 정의입니다.</target>
        </trans-unit>
        <trans-unit id="b050826ffcdfc3e1e44f6fc0d20279eecea1e997" translate="yes" xml:space="preserve">
          <source>Every expression belongs to one of three value categories: lvalue, non-lvalue object (rvalue), and function designator.</source>
          <target state="translated">모든 표현식은 lvalue, llvalue가 아닌 객체 (rvalue) 및 함수 지정자의 세 가지 값 범주 중 하나에 속합니다.</target>
        </trans-unit>
        <trans-unit id="5d22a5219034805f8cbb9d13ebb2c2aa525868ea" translate="yes" xml:space="preserve">
          <source>Every expression in the initializer list must be a &lt;a href=&quot;constant_expression&quot;&gt;constant expression&lt;/a&gt; when initializing aggregates of any storage duration.</source>
          <target state="translated">이니셜 라이저 목록의 모든 표현식은 스토리지 기간의 집계를 초기화 할 때 &lt;a href=&quot;constant_expression&quot;&gt;상수 표현식&lt;/a&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="8061fc72228b0f11d8e5fe2acd66cf7973c92c06" translate="yes" xml:space="preserve">
          <source>Every identifier other than macro name or macro parameter name has &lt;a href=&quot;scope&quot;&gt;scope&lt;/a&gt;, belongs to a &lt;a href=&quot;name_space&quot;&gt;name space&lt;/a&gt;, and may have &lt;a href=&quot;storage_duration&quot;&gt;linkage&lt;/a&gt;. The same identifier can denote different entities at different points in the program, or may denote different entities at the same point if the entities are in different name spaces.</source>
          <target state="translated">매크로 이름이나 매크로 매개 변수 이름이 아닌 다른 모든 식별자는이 &lt;a href=&quot;scope&quot;&gt;범위를&lt;/a&gt; 하는에 속하는 &lt;a href=&quot;name_space&quot;&gt;이름 공간&lt;/a&gt; , 그리고있을 수 있습니다 &lt;a href=&quot;storage_duration&quot;&gt;연결을&lt;/a&gt; . 동일한 식별자는 프로그램의 다른 지점에서 다른 엔티티를 나타내거나 엔티티가 다른 이름 공간에있는 경우 같은 지점에서 다른 엔티티를 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28bf02b780b942d327d4765f8dca30714c80b2c2" translate="yes" xml:space="preserve">
          <source>Every object has an</source>
          <target state="translated">모든 개체는</target>
        </trans-unit>
        <trans-unit id="2cb5903e11e24e79124c7b84f8abc476a4f4997a" translate="yes" xml:space="preserve">
          <source>Every object has.</source>
          <target state="translated">모든 물건이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0cae74747ce921ce4dc2761826efeaa22990fc6f" translate="yes" xml:space="preserve">
          <source>Exact</source>
          <target state="translated">Exact</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="0846421fa4d44dac1b26a7842a49c3943013e9ff" translate="yes" xml:space="preserve">
          <source>Except for &lt;a href=&quot;bit_field&quot;&gt;bit fields&lt;/a&gt;, objects are composed of contiguous sequences of one or more bytes, each consisting of &lt;code&gt;&lt;a href=&quot;../types/limits&quot;&gt;CHAR_BIT&lt;/a&gt;&lt;/code&gt; bits, and can be copied with &lt;code&gt;&lt;a href=&quot;../string/byte/memcpy&quot;&gt;memcpy&lt;/a&gt;&lt;/code&gt; into an object of type &lt;code&gt;unsigned char[n]&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the size of the object. The contents of the resulting array are known as</source>
          <target state="translated">&lt;a href=&quot;bit_field&quot;&gt;비트 필드를&lt;/a&gt; 제외하고 객체는 각각 &lt;code&gt;&lt;a href=&quot;../types/limits&quot;&gt;CHAR_BIT&lt;/a&gt;&lt;/code&gt; 비트로 구성된 하나 이상의 바이트의 연속 시퀀스로 구성 되며 &lt;code&gt;&lt;a href=&quot;../string/byte/memcpy&quot;&gt;memcpy&lt;/a&gt;&lt;/code&gt; 를 사용하여 &lt;code&gt;unsigned char[n]&lt;/code&gt; 유형의 객체에 복사 할 수 있습니다 . 여기서 &lt;code&gt;n&lt;/code&gt; 은 객체의 크기입니다. 결과 배열의 내용은</target>
        </trans-unit>
        <trans-unit id="a4c65a0cba6faa6401c55873ee72909d9d343ce9" translate="yes" xml:space="preserve">
          <source>Except if the type of expression is a &lt;a href=&quot;array&quot;&gt;VLA&lt;/a&gt;, (since C99)expression is not evaluated and the &lt;code&gt;sizeof&lt;/code&gt; operator may be used in an integer &lt;a href=&quot;constant_expression&quot;&gt;constant expression&lt;/a&gt;.</source>
          <target state="translated">표현식 유형이 &lt;a href=&quot;array&quot;&gt;VLA&lt;/a&gt; 인 경우를 제외하고 (C99 이후) 표현식은 평가되지 않으며 &lt;code&gt;sizeof&lt;/code&gt; 연산자는 정수 &lt;a href=&quot;constant_expression&quot;&gt;상수 표현식에&lt;/a&gt; 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c82c4955ac4c657fe3c1c1a33c42f14589789f17" translate="yes" xml:space="preserve">
          <source>Except the redundant parentheses around the identifier are meaningful in a type-name and represent &quot;function with no parameter specification&quot;:</source>
          <target state="translated">식별자 주위의 중복 괄호를 제외하고 type-name에서 의미가 있으며 &quot;매개 변수 지정이없는 함수&quot;를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c39d3a34e7546d37d567982f43f1e3ec730f1f22" translate="yes" xml:space="preserve">
          <source>Except within a &lt;a href=&quot;language/character_constant&quot;&gt;character constant&lt;/a&gt;, a &lt;a href=&quot;language/string_literal&quot;&gt;string literal&lt;/a&gt;, or a comment, the characters &lt;code&gt;/*&lt;/code&gt; introduce a comment. The contents of such a comment are examined only to identify multibyte characters and to find the characters &lt;code&gt;*/&lt;/code&gt; that terminate the comment. C-style comments cannot be nested.</source>
          <target state="translated">&lt;a href=&quot;language/character_constant&quot;&gt;문자 상수&lt;/a&gt; , &lt;a href=&quot;language/string_literal&quot;&gt;문자열 리터럴&lt;/a&gt; 또는 주석을 제외하고 &lt;code&gt;/*&lt;/code&gt; 문자 는 주석을 소개합니다. 이러한 주석의 내용은 멀티 바이트 문자를 식별 하고 주석을 종료하는 &lt;code&gt;*/&lt;/code&gt; 문자를 찾기 위해서만 검사됩니다 . C 스타일 주석은 중첩 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="bddc2538ec8959f0494f56c6df15dc6c8b6728c6" translate="yes" xml:space="preserve">
          <source>Except within a &lt;a href=&quot;language/character_constant&quot;&gt;character constant&lt;/a&gt;, a &lt;a href=&quot;language/string_literal&quot;&gt;string literal&lt;/a&gt;, or a comment, the characters &lt;code&gt;//&lt;/code&gt; introduce a comment that includes all multibyte characters up to, but not including, the next new-line character. The contents of such a comment are examined only to identify multibyte characters and to find the new-line character that terminates the comment. C++-style comments can be nested:</source>
          <target state="translated">&lt;a href=&quot;language/character_constant&quot;&gt;문자 상수&lt;/a&gt; , &lt;a href=&quot;language/string_literal&quot;&gt;문자열 리터럴&lt;/a&gt; 또는 주석을 제외하고 , 문자는 &lt;code&gt;//&lt;/code&gt; 다음 줄 바꾸기 문자까지는 포함하지 않고 모든 멀티 바이트 문자를 포함하는 주석을 소개합니다. 이러한 주석의 내용은 멀티 바이트 문자를 식별하고 주석을 종료하는 개행 문자를 찾기 위해서만 검사됩니다. C ++ 스타일 주석은 중첩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f8a730b7e50f87ea67dec5244562816a07b3aaa" translate="yes" xml:space="preserve">
          <source>Executes a loop.</source>
          <target state="translated">루프를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="2134926c41a5af01a113605847abc27742273c7e" translate="yes" xml:space="preserve">
          <source>Executes a statement repeatedly until the value of condition becomes false. The test takes place after each iteration.</source>
          <target state="translated">condition 값이 false가 될 때까지 명령문을 반복적으로 실행합니다. 테스트는 각 반복 후에 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="11f93f9b195c7cd21096794e98c03a7027da2f79" translate="yes" xml:space="preserve">
          <source>Executes a statement repeatedly, until the value of expression becomes equal to zero. The test takes place before each iteration.</source>
          <target state="translated">expression의 값이 0이 될 때까지 명령문을 반복적으로 실행합니다. 테스트는 각 반복 전에 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="85e7dec4537bfae2058cca4e9884515a8b83fb5b" translate="yes" xml:space="preserve">
          <source>Executes code according to the value of an integral argument.</source>
          <target state="translated">정수 인수의 값에 따라 코드를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="27cfa9eee3e7ceef3b1e500e47b1e1610a8c97f4" translate="yes" xml:space="preserve">
          <source>Executing the &lt;code&gt;return&lt;/code&gt; statement in a &lt;a href=&quot;_noreturn&quot;&gt;no-return function&lt;/a&gt; is undefined behavior.</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt; &lt;a href=&quot;_noreturn&quot;&gt;안함 함수&lt;/a&gt; 에서 return 문을 실행하는 것은 정의되지 않은 동작입니다.</target>
        </trans-unit>
        <trans-unit id="28c764ed1d6222630406c5783a2aaab97f66bd88" translate="yes" xml:space="preserve">
          <source>Expanded value</source>
          <target state="translated">확장 된 가치</target>
        </trans-unit>
        <trans-unit id="2c1bd25ffde3db50385bd1702ced6f7b127db28b" translate="yes" xml:space="preserve">
          <source>Expands to</source>
          <target state="translated">로 확장</target>
        </trans-unit>
        <trans-unit id="8faacdf8b7af79664977eafc89be9750aba9f6d1" translate="yes" xml:space="preserve">
          <source>Expands to &lt;a href=&quot;../language/constant_expression&quot;&gt;preprocessor constant expressions&lt;/a&gt; that evaluate to either &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt;, or &lt;code&gt;2&lt;/code&gt; which indicate the lock-free property of the corresponding &lt;a href=&quot;../atomic&quot;&gt;atomic types&lt;/a&gt; (both signed and unsigned).</source>
          <target state="translated">대응하는 &lt;a href=&quot;../atomic&quot;&gt;원자 유형&lt;/a&gt; (부호 및 부호 없음) 의 잠금없는 특성을 나타내는 &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;1&lt;/code&gt; 또는 &lt;code&gt;2&lt;/code&gt; 로 평가 되는 &lt;a href=&quot;../language/constant_expression&quot;&gt;전 처리기 상수 표현식으로&lt;/a&gt; 확장됩니다 .</target>
        </trans-unit>
        <trans-unit id="4945de103990c828d28d11116d17a1455abd773d" translate="yes" xml:space="preserve">
          <source>Expands to a positive integral &lt;a href=&quot;../language/constant_expression&quot;&gt;constant expression&lt;/a&gt; defining the maximum number of times a destructor for thread-local storage pointer will be called by &lt;code&gt;&lt;a href=&quot;thrd_exit&quot;&gt;thrd_exit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">스레드 로컬 스토리지 포인터에 대한 소멸자가 &lt;code&gt;&lt;a href=&quot;thrd_exit&quot;&gt;thrd_exit&lt;/a&gt;&lt;/code&gt; 에 의해 호출되는 최대 횟수를 정의 하는 양의 정수 &lt;a href=&quot;../language/constant_expression&quot;&gt;상수 표현식으로&lt;/a&gt; 확장됩니다 .</target>
        </trans-unit>
        <trans-unit id="6ac04c5b090acc87427f403a76810b032235784c" translate="yes" xml:space="preserve">
          <source>Expands to an expression (not necessarily a compile-time constant) of type &lt;code&gt;&lt;a href=&quot;clock_t&quot;&gt;clock_t&lt;/a&gt;&lt;/code&gt; equal to the number of clock ticks per second, as returned by &lt;code&gt;&lt;a href=&quot;clock&quot;&gt;clock()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;clock&quot;&gt;clock()&lt;/a&gt;&lt;/code&gt; 의해 리턴 된 초당 클럭 틱 수와 동일한 &lt;code&gt;&lt;a href=&quot;clock_t&quot;&gt;clock_t&lt;/a&gt;&lt;/code&gt; 유형의 표현식 (컴파일 타임 상수는 아님)으로 확장됩니다 .</target>
        </trans-unit>
        <trans-unit id="63f947b1d73753094d1ae7232094c3d68be133d1" translate="yes" xml:space="preserve">
          <source>Expands to an expression that can be used to initialize &lt;code&gt;&lt;a href=&quot;atomic_flag&quot;&gt;atomic_flag&lt;/a&gt;&lt;/code&gt; type. The value &lt;code&gt;atomic_flag&lt;/code&gt; that is not initialized using this macro is undefined.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;atomic_flag&quot;&gt;atomic_flag&lt;/a&gt;&lt;/code&gt; 유형 을 초기화하는 데 사용할 수있는 표현식으로 확장됩니다 . 이 매크로를 사용하여 초기화되지 않은 &lt;code&gt;atomic_flag&lt;/code&gt; 값 은 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6e54e6049cc9eea669bc3e5a4c9bc5a1dfc7508f" translate="yes" xml:space="preserve">
          <source>Expands to an expression that can be used to initialize an atomic variable of the same type as &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; 와 동일한 유형의 원자 변수를 초기화하는 데 사용할 수있는 표현식으로 확장 합니다 .</target>
        </trans-unit>
        <trans-unit id="8db16a62cd0eecafad46f2d6c4cb160336ba4375" translate="yes" xml:space="preserve">
          <source>Expands to an integer constant expression equal to the maximum value returned by the function &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt;. This value is implementation dependent. It's guaranteed that this value is at least &lt;code&gt;32767&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; 함수가 리턴 한 최대 값과 동일한 정수 상수 표현식으로 확장됩니다 . 이 값은 구현에 따라 다릅니다. 이 값이 &lt;code&gt;32767&lt;/code&gt; 이상임을 보증합니다 .</target>
        </trans-unit>
        <trans-unit id="b74a3f6f88cbf8779ab38cebe0c4e5a1aa35bcc5" translate="yes" xml:space="preserve">
          <source>Expands to positive &lt;code&gt;double&lt;/code&gt; expression that indicates overflow, not necessarily representable as a &lt;code&gt;float&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;float&lt;/code&gt; 로 나타낼 수있는 것은 아니지만 오버플로를 나타내는 양의 &lt;code&gt;double&lt;/code&gt; 표현식으로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="f5ccabdc1716ee0f1f6ba421bfe7a3cb18e19e27" translate="yes" xml:space="preserve">
          <source>Expands to positive &lt;code&gt;float&lt;/code&gt; expression that indicates overflow</source>
          <target state="translated">오버플로를 나타내는 양의 &lt;code&gt;float&lt;/code&gt; 식으로 확장</target>
        </trans-unit>
        <trans-unit id="1517f254032c8417e8afa57de1c3cc258d11f6c4" translate="yes" xml:space="preserve">
          <source>Expands to positive &lt;code&gt;long double&lt;/code&gt; expression that indicates overflow, not necessarily representable as a &lt;code&gt;float&lt;/code&gt; or &lt;code&gt;double&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;float&lt;/code&gt; 또는 &lt;code&gt;double&lt;/code&gt; 로 표현할 필요는없는 오버플로를 나타내는 양의 &lt;code&gt;long double&lt;/code&gt; 표현식으로 확장</target>
        </trans-unit>
        <trans-unit id="b32ef340ea4702fd5f41dbe4001671d76174ef71" translate="yes" xml:space="preserve">
          <source>Explanation</source>
          <target state="translated">Explanation</target>
        </trans-unit>
        <trans-unit id="9871eb9d9db410b188224356bf06656bc0125776" translate="yes" xml:space="preserve">
          <source>Explicit initialization</source>
          <target state="translated">명시 적 초기화</target>
        </trans-unit>
        <trans-unit id="dd8bfe3fdab8ac97b580b2a4aef0404f178b5ac1" translate="yes" xml:space="preserve">
          <source>Exponential functions</source>
          <target state="translated">지수 함수</target>
        </trans-unit>
        <trans-unit id="af1ce2aaa5c978ee528dbd127a42e4189e15865d" translate="yes" xml:space="preserve">
          <source>Expression evaluation may produce a result (e.g., evaluation of &lt;code&gt;2+2&lt;/code&gt; produces the result &lt;code&gt;4&lt;/code&gt;), may generate side-effects (e.g. evaluation of &lt;code&gt;&lt;a href=&quot;../io/fprintf&quot;&gt;printf&lt;/a&gt;(&quot;%d&quot;,4)&lt;/code&gt; sends the character &lt;code&gt;'4'&lt;/code&gt; to the standard output stream), and may designate objects or functions.</source>
          <target state="translated">식 평가는 결과를 생성 할 수 있으며 (예 : &lt;code&gt;2+2&lt;/code&gt; 의 평가 는 결과 &lt;code&gt;4&lt;/code&gt; 를 생성 함) 부작용을 생성 할 수 있습니다 (예 : &lt;code&gt;&lt;a href=&quot;../io/fprintf&quot;&gt;printf&lt;/a&gt;(&quot;%d&quot;,4)&lt;/code&gt; 평가 ( &quot;% d&quot;, 4) 는 문자 &lt;code&gt;'4'&lt;/code&gt; 를 표준 출력 스트림에 보냅니다 ) 객체 또는 기능을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a7a6ba0d7d2af3106edf9d912c2fc5a47512f54" translate="yes" xml:space="preserve">
          <source>Expression statements</source>
          <target state="translated">표현 문</target>
        </trans-unit>
        <trans-unit id="ae5fccd8dcd8fc317f8edfc8259af86cd2967a29" translate="yes" xml:space="preserve">
          <source>Expressions</source>
          <target state="translated">Expressions</target>
        </trans-unit>
        <trans-unit id="f353e8f82ea2aa488317fc7d8263ec638f8988ee" translate="yes" xml:space="preserve">
          <source>Expressions that are used in the &lt;a href=&quot;initialization&quot;&gt;initializers&lt;/a&gt; of objects with static and thread_local &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt; must be expressions that may be one of the following.</source>
          <target state="translated">정적 및 thread_local &lt;a href=&quot;storage_duration&quot;&gt;저장 기간을&lt;/a&gt; 갖는 객체 의 &lt;a href=&quot;initialization&quot;&gt;이니셜 라이저&lt;/a&gt; 에서 사용되는 표현식은 다음 중 하나 일 수있는 표현식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="73a249c29d63b610061072ac728997168ac1fe92" translate="yes" xml:space="preserve">
          <source>Extended multibyte and wide character utilities</source>
          <target state="translated">확장 멀티 바이트 및 와이드 문자 유틸리티</target>
        </trans-unit>
        <trans-unit id="29449f104db7b7f4060421a59f2c8652fcaf7414" translate="yes" xml:space="preserve">
          <source>External and tentative definitions</source>
          <target state="translated">외부 및 임시 정의</target>
        </trans-unit>
        <trans-unit id="f92e601eb8d663033dca3851ad6f1616d1966aa7" translate="yes" xml:space="preserve">
          <source>External links</source>
          <target state="translated">외부 링크</target>
        </trans-unit>
        <trans-unit id="77c407388266a4e5e937fe92a0ce467e4d5cf334" translate="yes" xml:space="preserve">
          <source>F.10.1.1 The acos functions (p: 518)</source>
          <target state="translated">F.10.1.1 acos 기능 (p : 518)</target>
        </trans-unit>
        <trans-unit id="cad3287a73936ba75ca64c1f05a0a540c8022d26" translate="yes" xml:space="preserve">
          <source>F.10.1.2 The asin functions (p: 518)</source>
          <target state="translated">F.10.1.2 asin 기능 (p : 518)</target>
        </trans-unit>
        <trans-unit id="9ef85f92ec5474ff35787d85c82c58bf7b470d4a" translate="yes" xml:space="preserve">
          <source>F.10.1.3 The atan functions (p: 519)</source>
          <target state="translated">F.10.1.3 아탄 기능 (p : 519)</target>
        </trans-unit>
        <trans-unit id="61654a10c29f6924e433f111ed48191ac88a2ce3" translate="yes" xml:space="preserve">
          <source>F.10.1.4 The atan2 functions (p: 519)</source>
          <target state="translated">F.10.1.4 atan2 기능 (p : 519)</target>
        </trans-unit>
        <trans-unit id="6b87bded088091f390f6ffad328a772e7e512e59" translate="yes" xml:space="preserve">
          <source>F.10.1.5 The cos functions (p: 519)</source>
          <target state="translated">F.10.1.5 cos 함수 (p : 519)</target>
        </trans-unit>
        <trans-unit id="d91aaea4c9d5123a333ed526b7019e6fe8161791" translate="yes" xml:space="preserve">
          <source>F.10.1.6 The sin functions (p: 519)</source>
          <target state="translated">F.10.1.6 죄 기능 (p : 519)</target>
        </trans-unit>
        <trans-unit id="037480d4008aac1c2ced1847c0d6506eaff99f02" translate="yes" xml:space="preserve">
          <source>F.10.1.7 The tan functions (p: 519)</source>
          <target state="translated">F.10.1.7 탄 기능 (p : 519)</target>
        </trans-unit>
        <trans-unit id="39ece3e4b919950cc9aef1f79b7ea2b485b2f749" translate="yes" xml:space="preserve">
          <source>F.10.10.1 The fma functions (p: 530)</source>
          <target state="translated">F.10.10.1 fma 기능 (p : 530)</target>
        </trans-unit>
        <trans-unit id="d4f406e24acff82500d3f53854f757aefe80a88b" translate="yes" xml:space="preserve">
          <source>F.10.11 Comparison macros (p: 531)</source>
          <target state="translated">F.10.11 비교 매크로 (p : 531)</target>
        </trans-unit>
        <trans-unit id="9b3f0ad6a5d5f3bdc88332446b21be594cf5b850" translate="yes" xml:space="preserve">
          <source>F.10.2.1 The acosh functions (p: 520)</source>
          <target state="translated">F.10.2.1 acosh 기능 (p : 520)</target>
        </trans-unit>
        <trans-unit id="e8a5915d0ff8e75d37c89114700efa34fcb3655c" translate="yes" xml:space="preserve">
          <source>F.10.2.2 The asinh functions (p: 520)</source>
          <target state="translated">F.10.2.2 asinh 함수 (p : 520)</target>
        </trans-unit>
        <trans-unit id="38d01d22054b31ca110c70ecab03b46da04ddbde" translate="yes" xml:space="preserve">
          <source>F.10.2.3 The atanh functions (p: 520)</source>
          <target state="translated">F.10.2.3 아탄 기능 (p : 520)</target>
        </trans-unit>
        <trans-unit id="6d1dcd9f7c26773cd7824edef93f2bc153fcedd1" translate="yes" xml:space="preserve">
          <source>F.10.2.4 The cosh functions (p: 520)</source>
          <target state="translated">F.10.2.4 코쉬 기능 (p : 520)</target>
        </trans-unit>
        <trans-unit id="958c262e658f94cec62537f399da067e4b2a3687" translate="yes" xml:space="preserve">
          <source>F.10.2.5 The sinh functions (p: 520)</source>
          <target state="translated">F.10.2.5 sinh 기능 (p : 520)</target>
        </trans-unit>
        <trans-unit id="89846dc268c67d448208698d5fb48751a4fa3ee7" translate="yes" xml:space="preserve">
          <source>F.10.2.6 The tanh functions (p: 520)</source>
          <target state="translated">F.10.2.6 탄 기능 (p : 520)</target>
        </trans-unit>
        <trans-unit id="087ba78251d8a6578f4172770ba9fb671bdc2930" translate="yes" xml:space="preserve">
          <source>F.10.3.1 The exp functions (p: 520)</source>
          <target state="translated">F.10.3.1 exp 함수 (p : 520)</target>
        </trans-unit>
        <trans-unit id="d2f1b4b78961c78fd097a3f2e3d5c95ac97b0697" translate="yes" xml:space="preserve">
          <source>F.10.3.10 The log2 functions (p: 522)</source>
          <target state="translated">F.10.3.10 log2 기능 (p : 522)</target>
        </trans-unit>
        <trans-unit id="794d0f6de81eceae99a02eae8075568628225b13" translate="yes" xml:space="preserve">
          <source>F.10.3.11 The logb functions (p: 522)</source>
          <target state="translated">F.10.3.11 로그 기능 (p : 522)</target>
        </trans-unit>
        <trans-unit id="359790e2c483d46f6d5fa87180647464c9ffd494" translate="yes" xml:space="preserve">
          <source>F.10.3.12 The modf functions (p: 523)</source>
          <target state="translated">F.10.3.12 modf 기능 (p : 523)</target>
        </trans-unit>
        <trans-unit id="26231b94cbb9b4ccc5abf2b75e7483700a200573" translate="yes" xml:space="preserve">
          <source>F.10.3.13 The scalbn functions (p: 523)</source>
          <target state="translated">F.10.3.13 scalbn 함수 (p : 523)</target>
        </trans-unit>
        <trans-unit id="c4c4e3a6535940d3ad6a58b578ff6b3f648cea5c" translate="yes" xml:space="preserve">
          <source>F.10.3.2 The exp2 functions (p: 521)</source>
          <target state="translated">F.10.3.2 exp2 기능 (p : 521)</target>
        </trans-unit>
        <trans-unit id="2ea743c028232e6944fba4cc2a23ead42a73967b" translate="yes" xml:space="preserve">
          <source>F.10.3.3 The expm1 functions (p: 521)</source>
          <target state="translated">F.10.3.3 expm1 기능 (p : 521)</target>
        </trans-unit>
        <trans-unit id="8b40b0a0ad12eacc6381e986766eb2e5616397d0" translate="yes" xml:space="preserve">
          <source>F.10.3.4 The frexp functions (p: 521)</source>
          <target state="translated">F.10.3.4 frexp 기능 (p : 521)</target>
        </trans-unit>
        <trans-unit id="a0911a9469e43f63891c8efa1bec7f36ad8c8abc" translate="yes" xml:space="preserve">
          <source>F.10.3.5 The ilogb functions (p: 521)</source>
          <target state="translated">F.10.3.5 ilogb 기능 (p : 521)</target>
        </trans-unit>
        <trans-unit id="75a2fa7eb5b40194e1e37e5ef123f250b756926a" translate="yes" xml:space="preserve">
          <source>F.10.3.6 The ldexp functions (p: 522)</source>
          <target state="translated">F.10.3.6 ldexp 기능 (p : 522)</target>
        </trans-unit>
        <trans-unit id="6f56427ef5bda97f9bd0f1abdca0f2d6c6ff57e8" translate="yes" xml:space="preserve">
          <source>F.10.3.7 The log functions (p: 522)</source>
          <target state="translated">F.10.3.7 로그 기능 (p : 522)</target>
        </trans-unit>
        <trans-unit id="f594a7472fd58a9aac605b75beccc17bd59b8dd5" translate="yes" xml:space="preserve">
          <source>F.10.3.8 The log10 functions (p: 522)</source>
          <target state="translated">F.10.3.8 log10 기능 (p : 522)</target>
        </trans-unit>
        <trans-unit id="a48a20da2597afea4f32bc8128a961f30186bb43" translate="yes" xml:space="preserve">
          <source>F.10.3.9 The log1p functions (p: 522)</source>
          <target state="translated">F.10.3.9 log1p 기능 (p : 522)</target>
        </trans-unit>
        <trans-unit id="7e9241bf052c178aa5d7679b82aa2fb1f5f3429f" translate="yes" xml:space="preserve">
          <source>F.10.4.1 The cbrt functions (p: 524)</source>
          <target state="translated">F.10.4.1 cbrt 기능 (p : 524)</target>
        </trans-unit>
        <trans-unit id="17febc2a8e0db50799bb968259ec83e250637ecf" translate="yes" xml:space="preserve">
          <source>F.10.4.3 The hypot functions (p: 524)</source>
          <target state="translated">F.10.4.3 hypot 함수 (p : 524)</target>
        </trans-unit>
        <trans-unit id="625f08597fe348094478d4ebb805e20b1dc18589" translate="yes" xml:space="preserve">
          <source>F.10.4.4 The pow functions (p: 524-525)</source>
          <target state="translated">F.10.4.4 pow 기능 (p : 524-525)</target>
        </trans-unit>
        <trans-unit id="25725da8bd22d2591488c89637aeec539180512b" translate="yes" xml:space="preserve">
          <source>F.10.4.5 The sqrt functions (p: 525)</source>
          <target state="translated">F.10.4.5 sqrt 함수 (p : 525)</target>
        </trans-unit>
        <trans-unit id="16f4c89fcc73a73762071c025286f4c826a965e3" translate="yes" xml:space="preserve">
          <source>F.10.5.1 The erf functions (p: 525)</source>
          <target state="translated">F.10.5.1 erf 기능 (p : 525)</target>
        </trans-unit>
        <trans-unit id="206fe7eceb3eeb950c8c0e350ab59cd90863fff1" translate="yes" xml:space="preserve">
          <source>F.10.5.2 The erfc functions (p: 525)</source>
          <target state="translated">F.10.5.2 erfc 함수 (p : 525)</target>
        </trans-unit>
        <trans-unit id="6d9ef222b026d1552a6e019e7cec89f1462b487f" translate="yes" xml:space="preserve">
          <source>F.10.5.3 The lgamma functions (p: 525)</source>
          <target state="translated">F.10.5.3 lgamma 함수 (p : 525)</target>
        </trans-unit>
        <trans-unit id="f246fcb4689fd18925ec623bbfcc71a41b0465c4" translate="yes" xml:space="preserve">
          <source>F.10.5.4 The tgamma functions (p: 525)</source>
          <target state="translated">F.10.5.4 감마 함수 (p : 525)</target>
        </trans-unit>
        <trans-unit id="cb2de2da7dae0b99044effe02f5a47bdaadc48af" translate="yes" xml:space="preserve">
          <source>F.10.6.1 The ceil functions (p: 526)</source>
          <target state="translated">F.10.6.1 ceil 기능 (p : 526)</target>
        </trans-unit>
        <trans-unit id="1b33b3f7cf068beaaa2da5d9ab8c39148105a3cc" translate="yes" xml:space="preserve">
          <source>F.10.6.2 The floor functions (p: 526)</source>
          <target state="translated">F.10.6.2 바닥 기능 (p : 526)</target>
        </trans-unit>
        <trans-unit id="f6ebb7d3b865f6734b8512e6179d7dfe39d6858d" translate="yes" xml:space="preserve">
          <source>F.10.6.3 The nearbyint functions (p: 526)</source>
          <target state="translated">F.10.6.3 nearint 기능 (p : 526)</target>
        </trans-unit>
        <trans-unit id="a84cc296df6994a9fdc52ad5813543f24f3c6cd9" translate="yes" xml:space="preserve">
          <source>F.10.6.4 The rint functions (p: 527)</source>
          <target state="translated">F.10.6.4 린트 기능 (p : 527)</target>
        </trans-unit>
        <trans-unit id="bbda21a32e5ae8a6c9aee9e4c77675635cf84fd8" translate="yes" xml:space="preserve">
          <source>F.10.6.5 The lrint and llrint functions (p: 527)</source>
          <target state="translated">F.10.6.5 lrint 및 llrint 기능 (p : 527)</target>
        </trans-unit>
        <trans-unit id="ec0b999019838cb54ccf2817d9714997b4e40445" translate="yes" xml:space="preserve">
          <source>F.10.6.6 The round functions (p: 527)</source>
          <target state="translated">F.10.6.6 반올림 함수 (p : 527)</target>
        </trans-unit>
        <trans-unit id="cb4356e2e5fad9450ac5558563f98452412688f4" translate="yes" xml:space="preserve">
          <source>F.10.6.7 The lround and llround functions (p: 528)</source>
          <target state="translated">F.10.6.7 lround 및 llround 함수 (p : 528)</target>
        </trans-unit>
        <trans-unit id="01904666c0e217576f27c19883b11b927df7f8fa" translate="yes" xml:space="preserve">
          <source>F.10.6.8 The trunc functions (p: 528)</source>
          <target state="translated">F.10.6.8 잘림 기능 (p : 528)</target>
        </trans-unit>
        <trans-unit id="1c86765d3b2ed0d1a6859351ba51e178fa90edb1" translate="yes" xml:space="preserve">
          <source>F.10.7.1 The fmod functions (p: 528)</source>
          <target state="translated">F.10.7.1 fmod 기능 (p : 528)</target>
        </trans-unit>
        <trans-unit id="8b9ef85d99a342671dcbe04d0342fa3a3e7392f4" translate="yes" xml:space="preserve">
          <source>F.10.7.2 The remainder functions (p: 529)</source>
          <target state="translated">F.10.7.2 나머지 기능들 (p : 529)</target>
        </trans-unit>
        <trans-unit id="ce8ff4da2761f2d7b47d2ff2b92c122baa53063b" translate="yes" xml:space="preserve">
          <source>F.10.7.3 The remquo functions (p: 529)</source>
          <target state="translated">F.10.7.3 원격 기능 (p : 529)</target>
        </trans-unit>
        <trans-unit id="dc2ed702cd3c1689dcef0d15c6b317b413615b93" translate="yes" xml:space="preserve">
          <source>F.10.8.1 The copysign functions (p: 529)</source>
          <target state="translated">F.10.8.1 복사 부호 기능 (p : 529)</target>
        </trans-unit>
        <trans-unit id="26f00db7b895801e69e888537ca6f5e8e8b77760" translate="yes" xml:space="preserve">
          <source>F.10.8.3 The nextafter functions (p: 529)</source>
          <target state="translated">F.10.8.3 다음 기능 (p : 529)</target>
        </trans-unit>
        <trans-unit id="2bd999c6b7635b98e319b1879c7049aacf6a11d7" translate="yes" xml:space="preserve">
          <source>F.10.8.4 The nexttoward functions (p: 529)</source>
          <target state="translated">F.10.8.4 다음 기능 (p : 529)</target>
        </trans-unit>
        <trans-unit id="0558fce2fc34a89230abb55717a1367a84816fb5" translate="yes" xml:space="preserve">
          <source>F.10.9.1 The fdim functions (p: 530)</source>
          <target state="translated">F.10.9.1 fdim 기능 (p : 530)</target>
        </trans-unit>
        <trans-unit id="de085a98998c76d2bcfef17bda25b20084cc5503" translate="yes" xml:space="preserve">
          <source>F.10.9.2 The fmax functions (p: 530)</source>
          <target state="translated">F.10.9.2 fmax 기능 (p : 530)</target>
        </trans-unit>
        <trans-unit id="9827db1f0b98a7b434030aa176982366a942c2df" translate="yes" xml:space="preserve">
          <source>F.10.9.3 The fmin functions (p: 530)</source>
          <target state="translated">F.10.9.3 fmin 기능 (p : 530)</target>
        </trans-unit>
        <trans-unit id="283438cc0f8a76e650782eb735336732fb8b236a" translate="yes" xml:space="preserve">
          <source>F.10/11/13 NAN (p: 518)</source>
          <target state="translated">F.10 / 11 / 13 NAN (p : 518)</target>
        </trans-unit>
        <trans-unit id="1be467d83b43dca68a5e634b5535ba14ab6b74a8" translate="yes" xml:space="preserve">
          <source>F.10/2 HUGE_VAL, HUGE_VALF, HUGE_VALL (p: 517)</source>
          <target state="translated">F.10 / 2 HUGE_VAL, HUGE_VALF, HUGE_VALL (p : 517)</target>
        </trans-unit>
        <trans-unit id="28cf2cca0ce08a9451ab3c5d8742e0e21020ea37" translate="yes" xml:space="preserve">
          <source>F.10/4 MATH_ERREXCEPT, math_errhandling (p: 517)</source>
          <target state="translated">F.10 / 4 MATH_ERREXCEPT, math_errhandling (p : 517)</target>
        </trans-unit>
        <trans-unit id="603370297957bfb90d8d437aad808f55b97ea754" translate="yes" xml:space="preserve">
          <source>F.9.1.1 The acos functions (p: 455)</source>
          <target state="translated">F.9.1.1 acos 기능 (p : 455)</target>
        </trans-unit>
        <trans-unit id="b0809cf0780a08bb1111998f12d6c4d23aeb9e53" translate="yes" xml:space="preserve">
          <source>F.9.1.2 The asin functions (p: 456)</source>
          <target state="translated">F.9.1.2 asin 기능 (p : 456)</target>
        </trans-unit>
        <trans-unit id="a551d81f71a5f9939ce28f69ef0a1e3ca5957298" translate="yes" xml:space="preserve">
          <source>F.9.1.3 The atan functions (p: 456)</source>
          <target state="translated">F.9.1.3 아탄 기능 (p : 456)</target>
        </trans-unit>
        <trans-unit id="5238a56c052eff99e24c4b6896aa6038f4f427e0" translate="yes" xml:space="preserve">
          <source>F.9.1.4 The atan2 functions (p: 456)</source>
          <target state="translated">F.9.1.4 atan2 기능 (p : 456)</target>
        </trans-unit>
        <trans-unit id="50d63741a36f7483fb2868bf6f151a6b40fd8286" translate="yes" xml:space="preserve">
          <source>F.9.1.5 The cos functions (p: 456)</source>
          <target state="translated">F.9.1.5 cos 함수 (p : 456)</target>
        </trans-unit>
        <trans-unit id="637d47c6b863cea5d6635ae1deb6280868ac9ca7" translate="yes" xml:space="preserve">
          <source>F.9.1.6 The sin functions (p: 456)</source>
          <target state="translated">F.9.1.6 죄 기능 (p : 456)</target>
        </trans-unit>
        <trans-unit id="861f518e82a65029e3454ffded115bac6bb7868b" translate="yes" xml:space="preserve">
          <source>F.9.1.7 The tan functions (p: 457)</source>
          <target state="translated">F.9.1.7 tan 기능 (p : 457)</target>
        </trans-unit>
        <trans-unit id="34bd0de5e368ca614c44962d98536185314635dd" translate="yes" xml:space="preserve">
          <source>F.9.10.1 The fma functions (p: 466)</source>
          <target state="translated">F.9.10.1 fma 기능 (p : 466)</target>
        </trans-unit>
        <trans-unit id="f13a5ba17e8846600a005f346f831f5817808357" translate="yes" xml:space="preserve">
          <source>F.9.2.1 The acosh functions (p: 457)</source>
          <target state="translated">F.9.2.1 acosh 기능 (p : 457)</target>
        </trans-unit>
        <trans-unit id="1b6f759c08ea790315523a28fc714222e7c34567" translate="yes" xml:space="preserve">
          <source>F.9.2.2 The asinh functions (p: 457)</source>
          <target state="translated">F.9.2.2 asinh 함수 (p : 457)</target>
        </trans-unit>
        <trans-unit id="4b776e7f758a71948a8453b4b483c8754328eb1c" translate="yes" xml:space="preserve">
          <source>F.9.2.3 The atanh functions (p: 457)</source>
          <target state="translated">F.9.2.3 아탄 기능 (p : 457)</target>
        </trans-unit>
        <trans-unit id="6f5e1e5c0e484db0cde4b49868660cf187a8d29a" translate="yes" xml:space="preserve">
          <source>F.9.2.4 The cosh functions (p: 457)</source>
          <target state="translated">F.9.2.4 cosh 기능 (p : 457)</target>
        </trans-unit>
        <trans-unit id="56312c5c16e0e6e01fd49d38e774bc27c65e72b5" translate="yes" xml:space="preserve">
          <source>F.9.2.5 The sinh functions (p: 457)</source>
          <target state="translated">F.9.2.5 sinh 기능 (p : 457)</target>
        </trans-unit>
        <trans-unit id="cb1c2ccbe39e702fed325ed172fd0cff4dbb043c" translate="yes" xml:space="preserve">
          <source>F.9.2.6 The tanh functions (p: 457)</source>
          <target state="translated">F.9.2.6 탄 기능 (p : 457)</target>
        </trans-unit>
        <trans-unit id="e645ed3f9b116cd9c05fd565a57b8ab2fc11dfa7" translate="yes" xml:space="preserve">
          <source>F.9.3.1 The exp functions (p: 458)</source>
          <target state="translated">F.9.3.1 exp 함수 (p : 458)</target>
        </trans-unit>
        <trans-unit id="adefde4f7eb6e1e3299903930c6f911c23307960" translate="yes" xml:space="preserve">
          <source>F.9.3.10 The log2 functions (p: 459)</source>
          <target state="translated">F.9.3.10 log2 기능 (p : 459)</target>
        </trans-unit>
        <trans-unit id="e7fc20f76d9f84afe8f473215f95a262986b2742" translate="yes" xml:space="preserve">
          <source>F.9.3.11 The logb functions (p: 459)</source>
          <target state="translated">F.9.3.11 로그 기능 (p : 459)</target>
        </trans-unit>
        <trans-unit id="80e34eb7bbcfaf7246bc2bd46cf60a81f73e8751" translate="yes" xml:space="preserve">
          <source>F.9.3.12 The modf functions (p: 460)</source>
          <target state="translated">F.9.3.12 modf 기능 (p : 460)</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
