<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="elisp">
    <body>
      <group id="elisp">
        <trans-unit id="23f6b5abc1ef17571fdf5c06f953e5d8690ca2f7" translate="yes" xml:space="preserve">
          <source>Each property has a name and a value. Both of these can be any Lisp object, but the name is normally a symbol. Typically each property name symbol is used for a particular purpose; for instance, the text property &lt;code&gt;face&lt;/code&gt; specifies the faces for displaying the character (see &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Special Properties&lt;/a&gt;). The usual way to access the property list is to specify a name and ask what value corresponds to it.</source>
          <target state="translated">각 속성에는 이름과 값이 있습니다. 둘 다 Lisp 객체가 될 수 있지만 이름은 일반적으로 기호입니다. 일반적으로 각 속성 이름 기호는 특정 용도로 사용됩니다. 예를 들어, text 속성 &lt;code&gt;face&lt;/code&gt; 는 문자를 표시하기위한 면을 지정합니다 ( &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Special Properties&lt;/a&gt; 참조 ). 속성 목록에 액세스하는 일반적인 방법은 이름을 지정하고 그에 해당하는 값을 묻는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1c1fea8ac4dca56f1c610d54d8aaf271e1962df6" translate="yes" xml:space="preserve">
          <source>Each signal has a standard effect on the subprocess. Most signals kill the subprocess, but some stop (or resume) execution instead. Most signals can optionally be handled by programs; if the program handles the signal, then we can say nothing in general about its effects.</source>
          <target state="translated">각 신호에는 하위 프로세스에 대한 표준 효과가 있습니다. 대부분의 신호는 하위 프로세스를 종료하지만 일부는 대신 실행을 중지 (또는 재개)합니다. 대부분의 신호는 프로그램에서 선택적으로 처리 할 수 ​​있습니다. 프로그램이 신호를 처리하면 그 효과에 대해 일반적으로 말할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c047bfaf3c4495ab37b9bd7458af73d1c3930d11" translate="yes" xml:space="preserve">
          <source>Each special form has its own rules for which arguments are evaluated and which are used without evaluation. Whether a particular argument is evaluated may depend on the results of evaluating other arguments.</source>
          <target state="translated">각 특수 형식에는 인수가 평가되고 평가없이 사용되는 자체 규칙이 있습니다. 특정 인수가 평가되는지 여부는 다른 인수를 평가 한 결과에 따라 달라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72dd71100c38a66ebf0fcfa852239a90749b52f5" translate="yes" xml:space="preserve">
          <source>Each specification in &lt;var&gt;specs&lt;/var&gt; is a property list with contents depending on image type. All specifications must at least contain the properties &lt;code&gt;:type &lt;var&gt;type&lt;/var&gt;&lt;/code&gt; and either &lt;code&gt;:file&amp;nbsp;&lt;var&gt;file&lt;/var&gt;&lt;/code&gt; or &lt;code&gt;:data&amp;nbsp;&lt;var&gt;data&lt;/var&gt;&lt;/code&gt;, where &lt;var&gt;type&lt;/var&gt; is a symbol specifying the image type, e.g., &lt;code&gt;xbm&lt;/code&gt;, &lt;var&gt;file&lt;/var&gt; is the file to load the image from, and &lt;var&gt;data&lt;/var&gt; is a string containing the actual image data. The first specification in the list whose &lt;var&gt;type&lt;/var&gt; is supported, and &lt;var&gt;file&lt;/var&gt; exists, is used to construct the image specification to be returned. If no specification is satisfied, &lt;code&gt;nil&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;var&gt;specs&lt;/var&gt; 각 사양 은 이미지 유형에 따라 내용이 포함 된 속성 목록입니다. 모든 스펙은 최소한 &lt;code&gt;:type &lt;var&gt;type&lt;/var&gt;&lt;/code&gt; 속성 과 &lt;code&gt;:file&amp;nbsp;&lt;var&gt;file&lt;/var&gt;&lt;/code&gt; 또는 &lt;code&gt;:data&amp;nbsp;&lt;var&gt;data&lt;/var&gt;&lt;/code&gt; 포함해야합니다 .&amp;nbsp; 여기서 &lt;var&gt;type&lt;/var&gt; 은 이미지 유형을 지정하는 기호입니다 (예 : &lt;code&gt;xbm&lt;/code&gt; , &lt;var&gt;file&lt;/var&gt; 은 이미지를로드 할 파일, &lt;var&gt;data&lt;/var&gt; 는 문자열) 실제 이미지 데이터를 포함합니다. &lt;var&gt;type&lt;/var&gt; 이 지원되고 &lt;var&gt;file&lt;/var&gt; 이 있는 목록의 첫 번째 사양은 반환 할 이미지 사양을 구성하는 데 사용됩니다. 사양이 충족되지 않으면 &lt;code&gt;nil&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="dbf7a48962876ca66372154f2f1def78d7d85188" translate="yes" xml:space="preserve">
          <source>Each symbol has a property list for recording miscellaneous information.</source>
          <target state="translated">각 기호에는 기타 정보를 기록하기위한 속성 목록이 있습니다.</target>
        </trans-unit>
        <trans-unit id="52fbede7ba5a23a939caafe5e9932ca45c34d031" translate="yes" xml:space="preserve">
          <source>Each symbol has four components (or &amp;ldquo;cells&amp;rdquo;), each of which references another object:</source>
          <target state="translated">각 심볼에는 4 개의 구성 요소 (또는 &quot;셀&quot;)가 있으며 각 구성 요소는 다른 객체를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="be67417f8b53a64af086e681886ca9f4c3c8fb8d" translate="yes" xml:space="preserve">
          <source>Each symbol&amp;rsquo;s properties and property values are stored in the symbol&amp;rsquo;s property list cell (see &lt;a href=&quot;symbol-components#Symbol-Components&quot;&gt;Symbol Components&lt;/a&gt;), in the form of a property list (see &lt;a href=&quot;property-lists#Property-Lists&quot;&gt;Property Lists&lt;/a&gt;).</source>
          <target state="translated">각 심볼의 속성과 속성 값은 심볼의 속성 목록 세포 (참조에 저장되어있는 &lt;a href=&quot;symbol-components#Symbol-Components&quot;&gt;기호 구성 요소&lt;/a&gt; ), 프로퍼티리스트의 형태로 (참조 &lt;a href=&quot;property-lists#Property-Lists&quot;&gt;속성 목록을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="82a1accf94b0791d1a997333410db664204fd93c" translate="yes" xml:space="preserve">
          <source>Each syntax class is designated by a mnemonic character, which serves as the name of the class when you need to specify a class. Usually, this designator character is one that is often assigned that class; however, its meaning as a designator is unvarying and independent of what syntax that character currently has. Thus, &amp;lsquo;</source>
          <target state="translated">각 구문 클래스는 니모닉 문자로 지정되며 클래스를 지정해야 할 때 클래스 이름으로 사용됩니다. 일반적으로이 지정 문자는 종종 해당 클래스에 지정되는 문자입니다. 그러나 지정자로서의 의미는 해당 문자가 현재 가지고있는 구문과 무관하고 독립적입니다. 따라서 '</target>
        </trans-unit>
        <trans-unit id="20c83e6b7e66f23e9b34223f18b5c3c8faeecf1b" translate="yes" xml:space="preserve">
          <source>Each terminal has a list of associated parameters. These &lt;em&gt;terminal parameters&lt;/em&gt; are mostly a convenient way of storage for terminal-local variables, but some terminal parameters have a special meaning.</source>
          <target state="translated">각 터미널에는 연관된 매개 변수 목록이 있습니다. 이러한 &lt;em&gt;터미널 매개 변수&lt;/em&gt; 는 대부분 터미널 로컬 변수를 저장하는 편리한 방법이지만 일부 터미널 매개 변수에는 특별한 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a95c9cc702f0dae817aad9ce2f5bcddea359025" translate="yes" xml:space="preserve">
          <source>Each terminal type can have its own Lisp library that Emacs loads when run on that type of terminal. The library&amp;rsquo;s name is constructed by concatenating the value of the variable &lt;code&gt;term-file-prefix&lt;/code&gt; and the terminal type (specified by the environment variable &lt;code&gt;TERM&lt;/code&gt;). Normally, &lt;code&gt;term-file-prefix&lt;/code&gt; has the value &lt;code&gt;&quot;term/&quot;&lt;/code&gt;; changing this is not recommended. If there is an entry matching &lt;code&gt;TERM&lt;/code&gt; in the &lt;code&gt;term-file-aliases&lt;/code&gt; association list, Emacs uses the associated value in place of &lt;code&gt;TERM&lt;/code&gt;. Emacs finds the file in the normal manner, by searching the &lt;code&gt;load-path&lt;/code&gt; directories, and trying the &amp;lsquo;</source>
          <target state="translated">각 터미널 유형은 해당 유형의 터미널에서 실행될 때 Emacs가로드하는 자체 Lisp 라이브러리를 가질 수 있습니다. 라이브러리의 이름은 변수 &lt;code&gt;term-file-prefix&lt;/code&gt; 의 값 과 터미널 유형 (환경 변수 &lt;code&gt;TERM&lt;/code&gt; 으로 지정됨)을 연결하여 구성됩니다 . 일반적으로 &lt;code&gt;term-file-prefix&lt;/code&gt; 는 &lt;code&gt;&quot;term/&quot;&lt;/code&gt; 값을 갖습니다 . 이를 변경하지 않는 것이 좋습니다. &lt;code&gt;term-file-aliases&lt;/code&gt; 연관 목록에 &lt;code&gt;TERM&lt;/code&gt; 과 일치하는 항목이있는 경우 Emacs는 &lt;code&gt;TERM&lt;/code&gt; 대신 연관된 값을 사용합니다 . Emacs는 &lt;code&gt;load-path&lt;/code&gt; 디렉토리 를 검색 하고 '</target>
        </trans-unit>
        <trans-unit id="abf9852196e45b8ddf01ffeb0a06d4b366da14b5" translate="yes" xml:space="preserve">
          <source>Each time a generic function is called, it builds the &lt;em&gt;effective method&lt;/em&gt; which will handle this invocation by combining the applicable methods defined for the function. The process of finding the applicable methods and producing the effective method is called &lt;em&gt;dispatch&lt;/em&gt;. The applicable methods are those all of whose specializers are compatible with the actual arguments of the call. Since all of the arguments must be compatible with the specializers, they all determine whether a method is applicable. Methods that explicitly specialize more than one argument are called &lt;em&gt;multiple-dispatch methods&lt;/em&gt;.</source>
          <target state="translated">제네릭 함수가 호출 될 때마다 함수에 대해 정의 된 적용 가능한 메소드를 결합하여이 호출을 처리 할 &lt;em&gt;효과적인 메소드&lt;/em&gt; 를 빌드합니다 . 적용 가능한 방법을 찾고 효과적인 방법을 만드는 과정을 &lt;em&gt;디스패치&lt;/em&gt; 라고 합니다. 적용 가능한 메서드는 전문화자가 호출의 실제 인수와 호환되는 모든 메서드입니다. 모든 인수는 전문 화자와 호환되어야하므로 모두 메서드가 적용 가능한지 여부를 결정합니다. 둘 이상의 인수를 명시 적으로 전문화하는 메서드를 &lt;em&gt;다중 디스패치 메서드&lt;/em&gt; 라고 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="47a0fbac78b3eea53dfbeb6288c7d952fd355c24" translate="yes" xml:space="preserve">
          <source>Each time a question is asked, the user may enter</source>
          <target state="translated">질문을 할 때마다 사용자는</target>
        </trans-unit>
        <trans-unit id="aad2a9d470474da5d8494a55e6808054f9e31862" translate="yes" xml:space="preserve">
          <source>Each time you use</source>
          <target state="translated">사용할 때마다</target>
        </trans-unit>
        <trans-unit id="ef5f67cf376cd71cde435468e95d944f3c241104" translate="yes" xml:space="preserve">
          <source>Each variable on this list can have properties &lt;code&gt;overlay-arrow-string&lt;/code&gt; and &lt;code&gt;overlay-arrow-bitmap&lt;/code&gt; that specify an overlay arrow string (for text terminals) or fringe bitmap (for graphical terminals) to display at the corresponding overlay arrow position. If either property is not set, the default &lt;code&gt;overlay-arrow-string&lt;/code&gt; or &lt;code&gt;overlay-arrow&lt;/code&gt; fringe indicator is used.</source>
          <target state="translated">이 목록의 각 변수 는 오버레이 화살표 문자열 (텍스트 터미널의 경우) 또는 프린지 비트 맵 (그래픽 터미널의 경우)을 지정하여 해당 오버레이 화살표 위치에 표시하는 속성 &lt;code&gt;overlay-arrow-string&lt;/code&gt; 및 &lt;code&gt;overlay-arrow-bitmap&lt;/code&gt; 을 가질 수 있습니다 . 속성이 설정되지 않은 경우 기본 &lt;code&gt;overlay-arrow-string&lt;/code&gt; 또는 &lt;code&gt;overlay-arrow&lt;/code&gt; 프린지 표시기가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4ef6f686fb9bcdcb38b76a946d731d5b21776b57" translate="yes" xml:space="preserve">
          <source>Each warning has a &lt;em&gt;warning type&lt;/em&gt; to classify it. The type is a list of symbols. The first symbol should be the custom group that you use for the program&amp;rsquo;s user options. For example, byte compiler warnings use the warning type &lt;code&gt;(bytecomp)&lt;/code&gt;. You can also subcategorize the warnings, if you wish, by using more symbols in the list.</source>
          <target state="translated">각 경고에는 분류 할 &lt;em&gt;경고 유형&lt;/em&gt; 이 있습니다. 유형은 기호 목록입니다. 첫 번째 기호는 프로그램의 사용자 옵션에 사용하는 사용자 지정 그룹이어야합니다. 예를 들어, 바이트 컴파일러 경고는 경고 유형 &lt;code&gt;(bytecomp)&lt;/code&gt; 을 사용 합니다. 원하는 경우 목록에서 더 많은 기호를 사용하여 경고를 하위 범주화 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7b05419563012fae186137d3649c98f1f79fa29" translate="yes" xml:space="preserve">
          <source>Each window belongs to exactly one frame (see &lt;a href=&quot;frames#Frames&quot;&gt;Frames&lt;/a&gt;).</source>
          <target state="translated">각 윈도우는 정확히 하나의 프레임 (참조에 속하는 &lt;a href=&quot;frames#Frames&quot;&gt;프레임을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3dbb592ccdc83f880aa1c33595a352f03e950a3c" translate="yes" xml:space="preserve">
          <source>Each window can specify a display table, and so can each buffer. The window&amp;rsquo;s display table, if there is one, takes precedence over the buffer&amp;rsquo;s display table. If neither exists, Emacs tries to use the standard display table; if that is &lt;code&gt;nil&lt;/code&gt;, Emacs uses the usual character display conventions (see &lt;a href=&quot;usual-display#Usual-Display&quot;&gt;Usual Display&lt;/a&gt;).</source>
          <target state="translated">각 창은 디스플레이 테이블을 지정할 수 있으며 각 버퍼도 지정할 수 있습니다. 창의 표시 테이블이 있으면 버퍼의 표시 테이블보다 우선합니다. 둘 다 존재하지 않으면 Emacs는 표준 디스플레이 테이블을 사용하려고합니다. 이것이 &lt;code&gt;nil&lt;/code&gt; 이면 Emacs는 일반적인 문자 표시 규칙을 사용합니다 ( &lt;a href=&quot;usual-display#Usual-Display&quot;&gt;일반 표시&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="377bae922cb141c720011b4887600679610fc2e2" translate="yes" xml:space="preserve">
          <source>Each window displays the contents of a buffer.</source>
          <target state="translated">각 창에는 버퍼의 내용이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="36e2e629a25c4f98d548b38fe566963d0bf5edbb" translate="yes" xml:space="preserve">
          <source>Each window has its own location of point.</source>
          <target state="translated">각 창에는 고유 한 지점 위치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="471c73409475e7e93e86c9bda3823fa89d907def" translate="yes" xml:space="preserve">
          <source>Each window has its own value of point (see &lt;a href=&quot;point#Point&quot;&gt;Point&lt;/a&gt;), independent of the value of point in other windows displaying the same buffer. This makes it useful to have multiple windows showing one buffer.</source>
          <target state="translated">각 창에는 동일한 버퍼를 표시하는 다른 창에있는 점의 값과 관계없이 고유 한 점 값 ( &lt;a href=&quot;point#Point&quot;&gt;Point&lt;/a&gt; 참조 )이 있습니다. 따라서 하나의 버퍼를 표시하는 여러 창을 갖는 것이 유용합니다.</target>
        </trans-unit>
        <trans-unit id="21af55b760406410c2ff15a1789fb087e13f691d" translate="yes" xml:space="preserve">
          <source>Each window maintains a marker used to keep track of a buffer position that specifies where in the buffer display should start. This position is called the &lt;em&gt;display-start&lt;/em&gt; position of the window (or just the &lt;em&gt;start&lt;/em&gt;). The character after this position is the one that appears at the upper left corner of the window. It is usually, but not inevitably, at the beginning of a text line.</source>
          <target state="translated">각 창은 버퍼 디스플레이에서 시작해야하는 위치를 지정하는 버퍼 위치를 추적하는 데 사용되는 마커를 유지합니다. 이 위치는라고 &lt;em&gt;표시 스타트&lt;/em&gt; 창 (또는 단지의 위치 &lt;em&gt;시작&lt;/em&gt; ). 이 위치 뒤의 문자는 창의 왼쪽 상단 모서리에 나타나는 문자입니다. 일반적으로 텍스트 줄의 시작 부분에 있지만 불가피하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="fce687f2b757b30204db6be7e540c24d557b9814" translate="yes" xml:space="preserve">
          <source>Each window remembers in a list the buffers it has previously displayed, and the order in which these buffers were removed from it. This history is used, for example, by &lt;code&gt;replace-buffer-in-windows&lt;/code&gt; (see &lt;a href=&quot;buffers-and-windows#Buffers-and-Windows&quot;&gt;Buffers and Windows&lt;/a&gt;), and when quitting windows (see &lt;a href=&quot;quitting-windows#Quitting-Windows&quot;&gt;Quitting Windows&lt;/a&gt;). The list is automatically maintained by Emacs, but you can use the following functions to explicitly inspect or alter it:</source>
          <target state="translated">각 창은 목록에서 이전에 표시 한 버퍼와 이러한 버퍼가 제거 된 순서를 기억합니다. 이 기록은 예를 들어 &lt;code&gt;replace-buffer-in-windows&lt;/code&gt; ( &lt;a href=&quot;buffers-and-windows#Buffers-and-Windows&quot;&gt;Buffers 및 Windows&lt;/a&gt; 참조 )와 창을 종료 할 때 ( &lt;a href=&quot;quitting-windows#Quitting-Windows&quot;&gt;Windows&lt;/a&gt; 종료 참조 ) 사용됩니다. 목록은 Emacs에 의해 자동으로 유지되지만 다음 함수를 사용하여 명시 적으로 검사하거나 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8aecaaf814d79e70608c06de7e5e42031379d48e" translate="yes" xml:space="preserve">
          <source>Each window remembers the buffers displayed in it.</source>
          <target state="translated">각 창은 그 안에 표시된 버퍼를 기억합니다.</target>
        </trans-unit>
        <trans-unit id="6813d6d7a333036a4e7f2011729ff7b5325fc05c" translate="yes" xml:space="preserve">
          <source>Eager macro-expansion skipped due to cycle&amp;hellip;</source>
          <target state="translated">주기로 인해 빠른 매크로 확장 건너 뛰기&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="c7819a9a17cb6e9b801c22d26ce09956afd86797" translate="yes" xml:space="preserve">
          <source>Easier construction of list structure.</source>
          <target state="translated">목록 구조를 더 쉽게 구성합니다.</target>
        </trans-unit>
        <trans-unit id="62982c50a7c0a185c8095d28e3fa75a7344df943" translate="yes" xml:space="preserve">
          <source>Easy Menu</source>
          <target state="translated">쉬운 메뉴</target>
        </trans-unit>
        <trans-unit id="e669883509d7784c6369e20b9c8e23e7a2ae19ce" translate="yes" xml:space="preserve">
          <source>Echo Area Customization</source>
          <target state="translated">에코 영역 사용자 지정</target>
        </trans-unit>
        <trans-unit id="e3ef941690c36ee5499f59f47789430e59decd21" translate="yes" xml:space="preserve">
          <source>Echo area messages are logged for the user.</source>
          <target state="translated">사용자에 대해 에코 영역 메시지가 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="d0d356e2906e1462d5588304b1489624265299d3" translate="yes" xml:space="preserve">
          <source>Edebug</source>
          <target state="translated">Edebug</target>
        </trans-unit>
        <trans-unit id="de72542989794bf4f9b5288408d18fa3b9d956e8" translate="yes" xml:space="preserve">
          <source>Edebug Breakpoints</source>
          <target state="translated">Edebug 중단 점</target>
        </trans-unit>
        <trans-unit id="b8aee5a6d2c322bc3ab9fb40d52ca9936fbddd0c" translate="yes" xml:space="preserve">
          <source>Edebug Display Update</source>
          <target state="translated">Edebug 디스플레이 업데이트</target>
        </trans-unit>
        <trans-unit id="bc18eb808760456413933f510d2a752bd1e8d6ab" translate="yes" xml:space="preserve">
          <source>Edebug Execution Modes</source>
          <target state="translated">Edebug 실행 모드</target>
        </trans-unit>
        <trans-unit id="db5fcd0b8950d84b987ca870e92762ff16aec921" translate="yes" xml:space="preserve">
          <source>Edebug Options</source>
          <target state="translated">Edebug 옵션</target>
        </trans-unit>
        <trans-unit id="ff142d85d91b23e86bff42fd24362bcde946851e" translate="yes" xml:space="preserve">
          <source>Edebug Recursive Edit</source>
          <target state="translated">Edebug 재귀 편집</target>
        </trans-unit>
        <trans-unit id="fa24aa898a4d87754b34d172971d0b2fd796309e" translate="yes" xml:space="preserve">
          <source>Edebug Views</source>
          <target state="translated">Edebug보기</target>
        </trans-unit>
        <trans-unit id="aaaaaf87ac09329f2cde58c88e53a15cfbfc4fd2" translate="yes" xml:space="preserve">
          <source>Edebug also has a coverage testing feature (see &lt;a href=&quot;coverage-testing#Coverage-Testing&quot;&gt;Coverage Testing&lt;/a&gt;). These features partly duplicate each other, and it would be cleaner to combine them.</source>
          <target state="translated">Edebug에는 커버리지 테스트 기능도 있습니다 ( &lt;a href=&quot;coverage-testing#Coverage-Testing&quot;&gt;커버리지 테스트&lt;/a&gt; 참조 ). 이러한 기능은 부분적으로 서로 중복되며 결합하는 것이 더 깔끔합니다.</target>
        </trans-unit>
        <trans-unit id="5994b668cd44159515a3e4ba54f24512ebee8719" translate="yes" xml:space="preserve">
          <source>Edebug always stops or pauses at a breakpoint, except when the Edebug mode is Go-nonstop. In that mode, it ignores breakpoints entirely.</source>
          <target state="translated">Edebug는 Edebug 모드가 Go-nonstop 인 경우를 제외하고 항상 중단 점에서 중지하거나 일시 중지합니다. 이 모드에서는 중단 점을 완전히 무시합니다.</target>
        </trans-unit>
        <trans-unit id="8ac07564c784bdf322cd2d256e04366eca19af10" translate="yes" xml:space="preserve">
          <source>Edebug and Macros</source>
          <target state="translated">Edebug 및 매크로</target>
        </trans-unit>
        <trans-unit id="2334c070b2d93786e0f9d4e0e6ef1389b7e33bc2" translate="yes" xml:space="preserve">
          <source>Edebug binds &lt;code&gt;debug-on-error&lt;/code&gt; to this value, if &lt;code&gt;debug-on-error&lt;/code&gt; was previously &lt;code&gt;nil&lt;/code&gt;. See &lt;a href=&quot;trapping-errors#Trapping-Errors&quot;&gt;Trapping Errors&lt;/a&gt;.</source>
          <target state="translated">Edebug는 &lt;code&gt;debug-on-error&lt;/code&gt; 가 이전에 &lt;code&gt;nil&lt;/code&gt; 인 경우 &lt;code&gt;debug-on-error&lt;/code&gt; 를이 값 에 바인딩 합니다. &lt;a href=&quot;trapping-errors#Trapping-Errors&quot;&gt;오류 트래핑을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f770030db08cea088bd08663ed881e1cd0f21f55" translate="yes" xml:space="preserve">
          <source>Edebug binds &lt;code&gt;debug-on-quit&lt;/code&gt; to this value, if &lt;code&gt;debug-on-quit&lt;/code&gt; was previously &lt;code&gt;nil&lt;/code&gt;. See &lt;a href=&quot;trapping-errors#Trapping-Errors&quot;&gt;Trapping Errors&lt;/a&gt;.</source>
          <target state="translated">Edebug는 &lt;code&gt;debug-on-quit&lt;/code&gt; 가 이전에 &lt;code&gt;nil&lt;/code&gt; 이었던 경우 &lt;code&gt;debug-on-quit&lt;/code&gt; 를이 값 에 바인딩 합니다. &lt;a href=&quot;trapping-errors#Trapping-Errors&quot;&gt;오류 트래핑을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="581bbe1c7b1bf43b35887b695cec303d8cc475a0" translate="yes" xml:space="preserve">
          <source>Edebug can record an execution trace, storing it in a buffer named</source>
          <target state="translated">Edebug는 실행 추적을 기록하여 다음 이름의 버퍼에 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20366c58a50ec9fdef7674ad425cec8c20ee076b" translate="yes" xml:space="preserve">
          <source>Edebug cannot save and restore the value of &lt;code&gt;unread-command-events&lt;/code&gt;. Entering Edebug while this variable has a nontrivial value can interfere with execution of the program you are debugging.</source>
          <target state="translated">Edebug는 &lt;code&gt;unread-command-events&lt;/code&gt; 값을 저장하고 복원 할 수 없습니다 . 이 변수에 중요한 값이있을 때 Edebug를 입력하면 디버깅중인 프로그램의 실행을 방해 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16918456881c20d67309bd633563ae947d9b3b7b" translate="yes" xml:space="preserve">
          <source>Edebug is a source-level debugger for Emacs Lisp programs, with which you can:</source>
          <target state="translated">Edebug는 Emacs Lisp 프로그램을위한 소스 레벨 디버거로 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="789c782ce1bff1de5d155e3b1f0f895fb82a5514" translate="yes" xml:space="preserve">
          <source>Edebug knows how to instrument all the standard special forms, &lt;code&gt;interactive&lt;/code&gt; forms with an expression argument, anonymous lambda expressions, and other defining forms. However, Edebug cannot determine on its own what a user-defined macro will do with the arguments of a macro call, so you must provide that information using Edebug specifications; for details, see &lt;a href=&quot;edebug-and-macros#Edebug-and-Macros&quot;&gt;Edebug and Macros&lt;/a&gt;.</source>
          <target state="translated">Edebug는 모든 표준 특수 형식, 식 인수가있는 &lt;code&gt;interactive&lt;/code&gt; 형식, 익명 람다 식 및 기타 정의 형식 을 계측하는 방법을 알고 있습니다. 그러나 Edebug는 사용자 정의 매크로가 매크로 호출의 인수로 수행 할 작업을 자체적으로 결정할 수 없으므로 Edebug 사양을 사용하여 해당 정보를 제공해야합니다. 자세한 내용은 &lt;a href=&quot;edebug-and-macros#Edebug-and-Macros&quot;&gt;Edebug 및 매크로를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1207a8c1131590d2c1fba8e8a08045f9810e7ded" translate="yes" xml:space="preserve">
          <source>Edebug provides rudimentary coverage testing and display of execution frequency.</source>
          <target state="translated">Edebug는 기본적인 범위 테스트 및 실행 빈도 표시를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="36c74f738d92fd5a51f36c24f8a45083919a4383" translate="yes" xml:space="preserve">
          <source>Edebug specifications provide the power of regular expression matching, plus some context-free grammar constructs: the matching of sublists with balanced parentheses, recursive processing of forms, and recursion via indirect specifications.</source>
          <target state="translated">Edebug 사양은 정규식 일치 기능과 함께 일부 문맥없는 문법 구조를 제공합니다 : 균형 잡힌 괄호가있는 하위 목록 일치, 양식 재귀 처리 및 간접 사양을 통한 재귀.</target>
        </trans-unit>
        <trans-unit id="f06b5c4b7654995d8c103e8f7c041be09dabee12" translate="yes" xml:space="preserve">
          <source>Edebug supports evaluation of expressions containing references to lexically bound symbols created by the following constructs in</source>
          <target state="translated">Edebug는 다음 구문으로 생성 된 어휘 바인딩 기호에 대한 참조를 포함하는 표현식 평가를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="92e9b4ffd97bcf6f208e24140d67894084ea0be2" translate="yes" xml:space="preserve">
          <source>Edebug supports several execution modes for running the program you are debugging. We call these alternatives &lt;em&gt;Edebug execution modes&lt;/em&gt;; do not confuse them with major or minor modes. The current Edebug execution mode determines how far Edebug continues execution before stopping&amp;mdash;whether it stops at each stop point, or continues to the next breakpoint, for example&amp;mdash;and how much Edebug displays the progress of the evaluation before it stops.</source>
          <target state="translated">Edebug는 디버깅중인 프로그램을 실행하기위한 여러 실행 모드를 지원합니다. 이러한 대안을 &lt;em&gt;Edebug 실행 모드&lt;/em&gt; 라고 &lt;em&gt;합니다&lt;/em&gt; . 메이저 또는 마이너 모드와 혼동하지 마십시오. 현재 Edebug 실행 모드는 Edebug가 중지하기 전에 실행을 계속하는 거리 (예 : 각 중지 지점에서 중지하거나 다음 중단 점까지 계속) 및 Edebug가 중지하기 전에 평가 진행률을 표시하는 정도를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="f7233d448eb4726f6f80864ae5edc50a6ac1b407" translate="yes" xml:space="preserve">
          <source>Edebug tries to be transparent to the program you are debugging, but it does not succeed completely. Edebug also tries to be transparent when you evaluate expressions with</source>
          <target state="translated">Edebug는 디버깅중인 프로그램에 대해 투명하게 시도하지만 완전히 성공하지는 않습니다. Edebug는 또한 다음을 사용하여 표현식을 평가할 때 투명 해 지려고합니다.</target>
        </trans-unit>
        <trans-unit id="33534c2c4e6a92bffabc52624dabaee51456428a" translate="yes" xml:space="preserve">
          <source>Edebug uses the following specifications for &lt;code&gt;defun&lt;/code&gt; and the associated argument list and &lt;code&gt;interactive&lt;/code&gt; specifications. It is necessary to handle interactive forms specially since an expression argument is actually evaluated outside of the function body. (The specification for &lt;code&gt;defmacro&lt;/code&gt; is very similar to that for &lt;code&gt;defun&lt;/code&gt;, but allows for the &lt;code&gt;declare&lt;/code&gt; statement.)</source>
          <target state="translated">Edebug는 &lt;code&gt;defun&lt;/code&gt; 및 관련 인수 목록 및 &lt;code&gt;interactive&lt;/code&gt; 사양에 대해 다음 사양을 사용합니다 . 표현식 인수는 실제로 함수 본문 외부에서 평가되므로 대화 형 형식을 특별히 처리해야합니다. (대한 사양 &lt;code&gt;defmacro&lt;/code&gt; 을 위한 매우 유사 &lt;code&gt;defun&lt;/code&gt; 는 하지만, 수 있습니다 &lt;code&gt;declare&lt;/code&gt; 문.)</target>
        </trans-unit>
        <trans-unit id="28e944e5aaec320c912fa03faba41f7a60142004" translate="yes" xml:space="preserve">
          <source>Edebug&amp;rsquo;s behavior may also be changed on a per-definition basis by adding an entry to this alist, with a key of your choice and three functions. Then set the &lt;code&gt;edebug-behavior&lt;/code&gt; symbol property of an instrumented definition to the key of the new entry, and Edebug will call the new functions in place of its own for that definition.</source>
          <target state="translated">Edebug의 동작은 사용자가 선택한 키와 세 가지 기능과 함께이 목록에 항목을 추가하여 정의별로 변경할 수도 있습니다. 그런 다음 계측 된 정의 의 &lt;code&gt;edebug-behavior&lt;/code&gt; 심볼 속성을 새 항목의 키로 설정하면 Edebug 는 해당 정의에 대해 자체적으로 새 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="2f53d1947915ed6dc821d423e99aa65ab03bb93d" translate="yes" xml:space="preserve">
          <source>Edebug&amp;rsquo;s step mode stops execution when the next stop point is reached. There are three other ways to stop Edebug execution once it has started: breakpoints, the global break condition, and source breakpoints.</source>
          <target state="translated">Edebug의 단계 모드는 다음 중지 지점에 도달하면 실행을 중지합니다. Edebug 실행이 시작되면 중지하는 세 가지 다른 방법이 있습니다 : 중단 점, 전역 중단 조건 및 소스 중단 점.</target>
        </trans-unit>
        <trans-unit id="5301648dcf6b53cefc9ed52999aaa92d4603cae0" translate="yes" xml:space="preserve">
          <source>Edit</source>
          <target state="translated">Edit</target>
        </trans-unit>
        <trans-unit id="26e19fa6a6a51a98d665a3d92cdd6e86ab35a512" translate="yes" xml:space="preserve">
          <source>Edit the replacement for this question in the minibuffer.</source>
          <target state="translated">미니 버퍼에서이 질문에 대한 대체를 편집하십시오.</target>
        </trans-unit>
        <trans-unit id="acd754eaa0be450083a7a0239c06b5b27192bf9c" translate="yes" xml:space="preserve">
          <source>Editing Types</source>
          <target state="translated">유형 편집</target>
        </trans-unit>
        <trans-unit id="7599687cce12a98db349160bf1999a82904d7cae" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;nil&lt;/code&gt;, which means the click occurred on buffer text, or a cons cell of the form (&lt;var&gt;string&lt;/var&gt; . &lt;var&gt;string-pos&lt;/var&gt;) if there is a string from a text property or an overlay at the click position.</source>
          <target state="translated">어느 &lt;code&gt;nil&lt;/code&gt; 클릭 수단 버퍼 텍스트 또는 폼 (반대의 셀에서 발생한 &lt;var&gt;string&lt;/var&gt; . &lt;var&gt;string-pos&lt;/var&gt; 텍스트 속성 또는 클릭 위치에 오버레이로부터 캐릭터가있는 경우).</target>
        </trans-unit>
        <trans-unit id="d7baec04849ab97493d5ac11cfad3d5209b1d2ba" translate="yes" xml:space="preserve">
          <source>Either a list of the form &lt;code&gt;(&lt;var&gt;key-file&lt;/var&gt; &lt;var&gt;cert-file&lt;/var&gt;)&lt;/code&gt;, naming the certificate key file and certificate file itself, or &lt;code&gt;t&lt;/code&gt;, meaning to query &lt;code&gt;auth-source&lt;/code&gt; for this information (see &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/auth/Help-for-users.html#Help-for-users&quot;&gt;auth-source&lt;/a&gt; in</source>
          <target state="translated">인증서 키 파일과 인증서 파일 자체의 이름을 지정 하는 형식 &lt;code&gt;(&lt;var&gt;key-file&lt;/var&gt; &lt;var&gt;cert-file&lt;/var&gt;)&lt;/code&gt; 목록 또는 이 정보에 대한 &lt;code&gt;auth-source&lt;/code&gt; 쿼리를 의미하는 &lt;code&gt;t&lt;/code&gt; 입니다 (의 &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/auth/Help-for-users.html#Help-for-users&quot;&gt;auth-source&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="865508465ca5b2bcd7d2f81973321df89ed12307" translate="yes" xml:space="preserve">
          <source>Elements 1, 2, and 6 are ignored in a state which you pass as an argument to &lt;code&gt;parse-partial-sexp&lt;/code&gt; to continue parsing. Elements 9 and 10 are mainly used internally by the parser code.</source>
          <target state="translated">요소 1, 2 및 6은 &lt;code&gt;parse-partial-sexp&lt;/code&gt; 을 계속 하기 위해 parse-partial-sexp 에 인수로 전달하는 상태에서 무시됩니다 . 요소 9와 10은 주로 파서 코드에서 내부적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="78699cbfd109ddf450b59043223813a8b7eeccec" translate="yes" xml:space="preserve">
          <source>Elements read from this list are normally recorded by the record-keeping features (see &lt;a href=&quot;recording-input#Recording-Input&quot;&gt;Recording Input&lt;/a&gt;) and while defining a keyboard macro (see &lt;a href=&quot;keyboard-macros#Keyboard-Macros&quot;&gt;Keyboard Macros&lt;/a&gt;). However, an element of the form &lt;code&gt;(no-record&amp;nbsp;.&amp;nbsp;&lt;var&gt;event&lt;/var&gt;)&lt;/code&gt; causes &lt;var&gt;event&lt;/var&gt; to be processed normally without recording it.</source>
          <target state="translated">요소는 일반적으로 기록 보관 기능에 의해 기록이 목록에서 읽기 (참조 &lt;a href=&quot;recording-input#Recording-Input&quot;&gt;녹음 입력&lt;/a&gt; ) 및 키보드 매크로를 정의하는 동안합니다 ( &lt;a href=&quot;keyboard-macros#Keyboard-Macros&quot;&gt;키보드 매크로&lt;/a&gt; ). 그러나 형식의 요소 &lt;code&gt;(no-record&amp;nbsp;.&amp;nbsp;&lt;var&gt;event&lt;/var&gt;)&lt;/code&gt; 는 &lt;var&gt;event&lt;/var&gt; 를 기록하지 않고 정상적으로 처리되도록합니다.</target>
        </trans-unit>
        <trans-unit id="545b0cb131beb226cbb616788142dc984df9548a" translate="yes" xml:space="preserve">
          <source>Eliminating an asynchronous subprocess.</source>
          <target state="translated">비동기 하위 프로세스 제거.</target>
        </trans-unit>
        <trans-unit id="b99aea41be1dd6682aef77fdd05c13425b490b64" translate="yes" xml:space="preserve">
          <source>Eliminating symbolic links from a file name.</source>
          <target state="translated">파일 이름에서 심볼릭 링크 제거.</target>
        </trans-unit>
        <trans-unit id="e75efa6670a36f5ce5a2c336a74d40c2b84e641a" translate="yes" xml:space="preserve">
          <source>Elisp</source>
          <target state="translated">Elisp</target>
        </trans-unit>
        <trans-unit id="11961af86ac0a289f5a8c470c62e5aff16dc0f5c" translate="yes" xml:space="preserve">
          <source>Emacs Display</source>
          <target state="translated">Emacs 디스플레이</target>
        </trans-unit>
        <trans-unit id="1d24b3a1a3bb63bf22f3f35dd8bdc416f585ca87" translate="yes" xml:space="preserve">
          <source>Emacs Dynamic Modules</source>
          <target state="translated">Emacs 동적 모듈</target>
        </trans-unit>
        <trans-unit id="9ef54a3413b4b5d1c94937992e5a38fa19928278" translate="yes" xml:space="preserve">
          <source>Emacs EasyPG Assistant Manual</source>
          <target state="translated">Emacs EasyPG Assistant 매뉴얼</target>
        </trans-unit>
        <trans-unit id="7d69c84368b765ad9cf1f68ed28726d76d0a1f4f" translate="yes" xml:space="preserve">
          <source>Emacs Lisp</source>
          <target state="translated">Emacs Lisp</target>
        </trans-unit>
        <trans-unit id="f364876c0176165f21f9725c4e1f6ba2004826f7" translate="yes" xml:space="preserve">
          <source>Emacs Lisp has a &lt;em&gt;compiler&lt;/em&gt; that translates functions written in Lisp into a special representation called &lt;em&gt;byte-code&lt;/em&gt; that can be executed more efficiently. The compiler replaces Lisp function definitions with byte-code. When a byte-code function is called, its definition is evaluated by the &lt;em&gt;byte-code interpreter&lt;/em&gt;.</source>
          <target state="translated">Emacs Lisp에는 Lisp로 작성된 함수를 보다 효율적으로 실행할 수있는 &lt;em&gt;바이트 코드&lt;/em&gt; 라는 특수 표현으로 변환 하는 &lt;em&gt;컴파일러&lt;/em&gt; 가 있습니다. 컴파일러는 Lisp 함수 정의를 바이트 코드로 대체합니다. 바이트 코드 함수가 호출되면 해당 정의는 &lt;em&gt;바이트 코드 인터프리터에&lt;/em&gt; 의해 평가됩니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="15dbc9ab10d150d57c606c833f2449026acec815" translate="yes" xml:space="preserve">
          <source>Emacs Lisp has several interfaces for loading. For example, &lt;code&gt;autoload&lt;/code&gt; creates a placeholder object for a function defined in a file; trying to call the autoloading function loads the file to get the function&amp;rsquo;s real definition (see &lt;a href=&quot;autoload#Autoload&quot;&gt;Autoload&lt;/a&gt;). &lt;code&gt;require&lt;/code&gt; loads a file if it isn&amp;rsquo;t already loaded (see &lt;a href=&quot;named-features#Named-Features&quot;&gt;Named Features&lt;/a&gt;). Ultimately, all these facilities call the &lt;code&gt;load&lt;/code&gt; function to do the work.</source>
          <target state="translated">Emacs Lisp에는 로딩을위한 여러 인터페이스가 있습니다. 예를 들어, &lt;code&gt;autoload&lt;/code&gt; 는 파일에 정의 된 함수에 대한 자리 표시 자 개체를 만듭니다. 자동로드 함수를 호출하려고하면 파일을로드하여 함수의 실제 정의를 가져옵니다 ( &lt;a href=&quot;autoload#Autoload&quot;&gt;Autoload&lt;/a&gt; 참조 ). &lt;code&gt;require&lt;/code&gt; 는 파일이 아직로드되지 않은 경우로드합니다 ( &lt;a href=&quot;named-features#Named-Features&quot;&gt;명명 된 기능&lt;/a&gt; 참조 ). 궁극적으로 이러한 모든 시설 은 작업을 수행하기 위해 &lt;code&gt;load&lt;/code&gt; 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="53311aa3b6248b8318ac6ffa867ca69521b615e7" translate="yes" xml:space="preserve">
          <source>Emacs Lisp is not at all influenced by Scheme; but the GNU project has an implementation of Scheme, called Guile. We use it in all new GNU software that calls for extensibility.</source>
          <target state="translated">Emacs Lisp는 Scheme의 영향을 전혀받지 않습니다. 그러나 GNU 프로젝트에는 Guile이라고하는 Scheme이 구현되어 있습니다. 확장 성을 요구하는 모든 새로운 GNU 소프트웨어에서 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5eb9e6bbd184c8e8d87bab48605f13c2f0e69a4c" translate="yes" xml:space="preserve">
          <source>Emacs Lisp mutexes are of a type called &lt;em&gt;recursive&lt;/em&gt;, which means that a thread can re-acquire a mutex it owns any number of times. A mutex keeps a count of how many times it has been acquired, and each acquisition of a mutex must be paired with a release. The last release by a thread of a mutex reverts it to the unowned state, potentially allowing another thread to acquire the mutex.</source>
          <target state="translated">Emacs Lisp 뮤텍스는 &lt;em&gt;recursive&lt;/em&gt; 라는 유형 입니다. 이는 스레드가 소유 한 뮤텍스를 여러 번 다시 획득 할 수 있음을 의미합니다. 뮤텍스는 획득 한 횟수를 유지하며 뮤텍스의 각 획득은 릴리스와 쌍을 이루어야합니다. 뮤텍스의 스레드에 의한 마지막 릴리스는 소유하지 않은 상태로 되돌려 잠재적으로 다른 스레드가 뮤텍스를 획득 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="5dacb820cefb1440695d68c57f34587912fb0410" translate="yes" xml:space="preserve">
          <source>Emacs Lisp programs can open stream (TCP) and datagram (UDP) network connections (see &lt;a href=&quot;datagrams#Datagrams&quot;&gt;Datagrams&lt;/a&gt;) to other processes on the same machine or other machines. A network connection is handled by Lisp much like a subprocess, and is represented by a process object. However, the process you are communicating with is not a child of the Emacs process, has no process</source>
          <target state="translated">Emacs Lisp 프로그램은 동일한 시스템 또는 다른 시스템의 다른 프로세스에 대한 스트림 (TCP) 및 데이터 그램 (UDP) 네트워크 연결 ( &lt;a href=&quot;datagrams#Datagrams&quot;&gt;데이터 그램&lt;/a&gt; 참조 )을 열 수 있습니다. 네트워크 연결은 하위 프로세스처럼 Lisp에 의해 처리되며 프로세스 개체로 표시됩니다. 그러나 통신중인 프로세스는 Emacs 프로세스의 하위 프로세스가 아니며 프로세스가 없습니다.</target>
        </trans-unit>
        <trans-unit id="7228b1f4138d429db1308081a4746c06528fb743" translate="yes" xml:space="preserve">
          <source>Emacs Lisp provides a general-purpose hash table data type, along with a series of functions for operating on them. Hash tables have a special printed representation, which consists of &amp;lsquo;</source>
          <target state="translated">Emacs Lisp는 일반적인 용도의 해시 테이블 데이터 유형과 이에 대해 작동하는 일련의 함수를 제공합니다. 해시 테이블에는 '</target>
        </trans-unit>
        <trans-unit id="ffe36d47af16b167f8af8d65f4621660e0a3fa30" translate="yes" xml:space="preserve">
          <source>Emacs Lisp provides a limited form of concurrency, called &lt;em&gt;threads&lt;/em&gt;. All the threads in a given instance of Emacs share the same memory. Concurrency in Emacs Lisp is &amp;ldquo;mostly cooperative&amp;rdquo;, meaning that Emacs will only switch execution between threads at well-defined times. However, the Emacs thread support has been designed in a way to later allow more fine-grained concurrency, and correct programs should not rely on cooperative threading.</source>
          <target state="translated">Emacs Lisp는 &lt;em&gt;threads&lt;/em&gt; 라는 제한된 형태의 동시성을 제공 &lt;em&gt;합니다&lt;/em&gt; . 주어진 Emacs 인스턴스의 모든 스레드는 동일한 메모리를 공유합니다. Emacs Lisp의 동시성은 &quot;대부분 협력 적&quot;입니다. 즉, Emacs는 잘 정의 된 시간에만 스레드간에 실행을 전환합니다. 그러나 Emacs 스레드 지원은 나중에보다 세밀한 동시성을 허용하도록 설계되었으며 올바른 프로그램은 협력 스레드에 의존해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="3523135daa3b21509914424f92d7c0654029826d" translate="yes" xml:space="preserve">
          <source>Emacs Lisp provides a rich set of the data types. Some of them, like cons cells, integers and strings, are common to nearly all Lisp dialects. Some others, like markers and buffers, are quite special and needed to provide the basic support to write editor commands in Lisp. To implement such a variety of object types and provide an efficient way to pass objects between the subsystems of an interpreter, there is a set of C data structures and a special type to represent the pointers to all of them, which is known as &lt;em&gt;tagged pointer&lt;/em&gt;.</source>
          <target state="translated">Emacs Lisp provides a rich set of the data types. Some of them, like cons cells, integers and strings, are common to nearly all Lisp dialects. Some others, like markers and buffers, are quite special and needed to provide the basic support to write editor commands in Lisp. To implement such a variety of object types and provide an efficient way to pass objects between the subsystems of an interpreter, there is a set of C data structures and a special type to represent the pointers to all of them, which is known as &lt;em&gt;tagged pointer&lt;/em&gt;.</target>
        </trans-unit>
        <trans-unit id="a0792e8235851678da162077315383848bc5c350" translate="yes" xml:space="preserve">
          <source>Emacs Lisp provides primitives to create and control threads, and also to create and control mutexes and condition variables, useful for thread synchronization.</source>
          <target state="translated">Emacs Lisp provides primitives to create and control threads, and also to create and control mutexes and condition variables, useful for thread synchronization.</target>
        </trans-unit>
        <trans-unit id="07838ca0f24b0415a3b2a5ec64b19ae909fd062f" translate="yes" xml:space="preserve">
          <source>Emacs Lisp provides several kinds of control structure, including other varieties of sequencing, conditionals, iteration, and (controlled) jumps&amp;mdash;all discussed below. The built-in control structures are special forms since their subforms are not necessarily evaluated or not evaluated sequentially. You can use macros to define your own control structure constructs (see &lt;a href=&quot;macros#Macros&quot;&gt;Macros&lt;/a&gt;).</source>
          <target state="translated">Emacs Lisp provides several kinds of control structure, including other varieties of sequencing, conditionals, iteration, and (controlled) jumps&amp;mdash;all discussed below. The built-in control structures are special forms since their subforms are not necessarily evaluated or not evaluated sequentially. You can use macros to define your own control structure constructs (see &lt;a href=&quot;macros#Macros&quot;&gt;Macros&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="5eced44d6f227b201299c5badcb9e4e4043498ff" translate="yes" xml:space="preserve">
          <source>Emacs Lisp provides the traditional four arithmetic operations (addition, subtraction, multiplication, and division), as well as remainder and modulus functions, and functions to add or subtract 1. Except for &lt;code&gt;%&lt;/code&gt;, each of these functions accepts both integer and floating-point arguments, and returns a floating-point number if any argument is floating point.</source>
          <target state="translated">Emacs Lisp provides the traditional four arithmetic operations (addition, subtraction, multiplication, and division), as well as remainder and modulus functions, and functions to add or subtract 1. Except for &lt;code&gt;%&lt;/code&gt; , each of these functions accepts both integer and floating-point arguments, and returns a floating-point number if any argument is floating point.</target>
        </trans-unit>
        <trans-unit id="c75c0672f1103474c697e0414e0d81f059ae0283" translate="yes" xml:space="preserve">
          <source>Emacs Lisp represents many special objects and constructs via special hash notations.</source>
          <target state="translated">Emacs Lisp represents many special objects and constructs via special hash notations.</target>
        </trans-unit>
        <trans-unit id="c4181f7e2dd76cd593dd2b4c56244fb6dc36cf72" translate="yes" xml:space="preserve">
          <source>Emacs Lisp supports nonlocal exits, whereby program control is transfered from one point in a program to another remote point. See &lt;a href=&quot;nonlocal-exits#Nonlocal-Exits&quot;&gt;Nonlocal Exits&lt;/a&gt;. Thus, Lisp functions called by your module might exit nonlocally by calling &lt;code&gt;signal&lt;/code&gt; or &lt;code&gt;throw&lt;/code&gt;, and your module functions must handle such nonlocal exits properly. Such handling is needed because C programs will not automatically release resources and perform other cleanups in these cases; your module code must itself do it. The module</source>
          <target state="translated">Emacs Lisp supports nonlocal exits, whereby program control is transfered from one point in a program to another remote point. See &lt;a href=&quot;nonlocal-exits#Nonlocal-Exits&quot;&gt;Nonlocal Exits&lt;/a&gt;. Thus, Lisp functions called by your module might exit nonlocally by calling &lt;code&gt;signal&lt;/code&gt; or &lt;code&gt;throw&lt;/code&gt; , and your module functions must handle such nonlocal exits properly. Such handling is needed because C programs will not automatically release resources and perform other cleanups in these cases; your module code must itself do it. The module</target>
        </trans-unit>
        <trans-unit id="8984f14f223609c734113eaabdefa7eec293526d" translate="yes" xml:space="preserve">
          <source>Emacs Lisp treats &lt;code&gt;-0.0&lt;/code&gt; as numerically equal to ordinary zero with respect to numeric comparisons like &lt;code&gt;=&lt;/code&gt;. This follows the</source>
          <target state="translated">Emacs Lisp treats &lt;code&gt;-0.0&lt;/code&gt; as numerically equal to ordinary zero with respect to numeric comparisons like &lt;code&gt;=&lt;/code&gt; . This follows the</target>
        </trans-unit>
        <trans-unit id="b22e8745733f1044e0e8e778b087514ab35866de" translate="yes" xml:space="preserve">
          <source>Emacs Lisp uses two kinds of storage for user-created Lisp objects: &lt;em&gt;normal storage&lt;/em&gt; and &lt;em&gt;pure storage&lt;/em&gt;. Normal storage is where all the new data created during an Emacs session are kept (see &lt;a href=&quot;garbage-collection#Garbage-Collection&quot;&gt;Garbage Collection&lt;/a&gt;). Pure storage is used for certain data in the preloaded standard Lisp files&amp;mdash;data that should never change during actual use of Emacs.</source>
          <target state="translated">Emacs Lisp uses two kinds of storage for user-created Lisp objects: &lt;em&gt;normal storage&lt;/em&gt; and &lt;em&gt;pure storage&lt;/em&gt;. Normal storage is where all the new data created during an Emacs session are kept (see &lt;a href=&quot;garbage-collection#Garbage-Collection&quot;&gt;Garbage Collection&lt;/a&gt;). Pure storage is used for certain data in the preloaded standard Lisp files&amp;mdash;data that should never change during actual use of Emacs.</target>
        </trans-unit>
        <trans-unit id="9930d40258feb9fa1a5853262c7e1ecbe82780b6" translate="yes" xml:space="preserve">
          <source>Emacs also attempts to load a second init file, called the &lt;em&gt;early init file&lt;/em&gt;, if it exists. This is a file named</source>
          <target state="translated">Emacs also attempts to load a second init file, called the &lt;em&gt;early init file&lt;/em&gt;, if it exists. This is a file named</target>
        </trans-unit>
        <trans-unit id="f438beb0b54269588c167da980a7fc150f86a60f" translate="yes" xml:space="preserve">
          <source>Emacs also defines &lt;em&gt;raw syntax descriptors&lt;/em&gt;, which are used to describe syntax classes at a lower level. See &lt;a href=&quot;syntax-table-internals#Syntax-Table-Internals&quot;&gt;Syntax Table Internals&lt;/a&gt;.</source>
          <target state="translated">Emacs also defines &lt;em&gt;raw syntax descriptors&lt;/em&gt;, which are used to describe syntax classes at a lower level. See &lt;a href=&quot;syntax-table-internals#Syntax-Table-Internals&quot;&gt;Syntax Table Internals&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="b081e88746f63937ab843405b000899eb6e7ac41" translate="yes" xml:space="preserve">
          <source>Emacs also provides explicit intervals as a presentation feature; see &lt;a href=&quot;overlays#Overlays&quot;&gt;Overlays&lt;/a&gt;.</source>
          <target state="translated">Emacs also provides explicit intervals as a presentation feature; see &lt;a href=&quot;overlays#Overlays&quot;&gt;Overlays&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="d6037f3bcf19731d59e4737efeb909a4477fe1f5" translate="yes" xml:space="preserve">
          <source>Emacs also runs the hook &lt;code&gt;window-selection-change-functions&lt;/code&gt; whenever the redisplay routine detects that another window has been selected since last redisplay. See &lt;a href=&quot;window-hooks#Window-Hooks&quot;&gt;Window Hooks&lt;/a&gt;, for a detailed explanation. &lt;code&gt;window-state-change-functions&lt;/code&gt; (described in the same section) is another abnormal hook run after a different window has been selected but is triggered by other window changes as well.</source>
          <target state="translated">Emacs also runs the hook &lt;code&gt;window-selection-change-functions&lt;/code&gt; whenever the redisplay routine detects that another window has been selected since last redisplay. See &lt;a href=&quot;window-hooks#Window-Hooks&quot;&gt;Window Hooks&lt;/a&gt;, for a detailed explanation. &lt;code&gt;window-state-change-functions&lt;/code&gt; (described in the same section) is another abnormal hook run after a different window has been selected but is triggered by other window changes as well.</target>
        </trans-unit>
        <trans-unit id="4fa081728575b5af47f34cfa1d0d81f4cfadd8e1" translate="yes" xml:space="preserve">
          <source>Emacs applications have the same sort of race-condition issues that other applications do. For example, even when &lt;code&gt;(file-readable-p &quot;foo.txt&quot;)&lt;/code&gt; returns &lt;code&gt;t&lt;/code&gt;, it could be that</source>
          <target state="translated">Emacs applications have the same sort of race-condition issues that other applications do. For example, even when &lt;code&gt;(file-readable-p &quot;foo.txt&quot;)&lt;/code&gt; returns &lt;code&gt;t&lt;/code&gt; , it could be that</target>
        </trans-unit>
        <trans-unit id="7834c231794da13a4ac8440585e75335487d24af" translate="yes" xml:space="preserve">
          <source>Emacs attempts to infer the coding systems of the files and network connections it accesses. See &lt;a href=&quot;coding-systems#Coding-Systems&quot;&gt;Coding Systems&lt;/a&gt;. If Emacs infers incorrectly, or if the other parties to the network connection disagree with Emacs&amp;rsquo;s inferences, the resulting system could be unreliable. Also, even when it infers correctly, Emacs often can use bytes that other programs cannot. For example, although to Emacs the null byte is just a character like any other, many other applications treat it as a string terminator and mishandle strings or files containing null bytes.</source>
          <target state="translated">Emacs attempts to infer the coding systems of the files and network connections it accesses. See &lt;a href=&quot;coding-systems#Coding-Systems&quot;&gt;Coding Systems&lt;/a&gt;. If Emacs infers incorrectly, or if the other parties to the network connection disagree with Emacs&amp;rsquo;s inferences, the resulting system could be unreliable. Also, even when it infers correctly, Emacs often can use bytes that other programs cannot. For example, although to Emacs the null byte is just a character like any other, many other applications treat it as a string terminator and mishandle strings or files containing null bytes.</target>
        </trans-unit>
        <trans-unit id="c00bcea23c0da23f92989ded99bb44ac6e6e81dc" translate="yes" xml:space="preserve">
          <source>Emacs auth-source Library</source>
          <target state="translated">Emacs auth-source Library</target>
        </trans-unit>
        <trans-unit id="9f846cfde8ec0bbf0a7662f71e026a3be4a6b612" translate="yes" xml:space="preserve">
          <source>Emacs automatically saves and restores the match data when it runs process filter functions (see &lt;a href=&quot;filter-functions#Filter-Functions&quot;&gt;Filter Functions&lt;/a&gt;) and process sentinels (see &lt;a href=&quot;sentinels#Sentinels&quot;&gt;Sentinels&lt;/a&gt;).</source>
          <target state="translated">Emacs automatically saves and restores the match data when it runs process filter functions (see &lt;a href=&quot;filter-functions#Filter-Functions&quot;&gt;Filter Functions&lt;/a&gt;) and process sentinels (see &lt;a href=&quot;sentinels#Sentinels&quot;&gt;Sentinels&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="67baa3b59c5cfd5117efdc499dc974b7501e0ed6" translate="yes" xml:space="preserve">
          <source>Emacs becomes &lt;em&gt;idle&lt;/em&gt; when it starts waiting for user input, and it remains idle until the user provides some input. If a timer is set for five seconds of idleness, it runs approximately five seconds after Emacs first becomes idle. Even if &lt;var&gt;repeat&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, this timer will not run again as long as Emacs remains idle, because the duration of idleness will continue to increase and will not go down to five seconds again.</source>
          <target state="translated">Emacs becomes &lt;em&gt;idle&lt;/em&gt; when it starts waiting for user input, and it remains idle until the user provides some input. If a timer is set for five seconds of idleness, it runs approximately five seconds after Emacs first becomes idle. Even if &lt;var&gt;repeat&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , this timer will not run again as long as Emacs remains idle, because the duration of idleness will continue to increase and will not go down to five seconds again.</target>
        </trans-unit>
        <trans-unit id="b099356ce36c80ba26fa8fbfb26af1e5b452e4c1" translate="yes" xml:space="preserve">
          <source>Emacs binds &lt;code&gt;inhibit-quit&lt;/code&gt; to &lt;code&gt;t&lt;/code&gt; before calling the timer function, because quitting out of many timer functions can leave things in an inconsistent state. This is normally unproblematical because most timer functions don&amp;rsquo;t do a lot of work. Indeed, for a timer to call a function that takes substantial time to run is likely to be annoying. If a timer function needs to allow quitting, it should use &lt;code&gt;with-local-quit&lt;/code&gt; (see &lt;a href=&quot;quitting#Quitting&quot;&gt;Quitting&lt;/a&gt;). For example, if a timer function calls &lt;code&gt;accept-process-output&lt;/code&gt; to receive output from an external process, that call should be wrapped inside &lt;code&gt;with-local-quit&lt;/code&gt;, to ensure that</source>
          <target state="translated">Emacs binds &lt;code&gt;inhibit-quit&lt;/code&gt; to &lt;code&gt;t&lt;/code&gt; before calling the timer function, because quitting out of many timer functions can leave things in an inconsistent state. This is normally unproblematical because most timer functions don&amp;rsquo;t do a lot of work. Indeed, for a timer to call a function that takes substantial time to run is likely to be annoying. If a timer function needs to allow quitting, it should use &lt;code&gt;with-local-quit&lt;/code&gt; (see &lt;a href=&quot;quitting#Quitting&quot;&gt;Quitting&lt;/a&gt;). For example, if a timer function calls &lt;code&gt;accept-process-output&lt;/code&gt; to receive output from an external process, that call should be wrapped inside &lt;code&gt;with-local-quit&lt;/code&gt; , to ensure that</target>
        </trans-unit>
        <trans-unit id="8f454504a503845ea061d18fe9395a3a052cad4b" translate="yes" xml:space="preserve">
          <source>Emacs buffers and strings support a large repertoire of characters from many different scripts, allowing users to type and display text in almost any known written language.</source>
          <target state="translated">Emacs buffers and strings support a large repertoire of characters from many different scripts, allowing users to type and display text in almost any known written language.</target>
        </trans-unit>
        <trans-unit id="cba03acb1e83d7835328c3a29d040dd5bf043a93" translate="yes" xml:space="preserve">
          <source>Emacs buffers are implemented using an invisible &lt;em&gt;gap&lt;/em&gt; to make insertion and deletion faster. Insertion works by filling in part of the gap, and deletion adds to the gap. Of course, this means that the gap must first be moved to the locus of the insertion or deletion. Emacs moves the gap only when you try to insert or delete. This is why your first editing command in one part of a large buffer, after previously editing in another far-away part, sometimes involves a noticeable delay.</source>
          <target state="translated">Emacs buffers are implemented using an invisible &lt;em&gt;gap&lt;/em&gt; to make insertion and deletion faster. Insertion works by filling in part of the gap, and deletion adds to the gap. Of course, this means that the gap must first be moved to the locus of the insertion or deletion. Emacs moves the gap only when you try to insert or delete. This is why your first editing command in one part of a large buffer, after previously editing in another far-away part, sometimes involves a noticeable delay.</target>
        </trans-unit>
        <trans-unit id="c8540d4172ad8a5276f664cef2b5ef4bc08d72c8" translate="yes" xml:space="preserve">
          <source>Emacs caches images so that it can display them again more efficiently. When Emacs displays an image, it searches the image cache for an existing image specification &lt;code&gt;equal&lt;/code&gt; to the desired specification. If a match is found, the image is displayed from the cache. Otherwise, Emacs loads the image normally.</source>
          <target state="translated">Emacs caches images so that it can display them again more efficiently. When Emacs displays an image, it searches the image cache for an existing image specification &lt;code&gt;equal&lt;/code&gt; to the desired specification. If a match is found, the image is displayed from the cache. Otherwise, Emacs loads the image normally.</target>
        </trans-unit>
        <trans-unit id="ac8f11976d61b957a0c5a1b9f2a8f7cf546ad3fc" translate="yes" xml:space="preserve">
          <source>Emacs calls this function when it loads a module. If a module does not export a function named &lt;code&gt;emacs_module_init&lt;/code&gt;, trying to load the module will signal an error. The initialization function should return zero if the initialization succeeds, non-zero otherwise. In the latter case, Emacs will signal an error, and the loading of the module will fail. If the user presses</source>
          <target state="translated">Emacs calls this function when it loads a module. If a module does not export a function named &lt;code&gt;emacs_module_init&lt;/code&gt; , trying to load the module will signal an error. The initialization function should return zero if the initialization succeeds, non-zero otherwise. In the latter case, Emacs will signal an error, and the loading of the module will fail. If the user presses</target>
        </trans-unit>
        <trans-unit id="d051a4f7d40fc5ccdbaf1d90ed27d0d62480fbe8" translate="yes" xml:space="preserve">
          <source>Emacs calls this hook immediately after it finishes applying file-local variables stored in &lt;code&gt;file-local-variables-alist&lt;/code&gt;.</source>
          <target state="translated">Emacs calls this hook immediately after it finishes applying file-local variables stored in &lt;code&gt;file-local-variables-alist&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="56083beaeb39428f247633ac12153adf7d4a8c85" translate="yes" xml:space="preserve">
          <source>Emacs calls this hook immediately before applying file-local variables stored in &lt;code&gt;file-local-variables-alist&lt;/code&gt;.</source>
          <target state="translated">Emacs calls this hook immediately before applying file-local variables stored in &lt;code&gt;file-local-variables-alist&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="994084f8ffd608b58932604d3ee3fde3154ef225" translate="yes" xml:space="preserve">
          <source>Emacs calls this low-level primitive to load a module from the specified &lt;var&gt;file&lt;/var&gt; and perform the necessary initialization of the module. This is the primitive which makes sure the module exports the &lt;code&gt;plugin_is_GPL_compatible&lt;/code&gt; symbol, calls the module&amp;rsquo;s &lt;code&gt;emacs_module_init&lt;/code&gt; function, and signals an error if that function returns an error indication, or if the use typed</source>
          <target state="translated">Emacs calls this low-level primitive to load a module from the specified &lt;var&gt;file&lt;/var&gt; and perform the necessary initialization of the module. This is the primitive which makes sure the module exports the &lt;code&gt;plugin_is_GPL_compatible&lt;/code&gt; symbol, calls the module&amp;rsquo;s &lt;code&gt;emacs_module_init&lt;/code&gt; function, and signals an error if that function returns an error indication, or if the use typed</target>
        </trans-unit>
        <trans-unit id="2fe40b51a3b73298470a39c542e0813062a24338" translate="yes" xml:space="preserve">
          <source>Emacs can also load compiled dynamic modules: shared libraries that provide additional functionality for use in Emacs Lisp programs, just like a package written in Emacs Lisp would. When a dynamic module is loaded, Emacs calls a specially-named initialization function which the module needs to implement, and which exposes the additional functions and variables to Emacs Lisp programs.</source>
          <target state="translated">Emacs can also load compiled dynamic modules: shared libraries that provide additional functionality for use in Emacs Lisp programs, just like a package written in Emacs Lisp would. When a dynamic module is loaded, Emacs calls a specially-named initialization function which the module needs to implement, and which exposes the additional functions and variables to Emacs Lisp programs.</target>
        </trans-unit>
        <trans-unit id="3d190adff472803f8e07de877cbb7a54e73c7af8" translate="yes" xml:space="preserve">
          <source>Emacs can be compiled with built-in libxml2 support.</source>
          <target state="translated">Emacs can be compiled with built-in libxml2 support.</target>
        </trans-unit>
        <trans-unit id="0d7e97dad016edbcfcb35167d07ce396bac6195d" translate="yes" xml:space="preserve">
          <source>Emacs can call this function at any time that it does redisplay or operates on menu data structures, so you should write it so it can safely be called at any time.</source>
          <target state="translated">Emacs can call this function at any time that it does redisplay or operates on menu data structures, so you should write it so it can safely be called at any time.</target>
        </trans-unit>
        <trans-unit id="da4487959604530250a24a92c5028e4b5764b43d" translate="yes" xml:space="preserve">
          <source>Emacs can communicate with serial ports. For interactive use,</source>
          <target state="translated">Emacs can communicate with serial ports. For interactive use,</target>
        </trans-unit>
        <trans-unit id="40194130dc989f8e2573473aabb240f1bb557d6d" translate="yes" xml:space="preserve">
          <source>Emacs can convert between its internal representation of a character and the character&amp;rsquo;s codepoint in a specific charset. The following two functions support these conversions.</source>
          <target state="translated">Emacs can convert between its internal representation of a character and the character&amp;rsquo;s codepoint in a specific charset. The following two functions support these conversions.</target>
        </trans-unit>
        <trans-unit id="1317571357b6546c95aaab3bc497c2a51ff101b2" translate="yes" xml:space="preserve">
          <source>Emacs can convert unibyte text to multibyte; it can also convert multibyte text to unibyte, provided that the multibyte text contains only</source>
          <target state="translated">Emacs can convert unibyte text to multibyte; it can also convert multibyte text to unibyte, provided that the multibyte text contains only</target>
        </trans-unit>
        <trans-unit id="560e70e6f372c6b3af7521a52ce8cab0bbbfe965" translate="yes" xml:space="preserve">
          <source>Emacs can copy the original file into a backup file, and then overwrite the original file with new contents. After this procedure, any other names (i.e., hard links) of the original file continue to refer to the current (updated) version of the file. The file&amp;rsquo;s owner and group will be unchanged.</source>
          <target state="translated">Emacs can copy the original file into a backup file, and then overwrite the original file with new contents. After this procedure, any other names (i.e., hard links) of the original file continue to refer to the current (updated) version of the file. The file&amp;rsquo;s owner and group will be unchanged.</target>
        </trans-unit>
        <trans-unit id="0f833cba56a479063ae8f2626b69d0324b51cffa" translate="yes" xml:space="preserve">
          <source>Emacs can create encrypted network connections, using either built-in or external support. The built-in support uses the GnuTLS Transport Layer Security Library; see &lt;a href=&quot;https://www.gnu.org/software/gnutls/&quot;&gt;the GnuTLS project page&lt;/a&gt;. If your Emacs was compiled with GnuTLS support, the function &lt;code&gt;gnutls-available-p&lt;/code&gt; is defined and returns non-&lt;code&gt;nil&lt;/code&gt;. For more details, see &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs-gnutls/index.html#Top&quot;&gt;Overview&lt;/a&gt; in</source>
          <target state="translated">Emacs can create encrypted network connections, using either built-in or external support. The built-in support uses the GnuTLS Transport Layer Security Library; see &lt;a href=&quot;https://www.gnu.org/software/gnutls/&quot;&gt;the GnuTLS project page&lt;/a&gt;. If your Emacs was compiled with GnuTLS support, the function &lt;code&gt;gnutls-available-p&lt;/code&gt; is defined and returns non- &lt;code&gt;nil&lt;/code&gt; . For more details, see &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs-gnutls/index.html#Top&quot;&gt;Overview&lt;/a&gt; in</target>
        </trans-unit>
        <trans-unit id="6be55ca6ff3d86e43d75b0ff1dc1e469e9a9cf2b" translate="yes" xml:space="preserve">
          <source>Emacs can display a number of different image formats. Some of these image formats are supported only if particular support libraries are installed. On some platforms, Emacs can load support libraries on demand; if so, the variable &lt;code&gt;dynamic-library-alist&lt;/code&gt; can be used to modify the set of known names for these dynamic libraries. See &lt;a href=&quot;dynamic-libraries#Dynamic-Libraries&quot;&gt;Dynamic Libraries&lt;/a&gt;.</source>
          <target state="translated">Emacs can display a number of different image formats. Some of these image formats are supported only if particular support libraries are installed. On some platforms, Emacs can load support libraries on demand; if so, the variable &lt;code&gt;dynamic-library-alist&lt;/code&gt; can be used to modify the set of known names for these dynamic libraries. See &lt;a href=&quot;dynamic-libraries#Dynamic-Libraries&quot;&gt;Dynamic Libraries&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="78c99b060b46e1017b43612a4ede9c782ecfe198" translate="yes" xml:space="preserve">
          <source>Emacs can display text written in scripts, such as Arabic, Farsi, and Hebrew, whose natural ordering for horizontal text display runs from right to left. Furthermore, segments of Latin script and digits embedded in right-to-left text are displayed left-to-right, while segments of right-to-left script embedded in left-to-right text (e.g., Arabic or Hebrew text in comments or strings in a program source file) are appropriately displayed right-to-left. We call such mixtures of left-to-right and right-to-left text &lt;em&gt;bidirectional text&lt;/em&gt;. This section describes the facilities and options for editing and displaying bidirectional text.</source>
          <target state="translated">Emacs can display text written in scripts, such as Arabic, Farsi, and Hebrew, whose natural ordering for horizontal text display runs from right to left. Furthermore, segments of Latin script and digits embedded in right-to-left text are displayed left-to-right, while segments of right-to-left script embedded in left-to-right text (e.g., Arabic or Hebrew text in comments or strings in a program source file) are appropriately displayed right-to-left. We call such mixtures of left-to-right and right-to-left text &lt;em&gt;bidirectional text&lt;/em&gt;. This section describes the facilities and options for editing and displaying bidirectional text.</target>
        </trans-unit>
        <trans-unit id="d60d2c50a0da2b1a3348170ffd2cb951a2fa1252" translate="yes" xml:space="preserve">
          <source>Emacs can do various things while idle: garbage collect, autosave or handle data from a subprocess. But these interludes during idleness do not interfere with idle timers, because they do not reset the clock of idleness to zero. An idle timer set for 600 seconds will run when ten minutes have elapsed since the last user command was finished, even if subprocess output has been accepted thousands of times within those ten minutes, and even if there have been garbage collections and autosaves.</source>
          <target state="translated">Emacs can do various things while idle: garbage collect, autosave or handle data from a subprocess. But these interludes during idleness do not interfere with idle timers, because they do not reset the clock of idleness to zero. An idle timer set for 600 seconds will run when ten minutes have elapsed since the last user command was finished, even if subprocess output has been accepted thousands of times within those ten minutes, and even if there have been garbage collections and autosaves.</target>
        </trans-unit>
        <trans-unit id="e9d06e075d964cd9d7cd802340a86c56af0e03e1" translate="yes" xml:space="preserve">
          <source>Emacs can indicate the buffer boundaries&amp;mdash;that is, the first and last line in the buffer&amp;mdash;with angle icons when they appear on the screen. In addition, Emacs can display an up-arrow in the fringe to show that there is text above the screen, and a down-arrow to show there is text below the screen.</source>
          <target state="translated">Emacs can indicate the buffer boundaries&amp;mdash;that is, the first and last line in the buffer&amp;mdash;with angle icons when they appear on the screen. In addition, Emacs can display an up-arrow in the fringe to show that there is text above the screen, and a down-arrow to show there is text below the screen.</target>
        </trans-unit>
        <trans-unit id="ee1ad9463e5b5996bde82c33ca18ac71261e7508" translate="yes" xml:space="preserve">
          <source>Emacs can list the names of the files in a directory as a Lisp list, or display the names in a buffer using the &lt;code&gt;ls&lt;/code&gt; shell command. In the latter case, it can optionally display information about each file, depending on the options passed to the &lt;code&gt;ls&lt;/code&gt; command.</source>
          <target state="translated">Emacs can list the names of the files in a directory as a Lisp list, or display the names in a buffer using the &lt;code&gt;ls&lt;/code&gt; shell command. In the latter case, it can optionally display information about each file, depending on the options passed to the &lt;code&gt;ls&lt;/code&gt; command.</target>
        </trans-unit>
        <trans-unit id="f742b9d1b7ebfbe69cdd55b7429ce465962460bb" translate="yes" xml:space="preserve">
          <source>Emacs can make use of scalable fonts, but by default it does not use them.</source>
          <target state="translated">Emacs can make use of scalable fonts, but by default it does not use them.</target>
        </trans-unit>
        <trans-unit id="acd5f593fd50d61539d462200b38d12727a40b86" translate="yes" xml:space="preserve">
          <source>Emacs can optionally create &lt;em&gt;lexical bindings&lt;/em&gt;. A lexical binding has &lt;em&gt;lexical scope&lt;/em&gt;, meaning that any reference to the variable must be located textually within the binding construct&lt;a href=&quot;#FOOT9&quot; name=&quot;DOCF9&quot;&gt;&lt;sup&gt;9&lt;/sup&gt;&lt;/a&gt;. It also has &lt;em&gt;indefinite extent&lt;/em&gt;, meaning that under some circumstances the binding can live on even after the binding construct has finished executing, by means of special objects called &lt;em&gt;closures&lt;/em&gt;.</source>
          <target state="translated">Emacs can optionally create &lt;em&gt;lexical bindings&lt;/em&gt;. A lexical binding has &lt;em&gt;lexical scope&lt;/em&gt;, meaning that any reference to the variable must be located textually within the binding construct&lt;a href=&quot;#FOOT9&quot; name=&quot;DOCF9&quot;&gt;&lt;sup&gt;9&lt;/sup&gt;&lt;/a&gt;. It also has &lt;em&gt;indefinite extent&lt;/em&gt;, meaning that under some circumstances the binding can live on even after the binding construct has finished executing, by means of special objects called &lt;em&gt;closures&lt;/em&gt;.</target>
        </trans-unit>
        <trans-unit id="da39689f87fe15efb9007a8a526db9cb76639bf0" translate="yes" xml:space="preserve">
          <source>Emacs can rename the original file so that it becomes a backup file, and then write the buffer being saved into a new file. After this procedure, any other names (i.e., hard links) of the original file now refer to the backup file. The new file is owned by the user doing the editing, and its group is the default for new files written by the user in that directory.</source>
          <target state="translated">Emacs can rename the original file so that it becomes a backup file, and then write the buffer being saved into a new file. After this procedure, any other names (i.e., hard links) of the original file now refer to the backup file. The new file is owned by the user doing the editing, and its group is the default for new files written by the user in that directory.</target>
        </trans-unit>
        <trans-unit id="92347b1446515a39aef2cc0d76e15aad335abd34" translate="yes" xml:space="preserve">
          <source>Emacs can revert buffers automatically. It does that by default for buffers visiting files. The following describes how to add support for auto-reverting new types of buffers.</source>
          <target state="translated">Emacs can revert buffers automatically. It does that by default for buffers visiting files. The following describes how to add support for auto-reverting new types of buffers.</target>
        </trans-unit>
        <trans-unit id="71141f928dc729ca46b6a67b62e6c7f381518108" translate="yes" xml:space="preserve">
          <source>Emacs can send commands to many other applications, and applications should take care that strings sent as operands of these commands are not misinterpreted as directives. For example, when using a shell command to rename a file &lt;var&gt;a&lt;/var&gt; to &lt;var&gt;b&lt;/var&gt;, do not simply use the string &lt;code&gt;mv &lt;var&gt;a&lt;/var&gt; &lt;var&gt;b&lt;/var&gt;&lt;/code&gt;, because either file name might start with &amp;lsquo;</source>
          <target state="translated">Emacs can send commands to many other applications, and applications should take care that strings sent as operands of these commands are not misinterpreted as directives. For example, when using a shell command to rename a file &lt;var&gt;a&lt;/var&gt; to &lt;var&gt;b&lt;/var&gt; , do not simply use the string &lt;code&gt;mv &lt;var&gt;a&lt;/var&gt; &lt;var&gt;b&lt;/var&gt;&lt;/code&gt; , because either file name might start with &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="218f4eed23a4dbb836c096575e0773d62ff23a72" translate="yes" xml:space="preserve">
          <source>Emacs can use coding systems to decode keyboard input and encode terminal output. This is useful for terminals that transmit or display text using a particular encoding, such as Latin-1. Emacs does not set &lt;code&gt;last-coding-system-used&lt;/code&gt; when encoding or decoding terminal I/O.</source>
          <target state="translated">Emacs can use coding systems to decode keyboard input and encode terminal output. This is useful for terminals that transmit or display text using a particular encoding, such as Latin-1. Emacs does not set &lt;code&gt;last-coding-system-used&lt;/code&gt; when encoding or decoding terminal I/O.</target>
        </trans-unit>
        <trans-unit id="1bb61c2a56d75a77f080b03fed07e83ed98821b1" translate="yes" xml:space="preserve">
          <source>Emacs cannot display the cursor when point is in the middle of a sequence of text that has the &lt;code&gt;display&lt;/code&gt; or &lt;code&gt;composition&lt;/code&gt; property, or is invisible. Therefore, after a command finishes and returns to the command loop, if point is within such a sequence, the command loop normally moves point to the edge of the sequence, making this sequence effectively intangible.</source>
          <target state="translated">Emacs cannot display the cursor when point is in the middle of a sequence of text that has the &lt;code&gt;display&lt;/code&gt; or &lt;code&gt;composition&lt;/code&gt; property, or is invisible. Therefore, after a command finishes and returns to the command loop, if point is within such a sequence, the command loop normally moves point to the edge of the sequence, making this sequence effectively intangible.</target>
        </trans-unit>
        <trans-unit id="d95b6dc098f282945ce76e8834176a488e9fb089" translate="yes" xml:space="preserve">
          <source>Emacs cannot run timers at any arbitrary point in a Lisp program; it can run them only when Emacs could accept output from a subprocess: namely, while waiting or inside certain primitive functions such as &lt;code&gt;sit-for&lt;/code&gt; or &lt;code&gt;read-event&lt;/code&gt; which &lt;em&gt;can&lt;/em&gt; wait. Therefore, a timer&amp;rsquo;s execution may be delayed if Emacs is busy. However, the time of execution is very precise if Emacs is idle.</source>
          <target state="translated">Emacs cannot run timers at any arbitrary point in a Lisp program; it can run them only when Emacs could accept output from a subprocess: namely, while waiting or inside certain primitive functions such as &lt;code&gt;sit-for&lt;/code&gt; or &lt;code&gt;read-event&lt;/code&gt; which &lt;em&gt;can&lt;/em&gt; wait. Therefore, a timer&amp;rsquo;s execution may be delayed if Emacs is busy. However, the time of execution is very precise if Emacs is idle.</target>
        </trans-unit>
        <trans-unit id="4eff4458427c41b7747ae4a55172d7cdb18689c2" translate="yes" xml:space="preserve">
          <source>Emacs character codes are a superset of the Unicode standard. Values 0 through &lt;code&gt;#x10FFFF&lt;/code&gt; (1114111) correspond to Unicode characters of the same codepoint; values &lt;code&gt;#x110000&lt;/code&gt; (1114112) through &lt;code&gt;#x3FFF7F&lt;/code&gt; (4194175) represent characters that are not unified with Unicode; and values &lt;code&gt;#x3FFF80&lt;/code&gt; (4194176) through &lt;code&gt;#x3FFFFF&lt;/code&gt; (4194303) represent eight-bit raw bytes.</source>
          <target state="translated">Emacs character codes are a superset of the Unicode standard. Values 0 through &lt;code&gt;#x10FFFF&lt;/code&gt; (1114111) correspond to Unicode characters of the same codepoint; values &lt;code&gt;#x110000&lt;/code&gt; (1114112) through &lt;code&gt;#x3FFF7F&lt;/code&gt; (4194175) represent characters that are not unified with Unicode; and values &lt;code&gt;#x3FFF80&lt;/code&gt; (4194176) through &lt;code&gt;#x3FFFFF&lt;/code&gt; (4194303) represent eight-bit raw bytes.</target>
        </trans-unit>
        <trans-unit id="0831640b8122043518cd95fedf37a5e6306aceac" translate="yes" xml:space="preserve">
          <source>Emacs chooses the representation for a string based on the text from which it is constructed. The general rule is to convert unibyte text to multibyte text when combining it with other multibyte text, because the multibyte representation is more general and can hold whatever characters the unibyte text has.</source>
          <target state="translated">Emacs chooses the representation for a string based on the text from which it is constructed. The general rule is to convert unibyte text to multibyte text when combining it with other multibyte text, because the multibyte representation is more general and can hold whatever characters the unibyte text has.</target>
        </trans-unit>
        <trans-unit id="f5ad25f8a992cb50da24bbff67e7ee574b817186" translate="yes" xml:space="preserve">
          <source>Emacs contains many keymaps, but at any time only a few keymaps are &lt;em&gt;active&lt;/em&gt;. When Emacs receives user input, it translates the input event (see &lt;a href=&quot;translation-keymaps#Translation-Keymaps&quot;&gt;Translation Keymaps&lt;/a&gt;), and looks for a key binding in the active keymaps.</source>
          <target state="translated">Emacs contains many keymaps, but at any time only a few keymaps are &lt;em&gt;active&lt;/em&gt;. When Emacs receives user input, it translates the input event (see &lt;a href=&quot;translation-keymaps#Translation-Keymaps&quot;&gt;Translation Keymaps&lt;/a&gt;), and looks for a key binding in the active keymaps.</target>
        </trans-unit>
        <trans-unit id="0b3d328f50bd5f37c94e899d7045b2092adf4eb5" translate="yes" xml:space="preserve">
          <source>Emacs cooperates with the window system by arranging to select frames as the server and window manager request. When a window system informs Emacs that one of its frames has been selected, Emacs internally generates a &lt;em&gt;focus-in&lt;/em&gt; event. When an Emacs frame is displayed on a text-terminal emulator, such as &lt;code&gt;xterm&lt;/code&gt;, which supports reporting of focus-change notification, the focus-in and focus-out events are available even for text-mode frames. Focus events are normally handled by &lt;code&gt;handle-focus-in&lt;/code&gt;.</source>
          <target state="translated">Emacs cooperates with the window system by arranging to select frames as the server and window manager request. When a window system informs Emacs that one of its frames has been selected, Emacs internally generates a &lt;em&gt;focus-in&lt;/em&gt; event. When an Emacs frame is displayed on a text-terminal emulator, such as &lt;code&gt;xterm&lt;/code&gt; , which supports reporting of focus-change notification, the focus-in and focus-out events are available even for text-mode frames. Focus events are normally handled by &lt;code&gt;handle-focus-in&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="decb92d5658870e3309626c9af67cdd848bae26b" translate="yes" xml:space="preserve">
          <source>Emacs creates the initial frame before it reads your init file. After reading that file, Emacs checks &lt;code&gt;initial-frame-alist&lt;/code&gt;, and applies the parameter settings in the altered value to the already created initial frame.</source>
          <target state="translated">Emacs creates the initial frame before it reads your init file. After reading that file, Emacs checks &lt;code&gt;initial-frame-alist&lt;/code&gt; , and applies the parameter settings in the altered value to the already created initial frame.</target>
        </trans-unit>
        <trans-unit id="23a93d1bd02e3ce484932a878d36df2e6d418cc6" translate="yes" xml:space="preserve">
          <source>Emacs defines four types of array, all one-dimensional: &lt;em&gt;strings&lt;/em&gt; (see &lt;a href=&quot;string-type#String-Type&quot;&gt;String Type&lt;/a&gt;), &lt;em&gt;vectors&lt;/em&gt; (see &lt;a href=&quot;vector-type#Vector-Type&quot;&gt;Vector Type&lt;/a&gt;), &lt;em&gt;bool-vectors&lt;/em&gt; (see &lt;a href=&quot;bool_002dvector-type#Bool_002dVector-Type&quot;&gt;Bool-Vector Type&lt;/a&gt;), and &lt;em&gt;char-tables&lt;/em&gt; (see &lt;a href=&quot;char_002dtable-type#Char_002dTable-Type&quot;&gt;Char-Table Type&lt;/a&gt;). Vectors and char-tables can hold elements of any type, but strings can only hold characters, and bool-vectors can only hold &lt;code&gt;t&lt;/code&gt; and &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Emacs defines four types of array, all one-dimensional: &lt;em&gt;strings&lt;/em&gt; (see &lt;a href=&quot;string-type#String-Type&quot;&gt;String Type&lt;/a&gt;), &lt;em&gt;vectors&lt;/em&gt; (see &lt;a href=&quot;vector-type#Vector-Type&quot;&gt;Vector Type&lt;/a&gt;), &lt;em&gt;bool-vectors&lt;/em&gt; (see &lt;a href=&quot;bool_002dvector-type#Bool_002dVector-Type&quot;&gt;Bool-Vector Type&lt;/a&gt;), and &lt;em&gt;char-tables&lt;/em&gt; (see &lt;a href=&quot;char_002dtable-type#Char_002dTable-Type&quot;&gt;Char-Table Type&lt;/a&gt;). Vectors and char-tables can hold elements of any type, but strings can only hold characters, and bool-vectors can only hold &lt;code&gt;t&lt;/code&gt; and &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3fb6415278ac71d7c8b8f161cc54b4109a3c312b" translate="yes" xml:space="preserve">
          <source>Emacs defines four types of array: strings, vectors, bool-vectors, and char-tables.</source>
          <target state="translated">Emacs defines four types of array: strings, vectors, bool-vectors, and char-tables.</target>
        </trans-unit>
        <trans-unit id="69b92bb4de9ad4e6aed0127a5eb28f648d0f341c" translate="yes" xml:space="preserve">
          <source>Emacs defines several special character sets. The character set &lt;code&gt;unicode&lt;/code&gt; includes all the characters whose Emacs code points are in the range &lt;code&gt;0..#x10FFFF&lt;/code&gt;. The character set &lt;code&gt;emacs&lt;/code&gt; includes all</source>
          <target state="translated">Emacs defines several special character sets. The character set &lt;code&gt;unicode&lt;/code&gt; includes all the characters whose Emacs code points are in the range &lt;code&gt;0..#x10FFFF&lt;/code&gt; . The character set &lt;code&gt;emacs&lt;/code&gt; includes all</target>
        </trans-unit>
        <trans-unit id="e38592f3457c7cc383975bc89f28f869224040ae" translate="yes" xml:space="preserve">
          <source>Emacs displays each slice as a separate image, and allows more intuitive scrolling up/down, instead of jumping up/down the entire image when paging through a buffer that displays (large) images.</source>
          <target state="translated">Emacs displays each slice as a separate image, and allows more intuitive scrolling up/down, instead of jumping up/down the entire image when paging through a buffer that displays (large) images.</target>
        </trans-unit>
        <trans-unit id="7dd49b156766b4330d659f8045f63c75d768b611" translate="yes" xml:space="preserve">
          <source>Emacs displays the cursor, by default as a rectangular block, in each window at the position of that window&amp;rsquo;s point. When the user switches to another buffer in a window, Emacs moves that window&amp;rsquo;s cursor to where point is in that buffer. If the exact position of point is hidden behind some display element, such as a display string or an image, Emacs displays the cursor immediately before or after that display element.</source>
          <target state="translated">Emacs displays the cursor, by default as a rectangular block, in each window at the position of that window&amp;rsquo;s point. When the user switches to another buffer in a window, Emacs moves that window&amp;rsquo;s cursor to where point is in that buffer. If the exact position of point is hidden behind some display element, such as a display string or an image, Emacs displays the cursor immediately before or after that display element.</target>
        </trans-unit>
        <trans-unit id="90854d4c059273c80e35dfc3fee7ae76a16735a5" translate="yes" xml:space="preserve">
          <source>Emacs displays the keyboard menu with the map&amp;rsquo;s overall prompt string, followed by the alternatives (the item strings of the map&amp;rsquo;s bindings), in the echo area. If the bindings don&amp;rsquo;t all fit at once, the user can type</source>
          <target state="translated">Emacs displays the keyboard menu with the map&amp;rsquo;s overall prompt string, followed by the alternatives (the item strings of the map&amp;rsquo;s bindings), in the echo area. If the bindings don&amp;rsquo;t all fit at once, the user can type</target>
        </trans-unit>
        <trans-unit id="8ee3e83e047b26f1bb5a4d367cc4242225a8e766" translate="yes" xml:space="preserve">
          <source>Emacs does not keep a queue of multiple reasons to call the sentinel of one process; it records just the current status and the fact that there has been a change. Therefore two changes in status, coming in quick succession, can call the sentinel just once. However, process termination will always run the sentinel exactly once. This is because the process status can&amp;rsquo;t change again after termination.</source>
          <target state="translated">Emacs does not keep a queue of multiple reasons to call the sentinel of one process; it records just the current status and the fact that there has been a change. Therefore two changes in status, coming in quick succession, can call the sentinel just once. However, process termination will always run the sentinel exactly once. This is because the process status can&amp;rsquo;t change again after termination.</target>
        </trans-unit>
        <trans-unit id="dc4de755cdb7678344be0c9f2ef7ced9da16c291" translate="yes" xml:space="preserve">
          <source>Emacs explicitly checks for an expression as shown above in your init file; your login name must appear in the expression as a Lisp string constant. You can also use the Customize interface. Other methods of setting &lt;code&gt;inhibit-startup-echo-area-message&lt;/code&gt; to the same value do not inhibit the startup message. This way, you can easily inhibit the message for yourself if you wish, but thoughtless copying of your init file will not inhibit the message for someone else.</source>
          <target state="translated">Emacs explicitly checks for an expression as shown above in your init file; your login name must appear in the expression as a Lisp string constant. You can also use the Customize interface. Other methods of setting &lt;code&gt;inhibit-startup-echo-area-message&lt;/code&gt; to the same value do not inhibit the startup message. This way, you can easily inhibit the message for yourself if you wish, but thoughtless copying of your init file will not inhibit the message for someone else.</target>
        </trans-unit>
        <trans-unit id="42f3639833a767a937f1dcec0ae3d27fe7d4f78c" translate="yes" xml:space="preserve">
          <source>Emacs explicitly checks for output from the process before running the process sentinel. Once the sentinel runs due to process termination, no further output can arrive from the process.</source>
          <target state="translated">Emacs explicitly checks for output from the process before running the process sentinel. Once the sentinel runs due to process termination, no further output can arrive from the process.</target>
        </trans-unit>
        <trans-unit id="a4e4a4a8604d8c5f44f50b7eaee3b67be7cc2ae6" translate="yes" xml:space="preserve">
          <source>Emacs functions that add a new element to a history list can also delete old elements if the list gets too long. The variable &lt;code&gt;history-length&lt;/code&gt; specifies the maximum length for most history lists. To specify a different maximum length for a particular history list, put the length in the &lt;code&gt;history-length&lt;/code&gt; property of the history list symbol. The variable &lt;code&gt;history-delete-duplicates&lt;/code&gt; specifies whether to delete duplicates in history.</source>
          <target state="translated">Emacs functions that add a new element to a history list can also delete old elements if the list gets too long. The variable &lt;code&gt;history-length&lt;/code&gt; specifies the maximum length for most history lists. To specify a different maximum length for a particular history list, put the length in the &lt;code&gt;history-length&lt;/code&gt; property of the history list symbol. The variable &lt;code&gt;history-delete-duplicates&lt;/code&gt; specifies whether to delete duplicates in history.</target>
        </trans-unit>
        <trans-unit id="4716416f00dd279f5dd607a085f5d6d79ec84a0c" translate="yes" xml:space="preserve">
          <source>Emacs guarantees that the maximum required value of &lt;code&gt;*count&lt;/code&gt; never exceeds &lt;code&gt;min (PTRDIFF_MAX, SIZE_MAX) / sizeof
(emacs_limb_t)&lt;/code&gt;, so you can use &lt;code&gt;malloc (*count * sizeof *magnitude)&lt;/code&gt; to allocate the &lt;code&gt;magnitude&lt;/code&gt; array without worrying about integer overflow in the size calculation.</source>
          <target state="translated">Emacs guarantees that the maximum required value of &lt;code&gt;*count&lt;/code&gt; never exceeds &lt;code&gt;min (PTRDIFF_MAX, SIZE_MAX) / sizeof (emacs_limb_t)&lt;/code&gt; , so you can use &lt;code&gt;malloc (*count * sizeof *magnitude)&lt;/code&gt; to allocate the &lt;code&gt;magnitude&lt;/code&gt; array without worrying about integer overflow in the size calculation.</target>
        </trans-unit>
        <trans-unit id="6b7b23ca683cca53cbcc351dc973d57c5ba2c383" translate="yes" xml:space="preserve">
          <source>Emacs has built-in support for computing &lt;em&gt;cryptographic hashes&lt;/em&gt;. A cryptographic hash, or &lt;em&gt;checksum&lt;/em&gt;, is a digital fingerprint of a piece of data (e.g., a block of text) which can be used to check that you have an unaltered copy of that data.</source>
          <target state="translated">Emacs has built-in support for computing &lt;em&gt;cryptographic hashes&lt;/em&gt;. A cryptographic hash, or &lt;em&gt;checksum&lt;/em&gt;, is a digital fingerprint of a piece of data (e.g., a block of text) which can be used to check that you have an unaltered copy of that data.</target>
        </trans-unit>
        <trans-unit id="eca0f5332e43d15251cecdd9558e33fbb26dcd5c" translate="yes" xml:space="preserve">
          <source>Emacs has built-in support for this. To begin profiling, type</source>
          <target state="translated">Emacs has built-in support for this. To begin profiling, type</target>
        </trans-unit>
        <trans-unit id="e59efddf97737e44b038590b93e7af92d497ee8e" translate="yes" xml:space="preserve">
          <source>Emacs has customization and other variables with similar considerations. For example, if the variable &lt;code&gt;shell-file-name&lt;/code&gt; specifies a shell with nonstandard behavior, an Emacs-based application may misbehave.</source>
          <target state="translated">Emacs has customization and other variables with similar considerations. For example, if the variable &lt;code&gt;shell-file-name&lt;/code&gt; specifies a shell with nonstandard behavior, an Emacs-based application may misbehave.</target>
        </trans-unit>
        <trans-unit id="d0db7329b8249a3f26dde80ed9599e46ebd35d35" translate="yes" xml:space="preserve">
          <source>Emacs has several functions that deal with passwords, e.g., &lt;code&gt;read-passwd&lt;/code&gt;. See &lt;a href=&quot;reading-a-password#Reading-a-Password&quot;&gt;Reading a Password&lt;/a&gt;. Although these functions do not attempt to broadcast passwords to the world, their implementations are not proof against determined attackers with access to Emacs internals. For example, even if Elisp code uses &lt;code&gt;clear-string&lt;/code&gt; to scrub a password from its memory after using it, remnants of the password may still reside in the garbage-collected free list. See &lt;a href=&quot;modifying-strings#Modifying-Strings&quot;&gt;Modifying Strings&lt;/a&gt;.</source>
          <target state="translated">Emacs has several functions that deal with passwords, e.g., &lt;code&gt;read-passwd&lt;/code&gt; . See &lt;a href=&quot;reading-a-password#Reading-a-Password&quot;&gt;Reading a Password&lt;/a&gt;. Although these functions do not attempt to broadcast passwords to the world, their implementations are not proof against determined attackers with access to Emacs internals. For example, even if Elisp code uses &lt;code&gt;clear-string&lt;/code&gt; to scrub a password from its memory after using it, remnants of the password may still reside in the garbage-collected free list. See &lt;a href=&quot;modifying-strings#Modifying-Strings&quot;&gt;Modifying Strings&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="2d4202fc4d0303db75d85aad9409b4fc14f3d791" translate="yes" xml:space="preserve">
          <source>Emacs ignores all face attributes from the &lt;code&gt;mouse-face&lt;/code&gt; property that alter the text size (e.g., &lt;code&gt;:height&lt;/code&gt;, &lt;code&gt;:weight&lt;/code&gt;, and &lt;code&gt;:slant&lt;/code&gt;). Those attributes are always the same as for the unhighlighted text.</source>
          <target state="translated">Emacs ignores all face attributes from the &lt;code&gt;mouse-face&lt;/code&gt; property that alter the text size (e.g., &lt;code&gt;:height&lt;/code&gt; , &lt;code&gt;:weight&lt;/code&gt; , and &lt;code&gt;:slant&lt;/code&gt; ). Those attributes are always the same as for the unhighlighted text.</target>
        </trans-unit>
        <trans-unit id="5faa39e22b5b9e6b70fa340f3f937b1c558d41df" translate="yes" xml:space="preserve">
          <source>Emacs includes a standard macro called &lt;code&gt;with-temp-buffer&lt;/code&gt; which expands into more or less the code shown above (see &lt;a href=&quot;current-buffer#Definition-of-with_002dtemp_002dbuffer&quot;&gt;Current Buffer&lt;/a&gt;). Several of the macros defined in this manual use &lt;code&gt;unwind-protect&lt;/code&gt; in this way.</source>
          <target state="translated">Emacs includes a standard macro called &lt;code&gt;with-temp-buffer&lt;/code&gt; which expands into more or less the code shown above (see &lt;a href=&quot;current-buffer#Definition-of-with_002dtemp_002dbuffer&quot;&gt;Current Buffer&lt;/a&gt;). Several of the macros defined in this manual use &lt;code&gt;unwind-protect&lt;/code&gt; in this way.</target>
        </trans-unit>
        <trans-unit id="3be04959a4a73f5846094512fe21b66b28793a3e" translate="yes" xml:space="preserve">
          <source>Emacs is able to display native widgets, such as GTK+ WebKit widgets, in Emacs buffers when it was built with the necessary support libraries and is running on a graphical terminal. To test whether Emacs supports display of embedded widgets, check that the &lt;code&gt;xwidget-internal&lt;/code&gt; feature is available (see &lt;a href=&quot;named-features#Named-Features&quot;&gt;Named Features&lt;/a&gt;).</source>
          <target state="translated">Emacs is able to display native widgets, such as GTK+ WebKit widgets, in Emacs buffers when it was built with the necessary support libraries and is running on a graphical terminal. To test whether Emacs supports display of embedded widgets, check that the &lt;code&gt;xwidget-internal&lt;/code&gt; feature is available (see &lt;a href=&quot;named-features#Named-Features&quot;&gt;Named Features&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="7fb6e43305b1bbb4090ee8b7af8d46e47a9b6d11" translate="yes" xml:space="preserve">
          <source>Emacs is able to send &lt;em&gt;notifications&lt;/em&gt; on systems that support the freedesktop.org Desktop Notifications Specification and on MS-Windows. In order to use this functionality on POSIX hosts, Emacs must have been compiled with D-Bus support, and the &lt;code&gt;notifications&lt;/code&gt; library must be loaded. See &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/dbus/index.html#Top&quot;&gt;D-Bus&lt;/a&gt; in</source>
          <target state="translated">Emacs is able to send &lt;em&gt;notifications&lt;/em&gt; on systems that support the freedesktop.org Desktop Notifications Specification and on MS-Windows. In order to use this functionality on POSIX hosts, Emacs must have been compiled with D-Bus support, and the &lt;code&gt;notifications&lt;/code&gt; library must be loaded. See &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/dbus/index.html#Top&quot;&gt;D-Bus&lt;/a&gt; in</target>
        </trans-unit>
        <trans-unit id="6c82d7724892492c38f9593a41f14fcca5af203f" translate="yes" xml:space="preserve">
          <source>Emacs is displaying the frame on a character-based terminal.</source>
          <target state="translated">Emacs is displaying the frame on a character-based terminal.</target>
        </trans-unit>
        <trans-unit id="b2182126d9b9ddba21c09d5684ccb269a6e78276" translate="yes" xml:space="preserve">
          <source>Emacs is displaying the frame using MS-DOS direct screen writes.</source>
          <target state="translated">Emacs is displaying the frame using MS-DOS direct screen writes.</target>
        </trans-unit>
        <trans-unit id="44765627efc8f89010449c0a9f3da8feaa76db08" translate="yes" xml:space="preserve">
          <source>Emacs is displaying the frame using X.</source>
          <target state="translated">Emacs is displaying the frame using X.</target>
        </trans-unit>
        <trans-unit id="a8e2a9a4a27495372ade66bfe4b5f63886de526b" translate="yes" xml:space="preserve">
          <source>Emacs is displaying the frame using native MS-Windows GUI.</source>
          <target state="translated">Emacs is displaying the frame using native MS-Windows GUI.</target>
        </trans-unit>
        <trans-unit id="b071b69063db39e82ec151d3de36f4c8c4a353c8" translate="yes" xml:space="preserve">
          <source>Emacs is displaying the frame using the Nextstep interface (used on GNUstep and macOS).</source>
          <target state="translated">Emacs is displaying the frame using the Nextstep interface (used on GNUstep and macOS).</target>
        </trans-unit>
        <trans-unit id="5afc383039e5d768bd41d71e6c4706685d7421aa" translate="yes" xml:space="preserve">
          <source>Emacs is usually able to display images when it is run on a graphical terminal. Images cannot be displayed in a text terminal, on certain graphical terminals that lack the support for this, or if Emacs is compiled without image support. You can use the function &lt;code&gt;display-images-p&lt;/code&gt; to determine if images can in principle be displayed (see &lt;a href=&quot;display-feature-testing#Display-Feature-Testing&quot;&gt;Display Feature Testing&lt;/a&gt;).</source>
          <target state="translated">Emacs is usually able to display images when it is run on a graphical terminal. Images cannot be displayed in a text terminal, on certain graphical terminals that lack the support for this, or if Emacs is compiled without image support. You can use the function &lt;code&gt;display-images-p&lt;/code&gt; to determine if images can in principle be displayed (see &lt;a href=&quot;display-feature-testing#Display-Feature-Testing&quot;&gt;Display Feature Testing&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="20d5a3e06646c394cc0872c5421edf765dc41006" translate="yes" xml:space="preserve">
          <source>Emacs keeps a flag called the &lt;em&gt;modified flag&lt;/em&gt; for each buffer, to record whether you have changed the text of the buffer. This flag is set to &lt;code&gt;t&lt;/code&gt; whenever you alter the contents of the buffer, and cleared to &lt;code&gt;nil&lt;/code&gt; when you save it. Thus, the flag shows whether there are unsaved changes. The flag value is normally shown in the mode line (see &lt;a href=&quot;mode-line-variables#Mode-Line-Variables&quot;&gt;Mode Line Variables&lt;/a&gt;), and controls saving (see &lt;a href=&quot;saving-buffers#Saving-Buffers&quot;&gt;Saving Buffers&lt;/a&gt;) and auto-saving (see &lt;a href=&quot;auto_002dsaving#Auto_002dSaving&quot;&gt;Auto-Saving&lt;/a&gt;).</source>
          <target state="translated">Emacs keeps a flag called the &lt;em&gt;modified flag&lt;/em&gt; for each buffer, to record whether you have changed the text of the buffer. This flag is set to &lt;code&gt;t&lt;/code&gt; whenever you alter the contents of the buffer, and cleared to &lt;code&gt;nil&lt;/code&gt; when you save it. Thus, the flag shows whether there are unsaved changes. The flag value is normally shown in the mode line (see &lt;a href=&quot;mode-line-variables#Mode-Line-Variables&quot;&gt;Mode Line Variables&lt;/a&gt;), and controls saving (see &lt;a href=&quot;saving-buffers#Saving-Buffers&quot;&gt;Saving Buffers&lt;/a&gt;) and auto-saving (see &lt;a href=&quot;auto_002dsaving#Auto_002dSaving&quot;&gt;Auto-Saving&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="1f6508afe4f7364bb84162c55aa6ec1f7edc81cf" translate="yes" xml:space="preserve">
          <source>Emacs keeps track of the start and end positions of the segments of text found during a search; this is called the &lt;em&gt;match data&lt;/em&gt;. Thanks to the match data, you can search for a complex pattern, such as a date in a mail message, and then extract parts of the match under control of the pattern.</source>
          <target state="translated">Emacs keeps track of the start and end positions of the segments of text found during a search; this is called the &lt;em&gt;match data&lt;/em&gt;. Thanks to the match data, you can search for a complex pattern, such as a date in a mail message, and then extract parts of the match under control of the pattern.</target>
        </trans-unit>
        <trans-unit id="0c6690bad1ceee8d9ed2098cbf0d23d2306a9b37" translate="yes" xml:space="preserve">
          <source>Emacs modifies every event it reads according to &lt;code&gt;extra-keyboard-modifiers&lt;/code&gt;, then translates it through &lt;code&gt;keyboard-translate-table&lt;/code&gt; (if applicable), before returning it from &lt;code&gt;read-event&lt;/code&gt;.</source>
          <target state="translated">Emacs modifies every event it reads according to &lt;code&gt;extra-keyboard-modifiers&lt;/code&gt; , then translates it through &lt;code&gt;keyboard-translate-table&lt;/code&gt; (if applicable), before returning it from &lt;code&gt;read-event&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="33e146ce39af7a489cb361dbc1e37c600789da32" translate="yes" xml:space="preserve">
          <source>Emacs never auto-adjusts the margins of any window after splitting or resizing it. It is the sole responsibility of any application setting this parameter to adjust the margins of this window as well as those of any new window that inherits this window&amp;rsquo;s margins due to a split. Both &lt;code&gt;window-configuration-change-hook&lt;/code&gt; and &lt;code&gt;window-size-change-functions&lt;/code&gt; (see &lt;a href=&quot;window-hooks#Window-Hooks&quot;&gt;Window Hooks&lt;/a&gt;) should be employed for this purpose.</source>
          <target state="translated">Emacs never auto-adjusts the margins of any window after splitting or resizing it. It is the sole responsibility of any application setting this parameter to adjust the margins of this window as well as those of any new window that inherits this window&amp;rsquo;s margins due to a split. Both &lt;code&gt;window-configuration-change-hook&lt;/code&gt; and &lt;code&gt;window-size-change-functions&lt;/code&gt; (see &lt;a href=&quot;window-hooks#Window-Hooks&quot;&gt;Window Hooks&lt;/a&gt;) should be employed for this purpose.</target>
        </trans-unit>
        <trans-unit id="731a5ccd4e119c3981a91156e4befc06a7253914" translate="yes" xml:space="preserve">
          <source>Emacs never reorders the text of a unibyte buffer, even if &lt;code&gt;bidi-display-reordering&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt; in the buffer. This is because unibyte buffers contain raw bytes, not characters, and thus lack the directionality properties required for reordering. Therefore, to test whether text in a buffer will be reordered for display, it is not enough to test the value of &lt;code&gt;bidi-display-reordering&lt;/code&gt; alone. The correct test is this:</source>
          <target state="translated">Emacs never reorders the text of a unibyte buffer, even if &lt;code&gt;bidi-display-reordering&lt;/code&gt; is non- &lt;code&gt;nil&lt;/code&gt; in the buffer. This is because unibyte buffers contain raw bytes, not characters, and thus lack the directionality properties required for reordering. Therefore, to test whether text in a buffer will be reordered for display, it is not enough to test the value of &lt;code&gt;bidi-display-reordering&lt;/code&gt; alone. The correct test is this:</target>
        </trans-unit>
        <trans-unit id="4d8a849bf06a7f6bc35485cd61775d653a4c2cd3" translate="yes" xml:space="preserve">
          <source>Emacs normally displays an error message when an error is signaled and not handled with &lt;code&gt;condition-case&lt;/code&gt;. While Edebug is active and executing instrumented code, it normally responds to all unhandled errors. You can customize this with the options &lt;code&gt;edebug-on-error&lt;/code&gt; and &lt;code&gt;edebug-on-quit&lt;/code&gt;; see &lt;a href=&quot;edebug-options#Edebug-Options&quot;&gt;Edebug Options&lt;/a&gt;.</source>
          <target state="translated">Emacs normally displays an error message when an error is signaled and not handled with &lt;code&gt;condition-case&lt;/code&gt; . While Edebug is active and executing instrumented code, it normally responds to all unhandled errors. You can customize this with the options &lt;code&gt;edebug-on-error&lt;/code&gt; and &lt;code&gt;edebug-on-quit&lt;/code&gt; ; see &lt;a href=&quot;edebug-options#Edebug-Options&quot;&gt;Edebug Options&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="b6da4556a5726903beca496cf1774233562b267a" translate="yes" xml:space="preserve">
          <source>Emacs normally tries to redisplay the screen whenever it waits for input. With the following function, you can request an immediate attempt to redisplay, in the middle of Lisp code, without actually waiting for input.</source>
          <target state="translated">Emacs normally tries to redisplay the screen whenever it waits for input. With the following function, you can request an immediate attempt to redisplay, in the middle of Lisp code, without actually waiting for input.</target>
        </trans-unit>
        <trans-unit id="b3b77106c4f5fd19224cba19e42352426a30909e" translate="yes" xml:space="preserve">
          <source>Emacs notification</source>
          <target state="translated">Emacs notification</target>
        </trans-unit>
        <trans-unit id="0d1349dea05c4f3f5117321a3ea3fe785f781605" translate="yes" xml:space="preserve">
          <source>Emacs often accesses the network, and you may want to configure it to avoid network accesses that it would normally do. For example, unless you set &lt;code&gt;tramp-mode&lt;/code&gt; to &lt;code&gt;nil&lt;/code&gt;, file names using a certain syntax are interpreted as being network files, and are retrieved across the network. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/tramp/index.html#Top&quot;&gt;The Tramp Manual&lt;/a&gt; in</source>
          <target state="translated">Emacs often accesses the network, and you may want to configure it to avoid network accesses that it would normally do. For example, unless you set &lt;code&gt;tramp-mode&lt;/code&gt; to &lt;code&gt;nil&lt;/code&gt; , file names using a certain syntax are interpreted as being network files, and are retrieved across the network. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/tramp/index.html#Top&quot;&gt;The Tramp Manual&lt;/a&gt; in</target>
        </trans-unit>
        <trans-unit id="f28e36da35b0898ac321f9cb68d8a14bca74d8ce" translate="yes" xml:space="preserve">
          <source>Emacs often accesses the network, and you may want to configure it to avoid network accesses that it would normally do. For example, unless you set &lt;code&gt;tramp-mode&lt;/code&gt; to &lt;code&gt;nil&lt;/code&gt;, file names using a certain syntax are interpreted as being network files, and are retrieved across the network. See &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/tramp/index.html#Top&quot;&gt;The Tramp Manual&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="581d858cf52872c9ad790c13ebef480b2798de3d" translate="yes" xml:space="preserve">
          <source>Emacs performs several steps to convert the data in a buffer (text, text properties, and possibly other information) to and from a representation suitable for storing into a file. This section describes the fundamental functions that perform this &lt;em&gt;format conversion&lt;/em&gt;, namely &lt;code&gt;insert-file-contents&lt;/code&gt; for reading a file into a buffer, and &lt;code&gt;write-region&lt;/code&gt; for writing a buffer into a file.</source>
          <target state="translated">Emacs performs several steps to convert the data in a buffer (text, text properties, and possibly other information) to and from a representation suitable for storing into a file. This section describes the fundamental functions that perform this &lt;em&gt;format conversion&lt;/em&gt;, namely &lt;code&gt;insert-file-contents&lt;/code&gt; for reading a file into a buffer, and &lt;code&gt;write-region&lt;/code&gt; for writing a buffer into a file.</target>
        </trans-unit>
        <trans-unit id="7ea6c4b1c250da2cff334a5b4482f568269fcc53" translate="yes" xml:space="preserve">
          <source>Emacs periodically saves all files that you are visiting; this is called &lt;em&gt;auto-saving&lt;/em&gt;. Auto-saving prevents you from losing more than a limited amount of work if the system crashes. By default, auto-saves happen every 300 keystrokes, or after around 30 seconds of idle time. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Auto-Save.html#Auto-Save&quot;&gt;Auto-Saving: Protection Against Disasters&lt;/a&gt; in</source>
          <target state="translated">Emacs periodically saves all files that you are visiting; this is called &lt;em&gt;auto-saving&lt;/em&gt;. Auto-saving prevents you from losing more than a limited amount of work if the system crashes. By default, auto-saves happen every 300 keystrokes, or after around 30 seconds of idle time. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Auto-Save.html#Auto-Save&quot;&gt;Auto-Saving: Protection Against Disasters&lt;/a&gt; in</target>
        </trans-unit>
        <trans-unit id="b0b9c6f31488f83183798bedef49f3e9859cb9fa" translate="yes" xml:space="preserve">
          <source>Emacs periodically saves all files that you are visiting; this is called &lt;em&gt;auto-saving&lt;/em&gt;. Auto-saving prevents you from losing more than a limited amount of work if the system crashes. By default, auto-saves happen every 300 keystrokes, or after around 30 seconds of idle time. See &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/Auto-Save.html#Auto-Save&quot;&gt;Auto-Saving: Protection Against Disasters&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df11fc994e2c3039bdad35c40cb0169c3b1f9d1d" translate="yes" xml:space="preserve">
          <source>Emacs provides a primitive that applications can use to detect instances of text whose bidirectional properties were overridden so as to make a left-to-right character display as if it were a right-to-left character, or vise versa.</source>
          <target state="translated">Emacs provides a primitive that applications can use to detect instances of text whose bidirectional properties were overridden so as to make a left-to-right character display as if it were a right-to-left character, or vise versa.</target>
        </trans-unit>
        <trans-unit id="61baf7ab83dc2d8df21e9d0bdf661236de4fd609" translate="yes" xml:space="preserve">
          <source>Emacs provides a standard way to distribute Emacs Lisp code to users. A &lt;em&gt;package&lt;/em&gt; is a collection of one or more files, formatted and bundled in such a way that users can easily download, install, uninstall, and upgrade it.</source>
          <target state="translated">Emacs provides a standard way to distribute Emacs Lisp code to users. A &lt;em&gt;package&lt;/em&gt; is a collection of one or more files, formatted and bundled in such a way that users can easily download, install, uninstall, and upgrade it.</target>
        </trans-unit>
        <trans-unit id="8ada8068790b12baa9e1062244390495c315ecb6" translate="yes" xml:space="preserve">
          <source>Emacs provides a variety of built-in help functions, all accessible to the user as subcommands of the prefix</source>
          <target state="translated">Emacs provides a variety of built-in help functions, all accessible to the user as subcommands of the prefix</target>
        </trans-unit>
        <trans-unit id="43fb2f0b6d17066c5bd67b780eb98dc2c0cc5b60" translate="yes" xml:space="preserve">
          <source>Emacs provides access to variables in the operating system environment through various functions. These variables include the name of the system, the user&amp;rsquo;s</source>
          <target state="translated">Emacs provides access to variables in the operating system environment through various functions. These variables include the name of the system, the user&amp;rsquo;s</target>
        </trans-unit>
        <trans-unit id="1d40bc6da91c5927b0dc8f18ad6ea9527ed5df47" translate="yes" xml:space="preserve">
          <source>Emacs provides another facility for such modes: you can quickly swap buffer text between two buffers with &lt;code&gt;buffer-swap-text&lt;/code&gt;. This function is very fast because it doesn&amp;rsquo;t move any text, it only changes the internal data structures of the buffer object to point to a different chunk of text. Using it, you can pretend that a group of two or more buffers are actually a single virtual buffer that holds the contents of all the individual buffers together.</source>
          <target state="translated">Emacs provides another facility for such modes: you can quickly swap buffer text between two buffers with &lt;code&gt;buffer-swap-text&lt;/code&gt; . This function is very fast because it doesn&amp;rsquo;t move any text, it only changes the internal data structures of the buffer object to point to a different chunk of text. Using it, you can pretend that a group of two or more buffers are actually a single virtual buffer that holds the contents of all the individual buffers together.</target>
        </trans-unit>
        <trans-unit id="e9aaccb8205c4eac21637c315bcf99abffe5c37c" translate="yes" xml:space="preserve">
          <source>Emacs provides miscellaneous functions for finding the height and width of a window. The return value of many of these functions can be specified either in units of pixels or in units of lines and columns. On a graphical display, the latter actually correspond to the height and width of a default character specified by the frame&amp;rsquo;s default font as returned by &lt;code&gt;frame-char-height&lt;/code&gt; and &lt;code&gt;frame-char-width&lt;/code&gt; (see &lt;a href=&quot;frame-font#Frame-Font&quot;&gt;Frame Font&lt;/a&gt;). Thus, if a window is displaying text with a different font or size, the reported line height and column width for that window may differ from the actual number of text lines or columns displayed within it.</source>
          <target state="translated">Emacs provides miscellaneous functions for finding the height and width of a window. The return value of many of these functions can be specified either in units of pixels or in units of lines and columns. On a graphical display, the latter actually correspond to the height and width of a default character specified by the frame&amp;rsquo;s default font as returned by &lt;code&gt;frame-char-height&lt;/code&gt; and &lt;code&gt;frame-char-width&lt;/code&gt; (see &lt;a href=&quot;frame-font#Frame-Font&quot;&gt;Frame Font&lt;/a&gt;). Thus, if a window is displaying text with a different font or size, the reported line height and column width for that window may differ from the actual number of text lines or columns displayed within it.</target>
        </trans-unit>
        <trans-unit id="b1632c6565185e45338eacdf43142cda2977a1ea" translate="yes" xml:space="preserve">
          <source>Emacs provides several functions and primitives that return time, both elapsed and processor time, used by the Emacs process.</source>
          <target state="translated">Emacs provides several functions and primitives that return time, both elapsed and processor time, used by the Emacs process.</target>
        </trans-unit>
        <trans-unit id="d46d6363e5a83deb2eb9ea6abf1be5990c469397" translate="yes" xml:space="preserve">
          <source>Emacs provides several primitives for accessing system processes. Not all platforms support these primitives; on those which don&amp;rsquo;t, these primitives return &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Emacs provides several primitives for accessing system processes. Not all platforms support these primitives; on those which don&amp;rsquo;t, these primitives return &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5dd098d236b6bd1b23e380080511f9e6289ec9ef" translate="yes" xml:space="preserve">
          <source>Emacs provides support for polymorphism. Like other Lisp environments, notably Common Lisp and its Common Lisp Object System (</source>
          <target state="translated">Emacs provides support for polymorphism. Like other Lisp environments, notably Common Lisp and its Common Lisp Object System (</target>
        </trans-unit>
        <trans-unit id="7e45b2565d3c6a45ec4a8ebbbda4c0e8bb3d845c" translate="yes" xml:space="preserve">
          <source>Emacs reads the file &lt;var&gt;filename&lt;/var&gt; from the</source>
          <target state="translated">Emacs reads the file &lt;var&gt;filename&lt;/var&gt; from the</target>
        </trans-unit>
        <trans-unit id="fa5f4104a9e9a2467fbc95628bbe7588c1e30307" translate="yes" xml:space="preserve">
          <source>Emacs redisplays only when it pauses. Usually, when you continue execution, the program re-enters Edebug at a breakpoint or after stepping, without pausing or reading input in between. In such cases, Emacs never gets a chance to redisplay the outside configuration. Consequently, what you see is the same window configuration as the last time Edebug was active, with no interruption.</source>
          <target state="translated">Emacs redisplays only when it pauses. Usually, when you continue execution, the program re-enters Edebug at a breakpoint or after stepping, without pausing or reading input in between. In such cases, Emacs never gets a chance to redisplay the outside configuration. Consequently, what you see is the same window configuration as the last time Edebug was active, with no interruption.</target>
        </trans-unit>
        <trans-unit id="f46dd8612b39986c03b492b88b8edc942b92aa81" translate="yes" xml:space="preserve">
          <source>Emacs represents each terminal as a &lt;em&gt;terminal object&lt;/em&gt; data type (see &lt;a href=&quot;terminal-type#Terminal-Type&quot;&gt;Terminal Type&lt;/a&gt;). On GNU and Unix systems, Emacs can use multiple terminals simultaneously in each session. On other systems, it can only use a single terminal. Each terminal object has the following attributes:</source>
          <target state="translated">Emacs represents each terminal as a &lt;em&gt;terminal object&lt;/em&gt; data type (see &lt;a href=&quot;terminal-type#Terminal-Type&quot;&gt;Terminal Type&lt;/a&gt;). On GNU and Unix systems, Emacs can use multiple terminals simultaneously in each session. On other systems, it can only use a single terminal. Each terminal object has the following attributes:</target>
        </trans-unit>
        <trans-unit id="aa45d2f9f0d5f594df92c4785fdb9ba7d0be0018" translate="yes" xml:space="preserve">
          <source>Emacs signals an error if &lt;var&gt;key&lt;/var&gt; is not a string or a vector.</source>
          <target state="translated">Emacs signals an error if &lt;var&gt;key&lt;/var&gt; is not a string or a vector.</target>
        </trans-unit>
        <trans-unit id="5a189e87eddfeb2b6f9c9a05136525e5f7f54d44" translate="yes" xml:space="preserve">
          <source>Emacs sometimes generates &lt;em&gt;mouse motion&lt;/em&gt; events to describe motion of the mouse without any button activity. Mouse motion events are represented by lists that look like this:</source>
          <target state="translated">Emacs는 때때로 버튼 동작없이 &lt;em&gt;마우스 동작&lt;/em&gt; 을 설명하기 위해 &lt;em&gt;마우스 동작&lt;/em&gt; 이벤트를 생성 합니다. 마우스 모션 이벤트는 다음과 같은 목록으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="8cea986d9dde8997ae558d2415d06c4c0c311a90" translate="yes" xml:space="preserve">
          <source>Emacs stores the overlays of each buffer in two lists, divided around an arbitrary center position. One list extends backwards through the buffer from that center position, and the other extends forwards from that center position. The center position can be anywhere in the buffer.</source>
          <target state="translated">Emacs는 각 버퍼의 오버레이를 임의의 중앙 위치를 기준으로 나누어 진 두 개의 목록에 저장합니다. 한 목록은 해당 중앙 위치에서 버퍼를 통해 뒤로 확장되고 다른 목록은 해당 중앙 위치에서 앞으로 확장됩니다. 중앙 위치는 버퍼의 어느 위치 에나있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad62c31e598a9d1f29a369781541a612009842a4" translate="yes" xml:space="preserve">
          <source>Emacs supplies two predefined values for this variable: &lt;code&gt;window-adjust-process-window-size-smallest&lt;/code&gt;, which returns the smallest of all the dimensions of the windows that display a process&amp;rsquo;s buffer; and &lt;code&gt;window-adjust-process-window-size-largest&lt;/code&gt;, which returns the largest dimensions. For more complex strategies, write your own function.</source>
          <target state="translated">Emacs는이 변수에 대해 두 가지 미리 정의 된 값을 제공합니다. &lt;code&gt;window-adjust-process-window-size-smallest&lt;/code&gt; 는 프로세스의 버퍼를 표시하는 모든 창의 크기 중 가장 작은 값 을 반환합니다. 그리고 가장 큰 차원을 반환하는 &lt;code&gt;window-adjust-process-window-size-largest&lt;/code&gt; 입니다. 더 복잡한 전략의 경우 자체 함수를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="61355fb31d5f838a8163a1a0717a06fbd8117c67" translate="yes" xml:space="preserve">
          <source>Emacs supports four kinds of mouse events: click events, drag events, button-down events, and motion events. All mouse events are represented as lists. The &lt;small&gt;CAR&lt;/small&gt; of the list is the event type; this says which mouse button was involved, and which modifier keys were used with it. The event type can also distinguish double or triple button presses (see &lt;a href=&quot;repeat-events#Repeat-Events&quot;&gt;Repeat Events&lt;/a&gt;). The rest of the list elements give position and time information.</source>
          <target state="translated">Emacs는 클릭 이벤트, 드래그 이벤트, 버튼 다운 이벤트 및 모션 이벤트의 네 가지 종류의 마우스 이벤트를 지원합니다. 모든 마우스 이벤트는 목록으로 표시됩니다. 목록 의 &lt;small&gt;CAR&lt;/small&gt; 은 이벤트 유형입니다. 이것은 어떤 마우스 버튼이 관련되었고 어떤 수정 키가 그것과 함께 사용되었는지를 나타냅니다. 이벤트 유형은 또한 두 번 또는 세 번 버튼 누름을 구분할 수 있습니다 ( &lt;a href=&quot;repeat-events#Repeat-Events&quot;&gt;이벤트 반복&lt;/a&gt; 참조 ). 나머지 목록 요소는 위치 및 시간 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6218bcff746da87fbb66fbec9ddb8a018bc5f549" translate="yes" xml:space="preserve">
          <source>Emacs supports saving state via a hook called &lt;code&gt;emacs-save-session-functions&lt;/code&gt;. Emacs runs this hook when the session manager tells it that the window system is shutting down. The functions are called with no arguments, and with the current buffer set to a temporary buffer. Each function can use &lt;code&gt;insert&lt;/code&gt; to add Lisp code to this buffer. At the end, Emacs saves the buffer in a file, called the &lt;em&gt;session file&lt;/em&gt;.</source>
          <target state="translated">Emacs는 &lt;code&gt;emacs-save-session-functions&lt;/code&gt; 라는 후크를 통해 상태 저장을 지원 합니다 . Emacs는 세션 관리자가 윈도우 시스템이 종료되고 있다고 알려줄 때이 후크를 실행합니다. 함수는 인수없이 호출되며 현재 버퍼는 임시 버퍼로 설정됩니다. 각 함수는 &lt;code&gt;insert&lt;/code&gt; 을 사용 하여이 버퍼에 Lisp 코드를 추가 할 수 있습니다 . 마지막으로 Emacs는 &lt;em&gt;세션 파일&lt;/em&gt; 이라는 파일에 버퍼를 저장 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="1ffa17ed9364f5575c0082d461c8f0e3489ecac2" translate="yes" xml:space="preserve">
          <source>Emacs supports several comment styles simultaneously in any one syntax table. A comment style is a set of flags &amp;lsquo;</source>
          <target state="translated">Emacs는 하나의 구문 테이블에서 동시에 여러 주석 스타일을 지원합니다. 주석 스타일은 플래그 '</target>
        </trans-unit>
        <trans-unit id="374f9fc9c7b543e09273805eabd95e1a26d66453" translate="yes" xml:space="preserve">
          <source>Emacs supports several common cryptographic hash algorithms: MD5, SHA-1, SHA-2, SHA-224, SHA-256, SHA-384 and SHA-512. MD5 is the oldest of these algorithms, and is commonly used in &lt;em&gt;message digests&lt;/em&gt; to check the integrity of messages transmitted over a network. MD5 and SHA-1 are not collision resistant (i.e., it is possible to deliberately design different pieces of data which have the same MD5 or SHA-1 hash), so you should not use them for anything security-related. For security-related applications you should use the other hash types, such as SHA-2 (e.g. &lt;code&gt;sha256&lt;/code&gt; or &lt;code&gt;sha512&lt;/code&gt;).</source>
          <target state="translated">Emacs는 MD5, SHA-1, SHA-2, SHA-224, SHA-256, SHA-384 및 SHA-512와 같은 몇 가지 일반적인 암호화 해시 알고리즘을 지원합니다. MD5는 이러한 알고리즘 중 가장 오래된 알고리즘이며 일반적으로 &lt;em&gt;메시지 다이제스트&lt;/em&gt; 에서 네트워크를 통해 전송되는 메시지의 무결성을 확인하는 데 사용됩니다 . MD5 및 SHA-1은 충돌 방지 기능이 없으므로 (즉, 동일한 MD5 또는 SHA-1 해시를 가진 다른 데이터 조각을 의도적으로 디자인 할 수 있습니다), 따라서 보안과 관련된 모든 것에 사용해서는 안됩니다. 보안 관련 애플리케이션의 경우 SHA-2 (예 : &lt;code&gt;sha256&lt;/code&gt; 또는 &lt;code&gt;sha512&lt;/code&gt; ) 와 같은 다른 해시 유형을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b7e49d60042c70b0537fcee92a3c84a52f433f6c" translate="yes" xml:space="preserve">
          <source>Emacs supports the X Session Management Protocol, which is used to suspend and restart applications. In the X Window System, a program called the &lt;em&gt;session manager&lt;/em&gt; is responsible for keeping track of the applications that are running. When the X server shuts down, the session manager asks applications to save their state, and delays the actual shutdown until they respond. An application can also cancel the shutdown.</source>
          <target state="translated">Emacs는 응용 프로그램을 일시 중지하고 다시 시작하는 데 사용되는 X 세션 관리 프로토콜을 지원합니다. X 윈도우 시스템에서 &lt;em&gt;세션 관리자&lt;/em&gt; 라는 프로그램 은 실행중인 응용 프로그램을 추적합니다. X 서버가 종료되면 세션 관리자는 애플리케이션에 상태를 저장하도록 요청하고 응답 할 때까지 실제 종료를 지연합니다. 응용 프로그램은 종료를 취소 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="89f5a42afa1af03f9d3097e4024bf58ff39a6001" translate="yes" xml:space="preserve">
          <source>Emacs then searches every Lisp file in the content directory for autoload magic comments (see &lt;a href=&quot;autoload#Autoload&quot;&gt;Autoload&lt;/a&gt;). These autoload definitions are saved to a file named</source>
          <target state="translated">그런 다음 Emacs는 콘텐츠 디렉토리의 모든 Lisp 파일에서 자동로드 매직 주석을 검색합니다 ( &lt;a href=&quot;autoload#Autoload&quot;&gt;Autoload&lt;/a&gt; 참조 ). 이러한 자동로드 정의는 다음과 같은 파일에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="642da26f6d818f57222aa0ba6201c9a5f8e43253" translate="yes" xml:space="preserve">
          <source>Emacs tries to load the library from the files in the order they appear in the list; if none is found, the Emacs session won&amp;rsquo;t have access to that library, and the features it provides will be unavailable.</source>
          <target state="translated">Emacs는 목록에 나타나는 순서대로 파일에서 라이브러리를로드하려고합니다. 아무것도 발견되지 않으면 Emacs 세션은 해당 라이브러리에 액세스 할 수 없으며 제공하는 기능을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6ec424687522d88149cabb8e9ff0c17e4a8a1445" translate="yes" xml:space="preserve">
          <source>Emacs uses the word &amp;ldquo;window&amp;rdquo; with a different meaning than in graphical desktop environments and window systems, such as the X Window System. When Emacs is run on X, each of its graphical X windows is an Emacs frame (containing one or more Emacs windows). When Emacs is run on a text terminal, the frame fills the entire terminal screen.</source>
          <target state="translated">Emacs는 그래픽 데스크탑 환경 및 X 윈도우 시스템과 같은 윈도우 시스템 에서와는 다른 의미로 &quot;창&quot;이라는 단어를 사용합니다. Emacs가 X에서 실행될 때 각 그래픽 X 창은 Emacs 프레임 (하나 이상의 Emacs 창 포함)입니다. Emacs가 텍스트 터미널에서 실행될 때 프레임은 전체 터미널 화면을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="6739d8fc92b7ea45c67f23811c8b9230bc3d4cae" translate="yes" xml:space="preserve">
          <source>Emacs uses this function internally when it loads directory variables from a &lt;code&gt;.dir-locals.el&lt;/code&gt; file. In that case, the optional argument &lt;var&gt;mtime&lt;/var&gt; holds the file modification time (as returned by &lt;code&gt;file-attributes&lt;/code&gt;). Emacs uses this time to check stored local variables are still valid. If you are assigning a class directly, not via a file, this argument should be &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Emacs는 &lt;code&gt;.dir-locals.el&lt;/code&gt; 파일 에서 디렉토리 변수를로드 할 때 내부적으로이 함수를 사용 합니다. 이 경우 선택적 인수 &lt;var&gt;mtime&lt;/var&gt; 은 파일 수정 시간 ( &lt;code&gt;file-attributes&lt;/code&gt; 에서 반환 됨)을 보유합니다 . Emacs는이 시간을 사용하여 저장된 지역 변수가 여전히 유효한지 확인합니다. 파일을 통하지 않고 직접 클래스를 할당하는 경우이 인수는 &lt;code&gt;nil&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="8a5eb29ea0683f15f88a024cecd03f16a4045817" translate="yes" xml:space="preserve">
          <source>Emacs uses two variables to store the prefix argument: &lt;code&gt;prefix-arg&lt;/code&gt; and &lt;code&gt;current-prefix-arg&lt;/code&gt;. Commands such as &lt;code&gt;universal-argument&lt;/code&gt; that set up prefix arguments for other commands store them in &lt;code&gt;prefix-arg&lt;/code&gt;. In contrast, &lt;code&gt;current-prefix-arg&lt;/code&gt; conveys the prefix argument to the current command, so setting it has no effect on the prefix arguments for future commands.</source>
          <target state="translated">Emacs는 &lt;code&gt;prefix-arg&lt;/code&gt; 및 &lt;code&gt;current-prefix-arg&lt;/code&gt; 두 가지 변수를 사용하여 접두사 인수를 저장합니다 . 다른 명령에 대한 접두사 인수를 설정하는 &lt;code&gt;universal-argument&lt;/code&gt; 와 같은 명령은이를 &lt;code&gt;prefix-arg&lt;/code&gt; 에 저장합니다 . 반대로 &lt;code&gt;current-prefix-arg&lt;/code&gt; 는 접두사 인수를 현재 명령으로 전달하므로 설정하면 향후 명령의 접두사 인수에 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8322177991ff5a69ef8d70459eeede0c94874d69" translate="yes" xml:space="preserve">
          <source>Emacs usually shows a &lt;em&gt;menu bar&lt;/em&gt; at the top of each frame. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Menu-Bars.html#Menu-Bars&quot;&gt;Menu Bars&lt;/a&gt; in</source>
          <target state="translated">Emacs는 일반적으로 각 프레임의 상단에 &lt;em&gt;메뉴 막대&lt;/em&gt; 를 &lt;em&gt;표시합니다&lt;/em&gt; . 참조 &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Menu-Bars.html#Menu-Bars&quot;&gt;메뉴 바&lt;/a&gt; 에서</target>
        </trans-unit>
        <trans-unit id="e20a8acad14546f712103458a94a51e9b75b1006" translate="yes" xml:space="preserve">
          <source>Emacs usually shows a &lt;em&gt;menu bar&lt;/em&gt; at the top of each frame. See &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/Menu-Bars.html#Menu-Bars&quot;&gt;Menu Bars&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0558f3f8ca5ebcf9982d4420378522febddf9f12" translate="yes" xml:space="preserve">
          <source>Emacs versions before Emacs 22 did not have &lt;code&gt;delay-mode-hooks&lt;/code&gt;. Versions before 24 did not have &lt;code&gt;change-major-mode-after-body-hook&lt;/code&gt;. When user-implemented major modes do not use &lt;code&gt;run-mode-hooks&lt;/code&gt; and have not been updated to use these newer features, they won&amp;rsquo;t entirely follow these conventions: they may run the parent&amp;rsquo;s mode hook too early, or fail to run &lt;code&gt;after-change-major-mode-hook&lt;/code&gt;. If you encounter such a major mode, please correct it to follow these conventions.</source>
          <target state="translated">Emacs 22 이전의 Emacs 버전에는 &lt;code&gt;delay-mode-hooks&lt;/code&gt; 가 없었습니다 . 24 이전 버전에는 &lt;code&gt;change-major-mode-after-body-hook&lt;/code&gt; 이 없습니다 . 사용자가 구현 한 주요 모드가 &lt;code&gt;run-mode-hooks&lt;/code&gt; 를 사용하지 않고 이러한 새로운 기능을 사용하도록 업데이트되지 않은 경우 이러한 규칙을 완전히 따르지 않습니다. 부모의 모드 후크를 너무 일찍 실행하거나 &lt;code&gt;after-change-major-mode-hook&lt;/code&gt; 실행하지 못할 수 있습니다 . change-major-mode-hook . 이러한 주요 모드가 발생하면 이러한 규칙을 따르도록 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="2175b4ca0a4ab5a7e1e6f75b7a977f193cc85367" translate="yes" xml:space="preserve">
          <source>Emacs will fail to decode</source>
          <target state="translated">Emacs는 디코딩에 실패합니다</target>
        </trans-unit>
        <trans-unit id="d4d48520a4e7157f1ff4ee50b46e94eaf663e2aa" translate="yes" xml:space="preserve">
          <source>Emacs will try to keep the position ratios of a child frame unaltered if that frame has a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;keep-ratio&lt;/code&gt; parameter (see &lt;a href=&quot;frame-interaction-parameters#Frame-Interaction-Parameters&quot;&gt;Frame Interaction Parameters&lt;/a&gt;) and its parent frame is resized.</source>
          <target state="translated">Emacs는 해당 프레임에 &lt;code&gt;nil&lt;/code&gt; 이 아닌 &lt;code&gt;keep-ratio&lt;/code&gt; 매개 변수 가 있고 ( &lt;a href=&quot;frame-interaction-parameters#Frame-Interaction-Parameters&quot;&gt;프레임 상호 작용 매개 변수&lt;/a&gt; 참조 ) 상위 프레임의 크기가 조정 된 경우 하위 프레임의 위치 비율을 변경하지 않고 유지하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="b154a9be9b6bdf586b186816066bb36a405e4a4a" translate="yes" xml:space="preserve">
          <source>Emacs will try to keep the width and height ratio of a child frame unaltered if that frame has a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;keep-ratio&lt;/code&gt; parameter (see &lt;a href=&quot;frame-interaction-parameters#Frame-Interaction-Parameters&quot;&gt;Frame Interaction Parameters&lt;/a&gt;) and its parent frame is resized.</source>
          <target state="translated">Emacs는 해당 프레임에 &lt;code&gt;nil&lt;/code&gt; 이 아닌 &lt;code&gt;keep-ratio&lt;/code&gt; 매개 변수 가 있고 ( &lt;a href=&quot;frame-interaction-parameters#Frame-Interaction-Parameters&quot;&gt;프레임 상호 작용 매개 변수&lt;/a&gt; 참조 ) 상위 프레임의 크기가 조정 된 경우 하위 프레임의 너비와 높이 비율을 변경하지 않고 유지하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="8f2ef7c37339106b409b42bf4c03ccef1510f3a8" translate="yes" xml:space="preserve">
          <source>Emacs works with several window systems, most notably the X Window System. Both Emacs and X use the term &amp;ldquo;window&amp;rdquo;, but use it differently. An Emacs frame is a single window as far as X is concerned; the individual Emacs windows are not known to X at all.</source>
          <target state="translated">Emacs는 여러 윈도우 시스템, 특히 X 윈도우 시스템에서 작동합니다. Emacs와 X는 모두&amp;ldquo;창&amp;rdquo;이라는 용어를 사용하지만 다르게 사용합니다. Emacs 프레임은 X에 관한 한 단일 창입니다. 개별 Emacs 창은 X에 전혀 알려지지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="3e023f4f3837dfad4265ed79f1fcd67f57a3591f" translate="yes" xml:space="preserve">
          <source>Emacs&amp;rsquo;s Widget for Object Collections.</source>
          <target state="translated">객체 컬렉션을위한 Emacs의 위젯.</target>
        </trans-unit>
        <trans-unit id="259a61bf42871d8fc1aec61faab84f39ed26f1e8" translate="yes" xml:space="preserve">
          <source>Emacs&amp;rsquo;s advice system provides two sets of primitives for that: the core set, for function values held in variables and object fields (with the corresponding primitives being &lt;code&gt;add-function&lt;/code&gt; and &lt;code&gt;remove-function&lt;/code&gt;) and another set layered on top of it for named functions (with the main primitives being &lt;code&gt;advice-add&lt;/code&gt; and &lt;code&gt;advice-remove&lt;/code&gt;).</source>
          <target state="translated">Emacs의 어드바이스 시스템은이를 위해 두 가지 기본 집합을 제공합니다. 즉, 변수 및 개체 필드에있는 함수 값에 대한 코어 집합 (해당 기본 요소는 &lt;code&gt;add-function&lt;/code&gt; 및 &lt;code&gt;remove-function&lt;/code&gt; )과 그 위에 계층화 된 또 다른 집합은 명명 된 함수 ( 주요 기본 요소는 &lt;code&gt;advice-add&lt;/code&gt; 및 &lt;code&gt;advice-remove&lt;/code&gt; 입니다.)</target>
        </trans-unit>
        <trans-unit id="7eb4cad6bae56a3671fe38d9c59df33108242d4f" translate="yes" xml:space="preserve">
          <source>Emacs.&lt;var&gt;class&lt;/var&gt;</source>
          <target state="translated">Emacs.&lt;var&gt;class&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="772ce1b98bdf9ba1f907e4ebaefb6456ad036e1b" translate="yes" xml:space="preserve">
          <source>Emacs.&lt;var&gt;class&lt;/var&gt;.&lt;var&gt;subclass&lt;/var&gt;</source>
          <target state="translated">Emacs.&lt;var&gt;class&lt;/var&gt;.&lt;var&gt;subclass&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="14cd681004a41ed10438de0371e7e1d227d03f61" translate="yes" xml:space="preserve">
          <source>Embedded Native Widgets</source>
          <target state="translated">임베디드 네이티브 위젯</target>
        </trans-unit>
        <trans-unit id="9a7852d05e7baac38409e4f91c01b6dd940846da" translate="yes" xml:space="preserve">
          <source>Embedding breakpoints in source code.</source>
          <target state="translated">소스 코드에 중단 점 포함.</target>
        </trans-unit>
        <trans-unit id="54cf6d6905ae6cd8bd43fbae70d64742d978021f" translate="yes" xml:space="preserve">
          <source>Emboss edge-detection uses a matrix of</source>
          <target state="translated">엠 보스 가장자리 감지는 다음 매트릭스를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="db0b559f4d5ae5e124f4899b893fbf4e32a596af" translate="yes" xml:space="preserve">
          <source>Empty matches do count, except that &lt;code&gt;split-string&lt;/code&gt; will not look for a final empty match when it already reached the end of the string using a non-empty match or when &lt;var&gt;string&lt;/var&gt; is empty:</source>
          <target state="translated">비어 있지 않은 일치를 사용하여 문자열의 끝에 이미 도달했거나 &lt;var&gt;string&lt;/var&gt; 이 비어 있을 때 &lt;code&gt;split-string&lt;/code&gt; 이 최종 빈 일치를 찾지 않는다는 점을 제외하면 빈 일치가 계산 됩니다 .</target>
        </trans-unit>
        <trans-unit id="9d433804d09a2b55eeb29add415a821fb9c7f1c0" translate="yes" xml:space="preserve">
          <source>Emulating Mode Line Formatting</source>
          <target state="translated">에뮬레이션 모드 라인 서식</target>
        </trans-unit>
        <trans-unit id="16f497122ec781967c9cd6bac0e6090a9d12ada1" translate="yes" xml:space="preserve">
          <source>Enabling Auto Compression mode appends the suffixes in &lt;code&gt;jka-compr-load-suffixes&lt;/code&gt; to this list and disabling Auto Compression mode removes them again. The standard value of &lt;code&gt;load-file-rep-suffixes&lt;/code&gt; if Auto Compression mode is disabled is &lt;code&gt;(&quot;&quot;)&lt;/code&gt;. Given that the standard value of &lt;code&gt;jka-compr-load-suffixes&lt;/code&gt; is &lt;code&gt;(&quot;.gz&quot;)&lt;/code&gt;, the standard value of &lt;code&gt;load-file-rep-suffixes&lt;/code&gt; if Auto Compression mode is enabled is &lt;code&gt;(&quot;&quot; &quot;.gz&quot;)&lt;/code&gt;.</source>
          <target state="translated">자동 압축 모드를 활성화하면 &lt;code&gt;jka-compr-load-suffixes&lt;/code&gt; 의 접미사 가이 목록에 추가되고 자동 압축 모드를 비활성화하면 다시 제거됩니다. 자동 압축 모드가 비활성화 된 경우 &lt;code&gt;load-file-rep-suffixes&lt;/code&gt; 의 표준 값 은 &lt;code&gt;(&quot;&quot;)&lt;/code&gt; 입니다. 의 표준 값 점을 감안 &lt;code&gt;jka-compr-load-suffixes&lt;/code&gt; 입니다 &lt;code&gt;(&quot;.gz&quot;)&lt;/code&gt; 의 표준 값 &lt;code&gt;load-file-rep-suffixes&lt;/code&gt; 자동 압축 모드가 활성화되어있는 경우입니다 &lt;code&gt;(&quot;&quot; &quot;.gz&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="97ea443a6ca1abd46f75c2ad8f1c051cf1f2375b" translate="yes" xml:space="preserve">
          <source>Enabling or disabling a minor mode twice in direct succession should not fail and should do the same thing as enabling or disabling it only once. In other words, the minor mode command should be idempotent.</source>
          <target state="translated">부 모드를 연속적으로 두 번 활성화 또는 비활성화하면 실패하지 않으며 한 번만 활성화 또는 비활성화하는 것과 동일한 작업을 수행해야합니다. 즉, 부 모드 명령은 멱등이어야합니다.</target>
        </trans-unit>
        <trans-unit id="a3b1c1ae369f1075ad679993e89089772fd41d3c" translate="yes" xml:space="preserve">
          <source>Encoded text is not really text, as far as Emacs is concerned, but rather a sequence of raw 8-bit bytes. We call buffers and strings that hold encoded text &lt;em&gt;unibyte&lt;/em&gt; buffers and strings, because Emacs treats them as a sequence of individual bytes. Usually, Emacs displays unibyte buffers and strings as octal codes such as &lt;code&gt;\237&lt;/code&gt;. We recommend that you never use unibyte buffers and strings except for manipulating encoded text or binary non-text data.</source>
          <target state="translated">인코딩 된 텍스트는 Emacs에 관한 한 실제 텍스트가 아니라 원시 8 비트 바이트 시퀀스입니다. Emacs는 이들을 개별 바이트의 시퀀스로 취급하기 때문에 인코딩 된 텍스트 &lt;em&gt;유니 바이트&lt;/em&gt; 버퍼와 문자열을 보유하는 버퍼와 문자열을 호출 합니다. 일반적으로 Emacs는 유니 바이트 버퍼와 문자열을 &lt;code&gt;\237&lt;/code&gt; 과 같은 8 진수 코드로 표시합니다 . 인코딩 된 텍스트 또는 이진 텍스트가 아닌 데이터를 조작하는 경우를 제외하고는 유니 바이트 버퍼 및 문자열을 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="bd7313ce1d017669659ef7e4ce9d21c10a5d020c" translate="yes" xml:space="preserve">
          <source>Encoding and I/O</source>
          <target state="translated">인코딩 및 I / O</target>
        </trans-unit>
        <trans-unit id="02f30c7d0f91b7195ed0ae6309a8ca548b2049c4" translate="yes" xml:space="preserve">
          <source>Encoding buffer text and then decoding the result can also fail to reproduce the original text. For instance, if you encode a character with a coding system which does not support that character, the result is unpredictable, and thus decoding it using the same coding system may produce a different text. Currently, Emacs can&amp;rsquo;t report errors that result from encoding unsupported characters.</source>
          <target state="translated">버퍼 텍스트를 인코딩 한 다음 결과를 디코딩해도 원본 텍스트를 재현하지 못할 수 있습니다. 예를 들어, 해당 문자를 지원하지 않는 코딩 시스템으로 문자를 인코딩하면 결과를 예측할 수 없으므로 동일한 코딩 시스템을 사용하여 디코딩하면 다른 텍스트가 생성 될 수 있습니다. 현재 Emacs는 지원되지 않는 문자 인코딩으로 인한 오류를보고 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0d4bbb47556074532bed047220c876c7fbf6d672" translate="yes" xml:space="preserve">
          <source>Encoding or decoding text without doing I/O.</source>
          <target state="translated">I / O를 수행하지 않고 텍스트 인코딩 또는 디코딩.</target>
        </trans-unit>
        <trans-unit id="c49dfe38fa95a2d94187448bdd45b6ceb51fea26" translate="yes" xml:space="preserve">
          <source>End of buffer</source>
          <target state="translated">버퍼 끝</target>
        </trans-unit>
        <trans-unit id="22ed4aff93c21533cf773a985fc18a0a9d6075db" translate="yes" xml:space="preserve">
          <source>End of file during parsing</source>
          <target state="translated">구문 분석 중 파일 끝</target>
        </trans-unit>
        <trans-unit id="51a24f40f1dfdda0623dab9d3238f372be53712c" translate="yes" xml:space="preserve">
          <source>End the current subpath by connecting it back to its initial point. A line is drawn along the connection.</source>
          <target state="translated">현재 하위 경로를 초기 지점에 다시 연결하여 종료합니다. 연결을 따라 선이 그려집니다.</target>
        </trans-unit>
        <trans-unit id="d83d52673aa258dada627130abd13b94143274cf" translate="yes" xml:space="preserve">
          <source>Ensuring you have tested all branches in your code.</source>
          <target state="translated">코드의 모든 분기를 테스트했는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="766315a2e77f28f51bb4338a661aed5831816a7e" translate="yes" xml:space="preserve">
          <source>Enter a recursive edit to deal with this question&amp;mdash;instead of any other action that would normally be taken.</source>
          <target state="translated">일반적으로 수행되는 다른 작업 대신이 질문을 처리하기 위해 반복 편집을 입력합니다.</target>
        </trans-unit>
        <trans-unit id="596cbfc7aa5284414bc7f90512c8bc54b1c78c11" translate="yes" xml:space="preserve">
          <source>Entering a recursive edit, and why you usually shouldn&amp;rsquo;t.</source>
          <target state="translated">재귀 편집을 입력하고 일반적으로하지 말아야하는 이유.</target>
        </trans-unit>
        <trans-unit id="93c491ff8b6ed99eb7d8c488249b40da813b3e66" translate="yes" xml:space="preserve">
          <source>Entering it at a certain point in the program.</source>
          <target state="translated">프로그램의 특정 지점에 입력합니다.</target>
        </trans-unit>
        <trans-unit id="d14d5f3e4385e31fcb77f0c423677755e926fcc3" translate="yes" xml:space="preserve">
          <source>Entering it when a certain function is called.</source>
          <target state="translated">특정 기능이 호출 될 때 입력합니다.</target>
        </trans-unit>
        <trans-unit id="ec57cd29307aa24142772c0c32253ccfca258554" translate="yes" xml:space="preserve">
          <source>Entering it when a variable is modified.</source>
          <target state="translated">변수가 수정 될 때 입력합니다.</target>
        </trans-unit>
        <trans-unit id="b4fb292744685eab3a4922e2a5ddda019c43db2a" translate="yes" xml:space="preserve">
          <source>Entering the Debugger on a Function Call</source>
          <target state="translated">함수 호출시 디버거 입력</target>
        </trans-unit>
        <trans-unit id="281d5c4d3f2ee8f959289903ff6d4cf7b9296934" translate="yes" xml:space="preserve">
          <source>Entering the Debugger on an Error</source>
          <target state="translated">오류 발생시 디버거 입력</target>
        </trans-unit>
        <trans-unit id="844887075a6009589b0868071d101e40cc28f3a9" translate="yes" xml:space="preserve">
          <source>Entering the debugger when a variable is modified</source>
          <target state="translated">변수가 수정 될 때 디버거 시작</target>
        </trans-unit>
        <trans-unit id="9a16ed8e32b37737effa3241044834a8eb948bb3" translate="yes" xml:space="preserve">
          <source>Entering the debugger when an error happens.</source>
          <target state="translated">오류가 발생하면 디버거를 입력합니다.</target>
        </trans-unit>
        <trans-unit id="09d7bf61bea73a703c7ae9aa3e0658c116885966" translate="yes" xml:space="preserve">
          <source>Entries in &lt;code&gt;local-function-key-map&lt;/code&gt; are ignored if they conflict with bindings made in the minor mode, local, or global keymaps. I.e., the remapping only applies if the original key sequence would otherwise not have any binding.</source>
          <target state="translated">&lt;code&gt;local-function-key-map&lt;/code&gt; 의 항목 은 부 모드, 로컬 또는 전역 키맵에서 만들어진 바인딩과 충돌하는 경우 무시됩니다. 즉, 원래 키 시퀀스에 바인딩이없는 경우에만 다시 매핑이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="8254ab2eb5612dc4ce1c103171c6b702da77f34a" translate="yes" xml:space="preserve">
          <source>Entry to Edebug for displaying something also saves and restores the following data (though some of them are deliberately not restored if an error or quit signal occurs).</source>
          <target state="translated">항목을 표시하기 위해 Edebug에 항목을 입력하면 다음 데이터도 저장 및 복원됩니다 (일부 데이터는 오류 또는 종료 신호가 발생하는 경우 의도적으로 복원되지 않음).</target>
        </trans-unit>
        <trans-unit id="79b3814747436fa5e36b284727f17f4584b2be36" translate="yes" xml:space="preserve">
          <source>Entry to the minibuffer binds this variable to the value of &lt;code&gt;minibuffer-help-form&lt;/code&gt; (see &lt;a href=&quot;minibuffer-misc#Definition-of-minibuffer_002dhelp_002dform&quot;&gt;Definition of minibuffer-help-form&lt;/a&gt;).</source>
          <target state="translated">미니 버퍼에 대한 항목은이 변수를 &lt;code&gt;minibuffer-help-form&lt;/code&gt; 의 값에 바인딩합니다 ( minibuffer-help-form &lt;a href=&quot;minibuffer-misc#Definition-of-minibuffer_002dhelp_002dform&quot;&gt;정의&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="8403ba2a4a5aa9baffc30d3d46a39f555141e42f" translate="yes" xml:space="preserve">
          <source>Environment and configuration variables</source>
          <target state="translated">환경 및 구성 변수</target>
        </trans-unit>
        <trans-unit id="c4de2199d0374144093362250edf386e9f468abf" translate="yes" xml:space="preserve">
          <source>Equality Predicates</source>
          <target state="translated">동등 술어</target>
        </trans-unit>
        <trans-unit id="834c979ef344d5fe417d910f8b66468831446066" translate="yes" xml:space="preserve">
          <source>Equality and inequality predicates.</source>
          <target state="translated">같음 및 같지 않음 술어.</target>
        </trans-unit>
        <trans-unit id="c8d0f04136312386813886250977d18ad026a2f1" translate="yes" xml:space="preserve">
          <source>Equivalent to &amp;lsquo;</source>
          <target state="translated">'와 동일</target>
        </trans-unit>
        <trans-unit id="fa647c1ab7e45907989ea68b5acf3879755d28ca" translate="yes" xml:space="preserve">
          <source>Error Messages</source>
          <target state="translated">오류 메시지</target>
        </trans-unit>
        <trans-unit id="5a760c7fc538e175f1cfc5267b17003886b1f1cb" translate="yes" xml:space="preserve">
          <source>Error Symbols and Condition Names</source>
          <target state="translated">오류 기호 및 조건 이름</target>
        </trans-unit>
        <trans-unit id="1f7f4fdf201c7b5f16e21bf03e3078b9a1c7771e" translate="yes" xml:space="preserve">
          <source>Error and warning messages from byte compilation are printed in a buffer named</source>
          <target state="translated">바이트 컴파일의 오류 및 경고 메시지는 다음과 같은 버퍼에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="dfccb975dbeae0442fb778b970540719d3134c8b" translate="yes" xml:space="preserve">
          <source>Error signaling and handling have some resemblance to &lt;code&gt;throw&lt;/code&gt; and &lt;code&gt;catch&lt;/code&gt; (see &lt;a href=&quot;catch-and-throw#Catch-and-Throw&quot;&gt;Catch and Throw&lt;/a&gt;), but they are entirely separate facilities. An error cannot be caught by a &lt;code&gt;catch&lt;/code&gt;, and a &lt;code&gt;throw&lt;/code&gt; cannot be handled by an error handler (though using &lt;code&gt;throw&lt;/code&gt; when there is no suitable &lt;code&gt;catch&lt;/code&gt; signals an error that can be handled).</source>
          <target state="translated">오류 신호 및 처리는 &lt;code&gt;throw&lt;/code&gt; 및 &lt;code&gt;catch&lt;/code&gt; 와 비슷 하지만 ( &lt;a href=&quot;catch-and-throw#Catch-and-Throw&quot;&gt;Catch 및 Throw&lt;/a&gt; 참조 ) 완전히 별개의 기능입니다. &lt;code&gt;catch&lt;/code&gt; 로 오류를 포착 할 수없고 오류 핸들러 가 &lt;code&gt;throw&lt;/code&gt; 를 처리 할 수 ​​없습니다 ( 적절한 &lt;code&gt;catch&lt;/code&gt; 가 없을 때 &lt;code&gt;throw&lt;/code&gt; 를 사용 하면 처리 할 수있는 오류를 알릴 수 있음).</target>
        </trans-unit>
        <trans-unit id="805e86a8cbf628e38e4c45612c005a504009e79a" translate="yes" xml:space="preserve">
          <source>Errors</source>
          <target state="translated">Errors</target>
        </trans-unit>
        <trans-unit id="9d0a10c2c2e113d5312e59894e38cc94f35e4f65" translate="yes" xml:space="preserve">
          <source>Errors in finalizers are printed to &lt;code&gt;*Messages*&lt;/code&gt;. Emacs runs a given finalizer object&amp;rsquo;s associated function exactly once, even if that function fails.</source>
          <target state="translated">종료 자의 오류는 &lt;code&gt;*Messages*&lt;/code&gt; 인쇄됩니다 . Emacs는 해당 함수가 실패하더라도 지정된 종료 자 객체의 관련 함수를 정확히 한 번 실행합니다.</target>
        </trans-unit>
        <trans-unit id="4db567f1da446be4a0e532bab664141df98a3c4f" translate="yes" xml:space="preserve">
          <source>Escape-syntax characters: &amp;lsquo;</source>
          <target state="translated">이스케이프 구문 문자 : '</target>
        </trans-unit>
        <trans-unit id="cf82113fd70beadf20192ff3e6d4d74b99c817ff" translate="yes" xml:space="preserve">
          <source>Establishing a local binding saves away the variable&amp;rsquo;s previous value (or lack of one). We say that the previous value is &lt;em&gt;shadowed&lt;/em&gt;. Both global and local values may be shadowed. If a local binding is in effect, using &lt;code&gt;setq&lt;/code&gt; on the local variable stores the specified value in the local binding. When that local binding is no longer in effect, the previously shadowed value (or lack of one) comes back.</source>
          <target state="translated">로컬 바인딩을 설정하면 변수의 이전 값 (또는 값 부족)이 절약됩니다. 우리는 이전 값이 &lt;em&gt;음영 처리&lt;/em&gt; 되었다고 말합니다 . 글로벌 및 로컬 값 모두 음영 처리 될 수 있습니다. 로컬 바인딩이 유효한 경우 로컬 변수에 &lt;code&gt;setq&lt;/code&gt; 를 사용 하면 지정된 값이 로컬 바인딩에 저장됩니다. 해당 로컬 바인딩이 더 이상 적용되지 않으면 이전에 음영 처리 된 값 (또는 부족한 값)이 다시 나타납니다.</target>
        </trans-unit>
        <trans-unit id="e7b08833a45efab519f57833aec45127debfcb2b" translate="yes" xml:space="preserve">
          <source>Eval</source>
          <target state="translated">Eval</target>
        </trans-unit>
        <trans-unit id="51e8465ca0546c95a84fea0ae32a522b14322458" translate="yes" xml:space="preserve">
          <source>Eval:</source>
          <target state="translated">Eval:</target>
        </trans-unit>
        <trans-unit id="017bb101654ddccd6af97e1fb1a4a04d0dd0c6b5" translate="yes" xml:space="preserve">
          <source>Evaluate &lt;var&gt;bindings&lt;/var&gt; to a list of bindings as in &lt;code&gt;rx-let&lt;/code&gt;, and evaluate &lt;var&gt;body&lt;/var&gt; with those bindings in effect for calls to &lt;code&gt;rx-to-string&lt;/code&gt;.</source>
          <target state="translated">평가 &lt;var&gt;bindings&lt;/var&gt; 과 바인딩의 목록을 &lt;code&gt;rx-let&lt;/code&gt; ,하고 평가 &lt;var&gt;body&lt;/var&gt; 위해 통화에 대한 효과에 그 바인딩 &lt;code&gt;rx-to-string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1b9783654f5c1c6a7ce0d518a3c7753257a3b28" translate="yes" xml:space="preserve">
          <source>Evaluate &lt;var&gt;expression&lt;/var&gt; to determine its value, &lt;var&gt;expval&lt;/var&gt;. Find the first clause in &lt;var&gt;clauses&lt;/var&gt; whose &lt;var&gt;pattern&lt;/var&gt; matches &lt;var&gt;expval&lt;/var&gt; and pass control to that clause&amp;rsquo;s &lt;var&gt;body-forms&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;expression&lt;/var&gt; 을 평가 하여 값인 &lt;var&gt;expval&lt;/var&gt; 을 결정합니다 . 최초의 절 찾기 &lt;var&gt;clauses&lt;/var&gt; &lt;var&gt;pattern&lt;/var&gt; 과 일치 &lt;var&gt;expval&lt;/var&gt; 그 조항의와 패스 제어 &lt;var&gt;body-forms&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="7acc8ce084889c04ea391fe80485a1141d6aba72" translate="yes" xml:space="preserve">
          <source>Evaluate &lt;var&gt;form&lt;/var&gt; and return its value, but inform coverage testing that &lt;var&gt;form&lt;/var&gt;&amp;rsquo;s value should always be the same.</source>
          <target state="translated">&lt;var&gt;form&lt;/var&gt; 평가 하고 그 값을 반환하되 &lt;var&gt;form&lt;/var&gt; 의 값이 항상 동일해야 함을 커버리지 테스트에 알립니다 .</target>
        </trans-unit>
        <trans-unit id="a7a2ac4cbdbdccec325f508d425bb5f51d47991d" translate="yes" xml:space="preserve">
          <source>Evaluate &lt;var&gt;form&lt;/var&gt;, a Lisp expression, find the first &lt;var&gt;tag&lt;/var&gt; that matches it, and process its associated data layout specification &lt;var&gt;spec&lt;/var&gt;. Matching can occur in one of three ways:</source>
          <target state="translated">Lisp 표현식 인 &lt;var&gt;form&lt;/var&gt; 을 평가 하고 일치 하는 첫 번째 &lt;var&gt;tag&lt;/var&gt; 를 찾은 다음 관련 데이터 레이아웃 사양 &lt;var&gt;spec&lt;/var&gt; 합니다. 일치는 다음 세 가지 방법 중 하나로 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a7f623e6b41e2cb816551108409e841a3217f90" translate="yes" xml:space="preserve">
          <source>Evaluate &lt;var&gt;form&lt;/var&gt;, a Lisp expression, for side-effect only. If the field name is specified, the value is bound to that field name.</source>
          <target state="translated">부작용에 대해서만 Lisp 표현식 인 &lt;var&gt;form&lt;/var&gt; 을 평가 합니다. 필드 이름이 지정되면 값이 해당 필드 이름에 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="580ad2e14e2540c83fc1feadb6dbd64861f6a26e" translate="yes" xml:space="preserve">
          <source>Evaluate &lt;var&gt;form&lt;/var&gt;, informing coverage testing that &lt;var&gt;form&lt;/var&gt; should never return. If it ever does return, you get a run-time error.</source>
          <target state="translated">&lt;var&gt;form&lt;/var&gt; 평가 하여 &lt;var&gt;form&lt;/var&gt; 이 반환되지 않아야 함을 커버리지 테스트에 알립니다 . 반환되는 경우 런타임 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bba9f3f9dd3f430bb8581d609be73110636f4819" translate="yes" xml:space="preserve">
          <source>Evaluate expression &lt;var&gt;exp&lt;/var&gt; in the context of Edebug itself (&lt;code&gt;eval-expression&lt;/code&gt;).</source>
          <target state="translated">Edebug 자체의 컨텍스트에서 &lt;var&gt;exp&lt;/var&gt; 표현식을 평가 합니다 ( &lt;code&gt;eval-expression&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="853e1525137800a049ad2ae06d42889f8357df2d" translate="yes" xml:space="preserve">
          <source>Evaluate expression &lt;var&gt;exp&lt;/var&gt; in the context outside of Edebug (&lt;code&gt;edebug-eval-expression&lt;/code&gt;). That is, Edebug tries to minimize its interference with the evaluation.</source>
          <target state="translated">Edebug ( &lt;code&gt;edebug-eval-expression&lt;/code&gt; ) 외부의 컨텍스트에서 &lt;var&gt;exp&lt;/var&gt; 표현식을 평가하십시오 . 즉, Edebug는 평가와의 간섭을 최소화하려고합니다.</target>
        </trans-unit>
        <trans-unit id="948bb7c2498b0b3612f9c4b4ad2d6630a5510c14" translate="yes" xml:space="preserve">
          <source>Evaluate the expression before point, in the context outside of Edebug (&lt;code&gt;edebug-eval-last-sexp&lt;/code&gt;).</source>
          <target state="translated">Edebug ( &lt;code&gt;edebug-eval-last-sexp&lt;/code&gt; ) 외부의 컨텍스트에서 point 전에 표현식을 평가합니다 .</target>
        </trans-unit>
        <trans-unit id="f35818f832835c32b6fe2916269847d4edffa88c" translate="yes" xml:space="preserve">
          <source>Evaluate the expression before point, in the context outside of Edebug (&lt;code&gt;edebug-eval-last-sexp&lt;/code&gt;). With the prefix argument of zero (</source>
          <target state="translated">Edebug ( &lt;code&gt;edebug-eval-last-sexp&lt;/code&gt; ) 외부의 컨텍스트에서 point 전에 표현식을 평가합니다 . 접두사 인수 0 (</target>
        </trans-unit>
        <trans-unit id="231434026214c54f3d660e740912041c85fdfd39" translate="yes" xml:space="preserve">
          <source>Evaluate the expression before point, in the outside context, and insert the value in the buffer (&lt;code&gt;edebug-eval-print-last-sexp&lt;/code&gt;). With prefix argument of zero (</source>
          <target state="translated">외부 컨텍스트에서 point 앞의 표현식을 평가하고 값을 버퍼 ( &lt;code&gt;edebug-eval-print-last-sexp&lt;/code&gt; )에 삽입합니다. 접두사 인수 0 (</target>
        </trans-unit>
        <trans-unit id="78278047bd4e3ea382ac8201e93db09cc8442bfd" translate="yes" xml:space="preserve">
          <source>Evaluate the interactive &lt;var&gt;spec&lt;/var&gt; just like an interactive call to a function with such a spec would, and then return the corresponding list of arguments that was built. E.g., &lt;code&gt;(advice-eval-interactive-spec &quot;r\nP&quot;)&lt;/code&gt; will return a list of three elements, containing the boundaries of the region and the current prefix argument.</source>
          <target state="translated">이러한 사양이있는 함수에 대한 대화식 호출처럼 대화 형 &lt;var&gt;spec&lt;/var&gt; 평가 한 다음 빌드 된 해당 인수 목록을 반환합니다. 예를 들어, &lt;code&gt;(advice-eval-interactive-spec &quot;r\nP&quot;)&lt;/code&gt; 는 영역의 경계와 현재 접두사 인수를 포함하는 세 요소의 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c6f78c01d4848979b5b7c68ca6a35ed06ed99671" translate="yes" xml:space="preserve">
          <source>Evaluates &lt;var&gt;expr&lt;/var&gt; to get &lt;var&gt;exprval&lt;/var&gt; and matches if &lt;var&gt;exprval&lt;/var&gt; matches &lt;var&gt;pattern&lt;/var&gt;. (It is called &lt;code&gt;let&lt;/code&gt; because &lt;var&gt;pattern&lt;/var&gt; can bind symbols to values using &lt;var&gt;symbol&lt;/var&gt;.)</source>
          <target state="translated">들을 평가는 &lt;var&gt;expr&lt;/var&gt; 얻을 &lt;var&gt;exprval&lt;/var&gt; 과 일치하는 경우 &lt;var&gt;exprval&lt;/var&gt; 경기의 &lt;var&gt;pattern&lt;/var&gt; . (라고 &lt;code&gt;let&lt;/code&gt; 있기 때문에 &lt;var&gt;pattern&lt;/var&gt; 사용하여 값에 문자를 결합 할 수 &lt;var&gt;symbol&lt;/var&gt; .)</target>
        </trans-unit>
        <trans-unit id="87d131c3ebb6c4f0c9cfdfe39480aa9ad4b173d6" translate="yes" xml:space="preserve">
          <source>Evaluating Macro Arguments Repeatedly</source>
          <target state="translated">반복적으로 매크로 인수 평가</target>
        </trans-unit>
        <trans-unit id="24421971dc29c855ec4d191995ceb56afdbc89a7" translate="yes" xml:space="preserve">
          <source>Evaluating Macro Arguments in Expansion</source>
          <target state="translated">확장에서 매크로 인수 평가</target>
        </trans-unit>
        <trans-unit id="2f1f505e20fcaf20af4daf55e87911ae35f25363" translate="yes" xml:space="preserve">
          <source>Evaluating a form may also make changes that persist; these changes are called &lt;em&gt;side effects&lt;/em&gt;. An example of a form that produces a side effect is &lt;code&gt;(setq foo 1)&lt;/code&gt;.</source>
          <target state="translated">양식을 평가하면 변경 사항이 지속될 수도 있습니다. 이러한 변화를 &lt;em&gt;부작용&lt;/em&gt; 이라고 &lt;em&gt;합니다&lt;/em&gt; . 부작용을 &lt;code&gt;(setq foo 1)&lt;/code&gt; 형식의 예는 (setq foo 1) 입니다.</target>
        </trans-unit>
        <trans-unit id="2d61c182c806f0223ae98daf21330e85c522ce20" translate="yes" xml:space="preserve">
          <source>Evaluating body form &lt;code&gt;(list&amp;nbsp;e-num&amp;nbsp;o-num)&lt;/code&gt; signals error. To distinguish between sub-patterns, you can use another symbol, identical in name in all sub-patterns but differing in value. Reworking the above example:</source>
          <target state="translated">본문 형식 &lt;code&gt;(list&amp;nbsp;e-num&amp;nbsp;o-num)&lt;/code&gt; 평가하면 오류를 알 수 있습니다. 하위 패턴을 구별하기 위해 모든 하위 패턴에서 이름이 동일하지만 값이 다른 다른 기호를 사용할 수 있습니다. 위의 예를 재 작업 :</target>
        </trans-unit>
        <trans-unit id="3ae5bcbdd398a604619aaaeb51aa862b049a9d28" translate="yes" xml:space="preserve">
          <source>Evaluating expressions within Edebug.</source>
          <target state="translated">Edebug 내에서 표현식 평가.</target>
        </trans-unit>
        <trans-unit id="b918e0a59fc48b390462dde69196db2b275b9e40" translate="yes" xml:space="preserve">
          <source>Evaluating forms in the order they appear is the most common way control passes from one form to another. In some contexts, such as in a function body, this happens automatically. Elsewhere you must use a control structure construct to do this: &lt;code&gt;progn&lt;/code&gt;, the simplest control construct of Lisp.</source>
          <target state="translated">표시되는 순서대로 양식을 평가하는 것은 컨트롤이 한 양식에서 다른 양식으로 전달되는 가장 일반적인 방법입니다. 함수 본문과 같은 일부 컨텍스트에서 이것은 자동으로 발생합니다. 다른 곳에서는 제어 구조 구조를 사용해야합니다 : &lt;code&gt;progn&lt;/code&gt; , Lisp의 가장 간단한 제어 구조.</target>
        </trans-unit>
        <trans-unit id="1f02356dc5a053f01ce62f7ea573a8acd290011b" translate="yes" xml:space="preserve">
          <source>Evaluating the preceding forms and typing, in any order,</source>
          <target state="translated">앞의 양식을 평가하고 순서에 관계없이 입력합니다.</target>
        </trans-unit>
        <trans-unit id="98fece8fcee58d0d1df092488c54d0e087d2e152" translate="yes" xml:space="preserve">
          <source>Evaluating this form in the buffer</source>
          <target state="translated">버퍼에서이 양식 평가</target>
        </trans-unit>
        <trans-unit id="dcb390f68e265f8b977b81b6d105d4c08a08a6cb" translate="yes" xml:space="preserve">
          <source>Evaluating this form will usually display</source>
          <target state="translated">이 양식을 평가하면 일반적으로</target>
        </trans-unit>
        <trans-unit id="ff7513853508e7c6e3aa07908df2a450a026eb88" translate="yes" xml:space="preserve">
          <source>Evaluation</source>
          <target state="translated">Evaluation</target>
        </trans-unit>
        <trans-unit id="8ffcdfee5e7d21cf68ca5efead83afea63f2d8a0" translate="yes" xml:space="preserve">
          <source>Evaluation During Compilation</source>
          <target state="translated">컴파일 중 평가</target>
        </trans-unit>
        <trans-unit id="799e512ae5e7e3f329c10fa852a14d221c737ffd" translate="yes" xml:space="preserve">
          <source>Evaluation List Buffer</source>
          <target state="translated">평가 목록 버퍼</target>
        </trans-unit>
        <trans-unit id="bb51b95ce0002371cb5ea49458cb059c57d93de5" translate="yes" xml:space="preserve">
          <source>Evaluation Notation</source>
          <target state="translated">평가 표기법</target>
        </trans-unit>
        <trans-unit id="9f0ba46ba13ef1f25d98af8b19fda50c29d37fe0" translate="yes" xml:space="preserve">
          <source>Evaluation in textual order.</source>
          <target state="translated">텍스트 순서로 평가.</target>
        </trans-unit>
        <trans-unit id="29381319eaf57dc01242c3c13cbf345a9abbd540" translate="yes" xml:space="preserve">
          <source>Evaluation in the scheme of things.</source>
          <target state="translated">사물의 계획에서 평가.</target>
        </trans-unit>
        <trans-unit id="9a643d0c7814edf34f1de3bc48ce98cb63357e3a" translate="yes" xml:space="preserve">
          <source>Evaluation is a recursive process, and evaluating a form often involves evaluating parts within that form. For instance, when you evaluate a &lt;em&gt;function call&lt;/em&gt; form such as &lt;code&gt;(car x)&lt;/code&gt;, Emacs first evaluates the argument (the subform &lt;code&gt;x&lt;/code&gt;). After evaluating the argument, Emacs &lt;em&gt;executes&lt;/em&gt; the function (&lt;code&gt;car&lt;/code&gt;), and if the function is written in Lisp, execution works by evaluating the &lt;em&gt;body&lt;/em&gt; of the function (in this example, however, &lt;code&gt;car&lt;/code&gt; is not a Lisp function; it is a primitive function implemented in C). See &lt;a href=&quot;functions#Functions&quot;&gt;Functions&lt;/a&gt;, for more information about functions and function calls.</source>
          <target state="translated">평가는 반복적 인 프로세스이며 양식 평가에는 종종 해당 양식 내의 부품 평가가 포함됩니다. 예를 들어, &lt;code&gt;(car x)&lt;/code&gt; 와 같은 &lt;em&gt;함수 호출&lt;/em&gt; 형식 을 평가할 때 Emacs는 먼저 인수 (하위 형식 &lt;code&gt;x&lt;/code&gt; )를 평가합니다 . 인수를 평가 한 후 Emacs 는 함수 ( &lt;code&gt;car&lt;/code&gt; )를 &lt;em&gt;실행&lt;/em&gt; 하고 , 함수가 Lisp로 작성된 경우 함수의 &lt;em&gt;본문&lt;/em&gt; 을 평가하여 실행이 작동 합니다 (이 예제에서는 &lt;code&gt;car&lt;/code&gt; 가 Lisp 함수가 아닙니다. 기본 함수입니다. C에서 구현 됨). 함수 및 함수 호출에 대한 자세한 내용은 &lt;a href=&quot;functions#Functions&quot;&gt;Functions를&lt;/a&gt; 참조하십시오 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d705973d35f23ad5de4704455dc325a9d4eb170b" translate="yes" xml:space="preserve">
          <source>Evaluation of Function Forms</source>
          <target state="translated">기능 양식 평가</target>
        </trans-unit>
        <trans-unit id="5ce5fe6e895057f002660fd14290d646f73a8b54" translate="yes" xml:space="preserve">
          <source>Evaluation of the expression &lt;code&gt;(indent-relative nil)&lt;/code&gt; produces the following:</source>
          <target state="translated">표현식 &lt;code&gt;(indent-relative nil)&lt;/code&gt; 을 평가 하면 다음이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="7438669b48311d2f5b2747b9726e0fd9a708feb9" translate="yes" xml:space="preserve">
          <source>Evaluation of the macro call begins like evaluation of a function call except for one crucial difference: the macro arguments are the actual expressions appearing in the macro call. They are not evaluated before they are given to the macro definition. By contrast, the arguments of a function are results of evaluating the elements of the function call list.</source>
          <target state="translated">매크로 호출의 평가는 한 가지 중요한 차이점을 제외하고는 함수 호출의 평가와 같이 시작됩니다. 매크로 인수는 매크로 호출에 나타나는 실제 표현식입니다. 매크로 정의에 지정되기 전에 평가되지 않습니다. 반대로 함수의 인수는 함수 호출 목록의 요소를 평가 한 결과입니다.</target>
        </trans-unit>
        <trans-unit id="90d64dd1d645e502be2e3c08d30a8451f928949d" translate="yes" xml:space="preserve">
          <source>Evaluation takes place in a context called the &lt;em&gt;environment&lt;/em&gt;, which consists of the current values and bindings of all Lisp variables (see &lt;a href=&quot;variables#Variables&quot;&gt;Variables&lt;/a&gt;).&lt;a href=&quot;#FOOT7&quot; name=&quot;DOCF7&quot;&gt;&lt;sup&gt;7&lt;/sup&gt;&lt;/a&gt; Whenever a form refers to a variable without creating a new binding for it, the variable evaluates to the value given by the current environment. Evaluating a form may also temporarily alter the environment by binding variables (see &lt;a href=&quot;local-variables#Local-Variables&quot;&gt;Local Variables&lt;/a&gt;).</source>
          <target state="translated">평가는라는 문맥에서 일어나는 &lt;em&gt;환경&lt;/em&gt; 모두 리스프 변수 (참조의 현재 값 및 바인딩 구성, &lt;a href=&quot;variables#Variables&quot;&gt;변수&lt;/a&gt; ). &lt;a href=&quot;#FOOT7&quot; name=&quot;DOCF7&quot;&gt;&lt;sup&gt;7&lt;/sup&gt;&lt;/a&gt; 양식이 새 바인딩을 만들지 않고 변수를 참조 할 때마다 변수는 현재 환경에서 제공하는 값으로 평가됩니다. 양식을 평가하면 변수를 바인딩하여 일시적으로 환경을 변경할 수도 있습니다 ( &lt;a href=&quot;local-variables#Local-Variables&quot;&gt;로컬 변수&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="89441f5a56c1206182a2982f8b08988bca88d4b7" translate="yes" xml:space="preserve">
          <source>Even after a window is deleted, it continues to exist as a Lisp object, until there are no more references to it. Window deletion can be reversed, by restoring a saved window configuration (see &lt;a href=&quot;window-configurations#Window-Configurations&quot;&gt;Window Configurations&lt;/a&gt;).</source>
          <target state="translated">윈도우가 삭제 된 후에도 더 이상 참조가 없을 때까지 Lisp 객체로 계속 존재합니다. 창 삭제는 저장된 창 구성을 복원하여 되돌릴 수 있습니다 ( &lt;a href=&quot;window-configurations#Window-Configurations&quot;&gt;창 구성&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="7f71e452bdad7f804fdef6528245b229c6279394" translate="yes" xml:space="preserve">
          <source>Even if &lt;var&gt;update&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;window-end&lt;/code&gt; does not attempt to scroll the display if point has moved off the screen, the way real redisplay would do. It does not alter the &lt;code&gt;window-start&lt;/code&gt; value. In effect, it reports where the displayed text will end if scrolling is not required. Note that the position it returns might be only partially visible.</source>
          <target state="translated">해도 &lt;var&gt;update&lt;/var&gt; 비입니다 &lt;code&gt;nil&lt;/code&gt; , &lt;code&gt;window-end&lt;/code&gt; 포인트는 화면, 실제 다시 표시 할 것입니다 방법을 이동 한 경우 디스플레이를 스크롤하지 않습니다. &lt;code&gt;window-start&lt;/code&gt; 값을 변경하지 않습니다 . 실제로 스크롤이 필요하지 않은 경우 표시된 텍스트가 끝나는 위치를보고합니다. 반환되는 위치는 부분적으로 만 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85d0a91348426929c95737dda6bb8f3081e1106c" translate="yes" xml:space="preserve">
          <source>Even if you do not use &lt;code&gt;make-temp-file&lt;/code&gt; to create the temporary file, you should still use this variable to decide which directory to put the file in. However, if you expect the file to be small, you should use &lt;code&gt;small-temporary-file-directory&lt;/code&gt; first if that is non-&lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;make-temp-file&lt;/code&gt; 을 사용하여 임시 파일 을 생성 하지 않더라도이 변수를 사용하여 파일을 저장할 디렉토리를 결정해야합니다. 그러나 파일이 작을 것으로 예상되는 경우 &lt;code&gt;small-temporary-file-directory&lt;/code&gt; 를 사용해야합니다. &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 먼저 -file-directory .</target>
        </trans-unit>
        <trans-unit id="029e5f7d89c36acc32829e229969b89a54ce98c6" translate="yes" xml:space="preserve">
          <source>Even more powerful is &lt;code&gt;redraw-display&lt;/code&gt;:</source>
          <target state="translated">더 강력한 기능은 &lt;code&gt;redraw-display&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="432fa854d420fdda2cde68b3678fc84324738837" translate="yes" xml:space="preserve">
          <source>Even though the code letter doesn&amp;rsquo;t use a prompt string, you must follow it with a newline if it is not the last code character in the string.</source>
          <target state="translated">코드 문자가 프롬프트 문자열을 사용하지 않더라도 문자열의 마지막 코드 문자가 아니면 그 뒤에 개행 문자를 붙여야합니다.</target>
        </trans-unit>
        <trans-unit id="85560a7fc3cf7e747fea690e0afc513f6846e642" translate="yes" xml:space="preserve">
          <source>Even though this is not a normal hook, you can use &lt;code&gt;add-hook&lt;/code&gt; and &lt;code&gt;remove-hook&lt;/code&gt; to manipulate the list. See &lt;a href=&quot;hooks#Hooks&quot;&gt;Hooks&lt;/a&gt;.</source>
          <target state="translated">정상적인 후크는 아니지만 &lt;code&gt;add-hook&lt;/code&gt; 및 &lt;code&gt;remove-hook&lt;/code&gt; 를 사용하여 목록을 조작 할 수 있습니다 . &lt;a href=&quot;hooks#Hooks&quot;&gt;후크를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="37dfaec8f5a98d8e1a6fff0d00abd7c86770b663" translate="yes" xml:space="preserve">
          <source>Even when lexical binding is enabled, certain variables will continue to be dynamically bound. These are called &lt;em&gt;special variables&lt;/em&gt;. Every variable that has been defined with &lt;code&gt;defvar&lt;/code&gt;, &lt;code&gt;defcustom&lt;/code&gt; or &lt;code&gt;defconst&lt;/code&gt; is a special variable (see &lt;a href=&quot;defining-variables#Defining-Variables&quot;&gt;Defining Variables&lt;/a&gt;). All other variables are subject to lexical binding.</source>
          <target state="translated">어휘 바인딩이 활성화 된 경우에도 특정 변수는 계속 동적으로 바인딩됩니다. 이를 &lt;em&gt;특수 변수&lt;/em&gt; 라고 &lt;em&gt;합니다&lt;/em&gt; . &lt;code&gt;defvar&lt;/code&gt; , &lt;code&gt;defcustom&lt;/code&gt; 또는 &lt;code&gt;defconst&lt;/code&gt; 로 정의 된 모든 변수 는 특수 변수입니다 (변수 &lt;a href=&quot;defining-variables#Defining-Variables&quot;&gt;정의&lt;/a&gt; 참조 ). 다른 모든 변수에는 어휘 바인딩이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="1a444451a6bf3653aee29ba02a88a7a4286cfd3c" translate="yes" xml:space="preserve">
          <source>Event Examples</source>
          <target state="translated">이벤트 예</target>
        </trans-unit>
        <trans-unit id="04a0457b5051e01d35a084a34427af2e0f933cb3" translate="yes" xml:space="preserve">
          <source>Events processed immediately and individually.</source>
          <target state="translated">이벤트는 즉시 개별적으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="dfd77cb42dcfdf913a9b2993fc51c80aff807ab1" translate="yes" xml:space="preserve">
          <source>Events read from this list are not normally added to the current command&amp;rsquo;s key sequence (as returned by, e.g., &lt;code&gt;this-command-keys&lt;/code&gt;), as the events will already have been added once as they were read for the first time. An element of the form &lt;code&gt;(t&amp;nbsp;.&amp;nbsp;&lt;var&gt;event&lt;/var&gt;)&lt;/code&gt; forces &lt;var&gt;event&lt;/var&gt; to be added to the current command&amp;rsquo;s key sequence.</source>
          <target state="translated">이 목록에서 읽은 이벤트는 일반적으로 현재 명령의 키 시퀀스 (예 : &lt;code&gt;this-command-keys&lt;/code&gt; 에 의해 반환 됨)에 추가되지 않습니다 . 이벤트는 처음 읽었을 때 이미 한 번 추가 되었기 때문입니다. 양식의 요소 &lt;code&gt;(t&amp;nbsp;.&amp;nbsp;&lt;var&gt;event&lt;/var&gt;)&lt;/code&gt; 힘 &lt;var&gt;event&lt;/var&gt; 현재 명령의 키 시퀀스에 추가된다.</target>
        </trans-unit>
        <trans-unit id="a4137474199ffe7887e4815646c84fc0febba656" translate="yes" xml:space="preserve">
          <source>Every button has a &lt;em&gt;button type&lt;/em&gt;, which defines default values for the button&amp;rsquo;s properties. Button types are arranged in a hierarchy, with specialized types inheriting from more general types, so that it&amp;rsquo;s easy to define special-purpose types of buttons for specific tasks.</source>
          <target state="translated">모든 버튼에는 버튼의 속성에 대한 기본값을 정의 하는 &lt;em&gt;버튼 유형&lt;/em&gt; 이 있습니다. 버튼 유형은 더 일반적인 유형에서 상속 된 특수 유형을 사용하여 계층 구조로 배열되므로 특정 작업에 대한 특수 목적 유형의 버튼을 쉽게 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd5e71774a4e19fa74784e55cff6c970e9e3dc4c" translate="yes" xml:space="preserve">
          <source>Every coding system specifies a particular set of character code conversions, but the coding system &lt;code&gt;undecided&lt;/code&gt; is special: it leaves the choice unspecified, to be chosen heuristically for each file, based on the file&amp;rsquo;s data. The coding system &lt;code&gt;prefer-utf-8&lt;/code&gt; is like &lt;code&gt;undecided&lt;/code&gt;, but it prefers to choose &lt;code&gt;utf-8&lt;/code&gt; when possible.</source>
          <target state="translated">모든 코딩 시스템은 특정 문자 코드 변환 집합을 지정하지만, &lt;code&gt;undecided&lt;/code&gt; 코딩 시스템 은 특별합니다. 파일의 데이터를 기반으로 각 파일에 대해 경험적으로 선택되도록 선택 사항을 지정하지 않은 상태로 둡니다. 코딩 시스템 &lt;code&gt;prefer-utf-8&lt;/code&gt; 은 &lt;code&gt;undecided&lt;/code&gt; 와 비슷하지만 가능하면 &lt;code&gt;utf-8&lt;/code&gt; 을 선택하는 것을 선호 합니다.</target>
        </trans-unit>
        <trans-unit id="bc949dcffe18c4c6f376934cb6d379922c86061f" translate="yes" xml:space="preserve">
          <source>Every dynamic module should export a C-callable function named &lt;code&gt;emacs_module_init&lt;/code&gt;, which Emacs will call as part of the call to &lt;code&gt;load&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt; which loads the module. It should also export a symbol named &lt;code&gt;plugin_is_GPL_compatible&lt;/code&gt; to indicate that its code is released under the GPL or compatible license; Emacs will signal an error if your program tries to load modules that don&amp;rsquo;t export such a symbol.</source>
          <target state="translated">모든 동적 모듈은 &lt;code&gt;emacs_module_init&lt;/code&gt; 라는 이름의 C 호출 가능 함수를 내 보내야합니다 .이 함수는 Emacs가 모듈 을 &lt;code&gt;load&lt;/code&gt; 하는 호출의 일부로 호출 하거나 모듈을로드하도록 &lt;code&gt;require&lt;/code&gt; 합니다. 또한 &lt;code&gt;plugin_is_GPL_compatible&lt;/code&gt; 이라는 기호를 내 보내서 코드가 GPL 또는 호환 라이센스에 따라 릴리스되었음을 나타내야합니다. 프로그램이 그러한 기호를 내 보내지 않는 모듈을로드하려고하면 Emacs는 오류를 알립니다.</target>
        </trans-unit>
        <trans-unit id="5f7cc4e86bc2ba0c7806f0619e98d104b5a79730" translate="yes" xml:space="preserve">
          <source>Every error specifies an error message, one way or another. The message should state what is wrong (&amp;ldquo;File does not exist&amp;rdquo;), not how things ought to be (&amp;ldquo;File must exist&amp;rdquo;). The convention in Emacs Lisp is that error messages should start with a capital letter, but should not end with any sort of punctuation.</source>
          <target state="translated">모든 오류는 어떤 방식 으로든 오류 메시지를 지정합니다. 메시지는 문제 ( &quot;파일이 존재하지 않음&quot;)가 아니라 잘못된 내용 ( &quot;파일이 존재하지 않음&quot;)을 나타내야합니다. Emacs Lisp의 관례는 오류 메시지가 대문자로 시작해야하지만 어떤 종류의 구두점으로도 끝나서는 안된다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="79a80a71bc9146d2a7362b5b3df1e59c55f3d35d" translate="yes" xml:space="preserve">
          <source>Every event has an &lt;em&gt;event type&lt;/em&gt;, which classifies the event for key binding purposes. For a keyboard event, the event type equals the event value; thus, the event type for a character is the character, and the event type for a function key symbol is the symbol itself. For events that are lists, the event type is the symbol in the &lt;small&gt;CAR&lt;/small&gt; of the list. Thus, the event type is always a symbol or a character.</source>
          <target state="translated">모든 이벤트에는 키 바인딩 목적으로 이벤트를 분류 하는 &lt;em&gt;이벤트 유형이&lt;/em&gt; 있습니다. 키보드 이벤트의 경우 이벤트 유형은 이벤트 값과 같습니다. 따라서 문자의 이벤트 유형은 문자이고 기능 키 기호의 이벤트 유형은 기호 자체입니다. 목록 인 이벤트의 경우 이벤트 유형은 목록 의 &lt;small&gt;CAR&lt;/small&gt; 에있는 기호입니다 . 따라서 이벤트 유형은 항상 기호 또는 문자입니다.</target>
        </trans-unit>
        <trans-unit id="2c51bf37d933cb478063153751844a975d4a56fa" translate="yes" xml:space="preserve">
          <source>Every frame has a &lt;code&gt;name&lt;/code&gt; parameter; this serves as the default for the frame title which window systems typically display at the top of the frame. You can specify a name explicitly by setting the &lt;code&gt;name&lt;/code&gt; frame property.</source>
          <target state="translated">모든 프레임에는 &lt;code&gt;name&lt;/code&gt; 매개 변수가 있습니다. 이것은 윈도우 시스템이 일반적으로 프레임 상단에 표시하는 프레임 제목의 기본값으로 사용됩니다. &lt;code&gt;name&lt;/code&gt; 프레임 속성 을 설정하여 명시 적으로 이름을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="be6e27f4ca0ea0fc906e0595ff83ffbfacac687a" translate="yes" xml:space="preserve">
          <source>Every function added with &lt;code&gt;add-function&lt;/code&gt; can be accompanied by an association list of properties &lt;var&gt;props&lt;/var&gt;. Currently only two of those properties have a special meaning:</source>
          <target state="translated">&lt;code&gt;add-function&lt;/code&gt; 으로 추가 된 모든 함수 는 속성 &lt;var&gt;props&lt;/var&gt; 의 연관 목록을 동반 할 수 있습니다 . 현재 이러한 속성 중 두 가지만 특별한 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="17f75ba86886ee6d09b995da57d98781626b332d" translate="yes" xml:space="preserve">
          <source>Every major mode command begins by calling this function, which has the effect of switching to Fundamental mode and erasing most of the effects of the previous major mode. To ensure that this does its job, the variables that major modes set should not be marked permanent.</source>
          <target state="translated">모든 메이저 모드 명령은이 함수를 호출하여 시작됩니다.이 함수는 기본 모드로 전환하고 이전 메이저 모드의 효과 대부분을 지우는 효과가 있습니다. 이것이 제대로 작동하는지 확인하려면 주요 모드가 설정 한 변수를 영구적으로 표시하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="55faf3a67a23e694ebebf47d4073204f615bb078" translate="yes" xml:space="preserve">
          <source>Every major mode command is supposed to run a normal hook called the &lt;em&gt;mode hook&lt;/em&gt; as one of the last steps of initialization. This makes it easy for a user to customize the behavior of the mode, by overriding the buffer-local variable assignments already made by the mode. Most minor mode functions also run a mode hook at the end. But hooks are used in other contexts too. For example, the hook &lt;code&gt;suspend-hook&lt;/code&gt; runs just before Emacs suspends itself (see &lt;a href=&quot;suspending-emacs#Suspending-Emacs&quot;&gt;Suspending Emacs&lt;/a&gt;).</source>
          <target state="translated">모든 주요 모드 명령이 호출 된 일반 후크 실행하도록되어 &lt;em&gt;모드 후크&lt;/em&gt; 초기화의 마지막 단계 중 하나를. 이렇게하면 모드에서 이미 만든 버퍼 로컬 변수 할당을 재정 의하여 사용자가 모드의 동작을 쉽게 사용자 지정할 수 있습니다. 대부분의 마이너 모드 함수는 마지막에 모드 후크를 실행합니다. 그러나 후크는 다른 컨텍스트에서도 사용됩니다. 예를 들어, hook &lt;code&gt;suspend-hook&lt;/code&gt; 은 Emacs가 스스로를 정지하기 직전에 실행됩니다 ( &lt;a href=&quot;suspending-emacs#Suspending-Emacs&quot;&gt;Suspending Emacs&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="672f6ad74690ed9ca85e43781c95747abb81b4ff" translate="yes" xml:space="preserve">
          <source>Every major mode command should finish by running the mode-independent normal hook &lt;code&gt;change-major-mode-after-body-hook&lt;/code&gt;, its mode hook, and the normal hook &lt;code&gt;after-change-major-mode-hook&lt;/code&gt;. It does this by calling &lt;code&gt;run-mode-hooks&lt;/code&gt;. If the major mode is a derived mode, that is if it calls another major mode (the parent mode) in its body, it should do this inside &lt;code&gt;delay-mode-hooks&lt;/code&gt; so that the parent won&amp;rsquo;t run these hooks itself. Instead, the derived mode&amp;rsquo;s call to &lt;code&gt;run-mode-hooks&lt;/code&gt; runs the parent&amp;rsquo;s mode hook too. See &lt;a href=&quot;major-mode-conventions#Major-Mode-Conventions&quot;&gt;Major Mode Conventions&lt;/a&gt;.</source>
          <target state="translated">모든 메이저 모드 명령은 모드 독립적 인 일반 후크 &lt;code&gt;change-major-mode-after-body-hook&lt;/code&gt; , 해당 모드 후크 및 일반 후크 &lt;code&gt;after-change-major-mode-hook&lt;/code&gt; 을 실행하여 완료해야합니다 . &lt;code&gt;run-mode-hooks&lt;/code&gt; 를 호출하여이를 수행합니다 . 주 모드가 파생 모드 인 경우, 즉 본문에서 다른 주 모드 (부모 모드)를 호출 하는 경우 부모가 이러한 후크를 실행하지 않도록 &lt;code&gt;delay-mode-hooks&lt;/code&gt; 내에서이를 수행해야 합니다. 대신, 파생 모드의 &lt;code&gt;run-mode-hooks&lt;/code&gt; 호출 은 부모의 모드 후크도 실행합니다. &lt;a href=&quot;major-mode-conventions#Major-Mode-Conventions&quot;&gt;주요 모드 규칙을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1c9653498e3b20cbe78e73bc0fdc2179df100df9" translate="yes" xml:space="preserve">
          <source>Every object belongs to at least one type. Objects of the same type have similar structures and may usually be used in the same contexts. Types can overlap, and objects can belong to two or more types. Consequently, we can ask whether an object belongs to a particular type, but not for &lt;em&gt;the&lt;/em&gt; type of an object.</source>
          <target state="translated">모든 개체는 하나 이상의 유형에 속합니다. 동일한 유형의 객체는 유사한 구조를 가지며 일반적으로 동일한 컨텍스트에서 사용될 수 있습니다. 유형은 겹칠 수 있으며 객체는 둘 이상의 유형에 속할 수 있습니다. 결과적으로 객체가 특정 유형에 속하는지 여부를 물을 수 있지만 객체 유형에는 &lt;em&gt;해당&lt;/em&gt; 되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="741e3f11f682581bbfa9d4ff31815dc0fd76e81e" translate="yes" xml:space="preserve">
          <source>Every prefix of &lt;var&gt;key&lt;/var&gt; must be a prefix key (i.e., bound to a keymap) or undefined; otherwise an error is signaled. If some prefix of &lt;var&gt;key&lt;/var&gt; is undefined, then &lt;code&gt;define-key&lt;/code&gt; defines it as a prefix key so that the rest of &lt;var&gt;key&lt;/var&gt; can be defined as specified.</source>
          <target state="translated">&lt;var&gt;key&lt;/var&gt; 모든 접두사는 접두사 키 (즉, 키맵에 바인딩)이거나 정의되지 않아야합니다. 그렇지 않으면 오류가 표시됩니다. &lt;var&gt;key&lt;/var&gt; 일부 접두사 가 정의되지 않은 경우 &lt;code&gt;define-key&lt;/code&gt; 는이를 접두사 키로 정의하여 나머지 &lt;var&gt;key&lt;/var&gt; 가 지정된대로 정의 될 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="15e2f567ff3384e03f5cd1704a548718ea84af68" translate="yes" xml:space="preserve">
          <source>Every process also has a property list that you can use to store miscellaneous values associated with the process.</source>
          <target state="translated">모든 프로세스에는 프로세스와 관련된 기타 값을 저장하는 데 사용할 수있는 속성 목록도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9348b58eef15df85250fac36cefc612c81471e8c" translate="yes" xml:space="preserve">
          <source>Every successful search sets the match data. Therefore, you should query the match data immediately after searching, before calling any other function that might perform another search. Alternatively, you may save and restore the match data (see &lt;a href=&quot;saving-match-data#Saving-Match-Data&quot;&gt;Saving Match Data&lt;/a&gt;) around the call to functions that could perform another search. Or use the functions that explicitly do not modify the match data; e.g., &lt;code&gt;string-match-p&lt;/code&gt;.</source>
          <target state="translated">모든 성공적인 검색은 일치 데이터를 설정합니다. 따라서 다른 검색을 수행 할 수있는 다른 함수를 호출하기 전에 검색 직후 일치 데이터를 쿼리해야합니다. 또는 다른 검색을 수행 할 수있는 함수에 대한 호출 주변의 일치 데이터를 저장하고 복원 할 수 있습니다 (일치 데이터 &lt;a href=&quot;saving-match-data#Saving-Match-Data&quot;&gt;저장&lt;/a&gt; 참조 ). 또는 명시 적으로 일치 데이터를 수정하지 않는 함수를 사용하십시오. 예 : &lt;code&gt;string-match-p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf2a849c7b6f42e5bfdaf89a7b78d380bfa41cce" translate="yes" xml:space="preserve">
          <source>Every warning has a textual message, which explains the problem for the user, and a &lt;em&gt;severity level&lt;/em&gt; which is a symbol. Here are the possible severity levels, in order of decreasing severity, and their meanings:</source>
          <target state="translated">모든 경고에는 사용자의 문제를 설명하는 텍스트 메시지와 기호 인 &lt;em&gt;심각도 수준&lt;/em&gt; 이 있습니다. 심각도가 감소하는 순서대로 가능한 심각도 수준과 그 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b06efe9605d2c90f007fc010872332a9b840961c" translate="yes" xml:space="preserve">
          <source>Examining Buffer Contents</source>
          <target state="translated">버퍼 내용물 검사</target>
        </trans-unit>
        <trans-unit id="45de05e58932916bd458b107b6343320f7d62237" translate="yes" xml:space="preserve">
          <source>Examining Text Near Point</source>
          <target state="translated">지점 근처의 텍스트 검사</target>
        </trans-unit>
        <trans-unit id="0ef602781fba6e74f50b4c878856bf68c5243da7" translate="yes" xml:space="preserve">
          <source>Examining Text Properties</source>
          <target state="translated">텍스트 속성 검토</target>
        </trans-unit>
        <trans-unit id="ffc4525aba86e7e1e32a1dab1de11593e19e93f5" translate="yes" xml:space="preserve">
          <source>Examining and changing text in buffers.</source>
          <target state="translated">버퍼의 텍스트 검사 및 변경.</target>
        </trans-unit>
        <trans-unit id="56da633be7707f1febca2c7cdb6540149025c566" translate="yes" xml:space="preserve">
          <source>Examining text in a general fashion.</source>
          <target state="translated">일반적인 방식으로 텍스트를 검토합니다.</target>
        </trans-unit>
        <trans-unit id="7fcc7cce4f2ee556e73fd69281d3f8ec3d660954" translate="yes" xml:space="preserve">
          <source>Examining text in the vicinity of point.</source>
          <target state="translated">포인트 주변의 텍스트를 조사합니다.</target>
        </trans-unit>
        <trans-unit id="1810f73a9a2cf8433323cb7d681a9b461da5f4b3" translate="yes" xml:space="preserve">
          <source>Examining values of variables whose names are known only at run time.</source>
          <target state="translated">이름이 런타임에만 알려진 변수의 값을 조사합니다.</target>
        </trans-unit>
        <trans-unit id="000637ace4c7e7e66d920473418818b732694e21" translate="yes" xml:space="preserve">
          <source>Example of using Ewoc.</source>
          <target state="translated">Ewoc 사용 예.</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="42589f3ebaf21a748c64768b7db98352cce25abd" translate="yes" xml:space="preserve">
          <source>Example: &lt;code&gt;(= 42)&lt;/code&gt; In this example, the function is &lt;code&gt;=&lt;/code&gt;, &lt;var&gt;n&lt;/var&gt; is one, and the actual function call becomes: &lt;code&gt;(=&amp;nbsp;42&amp;nbsp;&lt;var&gt;expval&lt;/var&gt;)&lt;/code&gt;.</source>
          <target state="translated">예 : &lt;code&gt;(= 42)&lt;/code&gt; 이 예에서 함수는 &lt;code&gt;=&lt;/code&gt; 이고 &lt;var&gt;n&lt;/var&gt; 은 1이며 실제 함수 호출은 &lt;code&gt;(=&amp;nbsp;42&amp;nbsp;&lt;var&gt;expval&lt;/var&gt;)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c88d90029667f9c1b344d2029b2e93ff4a4a6be8" translate="yes" xml:space="preserve">
          <source>Example: &lt;code&gt;(lambda (n) (= 42 n))&lt;/code&gt;</source>
          <target state="translated">예 : &lt;code&gt;(lambda (n) (= 42 n))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6ad16a009e86ef75fd3de8e2ad5f092a5fca883d" translate="yes" xml:space="preserve">
          <source>Example: &lt;code&gt;integerp&lt;/code&gt;</source>
          <target state="translated">예 : &lt;code&gt;integerp&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="24b7ed5ddb195050534d0fab31090b455e27e26a" translate="yes" xml:space="preserve">
          <source>Example: Advantage Over &lt;code&gt;cl-case&lt;/code&gt;</source>
          <target state="translated">예 : &lt;code&gt;cl-case&lt;/code&gt; 에 비해 장점</target>
        </trans-unit>
        <trans-unit id="3ad7525bc727bae6ac350fa4ed968eaf0ca64284" translate="yes" xml:space="preserve">
          <source>Example: Reformulation with &lt;code&gt;pcase&lt;/code&gt;</source>
          <target state="translated">예 : &lt;code&gt;pcase&lt;/code&gt; 를 사용한 재구성</target>
        </trans-unit>
        <trans-unit id="7e097d720176885bcac5b1b5a1c82a40e2515d3c" translate="yes" xml:space="preserve">
          <source>Example: Using &lt;code&gt;and&lt;/code&gt;</source>
          <target state="translated">예 : &lt;code&gt;and&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="08d2dd1f8c7a3d92fa37946a0f154ebb3d4070aa" translate="yes" xml:space="preserve">
          <source>Examples in this manual indicate printed text with &amp;lsquo;</source>
          <target state="translated">이 설명서의 예는 '</target>
        </trans-unit>
        <trans-unit id="03eb4cb803b87579b4c90d6f201fca238d7fda68" translate="yes" xml:space="preserve">
          <source>Examples of Lisp code are formatted like this: &lt;code&gt;(list 1 2 3)&lt;/code&gt;. Names that represent metasyntactic variables, or arguments to a function being described, are formatted like this: &lt;var&gt;first-number&lt;/var&gt;.</source>
          <target state="translated">Lisp 코드의 예는 다음과 같이 형식화됩니다. &lt;code&gt;(list 1 2 3)&lt;/code&gt; . 메타 구문 변수를 나타내는 이름 또는 설명되는 함수에 대한 인수는 &lt;var&gt;first-number&lt;/var&gt; 와 같은 형식 입니다.</target>
        </trans-unit>
        <trans-unit id="9994e088a00d8a86302cb44924d52af48350bbaf" translate="yes" xml:space="preserve">
          <source>Examples of Using interactive</source>
          <target state="translated">대화 형 사용의 예</target>
        </trans-unit>
        <trans-unit id="94acd1dafcec67a5c71f53fbacda5ace7493adce" translate="yes" xml:space="preserve">
          <source>Examples of catch and throw</source>
          <target state="translated">잡기와 던지기의 예</target>
        </trans-unit>
        <trans-unit id="924f7fb06848c12124360cb9472532a6fc0fd107" translate="yes" xml:space="preserve">
          <source>Examples of how to read interactive arguments.</source>
          <target state="translated">대화 형 인수를 읽는 방법의 예입니다.</target>
        </trans-unit>
        <trans-unit id="0bf2185579aee4ae51b375504b158484ef051f7f" translate="yes" xml:space="preserve">
          <source>Examples of the lists for mouse events.</source>
          <target state="translated">마우스 이벤트 목록의 예.</target>
        </trans-unit>
        <trans-unit id="0856690c7b7cf58d003b7c079a6b26fd94d77bca" translate="yes" xml:space="preserve">
          <source>Examples to explain the precedence of action functions.</source>
          <target state="translated">액션 함수의 우선 순위를 설명하는 예.</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="ea83b89ce972bd83b6987e662353810d2585216a" translate="yes" xml:space="preserve">
          <source>Except where noted, these functions also accept internal windows as arguments. Resizing an internal window causes its child windows to be resized to fit the same space.</source>
          <target state="translated">언급 된 경우를 제외하고 이러한 함수는 내부 창도 인수로 허용합니다. 내부 창 크기를 조정하면 자식 창 크기가 같은 공간에 맞게 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="514c2777c3336bd01dec12407d7149cf0ec4b13b" translate="yes" xml:space="preserve">
          <source>Excess Close Parentheses</source>
          <target state="translated">초과 닫는 괄호</target>
        </trans-unit>
        <trans-unit id="4329f0811884f882f9183865d3de5482e9905a4d" translate="yes" xml:space="preserve">
          <source>Excess Open Parentheses</source>
          <target state="translated">초과 여는 괄호</target>
        </trans-unit>
        <trans-unit id="6996ee18eb4fe50e65e1865f16079fb735e17b31" translate="yes" xml:space="preserve">
          <source>Exclude minibuffer-only frames.</source>
          <target state="translated">미니 버퍼 전용 프레임을 제외합니다.</target>
        </trans-unit>
        <trans-unit id="102dbcf894945a5c748834e8214903c96d894d18" translate="yes" xml:space="preserve">
          <source>Excursions</source>
          <target state="translated">Excursions</target>
        </trans-unit>
        <trans-unit id="a4832fdf2fe9ae09bb2f1073e96b0875872b2167" translate="yes" xml:space="preserve">
          <source>Execute &lt;code&gt;(require '&lt;var&gt;feature&lt;/var&gt;)&lt;/code&gt; when your saved customizations set the value of this item. &lt;var&gt;feature&lt;/var&gt; should be a symbol.</source>
          <target state="translated">저장된 사용자 정의가이 항목의 값을 설정할 때 실행 &lt;code&gt;(require '&lt;var&gt;feature&lt;/var&gt;)&lt;/code&gt; 합니다. &lt;var&gt;feature&lt;/var&gt; 은 기호 여야합니다.</target>
        </trans-unit>
        <trans-unit id="e05b25ea5b95dc62329004b221749a289d2253d2" translate="yes" xml:space="preserve">
          <source>Execute &lt;var&gt;body&lt;/var&gt; once for each element of &lt;var&gt;list&lt;/var&gt;, on each iteration performing a destructuring binding of variables in &lt;var&gt;pattern&lt;/var&gt; to the values of the corresponding subfields of the element of &lt;var&gt;list&lt;/var&gt;. The bindings are performed as if by &lt;code&gt;pcase-let&lt;/code&gt;. When &lt;var&gt;pattern&lt;/var&gt; is a simple variable, this ends up being equivalent to &lt;code&gt;dolist&lt;/code&gt; (see &lt;a href=&quot;iteration#Iteration&quot;&gt;Iteration&lt;/a&gt;).</source>
          <target state="translated">&lt;var&gt;list&lt;/var&gt; 의 각 요소에 대해 &lt;var&gt;body&lt;/var&gt; 를 한 번씩 실행하고 , 각 반복 에서 &lt;var&gt;list&lt;/var&gt; 요소의 해당 하위 필드 값에 대한 &lt;var&gt;pattern&lt;/var&gt; 의 변수 구조 해제 바인딩을 수행 합니다 . 바인딩은 &lt;code&gt;pcase-let&lt;/code&gt; 처럼 수행됩니다 . 되면 &lt;var&gt;pattern&lt;/var&gt; 단순 변수이며, 등가 인 것을이 단부 &lt;code&gt;dolist&lt;/code&gt; (참조 &lt;a href=&quot;iteration#Iteration&quot;&gt;반복&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="f5bd2d24d188437ee6eefc900e5ffaee2dccd4a0" translate="yes" xml:space="preserve">
          <source>Execute &lt;var&gt;body&lt;/var&gt; pretending it does not modify the buffer. This includes checking whether the buffer&amp;rsquo;s file is locked (see &lt;a href=&quot;file-locks#File-Locks&quot;&gt;File Locks&lt;/a&gt;), running buffer modification hooks (see &lt;a href=&quot;change-hooks#Change-Hooks&quot;&gt;Change Hooks&lt;/a&gt;), etc. Note that if &lt;var&gt;body&lt;/var&gt; actually modifies the buffer text, its undo data may become corrupted.</source>
          <target state="translated">실행 &lt;var&gt;body&lt;/var&gt; 은 버퍼를 수정하지 않습니다 척. 여기에는 버퍼의 파일이 잠겨 있는지 확인 ( &lt;a href=&quot;file-locks#File-Locks&quot;&gt;파일 잠금&lt;/a&gt; 참조 ), 버퍼 수정 후크 실행 ( &lt;a href=&quot;change-hooks#Change-Hooks&quot;&gt;변경 후크&lt;/a&gt; 참조 ) 등이 포함됩니다. &lt;var&gt;body&lt;/var&gt; 실제로 버퍼 텍스트를 수정하면 실행 취소 데이터가 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cde77cd352d5005fa89463ae64af4ea589ac7e5d" translate="yes" xml:space="preserve">
          <source>Execute &lt;var&gt;body&lt;/var&gt;, but give up after &lt;var&gt;seconds&lt;/var&gt; seconds. If &lt;var&gt;body&lt;/var&gt; finishes before the time is up, &lt;code&gt;with-timeout&lt;/code&gt; returns the value of the last form in &lt;var&gt;body&lt;/var&gt;. If, however, the execution of &lt;var&gt;body&lt;/var&gt; is cut short by the timeout, then &lt;code&gt;with-timeout&lt;/code&gt; executes all the &lt;var&gt;timeout-forms&lt;/var&gt; and returns the value of the last of them.</source>
          <target state="translated">&lt;var&gt;body&lt;/var&gt; 를 실행 하지만 &lt;var&gt;seconds&lt;/var&gt; 초 후에 포기하십시오 . 만약 &lt;var&gt;body&lt;/var&gt; 마감 시간이 최대 전에 &lt;code&gt;with-timeout&lt;/code&gt; 수익률의 마지막 형태의 값 &lt;var&gt;body&lt;/var&gt; . 그러나 &lt;var&gt;body&lt;/var&gt; 실행이 타임 아웃에 의해 짧아지면 &lt;code&gt;with-timeout&lt;/code&gt; 은 모든 &lt;var&gt;timeout-forms&lt;/var&gt; 실행 하고 마지막 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fd13bad071682649e8d24fe41b2c2501dc4dc2ba" translate="yes" xml:space="preserve">
          <source>Executing &lt;code&gt;throw&lt;/code&gt; exits all Lisp constructs up to the matching &lt;code&gt;catch&lt;/code&gt;, including function calls. When binding constructs such as &lt;code&gt;let&lt;/code&gt; or function calls are exited in this way, the bindings are unbound, just as they are when these constructs exit normally (see &lt;a href=&quot;local-variables#Local-Variables&quot;&gt;Local Variables&lt;/a&gt;). Likewise, &lt;code&gt;throw&lt;/code&gt; restores the buffer and position saved by &lt;code&gt;save-excursion&lt;/code&gt; (see &lt;a href=&quot;excursions#Excursions&quot;&gt;Excursions&lt;/a&gt;), and the narrowing status saved by &lt;code&gt;save-restriction&lt;/code&gt;. It also runs any cleanups established with the &lt;code&gt;unwind-protect&lt;/code&gt; special form when it exits that form (see &lt;a href=&quot;cleanups#Cleanups&quot;&gt;Cleanups&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;throw&lt;/code&gt; 를 실행 하면 함수 호출을 포함 하여 일치하는 &lt;code&gt;catch&lt;/code&gt; 까지 모든 Lisp 구문이 종료됩니다 . &lt;code&gt;let&lt;/code&gt; 또는 function 호출 과 같은 바인딩 구문 이 이런 방식으로 종료되면 이러한 구문이 정상적으로 종료 될 때와 마찬가지로 바인딩이 바인딩 해제됩니다 ( &lt;a href=&quot;local-variables#Local-Variables&quot;&gt;로컬 변수&lt;/a&gt; 참조 ). 마찬가지로 &lt;code&gt;throw&lt;/code&gt; 는 &lt;code&gt;save-excursion&lt;/code&gt; ( &lt;a href=&quot;excursions#Excursions&quot;&gt;Excursions&lt;/a&gt; 참조 )에 의해 저장된 버퍼 및 위치 와 &lt;code&gt;save-restriction&lt;/code&gt; 에 의해 저장된 축소 상태를 복원합니다 . 또한 설립 어떤 정리 실행 &lt;code&gt;unwind-protect&lt;/code&gt; 는 그 형태를 (참조 종료 할 때 특별한 양식을 &lt;a href=&quot;cleanups#Cleanups&quot;&gt;클린업을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d74bb2e60e4d3fb084ead764f7b15124485c059e" translate="yes" xml:space="preserve">
          <source>Executing a program can also try adding suffixes to the specified name:</source>
          <target state="translated">프로그램을 실행하면 지정된 이름에 접미사를 추가 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ebee3b642b4f0ebb9781d2c0a16802f1c2e57b30" translate="yes" xml:space="preserve">
          <source>Executing commands within Edebug can change the key sequence that would be returned by &lt;code&gt;this-command-keys&lt;/code&gt;, and there is no way to reset the key sequence from Lisp.</source>
          <target state="translated">Edebug 내에서 명령을 실행 &lt;code&gt;this-command-keys&lt;/code&gt; 에서 반환되는 키 시퀀스가 ​​변경 될 수 있으며 Lisp에서 키 시퀀스를 재설정 할 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="1e481e9e93ff9fde3c47da4e2f9bd0a8821d11ef" translate="yes" xml:space="preserve">
          <source>Executing the function itself evaluates its body; this does involve symbol function indirection when calling &lt;code&gt;erste&lt;/code&gt;.</source>
          <target state="translated">함수 자체를 실행하면 본문이 평가됩니다. 이것은 &lt;code&gt;erste&lt;/code&gt; 를 호출 할 때 기호 함수 간접을 포함 합니다.</target>
        </trans-unit>
        <trans-unit id="14e5e55e3c46fc56ef37e001f4826a1009a88b69" translate="yes" xml:space="preserve">
          <source>Execution modes, stopping more or less often.</source>
          <target state="translated">실행 모드, 다소 자주 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="97b908e56c8affb6f198ab184ff139df70822588" translate="yes" xml:space="preserve">
          <source>Exit the debugger and continue execution. This resumes execution of the program as if the debugger had never been entered (aside from any side-effects that you caused by changing variable values or data structures while inside the debugger).</source>
          <target state="translated">디버거를 종료하고 실행을 계속하십시오. 이렇게하면 디버거가 입력 된 적이없는 것처럼 프로그램 실행이 재개됩니다 (디버거 내부에서 변수 값 또는 데이터 구조 변경으로 인한 부작용 제외).</target>
        </trans-unit>
        <trans-unit id="4da4762e60930fee76bfddad9df8fddb66bc010b" translate="yes" xml:space="preserve">
          <source>Exited</source>
          <target state="translated">Exited</target>
        </trans-unit>
        <trans-unit id="8999a6a28c3f6fde180e5adb92439670504be038" translate="yes" xml:space="preserve">
          <source>Exiting Emacs irreversibly.</source>
          <target state="translated">Emacs를 되돌릴 수 없게 종료합니다.</target>
        </trans-unit>
        <trans-unit id="e40779f9dbf7b9155821dddbd56974aefa46b434" translate="yes" xml:space="preserve">
          <source>Exiting Emacs reversibly.</source>
          <target state="translated">Emacs를 가역적으로 종료합니다.</target>
        </trans-unit>
        <trans-unit id="2a714eb1094cc86f04db1a930bf20e2cc4723b6e" translate="yes" xml:space="preserve">
          <source>Expand all the forms abbreviated with &amp;ldquo;...&amp;rdquo; in the frame at point.</source>
          <target state="translated">프레임에서 &quot;...&quot;로 축약 된 모든 양식을 포인트에서 확장합니다.</target>
        </trans-unit>
        <trans-unit id="c39165889ae82de3f3543cbdf660f6e4a5da6438" translate="yes" xml:space="preserve">
          <source>Expanding</source>
          <target state="translated">Expanding</target>
        </trans-unit>
        <trans-unit id="4c742e3f2d52d838216750f0562eaf969f0a39f0" translate="yes" xml:space="preserve">
          <source>Expansion of a Macro Call</source>
          <target state="translated">매크로 호출 확장</target>
        </trans-unit>
        <trans-unit id="6ca590c42a4d990c1e2fa2ffaa567f1164a66dcf" translate="yes" xml:space="preserve">
          <source>Explanation of terms we use in this manual.</source>
          <target state="translated">이 설명서에서 사용하는 용어에 대한 설명.</target>
        </trans-unit>
        <trans-unit id="5fdf6d25bdf76c29c879fee3e893bfe3162da24c" translate="yes" xml:space="preserve">
          <source>Explicit Encoding and Decoding</source>
          <target state="translated">명시 적 인코딩 및 디코딩</target>
        </trans-unit>
        <trans-unit id="2bdf1bdb932b1c4ad868d411e4ded7400f765e63" translate="yes" xml:space="preserve">
          <source>Explicit Entry to the Debugger</source>
          <target state="translated">디버거에 대한 명시 적 항목</target>
        </trans-unit>
        <trans-unit id="9a007c1d995b6d8073a9bc77022ebe07a3a0f5f8" translate="yes" xml:space="preserve">
          <source>Explicit Nonlocal Exits: catch and throw</source>
          <target state="translated">명시 적 비 로컬 이탈 : catch 및 throw</target>
        </trans-unit>
        <trans-unit id="1ad1ce0b3e7833459b128fbf4ce571d7a46890bd" translate="yes" xml:space="preserve">
          <source>Explicit control structures make possible an order of execution other than sequential.</source>
          <target state="translated">명시 적 제어 구조는 순차적이 아닌 실행 순서를 가능하게합니다.</target>
        </trans-unit>
        <trans-unit id="088345198c12c42185dc050f609431188d5e2c78" translate="yes" xml:space="preserve">
          <source>Explicitly displaying text in the echo area.</source>
          <target state="translated">에코 영역에 텍스트를 명시 적으로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="a689623f299989df674feba29e4f28665efe9319" translate="yes" xml:space="preserve">
          <source>Explicitly rounding floating-point numbers.</source>
          <target state="translated">부동 소수점 숫자를 명시 적으로 반올림합니다.</target>
        </trans-unit>
        <trans-unit id="6efc43ab25f6f82b115afa6cd6647daff5d515b8" translate="yes" xml:space="preserve">
          <source>Expression prefixes: &amp;lsquo;</source>
          <target state="translated">식 접두사 : '</target>
        </trans-unit>
        <trans-unit id="3ded6265cc857e0826a7951dc567e485d9688f10" translate="yes" xml:space="preserve">
          <source>Expressions whose values are displayed each time you enter Edebug.</source>
          <target state="translated">Edebug를 입력 할 때마다 값이 표시되는 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="828741415e596cc1348b75ea71ac729d3cf9801c" translate="yes" xml:space="preserve">
          <source>Extended File Attributes</source>
          <target state="translated">확장 파일 속성</target>
        </trans-unit>
        <trans-unit id="faef1b43d6020947447489d47a97113bf052f09e" translate="yes" xml:space="preserve">
          <source>Extended Menu Items</source>
          <target state="translated">확장 메뉴 항목</target>
        </trans-unit>
        <trans-unit id="79403e6568f432fc5806885c7a96d9f746bf269e" translate="yes" xml:space="preserve">
          <source>Extended file attributes for access control.</source>
          <target state="translated">액세스 제어를위한 확장 파일 속성.</target>
        </trans-unit>
        <trans-unit id="c69f5fcd1e924179660b0f849a1edfca16c76ff3" translate="yes" xml:space="preserve">
          <source>Extending pcase</source>
          <target state="translated">pcase 확장</target>
        </trans-unit>
        <trans-unit id="dcbd361d67335f13d72aa72e80e9b5074251cb85" translate="yes" xml:space="preserve">
          <source>Extending the concept of variables.</source>
          <target state="translated">변수의 개념 확장.</target>
        </trans-unit>
        <trans-unit id="f26cbcbfd3a60f50e69a2203bf39a117b6f7edba" translate="yes" xml:space="preserve">
          <source>External Border</source>
          <target state="translated">외부 테두리</target>
        </trans-unit>
        <trans-unit id="559369521d2b02178eca19a89ab3af270c529587" translate="yes" xml:space="preserve">
          <source>External borders don&amp;rsquo;t exist on text terminal frames. For graphical frames, their display can be suppressed by setting the &lt;code&gt;override-redirect&lt;/code&gt; or &lt;code&gt;undecorated&lt;/code&gt; frame parameter (see &lt;a href=&quot;management-parameters#Management-Parameters&quot;&gt;Management Parameters&lt;/a&gt;).</source>
          <target state="translated">텍스트 터미널 프레임에는 외부 테두리가 없습니다. 그래픽 프레임의 경우 &lt;code&gt;override-redirect&lt;/code&gt; 또는 &lt;code&gt;undecorated&lt;/code&gt; 프레임 매개 변수 를 설정하여 해당 표시를 억제 할 수 있습니다 ( &lt;a href=&quot;management-parameters#Management-Parameters&quot;&gt;관리 매개 변수&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="c0b99104aa13dc6a254700daf612011b95c664e0" translate="yes" xml:space="preserve">
          <source>Extra characters used in variable and command names along with word constituents. Examples include the characters &amp;lsquo;</source>
          <target state="translated">단어 구성 요소와 함께 변수 및 명령 이름에 사용되는 추가 문자. 예를 들어 '</target>
        </trans-unit>
        <trans-unit id="11971c4e6df4236f6e2a88fa65abcd7f3fc95e4e" translate="yes" xml:space="preserve">
          <source>Extra options affecting how buffers are displayed.</source>
          <target state="translated">버퍼 표시 방법에 영향을주는 추가 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="62794c2ea3b2113cb2c52f416844469a23bd3da4" translate="yes" xml:space="preserve">
          <source>Extracting the pieces of a list.</source>
          <target state="translated">목록의 일부를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="e1a1e9d545fa6732404318124fd97eb48df0b89c" translate="yes" xml:space="preserve">
          <source>Extraction of multiple values stored in an object is known as &lt;em&gt;destructuring&lt;/em&gt;. Using &lt;code&gt;pcase&lt;/code&gt; patterns allows to perform &lt;em&gt;destructuring binding&lt;/em&gt;, which is similar to a local binding (see &lt;a href=&quot;local-variables#Local-Variables&quot;&gt;Local Variables&lt;/a&gt;), but gives values to multiple elements of a variable by extracting those values from an object of compatible structure.</source>
          <target state="translated">객체에 저장된 여러 값의 추출라고도 &lt;em&gt;destructuring&lt;/em&gt; . 사용 &lt;code&gt;pcase&lt;/code&gt; 의 패턴은 수행 할 수 있도록 &lt;em&gt;결합 destructuring&lt;/em&gt; (참조 바인딩 로컬 유사 &lt;a href=&quot;local-variables#Local-Variables&quot;&gt;로컬 변수&lt;/a&gt; )하지만 호환 구조의 목적에서 그 값을 추출하여 가변의 다중 요소에 대한 값을 제공한다.</target>
        </trans-unit>
        <trans-unit id="e69f20e9f683920d3fb4329abd951e878b1f9372" translate="yes" xml:space="preserve">
          <source>F</source>
          <target state="translated">F</target>
        </trans-unit>
        <trans-unit id="88bfad9cfffeafd299a44d4daf979d57419a2621" translate="yes" xml:space="preserve">
          <source>F1</source>
          <target state="translated">F1</target>
        </trans-unit>
        <trans-unit id="b9c7614215c5bf3f22e0dd38d8c9a197b4432459" translate="yes" xml:space="preserve">
          <source>F11</source>
          <target state="translated">F11</target>
        </trans-unit>
        <trans-unit id="be3d820f356c0030f50fa290b419eb634ad7d08d" translate="yes" xml:space="preserve">
          <source>F3</source>
          <target state="translated">F3</target>
        </trans-unit>
        <trans-unit id="0b240bd1aef549aae787777e72c514ed278b4c9e" translate="yes" xml:space="preserve">
          <source>FIXME</source>
          <target state="translated">FIXME</target>
        </trans-unit>
        <trans-unit id="feab40e1fca77c7360ccca1481bb8ba5f919ce3a" translate="yes" xml:space="preserve">
          <source>FOO</source>
          <target state="translated">FOO</target>
        </trans-unit>
        <trans-unit id="d6cb99b2aaf9660672f786dca68ea38e17d6e0b1" translate="yes" xml:space="preserve">
          <source>FOO:</source>
          <target state="translated">FOO:</target>
        </trans-unit>
        <trans-unit id="e106961d692013d7e77bf986ab4ba215e15a1efd" translate="yes" xml:space="preserve">
          <source>Face Attribute Functions</source>
          <target state="translated">얼굴 속성 함수</target>
        </trans-unit>
        <trans-unit id="654864cf31f7692b390d6c92e9df53f991dd3be1" translate="yes" xml:space="preserve">
          <source>Face Attributes</source>
          <target state="translated">얼굴 속성</target>
        </trans-unit>
        <trans-unit id="d5e1cfea3023a6e8aa7a2742fbea8b8f08c0752f" translate="yes" xml:space="preserve">
          <source>Face Remapping</source>
          <target state="translated">얼굴 다시 매핑</target>
        </trans-unit>
        <trans-unit id="fdbb8fef1941523eb44ab9acd11a20e97debad36" translate="yes" xml:space="preserve">
          <source>Faces</source>
          <target state="translated">Faces</target>
        </trans-unit>
        <trans-unit id="819ff0ee4f320c1983239b6c9cbfadace5356c75" translate="yes" xml:space="preserve">
          <source>Faces for Font Lock</source>
          <target state="translated">글꼴 잠금 용 얼굴</target>
        </trans-unit>
        <trans-unit id="f16ad3d9b8a81e142c7177a85f1722ea3c8ecb24" translate="yes" xml:space="preserve">
          <source>Faces that are defined by default.</source>
          <target state="translated">기본적으로 정의 된면.</target>
        </trans-unit>
        <trans-unit id="fc338f87a058158eb824b53705961801516a9460" translate="yes" xml:space="preserve">
          <source>Features</source>
          <target state="translated">Features</target>
        </trans-unit>
        <trans-unit id="b332d3834aba40f3287a2b6bec41f4773cb1f1e7" translate="yes" xml:space="preserve">
          <source>Features for controlling the screen display.</source>
          <target state="translated">화면 표시 제어 기능.</target>
        </trans-unit>
        <trans-unit id="b9ae81895850ce8ada8529e0f5da57ea2c7986e1" translate="yes" xml:space="preserve">
          <source>Fields are added in a most to least significant order, so if the adjustment described above happens, it happens before adding days, hours, minutes or seconds.</source>
          <target state="translated">필드는 최상위에서 최하위 순서로 추가되므로 위에서 설명한 조정이 발생하면 일, 시간, 분 또는 초를 추가하기 전에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="84a27191b9d9fa3be49740ecbafdc1df51bea9cb" translate="yes" xml:space="preserve">
          <source>File Attributes</source>
          <target state="translated">파일 속성</target>
        </trans-unit>
        <trans-unit id="634af05bec00faebb5b301b9d511d8f08119591f" translate="yes" xml:space="preserve">
          <source>File Format Conversion</source>
          <target state="translated">파일 형식 변환</target>
        </trans-unit>
        <trans-unit id="394286763d09a40da21d7cdc6d10dc5ed278d4c0" translate="yes" xml:space="preserve">
          <source>File Local Variables</source>
          <target state="translated">파일 로컬 변수</target>
        </trans-unit>
        <trans-unit id="6945b1782b048888e914cc457381bec7925fce8d" translate="yes" xml:space="preserve">
          <source>File Locks</source>
          <target state="translated">파일 잠금</target>
        </trans-unit>
        <trans-unit id="8b6acea7a6a01e7f88e54a9260ec2af3a5357533" translate="yes" xml:space="preserve">
          <source>File Name Completion</source>
          <target state="translated">파일 이름 완성</target>
        </trans-unit>
        <trans-unit id="7451ac3d98ad2761e27cb7d7298ba6cd2cd31381" translate="yes" xml:space="preserve">
          <source>File Name Components</source>
          <target state="translated">파일 이름 구성 요소</target>
        </trans-unit>
        <trans-unit id="6e75764f6be72d64faaa7cd05889744083a1ffec" translate="yes" xml:space="preserve">
          <source>File Names</source>
          <target state="translated">파일 이름</target>
        </trans-unit>
        <trans-unit id="30fb1a4fd7f24b635466fa19633b5ffc1d1351f4" translate="yes" xml:space="preserve">
          <source>File local variables</source>
          <target state="translated">파일 지역 변수</target>
        </trans-unit>
        <trans-unit id="142ecb52f059b39536000c672c2af8e5e50fb47f" translate="yes" xml:space="preserve">
          <source>File mode specification error</source>
          <target state="translated">파일 모드 사양 오류</target>
        </trans-unit>
        <trans-unit id="41c49533612d0c04bef768e396e0a06eacbe8ed3" translate="yes" xml:space="preserve">
          <source>File notifications.</source>
          <target state="translated">파일 알림.</target>
        </trans-unit>
        <trans-unit id="abef62b2302277610c559dcbd2657a6f25e0cf68" translate="yes" xml:space="preserve">
          <source>File passwd is write-protected; try to save anyway? (yes or no)</source>
          <target state="translated">파일 암호는 쓰기 금지되어 있습니다. 어쨌든 저장하려고? (예 혹은 아니오)</target>
        </trans-unit>
        <trans-unit id="0fa423ea7a3de0b12d21f012b22a7141624872d0" translate="yes" xml:space="preserve">
          <source>File sizes, modification times, etc.</source>
          <target state="translated">파일 크기, 수정 시간 등</target>
        </trans-unit>
        <trans-unit id="33af16411a6a89fe3e0022fccba0ce8d9a48c5c8" translate="yes" xml:space="preserve">
          <source>Filenames containing &amp;lsquo;</source>
          <target state="translated">'를 포함하는 파일 이름</target>
        </trans-unit>
        <trans-unit id="6ce6c512ea433a7fc5c8841628e7696cd0ff7f2b" translate="yes" xml:space="preserve">
          <source>Files</source>
          <target state="translated">Files</target>
        </trans-unit>
        <trans-unit id="b82fb55310cb97d45bdeb83d3caf9294bba6b7ec" translate="yes" xml:space="preserve">
          <source>Files and Secondary Storage</source>
          <target state="translated">파일 및 보조 저장소</target>
        </trans-unit>
        <trans-unit id="2b3e8a94ab0ab81e327337eb1fcbbfd8f921ecea" translate="yes" xml:space="preserve">
          <source>Files are generally referred to by their names, in Emacs as elsewhere. File names in Emacs are represented as strings. The functions that operate on a file all expect a file name argument.</source>
          <target state="translated">파일은 일반적으로 다른 곳과 마찬가지로 Emacs에서 이름으로 참조됩니다. Emacs의 파일 이름은 문자열로 표시됩니다. 파일에서 작동하는 함수는 모두 파일 이름 인수를 예상합니다.</target>
        </trans-unit>
        <trans-unit id="98325be45e57b01ea42841fb2dc63e31875877c1" translate="yes" xml:space="preserve">
          <source>Filling</source>
          <target state="translated">Filling</target>
        </trans-unit>
        <trans-unit id="8bfde07209f239be1569e3c825b6748d05c9a119" translate="yes" xml:space="preserve">
          <source>Filter functions accept output from the process.</source>
          <target state="translated">필터 함수는 프로세스의 출력을받습니다.</target>
        </trans-unit>
        <trans-unit id="9f75d8a170ee3ebac199d6e0e7cd5fd77da7cf96" translate="yes" xml:space="preserve">
          <source>Filters can get unibyte or multibyte strings.</source>
          <target state="translated">필터는 유니 바이트 또는 멀티 바이트 문자열을 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aba4d2683351badc888e236a277c1fd78263060b" translate="yes" xml:space="preserve">
          <source>Finalizer Type</source>
          <target state="translated">종료 자 유형</target>
        </trans-unit>
        <trans-unit id="a8947680fe3863262f3ab5559d9bd7d760ac2651" translate="yes" xml:space="preserve">
          <source>Finally you can toggle the display of scroll bars on all frames by customizing the variables &lt;code&gt;scroll-bar-mode&lt;/code&gt; and &lt;code&gt;horizontal-scroll-bar-mode&lt;/code&gt;.</source>
          <target state="translated">마지막으로 &lt;code&gt;scroll-bar-mode&lt;/code&gt; 및 &lt;code&gt;horizontal-scroll-bar-mode&lt;/code&gt; 변수를 사용자 정의하여 모든 프레임에서 스크롤 막대 표시를 전환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="74d402c732ad516d11a21de33899809c80cdeff8" translate="yes" xml:space="preserve">
          <source>Finally, &lt;var&gt;function-list&lt;/var&gt; is a list of functions for the mode command to call for additional setup. It calls these functions just before it runs the mode hook variable &lt;code&gt;&lt;var&gt;mode&lt;/var&gt;-hook&lt;/code&gt;.</source>
          <target state="translated">마지막으로 &lt;var&gt;function-list&lt;/var&gt; 는 모드 명령이 추가 설정을 위해 호출하는 함수 목록입니다. 모드 후크 변수 &lt;code&gt;&lt;var&gt;mode&lt;/var&gt;-hook&lt;/code&gt; 실행하기 직전에 이러한 함수를 호출 합니다 .</target>
        </trans-unit>
        <trans-unit id="c55ab6d71a9ad314809822d8b9060ed2f5013cf1" translate="yes" xml:space="preserve">
          <source>Finally, Emacs runs a normal hook that generalizes the behavior of &lt;code&gt;window-state-change-functions&lt;/code&gt;.</source>
          <target state="translated">마지막으로 Emacs는 &lt;code&gt;window-state-change-functions&lt;/code&gt; 의 동작을 일반화하는 일반 후크를 실행 합니다 .</target>
        </trans-unit>
        <trans-unit id="408f1373e50d76e430a57c26aa76f5dbd3e9c977" translate="yes" xml:space="preserve">
          <source>Finally, a newline can have a &lt;code&gt;line-spacing&lt;/code&gt; text or overlay property that can enlarge the default frame line spacing and the buffer local &lt;code&gt;line-spacing&lt;/code&gt; variable: if its value is larger than the buffer or frame defaults, that larger value is used instead, for the display line ending in that newline.</source>
          <target state="translated">마지막으로, 줄 바꿈은 기본 프레임 줄 간격과 버퍼 로컬 &lt;code&gt;line-spacing&lt;/code&gt; 변수를 확대 할 수있는 &lt;code&gt;line-spacing&lt;/code&gt; 텍스트 또는 오버레이 속성을 가질 수 있습니다 . 값이 버퍼 또는 프레임 기본값보다 크면 더 큰 값이 대신 사용됩니다. 그 개행으로 끝나는 표시 줄을 위해.</target>
        </trans-unit>
        <trans-unit id="0a8ca0bbf8ca5c11ee4c822e14ac4b1cc54e98f6" translate="yes" xml:space="preserve">
          <source>Finally, and optionally, the &lt;code&gt;jsonrpc-connection&lt;/code&gt; subclass should implement the &lt;code&gt;jsonrpc-shutdown&lt;/code&gt; and &lt;code&gt;jsonrpc-running-p&lt;/code&gt; methods if these concepts apply to the transport. If they do, then any system resources (e.g. processes, timers, etc.) used to listen for messages on the wire should be released in &lt;code&gt;jsonrpc-shutdown&lt;/code&gt;, i.e. they should only be needed while &lt;code&gt;jsonrpc-running-p&lt;/code&gt; is non-nil.</source>
          <target state="translated">마지막으로, 선택적으로 &lt;code&gt;jsonrpc-connection&lt;/code&gt; 서브 클래스는 이러한 개념이 전송에 적용되는 경우 &lt;code&gt;jsonrpc-shutdown&lt;/code&gt; 및 &lt;code&gt;jsonrpc-running-p&lt;/code&gt; 메소드를 구현해야합니다 . 만약 그렇다면, 유선에서 메시지를 수신하는 데 사용되는 모든 시스템 리소스 (예 : 프로세스, 타이머 등)는 &lt;code&gt;jsonrpc-shutdown&lt;/code&gt; 에서 해제되어야합니다 . 즉, &lt;code&gt;jsonrpc-running-p&lt;/code&gt; 가 nil이 아닌 동안에 만 필요해야합니다 .</target>
        </trans-unit>
        <trans-unit id="88b4ea5530a97f6f8fc1e3e4b10461e76b40fcec" translate="yes" xml:space="preserve">
          <source>Finally, here is an example of a stream that is a function, named &lt;code&gt;useless-stream&lt;/code&gt;. Before we use the stream, we initialize the variable &lt;code&gt;useless-list&lt;/code&gt; to a list of characters. Then each call to the function &lt;code&gt;useless-stream&lt;/code&gt; obtains the next character in the list or unreads a character by adding it to the front of the list.</source>
          <target state="translated">마지막으로 &lt;code&gt;useless-stream&lt;/code&gt; 이라는 함수 인 스트림의 예가 있습니다. 스트림을 사용하기 전에 &lt;code&gt;useless-list&lt;/code&gt; 변수 를 문자 목록 으로 초기화합니다 . 그런 다음 함수 &lt;code&gt;useless-stream&lt;/code&gt; 에 대한 각 호출 은 목록의 다음 문자를 얻거나 목록의 맨 앞에 추가하여 문자를 읽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e17f52480988f71b0601586b82009b1463b6a040" translate="yes" xml:space="preserve">
          <source>Finally, here is the major mode command for Lisp mode:</source>
          <target state="translated">마지막으로 Lisp 모드의 주요 모드 명령은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="860e5e3571f2ad47db3311a1348d075142701f7d" translate="yes" xml:space="preserve">
          <source>Finally, in many cases some conflicts will remain despite all efforts to restructure the grammar. Do not despair: while the parser cannot be made more clever, you can make the lexer as smart as you want. So, the solution is then to look at the tokens involved in the conflict and to split one of those tokens into 2 (or more) different tokens. E.g., if the grammar needs to distinguish between two incompatible uses of the token &lt;code&gt;&quot;begin&quot;&lt;/code&gt;, make the lexer return different tokens (say &lt;code&gt;&quot;begin-fun&quot;&lt;/code&gt; and &lt;code&gt;&quot;begin-plain&quot;&lt;/code&gt;) depending on which kind of &lt;code&gt;&quot;begin&quot;&lt;/code&gt; it finds. This pushes the work of distinguishing the different cases to the lexer, which will thus have to look at the surrounding text to find ad-hoc clues.</source>
          <target state="translated">마지막으로, 문법을 재구성하려는 모든 노력에도 불구하고 많은 경우에 일부 갈등이 남아 있습니다. 절망하지 마십시오. 파서를 더 영리하게 만들 수는 없지만 렉서를 원하는만큼 똑똑하게 만들 수 있습니다. 따라서 해결책은 충돌과 관련된 토큰을 살펴보고 해당 토큰 중 하나를 2 개 (또는 그 이상의) 다른 토큰으로 분할하는 것입니다. 예를 들어 문법이 &lt;code&gt;&quot;begin&quot;&lt;/code&gt; 토큰의 두 가지 호환되지 않는 사용을 구별해야하는 경우, 렉서 가 찾은 &lt;code&gt;&quot;begin&quot;&lt;/code&gt; 종류에 따라 다른 토큰 (예 : &lt;code&gt;&quot;begin-fun&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;begin-plain&quot;&lt;/code&gt; )을 반환하도록합니다 . 이것은 서로 다른 케이스를 구별하는 작업을 어휘 분석기로 밀어 붙이고, 따라서 임시 단서를 찾기 위해 주변 텍스트를 살펴 봐야합니다.</target>
        </trans-unit>
        <trans-unit id="9a2f5d53696c836d007bdbba2afcc8145ab8a69a" translate="yes" xml:space="preserve">
          <source>Finally, in the following example, only two of the three possible matches pass the predicate &lt;code&gt;test&lt;/code&gt; (the string &amp;lsquo;</source>
          <target state="translated">마지막으로 다음 예에서는 가능한 세 가지 일치 중 두 개만 조건 자 &lt;code&gt;test&lt;/code&gt; 통과합니다 (문자열 '</target>
        </trans-unit>
        <trans-unit id="85ffc0c0143744d4e2b8094b05c47afef3598d23" translate="yes" xml:space="preserve">
          <source>Finally, the &lt;code&gt;svg-image&lt;/code&gt; takes an SVG object as its argument and returns an image object suitable for use in functions like &lt;code&gt;insert-image&lt;/code&gt;.</source>
          <target state="translated">마지막으로 &lt;code&gt;svg-image&lt;/code&gt; 는 SVG 객체를 인수로 취하고 &lt;code&gt;insert-image&lt;/code&gt; 와 같은 함수에서 사용하기에 적합한 이미지 객체를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="324c545c922d562bc07d2165d05858f4c2204358" translate="yes" xml:space="preserve">
          <source>Finally, the &lt;em&gt;global keymap&lt;/em&gt; contains key bindings that are defined regardless of the current buffer, such as</source>
          <target state="translated">마지막으로 &lt;em&gt;전역 키맵&lt;/em&gt; 에는 다음과 같이 현재 버퍼에 관계없이 정의 된 키 바인딩이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d5747d76af22cde76df111b9171bbfe1ef0d9121" translate="yes" xml:space="preserve">
          <source>Finally, the last part of the pattern matches any additional whitespace beyond the minimum needed to end a sentence.</source>
          <target state="translated">마지막으로, 패턴의 마지막 부분은 문장을 끝내는 데 필요한 최소값을 초과하는 추가 공백과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="51d9683535aae8eb5ee805c7c7cb6e34929d338c" translate="yes" xml:space="preserve">
          <source>Finally, this function passes the string through &lt;code&gt;substitute-command-keys&lt;/code&gt; to substitute key bindings (see &lt;a href=&quot;keys-in-documentation#Keys-in-Documentation&quot;&gt;Keys in Documentation&lt;/a&gt;). It skips this step if &lt;var&gt;verbatim&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">마지막으로이 함수는 &lt;code&gt;substitute-command-keys&lt;/code&gt; 를 통해 문자열 을 대체 키 바인딩으로 전달합니다 ( &lt;a href=&quot;keys-in-documentation#Keys-in-Documentation&quot;&gt;설명서의 키&lt;/a&gt; 참조 ). 경우에는이 단계를 건너 뛰고 &lt;var&gt;verbatim&lt;/var&gt; 아닌 것이다 &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ca4154f841daffd43e50a5f7de86f96c33aadc3" translate="yes" xml:space="preserve">
          <source>Finally, unless &lt;var&gt;verbatim&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, this function calls &lt;code&gt;substitute-command-keys&lt;/code&gt;. The result is the documentation string to return.</source>
          <target state="translated">마지막으로, &lt;var&gt;verbatim&lt;/var&gt; &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우이 함수는 &lt;code&gt;substitute-command-keys&lt;/code&gt; 호출 합니다 . 결과는 반환 할 문서 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="62487a369295a12ce9fd6f501b0a5a07e8d954e7" translate="yes" xml:space="preserve">
          <source>Finally, we evaluate the following:</source>
          <target state="translated">마지막으로 다음을 평가합니다.</target>
        </trans-unit>
        <trans-unit id="c9414bf74a898debd0d63dd3bc6a719232ad7a25" translate="yes" xml:space="preserve">
          <source>Finally, we show the use of a function as an output stream. The function &lt;code&gt;eat-output&lt;/code&gt; takes each character that it is given and conses it onto the front of the list &lt;code&gt;last-output&lt;/code&gt; (see &lt;a href=&quot;building-lists#Building-Lists&quot;&gt;Building Lists&lt;/a&gt;). At the end, the list contains all the characters output, but in reverse order.</source>
          <target state="translated">마지막으로 함수를 출력 스트림으로 사용하는 방법을 보여줍니다. &lt;code&gt;eat-output&lt;/code&gt; 함수 는 주어진 각 문자를 가져 와서 &lt;code&gt;last-output&lt;/code&gt; 목록의 맨 앞에 놓습니다 ( &lt;a href=&quot;building-lists#Building-Lists&quot;&gt;목록 작성&lt;/a&gt; 참조 ). 마지막으로 목록에는 모든 문자 출력이 포함되지만 역순입니다.</target>
        </trans-unit>
        <trans-unit id="647199d379e204b551bb8caf6eee952a5a23099d" translate="yes" xml:space="preserve">
          <source>Finally, you can write a module that will work with older versions of Emacs, by comparing the size of the environment passed by Emacs with known sizes, like this:</source>
          <target state="translated">마지막으로 다음과 같이 Emacs가 전달한 환경의 크기를 알려진 크기와 비교하여 이전 버전의 Emacs에서 작동하는 모듈을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e2eb9516a141724f8015ce1c62ea5bd295c5971" translate="yes" xml:space="preserve">
          <source>Finally, you may want to change how the key is presented. By default, the key is simply shown as a &lt;code&gt;const&lt;/code&gt;, since the user cannot change the special keys specified with the &lt;code&gt;:options&lt;/code&gt; keyword. However, you may want to use a more specialized type for presenting the key, like &lt;code&gt;function-item&lt;/code&gt; if you know it is a symbol with a function binding. This is done by using a customization type specification instead of a symbol for the key.</source>
          <target state="translated">마지막으로 키가 표시되는 방법을 변경할 수 있습니다. 기본적으로 키는 단순히 &lt;code&gt;const&lt;/code&gt; 로 표시됩니다. 사용자가 &lt;code&gt;:options&lt;/code&gt; 키워드로 지정된 특수 키를 변경할 수 없기 때문 입니다. 그러나 기능 바인딩이있는 기호라는 것을 알고있는 경우 &lt;code&gt;function-item&lt;/code&gt; 과 같이 키를 표시하는 데보다 특수한 유형을 사용할 수 있습니다 . 이는 키에 대한 기호 대신 사용자 정의 유형 스펙을 사용하여 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="6139bc12e79d6ddfa470ee70765f39ffc7d5d3f7" translate="yes" xml:space="preserve">
          <source>Finally, you should bind the Lisp function to a symbol, so that Lisp code could call your function by name. For that, use the module</source>
          <target state="translated">마지막으로 Lisp 코드가 이름으로 함수를 호출 할 수 있도록 Lisp 함수를 기호에 바인딩해야합니다. 이를 위해 모듈을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f12091ef2518a74b62d963c79a01a261eecf14dd" translate="yes" xml:space="preserve">
          <source>Find text by calling &lt;var&gt;function&lt;/var&gt;, and highlight the matches it finds using &lt;code&gt;font-lock-keyword-face&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;function&lt;/var&gt; 을 호출하여 텍스트를 찾고 &lt;code&gt;font-lock-keyword-face&lt;/code&gt; 를 사용하여 찾은 일치 항목을 강조 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="d8cb62b760103f3a5ef30dca2a1575326a388a92" translate="yes" xml:space="preserve">
          <source>Finding All Frames</source>
          <target state="translated">모든 프레임 찾기</target>
        </trans-unit>
        <trans-unit id="a8cd235836e49a75690240ec59ef6b0111bd200d" translate="yes" xml:space="preserve">
          <source>Finding a key&amp;rsquo;s binding in one keymap.</source>
          <target state="translated">하나의 키맵에서 키의 바인딩을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="a67031d1c0586751352731157ea673a33fc1c359" translate="yes" xml:space="preserve">
          <source>Finding a library to load.</source>
          <target state="translated">로드 할 라이브러리를 찾는 중입니다.</target>
        </trans-unit>
        <trans-unit id="ab6f2de981c47e18ec86a3accd270c86a07d11d8" translate="yes" xml:space="preserve">
          <source>Finding out how to use a mode.</source>
          <target state="translated">모드 사용 방법 알아보기.</target>
        </trans-unit>
        <trans-unit id="0d0744b64ec0a329edc14df06db4976aa9a1b6db" translate="yes" xml:space="preserve">
          <source>Finding out which part of the text matched, after a string or regexp search.</source>
          <target state="translated">문자열 또는 정규식 검색 후 일치하는 텍스트 부분 찾기.</target>
        </trans-unit>
        <trans-unit id="27eab570847d4819c36162c48efadc0e3c73b621" translate="yes" xml:space="preserve">
          <source>Finding the Parse State for a Position</source>
          <target state="translated">위치에 대한 구문 분석 상태 찾기</target>
        </trans-unit>
        <trans-unit id="3195ca9dd575bda2ce1d7ab996bdec288335a881" translate="yes" xml:space="preserve">
          <source>Finding the best available font for a face.</source>
          <target state="translated">얼굴에 가장 적합한 글꼴 찾기.</target>
        </trans-unit>
        <trans-unit id="75464c6f702ec7d0a0ab3508c4d05f31a92e0c06" translate="yes" xml:space="preserve">
          <source>Finding the completions for a given file name.</source>
          <target state="translated">주어진 파일 이름에 대한 완성 찾기.</target>
        </trans-unit>
        <trans-unit id="7e13eb28305d03d9b543ab78212d5a631cf6470c" translate="yes" xml:space="preserve">
          <source>Finding the marker&amp;rsquo;s buffer or character position.</source>
          <target state="translated">마커의 버퍼 또는 문자 위치 찾기.</target>
        </trans-unit>
        <trans-unit id="23b8f2102b2b397aff77e6066d02a87e98e53ab4" translate="yes" xml:space="preserve">
          <source>Finding the modifier keys in an event symbol. Event types.</source>
          <target state="translated">이벤트 기호에서 수정 자 키 찾기. 이벤트 유형.</target>
        </trans-unit>
        <trans-unit id="b33cfe3f2c7699c5039e1b04ea03cad84c95d16c" translate="yes" xml:space="preserve">
          <source>Finding the name and user id of the user.</source>
          <target state="translated">사용자의 이름 및 사용자 ID 찾기.</target>
        </trans-unit>
        <trans-unit id="bf7ab483bdaaa051136602ca4b6d78f94660a87a" translate="yes" xml:space="preserve">
          <source>Finding which file defined a certain symbol.</source>
          <target state="translated">특정 기호를 정의한 파일 찾기.</target>
        </trans-unit>
        <trans-unit id="5a96053867634128a72855dbe818f35bd9b03414" translate="yes" xml:space="preserve">
          <source>First, &lt;code&gt;let&lt;/code&gt; evaluates &lt;code&gt;(list&amp;nbsp;&quot;149&quot;&amp;nbsp;'default)&lt;/code&gt; to get &lt;code&gt;(&quot;149&quot;&amp;nbsp;default)&lt;/code&gt;, the &lt;var&gt;exprval&lt;/var&gt;, and then tries to match &lt;var&gt;exprval&lt;/var&gt; against pattern &lt;code&gt;val&lt;/code&gt;. Since that is a &lt;var&gt;symbol&lt;/var&gt; pattern, it matches unconditionally and additionally binds &lt;code&gt;val&lt;/code&gt; to &lt;var&gt;exprval&lt;/var&gt;. Now that &lt;code&gt;let&lt;/code&gt; has matched, &lt;code&gt;or&lt;/code&gt; matches.</source>
          <target state="translated">첫째, &lt;code&gt;let&lt;/code&gt; 평가됩니다 &lt;code&gt;(list&amp;nbsp;&quot;149&quot;&amp;nbsp;'default)&lt;/code&gt; 얻을 수 있습니다 &lt;code&gt;(&quot;149&quot;&amp;nbsp;default)&lt;/code&gt; 의 &lt;var&gt;exprval&lt;/var&gt; 을 다음과 일치하려고 &lt;var&gt;exprval&lt;/var&gt; 패턴에 대한 &lt;code&gt;val&lt;/code&gt; . 이것이 &lt;var&gt;symbol&lt;/var&gt; 패턴이므로 무조건 일치하고 추가로 &lt;code&gt;val&lt;/code&gt; 을 &lt;var&gt;exprval&lt;/var&gt; 에 바인딩 합니다. 이제 &lt;code&gt;let&lt;/code&gt; 일치,있다 &lt;code&gt;or&lt;/code&gt; 일치.</target>
        </trans-unit>
        <trans-unit id="1a5d8cc1e281a98d0c6c309e36c19d33c4d11f54" translate="yes" xml:space="preserve">
          <source>First, &lt;code&gt;pred&lt;/code&gt; matches if &lt;code&gt;(integerp&amp;nbsp;&lt;var&gt;expval&lt;/var&gt;)&lt;/code&gt; evaluates to non-&lt;code&gt;nil&lt;/code&gt;. Next, &lt;code&gt;n&lt;/code&gt; is a &lt;var&gt;symbol&lt;/var&gt; pattern that matches anything and binds &lt;code&gt;n&lt;/code&gt; to &lt;var&gt;expval&lt;/var&gt;. Lastly, &lt;code&gt;guard&lt;/code&gt; matches if the boolean expression &lt;code&gt;(&amp;lt;=&amp;nbsp;-9&amp;nbsp;n&amp;nbsp;9)&lt;/code&gt; (note the reference to &lt;code&gt;n&lt;/code&gt;) evaluates to non-&lt;code&gt;nil&lt;/code&gt;. If all these sub-patterns match, &lt;code&gt;and&lt;/code&gt; matches.</source>
          <target state="translated">첫째, &lt;code&gt;pred&lt;/code&gt; 는 if &lt;code&gt;(integerp&amp;nbsp;&lt;var&gt;expval&lt;/var&gt;)&lt;/code&gt; 이 non- &lt;code&gt;nil&lt;/code&gt; 로 평가 되면 일치합니다 . 다음으로, &lt;code&gt;n&lt;/code&gt; 은 어떤 것과도 일치하고 &lt;code&gt;n&lt;/code&gt; 을 &lt;var&gt;expval&lt;/var&gt; 에 바인딩 하는 &lt;var&gt;symbol&lt;/var&gt; 패턴입니다 . 마지막으로, 부울 표현식 &lt;code&gt;(&amp;lt;=&amp;nbsp;-9&amp;nbsp;n&amp;nbsp;9)&lt;/code&gt; ( &lt;code&gt;n&lt;/code&gt; 에 대한 참조 참조 )이 &lt;code&gt;nil&lt;/code&gt; 이 아닌 것으로 평가 되면 &lt;code&gt;guard&lt;/code&gt; 일치합니다 . 모든 하위 패턴이 일치하는 경우 &lt;code&gt;and&lt;/code&gt; 일치합니다.</target>
        </trans-unit>
        <trans-unit id="5602cfe37b2d2e8488d61df67b252418140d07f1" translate="yes" xml:space="preserve">
          <source>First, it checks whether Transient Mark mode is enabled and the region is active. If so, it calls &lt;code&gt;indent-region&lt;/code&gt; to indent all the text in the region (see &lt;a href=&quot;region-indent#Region-Indent&quot;&gt;Region Indent&lt;/a&gt;).</source>
          <target state="translated">먼저 Transient Mark 모드가 활성화되어 있고 영역이 활성화되어 있는지 확인합니다. 그렇다면 &lt;code&gt;indent-region&lt;/code&gt; 을 호출 하여 영역의 모든 텍스트를 &lt;a href=&quot;region-indent#Region-Indent&quot;&gt;들여 씁니다&lt;/a&gt; ( Region Indent 참조 ).</target>
        </trans-unit>
        <trans-unit id="5cc90ac529a1a596c4f7b306925e3c27b2eadc5e" translate="yes" xml:space="preserve">
          <source>First, such buffers must have a suitable &lt;code&gt;revert-buffer-function&lt;/code&gt; and &lt;code&gt;buffer-stale-function&lt;/code&gt; defined.</source>
          <target state="translated">첫째, 그러한 버퍼에는 적절한 &lt;code&gt;revert-buffer-function&lt;/code&gt; 및 &lt;code&gt;buffer-stale-function&lt;/code&gt; 정의되어 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="0fc3309066ed5f2ff1aa4525ffedf257cd1d0f93" translate="yes" xml:space="preserve">
          <source>First, this command expands any abbrev before point, unless &lt;var&gt;arg&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;. (Interactively, &lt;var&gt;arg&lt;/var&gt; is the prefix argument.) Then it inserts a hyphen before point, to indicate the start of the next abbrev to be expanded. The actual expansion removes the hyphen.</source>
          <target state="translated">첫째,이 명령 은 &lt;var&gt;arg&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 포인트 앞의 모든 약어를 확장합니다 . (대화식으로 &lt;var&gt;arg&lt;/var&gt; 는 접두사 인수입니다.) 그런 다음 포인트 앞에 하이픈을 삽입하여 확장 할 다음 약어의 시작을 나타냅니다. 실제 확장은 하이픈을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="a774409a00c21de377cf8ed5c6a56b8547973042" translate="yes" xml:space="preserve">
          <source>Flag</source>
          <target state="translated">Flag</target>
        </trans-unit>
        <trans-unit id="668fcf1810b2ce389d0b1a207b70b01210d0ace2" translate="yes" xml:space="preserve">
          <source>Flag the current frame like</source>
          <target state="translated">현재 프레임에 다음과 같이 플래그 지정</target>
        </trans-unit>
        <trans-unit id="6a56cfecdba7ea96836380ed1e69b4a44f61a462" translate="yes" xml:space="preserve">
          <source>Flag the current frame so that the debugger will be entered when the frame is exited. Frames flagged in this way are marked with stars in the backtrace buffer.</source>
          <target state="translated">프레임이 종료 될 때 디버거가 입력되도록 현재 프레임에 플래그를 지정합니다. 이러한 방식으로 플래그가 지정된 프레임은 역 추적 버퍼에서 별표로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="8493365622f8f23a430a6e553cd0fa55fbb91b58" translate="yes" xml:space="preserve">
          <source>Flag to set &lt;code&gt;coding-system&lt;/code&gt; of the process buffer from the coding system used to decode process output.</source>
          <target state="translated">프로세스 출력을 디코딩하는 데 사용되는 코딩 시스템에서 프로세스 버퍼의 코딩 시스템 을 설정 &lt;code&gt;coding-system&lt;/code&gt; 플래그 입니다.</target>
        </trans-unit>
        <trans-unit id="d15cd35cc1267b2e5feff273e3273e81715a547f" translate="yes" xml:space="preserve">
          <source>Floating-Point Basics</source>
          <target state="translated">부동 소수점 기초</target>
        </trans-unit>
        <trans-unit id="bdb039dcc477ba3def70845b9d2585d93f962bc6" translate="yes" xml:space="preserve">
          <source>Floating-Point Type</source>
          <target state="translated">부동 소수점 유형</target>
        </trans-unit>
        <trans-unit id="438bbb63180abb99b9a1a681f77aa34c104b3d49" translate="yes" xml:space="preserve">
          <source>Floating-point numbers are the computer equivalent of scientific notation; you can think of a floating-point number as a fraction together with a power of ten. The precise number of significant figures and the range of possible exponents is machine-specific; Emacs uses the C data type &lt;code&gt;double&lt;/code&gt; to store the value, and internally this records a power of 2 rather than a power of 10.</source>
          <target state="translated">부동 소수점 숫자는 과학적 표기법에 해당하는 컴퓨터입니다. 부동 소수점 숫자를 10의 거듭 제곱과 함께 분수로 생각할 수 있습니다. 유효 숫자의 정확한 수와 가능한 지수 범위는 기계에 따라 다릅니다. Emacs는 C 데이터 유형 &lt;code&gt;double&lt;/code&gt; 을 사용하여 값을 저장하고 내부적으로 이것은 10의 거듭 제곱이 아닌 2의 거듭 제곱을 기록합니다.</target>
        </trans-unit>
        <trans-unit id="bab4f9b32cf539639489e8df679cc5fcd42c2607" translate="yes" xml:space="preserve">
          <source>Floating-point numbers are useful for representing numbers that are not integral. The range of floating-point numbers is the same as the range of the C data type &lt;code&gt;double&lt;/code&gt; on the machine you are using. On all computers supported by Emacs, this is</source>
          <target state="translated">부동 소수점 숫자는 정수가 아닌 숫자를 나타내는 데 유용합니다. 부동 소수점 숫자의 범위 는 사용중인 시스템 에서 C 데이터 유형 &lt;code&gt;double&lt;/code&gt; 의 범위와 동일합니다 . Emacs가 지원하는 모든 컴퓨터에서 이것은</target>
        </trans-unit>
        <trans-unit id="6fb0f1fe4e017c28f8eea1d36230c9eb45418e19" translate="yes" xml:space="preserve">
          <source>Floating-point value.</source>
          <target state="translated">부동 소수점 값.</target>
        </trans-unit>
        <trans-unit id="81c6e47ced4689fc9b50ffb6c5d899c6c3458d6a" translate="yes" xml:space="preserve">
          <source>Focus Events</source>
          <target state="translated">포커스 이벤트</target>
        </trans-unit>
        <trans-unit id="1e645b972bad2a1f5548e11a059f25456c18a168" translate="yes" xml:space="preserve">
          <source>Focus events are represented in Lisp as lists that look like this:</source>
          <target state="translated">포커스 이벤트는 Lisp에서 다음과 같은 목록으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="17682d88592b02229ac424a4f95bc51968287272" translate="yes" xml:space="preserve">
          <source>Folding or wrapping long text lines.</source>
          <target state="translated">긴 텍스트 줄을 접거나 줄 바꿈.</target>
        </trans-unit>
        <trans-unit id="16be6fc4be7857cb1d203506b203e9ae71dbe2e1" translate="yes" xml:space="preserve">
          <source>Font Lock Basics</source>
          <target state="translated">글꼴 잠금 기본 사항</target>
        </trans-unit>
        <trans-unit id="efe3d0b886a6e6756ec774cf390598b0e5ff9f14" translate="yes" xml:space="preserve">
          <source>Font Lock Mode</source>
          <target state="translated">글꼴 잠금 모드</target>
        </trans-unit>
        <trans-unit id="8bf72cf6fee44ae0e97096fd69d4ebe9361c9ec8" translate="yes" xml:space="preserve">
          <source>Font Lock Multiline</source>
          <target state="translated">글꼴 잠금 여러 줄</target>
        </trans-unit>
        <trans-unit id="ab0acf1261e924742450fde03462e9eccf261b91" translate="yes" xml:space="preserve">
          <source>Font Lock mode (see &lt;a href=&quot;font-lock-mode#Font-Lock-Mode&quot;&gt;Font Lock Mode&lt;/a&gt;) works in most buffers by dynamically updating the &lt;code&gt;face&lt;/code&gt; property of characters based on the context.</source>
          <target state="translated">글꼴 잠금 모드 (참조 &lt;a href=&quot;font-lock-mode#Font-Lock-Mode&quot;&gt;글꼴 잠금 모드&lt;/a&gt; ) 동적으로 업데이트하여 가장 버퍼에서 작동 &lt;code&gt;face&lt;/code&gt; 문맥에 따라 문자의 속성을.</target>
        </trans-unit>
        <trans-unit id="c6ae546df279ab14850a00208c2542e4e12f0d10" translate="yes" xml:space="preserve">
          <source>Font Lock mode can highlight using any face, but Emacs defines several faces specifically for Font Lock to use to highlight text. These &lt;em&gt;Font Lock faces&lt;/em&gt; are listed below. They can also be used by major modes for syntactic highlighting outside of Font Lock mode (see &lt;a href=&quot;major-mode-conventions#Major-Mode-Conventions&quot;&gt;Major Mode Conventions&lt;/a&gt;).</source>
          <target state="translated">글꼴 잠금 모드는 모든 얼굴을 사용하여 강조 표시 할 수 있지만 Emacs는 특히 글꼴 잠금이 텍스트를 강조 표시하는 데 사용할 여러 얼굴을 정의합니다. 이러한 &lt;em&gt;글꼴 잠금 얼굴&lt;/em&gt; 은 아래에 나열되어 있습니다. 또한 글꼴 잠금 모드 외부의 구문 강조를 위해 주요 모드에서 사용할 수도 있습니다 ( &lt;a href=&quot;major-mode-conventions#Major-Mode-Conventions&quot;&gt;주요 모드 규칙&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="d3a49e72d5752fd0a1f1609dc66d91f9adac11be" translate="yes" xml:space="preserve">
          <source>Font Lock mode finds text to highlight in two ways: through syntactic parsing based on the syntax table, and through searching (usually for regular expressions). Syntactic fontification happens first; it finds comments and string constants and highlights them. Search-based fontification happens second.</source>
          <target state="translated">글꼴 잠금 모드는 두 가지 방법으로 강조 표시 할 텍스트를 찾습니다. 구문 테이블을 기반으로 한 구문 분석과 검색 (일반적으로 정규 표현식)을 사용합니다. 구문 글꼴 화가 먼저 발생합니다. 주석과 문자열 상수를 찾아 강조 표시합니다. 검색 기반 글꼴 화가 두 번째로 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f2a4b0d06bd26c4094acc6d06be6c29713210fab" translate="yes" xml:space="preserve">
          <source>Font Selection</source>
          <target state="translated">글꼴 선택</target>
        </trans-unit>
        <trans-unit id="1870afcff000c92cc31bceeb4d9b4496c9271455" translate="yes" xml:space="preserve">
          <source>Font Type</source>
          <target state="translated">글꼴 유형</target>
        </trans-unit>
        <trans-unit id="97f6e4b3b5283deebf4eb8440ae1032cce6d2c82" translate="yes" xml:space="preserve">
          <source>Font and Color Parameters</source>
          <target state="translated">글꼴 및 색상 매개 변수</target>
        </trans-unit>
        <trans-unit id="617a7feac03d690c7d634c9921443adedf9077eb" translate="yes" xml:space="preserve">
          <source>Font family name (a string). See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Fonts.html#Fonts&quot;&gt;Fonts&lt;/a&gt; in</source>
          <target state="translated">글꼴 패밀리 이름 (문자열). 참조 &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Fonts.html#Fonts&quot;&gt;글꼴&lt;/a&gt; 에</target>
        </trans-unit>
        <trans-unit id="d98ba0cd2d45c74c9105fe36f65c1febba92edd8" translate="yes" xml:space="preserve">
          <source>Font family name (a string). See &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/Fonts.html#Fonts&quot;&gt;Fonts&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6b554a056e5bc46e18cdfad97f7433899edd323" translate="yes" xml:space="preserve">
          <source>Font selection first finds the best available matches for the first attribute in the list; then, among the fonts which are best in that way, it searches for the best matches in the second attribute, and so on.</source>
          <target state="translated">글꼴 선택은 먼저 목록의 첫 번째 속성에 대해 가장 잘 일치하는 항목을 찾습니다. 그런 다음 그런 방식으로 가장 좋은 글꼴 중에서 두 번째 속성에서 가장 일치하는 글꼴을 검색하는 식입니다.</target>
        </trans-unit>
        <trans-unit id="a89193453fac12819a631009c0355f965f7d396b" translate="yes" xml:space="preserve">
          <source>Font slant&amp;mdash;one of the symbols &lt;code&gt;italic&lt;/code&gt;, &lt;code&gt;oblique&lt;/code&gt;, &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;reverse-italic&lt;/code&gt;, or &lt;code&gt;reverse-oblique&lt;/code&gt;. On text terminals that support variable-brightness text, slanted text is displayed as half-bright.</source>
          <target state="translated">심볼의 폰트 경사 온 &lt;code&gt;italic&lt;/code&gt; , &lt;code&gt;oblique&lt;/code&gt; , &lt;code&gt;normal&lt;/code&gt; , &lt;code&gt;reverse-italic&lt;/code&gt; 또는 &lt;code&gt;reverse-oblique&lt;/code&gt; . 가변 밝기 텍스트를 지원하는 텍스트 터미널에서 기울어 진 텍스트는 절반 밝기로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="121db6402441bd0541f0b53862701a0d2fbef923" translate="yes" xml:space="preserve">
          <source>Font weight&amp;mdash;one of the symbols (from densest to faintest) &lt;code&gt;ultra-bold&lt;/code&gt;, &lt;code&gt;extra-bold&lt;/code&gt;, &lt;code&gt;bold&lt;/code&gt;, &lt;code&gt;semi-bold&lt;/code&gt;, &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;semi-light&lt;/code&gt;, &lt;code&gt;light&lt;/code&gt;, &lt;code&gt;extra-light&lt;/code&gt;, or &lt;code&gt;ultra-light&lt;/code&gt;. On text terminals which support variable-brightness text, any weight greater than normal is displayed as extra bright, and any weight less than normal is displayed as half-bright.</source>
          <target state="translated">글꼴 두께- &lt;code&gt;ultra-bold&lt;/code&gt; , &lt;code&gt;extra-bold&lt;/code&gt; , &lt;code&gt;bold&lt;/code&gt; , &lt;code&gt;semi-light&lt;/code&gt; &lt;code&gt;semi-bold&lt;/code&gt; , &lt;code&gt;normal&lt;/code&gt; , 약간 밝게 , &lt;code&gt;light&lt;/code&gt; , &lt;code&gt;extra-light&lt;/code&gt; 또는 &lt;code&gt;ultra-light&lt;/code&gt; 밝게 기호 중 하나입니다 (가장 조밀함에서 가장 희미 함까지) . 가변 밝기 텍스트를 지원하는 텍스트 터미널에서 보통보다 큰 가중치는 더 밝게 표시되고 보통보다 작은 가중치는 절반 밝게 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="8c2ebf48420ae343561df753e43b69aad019c4ec" translate="yes" xml:space="preserve">
          <source>Fontification based on regexps.</source>
          <target state="translated">정규 표현식을 기반으로 한 글꼴 화.</target>
        </trans-unit>
        <trans-unit id="0a19191afa15ace9553b653b0ab1817384edcea4" translate="yes" xml:space="preserve">
          <source>Fontification based on syntax tables.</source>
          <target state="translated">구문 표를 기반으로 한 글꼴 화.</target>
        </trans-unit>
        <trans-unit id="d990de39c1d8401b13a944ac86e95f418f2b1274" translate="yes" xml:space="preserve">
          <source>Fontification will call &lt;var&gt;function&lt;/var&gt; repeatedly with the same limit, and with point where the previous invocation left it, until &lt;var&gt;function&lt;/var&gt; fails. On failure, &lt;var&gt;function&lt;/var&gt; need not reset point in any particular way.</source>
          <target state="translated">Fontification은 &lt;var&gt;function&lt;/var&gt; 가 실패 할 때까지 동일한 제한과 이전 호출이 남은 지점으로 &lt;var&gt;function&lt;/var&gt; 반복적으로 호출 합니다. 실패시 &lt;var&gt;function&lt;/var&gt; 은 특정 방식으로 포인트를 재설정 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f6a9f42468c4ad6da6bdd3029c4061af9efedf85" translate="yes" xml:space="preserve">
          <source>Fonts and colors for the frame text.</source>
          <target state="translated">프레임 텍스트의 글꼴 및 색상입니다.</target>
        </trans-unit>
        <trans-unit id="370c5f43426613481fdfffd5afd2ec8451dd4bee" translate="yes" xml:space="preserve">
          <source>Fonts for displaying text.</source>
          <target state="translated">텍스트를 표시하기위한 글꼴.</target>
        </trans-unit>
        <trans-unit id="6b4cad525641bf7699e6ab0211542150965ffbb4" translate="yes" xml:space="preserve">
          <source>Fontset-&lt;var&gt;n&lt;/var&gt;</source>
          <target state="translated">Fontset-&lt;var&gt;n&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="4a83fc4223f6f835230963f891f5894b226b7af2" translate="yes" xml:space="preserve">
          <source>Fontsets</source>
          <target state="translated">Fontsets</target>
        </trans-unit>
        <trans-unit id="0c6aa77e19ef0b153d085a45f431eea8c9bf5723" translate="yes" xml:space="preserve">
          <source>Fontsets can specify a font on a per-character basis; when the fontset does that, this function&amp;rsquo;s value may not be accurate.</source>
          <target state="translated">글꼴 집합은 문자별로 글꼴을 지정할 수 있습니다. 폰트 셋이 그렇게 할 때이 함수의 값이 정확하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="201a6b3053cc1422d2c3670b62616221d2290929" translate="yes" xml:space="preserve">
          <source>Foo</source>
          <target state="translated">Foo</target>
        </trans-unit>
        <trans-unit id="222782d2ff4c7cc6cf5c4bdeffe7941e2dd46d68" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;:before&lt;/code&gt; advice, being outermost means that this advice will be run first, before any other advice, whereas being innermost means that it will run right before the original function, with no other advice run between itself and the original function. Similarly, for &lt;code&gt;:after&lt;/code&gt; advice innermost means that it will run right after the original function, with no other advice run in between, whereas outermost means that it will be run right at the end after all other advice. An innermost &lt;code&gt;:override&lt;/code&gt; piece of advice will only override the original function and other pieces of advice will apply to it, whereas an outermost &lt;code&gt;:override&lt;/code&gt; piece of advice will override not only the original function but all other advice applied to it as well.</source>
          <target state="translated">For &lt;code&gt;:before&lt;/code&gt; advice, 가장 바깥쪽에 있다는 것은이 어드바이스가 다른 어드바이스보다 먼저 실행된다는 것을 의미하고, 가장 안쪽이된다는 것은 그 어드바이스가 원래 함수 바로 전에 실행되고, 그 자체와 원래 함수 사이에 다른 어드바이스가 실행되지 않음을 의미합니다. 비슷하게, for &lt;code&gt;:after&lt;/code&gt; advice innermost는 원래 함수 바로 뒤에 실행되고 그 사이에 다른 advice가 실행되지 않는다는 것을 의미하고, outermost는 다른 모든 advice가 끝날 때 바로 실행될 것임을 의미합니다. 가장 안쪽에있는 &lt;code&gt;:override&lt;/code&gt; 어드바이스는 원래 함수 만 덮어 쓰고 다른 어드바이스가 적용되는 반면, 가장 바깥쪽에있는 &lt;code&gt;:override&lt;/code&gt; 어드바이스는 원래 함수뿐만 아니라 여기에 적용된 다른 모든 어드바이스도 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="780a29736b25c508c29c6a3dedd3caa74f5f9492" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;equal&lt;/code&gt;, equality is defined recursively; for example, given two cons cells &lt;var&gt;x&lt;/var&gt; and &lt;var&gt;y&lt;/var&gt;, &lt;code&gt;(equal &lt;var&gt;x&lt;/var&gt; &lt;var&gt;y&lt;/var&gt;)&lt;/code&gt; returns &lt;code&gt;t&lt;/code&gt; if and only if both the expressions below return &lt;code&gt;t&lt;/code&gt;:</source>
          <target state="translated">들면 &lt;code&gt;equal&lt;/code&gt; 평등 재귀 정의된다; 예를 들어, 두 개의 반대 세포 주어진 &lt;var&gt;x&lt;/var&gt; 및 &lt;var&gt;y&lt;/var&gt; , &lt;code&gt;(equal &lt;var&gt;x&lt;/var&gt; &lt;var&gt;y&lt;/var&gt;)&lt;/code&gt; 를 반환 &lt;code&gt;t&lt;/code&gt; 경우에만 모두 리턴 아래 식 만약 &lt;code&gt;t&lt;/code&gt; 가 :</target>
        </trans-unit>
        <trans-unit id="8361c92b5f57d869af5b95ec47c3be590e320ff7" translate="yes" xml:space="preserve">
          <source>For A, because symbol &lt;code&gt;st&lt;/code&gt; is mentioned twice, the second mention becomes an equality test using &lt;code&gt;eq&lt;/code&gt;. On the other hand, B uses two separate symbols, &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt;, both of which become independent bindings.</source>
          <target state="translated">A의 경우 기호 &lt;code&gt;st&lt;/code&gt; 가 두 번 언급 되기 때문에 두 번째 언급은 &lt;code&gt;eq&lt;/code&gt; 를 사용한 동등성 테스트가됩니다 . 반면에 B는 두 개의 개별 기호 &lt;code&gt;s1&lt;/code&gt; 및 &lt;code&gt;s2&lt;/code&gt; 를 사용 하며 둘 다 독립적 인 바인딩이됩니다.</target>
        </trans-unit>
        <trans-unit id="b11610eb910bc3e09bb05d152b90cc4ed3de8e14" translate="yes" xml:space="preserve">
          <source>For Emacs Lisp mode, &lt;code&gt;imenu-generic-expression&lt;/code&gt; could look like this:</source>
          <target state="translated">Emacs Lisp 모드의 경우 &lt;code&gt;imenu-generic-expression&lt;/code&gt; 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4afc5c50d3365855eb6afc17378478bbb50beccb" translate="yes" xml:space="preserve">
          <source>For PBM images, specify image type &lt;code&gt;pbm&lt;/code&gt;. Color, gray-scale and monochromatic images are supported. For mono PBM images, two additional image properties are supported.</source>
          <target state="translated">PBM 이미지의 경우 이미지 유형 &lt;code&gt;pbm&lt;/code&gt; 을 지정하십시오 . 컬러, 그레이 스케일 및 단색 이미지가 지원됩니다. 모노 PBM 이미지의 경우 두 개의 추가 이미지 속성이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="e4029ea038ac2bc1533dfd42dca15945911a6e65" translate="yes" xml:space="preserve">
          <source>For a connection, &lt;var&gt;remote-address&lt;/var&gt; is the address to connect to. It overrides &lt;var&gt;family&lt;/var&gt;, &lt;var&gt;host&lt;/var&gt; and &lt;var&gt;service&lt;/var&gt;, so you might as well not specify them.</source>
          <target state="translated">연결의 경우 &lt;var&gt;remote-address&lt;/var&gt; 는 연결할 주소입니다. &lt;var&gt;family&lt;/var&gt; , &lt;var&gt;host&lt;/var&gt; 및 &lt;var&gt;service&lt;/var&gt; 를 재정의 하므로 지정하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8dd44b177320bc6af9a166a79a69645b4af9478f" translate="yes" xml:space="preserve">
          <source>For a datagram server, &lt;var&gt;remote-address&lt;/var&gt; specifies the initial setting of the remote datagram address.</source>
          <target state="translated">데이터 그램 서버의 경우 &lt;var&gt;remote-address&lt;/var&gt; 는 원격 데이터 그램 주소의 초기 설정을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="1ec8cb627d21e3d182615eec57f529138243db39" translate="yes" xml:space="preserve">
          <source>For a drag event, the name of the symbol &lt;var&gt;event-type&lt;/var&gt; contains the prefix &amp;lsquo;</source>
          <target state="translated">드래그 이벤트의 경우 심볼 &lt;var&gt;event-type&lt;/var&gt; 의 이름에 접두사 '</target>
        </trans-unit>
        <trans-unit id="c1a7557f2039cefe1324f701825e904b7b74f01b" translate="yes" xml:space="preserve">
          <source>For a few commands, these properties are present by default (you can remove them in your init file if you wish).</source>
          <target state="translated">몇 가지 명령의 경우 이러한 속성이 기본적으로 존재합니다 (원하는 경우 init 파일에서 제거 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="f158e15a661272a4f668cbe2ebc4100e6331ea32" translate="yes" xml:space="preserve">
          <source>For a fixed-size field, the length &lt;var&gt;len&lt;/var&gt; is given as an integer specifying the number of bytes in the field.</source>
          <target state="translated">고정 크기 필드의 경우 길이 &lt;var&gt;len&lt;/var&gt; 은 필드의 바이트 수를 지정하는 정수로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="94bf6db303e72a344c395d7b32f9f6b6c3a5e4f2" translate="yes" xml:space="preserve">
          <source>For a frame on a graphical terminal the following function returns the sizes of the areas described above:</source>
          <target state="translated">그래픽 터미널의 프레임에 대해 다음 함수는 위에 설명 된 영역의 크기를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f9a4455cc0875a8bb40f0c436c07d787c88d64b1" translate="yes" xml:space="preserve">
          <source>For a leaf window and windows showing a tooltip, this is the buffer, as a Lisp object, that the window is displaying. For an internal (&amp;ldquo;parent&amp;rdquo;) window, this is its first child window. For a pseudo window showing a menu or tool bar this is &lt;code&gt;nil&lt;/code&gt;. It is also &lt;code&gt;nil&lt;/code&gt; for a window that has been deleted.</source>
          <target state="translated">툴팁을 보여주는 리프 윈도우와 윈도우의 경우 이것은 윈도우가 표시하는 Lisp 객체로서의 버퍼입니다. 내부 ( &quot;부모&quot;) 창의 경우 이것은 첫 번째 자식 창입니다. 메뉴 또는 도구 모음을 표시하는 의사 창의 경우 이것은 &lt;code&gt;nil&lt;/code&gt; 입니다. 삭제 된 창에 대해서도 &lt;code&gt;nil&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e541a81b69fdfc92f78d919c17ef443858ce2a88" translate="yes" xml:space="preserve">
          <source>For a more complete list of contributors, please see the relevant change log entries in the Emacs source repository.</source>
          <target state="translated">기여자의 전체 목록은 Emacs 소스 저장소의 관련 변경 로그 항목을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="da33f8ed197d7dcafe1f10cf24364a3e44b8c16e" translate="yes" xml:space="preserve">
          <source>For a more elaborate example of using &lt;code&gt;defvar&lt;/code&gt; without a value, see &lt;a href=&quot;using-lexical-binding#Local-defvar-example&quot;&gt;Local defvar example&lt;/a&gt;.</source>
          <target state="translated">값없이 &lt;code&gt;defvar&lt;/code&gt; 를 사용하는보다 자세한 예제는 &lt;a href=&quot;using-lexical-binding#Local-defvar-example&quot;&gt;로컬 defvar 예제를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1fba15c59889a0f613ee7b6254fb4cdcc2bf5070" translate="yes" xml:space="preserve">
          <source>For a more realistic example where you might use this, consider that you have a buffer where certain sections represent URLs, and these are tagged with &lt;code&gt;shr-url&lt;/code&gt;.</source>
          <target state="translated">이것을 사용할 수있는보다 현실적인 예를 들어, 특정 섹션이 URL을 나타내는 버퍼가 있고 여기에 &lt;code&gt;shr-url&lt;/code&gt; 태그가 지정되어 있다고 가정하십시오 .</target>
        </trans-unit>
        <trans-unit id="874be1ffef73392c67ae3ceb4571855edc9b38ac" translate="yes" xml:space="preserve">
          <source>For a more strict function (that will error out upon invalid input), this function can be used instead. It can parse all variants of the ISO 8601 standard, so in addition to the formats mentioned above, it also parses things like &amp;ldquo;1998W45-3&amp;rdquo; (week number) and &amp;ldquo;1998-245&amp;rdquo; (ordinal day number). To parse durations, there&amp;rsquo;s &lt;code&gt;iso8601-parse-duration&lt;/code&gt;, and to parse intervals, there&amp;rsquo;s &lt;code&gt;iso8601-parse-interval&lt;/code&gt;. All these functions return decoded time structures, except the final one, which returns three of them (the start, the end, and the duration).</source>
          <target state="translated">보다 엄격한 함수 (잘못된 입력시 오류 발생)의 경우이 함수를 대신 사용할 수 있습니다. ISO 8601 표준의 모든 변형을 구문 분석 할 수 있으므로 위에서 언급 한 형식 외에도 &quot;1998W45-3&quot;(주 번호) 및 &quot;1998-245&quot;(표준 날짜 번호)와 같은 항목도 구문 분석합니다. 기간을 파싱하기 위해 &lt;code&gt;iso8601-parse-duration&lt;/code&gt; 이 있고 간격을 파싱하기 위해 &lt;code&gt;iso8601-parse-interval&lt;/code&gt; 이 있습니다. 이러한 모든 함수는 디코딩 된 시간 구조를 반환합니다. 단, 마지막 구조는 3 개 (시작, 종료 및 기간)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b1f0f2adf942c9d2dc3309bacacd2243cf7604e2" translate="yes" xml:space="preserve">
          <source>For a network process, the values include (see &lt;code&gt;make-network-process&lt;/code&gt; for a complete list):</source>
          <target state="translated">네트워크 프로세스의 경우 값에는 다음이 포함됩니다 ( 전체 목록 은 &lt;code&gt;make-network-process&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="f153e1c5645a5e23d096b21d21ce109610d96b4d" translate="yes" xml:space="preserve">
          <source>For a network, serial, or pipe connection, &lt;code&gt;process-status&lt;/code&gt; returns one of the symbols &lt;code&gt;open&lt;/code&gt;, &lt;code&gt;stop&lt;/code&gt;, or &lt;code&gt;closed&lt;/code&gt;. The latter means that the other side closed the connection, or Emacs did &lt;code&gt;delete-process&lt;/code&gt;. The value &lt;code&gt;stop&lt;/code&gt; means that &lt;code&gt;stop-process&lt;/code&gt; was called on the connection.</source>
          <target state="translated">네트워크, 직렬 또는 파이프 연결의 경우 &lt;code&gt;process-status&lt;/code&gt; 는 &lt;code&gt;open&lt;/code&gt; , &lt;code&gt;stop&lt;/code&gt; 또는 &lt;code&gt;closed&lt;/code&gt; 기호 중 하나를 반환합니다 . 후자는 다른 쪽이 연결을 닫았거나 Emacs가 &lt;code&gt;delete-process&lt;/code&gt; 를 수행 했음을 의미합니다 . &lt;code&gt;stop&lt;/code&gt; 값 은 연결에서 &lt;code&gt;stop-process&lt;/code&gt; 가 호출 되었음을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="6d196b666ddfa5e2c84615cae0e329a107522c93" translate="yes" xml:space="preserve">
          <source>For a normal hook, hook functions should be designed so that the order in which they are executed does not matter. Any dependence on the order is asking for trouble. However, the order is predictable: normally, &lt;var&gt;function&lt;/var&gt; goes at the front of the hook list, so it is executed first (barring another &lt;code&gt;add-hook&lt;/code&gt; call).</source>
          <target state="translated">일반적인 후크의 경우 후크 함수는 실행 순서가 중요하지 않도록 설계되어야합니다. 주문에 대한 의존성은 문제를 요구합니다. 그러나 순서는 예측할 수 있습니다. 일반적으로 &lt;var&gt;function&lt;/var&gt; 는 후크 목록의 맨 앞에 있으므로 먼저 실행됩니다 (또 다른 &lt;code&gt;add-hook&lt;/code&gt; 호출 제외 ).</target>
        </trans-unit>
        <trans-unit id="07239215f7db505c2e2bbfc3f9963a1fb0a6ddbd" translate="yes" xml:space="preserve">
          <source>For a normal, non-child frame this function returns a cons of the pixel coordinates of its outer position (see &lt;a href=&quot;frame-layout#Frame-Layout&quot;&gt;Frame Layout&lt;/a&gt;) with respect to the origin &lt;code&gt;(0, 0)&lt;/code&gt; of its display. For a child frame (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;) this function returns the pixel coordinates of its outer position with respect to an origin &lt;code&gt;(0, 0)&lt;/code&gt; at the native position of &lt;var&gt;frame&lt;/var&gt;&amp;rsquo;s parent.</source>
          <target state="translated">자식이 아닌 일반 프레임의 경우이 함수는 디스플레이 의 원점 &lt;code&gt;(0, 0)&lt;/code&gt; 을 기준으로 외부 위치 ( &lt;a href=&quot;frame-layout#Frame-Layout&quot;&gt;프레임 레이아웃&lt;/a&gt; 참조 ) 의 픽셀 좌표에 대한 단점을 반환합니다 . 하위 프레임 (참조 &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;하위 프레임&lt;/a&gt; 이 함수는 원점에 대해 그 외측 위치의 화소의 좌표를 반환) &lt;code&gt;(0, 0)&lt;/code&gt; 의 원래 위치에서 &lt;var&gt;frame&lt;/var&gt; 의 부모.</target>
        </trans-unit>
        <trans-unit id="7555a3f0929878def60a2a8b52d9653acbc69538" translate="yes" xml:space="preserve">
          <source>For a particular frame, the value specified here may be overridden by that frame&amp;rsquo;s &lt;code&gt;auto-hide-function&lt;/code&gt; frame parameter (see &lt;a href=&quot;frame-interaction-parameters#Frame-Interaction-Parameters&quot;&gt;Frame Interaction Parameters&lt;/a&gt;).</source>
          <target state="translated">특정 프레임의 경우 여기에 지정된 값은 해당 프레임의 &lt;code&gt;auto-hide-function&lt;/code&gt; 프레임 매개 변수에 의해 재정의 될 수 있습니다 ( &lt;a href=&quot;frame-interaction-parameters#Frame-Interaction-Parameters&quot;&gt;프레임 상호 작용 매개 변수&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="e684da989eacfd97b2925e7be52fae8c01f15e86" translate="yes" xml:space="preserve">
          <source>For a related feature, see &lt;a href=&quot;init-file#Init-File&quot;&gt;window-setup-hook&lt;/a&gt;.</source>
          <target state="translated">관련 기능은 &lt;a href=&quot;init-file#Init-File&quot;&gt;window-setup-hook을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f64cde43e52e64458ff57aaae7a20c71fc92b47a" translate="yes" xml:space="preserve">
          <source>For a remote &lt;var&gt;filename&lt;/var&gt;, this function returns a file name which could be used directly as an argument of a remote process (see &lt;a href=&quot;asynchronous-processes#Asynchronous-Processes&quot;&gt;Asynchronous Processes&lt;/a&gt;, and see &lt;a href=&quot;synchronous-processes#Synchronous-Processes&quot;&gt;Synchronous Processes&lt;/a&gt;), and as the program to run on the remote host. If &lt;var&gt;filename&lt;/var&gt; is local, this function returns it unchanged.</source>
          <target state="translated">원격 &lt;var&gt;filename&lt;/var&gt; 의 경우이 함수는 원격 프로세스의 인수 ( &lt;a href=&quot;asynchronous-processes#Asynchronous-Processes&quot;&gt;비동기 프로세스&lt;/a&gt; 참조 및 &lt;a href=&quot;synchronous-processes#Synchronous-Processes&quot;&gt;동기 프로세스&lt;/a&gt; 참조 ) 로 직접 사용할 수 있고 원격 호스트에서 실행할 프로그램 으로 사용할 수있는 파일 이름을 반환 합니다. 경우 &lt;var&gt;filename&lt;/var&gt; 로컬,이 기능은 변경되지 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2e2af02388fcb473348e3e1783b1223ba2413713" translate="yes" xml:space="preserve">
          <source>For a serial connection, see &lt;code&gt;make-serial-process&lt;/code&gt; and &lt;code&gt;serial-process-configure&lt;/code&gt; for the list of keys. For a pipe connection, see &lt;code&gt;make-pipe-process&lt;/code&gt; for the list of keys.</source>
          <target state="translated">직렬 연결 의 경우 키 목록 은 &lt;code&gt;make-serial-process&lt;/code&gt; 및 &lt;code&gt;serial-process-configure&lt;/code&gt; 를 참조하십시오. 파이프 연결 의 경우 키 목록 은 &lt;code&gt;make-pipe-process&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="506e52ccaad624a03a5a25b690b4ec879ceb8066" translate="yes" xml:space="preserve">
          <source>For a server process, &lt;var&gt;local-address&lt;/var&gt; is the address to listen on. It overrides &lt;var&gt;family&lt;/var&gt;, &lt;var&gt;host&lt;/var&gt; and &lt;var&gt;service&lt;/var&gt;, so you might as well not specify them.</source>
          <target state="translated">서버 프로세스의 경우 &lt;var&gt;local-address&lt;/var&gt; 는 수신 대기 할 주소입니다. &lt;var&gt;family&lt;/var&gt; , &lt;var&gt;host&lt;/var&gt; 및 &lt;var&gt;service&lt;/var&gt; 를 재정의 하므로 지정하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="063ae54c86a72f6dd2b6ef0b2c53785caaf880ca" translate="yes" xml:space="preserve">
          <source>For a server process, the options specified with &lt;code&gt;make-network-process&lt;/code&gt; are not inherited by the client connections, so you will need to set the necessary options for each child connection as it is created.</source>
          <target state="translated">서버 프로세스의 경우 &lt;code&gt;make-network-process&lt;/code&gt; 로 지정된 옵션 은 클라이언트 연결에 상속되지 않으므로 생성 될 때 각 자식 연결에 필요한 옵션을 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="ab0e9166dd05d405f2aa575ede5d0ec4d4aa5de5" translate="yes" xml:space="preserve">
          <source>For a single-file package, &lt;var&gt;file&lt;/var&gt; is the package Lisp file; for a multi-file package, it is the package tar file. You can also sign the archive&amp;rsquo;s contents file in the same way. Make the</source>
          <target state="translated">단일 파일 패키지의 경우 &lt;var&gt;file&lt;/var&gt; 은 패키지 Lisp 파일입니다. 다중 파일 패키지의 경우 패키지 tar 파일입니다. 동일한 방법으로 아카이브의 내용 파일에 서명 할 수도 있습니다. 만들기</target>
        </trans-unit>
        <trans-unit id="cddac283c6fbad067cde2e91d582a0863ab1f67d" translate="yes" xml:space="preserve">
          <source>For additional safety, &lt;code&gt;read-circle&lt;/code&gt; is temporarily bound to &lt;code&gt;nil&lt;/code&gt; when Emacs reads file-local variables (see &lt;a href=&quot;input-functions#Input-Functions&quot;&gt;Input Functions&lt;/a&gt;). This prevents the Lisp reader from recognizing circular and shared Lisp structures (see &lt;a href=&quot;circular-objects#Circular-Objects&quot;&gt;Circular Objects&lt;/a&gt;).</source>
          <target state="translated">추가 안전을 위해 Emacs가 파일 로컬 변수를 읽을 때 &lt;code&gt;read-circle&lt;/code&gt; 은 일시적으로 &lt;code&gt;nil&lt;/code&gt; 에 바인딩됩니다 ( &lt;a href=&quot;input-functions#Input-Functions&quot;&gt;입력 함수&lt;/a&gt; 참조 ). 이렇게하면 Lisp 판독기가 원형 및 공유 Lisp 구조를 인식하지 못합니다 ( &lt;a href=&quot;circular-objects#Circular-Objects&quot;&gt;원형 객체&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="ef6f908916c2213a58292c4ccfef487ba3e9d216" translate="yes" xml:space="preserve">
          <source>For an alternative facility for destructuring binding, see &lt;a href=&quot;sequence-functions#seq_002dlet&quot;&gt;seq-let&lt;/a&gt;.</source>
          <target state="translated">바인딩 해제를위한 대체 기능은 &lt;a href=&quot;sequence-functions#seq_002dlet&quot;&gt;seq-let을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c326acf6241c7c0809b501cb8dd76fd10d776f0d" translate="yes" xml:space="preserve">
          <source>For an example of an application using this transport scheme on top of JSONRPC, see the &lt;a href=&quot;https://microsoft.github.io/language-server-protocol/specification&quot;&gt;Language Server Protocol&lt;/a&gt;.</source>
          <target state="translated">JSONRPC 위에이 전송 체계를 사용하는 애플리케이션의 예는 &lt;a href=&quot;https://microsoft.github.io/language-server-protocol/specification&quot;&gt;언어 서버 프로토콜을&lt;/a&gt; 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="6412f08014b3c59973f751a0a41329ada671054a" translate="yes" xml:space="preserve">
          <source>For an interesting example of using &lt;code&gt;apply&lt;/code&gt;, see &lt;a href=&quot;mapping-functions#Definition-of-mapcar&quot;&gt;Definition of mapcar&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;apply&lt;/code&gt; 사용에 대한 흥미로운 예 &lt;a href=&quot;mapping-functions#Definition-of-mapcar&quot;&gt;는 맵카 정의를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2ac62ffb11b1205cd2ec0e3eeb9745d1fcc6ad4f" translate="yes" xml:space="preserve">
          <source>For any other non-&lt;code&gt;nil&lt;/code&gt; action code, the</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; 이 아닌 다른 액션 코드의 경우</target>
        </trans-unit>
        <trans-unit id="f5267fdc1484269b536d70f99bea2db606a9c39b" translate="yes" xml:space="preserve">
          <source>For any two integers &lt;var&gt;dividend&lt;/var&gt; and &lt;var&gt;divisor&lt;/var&gt;,</source>
          <target state="translated">두 정수 &lt;var&gt;dividend&lt;/var&gt; 와 &lt;var&gt;divisor&lt;/var&gt; ,</target>
        </trans-unit>
        <trans-unit id="a72da2a1bc658d9b10287fe8776144e018a0887d" translate="yes" xml:space="preserve">
          <source>For any two numbers &lt;var&gt;dividend&lt;/var&gt; and &lt;var&gt;divisor&lt;/var&gt;,</source>
          <target state="translated">두 수의 &lt;var&gt;dividend&lt;/var&gt; 와 &lt;var&gt;divisor&lt;/var&gt; ,</target>
        </trans-unit>
        <trans-unit id="5efb7641f20d02b2baa5f784be6822d9efd593f5" translate="yes" xml:space="preserve">
          <source>For background, See &lt;a href=&quot;pattern_002dmatching-conditional#Pattern_002dMatching-Conditional&quot;&gt;Pattern-Matching Conditional&lt;/a&gt;.</source>
          <target state="translated">배경은 &lt;a href=&quot;pattern_002dmatching-conditional#Pattern_002dMatching-Conditional&quot;&gt;Pattern-Matching Conditional을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c3502c2bb302e63d8fdc434b18b9e68b88f911a8" translate="yes" xml:space="preserve">
          <source>For backward compatibility, if &lt;var&gt;code-point&lt;/var&gt; doesn&amp;rsquo;t fit in a Lisp fixnum (see &lt;a href=&quot;integer-basics#Integer-Basics&quot;&gt;most-positive-fixnum&lt;/a&gt;), it can be specified as a cons cell &lt;code&gt;(&lt;var&gt;high&lt;/var&gt; . &lt;var&gt;low&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;low&lt;/var&gt; are the lower 16 bits of the value and &lt;var&gt;high&lt;/var&gt; are the high 16 bits. This usage is obsolescent.</source>
          <target state="translated">이전 버전과의 호환성을 위해 &lt;var&gt;code-point&lt;/var&gt; 가 Lisp 고정 번호 ( &lt;a href=&quot;integer-basics#Integer-Basics&quot;&gt;most-positive-fixnum&lt;/a&gt; 참조)에 맞지 않으면 cons 셀 &lt;code&gt;(&lt;var&gt;high&lt;/var&gt; . &lt;var&gt;low&lt;/var&gt;)&lt;/code&gt; 로 지정할 수 있습니다 . 여기서 &lt;var&gt;low&lt;/var&gt; 는 값의 하위 16 비트이고 &lt;var&gt;high&lt;/var&gt; 는 높은 16 비트입니다. 이 사용법은 오래되었습니다.</target>
        </trans-unit>
        <trans-unit id="47a69e571816bd3e5633261d32fa1543fdceb651" translate="yes" xml:space="preserve">
          <source>For backward compatibility, there are obsolete aliases &lt;code&gt;x-get-selection&lt;/code&gt; and &lt;code&gt;x-set-selection&lt;/code&gt;, which were the names of &lt;code&gt;gui-get-selection&lt;/code&gt; and &lt;code&gt;gui-set-selection&lt;/code&gt; before Emacs 25.1.</source>
          <target state="translated">이전 버전과의 호환성을 &lt;code&gt;gui-get-selection&lt;/code&gt; Emacs 25.1 이전 의 gui-get-selection 및 &lt;code&gt;gui-set-selection&lt;/code&gt; 의 이름 인 &lt;code&gt;x-get-selection&lt;/code&gt; 및 &lt;code&gt;x-set-selection&lt;/code&gt; 별칭이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="121e05938fd78cea0604b54505c7ff8a45f6a892" translate="yes" xml:space="preserve">
          <source>For best results, make this variable buffer-local, so that it will disappear after doing its job and will not interfere with the subsequent major mode. See &lt;a href=&quot;hooks#Hooks&quot;&gt;Hooks&lt;/a&gt;.</source>
          <target state="translated">최상의 결과를 얻으려면이 변수를 버퍼 로컬로 설정하여 작업을 수행 한 후 사라지고 후속 주 모드를 방해하지 않도록하십시오. &lt;a href=&quot;hooks#Hooks&quot;&gt;후크를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6ce34402ffe1794374d65dd17b0aaf42c8292bb4" translate="yes" xml:space="preserve">
          <source>For buffers not visiting a file to be restored, the major mode must define a function to do the job, and that function must be listed in the alist &lt;code&gt;desktop-buffer-mode-handlers&lt;/code&gt;.</source>
          <target state="translated">복원 할 파일을 방문하지 않는 버퍼의 경우 주 모드는 작업을 수행하는 기능을 정의해야하며 해당 기능은 alist &lt;code&gt;desktop-buffer-mode-handlers&lt;/code&gt; 에 나열되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="e1e2d59e0ba5fd511d731e5a3da89d45abb82eca" translate="yes" xml:space="preserve">
          <source>For buffers not visiting a file to have their state saved, the major mode must bind the buffer local variable &lt;code&gt;desktop-save-buffer&lt;/code&gt; to a non-&lt;code&gt;nil&lt;/code&gt; value.</source>
          <target state="translated">파일을 방문하지 않는 버퍼의 상태를 저장하려면 주 모드에서 버퍼 로컬 변수 &lt;code&gt;desktop-save-buffer&lt;/code&gt; 를 &lt;code&gt;nil&lt;/code&gt; 이 아닌 값으로 바인딩해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b39dd696e09f4d3cfe391ed2d07e39f2ea51797c" translate="yes" xml:space="preserve">
          <source>For clickable text buttons that send the user to a different buffer or location.</source>
          <target state="translated">사용자를 다른 버퍼 또는 위치로 보내는 클릭 가능한 텍스트 버튼입니다.</target>
        </trans-unit>
        <trans-unit id="9783294e746a5ee573ba95bc5e33919cf41c465b" translate="yes" xml:space="preserve">
          <source>For clicks on a marginal area or on a fringe, this is the buffer position of the first visible character in the corresponding line in the window. For clicks on the mode line, the header line or the tab line, this is &lt;code&gt;nil&lt;/code&gt;. For other events, it is the buffer position closest to the click.</source>
          <target state="translated">경계 영역이나 가장자리를 클릭하는 경우 이것은 창에서 해당 줄에있는 첫 번째 보이는 문자의 버퍼 위치입니다. 모드 라인, 헤더 라인 또는 탭 라인에 대한 클릭의 경우 이것은 &lt;code&gt;nil&lt;/code&gt; 입니다. 다른 이벤트의 경우 클릭에 가장 가까운 버퍼 위치입니다.</target>
        </trans-unit>
        <trans-unit id="fb91260615c03a6f98320ec1431d1a615f829940" translate="yes" xml:space="preserve">
          <source>For clicks on a scroll bar, &lt;var&gt;position&lt;/var&gt; has this form:</source>
          <target state="translated">스크롤바 클릭의 경우 &lt;var&gt;position&lt;/var&gt; 는 다음과 같은 형식입니다.</target>
        </trans-unit>
        <trans-unit id="91f14921ea0887e603038510bd522b9f359946e5" translate="yes" xml:space="preserve">
          <source>For commands to display documentation strings, see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Help.html#Help&quot;&gt;Help&lt;/a&gt; in</source>
          <target state="translated">설명서 문자열을 표시하는 명령은 다음의 &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Help.html#Help&quot;&gt;도움말&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ead2df90c6ccf9b8d39bf9f95b755b0f11d30a67" translate="yes" xml:space="preserve">
          <source>For commands to display documentation strings, see &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/Help.html#Help&quot;&gt;Help&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f041697205704c9b82f5ea10802566a0ac769ba2" translate="yes" xml:space="preserve">
          <source>For compatibility with previous versions of Emacs, &lt;code&gt;window-height&lt;/code&gt; is an alias for &lt;code&gt;window-total-height&lt;/code&gt;, and &lt;code&gt;window-width&lt;/code&gt; is an alias for &lt;code&gt;window-body-width&lt;/code&gt;. These aliases are considered obsolete and will be removed in the future.</source>
          <target state="translated">이전 버전의 Emacs와의 호환성을 위해 &lt;code&gt;window-height&lt;/code&gt; 는 &lt;code&gt;window-total-height&lt;/code&gt; 의 별칭 이고 &lt;code&gt;window-width&lt;/code&gt; 는 &lt;code&gt;window-body-width&lt;/code&gt; 의 별칭입니다 . 이러한 별칭은 사용되지 않는 것으로 간주되며 향후 제거 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="6aeb0736165542de00797d9e9036075c849b9f1d" translate="yes" xml:space="preserve">
          <source>For compatibility, &lt;var&gt;predicate&lt;/var&gt; can also be one of the symbols &lt;code&gt;executable&lt;/code&gt;, &lt;code&gt;readable&lt;/code&gt;, &lt;code&gt;writable&lt;/code&gt;, &lt;code&gt;exists&lt;/code&gt;, or a list of one or more of these symbols.</source>
          <target state="translated">호환성을 위해 &lt;var&gt;predicate&lt;/var&gt; 는 &lt;code&gt;executable&lt;/code&gt; , &lt;code&gt;readable&lt;/code&gt; , &lt;code&gt;writable&lt;/code&gt; , &lt;code&gt;exists&lt;/code&gt; 또는 이러한 기호 중 하나 이상의 목록 중 하나 일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="66900f3ecb19bc7a744771fb6d1b592b9c854053" translate="yes" xml:space="preserve">
          <source>For consistency, you should also specify that element of the history as the initial minibuffer contents, using the &lt;var&gt;initial&lt;/var&gt; argument to the minibuffer input function (see &lt;a href=&quot;initial-input#Initial-Input&quot;&gt;Initial Input&lt;/a&gt;).</source>
          <target state="translated">일관성 을 위해 미니 버퍼 입력 함수에 대한 &lt;var&gt;initial&lt;/var&gt; 인수를 사용하여 히스토리의 해당 요소를 초기 미니 버퍼 내용으로 지정해야 합니다 ( &lt;a href=&quot;initial-input#Initial-Input&quot;&gt;초기 입력&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="74c62700c6d87541270a5795bc335f128345e975" translate="yes" xml:space="preserve">
          <source>For convenience, the &lt;code&gt;jsonrpc&lt;/code&gt; library comes with a built-in &lt;code&gt;jsonrpc-process-connection&lt;/code&gt; transport implementation that can talk to local subprocesses (using the standard input and standard output); or TCP hosts (using sockets); or any other remote endpoint that Emacs&amp;rsquo;s process object can represent (see &lt;a href=&quot;processes#Processes&quot;&gt;Processes&lt;/a&gt;).</source>
          <target state="translated">편의를 위해 &lt;code&gt;jsonrpc&lt;/code&gt; 라이브러리에는 로컬 하위 프로세스와 통신 할 수 있는 기본 제공 &lt;code&gt;jsonrpc-process-connection&lt;/code&gt; 전송 구현 이 함께 제공됩니다 (표준 입력 및 표준 출력 사용). 또는 TCP 호스트 (소켓 사용) 또는 Emacs의 프로세스 객체가 나타낼 수있는 다른 원격 엔드 포인트 ( &lt;a href=&quot;processes#Processes&quot;&gt;Processes&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="043b52ca73b98f1cccd797380f813644ed89dd0c" translate="yes" xml:space="preserve">
          <source>For convenience, there are two sorts of button-creation functions, those that add button properties to an existing region of a buffer, called &lt;code&gt;make-...button&lt;/code&gt;, and those that also insert the button text, called &lt;code&gt;insert-...button&lt;/code&gt;.</source>
          <target state="translated">편의를 위해 두 가지 종류의 버튼 생성 함수가 있습니다. 즉, 기존 버퍼 영역에 버튼 속성을 추가하는 &lt;code&gt;make-...button&lt;/code&gt; 이라는 것과 버튼 텍스트를 삽입하는 기능인 &lt;code&gt;insert-...button&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54dc6f12eb601168a1ac37613145f57827189341" translate="yes" xml:space="preserve">
          <source>For details, see &lt;a href=&quot;syntax-class-table#Syntax-Class-Table&quot;&gt;Syntax Class Table&lt;/a&gt;. Please note that &lt;code&gt;(syntax punctuation)&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; equivalent to the character class &lt;code&gt;punctuation&lt;/code&gt;. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;syntax-class-table#Syntax-Class-Table&quot;&gt;구문 클래스 테이블을&lt;/a&gt; 참조하십시오 . 주의하시기 바랍니다 &lt;code&gt;(syntax punctuation)&lt;/code&gt; 입니다 &lt;em&gt;하지&lt;/em&gt; 문자 클래스에 해당 &lt;code&gt;punctuation&lt;/code&gt; . 해당 문자열 regexp : '</target>
        </trans-unit>
        <trans-unit id="734002e9a587e32b29f5a860c41732ff384a5177" translate="yes" xml:space="preserve">
          <source>For difficult cases, you can add do-nothing macros to your code to give advice to the test coverage tool.</source>
          <target state="translated">어려운 경우 코드에 아무것도하지 않는 매크로를 추가하여 테스트 커버리지 도구에 조언을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11e3a73ca5000b7c31eb2b1c1d6daf9a7ff26858" translate="yes" xml:space="preserve">
          <source>For dimmed-out text. For example, it is used for the ignored part of a filename in the minibuffer (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Minibuffer-File.html#Minibuffer-File&quot;&gt;Minibuffers for File Names&lt;/a&gt; in</source>
          <target state="translated">흐리게 표시된 텍스트 용입니다. 예를 들어, &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Minibuffer-File.html#Minibuffer-File&quot;&gt;미니 버퍼에서 파일 이름&lt;/a&gt; 의 무시 된 부분에 사용됩니다 ( 파일 이름 에 대한 미니 버퍼 참조) .</target>
        </trans-unit>
        <trans-unit id="4d503e2485ae52061b643d80981a73e2c3d9d84f" translate="yes" xml:space="preserve">
          <source>For dimmed-out text. For example, it is used for the ignored part of a filename in the minibuffer (see &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/Minibuffer-File.html#Minibuffer-File&quot;&gt;Minibuffers for File Names&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5592d06734e01b56669b7b1caf8a3c141e8d7c72" translate="yes" xml:space="preserve">
          <source>For each &lt;var&gt;package&lt;/var&gt;, which is a symbol, there are one or more elements that contain a package version &lt;var&gt;pversion&lt;/var&gt; with an associated Emacs version &lt;var&gt;eversion&lt;/var&gt;. These versions are strings. For example, the MH-E package updates this alist with the following:</source>
          <target state="translated">각 &lt;var&gt;package&lt;/var&gt; 상징, 패키지 버전을 포함하는 하나 개 이상의 요소가 존재 &lt;var&gt;pversion&lt;/var&gt; 연관된 이맥스 버전과 &lt;var&gt;eversion&lt;/var&gt; . 이러한 버전은 문자열입니다. 예를 들어 MH-E 패키지는이 목록을 다음과 같이 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="585b81ea7d737603e85999c64cc945eb2153ae26" translate="yes" xml:space="preserve">
          <source>For each directory in &lt;code&gt;load-path&lt;/code&gt;, Emacs then checks to see if it contains a file</source>
          <target state="translated">&lt;code&gt;load-path&lt;/code&gt; 의 각 디렉토리에 대해 Emacs는 파일이 포함되어 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="d779a4ebd64888b38cfe346c6e444aa365dc3c8d" translate="yes" xml:space="preserve">
          <source>For each internal window, the screen areas of the immediate children are arranged either vertically or horizontally (never both). If the child windows are arranged one above the other, they are said to form a &lt;em&gt;vertical combination&lt;/em&gt;; if they are arranged side by side, they are said to form a &lt;em&gt;horizontal combination&lt;/em&gt;. Consider the following example:</source>
          <target state="translated">각 내부 창에 대해 직계 자식의 화면 영역은 세로 또는 가로로 정렬됩니다 (둘 다 아님). 자식 창을 위아래로 배열하면 &lt;em&gt;세로 조합&lt;/em&gt; 을 형성한다고합니다 . 나란히 배열하면 &lt;em&gt;수평 조합&lt;/em&gt; 을 형성한다고합니다 . 다음 예를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="743c690cc98b53d8a1c6cfd4427025d5e238101a" translate="yes" xml:space="preserve">
          <source>For efficiency this function might return a value that is &lt;code&gt;eq&lt;/code&gt; to &lt;var&gt;time&lt;/var&gt;, or that otherwise shares structure with &lt;var&gt;time&lt;/var&gt;.</source>
          <target state="translated">효율성을 위해이 기능은 값을 반환 할 수 있습니다 &lt;code&gt;eq&lt;/code&gt; 에 &lt;var&gt;time&lt;/var&gt; , 또는와 그 다른 주 구조 &lt;var&gt;time&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="c8a1f0205dc400cc4bfe8517f02f340b224dbb0d" translate="yes" xml:space="preserve">
          <source>For efficiency, Emacs does not continuously recompute each window&amp;rsquo;s mode line and header line. It does so when circumstances appear to call for it&amp;mdash;for instance, if you change the window configuration, switch buffers, narrow or widen the buffer, scroll, or modify the buffer. If you alter any of the variables referenced by &lt;code&gt;mode-line-format&lt;/code&gt; or &lt;code&gt;header-line-format&lt;/code&gt; (see &lt;a href=&quot;mode-line-variables#Mode-Line-Variables&quot;&gt;Mode Line Variables&lt;/a&gt;), or any other data structures that affect how text is displayed (see &lt;a href=&quot;display#Display&quot;&gt;Display&lt;/a&gt;), you should use the function &lt;code&gt;force-mode-line-update&lt;/code&gt; to update the display.</source>
          <target state="translated">효율성을 위해 Emacs는 각 창의 모드 행과 헤더 행을 계속해서 재 계산하지 않습니다. 예를 들어 창 구성을 변경하거나 버퍼를 전환하거나 버퍼를 좁히거나 넓히거나, 스크롤하거나 버퍼를 수정하는 경우와 같이 상황이이를 요구하는 것처럼 보일 때 그렇게합니다. 당신이 참조하는 변수의 변경하는 경우 &lt;code&gt;mode-line-format&lt;/code&gt; 또는 &lt;code&gt;header-line-format&lt;/code&gt; (참조 &lt;a href=&quot;mode-line-variables#Mode-Line-Variables&quot;&gt;모드 라인 변수&lt;/a&gt; ) 또는 텍스트 (참조 표시되는 방식에 영향을주는 다른 데이터 구조 &lt;a href=&quot;display#Display&quot;&gt;디스플레이&lt;/a&gt; ), 당신은 함수를 사용해야 &lt;code&gt;force-mode-line-update&lt;/code&gt; 를 사용하여 디스플레이를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="f6f082c77d40eec0a94cd546026872b5e62ed240" translate="yes" xml:space="preserve">
          <source>For efficiency, we recommend writing these functions so that they usually assign faces to around 400 to 600 characters at each call.</source>
          <target state="translated">효율성을 위해 이러한 함수를 작성하여 일반적으로 각 호출에서 약 400 ~ 600 자에 얼굴을 할당하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b45b099ef44308af9850ef419b10729db525c224" translate="yes" xml:space="preserve">
          <source>For elements whose &lt;var&gt;matcher&lt;/var&gt; is a function, the function should ensure that submatch 0 covers the whole relevant multiline construct, even if only a small subpart will be highlighted. It is often just as easy to add the &lt;code&gt;font-lock-multiline&lt;/code&gt; property by hand.</source>
          <target state="translated">&lt;var&gt;matcher&lt;/var&gt; 자가 함수 인 요소의 경우 함수는 작은 하위 부분 만 강조 표시 되더라도 하위 일치 0이 전체 관련 여러 줄 구성을 포함하는지 확인해야합니다. &lt;code&gt;font-lock-multiline&lt;/code&gt; 속성을 직접 추가하는 것만큼이나 쉽습니다 .</target>
        </trans-unit>
        <trans-unit id="dc3c09a115b4ee611eb7505826a4fa0c2a8495d8" translate="yes" xml:space="preserve">
          <source>For example</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="1da55473e7e0bd5ddce679a996ae1f4bc172ce33" translate="yes" xml:space="preserve">
          <source>For example &lt;code&gt;(168 . mute-acute)&lt;/code&gt; defines a system-specific key (used by HP X servers) whose numeric code is -2**28 + 168.</source>
          <target state="translated">예를 들어 &lt;code&gt;(168 . mute-acute)&lt;/code&gt; 는 숫자 코드가 -2 ** 28 + 168 인 시스템 특정 키 (HP X 서버에서 사용 )를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="67c7bfe6911146baef42ccf95311646fa6de1225" translate="yes" xml:space="preserve">
          <source>For example, &amp;lsquo;</source>
          <target state="translated">예를 들어 '</target>
        </trans-unit>
        <trans-unit id="744b687fbce69d0c70cd3e18220f9dacadd484ee" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;((top . left) (t . right))&lt;/code&gt; places the top angle bitmap in left fringe, and the bottom angle bitmap as well as both arrow bitmaps in right fringe. To show the angle bitmaps in the left fringe, and no arrow bitmaps, use &lt;code&gt;((top .  left) (bottom . left))&lt;/code&gt;.</source>
          <target state="translated">예를 들어, &lt;code&gt;((top . left) (t . right))&lt;/code&gt; 는 위쪽 각도 비트 맵을 왼쪽 가장자리에 배치하고 아래쪽 각도 비트 맵과 양쪽 화살표 비트 맵을 오른쪽 가장자리에 배치합니다. 왼쪽 가장자리에 각도 비트 맵을 표시하고 화살표 비트 맵은 표시하지 않으려면 &lt;code&gt;((top . left) (bottom . left))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f964fb57ecfe5d927e9308065e31b4bf29558753" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;(format-mode-line header-line-format)&lt;/code&gt; returns the text that would appear in the selected window&amp;rsquo;s header line (&lt;code&gt;&quot;&quot;&lt;/code&gt; if it has no header line). &lt;code&gt;(format-mode-line header-line-format
'header-line)&lt;/code&gt; returns the same text, with each character carrying the face that it will have in the header line itself, and also redraws the header line.</source>
          <target state="translated">예를 들어, &lt;code&gt;(format-mode-line header-line-format)&lt;/code&gt; 은 선택한 창의 헤더 행 (헤더 행 이없는 경우 &lt;code&gt;&quot;&quot;&lt;/code&gt; )에 나타날 텍스트를 반환합니다 . &lt;code&gt;(format-mode-line header-line-format 'header-line)&lt;/code&gt; 은 동일한 텍스트를 반환하며 각 문자는 헤더 행 자체에있는 얼굴을 가지고 있으며 헤더 행도 다시 그립니다.</target>
        </trans-unit>
        <trans-unit id="efc83ffc3386e01c1e8ade2e8cd7e012a462a074" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;(list integer string function)&lt;/code&gt; describes a list of three elements; the first element must be an integer, the second a string, and the third a function.</source>
          <target state="translated">예를 들어, &lt;code&gt;(list integer string function)&lt;/code&gt; 은 세 가지 요소의 목록을 설명합니다. 첫 번째 요소는 정수, 두 번째 요소는 문자열, 세 번째 요소는 함수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="3ef44bbdb2e48aa8186cb898c6acf5f8c9242879" translate="yes" xml:space="preserve">
          <source>For example, VT100 terminals send</source>
          <target state="translated">예를 들어, VT100 터미널은</target>
        </trans-unit>
        <trans-unit id="23ba4f1aaf8956b33e5b48d8206686c31ca1190c" translate="yes" xml:space="preserve">
          <source>For example, after evaluating &lt;code&gt;(fac 5)&lt;/code&gt; with a source breakpoint, and setting &lt;code&gt;edebug-test-coverage&lt;/code&gt; to &lt;code&gt;t&lt;/code&gt;, when the breakpoint is reached, the frequency data looks like this:</source>
          <target state="translated">예를 들어 소스 중단 점으로 평가 &lt;code&gt;(fac 5)&lt;/code&gt; 하고 &lt;code&gt;edebug-test-coverage&lt;/code&gt; 를 &lt;code&gt;t&lt;/code&gt; 로 설정 한 후 중단 점에 도달하면 빈도 데이터는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a05e8356c63b07a3e3fc9b2fa536ac0bcc4967b7" translate="yes" xml:space="preserve">
          <source>For example, an argument list that looks like this:</source>
          <target state="translated">예를 들어, 다음과 같은 인수 목록 :</target>
        </trans-unit>
        <trans-unit id="05d69093edb129241b3a840cf6b1b328b6242dcb" translate="yes" xml:space="preserve">
          <source>For example, characters with different coding points but the same meaning might be considered as equal, like different grave accent Unicode characters:</source>
          <target state="translated">예를 들어, 코딩 포인트는 다르지만 의미는 같은 문자는 다른 억음 악센트 유니 코드 문자처럼 동일한 것으로 간주 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27adeb48c032951b6d20992076af3c8afa49c305" translate="yes" xml:space="preserve">
          <source>For example, from the following we deduce that any attempt to read a file in</source>
          <target state="translated">예를 들어, 다음에서 우리는 파일을 읽으려는 시도가</target>
        </trans-unit>
        <trans-unit id="0273d690dd99e985b0b2971241e85b32b497db6a" translate="yes" xml:space="preserve">
          <source>For example, given a macro defined as follows:</source>
          <target state="translated">예를 들어 다음과 같이 정의 된 매크로가 있습니다.</target>
        </trans-unit>
        <trans-unit id="db74331eb04a1de8dbcacf0c70f3b3441856bf28" translate="yes" xml:space="preserve">
          <source>For example, here are the file attributes for</source>
          <target state="translated">예를 들어, 다음은 파일 속성입니다.</target>
        </trans-unit>
        <trans-unit id="005c7abc213860be7f588f0de309060be8ddf15b" translate="yes" xml:space="preserve">
          <source>For example, here is how Emacs sets the parent of &lt;code&gt;help-mode-map&lt;/code&gt;, such that it inherits from both &lt;code&gt;button-buffer-map&lt;/code&gt; and &lt;code&gt;special-mode-map&lt;/code&gt;:</source>
          <target state="translated">예를 들어, Emacs가 &lt;code&gt;help-mode-map&lt;/code&gt; 의 부모를 설정하는 방법 은 &lt;code&gt;button-buffer-map&lt;/code&gt; 및 &lt;code&gt;special-mode-map&lt;/code&gt; 모두에서 상속 됩니다 .</target>
        </trans-unit>
        <trans-unit id="8b9b4bb05ac508d1f9ca72c94fdcaa4c15ce5531" translate="yes" xml:space="preserve">
          <source>For example, here is how Info mode handles</source>
          <target state="translated">예를 들어, 다음은 정보 모드가</target>
        </trans-unit>
        <trans-unit id="965efa71bb0bbcfbc42c969ae3abf4c71959d610" translate="yes" xml:space="preserve">
          <source>For example, here is how pcvs enables</source>
          <target state="translated">예를 들어 다음은 pcvs가</target>
        </trans-unit>
        <trans-unit id="ef5d21db3ba65b99f498854b10fea91677ea3a8d" translate="yes" xml:space="preserve">
          <source>For example, here is how to construct a display table that mimics the effect of setting &lt;code&gt;ctl-arrow&lt;/code&gt; to a non-&lt;code&gt;nil&lt;/code&gt; value (see &lt;a href=&quot;glyphs#Glyphs&quot;&gt;Glyphs&lt;/a&gt;, for the function &lt;code&gt;make-glyph-code&lt;/code&gt;):</source>
          <target state="translated">예를 들어, 다음은 &lt;code&gt;ctl-arrow&lt;/code&gt; 를 &lt;code&gt;nil&lt;/code&gt; 이 아닌 값 으로 설정 한 효과를 모방 한 표시 테이블을 구성하는 방법입니다 ( &lt;code&gt;make-glyph-code&lt;/code&gt; 함수에 대해서는 &lt;a href=&quot;glyphs#Glyphs&quot;&gt;Glyphs&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="595d53d45350a65aafc72a30d20894f7a9984264" translate="yes" xml:space="preserve">
          <source>For example, here is how to set the &lt;code&gt;comment&lt;/code&gt; and &lt;code&gt;face&lt;/code&gt; properties of a range of text:</source>
          <target state="translated">예를 들어, 다음은 텍스트 범위의 &lt;code&gt;comment&lt;/code&gt; 및 &lt;code&gt;face&lt;/code&gt; 속성 을 설정하는 방법 입니다.</target>
        </trans-unit>
        <trans-unit id="74a09f53a928afdb5314957c2f2bf981977e0431" translate="yes" xml:space="preserve">
          <source>For example, here we make an invisible buffer for temporary use, and make sure to kill it before finishing:</source>
          <target state="translated">예를 들어, 여기서 임시 사용을 위해 보이지 않는 버퍼를 만들고 완료하기 전에 반드시 죽여야합니다.</target>
        </trans-unit>
        <trans-unit id="c5f653d685daad8272ec011f525c34b0738959db" translate="yes" xml:space="preserve">
          <source>For example, here&amp;rsquo;s the definition of the standard face &lt;code&gt;highlight&lt;/code&gt;:</source>
          <target state="translated">예를 들어, 다음은 표준 얼굴 &lt;code&gt;highlight&lt;/code&gt; 의 정의입니다 .</target>
        </trans-unit>
        <trans-unit id="395ba922e8b33bcf9d38dae422d749535c7b11b4" translate="yes" xml:space="preserve">
          <source>For example, if &lt;var&gt;name&lt;/var&gt; is &lt;code&gt;(a b 2 c)&lt;/code&gt;, that means to find field &lt;code&gt;c&lt;/code&gt; in the third element of subfield &lt;code&gt;b&lt;/code&gt; of field &lt;code&gt;a&lt;/code&gt;. (This corresponds to &lt;code&gt;struct.a.b[2].c&lt;/code&gt; in C.)</source>
          <target state="translated">예를 들어 &lt;var&gt;name&lt;/var&gt; 이 &lt;code&gt;(a b 2 c)&lt;/code&gt; 이면 필드 &lt;code&gt;b&lt;/code&gt; 의 서브 필드 b 의 세 번째 요소에서 필드 &lt;code&gt;c&lt;/code&gt; 를 찾는 것을 의미 &lt;code&gt;a&lt;/code&gt; . (이것은 C의 &lt;code&gt;struct.a.b[2].c&lt;/code&gt; 에 해당합니다.)</target>
        </trans-unit>
        <trans-unit id="0ff800dd3253158d07e32e80e98d75b35fc7a3ef" translate="yes" xml:space="preserve">
          <source>For example, if Font-Lock mode is enabled, you might get results like these:</source>
          <target state="translated">예를 들어 글꼴 잠금 모드가 활성화 된 경우 다음과 같은 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df6fc5dabfc94afe09280ab88b14c7122922b50e" translate="yes" xml:space="preserve">
          <source>For example, if point is 1 and you set the start of the window to 37, the start of the next line, point will be above the top of the window. The display routines will automatically move point if it is still 1 when redisplay occurs. Here is an example:</source>
          <target state="translated">예를 들어, 포인트가 1이고 창 시작을 37로 설정하면 다음 줄의 시작 지점이 창 상단 위에 있습니다. 재 표시가 발생할 때 여전히 1 인 경우 표시 루틴은 자동으로 포인트를 이동합니다. 다음은 그 예입니다.</target>
        </trans-unit>
        <trans-unit id="bb0699bd8f47a3e8cccd5e7fd0f027e76b217cb4" translate="yes" xml:space="preserve">
          <source>For example, if the current buffer name is &amp;lsquo;</source>
          <target state="translated">예를 들어, 현재 버퍼 이름이 '</target>
        </trans-unit>
        <trans-unit id="adb2b1888f6b5b7287616e1bc0062845ce891f7f" translate="yes" xml:space="preserve">
          <source>For example, if we distribute version 1.3 of the superfrobnicator as a multi-file package, the tar file would be</source>
          <target state="translated">예를 들어, superfrobnicator 1.3 버전을 다중 파일 패키지로 배포하는 경우 tar 파일은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="129a058c7280c246533530a1fd820643df60b883" translate="yes" xml:space="preserve">
          <source>For example, if you call &lt;code&gt;read-key-sequence&lt;/code&gt; and then click the mouse on the window&amp;rsquo;s mode line, you get two events, like this:</source>
          <target state="translated">예를 들어 &lt;code&gt;read-key-sequence&lt;/code&gt; 를 호출 한 다음 창의 모드 행에서 마우스를 클릭하면 다음과 같은 두 가지 이벤트가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d09e7149c4c55ac025b6b60f987664076f98cc22" translate="yes" xml:space="preserve">
          <source>For example, if you plan to sort all the lines in the region by the first word on each line starting with the letter &amp;lsquo;</source>
          <target state="translated">예를 들어, 문자 '로 시작하는 각 줄의 첫 번째 단어를 기준으로 영역의 모든 줄을 정렬하려는 경우</target>
        </trans-unit>
        <trans-unit id="485357f2c908b453f13370041021bdb6b189d1b3" translate="yes" xml:space="preserve">
          <source>For example, in</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="68c35d1e3bb1c66f44569c82c8af6a96b625a484" translate="yes" xml:space="preserve">
          <source>For example, in the standard syntax table, the entry for &amp;lsquo;</source>
          <target state="translated">예를 들어, 표준 구문 테이블에서 '</target>
        </trans-unit>
        <trans-unit id="49538d0b2708caa4cbfe7507522436cff4c2aa9b" translate="yes" xml:space="preserve">
          <source>For example, punctuation and whitespace characters might be ignored for sorting (see &lt;a href=&quot;sequence-functions#Sequence-Functions&quot;&gt;Sequence Functions&lt;/a&gt;):</source>
          <target state="translated">예를 들어, 구두점 및 공백 문자는 정렬시 무시 될 수 있습니다 ( &lt;a href=&quot;sequence-functions#Sequence-Functions&quot;&gt;시퀀스 함수&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="2166ab4db5dbdc8250f642388719feb57292d22d" translate="yes" xml:space="preserve">
          <source>For example, setting this variable is useful to get a backtrace from code evaluated by emacsclient&amp;rsquo;s</source>
          <target state="translated">예를 들어,이 변수를 설정하면 emacsclient의 평가 코드에서 역 추적을 얻는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="5420205529242dca31bafacc450a37a00adac6c1" translate="yes" xml:space="preserve">
          <source>For example, suppose My mode provides a special command &lt;code&gt;my-kill-line&lt;/code&gt;, which should be invoked instead of &lt;code&gt;kill-line&lt;/code&gt;. To establish this, its mode keymap should contain the following remapping:</source>
          <target state="translated">예를 들어, 내 모드가 특별한 명령을 제공한다고 가정 &lt;code&gt;my-kill-line&lt;/code&gt; 대신 호출해야, &lt;code&gt;kill-line&lt;/code&gt; . 이를 설정하려면 모드 키맵에 다음 재 매핑이 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="6735e17f34be2237ed73b289e8fd1588a3f7c8b3" translate="yes" xml:space="preserve">
          <source>For example, the &lt;code&gt;shell-command-on-region&lt;/code&gt; command uses &lt;code&gt;call-shell-region&lt;/code&gt; in a manner similar to this:</source>
          <target state="translated">예를 들어 &lt;code&gt;shell-command-on-region&lt;/code&gt; 명령은 다음과 유사한 방식으로 &lt;code&gt;call-shell-region&lt;/code&gt; 을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="27ee27aae03dd0ad802396582186884cc3bbd399" translate="yes" xml:space="preserve">
          <source>For example, the following code adds two fontification patterns for C mode: one to fontify the word &amp;lsquo;</source>
          <target state="translated">예를 들어 다음 코드는 C 모드에 대해 두 가지 글꼴 패턴을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="175738e16217893190fe59a465d2f0cbf4a51eae" translate="yes" xml:space="preserve">
          <source>For example, the following code would assign an italicized green face to the text between &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt;:</source>
          <target state="translated">예를 들어 다음 코드는 &lt;var&gt;start&lt;/var&gt; 과 &lt;var&gt;end&lt;/var&gt; 사이의 텍스트에 기울임 꼴 녹색면을 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="fe4398851e7138b4cfe9a97b657ef55520230c8a" translate="yes" xml:space="preserve">
          <source>For example, the function that implements numeric prefix arguments reads any number of digits. When it finds a non-digit event, it must unread the event so that it can be read normally by the command loop. Likewise, incremental search uses this feature to unread events with no special meaning in a search, because these events should exit the search and then execute normally.</source>
          <target state="translated">예를 들어 숫자 접두사 인수를 구현하는 함수는 임의의 자릿수를 읽습니다. 숫자가 아닌 이벤트를 발견하면 명령 루프에서 정상적으로 읽을 수 있도록 이벤트를 읽지 않아야합니다. 마찬가지로 증분 검색은 검색에서 특별한 의미가없는 읽지 않은 이벤트에이 기능을 사용합니다. 이러한 이벤트는 검색을 종료 한 다음 정상적으로 실행되어야하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="384f2d22a8a927ed244f80bc1dc93234f2018dcb" translate="yes" xml:space="preserve">
          <source>For example, the regular expression &amp;lsquo;</source>
          <target state="translated">예를 들어 정규 표현식 '</target>
        </trans-unit>
        <trans-unit id="b2ef5659cb8be7a6b60ecf6bbc0af64c87f3fe3c" translate="yes" xml:space="preserve">
          <source>For example, the syntax descriptor for the character &amp;lsquo;</source>
          <target state="translated">예를 들어, 문자 '</target>
        </trans-unit>
        <trans-unit id="4585c648d09853d23b2922efeb34fb0dcfabedb0" translate="yes" xml:space="preserve">
          <source>For example, the usual way to show what percentage of a buffer is above the top of the window is to use a list like this: &lt;code&gt;(-3 &quot;%p&quot;)&lt;/code&gt;.</source>
          <target state="translated">예를 들어, 창 상단 위에있는 버퍼의 백분율을 표시하는 일반적인 방법은 다음과 같은 목록을 사용하는 것입니다 : &lt;code&gt;(-3 &quot;%p&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bbd366bf7da22ebc87b5581744b6af4853c2f8fd" translate="yes" xml:space="preserve">
          <source>For example, this expression tests whether &lt;code&gt;x&lt;/code&gt; is either &lt;code&gt;nil&lt;/code&gt; or the integer zero:</source>
          <target state="translated">예를 들어, 다음 표현식 은 &lt;code&gt;x&lt;/code&gt; 가 &lt;code&gt;nil&lt;/code&gt; 인지 정수 0 인지 테스트합니다 .</target>
        </trans-unit>
        <trans-unit id="2c848e5dda222b3589fe7c48d05f8bcd6f0e6905" translate="yes" xml:space="preserve">
          <source>For example, this redefines</source>
          <target state="translated">예를 들어, 이것은</target>
        </trans-unit>
        <trans-unit id="8b0e6046e3d16467ee010606573cdfcbd88b269c" translate="yes" xml:space="preserve">
          <source>For example, to find the buffer position of column &lt;var&gt;col&lt;/var&gt; of screen line &lt;var&gt;line&lt;/var&gt; of a certain window, pass the window&amp;rsquo;s display start location as &lt;var&gt;from&lt;/var&gt; and the window&amp;rsquo;s upper-left coordinates as &lt;var&gt;frompos&lt;/var&gt;. Pass the buffer&amp;rsquo;s &lt;code&gt;(point-max)&lt;/code&gt; as &lt;var&gt;to&lt;/var&gt;, to limit the scan to the end of the accessible portion of the buffer, and pass &lt;var&gt;line&lt;/var&gt; and &lt;var&gt;col&lt;/var&gt; as &lt;var&gt;topos&lt;/var&gt;. Here&amp;rsquo;s a function that does this:</source>
          <target state="translated">예를 들어, 특정 윈도우 의 화면 라인 &lt;var&gt;line&lt;/var&gt; 의 &lt;var&gt;col&lt;/var&gt; 컬럼 의 버퍼 위치를 찾으려면 윈도우의 표시 시작 위치를 &lt;var&gt;from&lt;/var&gt; 으로 전달하고 창의 왼쪽 상단 좌표를 &lt;var&gt;frompos&lt;/var&gt; 로 전달 합니다. 버퍼의 &lt;code&gt;(point-max)&lt;/code&gt; as &lt;var&gt;to&lt;/var&gt; 를 전달하여 스캔을 버퍼의 액세스 가능한 부분의 끝으로 제한하고 &lt;var&gt;line&lt;/var&gt; 및 &lt;var&gt;col&lt;/var&gt; 을 &lt;var&gt;topos&lt;/var&gt; 로 전달 합니다 . 이를 수행하는 함수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9e942398938b535914ef7e95735c0d1f57c8343d" translate="yes" xml:space="preserve">
          <source>For example, to match &lt;var&gt;expval&lt;/var&gt; that must be a list of two elements whose first element is a specific string and the second element is any value, you can write a core pattern:</source>
          <target state="translated">예를 들어 첫 번째 요소가 특정 문자열이고 두 번째 요소가 임의의 값인 두 요소의 목록이어야하는 &lt;var&gt;expval&lt;/var&gt; 을 일치 시키 려면 핵심 패턴을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8647d2af0d56d8b4d684ccdc41d0e7ef012c977f" translate="yes" xml:space="preserve">
          <source>For example, to specify a list whose first element must be &lt;code&gt;baz&lt;/code&gt; and whose remaining arguments should be zero or more of &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt;, use this customization type:</source>
          <target state="translated">예를 들어, 첫 번째 요소가 &lt;code&gt;baz&lt;/code&gt; 여야 하고 나머지 인수가 &lt;code&gt;foo&lt;/code&gt; 및 &lt;code&gt;bar&lt;/code&gt; 중 0 이상 이어야하는 목록을 지정 하려면 다음 사용자 정의 유형을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3fced1f25af160096cf3380284c60e8f0069d9a0" translate="yes" xml:space="preserve">
          <source>For example, using 4-bit binary numbers, the bitwise AND of 13 and 12 is 12: 1101 combined with 1100 produces 1100. In both the binary numbers, the leftmost two bits are both 1 so the leftmost two bits of the returned value are both 1. However, for the rightmost two bits, each is 0 in at least one of the arguments, so the rightmost two bits of the returned value are both 0.</source>
          <target state="translated">예를 들어, 4 비트 이진수를 사용하면 13과 12의 비트 AND는 12입니다. 1100과 1100을 결합하면 1100이 생성됩니다. 두 이진수에서 가장 왼쪽 두 비트는 모두 1이므로 반환 된 값의 가장 왼쪽 두 비트는 다음과 같습니다. 둘 다 1. 그러나 맨 오른쪽 두 비트의 경우 인수 중 하나 이상에서 각각 0이되므로 반환 된 값의 맨 오른쪽 두 비트는 모두 0입니다.</target>
        </trans-unit>
        <trans-unit id="a991b30b321a789877e152611b03f5b1bbf24c9c" translate="yes" xml:space="preserve">
          <source>For example, when a function is called, its argument variables receive local values, which are the actual arguments supplied to the function call; these local bindings take effect within the body of the function. To take another example, the &lt;code&gt;let&lt;/code&gt; special form explicitly establishes local bindings for specific variables, which take effect only within the body of the &lt;code&gt;let&lt;/code&gt; form.</source>
          <target state="translated">예를 들어, 함수가 호출되면 해당 인수 변수는 함수 호출에 제공된 실제 인수 인 로컬 값을받습니다. 이러한 로컬 바인딩은 함수 본문 내에서 적용됩니다. 또 다른 예를 들어, &lt;code&gt;let&lt;/code&gt; 특수 양식은 특정 변수에 대한 로컬 바인딩을 명시 적으로 설정하며 이는 &lt;code&gt;let&lt;/code&gt; 양식 의 본문 내에서만 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="302d045a398db08075b269c868fcbd268402b1ec" translate="yes" xml:space="preserve">
          <source>For example, you could define &lt;code&gt;name&lt;/code&gt; to mean &lt;code&gt;(one-or-more letter)&lt;/code&gt;, and &lt;code&gt;(quoted &lt;var&gt;x&lt;/var&gt;)&lt;/code&gt; to mean &lt;code&gt;(seq ?' &lt;var&gt;x&lt;/var&gt; ?')&lt;/code&gt; for any &lt;var&gt;x&lt;/var&gt;. These forms could then be used in &lt;code&gt;rx&lt;/code&gt; expressions like any other: &lt;code&gt;(rx (quoted name))&lt;/code&gt; would match a nonempty sequence of letters inside single quotes.</source>
          <target state="translated">예를 들어, 사용자가 정의 할 수 &lt;code&gt;name&lt;/code&gt; 의미하는 &lt;code&gt;(one-or-more letter)&lt;/code&gt; 및 &lt;code&gt;(quoted &lt;var&gt;x&lt;/var&gt;)&lt;/code&gt; 의미 &lt;code&gt;(seq ?' &lt;var&gt;x&lt;/var&gt; ?')&lt;/code&gt; 어떤을위한 &lt;var&gt;x&lt;/var&gt; . 이 형식은 다른 모든 식과 마찬가지로 &lt;code&gt;rx&lt;/code&gt; 식에서 사용할 수 있습니다 . &lt;code&gt;(rx (quoted name))&lt;/code&gt; 은 작은 따옴표 안에있는 비어 있지 않은 문자 시퀀스와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="14b38a77b4f2c99de9b60a13e177bd689dcadc7c" translate="yes" xml:space="preserve">
          <source>For examples of key sequences written in string and vector representations, &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Init-Rebinding.html#Init-Rebinding&quot;&gt;Init Rebinding&lt;/a&gt; in</source>
          <target state="translated">문자열 및 벡터 표현으로 작성된 키 시퀀스의 예를 보려면 &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Init-Rebinding.html#Init-Rebinding&quot;&gt;Init Rebinding&lt;/a&gt; in</target>
        </trans-unit>
        <trans-unit id="625c3178d4b4c643caa32d52e1c5638502985dcf" translate="yes" xml:space="preserve">
          <source>For examples of key sequences written in string and vector representations, &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/Init-Rebinding.html#Init-Rebinding&quot;&gt;Init Rebinding&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="756ed62664ef2f85085fafd6014de3a11655e566" translate="yes" xml:space="preserve">
          <source>For flexibility, the</source>
          <target state="translated">유연성을 위해</target>
        </trans-unit>
        <trans-unit id="885fd45c866065f1ec4b303a41cc5a28f9d59115" translate="yes" xml:space="preserve">
          <source>For frames with an internal menu or tool bar, the frame&amp;rsquo;s native height cannot be told exactly before the frame has been actually drawn. This means that in general you cannot use the native size to specify the initial size of a frame. As soon as you know the native size of a visible frame, you can calculate its outer size (see &lt;a href=&quot;frame-layout#Frame-Layout&quot;&gt;Frame Layout&lt;/a&gt;) by adding in the remaining components from the return value of &lt;code&gt;frame-geometry&lt;/code&gt;. For invisible frames or for frames that have yet to be created, however, the outer size can only be estimated. This also means that calculating an exact initial position of a frame specified via offsets from the right or bottom edge of the screen (see &lt;a href=&quot;frame-position#Frame-Position&quot;&gt;Frame Position&lt;/a&gt;) is impossible.</source>
          <target state="translated">내부 메뉴 또는 도구 모음이있는 프레임의 경우 프레임이 실제로 그려지기 전에 프레임의 기본 높이를 정확히 알 수 없습니다. 이것은 일반적으로 프레임의 초기 크기를 지정하는 데 기본 크기를 사용할 수 없음을 의미합니다. 표시되는 프레임의 기본 크기를 알게되면 &lt;code&gt;frame-geometry&lt;/code&gt; 의 반환 값에서 나머지 구성 요소를 추가 하여 외부 크기를 계산할 수 있습니다 ( &lt;a href=&quot;frame-layout#Frame-Layout&quot;&gt;프레임 레이아웃&lt;/a&gt; 참조 ) . 그러나 보이지 않는 프레임이나 아직 생성되지 않은 프레임의 경우 외부 크기 만 추정 할 수 있습니다. 이는 또한 화면의 오른쪽 또는 하단 가장자리에서 오프셋을 통해 지정된 프레임의 정확한 초기 위치를 계산하는 것이 불가능 함을 의미합니다 ( &lt;a href=&quot;frame-position#Frame-Position&quot;&gt;프레임 위치&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="2f94eeb4c257732d5e9d9e2db099193ac251cd9c" translate="yes" xml:space="preserve">
          <source>For functions and variables related to visiting files in buffers, see &lt;a href=&quot;visiting-files#Visiting-Files&quot;&gt;Visiting Files&lt;/a&gt; and &lt;a href=&quot;saving-buffers#Saving-Buffers&quot;&gt;Saving Buffers&lt;/a&gt;. For functions and variables related to the display of buffers in windows, see &lt;a href=&quot;buffers-and-windows#Buffers-and-Windows&quot;&gt;Buffers and Windows&lt;/a&gt;.</source>
          <target state="translated">버퍼의 파일 방문과 관련된 함수 및 변수는 파일 &lt;a href=&quot;visiting-files#Visiting-Files&quot;&gt;방문&lt;/a&gt; 및 &lt;a href=&quot;saving-buffers#Saving-Buffers&quot;&gt;버퍼 저장을&lt;/a&gt; 참조하십시오 . 창에서 버퍼 표시와 관련된 함수 및 변수는 &lt;a href=&quot;buffers-and-windows#Buffers-and-Windows&quot;&gt;버퍼 및&lt;/a&gt; 창을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="096e441f5d07c9aeca48a8c3b6c68d8259beb478" translate="yes" xml:space="preserve">
          <source>For good performance, it&amp;rsquo;s very important to use the &lt;var&gt;limit&lt;/var&gt; argument to these functions, especially the ones that search for a single property&amp;mdash;otherwise, they may spend a long time scanning to the end of the buffer, if the property you are interested in does not change.</source>
          <target state="translated">좋은 성능을 위해서는 이러한 함수, 특히 단일 속성을 검색하는 함수에 &lt;var&gt;limit&lt;/var&gt; 인수 를 사용하는 것이 매우 중요합니다. 그렇지 않으면 관심있는 속성이 수행하는 경우 버퍼 끝까지 스캔하는 데 오랜 시간이 걸릴 수 있습니다. 변경 없음.</target>
        </trans-unit>
        <trans-unit id="c636758eb9f2ccf22d584f3ccf22195b5beb19a7" translate="yes" xml:space="preserve">
          <source>For graphical terminals, note that on multi-monitor setups this refers to the height for all physical monitors associated with &lt;var&gt;display&lt;/var&gt;. See &lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;Multiple Terminals&lt;/a&gt;.</source>
          <target state="translated">그래픽 터미널의 경우 다중 모니터 설정에서 이는 &lt;var&gt;display&lt;/var&gt; 와 관련된 모든 물리적 모니터의 높이를 나타냅니다 . &lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;다중 터미널을&lt;/a&gt; 참고하십시오 .</target>
        </trans-unit>
        <trans-unit id="4b8896e43509c656a91f644b662d9fd3b6c48f29" translate="yes" xml:space="preserve">
          <source>For graphical terminals, note that on multi-monitor setups this refers to the pixel height for all physical monitors associated with &lt;var&gt;display&lt;/var&gt;. See &lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;Multiple Terminals&lt;/a&gt;.</source>
          <target state="translated">그래픽 터미널의 경우 다중 모니터 설정에서 이는 &lt;var&gt;display&lt;/var&gt; 와 관련된 모든 물리적 모니터의 픽셀 높이를 나타냅니다 . &lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;다중 터미널을&lt;/a&gt; 참고하십시오 .</target>
        </trans-unit>
        <trans-unit id="d5ab03b3e614eac3a7bbaa567f279a4f1f9d057d" translate="yes" xml:space="preserve">
          <source>For graphical terminals, note that on multi-monitor setups this refers to the pixel width for all physical monitors associated with &lt;var&gt;display&lt;/var&gt;. See &lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;Multiple Terminals&lt;/a&gt;.</source>
          <target state="translated">그래픽 터미널의 경우 다중 모니터 설정에서 이는 &lt;var&gt;display&lt;/var&gt; 와 관련된 모든 물리적 모니터의 픽셀 너비를 나타냅니다 . &lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;다중 터미널을&lt;/a&gt; 참고하십시오 .</target>
        </trans-unit>
        <trans-unit id="9af87cec8b479351a811ac8aa5c236492c607087" translate="yes" xml:space="preserve">
          <source>For graphical terminals, note that on multi-monitor setups this refers to the width for all physical monitors associated with &lt;var&gt;display&lt;/var&gt;. See &lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;Multiple Terminals&lt;/a&gt;.</source>
          <target state="translated">그래픽 터미널의 경우 다중 모니터 설정에서 이는 &lt;var&gt;display&lt;/var&gt; 와 관련된 모든 물리적 모니터의 너비를 나타냅니다 . &lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;다중 터미널을&lt;/a&gt; 참고하십시오 .</target>
        </trans-unit>
        <trans-unit id="632f51d2e3c1de25d6cd1469e9b63dd75f33b29f" translate="yes" xml:space="preserve">
          <source>For higher-level input facilities, see &lt;a href=&quot;minibuffers#Minibuffers&quot;&gt;Minibuffers&lt;/a&gt;.</source>
          <target state="translated">더 높은 수준의 입력 기능에 대해서는 &lt;a href=&quot;minibuffers#Minibuffers&quot;&gt;미니 버퍼를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9da377bf3a4e5ee235e3f1dc396f7d2833196cf1" translate="yes" xml:space="preserve">
          <source>For historical compatibility reasons, &amp;lsquo;</source>
          <target state="translated">역사적 호환성 이유로 '</target>
        </trans-unit>
        <trans-unit id="65628619bb4b16082341e795ef37116997318974" translate="yes" xml:space="preserve">
          <source>For historical reasons, Emacs does not run a separate hook whenever a window gets selected. Applications and internal routines often temporarily select a window to perform a few actions on it. They do that either to simplify coding&amp;mdash;because many functions by default operate on the selected window when no &lt;var&gt;window&lt;/var&gt; argument is specified&amp;mdash;or because some functions did not (and still do not) take a window as argument and always operate(d) on the selected window instead. Running a hook every time a window gets selected for a short time and once more when the previously selected window gets restored is not useful.</source>
          <target state="translated">역사적 이유로 Emacs는 창이 선택 될 때마다 별도의 후크를 실행하지 않습니다. 응용 프로그램과 내부 루틴은 종종 일시적으로 창을 선택하여 몇 가지 작업을 수행합니다. 코딩을 단순화하기 위해 (기본적으로 많은 함수가 &lt;var&gt;window&lt;/var&gt; 인수가 지정 되지 않은 경우 선택한 창에서 작동 하기 때문에) 또는 일부 함수가 창을 인수로 사용하지 않고 항상 작동 (d)했기 때문에 대신 선택한 창. 짧은 시간 동안 창이 선택 될 때마다 그리고 이전에 선택한 창이 복원 될 때 한 번 더 후크를 실행하는 것은 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="00ffbca2eef06914871b856c4d2841fd46e63245" translate="yes" xml:space="preserve">
          <source>For historical reasons, Emacs treats the</source>
          <target state="translated">역사적인 이유로 Emacs는</target>
        </trans-unit>
        <trans-unit id="046929ea68cbb73ffed966af9cb9c86855132a7b" translate="yes" xml:space="preserve">
          <source>For image types whose support libraries are statically linked, this function always returns &lt;code&gt;t&lt;/code&gt;. For image types whose support libraries are dynamically loaded, it returns &lt;code&gt;t&lt;/code&gt; if the library could be loaded and &lt;code&gt;nil&lt;/code&gt; otherwise.</source>
          <target state="translated">지원 라이브러리가 정적으로 연결된 이미지 유형의 경우이 함수는 항상 &lt;code&gt;t&lt;/code&gt; 를 반환합니다 . 지원 라이브러리가 동적으로로드되는 이미지 유형의 경우 라이브러리를로드 할 수 있으면 &lt;code&gt;t&lt;/code&gt; 를 반환 하고 그렇지 않으면 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d115e12f0efdfbb2d9aaf8b6529a43e7a2fbef42" translate="yes" xml:space="preserve">
          <source>For information about how &lt;code&gt;load&lt;/code&gt; is used in building Emacs, see &lt;a href=&quot;building-emacs#Building-Emacs&quot;&gt;Building Emacs&lt;/a&gt;.</source>
          <target state="translated">Emacs 빌드에서 &lt;code&gt;load&lt;/code&gt; 가 사용되는 방법에 대한 정보는 &lt;a href=&quot;building-emacs#Building-Emacs&quot;&gt;Building Emacs를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fb864d046c9d6a21427cb9289d67ab5c533404eb" translate="yes" xml:space="preserve">
          <source>For information about other concatenation functions, see the description of &lt;code&gt;mapconcat&lt;/code&gt; in &lt;a href=&quot;mapping-functions#Mapping-Functions&quot;&gt;Mapping Functions&lt;/a&gt;, &lt;code&gt;vconcat&lt;/code&gt; in &lt;a href=&quot;vector-functions#Vector-Functions&quot;&gt;Vector Functions&lt;/a&gt;, and &lt;code&gt;append&lt;/code&gt; in &lt;a href=&quot;building-lists#Building-Lists&quot;&gt;Building Lists&lt;/a&gt;. For concatenating individual command-line arguments into a string to be used as a shell command, see &lt;a href=&quot;shell-arguments#Shell-Arguments&quot;&gt;combine-and-quote-strings&lt;/a&gt;.</source>
          <target state="translated">다른 연결 기능에 대한 자세한 내용은 설명을 참조 &lt;code&gt;mapconcat&lt;/code&gt; 에서 &lt;a href=&quot;mapping-functions#Mapping-Functions&quot;&gt;매핑 기능&lt;/a&gt; , &lt;code&gt;vconcat&lt;/code&gt; 에서 &lt;a href=&quot;vector-functions#Vector-Functions&quot;&gt;벡터 함수&lt;/a&gt; , 및 &lt;code&gt;append&lt;/code&gt; 에있는 &lt;a href=&quot;building-lists#Building-Lists&quot;&gt;건물 목록을&lt;/a&gt; . 개별 명령 줄 인수를 셸 명령으로 사용할 문자열로 연결하는 방법은 &lt;a href=&quot;shell-arguments#Shell-Arguments&quot;&gt;combine-and-quote-strings를&lt;/a&gt; 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="562de7ef6e5c5372cd8038579b0b5fa9de52b85c" translate="yes" xml:space="preserve">
          <source>For instance, here&amp;rsquo;s a closure that removes itself from a hook after being run once:</source>
          <target state="translated">예를 들어 다음은 한 번 실행 된 후 후크에서 제거되는 클로저입니다.</target>
        </trans-unit>
        <trans-unit id="44d3371577866cddaf4db74fddddccf76614f5ae" translate="yes" xml:space="preserve">
          <source>For instance, if you want &amp;ldquo;same time next month&amp;rdquo;, you could say:</source>
          <target state="translated">예를 들어 &quot;다음 달에 같은 시간&quot;을 원하면 다음과 같이 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3865a9fa40f6a3d2713ffd26e08118fa4e6f6eac" translate="yes" xml:space="preserve">
          <source>For instance, if you want to make the</source>
          <target state="translated">예를 들어,</target>
        </trans-unit>
        <trans-unit id="e191e46f09a5a6a356d408b941943f636d82eff7" translate="yes" xml:space="preserve">
          <source>For instance, in old versions of Emacs the &lt;code&gt;sit-for&lt;/code&gt; function accepted three arguments, like this</source>
          <target state="translated">예를 들어, 이전 버전의 Emacs에서 &lt;code&gt;sit-for&lt;/code&gt; 함수는 다음과 같이 세 가지 인수를 허용했습니다.</target>
        </trans-unit>
        <trans-unit id="30920d93fa04181e77388625fe59f18dfff55497" translate="yes" xml:space="preserve">
          <source>For instance, suppose &lt;code&gt;load-path&lt;/code&gt; is set to</source>
          <target state="translated">예를 들어 &lt;code&gt;load-path&lt;/code&gt; 가 다음과 같이 설정되어 있다고 가정 합니다.</target>
        </trans-unit>
        <trans-unit id="128598d10cceac7cba1f49e0a7362870b28df10f" translate="yes" xml:space="preserve">
          <source>For instance, this changes the default fontset to use a font of which family name is &amp;lsquo;</source>
          <target state="translated">예를 들어, 이것은 패밀리 이름이 '인 글꼴을 사용하도록 기본 글꼴 세트를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="c0e75d5266c7e5f456b09b17569d8f50669d4c79" translate="yes" xml:space="preserve">
          <source>For instance, to display an arrow in the left fringe, using the &lt;code&gt;warning&lt;/code&gt; face, you could say something like:</source>
          <target state="translated">예를 들어, &lt;code&gt;warning&lt;/code&gt; 면을 사용하여 왼쪽 가장자리에 화살표를 표시하려면 다음과 같이 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2cec329c05b78c603818950c0fa31246f51373c3" translate="yes" xml:space="preserve">
          <source>For instance, to increase the year in a decoded time, you could say:</source>
          <target state="translated">예를 들어, 디코딩 된 시간에서 연도를 늘리려면 다음과 같이 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4eb2b60c2dd5ee8e2d11c45799591a9a142fb00" translate="yes" xml:space="preserve">
          <source>For interactive development of regular expressions, you can use the</source>
          <target state="translated">정규식의 대화식 개발을 위해 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1227c8ac2d428a960d30b6659ad99b5189b10660" translate="yes" xml:space="preserve">
          <source>For interactive use, Emacs provides two commands which always split the selected window. These call &lt;code&gt;split-window&lt;/code&gt; internally.</source>
          <target state="translated">대화식 사용을 위해 Emacs는 항상 선택된 창을 분할하는 두 개의 명령을 제공합니다. 이들은 내부적으로 &lt;code&gt;split-window&lt;/code&gt; 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="4fd869c535f12482bfdf3b13eeadecad9584228d" translate="yes" xml:space="preserve">
          <source>For its working, &lt;code&gt;replace-buffer-contents&lt;/code&gt; needs to compare the contents of the original buffer with that of &lt;var&gt;source&lt;/var&gt; which is a costly operation if the buffers are huge and there is a high number of differences between them. In order to keep &lt;code&gt;replace-buffer-contents&lt;/code&gt;&amp;rsquo;s runtime in bounds, it has two optional arguments.</source>
          <target state="translated">그 작업의 경우, &lt;code&gt;replace-buffer-contents&lt;/code&gt; 의 원래 버퍼의 내용을 비교하는 요구를 &lt;var&gt;source&lt;/var&gt; 버퍼가 거대하고 그들 사이의 차이의 높은 숫자가있는 경우 비용이 많이 드는 작업입니다. &lt;code&gt;replace-buffer-contents&lt;/code&gt; 의 런타임을 경계 로 유지하기 위해 두 개의 선택적 인수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5ea8f4d1afb6f7f3e89cf1a3d588341e3fb83bf" translate="yes" xml:space="preserve">
          <source>For key lookup, only the event type matters: two events of the same type necessarily run the same command. The command can access the full values of these events using the &amp;lsquo;</source>
          <target state="translated">키 조회의 경우 이벤트 유형 만 중요합니다. 동일한 유형의 두 이벤트는 반드시 동일한 명령을 실행합니다. 명령은 '를 사용하여 이러한 이벤트의 전체 값에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="edcd252dab164457f78c494eb745e585735056e9" translate="yes" xml:space="preserve">
          <source>For letters, the basic code itself indicates upper versus lower case; for digits and punctuation, the shift key selects an entirely different character with a different basic code. In order to keep within the</source>
          <target state="translated">문자의 경우 기본 코드 자체는 대소 문자를 나타냅니다. 숫자 및 구두점의 경우 Shift 키는 기본 코드가 다른 완전히 다른 문자를 선택합니다. 내에서 유지하기 위해</target>
        </trans-unit>
        <trans-unit id="d761f0e8822448b6dc970fbe8b9a8dc3b66c9b19" translate="yes" xml:space="preserve">
          <source>For mechanisms to add user-defined extensions to the &lt;code&gt;rx&lt;/code&gt; notation, see &lt;a href=&quot;extending-rx#Extending-Rx&quot;&gt;Extending Rx&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;rx&lt;/code&gt; 표기법 에 사용자 정의 확장을 추가하는 메커니즘 은 &lt;a href=&quot;extending-rx#Extending-Rx&quot;&gt;Extending Rx를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a396e4435f09e1fcfcd85ad1599a0c2f4e045ad7" translate="yes" xml:space="preserve">
          <source>For more coarse-grained suppression of compiler warnings, you can use the &lt;code&gt;with-no-warnings&lt;/code&gt; construct:</source>
          <target state="translated">컴파일러 경고를보다 대략적으로 억제하려면 &lt;code&gt;with-no-warnings&lt;/code&gt; 구문을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="51d6ec0ae56211f45b2f4f741eaeaa54ee2c5ff1" translate="yes" xml:space="preserve">
          <source>For more control over the expansion, the &lt;code&gt;gv-define-expander&lt;/code&gt; macro can be used. For instance, a settable &lt;code&gt;substring&lt;/code&gt; could be implemented this way:</source>
          <target state="translated">확장에 대한 더 많은 제어를 위해 &lt;code&gt;gv-define-expander&lt;/code&gt; 매크로를 사용할 수 있습니다. 예를 들어 설정 가능한 &lt;code&gt;substring&lt;/code&gt; 은 다음과 같이 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="524ad0277d25c2a67f3998052801445b5918661a" translate="yes" xml:space="preserve">
          <source>For more information about currently defined categories, run the command</source>
          <target state="translated">현재 정의 된 카테고리에 대한 자세한 정보를 보려면 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="b5c46c52685405cf067e15388e386b840ba65dc7" translate="yes" xml:space="preserve">
          <source>For more information about general sequence and array predicates, see &lt;a href=&quot;sequences-arrays-vectors#Sequences-Arrays-Vectors&quot;&gt;Sequences Arrays Vectors&lt;/a&gt;, and &lt;a href=&quot;arrays#Arrays&quot;&gt;Arrays&lt;/a&gt;.</source>
          <target state="translated">일반 시퀀스 및 배열 조건 자에 대한 자세한 내용은 &lt;a href=&quot;sequences-arrays-vectors#Sequences-Arrays-Vectors&quot;&gt;시퀀스 배열 벡터&lt;/a&gt; 및 &lt;a href=&quot;arrays#Arrays&quot;&gt;배열 항목을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="db111e5010118b2c0af6eaa6bee37a4412fe7c17" translate="yes" xml:space="preserve">
          <source>For most image types, the value of a &lt;code&gt;:data&lt;/code&gt; property should be a string containing the image data. Some image types do not support &lt;code&gt;:data&lt;/code&gt;; for some others, &lt;code&gt;:data&lt;/code&gt; alone is not enough, so you need to use other image properties along with &lt;code&gt;:data&lt;/code&gt;. See the following subsections for details.</source>
          <target state="translated">대부분의 이미지 유형에서 &lt;code&gt;:data&lt;/code&gt; 속성 의 값은 이미지 데이터를 포함하는 문자열이어야합니다. 일부 이미지 유형은 다음을 지원하지 않습니다 &lt;code&gt;:data&lt;/code&gt; ; 다른 일부의 경우 &lt;code&gt;:data&lt;/code&gt; 만으로는 충분하지 않으므로 &lt;code&gt;:data&lt;/code&gt; 와 함께 다른 이미지 속성을 사용해야 합니다 . 자세한 내용은 다음 하위 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1ef84bfa8f9cff2af4cd7df121bd6682024ceda1" translate="yes" xml:space="preserve">
          <source>For most purposes, you can think of the current binding as the innermost local binding, or the global binding if there is no local binding. To be more precise, a rule called the &lt;em&gt;scoping rule&lt;/em&gt; determines where in a program a local binding takes effect. The default scoping rule in Emacs Lisp is called &lt;em&gt;dynamic scoping&lt;/em&gt;, which simply states that the current binding at any given point in the execution of a program is the most recently-created binding for that variable that still exists. For details about dynamic scoping, and an alternative scoping rule called &lt;em&gt;lexical scoping&lt;/em&gt;, See &lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;Variable Scoping&lt;/a&gt;.</source>
          <target state="translated">대부분의 경우 현재 바인딩을 가장 안쪽의 로컬 바인딩으로 생각하거나 로컬 바인딩이없는 경우 전역 바인딩으로 생각할 수 있습니다. 더 정확히 말하면 &lt;em&gt;범위 지정&lt;/em&gt; 규칙이라는 &lt;em&gt;규칙&lt;/em&gt; 이 프로그램에서 로컬 바인딩이 적용되는 위치를 결정합니다. Emacs Lisp의 기본 범위 지정 규칙은 &lt;em&gt;동적 범위 지정&lt;/em&gt; 이라고 하며, 프로그램 실행의 특정 지점에서 현재 바인딩이 여전히 존재하는 해당 변수에 대해 가장 최근에 생성 된 바인딩임을 나타냅니다. 동적 범위 지정 및 &lt;em&gt;어휘 범위 지정&lt;/em&gt; 이라는 대체 범위 지정 규칙에 대한 자세한 내용은 &lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;변수 범위 &lt;/a&gt;&lt;em&gt;지정&lt;/em&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="89f804faf672e4d150387c9abaf8964a26ecd02a" translate="yes" xml:space="preserve">
          <source>For on-demand loading of external libraries which are known in advance to be required by certain Emacs primitives, see &lt;a href=&quot;dynamic-libraries#Dynamic-Libraries&quot;&gt;Dynamic Libraries&lt;/a&gt;.</source>
          <target state="translated">특정 Emacs 프리미티브에 필요한 것으로 미리 알려진 외부 라이브러리의 온 디맨드로드에 대해서는 &lt;a href=&quot;dynamic-libraries#Dynamic-Libraries&quot;&gt;Dynamic Libraries를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b86b2bc573dc8ed225848ddb470b4ae1aa78a403" translate="yes" xml:space="preserve">
          <source>For other concatenation functions, see &lt;code&gt;mapconcat&lt;/code&gt; in &lt;a href=&quot;mapping-functions#Mapping-Functions&quot;&gt;Mapping Functions&lt;/a&gt;, &lt;code&gt;concat&lt;/code&gt; in &lt;a href=&quot;creating-strings#Creating-Strings&quot;&gt;Creating Strings&lt;/a&gt;, and &lt;code&gt;append&lt;/code&gt; in &lt;a href=&quot;building-lists#Building-Lists&quot;&gt;Building Lists&lt;/a&gt;.</source>
          <target state="translated">다른 연결 기능을 참조 &lt;code&gt;mapconcat&lt;/code&gt; 에서 &lt;a href=&quot;mapping-functions#Mapping-Functions&quot;&gt;매핑 기능&lt;/a&gt; , &lt;code&gt;concat&lt;/code&gt; 에서 &lt;a href=&quot;creating-strings#Creating-Strings&quot;&gt;문자열을 생성&lt;/a&gt; 하고, &lt;code&gt;append&lt;/code&gt; 에있는 &lt;a href=&quot;building-lists#Building-Lists&quot;&gt;건물 목록을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a6cbbd948804398001fb9ec5cd695738cd21d0f5" translate="yes" xml:space="preserve">
          <source>For performance reasons, stack-allocated strings are limited to</source>
          <target state="translated">성능상의 이유로 스택 할당 문자열은 다음으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="a60122d601392756258517760482e4ba7a25429e" translate="yes" xml:space="preserve">
          <source>For performance, the operating system may cache or alias changes made by these functions instead of writing them immediately to secondary storage. See &lt;a href=&quot;files-and-storage#Files-and-Storage&quot;&gt;Files and Storage&lt;/a&gt;.</source>
          <target state="translated">성능을 위해 운영 체제는 보조 스토리지에 즉시 기록하는 대신 이러한 기능에 의해 변경된 내용을 캐시하거나 별칭을 지정할 수 있습니다. &lt;a href=&quot;files-and-storage#Files-and-Storage&quot;&gt;파일 및 저장소를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="faf441b6a95cda64d0224c1f65fb2e965874dda2" translate="yes" xml:space="preserve">
          <source>For performance, the operating system may not write the backup file&amp;rsquo;s contents to secondary storage immediately, or may alias the backup data with the original until one or the other is later modified. See &lt;a href=&quot;files-and-storage#Files-and-Storage&quot;&gt;Files and Storage&lt;/a&gt;.</source>
          <target state="translated">성능을 위해 운영 체제는 백업 파일의 내용을 보조 스토리지에 즉시 쓰지 않거나 나중에 하나 또는 다른 항목이 수정 될 때까지 백업 데이터를 원본으로 별칭을 지정할 수 있습니다. &lt;a href=&quot;files-and-storage#Files-and-Storage&quot;&gt;파일 및 저장소를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="da6be8c7db7588c481d6d3eeb3044b3834dbeafd" translate="yes" xml:space="preserve">
          <source>For programming languages, an important feature of a major mode is to provide automatic indentation. There are two parts: one is to decide what is the right indentation of a line, and the other is to decide when to reindent a line. By default, Emacs reindents a line whenever you type a character in &lt;code&gt;electric-indent-chars&lt;/code&gt;, which by default only includes Newline. Major modes can add chars to &lt;code&gt;electric-indent-chars&lt;/code&gt; according to the syntax of the language.</source>
          <target state="translated">프로그래밍 언어의 경우 주 모드의 중요한 기능은 자동 들여 쓰기를 제공하는 것입니다. 두 부분이 있습니다. 하나는 줄의 올바른 들여 쓰기를 결정하는 것이고 다른 하나는 줄을 다시 들여 쓰기 할시기를 결정하는 것입니다. 기본적으로 Emacs는 &lt;code&gt;electric-indent-chars&lt;/code&gt; 에 문자 를 입력 할 때마다 줄을 다시 들여 씁니다 . 기본적으로 Newline 만 포함합니다. 주요 모드는 언어 구문에 따라 &lt;code&gt;electric-indent-chars&lt;/code&gt; 에 문자를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ddab071833859a06b07541c99492d90ddd4fc900" translate="yes" xml:space="preserve">
          <source>For purposes of evaluation, the array is a constant&amp;mdash;i.e., it evaluates to itself.</source>
          <target state="translated">평가를 위해 배열은 상수입니다. 즉, 자체적으로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="8d5a0c7b7da7f4d2d585a62d2acde8ed3120c9fb" translate="yes" xml:space="preserve">
          <source>For relative time values, Emacs considers a month to be exactly thirty days, and a year to be exactly 365.25 days.</source>
          <target state="translated">상대 시간 값의 경우 Emacs는 한 달을 정확히 30 일로, 1 년을 정확히 365.25 일로 간주합니다.</target>
        </trans-unit>
        <trans-unit id="90054c0c3e1da561a0a9026341ea698f8915bbc4" translate="yes" xml:space="preserve">
          <source>For replacing display specifications, &lt;em&gt;the text that has the property&lt;/em&gt; means all the consecutive characters that have the same Lisp object as their &lt;code&gt;display&lt;/code&gt; property; these characters are replaced as a single unit. If two characters have different Lisp objects as their &lt;code&gt;display&lt;/code&gt; properties (i.e., objects which are not &lt;code&gt;eq&lt;/code&gt;), they are handled separately.</source>
          <target state="translated">디스플레이 사양을 바꾸는 &lt;em&gt;경우 속성이있는 텍스트는 &lt;/em&gt; &lt;code&gt;display&lt;/code&gt; 속성 과 동일한 Lisp 개체를 가진 모든 연속 문자를 의미합니다 . 이러한 문자는 단일 단위로 대체됩니다. 두 캐릭터가 &lt;code&gt;display&lt;/code&gt; 속성 으로 Lisp 객체가 다른 경우 (즉, &lt;code&gt;eq&lt;/code&gt; 가 아닌 객체 ), 이들은 별도로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="e2f9af1a35a2660fd8409da9cb1f927de77abafd" translate="yes" xml:space="preserve">
          <source>For representing control characters to be found in files or strings, we recommend the &amp;lsquo;</source>
          <target state="translated">파일이나 문자열에서 찾을 수있는 제어 문자를 나타내려면 '</target>
        </trans-unit>
        <trans-unit id="8fe2d9b8dc77be3c74c45be6d83fd5245b7aadc8" translate="yes" xml:space="preserve">
          <source>For some languages, upper and lower case letters are not in one-to-one correspondence. There may be two different lower case letters with the same upper case equivalent. In these cases, you need to specify the maps for both lower case and upper case.</source>
          <target state="translated">일부 언어의 경우 대문자와 소문자가 일대일 대응이 아닙니다. 동일한 대문자를 가진 두 개의 다른 소문자가있을 수 있습니다. 이 경우 소문자와 대문자 모두에 대한 맵을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="c71d3f2b7e58f202f82ff156034a0110342e4f42" translate="yes" xml:space="preserve">
          <source>For some purposes, it does not matter whether a list is proper, circular or dotted. If a program doesn&amp;rsquo;t look far enough down the list to see the &lt;small&gt;CDR&lt;/small&gt; of the final cons cell, it won&amp;rsquo;t care. However, some functions that operate on lists demand proper lists and signal errors if given a dotted list. Most functions that try to find the end of a list enter infinite loops if given a circular list.</source>
          <target state="translated">어떤 목적에서는 목록이 적절한 지, 원형인지, 점선인지는 중요하지 않습니다. 프로그램이 최종 단점 셀 의 &lt;small&gt;CDR&lt;/small&gt; 을 볼 수있을만큼 목록을 충분히 아래로 보지 않으면 상관하지 않습니다. 그러나 목록에서 작동하는 일부 함수는 점선 목록이 주어지면 적절한 목록과 신호 오류를 요구합니다. 목록의 끝을 찾으려고하는 대부분의 함수는 순환 목록이 주어지면 무한 루프에 들어갑니다.</target>
        </trans-unit>
        <trans-unit id="d500549849bc15bef76128691a5baf2432335f7d" translate="yes" xml:space="preserve">
          <source>For some purposes, the nondirectory part is further subdivided into the name proper and the &lt;em&gt;version number&lt;/em&gt;. On most systems, only backup files have version numbers in their names.</source>
          <target state="translated">일부 목적을 위해 비 디렉토리 부분은 적절한 이름과 &lt;em&gt;버전 번호&lt;/em&gt; 로 더 세분화됩니다 . 대부분의 시스템에서 백업 파일 만 이름에 버전 번호가 있습니다.</target>
        </trans-unit>
        <trans-unit id="112d87a662d1681332b9049c4a51e3d53eb7aa11" translate="yes" xml:space="preserve">
          <source>For stretches of text that should temporarily stand out. For example, it is commonly assigned to the &lt;code&gt;mouse-face&lt;/code&gt; property for cursor highlighting (see &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Special Properties&lt;/a&gt;).</source>
          <target state="translated">일시적으로 눈에 띄는 텍스트에 적합합니다. 예를 들어 일반적으로 커서 강조 표시를 위해 &lt;code&gt;mouse-face&lt;/code&gt; 속성에 할당됩니다 ( &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;특수 속성&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="42c65b3d7d99521ed4092ae00fce87c47ab3b0ba" translate="yes" xml:space="preserve">
          <source>For symbols in special obarrays, which are not used for ordinary purposes, it may make sense to use the property list cell in a nonstandard fashion; in fact, the abbrev mechanism does so (see &lt;a href=&quot;abbrevs#Abbrevs&quot;&gt;Abbrevs&lt;/a&gt;).</source>
          <target state="translated">일반적인 목적으로 사용되지 않는 특수 오바 레이의 심볼의 경우 비표준 방식으로 속성 목록 셀을 사용하는 것이 합리적 일 수 있습니다. 사실, abbrev 메커니즘은 그렇게합니다 ( &lt;a href=&quot;abbrevs#Abbrevs&quot;&gt;Abbrevs&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="a852800d4f26ade1bdda0b79a03c7fc24d024ed5" translate="yes" xml:space="preserve">
          <source>For syntactic analysis, such as in indentation, often the useful thing is to compute the syntactic state corresponding to a given buffer position. This function does that conveniently.</source>
          <target state="translated">들여 쓰기와 같은 구문 분석의 경우 종종 유용한 것은 주어진 버퍼 위치에 해당하는 구문 상태를 계산하는 것입니다. 이 기능은 편리하게 수행합니다.</target>
        </trans-unit>
        <trans-unit id="0ca28c3cc32b5a56a828f789e939bb88d8e4bc04" translate="yes" xml:space="preserve">
          <source>For technical reasons, a unibyte and a multibyte string are &lt;code&gt;equal&lt;/code&gt; if and only if they contain the same sequence of character codes and all these codes are either in the range 0 through 127 (</source>
          <target state="translated">기술적 인 이유로 유니 바이트 및 멀티 바이트 문자열은 &lt;code&gt;equal&lt;/code&gt; 문자 코드 시퀀스를 포함하고 이러한 모든 코드가 0에서 127 사이의 범위에있는 경우에만 동일 합니다 (</target>
        </trans-unit>
        <trans-unit id="45642cd47dfa6bf8d29ea83a9bea3bad88b8f0bd" translate="yes" xml:space="preserve">
          <source>For text concerning errors, warnings, or successes. For example, these are used for messages in</source>
          <target state="translated">오류, 경고 또는 성공과 관련된 텍스트입니다. 예를 들어, 이들은 메시지에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6e07008dae896457b72d081a4580cd31c5207a4e" translate="yes" xml:space="preserve">
          <source>For text matching (respectively) permanent search matches, interactive search matches, and lazy highlighting other matches than the current interactive one.</source>
          <target state="translated">텍스트 일치 (각각) 영구 검색 일치, 대화 형 검색 일치 및 현재 대화 형 일치와 다른 일치하는 지연 강조 표시의 경우.</target>
        </trans-unit>
        <trans-unit id="199754d5171ec2cef7de10ed893154f11d501bd8" translate="yes" xml:space="preserve">
          <source>For that reason, it is better to avoid binding commands to key sequences where the end of the key sequence is a prefix of a key translation. The main such problematic suffixes/prefixes are</source>
          <target state="translated">따라서 키 시퀀스의 끝이 키 변환의 접두사 인 키 시퀀스에 명령을 바인딩하지 않는 것이 좋습니다. 이러한 문제가있는 주요 접미사 / 접두사는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f10e2ee38beb0efc1d5476196bbcfc128749e76f" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;(eval &lt;var&gt;form&lt;/var&gt;)&lt;/code&gt; forms used in a bindat specification, the &lt;var&gt;form&lt;/var&gt; can access and update these dynamically bound variables during evaluation:</source>
          <target state="translated">를 들어 &lt;code&gt;(eval &lt;var&gt;form&lt;/var&gt;)&lt;/code&gt; bindat 사양에 사용되는 양식의 &lt;var&gt;form&lt;/var&gt; 액세스 및 평가시 이러한 동적 바인딩 변수를 업데이트 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="ea753a8ffd58775e7c0c7c0606c76821fe2cfcae" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;pop&lt;/code&gt; macro, which removes the first element from a list, See &lt;a href=&quot;list-elements#List-Elements&quot;&gt;List Elements&lt;/a&gt;.</source>
          <target state="translated">목록에서 첫 번째 요소를 제거 하는 &lt;code&gt;pop&lt;/code&gt; 매크로의 경우 &lt;a href=&quot;list-elements#List-Elements&quot;&gt;목록 요소를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ef8376493cc4d066a996040b4337c10b4a0cd3a5" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;push&lt;/code&gt; macro, which adds an element to a list, See &lt;a href=&quot;list-variables#List-Variables&quot;&gt;List Variables&lt;/a&gt;.</source>
          <target state="translated">위해 &lt;code&gt;push&lt;/code&gt; 목록을 볼 수있는 요소를 추가 매크로 &lt;a href=&quot;list-variables#List-Variables&quot;&gt;변수 목록&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0f3fe319bd30de7f1551c3b872e3e4bba5b856b1" translate="yes" xml:space="preserve">
          <source>For the better understanding of what stable sort is, consider the following vector example. After sorting, all items whose &lt;code&gt;car&lt;/code&gt; is 8 are grouped at the beginning of &lt;code&gt;vector&lt;/code&gt;, but their relative order is preserved. All items whose &lt;code&gt;car&lt;/code&gt; is 9 are grouped at the end of &lt;code&gt;vector&lt;/code&gt;, but their relative order is also preserved:</source>
          <target state="translated">안정적인 정렬이 무엇인지 더 잘 이해하려면 다음 벡터 예제를 고려하십시오. 정렬 후 &lt;code&gt;car&lt;/code&gt; 가 8 인 모든 항목 은 &lt;code&gt;vector&lt;/code&gt; 의 시작 부분에 그룹화 되지만 상대적 순서는 유지됩니다. &lt;code&gt;car&lt;/code&gt; 가 9 인 모든 항목 은 &lt;code&gt;vector&lt;/code&gt; 의 끝에서 그룹화 되지만 상대적 순서도 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="87d8274e9315f6d205c44c909122fe4b2bcd2515" translate="yes" xml:space="preserve">
          <source>For the common case of all backups going into one directory, the alist should contain a single element pairing &amp;lsquo;</source>
          <target state="translated">모든 백업이 하나의 디렉토리로 이동하는 일반적인 경우에는 목록에 단일 요소 쌍 '</target>
        </trans-unit>
        <trans-unit id="397056acd2602b1eb8236b9ebdd8ab76eec096da" translate="yes" xml:space="preserve">
          <source>For the customization option &lt;var&gt;symbol&lt;/var&gt;, add &lt;var&gt;value&lt;/var&gt; to the list of reasonable values.</source>
          <target state="translated">사용자 정의 옵션 &lt;var&gt;symbol&lt;/var&gt; 의 경우 적절한 값 목록에 &lt;var&gt;value&lt;/var&gt; 을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="4a38dedbdf3df9cf3e1410eb6cee8a459e8d9366" translate="yes" xml:space="preserve">
          <source>For the following functions, X and Y coordinates are reported in integer character units, i.e., numbers of lines and columns respectively. On a graphical display, each &amp;ldquo;line&amp;rdquo; and &amp;ldquo;column&amp;rdquo; corresponds to the height and width of the default character specified by the frame&amp;rsquo;s default font (see &lt;a href=&quot;frame-font#Frame-Font&quot;&gt;Frame Font&lt;/a&gt;).</source>
          <target state="translated">다음 기능의 경우 X 및 Y 좌표는 정수 문자 단위, 즉 각각 행과 열의 수로보고됩니다. 그래픽 디스플레이에서 각 &quot;행&quot;과 &quot;열&quot;은 프레임의 기본 글꼴에 지정된 기본 문자의 높이와 너비에 해당합니다 ( &lt;a href=&quot;frame-font#Frame-Font&quot;&gt;프레임 글꼴&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="25a6d2221bff01069101fec57cebeb42f17550b9" translate="yes" xml:space="preserve">
          <source>For the full list of the possible states, see the manual page of the &lt;code&gt;ps&lt;/code&gt; command.</source>
          <target state="translated">가능한 상태의 전체 목록은 &lt;code&gt;ps&lt;/code&gt; 명령 의 매뉴얼 페이지를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e75de6ea26daa8fe7f4c02ce82f35f330195a3b1" translate="yes" xml:space="preserve">
          <source>For the most part, &amp;lsquo;</source>
          <target state="translated">대부분의 경우 '</target>
        </trans-unit>
        <trans-unit id="8f083f87437f8af6d0e911df4fe787b5367ecfff" translate="yes" xml:space="preserve">
          <source>For the next three functions, the optional argument &lt;var&gt;table&lt;/var&gt; defaults to the current buffer&amp;rsquo;s category table.</source>
          <target state="translated">다음 세 함수의 경우 선택적 인수 &lt;var&gt;table&lt;/var&gt; 기본값은 현재 버퍼의 범주 테이블입니다.</target>
        </trans-unit>
        <trans-unit id="0de287c6c6b45bac437b1271e755cca625f2d489" translate="yes" xml:space="preserve">
          <source>For the remaining character sets, those that you don&amp;rsquo;t specify explicitly, Emacs chooses a font based on &lt;var&gt;fontpattern&lt;/var&gt;: it replaces &amp;lsquo;</source>
          <target state="translated">나머지 문자 세트, 명시 적으로 지정하지 않은 문자 세트의 경우 Emacs는 &lt;var&gt;fontpattern&lt;/var&gt; 을 기반으로 글꼴을 선택 합니다.</target>
        </trans-unit>
        <trans-unit id="a906a8f725709d4b0de4a96ab4461367a34e3920" translate="yes" xml:space="preserve">
          <source>For the size parameters, the value must be an integer. The position parameter names &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;top&lt;/code&gt; are not totally accurate, because some values indicate the position of the right or bottom edges instead. The &lt;var&gt;value&lt;/var&gt; possibilities for the position parameters are: an integer, a list &lt;code&gt;(+ &lt;var&gt;pos&lt;/var&gt;)&lt;/code&gt;, or a list &lt;code&gt;(- &lt;var&gt;pos&lt;/var&gt;)&lt;/code&gt;; as previously described (see &lt;a href=&quot;position-parameters#Position-Parameters&quot;&gt;Position Parameters&lt;/a&gt;).</source>
          <target state="translated">크기 매개 변수의 경우 값은 정수 여야합니다. 일부 값이 대신 오른쪽 또는 아래쪽 가장자리의 위치를 ​​나타 내기 때문에 &lt;code&gt;left&lt;/code&gt; 및 &lt;code&gt;top&lt;/code&gt; 위치 매개 변수 이름 은 완전히 정확하지 않습니다. 위치 매개 변수 의 가능한 &lt;var&gt;value&lt;/var&gt; 은 정수, 목록 &lt;code&gt;(+ &lt;var&gt;pos&lt;/var&gt;)&lt;/code&gt; 또는 목록 &lt;code&gt;(- &lt;var&gt;pos&lt;/var&gt;)&lt;/code&gt; . 이전에 설명한대로 ( &lt;a href=&quot;position-parameters#Position-Parameters&quot;&gt;위치 매개 변수&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="bd63f6190989b582ea9c376026bf123ee7491af3" translate="yes" xml:space="preserve">
          <source>For the vector, it is even simpler because you don&amp;rsquo;t need setq:</source>
          <target state="translated">벡터의 경우 setq가 필요하지 않기 때문에 더 간단합니다.</target>
        </trans-unit>
        <trans-unit id="2ffffe0d3dd28ebd8002e469cb5d2dfd42923c8e" translate="yes" xml:space="preserve">
          <source>For these reasons, advice should be reserved for the cases where you cannot modify a function&amp;rsquo;s behavior in any other way. If it is possible to do the same thing via a hook, that is preferable (see &lt;a href=&quot;hooks#Hooks&quot;&gt;Hooks&lt;/a&gt;). If you simply want to change what a particular key does, it may be better to write a new command, and remap the old command&amp;rsquo;s key bindings to the new one (see &lt;a href=&quot;remapping-commands#Remapping-Commands&quot;&gt;Remapping Commands&lt;/a&gt;).</source>
          <target state="translated">이러한 이유로 다른 방식으로 함수의 동작을 수정할 수없는 경우에 대한 조언을 예약해야합니다. 후크를 통해 동일한 작업을 수행 할 수 있다면 바람직합니다 ( &lt;a href=&quot;hooks#Hooks&quot;&gt;후크&lt;/a&gt; 참조 ). 특정 키의 기능을 변경하려는 경우 새 명령을 작성하고 이전 명령의 키 바인딩을 새 명령에 다시 매핑하는 것이 좋습니다 ( &lt;a href=&quot;remapping-commands#Remapping-Commands&quot;&gt;명령 다시 매핑&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="9b52907f69d9a50e4ec7ab8929f4201bc2b2e2e4" translate="yes" xml:space="preserve">
          <source>For this function to work, point must be somewhere between &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt;.</source>
          <target state="translated">이 기능이 작동하려면 점이 &lt;var&gt;start&lt;/var&gt; 과 &lt;var&gt;end&lt;/var&gt; 사이에 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="b964418f003633de4c03a4cd9b1087f166bf72e2" translate="yes" xml:space="preserve">
          <source>For this reason, this function is seldom useful if you need to determine more than just the fact that a file is or isn&amp;rsquo;t a symbolic link. If you actually need the file name of the link target, use &lt;code&gt;file-chase-links&lt;/code&gt; or &lt;code&gt;file-truename&lt;/code&gt;, described in &lt;a href=&quot;truenames#Truenames&quot;&gt;Truenames&lt;/a&gt;.</source>
          <target state="translated">이러한 이유로이 함수는 파일이 심볼릭 링크인지 아닌지 여부를 확인하는 것 이상을 확인해야하는 경우 거의 유용하지 않습니다. 실제로 링크 대상의 파일 이름이 필요한 경우 &lt;code&gt;file-truename&lt;/code&gt; 에 설명 된 &lt;code&gt;file-chase-links&lt;/code&gt; 또는 file-truename 을 사용 &lt;a href=&quot;truenames#Truenames&quot;&gt;하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="19381c88cff85e8267de9ed9e5513028e6adebad" translate="yes" xml:space="preserve">
          <source>For yanking, one entry in the kill ring is designated the front of the ring. Some yank commands rotate the ring by designating a different element as the front. But this virtual rotation doesn&amp;rsquo;t change the list itself&amp;mdash;the most recent entry always comes first in the list.</source>
          <target state="translated">잡아 당기기의 경우 킬 링의 한 항목이 링의 전면으로 지정됩니다. 일부 yank 명령은 다른 요소를 앞쪽으로 지정하여 링을 회전시킵니다. 그러나이 가상 회전은 목록 자체를 변경하지 않습니다. 가장 최근 항목이 항상 목록의 첫 번째 항목이됩니다.</target>
        </trans-unit>
        <trans-unit id="fa1a0f8f3b130a55ce024bebdfbd50a7e2e42d15" translate="yes" xml:space="preserve">
          <source>Force &lt;var&gt;thunk&lt;/var&gt; to perform the evaluation of the forms specified in the &lt;code&gt;thunk-delay&lt;/code&gt; that created the thunk. The result of the evaluation of the last form is returned. The &lt;var&gt;thunk&lt;/var&gt; also &amp;ldquo;remembers&amp;rdquo; that it has been forced: Any further calls of &lt;code&gt;thunk-force&lt;/code&gt; with the same &lt;var&gt;thunk&lt;/var&gt; will just return the same result without evaluating the forms again.</source>
          <target state="translated">&lt;var&gt;thunk&lt;/var&gt; 를 생성 한 썽크 &lt;code&gt;thunk-delay&lt;/code&gt; 지정된 양식의 평가를 수행하도록 썽크 를 강제 실행합니다 . 마지막 양식의 평가 결과가 반환됩니다. &lt;var&gt;thunk&lt;/var&gt; 의 더 이상의 전화 : 또한 강제 된 것을 &quot;기억&quot; &lt;code&gt;thunk-force&lt;/code&gt; 같은과 &lt;var&gt;thunk&lt;/var&gt; 바로 다시 형태를 평가하지 않고 동일한 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d8311d282a06bf7c13df916c21ae0692e8509152" translate="yes" xml:space="preserve">
          <source>Forcing Redisplay</source>
          <target state="translated">강제 재표시</target>
        </trans-unit>
        <trans-unit id="50fe9b523b09e3d4f5eb9578dd9aa2cded42eb5b" translate="yes" xml:space="preserve">
          <source>Forcing redisplay.</source>
          <target state="translated">강제 재표시.</target>
        </trans-unit>
        <trans-unit id="54e5928d6cbe4200cfedd66bfae0116254371dd3" translate="yes" xml:space="preserve">
          <source>Foreground color, a string. The value can be a system-defined color name, or a hexadecimal color specification. See &lt;a href=&quot;color-names#Color-Names&quot;&gt;Color Names&lt;/a&gt;. On black-and-white displays, certain shades of gray are implemented by stipple patterns.</source>
          <target state="translated">전경색, 문자열. 값은 시스템 정의 색상 이름이거나 16 진수 색상 사양 일 수 있습니다. &lt;a href=&quot;color-names#Color-Names&quot;&gt;색상 이름을&lt;/a&gt; 참조하십시오 . 흑백 디스플레이에서 특정 회색 음영은 점각 패턴으로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="d9151cf0df95ff2f005ffb2dbfff11e476773720" translate="yes" xml:space="preserve">
          <source>Format of Descriptions</source>
          <target state="translated">설명 형식</target>
        </trans-unit>
        <trans-unit id="690ff78b94f5f2ab90ba941868039323171c46a4" translate="yes" xml:space="preserve">
          <source>Format of GnuTLS Cryptography Inputs</source>
          <target state="translated">GnuTLS 암호화 입력 형식</target>
        </trans-unit>
        <trans-unit id="3b30bd7322a19ebf11a0420fbb9d0d2e2a952c4c" translate="yes" xml:space="preserve">
          <source>Format of Keymaps</source>
          <target state="translated">키맵 형식</target>
        </trans-unit>
        <trans-unit id="ffba191c046f0f3d86eca0356dcfa6c942799127" translate="yes" xml:space="preserve">
          <source>Formatted Text Properties</source>
          <target state="translated">서식있는 텍스트 속성</target>
        </trans-unit>
        <trans-unit id="46ced2475097f609a37fcad0f6e2c12ef6e35700" translate="yes" xml:space="preserve">
          <source>Formatting Strings</source>
          <target state="translated">문자열 서식 지정</target>
        </trans-unit>
        <trans-unit id="08ddf2db0601ff64b5999d791aceb04902f2ab24" translate="yes" xml:space="preserve">
          <source>Formatting custom &lt;code&gt;format&lt;/code&gt; specifications.</source>
          <target state="translated">사용자 지정 &lt;code&gt;format&lt;/code&gt; 사양을 포맷 합니다.</target>
        </trans-unit>
        <trans-unit id="85e179fd2599024e08f48eaf746a1effe699c9af" translate="yes" xml:space="preserve">
          <source>Formatting is often useful for computing messages to be displayed. In fact, the functions &lt;code&gt;message&lt;/code&gt; and &lt;code&gt;error&lt;/code&gt; provide the same formatting feature described here; they differ from &lt;code&gt;format-message&lt;/code&gt; only in how they use the result of formatting.</source>
          <target state="translated">형식은 종종 표시 할 메시지를 계산하는 데 유용합니다. 실제로 함수 &lt;code&gt;message&lt;/code&gt; 및 &lt;code&gt;error&lt;/code&gt; 는 여기에 설명 된 것과 동일한 형식 지정 기능을 제공합니다. 형식화 결과를 사용하는 방식 만 &lt;code&gt;format-message&lt;/code&gt; 와 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="1e169267238c8a26c2ddbb83e054dfbd79640e6b" translate="yes" xml:space="preserve">
          <source>Formatting text as the mode line would.</source>
          <target state="translated">모드 라인처럼 텍스트 서식을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="3c6860ed0688d49392f43c31b5e487af200d8da8" translate="yes" xml:space="preserve">
          <source>Forms that call functions.</source>
          <target state="translated">함수를 호출하는 양식.</target>
        </trans-unit>
        <trans-unit id="a61c89f45d054dc7a27512e0b0970e65fadc39de" translate="yes" xml:space="preserve">
          <source>Forms that call macros.</source>
          <target state="translated">매크로를 호출하는 양식.</target>
        </trans-unit>
        <trans-unit id="99a2a5d26385032afad4033277b91f1c2729bb11" translate="yes" xml:space="preserve">
          <source>Forms that evaluate to themselves.</source>
          <target state="translated">스스로 평가하는 양식.</target>
        </trans-unit>
        <trans-unit id="ba4e72261283258434788542ba397135c10f39d8" translate="yes" xml:space="preserve">
          <source>Forward</source>
          <target state="translated">Forward</target>
        </trans-unit>
        <trans-unit id="03ff98c7185813598af4b44b2a4f969fae61d671" translate="yes" xml:space="preserve">
          <source>Four special values for &lt;code&gt;direction&lt;/code&gt; entries allow to implicitly specify the selected frame&amp;rsquo;s main window as the reference window: &lt;code&gt;leftmost&lt;/code&gt;, &lt;code&gt;top&lt;/code&gt;, &lt;code&gt;rightmost&lt;/code&gt; and &lt;code&gt;bottom&lt;/code&gt;. This means that instead of, for example, &lt;code&gt;(direction&amp;nbsp;.&amp;nbsp;left)&amp;nbsp;(window&amp;nbsp;.&amp;nbsp;main)&lt;/code&gt; one can just specify &lt;code&gt;(direction&amp;nbsp;.&amp;nbsp;leftmost)&lt;/code&gt;. An existing &lt;code&gt;window&lt;/code&gt;&lt;var&gt;alist&lt;/var&gt; entry is ignored in such cases.</source>
          <target state="translated">&lt;code&gt;direction&lt;/code&gt; 항목에 대한 네 가지 특수 값을 사용하면 선택한 프레임의 기본 창을 참조 창으로 암시 적으로 지정할 수 있습니다 : &lt;code&gt;leftmost&lt;/code&gt; , &lt;code&gt;top&lt;/code&gt; , &lt;code&gt;rightmost&lt;/code&gt; 및 &lt;code&gt;bottom&lt;/code&gt; . 이것은 예를 들어 &lt;code&gt;(direction&amp;nbsp;.&amp;nbsp;left)&amp;nbsp;(window&amp;nbsp;.&amp;nbsp;main)&lt;/code&gt; 대신 &lt;code&gt;(direction&amp;nbsp;.&amp;nbsp;leftmost)&lt;/code&gt; 지정할 수 있음을 의미 합니다. 기존 &lt;code&gt;window&lt;/code&gt; &lt;var&gt;alist&lt;/var&gt; 의 항목은 이러한 경우에 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="f8be388d8709a99dab45a803379f214da551553c" translate="yes" xml:space="preserve">
          <source>Four-byte vector representing an Internet address. For example: &lt;code&gt;[127 0 0 1]&lt;/code&gt; for localhost.</source>
          <target state="translated">인터넷 주소를 나타내는 4 바이트 벡터. 예 : localhost의 경우 &lt;code&gt;[127 0 0 1]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b64b0ae712554037fe6db96671213dc347089595" translate="yes" xml:space="preserve">
          <source>Fractional seconds as a number of nanoseconds. For timestamps returned by &lt;code&gt;extract_time&lt;/code&gt;, this is always nonnegative and less than one billion. (Although POSIX requires the type of &lt;code&gt;tv_nsec&lt;/code&gt; to be &lt;code&gt;long&lt;/code&gt;, the type is &lt;code&gt;long long&lt;/code&gt; on some nonstandard platforms.)</source>
          <target state="translated">나노초 단위의 분수 초입니다. &lt;code&gt;extract_time&lt;/code&gt; 에 의해 반환 된 타임 스탬프의 경우이 값은 항상 음수가 아니고 10 억 미만입니다. (POSIX는 유형이 필요하지만 &lt;code&gt;tv_nsec&lt;/code&gt; 을 할 &lt;code&gt;long&lt;/code&gt; , 유형입니다 &lt;code&gt;long long&lt;/code&gt; 일부 비표준 플랫폼에서.)</target>
        </trans-unit>
        <trans-unit id="7635f609fc39a6b2309200df6c13ba7f981e6e93" translate="yes" xml:space="preserve">
          <source>Frame Configuration Type</source>
          <target state="translated">프레임 구성 유형</target>
        </trans-unit>
        <trans-unit id="b3375a4b79b653dfb166deb920a1a8a07454332b" translate="yes" xml:space="preserve">
          <source>Frame Configurations</source>
          <target state="translated">프레임 구성</target>
        </trans-unit>
        <trans-unit id="2628654f3592f30e3e183e8fe28ea0baef770932" translate="yes" xml:space="preserve">
          <source>Frame Font</source>
          <target state="translated">프레임 글꼴</target>
        </trans-unit>
        <trans-unit id="48a4e1fb6a458c2e798e7f81d3081543b9b437d1" translate="yes" xml:space="preserve">
          <source>Frame Geometry</source>
          <target state="translated">프레임 형상</target>
        </trans-unit>
        <trans-unit id="3f455212bef49865fcc51892b83fce71911f1680" translate="yes" xml:space="preserve">
          <source>Frame Interaction Parameters</source>
          <target state="translated">프레임 상호 작용 매개 변수</target>
        </trans-unit>
        <trans-unit id="b00c42c9c273b5bc922c8b715a7c39b737a31f0e" translate="yes" xml:space="preserve">
          <source>Frame Layout</source>
          <target state="translated">프레임 레이아웃</target>
        </trans-unit>
        <trans-unit id="ee5af9328eadec13e19d54784546362006d1c6a2" translate="yes" xml:space="preserve">
          <source>Frame Layouts with Side Windows</source>
          <target state="translated">측면 창이있는 프레임 레이아웃</target>
        </trans-unit>
        <trans-unit id="2def4ca016ae808f491d5589a4d3596db373a3bd" translate="yes" xml:space="preserve">
          <source>Frame Parameters</source>
          <target state="translated">프레임 매개 변수</target>
        </trans-unit>
        <trans-unit id="3795259ac55a38a9c80dc78cb37d9173d40c7749" translate="yes" xml:space="preserve">
          <source>Frame Position</source>
          <target state="translated">프레임 위치</target>
        </trans-unit>
        <trans-unit id="8b0227b2f358f622998d1841dc8551f0359eac0d" translate="yes" xml:space="preserve">
          <source>Frame Size</source>
          <target state="translated">프레임 크기</target>
        </trans-unit>
        <trans-unit id="b7ac3c8ffea3811343eb8213490bb38d98fb19f5" translate="yes" xml:space="preserve">
          <source>Frame Titles</source>
          <target state="translated">프레임 제목</target>
        </trans-unit>
        <trans-unit id="9c5749558dd4c5bf4399310cd20ad88f7947524b" translate="yes" xml:space="preserve">
          <source>Frame Type</source>
          <target state="translated">프레임 유형</target>
        </trans-unit>
        <trans-unit id="e7c9cb1f7a76750767299beca11d5593148f6bbd" translate="yes" xml:space="preserve">
          <source>Frame parameters exist mostly for the sake of graphical displays. Most frame parameters have no effect when applied to a frame on a text terminal; only the &lt;code&gt;height&lt;/code&gt;, &lt;code&gt;width&lt;/code&gt;, &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;title&lt;/code&gt;, &lt;code&gt;menu-bar-lines&lt;/code&gt;, &lt;code&gt;buffer-list&lt;/code&gt; and &lt;code&gt;buffer-predicate&lt;/code&gt; parameters do something special. If the terminal supports colors, the parameters &lt;code&gt;foreground-color&lt;/code&gt;, &lt;code&gt;background-color&lt;/code&gt;, &lt;code&gt;background-mode&lt;/code&gt; and &lt;code&gt;display-type&lt;/code&gt; are also meaningful. If the terminal supports frame transparency, the parameter &lt;code&gt;alpha&lt;/code&gt; is also meaningful.</source>
          <target state="translated">프레임 매개 변수는 대부분 그래픽 표시를 위해 존재합니다. 대부분의 프레임 매개 변수는 텍스트 터미널의 프레임에 적용될 때 효과가 없습니다. 단지 &lt;code&gt;height&lt;/code&gt; , &lt;code&gt;width&lt;/code&gt; , &lt;code&gt;name&lt;/code&gt; , &lt;code&gt;title&lt;/code&gt; , &lt;code&gt;menu-bar-lines&lt;/code&gt; , &lt;code&gt;buffer-list&lt;/code&gt; 및 &lt;code&gt;buffer-predicate&lt;/code&gt; 매개 변수는 뭔가 특별 해. 터미널이 색상을 지원하는 경우 &lt;code&gt;foreground-color&lt;/code&gt; , &lt;code&gt;background-color&lt;/code&gt; , &lt;code&gt;background-mode&lt;/code&gt; 및 &lt;code&gt;display-type&lt;/code&gt; 매개 변수 도 의미가 있습니다. 터미널이 프레임 투명도를 지원하는 경우 매개 변수 &lt;code&gt;alpha&lt;/code&gt; 도 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0eaf8dac44f190c3faaf3c94ff99cbda42392375" translate="yes" xml:space="preserve">
          <source>Frame parameters usually specify frame sizes in character units. On graphical displays, the &lt;code&gt;default&lt;/code&gt; face determines the actual pixel sizes of these character units (see &lt;a href=&quot;face-attributes#Face-Attributes&quot;&gt;Face Attributes&lt;/a&gt;).</source>
          <target state="translated">프레임 매개 변수는 일반적으로 문자 단위로 프레임 크기를 지정합니다. 그래픽 디스플레이에서 &lt;code&gt;default&lt;/code&gt; 얼굴은 이러한 문자 단위의 실제 픽셀 크기를 결정합니다 ( &lt;a href=&quot;face-attributes#Face-Attributes&quot;&gt;얼굴 속성&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="e93788474e90074ae4a2304390f95b4eaa4aa995" translate="yes" xml:space="preserve">
          <source>Frame&amp;rsquo;s size.</source>
          <target state="translated">프레임의 크기.</target>
        </trans-unit>
        <trans-unit id="e3e7a3833d19706ebf33b2c3baf8e05deeed7bca" translate="yes" xml:space="preserve">
          <source>Frames</source>
          <target state="translated">Frames</target>
        </trans-unit>
        <trans-unit id="1016cca46904e2542be02bd1ee40819628cf410e" translate="yes" xml:space="preserve">
          <source>Frames are listed from topmost (first) to bottommost (last). As a special case, if &lt;var&gt;display&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt; and specifies a live frame, it returns the child frames of that frame in Z (stacking) order.</source>
          <target state="translated">프레임은 맨 위 (첫 번째)에서 맨 아래 (마지막)까지 나열됩니다. 특별한 경우로 &lt;var&gt;display&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니고 라이브 프레임을 지정하면 Z (스태킹) 순서로 해당 프레임의 자식 프레임을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e869c0a12c0ebdcb83032af0ab6e9b29aa99d134" translate="yes" xml:space="preserve">
          <source>Frames have no read syntax. They print in hash notation, giving the frame&amp;rsquo;s title, plus its address in core (useful to identify the frame uniquely).</source>
          <target state="translated">프레임에는 읽기 구문이 없습니다. 프레임의 제목과 코어의 주소를 제공하는 해시 표기법으로 인쇄합니다 (프레임을 고유하게 식별하는 데 유용함).</target>
        </trans-unit>
        <trans-unit id="e8c12e749eac8bfa8e0b8a6b5ce728ac241d622d" translate="yes" xml:space="preserve">
          <source>Frames last until explicitly deleted.</source>
          <target state="translated">프레임은 명시 적으로 삭제 될 때까지 지속됩니다.</target>
        </trans-unit>
        <trans-unit id="aa0f21fa248066fad343c13774776ce1ec7db69f" translate="yes" xml:space="preserve">
          <source>Frames may be visible or invisible, or icons.</source>
          <target state="translated">프레임은 보이거나 보이지 않거나 아이콘이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a7705c02c88885a265e66e6bb596b4a0e5c62bd" translate="yes" xml:space="preserve">
          <source>Fringe Bitmaps</source>
          <target state="translated">프린지 비트 맵</target>
        </trans-unit>
        <trans-unit id="1aceb2d056e100bb87ff7213c426cc3f95936843" translate="yes" xml:space="preserve">
          <source>Fringe Cursors</source>
          <target state="translated">프린지 커서</target>
        </trans-unit>
        <trans-unit id="0416d0190cff216cfabfea78b591f9bda7805597" translate="yes" xml:space="preserve">
          <source>Fringe Indicators</source>
          <target state="translated">프린지 표시기</target>
        </trans-unit>
        <trans-unit id="5fd5c0c63bf89cdc3cf251efbc18952a6efcce45" translate="yes" xml:space="preserve">
          <source>Fringe Size and Position</source>
          <target state="translated">프린지 크기 및 위치</target>
        </trans-unit>
        <trans-unit id="60d9defe1a472be58d3446f380572d057a4539e8" translate="yes" xml:space="preserve">
          <source>Fringes</source>
          <target state="translated">Fringes</target>
        </trans-unit>
        <trans-unit id="a6c57f8a9bfb2be0237a1ce84804479a5b55ef2a" translate="yes" xml:space="preserve">
          <source>Frobnicate and bifurcate flanges</source>
          <target state="translated">Frobnicate 및 분기 플랜지</target>
        </trans-unit>
        <trans-unit id="7d7a9a3b073942c9c4a39433167a05cedca55794" translate="yes" xml:space="preserve">
          <source>Frobnicate buffer:</source>
          <target state="translated">Frobnicate 버퍼 :</target>
        </trans-unit>
        <trans-unit id="ae12ce3903efdf6296129a3285e0ae497ae13b29" translate="yes" xml:space="preserve">
          <source>From the past subsections we already know that &lt;code&gt;display-buffer&lt;/code&gt; must be supplied with a number of display actions (see &lt;a href=&quot;choosing-window#Choosing-Window&quot;&gt;Choosing Window&lt;/a&gt;) in order to display a buffer. In a completely uncustomized Emacs, these actions are specified by &lt;code&gt;display-buffer-fallback-action&lt;/code&gt; in the following order of precedence: Reuse a window, pop up a new window on the same frame, use a window previously showing the buffer, use some window and pop up a new frame. (Note that the remaining actions named by &lt;code&gt;display-buffer-fallback-action&lt;/code&gt; are void in an uncustomized Emacs).</source>
          <target state="translated">지난 하위 섹션에서 우리는 이미 &lt;code&gt;display-buffer&lt;/code&gt; 를 표시하기 위해 디스플레이 버퍼에 여러 디스플레이 작업 ( &lt;a href=&quot;choosing-window#Choosing-Window&quot;&gt;창 선택&lt;/a&gt; 참조 )을 제공해야 한다는 것을 알고 있습니다 . 완전히 사용자 지정되지 않은 Emacs에서 이러한 작업은 &lt;code&gt;display-buffer-fallback-action&lt;/code&gt; 에 의해 다음 우선 순위 순서로 지정됩니다 . 창 재사용, 동일한 프레임에 새 창 팝업, 이전에 버퍼를 표시 한 창 사용, 일부 창 사용 새 프레임이 나타납니다. ( &lt;code&gt;display-buffer-fallback-action&lt;/code&gt; 으로 명명 된 나머지 작업 은 사용자 지정되지 않은 Emacs에서 무효입니다.)</target>
        </trans-unit>
        <trans-unit id="c4d63e4c56f1d2b74aaf3de1c3943ce348748d84" translate="yes" xml:space="preserve">
          <source>From:</source>
          <target state="translated">From:</target>
        </trans-unit>
        <trans-unit id="0ebe3e47a285e380363401a28eb7f3dddc4e9c33" translate="yes" xml:space="preserve">
          <source>Full-height and full-width frames are more similar to maximized frames in this regard. However, these typically display an external border which might be absent with maximized frames. Hence the heights of maximized and full-height frames and the widths of maximized and full-width frames often differ by a few pixels.</source>
          <target state="translated">전체 높이 및 전체 너비 프레임은 이와 관련하여 최대화 된 프레임과 더 유사합니다. 그러나 일반적으로 최대화 된 프레임에는 없을 수있는 외부 테두리가 표시됩니다. 따라서 최대화 및 전체 높이 프레임의 높이와 최대화 및 전체 너비 프레임의 너비는 종종 몇 픽셀 씩 다릅니다.</target>
        </trans-unit>
        <trans-unit id="0227794e334ddbac1cacd5653be8fdf6837f6bbe" translate="yes" xml:space="preserve">
          <source>Full-screen on macOS hides both the tool-bar and the menu-bar, however both will be displayed if the mouse pointer is moved to the top of the screen.</source>
          <target state="translated">macOS의 전체 화면은 도구 모음과 메뉴 모음을 모두 숨기지 만 마우스 포인터를 화면 상단으로 이동하면 둘 다 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f1e410ad1472b42cb42cc98962428637290b6706" translate="yes" xml:space="preserve">
          <source>Function</source>
          <target state="translated">Function</target>
        </trans-unit>
        <trans-unit id="a3593edc88e17616adbb4037346eb999d6ceb735" translate="yes" xml:space="preserve">
          <source>Function Keys</source>
          <target state="translated">기능 키</target>
        </trans-unit>
        <trans-unit id="760cf6a6d209c21ac6c4fd1b396c72c47be7d5a6" translate="yes" xml:space="preserve">
          <source>Function Type</source>
          <target state="translated">기능 유형</target>
        </trans-unit>
        <trans-unit id="edb917120f9cb05f9cf4013067ef2c91be5076f9" translate="yes" xml:space="preserve">
          <source>Function arguments, e.g., the &lt;var&gt;time&lt;/var&gt; argument to &lt;code&gt;current-time-string&lt;/code&gt;, accept a more-general &lt;em&gt;time value&lt;/em&gt; format, which can be a Lisp timestamp, &lt;code&gt;nil&lt;/code&gt; for the current time, a single floating-point number for seconds, or a list &lt;code&gt;(&lt;var&gt;high&lt;/var&gt; &lt;var&gt;low&lt;/var&gt; &lt;var&gt;micro&lt;/var&gt;)&lt;/code&gt; or &lt;code&gt;(&lt;var&gt;high&lt;/var&gt;
&lt;var&gt;low&lt;/var&gt;)&lt;/code&gt; that is a truncated list timestamp with missing elements taken to be zero.</source>
          <target state="translated">함수 인수는, 예를 들어, &lt;var&gt;time&lt;/var&gt; 에 인수 &lt;code&gt;current-time-string&lt;/code&gt; 좀 더-일반적인 동의를 &lt;em&gt;시간 값&lt;/em&gt; 리스프 타임 스탬프 형식이 될 수, &lt;code&gt;nil&lt;/code&gt; , 현재 시간, 초 단일 부동 소수점 숫자, 또는 목록 &lt;code&gt;(&lt;var&gt;high&lt;/var&gt; &lt;var&gt;low&lt;/var&gt; &lt;var&gt;micro&lt;/var&gt;)&lt;/code&gt; 또는 &lt;code&gt;(&lt;var&gt;high&lt;/var&gt; &lt;var&gt;low&lt;/var&gt;)&lt;/code&gt; 는 누락 된 요소가 0이되는 잘린 목록 타임 스탬프입니다.</target>
        </trans-unit>
        <trans-unit id="b933407dd477578aff5c3408d8b3e8fdaf706985" translate="yes" xml:space="preserve">
          <source>Function calls (see &lt;a href=&quot;functions#Functions&quot;&gt;Functions&lt;/a&gt;).</source>
          <target state="translated">함수 호출 ( &lt;a href=&quot;functions#Functions&quot;&gt;함수&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="1af483dbbd3691ff179fefeb552423fd10c4d63c" translate="yes" xml:space="preserve">
          <source>Function keys &amp;ndash; keys with names, not symbols.</source>
          <target state="translated">기능 키 &amp;ndash; 기호가 아닌 이름이있는 키.</target>
        </trans-unit>
        <trans-unit id="c28f90844ff41af6464401dafa16370f6a7ddc41" translate="yes" xml:space="preserve">
          <source>Function of one argument (the response to &lt;var&gt;capability-command&lt;/var&gt;), which returns either &lt;code&gt;nil&lt;/code&gt;, or the command to activate</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; 또는 활성화 할 명령을 반환하는 하나의 인수 ( &lt;var&gt;capability-command&lt;/var&gt; 에 대한 응답 )의 함수</target>
        </trans-unit>
        <trans-unit id="2599b4160212dbdafa79551462c78d2a10591f78" translate="yes" xml:space="preserve">
          <source>Function to call to quit the current buffer.</source>
          <target state="translated">현재 버퍼를 종료하기 위해 호출하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="2692d9c0a34514bfbf97445668a3984d5bef3f10" translate="yes" xml:space="preserve">
          <source>Function to call when an action is invoked. The notification &lt;var&gt;id&lt;/var&gt; and the &lt;var&gt;key&lt;/var&gt; of the action are passed as arguments to the function.</source>
          <target state="translated">작업이 호출 될 때 호출 할 함수입니다. 알림 &lt;var&gt;id&lt;/var&gt; 와 작업의 &lt;var&gt;key&lt;/var&gt; 는 함수에 인수로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="665a4b2f050f5cc458f3cc402b354ab096def6f3" translate="yes" xml:space="preserve">
          <source>Function to call when the notification has been closed by timeout or by the user. The function receive the notification &lt;var&gt;id&lt;/var&gt; and the closing &lt;var&gt;reason&lt;/var&gt; as arguments:</source>
          <target state="translated">시간 초과 또는 사용자에 의해 알림이 닫 혔을 때 호출 할 함수입니다. 함수는 알림 &lt;var&gt;id&lt;/var&gt; 와 닫는 &lt;var&gt;reason&lt;/var&gt; 를 인수로 받습니다 .</target>
        </trans-unit>
        <trans-unit id="ab32b13d036c7de39a76ff893bf8bd1e2f72feca" translate="yes" xml:space="preserve">
          <source>Function to use for declaring that a region&amp;rsquo;s fontification is out of date. It takes two arguments, the beginning and end of the region. The default value of this variable is &lt;code&gt;font-lock-after-change-function&lt;/code&gt;.</source>
          <target state="translated">지역의 글꼴이 오래되었음을 선언하는 데 사용하는 함수입니다. 영역의 시작과 끝이라는 두 개의 인수가 필요합니다. 이 변수의 기본값은 &lt;code&gt;font-lock-after-change-function&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="45c03975934a7989defa092bb01160d6a6d14561" translate="yes" xml:space="preserve">
          <source>Function to use for fontifying a region. It should take two arguments, the beginning and end of the region, and an optional third argument &lt;var&gt;verbose&lt;/var&gt;. If &lt;var&gt;verbose&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the function should print status messages. The default value is &lt;code&gt;font-lock-default-fontify-region&lt;/code&gt;.</source>
          <target state="translated">영역을 글꼴 화하는 데 사용하는 기능입니다. 두 개의 인수, 영역의 시작과 끝, 그리고 선택적인 세 번째 인수 인 &lt;var&gt;verbose&lt;/var&gt; 를 가져야합니다 . &lt;var&gt;verbose&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 함수는 상태 메시지를 인쇄해야합니다. 기본값은 &lt;code&gt;font-lock-default-fontify-region&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8989f04b34b16d9a2aa0d821237abfc63224442a" translate="yes" xml:space="preserve">
          <source>Function to use for fontifying the buffer. The default value is &lt;code&gt;font-lock-default-fontify-buffer&lt;/code&gt;.</source>
          <target state="translated">버퍼 글꼴 화에 사용하는 기능입니다. 기본값은 &lt;code&gt;font-lock-default-fontify-buffer&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f0d73e2fdb1863b97c8fd3e0f73627aa524fcd58" translate="yes" xml:space="preserve">
          <source>Function to use for making sure a region of the current buffer has been fontified. It is called with two arguments, the beginning and end of the region. The default value of this variable is a function that calls &lt;code&gt;font-lock-default-fontify-buffer&lt;/code&gt; if the buffer is not fontified; the effect is to make sure the entire accessible portion of the buffer is fontified.</source>
          <target state="translated">현재 버퍼의 영역이 글꼴 화되었는지 확인하는 데 사용할 함수입니다. 영역의 시작과 끝이라는 두 개의 인수로 호출됩니다. 이 변수의 기본값 은 버퍼가 폰트 화되지 않은 경우 &lt;code&gt;font-lock-default-fontify-buffer&lt;/code&gt; 를 호출하는 함수입니다 . 그 효과는 버퍼의 액세스 가능한 전체 부분이 글꼴 화되었는지 확인하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0ef6fffab83d22c64fb8b7e968c6d90ca33655e7" translate="yes" xml:space="preserve">
          <source>Function to use for unfontifying a region. It should take two arguments, the beginning and end of the region. The default value is &lt;code&gt;font-lock-default-unfontify-region&lt;/code&gt;.</source>
          <target state="translated">영역 글꼴을 해제하는 데 사용하는 기능입니다. 영역의 시작과 끝이라는 두 개의 인수가 필요합니다. 기본값은 &lt;code&gt;font-lock-default-unfontify-region&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="13e180d67a77c305f9559009ded2e991db88b38d" translate="yes" xml:space="preserve">
          <source>Function to use for unfontifying the buffer. This is used when turning off Font Lock mode. The default value is &lt;code&gt;font-lock-default-unfontify-buffer&lt;/code&gt;.</source>
          <target state="translated">버퍼의 글꼴을 해제하는 데 사용하는 기능입니다. 글꼴 잠금 모드를 끌 때 사용됩니다. 기본값은 &lt;code&gt;font-lock-default-unfontify-buffer&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="29ac7b1b85bc7c68994dfadb32cfe581e050f9d7" translate="yes" xml:space="preserve">
          <source>Function: &lt;em&gt;bool&lt;/em&gt;&lt;strong&gt;copy_string_contents&lt;/strong&gt;&lt;em&gt;(emacs_env *&lt;var&gt;env&lt;/var&gt;, emacs_value &lt;var&gt;arg&lt;/var&gt;, char *&lt;var&gt;buf&lt;/var&gt;, ptrdiff_t *&lt;var&gt;len&lt;/var&gt;)&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;em&gt;bool &lt;/em&gt;&lt;strong&gt;copy_string_contents &lt;/strong&gt;&lt;em&gt;(emacs_env * &lt;var&gt;env&lt;/var&gt; , emacs_value &lt;var&gt;arg&lt;/var&gt; , char * &lt;var&gt;buf&lt;/var&gt; , ptrdiff_t * &lt;var&gt;len&lt;/var&gt; )&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="43209e42da44d5222b0c0bfa936fe69a5420310a" translate="yes" xml:space="preserve">
          <source>Function: &lt;em&gt;bool&lt;/em&gt;&lt;strong&gt;eq&lt;/strong&gt;&lt;em&gt;(emacs_env *&lt;var&gt;env&lt;/var&gt;, emacs_value &lt;var&gt;val1&lt;/var&gt;, emacs_value &lt;var&gt;val2&lt;/var&gt;)&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;em&gt;bool &lt;/em&gt;&lt;strong&gt;eq &lt;/strong&gt;&lt;em&gt;(emacs_env * &lt;var&gt;env&lt;/var&gt; , emacs_value &lt;var&gt;val1&lt;/var&gt; , emacs_value &lt;var&gt;val2&lt;/var&gt; )&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0a083631728d88f085771468c6029fc24c1f37a8" translate="yes" xml:space="preserve">
          <source>Function: &lt;em&gt;bool&lt;/em&gt;&lt;strong&gt;extract_big_integer&lt;/strong&gt;&lt;em&gt;(emacs_env *&lt;var&gt;env&lt;/var&gt;, emacs_value &lt;var&gt;arg&lt;/var&gt;, int *&lt;var&gt;sign&lt;/var&gt;, ptrdiff_t *&lt;var&gt;count&lt;/var&gt;, emacs_limb_t *&lt;var&gt;magnitude&lt;/var&gt;)&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;em&gt;bool &lt;/em&gt;&lt;strong&gt;extract_big_integer &lt;/strong&gt;&lt;em&gt;(emacs_env * &lt;var&gt;env&lt;/var&gt; , emacs_value &lt;var&gt;arg&lt;/var&gt; , int * &lt;var&gt;sign&lt;/var&gt; , ptrdiff_t * &lt;var&gt;count&lt;/var&gt; , emacs_limb_t * &lt;var&gt;magnitude&lt;/var&gt; )&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f4ddf8e81ae981c10ee9c4e6dee208d399cff2e9" translate="yes" xml:space="preserve">
          <source>Function: &lt;em&gt;bool&lt;/em&gt;&lt;strong&gt;is_not_nil&lt;/strong&gt;&lt;em&gt;(emacs_env *&lt;var&gt;env&lt;/var&gt;, emacs_value &lt;var&gt;val&lt;/var&gt;)&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;em&gt;bool &lt;/em&gt;&lt;strong&gt;is_not_nil &lt;/strong&gt;&lt;em&gt;(emacs_env * &lt;var&gt;env&lt;/var&gt; , emacs_value &lt;var&gt;val&lt;/var&gt; )&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="105efe21e95eddae77100b88bc0691a1b98616da" translate="yes" xml:space="preserve">
          <source>Function: &lt;em&gt;bool&lt;/em&gt;&lt;strong&gt;should_quit&lt;/strong&gt;&lt;em&gt;(emacs_env *&lt;var&gt;env&lt;/var&gt;)&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;em&gt;bool &lt;/em&gt;&lt;strong&gt;should_quit &lt;/strong&gt;&lt;em&gt;(emacs_env * &lt;var&gt;env&lt;/var&gt; )&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="46496808f25e805ece88233ae0979c6b0e67bbb9" translate="yes" xml:space="preserve">
          <source>Function: &lt;em&gt;double&lt;/em&gt;&lt;strong&gt;extract_float&lt;/strong&gt;&lt;em&gt;(emacs_env *&lt;var&gt;env&lt;/var&gt;, emacs_value &lt;var&gt;arg&lt;/var&gt;)&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;em&gt;double &lt;/em&gt;&lt;strong&gt;extract_float &lt;/strong&gt;&lt;em&gt;(emacs_env * &lt;var&gt;env&lt;/var&gt; , emacs_value &lt;var&gt;arg&lt;/var&gt; )&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="806aa18554b1b3b36361414dc4393f02345f2b77" translate="yes" xml:space="preserve">
          <source>Function: &lt;em&gt;emacs_finalizer&lt;/em&gt;&lt;strong&gt;get_user_finalizer&lt;/strong&gt;&lt;em&gt;(emacs_env *&lt;var&gt;env&lt;/var&gt;, emacs_value val)&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;em&gt;emacs_finalizer &lt;/em&gt;&lt;strong&gt;get_user_finalizer &lt;/strong&gt;&lt;em&gt;(emacs_env * &lt;var&gt;env&lt;/var&gt; , emacs_value val)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f92f9adbb019f4be1ff6bccd71fa37a1e9f0752d" translate="yes" xml:space="preserve">
          <source>Function: &lt;em&gt;emacs_value&lt;/em&gt;&lt;strong&gt;funcall&lt;/strong&gt;&lt;em&gt;(emacs_env *&lt;var&gt;env&lt;/var&gt;, emacs_value &lt;var&gt;func&lt;/var&gt;, ptrdiff_t &lt;var&gt;nargs&lt;/var&gt;, emacs_value *&lt;var&gt;args&lt;/var&gt;)&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;em&gt;emacs_value &lt;/em&gt;&lt;strong&gt;funcall &lt;/strong&gt;&lt;em&gt;(emacs_env * &lt;var&gt;env&lt;/var&gt; , emacs_value &lt;var&gt;func&lt;/var&gt; , ptrdiff_t &lt;var&gt;nargs&lt;/var&gt; , emacs_value * &lt;var&gt;args&lt;/var&gt; )&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5fe746a0b8a5af7907e36602dcb7cce31e68cffe" translate="yes" xml:space="preserve">
          <source>Function: &lt;em&gt;emacs_value&lt;/em&gt;&lt;strong&gt;intern&lt;/strong&gt;&lt;em&gt;(emacs_env *&lt;var&gt;env&lt;/var&gt;, const char *name)&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;em&gt;emacs_value &lt;/em&gt;&lt;strong&gt;인턴 &lt;/strong&gt;&lt;em&gt;(emacs_env * &lt;var&gt;env&lt;/var&gt; , const char * name)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="69366add43b68eb7557dd679115032d775dfbad4" translate="yes" xml:space="preserve">
          <source>Function: &lt;em&gt;emacs_value&lt;/em&gt;&lt;strong&gt;make_big_integer&lt;/strong&gt;&lt;em&gt;(emacs_env *&lt;var&gt;env&lt;/var&gt;, int sign, ptrdiff_t count, const emacs_limb_t *magnitude)&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;em&gt;emacs_value &lt;/em&gt;&lt;strong&gt;make_big_integer &lt;/strong&gt;&lt;em&gt;(emacs_env * &lt;var&gt;env&lt;/var&gt; , int sign, ptrdiff_t count, const emacs_limb_t * magnitude)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="86c526521a5e403b8f09c2f18f99a105ccb08944" translate="yes" xml:space="preserve">
          <source>Function: &lt;em&gt;emacs_value&lt;/em&gt;&lt;strong&gt;make_float&lt;/strong&gt;&lt;em&gt;(emacs_env *&lt;var&gt;env&lt;/var&gt;, double &lt;var&gt;d&lt;/var&gt;)&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;em&gt;emacs_value &lt;/em&gt;&lt;strong&gt;make_float &lt;/strong&gt;&lt;em&gt;(emacs_env * &lt;var&gt;env&lt;/var&gt; , double &lt;var&gt;d&lt;/var&gt; )&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bc9949f3e2b70023f22e3482180edb77f785724c" translate="yes" xml:space="preserve">
          <source>Function: &lt;em&gt;emacs_value&lt;/em&gt;&lt;strong&gt;make_function&lt;/strong&gt;&lt;em&gt;(emacs_env *&lt;var&gt;env&lt;/var&gt;, ptrdiff_t &lt;var&gt;min_arity&lt;/var&gt;, ptrdiff_t &lt;var&gt;max_arity&lt;/var&gt;, subr &lt;var&gt;func&lt;/var&gt;, const char *&lt;var&gt;docstring&lt;/var&gt;, void *&lt;var&gt;data&lt;/var&gt;)&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;em&gt;emacs_value &lt;/em&gt;&lt;strong&gt;make_function &lt;/strong&gt;&lt;em&gt;(emacs_env * &lt;var&gt;env&lt;/var&gt; , ptrdiff_t &lt;var&gt;min_arity&lt;/var&gt; , ptrdiff_t &lt;var&gt;max_arity&lt;/var&gt; , subr &lt;var&gt;func&lt;/var&gt; , const char * &lt;var&gt;docstring&lt;/var&gt; , void * &lt;var&gt;data&lt;/var&gt; )&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8f238a989184ce744dc0dae5aa6c965a18a3a354" translate="yes" xml:space="preserve">
          <source>Function: &lt;em&gt;emacs_value&lt;/em&gt;&lt;strong&gt;make_global_ref&lt;/strong&gt;&lt;em&gt;(emacs_env *&lt;var&gt;env&lt;/var&gt;, emacs_value &lt;var&gt;value&lt;/var&gt;)&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;em&gt;emacs_value &lt;/em&gt;&lt;strong&gt;make_global_ref &lt;/strong&gt;&lt;em&gt;(emacs_env * &lt;var&gt;env&lt;/var&gt; , emacs_value &lt;var&gt;value&lt;/var&gt; )&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d34b56badd48e7a7cf5498a40e61664a4221c33b" translate="yes" xml:space="preserve">
          <source>Function: &lt;em&gt;emacs_value&lt;/em&gt;&lt;strong&gt;make_integer&lt;/strong&gt;&lt;em&gt;(emacs_env *&lt;var&gt;env&lt;/var&gt;, intmax_t &lt;var&gt;n&lt;/var&gt;)&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;em&gt;emacs_value &lt;/em&gt;&lt;strong&gt;make_integer &lt;/strong&gt;&lt;em&gt;(emacs_env * &lt;var&gt;env&lt;/var&gt; , intmax_t &lt;var&gt;n&lt;/var&gt; )&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="efccd097e1691267c5cfc08bc051b9cf98d81271" translate="yes" xml:space="preserve">
          <source>Function: &lt;em&gt;emacs_value&lt;/em&gt;&lt;strong&gt;make_string&lt;/strong&gt;&lt;em&gt;(emacs_env *&lt;var&gt;env&lt;/var&gt;, const char *&lt;var&gt;str&lt;/var&gt;, ptrdiff_t &lt;var&gt;strlen&lt;/var&gt;)&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;em&gt;emacs_value &lt;/em&gt;&lt;strong&gt;make_string &lt;/strong&gt;&lt;em&gt;(emacs_env * &lt;var&gt;env&lt;/var&gt; , const char * &lt;var&gt;str&lt;/var&gt; , ptrdiff_t &lt;var&gt;strlen&lt;/var&gt; )&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bf62b723d8f9b3fb90335a5aa55f3134e61cc766" translate="yes" xml:space="preserve">
          <source>Function: &lt;em&gt;emacs_value&lt;/em&gt;&lt;strong&gt;make_time&lt;/strong&gt;&lt;em&gt;(emacs_env *&lt;var&gt;env&lt;/var&gt;, struct timespec &lt;var&gt;time&lt;/var&gt;)&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;em&gt;emacs_value &lt;/em&gt;&lt;strong&gt;make_time &lt;/strong&gt;&lt;em&gt;(emacs_env * &lt;var&gt;env&lt;/var&gt; , struct timespec &lt;var&gt;time&lt;/var&gt; )&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="31a94d5c82e3002103ed7286a113a6d5cd089bb8" translate="yes" xml:space="preserve">
          <source>Function: &lt;em&gt;emacs_value&lt;/em&gt;&lt;strong&gt;make_user_ptr&lt;/strong&gt;&lt;em&gt;(emacs_env *&lt;var&gt;env&lt;/var&gt;, emacs_finalizer &lt;var&gt;fin&lt;/var&gt;, void *&lt;var&gt;ptr&lt;/var&gt;)&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;em&gt;emacs_value &lt;/em&gt;&lt;strong&gt;make_user_ptr &lt;/strong&gt;&lt;em&gt;(emacs_env * &lt;var&gt;env&lt;/var&gt; , emacs_finalizer &lt;var&gt;fin&lt;/var&gt; , void * &lt;var&gt;ptr&lt;/var&gt; )&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1652df41489e8d88823b9838de59907c2468860b" translate="yes" xml:space="preserve">
          <source>Function: &lt;em&gt;emacs_value&lt;/em&gt;&lt;strong&gt;module_func&lt;/strong&gt;&lt;em&gt;(emacs_env *&lt;var&gt;env&lt;/var&gt;, ptrdiff_t &lt;var&gt;nargs&lt;/var&gt;, emacs_value *&lt;var&gt;args&lt;/var&gt;, void *&lt;var&gt;data&lt;/var&gt;)&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;em&gt;emacs_value &lt;/em&gt;&lt;strong&gt;module_func &lt;/strong&gt;&lt;em&gt;(emacs_env * &lt;var&gt;env&lt;/var&gt; , ptrdiff_t &lt;var&gt;nargs&lt;/var&gt; , emacs_value * &lt;var&gt;args&lt;/var&gt; , void * &lt;var&gt;data&lt;/var&gt; )&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ce19e0806cf91f917cda3b2a89173ee7dc9a6b19" translate="yes" xml:space="preserve">
          <source>Function: &lt;em&gt;emacs_value&lt;/em&gt;&lt;strong&gt;type_of&lt;/strong&gt;&lt;em&gt;(emacs_env *&lt;var&gt;env&lt;/var&gt;, emacs_value &lt;code&gt;object&lt;/code&gt;)&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;em&gt;emacs_value &lt;/em&gt;&lt;strong&gt;type_of &lt;/strong&gt;&lt;em&gt;(emacs_env * &lt;var&gt;env&lt;/var&gt; , emacs_value &lt;code&gt;object&lt;/code&gt; )&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3280286f69bb3ae9c426a405ae63213dd06d0a85" translate="yes" xml:space="preserve">
          <source>Function: &lt;em&gt;emacs_value&lt;/em&gt;&lt;strong&gt;vec_get&lt;/strong&gt;&lt;em&gt;(emacs_env *&lt;var&gt;env&lt;/var&gt;, emacs_value &lt;var&gt;vector&lt;/var&gt;, ptrdiff_t &lt;var&gt;index&lt;/var&gt;)&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;em&gt;emacs_value &lt;/em&gt;&lt;strong&gt;vec_get &lt;/strong&gt;&lt;em&gt;(emacs_env * &lt;var&gt;env&lt;/var&gt; , emacs_value &lt;var&gt;vector&lt;/var&gt; , ptrdiff_t &lt;var&gt;index&lt;/var&gt; )&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c2496c321ce0a12883501e61880954b51415ef01" translate="yes" xml:space="preserve">
          <source>Function: &lt;em&gt;enum&lt;/em&gt;&lt;strong&gt;emacs_funcall_exit&lt;/strong&gt;&lt;em&gt;non_local_exit_check (emacs_env *&lt;var&gt;env&lt;/var&gt;)&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;em&gt;enum &lt;/em&gt;&lt;strong&gt;emacs_funcall_exit &lt;/strong&gt;&lt;em&gt;non_local_exit_check (emacs_env * &lt;var&gt;env&lt;/var&gt; )&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="250199de739b457ef5e93610db2ca9333416587c" translate="yes" xml:space="preserve">
          <source>Function: &lt;em&gt;enum&lt;/em&gt;&lt;strong&gt;emacs_funcall_exit&lt;/strong&gt;&lt;em&gt;non_local_exit_get (emacs_env *&lt;var&gt;env&lt;/var&gt;, emacs_value *&lt;var&gt;symbol&lt;/var&gt;, emacs_value *&lt;var&gt;data&lt;/var&gt;)&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;em&gt;enum &lt;/em&gt;&lt;strong&gt;emacs_funcall_exit &lt;/strong&gt;&lt;em&gt;non_local_exit_get (emacs_env * &lt;var&gt;env&lt;/var&gt; , emacs_value * &lt;var&gt;symbol&lt;/var&gt; , emacs_value * &lt;var&gt;data&lt;/var&gt; )&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5f3c781b29789dfa749cbb1d1693af71aa8277c2" translate="yes" xml:space="preserve">
          <source>Function: &lt;em&gt;enum&lt;/em&gt;&lt;strong&gt;emacs_process_input_result&lt;/strong&gt;&lt;em&gt;process_input (emacs_env *&lt;var&gt;env&lt;/var&gt;)&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;em&gt;enum &lt;/em&gt;&lt;strong&gt;emacs_process_input_result &lt;/strong&gt;&lt;em&gt;process_input (emacs_env * &lt;var&gt;env&lt;/var&gt; )&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="15caa6ab5c37f9ed8c30fc5192ab79385790c989" translate="yes" xml:space="preserve">
          <source>Function: &lt;em&gt;int&lt;/em&gt;&lt;strong&gt;emacs_module_init&lt;/strong&gt;&lt;em&gt;(struct emacs_runtime *&lt;var&gt;runtime&lt;/var&gt;)&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;em&gt;int &lt;/em&gt;&lt;strong&gt;emacs_module_init &lt;/strong&gt;&lt;em&gt;(struct emacs_runtime * &lt;var&gt;runtime&lt;/var&gt; )&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ea173b2b82b3bd673c8e85458c9503487035efe6" translate="yes" xml:space="preserve">
          <source>Function: &lt;em&gt;intmax_t&lt;/em&gt;&lt;strong&gt;extract_integer&lt;/strong&gt;&lt;em&gt;(emacs_env *&lt;var&gt;env&lt;/var&gt;, emacs_value &lt;var&gt;arg&lt;/var&gt;)&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;em&gt;intmax_t &lt;/em&gt;&lt;strong&gt;extract_integer &lt;/strong&gt;&lt;em&gt;(emacs_env * &lt;var&gt;env&lt;/var&gt; , emacs_value &lt;var&gt;arg&lt;/var&gt; )&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4a5a11128abdaf3c29ce5252b15b3e9c9a7f9fbb" translate="yes" xml:space="preserve">
          <source>Function: &lt;em&gt;ptrdiff_t&lt;/em&gt;&lt;strong&gt;vec_size&lt;/strong&gt;&lt;em&gt;(emacs_env *&lt;var&gt;env&lt;/var&gt;, emacs_value &lt;var&gt;vector&lt;/var&gt;)&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;em&gt;ptrdiff_t &lt;/em&gt;&lt;strong&gt;vec_size &lt;/strong&gt;&lt;em&gt;(emacs_env * &lt;var&gt;env&lt;/var&gt; , emacs_value &lt;var&gt;vector&lt;/var&gt; )&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5795593173edce0d076b2301ab601e1a95b34ab3" translate="yes" xml:space="preserve">
          <source>Function: &lt;em&gt;struct&lt;/em&gt;&lt;strong&gt;timespec&lt;/strong&gt;&lt;em&gt;extract_time (emacs_env *&lt;var&gt;env&lt;/var&gt;, emacs_value &lt;var&gt;time&lt;/var&gt;)&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;em&gt;struct &lt;/em&gt;&lt;strong&gt;timespec &lt;/strong&gt;&lt;em&gt;extract_time (emacs_env * &lt;var&gt;env&lt;/var&gt; , emacs_value &lt;var&gt;time&lt;/var&gt; )&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a04e17cbd62c2f9d6a93b6044fd6de96f73193a6" translate="yes" xml:space="preserve">
          <source>Function: &lt;em&gt;void&lt;/em&gt;&lt;strong&gt;*get_user_ptr&lt;/strong&gt;&lt;em&gt;(emacs_env *&lt;var&gt;env&lt;/var&gt;, emacs_value val)&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;em&gt;void &lt;/em&gt;&lt;strong&gt;* get_user_ptr &lt;/strong&gt;&lt;em&gt;(emacs_env * &lt;var&gt;env&lt;/var&gt; , emacs_value val)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5cb40a95e6fdb40bbfdcb3f14ef923602f71cad3" translate="yes" xml:space="preserve">
          <source>Function: &lt;em&gt;void&lt;/em&gt;&lt;strong&gt;free_global_ref&lt;/strong&gt;&lt;em&gt;(emacs_env *&lt;var&gt;env&lt;/var&gt;, emacs_value &lt;var&gt;global_value&lt;/var&gt;)&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;em&gt;void &lt;/em&gt;&lt;strong&gt;free_global_ref &lt;/strong&gt;&lt;em&gt;(emacs_env * &lt;var&gt;env&lt;/var&gt; , emacs_value &lt;var&gt;global_value&lt;/var&gt; )&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4460a463b7a8fa974d526e5f4101013d6894d26f" translate="yes" xml:space="preserve">
          <source>Function: &lt;em&gt;void&lt;/em&gt;&lt;strong&gt;non_local_exit_clear&lt;/strong&gt;&lt;em&gt;(emacs_env *&lt;var&gt;env&lt;/var&gt;)&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;em&gt;void &lt;/em&gt;&lt;strong&gt;non_local_exit_clear &lt;/strong&gt;&lt;em&gt;(emacs_env * &lt;var&gt;env&lt;/var&gt; )&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="123e5abbfa3ddcfb3452326c55c6fea0835adde4" translate="yes" xml:space="preserve">
          <source>Function: &lt;em&gt;void&lt;/em&gt;&lt;strong&gt;non_local_exit_signal&lt;/strong&gt;&lt;em&gt;(emacs_env *&lt;var&gt;env&lt;/var&gt;, emacs_value &lt;var&gt;error&lt;/var&gt;, emacs_value &lt;var&gt;data&lt;/var&gt;)&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;em&gt;void &lt;/em&gt;&lt;strong&gt;non_local_exit_signal &lt;/strong&gt;&lt;em&gt;(emacs_env * &lt;var&gt;env&lt;/var&gt; , emacs_value &lt;var&gt;error&lt;/var&gt; , emacs_value &lt;var&gt;data&lt;/var&gt; )&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2998af0b6fdbee388b2efab4a316d0972913ffa0" translate="yes" xml:space="preserve">
          <source>Function: &lt;em&gt;void&lt;/em&gt;&lt;strong&gt;non_local_exit_throw&lt;/strong&gt;&lt;em&gt;(emacs_env *&lt;var&gt;env&lt;/var&gt;, emacs_value &lt;var&gt;tag&lt;/var&gt;, emacs_value &lt;var&gt;value&lt;/var&gt;)&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;em&gt;void &lt;/em&gt;&lt;strong&gt;non_local_exit_throw &lt;/strong&gt;&lt;em&gt;(emacs_env * &lt;var&gt;env&lt;/var&gt; , emacs_value &lt;var&gt;tag&lt;/var&gt; , emacs_value &lt;var&gt;value&lt;/var&gt; )&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0a6378174934b410fac15b7e06748ff0c46e5b8a" translate="yes" xml:space="preserve">
          <source>Function: &lt;em&gt;void&lt;/em&gt;&lt;strong&gt;set_user_finalizer&lt;/strong&gt;&lt;em&gt;(emacs_env *&lt;var&gt;env&lt;/var&gt;, emacs_value &lt;var&gt;val&lt;/var&gt;, emacs_finalizer &lt;var&gt;fin&lt;/var&gt;)&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;em&gt;void &lt;/em&gt;&lt;strong&gt;set_user_finalizer &lt;/strong&gt;&lt;em&gt;(emacs_env * &lt;var&gt;env&lt;/var&gt; , emacs_value &lt;var&gt;val&lt;/var&gt; , emacs_finalizer &lt;var&gt;fin&lt;/var&gt; )&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="848f2eb81bc2abc617b2bdd0e787737a3c29494b" translate="yes" xml:space="preserve">
          <source>Function: &lt;em&gt;void&lt;/em&gt;&lt;strong&gt;set_user_ptr&lt;/strong&gt;&lt;em&gt;(emacs_env *&lt;var&gt;env&lt;/var&gt;, emacs_value &lt;var&gt;value&lt;/var&gt;, void *&lt;var&gt;ptr&lt;/var&gt;)&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;em&gt;void &lt;/em&gt;&lt;strong&gt;set_user_ptr &lt;/strong&gt;&lt;em&gt;(emacs_env * &lt;var&gt;env&lt;/var&gt; , emacs_value &lt;var&gt;value&lt;/var&gt; , void * &lt;var&gt;ptr&lt;/var&gt; )&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d5f89a3e79a0b41ba6e1b673b9e5def02dde99dc" translate="yes" xml:space="preserve">
          <source>Function: &lt;em&gt;void&lt;/em&gt;&lt;strong&gt;vec_set&lt;/strong&gt;&lt;em&gt;(emacs_env *&lt;var&gt;env&lt;/var&gt;, emacs_value &lt;var&gt;vector&lt;/var&gt;, ptrdiff_t &lt;var&gt;index&lt;/var&gt;, emacs_value &lt;var&gt;value&lt;/var&gt;)&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;em&gt;void &lt;/em&gt;&lt;strong&gt;vec_set &lt;/strong&gt;&lt;em&gt;(emacs_env * &lt;var&gt;env&lt;/var&gt; , emacs_value &lt;var&gt;vector&lt;/var&gt; , ptrdiff_t &lt;var&gt;index&lt;/var&gt; , emacs_value &lt;var&gt;value&lt;/var&gt; )&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c1d791c892cb854a1ab849fac40b8468ef31039b" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;%&lt;/strong&gt;&lt;em&gt;dividend divisor&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;strong&gt;% &lt;/strong&gt;&lt;em&gt;배당 제수&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c5b18f8fd8b0717a513da835a9bab575062081b0" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;&amp;gt;&lt;/strong&gt;&lt;em&gt;number-or-marker &amp;amp;rest number-or-markers&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;&amp;gt; &lt;/strong&gt;&lt;em&gt;숫자 또는 마커 및 나머지 숫자 또는 마커&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f54f4af95eb930cb5a4378a94ca2e92e5c0c6ce2" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;&amp;gt;=&lt;/strong&gt;&lt;em&gt;number-or-marker &amp;amp;rest number-or-markers&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;&amp;gt; = &lt;/strong&gt;&lt;em&gt;숫자 또는 마커 및 나머지 숫자 또는 마커&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cb3fb7d841b16b297ea22eae4c2b7494c003c3ad" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;&amp;lt;&lt;/strong&gt;&lt;em&gt;number-or-marker &amp;amp;rest number-or-markers&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;&amp;lt; &lt;/strong&gt;&lt;em&gt;숫자 또는 마커 및 나머지 숫자 또는 마커&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3dd193607cabcb8340d5c70c2fb735a092f7a886" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;&amp;lt;=&lt;/strong&gt;&lt;em&gt;number-or-marker &amp;amp;rest number-or-markers&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;&amp;lt;= &lt;/strong&gt;&lt;em&gt;숫자 또는 마커 및 나머지 숫자 또는 마커&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="12612370492685d7458881bae8ab851336e5f836" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;*&lt;/strong&gt;&lt;em&gt;&amp;amp;rest numbers-or-markers&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;* &lt;/strong&gt;&lt;em&gt;&amp;amp; rest numbers-or-markers&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9f84436671ab7cbd9448b03e2fe260eb3839c121" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;+&lt;/strong&gt;&lt;em&gt;&amp;amp;rest numbers-or-markers&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;+ &lt;/strong&gt;&lt;em&gt;나머지 숫자 또는 마커&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b4622f3cebc989e3592888396fca10a463f08e83" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;-&lt;/strong&gt;&lt;em&gt;&amp;amp;optional number-or-marker &amp;amp;rest more-numbers-or-markers&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;- &lt;/strong&gt;&lt;em&gt;옵션 번호 또는 마커 및 나머지 번호 또는 마커&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6eb4aa1563e7358026ec57258beb186f2b9b212b" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;/&lt;/strong&gt;&lt;em&gt;number &amp;amp;rest divisors&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;strong&gt;/ &lt;/strong&gt;&lt;em&gt;숫자 및 나머지 제수&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="076c46093eb01acd7ee61ea40851f41483a1e2cc" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;/=&lt;/strong&gt;&lt;em&gt;number-or-marker1 number-or-marker2&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;strong&gt;/ = &lt;/strong&gt;&lt;em&gt;number-or-marker1 number-or-marker2&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9fda0e26f46e9f40e25b97f61dfc989122b0b0e9" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;1+&lt;/strong&gt;&lt;em&gt;number-or-marker&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;1+ &lt;/strong&gt;&lt;em&gt;숫자 또는 마커&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9ca4668dd4a486043993458ff7027542eca00f1b" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;1-&lt;/strong&gt;&lt;em&gt;number-or-marker&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;1- &lt;/strong&gt;&lt;em&gt;숫자 또는 마커&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="673f310a5e054265dee2baa2faefdc1daea9d19d" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;=&lt;/strong&gt;&lt;em&gt;number-or-marker &amp;amp;rest number-or-markers&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;= &lt;/strong&gt;&lt;em&gt;숫자 또는 마커 및 나머지 숫자 또는 마커&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="15660b1074ccfbafe711667eb02f31ce70c45534" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;Snarf-documentation&lt;/strong&gt;&lt;em&gt;filename&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;Snarf 문서 &lt;/strong&gt;&lt;em&gt;파일 이름&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="77a46a42adbb10113fb1b6acea2a498bc9117402" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;abbrev-expansion&lt;/strong&gt;&lt;em&gt;abbrev &amp;amp;optional table&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;abbrev-expansion &lt;/strong&gt;&lt;em&gt;abbrev &amp;amp; optional table&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ca0e02a5a5ae7bb3eeae0906eed53ed1bbc088a9" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;abbrev-get&lt;/strong&gt;&lt;em&gt;abbrev prop&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;abbrev-get &lt;/strong&gt;&lt;em&gt;abbrev prop&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fbe9898616465dfd7eee5e3befdff9b1b7fc4f78" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;abbrev-insert&lt;/strong&gt;&lt;em&gt;abbrev &amp;amp;optional name start end&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;abbrev-insert &lt;/strong&gt;&lt;em&gt;abbrev &amp;amp; optional name start end&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="05dd83f623c276f330db0a2b68227f250e2c8fc1" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;abbrev-put&lt;/strong&gt;&lt;em&gt;abbrev prop val&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;abbrev-put &lt;/strong&gt;&lt;em&gt;abbrev prop val&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="41adef79f28e09e25f992373945fe1334afed74c" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;abbrev-symbol&lt;/strong&gt;&lt;em&gt;abbrev &amp;amp;optional table&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;abbrev-symbol &lt;/strong&gt;&lt;em&gt;abbrev &amp;amp; optional table&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="add9f8e7576e279a97bce948454dd529fa92734d" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;abbrev-table-get&lt;/strong&gt;&lt;em&gt;table prop&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;abbrev-table-get &lt;/strong&gt;&lt;em&gt;table prop&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="274d77f3e845519adec06a38928af2a5861c1467" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;abbrev-table-p&lt;/strong&gt;&lt;em&gt;object&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;strong&gt;abbrev-table-p &lt;/strong&gt;&lt;em&gt;객체&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="509039c0b8ae1626f5c308473f97d52640dcffea" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;abbrev-table-put&lt;/strong&gt;&lt;em&gt;table prop val&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;abbrev-table-put &lt;/strong&gt;&lt;em&gt;table prop val&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2e88c141f0cee16cb883616ac8c23e605a46c157" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;abbreviate-file-name&lt;/strong&gt;&lt;em&gt;filename&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;약어 파일 이름 &lt;/strong&gt;&lt;em&gt;파일 이름&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="53988ea2de9bf1e2000f9f490c4e287009eb9563" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;abs&lt;/strong&gt;&lt;em&gt;number&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;abs &lt;/strong&gt;&lt;em&gt;번호&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4ef7e8af7f2674eed6c9add53bec94c999e16cc3" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;accept-change-group&lt;/strong&gt;&lt;em&gt;handle&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;변경 그룹 허용 &lt;/strong&gt;&lt;em&gt;핸들&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b61fe4be9450b4478d86aa7f2c8d6666ca4c335a" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;accept-process-output&lt;/strong&gt;&lt;em&gt;&amp;amp;optional process seconds millisec just-this-one&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;프로세스 출력 허용 &lt;/strong&gt;&lt;em&gt;및 옵션 프로세스 초 millisec just-this-one&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="77bfba268562aeedbcc567d0156de532e93cc598" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;access-file&lt;/strong&gt;&lt;em&gt;filename string&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;액세스 파일 파일 &lt;/strong&gt;&lt;em&gt;이름 문자열&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="94a7443266e7f0cd0769b54d0a023e51908e48c5" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;accessible-keymaps&lt;/strong&gt;&lt;em&gt;keymap &amp;amp;optional prefix&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;액세스 가능한 키맵 &lt;/strong&gt;&lt;em&gt;키맵 및 선택적 접두사&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="99d1773492edc65a1e4d4101e9af52d0e4ebcac9" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;acos&lt;/strong&gt;&lt;em&gt;arg&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;strong&gt;acos &lt;/strong&gt;&lt;em&gt;arg&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="359c3af0b85dce98d26212a265804a71f3b327ed" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;activate-change-group&lt;/strong&gt;&lt;em&gt;handle&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;활성 변경 그룹 &lt;/strong&gt;&lt;em&gt;핸들&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d8e06cd3ec808ed952ab178271d7443dcf4a538a" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;active-minibuffer-window&lt;/strong&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;활성 미니 버퍼 창&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="953f6635af7d1642eb26aa42cdf537faa7b40e50" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;add-face-text-property&lt;/strong&gt;&lt;em&gt;start end face &amp;amp;optional appendp object&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;add-face-text-property &lt;/strong&gt;&lt;em&gt;시작 끝면 및 선택적 appendp 개체&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dd381e5c98bd7eb6505076a8d913a11a30730429" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;add-hook&lt;/strong&gt;&lt;em&gt;hook function &amp;amp;optional depth local&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;추가 후크 &lt;/strong&gt;&lt;em&gt;후크 기능 및 옵션 깊이 로컬&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b68f9a3c00473be99f1930ec81233e79a5b81661" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;add-text-properties&lt;/strong&gt;&lt;em&gt;start end props &amp;amp;optional object&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;추가 텍스트 속성 &lt;/strong&gt;&lt;em&gt;시작 끝 소품 및 옵션 개체&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e86f0e066f0c0211d38fc23f7fa3b65e0f45b80a" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;add-to-history&lt;/strong&gt;&lt;em&gt;history-var newelt &amp;amp;optional maxelt keep-all&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;히스토리에 추가 &lt;/strong&gt;&lt;em&gt;내역 -var newelt &amp;amp; optional maxelt keep-all&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d4565f852f8c5f0f3662f27084d667f63990815a" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;add-to-invisibility-spec&lt;/strong&gt;&lt;em&gt;element&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;비 가시성 사양 추가 &lt;/strong&gt;&lt;em&gt;요소&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b0136fcb21e768536bf154e06b83fbc26ea0c436" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;add-to-list&lt;/strong&gt;&lt;em&gt;symbol element &amp;amp;optional append compare-fn&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;목록에 &lt;/strong&gt;&lt;em&gt;추가 기호 요소 및 옵션 추가 비교 -fn&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2e68e013c38485c87a82c737f9a93fb3766d2e4f" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;add-to-ordered-list&lt;/strong&gt;&lt;em&gt;symbol element &amp;amp;optional order&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;주문 목록에 추가 &lt;/strong&gt;&lt;em&gt;기호 요소 및 선택적 순서&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f2f73c558244dab072ebd4a857a53e530a675420" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;add-variable-watcher&lt;/strong&gt;&lt;em&gt;symbol watch-function&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;변수 감시자 &lt;/strong&gt;&lt;em&gt;기호 감시 기능 추가&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2e737df9537a502421509e0b982d4e8a69e9ae25" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;adjust-window-trailing-edge&lt;/strong&gt;&lt;em&gt;window delta &amp;amp;optional horizontal pixelwise&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;조정 창 뒤 가장자리 &lt;/strong&gt;&lt;em&gt;창 델타 및 선택적 수평 픽셀 단위&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0a03a2d3067c2c487ad56571c539c8c18dd6aa93" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;advice-add&lt;/strong&gt;&lt;em&gt;symbol where function &amp;amp;optional props&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;em&gt;기능 및 옵션 소품이있는 곳에 &lt;/em&gt;&lt;strong&gt;조언 추가 &lt;/strong&gt;&lt;em&gt;기호&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="34a24f2b4e69600effe8558ce547e4c14aae67f5" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;advice-eval-interactive-spec&lt;/strong&gt;&lt;em&gt;spec&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;advice-eval-interactive-spec &lt;/strong&gt;&lt;em&gt;사양&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0977ae87353d9e8482219dadc924900c613027d7" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;advice-function-mapc&lt;/strong&gt;&lt;em&gt;f function-def&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;strong&gt;advice-function-mapc &lt;/strong&gt;&lt;em&gt;f function-def&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7afbb1c06dc6b32625b8a429e078205b952c57c4" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;advice-function-member-p&lt;/strong&gt;&lt;em&gt;advice function-def&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;strong&gt;advice-function-member-p &lt;/strong&gt;&lt;em&gt;advice function-def&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c174211b70406fcf10d6edf2032714767f01569c" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;advice-mapc&lt;/strong&gt;&lt;em&gt;function symbol&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;조언 -mapc &lt;/strong&gt;&lt;em&gt;기능 기호&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3a160119c6132fd2ae34cb3730cd450afdd4eb3a" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;advice-member-p&lt;/strong&gt;&lt;em&gt;function symbol&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;strong&gt;advice-member-p &lt;/strong&gt;&lt;em&gt;함수 기호&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9d843324b80794950f554af4867420fd0b491f22" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;advice-remove&lt;/strong&gt;&lt;em&gt;symbol function&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;조언- &lt;/strong&gt;&lt;em&gt;기호 &lt;/em&gt;&lt;strong&gt;제거 &lt;/strong&gt;&lt;em&gt;기능&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3d1c39005211e777d3c66ade79300389ba19534a" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;after-find-file&lt;/strong&gt;&lt;em&gt;&amp;amp;optional error warn noauto after-find-file-from-revert-buffer nomodes&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;after-find-file &lt;/strong&gt;&lt;em&gt;및 optional error warn noauto after-find-file-from-revert-buffer nomodes&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6e850b484835785042b4a33b36759b6bb9948943" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;alist-get&lt;/strong&gt;&lt;em&gt;key alist &amp;amp;optional default remove testfn&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;alist-get &lt;/strong&gt;&lt;em&gt;key alist &amp;amp; optional default remove testfn&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0806197d3cc28021277a6f7a9b0d18bb6915cba4" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;all-completions&lt;/strong&gt;&lt;em&gt;string collection &amp;amp;optional predicate&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;모든 완성 &lt;/strong&gt;&lt;em&gt;문자열 수집 및 선택적 술어&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a7c8c2289593bd666923f67da5649b016add8893" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;all-threads&lt;/strong&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;모든 스레드&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="62b811abbd0e6fd55453507578a60daf3efdd5e2" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;append&lt;/strong&gt;&lt;em&gt;&amp;amp;rest sequences&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;추가 &lt;/strong&gt;&lt;em&gt;및 나머지 시퀀스&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="685848e651a9b657fe399dc2ee123889410b06e3" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;apply-partially&lt;/strong&gt;&lt;em&gt;func &amp;amp;rest args&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;strong&gt;부분적으로 &lt;/strong&gt;&lt;em&gt;func &amp;amp; rest 인수 &lt;/em&gt;&lt;strong&gt;적용&lt;/strong&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8cb3e9dea1c22f6f264810319e6ad738a5d69971" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;apply&lt;/strong&gt;&lt;em&gt;function &amp;amp;rest arguments&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;em&gt;함수 및 나머지 인수 &lt;/em&gt;&lt;strong&gt;적용&lt;/strong&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ae394c13f973ed82b3e262c675db73972a06adde" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;aref&lt;/strong&gt;&lt;em&gt;arr index&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;strong&gt;aref &lt;/strong&gt;&lt;em&gt;arr index&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9e64eea934ac20aa0d2ccf8e7fed61fc45f32ae3" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;arrayp&lt;/strong&gt;&lt;em&gt;object&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;strong&gt;arrayp &lt;/strong&gt;&lt;em&gt;객체&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d7f7340f1861f47fbcf07c149610ed64d854cccc" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;aset&lt;/strong&gt;&lt;em&gt;array index object&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;strong&gt;aset &lt;/strong&gt;&lt;em&gt;배열 인덱스 객체&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2a07af217548ae5263016b27748ad1c755d9e42a" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;ash&lt;/strong&gt;&lt;em&gt;integer1 count&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;strong&gt;ash &lt;/strong&gt;&lt;em&gt;integer1 count&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f5cfc164b82bdd3b33d533b5a21347b3d74cd612" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;asin&lt;/strong&gt;&lt;em&gt;arg&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;strong&gt;asin &lt;/strong&gt;&lt;em&gt;arg&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d2d6f8925f184501ac2514c7caeabe2d2447422a" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;ask-user-about-lock&lt;/strong&gt;&lt;em&gt;file other-user&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;em&gt;다른 &lt;/em&gt;&lt;strong&gt;사용자에게 &lt;/strong&gt;&lt;em&gt;파일 &lt;/em&gt;&lt;strong&gt;잠금에 대한 질문&lt;/strong&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2de941f15f7b2e0bba2d2f2477b93871730dfe28" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;ask-user-about-supersession-threat&lt;/strong&gt;&lt;em&gt;filename&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;사용자에 대한 대체 위협 &lt;/strong&gt;&lt;em&gt;파일 이름 &lt;/em&gt;&lt;strong&gt;묻기&lt;/strong&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3e3dddf98e0c8ce1a2c7a522d4602f077c4817ab" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;assoc-default&lt;/strong&gt;&lt;em&gt;key alist &amp;amp;optional test default&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;assoc-default &lt;/strong&gt;&lt;em&gt;key alist 및 optional test default&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cd41237ac600d80d3785527bbf6f7165f06fc135" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;assoc-delete-all&lt;/strong&gt;&lt;em&gt;key alist &amp;amp;optional test&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;assoc-delete-all &lt;/strong&gt;&lt;em&gt;key alist 및 optional test&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5eea2cb7c500f44d8ed58b7535d3d2c849fcb72d" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;assoc-string&lt;/strong&gt;&lt;em&gt;key alist &amp;amp;optional case-fold&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;assoc-string &lt;/strong&gt;&lt;em&gt;key alist &amp;amp; optional case-fold&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e444cc49745e6039bac4ea7bb00b8760dbc7de85" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;assoc&lt;/strong&gt;&lt;em&gt;key alist &amp;amp;optional testfn&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;assoc &lt;/strong&gt;&lt;em&gt;키 alist 및 옵션 testfn&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="239ea4015b314d56fb63ccbab0f4fc2de49a168f" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;assq-delete-all&lt;/strong&gt;&lt;em&gt;key alist&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;assq-delete-all &lt;/strong&gt;&lt;em&gt;key alist&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b3e2ab89d97305342a57961b5d864853ced83e28" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;assq&lt;/strong&gt;&lt;em&gt;key alist&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;assq&lt;/strong&gt;&lt;em&gt;key alist&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b2aea059a0d7f8476141fd937bf1aaf5702451cc" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;atan&lt;/strong&gt;&lt;em&gt;y &amp;amp;optional x&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;atan&lt;/strong&gt;&lt;em&gt;y &amp;amp;optional x&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e3c17221dde759a5e3575970a605d2a3e2ecb322" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;atom&lt;/strong&gt;&lt;em&gt;object&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;atom&lt;/strong&gt;&lt;em&gt;object&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c4a5318e6dd8e86460d3287e020d65f08d56761f" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;auto-save-file-name-p&lt;/strong&gt;&lt;em&gt;filename&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;auto-save-file-name-p&lt;/strong&gt;&lt;em&gt;filename&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a45e65f2ad7e289d0f2e7b052dc7033ab56a9488" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;autoload-do-load&lt;/strong&gt;&lt;em&gt;autoload &amp;amp;optional name macro-only&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;autoload-do-load&lt;/strong&gt;&lt;em&gt;autoload &amp;amp;optional name macro-only&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9bcc17624d066bb39ec0a10b6ee8cb0b717df9fe" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;autoload&lt;/strong&gt;&lt;em&gt;function filename &amp;amp;optional docstring interactive type&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;autoload&lt;/strong&gt;&lt;em&gt;function filename &amp;amp;optional docstring interactive type&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2dd6ebdf8c4bbd24dc0b202900e686bd4ef0b934" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;autoloadp&lt;/strong&gt;&lt;em&gt;object&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;autoloadp&lt;/strong&gt;&lt;em&gt;object&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="25871f854fbeddc919a99cee9f1478060b5227db" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;backtrace-debug&lt;/strong&gt;&lt;em&gt;level flag&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;backtrace-debug&lt;/strong&gt;&lt;em&gt;level flag&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f1bfcee75f6be560f58743876efc19d7b1084c19" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;backtrace-frame&lt;/strong&gt;&lt;em&gt;frame-number &amp;amp;optional base&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;backtrace-frame&lt;/strong&gt;&lt;em&gt;frame-number &amp;amp;optional base&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="53daa33b72ee12831288c7dac28606cb0327e76e" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;backtrace&lt;/strong&gt;</source>
          <target state="translated">Function: &lt;strong&gt;backtrace&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="131b40239bc16fc9212d7f437e20b6c20068addf" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;backup-buffer&lt;/strong&gt;</source>
          <target state="translated">Function: &lt;strong&gt;backup-buffer&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e1c5efaea3e860c5ebd7129d05cde63e7c0bda96" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;backup-file-name-p&lt;/strong&gt;&lt;em&gt;filename&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;backup-file-name-p&lt;/strong&gt;&lt;em&gt;filename&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9d4115caf626a72b2e5c2e0648d93a81ed356cd7" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;backward-prefix-chars&lt;/strong&gt;</source>
          <target state="translated">Function: &lt;strong&gt;backward-prefix-chars&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b88b5bfff69b86626c1c3a70a20ee3a792e06aa5" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;backward-word-strictly&lt;/strong&gt;&lt;em&gt;&amp;amp;optional count&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;backward-word-strictly&lt;/strong&gt;&lt;em&gt;&amp;amp;optional count&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="16ea05dcad961cd644a66c3eac32113074a9c690" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;barf-if-buffer-read-only&lt;/strong&gt;&lt;em&gt;&amp;amp;optional position&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;barf-if-buffer-read-only&lt;/strong&gt;&lt;em&gt;&amp;amp;optional position&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="69729dae5c8ac8b858b65ceb0bb2c48aab9a8e39" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;base64-decode-string&lt;/strong&gt;&lt;em&gt;string &amp;amp;optional base64url&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;base64-decode-string&lt;/strong&gt;&lt;em&gt;string &amp;amp;optional base64url&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b00edb6416a8bab975c2b26f9fdb30ae0d15525c" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;base64-encode-string&lt;/strong&gt;&lt;em&gt;string &amp;amp;optional no-line-break&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;base64-encode-string&lt;/strong&gt;&lt;em&gt;string &amp;amp;optional no-line-break&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e3e143ea36d12eaa70b2fca8d8067c4c57e5bcb7" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;base64url-encode-string&lt;/strong&gt;&lt;em&gt;string &amp;amp;optional no-pad&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;base64url-encode-string&lt;/strong&gt;&lt;em&gt;string &amp;amp;optional no-pad&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="502c313c6cc48b783b00781dea93cd5cd8433d20" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;batch-byte-compile&lt;/strong&gt;&lt;em&gt;&amp;amp;optional noforce&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;batch-byte-compile&lt;/strong&gt;&lt;em&gt;&amp;amp;optional noforce&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ab89670592e1d6b6b9440f7820bb8fb26632f386" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;beep&lt;/strong&gt;&lt;em&gt;&amp;amp;optional do-not-terminate&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;beep&lt;/strong&gt;&lt;em&gt;&amp;amp;optional do-not-terminate&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6273a498025b29bd7d9a8184945cc88fd76b1c8b" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;bidi-find-overridden-directionality&lt;/strong&gt;&lt;em&gt;from to &amp;amp;optional object&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;bidi-find-overridden-directionality&lt;/strong&gt;&lt;em&gt;from to &amp;amp;optional object&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="174beea5b65772f0c690611ea4c86a51786f110b" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;bidi-string-mark-left-to-right&lt;/strong&gt;&lt;em&gt;string&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;bidi-string-mark-left-to-right&lt;/strong&gt;&lt;em&gt;string&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="56774e34cb951af8612601ccda8e628c07085c80" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;bignump&lt;/strong&gt;&lt;em&gt;object&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;bignump&lt;/strong&gt;&lt;em&gt;object&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="aee0ddae4c2d01b37c319b39675454a74c5e3756" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;bindat-get-field&lt;/strong&gt;&lt;em&gt;struct &amp;amp;rest name&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;bindat-get-field&lt;/strong&gt;&lt;em&gt;struct &amp;amp;rest name&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8661379acb672e89fc6786773783f4035a5e2d7a" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;bindat-ip-to-string&lt;/strong&gt;&lt;em&gt;ip&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;bindat-ip-to-string&lt;/strong&gt;&lt;em&gt;ip&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="313d20a7f51e0c756d97d20c79e0fab2e0062c5b" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;bindat-length&lt;/strong&gt;&lt;em&gt;spec struct&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;bindat-length&lt;/strong&gt;&lt;em&gt;spec struct&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bcfa80aa0cd096410642a04ebd9d63dcf821c98e" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;bindat-pack&lt;/strong&gt;&lt;em&gt;spec struct &amp;amp;optional bindat-raw bindat-idx&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;bindat-pack&lt;/strong&gt;&lt;em&gt;spec struct &amp;amp;optional bindat-raw bindat-idx&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9c39da3f53b4c7c9fada690b5290ce87496af432" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;bindat-unpack&lt;/strong&gt;&lt;em&gt;spec bindat-raw &amp;amp;optional bindat-idx&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;bindat-unpack&lt;/strong&gt;&lt;em&gt;spec bindat-raw &amp;amp;optional bindat-idx&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="14d6231efdd46c46683ca9fd42ac584c6eab262f" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;bitmap-spec-p&lt;/strong&gt;&lt;em&gt;object&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;bitmap-spec-p&lt;/strong&gt;&lt;em&gt;object&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="33f6df1d1f12a61e4f5c9fb7e353e63cb1b7303c" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;bobp&lt;/strong&gt;</source>
          <target state="translated">Function: &lt;strong&gt;bobp&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f95a13f4f7713a06dfeb5b616fe25d005531f18b" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;bolp&lt;/strong&gt;</source>
          <target state="translated">Function: &lt;strong&gt;bolp&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cf11ebf627ce9b13fbaebc9f63f13cd2ead96088" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;bool-vector-count-consecutive&lt;/strong&gt;&lt;em&gt;a b i&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;bool-vector-count-consecutive&lt;/strong&gt;&lt;em&gt;a b i&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="109f1f4a3a6504eb7b376d51a67171e8e8eecd06" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;bool-vector-count-population&lt;/strong&gt;&lt;em&gt;a&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;bool-vector-count-population&lt;/strong&gt;&lt;em&gt;a&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2ebd08cb45eb4d3110ca15806108143f8e950460" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;bool-vector-exclusive-or&lt;/strong&gt;&lt;em&gt;a b &amp;amp;optional c&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;bool-vector-exclusive-or&lt;/strong&gt;&lt;em&gt;a b &amp;amp;optional c&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="246d1b242787c8af9c656851739d05d1cffa4ebd" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;bool-vector-intersection&lt;/strong&gt;&lt;em&gt;a b &amp;amp;optional c&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;bool-vector-intersection&lt;/strong&gt;&lt;em&gt;a b &amp;amp;optional c&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d0e3fce4270209a102734690cfa709018fab0f98" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;bool-vector-not&lt;/strong&gt;&lt;em&gt;a &amp;amp;optional b&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;bool-vector-not&lt;/strong&gt;&lt;em&gt;a &amp;amp;optional b&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6732e4b0a85990ee32be720e711cd64ea2e8bdb3" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;bool-vector-p&lt;/strong&gt;&lt;em&gt;object&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;bool-vector-p&lt;/strong&gt;&lt;em&gt;object&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="55168ada494c82e0b7f718e23d9e830dee8557ac" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;bool-vector-set-difference&lt;/strong&gt;&lt;em&gt;a b &amp;amp;optional c&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;bool-vector-set-difference&lt;/strong&gt;&lt;em&gt;a b &amp;amp;optional c&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="12f9e56dbe8024c15162eb83a99abfd3fbb34e88" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;bool-vector-subsetp&lt;/strong&gt;&lt;em&gt;a b&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;bool-vector-subsetp&lt;/strong&gt;&lt;em&gt;a b&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4e465262a9d0edb9a4325997854ecbe635d203b4" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;bool-vector-union&lt;/strong&gt;&lt;em&gt;a b &amp;amp;optional c&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;bool-vector-union&lt;/strong&gt;&lt;em&gt;a b &amp;amp;optional c&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c9d36db9eb4751a9be4d3d13f0d92487c020ca0a" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;bool-vector&lt;/strong&gt;&lt;em&gt;&amp;amp;rest objects&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;bool-vector&lt;/strong&gt;&lt;em&gt;&amp;amp;rest objects&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="14b6580f1de56e0b35115e844658bf51519c7195" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;booleanp&lt;/strong&gt;&lt;em&gt;object&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;booleanp&lt;/strong&gt;&lt;em&gt;object&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="015300599d04983874d9fbd2d64cac46d359c4df" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;boundp&lt;/strong&gt;&lt;em&gt;variable&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;boundp&lt;/strong&gt;&lt;em&gt;variable&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fa96a4d675e94c373ad136e7914966a49dbddc40" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;buffer-base-buffer&lt;/strong&gt;&lt;em&gt;&amp;amp;optional buffer&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;buffer-base-buffer&lt;/strong&gt;&lt;em&gt;&amp;amp;optional buffer&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="30b0cd18a017c9c767c4f91441b4d5f80dbb27cb" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;buffer-chars-modified-tick&lt;/strong&gt;&lt;em&gt;&amp;amp;optional buffer&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;buffer-chars-modified-tick&lt;/strong&gt;&lt;em&gt;&amp;amp;optional buffer&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0443bfd1aafd5fb44360b0fa616a0c3d7abe7a3a" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;buffer-end&lt;/strong&gt;&lt;em&gt;flag&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;buffer-end&lt;/strong&gt;&lt;em&gt;flag&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a305c9472a806f5d996a6a4e3196954831ec9f0b" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;buffer-file-name&lt;/strong&gt;&lt;em&gt;&amp;amp;optional buffer&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;buffer-file-name&lt;/strong&gt;&lt;em&gt;&amp;amp;optional buffer&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4a588ee8706783f01d6774d66e016ce1907ee5c5" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;buffer-hash&lt;/strong&gt;&lt;em&gt;&amp;amp;optional buffer-or-name&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;buffer-hash&lt;/strong&gt;&lt;em&gt;&amp;amp;optional buffer-or-name&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3c8cbfa11b12c59b8fb8db20cea27dbec8dddf58" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;buffer-list&lt;/strong&gt;&lt;em&gt;&amp;amp;optional frame&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;buffer-list&lt;/strong&gt;&lt;em&gt;&amp;amp;optional frame&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5ca67bf70826116169e721edc84594fe5147bad1" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;buffer-live-p&lt;/strong&gt;&lt;em&gt;object&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;buffer-live-p&lt;/strong&gt;&lt;em&gt;object&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f8dd2e9588a43afbb497aa44486ef9ff4765e112" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;buffer-local-value&lt;/strong&gt;&lt;em&gt;variable buffer&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;buffer-local-value&lt;/strong&gt;&lt;em&gt;variable buffer&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ce7a0d5828c58d2679728d56b544ac143e00c13f" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;buffer-local-variables&lt;/strong&gt;&lt;em&gt;&amp;amp;optional buffer&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;buffer-local-variables&lt;/strong&gt;&lt;em&gt;&amp;amp;optional buffer&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2361533430ee22ffd5fbaa9060b081d67c613fa1" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;buffer-modified-p&lt;/strong&gt;&lt;em&gt;&amp;amp;optional buffer&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;buffer-modified-p&lt;/strong&gt;&lt;em&gt;&amp;amp;optional buffer&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b440756221715880ae125e3e0875f94aa1b5b441" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;buffer-modified-tick&lt;/strong&gt;&lt;em&gt;&amp;amp;optional buffer&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;buffer-modified-tick&lt;/strong&gt;&lt;em&gt;&amp;amp;optional buffer&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6f13793e7de251b0b3f7b9fb488f0b93db11bbdf" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;buffer-name&lt;/strong&gt;&lt;em&gt;&amp;amp;optional buffer&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;buffer-name&lt;/strong&gt;&lt;em&gt;&amp;amp;optional buffer&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="051f9f2ce3fe25bda59e56824b2cf327bad985d3" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;buffer-narrowed-p&lt;/strong&gt;</source>
          <target state="translated">Function: &lt;strong&gt;buffer-narrowed-p&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="be9a6e1469db9cd48289d3ee62ea1a4a9ae1a14a" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;buffer-size&lt;/strong&gt;&lt;em&gt;&amp;amp;optional buffer&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;buffer-size&lt;/strong&gt;&lt;em&gt;&amp;amp;optional buffer&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="82509c27cdfb038cedd2cdf951cc2734d4c980c1" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;buffer-string&lt;/strong&gt;</source>
          <target state="translated">Function: &lt;strong&gt;buffer-string&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="17016db07a116a15ab5e40bf753899eff9d5a069" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;buffer-substring-no-properties&lt;/strong&gt;&lt;em&gt;start end&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;buffer-substring-no-properties&lt;/strong&gt;&lt;em&gt;start end&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="31d80d0da447e850d905aa6c5c7387be81590fcf" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;buffer-substring-with-bidi-context&lt;/strong&gt;&lt;em&gt;start end &amp;amp;optional no-properties&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;buffer-substring-with-bidi-context&lt;/strong&gt;&lt;em&gt;start end &amp;amp;optional no-properties&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="46a5fbf3089f710234647453da78389ad538460e" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;buffer-substring&lt;/strong&gt;&lt;em&gt;start end&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;buffer-substring&lt;/strong&gt;&lt;em&gt;start end&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4ab8f55221eb9ae34e31fcedba33c52146cc259f" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;buffer-swap-text&lt;/strong&gt;&lt;em&gt;buffer&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;buffer-swap-text&lt;/strong&gt;&lt;em&gt;buffer&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2a873b81a04afe17fdd2452b1ef8f1481328d86a" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;bufferp&lt;/strong&gt;&lt;em&gt;object&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;bufferp&lt;/strong&gt;&lt;em&gt;object&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e61da70f8396c27b6ea9303ac9a498891355c382" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;bufferpos-to-filepos&lt;/strong&gt;&lt;em&gt;position &amp;amp;optional quality coding-system&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;bufferpos-to-filepos&lt;/strong&gt;&lt;em&gt;position &amp;amp;optional quality coding-system&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1aae739e73cab112d9cb7859964cb6e80d307bbe" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;butlast&lt;/strong&gt;&lt;em&gt;x &amp;amp;optional n&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;butlast&lt;/strong&gt;&lt;em&gt;x &amp;amp;optional n&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0f6fcb0726c12ad91cb45f3e4fbeccbd519826a9" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;button-activate&lt;/strong&gt;&lt;em&gt;button &amp;amp;optional use-mouse-action&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;button-activate&lt;/strong&gt;&lt;em&gt;button &amp;amp;optional use-mouse-action&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ca9452480ff3f1e9d2a339fac689785df2396af9" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;button-at&lt;/strong&gt;&lt;em&gt;pos&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;button-at&lt;/strong&gt;&lt;em&gt;pos&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f51a047ff418564c15fbb3a5aa5a3e6452a1bdd4" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;button-end&lt;/strong&gt;&lt;em&gt;button&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;button-end&lt;/strong&gt;&lt;em&gt;button&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6e52df647fabf94c621851bd41ba7de3686f04e5" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;button-get&lt;/strong&gt;&lt;em&gt;button prop&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;button-get&lt;/strong&gt;&lt;em&gt;button prop&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7403216f1bac8fb74966974ca1e2a03d1ab0ca52" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;button-has-type-p&lt;/strong&gt;&lt;em&gt;button type&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;button-has-type-p&lt;/strong&gt;&lt;em&gt;button type&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f23376ac82096363c6d97867068ad30f6a9beaeb" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;button-label&lt;/strong&gt;&lt;em&gt;button&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;button-label&lt;/strong&gt;&lt;em&gt;button&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="93158304b6700c969fbb97bdc3d2059b07b38479" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;button-put&lt;/strong&gt;&lt;em&gt;button prop val&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;button-put&lt;/strong&gt;&lt;em&gt;button prop val&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8e51aa27bd72f552fea52cdaf01c0e2a99eafce4" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;button-start&lt;/strong&gt;&lt;em&gt;button&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;button-start&lt;/strong&gt;&lt;em&gt;button&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fb745763f947d23f7f02548b039b9b0b06a5ed1b" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;button-type-get&lt;/strong&gt;&lt;em&gt;type prop&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;button-type-get&lt;/strong&gt;&lt;em&gt;type prop&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b86a8e6f9f1ed2d38223af842fedd8a8a772e814" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;button-type-put&lt;/strong&gt;&lt;em&gt;type prop val&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;button-type-put&lt;/strong&gt;&lt;em&gt;type prop val&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9e2da9a762553d3872d08ca4fa6edd1143809040" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;button-type-subtype-p&lt;/strong&gt;&lt;em&gt;type supertype&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;button-type-subtype-p&lt;/strong&gt;&lt;em&gt;type supertype&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="afa4c3b3d69c1615a40e9eda6618bf16b1f9fa7a" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;button-type&lt;/strong&gt;&lt;em&gt;button&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;button-type&lt;/strong&gt;&lt;em&gt;button&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="33d5ca8cef956ebbd0376b69d71c1018242bf98d" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;byte-code-function-p&lt;/strong&gt;&lt;em&gt;object&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;byte-code-function-p&lt;/strong&gt;&lt;em&gt;object&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f7ccd7da8afeba0ab4a2651f17fb68ce02186f44" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;byte-compile&lt;/strong&gt;&lt;em&gt;symbol&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;byte-compile&lt;/strong&gt;&lt;em&gt;symbol&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4c97893403e189c5afc92eb46dcb634eeca63eba" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;byte-to-position&lt;/strong&gt;&lt;em&gt;byte-position&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;byte-to-position&lt;/strong&gt;&lt;em&gt;byte-position&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b0ee476c873d1696c33d9137e7b4d7fbafc86a64" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;byte-to-string&lt;/strong&gt;&lt;em&gt;byte&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;byte-to-string&lt;/strong&gt;&lt;em&gt;byte&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="34aee39d08024d3c82e4a99ab8586244c3453c5c" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;caar&lt;/strong&gt;&lt;em&gt;cons-cell&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;caar&lt;/strong&gt;&lt;em&gt;cons-cell&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1c1be267e9d9904b4842e45fac881df3ea9ee781" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;cadr&lt;/strong&gt;&lt;em&gt;cons-cell&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;cadr&lt;/strong&gt;&lt;em&gt;cons-cell&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dd0cf7d1ef7edafb7f4d58c7fb2c4dfa8e40249f" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;call-interactively&lt;/strong&gt;&lt;em&gt;command &amp;amp;optional record-flag keys&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;call-interactively&lt;/strong&gt;&lt;em&gt;command &amp;amp;optional record-flag keys&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="70eb9ec601554f2c6a1eae0d4237acc70e23f4ff" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;call-process-region&lt;/strong&gt;&lt;em&gt;start end program &amp;amp;optional delete destination display &amp;amp;rest args&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;call-process-region&lt;/strong&gt;&lt;em&gt;start end program &amp;amp;optional delete destination display &amp;amp;rest args&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9365262957294c1bcc5562ff05953f8f9a75af4e" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;call-process-shell-command&lt;/strong&gt;&lt;em&gt;command &amp;amp;optional infile destination display&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;call-process-shell-command&lt;/strong&gt;&lt;em&gt;command &amp;amp;optional infile destination display&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="234a7c69afb454fee73bf056731bbba0e1b8ad62" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;call-process&lt;/strong&gt;&lt;em&gt;program &amp;amp;optional infile destination display &amp;amp;rest args&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;call-process&lt;/strong&gt;&lt;em&gt;program &amp;amp;optional infile destination display &amp;amp;rest args&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9631a8956c2209172b946e088f1d4d19888300ab" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;call-shell-region&lt;/strong&gt;&lt;em&gt;start end command &amp;amp;optional delete destination&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;call-shell-region&lt;/strong&gt;&lt;em&gt;start end command &amp;amp;optional delete destination&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="550062a7c1554f6b94d87fd8f85f7e5b078c83c9" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;called-interactively-p&lt;/strong&gt;&lt;em&gt;kind&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;called-interactively-p&lt;/strong&gt;&lt;em&gt;kind&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="66277dfa7cb1220ff14e4fd9e8eb5c5d3f96849b" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;cancel-change-group&lt;/strong&gt;&lt;em&gt;handle&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;cancel-change-group&lt;/strong&gt;&lt;em&gt;handle&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2775faf1bf3f7c4a57b1cdfa7bced6f68da5f8dd" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;cancel-timer&lt;/strong&gt;&lt;em&gt;timer&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;cancel-timer&lt;/strong&gt;&lt;em&gt;timer&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="852307446d52147294fb5e73102228a3c74dd7e6" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;capitalize&lt;/strong&gt;&lt;em&gt;string-or-char&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;capitalize&lt;/strong&gt;&lt;em&gt;string-or-char&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6c004eb4846b6c84e18ba1845f08f5c7b43ef391" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;car-safe&lt;/strong&gt;&lt;em&gt;object&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;car-safe&lt;/strong&gt;&lt;em&gt;object&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d70f4229ec1ac5395ecaca935a9eb158d493d596" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;car&lt;/strong&gt;&lt;em&gt;cons-cell&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;car&lt;/strong&gt;&lt;em&gt;cons-cell&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3936a03b2f6902b4e1b3f9cdb1531ba75c7fdc9f" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;case-table-p&lt;/strong&gt;&lt;em&gt;object&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;case-table-p&lt;/strong&gt;&lt;em&gt;object&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f6c80d2bde519e96a1579fa2e654beeb480a019c" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;category-docstring&lt;/strong&gt;&lt;em&gt;category &amp;amp;optional table&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;category-docstring&lt;/strong&gt;&lt;em&gt;category &amp;amp;optional table&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="070e8c8e7664306ae6871b597ba1e1ec5a2d9f45" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;category-set-mnemonics&lt;/strong&gt;&lt;em&gt;category-set&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;category-set-mnemonics&lt;/strong&gt;&lt;em&gt;category-set&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7c698443236912bb108079102c13ea723d947934" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;category-table-p&lt;/strong&gt;&lt;em&gt;object&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;category-table-p&lt;/strong&gt;&lt;em&gt;object&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5e92b685cd7c3a22a24f78e6056be4628b96bd9e" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;category-table&lt;/strong&gt;</source>
          <target state="translated">Function: &lt;strong&gt;category-table&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a7e66dc454d4d853a9310418f8a332bb82a23437" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;cdar&lt;/strong&gt;&lt;em&gt;cons-cell&lt;/em&gt;</source>
          <target state="translated">Function: &lt;strong&gt;cdar&lt;/strong&gt;&lt;em&gt;cons-cell&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="16622ba509a2c267ee58ef2ea832f27fa9c15608" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;cddr&lt;/strong&gt;&lt;em&gt;cons-cell&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;cddr &lt;/strong&gt;&lt;em&gt;cons-cell&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f10afae7b007b51a030ab5fc705e6bac1ef7a5df" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;cdr-safe&lt;/strong&gt;&lt;em&gt;object&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;cdr-safe &lt;/strong&gt;&lt;em&gt;개체&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="047f4689447b96857a8947da4cba0269e448a6d0" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;cdr&lt;/strong&gt;&lt;em&gt;cons-cell&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;cdr &lt;/strong&gt;&lt;em&gt;cons-cell&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="60c77f25bf6184d810695988dec19771d2976e6f" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;ceiling&lt;/strong&gt;&lt;em&gt;number &amp;amp;optional divisor&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;천장 &lt;/strong&gt;&lt;em&gt;번호 및 선택적 제수&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="852ffa748551d3f9377a2bef50e6bd61d6f777d2" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;char-after&lt;/strong&gt;&lt;em&gt;&amp;amp;optional position&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;문자 후 &lt;/strong&gt;&lt;em&gt;및 옵션 위치&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dea239d2c680d7781cdc8ab2943bd00f710fb846" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;char-before&lt;/strong&gt;&lt;em&gt;&amp;amp;optional position&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;char-before &lt;/strong&gt;&lt;em&gt;&amp;amp; optional 위치&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0a206b520bc6631f48b86177f0a53d3b646edf28" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;char-category-set&lt;/strong&gt;&lt;em&gt;char&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;strong&gt;char-category-set &lt;/strong&gt;&lt;em&gt;char&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="630a918840f55a66b9568d9e9c4feaa333dde02a" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;char-charset&lt;/strong&gt;&lt;em&gt;character &amp;amp;optional restriction&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;char-charset &lt;/strong&gt;&lt;em&gt;문자 및 선택적 제한&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2753b71977cc335c4845e0c8ca9a11e22dfdc6f7" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;char-code-property-description&lt;/strong&gt;&lt;em&gt;prop value&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;char-code-property-description &lt;/strong&gt;&lt;em&gt;prop 값&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c5cc1d800868abd6aabd731dcd6bd832791c3d1a" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;char-displayable-p&lt;/strong&gt;&lt;em&gt;char&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;char-displayable-p &lt;/strong&gt;&lt;em&gt;char&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e60536f10c7d06039df977083bcf87c9234e96ee" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;char-equal&lt;/strong&gt;&lt;em&gt;character1 character2&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;char-equal &lt;/strong&gt;&lt;em&gt;character1 character2&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7d95d1f5b01d5c8b438cd5fecf47d85bbbb1ec36" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;char-from-name&lt;/strong&gt;&lt;em&gt;string &amp;amp;optional ignore-case&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;char-from-name &lt;/strong&gt;&lt;em&gt;문자열 및 선택 사항 인 ignore-case&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4c40d317b8cc626c35194e60bd40385ac0639016" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;char-or-string-p&lt;/strong&gt;&lt;em&gt;object&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;strong&gt;char-or-string-p &lt;/strong&gt;&lt;em&gt;객체&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c897d63f806af28afb4cd60c3b96ad98b8eec58b" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;char-syntax&lt;/strong&gt;&lt;em&gt;character&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;문자 구문 &lt;/strong&gt;&lt;em&gt;문자&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bd4c50fa276c601b56559c709ed5079269d00f03" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;char-table-extra-slot&lt;/strong&gt;&lt;em&gt;char-table n&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;char-table-extra-slot &lt;/strong&gt;&lt;em&gt;char-table n&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7dcb199fd0da9d3bcb0a1bdc4287df214f46b2b8" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;char-table-p&lt;/strong&gt;&lt;em&gt;object&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;strong&gt;char-table-p &lt;/strong&gt;&lt;em&gt;객체&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="42c7484134ef84c8e29ffb12bec1f7670d494138" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;char-table-parent&lt;/strong&gt;&lt;em&gt;char-table&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;char-table-parent &lt;/strong&gt;&lt;em&gt;char-table&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="785b5330bbfc8af5f6a6b5d277eace49d768b8c7" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;char-table-range&lt;/strong&gt;&lt;em&gt;char-table range&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;strong&gt;문자 테이블 범위 &lt;/strong&gt;&lt;em&gt;문자 테이블 범위&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1d30fab06f4240d0098779781b5cc71828316051" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;char-table-subtype&lt;/strong&gt;&lt;em&gt;char-table&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;strong&gt;char-table-subtype &lt;/strong&gt;&lt;em&gt;char-table&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f64a2fc8b8fcc9100bba6396e9e3af39c89be4f2" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;char-to-string&lt;/strong&gt;&lt;em&gt;character&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;문자-문자열 &lt;/strong&gt;&lt;em&gt;문자&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dc564b1d5ffdddfb9ab7d2ebef9e0a5b1aa1ccf9" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;char-width&lt;/strong&gt;&lt;em&gt;char&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;strong&gt;char-width &lt;/strong&gt;&lt;em&gt;char&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e9823c73fc58ec1b90bc60c496b9503895558b9b" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;characterp&lt;/strong&gt;&lt;em&gt;charcode&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;characterp &lt;/strong&gt;&lt;em&gt;charcode&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6d5a77b0c220e9a44df58e66ac5918c3c26f19d7" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;charset-after&lt;/strong&gt;&lt;em&gt;&amp;amp;optional pos&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;charset-after &lt;/strong&gt;&lt;em&gt;&amp;amp; optional pos&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d6ec702c076c38a6163e8c24e48449e2eb5b3be3" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;charset-plist&lt;/strong&gt;&lt;em&gt;charset&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;charset-plist &lt;/strong&gt;&lt;em&gt;charset&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fc570a269b2d36d3ed29317490ff3bbf1fa9c48b" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;charset-priority-list&lt;/strong&gt;&lt;em&gt;&amp;amp;optional highestp&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;charset-priority-list &lt;/strong&gt;&lt;em&gt;&amp;amp; optional higherp&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0de4a58f17ffccd5bbb338fcb332677631602c64" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;charsetp&lt;/strong&gt;&lt;em&gt;object&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;strong&gt;charsetp &lt;/strong&gt;&lt;em&gt;객체&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ac3f930abaa34eee0d80761a890cc69ec044a1ec" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;check-coding-system&lt;/strong&gt;&lt;em&gt;coding-system&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;검사 코딩 시스템 &lt;/strong&gt;&lt;em&gt;코딩 시스템&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="206b61972e1cd69d6fd67557025bbeeed96cac1f" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;check-coding-systems-region&lt;/strong&gt;&lt;em&gt;start end coding-system-list&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;check-coding-systems-region &lt;/strong&gt;&lt;em&gt;시작 끝 coding-system-list&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="91b99c57992a4a4782e83da9223b3d24a7d89b60" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;cl-call-next-method&lt;/strong&gt;&lt;em&gt;&amp;amp;rest args&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;strong&gt;cl-call-next-method &lt;/strong&gt;&lt;em&gt;&amp;amp; rest args&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="df2781c0e34245e14e02e966b85cb332d6a423df" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;cl-next-method-p&lt;/strong&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;cl-next-method-p&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c1adb23327f964787a36bf908dab545d3b70dfe7" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;cl-old-struct-compat-mode&lt;/strong&gt;&lt;em&gt;arg&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;strong&gt;cl-old-struct-compat-mode &lt;/strong&gt;&lt;em&gt;arg&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d16ddc1de231afc2e9248a4e1ea784ce180f3c02" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;clear-abbrev-table&lt;/strong&gt;&lt;em&gt;abbrev-table&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;clear-abbrev-table &lt;/strong&gt;&lt;em&gt;abbrev-table&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="510e0d836cb736fdfbc94a7120108dbed5ba2f91" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;clear-image-cache&lt;/strong&gt;&lt;em&gt;&amp;amp;optional filter&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;명확한 이미지 캐시 &lt;/strong&gt;&lt;em&gt;및 옵션 필터&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1c77b6351969085039d88c7fc4d46a5178c1dd2d" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;clear-string&lt;/strong&gt;&lt;em&gt;string&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;명확한 문자열 &lt;/strong&gt;&lt;em&gt;문자열&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6a92634f360f3680b8fb3e5393f46f344d5d52d1" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;clear-this-command-keys&lt;/strong&gt;&lt;em&gt;&amp;amp;optional keep-record&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;이 명령 키 지우기 &lt;/strong&gt;&lt;em&gt;및 기록 유지 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4e9dd1050590e6addc4705a9bd7eb9df90342c18" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;clear-visited-file-modtime&lt;/strong&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;명확한 방문 파일 modtime&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f70e48348e40392e9abcb306f0be5781c3e11576" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;clrhash&lt;/strong&gt;&lt;em&gt;table&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;clrhash &lt;/strong&gt;&lt;em&gt;테이블&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8804c3c324daeb306700917ab50868f5b465a046" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;coding-system-aliases&lt;/strong&gt;&lt;em&gt;coding-system&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;코딩 시스템 별칭 &lt;/strong&gt;&lt;em&gt;코딩 시스템&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c1a39a870eddcfc28d4942774e92efc8b4a10bea" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;coding-system-change-eol-conversion&lt;/strong&gt;&lt;em&gt;coding-system eol-type&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;코딩 시스템 변경-올-변환 &lt;/strong&gt;&lt;em&gt;코딩-시스템 eol- 유형&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="82f31a8a0f8e7e788d29de18dc980e769f83d18a" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;coding-system-change-text-conversion&lt;/strong&gt;&lt;em&gt;eol-coding text-coding&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;코딩 시스템 변경 텍스트 변환 &lt;/strong&gt;&lt;em&gt;eol 코딩 텍스트 코딩&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6b7654eafa6d18c7d1ecfe3e4a54f1930473562c" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;coding-system-charset-list&lt;/strong&gt;&lt;em&gt;coding-system&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;코딩 시스템 문자셋 목록 &lt;/strong&gt;&lt;em&gt;코딩 시스템&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="39050a32add1c2bac04d9ec861e401892c6703af" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;coding-system-eol-type&lt;/strong&gt;&lt;em&gt;coding-system&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;코딩 시스템 얼형 &lt;/strong&gt;&lt;em&gt;코딩 시스템&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3af6b192767b0133fa9fcaf65e7308889037e7d9" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;coding-system-get&lt;/strong&gt;&lt;em&gt;coding-system property&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;coding-system-get &lt;/strong&gt;&lt;em&gt;coding-system 속성&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f21feb8d79eee772fbe4876d618a8d135c32ff28" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;coding-system-list&lt;/strong&gt;&lt;em&gt;&amp;amp;optional base-only&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;코딩 시스템 목록 &lt;/strong&gt;&lt;em&gt;및 옵션 기본 전용&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="007f2122b415f91848394d123fd820fddb095d69" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;coding-system-p&lt;/strong&gt;&lt;em&gt;object&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;코딩 시스템 p &lt;/strong&gt;&lt;em&gt;객체&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c77afd26a17ef925845d1adee2cb7c1b2a72aa0f" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;coding-system-priority-list&lt;/strong&gt;&lt;em&gt;&amp;amp;optional highestp&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;코딩 시스템 우선 순위 목록 &lt;/strong&gt;&lt;em&gt;및 선택 사항 최고&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7fa31a6eb99f0ec5fca182026aec3ed0183b02dd" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;color-defined-p&lt;/strong&gt;&lt;em&gt;color &amp;amp;optional frame&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;색상 정의 -p &lt;/strong&gt;&lt;em&gt;색상 및 옵션 프레임&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2c41a0d861ac96e508b0e6dd027c853ac61af998" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;color-gray-p&lt;/strong&gt;&lt;em&gt;color &amp;amp;optional frame&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;색상 회색 p &lt;/strong&gt;&lt;em&gt;색상 및 옵션 프레임&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="383d8f151d9c6e2fdf4eb766e8bf0af363ed57de" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;color-supported-p&lt;/strong&gt;&lt;em&gt;color &amp;amp;optional frame background-p&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;색상 지원 -p &lt;/strong&gt;&lt;em&gt;색상 및 옵션 프레임 배경 -p&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="eb8619c981a9f5fe568c8c16410b4fb8ad906fc5" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;color-values&lt;/strong&gt;&lt;em&gt;color &amp;amp;optional frame&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;색상 값 &lt;/strong&gt;&lt;em&gt;색상 및 옵션 프레임&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="93c8d5283a0ea48b5baf4802cc68ce67657d777b" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;combine-and-quote-strings&lt;/strong&gt;&lt;em&gt;list-of-strings &amp;amp;optional separator&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;결합 및 인용 문자열 문자열 &lt;/strong&gt;&lt;em&gt;목록 및 선택적 구분 기호&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d009ccf2578d55b4e4b3e24acab3b674978014c6" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;command-execute&lt;/strong&gt;&lt;em&gt;command &amp;amp;optional record-flag keys special&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;명령 실행 &lt;/strong&gt;&lt;em&gt;명령 및 옵션 레코드 플래그 키 특별&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5bcf8a07b4ff2a897699c39c949a6409512702a9" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;command-line&lt;/strong&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;명령 줄&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3ff87fadb9c25755ba3d36c9e1016fe1e035d12d" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;command-remapping&lt;/strong&gt;&lt;em&gt;command &amp;amp;optional position keymaps&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;명령 다시 매핑 &lt;/strong&gt;&lt;em&gt;명령 및 선택적 위치 키맵&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="63b31f007940028bcce0a08f659253a5120fffec" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;commandp&lt;/strong&gt;&lt;em&gt;object &amp;amp;optional for-call-interactively&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;commandp &lt;/strong&gt;&lt;em&gt;개체 및 선택적 for-call-interactively&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="510d7d51a6e89a973dc14422468e094eaedf968c" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;compare-buffer-substrings&lt;/strong&gt;&lt;em&gt;buffer1 start1 end1 buffer2 start2 end2&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;strong&gt;비교 버퍼 하위 문자열 &lt;/strong&gt;&lt;em&gt;buffer1 start1 end1 buffer2 start2 end2&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1b6173f21800b523f55448aebe48b82d8b22cbf0" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;compare-strings&lt;/strong&gt;&lt;em&gt;string1 start1 end1 string2 start2 end2 &amp;amp;optional ignore-case&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;문자열 비교 &lt;/strong&gt;&lt;em&gt;string1 start1 end1 string2 start2 end2 &amp;amp; optional ignore-case&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6dc4c1c1c5f1cf83d3b13d266d00d135565de254" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;compare-window-configurations&lt;/strong&gt;&lt;em&gt;config1 config2&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;비교 창 구성 &lt;/strong&gt;&lt;em&gt;config1 config2&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a0cf9fedd16b4129623a54b829a6c002f5980549" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;completing-read&lt;/strong&gt;&lt;em&gt;prompt collection &amp;amp;optional predicate require-match initial history default inherit-input-method&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;완료 읽기 &lt;/strong&gt;&lt;em&gt;프롬프트 수집 및 선택적 술어 요구 일치 초기 기록 기본 상속 입력 방법&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2129decdf67dc031053e8a71f391381ee473af4f" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;completion-boundaries&lt;/strong&gt;&lt;em&gt;string collection predicate suffix&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;strong&gt;완료 경계 &lt;/strong&gt;&lt;em&gt;문자열 콜렉션 술어 접미사&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="08d5e7d770839a0dbe79925dde4a6a49b953f67b" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;completion-in-region&lt;/strong&gt;&lt;em&gt;start end collection &amp;amp;optional predicate&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;지역 내 완료 &lt;/strong&gt;&lt;em&gt;시작 끝 수집 및 선택적 술어&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6b8ba41f6e31c78bbe14e0cfabbcb1c0ebaa5e77" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;completion-table-dynamic&lt;/strong&gt;&lt;em&gt;function &amp;amp;optional switch-buffer&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;완료 테이블 동적 &lt;/strong&gt;&lt;em&gt;기능 및 옵션 스위치 버퍼&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="39c868ffddcf76664f7de7242111e1918eeb3e6f" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;completion-table-with-cache&lt;/strong&gt;&lt;em&gt;function &amp;amp;optional ignore-case&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;캐시 &lt;/strong&gt;&lt;em&gt;기능이있는 &lt;/em&gt;&lt;strong&gt;완료 테이블 &lt;/strong&gt;&lt;em&gt;및 옵션 무시 케이스&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="41d3ad27e6f106d353942d0bbbbafdd2a1729570" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;compute-motion&lt;/strong&gt;&lt;em&gt;from frompos to topos width offsets window&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;em&gt;frompos에서 topos 너비 오프셋 창으로의 &lt;/em&gt;&lt;strong&gt;컴퓨팅 모션&lt;/strong&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d0ec4c3c3b5dd9a931c901db0c0de27c54c88e95" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;concat&lt;/strong&gt;&lt;em&gt;&amp;amp;rest sequences&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;strong&gt;연결 &lt;/strong&gt;&lt;em&gt;및 나머지 시퀀스&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5e7ece7c729afe9c73fcc33c835a6b92ac7f07ab" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;condition-mutex&lt;/strong&gt;&lt;em&gt;cond&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;strong&gt;condition-mutex &lt;/strong&gt;&lt;em&gt;cond&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3d89d8512d16f66078415a3a4cb543c3e4decbe6" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;condition-name&lt;/strong&gt;&lt;em&gt;cond&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;strong&gt;조건 이름 &lt;/strong&gt;&lt;em&gt;cond&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fe44c0c8569659d65c34234b7970cd329b801130" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;condition-notify&lt;/strong&gt;&lt;em&gt;cond &amp;amp;optional all&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;조건-통지 &lt;/strong&gt;&lt;em&gt;조건 및 옵션 모두&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ce35400508b6409e9e8108d55d433fe59956735a" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;condition-variable-p&lt;/strong&gt;&lt;em&gt;object&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;strong&gt;condition-variable-p &lt;/strong&gt;&lt;em&gt;객체&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d0d19927b8e21c4cb7947dc4bda9a62c92a00600" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;condition-wait&lt;/strong&gt;&lt;em&gt;cond&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;strong&gt;condition-wait &lt;/strong&gt;&lt;em&gt;cond&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="36512be769d3f34ad0369d23681de343c600f8c8" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;connection-local-set-profile-variables&lt;/strong&gt;&lt;em&gt;profile variables&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;connection-local-set-profile-variables &lt;/strong&gt;&lt;em&gt;프로필 변수&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fd5a0a1ac941b2c02354964ff7671be4ad8b7c62" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;connection-local-set-profiles&lt;/strong&gt;&lt;em&gt;criteria &amp;amp;rest profiles&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;연결 로컬 설정 프로필 &lt;/strong&gt;&lt;em&gt;기준 및 나머지 프로필&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="827ee66319f0fc56426e64a3250cf202da4da54f" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;cons&lt;/strong&gt;&lt;em&gt;object1 object2&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;strong&gt;단점 &lt;/strong&gt;&lt;em&gt;object1 object2&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9bd4149ba1de415f88c7767745a65ccd544a8142" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;consp&lt;/strong&gt;&lt;em&gt;object&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;strong&gt;consp &lt;/strong&gt;&lt;em&gt;개체&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dc978d1967d4905ba71e5d7faedb79b0ca5010f0" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;constrain-to-field&lt;/strong&gt;&lt;em&gt;new-pos old-pos &amp;amp;optional escape-from-edge only-in-line inhibit-capture-property&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;필드로 제한 &lt;/strong&gt;&lt;em&gt;new-pos old-pos &amp;amp; optional escape-from-edge only-in-line 금지 캡처 속성&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5161e78605a25c810f76bba1161723d912d1f341" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;continue-process&lt;/strong&gt;&lt;em&gt;&amp;amp;optional process current-group&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;계속 프로세스 &lt;/strong&gt;&lt;em&gt;및 옵션 프로세스 현재 그룹&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="66beb41618980a6b6bb7cffb5ee53d36cc1aa64c" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;controlling-tty-p&lt;/strong&gt;&lt;em&gt;&amp;amp;optional tty&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;제어 -tty-p &lt;/strong&gt;&lt;em&gt;및 선택적 tty&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d35524ae2027978f244f886ccdc5de018541aa96" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;convert-standard-filename&lt;/strong&gt;&lt;em&gt;filename&lt;/em&gt;</source>
          <target state="translated">함수 : &lt;strong&gt;표준 파일 &lt;/strong&gt;&lt;em&gt;이름 &lt;/em&gt;&lt;strong&gt;변환 파일 &lt;/strong&gt;&lt;em&gt;이름&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1b6f1526053f78c7107eb0eb92cab40b1cc36642" translate="yes" xml:space="preserve">
          <source>Function: &lt;strong&gt;coordinates-in-window-p&lt;/strong&gt;&lt;em&gt;coordinates window&lt;/em&gt;</source>
          <target state="translated">기능 : &lt;strong&gt;좌표 창 -p &lt;/strong&gt;&lt;em&gt;좌표 창&lt;/em&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
