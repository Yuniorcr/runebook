<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="elisp">
    <body>
      <group id="elisp">
        <trans-unit id="3571d6eb92f7d98e1c4eda2402213efe0e7ab52a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;&lt;var&gt;signal-description&lt;/var&gt; (core dumped)\n&quot;&lt;/code&gt;. The &lt;var&gt;signal-description&lt;/var&gt; is a system-dependent textual description of a signal, e.g., &lt;code&gt;&quot;killed&quot;&lt;/code&gt; for &lt;code&gt;SIGKILL&lt;/code&gt;. The &amp;ldquo;core dumped&amp;rdquo; part is optional, and only appears if the process dumped core.</source>
          <target state="translated">&lt;code&gt;&quot;&lt;var&gt;signal-description&lt;/var&gt; (core dumped)\n&quot;&lt;/code&gt; . &lt;var&gt;signal-description&lt;/var&gt; 예를 들어, 신호의 시스템에 의존하는 텍스트 설명입니다 &lt;code&gt;&quot;killed&quot;&lt;/code&gt; 에 대한 &lt;code&gt;SIGKILL&lt;/code&gt; . &quot;코어 덤프&quot;부분은 선택 사항이며 프로세스가 코어를 덤프 한 경우에만 나타납니다.</target>
        </trans-unit>
        <trans-unit id="21510b6b5c7cbab2e1be067295358d4792e4d65e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;connection broken by remote peer\n&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;connection broken by remote peer\n&quot;&lt;/code&gt; . \ n&quot; .</target>
        </trans-unit>
        <trans-unit id="9816d6ca400b6770ec7060208e3f151de8d707a8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;deleted\n&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;deleted\n&quot;&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="1c32b918f930d17e17d32954809a49631abaa8a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;exited abnormally with code &lt;var&gt;exitcode&lt;/var&gt; (core dumped)\n&quot;&lt;/code&gt;. The &amp;ldquo;core dumped&amp;rdquo; part is optional, and only appears if the process dumped core.</source>
          <target state="translated">&lt;code&gt;&quot;exited abnormally with code &lt;var&gt;exitcode&lt;/var&gt; (core dumped)\n&quot;&lt;/code&gt; . &quot;코어 덤프&quot;부분은 선택 사항이며 프로세스가 코어를 덤프 한 경우에만 나타납니다.</target>
        </trans-unit>
        <trans-unit id="0fd91ad9f72c086362a3597555e03163dbe8e5d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;failed with code &lt;var&gt;fail-code&lt;/var&gt;\n&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;failed with code &lt;var&gt;fail-code&lt;/var&gt;\n&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="452f3fbb5d5b06f71bcf670ee21189ba10aebe5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;finished\n&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;finished\n&quot;&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="8ce5578b61523c780393dc21e82f5fd6d5f2f0fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;open from &lt;var&gt;host-name&lt;/var&gt;\n&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;open from &lt;var&gt;host-name&lt;/var&gt;\n&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aaa2e8e855dbd08e0cfa22710f395245e053bd02" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;open\n&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;open\n&quot;&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="667e3d01a04fd5c5457e513a4050129a3a31ab13" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(add-function :after &lt;var&gt;funvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;)&lt;/code&gt; is comparable for single-function hooks to &lt;code&gt;(add-hook '&lt;var&gt;hookvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;
'append)&lt;/code&gt; for normal hooks.</source>
          <target state="translated">&lt;code&gt;(add-function :after &lt;var&gt;funvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;)&lt;/code&gt; 은 단일 기능 후크의 경우 일반 후크의 경우 &lt;code&gt;(add-hook '&lt;var&gt;hookvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt; 'append)&lt;/code&gt; 와 비슷 합니다 .</target>
        </trans-unit>
        <trans-unit id="e79f2e8727e321371b1128b55cf7222da89f4f69" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(add-function :after-until &lt;var&gt;funvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;)&lt;/code&gt; is comparable for single-function hooks to &lt;code&gt;(add-hook '&lt;var&gt;hookvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;
'append)&lt;/code&gt; when &lt;var&gt;hookvar&lt;/var&gt; is run via &lt;code&gt;run-hook-with-args-until-success&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;(add-function :after-until &lt;var&gt;funvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;)&lt;/code&gt; 은 &lt;var&gt;hookvar&lt;/var&gt; 가 &lt;code&gt;run-hook-with-args-until-success&lt;/code&gt; 를 통해 실행될 때 단일 기능 후크에 대해 &lt;code&gt;(add-hook '&lt;var&gt;hookvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt; 'append)&lt;/code&gt; 비슷 합니다.</target>
        </trans-unit>
        <trans-unit id="d1ada1c40c2fc461e47b0536ab0b0d83798556ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(add-function :after-while &lt;var&gt;funvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;)&lt;/code&gt; is comparable for single-function hooks to &lt;code&gt;(add-hook '&lt;var&gt;hookvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;
'append)&lt;/code&gt; when &lt;var&gt;hookvar&lt;/var&gt; is run via &lt;code&gt;run-hook-with-args-until-failure&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;(add-function :after-while &lt;var&gt;funvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;)&lt;/code&gt; 은 &lt;var&gt;hookvar&lt;/var&gt; 가 &lt;code&gt;run-hook-with-args-until-failure&lt;/code&gt; 를 통해 실행될 때 단일 기능 후크에 대해 &lt;code&gt;(add-hook '&lt;var&gt;hookvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt; 'append)&lt;/code&gt; 비슷 합니다.</target>
        </trans-unit>
        <trans-unit id="77fd36076dd83bbf47f8b99d3020b0d1a3a0c601" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(add-function :before &lt;var&gt;funvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;)&lt;/code&gt; is comparable for single-function hooks to &lt;code&gt;(add-hook '&lt;var&gt;hookvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;)&lt;/code&gt; for normal hooks.</source>
          <target state="translated">&lt;code&gt;(add-function :before &lt;var&gt;funvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;)&lt;/code&gt; 은 단일 기능 후크의 경우 일반 후크의 경우 &lt;code&gt;(add-hook '&lt;var&gt;hookvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;)&lt;/code&gt; 과 비슷 합니다 .</target>
        </trans-unit>
        <trans-unit id="30dada64dce8c2ce8801fc2baeb378ba25b722b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(add-function :before-until &lt;var&gt;funvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;)&lt;/code&gt; is comparable for single-function hooks to &lt;code&gt;(add-hook '&lt;var&gt;hookvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;)&lt;/code&gt; when &lt;var&gt;hookvar&lt;/var&gt; is run via &lt;code&gt;run-hook-with-args-until-success&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;(add-function :before-until &lt;var&gt;funvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;)&lt;/code&gt; 은 &lt;var&gt;hookvar&lt;/var&gt; 가 &lt;code&gt;run-hook-with-args-until-success&lt;/code&gt; 를 통해 실행될 때 단일 함수 후크에 대해 &lt;code&gt;(add-hook '&lt;var&gt;hookvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22c99938a4d009a4111676d43f22995cb86610e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(add-function :before-while &lt;var&gt;funvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;)&lt;/code&gt; is comparable for single-function hooks to &lt;code&gt;(add-hook '&lt;var&gt;hookvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;)&lt;/code&gt; when &lt;var&gt;hookvar&lt;/var&gt; is run via &lt;code&gt;run-hook-with-args-until-failure&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;(add-function :before-while &lt;var&gt;funvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;)&lt;/code&gt; 은 &lt;var&gt;hookvar&lt;/var&gt; 가 &lt;code&gt;run-hook-with-args-until-failure&lt;/code&gt; 를 통해 실행될 때 단일 함수 후크에 대해 &lt;code&gt;(add-hook '&lt;var&gt;hookvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5c6252a7ccf0c052151b4b73d200cde8cab47324" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(column . &lt;var&gt;column&lt;/var&gt;)&lt;/code&gt;: indent to column &lt;var&gt;column&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;(column . &lt;var&gt;column&lt;/var&gt;)&lt;/code&gt; : 열 &lt;var&gt;column&lt;/var&gt; 들여 쓰기 .</target>
        </trans-unit>
        <trans-unit id="bd05cccba28e6261f59cbfbe25751f0d1d3ec26e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(zerop x)&lt;/code&gt; is equivalent to &lt;code&gt;(= x 0)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;(zerop x)&lt;/code&gt; 는 &lt;code&gt;(= x 0)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8a39a0d34aa08d1f39b0ffda4c8edaa99d08f6ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0&lt;/code&gt; means operate on all visible or iconified frames.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; 은 표시되거나 아이콘 화 된 모든 프레임에서 작동 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="4dc6a4b0544f7e10c0aac111768586f7e59a5bf1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;2C-mode-map&lt;/code&gt; is the global keymap used for the</source>
          <target state="translated">&lt;code&gt;2C-mode-map&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="ff17a4d55b54932f733d4df35f4351fe75f50056" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:after&lt;/code&gt;, in which case &lt;var&gt;arg&lt;/var&gt; is a token and the function should return the &lt;var&gt;offset&lt;/var&gt; to use for indentation after &lt;var&gt;arg&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;:after&lt;/code&gt; ,이 경우 &lt;var&gt;arg&lt;/var&gt; 는 토큰이고 함수는 &lt;var&gt;arg&lt;/var&gt; 뒤에 들여 쓰기에 사용할 &lt;var&gt;offset&lt;/var&gt; 을 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="745c148e949b23754d925fc97e53ee25ac2e7fc4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:backward-token&lt;/code&gt;&lt;var&gt;fun&lt;/var&gt;: Specify the backward lexer to use.</source>
          <target state="translated">&lt;code&gt;:backward-token&lt;/code&gt; &lt;var&gt;fun&lt;/var&gt; : 사용할 역방향 어휘 분석기를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="09bf88985b0025e5ce963894bae66add561883e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:before&lt;/code&gt;, in which case &lt;var&gt;arg&lt;/var&gt; is a token and the function should return the &lt;var&gt;offset&lt;/var&gt; to use to indent &lt;var&gt;arg&lt;/var&gt; itself.</source>
          <target state="translated">&lt;code&gt;:before&lt;/code&gt; ,이 경우 &lt;var&gt;arg&lt;/var&gt; 는 토큰이고 함수는 &lt;var&gt;arg&lt;/var&gt; 자체 를 들여 쓰는 데 사용할 &lt;var&gt;offset&lt;/var&gt; 을 반환해야 합니다.</target>
        </trans-unit>
        <trans-unit id="4a6b6bc5821f2cf42d0e5e833804de89ab8123e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:elem&lt;/code&gt;, in which case the function should return either the offset to use to indent function arguments (if &lt;var&gt;arg&lt;/var&gt; is the symbol &lt;code&gt;arg&lt;/code&gt;) or the basic indentation step (if &lt;var&gt;arg&lt;/var&gt; is the symbol &lt;code&gt;basic&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;:elem&lt;/code&gt; ,이 경우 함수는 함수 인수를 들여 쓰는 데 사용할 오프셋 ( &lt;var&gt;arg&lt;/var&gt; 이 기호 &lt;code&gt;arg&lt;/code&gt; 인 경우 ) 또는 기본 들여 쓰기 단계 ( &lt;var&gt;arg&lt;/var&gt; 가 기호 &lt;code&gt;basic&lt;/code&gt; 경우)를 반환해야 합니다.</target>
        </trans-unit>
        <trans-unit id="66ff7dd6575d51f021e1583cc2aa0383d29e79db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:forward-token&lt;/code&gt;&lt;var&gt;fun&lt;/var&gt;: Specify the forward lexer to use.</source>
          <target state="translated">&lt;code&gt;:forward-token&lt;/code&gt; &lt;var&gt;fun&lt;/var&gt; : 사용할 포워드 어휘 분석기를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="60b5e4ffa4ea98bbfb035262b0942a24c34df7a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:list-intro&lt;/code&gt;, in which case &lt;var&gt;arg&lt;/var&gt; is a token and the function should return non-&lt;code&gt;nil&lt;/code&gt; if the token is followed by a list of expressions (not separated by any token) rather than an expression.</source>
          <target state="translated">&lt;code&gt;:list-intro&lt;/code&gt; ,이 경우 &lt;var&gt;arg&lt;/var&gt; 는 토큰이고 토큰 뒤에 표현식이 아닌 표현식 목록 (토큰으로 구분되지 않음)이 오는 경우 함수는 &lt;code&gt;nil&lt;/code&gt; 이 아닌 값을 반환해야 합니다.</target>
        </trans-unit>
        <trans-unit id="de4ff782e72efa54bfa512b55e8172fc1b21044d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:local&lt;/code&gt; and &lt;code&gt;:remote&lt;/code&gt; are included even if they were not specified explicitly in &lt;code&gt;make-network-process&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:local&lt;/code&gt; 및 &lt;code&gt;:remote&lt;/code&gt; 는 &lt;code&gt;make-network-process&lt;/code&gt; 에 명시 적으로 지정되지 않은 경우에도 포함 됩니다 .</target>
        </trans-unit>
        <trans-unit id="93d4cc5172b5a539cd9385caf51a90816a586e54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:tag&lt;/code&gt; is often used with &lt;code&gt;const&lt;/code&gt;, inside of &lt;code&gt;choice&lt;/code&gt;. For example,</source>
          <target state="translated">&lt;code&gt;:tag&lt;/code&gt; 자주 사용되는 &lt;code&gt;const&lt;/code&gt; 를 , 내부 &lt;code&gt;choice&lt;/code&gt; . 예를 들면</target>
        </trans-unit>
        <trans-unit id="d8d5cc8815e0bd9596f7142348a8519bc72bc958" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;access-file&lt;/code&gt;, &lt;code&gt;add-name-to-file&lt;/code&gt;, &lt;code&gt;byte-compiler-base-file-name&lt;/code&gt;, &lt;code&gt;copy-directory&lt;/code&gt;, &lt;code&gt;copy-file&lt;/code&gt;, &lt;code&gt;delete-directory&lt;/code&gt;, &lt;code&gt;delete-file&lt;/code&gt;, &lt;code&gt;diff-latest-backup-file&lt;/code&gt;, &lt;code&gt;directory-file-name&lt;/code&gt;, &lt;code&gt;directory-files&lt;/code&gt;, &lt;code&gt;directory-files-and-attributes&lt;/code&gt;, &lt;code&gt;dired-compress-file&lt;/code&gt;, &lt;code&gt;dired-uncache&lt;/code&gt;, &lt;code&gt;exec-path&lt;/code&gt;, &lt;code&gt;expand-file-name&lt;/code&gt;, &lt;code&gt;file-accessible-directory-p&lt;/code&gt;, &lt;code&gt;file-acl&lt;/code&gt;, &lt;code&gt;file-attributes&lt;/code&gt;, &lt;code&gt;file-directory-p&lt;/code&gt;, &lt;code&gt;file-equal-p&lt;/code&gt;, &lt;code&gt;file-executable-p&lt;/code&gt;, &lt;code&gt;file-exists-p&lt;/code&gt;, &lt;code&gt;file-in-directory-p&lt;/code&gt;, &lt;code&gt;file-local-copy&lt;/code&gt;, &lt;code&gt;file-modes&lt;/code&gt;, &lt;code&gt;file-name-all-completions&lt;/code&gt;, &lt;code&gt;file-name-as-directory&lt;/code&gt;, &lt;code&gt;file-name-case-insensitive-p&lt;/code&gt;, &lt;code&gt;file-name-completion&lt;/code&gt;, &lt;code&gt;file-name-directory&lt;/code&gt;, &lt;code&gt;file-name-nondirectory&lt;/code&gt;, &lt;code&gt;file-name-sans-versions&lt;/code&gt;, &lt;code&gt;file-newer-than-file-p&lt;/code&gt;, &lt;code&gt;file-notify-add-watch&lt;/code&gt;, &lt;code&gt;file-notify-rm-watch&lt;/code&gt;, &lt;code&gt;file-notify-valid-p&lt;/code&gt;, &lt;code&gt;file-ownership-preserved-p&lt;/code&gt;, &lt;code&gt;file-readable-p&lt;/code&gt;, &lt;code&gt;file-regular-p&lt;/code&gt;, &lt;code&gt;file-remote-p&lt;/code&gt;, &lt;code&gt;file-selinux-context&lt;/code&gt;, &lt;code&gt;file-symlink-p&lt;/code&gt;, &lt;code&gt;file-system-info&lt;/code&gt;, &lt;code&gt;file-truename&lt;/code&gt;, &lt;code&gt;file-writable-p&lt;/code&gt;, &lt;code&gt;find-backup-file-name&lt;/code&gt;, &lt;code&gt;get-file-buffer&lt;/code&gt;, &lt;code&gt;insert-directory&lt;/code&gt;, &lt;code&gt;insert-file-contents&lt;/code&gt;, &lt;code&gt;load&lt;/code&gt;, &lt;code&gt;make-auto-save-file-name&lt;/code&gt;, &lt;code&gt;make-directory&lt;/code&gt;, &lt;code&gt;make-directory-internal&lt;/code&gt;, &lt;code&gt;make-nearby-temp-file&lt;/code&gt;, &lt;code&gt;make-process&lt;/code&gt;, &lt;code&gt;make-symbolic-link&lt;/code&gt;, &lt;code&gt;process-file&lt;/code&gt;, &lt;code&gt;rename-file&lt;/code&gt;, &lt;code&gt;set-file-acl&lt;/code&gt;, &lt;code&gt;set-file-modes&lt;/code&gt;, &lt;code&gt;set-file-selinux-context&lt;/code&gt;, &lt;code&gt;set-file-times&lt;/code&gt;, &lt;code&gt;set-visited-file-modtime&lt;/code&gt;, &lt;code&gt;shell-command&lt;/code&gt;, &lt;code&gt;start-file-process&lt;/code&gt;, &lt;code&gt;substitute-in-file-name&lt;/code&gt;, &lt;code&gt;temporary-file-directory&lt;/code&gt;, &lt;code&gt;unhandled-file-name-directory&lt;/code&gt;, &lt;code&gt;vc-registered&lt;/code&gt;, &lt;code&gt;verify-visited-file-modtime&lt;/code&gt;, &lt;code&gt;write-region&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;access-file&lt;/code&gt; , &lt;code&gt;add-name-to-file&lt;/code&gt; , &lt;code&gt;byte-compiler-base-file-name&lt;/code&gt; , &lt;code&gt;copy-directory&lt;/code&gt; , &lt;code&gt;copy-file&lt;/code&gt; , &lt;code&gt;delete-directory&lt;/code&gt; , &lt;code&gt;delete-file&lt;/code&gt; , &lt;code&gt;diff-latest-backup-file&lt;/code&gt; , &lt;code&gt;directory-file-name&lt;/code&gt; , &lt;code&gt;directory-files&lt;/code&gt; , &lt;code&gt;directory-files-and-attributes&lt;/code&gt; , &lt;code&gt;dired-compress-file&lt;/code&gt; , &lt;code&gt;dired-uncache&lt;/code&gt; , &lt;code&gt;exec-path&lt;/code&gt; , &lt;code&gt;expand-file-name&lt;/code&gt; , &lt;code&gt;file-accessible-directory-p&lt;/code&gt; , &lt;code&gt;file-acl&lt;/code&gt; , &lt;code&gt;file-attributes&lt;/code&gt; , &lt;code&gt;file-directory-p&lt;/code&gt; , &lt;code&gt;file-equal-p&lt;/code&gt; , &lt;code&gt;file-executable-p&lt;/code&gt; , &lt;code&gt;file-exists-p&lt;/code&gt; , &lt;code&gt;file-in-directory-p&lt;/code&gt; , &lt;code&gt;file-local-copy&lt;/code&gt; , &lt;code&gt;file-modes&lt;/code&gt; , &lt;code&gt;file-name-all-completions&lt;/code&gt; , &lt;code&gt;file-name-as-directory&lt;/code&gt; , &lt;code&gt;file-name-case-insensitive-p&lt;/code&gt; , &lt;code&gt;file-name-completion&lt;/code&gt; , &lt;code&gt;file-name-directory&lt;/code&gt; , &lt;code&gt;file-name-nondirectory&lt;/code&gt; , &lt;code&gt;file-name-sans-versions&lt;/code&gt; , &lt;code&gt;file-newer-than-file-p&lt;/code&gt; , &lt;code&gt;file-notify-add-watch&lt;/code&gt; , &lt;code&gt;file-notify-rm-watch&lt;/code&gt; , &lt;code&gt;file-notify-valid-p&lt;/code&gt; , &lt;code&gt;file-ownership-preserved-p&lt;/code&gt; , &lt;code&gt;file-readable-p&lt;/code&gt; , &lt;code&gt;file-regular-p&lt;/code&gt; , &lt;code&gt;file-remote-p&lt;/code&gt; , &lt;code&gt;file-selinux-context&lt;/code&gt; , &lt;code&gt;file-symlink-p&lt;/code&gt; , &lt;code&gt;file-system-info&lt;/code&gt; , &lt;code&gt;file-truename&lt;/code&gt; , &lt;code&gt;file-writable-p&lt;/code&gt; , &lt;code&gt;find-backup-file-name&lt;/code&gt; , &lt;code&gt;get-file-buffer&lt;/code&gt; , &lt;code&gt;insert-directory&lt;/code&gt; , &lt;code&gt;insert-file-contents&lt;/code&gt; , &lt;code&gt;load&lt;/code&gt; , &lt;code&gt;make-auto-save-file-name&lt;/code&gt; , &lt;code&gt;make-directory&lt;/code&gt; , &lt;code&gt;make-directory-internal&lt;/code&gt; , &lt;code&gt;make-nearby-temp-file&lt;/code&gt; , &lt;code&gt;make-process&lt;/code&gt; , &lt;code&gt;make-symbolic-link&lt;/code&gt; , &lt;code&gt;process-file&lt;/code&gt; , &lt;code&gt;rename-file&lt;/code&gt; , &lt;code&gt;set-file-acl&lt;/code&gt; , &lt;code&gt;set-file-modes&lt;/code&gt; , &lt;code&gt;set-file-selinux-context&lt;/code&gt; , &lt;code&gt;set-file-times&lt;/code&gt; , &lt;code&gt;set-visited-file-modtime&lt;/code&gt; , &lt;code&gt;shell-command&lt;/code&gt; , &lt;code&gt;start-file-process&lt;/code&gt; , &lt;code&gt;substitute-in-file-name&lt;/code&gt; , &lt;code&gt;temporary-file-directory&lt;/code&gt; , &lt;code&gt;unhandled-file-name-directory&lt;/code&gt; , &lt;code&gt;vc-registered&lt;/code&gt; , &lt;code&gt;verify-visited-file-modtime&lt;/code&gt; , &lt;code&gt;write-region&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a910d2cabd88a287657c3675086df2e12c75bb5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;add-hook&lt;/code&gt; can handle the cases where &lt;var&gt;hook&lt;/var&gt; is void or its value is a single function; it sets or changes the value to a list of functions.</source>
          <target state="translated">&lt;code&gt;add-hook&lt;/code&gt; 은 &lt;var&gt;hook&lt;/var&gt; 가 void이거나 그 값이 단일 함수 인 경우를 처리 할 수 ​​있습니다 . 함수 목록에 값을 설정하거나 변경합니다.</target>
        </trans-unit>
        <trans-unit id="e338fdebb37360438c44e0ef1f0938e510dc62c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;advice-add&lt;/code&gt; can be useful for altering the behavior of existing calls to an existing function without having to redefine the whole function. However, it can be a source of bugs, since existing callers to the function may assume the old behavior, and work incorrectly when the behavior is changed by advice. Advice can also cause confusion in debugging, if the person doing the debugging does not notice or remember that the function has been modified by advice.</source>
          <target state="translated">&lt;code&gt;advice-add&lt;/code&gt; 는 전체 함수를 재정의 할 필요없이 기존 함수에 대한 기존 호출의 동작을 변경하는 데 유용 할 수 있습니다. 그러나 함수에 대한 기존 호출자가 이전 동작을 가정하고 조언에 의해 동작이 변경 될 때 잘못 작동 할 수 있으므로 버그의 원인이 될 수 있습니다. 조언은 또한 디버깅을 수행하는 사람이 조언에 의해 함수가 수정되었음을 알아 차 리거나 기억하지 못하는 경우 디버깅에 혼란을 일으킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b5bc6aebbe4d1ec5567b21d8b250c6288b5aa13" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;alnum&lt;/code&gt;, &lt;code&gt;alphanumeric&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;alnum&lt;/code&gt; , &lt;code&gt;alphanumeric&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="55e0ebe110df9b523af8588d07de74b48311387b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;alpha&lt;/code&gt;, &lt;code&gt;alphabetic&lt;/code&gt;, &lt;code&gt;letter&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;alpha&lt;/code&gt; , &lt;code&gt;alphabetic&lt;/code&gt; , &lt;code&gt;letter&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="258b77970c969f1cf29cda319c3a2f76f3ca3d03" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;and&lt;/code&gt; expressions can also be written using either &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;cond&lt;/code&gt;. Here&amp;rsquo;s how:</source>
          <target state="translated">&lt;code&gt;and&lt;/code&gt; 표현식은 &lt;code&gt;if&lt;/code&gt; 또는 &lt;code&gt;cond&lt;/code&gt; 를 사용하여 작성할 수도 있습니다 . 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5c8ce8061acb49230ba8a01fbdf7ed67c9a03473" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, &lt;code&gt;not&lt;/code&gt;, and friends.</source>
          <target state="translated">&lt;code&gt;and&lt;/code&gt; , &lt;code&gt;or&lt;/code&gt; , &lt;code&gt;not&lt;/code&gt; 및 친구.</target>
        </trans-unit>
        <trans-unit id="6cbffc1a87a05c66112554e09bc35c04c5fa36de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;anychar&lt;/code&gt;, &lt;code&gt;anything&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;anychar&lt;/code&gt; , &lt;code&gt;anything&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ee4e624b640721bf440e6348f13fadce71c3902a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;apply&lt;/code&gt; calls &lt;var&gt;function&lt;/var&gt; with &lt;var&gt;arguments&lt;/var&gt;, just like &lt;code&gt;funcall&lt;/code&gt; but with one difference: the last of &lt;var&gt;arguments&lt;/var&gt; is a list of objects, which are passed to &lt;var&gt;function&lt;/var&gt; as separate arguments, rather than a single list. We say that &lt;code&gt;apply&lt;/code&gt;&lt;em&gt;spreads&lt;/em&gt; this list so that each individual element becomes an argument.</source>
          <target state="translated">&lt;code&gt;apply&lt;/code&gt; calls &lt;var&gt;function&lt;/var&gt; with &lt;var&gt;arguments&lt;/var&gt; , &lt;code&gt;funcall&lt;/code&gt; 과 비슷 하지만 한 가지 차이점이 있습니다. 마지막 &lt;var&gt;arguments&lt;/var&gt; 는 단일 목록이 아닌 별도의 인수 로 &lt;var&gt;function&lt;/var&gt; 전달되는 객체 목록입니다. &lt;code&gt;apply&lt;/code&gt; 는 이 목록을 &lt;em&gt;펼쳐서&lt;/em&gt; 각 개별 요소가 인수가된다고 말합니다.</target>
        </trans-unit>
        <trans-unit id="c9856e4d3686dbca6454b1252a811ab995dd7923" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;apply&lt;/code&gt; returns the result of calling &lt;var&gt;function&lt;/var&gt;. As with &lt;code&gt;funcall&lt;/code&gt;, &lt;var&gt;function&lt;/var&gt; must either be a Lisp function or a primitive function; special forms and macros do not make sense in &lt;code&gt;apply&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;apply&lt;/code&gt; 는 &lt;var&gt;function&lt;/var&gt; 호출의 결과를 반환합니다 . 와 같이 &lt;code&gt;funcall&lt;/code&gt; , &lt;var&gt;function&lt;/var&gt; 하나 리스프 함수 또는 원시 함수이어야; 특수한 형식과 매크로는 &lt;code&gt;apply&lt;/code&gt; 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="543192ce173130f8e60f6356c2436ff81754276f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ash&lt;/code&gt; (&lt;em&gt;arithmetic shift&lt;/em&gt;) shifts the bits in &lt;var&gt;integer1&lt;/var&gt; to the left &lt;var&gt;count&lt;/var&gt; places, or to the right if &lt;var&gt;count&lt;/var&gt; is negative. Left shifts introduce zero bits on the right; right shifts discard the rightmost bits. Considered as an integer operation, &lt;code&gt;ash&lt;/code&gt; multiplies &lt;var&gt;integer1&lt;/var&gt; by 2**&lt;var&gt;count&lt;/var&gt;, and then converts the result to an integer by rounding downward, toward minus infinity.</source>
          <target state="translated">&lt;code&gt;ash&lt;/code&gt; ( &lt;em&gt;산술 시프트&lt;/em&gt; )는 &lt;var&gt;integer1&lt;/var&gt; 의 비트를 왼쪽 &lt;var&gt;count&lt;/var&gt; 자리로 이동하거나 &lt;var&gt;count&lt;/var&gt; 가 음수 이면 오른쪽으로 이동합니다 . 왼쪽 시프트는 오른쪽에 0 비트를 도입합니다. 오른쪽 시프트는 가장 오른쪽 비트를 버립니다. 정수 연산으로 간주되는 &lt;code&gt;ash&lt;/code&gt; 는 &lt;var&gt;integer1&lt;/var&gt; 에 2 ** &lt;var&gt;count&lt;/var&gt; 를 곱한 다음 마이너스 무한대쪽으로 반올림하여 결과를 정수로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="968029e28d94f9920ac5b9f8216de27a4a72f17e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autoload&lt;/code&gt; is also effectively &lt;code&gt;eval-and-compile&lt;/code&gt; too. It&amp;rsquo;s recognized when compiling, so uses of such a function don&amp;rsquo;t produce &amp;ldquo;not known to be defined&amp;rdquo; warnings.</source>
          <target state="translated">&lt;code&gt;autoload&lt;/code&gt; 는 또한 효과적으로 &lt;code&gt;eval-and-compile&lt;/code&gt; 됩니다. 컴파일 할 때 인식되므로 이러한 함수를 사용하면 &quot;정의되지 않은 것으로 알려지지 않음&quot;경고가 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="915ee42daeea60e842ed1dda4a1dd9b72a50f128" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;backspace&lt;/code&gt;, &lt;code&gt;tab&lt;/code&gt;, &lt;code&gt;newline&lt;/code&gt;, &lt;code&gt;return&lt;/code&gt;, &lt;code&gt;delete&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;backspace&lt;/code&gt; , &lt;code&gt;tab&lt;/code&gt; , &lt;code&gt;newline&lt;/code&gt; , &lt;code&gt;return&lt;/code&gt; , &lt;code&gt;delete&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="946f496fb049245538cd4cc7ba5132c40e505caf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bottom-left-angle&lt;/code&gt;, &lt;code&gt;bottom-right-angle&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;bottom-left-angle&lt;/code&gt; , &lt;code&gt;bottom-right-angle&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a4c30ff3b0a0eb9c8d6a6aa28cdb76515efbcb0d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer-file-coding-system&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; affect sending text to a subprocess.</source>
          <target state="translated">&lt;code&gt;buffer-file-coding-system&lt;/code&gt; 은 텍스트를 하위 프로세스로 보내는 데 영향을 주지 &lt;em&gt;않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="107c725c617b4da70945aecf0c2954c9beb9b006" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;catch&lt;/code&gt; establishes a return point for the &lt;code&gt;throw&lt;/code&gt; function. The return point is distinguished from other such return points by &lt;var&gt;tag&lt;/var&gt;, which may be any Lisp object except &lt;code&gt;nil&lt;/code&gt;. The argument &lt;var&gt;tag&lt;/var&gt; is evaluated normally before the return point is established.</source>
          <target state="translated">&lt;code&gt;catch&lt;/code&gt; 는 &lt;code&gt;throw&lt;/code&gt; 함수 의 반환 지점을 설정 합니다. 리턴 포인트는 &lt;var&gt;tag&lt;/var&gt; 로 다른 리턴 포인트와 구별되며 &lt;code&gt;nil&lt;/code&gt; 을 제외한 모든 Lisp 객체 일 수 있습니다 . 인수 &lt;var&gt;tag&lt;/var&gt; 는 반환 지점이 설정되기 전에 정상적으로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="156ce65ca7942c7ecfd976b8e12a4e9225a1417d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;close-notification&lt;/code&gt; if the notification was closed by a call to &lt;code&gt;notifications-close-notification&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;close-notification&lt;/code&gt; 호출에 의해 알림이 닫힌 경우 &lt;code&gt;notifications-close-notification&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="344540fc9932e2a7fe71c70a031687cce00941a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cntrl&lt;/code&gt;, &lt;code&gt;control&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;cntrl&lt;/code&gt; , &lt;code&gt;control&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3abbbe55e10afc6f9cf312b234ef5f28aa43d773" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;compile-defun&lt;/code&gt; normally displays the result of evaluation in the echo area, but if &lt;var&gt;arg&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it inserts the result in the current buffer after the form it has compiled.</source>
          <target state="translated">&lt;code&gt;compile-defun&lt;/code&gt; 은 일반적으로 에코 영역에 평가 결과를 표시하지만, &lt;var&gt;arg&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 컴파일 된 형식 뒤에 결과를 현재 버퍼에 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="0f9e94627d25b926f591b1e1c255e6cd7722db03" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;completing-read&lt;/code&gt; uses this value as the local keymap when an exact match of one of the completions is not required. By default, this keymap makes the following bindings:</source>
          <target state="translated">&lt;code&gt;completing-read&lt;/code&gt; 는 완료 중 하나와 정확히 일치하지 않아도되는 경우이 값을 로컬 키맵으로 사용합니다. 기본적으로이 키맵은 다음 바인딩을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="74ad6806c122f9cb293d13928c1c9f99fd4f37a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;completing-read&lt;/code&gt; uses this value as the local keymap when an exact match of one of the completions is required. Therefore, no keys are bound to &lt;code&gt;exit-minibuffer&lt;/code&gt;, the command that exits the minibuffer unconditionally. By default, this keymap makes the following bindings:</source>
          <target state="translated">&lt;code&gt;completing-read&lt;/code&gt; 는 완료 중 하나와 정확히 일치해야하는 경우이 값을 로컬 키맵으로 사용합니다. 따라서 미니 버퍼를 무조건 종료하는 명령 인 &lt;code&gt;exit-minibuffer&lt;/code&gt; 에 바인딩 된 키가 없습니다 . 기본적으로이 키맵은 다음 바인딩을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c2ce8658f4068cd02c2cf6c073921a3359734353" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cond&lt;/code&gt; chooses among an arbitrary number of alternatives. Each &lt;var&gt;clause&lt;/var&gt; in the &lt;code&gt;cond&lt;/code&gt; must be a list. The &lt;small&gt;CAR&lt;/small&gt; of this list is the &lt;var&gt;condition&lt;/var&gt;; the remaining elements, if any, the &lt;var&gt;body-forms&lt;/var&gt;. Thus, a clause looks like this:</source>
          <target state="translated">&lt;code&gt;cond&lt;/code&gt; 는 임의의 수의 대안 중에서 선택합니다. &lt;code&gt;cond&lt;/code&gt; 의 각 &lt;var&gt;clause&lt;/var&gt; 은 목록이어야합니다. 이 목록 의 &lt;small&gt;CAR&lt;/small&gt; 은 &lt;var&gt;condition&lt;/var&gt; . 나머지 요소 (있는 경우)는 &lt;var&gt;body-forms&lt;/var&gt; . 따라서 절은 다음과 같습니다.&lt;small&gt;&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="d86b25e6a88950288688d5cde9d105628656c282" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cond&lt;/code&gt; tries the clauses in textual order, by evaluating the &lt;var&gt;condition&lt;/var&gt; of each clause. If the value of &lt;var&gt;condition&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the clause succeeds; then &lt;code&gt;cond&lt;/code&gt; evaluates its &lt;var&gt;body-forms&lt;/var&gt;, and returns the value of the last of &lt;var&gt;body-forms&lt;/var&gt;. Any remaining clauses are ignored.</source>
          <target state="translated">&lt;code&gt;cond&lt;/code&gt; 는 각 절의 &lt;var&gt;condition&lt;/var&gt; 을 평가하여 텍스트 순서로 절을 시도합니다 . &lt;var&gt;condition&lt;/var&gt; 의 값이 &lt;code&gt;nil&lt;/code&gt; 이 아니면 절이 성공합니다. 다음 &lt;code&gt;cond&lt;/code&gt; 의 평가 &lt;var&gt;body-forms&lt;/var&gt; , 그리고 마지막의 값 반환 &lt;var&gt;body-forms&lt;/var&gt; . 나머지 절은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="fdb0af8dfd8be2e8ae3cbfe120787af9b87bf7b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;condition-case&lt;/code&gt; (see &lt;a href=&quot;errors#Errors&quot;&gt;Errors&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;condition-case&lt;/code&gt; ( &lt;a href=&quot;errors#Errors&quot;&gt;오류&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="a6580f4efb6d6c9f789a125e8465845469547a7d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;condition-notify&lt;/code&gt; releases the associated mutex while waiting. This allows other threads to acquire the mutex in order to wait on the condition.</source>
          <target state="translated">&lt;code&gt;condition-notify&lt;/code&gt; 는 기다리는 동안 연관된 뮤텍스를 해제합니다. 이렇게하면 다른 스레드가 조건을 기다리기 위해 뮤텍스를 획득 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8437ca185db531b06367cb4346d8260607338a2e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;condition-wait&lt;/code&gt; releases the associated mutex while waiting. This allows other threads to acquire the mutex in order to notify the condition.</source>
          <target state="translated">&lt;code&gt;condition-wait&lt;/code&gt; 는 기다리는 동안 연관된 뮤텍스를 해제합니다. 이를 통해 다른 스레드는 조건을 알리기 위해 뮤텍스를 획득 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccd4e34801f17b7a3fc04d72bc18102aa79bedcb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cons&lt;/code&gt; is often used to add a single element to the front of a list. This is called &lt;em&gt;consing the element onto the list&lt;/em&gt;. &lt;a href=&quot;#FOOT4&quot; name=&quot;DOCF4&quot;&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt; For example:</source>
          <target state="translated">&lt;code&gt;cons&lt;/code&gt; 는 종종 목록 앞에 단일 요소를 추가하는 데 사용됩니다. 이것은 &lt;em&gt;요소를 목록에 포함시키는 것&lt;/em&gt; 입니다. &lt;a href=&quot;#FOOT4&quot; name=&quot;DOCF4&quot;&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt; 예 :</target>
        </trans-unit>
        <trans-unit id="b38a6ad2ed893ce1ea657ffbd022f9f0ab0a4705" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ctl-x-4-map&lt;/code&gt; is the global keymap used for the</source>
          <target state="translated">&lt;code&gt;ctl-x-4-map&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="036bac0feee09c67b7f81e2405656a5bd88c0a36" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ctl-x-5-map&lt;/code&gt; is the global keymap used for the</source>
          <target state="translated">&lt;code&gt;ctl-x-5-map&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="645c950388b00cd4f5f82802b0b36167e7f5cab9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ctl-x-map&lt;/code&gt; is the global keymap used for the</source>
          <target state="translated">&lt;code&gt;ctl-x-map&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="bc2d1647b4cc96f41ed5000b4f82d722e0eedffe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;current-local-map&lt;/code&gt; returns a reference to the local keymap, not a copy of it; if you use &lt;code&gt;define-key&lt;/code&gt; or other functions on it you will alter local bindings.</source>
          <target state="translated">&lt;code&gt;current-local-map&lt;/code&gt; 은 복사본이 아닌 로컬 키맵에 대한 참조를 반환합니다. &lt;code&gt;define-key&lt;/code&gt; 또는 기타 기능 을 사용 하는 경우 로컬 바인딩을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="51c9fd0ac637d6e499a4fa7b3f7d1d6a62ef6a86" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cursor-in-echo-area&lt;/code&gt; is locally bound to &lt;code&gt;nil&lt;/code&gt; so that the cursor shows up in the window.</source>
          <target state="translated">&lt;code&gt;cursor-in-echo-area&lt;/code&gt; 는 로컬로 &lt;code&gt;nil&lt;/code&gt; 에 바인딩되어 커서가 창에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="dde4dbb3472d8335edeac01bd24bdb83e60b9415" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;data-directory&lt;/code&gt;/images</source>
          <target state="translated">&lt;code&gt;data-directory&lt;/code&gt;/images</target>
        </trans-unit>
        <trans-unit id="934a2252e658e61b0e8e140170bcdaf3db4fe9a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;debug&lt;/code&gt; as first argument means &lt;code&gt;debug&lt;/code&gt; was called because of entry to a function that was set to debug on entry. The debugger displays the string &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;debug&lt;/code&gt; 첫 번째 인수 수단의 같은 &lt;code&gt;debug&lt;/code&gt; 때문에 항목을 디버그로 설정하는 기능에 대한 항목의 부름을 받았다. 디버거는 '</target>
        </trans-unit>
        <trans-unit id="5408ee3a5ae30f1b73e2236ceb15094b6b7e60de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;declare&lt;/code&gt; is a special macro which can be used to add meta properties to a function or macro: for example, marking it as obsolete, or giving its forms a special</source>
          <target state="translated">&lt;code&gt;declare&lt;/code&gt; 은 함수 나 매크로에 메타 속성을 추가하는 데 사용할 수있는 특수 매크로입니다.</target>
        </trans-unit>
        <trans-unit id="e948495adb03f74ecb74007271523cddadcd35a1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;default-boundp&lt;/code&gt; is to &lt;code&gt;default-value&lt;/code&gt; as &lt;code&gt;boundp&lt;/code&gt; is to &lt;code&gt;symbol-value&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;default-boundp&lt;/code&gt; 는 &lt;code&gt;default-value&lt;/code&gt; 이고 &lt;code&gt;boundp&lt;/code&gt; 는 &lt;code&gt;symbol-value&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f750ad0e57affc67c45a2f12853a28fd6ccb4c86" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defconst&lt;/code&gt; always evaluates &lt;var&gt;value&lt;/var&gt;, and sets the value of &lt;var&gt;symbol&lt;/var&gt; to the result. If &lt;var&gt;symbol&lt;/var&gt; does have a buffer-local binding in the current buffer, &lt;code&gt;defconst&lt;/code&gt; sets the default value, not the buffer-local value. (But you should not be making buffer-local bindings for a symbol that is defined with &lt;code&gt;defconst&lt;/code&gt;.)</source>
          <target state="translated">&lt;code&gt;defconst&lt;/code&gt; 는 항상 &lt;var&gt;value&lt;/var&gt; 를 평가 하고 &lt;var&gt;symbol&lt;/var&gt; 값을 결과로 설정합니다 . &lt;var&gt;symbol&lt;/var&gt; 이 현재 버퍼에 버퍼 로컬 바인딩을 가지고있는 경우 &lt;code&gt;defconst&lt;/code&gt; 는 버퍼 로컬 값이 아닌 기본값을 설정합니다. (그러나 &lt;code&gt;defconst&lt;/code&gt; 로 정의 된 심볼에 대해 버퍼 로컬 바인딩을 만들면 안됩니다 .)</target>
        </trans-unit>
        <trans-unit id="12dee0792bdf9b486bfd740498d0eadb2c152801" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defcustom&lt;/code&gt;, &lt;code&gt;defgroup&lt;/code&gt;, &lt;code&gt;defclass&lt;/code&gt; (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/eieio/index.html#Top&quot;&gt;EIEIO&lt;/a&gt; in</source>
          <target state="translated">&lt;code&gt;defcustom&lt;/code&gt; 는 , &lt;code&gt;defgroup&lt;/code&gt; , &lt;code&gt;defclass&lt;/code&gt; 는 (참조 &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/eieio/index.html#Top&quot;&gt;EIEIO을&lt;/a&gt; 에</target>
        </trans-unit>
        <trans-unit id="012f5d01fd0d5a5d01a85ae0f6957fec801c9a45" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defimage&lt;/code&gt; tests each argument, one by one, to see if it is usable&amp;mdash;that is, if the type is supported and the file exists. The first usable argument is used to make an image descriptor which is stored in &lt;var&gt;symbol&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;defimage&lt;/code&gt; 는 각 인수를 하나씩 테스트하여 사용 가능한지 즉, 유형이 지원되고 파일이 존재하는지 확인합니다. 첫 번째 사용 가능한 인수는 &lt;var&gt;symbol&lt;/var&gt; 에 저장되는 이미지 설명자를 만드는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="65612ea68e9ef580a07b967a84376d66e7d1511f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;define-abbrev&lt;/code&gt; is the low-level basic function for defining an abbrev in an abbrev table.</source>
          <target state="translated">&lt;code&gt;define-abbrev&lt;/code&gt; 는 abbrev 테이블에서 abbrev를 정의하기위한 저수준 기본 기능입니다.</target>
        </trans-unit>
        <trans-unit id="f93257cd24b7904a7e36862707a2b00198231632" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;define-minor-mode&lt;/code&gt;, &lt;code&gt;define-globalized-minor-mode&lt;/code&gt;, &lt;code&gt;define-generic-mode&lt;/code&gt;, &lt;code&gt;define-derived-mode&lt;/code&gt;, &lt;code&gt;easy-mmode-define-minor-mode&lt;/code&gt;, &lt;code&gt;easy-mmode-define-global-mode&lt;/code&gt;, &lt;code&gt;define-compilation-mode&lt;/code&gt;, and &lt;code&gt;define-global-minor-mode&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;define-minor-mode&lt;/code&gt; , &lt;code&gt;define-globalized-minor-mode&lt;/code&gt; , &lt;code&gt;define-generic-mode&lt;/code&gt; , &lt;code&gt;define-derived-mode&lt;/code&gt; , &lt;code&gt;easy-mmode-define-minor-mode&lt;/code&gt; , &lt;code&gt;easy-mmode-define-global-mode&lt;/code&gt; , &lt;code&gt;define-compilation-mode&lt;/code&gt; 및 &lt;code&gt;define-global-minor-mode&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9ad858ca1737d12f8ddf97a19595ffe87722585d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defmacro&lt;/code&gt; defines a symbol as a macro. It creates a macro object and stores it in the function cell of the symbol. Note that a given symbol can be a macro or a function, but not both at once, because both macro and function definitions are kept in the function cell, and that cell can hold only one Lisp object at any given time. See &lt;a href=&quot;macros#Macros&quot;&gt;Macros&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;defmacro&lt;/code&gt; 는 심볼을 매크로로 정의합니다. 매크로 객체를 생성하여 심볼의 기능 셀에 저장합니다. 매크로와 함수 정의가 모두 함수 셀에 유지되고 해당 셀은 주어진 시간에 하나의 Lisp 개체 만 보유 할 수 있기 때문에 주어진 기호는 매크로 또는 함수일 수 있지만 동시에 둘 다가 될 수는 없습니다. &lt;a href=&quot;macros#Macros&quot;&gt;매크로를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb8d765d8f8a2f740e70c10fe1ba95bc9a6f3810" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defmacro&lt;/code&gt; defines the symbol &lt;var&gt;name&lt;/var&gt; (which should not be quoted) as a macro that looks like this:</source>
          <target state="translated">&lt;code&gt;defmacro&lt;/code&gt; 는 기호 &lt;var&gt;name&lt;/var&gt; (따옴표로 묶지 않아야 함)을 다음과 같은 매크로로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="01769f0bc967504ad48bb76fcab17f7c05016973" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defun&lt;/code&gt; and &lt;code&gt;defmacro&lt;/code&gt;; also &lt;code&gt;cl-defun&lt;/code&gt; and &lt;code&gt;cl-defmacro&lt;/code&gt; (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/cl/Argument-Lists.html#Argument-Lists&quot;&gt;Argument Lists&lt;/a&gt; in</source>
          <target state="translated">&lt;code&gt;defun&lt;/code&gt; 및 &lt;code&gt;defmacro&lt;/code&gt; ; 또한 &lt;code&gt;cl-defun&lt;/code&gt; 및 &lt;code&gt;cl-defmacro&lt;/code&gt; (참조 &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/cl/Argument-Lists.html#Argument-Lists&quot;&gt;인수리스트&lt;/a&gt; 에</target>
        </trans-unit>
        <trans-unit id="b647875bc6007b6250b773099308720656737afa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defun&lt;/code&gt; defines a symbol as a function, creating a lambda expression and storing it in the function cell of the symbol. This lambda expression thus becomes the function definition of the symbol. (The term &amp;ldquo;function definition&amp;rdquo;, meaning the contents of the function cell, is derived from the idea that &lt;code&gt;defun&lt;/code&gt; gives the symbol its definition as a function.) &lt;code&gt;defsubst&lt;/code&gt; and &lt;code&gt;defalias&lt;/code&gt; are two other ways of defining a function. See &lt;a href=&quot;functions#Functions&quot;&gt;Functions&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;defun&lt;/code&gt; 은 기호를 함수로 정의하여 람다 식을 만들고 기호의 함수 셀에 저장합니다. 따라서이 람다 식은 기호의 함수 정의가됩니다. (함수 셀의 내용을 의미하는 &quot;함수 정의&quot;라는 용어는 &lt;code&gt;defun&lt;/code&gt; 이 기호에 함수로 정의를 제공 한다는 아이디어에서 파생되었습니다 .) &lt;code&gt;defsubst&lt;/code&gt; 및 &lt;code&gt;defalias&lt;/code&gt; 는 함수를 정의하는 다른 두 가지 방법입니다. &lt;a href=&quot;functions#Functions&quot;&gt;함수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="152769b81ca9a1e399de93e4483e4b2b25d12e27" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defun&lt;/code&gt; is the usual way to define new Lisp functions. It defines the symbol &lt;var&gt;name&lt;/var&gt; as a function with argument list &lt;var&gt;args&lt;/var&gt; and body forms given by &lt;var&gt;body&lt;/var&gt;. Neither &lt;var&gt;name&lt;/var&gt; nor &lt;var&gt;args&lt;/var&gt; should be quoted.</source>
          <target state="translated">&lt;code&gt;defun&lt;/code&gt; 은 새로운 Lisp 함수를 정의하는 일반적인 방법입니다. 인수 목록 &lt;var&gt;args&lt;/var&gt; 및 body가 제공하는 &lt;var&gt;body&lt;/var&gt; 형식을 사용 하여 기호 &lt;var&gt;name&lt;/var&gt; 을 함수로 정의합니다 . 둘 다 &lt;var&gt;name&lt;/var&gt; 않고 &lt;var&gt;args&lt;/var&gt; 인용되어야한다.</target>
        </trans-unit>
        <trans-unit id="56917c3bbaff8b95c5489feaa298d6f87beca6dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defvar&lt;/code&gt; and &lt;code&gt;defconst&lt;/code&gt; are special forms that define a symbol as a &lt;em&gt;global variable&lt;/em&gt;&amp;mdash;a variable that can be accessed at any point in a Lisp program. See &lt;a href=&quot;variables#Variables&quot;&gt;Variables&lt;/a&gt;, for details about variables. To define a customizable variable, use the &lt;code&gt;defcustom&lt;/code&gt; macro, which also calls &lt;code&gt;defvar&lt;/code&gt; as a subroutine (see &lt;a href=&quot;customization#Customization&quot;&gt;Customization&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;defvar&lt;/code&gt; 및 &lt;code&gt;defconst&lt;/code&gt; 는 심볼을 &lt;em&gt;전역 변수 (&lt;/em&gt; Lisp 프로그램의 어느 지점에서나 액세스 할 수있는 변수) 로 정의하는 특수 형식입니다 . &lt;a href=&quot;variables#Variables&quot;&gt;변수&lt;/a&gt; 에 대한 자세한 내용은 변수를 참조하십시오 . 사용자 정의 가능한 변수를 정의하려면 &lt;code&gt;defvar&lt;/code&gt; 를 서브 루틴으로 호출 하는 &lt;code&gt;defcustom&lt;/code&gt; 매크로를 사용 하십시오 ( &lt;a href=&quot;customization#Customization&quot;&gt;사용자 정의&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="3eb2267cae74dc899c4fbba26cfe21e3ea5b6517" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;delete-blank-lines&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;delete-blank-lines&lt;/code&gt; 는 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f840984ec3795b6f839ea590accd0745c89aaf79" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;delete-directory&lt;/code&gt; only follows symbolic links at the level of parent directories.</source>
          <target state="translated">&lt;code&gt;delete-directory&lt;/code&gt; 는 상위 디렉토리 수준에서 기호 링크 만 따릅니다.</target>
        </trans-unit>
        <trans-unit id="8b4225e31b19638d22dc17fbb44550f51340cfd5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;digit&lt;/code&gt;, &lt;code&gt;numeric&lt;/code&gt;, &lt;code&gt;num&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;digit&lt;/code&gt; , &lt;code&gt;numeric&lt;/code&gt; , &lt;code&gt;num&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8a908719f62b48c099dab98a459ed559d227965c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dismissed&lt;/code&gt; if the notification was dismissed by the user</source>
          <target state="translated">&lt;code&gt;dismissed&lt;/code&gt; 사용자가 알림을 닫은 경우 닫힘</target>
        </trans-unit>
        <trans-unit id="e907d769ab6400ef158c183eb829b092f502e5ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;display-buffer-alist&lt;/code&gt; and &lt;code&gt;display-buffer-base-action&lt;/code&gt; are user options&amp;mdash;Lisp programs must never set or rebind them. &lt;code&gt;display-buffer-overriding-action&lt;/code&gt;, on the other hand, is reserved for applications&amp;mdash;who seldom use that option and if they use it, then with utmost care.</source>
          <target state="translated">&lt;code&gt;display-buffer-alist&lt;/code&gt; 및 &lt;code&gt;display-buffer-base-action&lt;/code&gt; 은 사용자 옵션입니다. Lisp 프로그램은이를 설정하거나 다시 바인딩해서는 안됩니다. 반면에 &lt;code&gt;display-buffer-overriding-action&lt;/code&gt; 은 해당 옵션을 거의 사용하지 않고 사용하는 경우 최대한주의를 기울인 응용 프로그램 용으로 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="14d1ad1d34836cb877fe7eddc4cca15ca9bee5c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;display-buffer&lt;/code&gt; calls the action functions specified by this list in turn, passing the buffer as the first argument and the combined action alist as the second argument, until one of the functions returns non-&lt;code&gt;nil&lt;/code&gt;. See &lt;a href=&quot;precedence-of-action-functions#Precedence-of-Action-Functions&quot;&gt;Precedence of Action Functions&lt;/a&gt;, for examples how display actions specified by different sources are processed by &lt;code&gt;display-buffer&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;display-buffer&lt;/code&gt; 는 함수 중 하나가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 값을 반환 할 때까지이 목록에 지정된 작업 함수를 차례로 호출하여 버퍼를 첫 번째 인수로 전달하고 결합 된 작업 alist를 두 번째 인수로 전달합니다 . 다른 소스에 의해 지정된 디스플레이 작업이 &lt;code&gt;display-buffer&lt;/code&gt; 에 의해 처리되는 방법에 대한 예제 &lt;a href=&quot;precedence-of-action-functions#Precedence-of-Action-Functions&quot;&gt;는 작업 함수의 우선 순위를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ee6044593bc3c007fee9246a9041dc268f757d82" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;display-buffer&lt;/code&gt; delegates the task of finding a suitable window to so-called action functions (see &lt;a href=&quot;buffer-display-action-functions#Buffer-Display-Action-Functions&quot;&gt;Buffer Display Action Functions&lt;/a&gt;). First, &lt;code&gt;display-buffer&lt;/code&gt; compiles a so-called action alist&amp;mdash;a special association list that action functions can use to fine-tune their behavior. Then it passes that alist on to each action function it calls (see &lt;a href=&quot;buffer-display-action-alists#Buffer-Display-Action-Alists&quot;&gt;Buffer Display Action Alists&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;display-buffer&lt;/code&gt; 는 적절한 창을 찾는 작업을 소위 액션 함수에 위임합니다 ( &lt;a href=&quot;buffer-display-action-functions#Buffer-Display-Action-Functions&quot;&gt;버퍼 디스플레이 액션 함수&lt;/a&gt; 참조 ). 첫째, &lt;code&gt;display-buffer&lt;/code&gt; 는 소위 조치 목록 (액션 함수가 동작을 미세 조정하는 데 사용할 수있는 특수 연관 목록)을 컴파일합니다. 그런 다음 해당 목록을 호출하는 각 작업 함수에 전달합니다 ( &lt;a href=&quot;buffer-display-action-alists#Buffer-Display-Action-Alists&quot;&gt;Buffer Display Action Alists&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="f227d53c9e56460fd790779757e8a90bd347614f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;display-buffer&lt;/code&gt; is not overly well suited for displaying several buffers in sequence and making sure that all these buffers are shown orderly in the resulting window configuration. Again, the standard action functions &lt;code&gt;display-buffer-pop-up-window&lt;/code&gt; and &lt;code&gt;display-buffer-use-some-window&lt;/code&gt; are not very suited for this purpose due to their somewhat chaotic nature in more complex configurations.</source>
          <target state="translated">&lt;code&gt;display-buffer&lt;/code&gt; 는 여러 버퍼를 순서대로 표시하고 이러한 모든 버퍼가 결과 창 구성에 순서대로 표시되도록하는 데 지나치게 적합하지 않습니다. 다시 말하지만, 표준 액션 함수 &lt;code&gt;display-buffer-pop-up-window&lt;/code&gt; 및 &lt;code&gt;display-buffer-use-some-window&lt;/code&gt; 는 더 복잡한 구성에서 다소 혼란스러운 특성으로 인해이 목적에 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d64a554d77989581707b51f284c6e6248aa81ec2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;display-buffer&lt;/code&gt; works by combining display actions from several sources, and calling the action functions in turn, until one of them manages to display the buffer and returns a non-&lt;code&gt;nil&lt;/code&gt; value.</source>
          <target state="translated">&lt;code&gt;display-buffer&lt;/code&gt; 는 여러 소스의 디스플레이 액션을 결합하고 액션 함수 중 하나가 버퍼를 표시하고 &lt;code&gt;nil&lt;/code&gt; 이 아닌 값을 반환 할 때까지 차례로 액션 함수를 호출하는 방식으로 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="c1d4765f3824d06ce66d790e3171caf102615dee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;edebug-tracing&lt;/code&gt; and &lt;code&gt;edebug-trace&lt;/code&gt; insert lines in the trace buffer whenever they are called, even if Edebug is not active. Adding text to the trace buffer also scrolls its window to show the last lines inserted.</source>
          <target state="translated">&lt;code&gt;edebug-tracing&lt;/code&gt; 및 &lt;code&gt;edebug-trace&lt;/code&gt; 는 Edebug가 활성화되지 않은 경우에도 호출 될 때마다 추적 버퍼에 행을 삽입합니다. 추적 버퍼에 텍스트를 추가하면 창을 스크롤하여 삽입 된 마지막 행을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="a3f2415c34e4a3793e8232f202cffcf43789c5b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;error&lt;/code&gt; works by calling &lt;code&gt;signal&lt;/code&gt; with two arguments: the error symbol &lt;code&gt;error&lt;/code&gt;, and a list containing the string returned by &lt;code&gt;format-message&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;error&lt;/code&gt; 는 두 개의 인수, 즉 error 기호 &lt;code&gt;error&lt;/code&gt; 와 &lt;code&gt;format-message&lt;/code&gt; 가 반환 한 문자열을 포함하는 목록을 사용하여 &lt;code&gt;signal&lt;/code&gt; 를 호출 하여 작동 합니다 .</target>
        </trans-unit>
        <trans-unit id="e6880af6d200f2ca04ff4195004b0ab2299113fd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;esc-map&lt;/code&gt; is the global keymap for the</source>
          <target state="translated">&lt;code&gt;esc-map&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="7f8cd7311207af652cc522fd80e074dcb6e7e056" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;eval-current-buffer&lt;/code&gt; is an alias for this command.</source>
          <target state="translated">&lt;code&gt;eval-current-buffer&lt;/code&gt; 는이 명령의 별칭입니다.</target>
        </trans-unit>
        <trans-unit id="56f57ab8e49b20109332e2ec24f457692e98e579" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;eval-region&lt;/code&gt; does not move point. It always returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;eval-region&lt;/code&gt; 은 포인트를 이동하지 않습니다. 항상 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="9ad1f65d94f09547d3da4083875674afe6e969a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;exclamation-mark&lt;/code&gt;, &lt;code&gt;question-mark&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;exclamation-mark&lt;/code&gt; , &lt;code&gt;question-mark&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="40521d850dea7dce49a507b35bd302f3a54c8926" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;execute-extended-command&lt;/code&gt; is the normal definition of</source>
          <target state="translated">&lt;code&gt;execute-extended-command&lt;/code&gt; is the normal definition of</target>
        </trans-unit>
        <trans-unit id="6cf89b7da2a6174c3f8e679617a63de5d2e383ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expand-file-name&lt;/code&gt; uses the default directory when its second argument is &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;expand-file-name&lt;/code&gt; uses the default directory when its second argument is &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5c9062e5a9494acbeb71a2172655b2ae069bc217" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expired&lt;/code&gt; if the notification has expired</source>
          <target state="translated">&lt;code&gt;expired&lt;/code&gt; if the notification has expired</target>
        </trans-unit>
        <trans-unit id="d53f261a510c119d203db947e2ce5638e5bea95c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;facemenu-keymap&lt;/code&gt; is the global keymap used for the</source>
          <target state="translated">&lt;code&gt;facemenu-keymap&lt;/code&gt; is the global keymap used for the</target>
        </trans-unit>
        <trans-unit id="96b2d34869a0042346118c9a1c97c40bcab3a087" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;file-name-completion&lt;/code&gt; usually ignores file names that end in any string in this list. It does not ignore them when all the possible completions end in one of these suffixes. This variable has no effect on &lt;code&gt;file-name-all-completions&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;file-name-completion&lt;/code&gt; usually ignores file names that end in any string in this list. It does not ignore them when all the possible completions end in one of these suffixes. This variable has no effect on &lt;code&gt;file-name-all-completions&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b3f4cf9c9f44781f17e7b70a6e9267aa8b348f35" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filled-rectangle&lt;/code&gt;, &lt;code&gt;hollow-rectangle&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;filled-rectangle&lt;/code&gt; , &lt;code&gt;hollow-rectangle&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="63b0bf27eaf099c7a2aba78987210d1f60b20dc2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filled-square&lt;/code&gt;, &lt;code&gt;hollow-square&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;filled-square&lt;/code&gt; , &lt;code&gt;hollow-square&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7b151e0b46584e52a571005d89553b79e3782e2c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;format&lt;/code&gt;: Emacs&amp;rsquo;s analogue of &lt;code&gt;printf&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;format&lt;/code&gt; : Emacs&amp;rsquo;s analogue of &lt;code&gt;printf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0319a37175b95184201be0902c9bbe3c803de352" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forward-line&lt;/code&gt; returns the difference between &lt;var&gt;count&lt;/var&gt; and the number of lines actually moved. If you attempt to move down five lines from the beginning of a buffer that has only three lines, point stops at the end of the last line, and the value will be 2. As an explicit exception, if the last accessible line is non-empty, but has no newline (e.g., if the buffer ends without a newline), the function sets point to the end of that line, and the value returned by the function counts that line as one line successfully moved.</source>
          <target state="translated">&lt;code&gt;forward-line&lt;/code&gt; returns the difference between &lt;var&gt;count&lt;/var&gt; and the number of lines actually moved. If you attempt to move down five lines from the beginning of a buffer that has only three lines, point stops at the end of the last line, and the value will be 2. As an explicit exception, if the last accessible line is non-empty, but has no newline (e.g., if the buffer ends without a newline), the function sets point to the end of that line, and the value returned by the function counts that line as one line successfully moved.</target>
        </trans-unit>
        <trans-unit id="9fb006a1606ebf156dd571dfdde441e64a22ee51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;funcall&lt;/code&gt; calls &lt;var&gt;function&lt;/var&gt; with &lt;var&gt;arguments&lt;/var&gt;, and returns whatever &lt;var&gt;function&lt;/var&gt; returns.</source>
          <target state="translated">&lt;code&gt;funcall&lt;/code&gt; calls &lt;var&gt;function&lt;/var&gt; with &lt;var&gt;arguments&lt;/var&gt; , and returns whatever &lt;var&gt;function&lt;/var&gt; returns.</target>
        </trans-unit>
        <trans-unit id="5ee061b6998fb423f324fd8ff9a9a90f8bd371bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;garbage-collect&lt;/code&gt; returns a list with information on amount of space in use, where each entry has the form &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;garbage-collect&lt;/code&gt; returns a list with information on amount of space in use, where each entry has the form &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="e8f473f7afedf2216e2bb733f7d1ce2bfec20e81" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;goto-char&lt;/code&gt; returns &lt;var&gt;position&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;goto-char&lt;/code&gt; returns &lt;var&gt;position&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="66c22645f673d359bd032afd87fb1bda780e5783" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;goto-map&lt;/code&gt; is the global keymap used for the</source>
          <target state="translated">&lt;code&gt;goto-map&lt;/code&gt; is the global keymap used for the</target>
        </trans-unit>
        <trans-unit id="8eac353d9cbc652ce59f1d95e7cab268e9264776" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;graph&lt;/code&gt;, &lt;code&gt;graphic&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;graph&lt;/code&gt; , &lt;code&gt;graphic&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cc4b408f601dfd18211762a1f31289581f4d6d7a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;help-map&lt;/code&gt; is the global keymap for the</source>
          <target state="translated">&lt;code&gt;help-map&lt;/code&gt; is the global keymap for the</target>
        </trans-unit>
        <trans-unit id="d8a2acd22017b9816e7a1b9eb88b311cea6e2d74" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if&lt;/code&gt; chooses between the &lt;var&gt;then-form&lt;/var&gt; and the &lt;var&gt;else-forms&lt;/var&gt; based on the value of &lt;var&gt;condition&lt;/var&gt;. If the evaluated &lt;var&gt;condition&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, &lt;var&gt;then-form&lt;/var&gt; is evaluated and the result returned. Otherwise, the &lt;var&gt;else-forms&lt;/var&gt; are evaluated in textual order, and the value of the last one is returned. (The &lt;var&gt;else&lt;/var&gt; part of &lt;code&gt;if&lt;/code&gt; is an example of an implicit &lt;code&gt;progn&lt;/code&gt;. See &lt;a href=&quot;sequencing#Sequencing&quot;&gt;Sequencing&lt;/a&gt;.)</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; chooses between the &lt;var&gt;then-form&lt;/var&gt; and the &lt;var&gt;else-forms&lt;/var&gt; based on the value of &lt;var&gt;condition&lt;/var&gt; . If the evaluated &lt;var&gt;condition&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , &lt;var&gt;then-form&lt;/var&gt; is evaluated and the result returned. Otherwise, the &lt;var&gt;else-forms&lt;/var&gt; are evaluated in textual order, and the value of the last one is returned. (The &lt;var&gt;else&lt;/var&gt; part of &lt;code&gt;if&lt;/code&gt; is an example of an implicit &lt;code&gt;progn&lt;/code&gt; . See &lt;a href=&quot;sequencing#Sequencing&quot;&gt;Sequencing&lt;/a&gt;.)</target>
        </trans-unit>
        <trans-unit id="a54485aa58de9cb2289aa67ac7fdf50fdb9aa0df" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if&lt;/code&gt; is a special form because the branch that is not selected is never evaluated&amp;mdash;it is ignored. Thus, in this example, &lt;code&gt;true&lt;/code&gt; is not printed because &lt;code&gt;print&lt;/code&gt; is never called:</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; is a special form because the branch that is not selected is never evaluated&amp;mdash;it is ignored. Thus, in this example, &lt;code&gt;true&lt;/code&gt; is not printed because &lt;code&gt;print&lt;/code&gt; is never called:</target>
        </trans-unit>
        <trans-unit id="6ef7e796b7e6b6881e2794286c19b66d90407fc6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if&lt;/code&gt;, &lt;code&gt;cond&lt;/code&gt;, &lt;code&gt;when&lt;/code&gt;, &lt;code&gt;unless&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; , &lt;code&gt;cond&lt;/code&gt; , &lt;code&gt;when&lt;/code&gt; , &lt;code&gt;unless&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="56df690091e9e1e1d78c541ae39c8a9446bfb9c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;indent-region&lt;/code&gt; with a non-&lt;code&gt;nil&lt;/code&gt; argument &lt;var&gt;to-column&lt;/var&gt; has a different meaning and does not use this variable.</source>
          <target state="translated">&lt;code&gt;indent-region&lt;/code&gt; with a non- &lt;code&gt;nil&lt;/code&gt; argument &lt;var&gt;to-column&lt;/var&gt; has a different meaning and does not use this variable.</target>
        </trans-unit>
        <trans-unit id="29940b6669ea18ccc514f7f5deaf6a35beb7ed92" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inhibit-startup-message&lt;/code&gt; and &lt;code&gt;inhibit-splash-screen&lt;/code&gt; are aliases for this variable.</source>
          <target state="translated">&lt;code&gt;inhibit-startup-message&lt;/code&gt; and &lt;code&gt;inhibit-splash-screen&lt;/code&gt; are aliases for this variable.</target>
        </trans-unit>
        <trans-unit id="29a11d8eb74550c13ad46f3f07785cf2e8353c3a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;insert-file-contents&lt;/code&gt; and &lt;code&gt;write-region&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;insert-file-contents&lt;/code&gt; and &lt;code&gt;write-region&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc1819efabcf2c79e08931073dd0c99baeef175f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int-to-string&lt;/code&gt; is a semi-obsolete alias for this function.</source>
          <target state="translated">&lt;code&gt;int-to-string&lt;/code&gt; is a semi-obsolete alias for this function.</target>
        </trans-unit>
        <trans-unit id="cb18fb2d174e74648ae14f7c5881fe0d47fa5e84" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iter-defun&lt;/code&gt; defines a generator function. A generator function has the same signature as a normal function, but works differently. Instead of executing &lt;var&gt;body&lt;/var&gt; when called, a generator function returns an iterator object. That iterator runs &lt;var&gt;body&lt;/var&gt; to generate values, emitting a value and pausing where &lt;code&gt;iter-yield&lt;/code&gt; or &lt;code&gt;iter-yield-from&lt;/code&gt; appears. When &lt;var&gt;body&lt;/var&gt; returns normally, &lt;code&gt;iter-next&lt;/code&gt; signals &lt;code&gt;iter-end-of-sequence&lt;/code&gt; with &lt;var&gt;body&lt;/var&gt;&amp;rsquo;s result as its condition data.</source>
          <target state="translated">&lt;code&gt;iter-defun&lt;/code&gt; defines a generator function. A generator function has the same signature as a normal function, but works differently. Instead of executing &lt;var&gt;body&lt;/var&gt; when called, a generator function returns an iterator object. That iterator runs &lt;var&gt;body&lt;/var&gt; to generate values, emitting a value and pausing where &lt;code&gt;iter-yield&lt;/code&gt; or &lt;code&gt;iter-yield-from&lt;/code&gt; appears. When &lt;var&gt;body&lt;/var&gt; returns normally, &lt;code&gt;iter-next&lt;/code&gt; signals &lt;code&gt;iter-end-of-sequence&lt;/code&gt; with &lt;var&gt;body&lt;/var&gt; &amp;rsquo;s result as its condition data.</target>
        </trans-unit>
        <trans-unit id="4109e5aa6a1bfade7fb636b24ed135f433d38221" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iter-lambda&lt;/code&gt; produces an unnamed generator function that works just like a generator function produced with &lt;code&gt;iter-defun&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;iter-lambda&lt;/code&gt; produces an unnamed generator function that works just like a generator function produced with &lt;code&gt;iter-defun&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15d98457ad8a543fbfb81705f5a8344cb739a07d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iter-yield-from&lt;/code&gt; yields all the values that &lt;var&gt;iterator&lt;/var&gt; produces and evaluates to the value that &lt;var&gt;iterator&lt;/var&gt;&amp;rsquo;s generator function returns normally. While it has control, &lt;var&gt;iterator&lt;/var&gt; receives values sent to the iterator using &lt;code&gt;iter-next&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;iter-yield-from&lt;/code&gt; yields all the values that &lt;var&gt;iterator&lt;/var&gt; produces and evaluates to the value that &lt;var&gt;iterator&lt;/var&gt; &amp;rsquo;s generator function returns normally. While it has control, &lt;var&gt;iterator&lt;/var&gt; receives values sent to the iterator using &lt;code&gt;iter-next&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="76d4e792a718ab7a155f494cc528e3c2ff57d59c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kill-all-local-variables&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;kill-all-local-variables&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16db06500a347a02d731c188dee9c19d07a423c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kill-line&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; remapped to &lt;code&gt;my-other-kill-line&lt;/code&gt;. Instead, if an ordinary key binding specifies &lt;code&gt;kill-line&lt;/code&gt;, it is remapped to &lt;code&gt;my-kill-line&lt;/code&gt;; if an ordinary binding specifies &lt;code&gt;my-kill-line&lt;/code&gt;, it is remapped to &lt;code&gt;my-other-kill-line&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;kill-line&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; remapped to &lt;code&gt;my-other-kill-line&lt;/code&gt; . Instead, if an ordinary key binding specifies &lt;code&gt;kill-line&lt;/code&gt; , it is remapped to &lt;code&gt;my-kill-line&lt;/code&gt; ; if an ordinary binding specifies &lt;code&gt;my-kill-line&lt;/code&gt; , it is remapped to &lt;code&gt;my-other-kill-line&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0ccd36137fe5b6a475fa203ddbbe785c93b64de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kill-local-variable&lt;/code&gt; returns &lt;var&gt;variable&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;kill-local-variable&lt;/code&gt; returns &lt;var&gt;variable&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="ea41619b9bb6734de2a51b35884577b932079033" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kill-region&lt;/code&gt; is the usual subroutine for killing text. Any command that calls this function is a kill command (and should probably have &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;kill-region&lt;/code&gt; is the usual subroutine for killing text. Any command that calls this function is a kill command (and should probably have &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="ac6b1ea9968bed95795df33bf349e7fcfc89e356" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kp-0&lt;/code&gt;, &lt;code&gt;kp-1&lt;/code&gt;, &amp;hellip;</source>
          <target state="translated">&lt;code&gt;kp-0&lt;/code&gt; , &lt;code&gt;kp-1&lt;/code&gt; , &amp;hellip;</target>
        </trans-unit>
        <trans-unit id="96bb856bea3cba200a8e8092b22bcd8017da69ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kp-add&lt;/code&gt;, &lt;code&gt;kp-decimal&lt;/code&gt;, &lt;code&gt;kp-divide&lt;/code&gt;, &amp;hellip;</source>
          <target state="translated">&lt;code&gt;kp-add&lt;/code&gt; , &lt;code&gt;kp-decimal&lt;/code&gt; , &lt;code&gt;kp-divide&lt;/code&gt; , &amp;hellip;</target>
        </trans-unit>
        <trans-unit id="9273b099ca4265ff47245a822044a6a00d6b8dfd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kp-f1&lt;/code&gt;, &lt;code&gt;kp-f2&lt;/code&gt;, &lt;code&gt;kp-f3&lt;/code&gt;, &lt;code&gt;kp-f4&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;kp-f1&lt;/code&gt; , &lt;code&gt;kp-f2&lt;/code&gt; , &lt;code&gt;kp-f3&lt;/code&gt; , &lt;code&gt;kp-f4&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a957618586d8ac88b947fe0630ce1faea33ea0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kp-home&lt;/code&gt;, &lt;code&gt;kp-left&lt;/code&gt;, &lt;code&gt;kp-up&lt;/code&gt;, &lt;code&gt;kp-right&lt;/code&gt;, &lt;code&gt;kp-down&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;kp-home&lt;/code&gt; , &lt;code&gt;kp-left&lt;/code&gt; , &lt;code&gt;kp-up&lt;/code&gt; , &lt;code&gt;kp-right&lt;/code&gt; , &lt;code&gt;kp-down&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aa2b1e7bd7417d3f65fd45ff405387192fa4977a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kp-prior&lt;/code&gt;, &lt;code&gt;kp-next&lt;/code&gt;, &lt;code&gt;kp-end&lt;/code&gt;, &lt;code&gt;kp-begin&lt;/code&gt;, &lt;code&gt;kp-insert&lt;/code&gt;, &lt;code&gt;kp-delete&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;kp-prior&lt;/code&gt; , &lt;code&gt;kp-next&lt;/code&gt; , &lt;code&gt;kp-end&lt;/code&gt; , &lt;code&gt;kp-begin&lt;/code&gt; , &lt;code&gt;kp-insert&lt;/code&gt; , &lt;code&gt;kp-delete&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ca103fc8145d768e4a992e1cce45d81cc0ae7ebd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;left-arrow&lt;/code&gt;, &lt;code&gt;right-arrow&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;left-arrow&lt;/code&gt; , &lt;code&gt;right-arrow&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="246c0a986c7218186285fca89160a22af3cd88a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;left-bracket&lt;/code&gt;, &lt;code&gt;right-bracket&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;left-bracket&lt;/code&gt; , &lt;code&gt;right-bracket&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="125c1fd5ca16053f27bdd1d5ed69ccb1e10adb33" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;left-curly-arrow&lt;/code&gt;, &lt;code&gt;right-curly-arrow&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;left-curly-arrow&lt;/code&gt; , &lt;code&gt;right-curly-arrow&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="de2aba66da4813f38b7fc7692996f3b46cfc61f1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;left&lt;/code&gt;, &lt;code&gt;up&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;, &lt;code&gt;down&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;left&lt;/code&gt; , &lt;code&gt;up&lt;/code&gt; , &lt;code&gt;right&lt;/code&gt; , &lt;code&gt;down&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f6a8951a0db72dc26037795669472890ed7d2db9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;line-end&lt;/code&gt;, &lt;code&gt;eol&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;line-end&lt;/code&gt; , &lt;code&gt;eol&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ba55e96a733989c354535f935f2201139db555e3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;line-start&lt;/code&gt;, &lt;code&gt;bol&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;line-start&lt;/code&gt; , &lt;code&gt;bol&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9d0081f74a3b4ebb64b86d12fa3478d75d41dad9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;load&lt;/code&gt; returns &lt;code&gt;t&lt;/code&gt; if the file loads successfully.</source>
          <target state="translated">&lt;code&gt;load&lt;/code&gt; returns &lt;code&gt;t&lt;/code&gt; if the file loads successfully.</target>
        </trans-unit>
        <trans-unit id="249215aae3d1624114895ec3e31fcf94b2a1e635" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;local-function-key-map&lt;/code&gt; inherits from &lt;code&gt;function-key-map&lt;/code&gt;. The latter should only be altered if you want the binding to apply in all terminals, so using the former is almost always preferred.</source>
          <target state="translated">&lt;code&gt;local-function-key-map&lt;/code&gt; inherits from &lt;code&gt;function-key-map&lt;/code&gt; . The latter should only be altered if you want the binding to apply in all terminals, so using the former is almost always preferred.</target>
        </trans-unit>
        <trans-unit id="1fff4afaded7fd7b964a1ba99587343fdf63a9b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lower&lt;/code&gt;, &lt;code&gt;lower-case&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;lower&lt;/code&gt; , &lt;code&gt;lower-case&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ea87c6e99c32b702626bc85185ff62fd8116cd88" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lsh&lt;/code&gt;, which is an abbreviation for &lt;em&gt;logical shift&lt;/em&gt;, shifts the bits in &lt;var&gt;integer1&lt;/var&gt; to the left &lt;var&gt;count&lt;/var&gt; places, or to the right if &lt;var&gt;count&lt;/var&gt; is negative, bringing zeros into the vacated bits. If &lt;var&gt;count&lt;/var&gt; is negative, then &lt;var&gt;integer1&lt;/var&gt; must be either a fixnum or a positive bignum, and &lt;code&gt;lsh&lt;/code&gt; treats a negative fixnum as if it were unsigned by subtracting twice &lt;code&gt;most-negative-fixnum&lt;/code&gt; before shifting, producing a nonnegative result. This quirky behavior dates back to when Emacs supported only fixnums; nowadays &lt;code&gt;ash&lt;/code&gt; is a better choice.</source>
          <target state="translated">&lt;code&gt;lsh&lt;/code&gt; , which is an abbreviation for &lt;em&gt;logical shift&lt;/em&gt;, shifts the bits in &lt;var&gt;integer1&lt;/var&gt; to the left &lt;var&gt;count&lt;/var&gt; places, or to the right if &lt;var&gt;count&lt;/var&gt; is negative, bringing zeros into the vacated bits. If &lt;var&gt;count&lt;/var&gt; is negative, then &lt;var&gt;integer1&lt;/var&gt; must be either a fixnum or a positive bignum, and &lt;code&gt;lsh&lt;/code&gt; treats a negative fixnum as if it were unsigned by subtracting twice &lt;code&gt;most-negative-fixnum&lt;/code&gt; before shifting, producing a nonnegative result. This quirky behavior dates back to when Emacs supported only fixnums; nowadays &lt;code&gt;ash&lt;/code&gt; is a better choice.</target>
        </trans-unit>
        <trans-unit id="17ad6217085ea5b5e0b013ad0875589ff8f45a11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;macroexpand-all&lt;/code&gt; expands macros like &lt;code&gt;macroexpand&lt;/code&gt;, but will look for and expand all macros in &lt;var&gt;form&lt;/var&gt;, not just at the top-level. If no macros are expanded, the return value is &lt;code&gt;eq&lt;/code&gt; to &lt;var&gt;form&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;macroexpand-all&lt;/code&gt; expands macros like &lt;code&gt;macroexpand&lt;/code&gt; , but will look for and expand all macros in &lt;var&gt;form&lt;/var&gt; , not just at the top-level. If no macros are expanded, the return value is &lt;code&gt;eq&lt;/code&gt; to &lt;var&gt;form&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="f6c4eb079c3a7e5f0aab351a5677f46fed73aea3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mapc&lt;/code&gt; is like &lt;code&gt;mapcar&lt;/code&gt; except that &lt;var&gt;function&lt;/var&gt; is used for side-effects only&amp;mdash;the values it returns are ignored, not collected into a list. &lt;code&gt;mapc&lt;/code&gt; always returns &lt;var&gt;sequence&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;mapc&lt;/code&gt; is like &lt;code&gt;mapcar&lt;/code&gt; except that &lt;var&gt;function&lt;/var&gt; is used for side-effects only&amp;mdash;the values it returns are ignored, not collected into a list. &lt;code&gt;mapc&lt;/code&gt; always returns &lt;var&gt;sequence&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="f17fefcdf6fb3bfcd7affd13ee8956dda2d2cc22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mapcar&lt;/code&gt; applies &lt;var&gt;function&lt;/var&gt; to each element of &lt;var&gt;sequence&lt;/var&gt; in turn, and returns a list of the results.</source>
          <target state="translated">&lt;code&gt;mapcar&lt;/code&gt; applies &lt;var&gt;function&lt;/var&gt; to each element of &lt;var&gt;sequence&lt;/var&gt; in turn, and returns a list of the results.</target>
        </trans-unit>
        <trans-unit id="c5bcbf90aecc6544db096dd87c06c5ca1e224508" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mapconcat&lt;/code&gt; applies &lt;var&gt;function&lt;/var&gt; to each element of &lt;var&gt;sequence&lt;/var&gt;; the results, which must be sequences of characters (strings, vectors, or lists), are concatenated into a single string return value. Between each pair of result sequences, &lt;code&gt;mapconcat&lt;/code&gt; inserts the characters from &lt;var&gt;separator&lt;/var&gt;, which also must be a string, or a vector or list of characters. See &lt;a href=&quot;sequences-arrays-vectors#Sequences-Arrays-Vectors&quot;&gt;Sequences Arrays Vectors&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;mapconcat&lt;/code&gt; applies &lt;var&gt;function&lt;/var&gt; to each element of &lt;var&gt;sequence&lt;/var&gt; ; the results, which must be sequences of characters (strings, vectors, or lists), are concatenated into a single string return value. Between each pair of result sequences, &lt;code&gt;mapconcat&lt;/code&gt; inserts the characters from &lt;var&gt;separator&lt;/var&gt; , which also must be a string, or a vector or list of characters. See &lt;a href=&quot;sequences-arrays-vectors#Sequences-Arrays-Vectors&quot;&gt;Sequences Arrays Vectors&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="f7d2693764e07f0cb804bb968f848fd6f5c17e05" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max-lisp-eval-depth&lt;/code&gt; (see &lt;a href=&quot;eval#Eval&quot;&gt;Eval&lt;/a&gt;) and &lt;code&gt;max-specpdl-size&lt;/code&gt; (see &lt;a href=&quot;local-variables#Local-Variables&quot;&gt;Local Variables&lt;/a&gt;) are both increased to reduce Edebug&amp;rsquo;s impact on the stack. You could, however, still run out of stack space when using Edebug. You can also enlarge the value of &lt;code&gt;edebug-max-depth&lt;/code&gt; if Edebug reaches the limit of recursion depth instrumenting code that contains very large quoted lists.</source>
          <target state="translated">&lt;code&gt;max-lisp-eval-depth&lt;/code&gt; (see &lt;a href=&quot;eval#Eval&quot;&gt;Eval&lt;/a&gt;) and &lt;code&gt;max-specpdl-size&lt;/code&gt; (see &lt;a href=&quot;local-variables#Local-Variables&quot;&gt;Local Variables&lt;/a&gt;) are both increased to reduce Edebug&amp;rsquo;s impact on the stack. You could, however, still run out of stack space when using Edebug. You can also enlarge the value of &lt;code&gt;edebug-max-depth&lt;/code&gt; if Edebug reaches the limit of recursion depth instrumenting code that contains very large quoted lists.</target>
        </trans-unit>
        <trans-unit id="4dcede8a74a74667f6d6baa9436ec3f1ac34d528" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max-specpdl-size&lt;/code&gt; provides another limit on nesting. See &lt;a href=&quot;local-variables#Definition-of-max_002dspecpdl_002dsize&quot;&gt;Local Variables&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;max-specpdl-size&lt;/code&gt; provides another limit on nesting. See &lt;a href=&quot;local-variables#Definition-of-max_002dspecpdl_002dsize&quot;&gt;Local Variables&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="4283393c76101b7c75957e1aa804e3afd17b137b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;maximum-scroll-margin&lt;/code&gt; itself has a maximum value of 0.5, which allows setting margins large to keep the cursor at the middle line of the window (or two middle lines if the window has an even number of lines). If it&amp;rsquo;s set to a larger value (or any value other than a float between 0.0 and 0.5) then the default value of 0.25 will be used instead.</source>
          <target state="translated">&lt;code&gt;maximum-scroll-margin&lt;/code&gt; itself has a maximum value of 0.5, which allows setting margins large to keep the cursor at the middle line of the window (or two middle lines if the window has an even number of lines). If it&amp;rsquo;s set to a larger value (or any value other than a float between 0.0 and 0.5) then the default value of 0.25 will be used instead.</target>
        </trans-unit>
        <trans-unit id="0abfae913559cf6e54f47e4c7056eab492888b98" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;minor-mode-alist&lt;/code&gt; itself is not buffer-local. Each variable mentioned in the alist should be buffer-local if its minor mode can be enabled separately in each buffer.</source>
          <target state="translated">&lt;code&gt;minor-mode-alist&lt;/code&gt; itself is not buffer-local. Each variable mentioned in the alist should be buffer-local if its minor mode can be enabled separately in each buffer.</target>
        </trans-unit>
        <trans-unit id="5c765a30c75d52af9ee570867780f3be534d6e3b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;minor-mode-overriding-map-alist&lt;/code&gt; is automatically buffer-local in all buffers.</source>
          <target state="translated">&lt;code&gt;minor-mode-overriding-map-alist&lt;/code&gt; is automatically buffer-local in all buffers.</target>
        </trans-unit>
        <trans-unit id="17ec7b27c2211f568583f150e109b60c029edde5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mode-specific-map&lt;/code&gt; is the global keymap for the prefix key</source>
          <target state="translated">&lt;code&gt;mode-specific-map&lt;/code&gt; is the global keymap for the prefix key</target>
        </trans-unit>
        <trans-unit id="7890b9b8602eeddc0d995b6dc7c4ee21547818ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mule-keymap&lt;/code&gt; is the global keymap used for the</source>
          <target state="translated">&lt;code&gt;mule-keymap&lt;/code&gt; is the global keymap used for the</target>
        </trans-unit>
        <trans-unit id="d2f6cca2ccdb0ab132f6b7baf5caa26313957731" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nil&lt;/code&gt; means consider only windows on the selected frame. (Actually, the last frame used that is not a minibuffer-only frame.)</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; means consider only windows on the selected frame. (Actually, the last frame used that is not a minibuffer-only frame.)</target>
        </trans-unit>
        <trans-unit id="d0b9f6234ea8f44b037a824027a723100a30ef4a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nil&lt;/code&gt; means operate on all frames.</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; means operate on all frames.</target>
        </trans-unit>
        <trans-unit id="819a422042048b76988497f308e14b5e715ceab5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nil&lt;/code&gt; means that the events used so far in the lookup form an undefined key. When a keymap fails to mention an event type at all, and has no default binding, that is equivalent to a binding of &lt;code&gt;nil&lt;/code&gt; for that event type.</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; means that the events used so far in the lookup form an undefined key. When a keymap fails to mention an event type at all, and has no default binding, that is equivalent to a binding of &lt;code&gt;nil&lt;/code&gt; for that event type.</target>
        </trans-unit>
        <trans-unit id="afd72feaaa11fde848c1815c3b5a58b659297a44" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nil&lt;/code&gt; means to consider windows on &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s frame. If the minibuffer window is considered (as specified by the &lt;var&gt;minibuf&lt;/var&gt; argument), then frames that share the minibuffer window are considered too.</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; means to consider windows on &lt;var&gt;window&lt;/var&gt; &amp;rsquo;s frame. If the minibuffer window is considered (as specified by the &lt;var&gt;minibuf&lt;/var&gt; argument), then frames that share the minibuffer window are considered too.</target>
        </trans-unit>
        <trans-unit id="7f9b163d3a6478ab15f71af56a99d5c9db6c481b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nil&lt;/code&gt; means to leave the height of the chosen window alone.</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; means to leave the height of the chosen window alone.</target>
        </trans-unit>
        <trans-unit id="c2c1988a6a0d0d9e3ac37be3a0ca11cc3a3c9234" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nil&lt;/code&gt; means to leave the width of the chosen window alone.</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; means to leave the width of the chosen window alone.</target>
        </trans-unit>
        <trans-unit id="57cc7b3ade0670ca46365bd57aa0ed27d064ec81" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nil&lt;/code&gt; specified as an output stream means to use the value of &lt;code&gt;standard-output&lt;/code&gt; instead; that value is the &lt;em&gt;default output stream&lt;/em&gt;, and must not be &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; specified as an output stream means to use the value of &lt;code&gt;standard-output&lt;/code&gt; instead; that value is the &lt;em&gt;default output stream&lt;/em&gt;, and must not be &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41ba9d1889a34528a7c6886cc43b66ce04b8fdce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nil&lt;/code&gt; supplied as an input stream means to use the value of &lt;code&gt;standard-input&lt;/code&gt; instead; that value is the &lt;em&gt;default input stream&lt;/em&gt;, and must be a non-&lt;code&gt;nil&lt;/code&gt; input stream.</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; supplied as an input stream means to use the value of &lt;code&gt;standard-input&lt;/code&gt; instead; that value is the &lt;em&gt;default input stream&lt;/em&gt;, and must be a non- &lt;code&gt;nil&lt;/code&gt; input stream.</target>
        </trans-unit>
        <trans-unit id="0e057410ded4fee7473aed5c911a7c0479cd5a80" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nil&lt;/code&gt;, meaning there is no prefix argument. Its numeric value is 1, but numerous commands make a distinction between &lt;code&gt;nil&lt;/code&gt; and the integer 1.</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; , meaning there is no prefix argument. Its numeric value is 1, but numerous commands make a distinction between &lt;code&gt;nil&lt;/code&gt; and the integer 1.</target>
        </trans-unit>
        <trans-unit id="0d104d5ef48ee4b951b5d1860fbeed9512018d1e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nil&lt;/code&gt;: use the default indentation rule.</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; : use the default indentation rule.</target>
        </trans-unit>
        <trans-unit id="132ce6461764b770ab4320ac5096dea3d95d0c59" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;no-conversion&lt;/code&gt; (and its alias &lt;code&gt;binary&lt;/code&gt;) is equivalent to &lt;code&gt;raw-text-unix&lt;/code&gt;: it specifies no conversion of either character codes or end-of-line.</source>
          <target state="translated">&lt;code&gt;no-conversion&lt;/code&gt; (and its alias &lt;code&gt;binary&lt;/code&gt; ) is equivalent to &lt;code&gt;raw-text-unix&lt;/code&gt; : it specifies no conversion of either character codes or end-of-line.</target>
        </trans-unit>
        <trans-unit id="639f287af0a67f8ed92462a2183771add87f55ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;normal-mode&lt;/code&gt; uses &lt;code&gt;condition-case&lt;/code&gt; around the call to the major mode command, so errors are caught and reported as a &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;normal-mode&lt;/code&gt; uses &lt;code&gt;condition-case&lt;/code&gt; around the call to the major mode command, so errors are caught and reported as a &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="f1d673027be7f0dc198c4e29d79f765eb0015789" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;not-newline&lt;/code&gt;, &lt;code&gt;nonl&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;not-newline&lt;/code&gt; , &lt;code&gt;nonl&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3b477bde094dcd85ca9226e2b3dd79c674114393" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;posn-at-point&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt; if &lt;var&gt;pos&lt;/var&gt; is not visible in &lt;var&gt;window&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;posn-at-point&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt; if &lt;var&gt;pos&lt;/var&gt; is not visible in &lt;var&gt;window&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="914d11373ff4c8970d90e6703077a712573544e3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;primitive-undo&lt;/code&gt; adds elements to the buffer&amp;rsquo;s undo list when it changes the buffer. Undo commands avoid confusion by saving the undo list value at the beginning of a sequence of undo operations. Then the undo operations use and update the saved value. The new elements added by undoing are not part of this saved value, so they don&amp;rsquo;t interfere with continuing to undo.</source>
          <target state="translated">&lt;code&gt;primitive-undo&lt;/code&gt; adds elements to the buffer&amp;rsquo;s undo list when it changes the buffer. Undo commands avoid confusion by saving the undo list value at the beginning of a sequence of undo operations. Then the undo operations use and update the saved value. The new elements added by undoing are not part of this saved value, so they don&amp;rsquo;t interfere with continuing to undo.</target>
        </trans-unit>
        <trans-unit id="313c7f224d72ebc094061d7d24a663761e97b45b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;print&lt;/code&gt;, &lt;code&gt;printing&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;print&lt;/code&gt; , &lt;code&gt;printing&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ec9eda81cf8008a97b1d863eb1be427f16a8f3b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;provide&lt;/code&gt; and &lt;code&gt;require&lt;/code&gt; are an alternative to &lt;code&gt;autoload&lt;/code&gt; for loading files automatically. They work in terms of named &lt;em&gt;features&lt;/em&gt;. Autoloading is triggered by calling a specific function, but a feature is loaded the first time another program asks for it by name.</source>
          <target state="translated">&lt;code&gt;provide&lt;/code&gt; and &lt;code&gt;require&lt;/code&gt; are an alternative to &lt;code&gt;autoload&lt;/code&gt; for loading files automatically. They work in terms of named &lt;em&gt;features&lt;/em&gt;. Autoloading is triggered by calling a specific function, but a feature is loaded the first time another program asks for it by name.</target>
        </trans-unit>
        <trans-unit id="d70e77d38be89adf89d1b036b81076ba6e81cf61" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;punct&lt;/code&gt;, &lt;code&gt;punctuation&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;punct&lt;/code&gt; , &lt;code&gt;punctuation&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="084755a084b693739801d8d8edf38356f3c7cd80" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;push-button&lt;/code&gt; is the command that a user uses to actually push a button, and is bound by default in the button itself to</source>
          <target state="translated">&lt;code&gt;push-button&lt;/code&gt; is the command that a user uses to actually push a button, and is bound by default in the button itself to</target>
        </trans-unit>
        <trans-unit id="6ebf9fbf5d62647055c4ba6438a6901540013693" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rassoc&lt;/code&gt; is like &lt;code&gt;assoc&lt;/code&gt; except that it compares the &lt;small&gt;CDR&lt;/small&gt; of each &lt;var&gt;alist&lt;/var&gt; association instead of the &lt;small&gt;CAR&lt;/small&gt;. You can think of this as reverse &lt;code&gt;assoc&lt;/code&gt;, finding the key for a given value.</source>
          <target state="translated">&lt;code&gt;rassoc&lt;/code&gt; is like &lt;code&gt;assoc&lt;/code&gt; except that it compares the &lt;small&gt;CDR&lt;/small&gt; of each &lt;var&gt;alist&lt;/var&gt; association instead of the &lt;small&gt;CAR&lt;/small&gt;. You can think of this as reverse &lt;code&gt;assoc&lt;/code&gt; , finding the key for a given value.</target>
        </trans-unit>
        <trans-unit id="5b28e51d950dde8e979a69abe72749c3a72a81b6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rassq&lt;/code&gt; cannot search for a value stored in the &lt;small&gt;CAR&lt;/small&gt; of the &lt;small&gt;CDR&lt;/small&gt; of an element:</source>
          <target state="translated">&lt;code&gt;rassq&lt;/code&gt; cannot search for a value stored in the &lt;small&gt;CAR&lt;/small&gt; of the &lt;small&gt;CDR&lt;/small&gt; of an element:</target>
        </trans-unit>
        <trans-unit id="e731698340710bd2ed27567345847db52d9ecc7b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rassq&lt;/code&gt; is like &lt;code&gt;assq&lt;/code&gt; except that it compares the &lt;small&gt;CDR&lt;/small&gt; of each &lt;var&gt;alist&lt;/var&gt; association instead of the &lt;small&gt;CAR&lt;/small&gt;. You can think of this as reverse &lt;code&gt;assq&lt;/code&gt;, finding the key for a given value.</source>
          <target state="translated">&lt;code&gt;rassq&lt;/code&gt; is like &lt;code&gt;assq&lt;/code&gt; except that it compares the &lt;small&gt;CDR&lt;/small&gt; of each &lt;var&gt;alist&lt;/var&gt; association instead of the &lt;small&gt;CAR&lt;/small&gt;. You can think of this as reverse &lt;code&gt;assq&lt;/code&gt; , finding the key for a given value.</target>
        </trans-unit>
        <trans-unit id="67994628b87e5a6fefaf54d031a115c17ae6ec51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;read-file-name&lt;/code&gt; does not automatically expand the returned file name. You can call &lt;code&gt;expand-file-name&lt;/code&gt; yourself if an absolute file name is required.</source>
          <target state="translated">&lt;code&gt;read-file-name&lt;/code&gt; does not automatically expand the returned file name. You can call &lt;code&gt;expand-file-name&lt;/code&gt; yourself if an absolute file name is required.</target>
        </trans-unit>
        <trans-unit id="a5bb534f341b26b90a134da77d2d54c776b85a5c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;read-regexp&lt;/code&gt; now ensures that the result of processing &lt;var&gt;defaults&lt;/var&gt; is a list (i.e., if the value is &lt;code&gt;nil&lt;/code&gt; or a string, it converts it to a list of one element). To this list, &lt;code&gt;read-regexp&lt;/code&gt; then appends a few potentially useful candidates for input. These are:</source>
          <target state="translated">&lt;code&gt;read-regexp&lt;/code&gt; now ensures that the result of processing &lt;var&gt;defaults&lt;/var&gt; is a list (i.e., if the value is &lt;code&gt;nil&lt;/code&gt; or a string, it converts it to a list of one element). To this list, &lt;code&gt;read-regexp&lt;/code&gt; then appends a few potentially useful candidates for input. These are:</target>
        </trans-unit>
        <trans-unit id="d4c55533c2f01f1b7db258f38f07cb55c889d489" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;replace-buffer-contents&lt;/code&gt; returns t if a non-destructive replacement could be performed. Otherwise, i.e., if &lt;var&gt;max-secs&lt;/var&gt; was exceeded, it returns nil.</source>
          <target state="translated">&lt;code&gt;replace-buffer-contents&lt;/code&gt; returns t if a non-destructive replacement could be performed. Otherwise, i.e., if &lt;var&gt;max-secs&lt;/var&gt; was exceeded, it returns nil.</target>
        </trans-unit>
        <trans-unit id="fc560a9efb7ad3b860b6ef11a703b3989d2a895b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;revert-buffer&lt;/code&gt; binds this variable to a non-&lt;code&gt;nil&lt;/code&gt; value while it is working.</source>
          <target state="translated">&lt;code&gt;revert-buffer&lt;/code&gt; binds this variable to a non- &lt;code&gt;nil&lt;/code&gt; value while it is working.</target>
        </trans-unit>
        <trans-unit id="760a5fbe6045d8f7559904c18d6a2c56d1688252" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;revert-buffer&lt;/code&gt;, and how to customize what it does.</source>
          <target state="translated">&lt;code&gt;revert-buffer&lt;/code&gt; , and how to customize what it does.</target>
        </trans-unit>
        <trans-unit id="0d8aa86d0e2e4c279aa3d7ab23ba5404e9f3bb99" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;right-triangle&lt;/code&gt;, &lt;code&gt;left-triangle&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;right-triangle&lt;/code&gt; , &lt;code&gt;left-triangle&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ea54e890fcbaf5ede0bc6e26303eaf3f9555144a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rx-let&lt;/code&gt; can be used not only inside a function, but also at top level to include global variable and function definitions that need to share a common set of &lt;code&gt;rx&lt;/code&gt; forms. Since the names are local inside &lt;var&gt;body&lt;/var&gt;, there is no need for any package prefixes. Example:</source>
          <target state="translated">&lt;code&gt;rx-let&lt;/code&gt; can be used not only inside a function, but also at top level to include global variable and function definitions that need to share a common set of &lt;code&gt;rx&lt;/code&gt; forms. Since the names are local inside &lt;var&gt;body&lt;/var&gt; , there is no need for any package prefixes. Example:</target>
        </trans-unit>
        <trans-unit id="5b08879be5eaeb8caa4a6762910dd120cba71aa8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;save-buffer&lt;/code&gt; is responsible for making backup files. Normally, &lt;var&gt;backup-option&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, and &lt;code&gt;save-buffer&lt;/code&gt; makes a backup file only if this is the first save since visiting the file. Other values for &lt;var&gt;backup-option&lt;/var&gt; request the making of backup files in other circumstances:</source>
          <target state="translated">&lt;code&gt;save-buffer&lt;/code&gt; is responsible for making backup files. Normally, &lt;var&gt;backup-option&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; , and &lt;code&gt;save-buffer&lt;/code&gt; makes a backup file only if this is the first save since visiting the file. Other values for &lt;var&gt;backup-option&lt;/var&gt; request the making of backup files in other circumstances:</target>
        </trans-unit>
        <trans-unit id="a1e81cd0dbdcd543cf4536779a9160daa8d5b908" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;save-restriction&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; restore point; use &lt;code&gt;save-excursion&lt;/code&gt; for that. If you use both &lt;code&gt;save-restriction&lt;/code&gt; and &lt;code&gt;save-excursion&lt;/code&gt; together, &lt;code&gt;save-excursion&lt;/code&gt; should come first (on the outside). Otherwise, the old point value would be restored with temporary narrowing still in effect. If the old point value were outside the limits of the temporary narrowing, this would fail to restore it accurately.</source>
          <target state="translated">&lt;code&gt;save-restriction&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; restore point; use &lt;code&gt;save-excursion&lt;/code&gt; for that. If you use both &lt;code&gt;save-restriction&lt;/code&gt; and &lt;code&gt;save-excursion&lt;/code&gt; together, &lt;code&gt;save-excursion&lt;/code&gt; should come first (on the outside). Otherwise, the old point value would be restored with temporary narrowing still in effect. If the old point value were outside the limits of the temporary narrowing, this would fail to restore it accurately.</target>
        </trans-unit>
        <trans-unit id="f681cec249f999acd57b8bf621e56d79bd04124b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;search-map&lt;/code&gt; is the global keymap used for the</source>
          <target state="translated">&lt;code&gt;search-map&lt;/code&gt; is the global keymap used for the</target>
        </trans-unit>
        <trans-unit id="21f45bc2679fe0ce6666bb52f56d2a1f5b4f3917" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;seq-elt&lt;/code&gt; returns places settable using &lt;code&gt;setf&lt;/code&gt; (see &lt;a href=&quot;setting-generalized-variables#Setting-Generalized-Variables&quot;&gt;Setting Generalized Variables&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;seq-elt&lt;/code&gt; returns places settable using &lt;code&gt;setf&lt;/code&gt; (see &lt;a href=&quot;setting-generalized-variables#Setting-Generalized-Variables&quot;&gt;Setting Generalized Variables&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="412a741ecf02586a155f9800e1819ad1a59f7197" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setenv&lt;/code&gt; returns the new value of &lt;var&gt;variable&lt;/var&gt;, or &lt;code&gt;nil&lt;/code&gt; if it removed &lt;var&gt;variable&lt;/var&gt; from the environment.</source>
          <target state="translated">&lt;code&gt;setenv&lt;/code&gt; returns the new value of &lt;var&gt;variable&lt;/var&gt; , or &lt;code&gt;nil&lt;/code&gt; if it removed &lt;var&gt;variable&lt;/var&gt; from the environment.</target>
        </trans-unit>
        <trans-unit id="b3298f6be0f65fb71cd9899fbda4f5d128e54411" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setenv&lt;/code&gt; works by modifying &lt;code&gt;process-environment&lt;/code&gt;; binding that variable with &lt;code&gt;let&lt;/code&gt; is also reasonable practice.</source>
          <target state="translated">&lt;code&gt;setenv&lt;/code&gt; works by modifying &lt;code&gt;process-environment&lt;/code&gt; ; binding that variable with &lt;code&gt;let&lt;/code&gt; is also reasonable practice.</target>
        </trans-unit>
        <trans-unit id="1805264040f480fcfe5811e91adc07dd7107d291" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setf&lt;/code&gt; signals an error if you pass a &lt;var&gt;place&lt;/var&gt; form that it does not know how to handle.</source>
          <target state="translated">&lt;code&gt;setf&lt;/code&gt; signals an error if you pass a &lt;var&gt;place&lt;/var&gt; form that it does not know how to handle.</target>
        </trans-unit>
        <trans-unit id="a0b172aed0c367b6469c519892afd795f43421f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setq&lt;/code&gt; does not evaluate &lt;var&gt;symbol&lt;/var&gt;; it sets the symbol that you write. We say that this argument is &lt;em&gt;automatically quoted&lt;/em&gt;. The &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;setq&lt;/code&gt; does not evaluate &lt;var&gt;symbol&lt;/var&gt; ; it sets the symbol that you write. We say that this argument is &lt;em&gt;automatically quoted&lt;/em&gt;. The &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="84fb1128fe6ec1835607db7b74ec3623c9faaf3b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;space&lt;/code&gt;, &lt;code&gt;whitespace&lt;/code&gt;, &lt;code&gt;white&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;space&lt;/code&gt; , &lt;code&gt;whitespace&lt;/code&gt; , &lt;code&gt;white&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3acebe1579627cb1ae8404add4a67e4deaffbb44" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;standard-output&lt;/code&gt; and &lt;code&gt;standard-input&lt;/code&gt; are bound to &lt;code&gt;nil&lt;/code&gt; by the &lt;code&gt;recursive-edit&lt;/code&gt;, but Edebug temporarily restores them during evaluations.</source>
          <target state="translated">&lt;code&gt;standard-output&lt;/code&gt; and &lt;code&gt;standard-input&lt;/code&gt; are bound to &lt;code&gt;nil&lt;/code&gt; by the &lt;code&gt;recursive-edit&lt;/code&gt; , but Edebug temporarily restores them during evaluations.</target>
        </trans-unit>
        <trans-unit id="0a9ae84722969551ac034daec5e016ebd0c44e32" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;store-match-data&lt;/code&gt; is a semi-obsolete alias for &lt;code&gt;set-match-data&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;store-match-data&lt;/code&gt; is a semi-obsolete alias for &lt;code&gt;set-match-data&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09664cb1c96e9185c9144ca00b932c6582599f0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string-end&lt;/code&gt;, &lt;code&gt;eos&lt;/code&gt;, &lt;code&gt;buffer-end&lt;/code&gt;, &lt;code&gt;eot&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;string-end&lt;/code&gt; , &lt;code&gt;eos&lt;/code&gt; , &lt;code&gt;buffer-end&lt;/code&gt; , &lt;code&gt;eot&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d6440bc6219257786238ef571e25a78488969195" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string-equal&lt;/code&gt; is another name for &lt;code&gt;string=&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;string-equal&lt;/code&gt; is another name for &lt;code&gt;string=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be651b6f67d7e458c50b3cf7fb671ab938eb0255" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string-lessp&lt;/code&gt; is another name for &lt;code&gt;string&amp;lt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;string-lessp&lt;/code&gt; is another name for &lt;code&gt;string&amp;lt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b5a5dbc53a397eb7b8627403504ca468cdec06d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string-start&lt;/code&gt;, &lt;code&gt;bos&lt;/code&gt;, &lt;code&gt;buffer-start&lt;/code&gt;, &lt;code&gt;bot&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;string-start&lt;/code&gt; , &lt;code&gt;bos&lt;/code&gt; , &lt;code&gt;buffer-start&lt;/code&gt; , &lt;code&gt;bot&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="35766ce72fedccae73899ff72af9f02eba537d17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string-to-int&lt;/code&gt; is an obsolete alias for this function.</source>
          <target state="translated">&lt;code&gt;string-to-int&lt;/code&gt; is an obsolete alias for this function.</target>
        </trans-unit>
        <trans-unit id="f7f7697af3e84322eec091c3c1c134ddc067b714" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;subst-char-in-region&lt;/code&gt; does not move point and returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;subst-char-in-region&lt;/code&gt; 은 점을 이동하지 않고 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="dd8ca73079df3dd53ec8024a2bbc2995ca2223f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;substring&lt;/code&gt; also accepts a vector for the first argument. For example:</source>
          <target state="translated">&lt;code&gt;substring&lt;/code&gt; 은 첫 번째 인수에 대한 벡터도 허용합니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="7538a9062ef699c535de57d93e800e4b85bc83fc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;t&lt;/code&gt; (the default)</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; (기본값)</target>
        </trans-unit>
        <trans-unit id="61a81a6cdbc4b7f9b8d52d68af382ec09ee04b6c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;t&lt;/code&gt; for a directory, a string for a symbolic link (the name linked to), or &lt;code&gt;nil&lt;/code&gt; for a text file (&lt;code&gt;file-attribute-type&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 는 디렉토리, 심볼릭 링크의 문자열 (링크 된 이름), 텍스트 파일의 경우 &lt;code&gt;nil&lt;/code&gt; ( &lt;code&gt;file-attribute-type&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="d721e32bb95cdb8eeeb178c9e1375221de1d3779" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;t&lt;/code&gt; if daylight saving time is effect, &lt;code&gt;nil&lt;/code&gt; if it is not in effect, and -1 if this information is not available.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 일광 절약 시간이 유효한 경우 , 유효 &lt;code&gt;nil&lt;/code&gt; 않은 경우 nil ,이 정보를 사용할 수없는 경우 -1.</target>
        </trans-unit>
        <trans-unit id="d7a0e85e56982169debe8d361bb05d3472094c1b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;t&lt;/code&gt; if inside a non-nestable comment (of any comment style; see &lt;a href=&quot;syntax-flags#Syntax-Flags&quot;&gt;Syntax Flags&lt;/a&gt;); or the comment nesting level if inside a comment that can be nested.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 중첩 불가능한 주석 (모든 주석 스타일, &lt;a href=&quot;syntax-flags#Syntax-Flags&quot;&gt;구문 플래그&lt;/a&gt; 참조 ); 또는 중첩 될 수있는 주석 내부에있는 경우 주석 중첩 수준.</target>
        </trans-unit>
        <trans-unit id="cef1f4ed993c9f70d6394dbf0337c4865820f50f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;t&lt;/code&gt; if the end point is just after a quote character.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 끝 점이 따옴표 문자 바로 뒤에있는 경우.</target>
        </trans-unit>
        <trans-unit id="ca362524e068b7a0ec650b69f842377fea553dc6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;t&lt;/code&gt; means consider windows on all existing frames.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 는 모든 기존 프레임의 창을 고려함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d7d22e3999dd931ac69620324b6cb2afd00057de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;t&lt;/code&gt; means consider windows on all frames.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 는 모든 프레임의 창을 고려함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="86776f9a01ba5ba7ca2810476ff92a879defb5bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;t&lt;/code&gt; means do not switch to a buffer shown on any live frame.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 는 라이브 프레임에 표시된 버퍼로 전환하지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="49bfc08b83a08210a4c227a7b4aff67853a73f0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;t&lt;/code&gt; means operate on the selected frame.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 는 선택한 프레임에서 작동 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="400fda1edd4652607c56029e5840115a5c101a3f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;t&lt;/code&gt; means to consider windows on all existing frames.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 는 모든 기존 프레임의 창을 고려함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="54a6a6c1c1513953b205df1e1454c11d8964fb78" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;t&lt;/code&gt; used as a stream means that the input is read from the minibuffer. In fact, the minibuffer is invoked once and the text given by the user is made into a string that is then used as the input stream. If Emacs is running in batch mode, standard input is used instead of the minibuffer. For example,</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 를 스트림으로 사용한다는 것은 미니 버퍼에서 입력을 읽는다는 의미입니다. 실제로 미니 버퍼는 한 번 호출되고 사용자가 제공 한 텍스트는 입력 스트림으로 사용되는 문자열로 만들어집니다. Emacs가 배치 모드에서 실행중인 경우 미니 버퍼 대신 표준 입력이 사용됩니다. 예를 들면</target>
        </trans-unit>
        <trans-unit id="ef9a8dbd2ad88f17735d99134022fcc0f0647ed1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tab-prefix-map&lt;/code&gt; is the global keymap used for the</source>
          <target state="translated">&lt;code&gt;tab-prefix-map&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="35fa46cdfad9f57143883b7f4bf97917fce8f5fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt; means do not switch to a buffer shown on the frame that hosts the window &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; is acting upon.</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 수단은 창을 호스팅하는 상기 프레임에 표시 버퍼로 전환하지 않는 &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; 에 작용한다.</target>
        </trans-unit>
        <trans-unit id="dc8c81c5704363757846f658896f4d2ab6fdd06a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;thunk-let&lt;/code&gt; and &lt;code&gt;thunk-let*&lt;/code&gt; use thunks implicitly: their expansion creates helper symbols and binds them to thunks wrapping the binding expressions. All references to the original variables in the body &lt;var&gt;forms&lt;/var&gt; are then replaced by an expression that calls &lt;code&gt;thunk-force&lt;/code&gt; with the according helper variable as the argument. So, any code using &lt;code&gt;thunk-let&lt;/code&gt; or &lt;code&gt;thunk-let*&lt;/code&gt; could be rewritten to use thunks, but in many cases using these macros results in nicer code than using thunks explicitly.</source>
          <target state="translated">&lt;code&gt;thunk-let&lt;/code&gt; 및 &lt;code&gt;thunk-let*&lt;/code&gt; 은 암시 적으로 썽크를 사용합니다. 확장은 헬퍼 기호를 생성하고 바인딩 표현식을 래핑하는 썽크에 바인딩합니다. 그런 다음 본문 &lt;var&gt;forms&lt;/var&gt; 의 원래 변수에 대한 모든 참조는 해당 도우미 변수를 인수로 사용하여 &lt;code&gt;thunk-force&lt;/code&gt; 를 호출하는 표현식으로 대체됩니다 . 따라서 &lt;code&gt;thunk-let&lt;/code&gt; 또는 &lt;code&gt;thunk-let*&lt;/code&gt; 사용하는 모든 코드는 썽크 를 사용하도록 다시 작성할 수 있지만 많은 경우 이러한 매크로를 사용하면 썽크를 명시 적으로 사용하는 것보다 더 좋은 코드가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="1635457aaed54c29c183ca9ed092a80dc29e4d70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;time-to-seconds&lt;/code&gt; is an alias for this function.</source>
          <target state="translated">&lt;code&gt;time-to-seconds&lt;/code&gt; 는이 함수의 별칭입니다.</target>
        </trans-unit>
        <trans-unit id="26c106c1ab2f109ecd879a98213bfc8ac5a2d35a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;top-left-angle&lt;/code&gt;, &lt;code&gt;top-right-angle&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;top-left-angle&lt;/code&gt; , &lt;code&gt;top-right-angle&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fdc662193077bc52c6a9cf20b8a1d930c0058986" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;truncation&lt;/code&gt;, &lt;code&gt;continuation&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;truncation&lt;/code&gt; , &lt;code&gt;continuation&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c6ea0de9e9374af042b6bd3ef906b2af5702afb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;try-completion&lt;/code&gt; compares &lt;var&gt;string&lt;/var&gt; against each of the permissible completions specified by the completion table. If no permissible completions match, it returns &lt;code&gt;nil&lt;/code&gt;. If there is just one matching completion, and the match is exact, it returns &lt;code&gt;t&lt;/code&gt;. Otherwise, it returns the longest initial sequence common to all possible matching completions.</source>
          <target state="translated">&lt;code&gt;try-completion&lt;/code&gt; 은 완료 테이블에 지정된 허용 가능한 각 완료 와 &lt;var&gt;string&lt;/var&gt; 을 비교 합니다. 허용 가능한 완료가 일치하지 않으면 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 . 일치하는 완료가 하나만 있고 일치가 정확하면 &lt;code&gt;t&lt;/code&gt; 를 반환합니다 . 그렇지 않으면 가능한 모든 일치 완료에 공통되는 가장 긴 초기 시퀀스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="742ccebb68329ec2fd3c50d040bcbe34bc9b1bb7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;undefined&lt;/code&gt; if the notification server hasn&amp;rsquo;t provided a reason</source>
          <target state="translated">&lt;code&gt;undefined&lt;/code&gt; 알림 서버가 이유를 제공하지 않은 경우 정의되지 않음</target>
        </trans-unit>
        <trans-unit id="c58195fc3f2a7a906b58840d6e73503af41f547a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;undefined&lt;/code&gt; is used in local keymaps to override a global key binding and make the key undefined locally. A local binding of &lt;code&gt;nil&lt;/code&gt; would fail to do this because it would not override the global binding.</source>
          <target state="translated">&lt;code&gt;undefined&lt;/code&gt; 는 전역 키 바인딩을 재정의하고 키를 로컬에서 정의되지 않도록 만들기 위해 로컬 키맵에서 사용됩니다. &lt;code&gt;nil&lt;/code&gt; 의 로컬 바인딩은 전역 바인딩을 재정의하지 않기 때문에이를 수행하지 못합니다.</target>
        </trans-unit>
        <trans-unit id="4abbd5612df0f57058f67cb30404ce3ad8bf4e37" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unspecified&lt;/code&gt; is a relative value for all attributes. For &lt;code&gt;:height&lt;/code&gt;, floating point and function values are also relative.</source>
          <target state="translated">&lt;code&gt;unspecified&lt;/code&gt; 는 모든 속성에 대한 상대 값입니다. 내용 &lt;code&gt;:height&lt;/code&gt; , 및 부동 소수점 값 함수는 상대적이다.</target>
        </trans-unit>
        <trans-unit id="124f3fdc8f42c34d14b0df2c0020eb474f4eee0a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unwind-protect&lt;/code&gt; executes &lt;var&gt;body-form&lt;/var&gt; with a guarantee that the &lt;var&gt;cleanup-forms&lt;/var&gt; will be evaluated if control leaves &lt;var&gt;body-form&lt;/var&gt;, no matter how that happens. &lt;var&gt;body-form&lt;/var&gt; may complete normally, or execute a &lt;code&gt;throw&lt;/code&gt; out of the &lt;code&gt;unwind-protect&lt;/code&gt;, or cause an error; in all cases, the &lt;var&gt;cleanup-forms&lt;/var&gt; will be evaluated.</source>
          <target state="translated">&lt;code&gt;unwind-protect&lt;/code&gt; 는 제어가 &lt;var&gt;body-form&lt;/var&gt; 을 벗어나면 어떻게되는지에 관계없이 &lt;var&gt;cleanup-forms&lt;/var&gt; 이 평가 된다는 보장과 함께 &lt;var&gt;body-form&lt;/var&gt; 을 실행 합니다. &lt;var&gt;body-form&lt;/var&gt; 일반적으로 완료하거나 실행할 수 &lt;code&gt;throw&lt;/code&gt; 의 밖으로 &lt;code&gt;unwind-protect&lt;/code&gt; 하거나 오류가 발생할; 모든 경우에 &lt;var&gt;cleanup-forms&lt;/var&gt; 이 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="d81808bd6e7785579442de56a811c26e9936edbe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;up-arrow&lt;/code&gt;, &lt;code&gt;down-arrow&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;up-arrow&lt;/code&gt; , &lt;code&gt;down-arrow&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8935adeb062340d1e761af492c6eaa9b7433f232" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;up&lt;/code&gt;, &lt;code&gt;down&lt;/code&gt;, &lt;code&gt;top&lt;/code&gt;, &lt;code&gt;bottom&lt;/code&gt;, &lt;code&gt;top-bottom&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;up&lt;/code&gt; , &lt;code&gt;down&lt;/code&gt; , &lt;code&gt;top&lt;/code&gt; , &lt;code&gt;bottom&lt;/code&gt; , &lt;code&gt;top-bottom&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="47d330161b419cd92c499dffb7d1b14eb52cac0a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;upper&lt;/code&gt;, &lt;code&gt;upper-case&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;upper&lt;/code&gt; , &lt;code&gt;upper-case&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="158a61e3891293cbbcf96cd60832d79e93f772f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;vc-prefix-map&lt;/code&gt; is the global keymap used for the</source>
          <target state="translated">&lt;code&gt;vc-prefix-map&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="825022a69b3f863708db90f5ed68a02a6a6cb129" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;vertical-bar&lt;/code&gt;, &lt;code&gt;horizontal-bar&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;vertical-bar&lt;/code&gt; , &lt;code&gt;horizontal-bar&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a3a138938711530a671959761d2f5b9f94df0a46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;visible&lt;/code&gt; means consider windows on all visible frames.</source>
          <target state="translated">&lt;code&gt;visible&lt;/code&gt; 것은 보이는 모든 프레임의 창을 고려함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="77816e79409cf71a3ff6cf54ef6a99b6d9084ac1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;visible&lt;/code&gt; means do not switch to a buffer shown on any visible frame.</source>
          <target state="translated">&lt;code&gt;visible&lt;/code&gt; 것은 보이는 프레임에 표시된 버퍼로 전환하지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="a627c5f703440f7243320f587bc60b331be36cfe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;visible&lt;/code&gt; means operate on all visible frames.</source>
          <target state="translated">&lt;code&gt;visible&lt;/code&gt; 것은 모든 보이는 프레임에서 작동 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0e452b8631dd9c74908f6235ce975031b73eab84" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;visible&lt;/code&gt; means to consider windows on all visible frames.</source>
          <target state="translated">&lt;code&gt;visible&lt;/code&gt; 것은 모든 보이는 프레임의 창을 고려하는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="6b417aa5a01b38f3953d2734846bd5504972f617" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;while&lt;/code&gt; first evaluates &lt;var&gt;condition&lt;/var&gt;. If the result is non-&lt;code&gt;nil&lt;/code&gt;, it evaluates &lt;var&gt;forms&lt;/var&gt; in textual order. Then it reevaluates &lt;var&gt;condition&lt;/var&gt;, and if the result is non-&lt;code&gt;nil&lt;/code&gt;, it evaluates &lt;var&gt;forms&lt;/var&gt; again. This process repeats until &lt;var&gt;condition&lt;/var&gt; evaluates to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; 제들을 평가의 &lt;var&gt;condition&lt;/var&gt; . 결과가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 텍스트 순서로 &lt;var&gt;forms&lt;/var&gt; 을 평가 합니다 . 그런 다음 &lt;var&gt;condition&lt;/var&gt; 을 재평가 하고 결과가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 &lt;var&gt;forms&lt;/var&gt; 다시 평가 합니다. 이 프로세스는 &lt;var&gt;condition&lt;/var&gt; 이 &lt;code&gt;nil&lt;/code&gt; 로 평가 될 때까지 반복됩니다 .</target>
        </trans-unit>
        <trans-unit id="c28c2a35f9d17a3343930a2172690998bd7ed6a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;while&lt;/code&gt; loops.</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; 루프.</target>
        </trans-unit>
        <trans-unit id="81be4f19137f9a61fb5ee70cfec51ee80bd453b3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;wholenump&lt;/code&gt; is a synonym for &lt;code&gt;natnump&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;wholenump&lt;/code&gt; 는 동의어입니다 &lt;code&gt;natnump&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c30e3ea56a8b52086eba86f23ff7faec339cb641" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window-preserve-size&lt;/code&gt; installs a window parameter (see &lt;a href=&quot;window-parameters#Window-Parameters&quot;&gt;Window Parameters&lt;/a&gt;) called &lt;code&gt;window-preserved-size&lt;/code&gt; which is consulted by the window resizing functions. This parameter will not prevent resizing the window when the window shows another buffer than the one when &lt;code&gt;window-preserve-size&lt;/code&gt; was invoked or if its size has changed since then.</source>
          <target state="translated">&lt;code&gt;window-preserve-size&lt;/code&gt; 는 창 크기 조정 기능에 의해 참조되는 &lt;code&gt;window-preserved-size&lt;/code&gt; 라는 창 &lt;a href=&quot;window-parameters#Window-Parameters&quot;&gt;매개&lt;/a&gt; 변수 ( Window 매개 변수 참조)를 설치 합니다. 이 매개 변수는 &lt;code&gt;window-preserve-size&lt;/code&gt; 가 호출 되었을 때의 버퍼가 아닌 다른 버퍼를 창에 표시 하거나 그 이후로 크기가 변경된 경우 창 크기 조정을 방지하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="dfa8c3025baa1619a1cb484a98d518b5cb3a4666" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window-preserve-size&lt;/code&gt; is currently invoked by the following functions:</source>
          <target state="translated">&lt;code&gt;window-preserve-size&lt;/code&gt; 는 현재 다음 함수에 의해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="084ca655493b3ba8f35420163c15a65c888726c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window-text-pixel-size&lt;/code&gt; treats the text displayed in a window as a whole and does not care about the size of individual lines. The following function does.</source>
          <target state="translated">&lt;code&gt;window-text-pixel-size&lt;/code&gt; 는 창에 표시되는 텍스트를 전체로 취급하고 개별 줄의 크기는 신경 쓰지 않습니다. 다음 함수가 수행합니다.</target>
        </trans-unit>
        <trans-unit id="c2e71a1180aa7a9a3d673745a9a8f4074202f2a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;with-output-to-temp-buffer&lt;/code&gt; binds &lt;code&gt;standard-output&lt;/code&gt; to the temporary buffer, then it evaluates the forms in &lt;var&gt;body&lt;/var&gt;. Output using the Lisp output functions within &lt;var&gt;body&lt;/var&gt; goes by default to that buffer (but screen display and messages in the echo area, although they are &amp;ldquo;output&amp;rdquo; in the general sense of the word, are not affected). See &lt;a href=&quot;output-functions#Output-Functions&quot;&gt;Output Functions&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;with-output-to-temp-buffer&lt;/code&gt; 는 &lt;code&gt;standard-output&lt;/code&gt; 을 임시 버퍼에 바인딩 한 다음 &lt;var&gt;body&lt;/var&gt; 의 형식을 평가합니다 . &lt;var&gt;body&lt;/var&gt; 에서 Lisp 출력 기능을 사용하는 출력 은 기본적으로 해당 버퍼로 이동합니다 (그러나 화면 표시 및 에코 영역의 메시지는 일반적인 의미에서 &quot;출력&quot;이지만 영향을받지 않음). &lt;a href=&quot;output-functions#Output-Functions&quot;&gt;출력 함수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e84f2f07e30b4ea5b6c20826c999333168050c7c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;word-end&lt;/code&gt;, &lt;code&gt;eow&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;word-end&lt;/code&gt; , &lt;code&gt;eow&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="16546b833113bda25ce2e4419ca8eceff3c8b2e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;word-start&lt;/code&gt;, &lt;code&gt;bow&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;word-start&lt;/code&gt; , &lt;code&gt;bow&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="827f531e685c5586bab6272e4714cb1f0b74f54f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;word&lt;/code&gt;, &lt;code&gt;wordchar&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;word&lt;/code&gt; , &lt;code&gt;wordchar&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bb2c2f7c4cb32494d97ed15a5af54c85a51810ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;xdigit&lt;/code&gt;, &lt;code&gt;hex-digit&lt;/code&gt;, &lt;code&gt;hex&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;xdigit&lt;/code&gt; , &lt;code&gt;hex-digit&lt;/code&gt; , &lt;code&gt;hex&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8f40edd7b33461714aab3f00a1e35711dbe3ef1c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;yank&lt;/code&gt; does not alter the contents of the kill ring, unless it used text provided by another program, in which case it pushes that text onto the kill ring. However if &lt;var&gt;arg&lt;/var&gt; is an integer different from one, it rotates the kill ring to place the yanked string at the front.</source>
          <target state="translated">&lt;code&gt;yank&lt;/code&gt; 는 다른 프로그램에서 제공 한 텍스트를 사용하지 않는 한 킬 링의 내용을 변경하지 않습니다.이 경우 해당 텍스트를 킬 링으로 푸시합니다. 그러나 &lt;var&gt;arg&lt;/var&gt; 가 1과 다른 정수인 경우 킬 링을 회전하여 앞쪽에 늘어진 문자열을 배치합니다.</target>
        </trans-unit>
        <trans-unit id="4126970d6a7ed13e2eda65cb72f08e67f0f64f18" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;yank&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;yank&lt;/code&gt; 는 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="cc9e4d7d0310a3211cb2de0be80e8626f71d3e81" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;yes-or-no-p&lt;/code&gt; requires more work from the user than &lt;code&gt;y-or-n-p&lt;/code&gt; and is appropriate for more crucial decisions.</source>
          <target state="translated">&lt;code&gt;yes-or-no-p&lt;/code&gt; 는 &lt;code&gt;y-or-n-p&lt;/code&gt; 보다 사용자의 작업이 더 많이 필요 하며 더 중요한 결정에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="4ef594a430773406e23fbc4cd92fa339e01285bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;yes-or-no-p&lt;/code&gt; starts by displaying &lt;var&gt;prompt&lt;/var&gt; in the minibuffer, followed by &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;yes-or-no-p&lt;/code&gt; 는 미니 버퍼에 &lt;var&gt;prompt&lt;/var&gt; 를 표시 한 다음 '</target>
        </trans-unit>
        <trans-unit id="1bb5dae876438c6d89cc978517eaaf9a3cd5e088" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Backquote constructs&lt;/em&gt; allow you to quote a list, but selectively evaluate elements of that list. In the simplest case, it is identical to the special form &lt;code&gt;quote&lt;/code&gt; (described in the previous section; see &lt;a href=&quot;quoting#Quoting&quot;&gt;Quoting&lt;/a&gt;). For example, these two forms yield identical results:</source>
          <target state="translated">&lt;em&gt;역&lt;/em&gt; 따옴표 &lt;em&gt;구조를&lt;/em&gt; 사용하면 목록을 인용 할 수 있지만 해당 목록의 요소를 선택적으로 평가할 수 있습니다. 가장 간단한 경우는 특수한 형태의 &lt;code&gt;quote&lt;/code&gt; 동일합니다 (이전 섹션에서 설명했습니다 . &lt;a href=&quot;quoting#Quoting&quot;&gt;따옴표&lt;/a&gt; 참조 ). 예를 들어 다음 두 가지 형식은 동일한 결과를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="52d398a3e39ccaa473ca45e376fe6cbb42cee86c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Base coding systems&lt;/em&gt; such as &lt;code&gt;latin-1&lt;/code&gt; leave the end-of-line conversion unspecified, to be chosen based on the data. &lt;em&gt;Variant coding systems&lt;/em&gt; such as &lt;code&gt;latin-1-unix&lt;/code&gt;, &lt;code&gt;latin-1-dos&lt;/code&gt; and &lt;code&gt;latin-1-mac&lt;/code&gt; specify the end-of-line conversion explicitly as well. Most base coding systems have three corresponding variants whose names are formed by adding &amp;lsquo;</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt; &lt;code&gt;latin-1&lt;/code&gt; 과 같은 &lt;em&gt;기본 코딩 시스템&lt;/em&gt; 은 데이터를 기반으로 선택되도록 라인 끝 변환을 지정하지 않은 상태로 둡니다. &lt;code&gt;latin-1-unix&lt;/code&gt; , &lt;code&gt;latin-1-dos&lt;/code&gt; 및 &lt;code&gt;latin-1-mac&lt;/code&gt; 과 같은 &lt;em&gt;변형 코딩 시스템&lt;/em&gt; 은 줄 끝 변환도 명시 적으로 지정합니다. 대부분의 기본 코딩 시스템에는 '</target>
        </trans-unit>
        <trans-unit id="51b7d02da1d055c8be3f5ae434d97d9a260939bb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Byte-code function objects&lt;/em&gt; are produced by byte-compiling Lisp code (see &lt;a href=&quot;byte-compilation#Byte-Compilation&quot;&gt;Byte Compilation&lt;/a&gt;). Internally, a byte-code function object is much like a vector; however, the evaluator handles this data type specially when it appears in a function call. See &lt;a href=&quot;byte_002dcode-objects#Byte_002dCode-Objects&quot;&gt;Byte-Code Objects&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;바이트 코드 함수 객체&lt;/em&gt; 는 Lisp 코드를 바이트 컴파일하여 생성됩니다 ( &lt;a href=&quot;byte-compilation#Byte-Compilation&quot;&gt;Byte Compilation&lt;/a&gt; 참조 ). 내부적으로 바이트 코드 함수 객체는 벡터와 매우 유사합니다. 그러나 평가자는이 데이터 유형이 함수 호출에 나타날 때 특별히 처리합니다. &lt;a href=&quot;byte_002dcode-objects#Byte_002dCode-Objects&quot;&gt;바이트 코드 객체를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5dbbd81db1ec718403ad921765144545b1bbfac6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Categories&lt;/em&gt; provide an alternate way of classifying characters syntactically. You can define several categories as needed, then independently assign each character to one or more categories. Unlike syntax classes, categories are not mutually exclusive; it is normal for one character to belong to several categories.</source>
          <target state="translated">&lt;em&gt;범주&lt;/em&gt; 는 문자를 구문 적으로 분류하는 대체 방법을 제공합니다. 필요에 따라 여러 범주를 정의한 다음 각 문자를 하나 이상의 범주에 독립적으로 할당 할 수 있습니다. 구문 클래스와 달리 범주는 상호 배타적이지 않습니다. 한 캐릭터가 여러 카테고리에 속하는 것은 정상입니다.</target>
        </trans-unit>
        <trans-unit id="1558d6fbf1fe03911a5a03e621568b3d9a4ce168" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Character code conversion&lt;/em&gt; involves conversion between the internal representation of characters used inside Emacs and some other encoding. Emacs supports many different encodings, in that it can convert to and from them. For example, it can convert text to or from encodings such as Latin 1, Latin 2, Latin 3, Latin 4, Latin 5, and several variants of ISO 2022. In some cases, Emacs supports several alternative encodings for the same characters; for example, there are three coding systems for the Cyrillic (Russian) alphabet: ISO, Alternativnyj, and KOI8.</source>
          <target state="translated">&lt;em&gt;문자 코드 변환&lt;/em&gt; 에는 Emacs 내부에서 사용되는 문자의 내부 표현과 다른 인코딩 간의 &lt;em&gt;변환이&lt;/em&gt; 포함됩니다. Emacs는 변환 할 수 있다는 점에서 다양한 인코딩을 지원합니다. 예를 들어 라틴 1, 라틴 2, 라틴 3, 라틴 4, 라틴 5 및 ISO 2022의 여러 변형과 같은 인코딩간에 텍스트를 변환 할 수 있습니다. 경우에 따라 Emacs는 동일한 문자에 대해 여러 대체 인코딩을 지원합니다. 예를 들어 키릴 (러시아어) 알파벳에 대한 세 가지 코딩 시스템이 있습니다 : ISO, Alternativnyj 및 KOI8.</target>
        </trans-unit>
        <trans-unit id="2280765473a8763d5ed8fdb811b91a718fab2b2f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Clickable text&lt;/em&gt; is text that can be clicked, with either the mouse or via a keyboard command, to produce some result. Many major modes use clickable text to implement textual hyper-links, or &lt;em&gt;links&lt;/em&gt; for short.</source>
          <target state="translated">&lt;em&gt;클릭 가능한 텍스트&lt;/em&gt; 는 일부 결과를 생성하기 위해 마우스 또는 키보드 명령을 통해 클릭 할 수있는 텍스트입니다. 대부분의 주요 모드는 텍스트 하이퍼 링크 또는 구현하기 위해 클릭 할 수있는 텍스트를 사용하여 &lt;em&gt;링크&lt;/em&gt; 짧은합니다.</target>
        </trans-unit>
        <trans-unit id="896ce8b737ceaab656b74c1b4f5d586889200d2b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Completion&lt;/em&gt; is a feature that fills in the rest of a name starting from an abbreviation for it. Completion works by comparing the user&amp;rsquo;s input against a list of valid names and determining how much of the name is determined uniquely by what the user has typed. For example, when you type</source>
          <target state="translated">&lt;em&gt;완성&lt;/em&gt; 은 약어로 시작하여 나머지 이름을 채우는 기능입니다. 완성은 사용자의 입력을 유효한 이름 목록과 비교하고 사용자가 입력 한 내용에 따라 고유하게 결정되는 이름의 양을 결정하는 방식으로 작동합니다. 예를 들어, 입력 할 때</target>
        </trans-unit>
        <trans-unit id="63d57554d3523ee752846b3da7ebbb9b7117ca1a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Custom themes&lt;/em&gt; are collections of settings that can be enabled or disabled as a unit. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Custom-Themes.html#Custom-Themes&quot;&gt;Custom Themes&lt;/a&gt; in</source>
          <target state="translated">&lt;em&gt;사용자 지정 테마&lt;/em&gt; 는 하나의 단위로 활성화 또는 비활성화 할 수있는 설정 모음입니다. 참고 &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Custom-Themes.html#Custom-Themes&quot;&gt;사용자 지정 테마&lt;/a&gt; 에</target>
        </trans-unit>
        <trans-unit id="59c2468b329e81a15b4582afd13987bde009bc69" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Customizable variables&lt;/em&gt;, also called &lt;em&gt;user options&lt;/em&gt;, are global Lisp variables whose values can be set through the Customize interface. Unlike other global variables, which are defined with &lt;code&gt;defvar&lt;/code&gt; (see &lt;a href=&quot;defining-variables#Defining-Variables&quot;&gt;Defining Variables&lt;/a&gt;), customizable variables are defined using the &lt;code&gt;defcustom&lt;/code&gt; macro. In addition to calling &lt;code&gt;defvar&lt;/code&gt; as a subroutine, &lt;code&gt;defcustom&lt;/code&gt; states how the variable should be displayed in the Customize interface, the values it is allowed to take, etc.</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;&lt;em&gt;사용자 옵션&lt;/em&gt; 이라고도하는 &lt;em&gt;사용자 &lt;/em&gt;&lt;em&gt;정의 가능한 변수&lt;/em&gt; 는 사용자 정의 인터페이스를 통해 값을 설정할 수있는 전역 Lisp 변수입니다. &lt;code&gt;defvar&lt;/code&gt; ( &lt;a href=&quot;defining-variables#Defining-Variables&quot;&gt;변수 정의&lt;/a&gt; 참조)로 정의 되는 다른 전역 변수와 달리 사용자 정의 가능한 변수는 &lt;code&gt;defcustom&lt;/code&gt; 매크로를 사용하여 정의됩니다 . 호출 이외에 &lt;code&gt;defvar&lt;/code&gt; 서브 루틴으로서, &lt;code&gt;defcustom&lt;/code&gt; 이 변수는 사용자 인터페이스에 표시되는 방식을 말한다, 값은 등이 취할 수있다</target>
        </trans-unit>
        <trans-unit id="d2cd1f82937a4eb7683a776100c85b39df7832c6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Deleting a process&lt;/em&gt; disconnects Emacs immediately from the subprocess. Processes are deleted automatically after they terminate, but not necessarily right away. You can delete a process explicitly at any time. If you explicitly delete a terminated process before it is deleted automatically, no harm results. Deleting a running process sends a signal to terminate it (and its child processes, if any), and calls the process sentinel. See &lt;a href=&quot;sentinels#Sentinels&quot;&gt;Sentinels&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;프로세스를 삭제하면&lt;/em&gt; Emacs가 하위 프로세스에서 즉시 연결 해제됩니다. 프로세스는 종료 후 자동으로 삭제되지만 반드시 즉시 삭제되는 것은 아닙니다. 언제든지 명시 적으로 프로세스를 삭제할 수 있습니다. 자동으로 삭제되기 전에 종료 된 프로세스를 명시 적으로 삭제해도 아무런 문제가 없습니다. 실행중인 프로세스를 삭제하면 해당 프로세스 (및 하위 프로세스가있는 경우)를 종료하라는 신호를 보내고 프로세스 센티넬을 호출합니다. &lt;a href=&quot;sentinels#Sentinels&quot;&gt;Sentinels를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6a04597d44103a66abcb00dff3bbf8451a6cde11" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Deleting&lt;/em&gt; a window removes it from the frame&amp;rsquo;s window tree. If the window is a live window, it disappears from the screen. If the window is an internal window, its child windows are deleted too.</source>
          <target state="translated">&lt;em&gt;삭제&lt;/em&gt; 창은 프레임의 윈도우 트리에서 제거합니다. 창이 라이브 창인 경우 화면에서 사라집니다. 창이 내부 창인 경우 하위 창도 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="a81cd1d7c6f845c2f4389ced6d9de2027622091f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Desktop Save Mode&lt;/em&gt; is a feature to save the state of Emacs from one session to another. The user-level commands for using Desktop Save Mode are described in the GNU Emacs Manual (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Saving-Emacs-Sessions.html#Saving-Emacs-Sessions&quot;&gt;Saving Emacs Sessions&lt;/a&gt; in</source>
          <target state="translated">&lt;em&gt;데스크탑 저장 모드&lt;/em&gt; 는 한 세션에서 다른 세션으로 Emacs의 상태를 저장하는 기능입니다. 바탕 화면 저장 모드를 사용하는 사용자 수준의 명령은 GNU Emacs의 매뉴얼 (참조에 설명되어 &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Saving-Emacs-Sessions.html#Saving-Emacs-Sessions&quot;&gt;저장 이맥스 세션&lt;/a&gt; 에서</target>
        </trans-unit>
        <trans-unit id="6a98088cdd182559754e982a584f93bcf30a3813" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Disabling a command&lt;/em&gt; marks the command as requiring user confirmation before it can be executed. Disabling is used for commands which might be confusing to beginning users, to prevent them from using the commands by accident.</source>
          <target state="translated">&lt;em&gt;명령을 비활성화하면 명령을&lt;/em&gt; 실행하기 전에 사용자 확인이 필요한 것으로 표시됩니다. 비활성화는 사용자가 실수로 명령을 사용하는 것을 방지하기 위해 처음 사용자에게 혼동을 줄 수있는 명령에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="eb0a8a9ea212b9db6c42c1e84c8e32063775f5a6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Dotted pair notation&lt;/em&gt; is a general syntax for cons cells that represents the &lt;small&gt;CAR&lt;/small&gt; and &lt;small&gt;CDR&lt;/small&gt; explicitly. In this syntax, &lt;code&gt;(&lt;var&gt;a&lt;/var&gt; . &lt;var&gt;b&lt;/var&gt;)&lt;/code&gt; stands for a cons cell whose &lt;small&gt;CAR&lt;/small&gt; is the object &lt;var&gt;a&lt;/var&gt; and whose &lt;small&gt;CDR&lt;/small&gt; is the object &lt;var&gt;b&lt;/var&gt;. Dotted pair notation is more general than list syntax because the &lt;small&gt;CDR&lt;/small&gt; does not have to be a list. However, it is more cumbersome in cases where list syntax would work. In dotted pair notation, the list &amp;lsquo;</source>
          <target state="translated">&lt;em&gt;점선 표기법&lt;/em&gt; 은 &lt;small&gt;CAR&lt;/small&gt; 및 &lt;small&gt;CDR을&lt;/small&gt; 명시 적으로 나타내는 cons 셀의 일반적인 구문입니다 . 이 구문에서 &lt;code&gt;(&lt;var&gt;a&lt;/var&gt; . &lt;var&gt;b&lt;/var&gt;)&lt;/code&gt; 는 &lt;small&gt;CAR&lt;/small&gt; 이 객체 &lt;var&gt;a&lt;/var&gt; 이고 &lt;small&gt;CDR&lt;/small&gt; 이 객체 &lt;var&gt;b&lt;/var&gt; 인 cons 셀을 나타냅니다 . 점선 표기법은 &lt;small&gt;CDR&lt;/small&gt; 이 목록 일 필요가 없기 때문에 목록 구문보다 더 일반적 입니다. 그러나 목록 구문이 작동하는 경우 더 번거 롭습니다. 점선 표기법에서 목록 '</target>
        </trans-unit>
        <trans-unit id="d05af30e83de96c74400c03d5c224bcd479e45b8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;End of line conversion&lt;/em&gt; handles three different conventions used on various systems for representing end of line in files. The Unix convention, used on GNU and Unix systems, is to use the linefeed character (also called newline). The DOS convention, used on MS-Windows and MS-DOS systems, is to use a carriage return and a linefeed at the end of a line. The Mac convention is to use just carriage return. (This was the convention used in Classic Mac OS.)</source>
          <target state="translated">&lt;em&gt;줄 끝 변환&lt;/em&gt; 은 파일에서 줄 끝을 나타 내기 위해 다양한 시스템에서 사용되는 세 가지 다른 규칙을 처리합니다. GNU 및 Unix 시스템에서 사용되는 Unix 규칙은 줄 바꿈 문자 (줄 바꿈이라고도 함)를 사용하는 것입니다. MS-Windows 및 MS-DOS 시스템에서 사용되는 DOS 규칙은 행 끝에 캐리지 리턴과 줄 바꿈을 사용하는 것입니다. Mac 규칙은 캐리지 리턴 만 사용하는 것입니다. (이것은 Classic Mac OS에서 사용되는 규칙입니다.)</target>
        </trans-unit>
        <trans-unit id="7525ea7dc927a64f5dc8869487e40c6d636e3777" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Expanding&lt;/em&gt; a file name means converting a relative file name to an absolute one. Since this is done relative to a default directory, you must specify the default directory as well as the file name to be expanded. It also involves expanding abbreviations like</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;파일 이름을 &lt;em&gt;확장&lt;/em&gt; 한다는 것은 상대 파일 이름을 절대 이름으로 변환하는 것을 의미합니다. 이는 기본 디렉토리를 기준으로 수행되므로 기본 디렉토리와 확장 할 파일 이름을 지정해야합니다. 또한 다음과 같은 확장 약어를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="e238173aa0c8a6a07d4777f2af3642f8e79949df" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Experience shows that using dynamic function loading provides benefits that are hardly measurable, so this feature is deprecated since Emacs 27.1.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;경험에 따르면 동적 함수 로딩을 사용하면 거의 측정 할 수없는 이점이 제공되므로이 기능은 Emacs 27.1부터 사용되지 않습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4d4acaa738d1bb5676446288b0e8540c4e231918" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Face attributes&lt;/em&gt; determine the visual appearance of a face. The following table lists all the face attributes, their possible values, and their effects.</source>
          <target state="translated">&lt;em&gt;얼굴 속성&lt;/em&gt; 은 얼굴의 시각적 모양을 결정합니다. 다음 표에는 모든 얼굴 속성, 가능한 값 및 효과가 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="012a0b361ae7bc306740626a022ce7edb06aed35" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Filling&lt;/em&gt; means adjusting the lengths of lines (by moving the line breaks) so that they are nearly (but no greater than) a specified maximum width. Additionally, lines can be &lt;em&gt;justified&lt;/em&gt;, which means inserting spaces to make the left and/or right margins line up precisely. The width is controlled by the variable &lt;code&gt;fill-column&lt;/code&gt;. For ease of reading, lines should be no longer than 70 or so columns.</source>
          <target state="translated">&lt;em&gt;채우기&lt;/em&gt; 는 줄 바꿈을 이동하여 줄의 길이를 조정하여 지정된 최대 너비에 가깝게 (하지만 그보다 크지 않음)하는 것을 의미합니다. 또한 줄을 &lt;em&gt;맞출&lt;/em&gt; 수 있습니다. 즉, 왼쪽 및 / 또는 오른쪽 여백이 정확하게 &lt;em&gt;정렬&lt;/em&gt; 되도록 공백을 삽입해야합니다. 너비는 변수 &lt;code&gt;fill-column&lt;/code&gt; 에 의해 제어 됩니다 . 읽기 쉽도록 줄은 70 개 정도의 열을 넘지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="6be21549dd8cb0cb5b56d3378fa69c057f0887ec" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Font Lock mode&lt;/em&gt; is a buffer-local minor mode that automatically attaches &lt;code&gt;face&lt;/code&gt; properties to certain parts of the buffer based on their syntactic role. How it parses the buffer depends on the major mode; most major modes define syntactic criteria for which faces to use in which contexts. This section explains how to customize Font Lock for a particular major mode.</source>
          <target state="translated">&lt;em&gt;글꼴 잠금 모드&lt;/em&gt; 는 해당 구문 역할에 따라 버퍼의 특정 부분에 &lt;code&gt;face&lt;/code&gt; 속성을 자동으로 연결하는 버퍼 로컬 부 모드입니다 . 버퍼를 구문 분석하는 방법은 주 모드에 따라 다릅니다. 대부분의 주요 모드는 어떤 상황에서 사용할 얼굴에 대한 구문 기준을 정의합니다. 이 섹션에서는 특정 주요 모드에 대해 글꼴 잠금을 사용자 정의하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="6ebc87bbb7e17bed3e9c29a0284f9bee1e5c5c1a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Formatting&lt;/em&gt; means constructing a string by substituting computed values at various places in a constant string. This constant string controls how the other values are printed, as well as where they appear; it is called a &lt;em&gt;format string&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;형식화&lt;/em&gt; 는 상수 문자열의 여러 위치에서 계산 된 값을 대체하여 문자열을 구성하는 것을 의미합니다. 이 상수 문자열은 다른 값이 인쇄되는 방법과 표시되는 위치를 제어합니다. 이를 &lt;em&gt;형식 문자열&lt;/em&gt; 이라고 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="0e507faa00934023f42170624d268ab633490367" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Fringe indicators&lt;/em&gt; are tiny icons displayed in the window fringe to indicate truncated or continued lines, buffer boundaries, etc.</source>
          <target state="translated">&lt;em&gt;프린지 표시기&lt;/em&gt; 는 잘 리거나 연속 된 선, 버퍼 경계 등을 나타 내기 위해 창 가장자리에 &lt;em&gt;표시&lt;/em&gt; 되는 작은 아이콘입니다.</target>
        </trans-unit>
        <trans-unit id="c4a2bfc783163eddcde352fbc4dd6772b257ca00" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Generic modes&lt;/em&gt; are simple major modes with basic support for comment syntax and Font Lock mode. To define a generic mode, use the macro &lt;code&gt;define-generic-mode&lt;/code&gt;. See the file</source>
          <target state="translated">&lt;em&gt;일반 모드&lt;/em&gt; 는 주석 구문 및 글꼴 잠금 모드를 기본적으로 지원하는 단순 주요 모드입니다. 일반 모드를 정의하려면 define &lt;code&gt;define-generic-mode&lt;/code&gt; 매크로를 사용하세요 . 파일보기</target>
        </trans-unit>
        <trans-unit id="112776f7781a51db193688bdbd2c5e934d7ba37b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Glyphless characters&lt;/em&gt; are characters which are displayed in a special way, e.g., as a box containing a hexadecimal code, instead of being displayed literally. These include characters which are explicitly defined to be glyphless, as well as characters for which there is no available font (on a graphical display), and characters which cannot be encoded by the terminal&amp;rsquo;s coding system (on a text terminal).</source>
          <target state="translated">&lt;em&gt;글리프가없는 문자&lt;/em&gt; 는 문자 그대로 표시되는 대신 16 진수 코드를 포함하는 상자와 같이 특별한 방식으로 표시되는 문자입니다. 여기에는 글리프가없는 것으로 명시 적으로 정의 된 문자, 사용 가능한 글꼴 (그래픽 디스플레이에서)이없는 문자 및 터미널의 코딩 시스템 (텍스트 터미널에서)으로 인코딩 할 수없는 문자가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="4fcbce64e8b9f4d24225b3774ba8d80b3cad522d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Horizontal scrolling&lt;/em&gt; means shifting the image in the window left or right by a specified multiple of the normal character width. Each window has a &lt;em&gt;horizontal scroll position&lt;/em&gt;, which is a number, never less than zero. It specifies how far to shift the contents left. Shifting the window contents left generally makes all or part of some characters disappear off the left, and all or part of some other characters appear at the right. The usual value is zero.</source>
          <target state="translated">&lt;em&gt;수평 스크롤&lt;/em&gt; 은 창에있는 이미지를 일반 문자 너비의 지정된 배수만큼 왼쪽 또는 오른쪽으로 이동하는 것을 의미합니다. 각 창에는 &lt;em&gt;수평 스크롤 위치&lt;/em&gt; 가 있으며, 숫자는 0보다 작지 않습니다. 콘텐츠를 왼쪽으로 이동하는 거리를 지정합니다. 창 내용을 왼쪽으로 이동하면 일반적으로 일부 문자의 전체 또는 일부가 왼쪽에서 사라지고 일부 다른 문자의 전체 또는 일부가 오른쪽에 나타납니다. 일반적인 값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="93402787644d1d7eafe5bba491536d2c7912cfa7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Imenu&lt;/em&gt; is a feature that lets users select a definition or section in the buffer, from a menu which lists all of them, to go directly to that location in the buffer. Imenu works by constructing a buffer index which lists the names and buffer positions of the definitions, or other named portions of the buffer; then the user can choose one of them and move point to it. Major modes can add a menu bar item to use Imenu using &lt;code&gt;imenu-add-to-menubar&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;Imenu&lt;/em&gt; 는 사용자가 모두를 나열하는 메뉴에서 버퍼의 정의 또는 섹션을 선택하여 버퍼의 해당 위치로 직접 이동할 수있는 기능입니다. Imenu는 정의의 이름과 버퍼 위치 또는 버퍼의 다른 명명 된 부분을 나열하는 버퍼 인덱스를 구성하여 작동합니다. 그런 다음 사용자는 그중 하나를 선택하고 포인트를 이동할 수 있습니다. 주요 모드는 &lt;code&gt;imenu-add-to-menubar&lt;/code&gt; 를 사용하여 Imenu를 사용하는 메뉴 모음 항목을 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2d23fc3b6ee48861c0752ea1530c14e065028d3f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Input methods&lt;/em&gt; provide convenient ways of entering non-</source>
          <target state="translated">&lt;em&gt;입력 방법&lt;/em&gt; 은 비</target>
        </trans-unit>
        <trans-unit id="3ee20567a4dabe85bc7a2e8fd9c60352f47fec7f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Insertion&lt;/em&gt; means adding new text to a buffer. The inserted text goes at point&amp;mdash;between the character before point and the character after point. Some insertion functions leave point before the inserted text, while other functions leave it after. We call the former insertion &lt;em&gt;after point&lt;/em&gt; and the latter insertion &lt;em&gt;before point&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;삽입&lt;/em&gt; 은 버퍼에 새 텍스트를 추가하는 것을 의미합니다. 삽입 된 텍스트는 포인트 앞의 문자와 포인트 뒤의 문자 사이에 위치합니다. 일부 삽입 기능은 삽입 된 텍스트 앞에 포인트를두고 다른 기능은 포인트를 뒤에 둡니다. 전자는 &lt;em&gt;point 뒤에&lt;/em&gt; 삽입하고 후자는 &lt;em&gt;point 앞에&lt;/em&gt; 삽입이라고 부릅니다 .</target>
        </trans-unit>
        <trans-unit id="450e3407eb4f03adcc2aec7c838ee4624ba54573" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Key lookup&lt;/em&gt; is the process of finding the binding of a key sequence from a given keymap. The execution or use of the binding is not part of key lookup.</source>
          <target state="translated">&lt;em&gt;키 조회&lt;/em&gt; 는 주어진 키맵에서 키 시퀀스의 바인딩을 찾는 프로세스입니다. 바인딩의 실행 또는 사용은 키 조회의 일부가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="8fa89626f95af4781c407f7abfa45810f2067b99" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Kill functions&lt;/em&gt; delete text like the deletion functions, but save it so that the user can reinsert it by &lt;em&gt;yanking&lt;/em&gt;. Most of these functions have &amp;lsquo;</source>
          <target state="translated">&lt;em&gt;Kill 함수&lt;/em&gt; 는 삭제 함수처럼 텍스트를 삭제하지만 사용자가 &lt;em&gt;yanking&lt;/em&gt; 하여 다시 삽입 할 수 있도록 저장합니다 . 이러한 기능의 대부분에는 '</target>
        </trans-unit>
        <trans-unit id="e750f743a960078ed373cd9c29df128dfa4aef0e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Killing a buffer&lt;/em&gt; makes its name unknown to Emacs and makes the memory space it occupied available for other use.</source>
          <target state="translated">&lt;em&gt;버퍼&lt;/em&gt; 를 &lt;em&gt;죽이는 것은&lt;/em&gt; Emacs가 그 이름을 알 수 없게하여 그 &lt;em&gt;버퍼&lt;/em&gt; 가 차지한 메모리 공간을 다른 용도로 사용할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="d02ce601b5b10f3d058800e2800ad7f708907fbf" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Macros&lt;/em&gt; enable you to define new control constructs and other language features. A macro is defined much like a function, but instead of telling how to compute a value, it tells how to compute another Lisp expression which will in turn compute the value. We call this expression the &lt;em&gt;expansion&lt;/em&gt; of the macro.</source>
          <target state="translated">&lt;em&gt;매크로를&lt;/em&gt; 사용하면 새로운 제어 구조 및 기타 언어 기능을 정의 할 수 있습니다. 매크로는 함수와 매우 유사하게 정의되지만 값을 계산하는 방법을 알려주는 대신 값을 계산할 다른 Lisp 표현식을 계산하는 방법을 알려줍니다. 이 표현을 매크로 의 &lt;em&gt;확장&lt;/em&gt; 이라고합니다.</target>
        </trans-unit>
        <trans-unit id="b7f04fd1b052b638ef4bddfcc5d3e36d470f8ae2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Narrowing&lt;/em&gt; means limiting the text addressable by Emacs editing commands to a limited range of characters in a buffer. The text that remains addressable is called the &lt;em&gt;accessible portion&lt;/em&gt; of the buffer.</source>
          <target state="translated">&lt;em&gt;축소&lt;/em&gt; 는 Emacs 편집 명령으로 처리 할 수있는 텍스트를 버퍼의 제한된 문자 범위로 제한하는 것을 의미합니다. 주소를 지정할 수있는 텍스트를 버퍼 의 &lt;em&gt;액세스 가능한 부분&lt;/em&gt; 이라고합니다 .</target>
        </trans-unit>
        <trans-unit id="f76cc0b3cbad8d2db0f2f0631879949e24049985" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Point&lt;/em&gt; is a special buffer position used by many editing commands, including the self-inserting typed characters and text insertion functions. Other commands move point through the text to allow editing and insertion at different places.</source>
          <target state="translated">&lt;em&gt;Point&lt;/em&gt; 는 자체 삽입 입력 문자 및 텍스트 삽입 기능을 포함하여 많은 편집 명령에서 사용되는 특수 버퍼 위치입니다. 다른 명령은 텍스트에서 포인트를 이동하여 다른 위치에서 편집하고 삽입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f1d8b41be48e34b694c6ff7cfd0bf33a88ecdc2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Printing&lt;/em&gt; a Lisp object means producing text that represents that object&amp;mdash;converting the object to its &lt;em&gt;printed representation&lt;/em&gt; (see &lt;a href=&quot;printed-representation#Printed-Representation&quot;&gt;Printed Representation&lt;/a&gt;). Printing the cons cell described above produces the text &amp;lsquo;</source>
          <target state="translated">&lt;em&gt;인쇄&lt;/em&gt; 자사의 오브젝트를 오브젝트 변환 나타내는 텍스트 생산 리스프 오브젝트 수단 &lt;em&gt;인쇄 된 표현&lt;/em&gt; (참조 &lt;a href=&quot;printed-representation#Printed-Representation&quot;&gt;인쇄 표현&lt;/a&gt; ). 위에서 설명한 단점 셀을 인쇄하면 '</target>
        </trans-unit>
        <trans-unit id="3486a4d997a0991471cc5bda965e32d990483810" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Printing&lt;/em&gt; and &lt;em&gt;reading&lt;/em&gt; are the operations of converting Lisp objects to textual form and vice versa. They use the printed representations and read syntax described in &lt;a href=&quot;lisp-data-types#Lisp-Data-Types&quot;&gt;Lisp Data Types&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;인쇄&lt;/em&gt; 및 &lt;em&gt;읽기&lt;/em&gt; 는 Lisp 개체를 텍스트 형식으로 또는 그 반대로 변환하는 작업입니다. 그들은 인쇄 된 표현을 사용하고 &lt;a href=&quot;lisp-data-types#Lisp-Data-Types&quot;&gt;Lisp 데이터 유형에&lt;/a&gt; 설명 된 구문을 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="2f09674ebe8ae04d0dfaa08942261acf706c3808" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Radio buttons&lt;/em&gt; are a group of menu items, in which at any time one and only one is selected. There should be a variable whose value says which one is selected at any time. The &lt;var&gt;selected&lt;/var&gt; form for each radio button in the group should check whether the variable has the right value for selecting that button. Clicking on the button should set the variable so that the button you clicked on becomes selected.</source>
          <target state="translated">&lt;em&gt;라디오 버튼&lt;/em&gt; 은 메뉴 항목 그룹으로, 언제든지 하나만 선택됩니다. 값이 언제든지 선택되는 변수가 있어야합니다. &lt;var&gt;selected&lt;/var&gt; 그룹의 각 라디오 버튼 형태의 변수가 그 버튼을 선택하기위한 적절한 값을 가지고 있는지 여부를 확인한다. 버튼을 클릭하면 클릭 한 버튼이 선택되도록 변수를 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="ab34954a6344cc9f97aee9484c997887b7839fdc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Raw bytes&lt;/em&gt; are non-</source>
          <target state="translated">&lt;em&gt;원시 바이트&lt;/em&gt; 는</target>
        </trans-unit>
        <trans-unit id="ed4269883b3c79ca4adc800e4219a3f334e69fa5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Reading&lt;/em&gt; a Lisp object means parsing a Lisp expression in textual form and producing a corresponding Lisp object. This is how Lisp programs get into Lisp from files of Lisp code. We call the text the &lt;em&gt;read syntax&lt;/em&gt; of the object. For example, the text &amp;lsquo;</source>
          <target state="translated">&lt;em&gt;읽기&lt;/em&gt; 리스프 오브젝트 수단 텍스트 형태의 리스프 발현을 분석하고 대응 리스프 객체를 생성한다. 이것이 Lisp 프로그램이 Lisp 코드 파일에서 Lisp로 들어가는 방법입니다. 텍스트를 개체 의 &lt;em&gt;읽기 구문&lt;/em&gt; 이라고합니다. 예를 들어 '</target>
        </trans-unit>
        <trans-unit id="542ea923b04cc1dd1ce08b789da1b9d9a6edaf8f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;SVG paths&lt;/em&gt; allow creation of complex images by combining lines, curves, arcs, and other basic shapes. The functions described below allow invoking SVG path commands from a Lisp program.</source>
          <target state="translated">&lt;em&gt;SVG 경로를&lt;/em&gt; 사용하면 선, 곡선, 호 및 기타 기본 모양을 결합하여 복잡한 이미지를 만들 수 있습니다. 아래에 설명 된 함수는 Lisp 프로그램에서 SVG 경로 명령을 호출 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="73c188badc81bf3fc4092200e27bb45f1e16c9ec" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Selective display&lt;/em&gt; refers to a pair of related features for hiding certain lines on the screen.</source>
          <target state="translated">&lt;em&gt;선택적 표시&lt;/em&gt; 는 화면에서 특정 줄을 숨기는 한 쌍의 관련 기능을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="bf63ae9c067ac9de03cc843159e0246f28041dea" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Sending a signal&lt;/em&gt; to a subprocess is a way of interrupting its activities. There are several different signals, each with its own meaning. The set of signals and their names is defined by the operating system. For example, the signal &lt;code&gt;SIGINT&lt;/code&gt; means that the user has typed</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;하위 프로세스에 &lt;em&gt;신호&lt;/em&gt; 를 &lt;em&gt;보내는 것은&lt;/em&gt; 활동을 중단하는 방법입니다. 각각 고유 한 의미를 가진 여러 가지 신호가 있습니다. 신호 세트와 이름은 운영 체제에 의해 정의됩니다. 예를 들어 &lt;code&gt;SIGINT&lt;/code&gt; 신호 는 사용자가 다음을 입력했음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8517a23cb3410f1a9a7dbb62a23f1121a3f4bfb7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Signaling&lt;/em&gt; an error means beginning error processing. Error processing normally aborts all or part of the running program and returns to a point that is set up to handle the error (see &lt;a href=&quot;processing-of-errors#Processing-of-Errors&quot;&gt;Processing of Errors&lt;/a&gt;). Here we describe how to signal an error.</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;오류 &lt;em&gt;신호&lt;/em&gt; 는 오류 처리 시작을 의미합니다. 오류 처리는 일반적으로 실행중인 프로그램의 전체 또는 일부를 중단하고 오류를 처리하도록 설정된 지점으로 돌아갑니다 ( &lt;a href=&quot;processing-of-errors#Processing-of-Errors&quot;&gt;오류 처리&lt;/a&gt; 참조 ). 여기에서는 오류 신호를 보내는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="4e9d8ee4cad5d0529cec696f38446bdf19fdb896" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Textual scrolling&lt;/em&gt; means moving the text up or down through a window. It works by changing the window&amp;rsquo;s display-start location. It may also change the value of &lt;code&gt;window-point&lt;/code&gt; to keep point on the screen (see &lt;a href=&quot;window-point#Window-Point&quot;&gt;Window Point&lt;/a&gt;).</source>
          <target state="translated">&lt;em&gt;텍스트 스크롤&lt;/em&gt; 은 창을 통해 텍스트를 위나 아래로 이동하는 것을 의미합니다. 창의 표시 시작 위치를 변경하여 작동합니다. 또한 &lt;code&gt;window-point&lt;/code&gt; 를 유지하기 위해 window-point 의 값을 변경할 수도 있습니다 ( &lt;a href=&quot;window-point#Window-Point&quot;&gt;Window Point&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="9740e3157a8155d498bbc4297186350c293bbe46" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Tooltips&lt;/em&gt; are special frames (see &lt;a href=&quot;frames#Frames&quot;&gt;Frames&lt;/a&gt;) that are used to display helpful hints (a.k.a. &amp;ldquo;tips&amp;rdquo;) related to the current position of the mouse pointer. Emacs uses tooltips to display help strings about active portions of text (see &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Special Properties&lt;/a&gt;) and about various UI elements, such as menu items (see &lt;a href=&quot;extended-menu-items#Extended-Menu-Items&quot;&gt;Extended Menu Items&lt;/a&gt;) and tool-bar buttons (see &lt;a href=&quot;tool-bar#Tool-Bar&quot;&gt;Tool Bar&lt;/a&gt;).</source>
          <target state="translated">&lt;em&gt;툴팁은&lt;/em&gt; 특별 프레임 (참조있는 &lt;a href=&quot;frames#Frames&quot;&gt;프레임을&lt;/a&gt; 유용한 힌트 마우스 포인터의 현재 위치에 관련된 (일명 &quot;팁&quot;)를 표시하는 데 사용됩니다). Emacs는 도구 설명을 사용하여 텍스트의 활성 부분 ( &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;특수 속성&lt;/a&gt; 참조 )과 메뉴 항목 ( &lt;a href=&quot;extended-menu-items#Extended-Menu-Items&quot;&gt;확장 메뉴 항목&lt;/a&gt; 참조 ) 및 도구 모음 버튼 ( &lt;a href=&quot;tool-bar#Tool-Bar&quot;&gt;도구 모음&lt;/a&gt; 참조)과 같은 다양한 UI 요소에 대한 도움말 문자열을 표시 합니다 .</target>
        </trans-unit>
        <trans-unit id="f32db6bb4b57bc264e0f679447e2ae5d29a9ba1a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Vertical fractional scrolling&lt;/em&gt; means shifting text in a window up or down by a specified multiple or fraction of a line. Emacs uses it, for example, on images and screen lines which are taller than the window. Each window has a &lt;em&gt;vertical scroll position&lt;/em&gt;, which is a number, never less than zero. It specifies how far to raise the contents of the window when displaying them. Raising the window contents generally makes all or part of some lines disappear off the top, and all or part of some other lines appear at the bottom. The usual value is zero.</source>
          <target state="translated">&lt;em&gt;수직 부분 스크롤링&lt;/em&gt; 이란 창에있는 텍스트를 지정된 줄의 배수 또는 부분만큼 위아래로 &lt;em&gt;이동&lt;/em&gt; 하는 것을 의미합니다. 예를 들어, Emacs는 창보다 큰 이미지와 화면 라인에서이를 사용합니다. 각 창에는 &lt;em&gt;수직 스크롤 위치&lt;/em&gt; 가 있으며 숫자는 0보다 작지 않습니다. 창 내용을 표시 할 때 창의 내용을 얼마나 올릴 지 지정합니다. 창 내용을 올리면 일반적으로 일부 줄의 전체 또는 일부가 위쪽에서 사라지고 일부 다른 줄의 전체 또는 일부가 아래쪽에 나타납니다. 일반적인 값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="bd79e7372baa17750e541bfbfffa6606962eb07f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Warning&lt;/em&gt;: Since the result is floating point, it may not be exact. Do not use this function if precise time stamps are required. For example, on typical systems &lt;code&gt;(float-time '(1 . 10))&lt;/code&gt; displays as &amp;lsquo;</source>
          <target state="translated">&lt;em&gt;경고&lt;/em&gt; : 결과는 부동 소수점이므로 정확하지 않을 수 있습니다. 정확한 타임 스탬프가 필요한 경우이 기능을 사용하지 마십시오. 예를 들어, 일반적인 시스템에서 &lt;code&gt;(float-time '(1 . 10))&lt;/code&gt; 은'</target>
        </trans-unit>
        <trans-unit id="b7ead6f25bbfb241ae5a10952f368db3cd8e2925" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Warnings&lt;/em&gt; are a facility for a program to inform the user of a possible problem, but continue running.</source>
          <target state="translated">&lt;em&gt;경고&lt;/em&gt; 는 프로그램이 가능한 문제를 사용자에게 알리지 만 계속 실행하는 기능입니다.</target>
        </trans-unit>
        <trans-unit id="5800c704dda84085ba62504ba165321ee93d8e57" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;autoload object&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;객체 자동로드&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8ae8f2277c5b62b3d53dc4d888c37dc29d4b795a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;byte-code function&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;바이트 코드 기능&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="eb6a46032363c9a7fc5a4b8a88bdcede5d9a80aa" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;closure&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;closure&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9be7baeb66ad7e95f9d0eded08808a28a890c19a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;command&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;command&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="661ff4cb9bee36474098da7a6f259f9a4407b987" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;lambda expression&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;람다 식&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ed4a26bd2219a669612e9e3c2b7b5c6da73a19c5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;macro&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;macro&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e5e68111703f0fb6a63a3104797560ce66e23edc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;primitive&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;primitive&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b9022b2a3b0031d43e1cc771ebb9cb4bda490457" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;special form&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;특별한 형태&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bd34485d7828eb7e27180a104aa1a4cd030fa4b5" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;ASCII&lt;/small&gt; control characters such as</source>
          <target state="translated">&lt;small&gt;다음&lt;/small&gt; 과 같은 &lt;small&gt;ASCII&lt;/small&gt; 제어 문자</target>
        </trans-unit>
        <trans-unit id="70306c232df57307eafd76afbab83c839cc46f47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Caution:&lt;/strong&gt; it is easy to make a mistake when using the &lt;code&gt;save-restriction&lt;/code&gt; construct. Read the entire description here before you try it.</source>
          <target state="translated">&lt;strong&gt;주의 : &lt;/strong&gt; &lt;code&gt;save-restriction&lt;/code&gt; 구조를 사용할 때 실수하기 쉽습니다 . 시도하기 전에 여기에서 전체 설명을 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="fedd7bf18771ffbebe7137b31f6e3297e5df6d53" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Common Lisp Note:&lt;/strong&gt; At top level, &lt;code&gt;eval-when-compile&lt;/code&gt; is analogous to the Common Lisp idiom &lt;code&gt;(eval-when (compile eval) &amp;hellip;)&lt;/code&gt;. Elsewhere, the Common Lisp &amp;lsquo;</source>
          <target state="translated">&lt;strong&gt;Common Lisp 참고 :&lt;/strong&gt; 최상위 수준에서 &lt;code&gt;eval-when-compile&lt;/code&gt; 은 Common Lisp 관용구 &lt;code&gt;(eval-when (compile eval) &amp;hellip;)&lt;/code&gt; 유사합니다 . 다른 곳에서는 Common Lisp '</target>
        </trans-unit>
        <trans-unit id="4e710f2d7f73f4a8fe8b17904699b0f862c6c885" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Common Lisp Note:&lt;/strong&gt; Common Lisp has different meanings for &lt;var&gt;dow&lt;/var&gt; and &lt;var&gt;utcoff&lt;/var&gt;, and its &lt;var&gt;second&lt;/var&gt; is an integer between 0 and 59 inclusive.</source>
          <target state="translated">&lt;strong&gt;CL의 주 :&lt;/strong&gt; CL의 다른 의미가 갖는 &lt;var&gt;dow&lt;/var&gt; 와 &lt;var&gt;utcoff&lt;/var&gt; 를 , 그 &lt;var&gt;second&lt;/var&gt; 0에서 59까지의 정수이다.</target>
        </trans-unit>
        <trans-unit id="40ee60ee9fcbc30da4bad494a245522e8219bb9d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Do not try to put symbols in an obarray yourself.&lt;/strong&gt; This does not work&amp;mdash;only &lt;code&gt;intern&lt;/code&gt; can enter a symbol in an obarray properly.</source>
          <target state="translated">&lt;strong&gt;오바 레이에 기호를 직접 넣으려고하지 마십시오. &lt;/strong&gt;이것은 작동하지 않습니다. &lt;code&gt;intern&lt;/code&gt; 만이 오바 레이에 기호를 올바르게 입력 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38de59784bef692535056aa1a8f0e471c6f3a1f4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;MS-DOS note:&lt;/strong&gt; On MS-DOS, there is no such thing as an executable file mode bit. So &lt;code&gt;file-modes&lt;/code&gt; considers a file executable if its name ends in one of the standard executable extensions, such as</source>
          <target state="translated">&lt;strong&gt;MS-DOS 참고 :&lt;/strong&gt; MS-DOS에는 실행 파일 모드 비트와 같은 것이 없습니다. 따라서 &lt;code&gt;file-modes&lt;/code&gt; 는 이름이 다음과 같은 표준 실행 파일 확장 중 하나로 끝나는 경우 파일 실행 파일을 고려합니다.</target>
        </trans-unit>
        <trans-unit id="6d4102b9a0d3b47cc4a8ba5dd78a2e9f73e6b1b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Please note:&lt;/strong&gt; Each &amp;lsquo;</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 각 '</target>
        </trans-unit>
        <trans-unit id="6aae4a6180fd094fd06245c7fbdba28ea2ad76d3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Please note:&lt;/strong&gt; For historical compatibility, special characters are treated as ordinary ones if they are in contexts where their special meanings make no sense. For example, &amp;lsquo;</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 역사적 호환성을 위해 특수 문자는 특수한 의미가 의미가없는 컨텍스트에있는 경우 일반 문자로 처리됩니다. 예 : '</target>
        </trans-unit>
        <trans-unit id="e1c151cdbdbd417cac114e5aec12f7f9f9b66ea0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Please note:&lt;/strong&gt; The argument &lt;var&gt;program&lt;/var&gt; contains only the name of the program file; it may not contain any command-line arguments. You must use a separate argument, &lt;var&gt;args&lt;/var&gt;, to provide those, as described below.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt; &lt;var&gt;program&lt;/var&gt; 인수 는 프로그램 파일의 이름 만 포함합니다. 명령 줄 인수를 포함 할 수 없습니다. 아래에 설명 된대로 별도의 인수 &lt;var&gt;args&lt;/var&gt; 를 사용하여 이를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="3e5f3511148dd7847670eff73efe5ab3c4fa41c9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Please note:&lt;/strong&gt; Use this function only if you want the user to see that the mark has moved, and you want the previous mark position to be lost. Normally, when a new mark is set, the old one should go on the &lt;code&gt;mark-ring&lt;/code&gt;. For this reason, most applications should use &lt;code&gt;push-mark&lt;/code&gt; and &lt;code&gt;pop-mark&lt;/code&gt;, not &lt;code&gt;set-mark&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 기능은 사용자가 마크가 이동 한 것을보고 이전 마크 위치를 잃어 버리기를 원하는 경우에만 사용하십시오. 일반적으로 새 마크가 설정되면 이전 마크가 &lt;code&gt;mark-ring&lt;/code&gt; 에 있어야합니다 . 이러한 이유로 대부분의 애플리케이션은 &lt;code&gt;set-mark&lt;/code&gt; 가 아닌 &lt;code&gt;push-mark&lt;/code&gt; 및 &lt;code&gt;pop-mark&lt;/code&gt; 를 사용해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="1c5a80c4486e1ea38490953d74749fe3a3c8c080" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Please note:&lt;/strong&gt;&lt;code&gt;create-file-buffer&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; associate the new buffer with a file and does not select the buffer. It also does not use the default major mode.</source>
          <target state="translated">&lt;strong&gt;제발 참고 : &lt;/strong&gt; &lt;code&gt;create-file-buffer&lt;/code&gt; 않습니다 &lt;em&gt;없습니다&lt;/em&gt; 파일과 새로운 버퍼를 연결하고 버퍼를 선택하지 않습니다. 또한 기본 주 모드를 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a645ff0054371611b3b65b133b649ed3610b6564" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Usage note:&lt;/strong&gt; Don&amp;rsquo;t use &lt;code&gt;x-popup-menu&lt;/code&gt; to display a menu if you could do the job with a prefix key defined with a menu keymap. If you use a menu keymap to implement a menu,</source>
          <target state="translated">&lt;strong&gt;사용법 참고 :&lt;/strong&gt; 메뉴 키맵으로 정의 된 접두사 키로 작업을 수행 할 수 있다면 &lt;code&gt;x-popup-menu&lt;/code&gt; 를 표시하기 위해 x-popup-menu 를 사용하지 마십시오 . 메뉴 키맵을 사용하여 메뉴를 구현하는 경우</target>
        </trans-unit>
        <trans-unit id="da6799279e920a1a3a23e11b28477a3c522ee7c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Changing the string by substituting characters does change the name of the symbol, but fails to update the obarray, so don&amp;rsquo;t do it!</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 문자를 대체하여 문자열을 변경하면 기호 이름이 변경되지만 Obarray를 업데이트하지 못하므로 수행하지 마십시오!</target>
        </trans-unit>
        <trans-unit id="f42b1c51152dd5561d6e32556f381fe792e7644d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Coding systems such as &lt;code&gt;undecided&lt;/code&gt;, which determine the coding system from the data, do not work entirely reliably with asynchronous subprocess output. This is because Emacs handles asynchronous subprocess output in batches, as it arrives. If the coding system leaves the character code conversion unspecified, or leaves the end-of-line conversion unspecified, Emacs must try to detect the proper conversion from one batch at a time, and this does not always work.</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 데이터에서 코딩 시스템을 결정하는 &lt;code&gt;undecided&lt;/code&gt; 와 같은 코딩 시스템은 비동기 하위 프로세스 출력에서 ​​완전히 안정적으로 작동하지 않습니다. 이는 Emacs가 비동기 하위 프로세스 출력이 도착하면 일괄 처리하기 때문입니다. 코딩 시스템이 문자 코드 변환을 지정하지 않거나 줄 끝 변환을 지정하지 않은 상태로두면 Emacs는 한 번에 하나의 배치에서 적절한 변환을 감지해야하며 이것이 항상 작동하는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="d7a32311cb98f8982192a3a0cfb3fbd4012739fa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Coding systems such as &lt;code&gt;undecided&lt;/code&gt;, which determine the coding system from the data, do not work entirely reliably with asynchronous subprocess output. This is because Emacs has to process asynchronous subprocess output in batches, as it arrives. Emacs must try to detect the proper coding system from one batch at a time, and this does not always work. Therefore, if at all possible, specify a coding system that determines both the character code conversion and the end of line conversion&amp;mdash;that is, one like &lt;code&gt;latin-1-unix&lt;/code&gt;, rather than &lt;code&gt;undecided&lt;/code&gt; or &lt;code&gt;latin-1&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 데이터에서 코딩 시스템을 결정하는 &lt;code&gt;undecided&lt;/code&gt; 와 같은 코딩 시스템은 비동기 하위 프로세스 출력에서 ​​완전히 안정적으로 작동하지 않습니다. 이는 Emacs가 비동기 하위 프로세스 출력이 도착하면 일괄 처리해야하기 때문입니다. Emacs는 한 번에 하나의 배치에서 적절한 코딩 시스템을 감지해야하며 이것이 항상 작동하는 것은 아닙니다. 따라서 가능하다면 문자 코드 변환과 줄 끝 변환을 모두 결정하는 코딩 시스템을 지정하십시오. 즉, &lt;code&gt;undecided&lt;/code&gt; 또는 &lt;code&gt;latin-1&lt;/code&gt; 이 아니라 &lt;code&gt;latin-1-unix&lt;/code&gt; 와 같은 시스템을 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="36f77abc0ee8492d9c84e64781a102965a17ca14" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Do not design an element of &lt;code&gt;font-lock-keywords&lt;/code&gt; to match text which spans lines; this does not work reliably. For details, see &lt;a href=&quot;multiline-font-lock#Multiline-Font-Lock&quot;&gt;Multiline Font Lock&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;경고 : 여러&lt;/strong&gt; 줄에 걸쳐있는 텍스트와 일치하도록 &lt;code&gt;font-lock-keywords&lt;/code&gt; 요소를 디자인하지 마십시오 . 이것은 안정적으로 작동하지 않습니다. 자세한 내용은 여러 줄 &lt;a href=&quot;multiline-font-lock#Multiline-Font-Lock&quot;&gt;글꼴 잠금을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="85a74edcffc0a92c3e7b4d248d547a8ecec6f582" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Don&amp;rsquo;t assume that you should use &lt;code&gt;make-variable-buffer-local&lt;/code&gt; for user-option variables, simply because users &lt;em&gt;might&lt;/em&gt; want to customize them differently in different buffers. Users can make any variable local, when they wish to. It is better to leave the choice to them.</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 사용자 옵션 변수에 대해 &lt;code&gt;make-variable-buffer-local&lt;/code&gt; 을 사용해야한다고 가정하지 마십시오 &lt;strong&gt;.&lt;/strong&gt; 사용자 &lt;em&gt;가&lt;/em&gt; 다른 버퍼에서 다르게 사용자 정의 할 &lt;em&gt;수&lt;/em&gt; 있기 때문 입니다. 사용자는 원하는 경우 모든 변수를 로컬로 만들 수 있습니다. 선택권을 그들에게 맡기는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="5c82827514f3c4432ba7da9ea921f90a74bde2b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Don&amp;rsquo;t use this function in Lisp programs!</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; Lisp 프로그램에서이 기능을 사용하지 마십시오!</target>
        </trans-unit>
        <trans-unit id="91b5bf064a888797b6873fc939ffb0b98c08f120" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; If the changes you combine occur in widely scattered parts of the buffer, this will still work, but it is not advisable, because it may lead to inefficient behavior for some change hook functions.</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 결합한 변경 사항이 버퍼의 광범위하게 분산 된 부분에서 발생하는 경우에도 여전히 작동하지만 일부 변경 후크 기능에 대해 비효율적 인 동작을 유발할 수 있으므로 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="45e9aba6be8fa67b5877a89186eb307eaa7e3eea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; If this function is called from within a &lt;code&gt;save-excursion&lt;/code&gt; form, the current buffer will be set to &lt;var&gt;buffer&lt;/var&gt; upon leaving the form, since the marker used by &lt;code&gt;save-excursion&lt;/code&gt; to save the position and buffer will be swapped as well.</source>
          <target state="translated">&lt;strong&gt;주의 :&lt;/strong&gt; 이 함수는 내에서 호출되는 경우 &lt;code&gt;save-excursion&lt;/code&gt; 형태, 현재 버퍼로 설정한다 &lt;var&gt;buffer&lt;/var&gt; 에 의해 사용 된 마커 이후 형태를 이탈에 &lt;code&gt;save-excursion&lt;/code&gt; 위치 저장 버퍼가 아니라 교체 될 것이다.</target>
        </trans-unit>
        <trans-unit id="2bbac455862d3d9d7a2292fdfceca6f3801d0b5b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; If you use a &lt;code&gt;defconst&lt;/code&gt; or &lt;code&gt;defvar&lt;/code&gt; special form while the variable has a local binding (made with &lt;code&gt;let&lt;/code&gt;, or a function argument), it sets the local binding rather than the global binding. This is not what you usually want. To prevent this, use these special forms at top level in a file, where normally no local binding is in effect, and make sure to load the file before making a local binding for the variable.</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 변수에 로컬 바인딩 ( &lt;code&gt;let&lt;/code&gt; 또는 함수 인수 로 만든)이있는 동안 &lt;code&gt;defconst&lt;/code&gt; 또는 &lt;code&gt;defvar&lt;/code&gt; 특수 형식을 사용하는 경우 전역 바인딩이 아닌 로컬 바인딩을 설정합니다. 이것은 당신이 일반적으로 원하는 것이 아닙니다. 이를 방지하려면 일반적으로 로컬 바인딩이 적용되지 않는 파일의 최상위 수준에서 이러한 특수 형식을 사용하고 변수에 대한 로컬 바인딩을 만들기 전에 파일을로드해야합니다.</target>
        </trans-unit>
        <trans-unit id="05119ee0b2d49b617152ce6e37a3484e14f71a9c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; If you want to use your own string as a message verbatim, don&amp;rsquo;t just write &lt;code&gt;(message &lt;var&gt;string&lt;/var&gt;)&lt;/code&gt;. If &lt;var&gt;string&lt;/var&gt; contains &amp;lsquo;</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 자신의 문자열을 메시지 그대로 사용하려면 &lt;code&gt;(message &lt;var&gt;string&lt;/var&gt;)&lt;/code&gt; 작성하지 마십시오 . 만약 &lt;var&gt;string&lt;/var&gt; '포함</target>
        </trans-unit>
        <trans-unit id="33ecfae8a5840f6e86defbbccc38ab13acbfcf98" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; If you want to use your own string as an error message verbatim, don&amp;rsquo;t just write &lt;code&gt;(error &lt;var&gt;string&lt;/var&gt;)&lt;/code&gt;. If &lt;var&gt;string&lt;/var&gt;&lt;var&gt;string&lt;/var&gt; contains &amp;lsquo;</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 자신의 문자열을 그대로 오류 메시지로 사용하려면 &lt;code&gt;(error &lt;var&gt;string&lt;/var&gt;)&lt;/code&gt; 작성하지 마십시오 . 만약 &lt;var&gt;string&lt;/var&gt; &lt;var&gt;string&lt;/var&gt; '포함</target>
        </trans-unit>
        <trans-unit id="064430ad9cf0c8b3dcd0d4417ee59ce9c6716cbb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; In most cases, you should not use this function; use &lt;code&gt;make-temp-file&lt;/code&gt; instead! This function is susceptible to a race condition, between the &lt;code&gt;make-temp-name&lt;/code&gt; call and the creation of the file, which in some cases may cause a security hole.</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 대부분의 경우이 기능을 사용하지 마십시오. 사용 &lt;code&gt;make-temp-file&lt;/code&gt; 대신! 이 함수는 &lt;code&gt;make-temp-name&lt;/code&gt; 호출과 파일 생성 사이의 경쟁 조건에 영향을 받기 때문에 어떤 경우에는 보안 허점이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df977bf7983dca5df5b615b10e538a2c0edadc3f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Major mode commands must not call &lt;code&gt;font-lock-add-keywords&lt;/code&gt; under any circumstances, either directly or indirectly, except through their mode hooks. (Doing so would lead to incorrect behavior for some minor modes.) They should set up their rules for search-based fontification by setting &lt;code&gt;font-lock-keywords&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 주요 모드 명령은 모드 후크를 통하지 않는 한 직접 또는 간접적으로 어떤 상황에서도 &lt;code&gt;font-lock-add-keywords&lt;/code&gt; 를 호출해서는 안됩니다 . (그렇게하면 일부 부 모드에서 잘못된 동작이 발생할 수 있습니다.) 그들은 &lt;code&gt;font-lock-keywords&lt;/code&gt; 를 설정하여 검색 기반 글꼴 화에 대한 규칙을 설정해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="5bb321756a7688c8a3f5e181b1d0cb5de59a639b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Nested repetition operators can run for an indefinitely long time, if they lead to ambiguous matching. For example, trying to match the regular expression &amp;lsquo;</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 중첩 된 반복 연산자는 모호한 일치로 이어질 경우 무기한 오랫동안 실행할 수 있습니다. 예를 들어 정규 표현식 '</target>
        </trans-unit>
        <trans-unit id="23aa90d6d2217d7cb5e63a09251ea382a0ae7f51" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Ordinary insertion of text adjacent to the saved point value relocates the saved value, just as it relocates all markers. More precisely, the saved value is a marker with insertion type &lt;code&gt;nil&lt;/code&gt;. See &lt;a href=&quot;marker-insertion-types#Marker-Insertion-Types&quot;&gt;Marker Insertion Types&lt;/a&gt;. Therefore, when the saved point value is restored, it normally comes before the inserted text.</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 저장된 포인트 값에 인접한 텍스트를 일반적으로 삽입하면 모든 마커가 재배치되는 것처럼 저장된 값이 재배치됩니다. 보다 정확하게는 저장된 값은 삽입 유형이 &lt;code&gt;nil&lt;/code&gt; 인 마커입니다 . &lt;a href=&quot;marker-insertion-types#Marker-Insertion-Types&quot;&gt;마커 삽입 유형을&lt;/a&gt; 참조하십시오 . 따라서 저장된 포인트 값이 복원 될 때 일반적으로 삽입 된 텍스트 앞에옵니다.</target>
        </trans-unit>
        <trans-unit id="1e57b0c0a7f9166cb502f50cdef1217f6faa77be" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Setting this variable to non-&lt;code&gt;nil&lt;/code&gt; may have annoying effects. Various parts of Emacs catch errors in the normal course of affairs, and you may not even realize that errors happen there. If you need to debug code wrapped in &lt;code&gt;condition-case&lt;/code&gt;, consider using &lt;code&gt;condition-case-unless-debug&lt;/code&gt; (see &lt;a href=&quot;handling-errors#Handling-Errors&quot;&gt;Handling Errors&lt;/a&gt;).</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 이 변수를 &lt;code&gt;nil&lt;/code&gt; 이 아닌 값으로 설정하면 성가신 영향을 미칠 수 있습니다. Emacs의 다양한 부분은 정상적인 업무 과정에서 오류를 포착하고 거기에서 오류가 발생한다는 것을 깨닫지 못할 수도 있습니다. &lt;code&gt;condition-case&lt;/code&gt; 로 래핑 된 코드를 디버깅해야하는 경우 &lt;code&gt;condition-case-unless-debug&lt;/code&gt; 사용을 고려 하세요 ( &lt;a href=&quot;handling-errors#Handling-Errors&quot;&gt;오류 처리&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="99398d90876bc60a8ea5c21dd040f9efdb83a5ce" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Since receiving subprocess output sets this variable, it can change whenever Emacs waits; therefore, you should copy the value shortly after the function call that stores the value you are interested in.</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 수신 하위 프로세스 출력은이 변수를 설정하므로 Emacs가 대기 할 때마다 변경 될 수 있습니다. 따라서 관심있는 값을 저장하는 함수 호출 직후에 값을 복사해야합니다.</target>
        </trans-unit>
        <trans-unit id="80b59cca73514532244288020d72ec71b0c54f97" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; When a variable has buffer-local bindings in one or more buffers, &lt;code&gt;let&lt;/code&gt; rebinds the binding that&amp;rsquo;s currently in effect. For instance, if the current buffer has a buffer-local value, &lt;code&gt;let&lt;/code&gt; temporarily rebinds that. If no buffer-local bindings are in effect, &lt;code&gt;let&lt;/code&gt; rebinds the default value. If inside the &lt;code&gt;let&lt;/code&gt; you then change to a different current buffer in which a different binding is in effect, you won&amp;rsquo;t see the &lt;code&gt;let&lt;/code&gt; binding any more. And if you exit the &lt;code&gt;let&lt;/code&gt; while still in the other buffer, you won&amp;rsquo;t see the unbinding occur (though it will occur properly). Here is an example to illustrate:</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 변수가 버퍼 로컬 바인딩을 하나 이상의 버퍼에가있는 경우, &lt;code&gt;let&lt;/code&gt; 현재 효과에 바인딩 그의를 리 바인드합니다. 현재의 버퍼 - 버퍼 로컬 값을 갖는 경우, 예를 들면, &lt;code&gt;let&lt;/code&gt; 임시로 바인드. 버퍼 로컬 바인딩이 적용되지 않은 경우 &lt;code&gt;let&lt;/code&gt; 은 기본값을 리 바인드합니다. &lt;code&gt;let&lt;/code&gt; 내부에서 다른 바인딩이 적용되는 다른 현재 버퍼로 변경하면 &lt;code&gt;let&lt;/code&gt; 바인딩이 더 이상 표시되지 않습니다 . 다른 버퍼에있는 동안 &lt;code&gt;let&lt;/code&gt; 을 종료하면 바인딩 해제가 발생하는 것을 볼 수 없습니다 (올바르게 발생하더라도). 다음은 설명을위한 예입니다.</target>
        </trans-unit>
        <trans-unit id="3ba7ea0fe9530c6fcf03322393469252b0a2972b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; You must not alter the values of &lt;code&gt;after-change-functions&lt;/code&gt; within the body of a &lt;code&gt;combine-after-change-calls&lt;/code&gt; form.</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 변경 &lt;code&gt;after-change-functions&lt;/code&gt; &lt;code&gt;combine-after-change-calls&lt;/code&gt; 양식 의 본문 내에서 변경 후 함수 의 값을 변경해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="07d2995fbb542cf0b4f59c7660f01041c61d2c74" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; You must not alter the values of &lt;code&gt;before-change-functions&lt;/code&gt; or &lt;code&gt;after-change-function&lt;/code&gt; within &lt;var&gt;body&lt;/var&gt;.</source>
          <target state="translated">&lt;strong&gt;경고 : &lt;/strong&gt; &lt;var&gt;body&lt;/var&gt; 내의 &lt;code&gt;before-change-functions&lt;/code&gt; 또는 &lt;code&gt;after-change-function&lt;/code&gt; 기능 의 값을 변경해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="35fd27e99b5c58482abb5d76202e99aa0a1953f4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; You must not make any buffer changes outside of the region specified by &lt;var&gt;beg&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt;.</source>
          <target state="translated">&lt;strong&gt;경고 : &lt;/strong&gt; &lt;var&gt;beg&lt;/var&gt; 및 &lt;var&gt;end&lt;/var&gt; 로 지정된 영역 외부에서 버퍼를 변경해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="f9c24dc88e1e15e20222bea25a327387b74ae63e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; do not use &lt;code&gt;make-local-variable&lt;/code&gt; for a hook variable. The hook variables are automatically made buffer-local as needed if you use the &lt;var&gt;local&lt;/var&gt; argument to &lt;code&gt;add-hook&lt;/code&gt; or &lt;code&gt;remove-hook&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 후크 변수에 &lt;code&gt;make-local-variable&lt;/code&gt; 을 사용하지 마십시오 . 후크 변수는 &lt;var&gt;local&lt;/var&gt; 인수를 사용하여 &lt;code&gt;add-hook&lt;/code&gt; 또는 &lt;code&gt;remove-hook&lt;/code&gt; 을 사용하는 경우 필요에 따라 자동으로 버퍼 로컬이됩니다 .</target>
        </trans-unit>
        <trans-unit id="f09a5a9449bb11206b824d27af8eddf75c885f9b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; don&amp;rsquo;t bind this variable with &lt;code&gt;let&lt;/code&gt;. It is often buffer-local, and if you bind it around reading input (which is exactly when you &lt;em&gt;would&lt;/em&gt; bind it), switching buffers asynchronously while Emacs is waiting will cause the value to be restored in the wrong buffer.</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 이 변수를 &lt;code&gt;let&lt;/code&gt; 으로 바인딩하지 마십시오 . 그것은 종종 로컬 버퍼, 그리고 당신이 (당신이 정확히 언제 어떤 입력을 읽고 그것을 주위에 결합하는 경우 &lt;em&gt;것&lt;/em&gt; 이맥스 잘못된 버퍼에 복원 할 수있는 값의 원인이됩니다 기다리는 동안 비동기 버퍼를 전환, 바인딩).</target>
        </trans-unit>
        <trans-unit id="2c808981ea7426dd8fb31718768bdfb9240b0d82" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; don&amp;rsquo;t use the &lt;code&gt;font-lock-multiline&lt;/code&gt; property on large ranges of text, because that will make rehighlighting slow.</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 넓은 범위의 텍스트 에는 &lt;code&gt;font-lock-multiline&lt;/code&gt; 속성을 사용하지 마십시오 . 그러면 다시 강조 표시가 느려질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05ceae8ad10f503f250029c7f5afe4600bba1cb7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; don&amp;rsquo;t use this feature to alter the way the window is scrolled. It&amp;rsquo;s not designed for that, and such use probably won&amp;rsquo;t work.</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 이 기능을 사용하여 창이 스크롤되는 방식을 변경하지 마십시오. 그것은 그것을 위해 설계되지 않았으며 그러한 사용은 아마도 작동하지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="0206e6a7c67c64ebf9955d38fb60db7426e22736" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; if you change &lt;code&gt;file-name-coding-system&lt;/code&gt; (or the language environment) in the middle of an Emacs session, problems can result if you have already visited files whose names were encoded using the earlier coding system and are handled differently under the new coding system. If you try to save one of these buffers under the visited file name, saving may use the wrong file name, or it may get an error. If such a problem happens, use</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 당신이 변경하는 경우 &lt;code&gt;file-name-coding-system&lt;/code&gt; 이맥스 세션의 중간에 (또는 언어 환경을) 이미 이름이 이전 코딩 시스템을 사용하여 인코딩 된 파일을 방문하고, 아래에서 다르게 처리하는 경우, 문제가 발생할 수 있습니다 새로운 코딩 시스템. 방문한 파일 이름으로 이러한 버퍼 중 하나를 저장하려고하면 저장시 잘못된 파일 이름이 사용되거나 오류가 발생할 수 있습니다. 이러한 문제가 발생하면</target>
        </trans-unit>
        <trans-unit id="0dcce5150d56b66b966d918e097e575a78318f08" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; if you use the display table to change the display of newline characters, the whole buffer will be displayed as one long line.</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 표시 테이블을 사용하여 개행 문자의 표시를 변경하면 전체 버퍼가 하나의 긴 행으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="29632dff1239ce71ce3a6f2b24015c04aa685041" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; the argument values should not include any data types that can&amp;rsquo;t be printed and then read. Some facilities save &lt;code&gt;command-history&lt;/code&gt; in a file to be read in the subsequent sessions; if a command&amp;rsquo;s arguments contain a data type that prints using &amp;lsquo;</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 인수 값에는 인쇄 한 후 읽을 수없는 데이터 유형이 포함되어서는 안됩니다. 일부 기능 은 후속 세션에서 읽을 수 있도록 &lt;code&gt;command-history&lt;/code&gt; 을 파일에 저장 합니다. 명령의 인수가 '를 사용하여 인쇄하는 데이터 유형을 포함하는 경우</target>
        </trans-unit>
        <trans-unit id="bfc7d7757834b011b196dc085198902d4c7d8e65" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: Lisp macros and keyboard macros (see &lt;a href=&quot;keyboard-macros#Keyboard-Macros&quot;&gt;Keyboard Macros&lt;/a&gt;) are entirely different things. When we use the word &amp;ldquo;macro&amp;rdquo; without qualification, we mean a Lisp macro, not a keyboard macro.</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : 리스프 매크로와 키보드 매크로 (참조 &lt;a href=&quot;keyboard-macros#Keyboard-Macros&quot;&gt;키보드 매크로는&lt;/a&gt; ) 완전히 다른 것들입니다. 자격없이 &quot;매크로&quot;라는 단어를 사용하면 키보드 매크로가 아닌 Lisp 매크로를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="fabe30e6344dd13a2d7e00055d41e03305ca2ba2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: Note that the list in &lt;code&gt;nums&lt;/code&gt; no longer contains 0; this is the same cons cell that it was before, but it is no longer the first one in the list. Don&amp;rsquo;t assume a variable that formerly held the argument now holds the entire sorted list! Instead, save the result of &lt;code&gt;sort&lt;/code&gt; and use that. Most often we store the result back into the variable that held the original list:</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : &lt;code&gt;nums&lt;/code&gt; 의 목록 에는 더 이상 0이 포함되지 않습니다. 이것은 이전과 동일한 단점 셀이지만 더 이상 목록의 첫 번째 셀이 아닙니다. 이전에 인수를 보유했던 변수가 이제 전체 정렬 된 목록을 보유한다고 가정하지 마십시오! 대신 &lt;code&gt;sort&lt;/code&gt; 결과를 저장 하고 사용하십시오. 대부분의 경우 결과를 원래 목록을 보유한 변수에 다시 저장합니다.</target>
        </trans-unit>
        <trans-unit id="ba718421b608b61cd6a2f215e2d8aa0c23151d9a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;We discourage use of a non-&lt;code&gt;nil&lt;/code&gt; value for &lt;var&gt;initial&lt;/var&gt;&lt;/strong&gt;, because initial input is an intrusive interface. History lists and default values provide a much more convenient method to offer useful default inputs to the user.</source>
          <target state="translated">&lt;strong&gt;우리는 비 사용 억제 &lt;code&gt;nil&lt;/code&gt; 에 대한 가치 &lt;var&gt;initial&lt;/var&gt; &lt;/strong&gt; 초기 입력 관입 인터페이스이므로. 히스토리 목록과 기본값은 사용자에게 유용한 기본 입력을 제공하는 훨씬 더 편리한 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b1b9a3564d33e0fe386c96a11a997ce906bc8d2c" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;A&lt;/var&gt;*</source>
          <target state="translated">&lt;var&gt;A&lt;/var&gt;*</target>
        </trans-unit>
        <trans-unit id="639372047fe8250a564cf1eb6b02b0b8d7e2adeb" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;A&lt;/var&gt;*?</source>
          <target state="translated">&lt;var&gt;A&lt;/var&gt;*?</target>
        </trans-unit>
        <trans-unit id="9bf26381ace5ddd45faed752347619c79ad9b0f2" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;A&lt;/var&gt;+</source>
          <target state="translated">&lt;var&gt;A&lt;/var&gt;+</target>
        </trans-unit>
        <trans-unit id="1f4812366bcad6063b8bc30079ff6f730a73f239" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;A&lt;/var&gt;+?</source>
          <target state="translated">&lt;var&gt;A&lt;/var&gt;+?</target>
        </trans-unit>
        <trans-unit id="bc301264f66964afade4544f2549e9ecb0e4f516" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;A&lt;/var&gt;&lt;var&gt;B&lt;/var&gt;&amp;hellip;</source>
          <target state="translated">&lt;var&gt;A&lt;/var&gt;&lt;var&gt;B&lt;/var&gt;&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="0f0c348b2921825c505106ed1e5990044cd68713" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;A&lt;/var&gt;?</source>
          <target state="translated">&lt;var&gt;A&lt;/var&gt;?</target>
        </trans-unit>
        <trans-unit id="2308c8eb026e3ceb97214c64e9dd48f3241dcfb7" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;A&lt;/var&gt;??</source>
          <target state="translated">&lt;var&gt;A&lt;/var&gt;??</target>
        </trans-unit>
        <trans-unit id="dc72642f871262e6b752597333df8d8e9dd51891" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;A&lt;/var&gt;\{&lt;var&gt;n&lt;/var&gt;,&lt;var&gt;m&lt;/var&gt;\}</source>
          <target state="translated">&lt;var&gt;A&lt;/var&gt;\{&lt;var&gt;n&lt;/var&gt;,&lt;var&gt;m&lt;/var&gt;\}</target>
        </trans-unit>
        <trans-unit id="072675b59fadf451e0a05fde271899b16f325fb1" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;A&lt;/var&gt;\{&lt;var&gt;n&lt;/var&gt;,\}</source>
          <target state="translated">&lt;var&gt;A&lt;/var&gt;\{&lt;var&gt;n&lt;/var&gt;,\}</target>
        </trans-unit>
        <trans-unit id="47ef4b2187df56939010631d2add49667e8a8aca" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;A&lt;/var&gt;\{&lt;var&gt;n&lt;/var&gt;\}</source>
          <target state="translated">&lt;var&gt;A&lt;/var&gt;\{&lt;var&gt;n&lt;/var&gt;\}</target>
        </trans-unit>
        <trans-unit id="76e4e3a09ac81c5d948d7b54b04272d30706b4d1" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;A&lt;/var&gt;\|&lt;var&gt;B&lt;/var&gt;\|&amp;hellip;</source>
          <target state="translated">&lt;var&gt;A&lt;/var&gt;\|&lt;var&gt;B&lt;/var&gt;\|&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="bc58f81cb092eedec2d6d8c884a9b82607fa7e3b" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;activate-func&lt;/var&gt; is a function to call to activate this method. The &lt;var&gt;args&lt;/var&gt;, if any, are passed as arguments to &lt;var&gt;activate-func&lt;/var&gt;. All told, the arguments to &lt;var&gt;activate-func&lt;/var&gt; are &lt;var&gt;input-method&lt;/var&gt; and the &lt;var&gt;args&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;activate-func&lt;/var&gt; 는이 메서드를 활성화하기 위해 호출하는 함수입니다. &lt;var&gt;args&lt;/var&gt; (있는 경우)에 인수로 전달되는 &lt;var&gt;activate-func&lt;/var&gt; . 모두 말하면 &lt;var&gt;activate-func&lt;/var&gt; 의 인수 는 &lt;var&gt;input-method&lt;/var&gt; 와 &lt;var&gt;args&lt;/var&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fb0c583b9c9e9be9be62ec9f98c564288e7e889c" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;aead_auth&lt;/var&gt; is only checked with AEAD ciphers, that is, ciphers whose plist has &lt;code&gt;:cipher-aead-capable t&lt;/code&gt;. Otherwise it&amp;rsquo;s ignored.</source>
          <target state="translated">&lt;var&gt;aead_auth&lt;/var&gt; 는 AEAD 암호, 즉 plist에 &lt;code&gt;:cipher-aead-capable t&lt;/code&gt; 가있는 암호로만 확인됩니다 . 그렇지 않으면 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="fe415e21b51794699e741f46ca2b74fca55619fa" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;alist&lt;/var&gt; is an association list of symbols and values as for &lt;code&gt;display-buffer&lt;/code&gt;. The following symbols in &lt;var&gt;alist&lt;/var&gt; are special for this function:</source>
          <target state="translated">&lt;var&gt;alist&lt;/var&gt; 는 &lt;code&gt;display-buffer&lt;/code&gt; 와 같이 기호 및 값의 연관 목록입니다 . 에서 다음과 같은 기호 &lt;var&gt;alist&lt;/var&gt; 는 이 기능에 대한 특별하다 :</target>
        </trans-unit>
        <trans-unit id="eba413b4ed6d73161a8353916a5866a74e0565b9" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;arglist&lt;/var&gt; may end in &lt;code&gt;&amp;amp;rest&lt;/code&gt; and one final argument name, denoting a rest parameter. The rest parameter will expand to all extra actual argument values not matched by any other parameter in &lt;var&gt;arglist&lt;/var&gt;, spliced into &lt;var&gt;rx-form&lt;/var&gt; where it occurs. Example:</source>
          <target state="translated">&lt;var&gt;arglist&lt;/var&gt; 는 &lt;code&gt;&amp;amp;rest&lt;/code&gt; 및 나머지 매개 변수를 나타내는 하나의 마지막 인수 이름으로 끝날 수 있습니다 . 나머지 매개 변수의 다른 매개 변수에 일치하지 않는 모든 여분의 실제 인수 값으로 확장됩니다 &lt;var&gt;arglist&lt;/var&gt; 에 접합, &lt;var&gt;rx-form&lt;/var&gt; 가 발생합니다. 예:</target>
        </trans-unit>
        <trans-unit id="d5bf91b60980cfbb14ffe935c92c37d495dc65c9" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;background&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, should be a string specifying a color, which is used as the image&amp;rsquo;s background color if the image supports transparency. If the value is &lt;code&gt;nil&lt;/code&gt;, it defaults to the frame&amp;rsquo;s background color.</source>
          <target state="translated">&lt;var&gt;background&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 이미지가 투명도를 지원하는 경우 이미지의 배경색으로 사용되는 색상을 지정하는 문자열이어야합니다. 값이 &lt;code&gt;nil&lt;/code&gt; 이면 프레임의 배경색으로 기본 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="03bae4a0f67b53539e330b159bda6052780e7ba5" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;base&lt;/var&gt;...&lt;var&gt;how-far&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;base&lt;/var&gt;...&lt;var&gt;how-far&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="ce7047ebe43595779bf964d11c2638b3ba54ec0b" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;bindings&lt;/var&gt; is a list of bindings of the form &lt;code&gt;(&lt;var&gt;pattern&lt;/var&gt;
&lt;var&gt;exp&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;exp&lt;/var&gt; is an expression to evaluate and &lt;var&gt;pattern&lt;/var&gt; is a &lt;code&gt;pcase&lt;/code&gt; pattern. The variable bindings are produced by destructuring binding of elements of &lt;var&gt;pattern&lt;/var&gt; to the values of the corresponding elements of the evaluated &lt;var&gt;exp&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;bindings&lt;/var&gt; 는 &lt;code&gt;(&lt;var&gt;pattern&lt;/var&gt; &lt;var&gt;exp&lt;/var&gt;)&lt;/code&gt; 형식의 바인딩 목록입니다 . 여기서 &lt;var&gt;exp&lt;/var&gt; 는 평가할 표현식이고 &lt;var&gt;pattern&lt;/var&gt; 은 &lt;code&gt;pcase&lt;/code&gt; 패턴입니다. 변수 바인딩은 평가 된 &lt;var&gt;exp&lt;/var&gt; 의 해당 요소 값에 대한 &lt;var&gt;pattern&lt;/var&gt; 요소의 바인딩을 분해하여 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="1e4e93d29947e853fda98497930b3b20ac078622" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;bindings&lt;/var&gt; is a list of bindings of the form &lt;code&gt;(&lt;var&gt;pattern&lt;/var&gt;&amp;nbsp;&lt;var&gt;exp&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;exp&lt;/var&gt; is an expression to evaluate and &lt;var&gt;pattern&lt;/var&gt; is a &lt;code&gt;pcase&lt;/code&gt; pattern.</source>
          <target state="translated">&lt;var&gt;bindings&lt;/var&gt; 는 &lt;code&gt;(&lt;var&gt;pattern&lt;/var&gt;&amp;nbsp;&lt;var&gt;exp&lt;/var&gt;)&lt;/code&gt; 형식의 바인딩 목록입니다 . 여기서 &lt;var&gt;exp&lt;/var&gt; 는 평가할 표현식이고 &lt;var&gt;pattern&lt;/var&gt; 은 &lt;code&gt;pcase&lt;/code&gt; 패턴입니다.</target>
        </trans-unit>
        <trans-unit id="d4209f1f9bb188e95924bdefb815300395d0fa4d" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;bnf&lt;/var&gt; is a list of nonterminal definitions of the form &lt;code&gt;(&lt;var&gt;nonterm&lt;/var&gt; &lt;var&gt;rhs1&lt;/var&gt; &lt;var&gt;rhs2&lt;/var&gt; ...)&lt;/code&gt; where each &lt;var&gt;rhs&lt;/var&gt; is a (non-empty) list of terminals (aka tokens) or non-terminals.</source>
          <target state="translated">&lt;var&gt;bnf&lt;/var&gt; 폼의 비단 정의 목록이다 &lt;code&gt;(&lt;var&gt;nonterm&lt;/var&gt; &lt;var&gt;rhs1&lt;/var&gt; &lt;var&gt;rhs2&lt;/var&gt; ...)&lt;/code&gt; 각각의 &lt;var&gt;rhs&lt;/var&gt; 단자 (일명 토큰) 또는 비 단자 (비어)리스트이다.</target>
        </trans-unit>
        <trans-unit id="c62c4cf5a34d62f4083055437ae2063f61f743fa" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;boolean-expression&lt;/var&gt; is evaluated:</source>
          <target state="translated">&lt;var&gt;boolean-expression&lt;/var&gt; 이 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="897206fe1c279b99023a941cb036c2c9032a2c09" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;buffer-name&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, specifies the name of the buffer for logging the warning. By default, it is</source>
          <target state="translated">&lt;var&gt;buffer-name&lt;/var&gt; 은 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 경고를 로깅하기위한 버퍼의 이름을 지정합니다. 기본적으로</target>
        </trans-unit>
        <trans-unit id="3e97490488a20d8323027e17c1aa26733fbaf6d4" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;buffer-or-name&lt;/var&gt; must be either a string or an existing buffer. If it is a string and a live buffer with that name already exists, &lt;code&gt;get-buffer-create&lt;/code&gt; returns that buffer. If no such buffer exists, it creates a new buffer. If &lt;var&gt;buffer-or-name&lt;/var&gt; is a buffer instead of a string, it is returned as given, even if it is dead.</source>
          <target state="translated">&lt;var&gt;buffer-or-name&lt;/var&gt; 은 문자열이거나 기존 버퍼 여야합니다. 문자열이고 해당 이름의 라이브 버퍼가 이미 존재하는 경우 &lt;code&gt;get-buffer-create&lt;/code&gt; 는 해당 버퍼를 반환합니다. 그러한 버퍼가 없으면 새 버퍼를 만듭니다. 경우 &lt;var&gt;buffer-or-name&lt;/var&gt; 문자열이 아닌 버퍼가 주어진, 죽은 경우에도 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="8a0455ef45d72d81ce9684877db5cc07d5c8a84c" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;buffer-or-name&lt;/var&gt; should be a buffer or the name of a buffer; if omitted or &lt;code&gt;nil&lt;/code&gt;, it defaults to the current buffer. The optional argument &lt;var&gt;all-frames&lt;/var&gt; specifies which windows to consider:</source>
          <target state="translated">&lt;var&gt;buffer-or-name&lt;/var&gt; 은 버퍼 또는 버퍼의 이름 이어야합니다. 생략되거나 &lt;code&gt;nil&lt;/code&gt; 인 경우 기본값은 현재 버퍼입니다. 선택적 인수 &lt;var&gt;all-frames&lt;/var&gt; 는 고려할 창을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="14dedd5200d621b6760f626d379fabf74a6e69ec" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;character&lt;/var&gt; may be &lt;code&gt;nil&lt;/code&gt;, which means to use &lt;var&gt;font-spec&lt;/var&gt; for any character which no font-spec is specified.</source>
          <target state="translated">&lt;var&gt;character&lt;/var&gt; 는 &lt;code&gt;nil&lt;/code&gt; 일 수 있으며 , 이는 font-spec이 지정되지 않은 모든 문자에 대해 &lt;var&gt;font-spec&lt;/var&gt; 을 사용함을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="0c32dca097b381952f874c4d538bc6d57210dbbe" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;character&lt;/var&gt; may be a charset (see &lt;a href=&quot;character-sets#Character-Sets&quot;&gt;Character Sets&lt;/a&gt;). In that case, use &lt;var&gt;font-spec&lt;/var&gt; for all the characters in the charset.</source>
          <target state="translated">&lt;var&gt;character&lt;/var&gt; 는 &lt;a href=&quot;character-sets#Character-Sets&quot;&gt;문자 집합&lt;/a&gt; 일 수 있습니다 ( 문자 집합 참조 ). 이 경우 문자 세트의 모든 문자에 대해 &lt;var&gt;font-spec&lt;/var&gt; 을 사용 하십시오.</target>
        </trans-unit>
        <trans-unit id="49b46ba92d516a8eb20ffe7277a91cf8b50a2fc7" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;character&lt;/var&gt; may be a script name (see &lt;a href=&quot;character-properties#Character-Properties&quot;&gt;char-script-table&lt;/a&gt;). In that case, use &lt;var&gt;font-spec&lt;/var&gt; for all the characters belonging to the script.</source>
          <target state="translated">&lt;var&gt;character&lt;/var&gt; 는 스크립트 이름 일 수 있습니다 ( &lt;a href=&quot;character-properties#Character-Properties&quot;&gt;char-script-table 참조&lt;/a&gt; ). 이 경우 스크립트에 속한 모든 문자에 대해 &lt;var&gt;font-spec&lt;/var&gt; 을 사용 하십시오.</target>
        </trans-unit>
        <trans-unit id="315b7c3e1a935f87a345ecedd5cae6998bb888a6" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;charset&lt;/var&gt;:&lt;var&gt;font&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;charset&lt;/var&gt;:&lt;var&gt;font&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="4b4d89a582c439acb0591d942dabf0428a352e0f" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;choices&lt;/var&gt; is an alist where the first element in each entry is a character to be entered, the second element is a short name for the entry to be displayed while prompting (if there&amp;rsquo;s room, it might be shortened), and the third, optional entry is a longer explanation that will be displayed in a help buffer if the user requests more help.</source>
          <target state="translated">&lt;var&gt;choices&lt;/var&gt; 는 각 항목의 첫 번째 요소가 입력 할 문자이고, 두 번째 요소는 프롬프트하는 동안 표시 할 항목의 짧은 이름 (공간이있는 경우 짧아 질 수 있음), 세 번째, 선택적 항목 인 목록입니다. 사용자가 더 많은 도움을 요청하면 도움말 버퍼에 표시되는 긴 설명입니다.</target>
        </trans-unit>
        <trans-unit id="48a1fa281d645561b8164abd8a41647240cfde22" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;col&lt;/var&gt;, &lt;var&gt;row&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;col&lt;/var&gt; , &lt;var&gt;row&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="25719d0480de36aa48958210c4694af307c0943b" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;collection&lt;/var&gt; is called the &lt;em&gt;completion table&lt;/em&gt;. Its value must be a list of strings or cons cells, an obarray, a hash table, or a completion function.</source>
          <target state="translated">&lt;var&gt;collection&lt;/var&gt; &lt;em&gt;완성 테이블&lt;/em&gt; 이라고 &lt;em&gt;합니다&lt;/em&gt; . 값은 문자열 또는 단점 셀 목록, 오바 레이, 해시 테이블 또는 완료 함수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="95ac74539379f37ce12d859cdcecdd757d3861e3" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;color&lt;/var&gt; is either a string, or the symbol &lt;code&gt;foreground-color&lt;/code&gt;, meaning the foreground color of the face. Omitting the attribute &lt;code&gt;:color&lt;/code&gt; means to use the foreground color of the face. &lt;var&gt;style&lt;/var&gt; should be a symbol &lt;code&gt;line&lt;/code&gt; or &lt;code&gt;wave&lt;/code&gt;, meaning to use a straight or wavy line. Omitting the attribute &lt;code&gt;:style&lt;/code&gt; means to use a straight line.</source>
          <target state="translated">&lt;var&gt;color&lt;/var&gt; 는 문자열이거나 , 얼굴의 전경색을 의미하는 foreground &lt;code&gt;foreground-color&lt;/code&gt; 기호 입니다. &lt;code&gt;:color&lt;/code&gt; 속성을 생략하면 얼굴의 전경색을 사용한다는 의미입니다. &lt;var&gt;style&lt;/var&gt; 은 직선 또는 물결 선을 사용하는 것을 의미 하는 기호 &lt;code&gt;line&lt;/code&gt; 또는 &lt;code&gt;wave&lt;/code&gt; 이어야합니다 . &lt;code&gt;:style&lt;/code&gt; 속성을 생략하면 직선을 사용한다는 의미입니다.</target>
        </trans-unit>
        <trans-unit id="85506ad78941e763e80e1d83890c372391e36bd1" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;condition&lt;/var&gt; can also be a list of error conditions.</source>
          <target state="translated">&lt;var&gt;condition&lt;/var&gt; 은 오류 조건 목록 일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e5f961b2b9d3d160b6161982913cce6cbabbb86" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;contents&lt;/var&gt; is a vector with the same number of elements as &lt;code&gt;tabulated-list-format&lt;/code&gt;. Each vector element is either a string, which is inserted into the buffer as-is, or a list &lt;code&gt;(&lt;var&gt;label&lt;/var&gt;
. &lt;var&gt;properties&lt;/var&gt;)&lt;/code&gt;, which means to insert a text button by calling &lt;code&gt;insert-text-button&lt;/code&gt; with &lt;var&gt;label&lt;/var&gt; and &lt;var&gt;properties&lt;/var&gt; as arguments (see &lt;a href=&quot;making-buttons#Making-Buttons&quot;&gt;Making Buttons&lt;/a&gt;).</source>
          <target state="translated">&lt;var&gt;contents&lt;/var&gt; 는 &lt;code&gt;tabulated-list-format&lt;/code&gt; 과 동일한 수의 요소를 가진 벡터입니다 . 각 벡터 요소는있는 그대로 버퍼에 삽입되는 문자열이거나 &lt;var&gt;label&lt;/var&gt; 및 &lt;var&gt;properties&lt;/var&gt; 을 인수로 사용 하여 &lt;code&gt;insert-text-button&lt;/code&gt; 을 호출하여 텍스트 버튼을 삽입하는 것을 의미 하는 목록 &lt;code&gt;(&lt;var&gt;label&lt;/var&gt; . &lt;var&gt;properties&lt;/var&gt;)&lt;/code&gt; ( &lt;a href=&quot;making-buttons#Making-Buttons&quot;&gt;Make 버튼&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="059eb938a23f2d665b19373c768d7d7e5c49c2b3" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;coordinates&lt;/var&gt; should be a cons cell of the form &lt;code&gt;(&lt;var&gt;x&lt;/var&gt;
. &lt;var&gt;y&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;x&lt;/var&gt; and &lt;var&gt;y&lt;/var&gt; are given in default character sizes (see &lt;a href=&quot;frame-font#Frame-Font&quot;&gt;Frame Font&lt;/a&gt;) relative to the native position of &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s frame (see &lt;a href=&quot;frame-geometry#Frame-Geometry&quot;&gt;Frame Geometry&lt;/a&gt;).</source>
          <target state="translated">&lt;var&gt;coordinates&lt;/var&gt; 는 &lt;code&gt;(&lt;var&gt;x&lt;/var&gt; . &lt;var&gt;y&lt;/var&gt;)&lt;/code&gt; 형식의 cons 셀이어야합니다 . 여기서 &lt;var&gt;x&lt;/var&gt; 및 &lt;var&gt;y&lt;/var&gt; 는 &lt;var&gt;window&lt;/var&gt; 프레임 의 기본 위치를 기준으로 기본 문자 크기 ( &lt;a href=&quot;frame-font#Frame-Font&quot;&gt;프레임 글꼴&lt;/a&gt; 참조 )로 제공됩니다 ( &lt;a href=&quot;frame-geometry#Frame-Geometry&quot;&gt;프레임 형상&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="25f4d037ea3c1415b198231934180e02de1d9bd1" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;default-coding-system&lt;/var&gt; can also be a list whose first element is &lt;code&gt;t&lt;/code&gt; and whose other elements are coding systems. Then, if no coding system in the list can handle the text, &lt;code&gt;select-safe-coding-system&lt;/code&gt; queries the user immediately, without trying any of the three alternatives described above. This is handy for checking only the coding systems in the list.</source>
          <target state="translated">&lt;var&gt;default-coding-system&lt;/var&gt; 은 첫 번째 요소가 &lt;code&gt;t&lt;/code&gt; 이고 다른 요소가 코딩 시스템 인 목록 일 수도 있습니다 . 그런 다음 목록에있는 코딩 시스템이 텍스트를 처리 할 수없는 경우 &lt;code&gt;select-safe-coding-system&lt;/code&gt; 은 위에 설명 된 세 가지 대안을 시도하지 않고 사용자에게 즉시 쿼리합니다. 이것은 목록의 코딩 시스템 만 확인하는 데 편리합니다.</target>
        </trans-unit>
        <trans-unit id="d4740bdea7c58dc3cd47e4b528d9cddfd5ab846b" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;descriptor&lt;/var&gt; is the same object as the one returned by this function. &lt;var&gt;action&lt;/var&gt; is the description of the event. It could be any one of the following symbols:</source>
          <target state="translated">&lt;var&gt;descriptor&lt;/var&gt; 자는이 함수에 의해 반환 된 것과 동일한 객체입니다. &lt;var&gt;action&lt;/var&gt; 은 이벤트에 대한 설명입니다. 다음 기호 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8cbced6a8e5085804c5b909584c06f650eaf2a8" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;display&lt;/var&gt; specifies a class of terminals (see below). &lt;var&gt;plist&lt;/var&gt; is a property list of face attributes and their values, specifying how the face appears on such terminals. For backward compatibility, you can also write an element as &lt;code&gt;(&lt;var&gt;display&lt;/var&gt; &lt;var&gt;plist&lt;/var&gt;)&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;display&lt;/var&gt; 는 터미널 클래스를 지정합니다 (아래 참조). &lt;var&gt;plist&lt;/var&gt; 는 얼굴 속성 및 해당 값의 속성 목록으로, 이러한 터미널에 얼굴이 나타나는 방식을 지정합니다. 이전 버전과의 호환성을 위해 요소를 &lt;code&gt;(&lt;var&gt;display&lt;/var&gt; &lt;var&gt;plist&lt;/var&gt;)&lt;/code&gt; 로 작성할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e3ad125e9fcc9d8ed043a029ffcfd9d1a4d42f6e" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;doc&lt;/var&gt;, if present, should be a string specifying the function&amp;rsquo;s documentation string (see &lt;a href=&quot;function-documentation#Function-Documentation&quot;&gt;Function Documentation&lt;/a&gt;). &lt;var&gt;declare&lt;/var&gt;, if present, should be a &lt;code&gt;declare&lt;/code&gt; form specifying function metadata (see &lt;a href=&quot;declare-form#Declare-Form&quot;&gt;Declare Form&lt;/a&gt;). &lt;var&gt;interactive&lt;/var&gt;, if present, should be an &lt;code&gt;interactive&lt;/code&gt; form specifying how the function is to be called interactively (see &lt;a href=&quot;interactive-call#Interactive-Call&quot;&gt;Interactive Call&lt;/a&gt;).</source>
          <target state="translated">&lt;var&gt;doc&lt;/var&gt; 가있는 경우 함수의 문서화 문자열을 지정하는 문자열이어야합니다 ( &lt;a href=&quot;function-documentation#Function-Documentation&quot;&gt;함수 문서&lt;/a&gt; 참조 ). &lt;var&gt;declare&lt;/var&gt; 는있는 경우 함수 메타 데이터를 지정 하는 &lt;code&gt;declare&lt;/code&gt; 형식 이어야합니다 ( &lt;a href=&quot;declare-form#Declare-Form&quot;&gt;Declare Form&lt;/a&gt; 참조 ). &lt;var&gt;interactive&lt;/var&gt; 가있는 경우 함수가 대화식으로 호출되는 방법을 지정하는 &lt;code&gt;interactive&lt;/code&gt; 형식 이어야합니다 ( &lt;a href=&quot;interactive-call#Interactive-Call&quot;&gt;대화 형 호출&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="4d7cbc1a74d03a0f78e34f4208bb2aee52517b47" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;doc&lt;/var&gt;, if present, should be a string specifying the macro&amp;rsquo;s documentation string. &lt;var&gt;declare&lt;/var&gt;, if present, should be a &lt;code&gt;declare&lt;/code&gt; form specifying metadata for the macro (see &lt;a href=&quot;declare-form#Declare-Form&quot;&gt;Declare Form&lt;/a&gt;). Note that macros cannot have interactive declarations, since they cannot be called interactively.</source>
          <target state="translated">&lt;var&gt;doc&lt;/var&gt; 가있는 경우 매크로의 문서 문자열을 지정하는 문자열이어야합니다. &lt;var&gt;declare&lt;/var&gt; 이있는 경우 매크로에 대한 메타 데이터를 지정 하는 &lt;code&gt;declare&lt;/code&gt; 형식 이어야합니다 ( &lt;a href=&quot;declare-form#Declare-Form&quot;&gt;형식 선언&lt;/a&gt; 참조 ). 매크로는 대화식으로 호출 할 수 없기 때문에 대화 형 선언을 가질 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0ccc8ddd11dcc504c397e4a0a41030c2848cd67f" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;dx&lt;/var&gt;, &lt;var&gt;dy&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;dx&lt;/var&gt; , &lt;var&gt;dy&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="bfeb638334ed0ea3560b17a40e5f38c1328d1164" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;emacs-name&lt;/var&gt;.dmp</source>
          <target state="translated">&lt;var&gt;emacs-name&lt;/var&gt;.dmp</target>
        </trans-unit>
        <trans-unit id="f43bbd847569b4d0976a8c99d3ef58935b829e02" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;enable&lt;/var&gt; is an expression; if it evaluates to &lt;code&gt;nil&lt;/code&gt;, the item is make unselectable.. &lt;code&gt;:enable&lt;/code&gt; is an alias for &lt;code&gt;:active&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;enable&lt;/var&gt; 은 표현식입니다. &lt;code&gt;nil&lt;/code&gt; 로 평가 되면 항목은 선택 불가능하게됩니다 . &lt;code&gt;:enable&lt;/code&gt; 은 &lt;code&gt;:active&lt;/code&gt; 의 별칭입니다 .</target>
        </trans-unit>
        <trans-unit id="026a4d4e36d46678bd210dd9c83988b282f1bbc3" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;enable&lt;/var&gt; is an expression; if it evaluates to &lt;code&gt;nil&lt;/code&gt;, the menu is not selectable. &lt;code&gt;:enable&lt;/code&gt; is an alias for &lt;code&gt;:active&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;enable&lt;/var&gt; 은 표현식입니다. &lt;code&gt;nil&lt;/code&gt; 로 평가 되면 메뉴를 선택할 수 없습니다. &lt;code&gt;:enable&lt;/code&gt; 은 &lt;code&gt;:active&lt;/code&gt; 의 별칭입니다 .</target>
        </trans-unit>
        <trans-unit id="24543b8028f1a35def94fb638729d3e0dc460d74" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;endkeyfun&lt;/var&gt; is called to move point from the start of the sort key to the end of the sort key. This argument is optional. If &lt;var&gt;startkeyfun&lt;/var&gt; returns &lt;code&gt;nil&lt;/code&gt; and this argument is omitted (or &lt;code&gt;nil&lt;/code&gt;), then the sort key extends to the end of the record. There is no need for &lt;var&gt;endkeyfun&lt;/var&gt; if &lt;var&gt;startkeyfun&lt;/var&gt; returns a non-&lt;code&gt;nil&lt;/code&gt; value.</source>
          <target state="translated">&lt;var&gt;endkeyfun&lt;/var&gt; 은 정렬 키의 시작에서 정렬 키의 끝으로 포인트를 이동하기 위해 호출됩니다. 이 인수는 선택 사항입니다. 경우 &lt;var&gt;startkeyfun&lt;/var&gt; 의 반환 &lt;code&gt;nil&lt;/code&gt; 을 이 인수가 생략 (또는됩니다 &lt;code&gt;nil&lt;/code&gt; ), 다음 정렬 키는 레코드의 끝으로 확장합니다. &lt;var&gt;endkeyfun&lt;/var&gt; 이 &lt;code&gt;nil&lt;/code&gt; 이 아닌 값을 반환 하면 &lt;var&gt;startkeyfun&lt;/var&gt; 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ae4587c6776baee695ab496cec1fcc993fbc9d28" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;endrecfun&lt;/var&gt; is called with point within a record. It moves point to the end of the record.</source>
          <target state="translated">&lt;var&gt;endrecfun&lt;/var&gt; 은 레코드 내에서 포인트로 호출됩니다. 레코드 끝으로 포인트를 이동합니다.</target>
        </trans-unit>
        <trans-unit id="07258c3d909b7d04fbc29283d3a6c004534672a9" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;eol-type&lt;/var&gt; may also be 0, 1 or 2, standing for &lt;code&gt;unix&lt;/code&gt;, &lt;code&gt;dos&lt;/code&gt; and &lt;code&gt;mac&lt;/code&gt;, respectively.</source>
          <target state="translated">&lt;var&gt;eol-type&lt;/var&gt; 은 각각 &lt;code&gt;unix&lt;/code&gt; , &lt;code&gt;dos&lt;/code&gt; 및 &lt;code&gt;mac&lt;/code&gt; 을 나타내는 0, 1 또는 2 일 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a679848f4f81da63a940e500185e5f4d31fb505d" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;face&lt;/var&gt; is a face name (a symbol), and &lt;var&gt;spec&lt;/var&gt; is the customized face specification for that face (see &lt;a href=&quot;defining-faces#Defining-Faces&quot;&gt;Defining Faces&lt;/a&gt;).</source>
          <target state="translated">&lt;var&gt;face&lt;/var&gt; 는 얼굴 이름 (기호)이고 &lt;var&gt;spec&lt;/var&gt; 은 해당 얼굴에 대한 사용자 정의 된 얼굴 사양입니다 (얼굴 &lt;a href=&quot;defining-faces#Defining-Faces&quot;&gt;정의&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="a673288deae0cf01bf7e0c37ea6455f2424f67ef" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;face&lt;/var&gt; is merged with the &lt;code&gt;fringe&lt;/code&gt; face, so normally &lt;var&gt;face&lt;/var&gt; should specify only the foreground color.</source>
          <target state="translated">&lt;var&gt;face&lt;/var&gt; 은 &lt;code&gt;fringe&lt;/code&gt; 얼굴 과 병합 되므로 일반적으로 &lt;var&gt;face&lt;/var&gt; 은 전경색 만 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="26d9a049372ef2db3d71a63355e838837e772504" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;family&lt;/var&gt; specifies the address (and protocol) family for communication. &lt;code&gt;nil&lt;/code&gt; means determine the proper address family automatically for the given &lt;var&gt;host&lt;/var&gt; and &lt;var&gt;service&lt;/var&gt;. &lt;code&gt;local&lt;/code&gt; specifies a Unix socket, in which case &lt;var&gt;host&lt;/var&gt; is ignored. &lt;code&gt;ipv4&lt;/code&gt; and &lt;code&gt;ipv6&lt;/code&gt; specify to use IPv4 and IPv6, respectively.</source>
          <target state="translated">&lt;var&gt;family&lt;/var&gt; 는 통신을위한 주소 (및 프로토콜) 제품군을 지정합니다. &lt;code&gt;nil&lt;/code&gt; 은 주어진 &lt;var&gt;host&lt;/var&gt; 와 &lt;var&gt;service&lt;/var&gt; 대한 적절한 주소 패밀리를 자동으로 결정 함을 의미 합니다 . &lt;code&gt;local&lt;/code&gt; 은 Unix 소켓을 지정하며이 경우 &lt;var&gt;host&lt;/var&gt; 는 무시됩니다. &lt;code&gt;ipv4&lt;/code&gt; 및 &lt;code&gt;ipv6&lt;/code&gt; 은 각각 IPv4 및 IPv6를 사용하도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="c439447a5739faaa36388e0fd0208ee5b5f20788" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file&lt;/var&gt; and &lt;var&gt;file1&lt;/var&gt; are the name of the file(s) whose event is being reported. For example:</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt; 및 &lt;var&gt;file1&lt;/var&gt; 은 이벤트가보고되는 파일의 이름입니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="494dfd3e482f441bcf7349c4b35ed8257f3fcf33" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file&lt;/var&gt; has been renamed to &lt;var&gt;file1&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt; 이름이 &lt;var&gt;file1&lt;/var&gt; 로 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="d0efe3807ad969de00033c63916e52295c7dc7db" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file&lt;/var&gt; was created</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt; 이 생성되었습니다</target>
        </trans-unit>
        <trans-unit id="ff9b4e58b863e2d9426f346e0b4e0bc3b5c5203e" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file&lt;/var&gt; was deleted</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt; 이 삭제되었습니다</target>
        </trans-unit>
        <trans-unit id="ceaae3594f636f9cdc34f5ebddb7ea2e6a63d442" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file&lt;/var&gt;&amp;rsquo;s contents has changed; with</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt; 의 내용이 변경되었습니다. 와</target>
        </trans-unit>
        <trans-unit id="c371da9511eda87a2212e3220f12941b56c97397" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;filename&lt;/var&gt;.&lt;var&gt;ext&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;filename&lt;/var&gt;.&lt;var&gt;ext&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="4e7cc819e121989dca24eab6e075d8cd141f4606" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;filename&lt;/var&gt;.el</source>
          <target state="translated">&lt;var&gt;filename&lt;/var&gt;.el</target>
        </trans-unit>
        <trans-unit id="33e86703d5b2c9fe524e4c7367176bbb74f72f27" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;filename&lt;/var&gt;.elc</source>
          <target state="translated">&lt;var&gt;filename&lt;/var&gt;.elc</target>
        </trans-unit>
        <trans-unit id="03c0f13fc536f6551c91f757809e50b3865faf3e" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;firstchar&lt;/var&gt;..&lt;var&gt;lastchar&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;firstchar&lt;/var&gt;..&lt;var&gt;lastchar&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="2f1c5588aa47061170d13d3fdbdf7eb212c134e7" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;flags&lt;/var&gt; is a list of conditions to set what will be watched for. It can include the following symbols:</source>
          <target state="translated">&lt;var&gt;flags&lt;/var&gt; 는 감시 대상을 설정하는 조건 목록입니다. 다음 기호를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb3f01a3d3b221299cad46839d79ffbec32038e4" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;font-spec&lt;/var&gt; may be &lt;code&gt;nil&lt;/code&gt;, which explicitly specifies that there&amp;rsquo;s no font for the specified &lt;var&gt;character&lt;/var&gt;. This is useful, for example, to avoid expensive system-wide search for fonts for characters that have no glyphs, like those from the Unicode Private Use Area (PUA).</source>
          <target state="translated">&lt;var&gt;font-spec&lt;/var&gt; 은 &lt;code&gt;nil&lt;/code&gt; 일 수 있으며 , 지정된 &lt;var&gt;character&lt;/var&gt; 대한 글꼴이 없음을 명시 적으로 지정합니다 . 예를 들어, 이것은 유니 코드 PUA (Private Use Area)의 문자와 같이 문자가없는 문자에 대한 글꼴을 시스템 전체에서 검색하는 비용이 많이 드는 것을 방지하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="87791ac35e559d82f0beba087e4f60504c73063c" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;font-spec&lt;/var&gt; may be a cons; &lt;code&gt;(&lt;var&gt;family&lt;/var&gt; . &lt;var&gt;registry&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;family&lt;/var&gt; is a family name of a font (possibly including a foundry name at the head), &lt;var&gt;registry&lt;/var&gt; is a registry name of a font (possibly including an encoding name at the tail).</source>
          <target state="translated">&lt;var&gt;font-spec&lt;/var&gt; 은 단점 일 수 있습니다. &lt;code&gt;(&lt;var&gt;family&lt;/var&gt; . &lt;var&gt;registry&lt;/var&gt;)&lt;/code&gt; , 여기서 &lt;var&gt;family&lt;/var&gt; 는 글꼴의 패밀리 이름 (머리에 파운드리 이름 포함)이고 &lt;var&gt;registry&lt;/var&gt; 는 글꼴의 레지스트리 이름입니다 (꼬리에 인코딩 이름 포함).</target>
        </trans-unit>
        <trans-unit id="c4d8e9b29420e5f894d3d4388135196d57737a2e" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;font-spec&lt;/var&gt; may be a font name, a string.</source>
          <target state="translated">&lt;var&gt;font-spec&lt;/var&gt; 은 글꼴 이름, 문자열 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="759768b158ba114fe576f2c579a978fa9530def7" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;font-spec&lt;/var&gt; may be a font-spec object created by the function &lt;code&gt;font-spec&lt;/code&gt; (see &lt;a href=&quot;low_002dlevel-font#Low_002dLevel-Font&quot;&gt;Low-Level Font&lt;/a&gt;).</source>
          <target state="translated">&lt;var&gt;font-spec&lt;/var&gt; 함수에 의해 생성 된 폰트 스펙 개체 일 수있다 &lt;code&gt;font-spec&lt;/code&gt; (참조 &lt;a href=&quot;low_002dlevel-font#Low_002dLevel-Font&quot;&gt;저수준 폰트&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="029bbc3c1e9a51615a423507e468eedf7d75d6f0" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;foo&lt;/var&gt;-theme.el</source>
          <target state="translated">&lt;var&gt;foo&lt;/var&gt;-theme.el</target>
        </trans-unit>
        <trans-unit id="86da1189a32a4e33ef437641c2dc1ff3f09bc416" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;form&lt;/var&gt; is a Lisp expression evaluated at the moment the field is unpacked or packed. The result of the evaluation should be one of the above-listed type specifications.</source>
          <target state="translated">&lt;var&gt;form&lt;/var&gt; 은 필드가 풀리거나 패킹되는 순간 평가되는 Lisp 표현식입니다. 평가 결과는 위에 나열된 유형 사양 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="92c54291694533dc568fa1eb74e1ad40167195fd" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;form&lt;/var&gt; is an expression that is dynamically evaluated and whose value is concatenated with the menu entry&amp;rsquo;s label.</source>
          <target state="translated">&lt;var&gt;form&lt;/var&gt; 은 동적으로 평가되고 그 값이 메뉴 항목의 레이블과 연결되는 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="fb3bf40536e1a49665a57075be8eb3a300e2ec1a" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;form&lt;/var&gt; is an expression that is evaluated to obtain a value which serves as the menu item&amp;rsquo;s label (the default is &lt;var&gt;name&lt;/var&gt;).</source>
          <target state="translated">&lt;var&gt;form&lt;/var&gt; 은 메뉴 항목의 레이블 역할을하는 값을 얻기 위해 평가되는 표현식입니다 (기본값은 &lt;var&gt;name&lt;/var&gt; ).</target>
        </trans-unit>
        <trans-unit id="f51c3cfdb2c95fd18d36a83c0a64f4afa1c8d6e0" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;fringe&lt;/var&gt; is either the symbol &lt;code&gt;left-fringe&lt;/code&gt; or &lt;code&gt;right-fringe&lt;/code&gt;. &lt;var&gt;bitmap&lt;/var&gt; is a symbol identifying the bitmap to display. The optional &lt;var&gt;face&lt;/var&gt; names a face whose foreground and background colors are to be used to display the bitmap, using the attributes of the &lt;code&gt;fringe&lt;/code&gt; face for colors that &lt;var&gt;face&lt;/var&gt; didn&amp;rsquo;t specify. If &lt;var&gt;face&lt;/var&gt; is omitted, that means to use the attributes of the &lt;code&gt;default&lt;/code&gt; face for the colors which the &lt;code&gt;fringe&lt;/code&gt; face didn&amp;rsquo;t specify. For predictable results that don&amp;rsquo;t depend on the attributes of the &lt;code&gt;default&lt;/code&gt; and &lt;code&gt;fringe&lt;/code&gt; faces, we recommend you never omit &lt;var&gt;face&lt;/var&gt;, but always provide a specific face. In particular, if you want the bitmap to be always displayed in the &lt;code&gt;fringe&lt;/code&gt; face, use &lt;code&gt;fringe&lt;/code&gt; as &lt;var&gt;face&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;fringe&lt;/var&gt; 는 &lt;code&gt;left-fringe&lt;/code&gt; 또는 &lt;code&gt;right-fringe&lt;/code&gt; 기호 입니다. &lt;var&gt;bitmap&lt;/var&gt; 은 표시 할 비트 맵을 식별하는 기호입니다. 선택적 &lt;var&gt;face&lt;/var&gt; 은 &lt;var&gt;face&lt;/var&gt; 이 지정하지 않은 색 에 대한 &lt;code&gt;fringe&lt;/code&gt; 얼굴 의 속성을 사용하여 비트 맵을 표시하는 데 사용되는 전경색과 배경색을 가진 얼굴의 이름을 지정합니다. &lt;var&gt;face&lt;/var&gt; 가 생략 된 경우 , 이는 &lt;code&gt;fringe&lt;/code&gt; face가 지정하지 않은 색상에 &lt;code&gt;default&lt;/code&gt; face 의 속성을 사용함을 의미합니다 . &lt;code&gt;default&lt;/code&gt; 및 &lt;code&gt;fringe&lt;/code&gt; 지면의 속성에 의존하지 않는 예측 가능한 결과를 얻으 려면 절대로 생략하지 않는 것이 좋습니다. &lt;var&gt;face&lt;/var&gt; 이지만 항상 특정 얼굴을 제공합니다. 당신이 원하는 경우 특히, 비트 맵은 항상에 표시 할 &lt;code&gt;fringe&lt;/code&gt; 얼굴, 사용 &lt;code&gt;fringe&lt;/code&gt; 같은 &lt;var&gt;face&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="0e67933ea042f44af21af128920ef083d97dd3b1" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;function&lt;/var&gt; is called with four arguments: &lt;var&gt;evald&lt;/var&gt;, &lt;var&gt;func&lt;/var&gt;, &lt;var&gt;args&lt;/var&gt;, and &lt;var&gt;flags&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;function&lt;/var&gt; 은 &lt;var&gt;evald&lt;/var&gt; , &lt;var&gt;func&lt;/var&gt; , &lt;var&gt;args&lt;/var&gt; 및 &lt;var&gt;flags&lt;/var&gt; 의 네 가지 인수로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="96a61bda6352a0a069ba29f13038afcd21b6e3cb" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;function&lt;/var&gt; is compared with functions added to &lt;var&gt;place&lt;/var&gt; using &lt;code&gt;equal&lt;/code&gt;, to try and make it work also with lambda expressions. It is additionally compared also with the &lt;code&gt;name&lt;/code&gt; property of the functions added to &lt;var&gt;place&lt;/var&gt;, which can be more reliable than comparing lambda expressions using &lt;code&gt;equal&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;function&lt;/var&gt; 는 &lt;code&gt;equal&lt;/code&gt; 을 사용하여 &lt;var&gt;place&lt;/var&gt; 추가 된 함수와 비교 되어 람다 식에서도 작동하도록합니다. 또한 &lt;var&gt;place&lt;/var&gt; 에 추가 된 함수 의 &lt;code&gt;name&lt;/code&gt; 속성 과도 비교 됩니다 . 이는 &lt;code&gt;equal&lt;/code&gt; 을 사용하여 람다 식을 비교하는 것보다 더 신뢰할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5575fbb1388958318be1a3552e5c7c509f3c4fc2" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;function&lt;/var&gt; must be a function which, if called with one argument&amp;mdash;the list of the other menu items&amp;mdash;returns the actual items to be displayed in the menu.</source>
          <target state="translated">&lt;var&gt;function&lt;/var&gt; 은 하나의 인수 (다른 메뉴 항목 목록)와 함께 호출되는 경우 메뉴에 표시 될 실제 항목을 반환하는 함수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="7521d4e1d834b0b0b2987dd83395e6b17b51ac26" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;function&lt;/var&gt; should be a function used to initialize the variable when the &lt;code&gt;defcustom&lt;/code&gt; is evaluated. It should take two arguments, the option name (a symbol) and the value. Here are some predefined functions meant for use in this way:</source>
          <target state="translated">&lt;var&gt;function&lt;/var&gt; 은 &lt;code&gt;defcustom&lt;/code&gt; 이 평가 될 때 변수를 초기화하는 데 사용되는 함수 여야합니다 . 옵션 이름 (기호)과 값이라는 두 개의 인수를 가져야합니다. 다음은 이러한 방식으로 사용하기위한 몇 가지 미리 정의 된 함수입니다.</target>
        </trans-unit>
        <trans-unit id="f8f6f9d814feac7c8527f7543b641d0a69a818ed" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;getter&lt;/var&gt; will be bound to a copyable expression that returns the value of &lt;var&gt;place&lt;/var&gt;. &lt;var&gt;setter&lt;/var&gt; will be bound to a function that takes an expression &lt;var&gt;v&lt;/var&gt; and returns a new expression that sets &lt;var&gt;place&lt;/var&gt; to &lt;var&gt;v&lt;/var&gt;. &lt;var&gt;body&lt;/var&gt; should return a Emacs Lisp expression manipulating &lt;var&gt;place&lt;/var&gt; via &lt;var&gt;getter&lt;/var&gt; and &lt;var&gt;setter&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;getter&lt;/var&gt; 는 &lt;var&gt;place&lt;/var&gt; 값을 반환하는 복사 가능한 표현식에 바인딩됩니다 . &lt;var&gt;setter&lt;/var&gt; 는 &lt;var&gt;v&lt;/var&gt; 표현식을 취하고 &lt;var&gt;place&lt;/var&gt; 를 &lt;var&gt;v&lt;/var&gt; 로 설정하는 새 표현식을 반환하는 함수에 바인딩됩니다 . &lt;var&gt;body&lt;/var&gt; 는 &lt;var&gt;getter&lt;/var&gt; 및 &lt;var&gt;setter&lt;/var&gt; 를 통해 &lt;var&gt;place&lt;/var&gt; 를 조작하는 Emacs Lisp 표현식을 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4043993b61e9a42a8e9285bfdbfe54534c1e8638" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;group&lt;/var&gt; should be one of the following:</source>
          <target state="translated">&lt;var&gt;group&lt;/var&gt; 은 다음 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="2d92881cdd8c4025ff540b733613ee07d9cfa4fc" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;handler&lt;/var&gt; describes how to unpack or pack the field and can be one of the following:</source>
          <target state="translated">&lt;var&gt;handler&lt;/var&gt; 는 필드의 압축을 풀거나 압축하는 방법을 설명하며 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14afc8802dd099dffd902090a0a69552b90aa24b" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;height&lt;/var&gt; specifies the height of the horizontal scroll bar in pixels (&lt;code&gt;nil&lt;/code&gt; means use the height specified for the frame). &lt;var&gt;horizontal-type&lt;/var&gt; specifies whether to have a horizontal scroll bar. The possible values are &lt;code&gt;bottom&lt;/code&gt;, &lt;code&gt;t&lt;/code&gt;, which means to use the frame&amp;rsquo;s default, and &lt;code&gt;nil&lt;/code&gt; for no horizontal scroll bar. Note that for a mini window the value &lt;code&gt;t&lt;/code&gt; has the same meaning as &lt;code&gt;nil&lt;/code&gt;, namely to not show a horizontal scroll bar. You have to explicitly specify &lt;code&gt;bottom&lt;/code&gt; in order to show a horizontal scroll bar in a mini window.</source>
          <target state="translated">&lt;var&gt;height&lt;/var&gt; 는 가로 스크롤 막대의 높이를 픽셀 단위로 지정합니다. &lt;code&gt;nil&lt;/code&gt; 은 프레임에 지정된 높이를 사용함을 의미합니다. &lt;var&gt;horizontal-type&lt;/var&gt; 은 수평 스크롤 막대를 가질 지 여부를 지정합니다. 가능한 값은 &lt;code&gt;bottom&lt;/code&gt; , &lt;code&gt;t&lt;/code&gt; 는 프레임의 기본값을 사용함을 의미하고 &lt;code&gt;nil&lt;/code&gt; 은 수평 스크롤 바가없는 경우입니다. 미니 윈도우의 경우 &lt;code&gt;t&lt;/code&gt; 값 은 &lt;code&gt;nil&lt;/code&gt; 과 동일한 의미를 갖습니다 . 즉, 가로 스크롤 막대를 표시하지 않습니다. 미니 창에 가로 스크롤 막대를 표시하려면 &lt;code&gt;bottom&lt;/code&gt; 을 명시 적으로 지정해야 합니다.</target>
        </trans-unit>
        <trans-unit id="6cd4abcdd0cf44425cf91cbe5f1f6af6363adce9" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;help&lt;/var&gt; is a string describing the menu item.</source>
          <target state="translated">&lt;var&gt;help&lt;/var&gt; 는 메뉴 항목을 설명하는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="96a4bc599371ca129df372931368e5d53c4c5189" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;help&lt;/var&gt; specifies a help-echo string to display while the mouse is on that item in the same way as &lt;code&gt;help-echo&lt;/code&gt; text properties (see &lt;a href=&quot;special-properties#Help-display&quot;&gt;Help display&lt;/a&gt;).</source>
          <target state="translated">&lt;var&gt;help&lt;/var&gt; 는 &lt;code&gt;help-echo&lt;/code&gt; 텍스트 속성 과 같은 방식으로 마우스가 해당 항목에있는 동안 표시 할 help-echo 문자열을 지정 합니다 ( &lt;a href=&quot;special-properties#Help-display&quot;&gt;도움말 표시&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="b3a3fe3a0adcd58bec41606b7786fe808bb50fde" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;host&lt;/var&gt;:&lt;var&gt;dpy&lt;/var&gt;.&lt;var&gt;screen&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;host&lt;/var&gt;:&lt;var&gt;dpy&lt;/var&gt;.&lt;var&gt;screen&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="42b4994da7ef7bf80d71cd16fb9dc08946036693" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;host&lt;/var&gt;:&lt;var&gt;server&lt;/var&gt;.&lt;var&gt;screen&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;host&lt;/var&gt;:&lt;var&gt;server&lt;/var&gt;.&lt;var&gt;screen&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="0e3c28fae96e04daa9845a71c500ac2d21de32d1" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;hostname&lt;/var&gt;:&lt;var&gt;displaynumber&lt;/var&gt;.&lt;var&gt;screennumber&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;hostname&lt;/var&gt;:&lt;var&gt;displaynumber&lt;/var&gt;.&lt;var&gt;screennumber&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="1c483a6a0980a0cf8c23d9ab62832084d98a30b1" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;id&lt;/var&gt; is either &lt;code&gt;nil&lt;/code&gt;, or a Lisp object that identifies the entry. If the latter, the cursor stays on the same entry when re-sorting entries. Comparison is done with &lt;code&gt;equal&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;id&lt;/var&gt; 는 &lt;code&gt;nil&lt;/code&gt; 이거나 항목을 식별하는 Lisp 객체입니다. 후자의 경우 항목을 다시 정렬 할 때 커서가 동일한 항목에 유지됩니다. 비교는 &lt;code&gt;equal&lt;/code&gt; 로 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="31818ab23abac17f811cdac8cd47bac29ad5ea73" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;identification&lt;/var&gt; specifies which part of the identifier shall be returned as string. &lt;var&gt;identification&lt;/var&gt; can be the symbol &lt;code&gt;method&lt;/code&gt;, &lt;code&gt;user&lt;/code&gt; or &lt;code&gt;host&lt;/code&gt;; any other value is handled like &lt;code&gt;nil&lt;/code&gt; and means to return the complete identifier string. In the example above, the remote &lt;code&gt;user&lt;/code&gt; identifier string would be &lt;code&gt;root&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;identification&lt;/var&gt; 은 식별자의 어느 부분이 문자열로 반환되는지를 지정합니다. &lt;var&gt;identification&lt;/var&gt; 은 기호 &lt;code&gt;method&lt;/code&gt; , &lt;code&gt;user&lt;/code&gt; 또는 &lt;code&gt;host&lt;/code&gt; 가 될 수 있습니다 . 다른 모든 값은 &lt;code&gt;nil&lt;/code&gt; 처럼 처리 되며 완전한 식별자 문자열을 반환하는 것을 의미합니다. 위의 예에서 원격 &lt;code&gt;user&lt;/code&gt; 식별자 문자열은 &lt;code&gt;root&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="86739b7293c7a619312c3904fbbaab23074b10ee" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;image&lt;/var&gt; is either a single image specification (see &lt;a href=&quot;images#Images&quot;&gt;Images&lt;/a&gt;) or a vector of four image specifications. If you use a vector of four, one of them is used, depending on circumstances:</source>
          <target state="translated">&lt;var&gt;image&lt;/var&gt; 는 단일 이미지 사양 ( &lt;a href=&quot;images#Images&quot;&gt;Images&lt;/a&gt; 참조 )이거나 4 개의 이미지 사양으로 구성된 벡터입니다. 4 개의 벡터를 사용하는 경우 상황에 따라 그중 하나가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3054de9d7101f47ab193522932e03068882fe0a2" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;include&lt;/var&gt; is an expression; if it evaluates to &lt;code&gt;nil&lt;/code&gt;, the item is made invisible. &lt;code&gt;:included&lt;/code&gt; is an alias for &lt;code&gt;:visible&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;include&lt;/var&gt; 는 표현식입니다. &lt;code&gt;nil&lt;/code&gt; 로 평가 되면 항목이 보이지 않게됩니다. &lt;code&gt;:included&lt;/code&gt; 는 &lt;code&gt;:visible&lt;/code&gt; 의 별칭입니다 .</target>
        </trans-unit>
        <trans-unit id="7c4739c613e959e93e32b340d505b80d83477102" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;include&lt;/var&gt; is an expression; if it evaluates to &lt;code&gt;nil&lt;/code&gt;, the menu is made invisible. &lt;code&gt;:included&lt;/code&gt; is an alias for &lt;code&gt;:visible&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;include&lt;/var&gt; 는 표현식입니다. &lt;code&gt;nil&lt;/code&gt; 로 평가 되면 메뉴가 보이지 않게됩니다. &lt;code&gt;:included&lt;/code&gt; 는 &lt;code&gt;:visible&lt;/code&gt; 의 별칭입니다 .</target>
        </trans-unit>
        <trans-unit id="6420fd3e3f459ab10132a472e9ecc278de5f7219" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;initial&lt;/var&gt; can also be a cons cell of the form &lt;code&gt;(&lt;var&gt;string&lt;/var&gt;
. &lt;var&gt;position&lt;/var&gt;)&lt;/code&gt;. This means to insert &lt;var&gt;string&lt;/var&gt; in the minibuffer but put point at &lt;var&gt;position&lt;/var&gt; within the string&amp;rsquo;s text.</source>
          <target state="translated">&lt;var&gt;initial&lt;/var&gt; 은 &lt;code&gt;(&lt;var&gt;string&lt;/var&gt; . &lt;var&gt;position&lt;/var&gt;)&lt;/code&gt; 형식의 단점 셀일 수도 있습니다 . 이것은 미니 버퍼에 &lt;var&gt;string&lt;/var&gt; 을 삽입 하지만 문자열의 텍스트 내 &lt;var&gt;position&lt;/var&gt; 에 포인트를 두는 것을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="4b206e32ad38dde073c99970ff35c938f9f6fb77" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;instance&lt;/var&gt;.&lt;var&gt;attribute&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;instance&lt;/var&gt;.&lt;var&gt;attribute&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="718efbcd8e4b5b6b8e8b13b1459e1cc03479ab48" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;instance&lt;/var&gt;.&lt;var&gt;component&lt;/var&gt;.&lt;var&gt;attribute&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;instance&lt;/var&gt;.&lt;var&gt;component&lt;/var&gt;.&lt;var&gt;attribute&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="4248e5e822e0f5d532af3eedf7c73be8341c3ad8" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;keys&lt;/var&gt; is a hint indicating which key sequence to display as keyboard equivalent, in case the command is bound to several key sequences. It has no effect if &lt;var&gt;keys&lt;/var&gt; is not bound to same command as this menu item.</source>
          <target state="translated">&lt;var&gt;keys&lt;/var&gt; 는 명령이 여러 키 시퀀스에 바인딩 된 경우 키보드에 해당하는 키 시퀀스를 표시하는 힌트입니다. &lt;var&gt;keys&lt;/var&gt; 가이 메뉴 항목과 동일한 명령에 바인딩되어 있지 않으면 아무 효과 가 없습니다.</target>
        </trans-unit>
        <trans-unit id="62f6c891a1b05f30a58f0aeeed5e7c0f2822315d" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;keys&lt;/var&gt; is a string to display as keyboard equivalent to the menu item. This is normally not needed, as keyboard equivalents are computed automatically. &lt;var&gt;keys&lt;/var&gt; is expanded with &lt;code&gt;substitute-command-keys&lt;/code&gt; before it is displayed (see &lt;a href=&quot;keys-in-documentation#Keys-in-Documentation&quot;&gt;Keys in Documentation&lt;/a&gt;).</source>
          <target state="translated">&lt;var&gt;keys&lt;/var&gt; 는 메뉴 항목에 해당하는 키보드로 표시 할 문자열입니다. 키보드 등가물이 자동으로 계산되므로 일반적으로 필요하지 않습니다. &lt;var&gt;keys&lt;/var&gt; 는 표시되기 전에 &lt;code&gt;substitute-command-keys&lt;/code&gt; 키로 확장 됩니다 ( &lt;a href=&quot;keys-in-documentation#Keys-in-Documentation&quot;&gt;설명서의 키&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="596b2e28f20e0f7c98531ef608bc15ad4ac40bab" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;library&lt;/var&gt; can also be a feature (i.e., a symbol), in which case &lt;var&gt;body&lt;/var&gt; is evaluated at the end of any file where &lt;code&gt;(provide &lt;var&gt;library&lt;/var&gt;)&lt;/code&gt; is called.</source>
          <target state="translated">&lt;var&gt;library&lt;/var&gt; 는 또한 기능 (즉, 심볼)이 될 수 있으며,이 경우 &lt;var&gt;body&lt;/var&gt; 는 &lt;code&gt;(provide &lt;var&gt;library&lt;/var&gt;)&lt;/code&gt; 가 호출 되는 모든 파일의 끝에서 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="3000b097be57636b873656a46f8475a5f1beb072" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;map&lt;/var&gt; must contain an appropriate keymap bound to &lt;code&gt;[menu-bar]&lt;/code&gt;. The remaining arguments &lt;var&gt;props&lt;/var&gt; are additional property list elements to add to the menu item specification.</source>
          <target state="translated">&lt;var&gt;map&lt;/var&gt; 은 &lt;code&gt;[menu-bar]&lt;/code&gt; 에 바인딩 된 적절한 키맵을 포함해야합니다 . 나머지 인수 &lt;var&gt;props&lt;/var&gt; 은 메뉴 항목 사양에 추가 할 추가 속성 목록 요소입니다.</target>
        </trans-unit>
        <trans-unit id="a521da8968366f92cee94a02ace1fd6c8e079a13" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;max-costs&lt;/var&gt; defines the quality of the difference computation. If the actual costs exceed this limit, heuristics are used to provide a faster but suboptimal solution. The default value is 1000000.</source>
          <target state="translated">&lt;var&gt;max-costs&lt;/var&gt; 은 차이 계산의 품질을 정의합니다. 실제 비용이이 한도를 초과하면 더 빠르지 만 최적이 아닌 솔루션을 제공하기 위해 휴리스틱이 사용됩니다. 기본값은 1000000입니다.</target>
        </trans-unit>
        <trans-unit id="a763217bb3a14d4f74e940f501ce1a0a143c32e1" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;max-secs&lt;/var&gt; defines a hard boundary in terms of seconds. If given and exceeded, it will fall back to &lt;code&gt;delete-region&lt;/code&gt; and &lt;code&gt;insert-buffer-substring&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;max-secs&lt;/var&gt; 는 초 단위로 하드 경계를 정의합니다. 주어지고 초과되면 &lt;code&gt;delete-region&lt;/code&gt; 및 &lt;code&gt;insert-buffer-substring&lt;/code&gt; 으로 돌아갑니다 .</target>
        </trans-unit>
        <trans-unit id="a5c8a5efcfb5474cdb45133f3322fdc9ebc87680" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;method&lt;/var&gt; can be:</source>
          <target state="translated">&lt;var&gt;method&lt;/var&gt; 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="27fa08ba53bae7468bfa10b0879a0af63b63c7ff" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;method&lt;/var&gt; should be the method name that was passed to &lt;code&gt;smie-rules-function&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;method&lt;/var&gt; 는 &lt;code&gt;smie-rules-function&lt;/code&gt; 에 전달 된 메서드 이름이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="50b807ebac2655b0d8a5c152f0862476091a5d62" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;modename&lt;/var&gt;-mode-hook</source>
          <target state="translated">&lt;var&gt;modename&lt;/var&gt;-mode-hook</target>
        </trans-unit>
        <trans-unit id="586b5298d2b503845edf7730bbc979076f5aeccd" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;name&lt;/var&gt; can be supplied to give a name to the thread. The name is used for debugging and informational purposes only; it has no meaning to Emacs. If &lt;var&gt;name&lt;/var&gt; is provided, it must be a string.</source>
          <target state="translated">&lt;var&gt;name&lt;/var&gt; 을 제공하여 스레드에 이름을 지정할 수 있습니다. 이름은 디버깅 및 정보 제공 목적으로 만 사용됩니다. Emacs에게는 의미가 없습니다. &lt;var&gt;name&lt;/var&gt; 이 제공되는 경우 문자열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="5eebb341ded2a927ba41d8e9885ef924c499a969" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;name&lt;/var&gt; is the column&amp;rsquo;s name (a string).</source>
          <target state="translated">&lt;var&gt;name&lt;/var&gt; 은 열의 이름 (문자열)입니다.</target>
        </trans-unit>
        <trans-unit id="8bc34451416eb9bb94dc7e49d8604ec8fead239e" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;name&lt;/var&gt; should be a string. The argument &lt;var&gt;expansion&lt;/var&gt; is normally the desired expansion (a string), or &lt;code&gt;nil&lt;/code&gt; to undefine the abbrev. If it is anything but a string or &lt;code&gt;nil&lt;/code&gt;, then the abbreviation expands solely by running &lt;var&gt;hook&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;name&lt;/var&gt; 은 문자열이어야합니다. 인수 &lt;var&gt;expansion&lt;/var&gt; 은 일반적으로 원하는 확장 (문자열)이거나 약어를 정의 &lt;code&gt;nil&lt;/code&gt; 려면 nil 입니다. 문자열이나 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 약어는 &lt;var&gt;hook&lt;/var&gt; 를 실행하여 확장됩니다 .</target>
        </trans-unit>
        <trans-unit id="30b5243fd966445dc45a08c73f83cb0da097f434" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;name&lt;/var&gt;-&lt;var&gt;version&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;name&lt;/var&gt;-&lt;var&gt;version&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="cf344c891bff62333dbba018c548d00aaff7e834" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;name&lt;/var&gt;-&lt;var&gt;version&lt;/var&gt;.tar</source>
          <target state="translated">&lt;var&gt;name&lt;/var&gt;-&lt;var&gt;version&lt;/var&gt;.tar</target>
        </trans-unit>
        <trans-unit id="216a58edd79a48074a5ad6617458bb495b2790c5" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;name&lt;/var&gt;-autoloads.el</source>
          <target state="translated">&lt;var&gt;name&lt;/var&gt;-autoloads.el</target>
        </trans-unit>
        <trans-unit id="167bb5544e79104b156c0e1d7f1157bf42714410" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;name&lt;/var&gt;-pkg.el</source>
          <target state="translated">&lt;var&gt;name&lt;/var&gt;-pkg.el</target>
        </trans-unit>
        <trans-unit id="9e81faaecc9188da3158c2527f5a008ccce20eb6" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;name&lt;/var&gt;/../</source>
          <target state="translated">&lt;var&gt;name&lt;/var&gt;/../</target>
        </trans-unit>
        <trans-unit id="ab97241a11e66b9d7122a5dccc133b2a7f1d73a4" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;nextrecfun&lt;/var&gt; is called with point at the end of a record. This function moves point to the start of the next record. The first record is assumed to start at the position of point when &lt;code&gt;sort-subr&lt;/code&gt; is called. Therefore, you should usually move point to the beginning of the buffer before calling &lt;code&gt;sort-subr&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;nextrecfun&lt;/var&gt; 은 레코드 끝에서 포인트로 호출됩니다. 이 기능은 다음 레코드의 시작 지점으로 이동합니다. 첫 번째 레코드는 &lt;code&gt;sort-subr&lt;/code&gt; 이 호출 될 때 포인트 위치에서 시작하는 것으로 가정합니다 . 따라서 일반적으로 &lt;code&gt;sort-subr&lt;/code&gt; 을 호출하기 전에 포인트를 버퍼의 시작 부분으로 이동해야합니다 .</target>
        </trans-unit>
        <trans-unit id="cf466c1676191116404da7c893fc26c9b6a9eeb6" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;number&lt;/var&gt;: offset by &lt;var&gt;number&lt;/var&gt;, relative to a base token which is the current token for &lt;code&gt;:after&lt;/code&gt; and its parent for &lt;code&gt;:before&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;number&lt;/var&gt; : &lt;code&gt;:after&lt;/code&gt; 의 현재 토큰 이고 &lt;code&gt;:before&lt;/code&gt; 의 부모 인 기본 토큰에 상대적인 &lt;var&gt;number&lt;/var&gt; 오프셋됩니다 .</target>
        </trans-unit>
        <trans-unit id="b62a446c8e768cf79eea37dae884533e6c6dbd9c" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;offset&lt;/var&gt; can be:</source>
          <target state="translated">&lt;var&gt;offset&lt;/var&gt; 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="de3cf1331d6c45eb1d3caca8b7b2d4f52e3a4ef9" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;order&lt;/var&gt; may also be omitted or &lt;code&gt;nil&lt;/code&gt;. Then the numeric order of &lt;var&gt;element&lt;/var&gt; stays unchanged if it already has one; otherwise, &lt;var&gt;element&lt;/var&gt; has no numeric order. Elements without a numeric list order are placed at the end of the list, in no particular order.</source>
          <target state="translated">&lt;var&gt;order&lt;/var&gt; 는 생략하거나 &lt;code&gt;nil&lt;/code&gt; 할 수도 있습니다 . 그런 다음 &lt;var&gt;element&lt;/var&gt; 의 숫자 순서는 이미있는 경우 변경되지 않습니다. 그렇지 않으면 &lt;var&gt;element&lt;/var&gt; 에 숫자 순서가 없습니다. 숫자 목록 순서가없는 요소는 특정 순서없이 목록 끝에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="99c4d75e06c1981a99d6ec13897814fd98ced18d" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;package&lt;/var&gt; should be the official name of the package, as a symbol (e.g., &lt;code&gt;MH-E&lt;/code&gt;). &lt;var&gt;version&lt;/var&gt; should be a string. If the package &lt;var&gt;package&lt;/var&gt; is released as part of Emacs, &lt;var&gt;package&lt;/var&gt; and &lt;var&gt;version&lt;/var&gt; should appear in the value of &lt;code&gt;customize-package-emacs-version-alist&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;package&lt;/var&gt; 는 기호로 된 패키지의 공식 이름이어야합니다 (예 : &lt;code&gt;MH-E&lt;/code&gt; ). &lt;var&gt;version&lt;/var&gt; 은 문자열이어야합니다. 패키지 &lt;var&gt;package&lt;/var&gt; 가 Emacs의 일부로 출시 된 경우 &lt;var&gt;package&lt;/var&gt; 및 &lt;var&gt;version&lt;/var&gt; 은 &lt;code&gt;customize-package-emacs-version-alist&lt;/code&gt; 값에 표시되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="6894fefccfb7ff6f9b8c6767f4eccbdc010b5930" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;pairs&lt;/var&gt; is a list of variable and value pairs. This macro creates a buffer-local binding in the current buffer for each of the variables, and gives them a buffer-local value. It is equivalent to calling &lt;code&gt;make-local-variable&lt;/code&gt; followed by &lt;code&gt;setq&lt;/code&gt; for each of the variables. The variables should be unquoted symbols.</source>
          <target state="translated">&lt;var&gt;pairs&lt;/var&gt; 은 변수 및 값 쌍의 목록입니다. 이 매크로는 각 변수에 대해 현재 버퍼에 버퍼 로컬 바인딩을 만들고 버퍼 로컬 값을 제공합니다. 각 &lt;code&gt;make-local-variable&lt;/code&gt; 에 대해 make-local-variable 다음에 &lt;code&gt;setq&lt;/code&gt; 를 호출 하는 것과 같습니다 . 변수는 따옴표가없는 기호 여야합니다.</target>
        </trans-unit>
        <trans-unit id="faac51bbe73b1a7baf50319796f7718c84360e1d" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;position&lt;/var&gt; is a mouse position list (see &lt;a href=&quot;click-events#Click-Events&quot;&gt;Click Events&lt;/a&gt;), specifying the current position of the mouse cursor. As with the end-position of a drag event, this position list may represent a location outside the boundaries of the initially selected frame, in which case the list contains that frame in place of a window.</source>
          <target state="translated">&lt;var&gt;position&lt;/var&gt; 은 마우스 위치 목록 ( &lt;a href=&quot;click-events#Click-Events&quot;&gt;클릭 이벤트&lt;/a&gt; 참조 )으로, 마우스 커서의 현재 위치를 지정합니다. 드래그 이벤트의 끝 위치와 마찬가지로이 위치 목록은 처음 선택한 프레임의 경계 외부에있는 위치를 나타낼 수 있습니다.이 경우 목록에는 창 대신 해당 프레임이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="f59e3c7c715366ed238889ef97ba31c569ce7eb7" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;predicate&lt;/var&gt; can either be &lt;code&gt;t&lt;/code&gt; (which is a synonym for &lt;code&gt;equal&lt;/code&gt;), &lt;code&gt;nil&lt;/code&gt; (which means &amp;ldquo;not equal&amp;rdquo;), or a predicate that will be called with two parameters: The first is &lt;var&gt;value&lt;/var&gt;, and the second is the value of the text property we&amp;rsquo;re inspecting.</source>
          <target state="translated">&lt;var&gt;predicate&lt;/var&gt; 는 &lt;code&gt;t&lt;/code&gt; ( &lt;code&gt;equal&lt;/code&gt; 의 동의어 ), &lt;code&gt;nil&lt;/code&gt; ( &quot;같지 않음&quot;을 의미) 또는 두 개의 매개 변수로 호출되는 술어 일 수 있습니다. 첫 번째는 &lt;var&gt;value&lt;/var&gt; 이고 두 번째는 text 속성의 값입니다. 검사 중입니다.</target>
        </trans-unit>
        <trans-unit id="df5ae6820e0b025e86df03022536665959855d02" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;prefix&lt;/var&gt;--&amp;hellip;</source>
          <target state="translated">&lt;var&gt;prefix&lt;/var&gt;--&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="2701a0d0273e8b0469c3357e04df113afa7340aa" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;prefix&lt;/var&gt;.el</source>
          <target state="translated">&lt;var&gt;prefix&lt;/var&gt;.el</target>
        </trans-unit>
        <trans-unit id="415cc0168ff768c5644927069f207439cffdcaaf" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;question&lt;/var&gt;...&lt;var&gt;answer&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;question&lt;/var&gt;...&lt;var&gt;answer&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="b1a5e789f14de0932441acbb046bd1a8125964ba" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;radix&lt;/var&gt;r</source>
          <target state="translated">&lt;var&gt;radix&lt;/var&gt;r</target>
        </trans-unit>
        <trans-unit id="9490106685cc5ae114d3b5a517eee30cb47980e5" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;remapping&lt;/var&gt; may be any face spec suitable for a &lt;code&gt;face&lt;/code&gt; text property: either a face (i.e., a face name or a property list of attribute/value pairs), or a list of faces. For details, see the description of the &lt;code&gt;face&lt;/code&gt; text property in &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Special Properties&lt;/a&gt;. &lt;var&gt;remapping&lt;/var&gt; serves as the complete specification for the remapped face&amp;mdash;it replaces the normal definition of &lt;var&gt;face&lt;/var&gt;, instead of modifying it.</source>
          <target state="translated">&lt;var&gt;remapping&lt;/var&gt; 은 얼굴 (즉, 얼굴 이름 또는 속성 / 값 쌍의 속성 목록) 또는 얼굴 목록과 같은 &lt;code&gt;face&lt;/code&gt; 텍스트 속성에 적합한 얼굴 사양 일 수 있습니다 . 자세한 내용 은 &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;특수 속성&lt;/a&gt; 의 &lt;code&gt;face&lt;/code&gt; 텍스트 속성에 대한 설명을 참조하십시오 . &lt;var&gt;remapping&lt;/var&gt; 은 다시 매핑 된면에 대한 완전한 사양으로 사용되며, 수정하는 대신 &lt;var&gt;face&lt;/var&gt; 의 일반 정의를 대체 합니다.</target>
        </trans-unit>
        <trans-unit id="7710cef71b2a55732fa034589d5a9648abf147de" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;repeated-args&lt;/var&gt;&amp;hellip;</source>
          <target state="translated">&lt;var&gt;repeated-args&lt;/var&gt;&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="e4128ed07ab55fb2620ee23c8c4002a9d6d8a606" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;reporter&lt;/var&gt; must be the result of a call to &lt;code&gt;make-progress-reporter&lt;/code&gt;. &lt;var&gt;value&lt;/var&gt; specifies the current state of your operation and must be between &lt;var&gt;min-value&lt;/var&gt; and &lt;var&gt;max-value&lt;/var&gt; (inclusive) as passed to &lt;code&gt;make-progress-reporter&lt;/code&gt;. For instance, if you scan a buffer, then &lt;var&gt;value&lt;/var&gt; should be the result of a call to &lt;code&gt;point&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;reporter&lt;/var&gt; 는 &lt;code&gt;make-progress-reporter&lt;/code&gt; 호출의 결과 여야합니다 . &lt;var&gt;value&lt;/var&gt; 는 작업의 현재 상태를 지정하며 &lt;code&gt;make-progress-reporter&lt;/code&gt; 에 전달 될 때 &lt;var&gt;min-value&lt;/var&gt; 과 &lt;var&gt;max-value&lt;/var&gt; (포함) 사이에 있어야합니다 . 예를 들어 버퍼를 스캔하는 경우 &lt;var&gt;value&lt;/var&gt; 는 &lt;code&gt;point&lt;/code&gt; 에 대한 호출의 결과 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="0c7b8b66a17ec0d9e7d1c618f4047785138de257" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;reporter&lt;/var&gt;, &lt;var&gt;value&lt;/var&gt;, and &lt;var&gt;suffix&lt;/var&gt; have the same meaning as for &lt;code&gt;progress-reporter-update&lt;/code&gt;. Optional &lt;var&gt;new-message&lt;/var&gt; allows you to change the message of the &lt;var&gt;reporter&lt;/var&gt;. Since this function always updates the echo area, such a change will be immediately presented to the user.</source>
          <target state="translated">&lt;var&gt;reporter&lt;/var&gt; , &lt;var&gt;value&lt;/var&gt; 및 &lt;var&gt;suffix&lt;/var&gt; 는 &lt;code&gt;progress-reporter-update&lt;/code&gt; 와 동일한 의미를 갖습니다 . 선택 사항 인 &lt;var&gt;new-message&lt;/var&gt; 를 사용하면 &lt;var&gt;reporter&lt;/var&gt; 의 메시지를 변경할 수 있습니다 . 이 기능은 항상 에코 영역을 업데이트하므로 이러한 변경 사항이 사용자에게 즉시 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="d51fe7a021174666b578e4a21bdb3a618171cc76" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;requirements&lt;/var&gt; is a list of required packages and their versions. Each element in this list should have the form &lt;code&gt;(&lt;var&gt;dep-name&lt;/var&gt;
&lt;var&gt;dep-version&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;dep-name&lt;/var&gt; is a symbol whose name is the dependency&amp;rsquo;s package name, and &lt;var&gt;dep-version&lt;/var&gt; is the dependency&amp;rsquo;s version (a string).</source>
          <target state="translated">&lt;var&gt;requirements&lt;/var&gt; 은 필수 패키지 및 해당 버전 목록입니다. 이 목록의 각 요소는 &lt;code&gt;(&lt;var&gt;dep-name&lt;/var&gt; &lt;var&gt;dep-version&lt;/var&gt;)&lt;/code&gt; 형식이어야합니다 . 여기서 &lt;var&gt;dep-name&lt;/var&gt; 은 이름이 종속성의 패키지 이름 인 기호이고 &lt;var&gt;dep-version&lt;/var&gt; 은 종속성의 버전 (문자열)입니다.</target>
        </trans-unit>
        <trans-unit id="e737d37d389d75f9cac6bb7ddb721d5c73f5fc03" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;selected&lt;/var&gt; is an expression; the checkbox or radio button is selected whenever the expression&amp;rsquo;s value is non-&lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;selected&lt;/var&gt; 는 표현식입니다. 표현식의 값이 &lt;code&gt;nil&lt;/code&gt; 이 아닐 때마다 확인란 또는 라디오 버튼이 선택 됩니다.</target>
        </trans-unit>
        <trans-unit id="4e76826cc6b334ade60730144fcdff6d3be4a681" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;service&lt;/var&gt; specifies a port number to connect to; or, for a server, the port number to listen on. It should be a service name like &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;service&lt;/var&gt; 는 연결할 포트 번호를 지정합니다. 또는 서버의 경우 수신 대기 할 포트 번호입니다. '와 같은 서비스 이름이어야합니다.</target>
        </trans-unit>
        <trans-unit id="973adcc3dd59f5f52753edf51047c9f8e5fa5e46" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;sort&lt;/var&gt; specifies how to sort entries by the column. If &lt;code&gt;nil&lt;/code&gt;, the column cannot be used for sorting. If &lt;code&gt;t&lt;/code&gt;, the column is sorted by comparing string values. Otherwise, this should be a predicate function for &lt;code&gt;sort&lt;/code&gt; (see &lt;a href=&quot;rearrangement#Rearrangement&quot;&gt;Rearrangement&lt;/a&gt;), which accepts two arguments with the same form as the elements of &lt;code&gt;tabulated-list-entries&lt;/code&gt; (see below).</source>
          <target state="translated">&lt;var&gt;sort&lt;/var&gt; 는 열을 기준으로 항목을 정렬하는 방법을 지정합니다. 경우 &lt;code&gt;nil&lt;/code&gt; , 열 정렬에 사용할 수 없습니다. 경우 &lt;code&gt;t&lt;/code&gt; , 열은 문자열 값을 비교하여 정렬됩니다. 그렇지 않으면, 이것은 &lt;code&gt;sort&lt;/code&gt; 위한 술어 함수 여야합니다 (재 &lt;a href=&quot;rearrangement#Rearrangement&quot;&gt;배열&lt;/a&gt; 참조 ). 이것은 &lt;code&gt;tabulated-list-entries&lt;/code&gt; 의 요소와 동일한 형식을 가진 두 개의 인수를 허용 합니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="7d39073d4b8db9cde37f102e3b0b1b5f83406619" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;speed&lt;/var&gt; is the speed of the serial port in bits per second. 9600 is a common value. The buffer is in Term mode; see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Term-Mode.html#Term-Mode&quot;&gt;Term Mode&lt;/a&gt; in</source>
          <target state="translated">&lt;var&gt;speed&lt;/var&gt; 는 직렬 포트의 속도 (초당 비트 수)입니다. 9600은 일반적인 값입니다. 버퍼가 기간 모드에 있습니다. 참조 &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Term-Mode.html#Term-Mode&quot;&gt;기간 모드&lt;/a&gt; 에</target>
        </trans-unit>
        <trans-unit id="971f47e8670651577dc6a42bb689ff8bc62ca26d" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt; delimit the text to complete (which should enclose point). &lt;var&gt;collection&lt;/var&gt; is a completion table for completing that text, in a form suitable for passing as the second argument to &lt;code&gt;try-completion&lt;/code&gt; (see &lt;a href=&quot;basic-completion#Basic-Completion&quot;&gt;Basic Completion&lt;/a&gt;); completion alternatives will be generated from this completion table in the usual way, via the completion styles defined in &lt;code&gt;completion-styles&lt;/code&gt; (see &lt;a href=&quot;completion-variables#Completion-Variables&quot;&gt;Completion Variables&lt;/a&gt;). &lt;var&gt;props&lt;/var&gt; is a property list for additional information; any of the properties in &lt;code&gt;completion-extra-properties&lt;/code&gt; are recognized (see &lt;a href=&quot;completion-variables#Completion-Variables&quot;&gt;Completion Variables&lt;/a&gt;), as well as the following additional ones:</source>
          <target state="translated">&lt;var&gt;start&lt;/var&gt; 과 &lt;var&gt;end&lt;/var&gt; 은 완료 할 텍스트를 구분합니다 (포인트를 묶어야 함). &lt;var&gt;collection&lt;/var&gt; 은 &lt;code&gt;try-completion&lt;/code&gt; 에 대한 두 번째 인수로 전달하기에 적합한 형식으로 해당 텍스트를 완성하기위한 완성 테이블입니다 ( &lt;a href=&quot;basic-completion#Basic-Completion&quot;&gt;Basic Completion&lt;/a&gt; 참조 ). 완성 대안에 정의 완료 스타일을 통해, 일반적인 방법으로이 완료 테이블에서 생성됩니다 &lt;code&gt;completion-styles&lt;/code&gt; (참조 &lt;a href=&quot;completion-variables#Completion-Variables&quot;&gt;완료 변수&lt;/a&gt; ). &lt;var&gt;props&lt;/var&gt; 는 추가 정보를위한 속성 목록입니다. 의 속성의 &lt;code&gt;completion-extra-properties&lt;/code&gt; (참조 인식 &lt;a href=&quot;completion-variables#Completion-Variables&quot;&gt;완료 변수&lt;/a&gt; 뿐만 아니라 다음과 같은 추가 것들) :</target>
        </trans-unit>
        <trans-unit id="9309574541180ffc910dcfe02cdda08d3749f086" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;start&lt;/var&gt; may be a string, in which case &lt;var&gt;end&lt;/var&gt; is ignored and the returned value references string indices instead of buffer positions.</source>
          <target state="translated">&lt;var&gt;start&lt;/var&gt; 는 문자열 일 수 있습니다.이 경우 &lt;var&gt;end&lt;/var&gt; 는 무시되고 반환 된 값은 버퍼 위치 대신 문자열 인덱스를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="da4a280c768d1277e096e4c3e78a80bca4fe7713" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;startkeyfun&lt;/var&gt; is called to move point from the start of a record to the start of the sort key. This argument is optional; if it is omitted, the whole record is the sort key. If supplied, the function should either return a non-&lt;code&gt;nil&lt;/code&gt; value to be used as the sort key, or return &lt;code&gt;nil&lt;/code&gt; to indicate that the sort key is in the buffer starting at point. In the latter case, &lt;var&gt;endkeyfun&lt;/var&gt; is called to find the end of the sort key.</source>
          <target state="translated">&lt;var&gt;startkeyfun&lt;/var&gt; 은 레코드의 시작에서 정렬 키의 시작으로 포인트를 이동하기 위해 호출됩니다. 이 인수는 선택 사항입니다. 생략하면 전체 레코드가 정렬 키입니다. 제공된 경우 함수는 정렬 키로 사용할 &lt;code&gt;nil&lt;/code&gt; 이 아닌 값을 반환하거나 정렬 키가 지점에서 시작하는 버퍼에 있음을 나타 내기 위해 &lt;code&gt;nil&lt;/code&gt; 을 반환 해야합니다. 후자의 경우 정렬 키의 끝을 찾기 위해 &lt;var&gt;endkeyfun&lt;/var&gt; 이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="f73238806df0360ca7ee8bae497b6f974a669f33" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;style&lt;/var&gt; is a symbol describing the type of menu item; it should be &lt;code&gt;toggle&lt;/code&gt; (a checkbox), or &lt;code&gt;radio&lt;/code&gt; (a radio button), or anything else (meaning an ordinary menu item).</source>
          <target state="translated">&lt;var&gt;style&lt;/var&gt; 은 메뉴 항목의 유형을 설명하는 기호입니다. &lt;code&gt;toggle&lt;/code&gt; (체크 박스), &lt;code&gt;radio&lt;/code&gt; (라디오 버튼) 또는 기타 (일반 메뉴 항목을 의미) 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="7e15045cd15efc60dcbadbf4a9bfc1c74a850b81" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;symbol&lt;/var&gt; should be a function name; that function is called to calculate the indentation of a line within this expression. The function receives two arguments:</source>
          <target state="translated">&lt;var&gt;symbol&lt;/var&gt; 는 함수 이름이어야합니다. 해당 함수는이 표현식 내에서 줄의 들여 쓰기를 계산하기 위해 호출됩니다. 이 함수는 두 개의 인수를받습니다.</target>
        </trans-unit>
        <trans-unit id="b66f2812c276f2743d9f7dec6d2407921c4d0a73" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;tag&lt;/var&gt; matches if it is &lt;code&gt;equal&lt;/code&gt; to the value of &lt;var&gt;form&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;tag&lt;/var&gt; 가 &lt;var&gt;form&lt;/var&gt; 의 값 &lt;code&gt;equal&lt;/code&gt; 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="c11330b958f1facf64bc5c4a8eb2f52f8887ebe9" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;tag&lt;/var&gt; matches unconditionally if it is &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;tag&lt;/var&gt; 가 &lt;code&gt;t&lt;/code&gt; 인 경우 무조건 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="fa74cd02b9eeaeaf01040683ef1ec0eda3535dae" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;time&lt;/var&gt; may specify an absolute or a relative time.</source>
          <target state="translated">&lt;var&gt;time&lt;/var&gt; 은 절대 또는 상대 시간을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95feb66b937fd5d812ad2340ecbc42562d0ebd18" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;title&lt;/var&gt; is a string to display in the mode line while this method is active. &lt;var&gt;description&lt;/var&gt; is a string describing this method and what it is good for.</source>
          <target state="translated">&lt;var&gt;title&lt;/var&gt; 은이 메서드가 활성화되어있는 동안 모드 행에 표시 할 문자열입니다. &lt;var&gt;description&lt;/var&gt; 은이 메서드와 그 용도를 설명하는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="a98d01c0ccac615cc082b2f95fdfe91a54d7a493" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;to-fn&lt;/var&gt; must not involve buffers or files other than the one being encoded, otherwise the internal buffer used for formatting might be overwritten.</source>
          <target state="translated">&lt;var&gt;to-fn&lt;/var&gt; 은 인코딩되는 것 이외의 버퍼 나 파일을 포함해서는 안됩니다. 그렇지 않으면 포맷에 사용 된 내부 버퍼를 덮어 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b832016f06701ddcb16ef3791cf3a3ce2a9399c1" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;type&lt;/var&gt; should be a symbol; it is usually one of &lt;code&gt;PRIMARY&lt;/code&gt;, &lt;code&gt;SECONDARY&lt;/code&gt; or &lt;code&gt;CLIPBOARD&lt;/code&gt;. These are symbols with upper-case names, in accord with X Window System conventions. If &lt;var&gt;type&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, that stands for &lt;code&gt;PRIMARY&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;type&lt;/var&gt; 은 기호 여야합니다. 일반적으로 &lt;code&gt;PRIMARY&lt;/code&gt; , &lt;code&gt;SECONDARY&lt;/code&gt; 또는 &lt;code&gt;CLIPBOARD&lt;/code&gt; 중 하나입니다 . X Window System 규칙에 따라 대문자 이름이있는 기호입니다. 경우 &lt;var&gt;type&lt;/var&gt; 이다 &lt;code&gt;nil&lt;/code&gt; , 그 의미 &lt;code&gt;PRIMARY&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a342c7d2cce7402a90fc60df3bea3e251c92fd5d" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;value&lt;/var&gt; is sent into the iterator and becomes the value to which &lt;code&gt;iter-yield&lt;/code&gt; evaluates. &lt;var&gt;value&lt;/var&gt; is ignored for the first &lt;code&gt;iter-next&lt;/code&gt; call to a given iterator, since at the start of &lt;var&gt;iterator&lt;/var&gt;&amp;rsquo;s generator function, the generator function is not evaluating any &lt;code&gt;iter-yield&lt;/code&gt; form.</source>
          <target state="translated">&lt;var&gt;value&lt;/var&gt; 는 반복자로 전송되고 &lt;code&gt;iter-yield&lt;/code&gt; 가 평가 하는 값이 됩니다. &lt;var&gt;iterator&lt;/var&gt; 의 생성기 함수 가 시작될 때 생성기 함수가 반복 &lt;code&gt;iter-yield&lt;/code&gt; 형식을 평가하지 않기 때문에 주어진 반복기 에 대한 첫 번째 &lt;code&gt;iter-next&lt;/code&gt; 호출에 대해 &lt;var&gt;value&lt;/var&gt; 가 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="82930ebb4abfe28d89aca586ee4550c2d7c57fee" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;var&lt;/var&gt; is a variable name (a symbol), and &lt;var&gt;expression&lt;/var&gt; is an expression which evaluates to the desired customized value.</source>
          <target state="translated">&lt;var&gt;var&lt;/var&gt; 는 변수 이름 (기호)이고 &lt;var&gt;expression&lt;/var&gt; 은 원하는 사용자 정의 값으로 평가되는 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="ad71f6f9e29b21a5a4b5ba0031c96e235018c497" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;watch-function&lt;/var&gt; will be called, just before changing the value of &lt;var&gt;symbol&lt;/var&gt;, with 4 arguments: &lt;var&gt;symbol&lt;/var&gt;, &lt;var&gt;newval&lt;/var&gt;, &lt;var&gt;operation&lt;/var&gt;, and &lt;var&gt;where&lt;/var&gt;. &lt;var&gt;symbol&lt;/var&gt; is the variable being changed. &lt;var&gt;newval&lt;/var&gt; is the value it will be changed to. (The old value is available to &lt;var&gt;watch-function&lt;/var&gt; as the value of &lt;var&gt;symbol&lt;/var&gt;, since it was not yet changed to &lt;var&gt;newval&lt;/var&gt;.) &lt;var&gt;operation&lt;/var&gt; is a symbol representing the kind of change, one of: &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;unlet&lt;/code&gt;, &lt;code&gt;makunbound&lt;/code&gt;, or &lt;code&gt;defvaralias&lt;/code&gt;. &lt;var&gt;where&lt;/var&gt; is a buffer if the buffer-local value of the variable is being changed, &lt;code&gt;nil&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;var&gt;watch-function&lt;/var&gt; 은 &lt;var&gt;symbol&lt;/var&gt; , &lt;var&gt;newval&lt;/var&gt; , &lt;var&gt;operation&lt;/var&gt; 및 &lt;var&gt;where&lt;/var&gt; 의 4 개의 인수와 함께 &lt;var&gt;symbol&lt;/var&gt; 의 값을 변경하기 직전에 호출됩니다 . &lt;var&gt;symbol&lt;/var&gt; 은 변경되는 변수입니다. &lt;var&gt;newval&lt;/var&gt; 은 변경 될 값입니다. ( 아직 &lt;var&gt;newval&lt;/var&gt; 로 변경되지 않았기 때문에 이전 값은 &lt;var&gt;symbol&lt;/var&gt; 의 값으로 &lt;var&gt;watch-function&lt;/var&gt; 에 사용할 수 있습니다 .) &lt;var&gt;operation&lt;/var&gt; 은 &lt;code&gt;set&lt;/code&gt; , &lt;code&gt;let&lt;/code&gt; , &lt;code&gt;unlet&lt;/code&gt; , &lt;code&gt;makunbound&lt;/code&gt; 또는 &lt;code&gt;defvaralias&lt;/code&gt; 중 하나의 변경 종류를 나타내는 기호입니다.. &lt;var&gt;where&lt;/var&gt; 변수의 로컬 버퍼 값이 변경되는 경우, 버퍼는 &lt;code&gt;nil&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="4052603b19bcf65791aed68e81734e46505fd1f7" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;where&lt;/var&gt; determines how &lt;var&gt;function&lt;/var&gt; is composed with the existing function, e.g., whether &lt;var&gt;function&lt;/var&gt; should be called before, or after the original function. See &lt;a href=&quot;advice-combinators#Advice-Combinators&quot;&gt;Advice Combinators&lt;/a&gt;, for the list of available ways to compose the two functions.</source>
          <target state="translated">&lt;var&gt;where&lt;/var&gt; &lt;var&gt;function&lt;/var&gt; 가 기존 함수로 구성 되는 방식을 결정합니다 ( 예 : &lt;var&gt;function&lt;/var&gt; 를 원래 함수 이전 또는 이후에 호출 해야하는지 여부) . 두 함수를 구성하는 데 사용할 수있는 방법 목록은 &lt;a href=&quot;advice-combinators#Advice-Combinators&quot;&gt;Advice Combinators를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ca11e1531e4a8d8494d88f05f553a46919cfe550" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;width&lt;/var&gt; is the width to reserve for the column (an integer). This is meaningless for the last column, which runs to the end of each line.</source>
          <target state="translated">&lt;var&gt;width&lt;/var&gt; 는 열에 예약 할 너비 (정수)입니다. 이것은 각 줄의 끝까지 이어지는 마지막 열에는 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5627b0a3a3d443b1933453bb5cd20de0f0d26d5a" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;width&lt;/var&gt; specifies the width of the vertical scroll bar in pixels (&lt;code&gt;nil&lt;/code&gt; means use the width specified for the frame). &lt;var&gt;vertical-type&lt;/var&gt; specifies whether to have a vertical scroll bar and, if so, where. The possible values are &lt;code&gt;left&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;, &lt;code&gt;t&lt;/code&gt;, which means to use the frame&amp;rsquo;s default, and &lt;code&gt;nil&lt;/code&gt; for no vertical scroll bar.</source>
          <target state="translated">&lt;var&gt;width&lt;/var&gt; 는 세로 스크롤 막대의 너비를 픽셀 단위로 지정합니다. &lt;code&gt;nil&lt;/code&gt; 은 프레임에 지정된 너비를 사용함을 의미합니다. &lt;var&gt;vertical-type&lt;/var&gt; 은 수직 스크롤 막대를 가질 지 여부를 지정합니다. 가능한 값은 &lt;code&gt;left&lt;/code&gt; , &lt;code&gt;right&lt;/code&gt; , &lt;code&gt;t&lt;/code&gt; , 즉 프레임의 기본값을 사용함을 의미하고 &lt;code&gt;nil&lt;/code&gt; 은 수직 스크롤바가없는 경우입니다.</target>
        </trans-unit>
        <trans-unit id="c547cbc5c2845f4e2577ba46634ae50d14551741" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;width&lt;/var&gt;, &lt;var&gt;height&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;width&lt;/var&gt; , &lt;var&gt;height&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="a74d8ab3c01149182f1dc5ec8c690fdbb66475cb" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;window&lt;/var&gt; must be a live window and defaults to the selected window. &lt;var&gt;position&lt;/var&gt; defaults to the value of &lt;code&gt;window-point&lt;/code&gt; of &lt;var&gt;window&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;window&lt;/var&gt; 은 라이브 창 이어야하며 기본값은 선택한 창입니다. &lt;var&gt;position&lt;/var&gt; 의 값을 기본값으로 &lt;code&gt;window-point&lt;/code&gt; 의 &lt;var&gt;window&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="0dcdc549a8dcec6ec113ac1e899f074af9747242" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;x&lt;/var&gt;, &lt;var&gt;y&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;x&lt;/var&gt; , &lt;var&gt;y&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="13a189a749c2f5d122db857ceb450b488307174d" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;x&lt;/var&gt;, &lt;var&gt;y&lt;/var&gt;, &lt;var&gt;width&lt;/var&gt;, and &lt;var&gt;height&lt;/var&gt; are integers. &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;x&lt;/var&gt; , &lt;var&gt;y&lt;/var&gt; , &lt;var&gt;width&lt;/var&gt; 및 &lt;var&gt;height&lt;/var&gt; 는 정수입니다. '</target>
        </trans-unit>
        <trans-unit id="f26d70e928cbdeb5062b11f0ae6f958bb78b21d4" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;x&lt;/var&gt;:/</source>
          <target state="translated">&lt;var&gt;x&lt;/var&gt;:/</target>
        </trans-unit>
        <trans-unit id="67327d2400403d993e67763cc63d3cf059b83c31" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;x&lt;/var&gt;:&lt;var&gt;xx&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;x&lt;/var&gt;:&lt;var&gt;xx&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="f31313bcbf9330da698e50ff142d0dd1d44b3b89" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;xx&lt;/var&gt;:&lt;var&gt;xx&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;xx&lt;/var&gt;:&lt;var&gt;xx&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="30a117ecb6ca07e6f0ab39ae1a00a801221ab69b" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;xx&lt;/var&gt;:&lt;var&gt;xx&lt;/var&gt;AM</source>
          <target state="translated">&lt;var&gt;xx&lt;/var&gt;:&lt;var&gt;xx&lt;/var&gt;AM</target>
        </trans-unit>
        <trans-unit id="0dc7a88310600ac2f33242840088cfa949ec5c00" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;xx&lt;/var&gt;:&lt;var&gt;xx&lt;/var&gt;PM</source>
          <target state="translated">&lt;var&gt;xx&lt;/var&gt;:&lt;var&gt;xx&lt;/var&gt;PM</target>
        </trans-unit>
        <trans-unit id="c4c469fb34962159f38a8e5056a82948fa3189e5" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;xx&lt;/var&gt;:&lt;var&gt;xx&lt;/var&gt;am</source>
          <target state="translated">&lt;var&gt;xx&lt;/var&gt;:&lt;var&gt;xx&lt;/var&gt;am</target>
        </trans-unit>
        <trans-unit id="03562318cb6818e744ba723a24c875d69c2acd5e" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;xx&lt;/var&gt;:&lt;var&gt;xx&lt;/var&gt;pm</source>
          <target state="translated">&lt;var&gt;xx&lt;/var&gt;:&lt;var&gt;xx&lt;/var&gt;pm</target>
        </trans-unit>
        <trans-unit id="7ef500418ff05008137b29635c42810a2ebca53e" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;xx&lt;/var&gt;AM</source>
          <target state="translated">&lt;var&gt;xx&lt;/var&gt;AM</target>
        </trans-unit>
        <trans-unit id="6c6955642e9352178bc5a205a340c2d1c58c2de1" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;xx&lt;/var&gt;PM</source>
          <target state="translated">&lt;var&gt;xx&lt;/var&gt;PM</target>
        </trans-unit>
        <trans-unit id="17736819552d9e273869f36b796435c4a2c74701" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;xx&lt;/var&gt;am</source>
          <target state="translated">&lt;var&gt;xx&lt;/var&gt;am</target>
        </trans-unit>
        <trans-unit id="2a964e36e106b1339a3db0d45ec183e349520142" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;xx&lt;/var&gt;pm</source>
          <target state="translated">&lt;var&gt;xx&lt;/var&gt;pm</target>
        </trans-unit>
        <trans-unit id="21606782c65e44cac7afbb90977d8b6f82140e76" translate="yes" xml:space="preserve">
          <source>=</source>
          <target state="translated">=</target>
        </trans-unit>
        <trans-unit id="f52815edb4bf4384e64b0256a58e2fe3b042d4cd" translate="yes" xml:space="preserve">
          <source>?A</source>
          <target state="translated">?A</target>
        </trans-unit>
        <trans-unit id="599203ebe43f2624eea570ebba0a49b67a1818e0" translate="yes" xml:space="preserve">
          <source>?B</source>
          <target state="translated">?B</target>
        </trans-unit>
        <trans-unit id="b5a94beeeb73f886a4d79af28858dcb3ab6b7b31" translate="yes" xml:space="preserve">
          <source>?C</source>
          <target state="translated">?C</target>
        </trans-unit>
        <trans-unit id="6b4d70182298a45eaa7031398daeb6ad2782ad12" translate="yes" xml:space="preserve">
          <source>?\(</source>
          <target state="translated">?\(</target>
        </trans-unit>
        <trans-unit id="cbdd61d5fc29c31fa4405792eff9e39190e4f4e5" translate="yes" xml:space="preserve">
          <source>?\+</source>
          <target state="translated">?\+</target>
        </trans-unit>
        <trans-unit id="bad2940ef87b0d17a7c5116349545f3d674e067b" translate="yes" xml:space="preserve">
          <source>?\001</source>
          <target state="translated">?\001</target>
        </trans-unit>
        <trans-unit id="b3502d529dc1d8854f93560dc98666d4c65a5d0b" translate="yes" xml:space="preserve">
          <source>?\101</source>
          <target state="translated">?\101</target>
        </trans-unit>
        <trans-unit id="9fce6b611deb45edf21130052b9ecd9841a07506" translate="yes" xml:space="preserve">
          <source>?\C-\M-b</source>
          <target state="translated">?\C-\M-b</target>
        </trans-unit>
        <trans-unit id="4b0228d76a0a6f7f54d81c734f2e43b1cc79e704" translate="yes" xml:space="preserve">
          <source>?\C-\S-O</source>
          <target state="translated">?\C-\S-O</target>
        </trans-unit>
        <trans-unit id="87d2660a051e41aff96738baba5c207e2368c747" translate="yes" xml:space="preserve">
          <source>?\C-\S-o</source>
          <target state="translated">?\C-\S-o</target>
        </trans-unit>
        <trans-unit id="47fab5f7d4ae0f140143069c934867ab789751be" translate="yes" xml:space="preserve">
          <source>?\C-i</source>
          <target state="translated">?\C-i</target>
        </trans-unit>
        <trans-unit id="f90e3407f2bff3255b57e2755039432462d135ce" translate="yes" xml:space="preserve">
          <source>?\H-\M-\A-x</source>
          <target state="translated">?\H-\M-\A-x</target>
        </trans-unit>
        <trans-unit id="fee07cee280ad5aba36e35ab3213cbf3c5b9533d" translate="yes" xml:space="preserve">
          <source>?\M-A</source>
          <target state="translated">?\M-A</target>
        </trans-unit>
        <trans-unit id="a1f5f591dc022e0992becc5c6b9f2e09e9c4b113" translate="yes" xml:space="preserve">
          <source>?\M-\002</source>
          <target state="translated">?\M-\002</target>
        </trans-unit>
        <trans-unit id="bafd36bf88f8103b9efc69193c226588e4c45387" translate="yes" xml:space="preserve">
          <source>?\M-\101</source>
          <target state="translated">?\M-\101</target>
        </trans-unit>
        <trans-unit id="e5909bdf46b00c73e8aeff9468823539310a55f0" translate="yes" xml:space="preserve">
          <source>?\M-\C-b</source>
          <target state="translated">?\M-\C-b</target>
        </trans-unit>
        <trans-unit id="1b208eb3a3549c10763461c273c87956d3e3bbd4" translate="yes" xml:space="preserve">
          <source>?\N{LATIN SMALL LETTER A WITH GRAVE}</source>
          <target state="translated">? \ N {라틴어 소문자 A와 무덤}</target>
        </trans-unit>
        <trans-unit id="69a1f2deba55a734a6250ac07cfbc6794b3933af" translate="yes" xml:space="preserve">
          <source>?\\</source>
          <target state="translated">?\\</target>
        </trans-unit>
        <trans-unit id="0cf3cb1faea919f3860f818b03bbfcc9243d8900" translate="yes" xml:space="preserve">
          <source>?\^I</source>
          <target state="translated">?\^I</target>
        </trans-unit>
        <trans-unit id="3a04971235dc052a903f8d075da18e8ac58afa8f" translate="yes" xml:space="preserve">
          <source>?\^i</source>
          <target state="translated">?\^i</target>
        </trans-unit>
        <trans-unit id="867b960f113a7a5c0779b8c58e84e28e2f75a966" translate="yes" xml:space="preserve">
          <source>?\a</source>
          <target state="translated">?\a</target>
        </trans-unit>
        <trans-unit id="c5fbfc44c04b0fd9df447c22156ee7e37b25953b" translate="yes" xml:space="preserve">
          <source>?\b</source>
          <target state="translated">?\b</target>
        </trans-unit>
        <trans-unit id="4a810b1bf40c42dd4a08f3aa3861012326b32b47" translate="yes" xml:space="preserve">
          <source>?\d</source>
          <target state="translated">?\d</target>
        </trans-unit>
        <trans-unit id="29b3719b09d80bc7811aa176d73698536daca42b" translate="yes" xml:space="preserve">
          <source>?\e</source>
          <target state="translated">?\e</target>
        </trans-unit>
        <trans-unit id="ae9f72aaf52a6d4ac9607293d42d29afbca0843b" translate="yes" xml:space="preserve">
          <source>?\f</source>
          <target state="translated">?\f</target>
        </trans-unit>
        <trans-unit id="bedb9d8a983c4ae4258638456f7c4f707b123023" translate="yes" xml:space="preserve">
          <source>?\n</source>
          <target state="translated">?\n</target>
        </trans-unit>
        <trans-unit id="f946c4dd6853b2a51d459def9d1ebc230990d4fa" translate="yes" xml:space="preserve">
          <source>?\r</source>
          <target state="translated">?\r</target>
        </trans-unit>
        <trans-unit id="17d0768830f0c94bc4faf17615c57d2000e33f61" translate="yes" xml:space="preserve">
          <source>?\s</source>
          <target state="translated">?\s</target>
        </trans-unit>
        <trans-unit id="88c16d23df60641aa21518113b70aa5b1fd9c6af" translate="yes" xml:space="preserve">
          <source>?\t</source>
          <target state="translated">?\t</target>
        </trans-unit>
        <trans-unit id="5001639220c7a661b719c767f92b87d61d334296" translate="yes" xml:space="preserve">
          <source>?\v</source>
          <target state="translated">?\v</target>
        </trans-unit>
        <trans-unit id="fe8951e791e6bfe2053499640fdae36ad6b9fddc" translate="yes" xml:space="preserve">
          <source>?\x1</source>
          <target state="translated">?\x1</target>
        </trans-unit>
        <trans-unit id="7bfc455b958ad97ebd11ba2a62f818761637ffae" translate="yes" xml:space="preserve">
          <source>?\x41</source>
          <target state="translated">?\x41</target>
        </trans-unit>
        <trans-unit id="dbb47e7dc891f20d38639d6ad3ad2e8c45fd9a4d" translate="yes" xml:space="preserve">
          <source>?a</source>
          <target state="translated">?a</target>
        </trans-unit>
        <trans-unit id="6dcd4ce23d88e2ee9568ba546c007c63d9131c1b" translate="yes" xml:space="preserve">
          <source>A</source>
          <target state="translated">A</target>
        </trans-unit>
        <trans-unit id="7b25536642ada965a8ba70bb7e96b265170e1e74" translate="yes" xml:space="preserve">
          <source>A &amp;lsquo;</source>
          <target state="translated">ㅏ '</target>
        </trans-unit>
        <trans-unit id="8cdca21dea5e4a8264a4a0d19a1fee7e75441b25" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;let&lt;/code&gt; special form has a sequence of bindings and a body. Each of the bindings is either a symbol or a sublist with a symbol and optional expression. In the specification below, notice the &lt;code&gt;gate&lt;/code&gt; inside of the sublist to prevent backtracking once a sublist is found.</source>
          <target state="translated">A는 &lt;code&gt;let&lt;/code&gt; 특별한 형태의 바인딩 및 신체의 시퀀스를 가지고있다. 각 바인딩은 기호 또는 기호 및 선택적 표현식이있는 하위 목록입니다. 아래 사양 에서 하위 목록이 발견되면 역 추적을 방지하기 위해 하위 목록 내부의 &lt;code&gt;gate&lt;/code&gt; 를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="135e6a2bf74be90fe3f773ee5fdeeae2bbbdd7ab" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;progn&lt;/code&gt; special form looks like this:</source>
          <target state="translated">&lt;code&gt;progn&lt;/code&gt; 이 같은 특수 형태 외모 :</target>
        </trans-unit>
        <trans-unit id="c62e5da7301e854f814d079251caea61f86ba089" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;struct buffer_text&lt;/code&gt; structure that ordinarily holds the buffer contents. In indirect buffers, this field is not used.</source>
          <target state="translated">일반적으로 버퍼 내용을 보유 하는 &lt;code&gt;struct buffer_text&lt;/code&gt; 구조입니다. 간접 버퍼에서는이 필드가 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0d79644c9f1e2b9d43b38945d21a85b8f41eceb5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;wrong-type-argument&lt;/code&gt; error is signaled if &lt;var&gt;start&lt;/var&gt; is not an integer or if &lt;var&gt;end&lt;/var&gt; is neither an integer nor &lt;code&gt;nil&lt;/code&gt;. An &lt;code&gt;args-out-of-range&lt;/code&gt; error is signaled if &lt;var&gt;start&lt;/var&gt; indicates a character following &lt;var&gt;end&lt;/var&gt;, or if either integer is out of range for &lt;var&gt;string&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;wrong-type-argument&lt;/code&gt; 경우 오류가 신호됩니다 &lt;var&gt;start&lt;/var&gt; 정수가 아닌 경우, 또는 &lt;var&gt;end&lt;/var&gt; 정수도도 아니다 &lt;code&gt;nil&lt;/code&gt; . &lt;code&gt;args-out-of-range&lt;/code&gt; 경우 오류가 신호됩니다 &lt;var&gt;start&lt;/var&gt; 문자 다음을 나타냅니다 &lt;var&gt;end&lt;/var&gt; , 또는 하나의 정수가 범위 외의 경우 &lt;var&gt;string&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="ffd1de607d4e86730b7914fe4c5cd9684285cc40" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;Lisp macro&lt;/em&gt; is a user-defined construct that extends the Lisp language. It is represented as an object much like a function, but with different argument-passing semantics. A Lisp macro has the form of a list whose first element is the symbol &lt;code&gt;macro&lt;/code&gt; and whose &lt;small&gt;CDR&lt;/small&gt; is a Lisp function object, including the &lt;code&gt;lambda&lt;/code&gt; symbol.</source>
          <target state="translated">&lt;em&gt;리스프 매크로&lt;/em&gt; 리스프 언어를 확장하는 사용자 정의 구조이다. 함수와 매우 유사하지만 인수 전달 의미가 다른 객체로 표시됩니다. Lisp 매크로는 첫 번째 요소가 기호 &lt;code&gt;macro&lt;/code&gt; 이고 &lt;small&gt;CDR&lt;/small&gt; 이 &lt;code&gt;lambda&lt;/code&gt; 기호를 포함하는 Lisp 함수 개체 인 목록 형식을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="7d0a1b483ba2d8b083551109a784f0c67ae64feb" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;backup file&lt;/em&gt; is a copy of the old contents of a file you are editing. Emacs makes a backup file the first time you save a buffer into its visited file. Thus, normally, the backup file contains the contents of the file as it was before the current editing session. The contents of the backup file normally remain unchanged once it exists.</source>
          <target state="translated">&lt;em&gt;백업 파일은&lt;/em&gt; 편집중인 파일의 이전 내용의 복사본입니다. Emacs는 방문한 파일에 버퍼를 처음 저장할 때 백업 파일을 만듭니다. 따라서 일반적으로 백업 파일에는 현재 편집 세션 이전의 파일 내용이 포함됩니다. 백업 파일의 내용은 정상적으로 존재하면 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3d929fdcc82b42627ef27e398a719ddbde6028a6" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;bool-vector&lt;/em&gt; is a one-dimensional array whose elements must be &lt;code&gt;t&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;BOOL 벡터는&lt;/em&gt; 요소가 있어야 일차원 배열 &lt;code&gt;t&lt;/code&gt; 또는 &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="825376a8553269fb52ebcf7ffb4eb207689b12ed" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;buffer&lt;/em&gt; is a Lisp object containing text to be edited. Buffers are used to hold the contents of files that are being visited; there may also be buffers that are not visiting files. Although several buffers normally exist, only one buffer is designated the &lt;em&gt;current buffer&lt;/em&gt; at any time. Most editing commands act on the contents of the current buffer. Each buffer, including the current buffer, may or may not be displayed in any windows.</source>
          <target state="translated">&lt;em&gt;버퍼가&lt;/em&gt; 텍스트를 포함하는 리스프 오브젝트를 편집한다. 버퍼는 방문중인 파일의 내용을 보관하는 데 사용됩니다. 파일을 방문하지 않는 버퍼도있을 수 있습니다. 일반적으로 여러 개의 버퍼가 존재하지만 한 번에 하나의 버퍼 만 &lt;em&gt;현재 버퍼&lt;/em&gt; 로 지정 됩니다. 대부분의 편집 명령은 현재 버퍼의 내용에 적용됩니다. 현재 버퍼를 포함한 각 버퍼는 모든 창에 표시되거나 표시되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f67a6c4f9bfcdbbe46b59e51fc8c393aeac5bb3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;buffer&lt;/em&gt; is a Lisp object containing text to be edited. Buffers are used to hold the contents of files that are being visited; there may also be buffers that are not visiting files. While several buffers may exist at one time, only one buffer is designated the &lt;em&gt;current buffer&lt;/em&gt; at any time. Most editing commands act on the contents of the current buffer. Each buffer, including the current buffer, may or may not be displayed in any windows.</source>
          <target state="translated">&lt;em&gt;버퍼가&lt;/em&gt; 텍스트를 포함하는 리스프 오브젝트를 편집한다. 버퍼는 방문중인 파일의 내용을 보관하는 데 사용됩니다. 파일을 방문하지 않는 버퍼도있을 수 있습니다. 한 번에 여러 버퍼가 존재할 수 있지만 한 번에 하나의 버퍼 만 &lt;em&gt;현재 버퍼&lt;/em&gt; 로 지정 됩니다. 대부분의 편집 명령은 현재 버퍼의 내용에 적용됩니다. 현재 버퍼를 포함한 각 버퍼는 모든 창에 표시되거나 표시되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52fb4ef66447b55a8ae80b672427c06354ee2e1d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;buffer&lt;/em&gt; is an object that holds text that can be edited (see &lt;a href=&quot;buffers#Buffers&quot;&gt;Buffers&lt;/a&gt;). Most buffers hold the contents of a disk file (see &lt;a href=&quot;files#Files&quot;&gt;Files&lt;/a&gt;) so they can be edited, but some are used for other purposes. Most buffers are also meant to be seen by the user, and therefore displayed, at some time, in a window (see &lt;a href=&quot;windows#Windows&quot;&gt;Windows&lt;/a&gt;). But a buffer need not be displayed in any window. Each buffer has a designated position called &lt;em&gt;point&lt;/em&gt; (see &lt;a href=&quot;positions#Positions&quot;&gt;Positions&lt;/a&gt;); most editing commands act on the contents of the current buffer in the neighborhood of point. At any time, one buffer is the &lt;em&gt;current buffer&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;버퍼&lt;/em&gt; (보고 편집 할 수있는 텍스트를 보유 대상인 &lt;a href=&quot;buffers#Buffers&quot;&gt;버퍼&lt;/a&gt; ). 대부분의 버퍼는 디스크 파일 (참조의 내용 누르고 &lt;a href=&quot;files#Files&quot;&gt;파일&lt;/a&gt; )가 편집 할 수 있도록,하지만 일부는 다른 용도로 사용된다. 대부분의 버퍼는 또한 사용자가 볼 수 있도록되어 있으므로 때때로 창에 표시됩니다 ( &lt;a href=&quot;windows#Windows&quot;&gt;Windows&lt;/a&gt; 참조 ). 그러나 어떤 창에도 버퍼를 표시 할 필요는 없습니다. 각 버퍼에는 &lt;em&gt;point&lt;/em&gt; 라는 지정된 위치가 &lt;em&gt;있습니다&lt;/em&gt; ( &lt;a href=&quot;positions#Positions&quot;&gt;Positions&lt;/a&gt; 참조 ). 대부분의 편집 명령은 포인트 근처에있는 현재 버퍼의 내용에 적용됩니다. 언제든지 하나의 버퍼가 &lt;em&gt;현재 버퍼&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="58e9f6a52a39d48be38551b57b93b51b37d8bbc8" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;char-table&lt;/em&gt; is a one-dimensional array of elements of any type, indexed by character codes. Char-tables have certain extra features to make them more useful for many jobs that involve assigning information to character codes&amp;mdash;for example, a char-table can have a parent to inherit from, a default value, and a small number of extra slots to use for special purposes. A char-table can also specify a single value for a whole character set.</source>
          <target state="translated">&lt;em&gt;문자 테이블은&lt;/em&gt; 문자 코드에 의해 인덱싱 된 모든 유형의 요소들의 1 차원 어레이이다. 문자 테이블에는 문자 코드에 정보를 할당하는 것과 관련된 많은 작업에 더 유용한 특정 추가 기능이 있습니다. 예를 들어 문자 테이블에는 상속 할 상위 항목, 기본값 및 적은 수의 추가 슬롯이있을 수 있습니다. 특별한 목적으로 사용하십시오. char-table은 전체 문자 집합에 대해 단일 값을 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d0930676c0654f8b70278e726ef587819be2392" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;character property&lt;/em&gt; is a named attribute of a character that specifies how the character behaves and how it should be handled during text processing and display. Thus, character properties are an important part of specifying the character&amp;rsquo;s semantics.</source>
          <target state="translated">&lt;em&gt;문자 속성은&lt;/em&gt; 문자의 명명 된 속성으로 지정하는 방법 문자 동작합니다 그리고 그것은 텍스트 처리 및 디스플레이하는 동안 처리하는 방법. 따라서 캐릭터 속성은 캐릭터의 의미를 지정하는 데 중요한 부분입니다.</target>
        </trans-unit>
        <trans-unit id="e3936c7a37167833ab4cfaa4fe7b776318fe87ee" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;character&lt;/em&gt; in Emacs Lisp is nothing more than an integer. In other words, characters are represented by their character codes. For example, the character</source>
          <target state="translated">Emacs Lisp 의 &lt;em&gt;문자&lt;/em&gt; 는 정수에 지나지 않습니다. 즉, 문자는 문자 코드로 표시됩니다. 예를 들어, 캐릭터</target>
        </trans-unit>
        <trans-unit id="988e76f4ba6424d00a22226b31c6bb6069712f52" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;command-line option&lt;/em&gt; is an argument on the command line, which has the form:</source>
          <target state="translated">&lt;em&gt;명령 줄 옵션&lt;/em&gt; 의 형식은 명령 줄에 인수입니다 :</target>
        </trans-unit>
        <trans-unit id="4e8a05b6c91ae7521b9158c75abe8973ce6b52be" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;comment&lt;/em&gt; is text that is written in a program only for the sake of humans that read the program, and that has no effect on the meaning of the program. In Lisp, an unescaped semicolon (&amp;lsquo;</source>
          <target state="translated">&lt;em&gt;코멘트&lt;/em&gt; 는 프로그램을 읽을 사람을 위해 프로그램에 기록 된 텍스트이며, 그 프로그램의 의미에 영향을주지 않습니다. Lisp에서 이스케이프 처리되지 않은 세미콜론 ( '</target>
        </trans-unit>
        <trans-unit id="0701bec604d6ebb4ee489eb99b493dc2af69d7c2" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;condition variable&lt;/em&gt; is a device for a more complex thread synchronization than the one supported by a mutex. A thread can wait on a condition variable, to be woken up when some other thread notifies the condition.</source>
          <target state="translated">&lt;em&gt;조건 변수는&lt;/em&gt; 뮤텍스에 의해 지원되는 것보다 더 복잡한 스레드 동기화하는 장치이다. 스레드는 다른 스레드가 조건을 알릴 때 깨어나 기 위해 조건 변수를 기다릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2b1e319d48c52f8b9b1dc9edeed91b28bd7bcde" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;condition variable&lt;/em&gt; is a way for a thread to block until some event occurs. A thread can wait on a condition variable, to be woken up when some other thread notifies the condition.</source>
          <target state="translated">&lt;em&gt;조건 변수는&lt;/em&gt; 어떤 이벤트가 발생할 때까지 스레드를 차단하는 방법이다. 스레드는 다른 스레드가 조건을 알릴 때 깨어나 기 위해 조건 변수를 기다릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e8c4291506499a1c34b2f7a3b465bd996ccfdf5" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;conditional breakpoint&lt;/em&gt; tests a condition each time the program gets there. Any errors that occur as a result of evaluating the condition are ignored, as if the result were &lt;code&gt;nil&lt;/code&gt;. To set a conditional breakpoint, use</source>
          <target state="translated">&lt;em&gt;조건부 중단 점&lt;/em&gt; 조건을 프로그램이 얻을 때마다 테스트합니다. 조건을 평가 한 결과 발생하는 모든 오류는 결과가 &lt;code&gt;nil&lt;/code&gt; 인 것처럼 무시됩니다 . 조건부 중단 점을 설정하려면</target>
        </trans-unit>
        <trans-unit id="0f175283d77a4fd94b6fc26212092340b20a89a3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;cons cell&lt;/em&gt; is an object that consists of two slots, called the &lt;small&gt;CAR&lt;/small&gt; slot and the &lt;small&gt;CDR&lt;/small&gt; slot. Each slot can &lt;em&gt;hold&lt;/em&gt; any Lisp object. We also say that the &lt;small&gt;CAR&lt;/small&gt; of this cons cell is whatever object its &lt;small&gt;CAR&lt;/small&gt; slot currently holds, and likewise for the &lt;small&gt;CDR&lt;/small&gt;.</source>
          <target state="translated">&lt;em&gt;반대 셀&lt;/em&gt; 호출 개의 슬롯으로 구성 목적 &lt;small&gt;CAR의&lt;/small&gt; 슬롯과 &lt;small&gt;CDR의&lt;/small&gt; 슬롯. 각 슬롯은 Lisp 오브젝트를 &lt;em&gt;보유&lt;/em&gt; 할 수 있습니다 . 우리는 또한 말 &lt;small&gt;CAR&lt;/small&gt; 이 단점 셀의이 객체 뭐든 &lt;small&gt;자동차&lt;/small&gt; 슬롯을 현재 보유하고 있으며 마찬가지로위한 &lt;small&gt;CDR&lt;/small&gt; .</target>
        </trans-unit>
        <trans-unit id="b422ee9e4026fd4e0cd35274610df0b46359f25a" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;data element&lt;/em&gt;, a single Lisp object.</source>
          <target state="translated">&lt;em&gt;데이터 요소&lt;/em&gt; 단일 리스프 개체.</target>
        </trans-unit>
        <trans-unit id="2fd5ff9853d86e2b5387329321415f00ec01c50e" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;datagram&lt;/em&gt; connection communicates with individual packets rather than streams of data. Each call to &lt;code&gt;process-send&lt;/code&gt; sends one datagram packet (see &lt;a href=&quot;input-to-processes#Input-to-Processes&quot;&gt;Input to Processes&lt;/a&gt;), and each datagram received results in one call to the filter function.</source>
          <target state="translated">&lt;em&gt;그램&lt;/em&gt; 연결 개별 패킷이 아닌 데이터 스트림을 전달한다. &lt;code&gt;process-send&lt;/code&gt; 에 대한 각 호출 은 하나의 데이터 그램 패킷을 전송하고 ( &lt;a href=&quot;input-to-processes#Input-to-Processes&quot;&gt;프로세스에&lt;/a&gt; 대한 입력 참조 ) 수신 된 각 데이터 그램은 필터 함수에 대한 한 번의 호출을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="f72e9e8f55ba9b0d557af040b71fe45f88267513" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;definition&lt;/em&gt; is a special kind of Lisp expression that announces your intention to use a symbol in a particular way. It typically specifies a value or meaning for the symbol for one kind of use, plus documentation for its meaning when used in this way. Thus, when you define a symbol as a variable, you can supply an initial value for the variable, plus documentation for the variable.</source>
          <target state="translated">&lt;em&gt;정의는&lt;/em&gt; 특정 방식으로 기호를 사용하는 당신의 의도를 발표 리스프 식의 특별한 종류이다. 일반적으로 한 종류의 기호에 대한 값 또는 의미를 지정하고 이러한 방식으로 사용할 경우 해당 의미에 대한 문서를 지정합니다. 따라서 심볼을 변수로 정의 할 때 변수의 초기 값과 변수에 대한 문서를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3be196257fddf44d2005a0a44f83cb229fa5908d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;directory name&lt;/em&gt; is a string that must name a directory if it names any file at all. A directory is actually a kind of file, and it has a file name (called the &lt;em&gt;directory file name&lt;/em&gt;, which is related to the directory name but is typically not identical. (This is not quite the same as the usual POSIX terminology.) These two names for the same entity are related by a syntactic transformation. On GNU and other POSIX-like systems, this is simple: to obtain a directory name, append a &amp;lsquo;</source>
          <target state="translated">&lt;em&gt;디렉토리 이름은&lt;/em&gt; 모두에서 그 이름이있는 경우 파일 디렉토리의 이름을 지정해야합니다 문자열입니다. 디렉토리는 실제로 일종의 파일이며 파일 이름 ( 디렉토리 이름과 관련이 있지만 일반적으로 동일하지 않은 &lt;em&gt;디렉토리 파일 이름&lt;/em&gt; 이라고 함) 이 있습니다 (일반적인 POSIX 용어와 완전히 동일하지 않음). 동일한 엔티티에 대한 두 개의 이름은 구문 변환으로 관련됩니다. GNU 및 기타 POSIX 유사 시스템에서는 간단합니다. 디렉토리 이름을 얻으려면 '</target>
        </trans-unit>
        <trans-unit id="df1dde6d3983db88f8cc142a935e30fd2f3bd233" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;dynamic Emacs module&lt;/em&gt; is a shared library that provides additional functionality for use in Emacs Lisp programs, just like a package written in Emacs Lisp would.</source>
          <target state="translated">&lt;em&gt;동적 이맥스 모듈은&lt;/em&gt; 단지 것 이맥스 리스프로 작성된 패키지처럼, 이맥스 리스프 프로그램에서 사용하기위한 추가 기능을 제공하는 공유 라이브러리입니다.</target>
        </trans-unit>
        <trans-unit id="5de98caf4399a9e93ce65d6deeb5b1cb3b08a098" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;dynamically loaded library&lt;/em&gt; is a library that is loaded on demand, when its facilities are first needed. Emacs supports such on-demand loading of support libraries for some of its features.</source>
          <target state="translated">&lt;em&gt;동적으로로드 된 라이브러리는&lt;/em&gt; 그 시설이 처음 필요할 때, 필요에 따라로드되는 라이브러리입니다. Emacs는 일부 기능에 대한 지원 라이브러리의 온 디맨드로드를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="05b5a3be7d8b03b9d46f3e151dea5e13577ea7a8" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;face alias&lt;/em&gt; provides an equivalent name for a face. You can define a face alias by giving the alias symbol the &lt;code&gt;face-alias&lt;/code&gt; property, with a value of the target face name. The following example makes &lt;code&gt;modeline&lt;/code&gt; an alias for the &lt;code&gt;mode-line&lt;/code&gt; face.</source>
          <target state="translated">&lt;em&gt;얼굴 별칭은&lt;/em&gt; 얼굴에 대한 동등한 이름을 제공합니다. 대상 얼굴 이름 값과 함께 &lt;code&gt;face-alias&lt;/code&gt; 속성에 별칭 기호를 제공하여 얼굴 별칭을 정의 할 수 있습니다 . 다음 예제에서는 &lt;code&gt;modeline&lt;/code&gt; 을 &lt;code&gt;mode-line&lt;/code&gt; 면 의 별칭으로 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="302cf515b4948fb8d82a2188371caddf7704019d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;face&lt;/em&gt; is a collection of graphical attributes for displaying text: font, foreground color, background color, optional underlining, etc. Faces control how Emacs displays text in buffers, as well as other parts of the frame such as the mode line.</source>
          <target state="translated">&lt;em&gt;얼굴&lt;/em&gt; 표시 텍스트 그래픽 속성들의 집합이다 : 등 폰트 전경 색상, 배경 색상 선택 밑줄 제어 얼굴 방법 이멕스 디스플레이 버퍼의 텍스트뿐만 아니라, 모드 선으로서 상기 프레임의 다른 부분.</target>
        </trans-unit>
        <trans-unit id="231e0a86e11ce9343b5d5ac44eab6dbd7b32d896" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;finalizer object&lt;/em&gt; helps Lisp code clean up after objects that are no longer needed. A finalizer holds a Lisp function object. When a finalizer object becomes unreachable after a garbage collection pass, Emacs calls the finalizer&amp;rsquo;s associated function object. When deciding whether a finalizer is reachable, Emacs does not count references from finalizer objects themselves, allowing you to use finalizers without having to worry about accidentally capturing references to finalized objects themselves.</source>
          <target state="translated">&lt;em&gt;종료 자 객체는&lt;/em&gt; 더 이상 필요하지 않은 객체 후 리스프 코드 정리를하는 데 도움이됩니다. 종료자는 Lisp 함수 개체를 보유합니다. 가비지 컬렉션을 통과 한 후 종료 자 객체에 도달 할 수 없게되면 Emacs는 종료 자와 관련된 함수 객체를 호출합니다. 종료 자에 도달 할 수 있는지 여부를 결정할 때 Emacs는 종료 자 객체 자체에서 참조를 계산하지 않으므로 종료 자 자체에 대한 참조를 실수로 캡처하는 것에 대해 걱정할 필요없이 종료자를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99b352b3839ee48b6a471f7ec46b92984bf71f47" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;font&lt;/em&gt; specifies how to display text on a graphical terminal. There are actually three separate font types&amp;mdash;&lt;em&gt;font objects&lt;/em&gt;, &lt;em&gt;font specs&lt;/em&gt;, and &lt;em&gt;font entities&lt;/em&gt;&amp;mdash;each of which has slightly different properties. None of them have a read syntax; their print syntax looks like &amp;lsquo;</source>
          <target state="translated">&lt;em&gt;글꼴&lt;/em&gt; 을 지정하는 방법 그래픽 터미널에 텍스트를 표시합니다. 실제로 &lt;em&gt;글꼴 개체&lt;/em&gt; , &lt;em&gt;글꼴 사양&lt;/em&gt; 및 &lt;em&gt;글꼴 엔터티의&lt;/em&gt; 세 가지 개별 글꼴 유형이 있으며 각 유형 에는 약간 다른 속성이 있습니다. 그들 중 어느 것도 읽기 구문이 없습니다. 그들의 인쇄 구문은 '</target>
        </trans-unit>
        <trans-unit id="cf495fc305171d785ac263bbb756e22d29649431" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;fontset&lt;/em&gt; is a list of fonts, each assigned to a range of character codes. An individual font cannot display the whole range of characters that Emacs supports, but a fontset can. Fontsets have names, just as fonts do, and you can use a fontset name in place of a font name when you specify the font for a frame or a face. Here is information about defining a fontset under Lisp program control.</source>
          <target state="translated">&lt;em&gt;폰트 세트는&lt;/em&gt; 글꼴, 문자 코드의 범위에 할당 된 각의 목록입니다. 개별 글꼴은 Emacs가 지원하는 전체 문자 범위를 표시 할 수 없지만 글꼴 집합은 표시 할 수 있습니다. 글꼴 세트에는 글꼴과 마찬가지로 이름이 있으며 프레임 또는 얼굴의 글꼴을 지정할 때 글꼴 이름 대신 글꼴 세트 이름을 사용할 수 있습니다. 다음은 Lisp 프로그램 제어에서 글꼴 집합을 정의하는 방법에 대한 정보입니다.</target>
        </trans-unit>
        <trans-unit id="6e7ec63ccc23013db0bcf9c823a2170ba27b77ec" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;frame configuration&lt;/em&gt; records the current arrangement of frames, all their properties, and the window configuration of each one. (See &lt;a href=&quot;window-configurations#Window-Configurations&quot;&gt;Window Configurations&lt;/a&gt;.)</source>
          <target state="translated">&lt;em&gt;프레임 구조는&lt;/em&gt; 프레임의 모든 특성은 현재 구성 및 각 윈도우의 구성을 기록한다. ( &lt;a href=&quot;window-configurations#Window-Configurations&quot;&gt;창 구성을&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="bdb34f67e1e9ada804a26661b470461156464a32" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;frame configuration&lt;/em&gt; stores information about the positions, sizes, and contents of the windows in all frames. It is not a primitive type&amp;mdash;it is actually a list whose &lt;small&gt;CAR&lt;/small&gt; is &lt;code&gt;frame-configuration&lt;/code&gt; and whose &lt;small&gt;CDR&lt;/small&gt; is an alist. Each alist element describes one frame, which appears as the &lt;small&gt;CAR&lt;/small&gt; of that element.</source>
          <target state="translated">&lt;em&gt;프레임 구성의&lt;/em&gt; 모든 프레임에서 윈도우의 위치, 크기 및 내용에 대한 정보를 저장합니다. 기본 유형이 아닙니다. 실제로 &lt;small&gt;CAR&lt;/small&gt; 이 &lt;code&gt;frame-configuration&lt;/code&gt; 이고 &lt;small&gt;CDR&lt;/small&gt; 이 목록 인 목록입니다 . 각 alist 요소 는 해당 요소 의 &lt;small&gt;CAR&lt;/small&gt; 로 나타나는 하나의 프레임을 설명 합니다.</target>
        </trans-unit>
        <trans-unit id="5332e8873c75bb7ff6085b71dc2c97ddd4c56866" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;frame&lt;/em&gt; is a screen area that contains one or more Emacs windows; we also use the term &amp;ldquo;frame&amp;rdquo; to refer to the Lisp object that Emacs uses to refer to the screen area.</source>
          <target state="translated">&lt;em&gt;프레임은&lt;/em&gt; 하나 또는 그 이상의 이맥스 창을 포함하는 화면 영역입니다; 또한 Emacs가 화면 영역을 참조하는 데 사용하는 Lisp 개체를 지칭하기 위해 &quot;프레임&quot;이라는 용어를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7005fbe65ff98f53ff5b531201eb323a6292f93a" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;frame&lt;/em&gt; is a screen object that contains one or more Emacs windows (see &lt;a href=&quot;windows#Windows&quot;&gt;Windows&lt;/a&gt;). It is the kind of object called a &amp;ldquo;window&amp;rdquo; in the terminology of graphical environments; but we can&amp;rsquo;t call it a &amp;ldquo;window&amp;rdquo; here, because Emacs uses that word in a different way. In Emacs Lisp, a &lt;em&gt;frame object&lt;/em&gt; is a Lisp object that represents a frame on the screen. See &lt;a href=&quot;frame-type#Frame-Type&quot;&gt;Frame Type&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;프레임은&lt;/em&gt; 하나 또는 그 이상의 이맥스 창 (참조가 포함 된 화면 개체입니다 &lt;a href=&quot;windows#Windows&quot;&gt;윈도우&lt;/a&gt; ). 이것은 그래픽 환경의 용어로 &quot;창&quot;이라고하는 일종의 객체입니다. 그러나 Emacs는이 단어를 다른 방식으로 사용하기 때문에 여기서 &quot;창&quot;이라고 부를 수는 없습니다. Emacs Lisp에서 &lt;em&gt;프레임 객체&lt;/em&gt; 는 화면의 프레임을 나타내는 Lisp 객체입니다. &lt;a href=&quot;frame-type#Frame-Type&quot;&gt;프레임 유형을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f88eec5b56af18f140f7d22807ca47874dd75224" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;generalized variable&lt;/em&gt; or &lt;em&gt;place form&lt;/em&gt; is one of the many places in Lisp memory where values can be stored using the &lt;code&gt;setf&lt;/code&gt; macro (see &lt;a href=&quot;setting-generalized-variables#Setting-Generalized-Variables&quot;&gt;Setting Generalized Variables&lt;/a&gt;). The simplest place form is a regular Lisp variable. But the &lt;small&gt;CAR&lt;/small&gt;s and &lt;small&gt;CDR&lt;/small&gt;s of lists, elements of arrays, properties of symbols, and many other locations are also places where Lisp values get stored.</source>
          <target state="translated">&lt;em&gt;일반화 변수&lt;/em&gt; 또는 &lt;em&gt;장소 형태&lt;/em&gt; 값이 사용 저장할 수있는 리스프 메모리의 많은 장소 중 하나 &lt;code&gt;setf&lt;/code&gt; 의의 (참조 매크로 &lt;a href=&quot;setting-generalized-variables#Setting-Generalized-Variables&quot;&gt;일반화 변수 설정&lt;/a&gt; ). 가장 간단한 장소 형식은 일반 Lisp 변수입니다. 그러나 목록의 &lt;small&gt;CAR&lt;/small&gt; 및 &lt;small&gt;CDR&lt;/small&gt; , 배열 요소, 기호 속성 및 기타 여러 위치도 Lisp 값이 저장되는 장소입니다.</target>
        </trans-unit>
        <trans-unit id="2e00b950f26582a69a82bcfeb353306eb48c749f" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;generator&lt;/em&gt; is a function that produces a potentially-infinite stream of values. Each time the function produces a value, it suspends itself and waits for a caller to request the next value.</source>
          <target state="translated">&lt;em&gt;발생기&lt;/em&gt; 값의 잠재적으로 무한 스트림을 생성하는 함수이다. 함수가 값을 생성 할 때마다 자신을 일시 중지하고 호출자가 다음 값을 요청할 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="9b2b0dd0e5a45f9158401409dcf1687cdf829136" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;global break condition&lt;/em&gt; stops execution when a specified condition is satisfied, no matter where that may occur. Edebug evaluates the global break condition at every stop point; if it evaluates to a non-&lt;code&gt;nil&lt;/code&gt; value, then execution stops or pauses depending on the execution mode, as if a breakpoint had been hit. If evaluating the condition gets an error, execution does not stop.</source>
          <target state="translated">&lt;em&gt;글로벌 브레이크 상태가&lt;/em&gt; 지정된 조건이 만족 될 때 실행을 중지, 즉 발생없이. Edebug는 모든 중지 지점에서 전역 중단 조건을 평가합니다. &lt;code&gt;nil&lt;/code&gt; 이 아닌 값으로 평가 되면 중단 점이 적중 된 것처럼 실행 모드에 따라 실행이 중지되거나 일시 중지됩니다. 조건 평가에 오류가 발생하면 실행이 중지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8f1a3403d60a9a41e86b1033af245da071e2841d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;glyph&lt;/em&gt; is a graphical symbol which occupies a single character position on the screen. Each glyph is represented in Lisp as a &lt;em&gt;glyph code&lt;/em&gt;, which specifies a character and optionally a face to display it in (see &lt;a href=&quot;faces#Faces&quot;&gt;Faces&lt;/a&gt;). The main use of glyph codes is as the entries of display tables (see &lt;a href=&quot;display-tables#Display-Tables&quot;&gt;Display Tables&lt;/a&gt;). The following functions are used to manipulate glyph codes:</source>
          <target state="translated">&lt;em&gt;그래프는&lt;/em&gt; 화면에 하나의 문자 위치를 차지 그래픽 상징이다. 각 글리프는 Lisp에서 &lt;em&gt;글리프 코드&lt;/em&gt; 로 표현되며 문자와 선택적으로 표시 할 얼굴을 지정합니다 ( &lt;a href=&quot;faces#Faces&quot;&gt;Faces&lt;/a&gt; 참조 ). 글리프 코드의 주요 사용은 디스플레이 테이블의 항목으로이다 ( &lt;a href=&quot;display-tables#Display-Tables&quot;&gt;디스플레이 테이블&lt;/a&gt; ). 다음 함수는 글리프 코드를 조작하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fc890b7a72b483efddff830ca6044d4db575c15e" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;hook&lt;/em&gt; is a variable where you can store a function or functions to be called on a particular occasion by an existing program. Emacs provides hooks for the sake of customization. Most often, hooks are set up in the init file (see &lt;a href=&quot;init-file#Init-File&quot;&gt;Init File&lt;/a&gt;), but Lisp programs can set them also. See &lt;a href=&quot;standard-hooks#Standard-Hooks&quot;&gt;Standard Hooks&lt;/a&gt;, for a list of some standard hook variables.</source>
          <target state="translated">&lt;em&gt;후크는&lt;/em&gt; 기존의 프로그램에 의해 특정 경우에 호출하는 함수 또는 함수를 저장할 수있는 변수입니다. Emacs는 사용자 정의를 위해 후크를 제공합니다. 대부분의 경우 후크는 init 파일에 설정되지만 ( &lt;a href=&quot;init-file#Init-File&quot;&gt;Init 파일&lt;/a&gt; 참조 ) Lisp 프로그램도 설정할 수 있습니다. 일부 표준 후크 변수 목록은 &lt;a href=&quot;standard-hooks#Standard-Hooks&quot;&gt;표준 후크를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bffdbb4588347fb567343611aa24c24d8bc17385" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;key sequence&lt;/em&gt;, or &lt;em&gt;key&lt;/em&gt; for short, is a sequence of one or more input events that form a unit. Input events include characters, function keys, mouse actions, or system events external to Emacs, such as &lt;code&gt;iconify-frame&lt;/code&gt; (see &lt;a href=&quot;input-events#Input-Events&quot;&gt;Input Events&lt;/a&gt;). The Emacs Lisp representation for a key sequence is a string or vector. Unless otherwise stated, any Emacs Lisp function that accepts a key sequence as an argument can handle both representations.</source>
          <target state="translated">&lt;em&gt;키 시퀀스&lt;/em&gt; 또는 &lt;em&gt;키&lt;/em&gt; 짧게는 유닛을 형성하는 하나 개 이상의 입력 이벤트의 시퀀스이다. 입력 이벤트에는 문자, 기능 키, 마우스 동작 또는 &lt;code&gt;iconify-frame&lt;/code&gt; 과 같은 Emacs 외부의 시스템 이벤트가 포함됩니다 ( &lt;a href=&quot;input-events#Input-Events&quot;&gt;입력 이벤트&lt;/a&gt; 참조 ). 키 시퀀스에 대한 Emacs Lisp 표현은 문자열 또는 벡터입니다. 달리 명시되지 않는 한, 키 시퀀스를 인수로 받아들이는 Emacs Lisp 함수는 두 표현을 모두 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="b85988e0bf41dad4173ddd11ccf598cee7e5972e" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;keyboard macro&lt;/em&gt; is a canned sequence of input events that can be considered a command and made the definition of a key. The Lisp representation of a keyboard macro is a string or vector containing the events. Don&amp;rsquo;t confuse keyboard macros with Lisp macros (see &lt;a href=&quot;macros#Macros&quot;&gt;Macros&lt;/a&gt;).</source>
          <target state="translated">&lt;em&gt;키보드 매크로&lt;/em&gt; 명령을 고려하고 키의 정의를 할 수 입력 이벤트의 통조림 순서입니다. 키보드 매크로의 Lisp 표현은 이벤트를 포함하는 문자열 또는 벡터입니다. 리스프 매크로 (참조하지 혼동 키보드 매크로를 수행 &lt;a href=&quot;macros#Macros&quot;&gt;매크로&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="26289a3b7ffc5e23d66eaad1d2458be5aefdcf24" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;keymap&lt;/em&gt; maps keys typed by the user to commands. This mapping controls how the user&amp;rsquo;s command input is executed. A keymap is actually a list whose &lt;small&gt;CAR&lt;/small&gt; is the symbol &lt;code&gt;keymap&lt;/code&gt;.</source>
          <target state="translated">A &lt;em&gt;keymap&lt;/em&gt; maps keys typed by the user to commands. This mapping controls how the user&amp;rsquo;s command input is executed. A keymap is actually a list whose &lt;small&gt;CAR&lt;/small&gt; is the symbol &lt;code&gt;keymap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="84844081aae365d9d0de9b26a33a808ddac23b71" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;list&lt;/em&gt; is a series of cons cells, linked together so that the &lt;small&gt;CDR&lt;/small&gt; slot of each cons cell holds either the next cons cell or the empty list. The empty list is actually the symbol &lt;code&gt;nil&lt;/code&gt;. See &lt;a href=&quot;lists#Lists&quot;&gt;Lists&lt;/a&gt;, for details. Because most cons cells are used as part of lists, we refer to any structure made out of cons cells as a &lt;em&gt;list structure&lt;/em&gt;.</source>
          <target state="translated">A &lt;em&gt;list&lt;/em&gt; is a series of cons cells, linked together so that the &lt;small&gt;CDR&lt;/small&gt; slot of each cons cell holds either the next cons cell or the empty list. The empty list is actually the symbol &lt;code&gt;nil&lt;/code&gt; . See &lt;a href=&quot;lists#Lists&quot;&gt;Lists&lt;/a&gt;, for details. Because most cons cells are used as part of lists, we refer to any structure made out of cons cells as a &lt;em&gt;list structure&lt;/em&gt;.</target>
        </trans-unit>
        <trans-unit id="af9d5be7310bdf986a613a593c3dd63f8b5a68a2" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;list&lt;/em&gt; represents a sequence of zero or more elements (which may be any Lisp objects). The important difference between lists and vectors is that two or more lists can share part of their structure; in addition, you can insert or delete elements in a list without copying the whole list.</source>
          <target state="translated">A &lt;em&gt;list&lt;/em&gt; represents a sequence of zero or more elements (which may be any Lisp objects). The important difference between lists and vectors is that two or more lists can share part of their structure; in addition, you can insert or delete elements in a list without copying the whole list.</target>
        </trans-unit>
        <trans-unit id="caf235f1847f4378a02cdfbd452659a1c4694aa0" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;live frame&lt;/em&gt; is one that has not been deleted. When a frame is deleted, it is removed from its terminal display, although it may continue to exist as a Lisp object until there are no more references to it.</source>
          <target state="translated">A &lt;em&gt;live frame&lt;/em&gt; is one that has not been deleted. When a frame is deleted, it is removed from its terminal display, although it may continue to exist as a Lisp object until there are no more references to it.</target>
        </trans-unit>
        <trans-unit id="8066ef771ec62ca85e2f184cfbffda7ebe217837" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;live window&lt;/em&gt; is one that is actually displaying a buffer in a frame.</source>
          <target state="translated">A &lt;em&gt;live window&lt;/em&gt; is one that is actually displaying a buffer in a frame.</target>
        </trans-unit>
        <trans-unit id="27e69c5bbb12137e4e756c6d8a53777154a45869" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;mapping function&lt;/em&gt; applies a given function (&lt;em&gt;not&lt;/em&gt; a special form or macro) to each element of a list or other collection. Emacs Lisp has several such functions; this section describes &lt;code&gt;mapcar&lt;/code&gt;, &lt;code&gt;mapc&lt;/code&gt;, &lt;code&gt;mapconcat&lt;/code&gt;, and &lt;code&gt;mapcan&lt;/code&gt;, which map over a list. See &lt;a href=&quot;creating-symbols#Definition-of-mapatoms&quot;&gt;Definition of mapatoms&lt;/a&gt;, for the function &lt;code&gt;mapatoms&lt;/code&gt; which maps over the symbols in an obarray. See &lt;a href=&quot;hash-access#Definition-of-maphash&quot;&gt;Definition of maphash&lt;/a&gt;, for the function &lt;code&gt;maphash&lt;/code&gt; which maps over key/value associations in a hash table.</source>
          <target state="translated">A &lt;em&gt;mapping function&lt;/em&gt; applies a given function (&lt;em&gt;not&lt;/em&gt; a special form or macro) to each element of a list or other collection. Emacs Lisp has several such functions; this section describes &lt;code&gt;mapcar&lt;/code&gt; , &lt;code&gt;mapc&lt;/code&gt; , &lt;code&gt;mapconcat&lt;/code&gt; , and &lt;code&gt;mapcan&lt;/code&gt; , which map over a list. See &lt;a href=&quot;creating-symbols#Definition-of-mapatoms&quot;&gt;Definition of mapatoms&lt;/a&gt;, for the function &lt;code&gt;mapatoms&lt;/code&gt; which maps over the symbols in an obarray. See &lt;a href=&quot;hash-access#Definition-of-maphash&quot;&gt;Definition of maphash&lt;/a&gt;, for the function &lt;code&gt;maphash&lt;/code&gt; which maps over key/value associations in a hash table.</target>
        </trans-unit>
        <trans-unit id="a9ae386e3e011cfcbc753bf66f2b7dc0fabd4c7d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;marker&lt;/em&gt; denotes a position in a specific buffer. Markers therefore have two components: one for the buffer, and one for the position. Changes in the buffer&amp;rsquo;s text automatically relocate the position value as necessary to ensure that the marker always points between the same two characters in the buffer.</source>
          <target state="translated">A &lt;em&gt;marker&lt;/em&gt; denotes a position in a specific buffer. Markers therefore have two components: one for the buffer, and one for the position. Changes in the buffer&amp;rsquo;s text automatically relocate the position value as necessary to ensure that the marker always points between the same two characters in the buffer.</target>
        </trans-unit>
        <trans-unit id="10866be02ee509421064f62cfd0967bae1b9827e" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;marker&lt;/em&gt; is a Lisp object used to specify a position in a buffer relative to the surrounding text. A marker changes its offset from the beginning of the buffer automatically whenever text is inserted or deleted, so that it stays with the two characters on either side of it.</source>
          <target state="translated">A &lt;em&gt;marker&lt;/em&gt; is a Lisp object used to specify a position in a buffer relative to the surrounding text. A marker changes its offset from the beginning of the buffer automatically whenever text is inserted or deleted, so that it stays with the two characters on either side of it.</target>
        </trans-unit>
        <trans-unit id="c40b04bfc88c42dd334dd169fa41966183de182f" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;meta character&lt;/em&gt; is a character typed with the</source>
          <target state="translated">A &lt;em&gt;meta character&lt;/em&gt; is a character typed with the</target>
        </trans-unit>
        <trans-unit id="23a7fef4af90e3b0c9cafbdf008ce03197ab4053" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;minibuffer history list&lt;/em&gt; records previous minibuffer inputs so the user can reuse them conveniently. It is a variable whose value is a list of strings (previous inputs), most recent first.</source>
          <target state="translated">A &lt;em&gt;minibuffer history list&lt;/em&gt; records previous minibuffer inputs so the user can reuse them conveniently. It is a variable whose value is a list of strings (previous inputs), most recent first.</target>
        </trans-unit>
        <trans-unit id="a3c74914ae7bc9ba19ba505460ec3639d41b6d29" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;minibuffer&lt;/em&gt; is a special buffer that Emacs commands use to read arguments more complicated than the single numeric prefix argument. These arguments include file names, buffer names, and command names (as in</source>
          <target state="translated">A &lt;em&gt;minibuffer&lt;/em&gt; is a special buffer that Emacs commands use to read arguments more complicated than the single numeric prefix argument. These arguments include file names, buffer names, and command names (as in</target>
        </trans-unit>
        <trans-unit id="095e352a513e7437f83cc3f2d00b1c1af9e83004" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;minor mode&lt;/em&gt; provides optional features that users may enable or disable independently of the choice of major mode. Minor modes can be enabled individually or in combination.</source>
          <target state="translated">A &lt;em&gt;minor mode&lt;/em&gt; provides optional features that users may enable or disable independently of the choice of major mode. Minor modes can be enabled individually or in combination.</target>
        </trans-unit>
        <trans-unit id="35acaca11349cdd41823945ec417fac0c53cf91f" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;mode&lt;/em&gt; is a set of definitions that customize Emacs behavior in useful ways. There are two varieties of modes: &lt;em&gt;minor modes&lt;/em&gt;, which provide features that users can turn on and off while editing; and &lt;em&gt;major modes&lt;/em&gt;, which are used for editing or interacting with a particular kind of text. Each buffer has exactly one &lt;em&gt;major mode&lt;/em&gt; at a time.</source>
          <target state="translated">A &lt;em&gt;mode&lt;/em&gt; is a set of definitions that customize Emacs behavior in useful ways. There are two varieties of modes: &lt;em&gt;minor modes&lt;/em&gt;, which provide features that users can turn on and off while editing; and &lt;em&gt;major modes&lt;/em&gt;, which are used for editing or interacting with a particular kind of text. Each buffer has exactly one &lt;em&gt;major mode&lt;/em&gt; at a time.</target>
        </trans-unit>
        <trans-unit id="37b921e8300edb8a842bf43a173edf00518feefd" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;mutex&lt;/em&gt; is an exclusive lock that threads can own and disown, in order to synchronize between them. See &lt;a href=&quot;mutexes#Mutexes&quot;&gt;Mutexes&lt;/a&gt;.</source>
          <target state="translated">A &lt;em&gt;mutex&lt;/em&gt; is an exclusive lock that threads can own and disown, in order to synchronize between them. See &lt;a href=&quot;mutexes#Mutexes&quot;&gt;Mutexes&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="4830aeeb1a3770ba82e4cfc3244dd0ec52cad099" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;mutex&lt;/em&gt; is an exclusive lock. At any moment, zero or one threads may own a mutex. If a thread attempts to acquire a mutex, and the mutex is already owned by some other thread, then the acquiring thread will block until the mutex becomes available.</source>
          <target state="translated">A &lt;em&gt;mutex&lt;/em&gt; is an exclusive lock. At any moment, zero or one threads may own a mutex. If a thread attempts to acquire a mutex, and the mutex is already owned by some other thread, then the acquiring thread will block until the mutex becomes available.</target>
        </trans-unit>
        <trans-unit id="dc0c42a6c93823ee7b58dbe26d1a5b8cff167d34" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;nonlocal exit&lt;/em&gt; is a transfer of control from one point in a program to another remote point. Nonlocal exits can occur in Emacs Lisp as a result of errors; you can also use them under explicit control. Nonlocal exits unbind all variable bindings made by the constructs being exited.</source>
          <target state="translated">A &lt;em&gt;nonlocal exit&lt;/em&gt; is a transfer of control from one point in a program to another remote point. Nonlocal exits can occur in Emacs Lisp as a result of errors; you can also use them under explicit control. Nonlocal exits unbind all variable bindings made by the constructs being exited.</target>
        </trans-unit>
        <trans-unit id="5e377035dc909cd277170acf67398e48b68c8bcc" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;parser state&lt;/em&gt; is a list of (currently) eleven elements describing the state of the syntactic parser, after it parses the text between a specified starting point and a specified end point in the buffer using &lt;code&gt;parse-partial-sexp&lt;/code&gt; (see &lt;a href=&quot;low_002dlevel-parsing#Low_002dLevel-Parsing&quot;&gt;Low-Level Parsing&lt;/a&gt;). Parsing functions such as &lt;code&gt;syntax-ppss&lt;/code&gt; (see &lt;a href=&quot;position-parse#Position-Parse&quot;&gt;Position Parse&lt;/a&gt;) also return a parser state as the value. &lt;code&gt;parse-partial-sexp&lt;/code&gt; can accept a parser state as an argument, for resuming parsing.</source>
          <target state="translated">A &lt;em&gt;parser state&lt;/em&gt; is a list of (currently) eleven elements describing the state of the syntactic parser, after it parses the text between a specified starting point and a specified end point in the buffer using &lt;code&gt;parse-partial-sexp&lt;/code&gt; (see &lt;a href=&quot;low_002dlevel-parsing#Low_002dLevel-Parsing&quot;&gt;Low-Level Parsing&lt;/a&gt;). Parsing functions such as &lt;code&gt;syntax-ppss&lt;/code&gt; (see &lt;a href=&quot;position-parse#Position-Parse&quot;&gt;Position Parse&lt;/a&gt;) also return a parser state as the value. &lt;code&gt;parse-partial-sexp&lt;/code&gt; can accept a parser state as an argument, for resuming parsing.</target>
        </trans-unit>
        <trans-unit id="99955a994ed6a1f18590cbdc73cecfc8216312e7" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;position&lt;/em&gt; is the index of a character in the text of a buffer. More precisely, a position identifies the place between two characters (or before the first character, or after the last character), so we can speak of the character before or after a given position. However, we often speak of the character &amp;ldquo;at&amp;rdquo; a position, meaning the character after that position.</source>
          <target state="translated">A &lt;em&gt;position&lt;/em&gt; is the index of a character in the text of a buffer. More precisely, a position identifies the place between two characters (or before the first character, or after the last character), so we can speak of the character before or after a given position. However, we often speak of the character &amp;ldquo;at&amp;rdquo; a position, meaning the character after that position.</target>
        </trans-unit>
        <trans-unit id="acbb40f52f0ff6871e2319c0abae324c32608028" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;prefix key&lt;/em&gt; is a key sequence whose binding is a keymap. The keymap defines what to do with key sequences that extend the prefix key. For example,</source>
          <target state="translated">A &lt;em&gt;prefix key&lt;/em&gt; is a key sequence whose binding is a keymap. The keymap defines what to do with key sequences that extend the prefix key. For example,</target>
        </trans-unit>
        <trans-unit id="a750851ed6b490138262266435560c5f1eb8ffec" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;pretty-printer&lt;/em&gt; function which is responsible for inserting the textual representation of a data element value into the current buffer.</source>
          <target state="translated">A &lt;em&gt;pretty-printer&lt;/em&gt; function which is responsible for inserting the textual representation of a data element value into the current buffer.</target>
        </trans-unit>
        <trans-unit id="ef7d6b5d68eeef2c9d56f4de3848bbbf8c671fb9" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;primitive function&lt;/em&gt; is a function callable from Lisp but written in the C programming language. Primitive functions are also called &lt;em&gt;subrs&lt;/em&gt; or &lt;em&gt;built-in functions&lt;/em&gt;. (The word &amp;ldquo;subr&amp;rdquo; is derived from &amp;ldquo;subroutine&amp;rdquo;.) Most primitive functions evaluate all their arguments when they are called. A primitive function that does not evaluate all its arguments is called a &lt;em&gt;special form&lt;/em&gt; (see &lt;a href=&quot;special-forms#Special-Forms&quot;&gt;Special Forms&lt;/a&gt;).</source>
          <target state="translated">A &lt;em&gt;primitive function&lt;/em&gt; is a function callable from Lisp but written in the C programming language. Primitive functions are also called &lt;em&gt;subrs&lt;/em&gt; or &lt;em&gt;built-in functions&lt;/em&gt;. (The word &amp;ldquo;subr&amp;rdquo; is derived from &amp;ldquo;subroutine&amp;rdquo;.) Most primitive functions evaluate all their arguments when they are called. A primitive function that does not evaluate all its arguments is called a &lt;em&gt;special form&lt;/em&gt; (see &lt;a href=&quot;special-forms#Special-Forms&quot;&gt;Special Forms&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="92dd79b41e8cbe4e517fdbda3429d77589653c7a" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;process sentinel&lt;/em&gt; is a function that is called whenever the associated process changes status for any reason, including signals (whether sent by Emacs or caused by the process&amp;rsquo;s own actions) that terminate, stop, or continue the process. The process sentinel is also called if the process exits. The sentinel receives two arguments: the process for which the event occurred, and a string describing the type of event.</source>
          <target state="translated">A &lt;em&gt;process sentinel&lt;/em&gt; is a function that is called whenever the associated process changes status for any reason, including signals (whether sent by Emacs or caused by the process&amp;rsquo;s own actions) that terminate, stop, or continue the process. The process sentinel is also called if the process exits. The sentinel receives two arguments: the process for which the event occurred, and a string describing the type of event.</target>
        </trans-unit>
        <trans-unit id="12f51ef3151fa4e8e2f32edf93c5a003ab590ef1" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;property list&lt;/em&gt; (&lt;em&gt;plist&lt;/em&gt; for short) is a list of paired elements. Each of the pairs associates a property name (usually a symbol) with a property or value. Here is an example of a property list:</source>
          <target state="translated">A &lt;em&gt;property list&lt;/em&gt; (&lt;em&gt;plist&lt;/em&gt; for short) is a list of paired elements. Each of the pairs associates a property name (usually a symbol) with a property or value. Here is an example of a property list:</target>
        </trans-unit>
        <trans-unit id="52b2b067c403f7f587744597ed1ab1d8466917e9" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;record&lt;/em&gt; is much like a &lt;code&gt;vector&lt;/code&gt;. However, the first element is used to hold its type as returned by &lt;code&gt;type-of&lt;/code&gt;. The purpose of records is to allow programmers to create objects with new types that are not built into Emacs.</source>
          <target state="translated">A &lt;em&gt;record&lt;/em&gt; is much like a &lt;code&gt;vector&lt;/code&gt; . However, the first element is used to hold its type as returned by &lt;code&gt;type-of&lt;/code&gt; . The purpose of records is to allow programmers to create objects with new types that are not built into Emacs.</target>
        </trans-unit>
        <trans-unit id="ac904311c71c6650010f4b866dec5796be0375e1" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;regular expression&lt;/em&gt;, or &lt;em&gt;regexp&lt;/em&gt; for short, is a pattern that denotes a (possibly infinite) set of strings. Searching for matches for a regexp is a very powerful operation. This section explains how to write regexps; the following section says how to search for them.</source>
          <target state="translated">A &lt;em&gt;regular expression&lt;/em&gt;, or &lt;em&gt;regexp&lt;/em&gt; for short, is a pattern that denotes a (possibly infinite) set of strings. Searching for matches for a regexp is a very powerful operation. This section explains how to write regexps; the following section says how to search for them.</target>
        </trans-unit>
        <trans-unit id="340faeff4ade281880a3cb6ca1e42a0487f388d4" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;ring&lt;/em&gt; is a fixed-size data structure that supports insertion, deletion, rotation, and modulo-indexed reference and traversal. An efficient ring data structure is implemented by the &lt;code&gt;ring&lt;/code&gt; package. It provides the functions listed in this section.</source>
          <target state="translated">A &lt;em&gt;ring&lt;/em&gt; is a fixed-size data structure that supports insertion, deletion, rotation, and modulo-indexed reference and traversal. An efficient ring data structure is implemented by the &lt;code&gt;ring&lt;/code&gt; package. It provides the functions listed in this section.</target>
        </trans-unit>
        <trans-unit id="68107fbcb19dcf923ea627fb36416c892f961e00" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;self-evaluating form&lt;/em&gt; is any form that is not a list or symbol. Self-evaluating forms evaluate to themselves: the result of evaluation is the same object that was evaluated. Thus, the number 25 evaluates to 25, and the string &lt;code&gt;&quot;foo&quot;&lt;/code&gt; evaluates to the string &lt;code&gt;&quot;foo&quot;&lt;/code&gt;. Likewise, evaluating a vector does not cause evaluation of the elements of the vector&amp;mdash;it returns the same vector with its contents unchanged.</source>
          <target state="translated">A &lt;em&gt;self-evaluating form&lt;/em&gt; is any form that is not a list or symbol. Self-evaluating forms evaluate to themselves: the result of evaluation is the same object that was evaluated. Thus, the number 25 evaluates to 25, and the string &lt;code&gt;&quot;foo&quot;&lt;/code&gt; evaluates to the string &lt;code&gt;&quot;foo&quot;&lt;/code&gt; . Likewise, evaluating a vector does not cause evaluation of the elements of the vector&amp;mdash;it returns the same vector with its contents unchanged.</target>
        </trans-unit>
        <trans-unit id="97affbde2ffa12c383f5a977599a31f30dc833c5" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;sequence&lt;/em&gt; is a Lisp object that represents an ordered set of elements. There are two kinds of sequence in Emacs Lisp: &lt;em&gt;lists&lt;/em&gt; and &lt;em&gt;arrays&lt;/em&gt;.</source>
          <target state="translated">A &lt;em&gt;sequence&lt;/em&gt; is a Lisp object that represents an ordered set of elements. There are two kinds of sequence in Emacs Lisp: &lt;em&gt;lists&lt;/em&gt; and &lt;em&gt;arrays&lt;/em&gt;.</target>
        </trans-unit>
        <trans-unit id="568827dac526a47b39447d6b276556cfd23968d9" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;sequencing pattern&lt;/em&gt; (also known as &lt;var&gt;seqpat&lt;/var&gt;) is a pattern that processes its sub-pattern arguments in sequence. There are two for &lt;code&gt;pcase&lt;/code&gt;: &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt;. They behave in a similar manner to the special forms that share their name (see &lt;a href=&quot;combining-conditions#Combining-Conditions&quot;&gt;Combining Conditions&lt;/a&gt;), but instead of processing values, they process sub-patterns.</source>
          <target state="translated">A &lt;em&gt;sequencing pattern&lt;/em&gt; (also known as &lt;var&gt;seqpat&lt;/var&gt; ) is a pattern that processes its sub-pattern arguments in sequence. There are two for &lt;code&gt;pcase&lt;/code&gt; : &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; . They behave in a similar manner to the special forms that share their name (see &lt;a href=&quot;combining-conditions#Combining-Conditions&quot;&gt;Combining Conditions&lt;/a&gt;), but instead of processing values, they process sub-patterns.</target>
        </trans-unit>
        <trans-unit id="44ce679751e6da1d1f8b12e72ba46761e9428d8c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;special form&lt;/em&gt; is a primitive function specially marked so that its arguments are not all evaluated. Most special forms define control structures or perform variable bindings&amp;mdash;things which functions cannot do.</source>
          <target state="translated">A &lt;em&gt;special form&lt;/em&gt; is a primitive function specially marked so that its arguments are not all evaluated. Most special forms define control structures or perform variable bindings&amp;mdash;things which functions cannot do.</target>
        </trans-unit>
        <trans-unit id="b859c57965a012d5104743eca8f2d1fc761af942" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;specification list&lt;/em&gt; is required for an Edebug specification if some arguments of a macro call are evaluated while others are not. Some elements in a specification list match one or more arguments, but others modify the processing of all following elements. The latter, called &lt;em&gt;specification keywords&lt;/em&gt;, are symbols beginning with &amp;lsquo;</source>
          <target state="translated">A &lt;em&gt;specification list&lt;/em&gt; is required for an Edebug specification if some arguments of a macro call are evaluated while others are not. Some elements in a specification list match one or more arguments, but others modify the processing of all following elements. The latter, called &lt;em&gt;specification keywords&lt;/em&gt;, are symbols beginning with &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="21fe5cc3e8db4633a353ec7b1907c0b1a22bd112" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;stream&lt;/em&gt; is an object that can be used as a source or sink for characters&amp;mdash;either to supply characters for input or to accept them as output. Many different types can be used this way: markers, buffers, strings, and functions. Most often, input streams (character sources) obtain characters from the keyboard, a buffer, or a file, and output streams (character sinks) send characters to a buffer, such as a</source>
          <target state="translated">A &lt;em&gt;stream&lt;/em&gt; is an object that can be used as a source or sink for characters&amp;mdash;either to supply characters for input or to accept them as output. Many different types can be used this way: markers, buffers, strings, and functions. Most often, input streams (character sources) obtain characters from the keyboard, a buffer, or a file, and output streams (character sinks) send characters to a buffer, such as a</target>
        </trans-unit>
        <trans-unit id="96f59884a848b92e2675f99c9b833d4b90e7cca7" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;string&lt;/em&gt; is an array of characters. Strings are used for many purposes in Emacs, as can be expected in a text editor; for example, as the names of Lisp symbols, as messages for the user, and to represent text extracted from buffers. Strings in Lisp are constants: evaluation of a string returns the same string.</source>
          <target state="translated">A &lt;em&gt;string&lt;/em&gt; is an array of characters. Strings are used for many purposes in Emacs, as can be expected in a text editor; for example, as the names of Lisp symbols, as messages for the user, and to represent text extracted from buffers. Strings in Lisp are constants: evaluation of a string returns the same string.</target>
        </trans-unit>
        <trans-unit id="0d072ef54b4cc522b35609148bc97bd4b7293a8a" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;symbol&lt;/em&gt; in GNU Emacs Lisp is an object with a name. The symbol name serves as the printed representation of the symbol. In ordinary Lisp use, with one single obarray (see &lt;a href=&quot;creating-symbols#Creating-Symbols&quot;&gt;Creating Symbols&lt;/a&gt;), a symbol&amp;rsquo;s name is unique&amp;mdash;no two symbols have the same name.</source>
          <target state="translated">A &lt;em&gt;symbol&lt;/em&gt; in GNU Emacs Lisp is an object with a name. The symbol name serves as the printed representation of the symbol. In ordinary Lisp use, with one single obarray (see &lt;a href=&quot;creating-symbols#Creating-Symbols&quot;&gt;Creating Symbols&lt;/a&gt;), a symbol&amp;rsquo;s name is unique&amp;mdash;no two symbols have the same name.</target>
        </trans-unit>
        <trans-unit id="5c76bc331660adccd694734fdd974e80b6b3ec0b" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;symbol&lt;/em&gt; is an object with a unique name. This chapter describes symbols, their components, their property lists, and how they are created and interned. Separate chapters describe the use of symbols as variables and as function names; see &lt;a href=&quot;variables#Variables&quot;&gt;Variables&lt;/a&gt;, and &lt;a href=&quot;functions#Functions&quot;&gt;Functions&lt;/a&gt;. For the precise read syntax for symbols, see &lt;a href=&quot;symbol-type#Symbol-Type&quot;&gt;Symbol Type&lt;/a&gt;.</source>
          <target state="translated">A &lt;em&gt;symbol&lt;/em&gt; is an object with a unique name. This chapter describes symbols, their components, their property lists, and how they are created and interned. Separate chapters describe the use of symbols as variables and as function names; see &lt;a href=&quot;variables#Variables&quot;&gt;Variables&lt;/a&gt;, and &lt;a href=&quot;functions#Functions&quot;&gt;Functions&lt;/a&gt;. For the precise read syntax for symbols, see &lt;a href=&quot;symbol-type#Symbol-Type&quot;&gt;Symbol Type&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="b20ef7f5f1b7eef351ff780dde60d61921f5757e" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;syntax descriptor&lt;/em&gt; is a Lisp string that describes the syntax class and other syntactic properties of a character. When you want to modify the syntax of a character, that is done by calling the function &lt;code&gt;modify-syntax-entry&lt;/code&gt; and passing a syntax descriptor as one of its arguments (see &lt;a href=&quot;syntax-table-functions#Syntax-Table-Functions&quot;&gt;Syntax Table Functions&lt;/a&gt;).</source>
          <target state="translated">A &lt;em&gt;syntax descriptor&lt;/em&gt; is a Lisp string that describes the syntax class and other syntactic properties of a character. When you want to modify the syntax of a character, that is done by calling the function &lt;code&gt;modify-syntax-entry&lt;/code&gt; and passing a syntax descriptor as one of its arguments (see &lt;a href=&quot;syntax-table-functions#Syntax-Table-Functions&quot;&gt;Syntax Table Functions&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="3a870e4ec1d3cf44e7dab053db3f22b7cb521b55" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;syntax table&lt;/em&gt; specifies the syntactic role of each character in a buffer. It can be used to determine where words, symbols, and other syntactic constructs begin and end. This information is used by many Emacs facilities, including Font Lock mode (see &lt;a href=&quot;font-lock-mode#Font-Lock-Mode&quot;&gt;Font Lock Mode&lt;/a&gt;) and the various complex movement commands (see &lt;a href=&quot;motion#Motion&quot;&gt;Motion&lt;/a&gt;).</source>
          <target state="translated">A &lt;em&gt;syntax table&lt;/em&gt; specifies the syntactic role of each character in a buffer. It can be used to determine where words, symbols, and other syntactic constructs begin and end. This information is used by many Emacs facilities, including Font Lock mode (see &lt;a href=&quot;font-lock-mode#Font-Lock-Mode&quot;&gt;Font Lock Mode&lt;/a&gt;) and the various complex movement commands (see &lt;a href=&quot;motion#Motion&quot;&gt;Motion&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="99b87789bc8b75b81e830bdef55dad68ee43fcaa" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;terminal&lt;/em&gt; is a device capable of displaying one or more Emacs frames (see &lt;a href=&quot;frame-type#Frame-Type&quot;&gt;Frame Type&lt;/a&gt;).</source>
          <target state="translated">A &lt;em&gt;terminal&lt;/em&gt; is a device capable of displaying one or more Emacs frames (see &lt;a href=&quot;frame-type#Frame-Type&quot;&gt;Frame Type&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="fc674df13ab428b273ec26c0dd720fcddbf5cf41" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;terminal&lt;/em&gt; is a display device capable of displaying one or more Emacs frames. In Emacs Lisp, a &lt;em&gt;terminal object&lt;/em&gt; is a Lisp object that represents a terminal. See &lt;a href=&quot;terminal-type#Terminal-Type&quot;&gt;Terminal Type&lt;/a&gt;.</source>
          <target state="translated">A &lt;em&gt;terminal&lt;/em&gt; is a display device capable of displaying one or more Emacs frames. In Emacs Lisp, a &lt;em&gt;terminal object&lt;/em&gt; is a Lisp object that represents a terminal. See &lt;a href=&quot;terminal-type#Terminal-Type&quot;&gt;Terminal Type&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="59e631708c8fbabe8339a1ca817ba7c237c89147" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;thread&lt;/em&gt; in Emacs represents a separate thread of Emacs Lisp execution. It runs its own Lisp program, has its own current buffer, and can have subprocesses locked to it, i.e. subprocesses whose output only this thread can accept. See &lt;a href=&quot;threads#Threads&quot;&gt;Threads&lt;/a&gt;.</source>
          <target state="translated">A &lt;em&gt;thread&lt;/em&gt; in Emacs represents a separate thread of Emacs Lisp execution. It runs its own Lisp program, has its own current buffer, and can have subprocesses locked to it, i.e. subprocesses whose output only this thread can accept. See &lt;a href=&quot;threads#Threads&quot;&gt;Threads&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="5c2cf5a995b49c827b5d22748c933ccd1cf7a468" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;toggle&lt;/em&gt; is a menu item which is labeled as either on or off according to the value of &lt;var&gt;selected&lt;/var&gt;. The command itself should toggle &lt;var&gt;selected&lt;/var&gt;, setting it to &lt;code&gt;t&lt;/code&gt; if it is &lt;code&gt;nil&lt;/code&gt;, and to &lt;code&gt;nil&lt;/code&gt; if it is &lt;code&gt;t&lt;/code&gt;. Here is how the menu item to toggle the &lt;code&gt;debug-on-error&lt;/code&gt; flag is defined:</source>
          <target state="translated">A &lt;em&gt;toggle&lt;/em&gt; is a menu item which is labeled as either on or off according to the value of &lt;var&gt;selected&lt;/var&gt; . The command itself should toggle &lt;var&gt;selected&lt;/var&gt; , setting it to &lt;code&gt;t&lt;/code&gt; if it is &lt;code&gt;nil&lt;/code&gt; , and to &lt;code&gt;nil&lt;/code&gt; if it is &lt;code&gt;t&lt;/code&gt; . Here is how the menu item to toggle the &lt;code&gt;debug-on-error&lt;/code&gt; flag is defined:</target>
        </trans-unit>
        <trans-unit id="fcd1859232eb3fd90a12024f85384e7d8dc9e40a" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;tool bar&lt;/em&gt; is a row of clickable icons at the top of a frame, just below the menu bar. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Tool-Bars.html#Tool-Bars&quot;&gt;Tool Bars&lt;/a&gt; in</source>
          <target state="translated">A &lt;em&gt;tool bar&lt;/em&gt; is a row of clickable icons at the top of a frame, just below the menu bar. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Tool-Bars.html#Tool-Bars&quot;&gt;Tool Bars&lt;/a&gt; in</target>
        </trans-unit>
        <trans-unit id="dcf23c2364e9a64ec7b2fbca8a8b877bcb33dd05" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;translation table&lt;/em&gt; is a char-table (see &lt;a href=&quot;char_002dtables#Char_002dTables&quot;&gt;Char-Tables&lt;/a&gt;) that specifies a mapping of characters into characters. These tables are used in encoding and decoding, and for other purposes. Some coding systems specify their own particular translation tables; there are also default translation tables which apply to all other coding systems.</source>
          <target state="translated">A &lt;em&gt;translation table&lt;/em&gt; is a char-table (see &lt;a href=&quot;char_002dtables#Char_002dTables&quot;&gt;Char-Tables&lt;/a&gt;) that specifies a mapping of characters into characters. These tables are used in encoding and decoding, and for other purposes. Some coding systems specify their own particular translation tables; there are also default translation tables which apply to all other coding systems.</target>
        </trans-unit>
        <trans-unit id="4e4b7c57666cacb5044a47b639cb9e52a3cc5602" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;type descriptor&lt;/em&gt; is a &lt;code&gt;record&lt;/code&gt; which holds information about a type. Slot 1 in the record must be a symbol naming the type, and &lt;code&gt;type-of&lt;/code&gt; relies on this to return the type of &lt;code&gt;record&lt;/code&gt; objects. No other type descriptor slot is used by Emacs; they are free for use by Lisp extensions.</source>
          <target state="translated">A &lt;em&gt;type descriptor&lt;/em&gt; is a &lt;code&gt;record&lt;/code&gt; which holds information about a type. Slot 1 in the record must be a symbol naming the type, and &lt;code&gt;type-of&lt;/code&gt; relies on this to return the type of &lt;code&gt;record&lt;/code&gt; objects. No other type descriptor slot is used by Emacs; they are free for use by Lisp extensions.</target>
        </trans-unit>
        <trans-unit id="cf4c3266ea964fd1cade86b02fc7862eb97f6b90" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;valid window&lt;/em&gt; is one that is either live or internal. A valid window can be &lt;em&gt;deleted&lt;/em&gt;, i.e., removed from its frame (see &lt;a href=&quot;deleting-windows#Deleting-Windows&quot;&gt;Deleting Windows&lt;/a&gt;); then it is no longer valid, but the Lisp object representing it might be still referenced from other Lisp objects. A deleted window may be made valid again by restoring a saved window configuration (see &lt;a href=&quot;window-configurations#Window-Configurations&quot;&gt;Window Configurations&lt;/a&gt;).</source>
          <target state="translated">A &lt;em&gt;valid window&lt;/em&gt; is one that is either live or internal. A valid window can be &lt;em&gt;deleted&lt;/em&gt;, i.e., removed from its frame (see &lt;a href=&quot;deleting-windows#Deleting-Windows&quot;&gt;Deleting Windows&lt;/a&gt;); then it is no longer valid, but the Lisp object representing it might be still referenced from other Lisp objects. A deleted window may be made valid again by restoring a saved window configuration (see &lt;a href=&quot;window-configurations#Window-Configurations&quot;&gt;Window Configurations&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="5ad4daa28cddc16fff21959bfa78979f977c6062" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;variable definition&lt;/em&gt; is a construct that announces your intention to use a symbol as a global variable. It uses the special forms &lt;code&gt;defvar&lt;/code&gt; or &lt;code&gt;defconst&lt;/code&gt;, which are documented below.</source>
          <target state="translated">A &lt;em&gt;variable definition&lt;/em&gt; is a construct that announces your intention to use a symbol as a global variable. It uses the special forms &lt;code&gt;defvar&lt;/code&gt; or &lt;code&gt;defconst&lt;/code&gt; , which are documented below.</target>
        </trans-unit>
        <trans-unit id="a8c4d77d87118f0607591ffbfce0deb3dccc3cea" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;variable&lt;/em&gt; is a name that can be &lt;em&gt;bound&lt;/em&gt; (or &lt;em&gt;set&lt;/em&gt;) to an object. The object to which a variable is bound is called a &lt;em&gt;value&lt;/em&gt;; we say also that variable holds that value. Although nearly all variables can be set by the user, certain variables exist specifically so that users can change them; these are called &lt;em&gt;user options&lt;/em&gt;. Ordinary variables and user options are described using a format like that for functions, except that there are no arguments.</source>
          <target state="translated">A &lt;em&gt;variable&lt;/em&gt; is a name that can be &lt;em&gt;bound&lt;/em&gt; (or &lt;em&gt;set&lt;/em&gt;) to an object. The object to which a variable is bound is called a &lt;em&gt;value&lt;/em&gt;; we say also that variable holds that value. Although nearly all variables can be set by the user, certain variables exist specifically so that users can change them; these are called &lt;em&gt;user options&lt;/em&gt;. Ordinary variables and user options are described using a format like that for functions, except that there are no arguments.</target>
        </trans-unit>
        <trans-unit id="1156c4586d2d0883c8aca28ed3ce095b29909471" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;variable&lt;/em&gt; is a name used in a program to stand for a value. In Lisp, each variable is represented by a Lisp symbol (see &lt;a href=&quot;symbols#Symbols&quot;&gt;Symbols&lt;/a&gt;). The variable name is simply the symbol&amp;rsquo;s name, and the variable&amp;rsquo;s value is stored in the symbol&amp;rsquo;s value cell&lt;a href=&quot;#FOOT8&quot; name=&quot;DOCF8&quot;&gt;&lt;sup&gt;8&lt;/sup&gt;&lt;/a&gt;. See &lt;a href=&quot;symbol-components#Symbol-Components&quot;&gt;Symbol Components&lt;/a&gt;. In Emacs Lisp, the use of a symbol as a variable is independent of its use as a function name.</source>
          <target state="translated">A &lt;em&gt;variable&lt;/em&gt; is a name used in a program to stand for a value. In Lisp, each variable is represented by a Lisp symbol (see &lt;a href=&quot;symbols#Symbols&quot;&gt;Symbols&lt;/a&gt;). The variable name is simply the symbol&amp;rsquo;s name, and the variable&amp;rsquo;s value is stored in the symbol&amp;rsquo;s value cell&lt;a href=&quot;#FOOT8&quot; name=&quot;DOCF8&quot;&gt;&lt;sup&gt;8&lt;/sup&gt;&lt;/a&gt;. See &lt;a href=&quot;symbol-components#Symbol-Components&quot;&gt;Symbol Components&lt;/a&gt;. In Emacs Lisp, the use of a symbol as a variable is independent of its use as a function name.</target>
        </trans-unit>
        <trans-unit id="cd6722509f8edba7d22e136508797e09752ed07c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;vector&lt;/em&gt; is a general-purpose array whose elements can be any Lisp objects. (By contrast, the elements of a string can only be characters. See &lt;a href=&quot;strings-and-characters#Strings-and-Characters&quot;&gt;Strings and Characters&lt;/a&gt;.) Vectors are used in Emacs for many purposes: as key sequences (see &lt;a href=&quot;key-sequences#Key-Sequences&quot;&gt;Key Sequences&lt;/a&gt;), as symbol-lookup tables (see &lt;a href=&quot;creating-symbols#Creating-Symbols&quot;&gt;Creating Symbols&lt;/a&gt;), as part of the representation of a byte-compiled function (see &lt;a href=&quot;byte-compilation#Byte-Compilation&quot;&gt;Byte Compilation&lt;/a&gt;), and more.</source>
          <target state="translated">A &lt;em&gt;vector&lt;/em&gt; is a general-purpose array whose elements can be any Lisp objects. (By contrast, the elements of a string can only be characters. See &lt;a href=&quot;strings-and-characters#Strings-and-Characters&quot;&gt;Strings and Characters&lt;/a&gt;.) Vectors are used in Emacs for many purposes: as key sequences (see &lt;a href=&quot;key-sequences#Key-Sequences&quot;&gt;Key Sequences&lt;/a&gt;), as symbol-lookup tables (see &lt;a href=&quot;creating-symbols#Creating-Symbols&quot;&gt;Creating Symbols&lt;/a&gt;), as part of the representation of a byte-compiled function (see &lt;a href=&quot;byte-compilation#Byte-Compilation&quot;&gt;Byte Compilation&lt;/a&gt;), and more.</target>
        </trans-unit>
        <trans-unit id="55c4773d043da91116a793da0f1846bba4760d2f" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;vector&lt;/em&gt; is a one-dimensional array of elements of any type. It takes a constant amount of time to access any element of a vector. (In a list, the access time of an element is proportional to the distance of the element from the beginning of the list.)</source>
          <target state="translated">A &lt;em&gt;vector&lt;/em&gt; is a one-dimensional array of elements of any type. It takes a constant amount of time to access any element of a vector. (In a list, the access time of an element is proportional to the distance of the element from the beginning of the list.)</target>
        </trans-unit>
        <trans-unit id="ac5f70614b0372d4f8f82b846b8c000ce8f68ed3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;window configuration&lt;/em&gt; records the entire layout of one frame&amp;mdash;all windows, their sizes, which buffers they contain, how those buffers are scrolled, and their value of point; also their fringes, margins, and scroll bar settings. It also includes the value of &lt;code&gt;minibuffer-scroll-window&lt;/code&gt;. As a special exception, the window configuration does not record the value of point in the selected window for the current buffer.</source>
          <target state="translated">A &lt;em&gt;window configuration&lt;/em&gt; records the entire layout of one frame&amp;mdash;all windows, their sizes, which buffers they contain, how those buffers are scrolled, and their value of point; also their fringes, margins, and scroll bar settings. It also includes the value of &lt;code&gt;minibuffer-scroll-window&lt;/code&gt; . As a special exception, the window configuration does not record the value of point in the selected window for the current buffer.</target>
        </trans-unit>
        <trans-unit id="0d57455a82c850bc61f2d2aecdc1b09c8b42b9e8" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;window configuration&lt;/em&gt; stores information about the positions, sizes, and contents of the windows in a frame, so you can recreate the same arrangement of windows later.</source>
          <target state="translated">A &lt;em&gt;window configuration&lt;/em&gt; stores information about the positions, sizes, and contents of the windows in a frame, so you can recreate the same arrangement of windows later.</target>
        </trans-unit>
        <trans-unit id="c00b85431c59b78e8f4e74a1925ee57f90bf7090" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;window&lt;/em&gt; describes the portion of the terminal screen that Emacs uses to display a buffer. Every window has one associated buffer, whose contents appear in the window. By contrast, a given buffer may appear in one window, no window, or several windows.</source>
          <target state="translated">A &lt;em&gt;window&lt;/em&gt; describes the portion of the terminal screen that Emacs uses to display a buffer. Every window has one associated buffer, whose contents appear in the window. By contrast, a given buffer may appear in one window, no window, or several windows.</target>
        </trans-unit>
        <trans-unit id="f5cca0cf4b997e339b41d33bd8f75be84d6ffeaa" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;window&lt;/em&gt; is an area of the screen that is used to display a buffer (see &lt;a href=&quot;buffers#Buffers&quot;&gt;Buffers&lt;/a&gt;). In Emacs Lisp, windows are represented by a special Lisp object type.</source>
          <target state="translated">A &lt;em&gt;window&lt;/em&gt; is an area of the screen that is used to display a buffer (see &lt;a href=&quot;buffers#Buffers&quot;&gt;Buffers&lt;/a&gt;). In Emacs Lisp, windows are represented by a special Lisp object type.</target>
        </trans-unit>
        <trans-unit id="3507a8b3b334275d08f16d7312604f9c5451dc34" translate="yes" xml:space="preserve">
          <source>A Custom theme file should be named</source>
          <target state="translated">A Custom theme file should be named</target>
        </trans-unit>
        <trans-unit id="97e76d477ef6ece585bf0e8e626dfbf9ff92f225" translate="yes" xml:space="preserve">
          <source>A GNU (glibc-based) system with a FreeBSD kernel.</source>
          <target state="translated">A GNU (glibc-based) system with a FreeBSD kernel.</target>
        </trans-unit>
        <trans-unit id="88a0c01d860cf991a4d23f7a207dd587f005e263" translate="yes" xml:space="preserve">
          <source>A GNU/Linux system&amp;mdash;that is, a variant GNU system, using the Linux kernel. (These systems are the ones people often call &amp;ldquo;Linux&amp;rdquo;, but actually Linux is just the kernel, not the whole system.)</source>
          <target state="translated">A GNU/Linux system&amp;mdash;that is, a variant GNU system, using the Linux kernel. (These systems are the ones people often call &amp;ldquo;Linux&amp;rdquo;, but actually Linux is just the kernel, not the whole system.)</target>
        </trans-unit>
        <trans-unit id="739c3877cd46882f2bf1e29532388af125b773c3" translate="yes" xml:space="preserve">
          <source>A Lisp &lt;em&gt;object&lt;/em&gt; is a piece of data used and manipulated by Lisp programs. For our purposes, a &lt;em&gt;type&lt;/em&gt; or &lt;em&gt;data type&lt;/em&gt; is a set of possible objects.</source>
          <target state="translated">A Lisp &lt;em&gt;object&lt;/em&gt; is a piece of data used and manipulated by Lisp programs. For our purposes, a &lt;em&gt;type&lt;/em&gt; or &lt;em&gt;data type&lt;/em&gt; is a set of possible objects.</target>
        </trans-unit>
        <trans-unit id="0ede65fe49eec2a820dcd37ce90bed61992a08df" translate="yes" xml:space="preserve">
          <source>A Lisp buffer object contains numerous pieces of information. Some of this information is directly accessible to the programmer through variables, while other information is accessible only through special-purpose functions. For example, the visited file name is directly accessible through a variable, while the value of point is accessible only through a primitive function.</source>
          <target state="translated">A Lisp buffer object contains numerous pieces of information. Some of this information is directly accessible to the programmer through variables, while other information is accessible only through special-purpose functions. For example, the visited file name is directly accessible through a variable, while the value of point is accessible only through a primitive function.</target>
        </trans-unit>
        <trans-unit id="0cb2ab52c23e67cc9d47f5aaa484af8daf209b86" translate="yes" xml:space="preserve">
          <source>A Lisp expression that you can evaluate is called a &lt;em&gt;form&lt;/em&gt;. Evaluating a form always produces a result, which is a Lisp object. In the examples in this manual, this is indicated with &amp;lsquo;</source>
          <target state="translated">A Lisp expression that you can evaluate is called a &lt;em&gt;form&lt;/em&gt;. Evaluating a form always produces a result, which is a Lisp object. In the examples in this manual, this is indicated with &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="44b74e4a3fac58ee6b57c96a4dd7b2d0e1cbf309" translate="yes" xml:space="preserve">
          <source>A Lisp form&amp;rsquo;s value. &amp;lsquo;</source>
          <target state="translated">A Lisp form&amp;rsquo;s value. &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="636bf0c1ed1567a512c03ae0afbe1fe64b2f9b82" translate="yes" xml:space="preserve">
          <source>A Lisp function called whenever the state of the process changes.</source>
          <target state="translated">A Lisp function called whenever the state of the process changes.</target>
        </trans-unit>
        <trans-unit id="7e57febc310f2002b2d190a0e3bcc2fe01e7ac4d" translate="yes" xml:space="preserve">
          <source>A Lisp function used to accept output from the process.</source>
          <target state="translated">A Lisp function used to accept output from the process.</target>
        </trans-unit>
        <trans-unit id="4952821b0ad1ac9117ff033a72abb999f4aaedb8" translate="yes" xml:space="preserve">
          <source>A Lisp macro object is a list whose &lt;small&gt;CAR&lt;/small&gt; is &lt;code&gt;macro&lt;/code&gt;, and whose &lt;small&gt;CDR&lt;/small&gt; is a function. Expansion of the macro works by applying the function (with &lt;code&gt;apply&lt;/code&gt;) to the list of &lt;em&gt;unevaluated&lt;/em&gt; arguments from the macro call.</source>
          <target state="translated">A Lisp macro object is a list whose &lt;small&gt;CAR&lt;/small&gt; is &lt;code&gt;macro&lt;/code&gt; , and whose &lt;small&gt;CDR&lt;/small&gt; is a function. Expansion of the macro works by applying the function (with &lt;code&gt;apply&lt;/code&gt; ) to the list of &lt;em&gt;unevaluated&lt;/em&gt; arguments from the macro call.</target>
        </trans-unit>
        <trans-unit id="676c0d12c6662696653cb17b87b78c6a68f660fb" translate="yes" xml:space="preserve">
          <source>A Lisp object that is intended for evaluation is called a &lt;em&gt;form&lt;/em&gt; or &lt;em&gt;expression&lt;/em&gt;&lt;a href=&quot;#FOOT6&quot; name=&quot;DOCF6&quot;&gt;&lt;sup&gt;6&lt;/sup&gt;&lt;/a&gt;. The fact that forms are data objects and not merely text is one of the fundamental differences between Lisp-like languages and typical programming languages. Any object can be evaluated, but in practice only numbers, symbols, lists and strings are evaluated very often.</source>
          <target state="translated">A Lisp object that is intended for evaluation is called a &lt;em&gt;form&lt;/em&gt; or &lt;em&gt;expression&lt;/em&gt;&lt;a href=&quot;#FOOT6&quot; name=&quot;DOCF6&quot;&gt;&lt;sup&gt;6&lt;/sup&gt;&lt;/a&gt;. The fact that forms are data objects and not merely text is one of the fundamental differences between Lisp-like languages and typical programming languages. Any object can be evaluated, but in practice only numbers, symbols, lists and strings are evaluated very often.</target>
        </trans-unit>
        <trans-unit id="f33adea499465f70fa576e194f71f0ef7924e620" translate="yes" xml:space="preserve">
          <source>A Lisp object that is intended to be evaluated is called a &lt;em&gt;form&lt;/em&gt; (or an &lt;em&gt;expression&lt;/em&gt;). How Emacs evaluates a form depends on its data type. Emacs has three different kinds of form that are evaluated differently: symbols, lists, and all other types. This section describes all three kinds, one by one, starting with the other types, which are self-evaluating forms.</source>
          <target state="translated">A Lisp object that is intended to be evaluated is called a &lt;em&gt;form&lt;/em&gt; (or an &lt;em&gt;expression&lt;/em&gt;). How Emacs evaluates a form depends on its data type. Emacs has three different kinds of form that are evaluated differently: symbols, lists, and all other types. This section describes all three kinds, one by one, starting with the other types, which are self-evaluating forms.</target>
        </trans-unit>
        <trans-unit id="61232e4f0cd79d42e285f0ee5d7b7c9f443664ba" translate="yes" xml:space="preserve">
          <source>A Lisp object, specified with its read syntax, terminated with a</source>
          <target state="translated">A Lisp object, specified with its read syntax, terminated with a</target>
        </trans-unit>
        <trans-unit id="a7b12802b4f43521be72ce4a8abec084c2492675" translate="yes" xml:space="preserve">
          <source>A Lisp program can pop up a menu so that the user can choose an alternative with the mouse. On a text terminal, if the mouse is not available, the user can choose an alternative using the keyboard motion keys&amp;mdash;</source>
          <target state="translated">A Lisp program can pop up a menu so that the user can choose an alternative with the mouse. On a text terminal, if the mouse is not available, the user can choose an alternative using the keyboard motion keys&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="7f6a3034ff2fce3c5efc4de7ca7afdcbe18b3a20" translate="yes" xml:space="preserve">
          <source>A Lisp program can specify to which thread a process is to be locked, or instruct Emacs to unlock a process, in which case its output can be processed by any thread. Only a single thread will wait for output from a given process at one time&amp;mdash;once one thread begins waiting for output, the process is temporarily locked until &lt;code&gt;accept-process-output&lt;/code&gt; or &lt;code&gt;sit-for&lt;/code&gt; returns.</source>
          <target state="translated">A Lisp program can specify to which thread a process is to be locked, or instruct Emacs to unlock a process, in which case its output can be processed by any thread. Only a single thread will wait for output from a given process at one time&amp;mdash;once one thread begins waiting for output, the process is temporarily locked until &lt;code&gt;accept-process-output&lt;/code&gt; or &lt;code&gt;sit-for&lt;/code&gt; returns.</target>
        </trans-unit>
        <trans-unit id="6bea1c4b3a46894d0953d9ddc50f1e289ea694d1" translate="yes" xml:space="preserve">
          <source>A Lisp program consists of a set of &lt;em&gt;expressions&lt;/em&gt;, or &lt;em&gt;forms&lt;/em&gt; (see &lt;a href=&quot;forms#Forms&quot;&gt;Forms&lt;/a&gt;). We control the order of execution of these forms by enclosing them in &lt;em&gt;control structures&lt;/em&gt;. Control structures are special forms which control when, whether, or how many times to execute the forms they contain.</source>
          <target state="translated">A Lisp program consists of a set of &lt;em&gt;expressions&lt;/em&gt;, or &lt;em&gt;forms&lt;/em&gt; (see &lt;a href=&quot;forms#Forms&quot;&gt;Forms&lt;/a&gt;). We control the order of execution of these forms by enclosing them in &lt;em&gt;control structures&lt;/em&gt;. Control structures are special forms which control when, whether, or how many times to execute the forms they contain.</target>
        </trans-unit>
        <trans-unit id="49b243589d051decd3fee204d71246c9c4049473" translate="yes" xml:space="preserve">
          <source>A Lisp program is composed mainly of Lisp functions. This chapter explains what functions are, how they accept arguments, and how to define them.</source>
          <target state="translated">A Lisp program is composed mainly of Lisp functions. This chapter explains what functions are, how they accept arguments, and how to define them.</target>
        </trans-unit>
        <trans-unit id="6f6b3875c43f74196130caa79a2aae800b9e504b" translate="yes" xml:space="preserve">
          <source>A Lisp string that names the buffer. It is guaranteed to be unique. See &lt;a href=&quot;buffer-names#Buffer-Names&quot;&gt;Buffer Names&lt;/a&gt;. This and the following fields have their names in the C struct definition end in a &lt;code&gt;_&lt;/code&gt; to indicate that they should not be accessed directly, but via the &lt;code&gt;BVAR&lt;/code&gt; macro, like this:</source>
          <target state="translated">A Lisp string that names the buffer. It is guaranteed to be unique. See &lt;a href=&quot;buffer-names#Buffer-Names&quot;&gt;Buffer Names&lt;/a&gt;. This and the following fields have their names in the C struct definition end in a &lt;code&gt;_&lt;/code&gt; to indicate that they should not be accessed directly, but via the &lt;code&gt;BVAR&lt;/code&gt; macro, like this:</target>
        </trans-unit>
        <trans-unit id="0dba94b2c27dc16f1ce1573a3fa87d12c74ef063" translate="yes" xml:space="preserve">
          <source>A Lisp string, the name of the process.</source>
          <target state="translated">A Lisp string, the name of the process.</target>
        </trans-unit>
        <trans-unit id="3830b5730347a3887344295754013d799c21d823" translate="yes" xml:space="preserve">
          <source>A Sample Function Description</source>
          <target state="translated">샘플 기능 설명</target>
        </trans-unit>
        <trans-unit id="47688b6f0ccbc8ce6a610200f12d5466c7935f4e" translate="yes" xml:space="preserve">
          <source>A Sample Variable Description</source>
          <target state="translated">A Sample Variable Description</target>
        </trans-unit>
        <trans-unit id="e5a96014bd90b149f5c06b869ab3dedf6896aa07" translate="yes" xml:space="preserve">
          <source>A Simple Example of a Macro</source>
          <target state="translated">A Simple Example of a Macro</target>
        </trans-unit>
        <trans-unit id="6c6aa1370f28727d54174b46840756ee4eca1fca" translate="yes" xml:space="preserve">
          <source>A Simple Lambda Expression Example</source>
          <target state="translated">A Simple Lambda Expression Example</target>
        </trans-unit>
        <trans-unit id="fe1639cfe4a0a40f746ce0000ee16f6eaea5c41a" translate="yes" xml:space="preserve">
          <source>A backquote-style pattern has the form &lt;code&gt;`&lt;var&gt;qpat&lt;/var&gt;&lt;/code&gt; where &lt;var&gt;qpat&lt;/var&gt; can have the following forms:</source>
          <target state="translated">A backquote-style pattern has the form &lt;code&gt;`&lt;var&gt;qpat&lt;/var&gt;&lt;/code&gt; where &lt;var&gt;qpat&lt;/var&gt; can have the following forms:</target>
        </trans-unit>
        <trans-unit id="e09b92e1e2035037489b57b2cf5ea9ec97ecb050" translate="yes" xml:space="preserve">
          <source>A backslash is allowed, and harmless, preceding any character without a special escape meaning; thus, &amp;lsquo;</source>
          <target state="translated">A backslash is allowed, and harmless, preceding any character without a special escape meaning; thus, &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="9fb9879aefa3149183ad26133a7129b3b1a9107e" translate="yes" xml:space="preserve">
          <source>A basic example.</source>
          <target state="translated">A basic example.</target>
        </trans-unit>
        <trans-unit id="a9f489f58b662fe1c92a44259f90e291f9de6363" translate="yes" xml:space="preserve">
          <source>A blank line is defined as a line containing only tabs and spaces.</source>
          <target state="translated">A blank line is defined as a line containing only tabs and spaces.</target>
        </trans-unit>
        <trans-unit id="524e4a4511120df2884e060fd767b7b40a21308e" translate="yes" xml:space="preserve">
          <source>A bool-vector is much like a vector, except that it stores only the values &lt;code&gt;t&lt;/code&gt; and &lt;code&gt;nil&lt;/code&gt;. If you try to store any non-&lt;code&gt;nil&lt;/code&gt; value into an element of the bool-vector, the effect is to store &lt;code&gt;t&lt;/code&gt; there. As with all arrays, bool-vector indices start from 0, and the length cannot be changed once the bool-vector is created. Bool-vectors are constants when evaluated.</source>
          <target state="translated">A bool-vector is much like a vector, except that it stores only the values &lt;code&gt;t&lt;/code&gt; and &lt;code&gt;nil&lt;/code&gt; . If you try to store any non- &lt;code&gt;nil&lt;/code&gt; value into an element of the bool-vector, the effect is to store &lt;code&gt;t&lt;/code&gt; there. As with all arrays, bool-vector indices start from 0, and the length cannot be changed once the bool-vector is created. Bool-vectors are constants when evaluated.</target>
        </trans-unit>
        <trans-unit id="814538ef1618885380945f59cead64ad79435a60" translate="yes" xml:space="preserve">
          <source>A buffer can have blank areas called &lt;em&gt;display margins&lt;/em&gt; on the left and on the right. Ordinary text never appears in these areas, but you can put things into the display margins using the &lt;code&gt;display&lt;/code&gt; property. There is currently no way to make text or images in the margin mouse-sensitive.</source>
          <target state="translated">A buffer can have blank areas called &lt;em&gt;display margins&lt;/em&gt; on the left and on the right. Ordinary text never appears in these areas, but you can put things into the display margins using the &lt;code&gt;display&lt;/code&gt; property. There is currently no way to make text or images in the margin mouse-sensitive.</target>
        </trans-unit>
        <trans-unit id="dffb10f2e97287560c7112dc2419ba6c8e6575dc" translate="yes" xml:space="preserve">
          <source>A buffer is &lt;em&gt;modified&lt;/em&gt; if it needs to be saved.</source>
          <target state="translated">A buffer is &lt;em&gt;modified&lt;/em&gt; if it needs to be saved.</target>
        </trans-unit>
        <trans-unit id="01af951dc229e9603e576b0ef91e681538e5dd80" translate="yes" xml:space="preserve">
          <source>A buffer may be &lt;em&gt;indirect&lt;/em&gt;, which means it shares the text of another buffer, but presents it differently. See &lt;a href=&quot;indirect-buffers#Indirect-Buffers&quot;&gt;Indirect Buffers&lt;/a&gt;.</source>
          <target state="translated">A buffer may be &lt;em&gt;indirect&lt;/em&gt;, which means it shares the text of another buffer, but presents it differently. See &lt;a href=&quot;indirect-buffers#Indirect-Buffers&quot;&gt;Indirect Buffers&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="0d424b315e8ae166a8d74702d3afc5f437295bda" translate="yes" xml:space="preserve">
          <source>A buffer name. The buffer need not exist. By default, uses the name of a recently used buffer other than the current buffer. Completion, Default, Prompt.</source>
          <target state="translated">A buffer name. The buffer need not exist. By default, uses the name of a recently used buffer other than the current buffer. Completion, Default, Prompt.</target>
        </trans-unit>
        <trans-unit id="4eec8b38136453dbf281b73846ca4718f3fd5704" translate="yes" xml:space="preserve">
          <source>A buffer visiting a write-protected file is normally read-only.</source>
          <target state="translated">A buffer visiting a write-protected file is normally read-only.</target>
        </trans-unit>
        <trans-unit id="b3bbdf90f180c663bc226ff02e52a4cdd65396f4" translate="yes" xml:space="preserve">
          <source>A buffer-local variable cannot be made terminal-local (see &lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;Multiple Terminals&lt;/a&gt;).</source>
          <target state="translated">A buffer-local variable cannot be made terminal-local (see &lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;Multiple Terminals&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="ddf11dd51e081a083899b25a13468ba1a67d1221" translate="yes" xml:space="preserve">
          <source>A buffer-local variable has a buffer-local binding associated with a particular buffer. The binding is in effect when that buffer is current; otherwise, it is not in effect. If you set the variable while a buffer-local binding is in effect, the new value goes in that binding, so its other bindings are unchanged. This means that the change is visible only in the buffer where you made it.</source>
          <target state="translated">A buffer-local variable has a buffer-local binding associated with a particular buffer. The binding is in effect when that buffer is current; otherwise, it is not in effect. If you set the variable while a buffer-local binding is in effect, the new value goes in that binding, so its other bindings are unchanged. This means that the change is visible only in the buffer where you made it.</target>
        </trans-unit>
        <trans-unit id="0ea3f6b24d8b103d0443c8cc30b8a2924a186913" translate="yes" xml:space="preserve">
          <source>A buffer-local variable is &lt;em&gt;permanent&lt;/em&gt; if the variable name (a symbol) has a &lt;code&gt;permanent-local&lt;/code&gt; property that is non-&lt;code&gt;nil&lt;/code&gt;. Such variables are unaffected by &lt;code&gt;kill-all-local-variables&lt;/code&gt;, and their local bindings are therefore not cleared by changing major modes. Permanent locals are appropriate for data pertaining to where the file came from or how to save it, rather than with how to edit the contents.</source>
          <target state="translated">A buffer-local variable is &lt;em&gt;permanent&lt;/em&gt; if the variable name (a symbol) has a &lt;code&gt;permanent-local&lt;/code&gt; property that is non- &lt;code&gt;nil&lt;/code&gt; . Such variables are unaffected by &lt;code&gt;kill-all-local-variables&lt;/code&gt; , and their local bindings are therefore not cleared by changing major modes. Permanent locals are appropriate for data pertaining to where the file came from or how to save it, rather than with how to edit the contents.</target>
        </trans-unit>
        <trans-unit id="82e1d9061b15d192cfad42d3517641069e30a971" translate="yes" xml:space="preserve">
          <source>A button is essentially a set of text or overlay properties, attached to a stretch of text in a buffer. These properties are called &lt;em&gt;button properties&lt;/em&gt;. One of these properties, the &lt;em&gt;action property&lt;/em&gt;, specifies a function which is called when the user invokes the button using the keyboard or the mouse. The action function may examine the button and use its other properties as desired.</source>
          <target state="translated">A button is essentially a set of text or overlay properties, attached to a stretch of text in a buffer. These properties are called &lt;em&gt;button properties&lt;/em&gt;. One of these properties, the &lt;em&gt;action property&lt;/em&gt;, specifies a function which is called when the user invokes the button using the keyboard or the mouse. The action function may examine the button and use its other properties as desired.</target>
        </trans-unit>
        <trans-unit id="a12cd4fc77bf2095be17614fa62ca6d977e907e0" translate="yes" xml:space="preserve">
          <source>A button was pushed and not yet released.</source>
          <target state="translated">A button was pushed and not yet released.</target>
        </trans-unit>
        <trans-unit id="e63588ea815dd6fb8cf0feb02e36a33cea09758c" translate="yes" xml:space="preserve">
          <source>A byte-compiled function is not as efficient as a primitive function written in C, but runs much faster than the version written in Lisp. Here is an example:</source>
          <target state="translated">A byte-compiled function is not as efficient as a primitive function written in C, but runs much faster than the version written in Lisp. Here is an example:</target>
        </trans-unit>
        <trans-unit id="15e5cdcc2c4c2bf479874e2a6a0a6720464a787a" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;clear-this-command-keys&lt;/code&gt; (see &lt;a href=&quot;command-loop-info#Command-Loop-Info&quot;&gt;Command Loop Info&lt;/a&gt;) causes this function to return an empty vector immediately afterward.</source>
          <target state="translated">A call to &lt;code&gt;clear-this-command-keys&lt;/code&gt; (see &lt;a href=&quot;command-loop-info#Command-Loop-Info&quot;&gt;Command Loop Info&lt;/a&gt;) causes this function to return an empty vector immediately afterward.</target>
        </trans-unit>
        <trans-unit id="07bdcc88f0557d24553af69e03106b6926fb38fe" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;libxml-parse-html-region&lt;/code&gt; returns this</source>
          <target state="translated">A call to &lt;code&gt;libxml-parse-html-region&lt;/code&gt; returns this</target>
        </trans-unit>
        <trans-unit id="9ae4251fb7c25ebcbed3100b7db0002d95f465d8" translate="yes" xml:space="preserve">
          <source>A call to any of the following Emacs-specific functions:</source>
          <target state="translated">A call to any of the following Emacs-specific functions:</target>
        </trans-unit>
        <trans-unit id="3d83bc6e0965f055bd5764ea7054322f45bfafdd" translate="yes" xml:space="preserve">
          <source>A call to any of the following standard Lisp functions:</source>
          <target state="translated">A call to any of the following standard Lisp functions:</target>
        </trans-unit>
        <trans-unit id="7635e7ab6b3b4e2b3b227dcbb99a41ebeab9c463" translate="yes" xml:space="preserve">
          <source>A call to the function requires one actual argument for each of the &lt;var&gt;required-vars&lt;/var&gt;. There may be actual arguments for zero or more of the &lt;var&gt;optional-vars&lt;/var&gt;, and there cannot be any actual arguments beyond that unless the lambda list uses &lt;code&gt;&amp;amp;rest&lt;/code&gt;. In that case, there may be any number of extra actual arguments.</source>
          <target state="translated">A call to the function requires one actual argument for each of the &lt;var&gt;required-vars&lt;/var&gt; . There may be actual arguments for zero or more of the &lt;var&gt;optional-vars&lt;/var&gt; , and there cannot be any actual arguments beyond that unless the lambda list uses &lt;code&gt;&amp;amp;rest&lt;/code&gt; . In that case, there may be any number of extra actual arguments.</target>
        </trans-unit>
        <trans-unit id="67fa1aeb6732d6bf7e24ec11ac66725cadaddf46" translate="yes" xml:space="preserve">
          <source>A case table is a char-table (see &lt;a href=&quot;char_002dtables#Char_002dTables&quot;&gt;Char-Tables&lt;/a&gt;) whose subtype is &lt;code&gt;case-table&lt;/code&gt;. This char-table maps each character into the corresponding lower case character. It has three extra slots, which hold related tables:</source>
          <target state="translated">A case table is a char-table (see &lt;a href=&quot;char_002dtables#Char_002dTables&quot;&gt;Char-Tables&lt;/a&gt;) whose subtype is &lt;code&gt;case-table&lt;/code&gt; . This char-table maps each character into the corresponding lower case character. It has three extra slots, which hold related tables:</target>
        </trans-unit>
        <trans-unit id="2b5b379014c462345470b8abd71e3a1735572b62" translate="yes" xml:space="preserve">
          <source>A certain amount of Common Lisp emulation is available via the</source>
          <target state="translated">A certain amount of Common Lisp emulation is available via the</target>
        </trans-unit>
        <trans-unit id="a4a5415d16ff7ebd6665d307ffdd64fbd966a291" translate="yes" xml:space="preserve">
          <source>A char table (see &lt;a href=&quot;char_002dtable-type#Char_002dTable-Type&quot;&gt;Char-Table Type&lt;/a&gt;).</source>
          <target state="translated">A char table (see &lt;a href=&quot;char_002dtable-type#Char_002dTable-Type&quot;&gt;Char-Table Type&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="ecaf5c129d18b5a22edcf1fb273c1fdf8a52213c" translate="yes" xml:space="preserve">
          <source>A char table of characters which invoke &lt;code&gt;auto-fill-function&lt;/code&gt; when self-inserted&amp;mdash;space and newline in most language environments. They have an entry &lt;code&gt;t&lt;/code&gt; in the table.</source>
          <target state="translated">자체 삽입시 &lt;code&gt;auto-fill-function&lt;/code&gt; 을 호출하는 문자의 char 테이블 ( 대부분의 언어 환경에서 공백 및 줄 바꿈). 테이블에 항목 &lt;code&gt;t&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4331eab8b48d68401034877de0a7e395a6b7a91" translate="yes" xml:space="preserve">
          <source>A char-table can also have a &lt;em&gt;default value&lt;/em&gt;. If so, then &lt;code&gt;(aref &lt;var&gt;char-table&lt;/var&gt; &lt;var&gt;c&lt;/var&gt;)&lt;/code&gt; returns the default value whenever the char-table does not specify any other non-&lt;code&gt;nil&lt;/code&gt; value.</source>
          <target state="translated">char-table은 &lt;em&gt;기본값을&lt;/em&gt; 가질 수도 있습니다 . 그렇다면 &lt;code&gt;(aref &lt;var&gt;char-table&lt;/var&gt; &lt;var&gt;c&lt;/var&gt;)&lt;/code&gt; 는 char-table이 &lt;code&gt;nil&lt;/code&gt; 이 아닌 다른 값을 지정하지 않을 때마다 기본값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="1fb76fc397b52b86e435eb63aca61212ac723523" translate="yes" xml:space="preserve">
          <source>A char-table can have a &lt;em&gt;parent&lt;/em&gt;, which is another char-table. If it does, then whenever the char-table specifies &lt;code&gt;nil&lt;/code&gt; for a particular character &lt;var&gt;c&lt;/var&gt;, it inherits the value specified in the parent. In other words, &lt;code&gt;(aref &lt;var&gt;char-table&lt;/var&gt; &lt;var&gt;c&lt;/var&gt;)&lt;/code&gt; returns the value from the parent of &lt;var&gt;char-table&lt;/var&gt; if &lt;var&gt;char-table&lt;/var&gt; itself specifies &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">char-table 은 또 다른 char-table 인 &lt;em&gt;parent를&lt;/em&gt; 가질 수 있습니다 . 그렇다면 char-table 이 특정 문자 &lt;var&gt;c&lt;/var&gt; 에 대해 &lt;code&gt;nil&lt;/code&gt; 을 지정할 때마다 부모에 지정된 값을 상속합니다. 즉, &lt;code&gt;(aref &lt;var&gt;char-table&lt;/var&gt; &lt;var&gt;c&lt;/var&gt;)&lt;/code&gt; &lt;var&gt;char-table&lt;/var&gt; &lt;var&gt;c&lt;/var&gt; ) 의 부모 값을 리턴 &lt;var&gt;char-table&lt;/var&gt; 경우 &lt;var&gt;char-table&lt;/var&gt; 자체 지정 &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28812e862b6fe08ebd8034ca275ca9cc0b34ae20" translate="yes" xml:space="preserve">
          <source>A char-table can specify an element value for a single character code; it can also specify a value for an entire character set.</source>
          <target state="translated">문자 테이블은 단일 문자 코드에 대한 요소 값을 지정할 수 있습니다. 전체 문자 세트에 대한 값을 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b405f04567fba4621b52257941c3540fa92759c" translate="yes" xml:space="preserve">
          <source>A char-table is much like a vector, except that it is indexed by character codes. Any valid character code, without modifiers, can be used as an index in a char-table. You can access a char-table&amp;rsquo;s elements with &lt;code&gt;aref&lt;/code&gt; and &lt;code&gt;aset&lt;/code&gt;, as with any array. In addition, a char-table can have &lt;em&gt;extra slots&lt;/em&gt; to hold additional data not associated with particular character codes. Like vectors, char-tables are constants when evaluated, and can hold elements of any type.</source>
          <target state="translated">문자 테이블은 문자 코드로 색인된다는 점을 제외하면 벡터와 매우 유사합니다. 수정자가없는 유효한 문자 코드는 문자 테이블의 색인으로 사용할 수 있습니다. 모든 배열 과 &lt;code&gt;aset&lt;/code&gt; &lt;code&gt;aref&lt;/code&gt; 및 aset을 사용하여 char-table의 요소에 액세스 할 수 있습니다 . 또한 문자 테이블 에는 특정 문자 코드와 관련이없는 추가 데이터를 보관하기위한 추가 &lt;em&gt;슬롯&lt;/em&gt; 이있을 수 있습니다 . 벡터와 마찬가지로 char-table은 평가 될 때 상수이며 모든 유형의 요소를 보유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9d00bdec6ad25e61b5900d9855da9f05fa84630" translate="yes" xml:space="preserve">
          <source>A character (see &lt;a href=&quot;basic-char-syntax#Basic-Char-Syntax&quot;&gt;Basic Char Syntax&lt;/a&gt;).</source>
          <target state="translated">문자 ( &lt;a href=&quot;basic-char-syntax#Basic-Char-Syntax&quot;&gt;기본 문자 구문&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="5a9de7794a633ca12c84e901f3c32bafb6a9360d" translate="yes" xml:space="preserve">
          <source>A character alternative can also specify named character classes (see &lt;a href=&quot;char-classes#Char-Classes&quot;&gt;Char Classes&lt;/a&gt;). This is a POSIX feature. For example, &amp;lsquo;</source>
          <target state="translated">대체 문자는 명명 된 문자 클래스를 지정할 수도 있습니다 ( &lt;a href=&quot;char-classes#Char-Classes&quot;&gt;Char 클래스&lt;/a&gt; 참조 ). 이것은 POSIX 기능입니다. 예 : '</target>
        </trans-unit>
        <trans-unit id="5852ab82906acd43fcce8f1e9319776366ed12e5" translate="yes" xml:space="preserve">
          <source>A character is a Lisp object which represents a single character of text. In Emacs Lisp, characters are simply integers; whether an integer is a character or not is determined only by how it is used. See &lt;a href=&quot;character-codes#Character-Codes&quot;&gt;Character Codes&lt;/a&gt;, for details about character representation in Emacs.</source>
          <target state="translated">문자는 텍스트의 단일 문자를 나타내는 Lisp 객체입니다. Emacs Lisp에서 문자는 단순히 정수입니다. 정수가 문자인지 아닌지는 사용 방법에 의해서만 결정됩니다. Emacs의 문자 표현에 대한 자세한 내용은 문자 &lt;a href=&quot;character-codes#Character-Codes&quot;&gt;코드를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9dfbff13dd844666d887c5ab6faa1df6fbe6ee51" translate="yes" xml:space="preserve">
          <source>A character is invisible if its &lt;code&gt;invisible&lt;/code&gt; property is non-&lt;code&gt;nil&lt;/code&gt;. This is the default.</source>
          <target state="translated">&lt;code&gt;invisible&lt;/code&gt; 속성이 &lt;code&gt;nil&lt;/code&gt; 이 아니면 캐릭터는 보이지 않습니다 . 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="47f28363d88b6d425d64a18f02bda09273e7eca4" translate="yes" xml:space="preserve">
          <source>A character is invisible if its &lt;code&gt;invisible&lt;/code&gt; property value is &lt;var&gt;atom&lt;/var&gt; or if it is a list with &lt;var&gt;atom&lt;/var&gt; as a member; comparison is done with &lt;code&gt;eq&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;invisible&lt;/code&gt; 속성 값이 &lt;var&gt;atom&lt;/var&gt; 이거나 &lt;var&gt;atom&lt;/var&gt; 이 멤버로 포함 된 목록 인 경우 문자는 보이지 않습니다 . 비교는 &lt;code&gt;eq&lt;/code&gt; 로 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="4c2caeed893ef6aef55ca838c3839fe9fc2a1038" translate="yes" xml:space="preserve">
          <source>A character is invisible if its &lt;code&gt;invisible&lt;/code&gt; property value is &lt;var&gt;atom&lt;/var&gt; or if it is a list with &lt;var&gt;atom&lt;/var&gt; as a member; comparison is done with &lt;code&gt;eq&lt;/code&gt;. Moreover, a sequence of such characters displays as an ellipsis.</source>
          <target state="translated">&lt;code&gt;invisible&lt;/code&gt; 속성 값이 &lt;var&gt;atom&lt;/var&gt; 이거나 &lt;var&gt;atom&lt;/var&gt; 이 멤버로 포함 된 목록 인 경우 문자는 보이지 않습니다 . 비교는 &lt;code&gt;eq&lt;/code&gt; 로 수행됩니다 . 또한 이러한 문자 시퀀스는 줄임표로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="b5cebcadf9e0f5094b601d80021f925480c3f78b" translate="yes" xml:space="preserve">
          <source>A character&amp;rsquo;s syntax controls how it changes the state of the parser, rather than describing the state itself. For example, a string delimiter character toggles the parser state between in-string and in-code, but the syntax of characters does not directly say whether they are inside a string. For example (note that 15 is the syntax code for generic string delimiters),</source>
          <target state="translated">문자의 구문은 상태 자체를 설명하는 대신 파서의 상태를 변경하는 방법을 제어합니다. 예를 들어, 문자열 구분 문자는 문자열 내부와 코드 내부 사이에서 구문 분석기 상태를 전환하지만 문자 구문은 문자열 내부에 있는지 여부를 직접 말하지 않습니다. 예를 들어 (15는 일반 문자열 구분 기호에 대한 구문 코드입니다),</target>
        </trans-unit>
        <trans-unit id="995e1986dbee8019705c2c18b9dabf464763be2f" translate="yes" xml:space="preserve">
          <source>A character. The cursor does not move into the echo area. Prompt.</source>
          <target state="translated">캐릭터. 커서가 에코 영역으로 이동하지 않습니다. 신속한.</target>
        </trans-unit>
        <trans-unit id="9af6e20f678a486779e8667c74ae3962238033bd" translate="yes" xml:space="preserve">
          <source>A circle is a cons &lt;code&gt;(circle . ((&lt;var&gt;x0&lt;/var&gt; . &lt;var&gt;y0&lt;/var&gt;) . &lt;var&gt;r&lt;/var&gt;))&lt;/code&gt; which specifies the center and the radius of the circle; &lt;var&gt;r&lt;/var&gt; may be a float or integer.</source>
          <target state="translated">원은 &lt;code&gt;(circle . ((&lt;var&gt;x0&lt;/var&gt; . &lt;var&gt;y0&lt;/var&gt;) . &lt;var&gt;r&lt;/var&gt;))&lt;/code&gt; 의 중심과 반지름을 지정 하는 단점 (circle. (( x0 . y0 ). r )) 입니다. &lt;var&gt;r&lt;/var&gt; 은 실수 또는 정수일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50c12ff3802dbf249cfca7012b5760bea0a96b84" translate="yes" xml:space="preserve">
          <source>A clause may also look like this:</source>
          <target state="translated">절은 다음과 같이 보일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a41891558abee07449b02af72c74eac4e6837f1" translate="yes" xml:space="preserve">
          <source>A closure is a function that also carries a record of the lexical environment that existed when the function was defined. When it is invoked, any lexical variable references within its definition use the retained lexical environment. In all other respects, closures behave much like ordinary functions; in particular, they can be called in the same way as ordinary functions.</source>
          <target state="translated">클로저는 함수가 정의되었을 때 존재했던 어휘 환경의 기록을 전달하는 함수입니다. 호출 될 때 정의 내의 모든 어휘 변수 참조는 보유 된 어휘 환경을 사용합니다. 다른 모든 측면에서 클로저는 일반적인 기능과 매우 유사하게 작동합니다. 특히 일반 함수와 같은 방식으로 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce25d22da839fc3f074d57a6f7f3079b96e65780" translate="yes" xml:space="preserve">
          <source>A coding system name (a symbol)&amp;mdash;but only if this command has a prefix argument. With no prefix argument, &amp;lsquo;</source>
          <target state="translated">코딩 시스템 이름 (기호) &amp;mdash;이 명령에 접두사 인수가있는 경우에만 해당됩니다. 접두사 인수없이 '</target>
        </trans-unit>
        <trans-unit id="32f193f6c59efaee4ac9718360d54b11c34fae18" translate="yes" xml:space="preserve">
          <source>A coding system name (a symbol). If the user enters null input, the argument value is &lt;code&gt;nil&lt;/code&gt;. See &lt;a href=&quot;coding-systems#Coding-Systems&quot;&gt;Coding Systems&lt;/a&gt;. Completion, Existing, Prompt.</source>
          <target state="translated">코딩 시스템 이름 (기호). 사용자가 null 입력을 입력하면 인수 값은 &lt;code&gt;nil&lt;/code&gt; 입니다. &lt;a href=&quot;coding-systems#Coding-Systems&quot;&gt;코딩 시스템을&lt;/a&gt; 참고하십시오 . 완료, 기존, 프롬프트.</target>
        </trans-unit>
        <trans-unit id="7ae6346452476d84451bf83887065f34142fef82" translate="yes" xml:space="preserve">
          <source>A color name is text (usually in a string) that specifies a color. Symbolic names such as &amp;lsquo;</source>
          <target state="translated">색상 이름은 색상을 지정하는 텍스트 (일반적으로 문자열)입니다. '와 같은 기호 이름</target>
        </trans-unit>
        <trans-unit id="861c8320a472767fcebf0b85b88c1e68f51e31fe" translate="yes" xml:space="preserve">
          <source>A command can inhibit this feature by setting the variable &lt;code&gt;disable-point-adjustment&lt;/code&gt;:</source>
          <target state="translated">명령은 &lt;code&gt;disable-point-adjustment&lt;/code&gt; 변수를 설정하여이 기능을 억제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9a1feab560a446fec5a5847d8874376ebf879270" translate="yes" xml:space="preserve">
          <source>A command may be called from Lisp programs like any other function, but then the caller supplies the arguments and &lt;var&gt;arg-descriptor&lt;/var&gt; has no effect.</source>
          <target state="translated">다른 함수와 마찬가지로 Lisp 프로그램에서 명령을 호출 할 수 있지만 호출자가 인수를 제공하고 &lt;var&gt;arg-descriptor&lt;/var&gt; 는 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3850fb8bc1d5cf519ee8cb5ce99fd65ff30af7c4" translate="yes" xml:space="preserve">
          <source>A command name (i.e., a symbol satisfying &lt;code&gt;commandp&lt;/code&gt;). Existing, Completion, Prompt.</source>
          <target state="translated">명령 이름 (즉, &lt;code&gt;commandp&lt;/code&gt; 를 충족하는 기호 ). 기존, 완료, 프롬프트.</target>
        </trans-unit>
        <trans-unit id="dea75281854f153f67a07289a0bf70599fd97be6" translate="yes" xml:space="preserve">
          <source>A command that calls &lt;code&gt;read-event&lt;/code&gt;, &lt;code&gt;read-char-choice&lt;/code&gt;, or &lt;code&gt;read-char&lt;/code&gt; probably should bind &lt;code&gt;help-form&lt;/code&gt; to a non-&lt;code&gt;nil&lt;/code&gt; expression while it does input. (The time when you should not do this is when</source>
          <target state="translated">&lt;code&gt;read-event&lt;/code&gt; , &lt;code&gt;read-char-choice&lt;/code&gt; 또는 &lt;code&gt;read-char&lt;/code&gt; 를 호출하는 명령 은 입력하는 동안 &lt;code&gt;help-form&lt;/code&gt; 을 &lt;code&gt;nil&lt;/code&gt; 이 아닌 표현식에 바인딩해야 합니다. (이렇게하면 안되는 시간은</target>
        </trans-unit>
        <trans-unit id="786b45a633125186b705ed0d2a068df264c8c114" translate="yes" xml:space="preserve">
          <source>A common idiom is to write a pattern starting with &lt;code&gt;and&lt;/code&gt;, with one or more &lt;var&gt;symbol&lt;/var&gt; sub-patterns providing bindings to the sub-patterns that follow (as well as to the body forms). For example, the following pattern matches single-digit integers.</source>
          <target state="translated">일반적인 관용구는 &lt;code&gt;and&lt;/code&gt; 시작하는 패턴을 작성하는 것 입니다. 하나 이상의 &lt;var&gt;symbol&lt;/var&gt; 하위 패턴은 다음 하위 패턴 (본문 형태)에 바인딩을 제공합니다. 예를 들어 다음 패턴은 한 자리 정수와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="f07ac0baafe3f998e934789a564c3d4c6b97953a" translate="yes" xml:space="preserve">
          <source>A common pitfall is to use a constant list as a non-last argument to &lt;code&gt;nconc&lt;/code&gt;. If you do this, the resulting behavior is undefined. It is possible that your program will change each time you run it! Here is what might happen (though this is not guaranteed to happen):</source>
          <target state="translated">일반적인 함정은 상수 목록을 &lt;code&gt;nconc&lt;/code&gt; 에 대한 마지막 인수가 아닌 인수로 사용하는 것 입니다. 이렇게하면 결과 동작이 정의되지 않습니다. 프로그램을 실행할 때마다 프로그램이 변경 될 수 있습니다! 일어날 수있는 일은 다음과 같습니다 (확실한 것은 아니지만) :</target>
        </trans-unit>
        <trans-unit id="759143f2b89b63d556200183aad1e79402e78704" translate="yes" xml:space="preserve">
          <source>A common type of warning issued by the byte compiler is for functions and variables that were used but not defined. Such warnings report the line number for the end of the file, not the locations where the missing functions or variables were used; to find these, you must search the file manually.</source>
          <target state="translated">바이트 컴파일러에서 발행하는 일반적인 경고 유형은 사용되었지만 정의되지 않은 함수 및 변수에 대한 것입니다. 이러한 경고는 누락 된 함수 나 변수가 사용 된 위치가 아니라 파일 끝의 줄 번호를보고합니다. 이를 찾으려면 파일을 수동으로 검색해야합니다.</target>
        </trans-unit>
        <trans-unit id="2a3d7f1b5d61b15dc9a45f1d4a60683c03b995b6" translate="yes" xml:space="preserve">
          <source>A common use of advice is for named functions and macros. You could just use &lt;code&gt;add-function&lt;/code&gt; as in:</source>
          <target state="translated">일반적으로 어드바이스의 용도는 명명 된 함수와 매크로입니다. 다음 과 같이 &lt;code&gt;add-function&lt;/code&gt; 을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="488edd78a5bd826f662b481ed78ba3fdff0e08c8" translate="yes" xml:space="preserve">
          <source>A complemented character alternative can match a newline, unless newline is mentioned as one of the characters not to match. This is in contrast to the handling of regexps in programs such as &lt;code&gt;grep&lt;/code&gt;.</source>
          <target state="translated">대체 문자는 개행 문자가 일치하지 않는 문자 중 하나로 언급되지 않는 한 개행 문자와 일치 할 수 있습니다. 이것은 &lt;code&gt;grep&lt;/code&gt; 과 같은 프로그램에서 정규 표현식을 처리하는 것과는 대조적 입니다.</target>
        </trans-unit>
        <trans-unit id="ba456a01d8ae77fc51576a8cf54c1d1c946d7a68" translate="yes" xml:space="preserve">
          <source>A compromise is to set it to a positive number. This means that cached values are used for that amount of seconds since they were cached. If a remote file is checked regularly, it might be a good idea to let-bind this variable to a value less than the time period between consecutive checks. For example:</source>
          <target state="translated">타협은 양수로 설정하는 것입니다. 즉, 캐시 된 값은 캐시 된 이후 해당 시간 (초) 동안 사용됩니다. 원격 파일이 정기적으로 검사되는 경우이 변수를 연속 검사 사이의 기간보다 짧은 값에 바인딩하는 것이 좋습니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="91e9b79d51b851733226729b9b7576c7c693a1aa" translate="yes" xml:space="preserve">
          <source>A condition variable is associated with a mutex and, conceptually, with some condition. For proper operation, the mutex must be acquired, and then a waiting thread must loop, testing the condition and waiting on the condition variable. For example:</source>
          <target state="translated">조건 변수는 뮤텍스 및 개념적으로 일부 조건과 연관됩니다. 적절한 작동을 위해 뮤텍스를 획득 한 다음 대기중인 스레드가 루프하여 조건을 테스트하고 조건 변수를 대기해야합니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="3650f8c5497d7228961bb8ca2c4d9289b5d66fe8" translate="yes" xml:space="preserve">
          <source>A cons cell of the form &lt;code&gt;(:filtered&amp;nbsp;&lt;var&gt;filter&lt;/var&gt;&amp;nbsp;&lt;var&gt;face-spec&lt;/var&gt;)&lt;/code&gt;, that specifies the face given by &lt;var&gt;face-spec&lt;/var&gt;, but only if &lt;var&gt;filter&lt;/var&gt; matches when the face is used for display. The &lt;var&gt;face-spec&lt;/var&gt; can use any of the forms mentioned above. The &lt;var&gt;filter&lt;/var&gt; should be of the form &lt;code&gt;(:window&amp;nbsp;&lt;var&gt;param&lt;/var&gt;&amp;nbsp;&lt;var&gt;value&lt;/var&gt;)&lt;/code&gt;, which matches for windows whose parameter &lt;var&gt;param&lt;/var&gt; is &lt;code&gt;eq&lt;/code&gt; to &lt;var&gt;value&lt;/var&gt;. If the variable &lt;code&gt;face-filters-always-match&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;, all face filters are deemed to have matched.</source>
          <target state="translated">폼의 단점 셀 &lt;code&gt;(:filtered&amp;nbsp;&lt;var&gt;filter&lt;/var&gt;&amp;nbsp;&lt;var&gt;face-spec&lt;/var&gt;)&lt;/code&gt; , 그 지정에 의해 지정된 얼굴 &lt;var&gt;face-spec&lt;/var&gt; 있지만에만 &lt;var&gt;filter&lt;/var&gt; 일치하는면이 디스플레이에 사용된다. &lt;var&gt;face-spec&lt;/var&gt; 전술 한 형태 중 하나를 사용할 수있다. &lt;var&gt;filter&lt;/var&gt; 형식이어야 &lt;code&gt;(:window&amp;nbsp;&lt;var&gt;param&lt;/var&gt;&amp;nbsp;&lt;var&gt;value&lt;/var&gt;)&lt;/code&gt; , 그 파라미터 창문 일치 &lt;var&gt;param&lt;/var&gt; 이다 &lt;code&gt;eq&lt;/code&gt; 에 &lt;var&gt;value&lt;/var&gt; . 변수 &lt;code&gt;face-filters-always-match&lt;/code&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 모든 얼굴 필터가 일치하는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="d8271db68f51039072c221d4ef9ab0b74c409c21" translate="yes" xml:space="preserve">
          <source>A cons cell of the form &lt;code&gt;(foreground-color . &lt;var&gt;color-name&lt;/var&gt;)&lt;/code&gt; or &lt;code&gt;(background-color . &lt;var&gt;color-name&lt;/var&gt;)&lt;/code&gt;. This specifies the foreground or background color, similar to &lt;code&gt;(:foreground
&lt;var&gt;color-name&lt;/var&gt;)&lt;/code&gt; or &lt;code&gt;(:background &lt;var&gt;color-name&lt;/var&gt;)&lt;/code&gt;. This form is supported for backward compatibility only, and should be avoided.</source>
          <target state="translated">&lt;code&gt;(foreground-color . &lt;var&gt;color-name&lt;/var&gt;)&lt;/code&gt; 또는 &lt;code&gt;(background-color . &lt;var&gt;color-name&lt;/var&gt;)&lt;/code&gt; 형식의 cons 셀 . &lt;code&gt;(:foreground &lt;var&gt;color-name&lt;/var&gt;)&lt;/code&gt; 또는 &lt;code&gt;(:background &lt;var&gt;color-name&lt;/var&gt;)&lt;/code&gt; 과 유사한 전경색 또는 배경색을 지정합니다 . 이 형식은 이전 버전과의 호환성을 위해서만 지원되며 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="d03a2fa230ce48add85f00959d667fc812d94873" translate="yes" xml:space="preserve">
          <source>A cons cell of this format is a raw syntax descriptor (see &lt;a href=&quot;syntax-table-internals#Syntax-Table-Internals&quot;&gt;Syntax Table Internals&lt;/a&gt;), which directly specifies a syntax class for the underlying text character.</source>
          <target state="translated">이 형식의 단점 셀은 기본 텍스트 문자에 대한 구문 클래스를 직접 지정하는 원시 구문 설명자 ( &lt;a href=&quot;syntax-table-internals#Syntax-Table-Internals&quot;&gt;Syntax Table Internals&lt;/a&gt; 참조 )입니다.</target>
        </trans-unit>
        <trans-unit id="5238f872a1ac4dba38c3a3004ec3ed1655dc4fed" translate="yes" xml:space="preserve">
          <source>A cons cell refers to all the characters in the inclusive range &amp;lsquo;</source>
          <target state="translated">cons 셀은 포함 범위 '</target>
        </trans-unit>
        <trans-unit id="1ec89aacc5165a1fe6d3ad709f5d8ebc96163844" translate="yes" xml:space="preserve">
          <source>A cons of the horizontal and vertical width of &lt;var&gt;frame&lt;/var&gt;&amp;rsquo;s external borders as supplied by the window manager. If the window manager doesn&amp;rsquo;t supply these values, Emacs will try to guess them from the coordinates of the outer and inner frame.</source>
          <target state="translated">창 관리자에서 제공하는 &lt;var&gt;frame&lt;/var&gt; 외부 테두리 의 가로 및 세로 너비에 대한 단점입니다 . 창 관리자가 이러한 값을 제공하지 않으면 Emacs는 외부 및 내부 프레임의 좌표에서 값을 추측하려고합니다.</target>
        </trans-unit>
        <trans-unit id="0beb20967e7325f22b981dd3f01c49dfbca35c06" translate="yes" xml:space="preserve">
          <source>A cons of the outer width and height of &lt;var&gt;frame&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;frame&lt;/var&gt; 의 외부 너비와 높이의 단점 .</target>
        </trans-unit>
        <trans-unit id="79343f6085ac302ef9fa3a97ea5eeac739cb4772" translate="yes" xml:space="preserve">
          <source>A cons of the width and height of the menu bar of &lt;var&gt;frame&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;frame&lt;/var&gt; 메뉴 막대의 너비와 높이의 단점 .</target>
        </trans-unit>
        <trans-unit id="5f12a3cec98da0d7b3d27d5bc62141f964a4c280" translate="yes" xml:space="preserve">
          <source>A cons of the width and height of the title bar of &lt;var&gt;frame&lt;/var&gt; as supplied by the window manager or operating system. If both of them are zero, the frame has no title bar. If only the width is zero, Emacs was not able to retrieve the width information.</source>
          <target state="translated">창 관리자 또는 운영 체제에서 제공하는 &lt;var&gt;frame&lt;/var&gt; 의 제목 표시 줄 너비와 높이의 단점입니다 . 둘 다 0이면 프레임에 제목 표시 줄이 없습니다. 너비 만 0이면 Emacs는 너비 정보를 검색 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c58e8cae6440fd807e647cdf99797dc30cefd036" translate="yes" xml:space="preserve">
          <source>A cons of the width and height of the tool bar of &lt;var&gt;frame&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;frame&lt;/var&gt; 도구 모음의 너비와 높이의 단점 .</target>
        </trans-unit>
        <trans-unit id="f9033693e3f5a3c88a76aad01d35ab20eafc8a92" translate="yes" xml:space="preserve">
          <source>A cons representing the absolute position of the outer &lt;var&gt;frame&lt;/var&gt;, relative to the origin at position (0, 0) of &lt;var&gt;frame&lt;/var&gt;&amp;rsquo;s display.</source>
          <target state="translated">외부의 절대 위치를 나타내는 단점 &lt;var&gt;frame&lt;/var&gt; 의 위치에서 원점을 기준으로, (0, 0) &lt;var&gt;frame&lt;/var&gt; 의 표시.</target>
        </trans-unit>
        <trans-unit id="9b4eb54eabadc737377233ef8ded968fd41e2deb" translate="yes" xml:space="preserve">
          <source>A construct defined in Lisp, which differs from a function in that it translates a Lisp expression into another expression which is to be evaluated instead of the original expression. Macros enable Lisp programmers to do the sorts of things that special forms can do. See &lt;a href=&quot;macros#Macros&quot;&gt;Macros&lt;/a&gt;.</source>
          <target state="translated">Lisp에 정의 된 구조로, Lisp 표현식을 원래 표현식 대신 평가할 다른 표현식으로 변환한다는 점에서 함수와 다릅니다. 매크로를 사용하면 Lisp 프로그래머가 특수 양식이 할 수있는 일을 할 수 있습니다. &lt;a href=&quot;macros#Macros&quot;&gt;매크로를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="25f94db633d9470e92b721c0609e1574933b7102" translate="yes" xml:space="preserve">
          <source>A convenience macro for making menus.</source>
          <target state="translated">메뉴를 만들기위한 편리한 매크로.</target>
        </trans-unit>
        <trans-unit id="3fafa14ddeeaf20f1b4ad6912b65d2d19616adec" translate="yes" xml:space="preserve">
          <source>A convenient facility for defining minor modes.</source>
          <target state="translated">부 모드를 정의하는 편리한 기능입니다.</target>
        </trans-unit>
        <trans-unit id="297d6bae1b885556c226c6d00dbbeb28f22842b0" translate="yes" xml:space="preserve">
          <source>A convenient way to set up and update a package archive is via the &lt;code&gt;package-x&lt;/code&gt; library. This is included with Emacs, but not loaded by default; type</source>
          <target state="translated">패키지 아카이브를 설정하고 업데이트하는 편리한 방법은 &lt;code&gt;package-x&lt;/code&gt; 라이브러리를 사용하는 것입니다. 이것은 Emacs에 포함되어 있지만 기본적으로로드되지는 않습니다. 유형</target>
        </trans-unit>
        <trans-unit id="2e0cc653b247cb03dc9702d2d54a86897be33e6a" translate="yes" xml:space="preserve">
          <source>A convention for use of &lt;code&gt;buffer-invisibility-spec&lt;/code&gt; is that a major mode should use the mode&amp;rsquo;s own name as an element of &lt;code&gt;buffer-invisibility-spec&lt;/code&gt; and as the value of the &lt;code&gt;invisible&lt;/code&gt; property:</source>
          <target state="translated">&lt;code&gt;buffer-invisibility-spec&lt;/code&gt; 사용에 대한 규칙 은 주 모드가 &lt;code&gt;buffer-invisibility-spec&lt;/code&gt; 의 요소 와 &lt;code&gt;invisible&lt;/code&gt; 속성 의 값으로 모드의 고유 이름을 사용해야한다는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="0095e662bacaddef74e80e8571b0f884034dde11" translate="yes" xml:space="preserve">
          <source>A debugger for the Emacs Lisp evaluator.</source>
          <target state="translated">Emacs Lisp 평가 기용 디버거.</target>
        </trans-unit>
        <trans-unit id="c27aa099ef5cc29a5bab61fb80b9be59f07e143f" translate="yes" xml:space="preserve">
          <source>A declare form, as described in &lt;a href=&quot;declare-form#Declare-Form&quot;&gt;Declare Form&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;declare-form#Declare-Form&quot;&gt;Declare Form에&lt;/a&gt; 설명 된 선언 양식 .</target>
        </trans-unit>
        <trans-unit id="1be6fff32246cce77eab4434395816c475968954" translate="yes" xml:space="preserve">
          <source>A default value of some sort is used if the user enters no text in the minibuffer. The default depends on the code character.</source>
          <target state="translated">사용자가 미니 버퍼에 텍스트를 입력하지 않으면 일종의 기본값이 사용됩니다. 기본값은 코드 문자에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="3c9c4af7e022e7df38dd0e315a210ed85a2953a6" translate="yes" xml:space="preserve">
          <source>A defining form is not required to have a name field; and it may have multiple name fields.</source>
          <target state="translated">정의 양식에는 이름 필드가 필요하지 않습니다. 이름 필드가 여러 개있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5177ad8b95e4d0810b23a049c7d8aa0b5c5cdcd6" translate="yes" xml:space="preserve">
          <source>A definition says a symbol is used as a variable.</source>
          <target state="translated">정의에 따르면 기호가 변수로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="de08378d88f315c9fa8938316807fbbd8ff34ed7" translate="yes" xml:space="preserve">
          <source>A definition says how a symbol will be used.</source>
          <target state="translated">정의는 기호가 사용되는 방법을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4364a7b67be2475f663e63107ec953eb81d8fcc0" translate="yes" xml:space="preserve">
          <source>A deleted overlay is not permanently disconnected. You can give it a position in a buffer again by calling &lt;code&gt;move-overlay&lt;/code&gt;.</source>
          <target state="translated">삭제 된 오버레이는 영구적으로 연결 해제되지 않습니다. &lt;code&gt;move-overlay&lt;/code&gt; 를 호출하여 다시 버퍼에 위치를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="58b8939e754501ca7ffac5e754a5203fd8bccd0b" translate="yes" xml:space="preserve">
          <source>A description of an imaginary function, &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">가상 함수 &lt;code&gt;foo&lt;/code&gt; 에 대한 설명 .</target>
        </trans-unit>
        <trans-unit id="11aa25b3cc19f2ea9549c34581688b4bf0ea0136" translate="yes" xml:space="preserve">
          <source>A description of an imaginary variable, &lt;code&gt;electric-future-map&lt;/code&gt;.</source>
          <target state="translated">가상 변수에 대한 설명, &lt;code&gt;electric-future-map&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f73f21e9e7cf5032ba1e7628c65d4b74eb715d3" translate="yes" xml:space="preserve">
          <source>A detailed explanation of ACLs and SELinux is beyond the scope of this manual. For our purposes, each file can be associated with an &lt;em&gt;ACL&lt;/em&gt;, which specifies its properties under an ACL-based file control system, and/or an &lt;em&gt;SELinux context&lt;/em&gt;, which specifies its properties under the SELinux system.</source>
          <target state="translated">ACL 및 SELinux에 대한 자세한 설명은이 설명서의 범위를 벗어납니다. 우리의 목적을 위해, 각 파일은과 연관 될 수 &lt;em&gt;ACL&lt;/em&gt; ACL에 기반 파일 관리 시스템 아래의 특성들을 지정 및 / 또는 &lt;em&gt;SELinux의 컨텍스트&lt;/em&gt; 알림 selinux 시스템 아래의 특성들을 지정한다.</target>
        </trans-unit>
        <trans-unit id="e1955b79f8229f08318c426ea757222c4442b725" translate="yes" xml:space="preserve">
          <source>A deterministic computer program cannot generate true random numbers. For most purposes, &lt;em&gt;pseudo-random numbers&lt;/em&gt; suffice. A series of pseudo-random numbers is generated in a deterministic fashion. The numbers are not truly random, but they have certain properties that mimic a random series. For example, all possible values occur equally often in a pseudo-random series.</source>
          <target state="translated">결정 론적 컴퓨터 프로그램은 실제 난수를 생성 할 수 없습니다. 대부분의 경우 &lt;em&gt;의사 난수&lt;/em&gt; 이면 충분합니다. 일련의 의사 난수는 결정 론적 방식으로 생성됩니다. 숫자는 실제로 무작위가 아니지만 무작위 시리즈를 모방하는 특정 속성을 가지고 있습니다. 예를 들어, 가능한 모든 값은 의사 난수 시리즈에서 똑같이 자주 발생합니다.</target>
        </trans-unit>
        <trans-unit id="43e7ef970f24cac5d7645fe4b91714542c027a79" translate="yes" xml:space="preserve">
          <source>A dialog box is a variant of a pop-up menu&amp;mdash;it looks a little different, it always appears in the center of a frame, and it has just one level and one or more buttons. The main use of dialog boxes is for asking questions that the user can answer with &amp;ldquo;yes&amp;rdquo;, &amp;ldquo;no&amp;rdquo;, and a few other alternatives. With a single button, they can also force the user to acknowledge important information. The functions &lt;code&gt;y-or-n-p&lt;/code&gt; and &lt;code&gt;yes-or-no-p&lt;/code&gt; use dialog boxes instead of the keyboard, when called from commands invoked by mouse clicks.</source>
          <target state="translated">대화 상자는 팝업 메뉴의 변형입니다. 약간 다르게 보이며 항상 프레임 중앙에 나타나며 하나의 레벨과 하나 이상의 버튼 만 있습니다. 대화 상자의 주요 용도는 사용자가 &quot;예&quot;, &quot;아니요&quot;및 몇 가지 다른 대안으로 대답 할 수있는 질문을하는 것입니다. 버튼 하나로 사용자가 중요한 정보를 확인하도록 할 수도 있습니다. &lt;code&gt;y-or-n-p&lt;/code&gt; 및 &lt;code&gt;yes-or-no-p&lt;/code&gt; 함수 는 마우스 클릭으로 호출 된 명령에서 호출 될 때 키보드 대신 대화 상자를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="06e671a1ddbd1bf37d315d97dcc27b3ed2c2dee1" translate="yes" xml:space="preserve">
          <source>A different type of local variable binding.</source>
          <target state="translated">다른 유형의 지역 변수 바인딩.</target>
        </trans-unit>
        <trans-unit id="0091e52ca1a33dbd15c5a00528bef096a86ddc65" translate="yes" xml:space="preserve">
          <source>A different way to remove the instrumentation from a definition is to use the &lt;code&gt;edebug-remove-instrumentation&lt;/code&gt; command. It also allows removing the instrumentation from everything that has been instrumented.</source>
          <target state="translated">정의에서 계측을 제거하는 다른 방법은 &lt;code&gt;edebug-remove-instrumentation&lt;/code&gt; 명령 을 사용하는 것 입니다. 또한 계측 된 모든 것에서 계측을 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e5fced30518a6cc177c6f9f8661843eb09981dd" translate="yes" xml:space="preserve">
          <source>A directory can specify local variable values common to all files in that directory; Emacs uses these to create buffer-local bindings for those variables in buffers visiting any file in that directory. This is useful when the files in the directory belong to some &lt;em&gt;project&lt;/em&gt; and therefore share the same local variables.</source>
          <target state="translated">디렉토리는 해당 디렉토리의 모든 파일에 공통적 인 로컬 변수 값을 지정할 수 있습니다. Emacs는 이것을 사용하여 해당 디렉토리의 파일을 방문하는 버퍼의 해당 변수에 대한 버퍼 로컬 바인딩을 만듭니다. 이것은 디렉토리의 파일이 일부 &lt;em&gt;프로젝트&lt;/em&gt; 에 속하므로 동일한 로컬 변수를 공유 할 때 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="48d989c612224004f5b20619066f4e6b19f37178" translate="yes" xml:space="preserve">
          <source>A directory is a kind of file that contains other files entered under various names. Directories are a feature of the file system.</source>
          <target state="translated">디렉토리는 다양한 이름으로 입력 된 다른 파일을 포함하는 일종의 파일입니다. 디렉토리는 파일 시스템의 기능입니다.</target>
        </trans-unit>
        <trans-unit id="4ec31203fbb74e0088be167ac30971d85d3c047f" translate="yes" xml:space="preserve">
          <source>A directory&amp;rsquo;s name as a directory is different from its name as a file.</source>
          <target state="translated">디렉토리로서의 디렉토리 이름은 파일로서의 이름과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="a2d4ede6ec1806c95321d5345fff475d6f0aebcd" translate="yes" xml:space="preserve">
          <source>A directory. The default is the current default directory of the current buffer, &lt;code&gt;default-directory&lt;/code&gt; (see &lt;a href=&quot;file-name-expansion#File-Name-Expansion&quot;&gt;File Name Expansion&lt;/a&gt;). Existing, Completion, Default, Prompt.</source>
          <target state="translated">디렉토리. 기본값은 현재 버퍼의 현재 기본 디렉토리 인 &lt;code&gt;default-directory&lt;/code&gt; 입니다 ( &lt;a href=&quot;file-name-expansion#File-Name-Expansion&quot;&gt;파일 이름 확장&lt;/a&gt; 참조 ). 기존, 완료, 기본값, 프롬프트.</target>
        </trans-unit>
        <trans-unit id="aebf276f3f9ef6b6d78e048e8f10f2d90ee89099" translate="yes" xml:space="preserve">
          <source>A display specification of this form means to display &lt;var&gt;string&lt;/var&gt; instead of the text that has the display specification, at the same position as that text. It is equivalent to using just &lt;var&gt;string&lt;/var&gt;, but it is done as a special case of marginal display (see &lt;a href=&quot;display-margins#Display-Margins&quot;&gt;Display Margins&lt;/a&gt;).</source>
          <target state="translated">이 형식의 표시 사양은 표시 사양이 있는 텍스트 대신 해당 텍스트와 같은 위치에 &lt;var&gt;string&lt;/var&gt; 을 표시하는 것을 의미 합니다. &lt;var&gt;string&lt;/var&gt; 만 사용하는 것과 동일 하지만 &lt;a href=&quot;display-margins#Display-Margins&quot;&gt;여백&lt;/a&gt; 표시의 특수한 경우로 수행됩니다 ( Display Margins 참조 ).</target>
        </trans-unit>
        <trans-unit id="9161760d8a3ca941a9db98a283106b4f587110f2" translate="yes" xml:space="preserve">
          <source>A display table is a special-purpose char-table (see &lt;a href=&quot;char_002dtables#Char_002dTables&quot;&gt;Char-Tables&lt;/a&gt;), with &lt;code&gt;display-table&lt;/code&gt; as its subtype, which is used to override the usual character display conventions. This section describes how to make, inspect, and assign elements to a display table object.</source>
          <target state="translated">디스플레이 테이블은 특수 목적의 char-table ( &lt;a href=&quot;char_002dtables#Char_002dTables&quot;&gt;Char-Tables&lt;/a&gt; 참조 )이며 &lt;code&gt;display-table&lt;/code&gt; 을 하위 유형으로 사용하여 일반적인 문자 표시 규칙을 재정의하는 데 사용됩니다. 이 단원에서는 표시 테이블 객체에 요소를 만들고, 검사하고, 할당하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="52695f4559e95ed4fd291753560c2fbe430d0669" translate="yes" xml:space="preserve">
          <source>A documentation string for the format.</source>
          <target state="translated">형식에 대한 문서 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="6763620e7fdbc8305a10cc9edc12970524216315" translate="yes" xml:space="preserve">
          <source>A documentation string is written using the Lisp syntax for strings, with double-quote characters surrounding the text. It is, in fact, an actual Lisp string. When the string appears in the proper place in a function or variable definition, it serves as the function&amp;rsquo;s or variable&amp;rsquo;s documentation.</source>
          <target state="translated">문서 문자열은 텍스트를 큰 따옴표로 묶고 문자열에 Lisp 구문을 사용하여 작성됩니다. 사실 실제 Lisp 문자열입니다. 문자열이 함수 또는 변수 정의의 적절한 위치에 나타나면 함수 또는 변수의 문서 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="14c8ca9284b667313f9526899ae4f3c60147c600" translate="yes" xml:space="preserve">
          <source>A double dashed line in the menu&amp;rsquo;s foreground color.</source>
          <target state="translated">메뉴의 전경색에 이중 파선.</target>
        </trans-unit>
        <trans-unit id="813cbcdafcb879f3a5a1bf64906fb09751530f37" translate="yes" xml:space="preserve">
          <source>A double line in the menu&amp;rsquo;s foreground color.</source>
          <target state="translated">메뉴 전경색의 이중선.</target>
        </trans-unit>
        <trans-unit id="d311dc731460b00910cb74c5f2364a3a8671a3b6" translate="yes" xml:space="preserve">
          <source>A doubly-linked chain of &lt;em&gt;nodes&lt;/em&gt;, each of which contains:</source>
          <target state="translated">이중으로 연결된 &lt;em&gt;노드&lt;/em&gt; 체인으로 , 각 &lt;em&gt;노드&lt;/em&gt; 에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="670af85a0c88c05fba929b7f913f66bc95166bf6" translate="yes" xml:space="preserve">
          <source>A face defines a graphics style for text characters: font, colors, etc.</source>
          <target state="translated">얼굴은 글꼴, 색상 등 텍스트 문자의 그래픽 스타일을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="726bfb1c0aec1ad9ae708b0d3d1b5d85a1cfcd7c" translate="yes" xml:space="preserve">
          <source>A face name (a symbol or string).</source>
          <target state="translated">얼굴 이름 (기호 또는 문자열).</target>
        </trans-unit>
        <trans-unit id="4514d72359a84b597e6e68ca7f1afce732ca5d0d" translate="yes" xml:space="preserve">
          <source>A feature name is a symbol that stands for a collection of functions, variables, etc. The file that defines them should &lt;em&gt;provide&lt;/em&gt; the feature. Another program that uses them may ensure they are defined by &lt;em&gt;requiring&lt;/em&gt; the feature. This loads the file of definitions if it hasn&amp;rsquo;t been loaded already.</source>
          <target state="translated">기능 이름은 기능, 변수 등의 모음을 나타내는 기호입니다. 기능을 정의하는 파일 은 기능을 &lt;em&gt;제공&lt;/em&gt; 해야합니다. 이를 사용하는 다른 프로그램 은 기능 을 &lt;em&gt;요구&lt;/em&gt; 하여 정의되도록 할 수 있습니다. 아직로드되지 않은 경우 정의 파일을로드합니다.</target>
        </trans-unit>
        <trans-unit id="99c5746bfcdeb35c064b9bea4ccd10d38344ce46" translate="yes" xml:space="preserve">
          <source>A few Lisp variables are &lt;em&gt;terminal-local&lt;/em&gt;; that is, they have a separate binding for each terminal. The binding in effect at any time is the one for the terminal that the currently selected frame belongs to. These variables include &lt;code&gt;default-minibuffer-frame&lt;/code&gt;, &lt;code&gt;defining-kbd-macro&lt;/code&gt;, &lt;code&gt;last-kbd-macro&lt;/code&gt;, and &lt;code&gt;system-key-alist&lt;/code&gt;. They are always terminal-local, and can never be buffer-local (see &lt;a href=&quot;buffer_002dlocal-variables#Buffer_002dLocal-Variables&quot;&gt;Buffer-Local Variables&lt;/a&gt;).</source>
          <target state="translated">몇 가지 Lisp 변수는 &lt;em&gt;터미널 로컬입니다&lt;/em&gt; . 즉, 각 터미널에 대해 별도의 바인딩이 있습니다. 유효한 바인딩은 현재 선택된 프레임이 속한 터미널에 대한 바인딩입니다. 이러한 변수에는 &lt;code&gt;default-minibuffer-frame&lt;/code&gt; , definition- &lt;code&gt;defining-kbd-macro&lt;/code&gt; , &lt;code&gt;last-kbd-macro&lt;/code&gt; 및 &lt;code&gt;system-key-alist&lt;/code&gt; 가 포함 됩니다. 항상 터미널 로컬이며 버퍼 로컬이 될 수 없습니다 ( &lt;a href=&quot;buffer_002dlocal-variables#Buffer_002dLocal-Variables&quot;&gt;버퍼 로컬 변수&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="ef5e8cbc36482886f084f025163f8eb73160f6da" translate="yes" xml:space="preserve">
          <source>A few fundamental object types are built into Emacs. These, from which all other types are constructed, are called &lt;em&gt;primitive types&lt;/em&gt;. Each object belongs to one and only one primitive type. These types include &lt;em&gt;integer&lt;/em&gt;, &lt;em&gt;float&lt;/em&gt;, &lt;em&gt;cons&lt;/em&gt;, &lt;em&gt;symbol&lt;/em&gt;, &lt;em&gt;string&lt;/em&gt;, &lt;em&gt;vector&lt;/em&gt;, &lt;em&gt;hash-table&lt;/em&gt;, &lt;em&gt;subr&lt;/em&gt;, &lt;em&gt;byte-code function&lt;/em&gt;, and &lt;em&gt;record&lt;/em&gt;, plus several special types, such as &lt;em&gt;buffer&lt;/em&gt;, that are related to editing. (See &lt;a href=&quot;editing-types#Editing-Types&quot;&gt;Editing Types&lt;/a&gt;.)</source>
          <target state="translated">몇 가지 기본적인 객체 유형이 Emacs에 내장되어 있습니다. 다른 모든 유형이 생성되는이를 &lt;em&gt;기본 유형&lt;/em&gt; 이라고 &lt;em&gt;합니다&lt;/em&gt; . 각 객체는 하나의 기본 유형에만 속합니다. 이러한 유형에는 &lt;em&gt;integer&lt;/em&gt; , &lt;em&gt;float&lt;/em&gt; , &lt;em&gt;cons&lt;/em&gt; , &lt;em&gt;symbol&lt;/em&gt; , &lt;em&gt;string&lt;/em&gt; , &lt;em&gt;vector&lt;/em&gt; , &lt;em&gt;hash-table&lt;/em&gt; , &lt;em&gt;subr&lt;/em&gt; , &lt;em&gt;byte-code function&lt;/em&gt; , &lt;em&gt;record&lt;/em&gt; 및 편집과 관련된 여러 특수 유형 (예 : &lt;em&gt;buffer&lt;/em&gt; )이 포함됩니다. ( &lt;a href=&quot;editing-types#Editing-Types&quot;&gt;유형 편집을&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="2109a9b0cfa4198eb2ea0694b1fee3a782f0b966" translate="yes" xml:space="preserve">
          <source>A few other event types represent occurrences within the system.</source>
          <target state="translated">몇 가지 다른 이벤트 유형은 시스템 내의 발생을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1ff9d92dab390c666f58e186968e826c0b79fcf0" translate="yes" xml:space="preserve">
          <source>A few things to note:</source>
          <target state="translated">몇 가지 참고할 사항 :</target>
        </trans-unit>
        <trans-unit id="86b66daa5d856aaa51ac94ff6f958584a9ddc1e1" translate="yes" xml:space="preserve">
          <source>A field is a range of consecutive characters in the buffer that are identified by having the same value (comparing with &lt;code&gt;eq&lt;/code&gt;) of the &lt;code&gt;field&lt;/code&gt; property (either a text-property or an overlay property). This section describes special functions that are available for operating on fields.</source>
          <target state="translated">필드는 같은 값 (와 비교함으로써 식별되는 버퍼의 연속 된 문자의 범위 &lt;code&gt;eq&lt;/code&gt; 의) &lt;code&gt;field&lt;/code&gt; 속성 (텍스트 속성 또는 오버레이 속성 중 참조). 이 섹션에서는 필드 작업에 사용할 수있는 특수 기능에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="2edac8714c37f5d4697daa8ef9c7fbc14208533e" translate="yes" xml:space="preserve">
          <source>A field specification generally has the form &lt;code&gt;([&lt;var&gt;name&lt;/var&gt;]
&lt;var&gt;handler&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;name&lt;/var&gt; is optional. Don&amp;rsquo;t use names that are symbols meaningful as type specifications (above) or handler specifications (below), since that would be ambiguous. &lt;var&gt;name&lt;/var&gt; can be a symbol or an expression &lt;code&gt;(eval &lt;var&gt;form&lt;/var&gt;)&lt;/code&gt;, in which case &lt;var&gt;form&lt;/var&gt; should evaluate to a symbol.</source>
          <target state="translated">필드 사양은 일반적으로 &lt;code&gt;([&lt;var&gt;name&lt;/var&gt;] &lt;var&gt;handler&lt;/var&gt;)&lt;/code&gt; 형식을 가지며 , 여기서 &lt;var&gt;name&lt;/var&gt; 은 선택 사항입니다. 유형 사양 (위) 또는 핸들러 사양 (아래)으로 의미있는 기호 인 이름은 모호 할 수 있으므로 사용하지 마십시오. &lt;var&gt;name&lt;/var&gt; 은 기호 또는 표현식 &lt;code&gt;(eval &lt;var&gt;form&lt;/var&gt;)&lt;/code&gt; 이 될 수 있으며 ,이 경우 &lt;var&gt;form&lt;/var&gt; 은 기호로 평가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="66e349966ac46496fe078cf6419a73b28e3d4fe7" translate="yes" xml:space="preserve">
          <source>A field&amp;rsquo;s &lt;em&gt;type&lt;/em&gt; describes the size (in bytes) of the object that the field represents and, in the case of multibyte fields, how the bytes are ordered within the field. The two possible orderings are &lt;em&gt;big endian&lt;/em&gt; (also known as &amp;ldquo;network byte ordering&amp;rdquo;) and &lt;em&gt;little endian&lt;/em&gt;. For instance, the number &lt;code&gt;#x23cd&lt;/code&gt; (decimal 9165) in big endian would be the two bytes &lt;code&gt;#x23&lt;/code&gt;&lt;code&gt;#xcd&lt;/code&gt;; and in little endian, &lt;code&gt;#xcd&lt;/code&gt;&lt;code&gt;#x23&lt;/code&gt;. Here are the possible type values:</source>
          <target state="translated">필드의 &lt;em&gt;유형&lt;/em&gt; 은 필드가 나타내는 객체의 크기 (바이트)를 설명하고 멀티 바이트 필드의 경우 필드 내에서 바이트가 정렬되는 방식을 설명합니다. 가능한 두 가지 순서는 &lt;em&gt;빅 엔디안&lt;/em&gt; ( &quot;네트워크 바이트 순서&quot;라고도 함)과 &lt;em&gt;리틀 엔디안&lt;/em&gt; 입니다. 예를 들어, 빅 엔디안 의 숫자 &lt;code&gt;#x23cd&lt;/code&gt; (10 진수 9165)는 2 바이트입니다. &lt;code&gt;#x23&lt;/code&gt; &lt;code&gt;#xcd&lt;/code&gt; ; 그리고 리틀 엔디안에서는 &lt;code&gt;#xcd&lt;/code&gt; &lt;code&gt;#x23&lt;/code&gt; 입니다. 가능한 유형 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="580694942b3d2554858d2f62daeabff74c0c3401" translate="yes" xml:space="preserve">
          <source>A file and a buffer are two different things. A file is information recorded permanently in the computer (unless you delete it). A buffer, on the other hand, is information inside of Emacs that will vanish at the end of the editing session (or when you kill the buffer). When a buffer is visiting a file, it contains information copied from the file. The copy in the buffer is what you modify with editing commands. Changes to the buffer do not change the file; to make the changes permanent, you must &lt;em&gt;save&lt;/em&gt; the buffer, which means copying the altered buffer contents back into the file.</source>
          <target state="translated">파일과 버퍼는 서로 다른 두 가지입니다. 파일은 컴퓨터에 영구적으로 기록 된 정보입니다 (삭제하지 않는 한). 반면에 버퍼는 편집 세션이 끝날 때 (또는 버퍼를 죽일 때) 사라지는 Emacs 내부의 정보입니다. 버퍼가 파일을 방문 할 때 파일에서 복사 된 정보를 포함합니다. 버퍼의 사본은 편집 명령으로 수정하는 것입니다. 버퍼를 변경해도 파일은 변경되지 않습니다. 변경 사항을 영구적으로 적용 하려면 버퍼 를 &lt;em&gt;저장&lt;/em&gt; 해야합니다. 즉, 변경된 버퍼 내용을 파일에 다시 복사해야합니다.</target>
        </trans-unit>
        <trans-unit id="b6520ff9ddc77c2a9c18bbbb20d48bf4fa9f59b0" translate="yes" xml:space="preserve">
          <source>A file can specify local variable values; Emacs uses these to create buffer-local bindings for those variables in the buffer visiting that file. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/File-Variables.html#File-Variables&quot;&gt;Local Variables in Files&lt;/a&gt; in</source>
          <target state="translated">파일은 지역 변수 값을 지정할 수 있습니다. Emacs는 이것을 사용하여 해당 파일을 방문하는 버퍼의 해당 변수에 대한 버퍼 로컬 바인딩을 만듭니다. &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/File-Variables.html#File-Variables&quot;&gt;파일의 로컬 변수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8d614f30d1cecac0c2819f4acd5ac1120709f5e0" translate="yes" xml:space="preserve">
          <source>A file name handler can have an &lt;code&gt;operations&lt;/code&gt; property to declare which operations it handles in a nontrivial way. If this property has a non-&lt;code&gt;nil&lt;/code&gt; value, it should be a list of operations; then only those operations will call the handler. This avoids inefficiency, but its main purpose is for autoloaded handler functions, so that they won&amp;rsquo;t be loaded except when they have real work to do.</source>
          <target state="translated">파일 이름 처리기에는 &lt;code&gt;operations&lt;/code&gt; 속성이있어 사소한 방법으로 처리하는 작업을 선언 할 수 있습니다 . 이 속성에 &lt;code&gt;nil&lt;/code&gt; 이 아닌 값 이 있으면 작업 목록이어야합니다. 그런 다음 해당 작업 만 핸들러를 호출합니다. 이것은 비 효율성을 피하지만 그 주된 목적은 자동로드 된 핸들러 함수를위한 것이므로 실제 작업이있을 때를 제외하고는로드되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1088e5bc43c1b7e8706e14f51cbd3a0578264ad7" translate="yes" xml:space="preserve">
          <source>A file name of an existing file (see &lt;a href=&quot;file-names#File-Names&quot;&gt;File Names&lt;/a&gt;). The default directory is &lt;code&gt;default-directory&lt;/code&gt;. Existing, Completion, Default, Prompt.</source>
          <target state="translated">기존 파일의 &lt;a href=&quot;file-names#File-Names&quot;&gt;파일 이름&lt;/a&gt; ( 파일 이름 참조 ). 기본 디렉토리는 &lt;code&gt;default-directory&lt;/code&gt; 입니다. 기존, 완료, 기본값, 프롬프트.</target>
        </trans-unit>
        <trans-unit id="990b2e19e09d588c791c9ad42c0a10ebbf4a1858" translate="yes" xml:space="preserve">
          <source>A file name. The file need not exist. Completion, Default, Prompt.</source>
          <target state="translated">파일 이름. 파일이 존재하지 않아도됩니다. 완료, 기본값, 프롬프트.</target>
        </trans-unit>
        <trans-unit id="03b87a98b8d63d5ce31e62636e7feac61dc6a158" translate="yes" xml:space="preserve">
          <source>A file name. The file need not exist. If the user enters just a directory name, then the value is just that directory name, with no file name within the directory added. Completion, Default, Prompt.</source>
          <target state="translated">파일 이름. 파일이 존재하지 않아도됩니다. 사용자가 디렉토리 이름 만 입력하면 값은 해당 디렉토리 이름이며 디렉토리 내에 파일 이름이 추가되지 않습니다. 완료, 기본값, 프롬프트.</target>
        </trans-unit>
        <trans-unit id="f353c7943be8119125e4593f00061ea9a8b8c13d" translate="yes" xml:space="preserve">
          <source>A file of saved abbrev definitions is actually a file of Lisp code. The abbrevs are saved in the form of a Lisp program to define the same abbrev tables with the same contents. Therefore, you can load the file with &lt;code&gt;load&lt;/code&gt; (see &lt;a href=&quot;how-programs-do-loading#How-Programs-Do-Loading&quot;&gt;How Programs Do Loading&lt;/a&gt;). However, the function &lt;code&gt;quietly-read-abbrev-file&lt;/code&gt; is provided as a more convenient interface. Emacs automatically calls this function at startup.</source>
          <target state="translated">저장된 약어 정의 파일은 실제로 Lisp 코드 파일입니다. 약어는 Lisp 프로그램의 형태로 저장되어 동일한 내용을 가진 동일한 약어 테이블을 정의합니다. 따라서로드와 함께 파일을 &lt;code&gt;load&lt;/code&gt; 할 수 있습니다 ( &lt;a href=&quot;how-programs-do-loading#How-Programs-Do-Loading&quot;&gt;프로그램로드 방법&lt;/a&gt; 참조 ). 그러나 더 편리한 인터페이스로 &lt;code&gt;quietly-read-abbrev-file&lt;/code&gt; 기능 이 제공됩니다. Emacs는 시작할 때이 함수를 자동으로 호출합니다.</target>
        </trans-unit>
        <trans-unit id="dbf75453e1d8ee103bca7101c95d3ea1b66bfa1e" translate="yes" xml:space="preserve">
          <source>A file that Emacs visits can contain variable settings that affect the buffer visiting that file; See &lt;a href=&quot;file-local-variables#File-Local-Variables&quot;&gt;File Local Variables&lt;/a&gt;. Similarly, a directory can specify local variable values common to all files in that directory; see &lt;a href=&quot;directory-local-variables#Directory-Local-Variables&quot;&gt;Directory Local Variables&lt;/a&gt;. Although Emacs takes some effort to protect against misuse of these variables, a security hole can be created merely by a package setting &lt;code&gt;safe-local-variable&lt;/code&gt; too optimistically, a problem that is all too common. To disable this feature for both files and directories, set &lt;code&gt;enable-local-variables&lt;/code&gt; to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Emacs가 방문하는 파일에는 해당 파일을 방문하는 버퍼에 영향을주는 변수 설정이 포함될 수 있습니다. &lt;a href=&quot;file-local-variables#File-Local-Variables&quot;&gt;파일 로컬 변수를&lt;/a&gt; 참조하십시오 . 마찬가지로 디렉토리는 해당 디렉토리의 모든 파일에 공통적 인 로컬 변수 값을 지정할 수 있습니다. &lt;a href=&quot;directory-local-variables#Directory-Local-Variables&quot;&gt;디렉토리 로컬 변수를&lt;/a&gt; 참조하십시오 . Emacs는 이러한 변수의 오용을 방지하기 위해 약간의 노력을 기울이지 만, 패키지가 &lt;code&gt;safe-local-variable&lt;/code&gt; 을 너무 낙관적으로 설정하는 것만으로도 보안 허점을 만들 수 있습니다 . 이는 모두 너무 흔한 문제입니다. 파일과 디렉토리 모두에 대해이 기능을 비활성화하려면 &lt;code&gt;enable-local-variables&lt;/code&gt; 를 &lt;code&gt;nil&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="3266b8d29b93dc1eee17b5d16810b5e1424e98d5" translate="yes" xml:space="preserve">
          <source>A filter function must accept two arguments: the associated process and a string, which is output just received from it. The function is then free to do whatever it chooses with the output.</source>
          <target state="translated">필터 함수는 두 개의 인수, 즉 연관된 프로세스와 방금받은 출력 인 문자열을 받아야합니다. 그러면이 함수는 출력으로 선택한 모든 작업을 자유롭게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e7a297c1c489e864c66d0212903cca52a20067e" translate="yes" xml:space="preserve">
          <source>A first argument of &lt;code&gt;lambda&lt;/code&gt; means &lt;code&gt;debug&lt;/code&gt; was called because of entry to a function when &lt;code&gt;debug-on-next-call&lt;/code&gt; was non-&lt;code&gt;nil&lt;/code&gt;. The debugger displays &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;lambda&lt;/code&gt; 의 첫 번째 인수는 &lt;code&gt;debug-on-next-call&lt;/code&gt; 이 non - &lt;code&gt;nil&lt;/code&gt; 일 때 함수에 대한 항목으로 인해 &lt;code&gt;debug&lt;/code&gt; 가 호출 되었음을 의미 합니다. 디버거에 '</target>
        </trans-unit>
        <trans-unit id="e8ddb397b9ffeb8426670eadecdce6f5c08372fe" translate="yes" xml:space="preserve">
          <source>A five-element vector &lt;code&gt;[&lt;var&gt;a&lt;/var&gt; &lt;var&gt;b&lt;/var&gt; &lt;var&gt;c&lt;/var&gt; &lt;var&gt;d&lt;/var&gt; &lt;var&gt;p&lt;/var&gt;]&lt;/code&gt; represents an IPv4 address &lt;var&gt;a&lt;/var&gt;.&lt;var&gt;b&lt;/var&gt;.&lt;var&gt;c&lt;/var&gt;.&lt;var&gt;d&lt;/var&gt; and port number &lt;var&gt;p&lt;/var&gt;. &lt;code&gt;format-network-address&lt;/code&gt; converts that to the string &lt;code&gt;&quot;&lt;var&gt;a&lt;/var&gt;.&lt;var&gt;b&lt;/var&gt;.&lt;var&gt;c&lt;/var&gt;.&lt;var&gt;d&lt;/var&gt;:&lt;var&gt;p&lt;/var&gt;&quot;&lt;/code&gt;.</source>
          <target state="translated">요소가 다섯 개인 벡터 &lt;code&gt;[&lt;var&gt;a&lt;/var&gt; &lt;var&gt;b&lt;/var&gt; &lt;var&gt;c&lt;/var&gt; &lt;var&gt;d&lt;/var&gt; &lt;var&gt;p&lt;/var&gt;]&lt;/code&gt; 는 IPv4 주소 &lt;var&gt;a&lt;/var&gt; 를 나타냅니다 . &lt;var&gt;b&lt;/var&gt; . &lt;var&gt;c&lt;/var&gt; . &lt;var&gt;d&lt;/var&gt; 및 포트 번호 &lt;var&gt;p&lt;/var&gt; . &lt;code&gt;format-network-address&lt;/code&gt; 는이를 문자열 &lt;code&gt;&quot;&lt;var&gt;a&lt;/var&gt;.&lt;var&gt;b&lt;/var&gt;.&lt;var&gt;c&lt;/var&gt;.&lt;var&gt;d&lt;/var&gt;:&lt;var&gt;p&lt;/var&gt;&quot;&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="294aaabae5d3488734428644aba3718cfd7199de" translate="yes" xml:space="preserve">
          <source>A flag specifying the type of completion operation to perform; see &lt;a href=&quot;basic-completion#Basic-Completion&quot;&gt;Basic Completion&lt;/a&gt;, for the details of those operations. This flag may be one of the following values.</source>
          <target state="translated">수행 할 완료 작업 유형을 지정하는 플래그입니다. 이러한 작업에 대한 자세한 내용 은 &lt;a href=&quot;basic-completion#Basic-Completion&quot;&gt;기본 완료를&lt;/a&gt; 참조하십시오 . 이 플래그는 다음 값 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85c834e95015be4c5179423bef79b80cc4828fe4" translate="yes" xml:space="preserve">
          <source>A flag, &lt;code&gt;t&lt;/code&gt; if &lt;code&gt;format-write-file&lt;/code&gt; should not remove this format from &lt;code&gt;buffer-file-format&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;format-write-file&lt;/code&gt; 이 &lt;code&gt;buffer-file-format&lt;/code&gt; 에서이 형식을 제거하지 않아야하는 경우 플래그 &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c0b2bfadb17694a552c0239a8fd611c0d489e7e" translate="yes" xml:space="preserve">
          <source>A flag, &lt;code&gt;t&lt;/code&gt; if the encoding function modifies the buffer, and &lt;code&gt;nil&lt;/code&gt; if it works by returning a list of annotations.</source>
          <target state="translated">플래그, 인코딩 함수가 버퍼를 수정하는 경우 &lt;code&gt;t&lt;/code&gt; , 주석 목록을 반환하여 작동하는 경우 &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="19d7f1cfc631bf26b90fef20742acf5f863fc6f4" translate="yes" xml:space="preserve">
          <source>A flag, &lt;code&gt;t&lt;/code&gt; if this is really a child process. For a network or serial connection, it is a plist based on the arguments to &lt;code&gt;make-network-process&lt;/code&gt; or &lt;code&gt;make-serial-process&lt;/code&gt;.</source>
          <target state="translated">이것이 정말로 자식 프로세스라면 플래그, &lt;code&gt;t&lt;/code&gt; . 네트워크 또는 직렬 연결의 경우 &lt;code&gt;make-network-process&lt;/code&gt; 또는 &lt;code&gt;make-serial-process&lt;/code&gt; 에 대한 인수를 기반으로하는 plist 입니다.</target>
        </trans-unit>
        <trans-unit id="d522ef7e7a7eea406919509b9022d018c559d736" translate="yes" xml:space="preserve">
          <source>A floating-point number between 0.0 and 1.0 can be used to specify the width of a frame via its &lt;em&gt;width ratio&lt;/em&gt;&amp;mdash;the ratio of its outer width (see &lt;a href=&quot;frame-geometry#Frame-Geometry&quot;&gt;Frame Geometry&lt;/a&gt;) to the width of the frame&amp;rsquo;s workarea (see &lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;Multiple Terminals&lt;/a&gt;) or its parent frame&amp;rsquo;s (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;) native frame. Thus, a value of 0.5 makes the frame occupy half of the width of its workarea or parent frame, a value of 1.0 the full width. Similarly, the &lt;em&gt;height ratio&lt;/em&gt; of a frame is the ratio of its outer height to the height of its workarea or its parent&amp;rsquo;s native frame.</source>
          <target state="translated">0.0에서 1.0 사이의 부동 소수점 숫자를 사용하여 &lt;em&gt;너비 비율&lt;/em&gt; ( 프레임의 작업 영역 ( &lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;다중 터미널&lt;/a&gt; 참조 ) 또는 부모의 너비에 대한 외부 너비 ( &lt;a href=&quot;frame-geometry#Frame-Geometry&quot;&gt;프레임 형상&lt;/a&gt; 참조 ))의 비율을 통해 프레임 너비를 지정할 수 있습니다. 프레임의 ( &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;하위 프레임&lt;/a&gt; 참조 ) 기본 프레임. 따라서 값이 0.5이면 프레임이 작업 영역 또는 상위 프레임 너비의 절반을 차지하고 값 1.0은 전체 너비를 차지합니다. 마찬가지로 프레임 의 &lt;em&gt;높이 비율&lt;/em&gt; 은 작업 영역 또는 부모의 기본 프레임 높이에 대한 외부 높이의 비율입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="40f779f8938b4859342b30f78c216850c870ebc3" translate="yes" xml:space="preserve">
          <source>A floating-point number specifies the fraction of the chosen window&amp;rsquo;s desired total height with respect to the total height of its frame&amp;rsquo;s root window.</source>
          <target state="translated">부동 소수점 숫자는 프레임 루트 창의 총 높이에 대해 선택한 창의 원하는 총 높이의 비율을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="7b2c9b14e103c32f399869f8f372059ff0758de1" translate="yes" xml:space="preserve">
          <source>A floating-point number specifies the fraction of the chosen window&amp;rsquo;s desired total width with respect to the total width of the frame&amp;rsquo;s root window.</source>
          <target state="translated">부동 소수점 숫자는 프레임 루트 창의 총 너비에 대해 선택한 창의 원하는 총 너비의 비율을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="859a186fe1d162639532b367f483e64bb540ab2b" translate="yes" xml:space="preserve">
          <source>A floating-point value in the range 0.0 to 1.0 specifies the left edge&amp;rsquo;s offset via the &lt;em&gt;left position ratio&lt;/em&gt; of the frame&amp;mdash;the ratio of the left edge of its outer frame to the width of the frame&amp;rsquo;s workarea (see &lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;Multiple Terminals&lt;/a&gt;) or its parent&amp;rsquo;s native frame (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;) minus the width of the outer frame. Thus, a left position ratio of 0.0 flushes a frame to the left, a ratio of 0.5 centers it and a ratio of 1.0 flushes it to the right of its display or parent frame. Similarly, the &lt;em&gt;top position ratio&lt;/em&gt; of a frame is the ratio of the frame&amp;rsquo;s top position to the height of its workarea or parent frame minus the height of the frame.</source>
          <target state="translated">0.0에서 1.0 범위의 부동 소수점 값 은 프레임 의 &lt;em&gt;왼쪽 위치 비율 (&lt;/em&gt; 외부 프레임의 왼쪽 가장자리와 프레임의 작업 영역 ( &lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;다중 터미널&lt;/a&gt; 참조 ) 또는 상위 프레임의 너비에 대한 &lt;em&gt;비율)&lt;/em&gt; 을 통해 왼쪽 가장자리의 오프셋을 지정합니다. 기본 프레임 ( &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;하위 프레임&lt;/a&gt; 참조 )에서 외부 프레임의 너비를 뺀 값입니다. 따라서 왼쪽 위치 비율이 0.0이면 프레임이 왼쪽으로 플러시되고 비율이 0.5이면 중앙에, 1.0의 비율은 해당 디스플레이 또는 상위 프레임의 오른쪽으로 플러시됩니다. 마찬가지로, &lt;em&gt;상부 위치 비율&lt;/em&gt; 의 프레임은 Workarea에 또는 상위 프레임의 높이를 뺀 프레임의 높이와 상기 프레임의 상부 위치의 비이다.</target>
        </trans-unit>
        <trans-unit id="17ea726a541eca726a5fb0cd7e030f18bf5f479f" translate="yes" xml:space="preserve">
          <source>A focus event in the middle of a key sequence would garble the sequence. So Emacs never generates a focus event in the middle of a key sequence. If the user changes focus in the middle of a key sequence&amp;mdash;that is, after a prefix key&amp;mdash;then Emacs reorders the events so that the focus event comes either before or after the multi-event key sequence, and not within it.</source>
          <target state="translated">키 시퀀스 중간에 포커스 이벤트가 있으면 시퀀스가 ​​왜곡됩니다. 따라서 Emacs는 키 시퀀스 중간에 포커스 이벤트를 생성하지 않습니다. 사용자가 키 시퀀스 중간 (즉, 접두사 키 뒤)에서 포커스를 변경하면 Emacs는 이벤트를 재정렬하여 포커스 이벤트가 다중 이벤트 키 시퀀스 내부가 아니라 앞뒤로 오도록합니다.</target>
        </trans-unit>
        <trans-unit id="f412cfc73d389d8e515cd608573b4a6a5a02234e" translate="yes" xml:space="preserve">
          <source>A font entity is a reference to a font that need not be open. Its properties are intermediate between a font object and a font spec: like a font object, and unlike a font spec, it refers to a single, specific font. Unlike a font object, creating a font entity does not load the contents of that font into computer memory. Emacs may open multiple font objects of different sizes from a single font entity referring to a scalable font.</source>
          <target state="translated">글꼴 엔티티는 열 필요가없는 글꼴에 대한 참조입니다. 해당 속성은 글꼴 개체와 글꼴 사양 사이의 중간입니다. 글꼴 개체처럼 글꼴 사양과 달리 단일 특정 글꼴을 참조합니다. 글꼴 개체와 달리 글꼴 엔티티를 만들면 해당 글꼴의 내용이 컴퓨터 메모리에로드되지 않습니다. Emacs는 확장 가능한 글꼴을 참조하는 단일 글꼴 엔티티에서 크기가 다른 여러 글꼴 개체를 열 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d5b0425b5a94a9e9802d46b457503ba1cbe0cfe" translate="yes" xml:space="preserve">
          <source>A font object is a Lisp object that represents a font that Emacs has &lt;em&gt;opened&lt;/em&gt;. Font objects cannot be modified in Lisp, but they can be inspected.</source>
          <target state="translated">font 객체는 Emacs가 &lt;em&gt;연&lt;/em&gt; 글꼴을 나타내는 Lisp 객체입니다 . Lisp에서는 글꼴 개체를 수정할 수 없지만 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="515cc00d7f4cb95d05c8cecf8f1e5c3622cbf2f8" translate="yes" xml:space="preserve">
          <source>A font spec is a Lisp object that contains a set of specifications that can be used to find a font. More than one font may match the specifications in a font spec.</source>
          <target state="translated">글꼴 사양은 글꼴을 찾는 데 사용할 수있는 사양 집합을 포함하는 Lisp 개체입니다. 둘 이상의 글꼴이 글꼴 사양의 사양과 일치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fbb519c5d7bda3b24f3aefb7d9c3e252c108c2df" translate="yes" xml:space="preserve">
          <source>A fontset is a collection of fonts that handle a range of character sets.</source>
          <target state="translated">글꼴 집합은 다양한 문자 집합을 처리하는 글꼴 모음입니다.</target>
        </trans-unit>
        <trans-unit id="b1d4702f683ffb2a5355d8008fca5fe3ad8ec6be" translate="yes" xml:space="preserve">
          <source>A form that is a nonempty list is either a function call, a macro call, or a special form, according to its first element. These three kinds of forms are evaluated in different ways, described below. The remaining list elements constitute the &lt;em&gt;arguments&lt;/em&gt; for the function, macro, or special form.</source>
          <target state="translated">비어 있지 않은 목록 인 양식은 첫 번째 요소에 따라 함수 호출, 매크로 호출 또는 특수 양식입니다. 이 세 종류의 양식은 아래에 설명 된대로 다른 방식으로 평가됩니다. 나머지 목록 요소 는 함수, 매크로 또는 특수 형식에 대한 &lt;em&gt;인수&lt;/em&gt; 를 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="a12bc97651e58ff453885efcc98152a3b21b8d9d" translate="yes" xml:space="preserve">
          <source>A format specification can have a &lt;em&gt;field number&lt;/em&gt;, which is a decimal number immediately after the initial &amp;lsquo;</source>
          <target state="translated">형식 사양은 &lt;em&gt;필드 번호를&lt;/em&gt; 가질 수 있습니다. &lt;em&gt;필드 번호&lt;/em&gt; 는 처음 '</target>
        </trans-unit>
        <trans-unit id="c8844cc8b244f02d7287631d0e9e57e8bd2d710d" translate="yes" xml:space="preserve">
          <source>A format specification can include any number of the following flag characters immediately after the &amp;lsquo;</source>
          <target state="translated">형식 스펙은 '바로 뒤에 다음 플래그 문자를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33f8eb1db79183d4a02ee42a34f4def26f563ba0" translate="yes" xml:space="preserve">
          <source>A format specification is a sequence of characters beginning with a &amp;lsquo;</source>
          <target state="translated">형식 사양은 '로 시작하는 일련의 문자입니다.</target>
        </trans-unit>
        <trans-unit id="087e2b9c7736fb58cedc9236190680cf120fd098" translate="yes" xml:space="preserve">
          <source>A frame has many parameters that control its appearance and behavior. Just what parameters a frame has depends on what display mechanism it uses.</source>
          <target state="translated">프레임에는 모양과 동작을 제어하는 ​​많은 매개 변수가 있습니다. 프레임에 어떤 매개 변수가 있는지는 사용하는 디스플레이 메커니즘에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="8bed1cbe065649aba77e0f7bf1ff4e6629da4bbb" translate="yes" xml:space="preserve">
          <source>A frame initially contains a single main window and/or a minibuffer window; you can subdivide the main window vertically or horizontally into smaller windows. See &lt;a href=&quot;splitting-windows#Splitting-Windows&quot;&gt;Splitting Windows&lt;/a&gt;.</source>
          <target state="translated">프레임은 처음에 단일 주 창 및 / 또는 미니 버퍼 창을 포함합니다. 주 창을 세로 또는 가로로 작은 창으로 세분화 할 수 있습니다. &lt;a href=&quot;splitting-windows#Splitting-Windows&quot;&gt;창 분할을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="593d0194673ec750d2ada7934d7770635b502d64" translate="yes" xml:space="preserve">
          <source>A frame is &lt;em&gt;dominated&lt;/em&gt; by a physical monitor when either the largest area of the frame resides in that monitor, or (if the frame does not intersect any physical monitors) that monitor is the closest to the frame. Every (non-tooltip) frame (whether visible or not) in a graphical display is dominated by exactly one physical monitor at a time, though the frame can span multiple (or no) physical monitors.</source>
          <target state="translated">프레임 의 가장 큰 영역이 해당 모니터에 있거나 (프레임이 물리적 모니터와 교차하지 않는 경우) 해당 모니터가 프레임에 가장 가까운 경우 실제 모니터 가 프레임을 &lt;em&gt;지배&lt;/em&gt; 합니다. 그래픽 디스플레이의 모든 (도구 설명이 아닌) 프레임 (표시 여부에 관계없이)은 한 번에 정확히 하나의 물리적 모니터에 의해 지배되지만 프레임은 여러 물리적 모니터에 걸쳐있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="93e41b196f539a42aa80f80a422bd9a7138a3f5f" translate="yes" xml:space="preserve">
          <source>A frame means consider windows on that frame only.</source>
          <target state="translated">프레임은 해당 프레임의 창만 고려함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0ac0546e4fcf2e06468d2e59e1b006fdfd50ee70" translate="yes" xml:space="preserve">
          <source>A frame means operate on that frame.</source>
          <target state="translated">프레임은 해당 프레임에서 작동 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="56626d51f944fb36b16d03134023ca4666a8b106" translate="yes" xml:space="preserve">
          <source>A frame means to consider windows on that specific frame.</source>
          <target state="translated">프레임은 특정 프레임의 창을 고려하는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="68b2b2ef5f1170f2f9547a6799c6765e7406978b" translate="yes" xml:space="preserve">
          <source>A frame on a graphical display may be &lt;em&gt;visible&lt;/em&gt;, &lt;em&gt;invisible&lt;/em&gt;, or &lt;em&gt;iconified&lt;/em&gt;. If it is visible, its contents are displayed in the usual manner. If it is iconified, its contents are not displayed, but there is a little icon somewhere to bring the frame back into view (some window managers refer to this state as &lt;em&gt;minimized&lt;/em&gt; rather than &lt;em&gt;iconified&lt;/em&gt;, but from Emacs&amp;rsquo; point of view they are the same thing). If a frame is invisible, it is not displayed at all.</source>
          <target state="translated">그래픽 디스플레이의 프레임 일 수있다 &lt;em&gt;보이는&lt;/em&gt; , &lt;em&gt;투명&lt;/em&gt; 또는 &lt;em&gt;아이콘 화&lt;/em&gt; . 보이는 경우 내용이 일반적인 방식으로 표시됩니다. 아이콘 화 된 경우 내용이 표시되지 않지만 프레임을 다시보기 위해 어딘가에 작은 아이콘이 있습니다 (일부 창 관리자는이 상태를 &lt;em&gt;아이콘 화 된&lt;/em&gt; 것이 아니라 &lt;em&gt;최소화 된&lt;/em&gt; 것으로 언급 하지만 Emacs의 관점에서는 동일합니다 맡은 일). 프레임이 보이지 않으면 전혀 표시되지 않습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ae91a9bb638c7946c6a95ecd4004f1135f49e80a" translate="yes" xml:space="preserve">
          <source>A frame that is moved with the mouse will &amp;ldquo;snap&amp;rdquo; at the border(s) of the display or its parent frame whenever it is dragged as near to such an edge as the number of pixels specified by this parameter.</source>
          <target state="translated">마우스로 이동 한 프레임은이 매개 변수로 지정된 픽셀 수와 같은 가장자리에 가깝게 드래그 할 때마다 디스플레이의 테두리 또는 상위 프레임에 &quot;스냅&quot;됩니다.</target>
        </trans-unit>
        <trans-unit id="670133cb3dcebb82274414d4049e8b018c47f4e1" translate="yes" xml:space="preserve">
          <source>A full explanation of these matters is outside the scope of this manual. For more information on cryptographic keys and signing, see &lt;a href=&quot;http://www.gnupg.org/documentation/manuals/gnupg/index.html#Top&quot;&gt;GnuPG&lt;/a&gt; in</source>
          <target state="translated">이러한 문제에 대한 전체 설명은이 설명서의 범위를 벗어납니다. 암호화 키 및 서명에 대한 자세한 내용은 다음에서 &lt;a href=&quot;http://www.gnupg.org/documentation/manuals/gnupg/index.html#Top&quot;&gt;GnuPG&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b59af6565c9508dfc20c12f2304360ecea3059d7" translate="yes" xml:space="preserve">
          <source>A full keymap for</source>
          <target state="translated">에 대한 전체 키맵</target>
        </trans-unit>
        <trans-unit id="5e8dd76e935bb817d46b7e5de1c0f84394fd67d9" translate="yes" xml:space="preserve">
          <source>A full keymap is more efficient than a sparse keymap when it holds lots of bindings; for just a few, the sparse keymap is better.</source>
          <target state="translated">바인딩이 많은 경우 전체 키맵이 희소 키맵보다 더 효율적입니다. 소수의 경우 희소 키맵이 더 좋습니다.</target>
        </trans-unit>
        <trans-unit id="49a156dad931da06b08d870486bd7a2b697afdab" translate="yes" xml:space="preserve">
          <source>A full keymap used by the help utility package. It has the same keymap in its value cell and in its function cell.</source>
          <target state="translated">도움말 유틸리티 패키지에서 사용하는 전체 키맵입니다. 값 셀과 기능 셀에 동일한 키맵이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6509b7476dce0a2a745fa522309b5b12d6ec47f5" translate="yes" xml:space="preserve">
          <source>A full keymap used in the minibuffer when it is not active. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Minibuffer-Edit.html#Minibuffer-Edit&quot;&gt;Editing in the Minibuffer&lt;/a&gt; in</source>
          <target state="translated">미니 버퍼가 활성 상태가 아닐 때 사용되는 전체 키맵입니다. &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Minibuffer-Edit.html#Minibuffer-Edit&quot;&gt;미니 버퍼&lt;/a&gt; 에서 편집을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4bbb4ffda897b3f130c2ffc336b839e6d176be06" translate="yes" xml:space="preserve">
          <source>A function (in the strict sense, i.e., a function object) which is written in Lisp. These are described in the following section. See &lt;a href=&quot;lambda-expressions#Lambda-Expressions&quot;&gt;Lambda Expressions&lt;/a&gt;.</source>
          <target state="translated">Lisp로 작성된 함수 (엄격한 의미, 즉 함수 객체). 이에 대해서는 다음 섹션에서 설명합니다. &lt;a href=&quot;lambda-expressions#Lambda-Expressions&quot;&gt;Lambda 표현식을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="67975cc366b5448faeb9a64ea486c485cf194102" translate="yes" xml:space="preserve">
          <source>A function form: either a quoted function symbol, a quoted lambda expression, or a form (that should evaluate to a function symbol or lambda expression). This is useful when an argument that&amp;rsquo;s a lambda expression might be quoted with &lt;code&gt;quote&lt;/code&gt; rather than &lt;code&gt;function&lt;/code&gt;, since it instruments the body of the lambda expression either way.</source>
          <target state="translated">함수 형식 : 인용 된 함수 기호, 인용 된 람다 식 또는 형식 (함수 기호 또는 람다 식으로 평가되어야 함). 이것은 람다 식인 인수 가 &lt;code&gt;function&lt;/code&gt; 대신 따옴표로 &lt;code&gt;quote&lt;/code&gt; 될 때 유용합니다. 람다 식 의 본문을 어느 쪽이든 계측하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="74cc8825cac1c75201b5a72537a42bcaa095f7bf" translate="yes" xml:space="preserve">
          <source>A function in &lt;code&gt;completion-at-point-functions&lt;/code&gt; may also return a function instead of a list as described above. In that case, that returned function is called, with no argument, and it is entirely responsible for performing the completion. We discourage this usage; it is only intended to help convert old code to using &lt;code&gt;completion-at-point&lt;/code&gt;.</source>
          <target state="translated">의 함수 &lt;code&gt;completion-at-point-functions&lt;/code&gt; 또한 상술 한 바와 같이리스트 대신 함수를 반환 할 수있다. 이 경우 반환 된 함수가 인수없이 호출되며 완료를 수행하는 데 전적으로 책임이 있습니다. 이 사용을 권장하지 않습니다. 이전 코드를 &lt;code&gt;completion-at-point&lt;/code&gt; 사용으로 변환하는 데 도움을주기위한 것 입니다.</target>
        </trans-unit>
        <trans-unit id="3967a503993e60af7034808c468508aae1885fb4" translate="yes" xml:space="preserve">
          <source>A function is a Lisp program that can be invoked from other functions.</source>
          <target state="translated">함수는 다른 함수에서 호출 할 수있는 Lisp 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="88717033307ab176f0284b52276d93ae668d8d38" translate="yes" xml:space="preserve">
          <source>A function is never considered to be called interactively if it was called via Lisp evaluation (or with &lt;code&gt;apply&lt;/code&gt; or &lt;code&gt;funcall&lt;/code&gt;).</source>
          <target state="translated">Lisp 평가 (또는 &lt;code&gt;apply&lt;/code&gt; 또는 &lt;code&gt;funcall&lt;/code&gt; 사용 ) 를 통해 호출 된 함수는 대화식으로 호출되는 것으로 간주되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="45f7858322522afa6344fc4aadc6540f15152ac3" translate="yes" xml:space="preserve">
          <source>A function name (i.e., a symbol satisfying &lt;code&gt;fboundp&lt;/code&gt;). Existing, Completion, Prompt.</source>
          <target state="translated">함수 이름 (즉, &lt;code&gt;fboundp&lt;/code&gt; 를 충족하는 기호 ). 기존, 완료, 프롬프트.</target>
        </trans-unit>
        <trans-unit id="6604e0025d3d7acaa51d09313c30002d7a8a0abd" translate="yes" xml:space="preserve">
          <source>A function need not have a unique name. A given function object &lt;em&gt;usually&lt;/em&gt; appears in the function cell of only one symbol, but this is just a convention. It is easy to store it in several symbols using &lt;code&gt;fset&lt;/code&gt;; then each of the symbols is a valid name for the same function.</source>
          <target state="translated">함수에는 고유 한 이름이 필요하지 않습니다. 주어진 함수 객체는 &lt;em&gt;일반적으로&lt;/em&gt; 하나의 심볼의 함수 셀에 나타나지만 이는 단지 관례 일뿐입니다. &lt;code&gt;fset&lt;/code&gt; 을 사용하여 여러 심볼에 저장하는 것은 쉽습니다 . 각 기호는 동일한 기능에 대해 유효한 이름입니다.</target>
        </trans-unit>
        <trans-unit id="8cefa34de359ec87bedfc8878b6eeae0d47b4baa" translate="yes" xml:space="preserve">
          <source>A function object that is much like a lambda expression, except that it also encloses an environment of lexical variable bindings. See &lt;a href=&quot;closures#Closures&quot;&gt;Closures&lt;/a&gt;.</source>
          <target state="translated">어휘 변수 바인딩 환경을 포함한다는 점을 제외하면 람다 식과 매우 유사한 함수 개체입니다. &lt;a href=&quot;closures#Closures&quot;&gt;폐쇄를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4f48b6522b5235b501de8a062f2f445bd67cb08a" translate="yes" xml:space="preserve">
          <source>A function run by Edebug after it wraps the body of a definition or closure. After Edebug has initialized its own data, this function is called with one argument, the symbol associated with the definition, which may be the actual symbol defined or one generated by Edebug. This function may be used to set the &lt;code&gt;edebug-behavior&lt;/code&gt; symbol property of each definition instrumented by Edebug.</source>
          <target state="translated">정의 또는 클로저의 본문을 래핑 한 후 Edebug가 실행하는 함수입니다. Edebug가 자체 데이터를 초기화 한 후이 함수는 하나의 인수, 정의와 연관된 기호로 호출됩니다. 이는 정의 된 실제 기호이거나 Edebug에서 생성 한 것일 수 있습니다. 이 함수는 &lt;code&gt;edebug-behavior&lt;/code&gt; 계측 한 각 정의 의 edebug-behavior 심볼 속성 을 설정하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c7a8cbef03050f5100566a91d08438e778fff88b" translate="yes" xml:space="preserve">
          <source>A function run just before redisplay. It is called with one argument, the set of windows to be redisplayed. The set can be &lt;code&gt;nil&lt;/code&gt;, meaning only the selected window, or &lt;code&gt;t&lt;/code&gt;, meaning all the windows.</source>
          <target state="translated">다시 표시하기 직전에 실행되는 함수입니다. 다시 표시 할 창 집합 인 하나의 인수로 호출됩니다. 집합은 선택한 창만 의미하는 &lt;code&gt;nil&lt;/code&gt; 또는 모든 창을 의미하는 &lt;code&gt;t&lt;/code&gt; 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2170a7820bb4235d6aaed2f87dfc349064f9aeed" translate="yes" xml:space="preserve">
          <source>A function that has been compiled by the byte compiler. See &lt;a href=&quot;byte_002dcode-type#Byte_002dCode-Type&quot;&gt;Byte-Code Type&lt;/a&gt;.</source>
          <target state="translated">바이트 컴파일러에 의해 컴파일 된 함수입니다. &lt;a href=&quot;byte_002dcode-type#Byte_002dCode-Type&quot;&gt;바이트 코드 유형을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="514106b81c0fc955cf778a8f7e3aa693d74773cb" translate="yes" xml:space="preserve">
          <source>A function that takes three arguments&amp;mdash;the &lt;var&gt;window&lt;/var&gt; argument of &lt;code&gt;switch-to-prev-buffer&lt;/code&gt;, a buffer &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; intends to switch to and the &lt;var&gt;bury-or-kill&lt;/var&gt; argument of &lt;code&gt;switch-to-prev-buffer&lt;/code&gt;. If that function returns non-&lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; will refrain from switching to the buffer specified by the second argument.</source>
          <target state="translated">세 가지 인수 - 더 걸리는 기능 &lt;var&gt;window&lt;/var&gt; 의 인수 &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; , 버퍼 &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; 로 전환하고자하고, &lt;var&gt;bury-or-kill&lt;/var&gt; 의 인수 &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; . 그 기능은 비 - 반환하면 &lt;code&gt;nil&lt;/code&gt; , &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; 두 번째 인수에 의해 지정된 버퍼로 전환 자제한다.</target>
        </trans-unit>
        <trans-unit id="19663365a712443cf17b0462d9e95ba641121528" translate="yes" xml:space="preserve">
          <source>A function which is callable from Lisp but is actually written in C. Primitives are also called &lt;em&gt;built-in functions&lt;/em&gt;, or &lt;em&gt;subrs&lt;/em&gt;. Examples include functions like &lt;code&gt;car&lt;/code&gt; and &lt;code&gt;append&lt;/code&gt;. In addition, all special forms (see below) are also considered primitives.</source>
          <target state="translated">Lisp에서 호출 할 수 있지만 실제로 C로 작성된 함수입니다. Primitives는 &lt;em&gt;내장 함수&lt;/em&gt; 또는 &lt;em&gt;subrs라고도&lt;/em&gt; 합니다. 예를 들면 &lt;code&gt;car&lt;/code&gt; 및 &lt;code&gt;append&lt;/code&gt; 와 같은 함수가 있습니다. 또한 모든 특수 형식 (아래 참조)도 기본 형식으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="1b46c595245dc0dbb005afc3ecbbdd47644569b0" translate="yes" xml:space="preserve">
          <source>A function written in C, callable from Lisp.</source>
          <target state="translated">Lisp에서 호출 할 수있는 C로 작성된 함수.</target>
        </trans-unit>
        <trans-unit id="de877f0e31d6955ec95f1fb5f2fd10d5638c9689" translate="yes" xml:space="preserve">
          <source>A function written in Lisp, then compiled.</source>
          <target state="translated">Lisp로 작성된 후 컴파일 된 함수.</target>
        </trans-unit>
        <trans-unit id="c9d8c9cc7681ee2ca63be007d65e384b9608592a" translate="yes" xml:space="preserve">
          <source>A general syntax for cons cells.</source>
          <target state="translated">단점 셀의 일반 구문입니다.</target>
        </trans-unit>
        <trans-unit id="137d4bfab02523c448bc31f5a48ba6b6d8486e12" translate="yes" xml:space="preserve">
          <source>A generalized variable. See &lt;a href=&quot;generalized-variables#Generalized-Variables&quot;&gt;Generalized Variables&lt;/a&gt;.</source>
          <target state="translated">일반화 된 변수. &lt;a href=&quot;generalized-variables#Generalized-Variables&quot;&gt;일반화 변수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4ebf8b963e8ef8255cbf815c795b5ed45d06bb96" translate="yes" xml:space="preserve">
          <source>A generic function specifies an abstract operation, by defining its name and list of arguments, but (usually) no implementation. The actual implementation for several specific classes of arguments is provided by &lt;em&gt;methods&lt;/em&gt;, which should be defined separately. Each method that implements a generic function has the same name as the generic function, but the method&amp;rsquo;s definition indicates what kinds of arguments it can handle by &lt;em&gt;specializing&lt;/em&gt; the arguments defined by the generic function. These &lt;em&gt;argument specializers&lt;/em&gt; can be more or less specific; for example, a &lt;code&gt;string&lt;/code&gt; type is more specific than a more general type, such as &lt;code&gt;sequence&lt;/code&gt;.</source>
          <target state="translated">일반 함수는 이름과 인수 목록을 정의하여 추상 작업을 지정하지만 일반적으로 구현은 없습니다. 몇 가지 특정 인수 클래스에 대한 실제 구현은 별도로 정의해야하는 &lt;em&gt;methods&lt;/em&gt; 에 의해 제공됩니다 . 제네릭 함수를 구현하는 각 메서드는 제네릭 함수와 이름이 같지만 메서드의 정의는 제네릭 함수에서 정의한 인수 를 &lt;em&gt;특수화&lt;/em&gt; 하여 처리 할 수있는 인수의 종류를 나타냅니다 . 이러한 &lt;em&gt;주장 전문가&lt;/em&gt; 는 다소 구체적 일 수 있습니다. 예를 들어 &lt;code&gt;string&lt;/code&gt; 유형은 &lt;code&gt;sequence&lt;/code&gt; 와 같은보다 일반적인 유형보다 더 구체적 입니다.</target>
        </trans-unit>
        <trans-unit id="ce1f0389bfeda46a5ea7bd2acc7f288b0381d8d8" translate="yes" xml:space="preserve">
          <source>A good indentation function will usually need to actually parse the text, according to the syntax of the language. Luckily, it is not necessary to parse the text in as much detail as would be needed for a compiler, but on the other hand, the parser embedded in the indentation code will want to be somewhat friendly to syntactically incorrect code.</source>
          <target state="translated">좋은 들여 쓰기 기능은 일반적으로 언어 구문에 따라 실제로 텍스트를 구문 분석해야합니다. 운 좋게도 컴파일러에 필요한만큼 세부적으로 텍스트를 구문 분석 할 필요는 없지만, 반면 들여 쓰기 코드에 포함 된 구문 분석기는 구문 적으로 잘못된 코드에 다소 친숙해지기를 원할 것입니다.</target>
        </trans-unit>
        <trans-unit id="3411c17220662ceffaaf0e39a2c3512afe57639f" translate="yes" xml:space="preserve">
          <source>A hash table (see &lt;a href=&quot;hash-table-type#Hash-Table-Type&quot;&gt;Hash Table Type&lt;/a&gt;).</source>
          <target state="translated">해시 테이블 ( &lt;a href=&quot;hash-table-type#Hash-Table-Type&quot;&gt;Hash Table Type&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="cb7e4bf96a133b1dfdd48a75ed263d4f15112488" translate="yes" xml:space="preserve">
          <source>A hash table is a very fast kind of lookup table, somewhat like an alist (see &lt;a href=&quot;association-lists#Association-Lists&quot;&gt;Association Lists&lt;/a&gt;) in that it maps keys to corresponding values. It differs from an alist in these ways:</source>
          <target state="translated">해시 테이블은 키를 해당 값에 매핑한다는 점에서 alist ( &lt;a href=&quot;association-lists#Association-Lists&quot;&gt;Association Lists&lt;/a&gt; 참조)와 다소 유사한 매우 빠른 종류의 조회 테이블 입니다. 다음과 같은 점에서 alist와 다릅니다.</target>
        </trans-unit>
        <trans-unit id="5f8d7c7212fe9badba0bb89235cd56e06f21bd8a" translate="yes" xml:space="preserve">
          <source>A hash table is a very fast kind of lookup table, somewhat like an alist in that it maps keys to corresponding values, but much faster. The printed representation of a hash table specifies its properties and contents, like this:</source>
          <target state="translated">해시 테이블은 키를 해당 값에 매핑한다는 점에서 alist와 비슷하지만 훨씬 빠르다는 점에서 매우 빠른 종류의 조회 테이블입니다. 해시 테이블의 인쇄 된 표현은 다음과 같이 속성과 내용을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="d6be75f4157848f03320b85454c8ed3e94f490ce" translate="yes" xml:space="preserve">
          <source>A header of type &lt;code&gt;union vectorlike_header&lt;/code&gt; is common to all vectorlike objects.</source>
          <target state="translated">&lt;code&gt;union vectorlike_header&lt;/code&gt; 유형의 헤더는 모든 vectorlike 객체에 공통입니다.</target>
        </trans-unit>
        <trans-unit id="bc19b5ecba8524e89dd4b02718fefc5d6d8c187a" translate="yes" xml:space="preserve">
          <source>A history list for arguments that are Lisp expressions to evaluate.</source>
          <target state="translated">평가할 Lisp 식인 인수에 대한 기록 목록입니다.</target>
        </trans-unit>
        <trans-unit id="d29cbee4e05656304ef83f82b3f1d36d6c40950e" translate="yes" xml:space="preserve">
          <source>A history list for arguments that are faces.</source>
          <target state="translated">얼굴 인 인수에 대한 기록 목록입니다.</target>
        </trans-unit>
        <trans-unit id="a95052be4b299ec23859e52b4286287e5de16378" translate="yes" xml:space="preserve">
          <source>A history list for arguments that are names of extended commands.</source>
          <target state="translated">확장 명령의 이름 인 인수에 대한 기록 목록입니다.</target>
        </trans-unit>
        <trans-unit id="8ba9f20cccf9a22f825a093b59843fd157992039" translate="yes" xml:space="preserve">
          <source>A history list for arguments that are shell commands.</source>
          <target state="translated">셸 명령 인 인수에 대한 기록 목록입니다.</target>
        </trans-unit>
        <trans-unit id="bc1844518b7d6ff2a94eb6a74170941282cc242b" translate="yes" xml:space="preserve">
          <source>A history list for arguments to &lt;code&gt;query-replace&lt;/code&gt; (and similar arguments to other commands).</source>
          <target state="translated">&lt;code&gt;query-replace&lt;/code&gt; 인수 (및 다른 명령과 유사한 인수)에 대한 기록 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="a0f67257cfb467394ba7cf271bab3d6d12bfdd65" translate="yes" xml:space="preserve">
          <source>A history list for buffer-name arguments.</source>
          <target state="translated">버퍼 이름 인수에 대한 히스토리 목록입니다.</target>
        </trans-unit>
        <trans-unit id="7429cd9053f94b9269173955b75a832e95aa59b8" translate="yes" xml:space="preserve">
          <source>A history list for file-name arguments.</source>
          <target state="translated">파일 이름 인수에 대한 기록 목록입니다.</target>
        </trans-unit>
        <trans-unit id="01f40f095da40e7f61a66ab4604f84f69a4b3806" translate="yes" xml:space="preserve">
          <source>A history list for regular expression arguments.</source>
          <target state="translated">정규식 인수에 대한 기록 목록입니다.</target>
        </trans-unit>
        <trans-unit id="d9187f2c4893298bd5d2b8b6870e09edb2df8d32" translate="yes" xml:space="preserve">
          <source>A history list for variable-name arguments read by &lt;code&gt;read-variable&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;read-variable&lt;/code&gt; 로 읽은 변수 이름 인수의 기록 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="88d88490f2e0ece21ea2232720e8c994b48b45c0" translate="yes" xml:space="preserve">
          <source>A inheritance interface for building JSONRPC transport implementations</source>
          <target state="translated">JSONRPC 전송 구현을 빌드하기위한 상속 인터페이스</target>
        </trans-unit>
        <trans-unit id="9693681111fd400f0e66f9a76c03ef258c7b1a8e" translate="yes" xml:space="preserve">
          <source>A key sequence (see &lt;a href=&quot;key-sequences#Key-Sequences&quot;&gt;Key Sequences&lt;/a&gt;). This keeps reading events until a command (or undefined command) is found in the current key maps. The key sequence argument is represented as a string or vector. The cursor does not move into the echo area. Prompt.</source>
          <target state="translated">키 순서는 (참조 &lt;a href=&quot;key-sequences#Key-Sequences&quot;&gt;키 시퀀스&lt;/a&gt; ). 현재 키 맵에서 명령 (또는 정의되지 않은 명령)을 찾을 때까지 이벤트를 계속 읽습니다. 키 시퀀스 인수는 문자열 또는 벡터로 표시됩니다. 커서가 에코 영역으로 이동하지 않습니다. 신속한.</target>
        </trans-unit>
        <trans-unit id="0546250cda7c79f089fec5f11f6cebe8b610ed3c" translate="yes" xml:space="preserve">
          <source>A key sequence or &lt;code&gt;nil&lt;/code&gt;. Can be used after a &amp;lsquo;</source>
          <target state="translated">키 시퀀스 또는 &lt;code&gt;nil&lt;/code&gt; . '뒤에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfce53279f617e80eaa73917517fd51b517c5eca" translate="yes" xml:space="preserve">
          <source>A key sequence that starts with a mouse event is read using the keymaps of the buffer in the window that the mouse was in, not the current buffer. This does not imply that clicking in a window selects that window or its buffer&amp;mdash;that is entirely under the control of the command binding of the key sequence.</source>
          <target state="translated">마우스 이벤트로 시작하는 키 시퀀스는 현재 버퍼가 아닌 마우스가 있던 창에있는 버퍼의 키맵을 사용하여 읽습니다. 이것은 창을 클릭하는 것이 해당 창이나 버퍼를 선택한다는 것을 의미하지 않습니다. 이는 전적으로 키 시퀀스의 명령 바인딩 제어하에 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2dad76fedc5a5f74f4a3326932c54e1522b3afb" translate="yes" xml:space="preserve">
          <source>A key sequence, whose definition you intend to change. This works like &amp;lsquo;</source>
          <target state="translated">정의를 변경하려는 키 시퀀스. 이것은 '</target>
        </trans-unit>
        <trans-unit id="a4774465bd436b77f7c7df254153ca64b8821cf1" translate="yes" xml:space="preserve">
          <source>A keymap acts as a menu if it has an &lt;em&gt;overall prompt string&lt;/em&gt;, which is a string that appears as an element of the keymap. (See &lt;a href=&quot;format-of-keymaps#Format-of-Keymaps&quot;&gt;Format of Keymaps&lt;/a&gt;.) The string should describe the purpose of the menu&amp;rsquo;s commands. Emacs displays the overall prompt string as the menu title in some cases, depending on the toolkit (if any) used for displaying menus.&lt;a href=&quot;#FOOT14&quot; name=&quot;DOCF14&quot;&gt;&lt;sup&gt;14&lt;/sup&gt;&lt;/a&gt; Keyboard menus also display the overall prompt string.</source>
          <target state="translated">키맵 의 요소로 나타나는 &lt;em&gt;문자열&lt;/em&gt; 인 &lt;em&gt;전체 프롬프트 문자열&lt;/em&gt; 이있는 경우 키맵은 메뉴 역할을합니다 . ( &lt;a href=&quot;format-of-keymaps#Format-of-Keymaps&quot;&gt;키맵 형식&lt;/a&gt; 참조 ) 문자열은 메뉴 명령의 용도를 설명해야합니다. Emacs는 메뉴 표시에 사용되는 툴킷 (있는 경우)에 따라 일부 경우 메뉴 제목으로 전체 프롬프트 문자열을 표시합니다. &lt;a href=&quot;#FOOT14&quot; name=&quot;DOCF14&quot;&gt;&lt;sup&gt;14&lt;/sup&gt;&lt;/a&gt; 키보드 메뉴는 전체 프롬프트 문자열도 표시합니다.</target>
        </trans-unit>
        <trans-unit id="83f54a39819605edababa45c4847dfff5aca04d6" translate="yes" xml:space="preserve">
          <source>A keymap can inherit the bindings of another keymap, which we call the &lt;em&gt;parent keymap&lt;/em&gt;. Such a keymap looks like this:</source>
          <target state="translated">키맵은 &lt;em&gt;부모 키맵&lt;/em&gt; 이라고하는 다른 키맵의 바인딩을 상속 할 수 있습니다 . 이러한 키맵은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="adbbaeca7dea252f489449be95d1ffed4f071473" translate="yes" xml:space="preserve">
          <source>A keymap can operate as a menu as well as defining bindings for keyboard keys and mouse buttons. Menus are usually actuated with the mouse, but they can function with the keyboard also. If a menu keymap is active for the next input event, that activates the keyboard menu feature.</source>
          <target state="translated">키맵은 키보드 키와 마우스 버튼에 대한 바인딩을 정의 할뿐만 아니라 메뉴로 작동 할 수 있습니다. 메뉴는 일반적으로 마우스로 작동하지만 키보드로도 작동 할 수 있습니다. 다음 입력 이벤트에 대해 메뉴 키맵이 활성화되면 키보드 메뉴 기능이 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="5e8f2aa8d2594c1c94ef9f4765f642084bdc5c9e" translate="yes" xml:space="preserve">
          <source>A keymap can translate one command to another.</source>
          <target state="translated">키맵은 한 명령을 다른 명령으로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca5493874569cc11a4db914940648e6dd2feebb3" translate="yes" xml:space="preserve">
          <source>A keymap for translating keys. This one overrides ordinary key bindings, unlike &lt;code&gt;local-function-key-map&lt;/code&gt;. See &lt;a href=&quot;translation-keymaps#Translation-Keymaps&quot;&gt;Translation Keymaps&lt;/a&gt;.</source>
          <target state="translated">키 번역을위한 키맵. 이것은 &lt;code&gt;local-function-key-map&lt;/code&gt; 과 달리 일반 키 바인딩을 재정의 합니다 . &lt;a href=&quot;translation-keymaps#Translation-Keymaps&quot;&gt;번역 키맵을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="80a14f3ed730352665ac8497ab20c8aab1ead0c1" translate="yes" xml:space="preserve">
          <source>A keymap is a Lisp data structure that specifies &lt;em&gt;key bindings&lt;/em&gt; for various key sequences.</source>
          <target state="translated">키맵은 다양한 키 시퀀스에 대한 &lt;em&gt;키 바인딩&lt;/em&gt; 을 지정하는 Lisp 데이터 구조입니다 .</target>
        </trans-unit>
        <trans-unit id="e581df6f5d87ba129d52ded580910d5a01f546b3" translate="yes" xml:space="preserve">
          <source>A lambda expression is a function object written in Lisp. Here is an example:</source>
          <target state="translated">람다 식은 Lisp로 작성된 함수 개체입니다. 다음은 그 예입니다.</target>
        </trans-unit>
        <trans-unit id="f7a2c28e4460e8f858bc67f5e6523cad3aaaf449" translate="yes" xml:space="preserve">
          <source>A lambda expression is a list that looks like this:</source>
          <target state="translated">람다 식은 다음과 같은 목록입니다.</target>
        </trans-unit>
        <trans-unit id="b747ce530e646e9a380c84908496cdbfc9864e4b" translate="yes" xml:space="preserve">
          <source>A lambda expression may optionally have a &lt;em&gt;documentation string&lt;/em&gt; just after the lambda list. This string does not affect execution of the function; it is a kind of comment, but a systematized comment which actually appears inside the Lisp world and can be used by the Emacs help facilities. See &lt;a href=&quot;documentation#Documentation&quot;&gt;Documentation&lt;/a&gt;, for how the documentation string is accessed.</source>
          <target state="translated">람다 식은 람다 목록 바로 뒤에 &lt;em&gt;문서 문자열을&lt;/em&gt; 선택적으로 가질 수 있습니다 . 이 문자열은 함수 실행에 영향을주지 않습니다. 일종의 주석이지만 실제로 Lisp 세계에 나타나고 Emacs 도움말 기능에서 사용할 수있는 체계화 된 주석입니다. 참조 &lt;a href=&quot;documentation#Documentation&quot;&gt;문서를&lt;/a&gt; 문서 문자열에 액세스하는 방법에 대해.</target>
        </trans-unit>
        <trans-unit id="3b292d4cfd4f00850f90b2cafdf8eb012fcc7887" translate="yes" xml:space="preserve">
          <source>A lambda expression with no quoting.</source>
          <target state="translated">따옴표가없는 람다 식입니다.</target>
        </trans-unit>
        <trans-unit id="d44cec50b78191f5728f5dfe284c3f5d18297979" translate="yes" xml:space="preserve">
          <source>A lambda expression, by itself, has no name; it is an &lt;em&gt;anonymous function&lt;/em&gt;. Although lambda expressions can be used this way (see &lt;a href=&quot;anonymous-functions#Anonymous-Functions&quot;&gt;Anonymous Functions&lt;/a&gt;), they are more commonly associated with symbols to make &lt;em&gt;named functions&lt;/em&gt; (see &lt;a href=&quot;function-names#Function-Names&quot;&gt;Function Names&lt;/a&gt;). Before going into these details, the following subsections describe the components of a lambda expression and what they do.</source>
          <target state="translated">람다 식 자체에는 이름이 없습니다. 그것은이다 &lt;em&gt;익명 함수&lt;/em&gt; . 람다 식을 이런 방식으로 사용할 수 있지만 ( &lt;a href=&quot;anonymous-functions#Anonymous-Functions&quot;&gt;익명 함수&lt;/a&gt; 참조 ), &lt;em&gt;명명 된 함수&lt;/em&gt; 를 만들기 위해 더 일반적으로 기호와 연결됩니다 ( &lt;a href=&quot;function-names#Function-Names&quot;&gt;함수 이름&lt;/a&gt; 참조 ). 이러한 세부 정보로 이동하기 전에 다음 하위 섹션에서는 람다 식의 구성 요소와 그 기능에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="79901fc9ba461cbaf1a28d28ff8d5bb8913b104c" translate="yes" xml:space="preserve">
          <source>A lexically-bound variable has &lt;em&gt;lexical scope&lt;/em&gt;, meaning that any reference to the variable must be located textually within the binding construct. Here is an example (see &lt;a href=&quot;using-lexical-binding#Using-Lexical-Binding&quot;&gt;Using Lexical Binding&lt;/a&gt;, for how to actually enable lexical binding):</source>
          <target state="translated">어휘 바인딩 변수에는 &lt;em&gt;어휘 범위가 있습니다&lt;/em&gt; . 즉, 변수에 대한 모든 참조는 바인딩 구문 내에서 텍스트로 위치해야합니다. 다음은 예제입니다 ( 실제로 어휘 바인딩을 활성화하는 방법 은 &lt;a href=&quot;using-lexical-binding#Using-Lexical-Binding&quot;&gt;Using Lexical Binding&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="533bed4887f5fb41a2062d1ceb8b2882d359589f" translate="yes" xml:space="preserve">
          <source>A line prefix may also be specified for regions of text using the &lt;code&gt;line-prefix&lt;/code&gt; text or overlay property. This takes precedence over the &lt;code&gt;line-prefix&lt;/code&gt; variable. See &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Special Properties&lt;/a&gt;.</source>
          <target state="translated">라인 프리픽스도 사용하여 텍스트의 영역을 지정할 수있다 &lt;code&gt;line-prefix&lt;/code&gt; 텍스트 또는 오버레이 속성. 이것은 &lt;code&gt;line-prefix&lt;/code&gt; 변수 보다 우선 합니다. &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;특수 속성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9d5d522b996bc3a1dbbe7104db24a53d4976ad85" translate="yes" xml:space="preserve">
          <source>A line-prefix may also be specified for an entire buffer using the &lt;code&gt;line-prefix&lt;/code&gt; buffer-local variable (however, a &lt;code&gt;line-prefix&lt;/code&gt; text-property takes precedence over the value of the &lt;code&gt;line-prefix&lt;/code&gt; variable). See &lt;a href=&quot;truncation#Truncation&quot;&gt;Truncation&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;line-prefix&lt;/code&gt; buffer-local 변수를 사용하여 전체 버퍼에 대해 line-prefix를 지정할 수도 있습니다 (하지만 &lt;code&gt;line-prefix&lt;/code&gt; text-property가 &lt;code&gt;line-prefix&lt;/code&gt; 변수 값보다 우선 합니다). &lt;a href=&quot;truncation#Truncation&quot;&gt;잘림을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e1bcc030a8bc8877cd9b9cae08c99cc625688c45" translate="yes" xml:space="preserve">
          <source>A list can be illustrated by a diagram in which the cons cells are shown as pairs of boxes, like dominoes. (The Lisp reader cannot read such an illustration; unlike the textual notation, which can be understood by both humans and computers, the box illustrations can be understood only by humans.) This picture represents the three-element list &lt;code&gt;(rose violet buttercup)&lt;/code&gt;:</source>
          <target state="translated">목록은 cons 셀이 도미노처럼 상자 쌍으로 표시되는 다이어그램으로 설명 할 수 있습니다. (Lisp 독자는 그러한 그림을 읽을 수 없습니다. 사람과 컴퓨터가 모두 이해할 수있는 텍스트 표기법과 달리 상자 그림은 사람 만 이해할 수 있습니다.)이 그림은 세 가지 요소 목록 &lt;code&gt;(rose violet buttercup)&lt;/code&gt; 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="18f1e02aad43b9d2e925fec42e48b5173603ed8e" translate="yes" xml:space="preserve">
          <source>A list can represent a finite mathematical set.</source>
          <target state="translated">목록은 유한 수학적 집합을 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99dc99207530f20a557f325ad2ddf35b0334c2e1" translate="yes" xml:space="preserve">
          <source>A list can represent a finite relation or mapping.</source>
          <target state="translated">목록은 유한 관계 또는 매핑을 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac710751e4b90ec9bd82d44f9428b1100cf29626" translate="yes" xml:space="preserve">
          <source>A list can represent an unordered mathematical set&amp;mdash;simply consider a value an element of a set if it appears in the list, and ignore the order of the list. To form the union of two sets, use &lt;code&gt;append&lt;/code&gt; (as long as you don&amp;rsquo;t mind having duplicate elements). You can remove &lt;code&gt;equal&lt;/code&gt; duplicates using &lt;code&gt;delete-dups&lt;/code&gt;. Other useful functions for sets include &lt;code&gt;memq&lt;/code&gt; and &lt;code&gt;delq&lt;/code&gt;, and their &lt;code&gt;equal&lt;/code&gt; versions, &lt;code&gt;member&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt;.</source>
          <target state="translated">목록은 순서가 지정되지 않은 수학적 집합을 나타낼 수 있습니다. 목록에 표시된 값을 집합의 요소로 간주하고 목록의 순서를 무시하면됩니다. 두 세트의 합집합을 형성하려면 &lt;code&gt;append&lt;/code&gt; 사용 하십시오 (중복 요소가 있어도 상관 없음). &lt;code&gt;delete-dups&lt;/code&gt; 를 사용하여 &lt;code&gt;equal&lt;/code&gt; 중복을 제거 할 수 있습니다 . 집합에 대한 다른 유용한 함수로는 &lt;code&gt;memq&lt;/code&gt; 및 &lt;code&gt;delq&lt;/code&gt; 와 &lt;code&gt;equal&lt;/code&gt; 버전 인 &lt;code&gt;member&lt;/code&gt; 및 &lt;code&gt;delete&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec3b92eaabe91cf1801f07fdb6f671a3685b6b4e" translate="yes" xml:space="preserve">
          <source>A list containing the command arguments that were used to start this process. For a network or serial process, it is &lt;code&gt;nil&lt;/code&gt; if the process is running or &lt;code&gt;t&lt;/code&gt; if the process is stopped.</source>
          <target state="translated">이 프로세스를 시작하는 데 사용 된 명령 인수가 포함 된 목록입니다. 네트워크 또는 직렬 프로세스의 경우 프로세스가 실행 중이면 &lt;code&gt;nil&lt;/code&gt; 이고 프로세스가 중지되면 &lt;code&gt;t&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="03cd1740db820619af89ab8e9d8be24952c71154" translate="yes" xml:space="preserve">
          <source>A list is a sequence of elements, but it is not a single primitive object; it is made of cons cells, one cell per element. Finding the &lt;var&gt;n&lt;/var&gt;th element requires looking through &lt;var&gt;n&lt;/var&gt; cons cells, so elements farther from the beginning of the list take longer to access. But it is possible to add elements to the list, or remove elements.</source>
          <target state="translated">목록은 일련의 요소이지만 단일 기본 객체가 아닙니다. 요소 당 하나의 셀로 구성됩니다. 발견 &lt;var&gt;n&lt;/var&gt; 번째 요소 것은 통해보고 필요 &lt;var&gt;n&lt;/var&gt; 개의 액세스 긴 목록 테이크의 시작부터 멀리 요소 때문에, 단점 세포. 그러나 목록에 요소를 추가하거나 요소를 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79a7cbc441d380e14b5ac8933034a90bcc47cf66" translate="yes" xml:space="preserve">
          <source>A list is a series of cons cells chained together, so that each cell refers to the next one. There is one cons cell for each element of the list. By convention, the &lt;small&gt;CAR&lt;/small&gt;s of the cons cells hold the elements of the list, and the &lt;small&gt;CDR&lt;/small&gt;s are used to chain the list (this asymmetry between &lt;small&gt;CAR&lt;/small&gt; and &lt;small&gt;CDR&lt;/small&gt; is entirely a matter of convention; at the level of cons cells, the &lt;small&gt;CAR&lt;/small&gt; and &lt;small&gt;CDR&lt;/small&gt; slots have similar properties). Hence, the &lt;small&gt;CDR&lt;/small&gt; slot of each cons cell in a list refers to the following cons cell.</source>
          <target state="translated">목록은 함께 연결된 일련의 cons 셀이므로 각 셀은 다음 셀을 참조합니다. 목록의 각 요소에 대해 하나의 단점 셀이 있습니다. 관례 상, cons 셀 의 &lt;small&gt;CAR&lt;/small&gt; 은 목록의 요소를 보유하고 &lt;small&gt;CDR&lt;/small&gt; 은 목록을 연결하는 데 사용됩니다 ( &lt;small&gt;CAR&lt;/small&gt; 와 &lt;small&gt;CDR&lt;/small&gt; 간의 이러한 비대칭 은 전적으로 관례의 문제입니다. cons 셀 수준에서 &lt;small&gt;CAR은&lt;/small&gt; 및 &lt;small&gt;CDR&lt;/small&gt; 슬롯은 유사한 속성을 가짐). 따라서 리스트의 각 cons 셀 의 &lt;small&gt;CDR&lt;/small&gt; 슬롯은 다음과 같은 cons 셀을 참조합니다.</target>
        </trans-unit>
        <trans-unit id="eb5ad8cefc6fdf97ba909694a797fc46cf77bfea" translate="yes" xml:space="preserve">
          <source>A list of actions to be applied. &lt;var&gt;key&lt;/var&gt; and &lt;var&gt;title&lt;/var&gt; are both strings. The default action (usually invoked by clicking the notification) should have a key named &amp;lsquo;</source>
          <target state="translated">적용 할 작업 목록입니다. &lt;var&gt;key&lt;/var&gt; 와 &lt;var&gt;title&lt;/var&gt; 은 모두 문자열입니다. 기본 작업 (일반적으로 알림을 클릭하여 호출 됨)에는 '</target>
        </trans-unit>
        <trans-unit id="cb3dbbae0a50b4c6a0443b8163ae2bd799d39f32" translate="yes" xml:space="preserve">
          <source>A list of buffers that have been selected in this frame, ordered most-recently-selected first.</source>
          <target state="translated">이 프레임에서 선택된 버퍼 목록은 가장 최근에 선택된 것부터 순서가 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="9e4afc49af957f8ee7b00bb9c5101181b23c3178" translate="yes" xml:space="preserve">
          <source>A list of faces. Each list element should be either a face name or an anonymous face. This specifies a face which is an aggregate of the attributes of each of the listed faces. Faces occurring earlier in the list have higher priority.</source>
          <target state="translated">얼굴 목록. 각 목록 요소는 얼굴 이름 또는 익명 얼굴이어야합니다. 이것은 나열된 각 얼굴의 속성 집합 인 얼굴을 지정합니다. 목록의 앞부분에있는 얼굴이 더 높은 우선 순위를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="cd93b8f785e569c20a9a3b200dddb7784d87994f" translate="yes" xml:space="preserve">
          <source>A list of four integers &lt;code&gt;(&lt;var&gt;high&lt;/var&gt; &lt;var&gt;low&lt;/var&gt; &lt;var&gt;micro&lt;/var&gt;
&lt;var&gt;pico&lt;/var&gt;)&lt;/code&gt;, where 0&amp;le;&lt;var&gt;low&lt;/var&gt;&amp;lt;65536, 0&amp;le;&lt;var&gt;micro&lt;/var&gt;&amp;lt;1000000, and 0&amp;le;&lt;var&gt;pico&lt;/var&gt;&amp;lt;1000000. This represents the number of seconds using the formula: &lt;var&gt;high&lt;/var&gt; * 2**16 + &lt;var&gt;low&lt;/var&gt; + &lt;var&gt;micro&lt;/var&gt; * 10**-6 + &lt;var&gt;pico&lt;/var&gt; * 10**-12. In some cases, functions may default to returning two- or three-element lists, with omitted &lt;var&gt;micro&lt;/var&gt; and &lt;var&gt;pico&lt;/var&gt; components defaulting to zero. On all current machines &lt;var&gt;pico&lt;/var&gt; is a multiple of 1000, but this may change as higher-resolution clocks become available.</source>
          <target state="translated">4 개의 정수 목록 &lt;code&gt;(&lt;var&gt;high&lt;/var&gt; &lt;var&gt;low&lt;/var&gt; &lt;var&gt;micro&lt;/var&gt; &lt;var&gt;pico&lt;/var&gt;)&lt;/code&gt; , 여기서 0&amp;le; &lt;var&gt;low&lt;/var&gt; &amp;lt;65536, 0&amp;le; &lt;var&gt;micro&lt;/var&gt; &amp;lt;1000000, 0&amp;le; &lt;var&gt;pico&lt;/var&gt; &amp;lt;1000000입니다. 이것은 공식을 사용하여 초 수를 나타냅니다 : &lt;var&gt;high&lt;/var&gt; * 2 ** 16 + &lt;var&gt;low&lt;/var&gt; + &lt;var&gt;micro&lt;/var&gt; * 10 **-6 + &lt;var&gt;pico&lt;/var&gt; * 10 **-12. 경우에 따라 함수는 기본적으로 2 개 또는 3 개의 요소 목록을 반환 할 수 있으며 생략 된 &lt;var&gt;micro&lt;/var&gt; 및 &lt;var&gt;pico&lt;/var&gt; 구성 요소는 기본적으로 0으로 설정됩니다. 현재의 모든 컴퓨터에서 &lt;var&gt;pico&lt;/var&gt; 는 1000의 배수이지만 고해상도 클럭을 사용할 수있게되면 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64f061c5f8cefbf5c98fc8804458fac9b42c2790" translate="yes" xml:space="preserve">
          <source>A list of functions for &lt;code&gt;write-region&lt;/code&gt; to call. Each function in the list is called with two arguments: the start and end of the region to be written. These functions should not alter the contents of the buffer. Instead, they should return annotations.</source>
          <target state="translated">호출 할 &lt;code&gt;write-region&lt;/code&gt; 의 함수 목록입니다 . 목록의 각 함수는 기록 할 영역의 시작과 끝이라는 두 개의 인수로 호출됩니다. 이러한 함수는 버퍼의 내용을 변경해서는 안됩니다. 대신 주석을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="ad430a2aa751ead60d08bdf9430d36b7f4df318c" translate="yes" xml:space="preserve">
          <source>A list of functions to be called before playing a sound. Each function is called with one argument, a property list that describes the sound.</source>
          <target state="translated">사운드를 재생하기 전에 호출 할 함수 목록입니다. 각 함수는 사운드를 설명하는 속성 목록 인 하나의 인수로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="9762c2a4058c3add2cfe39ddf8d9dd6bdb44523b" translate="yes" xml:space="preserve">
          <source>A list of one element, which is an integer. This form of prefix argument results from one or a succession of</source>
          <target state="translated">정수인 하나의 요소 목록입니다. 이 형식의 접두사 인수는</target>
        </trans-unit>
        <trans-unit id="f5b0c0c7f5caee2f5c38fd7fde9aec68fd7f4efb" translate="yes" xml:space="preserve">
          <source>A list of other packages (possibly including minimal acceptable version numbers) on which this package depends. The list may be empty, meaning this package has no dependencies. Otherwise, installing this package also automatically installs its dependencies, recursively; if any dependency cannot be found, the package cannot be installed.</source>
          <target state="translated">이 패키지가 의존하는 다른 패키지 목록 (허용 가능한 최소 버전 번호 포함). 목록이 비어있을 수 있으며 이는이 패키지에 종속성이 없음을 의미합니다. 그렇지 않으면이 패키지를 설치하면 종속 항목도 재귀 적으로 자동으로 설치됩니다. 종속성을 찾을 수없는 경우 패키지를 설치할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5b66488132bcde1f299fe22c7b2b1810b9065678" translate="yes" xml:space="preserve">
          <source>A list of paired elements.</source>
          <target state="translated">쌍을 이루는 요소 목록입니다.</target>
        </trans-unit>
        <trans-unit id="a6fc5f224bd5c8d275550865575a986e426c96bf" translate="yes" xml:space="preserve">
          <source>A list of symbols, specifying the &lt;em&gt;font backends&lt;/em&gt; to use for drawing characters on the frame, in order of priority. In Emacs built without Cairo drawing on X, there are currently three potentially available font backends: &lt;code&gt;x&lt;/code&gt; (the X core font driver), &lt;code&gt;xft&lt;/code&gt; (the Xft font driver), and &lt;code&gt;xfthb&lt;/code&gt; (the Xft font driver with HarfBuzz text shaping). If built with Cairo drawing, there are also three potentially available font backends on X: &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;ftcr&lt;/code&gt; (the FreeType font driver on Cairo), and &lt;code&gt;ftcrhb&lt;/code&gt; (the FreeType font driver on Cairo with HarfBuzz text shaping). When Emacs is built with HarfBuzz, the default font driver is &lt;code&gt;ftcrhb&lt;/code&gt;, although use of the &lt;code&gt;ftcr&lt;/code&gt; driver is still possible, but not recommended. On MS-Windows, there are currently three available font backends: &lt;code&gt;gdi&lt;/code&gt; (the core MS-Windows font driver), &lt;code&gt;uniscribe&lt;/code&gt; (font driver for OTF and TTF fonts with text shaping by the Uniscribe engine), and &lt;code&gt;harfbuzz&lt;/code&gt; (font driver for OTF and TTF fonts with HarfBuzz text shaping) (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Windows-Fonts.html#Windows-Fonts&quot;&gt;Windows Fonts&lt;/a&gt; in</source>
          <target state="translated">우선 순위에 따라 프레임에 문자를 그리는 데 사용할 &lt;em&gt;글꼴 백엔드&lt;/em&gt; 를 지정하는 기호 목록입니다 . X에서 Cairo 그리기없이 구축 된 Emacs에는 현재 사용 가능한 세 가지 글꼴 백엔드가 있습니다. &lt;code&gt;x&lt;/code&gt; (X 코어 글꼴 드라이버), &lt;code&gt;xft&lt;/code&gt; (Xft 글꼴 드라이버) 및 &lt;code&gt;xfthb&lt;/code&gt; (HarfBuzz 텍스트 모양이있는 Xft 글꼴 드라이버)입니다. 카이로 그리기로 구축하는 경우, 세 가지 잠재적으로 사용 가능한 글꼴 X에 백엔드도있다 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;ftcr&lt;/code&gt; (카이로에 FreeType에서 글꼴 드라이버) 및 &lt;code&gt;ftcrhb&lt;/code&gt; (에 HarfBuzz 텍스트 형성 카이로에 FreeType에서 글꼴 드라이버). Emacs가 HarfBuzz로 빌드 된 경우 기본 글꼴 드라이버는 &lt;code&gt;ftcrhb&lt;/code&gt; 입니다. &lt;code&gt;ftcr&lt;/code&gt; 드라이버는 여전히 가능하지만 권장되지는 않습니다. : MS-Windows에서 세 가지 글꼴 백엔드에 현재있다 &lt;code&gt;gdi&lt;/code&gt; (핵심 MS-윈도우 글꼴 드라이버), &lt;code&gt;uniscribe&lt;/code&gt; 및 (OTF와 TTF 유니 스크라이브 (Uniscribe) 엔진에 의해 텍스트의 형성과 글꼴의 글꼴 드라이버) &lt;code&gt;harfbuzz&lt;/code&gt; OTF에 대한 (글꼴 드라이버는 에 HarfBuzz 텍스트의 형성과 TTF 글꼴) (참조 &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Windows-Fonts.html#Windows-Fonts&quot;&gt;윈도우 글꼴&lt;/a&gt; 에</target>
        </trans-unit>
        <trans-unit id="889ce2ae30cbe0ed4180a7fd8f0ae655444bf1e7" translate="yes" xml:space="preserve">
          <source>A list of terminal parameters. See &lt;a href=&quot;terminal-parameters#Terminal-Parameters&quot;&gt;Terminal Parameters&lt;/a&gt;.</source>
          <target state="translated">터미널 매개 변수 목록입니다. &lt;a href=&quot;terminal-parameters#Terminal-Parameters&quot;&gt;터미널 매개 변수를&lt;/a&gt; 참고하십시오 .</target>
        </trans-unit>
        <trans-unit id="486df487a5b36966765d7fa430db38ceca9357e2" translate="yes" xml:space="preserve">
          <source>A list whose first element is a string or list means to process all the elements recursively and concatenate the results. This is the most common form of mode line construct.</source>
          <target state="translated">첫 번째 요소가 문자열 또는 목록 인 목록은 모든 요소를 ​​재귀 적으로 처리하고 결과를 연결하는 것을 의미합니다. 이것은 모드 라인 구성의 가장 일반적인 형태입니다.</target>
        </trans-unit>
        <trans-unit id="537d031a677ca36fa6b9cad5a659d5374622bf7d" translate="yes" xml:space="preserve">
          <source>A list whose first element is a symbol representing the font type, one of &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;opentype&lt;/code&gt;, &lt;code&gt;truetype&lt;/code&gt;, &lt;code&gt;type1&lt;/code&gt;, &lt;code&gt;pcf&lt;/code&gt;, or &lt;code&gt;bdf&lt;/code&gt;. For OpenType fonts, the list includes 2 additional elements describing the &lt;small&gt;GSUB&lt;/small&gt; and &lt;small&gt;GPOS&lt;/small&gt; features supported by the font. Each of these elements is a list of the form &lt;code&gt;((&lt;var&gt;script&lt;/var&gt; (&lt;var&gt;langsys&lt;/var&gt; &lt;var&gt;feature&lt;/var&gt; &amp;hellip;) &amp;hellip;)
&amp;hellip;)&lt;/code&gt;, where &lt;var&gt;script&lt;/var&gt; is a symbol representing an OpenType script tag, &lt;var&gt;langsys&lt;/var&gt; is a symbol representing an OpenType langsys tag (or &lt;code&gt;nil&lt;/code&gt;, which stands for the default langsys), and each &lt;var&gt;feature&lt;/var&gt; is a symbol representing an OpenType feature tag.</source>
          <target state="translated">첫 번째 요소가 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;opentype&lt;/code&gt; , &lt;code&gt;truetype&lt;/code&gt; , &lt;code&gt;type1&lt;/code&gt; , &lt;code&gt;pcf&lt;/code&gt; 또는 &lt;code&gt;bdf&lt;/code&gt; 중 하나 인 글꼴 유형을 나타내는 기호 인 목록입니다 . OpenType 글꼴의 경우 목록에는 글꼴이 지원 하는 &lt;small&gt;GSUB&lt;/small&gt; 및 &lt;small&gt;GPOS&lt;/small&gt; 기능을 설명하는 2 개의 추가 요소가 포함됩니다 . 이러한 각 요소는 &lt;code&gt;((&lt;var&gt;script&lt;/var&gt; (&lt;var&gt;langsys&lt;/var&gt; &lt;var&gt;feature&lt;/var&gt; &amp;hellip;) &amp;hellip;) &amp;hellip;)&lt;/code&gt; 형식의 목록입니다. 여기서 &lt;var&gt;script&lt;/var&gt; 는 OpenType 스크립트 태그를 나타내는 기호 이고 &lt;var&gt;langsys&lt;/var&gt; 는 OpenType langsys 태그를 나타내는 기호 (또는 &lt;code&gt;nil&lt;/code&gt; , 기본 langsys를 나타냄) 각 &lt;var&gt;feature&lt;/var&gt; 은 OpenType 기능 태그를 나타내는 기호입니다.</target>
        </trans-unit>
        <trans-unit id="0ce46748c8e3407b9e05ae90432a1d1f6fcfef35" translate="yes" xml:space="preserve">
          <source>A list whose first element is a symbol that is not a keyword specifies a conditional. Its meaning depends on the value of &lt;var&gt;symbol&lt;/var&gt;. If &lt;var&gt;symbol&lt;/var&gt; has a non-&lt;code&gt;nil&lt;/code&gt; value, the second element, &lt;var&gt;then&lt;/var&gt;, is processed recursively as a mode line construct. Otherwise, the third element, &lt;var&gt;else&lt;/var&gt;, is processed recursively. You may omit &lt;var&gt;else&lt;/var&gt;; then the mode line construct displays nothing if the value of &lt;var&gt;symbol&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; or void.</source>
          <target state="translated">첫 번째 요소가 키워드가 아닌 기호 인 목록은 조건을 지정합니다. 그 의미는 &lt;var&gt;symbol&lt;/var&gt; 값에 따라 다릅니다 . &lt;var&gt;symbol&lt;/var&gt; 에 &lt;code&gt;nil&lt;/code&gt; 이 아닌 값 이 있으면 두 번째 요소 &lt;var&gt;then&lt;/var&gt; 은 모드 라인 구성으로 재귀 적으로 처리됩니다. 그렇지 않으면 세 번째 요소 인 &lt;var&gt;else&lt;/var&gt; 가 재귀 적으로 처리됩니다. &lt;var&gt;else&lt;/var&gt; 것을 생략 할 수 있습니다 . 그런 다음 모드 라인 구성은 &lt;var&gt;symbol&lt;/var&gt; 의 값 이 &lt;code&gt;nil&lt;/code&gt; 또는 void 이면 아무것도 표시하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="53b4d74e824eb5439ef4ec98237a2b8623aea845" translate="yes" xml:space="preserve">
          <source>A list whose first element is an integer specifies truncation or padding of the results of &lt;var&gt;rest&lt;/var&gt;. The remaining elements &lt;var&gt;rest&lt;/var&gt; are processed recursively as mode line constructs and concatenated together. When &lt;var&gt;width&lt;/var&gt; is positive, the result is space filled on the right if its width is less than &lt;var&gt;width&lt;/var&gt;. When &lt;var&gt;width&lt;/var&gt; is negative, the result is truncated on the right to -&lt;var&gt;width&lt;/var&gt; columns if its width exceeds -&lt;var&gt;width&lt;/var&gt;.</source>
          <target state="translated">첫 번째 요소가 정수인 목록은 &lt;var&gt;rest&lt;/var&gt; 결과의 자르기 또는 패딩을 지정합니다 . 나머지 요소는 &lt;var&gt;rest&lt;/var&gt; 모드 라인 구조로 순환 처리와 함께 연결된다. 때 &lt;var&gt;width&lt;/var&gt; 긍정적 결과는 그 폭 미만이면 오른쪽 채워진 공간 &lt;var&gt;width&lt;/var&gt; . 경우 &lt;var&gt;width&lt;/var&gt; - 부정적 결과는 오른쪽에 잘린 &lt;var&gt;width&lt;/var&gt; 폭을 초과하는 경우 열 - &lt;var&gt;width&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="200a1fdf699f4365c5108897a4f0ff20723ba395" translate="yes" xml:space="preserve">
          <source>A list whose first element is the symbol &lt;code&gt;:eval&lt;/code&gt; says to evaluate &lt;var&gt;form&lt;/var&gt;, and use the result as a string to display. Make sure this evaluation cannot load any files, as doing so could cause infinite recursion.</source>
          <target state="translated">첫 번째 요소가 기호 인 목록 &lt;code&gt;:eval&lt;/code&gt; 은 &lt;var&gt;form&lt;/var&gt; 을 평가 하고 결과를 표시 할 문자열로 사용합니다. 이 평가가 파일을로드 할 수 없는지 확인하십시오. 그렇게하면 무한 재귀가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a68e385750b6b6bb2e3e3b921b8caab43897c33" translate="yes" xml:space="preserve">
          <source>A list whose first element is the symbol &lt;code&gt;:propertize&lt;/code&gt; says to process the mode line construct &lt;var&gt;elt&lt;/var&gt; recursively, then add the text properties specified by &lt;var&gt;props&lt;/var&gt; to the result. The argument &lt;var&gt;props&lt;/var&gt; should consist of zero or more pairs &lt;var&gt;text-property&lt;/var&gt;&lt;var&gt;value&lt;/var&gt;. If &lt;var&gt;elt&lt;/var&gt; is or produces a string with text properties, all the characters of that string should have the same properties, or else some of them might be removed by &lt;code&gt;:propertize&lt;/code&gt;.</source>
          <target state="translated">그 첫 번째 요소 목록이 상징 &lt;code&gt;:propertize&lt;/code&gt; 은 모드 라인 구조를 처리하기 위해 말한다 &lt;var&gt;elt&lt;/var&gt; , 재귀 적으로 다음에 의해 지정된 텍스트 속성 추가 &lt;var&gt;props&lt;/var&gt; 결과로합니다. 인수 &lt;var&gt;props&lt;/var&gt; 는 0 개 이상의 &lt;var&gt;text-property&lt;/var&gt; &lt;var&gt;value&lt;/var&gt; 쌍으로 구성되어야 합니다 . &lt;var&gt;elt&lt;/var&gt; 가 텍스트 속성이있는 문자열이거나 생성하는 경우 해당 문자열의 모든 문자는 동일한 속성을 가져야합니다. 그렇지 않으면 일부는 &lt;code&gt;:propertize&lt;/code&gt; 에 의해 제거 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="99145ab59880d8f2b7e6b9be7771bce95706ef5a" translate="yes" xml:space="preserve">
          <source>A list with no elements in it is the &lt;em&gt;empty list&lt;/em&gt;; it is identical to the symbol &lt;code&gt;nil&lt;/code&gt;. In other words, &lt;code&gt;nil&lt;/code&gt; is both a symbol and a list.</source>
          <target state="translated">요소가없는 목록은 &lt;em&gt;빈 목록입니다&lt;/em&gt; . &lt;code&gt;nil&lt;/code&gt; 기호와 동일합니다 . 즉, &lt;code&gt;nil&lt;/code&gt; 은 기호이자 목록입니다.</target>
        </trans-unit>
        <trans-unit id="8d5b45234e07684855dcd49734c72caa44271737" translate="yes" xml:space="preserve">
          <source>A local keymap can cancel a menu bar item made by the global keymap by rebinding the same fake function key with &lt;code&gt;undefined&lt;/code&gt; as the binding. For example, this is how Dired suppresses the &amp;lsquo;</source>
          <target state="translated">로컬 키맵은 바인딩으로 &lt;code&gt;undefined&lt;/code&gt; 동일한 가짜 기능 키를 다시 바인딩하여 글로벌 키맵으로 만든 메뉴 모음 항목을 취소 할 수 있습니다 . 예를 들어, 이것이 Dired가 '</target>
        </trans-unit>
        <trans-unit id="7c4cffa2e30c2997d566ee8758396b533735bf09" translate="yes" xml:space="preserve">
          <source>A loop that scans the buffer forwards, creating overlays, can run faster if you do &lt;code&gt;(overlay-recenter (point-max))&lt;/code&gt; first.</source>
          <target state="translated">버퍼를 앞으로 스캔하여 오버레이를 생성하는 루프는 먼저 수행하면 &lt;code&gt;(overlay-recenter (point-max))&lt;/code&gt; 더 빨리 실행될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a7efdb49985c362b0ca4c8aa6d3088d6718cc09a" translate="yes" xml:space="preserve">
          <source>A lot of code uses the old &lt;code&gt;defadvice&lt;/code&gt; mechanism, which is largely made obsolete by the new &lt;code&gt;advice-add&lt;/code&gt;, whose implementation and semantics is significantly simpler.</source>
          <target state="translated">많은 코드는 구현과 의미가 훨씬 더 간단한 새로운 &lt;code&gt;advice-add&lt;/code&gt; 에 의해 대체로 쓸모 없게 된 오래된 &lt;code&gt;defadvice&lt;/code&gt; 메커니즘을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="0ae5e6660e603f36f91418d149ae3a32b329069b" translate="yes" xml:space="preserve">
          <source>A lower-level function for standardizing file names, which &lt;code&gt;locate-user-emacs-file&lt;/code&gt; uses as a subroutine, is &lt;code&gt;convert-standard-filename&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;locate-user-emacs-file&lt;/code&gt; 이 서브 루틴으로 사용 하는 파일 이름 표준화를위한 하위 레벨 함수 는 &lt;code&gt;convert-standard-filename&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="204dc77e267dd20b6bd5f085404e9de55232cab4" translate="yes" xml:space="preserve">
          <source>A macro (see &lt;a href=&quot;macros#Macros&quot;&gt;Macros&lt;/a&gt;) can also be marked obsolete with &lt;code&gt;make-obsolete&lt;/code&gt;; this has the same effects as for a function. An alias for a function or macro can also be marked as obsolete; this makes the alias itself obsolete, not the function or macro which it resolves to.</source>
          <target state="translated">매크로 ( &lt;a href=&quot;macros#Macros&quot;&gt;Macros&lt;/a&gt; 참조 )는 &lt;code&gt;make-obsolete&lt;/code&gt; 를 사용하여 폐기 됨으로 표시 될 수도 있습니다 . 이것은 함수와 동일한 효과를 갖습니다. 함수 또는 매크로에 대한 별칭도 사용되지 않음으로 표시 될 수 있습니다. 이로 인해 별칭 자체가 사용되지 않으며 확인되는 함수 나 매크로가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="bb6a5825df107e5229f7ac1f45fb39d09577f95a" translate="yes" xml:space="preserve">
          <source>A macro call looks just like a function call in that it is a list which starts with the name of the macro. The rest of the elements of the list are the arguments of the macro.</source>
          <target state="translated">매크로 호출은 매크로 이름으로 시작하는 목록이라는 점에서 함수 호출과 비슷합니다. 목록의 나머지 요소는 매크로의 인수입니다.</target>
        </trans-unit>
        <trans-unit id="c88b5640d4554aef41be1be878e9894c1dc41ba1" translate="yes" xml:space="preserve">
          <source>A magic autoload comment (often called an &lt;em&gt;autoload cookie&lt;/em&gt;) consists of &amp;lsquo;</source>
          <target state="translated">매직 자동로드 주석 (종종 &lt;em&gt;자동로드 쿠키&lt;/em&gt; 라고 함 )은 '</target>
        </trans-unit>
        <trans-unit id="bdf7d7f38bdc264583d1a0710beb7e25f8ed382e" translate="yes" xml:space="preserve">
          <source>A major client of this is &lt;code&gt;display-buffer-reuse-window&lt;/code&gt;, but all other action functions that try to reuse a window are affected as well. &lt;code&gt;display-buffer-in-previous-window&lt;/code&gt; consults it when searching for a window that previously displayed the buffer on another frame.</source>
          <target state="translated">이것의 주요 클라이언트는 &lt;code&gt;display-buffer-reuse-window&lt;/code&gt; 이지만 창 을 재사용하려는 다른 모든 작업 함수도 영향을받습니다. &lt;code&gt;display-buffer-in-previous-window&lt;/code&gt; 는 이전에 다른 프레임에 버퍼를 표시 한 창을 검색 할 때이를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="45f557d688272099786e68e616898e0f800432d9" translate="yes" xml:space="preserve">
          <source>A major mode can also rebind the keys</source>
          <target state="translated">메이저 모드는 키를 리 바인드 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="781c3e7a06dbadfac8818dd119ef44b70073b8cd" translate="yes" xml:space="preserve">
          <source>A margin display specification looks like &lt;code&gt;((margin
right-margin) &lt;var&gt;spec&lt;/var&gt;)&lt;/code&gt; or &lt;code&gt;((margin left-margin) &lt;var&gt;spec&lt;/var&gt;)&lt;/code&gt;. Here, &lt;var&gt;spec&lt;/var&gt; is another display specification that says what to display in the margin. Typically it is a string of text to display, or an image descriptor.</source>
          <target state="translated">여백 표시 사양은 &lt;code&gt;((margin right-margin) &lt;var&gt;spec&lt;/var&gt;)&lt;/code&gt; 또는 &lt;code&gt;((margin left-margin) &lt;var&gt;spec&lt;/var&gt;)&lt;/code&gt; . 여기서 &lt;var&gt;spec&lt;/var&gt; 은 여백에 표시 할 내용을 나타내는 또 다른 표시 사양입니다. 일반적으로 표시 할 텍스트 문자열 또는 이미지 설명자입니다.</target>
        </trans-unit>
        <trans-unit id="e70b47c889fabc845b90767aef6efcf0cf0a1107" translate="yes" xml:space="preserve">
          <source>A marker has three attributes: the marker position, the marker buffer, and the insertion type. The marker position is an integer that is equivalent (at a given time) to the marker as a position in that buffer. But the marker&amp;rsquo;s position value can change during the life of the marker, and often does. Insertion and deletion of text in the buffer relocate the marker. The idea is that a marker positioned between two characters remains between those two characters despite insertion and deletion elsewhere in the buffer. Relocation changes the integer equivalent of the marker.</source>
          <target state="translated">마커에는 마커 위치, 마커 버퍼 및 삽입 유형의 세 가지 속성이 있습니다. 마커 위치는 해당 버퍼의 위치로서 마커와 동일한 (주어진 시간에) 정수입니다. 그러나 마커의 위치 값은 마커의 수명 동안 변경 될 수 있으며 종종 변경됩니다. 버퍼에 텍스트를 삽입하고 삭제하면 마커가 재배치됩니다. 아이디어는 두 문자 사이에 위치한 마커가 버퍼의 다른 위치에 삽입 및 삭제 되었음에도 불구하고 두 문자 사이에 남아 있다는 것입니다. 재배치는 마커에 해당하는 정수를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="466a2e8e4ddd1269a8d20d90952cb9d2e8d1b556" translate="yes" xml:space="preserve">
          <source>A marker indicating the position of the end of the last output from this process inserted into the buffer. This is often but not always the end of the buffer.</source>
          <target state="translated">버퍼에 삽입 된이 프로세스의 마지막 출력 끝 위치를 나타내는 마커입니다. 이것은 종종 버퍼의 끝이지만 항상 그런 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="2d9513ddb58517694c738e7fbe081843e380b82c" translate="yes" xml:space="preserve">
          <source>A marker pointing to the position in the buffer that is the first character (in the logical order, see &lt;a href=&quot;bidirectional-display#Bidirectional-Display&quot;&gt;Bidirectional Display&lt;/a&gt;) displayed in the window.</source>
          <target state="translated">창에 표시되는 첫 번째 문자 (논리적 순서로 &lt;a href=&quot;bidirectional-display#Bidirectional-Display&quot;&gt;양방향 표시&lt;/a&gt; 참조) 인 버퍼의 위치를 ​​가리키는 마커 입니다.</target>
        </trans-unit>
        <trans-unit id="09e41168573d8c2d601b252f527ba1cf4c63c69d" translate="yes" xml:space="preserve">
          <source>A marker represents a buffer position to jump to.</source>
          <target state="translated">마커는 이동할 버퍼 위치를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="704ed7dde36adbdca349302504f832854db5ca66" translate="yes" xml:space="preserve">
          <source>A marker specifies a buffer and a position in that buffer. A marker can be used to represent a position in functions that require one, just as an integer could be used. In that case, the marker&amp;rsquo;s buffer is normally ignored. Of course, a marker used in this way usually points to a position in the buffer that the function operates on, but that is entirely the programmer&amp;rsquo;s responsibility. See &lt;a href=&quot;positions#Positions&quot;&gt;Positions&lt;/a&gt;, for a complete description of positions.</source>
          <target state="translated">마커는 버퍼와 해당 버퍼의 위치를 ​​지정합니다. 마커는 정수를 사용할 수있는 것처럼 1이 필요한 함수의 위치를 ​​나타내는 데 사용할 수 있습니다. 이 경우 마커의 버퍼는 일반적으로 무시됩니다. 물론 이러한 방식으로 사용되는 마커는 일반적으로 함수가 작동하는 버퍼의 위치를 ​​가리 키지 만 이는 전적으로 프로그래머의 책임입니다. &lt;a href=&quot;positions#Positions&quot;&gt;위치&lt;/a&gt; 에 대한 전체 설명은 위치를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0bc36f974eb0baf86a8ea0fb18f4b0a30f0045d5" translate="yes" xml:space="preserve">
          <source>A menu item can be a vector of three elements, &lt;code&gt;[&lt;var&gt;name&lt;/var&gt;
&lt;var&gt;callback&lt;/var&gt; &lt;var&gt;enable&lt;/var&gt;]&lt;/code&gt;. &lt;var&gt;name&lt;/var&gt; is the menu item name (a string). &lt;var&gt;callback&lt;/var&gt; is a command to run, or an expression to evaluate, when the item is chosen. &lt;var&gt;enable&lt;/var&gt; is an expression; if it evaluates to &lt;code&gt;nil&lt;/code&gt;, the item is disabled for selection.</source>
          <target state="translated">메뉴 항목은 &lt;code&gt;[&lt;var&gt;name&lt;/var&gt; &lt;var&gt;callback&lt;/var&gt; &lt;var&gt;enable&lt;/var&gt;]&lt;/code&gt; 세 가지 요소로 구성된 벡터 일 수 있습니다 . &lt;var&gt;name&lt;/var&gt; 은 메뉴 항목 이름 (문자열)입니다. &lt;var&gt;callback&lt;/var&gt; 은 항목이 선택 될 때 실행할 명령 또는 평가할 표현식입니다. &lt;var&gt;enable&lt;/var&gt; 은 표현식입니다. &lt;code&gt;nil&lt;/code&gt; 로 평가 되면 항목이 선택되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6783cd5380d1ff982a022350fe9ec3e438f07ed2" translate="yes" xml:space="preserve">
          <source>A menu separator is a kind of menu item that doesn&amp;rsquo;t display any text&amp;mdash;instead, it divides the menu into subparts with a horizontal line. A separator looks like this in the menu keymap:</source>
          <target state="translated">메뉴 구분 기호는 텍스트를 표시하지 않는 일종의 메뉴 항목입니다. 대신 메뉴를 가로줄로 하위 부분으로 나눕니다. 구분 기호는 메뉴 키맵에서 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="454923c998127cc9f1ebbf5e81d874369316f380" translate="yes" xml:space="preserve">
          <source>A method of expanding an expression into another expression, more fundamental but less pretty.</source>
          <target state="translated">표현을 다른 표현으로 확장하는 방법으로, 더 근본적이지만 덜 예쁘다.</target>
        </trans-unit>
        <trans-unit id="e1ebe68a6967a16e6180516760ceccb03b9f1d21" translate="yes" xml:space="preserve">
          <source>A minibuffer window (see &lt;a href=&quot;minibuffer-windows#Minibuffer-Windows&quot;&gt;Minibuffer Windows&lt;/a&gt;) that is not alone on its frame does not have a parent window, so it strictly speaking is not part of its frame&amp;rsquo;s window tree. Nonetheless, it is a sibling window of the frame&amp;rsquo;s root window, and thus can be reached via &lt;code&gt;window-next-sibling&lt;/code&gt;. Also, the function &lt;code&gt;window-tree&lt;/code&gt; described at the end of this section lists the minibuffer window alongside the actual window tree.</source>
          <target state="translated">프레임에 단독으로 존재하지 않는 &lt;a href=&quot;minibuffer-windows#Minibuffer-Windows&quot;&gt;미니 버퍼&lt;/a&gt; 창 ( 미니 버퍼 창 참조 )에는 부모 창이 없으므로 엄밀히 말하면 프레임의 창 트리의 일부가 아닙니다. 그럼에도 불구하고 프레임의 루트 창의 형제 창이므로 &lt;code&gt;window-next-sibling&lt;/code&gt; 을 통해 도달 할 수 있습니다 . 또한 이 섹션의 끝에 설명 된 기능 &lt;code&gt;window-tree&lt;/code&gt; 실제 창 트리와 함께 미니 버퍼 창을 나열합니다.</target>
        </trans-unit>
        <trans-unit id="89c2b888618beed3c117f354a901a70cc356f1d6" translate="yes" xml:space="preserve">
          <source>A minibuffer window is never a candidate. A dedicated window (see &lt;a href=&quot;dedicated-windows#Dedicated-Windows&quot;&gt;Dedicated Windows&lt;/a&gt;) is never a candidate unless the optional argument &lt;var&gt;dedicated&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;. The selected window is not a candidate if the optional argument &lt;var&gt;not-selected&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;. If the optional argument &lt;var&gt;not-selected&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt; and the selected window is the only candidate, this function returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">미니 버퍼 창은 후보가 아닙니다. 전용 창 ( &lt;a href=&quot;dedicated-windows#Dedicated-Windows&quot;&gt;Dedicated Windows&lt;/a&gt; 참조 )은 optional 인수 인 &lt;var&gt;dedicated&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 한 후보가 아닙니다 . 선택적 인수하면 선택 창이 후보는 아닌지를 &lt;var&gt;not-selected&lt;/var&gt; 않은 것입니다 &lt;code&gt;nil&lt;/code&gt; . 선택 &lt;var&gt;not-selected&lt;/var&gt; 선택적 인수 가 &lt;code&gt;nil&lt;/code&gt; 이 아니고 선택한 창이 유일한 후보 인 경우이 함수는 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b599a674f06dd65226c7bca41859f38c441875f7" translate="yes" xml:space="preserve">
          <source>A minor limitation of this feature, again because it targets symbols, is that only variables of dynamic scope may be watched. This poses little difficulty, since modifications to lexical variables can be discovered easily by inspecting the code within the scope of the variable (unlike dynamic variables, which can be modified by any code at all, see &lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;Variable Scoping&lt;/a&gt;).</source>
          <target state="translated">이 기능의 사소한 제한은 심볼을 대상으로하기 때문에 동적 범위의 변수 만 감시 할 수 있다는 것입니다. 어휘 변수에 대한 수정은 변수 범위 내에서 코드를 검사하여 쉽게 발견 할 수 있기 때문에 거의 어렵지 않습니다 (모든 코드에서 수정할 수있는 동적 변수와 달리 &lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;변수 범위 지정&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="d236ab570a4289eb003477e38186061d1fde0262" translate="yes" xml:space="preserve">
          <source>A minor-mode function to call after visiting a file converted from this format. The function is called with one argument, the integer 1; that tells a minor-mode function to enable the mode.</source>
          <target state="translated">이 형식에서 변환 된 파일을 방문한 후 호출 할 부 모드 함수입니다. 함수는 하나의 인수 인 정수 1로 호출됩니다. 모드를 활성화하는 부 모드 기능을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="c276708ad05da4fad726f0a5b45a06849defae13" translate="yes" xml:space="preserve">
          <source>A mode line construct may be as simple as a fixed string of text, but it usually specifies how to combine fixed strings with variables&amp;rsquo; values to construct the text. Many of these variables are themselves defined to have mode line constructs as their values.</source>
          <target state="translated">모드 라인 구성은 고정 된 텍스트 문자열만큼 간단 할 수 있지만 일반적으로 고정 된 문자열을 변수 값과 결합하여 텍스트를 구성하는 방법을 지정합니다. 이러한 변수의 대부분은 값으로 모드 라인 구성을 갖도록 자체적으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="8afb42d8de6cea8a8b63620c9e3383e0c0f0f509" translate="yes" xml:space="preserve">
          <source>A module can verify that the Emacs executable which loads the module is compatible with the module, by comparing the &lt;code&gt;size&lt;/code&gt; member of the &lt;var&gt;runtime&lt;/var&gt; structure with the value compiled into the module:</source>
          <target state="translated">모듈은 &lt;var&gt;runtime&lt;/var&gt; 구조 의 &lt;code&gt;size&lt;/code&gt; 멤버를 모듈로 컴파일 된 값과 비교하여 모듈을로드하는 Emacs 실행 파일이 모듈과 호환되는지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="348aed7380113f95130d713670b2f7bc22c14981" translate="yes" xml:space="preserve">
          <source>A module function always returns a value. If the function returns normally, the Lisp code which called it will see the Lisp object corresponding to the &lt;code&gt;emacs_value&lt;/code&gt; value the function returned. However, if the user typed</source>
          <target state="translated">모듈 함수는 항상 값을 반환합니다. 함수가 정상적으로 반환되면이를 호출 한 Lisp 코드 는 함수가 반환 한 &lt;code&gt;emacs_value&lt;/code&gt; 값에 해당하는 Lisp 객체를 볼 수 있습니다. 그러나 사용자가 입력 한 경우</target>
        </trans-unit>
        <trans-unit id="eb0109953f2a0b65f8f6c1374782995296dbdec9" translate="yes" xml:space="preserve">
          <source>A module function has the following general form and signature:</source>
          <target state="translated">모듈 함수에는 다음과 같은 일반적인 형식과 서명이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9940368a099b58ff18b341d077c7d872ecd6531e" translate="yes" xml:space="preserve">
          <source>A more advanced example would be to trace the calls to the process filter of a process &lt;var&gt;proc&lt;/var&gt;:</source>
          <target state="translated">더 고급 예제는 프로세스 &lt;var&gt;proc&lt;/var&gt; 의 프로세스 필터에 대한 호출을 추적하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="f7dfdb4b11e543f8cc270a0d51db8591bd156e62" translate="yes" xml:space="preserve">
          <source>A more convenient format string for such cases would be something like &lt;code&gt;&quot;%f&amp;nbsp;%l&amp;nbsp;&amp;lt;%e&amp;gt;&quot;&lt;/code&gt;, where each specification character carries more semantic information and can easily be rearranged relative to other specification characters, making such format strings more easily customizable by the user.</source>
          <target state="translated">이러한 경우에 더 편리한 형식 문자열은 &lt;code&gt;&quot;%f&amp;nbsp;%l&amp;nbsp;&amp;lt;%e&amp;gt;&quot;&lt;/code&gt; 와 같은 것입니다. 여기서 각 사양 문자는 더 많은 의미 정보를 전달하고 다른 사양 문자에 비해 쉽게 재 배열 될 수 있으므로 이러한 형식 문자열은 사용자.</target>
        </trans-unit>
        <trans-unit id="5a3d7f1ea620bc2801ba23e243907150a812ed06" translate="yes" xml:space="preserve">
          <source>A more powerful function is &lt;code&gt;store-substring&lt;/code&gt;:</source>
          <target state="translated">보다 강력한 기능은 &lt;code&gt;store-substring&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="0e8d8f144404b38e8eb77a264fc3e628792a87cf" translate="yes" xml:space="preserve">
          <source>A more powerful operation is to mark the variable as &lt;em&gt;automatically buffer-local&lt;/em&gt; by calling &lt;code&gt;make-variable-buffer-local&lt;/code&gt;. You can think of this as making the variable local in all buffers, even those yet to be created. More precisely, the effect is that setting the variable automatically makes the variable local to the current buffer if it is not already so. All buffers start out by sharing the default value of the variable as usual, but setting the variable creates a buffer-local binding for the current buffer. The new value is stored in the buffer-local binding, leaving the default binding untouched. This means that the default value cannot be changed with &lt;code&gt;setq&lt;/code&gt; in any buffer; the only way to change it is with &lt;code&gt;setq-default&lt;/code&gt;.</source>
          <target state="translated">보다 강력한 작업은 &lt;code&gt;make-variable-buffer-local&lt;/code&gt; 을 호출 하여 변수를 &lt;em&gt;자동으로 버퍼 로컬&lt;/em&gt; 로 표시하는 것 입니다. 아직 생성되지 않은 버퍼를 포함하여 모든 버퍼에서 변수를 로컬로 만드는 것으로 생각할 수 있습니다. 더 정확하게는, 그 효과는 변수를 설정하면 변수가 아직 그렇지 않은 경우 자동으로 현재 버퍼에 로컬이되는 것입니다. 모든 버퍼는 평소와 같이 변수의 기본값을 공유하여 시작되지만 변수를 설정하면 현재 버퍼에 대한 버퍼 로컬 바인딩이 생성됩니다. 새 값은 버퍼 로컬 바인딩에 저장되며 기본 바인딩은 그대로 둡니다. 즉, 버퍼에서 &lt;code&gt;setq&lt;/code&gt; 로 기본값을 변경할 수 없습니다 . 변경하는 유일한 방법은 &lt;code&gt;setq-default&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="dd57642f42b5205af6e02818c9a3f1fe9a885aae" translate="yes" xml:space="preserve">
          <source>A multi-file package is less convenient to create than a single-file package, but it offers more features: it can include multiple Emacs Lisp files, an Info manual, and other file types (such as images).</source>
          <target state="translated">다중 파일 패키지는 단일 파일 패키지보다 작성하기가 덜 편리하지만 더 많은 기능을 제공합니다. 여러 Emacs Lisp 파일, Info 매뉴얼 및 기타 파일 유형 (예 : 이미지)을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc6654118704a5566d1ff1cdbb86919396f3250f" translate="yes" xml:space="preserve">
          <source>A multi-frame image has a property &lt;code&gt;:index&lt;/code&gt;, whose value is an integer (counting from 0) that specifies which frame is being displayed.</source>
          <target state="translated">다중 프레임 이미지에는 표시되는 프레임을 지정하는 정수 (0부터 계산) 인 &lt;code&gt;:index&lt;/code&gt; 속성 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4d504d5e42e9c61bf870243dcef604603b80aa9" translate="yes" xml:space="preserve">
          <source>A multi-use object that refers to a function, variable, or property list, and has a unique identity.</source>
          <target state="translated">함수, 변수 또는 속성 목록을 참조하고 고유 한 ID를 갖는 다용도 개체입니다.</target>
        </trans-unit>
        <trans-unit id="6d71bbf0c51fcb0696b8faf36cf9fec0e3aa991a" translate="yes" xml:space="preserve">
          <source>A mutable object stops being mutable if it is part of an expression that is evaluated. For example:</source>
          <target state="translated">변경 가능한 객체는 평가되는 표현식의 일부인 경우 변경이 불가능합니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="6888a521ac5206883d93875783df2620806f55a5" translate="yes" xml:space="preserve">
          <source>A negative number</source>
          <target state="translated">음수</target>
        </trans-unit>
        <trans-unit id="e9f4501d43e4d90ee2f96cf1abe12d4d05922e4e" translate="yes" xml:space="preserve">
          <source>A negative number counts from the end of the string, so that -1 signifies the index of the last character of the string. For example:</source>
          <target state="translated">음수는 문자열 끝부터 계산되므로 -1은 문자열의 마지막 문자 색인을 나타냅니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="2e25842cb9b14194506db7c6020a25184de4be86" translate="yes" xml:space="preserve">
          <source>A negative number has a similar effect as a positive number, but selects the window under the mouse pointer only after the mouse pointer has remained in it for the entire duration of the absolute value of that number and in addition has stopped moving.</source>
          <target state="translated">음수는 양수와 비슷한 효과를 갖지만 마우스 포인터가 해당 숫자의 절대 값의 전체 기간 동안 유지되고 추가로 이동을 멈춘 후에 만 ​​마우스 포인터 아래의 창을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="da4adefdf857b6336231abc20b5b558c2ad6342c" translate="yes" xml:space="preserve">
          <source>A nested sub-alist element looks like this:</source>
          <target state="translated">중첩 된 sub-alist 요소는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a12a25db6b08bb0eb9d657dfc01a94bb05fe63fe" translate="yes" xml:space="preserve">
          <source>A new internal window &lt;var&gt;W5&lt;/var&gt; has been created; its children are &lt;var&gt;W2&lt;/var&gt; and the new live window &lt;var&gt;W4&lt;/var&gt;. Now, &lt;var&gt;W2&lt;/var&gt; is the only sibling of &lt;var&gt;W4&lt;/var&gt;, so enlarging &lt;var&gt;W4&lt;/var&gt; will try to shrink &lt;var&gt;W2&lt;/var&gt;, leaving &lt;var&gt;W3&lt;/var&gt; unaffected. Observe that &lt;var&gt;W5&lt;/var&gt; represents a vertical combination of two windows embedded in the vertical combination &lt;var&gt;W1&lt;/var&gt;.</source>
          <target state="translated">새 내부 창 &lt;var&gt;W5&lt;/var&gt; 가 생성되었습니다. 자식은 &lt;var&gt;W2&lt;/var&gt; 이고 새 라이브 창 &lt;var&gt;W4&lt;/var&gt; 입니다. 이제, &lt;var&gt;W2&lt;/var&gt; 는 유일한 형제 인 &lt;var&gt;W4&lt;/var&gt; 는 확대 있도록, &lt;var&gt;W4&lt;/var&gt; 것은 축소하려고합니다 &lt;var&gt;W2&lt;/var&gt; 를 떠나, &lt;var&gt;W3&lt;/var&gt; 는 영향을받지 않습니다. 관찰 &lt;var&gt;W5&lt;/var&gt; 는 수직 조합에 포함 된 두 개의 윈도우의 수직 조합 나타내는 &lt;var&gt;W1&lt;/var&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="8e90e2d8579d4e6fb87c1c41547020d8e134911b" translate="yes" xml:space="preserve">
          <source>A new live window &lt;var&gt;W2&lt;/var&gt; is created, to the left of the internal window &lt;var&gt;W3&lt;/var&gt;. A new internal window &lt;var&gt;W1&lt;/var&gt; is created, becoming the new root window.</source>
          <target state="translated">내부 창 ( &lt;var&gt;W3&lt;/var&gt; ) 의 왼쪽에 새로운 라이브 창 ( &lt;var&gt;W2&lt;/var&gt; ) 이 생성된다 . 새 내부 창 &lt;var&gt;W1&lt;/var&gt; 이 생성되어 새 루트 창이됩니다.</target>
        </trans-unit>
        <trans-unit id="e0f54cfb880806196378b4a34cf642931e193eb7" translate="yes" xml:space="preserve">
          <source>A new window, however, will be created by splitting the reference window such that the chosen window will share the opposite edge with the reference window. In our example, a new root window would be created with a new live window and the reference window as its children. The chosen window&amp;rsquo;s right edge coordinate would then equal the left edge coordinate of the reference window. Its left edge coordinate would equal the left edge coordinate of the frame&amp;rsquo;s new root window.</source>
          <target state="translated">그러나 선택한 창이 참조 창과 반대쪽 모서리를 공유하도록 참조 창을 분할하면 새 창이 생성됩니다. 이 예에서는 새 라이브 창과 참조 창을 자식으로 사용하여 새 루트 창이 생성됩니다. 선택한 창의 오른쪽 가장자리 좌표는 참조 창의 왼쪽 가장자리 좌표와 같습니다. 왼쪽 가장자리 좌표는 프레임의 새 루트 창의 왼쪽 가장자리 좌표와 같습니다.</target>
        </trans-unit>
        <trans-unit id="e78fb6263a1080feaf13664527cc8aee4aa494cc" translate="yes" xml:space="preserve">
          <source>A newline can have a &lt;code&gt;line-height&lt;/code&gt; text or overlay property that controls the total height of the display line ending in that newline.</source>
          <target state="translated">줄 바꿈에는 &lt;code&gt;line-height&lt;/code&gt; 텍스트 또는 해당 줄 바꿈으로 끝나는 표시 줄의 전체 높이를 제어하는 ​​오버레이 속성이 있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9d4a406b984bf68d93883ae0aaacc2f86b270542" translate="yes" xml:space="preserve">
          <source>A newline can have a &lt;code&gt;line-height&lt;/code&gt; text or overlay property that controls the total height of the display line ending in that newline. See &lt;a href=&quot;line-height#Line-Height&quot;&gt;Line Height&lt;/a&gt;.</source>
          <target state="translated">줄 바꿈에는 &lt;code&gt;line-height&lt;/code&gt; 텍스트 또는 해당 줄 바꿈으로 끝나는 표시 줄의 전체 높이를 제어하는 ​​오버레이 속성이 있을 수 있습니다 . &lt;a href=&quot;line-height#Line-Height&quot;&gt;선 높이를&lt;/a&gt; 참고하십시오 .</target>
        </trans-unit>
        <trans-unit id="8c8bf6a760bbc674a4774ccb47c86778b816aa24" translate="yes" xml:space="preserve">
          <source>A newline can have a &lt;code&gt;line-spacing&lt;/code&gt; text or overlay property that controls the height of the display line ending with that newline. The property value overrides the default frame line spacing and the buffer local &lt;code&gt;line-spacing&lt;/code&gt; variable. See &lt;a href=&quot;line-height#Line-Height&quot;&gt;Line Height&lt;/a&gt;.</source>
          <target state="translated">줄 바꿈에는 &lt;code&gt;line-spacing&lt;/code&gt; 텍스트 또는 해당 줄 바꿈으로 끝나는 표시 줄의 높이를 제어하는 ​​오버레이 속성이 있을 수 있습니다 . 속성 값은 기본 프레임 줄 간격 및 버퍼 로컬 &lt;code&gt;line-spacing&lt;/code&gt; 변수를 재정의합니다 . &lt;a href=&quot;line-height#Line-Height&quot;&gt;선 높이를&lt;/a&gt; 참고하십시오 .</target>
        </trans-unit>
        <trans-unit id="11021806fd752c764a129675338bc40ee3fdba04" translate="yes" xml:space="preserve">
          <source>A nine-element vector &lt;code&gt;[&lt;var&gt;a&lt;/var&gt; &lt;var&gt;b&lt;/var&gt; &lt;var&gt;c&lt;/var&gt; &lt;var&gt;d&lt;/var&gt; &lt;var&gt;e&lt;/var&gt;
&lt;var&gt;f&lt;/var&gt; &lt;var&gt;g&lt;/var&gt; &lt;var&gt;h&lt;/var&gt; &lt;var&gt;p&lt;/var&gt;]&lt;/code&gt; represents an IPv6 address along with a port number. &lt;code&gt;format-network-address&lt;/code&gt; converts that to the string &lt;code&gt;&quot;[&lt;var&gt;a&lt;/var&gt;:&lt;var&gt;b&lt;/var&gt;:&lt;var&gt;c&lt;/var&gt;:&lt;var&gt;d&lt;/var&gt;:&lt;var&gt;e&lt;/var&gt;:&lt;var&gt;f&lt;/var&gt;:&lt;var&gt;g&lt;/var&gt;:&lt;var&gt;h&lt;/var&gt;]:&lt;var&gt;p&lt;/var&gt;&quot;&lt;/code&gt;.</source>
          <target state="translated">9 개 요소 벡터 &lt;code&gt;[&lt;var&gt;a&lt;/var&gt; &lt;var&gt;b&lt;/var&gt; &lt;var&gt;c&lt;/var&gt; &lt;var&gt;d&lt;/var&gt; &lt;var&gt;e&lt;/var&gt; &lt;var&gt;f&lt;/var&gt; &lt;var&gt;g&lt;/var&gt; &lt;var&gt;h&lt;/var&gt; &lt;var&gt;p&lt;/var&gt;]&lt;/code&gt; 는 포트 번호와 함께 IPv6 주소를 나타냅니다. &lt;code&gt;format-network-address&lt;/code&gt; 는이를 문자열 &lt;code&gt;&quot;[&lt;var&gt;a&lt;/var&gt;:&lt;var&gt;b&lt;/var&gt;:&lt;var&gt;c&lt;/var&gt;:&lt;var&gt;d&lt;/var&gt;:&lt;var&gt;e&lt;/var&gt;:&lt;var&gt;f&lt;/var&gt;:&lt;var&gt;g&lt;/var&gt;:&lt;var&gt;h&lt;/var&gt;]:&lt;var&gt;p&lt;/var&gt;&quot;&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="257aa05b7eddcf8d0df8b79a44b34b5bae0010cd" translate="yes" xml:space="preserve">
          <source>A node &lt;em&gt;encapsulates&lt;/em&gt; a data element much the way a variable holds a value. Normally, encapsulation occurs as a part of adding a node to the ewoc. You can retrieve the data element value and place a new value in its place, like so:</source>
          <target state="translated">노드 는 변수가 값을 보유하는 방식과 마찬가지로 데이터 요소를 &lt;em&gt;캡슐화&lt;/em&gt; 합니다. 일반적으로 캡슐화는 노드를 ewoc에 추가하는 과정에서 발생합니다. 다음과 같이 데이터 요소 값을 검색하고 그 자리에 새 값을 배치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="538490c91b8e54e71e0f8ac6a28516d887289f24" translate="yes" xml:space="preserve">
          <source>A non-&lt;code&gt;nil&lt;/code&gt; value also means that when &lt;code&gt;display-buffer&lt;/code&gt; is looking for a window already displaying &lt;var&gt;buffer-or-name&lt;/var&gt;, it can search any visible or iconified frame, not just the selected frame.</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; 이 아닌 값은 &lt;code&gt;display-buffer&lt;/code&gt; 가 이미 &lt;var&gt;buffer-or-name&lt;/var&gt; 을 표시하고있는 창 을 찾을 때 선택한 프레임뿐만 아니라 표시되거나 아이콘 화 된 모든 프레임을 검색 할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0546509f02b872fbaf2e962a3d60dc4ba6951208" translate="yes" xml:space="preserve">
          <source>A non-&lt;code&gt;nil&lt;/code&gt; value for &lt;code&gt;save-abbrevs&lt;/code&gt; means that Emacs should offer to save abbrevs (if any have changed) when files are saved. If the value is &lt;code&gt;silently&lt;/code&gt;, Emacs saves the abbrevs without asking the user. &lt;code&gt;abbrev-file-name&lt;/code&gt; specifies the file to save the abbrevs in. The default value is &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;save-abbrevs&lt;/code&gt; 에 대한 &lt;code&gt;nil&lt;/code&gt; 이 아닌 값은 파일이 저장 될 때 Emacs가 (변경된 경우) 약어를 저장하도록 제안해야 함을 의미합니다. 값이 있으면 &lt;code&gt;silently&lt;/code&gt; , 이맥스는 사용자를 묻지 않고 abbrevs을 절약 할 수 있습니다. &lt;code&gt;abbrev-file-name&lt;/code&gt; 은 약어 를 저장할 파일을 지정합니다. 기본값은 &lt;code&gt;t&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b743dba1b96b6f3a754be1bd1d208ff3d9b301ed" translate="yes" xml:space="preserve">
          <source>A non-&lt;code&gt;nil&lt;/code&gt; value indicates that the named function is free of side effects (see &lt;a href=&quot;what-is-a-function#What-Is-a-Function&quot;&gt;What Is a Function&lt;/a&gt;), so the byte compiler may ignore a call whose value is unused. If the property&amp;rsquo;s value is &lt;code&gt;error-free&lt;/code&gt;, the byte compiler may even delete such unused calls. In addition to byte compiler optimizations, this property is also used for determining function safety (see &lt;a href=&quot;function-safety#Function-Safety&quot;&gt;Function Safety&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; 이 아닌 값은 명명 된 함수에 부작용이 없음을 나타내므로 ( &lt;a href=&quot;what-is-a-function#What-Is-a-Function&quot;&gt;What Is a Function&lt;/a&gt; 참조 ) 바이트 컴파일러는 값이 사용되지 않는 호출을 무시할 수 있습니다. 속성의 값이 &lt;code&gt;error-free&lt;/code&gt; 경우 바이트 컴파일러는 사용하지 않는 호출을 삭제할 수도 있습니다. 바이트 컴파일러 최적화 외에,이 속성은 안전 기능 (참조 결정하기 위해 사용되는 &lt;a href=&quot;function-safety#Function-Safety&quot;&gt;기능 안전성&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="68d8637c2c063f5d516fcb409cb0bfe1e6ec8eb6" translate="yes" xml:space="preserve">
          <source>A non-&lt;code&gt;nil&lt;/code&gt; value prevents another frame from being raised or selected, if the window chosen by &lt;code&gt;display-buffer&lt;/code&gt; is displayed there. Primarily affected by this are &lt;code&gt;display-buffer-use-some-frame&lt;/code&gt; and &lt;code&gt;display-buffer-reuse-window&lt;/code&gt;. &lt;code&gt;display-buffer-pop-up-frame&lt;/code&gt; should be affected as well, but there is no guarantee that the window manager will comply.</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; 이 아닌 값은 &lt;code&gt;display-buffer&lt;/code&gt; 에 의해 선택된 창이 여기에 표시 되는 경우 다른 프레임이 올라가거나 선택되는 것을 방지 합니다. 이것에 의해 주로 영향을받는 것은 &lt;code&gt;display-buffer-use-some-frame&lt;/code&gt; 및 &lt;code&gt;display-buffer-reuse-window&lt;/code&gt; 입니다. &lt;code&gt;display-buffer-pop-up-frame&lt;/code&gt; 도 영향을 받아야하지만 창 관리자가 준수 할 것이라는 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="f7b66ab735a6729f6954795dc552d7446c33c1da" translate="yes" xml:space="preserve">
          <source>A non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;invisible&lt;/code&gt; property can make a character invisible on the screen. See &lt;a href=&quot;invisible-text#Invisible-Text&quot;&gt;Invisible Text&lt;/a&gt;, for details.</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; 이 아닌 &lt;code&gt;invisible&lt;/code&gt; 속성은 화면에서 캐릭터를 보이지 않게 할 수 있습니다. 자세한 내용은 &lt;a href=&quot;invisible-text#Invisible-Text&quot;&gt;보이지 않는 텍스트&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2242bd96c0d6345a1c62e452fe3a19f8f5f50094" translate="yes" xml:space="preserve">
          <source>A non-sparse keymap can have a parent too, but this is not very useful. A non-sparse keymap always specifies something as the binding for every numeric character code without modifier bits, even if it is &lt;code&gt;nil&lt;/code&gt;, so these character&amp;rsquo;s bindings are never inherited from the parent keymap.</source>
          <target state="translated">희소하지 않은 키맵도 부모를 가질 수 있지만 이것은 그다지 유용하지 않습니다. 비 희소 키맵은 &lt;code&gt;nil&lt;/code&gt; 이더라도 항상 수정 자 비트가없는 모든 숫자 문자 코드의 바인딩으로 무언가를 지정 하므로 이러한 문자의 바인딩은 상위 키맵에서 상속되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="96fdb38fb061323696d5e6da2be26efebae2b6ce" translate="yes" xml:space="preserve">
          <source>A non-zero value means the fringes outside the display margins; othersize they are between the margin and the text.</source>
          <target state="translated">0이 아닌 값은 디스플레이 여백 밖의 언저리를 의미합니다. 다른 크기는 여백과 텍스트 사이에 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e856f1217fd9e054bd7c26d7ccd34fcad9679df" translate="yes" xml:space="preserve">
          <source>A non-zero value means the window&amp;rsquo;s buffer was modified when the window was last updated.</source>
          <target state="translated">0이 아닌 값은 창이 마지막으로 업데이트 될 때 창 버퍼가 수정되었음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="f4ced26d5ee072b933c88766864abe951040432f" translate="yes" xml:space="preserve">
          <source>A normal hook run by &lt;code&gt;make-frame&lt;/code&gt; before it creates the frame.</source>
          <target state="translated">&lt;code&gt;make-frame&lt;/code&gt; 을 만들기 전에 make-frame에 의해 실행되는 일반적인 후크 .</target>
        </trans-unit>
        <trans-unit id="e085a7032b28a27db16c87868f46e839741bf52e" translate="yes" xml:space="preserve">
          <source>A normal hook run when the Emacs server creates a client frame. When this hook is called, the created frame is the selected one. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Emacs-Server.html#Emacs-Server&quot;&gt;Emacs Server&lt;/a&gt; in</source>
          <target state="translated">Emacs 서버가 클라이언트 프레임을 만들 때 실행되는 정상적인 후크입니다. 이 후크가 호출되면 생성 된 프레임이 선택된 프레임이됩니다. &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Emacs-Server.html#Emacs-Server&quot;&gt;Emacs Server&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="69b2704fab7bbe92fe40d18eb3d4fc4767c355fa" translate="yes" xml:space="preserve">
          <source>A note to C programmers: a Lisp list thus works as a &lt;em&gt;linked list&lt;/em&gt; built up of cons cells. Because pointers in Lisp are implicit, we do not distinguish between a cons cell slot holding a value versus pointing to the value.</source>
          <target state="translated">C 프로그래머를위한 참고 사항 : Lisp 목록은 따라서 단점 셀로 구성된 &lt;em&gt;연결 목록으로&lt;/em&gt; 작동합니다 . Lisp의 포인터는 암시 적이므로 값을 가리키는 cons 셀 슬롯과 값을 가리키는 셀 슬롯을 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8bf2ac93cadbf3bbb911da1d57b28b3c7ca4f30c" translate="yes" xml:space="preserve">
          <source>A number stands for itself. If &lt;code&gt;insert-register&lt;/code&gt; finds a number in the register, it converts the number to decimal.</source>
          <target state="translated">숫자는 그 자체를 나타냅니다. 경우 &lt;code&gt;insert-register&lt;/code&gt; 레지스터에 숫자를 발견, 그것은 소수에 수를 변환합니다.</target>
        </trans-unit>
        <trans-unit id="fbb60e0d4701e93358add5c45d04ef4a9d9e341e" translate="yes" xml:space="preserve">
          <source>A number, &lt;var&gt;factor&lt;/var&gt;, means to use a font that is &lt;var&gt;factor&lt;/var&gt; times as tall as the default font.</source>
          <target state="translated">숫자, &lt;var&gt;factor&lt;/var&gt; , 수단은 글꼴 사용하는 &lt;var&gt;factor&lt;/var&gt; 의 기본 글꼴과 같은 높이로 시간을.</target>
        </trans-unit>
        <trans-unit id="12ed92f05eab35deca7fec65e22fd2ef456204a0" translate="yes" xml:space="preserve">
          <source>A number, read with the minibuffer. If the input is not a number, the user has to try again. &amp;lsquo;</source>
          <target state="translated">미니 버퍼로 읽은 숫자. 입력이 숫자가 아닌 경우 사용자는 다시 시도해야합니다. '</target>
        </trans-unit>
        <trans-unit id="b18f7887ca8513454d55a4d747d8dd6eecba2669" translate="yes" xml:space="preserve">
          <source>A package archive is simply a directory in which the package files, and associated files, are stored. If you want the archive to be reachable via HTTP, this directory must be accessible to a web server; See &lt;a href=&quot;archive-web-server#Archive-Web-Server&quot;&gt;Archive Web Server&lt;/a&gt;.</source>
          <target state="translated">패키지 아카이브는 단순히 패키지 파일 및 관련 파일이 저장되는 디렉토리입니다. HTTP를 통해 아카이브에 접근 할 수 있도록하려면 웹 서버에서이 디렉토리에 액세스 할 수 있어야합니다. &lt;a href=&quot;archive-web-server#Archive-Web-Server&quot;&gt;아카이브 웹 서버를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e8bca31273aea629d01827e859940f97c7f10f48" translate="yes" xml:space="preserve">
          <source>A package is either a &lt;em&gt;simple package&lt;/em&gt; or a &lt;em&gt;multi-file package&lt;/em&gt;. A simple package is stored in a package archive as a single Emacs Lisp file, while a multi-file package is stored as a tar file (containing multiple Lisp files, and possibly non-Lisp files such as a manual).</source>
          <target state="translated">패키지는 &lt;em&gt;단순 패키지&lt;/em&gt; 또는 &lt;em&gt;다중 파일 패키지&lt;/em&gt; 입니다. 단순 패키지는 단일 Emacs Lisp 파일로 패키지 아카이브에 저장되는 반면, 다중 파일 패키지는 tar 파일 (여러 Lisp 파일 및 수동과 같은 비 Lisp 파일 포함)으로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="e856d8db6bbaad896bdc3b1232335f7c837149d7" translate="yes" xml:space="preserve">
          <source>A pair of integers &lt;code&gt;(&lt;var&gt;ticks&lt;/var&gt; . &lt;var&gt;hz&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;hz&lt;/var&gt; is positive. This represents &lt;var&gt;ticks&lt;/var&gt;/&lt;var&gt;hz&lt;/var&gt; seconds, which is the same time as plain &lt;var&gt;ticks&lt;/var&gt; if &lt;var&gt;hz&lt;/var&gt; is 1. A common value for &lt;var&gt;hz&lt;/var&gt; is 1000000000, for a nanosecond-resolution clock.&lt;a href=&quot;#FOOT24&quot; name=&quot;DOCF24&quot;&gt;&lt;sup&gt;24&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">정수 쌍 &lt;code&gt;(&lt;var&gt;ticks&lt;/var&gt; . &lt;var&gt;hz&lt;/var&gt;)&lt;/code&gt; , 여기서 &lt;var&gt;hz&lt;/var&gt; 는 양수입니다. 이것은 대표 &lt;var&gt;ticks&lt;/var&gt; / &lt;var&gt;hz&lt;/var&gt; 일반 같은시기 인 초 &lt;var&gt;ticks&lt;/var&gt; 경우 &lt;var&gt;hz&lt;/var&gt; 대 1. 공통의 값이고 &lt;var&gt;hz&lt;/var&gt; 나노초 해상도 클럭, 1000000000이다. &lt;a href=&quot;#FOOT24&quot; name=&quot;DOCF24&quot;&gt;&lt;sup&gt;24&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ef07d2e6711012f848d582415b0eef1559c6b894" translate="yes" xml:space="preserve">
          <source>A peculiar wrinkle of this feature is that binding the variable (with &lt;code&gt;let&lt;/code&gt; or other binding constructs) does not create a buffer-local binding for it. Only setting the variable (with &lt;code&gt;set&lt;/code&gt; or &lt;code&gt;setq&lt;/code&gt;), while the variable does not have a &lt;code&gt;let&lt;/code&gt;-style binding that was made in the current buffer, does so.</source>
          <target state="translated">이 기능의 특이한 점은 변수를 바인딩 ( &lt;code&gt;let&lt;/code&gt; 또는 다른 바인딩 구성으로)해도 이에 대한 버퍼 로컬 바인딩이 생성되지 않는다는 것입니다. 변수 ( &lt;code&gt;set&lt;/code&gt; 또는 &lt;code&gt;setq&lt;/code&gt; 사용 ) 만 설정하고 변수 에는 현재 버퍼에서 만든 &lt;code&gt;let&lt;/code&gt; 스타일 바인딩 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="65536651f3f1ec2171ac27cb6241d27ce7c4b3bb" translate="yes" xml:space="preserve">
          <source>A piece of executable code you can call from elsewhere.</source>
          <target state="translated">다른 곳에서 호출 할 수있는 실행 코드입니다.</target>
        </trans-unit>
        <trans-unit id="016d0dc9545552ea2f3842743d3079ba4d84de5b" translate="yes" xml:space="preserve">
          <source>A place-holder for a real function. If the autoload object is called, Emacs loads the file containing the definition of the real function, and then calls the real function. See &lt;a href=&quot;autoload#Autoload&quot;&gt;Autoload&lt;/a&gt;.</source>
          <target state="translated">실제 함수에 대한 자리 표시 자입니다. autoload 객체가 호출되면 Emacs는 실제 함수의 정의가 포함 된 파일을로드 한 다음 실제 함수를 호출합니다. &lt;a href=&quot;autoload#Autoload&quot;&gt;자동로드를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1a22f28df4d8c16ca0f7b01c3698b6f622a0739c" translate="yes" xml:space="preserve">
          <source>A pointer to the &lt;code&gt;buffer_text&lt;/code&gt; structure for this buffer. In an ordinary buffer, this is the &lt;code&gt;own_text&lt;/code&gt; field above. In an indirect buffer, this is the &lt;code&gt;own_text&lt;/code&gt; field of the base buffer.</source>
          <target state="translated">이 버퍼 의 &lt;code&gt;buffer_text&lt;/code&gt; 구조에 대한 포인터 . 일반 버퍼에서 이것은 위 의 &lt;code&gt;own_text&lt;/code&gt; 필드입니다. 간접 버퍼에서 이것은 기본 버퍼 의 &lt;code&gt;own_text&lt;/code&gt; 필드입니다.</target>
        </trans-unit>
        <trans-unit id="570f25dd8cbde7553399581a7984cd58caf0d35b" translate="yes" xml:space="preserve">
          <source>A pointer to the next buffer, in the chain of all buffers, including killed buffers. This chain is used only for allocation and garbage collection, in order to collect killed buffers properly.</source>
          <target state="translated">종료 된 버퍼를 포함하여 모든 버퍼의 체인에있는 다음 버퍼에 대한 포인터입니다. 이 체인은 죽인 버퍼를 적절하게 수집하기 위해 할당 및 가비지 수집에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="57379d0a3548b0207ddf3db6f5db3f7110d0b085" translate="yes" xml:space="preserve">
          <source>A polygon is a cons &lt;code&gt;(poly . [&lt;var&gt;x0&lt;/var&gt; &lt;var&gt;y0&lt;/var&gt; &lt;var&gt;x1&lt;/var&gt; &lt;var&gt;y1&lt;/var&gt; ...])&lt;/code&gt; where each pair in the vector describes one corner in the polygon.</source>
          <target state="translated">다각형은 벡터의 각 쌍이 다각형의 한 모서리를 설명 하는 단점 &lt;code&gt;(poly . [&lt;var&gt;x0&lt;/var&gt; &lt;var&gt;y0&lt;/var&gt; &lt;var&gt;x1&lt;/var&gt; &lt;var&gt;y1&lt;/var&gt; ...])&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6d184f39a07a100cdc18527abf48e77c7d525171" translate="yes" xml:space="preserve">
          <source>A position in a buffer.</source>
          <target state="translated">버퍼의 위치.</target>
        </trans-unit>
        <trans-unit id="2e300e61cf6c874347a9d67084477385216e6483" translate="yes" xml:space="preserve">
          <source>A positive &lt;var&gt;delta&lt;/var&gt; moves the edge downwards or to the right; a negative &lt;var&gt;delta&lt;/var&gt; moves it upwards or to the left. If the edge cannot be moved as far as specified by &lt;var&gt;delta&lt;/var&gt;, this function moves it as far as possible but does not signal an error.</source>
          <target state="translated">양수 &lt;var&gt;delta&lt;/var&gt; 는 가장자리를 아래쪽 또는 오른쪽으로 이동합니다. 음수 &lt;var&gt;delta&lt;/var&gt; 는 위쪽 또는 왼쪽으로 이동합니다. &lt;var&gt;delta&lt;/var&gt; 에서 지정한만큼 가장자리를 이동할 수없는 경우이 함수는 가장자리 를 가능한 한 멀리 이동하지만 오류를 표시하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="00aee430f7407880b2ed8ae8e14a657999cb9fc2" translate="yes" xml:space="preserve">
          <source>A positive integer always relates the left edge of the frame to the left edge of its display or parent frame. A negative integer relates the right frame edge to the right edge of the display or parent frame.</source>
          <target state="translated">양의 정수는 항상 프레임의 왼쪽 가장자리를 디스플레이 또는 상위 프레임의 왼쪽 가장자리와 관련시킵니다. 음의 정수는 오른쪽 프레임 가장자리를 디스플레이 또는 상위 프레임의 오른쪽 가장자리에 연결합니다.</target>
        </trans-unit>
        <trans-unit id="b5ffcdb1646a361febcec1ea23f34bdb7945e518" translate="yes" xml:space="preserve">
          <source>A positive integer specifies the width of the frame&amp;rsquo;s text area (see &lt;a href=&quot;frame-geometry#Frame-Geometry&quot;&gt;Frame Geometry&lt;/a&gt;) in characters.</source>
          <target state="translated">양의 정수는 프레임의 텍스트 영역 ( &lt;a href=&quot;frame-geometry#Frame-Geometry&quot;&gt;프레임 지오메트리&lt;/a&gt; 참조)의 너비를 문자로 지정합니다.</target>
        </trans-unit>
        <trans-unit id="ca19f2cd0cc62d23b3cfa1a1fcdc05db8c699a78" translate="yes" xml:space="preserve">
          <source>A positive number</source>
          <target state="translated">양수</target>
        </trans-unit>
        <trans-unit id="90c812fcb50800a70596785c5c0f3157cdfad686" translate="yes" xml:space="preserve">
          <source>A positive value of &lt;var&gt;delta&lt;/var&gt; means to check whether the window can be enlarged by that number of lines or columns; a negative value of &lt;var&gt;delta&lt;/var&gt; means to check whether the window can be shrunk by that many lines or columns. If &lt;var&gt;delta&lt;/var&gt; is non-zero, a return value of 0 means that the window cannot be resized.</source>
          <target state="translated">&lt;var&gt;delta&lt;/var&gt; 의 양수 값은 창을 해당 행 또는 열 수만큼 확대 할 수 있는지 여부를 확인하는 것을 의미합니다. &lt;var&gt;delta&lt;/var&gt; 의 음수 값은 창이 그만큼 줄이나 열로 축소 될 수 있는지 여부를 확인하는 것을 의미합니다. &lt;var&gt;delta&lt;/var&gt; 가 0이 아닌 경우 반환 값 0은 창 크기를 조정할 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="faaf39aa6748e84922a13fdbf38017d24158baa6" translate="yes" xml:space="preserve">
          <source>A predicate function with which to filter possible matches, or &lt;code&gt;nil&lt;/code&gt; if none. The function should call the predicate for each possible match, and ignore the match if the predicate returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">가능한 일치 항목을 필터링하는 데 사용할 술어 함수입니다 .없는 경우 &lt;code&gt;nil&lt;/code&gt; 입니다. 함수는 가능한 각 일치에 대해 술어를 호출해야하며 술어가 &lt;code&gt;nil&lt;/code&gt; 을 리턴하면 일치를 무시해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f75a5fa3a933e8bb3e9c6cbfd95d79808fdc8fe4" translate="yes" xml:space="preserve">
          <source>A predicate&amp;mdash;that is, a function of one argument that returns either &lt;code&gt;nil&lt;/code&gt; or non-&lt;code&gt;nil&lt;/code&gt; according to the argument. Using a predicate in the list says that objects for which the predicate returns non-&lt;code&gt;nil&lt;/code&gt; are acceptable.</source>
          <target state="translated">술어-즉, 인수 에 따라 &lt;code&gt;nil&lt;/code&gt; 또는 non- &lt;code&gt;nil&lt;/code&gt; 을 반환하는 하나 의 인수 함수입니다. 목록에서 술어를 사용하면 술어가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 것을 리턴하는 오브젝트 가 허용 가능함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="b10591c3a6de57d65c5089bf32dbdfd76eeb6cd9" translate="yes" xml:space="preserve">
          <source>A primitive that is like a function but does not evaluate all of its arguments in the usual way. It may evaluate only some of the arguments, or may evaluate them in an unusual order, or several times. Examples include &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;and&lt;/code&gt;, and &lt;code&gt;while&lt;/code&gt;. See &lt;a href=&quot;special-forms#Special-Forms&quot;&gt;Special Forms&lt;/a&gt;.</source>
          <target state="translated">함수와 비슷하지만 일반적인 방식으로 모든 인수를 평가하지 않는 프리미티브입니다. 인수 중 일부만 평가하거나 비정상적인 순서로 또는 여러 번 평가할 수 있습니다. 예로는 &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;and&lt;/code&gt; , &lt;code&gt;while&lt;/code&gt; 등이 있습니다. &lt;a href=&quot;special-forms#Special-Forms&quot;&gt;특수 양식을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b579867d6cd890e864414d728157548f1b508fd1" translate="yes" xml:space="preserve">
          <source>A problem that will seriously impair Emacs operation soon if you do not attend to it promptly.</source>
          <target state="translated">즉시 처리하지 않으면 곧 Emacs 작동을 심각하게 손상시킬 문제입니다.</target>
        </trans-unit>
        <trans-unit id="618f1e47e98772bcc8e7d133445246d27c02428e" translate="yes" xml:space="preserve">
          <source>A process &lt;em&gt;filter function&lt;/em&gt; is a function that receives the standard output from the associated process. &lt;em&gt;All&lt;/em&gt; output from that process is passed to the filter. The default filter simply outputs directly to the process buffer.</source>
          <target state="translated">프로세스 &lt;em&gt;필터 기능&lt;/em&gt; 은 연관된 프로세스에서 표준 출력을 수신하는 기능입니다. 해당 프로세스의 &lt;em&gt;모든&lt;/em&gt; 출력이 필터로 전달됩니다. 기본 필터는 단순히 프로세스 버퍼에 직접 출력합니다.</target>
        </trans-unit>
        <trans-unit id="42b4112adc62fa10e873c69e88cadab9c30de1e8" translate="yes" xml:space="preserve">
          <source>A process can (and usually does) have an &lt;em&gt;associated buffer&lt;/em&gt;, which is an ordinary Emacs buffer that is used for two purposes: storing the output from the process, and deciding when to kill the process. You can also use the buffer to identify a process to operate on, since in normal practice only one process is associated with any given buffer. Many applications of processes also use the buffer for editing input to be sent to the process, but this is not built into Emacs Lisp.</source>
          <target state="translated">프로세스는 두 가지 목적으로 사용되는 일반적인 Emacs 버퍼 인 &lt;em&gt;연관된 buffer를&lt;/em&gt; 가질 수 있습니다 . 일반적으로 하나의 프로세스 만 주어진 버퍼와 연관되기 때문에 버퍼를 사용하여 작업 할 프로세스를 식별 할 수도 있습니다. 프로세스의 많은 응용 프로그램은 프로세스로 보낼 입력을 편집하기 위해 버퍼를 사용하지만 Emacs Lisp에 내장되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b9529b352bcf05c67171a60f84faa1cb5c0b72d2" translate="yes" xml:space="preserve">
          <source>A prompt immediately follows the code character. The prompt ends either with the end of the string or with a newline.</source>
          <target state="translated">코드 문자 바로 뒤에 프롬프트가 표시됩니다. 프롬프트는 문자열의 끝이나 개행으로 끝납니다.</target>
        </trans-unit>
        <trans-unit id="5c8c3454642c57a58973a211104a3e9fe7826baf" translate="yes" xml:space="preserve">
          <source>A pseudo-Lisp summary of searching active maps.</source>
          <target state="translated">활성 맵 검색에 대한 의사 Lisp 요약입니다.</target>
        </trans-unit>
        <trans-unit id="3cad1be83cf5d8d04672aa32ebef05f6a9b2fc4d" translate="yes" xml:space="preserve">
          <source>A question followed by an answer has two messages like the ones produced by &lt;code&gt;y-or-n-p&lt;/code&gt;: the first is &amp;lsquo;</source>
          <target state="translated">답변이 뒤 따르는 질문에는 &lt;code&gt;y-or-n-p&lt;/code&gt; 의해 생성 된 것과 같은 두 개의 메시지가 있습니다 . 첫 번째는 '</target>
        </trans-unit>
        <trans-unit id="8ea502c0ed6ef5dfe4f9ef1e23c5f6d04605cf5f" translate="yes" xml:space="preserve">
          <source>A quoted constant&amp;mdash;that is, &lt;code&gt;'&lt;var&gt;object&lt;/var&gt;&lt;/code&gt;. This sort of element in the list says that &lt;var&gt;object&lt;/var&gt; itself is an acceptable value.</source>
          <target state="translated">인용 된 상수, 즉 &lt;code&gt;'&lt;var&gt;object&lt;/var&gt;&lt;/code&gt; . 목록에있는 이러한 종류의 요소는 &lt;var&gt;object&lt;/var&gt; 자체가 허용 가능한 값 임을 나타 냅니다 .</target>
        </trans-unit>
        <trans-unit id="242ca05185b3294d6a0d632822a42b3a5da80025" translate="yes" xml:space="preserve">
          <source>A range is not affected by the locale&amp;rsquo;s collation sequence: it always represents the set of characters with codepoints ranging between those of its bounds, so that &amp;lsquo;</source>
          <target state="translated">범위는 로케일의 데이터 정렬 순서의 영향을받지 않습니다. 항상 해당 범위 사이의 코드 포인트 범위가있는 문자 세트를 나타내므로 '</target>
        </trans-unit>
        <trans-unit id="5c4c3a1951ef6f57d1c7ca838ccf2d8eb696240b" translate="yes" xml:space="preserve">
          <source>A record is considered a constant for evaluation: the result of evaluating it is the same record. This does not evaluate or even examine the slots. See &lt;a href=&quot;self_002devaluating-forms#Self_002dEvaluating-Forms&quot;&gt;Self-Evaluating Forms&lt;/a&gt;.</source>
          <target state="translated">레코드는 평가를위한 상수로 간주됩니다. 평가 결과는 동일한 레코드입니다. 이것은 슬롯을 평가하거나 검사하지 않습니다. &lt;a href=&quot;self_002devaluating-forms#Self_002dEvaluating-Forms&quot;&gt;자체 평가 양식을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1e8a6905d630d3404029e75db8db9a5413103c0b" translate="yes" xml:space="preserve">
          <source>A rectangle is a cons &lt;code&gt;(rect . ((&lt;var&gt;x0&lt;/var&gt; . &lt;var&gt;y0&lt;/var&gt;) . (&lt;var&gt;x1&lt;/var&gt; . &lt;var&gt;y1&lt;/var&gt;)))&lt;/code&gt; which specifies the pixel coordinates of the upper left and bottom right corners of the rectangle area.</source>
          <target state="translated">사각형은 사각형 영역의 왼쪽 상단과 오른쪽 하단 모서리의 픽셀 좌표를 지정 하는 cons &lt;code&gt;(rect . ((&lt;var&gt;x0&lt;/var&gt; . &lt;var&gt;y0&lt;/var&gt;) . (&lt;var&gt;x1&lt;/var&gt; . &lt;var&gt;y1&lt;/var&gt;)))&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="760581ec68346b2eddde59f770ca37fb8b422e75" translate="yes" xml:space="preserve">
          <source>A rectangle is represented by a list of strings.</source>
          <target state="translated">사각형은 문자열 목록으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="3346e6273038fc64f4fbb8d374b1fce2c136e83d" translate="yes" xml:space="preserve">
          <source>A region is valid if it has a non-zero size, or if the user option &lt;code&gt;use-empty-active-region&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt; (by default, it is &lt;code&gt;nil&lt;/code&gt;). The function &lt;code&gt;region-active-p&lt;/code&gt; is similar to &lt;code&gt;use-region-p&lt;/code&gt;, but considers all regions as valid. In most cases, you should not use &lt;code&gt;region-active-p&lt;/code&gt;, since if the region is empty it is often more appropriate to operate on point.</source>
          <target state="translated">영역은 크기가 0이 아니거나 사용자 옵션 &lt;code&gt;use-empty-active-region&lt;/code&gt; 이 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 (기본적으로 &lt;code&gt;nil&lt;/code&gt; ) 유효 합니다. &lt;code&gt;region-active-p&lt;/code&gt; 함수 는 &lt;code&gt;use-region-p&lt;/code&gt; 와 유사 하지만 모든 지역을 유효한 것으로 간주합니다. 대부분의 경우 &lt;code&gt;region-active-p&lt;/code&gt; 를 사용하지 않아야 합니다. 영역이 비어 있으면 point에서 작업하는 것이 더 적절하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="7645bf9394c9f078e2e073f4f4aec37d09bc9f80" translate="yes" xml:space="preserve">
          <source>A register is a sort of variable used in Emacs editing that can hold a variety of different kinds of values. Each register is named by a single character. All</source>
          <target state="translated">레지스터는 다양한 종류의 값을 보유 할 수있는 Emacs 편집에 사용되는 일종의 변수입니다. 각 레지스터는 단일 문자로 명명됩니다. 모두</target>
        </trans-unit>
        <trans-unit id="7979e8220db786a30b8cd38e091bc3092e455529" translate="yes" xml:space="preserve">
          <source>A regular expression which is used to recognize files represented in this format. If &lt;code&gt;nil&lt;/code&gt;, the format is never applied automatically.</source>
          <target state="translated">이 형식으로 표시된 파일을 인식하는 데 사용되는 정규식입니다. 경우 &lt;code&gt;nil&lt;/code&gt; , 형식이 자동으로 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c24b91a9f9a759a8c4432a87f2b4e9fd5d3ae1d4" translate="yes" xml:space="preserve">
          <source>A repeating timer nominally ought to run every &lt;var&gt;repeat&lt;/var&gt; seconds, but remember that any invocation of a timer can be late. Lateness of one repetition has no effect on the scheduled time of the next repetition. For instance, if Emacs is busy computing for long enough to cover three scheduled repetitions of the timer, and then starts to wait, it will immediately call the timer function three times in immediate succession (presuming no other timers trigger before or between them). If you want a timer to run again no less than &lt;var&gt;n&lt;/var&gt; seconds after the last invocation, don&amp;rsquo;t use the &lt;var&gt;repeat&lt;/var&gt; argument. Instead, the timer function should explicitly reschedule the timer.</source>
          <target state="translated">반복 타이머는 명목상 &lt;var&gt;repeat&lt;/var&gt; 초 마다 실행되어야 하지만 타이머 호출이 지연 될 수 있음을 기억하십시오. 한 번의 반복 지연은 다음 반복의 예정된 시간에 영향을주지 않습니다. 예를 들어, Emacs가 타이머의 세 번의 예약 된 반복을 처리 할 수있을만큼 충분히 오랫동안 컴퓨팅에 바쁘다가 대기를 시작하면 즉시 타이머 함수를 즉시 세 번 호출합니다 (다른 타이머가 그들 사이에 트리거되지 않는다고 가정). 마지막 호출 후 &lt;var&gt;n&lt;/var&gt; 초 이내에 타이머를 다시 실행 하려면 &lt;var&gt;repeat&lt;/var&gt; 인수를 사용하지 마십시오 . 대신 타이머 기능이 타이머를 명시 적으로 다시 예약해야합니다.</target>
        </trans-unit>
        <trans-unit id="e2f2ef14d718ca929e8c78fb3c4ed893768a421e" translate="yes" xml:space="preserve">
          <source>A report of data or circumstances that are inherently wrong.</source>
          <target state="translated">본질적으로 잘못된 데이터 또는 상황에 대한 보고서입니다.</target>
        </trans-unit>
        <trans-unit id="eb8781d25e6f48f39b9f40a9a917637ab87ff6e8" translate="yes" xml:space="preserve">
          <source>A report of data or circumstances that are not inherently wrong, but raise suspicion of a possible problem.</source>
          <target state="translated">본질적으로 잘못된 것은 아니지만 가능한 문제를 의심하는 데이터 또는 상황에 대한 보고서입니다.</target>
        </trans-unit>
        <trans-unit id="d307c7cf4ee99bc6a57ebcd6b8bdb77c9921af7c" translate="yes" xml:space="preserve">
          <source>A report of information that may be useful if you are debugging.</source>
          <target state="translated">디버깅하는 경우 유용 할 수있는 정보 보고서입니다.</target>
        </trans-unit>
        <trans-unit id="c2d41ababeb627cbea79a2b4774d407966246992" translate="yes" xml:space="preserve">
          <source>A request coming into the Emacs server (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Emacs-Server.html#Emacs-Server&quot;&gt;Emacs Server&lt;/a&gt; in</source>
          <target state="translated">이맥스 서버로 들어오는 요청하십시오 ( &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Emacs-Server.html#Emacs-Server&quot;&gt;이맥스 서버&lt;/a&gt; 에</target>
        </trans-unit>
        <trans-unit id="4719bdbbbee0aec61be6413a247c988307546c30" translate="yes" xml:space="preserve">
          <source>A search which fails may or may not alter the match data. In the current implementation, it does not, but we may change it in the future. Don&amp;rsquo;t try to rely on the value of the match data after a failing search.</source>
          <target state="translated">실패한 검색은 일치 데이터를 변경하거나 변경하지 않을 수 있습니다. 현재 구현에서는 그렇지 않지만 향후 변경 될 수 있습니다. 검색 실패 후 일치 데이터의 값에 의존하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="19f76fe6ffeea4fd01e5d22be85263b150bdcc1b" translate="yes" xml:space="preserve">
          <source>A self-evaluating form yields a value that becomes part of the program, and you should not try to modify it via &lt;code&gt;setcar&lt;/code&gt;, &lt;code&gt;aset&lt;/code&gt; or similar operations. The Lisp interpreter might unify the constants yielded by your program&amp;rsquo;s self-evaluating forms, so that these constants might share structure. See &lt;a href=&quot;mutability#Mutability&quot;&gt;Mutability&lt;/a&gt;.</source>
          <target state="translated">자체 평가 양식은 프로그램의 일부가되는 값을 생성하므로 &lt;code&gt;setcar&lt;/code&gt; , &lt;code&gt;aset&lt;/code&gt; 또는 유사한 작업을 통해 수정하려고 시도해서는 안됩니다 . Lisp 인터프리터는 프로그램의 자체 평가 형식에서 생성 된 상수를 통합하여 이러한 상수가 구조를 공유 할 수 있습니다. &lt;a href=&quot;mutability#Mutability&quot;&gt;Mutability를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="809f65864b2f06a73611f6d9773e8af0e1c6a342" translate="yes" xml:space="preserve">
          <source>A sentinel runs only while Emacs is waiting (e.g., for terminal input, or for time to elapse, or for process output). This avoids the timing errors that could result from running sentinels at random places in the middle of other Lisp programs. A program can wait, so that sentinels will run, by calling &lt;code&gt;sit-for&lt;/code&gt; or &lt;code&gt;sleep-for&lt;/code&gt; (see &lt;a href=&quot;waiting#Waiting&quot;&gt;Waiting&lt;/a&gt;), or &lt;code&gt;accept-process-output&lt;/code&gt; (see &lt;a href=&quot;accepting-output#Accepting-Output&quot;&gt;Accepting Output&lt;/a&gt;). Emacs also allows sentinels to run when the command loop is reading input. &lt;code&gt;delete-process&lt;/code&gt; calls the sentinel when it terminates a running process.</source>
          <target state="translated">센티넬은 Emacs가 대기하는 동안에 만 실행됩니다 (예 : 터미널 입력, 경과 시간 또는 프로세스 출력). 이렇게하면 다른 Lisp 프로그램 중간에있는 임의의 위치에서 센티넬을 실행할 때 발생할 수있는 타이밍 오류를 방지 할 수 있습니다. 프로그램은 &lt;code&gt;sit-for&lt;/code&gt; 또는 &lt;code&gt;sleep-for&lt;/code&gt; ( &lt;a href=&quot;waiting#Waiting&quot;&gt;Waiting&lt;/a&gt; 참조 ) 또는 &lt;code&gt;accept-process-output&lt;/code&gt; ( &lt;a href=&quot;accepting-output#Accepting-Output&quot;&gt;Accepting Output&lt;/a&gt; 참조 ) 을 호출하여 센티널이 실행되도록 대기 할 수 있습니다 . Emacs는 또한 명령 루프가 입력을 읽을 때 센티넬이 실행되도록합니다. &lt;code&gt;delete-process&lt;/code&gt; 는 실행중인 프로세스를 종료 할 때 센티넬을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="7e6cb7e7f9dd3a2fd01fc8d41681abcaa0d49a05" translate="yes" xml:space="preserve">
          <source>A sentinel that writes the output into the buffer of the process should check whether the buffer is still alive. If it tries to insert into a dead buffer, it will get an error. If the buffer is dead, &lt;code&gt;(buffer-name (process-buffer &lt;var&gt;process&lt;/var&gt;))&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">프로세스의 버퍼에 출력을 쓰는 감시자는 버퍼가 아직 살아 있는지 확인해야합니다. 데드 버퍼에 삽입하려고하면 오류가 발생합니다. 버퍼가 죽은 경우 &lt;code&gt;(buffer-name (process-buffer &lt;var&gt;process&lt;/var&gt;))&lt;/code&gt; 는 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="9064318e89e1a55faeb1389633cadc95355e58cb" translate="yes" xml:space="preserve">
          <source>A serial connection is represented by a process object, which can be used in a similar way to a subprocess or network process. You can send and receive data, and configure the serial port. A serial process object has no process ID, however, and you can&amp;rsquo;t send signals to it, and the status codes are different from other types of processes. &lt;code&gt;delete-process&lt;/code&gt; on the process object or &lt;code&gt;kill-buffer&lt;/code&gt; on the process buffer close the connection, but this does not affect the device connected to the serial port.</source>
          <target state="translated">직렬 연결은 프로세스 개체로 표시되며 하위 프로세스 또는 네트워크 프로세스와 유사한 방식으로 사용할 수 있습니다. 데이터를 송수신하고 직렬 포트를 구성 할 수 있습니다. 그러나 직렬 프로세스 개체에는 프로세스 ID가 없으며 신호를 보낼 수 없으며 상태 코드는 다른 유형의 프로세스와 다릅니다. 프로세스 개체의 &lt;code&gt;delete-process&lt;/code&gt; 또는 프로세스 버퍼의 &lt;code&gt;kill-buffer&lt;/code&gt; 는 연결을 닫지 만 직렬 포트에 연결된 장치에는 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="21fa9f7da229282ff2694dd4a704dadec42a314f" translate="yes" xml:space="preserve">
          <source>A series of progress messages has successive messages like those produced by &lt;code&gt;make-progress-reporter&lt;/code&gt;. They have the form &amp;lsquo;</source>
          <target state="translated">일련의 진행 메시지에는 &lt;code&gt;make-progress-reporter&lt;/code&gt; 가 생성 한 것과 같은 연속 메시지가 있습니다. 그들은 '</target>
        </trans-unit>
        <trans-unit id="d71f439ab0b95d0944c5e07853acd9ce8564b47a" translate="yes" xml:space="preserve">
          <source>A shell command is represented as a string; Emacs runs the command as a filter to perform the conversion.</source>
          <target state="translated">쉘 명령은 문자열로 표시됩니다. Emacs는 명령을 필터로 실행하여 변환을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="f3bb37324cc51a26f83843d1862a1fad8f6884b1" translate="yes" xml:space="preserve">
          <source>A shell command or function to decode data in this format (to convert file data into the usual Emacs data representation).</source>
          <target state="translated">이 형식의 데이터를 디코딩하는 셸 명령 또는 함수 (파일 데이터를 일반적인 Emacs 데이터 표현으로 변환).</target>
        </trans-unit>
        <trans-unit id="5ec054c18402296c7ff7d861f7941798d34c99a2" translate="yes" xml:space="preserve">
          <source>A shell command or function to encode data in this format&amp;mdash;that is, to convert the usual Emacs data representation into this format.</source>
          <target state="translated">데이터를이 형식으로 인코딩하는 쉘 명령 또는 함수, 즉 일반적인 Emacs 데이터 표현을이 형식으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="bc6de15dd942ef7840dc24baab1e8703aa52b682" translate="yes" xml:space="preserve">
          <source>A shell connection.</source>
          <target state="translated">쉘 연결.</target>
        </trans-unit>
        <trans-unit id="9094c70e17d9457eebec5ed27a044e758bc6892f" translate="yes" xml:space="preserve">
          <source>A short word (e.g., &amp;lsquo;</source>
          <target state="translated">짧은 단어 (예 : '</target>
        </trans-unit>
        <trans-unit id="ce6ed42d12370e9ea126ada03e72bd7201fc704a" translate="yes" xml:space="preserve">
          <source>A short-cut function is useful in modes such as C mode and Lisp mode, where the &lt;code&gt;indent-line-function&lt;/code&gt; must scan from the beginning of the function definition: applying it to each line would be quadratic in time. The short cut can update the scan information as it moves through the lines indenting them; this takes linear time. In a mode where indenting a line individually is fast, there is no need for a short cut.</source>
          <target state="translated">바로 가기 기능은 C 모드 및 Lisp 모드와 같은 모드에서 유용합니다. 여기서 &lt;code&gt;indent-line-function&lt;/code&gt; 은 함수 정의의 시작 부분부터 스캔해야합니다. 각 행에 적용하면 시간이 2 차가됩니다. 바로 가기는 들여 쓰기 된 줄을 따라 이동할 때 스캔 정보를 업데이트 할 수 있습니다. 이것은 선형 시간이 걸립니다. 줄을 개별적으로 들여 쓰기가 빠른 모드에서는 바로 가기가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dc7b14268a4f6af9d3385017ee2059ab1e06d721" translate="yes" xml:space="preserve">
          <source>A simple example.</source>
          <target state="translated">간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="ab823a2c48df7184be7245e578393bb0a5fddeca" translate="yes" xml:space="preserve">
          <source>A simple kind of menu key binding.</source>
          <target state="translated">간단한 종류의 메뉴 키 바인딩.</target>
        </trans-unit>
        <trans-unit id="277219dee67d93e83d0e5932ad5a5a1753829752" translate="yes" xml:space="preserve">
          <source>A simple minded indentation engine.</source>
          <target state="translated">단순한 들여 쓰기 엔진.</target>
        </trans-unit>
        <trans-unit id="5d11d08e977e9455c28873a94f783cd668ae1815" translate="yes" xml:space="preserve">
          <source>A simple package consists of a single Emacs Lisp source file. The file must conform to the Emacs Lisp library header conventions (see &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/elisp/Library-Headers.html#Library-Headers&quot;&gt;Library Headers&lt;/a&gt;). The package&amp;rsquo;s attributes are taken from the various headers, as illustrated by the following example:</source>
          <target state="translated">간단한 패키지는 단일 Emacs Lisp 소스 파일로 구성됩니다. 파일은 Emacs Lisp 라이브러리 헤더 규칙을 따라야합니다 ( &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/elisp/Library-Headers.html#Library-Headers&quot;&gt;라이브러리 헤더&lt;/a&gt; 참조 ). 패키지의 속성은 다음 예제에 설명 된대로 다양한 헤더에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="520a895cdaf962be2ce3af051f139699eaa002ef" translate="yes" xml:space="preserve">
          <source>A simple way to find out which variables need a variable definition is to byte-compile the source file. See &lt;a href=&quot;byte-compilation#Byte-Compilation&quot;&gt;Byte Compilation&lt;/a&gt;. If a non-special variable is used outside of a &lt;code&gt;let&lt;/code&gt; form, the byte-compiler will warn about reference or assignment to a free variable. If a non-special variable is bound but not used within a &lt;code&gt;let&lt;/code&gt; form, the byte-compiler will warn about an unused lexical variable. The byte-compiler will also issue a warning if you use a special variable as a function argument.</source>
          <target state="translated">변수 정의가 필요한 변수를 찾는 간단한 방법은 소스 파일을 바이트 컴파일하는 것입니다. &lt;a href=&quot;byte-compilation#Byte-Compilation&quot;&gt;바이트 컴파일을&lt;/a&gt; 참조하십시오 . 비 특수 변수가 &lt;code&gt;let&lt;/code&gt; 형식 외부에서 사용되는 경우 바이트 컴파일러는 자유 변수에 대한 참조 또는 할당에 대해 경고합니다. 비 특수 변수가 바인딩되었지만 &lt;code&gt;let&lt;/code&gt; 형식 내에서 사용되지 않는 경우 바이트 컴파일러는 사용되지 않은 어휘 변수에 대해 경고합니다. 바이트 컴파일러는 특수 변수를 함수 인수로 사용하는 경우에도 경고를 발행합니다.</target>
        </trans-unit>
        <trans-unit id="6f39c8140232b676e89b57d7d761a068ed372a35" translate="yes" xml:space="preserve">
          <source>A single X server can handle more than one display. Each X display has a three-part name, &amp;lsquo;</source>
          <target state="translated">단일 X 서버는 둘 이상의 디스플레이를 처리 할 수 ​​있습니다. 각 X 디스플레이에는 세 부분으로 된 이름 '</target>
        </trans-unit>
        <trans-unit id="32d2586e3a5876244258502d69a6f8d0bd5a0545" translate="yes" xml:space="preserve">
          <source>A single dashed line in the menu&amp;rsquo;s foreground color.</source>
          <target state="translated">메뉴 전경색의 단일 파선.</target>
        </trans-unit>
        <trans-unit id="0c3c5559359b2d5a679708aa8a74ccf3b71a8107" translate="yes" xml:space="preserve">
          <source>A single dashed line with a 3D raised appearance.</source>
          <target state="translated">3D 돌출 모양의 단일 파선입니다.</target>
        </trans-unit>
        <trans-unit id="17212cacb20906b6c24890be72d573523178f23c" translate="yes" xml:space="preserve">
          <source>A single dashed line with a 3D sunken appearance.</source>
          <target state="translated">3D 움푹 들어간 모양의 단일 파선.</target>
        </trans-unit>
        <trans-unit id="82b9849c085f11ad9ba2a7d45a6524fef0303bac" translate="yes" xml:space="preserve">
          <source>A single evaluated expression, which is instrumented. If your macro wraps the expression with &lt;code&gt;lambda&lt;/code&gt; before it is evaluated, use &lt;code&gt;def-form&lt;/code&gt; instead. See &lt;code&gt;def-form&lt;/code&gt; below.</source>
          <target state="translated">계측 된 단일 평가 식입니다. 매크로 가 평가되기 전에 &lt;code&gt;lambda&lt;/code&gt; 표현식을 래핑하는 경우 대신 &lt;code&gt;def-form&lt;/code&gt; 을 사용합니다. 아래 &lt;code&gt;def-form&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c513f75e3380a33dab37bc8aac024b117ef8a454" translate="yes" xml:space="preserve">
          <source>A single keymap directly specifies definitions for individual events. When a key sequence consists of a single event, its binding in a keymap is the keymap&amp;rsquo;s definition for that event. The binding of a longer key sequence is found by an iterative process: first find the definition of the first event (which must itself be a keymap); then find the second event&amp;rsquo;s definition in that keymap, and so on until all the events in the key sequence have been processed.</source>
          <target state="translated">단일 키맵은 개별 이벤트에 대한 정의를 직접 지정합니다. 키 시퀀스가 ​​단일 이벤트로 구성되면 키맵의 바인딩이 해당 이벤트에 대한 키맵의 정의입니다. 더 긴 키 시퀀스의 바인딩은 반복 프로세스에 의해 발견됩니다. 먼저 첫 번째 이벤트의 정의를 찾으십시오 (자체가 키맵이어야 함). 그런 다음 해당 키맵에서 두 번째 이벤트의 정의를 찾고 키 시퀀스의 모든 이벤트가 처리 될 때까지 계속합니다.</target>
        </trans-unit>
        <trans-unit id="68df86ba1c5862318582f32a099345601694b64c" translate="yes" xml:space="preserve">
          <source>A single line in the menu&amp;rsquo;s foreground color.</source>
          <target state="translated">메뉴의 전경색 한 줄.</target>
        </trans-unit>
        <trans-unit id="3641adcfa90046311ac53168ff3f79632b8c65e5" translate="yes" xml:space="preserve">
          <source>A single line with a 3D raised appearance.</source>
          <target state="translated">3D 돌출 모양의 단일 선입니다.</target>
        </trans-unit>
        <trans-unit id="23b2b0891d5f5c8e4e993fb83b1fecf8c9b84e7c" translate="yes" xml:space="preserve">
          <source>A single line with a 3D sunken appearance. This is the default, used separators consisting of dashes only.</source>
          <target state="translated">3D 움푹 들어간 모양의 단일 선. 대시로만 구성된 기본 사용 구분 기호입니다.</target>
        </trans-unit>
        <trans-unit id="1f59dc4152bf6a9fe4beadc9f38421d0b0d74e59" translate="yes" xml:space="preserve">
          <source>A single unevaluated Lisp object, which is not instrumented.</source>
          <target state="translated">계측되지 않은 평가되지 않은 단일 Lisp 개체입니다.</target>
        </trans-unit>
        <trans-unit id="9bf5016aa282317531cb06fa6fb9bc5beb69e9c5" translate="yes" xml:space="preserve">
          <source>A small number of additional symbols are made read-only for various practical reasons. These include &lt;code&gt;enable-multibyte-characters&lt;/code&gt;, &lt;code&gt;most-positive-fixnum&lt;/code&gt;, &lt;code&gt;most-negative-fixnum&lt;/code&gt;, and a few others. Any attempt to set or bind these also signals a &lt;code&gt;setting-constant&lt;/code&gt; error.</source>
          <target state="translated">다양한 실제적인 이유로 적은 수의 추가 기호가 읽기 전용으로 만들어집니다. 여기에는 &lt;code&gt;enable-multibyte-characters&lt;/code&gt; , &lt;code&gt;most-positive-fixnum&lt;/code&gt; , &lt;code&gt;most-negative-fixnum&lt;/code&gt; 및 기타 몇 가지가 포함됩니다. 이를 설정하거나 바인딩하려는 시도는 &lt;code&gt;setting-constant&lt;/code&gt; 오류를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7f66127e9377d487c9f73a0fe060d40fd147df4f" translate="yes" xml:space="preserve">
          <source>A source-level Emacs Lisp debugger.</source>
          <target state="translated">소스 레벨 Emacs Lisp 디버거.</target>
        </trans-unit>
        <trans-unit id="eb28b2c1df892613561beddc4f55a0e071830859" translate="yes" xml:space="preserve">
          <source>A sparse keymap for keys that follows the</source>
          <target state="translated">뒤에 오는 키에 대한 희소 키맵</target>
        </trans-unit>
        <trans-unit id="a9aac0b1d7a10812c3d23d1c071d53d1c3d93f10" translate="yes" xml:space="preserve">
          <source>A sparse keymap for subcommands of the prefix</source>
          <target state="translated">접두사의 하위 명령에 대한 희소 키맵</target>
        </trans-unit>
        <trans-unit id="40c40f01737627b7bbebfaa0fb152cd44949cc13" translate="yes" xml:space="preserve">
          <source>A sparse keymap for the keys following the help character</source>
          <target state="translated">도움말 문자 다음에 나오는 키에 대한 희소 키맵</target>
        </trans-unit>
        <trans-unit id="fa46b728661fa6d918bb2c7cb51670008d478213" translate="yes" xml:space="preserve">
          <source>A sparse keymap that provides global bindings for search-related commands.</source>
          <target state="translated">검색 관련 명령에 대한 전역 바인딩을 제공하는 희소 키맵입니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
