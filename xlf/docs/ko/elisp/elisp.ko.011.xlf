<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="elisp">
    <body>
      <group id="elisp">
        <trans-unit id="6ac036b8d1c1ea2354a0438f84ad30f9852d9133" translate="yes" xml:space="preserve">
          <source>If this variable&amp;rsquo;s value is non-&lt;code&gt;nil&lt;/code&gt;, it is a symbol which is used as a text property name. A non-&lt;code&gt;nil&lt;/code&gt; value for that text property means the other text properties for this character have already been computed.</source>
          <target state="translated">이 변수의 값이 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 텍스트 속성 이름으로 사용되는 기호입니다. 해당 텍스트 속성에 대한 &lt;code&gt;nil&lt;/code&gt; 이 아닌 값은이 문자에 대한 다른 텍스트 속성이 이미 계산되었음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8e2bb8ec07b4bc794a3673b2e73ca58eb14b1ba1" translate="yes" xml:space="preserve">
          <source>If two objects &lt;var&gt;obj1&lt;/var&gt; and &lt;var&gt;obj2&lt;/var&gt; are &lt;code&gt;eq&lt;/code&gt;, then &lt;code&gt;(sxhash-eq &lt;var&gt;obj1&lt;/var&gt;)&lt;/code&gt; and &lt;code&gt;(sxhash-eq &lt;var&gt;obj2&lt;/var&gt;)&lt;/code&gt; are the same integer.</source>
          <target state="translated">두 객체 &lt;var&gt;obj1&lt;/var&gt; 및 &lt;var&gt;obj2&lt;/var&gt; 가 &lt;code&gt;eq&lt;/code&gt; 이면 &lt;code&gt;(sxhash-eq &lt;var&gt;obj1&lt;/var&gt;)&lt;/code&gt; 및 &lt;code&gt;(sxhash-eq &lt;var&gt;obj2&lt;/var&gt;)&lt;/code&gt; 는 동일한 정수입니다.</target>
        </trans-unit>
        <trans-unit id="44ade2ddab356cb60d73286f7dd807880759d4c2" translate="yes" xml:space="preserve">
          <source>If two objects &lt;var&gt;obj1&lt;/var&gt; and &lt;var&gt;obj2&lt;/var&gt; are &lt;code&gt;eql&lt;/code&gt;, then &lt;code&gt;(sxhash-eql &lt;var&gt;obj1&lt;/var&gt;)&lt;/code&gt; and &lt;code&gt;(sxhash-eql &lt;var&gt;obj2&lt;/var&gt;)&lt;/code&gt; are the same integer.</source>
          <target state="translated">두 객체 &lt;var&gt;obj1&lt;/var&gt; 및 &lt;var&gt;obj2&lt;/var&gt; 가 &lt;code&gt;eql&lt;/code&gt; 이면 &lt;code&gt;(sxhash-eql &lt;var&gt;obj1&lt;/var&gt;)&lt;/code&gt; 및 &lt;code&gt;(sxhash-eql &lt;var&gt;obj2&lt;/var&gt;)&lt;/code&gt; 는 동일한 정수입니다.</target>
        </trans-unit>
        <trans-unit id="faa2ecf2925aadfa7df8d5d6017d1a43d6a4fbf6" translate="yes" xml:space="preserve">
          <source>If two objects &lt;var&gt;obj1&lt;/var&gt; and &lt;var&gt;obj2&lt;/var&gt; are &lt;code&gt;equal&lt;/code&gt;, then &lt;code&gt;(sxhash-equal &lt;var&gt;obj1&lt;/var&gt;)&lt;/code&gt; and &lt;code&gt;(sxhash-equal &lt;var&gt;obj2&lt;/var&gt;)&lt;/code&gt; are the same integer.</source>
          <target state="translated">두 물체 경우 &lt;var&gt;obj1&lt;/var&gt; 과 &lt;var&gt;obj2&lt;/var&gt; 보다가 있는 &lt;code&gt;equal&lt;/code&gt; 하고 &lt;code&gt;(sxhash-equal &lt;var&gt;obj1&lt;/var&gt;)&lt;/code&gt; 와 &lt;code&gt;(sxhash-equal &lt;var&gt;obj2&lt;/var&gt;)&lt;/code&gt; 와 동일한 정수이다.</target>
        </trans-unit>
        <trans-unit id="c4a957c6ab4394732423e757c73b91fce71b8325" translate="yes" xml:space="preserve">
          <source>If user input represents an octal number, this function returns that number. If it is a complete symbolic specification of mode bits, as in &lt;code&gt;&quot;u=rwx&quot;&lt;/code&gt;, the function converts it to the equivalent numeric value using &lt;code&gt;file-modes-symbolic-to-number&lt;/code&gt; and returns the result. If the specification is relative, as in &lt;code&gt;&quot;o+g&quot;&lt;/code&gt;, then the permissions on which the specification is based are taken from the mode bits of &lt;var&gt;base-file&lt;/var&gt;. If &lt;var&gt;base-file&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt;, the function uses &lt;code&gt;0&lt;/code&gt; as the base mode bits. The complete and relative specifications can be combined, as in &lt;code&gt;&quot;u+r,g+rx,o+r,g-w&quot;&lt;/code&gt;. See &lt;a href=&quot;http://www.gnu.org/software/coreutils/manual/html_node/File-permissions.html#File-permissions&quot;&gt;File permissions&lt;/a&gt; in</source>
          <target state="translated">사용자 입력이 8 진수를 나타내는 경우이 함수는 해당 숫자를 반환합니다. &lt;code&gt;&quot;u=rwx&quot;&lt;/code&gt; 에서와 같이 모드 비트의 완전한 기호 지정 인 경우 함수는 &lt;code&gt;file-modes-symbolic-to-number&lt;/code&gt; 를 숫자로 사용하여 해당 값을 동등한 숫자 값으로 변환 하고 결과를 반환합니다. 사양이 &lt;code&gt;&quot;o+g&quot;&lt;/code&gt; 와 같이 상대적인 경우 사양의 기반이되는 권한은 &lt;var&gt;base-file&lt;/var&gt; 의 모드 비트에서 가져옵니다 . 경우 &lt;var&gt;base-file&lt;/var&gt; 생략되거나 &lt;code&gt;nil&lt;/code&gt; 함수가 사용 &lt;code&gt;0&lt;/code&gt; 베이스 모드 비트로. &lt;code&gt;&quot;u+r,g+rx,o+r,g-w&quot;&lt;/code&gt; 에서와 같이 완전하고 상대적인 사양을 결합 할 수 있습니다 . &lt;a href=&quot;http://www.gnu.org/software/coreutils/manual/html_node/File-permissions.html#File-permissions&quot;&gt;파일 권한&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ab20dbc7190aa4c17064de5aae79eae25a6f3ca2" translate="yes" xml:space="preserve">
          <source>If we know that the &lt;code&gt;&quot;else&quot;&lt;/code&gt; is always aligned with its &lt;code&gt;&quot;if&quot;&lt;/code&gt; and is always at the beginning of a line, we can use a more efficient rule:</source>
          <target state="translated">&lt;code&gt;&quot;else&quot;&lt;/code&gt; 가 항상 &lt;code&gt;&quot;if&quot;&lt;/code&gt; 와 정렬되고 항상 줄의 시작 부분에 있다는 것을 알고 있다면 더 효율적인 규칙을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b94e278e89af3d9639830ebb8509d74bc9218c33" translate="yes" xml:space="preserve">
          <source>If you add a new primitive to a file that already has Lisp primitives defined in it, find the function (near the end of the file) named &lt;code&gt;syms_of_&lt;var&gt;something&lt;/var&gt;&lt;/code&gt;, and add the call to &lt;code&gt;defsubr&lt;/code&gt; there. If the file doesn&amp;rsquo;t have this function, or if you create a new file, add to it a &lt;code&gt;syms_of_&lt;var&gt;filename&lt;/var&gt;&lt;/code&gt; (e.g., &lt;code&gt;syms_of_myfile&lt;/code&gt;). Then find the spot in</source>
          <target state="translated">이미 Lisp 프리미티브가 정의 된 파일에 새 프리미티브를 추가하는 경우 &lt;code&gt;syms_of_&lt;var&gt;something&lt;/var&gt;&lt;/code&gt; 이라는 함수 (파일 끝 근처) 를 &lt;code&gt;defsubr&lt;/code&gt; 거기 에 defsubr 호출을 추가하십시오 . 파일에이 기능이 없거나 새 파일을 만드는 경우 &lt;code&gt;syms_of_&lt;var&gt;filename&lt;/var&gt;&lt;/code&gt; (예 : &lt;code&gt;syms_of_myfile&lt;/code&gt; )을 추가합니다. 그런 다음 장소를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="8e51eed80e79b2bcea4605ee7ff46c46550e45f1" translate="yes" xml:space="preserve">
          <source>If you alter the compiled file (such as by compiling a new version), then trying to load any function not already loaded will usually yield nonsense results.</source>
          <target state="translated">컴파일 된 파일을 변경하는 경우 (예 : 새 버전 컴파일), 아직로드되지 않은 함수를로드하려고하면 일반적으로 말도 안되는 결과가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="0eb0fd19eca276d41267eb825a3b2aa624892e92" translate="yes" xml:space="preserve">
          <source>If you are careful not to exceed the ring size, you can use the ring as a first-in-first-out queue. For example:</source>
          <target state="translated">링 크기를 초과하지 않도록주의하면 링을 선입 선출 대기열로 사용할 수 있습니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="fc8d2ca20908496286a727bd09248d8bc43a541e" translate="yes" xml:space="preserve">
          <source>If you are running across a network, and different parts of the network work at different baud rates, the value returned by Emacs may be different from the value used by your local terminal. Some network protocols communicate the local terminal speed to the remote machine, so that Emacs and other programs can get the proper value, but others do not. If Emacs has the wrong value, it makes decisions that are less than optimal. To fix the problem, set &lt;code&gt;baud-rate&lt;/code&gt;.</source>
          <target state="translated">네트워크를 통해 실행 중이고 네트워크의 다른 부분이 다른 전송 속도로 작동하는 경우 Emacs에서 반환하는 값은 로컬 터미널에서 사용하는 값과 다를 수 있습니다. 일부 네트워크 프로토콜은 로컬 터미널 속도를 원격 시스템에 전달하여 Emacs 및 기타 프로그램이 적절한 값을 얻을 수 있지만 다른 프로토콜은 그렇지 않습니다. Emacs의 가치가 잘못된 경우 최적이 아닌 결정을 내립니다. 문제를 해결하려면 &lt;code&gt;baud-rate&lt;/code&gt; 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="0072664fa49d446301646082567e540da686bac7" translate="yes" xml:space="preserve">
          <source>If you are sure that a warning message about a missing function or variable is unjustified, there are several ways to suppress it:</source>
          <target state="translated">누락 된 함수 또는 변수에 대한 경고 메시지가 정당하지 않다고 확신하는 경우이를 억제하는 몇 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f22a0f306b8db09319cdd2bfdcd0eed8dd5fd3d7" translate="yes" xml:space="preserve">
          <source>If you are using a macro to do something an ordinary function could do, just for the sake of speed, consider using an inline function instead. See &lt;a href=&quot;inline-functions#Inline-Functions&quot;&gt;Inline Functions&lt;/a&gt;.</source>
          <target state="translated">매크로를 사용하여 일반 함수가 수행 할 수있는 작업을 수행하는 경우 속도를 위해 대신 인라인 함수를 사용하는 것이 좋습니다. &lt;a href=&quot;inline-functions#Inline-Functions&quot;&gt;인라인 함수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d39bc44a789b7cd31c5d8a478076105fab4e1cea" translate="yes" xml:space="preserve">
          <source>If you are using a mode whose indentation is provided by SMIE, you can customize the indentation to suit your preferences. You can do this on a per-mode basis (using the option &lt;code&gt;smie-config&lt;/code&gt;), or a per-file basis (using the function &lt;code&gt;smie-config-local&lt;/code&gt; in a file-local variable specification).</source>
          <target state="translated">SMIE에서 들여 쓰기를 제공하는 모드를 사용하는 경우 선호도에 맞게 들여 쓰기를 사용자 정의 할 수 있습니다. 모드별로 ( &lt;code&gt;smie-config&lt;/code&gt; 옵션 사용 ) 또는 파일별로 ( 파일 로컬 변수 사양에서 &lt;code&gt;smie-config-local&lt;/code&gt; 함수 사용 )이를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af4a68bcde30998a536e42773304bc15d422df91" translate="yes" xml:space="preserve">
          <source>If you are writing code for release, for others to use, try to avoid including advice in it. If the function you want to advise has no hook to do the job, please talk with the Emacs developers about adding a suitable hook. Especially, Emacs&amp;rsquo;s own source files should not put advice on functions in Emacs. (There are currently a few exceptions to this convention, but we aim to correct them.) It is generally cleaner to create a new hook in &lt;code&gt;foo&lt;/code&gt;, and make &lt;code&gt;bar&lt;/code&gt; use the hook, than to have &lt;code&gt;bar&lt;/code&gt; put advice in &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">다른 사람들이 사용할 수 있도록 릴리스 용 코드를 작성하는 경우 조언을 포함하지 않도록하십시오. 조언하고자하는 함수에 작업을 수행 할 후크가없는 경우 적절한 후크 추가에 대해 Emacs 개발자와상의하십시오. 특히 Emacs의 자체 소스 파일은 Emacs의 기능에 대한 조언을 제공해서는 안됩니다. (이 현재이 협약의 몇 가지 예외가 있지만, 우리는이를 수정하는 것을 목표로하고 있습니다.) 그것은 새로운 후크 만드는 데 일반적으로 깨끗 &lt;code&gt;foo&lt;/code&gt; 는 , 그리고 메이크업의 &lt;code&gt;bar&lt;/code&gt; 있는 것보다, 후크를 사용하는 &lt;code&gt;bar&lt;/code&gt; 에 넣어 조언을 &lt;code&gt;foo&lt;/code&gt; 는 .</target>
        </trans-unit>
        <trans-unit id="bda02007617357daadbad5daa64711e089b1fa98" translate="yes" xml:space="preserve">
          <source>If you call &lt;code&gt;set-face-attribute&lt;/code&gt; and pass a font spec, font entity, or font name string as the value of the &lt;code&gt;:font&lt;/code&gt; attribute, Emacs opens the best matching font that is available for display. It then stores the corresponding font object as the actual value of the &lt;code&gt;:font&lt;/code&gt; attribute for that face.</source>
          <target state="translated">&lt;code&gt;set-face-attribute&lt;/code&gt; 를 호출 하고 글꼴 사양, 글꼴 엔티티 또는 글꼴 이름 문자열을 &lt;code&gt;:font&lt;/code&gt; 속성 의 값으로 전달하면 Emacs는 표시 할 수있는 가장 일치하는 글꼴을 엽니 다. 그런 다음 해당 글꼴 개체 를 해당 얼굴에 대한 &lt;code&gt;:font&lt;/code&gt; 속성 의 실제 값으로 저장합니다 .</target>
        </trans-unit>
        <trans-unit id="69c55f2e5f8ed1abaffbeb201babe6c0b3098a84" translate="yes" xml:space="preserve">
          <source>If you call &lt;code&gt;sort-regexp-fields&lt;/code&gt; interactively, it prompts for &lt;var&gt;record-regexp&lt;/var&gt; and &lt;var&gt;key-regexp&lt;/var&gt; in the minibuffer.</source>
          <target state="translated">&lt;code&gt;sort-regexp-fields&lt;/code&gt; 를 대화식으로 호출 하면 minibuffer 에 &lt;var&gt;record-regexp&lt;/var&gt; 및 &lt;var&gt;key-regexp&lt;/var&gt; 를 입력 하라는 메시지가 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="19b20fbcaed19267c0ae5233685511404c8fe13b" translate="yes" xml:space="preserve">
          <source>If you can read &lt;var&gt;filename&lt;/var&gt; this function returns &lt;code&gt;nil&lt;/code&gt;; otherwise it signals an error using &lt;var&gt;string&lt;/var&gt; as the error message text.</source>
          <target state="translated">&lt;var&gt;filename&lt;/var&gt; 을 읽을 수 있으면 이 함수는 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 . 그렇지 않으면 &lt;var&gt;string&lt;/var&gt; 을 오류 메시지 텍스트로 사용하여 오류를 알립니다 .</target>
        </trans-unit>
        <trans-unit id="ec646b6002abc5e60335d6f3ab6e9548f2ac3d2c" translate="yes" xml:space="preserve">
          <source>If you change &lt;code&gt;debug-on-error&lt;/code&gt; or &lt;code&gt;debug-on-quit&lt;/code&gt; while Edebug is active, these changes will be forgotten when Edebug becomes inactive. Furthermore, during Edebug&amp;rsquo;s recursive edit, these variables are bound to the values they had outside of Edebug.</source>
          <target state="translated">당신이 변경하면 &lt;code&gt;debug-on-error&lt;/code&gt; 또는 &lt;code&gt;debug-on-quit&lt;/code&gt; Edebug이 활성화되어있는 동안 Edebug가 비활성화 될 때 이러한 변경 잊혀 질 것이다. 또한 Edebug의 재귀 편집 중에 이러한 변수는 Edebug 외부에있는 값에 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="82e1d7f6837d7e1fd79a005ee98861790c6bed8a" translate="yes" xml:space="preserve">
          <source>If you change &lt;code&gt;debug-on-signal&lt;/code&gt; to a non-&lt;code&gt;nil&lt;/code&gt; value, the debugger gets the first chance at every error, regardless of the presence of &lt;code&gt;condition-case&lt;/code&gt;. (To invoke the debugger, the error must still fulfill the criteria specified by &lt;code&gt;debug-on-error&lt;/code&gt; and &lt;code&gt;debug-ignored-errors&lt;/code&gt;.)</source>
          <target state="translated">당신이 변경하면 &lt;code&gt;debug-on-signal&lt;/code&gt; 비에 &lt;code&gt;nil&lt;/code&gt; 값, 디버거에 관계없이 존재의 모든 오류에 첫 번째 기회를 얻을 &lt;code&gt;condition-case&lt;/code&gt; . (디버거를 호출하려면 오류가 &lt;code&gt;debug-on-error&lt;/code&gt; 및 &lt;code&gt;debug-ignored-errors&lt;/code&gt; 에 지정된 기준을 충족해야 합니다 .)</target>
        </trans-unit>
        <trans-unit id="a032c6d2c26bc9a17573480803a0fc6e92740213" translate="yes" xml:space="preserve">
          <source>If you change the bindings in &lt;var&gt;parent-keymap&lt;/var&gt; using &lt;code&gt;define-key&lt;/code&gt; or other key-binding functions, these changed bindings are visible in the inheriting keymap, unless shadowed by the bindings made by &lt;var&gt;elements&lt;/var&gt;. The converse is not true: if you use &lt;code&gt;define-key&lt;/code&gt; to change bindings in the inheriting keymap, these changes are recorded in &lt;var&gt;elements&lt;/var&gt;, but have no effect on &lt;var&gt;parent-keymap&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;define-key&lt;/code&gt; 또는 기타 키 바인딩 함수를 사용하여 &lt;var&gt;parent-keymap&lt;/var&gt; 의 바인딩을 변경하는 경우 이러한 변경된 바인딩은 &lt;var&gt;elements&lt;/var&gt; 로 만든 바인딩에 의해 가려지지 않는 한 상속하는 키맵에 표시됩니다 . 그 반대는 사실이 아닙니다. 상속하는 키맵의 바인딩을 변경하기 위해 &lt;code&gt;define-key&lt;/code&gt; 를 사용하면 이러한 변경 사항이 &lt;var&gt;elements&lt;/var&gt; 에 기록 되지만 &lt;var&gt;parent-keymap&lt;/var&gt; 에는 영향을주지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9cb1eba86e3ba5c0e1663be951356c7fd19739f3" translate="yes" xml:space="preserve">
          <source>If you change the values of &lt;code&gt;edebug-on-error&lt;/code&gt; or &lt;code&gt;edebug-on-quit&lt;/code&gt; while Edebug is active, their values won&amp;rsquo;t be used until the &lt;em&gt;next&lt;/em&gt; time Edebug is invoked via a new command.</source>
          <target state="translated">Edebug가 활성 상태 인 동안 &lt;code&gt;edebug-on-error&lt;/code&gt; 또는 &lt;code&gt;edebug-on-quit&lt;/code&gt; 의 값을 변경하면 &lt;em&gt;다음&lt;/em&gt; 번에 새 명령을 통해 Edebug를 호출 할 때까지 해당 값이 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b5ecdaab829d09620b381ec99a472542b3bed464" translate="yes" xml:space="preserve">
          <source>If you click a button three or more times and then press it again, the events for the presses beyond the third are all triple events. Emacs does not have separate event types for quadruple, quintuple, etc. events. However, you can look at the event list to find out precisely how many times the button was pressed.</source>
          <target state="translated">버튼을 세 번 이상 클릭 한 후 다시 누르면 세 번째 이후의 프레스 이벤트는 모두 트리플 이벤트입니다. Emacs에는 4 중, 5 중 등의 이벤트에 대해 별도의 이벤트 유형이 없습니다. 그러나 이벤트 목록을 보면 버튼을 얼마나 많이 눌렀는지 정확하게 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97f76d136a54a91f5ce09fa28d033744e2b18618" translate="yes" xml:space="preserve">
          <source>If you click a button twice and then press it again, all in quick succession, Emacs generates a &lt;em&gt;triple-down&lt;/em&gt; event, followed by either a &lt;em&gt;triple-click&lt;/em&gt; or a &lt;em&gt;triple-drag&lt;/em&gt;. The event types of these events contain &amp;lsquo;</source>
          <target state="translated">버튼을 두 번 클릭 한 다음 다시 누르면 빠르게 연속해서 Emacs는 &lt;em&gt;트리플 다운&lt;/em&gt; 이벤트를 생성 한 다음 &lt;em&gt;세 번 클릭&lt;/em&gt; 하거나 &lt;em&gt;세 번 드래그&lt;/em&gt; 합니다. 이러한 이벤트의 이벤트 유형에는 '</target>
        </trans-unit>
        <trans-unit id="babf73f5ef063cd1ca16de5c46e1c4b38d2d236a" translate="yes" xml:space="preserve">
          <source>If you click a button, then press it down again and start moving the mouse with the button held down, then you get a &lt;em&gt;double-drag&lt;/em&gt; event when you ultimately release the button. Its event type contains &amp;lsquo;</source>
          <target state="translated">버튼을 클릭 한 다음 다시 누르고 버튼을 누른 상태에서 마우스를 움직이기 시작 하면 궁극적으로 버튼을 놓을 때 &lt;em&gt;더블 드래그&lt;/em&gt; 이벤트가 발생합니다. 이벤트 유형에는 '</target>
        </trans-unit>
        <trans-unit id="c5fb3a0c87cdbd7c9d430fccee88612b713587b6" translate="yes" xml:space="preserve">
          <source>If you compile the above code, the anonymous function is also compiled. This would not happen if, say, you had constructed the anonymous function by quoting it as a list:</source>
          <target state="translated">위의 코드를 컴파일하면 익명 함수도 컴파일됩니다. 예를 들어 익명 함수를 목록으로 인용하여 생성 한 경우에는 이런 일이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3585ff0dc0e69eb3875d3c21881701fbf12049b6" translate="yes" xml:space="preserve">
          <source>If you define a function which is side-effect free or pure, give it a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;side-effect-free&lt;/code&gt; or &lt;code&gt;pure&lt;/code&gt; property, respectively (see &lt;a href=&quot;standard-properties#Standard-Properties&quot;&gt;Standard Properties&lt;/a&gt;).</source>
          <target state="translated">부작용이 없거나 순수한 함수를 정의하는 경우 에는 각각 &lt;code&gt;nil&lt;/code&gt; 이 아닌 &lt;code&gt;side-effect-free&lt;/code&gt; 속성 또는 &lt;code&gt;pure&lt;/code&gt; 속성을 지정하십시오 ( &lt;a href=&quot;standard-properties#Standard-Properties&quot;&gt;표준 속성&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="9d356c50a344f26b7b7e0c2e2a88f2a9d47c5035" translate="yes" xml:space="preserve">
          <source>If you delete or move the compiled file after loading it, Emacs can no longer load the remaining function definitions not already loaded.</source>
          <target state="translated">컴파일 된 파일을로드 한 후 삭제하거나 이동하면 Emacs는 더 이상로드되지 않은 나머지 함수 정의를로드 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="832ed8c18f70d41abab32f7213d1a98c3b93e0e3" translate="yes" xml:space="preserve">
          <source>If you did the last search in a buffer, you should omit the &lt;var&gt;string&lt;/var&gt; argument or specify &lt;code&gt;nil&lt;/code&gt; for it, and make sure that the current buffer is the one in which you performed the last search. Then this function edits the buffer, replacing the matched text with &lt;var&gt;replacement&lt;/var&gt;. It leaves point at the end of the replacement text.</source>
          <target state="translated">버퍼에서 마지막 검색을 수행 한 경우 &lt;var&gt;string&lt;/var&gt; 인수를 생략 하거나 &lt;code&gt;nil&lt;/code&gt; 을 지정 하고 현재 버퍼가 마지막 검색을 수행 한 버퍼인지 확인해야합니다. 그런 다음이 함수는 버퍼를 편집하여 일치하는 텍스트를 &lt;var&gt;replacement&lt;/var&gt; 로 바꿉니다 . 대체 텍스트의 끝에 점을 남깁니다.</target>
        </trans-unit>
        <trans-unit id="5752e1504ebf2064bf0d5937ac79557053162460" translate="yes" xml:space="preserve">
          <source>If you directly define a file-scope C variable of type &lt;code&gt;Lisp_Object&lt;/code&gt;, you must protect it from garbage-collection by calling &lt;code&gt;staticpro&lt;/code&gt; in &lt;code&gt;syms_of_&lt;var&gt;filename&lt;/var&gt;&lt;/code&gt;, like this:</source>
          <target state="translated">직접 형식의 파일 범위 C 변수를 정의하는 경우 &lt;code&gt;Lisp_Object&lt;/code&gt; 을 , 당신은 호출하여 가비지 컬렉션을 보호해야 &lt;code&gt;staticpro&lt;/code&gt; 에서 &lt;code&gt;syms_of_&lt;var&gt;filename&lt;/var&gt;&lt;/code&gt; 과 같이 :</target>
        </trans-unit>
        <trans-unit id="a799552f0c440dd51dc850366b3de6e02e55511d" translate="yes" xml:space="preserve">
          <source>If you divide an integer by the integer 0, Emacs signals an &lt;code&gt;arith-error&lt;/code&gt; error (see &lt;a href=&quot;errors#Errors&quot;&gt;Errors&lt;/a&gt;). Floating-point division of a nonzero number by zero yields either positive or negative infinity (see &lt;a href=&quot;float-basics#Float-Basics&quot;&gt;Float Basics&lt;/a&gt;).</source>
          <target state="translated">정수를 정수 0으로 나누면 Emacs는 &lt;code&gt;arith-error&lt;/code&gt; 오류를 표시합니다 ( &lt;a href=&quot;errors#Errors&quot;&gt;오류&lt;/a&gt; 참조 ). 0이 아닌 숫자를 0으로 부동 소수점으로 나누면 양수 또는 음의 무한대가 생성됩니다 ( &lt;a href=&quot;float-basics#Float-Basics&quot;&gt;Float 기본 사항&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="c48948f392e624e52dbc1aa826b6d5945fcc5647" translate="yes" xml:space="preserve">
          <source>If you do alter &lt;code&gt;mode-line-format&lt;/code&gt; itself, the new value should use the same variables that appear in the default value (see &lt;a href=&quot;mode-line-variables#Mode-Line-Variables&quot;&gt;Mode Line Variables&lt;/a&gt;), rather than duplicating their contents or displaying the information in another fashion. This way, customizations made by the user or by Lisp programs (such as &lt;code&gt;display-time&lt;/code&gt; and major modes) via changes to those variables remain effective.</source>
          <target state="translated">&lt;code&gt;mode-line-format&lt;/code&gt; 자체를 변경하는 경우 새 값은 내용을 복제하거나 다른 방식으로 정보를 표시하는 대신 기본값에 나타나는 동일한 변수를 사용해야합니다 ( &lt;a href=&quot;mode-line-variables#Mode-Line-Variables&quot;&gt;Mode Line 변수&lt;/a&gt; 참조 ). 이러한 방식으로 사용자 또는 Lisp 프로그램 (예 : &lt;code&gt;display-time&lt;/code&gt; 및 주요 모드)이 해당 변수 변경을 통해 만든 사용자 정의는 여전히 유효합니다.</target>
        </trans-unit>
        <trans-unit id="919e7db85c8f5ee11bd70bb4cc9d84095b916140" translate="yes" xml:space="preserve">
          <source>If you do not specify a window&amp;rsquo;s scroll bar settings via &lt;code&gt;set-window-scroll-bars&lt;/code&gt;, the buffer-local variables &lt;code&gt;vertical-scroll-bar&lt;/code&gt;, &lt;code&gt;horizontal-scroll-bar&lt;/code&gt;, &lt;code&gt;scroll-bar-width&lt;/code&gt; and &lt;code&gt;scroll-bar-height&lt;/code&gt; in the buffer being displayed control the window&amp;rsquo;s scroll bars. The function &lt;code&gt;set-window-buffer&lt;/code&gt; examines these variables. If you change them in a buffer that is already visible in a window, you can make the window take note of the new values by calling &lt;code&gt;set-window-buffer&lt;/code&gt; specifying the same buffer that is already displayed.</source>
          <target state="translated">당신이를 통해 윈도우의 스크롤 막대 설정을 지정하지 않는 경우 &lt;code&gt;set-window-scroll-bars&lt;/code&gt; , 버퍼 로컬 변수는 &lt;code&gt;vertical-scroll-bar&lt;/code&gt; , &lt;code&gt;horizontal-scroll-bar&lt;/code&gt; , &lt;code&gt;scroll-bar-width&lt;/code&gt; 과 &lt;code&gt;scroll-bar-height&lt;/code&gt; 버퍼에 표시되는 것은 창의 스크롤 막대를 제어합니다. &lt;code&gt;set-window-buffer&lt;/code&gt; 함수는 이러한 변수를 검사합니다. 창에 이미 보이는 버퍼에서 변경하면 이미 표시된 것과 동일한 버퍼를 지정하여 &lt;code&gt;set-window-buffer&lt;/code&gt; 를 호출하여 창에서 새 값을 기록하도록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7d5478635f2aa0a1b8f06759d112fc9a81bb9ae9" translate="yes" xml:space="preserve">
          <source>If you do not want a Lisp file to be compiled, ever, put a file-local variable binding for &lt;code&gt;no-byte-compile&lt;/code&gt; into it, like this:</source>
          <target state="translated">Lisp 파일을 컴파일하지 않으려면 다음 과 같이 &lt;code&gt;no-byte-compile&lt;/code&gt; 파일 로컬 변수 바인딩을 여기에 넣으 십시오.</target>
        </trans-unit>
        <trans-unit id="bd9289930e0af37b6580f5f7e82b4908b4ac925e" translate="yes" xml:space="preserve">
          <source>If you do not want a particular command to be recognized as the previous command in the case where it got an error, you must code that command to prevent this. One way is to set &lt;code&gt;this-command&lt;/code&gt; to &lt;code&gt;t&lt;/code&gt; at the beginning of the command, and set &lt;code&gt;this-command&lt;/code&gt; back to its proper value at the end, like this:</source>
          <target state="translated">오류가 발생한 경우 특정 명령이 이전 명령으로 인식되지 않도록하려면 해당 명령을 코딩하여이를 방지해야합니다. 한 가지 방법은 &lt;code&gt;this-command&lt;/code&gt; 의 시작 부분에서 this-command 를 &lt;code&gt;t&lt;/code&gt; 로 설정 하고 끝에서 &lt;code&gt;this-command&lt;/code&gt; 를 적절한 값으로 다시 설정 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5611162597f8b6ec87950a669e8a5984dfaa42e0" translate="yes" xml:space="preserve">
          <source>If you do not want this feature, set the variable &lt;code&gt;case-fold-search&lt;/code&gt; to &lt;code&gt;nil&lt;/code&gt;. Then all letters must match exactly, including case. This is a buffer-local variable; altering the variable affects only the current buffer. (See &lt;a href=&quot;intro-to-buffer_002dlocal#Intro-to-Buffer_002dLocal&quot;&gt;Intro to Buffer-Local&lt;/a&gt;.) Alternatively, you may change the default value. In Lisp code, you will more typically use &lt;code&gt;let&lt;/code&gt; to bind &lt;code&gt;case-fold-search&lt;/code&gt; to the desired value.</source>
          <target state="translated">이 기능을 원하지 않으면 &lt;code&gt;case-fold-search&lt;/code&gt; 변수 를 &lt;code&gt;nil&lt;/code&gt; 로 설정하십시오 . 그런 다음 모든 문자는 대소 문자를 포함하여 정확히 일치해야합니다. 이것은 버퍼 로컬 변수입니다. 변수를 변경하면 현재 버퍼에만 영향을줍니다. ( &lt;a href=&quot;intro-to-buffer_002dlocal#Intro-to-Buffer_002dLocal&quot;&gt;버퍼 로컬 소개를&lt;/a&gt; 참조하십시오 .) 또는 기본값을 변경할 수 있습니다. Lisp 코드에서는 일반적으로 &lt;code&gt;let&lt;/code&gt; 을 사용 하여 &lt;code&gt;case-fold-search&lt;/code&gt; 를 원하는 값 에 바인딩 합니다.</target>
        </trans-unit>
        <trans-unit id="f866fd286c45411a67dbb50a84fea3f20ae8d82b" translate="yes" xml:space="preserve">
          <source>If you do set the same variable again, the new value replaces the old one:</source>
          <target state="translated">동일한 변수를 다시 설정하면 새 값이 이전 값을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="3402ff5b14ba5a8ea18eb9cb2a7a34434be535f3" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t know exactly where in the source code you want to put the debug statement, but you want to display a backtrace when a certain message is displayed, you can set &lt;code&gt;debug-on-message&lt;/code&gt; to a regular expression matching the desired message.</source>
          <target state="translated">소스 코드에서 디버그 문을 삽입하려는 위치를 정확히 모르지만 특정 메시지가 표시 될 때 역 추적을 표시하려면 &lt;code&gt;debug-on-message&lt;/code&gt; 에 대한 디버그를 원하는 메시지와 일치하는 정규 표현식으로 설정할 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="1411d7398cdf316f7a761acc6232531b6f93aa6f" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t see a problem at that point, the next thing to do is to type</source>
          <target state="translated">그 시점에서 문제가 보이지 않으면 다음으로 할 일은 다음을 입력하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c777867a4fcf3b6790ba4a3f6676ab8e8eb5e7ea" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t specify &lt;var&gt;help&lt;/var&gt;, the default is &lt;code&gt;(&quot;object&quot;
&quot;objects&quot; &quot;act on&quot;)&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;help&lt;/var&gt; 를 지정하지 않으면 기본값은 &lt;code&gt;(&quot;object&quot; &quot;objects&quot; &quot;act on&quot;)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="73fcecbc1356991b98581a800856e4e2763a1b17" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t specify &lt;var&gt;history&lt;/var&gt;, then the default history list &lt;code&gt;minibuffer-history&lt;/code&gt; is used. For other standard history lists, see below. You can also create your own history list variable; just initialize it to &lt;code&gt;nil&lt;/code&gt; before the first use. If the variable is buffer local, then each buffer will have its own input history list.</source>
          <target state="translated">&lt;var&gt;history&lt;/var&gt; 를 지정하지 않으면 기본 내역 목록 &lt;code&gt;minibuffer-history&lt;/code&gt; 가 사용됩니다. 다른 표준 내역 목록은 아래를 참조하십시오. 자신 만의 히스토리 목록 변수를 만들 수도 있습니다. 처음 사용하기 전에 &lt;code&gt;nil&lt;/code&gt; 로 초기화하십시오 . 변수가 버퍼 로컬 인 경우 각 버퍼에는 자체 입력 내역 목록이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b45979ffc14a7465f0296ae53f5338e35b87473" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t specify the &lt;code&gt;line-height&lt;/code&gt; property, the line&amp;rsquo;s height consists of the contents&amp;rsquo; height plus the line spacing. There are several ways to specify the line spacing for different parts of Emacs text.</source>
          <target state="translated">&lt;code&gt;line-height&lt;/code&gt; 속성을 지정하지 않으면 줄의 높이는 내용의 높이와 줄 간격으로 구성됩니다. Emacs 텍스트의 다른 부분에 대한 줄 간격을 지정하는 방법에는 여러 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6743c06f00234ad9062a2a3a2ea7fc17e673ef8" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t specify this keyword at all, the default is to determine the coding systems from the data.</source>
          <target state="translated">이 키워드를 전혀 지정하지 않으면 기본값은 데이터에서 코딩 시스템을 결정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="04bef473929ac543401da8285cfb9a7eb0c1717c" translate="yes" xml:space="preserve">
          <source>If you get a warning that</source>
          <target state="translated">경고를 받으면</target>
        </trans-unit>
        <trans-unit id="e767fb6147ef9fb326b46a3482c4c2ceedb2b93a" translate="yes" xml:space="preserve">
          <source>If you have a constant that needs some calculation to produce, &lt;code&gt;eval-when-compile&lt;/code&gt; can do that at compile-time. For example,</source>
          <target state="translated">생성하기 위해 계산이 필요한 상수가있는 경우 &lt;code&gt;eval-when-compile&lt;/code&gt; 은 컴파일 타임에이를 수행 할 수 있습니다. 예를 들면</target>
        </trans-unit>
        <trans-unit id="3f37032d6c165b2681c4b1c8b2c526ae79d7f709" translate="yes" xml:space="preserve">
          <source>If you have a frame that displays only one window, you can fit that frame to its buffer using the command &lt;code&gt;fit-frame-to-buffer&lt;/code&gt;.</source>
          <target state="translated">하나의 창만 표시하는 프레임이있는 경우 &lt;code&gt;fit-frame-to-buffer&lt;/code&gt; 명령을 사용하여 해당 프레임을 버퍼에 맞출 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="33faad871265de71a9510766889514f64259bfd3" translate="yes" xml:space="preserve">
          <source>If you have made extensive changes to a file and then change your mind about them, you can get rid of them by reading in the previous version of the file with the &lt;code&gt;revert-buffer&lt;/code&gt; command. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Reverting.html#Reverting&quot;&gt;Reverting a Buffer&lt;/a&gt; in</source>
          <target state="translated">파일을 광범위하게 변경 한 다음 마음이 바뀐 경우 &lt;code&gt;revert-buffer&lt;/code&gt; 명령 을 사용하여 파일의 이전 버전을 읽어서 제거 할 수 있습니다 . &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Reverting.html#Reverting&quot;&gt;버퍼 되돌리기를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3114430b909452db4a0ad15c4686bf655a82d1b5" translate="yes" xml:space="preserve">
          <source>If you have never given a symbol any function definition, we say that that symbol&amp;rsquo;s function cell is &lt;em&gt;void&lt;/em&gt;. In other words, the function cell does not have any Lisp object in it. If you try to call the symbol as a function, Emacs signals a &lt;code&gt;void-function&lt;/code&gt; error.</source>
          <target state="translated">기호에 함수 정의를 지정하지 않은 경우 해당 기호의 함수 셀은 &lt;em&gt;void&lt;/em&gt; 입니다. 즉, 함수 셀에는 Lisp 개체가 없습니다. 기호를 함수로 호출하려고하면 Emacs는 &lt;code&gt;void-function&lt;/code&gt; 오류를 알립니다 .</target>
        </trans-unit>
        <trans-unit id="1adb1c551e5096149203b778dae4aca140133316" translate="yes" xml:space="preserve">
          <source>If you have passed a non-&lt;code&gt;nil&lt;/code&gt;&lt;var&gt;stderr&lt;/var&gt; to &lt;code&gt;make-process&lt;/code&gt;, it will have a standard error process. See &lt;a href=&quot;asynchronous-processes#Asynchronous-Processes&quot;&gt;Asynchronous Processes&lt;/a&gt;. In that case, waiting for process output from the main process doesn&amp;rsquo;t wait for output from the standard error process. To make sure you have received both all of standard output and all of standard error from a process, use the following code:</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; 이 아닌 &lt;var&gt;stderr&lt;/var&gt; 를 &lt;code&gt;make-process&lt;/code&gt; 에 전달 하면 표준 오류 프로세스가 발생합니다. &lt;a href=&quot;asynchronous-processes#Asynchronous-Processes&quot;&gt;비동기 프로세스를&lt;/a&gt; 참조하십시오 . 이 경우 메인 프로세스의 프로세스 출력을 기다리는 것은 표준 오류 프로세스의 출력을 기다리지 않습니다. 프로세스에서 모든 표준 출력과 모든 표준 오류를 모두 수신했는지 확인하려면 다음 코드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ef54783b26bd82dc91fad381aa3579ce041cbe4e" translate="yes" xml:space="preserve">
          <source>If you instrument the &lt;code&gt;test&lt;/code&gt; macro and step through it, then by default the result of the &lt;code&gt;symbol-function&lt;/code&gt; call has numerous &lt;code&gt;edebug-after&lt;/code&gt; and &lt;code&gt;edebug-before&lt;/code&gt; forms, which can make it difficult to see the actual result. If &lt;code&gt;edebug-unwrap-results&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;, Edebug tries to remove these forms from the result.</source>
          <target state="translated">&lt;code&gt;test&lt;/code&gt; 매크로 를 계측 하고 단계별로 실행하면 기본적으로 &lt;code&gt;symbol-function&lt;/code&gt; 호출 의 결과에 수많은 &lt;code&gt;edebug-after&lt;/code&gt; 및 &lt;code&gt;edebug-before&lt;/code&gt; 형식이 있으므로 실제 결과를 확인하기 어려울 수 있습니다. 경우 &lt;code&gt;edebug-unwrap-results&lt;/code&gt; 비입니다 &lt;code&gt;nil&lt;/code&gt; , Edebug는 결과에서 이러한 양식을 제거하려고합니다.</target>
        </trans-unit>
        <trans-unit id="33abc94ec53362e4d866e3e4d48d4aa529da00b3" translate="yes" xml:space="preserve">
          <source>If you instrument the definition of &lt;code&gt;fac&lt;/code&gt; (shown below) and then execute &lt;code&gt;(fac 3)&lt;/code&gt;, here is what you would normally see. Point is at the open-parenthesis before &lt;code&gt;if&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fac&lt;/code&gt; 정의 (아래 표시) 를 계측 한 다음 실행 &lt;code&gt;(fac 3)&lt;/code&gt; 하면 일반적으로 볼 수있는 내용은 다음과 같습니다 . 포인트는 &lt;code&gt;if&lt;/code&gt; 전에 여는 괄호에 있습니다.</target>
        </trans-unit>
        <trans-unit id="30df8677ae4d4b292044bc3da5da7b6491d7a906" translate="yes" xml:space="preserve">
          <source>If you invoke Emacs with command-line options that specify frame appearance, those options take effect by adding elements to either &lt;code&gt;initial-frame-alist&lt;/code&gt; or &lt;code&gt;default-frame-alist&lt;/code&gt;. Options which affect just the initial frame, such as &amp;lsquo;</source>
          <target state="translated">프레임 모양을 지정하는 명령 줄 옵션을 사용하여 Emacs를 호출하는 경우 해당 옵션은 &lt;code&gt;initial-frame-alist&lt;/code&gt; 또는 &lt;code&gt;default-frame-alist&lt;/code&gt; 에 요소를 추가하여 적용됩니다 . '와 같이 초기 프레임에만 영향을 미치는 옵션</target>
        </trans-unit>
        <trans-unit id="4f8ed670902a9aad525f057b6320f5c8058a1c22" translate="yes" xml:space="preserve">
          <source>If you just want to automatically auto-revert every &lt;code&gt;auto-revert-interval&lt;/code&gt; seconds (like the Buffer Menu), use:</source>
          <target state="translated">버퍼 메뉴와 같이 &lt;code&gt;auto-revert-interval&lt;/code&gt; 초) 마다 자동 으로 자동 복귀 하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="71a2adf65a17fe610efe228b45e1cb903d7bc113" translate="yes" xml:space="preserve">
          <source>If you kill a buffer that is current or displayed in a window, Emacs automatically selects or displays some other buffer instead. This means that killing a buffer can change the current buffer. Therefore, when you kill a buffer, you should also take the precautions associated with changing the current buffer (unless you happen to know that the buffer being killed isn&amp;rsquo;t current). See &lt;a href=&quot;current-buffer#Current-Buffer&quot;&gt;Current Buffer&lt;/a&gt;.</source>
          <target state="translated">현재 또는 창에 표시된 버퍼를 죽이면 Emacs는 대신 다른 버퍼를 자동으로 선택하거나 표시합니다. 이것은 버퍼를 죽이면 현재 버퍼를 변경할 수 있음을 의미합니다. 따라서 버퍼를 죽일 때 현재 버퍼를 변경하는 것과 관련된 예방 조치도 취해야합니다 (종료되는 버퍼가 현재 버퍼가 아님을 알 수없는 경우). &lt;a href=&quot;current-buffer#Current-Buffer&quot;&gt;현재 버퍼를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2706b518d3512c99807786ca5940e248dfba9276" translate="yes" xml:space="preserve">
          <source>If you kill a buffer that is the base buffer of one or more indirect buffers (see &lt;a href=&quot;indirect-buffers#Indirect-Buffers&quot;&gt;Indirect Buffers&lt;/a&gt;), the indirect buffers are automatically killed as well.</source>
          <target state="translated">하나 이상의 간접 버퍼의 기본 버퍼 인 버퍼를 종료하면 ( &lt;a href=&quot;indirect-buffers#Indirect-Buffers&quot;&gt;간접 버퍼&lt;/a&gt; 참조 ) 간접 버퍼도 자동으로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="939512f98de951d77e46c1fff3ddbca96952464a" translate="yes" xml:space="preserve">
          <source>If you kill the buffer-local binding of a variable that automatically becomes buffer-local when set, this makes the default value visible in the current buffer. However, if you set the variable again, that will once again create a buffer-local binding for it.</source>
          <target state="translated">설정시 자동으로 버퍼 로컬이되는 변수의 버퍼 로컬 바인딩을 종료하면 현재 버퍼에 기본값이 표시됩니다. 그러나 변수를 다시 설정하면 해당 변수에 대한 버퍼 로컬 바인딩이 다시 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="0bd6b02038337f2a12bac9ed44de58bac548a3a1" translate="yes" xml:space="preserve">
          <source>If you make local bindings (with &lt;code&gt;let&lt;/code&gt; or function arguments) for a variable that may also have buffer-local bindings, make sure that the same buffer is current at the beginning and at the end of the local binding&amp;rsquo;s scope. Otherwise you might bind it in one buffer and unbind it in another!</source>
          <target state="translated">버퍼-로컬 바인딩이있을 수도있는 변수에 대해 로컬 바인딩 ( &lt;code&gt;let&lt;/code&gt; 또는 함수 인수 사용)을 만드는 경우 동일한 버퍼가 로컬 바인딩 범위의 시작과 끝에서 최신 상태인지 확인하십시오. 그렇지 않으면 한 버퍼에 바인딩하고 다른 버퍼에 바인딩 해제 할 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="0b3744efd19539e84c69f0918b4efca1435c71f7" translate="yes" xml:space="preserve">
          <source>If you may need to follow symbolic links preceding &amp;lsquo;</source>
          <target state="translated">'앞의 기호 링크를 따라야 할 경우</target>
        </trans-unit>
        <trans-unit id="b461f9a1f06af80679d7c10a422deb5335205d1b" translate="yes" xml:space="preserve">
          <source>If you modify any of these two variables, you should normally modify both, to make sure they describe paragraphs consistently. For example, to have each new line start a new paragraph for bidi-reordering purposes, set both variables to &lt;code&gt;&quot;^&quot;&lt;/code&gt;.</source>
          <target state="translated">이 두 변수 중 하나를 수정하는 경우 일반적으로 둘 다 수정하여 단락을 일관되게 설명하는지 확인해야합니다. 예를 들어, 입찰가 재정렬을 위해 각 새 행이 새 단락을 시작하도록하려면 두 변수를 모두 &lt;code&gt;&quot;^&quot;&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="fbb55a4c1fcd6f3dc2ebf9fd160259311b33e11d" translate="yes" xml:space="preserve">
          <source>If you need a function to read a character using the minibuffer, use &lt;code&gt;read-char-from-minibuffer&lt;/code&gt; (see &lt;a href=&quot;multiple-queries#Multiple-Queries&quot;&gt;Multiple Queries&lt;/a&gt;).</source>
          <target state="translated">미니 버퍼를 사용하여 문자를 읽는 함수가 필요한 경우 &lt;code&gt;read-char-from-minibuffer&lt;/code&gt; 를 사용 하십시오 ( &lt;a href=&quot;multiple-queries#Multiple-Queries&quot;&gt;Multiple Queries&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="2229e5dcc64890b68f42258b57c852775ec25771" translate="yes" xml:space="preserve">
          <source>If you need full backtracking capability to handle multiple uses of &amp;lsquo;</source>
          <target state="translated">'의 여러 사용을 처리하기 위해 전체 역 추적 기능이 필요한 경우</target>
        </trans-unit>
        <trans-unit id="7165f313d61fb790c146d795e82a0805252bf947" translate="yes" xml:space="preserve">
          <source>If you need something more sophisticated, such as to make changes in various buffers constitute one atomic group, you must directly call lower-level functions that &lt;code&gt;atomic-change-group&lt;/code&gt; uses.</source>
          <target state="translated">다양한 버퍼의 변경이 하나의 원자 그룹을 구성하는 것과 같이 더 정교한 것이 필요한 경우 &lt;code&gt;atomic-change-group&lt;/code&gt; 사용 하는 하위 수준 함수를 직접 호출해야 합니다.</target>
        </trans-unit>
        <trans-unit id="11ad821a0f4118843537a5c201be2e1b6fea9371" translate="yes" xml:space="preserve">
          <source>If you need to ask the user a question that might have more than just 2 answers, use &lt;code&gt;read-answer&lt;/code&gt;.</source>
          <target state="translated">사용자에게 2 개 이상의 답변이있는 질문을해야하는 경우 &lt;code&gt;read-answer&lt;/code&gt; 를 사용 하세요.</target>
        </trans-unit>
        <trans-unit id="bb6836f3fc908033ed970b99b5923dc6160e9d7e" translate="yes" xml:space="preserve">
          <source>If you need to compute the width of a string on display, you should use &lt;code&gt;string-width&lt;/code&gt; (see &lt;a href=&quot;size-of-displayed-text#Size-of-Displayed-Text&quot;&gt;Size of Displayed Text&lt;/a&gt;), not &lt;code&gt;length&lt;/code&gt;, since &lt;code&gt;length&lt;/code&gt; only counts the number of characters, but does not account for the display width of each character.</source>
          <target state="translated">당신이 디스플레이에 문자열의 폭을 계산해야하는 경우 사용합니다 &lt;code&gt;string-width&lt;/code&gt; (참조 &lt;a href=&quot;size-of-displayed-text#Size-of-Displayed-Text&quot;&gt;표시되는 텍스트의 크기&lt;/a&gt; ),하지 &lt;code&gt;length&lt;/code&gt; 때문에, &lt;code&gt;length&lt;/code&gt; 단지 문자의 수를 계산하지만 각 문자의 표시 폭을 고려하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="70e7694409075c9777e7eff046635c9af505c810" translate="yes" xml:space="preserve">
          <source>If you need to deal with time values that are not representable by &lt;code&gt;struct timespec&lt;/code&gt;, or if you want higher precision, call the Lisp function &lt;code&gt;encode-time&lt;/code&gt; and work with its return value. See &lt;a href=&quot;time-conversion#Time-Conversion&quot;&gt;Time Conversion&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;struct timespec&lt;/code&gt; 으로 표현할 수없는 시간 값을 처리해야 하거나 더 높은 정밀도를 원하면 Lisp 함수 &lt;code&gt;encode-time&lt;/code&gt; 을 호출 하고 반환 값으로 작업하십시오. &lt;a href=&quot;time-conversion#Time-Conversion&quot;&gt;시간 변환을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b8b147bdeb91ba4529c7e7a0d87287ac0e0835ba" translate="yes" xml:space="preserve">
          <source>If you need to display in a single buffer several very different types of text, consider using an alternative facility described in &lt;a href=&quot;swapping-text#Swapping-Text&quot;&gt;Swapping Text&lt;/a&gt;.</source>
          <target state="translated">단일 버퍼에 표시해야하는 경우 텍스트의 몇 가지 매우 다른 유형, 설명 대체 시설의 사용을 고려 &lt;a href=&quot;swapping-text#Swapping-Text&quot;&gt;스와핑 텍스트&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eeed25719a7b61a09bb3ff7fc01192b5bf607932" translate="yes" xml:space="preserve">
          <source>If you need to make sure the resulting string, when copied to a different location, will not change its visual appearance due to reordering of bidirectional text, use the &lt;code&gt;buffer-substring-with-bidi-context&lt;/code&gt; function (see &lt;a href=&quot;bidirectional-display#Bidirectional-Display&quot;&gt;buffer-substring-with-bidi-context&lt;/a&gt;).</source>
          <target state="translated">결과 문자열이 다른 위치에 복사 될 때 양방향 텍스트의 재정렬로 인해 시각적 모양이 변경되지 않도록해야하는 경우 &lt;code&gt;buffer-substring-with-bidi-context&lt;/code&gt; 함수를 사용하십시오 ( &lt;a href=&quot;bidirectional-display#Bidirectional-Display&quot;&gt;buffer-substring-with- bidi-context&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="f6b2d2f05788f0a22eaa0bceb4193d2292e14cac" translate="yes" xml:space="preserve">
          <source>If you need to split a string into a list of individual command-line arguments suitable for &lt;code&gt;call-process&lt;/code&gt; or &lt;code&gt;start-process&lt;/code&gt;, see &lt;a href=&quot;shell-arguments#Shell-Arguments&quot;&gt;split-string-and-unquote&lt;/a&gt;.</source>
          <target state="translated">문자열을 &lt;code&gt;call-process&lt;/code&gt; 또는 &lt;code&gt;start-process&lt;/code&gt; 에 적합한 개별 명령 줄 인수 목록으로 분할해야하는 경우 &lt;a href=&quot;shell-arguments#Shell-Arguments&quot;&gt;split-string-and-unquote를&lt;/a&gt; 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="af860e5b717926ca034b7f46b6b08bfccf91b51e" translate="yes" xml:space="preserve">
          <source>If you need to use &lt;code&gt;funcall&lt;/code&gt; to call a command and make it behave as if invoked interactively, use &lt;code&gt;funcall-interactively&lt;/code&gt; (see &lt;a href=&quot;interactive-call#Interactive-Call&quot;&gt;Interactive Call&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;funcall&lt;/code&gt; 을 사용 하여 명령을 호출하고 대화식 으로 호출 된 것처럼 작동하도록 &lt;code&gt;funcall-interactively&lt;/code&gt; 경우 funcall-interactively를 사용 하십시오 ( &lt;a href=&quot;interactive-call#Interactive-Call&quot;&gt;Interactive Call&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="d21db95cbdcf54c25ebb2a8e577371ca4dde72ec" translate="yes" xml:space="preserve">
          <source>If you need to use binary I/O in batch mode, e.g., use the functions described in this section to write out arbitrary binary data or avoid conversion of newlines on non-POSIX hosts, see &lt;a href=&quot;input-functions#Input-Functions&quot;&gt;set-binary-mode&lt;/a&gt;.</source>
          <target state="translated">배치 모드에서 바이너리 I / O를 사용해야하는 경우, 예를 들어이 섹션에 설명 된 함수를 사용하여 임의의 바이너리 데이터를 작성하거나 비 POSIX 호스트에서 줄 바꿈 변환을 방지 &lt;a href=&quot;input-functions#Input-Functions&quot;&gt;합니다&lt;/a&gt; . set-binary-mode를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b65293e7558904871088857519e372b129e02eab" translate="yes" xml:space="preserve">
          <source>If you only need to save and restore the identity of the current buffer, use &lt;code&gt;save-current-buffer&lt;/code&gt; or &lt;code&gt;with-current-buffer&lt;/code&gt; instead (see &lt;a href=&quot;current-buffer#Current-Buffer&quot;&gt;Current Buffer&lt;/a&gt;). If you need to save or restore window configurations, see the forms described in &lt;a href=&quot;window-configurations#Window-Configurations&quot;&gt;Window Configurations&lt;/a&gt; and in &lt;a href=&quot;frame-configurations#Frame-Configurations&quot;&gt;Frame Configurations&lt;/a&gt;.</source>
          <target state="translated">현재 버퍼의 ID 만 저장하고 복원해야하는 경우 대신 &lt;code&gt;save-current-buffer&lt;/code&gt; 또는 &lt;code&gt;with-current-buffer&lt;/code&gt; 를 사용하십시오 ( &lt;a href=&quot;current-buffer#Current-Buffer&quot;&gt;현재 버퍼&lt;/a&gt; 참조 ). 창 구성을 저장하거나 복원해야하는 경우 &lt;a href=&quot;window-configurations#Window-Configurations&quot;&gt;창 구성&lt;/a&gt; 및 &lt;a href=&quot;frame-configurations#Frame-Configurations&quot;&gt;프레임 구성&lt;/a&gt; 에 설명 된 양식을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9083fbc2d21158149a1bc8ac3c7f2844e3ff216f" translate="yes" xml:space="preserve">
          <source>If you performed the last search on a string, pass the same string as &lt;var&gt;string&lt;/var&gt;. Then this function returns a new string, in which the matched text is replaced by &lt;var&gt;replacement&lt;/var&gt;.</source>
          <target state="translated">문자열에 대해 마지막 검색을 수행 한 경우 동일한 문자열을 &lt;var&gt;string&lt;/var&gt; 과 전달하십시오 . 그런 다음이 함수는 일치하는 텍스트가 &lt;var&gt;replacement&lt;/var&gt; 로 대체되는 새 문자열을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="fbd25781d637473670d3becc584d66487e91046b" translate="yes" xml:space="preserve">
          <source>If you plan to use &lt;code&gt;read&lt;/code&gt; later on the formatted string to retrieve a copy of the formatted value, use a specification that lets &lt;code&gt;read&lt;/code&gt; reconstruct the value. To format numbers in this reversible way you can use &amp;lsquo;</source>
          <target state="translated">형식이 지정된 문자열에서 나중에 &lt;code&gt;read&lt;/code&gt; 를 사용 하여 형식이 지정된 값의 복사본을 검색하려면 &lt;code&gt;read&lt;/code&gt; 가 값을 재구성 할 수있는 사양을 사용 하십시오. 이 되돌릴 수있는 방식으로 숫자를 형식화하려면 '</target>
        </trans-unit>
        <trans-unit id="6a33cd11cdd6f251eb76fe12ca6c4e85092aa642" translate="yes" xml:space="preserve">
          <source>If you press the same mouse button more than once in quick succession without moving the mouse, Emacs generates special &lt;em&gt;repeat&lt;/em&gt; mouse events for the second and subsequent presses.</source>
          <target state="translated">마우스를 움직이지 않고 같은 마우스 버튼을 빠르게 연속해서 두 번 이상 누르면 Emacs 는 두 번째 및 이후의 누르기에 대해 특별한 &lt;em&gt;반복&lt;/em&gt; 마우스 이벤트를 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="6e651e37e48dc0de984abd21d2f50cbabd101a42" translate="yes" xml:space="preserve">
          <source>If you provide a string instead of a symbol as &lt;var&gt;symbol&lt;/var&gt;, it stands for a symbol name. Then &lt;code&gt;unintern&lt;/code&gt; deletes the symbol (if any) in the obarray which has that name. If there is no such symbol, &lt;code&gt;unintern&lt;/code&gt; does nothing.</source>
          <target state="translated">당신이 대신 문자열로 상징 제공하는 경우 &lt;var&gt;symbol&lt;/var&gt; , 그것은 기호 이름을 의미합니다. 그런 다음 &lt;code&gt;unintern&lt;/code&gt; 은 해당 이름을 가진 obarray에서 기호 (있는 경우)를 삭제합니다. 그러한 기호가 없으면 &lt;code&gt;unintern&lt;/code&gt; 은 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="97d5739d107f56aa611048ed083389faa16f7c11" translate="yes" xml:space="preserve">
          <source>If you put a &lt;code&gt;defcustom&lt;/code&gt; in a pre-loaded Emacs Lisp file (see &lt;a href=&quot;building-emacs#Building-Emacs&quot;&gt;Building Emacs&lt;/a&gt;), the standard value installed at dump time might be incorrect, e.g., because another variable that it depends on has not been assigned the right value yet. In that case, use &lt;code&gt;custom-reevaluate-setting&lt;/code&gt;, described below, to re-evaluate the standard value after Emacs starts up.</source>
          <target state="translated">미리로드 된 Emacs Lisp 파일에 &lt;code&gt;defcustom&lt;/code&gt; 을 넣으면 ( &lt;a href=&quot;building-emacs#Building-Emacs&quot;&gt;Emacs 빌드&lt;/a&gt; 참조 ) 덤프 시간에 설치된 표준 값이 올바르지 않을 수 있습니다. 예를 들어 의존하는 다른 변수에 아직 올바른 값이 할당되지 않았기 때문입니다. 이 경우 아래 설명 된 &lt;code&gt;custom-reevaluate-setting&lt;/code&gt; 을 사용 하여 Emacs가 시작된 후 표준 값을 다시 평가하십시오.</target>
        </trans-unit>
        <trans-unit id="6c382b520db08e679ebb946a10d148108b4e2829" translate="yes" xml:space="preserve">
          <source>If you put a &lt;code&gt;yank-handler&lt;/code&gt; text property on all or part of a string, that alters how &lt;code&gt;insert-for-yank&lt;/code&gt; inserts the string. If different parts of the string have different &lt;code&gt;yank-handler&lt;/code&gt; values (comparison being done with &lt;code&gt;eq&lt;/code&gt;), each substring is handled separately. The property value must be a list of one to four elements, with the following format (where elements after the first may be omitted):</source>
          <target state="translated">문자열의 전체 또는 일부에 &lt;code&gt;yank-handler&lt;/code&gt; 텍스트 속성 을 넣으면 &lt;code&gt;insert-for-yank&lt;/code&gt; 가 문자열을 삽입하는 방법이 변경 됩니다. 문자열의 다른 부분에 다른 &lt;code&gt;yank-handler&lt;/code&gt; 값이있는 경우 ( &lt;code&gt;eq&lt;/code&gt; 로 수행되는 비교 ) 각 하위 문자열이 개별적으로 처리됩니다. 속성 값은 다음과 같은 형식의 1-4 개 요소 목록이어야합니다 (첫 번째 요소 뒤의 요소는 생략 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="20d9b4533ab2bc9736806c58622cd4bf44e87f4c" translate="yes" xml:space="preserve">
          <source>If you redump Emacs by calling &lt;code&gt;dump-emacs&lt;/code&gt; (see &lt;a href=&quot;building-emacs#Building-Emacs&quot;&gt;Building Emacs&lt;/a&gt;), you may wish to set this variable to &lt;code&gt;nil&lt;/code&gt; first in order to cause the new dumped Emacs to process its new command-line arguments.</source>
          <target state="translated">&lt;code&gt;dump-emacs&lt;/code&gt; 를 호출하여 Emacs를 다시 덤프 하는 경우 ( &lt;a href=&quot;building-emacs#Building-Emacs&quot;&gt;Emacs 빌드&lt;/a&gt; 참조 ), 새 덤프 된 Emacs가 새 명령 줄 인수를 처리하도록 하려면 먼저이 변수를 &lt;code&gt;nil&lt;/code&gt; 로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="085a188ee0ae3f10744759afa9f5b7baf461b132" translate="yes" xml:space="preserve">
          <source>If you run &lt;code&gt;normal-mode&lt;/code&gt; interactively, the argument &lt;var&gt;find-file&lt;/var&gt; is normally &lt;code&gt;nil&lt;/code&gt;. In this case, &lt;code&gt;normal-mode&lt;/code&gt; unconditionally processes any file local variables.</source>
          <target state="translated">&lt;code&gt;normal-mode&lt;/code&gt; 대화식으로 실행하는 경우 &lt;var&gt;find-file&lt;/var&gt; 인수 는 일반적으로 &lt;code&gt;nil&lt;/code&gt; 입니다. 이 경우 &lt;code&gt;normal-mode&lt;/code&gt; 는 모든 파일 로컬 변수를 무조건 처리합니다.</target>
        </trans-unit>
        <trans-unit id="69bd4b2952384a0a33ef5b0366f425ff27273401" translate="yes" xml:space="preserve">
          <source>If you run Emacs from the directory where it was built&amp;mdash;that is, an executable that has not been formally installed&amp;mdash;Emacs instead initializes &lt;code&gt;load-path&lt;/code&gt; using the</source>
          <target state="translated">Emacs가 빌드 된 디렉토리, 즉 공식적으로 설치되지 않은 실행 파일에서 실행하는 경우 Emacs는 대신 다음을 사용하여 &lt;code&gt;load-path&lt;/code&gt; 를 초기화 합니다.</target>
        </trans-unit>
        <trans-unit id="33df89859e8bd5153172b40f655f9725c87eaa23" translate="yes" xml:space="preserve">
          <source>If you set &lt;code&gt;debug-on-event&lt;/code&gt; to a special event (see &lt;a href=&quot;special-events#Special-Events&quot;&gt;Special Events&lt;/a&gt;), Emacs will try to enter the debugger as soon as it receives this event, bypassing &lt;code&gt;special-event-map&lt;/code&gt;. At present, the only supported values correspond to the signals &lt;code&gt;SIGUSR1&lt;/code&gt; and &lt;code&gt;SIGUSR2&lt;/code&gt; (this is the default). This can be helpful when &lt;code&gt;inhibit-quit&lt;/code&gt; is set and Emacs is not otherwise responding.</source>
          <target state="translated">를 설정하면 &lt;code&gt;debug-on-event&lt;/code&gt; 특별 이벤트 (참조 &lt;a href=&quot;special-events#Special-Events&quot;&gt;특별 이벤트&lt;/a&gt; , 이맥스는 무시하고,이 이벤트를 수신하는 즉시로 디버거를 입력하려고 할 것이다) &lt;code&gt;special-event-map&lt;/code&gt; . 현재 지원되는 유일한 값은 &lt;code&gt;SIGUSR1&lt;/code&gt; 및 &lt;code&gt;SIGUSR2&lt;/code&gt; 신호에 해당합니다 (기본값). 이것은 &lt;code&gt;inhibit-quit&lt;/code&gt; 가 설정되어 있고 Emacs가 달리 응답하지 않을 때 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9c694c02ac2532f5fe2abe237714159362002a21" translate="yes" xml:space="preserve">
          <source>If you set &lt;code&gt;debug-on-message&lt;/code&gt; to a regular expression, Emacs will enter the debugger if it displays a matching message in the echo area. For example, this can be useful when trying to find the cause of a particular message.</source>
          <target state="translated">를 설정하면 &lt;code&gt;debug-on-message&lt;/code&gt; 정규 표현식으로는 에코 영역에서 일치하는 메시지를 표시하는 경우, 이맥스는 디버거를 입력합니다. 예를 들어 특정 메시지의 원인을 찾으려고 할 때 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="690f685efae0cb9f9d5902d7605b6ee4e66d6dce" translate="yes" xml:space="preserve">
          <source>If you set this hook locally in a buffer, it is assumed to be associated with the file or the way the contents of the buffer were obtained. Thus the variable is marked as a permanent local, so that changing the major mode does not alter a buffer-local value. On the other hand, calling &lt;code&gt;set-visited-file-name&lt;/code&gt; will reset it. If this is not what you want, you might like to use &lt;code&gt;write-contents-functions&lt;/code&gt; instead.</source>
          <target state="translated">이 후크를 버퍼에 로컬로 설정하면 파일과 관련된 것으로 간주되거나 버퍼의 내용을 획득 한 방식으로 간주됩니다. 따라서 변수는 영구 로컬로 표시되므로 주 모드를 변경해도 버퍼 로컬 값이 변경되지 않습니다. 반면에 &lt;code&gt;set-visited-file-name&lt;/code&gt; 을 호출 하면 재설정됩니다. 이것이 원하는 것이 아니라면 &lt;code&gt;write-contents-functions&lt;/code&gt; 를 대신 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="cfc7987161a9303dafc2b33573d2e5f10008802a" translate="yes" xml:space="preserve">
          <source>If you set this variable to &lt;code&gt;nil&lt;/code&gt; in a buffer, that buffer does not have a mode line. (A window that is just one line tall also does not display a mode line.)</source>
          <target state="translated">버퍼 에서이 변수를 &lt;code&gt;nil&lt;/code&gt; 로 설정하면 해당 버퍼에 모드 라인이 없습니다. (단 한 줄의 창도 모드 줄을 표시하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="9d66da1552d51dd81ff05a3b900a0329bf52436f" translate="yes" xml:space="preserve">
          <source>If you set this variable to a non-&lt;code&gt;nil&lt;/code&gt; value, the feature of moving point out of these sequences is completely turned off.</source>
          <target state="translated">이 변수를 &lt;code&gt;nil&lt;/code&gt; 이 아닌 값으로 설정하면 이러한 시퀀스에서 포인트를 이동하는 기능이 완전히 꺼집니다.</target>
        </trans-unit>
        <trans-unit id="ca8a3595d33e58a00ada25426e1b2f96b61be780" translate="yes" xml:space="preserve">
          <source>If you specify &lt;var&gt;initial&lt;/var&gt;, that is an initial file name to insert in the buffer (after &lt;var&gt;directory&lt;/var&gt;, if that is inserted). In this case, point goes at the beginning of &lt;var&gt;initial&lt;/var&gt;. The default for &lt;var&gt;initial&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;&amp;mdash;don&amp;rsquo;t insert any file name. To see what &lt;var&gt;initial&lt;/var&gt; does, try the command</source>
          <target state="translated">&lt;var&gt;initial&lt;/var&gt; 을 지정 하면 버퍼에 삽입 할 초기 파일 이름 입니다 (삽입 된 경우 &lt;var&gt;directory&lt;/var&gt; 뒤에 ). 이 경우 점은 &lt;var&gt;initial&lt;/var&gt; 시작 부분에 있습니다. &lt;var&gt;initial&lt;/var&gt; 의 기본값 은 &lt;code&gt;nil&lt;/code&gt; 입니다. 파일 이름을 삽입 하지 마십시오. &lt;var&gt;initial&lt;/var&gt; 이 무엇을하는지 확인하려면 다음 명령을 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="5c87b5e9500f1aecb01a1e2b9e8cf60f70697916" translate="yes" xml:space="preserve">
          <source>If you specify &lt;var&gt;prompt&lt;/var&gt;, that becomes the overall prompt string for the keymap. You should specify this only for menu keymaps (see &lt;a href=&quot;defining-menus#Defining-Menus&quot;&gt;Defining Menus&lt;/a&gt;). A keymap with an overall prompt string will always present a mouse menu or a keyboard menu if it is active for looking up the next input event. Don&amp;rsquo;t specify an overall prompt string for the main map of a major or minor mode, because that would cause the command loop to present a keyboard menu every time.</source>
          <target state="translated">&lt;var&gt;prompt&lt;/var&gt; 를 지정 하면 키맵에 대한 전체 프롬프트 문자열이됩니다. 메뉴 키맵에 대해서만 지정해야합니다 ( &lt;a href=&quot;defining-menus#Defining-Menus&quot;&gt;메뉴 정의&lt;/a&gt; 참조 ). 전체 프롬프트 문자열이있는 키맵은 다음 입력 이벤트를 찾기 위해 활성화 된 경우 항상 마우스 메뉴 또는 키보드 메뉴를 표시합니다. 주 또는 부 모드의 주 맵에 대한 전체 프롬프트 문자열을 지정하지 마십시오. 명령 루프가 매번 키보드 메뉴를 표시하게 할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="5edea50f7657db34bc2bc85d01daa7f7adc96609" translate="yes" xml:space="preserve">
          <source>If you specify &lt;var&gt;uid&lt;/var&gt; (a number), the result is the user name that corresponds to &lt;var&gt;uid&lt;/var&gt;, or &lt;code&gt;nil&lt;/code&gt; if there is no such user.</source>
          <target state="translated">&lt;var&gt;uid&lt;/var&gt; (숫자) 를 지정하는 경우 결과는 &lt;var&gt;uid&lt;/var&gt; 에 해당하는 사용자 이름 이거나 해당 사용자가없는 경우 &lt;code&gt;nil&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f97e6393b96bab93a2f54c0164447ab04caf4a1b" translate="yes" xml:space="preserve">
          <source>If you specify a buffer, &lt;var&gt;buffer&lt;/var&gt;, then the value is the size of &lt;var&gt;buffer&lt;/var&gt;.</source>
          <target state="translated">buffer, &lt;var&gt;buffer&lt;/var&gt; 를 지정 하면 값은 &lt;var&gt;buffer&lt;/var&gt; 의 크기입니다 .</target>
        </trans-unit>
        <trans-unit id="f505374ea489ecb94c5a8340e207775e38c3e1b5" translate="yes" xml:space="preserve">
          <source>If you specify a number for &lt;var&gt;limit&lt;/var&gt;, then after chasing through that many links, the function just returns what it has even if that is still a symbolic link.</source>
          <target state="translated">&lt;var&gt;limit&lt;/var&gt; 에 숫자를 지정하면 그 많은 링크를 추적 한 후 함수는 여전히 기호 링크 인 경우에도 가지고있는 것을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="375bd3746fef25d0232e18d73f21e041e0753b43" translate="yes" xml:space="preserve">
          <source>If you specify an XBM image using data within Emacs instead of an external file, use the following three properties:</source>
          <target state="translated">외부 파일 대신 Emacs 내의 데이터를 사용하여 XBM 이미지를 지정하는 경우 다음 세 가지 속성을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fde2a383a2451f6ddbde3c6482877a98961e5cf2" translate="yes" xml:space="preserve">
          <source>If you specify the frame name explicitly when you create the frame, the name is also used (instead of the name of the Emacs executable) when looking up X resources for the frame.</source>
          <target state="translated">프레임을 생성 할 때 명시 적으로 프레임 이름을 지정하면 프레임에 대한 X 리소스를 찾을 때이 이름도 사용됩니다 (Emacs 실행 파일의 이름 대신).</target>
        </trans-unit>
        <trans-unit id="f6ca207d06cc2c68a4c2828df92b77209025123f" translate="yes" xml:space="preserve">
          <source>If you specify the same slot on the same side for two or more different buffers, the buffer displayed last is shown in the corresponding window. Hence, slots can be used for sharing the same side window between buffers.</source>
          <target state="translated">두 개 이상의 다른 버퍼에 대해 같은쪽에 동일한 슬롯을 지정하면 마지막에 표시된 버퍼가 해당 창에 표시됩니다. 따라서 슬롯은 버퍼간에 동일한 사이드 윈도우를 공유하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05d28610a19e0f56bd2c76d43cd9274215e3fa7d" translate="yes" xml:space="preserve">
          <source>If you specify this keyword, the variable&amp;rsquo;s documentation string should describe how to do the same job in hand-written Lisp code.</source>
          <target state="translated">이 키워드를 지정하면 변수의 설명서 문자열이 손으로 작성한 Lisp 코드에서 동일한 작업을 수행하는 방법을 설명해야합니다.</target>
        </trans-unit>
        <trans-unit id="716618ddbeabe19866aadf7f17b67b04057ebcef" translate="yes" xml:space="preserve">
          <source>If you store a completion alist in a variable, you should mark the variable as risky by giving it a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;risky-local-variable&lt;/code&gt; property. See &lt;a href=&quot;file-local-variables#File-Local-Variables&quot;&gt;File Local Variables&lt;/a&gt;.</source>
          <target state="translated">완료 목록을 변수에 저장하는 경우 &lt;code&gt;nil&lt;/code&gt; 이 아닌 &lt;code&gt;risky-local-variable&lt;/code&gt; 속성을 지정 하여 변수를 위험으로 표시해야 합니다. &lt;a href=&quot;file-local-variables#File-Local-Variables&quot;&gt;파일 로컬 변수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="40a77c6103e436345187dd30831cc5254ef479b8" translate="yes" xml:space="preserve">
          <source>If you try this, you will notice that repeated attempts to display</source>
          <target state="translated">이것을 시도하면 반복적으로 표시하려는 시도가 있음을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a67eecb62315ce39f790ce6ffad7fa4e38d4eb8" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;buffer-swap-text&lt;/code&gt; on a file-visiting buffer, you should set up a hook to save the buffer&amp;rsquo;s original text rather than what it was swapped with. &lt;code&gt;write-region-annotate-functions&lt;/code&gt; works for this purpose. You should probably set &lt;code&gt;buffer-saved-size&lt;/code&gt; to -2 in the buffer, so that changes in the text it is swapped with will not interfere with auto-saving.</source>
          <target state="translated">당신이 사용하는 경우 &lt;code&gt;buffer-swap-text&lt;/code&gt; 파일 - 방문 버퍼에, 당신은 오히려이로 교체 된 것보다 버퍼의 원래 텍스트를 저장하는 후크를 설정해야합니다. &lt;code&gt;write-region-annotate-functions&lt;/code&gt; 는 이러한 목적으로 작동합니다. 당신은 아마 설정해야 &lt;code&gt;buffer-saved-size&lt;/code&gt; 자동 저장을 방해하지 않습니다와 텍스트의 변경이 교환되고 그래서, 버퍼에 -2.</target>
        </trans-unit>
        <trans-unit id="d6907391755fb47bb50b18a1d24adc63588140ea" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;regexp-opt&lt;/code&gt; to produce the regular expression &lt;var&gt;matcher&lt;/var&gt;, you can use &lt;code&gt;regexp-opt-depth&lt;/code&gt; (see &lt;a href=&quot;regexp-functions#Regexp-Functions&quot;&gt;Regexp Functions&lt;/a&gt;) to calculate the value for &lt;var&gt;subexp&lt;/var&gt;.</source>
          <target state="translated">당신이 사용하는 경우 &lt;code&gt;regexp-opt&lt;/code&gt; 정규 표현식 생산하는 &lt;var&gt;matcher&lt;/var&gt; , 당신이 사용할 수있는 &lt;code&gt;regexp-opt-depth&lt;/code&gt; (참조 &lt;a href=&quot;regexp-functions#Regexp-Functions&quot;&gt;정규 표현식 함수&lt;/a&gt; 의 값을 계산하기 위해) &lt;var&gt;subexp&lt;/var&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="fd48732c105c46f30a8758370472e5d61da524f5" translate="yes" xml:space="preserve">
          <source>If you use a minibuffer-only frame, you might want that frame to raise when you enter the minibuffer. If so, set the variable &lt;code&gt;minibuffer-auto-raise&lt;/code&gt; to &lt;code&gt;t&lt;/code&gt;. See &lt;a href=&quot;raising-and-lowering#Raising-and-Lowering&quot;&gt;Raising and Lowering&lt;/a&gt;.</source>
          <target state="translated">미니 버퍼 전용 프레임을 사용하는 경우 미니 버퍼에 들어갈 때 해당 프레임이 올라가도록 할 수 있습니다. 그렇다면 변수 &lt;code&gt;minibuffer-auto-raise&lt;/code&gt; 를 &lt;code&gt;t&lt;/code&gt; 로 설정하십시오 . &lt;a href=&quot;raising-and-lowering#Raising-and-Lowering&quot;&gt;올리기 및 내리기를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fa0c1227e66ae4b44f79049d6018702a84803396" translate="yes" xml:space="preserve">
          <source>If you use any Unicode-style escape sequence &amp;lsquo;</source>
          <target state="translated">유니 코드 스타일 이스케이프 시퀀스 '를 사용하는 경우</target>
        </trans-unit>
        <trans-unit id="0b2b537fa713937b15520eb5e6b8621ddcd5294c" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;define-derived-mode&lt;/code&gt; macro, it will take care of many of these conventions automatically. See &lt;a href=&quot;derived-modes#Derived-Modes&quot;&gt;Derived Modes&lt;/a&gt;. Note also that Fundamental mode is an exception to many of these conventions, because it represents the default state of Emacs.</source>
          <target state="translated">&lt;code&gt;define-derived-mode&lt;/code&gt; 매크로 를 사용하면 이러한 많은 규칙이 자동으로 처리됩니다. &lt;a href=&quot;derived-modes#Derived-Modes&quot;&gt;파생 모드를&lt;/a&gt; 참조하십시오 . Fundamental 모드는 Emacs의 기본 상태를 나타 내기 때문에 이러한 많은 규칙에서 예외입니다.</target>
        </trans-unit>
        <trans-unit id="ebbd02981d2d6e160b2592d755148aa81cf87d75" translate="yes" xml:space="preserve">
          <source>If you use this command in a different window displaying the same buffer, that window will be used instead to display the current definition in the future.</source>
          <target state="translated">동일한 버퍼를 표시하는 다른 창에서이 명령을 사용하는 경우 해당 창은 나중에 현재 정의를 표시하는 데 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="afdbef8990f56e48b4ad3c9668d8bcdb3999729f" translate="yes" xml:space="preserve">
          <source>If you use this for a type that appears as an alternative inside of &lt;code&gt;choice&lt;/code&gt;; it specifies the default value to use, at first, if and when the user selects this alternative with the menu in the customization buffer.</source>
          <target state="translated">&lt;code&gt;choice&lt;/code&gt; 의 대안으로 나타나는 유형에 이것을 사용하는 경우 ; 사용자가 사용자 정의 버퍼의 메뉴를 사용하여이 대안을 선택하는 경우 처음에 사용할 기본값을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="629ad44964d5895c3d594065b4e7da091b6bb932" translate="yes" xml:space="preserve">
          <source>If you use this keyword more than once, you can put a single item into more than one group. Displaying any of those groups will show this item. Please don&amp;rsquo;t overdo this, since the result would be annoying.</source>
          <target state="translated">이 키워드를 두 번 이상 사용하면 단일 항목을 둘 이상의 그룹에 넣을 수 있습니다. 이러한 그룹을 표시하면이 항목이 표시됩니다. 결과가 귀찮을 수 있으므로 과도하게 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="49e3ca07657354c28816ff97da5c7582b8256ace" translate="yes" xml:space="preserve">
          <source>If you want a menu bar submenu to have contents that vary, you should still use a menu keymap to implement it. To make the contents vary, add a hook function to &lt;code&gt;menu-bar-update-hook&lt;/code&gt; to update the contents of the menu keymap as necessary.</source>
          <target state="translated">메뉴 모음 하위 메뉴에 다양한 내용이 포함되도록하려면 메뉴 키맵을 사용하여 구현해야합니다. 내용을 변경하려면 &lt;code&gt;menu-bar-update-hook&lt;/code&gt; 에 후크 함수를 추가하여 필요에 따라 메뉴 키맵의 내용을 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="3be39a84378c1d3ff63b94f456da0a9da8540136" translate="yes" xml:space="preserve">
          <source>If you want code to be executed when a &lt;em&gt;particular&lt;/em&gt; library is loaded, use the macro &lt;code&gt;with-eval-after-load&lt;/code&gt;:</source>
          <target state="translated">&lt;em&gt;특정&lt;/em&gt; 라이브러리가로드 될 때 코드가 실행되도록 하려면 &lt;code&gt;with-eval-after-load&lt;/code&gt; 매크로 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c9e263b344abbe33fc08169dcaf2cad9b660996f" translate="yes" xml:space="preserve">
          <source>If you want to be able to debug errors that are caught by a &lt;code&gt;condition-case&lt;/code&gt;, set the variable &lt;code&gt;debug-on-signal&lt;/code&gt; to a non-&lt;code&gt;nil&lt;/code&gt; value. You can also specify that a particular handler should let the debugger run first, by writing &lt;code&gt;debug&lt;/code&gt; among the conditions, like this:</source>
          <target state="translated">&lt;code&gt;condition-case&lt;/code&gt; 에서 포착 된 오류를 디버깅 할 수 있도록하려면 &lt;code&gt;debug-on-signal&lt;/code&gt; 변수를 &lt;code&gt;nil&lt;/code&gt; 이 아닌 값으로 설정하십시오. 다음 과 같이 조건간에 &lt;code&gt;debug&lt;/code&gt; 를 작성하여 특정 핸들러가 디버거가 먼저 실행되도록 지정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="59bdec6558d0121a21861b3648de710d60579fcc" translate="yes" xml:space="preserve">
          <source>If you want to be able to distinguish all possible values computed by &lt;var&gt;body&lt;/var&gt; from both kinds of abort conditions, write the code like this:</source>
          <target state="translated">두 종류의 중단 조건에서 &lt;var&gt;body&lt;/var&gt; 의해 계산 된 모든 가능한 값을 구별 할 수 있도록하려면 다음과 같은 코드를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="c7c6338ea698e54cbd61c931fd1eb115534a9075" translate="yes" xml:space="preserve">
          <source>If you want to change the way Emacs handles drop of different types or add a new type, customize &lt;code&gt;x-dnd-types-alist&lt;/code&gt;. This requires detailed knowledge of what types other applications use for drag and drop.</source>
          <target state="translated">Emacs가 다른 유형의 드롭을 처리하는 방식을 변경하거나 새 유형을 추가하려면 &lt;code&gt;x-dnd-types-alist&lt;/code&gt; 를 사용자 정의하십시오 . 이를 위해서는 다른 응용 프로그램이 드래그 앤 드롭에 사용하는 유형에 대한 자세한 지식이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="9962c78c83f1c13605cf8ba722facf4943be5aa3" translate="yes" xml:space="preserve">
          <source>If you want to define &lt;code&gt;safe-local-variable&lt;/code&gt; properties for variables defined in C source code, add the names and the properties of those variables to the list in the &amp;ldquo;Safe local variables&amp;rdquo; section of</source>
          <target state="translated">C 소스 코드에 정의 된 &lt;code&gt;safe-local-variable&lt;/code&gt; 에 대해 안전한 로컬 변수 속성을 정의하려면 해당 변수의 이름과 속성을 &quot;안전한 로컬 변수&quot;섹션의 목록에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="a63fb633f610fcf7b569e1e58f5a8bedb9ec6204" translate="yes" xml:space="preserve">
          <source>If you want to delete elements that are &lt;code&gt;equal&lt;/code&gt; to a given value, use &lt;code&gt;delete&lt;/code&gt; (see below).</source>
          <target state="translated">당신이 요소를 삭제하려면 &lt;code&gt;equal&lt;/code&gt; 주어진 값을 사용하여 &lt;code&gt;delete&lt;/code&gt; (아래 참조).</target>
        </trans-unit>
        <trans-unit id="a770c467b911a60af82d90717d058d45481ec026" translate="yes" xml:space="preserve">
          <source>If you want to find all matches for a regexp in part of the buffer, and replace them, the best way is to write an explicit loop using &lt;code&gt;re-search-forward&lt;/code&gt; and &lt;code&gt;replace-match&lt;/code&gt;, like this:</source>
          <target state="translated">버퍼의 일부에서 정규 표현식에 대한 모든 일치 항목을 찾아서 교체하려면 다음과 같이 &lt;code&gt;re-search-forward&lt;/code&gt; 및 &lt;code&gt;replace-match&lt;/code&gt; 를 사용하여 명시 적 루프를 작성하는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="e07043ea04e2ff5e4af20b9e5042e3dbc7fb1ab7" translate="yes" xml:space="preserve">
          <source>If you want to increment the variable, you must use &lt;code&gt;setq&lt;/code&gt;, like this:</source>
          <target state="translated">변수를 증가 시키려면 다음과 같이 &lt;code&gt;setq&lt;/code&gt; 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c38bee5b246e44204c9311862ab52b37815b5e96" translate="yes" xml:space="preserve">
          <source>If you want to make a Lisp variable that is defined in C behave like one declared with &lt;code&gt;defcustom&lt;/code&gt;, add an appropriate entry to</source>
          <target state="translated">C에 정의 된 Lisp 변수가 &lt;code&gt;defcustom&lt;/code&gt; 으로 선언 된 것과 같이 작동하도록 하려면 적절한 항목을 다음에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="c89381f0269c1ad13f9db33500586f3038ca5d1c" translate="yes" xml:space="preserve">
          <source>If you want to make the new mode the default for files with certain recognizable names, add an element to &lt;code&gt;auto-mode-alist&lt;/code&gt; to select the mode for those file names (see &lt;a href=&quot;auto-major-mode#Auto-Major-Mode&quot;&gt;Auto Major Mode&lt;/a&gt;). If you define the mode command to autoload, you should add this element in the same file that calls &lt;code&gt;autoload&lt;/code&gt;. If you use an autoload cookie for the mode command, you can also use an autoload cookie for the form that adds the element (see &lt;a href=&quot;autoload#autoload-cookie&quot;&gt;autoload cookie&lt;/a&gt;). If you do not autoload the mode command, it is sufficient to add the element in the file that contains the mode definition.</source>
          <target state="translated">새 모드를 특정 인식 가능한 이름을 가진 파일의 기본값으로 만들려면 &lt;code&gt;auto-mode-alist&lt;/code&gt; 에 요소를 추가하여 해당 파일 이름에 대한 모드를 선택하십시오 ( &lt;a href=&quot;auto-major-mode#Auto-Major-Mode&quot;&gt;자동 주요 모드&lt;/a&gt; 참조 ). 당신이 자동로드에 모드 명령을 정의하면 호출 동일한 파일에이 요소를 추가해야합니다 &lt;code&gt;autoload&lt;/code&gt; . mode 명령에 자동로드 쿠키를 사용하는 경우 요소를 추가하는 양식에 자동로드 쿠키를 사용할 수도 있습니다 ( &lt;a href=&quot;autoload#autoload-cookie&quot;&gt;autoload cookie&lt;/a&gt; 참조 ). 모드 명령을 자동로드하지 않으면 모드 정의가 포함 된 파일에 요소를 추가하는 것으로 충분합니다.</target>
        </trans-unit>
        <trans-unit id="b6bd9286bc367e97ce4540abf13e066ac7ad9d72" translate="yes" xml:space="preserve">
          <source>If you want to pass a file name to another process so that another program can read the file, use the function &lt;code&gt;file-local-copy&lt;/code&gt;; see &lt;a href=&quot;magic-file-names#Magic-File-Names&quot;&gt;Magic File Names&lt;/a&gt;.</source>
          <target state="translated">다른 프로그램이 파일을 읽을 수 있도록 파일 이름을 다른 프로세스에 전달하려면 &lt;code&gt;file-local-copy&lt;/code&gt; 함수를 사용하십시오 . &lt;a href=&quot;magic-file-names#Magic-File-Names&quot;&gt;매직 파일 이름을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="252c3f2a6736d1faced75b5183751f3b39035b6e" translate="yes" xml:space="preserve">
          <source>If you want to preload function or variable definitions, there are three ways you can do this and make their documentation strings accessible when you subsequently run Emacs:</source>
          <target state="translated">함수 또는 변수 정의를 미리로드하려면 다음과 같은 세 가지 방법으로이를 수행하고 나중에 Emacs를 실행할 때 문서 문자열에 액세스 할 수 있도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2cee666fd30a296699a4e8f28dd2fdfe14c7228f" translate="yes" xml:space="preserve">
          <source>If you want to specify group members through &lt;var&gt;members&lt;/var&gt;, each element should have the form &lt;code&gt;(&lt;var&gt;name&lt;/var&gt; &lt;var&gt;widget&lt;/var&gt;)&lt;/code&gt;. Here &lt;var&gt;name&lt;/var&gt; is a symbol, and &lt;var&gt;widget&lt;/var&gt; is a widget type for editing that symbol. Useful widgets are &lt;code&gt;custom-variable&lt;/code&gt; for a variable, &lt;code&gt;custom-face&lt;/code&gt; for a face, and &lt;code&gt;custom-group&lt;/code&gt; for a group.</source>
          <target state="translated">당신은을 통해 그룹 구성원을 지정하려면 &lt;var&gt;members&lt;/var&gt; , 각 요소의 형식이 있어야합니다 &lt;code&gt;(&lt;var&gt;name&lt;/var&gt; &lt;var&gt;widget&lt;/var&gt;)&lt;/code&gt; . 여기서 &lt;var&gt;name&lt;/var&gt; 은 심볼이고 &lt;var&gt;widget&lt;/var&gt; 은 해당 심볼을 편집하기위한 위젯 유형입니다. 유용한 위젯은 &lt;code&gt;custom-variable&lt;/code&gt; 대한 &lt;code&gt;custom-face&lt;/code&gt; 변수, 얼굴에 대한 &lt;code&gt;custom-group&lt;/code&gt; 얼굴 및 그룹에 대한 사용자 정의 그룹입니다.</target>
        </trans-unit>
        <trans-unit id="8e10bdc9c026c4aa399e4b42ba23f64d06212059" translate="yes" xml:space="preserve">
          <source>If you want to take action as soon as a button is pressed, you need to handle &lt;em&gt;button-down&lt;/em&gt; events.&lt;a href=&quot;#FOOT13&quot; name=&quot;DOCF13&quot;&gt;&lt;sup&gt;13&lt;/sup&gt;&lt;/a&gt; These occur as soon as a button is pressed. They are represented by lists that look exactly like click events (see &lt;a href=&quot;click-events#Click-Events&quot;&gt;Click Events&lt;/a&gt;), except that the &lt;var&gt;event-type&lt;/var&gt; symbol name contains the prefix &amp;lsquo;</source>
          <target state="translated">버튼을 누르는 즉시 조치를 취하려면 &lt;em&gt;버튼 다운&lt;/em&gt; 이벤트 를 처리해야 합니다. &lt;a href=&quot;#FOOT13&quot; name=&quot;DOCF13&quot;&gt;&lt;sup&gt;13&lt;/sup&gt;&lt;/a&gt; 버튼을 누르면 바로 발생합니다. &lt;var&gt;event-type&lt;/var&gt; 심볼 이름에 접두사 '가 포함 된 것을 제외하고는 클릭 이벤트 ( &lt;a href=&quot;click-events#Click-Events&quot;&gt;클릭 이벤트&lt;/a&gt; 참조)와 똑같은 목록으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="1a0489351d0c73d72b0fca1ef67e3467436c6466" translate="yes" xml:space="preserve">
          <source>If you want to use a directory file name in making such a combination, you must first convert it to a directory name using &lt;code&gt;file-name-as-directory&lt;/code&gt;:</source>
          <target state="translated">이러한 조합을 만들 때 디렉토리 파일 이름을 사용하려면 먼저 &lt;code&gt;file-name-as-directory&lt;/code&gt; 를 사용하여 디렉토리 이름으로 변환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="27743c56b5d0dd9981b65d5ea4209829501380cb" translate="yes" xml:space="preserve">
          <source>If you want to use this function in an Emacs that was already dumped, you must run Emacs with the &amp;lsquo;</source>
          <target state="translated">이미 덤프 된 Emacs에서이 기능을 사용하려면 '</target>
        </trans-unit>
        <trans-unit id="9bff8e6a47b35cd45f5d8552d3e143fb633c4b1c" translate="yes" xml:space="preserve">
          <source>If you want to write a command along the lines of &lt;code&gt;query-replace&lt;/code&gt;, you can use &lt;code&gt;perform-replace&lt;/code&gt; to do the work.</source>
          <target state="translated">&lt;code&gt;query-replace&lt;/code&gt; 줄을 따라 명령을 작성 하려면 &lt;code&gt;perform-replace&lt;/code&gt; 를 사용 하여 작업을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="353f48c9646e1a608529d6b8bd599dd5f82d0944" translate="yes" xml:space="preserve">
          <source>If you want to write a temporary file which is likely to be small, you should compute the directory like this:</source>
          <target state="translated">작을 가능성이있는 임시 파일을 작성하려면 다음과 같이 디렉토리를 계산해야합니다.</target>
        </trans-unit>
        <trans-unit id="1def4c97f647247a5c5ff48230af3b2e0d31bcc6" translate="yes" xml:space="preserve">
          <source>If you want your program to handle different types differently, you must do explicit type checking. The most common way to check the type of an object is to call a &lt;em&gt;type predicate&lt;/em&gt; function. Emacs has a type predicate for each type, as well as some predicates for combinations of types.</source>
          <target state="translated">프로그램이 다른 유형을 다르게 처리하도록하려면 명시 적 유형 검사를 수행해야합니다. 객체의 유형을 확인하는 가장 일반적인 방법은 &lt;em&gt;유형 술어&lt;/em&gt; 함수 를 호출하는 것입니다. Emacs에는 각 유형에 대한 유형 술어와 유형 조합에 대한 일부 술어가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f232d7dc078880a275acb49812461edd0ce860d" translate="yes" xml:space="preserve">
          <source>If you wanted to attach the same replace menu to a mouse click, you can do it this way:</source>
          <target state="translated">마우스 클릭에 동일한 바꾸기 메뉴를 연결하려면 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28b8c0ff1e6b7f40141852b8f78ad49d083249f7" translate="yes" xml:space="preserve">
          <source>If you wish to add text properties to a buffer or remove them without marking the buffer as modified, you can wrap the calls above in the &lt;code&gt;with-silent-modifications&lt;/code&gt; macro. See &lt;a href=&quot;buffer-modification#Buffer-Modification&quot;&gt;Buffer Modification&lt;/a&gt;.</source>
          <target state="translated">버퍼에 텍스트 속성을 추가하거나 버퍼를 수정 된 것으로 표시하지 않고 제거하려면 &lt;code&gt;with-silent-modifications&lt;/code&gt; 매크로 에서 위의 호출을 래핑 할 수 있습니다 . &lt;a href=&quot;buffer-modification#Buffer-Modification&quot;&gt;버퍼 수정을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9314fb2dc1ec806dadc29d80680d276f22ec3691" translate="yes" xml:space="preserve">
          <source>If you wish to verify the conformance of a module to the Emacs dynamic module</source>
          <target state="translated">Emacs 동적 모듈에 대한 모듈의 적합성을 확인하려면</target>
        </trans-unit>
        <trans-unit id="ca331c2a227354c196a20ee4c8b853bb299d3e61" translate="yes" xml:space="preserve">
          <source>If you wish, you can replace the &lt;code&gt;ask-user-about-lock&lt;/code&gt; function with your own version that makes the decision in another way.</source>
          <target state="translated">원한다면 &lt;code&gt;ask-user-about-lock&lt;/code&gt; 기능을 다른 방식으로 결정을 내리는 자신의 버전으로 바꿀 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4d662283da0f2958a60954e2e27370bba9903a41" translate="yes" xml:space="preserve">
          <source>If you would like to see Edebug&amp;rsquo;s functions in the backtrace, use</source>
          <target state="translated">역 추적에서 Edebug의 기능을 보려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0e7b1af4801797b08feab3ca25fd99f927f534a2" translate="yes" xml:space="preserve">
          <source>If you write a function definition with an unusual macro that is not one of the known and recognized function definition methods, use of an ordinary magic autoload comment would copy the whole definition into &lt;code&gt;loaddefs.el&lt;/code&gt;. That is not desirable. You can put the desired &lt;code&gt;autoload&lt;/code&gt; call into &lt;code&gt;loaddefs.el&lt;/code&gt; instead by writing this:</source>
          <target state="translated">알려지고 인식 된 함수 정의 메서드 중 하나가 아닌 비정상적인 매크로로 함수 정의를 작성하는 경우 일반 매직 자동로드 주석을 사용하면 전체 정의가 &lt;code&gt;loaddefs.el&lt;/code&gt; 에 복사됩니다 . 그것은 바람직하지 않습니다. 대신 다음과 같이 작성 하여 원하는 &lt;code&gt;autoload&lt;/code&gt; 호출을 &lt;code&gt;loaddefs.el&lt;/code&gt; 에 넣을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d233d041f222a6f0703355568126be43236fb134" translate="yes" xml:space="preserve">
          <source>If you write your own function to be put on the &lt;code&gt;tooltip-functions&lt;/code&gt; list, you may need to know the buffer of the mouse event that triggered the tooltip display. The following function provides that information.</source>
          <target state="translated">&lt;code&gt;tooltip-functions&lt;/code&gt; 목록 에 추가 할 자체 함수를 작성하는 경우 툴팁 표시를 트리거 한 마우스 이벤트의 버퍼를 알아야 할 수 있습니다. 다음 함수는 해당 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5f651282e9deb511f780af54aec3d7ab9890404b" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re setting up an asynchronous TLS connection, you have to also provide the &lt;code&gt;:tls-parameters&lt;/code&gt; parameter (see below).</source>
          <target state="translated">비동기 TLS 연결을 설정하는 경우 &lt;code&gt;:tls-parameters&lt;/code&gt; 매개 변수 도 제공해야합니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="d70f5aea9c1d350e01a6eceee76a9e7dbb533230" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using another package, but only need macros from it (the byte compiler will expand those), then &lt;code&gt;eval-when-compile&lt;/code&gt; can be used to load it for compiling, but not executing. For example,</source>
          <target state="translated">다른 패키지를 사용하고 있지만 매크로 만 필요한 경우 (바이트 컴파일러가 해당 패키지를 확장 함) &lt;code&gt;eval-when-compile&lt;/code&gt; 을 사용하여 컴파일 을 위해로드 할 수 있지만 실행하지는 않습니다. 예를 들면</target>
        </trans-unit>
        <trans-unit id="2d45e994d3ba3dcb17fc10bf4fc110fdce2e5f3f" translate="yes" xml:space="preserve">
          <source>If your Emacs Lisp program needs to assign some faces to text, it is often a good idea to use certain existing faces or inherit from them, rather than defining entirely new faces. This way, if other users have customized the basic faces to give Emacs a certain look, your program will fit in without additional customization.</source>
          <target state="translated">Emacs Lisp 프로그램에서 일부 얼굴을 텍스트에 할당해야하는 경우 완전히 새로운 얼굴을 정의하는 것보다 기존의 특정 얼굴을 사용하거나 상속하는 것이 좋습니다. 이렇게하면 다른 사용자가 기본 얼굴을 사용자 지정하여 Emacs에 특정 모양을 부여한 경우 추가 사용자 지정없이 프로그램에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="5c8bded4be6d6694860d7eb8600eff32119af59a" translate="yes" xml:space="preserve">
          <source>If your Emacs build has ImageMagick support, you can use the ImageMagick library to load many image formats (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/File-Conveniences.html#File-Conveniences&quot;&gt;File Conveniences&lt;/a&gt; in</source>
          <target state="translated">이맥스 빌드 ImageMagick이 지원이있는 경우, 당신은 많은 이미지 포맷 (볼로드 ImageMagick이 라이브러리를 사용하여 &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/File-Conveniences.html#File-Conveniences&quot;&gt;파일의 편의를&lt;/a&gt; 에</target>
        </trans-unit>
        <trans-unit id="79aae3290a46dbcf7b36398be7497460dba8720d" translate="yes" xml:space="preserve">
          <source>If your Lisp program needs to make layout decisions, you will find the following function useful:</source>
          <target state="translated">Lisp 프로그램에서 레이아웃을 결정해야하는 경우 다음 기능이 유용합니다.</target>
        </trans-unit>
        <trans-unit id="5fc6e331da7d896db05ebf47e4b7c4b10ed997b9" translate="yes" xml:space="preserve">
          <source>If your function happens to read input, a character you type intending to interrupt execution may be read by the function instead. You can avoid such unintended results by paying attention to when your program wants input.</source>
          <target state="translated">함수가 입력을 읽으면 실행을 중단하려는 문자를 대신 함수에서 읽을 수 있습니다. 프로그램이 입력을 원할 때주의를 기울이면 이러한 의도하지 않은 결과를 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ba170033e789539342f30492cc68db1c80633aa" translate="yes" xml:space="preserve">
          <source>If your mode fontifies text explicitly by adding &lt;code&gt;font-lock-face&lt;/code&gt; properties, it can specify &lt;code&gt;(nil t)&lt;/code&gt; for &lt;code&gt;font-lock-defaults&lt;/code&gt; to turn off all automatic fontification. However, this is not required; it is possible to fontify some things using &lt;code&gt;font-lock-face&lt;/code&gt; properties and set up automatic fontification for other parts of the text.</source>
          <target state="translated">모드가 &lt;code&gt;font-lock-face&lt;/code&gt; 속성 을 추가하여 명시 적으로 텍스트 를 &lt;code&gt;font-lock-defaults&lt;/code&gt; 경우 font-lock-defaults 에 대해 &lt;code&gt;(nil t)&lt;/code&gt; 를 지정 하여 모든 자동 글꼴 화 를 끌 수 있습니다. 그러나 이것은 필수 사항이 아닙니다. &lt;code&gt;font-lock-face&lt;/code&gt; 속성을 사용하여 일부를 글꼴 화 하고 텍스트의 다른 부분에 대해 자동 글꼴 화를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c52d9cb365da1adebc29d4657b8bbaede4dc551" translate="yes" xml:space="preserve">
          <source>If your module includes potentially long-running code, it is a good idea to check from time to time in that code whether the user wants to quit, e.g., by typing</source>
          <target state="translated">모듈에 잠재적으로 오래 실행되는 코드가 포함 된 경우 해당 코드에서 사용자가 종료를 원하는지 수시로 확인하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="89267be88e244d3cd9cb4a0ac81d5a54135d6b2b" translate="yes" xml:space="preserve">
          <source>If your monitor displays colors too light, you should specify a &lt;code&gt;screen-gamma&lt;/code&gt; value smaller than 2.2. This requests correction that makes colors darker. A screen gamma value of 1.5 may give good results for LCD color displays.</source>
          <target state="translated">모니터에 색상이 너무 밝게 표시되는 경우 2.2보다 작은 &lt;code&gt;screen-gamma&lt;/code&gt; 값을 지정해야합니다 . 이것은 색상을 더 어둡게 만드는 보정을 요청합니다. 화면 감마 값이 1.5이면 LCD 컬러 디스플레이에 좋은 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd935a1aca6ebbfdcc9a67b41e3b53df100359c7" translate="yes" xml:space="preserve">
          <source>If your package uses a fixed file name, how to handle various operating systems simply.</source>
          <target state="translated">패키지가 고정 된 파일 이름을 사용하는 경우 다양한 운영 체제를 간단히 처리하는 방법.</target>
        </trans-unit>
        <trans-unit id="1193689cd9a0ac4f92f059d1dc0a2088ab488de5" translate="yes" xml:space="preserve">
          <source>If your program is working correctly, but not fast enough, and you want to make it run more quickly or efficiently, the first thing to do is &lt;em&gt;profile&lt;/em&gt; your code so that you know where it spends most of the execution time. If you find that one particular function is responsible for a significant portion of the execution time, you can start looking for ways to optimize that piece.</source>
          <target state="translated">프로그램이 제대로 작동하지만 충분히 빠르지 않은 경우 더 빠르고 효율적으로 실행하려는 경우 가장 먼저해야 할 일은 코드를 &lt;em&gt;프로파일 링&lt;/em&gt; 하여 대부분의 실행 시간을 소비하는 위치를 파악하는 것입니다. 하나의 특정 기능이 실행 시간의 상당 부분을 담당하는 경우 해당 부분을 최적화하는 방법을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1e042424d49662dae08a1bf6462ad5f5721c1d9" translate="yes" xml:space="preserve">
          <source>If your system does not support a locale environment, this function behaves like &lt;code&gt;string-equal&lt;/code&gt;.</source>
          <target state="translated">시스템이 로케일 환경을 지원하지 않는 경우이 함수는 &lt;code&gt;string-equal&lt;/code&gt; 처럼 작동 합니다 .</target>
        </trans-unit>
        <trans-unit id="3b2ec9e1ced6426f29862d927943724a180f4f37" translate="yes" xml:space="preserve">
          <source>If your system does not support a locale environment, this function behaves like &lt;code&gt;string-lessp&lt;/code&gt;.</source>
          <target state="translated">시스템이 로케일 환경을 지원하지 않는 경우이 함수는 &lt;code&gt;string-lessp&lt;/code&gt; 처럼 작동 합니다 .</target>
        </trans-unit>
        <trans-unit id="a2a7f8c74638fa05ec98f6bc846b8e0afbd1dcfa" translate="yes" xml:space="preserve">
          <source>If, as a consequence of this variable&amp;rsquo;s setting, &lt;code&gt;split-window&lt;/code&gt; makes a new parent window, it also calls &lt;code&gt;set-window-combination-limit&lt;/code&gt; (see below) on the newly-created internal window. This affects how the window tree is rearranged when the child windows are deleted (see below).</source>
          <target state="translated">이 변수 설정의 결과로 &lt;code&gt;split-window&lt;/code&gt; 가 새 부모 창을 만드는 경우 새로 생성 된 내부 창에서 &lt;code&gt;set-window-combination-limit&lt;/code&gt; (아래 참조) 도 호출합니다 . 이는 자식 창이 삭제 될 때 창 트리가 재 배열되는 방식에 영향을줍니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="451b00a18210e489817e33a2f75ab13a9719ab44" translate="yes" xml:space="preserve">
          <source>If, for instance, you have a function with the following signature:</source>
          <target state="translated">예를 들어 다음과 같은 서명이있는 함수가있는 경우 :</target>
        </trans-unit>
        <trans-unit id="2abf7c3ec223f2095009c55b2f242e5df196b064" translate="yes" xml:space="preserve">
          <source>If, in the configuration shown at the beginning of this section, the combination limit of &lt;var&gt;W4&lt;/var&gt; (the parent window of &lt;var&gt;W6&lt;/var&gt; and &lt;var&gt;W7&lt;/var&gt;) is &lt;code&gt;t&lt;/code&gt;, deleting &lt;var&gt;W5&lt;/var&gt; will not implicitly delete &lt;var&gt;W4&lt;/var&gt; too.</source>
          <target state="translated">이 섹션의 시작 부분에 표시된 구성에서 &lt;var&gt;W4&lt;/var&gt; 의 조합 제한 ( &lt;var&gt;W6&lt;/var&gt; 및 &lt;var&gt;W7&lt;/var&gt; 의 상위 창 )이 &lt;code&gt;t&lt;/code&gt; 인 경우 &lt;var&gt;W5&lt;/var&gt; 를 삭제 해도 &lt;var&gt;W4&lt;/var&gt; 도 암시 적으로 삭제되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="78ffec08f0afea5009a9e4f31e999a7aef7bb8b2" translate="yes" xml:space="preserve">
          <source>Illustrates regular expression syntax.</source>
          <target state="translated">정규식 구문을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="6d6a2e3a1d75ffca319bbe002e550450309d7c59" translate="yes" xml:space="preserve">
          <source>Image Cache</source>
          <target state="translated">이미지 캐시</target>
        </trans-unit>
        <trans-unit id="48b5c8b5116be341240880cddc06c139bf112214" translate="yes" xml:space="preserve">
          <source>Image Descriptors</source>
          <target state="translated">이미지 설명자</target>
        </trans-unit>
        <trans-unit id="c8f6654a5156a1080fb81d03686a08b3810bb836" translate="yes" xml:space="preserve">
          <source>Image Formats</source>
          <target state="translated">이미지 형식</target>
        </trans-unit>
        <trans-unit id="aeaae8093342d2fd0a43876f35175087f3fc1c56" translate="yes" xml:space="preserve">
          <source>Image rotation is supported by &lt;var&gt;frame&lt;/var&gt; if the rotation angle is an integral multiple of 90 degrees.</source>
          <target state="translated">회전 각도가 90 도의 정수 배수 인 경우 이미지 회전이 &lt;var&gt;frame&lt;/var&gt; 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="22a44b07be718b7665f80244ca7dfeffb2cef34a" translate="yes" xml:space="preserve">
          <source>Image scaling is supported by &lt;var&gt;frame&lt;/var&gt; via the &lt;code&gt;:scale&lt;/code&gt;, &lt;code&gt;:width&lt;/code&gt;, &lt;code&gt;:height&lt;/code&gt;, &lt;code&gt;:max-width&lt;/code&gt;, and &lt;code&gt;:max-height&lt;/code&gt; properties.</source>
          <target state="translated">이미지 크기 조정은 &lt;code&gt;:scale&lt;/code&gt; , &lt;code&gt;:width&lt;/code&gt; , &lt;code&gt;:height&lt;/code&gt; , &lt;code&gt;:max-width&lt;/code&gt; 및 &lt;code&gt;:max-height&lt;/code&gt; 속성을 통해 &lt;var&gt;frame&lt;/var&gt; 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="1d1d6e296cb1c073ca88d9a58e07068eb51b05b3" translate="yes" xml:space="preserve">
          <source>Image support on some platforms uses this facility. Here&amp;rsquo;s an example of setting this variable for supporting images on MS-Windows:</source>
          <target state="translated">일부 플랫폼의 이미지 지원은이 기능을 사용합니다. 다음은 MS-Windows에서 이미지를 지원하기 위해이 변수를 설정하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="ba6aa59bf89de0d7431e45a8f58836f3a0d84eff" translate="yes" xml:space="preserve">
          <source>Image type &lt;code&gt;gif&lt;/code&gt;. Supports the &lt;code&gt;:index&lt;/code&gt; property. See &lt;a href=&quot;multi_002dframe-images#Multi_002dFrame-Images&quot;&gt;Multi-Frame Images&lt;/a&gt;.</source>
          <target state="translated">이미지 유형 &lt;code&gt;gif&lt;/code&gt; . &lt;code&gt;:index&lt;/code&gt; 속성을 지원합니다 . &lt;a href=&quot;multi_002dframe-images#Multi_002dFrame-Images&quot;&gt;다중 프레임 이미지를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e6b807cfc6c4926cd04ef1e64755f11a7ed890ee" translate="yes" xml:space="preserve">
          <source>Image type &lt;code&gt;jpeg&lt;/code&gt;.</source>
          <target state="translated">이미지 유형 &lt;code&gt;jpeg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bff299fe7917d8e01d672a807ac7ad596bd1fa0a" translate="yes" xml:space="preserve">
          <source>Image type &lt;code&gt;png&lt;/code&gt;.</source>
          <target state="translated">이미지 유형 &lt;code&gt;png&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d259c4b3f9f796b005c99eb224c7f8328e811db" translate="yes" xml:space="preserve">
          <source>Image type &lt;code&gt;tiff&lt;/code&gt;. Supports the &lt;code&gt;:index&lt;/code&gt; property. See &lt;a href=&quot;multi_002dframe-images#Multi_002dFrame-Images&quot;&gt;Multi-Frame Images&lt;/a&gt;.</source>
          <target state="translated">이미지 유형 &lt;code&gt;tiff&lt;/code&gt; . &lt;code&gt;:index&lt;/code&gt; 속성을 지원합니다 . &lt;a href=&quot;multi_002dframe-images#Multi_002dFrame-Images&quot;&gt;다중 프레임 이미지를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f82696e58684223314f34c1e138cf5a09eed1ec1" translate="yes" xml:space="preserve">
          <source>ImageMagick Images</source>
          <target state="translated">ImageMagick 이미지</target>
        </trans-unit>
        <trans-unit id="09e871c98fef3b901a775def173e4126aaf73b42" translate="yes" xml:space="preserve">
          <source>Images</source>
          <target state="translated">Images</target>
        </trans-unit>
        <trans-unit id="b10522704faf5fb14671202d20d0113707920769" translate="yes" xml:space="preserve">
          <source>Images are automatically scaled when created based on the &lt;code&gt;image-scaling-factor&lt;/code&gt; variable. The value is either a floating point number (where numbers higher than 1 means to increase the size and lower means to shrink the size), or the symbol &lt;code&gt;auto&lt;/code&gt;, which will compute a scaling factor based on the font pixel size.</source>
          <target state="translated">이미지 &lt;code&gt;image-scaling-factor&lt;/code&gt; 변수를 기반으로 생성 될 때 이미지의 배율이 자동으로 조정됩니다 . 값은 부동 소수점 숫자 (1보다 큰 숫자는 크기 증가를 의미하고 작은 숫자는 크기를 축소 함을 의미) 또는 기호 &lt;code&gt;auto&lt;/code&gt; 이며 글꼴 픽셀 크기에 따라 배율을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="bffbf50340be5bd8849e7bdae58afca1242ae52f" translate="yes" xml:space="preserve">
          <source>Images inserted with the insertion functions above also get a local keymap installed in the text properties (or overlays) that span the displayed image. This keymap defines the following commands:</source>
          <target state="translated">위의 삽입 기능을 사용하여 삽입 된 이미지는 표시된 이미지에 걸쳐있는 텍스트 속성 (또는 오버레이)에 설치된 로컬 키맵도 가져옵니다. 이 키맵은 다음 명령을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="2577d1937dba79f175ee8cc8dd563700f7a20a83" translate="yes" xml:space="preserve">
          <source>Images loaded with ImageMagick support the following additional image descriptor properties:</source>
          <target state="translated">ImageMagick으로로드 된 이미지는 다음과 같은 추가 이미지 설명자 속성을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="ae0df5967aaeb367560d887978e6697e8445e507" translate="yes" xml:space="preserve">
          <source>Images, margins, text size, etc.</source>
          <target state="translated">이미지, 여백, 텍스트 크기 등</target>
        </trans-unit>
        <trans-unit id="582d79238d4c996206b1d9fcda2bd858616fc5e0" translate="yes" xml:space="preserve">
          <source>Imenu</source>
          <target state="translated">Imenu</target>
        </trans-unit>
        <trans-unit id="9b3ebff6f4733ad352d5af8ef98a92252e56d9f9" translate="yes" xml:space="preserve">
          <source>Implementing a link involves three separate steps: (1) indicating clickability when the mouse moves over the link; (2) making</source>
          <target state="translated">링크를 구현하는 데는 다음 세 단계가 포함됩니다. (1) 링크 위로 마우스를 이동할 때 클릭 가능성을 나타냅니다. (2) 만들기</target>
        </trans-unit>
        <trans-unit id="ba709de5d7a6443728b0e7d903b67e7e463a3df8" translate="yes" xml:space="preserve">
          <source>Implied Frame Resizing</source>
          <target state="translated">묵시적 프레임 크기 조정</target>
        </trans-unit>
        <trans-unit id="6be920774eab706a9a6e9e109fe21af9fbbf76a5" translate="yes" xml:space="preserve">
          <source>Implied resizing of frames and how to prevent it.</source>
          <target state="translated">묵시적 프레임 크기 조정 및 방지 방법.</target>
        </trans-unit>
        <trans-unit id="aef36502d67b0520654deb764dd055a7e905cfdd" translate="yes" xml:space="preserve">
          <source>In</source>
          <target state="translated">In</target>
        </trans-unit>
        <trans-unit id="8fe04c542be958393c3da42ee6384a7d0cac600e" translate="yes" xml:space="preserve">
          <source>In Adaptive Fill mode, this command calls &lt;code&gt;fill-context-prefix&lt;/code&gt; to choose a fill prefix by default. See &lt;a href=&quot;adaptive-fill#Adaptive-Fill&quot;&gt;Adaptive Fill&lt;/a&gt;.</source>
          <target state="translated">적응 형 채우기 모드에서이 명령은 &lt;code&gt;fill-context-prefix&lt;/code&gt; 를 호출 하여 기본적으로 채우기 접두사를 선택합니다. &lt;a href=&quot;adaptive-fill#Adaptive-Fill&quot;&gt;적응 형 채우기를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="45a0c5d90449be73929ea5cf30f6e7c34dd2845f" translate="yes" xml:space="preserve">
          <source>In C the corresponding code uses &lt;code&gt;Fmake_variable_buffer_local&lt;/code&gt; in combination with &lt;code&gt;DEFSYM&lt;/code&gt;, i.e.</source>
          <target state="translated">C에 대응하는 코드를 사용 &lt;code&gt;Fmake_variable_buffer_local&lt;/code&gt; 을 조합하여 &lt;code&gt;DEFSYM&lt;/code&gt; 즉</target>
        </trans-unit>
        <trans-unit id="e18ad52ed484e26dd1d95b7bed4a6e310f733e51" translate="yes" xml:space="preserve">
          <source>In C, the tagged pointer is an object of type &lt;code&gt;Lisp_Object&lt;/code&gt;. Any initialized variable of such a type always holds the value of one of the following basic data types: integer, symbol, string, cons cell, float, or vectorlike object. Each of these data types has the corresponding tag value. All tags are enumerated by &lt;code&gt;enum Lisp_Type&lt;/code&gt; and placed into a 3-bit bitfield of the &lt;code&gt;Lisp_Object&lt;/code&gt;. The rest of the bits is the value itself. Integers are immediate, i.e., directly represented by those &lt;em&gt;value bits&lt;/em&gt;, and all other objects are represented by the C pointers to a corresponding object allocated from the heap. Width of the &lt;code&gt;Lisp_Object&lt;/code&gt; is platform- and configuration-dependent: usually it&amp;rsquo;s equal to the width of an underlying platform pointer (i.e., 32-bit on a 32-bit machine and 64-bit on a 64-bit one), but also there is a special configuration where &lt;code&gt;Lisp_Object&lt;/code&gt; is 64-bit but all pointers are 32-bit. The latter trick was designed to overcome the limited range of values for Lisp integers on a 32-bit system by using 64-bit &lt;code&gt;long long&lt;/code&gt; type for &lt;code&gt;Lisp_Object&lt;/code&gt;.</source>
          <target state="translated">C에서 태그가 지정된 포인터는 &lt;code&gt;Lisp_Object&lt;/code&gt; 유형의 개체입니다 . 이러한 유형의 초기화 된 변수는 항상 정수, 기호, 문자열, 단점 셀, 부동 소수점 또는 벡터 류 객체와 같은 기본 데이터 유형 중 하나의 값을 보유합니다. 이러한 각 데이터 유형에는 해당 태그 값이 있습니다. 모든 태그에 의해 열거 &lt;code&gt;enum Lisp_Type&lt;/code&gt; 과의 3 비트의 비트 필드에 배치 &lt;code&gt;Lisp_Object&lt;/code&gt; . 나머지 비트는 값 자체입니다. 정수는 즉치 즉, 해당 &lt;em&gt;값 비트로&lt;/em&gt; 직접 표현되며 다른 모든 객체는 힙에서 할당 된 해당 객체에 대한 C 포인터로 표현됩니다. &lt;code&gt;Lisp_Object&lt;/code&gt; 의 너비플랫폼 및 구성에 따라 다릅니다. 일반적으로 기본 플랫폼 포인터의 너비 (예 : 32 비트 시스템의 경우 32 비트, 64 비트 시스템의 경우 64 비트)와 같지만 특수한 구성도 있습니다. 여기서 &lt;code&gt;Lisp_Object&lt;/code&gt; 는 64 비트이지만 모든 포인터는 32 비트입니다. 후자의 트릭은 &lt;code&gt;Lisp_Object&lt;/code&gt; 에 64 비트 &lt;code&gt;long long&lt;/code&gt; 유형을 사용하여 32 비트 시스템에서 Lisp 정수의 제한된 범위 값을 극복하도록 설계되었습니다 .</target>
        </trans-unit>
        <trans-unit id="74391ea991c057a25805bcc7f35913579f56dca9" translate="yes" xml:space="preserve">
          <source>In Emacs Lisp, &lt;code&gt;nil&lt;/code&gt; and &lt;code&gt;t&lt;/code&gt; are special symbols that always evaluate to themselves. This is so that you do not need to quote them to use them as constants in a program. An attempt to change their values results in a &lt;code&gt;setting-constant&lt;/code&gt; error. See &lt;a href=&quot;constant-variables#Constant-Variables&quot;&gt;Constant Variables&lt;/a&gt;.</source>
          <target state="translated">Emacs Lisp에서 &lt;code&gt;nil&lt;/code&gt; 과 &lt;code&gt;t&lt;/code&gt; 는 항상 자신을 평가하는 특수 기호입니다. 따라서 프로그램에서 상수로 사용하기 위해 인용 할 필요가 없습니다. 값을 변경하려고하면 &lt;code&gt;setting-constant&lt;/code&gt; 오류가 발생합니다. &lt;a href=&quot;constant-variables#Constant-Variables&quot;&gt;상수 변수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7ad4e15232bab0e5d73751f02a46989f735b0d79" translate="yes" xml:space="preserve">
          <source>In Emacs Lisp, an obarray is actually a vector. Each element of the vector is a bucket; its value is either an interned symbol whose name hashes to that bucket, or 0 if the bucket is empty. Each interned symbol has an internal link (invisible to the user) to the next symbol in the bucket. Because these links are invisible, there is no way to find all the symbols in an obarray except using &lt;code&gt;mapatoms&lt;/code&gt; (below). The order of symbols in a bucket is not significant.</source>
          <target state="translated">Emacs Lisp에서 오바 레이는 실제로 벡터입니다. 벡터의 각 요소는 버킷입니다. 값은 이름이 해당 버킷으로 해시되는 인턴 심볼이거나 버킷이 비어있는 경우 0입니다. 인턴 된 각 심볼에는 버킷의 다음 심볼에 대한 내부 링크 (사용자에게 표시되지 않음)가 있습니다. 이러한 링크는 보이지 않기 때문에 &lt;code&gt;mapatoms&lt;/code&gt; (아래)을 사용하는 것 외에는 오바 레이의 모든 기호를 찾을 수있는 방법이 없습니다 . 버킷의 기호 순서는 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="167a75f8cc60d70b238473b34e2d15e825f2b4a7" translate="yes" xml:space="preserve">
          <source>In Emacs Lisp, certain symbols normally evaluate to themselves. These include &lt;code&gt;nil&lt;/code&gt; and &lt;code&gt;t&lt;/code&gt;, as well as any symbol whose name starts with &amp;lsquo;</source>
          <target state="translated">Emacs Lisp에서 특정 기호는 일반적으로 자체적으로 평가됩니다. 여기에는 &lt;code&gt;nil&lt;/code&gt; 및 &lt;code&gt;t&lt;/code&gt; 뿐만 아니라 이름이 '로 시작하는 모든 기호가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d3d82148ca2384cc8ee1ed3664e9a838b9558bde" translate="yes" xml:space="preserve">
          <source>In Emacs Lisp, fonts are represented using three different Lisp object types: &lt;em&gt;font objects&lt;/em&gt;, &lt;em&gt;font specs&lt;/em&gt;, and &lt;em&gt;font entities&lt;/em&gt;.</source>
          <target state="translated">Emacs Lisp에서 글꼴은 &lt;em&gt;글꼴 객체&lt;/em&gt; , &lt;em&gt;글꼴 사양&lt;/em&gt; 및 &lt;em&gt;글꼴 엔티티의&lt;/em&gt; 세 가지 Lisp 객체 유형을 사용하여 표현 &lt;em&gt;됩니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ce0c7667a4c5fb417ea75b3519174ba5e3b8596c" translate="yes" xml:space="preserve">
          <source>In Emacs Lisp, if two fixnums are numerically equal, they are the same Lisp object. That is, &lt;code&gt;eq&lt;/code&gt; is equivalent to &lt;code&gt;=&lt;/code&gt; on fixnums. It is sometimes convenient to use &lt;code&gt;eq&lt;/code&gt; for comparing an unknown value with a fixnum, because &lt;code&gt;eq&lt;/code&gt; does not report an error if the unknown value is not a number&amp;mdash;it accepts arguments of any type. By contrast, &lt;code&gt;=&lt;/code&gt; signals an error if the arguments are not numbers or markers. However, it is better programming practice to use &lt;code&gt;=&lt;/code&gt; if you can, even for comparing integers.</source>
          <target state="translated">Emacs Lisp에서 두 고정 번호가 수치 적으로 동일하면 동일한 Lisp 객체입니다. 즉, &lt;code&gt;eq&lt;/code&gt; 는 fixnums의 &lt;code&gt;=&lt;/code&gt; 와 같습니다. 알 수없는 값이 숫자가 아닌 경우 &lt;code&gt;eq&lt;/code&gt; 는 오류를보고하지 않고 모든 유형의 인수를 허용 하므로 알 수없는 값을 fixnum과 비교하는 데 &lt;code&gt;eq&lt;/code&gt; 를 사용하는 것이 편리한 경우가 있습니다. 반대로 &lt;code&gt;=&lt;/code&gt; 는 인수가 숫자 나 마커가 아닌 경우 오류를 나타냅니다. 그러나 정수를 비교하는 경우에도 가능하면 &lt;code&gt;=&lt;/code&gt; 를 사용하는 것이 더 나은 프로그래밍 관행 입니다.</target>
        </trans-unit>
        <trans-unit id="056b909cc3695df5e93a61166399585cdef0425e" translate="yes" xml:space="preserve">
          <source>In Emacs Lisp, it is &lt;em&gt;not&lt;/em&gt; an error if an element of an association list is not a cons cell. The alist search functions simply ignore such elements. Many other versions of Lisp signal errors in such cases.</source>
          <target state="translated">이맥스 리스프에서는하다 &lt;em&gt;하지&lt;/em&gt; 연관리스트의 요소가 반대 셀 있지 않으면 오류. 목록 검색 기능은 단순히 이러한 요소를 무시합니다. 이러한 경우 다른 많은 버전의 Lisp 신호 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0ba583440567b18d5b81ae15d30046dcd5919135" translate="yes" xml:space="preserve">
          <source>In Emacs Lisp, such a list is a valid expression which evaluates to a function object.</source>
          <target state="translated">Emacs Lisp에서 이러한 목록은 함수 객체로 평가되는 유효한 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="79e9cb90d8f1ed44a5daae3726bf1118952bd6eb" translate="yes" xml:space="preserve">
          <source>In Emacs Lisp, text characters are represented by integers. Any integer between zero and the value of &lt;code&gt;(max-char)&lt;/code&gt;, inclusive, is considered to be valid as a character. See &lt;a href=&quot;character-codes#Character-Codes&quot;&gt;Character Codes&lt;/a&gt;.</source>
          <target state="translated">Emacs Lisp에서 텍스트 문자는 정수로 표시됩니다. 0과 &lt;code&gt;(max-char)&lt;/code&gt; 값 ( 포함 ) 사이의 모든 정수 는 문자로 유효한 것으로 간주됩니다. &lt;a href=&quot;character-codes#Character-Codes&quot;&gt;문자 코드를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dc557095ff4ddb838d7231fc59eb5902f756d5f5" translate="yes" xml:space="preserve">
          <source>In Emacs Lisp, the symbol &lt;code&gt;nil&lt;/code&gt; has three separate meanings: it is a symbol with the name &amp;lsquo;</source>
          <target state="translated">Emacs Lisp에서 &lt;code&gt;nil&lt;/code&gt; 기호 는 세 가지 별도의 의미를 갖습니다. 이름이 '</target>
        </trans-unit>
        <trans-unit id="4bdd0ad62ddb48a82f579e9d7b8435a64c33dc3b" translate="yes" xml:space="preserve">
          <source>In Emacs&amp;rsquo;s current implementation, each graphical terminal possesses an image cache, which is shared by all the frames on that terminal (see &lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;Multiple Terminals&lt;/a&gt;). Thus, refreshing an image in one frame also refreshes it in all other frames on the same terminal.</source>
          <target state="translated">Emacs의 현재 구현에서 각 그래픽 터미널은 해당 터미널의 모든 프레임에서 공유하는 이미지 캐시를 보유합니다 ( &lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;다중 터미널&lt;/a&gt; 참조 ). 따라서 한 프레임의 이미지를 새로 고치면 동일한 터미널의 다른 모든 프레임에서도 새로 고쳐집니다.</target>
        </trans-unit>
        <trans-unit id="2cfd6914c188d4937ed552a12d7ad4fd0e04dbfb" translate="yes" xml:space="preserve">
          <source>In Emacs, each property has a name, which is a symbol, and a set of possible values, whose types depend on the property; if a character does not have a certain property, the value is &lt;code&gt;nil&lt;/code&gt;. As a general rule, the names of character properties in Emacs are produced from the corresponding Unicode properties by downcasing them and replacing each &amp;lsquo;</source>
          <target state="translated">Emacs에서 각 속성에는 기호 인 이름과 속성에 따라 유형이 달라지는 가능한 값 집합이 있습니다. 문자에 특정 속성이 없으면 값은 &lt;code&gt;nil&lt;/code&gt; 입니다. 일반적으로 Emacs의 문자 속성 이름은 해당 유니 코드 속성을 다운 케이싱하고 각 '</target>
        </trans-unit>
        <trans-unit id="30d7d9e3884c83ac05ed06549fc0bda540ce471f" translate="yes" xml:space="preserve">
          <source>In Emacs, processing user input takes priority over redisplay. If you call these functions when input is available, they don&amp;rsquo;t redisplay immediately, but the requested redisplay does happen eventually&amp;mdash;after all the input has been processed.</source>
          <target state="translated">Emacs에서는 사용자 입력 처리가 재 표시보다 우선합니다. 입력을 사용할 수있을 때 이러한 함수를 호출하면 즉시 다시 표시되지 않지만 요청 된 다시 표시는 결국 모든 입력이 처리 된 후 발생합니다.</target>
        </trans-unit>
        <trans-unit id="495b0af8742c1362f3b43e3c05d5f67cbd311b61" translate="yes" xml:space="preserve">
          <source>In GNU Emacs, you can search for the next match for a regular expression (see &lt;a href=&quot;syntax-of-regexps#Syntax-of-Regexps&quot;&gt;Syntax of Regexps&lt;/a&gt;) either incrementally or not. For incremental search commands, see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Regexp-Search.html#Regexp-Search&quot;&gt;Regular Expression Search&lt;/a&gt; in</source>
          <target state="translated">GNU Emacs에서 정규식에 대한 다음 일치 항목을 점진적으로 검색 할 수 있습니다 ( &lt;a href=&quot;syntax-of-regexps#Syntax-of-Regexps&quot;&gt;Regexps 구문&lt;/a&gt; 참조 ). 증분 검색 명령은 다음에서 &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Regexp-Search.html#Regexp-Search&quot;&gt;정규식 검색&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bb6bf702e875e738b66a4d81962fcc97a8fc8a9b" translate="yes" xml:space="preserve">
          <source>In Lisp symbols sometimes need to be quoted, to achieve the same effect in C you again use the corresponding constant symbol &lt;code&gt;Qmy_lisp_variable&lt;/code&gt;. For example, when creating a buffer-local variable (see &lt;a href=&quot;buffer_002dlocal-variables#Buffer_002dLocal-Variables&quot;&gt;Buffer-Local Variables&lt;/a&gt;) in Lisp you would write:</source>
          <target state="translated">Lisp에서 기호를 인용해야하는 경우도 있습니다. C에서 동일한 효과를 얻으려면 해당 상수 기호 &lt;code&gt;Qmy_lisp_variable&lt;/code&gt; 을 다시 사용하십시오 . 예를 들어 Lisp에서 &lt;a href=&quot;buffer_002dlocal-variables#Buffer_002dLocal-Variables&quot;&gt;버퍼&lt;/a&gt; 로컬 변수 ( Buffer-Local 변수 참조)를 만들 때 다음과 같이 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="1a54f569b2a1104466db435e6a994296e8a10203" translate="yes" xml:space="preserve">
          <source>In POSIX, locales control which language to use in language-related features. These Emacs variables control how Emacs interacts with these features.</source>
          <target state="translated">POSIX에서 로케일은 언어 관련 기능에서 사용할 언어를 제어합니다. 이 Emacs 변수는 Emacs가 이러한 기능과 상호 작용하는 방식을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="cb60a2c08b3d7d91de1154d61b87b4cbb7d768d9" translate="yes" xml:space="preserve">
          <source>In a Lisp program, if you want to look at the contents of a file but not alter it, the fastest way is to use &lt;code&gt;insert-file-contents&lt;/code&gt; in a temporary buffer. Visiting the file is not necessary and takes longer. See &lt;a href=&quot;reading-from-files#Reading-from-Files&quot;&gt;Reading from Files&lt;/a&gt;.</source>
          <target state="translated">Lisp 프로그램에서 파일의 내용을보고 싶지만 변경하지 않으려는 경우 가장 빠른 방법은 임시 버퍼에서 &lt;code&gt;insert-file-contents&lt;/code&gt; 을 사용 하는 것입니다. 파일을 방문 할 필요가 없으며 더 오래 걸립니다. &lt;a href=&quot;reading-from-files#Reading-from-Files&quot;&gt;파일에서 읽기를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1edf8916db656c7d77716fc20e2c864d77eff0a1" translate="yes" xml:space="preserve">
          <source>In a backtrace you can specify a stack frame by moving point to a line describing that frame. The frame whose line point is on is considered the &lt;em&gt;current frame&lt;/em&gt;.</source>
          <target state="translated">역 추적에서 해당 프레임을 설명하는 선으로 포인트를 이동하여 스택 프레임을 지정할 수 있습니다. 선점이있는 프레임이 &lt;em&gt;현재 프레임으로&lt;/em&gt; 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="d321617bc2957edda9f7299aaed744d6b62dfa9f" translate="yes" xml:space="preserve">
          <source>In a buffer, the buffer-local value of the variable &lt;code&gt;enable-multibyte-characters&lt;/code&gt; specifies the representation used. The representation for a string is determined and recorded in the string when the string is constructed.</source>
          <target state="translated">버퍼에서 &lt;code&gt;enable-multibyte-characters&lt;/code&gt; 변수의 로컬 버퍼 값 은 사용되는 표현을 지정합니다. 문자열에 대한 표현은 문자열이 구성 될 때 결정되고 문자열에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="d5b3c2f60eb9de03c344c19458f75ded0f988032" translate="yes" xml:space="preserve">
          <source>In a computer, an integer is represented as a binary number, a sequence of &lt;em&gt;bits&lt;/em&gt; (digits which are either zero or one). Conceptually the bit sequence is infinite on the left, with the most-significant bits being all zeros or all ones. A bitwise operation acts on the individual bits of such a sequence. For example, &lt;em&gt;shifting&lt;/em&gt; moves the whole sequence left or right one or more places, reproducing the same pattern moved over.</source>
          <target state="translated">컴퓨터에서 정수는 이진수, 즉 일련의 &lt;em&gt;비트&lt;/em&gt; (0 또는 1 인 숫자)로 표시됩니다. 개념적으로 비트 시퀀스는 왼쪽에서 무한하며 최상위 비트는 모두 0 또는 모두 1입니다. 비트 연산은 이러한 시퀀스의 개별 비트에 대해 작동합니다. 예를 들어, &lt;em&gt;이동&lt;/em&gt; 움직임은 전체 시퀀스 좌우 한 동일한 패턴을 재생 많은 장소는 옮겼다.</target>
        </trans-unit>
        <trans-unit id="fb58dc1bd5b5a462384b2bd580dc601ea418376c" translate="yes" xml:space="preserve">
          <source>In a connection, the address in internal format of the remote peer.</source>
          <target state="translated">연결에서 원격 피어의 내부 형식 주소입니다.</target>
        </trans-unit>
        <trans-unit id="937afbfd1c954fb42bb11db790d91eaf0406154d" translate="yes" xml:space="preserve">
          <source>In a customization of &lt;code&gt;display-buffer-alist&lt;/code&gt; it would be used as follows:</source>
          <target state="translated">&lt;code&gt;display-buffer-alist&lt;/code&gt; 의 사용자 정의에서 다음과 같이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="02df984c3529f76c9a4015001b01d209da05e6aa" translate="yes" xml:space="preserve">
          <source>In a function definition (a &lt;code&gt;lambda&lt;/code&gt; or &lt;code&gt;defun&lt;/code&gt; form), the documentation string is specified after the argument list, and is normally stored directly in the function object. See &lt;a href=&quot;function-documentation#Function-Documentation&quot;&gt;Function Documentation&lt;/a&gt;. You can also put function documentation in the &lt;code&gt;function-documentation&lt;/code&gt; property of a function name (see &lt;a href=&quot;accessing-documentation#Accessing-Documentation&quot;&gt;Accessing Documentation&lt;/a&gt;).</source>
          <target state="translated">함수 정의 ( &lt;code&gt;lambda&lt;/code&gt; 또는 &lt;code&gt;defun&lt;/code&gt; 형식)에서 설명서 문자열은 인수 목록 뒤에 지정되며 일반적으로 함수 객체에 직접 저장됩니다. &lt;a href=&quot;function-documentation#Function-Documentation&quot;&gt;함수 문서를&lt;/a&gt; 참조하십시오 . 함수 이름 의 &lt;code&gt;function-documentation&lt;/code&gt; 속성에 함수 문서를 넣을 수도 있습니다 ( &lt;a href=&quot;accessing-documentation#Accessing-Documentation&quot;&gt;문서 액세스&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="9eea6a2ed4dafd38340b45092920794b871b7be2" translate="yes" xml:space="preserve">
          <source>In a function description, the name of the function being described appears first. It is followed on the same line by a list of argument names. These names are also used in the body of the description, to stand for the values of the arguments.</source>
          <target state="translated">함수 설명에서 설명중인 함수의 이름이 먼저 나타납니다. 같은 줄에 인수 이름 목록이 이어집니다. 이러한 이름은 인수 값을 나타 내기 위해 설명 본문에서도 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f265fc98d3924e1abaf704d23613cfbac37962c6" translate="yes" xml:space="preserve">
          <source>In a general sense, a function is a rule for carrying out a computation given input values called &lt;em&gt;arguments&lt;/em&gt;. The result of the computation is called the &lt;em&gt;value&lt;/em&gt; or &lt;em&gt;return value&lt;/em&gt; of the function. The computation can also have side effects, such as lasting changes in the values of variables or the contents of data structures (see &lt;a href=&quot;intro-eval#Definition-of-side-effect&quot;&gt;Definition of side effect&lt;/a&gt;). A &lt;em&gt;pure function&lt;/em&gt; is a function which, in addition to having no side effects, always returns the same value for the same combination of arguments, regardless of external factors such as machine type or system state.</source>
          <target state="translated">일반적으로 함수는 &lt;em&gt;arguments&lt;/em&gt; 라는 입력 값이 주어지면 계산을 수행하는 규칙입니다 . 계산 결과를 함수 의 &lt;em&gt;값&lt;/em&gt; 또는 &lt;em&gt;반환 값&lt;/em&gt; 이라고합니다 . 계산은 변수 값이나 데이터 구조 내용의 지속적인 변경과 같은 부작용도 가질 수 있습니다 (부작용 &lt;a href=&quot;intro-eval#Definition-of-side-effect&quot;&gt;정의&lt;/a&gt; 참조 ). &lt;em&gt;순수 함수&lt;/em&gt; 부작용을 갖지 않는 이외에, 관계없이 항상 같은 형태 나 컴퓨터 시스템 상태 등의 외부 요인 인자 같은 조합에 대해 동일한 값을 반환하는 함수이다.</target>
        </trans-unit>
        <trans-unit id="96c3f228f301c5161e3eb0673e109763dc8f02e1" translate="yes" xml:space="preserve">
          <source>In a major mode for editing some kind of structured text, such as a programming language, indentation of text according to structure is probably useful. So the mode should set &lt;code&gt;indent-line-function&lt;/code&gt; to a suitable function, and probably customize other variables for indentation. See &lt;a href=&quot;auto_002dindentation#Auto_002dIndentation&quot;&gt;Auto-Indentation&lt;/a&gt;.</source>
          <target state="translated">프로그래밍 언어와 같은 구조화 된 텍스트를 편집하는 주요 모드에서는 구조에 따른 텍스트 들여 쓰기가 유용 할 것입니다. 따라서 모드는 &lt;code&gt;indent-line-function&lt;/code&gt; 을 적절한 함수로 설정하고 아마도 들여 쓰기를 위해 다른 변수를 사용자 정의해야합니다. &lt;a href=&quot;auto_002dindentation#Auto_002dIndentation&quot;&gt;자동 들여 쓰기를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1010cadba3e3eb9ca7bca39cbf0064b7fa6a1d87" translate="yes" xml:space="preserve">
          <source>In a package that can be preloaded, it is sometimes necessary (or useful) to delay certain evaluations until Emacs subsequently starts up. The vast majority of such cases relate to the values of customizable variables. For example, &lt;code&gt;tutorial-directory&lt;/code&gt; is a variable defined in</source>
          <target state="translated">미리로드 할 수있는 패키지에서 Emacs가 나중에 시작될 때까지 특정 평가를 지연하는 것이 때때로 필요 (또는 유용)합니다. 이러한 경우의 대부분은 사용자 정의 가능한 변수의 값과 관련이 있습니다. 예를 들어 &lt;code&gt;tutorial-directory&lt;/code&gt; 는 다음에 정의 된 변수입니다.</target>
        </trans-unit>
        <trans-unit id="0c9ab0563187085f470a4162ca64c920ef8f3780" translate="yes" xml:space="preserve">
          <source>In a server, if you specified &lt;code&gt;t&lt;/code&gt; for &lt;var&gt;service&lt;/var&gt;, this value is the actual port number.</source>
          <target state="translated">서버에서 &lt;var&gt;service&lt;/var&gt; 에 &lt;code&gt;t&lt;/code&gt; 를 지정한 경우이 값은 실제 포트 번호입니다.</target>
        </trans-unit>
        <trans-unit id="38330f228367727c246a23aacc922e71762f491b" translate="yes" xml:space="preserve">
          <source>In a string, the 2**7 bit attached to an</source>
          <target state="translated">문자열에서 2 ** 7 비트는</target>
        </trans-unit>
        <trans-unit id="cb764f5b1cd69acb27303028c22d0c8d6831d1ea" translate="yes" xml:space="preserve">
          <source>In a variable definition (a &lt;code&gt;defvar&lt;/code&gt; form), the documentation string is specified after the initial value. See &lt;a href=&quot;defining-variables#Defining-Variables&quot;&gt;Defining Variables&lt;/a&gt;. The string is stored in the variable&amp;rsquo;s &lt;code&gt;variable-documentation&lt;/code&gt; property.</source>
          <target state="translated">변수 정의 ( &lt;code&gt;defvar&lt;/code&gt; 형식)에서 문서 문자열은 초기 값 뒤에 지정됩니다. &lt;a href=&quot;defining-variables#Defining-Variables&quot;&gt;변수 정의를&lt;/a&gt; 참조하십시오 . 문자열은 변수의 &lt;code&gt;variable-documentation&lt;/code&gt; 속성에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="529ec901908473f00f0f48571f9c0e29f851ad5f" translate="yes" xml:space="preserve">
          <source>In addition an optional &lt;var&gt;coding-system&lt;/var&gt; can be specified if needed.</source>
          <target state="translated">또한 필요한 경우 선택적 &lt;var&gt;coding-system&lt;/var&gt; 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="525f83380ee1265a6947c7040c2a3e7d21c25884" translate="yes" xml:space="preserve">
          <source>In addition to accessing and manipulating processes that are subprocesses of the current Emacs session, Emacs Lisp programs can also access other processes running on the same machine. We call these &lt;em&gt;system processes&lt;/em&gt;, to distinguish them from Emacs subprocesses.</source>
          <target state="translated">현재 Emacs 세션의 하위 프로세스 인 프로세스에 액세스하고 조작하는 것 외에도 Emacs Lisp 프로그램은 동일한 시스템에서 실행중인 다른 프로세스에도 액세스 할 수 있습니다. 우리는이 &lt;em&gt;시스템 프로세스&lt;/em&gt; 를 Emacs 하위 프로세스와 구별하기 위해 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="7bdb7f13163d532b7e614f0668a6458aa5f29adb" translate="yes" xml:space="preserve">
          <source>In addition to its parents, the error symbol has a &lt;var&gt;message&lt;/var&gt; which is a string to be printed when that error is signaled but not handled. If that message is not valid, the error message &amp;lsquo;</source>
          <target state="translated">부모 외에도 오류 기호에는 오류가 신호를 받았지만 처리되지 않을 때 인쇄 할 문자열 인 &lt;var&gt;message&lt;/var&gt; 가 있습니다. 해당 메시지가 유효하지 않으면 오류 메시지 '</target>
        </trans-unit>
        <trans-unit id="c353f4ffe1e4f69045cda4cc05340d97bd69840b" translate="yes" xml:space="preserve">
          <source>In addition to operating on files themselves, Emacs Lisp programs often need to operate on file names; i.e., to take them apart and to use part of a name to construct related file names. This section describes how to manipulate file names.</source>
          <target state="translated">파일 자체에서 작동하는 것 외에도 Emacs Lisp 프로그램은 종종 파일 이름으로 작동해야합니다. 즉, 그것들을 분리하고 이름의 일부를 사용하여 관련 파일 이름을 구성합니다. 이 섹션에서는 파일 이름을 조작하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="387b3f59848f82250f4a8ce567df30121ef1d27b" translate="yes" xml:space="preserve">
          <source>In addition to processes that run programs, Lisp programs can open connections of several types to devices or processes running on the same machine or on other machines. The supported connection types are: TCP and UDP network connections, serial port connections, and pipe connections. Each such connection is also represented by a process object.</source>
          <target state="translated">프로그램을 실행하는 프로세스 외에도 Lisp 프로그램은 동일한 시스템 또는 다른 시스템에서 실행되는 장치 또는 프로세스에 대한 여러 유형의 연결을 열 수 있습니다. 지원되는 연결 유형은 TCP 및 UDP 네트워크 연결, 직렬 포트 연결 및 파이프 연결입니다. 이러한 각 연결은 프로세스 개체로도 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="3c5b86e3b4354c4c1fa9c08ccbf5b49528a15320" translate="yes" xml:space="preserve">
          <source>In addition to specifying a single codepoint, &lt;var&gt;character&lt;/var&gt; may be a cons &lt;code&gt;(&lt;var&gt;from&lt;/var&gt; . &lt;var&gt;to&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;from&lt;/var&gt; and &lt;var&gt;to&lt;/var&gt; are character codepoints. In that case, use &lt;var&gt;font-spec&lt;/var&gt; for all the characters in the range &lt;var&gt;from&lt;/var&gt; and &lt;var&gt;to&lt;/var&gt; (inclusive).</source>
          <target state="translated">단일 코드 포인트를 지정하는 것 외에도 &lt;var&gt;character&lt;/var&gt; 는 cons &lt;code&gt;(&lt;var&gt;from&lt;/var&gt; . &lt;var&gt;to&lt;/var&gt;)&lt;/code&gt; 일 수 있습니다 . 여기서 &lt;var&gt;from&lt;/var&gt; 및 &lt;var&gt;to&lt;/var&gt; 는 문자 코드 포인트입니다. 이 경우 &lt;var&gt;from&lt;/var&gt; 및 &lt;var&gt;to&lt;/var&gt; (포함) 범위의 모든 문자에 대해 &lt;var&gt;font-spec&lt;/var&gt; 을 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="41d3cfcccd9ef5616b8769d3619cf8d518b74e63" translate="yes" xml:space="preserve">
          <source>In addition to subprocesses of the current Emacs session, you can also access other processes running on your machine. See &lt;a href=&quot;system-processes#System-Processes&quot;&gt;System Processes&lt;/a&gt;.</source>
          <target state="translated">현재 Emacs 세션의 하위 프로세스 외에도 컴퓨터에서 실행중인 다른 프로세스에 액세스 할 수 있습니다. &lt;a href=&quot;system-processes#System-Processes&quot;&gt;시스템 프로세스를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a7064fdb6b5bca7cd74df3a9cfd9570247d7d390" translate="yes" xml:space="preserve">
          <source>In addition to the above, 24 additional compositions of &lt;code&gt;car&lt;/code&gt; and &lt;code&gt;cdr&lt;/code&gt; are defined as &lt;code&gt;c&lt;var&gt;xxx&lt;/var&gt;r&lt;/code&gt; and &lt;code&gt;c&lt;var&gt;xxxx&lt;/var&gt;r&lt;/code&gt;, where each &lt;code&gt;&lt;var&gt;x&lt;/var&gt;&lt;/code&gt; is either &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;d&lt;/code&gt;. &lt;code&gt;cadr&lt;/code&gt;, &lt;code&gt;caddr&lt;/code&gt;, and &lt;code&gt;cadddr&lt;/code&gt; pick out the second, third or fourth elements of a list, respectively.</source>
          <target state="translated">위의 것 외에도 &lt;code&gt;car&lt;/code&gt; 및 &lt;code&gt;cdr&lt;/code&gt; 의 24 개의 추가 구성은 &lt;code&gt;c&lt;var&gt;xxx&lt;/var&gt;r&lt;/code&gt; 및 &lt;code&gt;c&lt;var&gt;xxxx&lt;/var&gt;r&lt;/code&gt; 로 정의되며 , 여기서 각 &lt;code&gt;&lt;var&gt;x&lt;/var&gt;&lt;/code&gt; 는 &lt;code&gt;a&lt;/code&gt; 또는 &lt;code&gt;d&lt;/code&gt; 입니다. &lt;code&gt;cadr&lt;/code&gt; , &lt;code&gt;caddr&lt;/code&gt; 및 &lt;code&gt;cadddr&lt;/code&gt; 은 각각 목록의 두 번째, 세 번째 또는 네 번째 요소를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="5ea747ccb6525f229be3767e03769ebe3fd13bdb" translate="yes" xml:space="preserve">
          <source>In addition to the classes, entries for characters in a syntax table can specify flags. There are eight possible flags, represented by the characters &amp;lsquo;</source>
          <target state="translated">클래스 외에도 구문 테이블의 문자 항목은 플래그를 지정할 수 있습니다. 문자 '로 표시되는 8 개의 가능한 플래그가 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa8b8b78067e8a2d0074c7fc569ed6a4aef4b677" translate="yes" xml:space="preserve">
          <source>In addition to the common keywords (see &lt;a href=&quot;common-keywords#Common-Keywords&quot;&gt;Common Keywords&lt;/a&gt;), you can also use this keyword in &lt;code&gt;defgroup&lt;/code&gt;:</source>
          <target state="translated">일반적인 키워드뿐만 아니라 (참조 &lt;a href=&quot;common-keywords#Common-Keywords&quot;&gt;공통 키워드&lt;/a&gt; 당신은 또한이 키워드를 사용할 수 있습니다) &lt;code&gt;defgroup&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="29283b097ca518b11209ca1cc5e62af08088092e" translate="yes" xml:space="preserve">
          <source>In addition to the fundamental buffer list just described, Emacs maintains a local buffer list for each frame, in which the buffers that have been displayed (or had their windows selected) in that frame come first. (This order is recorded in the frame&amp;rsquo;s &lt;code&gt;buffer-list&lt;/code&gt; frame parameter; see &lt;a href=&quot;buffer-parameters#Buffer-Parameters&quot;&gt;Buffer Parameters&lt;/a&gt;.) Buffers never displayed in that frame come afterward, ordered according to the fundamental buffer list.</source>
          <target state="translated">방금 설명한 기본 버퍼 목록 외에도 Emacs는 각 프레임에 대한 로컬 버퍼 목록을 유지합니다.이 목록에서 해당 프레임에 표시된 (또는 선택한 창을 가진) 버퍼가 먼저 표시됩니다. (이 순서는 프레임의 &lt;code&gt;buffer-list&lt;/code&gt; 프레임 매개 변수에 기록됩니다 . &lt;a href=&quot;buffer-parameters#Buffer-Parameters&quot;&gt;버퍼 매개 변수&lt;/a&gt; 참조 ) 해당 프레임에 표시되지 않은 버퍼는 기본 버퍼 목록에 따라 순서가 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="70589b40fe71188d55af613ff5caa55411dd7c27" translate="yes" xml:space="preserve">
          <source>In addition to the keywords listed in &lt;a href=&quot;common-keywords#Common-Keywords&quot;&gt;Common Keywords&lt;/a&gt;, this macro accepts the following keywords:</source>
          <target state="translated">&lt;a href=&quot;common-keywords#Common-Keywords&quot;&gt;일반&lt;/a&gt; 키워드에 나열된 키워드 외에도이 매크로는 다음 키워드를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="14751632f3fa92d651d6de24660d939a484e328f" translate="yes" xml:space="preserve">
          <source>In addition to the mark, each buffer has a &lt;em&gt;mark ring&lt;/em&gt; which is a list of markers containing previous values of the mark. When editing commands change the mark, they should normally save the old value of the mark on the mark ring. The variable &lt;code&gt;mark-ring-max&lt;/code&gt; specifies the maximum number of entries in the mark ring; once the list becomes this long, adding a new element deletes the last element.</source>
          <target state="translated">마크 외에도 각 버퍼에는 &lt;em&gt;마크의&lt;/em&gt; 이전 값을 포함하는 마커 목록 인 &lt;em&gt;마크 링&lt;/em&gt; 이 있습니다. 편집 명령이 마크를 변경할 때 일반적으로 마크 링에 마크의 이전 값을 저장해야합니다. 변수 &lt;code&gt;mark-ring-max&lt;/code&gt; 는 마크 링의 최대 항목 수를 지정합니다. 목록이 이렇게 길어지면 새 요소를 추가하면 마지막 요소가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="c174d1d04f5ead445f6e0ecd4196859599f8b7e5" translate="yes" xml:space="preserve">
          <source>In addition to the specific escape sequences for special important control characters, Emacs provides several types of escape syntax that you can use to specify non-</source>
          <target state="translated">특수한 중요한 제어 문자에 대한 특정 이스케이프 시퀀스 외에도 Emacs는 비 (非)를 지정하는 데 사용할 수있는 여러 유형의 이스케이프 구문을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="806eb0827f5ad53c91dfa2917aa1276e03487d08" translate="yes" xml:space="preserve">
          <source>In addition to the stack, byte-code functions can use, bind, and set ordinary Lisp variables, by transferring values between variables and the stack.</source>
          <target state="translated">스택 외에도 바이트 코드 함수는 변수와 스택간에 값을 전송하여 일반 Lisp 변수를 사용, 바인딩 및 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8fb33822f9f0ddadebc4c17ae82c36a969b63dc" translate="yes" xml:space="preserve">
          <source>In addition to the usual &lt;code&gt;rx&lt;/code&gt; syntax, &lt;var&gt;rx-expr&lt;/var&gt;&amp;hellip; can contain the following constructs:</source>
          <target state="translated">일반적인 &lt;code&gt;rx&lt;/code&gt; 구문 외에도 &lt;var&gt;rx-expr&lt;/var&gt; &amp;hellip;에는 다음 구문이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="861619441bdc3073f9cfaef71fbacdcaa751184b" translate="yes" xml:space="preserve">
          <source>In addition, Emacs defines the following common mathematical constants:</source>
          <target state="translated">또한 Emacs는 다음과 같은 일반적인 수학 상수를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="a618d5cb4304df670c9f4fb6aed2d8570eaa1d4d" translate="yes" xml:space="preserve">
          <source>In addition, a module can verify the compatibility of the module</source>
          <target state="translated">또한 모듈은 모듈의 호환성을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6138054406fb00c76442b8e0e427c64e19964717" translate="yes" xml:space="preserve">
          <source>In addition, certain &lt;em&gt;magic&lt;/em&gt; file names are handled specially. For example, when a remote file name is specified, Emacs accesses the file over the network via an appropriate protocol. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Remote-Files.html#Remote-Files&quot;&gt;Remote Files&lt;/a&gt; in</source>
          <target state="translated">또한 특정 &lt;em&gt;매직&lt;/em&gt; 파일 이름은 특별히 처리됩니다. 예를 들어 원격 파일 이름이 지정되면 Emacs는 적절한 프로토콜을 통해 네트워크를 통해 파일에 액세스합니다. 참조 &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Remote-Files.html#Remote-Files&quot;&gt;원격 파일&lt;/a&gt; 에서를</target>
        </trans-unit>
        <trans-unit id="e8a5c4503f8397d7e06f3cb0730d58989841f459" translate="yes" xml:space="preserve">
          <source>In addition, each window maintains a list of &lt;em&gt;next buffers&lt;/em&gt;, which is a list of buffers re-shown by &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; (see below). This list is mainly used by &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; and &lt;code&gt;switch-to-next-buffer&lt;/code&gt; for choosing buffers to switch to.</source>
          <target state="translated">또한 각 창 은 &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; 로 전환 하여 다시 표시되는 &lt;em&gt;버퍼&lt;/em&gt; 목록 인 &lt;em&gt;다음 버퍼&lt;/em&gt; 목록을 유지합니다 (아래 참조). 이 목록은 주로 &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; &lt;code&gt;switch-to-next-buffer&lt;/code&gt; 를 선택하기 위해 이전 버퍼 로 전환 및 다음 버퍼로 전환에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="40fe5e071e4d8814ba46d10ce4d3d2ba5eb89d1b" translate="yes" xml:space="preserve">
          <source>In addition, it doesn&amp;rsquo;t alter a line if &lt;var&gt;nochange-regexp&lt;/var&gt; matches at the beginning of the line (if &lt;var&gt;nochange-regexp&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;).</source>
          <target state="translated">또한, &lt;var&gt;nochange-regexp&lt;/var&gt; 가 줄의 시작 부분에서 일치 하면 줄을 변경하지 않습니다 ( &lt;var&gt;nochange-regexp&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 ).</target>
        </trans-unit>
        <trans-unit id="634b56dedb74cfcfcc2b4c23398c78b873b18883" translate="yes" xml:space="preserve">
          <source>In addition, modes for buffers of tabulated data can inherit from Tabulated List mode, which is in turn derived from Special mode. See &lt;a href=&quot;tabulated-list-mode#Tabulated-List-Mode&quot;&gt;Tabulated List Mode&lt;/a&gt;.</source>
          <target state="translated">또한 테이블 데이터의 버퍼 모드는 테이블 형식 목록 모드에서 상속 될 수 있으며, 이는 차례로 특수 모드에서 파생됩니다. &lt;a href=&quot;tabulated-list-mode#Tabulated-List-Mode&quot;&gt;표 형식 목록 모드를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8458f97247e5805c182989af41d45c53eb115262" translate="yes" xml:space="preserve">
          <source>In addition, several major mode conventions (see &lt;a href=&quot;major-mode-conventions#Major-Mode-Conventions&quot;&gt;Major Mode Conventions&lt;/a&gt;) apply to minor modes as well: those regarding the names of global symbols, the use of a hook at the end of the initialization function, and the use of keymaps and other tables.</source>
          <target state="translated">또한 몇 가지 주요 모드 규칙 ( &lt;a href=&quot;major-mode-conventions#Major-Mode-Conventions&quot;&gt;Major Mode Conventions&lt;/a&gt; 참조 )이 부 모드에도 적용됩니다. 전역 기호 이름, 초기화 함수 끝에 후크 사용, 키맵 및 기타 테이블 사용과 관련된 규칙이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e10e520f9a6c6683a99c59aceede71aae7f0066" translate="yes" xml:space="preserve">
          <source>In addition, the keyword argument &lt;code&gt;:supertype&lt;/code&gt; may be used to specify a button-type from which &lt;var&gt;name&lt;/var&gt; inherits its default property values. Note that this inheritance happens only when &lt;var&gt;name&lt;/var&gt; is defined; subsequent changes to a supertype are not reflected in its subtypes.</source>
          <target state="translated">또한 키워드 인자 &lt;code&gt;:supertype&lt;/code&gt; 을 사용하여 &lt;var&gt;name&lt;/var&gt; 이 기본 속성 값을 상속 하는 버튼 유형을 지정할 수 있습니다 . 이 상속 은 &lt;var&gt;name&lt;/var&gt; 이 정의 된 경우에만 발생합니다 . 상위 유형에 대한 후속 변경 사항은 하위 유형에 반영되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="85ff8817dbd0f29156e32c5107069061c8afdaa3" translate="yes" xml:space="preserve">
          <source>In addition, this function by default also tells the display engine to update the display of &lt;var&gt;window&lt;/var&gt; when its frame gets redisplayed the next time. If &lt;var&gt;norecord&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, such updates are usually not performed. If, however, &lt;var&gt;norecord&lt;/var&gt; equals the special symbol &lt;code&gt;mark-for-redisplay&lt;/code&gt;, the additional actions mentioned above are omitted but &lt;var&gt;window&lt;/var&gt; will be nevertheless updated.</source>
          <target state="translated">또한이 기능은 기본적으로 다음 번에 프레임이 다시 표시 될 때 &lt;var&gt;window&lt;/var&gt; 표시를 업데이트하도록 디스플레이 엔진에 지시합니다 . &lt;var&gt;norecord&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 이러한 업데이트는 일반적으로 수행되지 않습니다. 그러나 &lt;var&gt;norecord&lt;/var&gt; 가 특수 기호 &lt;code&gt;mark-for-redisplay&lt;/code&gt; redisplay 와 같으면 위에서 언급 한 추가 작업은 생략되지만 &lt;var&gt;window&lt;/var&gt; 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="5bf884b3fb47f2ce4634851fb114d20b6bd6d338" translate="yes" xml:space="preserve">
          <source>In addition, to be acceptable, a completion must also match all the regular expressions in &lt;code&gt;completion-regexp-list&lt;/code&gt;. (Unless &lt;var&gt;collection&lt;/var&gt; is a function, in which case that function has to handle &lt;code&gt;completion-regexp-list&lt;/code&gt; itself.)</source>
          <target state="translated">또한, 허용 되려면 &lt;code&gt;completion-regexp-list&lt;/code&gt; 모든 정규 표현식과 일치해야 합니다 . ( &lt;var&gt;collection&lt;/var&gt; 이 함수가 아닌 경우 해당 함수는 &lt;code&gt;completion-regexp-list&lt;/code&gt; 자체 를 처리해야 합니다.)</target>
        </trans-unit>
        <trans-unit id="7cc2fc189c0b1e344fb740a24d867c950e0a2e21" translate="yes" xml:space="preserve">
          <source>In addition, when several consecutive fields are wildcards, Emacs collapses them into a single wildcard. This is to prevent use of auto-scaled fonts. Fonts made by scaling larger fonts are not usable for editing, and scaling a smaller font is not useful because it is better to use the smaller font in its own size, which Emacs does.</source>
          <target state="translated">또한 연속 된 여러 필드가 와일드 카드 인 경우 Emacs는이를 단일 와일드 카드로 축소합니다. 이것은 자동 크기 조정 된 글꼴의 사용을 방지하기위한 것입니다. 큰 글꼴 크기 조정으로 만든 글꼴은 편집에 사용할 수 없으며 작은 글꼴 크기 조정은 Emacs와 같이 자체 크기로 작은 글꼴을 사용하는 것이 더 낫기 때문에 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dcc0b00855e4755365a0cf1f09ff7bdbd4bc0266" translate="yes" xml:space="preserve">
          <source>In addition, you can mark a particular calling convention for a function as obsolete:</source>
          <target state="translated">또한 함수에 대한 특정 호출 규칙을 사용하지 않는 것으로 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="abd2410956fae4848b0fe5a8e212d2a9cb21e007" translate="yes" xml:space="preserve">
          <source>In addition, you can specify how to override other aspects of &lt;var&gt;parent&lt;/var&gt; with &lt;var&gt;body&lt;/var&gt;. The command &lt;var&gt;variant&lt;/var&gt; evaluates the forms in &lt;var&gt;body&lt;/var&gt; after setting up all its usual overrides, just before running the mode hooks.</source>
          <target state="translated">또한, 당신의 다른 측면 재정의하는 방법을 지정할 수 있습니다 &lt;var&gt;parent&lt;/var&gt; 와 함께 &lt;var&gt;body&lt;/var&gt; . 명령 &lt;var&gt;variant&lt;/var&gt; 은 모드 후크를 실행하기 직전에 모든 일반적인 재정의를 설정 한 후 &lt;var&gt;body&lt;/var&gt; 의 양식을 평가합니다 .</target>
        </trans-unit>
        <trans-unit id="02d36c3daefb75afe381d792395f9b544a5ec4c1" translate="yes" xml:space="preserve">
          <source>In addition, you can use &lt;code&gt;jit-lock-register&lt;/code&gt; to register a Font Lock fontification function, which will be called whenever parts of a buffer are (re)fontified because a window was scrolled or its size changed. See &lt;a href=&quot;other-font-lock-variables#Other-Font-Lock-Variables&quot;&gt;Other Font Lock Variables&lt;/a&gt;.</source>
          <target state="translated">또한 &lt;code&gt;jit-lock-register&lt;/code&gt; 를 사용 하여 창을 스크롤하거나 크기가 변경되어 버퍼의 일부가 (재) 폰팅 될 때마다 호출되는 Font Lock 글꼴 기능을 등록 할 수 있습니다. &lt;a href=&quot;other-font-lock-variables#Other-Font-Lock-Variables&quot;&gt;기타 글꼴 잠금 변수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5705334ff8d1c82c84ad44b35b05007f2fa086a6" translate="yes" xml:space="preserve">
          <source>In addition, you should use the &lt;code&gt;:image&lt;/code&gt; property; this is how you specify the image to display in the tool bar:</source>
          <target state="translated">또한 &lt;code&gt;:image&lt;/code&gt; 속성을 사용해야합니다 . 도구 모음에 표시 할 이미지를 지정하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ef0d186686b9c18697ab294b6e70ae5ec8c76b45" translate="yes" xml:space="preserve">
          <source>In all cases, the functions specify the program to be run. An error is signaled if the file is not found or cannot be executed. If the file name is relative, the variable &lt;code&gt;exec-path&lt;/code&gt; contains a list of directories to search. Emacs initializes &lt;code&gt;exec-path&lt;/code&gt; when it starts up, based on the value of the environment variable &lt;code&gt;PATH&lt;/code&gt;. The standard file name constructs, &amp;lsquo;</source>
          <target state="translated">모든 경우에 함수는 실행할 프로그램을 지정합니다. 파일을 찾을 수 없거나 실행할 수없는 경우 오류가 표시됩니다. 파일 이름이 상대적인 경우 &lt;code&gt;exec-path&lt;/code&gt; 변수 에는 검색 할 디렉토리 목록이 포함됩니다. Emacs 는 시작할 때 환경 변수 &lt;code&gt;PATH&lt;/code&gt; 의 값에 따라 &lt;code&gt;exec-path&lt;/code&gt; 를 초기화 합니다. 표준 파일 이름은 '</target>
        </trans-unit>
        <trans-unit id="b115e6222ce380955a9d138aca170aa8e2fc234f" translate="yes" xml:space="preserve">
          <source>In all of these functions, if &lt;var&gt;pos&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt;, the value of point is used by default. If narrowing is in effect, then &lt;var&gt;pos&lt;/var&gt; should fall within the accessible portion. See &lt;a href=&quot;narrowing#Narrowing&quot;&gt;Narrowing&lt;/a&gt;.</source>
          <target state="translated">이러한 모든 함수에서 &lt;var&gt;pos&lt;/var&gt; 가 생략되거나 &lt;code&gt;nil&lt;/code&gt; 이면 기본적으로 point 값이 사용됩니다. 축소가 적용되는 경우 &lt;var&gt;pos&lt;/var&gt; 는 액세스 가능한 부분 내에 있어야합니다. &lt;a href=&quot;narrowing#Narrowing&quot;&gt;축소를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cf682436e64696838034960370c404ea0fb339cf" translate="yes" xml:space="preserve">
          <source>In all other cases (i.e., if a backup was made by copying or if no backup was made), this function returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">다른 모든 경우 (예 : 복사를 통해 백업 한 경우 또는 백업이없는 경우)이 함수는 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="70cd7827f4bb42c08e11727b0f1fc468af4e5623" translate="yes" xml:space="preserve">
          <source>In all other respects, the indirect buffer and its base buffer are completely separate. They have different names, independent values of point, independent narrowing, independent markers and overlays (though inserting or deleting text in either buffer relocates the markers and overlays for both), independent major modes, and independent buffer-local variable bindings.</source>
          <target state="translated">다른 모든 측면에서 간접 버퍼와 기본 버퍼는 완전히 분리되어 있습니다. 서로 다른 이름, 독립적 인 포인트 값, 독립적 인 축소, 독립적 인 마커 및 오버레이 (두 버퍼에 텍스트를 삽입하거나 삭제하면 둘 다에 대한 마커와 오버레이가 재배치되지만), 독립적 인 주요 모드 및 독립적 인 버퍼 로컬 변수 바인딩이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9323836e208f0f82945b28702f7866a57f8574f" translate="yes" xml:space="preserve">
          <source>In an empty obarray, every element is 0, so you can create an obarray with &lt;code&gt;(make-vector &lt;var&gt;length&lt;/var&gt; 0)&lt;/code&gt;. &lt;strong&gt;This is the only valid way to create an obarray.&lt;/strong&gt; Prime numbers as lengths tend to result in good hashing; lengths one less than a power of two are also good.</source>
          <target state="translated">빈 오바 레이에서 모든 요소는 0이므로 &lt;code&gt;(make-vector &lt;var&gt;length&lt;/var&gt; 0)&lt;/code&gt; 로 오바 레이를 만들 수 있습니다 . &lt;strong&gt;이것은 오바 레이를 만드는 유일한 유효한 방법입니다. &lt;/strong&gt;길이로서의 소수는 좋은 해싱을 가져 오는 경향이 있습니다. 2의 거듭 제곱보다 1이 적은 길이도 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c76083d7ada2b44cfdf97bab16a99c1032df0a60" translate="yes" xml:space="preserve">
          <source>In an indirect buffer, this points to the base buffer. In an ordinary buffer, it is null.</source>
          <target state="translated">간접 버퍼에서 이것은 기본 버퍼를 가리 킵니다. 일반 버퍼에서는 널입니다.</target>
        </trans-unit>
        <trans-unit id="be6a5b6e0ca7ae36339c26b567db393e85f17f36" translate="yes" xml:space="preserve">
          <source>In an interactive call, &lt;var&gt;buffer-or-name&lt;/var&gt; is the current buffer. You cannot specify any other buffer.</source>
          <target state="translated">대화식 호출에서 &lt;var&gt;buffer-or-name&lt;/var&gt; 은 현재 버퍼입니다. 다른 버퍼는 지정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c4012945ab51c1de7ae7e0feebb4d0048885f32d" translate="yes" xml:space="preserve">
          <source>In an interactive call, &lt;var&gt;count&lt;/var&gt; is the numeric prefix argument, and &lt;var&gt;killp&lt;/var&gt; is the unprocessed prefix argument. Therefore, if a prefix argument is supplied, the text is saved in the kill ring. If no prefix argument is supplied, then one character is deleted, but not saved in the kill ring.</source>
          <target state="translated">대화식 호출에서 &lt;var&gt;count&lt;/var&gt; 는 숫자 접두사 인수이고 &lt;var&gt;killp&lt;/var&gt; 는 처리되지 않은 접두사 인수입니다. 따라서 접두사 인수가 제공되면 텍스트가 킬 링에 저장됩니다. 접두사 인수가 제공되지 않으면 한 문자가 삭제되지만 킬 링에는 저장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="704c56b79c4ed2cb4dfd912f6f7d4ba1689e5220" translate="yes" xml:space="preserve">
          <source>In an interactive call, &lt;var&gt;count&lt;/var&gt; is the numeric prefix argument.</source>
          <target state="translated">대화식 호출에서 &lt;var&gt;count&lt;/var&gt; 는 숫자 접두사 인수입니다.</target>
        </trans-unit>
        <trans-unit id="9c353c383e13b0c1f20602b8bc3d920d9ce5a372" translate="yes" xml:space="preserve">
          <source>In an interactive call, &lt;var&gt;join-following-p&lt;/var&gt; is the prefix argument, and &lt;var&gt;beg&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt; are, respectively, the start and end of the region if it is active, else &lt;code&gt;nil&lt;/code&gt;. The function returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">대화식 호출에서 &lt;var&gt;join-following-p&lt;/var&gt; 는 접두사 인수이고 &lt;var&gt;beg&lt;/var&gt; 및 &lt;var&gt;end&lt;/var&gt; 는 각각 활성화 된 경우 영역의 시작 및 끝이고, 그렇지 않으면 &lt;code&gt;nil&lt;/code&gt; 입니다. 이 함수는 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="dd9c47e572e1c96e3e5511e4f902232b871741f5" translate="yes" xml:space="preserve">
          <source>In an interactive call, &lt;var&gt;move-count&lt;/var&gt; is set to the numeric prefix argument.</source>
          <target state="translated">대화식 호출에서 &lt;var&gt;move-count&lt;/var&gt; 는 숫자 접두사 인수로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="877a7452b2cb77873327a9d65a9bc81a3bc68b87" translate="yes" xml:space="preserve">
          <source>In an interactive call, &lt;var&gt;n&lt;/var&gt; is the numeric prefix argument, if provided; otherwise &lt;var&gt;n&lt;/var&gt; defaults to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">대화식 호출에서 &lt;var&gt;n&lt;/var&gt; 은 제공된 경우 숫자 접두사 인수입니다. 그렇지 않으면 &lt;var&gt;n&lt;/var&gt; 기본값은 &lt;code&gt;nil&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d388d1baf8cc5dc2fc6fa147be58325965385ef6" translate="yes" xml:space="preserve">
          <source>In an interactive call, &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt; are point and the mark, and &lt;var&gt;region&lt;/var&gt; is always non-&lt;code&gt;nil&lt;/code&gt;, so the command always kills the text in the current region.</source>
          <target state="translated">대화식 호출에서 &lt;var&gt;start&lt;/var&gt; 과 &lt;var&gt;end&lt;/var&gt; 은 포인트와 마크이고 &lt;var&gt;region&lt;/var&gt; 은 항상 &lt;code&gt;nil&lt;/code&gt; 이 아니므로 명령은 항상 현재 영역의 텍스트를 종료합니다.</target>
        </trans-unit>
        <trans-unit id="a6cb6ba8c7fe3535c2d651a8267a7942776259f0" translate="yes" xml:space="preserve">
          <source>In an interactive call, &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt; are point and the mark, and &lt;var&gt;region&lt;/var&gt; is always non-&lt;code&gt;nil&lt;/code&gt;, so the command always saves the text in the current region.</source>
          <target state="translated">대화 형 호출에서 &lt;var&gt;start&lt;/var&gt; 과 &lt;var&gt;end&lt;/var&gt; 은 포인트와 마크이고 &lt;var&gt;region&lt;/var&gt; 은 항상 &lt;code&gt;nil&lt;/code&gt; 이 아니므로 명령은 항상 현재 영역에 텍스트를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="726b5ea42fc92cd6827c86a199c5d5ff92d13493" translate="yes" xml:space="preserve">
          <source>In an interactive call, &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt; are set to the bounds of the current region (point and the mark, with the smallest first).</source>
          <target state="translated">대화 형 호출에서 &lt;var&gt;start&lt;/var&gt; 과 &lt;var&gt;end&lt;/var&gt; 은 현재 영역의 경계 (가장 작은 것이 먼저 표시되는 지점 및 표시)로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="909035f0fed973896fe39afc8da0584d4b089bed" translate="yes" xml:space="preserve">
          <source>In an interactive call, BUFFER-OR-NAME is the current buffer. You cannot specify any other buffer. This function returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">대화식 호출에서 BUFFER-OR-NAME은 현재 버퍼입니다. 다른 버퍼는 지정할 수 없습니다. 이 함수는 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b6eeae93f2da1e1eebbead60ee6180c03e34ee17" translate="yes" xml:space="preserve">
          <source>In any alternative for which &lt;code&gt;nil&lt;/code&gt; is not a valid value, other than a &lt;code&gt;const&lt;/code&gt;, you should specify a valid default for that alternative using the &lt;code&gt;:value&lt;/code&gt; keyword. See &lt;a href=&quot;type-keywords#Type-Keywords&quot;&gt;Type Keywords&lt;/a&gt;.</source>
          <target state="translated">있는 어떤 대안 &lt;code&gt;nil&lt;/code&gt; 상 이외의 유효한 값이 아닌 &lt;code&gt;const&lt;/code&gt; 를 , 당신은 사용하여 그 대안에 대한 올바른 기본 지정해야합니다 &lt;code&gt;:value&lt;/code&gt; 키워드를. &lt;a href=&quot;type-keywords#Type-Keywords&quot;&gt;유형 키워드를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c3f1ff89d869dfc333b47133aae85f8c337add69" translate="yes" xml:space="preserve">
          <source>In any construct except &amp;lsquo;</source>
          <target state="translated">'를 제외한 모든 구성에서</target>
        </trans-unit>
        <trans-unit id="23f12bc9401d6ef353dd5c55264d43d354d02967" translate="yes" xml:space="preserve">
          <source>In backtraces, the tails of long lists and the ends of long strings, vectors or structures, as well as objects which are deeply nested, will be printed as underlined &amp;ldquo;...&amp;rdquo;. You can click with the mouse on a &amp;ldquo;...&amp;rdquo;, or type</source>
          <target state="translated">역 추적에서 긴 목록의 꼬리와 긴 문자열, 벡터 또는 구조의 끝은 물론 깊이 중첩 된 객체는 밑줄 &quot;...&quot;로 인쇄됩니다. &quot;...&quot;를 마우스로 클릭하거나</target>
        </trans-unit>
        <trans-unit id="c4a2e0b355083bd4e6d42b1e97e7d50e0326670d" translate="yes" xml:space="preserve">
          <source>In batch mode (see &lt;a href=&quot;batch-mode#Batch-Mode&quot;&gt;Batch Mode&lt;/a&gt;), &lt;code&gt;sit-for&lt;/code&gt; cannot be interrupted, even by input from the standard input descriptor. It is thus equivalent to &lt;code&gt;sleep-for&lt;/code&gt;, which is described below.</source>
          <target state="translated">배치 모드 (참조에 &lt;a href=&quot;batch-mode#Batch-Mode&quot;&gt;배치 모드&lt;/a&gt; ), &lt;code&gt;sit-for&lt;/code&gt; 중단 할 수없는, 심지어는 표준 입력 기술자로부터의 입력에 의해. 따라서 아래에 설명 된 &lt;code&gt;sleep-for&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="9752b056c39ff21442a1ef5d86a1fc2649afb383" translate="yes" xml:space="preserve">
          <source>In batch mode, the message is printed to the standard error stream, followed by a newline.</source>
          <target state="translated">배치 모드에서 메시지는 표준 오류 스트림에 인쇄되고 그 뒤에 줄 바꿈이 이어집니다.</target>
        </trans-unit>
        <trans-unit id="8f907e0c0c1a2381a3d4d498c2ada7dd4f978099" translate="yes" xml:space="preserve">
          <source>In between &lt;code&gt;deftheme&lt;/code&gt; and &lt;code&gt;provide-theme&lt;/code&gt; are Lisp forms specifying the theme settings: usually a call to &lt;code&gt;custom-theme-set-variables&lt;/code&gt; and/or a call to &lt;code&gt;custom-theme-set-faces&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;deftheme&lt;/code&gt; 과 &lt;code&gt;provide-theme&lt;/code&gt; 사이 에는 테마 설정을 지정하는 Lisp 양식이 있습니다. 일반적으로 &lt;code&gt;custom-theme-set-variables&lt;/code&gt; 호출 및 / 또는 &lt;code&gt;custom-theme-set-faces&lt;/code&gt; 호출 입니다.</target>
        </trans-unit>
        <trans-unit id="3186dd1c1a48267fc6d25c2e34e690dda868c78a" translate="yes" xml:space="preserve">
          <source>In binary, the decimal integer 5 looks like this:</source>
          <target state="translated">바이너리에서 10 진수 5는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d7ecff436b6d92bbc3770178067cf6d70a3b3360" translate="yes" xml:space="preserve">
          <source>In bitfields, prefer &lt;code&gt;unsigned int&lt;/code&gt; or &lt;code&gt;signed int&lt;/code&gt; to &lt;code&gt;int&lt;/code&gt;, as &lt;code&gt;int&lt;/code&gt; is less portable: it might be signed, and might not be. Single-bit bit fields should be &lt;code&gt;unsigned int&lt;/code&gt; or &lt;code&gt;bool_bf&lt;/code&gt; so that their values are 0 or 1.</source>
          <target state="translated">비트 필드에서는 &lt;code&gt;int&lt;/code&gt; 가 덜 이식 가능 하므로 &lt;code&gt;unsigned int&lt;/code&gt; 또는 &lt;code&gt;signed int&lt;/code&gt; 를 &lt;code&gt;int&lt;/code&gt; 보다 선호합니다. 서명 될 수도 있고 그렇지 않을 수도 있습니다. 단일 비트 비트 필드는 값이 0 또는 1이되도록 &lt;code&gt;unsigned int&lt;/code&gt; 또는 &lt;code&gt;bool_bf&lt;/code&gt; 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="675393a13b41d56ffdbbbad71f7b6ec5ff7928e6" translate="yes" xml:space="preserve">
          <source>In case a process status changes need to be passed to several sentinels, you can use &lt;code&gt;add-function&lt;/code&gt; to combine an existing sentinel with a new one. See &lt;a href=&quot;advising-functions#Advising-Functions&quot;&gt;Advising Functions&lt;/a&gt;.</source>
          <target state="translated">프로세스 상태 변경 사항을 여러 센티넬에 전달해야하는 경우 &lt;code&gt;add-function&lt;/code&gt; 을 사용 하여 기존 센티넬과 새 센티넬을 결합 할 수 있습니다 . &lt;a href=&quot;advising-functions#Advising-Functions&quot;&gt;조언 기능을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0977f1472f3a5da1475ae4011d1503a4798e4640" translate="yes" xml:space="preserve">
          <source>In case the process&amp;rsquo;s output needs to be passed to several filters, you can use &lt;code&gt;add-function&lt;/code&gt; to combine an existing filter with a new one. See &lt;a href=&quot;advising-functions#Advising-Functions&quot;&gt;Advising Functions&lt;/a&gt;.</source>
          <target state="translated">프로세스의 출력을 여러 필터로 전달해야하는 경우 &lt;code&gt;add-function&lt;/code&gt; 을 사용 하여 기존 필터를 새 필터와 결합 할 수 있습니다 . &lt;a href=&quot;advising-functions#Advising-Functions&quot;&gt;조언 기능을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="415e1a1cd6e77875c4b4a2bc134b390be6d8c82b" translate="yes" xml:space="preserve">
          <source>In complicated programs, simple termination may not be what you want. For example, the program may have made temporary changes in data structures, or created temporary buffers that should be deleted before the program is finished. In such cases, you would use &lt;code&gt;unwind-protect&lt;/code&gt; to establish &lt;em&gt;cleanup expressions&lt;/em&gt; to be evaluated in case of error. (See &lt;a href=&quot;cleanups#Cleanups&quot;&gt;Cleanups&lt;/a&gt;.) Occasionally, you may wish the program to continue execution despite an error in a subroutine. In these cases, you would use &lt;code&gt;condition-case&lt;/code&gt; to establish &lt;em&gt;error handlers&lt;/em&gt; to recover control in case of error.</source>
          <target state="translated">복잡한 프로그램에서는 간단한 종료가 원하는 것이 아닐 수 있습니다. 예를 들어, 프로그램이 데이터 구조를 임시로 변경했거나 프로그램이 완료되기 전에 삭제되어야하는 임시 버퍼를 생성했을 수 있습니다. 이러한 경우 &lt;code&gt;unwind-protect&lt;/code&gt; 를 사용 하여 오류 발생시 평가할 &lt;em&gt;정리 식&lt;/em&gt; 을 설정 합니다. ( &lt;a href=&quot;cleanups#Cleanups&quot;&gt;정리를&lt;/a&gt; 참조하십시오 .) 가끔 서브 루틴의 오류에도 불구하고 프로그램이 계속 실행되기를 원할 수 있습니다. 이 경우 &lt;code&gt;condition-case&lt;/code&gt; 를 사용하여 &lt;em&gt;오류 발생시&lt;/em&gt; 제어를 복구하기 위해 &lt;em&gt;오류 처리기&lt;/em&gt; 를 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="60f0d105f0d0cf77e2c002371b610ecf30fd644e" translate="yes" xml:space="preserve">
          <source>In contexts where a truth value is expected, any non-&lt;code&gt;nil&lt;/code&gt; value is considered to be &lt;var&gt;true&lt;/var&gt;. However, &lt;code&gt;t&lt;/code&gt; is the preferred way to represent the truth value &lt;var&gt;true&lt;/var&gt;. When you need to choose a value that represents &lt;var&gt;true&lt;/var&gt;, and there is no other basis for choosing, use &lt;code&gt;t&lt;/code&gt;. The symbol &lt;code&gt;t&lt;/code&gt; always has the value &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">진실 값이 예상되는 컨텍스트에서 &lt;code&gt;nil&lt;/code&gt; 이 아닌 값은 모두 &lt;var&gt;true&lt;/var&gt; 로 간주됩니다 . 그러나 &lt;code&gt;t&lt;/code&gt; 는 진리 값 &lt;var&gt;true&lt;/var&gt; 를 나타내는 데 선호되는 방법 입니다 . &lt;var&gt;true&lt;/var&gt; 를 나타내는 값을 선택해야하고 다른 선택 기준이없는 경우 &lt;code&gt;t&lt;/code&gt; 를 사용하십시오 . 심볼 &lt;code&gt;t&lt;/code&gt; 는 항상 값이 &lt;code&gt;t&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="8eba9b310f9d565eff25ab947d11a5a1f613377b" translate="yes" xml:space="preserve">
          <source>In contrast to the round-trip specification described in the previous subsection (see &lt;a href=&quot;format-conversion-round_002dtrip#Format-Conversion-Round_002dTrip&quot;&gt;Format Conversion Round-Trip&lt;/a&gt;), you can use the variables &lt;code&gt;after-insert-file-functions&lt;/code&gt; and &lt;code&gt;write-region-annotate-functions&lt;/code&gt; to separately control the respective reading and writing conversions.</source>
          <target state="translated">이전 서브 섹션 ( &lt;a href=&quot;format-conversion-round_002dtrip#Format-Conversion-Round_002dTrip&quot;&gt;Format Conversion Round-Trip&lt;/a&gt; 참조)에서 설명한 왕복 사양과 달리 , &lt;code&gt;after-insert-file-functions&lt;/code&gt; 및 &lt;code&gt;write-region-annotate-functions&lt;/code&gt; 변수 를 사용하여 각각의 읽기 및 쓰기를 개별적으로 제어 할 수 있습니다. 전환.</target>
        </trans-unit>
        <trans-unit id="0a3bf2d74aea58d6ea8bffb1137530a1210d0d12" translate="yes" xml:space="preserve">
          <source>In contrast, when reading, the annotations intermixed with the text are handled immediately. &lt;code&gt;insert-file-contents&lt;/code&gt; sets point to the beginning of some text to be converted, then calls the conversion functions with the length of that text. These functions should always return with point at the beginning of the inserted text. This approach makes sense for reading because annotations removed by the first converter can&amp;rsquo;t be mistakenly processed by a later converter. Each conversion function should scan for the annotations it recognizes, remove the annotation, modify the buffer text (to set a text property, for example), and return the updated length of the text, as it stands after those changes. The value returned by one function becomes the argument to the next function.</source>
          <target state="translated">반대로 읽을 때 텍스트와 혼합 된 주석은 즉시 처리됩니다. &lt;code&gt;insert-file-contents&lt;/code&gt; 세트는 변환 할 일부 텍스트의 시작을 가리킨 다음 해당 텍스트 길이로 변환 함수를 호출합니다. 이러한 함수는 항상 삽입 된 텍스트의 시작 부분에 포인트를 반환해야합니다. 첫 번째 변환기에서 제거 된 주석은 이후 변환기에서 실수로 처리 할 수 ​​없기 때문에이 방법은 읽기에 적합합니다. 각 변환 함수는 인식하는 주석을 검색하고, 주석을 제거하고, 버퍼 텍스트를 수정 (예 : 텍스트 속성 설정)하고, 변경된 텍스트의 업데이트 된 길이를 반환해야합니다. 한 함수에서 반환 된 값은 다음 함수의 인수가됩니다.</target>
        </trans-unit>
        <trans-unit id="45f849363c53b5551262a12f44a838fe59d9dfff" translate="yes" xml:space="preserve">
          <source>In conventional string syntax, it would be written</source>
          <target state="translated">기존의 문자열 구문에서는 다음과 같이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="6763f8895253c23b2bfde0810fbb36d480f05759" translate="yes" xml:space="preserve">
          <source>In database terminology, an &lt;em&gt;atomic&lt;/em&gt; change is an indivisible change&amp;mdash;it can succeed entirely or it can fail entirely, but it cannot partly succeed. A Lisp program can make a series of changes to one or several buffers as an &lt;em&gt;atomic change group&lt;/em&gt;, meaning that either the entire series of changes will be installed in their buffers or, in case of an error, none of them will be.</source>
          <target state="translated">데이터베이스 용어에서 &lt;em&gt;원자 적&lt;/em&gt; 변경은 불가분의 변경입니다. 완전히 성공하거나 완전히 실패 할 수 있지만 부분적으로는 성공할 수 없습니다. Lisp 프로그램은 &lt;em&gt;원자 변경 그룹&lt;/em&gt; 으로 하나 또는 여러 버퍼에 일련의 변경을 수행 할 수 있습니다. 즉, 전체 일련의 변경 사항이 해당 버퍼에 설치되거나 오류가 발생한 경우에는 아무것도 설치되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="24fde5297de2cdf3f7cddc429425532a566bab63" translate="yes" xml:space="preserve">
          <source>In detail, &lt;code&gt;fill-context-prefix&lt;/code&gt; does this:</source>
          <target state="translated">구체적으로 &lt;code&gt;fill-context-prefix&lt;/code&gt; 는 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="6c73b882a6269a46b3da224791afd0c995e3640a" translate="yes" xml:space="preserve">
          <source>In each frame, at any time, exactly one Emacs window is designated as &lt;em&gt;selected within the frame&lt;/em&gt;. For the selected frame, that window is called the &lt;em&gt;selected window&lt;/em&gt;&amp;mdash;the one in which most editing takes place, and in which the cursor for selected windows appears (see &lt;a href=&quot;cursor-parameters#Cursor-Parameters&quot;&gt;Cursor Parameters&lt;/a&gt;). Keyboard input that inserts or deletes text is also normally directed to this window. The selected window&amp;rsquo;s buffer is usually also the current buffer, except when &lt;code&gt;set-buffer&lt;/code&gt; has been used (see &lt;a href=&quot;current-buffer#Current-Buffer&quot;&gt;Current Buffer&lt;/a&gt;). As for non-selected frames, the window selected within the frame becomes the selected window if the frame is ever selected. See &lt;a href=&quot;selecting-windows#Selecting-Windows&quot;&gt;Selecting Windows&lt;/a&gt;.</source>
          <target state="translated">각 프레임에서 언제든지 정확히 하나의 Emacs 창이 &lt;em&gt;프레임 내에서 선택된&lt;/em&gt; 것으로 지정됩니다 . 선택한 프레임의 경우 해당 창을 &lt;em&gt;선택한 창&lt;/em&gt; 이라고합니다. 대부분의 편집이 수행되고 선택한 창에 대한 &lt;a href=&quot;cursor-parameters#Cursor-Parameters&quot;&gt;커서&lt;/a&gt; 가 표시되는 창입니다 ( 커서 매개 변수 참조 ). 텍스트를 삽입하거나 삭제하는 키보드 입력도 일반적으로이 창으로 지정됩니다. 선택된 윈도우의 버퍼는 일반적으로도시를 제외하고 현재의 버퍼이다 &lt;code&gt;set-buffer&lt;/code&gt; (참조 사용되고 &lt;a href=&quot;current-buffer#Current-Buffer&quot;&gt;전류 버퍼&lt;/a&gt; ). 선택되지 않은 프레임의 경우 프레임이 선택되면 프레임 내에서 선택된 창이 선택된 창이됩니다. &lt;a href=&quot;selecting-windows#Selecting-Windows&quot;&gt;Windows 선택을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ad35cfb21fd35d93c29df7f5ad4a4bed0b1b3107" translate="yes" xml:space="preserve">
          <source>In either case, evaluating the new form a second time should reuse the window already showing</source>
          <target state="translated">두 경우 모두 새 양식을 다시 평가하면 이미 표시된 창을 다시 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="ee27d0c4d0b49c83179819de6b9ff1ee23a49d86" translate="yes" xml:space="preserve">
          <source>In either case, if the buffer appended to happens to be displayed in some window, the next redisplay will show how its text has changed. If it is not displayed in any window, you will not see the change immediately on the screen. The command causes the buffer to become current temporarily, but does not cause it to be displayed.</source>
          <target state="translated">두 경우 모두 추가 된 버퍼가 일부 창에 표시되는 경우 다음 다시 표시 할 때 텍스트가 어떻게 변경되었는지 표시합니다. 어떤 창에도 표시되지 않으면 화면에 변경 사항이 즉시 표시되지 않습니다. 이 명령은 버퍼를 일시적으로 현재 상태로 만들지 만 표시하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="ef78bac5868bf004212c473e8f88981c10bea61b" translate="yes" xml:space="preserve">
          <source>In either case, the mouse pointer must enter the text area of a window in order to trigger its selection. Dragging the scroll bar slider or the mode line of a window conceptually should not cause its auto-selection.</source>
          <target state="translated">두 경우 모두 선택을 트리거하려면 마우스 포인터가 창의 텍스트 영역에 들어가야합니다. 스크롤 막대 슬라이더 또는 창의 모드 라인을 개념적으로 드래그하면 자동 선택이되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bb020b581d31901fa99b6df9f62296593685946f" translate="yes" xml:space="preserve">
          <source>In execution, this is equivalent to &lt;code&gt;(progn &lt;var&gt;body&lt;/var&gt;...)&lt;/code&gt;, but the compiler does not issue warnings for anything that occurs inside &lt;var&gt;body&lt;/var&gt;.</source>
          <target state="translated">실행시 이것은 &lt;code&gt;(progn &lt;var&gt;body&lt;/var&gt;...)&lt;/code&gt; 와 동일하지만 컴파일러는 &lt;var&gt;body&lt;/var&gt; 내부에서 발생하는 모든 것에 대해 경고를 발행하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b9f9f3178064d3634e45314cc92aa2cf96eef93d" translate="yes" xml:space="preserve">
          <source>In execution, this is equivalent to &lt;code&gt;(progn &lt;var&gt;body&lt;/var&gt;...)&lt;/code&gt;, but the compiler does not issue warnings for the specified conditions in &lt;var&gt;body&lt;/var&gt;. &lt;var&gt;warnings&lt;/var&gt; is an associative list of warning symbols and function/variable symbols they apply to. For instance, if you wish to call an obsolete function called &lt;code&gt;foo&lt;/code&gt;, but want to suppress the compilation warning, say:</source>
          <target state="translated">실행시 이것은 &lt;code&gt;(progn &lt;var&gt;body&lt;/var&gt;...)&lt;/code&gt; 와 동일하지만 컴파일러는 &lt;var&gt;body&lt;/var&gt; 에 지정된 조건에 대한 경고를 발행하지 않습니다 . &lt;var&gt;warnings&lt;/var&gt; 는 경고 기호 및 해당 기호가 적용되는 기능 / 변수 기호의 연관 목록입니다. 예를 들어 &lt;code&gt;foo&lt;/code&gt; 라는 구식 함수를 호출하고 싶지만 컴파일 경고를 억제하려면 다음과 같이 말하십시오.</target>
        </trans-unit>
        <trans-unit id="e7a73c00dd55be6828ec1b5b1eeb3d24e621b2d1" translate="yes" xml:space="preserve">
          <source>In fact, &lt;code&gt;shell-mode&lt;/code&gt; is used only in a function that executes &lt;code&gt;(require 'shell)&lt;/code&gt; before calling &lt;code&gt;shell-mode&lt;/code&gt;, so &lt;code&gt;shell-mode&lt;/code&gt; will be defined properly at run-time. When you know that such a warning does not indicate a real problem, it is good to suppress the warning. That makes new warnings which might mean real problems more visible. You do that with &lt;code&gt;declare-function&lt;/code&gt;.</source>
          <target state="translated">사실, &lt;code&gt;shell-mode&lt;/code&gt; 에서만 실행하는가하는 기능에 사용된다 &lt;code&gt;(require 'shell)&lt;/code&gt; 호출하기 전에 &lt;code&gt;shell-mode&lt;/code&gt; , 그래서 &lt;code&gt;shell-mode&lt;/code&gt; 실행 시간에 제대로 정의됩니다. 그러한 경고가 실제 문제를 나타내지 않는다는 것을 알고있는 경우 경고를 억제하는 것이 좋습니다. 이는 실제 문제를 더 잘 볼 수 있음을 의미 할 수있는 새로운 경고를 만듭니다. 당신은 &lt;code&gt;declare-function&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="702499afeb8537fae4516a820a217b87dce96b8a" translate="yes" xml:space="preserve">
          <source>In general, a coding system doesn&amp;rsquo;t guarantee roundtrip identity: decoding a byte sequence using a coding system, then encoding the resulting text in the same coding system, can produce a different byte sequence. But some coding systems do guarantee that the byte sequence will be the same as what you originally decoded. Here are a few examples:</source>
          <target state="translated">일반적으로 코딩 시스템은 왕복 식별을 보장하지 않습니다. 코딩 시스템을 사용하여 바이트 시퀀스를 디코딩 한 다음 동일한 코딩 시스템에서 결과 텍스트를 인코딩하면 다른 바이트 시퀀스가 ​​생성 될 수 있습니다. 그러나 일부 코딩 시스템은 바이트 시퀀스가 ​​원래 디코딩 한 것과 동일하다는 것을 보장합니다. 다음은 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="ed8140bd46b47c404332052d91ca4300f382ef67" translate="yes" xml:space="preserve">
          <source>In general, a customization type is a list whose first element is a symbol, one of the customization type names defined in the following sections. After this symbol come a number of arguments, depending on the symbol. Between the type symbol and its arguments, you can optionally write keyword-value pairs (see &lt;a href=&quot;type-keywords#Type-Keywords&quot;&gt;Type Keywords&lt;/a&gt;).</source>
          <target state="translated">일반적으로 사용자 정의 유형은 첫 번째 요소가 다음 섹션에 정의 된 사용자 정의 유형 이름 중 하나 인 기호 인 목록입니다. 이 기호 뒤에는 기호에 따라 여러 인수가 나옵니다. 유형 기호와 인수 사이에 선택적으로 키워드-값 쌍을 작성할 수 있습니다 ( &lt;a href=&quot;type-keywords#Type-Keywords&quot;&gt;유형 키워드&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="1b2ad17401a7d60fe385624a77f3d12df552ad7a" translate="yes" xml:space="preserve">
          <source>In general, any version of Emacs can run byte-compiled code produced by recent earlier versions of Emacs, but the reverse is not true.</source>
          <target state="translated">일반적으로 Emacs의 모든 버전은 최신 이전 버전의 Emacs에서 생성 된 바이트 컴파일 된 코드를 실행할 수 있지만 그 반대는 사실이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="483c66ee5a6826168e53ee4c3c9f71f1f0eb14bb" translate="yes" xml:space="preserve">
          <source>In general, it is not a good idea to position a frame relative to the right or bottom edge of its display. Positioning the initial or a new frame is either not accurate (because the size of the outer frame is not yet fully known before the frame has been made visible) or will cause additional flicker (if the frame has to be repositioned after becoming visible).</source>
          <target state="translated">일반적으로 디스플레이의 오른쪽 또는 아래쪽 가장자리를 기준으로 프레임을 배치하는 것은 좋지 않습니다. 초기 프레임 또는 새 프레임의 위치를 ​​지정하는 것은 정확하지 않거나 (외부 프레임의 크기가 프레임이 표시되기 전에 아직 완전히 알려지지 않았기 때문에) 또는 추가 깜박임 (프레임이 표시된 후 위치를 변경해야하는 경우)을 유발합니다.</target>
        </trans-unit>
        <trans-unit id="034a86c69916fca88f1f01a8bd4d6e2f2b480dfb" translate="yes" xml:space="preserve">
          <source>In general, the execution modes earlier in the above list run the program more slowly or stop sooner than the modes later in the list.</source>
          <target state="translated">일반적으로 위 목록의 앞부분에있는 실행 모드는 목록의 뒷부분에있는 모드보다 프로그램을 더 느리게 실행하거나 더 빨리 중지합니다.</target>
        </trans-unit>
        <trans-unit id="62c782f036549cb7ac5bcdfa7098ab39e8230d14" translate="yes" xml:space="preserve">
          <source>In general, you should never use &lt;code&gt;select-frame&lt;/code&gt; in a way that could switch to a different terminal without switching back when you&amp;rsquo;re done.</source>
          <target state="translated">일반적으로 완료 후 다시 전환하지 않고 다른 터미널로 전환 할 수있는 방식으로 &lt;code&gt;select-frame&lt;/code&gt; 을 사용해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="000defc205f6d714529fe32278af5b38a4bfd5bc" translate="yes" xml:space="preserve">
          <source>In hexadecimal and octal escape sequences, the escaped character code may contain a variable number of digits, so the first subsequent character which is not a valid hexadecimal or octal digit terminates the escape sequence. If the next character in a string could be interpreted as a hexadecimal or octal digit, write &amp;lsquo;</source>
          <target state="translated">16 진수 및 8 진수 이스케이프 시퀀스에서 이스케이프 된 문자 코드에는 가변 자릿수가 포함될 수 있으므로 유효한 16 진수 또는 8 진수가 아닌 첫 번째 후속 문자가 이스케이프 시퀀스를 종료합니다. 문자열의 다음 문자가 16 진수 또는 8 진수로 해석 될 수 있으면 '</target>
        </trans-unit>
        <trans-unit id="0836c04769a43db17a7b5ef05b200c3203b6be46" translate="yes" xml:space="preserve">
          <source>In human languages, and in C code, the parenthesis pairs are &amp;lsquo;</source>
          <target state="translated">인간 언어 및 C 코드에서 괄호 쌍은 '</target>
        </trans-unit>
        <trans-unit id="c6f32a0eb2283df62480c957c724fa4fc47bd02c" translate="yes" xml:space="preserve">
          <source>In its most simplistic form, a frame accommodates always one single window that can be used for displaying a buffer. As a consequence, it is always the latest call of &lt;code&gt;display-buffer&lt;/code&gt; that will have succeeded in placing its buffer there.</source>
          <target state="translated">가장 단순한 형태의 프레임은 항상 버퍼를 표시하는 데 사용할 수있는 하나의 단일 창을 수용합니다. 결과적으로 버퍼를 거기에 두는 데 성공한 것은 항상 최신 &lt;code&gt;display-buffer&lt;/code&gt; 호출입니다 .</target>
        </trans-unit>
        <trans-unit id="517dd96030f3f996fb1f45cc621a39517562983b" translate="yes" xml:space="preserve">
          <source>In many</source>
          <target state="translated">많은</target>
        </trans-unit>
        <trans-unit id="8dcd7ed16971de04e98f26c126a4533e71094f7f" translate="yes" xml:space="preserve">
          <source>In many cases, you can avoid the need to track the mouse by using the &lt;code&gt;mouse-face&lt;/code&gt; text property (see &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Special Properties&lt;/a&gt;). That works at a much lower level and runs more smoothly than Lisp-level mouse tracking.</source>
          <target state="translated">대부분의 경우 &lt;code&gt;mouse-face&lt;/code&gt; 텍스트 속성 을 사용하여 마우스 를 추적하지 않아도됩니다 ( &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;특수 속성&lt;/a&gt; 참조 ). 이는 훨씬 낮은 수준에서 작동하며 Lisp 수준의 마우스 추적보다 원활하게 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="49101488ffc937e3b7893c385b89b2d974310c1a" translate="yes" xml:space="preserve">
          <source>In most Emacs Lisp programs, the fact that non-</source>
          <target state="translated">대부분의 Emacs Lisp 프로그램에서</target>
        </trans-unit>
        <trans-unit id="3d37db503d5ae63228a732b670e52af7077b5d2f" translate="yes" xml:space="preserve">
          <source>In most cases, &lt;var&gt;repeat&lt;/var&gt; has no effect on when &lt;em&gt;first&lt;/em&gt; call takes place&amp;mdash;&lt;var&gt;time&lt;/var&gt; alone specifies that. There is one exception: if &lt;var&gt;time&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;, then the timer runs whenever the time is a multiple of &lt;var&gt;repeat&lt;/var&gt; seconds after the epoch. This is useful for functions like &lt;code&gt;display-time&lt;/code&gt;.</source>
          <target state="translated">대부분의 경우 &lt;var&gt;repeat&lt;/var&gt; 은 &lt;em&gt;첫 번째&lt;/em&gt; 호출이 발생하는시기에 영향을주지 않습니다 . &lt;var&gt;time&lt;/var&gt; 만으로 지정됩니다. 한 가지 예외가 있습니다. &lt;var&gt;time&lt;/var&gt; 이 &lt;code&gt;t&lt;/code&gt; 이면 시간 이 epoch 후 &lt;var&gt;repeat&lt;/var&gt; 초의 배수 일 때마다 타이머가 실행됩니다 . 이것은 &lt;code&gt;display-time&lt;/code&gt; 과 같은 함수에 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="2168d3ba9383968f4154392a9504604af5704a81" translate="yes" xml:space="preserve">
          <source>In most cases, an object&amp;rsquo;s printed representation is also a read syntax for the object. However, some types have no read syntax, since it does not make sense to enter objects of these types as constants in a Lisp program. These objects are printed in &lt;em&gt;hash notation&lt;/em&gt;, which consists of the characters &amp;lsquo;</source>
          <target state="translated">대부분의 경우 개체의 인쇄 된 표현은 개체에 대한 읽기 구문이기도합니다. 그러나 일부 유형에는 읽기 구문이 없습니다. Lisp 프로그램에서 이러한 유형의 객체를 상수로 입력하는 것은 의미가 없기 때문입니다. 이러한 개체는 '문자'로 구성된 &lt;em&gt;해시 표기법&lt;/em&gt; 으로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="c750c78aabaa316f26f23fc17657b3720fc57df7" translate="yes" xml:space="preserve">
          <source>In most cases, this is the same as &lt;code&gt;data-directory&lt;/code&gt;. They may be different when you run Emacs from the directory where you built it, without actually installing it. See &lt;a href=&quot;help-functions#Definition-of-data_002ddirectory&quot;&gt;Definition of data-directory&lt;/a&gt;.</source>
          <target state="translated">대부분의 경우 이는 &lt;code&gt;data-directory&lt;/code&gt; 와 동일 합니다. 실제로 설치하지 않고 빌드 한 디렉토리에서 Emacs를 실행하면 다를 수 있습니다. &lt;a href=&quot;help-functions#Definition-of-data_002ddirectory&quot;&gt;데이터 디렉토리 정의를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7f11478c160dcd0584465efccbf9e4064e017f8a" translate="yes" xml:space="preserve">
          <source>In most cases, you should not call minibuffer input functions in the middle of a Lisp function. Instead, do all minibuffer input as part of reading the arguments for a command, in the &lt;code&gt;interactive&lt;/code&gt; specification. See &lt;a href=&quot;defining-commands#Defining-Commands&quot;&gt;Defining Commands&lt;/a&gt;.</source>
          <target state="translated">대부분의 경우 Lisp 함수 중간에 미니 버퍼 입력 함수를 호출하면 안됩니다. 대신 &lt;code&gt;interactive&lt;/code&gt; 사양 에서 명령에 대한 인수를 읽는 동안 모든 미니 버퍼 입력을 수행하십시오 . &lt;a href=&quot;defining-commands#Defining-Commands&quot;&gt;명령 정의를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b4c2bc2c76de37d53e0710c100619151cccb7b2e" translate="yes" xml:space="preserve">
          <source>In most cases, you should not call these functions in the middle of a Lisp function. When possible, do all minibuffer input as part of reading the arguments for a command, in the &lt;code&gt;interactive&lt;/code&gt; specification. See &lt;a href=&quot;defining-commands#Defining-Commands&quot;&gt;Defining Commands&lt;/a&gt;.</source>
          <target state="translated">대부분의 경우 Lisp 함수 중간에 이러한 함수를 호출하면 안됩니다. 가능하면 &lt;code&gt;interactive&lt;/code&gt; 사양 에서 명령에 대한 인수를 읽을 때 모든 미니 버퍼 입력을 수행하십시오 . &lt;a href=&quot;defining-commands#Defining-Commands&quot;&gt;명령 정의를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2d28787cdfc551ad73cc6007bcd96f89f863e52c" translate="yes" xml:space="preserve">
          <source>In most cases, you should not need to call &lt;code&gt;package-activate-all&lt;/code&gt;, as this is done automatically during startup. Simply make sure to put any code that should run before &lt;code&gt;package-activate-all&lt;/code&gt; in the early init file, and any code that should run after it in the primary init file (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Init-File.html#Init-File&quot;&gt;Init File&lt;/a&gt; in</source>
          <target state="translated">대부분의 경우 시작하는 동안 자동으로 수행되므로 &lt;code&gt;package-activate-all&lt;/code&gt; 을 호출 할 필요가 없습니다 . &lt;code&gt;package-activate-all&lt;/code&gt; 이전에 실행해야하는 코드 는 초기 초기화 파일에, 그 이후에 실행해야하는 코드는 기본 초기화 파일에 넣어야합니다 ( &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Init-File.html#Init-File&quot;&gt;Init 파일&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="574e81c2ebf0fb53e6b7a82f512213500a53d2b7" translate="yes" xml:space="preserve">
          <source>In most clean Lisp code, this difference won&amp;rsquo;t matter. It can matter only if you perform side-effects on the objects constructed by the macro definition. Thus, to avoid trouble, &lt;strong&gt;avoid side effects on objects constructed by macro definitions&lt;/strong&gt;. Here is an example of how such side effects can get you into trouble:</source>
          <target state="translated">대부분의 깨끗한 Lisp 코드에서는이 차이가 중요하지 않습니다. 매크로 정의에 의해 생성 된 개체에 부작용을 수행하는 경우에만 중요 할 수 있습니다. 따라서 문제를 &lt;strong&gt;방지하려면 매크로 정의로 구성된 개체에 대한 부작용을 피하십시오&lt;/strong&gt; . 다음은 이러한 부작용이 어떻게 문제를 일으킬 수 있는지에 대한 예입니다.</target>
        </trans-unit>
        <trans-unit id="0b16687a5ada91a83610070c6aab00214708b230" translate="yes" xml:space="preserve">
          <source>In most computer languages, every function has a name. But in Lisp, a function in the strictest sense has no name: it is an object which can &lt;em&gt;optionally&lt;/em&gt; be associated with a symbol (e.g., &lt;code&gt;car&lt;/code&gt;) that serves as the function name. See &lt;a href=&quot;function-names#Function-Names&quot;&gt;Function Names&lt;/a&gt;. When a function has been given a name, we usually also refer to that symbol as a &amp;ldquo;function&amp;rdquo; (e.g., we refer to &amp;ldquo;the function &lt;code&gt;car&lt;/code&gt;&amp;rdquo;). In this manual, the distinction between a function name and the function object itself is usually unimportant, but we will take note wherever it is relevant.</source>
          <target state="translated">대부분의 컴퓨터 언어에서 모든 함수에는 이름이 있습니다. 그러나 Lisp에서 가장 엄격한 의미의 함수에는 이름이 없습니다 . 함수 이름으로 사용되는 기호 (예 : &lt;code&gt;car&lt;/code&gt; ) 와 &lt;em&gt;선택적&lt;/em&gt; 으로 연관 될 수있는 객체입니다 . &lt;a href=&quot;function-names#Function-Names&quot;&gt;함수 이름을&lt;/a&gt; 참조하십시오 . 기능에 이름이 부여 된 경우 일반적으로 해당 기호를 &quot;기능&quot;이라고도합니다 (예 : &quot;기능 &lt;code&gt;car&lt;/code&gt; &quot;라고 함). 이 설명서에서 함수 이름과 함수 객체 자체의 구분은 일반적으로 중요하지 않지만 관련성이있는 모든 경우에 유의합니다.</target>
        </trans-unit>
        <trans-unit id="0783cd0cb68b0d9a782edd9f6662166db1491334" translate="yes" xml:space="preserve">
          <source>In most languages, the programmer must declare the data type of each variable, and the type is known by the compiler but not represented in the data. Such type declarations do not exist in Emacs Lisp. A Lisp variable can have any type of value, and it remembers whatever value you store in it, type and all. (Actually, a small number of Emacs Lisp variables can only take on values of a certain type. See &lt;a href=&quot;variables-with-restricted-values#Variables-with-Restricted-Values&quot;&gt;Variables with Restricted Values&lt;/a&gt;.)</source>
          <target state="translated">대부분의 언어에서 프로그래머는 각 변수의 데이터 유형을 선언해야하며 유형은 컴파일러에 의해 알려지지 만 데이터에 표시되지 않습니다. 이러한 유형 선언은 Emacs Lisp에 없습니다. Lisp 변수는 모든 유형의 값을 가질 수 있으며 저장 한 값, 유형 및 모두를 기억합니다. (실제로 소수의 Emacs Lisp 변수는 특정 유형의 값만 가질 수 있습니다. &lt;a href=&quot;variables-with-restricted-values#Variables-with-Restricted-Values&quot;&gt;제한된 값을 가진 변수를&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="48532c1621002093d77ee956f1e52d70bc16b5b2" translate="yes" xml:space="preserve">
          <source>In most of the places where strings are used, we conceptualize the string as containing text characters&amp;mdash;the same kind of characters found in buffers or files. Occasionally Lisp programs use strings that conceptually contain keyboard characters; for example, they may be key sequences or keyboard macro definitions. However, storing keyboard characters in a string is a complex matter, for reasons of historical compatibility, and it is not always possible.</source>
          <target state="translated">문자열이 사용되는 대부분의 장소에서 우리는 문자열을 텍스트 문자 (버퍼 나 파일에있는 것과 같은 종류의 문자)를 포함하는 것으로 개념화합니다. 때때로 Lisp 프로그램은 개념적으로 키보드 문자를 포함하는 문자열을 사용합니다. 예를 들어, 키 시퀀스 또는 키보드 매크로 정의 일 수 있습니다. 그러나 키보드 문자를 문자열에 저장하는 것은 역사적 호환성 때문에 복잡한 문제이며 항상 가능한 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="5f4144091cc9aca1cd2f8e02b0fccbdf93c70e06" translate="yes" xml:space="preserve">
          <source>In most programming languages, it is impossible to have a function without a name. In Lisp, a function has no intrinsic name. A lambda expression can be called as a function even though it has no name; to emphasize this, we also call it an &lt;em&gt;anonymous function&lt;/em&gt; (see &lt;a href=&quot;anonymous-functions#Anonymous-Functions&quot;&gt;Anonymous Functions&lt;/a&gt;). A named function in Lisp is just a symbol with a valid function in its function cell (see &lt;a href=&quot;defining-functions#Defining-Functions&quot;&gt;Defining Functions&lt;/a&gt;).</source>
          <target state="translated">대부분의 프로그래밍 언어에서 이름이없는 함수는 불가능합니다. Lisp에서 함수에는 고유 이름이 없습니다. 람다 식은 이름이 없더라도 함수로 호출 할 수 있습니다. 이를 강조하기 위해 &lt;em&gt;익명 함수&lt;/em&gt; ( &lt;a href=&quot;anonymous-functions#Anonymous-Functions&quot;&gt;Anonymous Functions&lt;/a&gt; 참조) 라고도합니다 . Lisp에서 명명 된 함수는 함수 셀에 유효한 함수가있는 기호 일뿐입니다 (함수 &lt;a href=&quot;defining-functions#Defining-Functions&quot;&gt;정의&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="717022d1f6adfca4a3a7968227e86d9f8fd9f6f0" translate="yes" xml:space="preserve">
          <source>In most ways, a minibuffer is a normal Emacs buffer. Most operations &lt;em&gt;within&lt;/em&gt; a buffer, such as editing commands, work normally in a minibuffer. However, many operations for managing buffers do not apply to minibuffers. The name of a minibuffer always has the form &amp;lsquo;</source>
          <target state="translated">대부분의 경우 미니 버퍼는 일반 Emacs 버퍼입니다. 편집 명령과 같은 버퍼 &lt;em&gt;내의&lt;/em&gt; 대부분의 작업 은 미니 버퍼에서 정상적으로 작동합니다. 그러나 버퍼 관리를위한 많은 작업이 미니 버퍼에 적용되지 않습니다. 미니 버퍼의 이름은 항상 '</target>
        </trans-unit>
        <trans-unit id="2561cd793393aff7d27fa03dc11a09e0ffcec475" translate="yes" xml:space="preserve">
          <source>In one special case, &lt;var&gt;pos-or-area&lt;/var&gt; is a list containing a symbol (one of the symbols listed above) instead of just the symbol. This happens after the imaginary prefix keys for the event are registered by Emacs. See &lt;a href=&quot;key-sequence-input#Key-Sequence-Input&quot;&gt;Key Sequence Input&lt;/a&gt;.</source>
          <target state="translated">특별한 경우에 &lt;var&gt;pos-or-area&lt;/var&gt; 는 기호 대신에 기호 (위에 나열된 기호 중 하나)가 포함 된 목록입니다. 이것은 이벤트의 가상 접두사 키가 Emacs에 등록 된 후에 발생합니다. &lt;a href=&quot;key-sequence-input#Key-Sequence-Input&quot;&gt;키 시퀀스 입력을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="40058b1b79d94d51db03317b307ab30a9e089207" translate="yes" xml:space="preserve">
          <source>In order for a symbol to be an error symbol, it must be defined with &lt;code&gt;define-error&lt;/code&gt; which takes a parent condition (defaults to &lt;code&gt;error&lt;/code&gt;). This parent defines the conditions that this kind of error belongs to. The transitive set of parents always includes the error symbol itself, and the symbol &lt;code&gt;error&lt;/code&gt;. Because quitting is not considered an error, the set of parents of &lt;code&gt;quit&lt;/code&gt; is just &lt;code&gt;(quit)&lt;/code&gt;.</source>
          <target state="translated">심볼이 오류 심볼이 되려면 부모 조건을 취하는 &lt;code&gt;define-error&lt;/code&gt; 로 정의 해야합니다 (기본값은 &lt;code&gt;error&lt;/code&gt; ). 이 부모는 이러한 종류의 오류가 속하는 조건을 정의합니다. 전 이적 상위 집합에는 항상 오류 기호 자체와 &lt;code&gt;error&lt;/code&gt; 기호 가 포함 됩니다. 종료는 오류로 간주되지 않으므로 &lt;code&gt;quit&lt;/code&gt; 의 부모 집합 은 just &lt;code&gt;(quit)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="42862e17fb0b9045574c0488aeeff987c7b035ab" translate="yes" xml:space="preserve">
          <source>In order for compilation of macro calls to work, the macros must already be defined in Lisp when the calls to them are compiled. The compiler has a special feature to help you do this: if a file being compiled contains a &lt;code&gt;defmacro&lt;/code&gt; form, the macro is defined temporarily for the rest of the compilation of that file.</source>
          <target state="translated">매크로 호출 컴파일이 작동하려면 매크로 호출이 컴파일 될 때 Lisp에 이미 정의되어 있어야합니다. 컴파일러에는이를 수행하는 데 도움이되는 특수 기능이 있습니다. 컴파일중인 파일에 &lt;code&gt;defmacro&lt;/code&gt; 형식이 포함 된 경우 해당 파일 의 나머지 컴파일 동안 매크로가 임시로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="007cc651440219a61408c3deac9dfe41920a80bf" translate="yes" xml:space="preserve">
          <source>In order to extract the local part of the file&amp;rsquo;s name of a temporary file, use &lt;code&gt;file-local-name&lt;/code&gt; (see &lt;a href=&quot;magic-file-names#Magic-File-Names&quot;&gt;Magic File Names&lt;/a&gt;).</source>
          <target state="translated">임시 파일의 파일 이름에서 로컬 부분을 추출하려면 &lt;code&gt;file-local-name&lt;/code&gt; 을 사용 하십시오 ( &lt;a href=&quot;magic-file-names#Magic-File-Names&quot;&gt;Magic File Names&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="02b3ec04225a3187705865de19dd49a2f10d82cd" translate="yes" xml:space="preserve">
          <source>In order to find out which window or frame was selected the last time window change functions were run, the following functions can be used:</source>
          <target state="translated">In order to find out which window or frame was selected the last time window change functions were run, the following functions can be used:</target>
        </trans-unit>
        <trans-unit id="4aa759b30fc1bac4367e22f29f78fa95acabc797" translate="yes" xml:space="preserve">
          <source>In order to give a child frame a draggable header or mode line, the window parameters &lt;code&gt;mode-line-format&lt;/code&gt; and &lt;code&gt;header-line-format&lt;/code&gt; are handy (see &lt;a href=&quot;window-parameters#Window-Parameters&quot;&gt;Window Parameters&lt;/a&gt;). These allow to remove an unwanted mode line (when &lt;code&gt;drag-with-header-line&lt;/code&gt; is chosen) and to remove mouse-sensitive areas which might interfere with frame dragging.</source>
          <target state="translated">In order to give a child frame a draggable header or mode line, the window parameters &lt;code&gt;mode-line-format&lt;/code&gt; and &lt;code&gt;header-line-format&lt;/code&gt; are handy (see &lt;a href=&quot;window-parameters#Window-Parameters&quot;&gt;Window Parameters&lt;/a&gt;). These allow to remove an unwanted mode line (when &lt;code&gt;drag-with-header-line&lt;/code&gt; is chosen) and to remove mouse-sensitive areas which might interfere with frame dragging.</target>
        </trans-unit>
        <trans-unit id="3a1da75035de559e954ff07f12d67704d95cfb68" translate="yes" xml:space="preserve">
          <source>In order to prevent the hook functions from being called more than once for the same part of the buffer, you can use the variable &lt;code&gt;buffer-access-fontified-property&lt;/code&gt;.</source>
          <target state="translated">In order to prevent the hook functions from being called more than once for the same part of the buffer, you can use the variable &lt;code&gt;buffer-access-fontified-property&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce8866ba225f4a0e162725c09d5505ceaec41ba9" translate="yes" xml:space="preserve">
          <source>In order to see how this new, modified form works, delete any frame showing</source>
          <target state="translated">In order to see how this new, modified form works, delete any frame showing</target>
        </trans-unit>
        <trans-unit id="25d21175a564e227d0d2be93a38559526ba4e991" translate="yes" xml:space="preserve">
          <source>In order to use Edebug to debug Lisp code, you must first &lt;em&gt;instrument&lt;/em&gt; the code. Instrumenting code inserts additional code into it, to invoke Edebug at the proper places.</source>
          <target state="translated">In order to use Edebug to debug Lisp code, you must first &lt;em&gt;instrument&lt;/em&gt; the code. Instrumenting code inserts additional code into it, to invoke Edebug at the proper places.</target>
        </trans-unit>
        <trans-unit id="fe0db91a5b392657a0aca17c10f50da256d748a3" translate="yes" xml:space="preserve">
          <source>In ordinary usage, the difference between simple packages and multi-file packages is relatively unimportant; the Package Menu interface makes no distinction between them. However, the procedure for creating them differs, as explained in the following sections.</source>
          <target state="translated">In ordinary usage, the difference between simple packages and multi-file packages is relatively unimportant; the Package Menu interface makes no distinction between them. However, the procedure for creating them differs, as explained in the following sections.</target>
        </trans-unit>
        <trans-unit id="4049b50b43320603134b658569956160c5b33eec" translate="yes" xml:space="preserve">
          <source>In other languages, an expression is text; it has no other form. In Lisp, an expression is primarily a Lisp object and only secondarily the text that is the object&amp;rsquo;s read syntax. Often there is no need to emphasize this distinction, but you must keep it in the back of your mind, or you will occasionally be very confused.</source>
          <target state="translated">In other languages, an expression is text; it has no other form. In Lisp, an expression is primarily a Lisp object and only secondarily the text that is the object&amp;rsquo;s read syntax. Often there is no need to emphasize this distinction, but you must keep it in the back of your mind, or you will occasionally be very confused.</target>
        </trans-unit>
        <trans-unit id="b28e79f39397b0edb42bffc1a990b7fa7d5f45bc" translate="yes" xml:space="preserve">
          <source>In other words, after the end of a group, the matcher remembers the beginning and end of the text matched by that group. Later on in the regular expression you can use &amp;lsquo;</source>
          <target state="translated">In other words, after the end of a group, the matcher remembers the beginning and end of the text matched by that group. Later on in the regular expression you can use &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="73dca98bad9f727764c940e829d2b4567f5194c0" translate="yes" xml:space="preserve">
          <source>In other words, the string character with the &lt;code&gt;cursor&lt;/code&gt; property of any non-&lt;code&gt;nil&lt;/code&gt; value is the character where to display the cursor. The value of the property says for which buffer positions to display the cursor there. If the value is an integer &lt;var&gt;n&lt;/var&gt;, the cursor is displayed there when point is anywhere between the beginning of the overlay or &lt;code&gt;display&lt;/code&gt; property and &lt;var&gt;n&lt;/var&gt; positions after that. If the value is anything else and non-&lt;code&gt;nil&lt;/code&gt;, the cursor is displayed there only when point is at the beginning of the &lt;code&gt;display&lt;/code&gt; property or at &lt;code&gt;overlay-start&lt;/code&gt;.</source>
          <target state="translated">In other words, the string character with the &lt;code&gt;cursor&lt;/code&gt; property of any non- &lt;code&gt;nil&lt;/code&gt; value is the character where to display the cursor. The value of the property says for which buffer positions to display the cursor there. If the value is an integer &lt;var&gt;n&lt;/var&gt; , the cursor is displayed there when point is anywhere between the beginning of the overlay or &lt;code&gt;display&lt;/code&gt; property and &lt;var&gt;n&lt;/var&gt; positions after that. If the value is anything else and non- &lt;code&gt;nil&lt;/code&gt; , the cursor is displayed there only when point is at the beginning of the &lt;code&gt;display&lt;/code&gt; property or at &lt;code&gt;overlay-start&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="342b05b7073d64e941e7a9180ce0ab73ce5d1977" translate="yes" xml:space="preserve">
          <source>In particular, &lt;code&gt;delete-windows-on&lt;/code&gt; (see &lt;a href=&quot;deleting-windows#Deleting-Windows&quot;&gt;Deleting Windows&lt;/a&gt;) handles case (2) by deleting the associated frame and case (3) by showing another buffer in that frame&amp;rsquo;s only window. The function &lt;code&gt;replace-buffer-in-windows&lt;/code&gt; (see &lt;a href=&quot;buffers-and-windows#Buffers-and-Windows&quot;&gt;Buffers and Windows&lt;/a&gt;) which is called when a buffer gets killed, deletes the window in case (1) and behaves like &lt;code&gt;delete-windows-on&lt;/code&gt; otherwise.</source>
          <target state="translated">In particular, &lt;code&gt;delete-windows-on&lt;/code&gt; (see &lt;a href=&quot;deleting-windows#Deleting-Windows&quot;&gt;Deleting Windows&lt;/a&gt;) handles case (2) by deleting the associated frame and case (3) by showing another buffer in that frame&amp;rsquo;s only window. The function &lt;code&gt;replace-buffer-in-windows&lt;/code&gt; (see &lt;a href=&quot;buffers-and-windows#Buffers-and-Windows&quot;&gt;Buffers and Windows&lt;/a&gt;) which is called when a buffer gets killed, deletes the window in case (1) and behaves like &lt;code&gt;delete-windows-on&lt;/code&gt; otherwise.</target>
        </trans-unit>
        <trans-unit id="ae990d311270dc72ee6facabe1f2c786eb8e3f14" translate="yes" xml:space="preserve">
          <source>In particular, mutating the returned value may inadvertently change another string, alter a constant string in the program, or even raise an error. To obtain a string that you can safely mutate, use &lt;code&gt;copy-sequence&lt;/code&gt; on the result.</source>
          <target state="translated">In particular, mutating the returned value may inadvertently change another string, alter a constant string in the program, or even raise an error. To obtain a string that you can safely mutate, use &lt;code&gt;copy-sequence&lt;/code&gt; on the result.</target>
        </trans-unit>
        <trans-unit id="d8c72f894595d295da4116cddb04e4987b994ba0" translate="yes" xml:space="preserve">
          <source>In particular, under X (but not when building with GTK+), the frame&amp;rsquo;s outer border can be used. On MS-Windows, specifying a non-zero outer border width will show a one-pixel wide external border. Under all window-systems, the internal border can be used. In either case, it&amp;rsquo;s advisable to disable a child frame&amp;rsquo;s window manager decorations with the &lt;code&gt;undecorated&lt;/code&gt; frame parameter (see &lt;a href=&quot;management-parameters#Management-Parameters&quot;&gt;Management Parameters&lt;/a&gt;).</source>
          <target state="translated">In particular, under X (but not when building with GTK+), the frame&amp;rsquo;s outer border can be used. On MS-Windows, specifying a non-zero outer border width will show a one-pixel wide external border. Under all window-systems, the internal border can be used. In either case, it&amp;rsquo;s advisable to disable a child frame&amp;rsquo;s window manager decorations with the &lt;code&gt;undecorated&lt;/code&gt; frame parameter (see &lt;a href=&quot;management-parameters#Management-Parameters&quot;&gt;Management Parameters&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="785c848b7a9c76188153b98dc766e9eee3d7f299" translate="yes" xml:space="preserve">
          <source>In practice not all of the areas shown in the drawing will or may be present. The meaning of these areas is described below.</source>
          <target state="translated">In practice not all of the areas shown in the drawing will or may be present. The meaning of these areas is described below.</target>
        </trans-unit>
        <trans-unit id="1a24ae50708083315e6e5d71edf56c47415c18d3" translate="yes" xml:space="preserve">
          <source>In practice this means that &lt;code&gt;display-buffer&lt;/code&gt; builds a list of all action functions specified by these display actions. The first element of this list is the first action function specified by &lt;code&gt;display-buffer-overriding-action&lt;/code&gt;, if any. Its last element is &lt;code&gt;display-buffer-pop-up-frame&lt;/code&gt;&amp;mdash;the last action function specified by &lt;code&gt;display-buffer-fallback-action&lt;/code&gt;. Duplicates are not removed from this list&amp;mdash;hence one and the same action function may be called multiple times during one call of &lt;code&gt;display-buffer&lt;/code&gt;.</source>
          <target state="translated">In practice this means that &lt;code&gt;display-buffer&lt;/code&gt; builds a list of all action functions specified by these display actions. The first element of this list is the first action function specified by &lt;code&gt;display-buffer-overriding-action&lt;/code&gt; , if any. Its last element is &lt;code&gt;display-buffer-pop-up-frame&lt;/code&gt; &amp;mdash;the last action function specified by &lt;code&gt;display-buffer-fallback-action&lt;/code&gt; . Duplicates are not removed from this list&amp;mdash;hence one and the same action function may be called multiple times during one call of &lt;code&gt;display-buffer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="069dde31ed88efd7662427ed0d83c24aecd85cef" translate="yes" xml:space="preserve">
          <source>In practice, most &amp;lsquo;</source>
          <target state="translated">In practice, most &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="dff22f2148342d55185406b93857c7cd707282f3" translate="yes" xml:space="preserve">
          <source>In practice, nearly all functions have names, and are referred to by their names. You can create a named Lisp function by defining a lambda expression and putting it in a function cell (see &lt;a href=&quot;function-cells#Function-Cells&quot;&gt;Function Cells&lt;/a&gt;). However, it is more common to use the &lt;code&gt;defun&lt;/code&gt; special form, described in the next section. See &lt;a href=&quot;defining-functions#Defining-Functions&quot;&gt;Defining Functions&lt;/a&gt;.</source>
          <target state="translated">In practice, nearly all functions have names, and are referred to by their names. You can create a named Lisp function by defining a lambda expression and putting it in a function cell (see &lt;a href=&quot;function-cells#Function-Cells&quot;&gt;Function Cells&lt;/a&gt;). However, it is more common to use the &lt;code&gt;defun&lt;/code&gt; special form, described in the next section. See &lt;a href=&quot;defining-functions#Defining-Functions&quot;&gt;Defining Functions&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="e2ec4dd56177cba6f1cdca6d305d727013f82bc9" translate="yes" xml:space="preserve">
          <source>In practice, you can usually use the text property search functions in place of explicit interval boundaries. You can think of them as finding the boundaries of intervals, assuming that intervals are always coalesced whenever possible. See &lt;a href=&quot;property-search#Property-Search&quot;&gt;Property Search&lt;/a&gt;.</source>
          <target state="translated">In practice, you can usually use the text property search functions in place of explicit interval boundaries. You can think of them as finding the boundaries of intervals, assuming that intervals are always coalesced whenever possible. See &lt;a href=&quot;property-search#Property-Search&quot;&gt;Property Search&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="595414a18f0f6814ac8aec499699ba0cadf3010e" translate="yes" xml:space="preserve">
          <source>In principle, if you want an array of text characters, you could use either a string or a vector. In practice, we always choose strings for such applications, for four reasons:</source>
          <target state="translated">In principle, if you want an array of text characters, you could use either a string or a vector. In practice, we always choose strings for such applications, for four reasons:</target>
        </trans-unit>
        <trans-unit id="952a69bffe57014633d87ea51d91051b5c23b497" translate="yes" xml:space="preserve">
          <source>In principle, you can assign a variable value to any symbol with &lt;code&gt;setq&lt;/code&gt;, whether or not it has first been defined as a variable. However, you ought to write a variable definition for each global variable that you want to use; otherwise, your Lisp program may not act correctly if it is evaluated with lexical scoping enabled (see &lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;Variable Scoping&lt;/a&gt;).</source>
          <target state="translated">In principle, you can assign a variable value to any symbol with &lt;code&gt;setq&lt;/code&gt; , whether or not it has first been defined as a variable. However, you ought to write a variable definition for each global variable that you want to use; otherwise, your Lisp program may not act correctly if it is evaluated with lexical scoping enabled (see &lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;Variable Scoping&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="59a81a18a5d27bbbef59498c3ff3190989d0d540" translate="yes" xml:space="preserve">
          <source>In short, a keymap entry may be a keymap, a command, a keyboard macro, a symbol that leads to one of them, or &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">In short, a keymap entry may be a keymap, a command, a keyboard macro, a symbol that leads to one of them, or &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64a6416d90974dbdcf9b5cf8181346f0fcaef6ea" translate="yes" xml:space="preserve">
          <source>In simple cases, all you need to specify is the mapping to lower-case; the three related tables will be calculated automatically from that one.</source>
          <target state="translated">In simple cases, all you need to specify is the mapping to lower-case; the three related tables will be calculated automatically from that one.</target>
        </trans-unit>
        <trans-unit id="ca3f716cf86956eff115da7250837a9a9ae0da62" translate="yes" xml:space="preserve">
          <source>In some cases, a leading &amp;lsquo;</source>
          <target state="translated">In some cases, a leading &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="51c6be916769f1ca362110d817b3845ee05a7c40" translate="yes" xml:space="preserve">
          <source>In some cases, it is important to control the relative ordering of functions on the hook. The optional argument &lt;var&gt;depth&lt;/var&gt; lets you indicate where the function should be inserted in the list: it should then be a number between -100 and 100 where the higher the value, the closer to the end of the list the function should go. The &lt;var&gt;depth&lt;/var&gt; defaults to 0 and for backward compatibility when &lt;var&gt;depth&lt;/var&gt; is a non-nil symbol it is interpreted as a depth of 90. Furthermore, when &lt;var&gt;depth&lt;/var&gt; is strictly greater than 0 the function is added &lt;em&gt;after&lt;/em&gt; rather than before functions of the same depth. One should never use a depth of 100 (or -100), because one can never be sure that no other function will ever need to come before (or after) us.</source>
          <target state="translated">In some cases, it is important to control the relative ordering of functions on the hook. The optional argument &lt;var&gt;depth&lt;/var&gt; lets you indicate where the function should be inserted in the list: it should then be a number between -100 and 100 where the higher the value, the closer to the end of the list the function should go. The &lt;var&gt;depth&lt;/var&gt; defaults to 0 and for backward compatibility when &lt;var&gt;depth&lt;/var&gt; is a non-nil symbol it is interpreted as a depth of 90. Furthermore, when &lt;var&gt;depth&lt;/var&gt; is strictly greater than 0 the function is added &lt;em&gt;after&lt;/em&gt; rather than before functions of the same depth. One should never use a depth of 100 (or -100), because one can never be sure that no other function will ever need to come before (or after) us.</target>
        </trans-unit>
        <trans-unit id="65dfdc7d279aaa17d921d1528c2b2fe56c2c0a4d" translate="yes" xml:space="preserve">
          <source>In some cases, text lines are truncated on the screen rather than continued onto additional screen lines. In these cases, &lt;code&gt;vertical-motion&lt;/code&gt; moves point much like &lt;code&gt;forward-line&lt;/code&gt;. See &lt;a href=&quot;truncation#Truncation&quot;&gt;Truncation&lt;/a&gt;.</source>
          <target state="translated">In some cases, text lines are truncated on the screen rather than continued onto additional screen lines. In these cases, &lt;code&gt;vertical-motion&lt;/code&gt; moves point much like &lt;code&gt;forward-line&lt;/code&gt; . See &lt;a href=&quot;truncation#Truncation&quot;&gt;Truncation&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="4582e0d4f2cc8e2368ad7a2f683a1a7484ac075b" translate="yes" xml:space="preserve">
          <source>In some cases, the option is followed in the command line by an argument. In these cases, the &lt;var&gt;handler-function&lt;/var&gt; can find all the remaining command-line arguments in the variable &lt;code&gt;command-line-args-left&lt;/code&gt; (see below). (The entire list of command-line arguments is in &lt;code&gt;command-line-args&lt;/code&gt;.)</source>
          <target state="translated">In some cases, the option is followed in the command line by an argument. In these cases, the &lt;var&gt;handler-function&lt;/var&gt; can find all the remaining command-line arguments in the variable &lt;code&gt;command-line-args-left&lt;/code&gt; (see below). (The entire list of command-line arguments is in &lt;code&gt;command-line-args&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="878c8864da92eab3f1063c3c626126be65624841" translate="yes" xml:space="preserve">
          <source>In some configurations, Emacs cannot display a real dialog box; so instead it displays the same items in a pop-up menu in the center of the frame.</source>
          <target state="translated">In some configurations, Emacs cannot display a real dialog box; so instead it displays the same items in a pop-up menu in the center of the frame.</target>
        </trans-unit>
        <trans-unit id="4e6989e3c48ebc292a0fb0be926a8320dfd01322" translate="yes" xml:space="preserve">
          <source>In some functions (such as &lt;code&gt;read-quoted-char&lt;/code&gt;),</source>
          <target state="translated">In some functions (such as &lt;code&gt;read-quoted-char&lt;/code&gt; ),</target>
        </trans-unit>
        <trans-unit id="623f15e33a88f6fded6d8865aae03ac806476d9f" translate="yes" xml:space="preserve">
          <source>In some ways, the Button package duplicates the functionality in the Widget package. See &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/widget/index.html#Top&quot;&gt;Introduction&lt;/a&gt; in</source>
          <target state="translated">In some ways, the Button package duplicates the functionality in the Widget package. See &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/widget/index.html#Top&quot;&gt;Introduction&lt;/a&gt; in</target>
        </trans-unit>
        <trans-unit id="56e23b6ebee018ae84e4594f62dc43eca78b4394" translate="yes" xml:space="preserve">
          <source>In strings and buffers, the only control characters allowed are those that exist in</source>
          <target state="translated">In strings and buffers, the only control characters allowed are those that exist in</target>
        </trans-unit>
        <trans-unit id="0183eea7f0857fe25abe600463b2305c9ae8752b" translate="yes" xml:space="preserve">
          <source>In subsequent sections, we will describe the details of what evaluation means for each kind of form.</source>
          <target state="translated">In subsequent sections, we will describe the details of what evaluation means for each kind of form.</target>
        </trans-unit>
        <trans-unit id="a57836ad148b9af16d39bd5e1f715466141037f4" translate="yes" xml:space="preserve">
          <source>In that case, the anonymous function is kept as a lambda expression in the compiled code. The byte-compiler cannot assume this list is a function, even though it looks like one, since it does not know that &lt;code&gt;change-property&lt;/code&gt; intends to use it as a function.</source>
          <target state="translated">In that case, the anonymous function is kept as a lambda expression in the compiled code. The byte-compiler cannot assume this list is a function, even though it looks like one, since it does not know that &lt;code&gt;change-property&lt;/code&gt; intends to use it as a function.</target>
        </trans-unit>
        <trans-unit id="b6abefb0ebc02351d5d08f8505d9c39811bfa807" translate="yes" xml:space="preserve">
          <source>In the</source>
          <target state="translated">에서</target>
        </trans-unit>
        <trans-unit id="cc52d935c1f29304f640ff4f787b205caeb68ac4" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;rx&lt;/code&gt; notation (see &lt;a href=&quot;rx-notation#Rx-Notation&quot;&gt;Rx Notation&lt;/a&gt;), the regexp could be written</source>
          <target state="translated">In the &lt;code&gt;rx&lt;/code&gt; notation (see &lt;a href=&quot;rx-notation#Rx-Notation&quot;&gt;Rx Notation&lt;/a&gt;), the regexp could be written</target>
        </trans-unit>
        <trans-unit id="edf58eb540efa82d8a13378501011be853119a74" translate="yes" xml:space="preserve">
          <source>In the above example, the index for &amp;lsquo;</source>
          <target state="translated">In the above example, the index for &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="e3f6d7d410589a0987a82033d6841e21fcb99c48" translate="yes" xml:space="preserve">
          <source>In the above pseudo-code, if a key sequence starts with a mouse event (see &lt;a href=&quot;mouse-events#Mouse-Events&quot;&gt;Mouse Events&lt;/a&gt;), that event&amp;rsquo;s position is used instead of point, and the event&amp;rsquo;s buffer is used instead of the current buffer. In particular, this affects how the &lt;code&gt;keymap&lt;/code&gt; and &lt;code&gt;local-map&lt;/code&gt; properties are looked up. If a mouse event occurs on a string embedded with a &lt;code&gt;display&lt;/code&gt;, &lt;code&gt;before-string&lt;/code&gt;, or &lt;code&gt;after-string&lt;/code&gt; property (see &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Special Properties&lt;/a&gt;), and the string has a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;keymap&lt;/code&gt; or &lt;code&gt;local-map&lt;/code&gt; property, that overrides the corresponding property in the underlying buffer text (i.e., the property specified by the underlying text is ignored).</source>
          <target state="translated">In the above pseudo-code, if a key sequence starts with a mouse event (see &lt;a href=&quot;mouse-events#Mouse-Events&quot;&gt;Mouse Events&lt;/a&gt;), that event&amp;rsquo;s position is used instead of point, and the event&amp;rsquo;s buffer is used instead of the current buffer. In particular, this affects how the &lt;code&gt;keymap&lt;/code&gt; and &lt;code&gt;local-map&lt;/code&gt; properties are looked up. If a mouse event occurs on a string embedded with a &lt;code&gt;display&lt;/code&gt; , &lt;code&gt;before-string&lt;/code&gt; , or &lt;code&gt;after-string&lt;/code&gt; property (see &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Special Properties&lt;/a&gt;), and the string has a non- &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;keymap&lt;/code&gt; or &lt;code&gt;local-map&lt;/code&gt; property, that overrides the corresponding property in the underlying buffer text (i.e., the property specified by the underlying text is ignored).</target>
        </trans-unit>
        <trans-unit id="27631bf78c7ae4e923152b090765e541b19e5a80" translate="yes" xml:space="preserve">
          <source>In the case of lexical bindings (see &lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;Variable Scoping&lt;/a&gt;), a closure is an object like any other in Emacs Lisp, and bindings in a closure are shared by any threads invoking the closure.</source>
          <target state="translated">In the case of lexical bindings (see &lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;Variable Scoping&lt;/a&gt;), a closure is an object like any other in Emacs Lisp, and bindings in a closure are shared by any threads invoking the closure.</target>
        </trans-unit>
        <trans-unit id="59e0cecfabf4546ad2f48ca811a7e72617ebf6dd" translate="yes" xml:space="preserve">
          <source>In the customization buffer, each element is displayed and edited separately, according to the type specified for it.</source>
          <target state="translated">In the customization buffer, each element is displayed and edited separately, according to the type specified for it.</target>
        </trans-unit>
        <trans-unit id="b31bdf79753cfe29ec8e26d6c3395cd18ae6e0a8" translate="yes" xml:space="preserve">
          <source>In the customization buffer, the &lt;small&gt;CAR&lt;/small&gt; and &lt;small&gt;CDR&lt;/small&gt; are displayed and edited separately, each according to their specified type.</source>
          <target state="translated">In the customization buffer, the &lt;small&gt;CAR&lt;/small&gt; and &lt;small&gt;CDR&lt;/small&gt; are displayed and edited separately, each according to their specified type.</target>
        </trans-unit>
        <trans-unit id="794a81a94829a19492d4fef3897a2f66fd03bedc" translate="yes" xml:space="preserve">
          <source>In the customization buffer, the user selects an alternative using a menu, and can then edit the value in the usual way for that alternative.</source>
          <target state="translated">In the customization buffer, the user selects an alternative using a menu, and can then edit the value in the usual way for that alternative.</target>
        </trans-unit>
        <trans-unit id="77d73a55a4ef46351e5ba12b487904babc3187bd" translate="yes" xml:space="preserve">
          <source>In the documentation string of an autoloaded command (see &lt;a href=&quot;autoload#Autoload&quot;&gt;Autoload&lt;/a&gt;), these key-substitution sequences have an additional special effect: they cause</source>
          <target state="translated">In the documentation string of an autoloaded command (see &lt;a href=&quot;autoload#Autoload&quot;&gt;Autoload&lt;/a&gt;), these key-substitution sequences have an additional special effect: they cause</target>
        </trans-unit>
        <trans-unit id="a60a213b91a605f64eb22b1f3ba89d0650b4a400" translate="yes" xml:space="preserve">
          <source>In the early days of Lisp, &lt;code&gt;progn&lt;/code&gt; was the only way to execute two or more forms in succession and use the value of the last of them. But programmers found they often needed to use a &lt;code&gt;progn&lt;/code&gt; in the body of a function, where (at that time) only one form was allowed. So the body of a function was made into an implicit &lt;code&gt;progn&lt;/code&gt;: several forms are allowed just as in the body of an actual &lt;code&gt;progn&lt;/code&gt;. Many other control structures likewise contain an implicit &lt;code&gt;progn&lt;/code&gt;. As a result, &lt;code&gt;progn&lt;/code&gt; is not used as much as it was many years ago. It is needed now most often inside an &lt;code&gt;unwind-protect&lt;/code&gt;, &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, or in the &lt;var&gt;then&lt;/var&gt;-part of an &lt;code&gt;if&lt;/code&gt;.</source>
          <target state="translated">In the early days of Lisp, &lt;code&gt;progn&lt;/code&gt; was the only way to execute two or more forms in succession and use the value of the last of them. But programmers found they often needed to use a &lt;code&gt;progn&lt;/code&gt; in the body of a function, where (at that time) only one form was allowed. So the body of a function was made into an implicit &lt;code&gt;progn&lt;/code&gt; : several forms are allowed just as in the body of an actual &lt;code&gt;progn&lt;/code&gt; . Many other control structures likewise contain an implicit &lt;code&gt;progn&lt;/code&gt; . As a result, &lt;code&gt;progn&lt;/code&gt; is not used as much as it was many years ago. It is needed now most often inside an &lt;code&gt;unwind-protect&lt;/code&gt; , &lt;code&gt;and&lt;/code&gt; , &lt;code&gt;or&lt;/code&gt; , or in the &lt;var&gt;then&lt;/var&gt; -part of an &lt;code&gt;if&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7158787e9fd5c853d586cfa0e51a5ed11d6bcd94" translate="yes" xml:space="preserve">
          <source>In the example below,</source>
          <target state="translated">In the example below,</target>
        </trans-unit>
        <trans-unit id="6ae41878d5c3d4986d366e49c3e9a986cae7e077" translate="yes" xml:space="preserve">
          <source>In the example below, &lt;code&gt;fixup-whitespace&lt;/code&gt; is called the first time with point before the word &amp;lsquo;</source>
          <target state="translated">In the example below, &lt;code&gt;fixup-whitespace&lt;/code&gt; is called the first time with point before the word &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="1159bcac76d9d797434640f0fdc5e48f8f16f786" translate="yes" xml:space="preserve">
          <source>In the example below, point is located on the line starting &amp;lsquo;</source>
          <target state="translated">In the example below, point is located on the line starting &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="41e79dffa91b26c5c432c03364763e538453a3a0" translate="yes" xml:space="preserve">
          <source>In the example below, the Lisp program reads the character</source>
          <target state="translated">In the example below, the Lisp program reads the character</target>
        </trans-unit>
        <trans-unit id="6c6b370e3f7d29753468f7d7c39505a6457cb137" translate="yes" xml:space="preserve">
          <source>In the example below, the first process is started and runs (rather, sleeps) for 100 seconds (the output buffer &amp;lsquo;</source>
          <target state="translated">In the example below, the first process is started and runs (rather, sleeps) for 100 seconds (the output buffer &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="2cbe7de5e5f4171a8b0909e3ea37d9411601b61f" translate="yes" xml:space="preserve">
          <source>In the example below, the returned alist indicates that the key</source>
          <target state="translated">In the example below, the returned alist indicates that the key</target>
        </trans-unit>
        <trans-unit id="21f639f7916c0989e45d99b6f8d95bb479e2a7dc" translate="yes" xml:space="preserve">
          <source>In the examples below, imagine that you&amp;rsquo;re in a buffer that looks like this:</source>
          <target state="translated">In the examples below, imagine that you&amp;rsquo;re in a buffer that looks like this:</target>
        </trans-unit>
        <trans-unit id="45cdf70211c7a85bbbe2f457d2d568784938c5c8" translate="yes" xml:space="preserve">
          <source>In the examples below, the buffer &amp;lsquo;</source>
          <target state="translated">In the examples below, the buffer &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="50c103b8760cb1abed49a28229f31f25093e7fe2" translate="yes" xml:space="preserve">
          <source>In the examples below, we show the &lt;em&gt;display appearance&lt;/em&gt; of the buffer &lt;code&gt;foo&lt;/code&gt;, which changes with the value of &lt;code&gt;selective-display&lt;/code&gt;. The &lt;em&gt;contents&lt;/em&gt; of the buffer do not change.</source>
          <target state="translated">In the examples below, we show the &lt;em&gt;display appearance&lt;/em&gt; of the buffer &lt;code&gt;foo&lt;/code&gt; , which changes with the value of &lt;code&gt;selective-display&lt;/code&gt; . The &lt;em&gt;contents&lt;/em&gt; of the buffer do not change.</target>
        </trans-unit>
        <trans-unit id="8d8e5189aaefce12f30329357296c95e61a38bdb" translate="yes" xml:space="preserve">
          <source>In the first example below, the user types the character</source>
          <target state="translated">In the first example below, the user types the character</target>
        </trans-unit>
        <trans-unit id="1bcb5b6f5d8b3ef6f45f427e9e77f07309f79243" translate="yes" xml:space="preserve">
          <source>In the first of the following examples, the string &amp;lsquo;</source>
          <target state="translated">In the first of the following examples, the string &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="8d216f0c7f12baf6cd4ed80a6b27ab324e470109" translate="yes" xml:space="preserve">
          <source>In the first part of the following example, we list two files,</source>
          <target state="translated">In the first part of the following example, we list two files,</target>
        </trans-unit>
        <trans-unit id="acff65f1c9d9496c4b122331f3a702dc9fa85418" translate="yes" xml:space="preserve">
          <source>In the following documentation, &lt;var&gt;spec&lt;/var&gt; refers to a data layout specification, &lt;code&gt;bindat-raw&lt;/code&gt; to a byte array, and &lt;var&gt;struct&lt;/var&gt; to an alist representing unpacked field data.</source>
          <target state="translated">In the following documentation, &lt;var&gt;spec&lt;/var&gt; refers to a data layout specification, &lt;code&gt;bindat-raw&lt;/code&gt; to a byte array, and &lt;var&gt;struct&lt;/var&gt; to an alist representing unpacked field data.</target>
        </trans-unit>
        <trans-unit id="0f00c733671a04000a05bf717e25acf161719f5a" translate="yes" xml:space="preserve">
          <source>In the following example,</source>
          <target state="translated">다음 예에서</target>
        </trans-unit>
        <trans-unit id="e2316694a9af81a8f03d3bab0408009a0c338429" translate="yes" xml:space="preserve">
          <source>In the following example, Emacs displays the prompt &amp;lsquo;</source>
          <target state="translated">In the following example, Emacs displays the prompt &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="4a721fdb8420736a6ae7cc10bb2e34400e9c7e6d" translate="yes" xml:space="preserve">
          <source>In the following example, a Lisp expression calls &lt;code&gt;backtrace&lt;/code&gt; explicitly. This prints the backtrace to the stream &lt;code&gt;standard-output&lt;/code&gt;, which, in this case, is the buffer &amp;lsquo;</source>
          <target state="translated">In the following example, a Lisp expression calls &lt;code&gt;backtrace&lt;/code&gt; explicitly. This prints the backtrace to the stream &lt;code&gt;standard-output&lt;/code&gt; , which, in this case, is the buffer &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="95ec3b70ec2b6de3a44a863ec7979700ca8528bc" translate="yes" xml:space="preserve">
          <source>In the following example, assume that the file</source>
          <target state="translated">In the following example, assume that the file</target>
        </trans-unit>
        <trans-unit id="d4d9cd6735838e19fca58cfa4e5f227b1e63a68a" translate="yes" xml:space="preserve">
          <source>In the following example, assume that the first character in the buffer is &amp;lsquo;</source>
          <target state="translated">In the following example, assume that the first character in the buffer is &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="cbbae18ed437d3d1b7cd3f29fa619c133fefd3c5" translate="yes" xml:space="preserve">
          <source>In the following example, numerous symbols begin with the characters &amp;lsquo;</source>
          <target state="translated">In the following example, numerous symbols begin with the characters &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="1d8315041ff8cb6c06515b158189a3073ed152cc" translate="yes" xml:space="preserve">
          <source>In the following example, point is at the beginning of the second line:</source>
          <target state="translated">In the following example, point is at the beginning of the second line:</target>
        </trans-unit>
        <trans-unit id="42ecbf1ba17019105911ffebbbf6edf40624a688" translate="yes" xml:space="preserve">
          <source>In the following example, point is initially at the beginning of the line. Then &lt;code&gt;(search-forward &quot;fox&quot;)&lt;/code&gt; moves point after the last letter of &amp;lsquo;</source>
          <target state="translated">In the following example, point is initially at the beginning of the line. Then &lt;code&gt;(search-forward &quot;fox&quot;)&lt;/code&gt; moves point after the last letter of &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="4e4648a8ef8c97faf71ce36a2f1da992a66ce66a" translate="yes" xml:space="preserve">
          <source>In the following example, point is initially before the &amp;lsquo;</source>
          <target state="translated">In the following example, point is initially before the &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="998eebc83fc288fc771f6a8b8a1d104df394fe25" translate="yes" xml:space="preserve">
          <source>In the following example, point is initially located directly before the &amp;lsquo;</source>
          <target state="translated">In the following example, point is initially located directly before the &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="222a580e4261f699fc64318a04a2725d2450a74c" translate="yes" xml:space="preserve">
          <source>In the following example, suppose that</source>
          <target state="translated">In the following example, suppose that</target>
        </trans-unit>
        <trans-unit id="c4a412b551b194333428c49302d54e094323961e" translate="yes" xml:space="preserve">
          <source>In the following example, suppose that the current default directory has five files whose names begin with &amp;lsquo;</source>
          <target state="translated">In the following example, suppose that the current default directory has five files whose names begin with &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="5723aa0ef8724a536d5900f5c59be1d86438116d" translate="yes" xml:space="preserve">
          <source>In the following example, the &lt;code&gt;(list 4)&lt;/code&gt; that &lt;code&gt;delq&lt;/code&gt; attempts to match and the &lt;code&gt;(4)&lt;/code&gt; in the &lt;code&gt;sample-list&lt;/code&gt; are &lt;code&gt;equal&lt;/code&gt; but not &lt;code&gt;eq&lt;/code&gt;:</source>
          <target state="translated">In the following example, the &lt;code&gt;(list 4)&lt;/code&gt; that &lt;code&gt;delq&lt;/code&gt; attempts to match and the &lt;code&gt;(4)&lt;/code&gt; in the &lt;code&gt;sample-list&lt;/code&gt; are &lt;code&gt;equal&lt;/code&gt; but not &lt;code&gt;eq&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="49c3d7898ccead7f82ec14a83d5c284abbacaed2" translate="yes" xml:space="preserve">
          <source>In the following example, the function &lt;code&gt;simple-rec&lt;/code&gt; first advances point one word, then enters a recursive edit, printing out a message in the echo area. The user can then do any editing desired, and then type</source>
          <target state="translated">In the following example, the function &lt;code&gt;simple-rec&lt;/code&gt; first advances point one word, then enters a recursive edit, printing out a message in the echo area. The user can then do any editing desired, and then type</target>
        </trans-unit>
        <trans-unit id="bdd55f89db54776fce5243ffc69b1e9e59acdf44" translate="yes" xml:space="preserve">
          <source>In the following example, the user enters &amp;lsquo;</source>
          <target state="translated">In the following example, the user enters &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="7407d41abc6236fc89ae0cd2ce1bcece190e1422" translate="yes" xml:space="preserve">
          <source>In the following example, the user may type a number of characters right after starting the evaluation of the form. After the &lt;code&gt;sleep-for&lt;/code&gt; finishes sleeping, &lt;code&gt;discard-input&lt;/code&gt; discards any characters typed during the sleep.</source>
          <target state="translated">In the following example, the user may type a number of characters right after starting the evaluation of the form. After the &lt;code&gt;sleep-for&lt;/code&gt; finishes sleeping, &lt;code&gt;discard-input&lt;/code&gt; discards any characters typed during the sleep.</target>
        </trans-unit>
        <trans-unit id="f7696bfce1413c1620baa40974e9b096f97b1062" translate="yes" xml:space="preserve">
          <source>In the following example, the user types in the octal number 177 (which is 127 in decimal).</source>
          <target state="translated">In the following example, the user types in the octal number 177 (which is 127 in decimal).</target>
        </trans-unit>
        <trans-unit id="90031aaefbae5ba18088f25e005afdff8b8be5df" translate="yes" xml:space="preserve">
          <source>In the following example, we define a &lt;code&gt;change-property&lt;/code&gt; function that takes a function as its third argument, followed by a &lt;code&gt;double-property&lt;/code&gt; function that makes use of &lt;code&gt;change-property&lt;/code&gt; by passing it an anonymous function:</source>
          <target state="translated">In the following example, we define a &lt;code&gt;change-property&lt;/code&gt; function that takes a function as its third argument, followed by a &lt;code&gt;double-property&lt;/code&gt; function that makes use of &lt;code&gt;change-property&lt;/code&gt; by passing it an anonymous function:</target>
        </trans-unit>
        <trans-unit id="9a1fd088e9ae4b7e83b043fac095f41e72df8bbd" translate="yes" xml:space="preserve">
          <source>In the following example, we make</source>
          <target state="translated">In the following example, we make</target>
        </trans-unit>
        <trans-unit id="f9648cfc2ef9e1392db8901e3933f175d8a84fca" translate="yes" xml:space="preserve">
          <source>In the following example, we offer the user an expression with initial text that is already a valid form:</source>
          <target state="translated">In the following example, we offer the user an expression with initial text that is already a valid form:</target>
        </trans-unit>
        <trans-unit id="2e3e4218ff460b22a5180b17ddb295a8da5eceae" translate="yes" xml:space="preserve">
          <source>In the following example, we set the value of a symbol with &lt;code&gt;setq&lt;/code&gt;. Then we evaluate the symbol, and get back the value that &lt;code&gt;setq&lt;/code&gt; stored.</source>
          <target state="translated">In the following example, we set the value of a symbol with &lt;code&gt;setq&lt;/code&gt; . Then we evaluate the symbol, and get back the value that &lt;code&gt;setq&lt;/code&gt; stored.</target>
        </trans-unit>
        <trans-unit id="f311afb8bd19dedc75d6adda2a147ef509e3a73e" translate="yes" xml:space="preserve">
          <source>In the following example, we use &lt;code&gt;call-process-region&lt;/code&gt; to run the &lt;code&gt;cat&lt;/code&gt; utility, with standard input being the first five characters in buffer &amp;lsquo;</source>
          <target state="translated">In the following example, we use &lt;code&gt;call-process-region&lt;/code&gt; to run the &lt;code&gt;cat&lt;/code&gt; utility, with standard input being the first five characters in buffer &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="2ed30191890b49ad905f6c690d281609333d59e9" translate="yes" xml:space="preserve">
          <source>In the following examples, we call &lt;code&gt;delete-horizontal-space&lt;/code&gt; four times, once on each line, with point between the second and third characters on the line each time.</source>
          <target state="translated">In the following examples, we call &lt;code&gt;delete-horizontal-space&lt;/code&gt; four times, once on each line, with point between the second and third characters on the line each time.</target>
        </trans-unit>
        <trans-unit id="d73b2eb7e108f2274f2167b405818a1a4e5e8de9" translate="yes" xml:space="preserve">
          <source>In the following four functions, &amp;ldquo;beginning&amp;rdquo; or &amp;ldquo;end&amp;rdquo; of buffer refers to the beginning or end of the accessible portion.</source>
          <target state="translated">In the following four functions, &amp;ldquo;beginning&amp;rdquo; or &amp;ldquo;end&amp;rdquo; of buffer refers to the beginning or end of the accessible portion.</target>
        </trans-unit>
        <trans-unit id="b77941da969f1ea78534b72b05e1f2ecd1399269" translate="yes" xml:space="preserve">
          <source>In the functions below, &lt;var&gt;stream&lt;/var&gt; stands for an input stream (see the previous section). If &lt;var&gt;stream&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; or omitted, it defaults to the value of &lt;code&gt;standard-input&lt;/code&gt;.</source>
          <target state="translated">In the functions below, &lt;var&gt;stream&lt;/var&gt; stands for an input stream (see the previous section). If &lt;var&gt;stream&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; or omitted, it defaults to the value of &lt;code&gt;standard-input&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e02f70d33a63dec1a218a9f9fe21d0936515a768" translate="yes" xml:space="preserve">
          <source>In the functions below, &lt;var&gt;stream&lt;/var&gt; stands for an output stream. (See the previous section for a description of output streams. Also See &lt;a href=&quot;output-streams#external_002ddebugging_002doutput&quot;&gt;external-debugging-output&lt;/a&gt;, a useful stream value for debugging.) If &lt;var&gt;stream&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; or omitted, it defaults to the value of &lt;code&gt;standard-output&lt;/code&gt;.</source>
          <target state="translated">In the functions below, &lt;var&gt;stream&lt;/var&gt; stands for an output stream. (See the previous section for a description of output streams. Also See &lt;a href=&quot;output-streams#external_002ddebugging_002doutput&quot;&gt;external-debugging-output&lt;/a&gt;, a useful stream value for debugging.) If &lt;var&gt;stream&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; or omitted, it defaults to the value of &lt;code&gt;standard-output&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="842ff05e729e0c493fb0e3ce6cf4160def60f98a" translate="yes" xml:space="preserve">
          <source>In the functions that have an argument &lt;var&gt;newname&lt;/var&gt;, if a file by the name of &lt;var&gt;newname&lt;/var&gt; already exists, the actions taken depend on the value of the argument &lt;var&gt;ok-if-already-exists&lt;/var&gt;:</source>
          <target state="translated">In the functions that have an argument &lt;var&gt;newname&lt;/var&gt; , if a file by the name of &lt;var&gt;newname&lt;/var&gt; already exists, the actions taken depend on the value of the argument &lt;var&gt;ok-if-already-exists&lt;/var&gt; :</target>
        </trans-unit>
        <trans-unit id="b9986edbcc327565facd71c28fb47353a1513f05" translate="yes" xml:space="preserve">
          <source>In the functions that have an argument &lt;var&gt;newname&lt;/var&gt;, if this argument is a directory name it is treated as if the nondirectory part of the source name were appended. Typically, a directory name is one that ends in &amp;lsquo;</source>
          <target state="translated">In the functions that have an argument &lt;var&gt;newname&lt;/var&gt; , if this argument is a directory name it is treated as if the nondirectory part of the source name were appended. Typically, a directory name is one that ends in &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="3ff38bdd102a36bf5dad69f0bd3a4c48bcbb2f33" translate="yes" xml:space="preserve">
          <source>In the minibuffer,</source>
          <target state="translated">In the minibuffer,</target>
        </trans-unit>
        <trans-unit id="95d42950506f5e85d9c00b2291550dcad572692d" translate="yes" xml:space="preserve">
          <source>In the new syntax table, all characters are initially given the &amp;ldquo;inherit&amp;rdquo; (&amp;lsquo;</source>
          <target state="translated">In the new syntax table, all characters are initially given the &amp;ldquo;inherit&amp;rdquo; (&amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="654197206043d5aa17cba42455172c4d80bf915c" translate="yes" xml:space="preserve">
          <source>In the output, tab and newline appear as themselves.</source>
          <target state="translated">In the output, tab and newline appear as themselves.</target>
        </trans-unit>
        <trans-unit id="f0a865aff1bbfb0c542ac415212a86fda6d690da" translate="yes" xml:space="preserve">
          <source>In the parse tree, each HTML node is represented by a list in which the first element is a symbol representing the node name, the second element is an alist of node attributes, and the remaining elements are the subnodes.</source>
          <target state="translated">In the parse tree, each HTML node is represented by a list in which the first element is a symbol representing the node name, the second element is an alist of node attributes, and the remaining elements are the subnodes.</target>
        </trans-unit>
        <trans-unit id="a6aa826dba60e33cee2ff73324e1dfc071fd99de" translate="yes" xml:space="preserve">
          <source>In the previous section, the definition of &lt;code&gt;for&lt;/code&gt; was fixed as follows to make the expansion evaluate the macro arguments the proper number of times:</source>
          <target state="translated">In the previous section, the definition of &lt;code&gt;for&lt;/code&gt; was fixed as follows to make the expansion evaluate the macro arguments the proper number of times:</target>
        </trans-unit>
        <trans-unit id="d94acc49f6466170529c5b4de675f17843e1d018" translate="yes" xml:space="preserve">
          <source>In the previous sections we have described how to construct elaborate type specifications for &lt;code&gt;defcustom&lt;/code&gt;. In some cases you may want to give such a type specification a name. The obvious case is when you are using the same type for many user options: rather than repeat the specification for each option, you can give the type specification a name, and use that name each &lt;code&gt;defcustom&lt;/code&gt;. The other case is when a user option&amp;rsquo;s value is a recursive data structure. To make it possible for a datatype to refer to itself, it needs to have a name.</source>
          <target state="translated">In the previous sections we have described how to construct elaborate type specifications for &lt;code&gt;defcustom&lt;/code&gt; . In some cases you may want to give such a type specification a name. The obvious case is when you are using the same type for many user options: rather than repeat the specification for each option, you can give the type specification a name, and use that name each &lt;code&gt;defcustom&lt;/code&gt; . The other case is when a user option&amp;rsquo;s value is a recursive data structure. To make it possible for a datatype to refer to itself, it needs to have a name.</target>
        </trans-unit>
        <trans-unit id="e1fe76b2ce299aa2f258889220086dc41caa10db" translate="yes" xml:space="preserve">
          <source>In the previous subsection we have described in detail how individual action functions interpret the action alist entries they care about. Here we give a reference list of all known action alist entries according to their symbols, together with their values and action functions (see &lt;a href=&quot;buffer-display-action-functions#Buffer-Display-Action-Functions&quot;&gt;Buffer Display Action Functions&lt;/a&gt;) that recognize them. Throughout this list, the terms &amp;ldquo;buffer&amp;rdquo; will refer to the buffer &lt;code&gt;display-buffer&lt;/code&gt; is supposed to display, and &amp;ldquo;value&amp;rdquo; refers to the entry&amp;rsquo;s value.</source>
          <target state="translated">In the previous subsection we have described in detail how individual action functions interpret the action alist entries they care about. Here we give a reference list of all known action alist entries according to their symbols, together with their values and action functions (see &lt;a href=&quot;buffer-display-action-functions#Buffer-Display-Action-Functions&quot;&gt;Buffer Display Action Functions&lt;/a&gt;) that recognize them. Throughout this list, the terms &amp;ldquo;buffer&amp;rdquo; will refer to the buffer &lt;code&gt;display-buffer&lt;/code&gt; is supposed to display, and &amp;ldquo;value&amp;rdquo; refers to the entry&amp;rsquo;s value.</target>
        </trans-unit>
        <trans-unit id="70305cb871bf1fadf003b84d92f8f772b2e037ea" translate="yes" xml:space="preserve">
          <source>In the return value, &lt;var&gt;function&lt;/var&gt; is whatever was supplied as the &lt;small&gt;CAR&lt;/small&gt; of the evaluated list, or a &lt;code&gt;lambda&lt;/code&gt; expression in the case of a macro call. If the function has a &lt;code&gt;&amp;amp;rest&lt;/code&gt; argument, that is represented as the tail of the list &lt;var&gt;arg-values&lt;/var&gt;.</source>
          <target state="translated">In the return value, &lt;var&gt;function&lt;/var&gt; is whatever was supplied as the &lt;small&gt;CAR&lt;/small&gt; of the evaluated list, or a &lt;code&gt;lambda&lt;/code&gt; expression in the case of a macro call. If the function has a &lt;code&gt;&amp;amp;rest&lt;/code&gt; argument, that is represented as the tail of the list &lt;var&gt;arg-values&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="a43342cb008eceb0301dec01749bcef5885ffad6" translate="yes" xml:space="preserve">
          <source>In the second expression, the local binding of &lt;code&gt;print-escape-newlines&lt;/code&gt; is in effect during the call to &lt;code&gt;prin1&lt;/code&gt;, but not during the printing of the result.</source>
          <target state="translated">In the second expression, the local binding of &lt;code&gt;print-escape-newlines&lt;/code&gt; is in effect during the call to &lt;code&gt;prin1&lt;/code&gt; , but not during the printing of the result.</target>
        </trans-unit>
        <trans-unit id="780bba30b6e90faed0e2ade0fdd2f1da2fdca85f" translate="yes" xml:space="preserve">
          <source>In the second variant, the choice of lines to hide is made automatically based on indentation. This variant is designed to be a user-level feature.</source>
          <target state="translated">In the second variant, the choice of lines to hide is made automatically based on indentation. This variant is designed to be a user-level feature.</target>
        </trans-unit>
        <trans-unit id="bffc354f8e26188db7e818c849dff5db0c9e8f32" translate="yes" xml:space="preserve">
          <source>In the simplest case, &lt;var&gt;listname&lt;/var&gt; is an unquoted symbol naming a list; in that case, this macro is equivalent to &lt;code&gt;(prog1&amp;nbsp;(car&amp;nbsp;listname)&amp;nbsp;(setq&amp;nbsp;listname&amp;nbsp;(cdr&amp;nbsp;listname)))&lt;/code&gt;.</source>
          <target state="translated">In the simplest case, &lt;var&gt;listname&lt;/var&gt; is an unquoted symbol naming a list; in that case, this macro is equivalent to &lt;code&gt;(prog1&amp;nbsp;(car&amp;nbsp;listname)&amp;nbsp;(setq&amp;nbsp;listname&amp;nbsp;(cdr&amp;nbsp;listname)))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6677923bd341b8f53bd4e45ad643c994637a35f0" translate="yes" xml:space="preserve">
          <source>In the simplest case, &lt;var&gt;separator-type&lt;/var&gt; consists of only dashes. That specifies the default kind of separator. (For compatibility, &lt;code&gt;&quot;&quot;&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt; also count as separators.)</source>
          <target state="translated">In the simplest case, &lt;var&gt;separator-type&lt;/var&gt; consists of only dashes. That specifies the default kind of separator. (For compatibility, &lt;code&gt;&quot;&quot;&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt; also count as separators.)</target>
        </trans-unit>
        <trans-unit id="4ac8ea59e19025468a89992b0f2dbc087cbc7d49" translate="yes" xml:space="preserve">
          <source>In the simplest case, any non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;invisible&lt;/code&gt; property makes a character invisible. This is the default case&amp;mdash;if you don&amp;rsquo;t alter the default value of &lt;code&gt;buffer-invisibility-spec&lt;/code&gt;, this is how the &lt;code&gt;invisible&lt;/code&gt; property works. You should normally use &lt;code&gt;t&lt;/code&gt; as the value of the &lt;code&gt;invisible&lt;/code&gt; property if you don&amp;rsquo;t plan to set &lt;code&gt;buffer-invisibility-spec&lt;/code&gt; yourself.</source>
          <target state="translated">In the simplest case, any non- &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;invisible&lt;/code&gt; property makes a character invisible. This is the default case&amp;mdash;if you don&amp;rsquo;t alter the default value of &lt;code&gt;buffer-invisibility-spec&lt;/code&gt; , this is how the &lt;code&gt;invisible&lt;/code&gt; property works. You should normally use &lt;code&gt;t&lt;/code&gt; as the value of the &lt;code&gt;invisible&lt;/code&gt; property if you don&amp;rsquo;t plan to set &lt;code&gt;buffer-invisibility-spec&lt;/code&gt; yourself.</target>
        </trans-unit>
        <trans-unit id="b654a675313cc501deccb72dafb7cf632e0a67de" translate="yes" xml:space="preserve">
          <source>In the string representation, alphanumeric characters ordinarily stand for themselves; for example, &lt;code&gt;&quot;a&quot;&lt;/code&gt; represents</source>
          <target state="translated">In the string representation, alphanumeric characters ordinarily stand for themselves; for example, &lt;code&gt;&quot;a&quot;&lt;/code&gt; represents</target>
        </trans-unit>
        <trans-unit id="68ea687212db99586a26415019a5a3e01bea5f4c" translate="yes" xml:space="preserve">
          <source>In the terminology of operating systems, a &lt;em&gt;process&lt;/em&gt; is a space in which a program can execute. Emacs runs in a process. Emacs Lisp programs can invoke other programs in processes of their own. These are called &lt;em&gt;subprocesses&lt;/em&gt; or &lt;em&gt;child processes&lt;/em&gt; of the Emacs process, which is their &lt;em&gt;parent process&lt;/em&gt;.</source>
          <target state="translated">In the terminology of operating systems, a &lt;em&gt;process&lt;/em&gt; is a space in which a program can execute. Emacs runs in a process. Emacs Lisp programs can invoke other programs in processes of their own. These are called &lt;em&gt;subprocesses&lt;/em&gt; or &lt;em&gt;child processes&lt;/em&gt; of the Emacs process, which is their &lt;em&gt;parent process&lt;/em&gt;.</target>
        </trans-unit>
        <trans-unit id="20d433bd64cf194bf3401eb20026d1e5a072b7d8" translate="yes" xml:space="preserve">
          <source>In the unlikely event that you need a more general functionality than &lt;code&gt;custom-initialize-delay&lt;/code&gt; provides, you can use &lt;code&gt;before-init-hook&lt;/code&gt; (see &lt;a href=&quot;startup-summary#Startup-Summary&quot;&gt;Startup Summary&lt;/a&gt;).</source>
          <target state="translated">In the unlikely event that you need a more general functionality than &lt;code&gt;custom-initialize-delay&lt;/code&gt; provides, you can use &lt;code&gt;before-init-hook&lt;/code&gt; (see &lt;a href=&quot;startup-summary#Startup-Summary&quot;&gt;Startup Summary&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="653d17f655aa9bc207c0340a07989c300bfc7174" translate="yes" xml:space="preserve">
          <source>In the vector representation, each element of the vector represents an input event, in its Lisp form. See &lt;a href=&quot;input-events#Input-Events&quot;&gt;Input Events&lt;/a&gt;. For example, the vector &lt;code&gt;[?\C-x ?l]&lt;/code&gt; represents the key sequence</source>
          <target state="translated">In the vector representation, each element of the vector represents an input event, in its Lisp form. See &lt;a href=&quot;input-events#Input-Events&quot;&gt;Input Events&lt;/a&gt;. For example, the vector &lt;code&gt;[?\C-x ?l]&lt;/code&gt; represents the key sequence</target>
        </trans-unit>
        <trans-unit id="37545e5ede88b47c3c895f58d985de6aa2297176" translate="yes" xml:space="preserve">
          <source>In their most simple form of use, side windows allow to display specific buffers always in the same area of a frame. Hence they can be regarded as a generalization of the concept provided by &lt;code&gt;display-buffer-at-bottom&lt;/code&gt; (see &lt;a href=&quot;buffer-display-action-functions#Buffer-Display-Action-Functions&quot;&gt;Buffer Display Action Functions&lt;/a&gt;) to the remaining sides of a frame. With suitable customizations, however, side windows can be also used to provide frame layouts similar to those found in so-called integrated development environments (IDEs).</source>
          <target state="translated">In their most simple form of use, side windows allow to display specific buffers always in the same area of a frame. Hence they can be regarded as a generalization of the concept provided by &lt;code&gt;display-buffer-at-bottom&lt;/code&gt; (see &lt;a href=&quot;buffer-display-action-functions#Buffer-Display-Action-Functions&quot;&gt;Buffer Display Action Functions&lt;/a&gt;) to the remaining sides of a frame. With suitable customizations, however, side windows can be also used to provide frame layouts similar to those found in so-called integrated development environments (IDEs).</target>
        </trans-unit>
        <trans-unit id="4da8e1cd8146f3a0b7e768a0095492966a0a3fcb" translate="yes" xml:space="preserve">
          <source>In theory, a theme file can also contain other Lisp forms, which would be evaluated when loading the theme, but that is bad form. To protect against loading themes containing malicious code, Emacs displays the source file and asks for confirmation from the user before loading any non-built-in theme for the first time. As such, themes are not ordinarily byte-compiled, and source files always take precedence when Emacs is looking for a theme to load.</source>
          <target state="translated">In theory, a theme file can also contain other Lisp forms, which would be evaluated when loading the theme, but that is bad form. To protect against loading themes containing malicious code, Emacs displays the source file and asks for confirmation from the user before loading any non-built-in theme for the first time. As such, themes are not ordinarily byte-compiled, and source files always take precedence when Emacs is looking for a theme to load.</target>
        </trans-unit>
        <trans-unit id="bdc0c811869c12153b361b16802c27840ea05add" translate="yes" xml:space="preserve">
          <source>In these functions, the &lt;var&gt;process&lt;/var&gt; argument can be a process or the name of a process, or a buffer or buffer name (which stands for a process via &lt;code&gt;get-buffer-process&lt;/code&gt;). &lt;code&gt;nil&lt;/code&gt; means the current buffer&amp;rsquo;s process.</source>
          <target state="translated">In these functions, the &lt;var&gt;process&lt;/var&gt; argument can be a process or the name of a process, or a buffer or buffer name (which stands for a process via &lt;code&gt;get-buffer-process&lt;/code&gt; ). &lt;code&gt;nil&lt;/code&gt; means the current buffer&amp;rsquo;s process.</target>
        </trans-unit>
        <trans-unit id="7889cf29aeb64d8679d013ba57b97d89a395974a" translate="yes" xml:space="preserve">
          <source>In this case &lt;code&gt;with-temp-buffer-window&lt;/code&gt; always makes a new parent window when it splits an existing window (see &lt;a href=&quot;temporary-displays#Temporary-Displays&quot;&gt;Temporary Displays&lt;/a&gt;). Otherwise, window splitting behaves as for &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">이 경우 &lt;code&gt;with-temp-buffer-window&lt;/code&gt; 는 기존 창을 분할 할 때 항상 새 부모 창을 만듭니다 ( &lt;a href=&quot;temporary-displays#Temporary-Displays&quot;&gt;임시 디스플레이&lt;/a&gt; 참조 ). 그렇지 않으면 창 분할은 &lt;code&gt;nil&lt;/code&gt; 처럼 동작 합니다.</target>
        </trans-unit>
        <trans-unit id="4aad296f13c9498890681b6eab23e4731825c14d" translate="yes" xml:space="preserve">
          <source>In this case &lt;code&gt;with-temp-buffer-window&lt;/code&gt; makes a new parent window when it splits a window and &lt;code&gt;temp-buffer-resize-mode&lt;/code&gt; is enabled (see &lt;a href=&quot;temporary-displays#Temporary-Displays&quot;&gt;Temporary Displays&lt;/a&gt;). Otherwise, window splitting behaves as for &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">이 경우 &lt;code&gt;with-temp-buffer-window&lt;/code&gt; 는 창을 분할하고 &lt;code&gt;temp-buffer-resize-mode&lt;/code&gt; 가 활성화 될 때 새 부모 창을 만듭니다 ( &lt;a href=&quot;temporary-displays#Temporary-Displays&quot;&gt;임시 디스플레이&lt;/a&gt; 참조 ). 그렇지 않으면 창 분할은 &lt;code&gt;nil&lt;/code&gt; 처럼 동작 합니다.</target>
        </trans-unit>
        <trans-unit id="f92ba4ac4b99574f776831ff1c5804087ad33c57" translate="yes" xml:space="preserve">
          <source>In this case the &lt;code&gt;inhibit-same-window&lt;/code&gt; alist entry will successfully invalidate the &lt;code&gt;display-buffer-same-window&lt;/code&gt; specification from &lt;code&gt;display-buffer-overriding-action&lt;/code&gt; and &lt;code&gt;display-buffer&lt;/code&gt; will show</source>
          <target state="translated">이 경우 &lt;code&gt;inhibit-same-window&lt;/code&gt; alist 항목이 성공적으로 무효화 &lt;code&gt;display-buffer-same-window&lt;/code&gt; 에서 스펙 &lt;code&gt;display-buffer-overriding-action&lt;/code&gt; 및 &lt;code&gt;display-buffer&lt;/code&gt; 표시한다</target>
        </trans-unit>
        <trans-unit id="04b2213a63614ac8251b3c7bc455f4e8850855b5" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;&quot;prolog&quot;&lt;/code&gt; is the name of the file to load, 169681 refers to the documentation string in the</source>
          <target state="translated">이 경우 &lt;code&gt;&quot;prolog&quot;&lt;/code&gt; 는로드 할 파일의 이름이고 169681은</target>
        </trans-unit>
        <trans-unit id="8e648e458f3c001b5d685c0aaee6c84fe234be3f" translate="yes" xml:space="preserve">
          <source>In this case, the &lt;small&gt;CDR&lt;/small&gt; of the association &lt;code&gt;(lily white)&lt;/code&gt; is not the symbol &lt;code&gt;white&lt;/code&gt;, but rather the list &lt;code&gt;(white)&lt;/code&gt;. This becomes clearer if the association is written in dotted pair notation:</source>
          <target state="translated">이 경우 연관 의 &lt;small&gt;CDR &lt;/small&gt; &lt;code&gt;(lily white)&lt;/code&gt; 은 &lt;code&gt;white&lt;/code&gt; 기호가 아니라 목록 &lt;code&gt;(white)&lt;/code&gt; 입니다. 연관이 점선 표기법으로 작성되면 더 명확 해집니다.</target>
        </trans-unit>
        <trans-unit id="5c978b1007a3cfab25727c041633a410661259c5" translate="yes" xml:space="preserve">
          <source>In this case, the process is not truly synchronous, since it can run in parallel with Emacs; but you can think of it as synchronous in that Emacs is essentially finished with the subprocess as soon as this function returns.</source>
          <target state="translated">이 경우 프로세스는 Emacs와 병렬로 실행될 수 있기 때문에 진정한 동기식이 아닙니다. 그러나이 함수가 반환되는 즉시 Emacs가 기본적으로 하위 프로세스로 완료된다는 점에서 동기식으로 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fc1a62b1e8add3600030a618eb06b7554d262e1" translate="yes" xml:space="preserve">
          <source>In this diagram, each box represents a slot that can hold or refer to any Lisp object. Each pair of boxes represents a cons cell. Each arrow represents a reference to a Lisp object, either an atom or another cons cell.</source>
          <target state="translated">이 다이어그램에서 각 상자는 Lisp 개체를 보유하거나 참조 할 수있는 슬롯을 나타냅니다. 각 상자 쌍은 단점 셀을 나타냅니다. 각 화살표는 원자 또는 다른 단점 셀인 Lisp 개체에 대한 참조를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5189ea2c15eedb2e76964428691f1c5cd904bd9e" translate="yes" xml:space="preserve">
          <source>In this example, point is between the &amp;lsquo;</source>
          <target state="translated">이 예에서 포인트는 '</target>
        </trans-unit>
        <trans-unit id="f7926c062dd5a0ff5ef38fa8e29790f6b8333d0b" translate="yes" xml:space="preserve">
          <source>In this example, point is initially at the beginning of the buffer; the search leaves it between the &amp;lsquo;</source>
          <target state="translated">이 예에서 포인트는 처음에 버퍼의 시작 부분에 있습니다. 검색은 '</target>
        </trans-unit>
        <trans-unit id="8a9cce26338257a7f7f918d357295fda94e21a00" translate="yes" xml:space="preserve">
          <source>In this example, point is initially located at the beginning of the second line:</source>
          <target state="translated">이 예에서 point는 처음에 두 번째 줄의 시작 부분에 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c8ac6b39fdaea7c1429c01fa50b5a383964f56c" translate="yes" xml:space="preserve">
          <source>In this example, point is located directly before the &amp;lsquo;</source>
          <target state="translated">이 예에서 점은 '</target>
        </trans-unit>
        <trans-unit id="3576b093aaf2ac699eaa7e91d03edb88bd5e4be3" translate="yes" xml:space="preserve">
          <source>In this example, the first box, which holds the &lt;small&gt;CAR&lt;/small&gt; of the first cons cell, refers to or holds &lt;code&gt;rose&lt;/code&gt; (a symbol). The second box, holding the &lt;small&gt;CDR&lt;/small&gt; of the first cons cell, refers to the next pair of boxes, the second cons cell. The &lt;small&gt;CAR&lt;/small&gt; of the second cons cell is &lt;code&gt;violet&lt;/code&gt;, and its &lt;small&gt;CDR&lt;/small&gt; is the third cons cell. The &lt;small&gt;CDR&lt;/small&gt; of the third (and last) cons cell is &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">이 예 에서 첫 번째 cons 셀 의 &lt;small&gt;CAR&lt;/small&gt; 을 보유하는 첫 번째 상자 는 &lt;code&gt;rose&lt;/code&gt; (기호)를 참조하거나 보유 합니다. 첫 번째 cons 셀 의 &lt;small&gt;CDR&lt;/small&gt; 을 보유하는 두 번째 상자 는 다음 상자 쌍인 두 번째 cons 셀을 참조합니다. 두 번째 cons 셀 의 &lt;small&gt;CAR&lt;/small&gt; 은 &lt;code&gt;violet&lt;/code&gt; 이고 &lt;small&gt;CDR&lt;/small&gt; 은 세 번째 cons 셀입니다. 세 번째 (및 마지막) 단점 셀 의 &lt;small&gt;CDR&lt;/small&gt; 은 &lt;code&gt;nil&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="73de656109b1553b872ecb7b04fd7edf5fcf976d" translate="yes" xml:space="preserve">
          <source>In this example, the form is executed with buffer &amp;lsquo;</source>
          <target state="translated">이 예제에서 폼은 버퍼 '</target>
        </trans-unit>
        <trans-unit id="4b9029e7a66aa0c9f8ca4c799ed66e0cfbb79118" translate="yes" xml:space="preserve">
          <source>In this example, the index for &amp;lsquo;</source>
          <target state="translated">이 예에서 '</target>
        </trans-unit>
        <trans-unit id="764b384a226e6ab33f5227fab6776af37eb99b70" translate="yes" xml:space="preserve">
          <source>In this example, the interpreted code required 10 seconds to run, whereas the byte-compiled code required less than 4 seconds. These results are representative, but actual results may vary.</source>
          <target state="translated">이 예제에서 해석 된 코드는 실행하는 데 10 초가 소요되는 반면, 바이트 컴파일 된 코드는 4 초 미만이 소요되었습니다. 이러한 결과는 대표적이지만 실제 결과는 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c60d69a652292ccff830c67c8d2351ad5e5e0b6" translate="yes" xml:space="preserve">
          <source>In this example, the value says that</source>
          <target state="translated">이 예에서 값은</target>
        </trans-unit>
        <trans-unit id="bf4b9ec25e056b797f6607ca8b59766a3a808319" translate="yes" xml:space="preserve">
          <source>In this kind of element, &lt;var&gt;anchored-highlighter&lt;/var&gt; specifies how to highlight text that follows a match found by &lt;var&gt;matcher&lt;/var&gt;. So a match found by &lt;var&gt;matcher&lt;/var&gt; acts as the anchor for further searches specified by &lt;var&gt;anchored-highlighter&lt;/var&gt;. &lt;var&gt;anchored-highlighter&lt;/var&gt; is a list of the following form:</source>
          <target state="translated">이러한 종류의 요소에서 &lt;var&gt;anchored-highlighter&lt;/var&gt; 는 &lt;var&gt;matcher&lt;/var&gt; 에서 찾은 일치를 따르는 텍스트를 강조 표시하는 방법을 지정합니다 . 따라서 &lt;var&gt;matcher&lt;/var&gt; 에서 찾은 일치 항목 은 &lt;var&gt;anchored-highlighter&lt;/var&gt; 로 지정된 추가 검색에 대한 앵커 역할을합니다 . &lt;var&gt;anchored-highlighter&lt;/var&gt; 는 다음 형식의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="8f400ef8e587e9e01e8f55ffe8f0804f11bd1102" translate="yes" xml:space="preserve">
          <source>In this kind of element, &lt;var&gt;facespec&lt;/var&gt; is an expression whose value specifies the face to use for highlighting. In the simplest case, &lt;var&gt;facespec&lt;/var&gt; is a Lisp variable (a symbol) whose value is a face name.</source>
          <target state="translated">이러한 종류의 요소에서 &lt;var&gt;facespec&lt;/var&gt; 은 강조 표시에 사용할 얼굴을 값이 지정하는 표현식입니다. 가장 간단한 경우에 &lt;var&gt;facespec&lt;/var&gt; 은 값이 얼굴 이름 인 Lisp 변수 (기호)입니다.</target>
        </trans-unit>
        <trans-unit id="d0f3cf4781874539fca8b12ffa575360a97062a3" translate="yes" xml:space="preserve">
          <source>In this kind of element, &lt;var&gt;matcher&lt;/var&gt; is either a regular expression or a function, as described above. The &lt;small&gt;CDR&lt;/small&gt;, &lt;var&gt;subexp&lt;/var&gt;, specifies which subexpression of &lt;var&gt;matcher&lt;/var&gt; should be highlighted (instead of the entire text that &lt;var&gt;matcher&lt;/var&gt; matched).</source>
          <target state="translated">이러한 종류의 요소에서 &lt;var&gt;matcher&lt;/var&gt; 는 위에서 설명한 것처럼 정규식 또는 함수입니다. &lt;small&gt;CDR&lt;/small&gt; , &lt;var&gt;subexp&lt;/var&gt; 의 표현식 지정 &lt;var&gt;matcher&lt;/var&gt; 강조되어야한다 (그 대신, 전체 텍스트 &lt;var&gt;matcher&lt;/var&gt; 일치).</target>
        </trans-unit>
        <trans-unit id="d4c92f44f29e6a508a88862991fc4849cfa01b75" translate="yes" xml:space="preserve">
          <source>In this kind of element, &lt;var&gt;subexp-highlighter&lt;/var&gt; is a list which specifies how to highlight matches found by &lt;var&gt;matcher&lt;/var&gt;. It has the form:</source>
          <target state="translated">이러한 종류의 요소에서 &lt;var&gt;subexp-highlighter&lt;/var&gt; 는 &lt;var&gt;matcher&lt;/var&gt; 에서 찾은 일치 항목을 강조 표시하는 방법을 지정하는 목록입니다 . 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="65868b57f4589aab73c360fb6e9e308010443437" translate="yes" xml:space="preserve">
          <source>In this manual, we write &lt;code&gt;()&lt;/code&gt; when we wish to emphasize that it means the empty list, and we write &lt;code&gt;nil&lt;/code&gt; when we wish to emphasize that it means the truth value &lt;var&gt;false&lt;/var&gt;. That is a good convention to use in Lisp programs also.</source>
          <target state="translated">이 매뉴얼에서 우리 는 그것이 빈 목록을 의미 함을 강조하고 싶을 때 &lt;code&gt;()&lt;/code&gt; 를 쓰고 , 그것이 진실 값 &lt;var&gt;false&lt;/var&gt; 를 의미한다는 것을 강조하고 싶을 때 &lt;code&gt;nil&lt;/code&gt; 을 씁니다 . Lisp 프로그램에서도 사용하기에 좋은 규칙입니다.</target>
        </trans-unit>
        <trans-unit id="af20502ec39925ff9d9d9c1f4f7cbd4800bb2ffe" translate="yes" xml:space="preserve">
          <source>In this next example, point is between the &amp;lsquo;</source>
          <target state="translated">다음 예에서 포인트는 '</target>
        </trans-unit>
        <trans-unit id="5b3dc1e84019e82e89cd0988c8c5c64866bf8ed9" translate="yes" xml:space="preserve">
          <source>In this scenario, &lt;code&gt;jsonrpc-connection&lt;/code&gt; is subclassed to implement a different underlying transport strategy (for details on how to subclass, see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/eieio/Inheritance.html#Inheritance&quot;&gt;(eieio)Inheritance&lt;/a&gt;.). Users of the application-building interface can then instantiate objects of this concrete class (using the &lt;code&gt;make-instance&lt;/code&gt; function) and connect to JSONRPC endpoints using that strategy.</source>
          <target state="translated">이 시나리오에서 &lt;code&gt;jsonrpc-connection&lt;/code&gt; 은 다른 기본 전송 전략을 구현하기 위해 서브 클래 싱됩니다 (서브 클래스하는 방법에 대한 자세한 내용은 &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/eieio/Inheritance.html#Inheritance&quot;&gt;(eieio) Inheritance&lt;/a&gt; 참조 ). 그런 다음 애플리케이션 구축 인터페이스 사용자는이 구체적인 클래스의 개체를 인스턴스화하고 ( &lt;code&gt;make-instance&lt;/code&gt; 기능 사용) 해당 전략을 사용하여 JSONRPC 엔드 포인트에 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9e4e7371206d35dcfc5989991b4a959d04ae518" translate="yes" xml:space="preserve">
          <source>In this scenario, the JSONRPC application selects a concrete subclass of &lt;code&gt;jsonrpc-connection&lt;/code&gt;, and proceeds to create objects of that subclass using &lt;code&gt;make-instance&lt;/code&gt;. To initiate a contact to the remote endpoint, the JSONRPC application passes this object to the functions &lt;code&gt;jsonrpc-notify&lt;/code&gt;, &lt;code&gt;jsonrpc-request&lt;/code&gt;, and/or &lt;code&gt;jsonrpc-async-request&lt;/code&gt;. For handling remotely initiated contacts, which generally come in asynchronously, the instantiation should include &lt;code&gt;:request-dispatcher&lt;/code&gt; and &lt;code&gt;:notification-dispatcher&lt;/code&gt; initargs, which are both functions of 3 arguments: the connection object; a symbol naming the JSONRPC method invoked remotely; and a JSONRPC &lt;code&gt;params&lt;/code&gt; object.</source>
          <target state="translated">이 시나리오에서 JSONRPC 애플리케이션은 &lt;code&gt;jsonrpc-connection&lt;/code&gt; 의 구체적인 하위 클래스를 선택하고 &lt;code&gt;make-instance&lt;/code&gt; 를 사용하여 해당 하위 클래스의 객체를 생성합니다 . 원격 엔드 포인트에 대한 연결을 시작하기 위해 JSONRPC 애플리케이션은이 객체를 &lt;code&gt;jsonrpc-notify&lt;/code&gt; , &lt;code&gt;jsonrpc-request&lt;/code&gt; 및 / 또는 &lt;code&gt;jsonrpc-async-request&lt;/code&gt; 함수에 전달합니다 . 일반적으로 비동기 적으로 들어오는 원격 시작 연락처를 처리하려면 인스턴스화에 &lt;code&gt;:request-dispatcher&lt;/code&gt; 및 &lt;code&gt;:notification-dispatcher&lt;/code&gt; initargs 가 포함되어야합니다 . 두 가지 인수는 모두 다음과 같습니다. 연결 개체; 원격으로 호출 된 JSONRPC 메소드의 이름을 지정하는 기호; 및 JSONRPC &lt;code&gt;params&lt;/code&gt; 목적.</target>
        </trans-unit>
        <trans-unit id="1af82129d6d32c9e06217b885c8dd8bf6f60a0e9" translate="yes" xml:space="preserve">
          <source>In this section we describe functions for creating, accessing and altering syntax tables.</source>
          <target state="translated">이 섹션에서는 구문 테이블을 생성, 액세스 및 변경하는 함수를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="7456e6359dd2969245d309399580bcce1506a625" translate="yes" xml:space="preserve">
          <source>In this section we list some of the more general keymaps. Many of these exist when Emacs is first started, but some are loaded only when the respective feature is accessed.</source>
          <target state="translated">이 섹션에서는 좀 더 일반적인 키맵을 나열합니다. 이들 중 대부분은 Emacs가 처음 시작될 때 존재하지만 일부는 해당 기능에 액세스 할 때만로드됩니다.</target>
        </trans-unit>
        <trans-unit id="75c4faa5a87500b689faf740289921e94ba4648d" translate="yes" xml:space="preserve">
          <source>In this section, we describe how to create an &lt;em&gt;asynchronous process&lt;/em&gt;. After an asynchronous process is created, it runs in parallel with Emacs, and Emacs can communicate with it using the functions described in the following sections (see &lt;a href=&quot;input-to-processes#Input-to-Processes&quot;&gt;Input to Processes&lt;/a&gt;, and see &lt;a href=&quot;output-from-processes#Output-from-Processes&quot;&gt;Output from Processes&lt;/a&gt;). Note that process communication is only partially asynchronous: Emacs sends and receives data to and from a process only when those functions are called.</source>
          <target state="translated">이 섹션에서는 &lt;em&gt;비동기 프로세스&lt;/em&gt; 를 만드는 방법에 대해 설명합니다 . 비동기 프로세스가 생성 된 후에는 Emacs와 병렬로 실행되며 Emacs는 다음 섹션에 설명 된 함수를 사용하여 이와 통신 할 수 있습니다 ( &lt;a href=&quot;input-to-processes#Input-to-Processes&quot;&gt;프로세스에&lt;/a&gt; 대한 입력 참조 및 &lt;a href=&quot;output-from-processes#Output-from-Processes&quot;&gt;프로세스의 출력&lt;/a&gt; 참조 ). 프로세스 통신은 부분적으로 비동기 적입니다. Emacs는 해당 함수가 호출 될 때만 프로세스와 데이터를주고받습니다.</target>
        </trans-unit>
        <trans-unit id="c9b298dd66b005623af56bf6c6bc09c1e5f67332" translate="yes" xml:space="preserve">
          <source>In this section, we describe the functions that accept all types of arrays.</source>
          <target state="translated">이 섹션에서는 모든 유형의 배열을 허용하는 함수에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="abf73e32c756c256563a8daa580c451693687fe9" translate="yes" xml:space="preserve">
          <source>In this section, we document the &lt;code&gt;run-hooks&lt;/code&gt; function, which is used to run a normal hook. We also document the functions for running various kinds of abnormal hooks.</source>
          <target state="translated">이 섹션에서는 일반 후크를 실행하는 데 사용되는 &lt;code&gt;run-hooks&lt;/code&gt; 함수를 문서화합니다 . 또한 다양한 종류의 비정상적인 후크를 실행하는 기능을 문서화합니다.</target>
        </trans-unit>
        <trans-unit id="cc308cdcd27e50a8464c2fb8c2b137680f8aa92d" translate="yes" xml:space="preserve">
          <source>In this special form, the arguments &lt;var&gt;from&lt;/var&gt; and &lt;var&gt;to&lt;/var&gt; are optional, but must both be present or both absent. If they are present, &lt;var&gt;inc&lt;/var&gt; may optionally be specified as well. These arguments are grouped with the argument &lt;var&gt;var&lt;/var&gt; into a list, to distinguish them from &lt;var&gt;body&lt;/var&gt;, which includes all remaining elements of the form.</source>
          <target state="translated">이 특수 형식 &lt;var&gt;from&lt;/var&gt; 및 &lt;var&gt;to&lt;/var&gt; 인수 는 선택 사항이지만 둘 다 존재하거나 둘 다 없어야합니다. 있는 경우 &lt;var&gt;inc&lt;/var&gt; 도 선택적으로 지정할 수 있습니다. 이러한 인수는 &lt;var&gt;var&lt;/var&gt; 인수와 함께 목록으로 그룹화되어 양식의 나머지 모든 요소를 ​​포함하는 &lt;var&gt;body&lt;/var&gt; 와 구별됩니다 .</target>
        </trans-unit>
        <trans-unit id="9191121a266e1613654b74c183e9b81e80959c1f" translate="yes" xml:space="preserve">
          <source>In this subsection, &lt;var&gt;ewoc&lt;/var&gt; and &lt;var&gt;node&lt;/var&gt; stand for the structures described above (see &lt;a href=&quot;abstract-display#Abstract-Display&quot;&gt;Abstract Display&lt;/a&gt;), while &lt;var&gt;data&lt;/var&gt; stands for an arbitrary Lisp object used as a data element.</source>
          <target state="translated">이 하위 섹션에서 &lt;var&gt;ewoc&lt;/var&gt; 및 &lt;var&gt;node&lt;/var&gt; 는 위에서 설명한 구조를 나타내고 ( &lt;a href=&quot;abstract-display#Abstract-Display&quot;&gt;Abstract Display&lt;/a&gt; 참조 ) &lt;var&gt;data&lt;/var&gt; 는 데이터 요소로 사용되는 임의의 Lisp 객체를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b7695c1c385c781384681e043cf75498c33095e8" translate="yes" xml:space="preserve">
          <source>In typical use of text properties, most of the time several or many consecutive characters have the same value for a property. Rather than writing your programs to examine characters one by one, it is much faster to process chunks of text that have the same property value.</source>
          <target state="translated">일반적으로 텍스트 속성을 사용하는 경우 여러 연속 문자가 속성에 대해 동일한 값을 갖습니다. 문자를 하나씩 검사하도록 프로그램을 작성하는 것보다 동일한 속성 값을 가진 텍스트 청크를 처리하는 것이 훨씬 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="398759523f553da3a04d5632b9ae89f03ca6ebe6" translate="yes" xml:space="preserve">
          <source>In unusual circumstances, there can be more than one buffer visiting the same file name. In such cases, this function returns the first such buffer in the buffer list.</source>
          <target state="translated">비정상적인 상황에서 동일한 파일 이름을 방문하는 버퍼가 둘 이상있을 수 있습니다. 이러한 경우이 함수는 버퍼 목록에서 첫 번째 버퍼를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6bc522c712bd045ae610c3ffdfe588e290263853" translate="yes" xml:space="preserve">
          <source>In window systems, such as X, data can be transferred between different applications by means of &lt;em&gt;selections&lt;/em&gt;. X defines an arbitrary number of &lt;em&gt;selection types&lt;/em&gt;, each of which can store its own data; however, only three are commonly used: the &lt;em&gt;clipboard&lt;/em&gt;, &lt;em&gt;primary selection&lt;/em&gt;, and &lt;em&gt;secondary selection&lt;/em&gt;. Other window systems support only the clipboard. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Cut-and-Paste.html#Cut-and-Paste&quot;&gt;Cut and Paste&lt;/a&gt; in</source>
          <target state="translated">X와 같은 윈도우 시스템에서는 &lt;em&gt;선택&lt;/em&gt; 을 통해 서로 다른 응용 프로그램간에 데이터를 전송할 수 있습니다 . X는 임의의 수의 &lt;em&gt;선택 유형을&lt;/em&gt; 정의하며 각 &lt;em&gt;유형&lt;/em&gt; 은 자체 데이터를 저장할 수 있습니다. 그러나 일반적으로 &lt;em&gt;클립 보드&lt;/em&gt; , &lt;em&gt;기본 선택&lt;/em&gt; 및 &lt;em&gt;보조 선택&lt;/em&gt; 세 가지만 사용됩니다 . 다른 윈도우 시스템은 클립 보드 만 지원합니다. 참조 &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Cut-and-Paste.html#Cut-and-Paste&quot;&gt;잘라 내기 및 붙여 넣기&lt;/a&gt; 에</target>
        </trans-unit>
        <trans-unit id="1f4f96711902573479785d359bea6010a237cdfb" translate="yes" xml:space="preserve">
          <source>In writing the key sequence to rebind, it is good to use the special escape sequences for control and meta characters (see &lt;a href=&quot;string-type#String-Type&quot;&gt;String Type&lt;/a&gt;). The syntax &amp;lsquo;</source>
          <target state="translated">리 바인드 할 키 시퀀스를 작성할 때 제어 및 메타 문자에 대해 특수 이스케이프 시퀀스를 사용하는 것이 좋습니다 ( &lt;a href=&quot;string-type#String-Type&quot;&gt;String Type&lt;/a&gt; 참조 ). 구문 '</target>
        </trans-unit>
        <trans-unit id="5c699af66d7cc4077f86d1419c1e341294245528" translate="yes" xml:space="preserve">
          <source>Include an external link after the documentation string for this item. This is a sentence containing a button that references some other documentation.</source>
          <target state="translated">이 항목에 대한 문서 문자열 뒤에 외부 링크를 포함하십시오. 이것은 다른 문서를 참조하는 버튼이 포함 된 문장입니다.</target>
        </trans-unit>
        <trans-unit id="76775cb67de1d16719f132aea62e321213b81dcb" translate="yes" xml:space="preserve">
          <source>Includes examples and caveats.</source>
          <target state="translated">예와주의 사항을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="abb42b558c56ceb21cca2f6daadd7a31514411ab" translate="yes" xml:space="preserve">
          <source>Increase the image size (&lt;code&gt;image-increase-size&lt;/code&gt;). A prefix value of &amp;lsquo;</source>
          <target state="translated">이미지 크기를 늘리십시오 ( &lt;code&gt;image-increase-size&lt;/code&gt; ). 접두사 값 '</target>
        </trans-unit>
        <trans-unit id="9229257425378cb0ebb48e0365ae97d30b8cbd09" translate="yes" xml:space="preserve">
          <source>Incremental search can make invisible overlays visible temporarily and/or permanently when a match includes invisible text. To enable this, the overlay should have a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;isearch-open-invisible&lt;/code&gt; property. The property value should be a function to be called with the overlay as an argument. This function should make the overlay visible permanently; it is used when the match overlaps the overlay on exit from the search.</source>
          <target state="translated">증분 검색은 일치 항목에 보이지 않는 텍스트가 포함 된 경우 보이지 않는 오버레이를 일시적으로 및 / 또는 영구적으로 표시 할 수 있습니다. 이를 활성화하려면 오버레이에 &lt;code&gt;nil&lt;/code&gt; 이 아닌 &lt;code&gt;isearch-open-invisible&lt;/code&gt; 속성이 있어야 합니다. 속성 값은 오버레이를 인수로 사용하여 호출 할 함수 여야합니다. 이 기능은 오버레이를 영구적으로 표시해야합니다. 검색 종료시 일치 항목이 오버레이와 겹칠 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e6d579c6cc398fe7db545dd582fc67de8b2d582c" translate="yes" xml:space="preserve">
          <source>Indent all the lines in a region.</source>
          <target state="translated">영역의 모든 줄을 들여 씁니다.</target>
        </trans-unit>
        <trans-unit id="42c518bd88aefe4faecc452be3932f9e029498cb" translate="yes" xml:space="preserve">
          <source>Indent calls to this function or macro according to &lt;var&gt;indent-spec&lt;/var&gt;. This is typically used for macros, though it works for functions too. See &lt;a href=&quot;indenting-macros#Indenting-Macros&quot;&gt;Indenting Macros&lt;/a&gt;.</source>
          <target state="translated">&lt;var&gt;indent-spec&lt;/var&gt; 에 따라이 함수 또는 매크로에 대한 호출을 들여 씁니다 . 일반적으로 매크로에 사용되지만 함수에도 적용됩니다. &lt;a href=&quot;indenting-macros#Indenting-Macros&quot;&gt;매크로 들여 쓰기를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="27176cfb7708a018b06cd9d8ea7336b632a76f0d" translate="yes" xml:space="preserve">
          <source>Indent current token as a &lt;em&gt;separator&lt;/em&gt;.</source>
          <target state="translated">현재 토큰을 &lt;em&gt;구분 기호&lt;/em&gt; 로 들여 씁니다 .</target>
        </trans-unit>
        <trans-unit id="66b7ce43ce4a7ca89f6dad39cb0198725d35356c" translate="yes" xml:space="preserve">
          <source>Indent the current line based on previous lines.</source>
          <target state="translated">이전 줄을 기준으로 현재 줄을 들여 씁니다.</target>
        </trans-unit>
        <trans-unit id="c9ec7fcf0ce1c005cbdd2ae9ab39e1773e6bf368" translate="yes" xml:space="preserve">
          <source>Indentation</source>
          <target state="translated">Indentation</target>
        </trans-unit>
        <trans-unit id="511f4889f97fada7d908032cc1464f2aa35c8004" translate="yes" xml:space="preserve">
          <source>Indentation Controlled by Major Mode</source>
          <target state="translated">주 모드로 제어되는 들여 쓰기</target>
        </trans-unit>
        <trans-unit id="fdac28e1c2199ac39cc5e09f4dd786cd625bd4a4" translate="yes" xml:space="preserve">
          <source>Indentation Primitives</source>
          <target state="translated">들여 쓰기 프리미티브</target>
        </trans-unit>
        <trans-unit id="5b82b1b833300c0e6e5e24537ad294a6d135f9fa" translate="yes" xml:space="preserve">
          <source>Indentation Relative to Previous Lines</source>
          <target state="translated">이전 줄을 기준으로 들여 쓰기</target>
        </trans-unit>
        <trans-unit id="2af2ccd8b84225bf2c735da91f1184265c730f6a" translate="yes" xml:space="preserve">
          <source>Indentation-Based Motion Commands</source>
          <target state="translated">들여 쓰기 기반 동작 명령</target>
        </trans-unit>
        <trans-unit id="1bb77083feeb12d0ebb47ef46a39b5078cd5cb2d" translate="yes" xml:space="preserve">
          <source>Indenting Macros</source>
          <target state="translated">매크로 들여 쓰기</target>
        </trans-unit>
        <trans-unit id="30f00ddc559ee66f1e7768bbbc4d7eee4d538190" translate="yes" xml:space="preserve">
          <source>Indenting an Entire Region</source>
          <target state="translated">전체 영역 들여 쓰기</target>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="8f868c1e82b2154aed66be4aaa7e76b45121fbff" translate="yes" xml:space="preserve">
          <source>Index including concepts, functions, variables, and other terms.</source>
          <target state="translated">개념, 기능, 변수 및 기타 용어를 포함하는 색인입니다.</target>
        </trans-unit>
        <trans-unit id="d52c4a56e9e6d6db73917b478317c4b1d432ad1f" translate="yes" xml:space="preserve">
          <source>Indicates that the specification is for a defining form. Edebug&amp;rsquo;s definition of a defining form is a form containing one or more code forms which are saved and executed later, after the execution of the defining form.</source>
          <target state="translated">사양이 정의 양식에 대한 것임을 나타냅니다. 정의 양식에 대한 Edebug의 정의는 정의 양식을 실행 한 후 나중에 저장되고 실행되는 하나 이상의 코드 양식을 포함하는 양식입니다.</target>
        </trans-unit>
        <trans-unit id="1112b756bb004fe882859143d87adf31c2f5d050" translate="yes" xml:space="preserve">
          <source>Indirect Buffers</source>
          <target state="translated">간접 버퍼</target>
        </trans-unit>
        <trans-unit id="938b66bd8c62095908b57d694e88050ca1007edd" translate="yes" xml:space="preserve">
          <source>Individual characters are used occasionally in programs, but it is more common to work with &lt;em&gt;strings&lt;/em&gt;, which are sequences composed of characters. See &lt;a href=&quot;string-type#String-Type&quot;&gt;String Type&lt;/a&gt;.</source>
          <target state="translated">개별 문자는 프로그램에서 가끔 사용되지만 문자로 구성된 시퀀스 인 &lt;em&gt;문자열&lt;/em&gt; 로 작업하는 것이 더 일반적 입니다. &lt;a href=&quot;string-type#String-Type&quot;&gt;문자열 유형을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4b631f69842530d659306c8f06dbad594a6b1807" translate="yes" xml:space="preserve">
          <source>Info</source>
          <target state="translated">Info</target>
        </trans-unit>
        <trans-unit id="ad474c9deee501ca52324eb72953350dc14402c1" translate="yes" xml:space="preserve">
          <source>Info about total size of Lisp objects made so far.</source>
          <target state="translated">지금까지 만든 Lisp 개체의 총 크기에 대한 정보입니다.</target>
        </trans-unit>
        <trans-unit id="e73d741db9df809634f2d60fc44dc32e7f4bc7e7" translate="yes" xml:space="preserve">
          <source>Info for users downgrading to Emacs 26.</source>
          <target state="translated">Emacs 26으로 다운 그레이드하는 사용자를위한 정보.</target>
        </trans-unit>
        <trans-unit id="0eb5ed506e4923c28d7f4a8aa69efe99b3ad75d1" translate="yes" xml:space="preserve">
          <source>Information</source>
          <target state="translated">Information</target>
        </trans-unit>
        <trans-unit id="8247fbb975f100a6b13b56c054fa3613a36b297b" translate="yes" xml:space="preserve">
          <source>Information about Files</source>
          <target state="translated">파일에 대한 정보</target>
        </trans-unit>
        <trans-unit id="df29a9e6a31bec3e8b780a960759047a5bd6a25f" translate="yes" xml:space="preserve">
          <source>Information from Markers</source>
          <target state="translated">마커의 정보</target>
        </trans-unit>
        <trans-unit id="3ef56c865ee91dd66ebad0347cc1f0de75602bc3" translate="yes" xml:space="preserve">
          <source>Information from the Command Loop</source>
          <target state="translated">명령 루프의 정보</target>
        </trans-unit>
        <trans-unit id="18c79d206ba3bf95c4d3ca95be49d37877182f30" translate="yes" xml:space="preserve">
          <source>Informing user about progress of a long operation.</source>
          <target state="translated">사용자에게 긴 작업의 진행 상황을 알립니다.</target>
        </trans-unit>
        <trans-unit id="d8a1fba394d47f17007b00e6ef12b9c86a3c6414" translate="yes" xml:space="preserve">
          <source>Inherit standard syntax: &amp;lsquo;</source>
          <target state="translated">표준 구문 상속 : '</target>
        </trans-unit>
        <trans-unit id="15e80c1c18978164d737579b198c39c73404e4e1" translate="yes" xml:space="preserve">
          <source>Inheritance and Keymaps</source>
          <target state="translated">상속 및 키맵</target>
        </trans-unit>
        <trans-unit id="fb691787cc7690e0df61a80ff9e0643eb7d0d6da" translate="yes" xml:space="preserve">
          <source>Initial Frame Parameters</source>
          <target state="translated">초기 프레임 매개 변수</target>
        </trans-unit>
        <trans-unit id="89a2bccb3e4d6523cbe25ad5db3ff715866a115e" translate="yes" xml:space="preserve">
          <source>Initial Input</source>
          <target state="translated">초기 입력</target>
        </trans-unit>
        <trans-unit id="eb607b40a369ea5599a4b2f0220d4f687f78016b" translate="yes" xml:space="preserve">
          <source>Initialize the log function of a server process to &lt;var&gt;log&lt;/var&gt;. The log function is called each time the server accepts a network connection from a client. The arguments passed to the log function are &lt;var&gt;server&lt;/var&gt;, &lt;var&gt;connection&lt;/var&gt;, and &lt;var&gt;message&lt;/var&gt;; where &lt;var&gt;server&lt;/var&gt; is the server process, &lt;var&gt;connection&lt;/var&gt; is the new process for the connection, and &lt;var&gt;message&lt;/var&gt; is a string describing what has happened.</source>
          <target state="translated">하는 서버 프로세스의 로그 기능 초기화 &lt;var&gt;log&lt;/var&gt; . 로그 함수는 서버가 클라이언트의 네트워크 연결을 수락 할 때마다 호출됩니다. 로그 함수에 전달되는 인수는 &lt;var&gt;server&lt;/var&gt; , &lt;var&gt;connection&lt;/var&gt; 및 &lt;var&gt;message&lt;/var&gt; . 여기서 &lt;var&gt;server&lt;/var&gt; 는 서버 프로세스이고 &lt;var&gt;connection&lt;/var&gt; 은 연결 의 새 프로세스이며 &lt;var&gt;message&lt;/var&gt; 는 발생한 상황을 설명하는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="f894ea5a16cfcad8d7176dad8de92207ba46e301" translate="yes" xml:space="preserve">
          <source>Initialize the process filter to &lt;var&gt;filter&lt;/var&gt;.</source>
          <target state="translated">에 공정 필터 초기화 &lt;var&gt;filter&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="4bdcb3b64e7635d1c8dde72370f13421e348ea64" translate="yes" xml:space="preserve">
          <source>Initialize the process filter to &lt;var&gt;filter&lt;/var&gt;. If not specified, a default filter will be provided, which can be changed later. See &lt;a href=&quot;filter-functions#Filter-Functions&quot;&gt;Filter Functions&lt;/a&gt;.</source>
          <target state="translated">에 공정 필터 초기화 &lt;var&gt;filter&lt;/var&gt; . 지정하지 않으면 기본 필터가 제공되며 나중에 변경할 수 있습니다. &lt;a href=&quot;filter-functions#Filter-Functions&quot;&gt;필터 함수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="88aa27fccdee463394440c83004deae351722113" translate="yes" xml:space="preserve">
          <source>Initialize the process filter to &lt;var&gt;filter&lt;/var&gt;. If not specified, a default filter will be provided, which can be overridden later. See &lt;a href=&quot;filter-functions#Filter-Functions&quot;&gt;Filter Functions&lt;/a&gt;.</source>
          <target state="translated">에 공정 필터 초기화 &lt;var&gt;filter&lt;/var&gt; . 지정하지 않으면 나중에 재정의 할 수있는 기본 필터가 제공됩니다. &lt;a href=&quot;filter-functions#Filter-Functions&quot;&gt;필터 함수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="978fecd8f603fe8d25457aa9a55a2791886af74d" translate="yes" xml:space="preserve">
          <source>Initialize the process plist to &lt;var&gt;plist&lt;/var&gt;.</source>
          <target state="translated">로 처리 PLIST 초기화 &lt;var&gt;plist&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="c97165454b295da9973e4e05e4127a6851e7f5bd" translate="yes" xml:space="preserve">
          <source>Initialize the process query flag to &lt;var&gt;query-flag&lt;/var&gt;. See &lt;a href=&quot;query-before-exit#Query-Before-Exit&quot;&gt;Query Before Exit&lt;/a&gt;.</source>
          <target state="translated">프로세스 쿼리 플래그를 &lt;var&gt;query-flag&lt;/var&gt; 로 초기화합니다 . &lt;a href=&quot;query-before-exit#Query-Before-Exit&quot;&gt;종료 전 조회를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1296ca254782c4485a383df44dbf7f61ee7b4bc5" translate="yes" xml:space="preserve">
          <source>Initialize the process query flag to &lt;var&gt;query-flag&lt;/var&gt;. See &lt;a href=&quot;query-before-exit#Query-Before-Exit&quot;&gt;Query Before Exit&lt;/a&gt;. The flags defaults to &lt;code&gt;nil&lt;/code&gt; if unspecified.</source>
          <target state="translated">프로세스 쿼리 플래그를 &lt;var&gt;query-flag&lt;/var&gt; 로 초기화합니다 . &lt;a href=&quot;query-before-exit#Query-Before-Exit&quot;&gt;종료 전 조회를&lt;/a&gt; 참조하십시오 . 지정 &lt;code&gt;nil&lt;/code&gt; 않으면 플래그의 기본값은 nil 입니다.</target>
        </trans-unit>
        <trans-unit id="7423f99e44e5c0fe954c4b5fbab30632bfd77607" translate="yes" xml:space="preserve">
          <source>Initialize the process sentinel to &lt;var&gt;sentinel&lt;/var&gt;.</source>
          <target state="translated">프로세스 sentinel을 &lt;var&gt;sentinel&lt;/var&gt; 로 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="9db86c8bfdd16aec885a8fb101a51297ca90199b" translate="yes" xml:space="preserve">
          <source>Initialize the process sentinel to &lt;var&gt;sentinel&lt;/var&gt;. If not specified, a default sentinel will be used, which can be changed later. See &lt;a href=&quot;sentinels#Sentinels&quot;&gt;Sentinels&lt;/a&gt;.</source>
          <target state="translated">프로세스 sentinel을 &lt;var&gt;sentinel&lt;/var&gt; 로 초기화합니다 . 지정하지 않으면 나중에 변경할 수있는 기본 센티널이 사용됩니다. &lt;a href=&quot;sentinels#Sentinels&quot;&gt;Sentinels를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="438b44ac9a269df0c942362a3b40baff51fec529" translate="yes" xml:space="preserve">
          <source>Initialize the process sentinel to &lt;var&gt;sentinel&lt;/var&gt;. If not specified, a default sentinel will be used, which can be overridden later. See &lt;a href=&quot;sentinels#Sentinels&quot;&gt;Sentinels&lt;/a&gt;.</source>
          <target state="translated">프로세스 sentinel을 &lt;var&gt;sentinel&lt;/var&gt; 로 초기화합니다 . 지정하지 않으면 나중에 재정의 할 수있는 기본 센티널이 사용됩니다. &lt;a href=&quot;sentinels#Sentinels&quot;&gt;Sentinels를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cc3466ae2da1d30465b2916d783d7d5e733df96c" translate="yes" xml:space="preserve">
          <source>Initialize the type of device used to communicate with the subprocess. Possible values are &lt;code&gt;pty&lt;/code&gt; to use a pty, &lt;code&gt;pipe&lt;/code&gt; to use a pipe, or &lt;code&gt;nil&lt;/code&gt; to use the default derived from the value of the &lt;code&gt;process-connection-type&lt;/code&gt; variable. This parameter and the value of &lt;code&gt;process-connection-type&lt;/code&gt; are ignored if a non-&lt;code&gt;nil&lt;/code&gt; value is specified for the &lt;code&gt;:stderr&lt;/code&gt; parameter; in that case, the type will always be &lt;code&gt;pipe&lt;/code&gt;. On systems where ptys are not available (MS-Windows), this parameter is likewise ignored, and pipes are used unconditionally.</source>
          <target state="translated">하위 프로세스와 통신하는 데 사용되는 장치 유형을 초기화합니다. 가능한 값은 &lt;code&gt;pty&lt;/code&gt; 를 사용하려면 pty, &lt;code&gt;pipe&lt;/code&gt; 를 사용하려면 pipe, &lt;code&gt;process-connection-type&lt;/code&gt; 변수 값에서 파생 된 기본값을 사용하려면 &lt;code&gt;nil&lt;/code&gt; 입니다. &lt;code&gt;:stderr&lt;/code&gt; 매개 변수에 &lt;code&gt;nil&lt;/code&gt; 이 아닌 값이 지정된 경우이 매개 변수와 &lt;code&gt;process-connection-type&lt;/code&gt; 값은 무시됩니다 . 이 경우 유형은 항상 &lt;code&gt;pipe&lt;/code&gt; 입니다. pty를 사용할 수없는 시스템 (MS-Windows)에서는이 매개 변수도 무시되고 파이프는 무조건 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="75ba3477c577bc61f2782c6fbd5d3918d3d93888" translate="yes" xml:space="preserve">
          <source>Inline (&lt;code&gt;defsubst&lt;/code&gt;) functions are less troublesome; if you compile a call to such a function before its definition is known, the call will still work right, it will just run slower.</source>
          <target state="translated">인라인 ( &lt;code&gt;defsubst&lt;/code&gt; ) 함수는 덜 번거 롭습니다 . 정의가 알려지기 전에 그러한 함수에 대한 호출을 컴파일하면 호출이 여전히 올바르게 작동하고 느리게 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="b60019f47df04ae92897fa912c6748a6013313fa" translate="yes" xml:space="preserve">
          <source>Inline Functions</source>
          <target state="translated">인라인 함수</target>
        </trans-unit>
        <trans-unit id="023bd002a35d8328e1b84deea2b2fbe846651660" translate="yes" xml:space="preserve">
          <source>Inner Frame</source>
          <target state="translated">내부 프레임</target>
        </trans-unit>
        <trans-unit id="1ff7c24cdc862e41c4384103afd571ff8024a31c" translate="yes" xml:space="preserve">
          <source>Input Events</source>
          <target state="translated">입력 이벤트</target>
        </trans-unit>
        <trans-unit id="68e31416a1a24dd5f2a79386c7cd5ebc7d038f16" translate="yes" xml:space="preserve">
          <source>Input Focus</source>
          <target state="translated">입력 초점</target>
        </trans-unit>
        <trans-unit id="88198074ced9d4479d4b7e9aafe153884a14b789" translate="yes" xml:space="preserve">
          <source>Input Functions</source>
          <target state="translated">입력 기능</target>
        </trans-unit>
        <trans-unit id="c968ad8768affe487c292b6adc7616df4a013a6b" translate="yes" xml:space="preserve">
          <source>Input Methods</source>
          <target state="translated">입력 방법</target>
        </trans-unit>
        <trans-unit id="a821e6c8419f780e8743b7bf306490cddd9913c4" translate="yes" xml:space="preserve">
          <source>Input Modes</source>
          <target state="translated">입력 모드</target>
        </trans-unit>
        <trans-unit id="eed11d0bb1de0f449227ff92bf6d2ad650126f01" translate="yes" xml:space="preserve">
          <source>Input Streams</source>
          <target state="translated">입력 스트림</target>
        </trans-unit>
        <trans-unit id="3b3948df9e555ca646262a35e33cb7cf68613dc1" translate="yes" xml:space="preserve">
          <source>Input methods allow users to enter various non-ASCII characters without special keyboards.</source>
          <target state="translated">입력 방법을 사용하면 특수 키보드없이 다양한 비 ASCII 문자를 입력 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf60d2635214ca206c57f12fa87775f6b4f038df" translate="yes" xml:space="preserve">
          <source>Insert the output in a buffer with that name, before point.</source>
          <target state="translated">포인트 앞에 해당 이름의 버퍼에 출력을 삽입하십시오.</target>
        </trans-unit>
        <trans-unit id="3aa29461af0f56c0dd73083f79d4a003b7af3788" translate="yes" xml:space="preserve">
          <source>Insert the output in that buffer, before point. This includes both the standard output stream and the standard error stream of the process.</source>
          <target state="translated">포인트 앞에 해당 버퍼에 출력을 삽입하십시오. 여기에는 프로세스의 표준 출력 스트림과 표준 오류 스트림이 모두 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="1c64a3bbdde10f3ebb444ccc0c14466f3d048a31" translate="yes" xml:space="preserve">
          <source>Insert the output in the current buffer, before point.</source>
          <target state="translated">포인트 앞에 현재 버퍼에 출력을 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="0d849e555da7ae1ee48fec0567933a06f27173ff" translate="yes" xml:space="preserve">
          <source>Insert the strings &lt;var&gt;strings&lt;/var&gt;, just like the function &lt;code&gt;insert-before-markers&lt;/code&gt;, but inherit any sticky properties from the adjoining text.</source>
          <target state="translated">&lt;code&gt;insert-before-markers&lt;/code&gt; 함수와 마찬가지로 strings &lt;var&gt;strings&lt;/var&gt; 를삽입 하지만 인접한 텍스트에서 고정 속성을 상속합니다.</target>
        </trans-unit>
        <trans-unit id="90ef3b52113b2290b776d5edcbf7341e258eb075" translate="yes" xml:space="preserve">
          <source>Insert the strings &lt;var&gt;strings&lt;/var&gt;, just like the function &lt;code&gt;insert&lt;/code&gt;, but inherit any sticky properties from the adjoining text.</source>
          <target state="translated">insert 함수와 마찬가지로 strings &lt;var&gt;strings&lt;/var&gt; 를 &lt;code&gt;insert&lt;/code&gt; 하지만 인접한 텍스트에서 고정 속성을 상속합니다.</target>
        </trans-unit>
        <trans-unit id="d4b10e59d8cd180c5c4c38922e8312024dcd937c" translate="yes" xml:space="preserve">
          <source>Inserting Text</source>
          <target state="translated">텍스트 삽입</target>
        </trans-unit>
        <trans-unit id="f62a121c8905d9b70d56a62824bb530abbb240fe" translate="yes" xml:space="preserve">
          <source>Insertion and deletion in a buffer must check all the markers and relocate them if necessary. This slows processing in a buffer with a large number of markers. For this reason, it is a good idea to make a marker point nowhere if you are sure you don&amp;rsquo;t need it any more. Markers that can no longer be accessed are eventually removed (see &lt;a href=&quot;garbage-collection#Garbage-Collection&quot;&gt;Garbage Collection&lt;/a&gt;).</source>
          <target state="translated">버퍼에 삽입 및 삭제는 모든 마커를 확인하고 필요한 경우 재배치해야합니다. 이로 인해 마커 수가 많은 버퍼에서 처리 속도가 느려집니다. 따라서 마커가 더 이상 필요하지 않다고 확신하는 경우 아무 곳에도 마커 지점을 만드는 것이 좋습니다. 더 이상 액세스 할 수없는 마커는 결국 제거됩니다 ( &lt;a href=&quot;garbage-collection#Garbage-Collection&quot;&gt;가비지 컬렉션&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="17ee0ff6e39b0d949eba112fc3626357b3a22a32" translate="yes" xml:space="preserve">
          <source>Insertion functions signal an error if the current buffer is read-only (see &lt;a href=&quot;read-only-buffers#Read-Only-Buffers&quot;&gt;Read Only Buffers&lt;/a&gt;) or if they insert within read-only text (see &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Special Properties&lt;/a&gt;).</source>
          <target state="translated">삽입 함수는 현재 버퍼가 읽기 전용 인 경우 ( &lt;a href=&quot;read-only-buffers#Read-Only-Buffers&quot;&gt;읽기 전용 버퍼&lt;/a&gt; 참조 ) 또는 읽기 전용 텍스트 내에 삽입하는 경우 ( &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;특수 속성&lt;/a&gt; 참조) 오류 신호를 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="5434f633b863c5453f6112150b15fbd13f9dde5c" translate="yes" xml:space="preserve">
          <source>Insertion moves markers located at positions after the insertion point, so that they stay with the surrounding text (see &lt;a href=&quot;markers#Markers&quot;&gt;Markers&lt;/a&gt;). When a marker points at the place of insertion, insertion may or may not relocate the marker, depending on the marker&amp;rsquo;s insertion type (see &lt;a href=&quot;marker-insertion-types#Marker-Insertion-Types&quot;&gt;Marker Insertion Types&lt;/a&gt;). Certain special functions such as &lt;code&gt;insert-before-markers&lt;/code&gt; relocate all such markers to point after the inserted text, regardless of the markers&amp;rsquo; insertion type.</source>
          <target state="translated">삽입은 삽입 지점 뒤의 위치에있는 마커를 이동하여 주변 텍스트와 함께 유지되도록합니다 ( &lt;a href=&quot;markers#Markers&quot;&gt;마커&lt;/a&gt; 참조 ). 마커가 삽입 위치를 가리키는 경우 마커의 삽입 유형에 따라 삽입 할 수도 있고 재배치하지 않을 수도 있습니다 ( &lt;a href=&quot;marker-insertion-types#Marker-Insertion-Types&quot;&gt;마커 삽입 유형&lt;/a&gt; 참조 ). &lt;code&gt;insert-before-markers&lt;/code&gt; 와 같은 특정 특수 기능 은 마커의 삽입 유형에 관계없이 삽입 된 텍스트 뒤를 가리 키도록 모든 마커를 재배치합니다.</target>
        </trans-unit>
        <trans-unit id="bd95261b13119729b7f21abc1b22f07a4f3b895c" translate="yes" xml:space="preserve">
          <source>Insertion next to a read-only character is an error if inserting ordinary text there would inherit the &lt;code&gt;read-only&lt;/code&gt; property due to stickiness. Thus, you can control permission to insert next to read-only text by controlling the stickiness. See &lt;a href=&quot;sticky-properties#Sticky-Properties&quot;&gt;Sticky Properties&lt;/a&gt;.</source>
          <target state="translated">읽기 전용 문자 옆에 삽입하면 일반 텍스트를 삽입하면 고정 으로 인해 &lt;code&gt;read-only&lt;/code&gt; 속성 이 상속되는 경우 오류가 발생합니다 . 따라서 고 정성을 제어하여 읽기 전용 텍스트 옆에 삽입하는 권한을 제어 할 수 있습니다. &lt;a href=&quot;sticky-properties#Sticky-Properties&quot;&gt;고정 속성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0021bd63930267acc7e983ae1c2b95215f4a5f19" translate="yes" xml:space="preserve">
          <source>Insertion of text at the border between intervals also raises questions that have no satisfactory answer.</source>
          <target state="translated">간격 사이의 경계에 텍스트를 삽입하면 만족스러운 대답이없는 질문도 제기됩니다.</target>
        </trans-unit>
        <trans-unit id="a632b0d51711f298bce3fb60664237d20718b891" translate="yes" xml:space="preserve">
          <source>Inside a &lt;code&gt;repeat&lt;/code&gt; block, these contain the maximum number of repetitions (as specified by the &lt;var&gt;count&lt;/var&gt; parameter), and the current repetition number (counting from 0). Setting &lt;code&gt;count&lt;/code&gt; to zero will terminate the inner-most repeat block after the current repetition has completed.</source>
          <target state="translated">&lt;code&gt;repeat&lt;/code&gt; 블록 내부 에는 최대 반복 횟수 ( &lt;var&gt;count&lt;/var&gt; 매개 변수 로 지정됨 )와 현재 반복 횟수 (0부터 계산)가 포함됩니다. &lt;code&gt;count&lt;/code&gt; 를 0으로 설정 하면 현재 반복이 완료된 후 가장 안쪽에있는 반복 블록이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="bbecdb627416247ff6d11ce653cbc5c864a55b32" translate="yes" xml:space="preserve">
          <source>Install &lt;var&gt;filter&lt;/var&gt; as the process filter.</source>
          <target state="translated">공정 &lt;var&gt;filter&lt;/var&gt; 로 필터 를 설치합니다 .</target>
        </trans-unit>
        <trans-unit id="44e7cf106d78a4e14ed20efc7a4b48dce495ecdb" translate="yes" xml:space="preserve">
          <source>Install &lt;var&gt;plist&lt;/var&gt; as the initial plist of the process.</source>
          <target state="translated">프로세스의 초기 &lt;var&gt;plist&lt;/var&gt; 로 plist 를 설치합니다 .</target>
        </trans-unit>
        <trans-unit id="f8052583c9ddb4adcb58b5e1d5c25c1b544fa693" translate="yes" xml:space="preserve">
          <source>Install &lt;var&gt;sentinel&lt;/var&gt; as the process sentinel.</source>
          <target state="translated">프로세스 &lt;var&gt;sentinel&lt;/var&gt; 로 센티넬 을 설치합니다 .</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="16d39f83c12d88464b887e1ce49fd00973ec280c" translate="yes" xml:space="preserve">
          <source>Installing a package, either via the command &lt;code&gt;package-install-file&lt;/code&gt;, or via the Package Menu, creates a subdirectory of &lt;code&gt;package-user-dir&lt;/code&gt; named</source>
          <target state="translated">&lt;code&gt;package-install-file&lt;/code&gt; 명령 이나 패키지 메뉴를 통해 패키지를 설치 하면 &lt;code&gt;package-user-dir&lt;/code&gt; 이라는 하위 디렉토리가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="44bbd8cdd2a2c9792cd51329260082dfa8dcec4d" translate="yes" xml:space="preserve">
          <source>Installing several buffer changes atomically.</source>
          <target state="translated">여러 버퍼 변경 사항을 원자 적으로 설치합니다.</target>
        </trans-unit>
        <trans-unit id="0b8fb4bde942015c31c40daedf4c7212f24d5f6e" translate="yes" xml:space="preserve">
          <source>Instead of a string, &lt;var&gt;rep&lt;/var&gt; can be a function. In that case, &lt;code&gt;replace-regexp-in-string&lt;/code&gt; calls &lt;var&gt;rep&lt;/var&gt; for each match, passing the text of the match as its sole argument. It collects the value &lt;var&gt;rep&lt;/var&gt; returns and passes that to &lt;code&gt;replace-match&lt;/code&gt; as the replacement string. The match data at this point are the result of matching &lt;var&gt;regexp&lt;/var&gt; against a substring of &lt;var&gt;string&lt;/var&gt;.</source>
          <target state="translated">문자열 대신 &lt;var&gt;rep&lt;/var&gt; 은 함수가 될 수 있습니다. 이 경우 &lt;code&gt;replace-regexp-in-string&lt;/code&gt; 은 각 일치에 대해 &lt;var&gt;rep&lt;/var&gt; 을 호출 하여 일치 텍스트를 유일한 인수로 전달합니다. &lt;var&gt;rep&lt;/var&gt; 이 반환 하는 값을 수집하여 교체 문자열로 교체 &lt;code&gt;replace-match&lt;/code&gt; 전달 합니다. 이 시점에서 일치 데이터 는 &lt;var&gt;string&lt;/var&gt; 의 하위 문자열에 대해 &lt;var&gt;regexp&lt;/var&gt; 를 일치시킨 결과입니다 .</target>
        </trans-unit>
        <trans-unit id="3f1753669c714a1d7e578072aa4ed5c9dba79dc2" translate="yes" xml:space="preserve">
          <source>Instead of adding a buffer name or a regular expression to one of these options use a &lt;code&gt;display-buffer-alist&lt;/code&gt; entry for that buffer specifying the action function &lt;code&gt;display-buffer-same-window&lt;/code&gt;.</source>
          <target state="translated">이러한 옵션 중 하나에 버퍼 이름이나 정규식을 추가하는 대신 해당 버퍼에 &lt;code&gt;display-buffer-same-window&lt;/code&gt; 작업 함수를 지정 하는 &lt;code&gt;display-buffer-alist&lt;/code&gt; 항목을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="b0a6282c7355fde001d90d645305cae7bf3bf7cc" translate="yes" xml:space="preserve">
          <source>Instead of binding the mouse command in a major mode keymap, you can bind it within the link text, using the &lt;code&gt;keymap&lt;/code&gt; text property (see &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Special Properties&lt;/a&gt;). For instance:</source>
          <target state="translated">주 모드 키맵에서 마우스 명령을 바인딩하는 대신 &lt;code&gt;keymap&lt;/code&gt; 텍스트 속성을 사용하여 링크 텍스트 내에서 바인딩 할 수 있습니다 ( &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;특수 속성&lt;/a&gt; 참조 ). 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="2670142fd5a30e583bc4b4555d7ebad06b38986e" translate="yes" xml:space="preserve">
          <source>Instead of computing text properties for all the text in the buffer, you can arrange to compute the text properties for parts of the text when and if something depends on them.</source>
          <target state="translated">버퍼의 모든 텍스트에 대한 텍스트 속성을 계산하는 대신 텍스트의 일부에 대한 텍스트 속성을 계산하도록 정렬 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0c382c2cc436ecc3057d41eae8562719a5d21f3" translate="yes" xml:space="preserve">
          <source>Instead of customizing this variable to &lt;code&gt;t&lt;/code&gt;, customize &lt;code&gt;display-buffer-base-action&lt;/code&gt;, for example, as follows:</source>
          <target state="translated">이 변수를 &lt;code&gt;t&lt;/code&gt; 로 사용자 지정하는 대신 다음과 같이 &lt;code&gt;display-buffer-base-action&lt;/code&gt; 을 사용자 지정 합니다.</target>
        </trans-unit>
        <trans-unit id="f48c49102d6b6fcfa99d56a07826d258451b4f42" translate="yes" xml:space="preserve">
          <source>Instead of the &amp;lsquo;</source>
          <target state="translated">'대신</target>
        </trans-unit>
        <trans-unit id="27778412a3ebd3d11dbf8545f85798fd64a1f13a" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;region-beginning&lt;/code&gt; and &lt;code&gt;region-end&lt;/code&gt;, a command designed to operate on a region should normally use &lt;code&gt;interactive&lt;/code&gt; with the &amp;lsquo;</source>
          <target state="translated">사용하는 대신 &lt;code&gt;region-beginning&lt;/code&gt; 과 &lt;code&gt;region-end&lt;/code&gt; 일반적으로 사용한다, 지역에서 작동하도록 설계 명령을 &lt;code&gt;interactive&lt;/code&gt; '를 가진</target>
        </trans-unit>
        <trans-unit id="aaf2819d27bf1d28940bd55fb19452da2f766bc0" translate="yes" xml:space="preserve">
          <source>Instead of using this variable, it is cleaner to use another, newer feature: to pass the function as the &lt;var&gt;read-function&lt;/var&gt; argument to &lt;code&gt;eval-region&lt;/code&gt;. See &lt;a href=&quot;eval#Definition-of-eval_002dregion&quot;&gt;Eval&lt;/a&gt;.</source>
          <target state="translated">이 변수를 사용하는 대신 &lt;code&gt;eval-region&lt;/code&gt; 에 &lt;var&gt;read-function&lt;/var&gt; 인수로 함수를 전달하는 다른 새로운 기능을 사용하는 것이 더 깔끔합니다 . &lt;a href=&quot;eval#Definition-of-eval_002dregion&quot;&gt;Eval을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0d2c7cb2dbf87e9087cb37f404447063050738e9" translate="yes" xml:space="preserve">
          <source>Instead of writing a character literally into a multibyte string, you can write it as its character code using an escape sequence. See &lt;a href=&quot;general-escape-syntax#General-Escape-Syntax&quot;&gt;General Escape Syntax&lt;/a&gt;, for details about escape sequences.</source>
          <target state="translated">문자를 멀티 바이트 문자열에 문자를 쓰는 대신 이스케이프 시퀀스를 사용하여 문자 코드로 작성할 수 있습니다. 이스케이프 시퀀스에 대한 자세한 내용은 &lt;a href=&quot;general-escape-syntax#General-Escape-Syntax&quot;&gt;일반 이스케이프 구문을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8e0e5c167c46a9a94a4405deed528806c20888f6" translate="yes" xml:space="preserve">
          <source>Instrumenting Macro Calls</source>
          <target state="translated">매크로 호출 계측</target>
        </trans-unit>
        <trans-unit id="01d3a83d4f8979d33eb587942de6ed97b7aa1bf4" translate="yes" xml:space="preserve">
          <source>Instrumenting for Edebug</source>
          <target state="translated">Edebug 용 계측</target>
        </trans-unit>
        <trans-unit id="08303d355edd3eb94e9dada9e860f7f9d4221540" translate="yes" xml:space="preserve">
          <source>Integer Basics</source>
          <target state="translated">정수 기본</target>
        </trans-unit>
        <trans-unit id="5944fda631d99e7fe1c28748c40fccba38502e8a" translate="yes" xml:space="preserve">
          <source>Integer Type</source>
          <target state="translated">정수 유형</target>
        </trans-unit>
        <trans-unit id="0392f509cf780dcebf79ba10d500e70f3c35a232" translate="yes" xml:space="preserve">
          <source>Integers in Emacs Lisp are not limited to the machine word size. Under the hood, though, there are two kinds of integers: smaller ones, called &lt;em&gt;fixnums&lt;/em&gt;, and larger ones, called &lt;em&gt;bignums&lt;/em&gt;. Although Emacs Lisp code ordinarily should not depend on whether an integer is a fixnum or a bignum, older Emacs versions support only fixnums, some functions in Emacs still accept only fixnums, and older Emacs Lisp code may have trouble when given bignums. For example, while older Emacs Lisp code could safely compare integers for numeric equality with &lt;code&gt;eq&lt;/code&gt;, the presence of bignums means that equality predicates like &lt;code&gt;eql&lt;/code&gt; and &lt;code&gt;=&lt;/code&gt; should now be used to compare integers.</source>
          <target state="translated">Emacs Lisp의 정수는 기계어 크기에 제한되지 않습니다. 하지만 내부적으로는 두 종류의 정수가 있습니다. 작은 정수는 &lt;em&gt;fixnums&lt;/em&gt; 이고 큰 정수 는 &lt;em&gt;bignums&lt;/em&gt; 입니다. Emacs Lisp 코드는 일반적으로 정수가 고정 번호인지 큰 번호인지에 의존해서는 안되지만, 이전 Emacs 버전은 고정 번호 만 지원하고, Emacs의 일부 함수는 여전히 고정 번호 만 허용하고, 이전 Emacs Lisp 코드는 bignum이 주어지면 문제가 발생할 수 있습니다. 예를 들어, 이전 Emacs Lisp 코드는 숫자가 동일한 지 &lt;code&gt;eq&lt;/code&gt; 와 정수를 안전하게 비교할 수 있었지만 bignums의 존재 는 이제 &lt;code&gt;eql&lt;/code&gt; 및 &lt;code&gt;=&lt;/code&gt; 와 같은 같음 술어를 사용하여 정수를 비교해야 함을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="cdaff6a8856112e0bedf086bd56487ab63649d1a" translate="yes" xml:space="preserve">
          <source>Inter-thread events.</source>
          <target state="translated">스레드 간 이벤트.</target>
        </trans-unit>
        <trans-unit id="6c3d2212a9f9c32cfe9d9e6085463de2a793ed69" translate="yes" xml:space="preserve">
          <source>Interacting with the POSIX locale.</source>
          <target state="translated">POSIX 로케일과 상호 작용.</target>
        </trans-unit>
        <trans-unit id="a8f3404ff9a3b9a61cebb71bc3145a7e8268e559" translate="yes" xml:space="preserve">
          <source>Interaction with normal keymaps</source>
          <target state="translated">일반 키맵과의 상호 작용</target>
        </trans-unit>
        <trans-unit id="3a4d181036b390bfd4c90ee0f787d10de7dd1557" translate="yes" xml:space="preserve">
          <source>Interactive Call</source>
          <target state="translated">대화 형 통화</target>
        </trans-unit>
        <trans-unit id="8c112c62a1db80a1fd6eb4c52dbbd37b94063133" translate="yes" xml:space="preserve">
          <source>Interactive interfaces for redefining keys.</source>
          <target state="translated">키 재정의를위한 대화 형 인터페이스.</target>
        </trans-unit>
        <trans-unit id="bb426c56195b2ae94b49e74ad823d065b0153c08" translate="yes" xml:space="preserve">
          <source>Interactively, &lt;code&gt;byte-recompile-directory&lt;/code&gt; prompts for &lt;var&gt;directory&lt;/var&gt; and &lt;var&gt;flag&lt;/var&gt; is the prefix argument.</source>
          <target state="translated">대화식으로, &lt;code&gt;byte-recompile-directory&lt;/code&gt; 프롬프트는 &lt;var&gt;directory&lt;/var&gt; 및 &lt;var&gt;flag&lt;/var&gt; 를위한 접두사 인수입니다.</target>
        </trans-unit>
        <trans-unit id="89db943b3ea009e2eeb342d7b413658ef1beb7e7" translate="yes" xml:space="preserve">
          <source>Interactively, &lt;var&gt;mode&lt;/var&gt; is read from the minibuffer using &lt;code&gt;read-file-modes&lt;/code&gt; (see below), which lets the user type in either an integer or a string representing the permissions symbolically.</source>
          <target state="translated">대화식으로 &lt;var&gt;mode&lt;/var&gt; 는 &lt;code&gt;read-file-modes&lt;/code&gt; (아래 참조)를 사용하여 미니 버퍼에서 읽혀지며 ,이를 통해 사용자는 권한을 상징적으로 나타내는 정수 또는 문자열로 입력 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ac1b597f72189ba2ae56769e0cdd444c02533a2" translate="yes" xml:space="preserve">
          <source>Interactively, or when &lt;var&gt;display&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the return value is also displayed in the echo area.</source>
          <target state="translated">대화식으로 또는 &lt;var&gt;display&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 반환 값도 에코 영역에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="b6a1797fff7a6f70ada887bad92631a8a9bf2bb1" translate="yes" xml:space="preserve">
          <source>Interfacing to an archive web server</source>
          <target state="translated">아카이브 웹 서버에 연결</target>
        </trans-unit>
        <trans-unit id="6fd6296201ee71e0d25d2f3b29fb410be639536c" translate="yes" xml:space="preserve">
          <source>Interfacing to an archive web server.</source>
          <target state="translated">아카이브 웹 서버에 연결.</target>
        </trans-unit>
        <trans-unit id="b88993e0e807666740f1e6e7487891d4221c3508" translate="yes" xml:space="preserve">
          <source>Internal Border</source>
          <target state="translated">내부 테두리</target>
        </trans-unit>
        <trans-unit id="1f6f7ba7cb7b347a96d1107fab7991d51090ae38" translate="yes" xml:space="preserve">
          <source>Internal mechanisms of image display.</source>
          <target state="translated">이미지 디스플레이의 내부 메커니즘.</target>
        </trans-unit>
        <trans-unit id="aae2d2f7d4d44e63ffbe3d64c1331e1f4a7499c4" translate="yes" xml:space="preserve">
          <source>Internal size of a buffer, i.e., &lt;code&gt;sizeof (struct buffer)&lt;/code&gt;. (Do not confuse with the value returned by &lt;code&gt;buffer-size&lt;/code&gt; function.)</source>
          <target state="translated">버퍼의 내부 크기, 즉 &lt;code&gt;sizeof (struct buffer)&lt;/code&gt; . ( &lt;code&gt;buffer-size&lt;/code&gt; 함수가 반환하는 값과 혼동하지 마십시오 .)</target>
        </trans-unit>
        <trans-unit id="5a032235c1121bf9c1e0179ca7ff43c3f2ac2220" translate="yes" xml:space="preserve">
          <source>Internal size of a cons cell, i.e., &lt;code&gt;sizeof (struct Lisp_Cons)&lt;/code&gt;.</source>
          <target state="translated">cons 셀의 내부 크기, 즉 &lt;code&gt;sizeof (struct Lisp_Cons)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b01e7eab827250f987c16a7e503e6a91dd12d67d" translate="yes" xml:space="preserve">
          <source>Internal size of a float object, i.e., &lt;code&gt;sizeof (struct Lisp_Float)&lt;/code&gt;. (Do not confuse it with the native platform &lt;code&gt;float&lt;/code&gt; or &lt;code&gt;double&lt;/code&gt;.)</source>
          <target state="translated">float 객체의 내부 크기, 즉 &lt;code&gt;sizeof (struct Lisp_Float)&lt;/code&gt; . (기본 플랫폼 &lt;code&gt;float&lt;/code&gt; 또는 &lt;code&gt;double&lt;/code&gt; 과 혼동하지 마십시오 .)</target>
        </trans-unit>
        <trans-unit id="1837980aa62b1a62e48654b616a2e12c11db3594" translate="yes" xml:space="preserve">
          <source>Internal size of a string header, i.e., &lt;code&gt;sizeof (struct Lisp_String)&lt;/code&gt;.</source>
          <target state="translated">문자열 헤더의 내부 크기, 즉 &lt;code&gt;sizeof (struct Lisp_String)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="674373e621338f8918b9cf85fce5944b7e0a8d86" translate="yes" xml:space="preserve">
          <source>Internal size of a symbol, i.e., &lt;code&gt;sizeof (struct Lisp_Symbol)&lt;/code&gt;.</source>
          <target state="translated">심볼의 내부 크기, 즉 &lt;code&gt;sizeof (struct Lisp_Symbol)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4e2cb2dd48ef88f7cd7e24e4c124a254fe9f746" translate="yes" xml:space="preserve">
          <source>Internal size of a vector slot, always equal to &lt;code&gt;sizeof (Lisp_Object)&lt;/code&gt;.</source>
          <target state="translated">벡터 슬롯의 내부 크기, 항상 &lt;code&gt;sizeof (Lisp_Object)&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="0ee27812d3f05af328dcd6e592fdf426cab58207" translate="yes" xml:space="preserve">
          <source>Internal size of an interval object, i.e., &lt;code&gt;sizeof (struct interval)&lt;/code&gt;.</source>
          <target state="translated">간격 객체의 내부 크기, 즉 &lt;code&gt;sizeof (struct interval)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96c24069c6a8e1694d80a391c18f10c673381b44" translate="yes" xml:space="preserve">
          <source>Internally, &lt;code&gt;defalias&lt;/code&gt; normally uses &lt;code&gt;fset&lt;/code&gt; to set the definition. If &lt;var&gt;name&lt;/var&gt; has a &lt;code&gt;defalias-fset-function&lt;/code&gt; property, however, the associated value is used as a function to call in place of &lt;code&gt;fset&lt;/code&gt;.</source>
          <target state="translated">내부적으로 &lt;code&gt;defalias&lt;/code&gt; 는 일반적으로 &lt;code&gt;fset&lt;/code&gt; 을 사용하여 정의를 설정합니다. 그러나 &lt;var&gt;name&lt;/var&gt; 에 &lt;code&gt;defalias-fset-function&lt;/code&gt; 속성 이 있으면 관련 값이 &lt;code&gt;fset&lt;/code&gt; 대신 호출 할 함수로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="068796783fad3a87ca900b7c710e4916ea8b3bc6" translate="yes" xml:space="preserve">
          <source>Internally, &lt;code&gt;defcustom&lt;/code&gt; uses the symbol property &lt;code&gt;standard-value&lt;/code&gt; to record the expression for the standard value, &lt;code&gt;saved-value&lt;/code&gt; to record the value saved by the user with the customization buffer, and &lt;code&gt;customized-value&lt;/code&gt; to record the value set by the user with the customization buffer, but not saved. See &lt;a href=&quot;symbol-properties#Symbol-Properties&quot;&gt;Symbol Properties&lt;/a&gt;. In addition, there&amp;rsquo;s &lt;code&gt;themed-value&lt;/code&gt;, which is used to record the value set by a theme (see &lt;a href=&quot;custom-themes#Custom-Themes&quot;&gt;Custom Themes&lt;/a&gt;). These properties are lists, the car of which is an expression that evaluates to the value.</source>
          <target state="translated">내부적으로 &lt;code&gt;defcustom&lt;/code&gt; 은 기호 속성 &lt;code&gt;standard-value&lt;/code&gt; 를 사용하여 표준 값 에 대한 표현식을 기록하고, &lt;code&gt;saved-value&lt;/code&gt; 를 사용하여 사용자 정의 버퍼를 사용하여 사용자가 저장 한 값 을 기록하고 , custom -value 를 사용하여 사용자 정의 를 통해 사용자가 설정 한 &lt;code&gt;customized-value&lt;/code&gt; 을 기록합니다. 버퍼이지만 저장되지 않았습니다. &lt;a href=&quot;symbol-properties#Symbol-Properties&quot;&gt;기호 속성을&lt;/a&gt; 참조하십시오 . 또한 &lt;code&gt;themed-value&lt;/code&gt; 설정 한 값을 기록하는 데 사용되는 themed-value 가 있습니다 ( &lt;a href=&quot;custom-themes#Custom-Themes&quot;&gt;사용자 지정 테마&lt;/a&gt; 참조 ). 이러한 속성은 목록이며 자동차는 값으로 평가되는 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="d530007eafdd82a256c358d7298bdbec30d8cfb6" translate="yes" xml:space="preserve">
          <source>Internally, &lt;code&gt;make-serial-process&lt;/code&gt; calls &lt;code&gt;serial-process-configure&lt;/code&gt; for the initial configuration of the serial port.</source>
          <target state="translated">내부적으로 &lt;code&gt;make-serial-process&lt;/code&gt; 는 직렬 포트의 초기 구성을 위해 &lt;code&gt;serial-process-configure&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="793925a115b236f980464335670b39f399baa2cd" translate="yes" xml:space="preserve">
          <source>Internally, &lt;code&gt;word-search-forward&lt;/code&gt; and related functions use the function &lt;code&gt;word-search-regexp&lt;/code&gt; to convert &lt;var&gt;string&lt;/var&gt; to a regular expression that ignores punctuation.</source>
          <target state="translated">내부적으로 &lt;code&gt;word-search-forward&lt;/code&gt; 및 관련 함수는 &lt;code&gt;word-search-regexp&lt;/code&gt; 함수를 사용하여 &lt;var&gt;string&lt;/var&gt; 을 구두점을 무시하는 정규식 으로 변환 합니다 .</target>
        </trans-unit>
        <trans-unit id="975cc38153f45730f641194a328f88d442fb0adf" translate="yes" xml:space="preserve">
          <source>Internally, Emacs arranges windows in a tree; each group of siblings has a parent window whose area includes all the siblings. This field points to the window&amp;rsquo;s parent in that tree, as a Lisp object. For the root window of the tree and a minibuffer window this is always &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">내부적으로 Emacs는 창을 트리로 정렬합니다. 각 형제 그룹에는 모든 형제를 포함하는 영역의 부모 창이 있습니다. 이 필드는 Lisp 개체로 해당 트리에서 창의 부모를 가리 킵니다. 트리의 루트 창과 미니 버퍼 창의 경우 이것은 항상 &lt;code&gt;nil&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c9a16f1135c9a066d602dd303b59514a13358f60" translate="yes" xml:space="preserve">
          <source>Internally, Emacs stores each face&amp;rsquo;s default spec in its &lt;code&gt;face-defface-spec&lt;/code&gt; symbol property (see &lt;a href=&quot;symbol-properties#Symbol-Properties&quot;&gt;Symbol Properties&lt;/a&gt;). The &lt;code&gt;saved-face&lt;/code&gt; property stores any face spec saved by the user using the customization buffer; the &lt;code&gt;customized-face&lt;/code&gt; property stores the face spec customized for the current session, but not saved; and the &lt;code&gt;theme-face&lt;/code&gt; property stores an alist associating the active customization settings and Custom themes with the face specs for that face. The face&amp;rsquo;s documentation string is stored in the &lt;code&gt;face-documentation&lt;/code&gt; property.</source>
          <target state="translated">내부적으로, 이맥스는 각면의 기본 사양 저장 &lt;code&gt;face-defface-spec&lt;/code&gt; 기호 속성 (참조 &lt;a href=&quot;symbol-properties#Symbol-Properties&quot;&gt;심볼 속성을&lt;/a&gt; ). &lt;code&gt;saved-face&lt;/code&gt; 속성에는 모든면 스펙 커스터마이즈 버퍼를 사용하여 사용자에 의해 저장; &lt;code&gt;customized-face&lt;/code&gt; 속성에는 얼굴 현재 세션에 대한 사용자 정의 사양하지만, 저장되지; 그리고 &lt;code&gt;theme-face&lt;/code&gt; 속성은 그 얼굴 얼굴 사양과 활성 사용자 정의 설정 및 사용자 정의 테마를 연결 alist를 저장합니다. 얼굴의 문서화 문자열은 &lt;code&gt;face-documentation&lt;/code&gt; 속성에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="890345b36f6729af8e091b77ec37233f091c4268" translate="yes" xml:space="preserve">
          <source>Internally, a byte-code function object is much like a vector; its elements can be accessed using &lt;code&gt;aref&lt;/code&gt;. Its printed representation is like that for a vector, with an additional &amp;lsquo;</source>
          <target state="translated">내부적으로 바이트 코드 함수 객체는 벡터와 매우 유사합니다. 해당 요소는 &lt;code&gt;aref&lt;/code&gt; 를 사용하여 액세스 할 수 있습니다 . 인쇄 된 표현은 벡터의 경우와 같으며 '</target>
        </trans-unit>
        <trans-unit id="c255d867bde58e3eaa0e52e4d12a66d31afbc458" translate="yes" xml:space="preserve">
          <source>Internally, a record object is much like a vector; its slots can be accessed using &lt;code&gt;aref&lt;/code&gt; and it can be copied using &lt;code&gt;copy-sequence&lt;/code&gt;. However, the first slot is used to hold its type as returned by &lt;code&gt;type-of&lt;/code&gt;. Also, in the current implementation records can have at most 4096 slots, whereas vectors can be much larger. Like arrays, records use zero-origin indexing: the first slot has index 0.</source>
          <target state="translated">내부적으로 레코드 객체는 벡터와 매우 유사합니다. &lt;code&gt;aref&lt;/code&gt; 를 사용하여 슬롯에 액세스 할 수 있으며 &lt;code&gt;copy-sequence&lt;/code&gt; 를 사용하여 복사 할 수 있습니다 . 그러나 첫 번째 슬롯은 &lt;code&gt;type-of&lt;/code&gt; 에서 반환 된대로 해당 유형을 유지하는 데 사용됩니다 . 또한 현재 구현에서 레코드는 최대 4096 개의 슬롯을 가질 수있는 반면 벡터는 훨씬 더 클 수 있습니다. 배열과 마찬가지로 레코드는 제로 출처 인덱싱을 사용합니다. 첫 번째 슬롯에는 인덱스 0이 있습니다.</target>
        </trans-unit>
        <trans-unit id="10ce65f3f55d9a82d5a4e5b0c5a3b5dfc8acdf3d" translate="yes" xml:space="preserve">
          <source>Internally, a syntax table is a char-table (see &lt;a href=&quot;char_002dtables#Char_002dTables&quot;&gt;Char-Tables&lt;/a&gt;). The element at index &lt;var&gt;c&lt;/var&gt; describes the character with code &lt;var&gt;c&lt;/var&gt;; its value is a cons cell which specifies the syntax of the character in question. See &lt;a href=&quot;syntax-table-internals#Syntax-Table-Internals&quot;&gt;Syntax Table Internals&lt;/a&gt;, for details. However, instead of using &lt;code&gt;aset&lt;/code&gt; and &lt;code&gt;aref&lt;/code&gt; to modify and inspect syntax table contents, you should usually use the higher-level functions &lt;code&gt;char-syntax&lt;/code&gt; and &lt;code&gt;modify-syntax-entry&lt;/code&gt;, which are described in &lt;a href=&quot;syntax-table-functions#Syntax-Table-Functions&quot;&gt;Syntax Table Functions&lt;/a&gt;.</source>
          <target state="translated">내부적으로 구문 테이블은 문자 테이블입니다 ( &lt;a href=&quot;char_002dtables#Char_002dTables&quot;&gt;Char-Tables&lt;/a&gt; 참조 ). 색인 &lt;var&gt;c&lt;/var&gt; 의 요소는 코드 &lt;var&gt;c&lt;/var&gt; 로 문자를 설명합니다 . 그 값은 해당 문자의 구문을 지정하는 cons 셀입니다. 자세한 내용은 &lt;a href=&quot;syntax-table-internals#Syntax-Table-Internals&quot;&gt;구문 테이블 내부&lt;/a&gt; 를 참조하십시오. 그러나 &lt;code&gt;aset&lt;/code&gt; 및 &lt;code&gt;aref&lt;/code&gt; 를 사용하여 구문 테이블 내용을 수정하고 검사하는 대신 일반적으로 &lt;a href=&quot;syntax-table-functions#Syntax-Table-Functions&quot;&gt;구문 테이블 함수에&lt;/a&gt; 설명 된 상위 수준 함수 &lt;code&gt;char-syntax&lt;/code&gt; 및 &lt;code&gt;modify-syntax-entry&lt;/code&gt; 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ab6dcb624548f874717d593593cde5ae43f61956" translate="yes" xml:space="preserve">
          <source>Internally, the dynamic loading of documentation strings is accomplished by writing compiled files with a special Lisp reader construct, &amp;lsquo;</source>
          <target state="translated">내부적으로 문서 문자열의 동적로드는 특수 Lisp 판독기 구조 ''로 컴파일 된 파일을 작성하여 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="6c7d074b02409a43b3c3691b8e3eff070049c70c" translate="yes" xml:space="preserve">
          <source>Internally, the set of parents is stored in the &lt;code&gt;error-conditions&lt;/code&gt; property of the error symbol and the message is stored in the &lt;code&gt;error-message&lt;/code&gt; property of the error symbol.</source>
          <target state="translated">내부적으로 상위 집합은 오류 기호의 오류 &lt;code&gt;error-conditions&lt;/code&gt; 속성에 저장되고 메시지는 오류 기호의 오류 &lt;code&gt;error-message&lt;/code&gt; 속성에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="5b6293020ceb499ae9005377abda5b9d10b853fe" translate="yes" xml:space="preserve">
          <source>Internally, this function creates an overlay, and gives it a &lt;code&gt;before-string&lt;/code&gt; property containing text that has a &lt;code&gt;display&lt;/code&gt; property whose value is the image. (Whew!)</source>
          <target state="translated">내부적으로이 함수는 오버레이를 만들고 값이 이미지 인 &lt;code&gt;display&lt;/code&gt; 속성 이있는 텍스트를 포함하는 &lt;code&gt;before-string&lt;/code&gt; 속성을 제공합니다 . (아휴!)</target>
        </trans-unit>
        <trans-unit id="ad027260c034e64a0aed9ec0c21434a870d67bde" translate="yes" xml:space="preserve">
          <source>Internally, this function inserts &lt;var&gt;string&lt;/var&gt; in the buffer, and gives it a &lt;code&gt;display&lt;/code&gt; property which specifies &lt;var&gt;image&lt;/var&gt;. See &lt;a href=&quot;display-property#Display-Property&quot;&gt;Display Property&lt;/a&gt;.</source>
          <target state="translated">내부적으로이 함수 는 버퍼에 &lt;var&gt;string&lt;/var&gt; 을 삽입 하고 &lt;var&gt;image&lt;/var&gt; 를 지정 하는 &lt;code&gt;display&lt;/code&gt; 속성을 제공합니다 . &lt;a href=&quot;display-property#Display-Property&quot;&gt;표시 속성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d82805e46a43054034aa8dbdc3072940853963ca" translate="yes" xml:space="preserve">
          <source>Internals of Drag-and-Drop implementation.</source>
          <target state="translated">드래그 앤 드롭 구현의 내부.</target>
        </trans-unit>
        <trans-unit id="0878947a69e042d32e6c0e5b544cd467d1e941d1" translate="yes" xml:space="preserve">
          <source>Internals of the Debugger</source>
          <target state="translated">디버거의 내부</target>
        </trans-unit>
        <trans-unit id="f059416759860bf53ccffccb3662c0ac1c504a36" translate="yes" xml:space="preserve">
          <source>Internals of the Kill Ring</source>
          <target state="translated">킬 링의 내부</target>
        </trans-unit>
        <trans-unit id="c8a6d283f50874c1f273c7066e8f6024a632ca2a" translate="yes" xml:space="preserve">
          <source>International characters in strings.</source>
          <target state="translated">문자열의 국제 문자.</target>
        </trans-unit>
        <trans-unit id="2a55fdbcbc93e7871a3735ecdecb37fb80ceb461" translate="yes" xml:space="preserve">
          <source>Interning ensures that each obarray has just one symbol with any particular name. Other like-named symbols may exist, but not in the same obarray. Thus, the reader gets the same symbols for the same names, as long as you keep reading with the same obarray.</source>
          <target state="translated">인턴은 각 오바 레이가 특정 이름을 가진 하나의 기호 만 갖도록합니다. 유사한 이름의 다른 기호가 존재할 수 있지만 동일한 오바 레이에는 없습니다. 따라서 독자는 동일한 오바 레이로 계속 읽는 한 동일한 이름에 대해 동일한 기호를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="a82f77a8f55334d8bb59e260c5127cc00a4536b2" translate="yes" xml:space="preserve">
          <source>Interning usually happens automatically in the reader, but sometimes other programs need to do it. For example, after the</source>
          <target state="translated">인턴은 일반적으로 독자에서 자동으로 이루어 지지만 때로는 다른 프로그램에서이를 수행해야합니다. 예를 들어,</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="8ed8ee7e55170bcbcc50e6f4ddad4940be31b3b2" translate="yes" xml:space="preserve">
          <source>Introduction and concepts.</source>
          <target state="translated">소개 및 개념.</target>
        </trans-unit>
        <trans-unit id="f63dc883116ea7e854aa44d7f9ec4421e0ce2395" translate="yes" xml:space="preserve">
          <source>Introduction and conventions used.</source>
          <target state="translated">사용 된 소개 및 규칙.</target>
        </trans-unit>
        <trans-unit id="b8caf81bc82bf9149f7f4f8ca46a4d2df8d59d59" translate="yes" xml:space="preserve">
          <source>Introduction to Buffer-Local Variables</source>
          <target state="translated">버퍼 로컬 변수 소개</target>
        </trans-unit>
        <trans-unit id="ca959ab108e8c4b82e06c2cd8e7df1402c2fdca1" translate="yes" xml:space="preserve">
          <source>Introduction to Evaluation</source>
          <target state="translated">평가 소개</target>
        </trans-unit>
        <trans-unit id="424b5352ecd6aed0c4787a5e67cf7822394d4180" translate="yes" xml:space="preserve">
          <source>Introduction to Minibuffers</source>
          <target state="translated">미니 버퍼 소개</target>
        </trans-unit>
        <trans-unit id="08f3e034c9cceb45ce8ecb8f79ad7b810051e748" translate="yes" xml:space="preserve">
          <source>Introduction to Reading and Printing</source>
          <target state="translated">읽기 및 인쇄 소개</target>
        </trans-unit>
        <trans-unit id="97ad18054b9569eed06f9ecf25bb01ba9f0544fc" translate="yes" xml:space="preserve">
          <source>Introduction to use of Edebug.</source>
          <target state="translated">Edebug 사용 소개.</target>
        </trans-unit>
        <trans-unit id="fb00fd291ed8bdc1da78f75b2dfea4fe96a9552c" translate="yes" xml:space="preserve">
          <source>Invalid coding system</source>
          <target state="translated">잘못된 코딩 시스템</target>
        </trans-unit>
        <trans-unit id="f4da90dedff4144a88b3f5641db5e04aea389b0e" translate="yes" xml:space="preserve">
          <source>Invalid format operation</source>
          <target state="translated">잘못된 형식 작업</target>
        </trans-unit>
        <trans-unit id="05b9e32cfa1dec4a8735af4f154c5c0b16324e49" translate="yes" xml:space="preserve">
          <source>Invalid function</source>
          <target state="translated">잘못된 기능</target>
        </trans-unit>
        <trans-unit id="21f66391b38e2d6c5385ca6d73c08b6046139bff" translate="yes" xml:space="preserve">
          <source>Invalid read syntax</source>
          <target state="translated">잘못된 읽기 구문</target>
        </trans-unit>
        <trans-unit id="39af5982d90c7c046f2c0e30d3c43a0d69f7c511" translate="yes" xml:space="preserve">
          <source>Invalid read syntax: &quot;)&quot;</source>
          <target state="translated">잘못된 읽기 구문 : &quot;)&quot;</target>
        </trans-unit>
        <trans-unit id="1f526a95f220fa3e397793791a95103a25349fa5" translate="yes" xml:space="preserve">
          <source>Invalid regexp</source>
          <target state="translated">잘못된 정규식</target>
        </trans-unit>
        <trans-unit id="c28782659524c74728d4791e47ac0768f2d2a2fa" translate="yes" xml:space="preserve">
          <source>Invisible Text</source>
          <target state="translated">보이지 않는 텍스트</target>
        </trans-unit>
        <trans-unit id="1ba45e6efe9b69076beb81f22754c2276b515f29" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;pop-to-buffer&lt;/code&gt; to proceed.</source>
          <target state="translated">계속 &lt;code&gt;pop-to-buffer&lt;/code&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="2b6f179c44acf946ea87d5fd9a67e79980a7bf28" translate="yes" xml:space="preserve">
          <source>Invoking the Debugger</source>
          <target state="translated">디버거 호출</target>
        </trans-unit>
        <trans-unit id="3b5c7ed80b795c31ca809c1980f8e9b7ef9b7cb4" translate="yes" xml:space="preserve">
          <source>Invoking the Input Method</source>
          <target state="translated">입력 방법 호출</target>
        </trans-unit>
        <trans-unit id="f95535be202c390af54850aaa2b9814ce9f60024" translate="yes" xml:space="preserve">
          <source>Invoking the minibuffer with completion.</source>
          <target state="translated">완료와 함께 미니 버퍼를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="d82cb1a6affac049d5e0a64e8bc2eabc7098b52a" translate="yes" xml:space="preserve">
          <source>Is a given file readable? Writable?</source>
          <target state="translated">주어진 파일을 읽을 수 있습니까? 쓰기 가능?</target>
        </trans-unit>
        <trans-unit id="cc345fde3dff917a2877747ac2b2a0a59a508cad" translate="yes" xml:space="preserve">
          <source>Is it a directory? A symbolic link?</source>
          <target state="translated">디렉토리입니까? 심볼릭 링크?</target>
        </trans-unit>
        <trans-unit id="ce731c05fc64ab5b57ee9d5ba394e0ea5eb6be0b" translate="yes" xml:space="preserve">
          <source>Is this object a list? Comparing two lists.</source>
          <target state="translated">이 개체가 목록입니까? 두 목록을 비교합니다.</target>
        </trans-unit>
        <trans-unit id="faf1e5134b7192f681808c3c7a3dcf14d24adcce" translate="yes" xml:space="preserve">
          <source>It adds subdirectories to &lt;code&gt;load-path&lt;/code&gt;, by running the file named</source>
          <target state="translated">이름이 지정된 파일을 실행하여 &lt;code&gt;load-path&lt;/code&gt; 에 하위 디렉토리를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="26ebe0ae609401a2ad28c4f3ef880f902fb57804" translate="yes" xml:space="preserve">
          <source>It also affects decisions about whether to scroll part of the screen or repaint on text terminals. See &lt;a href=&quot;forcing-redisplay#Forcing-Redisplay&quot;&gt;Forcing Redisplay&lt;/a&gt;, for the corresponding functionality on graphical terminals.</source>
          <target state="translated">또한 화면의 일부를 스크롤할지 또는 텍스트 터미널에서 다시 칠할지에 대한 결정에도 영향을 미칩니다. 그래픽 터미널의 해당 기능에 대해서는 &lt;a href=&quot;forcing-redisplay#Forcing-Redisplay&quot;&gt;강제 다시 표시를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a4141f73f90581e1ab9aa132384bbf4e5ae08ded" translate="yes" xml:space="preserve">
          <source>It also applies to any asynchronous subprocess or network stream, but in a different way: the value of &lt;code&gt;coding-system-for-read&lt;/code&gt; when you start the subprocess or open the network stream specifies the input decoding method for that subprocess or network stream. It remains in use for that subprocess or network stream unless and until overridden.</source>
          <target state="translated">또한 모든 비동기 하위 프로세스 또는 네트워크 스트림에 적용되지만 다른 방식으로 하위 프로세스를 시작하거나 네트워크 스트림을 열 때 &lt;code&gt;coding-system-for-read&lt;/code&gt; 값은 해당 하위 프로세스 또는 네트워크 스트림에 대한 입력 디코딩 방법을 지정합니다. 재정의 될 때까지 해당 하위 프로세스 또는 네트워크 스트림에 대해 계속 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="aace0e7e04bb1701d0b33950723bc535b0281f25" translate="yes" xml:space="preserve">
          <source>It also displays the symbols in a buffer named</source>
          <target state="translated">또한 이름이 지정된 버퍼에 기호를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="10f4c6d92e33b4069ea7366cc5044b10b6555757" translate="yes" xml:space="preserve">
          <source>It always returns &lt;code&gt;t&lt;/code&gt; for buffers that are not visiting a file, even if &lt;code&gt;visited-file-modtime&lt;/code&gt; returns a non-zero value. For instance, it always returns &lt;code&gt;t&lt;/code&gt; for dired buffers. It returns &lt;code&gt;t&lt;/code&gt; for buffers that are visiting a file that does not exist and never existed, but &lt;code&gt;nil&lt;/code&gt; for file-visiting buffers whose file has been deleted.</source>
          <target state="translated">&lt;code&gt;visited-file-modtime&lt;/code&gt; 이 0이 아닌 값을 반환 하더라도 파일을 방문하지 않는 버퍼에 대해서는 항상 &lt;code&gt;t&lt;/code&gt; 를 반환합니다. 예를 들어, dired 버퍼에 대해서는 항상 &lt;code&gt;t&lt;/code&gt; 를 반환합니다 . 존재하지 않고 존재하지 않는 파일을 방문하는 버퍼에 대해서는 &lt;code&gt;t&lt;/code&gt; 를 반환 하고 파일 이 삭제 된 파일 방문 버퍼에 대해서는 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="36679f079089d8681a01f756abfb5ab13128d005" translate="yes" xml:space="preserve">
          <source>It always sets the file modes of the copied files to match the corresponding original file.</source>
          <target state="translated">항상 해당 원본 파일과 일치하도록 복사 된 파일의 파일 모드를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="68c121eadb6645154879627e1f8f4d91b9159e0d" translate="yes" xml:space="preserve">
          <source>It blocks out all process output (since Emacs accepts process output only while waiting).</source>
          <target state="translated">모든 프로세스 출력을 차단합니다 (Emacs는 대기 중에 만 프로세스 출력을 수락하기 때문에).</target>
        </trans-unit>
        <trans-unit id="db1622f7113638a1b6cf00fc1d147d1151f5939d" translate="yes" xml:space="preserve">
          <source>It blocks out any idle timers that ought to run during that time.</source>
          <target state="translated">해당 시간 동안 실행해야하는 유휴 타이머를 차단합니다.</target>
        </trans-unit>
        <trans-unit id="500a99712580a0fd93b02db9ad0f50b8dfd5061d" translate="yes" xml:space="preserve">
          <source>It calls &lt;code&gt;frame-notice-user-settings&lt;/code&gt;, which modifies the parameters of the selected frame according to whatever the init files specify.</source>
          <target state="translated">init 파일이 지정하는 것에 따라 선택된 프레임의 매개 변수를 수정하는 &lt;code&gt;frame-notice-user-settings&lt;/code&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="08316562225e169cff224da3eaa939766d93f6e4" translate="yes" xml:space="preserve">
          <source>It calls the function &lt;code&gt;package-activate-all&lt;/code&gt; to activate any optional Emacs Lisp package that has been installed. See &lt;a href=&quot;packaging-basics#Packaging-Basics&quot;&gt;Packaging Basics&lt;/a&gt;. However, Emacs doesn&amp;rsquo;t activate the packages when &lt;code&gt;package-enable-at-startup&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt; or when it&amp;rsquo;s started with one of the options &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;package-activate-all&lt;/code&gt; 함수를 호출하여 설치된 선택적 Emacs Lisp 패키지를 활성화합니다. &lt;a href=&quot;packaging-basics#Packaging-Basics&quot;&gt;패키징 기본 사항을&lt;/a&gt; 참조하십시오 . 그러나 Emacs는 &lt;code&gt;package-enable-at-startup&lt;/code&gt; 이 &lt;code&gt;nil&lt;/code&gt; 이거나 옵션 중 하나로 시작될 때 패키지를 활성화하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0136b0ca24d16b01a291e47bd7153f4f2fba2a73" translate="yes" xml:space="preserve">
          <source>It creates the submenu &lt;var&gt;menu-title&lt;/var&gt; specified by &lt;var&gt;sub-alist&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;sub-alist&lt;/var&gt; 에서 지정한 하위 &lt;var&gt;menu-title&lt;/var&gt; 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="69c1303d35db5ea0aad7fd95fc917c9a224ef2f1" translate="yes" xml:space="preserve">
          <source>It displays the &lt;em&gt;startup screen&lt;/em&gt;, which is a special buffer that contains information about copyleft and basic Emacs usage. This is not done if &lt;code&gt;inhibit-startup-screen&lt;/code&gt; or &lt;code&gt;initial-buffer-choice&lt;/code&gt; are non-&lt;code&gt;nil&lt;/code&gt;, or if the &amp;lsquo;</source>
          <target state="translated">카피 레프트 및 기본 Emacs 사용에 대한 정보를 포함하는 특수 버퍼 인 &lt;em&gt;시작 화면을&lt;/em&gt; 표시합니다 . 이 경우에 수행되지 &lt;code&gt;inhibit-startup-screen&lt;/code&gt; 또는 &lt;code&gt;initial-buffer-choice&lt;/code&gt; 비이다 &lt;code&gt;nil&lt;/code&gt; 경우, 또는 '</target>
        </trans-unit>
        <trans-unit id="26297586b2674d5e45392b02c3a4a0a6b4471608" translate="yes" xml:space="preserve">
          <source>It displays the initial echo area message, unless you have suppressed that with &lt;code&gt;inhibit-startup-echo-area-message&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;inhibit-startup-echo-area-message&lt;/code&gt; 를 사용하여 억제 하지 않는 한 초기 에코 영역 메시지를 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="deb0e9c99bf58c06b6f38c7c256f96f0b734089a" translate="yes" xml:space="preserve">
          <source>It does not matter to the caller of a function whether the function is primitive. However, this does matter if you try to redefine a primitive with a function written in Lisp. The reason is that the primitive function may be called directly from C code. Calls to the redefined function from Lisp will use the new definition, but calls from C code may still use the built-in definition. Therefore, &lt;strong&gt;we discourage redefinition of primitive functions&lt;/strong&gt;.</source>
          <target state="translated">함수가 기본인지 여부는 함수 호출자에게 중요하지 않습니다. 그러나 Lisp로 작성된 함수로 프리미티브를 재정의하려는 경우 이는 중요합니다. 그 이유는 기본 함수가 C 코드에서 직접 호출 될 수 있기 때문입니다. Lisp에서 재정의 된 함수에 대한 호출은 새 정의를 사용하지만 C 코드의 호출은 여전히 ​​기본 제공 정의를 사용할 수 있습니다. 따라서 &lt;strong&gt;우리는 원시 함수의 재정의를 권장하지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="dc2cfa8003c37f1bb7b6976cb93df4aaf5e867c7" translate="yes" xml:space="preserve">
          <source>It does some basic parsing of the command-line arguments.</source>
          <target state="translated">명령 줄 인수에 대한 몇 가지 기본 구문 분석을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="780d4f9cb3c97b4270953a6df1b1b787aacbefcb" translate="yes" xml:space="preserve">
          <source>It first deletes any child frame of &lt;var&gt;frame&lt;/var&gt; (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;) and any frame whose &lt;code&gt;delete-before&lt;/code&gt; frame parameter (see &lt;a href=&quot;frame-interaction-parameters#Frame-Interaction-Parameters&quot;&gt;Frame Interaction Parameters&lt;/a&gt;) specifies &lt;var&gt;frame&lt;/var&gt;. All such deletions are performed recursively; so this step makes sure that no other frames with &lt;var&gt;frame&lt;/var&gt; as their ancestor will exist. Then, unless &lt;var&gt;frame&lt;/var&gt; specifies a tooltip, this function runs the hook &lt;code&gt;delete-frame-functions&lt;/code&gt; (each function getting one argument, &lt;var&gt;frame&lt;/var&gt;) before actually killing the frame. After actually killing the frame and removing the frame from the frame list, &lt;code&gt;delete-frame&lt;/code&gt; runs &lt;code&gt;after-delete-frame-functions&lt;/code&gt;.</source>
          <target state="translated">그것은 첫째의 하위 프레임 삭제 &lt;var&gt;frame&lt;/var&gt; (참조 &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;아이 프레임을&lt;/a&gt; ) 누구의 어떤 프레임 &lt;code&gt;delete-before&lt;/code&gt; 프레임 매개 변수 (참조 &lt;a href=&quot;frame-interaction-parameters#Frame-Interaction-Parameters&quot;&gt;프레임 상호 작용 매개 변수&lt;/a&gt; ) 지정의 &lt;var&gt;frame&lt;/var&gt; . 이러한 모든 삭제는 반복적으로 수행됩니다. 그래서이 단계와 다른 프레임 있는지 확인합니다 &lt;var&gt;frame&lt;/var&gt; 자신의 조상이 존재하지 않습니다한다. 그런 다음 &lt;var&gt;frame&lt;/var&gt; 이 툴팁을 지정 하지 않는 한 ,이 함수는 &lt;var&gt;frame&lt;/var&gt; 을 실제로 죽이기 전에 hook &lt;code&gt;delete-frame-functions&lt;/code&gt; (각 함수가 하나의 인수 인 frame )를 실행합니다. 실제로 프레임을 죽이고 프레임 목록에서 프레임을 제거한 후 &lt;code&gt;delete-frame&lt;/code&gt; 이 실행됩니다. &lt;code&gt;after-delete-frame-functions&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="65b6824863bde18952e797a108d59972b5cd7ca4" translate="yes" xml:space="preserve">
          <source>It follows the cyclic ordering of windows. The optional arguments &lt;var&gt;minibuf&lt;/var&gt; and &lt;var&gt;all-frames&lt;/var&gt; specify the set of windows included; these have the same arguments as in &lt;code&gt;next-window&lt;/code&gt;. If &lt;var&gt;all-frames&lt;/var&gt; specifies a frame, the first window walked is the first window on that frame (the one returned by &lt;code&gt;frame-first-window&lt;/code&gt;), not necessarily the selected window.</source>
          <target state="translated">윈도우의 주기적 순서를 따릅니다. 선택적 인수 &lt;var&gt;minibuf&lt;/var&gt; 및 &lt;var&gt;all-frames&lt;/var&gt; 는 포함 된 창 세트를 지정합니다. 이들은 &lt;code&gt;next-window&lt;/code&gt; 에서와 동일한 인수를 갖습니다 . &lt;var&gt;all-frames&lt;/var&gt; 지정하는 경우 , 걸어 간 첫 번째 창은 해당 프레임의 첫 번째 창 ( &lt;code&gt;frame-first-window&lt;/code&gt; 에서 반환 된 창 )이며 반드시 선택한 창일 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="d6d1323f650d9889c77490ede806efe0a1b71711" translate="yes" xml:space="preserve">
          <source>It initializes the initial frame&amp;rsquo;s faces, and sets up the menu bar and tool bar if needed. If graphical frames are supported, it sets up the tool bar even if the current frame is not a graphical one, since a graphical frame may be created later on.</source>
          <target state="translated">초기 프레임의 얼굴을 초기화하고 필요한 경우 메뉴 모음과 도구 모음을 설정합니다. 그래픽 프레임이 지원되는 경우 나중에 그래픽 프레임이 생성 될 수 있으므로 현재 프레임이 그래픽 프레임이 아니더라도 도구 모음을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="4dd46431e678931fbcb6b6537b9da5f2a07769f6" translate="yes" xml:space="preserve">
          <source>It inserts frequency counts as comment lines after each line of code. You can undo all insertions with one &lt;code&gt;undo&lt;/code&gt; command. The counts appear under the &amp;lsquo;</source>
          <target state="translated">각 코드 줄 뒤에 주석 줄로 빈도 수를 삽입합니다. 하나의 &lt;code&gt;undo&lt;/code&gt; 명령으로 모든 삽입을 실행 취소 할 수 있습니다 . 개수는 '</target>
        </trans-unit>
        <trans-unit id="3173cca5c8e25be905c421498d74ebe861b45fb4" translate="yes" xml:space="preserve">
          <source>It is a good idea for this function to run &lt;code&gt;temp-buffer-show-hook&lt;/code&gt; just as &lt;code&gt;with-output-to-temp-buffer&lt;/code&gt; normally would, inside of &lt;code&gt;save-selected-window&lt;/code&gt; and with the chosen window and buffer selected.</source>
          <target state="translated">이 함수 는 &lt;code&gt;save-selected-window&lt;/code&gt; 내 에서 선택한 창과 버퍼를 선택한 상태에서 일반적 으로 &lt;code&gt;with-output-to-temp-buffer&lt;/code&gt; 처럼 &lt;code&gt;temp-buffer-show-hook&lt;/code&gt; 을 실행하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="12a15b18bad26a84d1b400ed140fae6294485d46" translate="yes" xml:space="preserve">
          <source>It is a good idea to provide documentation strings for all the functions in your program, even those that are called only from within your program. Documentation strings are like comments, except that they are easier to access.</source>
          <target state="translated">프로그램 내에서만 호출되는 함수를 포함하여 프로그램의 모든 함수에 대한 문서 문자열을 제공하는 것이 좋습니다. 문서 문자열은 액세스하기 쉽다는 점을 제외하면 주석과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f01ee6ca8bab6f5d9577b6a2063514f28c09839e" translate="yes" xml:space="preserve">
          <source>It is also legitimate for a major mode to rebind a standard key sequence whose standard meaning is rarely useful in that mode. For instance, minibuffer modes rebind</source>
          <target state="translated">또한 주 모드가 해당 모드에서 거의 유용하지 않은 표준 의미를 갖는 표준 키 시퀀스를 리 바인드하는 것도 합법적입니다. 예를 들어, 미니 버퍼 모드는</target>
        </trans-unit>
        <trans-unit id="2b57f5bccf3ef0816a9be0839152c423c58bb643" translate="yes" xml:space="preserve">
          <source>It is also possible to call &lt;code&gt;sit-for&lt;/code&gt; with three arguments, as &lt;code&gt;(sit-for &lt;var&gt;seconds&lt;/var&gt; &lt;var&gt;millisec&lt;/var&gt; &lt;var&gt;nodisp&lt;/var&gt;)&lt;/code&gt;, but that is considered obsolete.</source>
          <target state="translated">&lt;code&gt;(sit-for &lt;var&gt;seconds&lt;/var&gt; &lt;var&gt;millisec&lt;/var&gt; &lt;var&gt;nodisp&lt;/var&gt;)&lt;/code&gt; &lt;var&gt;seconds&lt;/var&gt; &lt;var&gt;millisec&lt;/var&gt; &lt;var&gt;nodisp&lt;/var&gt; ) 와 같이 세 개의 인수 &lt;code&gt;sit-for&lt;/code&gt; 하여 sit-for 를 호출 할 수도 있지만 이는 구식으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="baad5ec4e1257ce583e2c8021e1913799f72c849" translate="yes" xml:space="preserve">
          <source>It is also possible to find out how many arguments an arbitrary function expects:</source>
          <target state="translated">임의의 함수가 예상하는 인수 수를 알아낼 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6c145fead22c2d038d5449b927625f21786cd2b" translate="yes" xml:space="preserve">
          <source>It is also possible to watch filesystems on remote machines, see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Remote-Files.html#Remote-Files&quot;&gt;Remote Files&lt;/a&gt; in</source>
          <target state="translated">원격 컴퓨터에서 파일 시스템을 지켜 볼 수도 있습니다 &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Remote-Files.html#Remote-Files&quot;&gt;파일을 원격&lt;/a&gt; 에서</target>
        </trans-unit>
        <trans-unit id="3e621862bcf1c790b5d037616916bbe2c538d4f7" translate="yes" xml:space="preserve">
          <source>It is an error to call &lt;code&gt;condition-wait&lt;/code&gt; without holding the condition&amp;rsquo;s associated mutex.</source>
          <target state="translated">조건과 연관된 뮤텍스를 보유하지 않고 &lt;code&gt;condition-wait&lt;/code&gt; 를 호출하는 것은 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="a7b086934bad52d2aec76907ca52328c3844b39e" translate="yes" xml:space="preserve">
          <source>It is an error to make a constant or a read-only variable buffer-local. See &lt;a href=&quot;constant-variables#Constant-Variables&quot;&gt;Constant Variables&lt;/a&gt;.</source>
          <target state="translated">상수 또는 읽기 전용 변수를 버퍼 로컬로 만드는 것은 오류입니다. &lt;a href=&quot;constant-variables#Constant-Variables&quot;&gt;상수 변수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="72843249d94cfc895b70ea2d9791255b690c126e" translate="yes" xml:space="preserve">
          <source>It is assumed that when a caller of &lt;code&gt;display-buffer&lt;/code&gt; specifies a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;allow-no-window&lt;/code&gt; entry, it is also able to handle a &lt;code&gt;nil&lt;/code&gt; return value.</source>
          <target state="translated">&lt;code&gt;display-buffer&lt;/code&gt; 호출자가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 &lt;code&gt;allow-no-window&lt;/code&gt; 항목을 지정 하면 &lt;code&gt;nil&lt;/code&gt; 반환 값도 처리 할 수 ​​있다고 가정 합니다.</target>
        </trans-unit>
        <trans-unit id="3f80f1cfd1cf04e4bc17393008731d354dfb2372" translate="yes" xml:space="preserve">
          <source>It is best to avoid mentioning specific bit numbers in your program. To test the modifier bits of a character, use the function &lt;code&gt;event-modifiers&lt;/code&gt; (see &lt;a href=&quot;classifying-events#Classifying-Events&quot;&gt;Classifying Events&lt;/a&gt;). When making key bindings, you can use the read syntax for characters with modifier bits (&amp;lsquo;</source>
          <target state="translated">프로그램에서 특정 비트 번호를 언급하지 않는 것이 가장 좋습니다. 문자의 수정 자 비트를 테스트하려면 &lt;code&gt;event-modifiers&lt;/code&gt; 함수를 사용하십시오 ( &lt;a href=&quot;classifying-events#Classifying-Events&quot;&gt;이벤트 분류&lt;/a&gt; 참조 ). 키 바인딩을 만들 때 수정 자 비트 ( ')가있는 문자에 대해 읽기 구문을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d52a1fb8bf86f61e2abf981d0b44f7de8aa8b26" translate="yes" xml:space="preserve">
          <source>It is common for Lisp functions to accept functions as arguments or find them in data structures (especially in hook variables and property lists) and call them using &lt;code&gt;funcall&lt;/code&gt; or &lt;code&gt;apply&lt;/code&gt;. Functions that accept function arguments are often called &lt;em&gt;functionals&lt;/em&gt;.</source>
          <target state="translated">Lisp 함수는 함수를 인수로 받아들이거나 데이터 구조 (특히 후크 변수 및 속성 목록에서)에서 &lt;code&gt;funcall&lt;/code&gt; 또는 &lt;code&gt;apply&lt;/code&gt; 를 사용하여 호출하는 것이 일반적 입니다. 함수 인수를받는 함수를 종종 &lt;em&gt;함수&lt;/em&gt; 라고 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3f754947b959e216056814f1e32b8d9283beb7a0" translate="yes" xml:space="preserve">
          <source>It is common to add code to one&amp;rsquo;s init file (see &lt;a href=&quot;init-file#Init-File&quot;&gt;Init File&lt;/a&gt;) to add one or more directories to &lt;code&gt;load-path&lt;/code&gt;. For example:</source>
          <target state="translated">&lt;code&gt;load-path&lt;/code&gt; 에 하나 이상의 디렉토리를 추가하기 위해 init 파일 ( &lt;a href=&quot;init-file#Init-File&quot;&gt;Init 파일&lt;/a&gt; 참조 )에 코드를 추가하는 것이 일반적 입니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="b83625c7041cfe9ad97f496a0522d9523b3b8dc4" translate="yes" xml:space="preserve">
          <source>It is common to write numbers, characters, strings, and even vectors in Lisp code, taking advantage of the fact that they self-evaluate. However, it is quite unusual to do this for types that lack a read syntax, because there&amp;rsquo;s no way to write them textually. It is possible to construct Lisp expressions containing these types by means of a Lisp program. Here is an example:</source>
          <target state="translated">Lisp 코드에서 숫자, 문자, 문자열 및 벡터를 작성하는 것이 일반적이며 자체 평가한다는 사실을 활용합니다. 그러나 읽기 구문이없는 유형에 대해이 작업을 수행하는 것은 매우 드문 일입니다. 텍스트로 작성할 방법이 없기 때문입니다. Lisp 프로그램을 사용하여 이러한 유형을 포함하는 Lisp 표현식을 구성 할 수 있습니다. 다음은 그 예입니다.</target>
        </trans-unit>
        <trans-unit id="6c4f2df1721f4ac95ab46d4cfe55ed881a7d9df2" translate="yes" xml:space="preserve">
          <source>It is equally easy to insert a new element by changing &lt;small&gt;CDR&lt;/small&gt;s:</source>
          <target state="translated">&lt;small&gt;CDR&lt;/small&gt; 을 변경하여 새 요소를 삽입하는 것도 똑같이 쉽습니다 .</target>
        </trans-unit>
        <trans-unit id="66640a1037abec141a287214c7037d4b09466e4e" translate="yes" xml:space="preserve">
          <source>It is generally cleaner and more flexible to store a function in a data structure, and call it with &lt;code&gt;funcall&lt;/code&gt; or &lt;code&gt;apply&lt;/code&gt;, than to store an expression in the data structure and evaluate it. Using functions provides the ability to pass information to them as arguments.</source>
          <target state="translated">일반적으로 데이터 구조에 함수를 저장하고 데이터 구조에 표현식을 저장하고 평가하는 것보다 &lt;code&gt;funcall&lt;/code&gt; 또는 &lt;code&gt;apply&lt;/code&gt; 로 호출하는 것이 더 깨끗하고 유연 합니다. 함수를 사용하면 정보를 인수로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7224f1903528385d0d899a0e49ee687a6aa9d558" translate="yes" xml:space="preserve">
          <source>It is generally impossible to read the same sequence twice, since sequences are always created anew upon reading. If you read the read syntax for a sequence twice, you get two sequences with equal contents. There is one exception: the empty list &lt;code&gt;()&lt;/code&gt; always stands for the same object, &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">동일한 시퀀스를 두 번 읽는 것은 일반적으로 불가능합니다. 읽기시 시퀀스가 ​​항상 새로 생성되기 때문입니다. 시퀀스에 대한 읽기 구문을 두 번 읽으면 동일한 내용을 가진 두 시퀀스를 얻습니다. 한 가지 예외가 있습니다. 빈 목록 &lt;code&gt;()&lt;/code&gt; 은 항상 같은 객체 인 &lt;code&gt;nil&lt;/code&gt; 을 나타 냅니다.</target>
        </trans-unit>
        <trans-unit id="e2e4677a7491341a5525f2d613fb39d09d0efa30" translate="yes" xml:space="preserve">
          <source>It is implemented using the watchpoint mechanism, so it inherits the same characteristics and limitations: all aliases of &lt;var&gt;variable&lt;/var&gt; will be watched together, only dynamic variables can be watched, and changes to the objects referenced by variables are not detected. For details, see &lt;a href=&quot;watching-variables#Watching-Variables&quot;&gt;Watching Variables&lt;/a&gt;.</source>
          <target state="translated">감시 점 메커니즘을 사용하여 구현되므로 동일한 특성과 제한을 상속합니다. &lt;var&gt;variable&lt;/var&gt; 모든 별칭을 함께 감시하고 동적 변수 만 감시 할 수 있으며 변수가 참조하는 개체의 변경 사항은 감지되지 않습니다. 자세한 내용은 &lt;a href=&quot;watching-variables#Watching-Variables&quot;&gt;감시 변수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8bb7af09e2683dd1d43399c262cc53e7f80c18fb" translate="yes" xml:space="preserve">
          <source>It is important to assure that point does not continuously jump around as a consequence of auto-reverting. Of course, moving point might be inevitable if the buffer radically changes.</source>
          <target state="translated">자동 복귀의 결과로 포인트가 지속적으로 점프하지 않도록하는 것이 중요합니다. 물론 버퍼가 급격히 변하면 이동 점이 불가피 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3eede72b9dece35e34101793a2f333f89d89a4f4" translate="yes" xml:space="preserve">
          <source>It is invoked via a mouse command.</source>
          <target state="translated">마우스 명령을 통해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="b5639d37fabd83f8e595d9ba42541031771e2456" translate="yes" xml:space="preserve">
          <source>It is legitimate for a major mode to rebind a standard key sequence if it provides a command that does the same job in a way better suited to the text this mode is used for. For example, a major mode for editing a programming language might redefine</source>
          <target state="translated">이 모드가 사용되는 텍스트에 더 적합한 방식으로 동일한 작업을 수행하는 명령을 제공하는 경우 주 모드가 표준 키 시퀀스를 리 바인드하는 것이 합법적입니다. 예를 들어, 프로그래밍 언어를 편집하기위한 주요 모드는</target>
        </trans-unit>
        <trans-unit id="eae810ab4df9e8a364d85ae8c7b547bd3e8d8937" translate="yes" xml:space="preserve">
          <source>It is normal practice to change the bindings in the global keymap, but you should not assign this variable any value other than the keymap it starts out with.</source>
          <target state="translated">전역 키맵에서 바인딩을 변경하는 것은 일반적인 관행이지만이 변수가 시작하는 키맵 이외의 값을 할당해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="c7f2848da15c9bd47e2aa08dc291366d9534c8a8" translate="yes" xml:space="preserve">
          <source>It is not advisable to put anything in</source>
          <target state="translated">아무것도 넣지 않는 것이 좋습니다</target>
        </trans-unit>
        <trans-unit id="2bbf03bc73d7ef3e252d6245e26ed80331379d73" translate="yes" xml:space="preserve">
          <source>It is not crucial to exclude from the alist the keysyms of other X servers; those do no harm, as long as they don&amp;rsquo;t conflict with the ones used by the X server actually in use.</source>
          <target state="translated">다른 X 서버의 키 심을 목록에서 제외하는 것은 중요하지 않습니다. 실제로 사용중인 X 서버에서 사용하는 것과 충돌하지 않는 한 해를 끼치 지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6c9d03ef366e0475e733b12fb4ac0e9991b62830" translate="yes" xml:space="preserve">
          <source>It is not sufficient to determine whether a given window shows the currently active minibuffer by comparing it with the result of &lt;code&gt;(minibuffer-window)&lt;/code&gt;, because there can be more than one minibuffer window if there is more than one frame.</source>
          <target state="translated">하나 이상의 프레임이있는 경우 하나 이상의 미니 버퍼 창이있을 수 있기 때문에 주어진 창에 현재 활성화 된 미니 버퍼를 &lt;code&gt;(minibuffer-window)&lt;/code&gt; 의 결과와 비교하여 표시하는지 여부를 확인하는 것만으로는 충분하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="0e93812a73d2bc561240927bd0add1fb2b57b9cb" translate="yes" xml:space="preserve">
          <source>It is often convenient to write a function that allows certain arguments to be omitted. For example, the function &lt;code&gt;substring&lt;/code&gt; accepts three arguments&amp;mdash;a string, the start index and the end index&amp;mdash;but the third argument defaults to the &lt;var&gt;length&lt;/var&gt; of the string if you omit it. It is also convenient for certain functions to accept an indefinite number of arguments, as the functions &lt;code&gt;list&lt;/code&gt; and &lt;code&gt;+&lt;/code&gt; do.</source>
          <target state="translated">특정 인수를 생략 할 수있는 함수를 작성하는 것이 편리한 경우가 많습니다. 예를 들어, 함수 &lt;code&gt;substring&lt;/code&gt; 은 문자열, 시작 색인 및 종료 색인의 세 가지 인수를 허용하지만 생략 할 경우 세 번째 인수의 기본값 은 문자열 &lt;var&gt;length&lt;/var&gt; 입니다. 특정 함수가 함수 &lt;code&gt;list&lt;/code&gt; 및 &lt;code&gt;+&lt;/code&gt; 와 같이 무한한 수의 인수를 허용하는 것도 편리합니다 .</target>
        </trans-unit>
        <trans-unit id="4d267166b6e7f4643511ccbc7ed7e8692e1af1ee" translate="yes" xml:space="preserve">
          <source>It is often useful to move point temporarily within a localized portion of the program. This is called an &lt;em&gt;excursion&lt;/em&gt;, and it is done with the &lt;code&gt;save-excursion&lt;/code&gt; special form. This construct remembers the initial identity of the current buffer, and its value of point, and restores them after the excursion completes. It is the standard way to move point within one part of a program and avoid affecting the rest of the program, and is used thousands of times in the Lisp sources of Emacs.</source>
          <target state="translated">프로그램의 지역화 된 부분 내에서 일시적으로 포인트를 이동하는 것이 유용합니다. 이것은라고 &lt;em&gt;여행을&lt;/em&gt; 하고이 이루어집니다 &lt;code&gt;save-excursion&lt;/code&gt; 특별한 양식. 이 구조는 현재 버퍼의 초기 ID와 해당 포인트 값을 기억하고 이동이 완료된 후 복원합니다. 이것은 프로그램의 한 부분 내에서 포인트를 이동하고 나머지 프로그램에 영향을주지 않는 표준 방법이며, Emacs의 Lisp 소스에서 수천 번 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4a9a518d3c351efa42f91492c1d3d264dda80369" translate="yes" xml:space="preserve">
          <source>It is ok for a mode to use &lt;code&gt;font-lock-face&lt;/code&gt; for some text and also use the normal Font Lock machinery. But if the mode does not use the normal Font Lock machinery, it should not set the variable &lt;code&gt;font-lock-defaults&lt;/code&gt;. In this case the &lt;code&gt;face&lt;/code&gt; property will not be overriden, so using the &lt;code&gt;face&lt;/code&gt; property could work too. However, using &lt;code&gt;font-lock-face&lt;/code&gt; is generally preferable as it allows the user to control the fontification by toggling &lt;code&gt;font-lock-mode&lt;/code&gt;, and lets the code work regardless of whether the mode uses Font Lock machinery or not.</source>
          <target state="translated">모드가 일부 텍스트에 &lt;code&gt;font-lock-face&lt;/code&gt; 를 사용하고 일반 글꼴 잠금 기계 를 사용하는 것은 괜찮습니다 . 그러나 모드가 일반 글꼴 잠금 기계를 사용하지 않는 경우 변수 &lt;code&gt;font-lock-defaults&lt;/code&gt; 를 설정해서는 안됩니다 . 이 경우 &lt;code&gt;face&lt;/code&gt; 은 Using 있도록 속성은 오버라이드 (override)되지 않습니다 &lt;code&gt;face&lt;/code&gt; 재산 것은 너무 일할 수 있습니다. 그러나 &lt;code&gt;font-lock-face&lt;/code&gt; 를 사용하면 사용자가 &lt;code&gt;font-lock-mode&lt;/code&gt; 를 토글하여 글꼴 화를 제어 할 수 있고 모드가 글꼴 잠금 기계를 사용하는지 여부에 관계없이 코드가 작동 할 수 있으므로 일반적으로 선호됩니다 .</target>
        </trans-unit>
        <trans-unit id="c3d2ba074f26ffb62a211357cea324dbc4b2f4ea" translate="yes" xml:space="preserve">
          <source>It is possible to advise a primitive (see &lt;a href=&quot;what-is-a-function#What-Is-a-Function&quot;&gt;What Is a Function&lt;/a&gt;), but one should typically &lt;em&gt;not&lt;/em&gt; do so, for two reasons. Firstly, some primitives are used by the advice mechanism, and advising them could cause an infinite recursion. Secondly, many primitives are called directly from C, and such calls ignore advice; hence, one ends up in a confusing situation where some calls (occurring from Lisp code) obey the advice and other calls (from C code) do not.</source>
          <target state="translated">(참조 원시적 조언을 가능한 &lt;a href=&quot;what-is-a-function#What-Is-a-Function&quot;&gt;함수가 무엇인지&lt;/a&gt; ), 그러나 사람은 일반적으로해야 &lt;em&gt;하지&lt;/em&gt; 두 가지 이유로 그렇게. 첫째, 어드바이스 메커니즘에 의해 일부 프리미티브가 사용되며, 어드바이스하면 무한 재귀가 발생할 수 있습니다. 두 번째로, 많은 프리미티브가 C에서 직접 호출되며 이러한 호출은 조언을 무시합니다. 따라서 일부 호출 (Lisp 코드에서 발생)은 조언을 따르고 다른 호출 (C 코드에서 발생)은 수행하지 않는 혼란스러운 상황에 처하게됩니다.</target>
        </trans-unit>
        <trans-unit id="158ec131ed80fbe1245b2dbcf3882b001d0a335c" translate="yes" xml:space="preserve">
          <source>It is possible to avoid implicit resizing of a specific window when there are one or more other resizable windows on the same frame. For this purpose, Emacs must be advised to &lt;em&gt;preserve&lt;/em&gt; the size of that window. There are two basic ways to do that.</source>
          <target state="translated">동일한 프레임에 크기 조정이 가능한 다른 창이 하나 이상있는 경우 특정 창의 암시 적 크기 조정을 피할 수 있습니다. 이를 위해 Emacs는 해당 창의 크기 를 &lt;em&gt;유지&lt;/em&gt; 하도록 권장해야합니다 . 이를 수행하는 두 가지 기본 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5059d1ca2b3130d76d02552f9db1a53062d38b02" translate="yes" xml:space="preserve">
          <source>It is possible to read a special file (such as a FIFO or an I/O device) with &lt;code&gt;insert-file-contents&lt;/code&gt;, as long as &lt;var&gt;replace&lt;/var&gt; and &lt;var&gt;visit&lt;/var&gt; are &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">이와 (예 : FIFO 또는 I / O 장치와 같은) 특별한 파일을 읽을 수 있습니다 &lt;code&gt;insert-file-contents&lt;/code&gt; 만큼으로, &lt;var&gt;replace&lt;/var&gt; 및 &lt;var&gt;visit&lt;/var&gt; 입니다 &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="206fcc689764ad9025a7ae9e9481deb9e1a87744" translate="yes" xml:space="preserve">
          <source>It is possible to use &lt;code&gt;char-after&lt;/code&gt; to examine characters at various buffer positions without moving point to those positions. Only an actual change in the value of point runs these hook functions.</source>
          <target state="translated">&lt;code&gt;char-after&lt;/code&gt; 를 사용 하여 포인트를 해당 위치로 이동하지 않고도 다양한 버퍼 위치에서 문자를 검사 할 수 있습니다 . 포인트 값의 실제 변경 만 이러한 후크 기능을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="ea9002dbd9b169e39f06dc37297bb765ac7c9c2f" translate="yes" xml:space="preserve">
          <source>It is possible to use an anonymous Lisp macro just like an anonymous function, but this is never done, because it does not make sense to pass an anonymous macro to functionals such as &lt;code&gt;mapcar&lt;/code&gt;. In practice, all Lisp macros have names, and they are almost always defined with the &lt;code&gt;defmacro&lt;/code&gt; macro.</source>
          <target state="translated">익명의 함수처럼 익명의 Lisp 매크로를 사용하는 것이 가능하지만 이것은 결코 수행되지 않습니다. 왜냐하면 익명 매크로를 &lt;code&gt;mapcar&lt;/code&gt; 와 같은 함수에 전달하는 것은 의미가 없기 때문 입니다. 실제로 모든 Lisp 매크로에는 이름이 있으며 거의 ​​항상 &lt;code&gt;defmacro&lt;/code&gt; 매크로로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="91987bc01ce4e25960e8f7c77d19903b336be8fa" translate="yes" xml:space="preserve">
          <source>It is probably a good idea for the functions to do nothing if the character after &lt;var&gt;pos&lt;/var&gt; already has a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;fontified&lt;/code&gt; property, but this is not required. If one function overrides the assignments made by a previous one, the properties after the last function finishes are the ones that really matter.</source>
          <target state="translated">&lt;var&gt;pos&lt;/var&gt; 뒤의 문자에 이미 &lt;code&gt;nil&lt;/code&gt; 이 아닌 &lt;code&gt;fontified&lt;/code&gt; 속성 이있는 경우 함수가 아무 작업도 수행하지 않는 것이 좋겠지 만 필수는 아닙니다. 한 함수가 이전 함수의 할당을 재정의하는 경우 마지막 함수가 완료된 후의 속성이 실제로 중요한 속성입니다.</target>
        </trans-unit>
        <trans-unit id="8c50e007c4847dde92fe8e165d1a24f7fbca3071" translate="yes" xml:space="preserve">
          <source>It is quite common to use some storage for a while, then release it by (for example) killing a buffer or deleting the last pointer to an object. Emacs provides a &lt;em&gt;garbage collector&lt;/em&gt; to reclaim this abandoned storage. The garbage collector operates by finding and marking all Lisp objects that are still accessible to Lisp programs. To begin with, it assumes all the symbols, their values and associated function definitions, and any data presently on the stack, are accessible. Any objects that can be reached indirectly through other accessible objects are also accessible.</source>
          <target state="translated">잠시 동안 일부 저장소를 사용한 다음 버퍼를 죽이거나 객체에 대한 마지막 포인터를 삭제하여 해제하는 것은 매우 일반적입니다. Emacs는 이 버려진 스토리지를 회수하기 위해 &lt;em&gt;가비지 수집기&lt;/em&gt; 를 제공합니다 . 가비지 수집기는 여전히 Lisp 프로그램에 액세스 할 수있는 모든 Lisp 개체를 찾아 표시하는 방식으로 작동합니다. 우선, 모든 기호, 해당 값 및 관련 함수 정의 및 현재 스택에있는 모든 데이터에 액세스 할 수 있다고 가정합니다. 다른 액세스 가능한 개체를 통해 간접적으로 도달 할 수있는 모든 개체도 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f81f2fefce2410ae1512655349098e0d74c8ad5" translate="yes" xml:space="preserve">
          <source>It is risky to change this variable&amp;rsquo;s value without doing various other things. Normally it is better to use &lt;code&gt;set-visited-file-name&lt;/code&gt; (see below); some of the things done there, such as changing the buffer name, are not strictly necessary, but others are essential to avoid confusing Emacs.</source>
          <target state="translated">다른 다양한 작업을 수행하지 않고이 변수의 값을 변경하는 것은 위험합니다. 일반적으로 &lt;code&gt;set-visited-file-name&lt;/code&gt; 을 사용하는 것이 좋습니다 (아래 참조). 버퍼 이름 변경과 같이 거기에서 수행되는 일부 작업은 반드시 필요한 것은 아니지만 다른 작업은 Emacs의 혼동을 피하기 위해 필수적입니다.</target>
        </trans-unit>
        <trans-unit id="81c490de37e7452de0a620a005a47606bd70b349" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to make two variables synonyms, so that both variables always have the same value, and changing either one also changes the other. Whenever you change the name of a variable&amp;mdash;either because you realize its old name was not well chosen, or because its meaning has partly changed&amp;mdash;it can be useful to keep the old name as an &lt;em&gt;alias&lt;/em&gt; of the new one for compatibility. You can do this with &lt;code&gt;defvaralias&lt;/code&gt;.</source>
          <target state="translated">때로는 두 변수를 동의어로 만드는 것이 유용하므로 두 변수가 항상 동일한 값을 가지며 둘 중 하나를 변경하면 다른 변수도 변경됩니다. 이전 이름이 잘 선택되지 않았거나 의미가 부분적으로 변경 되었기 때문에 변수의 이름을 변경할 때마다 호환성 을 위해 이전 이름을 새 이름의 &lt;em&gt;별칭&lt;/em&gt; 으로 유지하는 것이 유용 할 수 있습니다 . &lt;code&gt;defvaralias&lt;/code&gt; 로이를 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a2a84b8c48d3b060fcc06470427ce26c8399bf6f" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to take some action when a variable changes its value. The &lt;em&gt;variable watchpoint&lt;/em&gt; facility provides the means to do so. Some possible uses for this feature include keeping display in sync with variable settings, and invoking the debugger to track down unexpected changes to variables (see &lt;a href=&quot;variable-debugging#Variable-Debugging&quot;&gt;Variable Debugging&lt;/a&gt;).</source>
          <target state="translated">변수가 값을 변경할 때 조치를 취하는 것이 유용 할 때가 있습니다. &lt;em&gt;변수 감시 점&lt;/em&gt; 시설은 수단이 그렇게하도록 제공합니다. 이 기능의 가능한 용도로는 디스플레이를 변수 설정과 동기화하고 디버거를 호출하여 변수에 대한 예기치 않은 변경 사항을 추적하는 것이 있습니다 ( &lt;a href=&quot;variable-debugging#Variable-Debugging&quot;&gt;변수 디버깅&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="3f4f9ca54d322d9dfa0b17bef44fd7e71b5662a0" translate="yes" xml:space="preserve">
          <source>It is useful to specify the &lt;code&gt;:require&lt;/code&gt; keyword for an option that turns on a certain feature. This causes Emacs to load the feature, if it is not already loaded, whenever the option is set. See &lt;a href=&quot;common-keywords#Common-Keywords&quot;&gt;Common Keywords&lt;/a&gt;. Here is an example:</source>
          <target state="translated">특정 기능을 켜는 옵션에 대해 &lt;code&gt;:require&lt;/code&gt; 키워드 를 지정하는 것이 유용 합니다. 이로 인해 Emacs는 옵션이 설정 될 때마다 아직로드되지 않은 경우 기능을로드합니다. &lt;a href=&quot;common-keywords#Common-Keywords&quot;&gt;일반 키워드를&lt;/a&gt; 참조하십시오 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1084186213269f2884b66a5901a0fe109856708d" translate="yes" xml:space="preserve">
          <source>It is usually a bad idea for timer functions to alter buffer contents. When they do, they usually should call &lt;code&gt;undo-boundary&lt;/code&gt; both before and after changing the buffer, to separate the timer&amp;rsquo;s changes from user commands&amp;rsquo; changes and prevent a single undo entry from growing to be quite large.</source>
          <target state="translated">일반적으로 타이머 함수가 버퍼 내용을 변경하는 것은 좋지 않습니다. 그렇게 할 때 일반적으로 버퍼 변경 전후에 &lt;code&gt;undo-boundary&lt;/code&gt; 를 호출 하여 사용자 명령의 변경 사항에서 타이머의 변경 사항을 분리하고 단일 실행 취소 항목이 상당히 커지는 것을 방지해야합니다.</target>
        </trans-unit>
        <trans-unit id="51bfeb221e33f8fd00e57f4226da961d1d317a23" translate="yes" xml:space="preserve">
          <source>It is usually a bad idea to have more than one process associated with the same buffer.</source>
          <target state="translated">일반적으로 동일한 버퍼에 둘 이상의 프로세스를 연결하는 것은 좋지 않습니다.</target>
        </trans-unit>
        <trans-unit id="341cb9738d8f2bcab2233c96dc993a86f9598f86" translate="yes" xml:space="preserve">
          <source>It is very common to read a Lisp form and then evaluate the form, but reading and evaluation are separate activities, and either can be performed alone. Reading per se does not evaluate anything; it converts the printed representation of a Lisp object to the object itself. It is up to the caller of &lt;code&gt;read&lt;/code&gt; to specify whether this object is a form to be evaluated, or serves some entirely different purpose. See &lt;a href=&quot;input-functions#Input-Functions&quot;&gt;Input Functions&lt;/a&gt;.</source>
          <target state="translated">Lisp 양식을 읽고 양식을 평가하는 것은 매우 일반적이지만 읽기와 평가는 별도의 활동이며 둘 중 하나를 단독으로 수행 할 수 있습니다. 읽기 자체는 아무것도 평가하지 않습니다. Lisp 객체의 인쇄 된 표현을 객체 자체로 변환합니다. 이 객체가 평가할 양식인지 또는 완전히 다른 용도로 사용되는지 여부를 지정하는 것은 &lt;code&gt;read&lt;/code&gt; 호출자 에게 달려 있습니다. &lt;a href=&quot;input-functions#Input-Functions&quot;&gt;입력 함수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="545d22f4c3da6e907a054b17ba6817a718596224" translate="yes" xml:space="preserve">
          <source>It is very unusual to change the global keymap.</source>
          <target state="translated">전역 키맵을 변경하는 것은 매우 드문 일입니다.</target>
        </trans-unit>
        <trans-unit id="96139028099a0bfa0975054c4ed4730a63010934" translate="yes" xml:space="preserve">
          <source>It loads any</source>
          <target state="translated">그것은 무엇이든로드합니다</target>
        </trans-unit>
        <trans-unit id="ce4af309e8e71369b6c603cca0cfd8e3be09a193" translate="yes" xml:space="preserve">
          <source>It loads the library</source>
          <target state="translated">라이브러리를로드합니다.</target>
        </trans-unit>
        <trans-unit id="f58887fd3294e17aa3e3e1af45b67849abc46e36" translate="yes" xml:space="preserve">
          <source>It loads your abbrevs from the file specified by &lt;code&gt;abbrev-file-name&lt;/code&gt;, if that file exists and can be read (see &lt;a href=&quot;abbrev-files#Abbrev-Files&quot;&gt;abbrev-file-name&lt;/a&gt;). This is not done if the option &amp;lsquo;</source>
          <target state="translated">파일이 존재하고 읽을 수있는 경우 &lt;code&gt;abbrev-file-name&lt;/code&gt; 으로 지정된 파일에서 약어를로드합니다 ( &lt;a href=&quot;abbrev-files#Abbrev-Files&quot;&gt;abbrev-file-name 참조&lt;/a&gt; ). 옵션 '</target>
        </trans-unit>
        <trans-unit id="dea39a1a58b57ed5c242a688a8b16e364190e632" translate="yes" xml:space="preserve">
          <source>It loads your early init file (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Early-Init-File.html#Early-Init-File&quot;&gt;Early Init File&lt;/a&gt; in</source>
          <target state="translated">그것은 당신의 초기 초기화 파일 (참조로드 &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Early-Init-File.html#Early-Init-File&quot;&gt;초기 초기화 파일&lt;/a&gt; 에</target>
        </trans-unit>
        <trans-unit id="a9b670a2bbddceb4c5ab7bd11a55ab2796be2d98" translate="yes" xml:space="preserve">
          <source>It loads your init file (see &lt;a href=&quot;init-file#Init-File&quot;&gt;Init File&lt;/a&gt;). This is not done if the options &amp;lsquo;</source>
          <target state="translated">init 파일을로드합니다 ( &lt;a href=&quot;init-file#Init-File&quot;&gt;Init 파일&lt;/a&gt; 참조 ). 옵션 '</target>
        </trans-unit>
        <trans-unit id="26dc9b8940f0ed8395f81364b4d2c60b19096a69" translate="yes" xml:space="preserve">
          <source>It makes a difference whether the user&amp;rsquo;s variable is named &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;x&lt;/code&gt;, because &lt;code&gt;a&lt;/code&gt; conflicts with the macro argument variable &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">그것은 사용자의 변수라는 이름의 여부를 차이가 있습니다 또는 &lt;code&gt;x&lt;/code&gt; , 때문에 매크로 인수 변수와 충돌 . &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3f588db542d569932c817bd6b5fdaa9a4f1bd05c" translate="yes" xml:space="preserve">
          <source>It may be a Lisp expression that is not a string; then it should be a form that is evaluated to get a list of arguments to pass to the command. Usually this form will call various functions to read input from the user, most often through the minibuffer (see &lt;a href=&quot;minibuffers#Minibuffers&quot;&gt;Minibuffers&lt;/a&gt;) or directly from the keyboard (see &lt;a href=&quot;reading-input#Reading-Input&quot;&gt;Reading Input&lt;/a&gt;).</source>
          <target state="translated">문자열이 아닌 Lisp 표현식 일 수 있습니다. 명령에 전달할 인수 목록을 얻기 위해 평가되는 양식이어야합니다. 일반적으로이 형식은 사용자로부터 입력을 읽기 위해 다양한 함수를 호출합니다. 대부분 &lt;a href=&quot;minibuffers#Minibuffers&quot;&gt;미니 버퍼를&lt;/a&gt; 통해 ( 미니 버퍼 참조 ) 또는 키보드에서 직접 ( &lt;a href=&quot;reading-input#Reading-Input&quot;&gt;입력 읽기&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="e657a7f0ef3da4440c9a172406d4c83cc7a6c0ec" translate="yes" xml:space="preserve">
          <source>It may be a string; its contents are a sequence of elements separated by newlines, one for each argument&lt;a href=&quot;#FOOT12&quot; name=&quot;DOCF12&quot;&gt;&lt;sup&gt;12&lt;/sup&gt;&lt;/a&gt;. Each element consists of a code character (see &lt;a href=&quot;interactive-codes#Interactive-Codes&quot;&gt;Interactive Codes&lt;/a&gt;) optionally followed by a prompt (which some code characters use and some ignore). Here is an example:</source>
          <target state="translated">문자열 일 수 있습니다. 내용은 줄 바꿈으로 구분 된 일련의 요소이며 각 인수에 대해 하나씩 &lt;a href=&quot;#FOOT12&quot; name=&quot;DOCF12&quot;&gt;&lt;sup&gt;12&lt;/sup&gt;&lt;/a&gt; . 각 요소는 코드 문자 ( &lt;a href=&quot;interactive-codes#Interactive-Codes&quot;&gt;대화 형 코드&lt;/a&gt; 참조 )와 선택적으로 프롬프트 (일부 코드 문자는 사용하고 일부는 무시)가 뒤 따릅니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="270207470e73c1b4f20ceeca5a4e07a1e861134d" translate="yes" xml:space="preserve">
          <source>It may be easier to understand Edebug specifications by studying the examples provided here.</source>
          <target state="translated">여기에 제공된 예제를 연구하면 Edebug 사양을 이해하는 것이 더 쉬울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29ae132e6f7b39d1f5c10685d3a9d808a04b0a94" translate="yes" xml:space="preserve">
          <source>It may be omitted or &lt;code&gt;nil&lt;/code&gt;; then the command is called with no arguments. This leads quickly to an error if the command requires one or more arguments.</source>
          <target state="translated">생략되거나 &lt;code&gt;nil&lt;/code&gt; 일 수 있습니다 . 그러면 인수없이 명령이 호출됩니다. 이로 인해 명령에 하나 이상의 인수가 필요한 경우 오류가 빠르게 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a7ae8f4f5163ffdad3ac600dbfe8890ee50679f5" translate="yes" xml:space="preserve">
          <source>It might be illustrative to look at the list of action functions &lt;code&gt;display-buffer&lt;/code&gt; would have tried to display</source>
          <target state="translated">&lt;code&gt;display-buffer&lt;/code&gt; 가 표시하려고 시도한 작업 함수 목록을 살펴 보는 것이 예시 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f613bf2f4a5a85329f026a11071df7c6baaf0a91" translate="yes" xml:space="preserve">
          <source>It now exits if the option &lt;code&gt;--batch&lt;/code&gt; was specified.</source>
          <target state="translated">&lt;code&gt;--batch&lt;/code&gt; 옵션 이 지정된 경우 이제 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="b223a189ae751119c33b80a020770286ea64a0a6" translate="yes" xml:space="preserve">
          <source>It processes any command-line options that were not handled earlier.</source>
          <target state="translated">이전에 처리되지 않은 모든 명령 줄 옵션을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="f719eab01b127d2177bbaf5f862883e5485e8eae" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;nil&lt;/code&gt; if the frame is known not to be focused, &lt;code&gt;t&lt;/code&gt; if the frame is known to be focused, or &lt;code&gt;unknown&lt;/code&gt; if Emacs does not know the focus state of the frame. (You may see this last state in TTY frames running on terminals that do not support explicit focus notifications.)</source>
          <target state="translated">프레임이 초점이 맞지 않는 것으로 알려진 경우 &lt;code&gt;nil&lt;/code&gt; 을 , 프레임이 초점을 맞춘 것으로 알려진 경우 &lt;code&gt;t&lt;/code&gt; 를 , Emacs가 프레임의 초점 상태를 알지 &lt;code&gt;unknown&lt;/code&gt; 경우 unknown을 리턴합니다 . (명시적인 포커스 알림을 지원하지 않는 터미널에서 실행되는 TTY 프레임에서이 마지막 상태를 볼 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="f6127be12a81ec3143b75ff723db16b07ec57fc0" translate="yes" xml:space="preserve">
          <source>It returns a list &lt;code&gt;(&lt;var&gt;id&lt;/var&gt; &lt;var&gt;cols&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;id&lt;/var&gt; is the ID of the deleted entry and &lt;var&gt;cols&lt;/var&gt; is a vector of its column descriptors. It moves point to the beginning of the current line. It returns &lt;code&gt;nil&lt;/code&gt; if there is no entry at point.</source>
          <target state="translated">목록 &lt;code&gt;(&lt;var&gt;id&lt;/var&gt; &lt;var&gt;cols&lt;/var&gt;)&lt;/code&gt; 반환합니다. 여기서 &lt;var&gt;id&lt;/var&gt; 는 삭제 된 항목의 ID이고 &lt;var&gt;cols&lt;/var&gt; 는 열 설명 자의 벡터입니다. 현재 줄의 시작 지점으로 이동합니다. 지점에 항목이 없으면 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="13687604dddd27521e079b6548d3c35983b18d78" translate="yes" xml:space="preserve">
          <source>It runs &lt;code&gt;emacs-startup-hook&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;emacs-startup-hook&lt;/code&gt; 을 실행 합니다.</target>
        </trans-unit>
        <trans-unit id="57d130dea79514478748a7450914f1fdf423cfbf" translate="yes" xml:space="preserve">
          <source>It runs &lt;code&gt;window-setup-hook&lt;/code&gt;. The only difference between this hook and &lt;code&gt;emacs-startup-hook&lt;/code&gt; is that this one runs after the previously mentioned modifications to the frame parameters.</source>
          <target state="translated">&lt;code&gt;window-setup-hook&lt;/code&gt; 을 실행 합니다. 이 후크와 &lt;code&gt;emacs-startup-hook&lt;/code&gt; 의 유일한 차이점 은 이전에 언급 한 프레임 매개 변수 수정 후에 실행된다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b4284000b9f4273ed298f7b9c6acbae8ad8a70fd" translate="yes" xml:space="preserve">
          <source>It runs the normal hook &lt;code&gt;after-init-hook&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;after-init-hook&lt;/code&gt; 일반 후크를 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="65ed86a0349bcbc41775fe86552a371004ac385f" translate="yes" xml:space="preserve">
          <source>It runs the normal hook &lt;code&gt;before-init-hook&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;before-init-hook&lt;/code&gt; 일반 후크 를 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="a06c9ffa5dcf00d29d69c9797dd7e0da6832d589" translate="yes" xml:space="preserve">
          <source>It sets the language environment and the terminal coding system, if requested by environment variables such as &lt;code&gt;LANG&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LANG&lt;/code&gt; 와 같은 환경 변수에 의해 요청되는 경우 언어 환경 및 터미널 코딩 시스템을 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="4923a2b121bc6bb59693b11c6a7750a08e3930eb" translate="yes" xml:space="preserve">
          <source>It sets the variable &lt;code&gt;after-init-time&lt;/code&gt; to the value of &lt;code&gt;current-time&lt;/code&gt;. This variable was set to &lt;code&gt;nil&lt;/code&gt; earlier; setting it to the current time signals that the initialization phase is over, and, together with &lt;code&gt;before-init-time&lt;/code&gt;, provides the measurement of how long it took.</source>
          <target state="translated">&lt;code&gt;after-init-time&lt;/code&gt; 변수 를 &lt;code&gt;current-time&lt;/code&gt; 값으로 설정합니다 . 이 변수는 이전 에 &lt;code&gt;nil&lt;/code&gt; 로 설정되었습니다 . 초기화 단계가 끝났다는 신호를 현재 시간으로 설정하고 &lt;code&gt;before-init-time&lt;/code&gt; 과 함께 소요 된 시간을 측정합니다.</target>
        </trans-unit>
        <trans-unit id="5daee93c148acf992b6fea81eb74da11887f6178" translate="yes" xml:space="preserve">
          <source>It sets the variable &lt;code&gt;before-init-time&lt;/code&gt; to the value of &lt;code&gt;current-time&lt;/code&gt; (see &lt;a href=&quot;time-of-day#Time-of-Day&quot;&gt;Time of Day&lt;/a&gt;). It also sets &lt;code&gt;after-init-time&lt;/code&gt; to &lt;code&gt;nil&lt;/code&gt;, which signals to Lisp programs that Emacs is being initialized.</source>
          <target state="translated">&lt;code&gt;before-init-time&lt;/code&gt; 변수 를 &lt;code&gt;current-time&lt;/code&gt; 값으로 설정합니다 ( &lt;a href=&quot;time-of-day#Time-of-Day&quot;&gt;Time of Day&lt;/a&gt; 참조 ). 또한 &lt;code&gt;after-init-time&lt;/code&gt; 을 &lt;code&gt;nil&lt;/code&gt; 로 설정하여 Emacs가 초기화되고 있음을 Lisp 프로그램에 알립니다.</target>
        </trans-unit>
        <trans-unit id="5e3e48641edd97a87cf2a4c0fb33b8851ec59b76" translate="yes" xml:space="preserve">
          <source>It should return either a number, which is the number of columns of indentation for that line, or a list whose car is such a number. The difference between returning a number and returning a list is that a number says that all following lines at the same nesting level should be indented just like this one; a list says that following lines might call for different indentations. This makes a difference when the indentation is being computed by</source>
          <target state="translated">해당 행의 들여 쓰기 열 수인 숫자 또는 car가 그러한 숫자 인 목록을 반환해야합니다. 숫자를 반환하는 것과 목록을 반환하는 것의 차이점은 숫자는 동일한 중첩 수준에있는 모든 다음 줄을 이와 같이 들여 쓰기해야한다는 것입니다. 목록은 다음 줄이 다른 들여 쓰기를 요구할 수 있다고 말합니다. 이것은 들여 쓰기가 다음에 의해 계산 될 때 차이를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="99280a67fd3ac6e66ec565182a43a4b5d4ec95df" translate="yes" xml:space="preserve">
          <source>It specifies the numbers of pixels to be left free on the left, above, the right, and below a frame that shall be fit. The default specifies &lt;code&gt;nil&lt;/code&gt; for each which means to use no margins. The value specified here can be overridden for a specific frame by that frame&amp;rsquo;s &lt;code&gt;fit-frame-to-buffer-margins&lt;/code&gt; parameter, if present.</source>
          <target state="translated">맞출 프레임의 왼쪽, 위, 오른쪽 및 아래에서 자유로울 픽셀 수를 지정합니다. 기본값은 여백을 사용하지 않음을 의미하는 각각에 대해 &lt;code&gt;nil&lt;/code&gt; 을 지정합니다 . 여기에 지정된 값은 해당 프레임의 &lt;code&gt;fit-frame-to-buffer-margins&lt;/code&gt; 매개 변수 (있는 경우)에 의해 특정 프레임에 대해 재정의 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="28ce94806e6158d5cc7c2d469c858c1b7c53e2dd" translate="yes" xml:space="preserve">
          <source>It takes a candidate for the fill prefix from the first line&amp;mdash;it tries first the function in &lt;code&gt;adaptive-fill-function&lt;/code&gt; (if any), then the regular expression &lt;code&gt;adaptive-fill-regexp&lt;/code&gt; (see below). The first non-&lt;code&gt;nil&lt;/code&gt; result of these, or the empty string if they&amp;rsquo;re both &lt;code&gt;nil&lt;/code&gt;, becomes the first line&amp;rsquo;s candidate.</source>
          <target state="translated">첫 번째 줄에서 채우기 접두사 후보를 가져옵니다. 먼저 &lt;code&gt;adaptive-fill-function&lt;/code&gt; (있는 경우) 에서 함수를 시도한 다음 정규 표현식 &lt;code&gt;adaptive-fill-regexp&lt;/code&gt; (아래 참조)를 시도합니다 . &lt;code&gt;nil&lt;/code&gt; 이 아닌 첫 번째 결과 또는 둘 다 &lt;code&gt;nil&lt;/code&gt; 인 경우 빈 문자열 이 첫 번째 줄의 후보가됩니다.</target>
        </trans-unit>
        <trans-unit id="f89e2f8e456314ee623854cef9dd8ebd8d7735d3" translate="yes" xml:space="preserve">
          <source>It use &lt;code&gt;custom-reevaluate-setting&lt;/code&gt; to re-initialize the members of the list &lt;code&gt;custom-delayed-init-variables&lt;/code&gt;. These are any pre-loaded user options whose default value depends on the run-time, rather than build-time, context. See &lt;a href=&quot;building-emacs#Building-Emacs&quot;&gt;custom-initialize-delay&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;custom-reevaluate-setting&lt;/code&gt; 을 사용 하여 &lt;code&gt;custom-delayed-init-variables&lt;/code&gt; 목록의 멤버를 다시 초기화합니다 . 기본값이 빌드 타임이 아닌 런타임에 따라 달라지는 사전로드 된 사용자 옵션입니다. &lt;a href=&quot;building-emacs#Building-Emacs&quot;&gt;custom-initialize-delay를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="44cd2108881f01dd8c596bbd91d07233b73cb9b2" translate="yes" xml:space="preserve">
          <source>It works to put a &lt;code&gt;lambda&lt;/code&gt;-expression function on a hook, but we recommend avoiding this because it can lead to confusion. If you add the same &lt;code&gt;lambda&lt;/code&gt;-expression a second time but write it slightly differently, you will get two equivalent but distinct functions on the hook. If you then remove one of them, the other will still be on it.</source>
          <target state="translated">&lt;code&gt;lambda&lt;/code&gt; 함수를 후크에 배치하는 데 작동 하지만 혼동을 일으킬 수 있으므로 피하는 것이 좋습니다. 동일한 &lt;code&gt;lambda&lt;/code&gt; 두 번 추가하지만 약간 다르게 작성하면 후크에서 동일하지만 별개의 두 함수를 얻을 수 있습니다. 그런 다음 그 중 하나를 제거해도 다른 하나는 계속 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="80fdf17dcc7b4f396ac917a2a9e0157cd87886a5" translate="yes" xml:space="preserve">
          <source>It you wish to use &lt;code&gt;fset&lt;/code&gt; to make an alternate name for a function, consider using &lt;code&gt;defalias&lt;/code&gt; instead. See &lt;a href=&quot;defining-functions#Definition-of-defalias&quot;&gt;Definition of defalias&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;fset&lt;/code&gt; 을 사용 하여 함수의 대체 이름을 만들 &lt;code&gt;defalias&lt;/code&gt; 대신 defalias 를 사용하는 것이 좋습니다. &lt;a href=&quot;defining-functions#Definition-of-defalias&quot;&gt;defalias 정의를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="12c3787085fed9c7ac2a19edc5f190b93b7fcd00" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important to note that generator function bodies only execute inside calls to &lt;code&gt;iter-next&lt;/code&gt;. A call to a function defined with &lt;code&gt;iter-defun&lt;/code&gt; produces an iterator; you must drive this iterator with &lt;code&gt;iter-next&lt;/code&gt; for anything interesting to happen. Each call to a generator function produces a &lt;em&gt;different&lt;/em&gt; iterator, each with its own state.</source>
          <target state="translated">제너레이터 함수 본문은 &lt;code&gt;iter-next&lt;/code&gt; 호출 내에서만 실행된다는 점에 유의해야합니다 . &lt;code&gt;iter-defun&lt;/code&gt; 으로 정의 된 함수에 대한 호출 은 반복자를 생성합니다. 흥미로운 일이 일어나려면 &lt;code&gt;iter-next&lt;/code&gt; 로이 반복자를 구동해야합니다 . 제너레이터 함수에 대한 각 호출은 각각 고유 한 상태를 가진 &lt;em&gt;다른&lt;/em&gt; 반복기를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="729165fc7a05eb589cbb1af78d5106f307b47f0e" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s often best to use a button-down event to trigger the menu. Then the user can select a menu item by releasing the button.</source>
          <target state="translated">메뉴를 트리거하려면 버튼 다운 이벤트를 사용하는 것이 가장 좋습니다. 그런 다음 사용자는 버튼을 놓아 메뉴 항목을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c08d58a77f22a792633779a50d013f737ce9483" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible to use &lt;code&gt;defmacro&lt;/code&gt; to define a macro to expand into the same code that an inline function would execute (see &lt;a href=&quot;macros#Macros&quot;&gt;Macros&lt;/a&gt;). But the macro would be limited to direct use in expressions&amp;mdash;a macro cannot be called with &lt;code&gt;apply&lt;/code&gt;, &lt;code&gt;mapcar&lt;/code&gt; and so on. Also, it takes some work to convert an ordinary function into a macro. To convert it into an inline function is easy; just replace &lt;code&gt;defun&lt;/code&gt; with &lt;code&gt;defsubst&lt;/code&gt;. Since each argument of an inline function is evaluated exactly once, you needn&amp;rsquo;t worry about how many times the body uses the arguments, as you do for macros.</source>
          <target state="translated">그것은 사용하는 것이 가능 &lt;code&gt;defmacro&lt;/code&gt; 인라인 함수 (참조 실행 것 같은 코드로 확장하는 매크로를 정의하는 &lt;a href=&quot;macros#Macros&quot;&gt;매크로&lt;/a&gt; ). 그러나 매크로는 표현식에서 직접 사용하도록 제한됩니다. 매크로는 &lt;code&gt;apply&lt;/code&gt; , &lt;code&gt;mapcar&lt;/code&gt; 등과 함께 호출 될 수 없습니다 . 또한 일반 함수를 매크로로 변환하려면 약간의 작업이 필요합니다. 인라인 함수로 변환하는 것은 쉽습니다. &lt;code&gt;defun&lt;/code&gt; 을 &lt;code&gt;defsubst&lt;/code&gt; 로 바꾸 십시오 . 인라인 함수의 각 인수는 정확히 한 번 평가되기 때문에 매크로와 마찬가지로 본문에서 인수를 사용하는 횟수에 대해 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="18905aab409cadb5b72681a650ec99001cb221e0" translate="yes" xml:space="preserve">
          <source>Iteration</source>
          <target state="translated">Iteration</target>
        </trans-unit>
        <trans-unit id="f4d74e5132bdad11a69b68ebde992bf491707cbc" translate="yes" xml:space="preserve">
          <source>Iteration means executing part of a program repetitively. For example, you might want to repeat some computation once for each element of a list, or once for each integer from 0 to &lt;var&gt;n&lt;/var&gt;. You can do this in Emacs Lisp with the special form &lt;code&gt;while&lt;/code&gt;:</source>
          <target state="translated">반복은 프로그램의 일부를 반복적으로 실행하는 것을 의미합니다. 예를 들어 목록의 각 요소에 대해 한 번 또는 0에서 &lt;var&gt;n&lt;/var&gt; 사이의 각 정수에 대해 한 번씩 계산을 반복 할 수 있습니다 . Emacs Lisp에서 다음과 같은 &lt;code&gt;while&lt;/code&gt; 특수한 형식으로이 작업을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2fb2f2a0c2e32e4191a12be240b63fedbe73b154" translate="yes" xml:space="preserve">
          <source>Its default value is a list of two functions:</source>
          <target state="translated">기본값은 두 가지 기능의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="49589a66a4ed1e537405d93b509f6624692ac859" translate="yes" xml:space="preserve">
          <source>Its limitations are two-fold:</source>
          <target state="translated">그 한계는 두 가지입니다.</target>
        </trans-unit>
        <trans-unit id="007b93ab24ba9d1da7373772173fe2a52b7889ac" translate="yes" xml:space="preserve">
          <source>Its value is a cons cell whose &lt;small&gt;CAR&lt;/small&gt; is the property value, the same value &lt;code&gt;get-char-property&lt;/code&gt; would return with the same arguments. Its &lt;small&gt;CDR&lt;/small&gt; is the overlay in which the property was found, or &lt;code&gt;nil&lt;/code&gt;, if it was found as a text property or not found at all.</source>
          <target state="translated">그 값은 &lt;small&gt;CAR&lt;/small&gt; 이 속성 값인 cons 셀 이며 동일한 값 &lt;code&gt;get-char-property&lt;/code&gt; 가 동일한 인수로 반환됩니다. 그 &lt;small&gt;CDR은&lt;/small&gt; 속성이 발견, 또는 한에 오버레이입니다 &lt;code&gt;nil&lt;/code&gt; 가 텍스트 속성으로 발견되거나 전혀 발견되지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="6b878b75e01a9b65a11b6b767fc6064f2ed8e1c3" translate="yes" xml:space="preserve">
          <source>Its value should be an alist of elements &lt;code&gt;(&lt;var&gt;group&lt;/var&gt;
. &lt;var&gt;method&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;group&lt;/var&gt; is a symbol specifying a group of characters, and &lt;var&gt;method&lt;/var&gt; is a symbol specifying how to display them.</source>
          <target state="translated">값은 요소 목록 &lt;code&gt;(&lt;var&gt;group&lt;/var&gt; . &lt;var&gt;method&lt;/var&gt;)&lt;/code&gt; 이어야합니다 . 여기서 &lt;var&gt;group&lt;/var&gt; 은 문자 그룹을 지정하는 기호 이고 &lt;var&gt;method&lt;/var&gt; 는 표시 방법을 지정하는 기호입니다.</target>
        </trans-unit>
        <trans-unit id="a45885aac538290762a4f7f3317abf411bb16059" translate="yes" xml:space="preserve">
          <source>JPEG</source>
          <target state="translated">JPEG</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="6f0b2b618684c092a8066c4d2b87cf92b25d0ab7" translate="yes" xml:space="preserve">
          <source>JSON Remote Procedure Call protocol</source>
          <target state="translated">JSON 원격 프로 시저 호출 프로토콜</target>
        </trans-unit>
        <trans-unit id="5f40c53af62eb7b5ee0a65ed1e7c8f365f43b1f1" translate="yes" xml:space="preserve">
          <source>JSON has only one map type, the object. JSON objects are represented using Lisp hashtables, alists or plists. When an alist or plist contains several elements with the same key, Emacs uses only the first element for serialization, in accordance with the behavior of &lt;code&gt;assq&lt;/code&gt;.</source>
          <target state="translated">JSON에는 하나의지도 유형 인 객체 만 있습니다. JSON 객체는 Lisp 해시 테이블, 목록 또는 plist를 사용하여 표현됩니다. alist 또는 plist에 동일한 키를 가진 여러 요소가 포함 된 경우 Emacs는 &lt;code&gt;assq&lt;/code&gt; 의 동작에 따라 직렬화에 첫 번째 요소 만 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="4027009299142689327089033c66ce6d8204c015" translate="yes" xml:space="preserve">
          <source>JSON has only one sequence type, the array. JSON arrays are represented using Lisp vectors.</source>
          <target state="translated">JSON에는 하나의 시퀀스 유형 인 배열 만 있습니다. JSON 배열은 Lisp 벡터를 사용하여 표현됩니다.</target>
        </trans-unit>
        <trans-unit id="89330272dcad769514c364e424832f313f1167c0" translate="yes" xml:space="preserve">
          <source>JSON only has floating-point numbers. They can represent both Lisp integers and Lisp floating-point numbers.</source>
          <target state="translated">JSON에는 부동 소수점 숫자 만 있습니다. Lisp 정수와 Lisp 부동 소수점 숫자를 모두 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18c0817b7de8ce2fe86bde8704950b2eeeb0640d" translate="yes" xml:space="preserve">
          <source>JSON strings are always Unicode strings encoded in UTF-8. Lisp strings can contain non-Unicode characters.</source>
          <target state="translated">JSON 문자열은 항상 UTF-8로 인코딩 된 유니 코드 문자열입니다. Lisp 문자열은 비 유니 코드 문자를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="604769fe0494c1a23dd3dbf7fcb493bb82074409" translate="yes" xml:space="preserve">
          <source>JSON uses three keywords: &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;. &lt;code&gt;true&lt;/code&gt; is represented by the symbol &lt;code&gt;t&lt;/code&gt;. By default, the remaining two are represented, respectively, by the symbols &lt;code&gt;:null&lt;/code&gt; and &lt;code&gt;:false&lt;/code&gt;.</source>
          <target state="translated">JSON은 &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;null&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; 의 세 가지 키워드를 사용합니다 . &lt;code&gt;true&lt;/code&gt; 는 기호 &lt;code&gt;t&lt;/code&gt; 로 표시됩니다 . 기본적으로 나머지 두 개는 각각 &lt;code&gt;:null&lt;/code&gt; 및 &lt;code&gt;:false&lt;/code&gt; 기호로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="ffacdf205c7b613f126d350a3416adc2ea7f7d90" translate="yes" xml:space="preserve">
          <source>JSONRPC</source>
          <target state="translated">JSONRPC</target>
        </trans-unit>
        <trans-unit id="023904df01b91caca2efa0a6f39bbded6afa2411" translate="yes" xml:space="preserve">
          <source>JSONRPC JSON object format</source>
          <target state="translated">JSONRPC JSON 객체 형식</target>
        </trans-unit>
        <trans-unit id="8cb256262920f81ff7c10fc10bd2e49e81c8137a" translate="yes" xml:space="preserve">
          <source>JSONRPC JSON objects are exchanged as Lisp plists (see &lt;a href=&quot;property-lists#Property-Lists&quot;&gt;Property Lists&lt;/a&gt;): JSON-compatible plists are handed to the dispatcher functions and, likewise, JSON-compatible plists should be given to &lt;code&gt;jsonrpc-notify&lt;/code&gt;, &lt;code&gt;jsonrpc-request&lt;/code&gt;, and &lt;code&gt;jsonrpc-async-request&lt;/code&gt;.</source>
          <target state="translated">JSONRPC JSON 객체는 Lisp plists로 교환됩니다 ( &lt;a href=&quot;property-lists#Property-Lists&quot;&gt;Property Lists&lt;/a&gt; 참조 ) : JSON 호환 plist는 디스패처 함수에 전달되며 마찬가지로 &lt;code&gt;jsonrpc-notify&lt;/code&gt; , &lt;code&gt;jsonrpc-request&lt;/code&gt; 및 &lt;code&gt;jsonrpc-async-request&lt;/code&gt; 에 JSON 호환 plist가 제공되어야합니다. .</target>
        </trans-unit>
        <trans-unit id="a9068fb4f18e456442cb8e3b2ddc33c5d4e5641e" translate="yes" xml:space="preserve">
          <source>JSONRPC communication</source>
          <target state="translated">JSONRPC 통신</target>
        </trans-unit>
        <trans-unit id="bb9246b17bfdff9790f8c3e72422d7b7db8ccff0" translate="yes" xml:space="preserve">
          <source>Jumping</source>
          <target state="translated">Jumping</target>
        </trans-unit>
        <trans-unit id="a20aab26c7084f09b487ca4a8ecb0f67c7f41eca" translate="yes" xml:space="preserve">
          <source>Jumping out of a sequence.</source>
          <target state="translated">시퀀스에서 점프.</target>
        </trans-unit>
        <trans-unit id="2d4e7474c74be192828a058c6fbfa5e4ed48ebd6" translate="yes" xml:space="preserve">
          <source>Just like &lt;code&gt;input-decode-map&lt;/code&gt;, but unlike &lt;code&gt;local-function-key-map&lt;/code&gt;, this keymap is applied regardless of whether the input key-sequence has a normal binding. Note however that actual key bindings can have an effect on &lt;code&gt;key-translation-map&lt;/code&gt;, even though they are overridden by it. Indeed, actual key bindings override &lt;code&gt;local-function-key-map&lt;/code&gt; and thus may alter the key sequence that &lt;code&gt;key-translation-map&lt;/code&gt; receives. Clearly, it is better to avoid this type of situation.</source>
          <target state="translated">마찬가지로 &lt;code&gt;input-decode-map&lt;/code&gt; 이지만 달리 &lt;code&gt;local-function-key-map&lt;/code&gt; 이 키맵 관계없이 상기 입력 키 시퀀스가 결합 정상이 있는지의인가된다. 그러나 실제 키 바인딩 은 대체 된 경우에도 &lt;code&gt;key-translation-map&lt;/code&gt; 에 영향을 미칠 수 있습니다 . 실제로 실제 키 바인딩은 &lt;code&gt;local-function-key-map&lt;/code&gt; 을 재정의 하므로 &lt;code&gt;key-translation-map&lt;/code&gt; 이 수신 하는 키 시퀀스를 변경할 수 있습니다 . 분명히 이러한 유형의 상황을 피하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="77d80675faa0379a05b630d16d127cfd2e69de8d" translate="yes" xml:space="preserve">
          <source>Just moving the mouse, not pushing a button.</source>
          <target state="translated">버튼을 누르지 않고 마우스를 움직 이기만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="17d7aa6336e0d7068a94ced38ef5d747f79474ef" translate="yes" xml:space="preserve">
          <source>Just what parameters a frame has depends on what display mechanism it uses. This section describes the parameters that have special meanings on some or all kinds of terminals. Of these, &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;title&lt;/code&gt;, &lt;code&gt;height&lt;/code&gt;, &lt;code&gt;width&lt;/code&gt;, &lt;code&gt;buffer-list&lt;/code&gt; and &lt;code&gt;buffer-predicate&lt;/code&gt; provide meaningful information in terminal frames, and &lt;code&gt;tty-color-mode&lt;/code&gt; is meaningful only for frames on text terminals.</source>
          <target state="translated">프레임에 어떤 매개 변수가 있는지는 사용하는 표시 메커니즘에 따라 다릅니다. 이 섹션에서는 일부 또는 모든 종류의 터미널에서 특별한 의미를 갖는 매개 변수에 대해 설명합니다. 이 중에서 &lt;code&gt;name&lt;/code&gt; , &lt;code&gt;title&lt;/code&gt; , &lt;code&gt;height&lt;/code&gt; , &lt;code&gt;width&lt;/code&gt; , &lt;code&gt;buffer-list&lt;/code&gt; 및 &lt;code&gt;buffer-predicate&lt;/code&gt; 는 터미널 프레임에서 의미있는 정보를 제공하며 &lt;code&gt;tty-color-mode&lt;/code&gt; 는 텍스트 터미널의 프레임에서만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7ee38bb7be4fc44198cb2685d9601dcf2b9f569" translate="yes" xml:space="preserve">
          <source>K</source>
          <target state="translated">K</target>
        </trans-unit>
        <trans-unit id="b4003201894d55fb52e96919b5492ae84d3e20c6" translate="yes" xml:space="preserve">
          <source>Keep the standard output stream separate from the standard error stream; deal with the ordinary output as specified by &lt;var&gt;real-destination&lt;/var&gt;, and dispose of the error output according to &lt;var&gt;error-destination&lt;/var&gt;. If &lt;var&gt;error-destination&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, that means to discard the error output, &lt;code&gt;t&lt;/code&gt; means mix it with the ordinary output, and a string specifies a file name to redirect error output into.</source>
          <target state="translated">표준 출력 스트림을 표준 오류 스트림과 별도로 유지하십시오. &lt;var&gt;real-destination&lt;/var&gt; 에 지정된대로 일반 출력을 처리하고 &lt;var&gt;error-destination&lt;/var&gt; 에 따라 오류 출력을 처리 합니다 . 경우 &lt;var&gt;error-destination&lt;/var&gt; 이다 &lt;code&gt;nil&lt;/code&gt; , 수단이 오류 출력을 폐기 할 것을 &lt;code&gt;t&lt;/code&gt; 의 수단은 일반 출력과 혼합하고, 문자열로 리디렉션 오류 출력에 파일 이름을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="2313f6a862f0a5a7b23c0ccfb3f009b7d62043d3" translate="yes" xml:space="preserve">
          <source>Keeping multiple backups for each source file.</source>
          <target state="translated">각 소스 파일에 대해 여러 백업을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="8d474fa62c5cf5a6da4cbae82ab10a2815da666e" translate="yes" xml:space="preserve">
          <source>Key Lookup</source>
          <target state="translated">키 조회</target>
        </trans-unit>
        <trans-unit id="cb77a254d48a5f705e632277b08072b03c096a05" translate="yes" xml:space="preserve">
          <source>Key Sequence Input</source>
          <target state="translated">키 시퀀스 입력</target>
        </trans-unit>
        <trans-unit id="7a7b2425d6daf70b349c0a7d7d7ea874344f67e9" translate="yes" xml:space="preserve">
          <source>Key Sequences</source>
          <target state="translated">키 시퀀스</target>
        </trans-unit>
        <trans-unit id="0b515ab1a9fb6a3fcee02f1f50e5a2f26e18e821" translate="yes" xml:space="preserve">
          <source>Key lookup uses just the event type of each event in the key sequence; the rest of the event is ignored. In fact, a key sequence used for key lookup may designate a mouse event with just its types (a symbol) instead of the entire event (a list). See &lt;a href=&quot;input-events#Input-Events&quot;&gt;Input Events&lt;/a&gt;. Such a key sequence is insufficient for &lt;code&gt;command-execute&lt;/code&gt; to run, but it is sufficient for looking up or rebinding a key.</source>
          <target state="translated">키 조회는 키 시퀀스에서 각 이벤트의 이벤트 유형 만 사용합니다. 나머지 이벤트는 무시됩니다. 사실, 키 조회에 사용되는 키 시퀀스는 전체 이벤트 (목록) 대신 유형 (기호)만으로 마우스 이벤트를 지정할 수 있습니다. &lt;a href=&quot;input-events#Input-Events&quot;&gt;입력 이벤트를&lt;/a&gt; 참조하십시오 . 이러한 키 시퀀스는 &lt;code&gt;command-execute&lt;/code&gt; 을 실행 하는 데 충분하지 않지만 키를 찾거나 다시 바인딩하는 데는 충분합니다.</target>
        </trans-unit>
        <trans-unit id="00ac667fea005ecd115f4ed149f2f13d0cf004c7" translate="yes" xml:space="preserve">
          <source>Key sequences as Lisp objects.</source>
          <target state="translated">Lisp 객체로서의 키 시퀀스.</target>
        </trans-unit>
        <trans-unit id="e6f5765563fe2bf147f6daa60b670109e680de3f" translate="yes" xml:space="preserve">
          <source>Key sequences containing function keys, mouse button events, system events, or non-</source>
          <target state="translated">기능 키, 마우스 버튼 이벤트, 시스템 이벤트 또는 비</target>
        </trans-unit>
        <trans-unit id="3961da9502b1e99387aff089f5c83ca94c5c588d" translate="yes" xml:space="preserve">
          <source>Keyboard Events</source>
          <target state="translated">키보드 이벤트</target>
        </trans-unit>
        <trans-unit id="cc4837611e356bedd08fd92c8bd27ef9a22790ca" translate="yes" xml:space="preserve">
          <source>Keyboard Macros</source>
          <target state="translated">키보드 매크로</target>
        </trans-unit>
        <trans-unit id="8b6bd7b83a0711a97c1d29c9f645fc934a4cbc3d" translate="yes" xml:space="preserve">
          <source>Keyboard macros (strings and vectors) are commands also, even though they are not functions. See &lt;a href=&quot;keyboard-macros#Keyboard-Macros&quot;&gt;Keyboard Macros&lt;/a&gt;. We say that a symbol is a command if its function cell contains a command (see &lt;a href=&quot;symbol-components#Symbol-Components&quot;&gt;Symbol Components&lt;/a&gt;); such a &lt;em&gt;named command&lt;/em&gt; can be invoked with</source>
          <target state="translated">키보드 매크로 (문자열 및 벡터)도 기능이 아니지만 명령입니다. &lt;a href=&quot;keyboard-macros#Keyboard-Macros&quot;&gt;키보드 매크로를&lt;/a&gt; 참조하십시오 . 기능 셀에 명령이 포함 된 경우 기호는 명령이라고 말합니다 ( &lt;a href=&quot;symbol-components#Symbol-Components&quot;&gt;기호 구성 요소&lt;/a&gt; 참조 ). 이러한 &lt;em&gt;명명 된 명령&lt;/em&gt; 은 다음과 같이 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57d8ce809f6aac6dc1bf827bb30233a06fa72cbe" translate="yes" xml:space="preserve">
          <source>Keyboard macros containing the commands in this section do not completely work: exiting from Edebug, to resume the program, loses track of the keyboard macro. This is not easy to fix. Also, defining or executing a keyboard macro outside of Edebug does not affect commands inside Edebug. This is usually an advantage. See also the &lt;code&gt;edebug-continue-kbd-macro&lt;/code&gt; option in &lt;a href=&quot;edebug-options#Edebug-Options&quot;&gt;Edebug Options&lt;/a&gt;.</source>
          <target state="translated">이 섹션의 명령이 포함 된 키보드 매크로는 완전히 작동하지 않습니다. Edebug를 종료하고 프로그램을 다시 시작하면 키보드 매크로가 추적되지 않습니다. 이것은 고치기가 쉽지 않습니다. 또한 Edebug 외부에서 키보드 매크로를 정의하거나 실행해도 Edebug 내부 명령에는 영향을주지 않습니다. 이것은 일반적으로 장점입니다. &lt;a href=&quot;edebug-options#Edebug-Options&quot;&gt;Edebug 옵션&lt;/a&gt; 의 &lt;code&gt;edebug-continue-kbd-macro&lt;/code&gt; 옵션 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e3894811d2bb2e8a0e70a43023f6e533fc04aa5f" translate="yes" xml:space="preserve">
          <source>Keymap Basics</source>
          <target state="translated">키맵 기초</target>
        </trans-unit>
        <trans-unit id="7e1e2cf42b1a47ad6de7151c248a098ee3773208" translate="yes" xml:space="preserve">
          <source>Keymap Type</source>
          <target state="translated">키맵 유형</target>
        </trans-unit>
        <trans-unit id="d76a6428ca9ac90ba70592739416e9b19c454e19" translate="yes" xml:space="preserve">
          <source>Keymaps</source>
          <target state="translated">Keymaps</target>
        </trans-unit>
        <trans-unit id="68c5dc6cf88794930ca2d061c030b64676e40cee" translate="yes" xml:space="preserve">
          <source>Keymaps and Minor Modes</source>
          <target state="translated">키맵 및 부 모드</target>
        </trans-unit>
        <trans-unit id="3093db83b00c2f7e5b19934739a3fc63828ae6d8" translate="yes" xml:space="preserve">
          <source>Keymaps do not directly record bindings for the meta characters. Instead, meta characters are regarded for purposes of key lookup as sequences of two characters, the first of which is</source>
          <target state="translated">키맵은 메타 문자에 대한 바인딩을 직접 기록하지 않습니다. 대신 메타 문자는 키 조회 목적으로 두 문자의 시퀀스로 간주되며, 첫 번째 문자는</target>
        </trans-unit>
        <trans-unit id="3117df544bce8c92b99c739e69838cf2a9859a28" translate="yes" xml:space="preserve">
          <source>Keymaps for Translating Sequences of Events</source>
          <target state="translated">이벤트 시퀀스 번역을위한 키맵</target>
        </trans-unit>
        <trans-unit id="89b194f61c3768b6f1d5626d1fe4d243fd85ddb1" translate="yes" xml:space="preserve">
          <source>Keymaps for translating sequences of events.</source>
          <target state="translated">이벤트 시퀀스를 번역하기위한 키맵.</target>
        </trans-unit>
        <trans-unit id="fe40ad8ac52f1e3452189e07dae6c5efcaaf2ae3" translate="yes" xml:space="preserve">
          <source>Keypad PF keys.</source>
          <target state="translated">키패드 PF 키.</target>
        </trans-unit>
        <trans-unit id="7ff53782c834404cf3524a8597174b2cf0076736" translate="yes" xml:space="preserve">
          <source>Keypad arrow keys. Emacs normally translates these into the corresponding non-keypad keys &lt;code&gt;home&lt;/code&gt;, &lt;code&gt;left&lt;/code&gt;, &amp;hellip;</source>
          <target state="translated">키패드 화살표 키. Emacs는 일반적으로이를 해당하는 비 키패드 키 &lt;code&gt;home&lt;/code&gt; , &lt;code&gt;left&lt;/code&gt; ,&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="b5eb0d39876e431709d140c2c21d82c8238a6c99" translate="yes" xml:space="preserve">
          <source>Keypad keys (to the right of the regular keyboard).</source>
          <target state="translated">키패드 키 (일반 키보드 오른쪽).</target>
        </trans-unit>
        <trans-unit id="eef968747a417ebd5b41ada36d96e9a593e3dde7" translate="yes" xml:space="preserve">
          <source>Keypad keys with digits.</source>
          <target state="translated">숫자가있는 키패드 키.</target>
        </trans-unit>
        <trans-unit id="dd3107ada3563f5762a1c77c6d042feef96965e8" translate="yes" xml:space="preserve">
          <source>Keys which are numbers are the same if they are &lt;code&gt;equal&lt;/code&gt;, that is, if they are equal in value and either both are integers or both are floating point; otherwise, two distinct objects are never the same.</source>
          <target state="translated">숫자 인 키는 &lt;code&gt;equal&lt;/code&gt; . 즉, 값이 같고 둘 다 정수이거나 둘 다 부동 소수점이면 동일합니다. 그렇지 않으면 두 개의 별개 개체가 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0a96287d882fd3ff1fe974dd3e8fb389c5f972f8" translate="yes" xml:space="preserve">
          <source>Keyword-argument pairs in a customization type.</source>
          <target state="translated">사용자 정의 유형의 키워드-인수 쌍.</target>
        </trans-unit>
        <trans-unit id="f530db58b3e5088dc7412c6d2298ba3f8456bdeb" translate="yes" xml:space="preserve">
          <source>Keywords</source>
          <target state="translated">Keywords</target>
        </trans-unit>
        <trans-unit id="99d76e74c509d75e4d702035d810e89f93c7d6d9" translate="yes" xml:space="preserve">
          <source>Kill Ring Concepts</source>
          <target state="translated">킬 링 개념</target>
        </trans-unit>
        <trans-unit id="0793494cd99ab42f2fd7a7de2f60c1b1f50d20a1" translate="yes" xml:space="preserve">
          <source>Killed text is saved for later yanking in the &lt;em&gt;kill ring&lt;/em&gt;. This is a list that holds a number of recent kills, not just the last text kill. We call this a &amp;ldquo;ring&amp;rdquo; because yanking treats it as having elements in a cyclic order. The list is kept in the variable &lt;code&gt;kill-ring&lt;/code&gt;, and can be operated on with the usual functions for lists; there are also specialized functions, described in this section, that treat it as a ring.</source>
          <target state="translated">킬된 텍스트는 나중에 &lt;em&gt;킬 링&lt;/em&gt; 에서 잡아 당기도록 저장됩니다 . 이것은 마지막 텍스트 킬뿐만 아니라 최근 킬 수를 보유한 목록입니다. yanking은 순환 순서의 요소를 갖는 것으로 취급하기 때문에 이것을 &quot;링&quot;이라고 부릅니다. 목록은 &lt;code&gt;kill-ring&lt;/code&gt; 변수에 보관되며 목록 에 대한 일반적인 기능으로 작동 할 수 있습니다. 이 섹션에서 설명하는 특수 기능도 링으로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="3af8708ad522d3a5f4a8a381debab1e57b5755ab" translate="yes" xml:space="preserve">
          <source>Killing Buffers</source>
          <target state="translated">킬링 버퍼</target>
        </trans-unit>
        <trans-unit id="905a28f726d10a308adc3a62e9e389be2995327d" translate="yes" xml:space="preserve">
          <source>Killing Emacs</source>
          <target state="translated">이맥스 죽이기</target>
        </trans-unit>
        <trans-unit id="e96de96c4cb696f64784e596daa37e7385985b37" translate="yes" xml:space="preserve">
          <source>Killing Emacs means ending the execution of the Emacs process. If you started Emacs from a terminal, the parent process normally resumes control. The low-level primitive for killing Emacs is &lt;code&gt;kill-emacs&lt;/code&gt;.</source>
          <target state="translated">Killing Emacs는 Emacs 프로세스의 실행을 종료하는 것을 의미합니다. 터미널에서 Emacs를 시작한 경우 부모 프로세스는 일반적으로 제어를 재개합니다. Emacs를 &lt;code&gt;kill-emacs&lt;/code&gt; 위한 저수준 기본 요소는 kill-emacs 입니다.</target>
        </trans-unit>
        <trans-unit id="32c52ea2582689ab686f39c40e2513b971ea8ebe" translate="yes" xml:space="preserve">
          <source>Killing a buffer that is already dead has no effect.</source>
          <target state="translated">이미 죽은 버퍼를 죽이는 것은 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6077b76b5702831c966267012f0fbf3e43b7d854" translate="yes" xml:space="preserve">
          <source>Killing an indirect buffer has no effect on its base buffer. Killing the base buffer effectively kills the indirect buffer in that it cannot ever again be the current buffer.</source>
          <target state="translated">간접 버퍼를 죽이는 것은 기본 버퍼에 영향을주지 않습니다. 기본 버퍼를 강제 종료하면 다시 현재 버퍼가 될 수 없다는 점에서 간접 버퍼도 효과적으로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="6e673387e3bdf070063073a3f9e5be789f453c2e" translate="yes" xml:space="preserve">
          <source>Killing the associated buffer of a process also kills the process. Emacs asks for confirmation first, if the process&amp;rsquo;s &lt;code&gt;process-query-on-exit-flag&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt; (see &lt;a href=&quot;query-before-exit#Query-Before-Exit&quot;&gt;Query Before Exit&lt;/a&gt;). This confirmation is done by the function &lt;code&gt;process-kill-buffer-query-function&lt;/code&gt;, which is run from &lt;code&gt;kill-buffer-query-functions&lt;/code&gt; (see &lt;a href=&quot;killing-buffers#Killing-Buffers&quot;&gt;Killing Buffers&lt;/a&gt;).</source>
          <target state="translated">프로세스의 관련 버퍼를 종료하면 프로세스도 종료됩니다. Emacs는 프로세스의 &lt;code&gt;process-query-on-exit-flag&lt;/code&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 먼저 확인을 요청합니다 ( &lt;a href=&quot;query-before-exit#Query-Before-Exit&quot;&gt;Query Before Exit&lt;/a&gt; 참조 ). 이 확인은 함수에 의해 수행되는 &lt;code&gt;process-kill-buffer-query-function&lt;/code&gt; 에서 실행되고, &lt;code&gt;kill-buffer-query-functions&lt;/code&gt; (참조 &lt;a href=&quot;killing-buffers#Killing-Buffers&quot;&gt;버퍼를 죽이는&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3bdff83a09d5676c78e5c2c430a0e721e8015f53" translate="yes" xml:space="preserve">
          <source>Killing the process&amp;rsquo;s buffer deletes the process, which kills the subprocess with a &lt;code&gt;SIGHUP&lt;/code&gt; signal (see &lt;a href=&quot;signals-to-processes#Signals-to-Processes&quot;&gt;Signals to Processes&lt;/a&gt;).</source>
          <target state="translated">프로세스의 버퍼를 종료하면 프로세스가 삭제되고 &lt;code&gt;SIGHUP&lt;/code&gt; 신호로 하위 프로세스가 종료 &lt;a href=&quot;signals-to-processes#Signals-to-Processes&quot;&gt;됩니다 (프로세스에&lt;/a&gt; 대한 신호 참조 ).</target>
        </trans-unit>
        <trans-unit id="7f4b3ead218699344f23be9d2cfa8db0a8b21cce" translate="yes" xml:space="preserve">
          <source>Kinds of Forms</source>
          <target state="translated">양식의 종류</target>
        </trans-unit>
        <trans-unit id="64d2ffb3f2887641adb1066e515d59980846cd8f" translate="yes" xml:space="preserve">
          <source>Kludge to make preloaded Lisp functions shareable.</source>
          <target state="translated">미리로드 된 Lisp 함수를 공유 할 수 있도록 Kludge.</target>
        </trans-unit>
        <trans-unit id="9f99b3ffcb996071b995db44be3acebff40b85cd" translate="yes" xml:space="preserve">
          <source>Knowing the outer size of a frame is useful for fitting a frame into the working area of its display (see &lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;Multiple Terminals&lt;/a&gt;) or for placing two frames adjacent to each other on the screen. Usually, the outer size of a frame is available only after the frame has been mapped (made visible, see &lt;a href=&quot;visibility-of-frames#Visibility-of-Frames&quot;&gt;Visibility of Frames&lt;/a&gt;) at least once. For the initial frame or a frame that has not been created yet, the outer size can be only estimated or must be calculated from the window-system&amp;rsquo;s or window manager&amp;rsquo;s defaults. One workaround is to obtain the differences of the outer and native (see below) sizes of a mapped frame and use them for calculating the outer size of the new frame.</source>
          <target state="translated">프레임의 외부 크기를 아는 것은 프레임을 디스플레이의 작업 영역에 맞추거나 ( &lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;다중 터미널&lt;/a&gt; 참조 ) 화면에서 두 개의 프레임을 서로 인접하게 배치 하는 데 유용합니다 . 일반적으로 프레임의 외부 크기는 프레임이 매핑 된 후 ( &lt;a href=&quot;visibility-of-frames#Visibility-of-Frames&quot;&gt;표시되고 프레임 가시성&lt;/a&gt; 참조 ) 한 번 이상 사용할 수 있습니다. 초기 프레임 또는 아직 생성되지 않은 프레임의 경우 외부 크기는 추정 만 가능하거나 창 시스템 또는 창 관리자의 기본값에서 계산해야합니다. 한 가지 해결 방법은 매핑 된 프레임의 외부 및 기본 (아래 참조) 크기의 차이를 가져 와서 새 프레임의 외부 크기를 계산하는 데 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="cbd787f29ba8f2730cc87a999b5ba33499aa964b" translate="yes" xml:space="preserve">
          <source>Kochi Gothic</source>
          <target state="translated">고치 고딕</target>
        </trans-unit>
        <trans-unit id="dbe210e5d6e8e316f7fec4291dc590c38590425d" translate="yes" xml:space="preserve">
          <source>LRM</source>
          <target state="translated">LRM</target>
        </trans-unit>
        <trans-unit id="93888d709ed769c070b132d596bc80ec625d98c7" translate="yes" xml:space="preserve">
          <source>LRO</source>
          <target state="translated">LRO</target>
        </trans-unit>
        <trans-unit id="0d6d942b0d775bd54e421837f661227031916cc3" translate="yes" xml:space="preserve">
          <source>Lambda Expressions</source>
          <target state="translated">람다 식</target>
        </trans-unit>
        <trans-unit id="08e9d75b80cfeb0adf69e90498297bc377db4e87" translate="yes" xml:space="preserve">
          <source>Lambda expressions are functions with no names.</source>
          <target state="translated">Lambda 표현식은 이름이없는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="91690fadbf640ee6fddae4125d1ea25d075b5bc6" translate="yes" xml:space="preserve">
          <source>Laplace edge-detection currently uses a matrix of</source>
          <target state="translated">Laplace edge-detection은 현재 다음의 행렬을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c26bd272e8dcb1ad4f38240d83c90fe2b2da1de1" translate="yes" xml:space="preserve">
          <source>Lastly (in this series of &lt;code&gt;and&lt;/code&gt; sub-patterns), &lt;code&gt;app&lt;/code&gt; evaluates &lt;code&gt;(match-string&amp;nbsp;1&amp;nbsp;&lt;var&gt;expval&lt;/var&gt;)&lt;/code&gt; (line 6) to get a temporary value &lt;var&gt;tmp&lt;/var&gt; (i.e., the &amp;ldquo;NUMBER&amp;rdquo; substring) and tries to match &lt;var&gt;tmp&lt;/var&gt; against pattern &lt;code&gt;val&lt;/code&gt; (line 7). Since that is a &lt;var&gt;symbol&lt;/var&gt; pattern, it matches unconditionally and additionally binds &lt;code&gt;val&lt;/code&gt; to &lt;var&gt;tmp&lt;/var&gt;.</source>
          <target state="translated">마지막으로 (이 일련의 &lt;code&gt;and&lt;/code&gt; 하위 패턴에서) &lt;code&gt;app&lt;/code&gt; 은 &lt;code&gt;(match-string&amp;nbsp;1&amp;nbsp;&lt;var&gt;expval&lt;/var&gt;)&lt;/code&gt; (6 행)을 평가하여 임시 값 &lt;var&gt;tmp&lt;/var&gt; (즉, &quot;NUMBER&quot;하위 문자열)를 가져오고 &lt;var&gt;tmp&lt;/var&gt; 를 패턴 &lt;code&gt;val&lt;/code&gt; (행 7). 그것은 &lt;var&gt;symbol&lt;/var&gt; 패턴 이기 때문에 무조건적으로 일치하고 추가적으로 &lt;code&gt;val&lt;/code&gt; 을 &lt;var&gt;tmp&lt;/var&gt; 에 바인딩 합니다 .</target>
        </trans-unit>
        <trans-unit id="3c447261c5172f1f0b697d9d9c7e4f3be584769f" translate="yes" xml:space="preserve">
          <source>Layout Parameters</source>
          <target state="translated">레이아웃 매개 변수</target>
        </trans-unit>
        <trans-unit id="dd7dcc546a0d472e7c791aa18106a1ac7f735332" translate="yes" xml:space="preserve">
          <source>Lazy Computation of Text Properties</source>
          <target state="translated">텍스트 속성의 지연 계산</target>
        </trans-unit>
        <trans-unit id="51a6c8e8ab483e67fa01f4eb903d9c6360351fa8" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s assume you did not type</source>
          <target state="translated">입력하지 않았다고 가정하겠습니다.</target>
        </trans-unit>
        <trans-unit id="6c75a6f87f325302da0b7e4c39c4c865071152a7" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s consider a user who, as a rule, prefers to display buffers on another frame. Such a user might provide the following customization:</source>
          <target state="translated">일반적으로 다른 프레임에 버퍼를 표시하는 것을 선호하는 사용자를 생각해 봅시다. 이러한 사용자는 다음과 같은 사용자 정의를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0ffbdb0406b9b3b41b822f0911fd341803419cd" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s consider the situation where &lt;code&gt;obj&lt;/code&gt; is not a string, or it is a string but has the wrong form. In this case, one of the &lt;code&gt;pred&lt;/code&gt; (lines 3-5) fails to match, thus &lt;code&gt;and&lt;/code&gt; (line 2) fails to match, thus &lt;code&gt;or&lt;/code&gt; (line 1) proceeds to try sub-pattern &lt;code&gt;let&lt;/code&gt; (line 8).</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 가 문자열이 아니거나 문자열이지만 형식이 잘못된 상황을 생각해 봅시다 . 이 경우, 하나 &lt;code&gt;pred&lt;/code&gt; (선 3-5) 따라서, 일치에 실패 &lt;code&gt;and&lt;/code&gt; (라인 2) 따라서, 일치에 실패 &lt;code&gt;or&lt;/code&gt; (라인 1) 서브 패턴하려고 진행 &lt;code&gt;let&lt;/code&gt; (행 8).</target>
        </trans-unit>
        <trans-unit id="f464f3d20ed12cd11f243e1c955b67ff512e7c56" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start with a precise explanation of the arguments to the &lt;code&gt;DEFUN&lt;/code&gt; macro. Here is a template for them:</source>
          <target state="translated">&lt;code&gt;DEFUN&lt;/code&gt; 매크로 에 대한 인수에 대한 정확한 설명부터 시작하겠습니다 . 다음은 이들을위한 템플릿입니다.</target>
        </trans-unit>
        <trans-unit id="41d77d8b522c0e48c0a6671a0d4abc1bf8cb3bb4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s use the term &lt;em&gt;keymap entry&lt;/em&gt; to describe the value found by looking up an event type in a keymap. (This doesn&amp;rsquo;t include the item string and other extra elements in a keymap element for a menu item, because &lt;code&gt;lookup-key&lt;/code&gt; and other key lookup functions don&amp;rsquo;t include them in the returned value.) While any Lisp object may be stored in a keymap as a keymap entry, not all make sense for key lookup. Here is a table of the meaningful types of keymap entries:</source>
          <target state="translated">&lt;em&gt;keymap 항목&lt;/em&gt; 이라는 용어를 사용하여 &lt;em&gt;keymap&lt;/em&gt; 에서 이벤트 유형을 검색하여 찾은 값을 설명해 보겠습니다 . ( &lt;code&gt;lookup-key&lt;/code&gt; 및 기타 키 조회 기능이 반환 된 값에 포함되지 않기 때문에 메뉴 항목에 대한 키맵 요소의 항목 문자열 및 기타 추가 요소는 포함되지 않습니다.) Lisp 객체는 키맵 항목으로서의 키맵, 키 조회에 모두 의미가있는 것은 아닙니다. 다음은 의미있는 키맵 항목 유형의 표입니다.</target>
        </trans-unit>
        <trans-unit id="8bbb0c0a5273b41486ac35de13cae2a081554aba" translate="yes" xml:space="preserve">
          <source>Letter-case of the strings is significant for the computed distance, but their text properties are ignored. If the optional argument &lt;var&gt;bytecompare&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the function calculates the distance in terms of bytes instead of characters. The byte-wise comparison uses the internal Emacs representation of characters, so it will produce inaccurate results for multibyte strings that include raw bytes (see &lt;a href=&quot;text-representations#Text-Representations&quot;&gt;Text Representations&lt;/a&gt;); make the strings unibyte by encoding them (see &lt;a href=&quot;explicit-encoding#Explicit-Encoding&quot;&gt;Explicit Encoding&lt;/a&gt;) if you need accurate results with raw bytes.</source>
          <target state="translated">문자열의 대소 문자는 계산 된 거리에 중요하지만 해당 텍스트 속성은 무시됩니다. 선택적 인수 &lt;var&gt;bytecompare&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 함수는 문자 대신 바이트로 거리를 계산합니다. 바이트 단위 비교는 문자의 내부 Emacs 표현을 사용하므로 원시 바이트를 포함하는 멀티 바이트 문자열에 대해 부정확 한 결과가 생성됩니다 ( &lt;a href=&quot;text-representations#Text-Representations&quot;&gt;텍스트 표현&lt;/a&gt; 참조 ). 원시 바이트로 정확한 결과가 필요한 경우 &lt;a href=&quot;explicit-encoding#Explicit-Encoding&quot;&gt;인코딩&lt;/a&gt; 하여 문자열을 유니 바이트로 만듭니다 ( Explicit Encoding 참조 ).</target>
        </trans-unit>
        <trans-unit id="24275f318d0094becb9bb3da3aed51320878e090" translate="yes" xml:space="preserve">
          <source>Level 1: highlight function declarations, file directives (such as include or import directives), strings and comments. The idea is speed, so only the most important and top-level components are fontified.</source>
          <target state="translated">레벨 1 : 강조 기능 선언, 파일 지시문 (예 : include 또는 import 지시문), 문자열 및 주석. 아이디어는 속도이므로 가장 중요한 최상위 구성 요소 만 글꼴로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="2117c8f73cb61424d16255425c9131034d1c287e" translate="yes" xml:space="preserve">
          <source>Level 2: in addition to level 1, highlight all language keywords, including type names that act like keywords, as well as named constant values. The idea is that all keywords (either syntactic or semantic) should be fontified appropriately.</source>
          <target state="translated">수준 2 : 수준 1 외에도 키워드처럼 작동하는 유형 이름과 명명 된 상수 값을 포함한 모든 언어 키워드를 강조 표시합니다. 아이디어는 모든 키워드 (구문 또는 의미)가 적절하게 글꼴 화되어야한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="660378d0e3ca367794af05e686894a24e39fd862" translate="yes" xml:space="preserve">
          <source>Level 3: in addition to level 2, highlight the symbols being defined in function and variable declarations, and all builtin function names, wherever they appear.</source>
          <target state="translated">레벨 3 : 레벨 2 외에도 함수 및 변수 선언에 정의되는 기호와 모든 내장 함수 이름이 표시되는 위치에 강조 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="87fb603e415154744259577d7102e0b2b0b1e8f1" translate="yes" xml:space="preserve">
          <source>Levels of Font Lock</source>
          <target state="translated">글꼴 잠금 수준</target>
        </trans-unit>
        <trans-unit id="845c80fcc7da2e284fb9f14c14e06bfedafb8705" translate="yes" xml:space="preserve">
          <source>Lexical Binding</source>
          <target state="translated">어휘 바인딩</target>
        </trans-unit>
        <trans-unit id="03c426c0276e9e8faf0018b87a45220aece313e0" translate="yes" xml:space="preserve">
          <source>Lexical binding is also enabled in Lisp Interaction and IELM mode, used in the</source>
          <target state="translated">Lisp Interaction 및 IELM 모드에서도 어휘 바인딩을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f85fbb6468aabdaf187bcf592914af6cc0d70ab" translate="yes" xml:space="preserve">
          <source>Lexical binding was introduced to Emacs, as an optional feature, in version 24.1. We expect its importance to increase with time. Lexical binding opens up many more opportunities for optimization, so programs using it are likely to run faster in future Emacs versions. Lexical binding is also more compatible with concurrency, which was added to Emacs in version 26.1.</source>
          <target state="translated">어휘 바인딩은 버전 24.1에서 선택적 기능으로 Emacs에 도입되었습니다. 우리는 그 중요성이 시간이 지남에 따라 증가 할 것으로 기대합니다. 어휘 바인딩은 최적화를위한 더 많은 기회를 열어 주므로이를 사용하는 프로그램은 향후 Emacs 버전에서 더 빠르게 실행될 것입니다. 어휘 바인딩은 버전 26.1에서 Emacs에 추가 된 동시성과 더 잘 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="88636ad7d4af3bb35c12874b15e249f93c783680" translate="yes" xml:space="preserve">
          <source>Lexical bindings have indefinite extent. Even after a binding construct has finished executing, its lexical environment can be &amp;ldquo;kept around&amp;rdquo; in Lisp objects called &lt;em&gt;closures&lt;/em&gt;. A closure is created when you define a named or anonymous function with lexical binding enabled. See &lt;a href=&quot;closures#Closures&quot;&gt;Closures&lt;/a&gt;, for details.</source>
          <target state="translated">어휘 바인딩의 범위는 무한합니다. 바인딩 구조가 실행을 마친 후에도 그 어휘 환경은 &lt;em&gt;클로저&lt;/em&gt; 라고하는 Lisp 객체에서 &quot;보존&quot;될 수 있습니다 . 어휘 바인딩이 활성화 된 이름 또는 익명 함수를 정의하면 클로저가 생성됩니다. 자세한 내용은 &lt;a href=&quot;closures#Closures&quot;&gt;폐쇄&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="58d773a50406916324eae7c7bdd22604efe3ac76" translate="yes" xml:space="preserve">
          <source>Library Search</source>
          <target state="translated">도서관 검색</target>
        </trans-unit>
        <trans-unit id="9b66d8e56a509c424a23ad7b016d16d59e2f1039" translate="yes" xml:space="preserve">
          <source>Licensed under the GNU GPL license.</source>
          <target state="translated">GNU GPL 라이선스에 따라 사용이 허가되었습니다.</target>
        </trans-unit>
        <trans-unit id="c7e02c95fe85052fcadf9745a5f1d0358088d936" translate="yes" xml:space="preserve">
          <source>Like</source>
          <target state="translated">Like</target>
        </trans-unit>
        <trans-unit id="1b251709afeae3912bdd27abd462e3a66e4fd821" translate="yes" xml:space="preserve">
          <source>Like &amp;lsquo;</source>
          <target state="translated">처럼 '</target>
        </trans-unit>
        <trans-unit id="18854c1917f4c8ae7ba5b12ef46faa8c310417a3" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;base64-encode-string&lt;/code&gt;, but generates the URL variant of base 64, and doesn&amp;rsquo;t insert newline characters into the encoded text, so the result is just one long line.</source>
          <target state="translated">마찬가지로 &lt;code&gt;base64-encode-string&lt;/code&gt; 하지만,베이스 (64)의 URL 변종을 생성하고, 결과는 하나의 긴 줄 그래서이 아닌 인코딩 된 텍스트에 개행 문자를 삽입한다.</target>
        </trans-unit>
        <trans-unit id="cf864cb9871ee5f0fed0c2f4c9ed40a911dc24fb" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;const&lt;/code&gt;, but used for values which are functions. This displays the documentation string as well as the function name. The documentation string is either the one you specify with &lt;code&gt;:doc&lt;/code&gt;, or &lt;var&gt;function&lt;/var&gt;&amp;rsquo;s own documentation string.</source>
          <target state="translated">마찬가지로 &lt;code&gt;const&lt;/code&gt; 를 하지만, 함수입니다 값에 사용. 이것은 문서 문자열과 함수 이름을 표시합니다. 문서 문자열은 &lt;code&gt;:doc&lt;/code&gt; 로 지정한 문자열 이거나 &lt;var&gt;function&lt;/var&gt; 의 자체 문서 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="35528820d5e979720b5f6b9b2860031f57025852" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;const&lt;/code&gt;, but used for values which are variable names. This displays the documentation string as well as the variable name. The documentation string is either the one you specify with &lt;code&gt;:doc&lt;/code&gt;, or &lt;var&gt;variable&lt;/var&gt;&amp;rsquo;s own documentation string.</source>
          <target state="translated">마찬가지로 &lt;code&gt;const&lt;/code&gt; 를 하지만, 변수 이름입니다 값에 사용. 이렇게하면 설명서 문자열과 변수 이름이 표시됩니다. 문서 문자열은 &lt;code&gt;:doc&lt;/code&gt; 로 지정한 문자열 이거나 &lt;var&gt;variable&lt;/var&gt; 의 자체 문서 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="511f05b3538b8f4e5096f874143c83d71d91d631" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;custom-initialize-set&lt;/code&gt;, but use the function &lt;code&gt;set-default&lt;/code&gt; to set the variable, instead of the variable&amp;rsquo;s &lt;code&gt;:set&lt;/code&gt; function. This is the usual choice for a variable whose &lt;code&gt;:set&lt;/code&gt; function enables or disables a minor mode; with this choice, defining the variable will not call the minor mode function, but customizing the variable will do so.</source>
          <target state="translated">마찬가지로 &lt;code&gt;custom-initialize-set&lt;/code&gt; ,하지만 기능 사용 &lt;code&gt;set-default&lt;/code&gt; 대신 변수의 변수를 설정하는 &lt;code&gt;:set&lt;/code&gt; 기능. 이것은 &lt;code&gt;:set&lt;/code&gt; 함수가 부 모드를 활성화 또는 비활성화하는 변수에 대한 일반적인 선택입니다 . 이 선택으로 변수를 정의하면 부 모드 함수가 호출되지 않지만 변수를 사용자 지정하면 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="204b186d3bb6599421d53e05eadb77e0ad88c08e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;custom-manual&lt;/code&gt; except that the link appears in the customization buffer with the Info node name.</source>
          <target state="translated">마찬가지로 &lt;code&gt;custom-manual&lt;/code&gt; 링크는 정보의 노드 이름을 가진 사용자 정의 버퍼에 표시되는 것을 제외하고.</target>
        </trans-unit>
        <trans-unit id="ce9088de4b6dd7133bd35b95efda2d37cb731128" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;defmacro&lt;/code&gt;, a function inlined with &lt;code&gt;define-inline&lt;/code&gt; inherits the scoping rules, either dynamic or lexical, from the call site. See &lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;Variable Scoping&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;defmacro&lt;/code&gt; 와 마찬가지로 &lt;code&gt;define-inline&lt;/code&gt; 으로 인라인 된 함수 는 호출 사이트에서 동적 또는 어휘 범위 지정 규칙을 상속합니다. &lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;변수 범위 지정을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="054b1abbf6ea76431660ba137b3df462a1771437" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;defvar&lt;/code&gt;, this macro marks &lt;code&gt;option&lt;/code&gt; as a special variable, meaning that it should always be dynamically bound. If &lt;var&gt;option&lt;/var&gt; is already lexically bound, that lexical binding remains in effect until the binding construct exits. See &lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;Variable Scoping&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;defvar&lt;/code&gt; 처럼 이 매크로는 &lt;code&gt;option&lt;/code&gt; 을 특수 변수로 표시 합니다. 즉, 항상 동적으로 바인딩되어야합니다. 경우 &lt;var&gt;option&lt;/var&gt; 이미 어휘 바인딩, 바인딩 구조가 종료 될 때까지 효과가 어휘 바인딩 남아 있습니다. &lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;변수 범위 지정을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f505d65b09cd1366a862e42a8e4a2919c0a4c57d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;exit&lt;/code&gt;, but add the key that was pressed to &lt;code&gt;unread-command-events&lt;/code&gt; (see &lt;a href=&quot;event-input-misc#Event-Input-Misc&quot;&gt;Event Input Misc&lt;/a&gt;).</source>
          <target state="translated">마찬가지로 &lt;code&gt;exit&lt;/code&gt; 만에 누른 키 추가 &lt;code&gt;unread-command-events&lt;/code&gt; 합니다 ( &lt;a href=&quot;event-input-misc#Event-Input-Misc&quot;&gt;이벤트 입력 기타를&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="ea9c4bf2fcaba7d1996da05f9b1b988c94d94fff" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;group&lt;/code&gt;, but explicitly assign the group number &lt;var&gt;n&lt;/var&gt;. &lt;var&gt;n&lt;/var&gt; must be positive. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">같이 &lt;code&gt;group&lt;/code&gt; 만 명시 적으로 그룹 번호를 할당 &lt;var&gt;n&lt;/var&gt; . &lt;var&gt;n&lt;/var&gt; 은 양수 여야합니다. 해당 문자열 regexp : '</target>
        </trans-unit>
        <trans-unit id="4add0eb468b070e1db0603abb32c078a15300385" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;list&lt;/code&gt; except that the value must be a vector instead of a list. The elements work the same as in &lt;code&gt;list&lt;/code&gt;.</source>
          <target state="translated">값이 목록이 아닌 벡터 여야한다는 점을 제외하면 &lt;code&gt;list&lt;/code&gt; 과 유사 합니다 . 요소는 &lt;code&gt;list&lt;/code&gt; 에서와 동일하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="1e9ef9ed8d9cfadaf1437987621cbd1046a68178" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;minflt&lt;/code&gt; and &lt;code&gt;majflt&lt;/code&gt;, but include the number of page faults for all the child processes of the given process.</source>
          <target state="translated">마찬가지로 &lt;code&gt;minflt&lt;/code&gt; 및 &lt;code&gt;majflt&lt;/code&gt; 하지만, 주어진 프로세스의 모든 자식 프로세스를위한 페이지 오류의 수를 포함한다.</target>
        </trans-unit>
        <trans-unit id="9dec2e247bfc6d918dc0518cecb0337e87b44e0a" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;next-frame&lt;/code&gt;, but cycles through all frames in the opposite direction.</source>
          <target state="translated">마찬가지로 &lt;code&gt;next-frame&lt;/code&gt; 반대 방향의 모든 프레임을 통해,하지만 순환합니다.</target>
        </trans-unit>
        <trans-unit id="1c35e817ce01d7a752f2915ea0e7c93f0517b8ce" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;plist-get&lt;/code&gt; except that it compares properties using &lt;code&gt;equal&lt;/code&gt; instead of &lt;code&gt;eq&lt;/code&gt;.</source>
          <target state="translated">마찬가지로 &lt;code&gt;plist-get&lt;/code&gt; 이 사용하는 특성을 비교하는 것을 제외하고 &lt;code&gt;equal&lt;/code&gt; 대신 &lt;code&gt;eq&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8a06b48a7b978de0c0d0d182fbd613f4474d842" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;plist-put&lt;/code&gt; except that it compares properties using &lt;code&gt;equal&lt;/code&gt; instead of &lt;code&gt;eq&lt;/code&gt;.</source>
          <target state="translated">추천 &lt;code&gt;plist-put&lt;/code&gt; 가 사용 특성을 비교 한 것을 제외하고는 &lt;code&gt;equal&lt;/code&gt; 대신 &lt;code&gt;eq&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e02ab76a9a240ef8de0ab7231efecfe7c29c24c" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;remove-text-properties&lt;/code&gt; except that &lt;var&gt;list-of-properties&lt;/var&gt; is a list of property names only, not an alternating list of property names and values.</source>
          <target state="translated">마찬가지로 &lt;code&gt;remove-text-properties&lt;/code&gt; 것을 제외 &lt;var&gt;list-of-properties&lt;/var&gt; 속성 이름 목록 만하지 속성 이름과 값의 교류의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="84e3993015f242ac6ae5f8797efb186174cfc8b8" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;set-buffer-modified-p&lt;/code&gt;, but does not force redisplay of mode lines.</source>
          <target state="translated">마찬가지로 &lt;code&gt;set-buffer-modified-p&lt;/code&gt; 되지만 모드 라인 다시 표시하게하지 않는다.</target>
        </trans-unit>
        <trans-unit id="9a6e79e4e3bd95966166ddf0bb5d7b010896c5bf" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;signal&lt;/code&gt; (see &lt;a href=&quot;signaling-errors#Signaling-Errors&quot;&gt;Signaling Errors&lt;/a&gt;), but the signal is delivered in the thread &lt;var&gt;thread&lt;/var&gt;. If &lt;var&gt;thread&lt;/var&gt; is the current thread, then this just calls &lt;code&gt;signal&lt;/code&gt; immediately. Otherwise, &lt;var&gt;thread&lt;/var&gt; will receive the signal as soon as it becomes current. If &lt;var&gt;thread&lt;/var&gt; was blocked by a call to &lt;code&gt;mutex-lock&lt;/code&gt;, &lt;code&gt;condition-wait&lt;/code&gt;, or &lt;code&gt;thread-join&lt;/code&gt;; &lt;code&gt;thread-signal&lt;/code&gt; will unblock it.</source>
          <target state="translated">&lt;code&gt;signal&lt;/code&gt; 와 비슷하지만 ( &lt;a href=&quot;signaling-errors#Signaling-Errors&quot;&gt;Signaling Errors&lt;/a&gt; 참조 ) 신호는 스레드 &lt;var&gt;thread&lt;/var&gt; 에서 전달됩니다 . 경우 &lt;var&gt;thread&lt;/var&gt; 현재 스레드,이 단지 호출 &lt;code&gt;signal&lt;/code&gt; 즉시. 그렇지 않으면 &lt;var&gt;thread&lt;/var&gt; 는 현재 신호가되는 즉시 신호를받습니다. &lt;var&gt;thread&lt;/var&gt; 가 &lt;code&gt;mutex-lock&lt;/code&gt; , &lt;code&gt;condition-wait&lt;/code&gt; 또는 &lt;code&gt;thread-join&lt;/code&gt; 호출에 의해 차단 된 경우 ; &lt;code&gt;thread-signal&lt;/code&gt; 가 차단을 해제합니다.</target>
        </trans-unit>
        <trans-unit id="70f44fcb4db769ebd3aa02784e1dfae20cbb9cec" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;start-process&lt;/code&gt;, this function starts a new asynchronous subprocess running &lt;var&gt;program&lt;/var&gt; in it, and returns its process object.</source>
          <target state="translated">&lt;code&gt;start-process&lt;/code&gt; 와 마찬가지로이 함수는 &lt;var&gt;program&lt;/var&gt; 을 실행하는 새로운 비동기 하위 프로세스를 시작하고 해당 프로세스 개체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1768be4d2bcedb1b2e7b51f71b8b22c88b6d6932" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;string&lt;/code&gt; except that the string must be a valid regular expression.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 이 유효한 정규식이어야한다는 점을 제외하면 문자열 과 유사 합니다 .</target>
        </trans-unit>
        <trans-unit id="f979121e411bd20dfdc3630fc906f2e77d6bac00" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;switch-to-buffer&lt;/code&gt;, this function updates the buffer list unless &lt;var&gt;norecord&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;switch-to-buffer&lt;/code&gt; 와 마찬가지로이 함수 는 &lt;var&gt;norecord&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 버퍼 목록을 업데이트합니다 .</target>
        </trans-unit>
        <trans-unit id="41318cc8f100d4675dfe14fffade93d0c7208044" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;tabulated-list-gui-sort-indicator-asc&lt;/code&gt;, but used for text-mode frames.</source>
          <target state="translated">마찬가지로 &lt;code&gt;tabulated-list-gui-sort-indicator-asc&lt;/code&gt; 하지만, 텍스트 모드 프레임에 사용.</target>
        </trans-unit>
        <trans-unit id="e26f9bf4e17c8b8a9b3a88b07dbaf00921a8ff2b" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;tabulated-list-gui-sort-indicator-asc&lt;/code&gt;, but used when the column is sorted in the descending order.</source>
          <target state="translated">마찬가지로 &lt;code&gt;tabulated-list-gui-sort-indicator-asc&lt;/code&gt; 열이 내림차순으로 정렬 할 때,하지만 사용.</target>
        </trans-unit>
        <trans-unit id="ac75f39d714deb46e7cfbb9da2b8004c0b4dd120" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;tabulated-list-tty-sort-indicator-asc&lt;/code&gt;, but used when the column is sorted in the descending order.</source>
          <target state="translated">마찬가지로 &lt;code&gt;tabulated-list-tty-sort-indicator-asc&lt;/code&gt; 열이 내림차순으로 정렬 할 때,하지만 사용.</target>
        </trans-unit>
        <trans-unit id="83baebd26ca9a920629b6b8881f71882e191e292" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;this-command-keys&lt;/code&gt;, except that it always returns the events in a vector, so you don&amp;rsquo;t need to deal with the complexities of storing input events in a string (see &lt;a href=&quot;strings-of-events#Strings-of-Events&quot;&gt;Strings of Events&lt;/a&gt;).</source>
          <target state="translated">마찬가지로 &lt;code&gt;this-command-keys&lt;/code&gt; , 당신은 문자열의 입력 이벤트를 저장의 복잡성을 처리 할 필요가 없습니다 항상, 벡터에서 이벤트를 반환하는 것을 제외하고 (참조 &lt;a href=&quot;strings-of-events#Strings-of-Events&quot;&gt;이벤트의 문자열&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2a77e33ddaa024bcb7e1de6d16b70822ff2b74e0" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;utime&lt;/code&gt;, &lt;code&gt;stime&lt;/code&gt;, and &lt;code&gt;time&lt;/code&gt;, but include the times of all the child processes of the given process.</source>
          <target state="translated">마찬가지로 &lt;code&gt;utime&lt;/code&gt; 와 , &lt;code&gt;stime&lt;/code&gt; 및 &lt;code&gt;time&lt;/code&gt; 만 주어진 프로세스의 모든 자식 프로세스의 시간을 포함한다.</target>
        </trans-unit>
        <trans-unit id="264fb3dd5c5a9c6df032cdd8b67cc032c5141d77" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;vertical-motion&lt;/code&gt;, &lt;code&gt;count-screen-lines&lt;/code&gt; always uses the current buffer, regardless of which buffer is displayed in &lt;var&gt;window&lt;/var&gt;. This makes possible to use &lt;code&gt;count-screen-lines&lt;/code&gt; in any buffer, whether or not it is currently displayed in some window.</source>
          <target state="translated">마찬가지로 &lt;code&gt;vertical-motion&lt;/code&gt; , &lt;code&gt;count-screen-lines&lt;/code&gt; 항상 어느 버퍼 표시에 관계없이, 현재의 버퍼를 사용 &lt;var&gt;window&lt;/var&gt; . 이렇게하면 현재 일부 창에 표시되는지 여부에 관계없이 모든 버퍼에서 &lt;code&gt;count-screen-lines&lt;/code&gt; 을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d2cce2deecdcf8cf23c34bb65bc484d84587588" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;y-or-n-p&lt;/code&gt;, except that if the user fails to answer within &lt;var&gt;seconds&lt;/var&gt; seconds, this function stops waiting and returns &lt;var&gt;default&lt;/var&gt;. It works by setting up a timer; see &lt;a href=&quot;timers#Timers&quot;&gt;Timers&lt;/a&gt;. The argument &lt;var&gt;seconds&lt;/var&gt; should be a number.</source>
          <target state="translated">마찬가지로 &lt;code&gt;y-or-n-p&lt;/code&gt; , 것을 제외하고 사용자는 내 대답에 실패 할 경우 &lt;var&gt;seconds&lt;/var&gt; 이 기능은 대기 및 반환 중지, 초 &lt;var&gt;default&lt;/var&gt; . 타이머를 설정하여 작동합니다. &lt;a href=&quot;timers#Timers&quot;&gt;타이머를&lt;/a&gt; 참조하십시오 . &lt;var&gt;seconds&lt;/var&gt; 인수 는 숫자 여야합니다.</target>
        </trans-unit>
        <trans-unit id="42d3bb0dd219a8f3377a5d7dfc35b9c093371501" translate="yes" xml:space="preserve">
          <source>Like a buffer, a string can contain text properties for the characters in it, as well as the characters themselves. See &lt;a href=&quot;text-properties#Text-Properties&quot;&gt;Text Properties&lt;/a&gt;. All the Lisp primitives that copy text from strings to buffers or other strings also copy the properties of the characters being copied.</source>
          <target state="translated">버퍼와 마찬가지로 문자열은 문자 자체뿐 아니라 문자에 대한 텍스트 속성을 포함 할 수 있습니다. &lt;a href=&quot;text-properties#Text-Properties&quot;&gt;텍스트 속성을&lt;/a&gt; 참조하십시오 . 문자열에서 버퍼 또는 다른 문자열로 텍스트를 복사하는 모든 Lisp 프리미티브는 복사되는 문자의 속성도 복사합니다.</target>
        </trans-unit>
        <trans-unit id="a8a6416bd2f6413e3de422a7bab6e772fb8419cd" translate="yes" xml:space="preserve">
          <source>Like a mode line, but at the top.</source>
          <target state="translated">모드 라인과 같지만 맨 위에 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea6efe0718530791d43dbe7d53bb5a14e1b67ed8" translate="yes" xml:space="preserve">
          <source>Like abbrevs, abbrev tables have properties, some of which influence the way they work. You can provide them as arguments to &lt;code&gt;define-abbrev-table&lt;/code&gt;, and manipulate them with the functions:</source>
          <target state="translated">약어와 마찬가지로 약어 테이블에는 속성이 있으며 그 중 일부는 작동 방식에 영향을줍니다. 이를 &lt;code&gt;define-abbrev-table&lt;/code&gt; 에 대한 인수로 제공하고 함수로 조작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44ec097d5bc177ce9f85e7d020e50ae88d2f91c4" translate="yes" xml:space="preserve">
          <source>Like any application, Emacs can be run in a secure environment, where the operating system enforces rules about access and the like. With some care, Emacs-based applications can also be part of a security perimeter that checks such rules. Although the default settings for Emacs work well for a typical software development environment, they may require adjustment in environments containing untrusted users that may include attackers. Here is a compendium of security issues that may be helpful if you are developing such applications. It is by no means complete; it is intended to give you an idea of the security issues involved, rather than to be a security checklist.</source>
          <target state="translated">다른 응용 프로그램과 마찬가지로 Emacs는 운영 체제가 액세스 등에 대한 규칙을 적용하는 안전한 환경에서 실행될 수 있습니다. 주의를 기울이면 Emacs 기반 응용 프로그램은 이러한 규칙을 확인하는 보안 경계의 일부가 될 수도 있습니다. Emacs의 기본 설정은 일반적인 소프트웨어 개발 환경에서 잘 작동하지만 공격자가 포함될 수있는 신뢰할 수없는 사용자가 포함 된 환경에서는 조정이 필요할 수 있습니다. 다음은 이러한 응용 프로그램을 개발하는 경우 도움이 될 수있는 보안 문제의 개요입니다. 결코 완전하지 않습니다. 보안 체크리스트가 아니라 관련된 보안 문제에 대한 아이디어를 제공하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="64697998797f77574ca5b12fc923c577aecf3e58" translate="yes" xml:space="preserve">
          <source>Like any marker, this marker can be set to point at any buffer you like. If you make it point at any buffer other than the one of which it is the mark, it will yield perfectly consistent, but rather odd, results. We recommend that you not do it!</source>
          <target state="translated">다른 마커와 마찬가지로이 마커는 원하는 버퍼를 가리 키도록 설정할 수 있습니다. 마크가있는 버퍼가 아닌 다른 버퍼를 가리 키도록하면 완벽하게 일관되지만 다소 이상한 결과를 얻을 수 있습니다. 하지 않는 것이 좋습니다!</target>
        </trans-unit>
        <trans-unit id="1e30ff33c9d97dd95ea9111da199e049a900cc43" translate="yes" xml:space="preserve">
          <source>Like other arrays, vectors use zero-origin indexing: the first element has index 0.</source>
          <target state="translated">다른 배열과 마찬가지로 벡터는 제로 원점 인덱싱을 사용합니다. 첫 번째 요소에는 인덱스 0이 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd4fbae429af14d7410a0be5944198b140179fb1" translate="yes" xml:space="preserve">
          <source>Like other buffers, a minibuffer uses a local keymap (see &lt;a href=&quot;keymaps#Keymaps&quot;&gt;Keymaps&lt;/a&gt;) to specify special key bindings. The function that invokes the minibuffer also sets up its local map according to the job to be done. See &lt;a href=&quot;text-from-minibuffer#Text-from-Minibuffer&quot;&gt;Text from Minibuffer&lt;/a&gt;, for the non-completion minibuffer local maps. See &lt;a href=&quot;completion-commands#Completion-Commands&quot;&gt;Completion Commands&lt;/a&gt;, for the minibuffer local maps for completion.</source>
          <target state="translated">다른 버퍼처럼 미니 버퍼는 (참조 로컬 키 맵 사용 &lt;a href=&quot;keymaps#Keymaps&quot;&gt;키맵&lt;/a&gt; 특수 키 바인딩을 지정 참조). 미니 버퍼를 호출하는 함수는 수행 할 작업에 따라 로컬 맵도 설정합니다. 완료되지 않은 &lt;a href=&quot;text-from-minibuffer#Text-from-Minibuffer&quot;&gt;미니 버퍼&lt;/a&gt; 로컬 맵 은 미니 버퍼의 텍스트를 참조하십시오 . &lt;a href=&quot;completion-commands#Completion-Commands&quot;&gt;완성을&lt;/a&gt; 위한 미니 버퍼 로컬 맵 은 Completion Commands를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b2ee97c7efba6f620110611b5db71717d51e8ddb" translate="yes" xml:space="preserve">
          <source>Like other positions, point designates a place between two characters (or before the first character, or after the last character), rather than a particular character. Usually terminals display the cursor over the character that immediately follows point; point is actually before the character on which the cursor sits.</source>
          <target state="translated">다른 위치와 마찬가지로 포인트는 특정 문자가 아닌 두 문자 사이 (또는 첫 번째 문자 앞 또는 마지막 문자 뒤)를 지정합니다. 일반적으로 터미널은 포인트 바로 뒤에 오는 문자 위에 커서를 표시합니다. point는 실제로 커서가있는 문자 앞에 있습니다.</target>
        </trans-unit>
        <trans-unit id="8da9a43aec4137b9ff967ca13c1bd7372e6ad639" translate="yes" xml:space="preserve">
          <source>Like the &lt;code&gt;and&lt;/code&gt; construct, &lt;code&gt;or&lt;/code&gt; can be written in terms of &lt;code&gt;cond&lt;/code&gt;. For example:</source>
          <target state="translated">&lt;code&gt;and&lt;/code&gt; 구문 처럼 &lt;code&gt;or&lt;/code&gt; &lt;code&gt;cond&lt;/code&gt; 로 쓸 수 있습니다 . 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="a93ae83163cf6a8ddec90d055956fb5025562919" translate="yes" xml:space="preserve">
          <source>Like the menu bar, the tool bar (see &lt;a href=&quot;tool-bar#Tool-Bar&quot;&gt;Tool Bar&lt;/a&gt;) can be either internal (drawn by Emacs itself) or external (drawn by a toolkit). The GTK+ and NS builds have the tool bar drawn by the toolkit. The remaining builds use internal tool bars. With GTK+ the tool bar can be located on either side of the frame, immediately outside the internal border, see below. Tool bars are usually not shown for child frames (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;). Display of the tool bar can be suppressed by setting the &lt;code&gt;tool-bar-lines&lt;/code&gt; parameter (see &lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;Layout Parameters&lt;/a&gt;) to zero.</source>
          <target state="translated">메뉴 바처럼, 도구 모음 (참고 &lt;a href=&quot;tool-bar#Tool-Bar&quot;&gt;도구 바&lt;/a&gt; ) 중 내부 또는 (툴킷에 의해 그려진) 외부 (이맥스 자체에 의해 그려진)이 될 수 있습니다. GTK + 및 NS 빌드에는 툴킷에 의해 그려진 도구 모음이 있습니다. 나머지 빌드는 내부 도구 모음을 사용합니다. GTK +를 사용하면 도구 모음을 프레임의 양쪽, 내부 테두리 바로 바깥쪽에 배치 할 수 있습니다 (아래 참조). 일반적으로 하위 프레임에는 도구 모음이 표시되지 않습니다 ( &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;하위 프레임&lt;/a&gt; 참조 ). &lt;code&gt;tool-bar-lines&lt;/code&gt; 매개 변수 ( &lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;레이아웃 매개 변수&lt;/a&gt; 참조 )를 0 으로 설정하여 도구 모음 표시를 억제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fda771ab560862777893dc0b295d979a9763ad74" translate="yes" xml:space="preserve">
          <source>Like the menu bar, the tool bar can display separators (see &lt;a href=&quot;menu-separators#Menu-Separators&quot;&gt;Menu Separators&lt;/a&gt;). Tool bar separators are vertical rather than horizontal, though, and only a single style is supported. They are represented in the tool bar keymap by &lt;code&gt;(menu-item &quot;--&quot;)&lt;/code&gt; entries; properties like &lt;code&gt;:visible&lt;/code&gt; are not supported for tool bar separators. Separators are rendered natively in GTK+ and Nextstep tool bars; in the other cases, they are rendered using an image of a vertical line.</source>
          <target state="translated">메뉴 모음과 마찬가지로 도구 모음은 구분 기호를 표시 할 수 있습니다 ( &lt;a href=&quot;menu-separators#Menu-Separators&quot;&gt;메뉴 구분 기호&lt;/a&gt; 참조 ). 도구 모음 구분 기호는 수평이 아닌 수직이며 단일 스타일 만 지원됩니다. 도구 모음 키맵에서 &lt;code&gt;(menu-item &quot;--&quot;)&lt;/code&gt; 항목으로 표시됩니다. &lt;code&gt;:visible&lt;/code&gt; 과 같은 속성 은 도구 모음 구분 기호에 지원되지 않습니다. 구분자는 GTK + 및 Nextstep 도구 모음에서 기본적으로 렌더링됩니다. 다른 경우에는 수직선 이미지를 사용하여 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="9df33e5d8f7b38be89f4b568592a838f25636c81" translate="yes" xml:space="preserve">
          <source>Like the standard &lt;code&gt;backref&lt;/code&gt; construct, but &lt;var&gt;ref&lt;/var&gt; can here also be a name introduced by a previous &lt;code&gt;(let &lt;var&gt;ref&lt;/var&gt; &amp;hellip;)&lt;/code&gt; construct.</source>
          <target state="translated">표준 &lt;code&gt;backref&lt;/code&gt; 구문과 비슷하지만 여기서 &lt;var&gt;ref&lt;/var&gt; 는 이전 &lt;code&gt;(let &lt;var&gt;ref&lt;/var&gt; &amp;hellip;)&lt;/code&gt; 구문에서 소개 된 이름 일 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6121daf0fb6ccba2fa0baef96baeb4b4791c43e3" translate="yes" xml:space="preserve">
          <source>Likewise, &lt;code&gt;save-excursion&lt;/code&gt; does not restore window-buffer correspondences altered by functions such as &lt;code&gt;switch-to-buffer&lt;/code&gt;.</source>
          <target state="translated">마찬가지로 &lt;code&gt;save-excursion&lt;/code&gt; 은 &lt;code&gt;switch-to-buffer&lt;/code&gt; 와 같은 기능에 의해 변경된 창 버퍼 대응을 복원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="86ef385a59e33cf483e8dded5ef79cc70f792473" translate="yes" xml:space="preserve">
          <source>Likewise, for handling the three types of remote contacts (requests, notifications, and responses to local requests), the transport implementation must arrange for the function &lt;code&gt;jsonrpc-connection-receive&lt;/code&gt; to be called after noticing a new JSONRPC message on the wire (whatever that &quot;wire&quot; may be).</source>
          <target state="translated">마찬가지로, 세 가지 유형의 원격 연락처 (요청, 알림 및 로컬 요청에 대한 응답)를 처리하기 위해 전송 구현은 새 JSONRPC 메시지를 확인한 후 호출되도록 &lt;code&gt;jsonrpc-connection-receive&lt;/code&gt; 함수를 정렬해야합니다 ( &quot;와이어&quot;가 될 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="0f76d8acf641d878dd8f95ce0cf81e2a38f35161" translate="yes" xml:space="preserve">
          <source>Likewise, for scrolling up. The value, &lt;var&gt;f&lt;/var&gt;, specifies how far point should be placed from the bottom of the window; thus, as with &lt;code&gt;scroll-down-aggressively&lt;/code&gt;, a larger value scrolls more aggressively.</source>
          <target state="translated">마찬가지로 위로 스크롤합니다. 값 &lt;var&gt;f&lt;/var&gt; 는 창 하단에서 포인트를 얼마나 멀리 배치해야하는지 지정합니다. 따라서 &lt;code&gt;scroll-down-aggressively&lt;/code&gt; 와 마찬가지로 값이 클수록 더 공격적으로 스크롤됩니다.</target>
        </trans-unit>
        <trans-unit id="9173a7576ab9406f8159ed0ad696d18cf5a5de55" translate="yes" xml:space="preserve">
          <source>Likewise, to move to the end of the buffer, use:</source>
          <target state="translated">마찬가지로 버퍼의 끝으로 이동하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="607bc37fe36f1db5f0eedea396370eb624c4e6e9" translate="yes" xml:space="preserve">
          <source>Likewise, you can suppress the warning for a specific use of a variable &lt;var&gt;variable&lt;/var&gt; by conditionalizing it on a &lt;code&gt;boundp&lt;/code&gt; test:</source>
          <target state="translated">마찬가지로, &lt;code&gt;boundp&lt;/code&gt; 테스트 에서 조건화 하여 변수 &lt;var&gt;variable&lt;/var&gt; 의 특정 사용에 대한 경고를 억제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6c62e4ab3dbe05f042adec9ffbc82e4cfec79087" translate="yes" xml:space="preserve">
          <source>Likewise, you can tell the compiler that a variable is defined using &lt;code&gt;defvar&lt;/code&gt; with no initial value. (Note that this marks the variable as special, i.e. dynamically bound, but only within the current lexical scope, or file if at top-level.) See &lt;a href=&quot;defining-variables#Defining-Variables&quot;&gt;Defining Variables&lt;/a&gt;.</source>
          <target state="translated">마찬가지로 변수가 초기 값없이 &lt;code&gt;defvar&lt;/code&gt; 를 사용하여 정의되었음을 컴파일러에 알릴 수 있습니다 . (이것은 변수를 특별하게 표시합니다. 즉, 동적으로 바인딩되지만 현재 어휘 범위 또는 최상위 수준 인 경우 파일 내에서만 가능합니다.) &lt;a href=&quot;defining-variables#Defining-Variables&quot;&gt;변수 정의를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="4b7070c9a5c61e5ad4b904c57e944895659357fd" translate="yes" xml:space="preserve">
          <source>Line 1 &amp;ldquo;factors out&amp;rdquo; the &lt;var&gt;expval&lt;/var&gt; binding with &lt;code&gt;and&lt;/code&gt; and &lt;var&gt;symbol&lt;/var&gt; (in this case, &lt;code&gt;num&lt;/code&gt;). On line 2, &lt;code&gt;or&lt;/code&gt; begins in the same way as before, but instead of binding different symbols, uses &lt;code&gt;let&lt;/code&gt; twice (lines 3-4) to bind the same symbol &lt;code&gt;spin&lt;/code&gt; in both sub-patterns. The value of &lt;code&gt;spin&lt;/code&gt; distinguishes the sub-patterns. The body form references both symbols (line 5).</source>
          <target state="translated">라인 1 은 &lt;code&gt;and&lt;/code&gt; 및 &lt;var&gt;symbol&lt;/var&gt; (이 경우 &lt;code&gt;num&lt;/code&gt; )를 사용 하여 &lt;var&gt;expval&lt;/var&gt; 바인딩을 &quot;인수 처리&quot;합니다 . 2 행에서 &lt;code&gt;or&lt;/code&gt; 이전과 동일한 방식으로 시작하지만 다른 기호를 바인딩하는 대신 &lt;code&gt;let&lt;/code&gt; 두 번 (3-4 행)을 사용 하여 두 하위 패턴에서 동일한 기호 &lt;code&gt;spin&lt;/code&gt; 을 바인딩합니다 . &lt;code&gt;spin&lt;/code&gt; 의 값은 하위 패턴을 구별합니다. 본문 양식은 두 기호를 모두 참조합니다 (5 행).</target>
        </trans-unit>
        <trans-unit id="ac3292c1d1364f8eb7cb1cb73de1b6c6819f007a" translate="yes" xml:space="preserve">
          <source>Line Height</source>
          <target state="translated">라인 높이</target>
        </trans-unit>
        <trans-unit id="d19fdad54534f671523b6ba91167c0a2af1211e8" translate="yes" xml:space="preserve">
          <source>Link to a file; &lt;var&gt;file&lt;/var&gt; is a string which specifies the name of the file to visit with &lt;code&gt;find-file&lt;/code&gt; when the user invokes this link.</source>
          <target state="translated">파일에 연결; &lt;var&gt;file&lt;/var&gt; 은 사용자가이 링크를 호출 할 때 &lt;code&gt;find-file&lt;/code&gt; 로 방문 할 파일의 이름을 지정하는 문자열입니다 .</target>
        </trans-unit>
        <trans-unit id="22480f8e64b100d948600dc541fbe87fd12cf0ad" translate="yes" xml:space="preserve">
          <source>Link to a web page; &lt;var&gt;url&lt;/var&gt; is a string which specifies the</source>
          <target state="translated">웹 페이지에 연결; &lt;var&gt;url&lt;/var&gt; 은</target>
        </trans-unit>
        <trans-unit id="6196a47a6fade23ecdb0cf7553070cfc1f4b67e9" translate="yes" xml:space="preserve">
          <source>Link to an Emacs Lisp library file; &lt;var&gt;library&lt;/var&gt; is a string which specifies the library name.</source>
          <target state="translated">Emacs Lisp 라이브러리 파일에 연결합니다. &lt;var&gt;library&lt;/var&gt; 는 라이브러리 이름을 지정하는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="bf66ba2266e555d89a7551e84cff8291754f5ac7" translate="yes" xml:space="preserve">
          <source>Link to an Info node; &lt;var&gt;info-node&lt;/var&gt; is a string which specifies the node name, as in &lt;code&gt;&quot;(emacs)Top&quot;&lt;/code&gt;. The link appears as &amp;lsquo;</source>
          <target state="translated">정보 노드에 연결합니다. &lt;var&gt;info-node&lt;/var&gt; 는 &lt;code&gt;&quot;(emacs)Top&quot;&lt;/code&gt; 에서와 같이 노드 이름을 지정하는 문자열입니다 . 링크는 '</target>
        </trans-unit>
        <trans-unit id="0d9e752b2010ff1455dafc24361a10db156301e1" translate="yes" xml:space="preserve">
          <source>Link to another customization group. Invoking it creates a new customization buffer for &lt;var&gt;group&lt;/var&gt;.</source>
          <target state="translated">다른 사용자 지정 그룹에 연결합니다. 호출하면 &lt;var&gt;group&lt;/var&gt; 에 대한 새 사용자 정의 버퍼가 생성 됩니다.</target>
        </trans-unit>
        <trans-unit id="8c73b95e12ba7b48400412835847598d2b4297a9" translate="yes" xml:space="preserve">
          <source>Link to the commentary section of a library; &lt;var&gt;library&lt;/var&gt; is a string which specifies the library name. See &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/elisp/Library-Headers.html#Library-Headers&quot;&gt;Library Headers&lt;/a&gt;.</source>
          <target state="translated">도서관의 해설 섹션으로 연결; &lt;var&gt;library&lt;/var&gt; 는 라이브러리 이름을 지정하는 문자열입니다. &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/elisp/Library-Headers.html#Library-Headers&quot;&gt;라이브러리 헤더를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0af47038ac7d2a137e5fb0843704c0a217bb19fe" translate="yes" xml:space="preserve">
          <source>Link to the documentation of a function; &lt;var&gt;function&lt;/var&gt; is a string which specifies the name of the function to describe with &lt;code&gt;describe-function&lt;/code&gt; when the user invokes this link.</source>
          <target state="translated">함수 문서에 대한 링크; &lt;var&gt;function&lt;/var&gt; 은 사용자가이 링크를 호출 할 때 &lt;code&gt;describe-function&lt;/code&gt; 으로 설명 할 함수의 이름을 지정하는 문자열입니다 .</target>
        </trans-unit>
        <trans-unit id="6004ab0c17b773b21124a13a049a164c20095e5e" translate="yes" xml:space="preserve">
          <source>Link to the documentation of a variable; &lt;var&gt;variable&lt;/var&gt; is a string which specifies the name of the variable to describe with &lt;code&gt;describe-variable&lt;/code&gt; when the user invokes this link.</source>
          <target state="translated">변수 문서에 대한 링크; &lt;var&gt;variable&lt;/var&gt; 은 사용자가이 링크를 호출 할 때 &lt;code&gt;describe-variable&lt;/code&gt; 로 설명 할 변수의 이름을 지정하는 문자열입니다 .</target>
        </trans-unit>
        <trans-unit id="11b92badcf27d4b637951157332f5903e3a51659" translate="yes" xml:space="preserve">
          <source>Links to the preceding and following nodes in the chain.</source>
          <target state="translated">체인의 이전 및 다음 노드에 대한 링크입니다.</target>
        </trans-unit>
        <trans-unit id="a7518b7d8d9c8b8ab73ff878b6f9268c622af85d" translate="yes" xml:space="preserve">
          <source>Lisp (LISt Processing language) was first developed in the late 1950s at the Massachusetts Institute of Technology for research in artificial intelligence. The great power of the Lisp language makes it ideal for other purposes as well, such as writing editing commands.</source>
          <target state="translated">Lisp (LISt 처리 언어)는 인공 지능 연구를 위해 1950 년대 후반 매사추세츠 공과 대학에서 처음 개발되었습니다. Lisp 언어의 강력한 힘은 편집 명령 작성과 같은 다른 목적에도 이상적입니다.</target>
        </trans-unit>
        <trans-unit id="093033f3ad1baf1e960c639480ab203cf9eefb80" translate="yes" xml:space="preserve">
          <source>Lisp Data Types</source>
          <target state="translated">Lisp 데이터 유형</target>
        </trans-unit>
        <trans-unit id="070300a2d38e695ab5e6b29fde3619a0ca2a902e" translate="yes" xml:space="preserve">
          <source>Lisp History</source>
          <target state="translated">Lisp 역사</target>
        </trans-unit>
        <trans-unit id="a95ae648eeb012f8070dcb15c34e598757cc1931" translate="yes" xml:space="preserve">
          <source>Lisp Macro Evaluation</source>
          <target state="translated">Lisp 매크로 평가</target>
        </trans-unit>
        <trans-unit id="0e410e687183103929a8880a76ed05ea40533c7d" translate="yes" xml:space="preserve">
          <source>Lisp code should use this function instead of &lt;code&gt;buffer-substring&lt;/code&gt;, &lt;code&gt;buffer-substring-no-properties&lt;/code&gt;, or &lt;code&gt;delete-and-extract-region&lt;/code&gt; when copying into user-accessible data structures such as the kill-ring, X clipboard, and registers. Major and minor modes can modify &lt;code&gt;filter-buffer-substring-function&lt;/code&gt; to alter such text as it is copied out of the buffer.</source>
          <target state="translated">Lisp 코드는 kill-ring, X 클립 보드 및 레지스터와 같은 사용자 액세스 가능한 데이터 구조에 복사 할 때 &lt;code&gt;buffer-substring&lt;/code&gt; , &lt;code&gt;buffer-substring-no-properties&lt;/code&gt; 또는 &lt;code&gt;delete-and-extract-region&lt;/code&gt; 대신이 함수를 사용해야합니다 . 메이저 및 마이너 모드는 &lt;code&gt;filter-buffer-substring-function&lt;/code&gt; 을 수정하여 버퍼에서 복사되는 텍스트를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8fc5a9e95ef7885a0b7599ee4ecbaf851f92a696" translate="yes" xml:space="preserve">
          <source>Lisp expression:</source>
          <target state="translated">Lisp 표현 :</target>
        </trans-unit>
        <trans-unit id="9a49e6726f59e36c724f79f5510e315b850a89a9" translate="yes" xml:space="preserve">
          <source>Lisp expressions for defining functions.</source>
          <target state="translated">함수 정의를위한 Lisp 표현식.</target>
        </trans-unit>
        <trans-unit id="04c1aa53f54116c8c2b6559a2f7db15e028716fc" translate="yes" xml:space="preserve">
          <source>Lisp functions are executable code, just like functions in other programming languages. In Lisp, unlike most languages, functions are also Lisp objects. A non-compiled function in Lisp is a lambda expression: that is, a list whose first element is the symbol &lt;code&gt;lambda&lt;/code&gt; (see &lt;a href=&quot;lambda-expressions#Lambda-Expressions&quot;&gt;Lambda Expressions&lt;/a&gt;).</source>
          <target state="translated">Lisp functions are executable code, just like functions in other programming languages. In Lisp, unlike most languages, functions are also Lisp objects. A non-compiled function in Lisp is a lambda expression: that is, a list whose first element is the symbol &lt;code&gt;lambda&lt;/code&gt; (see &lt;a href=&quot;lambda-expressions#Lambda-Expressions&quot;&gt;Lambda Expressions&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="48b47c25285835ef4229cdb4249b0b97f8b61318" translate="yes" xml:space="preserve">
          <source>Lisp functions vs. primitives; terminology.</source>
          <target state="translated">Lisp functions vs. primitives; terminology.</target>
        </trans-unit>
        <trans-unit id="b7f5a1d65c1925ee62d77c064437066c7e060879" translate="yes" xml:space="preserve">
          <source>Lisp is unlike many other languages in that its objects are &lt;em&gt;self-typing&lt;/em&gt;: the primitive type of each object is implicit in the object itself. For example, if an object is a vector, nothing can treat it as a number; Lisp knows it is a vector, not a number.</source>
          <target state="translated">Lisp is unlike many other languages in that its objects are &lt;em&gt;self-typing&lt;/em&gt;: the primitive type of each object is implicit in the object itself. For example, if an object is a vector, nothing can treat it as a number; Lisp knows it is a vector, not a number.</target>
        </trans-unit>
        <trans-unit id="c1a44c55700efa37938155d19ec6cee2495bb14b" translate="yes" xml:space="preserve">
          <source>Lisp macro objects are usually defined with the built-in &lt;code&gt;defmacro&lt;/code&gt; macro, but any list that begins with &lt;code&gt;macro&lt;/code&gt; is a macro as far as Emacs is concerned. See &lt;a href=&quot;macros#Macros&quot;&gt;Macros&lt;/a&gt;, for an explanation of how to write a macro.</source>
          <target state="translated">Lisp macro objects are usually defined with the built-in &lt;code&gt;defmacro&lt;/code&gt; macro, but any list that begins with &lt;code&gt;macro&lt;/code&gt; is a macro as far as Emacs is concerned. See &lt;a href=&quot;macros#Macros&quot;&gt;Macros&lt;/a&gt;, for an explanation of how to write a macro.</target>
        </trans-unit>
        <trans-unit id="d9a34bc15715c9484c3c6d58e0cfbe37f7e5fc6d" translate="yes" xml:space="preserve">
          <source>Lisp objects can refer to themselves. Printing a self-referential object in the normal way would require an infinite amount of text, and the attempt could cause infinite recursion. Emacs detects such recursion and prints &amp;lsquo;</source>
          <target state="translated">Lisp objects can refer to themselves. Printing a self-referential object in the normal way would require an infinite amount of text, and the attempt could cause infinite recursion. Emacs detects such recursion and prints &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="38cb61435a14d84b4e828f9b902cd652a45bb04e" translate="yes" xml:space="preserve">
          <source>Lisp packages that load files of customizations, or any other sort of user profile, should obey this variable in deciding where to find it. They should load the profile of the user name found in this variable. If &lt;code&gt;init-file-user&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;, meaning that the &amp;lsquo;</source>
          <target state="translated">Lisp packages that load files of customizations, or any other sort of user profile, should obey this variable in deciding where to find it. They should load the profile of the user name found in this variable. If &lt;code&gt;init-file-user&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt; , meaning that the &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="d96f39c620264ffeb78deb4cecb038146b82aebf" translate="yes" xml:space="preserve">
          <source>Lisp primitives are Lisp functions implemented in C. The details of interfacing the C function so that Lisp can call it are handled by a few C macros. The only way to really understand how to write new C code is to read the source, but we can explain some things here.</source>
          <target state="translated">Lisp primitives are Lisp functions implemented in C. The details of interfacing the C function so that Lisp can call it are handled by a few C macros. The only way to really understand how to write new C code is to read the source, but we can explain some things here.</target>
        </trans-unit>
        <trans-unit id="a7c856d0fff164a7f1d6af49754ec372f5744350" translate="yes" xml:space="preserve">
          <source>Lisp programs can also directly display a bitmap in the left or right fringe, by using a &lt;code&gt;display&lt;/code&gt; property for one of the characters appearing in the line (see &lt;a href=&quot;other-display-specs#Other-Display-Specs&quot;&gt;Other Display Specs&lt;/a&gt;). Such a display specification has the form</source>
          <target state="translated">Lisp programs can also directly display a bitmap in the left or right fringe, by using a &lt;code&gt;display&lt;/code&gt; property for one of the characters appearing in the line (see &lt;a href=&quot;other-display-specs#Other-Display-Specs&quot;&gt;Other Display Specs&lt;/a&gt;). Such a display specification has the form</target>
        </trans-unit>
        <trans-unit id="70a68430b5ee6f5c63e455e63af6968f951de310" translate="yes" xml:space="preserve">
          <source>Lisp programs can listen for connections by creating network servers. A network server is also represented by a kind of process object, but unlike a network connection, the network server never transfers data itself. When it receives a connection request, it creates a new network connection to represent the connection just made. (The network connection inherits certain information, including the process plist, from the server.) The network server then goes back to listening for more connection requests.</source>
          <target state="translated">Lisp programs can listen for connections by creating network servers. A network server is also represented by a kind of process object, but unlike a network connection, the network server never transfers data itself. When it receives a connection request, it creates a new network connection to represent the connection just made. (The network connection inherits certain information, including the process plist, from the server.) The network server then goes back to listening for more connection requests.</target>
        </trans-unit>
        <trans-unit id="eb25bc2c53938daa0a10ceee8670460ef857ca05" translate="yes" xml:space="preserve">
          <source>Lisp programs can set &lt;code&gt;transient-mark-mode&lt;/code&gt; to non-&lt;code&gt;nil&lt;/code&gt;, non-&lt;code&gt;t&lt;/code&gt; values to enable Transient Mark mode temporarily. If the value is &lt;code&gt;lambda&lt;/code&gt;, Transient Mark mode is automatically turned off after any action, such as buffer modification, that would normally deactivate the mark. If the value is &lt;code&gt;(only&amp;nbsp;.&amp;nbsp;&lt;var&gt;oldval&lt;/var&gt;)&lt;/code&gt;, then &lt;code&gt;transient-mark-mode&lt;/code&gt; is set to the value &lt;var&gt;oldval&lt;/var&gt; after any subsequent command that moves point and is not shift-translated (see &lt;a href=&quot;key-sequence-input#Key-Sequence-Input&quot;&gt;shift-translation&lt;/a&gt;), or after any other action that would normally deactivate the mark.</source>
          <target state="translated">Lisp programs can set &lt;code&gt;transient-mark-mode&lt;/code&gt; to non- &lt;code&gt;nil&lt;/code&gt; , non- &lt;code&gt;t&lt;/code&gt; values to enable Transient Mark mode temporarily. If the value is &lt;code&gt;lambda&lt;/code&gt; , Transient Mark mode is automatically turned off after any action, such as buffer modification, that would normally deactivate the mark. If the value is &lt;code&gt;(only&amp;nbsp;.&amp;nbsp;&lt;var&gt;oldval&lt;/var&gt;)&lt;/code&gt; , then &lt;code&gt;transient-mark-mode&lt;/code&gt; is set to the value &lt;var&gt;oldval&lt;/var&gt; after any subsequent command that moves point and is not shift-translated (see &lt;a href=&quot;key-sequence-input#Key-Sequence-Input&quot;&gt;shift-translation&lt;/a&gt;), or after any other action that would normally deactivate the mark.</target>
        </trans-unit>
        <trans-unit id="3aa64bd9d4a4db969c3909de23bb8e7a8d6e781d" translate="yes" xml:space="preserve">
          <source>Lisp programs can switch frames temporarily by calling the function &lt;code&gt;select-frame&lt;/code&gt;. This does not alter the window system&amp;rsquo;s concept of focus; rather, it escapes from the window manager&amp;rsquo;s control until that control is somehow reasserted.</source>
          <target state="translated">Lisp programs can switch frames temporarily by calling the function &lt;code&gt;select-frame&lt;/code&gt; . This does not alter the window system&amp;rsquo;s concept of focus; rather, it escapes from the window manager&amp;rsquo;s control until that control is somehow reasserted.</target>
        </trans-unit>
        <trans-unit id="e6266b236aa3407b98b48107324e801de224e6ad" translate="yes" xml:space="preserve">
          <source>Lisp programs must be prepared that user customizations may cause buffers to get displayed in an unexpected way. They should never assume in their subsequent behavior, that the buffer has been shown precisely the way they asked for in the &lt;var&gt;action&lt;/var&gt; argument of &lt;code&gt;display-buffer&lt;/code&gt;.</source>
          <target state="translated">Lisp programs must be prepared that user customizations may cause buffers to get displayed in an unexpected way. They should never assume in their subsequent behavior, that the buffer has been shown precisely the way they asked for in the &lt;var&gt;action&lt;/var&gt; argument of &lt;code&gt;display-buffer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6612695190dbf10d24bd3737b61d06d8dee5099f" translate="yes" xml:space="preserve">
          <source>Lisp programs should &lt;em&gt;not&lt;/em&gt; rely on hash codes being preserved between Emacs sessions, as the implementation of the hash functions uses some details of the object storage that can change between sessions and between different architectures.</source>
          <target state="translated">Lisp programs should &lt;em&gt;not&lt;/em&gt; rely on hash codes being preserved between Emacs sessions, as the implementation of the hash functions uses some details of the object storage that can change between sessions and between different architectures.</target>
        </trans-unit>
        <trans-unit id="430b9fa1fd5ba568a813aa706678d439215cf675" translate="yes" xml:space="preserve">
          <source>Lisp programs sometimes need to run a shell and give it a command that contains file names that were specified by the user. These programs ought to be able to support any valid file name. But the shell gives special treatment to certain characters, and if these characters occur in the file name, they will confuse the shell. To handle these characters, use the function &lt;code&gt;shell-quote-argument&lt;/code&gt;:</source>
          <target state="translated">Lisp programs sometimes need to run a shell and give it a command that contains file names that were specified by the user. These programs ought to be able to support any valid file name. But the shell gives special treatment to certain characters, and if these characters occur in the file name, they will confuse the shell. To handle these characters, use the function &lt;code&gt;shell-quote-argument&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cfca57d0cb6702725bd47fe954b2d8aad7ece85e" translate="yes" xml:space="preserve">
          <source>Lisp representation for character display fonts.</source>
          <target state="translated">Lisp representation for character display fonts.</target>
        </trans-unit>
        <trans-unit id="b7904939c664c0654e4069d00a64b5fe14da5051" translate="yes" xml:space="preserve">
          <source>List contains a loop</source>
          <target state="translated">List contains a loop</target>
        </trans-unit>
        <trans-unit id="3e55737f21b8d4e744eb6aa465bb3fe3e505747a" translate="yes" xml:space="preserve">
          <source>List of frame parameters for window systems.</source>
          <target state="translated">List of frame parameters for window systems.</target>
        </trans-unit>
        <trans-unit id="c1aa03bb883bbb60cce2d139f90d3fdb47174dc3" translate="yes" xml:space="preserve">
          <source>List of frames that this physical monitor dominates (see below).</source>
          <target state="translated">List of frames that this physical monitor dominates (see below).</target>
        </trans-unit>
        <trans-unit id="5255158e8775a2ebbae84ae901ff359ddfa1d8dd" translate="yes" xml:space="preserve">
          <source>List of set bits in &lt;var&gt;len&lt;/var&gt; bytes. The bytes are taken in big endian order and the bits are numbered starting with &lt;code&gt;8 *
&lt;var&gt;len&lt;/var&gt; - 1&lt;/code&gt; and ending with zero. For example: &lt;code&gt;bits
2&lt;/code&gt; unpacks &lt;code&gt;#x28&lt;/code&gt;&lt;code&gt;#x1c&lt;/code&gt; to &lt;code&gt;(2 3 4 11 13)&lt;/code&gt; and &lt;code&gt;#x1c&lt;/code&gt;&lt;code&gt;#x28&lt;/code&gt; to &lt;code&gt;(3 5 10 11 12)&lt;/code&gt;.</source>
          <target state="translated">List of set bits in &lt;var&gt;len&lt;/var&gt; bytes. The bytes are taken in big endian order and the bits are numbered starting with &lt;code&gt;8 * &lt;var&gt;len&lt;/var&gt; - 1&lt;/code&gt; and ending with zero. For example: &lt;code&gt;bits 2&lt;/code&gt; unpacks &lt;code&gt;#x28&lt;/code&gt; &lt;code&gt;#x1c&lt;/code&gt; to &lt;code&gt;(2 3 4 11 13)&lt;/code&gt; and &lt;code&gt;#x1c&lt;/code&gt; &lt;code&gt;#x28&lt;/code&gt; to &lt;code&gt;(3 5 10 11 12)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9849ac255593e53a8f74892aeb3c6148e2227ef" translate="yes" xml:space="preserve">
          <source>List of some standard error symbols.</source>
          <target state="translated">List of some standard error symbols.</target>
        </trans-unit>
        <trans-unit id="dd46ad2b3ec4905179728f23e75392d7cd255398" translate="yes" xml:space="preserve">
          <source>List of some standard hook variables.</source>
          <target state="translated">List of some standard hook variables.</target>
        </trans-unit>
        <trans-unit id="684686c9485926fd7bb605cb2b4b6557c3c1c8f3" translate="yes" xml:space="preserve">
          <source>List of some standard keymaps.</source>
          <target state="translated">List of some standard keymaps.</target>
        </trans-unit>
        <trans-unit id="57c9502a7d7d48fd4a86b45fefb2b163491c3ae1" translate="yes" xml:space="preserve">
          <source>Lists</source>
          <target state="translated">Lists</target>
        </trans-unit>
        <trans-unit id="20dd55e92ceb2d7f29cba2ee3c74cacc30b7d09c" translate="yes" xml:space="preserve">
          <source>Lists and Cons Cells</source>
          <target state="translated">Lists and Cons Cells</target>
        </trans-unit>
        <trans-unit id="95e6ae4511e2076e5ec8acc94916a3a73b48a317" translate="yes" xml:space="preserve">
          <source>Lists are the most commonly-used sequences. A list can hold elements of any type, and its length can be easily changed by adding or removing elements. See the next subsection for more about lists.</source>
          <target state="translated">Lists are the most commonly-used sequences. A list can hold elements of any type, and its length can be easily changed by adding or removing elements. See the next subsection for more about lists.</target>
        </trans-unit>
        <trans-unit id="0deb648df977bd4b3bf1acb18dcca54edca072ea" translate="yes" xml:space="preserve">
          <source>Lists in Lisp are not a primitive data type; they are built up from &lt;em&gt;cons cells&lt;/em&gt; (see &lt;a href=&quot;cons-cell-type#Cons-Cell-Type&quot;&gt;Cons Cell Type&lt;/a&gt;). A cons cell is a data object that represents an ordered pair. That is, it has two slots, and each slot &lt;em&gt;holds&lt;/em&gt;, or &lt;em&gt;refers to&lt;/em&gt;, some Lisp object. One slot is known as the &lt;small&gt;CAR&lt;/small&gt;, and the other is known as the &lt;small&gt;CDR&lt;/small&gt;. (These names are traditional; see &lt;a href=&quot;cons-cell-type#Cons-Cell-Type&quot;&gt;Cons Cell Type&lt;/a&gt;.) &lt;small&gt;CDR&lt;/small&gt; is pronounced &amp;ldquo;could-er&amp;rdquo;.</source>
          <target state="translated">Lists in Lisp are not a primitive data type; they are built up from &lt;em&gt;cons cells&lt;/em&gt; (see &lt;a href=&quot;cons-cell-type#Cons-Cell-Type&quot;&gt;Cons Cell Type&lt;/a&gt;). A cons cell is a data object that represents an ordered pair. That is, it has two slots, and each slot &lt;em&gt;holds&lt;/em&gt;, or &lt;em&gt;refers to&lt;/em&gt;, some Lisp object. One slot is known as the &lt;small&gt;CAR&lt;/small&gt;, and the other is known as the &lt;small&gt;CDR&lt;/small&gt;. (These names are traditional; see &lt;a href=&quot;cons-cell-type#Cons-Cell-Type&quot;&gt;Cons Cell Type&lt;/a&gt;.) &lt;small&gt;CDR&lt;/small&gt; is pronounced &amp;ldquo;could-er&amp;rdquo;.</target>
        </trans-unit>
        <trans-unit id="9099e49f5a4614e80a7fbc32b3b32e0c649d2edd" translate="yes" xml:space="preserve">
          <source>Lists, cons cells, and related functions.</source>
          <target state="translated">Lists, cons cells, and related functions.</target>
        </trans-unit>
        <trans-unit id="9e7aaaa88e5ccb737ed89b621f362caa5d1c2f65" translate="yes" xml:space="preserve">
          <source>Lists, strings and the other array types also share important similarities. For example, all have a length &lt;var&gt;l&lt;/var&gt;, and all have elements which can be indexed from zero to &lt;var&gt;l&lt;/var&gt; minus one. Several functions, called sequence functions, accept any kind of sequence. For example, the function &lt;code&gt;length&lt;/code&gt; reports the length of any kind of sequence. See &lt;a href=&quot;sequences-arrays-vectors#Sequences-Arrays-Vectors&quot;&gt;Sequences Arrays Vectors&lt;/a&gt;.</source>
          <target state="translated">Lists, strings and the other array types also share important similarities. For example, all have a length &lt;var&gt;l&lt;/var&gt; , and all have elements which can be indexed from zero to &lt;var&gt;l&lt;/var&gt; minus one. Several functions, called sequence functions, accept any kind of sequence. For example, the function &lt;code&gt;length&lt;/code&gt; reports the length of any kind of sequence. See &lt;a href=&quot;sequences-arrays-vectors#Sequences-Arrays-Vectors&quot;&gt;Sequences Arrays Vectors&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="c9ce88cec200da5730917cabea833810578d4d60" translate="yes" xml:space="preserve">
          <source>Lists, strings and vectors are called sequences. Certain functions act on any kind of sequence. The description of vectors is here as well.</source>
          <target state="translated">Lists, strings and vectors are called sequences. Certain functions act on any kind of sequence. The description of vectors is here as well.</target>
        </trans-unit>
        <trans-unit id="44705636b815ace7e561a7446a758c35f2dedad2" translate="yes" xml:space="preserve">
          <source>Literal text</source>
          <target state="translated">Literal text</target>
        </trans-unit>
        <trans-unit id="7561f82ae5b90f8428d596aba3af87144f94e678" translate="yes" xml:space="preserve">
          <source>Literal unprintable characters in strings.</source>
          <target state="translated">Literal unprintable characters in strings.</target>
        </trans-unit>
        <trans-unit id="c7ba7dcf662374aafe652b03d75cb8f6024519d9" translate="yes" xml:space="preserve">
          <source>Literals</source>
          <target state="translated">Literals</target>
        </trans-unit>
        <trans-unit id="bc6cc4663c2f684119734fdc2abb9c21336632c5" translate="yes" xml:space="preserve">
          <source>Living With a Weak Parser</source>
          <target state="translated">Living With a Weak Parser</target>
        </trans-unit>
        <trans-unit id="7a611ffe36f69e8659eea0f180752be7e04730b8" translate="yes" xml:space="preserve">
          <source>Load Suffixes</source>
          <target state="translated">Load Suffixes</target>
        </trans-unit>
        <trans-unit id="f9ad7c8d6bf23f4bd156133162b128490e0c6198" translate="yes" xml:space="preserve">
          <source>Load file &lt;var&gt;file&lt;/var&gt; (a string) before displaying this customization item (see &lt;a href=&quot;loading#Loading&quot;&gt;Loading&lt;/a&gt;). Loading is done with &lt;code&gt;load&lt;/code&gt;, and only if the file is not already loaded.</source>
          <target state="translated">Load file &lt;var&gt;file&lt;/var&gt; (a string) before displaying this customization item (see &lt;a href=&quot;loading#Loading&quot;&gt;Loading&lt;/a&gt;). Loading is done with &lt;code&gt;load&lt;/code&gt; , and only if the file is not already loaded.</target>
        </trans-unit>
        <trans-unit id="1bd4cd17a8147cc5cd6d3f97fd6644f944793104" translate="yes" xml:space="preserve">
          <source>Load the files with</source>
          <target state="translated">Load the files with</target>
        </trans-unit>
        <trans-unit id="883657b0663d05cb81a7f624698cafeec52f6b73" translate="yes" xml:space="preserve">
          <source>Loadable modules in Emacs are enabled by using the</source>
          <target state="translated">Loadable modules in Emacs are enabled by using the</target>
        </trans-unit>
        <trans-unit id="8f26c6520d61588a9757bc182157c4497628e871" translate="yes" xml:space="preserve">
          <source>Loading</source>
          <target state="translated">Loading</target>
        </trans-unit>
        <trans-unit id="0f84e4833a47ae5b5d6c641ba5839ef1259c6482" translate="yes" xml:space="preserve">
          <source>Loading Non-ASCII Characters</source>
          <target state="translated">Loading Non-ASCII Characters</target>
        </trans-unit>
        <trans-unit id="a881ef8a5e395de040b2cde053e1fa0f6d614659" translate="yes" xml:space="preserve">
          <source>Loading a file of Lisp code means bringing its contents into the Lisp environment in the form of Lisp objects. Emacs finds and opens the file, reads the text, evaluates each form, and then closes the file. Such a file is also called a &lt;em&gt;Lisp library&lt;/em&gt;.</source>
          <target state="translated">Loading a file of Lisp code means bringing its contents into the Lisp environment in the form of Lisp objects. Emacs finds and opens the file, reads the text, evaluates each form, and then closes the file. Such a file is also called a &lt;em&gt;Lisp library&lt;/em&gt;.</target>
        </trans-unit>
        <trans-unit id="904a9f782b30e1a58668b2173bc0b744a768d9fa" translate="yes" xml:space="preserve">
          <source>Loading a library if it isn&amp;rsquo;t already loaded.</source>
          <target state="translated">Loading a library if it isn&amp;rsquo;t already loaded.</target>
        </trans-unit>
        <trans-unit id="963c158ee7d6cc3ddeaacac290e282697c29cc98" translate="yes" xml:space="preserve">
          <source>Loading foo...</source>
          <target state="translated">Loading foo...</target>
        </trans-unit>
        <trans-unit id="90227054d0c4071b95dc470817610b24dd4cae6b" translate="yes" xml:space="preserve">
          <source>Loading foo...done</source>
          <target state="translated">Loading foo...done</target>
        </trans-unit>
        <trans-unit id="ff5148d6cff2251fbb44fa24ac71e87831f6949a" translate="yes" xml:space="preserve">
          <source>Local Variables</source>
          <target state="translated">지역 변수</target>
        </trans-unit>
        <trans-unit id="1c80e104177d7b78185bb1b8711d3cbd2a0da9a4" translate="yes" xml:space="preserve">
          <source>Local Variables in Macro Expansions</source>
          <target state="translated">Local Variables in Macro Expansions</target>
        </trans-unit>
        <trans-unit id="81e25eae5238b0d1e80b489db0e70db5d36fa19f" translate="yes" xml:space="preserve">
          <source>Local variable bindings in the expansion require special care.</source>
          <target state="translated">Local variable bindings in the expansion require special care.</target>
        </trans-unit>
        <trans-unit id="779b54ae3ad4227df0c4817bd5cf967d7971b9a8" translate="yes" xml:space="preserve">
          <source>Local variables common for remote connections.</source>
          <target state="translated">Local variables common for remote connections.</target>
        </trans-unit>
        <trans-unit id="7f188a87ee03e71d60616a4c96885d1c0b74f9c8" translate="yes" xml:space="preserve">
          <source>Local variables common to all files in a directory.</source>
          <target state="translated">Local variables common to all files in a directory.</target>
        </trans-unit>
        <trans-unit id="a222060e32289bf6910ac4a07a10733be500bd99" translate="yes" xml:space="preserve">
          <source>Locales</source>
          <target state="translated">Locales</target>
        </trans-unit>
        <trans-unit id="c40c47188d80c7c01d1f14ab9115e42654014c62" translate="yes" xml:space="preserve">
          <source>Locating Files in Standard Places</source>
          <target state="translated">Locating Files in Standard Places</target>
        </trans-unit>
        <trans-unit id="ca96bd07c69909b5097860baf11cb9da67a0b932" translate="yes" xml:space="preserve">
          <source>Locking and unlocking files, to prevent simultaneous editing by two people.</source>
          <target state="translated">Locking and unlocking files, to prevent simultaneous editing by two people.</target>
        </trans-unit>
        <trans-unit id="19b48b850743ec74aaf2ba7f74397470f9322fb8" translate="yes" xml:space="preserve">
          <source>Logging Messages in *Messages*</source>
          <target state="translated">Logging Messages in *Messages*</target>
        </trans-unit>
        <trans-unit id="f992fcdf326b78d500b906f947284b63f7afb915" translate="yes" xml:space="preserve">
          <source>Logical and, or, not, shifting.</source>
          <target state="translated">Logical and, or, not, shifting.</target>
        </trans-unit>
        <trans-unit id="5d5f34745d0c565923c156fa463ee88aafc88956" translate="yes" xml:space="preserve">
          <source>Long description</source>
          <target state="translated">Long description</target>
        </trans-unit>
        <trans-unit id="1601ce5c57967aca4f1582458112c97ae2082434" translate="yes" xml:space="preserve">
          <source>Looking Up Fonts</source>
          <target state="translated">Looking Up Fonts</target>
        </trans-unit>
        <trans-unit id="d63629c4a0bb6a63de031bf229ac03c609809d09" translate="yes" xml:space="preserve">
          <source>Looking Up and Expanding Abbreviations</source>
          <target state="translated">Looking Up and Expanding Abbreviations</target>
        </trans-unit>
        <trans-unit id="bc0e6625c124c4eb5bd0fcd56ac755373c3fb4f2" translate="yes" xml:space="preserve">
          <source>Looking at the properties of one character.</source>
          <target state="translated">Looking at the properties of one character.</target>
        </trans-unit>
        <trans-unit id="178121740f45b5d6e7facf9d96018d909c21354f" translate="yes" xml:space="preserve">
          <source>Looking through all keymaps, for printing help.</source>
          <target state="translated">Looking through all keymaps, for printing help.</target>
        </trans-unit>
        <trans-unit id="851bbb5519ca80dce271e99e2231072e5a4a3479" translate="yes" xml:space="preserve">
          <source>Looking up the names of available fonts and information about them.</source>
          <target state="translated">Looking up the names of available fonts and information about them.</target>
        </trans-unit>
        <trans-unit id="68ff0bd1cbaecfae7d37b0d97386effbf3fba27d" translate="yes" xml:space="preserve">
          <source>Lookup in a hash table is extremely fast for large tables&amp;mdash;in fact, the time required is essentially &lt;em&gt;independent&lt;/em&gt; of how many elements are stored in the table. For smaller tables (a few tens of elements) alists may still be faster because hash tables have a more-or-less constant overhead.</source>
          <target state="translated">Lookup in a hash table is extremely fast for large tables&amp;mdash;in fact, the time required is essentially &lt;em&gt;independent&lt;/em&gt; of how many elements are stored in the table. For smaller tables (a few tens of elements) alists may still be faster because hash tables have a more-or-less constant overhead.</target>
        </trans-unit>
        <trans-unit id="f5253ec82559052e87ceaff557957647ac4e6a68" translate="yes" xml:space="preserve">
          <source>Low-Level Font Representation</source>
          <target state="translated">Low-Level Font Representation</target>
        </trans-unit>
        <trans-unit id="323f212d3828fcc314985cd1386476951f05a2ee" translate="yes" xml:space="preserve">
          <source>Low-Level Kill Ring</source>
          <target state="translated">Low-Level Kill Ring</target>
        </trans-unit>
        <trans-unit id="cd3b0d6e2fa4c08068b3e57e488ba7e247c660c5" translate="yes" xml:space="preserve">
          <source>Low-Level Network Access</source>
          <target state="translated">Low-Level Network Access</target>
        </trans-unit>
        <trans-unit id="cbddb05b874ab89fa507c4d8957fdf31bf1114b7" translate="yes" xml:space="preserve">
          <source>Low-Level Parsing</source>
          <target state="translated">Low-Level Parsing</target>
        </trans-unit>
        <trans-unit id="4259b3253a806353d7c8d6ae41622a4465d4b63c" translate="yes" xml:space="preserve">
          <source>Low-level functions for completing strings.</source>
          <target state="translated">Low-level functions for completing strings.</target>
        </trans-unit>
        <trans-unit id="e3fc395679fd313e5a3b121bd0f61b1e24d51f49" translate="yes" xml:space="preserve">
          <source>Lower-level but more general function to create connections and servers.</source>
          <target state="translated">Lower-level but more general function to create connections and servers.</target>
        </trans-unit>
        <trans-unit id="412965d373e39e0acf2e9d34874530d49b3e8f45" translate="yes" xml:space="preserve">
          <source>Lower-level subroutines that they use.</source>
          <target state="translated">Lower-level subroutines that they use.</target>
        </trans-unit>
        <trans-unit id="c63ae6dd4fc9f9dda66970e827d13f7c73fe841c" translate="yes" xml:space="preserve">
          <source>M</source>
          <target state="translated">M</target>
        </trans-unit>
        <trans-unit id="1380c1040fe5f22f86cfa0fff612c7bb977dc760" translate="yes" xml:space="preserve">
          <source>M-</source>
          <target state="translated">M-</target>
        </trans-unit>
        <trans-unit id="37a5c39dff07a52dd3087c214ce1f8d1b29f0a8c" translate="yes" xml:space="preserve">
          <source>M-&amp;lt;</source>
          <target state="translated">M-&amp;lt;</target>
        </trans-unit>
        <trans-unit id="f56099d279d3bbbe13433ab2b41f59ecda17c1b5" translate="yes" xml:space="preserve">
          <source>M--</source>
          <target state="translated">M--</target>
        </trans-unit>
        <trans-unit id="3c8556ad1d538e0b24776b2eb4aadd97384f92be" translate="yes" xml:space="preserve">
          <source>M-.</source>
          <target state="translated">M-.</target>
        </trans-unit>
        <trans-unit id="195ce7fc591804e0719a61c0fa3a7301aae4a144" translate="yes" xml:space="preserve">
          <source>M-:</source>
          <target state="translated">M-:</target>
        </trans-unit>
        <trans-unit id="d63f0fe93faad24b66a76a47ccdc11cdad6f0669" translate="yes" xml:space="preserve">
          <source>M-: &lt;var&gt;exp&lt;/var&gt;RET</source>
          <target state="translated">M-: &lt;var&gt;exp&lt;/var&gt; RET</target>
        </trans-unit>
        <trans-unit id="306f4c5a0e32d8e206ce9f2acecfdbbd30b93ebd" translate="yes" xml:space="preserve">
          <source>M-A</source>
          <target state="translated">M-A</target>
        </trans-unit>
        <trans-unit id="6951aed8ad5e7255f081050661207da69a62bceb" translate="yes" xml:space="preserve">
          <source>M-F1</source>
          <target state="translated">M-F1</target>
        </trans-unit>
        <trans-unit id="d5deac9a11e75cdf2221fc4ccab2ecbdf3ce7f5e" translate="yes" xml:space="preserve">
          <source>M-O</source>
          <target state="translated">M-O</target>
        </trans-unit>
        <trans-unit id="582c231510f999e4090021d4c4d24dd9d1083ddc" translate="yes" xml:space="preserve">
          <source>M-TAB</source>
          <target state="translated">M-TAB</target>
        </trans-unit>
        <trans-unit id="6e83342732a657a8dfe6c872ef3fa40bd7ab6c1d" translate="yes" xml:space="preserve">
          <source>M-[</source>
          <target state="translated">M-[</target>
        </trans-unit>
        <trans-unit id="c32ec53effd66388f8d3ebba5bbdc052dda00483" translate="yes" xml:space="preserve">
          <source>M-a</source>
          <target state="translated">M-a</target>
        </trans-unit>
        <trans-unit id="dfec75d824ab931885b10c2deb8b602ddf385540" translate="yes" xml:space="preserve">
          <source>M-b</source>
          <target state="translated">M-b</target>
        </trans-unit>
        <trans-unit id="92eda3bf541ac9f8576ded598bec375af4abc3bd" translate="yes" xml:space="preserve">
          <source>M-end</source>
          <target state="translated">M-end</target>
        </trans-unit>
        <trans-unit id="980a6233a9b06694b777bb282affe943e0afc2da" translate="yes" xml:space="preserve">
          <source>M-g</source>
          <target state="translated">M-g</target>
        </trans-unit>
        <trans-unit id="52706036e0d1667ecb93c7d036d3d039cba1682a" translate="yes" xml:space="preserve">
          <source>M-n</source>
          <target state="translated">M-n</target>
        </trans-unit>
        <trans-unit id="c7cf6ebaeff525a4a38321125032420c3882f5a3" translate="yes" xml:space="preserve">
          <source>M-o</source>
          <target state="translated">M-o</target>
        </trans-unit>
        <trans-unit id="15f62577eedb593ecdad3ec32390144de3a4748e" translate="yes" xml:space="preserve">
          <source>M-o M-o</source>
          <target state="translated">M-o M-o</target>
        </trans-unit>
        <trans-unit id="ded2b381f768b0426ee02fc11e7b1ea526d86382" translate="yes" xml:space="preserve">
          <source>M-p</source>
          <target state="translated">M-p</target>
        </trans-unit>
        <trans-unit id="0f8046567a7777233033e7c62fcbaaf077eb077a" translate="yes" xml:space="preserve">
          <source>M-r</source>
          <target state="translated">M-r</target>
        </trans-unit>
        <trans-unit id="0006025ee1ee308621c9836f080cfbad730b00dd" translate="yes" xml:space="preserve">
          <source>M-s</source>
          <target state="translated">M-s</target>
        </trans-unit>
        <trans-unit id="e2dbd97a24cfd42feafe4155928e5e36e05f30f3" translate="yes" xml:space="preserve">
          <source>M-v</source>
          <target state="translated">M-v</target>
        </trans-unit>
        <trans-unit id="5516e58102890d870825312fe7edb083af235de4" translate="yes" xml:space="preserve">
          <source>M-x</source>
          <target state="translated">M-x</target>
        </trans-unit>
        <trans-unit id="e96ee2840300f270b45095c2f0ec40521a00cde5" translate="yes" xml:space="preserve">
          <source>M-x &lt;var&gt;command&lt;/var&gt;</source>
          <target state="translated">M-x &lt;var&gt;command&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="30b1c3d10bd4ea36dfe161af71f9b59cff94dfbf" translate="yes" xml:space="preserve">
          <source>M-x &lt;var&gt;command&lt;/var&gt;RET</source>
          <target state="translated">M-x &lt;var&gt;command&lt;/var&gt; RET</target>
        </trans-unit>
        <trans-unit id="c8f918be9ef0d86eff9e8b262b173a76afb5d823" translate="yes" xml:space="preserve">
          <source>M-x apropos RET x-pointer RET</source>
          <target state="translated">M-x apropos RET x-pointer RET</target>
        </trans-unit>
        <trans-unit id="19d036c0bdece7df51bbb22b25a57a912bb781fc" translate="yes" xml:space="preserve">
          <source>M-x customize</source>
          <target state="translated">M-x customize</target>
        </trans-unit>
        <trans-unit id="350cf2e68d92268174ae9d7178734cce54adaa8c" translate="yes" xml:space="preserve">
          <source>M-x describe-categories RET</source>
          <target state="translated">M-x describe-categories RET</target>
        </trans-unit>
        <trans-unit id="28a7266291890a298f219fa24bf612c876e68a3a" translate="yes" xml:space="preserve">
          <source>M-x dired-default-directory-on-left</source>
          <target state="translated">M-x dired-default-directory-on-left</target>
        </trans-unit>
        <trans-unit id="d0dbe2e240aeb6f1a78c981c88c230cc06b9fce7" translate="yes" xml:space="preserve">
          <source>M-x edebug-all-defs</source>
          <target state="translated">M-x edebug-all-defs</target>
        </trans-unit>
        <trans-unit id="c71a2298fbf3e6b350d972a5f6758ef0c7f37945" translate="yes" xml:space="preserve">
          <source>M-x edebug-all-forms</source>
          <target state="translated">M-x edebug-all-forms</target>
        </trans-unit>
        <trans-unit id="66031655733aef9ceba93288111a34d690630332" translate="yes" xml:space="preserve">
          <source>M-x edebug-backtrace-hide-instrumentation</source>
          <target state="translated">M-x edebug-backtrace-hide-instrumentation</target>
        </trans-unit>
        <trans-unit id="f849db42cc80a644b891cceb796496aea5a33446" translate="yes" xml:space="preserve">
          <source>M-x edebug-backtrace-show-instrumentation</source>
          <target state="translated">M-x edebug-backtrace-show-instrumentation</target>
        </trans-unit>
        <trans-unit id="0e0239d280915da82047b3562e0edc1ef7e13f61" translate="yes" xml:space="preserve">
          <source>M-x edebug-eval-top-level-form</source>
          <target state="translated">M-x edebug-eval-top-level-form</target>
        </trans-unit>
        <trans-unit id="95fa4b4069fcd95b6d5ac0204ea4c9cff0ee6f75" translate="yes" xml:space="preserve">
          <source>M-x edit-tab-stops</source>
          <target state="translated">M-x edit-tab-stops</target>
        </trans-unit>
        <trans-unit id="924625b2d7b939bdd69c369a8e0e7552d4621132" translate="yes" xml:space="preserve">
          <source>M-x list-colors-display</source>
          <target state="translated">M-x list-colors-display</target>
        </trans-unit>
        <trans-unit id="2d76ea9e63fcbb859b33f48edd7feb794a1730b1" translate="yes" xml:space="preserve">
          <source>M-x list-processes</source>
          <target state="translated">M-x list-processes</target>
        </trans-unit>
        <trans-unit id="84edc9f7052f2c9a7f036d7890685dfe8db762ec" translate="yes" xml:space="preserve">
          <source>M-x load-library RET package-x RET</source>
          <target state="translated">M-x load-library RET package-x RET</target>
        </trans-unit>
        <trans-unit id="b609619759aa9b92d26776cb6f14ab4bcfcc31de" translate="yes" xml:space="preserve">
          <source>M-x profiler-&amp;hellip;</source>
          <target state="translated">M-x profiler-&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="0773bdccb110b28fb0a67898b66d8dd11444e9cc" translate="yes" xml:space="preserve">
          <source>M-x profiler-report</source>
          <target state="translated">M-x profiler-report</target>
        </trans-unit>
        <trans-unit id="4f21aa5941ccf75086060a4caa6ef135d1f402a8" translate="yes" xml:space="preserve">
          <source>M-x profiler-start</source>
          <target state="translated">M-x profiler-start</target>
        </trans-unit>
        <trans-unit id="7f9fd75200c3ba11f87c5df3770346f3beaa6c06" translate="yes" xml:space="preserve">
          <source>M-x profiler-stop</source>
          <target state="translated">M-x profiler-stop</target>
        </trans-unit>
        <trans-unit id="e1f1559513ee5a73bed6212288039c357856e5b7" translate="yes" xml:space="preserve">
          <source>M-x python-mode</source>
          <target state="translated">M-x python-mode</target>
        </trans-unit>
        <trans-unit id="9a178593a35bbea7f02403c42d651edd7a1bdd3d" translate="yes" xml:space="preserve">
          <source>M-x re-builder</source>
          <target state="translated">M-x re-builder</target>
        </trans-unit>
        <trans-unit id="02844767c038cdd2dda139c1d2eab250404388db" translate="yes" xml:space="preserve">
          <source>M-x report-emacs-bug</source>
          <target state="translated">M-x report-emacs-bug</target>
        </trans-unit>
        <trans-unit id="4a8d44402484cf1af704bb5188c0b2f67fd9deae" translate="yes" xml:space="preserve">
          <source>M-x serial-term</source>
          <target state="translated">M-x serial-term</target>
        </trans-unit>
        <trans-unit id="d262f66141e61698a64505a1167b86f852cd6537" translate="yes" xml:space="preserve">
          <source>M-x set-visited-file-name</source>
          <target state="translated">M-x set-visited-file-name</target>
        </trans-unit>
        <trans-unit id="ddd4cde942039a43aa69d7aaf7874a8689013014" translate="yes" xml:space="preserve">
          <source>M-x shell</source>
          <target state="translated">M-x shell</target>
        </trans-unit>
        <trans-unit id="aeb29959992cb9268370a1bd309d2ce9f465185c" translate="yes" xml:space="preserve">
          <source>M-x testcover-mark-all</source>
          <target state="translated">M-x testcover-mark-all</target>
        </trans-unit>
        <trans-unit id="e8f70ba057d5e0dc5100fc76829c8002a8f06257" translate="yes" xml:space="preserve">
          <source>M-x testcover-next-mark</source>
          <target state="translated">M-x testcover-next-mark</target>
        </trans-unit>
        <trans-unit id="91f5f461f2c3a31e68b3789ab862a2b579739b85" translate="yes" xml:space="preserve">
          <source>M-x testcover-start RET&lt;var&gt;file&lt;/var&gt;RET</source>
          <target state="translated">M-x testcover-start RET &lt;var&gt;file&lt;/var&gt; RET</target>
        </trans-unit>
        <trans-unit id="0cb1249115b25aa2690a25b8910733c67b4a92a4" translate="yes" xml:space="preserve">
          <source>M-x untabify</source>
          <target state="translated">M-x untabify</target>
        </trans-unit>
        <trans-unit id="8938bda20b679e9984362cfe3b0025e2957609de" translate="yes" xml:space="preserve">
          <source>M-x update-directory-autoloads</source>
          <target state="translated">M-x update-directory-autoloads</target>
        </trans-unit>
        <trans-unit id="17a3a65ded9cf97168d2d48abac758964baf3233" translate="yes" xml:space="preserve">
          <source>M-x update-file-autoloads</source>
          <target state="translated">M-x update-file-autoloads</target>
        </trans-unit>
        <trans-unit id="157b9065ca9092b93a2cd86b2065b6f97cb3c423" translate="yes" xml:space="preserve">
          <source>M-x widget-browse RET binary-tree-of-string RET</source>
          <target state="translated">M-x widget-browse RET binary-tree-of-string RET</target>
        </trans-unit>
        <trans-unit id="3aa424326e8c65a4310c522189aff3bdb49730f9" translate="yes" xml:space="preserve">
          <source>M-xelp-instrument-listRET nil RET</source>
          <target state="translated">M-xelp-instrument-listRET nil RET</target>
        </trans-unit>
        <trans-unit id="d61a0439c16b301031a2c72fbbf40aec0781473a" translate="yes" xml:space="preserve">
          <source>M-xelp-results</source>
          <target state="translated">M-xelp-results</target>
        </trans-unit>
        <trans-unit id="4cb98f7867f1180986c1b84ef1785ff0b2c4dc15" translate="yes" xml:space="preserve">
          <source>M-xlist-buffers</source>
          <target state="translated">M-xlist-buffers</target>
        </trans-unit>
        <trans-unit id="05b684cd2cc4407a760fc4776a9afa8ac8eaddb7" translate="yes" xml:space="preserve">
          <source>M-xlist-tags</source>
          <target state="translated">M-xlist-tags</target>
        </trans-unit>
        <trans-unit id="7555a33395fef6db20d121fb58c3221aa124e48c" translate="yes" xml:space="preserve">
          <source>M-y</source>
          <target state="translated">M-y</target>
        </trans-unit>
        <trans-unit id="db42242da8c9daf4dc32a3e8f6a8c77ab461abee" translate="yes" xml:space="preserve">
          <source>MENU-BAR</source>
          <target state="translated">MENU-BAR</target>
        </trans-unit>
        <trans-unit id="40bb78ac4a8f75b73057a2a259dcfa335c88dad4" translate="yes" xml:space="preserve">
          <source>META</source>
          <target state="translated">META</target>
        </trans-unit>
        <trans-unit id="2d4aa5a5271bf55bf5139dda546f0f30ba06a6bd" translate="yes" xml:space="preserve">
          <source>MIME</source>
          <target state="translated">MIME</target>
        </trans-unit>
        <trans-unit id="240ac4da20e27f25d9defe42a63eca4461adbce9" translate="yes" xml:space="preserve">
          <source>MS-DOS and MS-Windows systems usually lack the standard Unix program &lt;code&gt;ls&lt;/code&gt;, so this function emulates the standard Unix program &lt;code&gt;ls&lt;/code&gt; with Lisp code.</source>
          <target state="translated">MS-DOS and MS-Windows systems usually lack the standard Unix program &lt;code&gt;ls&lt;/code&gt; , so this function emulates the standard Unix program &lt;code&gt;ls&lt;/code&gt; with Lisp code.</target>
        </trans-unit>
        <trans-unit id="a6a56e5df064567806bfd2d02ec60d53d177da70" translate="yes" xml:space="preserve">
          <source>MS-DOS doesn&amp;rsquo;t support asynchronous subprocesses, so this option doesn&amp;rsquo;t work there.</source>
          <target state="translated">MS-DOS doesn&amp;rsquo;t support asynchronous subprocesses, so this option doesn&amp;rsquo;t work there.</target>
        </trans-unit>
        <trans-unit id="660bf78961f4ec6bd8bd8b37a3b0b2769db2b14a" translate="yes" xml:space="preserve">
          <source>Macro</source>
          <target state="translated">Macro</target>
        </trans-unit>
        <trans-unit id="0d2da2eb949e2df3a96a434a98613935cdfa18a4" translate="yes" xml:space="preserve">
          <source>Macro Type</source>
          <target state="translated">Macro Type</target>
        </trans-unit>
        <trans-unit id="3764e4ae50932da915ec9a84fd2ba1b1c33188ce" translate="yes" xml:space="preserve">
          <source>Macro calls (see &lt;a href=&quot;macros#Macros&quot;&gt;Macros&lt;/a&gt;).</source>
          <target state="translated">매크로 호출 ( &lt;a href=&quot;macros#Macros&quot;&gt;매크로&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="730c77b761075cf87c04f675fec25c96f12254c7" translate="yes" xml:space="preserve">
          <source>Macro expansion can have counterintuitive consequences. This section describes some important consequences that can lead to trouble, and rules to follow to avoid trouble.</source>
          <target state="translated">매크로 확장은 직관에 반하는 결과를 초래할 수 있습니다. 이 섹션에서는 문제를 일으킬 수있는 몇 가지 중요한 결과와 문제를 방지하기 위해 따라야 할 규칙에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="7c8148b5f3e72ae81e30a87c1414a699978cee33" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;1value&lt;/strong&gt;&lt;em&gt;form&lt;/em&gt;</source>
          <target state="translated">매크로 : 1 &lt;strong&gt;값 &lt;/strong&gt;&lt;em&gt;형식&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f625904d011437c920c24217d1112932e75fdede" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;EMACS_LIMB_MAX&lt;/strong&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;EMACS_LIMB_MAX&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f63e91ed8761158e2824094f3c035978e33f0b75" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;add-function&lt;/strong&gt;&lt;em&gt;where place function &amp;amp;optional props&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;em&gt;위치 기능 및 옵션 소품 &lt;/em&gt;&lt;strong&gt;추가 기능&lt;/strong&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5429d225c6285d485886a63d9a654b44fd9af85a" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;cl-defgeneric&lt;/strong&gt;&lt;em&gt;name arguments [documentation] [options-and-methods&amp;hellip;] &amp;amp;rest body&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;cl-defgeneric &lt;/strong&gt;&lt;em&gt;이름 인수 [문서] [옵션 및 방법&amp;hellip;] &amp;amp; rest body&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ba5cedae4a4b306427387f90edd4dbd185e02578" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;cl-defmethod&lt;/strong&gt;&lt;em&gt;name [qualifier] arguments [&amp;amp;context (expr spec)&amp;hellip;] &amp;amp;rest [docstring] body&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;cl-defmethod &lt;/strong&gt;&lt;em&gt;name [qualifier] arguments [&amp;amp; context (expr spec)&amp;hellip;] &amp;amp; rest [docstring] body&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1ff2b909c891d19da7650f8ccd70d4ff20d5f0ef" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;combine-after-change-calls&lt;/strong&gt;&lt;em&gt;body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;변경 후 호출 결합 &lt;/strong&gt;&lt;em&gt;본문&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6ee51599c974e6734d6444e666498d94c6309037" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;combine-change-calls&lt;/strong&gt;&lt;em&gt;beg end body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;결합 변경 호출이 &lt;/strong&gt;&lt;em&gt;최종 본문을 요청합니다&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3aee740831df3fe36c5e3627bd95688debd9b10c" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;condition-case-unless-debug&lt;/strong&gt;&lt;em&gt;var protected-form handlers&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;condition-case-unless-debug &lt;/strong&gt;&lt;em&gt;var 보호 양식 핸들러&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="be46ac442c6b283fe5303544430db1733ede80cf" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;declare-function&lt;/strong&gt;&lt;em&gt;function file &amp;amp;optional arglist fileonly&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;함수 선언 &lt;/strong&gt;&lt;em&gt;기능 파일 및 선택적 arglist 파일 전용&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="62a5106ba44b52792efba46fd9abcd6f50d2a690" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;declare&lt;/strong&gt;&lt;em&gt;specs&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;em&gt;사양 &lt;/em&gt;&lt;strong&gt;선언 &lt;/strong&gt;&lt;em&gt;&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="aad917e7e24305c69cc7b616287145940c7bc611" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;def-edebug-spec&lt;/strong&gt;&lt;em&gt;macro specification&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;def-edebug-spec &lt;/strong&gt;&lt;em&gt;매크로 사양&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e8850ae7654fdd0f9e7e3643b836d299119c8eb3" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;defcustom&lt;/strong&gt;&lt;em&gt;option standard doc [keyword value]&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;defcustom &lt;/strong&gt;&lt;em&gt;옵션 표준 문서 [키워드 값]&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5434cd21483dbb5ef69be871541753221bd178a5" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;defface&lt;/strong&gt;&lt;em&gt;face spec doc [keyword value]&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;defface &lt;/strong&gt;&lt;em&gt;face spec doc [키워드 값]&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="14c7fabc7b52a8375cc5c9e142c3ac122d2ea4bc" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;defgroup&lt;/strong&gt;&lt;em&gt;group members doc [keyword value]&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;defgroup &lt;/strong&gt;&lt;em&gt;그룹 구성원 문서 [키워드 값]&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="28b55593ba483070425de7736987bf774bd2c491" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;defimage&lt;/strong&gt;&lt;em&gt;symbol specs &amp;amp;optional doc&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;defimage &lt;/strong&gt;&lt;em&gt;기호 사양 및 선택적 문서&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fea6bef8b59da7c79bbd75395190d7484736ecf9" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;define-advice&lt;/strong&gt;&lt;em&gt;symbol (where lambda-list &amp;amp;optional name depth) &amp;amp;rest body&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;정의 권고 &lt;/strong&gt;&lt;em&gt;기호 (여기서 람다 목록 및 선택적 이름 깊이) 및 나머지 본문&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="70852342716d3e0bca8b4f3d79c1ec5991f6b9cc" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;define-alternatives&lt;/strong&gt;&lt;em&gt;command &amp;amp;rest customizations&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;define-alternatives &lt;/strong&gt;&lt;em&gt;명령 및 나머지 사용자 정의&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="af424b3d2ee378903109c9532c12c3d915726f60" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;define-derived-mode&lt;/strong&gt;&lt;em&gt;variant parent name docstring keyword-args&amp;hellip; body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;정의 파생 모드 &lt;/strong&gt;&lt;em&gt;변형 상위 이름 docstring keyword-args&amp;hellip; body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d039443b2fcf2ccb94276b2881ba59ab7c4bef6e" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;define-generic-mode&lt;/strong&gt;&lt;em&gt;mode comment-list keyword-list font-lock-list auto-mode-list function-list &amp;amp;optional docstring&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;define-generic-mode &lt;/strong&gt;&lt;em&gt;mode comment-list keyword-list font-lock-list auto-mode-list function-list &amp;amp; optional docstring&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3be7a42eb17b3b478f941dfaad3f2a091b3d9de0" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;define-globalized-minor-mode&lt;/strong&gt;&lt;em&gt;global-mode mode turn-on keyword-args&amp;hellip; body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;define-globalized-minor-mode &lt;/strong&gt;&lt;em&gt;전역 모드 모드 turn-on keyword-args&amp;hellip; body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c3698aa5f5a4cf22d04e63dba4fd63eeab2b198c" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;define-inline&lt;/strong&gt;&lt;em&gt;name args [doc] [declare] body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;정의 인라인 &lt;/strong&gt;&lt;em&gt;이름 args [doc] [declare] body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1872fe945d43990f77596fefa545da1cad14ecf2" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;define-minor-mode&lt;/strong&gt;&lt;em&gt;mode doc [init-value [lighter [keymap]]] keyword-args&amp;hellip; body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;부 모드 &lt;/strong&gt;&lt;em&gt;모드 &lt;/em&gt;&lt;strong&gt;정의 &lt;/strong&gt;&lt;em&gt;문서 [init-value [lighter [keymap]]] keyword-args&amp;hellip; body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e428f2f8e85f45dc22b5c0ef48e7d972c7378dba" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;define-obsolete-face-alias&lt;/strong&gt;&lt;em&gt;obsolete-face current-face when&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;쓸모없는 얼굴 별칭 정의 쓸모없는 &lt;/strong&gt;&lt;em&gt;얼굴 현재 얼굴&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="803af6ea30a01f534dc197a816a8b6feeabe7985" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;define-obsolete-function-alias&lt;/strong&gt;&lt;em&gt;obsolete-name current-name when &amp;amp;optional doc&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;define-obsolete-function-alias &lt;/strong&gt;&lt;em&gt;obsolete-name current-name when &amp;amp; optional doc&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c1c5b6a54e8e1d18babd8fbf3277042db07db8a8" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;define-obsolete-variable-alias&lt;/strong&gt;&lt;em&gt;obsolete-name current-name &amp;amp;optional when docstring&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;폐기 된 변수 별명 정의 &lt;/strong&gt;&lt;em&gt;폐기 된 이름 현재 이름 및 독 스트링시 선택 사항&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="10f5376be352b9daee65a34b48f0eb2a91bc607c" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;defmacro&lt;/strong&gt;&lt;em&gt;name args [doc] [declare] body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;defmacro &lt;/strong&gt;&lt;em&gt;name args [doc] [declare] body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="78c0fc24e6b16b98abe1b0908482cec19956ca6f" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;defsubst&lt;/strong&gt;&lt;em&gt;name args [doc] [declare] [interactive] body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;defsubst &lt;/strong&gt;&lt;em&gt;name args [doc] [declare] [interactive] body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1683d10fb7854b9d19dee990d4fa2a5c7aa5855c" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;deftheme&lt;/strong&gt;&lt;em&gt;theme &amp;amp;optional doc&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;deftheme &lt;/strong&gt;&lt;em&gt;테마 및 선택적 문서&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8f549c138328cc6f82aa82edd990d79c318eb798" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;defun&lt;/strong&gt;&lt;em&gt;name args [doc] [declare] [interactive] body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;defun &lt;/strong&gt;&lt;em&gt;name args [doc] [declare] [interactive] body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="10c945e44b82a451a5291eaa330f70caa9d10af2" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;defvar-local&lt;/strong&gt;&lt;em&gt;variable value &amp;amp;optional docstring&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;defvar-local &lt;/strong&gt;&lt;em&gt;변수 값 및 선택적 docstring&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cc1f8d335ca6f3d1108310f49f1d7c79312c2310" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;delay-mode-hooks&lt;/strong&gt;&lt;em&gt;body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;지연 모드 후크 &lt;/strong&gt;&lt;em&gt;본문&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="236c5615e3d9ad7c6a4ecbd45a98af3f3547666f" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;dolist-with-progress-reporter&lt;/strong&gt;&lt;em&gt;(var count [result]) reporter-or-message body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;dolist-with-progress-reporter &lt;/strong&gt;&lt;em&gt;(var count [result]) reporter-or-message body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="af38a7273fecb69f9c319a26123467a4b36e125d" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;dolist&lt;/strong&gt;&lt;em&gt;(var list [result]) body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;dolist &lt;/strong&gt;&lt;em&gt;(var list [result]) 본문&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f09315db5afa839072a62fbc1535685142261f35" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;dotimes-with-progress-reporter&lt;/strong&gt;&lt;em&gt;(var count [result]) reporter-or-message body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;dotimes-with-progress-reporter &lt;/strong&gt;&lt;em&gt;(var count [result]) reporter-or-message body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7f92ffa9680e321f5b7958eb9df3da33cc00a96e" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;dotimes&lt;/strong&gt;&lt;em&gt;(var count [result]) body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;dotimes &lt;/strong&gt;&lt;em&gt;(var count [result]) 본문&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="27132dd2125d6a24d297f0e928ce24fd5c66c2a4" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;easy-menu-define&lt;/strong&gt;&lt;em&gt;symbol maps doc menu&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;쉬운 메뉴 정의 &lt;/strong&gt;&lt;em&gt;기호 맵 문서 메뉴&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4202975359e6a5a35e94aebc824c1980bfa133ab" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;edebug-tracing&lt;/strong&gt;&lt;em&gt;string body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;edebug-tracing &lt;/strong&gt;&lt;em&gt;string body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
