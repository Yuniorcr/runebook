<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="elisp">
    <body>
      <group id="elisp">
        <trans-unit id="cd969dae78e04fd8c37f6b3cfb39c7d32c4a3daa" translate="yes" xml:space="preserve">
          <source>Syntax Tables</source>
          <target state="translated">구문 테이블</target>
        </trans-unit>
        <trans-unit id="7a8491486c1dd1e36fecef6fb025b6d953ee6bce" translate="yes" xml:space="preserve">
          <source>Syntax character</source>
          <target state="translated">구문 문자</target>
        </trans-unit>
        <trans-unit id="3a75a3c003ea56dc72367919450cb68e784c15a4" translate="yes" xml:space="preserve">
          <source>Syntax flags are encoded in higher order bits, starting 16 bits from the least significant bit. This table gives the power of two which corresponds to each syntax flag.</source>
          <target state="translated">구문 플래그는 최하위 비트에서 16 비트부터 시작하여 상위 비트로 인코딩됩니다. 이 표는 각 구문 플래그에 해당하는 2의 거듭 제곱을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="69c9b8582ee05373bdfc0abb499365f98dd04862" translate="yes" xml:space="preserve">
          <source>Syntax for Strings</source>
          <target state="translated">문자열 구문</target>
        </trans-unit>
        <trans-unit id="8cb3a281e588cc742b01e3740c59ad1d56db3c93" translate="yes" xml:space="preserve">
          <source>Syntax for control characters.</source>
          <target state="translated">제어 문자에 대한 구문.</target>
        </trans-unit>
        <trans-unit id="183c7ba87286e0fe725dee087dc513f1f2559a37" translate="yes" xml:space="preserve">
          <source>Syntax for hyper-, super-, and alt-characters.</source>
          <target state="translated">하이퍼, 슈퍼 및 대체 문자에 대한 구문.</target>
        </trans-unit>
        <trans-unit id="81b87087386ebffcaa2df63aa5ab7fab58d228b0" translate="yes" xml:space="preserve">
          <source>Syntax for meta-characters.</source>
          <target state="translated">메타 문자에 대한 구문.</target>
        </trans-unit>
        <trans-unit id="f7eaf1748919ec8b360cee2686b8fa7780d6554c" translate="yes" xml:space="preserve">
          <source>Syntax for regular characters.</source>
          <target state="translated">일반 문자에 대한 구문.</target>
        </trans-unit>
        <trans-unit id="e284594ea5fa7caa24811e20fa73e2b5dff45cd4" translate="yes" xml:space="preserve">
          <source>Syntax name</source>
          <target state="translated">구문 이름</target>
        </trans-unit>
        <trans-unit id="8d26d1dba3b7aae7767b0e849b6989ede03494bf" translate="yes" xml:space="preserve">
          <source>Syntax of Regular Expressions</source>
          <target state="translated">정규식 구문</target>
        </trans-unit>
        <trans-unit id="d8464bf58345d9a6b7e29aa70e89a5dbda979411" translate="yes" xml:space="preserve">
          <source>Syntax tables (see &lt;a href=&quot;syntax-tables#Syntax-Tables&quot;&gt;Syntax Tables&lt;/a&gt;).</source>
          <target state="translated">구문 테이블 (참조 &lt;a href=&quot;syntax-tables#Syntax-Tables&quot;&gt;구문 테이블&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="131aa9c3aaea2e49816523d4aa4b0c24a9b447db" translate="yes" xml:space="preserve">
          <source>Syntax tables are implemented as char-tables (see &lt;a href=&quot;char_002dtables#Char_002dTables&quot;&gt;Char-Tables&lt;/a&gt;), but most Lisp programs don&amp;rsquo;t work directly with their elements. Syntax tables do not store syntax data as syntax descriptors (see &lt;a href=&quot;syntax-descriptors#Syntax-Descriptors&quot;&gt;Syntax Descriptors&lt;/a&gt;); they use an internal format, which is documented in this section. This internal format can also be assigned as syntax properties (see &lt;a href=&quot;syntax-properties#Syntax-Properties&quot;&gt;Syntax Properties&lt;/a&gt;).</source>
          <target state="translated">구문 테이블은 char-tables ( &lt;a href=&quot;char_002dtables#Char_002dTables&quot;&gt;Char-Tables&lt;/a&gt; 참조)로 구현 되지만 대부분의 Lisp 프로그램은 해당 요소와 직접 작동하지 않습니다. 구문 테이블은 구문 설명합니다 (같은 구문 데이터를 저장하지 않는 &lt;a href=&quot;syntax-descriptors#Syntax-Descriptors&quot;&gt;구문 설명자&lt;/a&gt; ); 이 섹션에 설명 된 내부 형식을 사용합니다. 이 내부 형식은 구문 속성으로 할당 할 수도 있습니다 ( &lt;a href=&quot;syntax-properties#Syntax-Properties&quot;&gt;구문 속성&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="9d59285289ccc6dfb4ed5e5485160fccc3f7588b" translate="yes" xml:space="preserve">
          <source>Syntax tables are not used by the Emacs Lisp reader, which has its own built-in syntactic rules which cannot be changed. (Some Lisp systems provide ways to redefine the read syntax, but we decided to leave this feature out of Emacs Lisp for simplicity.)</source>
          <target state="translated">구문 테이블은 변경 될 수없는 자체 내장 구문 규칙이있는 Emacs Lisp 판독기에서 사용되지 않습니다. (일부 Lisp 시스템은 읽기 구문을 재정의하는 방법을 제공하지만 간단하게이 기능을 Emacs Lisp에서 제외하기로 결정했습니다.)</target>
        </trans-unit>
        <trans-unit id="3335c043a5759be5adb0f7a04ab0ccf5c5aa2d46" translate="yes" xml:space="preserve">
          <source>System Interface</source>
          <target state="translated">시스템 인터페이스</target>
        </trans-unit>
        <trans-unit id="b5076ad981f290c37270bb2a148ea3bb144fbfe8" translate="yes" xml:space="preserve">
          <source>Systems that don&amp;rsquo;t use the X window system, such as MS-Windows, don&amp;rsquo;t support the notion of X displays, and have only one display on each host. The display name on these systems doesn&amp;rsquo;t follow the above 3-part format; for example, the display name on MS-Windows systems is a constant string &amp;lsquo;</source>
          <target state="translated">MS-Windows와 같이 X 윈도우 시스템을 사용하지 않는 시스템은 X 디스플레이 개념을 지원하지 않으며 각 호스트에 하나의 디스플레이 만 있습니다. 이러한 시스템의 표시 이름은 위의 세 부분 형식을 따르지 않습니다. 예를 들어 MS-Windows 시스템의 표시 이름은 상수 문자열 '</target>
        </trans-unit>
        <trans-unit id="c2c53d66948214258a26ca9ca845d7ac0c17f8e7" translate="yes" xml:space="preserve">
          <source>T</source>
          <target state="translated">T</target>
        </trans-unit>
        <trans-unit id="38d4aa698a701e2288a153e115d12aab45de5940" translate="yes" xml:space="preserve">
          <source>TAB</source>
          <target state="translated">TAB</target>
        </trans-unit>
        <trans-unit id="a775b64f2cd6a88a198986d46d44e0a021785125" translate="yes" xml:space="preserve">
          <source>TIFF</source>
          <target state="translated">TIFF</target>
        </trans-unit>
        <trans-unit id="d91e1888f2dc09f11a876e25966a6fbd32b9cd87" translate="yes" xml:space="preserve">
          <source>TLS</source>
          <target state="translated">TLS</target>
        </trans-unit>
        <trans-unit id="20c82d216d6c9ffeb3659bcf801fce1cd3ffc885" translate="yes" xml:space="preserve">
          <source>TOOL-BAR</source>
          <target state="translated">TOOL-BAR</target>
        </trans-unit>
        <trans-unit id="ba122ed060e172cdd2f88709faf4e9bdd7194f9a" translate="yes" xml:space="preserve">
          <source>Table of Syntax Classes</source>
          <target state="translated">구문 클래스 표</target>
        </trans-unit>
        <trans-unit id="2d8d1919ef262467c56883c41a879af2fee55b4e" translate="yes" xml:space="preserve">
          <source>Table of syntax classes.</source>
          <target state="translated">구문 클래스 표.</target>
        </trans-unit>
        <trans-unit id="a8a2a45aa44b8d88ed7a93657b0370ab7c1b47d3" translate="yes" xml:space="preserve">
          <source>Tabulated List mode</source>
          <target state="translated">표 형식 목록 모드</target>
        </trans-unit>
        <trans-unit id="52c8bfd56e2fda412e0ed96bacdbda1556965513" translate="yes" xml:space="preserve">
          <source>Tabulated List mode is a major mode for displaying tabulated data, i.e., data consisting of &lt;em&gt;entries&lt;/em&gt;, each entry occupying one row of text with its contents divided into columns. Tabulated List mode provides facilities for pretty-printing rows and columns, and sorting the rows according to the values in each column. It is derived from Special mode (see &lt;a href=&quot;basic-major-modes#Basic-Major-Modes&quot;&gt;Basic Major Modes&lt;/a&gt;).</source>
          <target state="translated">표 형식 목록 모드는 표 형식 데이터, 즉 &lt;em&gt;항목&lt;/em&gt; 으로 구성된 데이터를 표시하는 주요 모드입니다 . 각 항목은 텍스트의 한 행을 차지하며 내용은 열로 나뉩니다. 표 형식 목록 모드는 행과 열을 예쁘게 인쇄하고 각 열의 값에 따라 행을 정렬하는 기능을 제공합니다. 특수 모드에서 파생됩니다 ( &lt;a href=&quot;basic-major-modes#Basic-Major-Modes&quot;&gt;기본 주요 모드&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="498560170e6db33d7983c6d161bdd46436b34341" translate="yes" xml:space="preserve">
          <source>Tabulated List mode is intended to be used as a parent mode by a more specialized major mode. Examples include Process Menu mode (see &lt;a href=&quot;process-information#Process-Information&quot;&gt;Process Information&lt;/a&gt;) and Package Menu mode (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Package-Menu.html#Package-Menu&quot;&gt;Package Menu&lt;/a&gt; in</source>
          <target state="translated">표 형식 목록 모드는보다 전문화 된 주 모드에서 상위 모드로 사용하기위한 것입니다. 예를 들면 프로세스 메뉴 모드 (참조 포함 &lt;a href=&quot;process-information#Process-Information&quot;&gt;프로세스 정보&lt;/a&gt; ) 및 패키지 메뉴 모드 (참조 &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Package-Menu.html#Package-Menu&quot;&gt;패키지 메뉴&lt;/a&gt; 에서</target>
        </trans-unit>
        <trans-unit id="c8f684048b11741d27f33f2d7764ece4796a5527" translate="yes" xml:space="preserve">
          <source>Take care to ensure that the specifications are known to Edebug when you instrument code. If you are instrumenting a function which uses a macro defined in another file, you may first need to either evaluate the &lt;code&gt;require&lt;/code&gt; forms in the file containing your function, or explicitly load the file containing the macro. If the definition of a macro is wrapped by &lt;code&gt;eval-when-compile&lt;/code&gt;, you may need to evaluate it.</source>
          <target state="translated">코드를 계측 할 때 Edebug가 사양을 알고 있는지 확인하십시오. 다른 파일에 정의 된 매크로를 사용하는 함수를 계측하는 경우 먼저 함수가 포함 된 파일에서 &lt;code&gt;require&lt;/code&gt; 양식을 평가 하거나 매크로가 포함 된 파일을 명시 적으로로드해야 할 수 있습니다. 매크로 정의가 &lt;code&gt;eval-when-compile&lt;/code&gt; 로 래핑 된 경우 평가해야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f97cd8471dd801f12b6230920fd1f2d023c055a" translate="yes" xml:space="preserve">
          <source>Technically, a right divider belongs to the window on its left, which means that its width contributes to the total width of that window. A bottom divider belongs to the window above it, which means that its width contributes to the total height of that window. See &lt;a href=&quot;window-sizes#Window-Sizes&quot;&gt;Window Sizes&lt;/a&gt;. When a window has both, a right and a bottom divider, the bottom divider prevails. This means that a bottom divider is drawn over the full total width of its window while the right divider ends above the bottom divider.</source>
          <target state="translated">기술적으로 오른쪽 구분선은 왼쪽 창에 속하며, 이는 너비가 해당 창의 전체 너비에 기여 함을 의미합니다. 하단 구분선은 그 위에있는 창에 속합니다. 즉, 너비가 해당 창의 전체 높이에 기여 함을 의미합니다. &lt;a href=&quot;window-sizes#Window-Sizes&quot;&gt;창 크기를&lt;/a&gt; 참조하십시오 . 창에 오른쪽 및 아래쪽 구분선이 모두있는 경우 하단 구분선이 우선합니다. 즉, 하단 구분선은 창의 전체 너비에 걸쳐 그려지고 오른쪽 구분선은 하단 구분선 위에서 끝납니다.</target>
        </trans-unit>
        <trans-unit id="703bed112f2bdff3a214f69e179b0387e0f27ed9" translate="yes" xml:space="preserve">
          <source>Technically, this function may be thought of as an atomic action performed in two steps: The first step removes &lt;var&gt;frame1&lt;/var&gt;&amp;rsquo;s window-system window from the display. The second step reinserts &lt;var&gt;frame1&lt;/var&gt;&amp;rsquo;s window into the display below (above if &lt;var&gt;above&lt;/var&gt; is true) that of &lt;var&gt;frame2&lt;/var&gt;. Hence the position of &lt;var&gt;frame2&lt;/var&gt; in its display&amp;rsquo;s Z (stacking) order relative to all other frames excluding &lt;var&gt;frame1&lt;/var&gt; remains unaltered.</source>
          <target state="translated">기술적으로이 함수는 두 단계로 수행되는 원자 적 작업으로 생각할 수 있습니다. 첫 번째 단계는 디스플레이에서 &lt;var&gt;frame1&lt;/var&gt; 의 창 시스템 창을 제거합니다. 두 번째 단계는 다시 삽입 &lt;var&gt;frame1&lt;/var&gt; 은 아래에 표시의 창 (위의 경우 &lt;var&gt;above&lt;/var&gt; 참)의 &lt;var&gt;frame2&lt;/var&gt; . 그래서 위치 &lt;var&gt;frame2&lt;/var&gt; 를 제외한 다른 모든 프레임의 디스플레이의 Z (적층) 순서에 대해 &lt;var&gt;frame1&lt;/var&gt; 변경되지 않고 유지된다.</target>
        </trans-unit>
        <trans-unit id="5834d97093438086bf86a5d34542961bd2778fb2" translate="yes" xml:space="preserve">
          <source>Tell &lt;var&gt;process&lt;/var&gt; that its logical window size has dimensions &lt;var&gt;width&lt;/var&gt; by &lt;var&gt;height&lt;/var&gt;, in character units. If this function succeeds in communicating this information to the process, it returns &lt;code&gt;t&lt;/code&gt;; otherwise it returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">주기 &lt;var&gt;process&lt;/var&gt; 논리 윈도우의 크기는 치수가 갖는 &lt;var&gt;width&lt;/var&gt; 으로 &lt;var&gt;height&lt;/var&gt; 문자 단위. 이 함수가이 정보를 프로세스에 전달하는 데 성공하면 &lt;code&gt;t&lt;/code&gt; 를 반환합니다 . 그렇지 않으면 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c12bc156c5db862b3ba4e07551778ad339e33f61" translate="yes" xml:space="preserve">
          <source>Tell the byte compiler to assume that &lt;var&gt;function&lt;/var&gt; is defined in the file &lt;var&gt;file&lt;/var&gt;. The optional third argument &lt;var&gt;arglist&lt;/var&gt; is either &lt;code&gt;t&lt;/code&gt;, meaning the argument list is unspecified, or a list of formal parameters in the same style as &lt;code&gt;defun&lt;/code&gt;. An omitted &lt;var&gt;arglist&lt;/var&gt; defaults to &lt;code&gt;t&lt;/code&gt;, not &lt;code&gt;nil&lt;/code&gt;; this is atypical behavior for omitted arguments, and it means that to supply a fourth but not third argument one must specify &lt;code&gt;t&lt;/code&gt; for the third-argument placeholder instead of the usual &lt;code&gt;nil&lt;/code&gt;. The optional fourth argument &lt;var&gt;fileonly&lt;/var&gt; non-&lt;code&gt;nil&lt;/code&gt; means check only that &lt;var&gt;file&lt;/var&gt; exists, not that it actually defines &lt;var&gt;function&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;function&lt;/var&gt; 가 파일 &lt;var&gt;file&lt;/var&gt; 정의되어 있다고 가정하도록 바이트 컴파일러에 지시 합니다 . 선택적 세 번째 인수 &lt;var&gt;arglist&lt;/var&gt; 는 &lt;code&gt;t&lt;/code&gt; , 즉 인수 목록이 지정되지 않았거나 &lt;code&gt;defun&lt;/code&gt; 과 동일한 스타일의 형식 매개 변수 목록입니다 . 생략 된 &lt;var&gt;arglist&lt;/var&gt; 의 기본값은 &lt;code&gt;nil&lt;/code&gt; 이 아니라 &lt;code&gt;t&lt;/code&gt; 입니다 . 이것은 생략 된 인수에 대한 비정형 동작이며, 이는 세 번째 인수가 아닌 네 번째 인수 를 제공하려면 일반적인 &lt;code&gt;nil&lt;/code&gt; 대신 세 번째 인수 자리 표시 자에 &lt;code&gt;t&lt;/code&gt; 를 지정해야 함을 의미합니다 . 선택적 네 번째 인수 &lt;var&gt;fileonly&lt;/var&gt; non- &lt;code&gt;nil&lt;/code&gt; 은 &lt;var&gt;file&lt;/var&gt; 실제로 &lt;var&gt;function&lt;/var&gt; 을 정의하는 것이 아니라 파일 이 존재 합니다 .</target>
        </trans-unit>
        <trans-unit id="5df56b1b343eb8daedec867960cd9bb06bd6b999" translate="yes" xml:space="preserve">
          <source>Telling the Compiler that a Function is Defined</source>
          <target state="translated">함수가 정의되었음을 컴파일러에 알리기</target>
        </trans-unit>
        <trans-unit id="de1d117584d30c59a72af26003e0d0a855151dc5" translate="yes" xml:space="preserve">
          <source>Telling the compiler that a function is defined.</source>
          <target state="translated">함수가 정의되었음을 컴파일러에 알립니다.</target>
        </trans-unit>
        <trans-unit id="3c79631699bb3023f4d474dc6291a1b94cff5905" translate="yes" xml:space="preserve">
          <source>Temporarily dedicating windows to their buffers (see &lt;a href=&quot;dedicated-windows#Dedicated-Windows&quot;&gt;Dedicated Windows&lt;/a&gt;) avoids using a window for displaying a different buffer. A non-dedicated window will be used instead.</source>
          <target state="translated">임시로 창을 해당 버퍼에 &lt;a href=&quot;dedicated-windows#Dedicated-Windows&quot;&gt;전용&lt;/a&gt; (전용 창 참조 )하면 다른 버퍼를 표시하기 위해 창을 사용하지 않습니다. 대신 전용 창이 아닌 창이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="112d19493096b154fc9ad3a3ab3ba206e50684df" translate="yes" xml:space="preserve">
          <source>Temporarily display the outside current buffer with point at its outside position (&lt;code&gt;edebug-bounce-point&lt;/code&gt;), pausing for one second before returning to Edebug. With a prefix argument &lt;var&gt;n&lt;/var&gt;, pause for &lt;var&gt;n&lt;/var&gt; seconds instead.</source>
          <target state="translated">외부 위치 ( &lt;code&gt;edebug-bounce-point&lt;/code&gt; )에 지점이 있는 외부 전류 버퍼를 일시적으로 표시하고 , Edebug로 돌아 가기 전에 1 초 동안 일시 중지합니다. 접두사 인수 &lt;var&gt;n&lt;/var&gt; 을 사용하면 대신 &lt;var&gt;n&lt;/var&gt; 초 동안 일시 중지 합니다.</target>
        </trans-unit>
        <trans-unit id="204bf73fadce843ac40f4d284ffae49d63cf6cdb" translate="yes" xml:space="preserve">
          <source>Temporary Displays</source>
          <target state="translated">임시 표시</target>
        </trans-unit>
        <trans-unit id="885e345267ec6790ab06207f2febf07060307ad4" translate="yes" xml:space="preserve">
          <source>Temporary conses and strings on C stack.</source>
          <target state="translated">C 스택의 임시 conses 및 문자열.</target>
        </trans-unit>
        <trans-unit id="638a660125130110a8ff9f3b688f9ab733656cf5" translate="yes" xml:space="preserve">
          <source>Temporary displays are used by Lisp programs to put output into a buffer and then present it to the user for perusal rather than for editing. Many help commands use this feature.</source>
          <target state="translated">Lisp 프로그램은 임시 디스플레이를 사용하여 출력을 버퍼에 넣은 다음 편집이 아닌 열람을 위해 사용자에게 제공합니다. 많은 도움말 명령이이 기능을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a8fbdc5c349b4448bfd30149ad8c0322c6319430" translate="yes" xml:space="preserve">
          <source>Temporary motion and buffer changes.</source>
          <target state="translated">일시적인 모션 및 버퍼 변경.</target>
        </trans-unit>
        <trans-unit id="8c4b4dd44090443b75c719146f69039a4de8291e" translate="yes" xml:space="preserve">
          <source>Terminal I/O Encoding</source>
          <target state="translated">터미널 I / O 인코딩</target>
        </trans-unit>
        <trans-unit id="e518d15cadbf25f6701100c9e664ae69e7991eac" translate="yes" xml:space="preserve">
          <source>Terminal Input</source>
          <target state="translated">터미널 입력</target>
        </trans-unit>
        <trans-unit id="11bcad1f9e713086d9e16b8089d00a33ed64d247" translate="yes" xml:space="preserve">
          <source>Terminal Output</source>
          <target state="translated">터미널 출력</target>
        </trans-unit>
        <trans-unit id="59f006175b8fe7e3164de6d9ad0fd6f00418fe75" translate="yes" xml:space="preserve">
          <source>Terminal Parameters</source>
          <target state="translated">터미널 매개 변수</target>
        </trans-unit>
        <trans-unit id="b779b73affbf24fad613fe28b563d45c5ff37645" translate="yes" xml:space="preserve">
          <source>Terminal Type</source>
          <target state="translated">터미널 유형</target>
        </trans-unit>
        <trans-unit id="3b6ffae10c84baf737fa6441cfeed7605132aebb" translate="yes" xml:space="preserve">
          <source>Terminal-Specific Initialization</source>
          <target state="translated">터미널 별 초기화</target>
        </trans-unit>
        <trans-unit id="7896da4078fb49476e0b8958441644e36b86ac99" translate="yes" xml:space="preserve">
          <source>Terminals have no read syntax. They print in hash notation giving the terminal&amp;rsquo;s ordinal number and its TTY device file name.</source>
          <target state="translated">터미널에는 읽기 구문이 없습니다. 터미널의 서수와 TTY 장치 파일 이름을 제공하는 해시 표기법으로 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="88ffd1abfd18a3b86bf88447a1b5a3e97e14d62d" translate="yes" xml:space="preserve">
          <source>Terminate the program being debugged; return to top-level Emacs command execution.</source>
          <target state="translated">디버깅중인 프로그램을 종료하십시오. 최상위 Emacs 명령 실행으로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="a89b0dbcd302d4f9ba9ec7aca5a0f8a1ccc06a1a" translate="yes" xml:space="preserve">
          <source>Test Coverage</source>
          <target state="translated">테스트 범위</target>
        </trans-unit>
        <trans-unit id="03751596a5fb1a6a9c8670a0a29a5b074902945a" translate="yes" xml:space="preserve">
          <source>Testing Accessibility</source>
          <target state="translated">접근성 테스트</target>
        </trans-unit>
        <trans-unit id="da8948ee42cc0425d8ae2fab4e1fb0099dc30642" translate="yes" xml:space="preserve">
          <source>Testing Availability of Network Features</source>
          <target state="translated">네트워크 기능의 가용성 테스트</target>
        </trans-unit>
        <trans-unit id="d8d4dbd1a23f08fe554bc1a36408ea01da82c375" translate="yes" xml:space="preserve">
          <source>Testing existence, accessibility, size of files.</source>
          <target state="translated">파일의 존재, 접근성, 크기를 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="5eef48dce3886f67bf29572279a1d8c01513dd7e" translate="yes" xml:space="preserve">
          <source>Testing for numbers.</source>
          <target state="translated">숫자 테스트.</target>
        </trans-unit>
        <trans-unit id="69e02e42d50ebc840818a24261a4c38b29c09cd4" translate="yes" xml:space="preserve">
          <source>Testing whether an object is a marker.</source>
          <target state="translated">개체가 마커인지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="1af17a7f62df0b849a55bd3092c5d244b3f00a14" translate="yes" xml:space="preserve">
          <source>Testing whether an object is a string or char.</source>
          <target state="translated">객체가 문자열인지 문자인지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="a2ed0523781be8c76de933cdc16fb68427dc7f9f" translate="yes" xml:space="preserve">
          <source>Tests of equality between any two objects.</source>
          <target state="translated">두 개체 간의 동등성 테스트.</target>
        </trans-unit>
        <trans-unit id="6e3d8ffc0e534d8e43ad86a7d530e868b23593b6" translate="yes" xml:space="preserve">
          <source>Tests related to types.</source>
          <target state="translated">유형과 관련된 테스트.</target>
        </trans-unit>
        <trans-unit id="f45b4f0fb4f2822335c780c335891ff82850deb9" translate="yes" xml:space="preserve">
          <source>Texinfo</source>
          <target state="translated">Texinfo</target>
        </trans-unit>
        <trans-unit id="c3328c39b0e29f78e9ff45db674248b1d245887d" translate="yes" xml:space="preserve">
          <source>Text</source>
          <target state="translated">Text</target>
        </trans-unit>
        <trans-unit id="87a0562fa90309b524364e483951efe8af5cf185" translate="yes" xml:space="preserve">
          <source>Text Area</source>
          <target state="translated">텍스트 영역</target>
        </trans-unit>
        <trans-unit id="cab6f246e70a36aae141ac1b47f69051720f2342" translate="yes" xml:space="preserve">
          <source>Text Properties</source>
          <target state="translated">텍스트 속성</target>
        </trans-unit>
        <trans-unit id="b2b6482ac0db1130facf9df3d33260d44db222c6" translate="yes" xml:space="preserve">
          <source>Text Properties in Strings</source>
          <target state="translated">문자열의 텍스트 속성</target>
        </trans-unit>
        <trans-unit id="0203d97471cea7f0f9e87edf9c61812f9ed352fe" translate="yes" xml:space="preserve">
          <source>Text Property Search Functions</source>
          <target state="translated">텍스트 속성 검색 기능</target>
        </trans-unit>
        <trans-unit id="e2a1fdf371ef3e66e34eae2fac3b0b1a33d7c25e" translate="yes" xml:space="preserve">
          <source>Text Quoting Style</source>
          <target state="translated">텍스트 인용 스타일</target>
        </trans-unit>
        <trans-unit id="8ad1a0374eb3bf2b5f56dc4ed7649f748c78347b" translate="yes" xml:space="preserve">
          <source>Text Representations</source>
          <target state="translated">텍스트 표현</target>
        </trans-unit>
        <trans-unit id="382c95e23dc844e5ef1273fcbaec3dfb1687c262" translate="yes" xml:space="preserve">
          <source>Text Terminal Colors</source>
          <target state="translated">텍스트 터미널 색상</target>
        </trans-unit>
        <trans-unit id="015b197bbe54de5242507dc93ed1884dafc41845" translate="yes" xml:space="preserve">
          <source>Text covered by &lt;code&gt;display&lt;/code&gt; text properties, by overlays with &lt;code&gt;display&lt;/code&gt; properties whose value is a string, and by any other properties that replace buffer text, is treated as a single unit when it is reordered for display. That is, the entire chunk of text covered by these properties is reordered together. Moreover, the bidirectional properties of the characters in such a chunk of text are ignored, and Emacs reorders them as if they were replaced with a single character &lt;code&gt;U+FFFC&lt;/code&gt;, known as the &lt;em&gt;Object Replacement Character&lt;/em&gt;. This means that placing a display property over a portion of text may change the way that the surrounding text is reordered for display. To prevent this unexpected effect, always place such properties on text whose directionality is identical with text that surrounds it.</source>
          <target state="translated">적용 텍스트 &lt;code&gt;display&lt;/code&gt; 에 오버레이하여 텍스트 속성 &lt;code&gt;display&lt;/code&gt; 값이 속성은 문자열이며, 텍스트 버퍼 대체 다른 특성으로, 이는 디스플레이를 위해 재 배열되어 하나의 단위로 취급된다. 즉, 이러한 속성에 포함 된 전체 텍스트 청크가 함께 재정렬됩니다. 또한 이러한 텍스트 청크에서 문자의 양방향 속성은 무시되고 Emacs는 &lt;em&gt;객체 교체 문자&lt;/em&gt; 로 알려진 단일 문자 &lt;code&gt;U+FFFC&lt;/code&gt; 로 교체 된 것처럼 이들을 재정렬합니다.&lt;em&gt;&lt;/em&gt;. 즉, 텍스트 부분 위에 표시 속성을 배치하면 표시를 위해 주변 텍스트가 재정렬되는 방식이 변경 될 수 있습니다. 이러한 예상치 못한 효과를 방지하려면 방향성이 주변 텍스트와 동일한 텍스트에 항상 이러한 속성을 배치하십시오.</target>
        </trans-unit>
        <trans-unit id="1ad9759337a6a9038a2e7770ed58fa8870c7e97c" translate="yes" xml:space="preserve">
          <source>Text is read-only</source>
          <target state="translated">텍스트는 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="9a6eb4a9bf5716c42c83626704dad83699495ba5" translate="yes" xml:space="preserve">
          <source>Text is stored in Emacs buffers and strings in &lt;em&gt;logical&lt;/em&gt; (or &lt;em&gt;reading&lt;/em&gt;) order, i.e., the order in which a human would read each character. In right-to-left and bidirectional text, the order in which characters are displayed on the screen (called &lt;em&gt;visual order&lt;/em&gt;) is not the same as logical order; the characters&amp;rsquo; screen positions do not increase monotonically with string or buffer position. In performing this &lt;em&gt;bidirectional reordering&lt;/em&gt;, Emacs follows the Unicode Bidirectional Algorithm (a.k.a.</source>
          <target state="translated">텍스트는 &lt;em&gt;논리적&lt;/em&gt; (또는 &lt;em&gt;읽기&lt;/em&gt; ) 순서, 즉 인간이 각 문자를 읽는 순서 로 Emacs 버퍼와 문자열에 저장됩니다 . 오른쪽에서 왼쪽 및 양방향 텍스트에서 문자가 화면에 표시되는 &lt;em&gt;순서&lt;/em&gt; ( &lt;em&gt;시각적 순서&lt;/em&gt; 라고 함 )는 논리적 순서와 동일하지 않습니다. 캐릭터의 화면 위치는 문자열 또는 버퍼 위치에 따라 단조롭게 증가하지 않습니다. 이 &lt;em&gt;양방향 재정렬을&lt;/em&gt; 수행 할 때 Emacs는 Unicode Bidirectional Algorithm (일명</target>
        </trans-unit>
        <trans-unit id="cc87b41df7acde763452d7cdb5ae6ca0354ef8ae" translate="yes" xml:space="preserve">
          <source>Text lines are portions of the buffer delimited by newline characters, which are regarded as part of the previous line. The first text line begins at the beginning of the buffer, and the last text line ends at the end of the buffer whether or not the last character is a newline. The division of the buffer into text lines is not affected by the width of the window, by line continuation in display, or by how tabs and control characters are displayed.</source>
          <target state="translated">텍스트 행은 이전 행의 일부로 간주되는 개행 문자로 구분 된 버퍼의 일부입니다. 첫 번째 텍스트 줄은 버퍼의 시작 부분에서 시작하고 마지막 텍스트 줄은 마지막 문자가 개행 문자인지 여부에 관계없이 버퍼 끝에서 끝납니다. 버퍼를 텍스트 줄로 나누는 것은 창의 너비, 디스플레이의 줄 연속 또는 탭과 제어 문자가 표시되는 방식의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c6f3ab88d6206b25d3f1bd4b23a42dfc4e2125ac" translate="yes" xml:space="preserve">
          <source>Text mode and Lisp modes.</source>
          <target state="translated">텍스트 모드 및 Lisp 모드.</target>
        </trans-unit>
        <trans-unit id="d4dee9134d8f17e940ea640096421469faf682b3" translate="yes" xml:space="preserve">
          <source>Text mode is a major mode for editing human languages. It defines the &amp;lsquo;</source>
          <target state="translated">텍스트 모드는 인간 언어를 편집하기위한 주요 모드입니다. 그것은 '</target>
        </trans-unit>
        <trans-unit id="dfd75aa64722dfbe6f81a4a1dd09e0e0bd805010" translate="yes" xml:space="preserve">
          <source>Text mode is perhaps the simplest mode besides Fundamental mode. Here are excerpts from</source>
          <target state="translated">텍스트 모드는 기본 모드 외에 가장 간단한 모드 일 것입니다. 다음은 발췌 내용입니다.</target>
        </trans-unit>
        <trans-unit id="e542f92e46dea1aaed3020c3fc9ad84772b03042" translate="yes" xml:space="preserve">
          <source>Text properties also support the &lt;code&gt;modification-hooks&lt;/code&gt; property, but the details are somewhat different (see &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Special Properties&lt;/a&gt;).</source>
          <target state="translated">텍스트 속성도 &lt;code&gt;modification-hooks&lt;/code&gt; 속성을 지원 하지만 세부 사항은 약간 다릅니다 ( &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;특수 속성&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="6d0a9b467cc2388cf3c12708c4d04ff0102f37d9" translate="yes" xml:space="preserve">
          <source>Text properties are also potential loopholes, since their values could include functions to call. So Emacs discards all text properties from string values specified for file-local variables.</source>
          <target state="translated">텍스트 속성은 값이 호출 할 함수를 포함 할 수 있기 때문에 잠재적 인 허점입니다. 따라서 Emacs는 파일 로컬 변수에 지정된 문자열 값에서 모든 텍스트 속성을 버립니다.</target>
        </trans-unit>
        <trans-unit id="9d6234ac8ad7e0e9762eab32a2e86e6b1e823934" translate="yes" xml:space="preserve">
          <source>Text properties are considered a part of the text; overlays and their properties are specifically considered not to be part of the text. Thus, copying text between various buffers and strings preserves text properties, but does not try to preserve overlays. Changing a buffer&amp;rsquo;s text properties marks the buffer as modified, while moving an overlay or changing its properties does not. Unlike text property changes, overlay property changes are not recorded in the buffer&amp;rsquo;s undo list.</source>
          <target state="translated">텍스트 속성은 텍스트의 일부로 간주됩니다. 오버레이와 그 속성은 특히 텍스트의 일부가 아닌 것으로 간주됩니다. 따라서 다양한 버퍼와 문자열간에 텍스트를 복사하면 텍스트 속성이 유지되지만 오버레이는 유지되지 않습니다. 버퍼의 텍스트 속성을 변경하면 버퍼가 수정 된 것으로 표시되지만 오버레이를 이동하거나 속성을 변경하면 버퍼가 수정되지 않습니다. 텍스트 속성 변경과 달리 오버레이 속성 변경은 버퍼의 실행 취소 목록에 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6f74c7cc06988da062ed2b24126fb9eddd682788" translate="yes" xml:space="preserve">
          <source>Text terminals usually support only a small number of colors, and the computer uses small integers to select colors on the terminal. This means that the computer cannot reliably tell what the selected color looks like; instead, you have to inform your application which small integers correspond to which colors. However, Emacs does know the standard set of colors and will try to use them automatically.</source>
          <target state="translated">텍스트 터미널은 일반적으로 적은 수의 색상 만 지원하며 컴퓨터는 작은 정수를 사용하여 터미널에서 색상을 선택합니다. 이것은 컴퓨터가 선택한 색상이 어떻게 생겼는지 확실하게 말할 수 없음을 의미합니다. 대신 어떤 작은 정수가 어떤 색에 해당하는지 응용 프로그램에 알려야합니다. 그러나 Emacs는 표준 색상 세트를 알고 있으며 자동으로 사용하려고합니다.</target>
        </trans-unit>
        <trans-unit id="ff12dc73eb86a83b96f6fd94cd3a8c784b8cfb98" translate="yes" xml:space="preserve">
          <source>Textual Scrolling</source>
          <target state="translated">텍스트 스크롤</target>
        </trans-unit>
        <trans-unit id="8a741234fa57cb0334cb69e5c77a86c370043e5c" translate="yes" xml:space="preserve">
          <source>Textual scrolling functions (aside from &lt;code&gt;scroll-other-window&lt;/code&gt;) have unpredictable results if the current buffer is not the one displayed in the selected window. See &lt;a href=&quot;current-buffer#Current-Buffer&quot;&gt;Current Buffer&lt;/a&gt;.</source>
          <target state="translated">현재 버퍼가 선택한 창에 표시된 버퍼가 아닌 경우 텍스트 스크롤 기능 ( &lt;code&gt;scroll-other-window&lt;/code&gt; 제외)은 예측할 수없는 결과를 가져옵니다. &lt;a href=&quot;current-buffer#Current-Buffer&quot;&gt;현재 버퍼를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a8b0e7fb130776cf6ea8a938fc9ede74c81c65d4" translate="yes" xml:space="preserve">
          <source>That is, the &amp;ldquo;bold&amp;rdquo; words are the &lt;code&gt;bold&lt;/code&gt; face, and the &amp;ldquo;italic&amp;rdquo; word is in the &lt;code&gt;italic&lt;/code&gt; face.</source>
          <target state="translated">즉, &quot;bold&quot;단어는 &lt;code&gt;bold&lt;/code&gt; 얼굴이고 &quot;italic&quot;단어는 &lt;code&gt;italic&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7430a06da8c38762d75fab964293afaabef9af91" translate="yes" xml:space="preserve">
          <source>That last form can be used as &lt;var&gt;action&lt;/var&gt; argument of &lt;code&gt;display-buffer&lt;/code&gt; in the following way:</source>
          <target state="translated">마지막 형식은 다음과 같은 방식으로 &lt;code&gt;display-buffer&lt;/code&gt; 의 &lt;var&gt;action&lt;/var&gt; 인수 로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4c876d6e3a4a2df4b2e97076c563bcbda17e6f74" translate="yes" xml:space="preserve">
          <source>That lets the user specify a height value optionally and a width value optionally.</source>
          <target state="translated">이를 통해 사용자는 높이 값을 선택적으로 지정하고 너비 값을 선택적으로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="0ed4c9f9933dd9e4b8da3ca824145866c18f6a63" translate="yes" xml:space="preserve">
          <source>The &amp;lsquo;</source>
          <target state="translated">'</target>
        </trans-unit>
        <trans-unit id="5ff30588f2ea9f6154e9ab9ac554867c70e9717f" translate="yes" xml:space="preserve">
          <source>The 2**22 bit in the character event code indicates a character typed with the alt key held down. (The key labeled</source>
          <target state="translated">문자 이벤트 코드의 2 ** 22 비트는 Alt 키를 누른 상태에서 입력 한 문자를 나타냅니다. (표시된 키</target>
        </trans-unit>
        <trans-unit id="38975ff8c63f29a11434d9ffa76a663862efe213" translate="yes" xml:space="preserve">
          <source>The 2**23 bit in the character event code indicates a character typed with the super key held down.</source>
          <target state="translated">문자 이벤트 코드의 2 ** 23 비트는 수퍼 키를 누른 상태에서 입력 한 문자를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a46377d522c8c3976b822282db080ff137867c82" translate="yes" xml:space="preserve">
          <source>The 2**24 bit in the character event code indicates a character typed with the hyper key held down.</source>
          <target state="translated">문자 이벤트 코드의 2 ** 24 비트는 하이퍼 키를 누른 상태에서 입력 한 문자를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="cb443747876c5a79973dac02d3a7cd79f8cba32c" translate="yes" xml:space="preserve">
          <source>The 2**25 bit (the 26th bit) in the character event code indicates an</source>
          <target state="translated">문자 이벤트 코드의 2 ** 25 비트 (26 번째 비트)는</target>
        </trans-unit>
        <trans-unit id="d84cc0fb922803f23690da8e9b0d5a8328dc7acb" translate="yes" xml:space="preserve">
          <source>The 2**26 bit in the character code indicates a non-</source>
          <target state="translated">문자 코드의 2 ** 26 비트는</target>
        </trans-unit>
        <trans-unit id="a0f9cc26fb8eabe38b036b9be91a04cbf27fc5a6" translate="yes" xml:space="preserve">
          <source>The 2**27 bit in the character code indicates a character typed with the meta key held down.</source>
          <target state="translated">문자 코드의 2 ** 27 비트는 메타 키를 누른 상태에서 입력 한 문자를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="24ee70c53e17015b7f27a3b207abd795d4f0cc63" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;(&quot;(&quot; exps &quot;)&quot;)&lt;/code&gt; rule was not needed to pair up parens, since SMIE will pair up any characters that are marked as having paren syntax in the syntax table. What this rule does instead (together with the definition of &lt;code&gt;exps&lt;/code&gt;) is to make it clear that &lt;code&gt;&quot;,&quot;&lt;/code&gt; should not appear outside of parentheses.</source>
          <target state="translated">&lt;code&gt;(&quot;(&quot; exps &quot;)&quot;)&lt;/code&gt; SMIE 구문 테이블에 괄호 구문이있는 것으로 표시된 모든 문자를 짝 때문에 규칙, 괄호를 페어링이 필요하지 않았다. 대신이 규칙이 수행하는 작업 ( &lt;code&gt;exps&lt;/code&gt; 의 정의와 함께 )은 &lt;code&gt;&quot;,&quot;&lt;/code&gt; 가 괄호 밖에 나타나지 않아야 함을 명확히하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="7d3eb0602e766d794ddd5a23c3f8b6d078da78b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-&lt;/code&gt; function serves two purposes: negation and subtraction. When &lt;code&gt;-&lt;/code&gt; has a single argument, the value is the negative of the argument. When there are multiple arguments, &lt;code&gt;-&lt;/code&gt; subtracts each of the &lt;var&gt;more-numbers-or-markers&lt;/var&gt; from &lt;var&gt;number-or-marker&lt;/var&gt;, cumulatively. If there are no arguments, the result is 0.</source>
          <target state="translated">&lt;code&gt;-&lt;/code&gt; 부정과 뺄셈 : 함수는 두 가지 용도로 사용됩니다. 때 &lt;code&gt;-&lt;/code&gt; 하나의 인자를 가지고, 값은 인수의 부정적이다. 인수가 여러 개인 경우 &lt;code&gt;-&lt;/code&gt; 는 &lt;var&gt;more-numbers-or-markers&lt;/var&gt; 에서 각 추가 숫자 &lt;var&gt;number-or-marker&lt;/var&gt; 를 누적 하여 뺍니다 . 인수가 없으면 결과는 0입니다.</target>
        </trans-unit>
        <trans-unit id="dee3a47909b932498958ccca8e33a6ead189f5e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:advertised-binding&lt;/code&gt; property also affects the binding shown in menu items (see &lt;a href=&quot;menu-bar#Menu-Bar&quot;&gt;Menu Bar&lt;/a&gt;). The property is ignored if it specifies a key binding that the command does not actually have.</source>
          <target state="translated">&lt;code&gt;:advertised-binding&lt;/code&gt; 속성은 또한이 메뉴 항목 (참조에 표시된 바인딩에 영향을 &lt;a href=&quot;menu-bar#Menu-Bar&quot;&gt;메뉴 바&lt;/a&gt; ). 명령에 실제로 포함되지 않은 키 바인딩을 지정하면 속성이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="1882ca53c4043e647ef4b5684792d2bf1128e1a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:deferred&lt;/code&gt; keyword argument to &lt;code&gt;jsonrpc-request&lt;/code&gt; and &lt;code&gt;jsonrpc-async-request&lt;/code&gt; is designed to let the caller indicate that the specific request needs synchronization and its actual issuance may be delayed to the future, until some condition is satisfied. Specifying &lt;code&gt;:deferred&lt;/code&gt; for a request doesn&amp;rsquo;t mean it &lt;em&gt;will&lt;/em&gt; be delayed, only that it &lt;em&gt;can&lt;/em&gt; be. If the request isn&amp;rsquo;t sent immediately, &lt;code&gt;jsonrpc&lt;/code&gt; will make renewed efforts to send it at certain key times during communication, such as when receiving or sending other messages to the endpoint.</source>
          <target state="translated">&lt;code&gt;jsonrpc-request&lt;/code&gt; 및 &lt;code&gt;jsonrpc-async-request&lt;/code&gt; 에 대한 &lt;code&gt;:deferred&lt;/code&gt; 키워드 인수 는 호출자가 특정 요청에 동기화가 필요하고 일부 조건이 충족 될 때까지 실제 발급이 미래로 지연 될 수 있음을 나타낼 수 있도록 설계되었습니다. 지정 &lt;code&gt;:deferred&lt;/code&gt; 요청에 대해 그것이 의미하지 않는 &lt;em&gt;것&lt;/em&gt; 그것은 단지 것을 지연 될 &lt;em&gt;수 있습니다&lt;/em&gt; 합니다. 요청이 즉시 전송되지 않으면 &lt;code&gt;jsonrpc&lt;/code&gt; 는 엔드 포인트로 다른 메시지를 수신하거나 전송할 때와 같이 통신 중 특정 키 시간에 요청을 전송하기 위해 새롭게 노력합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9d39209831baabc8b831f50e0409fe8adb0807e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:help&lt;/code&gt; property specifies a help-echo string to display while the mouse is on that item. This is displayed in the same way as &lt;code&gt;help-echo&lt;/code&gt; text properties (see &lt;a href=&quot;special-properties#Help-display&quot;&gt;Help display&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;:help&lt;/code&gt; 마우스를 해당 항목에있는 동안 속성은 디스플레이에 도움 에코 문자열을 지정합니다. 이것은 &lt;code&gt;help-echo&lt;/code&gt; 텍스트 속성 과 같은 방식으로 표시됩니다 ( &lt;a href=&quot;special-properties#Help-display&quot;&gt;도움말 표시&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="d3dade1abb3b9c8790fadfc96040530f91f00991" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:inline&lt;/code&gt; feature lets you splice a variable number of elements into the middle of a &lt;code&gt;list&lt;/code&gt; or &lt;code&gt;vector&lt;/code&gt; customization type. You use it by adding &lt;code&gt;:inline t&lt;/code&gt; to a type specification which is contained in a &lt;code&gt;list&lt;/code&gt; or &lt;code&gt;vector&lt;/code&gt; specification.</source>
          <target state="translated">&lt;code&gt;:inline&lt;/code&gt; 기능을 사용하면 중간에 요소의 변수 번호를 스플 라이스 할 &lt;code&gt;list&lt;/code&gt; 또는 &lt;code&gt;vector&lt;/code&gt; 사용자 정의 유형입니다. &lt;code&gt;list&lt;/code&gt; 또는 &lt;code&gt;vector&lt;/code&gt; 사양에 포함 된 유형 사양에 &lt;code&gt;:inline t&lt;/code&gt; 를 추가하여 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="bfc189fd6a2dcae80441078e4b002d4e31ccd61f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:max-width&lt;/code&gt; and &lt;code&gt;:max-height&lt;/code&gt; keywords are used for scaling if the size of the image exceeds these values. If &lt;code&gt;:width&lt;/code&gt; is set, it will have precedence over &lt;code&gt;max-width&lt;/code&gt;, and if &lt;code&gt;:height&lt;/code&gt; is set, it will have precedence over &lt;code&gt;max-height&lt;/code&gt;, but you can otherwise mix these keywords as you wish.</source>
          <target state="translated">&lt;code&gt;:max-width&lt;/code&gt; 과 &lt;code&gt;:max-height&lt;/code&gt; 키워드는 이미지의 크기가이 값을 초과하면, 스케일링에 사용된다. 경우 &lt;code&gt;:width&lt;/code&gt; 설정되어, 그것보다 우선해야합니다 &lt;code&gt;max-width&lt;/code&gt; 하고있는 경우 &lt;code&gt;:height&lt;/code&gt; 설정, 그것은보다 우선해야합니다 &lt;code&gt;max-height&lt;/code&gt; 하지만, 당신이 원하는대로 당신은 다른 키워드를 혼합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9b06cb01b0dc998d981d7869a904792bbe31f03" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:rtl&lt;/code&gt; property specifies an alternative image to use for right-to-left languages. Only the GTK+ version of Emacs supports this at present.</source>
          <target state="translated">&lt;code&gt;:rtl&lt;/code&gt; 속성은 오른쪽에서 왼쪽으로 쓰는 언어를 사용하는 대신 이미지를 지정합니다. 현재 GTK + 버전의 Emacs만이이를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="c169ab5cd21a44a39207c218cf98e3315f8f1bc1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:width&lt;/code&gt; and &lt;code&gt;:align-to&lt;/code&gt; properties are supported on non-graphic terminals, but the other space properties in this section are not.</source>
          <target state="translated">&lt;code&gt;:width&lt;/code&gt; 과 &lt;code&gt;:align-to&lt;/code&gt; 특성 비 그래픽 단말기에서 지원되지만,이 섹션의 다른 공간 속성은 없다.</target>
        </trans-unit>
        <trans-unit id="1b3a5aeae5cf6e988d703b1a5e7837aeb615f5a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:width&lt;/code&gt; and &lt;code&gt;:height&lt;/code&gt; keywords are used for scaling the image. If only one of them is specified, the other one will be calculated so as to preserve the aspect ratio. If both are specified, aspect ratio may not be preserved.</source>
          <target state="translated">&lt;code&gt;:width&lt;/code&gt; 과 &lt;code&gt;:height&lt;/code&gt; 키워드가 이미지를 확장하는 데 사용됩니다. 둘 중 하나만 지정하면 가로 세로 비율을 유지하기 위해 다른 하나가 계산됩니다. 둘 다 지정하면 종횡비가 유지되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98439a61b5465911aa8bc125062739f9432a86eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;add-face-text-property&lt;/code&gt; function provides a convenient way to set this text property. See &lt;a href=&quot;changing-properties#Changing-Properties&quot;&gt;Changing Properties&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;add-face-text-property&lt;/code&gt; 기능이 텍스트 속성을 설정하는 편리한 방법을 제공합니다. &lt;a href=&quot;changing-properties#Changing-Properties&quot;&gt;속성 변경을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cd4e2e754506706afd7c9e246beb160bb480f467" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;alpha&lt;/code&gt; frame parameter can also be a cons cell &lt;code&gt;(&lt;var&gt;active&lt;/var&gt; . &lt;var&gt;inactive&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;active&lt;/var&gt; is the opacity of the frame when it is selected, and &lt;var&gt;inactive&lt;/var&gt; is the opacity when it is not selected.</source>
          <target state="translated">&lt;code&gt;alpha&lt;/code&gt; 프레임 파라미터는 또한 반대 세포 일 수있다 &lt;code&gt;(&lt;var&gt;active&lt;/var&gt; . &lt;var&gt;inactive&lt;/var&gt;)&lt;/code&gt; , 여기서 &lt;var&gt;active&lt;/var&gt; 선택하면 그 프레임의 불투명도이며 &lt;var&gt;inactive&lt;/var&gt; 선택되어 있지 불투명도이다.</target>
        </trans-unit>
        <trans-unit id="3cb3daaa7062a39e07e8493532e6ecf57d731436" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;and&lt;/code&gt; special form tests whether all the &lt;var&gt;conditions&lt;/var&gt; are true. It works by evaluating the &lt;var&gt;conditions&lt;/var&gt; one by one in the order written.</source>
          <target state="translated">&lt;code&gt;and&lt;/code&gt; 특수 형태의 시험을 모두 여부를 &lt;var&gt;conditions&lt;/var&gt; 사실이다. 작성된 순서대로 &lt;var&gt;conditions&lt;/var&gt; 하나씩 평가하여 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="19ff15c393043a9219761a4b88424de8e7fcd4d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;append&lt;/code&gt; function also provides a way to convert a vector into a list with the same elements:</source>
          <target state="translated">&lt;code&gt;append&lt;/code&gt; 기능은 같은 요소리스트로 벡터를 변환하는 방법을 제공합니다 :</target>
        </trans-unit>
        <trans-unit id="ec4feeecd8f21172cf3ce375cb9b4b75af9ca6c6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;buffer-name&lt;/code&gt; of a buffer is &lt;code&gt;nil&lt;/code&gt; if, and only if, the buffer is killed. A buffer that has not been killed is called a &lt;em&gt;live&lt;/em&gt; buffer. To test whether a buffer is live or killed, use the function &lt;code&gt;buffer-live-p&lt;/code&gt; (see below).</source>
          <target state="translated">&lt;code&gt;buffer-name&lt;/code&gt; 의 버퍼 이름 은 버퍼가 종료 된 경우에만 &lt;code&gt;nil&lt;/code&gt; 입니다. 종료되지 않은 버퍼를 &lt;em&gt;라이브&lt;/em&gt; 버퍼 라고합니다 . 버퍼가 활성 상태인지 아니면 종료되었는지 테스트하려면 &lt;code&gt;buffer-live-p&lt;/code&gt; 함수를 사용 하십시오 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="1bf11efbba3f5b738c403068ce4165ac4eda8d18" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cl-case&lt;/code&gt; macro chooses among alternatives by evaluating the equality of its first argument against a set of specific values.</source>
          <target state="translated">&lt;code&gt;cl-case&lt;/code&gt; 특정 값들의 집합에 대해 첫 번째 인자의 동등성을 평가 대안 중에서 매크로 선택한다.</target>
        </trans-unit>
        <trans-unit id="26f0cd6f24bb7ebd0d3d8ca59b36aac1c1707035" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;completing-read&lt;/code&gt; function binds variables to pass information to the commands that actually do completion. They are described in the following section.</source>
          <target state="translated">&lt;code&gt;completing-read&lt;/code&gt; 기능 바인딩 변수는 실제로 완료 할 명령에 정보를 전달합니다. 다음 섹션에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="c44c9a88addda9d5f8cbe1e09d1ef3e5332b9502" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond&lt;/code&gt; form chooses among alternatives by evaluating the predicate &lt;var&gt;condition&lt;/var&gt; of each of its clauses (see &lt;a href=&quot;conditionals#Conditionals&quot;&gt;Conditionals&lt;/a&gt;). The primary limitation is that variables let-bound in &lt;var&gt;condition&lt;/var&gt; are not available to the clause&amp;rsquo;s &lt;var&gt;body-forms&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;cond&lt;/code&gt; 조건부 평가함으로써 대안 중에서 선택한다면 형성 &lt;var&gt;condition&lt;/var&gt; 의 각 조항을 (참조 &lt;a href=&quot;conditionals#Conditionals&quot;&gt;조건문&lt;/a&gt; ). 주요 제한 사항은 &lt;var&gt;condition&lt;/var&gt; let-bound 변수 를 절의 &lt;var&gt;body-forms&lt;/var&gt; 에서 사용할 수 없다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="b6393d60a04e97f2116a36bf3d96d9009bda8c39" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;condition-case&lt;/code&gt; construct is often used to trap errors that are predictable, such as failure to open a file in a call to &lt;code&gt;insert-file-contents&lt;/code&gt;. It is also used to trap errors that are totally unpredictable, such as when the program evaluates an expression read from the user.</source>
          <target state="translated">&lt;code&gt;condition-case&lt;/code&gt; 구조는 종종에 대한 호출에서 파일을 엽니 다 실패로 예측 가능 트랩 오류에 사용되는 &lt;code&gt;insert-file-contents&lt;/code&gt; . 또한 프로그램이 사용자로부터 읽은 표현식을 평가할 때와 같이 완전히 예측할 수없는 오류를 트랩하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4e29405e0f1f6c37ab826a1f70ab932f0440abc5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;current-input-mode&lt;/code&gt; function returns the input mode settings Emacs is currently using.</source>
          <target state="translated">&lt;code&gt;current-input-mode&lt;/code&gt; 기능은 이맥스가 현재 사용하고 입력 모드 설정을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c234a92b19642441da1c2050b96be5c7305c6b87" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cursor-type&lt;/code&gt; frame parameter may be overridden by the variables &lt;code&gt;cursor-type&lt;/code&gt; and &lt;code&gt;cursor-in-non-selected-windows&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;cursor-type&lt;/code&gt; 프레임 파라미터를 변수로 대체 할 수 &lt;code&gt;cursor-type&lt;/code&gt; 과 &lt;code&gt;cursor-in-non-selected-windows&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="abe114d18cfa0ebfe62ff688cbe3eb7244ed6f72" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;defconst&lt;/code&gt; form, like &lt;code&gt;defvar&lt;/code&gt;, marks the variable as &lt;em&gt;special&lt;/em&gt;, meaning that it should always be dynamically bound (see &lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;Variable Scoping&lt;/a&gt;). In addition, it marks the variable as risky (see &lt;a href=&quot;file-local-variables#File-Local-Variables&quot;&gt;File Local Variables&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;defconst&lt;/code&gt; 의 형태는 같은 &lt;code&gt;defvar&lt;/code&gt; , 마크 등의 변수 &lt;em&gt;특별한&lt;/em&gt; 이 항상 동적 바인딩해야한다는 의미는, (참조 &lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;변수 범위 지정을&lt;/a&gt; ). 또한 변수를 위험한 것으로 표시합니다 ( &lt;a href=&quot;file-local-variables#File-Local-Variables&quot;&gt;파일 로컬 변수&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="64e40c8d2d701d73f72f1726b04f6361773a945c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;defcustom&lt;/code&gt; shows how the new widget can be used as an ordinary customization type.</source>
          <target state="translated">&lt;code&gt;defcustom&lt;/code&gt; 의 새로운 위젯이 일반 사용자 정의 유형으로 사용하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="c71b39c3926065d439068fcf1de8b785d9704dac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;define-derived-mode&lt;/code&gt; macro automatically marks the derived mode as special if the parent mode is special. Special mode is a convenient parent for such modes to inherit from; See &lt;a href=&quot;basic-major-modes#Basic-Major-Modes&quot;&gt;Basic Major Modes&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;define-derived-mode&lt;/code&gt; 매크로가 자동으로 표시 특별으로 파생 된 모드를 부모 모드가 특별합니다. 특수 모드는 이러한 모드를 상속하기에 편리한 상위 모드입니다. &lt;a href=&quot;basic-major-modes#Basic-Major-Modes&quot;&gt;기본 주 모드를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e11839d47e0b0ae68558951b5e41000c1afea76c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;defvar&lt;/code&gt; form returns &lt;var&gt;symbol&lt;/var&gt;, but it is normally used at top level in a file where its value does not matter.</source>
          <target state="translated">&lt;code&gt;defvar&lt;/code&gt; 형태로 반환 &lt;var&gt;symbol&lt;/var&gt; 있지만 일반적으로 그 값이 중요하지 않습니다 파일에 최상위 수준에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f2a831eac710a97efa9bd72520d60c444307b0c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;delq&lt;/code&gt; function deletes elements from the front of the list by simply advancing down the list, and returning a sublist that starts after those elements. For example:</source>
          <target state="translated">&lt;code&gt;delq&lt;/code&gt; 의 기능은 단순히 목록을 아래로 진행하고, 하위 목록을 반환하여리스트의 전방에서 요소를 삭제하는 것과 소자 후에 개시. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="3ddb538774d53998062db4dcb38e5ca6d446b2f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;describe-mode&lt;/code&gt; function provides information about major modes. It is normally bound to</source>
          <target state="translated">&lt;code&gt;describe-mode&lt;/code&gt; 기능은 주요 모드에 대한 정보를 제공합니다. 일반적으로</target>
        </trans-unit>
        <trans-unit id="420dbb7acb7058c3164d9b155e31d95bf6b40fdf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;describe-symbols&lt;/code&gt; function works like &lt;code&gt;apropos&lt;/code&gt;, but provides more information.</source>
          <target state="translated">는 &lt;code&gt;describe-symbols&lt;/code&gt; 기능처럼 작동 &lt;code&gt;apropos&lt;/code&gt; 하지만, 더 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d698b4556987ba6e891cbfa0189cb35f00181f47" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;display&lt;/code&gt; text property (or overlay property) is used to insert images into text, and to control other aspects of how text displays. The value of the &lt;code&gt;display&lt;/code&gt; property should be a display specification, or a list or vector containing several display specifications. Display specifications in the same &lt;code&gt;display&lt;/code&gt; property value generally apply in parallel to the text they cover.</source>
          <target state="translated">&lt;code&gt;display&lt;/code&gt; 텍스트 속성 (또는 속성 오버레이)은 텍스트에 대한 이미지를 삽입하는 방법 및 텍스트 디스플레이의 다른 측면을 제어하기 위해 사용된다. &lt;code&gt;display&lt;/code&gt; 속성 의 값은 표시 사양이거나 여러 표시 사양을 포함하는 목록 또는 벡터 여야합니다. 동일한 &lt;code&gt;display&lt;/code&gt; 속성 값 의 표시 사양은 일반적으로 표시 되는 텍스트와 병렬로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="2146c9591b8794278316c3a07921a6d986eec90e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;documentation&lt;/code&gt; function signals a &lt;code&gt;void-function&lt;/code&gt; error if &lt;var&gt;function&lt;/var&gt; has no function definition. However, it is OK if the function definition has no documentation string. In that case, &lt;code&gt;documentation&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;documentation&lt;/code&gt; 기능은 신호 &lt;code&gt;void-function&lt;/code&gt; 경우 에러 &lt;var&gt;function&lt;/var&gt; 어떤 함수 정의가 없다. 그러나 함수 정의에 문서 문자열이 없으면 괜찮습니다. 이 경우 &lt;code&gt;documentation&lt;/code&gt; 는 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a5946c5a7fe3388e239c56c7c95a52e422b36084" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dolist&lt;/code&gt; and &lt;code&gt;dotimes&lt;/code&gt; macros provide convenient ways to write two common kinds of loops.</source>
          <target state="translated">&lt;code&gt;dolist&lt;/code&gt; 와 &lt;code&gt;dotimes&lt;/code&gt; 매크로는 루프의 두 가지 일반적인 종류를 작성하는 편리한 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5cd619e63bb900a8b2dd3e53b8d42ac7bccfddfe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;emacs_env&lt;/code&gt; pointer will usually come from the first argument to the module function, or from the call to &lt;code&gt;get_environment&lt;/code&gt; if you need the environment in the module initialization function.</source>
          <target state="translated">&lt;code&gt;emacs_env&lt;/code&gt; 의 포인터는 일반적으로 모듈 함수에 첫 번째 인수에서 올 것이다, 또는 전화에서 할 &lt;code&gt;get_environment&lt;/code&gt; 당신이 모듈 초기화 함수의 환경이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="7ad2f8242022f8fdd9f0ca14ddd9059e3039f1a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;encode-time&lt;/code&gt; function acts as a rough inverse to &lt;code&gt;decode-time&lt;/code&gt;. For example, you can pass the output of the latter to the former as follows:</source>
          <target state="translated">&lt;code&gt;encode-time&lt;/code&gt; 함수에 대략 역 역할 &lt;code&gt;decode-time&lt;/code&gt; . 예를 들어, 다음과 같이 후자의 출력을 전자에 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5e051708617b016d8c30904d9f5633ae38b3813" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;face&lt;/code&gt; property controls the appearance of the character (see &lt;a href=&quot;faces#Faces&quot;&gt;Faces&lt;/a&gt;). The value of the property can be the following:</source>
          <target state="translated">&lt;code&gt;face&lt;/code&gt; 속성을 제어 문자의 모양 (참조 &lt;a href=&quot;faces#Faces&quot;&gt;얼굴을&lt;/a&gt; ). 속성 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="601594d3c15ba0ab5790f6701cbf7bd2686bf7a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;field&lt;/code&gt; property defines fields within the buffer.</source>
          <target state="translated">&lt;code&gt;field&lt;/code&gt; 속성 버퍼 내의 필드를 정의한다.</target>
        </trans-unit>
        <trans-unit id="91d87e0abd3197dd0c588023b97f64cbfcd2c19d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;find-file-noselect&lt;/code&gt; function normally calls &lt;code&gt;after-find-file&lt;/code&gt; after reading the file (see &lt;a href=&quot;subroutines-of-visiting#Subroutines-of-Visiting&quot;&gt;Subroutines of Visiting&lt;/a&gt;). That function sets the buffer major mode, parses local variables, warns the user if there exists an auto-save file more recent than the file just visited, and finishes by running the functions in &lt;code&gt;find-file-hook&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;find-file-noselect&lt;/code&gt; 기능은 일반적으로 호출 &lt;code&gt;after-find-file&lt;/code&gt; (참조 파일을 읽은 후 &lt;a href=&quot;subroutines-of-visiting#Subroutines-of-Visiting&quot;&gt;방문의 서브 루틴을&lt;/a&gt; ). 이 함수는 버퍼 주 모드를 설정하고, 지역 변수를 구문 분석하고, 방금 방문한 파일보다 최근에 자동 저장 파일이있는 경우 사용자에게 경고하고 &lt;code&gt;find-file-hook&lt;/code&gt; 에서 함수를 실행하여 완료합니다 .</target>
        </trans-unit>
        <trans-unit id="5b8dc94f0401068ad923a287f4722f89053e9822" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;find-file-noselect&lt;/code&gt; function uses two important subroutines which are sometimes useful in user Lisp code: &lt;code&gt;create-file-buffer&lt;/code&gt; and &lt;code&gt;after-find-file&lt;/code&gt;. This section explains how to use them.</source>
          <target state="translated">&lt;code&gt;find-file-noselect&lt;/code&gt; 기능은 사용자 리스프 코드에서 때로는 유용한 두 가지 중요한 서브 루틴을 사용하여 &lt;code&gt;create-file-buffer&lt;/code&gt; 하고 &lt;code&gt;after-find-file&lt;/code&gt; . 이 섹션에서는 사용 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="433399969927d5b1796b197fef7a6e76457e8540" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;find-file-noselect&lt;/code&gt; function usually returns the buffer that is visiting the file &lt;var&gt;filename&lt;/var&gt;. But, if wildcards are actually used and expanded, it returns a list of buffers that are visiting the various files.</source>
          <target state="translated">&lt;code&gt;find-file-noselect&lt;/code&gt; 기능은 일반적으로 파일 방문 버퍼 반환 &lt;var&gt;filename&lt;/var&gt; . 그러나 와일드 카드가 실제로 사용되고 확장되면 다양한 파일을 방문하는 버퍼 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a464addeb7232688689a59ac447a545f6c93c736" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;follow-link&lt;/code&gt; property, defining how a</source>
          <target state="translated">&lt;code&gt;follow-link&lt;/code&gt; 정의 특성, 방법</target>
        </trans-unit>
        <trans-unit id="444a5499ee66a56312fc2965164aa8d072d4a9f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;font-lock-multiline&lt;/code&gt; property is meant to ensure proper refontification; it does not automatically identify new multiline constructs. Identifying them requires that Font Lock mode operate on large enough chunks at a time. This will happen by accident on many cases, which may give the impression that multiline constructs magically work. If you set the &lt;code&gt;font-lock-multiline&lt;/code&gt; variable non-&lt;code&gt;nil&lt;/code&gt;, this impression will be even stronger, since the highlighting of those constructs which are found will be properly updated from then on. But that does not work reliably.</source>
          <target state="translated">&lt;code&gt;font-lock-multiline&lt;/code&gt; 속성은 적절한 refontification을 보장하기위한 것입니다; 새 여러 줄 구성을 자동으로 식별하지 않습니다. 이를 식별하려면 한 번에 충분히 큰 청크에서 글꼴 잠금 모드가 작동해야합니다. 이것은 많은 경우 우연히 발생하며 여러 줄 구조가 마술처럼 작동한다는 인상을 줄 수 있습니다. &lt;code&gt;font-lock-multiline&lt;/code&gt; 변수를 non - &lt;code&gt;nil&lt;/code&gt; 로 설정하면 발견 된 구성의 강조 표시가 그때부터 적절하게 업데이트되기 때문에이 인상은 더욱 강해질 것입니다. 그러나 그것은 안정적으로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="47be97b3e1f5347c54244ef417be3e1f2a83bb62" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;group&lt;/code&gt; widget is used here instead of &lt;code&gt;list&lt;/code&gt; only because the formatting is better suited for the purpose.</source>
          <target state="translated">&lt;code&gt;group&lt;/code&gt; 대신 여기에 사용되는 위젯 &lt;code&gt;list&lt;/code&gt; 포맷이 더 목적에 적합 때문.</target>
        </trans-unit>
        <trans-unit id="8fa064dc83f7cd8e73706942b3d3bf88b2f393fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;imenu-generic-expression&lt;/code&gt; regular expressions can then use &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;imenu-generic-expression&lt;/code&gt; 정규 표현식은 '사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="95cfa710dcb0d358ddec70e647ab0d09459da980" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;in&lt;/code&gt;, &lt;code&gt;mm&lt;/code&gt;, and &lt;code&gt;cm&lt;/code&gt; units specify the number of pixels per inch, millimeter, and centimeter, respectively. The &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; units correspond to the default width and height of the current face. An image specification of the form &lt;code&gt;(image&amp;nbsp;.&amp;nbsp;&lt;var&gt;props&lt;/var&gt;)&lt;/code&gt; (see &lt;a href=&quot;image-descriptors#Image-Descriptors&quot;&gt;Image Descriptors&lt;/a&gt;) corresponds to the width or height of the specified image. Similarly, an xwidget specification of the form &lt;code&gt;(xwidget&amp;nbsp;.&amp;nbsp;&lt;var&gt;props&lt;/var&gt;)&lt;/code&gt; stands for the width or height of the specified xwidget. See &lt;a href=&quot;xwidgets#Xwidgets&quot;&gt;Xwidgets&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;in&lt;/code&gt; , &lt;code&gt;mm&lt;/code&gt; 와 &lt;code&gt;cm&lt;/code&gt; 의 단위는 각각 인치 mm 및 센티미터 당 픽셀 수를 지정. &lt;code&gt;width&lt;/code&gt; 과 &lt;code&gt;height&lt;/code&gt; 유닛은 현재 얼굴 기본 폭과 높이에 해당한다. &lt;code&gt;(image&amp;nbsp;.&amp;nbsp;&lt;var&gt;props&lt;/var&gt;)&lt;/code&gt; 형식의 이미지 사양 ( &lt;a href=&quot;image-descriptors#Image-Descriptors&quot;&gt;이미지 설명자&lt;/a&gt; 참조 )은 지정된 이미지의 너비 또는 높이에 해당합니다. 마찬가지로 &lt;code&gt;(xwidget&amp;nbsp;.&amp;nbsp;&lt;var&gt;props&lt;/var&gt;)&lt;/code&gt; 형식의 xwidget 사양은 지정된 xwidget의 너비 또는 높이를 나타냅니다. &lt;a href=&quot;xwidgets#Xwidgets&quot;&gt;Xwidgets를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c1fa85ed58bc9efcbe16dc5d44ca81dd39c29afc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;intangible&lt;/code&gt; property on an overlay works just like the &lt;code&gt;intangible&lt;/code&gt; text property. It is obsolete. See &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Special Properties&lt;/a&gt;, for details.</source>
          <target state="translated">오버레이 의 &lt;code&gt;intangible&lt;/code&gt; 속성은 &lt;code&gt;intangible&lt;/code&gt; 텍스트 속성 처럼 작동 합니다. 구식입니다. 자세한 내용은 &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;특수 속성&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c74f8c0156232d28e603141c4cc1ee2352b2c427" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;interactive&lt;/code&gt; form must be located at top-level in the function body, or in the function symbol&amp;rsquo;s &lt;code&gt;interactive-form&lt;/code&gt; property (see &lt;a href=&quot;symbol-properties#Symbol-Properties&quot;&gt;Symbol Properties&lt;/a&gt;). It has its effect because the command loop looks for it before calling the function (see &lt;a href=&quot;interactive-call#Interactive-Call&quot;&gt;Interactive Call&lt;/a&gt;). Once the function is called, all its body forms are executed; at this time, if the &lt;code&gt;interactive&lt;/code&gt; form occurs within the body, the form simply returns &lt;code&gt;nil&lt;/code&gt; without even evaluating its argument.</source>
          <target state="translated">&lt;code&gt;interactive&lt;/code&gt; 양식은 함수 본문에서 최상위에있는, 또는 기능 심볼의에서해야 &lt;code&gt;interactive-form&lt;/code&gt; 특성 (참조 &lt;a href=&quot;symbol-properties#Symbol-Properties&quot;&gt;심볼 속성을&lt;/a&gt; ). 명령 루프가 함수를 호출하기 전에 검색하기 때문에 효과가 있습니다 ( &lt;a href=&quot;interactive-call#Interactive-Call&quot;&gt;Interactive Call&lt;/a&gt; 참조 ). 함수가 호출되면 모든 본문 형식이 실행됩니다. 이때 &lt;code&gt;interactive&lt;/code&gt; 형식이 본문 내에서 발생하면 형식 은 인수를 평가 &lt;code&gt;nil&lt;/code&gt; 않고 단순히 nil 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f846208cf69e148316b2a5e801ec368e4897cade" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;invisible&lt;/code&gt; property can make the text in the overlay invisible, which means that it does not appear on the screen. See &lt;a href=&quot;invisible-text#Invisible-Text&quot;&gt;Invisible Text&lt;/a&gt;, for details.</source>
          <target state="translated">&lt;code&gt;invisible&lt;/code&gt; 속성은 화면에 나타나지 않습니다하는 수단, 오버레이의 텍스트가 보이지 않게 할 수 있습니다. 자세한 내용은 &lt;a href=&quot;invisible-text#Invisible-Text&quot;&gt;보이지 않는 텍스트&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bae7cf08edd92266cd91450bcbdcde42f958861e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jsonrpc&lt;/code&gt; library implements the</source>
          <target state="translated">&lt;code&gt;jsonrpc&lt;/code&gt; 라이브러리 구현</target>
        </trans-unit>
        <trans-unit id="cea28c2d7fc3fcf0178f1c3323d9e331934d7db9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;keymap&lt;/code&gt; and &lt;code&gt;local-map&lt;/code&gt; properties do not affect a string displayed by the &lt;code&gt;before-string&lt;/code&gt;, &lt;code&gt;after-string&lt;/code&gt;, or &lt;code&gt;display&lt;/code&gt; properties. This is only relevant for mouse clicks and other mouse events that fall on the string, since point is never on the string. To bind special mouse events for the string, assign it a &lt;code&gt;keymap&lt;/code&gt; or &lt;code&gt;local-map&lt;/code&gt; text property. See &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Special Properties&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;keymap&lt;/code&gt; 및 &lt;code&gt;local-map&lt;/code&gt; 특성에 의해 표시되는 문자열에 영향을주지 않는 &lt;code&gt;before-string&lt;/code&gt; , &lt;code&gt;after-string&lt;/code&gt; , 또는 &lt;code&gt;display&lt;/code&gt; 속성을. 포인트는 문자열에 있지 않기 때문에 마우스 클릭 및 문자열에 해당하는 기타 마우스 이벤트에만 관련됩니다. 문자열에 대한 특수 마우스 이벤트를 바인딩하려면 &lt;code&gt;keymap&lt;/code&gt; 또는 &lt;code&gt;local-map&lt;/code&gt; 텍스트 속성을 할당하십시오 . &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;특수 속성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9c80a5ff57952dcdf069923f6c4148ca2b519f38" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;keymap&lt;/code&gt; property specifies an additional keymap for commands. When this keymap applies, it is used for key lookup before the minor mode keymaps and before the buffer&amp;rsquo;s local map. See &lt;a href=&quot;active-keymaps#Active-Keymaps&quot;&gt;Active Keymaps&lt;/a&gt;. If the property value is a symbol, the symbol&amp;rsquo;s function definition is used as the keymap.</source>
          <target state="translated">&lt;code&gt;keymap&lt;/code&gt; 속성은 명령에 대한 추가 키맵을 지정합니다. 이 키맵이 적용되면 부 모드 키맵 이전과 버퍼의 로컬 맵 이전에 키 조회에 사용됩니다. &lt;a href=&quot;active-keymaps#Active-Keymaps&quot;&gt;활성 키맵을&lt;/a&gt; 참조하십시오 . 속성 값이 심볼이면 심볼의 함수 정의가 키맵으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d3dd9b04eaf9d8f1503fdd7493d3e02d22d27e88" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;kill-emacs&lt;/code&gt; function is normally called via the higher-level command</source>
          <target state="translated">&lt;code&gt;kill-emacs&lt;/code&gt; 기능은 일반적으로 높은 수준의 명령을 통해 호출</target>
        </trans-unit>
        <trans-unit id="c92e19a6bbfd6a262fe1a00d8884e70099e8c2b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;kill-ring-yank-pointer&lt;/code&gt; variable points to a link in the kill ring list, whose &lt;small&gt;CAR&lt;/small&gt; is the text to yank next. We say it identifies the front of the ring. Moving &lt;code&gt;kill-ring-yank-pointer&lt;/code&gt; to a different link is called &lt;em&gt;rotating the kill ring&lt;/em&gt;. We call the kill ring a &amp;ldquo;ring&amp;rdquo; because the functions that move the yank pointer wrap around from the end of the list to the beginning, or vice-versa. Rotation of the kill ring is virtual; it does not change the value of &lt;code&gt;kill-ring&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;kill-ring-yank-pointer&lt;/code&gt; 킬 링리스트에있는 링크에 변수 포인트 &lt;small&gt;CAR는&lt;/small&gt; 다음에 꺼낼 수있는 텍스트입니다. 우리는 그것이 링의 앞면을 식별한다고 말합니다. 이동 &lt;code&gt;kill-ring-yank-pointer&lt;/code&gt; 다른 링크하는 것은이라고 &lt;em&gt;킬 (kill) 링을 회전&lt;/em&gt; . yank 포인터를 이동하는 함수가 목록의 끝에서 시작으로 또는 그 반대로 둘러싸 기 때문에 킬 링을 &quot;링&quot;이라고합니다. 킬 링의 회전은 가상입니다. &lt;code&gt;kill-ring&lt;/code&gt; 값은 변경되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="300fdeb58fe0177e7e1b352ab7be30fbfbfd4c57" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lambda&lt;/code&gt; form has one other effect: it tells the Emacs evaluator and byte-compiler that its argument is a function, by using &lt;code&gt;function&lt;/code&gt; as a subroutine (see below).</source>
          <target state="translated">&lt;code&gt;lambda&lt;/code&gt; 형태는 하나 개의 다른 효과를 가지고 그것의 인자를 사용하여, 함수임을 이멕스 평가자 바이트 컴파일러 지시 &lt;code&gt;function&lt;/code&gt; (아래 참조) 서브 루틴.</target>
        </trans-unit>
        <trans-unit id="a2aafafa00230d541923e3ade40d481ca37d93c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;left&lt;/code&gt;, &lt;code&gt;center&lt;/code&gt;, and &lt;code&gt;right&lt;/code&gt; positions can be used with &lt;code&gt;:align-to&lt;/code&gt; to specify a position relative to the left edge, center, or right edge of the text area. When the window displays line numbers, the &lt;code&gt;left&lt;/code&gt; and the &lt;code&gt;center&lt;/code&gt; positions are offset to account for the screen space taken by the line-number display.</source>
          <target state="translated">&lt;code&gt;left&lt;/code&gt; , &lt;code&gt;center&lt;/code&gt; 및 &lt;code&gt;right&lt;/code&gt; 위치로 사용될 수 &lt;code&gt;:align-to&lt;/code&gt; 왼쪽 가장자리 중앙 또는 텍스트 영역의 우측 에지에 대한 위치를 지정. 창에 줄 번호가 표시되면 &lt;code&gt;left&lt;/code&gt; 과 &lt;code&gt;center&lt;/code&gt; 위치가 오프셋되어 줄 번호 디스플레이가 차지하는 화면 공간을 고려합니다.</target>
        </trans-unit>
        <trans-unit id="0400cb4c69cbe2da905584673b0c879713b9c76e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;let&lt;/code&gt; binding defines a lexical environment in which the variable &lt;code&gt;x&lt;/code&gt; is locally bound to 0. Within this binding construct, we define a lambda expression which increments &lt;code&gt;x&lt;/code&gt; by one and returns the incremented value. This lambda expression is automatically turned into a closure, in which the lexical environment lives on even after the &lt;code&gt;let&lt;/code&gt; binding construct has exited. Each time we evaluate the closure, it increments &lt;code&gt;x&lt;/code&gt;, using the binding of &lt;code&gt;x&lt;/code&gt; in that lexical environment.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 정의를 가변하는 사전 환경 바인딩 &lt;code&gt;x&lt;/code&gt; 로컬이 결합 구조체 내에 0으로 결합되어, 우리는 증분 람다 식 정의 &lt;code&gt;x&lt;/code&gt; 하나 되돌아 증가 된 값으로한다. 이 람다 식은 &lt;code&gt;let&lt;/code&gt; 바인딩 구문이 종료 된 후에도 어휘 환경이 유지되는 클로저로 자동 변환됩니다 . 클로저를 평가할 때마다 해당 어휘 환경에서 &lt;code&gt;x&lt;/code&gt; 의 바인딩을 사용하여 &lt;code&gt;x&lt;/code&gt; 를 증가시킵니다 .</target>
        </trans-unit>
        <trans-unit id="13495fafa6f5ab5c87807a5b63a3af0706d7817e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;list-threads&lt;/code&gt; command lists all the currently alive threads. In the resulting buffer, each thread is identified either by the name passed to &lt;code&gt;make-thread&lt;/code&gt; (see &lt;a href=&quot;basic-thread-functions#Basic-Thread-Functions&quot;&gt;Basic Thread Functions&lt;/a&gt;), or by its unique internal identifier if it was not created with a name. The status of each thread at the time of the creation or last update of the buffer is shown, in addition to the object the thread was blocked on at the time, if it was blocked.</source>
          <target state="translated">&lt;code&gt;list-threads&lt;/code&gt; 목록 모든 현재 살아 스레드를 명령. 결과 버퍼에서 각 스레드는 &lt;code&gt;make-thread&lt;/code&gt; ( &lt;a href=&quot;basic-thread-functions#Basic-Thread-Functions&quot;&gt;기본 스레드 함수&lt;/a&gt; 참조)에 전달 된 이름으로 식별되거나 이름으로 생성되지 않은 경우 고유 한 내부 식별자로 식별됩니다. 버퍼 생성 또는 마지막 업데이트 당시의 각 스레드의 상태가 차단 된 경우 해당 스레드가 차단 된 객체와 함께 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="0913489aeb9c330c64bb079b1c5f7c7b0fe21837" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;list-timers&lt;/code&gt; command lists all the currently active timers. There&amp;rsquo;s only one command available in the buffer displayed:</source>
          <target state="translated">&lt;code&gt;list-timers&lt;/code&gt; 목록 모든 현재 활성화 된 타이머를 명령. 표시된 버퍼에서 사용할 수있는 명령은 하나뿐입니다.</target>
        </trans-unit>
        <trans-unit id="2001adc7401e23d02f00869110aad55b1044900c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;load&lt;/code&gt; function and others.</source>
          <target state="translated">&lt;code&gt;load&lt;/code&gt; 기능 등이있다.</target>
        </trans-unit>
        <trans-unit id="60b597e3a1575b6fda9337a82325c5e944998909" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;local-map&lt;/code&gt; property is similar to &lt;code&gt;keymap&lt;/code&gt; but replaces the buffer&amp;rsquo;s local map rather than augmenting existing keymaps. This also means it has lower precedence than minor mode keymaps.</source>
          <target state="translated">&lt;code&gt;local-map&lt;/code&gt; 속성과 유사 &lt;code&gt;keymap&lt;/code&gt; 하지만 기존의 키맵을 보강하기보다는 버퍼의 현지지도를 대체합니다. 이것은 또한 부 모드 키맵보다 우선 순위가 낮다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="5c9fa7882799c21b778d554910cdcdfb2d432b8e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;make-symbol&lt;/code&gt; function returns an uninterned symbol, distinct from the symbol that is used if you write the name in a Lisp expression. Distinct symbols with the same name are not &lt;code&gt;eq&lt;/code&gt;. See &lt;a href=&quot;creating-symbols#Creating-Symbols&quot;&gt;Creating Symbols&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;make-symbol&lt;/code&gt; 기능을 사용하면 리스프 식의 이름을 작성하는 경우 사용되는 기호와 구별 uninterned 기호를 반환합니다. 이름이 같은 고유 한 기호는 &lt;code&gt;eq&lt;/code&gt; 가 아닙니다 . &lt;a href=&quot;creating-symbols#Creating-Symbols&quot;&gt;기호 작성을&lt;/a&gt; 참고하십시오 .</target>
        </trans-unit>
        <trans-unit id="39c002469150bf19e61aa64b21029ed51696a1ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;modiff&lt;/code&gt; field of the window&amp;rsquo;s buffer, as of the last time a redisplay completed in this window.</source>
          <target state="translated">이 창에서 마지막으로 다시 표시가 완료된 시점의 창 버퍼 의 &lt;code&gt;modiff&lt;/code&gt; 필드입니다.</target>
        </trans-unit>
        <trans-unit id="8792ad0df49661320c71bdaa90f1c322ed577276" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;or&lt;/code&gt; special form tests whether at least one of the &lt;var&gt;conditions&lt;/var&gt; is true. It works by evaluating all the &lt;var&gt;conditions&lt;/var&gt; one by one in the order written.</source>
          <target state="translated">&lt;code&gt;or&lt;/code&gt; 특별한 형태의 테스트는 적어도 하나의 여부를 &lt;var&gt;conditions&lt;/var&gt; 사실이다. 작성된 순서대로 모든 &lt;var&gt;conditions&lt;/var&gt; 하나씩 평가하여 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="54cf985900734756973b5e6c1038f7a5bb008475" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;overlay_modiff&lt;/code&gt; field of the window&amp;rsquo;s buffer, as of the last time a redisplay completed in this window.</source>
          <target state="translated">이 창에서 마지막으로 재 표시가 완료된 시점의 창 버퍼 의 &lt;code&gt;overlay_modiff&lt;/code&gt; 필드입니다.</target>
        </trans-unit>
        <trans-unit id="37eaec0c1b4099d02a0ae66595ebff4846d95b4a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parent-frame&lt;/code&gt; parameter can be changed at any time. Setting it to another frame &lt;em&gt;reparents&lt;/em&gt; the child frame. Setting it to another child frame makes the frame a &lt;em&gt;nested&lt;/em&gt; child frame. Setting it to &lt;code&gt;nil&lt;/code&gt; restores the frame&amp;rsquo;s status as a top-level frame&amp;mdash;a frame whose window-system window is a child of its display&amp;rsquo;s root window.</source>
          <target state="translated">&lt;code&gt;parent-frame&lt;/code&gt; 파라미터는 언제든지 변경 될 수있다. 다른 프레임으로 &lt;em&gt;설정&lt;/em&gt; 하면 자식 프레임이 다시 부모가됩니다. 다른 자식 프레임으로 설정하면 프레임이 &lt;em&gt;중첩 된&lt;/em&gt; 자식 프레임이됩니다. &lt;code&gt;nil&lt;/code&gt; 로 설정 하면 프레임의 상태가 최상위 프레임 (윈도우 시스템 창이 디스플레이의 루트 창의 자식 인 프레임)으로 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="2cbabe60c124238bf2333a137807d3133e30e0c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pcase&lt;/code&gt; macro can use &lt;code&gt;rx&lt;/code&gt; expressions as patterns directly; see &lt;a href=&quot;pcase-macro#rx-in-pcase&quot;&gt;rx in pcase&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pcase&lt;/code&gt; 의 매크로를 사용할 수있는 &lt;code&gt;rx&lt;/code&gt; 직접 패턴으로 표현; &lt;a href=&quot;pcase-macro#rx-in-pcase&quot;&gt;pcase의 rx를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ad2b03edf0503d884029350321e8227580f971a3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pcase&lt;/code&gt; macro supports several kinds of patterns (see &lt;a href=&quot;pattern_002dmatching-conditional#Pattern_002dMatching-Conditional&quot;&gt;Pattern-Matching Conditional&lt;/a&gt;). You can add support for other kinds of patterns using the &lt;code&gt;pcase-defmacro&lt;/code&gt; macro.</source>
          <target state="translated">&lt;code&gt;pcase&lt;/code&gt; 매크로 지원 패턴의 여러 종류 (참조 &lt;a href=&quot;pattern_002dmatching-conditional#Pattern_002dMatching-Conditional&quot;&gt;조건을 패턴 일치&lt;/a&gt; ). &lt;code&gt;pcase-defmacro&lt;/code&gt; 매크로를 사용하여 다른 종류의 패턴에 대한 지원을 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5b3d5823b8631faa4d412a2d00c614d255559941" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pcase&lt;/code&gt; patterns provide an alternative facility for destructuring binding, see &lt;a href=&quot;destructuring-with-pcase-patterns#Destructuring-with-pcase-Patterns&quot;&gt;Destructuring with pcase Patterns&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pcase&lt;/code&gt; 의 패턴은, 바인딩 destructuring에 대한 대체 시설을 제공 참조 &lt;a href=&quot;destructuring-with-pcase-patterns#Destructuring-with-pcase-Patterns&quot;&gt;pcase 패턴과 Destructuring&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f4f5f41a3aef3458c44d5db29ce9dfc422046f88" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;print&lt;/code&gt; function is a convenient way of printing. It outputs the printed representation of &lt;var&gt;object&lt;/var&gt; to &lt;var&gt;stream&lt;/var&gt;, printing in addition one newline before &lt;var&gt;object&lt;/var&gt; and another after it. Quoting characters are used. &lt;code&gt;print&lt;/code&gt; returns &lt;var&gt;object&lt;/var&gt;. For example:</source>
          <target state="translated">&lt;code&gt;print&lt;/code&gt; 기능은 인쇄하는 편리한 방법입니다. &lt;var&gt;object&lt;/var&gt; 의 인쇄 된 표현 을 &lt;var&gt;stream&lt;/var&gt; 에 출력하고 &lt;var&gt;object&lt;/var&gt; 앞 과 그 뒤에 한 줄 바꿈을 추가로 인쇄 합니다. 인용 문자가 사용됩니다. &lt;code&gt;print&lt;/code&gt; 는 &lt;var&gt;object&lt;/var&gt; 를 반환 합니다 . 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="ccc61565cace17508e3d5f3f87acbb4cc610269f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;process-status&lt;/code&gt; function returns &lt;code&gt;open&lt;/code&gt;, &lt;code&gt;closed&lt;/code&gt;, &lt;code&gt;connect&lt;/code&gt;, &lt;code&gt;stop&lt;/code&gt;, or &lt;code&gt;failed&lt;/code&gt; for network connections. For a network server, the status is always &lt;code&gt;listen&lt;/code&gt;. Except for &lt;code&gt;stop&lt;/code&gt;, none of those values is possible for a real subprocess. See &lt;a href=&quot;process-information#Process-Information&quot;&gt;Process Information&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;process-status&lt;/code&gt; 함수가 리턴 &lt;code&gt;open&lt;/code&gt; , &lt;code&gt;closed&lt;/code&gt; , &lt;code&gt;connect&lt;/code&gt; , &lt;code&gt;stop&lt;/code&gt; 또는 &lt;code&gt;failed&lt;/code&gt; 네트워크 연결. 네트워크 서버의 경우 상태는 항상 &lt;code&gt;listen&lt;/code&gt; 입니다. &lt;code&gt;stop&lt;/code&gt; 을 제외하고 실제 하위 프로세스에는 해당 값이 없습니다. &lt;a href=&quot;process-information#Process-Information&quot;&gt;프로세스 정보를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="de088b6f64f19c2025fcc7d39d6e8d69dd77d6e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prop-match&lt;/code&gt; structure has the following accessors: &lt;code&gt;prop-match-beginning&lt;/code&gt; (the start of the match), &lt;code&gt;prop-match-end&lt;/code&gt; (the end of the match), and &lt;code&gt;prop-match-value&lt;/code&gt; (the value of &lt;var&gt;property&lt;/var&gt; at the start of the match).</source>
          <target state="translated">&lt;code&gt;prop-match&lt;/code&gt; : 구조는 다음과 같은 접근이 &lt;code&gt;prop-match-beginning&lt;/code&gt; (경기의 시작), &lt;code&gt;prop-match-end&lt;/code&gt; (경기 종료), 및 &lt;code&gt;prop-match-value&lt;/code&gt; (값 &lt;var&gt;property&lt;/var&gt; 을 시작할 때를 경기의).</target>
        </trans-unit>
        <trans-unit id="598373f29709110698650f08e484fa46a6f764f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read-command&lt;/code&gt; function is a simplified interface to &lt;code&gt;completing-read&lt;/code&gt;. It uses the variable &lt;code&gt;obarray&lt;/code&gt; so as to complete in the set of extant Lisp symbols, and it uses the &lt;code&gt;commandp&lt;/code&gt; predicate so as to accept only command names:</source>
          <target state="translated">&lt;code&gt;read-command&lt;/code&gt; 기능에 대한 단순화 된 인터페이스입니다 &lt;code&gt;completing-read&lt;/code&gt; . 현존하는 Lisp 기호 세트를 완성하기 위해 변수 &lt;code&gt;obarray&lt;/code&gt; 를 사용하고 명령 이름 만 허용하도록 &lt;code&gt;commandp&lt;/code&gt; 술어를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="2a8b0f78b4fb6dd443231846e3503cfc2ae4faa4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read-multiple-choice-face&lt;/code&gt; face is used to highlight the matching characters in the name string on graphical terminals.</source>
          <target state="translated">&lt;code&gt;read-multiple-choice-face&lt;/code&gt; 얼굴 그래픽 터미널의 이름 문자열에서 일치하는 문자를 강조하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="200780fa627bf54ef45ca3b42f1020c5fa31731b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rear-nonsticky&lt;/code&gt; property works the opposite way. Most properties are rear-sticky by default, so the &lt;code&gt;rear-nonsticky&lt;/code&gt; property says which properties are &lt;em&gt;not&lt;/em&gt; rear-sticky. If a character&amp;rsquo;s &lt;code&gt;rear-nonsticky&lt;/code&gt; property is &lt;code&gt;t&lt;/code&gt;, then none of its properties are rear-sticky. If the &lt;code&gt;rear-nonsticky&lt;/code&gt; property is a list, properties are rear-sticky &lt;em&gt;unless&lt;/em&gt; their names are in the list.</source>
          <target state="translated">&lt;code&gt;rear-nonsticky&lt;/code&gt; 속성은 반대의 방식으로 작동합니다. 대부분의 속성은 기본적으로 후면 고정이므로 &lt;code&gt;rear-nonsticky&lt;/code&gt; 속성은 후면 고정 이 &lt;em&gt;아닌&lt;/em&gt; 속성을 나타 냅니다. 캐릭터의 &lt;code&gt;rear-nonsticky&lt;/code&gt; 속성이 &lt;code&gt;t&lt;/code&gt; 이면 해당 속성 중 어느 것도 후면 고정 속성이 아닙니다. 는 IF &lt;code&gt;rear-nonsticky&lt;/code&gt; 속성은 목록, 속성은 후면 끈적 &lt;em&gt;하지 않는 한&lt;/em&gt; 자신의 이름이 목록에 있습니다.</target>
        </trans-unit>
        <trans-unit id="21b5243fd9928f00ce2770b484cc6cb21e26829f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rx&lt;/code&gt; notation can be extended by defining new symbols and parameterized forms in terms of other &lt;code&gt;rx&lt;/code&gt; expressions. This is handy for sharing parts between several regexps, and for making complex ones easier to build and understand by putting them together from smaller pieces.</source>
          <target state="translated">&lt;code&gt;rx&lt;/code&gt; 표기법은 다른 측면에서 새로운 기호와 파라미터 형태를 정의하여 확장 할 수 있습니다 &lt;code&gt;rx&lt;/code&gt; 표현. 이것은 여러 정규 표현식간에 부분을 공유하고 복잡한 부분을 작은 부분으로 모아서 쉽게 만들고 이해하도록 만드는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d35c64be484f1d1e41d1cf10785e16404529be6a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rx&lt;/code&gt; notation is mainly useful in Lisp code; it cannot be used in most interactive situations where a regexp is requested, such as when running &lt;code&gt;query-replace-regexp&lt;/code&gt; or in variable customization.</source>
          <target state="translated">&lt;code&gt;rx&lt;/code&gt; 표기법은 리스프 코드에서 유용하게; &lt;code&gt;query-replace-regexp&lt;/code&gt; 를 실행 하거나 변수 사용자 정의를 실행할 때와 같이 regexp가 요청되는 대부분의 대화식 상황에서는 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="53551c07d10f3f216837e0f26f28d397fcb2ed21" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;save-current-buffer&lt;/code&gt; special form saves the identity of the current buffer, evaluates the &lt;var&gt;body&lt;/var&gt; forms, and finally restores that buffer as current. The return value is the value of the last form in &lt;var&gt;body&lt;/var&gt;. The current buffer is restored even in case of an abnormal exit via &lt;code&gt;throw&lt;/code&gt; or error (see &lt;a href=&quot;nonlocal-exits#Nonlocal-Exits&quot;&gt;Nonlocal Exits&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;save-current-buffer&lt;/code&gt; 특수 형태는 현재 버퍼의 신원을 저장하는 평가 &lt;var&gt;body&lt;/var&gt; 형태를, 그리고 마지막으로 현재로 그 버퍼를 복원합니다. 반환 값은 &lt;var&gt;body&lt;/var&gt; 의 마지막 양식 값입니다 . 현재 버퍼는 &lt;code&gt;throw&lt;/code&gt; 또는 오류 를 통해 비정상적으로 종료 된 경우에도 복원됩니다 ( &lt;a href=&quot;nonlocal-exits#Nonlocal-Exits&quot;&gt;Nonlocal Exit&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="02fe48ac684709f11ba9e8bf659b5046cd711774" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;setf&lt;/code&gt; macro is the most basic way to operate on generalized variables. The &lt;code&gt;setf&lt;/code&gt; form is like &lt;code&gt;setq&lt;/code&gt;, except that it accepts arbitrary place forms on the left side rather than just symbols. For example, &lt;code&gt;(setf (car a) b)&lt;/code&gt; sets the car of &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;b&lt;/code&gt;, doing the same operation as &lt;code&gt;(setcar a b)&lt;/code&gt;, but without you having to use two separate functions for setting and accessing this type of place.</source>
          <target state="translated">&lt;code&gt;setf&lt;/code&gt; 의의 매크로는 일반 변수에 작동 할 수있는 가장 기본적인 방법입니다. &lt;code&gt;setf&lt;/code&gt; 의의 형태처럼 &lt;code&gt;setq&lt;/code&gt; 는 왼쪽에서 임의의 장소에 형성보다는 기호를 수용 이외에는. 예를 들어, &lt;code&gt;(setf (car a) b)&lt;/code&gt; 의 차가 설정 &lt;code&gt;a&lt;/code&gt; 로 &lt;code&gt;b&lt;/code&gt; 와 동일한 동작을하고, &lt;code&gt;(setcar a b)&lt;/code&gt; 있지만, 설정 장소의 타입에 액세스하는 두 개의 별도의 기능을 사용하지 않고도.</target>
        </trans-unit>
        <trans-unit id="519db98ccdce7a0ac9a46f7b701fd15fc85de13f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;setf&lt;/code&gt; macro.</source>
          <target state="translated">&lt;code&gt;setf&lt;/code&gt; 의의 매크로입니다.</target>
        </trans-unit>
        <trans-unit id="aa53c63a9abb045c39925931519d6a1ad749f396" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;silly-loop&lt;/code&gt; function is somewhat more complex:</source>
          <target state="translated">&lt;code&gt;silly-loop&lt;/code&gt; 기능은 약간 더 복잡하다 :</target>
        </trans-unit>
        <trans-unit id="c7a98fc9f98f8ed0409fa02d84cfaa200eb97ed0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sort-paragraphs&lt;/code&gt; function is very much the same, except that its &lt;code&gt;sort-subr&lt;/code&gt; call looks like this:</source>
          <target state="translated">&lt;code&gt;sort-paragraphs&lt;/code&gt; 함수는 제외하고, 매우 동일 &lt;code&gt;sort-subr&lt;/code&gt; 이 같은 통화 외모 :</target>
        </trans-unit>
        <trans-unit id="695d17039e6c523d0970c6a178f2b0f1e4914ac6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;split-window&lt;/code&gt; call has created a new live window, denoted by &lt;var&gt;W5&lt;/var&gt;. It has also created a new internal window, denoted by &lt;var&gt;W3&lt;/var&gt;, which becomes the root window and the parent of both &lt;var&gt;W4&lt;/var&gt; and &lt;var&gt;W5&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;split-window&lt;/code&gt; 통화로 표시 새로운 라이브 창을 만들었습니다 &lt;var&gt;W5&lt;/var&gt; 를 . 또한 &lt;var&gt;W3&lt;/var&gt; 으로 표시되는 새 내부 창을 만들었는데 ,이 창은 루트 창과 &lt;var&gt;W4&lt;/var&gt; 및 &lt;var&gt;W5&lt;/var&gt; 모두의 부모가 됩니다.</target>
        </trans-unit>
        <trans-unit id="b2e5b8192b36bed82b233ac7ff740de7b4a505e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;stopped&lt;/code&gt; event reports, that watching the file has been stopped. This could be because &lt;code&gt;file-notify-rm-watch&lt;/code&gt; was called (see below), or because the file being watched was deleted, or due to another error reported from the underlying library.</source>
          <target state="translated">&lt;code&gt;stopped&lt;/code&gt; 이벤트 보고서 파일을보고하는 것은 중지되었습니다. 이는 &lt;code&gt;file-notify-rm-watch&lt;/code&gt; 가 호출되었거나 (아래 참조) 감시중인 파일이 삭제되었거나 기본 라이브러리에서보고 된 다른 오류 때문일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08a33b6bbd7b79c1bd61398e4080d80acb78db3d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;suppress-keymap&lt;/code&gt; function does not make it impossible to modify a buffer, as it does not suppress commands such as &lt;code&gt;yank&lt;/code&gt; and &lt;code&gt;quoted-insert&lt;/code&gt;. To prevent any modification of a buffer, make it read-only (see &lt;a href=&quot;read-only-buffers#Read-Only-Buffers&quot;&gt;Read Only Buffers&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;suppress-keymap&lt;/code&gt; 함수는 같은 억제 명령하지 않는 한 불가능, 버퍼를 수정하지 않습니다 &lt;code&gt;yank&lt;/code&gt; 및 &lt;code&gt;quoted-insert&lt;/code&gt; . 버퍼의 수정을 방지하려면 &lt;a href=&quot;read-only-buffers#Read-Only-Buffers&quot;&gt;읽기 전용으로 설정&lt;/a&gt; 하십시오 ( 읽기 전용 버퍼 참조 ).</target>
        </trans-unit>
        <trans-unit id="347f633203d82e1fb528295569b12e1c05eae812" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;syntax-table&lt;/code&gt; property overrides what the syntax table says about this particular character. See &lt;a href=&quot;syntax-properties#Syntax-Properties&quot;&gt;Syntax Properties&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;syntax-table&lt;/code&gt; 특성 재 구문 테이블이 특정 문자에 대해 말씀. &lt;a href=&quot;syntax-properties#Syntax-Properties&quot;&gt;구문 속성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="92bcd0f9acc582211cd5c8c795c82abd36469aa1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;thin-space&lt;/code&gt;, &lt;code&gt;empty-box&lt;/code&gt;, &lt;code&gt;hex-code&lt;/code&gt;, and</source>
          <target state="translated">&lt;code&gt;thin-space&lt;/code&gt; , &lt;code&gt;empty-box&lt;/code&gt; , &lt;code&gt;hex-code&lt;/code&gt; , 그리고</target>
        </trans-unit>
        <trans-unit id="59f05476c96f428731172a18b457adc61f7b26e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;throw&lt;/code&gt; form, if executed, transfers control straight back to the corresponding &lt;code&gt;catch&lt;/code&gt;, which returns immediately. The code following the &lt;code&gt;throw&lt;/code&gt; is not executed. The second argument of &lt;code&gt;throw&lt;/code&gt; is used as the return value of the &lt;code&gt;catch&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;throw&lt;/code&gt; 실행하면 형태는, 전송은 대응하는 직선 다시 제어 &lt;code&gt;catch&lt;/code&gt; 즉시 반환합니다. &lt;code&gt;throw&lt;/code&gt; 다음의 코드 는 실행되지 않습니다. &lt;code&gt;throw&lt;/code&gt; 의 두 번째 인수 는 &lt;code&gt;catch&lt;/code&gt; 의 반환 값으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="0202856c38d3263072f8da9b700d02ede351a72a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;throw&lt;/code&gt; need not appear lexically within the &lt;code&gt;catch&lt;/code&gt; that it jumps to. It can equally well be called from another function called within the &lt;code&gt;catch&lt;/code&gt;. As long as the &lt;code&gt;throw&lt;/code&gt; takes place chronologically after entry to the &lt;code&gt;catch&lt;/code&gt;, and chronologically before exit from it, it has access to that &lt;code&gt;catch&lt;/code&gt;. This is why &lt;code&gt;throw&lt;/code&gt; can be used in commands such as &lt;code&gt;exit-recursive-edit&lt;/code&gt; that throw back to the editor command loop (see &lt;a href=&quot;recursive-editing#Recursive-Editing&quot;&gt;Recursive Editing&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;throw&lt;/code&gt; 내에서 전적으로 표시 할 필요가 &lt;code&gt;catch&lt;/code&gt; 가 점프있다. &lt;code&gt;catch&lt;/code&gt; 내에서 호출되는 다른 함수에서도 동일하게 호출 될 수 있습니다 . 만큼으로 &lt;code&gt;throw&lt;/code&gt; 시간순으로 입국 후 발생 &lt;code&gt;catch&lt;/code&gt; 하고 연대순으로 그것을 종료하기 전에, 그에 액세스 할 수 있습니다 &lt;code&gt;catch&lt;/code&gt; . 이것이 &lt;code&gt;throw&lt;/code&gt; 가 편집기 명령 루프로 되돌아가는 &lt;code&gt;exit-recursive-edit&lt;/code&gt; 와 같은 명령에서 사용될 수있는 이유입니다 ( &lt;a href=&quot;recursive-editing#Recursive-Editing&quot;&gt;재귀 편집&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="a74decb60f69c5be5ea94172409090ba9d08975e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tooltip&lt;/code&gt; face determines the appearance of text shown in tooltips. It should generally use a variable-pitch font of size that is preferably smaller than the default frame font.</source>
          <target state="translated">&lt;code&gt;tooltip&lt;/code&gt; 면 은 도구 설명에 표시되는 텍스트의 모양을 결정합니다. 일반적으로 기본 프레임 글꼴보다 작은 가변 피치 글꼴을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="60eb5861f5cbed8659df08572852903a05d250cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;top-visible&lt;/code&gt; parameter specifies the number of pixels at the top of the frame that always remain visible within the parent&amp;rsquo;s native frame during dragging and should be set when specifying a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;drag-with-header-line&lt;/code&gt; parameter. The &lt;code&gt;bottom-visible&lt;/code&gt; parameter specifies the number of pixels at the bottom of the frame that always remain visible within the parent&amp;rsquo;s native frame during dragging and should be preferred when specifying a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;drag-with-mode-line&lt;/code&gt; parameter.</source>
          <target state="translated">&lt;code&gt;top-visible&lt;/code&gt; 매개 변수는 항상 드래그하는 동안 부모의 기본 프레임 내에서 계속 표시와 비 지정할 때 설정을해야한다는 프레임의 상단에있는 픽셀의 수를 지정 &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;drag-with-header-line&lt;/code&gt; 매개 변수를. &lt;code&gt;bottom-visible&lt;/code&gt; 파라미터 항상 끌어 동안 부모의 기본 프레임 내의 가시적 남아 비 지정할 때 바람직되어야하는 하단 프레임의 화소 수를 지정 &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;drag-with-mode-line&lt;/code&gt; 파라미터.</target>
        </trans-unit>
        <trans-unit id="e012f9c53fc17471a7a19403b675f18036df7992" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;track-mouse&lt;/code&gt; form causes Emacs to generate mouse motion events by binding the variable &lt;code&gt;track-mouse&lt;/code&gt; to a non-&lt;code&gt;nil&lt;/code&gt; value. If that variable has the special value &lt;code&gt;dragging&lt;/code&gt;, it additionally instructs the display engine to refrain from changing the shape of the mouse pointer. This is desirable in Lisp programs that require mouse dragging across large portions of Emacs display, which might otherwise cause the mouse pointer to change its shape according to the display portion it hovers on (see &lt;a href=&quot;pointer-shape#Pointer-Shape&quot;&gt;Pointer Shape&lt;/a&gt;). Therefore, Lisp programs that need the mouse pointer to retain its original shape during dragging should bind &lt;code&gt;track-mouse&lt;/code&gt; to the value &lt;code&gt;dragging&lt;/code&gt; at the beginning of their &lt;var&gt;body&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;track-mouse&lt;/code&gt; 형태 막스 가변 결합하여 마우스 모션 이벤트를 발생시킨다 &lt;code&gt;track-mouse&lt;/code&gt; 비에 &lt;code&gt;nil&lt;/code&gt; 값. 해당 변수에 &lt;code&gt;dragging&lt;/code&gt; 특수 값이있는 경우 추가로 디스플레이 엔진에 마우스 포인터의 모양을 변경하지 않도록 지시합니다. 이것은 Emacs 디스플레이의 많은 부분을 마우스로 드래그해야하는 Lisp 프로그램에서 바람직합니다. 그렇지 않으면 마우스 포인터가 표시되는 부분에 따라 모양이 변경 될 수 있습니다 ( &lt;a href=&quot;pointer-shape#Pointer-Shape&quot;&gt;포인터 모양&lt;/a&gt; 참조 ). 따라서 드래그하는 동안 원래 모양을 유지하기 위해 마우스 포인터가 필요한 Lisp 프로그램은 &lt;code&gt;track-mouse&lt;/code&gt; 를 &lt;code&gt;dragging&lt;/code&gt; 하는 값에 바인딩해야합니다. &lt;var&gt;body&lt;/var&gt; 의 시작 부분에 .</target>
        </trans-unit>
        <trans-unit id="b19edd674347d83642c768bcde88b949ac9815cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try-completion&lt;/code&gt; function is the basic primitive for completion: it returns the longest determined completion of a given initial string, with a given set of strings to match against.</source>
          <target state="translated">&lt;code&gt;try-completion&lt;/code&gt; 기능은 완료에 대한 기본 원시적이다 : 그것은과 비교할 문자열의 주어진 집합으로, 주어진 초기 문자열의 긴 결정 완료를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2f4b6ab7ad75f50c3944d9f90023bc41fff2a2c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unload-feature&lt;/code&gt; function is written in Lisp; its actions are based on the variable &lt;code&gt;load-history&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;unload-feature&lt;/code&gt; 기능은 리스프로 작성; 해당 작업은 변수 &lt;code&gt;load-history&lt;/code&gt; 를 기반으로합니다 .</target>
        </trans-unit>
        <trans-unit id="c7b26bfe3a503536b3db21d80937ae70a63a3b4f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unwind-protect&lt;/code&gt; construct is essential whenever you temporarily put a data structure in an inconsistent state; it permits you to make the data consistent again in the event of an error or throw. (Another more specific cleanup construct that is used only for changes in buffer contents is the atomic change group; &lt;a href=&quot;atomic-changes#Atomic-Changes&quot;&gt;Atomic Changes&lt;/a&gt;.)</source>
          <target state="translated">&lt;code&gt;unwind-protect&lt;/code&gt; 당신이 일시적으로 일치하지 않는 상태에서의 데이터 구조를 넣을 때마다 구조가 필수적이다; 이를 통해 오류 또는 발생시 데이터를 다시 일관성있게 만들 수 있습니다. (버퍼 내용의 변경에만 사용되는 또 다른보다 구체적인 정리 구조는 원자 변경 그룹, &lt;a href=&quot;atomic-changes#Atomic-Changes&quot;&gt;원자 변경&lt;/a&gt; 입니다.)</target>
        </trans-unit>
        <trans-unit id="2f49acd9789b7b2eeac22d067a11cc480fc012ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vconcat&lt;/code&gt; function also allows byte-code function objects as arguments. This is a special feature to make it easy to access the entire contents of a byte-code function object. See &lt;a href=&quot;byte_002dcode-objects#Byte_002dCode-Objects&quot;&gt;Byte-Code Objects&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;vconcat&lt;/code&gt; 의 기능은 바이트 코드 함수는 인수로 개체 수있다. 이것은 바이트 코드 함수 객체의 전체 내용에 쉽게 액세스 할 수 있도록하는 특수 기능입니다. &lt;a href=&quot;byte_002dcode-objects#Byte_002dCode-Objects&quot;&gt;바이트 코드 객체를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="74475dab8b3d8a3c528caed3c11e831ed50eb48d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;window-start&lt;/code&gt; position in the buffer as of the last time the buffer was displayed in a window.</source>
          <target state="translated">버퍼가 창에 마지막으로 표시되었을 때 버퍼 의 &lt;code&gt;window-start&lt;/code&gt; 위치입니다.</target>
        </trans-unit>
        <trans-unit id="1c8c8bc7c8ca1829e5170cf2b088a497d991bd1c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;with-case-table&lt;/code&gt; macro saves the current case table, makes &lt;var&gt;table&lt;/var&gt; the current case table, evaluates the &lt;var&gt;body&lt;/var&gt; forms, and finally restores the case table. The return value is the value of the last form in &lt;var&gt;body&lt;/var&gt;. The case table is restored even in case of an abnormal exit via &lt;code&gt;throw&lt;/code&gt; or error (see &lt;a href=&quot;nonlocal-exits#Nonlocal-Exits&quot;&gt;Nonlocal Exits&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;with-case-table&lt;/code&gt; 매크로는, 현재의 경우 테이블을 저장하게 &lt;var&gt;table&lt;/var&gt; 현재의 경우 테이블의 평가 &lt;var&gt;body&lt;/var&gt; 형태, 그리고 마지막 사례 테이블을 복원합니다. 반환 값은 &lt;var&gt;body&lt;/var&gt; 의 마지막 양식 값입니다 . &lt;code&gt;throw&lt;/code&gt; 또는 오류 를 통해 비정상적인 종료가 발생한 경우에도 케이스 테이블이 복원됩니다 ( &lt;a href=&quot;nonlocal-exits#Nonlocal-Exits&quot;&gt;Nonlocal Exits&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="5e3555312fd01da7949ec5e51b8d950b8aeb3bf5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;with-current-buffer&lt;/code&gt; macro saves the identity of the current buffer, makes &lt;var&gt;buffer-or-name&lt;/var&gt; current, evaluates the &lt;var&gt;body&lt;/var&gt; forms, and finally restores the current buffer. &lt;var&gt;buffer-or-name&lt;/var&gt; must specify an existing buffer or the name of an existing buffer.</source>
          <target state="translated">&lt;code&gt;with-current-buffer&lt;/code&gt; 매크로 현재 버퍼의 ID를 저장을 만든다 &lt;var&gt;buffer-or-name&lt;/var&gt; 전류를 평가 &lt;var&gt;body&lt;/var&gt; 형태, 그리고 마지막으로, 현재의 버퍼를 복원한다. &lt;var&gt;buffer-or-name&lt;/var&gt; 은 기존 버퍼 또는 기존 버퍼의 이름 을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="6be74ef0912f083c42a192cd4080659f8c01b40c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;with-temp-buffer&lt;/code&gt; macro evaluates the &lt;var&gt;body&lt;/var&gt; forms with a temporary buffer as the current buffer. It saves the identity of the current buffer, creates a temporary buffer and makes it current, evaluates the &lt;var&gt;body&lt;/var&gt; forms, and finally restores the previous current buffer while killing the temporary buffer. By default, undo information (see &lt;a href=&quot;undo#Undo&quot;&gt;Undo&lt;/a&gt;) is not recorded in the buffer created by this macro (but &lt;var&gt;body&lt;/var&gt; can enable that, if needed).</source>
          <target state="translated">는 &lt;code&gt;with-temp-buffer&lt;/code&gt; 매크로 평가하여 께 &lt;var&gt;body&lt;/var&gt; 현재 버퍼로서 임시 버퍼 형태. 현재 버퍼의 ID를 저장하고 임시 버퍼를 생성하여 현재로 만들고 &lt;var&gt;body&lt;/var&gt; 형태를 평가 하고 마지막으로 임시 버퍼를 죽이면서 이전 현재 버퍼를 복원합니다. 기본적으로 실행 취소 정보 ( &lt;a href=&quot;undo#Undo&quot;&gt;실행 취소&lt;/a&gt; 참조 )는이 매크로에 의해 생성 된 버퍼에 기록되지 않습니다 (그러나 필요한 경우 &lt;var&gt;body&lt;/var&gt; 활성화 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="85d2333f7e1dc8910f83232e2a64715d76356c35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;with-temp-file&lt;/code&gt; macro evaluates the &lt;var&gt;body&lt;/var&gt; forms with a temporary buffer as the current buffer; then, at the end, it writes the buffer contents into file &lt;var&gt;file&lt;/var&gt;. It kills the temporary buffer when finished, restoring the buffer that was current before the &lt;code&gt;with-temp-file&lt;/code&gt; form. Then it returns the value of the last form in &lt;var&gt;body&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;with-temp-file&lt;/code&gt; 매크로 평가 &lt;var&gt;body&lt;/var&gt; 현재 버퍼로서 임시 버퍼 형태; 그런 다음 마지막에 버퍼 내용을 file &lt;var&gt;file&lt;/var&gt; 에 씁니다 . 완료되면 임시 버퍼를 죽이고 &lt;code&gt;with-temp-file&lt;/code&gt; 형식 이전의 현재 버퍼를 복원합니다 . 그런 다음 &lt;var&gt;body&lt;/var&gt; 의 마지막 양식 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="75f491c1d7a86fd552f0176600f4381bb8cc0388" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;absolute position&lt;/em&gt; of a frame is given as a pair (X, Y) of horizontal and vertical pixel offsets relative to an origin (0, 0) of the frame&amp;rsquo;s display. Correspondingly, the &lt;em&gt;absolute edges&lt;/em&gt; of a frame are given as pixel offsets from that origin.</source>
          <target state="translated">프레임 의 &lt;em&gt;절대 위치&lt;/em&gt; 는 프레임 디스플레이의 원점 (0, 0)을 기준으로 수평 및 수직 픽셀 오프셋 쌍 (X, Y)으로 제공됩니다. 이에 따라 프레임 의 &lt;em&gt;절대 가장자리&lt;/em&gt; 는 해당 원점에서 픽셀 오프셋으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="9076db1171c8c8a5ca5175d7dfede3c98233cff3" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;advice&lt;/em&gt; feature lets you add to the existing definition of a function, by &lt;em&gt;advising the function&lt;/em&gt;. This is a cleaner method than redefining the whole function.</source>
          <target state="translated">&lt;em&gt;조언&lt;/em&gt; 기능을 사용하여 함수의 기존 정의에 추가 할 수있는 &lt;em&gt;기능을 조언&lt;/em&gt; . 이것은 전체 기능을 재정의하는 것보다 더 깨끗한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="904d222802ad2663ace2ad3097bbf68979ad4806" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;autoload&lt;/em&gt; facility lets you register the existence of a function or macro, but put off loading the file that defines it. The first call to the function automatically loads the proper library, in order to install the real definition and other associated code, then runs the real definition as if it had been loaded all along. Autoloading can also be triggered by looking up the documentation of the function or macro (see &lt;a href=&quot;documentation-basics#Documentation-Basics&quot;&gt;Documentation Basics&lt;/a&gt;), and completion of variable and function names (see &lt;a href=&quot;autoload-by-prefix#Autoload-by-Prefix&quot;&gt;Autoload by Prefix&lt;/a&gt; below).</source>
          <target state="translated">&lt;em&gt;자동로드&lt;/em&gt; 기능은 함수 또는 매크로의 존재를 등록하지만 정의하는 그것을 파일의 로딩 연기 할 수 있습니다. 함수에 대한 첫 번째 호출은 실제 정의 및 기타 관련 코드를 설치하기 위해 적절한 라이브러리를 자동으로로드 한 다음 마치로드 된 것처럼 실제 정의를 실행합니다. 자동로드는 함수 또는 매크로의 문서를 조회하고 ( &lt;a href=&quot;documentation-basics#Documentation-Basics&quot;&gt;문서 기본 사항&lt;/a&gt; 참조 ) 변수 및 함수 이름의 완성 ( 아래 &lt;a href=&quot;autoload-by-prefix#Autoload-by-Prefix&quot;&gt;접두사 별 자동로드&lt;/a&gt; 참조) 을 검색하여 트리거 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="92e5c483eda768ffc040b45483dc57544c8342d5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;autoload&lt;/em&gt; feature allows you to call a function or macro whose function definition has not yet been loaded into Emacs. It specifies which file contains the definition. When an autoload object appears as a symbol&amp;rsquo;s function definition, calling that symbol as a function automatically loads the specified file; then it calls the real definition loaded from that file. The way to arrange for an autoload object to appear as a symbol&amp;rsquo;s function definition is described in &lt;a href=&quot;autoload#Autoload&quot;&gt;Autoload&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;자동로드&lt;/em&gt; 기능을 사용하면 그 기능을 정의 아직 이맥스에로드되지 않은 함수 또는 매크로를 호출 할 수 있습니다. 정의가 포함 된 파일을 지정합니다. 자동로드 객체가 심볼의 함수 정의로 나타날 때 해당 심볼을 함수로 호출하면 지정된 파일이 자동으로로드됩니다. 그런 다음 해당 파일에서로드 된 실제 정의를 호출합니다. 자동로드 객체가 심볼의 기능 정의로 나타나도록 정렬하는 방법은 &lt;a href=&quot;autoload#Autoload&quot;&gt;Autoload에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="db7e415ee146c05de6c08823c26d0684fe6dbf60" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;body height&lt;/em&gt; of a window is the height of its text area, which does not include a mode or header line, a horizontal scroll bar, or a bottom divider.</source>
          <target state="translated">&lt;em&gt;바디 높이&lt;/em&gt; 창의은 모드 또는 헤더 행, 가로 스크롤 바 또는 하부 산기를 포함하지 않은 해당 텍스트 영역의 높이이다.</target>
        </trans-unit>
        <trans-unit id="217d247606dfc265df3143a5a2e96b2fb55c37ec" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;body width&lt;/em&gt; of a window is the width of its text area, which does not include the scroll bar, fringes, margins or a right divider. Note that when one or both fringes are removed (by setting their width to zero), the display engine reserves two character cells, one on each side of the window, for displaying the continuation and truncation glyphs, which leaves 2 columns less for text display. (The function &lt;code&gt;window-max-chars-per-line&lt;/code&gt;, described below, takes this peculiarity into account.)</source>
          <target state="translated">&lt;em&gt;바디 폭&lt;/em&gt; 윈도우의 스크롤 바, 줄무늬, 마진 또는 오른쪽 산기를 포함하지 않는 문자의 영역의 폭이다. 하나 또는 두 테두리가 제거되면 (폭을 0으로 설정하여) 디스플레이 엔진은 연속 및 잘림 글리프를 표시하기 위해 두 개의 문자 셀을 예약합니다. . ( 아래에 설명 된 &lt;code&gt;window-max-chars-per-line&lt;/code&gt; 함수 는이 특성을 고려합니다.)</target>
        </trans-unit>
        <trans-unit id="5097ffd7cf46ae9c24a40f48668d84137f1efbad" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;buffer file name&lt;/em&gt; is the name of the file that is visited in that buffer. When a buffer is not visiting a file, its buffer file name is &lt;code&gt;nil&lt;/code&gt;. Most of the time, the buffer name is the same as the nondirectory part of the buffer file name, but the buffer file name and the buffer name are distinct and can be set independently. See &lt;a href=&quot;visiting-files#Visiting-Files&quot;&gt;Visiting Files&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;버퍼 파일 이름은&lt;/em&gt; 그 버퍼에 방문 파일의 이름입니다. 버퍼가 파일을 방문하지 않을 때 버퍼 파일 이름은 &lt;code&gt;nil&lt;/code&gt; 입니다. 대부분의 경우 버퍼 이름은 버퍼 파일 이름의 비 디렉토리 부분과 동일하지만 버퍼 파일 이름과 버퍼 이름은 별개이며 독립적으로 설정할 수 있습니다. &lt;a href=&quot;visiting-files#Visiting-Files&quot;&gt;파일 방문을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9edbfee6ba6e0df8bcbbec78b92592c29e802ba7" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;buffer list&lt;/em&gt; is a list of all live buffers. The order of the buffers in this list is based primarily on how recently each buffer has been displayed in a window. Several functions, notably &lt;code&gt;other-buffer&lt;/code&gt;, use this ordering. A buffer list displayed for the user also follows this order.</source>
          <target state="translated">&lt;em&gt;버퍼 목록은&lt;/em&gt; 모든 라이브 버퍼의 목록입니다. 이 목록의 버퍼 순서는 주로 각 버퍼가 창에 얼마나 최근에 표시되었는지를 기반으로합니다. 특히 &lt;code&gt;other-buffer&lt;/code&gt; 와 같은 여러 함수 가이 순서를 사용합니다. 사용자에게 표시되는 버퍼 목록도이 순서를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="28c38d051cd80da945d60773cba7daf700f65577" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;corresponding element&lt;/em&gt; is the portion of &lt;var&gt;expval&lt;/var&gt; that is in the same structural position as the structural position of &lt;var&gt;qpat&lt;/var&gt; in the backquote-style pattern. (In the example above, the corresponding element of &lt;code&gt;second-elem&lt;/code&gt; is the second element of &lt;var&gt;expval&lt;/var&gt;.)</source>
          <target state="translated">&lt;em&gt;대응하는 요소&lt;/em&gt; 의 부분 인 &lt;var&gt;expval&lt;/var&gt; 의 구조적 위치와 동일한 위치에 구성 &lt;var&gt;qpat&lt;/var&gt; 역 인용 부호 스타일의 패턴이다. (위의 예에서 &lt;code&gt;second-elem&lt;/code&gt; 의 해당 요소는 &lt;var&gt;expval&lt;/var&gt; 의 두 번째 요소입니다 .)</target>
        </trans-unit>
        <trans-unit id="e246a752a97b0685bf65ee14255ff2c4d2e678d5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;echo area&lt;/em&gt; is used for displaying error messages (see &lt;a href=&quot;errors#Errors&quot;&gt;Errors&lt;/a&gt;), for messages made with the &lt;code&gt;message&lt;/code&gt; primitive, and for echoing keystrokes. It is not the same as the minibuffer, despite the fact that the minibuffer appears (when active) in the same place on the screen as the echo area. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Minibuffer.html#Minibuffer&quot;&gt;The Minibuffer&lt;/a&gt; in</source>
          <target state="translated">&lt;em&gt;에코 영역&lt;/em&gt; (참조 에러 메시지를 표시하기 위해 사용된다 &lt;a href=&quot;errors#Errors&quot;&gt;오류&lt;/a&gt; 만든 메시지) &lt;code&gt;message&lt;/code&gt; , 프리미티브 및 키 입력을 반향. 미니 버퍼가 화면의 에코 영역과 동일한 위치에 표시된다는 사실에도 불구하고 미니 버퍼와 동일하지 않습니다. 참조 &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Minibuffer.html#Minibuffer&quot;&gt;미니 버퍼를&lt;/a&gt; 에</target>
        </trans-unit>
        <trans-unit id="f3ea9e34e06d750f6249582c09adfb2b14c104be" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;evaluation&lt;/em&gt; of expressions in Emacs Lisp is performed by the &lt;em&gt;Lisp interpreter&lt;/em&gt;&amp;mdash;a program that receives a Lisp object as input and computes its &lt;em&gt;value as an expression&lt;/em&gt;. How it does this depends on the data type of the object, according to rules described in this chapter. The interpreter runs automatically to evaluate portions of your program, but can also be called explicitly via the Lisp primitive function &lt;code&gt;eval&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;평가&lt;/em&gt; 이맥스 리스프에서 표현식이 수행된다 &lt;em&gt;인터프리터 리스프&lt;/em&gt; 입력으로 리스프 객체를 수신하고, 계산 -a 프로그램 &lt;em&gt;식으로 값&lt;/em&gt; . 이를 수행하는 방법은이 장에 설명 된 규칙에 따라 객체의 데이터 유형에 따라 다릅니다. 인터프리터는 프로그램의 일부를 평가하기 위해 자동으로 실행되지만 Lisp 기본 함수 &lt;code&gt;eval&lt;/code&gt; 을 통해 명시 적으로 호출 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a4c54835a8ed7b0637b2955ac97e3f976fc948b0" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;external border&lt;/em&gt; is part of the decorations supplied by the window manager. It is typically used for resizing the frame with the mouse and is therefore not shown on &amp;ldquo;fullboth&amp;rdquo; and maximized frames (see &lt;a href=&quot;size-parameters#Size-Parameters&quot;&gt;Size Parameters&lt;/a&gt;). Its width is determined by the window manager and cannot be changed by Emacs&amp;rsquo; functions.</source>
          <target state="translated">&lt;em&gt;외부 테두리&lt;/em&gt; 창 관리자가 제공하는 장식의 일부입니다. 일반적으로 마우스로 프레임 크기를 조정하는 데 사용되므로 &quot;fullboth&quot;및 최대화 된 프레임에는 표시되지 않습니다 ( &lt;a href=&quot;size-parameters#Size-Parameters&quot;&gt;크기 매개 변수&lt;/a&gt; 참조 ). 너비는 창 관리자에 의해 결정되며 Emacs의 기능으로 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f2d8bed44c2c20c17f4bf773118cf6698d61845b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;fringe bitmaps&lt;/em&gt; are the actual bitmaps which represent the logical fringe indicators for truncated or continued lines, buffer boundaries, overlay arrows, etc. Each bitmap is represented by a symbol. These symbols are referred to by the variable &lt;code&gt;fringe-indicator-alist&lt;/code&gt;, which maps fringe indicators to bitmaps (see &lt;a href=&quot;fringe-indicators#Fringe-Indicators&quot;&gt;Fringe Indicators&lt;/a&gt;), and the variable &lt;code&gt;fringe-cursor-alist&lt;/code&gt;, which maps fringe cursors to bitmaps (see &lt;a href=&quot;fringe-cursors#Fringe-Cursors&quot;&gt;Fringe Cursors&lt;/a&gt;).</source>
          <target state="translated">&lt;em&gt;프린지 비트 맵&lt;/em&gt; 리거나 계속 라인 논리 프린지 지표를 나타내는 실제 비트 맵이며, 경계 등, 오버레이 화살표 각 비트 맵이 기호로 표시되는 버퍼. 이러한 기호는 &lt;code&gt;fringe-indicator-alist&lt;/code&gt; 변수로 참조되며 , fringe 표시기를 비트 맵에 매핑하고 ( &lt;a href=&quot;fringe-indicators#Fringe-Indicators&quot;&gt;Fringe Indicators&lt;/a&gt; 참조 ) 변수 &lt;code&gt;fringe-cursor-alist&lt;/code&gt; 는 가장자리 커서를 비트 맵에 매핑합니다 ( &lt;a href=&quot;fringe-cursors#Fringe-Cursors&quot;&gt;Fringe Cursors&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="c3217775f22c68286c9e9e2ce3e64e15e557ece9" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;function definition&lt;/em&gt; of a symbol is the object stored in the function cell of the symbol. The functions described here access, test, and set the function cell of symbols.</source>
          <target state="translated">심볼 의 &lt;em&gt;기능 정의&lt;/em&gt; 는 심볼의 기능 셀에 저장된 객체입니다. 여기에 설명 된 기능은 기호의 기능 셀에 액세스, 테스트 및 설정합니다.</target>
        </trans-unit>
        <trans-unit id="e263e404107701ba2e2127c05d30319797f11c39" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;inner frame&lt;/em&gt; is the rectangle reserved for the frame&amp;rsquo;s windows. It&amp;rsquo;s enclosed by the internal border which, however, is not part of the inner frame. Its edges are called the &lt;em&gt;inner edges&lt;/em&gt; of the frame. The &lt;em&gt;inner width&lt;/em&gt; and &lt;em&gt;inner height&lt;/em&gt; specify the &lt;em&gt;inner size&lt;/em&gt; of the rectangle. The inner frame is sometimes also referred to as the &lt;em&gt;display area&lt;/em&gt; of the frame.</source>
          <target state="translated">&lt;em&gt;내부 프레임은&lt;/em&gt; 프레임의 창에 예약 된 사각형이다. 그러나 내부 프레임의 일부가 아닌 내부 테두리로 둘러싸여 있습니다. 그 가장자리를 프레임 의 &lt;em&gt;안쪽 가장자리&lt;/em&gt; 라고합니다 . &lt;em&gt;내폭&lt;/em&gt; 및 &lt;em&gt;내부 높이&lt;/em&gt; 지정 &lt;em&gt;내부 크기&lt;/em&gt; 사각형한다. 내부 프레임은 때때로 프레임의 &lt;em&gt;표시 영역&lt;/em&gt; 이라고도합니다 .</target>
        </trans-unit>
        <trans-unit id="5a74065a844b2999c1d678863c486ee2bfa66178" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;native frame&lt;/em&gt; is a rectangle located entirely within the outer frame. It excludes the areas occupied by an external or outer border, the title bar and any external menu or tool bar. The edges of the native frame are called the &lt;em&gt;native edges&lt;/em&gt; of the frame. Together, the &lt;em&gt;native width&lt;/em&gt; and &lt;em&gt;native height&lt;/em&gt; of a frame specify the &lt;em&gt;native size&lt;/em&gt; of the frame.</source>
          <target state="translated">&lt;em&gt;기본 프레임은&lt;/em&gt; 외부 프레임 내에 완전히 위치한 사각형이다. 외부 또는 외부 테두리, 제목 표시 줄 및 외부 메뉴 또는 도구 모음이 차지하는 영역은 제외됩니다. 기본 프레임의 가장자리를 프레임의 &lt;em&gt;기본 가장자리&lt;/em&gt; 라고합니다 . 프레임 의 &lt;em&gt;기본 너비&lt;/em&gt; 와 &lt;em&gt;기본 높이는&lt;/em&gt; 함께 프레임의 &lt;em&gt;기본 크기&lt;/em&gt; 를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="ae4cf0b922d8647c81dfc51bc033d154bb0b9c1e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;nice value&lt;/em&gt; of the process, a number. (Processes with smaller nice values get scheduled more favorably.)</source>
          <target state="translated">프로세스 의 &lt;em&gt;좋은 가치&lt;/em&gt; , 숫자. (더 작은 nice 값을 가진 프로세스가 더 유리하게 예약됩니다.)</target>
        </trans-unit>
        <trans-unit id="2c09e0fcd64a13f02c8fe447c36039473c0ce853" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;outer border&lt;/em&gt; is a separate border whose width can be specified with the &lt;code&gt;border-width&lt;/code&gt; frame parameter (see &lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;Layout Parameters&lt;/a&gt;). In practice, either the external or the outer border of a frame are displayed but never both at the same time. Usually, the outer border is shown only for special frames that are not (fully) controlled by the window manager like tooltip frames (see &lt;a href=&quot;tooltips#Tooltips&quot;&gt;Tooltips&lt;/a&gt;), child frames (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;) and &lt;code&gt;undecorated&lt;/code&gt; or &lt;code&gt;override-redirect&lt;/code&gt; frames (see &lt;a href=&quot;management-parameters#Management-Parameters&quot;&gt;Management Parameters&lt;/a&gt;).</source>
          <target state="translated">&lt;em&gt;외측 테두리는&lt;/em&gt; 그 폭과 지정 될 수있는 별도의 국경 &lt;code&gt;border-width&lt;/code&gt; 프레임 파라미터 (참조 &lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;레이아웃 파라미터&lt;/a&gt; ). 실제로 프레임의 외부 또는 외부 테두리가 표시되지만 동시에 둘 다 표시되지는 않습니다. 일반적으로 외부 테두리는 도구 설명 프레임 ( &lt;a href=&quot;tooltips#Tooltips&quot;&gt;도구 설명&lt;/a&gt; 참조 ), 하위 프레임 ( &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;하위 프레임&lt;/a&gt; 참조 ) 및 &lt;code&gt;undecorated&lt;/code&gt; 않거나 &lt;code&gt;override-redirect&lt;/code&gt; 프레임 ( &lt;a href=&quot;management-parameters#Management-Parameters&quot;&gt;관리 매개 변수&lt;/a&gt; 참조 )과 같이 창 관리자에 의해 (완전히) 제어되지 않는 특수 프레임에 대해서만 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="2a16135456343ff9bfb76f420c809a82672446af" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;outer frame&lt;/em&gt; is a rectangle comprising all areas shown in the drawing. The edges of that rectangle are called the &lt;em&gt;outer edges&lt;/em&gt; of the frame. Together, the &lt;em&gt;outer width&lt;/em&gt; and &lt;em&gt;outer height&lt;/em&gt; of the frame specify the &lt;em&gt;outer size&lt;/em&gt; of that rectangle.</source>
          <target state="translated">&lt;em&gt;외부 프레임은&lt;/em&gt; 도시 모든 영역을 포함하는 직사각형이다. 이 직사각형의 가장자리를 프레임 의 &lt;em&gt;외부 가장자리&lt;/em&gt; 라고합니다 . 프레임 의 &lt;em&gt;외부 너비&lt;/em&gt; 와 &lt;em&gt;외부 높이는&lt;/em&gt; 함께 해당 사각형 의 &lt;em&gt;외부 크기&lt;/em&gt; 를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="63a8b7096512c8aa2271f3f9850a19c72d70184b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;overlay arrow&lt;/em&gt; is useful for directing the user&amp;rsquo;s attention to a particular line in a buffer. For example, in the modes used for interface to debuggers, the overlay arrow indicates the line of code about to be executed. This feature has nothing to do with &lt;em&gt;overlays&lt;/em&gt; (see &lt;a href=&quot;overlays#Overlays&quot;&gt;Overlays&lt;/a&gt;).</source>
          <target state="translated">&lt;em&gt;오버레이 화살표&lt;/em&gt; 버퍼 내의 특정 라인에 사용자의 관심을 유도하는데 유용하다. 예를 들어 디버거 인터페이스에 사용되는 모드에서 오버레이 화살표는 실행될 코드 줄을 나타냅니다. 이 기능은 &lt;em&gt;오버레이&lt;/em&gt; 와 관련이 없습니다 ( &lt;a href=&quot;overlays#Overlays&quot;&gt;오버레이&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="9d788001216c640953c68e8a1fd972cb556924b6" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;printable &lt;acronym&gt;ASCII&lt;/acronym&gt; characters&lt;/em&gt;, character codes 32 through 126 (consisting of numerals, English letters, and symbols like &amp;lsquo;</source>
          <target state="translated">&lt;em&gt;인쇄 가능한 &lt;acronym&gt;ASCII의&lt;/acronym&gt; 문자&lt;/em&gt; , 문자 코드 (32) (126) (숫자로 구성을 통해, 같은 영어 문자 및 기호 '</target>
        </trans-unit>
        <trans-unit id="ee5f0d9d7366f64e692b08bd6bdd53cffd9ff956" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;printed representation&lt;/em&gt; of an object is the format of the output generated by the Lisp printer (the function &lt;code&gt;prin1&lt;/code&gt;) for that object. Every data type has a unique printed representation. The &lt;em&gt;read syntax&lt;/em&gt; of an object is the format of the input accepted by the Lisp reader (the function &lt;code&gt;read&lt;/code&gt;) for that object. This is not necessarily unique; many kinds of object have more than one syntax. See &lt;a href=&quot;read-and-print#Read-and-Print&quot;&gt;Read and Print&lt;/a&gt;.</source>
          <target state="translated">개체 의 &lt;em&gt;인쇄 된 표현&lt;/em&gt; 은 해당 개체에 대해 Lisp 프린터 (함수 &lt;code&gt;prin1&lt;/code&gt; )에서 생성 한 출력 형식입니다 . 모든 데이터 유형에는 고유 한 인쇄 표현이 있습니다. 객체 의 &lt;em&gt;읽기 구문&lt;/em&gt; 은 해당 객체에 대해 Lisp 판독기 ( &lt;code&gt;read&lt;/code&gt; 함수 )에서 허용하는 입력 형식입니다 . 이것은 반드시 고유 한 것은 아닙니다. 많은 종류의 객체에는 둘 이상의 구문이 있습니다. &lt;a href=&quot;read-and-print#Read-and-Print&quot;&gt;읽기 및 인쇄를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="16283fc66bc938541ae5f94a57f5db7f82024d76" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;sequence&lt;/em&gt; type is the union of two other Lisp types: lists and arrays. In other words, any list is a sequence, and any array is a sequence. The common property that all sequences have is that each is an ordered collection of elements.</source>
          <target state="translated">&lt;em&gt;시퀀스&lt;/em&gt; 리스트와 배열 : 유형이 다른 두 리스프 유형의 조합입니다. 즉, 모든 목록은 시퀀스이고 모든 배열은 시퀀스입니다. 모든 시퀀스의 공통 속성은 각 시퀀스가 ​​정렬 된 요소 모음이라는 것입니다.</target>
        </trans-unit>
        <trans-unit id="26bbe6f8407610c43aa3bfb4d0e5236a34a2cd8d" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;syntax class&lt;/em&gt; of a character describes its syntactic role. Each syntax table specifies the syntax class of each character. There is no necessary relationship between the class of a character in one syntax table and its class in any other table.</source>
          <target state="translated">문자 의 &lt;em&gt;구문 클래스&lt;/em&gt; 는 구문 역할을 설명합니다. 각 구문 테이블은 각 문자의 구문 클래스를 지정합니다. 한 구문 테이블의 문자 클래스와 다른 테이블의 클래스 간에는 필요한 관계가 없습니다.</target>
        </trans-unit>
        <trans-unit id="926a41bf96866251570aab9ee4f7d77e1444ba77" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;text area&lt;/em&gt; of a frame is a somewhat fictitious area that can be embedded in the native frame. Its position is unspecified. Its width can be obtained by removing from that of the native width the widths of the internal border, one vertical scroll bar, and one left and one right fringe if they are specified for this frame, see &lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;Layout Parameters&lt;/a&gt;. Its height can be obtained by removing from that of the native height the widths of the internal border and the heights of the frame&amp;rsquo;s internal menu and tool bars and one horizontal scroll bar if specified for this frame.</source>
          <target state="translated">프레임 의 &lt;em&gt;텍스트 영역&lt;/em&gt; 은 기본 프레임에 포함될 수있는 다소 가상의 영역입니다. 위치가 지정되지 않았습니다. 이 프레임에 대해 지정된 경우 내부 테두리, 세로 스크롤 막대, 왼쪽 및 오른쪽 가장자리의 너비를 기본 너비에서 제거하여 너비를 얻을 수 있습니다 . &lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;레이아웃 매개 변수를&lt;/a&gt; 참조하세요 . 높이는 기본 높이에서 내부 테두리의 너비와 프레임의 내부 메뉴 및 도구 모음의 높이를 제거하고이 프레임에 대해 지정된 경우 하나의 가로 스크롤 막대를 제거하여 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc567aa0f13044eee99b9583effa6fce58743091" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;title bar&lt;/em&gt;, a.k.a. &lt;em&gt;caption bar&lt;/em&gt;, is also part of the window manager&amp;rsquo;s decorations and typically displays the title of the frame (see &lt;a href=&quot;frame-titles#Frame-Titles&quot;&gt;Frame Titles&lt;/a&gt;) as well as buttons for minimizing, maximizing and deleting the frame. It can be also used for dragging the frame with the mouse. The title bar is usually not displayed for fullboth (see &lt;a href=&quot;size-parameters#Size-Parameters&quot;&gt;Size Parameters&lt;/a&gt;), tooltip (see &lt;a href=&quot;tooltips#Tooltips&quot;&gt;Tooltips&lt;/a&gt;) and child frames (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;) and doesn&amp;rsquo;t exist for terminal frames. Display of the title bar can be suppressed by setting the &lt;code&gt;override-redirect&lt;/code&gt; or the &lt;code&gt;undecorated&lt;/code&gt; frame parameters (see &lt;a href=&quot;management-parameters#Management-Parameters&quot;&gt;Management Parameters&lt;/a&gt;).</source>
          <target state="translated">&lt;em&gt;제목 표시 줄&lt;/em&gt; , 일명 &lt;em&gt;캡션 바&lt;/em&gt; (참조 또한 윈도우 매니저의 훈장의 일부이며 일반적으로 프레임의 제목을 표시 &lt;a href=&quot;frame-titles#Frame-Titles&quot;&gt;프레임 제목을&lt;/a&gt; )뿐만 아니라, 최소화 최대화하고 프레임을 삭제하는 버튼. 마우스로 프레임을 드래그 할 때도 사용할 수 있습니다. 제목 표시 줄은 일반적으로 전체 ( &lt;a href=&quot;size-parameters#Size-Parameters&quot;&gt;크기 매개 변수&lt;/a&gt; 참조 ), 도구 설명 ( &lt;a href=&quot;tooltips#Tooltips&quot;&gt;도구 설명&lt;/a&gt; 참조 ) 및 하위 프레임 ( &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;하위 프레임&lt;/a&gt; 참조 )에 대해 표시되지 않으며 터미널 프레임에 대해서는 존재하지 않습니다. &lt;code&gt;override-redirect&lt;/code&gt; 또는 &lt;code&gt;undecorated&lt;/code&gt; 프레임 매개 변수 를 설정하여 제목 표시 줄의 표시를 억제 할 수 있습니다 ( &lt;a href=&quot;management-parameters#Management-Parameters&quot;&gt;관리 매개 변수&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="cf5061df863bf4d7e25945860733704a7f478bc7" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;total height&lt;/em&gt; of a window is the number of lines comprising the window&amp;rsquo;s body, the header line, the horizontal scroll bar, the mode line and the bottom divider (if any).</source>
          <target state="translated">&lt;em&gt;전체 높이&lt;/em&gt; 창의 창 신체 헤더 라인, 가로 스크롤 바, 상기 모드 라인과 하단 분배기 (있는 경우)를 포함하는 라인의 수이다.</target>
        </trans-unit>
        <trans-unit id="df7776a34012721e685782936a52e8dfef11825e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;total width&lt;/em&gt; of a window is the number of lines comprising the window&amp;rsquo;s body, its margins, fringes, scroll bars and a right divider (if any).</source>
          <target state="translated">&lt;em&gt;전폭&lt;/em&gt; 윈도우의 윈도우의 몸, 마진, 줄무늬, 스크롤 바 및 우측 칸막이 (있는 경우)를 포함하는 라인의 수이다.</target>
        </trans-unit>
        <trans-unit id="0a4f1e482e03cd1786491328f05f6a3a541b8f00" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;truename&lt;/em&gt; of a file is the name that you get by following symbolic links at all levels until none remain, then simplifying away &amp;lsquo;</source>
          <target state="translated">&lt;em&gt;truename&lt;/em&gt; 의 파일은 '아무도 남아 있지 않을 때까지 당신이 다음 멀리 단순화, 모든 수준에서 심볼릭 링크를 따라 얻을 이름입니다</target>
        </trans-unit>
        <trans-unit id="5a368df5a1b8c9ef35e252db40eaf9e6300e7992" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;use time&lt;/em&gt; of a window is not really a time value, but an integer that does increase monotonically with each call of &lt;code&gt;select-window&lt;/code&gt; with a &lt;code&gt;nil&lt;/code&gt;&lt;var&gt;norecord&lt;/var&gt; argument. The window with the lowest use time is usually called the least recently used window while the window with the highest use time is called the most recently used one (see &lt;a href=&quot;cyclic-window-ordering#Cyclic-Window-Ordering&quot;&gt;Cyclic Window Ordering&lt;/a&gt;).</source>
          <target state="translated">&lt;em&gt;사용 시간&lt;/em&gt; 창의 정말 시간 값이 아니라 않는 정수의 각 호출 단조 증가 &lt;code&gt;select-window&lt;/code&gt; A를 &lt;code&gt;nil&lt;/code&gt; &lt;var&gt;norecord&lt;/var&gt; 의 인수. 사용 시간이 가장 낮은 창을 일반적으로 가장 최근에 사용한 창이라고하며 가장 많이 사용하는 창을 가장 최근에 사용한 창이라고합니다 ( &lt;a href=&quot;cyclic-window-ordering#Cyclic-Window-Ordering&quot;&gt;순환 창 순서&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="5970313ec78081de0b5e6fa3c17cbcb799a07f06" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;window state change flag&lt;/em&gt; of a frame, if set, will cause the default values of &lt;code&gt;window-state-change-functions&lt;/code&gt; (for that frame) and &lt;code&gt;window-state-change-hook&lt;/code&gt; to be run during next redisplay regardless of whether a window state change actually occurred for that frame or not. After running any functions on these hooks, the flag is reset for each frame. Applications can set that flag and inspect its value using the following functions.</source>
          <target state="translated">설정된 경우 프레임 의 &lt;em&gt;창 상태 변경 플래그&lt;/em&gt; 는 창 상태 여부에 관계없이 다음 다시 표시 중에 창 상태 &lt;code&gt;window-state-change-functions&lt;/code&gt; (해당 프레임에 대한) 및 &lt;code&gt;window-state-change-hook&lt;/code&gt; 의 기본값 이 실행되도록합니다. 그 프레임에 대해 실제로 변경이 발생했는지 여부. 이러한 후크에서 기능을 실행 한 후 각 프레임에 대해 플래그가 재설정됩니다. 애플리케이션은 다음 함수를 사용하여 해당 플래그를 설정하고 값을 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d16338fb95ab07992fcf2621cd0fa8dac537741" translate="yes" xml:space="preserve">
          <source>The &lt;small&gt;CAR&lt;/small&gt; of each entry of this alist is a symbol specifying the parameter. The &lt;small&gt;CDR&lt;/small&gt; should be one of the following:</source>
          <target state="translated">이 목록 의 각 항목의 &lt;small&gt;CAR&lt;/small&gt; 은 매개 변수를 지정하는 기호입니다. &lt;small&gt;CDR은&lt;/small&gt; 다음 중 하나 여야합니다 :</target>
        </trans-unit>
        <trans-unit id="e49ce88f5cd8792ee1a6675c8d5cc998d7f16094" translate="yes" xml:space="preserve">
          <source>The &lt;small&gt;CAR&lt;/small&gt;, &lt;var&gt;characters&lt;/var&gt;, can be either a character or a string. The element says to give that character or characters the syntax specified by &lt;var&gt;syntax-description&lt;/var&gt;, which is passed to &lt;code&gt;modify-syntax-entry&lt;/code&gt; (see &lt;a href=&quot;syntax-table-functions#Syntax-Table-Functions&quot;&gt;Syntax Table Functions&lt;/a&gt;).</source>
          <target state="translated">&lt;small&gt;자동차&lt;/small&gt; , &lt;var&gt;characters&lt;/var&gt; , 문자 또는 문자열이 될 수 있습니다. 요소는 해당 문자 또는 문자에 &lt;var&gt;syntax-description&lt;/var&gt; 으로 지정된 구문을 제공하도록 지시하며 이는 &lt;code&gt;modify-syntax-entry&lt;/code&gt; 에 전달됩니다 ( &lt;a href=&quot;syntax-table-functions#Syntax-Table-Functions&quot;&gt;구문 테이블 함수&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="080c3e614f7fb18227cc5998f98d3b818d3afa14" translate="yes" xml:space="preserve">
          <source>The &lt;small&gt;CAR&lt;/small&gt;, &lt;var&gt;item-string&lt;/var&gt;, is the string to be displayed in the menu. It should be short&amp;mdash;preferably one to three words. It should describe the action of the command it corresponds to. Note that not all graphical toolkits can display non-</source>
          <target state="translated">&lt;small&gt;CAR&lt;/small&gt; , &lt;var&gt;item-string&lt;/var&gt; 메뉴에 표시 할 문자열입니다. 짧아야합니다. 1 ~ 3 단어가 좋습니다. 해당하는 명령의 동작을 설명해야합니다. 모든 그래픽 툴킷이 비</target>
        </trans-unit>
        <trans-unit id="e0a23dd8d612c78e404d710bcf5dfd6ed67ae9dd" translate="yes" xml:space="preserve">
          <source>The &lt;small&gt;CAR&lt;/small&gt;, &lt;var&gt;option&lt;/var&gt;, is a string, the name of a command-line option (including the initial hyphen). The &lt;var&gt;handler-function&lt;/var&gt; is called to handle &lt;var&gt;option&lt;/var&gt;, and receives the option name as its sole argument.</source>
          <target state="translated">&lt;small&gt;CAR&lt;/small&gt; , &lt;var&gt;option&lt;/var&gt; , 문자열, (초기 하이픈 포함) 명령 줄 옵션의 이름입니다. &lt;var&gt;handler-function&lt;/var&gt; 처리하기 위해 호출 &lt;var&gt;option&lt;/var&gt; , 그것의 유일한 인수로 옵션 이름을받습니다.</target>
        </trans-unit>
        <trans-unit id="a7747b7d0b978aa494fc040c28ed49005a49fbd7" translate="yes" xml:space="preserve">
          <source>The &lt;small&gt;CAR&lt;/small&gt;, &lt;var&gt;subexp&lt;/var&gt;, is an integer specifying which subexpression of the match to fontify (0 means the entire matching text). The second subelement, &lt;var&gt;facespec&lt;/var&gt;, is an expression whose value specifies the face, as described above.</source>
          <target state="translated">&lt;small&gt;CAR은&lt;/small&gt; , &lt;var&gt;subexp&lt;/var&gt; 은 , 경기 표현식 (0 수단 전체 매칭 텍스트) fontify 정수를 지정한다. 두 번째 하위 요소 인 &lt;var&gt;facespec&lt;/var&gt; 은 위에서 설명한대로 값이 얼굴을 지정하는 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="fbe99fb685d5b20fe0da1df63eb118ad684010c5" translate="yes" xml:space="preserve">
          <source>The &lt;small&gt;CDR&lt;/small&gt; of the element, &lt;var&gt;coding&lt;/var&gt;, should be either a coding system, a cons cell containing two coding systems, or a function name (a symbol with a function definition). If &lt;var&gt;coding&lt;/var&gt; is a coding system, that coding system is used for both reading the file and writing it. If &lt;var&gt;coding&lt;/var&gt; is a cons cell containing two coding systems, its &lt;small&gt;CAR&lt;/small&gt; specifies the coding system for decoding, and its &lt;small&gt;CDR&lt;/small&gt; specifies the coding system for encoding.</source>
          <target state="translated">요소 인 &lt;var&gt;coding&lt;/var&gt; 의 &lt;small&gt;CDR&lt;/small&gt; 은 코딩 시스템, 두 개의 코딩 시스템을 포함하는 cons 셀 또는 함수 이름 (함수 정의가있는 기호)이어야합니다. 경우 &lt;var&gt;coding&lt;/var&gt; 코딩 시스템은 모두 파일을 읽고 그것을 쓰기에 사용되는, 코딩 시스템입니다. &lt;var&gt;coding&lt;/var&gt; 이 두 개의 코딩 시스템을 포함하는 단점 셀인 경우 &lt;small&gt;CAR&lt;/small&gt; 은 디코딩을위한 코딩 시스템을 지정 하고 &lt;small&gt;CDR&lt;/small&gt; 은 인코딩을위한 코딩 시스템을 지정합니다.&lt;small&gt;&lt;/small&gt;&lt;small&gt;&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="eadcb8d9ac867b4bc1c3959f1bb9e74b5fc964c3" translate="yes" xml:space="preserve">
          <source>The &lt;small&gt;GNU&lt;/small&gt;&lt;code&gt;Coreutils&lt;/code&gt; Manual</source>
          <target state="translated">&lt;small&gt;GNU &lt;/small&gt; &lt;code&gt;Coreutils&lt;/code&gt; 매뉴얼</target>
        </trans-unit>
        <trans-unit id="8b3d5cecab4d963718b0a6b6d47d896d90a339da" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;action&lt;/var&gt; argument.</source>
          <target state="translated">&lt;var&gt;action&lt;/var&gt; 인수.</target>
        </trans-unit>
        <trans-unit id="4bcf2fda42e12989ef3ca0c11552c2b31eccd611" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;align&lt;/var&gt; argument may also be a list &lt;code&gt;(&lt;var&gt;align&lt;/var&gt;
&lt;var&gt;periodic&lt;/var&gt;)&lt;/code&gt; where &lt;var&gt;align&lt;/var&gt; is interpreted as described above. If &lt;var&gt;periodic&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it specifies that the rows in &lt;code&gt;bits&lt;/code&gt; should be repeated enough times to reach the specified height.</source>
          <target state="translated">&lt;var&gt;align&lt;/var&gt; 인수는 또한리스트 일 수있다 &lt;code&gt;(&lt;var&gt;align&lt;/var&gt; &lt;var&gt;periodic&lt;/var&gt;)&lt;/code&gt; 여기서 &lt;var&gt;align&lt;/var&gt; 상술 한 바와 같이 해석된다. 경우 &lt;var&gt;periodic&lt;/var&gt; 비이다 &lt;code&gt;nil&lt;/code&gt; , 그것의 행하도록 지정 &lt;code&gt;bits&lt;/code&gt; 지정된 높이에 도달 할 정도로 회 반복한다.</target>
        </trans-unit>
        <trans-unit id="b05c56c38c737d0175513c9a788605ea9cfba32d" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;array&lt;/var&gt; should be mutable. See &lt;a href=&quot;mutability#Mutability&quot;&gt;Mutability&lt;/a&gt;.</source>
          <target state="translated">&lt;var&gt;array&lt;/var&gt; 가변되어야한다. &lt;a href=&quot;mutability#Mutability&quot;&gt;Mutability를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2eff832af67f0f23474068445f337e5f973d50b5" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;body&lt;/var&gt; forms should not use the minibuffer more than once. If the minibuffer is re-entered recursively, &lt;var&gt;function&lt;/var&gt; will only be called once, for the outermost use of the minibuffer.</source>
          <target state="translated">&lt;var&gt;body&lt;/var&gt; 형태는 두 번 이상 미니 버퍼를 사용하지 말아야합니다. 미니 버퍼가 재귀 적으로 재 입력 되면, 미니 버퍼의 가장 바깥 쪽 사용을 위해 &lt;var&gt;function&lt;/var&gt; 는 한 번만 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="25d40a90977bab6a7277cfccfa36bab3a91341d9" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;body&lt;/var&gt; is inspected at compilation time, and only the symbols that appear in &lt;var&gt;body&lt;/var&gt; with a &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;body&lt;/var&gt; 에 나타나는 기호 만 컴파일 시간에 검사하고, &lt;var&gt;body&lt;/var&gt; '은과를</target>
        </trans-unit>
        <trans-unit id="cd761e030f558aabcde6ca15db330bae7e53acff" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;buffer-or-name&lt;/var&gt; and &lt;var&gt;norecord&lt;/var&gt; arguments have the same meanings as in &lt;code&gt;switch-to-buffer&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;buffer-or-name&lt;/var&gt; 과 &lt;var&gt;norecord&lt;/var&gt; 인수와 동일한 의미를 가지고 &lt;code&gt;switch-to-buffer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88e2285bcf064744d6763e2dc89f7fc8ba369a0d" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;buffer&lt;/var&gt; argument is the buffer to associate with the connection. Output from the connection is inserted in the buffer, unless you specify your own filter function to handle the output. If &lt;var&gt;buffer&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, it means that the connection is not associated with any buffer.</source>
          <target state="translated">&lt;var&gt;buffer&lt;/var&gt; 인수는 접속에 연결하는 버퍼이다. 출력을 처리하기 위해 자체 필터 함수를 지정하지 않는 한 연결의 출력은 버퍼에 삽입됩니다. 경우 &lt;var&gt;buffer&lt;/var&gt; 이다 &lt;code&gt;nil&lt;/code&gt; , 상기 연결은 임의의 버퍼와 연관되지 않는다는 것을 의미한다.</target>
        </trans-unit>
        <trans-unit id="19573e4fe6e8797ca8d2698b89b9d56ef0deda57" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;cipher&lt;/var&gt; can be the whole plist from &lt;code&gt;gnutls-ciphers&lt;/code&gt;, or just the symbol key, or a string with the name of that symbol.</source>
          <target state="translated">&lt;var&gt;cipher&lt;/var&gt; 에서 전체 PLIST 수 있습니다 &lt;code&gt;gnutls-ciphers&lt;/code&gt; , 아니면 그냥 기호 키 또는 해당 심볼의 이름을 가진 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="9358734f2ec35fb2f2572d67721cdbdbe0a84b23" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;contents&lt;/var&gt; of a register can have several possible types:</source>
          <target state="translated">레지스터 의 &lt;var&gt;contents&lt;/var&gt; 은 몇 가지 가능한 유형을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6901063123b348019b3ef01026e7a9347a9f0aad" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;count&lt;/var&gt; argument can be a cons cell, &lt;code&gt;(&lt;var&gt;cols&lt;/var&gt;
. &lt;var&gt;lines&lt;/var&gt;)&lt;/code&gt;, instead of an integer. Then the function moves by &lt;var&gt;lines&lt;/var&gt; screen lines, and puts point &lt;var&gt;cols&lt;/var&gt; columns from the visual start of that screen line. Note that &lt;var&gt;cols&lt;/var&gt; are counted from the &lt;em&gt;visual&lt;/em&gt; start of the line; if the window is scrolled horizontally (see &lt;a href=&quot;horizontal-scrolling#Horizontal-Scrolling&quot;&gt;Horizontal Scrolling&lt;/a&gt;), the column on which point will end is in addition to the number of columns by which the text is scrolled.</source>
          <target state="translated">&lt;var&gt;count&lt;/var&gt; 인수는 반대 세포 일 수있다 &lt;code&gt;(&lt;var&gt;cols&lt;/var&gt; . &lt;var&gt;lines&lt;/var&gt;)&lt;/code&gt; 대신 정수. 그런 다음 함수는 &lt;var&gt;lines&lt;/var&gt; 스크린 라인으로 이동하고 해당 스크린 라인의 시각적 시작에서 포인트 &lt;var&gt;cols&lt;/var&gt; 열을 배치합니다. 참고 &lt;var&gt;cols&lt;/var&gt; 로부터 계산되는 &lt;em&gt;영상&lt;/em&gt; 라인의 개시; 창이 수평으로 스크롤되는 경우 ( &lt;a href=&quot;horizontal-scrolling#Horizontal-Scrolling&quot;&gt;수평 스크롤&lt;/a&gt; 참조 ) 지점이 끝나는 열은 텍스트가 스크롤되는 열 수에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="f2ad21d8232e7c9573096d6fec09010bbae18135" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;data-type&lt;/var&gt; argument specifies the form of data conversion to use, to convert the raw data obtained from another program into Lisp data. Meaningful values include &lt;code&gt;TEXT&lt;/code&gt;, &lt;code&gt;STRING&lt;/code&gt;, &lt;code&gt;UTF8_STRING&lt;/code&gt;, &lt;code&gt;TARGETS&lt;/code&gt;, &lt;code&gt;LENGTH&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, &lt;code&gt;FILE_NAME&lt;/code&gt;, &lt;code&gt;CHARACTER_POSITION&lt;/code&gt;, &lt;code&gt;NAME&lt;/code&gt;, &lt;code&gt;LINE_NUMBER&lt;/code&gt;, &lt;code&gt;COLUMN_NUMBER&lt;/code&gt;, &lt;code&gt;OWNER_OS&lt;/code&gt;, &lt;code&gt;HOST_NAME&lt;/code&gt;, &lt;code&gt;USER&lt;/code&gt;, &lt;code&gt;CLASS&lt;/code&gt;, &lt;code&gt;ATOM&lt;/code&gt;, and &lt;code&gt;INTEGER&lt;/code&gt;. (These are symbols with upper-case names in accord with X conventions.) The default for &lt;var&gt;data-type&lt;/var&gt; is &lt;code&gt;STRING&lt;/code&gt;. Window systems other than X usually support only a small subset of these types, in addition to &lt;code&gt;STRING&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;data-type&lt;/var&gt; 인수 지정 용도에 데이터 변환의 형태는 리스프 데이터로 다른 프로그램에 의한 원시 데이터를 변환하는 방법. 의미있는 값은 &lt;code&gt;TEXT&lt;/code&gt; , &lt;code&gt;STRING&lt;/code&gt; , &lt;code&gt;UTF8_STRING&lt;/code&gt; , &lt;code&gt;TARGETS&lt;/code&gt; , &lt;code&gt;LENGTH&lt;/code&gt; , &lt;code&gt;DELETE&lt;/code&gt; , &lt;code&gt;FILE_NAME&lt;/code&gt; , &lt;code&gt;CHARACTER_POSITION&lt;/code&gt; , &lt;code&gt;NAME&lt;/code&gt; , &lt;code&gt;LINE_NUMBER&lt;/code&gt; , &lt;code&gt;COLUMN_NUMBER&lt;/code&gt; , &lt;code&gt;OWNER_OS&lt;/code&gt; , &lt;code&gt;HOST_NAME&lt;/code&gt; , &lt;code&gt;USER&lt;/code&gt; , &lt;code&gt;CLASS&lt;/code&gt; , &lt;code&gt;ATOM&lt;/code&gt; , &lt;code&gt;INTEGER&lt;/code&gt; . (X 규칙에 따라 대문자 이름이있는 기호입니다.) &lt;var&gt;data-type&lt;/var&gt; 의 기본값 은 &lt;code&gt;STRING&lt;/code&gt; 입니다. X 이외의 윈도우 시스템은 일반적으로 &lt;code&gt;STRING&lt;/code&gt; 외에 이러한 유형의 작은 하위 집합 만 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="97a7e1832ebe58d63879484df2925b4e83ba7f55" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;digest-method&lt;/var&gt; can be the whole plist from &lt;code&gt;gnutls-digests&lt;/code&gt;, or just the symbol key, or a string with the name of that symbol.</source>
          <target state="translated">&lt;var&gt;digest-method&lt;/var&gt; 에서 전체 PLIST 수 있습니다 &lt;code&gt;gnutls-digests&lt;/code&gt; , 아니면 그냥 기호 키 또는 해당 심볼의 이름을 가진 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="935a0eaf2fbd230fea04adaaa1082e4cc3a672c1" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;directory&lt;/var&gt; argument, described below, does not specify a remote file. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Remote-Files.html#Remote-Files&quot;&gt;Remote Files&lt;/a&gt; in</source>
          <target state="translated">아래에 설명 된 &lt;var&gt;directory&lt;/var&gt; 인수는 원격 파일을 지정하지 않습니다. 참조 &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Remote-Files.html#Remote-Files&quot;&gt;원격 파일&lt;/a&gt; 에서를</target>
        </trans-unit>
        <trans-unit id="5542f9599795f05b8099573e3d57536d54dac1a9" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;display&lt;/var&gt; part of an element of &lt;var&gt;spec&lt;/var&gt; determines which terminals the element matches. If more than one element of &lt;var&gt;spec&lt;/var&gt; matches a given terminal, the first element that matches is the one used for that terminal. There are three possibilities for &lt;var&gt;display&lt;/var&gt;:</source>
          <target state="translated">&lt;var&gt;display&lt;/var&gt; 의 요소의 일부 &lt;var&gt;spec&lt;/var&gt; 되는 단자 소자 일치를 판정한다. 하나 이상의 &lt;var&gt;spec&lt;/var&gt; 요소가 지정된 터미널과 일치하는 경우 일치하는 첫 번째 요소가 해당 터미널에 사용되는 요소입니다. &lt;var&gt;display&lt;/var&gt; 에는 세 가지 가능성이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c9bda405d6d41a6743c07817af4eb4d0e700fb41" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;env&lt;/var&gt; argument provides a pointer to the</source>
          <target state="translated">&lt;var&gt;env&lt;/var&gt; 인수는 포인터를 제공합니다</target>
        </trans-unit>
        <trans-unit id="08e2ed661c4652900c4d2a493699f6dfd70d222b" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;factor&lt;/var&gt; must be a number, which is interpreted as a multiple of the height of the affected text. If it is positive, that means to display the characters raised. If it is negative, that means to display them lower down.</source>
          <target state="translated">&lt;var&gt;factor&lt;/var&gt; 영향을받는 텍스트의 높이의 복수로 해석됩니다 숫자이어야합니다. 양수이면 제기 된 문자를 표시합니다. 음수이면 아래쪽에 표시한다는 의미입니다.</target>
        </trans-unit>
        <trans-unit id="9fcc21f91bf906917402c028c06a30dae7160f1b" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;form&lt;/var&gt; argument controls the form of the returned &lt;var&gt;seconds&lt;/var&gt; element, as described below. The return value is a list of nine elements, as follows:</source>
          <target state="translated">&lt;var&gt;form&lt;/var&gt; 인자를 제어 반환의 형태로 &lt;var&gt;seconds&lt;/var&gt; 소자는 다음과 같이 설명했다. 반환 값은 다음과 같이 9 개의 요소 목록입니다.</target>
        </trans-unit>
        <trans-unit id="fbc01069be7d09c7d3a3a41b0f35d9961db204d7" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;handler&lt;/var&gt; then needs to figure out whether to handle &lt;var&gt;filename&lt;/var&gt; or &lt;var&gt;dirname&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;handler&lt;/var&gt; 다음 여부를 핸들에 알아낼 필요가 &lt;var&gt;filename&lt;/var&gt; 또는 &lt;var&gt;dirname&lt;/var&gt; 은 .</target>
        </trans-unit>
        <trans-unit id="6cf3ab9b3b26be9707eddf18a92b9c71e8357257" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;hash-method&lt;/var&gt; can be the whole plist from &lt;code&gt;gnutls-macs&lt;/code&gt;, or just the symbol key, or a string with the name of that symbol.</source>
          <target state="translated">&lt;var&gt;hash-method&lt;/var&gt; 에서 전체 PLIST 수 있습니다 &lt;code&gt;gnutls-macs&lt;/code&gt; , 아니면 그냥 기호 키 또는 해당 심볼의 이름을 가진 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="99af7f395067de5484dbd0bd18d306d12c0c9b03" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;input&lt;/var&gt; can be specified as a buffer or string or in other ways (see &lt;a href=&quot;format-of-gnutls-cryptography-inputs#Format-of-GnuTLS-Cryptography-Inputs&quot;&gt;Format of GnuTLS Cryptography Inputs&lt;/a&gt;).</source>
          <target state="translated">&lt;var&gt;input&lt;/var&gt; 버퍼 또는 문자열 또는 다른 방법 (참조 지정 될 수 &lt;a href=&quot;format-of-gnutls-cryptography-inputs#Format-of-GnuTLS-Cryptography-Inputs&quot;&gt;GnuTLS 암호의 입력 형식&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="56e73e2ce780242f8e4988661d4b9746a25edb2f" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;iv&lt;/var&gt; and &lt;var&gt;input&lt;/var&gt; and the optional &lt;var&gt;aead_auth&lt;/var&gt; can be specified as a buffer or string or in other ways (see &lt;a href=&quot;format-of-gnutls-cryptography-inputs#Format-of-GnuTLS-Cryptography-Inputs&quot;&gt;Format of GnuTLS Cryptography Inputs&lt;/a&gt;).</source>
          <target state="translated">&lt;var&gt;iv&lt;/var&gt; 및 &lt;var&gt;input&lt;/var&gt; 과 선택적 &lt;var&gt;aead_auth&lt;/var&gt; 는 버퍼 또는 문자열 또는 다른 방법 (참조 지정 될 수 &lt;a href=&quot;format-of-gnutls-cryptography-inputs#Format-of-GnuTLS-Cryptography-Inputs&quot;&gt;GnuTLS 암호의 입력 형식&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="0e01e83278249866df827f81cce4dae86e59aa92" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;keep-pred&lt;/var&gt; argument can also be a function. In that case, the function is called with no arguments, prior to running each command, while &lt;var&gt;keymap&lt;/var&gt; is active; it should return non-&lt;code&gt;nil&lt;/code&gt; if &lt;var&gt;keymap&lt;/var&gt; should stay active.</source>
          <target state="translated">&lt;var&gt;keep-pred&lt;/var&gt; 인수는 함수가 될 수 있습니다. 이 경우 &lt;var&gt;keymap&lt;/var&gt; 이 활성 상태 인 동안 각 명령을 실행하기 전에 인수없이 함수가 호출됩니다 . &lt;var&gt;keymap&lt;/var&gt; 이 활성 상태로 유지되어야하는 경우 &lt;code&gt;nil&lt;/code&gt; 이 아닌 값을 반환 해야합니다.</target>
        </trans-unit>
        <trans-unit id="cbdbfab6e83937e27f501cc05397b6ce3086f4a1" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;key-regexp&lt;/var&gt; argument can refer to the text matched by a subexpression of &lt;var&gt;record-regexp&lt;/var&gt;, or it can be a regular expression on its own.</source>
          <target state="translated">&lt;var&gt;key-regexp&lt;/var&gt; 인수의 서브 표현식으로 일치하는 텍스트를 참조 할 수 있습니다 &lt;var&gt;record-regexp&lt;/var&gt; , 또는 그 자체 정규 표현식이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1492573ae0239681a6f0caf30565cd718bdad9de" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;key&lt;/var&gt; can be specified as a buffer or string or in other ways (see &lt;a href=&quot;format-of-gnutls-cryptography-inputs#Format-of-GnuTLS-Cryptography-Inputs&quot;&gt;Format of GnuTLS Cryptography Inputs&lt;/a&gt;). The &lt;var&gt;key&lt;/var&gt; will be wiped after use if it&amp;rsquo;s a string.</source>
          <target state="translated">&lt;var&gt;key&lt;/var&gt; 버퍼 또는 문자열로 또는 다른 방법으로 (참조 지정할 수 있습니다 &lt;a href=&quot;format-of-gnutls-cryptography-inputs#Format-of-GnuTLS-Cryptography-Inputs&quot;&gt;GnuTLS 암호 입력의 형식&lt;/a&gt; ). &lt;var&gt;key&lt;/var&gt; 는 문자열의 경우 사용 후 닦아됩니다.</target>
        </trans-unit>
        <trans-unit id="62a36f43d3ae1d147429ed8ea40e22e275d19322" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;keymap&lt;/var&gt; argument can also be a list of keymaps.</source>
          <target state="translated">&lt;var&gt;keymap&lt;/var&gt; 인수는 키맵의 목록이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="183078d8ef81556e2619f842ffd518df0177a7d6" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;keyword-args&lt;/var&gt; are pairs of keywords and values. The values, except for &lt;code&gt;:after-hook&lt;/code&gt;&amp;rsquo;s, are evaluated. The following keywords are currently supported:</source>
          <target state="translated">&lt;var&gt;keyword-args&lt;/var&gt; 키워드와 값의 쌍입니다. &lt;code&gt;:after-hook&lt;/code&gt; 을 제외한 값 이 평가됩니다. 현재 지원되는 키워드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d9a9d314d3829c1d47b53b6d2cc5c9f93e1f95cd" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;macro&lt;/var&gt; argument can actually be any symbol, not just a macro name.</source>
          <target state="translated">&lt;var&gt;macro&lt;/var&gt; 인수는 실제로 기호뿐만 아니라 매크로 이름이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="478187ccf5afebe445a949310656331eb0c33123" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;method&lt;/var&gt; symbol should be one of &lt;code&gt;zero-width&lt;/code&gt;, &lt;code&gt;thin-space&lt;/code&gt;, &lt;code&gt;empty-box&lt;/code&gt;, or &lt;code&gt;hex-code&lt;/code&gt;. These have the same meanings as in &lt;code&gt;glyphless-char-display&lt;/code&gt;, above.</source>
          <target state="translated">&lt;var&gt;method&lt;/var&gt; 심볼 중 하나 여야 &lt;code&gt;zero-width&lt;/code&gt; , &lt;code&gt;thin-space&lt;/code&gt; , &lt;code&gt;empty-box&lt;/code&gt; 또는 &lt;code&gt;hex-code&lt;/code&gt; . 이들은 위의 &lt;code&gt;glyphless-char-display&lt;/code&gt; 에서와 동일한 의미를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="9aa33ebf3a782ebb64d24c0ca92f2745ce316273" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;name&lt;/var&gt; argument specifies the name for the process object. It is modified as necessary to make it unique.</source>
          <target state="translated">&lt;var&gt;name&lt;/var&gt; 인수는 프로세스 개체의 이름을 지정합니다. 고유하게 만들기 위해 필요에 따라 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="231e9e8ad59606a784462ddf1fc5a1c3ee071528" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;now&lt;/var&gt; and &lt;var&gt;comment&lt;/var&gt; entries are for internal use only, and may be omitted. &lt;var&gt;now&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, means to install the face specification now, even if the &lt;code&gt;defface&lt;/code&gt; form has not been evaluated. &lt;var&gt;comment&lt;/var&gt; is a string describing the customization.</source>
          <target state="translated">&lt;var&gt;now&lt;/var&gt; 과 &lt;var&gt;comment&lt;/var&gt; 항목은 내부 용이며, 생략 할 수있다. &lt;var&gt;now&lt;/var&gt; , non- &lt;code&gt;nil&lt;/code&gt; 이면 &lt;code&gt;defface&lt;/code&gt; 형식이 평가되지 않은 경우에도 지금 face 사양을 설치하는 것을 의미합니다 . &lt;var&gt;comment&lt;/var&gt; 는 사용자 정의를 설명하는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="0988033c8bfd11489dbc605759fe15110dbf7750" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;now&lt;/var&gt;, &lt;var&gt;request&lt;/var&gt;, and &lt;var&gt;comment&lt;/var&gt; entries are for internal use only, and may be omitted. &lt;var&gt;now&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, means to set the variable&amp;rsquo;s value now, even if the variable&amp;rsquo;s &lt;code&gt;defcustom&lt;/code&gt; form has not been evaluated. &lt;var&gt;request&lt;/var&gt; is a list of features to be loaded immediately (see &lt;a href=&quot;named-features#Named-Features&quot;&gt;Named Features&lt;/a&gt;). &lt;var&gt;comment&lt;/var&gt; is a string describing the customization.</source>
          <target state="translated">는 &lt;var&gt;now&lt;/var&gt; , &lt;var&gt;request&lt;/var&gt; 및 &lt;var&gt;comment&lt;/var&gt; 항목은 내부 용이며, 생략 할 수있다. &lt;var&gt;now&lt;/var&gt; , non- &lt;code&gt;nil&lt;/code&gt; 이면 변수의 &lt;code&gt;defcustom&lt;/code&gt; 형식이 평가되지 않은 경우에도 변수의 값을 지금 설정하는 것을 의미합니다 . &lt;var&gt;request&lt;/var&gt; 은 즉시로드 할 기능 목록입니다 ( &lt;a href=&quot;named-features#Named-Features&quot;&gt;명명 된 기능&lt;/a&gt; 참조 ). &lt;var&gt;comment&lt;/var&gt; 는 사용자 정의를 설명하는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="bfd48d1c6ff687e2f1df6dd6dad4acb172c7b66e" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;order&lt;/var&gt; is typically a number (integer or float), and the elements of the list are sorted in non-decreasing numerical order.</source>
          <target state="translated">&lt;var&gt;order&lt;/var&gt; 통상적으로 다수의 (정수 또는 부동 소수점)이고, 상기리스트의 요소들은 비 감소 번호순으로 분류된다.</target>
        </trans-unit>
        <trans-unit id="730dc6e5be96fa3e4dc3d63a62d43cd867c25f03" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;parameters&lt;/var&gt; argument is an alist that specifies frame parameters for the new frame. See &lt;a href=&quot;frame-parameters#Frame-Parameters&quot;&gt;Frame Parameters&lt;/a&gt;. If you specify the &lt;code&gt;terminal&lt;/code&gt; parameter in &lt;var&gt;parameters&lt;/var&gt;, the new frame is created on that terminal. Otherwise, if you specify the &lt;code&gt;window-system&lt;/code&gt; frame parameter in &lt;var&gt;parameters&lt;/var&gt;, that determines whether the frame should be displayed on a text terminal or a graphical terminal. See &lt;a href=&quot;window-systems#Window-Systems&quot;&gt;Window Systems&lt;/a&gt;. If neither is specified, the new frame is created in the same terminal as the selected frame.</source>
          <target state="translated">&lt;var&gt;parameters&lt;/var&gt; 인자는 새로운 프레임에 대한 프레임을 지정하는 파라미터 alist이다. &lt;a href=&quot;frame-parameters#Frame-Parameters&quot;&gt;프레임 매개 변수를&lt;/a&gt; 참조하십시오 . 당신이 지정하는 경우 &lt;code&gt;terminal&lt;/code&gt; 에서 매개 변수를 &lt;var&gt;parameters&lt;/var&gt; , 새로운 프레임은 해당 터미널에 생성됩니다. 당신이 지정하는 경우 그렇지 않으면, &lt;code&gt;window-system&lt;/code&gt; 의 프레임 매개 변수 &lt;var&gt;parameters&lt;/var&gt; , 그 프레임이 텍스트 터미널이나 그래픽 터미널에 표시할지 여부를 결정합니다. &lt;a href=&quot;window-systems#Window-Systems&quot;&gt;윈도우 시스템을&lt;/a&gt; 참조하십시오 . 둘 다 지정하지 않으면 선택한 프레임과 동일한 터미널에 새 프레임이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="afc7d9a60aa3b751ef05acfcffc9377a3cf63789" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;process&lt;/var&gt; argument can be a system process</source>
          <target state="translated">&lt;var&gt;process&lt;/var&gt; 인수는 시스템 프로세스 일 수있다</target>
        </trans-unit>
        <trans-unit id="b8e361047f1404d82466da0618267cd2f934e8f3" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;seconds&lt;/var&gt; element is a Lisp timestamp that is nonnegative and less than 61; it is less than 60 except during positive leap seconds (assuming the operating system supports leap seconds). If the optional &lt;var&gt;form&lt;/var&gt; argument is &lt;code&gt;t&lt;/code&gt;, &lt;var&gt;seconds&lt;/var&gt; uses the same precision as &lt;var&gt;time&lt;/var&gt;; if &lt;var&gt;form&lt;/var&gt; is &lt;code&gt;integer&lt;/code&gt;, &lt;var&gt;seconds&lt;/var&gt; is truncated to an integer. For example, if &lt;var&gt;time&lt;/var&gt; is the timestamp &lt;code&gt;(1566009571321 . 1000)&lt;/code&gt;, which represents 2019-08-17 02:39:31.321 UTC on typical systems that lack leap seconds, then &lt;code&gt;(decode-time &lt;var&gt;time&lt;/var&gt; t t)&lt;/code&gt; returns &lt;code&gt;((31321 . 1000)
39 2 17 8 2019 6 nil 0)&lt;/code&gt;, whereas &lt;code&gt;(decode-time &lt;var&gt;time&lt;/var&gt; t
'integer)&lt;/code&gt; returns &lt;code&gt;(31 39 2 17 8 2019 6 nil 0)&lt;/code&gt;. If &lt;var&gt;form&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt;, it currently defaults to &lt;code&gt;integer&lt;/code&gt; but this default may change in future Emacs releases, so callers requiring a particular form should specify &lt;var&gt;form&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;seconds&lt;/var&gt; 요소는 음수, 61보다 작은 리스프 타임 스탬프이고; 양의 윤초 동안을 제외하고는 60 미만입니다 (운영 체제가 윤초를 지원한다고 가정). 선택적 &lt;var&gt;form&lt;/var&gt; 인수가 &lt;code&gt;t&lt;/code&gt; 이면 &lt;var&gt;seconds&lt;/var&gt; 는 &lt;var&gt;time&lt;/var&gt; 과 동일한 정밀도를 사용합니다 . 경우 &lt;var&gt;form&lt;/var&gt; 입니다 &lt;code&gt;integer&lt;/code&gt; , &lt;var&gt;seconds&lt;/var&gt; 정수로 잘립니다. 예를 들어 &lt;var&gt;time&lt;/var&gt; 이 윤초가없는 일반적인 시스템에서 2019-08-17 02 : 39 : 31.321 UTC를 나타내는 타임 스탬프 &lt;code&gt;(1566009571321 . 1000)&lt;/code&gt; 이면 &lt;code&gt;(decode-time &lt;var&gt;time&lt;/var&gt; t t)&lt;/code&gt; 반환됩니다. &lt;code&gt;((31321 . 1000) 39 2 17 8 2019 6 nil 0)&lt;/code&gt; , 반면 &lt;code&gt;(decode-time &lt;var&gt;time&lt;/var&gt; t 'integer)&lt;/code&gt; 는 &lt;code&gt;(31 39 2 17 8 2019 6 nil 0)&lt;/code&gt; 을 반환합니다 . 경우 &lt;var&gt;form&lt;/var&gt; 생략되거나 &lt;code&gt;nil&lt;/code&gt; 로, 그것은 현재 기본적으로 &lt;code&gt;integer&lt;/code&gt; 있지만 특정 양식을 필요로하는 발신자 지정해야합니다 있도록이 기본값은 미래 이맥스 릴리스에서 변경 될 수 있습니다 &lt;var&gt;form&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="b3501ce0f22c5a460c2284b5b67304c4ec40866f" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;spec&lt;/var&gt; argument is a &lt;em&gt;face spec&lt;/em&gt;, which states how the face should appear on different kinds of terminals. It should be an alist whose elements each have the form</source>
          <target state="translated">&lt;var&gt;spec&lt;/var&gt; 인수는 인 &lt;em&gt;얼굴 사양&lt;/em&gt; 면은 단자의 다른 종류에 표시하는 방법을 말한다. 각 요소가 다음과 같은 형식을 갖는 alist 여야합니다.</target>
        </trans-unit>
        <trans-unit id="c06e3e6329485a46088e33ab0a58763a6add9987" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;try-completion&lt;/var&gt; and &lt;var&gt;all-completions&lt;/var&gt; functions should each accept four arguments: &lt;var&gt;string&lt;/var&gt;, &lt;var&gt;collection&lt;/var&gt;, &lt;var&gt;predicate&lt;/var&gt;, and &lt;var&gt;point&lt;/var&gt;. The &lt;var&gt;string&lt;/var&gt;, &lt;var&gt;collection&lt;/var&gt;, and &lt;var&gt;predicate&lt;/var&gt; arguments have the same meanings as in &lt;code&gt;try-completion&lt;/code&gt; (see &lt;a href=&quot;basic-completion#Basic-Completion&quot;&gt;Basic Completion&lt;/a&gt;), and the &lt;var&gt;point&lt;/var&gt; argument is the position of point within &lt;var&gt;string&lt;/var&gt;. Each function should return a non-&lt;code&gt;nil&lt;/code&gt; value if it performed its job, and &lt;code&gt;nil&lt;/code&gt; if it did not (e.g., if there is no way to complete &lt;var&gt;string&lt;/var&gt; according to the completion style).</source>
          <target state="translated">&lt;var&gt;try-completion&lt;/var&gt; 하고 &lt;var&gt;all-completions&lt;/var&gt; : 기능은 각 사 개 인수 받아 들여야 &lt;var&gt;string&lt;/var&gt; , &lt;var&gt;collection&lt;/var&gt; , &lt;var&gt;predicate&lt;/var&gt; , 및 &lt;var&gt;point&lt;/var&gt; . &lt;var&gt;string&lt;/var&gt; , &lt;var&gt;collection&lt;/var&gt; 및 &lt;var&gt;predicate&lt;/var&gt; 인수와 같은 의미를 가지고 &lt;code&gt;try-completion&lt;/code&gt; 합니다 ( &lt;a href=&quot;basic-completion#Basic-Completion&quot;&gt;기본 완료&lt;/a&gt; ) 및 &lt;var&gt;point&lt;/var&gt; 인수 내에서 점의 위치입니다 &lt;var&gt;string&lt;/var&gt; . 각 기능은 비 반환해야합니다 &lt;code&gt;nil&lt;/code&gt; 그것의 작업을 수행 한 경우 값을, 그리고 &lt;code&gt;nil&lt;/code&gt; 는하지 (한 경우 예를 들어, 완료 할 수있는 방법이없는 경우 &lt;var&gt;string&lt;/var&gt; 완성 스타일에 따라).</target>
        </trans-unit>
        <trans-unit id="0335ff665c252c34bc8af3595631a385d6bec903" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;var-sequence&lt;/var&gt; sequence can also include the &lt;code&gt;&amp;amp;rest&lt;/code&gt; marker followed by a variable name to be bound to the rest of &lt;var&gt;val-sequence&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;var-sequence&lt;/var&gt; 시퀀스도 포함 할 수 &lt;code&gt;&amp;amp;rest&lt;/code&gt; 의 나머지에 결합 될 변수 이름 다음 마커 &lt;var&gt;val-sequence&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="48c44bcaee3aecba4fd3386d2632d16003a6a097" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;width&lt;/var&gt; and &lt;var&gt;height&lt;/var&gt; arguments specify the widget size in pixels, and &lt;var&gt;title&lt;/var&gt;, a string, specifies its title.</source>
          <target state="translated">&lt;var&gt;width&lt;/var&gt; 및 &lt;var&gt;height&lt;/var&gt; 인수 위젯 픽셀 크기, 지정 &lt;var&gt;title&lt;/var&gt; 문자열을, 그 타이틀을 지정.</target>
        </trans-unit>
        <trans-unit id="042fa4319f83303549e9163cc74bb7a75739f113" translate="yes" xml:space="preserve">
          <source>The Buffer Gap</source>
          <target state="translated">버퍼 갭</target>
        </trans-unit>
        <trans-unit id="88db08fc40ec31b574f716946b51aacded45fd94" translate="yes" xml:space="preserve">
          <source>The Buffer List</source>
          <target state="translated">버퍼 목록</target>
        </trans-unit>
        <trans-unit id="c1b161f427b1f734326373d819a11018ebc6afec" translate="yes" xml:space="preserve">
          <source>The Button package defines functions for inserting and manipulating &lt;em&gt;buttons&lt;/em&gt; that can be activated with the mouse or via keyboard commands. These buttons are typically used for various kinds of hyperlinks.</source>
          <target state="translated">Button 패키지는 마우스 또는 키보드 명령을 통해 활성화 할 수있는 &lt;em&gt;버튼&lt;/em&gt; 을 삽입하고 조작하는 기능을 정의 합니다. 이러한 버튼은 일반적으로 다양한 종류의 하이퍼 링크에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ed389ad7628fa8d3021e70d30f1da8af14a2e91e" translate="yes" xml:space="preserve">
          <source>The C functions &lt;code&gt;call0&lt;/code&gt;, &lt;code&gt;call1&lt;/code&gt;, &lt;code&gt;call2&lt;/code&gt;, and so on, provide handy ways to call a Lisp function conveniently with a fixed number of arguments. They work by calling &lt;code&gt;Ffuncall&lt;/code&gt;.</source>
          <target state="translated">C 함수 &lt;code&gt;call0&lt;/code&gt; , &lt;code&gt;call1&lt;/code&gt; , &lt;code&gt;call2&lt;/code&gt; 등은 고정 된 수의 인수를 사용하여 Lisp 함수를 편리하게 호출하는 편리한 방법을 제공합니다. 그들은 &lt;code&gt;Ffuncall&lt;/code&gt; 을 호출하여 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="c8b73b7861af4aafe3f06ecc14faf1d3eea057a5" translate="yes" xml:space="preserve">
          <source>The C part of Emacs is portable to C99 or later: C11-specific features such as &amp;lsquo;</source>
          <target state="translated">Emacs의 C 부분은 C99 이상으로 이식 가능합니다 : '</target>
        </trans-unit>
        <trans-unit id="de35110382ab3d228e2b097a0fd8120a8e5e7818" translate="yes" xml:space="preserve">
          <source>The Case Table</source>
          <target state="translated">케이스 테이블</target>
        </trans-unit>
        <trans-unit id="1f400cc4a2f5b022649bc110a1d58fe7aba52a53" translate="yes" xml:space="preserve">
          <source>The Common Lisp loop facility also contains features for working with iterators. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/cl/Loop-Facility.html#Loop-Facility&quot;&gt;Loop Facility&lt;/a&gt; in</source>
          <target state="translated">Common Lisp 루프 기능에는 반복기 작업을위한 기능도 포함되어 있습니다. 참조 &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/cl/Loop-Facility.html#Loop-Facility&quot;&gt;루프 시설을&lt;/a&gt; 에</target>
        </trans-unit>
        <trans-unit id="b959eb0c15ee6787dc31ccfba3386e533a6ed0de" translate="yes" xml:space="preserve">
          <source>The Current Buffer</source>
          <target state="translated">현재 버퍼</target>
        </trans-unit>
        <trans-unit id="3eeba2f256fb33046d7a21ae5a30d974e72989bf" translate="yes" xml:space="preserve">
          <source>The D-Bus bus. This argument is needed only if a bus other than &lt;code&gt;:session&lt;/code&gt; shall be used.</source>
          <target state="translated">D-Bus 버스. 이 인수는 &lt;code&gt;:session&lt;/code&gt; 이외의 버스를 사용하는 경우에만 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="d943856e8a1ab46910a0a060d4b4a8bc05b6d2d7" translate="yes" xml:space="preserve">
          <source>The Data Structure of the Mode Line</source>
          <target state="translated">모드 라인의 데이터 구조</target>
        </trans-unit>
        <trans-unit id="6845dcf7b293a7f410b480283184f4343e62c6bc" translate="yes" xml:space="preserve">
          <source>The Debugger mode</source>
          <target state="translated">디버거 모드</target>
        </trans-unit>
        <trans-unit id="d50f479d67b7ffd944ff37303a4fcf2b32a43c84" translate="yes" xml:space="preserve">
          <source>The Default Value of a Buffer-Local Variable</source>
          <target state="translated">버퍼 로컬 변수의 기본값</target>
        </trans-unit>
        <trans-unit id="1af63431f4b48d26e4f383b32edfc24d505f479c" translate="yes" xml:space="preserve">
          <source>The Echo Area</source>
          <target state="translated">에코 영역</target>
        </trans-unit>
        <trans-unit id="d3ecd4c390bc66755238340e318147394eb63696" translate="yes" xml:space="preserve">
          <source>The Edebug specification says which parts of a call to the macro are forms to be evaluated. For simple macros, the specification often looks very similar to the formal argument list of the macro definition, but specifications are much more general than macro arguments. See &lt;a href=&quot;defining-macros#Defining-Macros&quot;&gt;Defining Macros&lt;/a&gt;, for more explanation of the &lt;code&gt;declare&lt;/code&gt; form.</source>
          <target state="translated">Edebug 사양은 매크로 호출의 어떤 부분이 평가 될 양식인지를 알려줍니다. 간단한 매크로의 경우 사양은 종종 매크로 정의의 형식 인수 목록과 매우 유사 해 보이지만 사양은 매크로 인수보다 훨씬 더 일반적입니다. &lt;code&gt;declare&lt;/code&gt; 양식에 대한 자세한 설명은 &lt;a href=&quot;defining-macros#Defining-Macros&quot;&gt;매크로 정의를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9e84da412291b7634158164e0c4c2be118e4000c" translate="yes" xml:space="preserve">
          <source>The Emacs Lisp byte compiler may collapse identical literal objects, such as literal strings, into references to the same object, with the effect that the byte-compiled code will compare such objects as &lt;code&gt;eq&lt;/code&gt;, while the interpreted version of the same code will not. Therefore, your code should never rely on objects with the same literal contents being either &lt;code&gt;eq&lt;/code&gt; or not &lt;code&gt;eq&lt;/code&gt;, it should instead use functions that compare object contents such as &lt;code&gt;equal&lt;/code&gt;, described below. Similarly, your code should not modify literal objects (e.g., put text properties on literal strings), since doing that might affect other literal objects of the same contents, if the byte compiler collapses them.</source>
          <target state="translated">Emacs Lisp 바이트 컴파일러는 리터럴 문자열과 같은 동일한 리터럴 객체를 동일한 객체에 대한 참조로 축소 할 수 있으며, 바이트 컴파일 된 코드는 &lt;code&gt;eq&lt;/code&gt; 와 같은 객체를 비교 하지만 동일한 코드의 해석 된 버전은 그렇지 않습니다. 따라서 코드는 동일한 리터럴 내용이 &lt;code&gt;eq&lt;/code&gt; 또는 &lt;code&gt;eq&lt;/code&gt; 가 아닌 객체에 의존 해서는 안됩니다. 대신 아래에 설명 된 &lt;code&gt;equal&lt;/code&gt; 과 같은 객체 내용을 비교하는 함수를 사용해야 합니다. 마찬가지로 코드는 리터럴 객체를 수정해서는 안됩니다 (예 : 리터럴 문자열에 텍스트 속성 배치). 그렇게하면 바이트 컴파일러가이를 축소 할 경우 동일한 내용의 다른 리터럴 객체에 영향을 미칠 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="310426987bb1554a93b5fd738cbd277c007e71d9" translate="yes" xml:space="preserve">
          <source>The Emacs Lisp interpreter itself does not perform type checking on the actual arguments passed to functions when they are called. It could not do so, since function arguments in Lisp do not have declared data types, as they do in other programming languages. It is therefore up to the individual function to test whether each actual argument belongs to a type that the function can use.</source>
          <target state="translated">Emacs Lisp 인터프리터 자체는 호출 될 때 함수에 전달 된 실제 인수에 대해 유형 검사를 수행하지 않습니다. Lisp의 함수 인수는 다른 프로그래밍 언어 에서처럼 선언 된 데이터 유형이 없기 때문에 그렇게 할 수 없습니다. 따라서 각 실제 인수가 함수가 사용할 수있는 유형에 속하는지 여부를 테스트하는 것은 개별 함수에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b5ed2bacaf122b157d132153caf1a6c76e1e216" translate="yes" xml:space="preserve">
          <source>The Emacs Manual</source>
          <target state="translated">Emacs 매뉴얼</target>
        </trans-unit>
        <trans-unit id="ed9c188a636545890d0306bb79a70700989914ce" translate="yes" xml:space="preserve">
          <source>The Emacs Web Wowser Manual</source>
          <target state="translated">Emacs Web Wowser 매뉴얼</target>
        </trans-unit>
        <trans-unit id="c5f97d9b01c47621a8f1576c10266887562eaba8" translate="yes" xml:space="preserve">
          <source>The Emacs Widget Library</source>
          <target state="translated">Emacs 위젯 라이브러리</target>
        </trans-unit>
        <trans-unit id="cf1a28f1f55db75a34f2ee21a67962dda3683be4" translate="yes" xml:space="preserve">
          <source>The Emacs command loop is entered automatically when Emacs starts up. This top-level invocation of the command loop never exits; it keeps running as long as Emacs does. Lisp programs can also invoke the command loop. Since this makes more than one activation of the command loop, we call it &lt;em&gt;recursive editing&lt;/em&gt;. A recursive editing level has the effect of suspending whatever command invoked it and permitting the user to do arbitrary editing before resuming that command.</source>
          <target state="translated">Emacs 명령 루프는 Emacs가 시작될 때 자동으로 입력됩니다. 이 최상위 수준의 명령 루프 호출은 종료되지 않습니다. Emacs가하는 한 계속 실행됩니다. Lisp 프로그램은 명령 루프를 호출 할 수도 있습니다. 이것은 명령 루프를 두 번 이상 활성화하므로 &lt;em&gt;재귀 편집&lt;/em&gt; 이라고합니다 . 재귀 적 편집 수준은 명령을 호출 한 모든 명령을 일시 중단하고 사용자가 해당 명령을 다시 시작하기 전에 임의의 편집을 수행하도록 허용하는 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d2757b8581c35fe6423fa5de538de963ebfee3a" translate="yes" xml:space="preserve">
          <source>The Emacs command loop reads a sequence of &lt;em&gt;input events&lt;/em&gt; that represent keyboard or mouse activity, or system events sent to Emacs. The events for keyboard activity are characters or symbols; other events are always lists. This section describes the representation and meaning of input events in detail.</source>
          <target state="translated">Emacs 명령 루프 는 키보드 또는 마우스 활동을 나타내는 일련의 &lt;em&gt;입력 이벤트&lt;/em&gt; 또는 Emacs로 전송 된 시스템 이벤트를 읽습니다 . 키보드 활동에 대한 이벤트는 문자 또는 기호입니다. 다른 이벤트는 항상 목록입니다. 이 섹션에서는 입력 이벤트의 표현과 의미를 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="824a7c8d972dbc9f0918b1d2dd36bd16830fd203" translate="yes" xml:space="preserve">
          <source>The Emacs-GnuTLS manual</source>
          <target state="translated">Emacs-GnuTLS 매뉴얼</target>
        </trans-unit>
        <trans-unit id="48abe72f85ec259728635bab36a8349e8fee558c" translate="yes" xml:space="preserve">
          <source>The Ewoc package constructs buffer text that represents a structure of Lisp objects, and updates the text to follow changes in that structure. This is like the &amp;ldquo;view&amp;rdquo; component in the &amp;ldquo;model&amp;ndash;view&amp;ndash;controller&amp;rdquo; design paradigm. Ewoc means &amp;ldquo;Emacs&amp;rsquo;s Widget for Object Collections&amp;rdquo;.</source>
          <target state="translated">Ewoc 패키지는 Lisp 개체의 구조를 나타내는 버퍼 텍스트를 구성하고 해당 구조의 변경 사항을 따르도록 텍스트를 업데이트합니다. 이것은 &quot;모델-뷰-컨트롤러&quot;설계 패러다임의 &quot;뷰&quot;구성 요소와 같습니다. Ewoc은 &quot;객체 컬렉션을위한 Emacs의 위젯&quot;을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="b090490c607ee3ae40053556e3bd1bc26e7b84ef" translate="yes" xml:space="preserve">
          <source>The Font Lock functionality is based on several basic functions. Each of these calls the function specified by the corresponding variable. This indirection allows major and minor modes to modify the way fontification works in the buffers of that mode, and even use the Font Lock mechanisms for features that have nothing to do with fontification. (This is why the description below says &amp;ldquo;should&amp;rdquo; when it describes what the functions do: the mode can customize the values of the corresponding variables to do something entirely different.) The variables mentioned below are described in &lt;a href=&quot;other-font-lock-variables#Other-Font-Lock-Variables&quot;&gt;Other Font Lock Variables&lt;/a&gt;.</source>
          <target state="translated">글꼴 잠금 기능은 몇 가지 기본 기능을 기반으로합니다. 이들 각각은 해당 변수에 지정된 함수를 호출합니다. 이 간접적 인 방법은 메이저 모드와 마이너 모드가 해당 모드의 버퍼에서 글꼴 화가 작동하는 방식을 수정하고 글꼴 화와 관련이없는 기능에 대해 글꼴 잠금 메커니즘을 사용할 수도 있습니다. (이것이 함수가하는 일을 설명 할 때 아래 설명에서 &quot;해야한다&quot;라고 말하는 이유입니다. 모드는 해당 변수의 값을 사용자 정의하여 완전히 다른 작업을 수행 할 수 있습니다.) 아래 언급 된 변수는 &lt;a href=&quot;other-font-lock-variables#Other-Font-Lock-Variables&quot;&gt;기타 글꼴 잠금 변수에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffe1e1010931294e4ff432189f143dba8ad3d52c" translate="yes" xml:space="preserve">
          <source>The GNU C Library Reference Manual</source>
          <target state="translated">GNU C 라이브러리 참조 매뉴얼</target>
        </trans-unit>
        <trans-unit id="f510bd36e1c0e21b92eb72e77742b390298c8296" translate="yes" xml:space="preserve">
          <source>The GNU Emacs Manual</source>
          <target state="translated">GNU Emacs 매뉴얼</target>
        </trans-unit>
        <trans-unit id="be8e8d5a20ebc8f402b76cd53e568b1f3714e9b8" translate="yes" xml:space="preserve">
          <source>The GNU Libc Manual</source>
          <target state="translated">GNU Libc 매뉴얼</target>
        </trans-unit>
        <trans-unit id="97d4e4584e3d965d515d24f39f1ba0fb87608737" translate="yes" xml:space="preserve">
          <source>The GNU Privacy Guard Manual</source>
          <target state="translated">GNU 프라이버시 가드 매뉴얼</target>
        </trans-unit>
        <trans-unit id="46ff57e09cd2f765d85462c770ad0d94e1fb2d96" translate="yes" xml:space="preserve">
          <source>The GNU system (using the GNU kernel, which consists of the HURD and Mach).</source>
          <target state="translated">GNU 시스템 (HURD 및 Mach로 구성된 GNU 커널 사용).</target>
        </trans-unit>
        <trans-unit id="d45b5a5dd9f2e4c7ca56bba45693e77c91e54851" translate="yes" xml:space="preserve">
          <source>The GTK+ and NS versions of Emacs ignores items 1 to 3, because disabled and/or deselected images are autocomputed from item 0.</source>
          <target state="translated">Emacs의 GTK + 및 NS 버전은 항목 1 ~ 3을 무시합니다. 비활성화 및 / 또는 선택 취소 된 이미지는 항목 0에서 자동 계산되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="fff10c181322ecc664c42dfda8fefedaf1847850" translate="yes" xml:space="preserve">
          <source>The ID number of the outermost window-system window in which the frame exists. As with &lt;code&gt;window-id&lt;/code&gt;, changing this parameter has no actual effect.</source>
          <target state="translated">프레임이 존재하는 가장 바깥 쪽 창 시스템 창의 ID 번호입니다. 와 같이 &lt;code&gt;window-id&lt;/code&gt; , 이러한 매개 변수를 변경하는 것은 실제 효과가 없다.</target>
        </trans-unit>
        <trans-unit id="4d63d6de0303f72672f86fee4a5f29964456f058" translate="yes" xml:space="preserve">
          <source>The ID number which the graphical display uses for this frame. Emacs assigns this parameter when the frame is created; changing the parameter has no effect on the actual ID number.</source>
          <target state="translated">그래픽 디스플레이가이 프레임에 사용하는 ID 번호입니다. Emacs는 프레임이 생성 될 때이 매개 변수를 할당합니다. 매개 변수를 변경해도 실제 ID 번호에는 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b7c31f5b358bfa18cfdf049d5e081a95b7c9c0ea" translate="yes" xml:space="preserve">
          <source>The Init File</source>
          <target state="translated">초기화 파일</target>
        </trans-unit>
        <trans-unit id="cbab447af0083f2d9278c7461d6eaff464619006" translate="yes" xml:space="preserve">
          <source>The Internet protocol address.</source>
          <target state="translated">인터넷 프로토콜 주소입니다.</target>
        </trans-unit>
        <trans-unit id="aba4cfd77de5ccd0c7c2dc2fb4bf06e5c623205b" translate="yes" xml:space="preserve">
          <source>The Kill Ring</source>
          <target state="translated">킬 링</target>
        </trans-unit>
        <trans-unit id="82814d081d76842dd03cfad63480273e62e1f98e" translate="yes" xml:space="preserve">
          <source>The Lisp Debugger</source>
          <target state="translated">Lisp 디버거</target>
        </trans-unit>
        <trans-unit id="c8d28bedb49ac3761246585ddcb49c12087f68df" translate="yes" xml:space="preserve">
          <source>The Lisp interpreter, or evaluator, is the part of Emacs that computes the value of an expression that is given to it. When a function written in Lisp is called, the evaluator computes the value of the function by evaluating the expressions in the function body. Thus, running any Lisp program really means running the Lisp interpreter.</source>
          <target state="translated">Lisp 인터프리터 또는 평가자는 주어진 표현식의 값을 계산하는 Emacs의 일부입니다. Lisp로 작성된 함수가 호출되면 평가자는 함수 본문의 식을 평가하여 함수의 값을 계산합니다. 따라서 Lisp 프로그램을 실행한다는 것은 실제로 Lisp 인터프리터를 실행하는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="67096f218be8637118f0e140ce449a73a3aa3d19" translate="yes" xml:space="preserve">
          <source>The Lisp macros below provide different ways of binding names to definitions. Common to all of them are the following rules:</source>
          <target state="translated">아래의 Lisp 매크로는 이름을 정의에 바인딩하는 다양한 방법을 제공합니다. 그들 모두에 공통된 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b92835e656ef8b33221e27f7efc472160affd9c6" translate="yes" xml:space="preserve">
          <source>The Lisp modes have two string quote characters: double-quote (&amp;lsquo;</source>
          <target state="translated">Lisp 모드에는 두 개의 문자열 인용 문자가 있습니다. 큰 따옴표 ( '</target>
        </trans-unit>
        <trans-unit id="00a189f320831f6a7cbe46d5d1c34bc9f301c86a" translate="yes" xml:space="preserve">
          <source>The Lisp package which goes with your module could then load the module using the &lt;code&gt;load&lt;/code&gt; primitive (see &lt;a href=&quot;dynamic-modules#Dynamic-Modules&quot;&gt;Dynamic Modules&lt;/a&gt;) when the package is loaded into Emacs.</source>
          <target state="translated">모듈로 간다 리스프 패키지는 다음 사용하여 모듈을로드 할 수 &lt;code&gt;load&lt;/code&gt; 원시 (참조 &lt;a href=&quot;dynamic-modules#Dynamic-Modules&quot;&gt;동적 모듈&lt;/a&gt; 패키지가 이맥스에로드됩니다).</target>
        </trans-unit>
        <trans-unit id="a10dde5e9f797bafad7f9b20fb8272a90e00c8e1" translate="yes" xml:space="preserve">
          <source>The Lisp printer can produce this syntax to record circular and shared structure in a Lisp object, if you bind the variable &lt;code&gt;print-circle&lt;/code&gt; to a non-&lt;code&gt;nil&lt;/code&gt; value. See &lt;a href=&quot;output-variables#Output-Variables&quot;&gt;Output Variables&lt;/a&gt;.</source>
          <target state="translated">Lisp 프린터는이 구문을 생성하여 변수 &lt;code&gt;print-circle&lt;/code&gt; 을 &lt;code&gt;nil&lt;/code&gt; 이 아닌 값에 바인딩하는 경우 Lisp 개체에 원형 및 공유 구조를 기록 할 수 있습니다 . &lt;a href=&quot;output-variables#Output-Variables&quot;&gt;출력 변수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="eae52bdc2047fd6ec677f1f8ee8f1932da4d37e9" translate="yes" xml:space="preserve">
          <source>The Lisp reader reads an integer as a nonempty sequence of decimal digits with optional initial sign and optional final period.</source>
          <target state="translated">Lisp 판독기는 선택적 초기 부호와 선택적 마지막 마침표를 사용하여 비어 있지 않은 10 진수 시퀀스로 정수를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="2a586c1cf0727731b69b8375a90b4485bdf10c07" translate="yes" xml:space="preserve">
          <source>The Lisp reader reports invalid syntax, but cannot say where the real problem is. For example, the error &amp;lsquo;</source>
          <target state="translated">Lisp 판독기는 잘못된 구문을보고하지만 실제 문제가 어디에 있는지 말할 수 없습니다. 예를 들어 '</target>
        </trans-unit>
        <trans-unit id="fcecede5703df29c00b9f51550de12dc7dfbae92" translate="yes" xml:space="preserve">
          <source>The Mark</source>
          <target state="translated">마크</target>
        </trans-unit>
        <trans-unit id="f37b90308c8ea9bb361394a84649d9067c3b3b87" translate="yes" xml:space="preserve">
          <source>The Match Data</source>
          <target state="translated">경기 데이터</target>
        </trans-unit>
        <trans-unit id="e12f3f3cbde4367f4806f21a6ef69e7d82fb3756" translate="yes" xml:space="preserve">
          <source>The Menu Bar</source>
          <target state="translated">메뉴 바</target>
        </trans-unit>
        <trans-unit id="f476ae6da532e421223f60de7495c64fa2d57aaa" translate="yes" xml:space="preserve">
          <source>The Outside Context</source>
          <target state="translated">외부 컨텍스트</target>
        </trans-unit>
        <trans-unit id="452e09252ab77548d7926d100d076b5a89f76615" translate="yes" xml:space="preserve">
          <source>The Overlay Arrow</source>
          <target state="translated">오버레이 화살표</target>
        </trans-unit>
        <trans-unit id="2749af725670d68e7c9f29455577d15f1aa89399" translate="yes" xml:space="preserve">
          <source>The POSIX search and match functions do not properly support the non-greedy repetition operators (see &lt;a href=&quot;regexp-special#Regexp-Special&quot;&gt;non-greedy&lt;/a&gt;). This is because POSIX backtracking conflicts with the semantics of non-greedy repetition.</source>
          <target state="translated">POSIX 검색 및 일치 기능은 탐욕스럽지 않은 반복 연산자를 제대로 지원하지 않습니다 ( &lt;a href=&quot;regexp-special#Regexp-Special&quot;&gt;탐욕스럽지 않은&lt;/a&gt; 참조 ). 이것은 POSIX 역 추적이 탐욕스럽지 않은 반복의 의미와 충돌하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="975c0dbec8418cefac1c26cea47400958485a24f" translate="yes" xml:space="preserve">
          <source>The Region</source>
          <target state="translated">지역</target>
        </trans-unit>
        <trans-unit id="7f0920ea8dce344ced982af555e68f1fcc8fb02c" translate="yes" xml:space="preserve">
          <source>The Thread List</source>
          <target state="translated">스레드 목록</target>
        </trans-unit>
        <trans-unit id="0b3b10e0747a616770fcc68ce9c42692021f69c3" translate="yes" xml:space="preserve">
          <source>The Top Level of Mode Line Control</source>
          <target state="translated">모드 라인 제어의 최상위 레벨</target>
        </trans-unit>
        <trans-unit id="0f9f110896a8003386b884af9710262024fcd3bd" translate="yes" xml:space="preserve">
          <source>The Tramp Manual</source>
          <target state="translated">부정 기선 매뉴얼</target>
        </trans-unit>
        <trans-unit id="3d449198e0052c8b8dae47f7157c82ee61e7dd1a" translate="yes" xml:space="preserve">
          <source>The WebKit component.</source>
          <target state="translated">WebKit 구성 요소입니다.</target>
        </trans-unit>
        <trans-unit id="c97106172cf0fee2d4e25fbcc7b9b6c23c939797" translate="yes" xml:space="preserve">
          <source>The Window Start and End Positions</source>
          <target state="translated">창 시작 및 끝 위치</target>
        </trans-unit>
        <trans-unit id="00312f9c47a904c7e40141a60dd85f937febefae" translate="yes" xml:space="preserve">
          <source>The X Window System defines three other modifier bits that can be set in a character: &lt;em&gt;hyper&lt;/em&gt;, &lt;em&gt;super&lt;/em&gt; and &lt;em&gt;alt&lt;/em&gt;. The syntaxes for these bits are &amp;lsquo;</source>
          <target state="translated">X 윈도우 시스템은 문자에 설정할 수있는 세 가지 다른 수정 자 비트를 정의합니다 : &lt;em&gt;hyper&lt;/em&gt; , &lt;em&gt;super&lt;/em&gt; 및 &lt;em&gt;alt&lt;/em&gt; . 이 비트의 구문은 '</target>
        </trans-unit>
        <trans-unit id="239e6f6db120d4b7497121d69c34a71f64242413" translate="yes" xml:space="preserve">
          <source>The Zen of Buffer Display</source>
          <target state="translated">버퍼 디스플레이의 선</target>
        </trans-unit>
        <trans-unit id="d1c7be134e2b1ac53a747c65f17468ae85a6e82a" translate="yes" xml:space="preserve">
          <source>The abnormal hook &lt;code&gt;window-size-change-functions&lt;/code&gt; (see &lt;a href=&quot;window-hooks#Window-Hooks&quot;&gt;Window Hooks&lt;/a&gt;) tracks all changes of the inner size of a frame including those induced by request of the window-system or window manager. To rule out false positives that might occur when changing only the sizes of a frame&amp;rsquo;s windows without actually changing the size of the inner frame, use the following function.</source>
          <target state="translated">비정상적인 후크 &lt;code&gt;window-size-change-functions&lt;/code&gt; ( &lt;a href=&quot;window-hooks#Window-Hooks&quot;&gt;Window Hooks&lt;/a&gt; 참조 )은 창 시스템 또는 창 관리자의 요청에 의해 유도 된 것을 포함하여 프레임 내부 크기의 모든 변경을 추적합니다. 내부 프레임의 크기를 실제로 변경하지 않고 프레임 창의 크기 만 변경할 때 발생할 수있는 오탐을 배제하려면 다음 함수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="acb5f2e3b961983ad080c933704bf1921460d37a" translate="yes" xml:space="preserve">
          <source>The above commands use the function &lt;code&gt;pop-to-buffer&lt;/code&gt;, which flexibly displays a buffer in some window and selects that window for editing. In turn, &lt;code&gt;pop-to-buffer&lt;/code&gt; uses &lt;code&gt;display-buffer&lt;/code&gt; for displaying the buffer. Hence, all the variables affecting &lt;code&gt;display-buffer&lt;/code&gt; will affect it as well. See &lt;a href=&quot;choosing-window#Choosing-Window&quot;&gt;Choosing Window&lt;/a&gt;, for the documentation of &lt;code&gt;display-buffer&lt;/code&gt;.</source>
          <target state="translated">위의 명령은 &lt;code&gt;pop-to-buffer&lt;/code&gt; 함수를 사용하여 일부 창에 버퍼를 유연하게 표시하고 해당 창을 편집 용으로 선택합니다. 차례로 &lt;code&gt;pop-to-buffer&lt;/code&gt; 는 &lt;code&gt;display-buffer&lt;/code&gt; 를 표시하기 위해 display-buffer 를 사용 합니다 . 따라서 &lt;code&gt;display-buffer&lt;/code&gt; 영향을 미치는 모든 변수도 영향 을 미칩니다. &lt;code&gt;display-buffer&lt;/code&gt; 에 대한 문서는 &lt;a href=&quot;choosing-window#Choosing-Window&quot;&gt;Choosing Window를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cd813c20f1c6269cd7421cd80bccde0cf42a41bb" translate="yes" xml:space="preserve">
          <source>The above display conventions apply even when there is a display table, for any character whose entry in the active display table is &lt;code&gt;nil&lt;/code&gt;. Thus, when you set up a display table, you need only specify the characters for which you want special behavior.</source>
          <target state="translated">위의 표시 규칙은 표시 테이블이있는 경우에도 활성 표시 테이블의 항목이 &lt;code&gt;nil&lt;/code&gt; 인 모든 문자에 적용됩니다 . 따라서 디스플레이 테이블을 설정할 때 특별한 동작을 원하는 문자 만 지정하면됩니다.</target>
        </trans-unit>
        <trans-unit id="1790de9a4c228ec0f7e88481efc2c65fd587eb7a" translate="yes" xml:space="preserve">
          <source>The above example would allow the conclusion that users customize &lt;code&gt;display-buffer-alist&lt;/code&gt; for the sole purpose to overrule the &lt;var&gt;action&lt;/var&gt; argument chosen by applications. Such a conclusion would be incorrect. &lt;code&gt;display-buffer-alist&lt;/code&gt; is the standard option for users to direct the course of display of specific buffers in a preferred way regardless of whether the display is also guided by an &lt;var&gt;action&lt;/var&gt; argument.</source>
          <target state="translated">위의 예는 사용자 가 응용 프로그램에서 선택한 &lt;var&gt;action&lt;/var&gt; 인수 를 무시하기위한 유일한 목적으로 &lt;code&gt;display-buffer-alist&lt;/code&gt; 를 사용자 정의한다는 결론을 내릴 수 있습니다 . 그러한 결론은 잘못된 것입니다. &lt;code&gt;display-buffer-alist&lt;/code&gt; 는 디스플레이가 &lt;var&gt;action&lt;/var&gt; 인수에 의해 안내되는지 여부에 관계없이 사용자가 선호하는 방식으로 특정 버퍼의 디스플레이 과정을 지시하는 표준 옵션입니다 .</target>
        </trans-unit>
        <trans-unit id="aeb0dafcf8103ae88a77afae29bde5756ca7c094" translate="yes" xml:space="preserve">
          <source>The above feature works by calling an external executable (e.g., &lt;code&gt;gzip&lt;/code&gt;). Emacs can also be compiled with support for built-in decompression using the zlib library, which is faster than calling an external program.</source>
          <target state="translated">위의 기능은 외부 실행 파일 (예 : &lt;code&gt;gzip&lt;/code&gt; ) 을 호출하여 작동합니다 . Emacs는 외부 프로그램을 호출하는 것보다 더 빠른 zlib 라이브러리를 사용하여 내장 압축 해제를 지원하여 컴파일 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="387f04e2a1f6936573fe28b42d630e5f93dc27a4" translate="yes" xml:space="preserve">
          <source>The above grammar does not explicitly mention the syntax of function calls: SMIE will automatically allow any sequence of sexps, such as identifiers, balanced parentheses, or &lt;code&gt;begin ... end&lt;/code&gt; blocks to appear anywhere anyway.</source>
          <target state="translated">위의 문법은 함수 호출의 구문을 명시 적으로 언급하지 않습니다. SMIE는 식별자, 균형 잡힌 괄호 또는 &lt;code&gt;begin ... end&lt;/code&gt; 블록 과 같은 모든 성별 시퀀스가 어쨌든 어디에서나 나타날 수 있도록 자동으로 허용 합니다.</target>
        </trans-unit>
        <trans-unit id="deec33282919bd446ca8d3ce98c567ff797c98f6" translate="yes" xml:space="preserve">
          <source>The above method with the additional argument is usually best, because it allows callers to say &amp;ldquo;treat this call as interactive&amp;rdquo;. But you can also do the job by testing &lt;code&gt;called-interactively-p&lt;/code&gt;.</source>
          <target state="translated">추가 인수가있는 위의 방법은 호출자가 &quot;이 호출을 대화 형으로 처리&quot;라고 말할 수 있기 때문에 일반적으로 가장 좋습니다. 그러나 &lt;code&gt;called-interactively-p&lt;/code&gt; 를 테스트하여 작업을 수행 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="54cfffd5c06cc33525dd38f3e201f1461707ae99" translate="yes" xml:space="preserve">
          <source>The above three arguments &lt;var&gt;init-value&lt;/var&gt;, &lt;var&gt;lighter&lt;/var&gt;, and &lt;var&gt;keymap&lt;/var&gt; can be (partially) omitted when &lt;var&gt;keyword-args&lt;/var&gt; are used. The &lt;var&gt;keyword-args&lt;/var&gt; consist of keywords followed by corresponding values. A few keywords have special meanings:</source>
          <target state="translated">위의 세 가지 인수 &lt;var&gt;init-value&lt;/var&gt; , &lt;var&gt;lighter&lt;/var&gt; 및 &lt;var&gt;keymap&lt;/var&gt; 은 &lt;var&gt;keyword-args&lt;/var&gt; 를 사용할 때 (부분적으로) 생략 할 수 있습니다 . &lt;var&gt;keyword-args&lt;/var&gt; 해당 값 다음 키워드로 구성된다. 몇 가지 키워드에는 특별한 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="912c11980ecb67df3dcc61f5360f26f85c672e6b" translate="yes" xml:space="preserve">
          <source>The above variables actually take effect via the function &lt;code&gt;set-window-buffer&lt;/code&gt; (see &lt;a href=&quot;buffers-and-windows#Buffers-and-Windows&quot;&gt;Buffers and Windows&lt;/a&gt;), which calls &lt;code&gt;set-window-fringes&lt;/code&gt; as a subroutine. If you change one of these variables, the fringe display is not updated in existing windows showing the buffer, unless you call &lt;code&gt;set-window-buffer&lt;/code&gt; again in each affected window. You can also use &lt;code&gt;set-window-fringes&lt;/code&gt; to control the fringe display in individual windows.</source>
          <target state="translated">위의 변수는 실제로 &lt;code&gt;set-window-buffer&lt;/code&gt; 함수 ( &lt;a href=&quot;buffers-and-windows#Buffers-and-Windows&quot;&gt;Buffers 및 Windows&lt;/a&gt; 참조) 를 통해 적용되며 , 이는 &lt;code&gt;set-window-fringes&lt;/code&gt; 를 서브 루틴으로 호출합니다 . 이러한 변수 중 하나를 변경하면 영향을받는 각 창에서 &lt;code&gt;set-window-buffer&lt;/code&gt; 를 다시 호출하지 않는 한 버퍼를 표시하는 기존 창에서 프린지 표시가 업데이트되지 않습니다 . &lt;code&gt;set-window-fringes&lt;/code&gt; 를 사용하여 개별 창에서 언저리 표시를 제어 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ca188b29b3bb57f7bcf3fb693861f1370085a8bf" translate="yes" xml:space="preserve">
          <source>The accepted &lt;var&gt;keyword&lt;/var&gt; values are &lt;code&gt;:bindtodevice&lt;/code&gt;, etc. For the complete list, see &lt;a href=&quot;network-options#Network-Options&quot;&gt;Network Options&lt;/a&gt;. This form returns non-&lt;code&gt;nil&lt;/code&gt; if that particular network option is supported by &lt;code&gt;make-network-process&lt;/code&gt; (or &lt;code&gt;set-network-process-option&lt;/code&gt;).</source>
          <target state="translated">허용되는 &lt;var&gt;keyword&lt;/var&gt; 값은 &lt;code&gt;:bindtodevice&lt;/code&gt; 등입니다. 전체 목록은 &lt;a href=&quot;network-options#Network-Options&quot;&gt;네트워크 옵션을&lt;/a&gt; 참조하십시오 . 특정 네트워크 옵션이 &lt;code&gt;make-network-process&lt;/code&gt; (또는 &lt;code&gt;set-network-process-option&lt;/code&gt; )에서 지원되는 경우이 형식은 &lt;code&gt;nil&lt;/code&gt; 이 아닌 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="cc9760775537207d1cf5d5aa94d98184e1eb1a24" translate="yes" xml:space="preserve">
          <source>The action alist passed in each function call is:</source>
          <target state="translated">각 함수 호출에서 전달되는 작업 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4c1e9cf149ace88e3f3737c4a06b35438f05f558" translate="yes" xml:space="preserve">
          <source>The action code tells</source>
          <target state="translated">액션 코드는</target>
        </trans-unit>
        <trans-unit id="20f7f463b94870cfb1b047961088cae0d326ca22" translate="yes" xml:space="preserve">
          <source>The actual completion is done by passing the completion table &lt;var&gt;collection&lt;/var&gt; and the completion predicate &lt;var&gt;predicate&lt;/var&gt; to the function &lt;code&gt;try-completion&lt;/code&gt; (see &lt;a href=&quot;basic-completion#Basic-Completion&quot;&gt;Basic Completion&lt;/a&gt;). This happens in certain commands bound in the local keymaps used for completion. Some of these commands also call &lt;code&gt;test-completion&lt;/code&gt;. Thus, if &lt;var&gt;predicate&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it should be compatible with &lt;var&gt;collection&lt;/var&gt; and &lt;code&gt;completion-ignore-case&lt;/code&gt;. See &lt;a href=&quot;basic-completion#Definition-of-test_002dcompletion&quot;&gt;Definition of test-completion&lt;/a&gt;.</source>
          <target state="translated">실제 완료는 완료 테이블 &lt;var&gt;collection&lt;/var&gt; 및 완료 &lt;var&gt;predicate&lt;/var&gt; 를 함수 &lt;code&gt;try-completion&lt;/code&gt; 에 전달하여 수행됩니다 ( &lt;a href=&quot;basic-completion#Basic-Completion&quot;&gt;Basic Completion&lt;/a&gt; 참조 ). 이는 완료에 사용되는 로컬 키맵에 바인딩 된 특정 명령에서 발생합니다. 이러한 명령 중 일부는 &lt;code&gt;test-completion&lt;/code&gt; 을 호출 합니다. 따라서 &lt;var&gt;predicate&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 &lt;var&gt;collection&lt;/var&gt; 및 &lt;code&gt;completion-ignore-case&lt;/code&gt; 와 호환되어야합니다 . &lt;a href=&quot;basic-completion#Definition-of-test_002dcompletion&quot;&gt;테스트 완료 정의를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d1af2bc35ffe0c2bc3b64bd633b7094bc586529d" translate="yes" xml:space="preserve">
          <source>The actual vertical scroll position must always correspond to an integral number of pixels, so the value you specify is rounded accordingly.</source>
          <target state="translated">실제 세로 스크롤 위치는 항상 정수 픽셀 수와 일치해야하므로 지정한 값이 그에 따라 반올림됩니다.</target>
        </trans-unit>
        <trans-unit id="ff765a1d0b1ea170510397b3d6bdae6f65de5184" translate="yes" xml:space="preserve">
          <source>The address of the buffer contents. The buffer contents is a linear C array of &lt;code&gt;char&lt;/code&gt;, with the gap somewhere in its midst.</source>
          <target state="translated">버퍼 내용의 주소. 버퍼 내용은 &lt;code&gt;char&lt;/code&gt; 의 선형 C 배열이며 그 중간 어딘가에 간격이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3c2ee5327a92dfc5bf111a48a9aefa1920eaf43" translate="yes" xml:space="preserve">
          <source>The advantage of dynamic function loading is that loading the file should become faster. This is a good thing for a file which contains many separate user-callable functions, if using one of them does not imply you will probably also use the rest. A specialized mode which provides many keyboard commands often has that usage pattern: a user may invoke the mode, but use only a few of the commands it provides.</source>
          <target state="translated">동적 함수 로딩의 장점은 파일 로딩 속도가 빨라진다는 것입니다. 이것은 사용자가 호출 할 수있는 여러 함수를 포함하는 파일에 유용합니다. 그 중 하나를 사용한다고해서 나머지도 사용할 수 있다는 의미는 아닙니다. 많은 키보드 명령을 제공하는 특수 모드에는 종종 사용 패턴이 있습니다. 사용자는 모드를 호출 할 수 있지만 제공하는 명령 중 일부만 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d5619eed72157c4d0bdb07860d63c48de2da3d98" translate="yes" xml:space="preserve">
          <source>The advantage of this formulation is that it reuses the indentation of the previous &lt;code&gt;&quot;else&quot;&lt;/code&gt;, rather than going all the way back to the first &lt;code&gt;&quot;if&quot;&lt;/code&gt; of the sequence.</source>
          <target state="translated">이 공식의 장점은 시퀀스 의 첫 번째 &lt;code&gt;&quot;if&quot;&lt;/code&gt; 로 돌아가는 대신 이전 &lt;code&gt;&quot;else&quot;&lt;/code&gt; 의 들여 쓰기를 재사용 한다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="3a50be9f4a1773d19c2822e2848993b6a2da815f" translate="yes" xml:space="preserve">
          <source>The advantage of using this variable rather than an ordinary global variable is that the data will never carry over to a subsequent command invocation.</source>
          <target state="translated">일반 전역 변수 대신이 변수를 사용하는 이점은 데이터가 후속 명령 호출로 전달되지 않는다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1596d1cec331c0a1119dda271b5137a09454b0dd" translate="yes" xml:space="preserve">
          <source>The alist containing the structured data that have been unpacked so far, or the entire structure being packed. You can use &lt;code&gt;bindat-get-field&lt;/code&gt; to access specific fields of this structure.</source>
          <target state="translated">지금까지 압축 해제 된 구조화 된 데이터 또는 압축중인 전체 구조를 포함하는 목록입니다. &lt;code&gt;bindat-get-field&lt;/code&gt; 를 사용하여이 구조의 특정 필드에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="16a4156fb321a63923ec85058a36944c0a91c6f3" translate="yes" xml:space="preserve">
          <source>The alist describes which parameters were specified in &lt;var&gt;geom&lt;/var&gt;, and gives the values specified for them. Each element looks like &lt;code&gt;(&lt;var&gt;parameter&lt;/var&gt; . &lt;var&gt;value&lt;/var&gt;)&lt;/code&gt;. The possible &lt;var&gt;parameter&lt;/var&gt; values are &lt;code&gt;left&lt;/code&gt;, &lt;code&gt;top&lt;/code&gt;, &lt;code&gt;width&lt;/code&gt;, and &lt;code&gt;height&lt;/code&gt;.</source>
          <target state="translated">목록은 &lt;var&gt;geom&lt;/var&gt; 에 지정된 매개 변수를 설명하고 매개 변수에 지정된 값을 제공합니다. 각 요소는 &lt;code&gt;(&lt;var&gt;parameter&lt;/var&gt; . &lt;var&gt;value&lt;/var&gt;)&lt;/code&gt; 처럼 보입니다 . 가능한 &lt;var&gt;parameter&lt;/var&gt; 값은 &lt;code&gt;left&lt;/code&gt; , &lt;code&gt;top&lt;/code&gt; , &lt;code&gt;width&lt;/code&gt; 및 &lt;code&gt;height&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c733f98486863c87c8afe728430d26b6647157fa" translate="yes" xml:space="preserve">
          <source>The alist of this window&amp;rsquo;s parameters.</source>
          <target state="translated">이 창의 매개 변수 목록입니다.</target>
        </trans-unit>
        <trans-unit id="4de99a71510486f7e37d746816616f03fc75f487" translate="yes" xml:space="preserve">
          <source>The alt modifier.</source>
          <target state="translated">alt 수정 자.</target>
        </trans-unit>
        <trans-unit id="c9957faf6d8ce383f9b22bb3d1e72f7bd208cd8d" translate="yes" xml:space="preserve">
          <source>The angle in degrees by which the x-axis of the ellipse is rotated relative to the x-axis of the current coordinate system.</source>
          <target state="translated">타원의 x 축이 현재 좌표계의 x 축을 기준으로 회전하는 각도입니다.</target>
        </trans-unit>
        <trans-unit id="6140640f4032f19682107247228755508d75322e" translate="yes" xml:space="preserve">
          <source>The answers and their meanings, even &amp;lsquo;</source>
          <target state="translated">대답과 그 의미, 심지어 '</target>
        </trans-unit>
        <trans-unit id="eb1ac55dfe1608150149494f5a53ac6108d010b5" translate="yes" xml:space="preserve">
          <source>The appearance of child frames is largely dependent on the parameters provided via &lt;var&gt;alist&lt;/var&gt;. It is advisable to use at least ratios to specify the size (see &lt;a href=&quot;size-parameters#Size-Parameters&quot;&gt;Size Parameters&lt;/a&gt;) and the position (see &lt;a href=&quot;position-parameters#Position-Parameters&quot;&gt;Position Parameters&lt;/a&gt;) of the child frame, and to add a &lt;code&gt;keep-ratio&lt;/code&gt; parameter (see &lt;a href=&quot;frame-interaction-parameters#Frame-Interaction-Parameters&quot;&gt;Frame Interaction Parameters&lt;/a&gt;), in order to make sure that the child frame remains visible. For other parameters that should be considered see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;.</source>
          <target state="translated">자식 프레임의 모양은 &lt;var&gt;alist&lt;/var&gt; 를 통해 제공되는 매개 변수에 따라 크게 달라집니다 . 크기 (참조 지정하는 최소 비율로 사용하는 것이 좋습니다 &lt;a href=&quot;size-parameters#Size-Parameters&quot;&gt;크기 매개 변수&lt;/a&gt; ) 및 위치 (참조 &lt;a href=&quot;position-parameters#Position-Parameters&quot;&gt;위치 매개 변수&lt;/a&gt; 자식 프레임을) 및 추가 &lt;code&gt;keep-ratio&lt;/code&gt; (참조 매개 변수를 &lt;a href=&quot;frame-interaction-parameters#Frame-Interaction-Parameters&quot;&gt;프레임 상호 작용 매개 변수를&lt;/a&gt; 확인하기 위해) 자식 프레임이 계속 표시됩니다. 고려해야 할 다른 매개 변수에 대해서는 &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;하위 프레임을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="298a0fa20ea50d72583add29a3d5ae410ddedeac" translate="yes" xml:space="preserve">
          <source>The appearance of the keyword &lt;code&gt;&amp;amp;optional&lt;/code&gt; in the argument list indicates that the subsequent arguments may be omitted (omitted arguments default to &lt;code&gt;nil&lt;/code&gt;). Do not write &lt;code&gt;&amp;amp;optional&lt;/code&gt; when you call the function.</source>
          <target state="translated">인수 목록에 키워드 &lt;code&gt;&amp;amp;optional&lt;/code&gt; 이 나타나는 것은 후속 인수가 생략 될 수 있음을 나타냅니다 (생략 된 인수는 기본적으로 &lt;code&gt;nil&lt;/code&gt; ). 함수를 호출 할 때 &lt;code&gt;&amp;amp;optional&lt;/code&gt; 작성하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="3f5c7ba81da02c1e205b368aaea8e197ad50a24b" translate="yes" xml:space="preserve">
          <source>The applicable methods are sorted into the order in which they will be combined. The method whose left-most argument specializer is the most specific one will come first in the order. (Specifying &lt;code&gt;:argument-precedence-order&lt;/code&gt; as part of &lt;code&gt;cl-defmethod&lt;/code&gt; overrides that, as described above.) If the method body calls &lt;code&gt;cl-call-next-method&lt;/code&gt;, the next most-specific method will run. If there are applicable &lt;code&gt;:around&lt;/code&gt; methods, the most-specific of them will run first; it should call &lt;code&gt;cl-call-next-method&lt;/code&gt; to run any of the less specific &lt;code&gt;:around&lt;/code&gt; methods. Next, the &lt;code&gt;:before&lt;/code&gt; methods run in the order of their specificity, followed by the primary method, and lastly the &lt;code&gt;:after&lt;/code&gt; methods in the reverse order of their specificity.</source>
          <target state="translated">적용 가능한 메소드는 결합되는 순서로 정렬됩니다. 가장 왼쪽에있는 인수 전문화자가 가장 구체적인 메서드가 순서대로 먼저 표시됩니다. ( &lt;code&gt;:argument-precedence-order&lt;/code&gt; 를 &lt;code&gt;cl-defmethod&lt;/code&gt; 의 일부로 지정 하면 위에서 설명한 것처럼이를 재정의합니다.) 메서드 본문이 &lt;code&gt;cl-call-next-method&lt;/code&gt; 를 호출 하면 다음으로 가장 구체적인 메서드가 실행됩니다. 적용 가능한 &lt;code&gt;:around&lt;/code&gt; 메소드 가 있으면 가장 구체적인 메소드가 먼저 실행됩니다. 덜 구체적인 &lt;code&gt;:around&lt;/code&gt; 메소드 를 실행하려면 &lt;code&gt;cl-call-next-method&lt;/code&gt; 를 호출 해야 합니다. 다음으로 &lt;code&gt;:before&lt;/code&gt; 메소드는 특이성의 순서로 실행되고 그 다음에는 기본 메소드가 실행되고 마지막으로 &lt;code&gt;:after&lt;/code&gt; 그들의 특이성의 역순으로 메소드 이후 .</target>
        </trans-unit>
        <trans-unit id="c76f854944de42c1326dc55d5c64da71693c76d4" translate="yes" xml:space="preserve">
          <source>The appropriate comment syntax settings for C++ can be as follows:</source>
          <target state="translated">C ++에 대한 적절한 주석 구문 설정은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7af380f8e979eb018fdd3697719035381131cdb4" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;name&lt;/code&gt; can also be a predicate function. The predicate is called for every directory examined by the function, starting from &lt;var&gt;file&lt;/var&gt; (even if &lt;var&gt;file&lt;/var&gt; is not a directory). It is called with one argument (the file or directory) and should return non-&lt;code&gt;nil&lt;/code&gt; if that directory is the one it is looking for.</source>
          <target state="translated">인수 &lt;code&gt;name&lt;/code&gt; 은 술어 함수일 수도 있습니다. 술어는 &lt;var&gt;file&lt;/var&gt; 에서 시작하여 함수가 검사하는 모든 디렉토리에 대해 호출 됩니다 ( &lt;var&gt;file&lt;/var&gt; 이 디렉토리가 아닌 경우에도 ). 하나의 인수 (파일 또는 디렉토리)로 호출되며 해당 디렉토리가 찾고있는 디렉토리이면 &lt;code&gt;nil&lt;/code&gt; 이 아닌 값을 반환해야 합니다.</target>
        </trans-unit>
        <trans-unit id="3ca220a7d203286861c22592355a8976c8e1dc15" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;accept-defaults&lt;/var&gt; controls checking for default bindings, as in &lt;code&gt;lookup-key&lt;/code&gt; (above).</source>
          <target state="translated">&lt;var&gt;accept-defaults&lt;/var&gt; 인수 는 &lt;code&gt;lookup-key&lt;/code&gt; (위) 에서와 같이 기본 바인딩 검사를 제어합니다 .</target>
        </trans-unit>
        <trans-unit id="7bd635c6abdd8e152863881cdc6fa5ff15a5ff9d" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;accept-defaults&lt;/var&gt; controls checking for default bindings, as in &lt;code&gt;lookup-key&lt;/code&gt; (see &lt;a href=&quot;functions-for-key-lookup#Functions-for-Key-Lookup&quot;&gt;Functions for Key Lookup&lt;/a&gt;).</source>
          <target state="translated">&lt;var&gt;accept-defaults&lt;/var&gt; 인수 는 &lt;code&gt;lookup-key&lt;/code&gt; 에서와 같이 기본 바인딩 검사를 제어 합니다 ( &lt;a href=&quot;functions-for-key-lookup#Functions-for-Key-Lookup&quot;&gt;키 조회 함수&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="d29509ca5aacfab823a57d08757922aaad71cdd0" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;action&lt;/var&gt; can also have a non-&lt;code&gt;nil&lt;/code&gt;, non-list value. This has the special meaning that the buffer should be displayed in a window other than the selected one, even if the selected window is already displaying it. If called interactively with a prefix argument, &lt;var&gt;action&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;. Lisp programs should always supply a list value.</source>
          <target state="translated">인수 &lt;var&gt;action&lt;/var&gt; 은 &lt;code&gt;nil&lt;/code&gt; 이 아닌 목록 값을 가질 수도 있습니다 . 이것은 선택한 창이 이미 표시되어 있더라도 버퍼가 선택한 창 이외의 창에 표시되어야한다는 특별한 의미를 갖습니다. 접두사 인수를 사용하여 대화식으로 호출하면 &lt;var&gt;action&lt;/var&gt; 은 &lt;code&gt;t&lt;/code&gt; 입니다. Lisp 프로그램은 항상 목록 값을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="1beb69cfa7b071babf9978632af37dd09371bacd" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;actor&lt;/var&gt; says how to act on the answers that the user gives. It should be a function of one argument, and it is called with each object that the user says yes for. Its argument is always an object obtained from &lt;var&gt;list&lt;/var&gt;.</source>
          <target state="translated">인수 &lt;var&gt;actor&lt;/var&gt; 는 사용자가 제공하는 답변에 따라 행동하는 방법을 말합니다. 하나의 인수의 함수 여야하며 사용자가 예라고 말하는 각 개체와 함께 호출됩니다. 인수는 항상 &lt;var&gt;list&lt;/var&gt; 에서 얻은 객체 입니다.</target>
        </trans-unit>
        <trans-unit id="ee17f20b9e88dfb3aa41595d461a73079a3e5d43" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;align&lt;/var&gt; specifies the positioning of the bitmap relative to the range of rows where it is used; the default is to center the bitmap. The allowed values are &lt;code&gt;top&lt;/code&gt;, &lt;code&gt;center&lt;/code&gt;, or &lt;code&gt;bottom&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;align&lt;/var&gt; 인수 는 사용되는 행 범위에 상대적인 비트 맵의 ​​위치를 ​​지정합니다. 기본값은 비트 맵을 가운데에 맞추는 것입니다. 허용되는 값은 &lt;code&gt;top&lt;/code&gt; , &lt;code&gt;center&lt;/code&gt; 또는 &lt;code&gt;bottom&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7753c98dbb86ce3ef5fdc83ef2b7a29620966442" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;area&lt;/var&gt; specifies whether to put the image in a margin. If it is &lt;code&gt;left-margin&lt;/code&gt;, the image appears in the left margin; &lt;code&gt;right-margin&lt;/code&gt; specifies the right margin. If &lt;var&gt;area&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; or omitted, the image is displayed at point within the buffer&amp;rsquo;s text.</source>
          <target state="translated">인수 &lt;var&gt;area&lt;/var&gt; 은 이미지를 여백에 넣을지 여부를 지정합니다. 이 경우 &lt;code&gt;left-margin&lt;/code&gt; 이미지가 왼쪽 여백에 나타납니다; &lt;code&gt;right-margin&lt;/code&gt; 은 오른쪽 여백을 지정합니다. 경우 &lt;var&gt;area&lt;/var&gt; 이다 &lt;code&gt;nil&lt;/code&gt; 또는 생략 된 이미지는 버퍼 내의 텍스트의 포인트에 표시된다.</target>
        </trans-unit>
        <trans-unit id="d364497680dc1a96c19f79375cbd6751df8d0fba" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;args&lt;/var&gt; is a list of keyword/argument pairs. The following keywords are accepted:</source>
          <target state="translated">인수 &lt;var&gt;args&lt;/var&gt; 키워드 / 인수 쌍의 목록입니다. 다음 키워드가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="edb4e5ef6ed5ceb13b27dd15b0d01fa920d79d9f" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;auto-mode-list&lt;/var&gt; is a list of regular expressions to add to the variable &lt;code&gt;auto-mode-alist&lt;/code&gt;. They are added by the execution of the &lt;code&gt;define-generic-mode&lt;/code&gt; form, not by expanding the macro call.</source>
          <target state="translated">&lt;var&gt;auto-mode-list&lt;/var&gt; 인수 는 &lt;code&gt;auto-mode-alist&lt;/code&gt; 변수에 추가 할 정규식 목록입니다 . 매크로 호출을 확장하는 것이 아니라 &lt;code&gt;define-generic-mode&lt;/code&gt; 형식 의 실행에 의해 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="9ee6a087463d0ff4f764f5b9d27cda3abf523b0f" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;bits&lt;/var&gt; specifies the image to use. It should be either a string or a vector of integers, where each element (an integer) corresponds to one row of the bitmap. Each bit of an integer corresponds to one pixel of the bitmap, where the low bit corresponds to the rightmost pixel of the bitmap. (Note that this order of bits is opposite of the order in XBM images; see &lt;a href=&quot;xbm-images#XBM-Images&quot;&gt;XBM Images&lt;/a&gt;.)</source>
          <target state="translated">인수 &lt;var&gt;bits&lt;/var&gt; 는 사용할 이미지를 지정합니다. 각 요소 (정수)는 비트 맵의 ​​한 행에 해당하는 문자열 또는 정수 벡터 여야합니다. 정수의 각 비트는 비트 맵의 ​​한 픽셀에 해당하며 하위 비트는 비트 맵의 ​​가장 오른쪽 픽셀에 해당합니다. (이 비트 순서는 XBM 이미지의 순서와 반대입니다 . &lt;a href=&quot;xbm-images#XBM-Images&quot;&gt;XBM 이미지&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="9b233061a24b93e6081107b51828a209e52ef880" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;buf&lt;/var&gt; can be a &lt;code&gt;NULL&lt;/code&gt; pointer, in which case the function stores in &lt;code&gt;*&lt;var&gt;len&lt;/var&gt;&lt;/code&gt; the number of bytes required for storing the contents of &lt;var&gt;arg&lt;/var&gt;, and returns &lt;code&gt;true&lt;/code&gt;. This is how you can determine the size of &lt;var&gt;buf&lt;/var&gt; needed to store a particular string: first call &lt;code&gt;copy_string_contents&lt;/code&gt; with &lt;code&gt;NULL&lt;/code&gt; as &lt;var&gt;buf&lt;/var&gt;, then allocate enough memory to hold the number of bytes stored by the function in &lt;code&gt;*&lt;var&gt;len&lt;/var&gt;&lt;/code&gt;, and call the function again with non-&lt;code&gt;NULL&lt;/code&gt;&lt;var&gt;buf&lt;/var&gt; to actually perform the text copying.</source>
          <target state="translated">&lt;var&gt;buf&lt;/var&gt; 인수 는 &lt;code&gt;NULL&lt;/code&gt; 포인터 가 될 수 있으며 ,이 경우 함수는 &lt;var&gt;arg&lt;/var&gt; 의 내용을 저장하는 데 필요한 바이트 수를 &lt;code&gt;*&lt;var&gt;len&lt;/var&gt;&lt;/code&gt; 에 저장하고 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . 다음은 특정 문자열을 저장하는 데 필요한 &lt;var&gt;buf&lt;/var&gt; 의 크기를 결정하는 방법입니다 . 먼저 &lt;code&gt;NULL&lt;/code&gt; 을 &lt;var&gt;buf&lt;/var&gt; 로 사용 하여 &lt;code&gt;copy_string_contents&lt;/code&gt; 를 호출 한 다음 &lt;code&gt;*&lt;var&gt;len&lt;/var&gt;&lt;/code&gt; &lt;var&gt;len&lt;/var&gt; 에있는 함수가 저장 한 바이트 수를 보유하기에 충분한 메모리를 할당 하고 non으로 다시 호출합니다. - 실제로 텍스트 복사를 수행하는 &lt;code&gt;NULL&lt;/code&gt; &lt;var&gt;buf&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="c62f796ca367437edd9bbfec13b2cb245b68f3a0" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;buffer-or-name&lt;/var&gt; specifies the temporary buffer. It can be either a buffer, which must already exist, or a string, in which case a buffer of that name is created, if necessary. The buffer is marked as unmodified and read-only when &lt;code&gt;with-temp-buffer-window&lt;/code&gt; exits.</source>
          <target state="translated">&lt;var&gt;buffer-or-name&lt;/var&gt; 인수 는 임시 버퍼를 지정합니다. 이미 존재해야하는 버퍼이거나 필요한 경우 해당 이름의 버퍼가 생성되는 문자열 일 수 있습니다. &lt;code&gt;with-temp-buffer-window&lt;/code&gt; 가 종료 되면 버퍼는 수정되지 않은 것으로 표시되고 읽기 전용 으로 표시 됩니다.</target>
        </trans-unit>
        <trans-unit id="a1c5d94728b5d5501baf9d04c247ab6731f26635" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;character-set&lt;/var&gt; is a string, like the inside of a &amp;lsquo;</source>
          <target state="translated">인수 &lt;var&gt;character-set&lt;/var&gt; 은 '의 내부와 같은 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="454b60cd7a8b9522c076db2ecfb6a4f1bed5da38" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;color&lt;/var&gt; must be a valid color name.</source>
          <target state="translated">&lt;var&gt;color&lt;/var&gt; 인수 는 유효한 색상 이름이어야합니다.</target>
        </trans-unit>
        <trans-unit id="18f7ad6dac6cb9de707886ec8955eea2d280c1e3" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;command-loop&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, means that this key sequence is being read by something that will read commands one after another. It should be &lt;code&gt;nil&lt;/code&gt; if the caller will read just one key sequence.</source>
          <target state="translated">The argument &lt;var&gt;command-loop&lt;/var&gt; , if non- &lt;code&gt;nil&lt;/code&gt; , means that this key sequence is being read by something that will read commands one after another. It should be &lt;code&gt;nil&lt;/code&gt; if the caller will read just one key sequence.</target>
        </trans-unit>
        <trans-unit id="73cd856bd4485d69fb41a49bb978b8e54f955de7" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;command&lt;/var&gt; can be any object; it is compared with all keymap entries using &lt;code&gt;eq&lt;/code&gt;.</source>
          <target state="translated">The argument &lt;var&gt;command&lt;/var&gt; can be any object; it is compared with all keymap entries using &lt;code&gt;eq&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c292ebda07b62fafda1bd9dcde58aac39ae09123" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;comment-list&lt;/var&gt; is a list in which each element is either a character, a string of one or two characters, or a cons cell. A character or a string is set up in the mode&amp;rsquo;s syntax table as a comment starter. If the entry is a cons cell, the &lt;small&gt;CAR&lt;/small&gt; is set up as a comment starter and the &lt;small&gt;CDR&lt;/small&gt; as a comment ender. (Use &lt;code&gt;nil&lt;/code&gt; for the latter if you want comments to end at the end of the line.) Note that the syntax table mechanism has limitations about what comment starters and enders are actually possible. See &lt;a href=&quot;syntax-tables#Syntax-Tables&quot;&gt;Syntax Tables&lt;/a&gt;.</source>
          <target state="translated">The argument &lt;var&gt;comment-list&lt;/var&gt; is a list in which each element is either a character, a string of one or two characters, or a cons cell. A character or a string is set up in the mode&amp;rsquo;s syntax table as a comment starter. If the entry is a cons cell, the &lt;small&gt;CAR&lt;/small&gt; is set up as a comment starter and the &lt;small&gt;CDR&lt;/small&gt; as a comment ender. (Use &lt;code&gt;nil&lt;/code&gt; for the latter if you want comments to end at the end of the line.) Note that the syntax table mechanism has limitations about what comment starters and enders are actually possible. See &lt;a href=&quot;syntax-tables#Syntax-Tables&quot;&gt;Syntax Tables&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="00acfc829089029b9f202f10adf5992c457658f8" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;count&lt;/var&gt; is a repeat count; &lt;var&gt;kbdmacro&lt;/var&gt; is executed that many times. If &lt;var&gt;count&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt;, &lt;var&gt;kbdmacro&lt;/var&gt; is executed once. If it is 0, &lt;var&gt;kbdmacro&lt;/var&gt; is executed over and over until it encounters an error or a failing search.</source>
          <target state="translated">The argument &lt;var&gt;count&lt;/var&gt; is a repeat count; &lt;var&gt;kbdmacro&lt;/var&gt; is executed that many times. If &lt;var&gt;count&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt; , &lt;var&gt;kbdmacro&lt;/var&gt; is executed once. If it is 0, &lt;var&gt;kbdmacro&lt;/var&gt; is executed over and over until it encounters an error or a failing search.</target>
        </trans-unit>
        <trans-unit id="8c7ff309333d395240c83333e112d50cc4709c16" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;current-group&lt;/var&gt; is a flag that makes a difference when you are running a job-control shell as an Emacs subprocess. If it is non-&lt;code&gt;nil&lt;/code&gt;, then the signal is sent to the current process-group of the terminal that Emacs uses to communicate with the subprocess. If the process is a job-control shell, this means the shell&amp;rsquo;s current subjob. If &lt;var&gt;current-group&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, the signal is sent to the process group of the immediate subprocess of Emacs. If the subprocess is a job-control shell, this is the shell itself. If &lt;var&gt;current-group&lt;/var&gt; is &lt;code&gt;lambda&lt;/code&gt;, the signal is sent to the process-group that owns the terminal, but only if it is not the shell itself.</source>
          <target state="translated">The argument &lt;var&gt;current-group&lt;/var&gt; is a flag that makes a difference when you are running a job-control shell as an Emacs subprocess. If it is non- &lt;code&gt;nil&lt;/code&gt; , then the signal is sent to the current process-group of the terminal that Emacs uses to communicate with the subprocess. If the process is a job-control shell, this means the shell&amp;rsquo;s current subjob. If &lt;var&gt;current-group&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; , the signal is sent to the process group of the immediate subprocess of Emacs. If the subprocess is a job-control shell, this is the shell itself. If &lt;var&gt;current-group&lt;/var&gt; is &lt;code&gt;lambda&lt;/code&gt; , the signal is sent to the process-group that owns the terminal, but only if it is not the shell itself.</target>
        </trans-unit>
        <trans-unit id="d3941ef4572aafabe4d82a914cd588f566cf28f8" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;data&lt;/var&gt; is a way to arrange for arbitrary additional data to be passed to &lt;var&gt;func&lt;/var&gt; when it is called. Whatever pointer is passed to &lt;code&gt;make_function&lt;/code&gt; will be passed unaltered to &lt;var&gt;func&lt;/var&gt;.</source>
          <target state="translated">The argument &lt;var&gt;data&lt;/var&gt; is a way to arrange for arbitrary additional data to be passed to &lt;var&gt;func&lt;/var&gt; when it is called. Whatever pointer is passed to &lt;code&gt;make_function&lt;/code&gt; will be passed unaltered to &lt;var&gt;func&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="b7de2b6cb91524eff278a8127fa1412f99cec41e" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;default&lt;/var&gt; specifies default values to make available through the history commands. It should be a string, a list of strings, or &lt;code&gt;nil&lt;/code&gt;. The string or strings become the minibuffer&amp;rsquo;s &amp;ldquo;future history&amp;rdquo;, available to the user with</source>
          <target state="translated">The argument &lt;var&gt;default&lt;/var&gt; specifies default values to make available through the history commands. It should be a string, a list of strings, or &lt;code&gt;nil&lt;/code&gt; . The string or strings become the minibuffer&amp;rsquo;s &amp;ldquo;future history&amp;rdquo;, available to the user with</target>
        </trans-unit>
        <trans-unit id="0fd8a73b42de8615825093fdcc1004c92eed7544" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;default&lt;/var&gt; specifies what to return if the user enters null input. It can be a symbol, a string or a list of strings. If it is a string, &lt;code&gt;read-command&lt;/code&gt; interns it before returning it. If it is a list, &lt;code&gt;read-command&lt;/code&gt; interns the first element of this list. If &lt;var&gt;default&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, that means no default has been specified; then if the user enters null input, the return value is &lt;code&gt;(intern &quot;&quot;)&lt;/code&gt;, that is, a symbol whose name is an empty string, and whose printed representation is &lt;code&gt;##&lt;/code&gt; (see &lt;a href=&quot;symbol-type#Symbol-Type&quot;&gt;Symbol Type&lt;/a&gt;).</source>
          <target state="translated">The argument &lt;var&gt;default&lt;/var&gt; specifies what to return if the user enters null input. It can be a symbol, a string or a list of strings. If it is a string, &lt;code&gt;read-command&lt;/code&gt; interns it before returning it. If it is a list, &lt;code&gt;read-command&lt;/code&gt; interns the first element of this list. If &lt;var&gt;default&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; , that means no default has been specified; then if the user enters null input, the return value is &lt;code&gt;(intern &quot;&quot;)&lt;/code&gt; , that is, a symbol whose name is an empty string, and whose printed representation is &lt;code&gt;##&lt;/code&gt; (see &lt;a href=&quot;symbol-type#Symbol-Type&quot;&gt;Symbol Type&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="4c97f0e8be6d0008a7faafdfd445d05e4a3215d0" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;directory&lt;/var&gt; specifies the directory to use for completing relative file names. It should be an absolute directory name. If the variable &lt;code&gt;insert-default-directory&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;, &lt;var&gt;directory&lt;/var&gt; is also inserted in the minibuffer as initial input. It defaults to the current buffer&amp;rsquo;s value of &lt;code&gt;default-directory&lt;/code&gt;.</source>
          <target state="translated">The argument &lt;var&gt;directory&lt;/var&gt; specifies the directory to use for completing relative file names. It should be an absolute directory name. If the variable &lt;code&gt;insert-default-directory&lt;/code&gt; is non- &lt;code&gt;nil&lt;/code&gt; , &lt;var&gt;directory&lt;/var&gt; is also inserted in the minibuffer as initial input. It defaults to the current buffer&amp;rsquo;s value of &lt;code&gt;default-directory&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eac6e77f50cc69887c03e5e7a9a7a83098c352ec" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;doc&lt;/var&gt; specifies the documentation string for the variable.</source>
          <target state="translated">The argument &lt;var&gt;doc&lt;/var&gt; specifies the documentation string for the variable.</target>
        </trans-unit>
        <trans-unit id="7781b509373191b675fad7c943463743a5b15403" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;docstring&lt;/var&gt; is the documentation string for the function. Specifying the documentation string in the call to &lt;code&gt;autoload&lt;/code&gt; makes it possible to look at the documentation without loading the function&amp;rsquo;s real definition. Normally, this should be identical to the documentation string in the function definition itself. If it isn&amp;rsquo;t, the function definition&amp;rsquo;s documentation string takes effect when it is loaded.</source>
          <target state="translated">The argument &lt;var&gt;docstring&lt;/var&gt; is the documentation string for the function. Specifying the documentation string in the call to &lt;code&gt;autoload&lt;/code&gt; makes it possible to look at the documentation without loading the function&amp;rsquo;s real definition. Normally, this should be identical to the documentation string in the function definition itself. If it isn&amp;rsquo;t, the function definition&amp;rsquo;s documentation string takes effect when it is loaded.</target>
        </trans-unit>
        <trans-unit id="04e091f63b7fbae98fa99c0bac21a5a178106ee2" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;docstring&lt;/var&gt; specifies the documentation string for the function. It should be either an</source>
          <target state="translated">The argument &lt;var&gt;docstring&lt;/var&gt; specifies the documentation string for the function. It should be either an</target>
        </trans-unit>
        <trans-unit id="bd17ab1ce2a49502882ba295a450f07a837d7a99" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;docstring&lt;/var&gt; specifies the documentation string for the new mode. &lt;code&gt;define-derived-mode&lt;/code&gt; adds some general information about the mode&amp;rsquo;s hook, followed by the mode&amp;rsquo;s keymap, at the end of this documentation string. If you omit &lt;var&gt;docstring&lt;/var&gt;, &lt;code&gt;define-derived-mode&lt;/code&gt; generates a documentation string.</source>
          <target state="translated">The argument &lt;var&gt;docstring&lt;/var&gt; specifies the documentation string for the new mode. &lt;code&gt;define-derived-mode&lt;/code&gt; adds some general information about the mode&amp;rsquo;s hook, followed by the mode&amp;rsquo;s keymap, at the end of this documentation string. If you omit &lt;var&gt;docstring&lt;/var&gt; , &lt;code&gt;define-derived-mode&lt;/code&gt; generates a documentation string.</target>
        </trans-unit>
        <trans-unit id="8b2f3e02d30ef15fdb865417c6bf4e751f67ad61" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;error-symbol&lt;/var&gt; must be an &lt;em&gt;error symbol&lt;/em&gt;&amp;mdash;a symbol defined with &lt;code&gt;define-error&lt;/code&gt;. This is how Emacs Lisp classifies different sorts of errors. See &lt;a href=&quot;error-symbols#Error-Symbols&quot;&gt;Error Symbols&lt;/a&gt;, for a description of error symbols, error conditions and condition names.</source>
          <target state="translated">The argument &lt;var&gt;error-symbol&lt;/var&gt; must be an &lt;em&gt;error symbol&lt;/em&gt;&amp;mdash;a symbol defined with &lt;code&gt;define-error&lt;/code&gt; . This is how Emacs Lisp classifies different sorts of errors. See &lt;a href=&quot;error-symbols#Error-Symbols&quot;&gt;Error Symbols&lt;/a&gt;, for a description of error symbols, error conditions and condition names.</target>
        </trans-unit>
        <trans-unit id="bc63a3477a188838da943b9200d27c84d6d19f56" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;event&lt;/var&gt; may be an entire event object, or just an event type. If &lt;var&gt;event&lt;/var&gt; is a symbol that has never been used in an event that has been read as input in the current Emacs session, then &lt;code&gt;event-modifiers&lt;/code&gt; can return &lt;code&gt;nil&lt;/code&gt;, even when &lt;var&gt;event&lt;/var&gt; actually has modifiers.</source>
          <target state="translated">The argument &lt;var&gt;event&lt;/var&gt; may be an entire event object, or just an event type. If &lt;var&gt;event&lt;/var&gt; is a symbol that has never been used in an event that has been read as input in the current Emacs session, then &lt;code&gt;event-modifiers&lt;/code&gt; can return &lt;code&gt;nil&lt;/code&gt; , even when &lt;var&gt;event&lt;/var&gt; actually has modifiers.</target>
        </trans-unit>
        <trans-unit id="7904c0efac8eb6a309359bc0c8d1556bb612c4b3" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;file&lt;/var&gt; may be either a directory or a file specification including wildcard characters. If &lt;var&gt;wildcard&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, that means treat &lt;var&gt;file&lt;/var&gt; as a file specification with wildcards.</source>
          <target state="translated">The argument &lt;var&gt;file&lt;/var&gt; may be either a directory or a file specification including wildcard characters. If &lt;var&gt;wildcard&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , that means treat &lt;var&gt;file&lt;/var&gt; as a file specification with wildcards.</target>
        </trans-unit>
        <trans-unit id="9371be3ca14b7d72d73c5ede9be6979d9d6d0623" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;force&lt;/var&gt; also has an effect if the line isn&amp;rsquo;t long enough to reach column &lt;var&gt;column&lt;/var&gt;; if it is &lt;code&gt;t&lt;/code&gt;, that means to add whitespace at the end of the line to reach that column.</source>
          <target state="translated">The argument &lt;var&gt;force&lt;/var&gt; also has an effect if the line isn&amp;rsquo;t long enough to reach column &lt;var&gt;column&lt;/var&gt; ; if it is &lt;code&gt;t&lt;/code&gt; , that means to add whitespace at the end of the line to reach that column.</target>
        </trans-unit>
        <trans-unit id="12147a609851b483f1ee7c1184f437efbf04c5a7" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;format&lt;/var&gt; is a list of format names. If &lt;var&gt;format&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, no conversion takes place. Interactively, typing just</source>
          <target state="translated">The argument &lt;var&gt;format&lt;/var&gt; is a list of format names. If &lt;var&gt;format&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; , no conversion takes place. Interactively, typing just</target>
        </trans-unit>
        <trans-unit id="4e552f392e638ae5e1cc465f462059be7ffc7762" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;function&lt;/var&gt; must be a function that can take one argument and returns a sequence of characters: a string, a vector, or a list. The argument &lt;var&gt;sequence&lt;/var&gt; can be any kind of sequence except a char-table; that is, a list, a vector, a bool-vector, or a string.</source>
          <target state="translated">The argument &lt;var&gt;function&lt;/var&gt; must be a function that can take one argument and returns a sequence of characters: a string, a vector, or a list. The argument &lt;var&gt;sequence&lt;/var&gt; can be any kind of sequence except a char-table; that is, a list, a vector, a bool-vector, or a string.</target>
        </trans-unit>
        <trans-unit id="ddc30685dfa4ed9158a6234aef7cfe1c4019a601" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;function&lt;/var&gt; must be either a Lisp function or a primitive function. Special forms and macros are not allowed, because they make sense only when given the unevaluated argument expressions. &lt;code&gt;funcall&lt;/code&gt; cannot provide these because, as we saw above, it never knows them in the first place.</source>
          <target state="translated">The argument &lt;var&gt;function&lt;/var&gt; must be either a Lisp function or a primitive function. Special forms and macros are not allowed, because they make sense only when given the unevaluated argument expressions. &lt;code&gt;funcall&lt;/code&gt; cannot provide these because, as we saw above, it never knows them in the first place.</target>
        </trans-unit>
        <trans-unit id="2e30324ca741e84e486f486ca93672bb66bab46e" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;help-line&lt;/var&gt; should be a single-line summary of the alternatives in &lt;var&gt;help-map&lt;/var&gt;. In the current version of Emacs, this argument is used only if you set the option &lt;code&gt;three-step-help&lt;/code&gt; to &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">The argument &lt;var&gt;help-line&lt;/var&gt; should be a single-line summary of the alternatives in &lt;var&gt;help-map&lt;/var&gt; . In the current version of Emacs, this argument is used only if you set the option &lt;code&gt;three-step-help&lt;/code&gt; to &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="127d393be33d3a8d95a8598319f7563453a6009e" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;history&lt;/var&gt; specifies a history list variable to use for saving the input and for history commands used in the minibuffer. It defaults to &lt;code&gt;minibuffer-history&lt;/code&gt;. You can optionally specify a starting position in the history list as well. See &lt;a href=&quot;minibuffer-history#Minibuffer-History&quot;&gt;Minibuffer History&lt;/a&gt;.</source>
          <target state="translated">The argument &lt;var&gt;history&lt;/var&gt; specifies a history list variable to use for saving the input and for history commands used in the minibuffer. It defaults to &lt;code&gt;minibuffer-history&lt;/code&gt; . You can optionally specify a starting position in the history list as well. See &lt;a href=&quot;minibuffer-history#Minibuffer-History&quot;&gt;Minibuffer History&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="3573ac7d09f3cbe3a9ed7cb1b453c6e5b9ae6a98" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;history&lt;/var&gt; specifies which history list variable to use for saving the input and for minibuffer history commands. It defaults to &lt;code&gt;minibuffer-history&lt;/code&gt;. See &lt;a href=&quot;minibuffer-history#Minibuffer-History&quot;&gt;Minibuffer History&lt;/a&gt;.</source>
          <target state="translated">The argument &lt;var&gt;history&lt;/var&gt; specifies which history list variable to use for saving the input and for minibuffer history commands. It defaults to &lt;code&gt;minibuffer-history&lt;/code&gt; . See &lt;a href=&quot;minibuffer-history#Minibuffer-History&quot;&gt;Minibuffer History&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="337728b68989d9c2d290c7b3166cd39cbd7d6a6f" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;hook&lt;/var&gt; is a function or &lt;code&gt;nil&lt;/code&gt;. If &lt;var&gt;hook&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then it is called with no arguments after the abbrev is replaced with &lt;var&gt;expansion&lt;/var&gt;; point is located at the end of &lt;var&gt;expansion&lt;/var&gt; when &lt;var&gt;hook&lt;/var&gt; is called.</source>
          <target state="translated">The argument &lt;var&gt;hook&lt;/var&gt; is a function or &lt;code&gt;nil&lt;/code&gt; . If &lt;var&gt;hook&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , then it is called with no arguments after the abbrev is replaced with &lt;var&gt;expansion&lt;/var&gt; ; point is located at the end of &lt;var&gt;expansion&lt;/var&gt; when &lt;var&gt;hook&lt;/var&gt; is called.</target>
        </trans-unit>
        <trans-unit id="bd5778b8ef92c13549c1f7ef7e69e42a33280d37" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;how&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt; specifies explicitly the style of justification. It can be &lt;code&gt;left&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;, &lt;code&gt;full&lt;/code&gt;, &lt;code&gt;center&lt;/code&gt;, or &lt;code&gt;none&lt;/code&gt;. If it is &lt;code&gt;t&lt;/code&gt;, that means to follow specified justification style (see &lt;code&gt;current-justification&lt;/code&gt;, below). &lt;code&gt;nil&lt;/code&gt; means to do full justification.</source>
          <target state="translated">The argument &lt;var&gt;how&lt;/var&gt; , if non- &lt;code&gt;nil&lt;/code&gt; specifies explicitly the style of justification. It can be &lt;code&gt;left&lt;/code&gt; , &lt;code&gt;right&lt;/code&gt; , &lt;code&gt;full&lt;/code&gt; , &lt;code&gt;center&lt;/code&gt; , or &lt;code&gt;none&lt;/code&gt; . If it is &lt;code&gt;t&lt;/code&gt; , that means to follow specified justification style (see &lt;code&gt;current-justification&lt;/code&gt; , below). &lt;code&gt;nil&lt;/code&gt; means to do full justification.</target>
        </trans-unit>
        <trans-unit id="1842f1cad7ab3b7c140d1cfe864326f7e3619df2" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;image&lt;/var&gt; must be an image descriptor, perhaps returned by &lt;code&gt;create-image&lt;/code&gt; or stored by &lt;code&gt;defimage&lt;/code&gt;.</source>
          <target state="translated">The argument &lt;var&gt;image&lt;/var&gt; must be an image descriptor, perhaps returned by &lt;code&gt;create-image&lt;/code&gt; or stored by &lt;code&gt;defimage&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96f968277564af4a88d9fe134d19c7c4704c5a69" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;initial&lt;/var&gt; is mostly deprecated; we recommend using a non-&lt;code&gt;nil&lt;/code&gt; value only in conjunction with specifying a cons cell for &lt;var&gt;history&lt;/var&gt;. See &lt;a href=&quot;initial-input#Initial-Input&quot;&gt;Initial Input&lt;/a&gt;. For default input, use &lt;var&gt;default&lt;/var&gt; instead.</source>
          <target state="translated">The argument &lt;var&gt;initial&lt;/var&gt; is mostly deprecated; we recommend using a non- &lt;code&gt;nil&lt;/code&gt; value only in conjunction with specifying a cons cell for &lt;var&gt;history&lt;/var&gt; . See &lt;a href=&quot;initial-input#Initial-Input&quot;&gt;Initial Input&lt;/a&gt;. For default input, use &lt;var&gt;default&lt;/var&gt; instead.</target>
        </trans-unit>
        <trans-unit id="974d3227bd589119d939e9661c5cc12b79770e53" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;keys&lt;/var&gt;, if given, should be a vector which specifies the sequence of events to supply if the command inquires which events were used to invoke it. If &lt;var&gt;keys&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt;, the default is the return value of &lt;code&gt;this-command-keys-vector&lt;/code&gt;. See &lt;a href=&quot;command-loop-info#Definition-of-this_002dcommand_002dkeys_002dvector&quot;&gt;Definition of this-command-keys-vector&lt;/a&gt;.</source>
          <target state="translated">The argument &lt;var&gt;keys&lt;/var&gt; , if given, should be a vector which specifies the sequence of events to supply if the command inquires which events were used to invoke it. If &lt;var&gt;keys&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt; , the default is the return value of &lt;code&gt;this-command-keys-vector&lt;/code&gt; . See &lt;a href=&quot;command-loop-info#Definition-of-this_002dcommand_002dkeys_002dvector&quot;&gt;Definition of this-command-keys-vector&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="c4c4bb39cda803046ad86dff926b35116869dcc4" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;keyword-list&lt;/var&gt; is a list of keywords to highlight with &lt;code&gt;font-lock-keyword-face&lt;/code&gt;. Each keyword should be a string. Meanwhile, &lt;var&gt;font-lock-list&lt;/var&gt; is a list of additional expressions to highlight. Each element of this list should have the same form as an element of &lt;code&gt;font-lock-keywords&lt;/code&gt;. See &lt;a href=&quot;search_002dbased-fontification#Search_002dbased-Fontification&quot;&gt;Search-based Fontification&lt;/a&gt;.</source>
          <target state="translated">The argument &lt;var&gt;keyword-list&lt;/var&gt; is a list of keywords to highlight with &lt;code&gt;font-lock-keyword-face&lt;/code&gt; . Each keyword should be a string. Meanwhile, &lt;var&gt;font-lock-list&lt;/var&gt; is a list of additional expressions to highlight. Each element of this list should have the same form as an element of &lt;code&gt;font-lock-keywords&lt;/code&gt; . See &lt;a href=&quot;search_002dbased-fontification#Search_002dbased-Fontification&quot;&gt;Search-based Fontification&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="25d82b58f4ee522411cbc631410a35fdf23c3431" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;kind&lt;/var&gt; should be either the symbol &lt;code&gt;interactive&lt;/code&gt; or the symbol &lt;code&gt;any&lt;/code&gt;. If it is &lt;code&gt;interactive&lt;/code&gt;, then &lt;code&gt;called-interactively-p&lt;/code&gt; returns &lt;code&gt;t&lt;/code&gt; only if the call was made directly by the user&amp;mdash;e.g., if the user typed a key sequence bound to the calling function, but &lt;em&gt;not&lt;/em&gt; if the user ran a keyboard macro that called the function (see &lt;a href=&quot;keyboard-macros#Keyboard-Macros&quot;&gt;Keyboard Macros&lt;/a&gt;). If &lt;var&gt;kind&lt;/var&gt; is &lt;code&gt;any&lt;/code&gt;, &lt;code&gt;called-interactively-p&lt;/code&gt; returns &lt;code&gt;t&lt;/code&gt; for any kind of interactive call, including keyboard macros.</source>
          <target state="translated">The argument &lt;var&gt;kind&lt;/var&gt; should be either the symbol &lt;code&gt;interactive&lt;/code&gt; or the symbol &lt;code&gt;any&lt;/code&gt; . If it is &lt;code&gt;interactive&lt;/code&gt; , then &lt;code&gt;called-interactively-p&lt;/code&gt; returns &lt;code&gt;t&lt;/code&gt; only if the call was made directly by the user&amp;mdash;e.g., if the user typed a key sequence bound to the calling function, but &lt;em&gt;not&lt;/em&gt; if the user ran a keyboard macro that called the function (see &lt;a href=&quot;keyboard-macros#Keyboard-Macros&quot;&gt;Keyboard Macros&lt;/a&gt;). If &lt;var&gt;kind&lt;/var&gt; is &lt;code&gt;any&lt;/code&gt; , &lt;code&gt;called-interactively-p&lt;/code&gt; returns &lt;code&gt;t&lt;/code&gt; for any kind of interactive call, including keyboard macros.</target>
        </trans-unit>
        <trans-unit id="196be81f6b9a392e133455b5fb487c8f96ab960c" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;left&lt;/var&gt; specifies the width in pixels of the left fringe, and likewise &lt;var&gt;right&lt;/var&gt; for the right fringe. A value of &lt;code&gt;nil&lt;/code&gt; for either one stands for the default width. If &lt;var&gt;outside-margins&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, that specifies that fringes should appear outside of the display margins.</source>
          <target state="translated">The argument &lt;var&gt;left&lt;/var&gt; specifies the width in pixels of the left fringe, and likewise &lt;var&gt;right&lt;/var&gt; for the right fringe. A value of &lt;code&gt;nil&lt;/code&gt; for either one stands for the default width. If &lt;var&gt;outside-margins&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , that specifies that fringes should appear outside of the display margins.</target>
        </trans-unit>
        <trans-unit id="9d27ba0b5af1380567016503ffb0e2b8f7cc8071" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;lexical&lt;/var&gt; specifies the scoping rule for local variables (see &lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;Variable Scoping&lt;/a&gt;). If it is omitted or &lt;code&gt;nil&lt;/code&gt;, that means to evaluate &lt;var&gt;form&lt;/var&gt; using the default dynamic scoping rule. If it is &lt;code&gt;t&lt;/code&gt;, that means to use the lexical scoping rule. The value of &lt;var&gt;lexical&lt;/var&gt; can also be a non-empty alist specifying a particular &lt;em&gt;lexical environment&lt;/em&gt; for lexical bindings; however, this feature is only useful for specialized purposes, such as in Emacs Lisp debuggers. See &lt;a href=&quot;lexical-binding#Lexical-Binding&quot;&gt;Lexical Binding&lt;/a&gt;.</source>
          <target state="translated">The argument &lt;var&gt;lexical&lt;/var&gt; specifies the scoping rule for local variables (see &lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;Variable Scoping&lt;/a&gt;). If it is omitted or &lt;code&gt;nil&lt;/code&gt; , that means to evaluate &lt;var&gt;form&lt;/var&gt; using the default dynamic scoping rule. If it is &lt;code&gt;t&lt;/code&gt; , that means to use the lexical scoping rule. The value of &lt;var&gt;lexical&lt;/var&gt; can also be a non-empty alist specifying a particular &lt;em&gt;lexical environment&lt;/em&gt; for lexical bindings; however, this feature is only useful for specialized purposes, such as in Emacs Lisp debuggers. See &lt;a href=&quot;lexical-binding#Lexical-Binding&quot;&gt;Lexical Binding&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="c17f6e31c66c06841db5748f38c43cbe2e85ecb7" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;limit&lt;/var&gt; specifies the bound to the search, and should be a position in the current buffer. No match extending after that position is accepted. If &lt;var&gt;limit&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt;, it defaults to the end of the accessible portion of the buffer.</source>
          <target state="translated">The argument &lt;var&gt;limit&lt;/var&gt; specifies the bound to the search, and should be a position in the current buffer. No match extending after that position is accepted. If &lt;var&gt;limit&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt; , it defaults to the end of the accessible portion of the buffer.</target>
        </trans-unit>
        <trans-unit id="dd040b041a862b040024285cd7f4c2ae445161d8" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;members&lt;/var&gt; is a list specifying an initial set of customization items to be members of the group. However, most often &lt;var&gt;members&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, and you specify the group&amp;rsquo;s members by using the &lt;code&gt;:group&lt;/code&gt; keyword when defining those members.</source>
          <target state="translated">The argument &lt;var&gt;members&lt;/var&gt; is a list specifying an initial set of customization items to be members of the group. However, most often &lt;var&gt;members&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; , and you specify the group&amp;rsquo;s members by using the &lt;code&gt;:group&lt;/code&gt; keyword when defining those members.</target>
        </trans-unit>
        <trans-unit id="0408e94f530ce550a379720f8c833ca4bc4fc95a" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;menu&lt;/var&gt; says what to display in the menu. It can be a keymap or a list of keymaps (see &lt;a href=&quot;menu-keymaps#Menu-Keymaps&quot;&gt;Menu Keymaps&lt;/a&gt;). In this case, the return value is the list of events corresponding to the user&amp;rsquo;s choice. This list has more than one element if the choice occurred in a submenu. (Note that &lt;code&gt;x-popup-menu&lt;/code&gt; does not actually execute the command bound to that sequence of events.) On text terminals and toolkits that support menu titles, the title is taken from the prompt string of &lt;var&gt;menu&lt;/var&gt; if &lt;var&gt;menu&lt;/var&gt; is a keymap, or from the prompt string of the first keymap in &lt;var&gt;menu&lt;/var&gt; if it is a list of keymaps (see &lt;a href=&quot;defining-menus#Defining-Menus&quot;&gt;Defining Menus&lt;/a&gt;).</source>
          <target state="translated">The argument &lt;var&gt;menu&lt;/var&gt; says what to display in the menu. It can be a keymap or a list of keymaps (see &lt;a href=&quot;menu-keymaps#Menu-Keymaps&quot;&gt;Menu Keymaps&lt;/a&gt;). In this case, the return value is the list of events corresponding to the user&amp;rsquo;s choice. This list has more than one element if the choice occurred in a submenu. (Note that &lt;code&gt;x-popup-menu&lt;/code&gt; does not actually execute the command bound to that sequence of events.) On text terminals and toolkits that support menu titles, the title is taken from the prompt string of &lt;var&gt;menu&lt;/var&gt; if &lt;var&gt;menu&lt;/var&gt; is a keymap, or from the prompt string of the first keymap in &lt;var&gt;menu&lt;/var&gt; if it is a list of keymaps (see &lt;a href=&quot;defining-menus#Defining-Menus&quot;&gt;Defining Menus&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="88747b097449b29e56bc00712a63362c30691cd1" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;meta&lt;/var&gt; controls support for input character codes above 127. If &lt;var&gt;meta&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;, Emacs converts characters with the 8th bit set into Meta characters. If &lt;var&gt;meta&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, Emacs disregards the 8th bit; this is necessary when the terminal uses it as a parity bit. If &lt;var&gt;meta&lt;/var&gt; is neither &lt;code&gt;t&lt;/code&gt; nor &lt;code&gt;nil&lt;/code&gt;, Emacs uses all 8 bits of input unchanged. This is good for terminals that use 8-bit character sets.</source>
          <target state="translated">The argument &lt;var&gt;meta&lt;/var&gt; controls support for input character codes above 127. If &lt;var&gt;meta&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt; , Emacs converts characters with the 8th bit set into Meta characters. If &lt;var&gt;meta&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; , Emacs disregards the 8th bit; this is necessary when the terminal uses it as a parity bit. If &lt;var&gt;meta&lt;/var&gt; is neither &lt;code&gt;t&lt;/code&gt; nor &lt;code&gt;nil&lt;/code&gt; , Emacs uses all 8 bits of input unchanged. This is good for terminals that use 8-bit character sets.</target>
        </trans-unit>
        <trans-unit id="7b69f27c31d0a41c9c347845fd11bdd63da029d5" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;millisec&lt;/var&gt; is obsolete (and should not be used), because &lt;var&gt;seconds&lt;/var&gt; can be floating point to specify waiting a fractional number of seconds. If &lt;var&gt;seconds&lt;/var&gt; is 0, the function accepts whatever output is pending but does not wait.</source>
          <target state="translated">The argument &lt;var&gt;millisec&lt;/var&gt; is obsolete (and should not be used), because &lt;var&gt;seconds&lt;/var&gt; can be floating point to specify waiting a fractional number of seconds. If &lt;var&gt;seconds&lt;/var&gt; is 0, the function accepts whatever output is pending but does not wait.</target>
        </trans-unit>
        <trans-unit id="0cf53f56ad140e70514995e9d0814aa3d76c0e8e" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;mode&lt;/var&gt; should be an integer which specifies the permissions, similar to &lt;code&gt;set-file-modes&lt;/code&gt; above. Only the lowest 9 bits are meaningful.</source>
          <target state="translated">The argument &lt;var&gt;mode&lt;/var&gt; should be an integer which specifies the permissions, similar to &lt;code&gt;set-file-modes&lt;/code&gt; above. Only the lowest 9 bits are meaningful.</target>
        </trans-unit>
        <trans-unit id="a16d7cf6dfa227347abb2403a6e7c2be2b2591f2" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;name&lt;/var&gt; may also be a symbol; in that case, the function returns &lt;var&gt;name&lt;/var&gt; if &lt;var&gt;name&lt;/var&gt; is interned in the specified obarray, and otherwise &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">The argument &lt;var&gt;name&lt;/var&gt; may also be a symbol; in that case, the function returns &lt;var&gt;name&lt;/var&gt; if &lt;var&gt;name&lt;/var&gt; is interned in the specified obarray, and otherwise &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="69fc1cc6b623ffbdee12e31cc3480d92239d6a8b" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;noerror&lt;/var&gt; only affects valid searches which fail to find a match. Invalid arguments cause errors regardless of &lt;var&gt;noerror&lt;/var&gt;.</source>
          <target state="translated">The argument &lt;var&gt;noerror&lt;/var&gt; only affects valid searches which fail to find a match. Invalid arguments cause errors regardless of &lt;var&gt;noerror&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="8d81e59db92b382d9e224aeb68da9946a0652004" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;object&lt;/var&gt; can be a function name, a lambda expression (see &lt;a href=&quot;lambda-expressions#Lambda-Expressions&quot;&gt;Lambda Expressions&lt;/a&gt;), or a byte-code object (see &lt;a href=&quot;byte_002dcode-objects#Byte_002dCode-Objects&quot;&gt;Byte-Code Objects&lt;/a&gt;). If it is a lambda expression, &lt;code&gt;disassemble&lt;/code&gt; compiles it and disassembles the resulting compiled code.</source>
          <target state="translated">The argument &lt;var&gt;object&lt;/var&gt; can be a function name, a lambda expression (see &lt;a href=&quot;lambda-expressions#Lambda-Expressions&quot;&gt;Lambda Expressions&lt;/a&gt;), or a byte-code object (see &lt;a href=&quot;byte_002dcode-objects#Byte_002dCode-Objects&quot;&gt;Byte-Code Objects&lt;/a&gt;). If it is a lambda expression, &lt;code&gt;disassemble&lt;/code&gt; compiles it and disassembles the resulting compiled code.</target>
        </trans-unit>
        <trans-unit id="dad6e03a1386425d5769205e122d50e6a21178f7" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;object&lt;/var&gt; may be a string, a buffer, or a window. If it is a window, then the buffer displayed in that window is used for text properties and overlays, but only the overlays active for that window are considered. If &lt;var&gt;object&lt;/var&gt; is a buffer, then overlays in that buffer are considered first, in order of decreasing priority, followed by the text properties. If &lt;var&gt;object&lt;/var&gt; is a string, only text properties are considered, since strings never have overlays.</source>
          <target state="translated">The argument &lt;var&gt;object&lt;/var&gt; may be a string, a buffer, or a window. If it is a window, then the buffer displayed in that window is used for text properties and overlays, but only the overlays active for that window are considered. If &lt;var&gt;object&lt;/var&gt; is a buffer, then overlays in that buffer are considered first, in order of decreasing priority, followed by the text properties. If &lt;var&gt;object&lt;/var&gt; is a string, only text properties are considered, since strings never have overlays.</target>
        </trans-unit>
        <trans-unit id="001fe7686d2c31dc753172d3f9a15f72fd251e2a" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;offsets&lt;/var&gt; is either &lt;code&gt;nil&lt;/code&gt; or a cons cell of the form &lt;code&gt;(&lt;var&gt;hscroll&lt;/var&gt; . &lt;var&gt;tab-offset&lt;/var&gt;)&lt;/code&gt;. Here &lt;var&gt;hscroll&lt;/var&gt; is the number of columns not being displayed at the left margin; most callers get this by calling &lt;code&gt;window-hscroll&lt;/code&gt;. Meanwhile, &lt;var&gt;tab-offset&lt;/var&gt; is the offset between column numbers on the screen and column numbers in the buffer. This can be nonzero in a continuation line, when the previous screen lines&amp;rsquo; widths do not add up to a multiple of &lt;code&gt;tab-width&lt;/code&gt;. It is always zero in a non-continuation line.</source>
          <target state="translated">The argument &lt;var&gt;offsets&lt;/var&gt; is either &lt;code&gt;nil&lt;/code&gt; or a cons cell of the form &lt;code&gt;(&lt;var&gt;hscroll&lt;/var&gt; . &lt;var&gt;tab-offset&lt;/var&gt;)&lt;/code&gt; . Here &lt;var&gt;hscroll&lt;/var&gt; is the number of columns not being displayed at the left margin; most callers get this by calling &lt;code&gt;window-hscroll&lt;/code&gt; . Meanwhile, &lt;var&gt;tab-offset&lt;/var&gt; is the offset between column numbers on the screen and column numbers in the buffer. This can be nonzero in a continuation line, when the previous screen lines&amp;rsquo; widths do not add up to a multiple of &lt;code&gt;tab-width&lt;/code&gt; . It is always zero in a non-continuation line.</target>
        </trans-unit>
        <trans-unit id="bd432b621bc1d2381c02fe76deeee1b9cd6e2aa5" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;operation&lt;/var&gt; is a symbol; it should be one of &lt;code&gt;write-region&lt;/code&gt;, &lt;code&gt;start-process&lt;/code&gt;, &lt;code&gt;call-process&lt;/code&gt;, &lt;code&gt;call-process-region&lt;/code&gt;, &lt;code&gt;insert-file-contents&lt;/code&gt;, or &lt;code&gt;open-network-stream&lt;/code&gt;. These are the names of the Emacs I/O primitives that can do character code and eol conversion.</source>
          <target state="translated">The argument &lt;var&gt;operation&lt;/var&gt; is a symbol; it should be one of &lt;code&gt;write-region&lt;/code&gt; , &lt;code&gt;start-process&lt;/code&gt; , &lt;code&gt;call-process&lt;/code&gt; , &lt;code&gt;call-process-region&lt;/code&gt; , &lt;code&gt;insert-file-contents&lt;/code&gt; , or &lt;code&gt;open-network-stream&lt;/code&gt; . These are the names of the Emacs I/O primitives that can do character code and eol conversion.</target>
        </trans-unit>
        <trans-unit id="b5c495570323a121506457028c43ca0430313d78" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;partial-filename&lt;/var&gt; must be a file name containing no directory part and no slash (or backslash on some systems). The current buffer&amp;rsquo;s default directory is prepended to &lt;var&gt;directory&lt;/var&gt;, if &lt;var&gt;directory&lt;/var&gt; is not absolute.</source>
          <target state="translated">The argument &lt;var&gt;partial-filename&lt;/var&gt; must be a file name containing no directory part and no slash (or backslash on some systems). The current buffer&amp;rsquo;s default directory is prepended to &lt;var&gt;directory&lt;/var&gt; , if &lt;var&gt;directory&lt;/var&gt; is not absolute.</target>
        </trans-unit>
        <trans-unit id="b48f922752b498de38261334e1913b2bb02b6d0d" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;position&lt;/var&gt; specifies where on the screen to put the top left corner of the menu. It can be either a mouse button event (which says to put the menu where the user actuated the button) or a list of this form:</source>
          <target state="translated">The argument &lt;var&gt;position&lt;/var&gt; specifies where on the screen to put the top left corner of the menu. It can be either a mouse button event (which says to put the menu where the user actuated the button) or a list of this form:</target>
        </trans-unit>
        <trans-unit id="d8afa9b503d1608b12cdededd886534cc2bc5427" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;predicate&lt;/var&gt; is the function to use to compare keys. It is called with two arguments, the keys to compare, and should return non-&lt;code&gt;nil&lt;/code&gt; if the first key should come before the second in the sorting order. What exactly are the key arguments depends on what &lt;var&gt;startkeyfun&lt;/var&gt; and &lt;var&gt;endkeyfun&lt;/var&gt; return. If &lt;var&gt;predicate&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt;, it defaults to &lt;code&gt;&amp;lt;&lt;/code&gt; if the keys are numbers, to &lt;code&gt;compare-buffer-substrings&lt;/code&gt; if the keys are cons cells (whose &lt;code&gt;car&lt;/code&gt; and &lt;code&gt;cdr&lt;/code&gt; are start and end buffer positions of the key), and to &lt;code&gt;string&amp;lt;&lt;/code&gt; otherwise (with keys assumed to be strings).</source>
          <target state="translated">The argument &lt;var&gt;predicate&lt;/var&gt; is the function to use to compare keys. It is called with two arguments, the keys to compare, and should return non- &lt;code&gt;nil&lt;/code&gt; if the first key should come before the second in the sorting order. What exactly are the key arguments depends on what &lt;var&gt;startkeyfun&lt;/var&gt; and &lt;var&gt;endkeyfun&lt;/var&gt; return. If &lt;var&gt;predicate&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt; , it defaults to &lt;code&gt;&amp;lt;&lt;/code&gt; if the keys are numbers, to &lt;code&gt;compare-buffer-substrings&lt;/code&gt; if the keys are cons cells (whose &lt;code&gt;car&lt;/code&gt; and &lt;code&gt;cdr&lt;/code&gt; are start and end buffer positions of the key), and to &lt;code&gt;string&amp;lt;&lt;/code&gt; otherwise (with keys assumed to be strings).</target>
        </trans-unit>
        <trans-unit id="a855a735accf62e1134dc780be542253eb20ba2e" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;predicate&lt;/var&gt; must be a function that accepts two arguments. It is called with two elements of &lt;var&gt;sequence&lt;/var&gt;. To get an increasing order sort, the &lt;var&gt;predicate&lt;/var&gt; should return non-&lt;code&gt;nil&lt;/code&gt; if the first element is &amp;ldquo;less&amp;rdquo; than the second, or &lt;code&gt;nil&lt;/code&gt; if not.</source>
          <target state="translated">The argument &lt;var&gt;predicate&lt;/var&gt; must be a function that accepts two arguments. It is called with two elements of &lt;var&gt;sequence&lt;/var&gt; . To get an increasing order sort, the &lt;var&gt;predicate&lt;/var&gt; should return non- &lt;code&gt;nil&lt;/code&gt; if the first element is &amp;ldquo;less&amp;rdquo; than the second, or &lt;code&gt;nil&lt;/code&gt; if not.</target>
        </trans-unit>
        <trans-unit id="d1251fac003853896e745f0298e2aa9d94692f65" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;process&lt;/var&gt; must be either a process, a process name, a buffer, a buffer name, or &lt;code&gt;nil&lt;/code&gt;. A buffer or buffer name stands for a process through &lt;code&gt;get-buffer-process&lt;/code&gt;. &lt;code&gt;nil&lt;/code&gt; stands for the process associated with the current buffer. Except with &lt;code&gt;stop-process&lt;/code&gt; and &lt;code&gt;continue-process&lt;/code&gt;, an error is signaled if &lt;var&gt;process&lt;/var&gt; does not identify an active process, or if it represents a network, serial, or pipe connection.</source>
          <target state="translated">The argument &lt;var&gt;process&lt;/var&gt; must be either a process, a process name, a buffer, a buffer name, or &lt;code&gt;nil&lt;/code&gt; . A buffer or buffer name stands for a process through &lt;code&gt;get-buffer-process&lt;/code&gt; . &lt;code&gt;nil&lt;/code&gt; stands for the process associated with the current buffer. Except with &lt;code&gt;stop-process&lt;/code&gt; and &lt;code&gt;continue-process&lt;/code&gt; , an error is signaled if &lt;var&gt;process&lt;/var&gt; does not identify an active process, or if it represents a network, serial, or pipe connection.</target>
        </trans-unit>
        <trans-unit id="af5bf7e34455acf7be31e9bc5d6f866fc302930e" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;prompt&lt;/var&gt; is either a string to be displayed in the echo area as a prompt, or &lt;code&gt;nil&lt;/code&gt;, meaning not to display a prompt.</source>
          <target state="translated">The argument &lt;var&gt;prompt&lt;/var&gt; is either a string to be displayed in the echo area as a prompt, or &lt;code&gt;nil&lt;/code&gt; , meaning not to display a prompt.</target>
        </trans-unit>
        <trans-unit id="70512a26fcee3aeb8a3425f6dc51d96e107b4faf" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;prompt&lt;/var&gt; is either a string to be displayed in the echo area as a prompt, or &lt;code&gt;nil&lt;/code&gt;, meaning not to display a prompt. The argument &lt;var&gt;continue-echo&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, means to echo this key as a continuation of the previous key.</source>
          <target state="translated">The argument &lt;var&gt;prompt&lt;/var&gt; is either a string to be displayed in the echo area as a prompt, or &lt;code&gt;nil&lt;/code&gt; , meaning not to display a prompt. The argument &lt;var&gt;continue-echo&lt;/var&gt; , if non- &lt;code&gt;nil&lt;/code&gt; , means to echo this key as a continuation of the previous key.</target>
        </trans-unit>
        <trans-unit id="872e597e29d6ed7b7a8c180508178c91f1565bab" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;prompt&lt;/var&gt; should be a string ending with a colon and a space. If &lt;var&gt;default&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the function inserts it in &lt;var&gt;prompt&lt;/var&gt; before the colon to follow the convention for reading from the minibuffer with a default value (see &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/elisp/Programming-Tips.html#Programming-Tips&quot;&gt;Programming Tips&lt;/a&gt;).</source>
          <target state="translated">The argument &lt;var&gt;prompt&lt;/var&gt; should be a string ending with a colon and a space. If &lt;var&gt;default&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , the function inserts it in &lt;var&gt;prompt&lt;/var&gt; before the colon to follow the convention for reading from the minibuffer with a default value (see &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/elisp/Programming-Tips.html#Programming-Tips&quot;&gt;Programming Tips&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="5608256bb905bdbb1eff90b08fadc105facf372d" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;prompter&lt;/var&gt; specifies how to ask each question. If &lt;var&gt;prompter&lt;/var&gt; is a string, the question text is computed like this:</source>
          <target state="translated">The argument &lt;var&gt;prompter&lt;/var&gt; specifies how to ask each question. If &lt;var&gt;prompter&lt;/var&gt; is a string, the question text is computed like this:</target>
        </trans-unit>
        <trans-unit id="eed1350308760f73cd3d24fa91bd9205b37cd744" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;props&lt;/var&gt; is the new property list. It should be a list whose elements are property names alternating with corresponding values.</source>
          <target state="translated">The argument &lt;var&gt;props&lt;/var&gt; is the new property list. It should be a list whose elements are property names alternating with corresponding values.</target>
        </trans-unit>
        <trans-unit id="5bbc2fd92fa2dd281ae56f30f0b8f43f4acc8a92" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;props&lt;/var&gt; specifies which properties to add. It should have the form of a property list (see &lt;a href=&quot;property-lists#Property-Lists&quot;&gt;Property Lists&lt;/a&gt;): a list whose elements include the property names followed alternately by the corresponding values.</source>
          <target state="translated">The argument &lt;var&gt;props&lt;/var&gt; specifies which properties to add. It should have the form of a property list (see &lt;a href=&quot;property-lists#Property-Lists&quot;&gt;Property Lists&lt;/a&gt;): a list whose elements include the property names followed alternately by the corresponding values.</target>
        </trans-unit>
        <trans-unit id="9cc67a41c7e64481d999b8a504d6065516bede3a" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;props&lt;/var&gt; specifies which properties to delete. It should have the form of a property list (see &lt;a href=&quot;property-lists#Property-Lists&quot;&gt;Property Lists&lt;/a&gt;): a list whose elements are property names alternating with corresponding values. But only the names matter&amp;mdash;the values that accompany them are ignored. For example, here&amp;rsquo;s how to remove the &lt;code&gt;face&lt;/code&gt; property.</source>
          <target state="translated">The argument &lt;var&gt;props&lt;/var&gt; specifies which properties to delete. It should have the form of a property list (see &lt;a href=&quot;property-lists#Property-Lists&quot;&gt;Property Lists&lt;/a&gt;): a list whose elements are property names alternating with corresponding values. But only the names matter&amp;mdash;the values that accompany them are ignored. For example, here&amp;rsquo;s how to remove the &lt;code&gt;face&lt;/code&gt; property.</target>
        </trans-unit>
        <trans-unit id="69f2c50ecf74da021b0e7c46691093ec14c66784" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;question&lt;/var&gt; is the outgoing message that starts the transaction. The argument &lt;var&gt;fn&lt;/var&gt; is the function to call when the corresponding answer comes back; it is called with two arguments: &lt;var&gt;closure&lt;/var&gt;, and the answer received.</source>
          <target state="translated">The argument &lt;var&gt;question&lt;/var&gt; is the outgoing message that starts the transaction. The argument &lt;var&gt;fn&lt;/var&gt; is the function to call when the corresponding answer comes back; it is called with two arguments: &lt;var&gt;closure&lt;/var&gt; , and the answer received.</target>
        </trans-unit>
        <trans-unit id="d815e5eb2953e57ddfdc5993729a096fec8bc0cb" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;regexp&lt;/var&gt; is a regular expression that should match text at the end of the entire answer, but nothing before; that&amp;rsquo;s how &lt;code&gt;tq-enqueue&lt;/code&gt; determines where the answer ends.</source>
          <target state="translated">The argument &lt;var&gt;regexp&lt;/var&gt; is a regular expression that should match text at the end of the entire answer, but nothing before; that&amp;rsquo;s how &lt;code&gt;tq-enqueue&lt;/code&gt; determines where the answer ends.</target>
        </trans-unit>
        <trans-unit id="5b5f44f3d22c5a5049bd7ccd1b39ed76340c19cb" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;replacements&lt;/var&gt; specifies what to replace occurrences with. If it is a string, that string is used. It can also be a list of strings, to be used in cyclic order.</source>
          <target state="translated">The argument &lt;var&gt;replacements&lt;/var&gt; specifies what to replace occurrences with. If it is a string, that string is used. It can also be a list of strings, to be used in cyclic order.</target>
        </trans-unit>
        <trans-unit id="211392b7efa5b598b944102aa71b19e31292e6a4" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;runtime&lt;/var&gt; is a pointer to a C &lt;code&gt;struct&lt;/code&gt; that includes 2 public fields: &lt;code&gt;size&lt;/code&gt;, which provides the size of the structure in bytes; and &lt;code&gt;get_environment&lt;/code&gt;, which provides a pointer to a function that allows the module initialization function access to the Emacs environment object and its interfaces.</source>
          <target state="translated">The argument &lt;var&gt;runtime&lt;/var&gt; is a pointer to a C &lt;code&gt;struct&lt;/code&gt; that includes 2 public fields: &lt;code&gt;size&lt;/code&gt; , which provides the size of the structure in bytes; and &lt;code&gt;get_environment&lt;/code&gt; , which provides a pointer to a function that allows the module initialization function access to the Emacs environment object and its interfaces.</target>
        </trans-unit>
        <trans-unit id="b0e7e0b91ad298260b1816cbd65796b68a0bd82d" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;seconds&lt;/var&gt; need not be an integer. If it is floating point, &lt;code&gt;sit-for&lt;/code&gt; waits for a fractional number of seconds. Some systems support only a whole number of seconds; on these systems, &lt;var&gt;seconds&lt;/var&gt; is rounded down.</source>
          <target state="translated">The argument &lt;var&gt;seconds&lt;/var&gt; need not be an integer. If it is floating point, &lt;code&gt;sit-for&lt;/code&gt; waits for a fractional number of seconds. Some systems support only a whole number of seconds; on these systems, &lt;var&gt;seconds&lt;/var&gt; is rounded down.</target>
        </trans-unit>
        <trans-unit id="1a269d46174e2be95bd3636d0d8a3ec1968953df" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;seconds&lt;/var&gt; need not be an integer. If it is floating point, &lt;code&gt;sleep-for&lt;/code&gt; waits for a fractional number of seconds. Some systems support only a whole number of seconds; on these systems, &lt;var&gt;seconds&lt;/var&gt; is rounded down.</source>
          <target state="translated">The argument &lt;var&gt;seconds&lt;/var&gt; need not be an integer. If it is floating point, &lt;code&gt;sleep-for&lt;/code&gt; waits for a fractional number of seconds. Some systems support only a whole number of seconds; on these systems, &lt;var&gt;seconds&lt;/var&gt; is rounded down.</target>
        </trans-unit>
        <trans-unit id="c189f7ca8290602de13d50f2372250cb9f720a2d" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;sequence&lt;/var&gt; can be any kind of sequence except a char-table; that is, a list, a vector, a bool-vector, or a string. The result is always a list. The length of the result is the same as the length of &lt;var&gt;sequence&lt;/var&gt;. For example:</source>
          <target state="translated">The argument &lt;var&gt;sequence&lt;/var&gt; can be any kind of sequence except a char-table; that is, a list, a vector, a bool-vector, or a string. The result is always a list. The length of the result is the same as the length of &lt;var&gt;sequence&lt;/var&gt; . For example:</target>
        </trans-unit>
        <trans-unit id="b45bd09aa0d91bbfc69fc9a445440572bd4cf5d2" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;slice&lt;/var&gt; specifies a slice of the image to insert. If &lt;var&gt;slice&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; or omitted the whole image is inserted. Otherwise, &lt;var&gt;slice&lt;/var&gt; is a list &lt;code&gt;(&lt;var&gt;x&lt;/var&gt; &lt;var&gt;y&lt;/var&gt; &lt;var&gt;width&lt;/var&gt;
&lt;var&gt;height&lt;/var&gt;)&lt;/code&gt; which specifies the &lt;var&gt;x&lt;/var&gt; and &lt;var&gt;y&lt;/var&gt; positions and &lt;var&gt;width&lt;/var&gt; and &lt;var&gt;height&lt;/var&gt; of the image area to insert. Integer values are in units of pixels. A floating-point number in the range 0.0&amp;ndash;1.0 stands for that fraction of the width or height of the entire image.</source>
          <target state="translated">The argument &lt;var&gt;slice&lt;/var&gt; specifies a slice of the image to insert. If &lt;var&gt;slice&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; or omitted the whole image is inserted. Otherwise, &lt;var&gt;slice&lt;/var&gt; is a list &lt;code&gt;(&lt;var&gt;x&lt;/var&gt; &lt;var&gt;y&lt;/var&gt; &lt;var&gt;width&lt;/var&gt; &lt;var&gt;height&lt;/var&gt;)&lt;/code&gt; which specifies the &lt;var&gt;x&lt;/var&gt; and &lt;var&gt;y&lt;/var&gt; positions and &lt;var&gt;width&lt;/var&gt; and &lt;var&gt;height&lt;/var&gt; of the image area to insert. Integer values are in units of pixels. A floating-point number in the range 0.0&amp;ndash;1.0 stands for that fraction of the width or height of the entire image.</target>
        </trans-unit>
        <trans-unit id="e99474cc32a24e7c4f609644dcecc5ca6a4477e1" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;special&lt;/var&gt;, if given, means to ignore the prefix argument and not clear it. This is used for executing special events (see &lt;a href=&quot;special-events#Special-Events&quot;&gt;Special Events&lt;/a&gt;).</source>
          <target state="translated">The argument &lt;var&gt;special&lt;/var&gt; , if given, means to ignore the prefix argument and not clear it. This is used for executing special events (see &lt;a href=&quot;special-events#Special-Events&quot;&gt;Special Events&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="e130557ecc7dad6914c0d468f71414349355f143" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;standard&lt;/var&gt; is an expression that specifies the standard value for &lt;var&gt;option&lt;/var&gt;. Evaluating the &lt;code&gt;defcustom&lt;/code&gt; form evaluates &lt;var&gt;standard&lt;/var&gt;, but does not necessarily bind the option to that value. If &lt;var&gt;option&lt;/var&gt; already has a default value, it is left unchanged. If the user has already saved a customization for &lt;var&gt;option&lt;/var&gt;, the user&amp;rsquo;s customized value is installed as the default value. Otherwise, the result of evaluating &lt;var&gt;standard&lt;/var&gt; is installed as the default value.</source>
          <target state="translated">The argument &lt;var&gt;standard&lt;/var&gt; is an expression that specifies the standard value for &lt;var&gt;option&lt;/var&gt; . Evaluating the &lt;code&gt;defcustom&lt;/code&gt; form evaluates &lt;var&gt;standard&lt;/var&gt; , but does not necessarily bind the option to that value. If &lt;var&gt;option&lt;/var&gt; already has a default value, it is left unchanged. If the user has already saved a customization for &lt;var&gt;option&lt;/var&gt; , the user&amp;rsquo;s customized value is installed as the default value. Otherwise, the result of evaluating &lt;var&gt;standard&lt;/var&gt; is installed as the default value.</target>
        </trans-unit>
        <trans-unit id="a41b9cd7c5304ae1483b63947c8ae36bea193179" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;switch-frame-ok&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, means that this function should process a &lt;code&gt;switch-frame&lt;/code&gt; event if the user switches frames before typing anything. If the user switches frames in the middle of a key sequence, or at the start of the sequence but &lt;var&gt;switch-frame-ok&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, then the event will be put off until after the current key sequence.</source>
          <target state="translated">The argument &lt;var&gt;switch-frame-ok&lt;/var&gt; , if non- &lt;code&gt;nil&lt;/code&gt; , means that this function should process a &lt;code&gt;switch-frame&lt;/code&gt; event if the user switches frames before typing anything. If the user switches frames in the middle of a key sequence, or at the start of the sequence but &lt;var&gt;switch-frame-ok&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; , then the event will be put off until after the current key sequence.</target>
        </trans-unit>
        <trans-unit id="e18bbe26e7a2b0de4caab7675f413155a70f8050" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;symbol&lt;/var&gt; is not implicitly quoted; &lt;code&gt;add-to-list&lt;/code&gt; is an ordinary function, like &lt;code&gt;set&lt;/code&gt; and unlike &lt;code&gt;setq&lt;/code&gt;. Quote the argument yourself if that is what you want.</source>
          <target state="translated">The argument &lt;var&gt;symbol&lt;/var&gt; is not implicitly quoted; &lt;code&gt;add-to-list&lt;/code&gt; is an ordinary function, like &lt;code&gt;set&lt;/code&gt; and unlike &lt;code&gt;setq&lt;/code&gt; . Quote the argument yourself if that is what you want.</target>
        </trans-unit>
        <trans-unit id="ca7c32d401bf914b6464aff472c84af0a66020cf" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;symbol&lt;/var&gt; is not implicitly quoted; &lt;code&gt;add-to-ordered-list&lt;/code&gt; is an ordinary function, like &lt;code&gt;set&lt;/code&gt; and unlike &lt;code&gt;setq&lt;/code&gt;. Quote the argument yourself if necessary.</source>
          <target state="translated">The argument &lt;var&gt;symbol&lt;/var&gt; is not implicitly quoted; &lt;code&gt;add-to-ordered-list&lt;/code&gt; is an ordinary function, like &lt;code&gt;set&lt;/code&gt; and unlike &lt;code&gt;setq&lt;/code&gt; . Quote the argument yourself if necessary.</target>
        </trans-unit>
        <trans-unit id="e08b6b7aae0045521f8c5b5cfa5fa2ed408551ff" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;syntax-descriptor&lt;/var&gt; is a syntax descriptor, i.e., a string whose first character is a syntax class designator and whose second and subsequent characters optionally specify a matching character and syntax flags. See &lt;a href=&quot;syntax-descriptors#Syntax-Descriptors&quot;&gt;Syntax Descriptors&lt;/a&gt;. An error is signaled if &lt;var&gt;syntax-descriptor&lt;/var&gt; is not a valid syntax descriptor.</source>
          <target state="translated">The argument &lt;var&gt;syntax-descriptor&lt;/var&gt; is a syntax descriptor, i.e., a string whose first character is a syntax class designator and whose second and subsequent characters optionally specify a matching character and syntax flags. See &lt;a href=&quot;syntax-descriptors#Syntax-Descriptors&quot;&gt;Syntax Descriptors&lt;/a&gt;. An error is signaled if &lt;var&gt;syntax-descriptor&lt;/var&gt; is not a valid syntax descriptor.</target>
        </trans-unit>
        <trans-unit id="98c04eb36732c1f9acd376bb1b7e8f2093b46e58" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;thing&lt;/var&gt; is a symbol which specifies a kind of syntactic entity. Possibilities include &lt;code&gt;symbol&lt;/code&gt;, &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;sexp&lt;/code&gt;, &lt;code&gt;defun&lt;/code&gt;, &lt;code&gt;filename&lt;/code&gt;, &lt;code&gt;url&lt;/code&gt;, &lt;code&gt;word&lt;/code&gt;, &lt;code&gt;sentence&lt;/code&gt;, &lt;code&gt;whitespace&lt;/code&gt;, &lt;code&gt;line&lt;/code&gt;, &lt;code&gt;page&lt;/code&gt;, and others.</source>
          <target state="translated">The argument &lt;var&gt;thing&lt;/var&gt; is a symbol which specifies a kind of syntactic entity. Possibilities include &lt;code&gt;symbol&lt;/code&gt; , &lt;code&gt;list&lt;/code&gt; , &lt;code&gt;sexp&lt;/code&gt; , &lt;code&gt;defun&lt;/code&gt; , &lt;code&gt;filename&lt;/code&gt; , &lt;code&gt;url&lt;/code&gt; , &lt;code&gt;word&lt;/code&gt; , &lt;code&gt;sentence&lt;/code&gt; , &lt;code&gt;whitespace&lt;/code&gt; , &lt;code&gt;line&lt;/code&gt; , &lt;code&gt;page&lt;/code&gt; , and others.</target>
        </trans-unit>
        <trans-unit id="70061b1cc9d0665934fc07564012818e3ed00551" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;time&lt;/var&gt;, if given, specifies a time to format, instead of the current time. The optional argument &lt;var&gt;zone&lt;/var&gt; defaults to the current time zone rule. See &lt;a href=&quot;time-zone-rules#Time-Zone-Rules&quot;&gt;Time Zone Rules&lt;/a&gt;. The operating system limits the range of time and zone values.</source>
          <target state="translated">The argument &lt;var&gt;time&lt;/var&gt; , if given, specifies a time to format, instead of the current time. The optional argument &lt;var&gt;zone&lt;/var&gt; defaults to the current time zone rule. See &lt;a href=&quot;time-zone-rules#Time-Zone-Rules&quot;&gt;Time Zone Rules&lt;/a&gt;. The operating system limits the range of time and zone values.</target>
        </trans-unit>
        <trans-unit id="67093ca62609112dce25a039485acdd340da0cbb" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;time&lt;/var&gt;, if given, specifies a time value to analyze instead of the current time. The optional argument &lt;var&gt;zone&lt;/var&gt; defaults to the current time zone rule. The operating system limits the range of time and zone values.</source>
          <target state="translated">The argument &lt;var&gt;time&lt;/var&gt; , if given, specifies a time value to analyze instead of the current time. The optional argument &lt;var&gt;zone&lt;/var&gt; defaults to the current time zone rule. The operating system limits the range of time and zone values.</target>
        </trans-unit>
        <trans-unit id="a166fde7744586ad3de5035db801908eb626de30" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;value&lt;/var&gt; is used as the value to return from that &lt;code&gt;catch&lt;/code&gt;.</source>
          <target state="translated">The argument &lt;var&gt;value&lt;/var&gt; is used as the value to return from that &lt;code&gt;catch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="476196cad18d685889ec67ed735c3184bfb0b98c" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;var&lt;/var&gt; is a variable. &lt;code&gt;condition-case&lt;/code&gt; does not bind this variable when executing the &lt;var&gt;protected-form&lt;/var&gt;, only when it handles an error. At that time, it binds &lt;var&gt;var&lt;/var&gt; locally to an &lt;em&gt;error description&lt;/em&gt;, which is a list giving the particulars of the error. The error description has the form &lt;code&gt;(&lt;var&gt;error-symbol&lt;/var&gt;
. &lt;var&gt;data&lt;/var&gt;)&lt;/code&gt;. The handler can refer to this list to decide what to do. For example, if the error is for failure opening a file, the file name is the second element of &lt;var&gt;data&lt;/var&gt;&amp;mdash;the third element of the error description.</source>
          <target state="translated">The argument &lt;var&gt;var&lt;/var&gt; is a variable. &lt;code&gt;condition-case&lt;/code&gt; does not bind this variable when executing the &lt;var&gt;protected-form&lt;/var&gt; , only when it handles an error. At that time, it binds &lt;var&gt;var&lt;/var&gt; locally to an &lt;em&gt;error description&lt;/em&gt;, which is a list giving the particulars of the error. The error description has the form &lt;code&gt;(&lt;var&gt;error-symbol&lt;/var&gt; . &lt;var&gt;data&lt;/var&gt;)&lt;/code&gt; . The handler can refer to this list to decide what to do. For example, if the error is for failure opening a file, the file name is the second element of &lt;var&gt;data&lt;/var&gt; &amp;mdash;the third element of the error description.</target>
        </trans-unit>
        <trans-unit id="e0fe210e6f1d01348600177fc40d83de22fa4e2e" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;visible-ok&lt;/var&gt; is handled as with &lt;code&gt;other-buffer&lt;/code&gt;, see above. If no suitable buffer can be found, the buffer</source>
          <target state="translated">The argument &lt;var&gt;visible-ok&lt;/var&gt; is handled as with &lt;code&gt;other-buffer&lt;/code&gt; , see above. If no suitable buffer can be found, the buffer</target>
        </trans-unit>
        <trans-unit id="72848c5e5c01bccb49e9d85b256bded1595df4a4" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;when&lt;/var&gt; should be a string indicating when the function was first made obsolete&amp;mdash;for example, a date or a release number.</source>
          <target state="translated">The argument &lt;var&gt;when&lt;/var&gt; should be a string indicating when the function was first made obsolete&amp;mdash;for example, a date or a release number.</target>
        </trans-unit>
        <trans-unit id="981c67516263983386e948611e806a1396a3f68a" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;width&lt;/var&gt; is the number of columns available to display text; this affects handling of continuation lines. &lt;code&gt;nil&lt;/code&gt; means the actual number of usable text columns in the window, which is equivalent to the value returned by &lt;code&gt;(window-width window)&lt;/code&gt;.</source>
          <target state="translated">The argument &lt;var&gt;width&lt;/var&gt; is the number of columns available to display text; this affects handling of continuation lines. &lt;code&gt;nil&lt;/code&gt; means the actual number of usable text columns in the window, which is equivalent to the value returned by &lt;code&gt;(window-width window)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a911ba7619afc0fecdef0edde89f01cbdc7950a1" translate="yes" xml:space="preserve">
          <source>The argument is a single, highest-level form in a definition. This is like &lt;code&gt;def-body&lt;/code&gt;, except it is used to match a single form rather than a list of forms. As a special case, &lt;code&gt;def-form&lt;/code&gt; also means that tracing information is not output when the form is executed. See the &lt;code&gt;interactive&lt;/code&gt; example.</source>
          <target state="translated">The argument is a single, highest-level form in a definition. This is like &lt;code&gt;def-body&lt;/code&gt; , except it is used to match a single form rather than a list of forms. As a special case, &lt;code&gt;def-form&lt;/code&gt; also means that tracing information is not output when the form is executed. See the &lt;code&gt;interactive&lt;/code&gt; example.</target>
        </trans-unit>
        <trans-unit id="7dda82e624c89291ddeeb7176faeb74ec8ff9fc4" translate="yes" xml:space="preserve">
          <source>The argument is the body of code in a definition. This is like &lt;code&gt;body&lt;/code&gt;, described above, but a definition body must be instrumented with a different Edebug call that looks up information associated with the definition. Use &lt;code&gt;def-body&lt;/code&gt; for the highest level list of forms within the definition.</source>
          <target state="translated">The argument is the body of code in a definition. This is like &lt;code&gt;body&lt;/code&gt; , described above, but a definition body must be instrumented with a different Edebug call that looks up information associated with the definition. Use &lt;code&gt;def-body&lt;/code&gt; for the highest level list of forms within the definition.</target>
        </trans-unit>
        <trans-unit id="7fc1b12a3b1d895f282732e4c2ebfaebd02311cb" translate="yes" xml:space="preserve">
          <source>The argument must be a cons cell whose &lt;code&gt;car&lt;/code&gt; is &lt;code&gt;eql&lt;/code&gt; to &lt;var&gt;object&lt;/var&gt;.</source>
          <target state="translated">The argument must be a cons cell whose &lt;code&gt;car&lt;/code&gt; is &lt;code&gt;eql&lt;/code&gt; to &lt;var&gt;object&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="7dd03bfcc4c0687119a09e247b34a10daf413382" translate="yes" xml:space="preserve">
          <source>The argument must be an instance of a class named &lt;var&gt;struct-type&lt;/var&gt; defined with &lt;code&gt;cl-defstruct&lt;/code&gt; (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/cl/Structures.html#Structures&quot;&gt;Structures&lt;/a&gt; in</source>
          <target state="translated">The argument must be an instance of a class named &lt;var&gt;struct-type&lt;/var&gt; defined with &lt;code&gt;cl-defstruct&lt;/code&gt; (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/cl/Structures.html#Structures&quot;&gt;Structures&lt;/a&gt; in</target>
        </trans-unit>
        <trans-unit id="6a016fb8d81e2ab32819f60e0f432fb6a3d9fce9" translate="yes" xml:space="preserve">
          <source>The argument should be a symbol named &lt;var&gt;string&lt;/var&gt;. This specification is equivalent to the quoted symbol, &lt;code&gt;'&lt;var&gt;symbol&lt;/var&gt;&lt;/code&gt;, where the name of &lt;var&gt;symbol&lt;/var&gt; is the &lt;var&gt;string&lt;/var&gt;, but the string form is preferred.</source>
          <target state="translated">The argument should be a symbol named &lt;var&gt;string&lt;/var&gt; . This specification is equivalent to the quoted symbol, &lt;code&gt;'&lt;var&gt;symbol&lt;/var&gt;&lt;/code&gt; , where the name of &lt;var&gt;symbol&lt;/var&gt; is the &lt;var&gt;string&lt;/var&gt; , but the string form is preferred.</target>
        </trans-unit>
        <trans-unit id="6d235a75502a298491d0f8f47584c491581700a2" translate="yes" xml:space="preserve">
          <source>The argument should be a vector whose elements must match the &lt;var&gt;elements&lt;/var&gt; in the specification. See the backquote example.</source>
          <target state="translated">The argument should be a vector whose elements must match the &lt;var&gt;elements&lt;/var&gt; in the specification. See the backquote example.</target>
        </trans-unit>
        <trans-unit id="bac3fcdc65f408fcb049e05f8e1cc77394dd852a" translate="yes" xml:space="preserve">
          <source>The argument to &lt;code&gt;byte-compile&lt;/code&gt; can also be a &lt;code&gt;lambda&lt;/code&gt; expression. In that case, the function returns the corresponding compiled code but does not store it anywhere.</source>
          <target state="translated">The argument to &lt;code&gt;byte-compile&lt;/code&gt; can also be a &lt;code&gt;lambda&lt;/code&gt; expression. In that case, the function returns the corresponding compiled code but does not store it anywhere.</target>
        </trans-unit>
        <trans-unit id="65872c371b9193c99790a2d59431ec0002cb765f" translate="yes" xml:space="preserve">
          <source>The argument to the &lt;code&gt;:options&lt;/code&gt; keywords should be a list of specifications for reasonable keys in the alist. Ordinarily, they are simply atoms, which stand for themselves. For example:</source>
          <target state="translated">The argument to the &lt;code&gt;:options&lt;/code&gt; keywords should be a list of specifications for reasonable keys in the alist. Ordinarily, they are simply atoms, which stand for themselves. For example:</target>
        </trans-unit>
        <trans-unit id="39a320a7e7ff203aa87f177be24c8afee00608cf" translate="yes" xml:space="preserve">
          <source>The argument, a symbol, is the name of an argument of the defining form. However, lambda-list keywords (symbols starting with &amp;lsquo;</source>
          <target state="translated">The argument, a symbol, is the name of an argument of the defining form. However, lambda-list keywords (symbols starting with &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="04bfbbc1720d1306603968788629498a7b7b6c73" translate="yes" xml:space="preserve">
          <source>The argument, a symbol, is the name of the defining form.</source>
          <target state="translated">The argument, a symbol, is the name of the defining form.</target>
        </trans-unit>
        <trans-unit id="a1265c068f2d370b4c89f1bdd6a871f3831d14cc" translate="yes" xml:space="preserve">
          <source>The arguments &lt;code&gt;:before&lt;/code&gt; and &lt;code&gt;:around&lt;/code&gt; used in the above examples specify how the two functions are composed, since there are many different ways to do it. The added function is also called a piece of &lt;em&gt;advice&lt;/em&gt;.</source>
          <target state="translated">The arguments &lt;code&gt;:before&lt;/code&gt; and &lt;code&gt;:around&lt;/code&gt; used in the above examples specify how the two functions are composed, since there are many different ways to do it. The added function is also called a piece of &lt;em&gt;advice&lt;/em&gt;.</target>
        </trans-unit>
        <trans-unit id="e775df69264dec0b29fe83b2750522c9ef3d6768" translate="yes" xml:space="preserve">
          <source>The arguments &lt;code&gt;from&lt;/code&gt;, &lt;code&gt;to&lt;/code&gt;, and &lt;code&gt;do&lt;/code&gt; in this macro are syntactic sugar; they are entirely ignored. The idea is that you will write noise words (such as &lt;code&gt;from&lt;/code&gt;, &lt;code&gt;to&lt;/code&gt;, and &lt;code&gt;do&lt;/code&gt;) in those positions in the macro call.</source>
          <target state="translated">The arguments &lt;code&gt;from&lt;/code&gt; , &lt;code&gt;to&lt;/code&gt; , and &lt;code&gt;do&lt;/code&gt; in this macro are syntactic sugar; they are entirely ignored. The idea is that you will write noise words (such as &lt;code&gt;from&lt;/code&gt; , &lt;code&gt;to&lt;/code&gt; , and &lt;code&gt;do&lt;/code&gt; ) in those positions in the macro call.</target>
        </trans-unit>
        <trans-unit id="ab831da1503b01e34a6cae5b52e070de7ee3e57d" translate="yes" xml:space="preserve">
          <source>The arguments &lt;var&gt;args&lt;/var&gt; are a list of keyword/argument pairs. Omitting a keyword is always equivalent to specifying it with value &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">The arguments &lt;var&gt;args&lt;/var&gt; are a list of keyword/argument pairs. Omitting a keyword is always equivalent to specifying it with value &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af5eede62c1d9440db74aefa6774703b63dee39b" translate="yes" xml:space="preserve">
          <source>The arguments &lt;var&gt;args&lt;/var&gt; are a list of keyword/argument pairs. Omitting a keyword is always equivalent to specifying it with value &lt;code&gt;nil&lt;/code&gt;. Here are the meaningful keywords:</source>
          <target state="translated">The arguments &lt;var&gt;args&lt;/var&gt; are a list of keyword/argument pairs. Omitting a keyword is always equivalent to specifying it with value &lt;code&gt;nil&lt;/code&gt; . Here are the meaningful keywords:</target>
        </trans-unit>
        <trans-unit id="7d2a621488d57b7f6ddca20e096977bc70d24abb" translate="yes" xml:space="preserve">
          <source>The arguments &lt;var&gt;destination&lt;/var&gt; and &lt;var&gt;display&lt;/var&gt; control what to do with the output from the subprocess, and whether to update the display as it comes in. For details, see the description of &lt;code&gt;call-process&lt;/code&gt;, above. If &lt;var&gt;destination&lt;/var&gt; is the integer 0, &lt;code&gt;call-process-region&lt;/code&gt; discards the output and returns &lt;code&gt;nil&lt;/code&gt; immediately, without waiting for the subprocess to finish (this only works if asynchronous subprocesses are supported; i.e., not on MS-DOS).</source>
          <target state="translated">The arguments &lt;var&gt;destination&lt;/var&gt; and &lt;var&gt;display&lt;/var&gt; control what to do with the output from the subprocess, and whether to update the display as it comes in. For details, see the description of &lt;code&gt;call-process&lt;/code&gt; , above. If &lt;var&gt;destination&lt;/var&gt; is the integer 0, &lt;code&gt;call-process-region&lt;/code&gt; discards the output and returns &lt;code&gt;nil&lt;/code&gt; immediately, without waiting for the subprocess to finish (this only works if asynchronous subprocesses are supported; i.e., not on MS-DOS).</target>
        </trans-unit>
        <trans-unit id="64da8840c3ed49a60f1595d4cb5d5e86fba3d26e" translate="yes" xml:space="preserve">
          <source>The arguments &lt;var&gt;front-advance&lt;/var&gt; and &lt;var&gt;rear-advance&lt;/var&gt; specify the marker insertion type for the start of the overlay and for the end of the overlay, respectively. See &lt;a href=&quot;marker-insertion-types#Marker-Insertion-Types&quot;&gt;Marker Insertion Types&lt;/a&gt;. If they are both &lt;code&gt;nil&lt;/code&gt;, the default, then the overlay extends to include any text inserted at the beginning, but not text inserted at the end. If &lt;var&gt;front-advance&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, text inserted at the beginning of the overlay is excluded from the overlay. If &lt;var&gt;rear-advance&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, text inserted at the end of the overlay is included in the overlay.</source>
          <target state="translated">The arguments &lt;var&gt;front-advance&lt;/var&gt; and &lt;var&gt;rear-advance&lt;/var&gt; specify the marker insertion type for the start of the overlay and for the end of the overlay, respectively. See &lt;a href=&quot;marker-insertion-types#Marker-Insertion-Types&quot;&gt;Marker Insertion Types&lt;/a&gt;. If they are both &lt;code&gt;nil&lt;/code&gt; , the default, then the overlay extends to include any text inserted at the beginning, but not text inserted at the end. If &lt;var&gt;front-advance&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , text inserted at the beginning of the overlay is excluded from the overlay. If &lt;var&gt;rear-advance&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , text inserted at the end of the overlay is included in the overlay.</target>
        </trans-unit>
        <trans-unit id="97c844f62d367d7173221f3f8a509a2c63cee23c" translate="yes" xml:space="preserve">
          <source>The arguments &lt;var&gt;host&lt;/var&gt; and &lt;var&gt;service&lt;/var&gt; specify where to connect to; &lt;var&gt;host&lt;/var&gt; is the host name (a string), and &lt;var&gt;service&lt;/var&gt; is the name of a defined network service (a string) or a port number (an integer like &lt;code&gt;80&lt;/code&gt; or an integer string like &lt;code&gt;&quot;80&quot;&lt;/code&gt;).</source>
          <target state="translated">The arguments &lt;var&gt;host&lt;/var&gt; and &lt;var&gt;service&lt;/var&gt; specify where to connect to; &lt;var&gt;host&lt;/var&gt; is the host name (a string), and &lt;var&gt;service&lt;/var&gt; is the name of a defined network service (a string) or a port number (an integer like &lt;code&gt;80&lt;/code&gt; or an integer string like &lt;code&gt;&quot;80&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="34cdb521004558de19416e08fc21cef4475e568a" translate="yes" xml:space="preserve">
          <source>The arguments &lt;var&gt;min-value&lt;/var&gt; and &lt;var&gt;max-value&lt;/var&gt; should be numbers standing for the starting and final states of the operation. For instance, an operation that scans a buffer should set these to the results of &lt;code&gt;point-min&lt;/code&gt; and &lt;code&gt;point-max&lt;/code&gt; correspondingly. &lt;var&gt;max-value&lt;/var&gt; should be greater than &lt;var&gt;min-value&lt;/var&gt;.</source>
          <target state="translated">The arguments &lt;var&gt;min-value&lt;/var&gt; and &lt;var&gt;max-value&lt;/var&gt; should be numbers standing for the starting and final states of the operation. For instance, an operation that scans a buffer should set these to the results of &lt;code&gt;point-min&lt;/code&gt; and &lt;code&gt;point-max&lt;/code&gt; correspondingly. &lt;var&gt;max-value&lt;/var&gt; should be greater than &lt;var&gt;min-value&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="cff38d80b42f070246735699a0bac4bf679938b6" translate="yes" xml:space="preserve">
          <source>The arguments &lt;var&gt;minibuf&lt;/var&gt; and &lt;var&gt;all-frames&lt;/var&gt; have the same meanings as in the function &lt;code&gt;next-window&lt;/code&gt; (see &lt;a href=&quot;cyclic-window-ordering#Cyclic-Window-Ordering&quot;&gt;Cyclic Window Ordering&lt;/a&gt;). Note that the &lt;var&gt;all-frames&lt;/var&gt; argument does &lt;em&gt;not&lt;/em&gt; behave exactly like in &lt;code&gt;get-buffer-window&lt;/code&gt;.</source>
          <target state="translated">The arguments &lt;var&gt;minibuf&lt;/var&gt; and &lt;var&gt;all-frames&lt;/var&gt; have the same meanings as in the function &lt;code&gt;next-window&lt;/code&gt; (see &lt;a href=&quot;cyclic-window-ordering#Cyclic-Window-Ordering&quot;&gt;Cyclic Window Ordering&lt;/a&gt;). Note that the &lt;var&gt;all-frames&lt;/var&gt; argument does &lt;em&gt;not&lt;/em&gt; behave exactly like in &lt;code&gt;get-buffer-window&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="01d6b84175f7364145c82b076d43d4cd73606a88" translate="yes" xml:space="preserve">
          <source>The arguments &lt;var&gt;params&lt;/var&gt; are specified as keyword/value pairs. All the parameters are optional, but if no parameters are specified, the function will do nothing and return &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">The arguments &lt;var&gt;params&lt;/var&gt; are specified as keyword/value pairs. All the parameters are optional, but if no parameters are specified, the function will do nothing and return &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc7481fa7deb6b4399c57ef9a83c397322635635" translate="yes" xml:space="preserve">
          <source>The arguments &lt;var&gt;seconds&lt;/var&gt; and &lt;var&gt;millisec&lt;/var&gt; let you specify timeout periods. The former specifies a period measured in seconds and the latter specifies one measured in milliseconds. The two time periods thus specified are added together, and &lt;code&gt;accept-process-output&lt;/code&gt; returns after that much time, even if there is no subprocess output.</source>
          <target state="translated">The arguments &lt;var&gt;seconds&lt;/var&gt; and &lt;var&gt;millisec&lt;/var&gt; let you specify timeout periods. The former specifies a period measured in seconds and the latter specifies one measured in milliseconds. The two time periods thus specified are added together, and &lt;code&gt;accept-process-output&lt;/code&gt; returns after that much time, even if there is no subprocess output.</target>
        </trans-unit>
        <trans-unit id="40b8cf91d8ad0d522899259a939f943a2be85226" translate="yes" xml:space="preserve">
          <source>The arguments after the protected form are handlers. Each handler lists one or more &lt;em&gt;condition names&lt;/em&gt; (which are symbols) to specify which errors it will handle. The error symbol specified when an error is signaled also defines a list of condition names. A handler applies to an error if they have any condition names in common. In the example above, there is one handler, and it specifies one condition name, &lt;code&gt;error&lt;/code&gt;, which covers all errors.</source>
          <target state="translated">The arguments after the protected form are handlers. Each handler lists one or more &lt;em&gt;condition names&lt;/em&gt; (which are symbols) to specify which errors it will handle. The error symbol specified when an error is signaled also defines a list of condition names. A handler applies to an error if they have any condition names in common. In the example above, there is one handler, and it specifies one condition name, &lt;code&gt;error&lt;/code&gt; , which covers all errors.</target>
        </trans-unit>
        <trans-unit id="9212152c0a1d54415d1a64052fa71d9a41f7a676" translate="yes" xml:space="preserve">
          <source>The arguments and the forms in each argument are processed in order, and if a previous form already translates &lt;var&gt;to&lt;/var&gt; to some other character, say &lt;var&gt;to-alt&lt;/var&gt;, &lt;var&gt;from&lt;/var&gt; is also translated to &lt;var&gt;to-alt&lt;/var&gt;.</source>
          <target state="translated">인수 각 인자의 형태가 순서대로 처리하고, 이전의 형태로 이미 변환되어있는 경우 &lt;var&gt;to&lt;/var&gt; 다른 캐릭터라고 &lt;var&gt;to-alt&lt;/var&gt; , &lt;var&gt;from&lt;/var&gt; 에도 번역 &lt;var&gt;to-alt&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="814b87943ef37ce98ee6242e77f736c9eb2fb447" translate="yes" xml:space="preserve">
          <source>The arguments are handled in almost the same way as for &lt;code&gt;call-process&lt;/code&gt;, with the following differences:</source>
          <target state="translated">인수는 &lt;code&gt;call-process&lt;/code&gt; 와 거의 동일한 방식으로 처리 되지만 다음과 같은 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="fcce85c9773f3a972b86865cc6636258080a75e9" translate="yes" xml:space="preserve">
          <source>The array (either a string or a vector) is a keyboard macro. The events used so far in the lookup form a complete key, and the array is its binding. See &lt;a href=&quot;keyboard-macros#Keyboard-Macros&quot;&gt;Keyboard Macros&lt;/a&gt;, for more information.</source>
          <target state="translated">배열 (문자열 또는 벡터)은 키보드 매크로입니다. 지금까지 조회에서 사용 된 이벤트는 완전한 키를 형성하고 배열은 바인딩입니다. 자세한 내용은 &lt;a href=&quot;keyboard-macros#Keyboard-Macros&quot;&gt;키보드 매크로&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="963886fcccc037b6f38c2a2596d1c5be6615d83d" translate="yes" xml:space="preserve">
          <source>The array type is a subset of the sequence type, and contains the string type, the vector type, the bool-vector type, and the char-table type.</source>
          <target state="translated">배열 유형은 시퀀스 유형의 하위 집합이며 문자열 유형, 벡터 유형, bool-vector 유형 및 char-table 유형을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="0f5f28eb8e784010e8d3a08cf4b1d401f6ae42af" translate="yes" xml:space="preserve">
          <source>The ascent and descent of this font. The sum of these two numbers gives the font height.</source>
          <target state="translated">이 글꼴의 상승 및 하강입니다. 이 두 숫자의 합은 글꼴 높이를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7e216dedda9faf32fa78cf8ce88437f4d994fd23" translate="yes" xml:space="preserve">
          <source>The ascent and descent of this font. The sum of these two numbers should be equal to the value of &lt;var&gt;height&lt;/var&gt; above.</source>
          <target state="translated">이 글꼴의 상승 및 하강입니다. 이 두 숫자의 합은 위 의 &lt;var&gt;height&lt;/var&gt; 값과 같아야합니다 .</target>
        </trans-unit>
        <trans-unit id="d2192054ba53475e5b125700aa3f3380335e17a2" translate="yes" xml:space="preserve">
          <source>The associated buffer of the process.</source>
          <target state="translated">프로세스의 연관된 버퍼입니다.</target>
        </trans-unit>
        <trans-unit id="4e9bf1b1a4172ecf859689db8cd8cd68a80b729f" translate="yes" xml:space="preserve">
          <source>The associated value is the process buffer.</source>
          <target state="translated">연관된 값은 프로세스 버퍼입니다.</target>
        </trans-unit>
        <trans-unit id="a2b38e01be3ffa82581d5a54dfe09f0aeda1f048" translate="yes" xml:space="preserve">
          <source>The associated value is the process filter function. See &lt;a href=&quot;filter-functions#Filter-Functions&quot;&gt;Filter Functions&lt;/a&gt;.</source>
          <target state="translated">연관된 값은 프로세스 필터 기능입니다. &lt;a href=&quot;filter-functions#Filter-Functions&quot;&gt;필터 함수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="48d7a92d54184811d7707356f98484aee137939d" translate="yes" xml:space="preserve">
          <source>The associated value is the process sentinel function. See &lt;a href=&quot;sentinels#Sentinels&quot;&gt;Sentinels&lt;/a&gt;.</source>
          <target state="translated">연관된 값은 프로세스 센티넬 함수입니다. &lt;a href=&quot;sentinels#Sentinels&quot;&gt;Sentinels를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="95db3e2086e53bdd69e52a5a8427bb4c66aa1f51" translate="yes" xml:space="preserve">
          <source>The association list describing the buffer-local variable bindings of this buffer, not including the built-in buffer-local bindings that have special slots in the buffer object. (Those slots are omitted from this table.) See &lt;a href=&quot;buffer_002dlocal-variables#Buffer_002dLocal-Variables&quot;&gt;Buffer-Local Variables&lt;/a&gt;.</source>
          <target state="translated">이 버퍼의 버퍼 로컬 변수 바인딩을 설명하는 연관 목록입니다. 버퍼 오브젝트에 특수 슬롯이있는 내장 버퍼 로컬 바인딩은 포함되지 않습니다. (이러한 슬롯은이 표에서 생략되었습니다.) &lt;a href=&quot;buffer_002dlocal-variables#Buffer_002dLocal-Variables&quot;&gt;버퍼 로컬 변수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cf7184822d397bb6098b38e6c59e1389ef5652a4" translate="yes" xml:space="preserve">
          <source>The attributes &lt;code&gt;:weight&lt;/code&gt; and &lt;code&gt;:width&lt;/code&gt; have symbolic values in a range centered around &lt;code&gt;normal&lt;/code&gt;. Matches that are more extreme (farther from &lt;code&gt;normal&lt;/code&gt;) are somewhat preferred to matches that are less extreme (closer to &lt;code&gt;normal&lt;/code&gt;); this is designed to ensure that non-normal faces contrast with normal ones, whenever possible.</source>
          <target state="translated">&lt;code&gt;:weight&lt;/code&gt; 및 &lt;code&gt;:width&lt;/code&gt; 속성 은 &lt;code&gt;normal&lt;/code&gt; 을 중심으로하는 범위의 기호 값을 갖습니다 . 더 극단적 인 ( &lt;code&gt;normal&lt;/code&gt; 에서 멀어지는 ) 일치가 덜 극단적 인 ( &lt;code&gt;normal&lt;/code&gt; 더 가까운) 일치보다 다소 선호됩니다 . 이것은 가능하면 비정규면이 정상면과 대조되도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="0abb4a0617aec66a698231d1cbca2e1c3a48e616" translate="yes" xml:space="preserve">
          <source>The attributes of remote files can be cached for better performance. If they are changed outside of Emacs&amp;rsquo;s control, the cached values become invalid, and must be reread.</source>
          <target state="translated">더 나은 성능을 위해 원격 파일의 속성을 캐시 할 수 있습니다. Emacs의 제어 범위 밖에서 변경되면 캐시 된 값은 무효가되며 다시 읽어야합니다.</target>
        </trans-unit>
        <trans-unit id="23608b582d3ca9bf4c877cee9d51711a0c0a0644" translate="yes" xml:space="preserve">
          <source>The autoloaded file usually contains other definitions and may require or provide one or more features. If the file is not completely loaded (due to an error in the evaluation of its contents), any function definitions or &lt;code&gt;provide&lt;/code&gt; calls that occurred during the load are undone. This is to ensure that the next attempt to call any function autoloading from this file will try again to load the file. If not for this, then some of the functions in the file might be defined by the aborted load, but fail to work properly for the lack of certain subroutines not loaded successfully because they come later in the file.</source>
          <target state="translated">자동로드 된 파일은 일반적으로 다른 정의를 포함하며 하나 이상의 기능을 필요로하거나 제공 할 수 있습니다. 파일이 완전히로드되지 않은 경우 (내용 평가 오류로 인해), 로드 중에 발생한 함수 정의 또는 &lt;code&gt;provide&lt;/code&gt; 호출이 실행 취소됩니다. 이는이 파일에서 자동로드되는 함수를 호출하려는 다음 시도가 파일로드를 다시 시도하도록하기위한 것입니다. 그렇지 않은 경우 파일의 일부 함수는 중단 된로드에 의해 정의 될 수 있지만 파일에서 나중에 제공되기 때문에 성공적으로로드되지 않은 특정 서브 루틴이 부족하여 제대로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3c1146df3835709f3489eed6acaaa81381b10221" translate="yes" xml:space="preserve">
          <source>The average width of the font characters. If this is zero, Emacs uses the value of &lt;var&gt;space-width&lt;/var&gt; instead, when it calculates text layout on display.</source>
          <target state="translated">글꼴 문자의 평균 너비입니다. 이것이 0이면 Emacs는 디스플레이에 텍스트 레이아웃을 계산할 때 대신 &lt;var&gt;space-width&lt;/var&gt; 값을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="704160cb67753b1d63800eb641605e7fceeb4095" translate="yes" xml:space="preserve">
          <source>The background stipple, a bitmap.</source>
          <target state="translated">배경 점각, 비트 맵.</target>
        </trans-unit>
        <trans-unit id="4dfd0f8fb905e11c58077fc23caa09ad33e261d1" translate="yes" xml:space="preserve">
          <source>The backquote-style pattern is more concise, resembles the structure of &lt;var&gt;expval&lt;/var&gt;, and avoids binding &lt;code&gt;ls&lt;/code&gt;.</source>
          <target state="translated">역 따옴표 스타일 패턴은 더 간결하고 &lt;var&gt;expval&lt;/var&gt; 의 구조와 유사하며 &lt;code&gt;ls&lt;/code&gt; 바인딩을 피 합니다.</target>
        </trans-unit>
        <trans-unit id="79f62846ef32f37cfacd61a3173063b8365ba096" translate="yes" xml:space="preserve">
          <source>The backslash and newline immediately following the double-quote are a convention used only in the preloaded uncompiled Lisp files such as</source>
          <target state="translated">큰 따옴표 바로 뒤의 백 슬래시와 줄 바꿈은 다음과 같이 미리로드 된 컴파일되지 않은 Lisp 파일에서만 사용되는 규칙입니다.</target>
        </trans-unit>
        <trans-unit id="de1dd4b617fb02852473458167ad4aff4326193a" translate="yes" xml:space="preserve">
          <source>The backtrace buffer is killed automatically when you continue execution.</source>
          <target state="translated">역 추적 버퍼는 실행을 계속하면 자동으로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="ddf6b6a15b9c301145e71531518322c635178411" translate="yes" xml:space="preserve">
          <source>The backtrace buffer is read-only and uses a special major mode, Debugger mode, in which letters are defined as debugger commands. The usual Emacs editing commands are available; thus, you can switch windows to examine the buffer that was being edited at the time of the error, switch buffers, visit files, or do any other sort of editing. However, the debugger is a recursive editing level (see &lt;a href=&quot;recursive-editing#Recursive-Editing&quot;&gt;Recursive Editing&lt;/a&gt;) and it is wise to go back to the backtrace buffer and exit the debugger (with the</source>
          <target state="translated">역 추적 버퍼는 읽기 전용이며 특수 주 모드 인 디버거 모드를 사용합니다. 여기서 문자는 디버거 명령으로 정의됩니다. 일반적인 Emacs 편집 명령을 사용할 수 있습니다. 따라서 창을 전환하여 오류 발생시 편집 중이던 버퍼를 검사하거나 버퍼를 전환하거나 파일을 방문하거나 다른 종류의 편집을 수행 할 수 있습니다. 그러나 디버거는 재귀 편집 수준 ( &lt;a href=&quot;recursive-editing#Recursive-Editing&quot;&gt;재귀 편집&lt;/a&gt; 참조 )이므로 역 추적 버퍼로 돌아가 디버거를 종료하는 것이 좋습니다 (</target>
        </trans-unit>
        <trans-unit id="23b99814c4ea22e4979913b8fb0652d765957bab" translate="yes" xml:space="preserve">
          <source>The backtrace buffer shows you the functions that are executing and their argument values. When a backtrace buffer is created, it shows each stack frame on one, possibly very long, line. (A stack frame is the place where the Lisp interpreter records information about a particular invocation of a function.) The most recently called function will be at the top.</source>
          <target state="translated">역 추적 버퍼는 실행중인 함수와 해당 인수 값을 보여줍니다. 역 추적 버퍼가 생성되면 각 스택 프레임을 매우 긴 한 줄에 표시합니다. (스택 프레임은 Lisp 인터프리터가 함수의 특정 호출에 대한 정보를 기록하는 위치입니다.) 가장 최근에 호출 된 함수가 맨 위에 있습니다.</target>
        </trans-unit>
        <trans-unit id="8595c07de42c7db906c6a77faaf01296ee5350c3" translate="yes" xml:space="preserve">
          <source>The basic Emacs command for clicking on links is</source>
          <target state="translated">링크를 클릭하기위한 기본 Emacs 명령은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="23904938ca5f99404695e7880a93c552b6870965" translate="yes" xml:space="preserve">
          <source>The basic concepts of Emacs Lisp packages.</source>
          <target state="translated">Emacs Lisp 패키지의 기본 개념.</target>
        </trans-unit>
        <trans-unit id="dd326d0a3d35091e15c16c7f337b0ac66431cc24" translate="yes" xml:space="preserve">
          <source>The basic function for creating network connections and network servers is &lt;code&gt;make-network-process&lt;/code&gt;. It can do either of those jobs, depending on the arguments you give it.</source>
          <target state="translated">네트워크 연결 및 네트워크 서버를 만드는 기본 기능은 &lt;code&gt;make-network-process&lt;/code&gt; 입니다. 그것은 당신이 제공하는 인수에 따라 이러한 작업 중 하나를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d950bb62899f50881bf10776ee448a653788f392" translate="yes" xml:space="preserve">
          <source>The basic object of editing.</source>
          <target state="translated">편집의 기본 개체입니다.</target>
        </trans-unit>
        <trans-unit id="f5a66fbf4e523bf88c788fc3850d6087dd15ab3a" translate="yes" xml:space="preserve">
          <source>The basic problem.</source>
          <target state="translated">기본적인 문제.</target>
        </trans-unit>
        <trans-unit id="181c1d01d991db4a55dd6d74f5a790be57e3b4e0" translate="yes" xml:space="preserve">
          <source>The basic textual scrolling functions are &lt;code&gt;scroll-up&lt;/code&gt; (which scrolls forward) and &lt;code&gt;scroll-down&lt;/code&gt; (which scrolls backward). In these function names, &amp;ldquo;up&amp;rdquo; and &amp;ldquo;down&amp;rdquo; refer to the direction of motion of the buffer text relative to the window. Imagine that the text is written on a long roll of paper and that the scrolling commands move the paper up and down. Thus, if you are looking at the middle of a buffer and repeatedly call &lt;code&gt;scroll-down&lt;/code&gt;, you will eventually see the beginning of the buffer.</source>
          <target state="translated">기본 텍스트 스크롤 기능은 &lt;code&gt;scroll-up&lt;/code&gt; (앞으로 스크롤) 및 &lt;code&gt;scroll-down&lt;/code&gt; (뒤로 스크롤)입니다. 이 함수 이름에서 &quot;위&quot;및 &quot;아래&quot;는 창에 대한 버퍼 텍스트의 움직임 방향을 나타냅니다. 텍스트가 긴 종이 롤에 쓰여지고 스크롤 명령이 종이를 위아래로 이동한다고 상상해보십시오. 따라서 버퍼의 중간을보고 &lt;code&gt;scroll-down&lt;/code&gt; 을 반복적으로 호출 하면 결국 버퍼의 시작 부분을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4701282aa39cd5d0eb4d386c2b17738d17c6095" translate="yes" xml:space="preserve">
          <source>The basis for &lt;code&gt;symbol-file&lt;/code&gt; is the data in the variable &lt;code&gt;load-history&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;symbol-file&lt;/code&gt; 의 기본 은 변수 &lt;code&gt;load-history&lt;/code&gt; 의 데이터입니다 .</target>
        </trans-unit>
        <trans-unit id="2a5348bdb54f46d592e5625886bbc8814fd8b74f" translate="yes" xml:space="preserve">
          <source>The behavior can be fixed by making a new parent window when splitting &lt;var&gt;W2&lt;/var&gt;. The variable described next allows that to be done.</source>
          <target state="translated">&lt;var&gt;W2&lt;/var&gt; 를 분할 할 때 새 부모 창을 만들어 동작을 수정할 수 있습니다 . 다음에 설명하는 변수를 사용하면이를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64b48110852054851530f6c1baded1e70feabdf3" translate="yes" xml:space="preserve">
          <source>The behavior is also controlled by &lt;var&gt;alist&lt;/var&gt; entries for &lt;code&gt;inhibit-same-window&lt;/code&gt;, &lt;code&gt;reusable-frames&lt;/code&gt; and &lt;code&gt;inhibit-switch-frame&lt;/code&gt;, like &lt;code&gt;display-buffer-reuse-window&lt;/code&gt; does.</source>
          <target state="translated">이 동작은 &lt;code&gt;display-buffer-reuse-window&lt;/code&gt; 가하는 것처럼 &lt;var&gt;alist&lt;/var&gt; &lt;code&gt;inhibit-same-window&lt;/code&gt; , &lt;code&gt;reusable-frames&lt;/code&gt; 및 &lt;code&gt;inhibit-switch-frame&lt;/code&gt; -switch-frame에 대한 alist 항목에 의해 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="25ff2d06be08150ca72615f6107e00c6cbe0b1b1" translate="yes" xml:space="preserve">
          <source>The behavior of &lt;code&gt;display-buffer&lt;/code&gt; is highly customizable. To understand how customizations are used in practice, you may wish to study examples illustrating the order of precedence which &lt;code&gt;display-buffer&lt;/code&gt; uses to call action functions (see &lt;a href=&quot;precedence-of-action-functions#Precedence-of-Action-Functions&quot;&gt;Precedence of Action Functions&lt;/a&gt;). To avoid conflicts between Lisp programs calling &lt;code&gt;display-buffer&lt;/code&gt; and user customizations of its behavior, it may make sense to follow a number of guidelines which are sketched in the final part of this section (see &lt;a href=&quot;the-zen-of-buffer-display#The-Zen-of-Buffer-Display&quot;&gt;The Zen of Buffer Display&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;display-buffer&lt;/code&gt; 의 동작은 사용자 정의가 가능합니다. 사용자 정의가 실제로 어떻게 사용되는지 이해하려면 &lt;code&gt;display-buffer&lt;/code&gt; 가 작업 함수를 호출하는 데 사용하는 우선 순위를 보여주는 예제를 연구 할 수 있습니다 (작업 함수의 &lt;a href=&quot;precedence-of-action-functions#Precedence-of-Action-Functions&quot;&gt;우선 순위&lt;/a&gt; 참조 ). &lt;code&gt;display-buffer&lt;/code&gt; 호출하는 Lisp 프로그램 과 그 동작의 사용자 사용자 지정 간의 충돌을 방지하려면 이 섹션의 마지막 부분에 설명 된 여러 지침을 따르는 것이 좋습니다 ( &lt;a href=&quot;the-zen-of-buffer-display#The-Zen-of-Buffer-Display&quot;&gt;The Zen of Buffer Display 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="48fe4299049d7c93ed4a533dc27f43e4ebb09779" translate="yes" xml:space="preserve">
          <source>The behavior of &lt;code&gt;fit-frame-to-buffer&lt;/code&gt; can be controlled with the help of the two options listed next.</source>
          <target state="translated">&lt;code&gt;fit-frame-to-buffer&lt;/code&gt; 동작은 다음에 나열된 두 가지 옵션을 사용하여 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14d6ad7c7b1496920e84cec590095837471103e0" translate="yes" xml:space="preserve">
          <source>The behavior of &lt;code&gt;parse-partial-sexp&lt;/code&gt; is also affected by &lt;code&gt;parse-sexp-lookup-properties&lt;/code&gt; (see &lt;a href=&quot;syntax-properties#Syntax-Properties&quot;&gt;Syntax Properties&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;parse-partial-sexp&lt;/code&gt; 의 동작은 parse- &lt;code&gt;parse-sexp-lookup-properties&lt;/code&gt; 영향도받습니다 ( &lt;a href=&quot;syntax-properties#Syntax-Properties&quot;&gt;구문 속성&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="f4c9653c1321ba597070b3a8bcef63917fd4713f" translate="yes" xml:space="preserve">
          <source>The behavior of buffer display actions (see &lt;a href=&quot;choosing-window#Choosing-Window&quot;&gt;Choosing Window&lt;/a&gt;) can be further modified by the following user options.</source>
          <target state="translated">버퍼 표시 동작의 동작 ( &lt;a href=&quot;choosing-window#Choosing-Window&quot;&gt;창 선택&lt;/a&gt; 참조 )은 다음 사용자 옵션으로 추가로 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af430c0aab9b6a6a7fdfe43e9d585a9057ba6897" translate="yes" xml:space="preserve">
          <source>The behavior of child frames deviates from that of top-level frames in a number of other ways as well. Here we sketch a few of them:</source>
          <target state="translated">자식 프레임의 동작은 다른 여러 가지면에서 최상위 프레임의 동작과 다릅니다. 여기에서 몇 가지를 스케치합니다.</target>
        </trans-unit>
        <trans-unit id="b740a83bb87c1094d716f669539562dedcf7a073" translate="yes" xml:space="preserve">
          <source>The behavior of this function may be altered by the window parameters of &lt;var&gt;window&lt;/var&gt;, so long as the variable &lt;code&gt;ignore-window-parameters&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;. If the value of the &lt;code&gt;delete-other-windows&lt;/code&gt; window parameter is &lt;code&gt;t&lt;/code&gt;, this function ignores all other window parameters. Otherwise, if the value of the &lt;code&gt;delete-other-windows&lt;/code&gt; window parameter is a function, that function is called with the argument &lt;var&gt;window&lt;/var&gt;, in lieu of the usual action of &lt;code&gt;delete-other-windows&lt;/code&gt;. See &lt;a href=&quot;window-parameters#Window-Parameters&quot;&gt;Window Parameters&lt;/a&gt;.</source>
          <target state="translated">이 기능의 동작의 윈도우 파라미터가 변경 될 수있다 &lt;var&gt;window&lt;/var&gt; 오랫동안 변수로서 &lt;code&gt;ignore-window-parameters&lt;/code&gt; 이다 &lt;code&gt;nil&lt;/code&gt; . 의 값 경우 &lt;code&gt;delete-other-windows&lt;/code&gt; 창 매개 변수가 &lt;code&gt;t&lt;/code&gt; ,이 기능은 다른 모든 창 매개 변수를 무시합니다. 그렇지 않으면 &lt;code&gt;delete-other-windows&lt;/code&gt; window 매개 변수의 값이 함수이면 &lt;code&gt;delete-other-windows&lt;/code&gt; 의 일반적인 작업 대신 &lt;var&gt;window&lt;/var&gt; 인수와 함께 해당 함수가 호출됩니다 . &lt;a href=&quot;window-parameters#Window-Parameters&quot;&gt;창 매개 변수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4f60ec1dc913f2d4aba64531e32d867d8e2f6ecb" translate="yes" xml:space="preserve">
          <source>The behavior of this function may be altered by the window parameters of &lt;var&gt;window&lt;/var&gt;, so long as the variable &lt;code&gt;ignore-window-parameters&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;. If the value of the &lt;code&gt;delete-window&lt;/code&gt; window parameter is &lt;code&gt;t&lt;/code&gt;, this function ignores all other window parameters. Otherwise, if the value of the &lt;code&gt;delete-window&lt;/code&gt; window parameter is a function, that function is called with the argument &lt;var&gt;window&lt;/var&gt;, in lieu of the usual action of &lt;code&gt;delete-window&lt;/code&gt;. See &lt;a href=&quot;window-parameters#Window-Parameters&quot;&gt;Window Parameters&lt;/a&gt;.</source>
          <target state="translated">이 기능의 동작의 윈도우 파라미터가 변경 될 수있다 &lt;var&gt;window&lt;/var&gt; 오랫동안 변수로서 &lt;code&gt;ignore-window-parameters&lt;/code&gt; 이다 &lt;code&gt;nil&lt;/code&gt; . 의 값 경우 &lt;code&gt;delete-window&lt;/code&gt; 창 매개 변수가 &lt;code&gt;t&lt;/code&gt; ,이 기능은 다른 모든 창 매개 변수를 무시합니다. 그렇지 않으면 &lt;code&gt;delete-window&lt;/code&gt; window 매개 변수 의 값 이 함수이면 &lt;code&gt;delete-window&lt;/code&gt; 의 일반적인 작업 대신 &lt;var&gt;window&lt;/var&gt; 인수와 함께 해당 함수가 호출됩니다 . &lt;a href=&quot;window-parameters#Window-Parameters&quot;&gt;창 매개 변수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8909897602cd17a4273ebb64ab850510d93123be" translate="yes" xml:space="preserve">
          <source>The behavior of this function may be altered by the window parameters of &lt;var&gt;window&lt;/var&gt;, so long as the variable &lt;code&gt;ignore-window-parameters&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;. If the value of the &lt;code&gt;split-window&lt;/code&gt; window parameter is &lt;code&gt;t&lt;/code&gt;, this function ignores all other window parameters. Otherwise, if the value of the &lt;code&gt;split-window&lt;/code&gt; window parameter is a function, that function is called with the arguments &lt;var&gt;window&lt;/var&gt;, &lt;var&gt;size&lt;/var&gt;, and &lt;var&gt;side&lt;/var&gt;, in lieu of the usual action of &lt;code&gt;split-window&lt;/code&gt;. Otherwise, this function obeys the &lt;code&gt;window-atom&lt;/code&gt; or &lt;code&gt;window-side&lt;/code&gt; window parameter, if any. See &lt;a href=&quot;window-parameters#Window-Parameters&quot;&gt;Window Parameters&lt;/a&gt;.</source>
          <target state="translated">이 기능의 동작의 윈도우 파라미터가 변경 될 수있다 &lt;var&gt;window&lt;/var&gt; 오랫동안 변수로서 &lt;code&gt;ignore-window-parameters&lt;/code&gt; 이다 &lt;code&gt;nil&lt;/code&gt; . 값의 경우 &lt;code&gt;split-window&lt;/code&gt; 윈도우 파라미터가 &lt;code&gt;t&lt;/code&gt; ,이 함수는 모든 다른 윈도우 파라미터를 무시한다. 그렇지 않고 &lt;code&gt;split-window&lt;/code&gt; 창 매개 변수 의 값이 함수이면 해당 함수는 일반적인 &lt;code&gt;split-window&lt;/code&gt; 작업 대신 &lt;var&gt;window&lt;/var&gt; , &lt;var&gt;size&lt;/var&gt; 및 &lt;var&gt;side&lt;/var&gt; 인수를 사용하여 호출됩니다 . 그렇지 않으면,이 함수는 &lt;code&gt;window-atom&lt;/code&gt; 또는 &lt;code&gt;window-side&lt;/code&gt; window 매개 변수 (있는 경우)를 따릅니다. 보다&lt;a href=&quot;window-parameters#Window-Parameters&quot;&gt;창 매개 변수&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9cc45d4c978076585a6ff258d4628feaba65d091" translate="yes" xml:space="preserve">
          <source>The bidirectional properties of characters can be overridden by inserting into the text special directional control characters, LEFT-TO-RIGHT OVERRIDE (</source>
          <target state="translated">문자의 양방향 속성은 텍스트 특수 방향 제어 문자 인 LEFT-TO-RIGHT OVERRIDE ()를 삽입하여 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ddc9759fd2b7786cbd37b4781873ad47f324e2a" translate="yes" xml:space="preserve">
          <source>The binding whose definition is &lt;code&gt;(&quot;--&quot;)&lt;/code&gt; is a separator line. Like a real menu item, the separator has a key symbol, in this case &lt;code&gt;separator-replace-tags&lt;/code&gt;. If one menu has two separators, they must have two different key symbols.</source>
          <target state="translated">정의가 &lt;code&gt;(&quot;--&quot;)&lt;/code&gt; 인 바인딩 은 구분선입니다. 실제 메뉴 항목과 마찬가지로 구분 기호에는 키 기호가 있습니다 (이 경우 &lt;code&gt;separator-replace-tags&lt;/code&gt; ) . 한 메뉴에 두 개의 구분 기호가있는 경우 두 개의 다른 키 기호가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="8bc0cde3ac12a6a4acea584ef36bd73f7c9731fc" translate="yes" xml:space="preserve">
          <source>The bitwise operations in Emacs Lisp apply only to integers.</source>
          <target state="translated">Emacs Lisp의 비트 연산은 정수에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="457ac28d787de6ecd95feb0905b63526b367e16f" translate="yes" xml:space="preserve">
          <source>The body of the notification. If &lt;var&gt;body&lt;/var&gt; is a string, it specifies the text of the notification message. Use embedded newlines to control how the text is broken into lines. The body text can be up to 255 characters long, and will be truncated if it&amp;rsquo;s longer. Unlike with D-Bus, the body text should be plain text, with no markup.</source>
          <target state="translated">알림의 본문입니다. 경우 &lt;var&gt;body&lt;/var&gt; 문자열, 그것은 알림 메시지의 텍스트를 지정합니다. 포함 된 줄 바꿈을 사용하여 텍스트가 줄로 분할되는 방식을 제어합니다. 본문 텍스트는 최대 255 자까지 가능하며 길이가 더 길면 잘립니다. D-Bus와 달리 본문 텍스트는 마크 업이없는 일반 텍스트 여야합니다.</target>
        </trans-unit>
        <trans-unit id="c5d378c0de07cb367247e7065675fce352e2e8da" translate="yes" xml:space="preserve">
          <source>The brief description is also taken from the first line. Here, it is &amp;lsquo;</source>
          <target state="translated">간단한 설명도 첫 번째 줄에서 가져옵니다. 여기있어 '</target>
        </trans-unit>
        <trans-unit id="fbd2e470098b8a59979b42d91f57778cec2ac8a5" translate="yes" xml:space="preserve">
          <source>The broadcast address.</source>
          <target state="translated">브로드 캐스트 주소입니다.</target>
        </trans-unit>
        <trans-unit id="9444e738ec3ad2f036ba7f9ef0d9c118bd783945" translate="yes" xml:space="preserve">
          <source>The buffer file name indicates which file is visited.</source>
          <target state="translated">버퍼 파일 이름은 방문한 파일을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="46b639fbc76f834ed60b16f7c2c36f68d4fa8701" translate="yes" xml:space="preserve">
          <source>The buffer object for the buffer that has been killed remains in existence as long as anything refers to it, but it is specially marked so that you cannot make it current or display it. Killed buffers retain their identity, however; if you kill two distinct buffers, they remain distinct according to &lt;code&gt;eq&lt;/code&gt; although both are dead.</source>
          <target state="translated">종료 된 버퍼에 대한 버퍼 개체는 어떤 것이 참조하는 한 존재하지만 특별히 표시되어 있으므로 현재로 만들거나 표시 할 수 없습니다. 그러나 종료 된 버퍼는 해당 ID를 유지합니다. 두 개의 서로 다른 버퍼를 죽이면 둘 다 &lt;code&gt;eq&lt;/code&gt; 에 따라 구별됩니다 .</target>
        </trans-unit>
        <trans-unit id="2bb148bf41b83dd7c67c5ca983b4f737e34081a2" translate="yes" xml:space="preserve">
          <source>The buffer position of the character clicked on in the text area; or, if the click was outside the text area, the window area where it occurred. It is one of the symbols &lt;code&gt;mode-line&lt;/code&gt;, &lt;code&gt;header-line&lt;/code&gt;, &lt;code&gt;tab-line&lt;/code&gt;, &lt;code&gt;vertical-line&lt;/code&gt;, &lt;code&gt;left-margin&lt;/code&gt;, &lt;code&gt;right-margin&lt;/code&gt;, &lt;code&gt;left-fringe&lt;/code&gt;, or &lt;code&gt;right-fringe&lt;/code&gt;.</source>
          <target state="translated">텍스트 영역에서 클릭 한 문자의 버퍼 위치. 또는 클릭이 텍스트 영역 밖에있는 경우 클릭이 발생한 창 영역입니다. 그것은 상징 중 하나입니다 &lt;code&gt;mode-line&lt;/code&gt; , &lt;code&gt;header-line&lt;/code&gt; , &lt;code&gt;tab-line&lt;/code&gt; , &lt;code&gt;vertical-line&lt;/code&gt; , &lt;code&gt;left-margin&lt;/code&gt; , &lt;code&gt;right-margin&lt;/code&gt; , &lt;code&gt;left-fringe&lt;/code&gt; , 또는 &lt;code&gt;right-fringe&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e0c6a9c7f2f23737ee9bec0aa37f53da73d239e" translate="yes" xml:space="preserve">
          <source>The buffer to associate with the process. The value can be either a buffer or a string that names a buffer. Process output goes at the end of that buffer, unless you specify an output stream or filter function to handle the output. If &lt;var&gt;buffer&lt;/var&gt; is not given, the process buffer&amp;rsquo;s name is taken from the value of the &lt;code&gt;:name&lt;/code&gt; keyword.</source>
          <target state="translated">프로세스와 연결할 버퍼입니다. 값은 버퍼 또는 버퍼 이름을 지정하는 문자열 일 수 있습니다. 출력을 처리 할 출력 스트림 또는 필터 함수를 지정하지 않는 한 프로세스 출력은 해당 버퍼의 끝으로 이동합니다. &lt;var&gt;buffer&lt;/var&gt; 가 지정되지 않은 경우 프로세스 버퍼의 이름은 &lt;code&gt;:name&lt;/code&gt; 키워드 의 값에서 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="42a7a981c12f34f51806e6af8e44330ecc1873b4" translate="yes" xml:space="preserve">
          <source>The buffer which its text is generated in.</source>
          <target state="translated">텍스트가 생성되는 버퍼입니다.</target>
        </trans-unit>
        <trans-unit id="72b7af992a3abc5d40c1f25fff8d07a12b73f582" translate="yes" xml:space="preserve">
          <source>The buffer will only auto-revert if it is marked unmodified. Hence, you will have to make sure that various functions mark the buffer modified if and only if either the buffer contains information that might be lost by reverting, or there is reason to believe that the user might be inconvenienced by auto-reverting, because he is actively working on the buffer. The user can always override this by manually adjusting the modified status of the buffer. To support this, calling the &lt;code&gt;revert-buffer-function&lt;/code&gt; on a buffer that is marked unmodified should always keep the buffer marked unmodified.</source>
          <target state="translated">버퍼는 수정되지 않은 것으로 표시된 경우에만 자동으로 되돌립니다. 따라서 버퍼에 되돌리기로 인해 손실 될 수있는 정보가 포함되어 있거나 사용자가 자동 ​​되돌리기로 인해 불편을 겪을 수 있다고 믿을 이유가있는 경우에만 다양한 함수가 수정 된 버퍼를 표시하도록해야합니다. 버퍼에서 활발히 작업하고 있습니다. 사용자는 버퍼의 수정 된 상태를 수동으로 조정하여 항상이를 무시할 수 있습니다. 이를 지원하기 위해 수정되지 않은 것으로 표시된 버퍼 에서 &lt;code&gt;revert-buffer-function&lt;/code&gt; 을 호출하면 항상 수정되지 않은 것으로 표시된 버퍼를 유지해야합니다.</target>
        </trans-unit>
        <trans-unit id="873949287545ef0ee1c24f3a275146b7c289aea3" translate="yes" xml:space="preserve">
          <source>The buffer&amp;rsquo;s value of point, as of the last time a redisplay completed in this window.</source>
          <target state="translated">이 창에서 마지막으로 다시 표시가 완료된 시점의 버퍼 포인트 값입니다.</target>
        </trans-unit>
        <trans-unit id="4ee204383471ebb747819beeda4333dfcb08b7c3" translate="yes" xml:space="preserve">
          <source>The buffer-local value of &lt;var&gt;variable&lt;/var&gt; starts out as the same value &lt;var&gt;variable&lt;/var&gt; previously had. If &lt;var&gt;variable&lt;/var&gt; was void, it remains void.</source>
          <target state="translated">&lt;var&gt;variable&lt;/var&gt; 의 버퍼 로컬 값은 이전에 가졌던 동일한 값 &lt;var&gt;variable&lt;/var&gt; 로 시작합니다 . 경우 &lt;var&gt;variable&lt;/var&gt; 무효이고, 그것은 무효 남아있다.</target>
        </trans-unit>
        <trans-unit id="36ca484b5abddc8c8e81e5e6b9502ec9f88a67b6" translate="yes" xml:space="preserve">
          <source>The buffer-local value of this variable holds the symbol for the current major mode. Its default value holds the default major mode for new buffers. The standard default value is &lt;code&gt;fundamental-mode&lt;/code&gt;.</source>
          <target state="translated">이 변수의 버퍼 로컬 값은 현재 주 모드에 대한 기호를 보유합니다. 기본값은 새 버퍼에 대한 기본 주 모드를 유지합니다. 표준 기본값은 &lt;code&gt;fundamental-mode&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1e4cd19bcf9c24b5b8a282bde2c2fd833888ed62" translate="yes" xml:space="preserve">
          <source>The buffer-local variable &lt;code&gt;enable-multibyte-characters&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt; in multibyte buffers, and &lt;code&gt;nil&lt;/code&gt; in unibyte ones. The mode line also indicates whether a buffer is multibyte or not. With a graphical display, in a multibyte buffer, the portion of the mode line that indicates the character set has a tooltip that (amongst other things) says that the buffer is multibyte. In a unibyte buffer, the character set indicator is absent. Thus, in a unibyte buffer (when using a graphical display) there is normally nothing before the indication of the visited file&amp;rsquo;s end-of-line convention (colon, backslash, etc.), unless you are using an input method.</source>
          <target state="translated">버퍼 로컬 변수가 &lt;code&gt;enable-multibyte-characters&lt;/code&gt; 비이다 &lt;code&gt;nil&lt;/code&gt; 멀티 버퍼, 그리고 &lt;code&gt;nil&lt;/code&gt; unibyte 것들이다. 모드 행은 또한 버퍼가 멀티 바이트인지 여부를 나타냅니다. 그래픽 디스플레이에서 멀티 바이트 버퍼에서 문자 집합을 나타내는 모드 행 부분에는 버퍼가 멀티 바이트임을 나타내는 도구 설명이 있습니다. 유니 바이트 버퍼에서는 문자 집합 표시기가 없습니다. 따라서 유니 바이트 버퍼 (그래픽 디스플레이를 사용할 때)에서는 입력 방법을 사용하지 않는 한 일반적으로 방문한 파일의 줄 끝 규칙 (콜론, 백 슬래시 등)을 표시하기 전에 아무것도 없습니다.</target>
        </trans-unit>
        <trans-unit id="acfac422dea48051a2c7c007628247062d5bf74c" translate="yes" xml:space="preserve">
          <source>The buffer-predicate function for this frame. The function &lt;code&gt;other-buffer&lt;/code&gt; uses this predicate (from the selected frame) to decide which buffers it should consider, if the predicate is not &lt;code&gt;nil&lt;/code&gt;. It calls the predicate with one argument, a buffer, once for each buffer; if the predicate returns a non-&lt;code&gt;nil&lt;/code&gt; value, it considers that buffer.</source>
          <target state="translated">이 프레임에 대한 버퍼 술어 함수. &lt;code&gt;other-buffer&lt;/code&gt; 함수 는이 술어 (선택된 프레임에서)를 사용하여 술어가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 고려해야 할 버퍼를 결정합니다 . 각 버퍼에 대해 한 번씩 하나의 인수 인 버퍼로 술어를 호출합니다. 술어가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 값을 리턴하면 해당 버퍼를 고려합니다.</target>
        </trans-unit>
        <trans-unit id="b4516ab94968d260129418edf75f3cd31faf9215" translate="yes" xml:space="preserve">
          <source>The built-in function &lt;code&gt;indirect-function&lt;/code&gt; provides an easy way to perform symbol function indirection explicitly.</source>
          <target state="translated">내장 함수 &lt;code&gt;indirect-function&lt;/code&gt; 는 기호 함수 간접을 명시 적으로 수행하는 쉬운 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f3cdf2d46910f6a19f564d8ab1c23afa5ceb31d7" translate="yes" xml:space="preserve">
          <source>The bulk of &lt;code&gt;grok/pcase&lt;/code&gt; is a single clause of a &lt;code&gt;pcase&lt;/code&gt; form, the pattern on lines 1-8, the (single) body form on line 9. The pattern is &lt;code&gt;or&lt;/code&gt;, which tries to match in turn its argument sub-patterns, first &lt;code&gt;and&lt;/code&gt; (lines 2-7), then &lt;code&gt;let&lt;/code&gt; (line 8), until one of them succeeds.</source>
          <target state="translated">벌크 &lt;code&gt;grok/pcase&lt;/code&gt; (A)의 하나의 절이 &lt;code&gt;pcase&lt;/code&gt; 의 형태 라인 1-8상의 패턴은, 라인 (9) 인 패턴에 (단일) 체형 &lt;code&gt;or&lt;/code&gt; 그 인자 서브 패턴 설정에 일치 시키려고하는 첫 번째 &lt;code&gt;and&lt;/code&gt; (행 2-7), 다음 &lt;code&gt;let&lt;/code&gt; 그 중 하나가 성공할 때까지, (라인 8).</target>
        </trans-unit>
        <trans-unit id="fb70f0ac918e95323b7c7d8c894fa19635af573c" translate="yes" xml:space="preserve">
          <source>The button type. See &lt;a href=&quot;button-types#Button-Types&quot;&gt;Button Types&lt;/a&gt;.</source>
          <target state="translated">버튼 유형입니다. &lt;a href=&quot;button-types#Button-Types&quot;&gt;버튼 유형을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bc5bc8ec439519ab1bd1ce7c170e4e3b8e964c13" translate="yes" xml:space="preserve">
          <source>The button&amp;rsquo;s keymap, defining bindings active within the button region. By default this is the usual button region keymap, stored in the variable &lt;code&gt;button-map&lt;/code&gt;, which defines</source>
          <target state="translated">버튼 영역 내에서 활성화 된 바인딩을 정의하는 버튼의 키맵입니다. 기본적으로이 변수에 저장된 일반 버튼의 지역 키맵입니다 &lt;code&gt;button-map&lt;/code&gt; 를 정의,</target>
        </trans-unit>
        <trans-unit id="a43c685ec98dba6c7317b7c086d65e4dcee7b6a8" translate="yes" xml:space="preserve">
          <source>The button-creation functions all take the &lt;code&gt;&amp;amp;rest&lt;/code&gt; argument &lt;var&gt;properties&lt;/var&gt;, which should be a sequence of &lt;var&gt;property value&lt;/var&gt; pairs, specifying properties to add to the button; see &lt;a href=&quot;button-properties#Button-Properties&quot;&gt;Button Properties&lt;/a&gt;. In addition, the keyword argument &lt;code&gt;:type&lt;/code&gt; may be used to specify a button-type from which to inherit other properties; see &lt;a href=&quot;button-types#Button-Types&quot;&gt;Button Types&lt;/a&gt;. Any properties not explicitly specified during creation will be inherited from the button&amp;rsquo;s type (if the type defines such a property).</source>
          <target state="translated">버튼 생성 함수는 모두 버튼 에 추가 할 속성을 지정하는 &lt;var&gt;property value&lt;/var&gt; 쌍 의 시퀀스 여야 하는 &lt;code&gt;&amp;amp;rest&lt;/code&gt; 인수 &lt;var&gt;properties&lt;/var&gt; 을 사용합니다. &lt;a href=&quot;button-properties#Button-Properties&quot;&gt;버튼 속성을&lt;/a&gt; 참조하십시오 . 또한 키워드 인자 &lt;code&gt;:type&lt;/code&gt; 을 사용하여 다른 속성을 상속 할 버튼 유형을 지정할 수 있습니다. &lt;a href=&quot;button-types#Button-Types&quot;&gt;버튼 유형을&lt;/a&gt; 참조하십시오 . 생성 중에 명시 적으로 지정되지 않은 모든 속성은 버튼의 유형에서 상속됩니다 (유형이 해당 속성을 정의하는 경우).</target>
        </trans-unit>
        <trans-unit id="07b9418ec8ac4ecbb4a365a5bd8c7af6fd875ba2" translate="yes" xml:space="preserve">
          <source>The byte compiler uses the dynamic function loading feature if the variable &lt;code&gt;byte-compile-dynamic&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt; at compilation time. Do not set this variable globally, since dynamic loading is desirable only for certain files. Instead, enable the feature for specific source files with file-local variable bindings. For example, you could do it by writing this text in the source file&amp;rsquo;s first line:</source>
          <target state="translated">바이트 컴파일러는 컴파일 시간에 &lt;code&gt;byte-compile-dynamic&lt;/code&gt; 변수 가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 동적 함수 로딩 기능을 사용합니다 . 동적 로딩은 특정 파일에만 바람직하므로이 변수를 전역 적으로 설정하지 마십시오. 대신 파일 로컬 변수 바인딩을 사용하여 특정 소스 파일에 대한 기능을 활성화하십시오. 예를 들어, 소스 파일의 첫 번째 줄에 다음 텍스트를 작성하여 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0f586f7c11295ae6041637f812fe199d118bbd2" translate="yes" xml:space="preserve">
          <source>The byte position corresponding to &lt;code&gt;window_end_pos&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;window_end_pos&lt;/code&gt; 에 해당하는 바이트 위치 입니다.</target>
        </trans-unit>
        <trans-unit id="bf3fbe15bb3d806e89a2d23a877d978fe26d5b4c" translate="yes" xml:space="preserve">
          <source>The byte-code interpreter is implemented as a simple stack machine. It pushes values onto a stack of its own, then pops them off to use them in calculations whose results are themselves pushed back on the stack. When a byte-code function returns, it pops a value off the stack and returns it as the value of the function.</source>
          <target state="translated">바이트 코드 인터프리터는 단순 스택 머신으로 구현됩니다. 값을 자체 스택에 푸시 한 다음 결과가 스택에 다시 푸시되는 계산에 사용하기 위해 값을 팝합니다. 바이트 코드 함수가 반환되면 스택에서 값을 꺼내 함수의 값으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8f21eeb3ce4b172d88f4a4054b14733959d546ae" translate="yes" xml:space="preserve">
          <source>The call to &lt;var&gt;func&lt;/var&gt; must be in the &lt;var&gt;then-form&lt;/var&gt; of the &lt;code&gt;if&lt;/code&gt;, and &lt;var&gt;func&lt;/var&gt; must appear quoted in the call to &lt;code&gt;fboundp&lt;/code&gt;. (This feature operates for &lt;code&gt;cond&lt;/code&gt; as well.)</source>
          <target state="translated">&lt;var&gt;func&lt;/var&gt; 에 대한 호출 은 &lt;code&gt;if&lt;/code&gt; 의 &lt;var&gt;then-form&lt;/var&gt; 이어야 하며 &lt;var&gt;func&lt;/var&gt; 는 &lt;code&gt;fboundp&lt;/code&gt; 에 대한 호출에서 인용 부호로 표시되어야합니다 . (이 기능은 &lt;code&gt;cond&lt;/code&gt; 에서도 작동 합니다.)</target>
        </trans-unit>
        <trans-unit id="cd816549d0833bdd182cffeef083166bd9eccadb" translate="yes" xml:space="preserve">
          <source>The canonical way to specify the &lt;em&gt;size of a frame&lt;/em&gt; from within Emacs is by specifying its &lt;em&gt;text size&lt;/em&gt;&amp;mdash;a tuple of the width and height of the frame&amp;rsquo;s text area (see &lt;a href=&quot;frame-layout#Frame-Layout&quot;&gt;Frame Layout&lt;/a&gt;). It can be measured either in pixels or in terms of the frame&amp;rsquo;s canonical character size (see &lt;a href=&quot;frame-font#Frame-Font&quot;&gt;Frame Font&lt;/a&gt;).</source>
          <target state="translated">Emacs 내 &lt;em&gt;에서 프레임 크기&lt;/em&gt; 를 지정하는 표준 방법 은 &lt;em&gt;텍스트 크기&lt;/em&gt; (프레임 텍스트 영역의 너비와 높이의 튜플 )를 지정하는 것 입니다 ( &lt;a href=&quot;frame-layout#Frame-Layout&quot;&gt;프레임 레이아웃&lt;/a&gt; 참조 ). 픽셀 단위 또는 프레임의 표준 문자 크기로 측정 할 수 있습니다 ( &lt;a href=&quot;frame-font#Frame-Font&quot;&gt;프레임 글꼴&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="35d63b67cea7481378d16b550f8c7d9339ebd861" translate="yes" xml:space="preserve">
          <source>The canonicalize table maps all of a set of case-related characters into a particular member of that set.</source>
          <target state="translated">canonicalize 테이블은 모든 대 / 소문자 관련 문자 집합을 해당 집합의 특정 구성원에 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="d98adabbf87cc8a08f14746c5fbb4310e30779ab" translate="yes" xml:space="preserve">
          <source>The case change commands described here work on text in the current buffer. See &lt;a href=&quot;case-conversion#Case-Conversion&quot;&gt;Case Conversion&lt;/a&gt;, for case conversion functions that work on strings and characters. See &lt;a href=&quot;case-tables#Case-Tables&quot;&gt;Case Tables&lt;/a&gt;, for how to customize which characters are upper or lower case and how to convert them.</source>
          <target state="translated">여기에 설명 된 대소 문자 변경 명령은 현재 버퍼의 텍스트에서 작동합니다. 참조 &lt;a href=&quot;case-conversion#Case-Conversion&quot;&gt;사례 변환&lt;/a&gt; , 대소 문자 변환 기능을위한 문자열과 문자에 일이. 어떤 문자가 대문자인지 소문자인지 사용자 정의하고 변환하는 방법 은 &lt;a href=&quot;case-tables#Case-Tables&quot;&gt;케이스 테이블을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="77ee252710982b3fcb0142f8b906f77a763d14f3" translate="yes" xml:space="preserve">
          <source>The case of a graphic character is indicated by its character code; for example,</source>
          <target state="translated">그래픽 문자의 대소 문자는 문자 코드로 표시됩니다. 예를 들면</target>
        </trans-unit>
        <trans-unit id="4e2b2272e435daf5cb6f60baee461dfc446d4222" translate="yes" xml:space="preserve">
          <source>The case table for the</source>
          <target state="translated">케이스 테이블</target>
        </trans-unit>
        <trans-unit id="280090829e281a538077bc06a68c1ff20cd3fb94" translate="yes" xml:space="preserve">
          <source>The category table is actually a char-table (see &lt;a href=&quot;char_002dtables#Char_002dTables&quot;&gt;Char-Tables&lt;/a&gt;). The element of the category table at index &lt;var&gt;c&lt;/var&gt; is a &lt;em&gt;category set&lt;/em&gt;&amp;mdash;a bool-vector&amp;mdash;that indicates which categories character &lt;var&gt;c&lt;/var&gt; belongs to. In this category set, if the element at index &lt;var&gt;cat&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;, that means category &lt;var&gt;cat&lt;/var&gt; is a member of the set, and that character &lt;var&gt;c&lt;/var&gt; belongs to category &lt;var&gt;cat&lt;/var&gt;.</source>
          <target state="translated">범주 테이블은 실제로 문자 테이블입니다 ( &lt;a href=&quot;char_002dtables#Char_002dTables&quot;&gt;Char-Tables&lt;/a&gt; 참조 ). 인덱스의 카테고리 테이블의 요소 &lt;var&gt;c&lt;/var&gt; 인 &lt;em&gt;카테고리 설정&lt;/em&gt; -a BOOL 벡터 카테고리 캐릭터 있는지를 나타내는 &lt;var&gt;c&lt;/var&gt; 속한다. 이 범주 집합에서 색인 &lt;var&gt;cat&lt;/var&gt; 의 요소 가 &lt;code&gt;t&lt;/code&gt; 이면 범주 &lt;var&gt;cat&lt;/var&gt; 이 집합의 구성원이고 해당 문자 &lt;var&gt;c&lt;/var&gt; 가 범주 &lt;var&gt;cat&lt;/var&gt; 에 속함을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="d0485386ae15548477e7a1c3ddbf99aabc72746a" translate="yes" xml:space="preserve">
          <source>The char-table has one extra slot, which determines how to display any character that cannot be displayed with any available font, or cannot be encoded by the terminal&amp;rsquo;s coding system. Its value should be one of the above display methods, except &lt;code&gt;zero-width&lt;/code&gt; or a cons cell.</source>
          <target state="translated">문자 테이블에는 사용 가능한 글꼴로 표시 할 수 없거나 터미널의 코딩 시스템에서 인코딩 할 수없는 문자를 표시하는 방법을 결정하는 추가 슬롯이 하나 있습니다. 값은 &lt;code&gt;zero-width&lt;/code&gt; 또는 단점 셀을 제외하고 위의 표시 방법 중 하나 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="9023ce61724bbabe84554211f1682a5b7d26a59b" translate="yes" xml:space="preserve">
          <source>The character &amp;lsquo;</source>
          <target state="translated">캐릭터 '</target>
        </trans-unit>
        <trans-unit id="e68ebec1ac879e97e03c36bf47008aa20c6bd7bd" translate="yes" xml:space="preserve">
          <source>The character and byte positions of point in a buffer.</source>
          <target state="translated">버퍼에있는 포인트의 문자 및 바이트 위치.</target>
        </trans-unit>
        <trans-unit id="f22f38b266e9823831c9d0ef2c9a1fe74ed5e490" translate="yes" xml:space="preserve">
          <source>The character and byte positions of the beginning of the accessible range of text in the buffer.</source>
          <target state="translated">버퍼에서 액세스 가능한 텍스트 범위 시작의 문자 및 바이트 위치입니다.</target>
        </trans-unit>
        <trans-unit id="6c5385edb6d96d02471dae4f088297c2fa6a7318" translate="yes" xml:space="preserve">
          <source>The character and byte positions of the buffer gap. See &lt;a href=&quot;buffer-gap#Buffer-Gap&quot;&gt;Buffer Gap&lt;/a&gt;.</source>
          <target state="translated">버퍼 갭의 문자 및 바이트 위치. &lt;a href=&quot;buffer-gap#Buffer-Gap&quot;&gt;버퍼 간격을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8c6314b6b815e7c063f41b61f7f1fd27b17e3df8" translate="yes" xml:space="preserve">
          <source>The character and byte positions of the end of the accessible range of text in the buffer.</source>
          <target state="translated">버퍼에서 액세스 가능한 텍스트 범위 끝의 문자 및 바이트 위치입니다.</target>
        </trans-unit>
        <trans-unit id="e3ea8b9851630ca5901561ab1adc692dcbe57e4a" translate="yes" xml:space="preserve">
          <source>The character and byte positions of the end of the buffer text.</source>
          <target state="translated">버퍼 텍스트 끝의 문자 및 바이트 위치입니다.</target>
        </trans-unit>
        <trans-unit id="159599eecd7ed600dfc647ecdceabd08ac6e6b7e" translate="yes" xml:space="preserve">
          <source>The character case functions change the case of single characters or of the contents of strings. The functions normally convert only alphabetic characters (the letters &amp;lsquo;</source>
          <target state="translated">문자 케이스 함수는 단일 문자의 대소 문자 또는 문자열 내용을 변경합니다. 이 함수는 일반적으로 알파벳 문자 ( '</target>
        </trans-unit>
        <trans-unit id="58661f35491edec56426ef5502747311e8425649" translate="yes" xml:space="preserve">
          <source>The character position of the start of the innermost parenthetical grouping containing the stopping point; &lt;code&gt;nil&lt;/code&gt; if none.</source>
          <target state="translated">중지 지점을 포함하는 가장 안쪽 괄호 그룹의 시작 문자 위치입니다. &lt;code&gt;nil&lt;/code&gt; 경우 nil .</target>
        </trans-unit>
        <trans-unit id="ed5394eb7206607235f4bd5c8e10df5c68b18fa4" translate="yes" xml:space="preserve">
          <source>The character position of the start of the last complete subexpression terminated; &lt;code&gt;nil&lt;/code&gt; if none.</source>
          <target state="translated">종료 된 마지막 완전한 하위 표현식의 시작 문자 위치. &lt;code&gt;nil&lt;/code&gt; 경우 nil .</target>
        </trans-unit>
        <trans-unit id="1247f75f37cf02e36f0fa69040f3ac6b097ecbdf" translate="yes" xml:space="preserve">
          <source>The characters &amp;lsquo;</source>
          <target state="translated">문자 '</target>
        </trans-unit>
        <trans-unit id="54c2a07fdd0ef1fdb5ddcd9fa98003e13884d86d" translate="yes" xml:space="preserve">
          <source>The characters in &lt;var&gt;string&lt;/var&gt;, other than the format specifications, are copied directly into the output, including their text properties, if any. Any text properties of the format specifications are copied to the produced string representations of the argument &lt;var&gt;objects&lt;/var&gt;.</source>
          <target state="translated">형식 사양이 아닌 &lt;var&gt;string&lt;/var&gt; 의 문자는 텍스트 속성 (있는 경우)을 포함하여 출력에 직접 복사됩니다. 형식 사양의 모든 텍스트 속성은 인수 &lt;var&gt;objects&lt;/var&gt; 의 생성 된 문자열 표현에 복사됩니다 .</target>
        </trans-unit>
        <trans-unit id="d3187515a75e9f5846604d36640635fa33365798" translate="yes" xml:space="preserve">
          <source>The characters in &lt;var&gt;template&lt;/var&gt;, other than the format specifications, are copied directly into the output, including their text properties, if any. Any text properties of the format specifications are copied to their replacements.</source>
          <target state="translated">형식 사양이 아닌 &lt;var&gt;template&lt;/var&gt; 의 문자는 텍스트 속성 (있는 경우)을 포함하여 출력에 직접 복사됩니다. 형식 사양의 모든 텍스트 속성이 대체 항목에 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="846a19eaa57baaea4ef97563adf70350f2950595" translate="yes" xml:space="preserve">
          <source>The charset registry and encoding of the font, such as &amp;lsquo;</source>
          <target state="translated">문자셋 레지스트리 및 글꼴 인코딩 (예 : '</target>
        </trans-unit>
        <trans-unit id="b3fa5e7367f49d16057c52ffe48350e2d39e997d" translate="yes" xml:space="preserve">
          <source>The choice of which window edges this function alters depends on the values of the option &lt;code&gt;window-combination-resize&lt;/code&gt; and the combination limits of the involved windows; in some cases, it may alter both edges. See &lt;a href=&quot;recombining-windows#Recombining-Windows&quot;&gt;Recombining Windows&lt;/a&gt;. To resize by moving only the bottom or right edge of a window, use the function &lt;code&gt;adjust-window-trailing-edge&lt;/code&gt;.</source>
          <target state="translated">이 함수가 변경하는 창 가장자리의 선택은 &lt;code&gt;window-combination-resize&lt;/code&gt; 옵션의 값 과 관련된 창의 조합 제한에 따라 다릅니다 . 경우에 따라 양쪽 가장자리가 변경 될 수 있습니다. &lt;a href=&quot;recombining-windows#Recombining-Windows&quot;&gt;Windows 재결합을&lt;/a&gt; 참조하십시오 . 창의 아래쪽 또는 오른쪽 가장자리 만 이동하여 크기를 조정하려면 &lt;code&gt;adjust-window-trailing-edge&lt;/code&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="aa502a49dcc709424f597b62f00f62cbd92bf872" translate="yes" xml:space="preserve">
          <source>The classification of the terminal&amp;rsquo;s background color, either &lt;code&gt;light&lt;/code&gt; or &lt;code&gt;dark&lt;/code&gt;.</source>
          <target state="translated">터미널의 배경색을 &lt;code&gt;light&lt;/code&gt; 또는 &lt;code&gt;dark&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="f93c6d22f7b132786ba6625daad510b5c573fb14" translate="yes" xml:space="preserve">
          <source>The client process&amp;rsquo;s plist is initialized from the server&amp;rsquo;s plist.</source>
          <target state="translated">클라이언트 프로세스의 plist는 서버의 plist에서 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="fbb47d099826f587fe36a3370bfe320b242c3ce1" translate="yes" xml:space="preserve">
          <source>The code character descriptions below contain a number of key words, defined here as follows:</source>
          <target state="translated">아래 코드 문자 설명에는 다음과 같이 정의 된 여러 키워드가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="75ce7901949b09d49a8e972aae9dfafa61a540ec" translate="yes" xml:space="preserve">
          <source>The code for every major mode should follow various coding conventions, including conventions for local keymap and syntax table initialization, function and variable names, and hooks.</source>
          <target state="translated">모든 주요 모드의 코드는 로컬 키맵 및 구문 테이블 초기화, 함수 및 변수 이름, 후크에 대한 규칙을 포함하여 다양한 코딩 규칙을 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="dfef9020b23692b251e830295a72905bdd207aaf" translate="yes" xml:space="preserve">
          <source>The code letter &amp;lsquo;</source>
          <target state="translated">코드 문자 '</target>
        </trans-unit>
        <trans-unit id="2482022c4c984ca682c681b8a8dff28fc069228d" translate="yes" xml:space="preserve">
          <source>The coding system &lt;code&gt;raw-text&lt;/code&gt; is special in that it prevents character code conversion, and causes the buffer visited with this coding system to be a unibyte buffer. For historical reasons, you can save both unibyte and multibyte text with this coding system. When you use &lt;code&gt;raw-text&lt;/code&gt; to encode multibyte text, it does perform one character code conversion: it converts eight-bit characters to their single-byte external representation. &lt;code&gt;raw-text&lt;/code&gt; does not specify the end-of-line conversion, allowing that to be determined as usual by the data, and has the usual three variants which specify the end-of-line conversion.</source>
          <target state="translated">코딩 시스템 &lt;code&gt;raw-text&lt;/code&gt; 는 문자 코드 변환을 방지하고이 코딩 시스템에서 방문한 버퍼를 유니 바이트 버퍼로 만든다는 점에서 특별합니다. 역사적 이유로이 코딩 시스템을 사용하여 유니 바이트 및 멀티 바이트 텍스트를 모두 저장할 수 있습니다. 당신이 사용하는 경우 &lt;code&gt;raw-text&lt;/code&gt; 인코딩 멀티 바이트 텍스트를, 그것은 하나 개의 문자 코드 변환을 수행 않습니다 : 그것은 그들의 싱글 바이트 외부 표현에 8 비트 문자로 변환합니다. &lt;code&gt;raw-text&lt;/code&gt; 는 줄 끝 변환을 지정하지 않으므로 데이터에 의해 평소와 같이 결정될 수 있으며 줄 끝 변환을 지정하는 일반적인 세 ​​가지 변형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9d6afb051f08a549ab7418ae16669da3deb347c" translate="yes" xml:space="preserve">
          <source>The coding system &lt;code&gt;utf-8-emacs&lt;/code&gt; specifies that the data is represented in the internal Emacs encoding (see &lt;a href=&quot;text-representations#Text-Representations&quot;&gt;Text Representations&lt;/a&gt;). This is like &lt;code&gt;raw-text&lt;/code&gt; in that no code conversion happens, but different in that the result is multibyte data. The name &lt;code&gt;emacs-internal&lt;/code&gt; is an alias for &lt;code&gt;utf-8-emacs-unix&lt;/code&gt; (so it forces no conversion of end-of-line, unlike &lt;code&gt;utf-8-emacs&lt;/code&gt;, which can decode all 3 kinds of end-of-line conventions).</source>
          <target state="translated">코딩 시스템 &lt;code&gt;utf-8-emacs&lt;/code&gt; 는 데이터가 내부 Emacs 인코딩으로 표현되도록 지정합니다 ( &lt;a href=&quot;text-representations#Text-Representations&quot;&gt;텍스트 표현&lt;/a&gt; 참조 ). 이것은 코드 변환이 발생하지 않는다는 점에서 &lt;code&gt;raw-text&lt;/code&gt; 와 같지만 결과가 멀티 바이트 데이터라는 점에서 다릅니다. 이름 &lt;code&gt;emacs-internal&lt;/code&gt; 은 &lt;code&gt;utf-8-emacs-unix&lt;/code&gt; 의 별칭입니다 (따라서 3 가지 종류의 줄 끝 규칙을 모두 디코딩 할 수있는 &lt;code&gt;utf-8-emacs&lt;/code&gt; 와는 달리 줄 끝 변환을 강제하지 않음 ) .</target>
        </trans-unit>
        <trans-unit id="b7a3e069788fc7a93ce66f5716c9ee69180ec9a7" translate="yes" xml:space="preserve">
          <source>The color for the border of the frame. It is equivalent to the &lt;code&gt;:background&lt;/code&gt; attribute of the &lt;code&gt;border&lt;/code&gt; face.</source>
          <target state="translated">프레임 테두리의 색상입니다. &lt;code&gt;border&lt;/code&gt; 의 &lt;code&gt;:background&lt;/code&gt; 속성과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="557d8af098a8640c6edfc6b2f65704a4cfb3bb1c" translate="yes" xml:space="preserve">
          <source>The color for the cursor that shows point. It is equivalent to the &lt;code&gt;:background&lt;/code&gt; attribute of the &lt;code&gt;cursor&lt;/code&gt; face.</source>
          <target state="translated">포인트를 표시하는 커서의 색상입니다. &lt;code&gt;cursor&lt;/code&gt; 면 의 &lt;code&gt;:background&lt;/code&gt; 속성과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="848f3a5cc67c97c12f59ed548791f5c7b9603605" translate="yes" xml:space="preserve">
          <source>The color for the mouse pointer. It is equivalent to the &lt;code&gt;:background&lt;/code&gt; attribute of the &lt;code&gt;mouse&lt;/code&gt; face.</source>
          <target state="translated">마우스 포인터의 색상입니다. &lt;code&gt;mouse&lt;/code&gt; 얼굴 의 &lt;code&gt;:background&lt;/code&gt; 속성과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="cd4a78191273afbed89fbc376fb0e490d94f3411" translate="yes" xml:space="preserve">
          <source>The color of lines drawn, and outlines around solid shapes.</source>
          <target state="translated">그려진 선의 색상과 단색 모양 주위의 윤곽선입니다.</target>
        </trans-unit>
        <trans-unit id="6dae735cc9d80db3034a398a30474af4088c1839" translate="yes" xml:space="preserve">
          <source>The color to use for the background of characters. It is equivalent to the &lt;code&gt;:background&lt;/code&gt; attribute of the &lt;code&gt;default&lt;/code&gt; face.</source>
          <target state="translated">문자 배경에 사용할 색상입니다. &lt;code&gt;default&lt;/code&gt; 얼굴 의 &lt;code&gt;:background&lt;/code&gt; 속성과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="01cf8df4bfb8df2b7d863a7131e6cc6356c0739b" translate="yes" xml:space="preserve">
          <source>The color to use for the image of a character. It is equivalent to the &lt;code&gt;:foreground&lt;/code&gt; attribute of the &lt;code&gt;default&lt;/code&gt; face.</source>
          <target state="translated">캐릭터 이미지에 사용할 색상입니다. &lt;code&gt;default&lt;/code&gt; 얼굴 의 &lt;code&gt;:foreground&lt;/code&gt; 속성과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="3093a0d9fd7e9a7555a91efc7023426af982bf7e" translate="yes" xml:space="preserve">
          <source>The color used for solid shapes.</source>
          <target state="translated">단색 모양에 사용되는 색상입니다.</target>
        </trans-unit>
        <trans-unit id="f926aaaf6e9ed7105210907467a7575bcbfb622b" translate="yes" xml:space="preserve">
          <source>The color values are returned for &lt;var&gt;frame&lt;/var&gt;&amp;rsquo;s display. If &lt;var&gt;frame&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt;, the information is returned for the selected frame&amp;rsquo;s display. If the frame cannot display colors, the value is &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;frame&lt;/var&gt; 표시를 위해 색상 값이 반환 됩니다. 경우 &lt;var&gt;frame&lt;/var&gt; 생략되거나 &lt;code&gt;nil&lt;/code&gt; , 정보는 상기 선택된 프레임의 표시를 리턴한다. 프레임이 색상을 표시 할 수없는 경우 값은 &lt;code&gt;nil&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0108b0958456a06b2b6bdb6b65f07e2c22074864" translate="yes" xml:space="preserve">
          <source>The column at which to fill warnings.</source>
          <target state="translated">경고를 채울 열입니다.</target>
        </trans-unit>
        <trans-unit id="c886ad6405a0592fa55644a3f4e64f01c567410f" translate="yes" xml:space="preserve">
          <source>The column functions convert between a character position (counting characters from the beginning of the buffer) and a column position (counting screen characters from the beginning of a line).</source>
          <target state="translated">열 함수는 문자 위치 (버퍼 시작 부분에서 문자 계산)와 열 위치 (줄 시작 부분에서 화면 문자 계산) 사이를 변환합니다.</target>
        </trans-unit>
        <trans-unit id="56f303b08f0089973ebdd5308c9f98921ddba9d4" translate="yes" xml:space="preserve">
          <source>The column number currently displayed in this window&amp;rsquo;s mode line, or -1 if column numbers are not being displayed.</source>
          <target state="translated">현재이 창의 모드 행에 표시된 열 번호 또는 열 번호가 표시되지 않는 경우 -1입니다.</target>
        </trans-unit>
        <trans-unit id="82c351222697abcc62b85c531b3382118709b682" translate="yes" xml:space="preserve">
          <source>The column to be used for top-level constructs. This replaces the default value of the top-level column used by the sub-mode, usually zero.</source>
          <target state="translated">최상위 구성에 사용할 열입니다. 이는 하위 모드에서 사용하는 최상위 열의 기본값 (일반적으로 0)을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="ad930e366f047e47ba168bb838f08a3c092549df" translate="yes" xml:space="preserve">
          <source>The combination limit is meaningful only for an internal window. If it is &lt;code&gt;nil&lt;/code&gt;, then Emacs is allowed to automatically delete &lt;var&gt;window&lt;/var&gt;, in response to a window deletion, in order to group the child windows of &lt;var&gt;window&lt;/var&gt; with its sibling windows to form a new window combination. If the combination limit is &lt;code&gt;t&lt;/code&gt;, the child windows of &lt;var&gt;window&lt;/var&gt; are never automatically recombined with its siblings.</source>
          <target state="translated">조합 제한은 내부 창에 대해서만 의미가 있습니다. 그것이 &lt;code&gt;nil&lt;/code&gt; 이면, Emacs는 윈도우 삭제에 대한 응답으로 &lt;var&gt;window&lt;/var&gt; 를 자동으로 삭제하도록 허용되어 새로운 윈도우 조합을 형성하기 위해 형제 &lt;var&gt;window&lt;/var&gt; 와 함께 윈도우의 자식 윈도우를 그룹화합니다 . 조합 제한이 &lt;code&gt;t&lt;/code&gt; 이면 &lt;var&gt;window&lt;/var&gt; 의 자식 창이 형제와 자동으로 다시 결합되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="062e4ea98a9662fe6dca5fb34a40a037aa606eb5" translate="yes" xml:space="preserve">
          <source>The command</source>
          <target state="translated">명령</target>
        </trans-unit>
        <trans-unit id="c1ffc1e3bfdf70f5721200a30a9b90345bdd4e1b" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;display-buffer&lt;/code&gt; flexibly chooses a window for display, and displays a specified buffer in that window. It can be called interactively, via the key binding</source>
          <target state="translated">&lt;code&gt;display-buffer&lt;/code&gt; 명령은 표시 할 창을 유연하게 선택하고 해당 창에 지정된 버퍼를 표시합니다. 키 바인딩을 통해 대화식으로 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d859d82af47e88b2e948fdd51d7bfa313a3eb5d" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;eval-region&lt;/code&gt; updates &lt;code&gt;load-history&lt;/code&gt;, but does so by adding the symbols defined to the element for the file being visited, rather than replacing that element. See &lt;a href=&quot;eval#Eval&quot;&gt;Eval&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;eval-region&lt;/code&gt; 명령은 &lt;code&gt;load-history&lt;/code&gt; 를 업데이트 하지만 해당 요소를 대체하는 대신 방문중인 파일의 요소에 정의 된 기호를 추가하여 업데이트합니다 . &lt;a href=&quot;eval#Eval&quot;&gt;Eval을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6a4fcc51ef457cdf0b2de9d77b741a0669273953" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;switch-to-next-buffer&lt;/code&gt; obeys this option in a similar way. If this option specifies a function, &lt;code&gt;switch-to-next-buffer&lt;/code&gt; will call that function with the third argument always &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;switch-to-next-buffer&lt;/code&gt; 명령 은 비슷한 방식으로이 옵션을 따릅니다. 이 옵션이 함수를 지정하면 &lt;code&gt;switch-to-next-buffer&lt;/code&gt; 는 항상 &lt;code&gt;nil&lt;/code&gt; 세 번째 인수를 사용하여 해당 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="f1bcbea4d3e3a2d7b364ec9e0f15ad7ae8da1bbb" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;temacs&amp;nbsp;-l&amp;nbsp;loadup&lt;/code&gt; would run</source>
          <target state="translated">&lt;code&gt;temacs&amp;nbsp;-l&amp;nbsp;loadup&lt;/code&gt; 명령 이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="ae164833eafad23104809bf29a295b984c817efa" translate="yes" xml:space="preserve">
          <source>The command &lt;var&gt;fname&lt;/var&gt; is defined to handle a few events itself, by scrolling the display of &lt;var&gt;help-text&lt;/var&gt;. When &lt;var&gt;fname&lt;/var&gt; reads one of those special events, it does the scrolling and then reads another event. When it reads an event that is not one of those few, and which has a binding in &lt;var&gt;help-map&lt;/var&gt;, it executes that key&amp;rsquo;s binding and then returns.</source>
          <target state="translated">&lt;var&gt;fname&lt;/var&gt; 명령 은 &lt;var&gt;help-text&lt;/var&gt; 표시를 스크롤하여 몇 가지 이벤트 자체를 처리하도록 정의됩니다 . &lt;var&gt;fname&lt;/var&gt; 이 이러한 특수 이벤트 중 하나를 읽을 때 스크롤을 수행 한 다음 다른 이벤트를 읽습니다. 몇 안되는 이벤트 중 하나가 아니고 &lt;var&gt;help-map&lt;/var&gt; 에 바인딩이있는 이벤트를 읽으면 해당 키의 바인딩을 실행 한 다음 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bc4bc33db4d6985e9ffe7472f3118727adcea411" translate="yes" xml:space="preserve">
          <source>The command bindings of input events are recorded in data structures called &lt;em&gt;keymaps&lt;/em&gt;. Each entry in a keymap associates (or &lt;em&gt;binds&lt;/em&gt;) an individual event type, either to another keymap or to a command. When an event type is bound to a keymap, that keymap is used to look up the next input event; this continues until a command is found. The whole process is called &lt;em&gt;key lookup&lt;/em&gt;.</source>
          <target state="translated">입력 이벤트의 명령 바인딩은 &lt;em&gt;키맵&lt;/em&gt; 이라고하는 데이터 구조에 기록됩니다 . 키맵의 각 항목 은 개별 이벤트 유형을 다른 키맵이나 명령에 연결 (또는 &lt;em&gt;바인딩&lt;/em&gt; )합니다. 이벤트 유형이 키맵에 바인딩되면 해당 키맵은 다음 입력 이벤트를 찾는 데 사용됩니다. 이것은 명령을 찾을 때까지 계속됩니다. 전체 프로세스를 &lt;em&gt;키 조회&lt;/em&gt; 라고 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e3a0644779d0a1f335811ac6b8e7f487869da769" translate="yes" xml:space="preserve">
          <source>The command does not set &lt;code&gt;this-command&lt;/code&gt; to &lt;code&gt;kill-region&lt;/code&gt;, so a subsequent kill command does not append to the same kill ring entry.</source>
          <target state="translated">이 명령은 &lt;code&gt;this-command&lt;/code&gt; 을 &lt;code&gt;kill-region&lt;/code&gt; 으로 설정하지 않으므로 후속 kill 명령은 동일한 kill ring 항목에 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="54ccd859ab08a7578c2accb2c8a5c8536ee5433a" translate="yes" xml:space="preserve">
          <source>The command loop keeps a history of the complex commands that have been executed, to make it convenient to repeat these commands. A &lt;em&gt;complex command&lt;/em&gt; is one for which the interactive argument reading uses the minibuffer. This includes any</source>
          <target state="translated">명령 루프는 실행 된 복잡한 명령의 기록을 유지하므로 이러한 명령을 편리하게 반복 할 수 있습니다. &lt;em&gt;복잡한 명령은&lt;/em&gt; 대화 형 인수 읽기가 미니 버퍼를 사용하는 것입니다. 여기에는</target>
        </trans-unit>
        <trans-unit id="7d8344b6378db1df6e46b16defc05a1c3460ae23" translate="yes" xml:space="preserve">
          <source>The command loop reads input a key sequence at a time, by calling &lt;code&gt;read-key-sequence&lt;/code&gt;. Lisp programs can also call this function; for example, &lt;code&gt;describe-key&lt;/code&gt; uses it to read the key to describe.</source>
          <target state="translated">명령 루프는 &lt;code&gt;read-key-sequence&lt;/code&gt; 를 호출하여 한 번에 키 시퀀스 입력을 읽습니다 . Lisp 프로그램은이 함수를 호출 할 수도 있습니다. 예를 들어 &lt;code&gt;describe-key&lt;/code&gt; 는이를 사용하여 설명 할 키를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="2ee88eb3cbfec06fb2f79be62a80a793ed81d1f4" translate="yes" xml:space="preserve">
          <source>The command loop runs this soon after &lt;code&gt;post-command-hook&lt;/code&gt; (q.v.).</source>
          <target state="translated">명령 루프는 &lt;code&gt;post-command-hook&lt;/code&gt; (qv) 직후에이를 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="b3556e9617ebdac53a98e97a52551b0c1b562ba7" translate="yes" xml:space="preserve">
          <source>The command loop sets this variable just before running a command, and copies its value into &lt;code&gt;last-command&lt;/code&gt; when the command finishes (unless the command specified a prefix argument for the following command).</source>
          <target state="translated">명령 루프는 명령을 실행하기 직전에이 변수를 설정 하고 명령이 완료 될 때 해당 값을 &lt;code&gt;last-command&lt;/code&gt; 에 복사 합니다 (명령이 다음 명령에 대한 접두사 인수를 지정하지 않은 경우).</target>
        </trans-unit>
        <trans-unit id="2055d37028ddd0c472cbfc94f6b67d5fdd69b086" translate="yes" xml:space="preserve">
          <source>The command loop sets this variable to &lt;code&gt;nil&lt;/code&gt; before each command, so if a command sets it, the effect applies only to that command.</source>
          <target state="translated">명령 루프는 각 명령 전에이 변수를 &lt;code&gt;nil&lt;/code&gt; 로 설정하므로 명령이이를 설정하면 해당 명령에만 효과가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="543a4b162ec103c275db3895fe55421dc42ccd27" translate="yes" xml:space="preserve">
          <source>The command named &lt;var&gt;mode&lt;/var&gt; first performs the standard actions such as setting the variable named &lt;var&gt;mode&lt;/var&gt; and then executes the &lt;var&gt;body&lt;/var&gt; forms, if any. It then runs the mode hook variable &lt;code&gt;&lt;var&gt;mode&lt;/var&gt;-hook&lt;/code&gt; and finishes by evaluating any form in &lt;code&gt;:after-hook&lt;/code&gt;.</source>
          <target state="translated">명령이라는 &lt;var&gt;mode&lt;/var&gt; 이러한 변수의 이름으로 설정 한 제 수행 표준 작업 &lt;var&gt;mode&lt;/var&gt; 실행 다음과 &lt;var&gt;body&lt;/var&gt; 가있는 경우, 형태. 그런 다음 모드 후크 변수 &lt;code&gt;&lt;var&gt;mode&lt;/var&gt;-hook&lt;/code&gt; 을 실행하고 &lt;code&gt;:after-hook&lt;/code&gt; 의 모든 양식을 평가하여 완료합니다 .</target>
        </trans-unit>
        <trans-unit id="4c1e16025c68e4172d32866b90a4de49e795379d" translate="yes" xml:space="preserve">
          <source>The command which is finally found might also be remapped. See &lt;a href=&quot;remapping-commands#Remapping-Commands&quot;&gt;Remapping Commands&lt;/a&gt;.</source>
          <target state="translated">마지막으로 발견 된 명령도 다시 매핑 될 수 있습니다. &lt;a href=&quot;remapping-commands#Remapping-Commands&quot;&gt;다시 매핑 명령을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="46d5686bfeb21ae9e75f3e0cd9110b273ca126ba" translate="yes" xml:space="preserve">
          <source>The command-line arguments are parsed by the &lt;code&gt;command-line-1&lt;/code&gt; function in the</source>
          <target state="translated">명령 줄 인수는 다음의 &lt;code&gt;command-line-1&lt;/code&gt; 함수에 의해 구문 분석됩니다 .</target>
        </trans-unit>
        <trans-unit id="3e89f0f5629d43551a732205c85f87087a894dfc" translate="yes" xml:space="preserve">
          <source>The command-line option &amp;lsquo;</source>
          <target state="translated">명령 줄 옵션 '</target>
        </trans-unit>
        <trans-unit id="33be2dffe066118290e67b49b508bdbeb6703d32" translate="yes" xml:space="preserve">
          <source>The command-line switches &amp;lsquo;</source>
          <target state="translated">명령 줄 스위치 '</target>
        </trans-unit>
        <trans-unit id="d45c8a3739b868f95df9b38858cd8d04f287a037" translate="yes" xml:space="preserve">
          <source>The command-line with which the process was invoked. This is a string in which individual command-line arguments are separated by blanks; whitespace characters that are embedded in the arguments are quoted as appropriate for the system&amp;rsquo;s shell: escaped by backslash characters on GNU and Unix, and enclosed in double quote characters on Windows. Thus, this command-line string can be directly used in primitives such as &lt;code&gt;shell-command&lt;/code&gt;.</source>
          <target state="translated">프로세스가 호출 된 명령 줄입니다. 이것은 개별 명령 행 인수가 공백으로 구분되는 문자열입니다. 인수에 포함 된 공백 문자는 시스템의 셸에 맞게 인용됩니다. GNU 및 Unix에서는 백 슬래시 문자로 이스케이프되고 Windows에서는 큰 따옴표로 묶입니다. 따라서이 명령 줄 문자열은 &lt;code&gt;shell-command&lt;/code&gt; 와 같은 기본 형식에서 직접 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="37c706527add4d02a59532cb46df5b7b130d04de" translate="yes" xml:space="preserve">
          <source>The commands available during recursive editing are the same ones available in the top-level editing loop and defined in the keymaps. Only a few special commands exit the recursive editing level; the others return to the recursive editing level when they finish. (The special commands for exiting are always available, but they do nothing when recursive editing is not in progress.)</source>
          <target state="translated">재귀 편집 중에 사용할 수있는 명령은 최상위 편집 루프에서 사용할 수 있고 키맵에 정의 된 것과 동일합니다. 몇 가지 특수 명령 만 재귀 편집 수준을 종료합니다. 나머지는 완료되면 재귀 편집 수준으로 돌아갑니다. (종료를위한 특수 명령은 항상 사용할 수 있지만 재귀 편집이 진행되지 않을 때는 아무 작업도 수행하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="a23d2cd639852ecd94cb9df3ddff9d5bd174b632" translate="yes" xml:space="preserve">
          <source>The commands described below can filter the killed text before they save it in the kill ring. They call &lt;code&gt;filter-buffer-substring&lt;/code&gt; (see &lt;a href=&quot;buffer-contents#Buffer-Contents&quot;&gt;Buffer Contents&lt;/a&gt;) to perform the filtering. By default, there&amp;rsquo;s no filtering, but major and minor modes and hook functions can set up filtering, so that text saved in the kill ring is different from what was in the buffer.</source>
          <target state="translated">아래에 설명 된 명령은 킬 링에 저장하기 전에 죽은 텍스트를 필터링 할 수 있습니다. 필터링을 수행하기 위해 &lt;code&gt;filter-buffer-substring&lt;/code&gt; ( &lt;a href=&quot;buffer-contents#Buffer-Contents&quot;&gt;Buffer Contents&lt;/a&gt; 참조 )을 호출 합니다. 기본적으로 필터링은 없지만 메이저 및 마이너 모드와 후크 기능은 필터링을 설정할 수 있으므로 킬 링에 저장된 텍스트가 버퍼에 있던 텍스트와 다릅니다.</target>
        </trans-unit>
        <trans-unit id="c7a1c8fbb62ae35db0fb700fa5a7a715258f8d84" translate="yes" xml:space="preserve">
          <source>The commands described in this section execute until they reach a specified location. All except</source>
          <target state="translated">이 섹션에서 설명하는 명령은 지정된 위치에 도달 할 때까지 실행됩니다. 모두 제외</target>
        </trans-unit>
        <trans-unit id="f7cca3dbc4a5e525b42888654a2250e48c3c88c9" translate="yes" xml:space="preserve">
          <source>The comment lines show that &lt;code&gt;fac&lt;/code&gt; was called 6 times. The first &lt;code&gt;if&lt;/code&gt; statement returned 5 times with the same result each time; the same is true of the condition on the second &lt;code&gt;if&lt;/code&gt;. The recursive call of &lt;code&gt;fac&lt;/code&gt; did not return at all.</source>
          <target state="translated">주석 행은 &lt;code&gt;fac&lt;/code&gt; 이 6 번 호출 되었음을 보여줍니다 . 첫 번째 &lt;code&gt;if&lt;/code&gt; 문은 매번 동일한 결과로 5 번 반환되었습니다. 동일한 두 번째의 조건에 해당하는 &lt;code&gt;if&lt;/code&gt; . &lt;code&gt;fac&lt;/code&gt; 의 재귀 호출 이 전혀 반환되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="0e2b64e2042c9eae11df7bbc9d8da126ed6518b7" translate="yes" xml:space="preserve">
          <source>The communication type and the process filter and sentinel are inherited from those of the server. The server never directly uses its filter and sentinel; their sole purpose is to initialize connections made to the server.</source>
          <target state="translated">통신 유형과 프로세스 필터 및 센티널은 서버의 유형으로부터 상속됩니다. 서버는 필터와 센티넬을 직접 사용하지 않습니다. 유일한 목적은 서버에 대한 연결을 초기화하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="afd81d64f2d80486e0d6f037979b681c7c67b5c5" translate="yes" xml:space="preserve">
          <source>The comparison function &lt;var&gt;predicate&lt;/var&gt; must give reliable results for any given pair of arguments, at least within a single call to &lt;code&gt;sort&lt;/code&gt;. It must be &lt;em&gt;antisymmetric&lt;/em&gt;; that is, if &lt;var&gt;a&lt;/var&gt; is less than &lt;var&gt;b&lt;/var&gt;, &lt;var&gt;b&lt;/var&gt; must not be less than &lt;var&gt;a&lt;/var&gt;. It must be &lt;em&gt;transitive&lt;/em&gt;&amp;mdash;that is, if &lt;var&gt;a&lt;/var&gt; is less than &lt;var&gt;b&lt;/var&gt;, and &lt;var&gt;b&lt;/var&gt; is less than &lt;var&gt;c&lt;/var&gt;, then &lt;var&gt;a&lt;/var&gt; must be less than &lt;var&gt;c&lt;/var&gt;. If you use a comparison function which does not meet these requirements, the result of &lt;code&gt;sort&lt;/code&gt; is unpredictable.</source>
          <target state="translated">비교 함수 &lt;var&gt;predicate&lt;/var&gt; 는 최소한 &lt;code&gt;sort&lt;/code&gt; 에 대한 단일 호출 내에서 주어진 인수 쌍에 대해 신뢰할 수있는 결과를 제공해야합니다 . &lt;em&gt;비대칭&lt;/em&gt; 이어야합니다 . 경우, 즉, &lt;var&gt;a&lt;/var&gt; 미만인 &lt;var&gt;b&lt;/var&gt; , &lt;var&gt;b&lt;/var&gt; 이하가 아니어야 . 이 있어야 &lt;em&gt;이행&lt;/em&gt; 하면 저거이고 &lt;var&gt;a&lt;/var&gt; 이하이고 &lt;var&gt;b&lt;/var&gt; 및 &lt;var&gt;b&lt;/var&gt; 이하이고 &lt;var&gt;c&lt;/var&gt; 하고 &lt;var&gt;a&lt;/var&gt; 보다 작아야 &lt;var&gt;c&lt;/var&gt; . 이러한 요구 사항을 충족하지 않는 비교 함수를 사용하면 &lt;code&gt;sort&lt;/code&gt; 결과를 예측할 수 없습니다. &lt;var&gt;a&lt;/var&gt; &lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b8af95aafe57d945cb1c3d7b18f42da5e30f98c5" translate="yes" xml:space="preserve">
          <source>The compiler ignores the &lt;code&gt;provide&lt;/code&gt;, then processes the &lt;code&gt;require&lt;/code&gt; by loading the file in question. Loading the file does execute the &lt;code&gt;provide&lt;/code&gt; call, so the subsequent &lt;code&gt;require&lt;/code&gt; call does nothing when the file is loaded.</source>
          <target state="translated">컴파일러는 &lt;code&gt;provide&lt;/code&gt; 를 무시한 다음 해당 파일을로드하여 &lt;code&gt;require&lt;/code&gt; 을 처리합니다 . 파일을로드하면 &lt;code&gt;provide&lt;/code&gt; 호출 이 실행 되므로 후속 &lt;code&gt;require&lt;/code&gt; 호출은 파일이로드 될 때 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="83b388904b97e9f960dfa5b394422e2b5894fab3" translate="yes" xml:space="preserve">
          <source>The completion function should accept three arguments:</source>
          <target state="translated">완료 함수는 세 가지 인수를 받아야합니다.</target>
        </trans-unit>
        <trans-unit id="0b6b092d0c4ac01b5f509dc38513b84d822a2a94" translate="yes" xml:space="preserve">
          <source>The complexities stem from the modifier bits that keyboard input characters can include. Aside from the Meta modifier, none of these modifier bits can be included in a string, and the Meta modifier is allowed only in special cases.</source>
          <target state="translated">복잡성은 키보드 입력 문자에 포함될 수있는 수정 자 비트에서 비롯됩니다. Meta 수정 자 외에 이러한 수정 자 비트는 문자열에 포함될 수 없으며 Meta 수정자는 특별한 경우에만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="84f18eeeb5829282eb800b86f2877e8b64e03deb" translate="yes" xml:space="preserve">
          <source>The components of a marker, and how it relocates.</source>
          <target state="translated">마커의 구성 요소 및 재배치 방법.</target>
        </trans-unit>
        <trans-unit id="27404eab7e82a326e1454e0c0e389aaa34dca41e" translate="yes" xml:space="preserve">
          <source>The concept of raising and lowering frames also applies to text terminal frames. On each text terminal, only the top frame is displayed at any one time.</source>
          <target state="translated">프레임 올리기 및 내리기의 개념은 텍스트 터미널 프레임에도 적용됩니다. 각 텍스트 터미널에서는 한 번에 상단 프레임 만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="cce4579f65c0c37d6850842d7ce1d0a6353f8c71" translate="yes" xml:space="preserve">
          <source>The concept of visibility is strongly related to that of (un-)mapped frames. A frame (or, more precisely, its window-system window) is and becomes &lt;em&gt;mapped&lt;/em&gt; when it is displayed for the first time and whenever it changes its state of visibility from &lt;code&gt;iconified&lt;/code&gt; or &lt;code&gt;invisible&lt;/code&gt; to &lt;code&gt;visible&lt;/code&gt;. Conversely, a frame is and becomes &lt;em&gt;unmapped&lt;/em&gt; whenever it changes its status from &lt;code&gt;visible&lt;/code&gt; to &lt;code&gt;iconified&lt;/code&gt; or &lt;code&gt;invisible&lt;/code&gt;.</source>
          <target state="translated">가시성의 개념은 매핑되지 않은 프레임의 개념과 밀접한 관련이 있습니다. 프레임 (또는보다 정확하게는 윈도우 시스템 창)이고된다 &lt;em&gt;맵핑&lt;/em&gt; 가 처음에 표시 될 때 그 시야의 상태를 변경할 때마다에서 &lt;code&gt;iconified&lt;/code&gt; 또는 &lt;code&gt;invisible&lt;/code&gt; 로 &lt;code&gt;visible&lt;/code&gt; . 역으로, 프레임이고하게 &lt;em&gt;매핑되지 않은&lt;/em&gt; 그것의 상태로 변경 될 때마다 &lt;code&gt;visible&lt;/code&gt; 에 &lt;code&gt;iconified&lt;/code&gt; 또는 &lt;code&gt;invisible&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5676e3bf9106b8a801a2ba7aa8fe6827e6fdc6cf" translate="yes" xml:space="preserve">
          <source>The concise expression of a predicate is known as a &lt;em&gt;pattern&lt;/em&gt;. When the predicate, called on the value of the first arg, returns non-&lt;code&gt;nil&lt;/code&gt;, we say that &amp;ldquo;the pattern matches the value&amp;rdquo; (or sometimes &amp;ldquo;the value matches the pattern&amp;rdquo;).</source>
          <target state="translated">술어의 간결한 표현을 &lt;em&gt;패턴이라고&lt;/em&gt; 합니다. 첫 번째 인수의 값에 대해 호출 된 술어가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 값을 반환 하면 &quot;패턴이 값과 일치&quot;(또는 때때로 &quot;값이 패턴과 일치&quot;)라고 말합니다.</target>
        </trans-unit>
        <trans-unit id="ab15735458ac1022eae759f78cdd057138f6e20d" translate="yes" xml:space="preserve">
          <source>The condition expression is stored in &lt;code&gt;edebug-global-break-condition&lt;/code&gt;. You can specify a new expression using the</source>
          <target state="translated">조건식은 &lt;code&gt;edebug-global-break-condition&lt;/code&gt; 에 저장됩니다 . 다음을 사용하여 새 표현식을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c16f550e5c642194989cb1eb487f94d46efc1764" translate="yes" xml:space="preserve">
          <source>The connection type: &amp;lsquo;</source>
          <target state="translated">연결 유형 : '</target>
        </trans-unit>
        <trans-unit id="467d0ce5daa923b058a0c23d80df3209d2288708" translate="yes" xml:space="preserve">
          <source>The connection&amp;rsquo;s local address is set up according to the port number used for the connection.</source>
          <target state="translated">연결의 로컬 주소는 연결에 사용되는 포트 번호에 따라 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="507cc7aafdf97b09a145788437398e04599af151" translate="yes" xml:space="preserve">
          <source>The connection&amp;rsquo;s process contact information is set according to the client&amp;rsquo;s addressing information (typically an IP address and a port number). This information is associated with the &lt;code&gt;process-contact&lt;/code&gt; keywords &lt;code&gt;:host&lt;/code&gt;, &lt;code&gt;:service&lt;/code&gt;, &lt;code&gt;:remote&lt;/code&gt;.</source>
          <target state="translated">연결의 프로세스 연락처 정보는 클라이언트의 주소 지정 정보 (일반적으로 IP 주소 및 포트 번호)에 따라 설정됩니다. 이 정보는 &lt;code&gt;process-contact&lt;/code&gt; 키워드 &lt;code&gt;:host&lt;/code&gt; , &lt;code&gt;:service&lt;/code&gt; , &lt;code&gt;:remote&lt;/code&gt; 와 연관됩니다 .</target>
        </trans-unit>
        <trans-unit id="4f972d8622119c5748437af2ecceeff29ecea407" translate="yes" xml:space="preserve">
          <source>The connection&amp;rsquo;s process name is constructed by concatenating the server process&amp;rsquo;s &lt;var&gt;name&lt;/var&gt; with a client identification string. The client identification string for an IPv4 connection looks like &amp;lsquo;</source>
          <target state="translated">연결의 프로세스 이름은 서버 프로세스의 &lt;var&gt;name&lt;/var&gt; 을 클라이언트 식별 문자열과 연결하여 구성됩니다 . IPv4 연결을위한 클라이언트 식별 문자열은 '</target>
        </trans-unit>
        <trans-unit id="1e87cd925416db3162f784b538be172c5b7921a1" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;display-buffer-fallback-action&lt;/code&gt;.</source>
          <target state="translated">상수 &lt;code&gt;display-buffer-fallback-action&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c760326f932b523d397cb33aa52ed43c6fb58a0c" translate="yes" xml:space="preserve">
          <source>The construct &amp;lsquo;</source>
          <target state="translated">구조 '</target>
        </trans-unit>
        <trans-unit id="d66f5e853b6924e849795ab495fa453e6e93fd12" translate="yes" xml:space="preserve">
          <source>The contents of a buffer are much like a string, but buffers are not used like strings in Emacs Lisp, and the available operations are different. For example, you can insert text efficiently into an existing buffer, altering the buffer&amp;rsquo;s contents, whereas inserting text into a string requires concatenating substrings, and the result is an entirely new string object.</source>
          <target state="translated">버퍼의 내용은 문자열과 매우 비슷하지만 버퍼는 Emacs Lisp의 문자열처럼 사용되지 않으며 사용 가능한 작업이 다릅니다. 예를 들어, 기존 버퍼에 텍스트를 효율적으로 삽입하여 버퍼의 내용을 변경할 수있는 반면, 문자열에 텍스트를 삽입하려면 하위 문자열을 연결해야하며 결과는 완전히 새로운 문자열 객체입니다.</target>
        </trans-unit>
        <trans-unit id="724d66b7323be904f10391c54dc669a39d58cee1" translate="yes" xml:space="preserve">
          <source>The contents of a documentation string should follow certain conventions. In particular, its first line should be a complete sentence (or two complete sentences) that briefly describes what the function or variable does. See &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/elisp/Documentation-Tips.html#Documentation-Tips&quot;&gt;Documentation Tips&lt;/a&gt;, for how to write good documentation strings.</source>
          <target state="translated">문서 문자열의 내용은 특정 규칙을 따라야합니다. 특히 첫 번째 줄은 함수 나 변수의 기능을 간략하게 설명하는 완전한 문장 (또는 두 개의 완전한 문장)이어야합니다. 좋은 문서 문자열을 작성하는 방법 은 &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/elisp/Documentation-Tips.html#Documentation-Tips&quot;&gt;문서 팁을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="11a8b449d638b416a746d961844b34d3d803a937" translate="yes" xml:space="preserve">
          <source>The contents of each mode line are specified by the buffer-local variable &lt;code&gt;mode-line-format&lt;/code&gt; (see &lt;a href=&quot;mode-line-top#Mode-Line-Top&quot;&gt;Mode Line Top&lt;/a&gt;). This variable holds a &lt;em&gt;mode line construct&lt;/em&gt;: a template that controls what is displayed on the buffer&amp;rsquo;s mode line. The value of &lt;code&gt;header-line-format&lt;/code&gt; specifies the buffer&amp;rsquo;s header line in the same way. All windows for the same buffer use the same &lt;code&gt;mode-line-format&lt;/code&gt; and &lt;code&gt;header-line-format&lt;/code&gt; unless a &lt;code&gt;mode-line-format&lt;/code&gt; or &lt;code&gt;header-line-format&lt;/code&gt; parameter has been specified for that window (see &lt;a href=&quot;window-parameters#Window-Parameters&quot;&gt;Window Parameters&lt;/a&gt;).</source>
          <target state="translated">각 모드 행의 내용은 버퍼 로컬 변수 &lt;code&gt;mode-line-format&lt;/code&gt; 에 의해 지정됩니다 ( &lt;a href=&quot;mode-line-top#Mode-Line-Top&quot;&gt;Mode Line Top&lt;/a&gt; 참조 ). 이 변수는 버퍼의 모드 라인에 표시되는 것을 제어하는 ​​템플릿 인 &lt;em&gt;모드 라인 구성을&lt;/em&gt; 보유합니다 . &lt;code&gt;header-line-format&lt;/code&gt; 의 값은 동일한 방식으로 버퍼의 헤더 행을 지정합니다. 동일한 버퍼에 대한 모든 창은 해당 창에 대해 &lt;code&gt;mode-line-format&lt;/code&gt; 또는 &lt;code&gt;header-line-format&lt;/code&gt; 매개 변수가 지정 되지 않은 한 동일한 &lt;code&gt;mode-line-format&lt;/code&gt; 및 &lt;code&gt;header-line-format&lt;/code&gt; 을 사용합니다 ( &lt;a href=&quot;window-parameters#Window-Parameters&quot;&gt;Window 매개 변수&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="6cce8467dc72be542e217587e79031715ed7a080" translate="yes" xml:space="preserve">
          <source>The contents of the function cell are also called the symbol&amp;rsquo;s &lt;em&gt;function definition&lt;/em&gt;. The procedure of using a symbol&amp;rsquo;s function definition in place of the symbol is called &lt;em&gt;symbol function indirection&lt;/em&gt;; see &lt;a href=&quot;function-indirection#Function-Indirection&quot;&gt;Function Indirection&lt;/a&gt;. If you have not given a symbol a function definition, its function cell is said to be &lt;em&gt;void&lt;/em&gt;, and it cannot be used as a function.</source>
          <target state="translated">기능 셀의 내용을 기호의 &lt;em&gt;기능 정의&lt;/em&gt; 라고도합니다 . 기호 대신 기호의 함수 정의를 사용하는 절차를 &lt;em&gt;기호 함수 간접&lt;/em&gt; 이라고 &lt;em&gt;합니다&lt;/em&gt; . &lt;a href=&quot;function-indirection#Function-Indirection&quot;&gt;함수 간접&lt;/a&gt; 참조 . 기호에 함수 정의를 지정하지 않은 경우 해당 함수 셀은 &lt;em&gt;void&lt;/em&gt; 라고하며 함수로 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9370f04a5544f51098edcb0f278d5570b1dac651" translate="yes" xml:space="preserve">
          <source>The control modifier.</source>
          <target state="translated">제어 수정 자입니다.</target>
        </trans-unit>
        <trans-unit id="aceb7a603d154f5ad7c647717d25306dce220852" translate="yes" xml:space="preserve">
          <source>The convenient way to track the mouse is to ask for events to represent mouse motion. Then you can wait for motion by waiting for an event. In addition, you can easily handle any other sorts of events that may occur. That is useful, because normally you don&amp;rsquo;t want to track the mouse forever&amp;mdash;only until some other event, such as the release of a button.</source>
          <target state="translated">마우스를 추적하는 편리한 방법은 마우스 동작을 나타내는 이벤트를 요청하는 것입니다. 그런 다음 이벤트를 기다리면서 동작을 기다릴 수 있습니다. 또한 발생할 수있는 다른 종류의 이벤트를 쉽게 처리 할 수 ​​있습니다. 이는 일반적으로 마우스를 영원히 추적하지 않고 버튼을 놓는 것과 같은 다른 이벤트가 발생할 때까지만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="793961ad223ddf2c3c519ec760da74fb582fe7a6" translate="yes" xml:space="preserve">
          <source>The coordinate arguments &lt;var&gt;frompos&lt;/var&gt; and &lt;var&gt;topos&lt;/var&gt; are cons cells of the form &lt;code&gt;(&lt;var&gt;hpos&lt;/var&gt; . &lt;var&gt;vpos&lt;/var&gt;)&lt;/code&gt;.</source>
          <target state="translated">좌표 인수 &lt;var&gt;frompos&lt;/var&gt; 및 &lt;var&gt;topos&lt;/var&gt; 는 &lt;code&gt;(&lt;var&gt;hpos&lt;/var&gt; . &lt;var&gt;vpos&lt;/var&gt;)&lt;/code&gt; 형식의 cons 셀입니다 .</target>
        </trans-unit>
        <trans-unit id="9db5eb46de2221425799aa8da6390edce63ae470" translate="yes" xml:space="preserve">
          <source>The coordinates are in the divider separating &lt;var&gt;window&lt;/var&gt; from a window beneath.</source>
          <target state="translated">좌표는 분리 분배기에 &lt;var&gt;window&lt;/var&gt; 아래에 창.</target>
        </trans-unit>
        <trans-unit id="6affe00f007f6996f29826150462b2973fdef994" translate="yes" xml:space="preserve">
          <source>The coordinates are in the divider separating &lt;var&gt;window&lt;/var&gt; from a window on the right.</source>
          <target state="translated">좌표는 오른쪽 창과 &lt;var&gt;window&lt;/var&gt; 을 구분하는 구분선 에 있습니다.</target>
        </trans-unit>
        <trans-unit id="32afd0d0bc1d682d09fba69eb4617c10c78505bb" translate="yes" xml:space="preserve">
          <source>The coordinates are in the header line of &lt;var&gt;window&lt;/var&gt;.</source>
          <target state="translated">좌표는 &lt;var&gt;window&lt;/var&gt; 의 헤더 라인에 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bd8e5163c2e5b18cd3fb5701dd235e3c1ebcec62" translate="yes" xml:space="preserve">
          <source>The coordinates are in the left or right fringe of the window.</source>
          <target state="translated">좌표는 창의 왼쪽 또는 오른쪽 가장자리에 있습니다.</target>
        </trans-unit>
        <trans-unit id="c738efd1b8fc20e939382319a3f95f8982d7b37a" translate="yes" xml:space="preserve">
          <source>The coordinates are in the left or right margin of the window.</source>
          <target state="translated">좌표는 창의 왼쪽 또는 오른쪽 여백에 있습니다.</target>
        </trans-unit>
        <trans-unit id="0cd27cf4656eb11e9fa2ca9618c8c00a5670e522" translate="yes" xml:space="preserve">
          <source>The coordinates are in the mode line of &lt;var&gt;window&lt;/var&gt;.</source>
          <target state="translated">좌표는 &lt;var&gt;window&lt;/var&gt; 모드 라인에 있습니다 .</target>
        </trans-unit>
        <trans-unit id="40b852e52258e1ed5fab2ee2299205f8ece29d1f" translate="yes" xml:space="preserve">
          <source>The coordinates are in the tab line of &lt;var&gt;window&lt;/var&gt;.</source>
          <target state="translated">좌표는 &lt;var&gt;window&lt;/var&gt; 탭 라인에 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c1a54627ce98dd91ddd99bb3fd351fc372636186" translate="yes" xml:space="preserve">
          <source>The coordinates are in the vertical line between &lt;var&gt;window&lt;/var&gt; and its neighbor to the right. This value occurs only if the window doesn&amp;rsquo;t have a scroll bar; positions in a scroll bar are considered outside the window for these purposes.</source>
          <target state="translated">좌표는 &lt;var&gt;window&lt;/var&gt; 오른쪽 이웃 사이의 수직선 에 있습니다. 이 값은 창에 스크롤 막대가없는 경우에만 발생합니다. 이러한 목적을 위해 스크롤 막대의 위치는 창 외부에있는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="b07ce1b12e208ef1aeb507e1116a4d5c9d8ef12e" translate="yes" xml:space="preserve">
          <source>The coordinates are inside &lt;var&gt;window&lt;/var&gt;. The numbers &lt;var&gt;relx&lt;/var&gt; and &lt;var&gt;rely&lt;/var&gt; are the equivalent window-relative coordinates for the specified position, counting from 0 at the top left corner of the window.</source>
          <target state="translated">좌표는 &lt;var&gt;window&lt;/var&gt; 안에 있습니다 . &lt;var&gt;relx&lt;/var&gt; 및 &lt;var&gt;rely&lt;/var&gt; 숫자 는 지정된 위치에 대한 동등한 창 상대 좌표이며 창의 왼쪽 상단 모서리에있는 0부터 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="3dab1b30075b2eaf66dc2d863b82b8873a9110f1" translate="yes" xml:space="preserve">
          <source>The coordinates are not in any part of &lt;var&gt;window&lt;/var&gt;.</source>
          <target state="translated">좌표는 &lt;var&gt;window&lt;/var&gt; 어떤 부분에도 없습니다 .</target>
        </trans-unit>
        <trans-unit id="6fbb6d2c4c5aa83c923375a4275035683805d5d9" translate="yes" xml:space="preserve">
          <source>The correspondences in a hash table are in no particular order.</source>
          <target state="translated">해시 테이블의 대응은 특별한 순서가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="aa3cbc5742428a7ca49d61d3c1ddaa3f048dcbae" translate="yes" xml:space="preserve">
          <source>The current buffer is restored even in case of an abnormal exit via &lt;code&gt;throw&lt;/code&gt; or error (see &lt;a href=&quot;nonlocal-exits#Nonlocal-Exits&quot;&gt;Nonlocal Exits&lt;/a&gt;).</source>
          <target state="translated">현재 버퍼는 &lt;code&gt;throw&lt;/code&gt; 또는 오류 를 통해 비정상적으로 종료 된 경우에도 복원됩니다 ( &lt;a href=&quot;nonlocal-exits#Nonlocal-Exits&quot;&gt;Nonlocal Exit&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="49ecbd424345bde3e4a4691932210becf3443056" translate="yes" xml:space="preserve">
          <source>The current buffer name, obtained with the &lt;code&gt;buffer-name&lt;/code&gt; function. See &lt;a href=&quot;buffer-names#Buffer-Names&quot;&gt;Buffer Names&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;buffer-name&lt;/code&gt; 함수로 얻은 현재 버퍼 이름 . &lt;a href=&quot;buffer-names#Buffer-Names&quot;&gt;버퍼 이름을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="93560fb8fbc083bf5b1817cfce168271a106cae0" translate="yes" xml:space="preserve">
          <source>The current column number of point, counting from one starting at the left margin of the window.</source>
          <target state="translated">창의 왼쪽 여백에서 시작하는 포인트의 현재 열 번호입니다.</target>
        </trans-unit>
        <trans-unit id="37bb7b86b993d6605fefad8b3d7df6dd2fc08c56" translate="yes" xml:space="preserve">
          <source>The current column number of point, counting from zero starting at the left margin of the window.</source>
          <target state="translated">창의 왼쪽 여백에서 시작하여 0부터 계산하는 포인트의 현재 열 번호입니다.</target>
        </trans-unit>
        <trans-unit id="21e20a260365897194b21ccb677ca7dc72919de4" translate="yes" xml:space="preserve">
          <source>The current file name in byte-compiled files (see &lt;a href=&quot;docs-and-compilation#Docs-and-Compilation&quot;&gt;Docs and Compilation&lt;/a&gt;). This is not meant to be used in Emacs Lisp source files.</source>
          <target state="translated">바이트 컴파일 된 파일의 현재 파일 이름입니다 ( &lt;a href=&quot;docs-and-compilation#Docs-and-Compilation&quot;&gt;문서 및 컴파일&lt;/a&gt; 참조 ). 이것은 Emacs Lisp 소스 파일에서 사용하기위한 것이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="b0e9ac8163716bfa85a52705be2822c48e82cbd6" translate="yes" xml:space="preserve">
          <source>The current flags of the interface.</source>
          <target state="translated">인터페이스의 현재 플래그입니다.</target>
        </trans-unit>
        <trans-unit id="4bc02bf671d789b23dfc61d21042a23f7be5f41a" translate="yes" xml:space="preserve">
          <source>The current line number of point, counting within the accessible portion of the buffer.</source>
          <target state="translated">버퍼의 액세스 가능한 부분 내에서 계산되는 포인트의 현재 라인 번호입니다.</target>
        </trans-unit>
        <trans-unit id="01cbdcc5115b6bb7222af2f5b8c203bd59b36d12" translate="yes" xml:space="preserve">
          <source>The current match data. See &lt;a href=&quot;match-data#Match-Data&quot;&gt;Match Data&lt;/a&gt;.</source>
          <target state="translated">현재 경기 데이터입니다. &lt;a href=&quot;match-data#Match-Data&quot;&gt;데이터 일치를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="74f9a1d87530d50c4d0bc7b5d1da7fe2f989980b" translate="yes" xml:space="preserve">
          <source>The current setting of an option is available via the &lt;code&gt;process-contact&lt;/code&gt; function.</source>
          <target state="translated">옵션의 현재 설정은 &lt;code&gt;process-contact&lt;/code&gt; 기능을 통해 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c8841e254b566bf5e794e8e991eb038996ac6058" translate="yes" xml:space="preserve">
          <source>The current value of this variable is used to rebind &lt;code&gt;help-form&lt;/code&gt; locally inside the minibuffer (see &lt;a href=&quot;help-functions#Help-Functions&quot;&gt;Help Functions&lt;/a&gt;).</source>
          <target state="translated">이 변수의 현재 값은 미니 버퍼 내에서 로컬로 &lt;code&gt;help-form&lt;/code&gt; 을 리 바인드하는 데 사용됩니다 ( &lt;a href=&quot;help-functions#Help-Functions&quot;&gt;도움말 함수&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="14a941d0e07e1294606a1ecd42518431ac54129d" translate="yes" xml:space="preserve">
          <source>The current working directory of the subprocess is set to the current buffer&amp;rsquo;s value of &lt;code&gt;default-directory&lt;/code&gt; if that is local (as determined by &lt;code&gt;unhandled-file-name-directory&lt;/code&gt;), or</source>
          <target state="translated">하위 프로세스의 현재 작업 디렉토리 가 로컬 인 경우 현재 버퍼의 &lt;code&gt;default-directory&lt;/code&gt; 값으로 설정 됩니다 ( &lt;code&gt;unhandled-file-name-directory&lt;/code&gt; 에 의해 결정됨 ).</target>
        </trans-unit>
        <trans-unit id="15dffde8e426c6fb2351035a35c4354ca1d72300" translate="yes" xml:space="preserve">
          <source>The current working directory of the subprocess is set to the current buffer&amp;rsquo;s value of &lt;code&gt;default-directory&lt;/code&gt; if that is local (as determined by &lt;code&gt;unhandled-file-name-directory&lt;/code&gt;), or &quot;~&quot; otherwise. If you want to run a process in a remote directory use &lt;code&gt;process-file&lt;/code&gt;.</source>
          <target state="translated">하위 프로세스의 현재 작업 디렉토리 는 로컬 ( &lt;code&gt;unhandled-file-name-directory&lt;/code&gt; 에 의해 결정됨) 인 경우 현재 버퍼의 &lt;code&gt;default-directory&lt;/code&gt; 값으로 설정 되고 그렇지 않으면 &quot;~&quot;로 설정됩니다. 원격 디렉토리에서 프로세스를 실행하려면 &lt;code&gt;process-file&lt;/code&gt; 을 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="5788a491a8ca633fe83f7cc719bce2a1bd26a058" translate="yes" xml:space="preserve">
          <source>The customization buffer shows all legitimate values using their read syntax, and the user edits them textually.</source>
          <target state="translated">사용자 정의 버퍼는 읽기 구문을 사용하여 모든 합법적 인 값을 표시하고 사용자는이를 텍스트로 편집합니다.</target>
        </trans-unit>
        <trans-unit id="679b679b420f2aea1b845938fef72fa046ada093" translate="yes" xml:space="preserve">
          <source>The customization declarations that we will describe in the next few sections&amp;mdash;&lt;code&gt;defcustom&lt;/code&gt;, &lt;code&gt;defgroup&lt;/code&gt;, etc.&amp;mdash;all accept keyword arguments (see &lt;a href=&quot;constant-variables#Constant-Variables&quot;&gt;Constant Variables&lt;/a&gt;) for specifying various information. This section describes keywords that apply to all types of customization declarations.</source>
          <target state="translated">다음 몇 섹션 ( &lt;code&gt;defcustom&lt;/code&gt; , &lt;code&gt;defgroup&lt;/code&gt; 등) 에서 설명 할 사용자 정의 선언은 모두 다양한 정보를 지정하기 위해 키워드 인수 ( &lt;a href=&quot;constant-variables#Constant-Variables&quot;&gt;상수 변수&lt;/a&gt; 참조 )를 허용합니다 . 이 섹션에서는 모든 유형의 사용자 지정 선언에 적용되는 키워드에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="3245d03a470996818ac4300b0d782a4d8da2f5f0" translate="yes" xml:space="preserve">
          <source>The data as a byte array.</source>
          <target state="translated">바이트 배열로서의 데이터.</target>
        </trans-unit>
        <trans-unit id="ca572036806441020e8effb7e24f638ba88825ed" translate="yes" xml:space="preserve">
          <source>The data structure that controls the mode line.</source>
          <target state="translated">모드 라인을 제어하는 ​​데이터 구조.</target>
        </trans-unit>
        <trans-unit id="573b608c65720dd5e9f86107ce3794e2b66f24ad" translate="yes" xml:space="preserve">
          <source>The data type used for byte-compiled functions.</source>
          <target state="translated">바이트 컴파일 된 함수에 사용되는 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="5a82b15b1b8d7d24f2d08410ac1cfd7e6d06997f" translate="yes" xml:space="preserve">
          <source>The datagram connection doesn&amp;rsquo;t have to talk with the same remote peer all the time. It has a &lt;em&gt;remote peer address&lt;/em&gt; which specifies where to send datagrams to. Each time an incoming datagram is passed to the filter function, the peer address is set to the address that datagram came from; that way, if the filter function sends a datagram, it will go back to that place. You can specify the remote peer address when you create the datagram connection using the &lt;code&gt;:remote&lt;/code&gt; keyword. You can change it later on by calling &lt;code&gt;set-process-datagram-address&lt;/code&gt;.</source>
          <target state="translated">데이터 그램 연결은 항상 동일한 원격 피어와 통신 할 필요가 없습니다. 데이터 그램을 보낼 위치를 지정 하는 &lt;em&gt;원격 피어 주소&lt;/em&gt; 가 있습니다. 들어오는 데이터 그램이 필터 기능에 전달 될 때마다 피어 주소는 데이터 그램이 가져온 주소로 설정됩니다. 이렇게하면 필터 함수가 데이터 그램을 보내면 해당 위치로 돌아갑니다. &lt;code&gt;:remote&lt;/code&gt; 키워드를 사용하여 데이터 그램 연결을 생성 할 때 원격 피어 주소를 지정할 수 있습니다 . 나중에 &lt;code&gt;set-process-datagram-address&lt;/code&gt; 를 호출하여 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c8a99693205cb27465e9a23712b2b01b8e7190e8" translate="yes" xml:space="preserve">
          <source>The day of the month, as an integer between 1 and 31.</source>
          <target state="translated">1에서 31 사이의 정수로 표시되는 날짜입니다.</target>
        </trans-unit>
        <trans-unit id="9368d4933dcb32e8f32e58e12038542028e5bf2e" translate="yes" xml:space="preserve">
          <source>The day of week, as an integer between 0 and 6, where 0 stands for Sunday.</source>
          <target state="translated">0에서 6 사이의 정수로 표시되는 요일입니다. 여기서 0은 일요일을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9391c6fb508041b1a4555e55af0146bfecc28aaf" translate="yes" xml:space="preserve">
          <source>The debugger buffer (in Debugger mode) provides special commands in addition to the usual Emacs commands and to the Backtrace mode commands described in the previous section. The most important use of debugger commands is for stepping through code, so that you can see how control flows. The debugger can step through the control structures of an interpreted function, but cannot do so in a byte-compiled function. If you would like to step through a byte-compiled function, replace it with an interpreted definition of the same function. (To do this, visit the source for the function and type</source>
          <target state="translated">디버거 버퍼 (디버거 모드)는 이전 섹션에서 설명한 일반적인 Emacs 명령과 Backtrace 모드 명령에 추가하여 특수 명령을 제공합니다. 디버거 명령의 가장 중요한 용도는 코드를 단계별로 실행하여 제어 흐름을 볼 수 있도록하는 것입니다. 디버거는 해석 된 함수의 제어 구조를 단계별로 실행할 수 있지만 바이트 컴파일 된 함수에서는 수행 할 수 없습니다. 바이트 컴파일 된 함수를 단계별로 실행하려면 동일한 함수의 해석 된 정의로 바꾸십시오. (이렇게하려면 기능 소스를 방문하여</target>
        </trans-unit>
        <trans-unit id="204c2340eea809f0b5f4579c67b2c9092c7084dc" translate="yes" xml:space="preserve">
          <source>The debugger itself must be run byte-compiled, since it makes assumptions about the state of the Lisp interpreter. These assumptions are false if the debugger is running interpreted.</source>
          <target state="translated">디버거 자체는 Lisp 인터프리터의 상태에 대해 가정하기 때문에 바이트 컴파일로 실행되어야합니다. 디버거가 해석되어 실행중인 경우 이러한 가정은 거짓입니다.</target>
        </trans-unit>
        <trans-unit id="ae895d64b56913e2616b56efee1afabf87405459" translate="yes" xml:space="preserve">
          <source>The declare Form</source>
          <target state="translated">선언 양식</target>
        </trans-unit>
        <trans-unit id="35659d17616bc9465a15f44ceedfcbfe411e25ad" translate="yes" xml:space="preserve">
          <source>The decoding functions ignore newline characters in the encoded text.</source>
          <target state="translated">디코딩 함수는 인코딩 된 텍스트의 개행 문자를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="e485b5724b35707f570323bcd0914ed0bd5f1c4d" translate="yes" xml:space="preserve">
          <source>The default behavior is abandoned as soon as the user customizes one of these thresholds or manually changes the frame&amp;rsquo;s layout. The default behavior is also abandoned when calling &lt;code&gt;display-buffer&lt;/code&gt; with a non-&lt;code&gt;nil&lt;/code&gt;&lt;var&gt;action&lt;/var&gt; argument or the user customizes one of the options mentioned in the previous subsections. Mastering &lt;code&gt;display-buffer&lt;/code&gt; soon may become a frustrating experience due to the plethora of applicable display actions and the resulting frame layouts.</source>
          <target state="translated">사용자가 이러한 임계 값 중 하나를 사용자 지정하거나 프레임 레이아웃을 수동으로 변경하면 기본 동작이 중단됩니다. &lt;code&gt;nil&lt;/code&gt; 이 아닌 &lt;var&gt;action&lt;/var&gt; 인수를 사용하여 &lt;code&gt;display-buffer&lt;/code&gt; 를 호출 하거나 사용자가 이전 하위 섹션에서 언급 한 옵션 중 하나를 사용자 지정 하는 경우에도 기본 동작이 중단됩니다 . &lt;code&gt;display-buffer&lt;/code&gt; 마스터 하는 것은 적용 가능한 디스플레이 작업과 그에 따른 프레임 레이아웃으로 인해 곧 실망스러운 경험이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9e9c9c82609653ae146c30ac1d8a91cbeb480f4" translate="yes" xml:space="preserve">
          <source>The default directory for temporary files is controlled by the variable &lt;code&gt;temporary-file-directory&lt;/code&gt;. This variable gives the user a uniform way to specify the directory for all temporary files. Some programs use &lt;code&gt;small-temporary-file-directory&lt;/code&gt; instead, if that is non-&lt;code&gt;nil&lt;/code&gt;. To use it, you should expand the prefix against the proper directory before calling &lt;code&gt;make-temp-file&lt;/code&gt;.</source>
          <target state="translated">임시 파일의 기본 디렉토리는 &lt;code&gt;temporary-file-directory&lt;/code&gt; 변수로 제어됩니다 . 이 변수는 사용자에게 모든 임시 파일에 대한 디렉토리를 지정하는 일관된 방법을 제공합니다. 일부 프로그램 은 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 &lt;code&gt;small-temporary-file-directory&lt;/code&gt; 를 대신 사용 합니다. 이를 사용하려면 &lt;code&gt;make-temp-file&lt;/code&gt; 을 호출하기 전에 적절한 디렉토리에 대한 접두사를 확장해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="b24d19f92acdbe56a7d260c78f0a136a2db97aa7" translate="yes" xml:space="preserve">
          <source>The default expansion function returns the abbrev symbol if it did expansion, and &lt;code&gt;nil&lt;/code&gt; otherwise. If the abbrev symbol has a hook function that is a symbol whose &lt;code&gt;no-self-insert&lt;/code&gt; property is non-&lt;code&gt;nil&lt;/code&gt;, and if the hook function returns &lt;code&gt;nil&lt;/code&gt; as its value, then the default expansion function returns &lt;code&gt;nil&lt;/code&gt;, even though expansion did occur.</source>
          <target state="translated">기본 확장 함수는 확장을 수행 한 경우 약어 기호를 반환하고 그렇지 않으면 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다. abbrev 기호에 &lt;code&gt;no-self-insert&lt;/code&gt; 속성이 &lt;code&gt;nil&lt;/code&gt; 이 아닌 기호 인 후크 함수가 있고 후크 함수가 값으로 &lt;code&gt;nil&lt;/code&gt; 을 반환 하면 확장이 발생 했더라도 기본 확장 함수는 &lt;code&gt;nil&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="24d2b1a3f58aabec28de7b41808ec803c54d89f7" translate="yes" xml:space="preserve">
          <source>The default face spec determines &lt;var&gt;face&lt;/var&gt;&amp;rsquo;s appearance when no customizations are in effect (see &lt;a href=&quot;customization#Customization&quot;&gt;Customization&lt;/a&gt;). If &lt;var&gt;face&lt;/var&gt; has already been customized (via Custom themes or via customizations read from the init file), its appearance is determined by the custom face spec(s), which override the default face spec &lt;var&gt;spec&lt;/var&gt;. However, if the customizations are subsequently removed, the appearance of &lt;var&gt;face&lt;/var&gt; will again be determined by its default face spec.</source>
          <target state="translated">기본 얼굴 사양 은 &lt;a href=&quot;customization#Customization&quot;&gt;사용자 화가&lt;/a&gt; 적용되지 않을 때 &lt;var&gt;face&lt;/var&gt; 의 모양을 결정 합니다 ( 사용자 화 참조 ). 경우 &lt;var&gt;face&lt;/var&gt; 이미 (사용자 정의 테마를 통해 또는 사용자 정의가 초기화 파일에서 읽기를 통해) 사용자 정의되었습니다, 그 모습은 기본 얼굴 스펙보다 우선 사용자 지정 얼굴 사양 (들)에 의해 결정된다 &lt;var&gt;spec&lt;/var&gt; . 그러나 나중에 사용자 정의가 제거되면 &lt;var&gt;face&lt;/var&gt; 의 모양이 기본 얼굴 사양에 따라 다시 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="e352d771642177d9315aafbe09aa957e033f415e" translate="yes" xml:space="preserve">
          <source>The default face, whose attributes are all specified. All other faces implicitly inherit from it: any unspecified attribute defaults to the attribute on this face (see &lt;a href=&quot;face-attributes#Face-Attributes&quot;&gt;Face Attributes&lt;/a&gt;).</source>
          <target state="translated">속성이 모두 지정된 기본 얼굴입니다. 다른 모든 얼굴은 암시 적으로 상속됩니다. 지정되지 않은 속성은 기본적으로이 얼굴의 속성으로 설정됩니다 ( &lt;a href=&quot;face-attributes#Face-Attributes&quot;&gt;얼굴 속성&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="97f6bab98a77e2dceae2315c3bef9cc3c9e5c926" translate="yes" xml:space="preserve">
          <source>The default file permissions have no effect when you save a modified version of an existing file; saving a file preserves its existing permissions.</source>
          <target state="translated">기본 파일 사용 권한은 기존 파일의 수정 된 버전을 저장할 때 적용되지 않습니다. 파일을 저장하면 기존 권한이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="c78819cd8a5f7400b7e12474830ebf1ad3d9a5da" translate="yes" xml:space="preserve">
          <source>The default filter function consults the obsolete wrapper hook &lt;code&gt;filter-buffer-substring-functions&lt;/code&gt; (see the documentation string of the macro &lt;code&gt;with-wrapper-hook&lt;/code&gt; for the details about this obsolete facility), and the obsolete variable &lt;code&gt;buffer-substring-filters&lt;/code&gt;. If both of these are &lt;code&gt;nil&lt;/code&gt;, it returns the unaltered text from the buffer, i.e., what &lt;code&gt;buffer-substring&lt;/code&gt; would return.</source>
          <target state="translated">기본 필터 함수는 더 이상 사용되지 않는 래퍼 후크 &lt;code&gt;filter-buffer-substring-functions&lt;/code&gt; ( 이 더 이상 사용되지 않는 기능에 대한 자세한 내용은 &lt;code&gt;with-wrapper-hook&lt;/code&gt; 가있는 매크로의 설명서 문자열 참조 ) 및 더 이상 사용되지 않는 변수 &lt;code&gt;buffer-substring-filters&lt;/code&gt; 를 참조 합니다. 둘 다 &lt;code&gt;nil&lt;/code&gt; 이면 버퍼에서 변경되지 않은 텍스트, 즉 &lt;code&gt;buffer-substring&lt;/code&gt; 이 반환 하는 텍스트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e3750f6dcb047a245eefc466255be6b4a6a8a1ea" translate="yes" xml:space="preserve">
          <source>The default filter function uses this marker to decide where to insert process output, and updates it to point after the inserted text. That is why successive batches of output are inserted consecutively.</source>
          <target state="translated">기본 필터 기능은이 마커를 사용하여 프로세스 출력을 삽입 할 위치를 결정하고 삽입 된 텍스트 뒤를 가리 키도록 업데이트합니다. 이것이 연속적인 출력 배치가 연속적으로 삽입되는 이유입니다.</target>
        </trans-unit>
        <trans-unit id="ef4cb4822663d880a22c02717254d159db66694e" translate="yes" xml:space="preserve">
          <source>The default font can be also set directly with the following function:</source>
          <target state="translated">기본 글꼴은 다음 기능을 사용하여 직접 설정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4569ee97ca7c48221170af5b1c61cb13f6d5f098" translate="yes" xml:space="preserve">
          <source>The default font of a frame and how to set it.</source>
          <target state="translated">프레임의 기본 글꼴 및 설정 방법.</target>
        </trans-unit>
        <trans-unit id="7a26ffd4823527bd36b0fa5afabe4c3d579d0f2b" translate="yes" xml:space="preserve">
          <source>The default for &lt;var&gt;weak&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, so that all keys and values referenced in the hash table are preserved from garbage collection.</source>
          <target state="translated">&lt;var&gt;weak&lt;/var&gt; 의 기본값 은 &lt;code&gt;nil&lt;/code&gt; 이므로 해시 테이블에서 참조되는 모든 키와 값이 가비지 수집에서 보존됩니다.</target>
        </trans-unit>
        <trans-unit id="7b9181999274ee620d9b62b9de5f15a97a955b39" translate="yes" xml:space="preserve">
          <source>The default for binding local variables in Emacs.</source>
          <target state="translated">Emacs에서 로컬 변수를 바인딩하기위한 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="87eae0a90d65d47dac4065dcb8cd03a98d7ed3e0" translate="yes" xml:space="preserve">
          <source>The default history list for minibuffer history input.</source>
          <target state="translated">미니 버퍼 히스토리 입력을위한 기본 히스토리 목록입니다.</target>
        </trans-unit>
        <trans-unit id="cbb0c0244aefe32651fdecae8e37c9c1d1884caa" translate="yes" xml:space="preserve">
          <source>The default is 200.</source>
          <target state="translated">기본값은 200입니다.</target>
        </trans-unit>
        <trans-unit id="582cef5881ae56697d27c6a4543a9c80f1165b5a" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;nil&lt;/code&gt;. Other values are reserved for future use. A specific split operation may ignore the value of this variable if it is affected by a non-&lt;code&gt;nil&lt;/code&gt; value of &lt;code&gt;window-combination-limit&lt;/code&gt;.</source>
          <target state="translated">기본값은 &lt;code&gt;nil&lt;/code&gt; 입니다. 다른 값은 향후 사용을 위해 예약되어 있습니다. 특정 분할 작업은 &lt;code&gt;window-combination-limit&lt;/code&gt; 의 &lt;code&gt;nil&lt;/code&gt; 이 아닌 값의 영향을받는 경우이 변수의 값을 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="85c215bf6d37dced9d2e10ebdf1f4c247bbf284b" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;window-size&lt;/code&gt;. Other values are reserved for future use.</source>
          <target state="translated">기본값은 &lt;code&gt;window-size&lt;/code&gt; 입니다. 다른 값은 향후 사용을 위해 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c4bf2ab4e22795d3bd5f44da1e6a3c75cc6bce8" translate="yes" xml:space="preserve">
          <source>The default is to call &lt;code&gt;iconify-frame&lt;/code&gt; (see &lt;a href=&quot;visibility-of-frames#Visibility-of-Frames&quot;&gt;Visibility of Frames&lt;/a&gt;). Alternatively, you may specify either &lt;code&gt;delete-frame&lt;/code&gt; (see &lt;a href=&quot;deleting-frames#Deleting-Frames&quot;&gt;Deleting Frames&lt;/a&gt;) to remove the frame from its display, &lt;code&gt;make-frame-invisible&lt;/code&gt; to make the frame invisible, &lt;code&gt;ignore&lt;/code&gt; to leave the frame unchanged, or any other function that can take a frame as its sole argument.</source>
          <target state="translated">기본값은 &lt;code&gt;iconify-frame&lt;/code&gt; 을 호출하는 것 &lt;a href=&quot;visibility-of-frames#Visibility-of-Frames&quot;&gt;입니다 (프레임 가시성&lt;/a&gt; 참조 ). 또는 &lt;code&gt;delete-frame&lt;/code&gt; &lt;a href=&quot;deleting-frames#Deleting-Frames&quot;&gt;삭제 (프레임 삭제&lt;/a&gt; 참조 )를 지정 하여 표시에서 프레임을 제거하거나, &lt;code&gt;make-frame-invisible&lt;/code&gt; 만들 거나, 프레임을 변경하지 않은 상태로 두려면 &lt;code&gt;ignore&lt;/code&gt; 하거나, 프레임을 다음과 같이 사용할 수있는 기타 기능을 지정할 수 있습니다. 유일한 주장.</target>
        </trans-unit>
        <trans-unit id="355b0cc7c09a335da133d2cb3faf5fa1f1f66adc" translate="yes" xml:space="preserve">
          <source>The default is to search in the</source>
          <target state="translated">기본값은</target>
        </trans-unit>
        <trans-unit id="c192f5222c92d4a59ea28dd931508202451f03f1" translate="yes" xml:space="preserve">
          <source>The default name for this file specifies your home directory and starts with &amp;lsquo;</source>
          <target state="translated">이 파일의 기본 이름은 홈 디렉토리를 지정하고 '</target>
        </trans-unit>
        <trans-unit id="81f50e022429a7e9b2ea12cb7d90ec2be233c641" translate="yes" xml:space="preserve">
          <source>The default size is 65.</source>
          <target state="translated">기본 크기는 65입니다.</target>
        </trans-unit>
        <trans-unit id="f81af72138fca1db6fa3768259f2dad66c43e06c" translate="yes" xml:space="preserve">
          <source>The default stroke color on any lines created.</source>
          <target state="translated">생성 된 모든 선의 기본 획 색상입니다.</target>
        </trans-unit>
        <trans-unit id="a42b364fb936e63b8fb9287c2bd08ed248154ba7" translate="yes" xml:space="preserve">
          <source>The default time zone is determined by the &lt;code&gt;TZ&lt;/code&gt; environment variable. See &lt;a href=&quot;system-environment#System-Environment&quot;&gt;System Environment&lt;/a&gt;. For example, you can tell Emacs to default to Universal Time with &lt;code&gt;(setenv &quot;TZ&quot; &quot;UTC0&quot;)&lt;/code&gt;. If &lt;code&gt;TZ&lt;/code&gt; is not in the environment, Emacs uses system wall clock time, which is a platform-dependent default time zone.</source>
          <target state="translated">기본 시간대는 &lt;code&gt;TZ&lt;/code&gt; 환경 변수에 의해 결정됩니다 . &lt;a href=&quot;system-environment#System-Environment&quot;&gt;시스템 환경을&lt;/a&gt; 참조하십시오 . 예를 들어, Emacs에 &lt;code&gt;(setenv &quot;TZ&quot; &quot;UTC0&quot;)&lt;/code&gt; 을 사용하여 기본적으로 표준시로 설정할 수 있습니다 . &lt;code&gt;TZ&lt;/code&gt; 가 환경에없는 경우 Emacs는 플랫폼에 따라 달라지는 기본 시간대 인 시스템 벽시계 시간을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="32d3076afb57dc0f673022de3f52015867d308b4" translate="yes" xml:space="preserve">
          <source>The default tool bar is defined so that items specific to editing do not appear for major modes whose command symbol has a &lt;code&gt;mode-class&lt;/code&gt; property of &lt;code&gt;special&lt;/code&gt; (see &lt;a href=&quot;major-mode-conventions#Major-Mode-Conventions&quot;&gt;Major Mode Conventions&lt;/a&gt;). Major modes may add items to the global bar by binding &lt;code&gt;[tool-bar
&lt;var&gt;foo&lt;/var&gt;]&lt;/code&gt; in their local map. It makes sense for some major modes to replace the default tool bar items completely, since not many can be accommodated conveniently, and the default bindings make this easy by using an indirection through &lt;code&gt;tool-bar-map&lt;/code&gt;.</source>
          <target state="translated">기본 도구 모음은 명령 기호 에 &lt;code&gt;special&lt;/code&gt; 의 &lt;code&gt;mode-class&lt;/code&gt; 속성 이있는 주요 모드에 대해 편집 관련 항목이 나타나지 않도록 정의됩니다 ( &lt;a href=&quot;major-mode-conventions#Major-Mode-Conventions&quot;&gt;주요 모드 규칙&lt;/a&gt; 참조 ). 주요 모드는 로컬 맵에서 &lt;code&gt;[tool-bar &lt;var&gt;foo&lt;/var&gt;]&lt;/code&gt; &lt;var&gt;foo&lt;/var&gt; ] 를 바인딩하여 글로벌 바에 항목을 추가 할 수 있습니다 . 일부 주요 모드에서는 기본 도구 모음 항목을 완전히 대체하는 것이 합리적입니다. 그 이유는 편리하게 수용 할 수있는 항목이 많지 않기 때문이며 기본 바인딩을 사용하면 &lt;code&gt;tool-bar-map&lt;/code&gt; 을 통한 간접 지정을 사용하여이를 쉽게 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7f8f458800640ea056a6ac8dce525674b542eb25" translate="yes" xml:space="preserve">
          <source>The default value &lt;code&gt;nil&lt;/code&gt; should be used when your window manager follows a &amp;ldquo;click-to-focus&amp;rdquo; policy where you have to click the mouse inside of a frame in order for that frame to gain focus.</source>
          <target state="translated">창 관리자가 &quot;클릭 투 포커스&quot;정책을 따를 때 기본값 &lt;code&gt;nil&lt;/code&gt; 을 사용해야합니다. 프레임 내부에서 마우스를 클릭해야 해당 프레임이 포커스를받을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65c90e417643a9493a18a85edd85f577a906b419" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;fill-column&lt;/code&gt; is 70.</source>
          <target state="translated">&lt;code&gt;fill-column&lt;/code&gt; 의 기본값 은 70입니다.</target>
        </trans-unit>
        <trans-unit id="1c5ee1145d2310fefd80e39a76e590d4030f537f" translate="yes" xml:space="preserve">
          <source>The default value is 1.5.</source>
          <target state="translated">기본값은 1.5입니다.</target>
        </trans-unit>
        <trans-unit id="023d79ed160a6c9a929201a5f88a10d241a22378" translate="yes" xml:space="preserve">
          <source>The default value is 1600. Entry to the Lisp debugger increases the value, if there is little room left, to make sure the debugger itself has room to execute.</source>
          <target state="translated">기본값은 1600입니다. Lisp 디버거에 대한 항목은 남은 공간이 거의없는 경우 값을 증가시켜 디버거 자체에 실행할 공간이 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="e9c764d13e36573c05043f232522dfc255e445b0" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;'(tab-bar-lines tool-bar-lines)&lt;/code&gt; for Lucid, Motif and MS-Windows (which means that adding/removing a tool or tab bar there does not change the outer frame height), &lt;code&gt;'(tab-bar-lines)&lt;/code&gt; on all other window systems including GTK+ (which means that changing any of the parameters listed above with the exception of &lt;code&gt;tab-bar-lines&lt;/code&gt; may change the size of the outer frame), and &lt;code&gt;t&lt;/code&gt; otherwise (which means the outer frame size never changes implicitly when there&amp;rsquo;s no window system support).</source>
          <target state="translated">Lucid, Motif 및 MS-Windows 의 경우 기본값은 &lt;code&gt;'(tab-bar-lines tool-bar-lines)&lt;/code&gt; 입니다 (즉, 도구 또는 탭 막대를 추가 / 제거해도 외부 프레임 높이가 변경되지 않음), &lt;code&gt;'(tab-bar-lines)&lt;/code&gt; GTK + ( &lt;code&gt;tab-bar-lines&lt;/code&gt; 제외하고 위에 나열된 매개 변수를 변경하면 외부 프레임의 크기가 변경 될 수 있음)를 포함한 다른 모든 윈도우 시스템 에서, 그렇지 않으면 &lt;code&gt;t&lt;/code&gt; (외부 윈도우 시스템 지원이 없을 때 프레임 크기는 절대로 절대 변경되지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="41b5142be2a25ab47e2b91994f5b738ecc8aff3e" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;nil&lt;/code&gt;, i.e., the prefix-discarding feature is disabled. This is because discarding prefixes often leads to confusing names for options and faces.</source>
          <target state="translated">기본값은 &lt;code&gt;nil&lt;/code&gt; 입니다 . 즉, 접두사 삭제 기능이 비활성화됩니다. 접두사를 버리면 종종 옵션과 얼굴의 이름이 혼동되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="60739858c427147eccf0a2c0969cc628b2fa3758" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;normal-backup-enable-predicate&lt;/code&gt;, which checks for files in &lt;code&gt;temporary-file-directory&lt;/code&gt; and &lt;code&gt;small-temporary-file-directory&lt;/code&gt;.</source>
          <target state="translated">기본값은 &lt;code&gt;normal-backup-enable-predicate&lt;/code&gt; 이며, &lt;code&gt;temporary-file-directory&lt;/code&gt; 및 &lt;code&gt;small-temporary-file-directory&lt;/code&gt; 의 파일을 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="19763762633973d0ed6336bf3782312f60260a0c" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;step&lt;/code&gt;. This variable can be set interactively with</source>
          <target state="translated">기본값은 &lt;code&gt;step&lt;/code&gt; 입니다. 이 변수는</target>
        </trans-unit>
        <trans-unit id="e11dbb62c77f8d4f68d95a72cdb3ccd5d2250955" translate="yes" xml:space="preserve">
          <source>The default value is determined in a reasonable way for your operating system; it is based on the &lt;code&gt;TMPDIR&lt;/code&gt;, &lt;code&gt;TMP&lt;/code&gt; and &lt;code&gt;TEMP&lt;/code&gt; environment variables, with a fall-back to a system-dependent name if none of these variables is defined.</source>
          <target state="translated">기본값은 운영 체제에 적합한 방식으로 결정됩니다. &lt;code&gt;TMPDIR&lt;/code&gt; , &lt;code&gt;TMP&lt;/code&gt; 및 &lt;code&gt;TEMP&lt;/code&gt; 환경 변수를 기반으로하며 이러한 변수가 정의되지 않은 경우 시스템 종속 이름으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="3bcf9e986e7383ce581df716448fe56d672113c0" translate="yes" xml:space="preserve">
          <source>The default value is seen in buffers that don&amp;rsquo;t have their own buffer-local values.</source>
          <target state="translated">기본값은 자체 버퍼 로컬 값이없는 버퍼에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="1193bd78586d719562726255cbef739c27920d29" translate="yes" xml:space="preserve">
          <source>The default value is the function that clears the message displayed in an active minibuffer.</source>
          <target state="translated">기본값은 활성 미니 버퍼에 표시된 메시지를 지우는 기능입니다.</target>
        </trans-unit>
        <trans-unit id="d5282ebe83f8d6dacbe0acbf2204264b3f3383ec" translate="yes" xml:space="preserve">
          <source>The default value is the function that displays the message at the end of the minibuffer when the minibuffer is active. However, if the text shown in the active minibuffer has the &lt;code&gt;minibuffer-message&lt;/code&gt; text property (see &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Special Properties&lt;/a&gt;) on some character, the message will be displayed before the first character having that property.</source>
          <target state="translated">기본값은 미니 버퍼가 활성화되었을 때 미니 버퍼 끝에 메시지를 표시하는 기능입니다. 그러나 활성 미니 버퍼에 표시된 텍스트 에 일부 문자에 대한 &lt;code&gt;minibuffer-message&lt;/code&gt; 텍스트 속성 ( &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;특수 속성&lt;/a&gt; 참조 )이있는 경우 해당 속성을 가진 첫 번째 문자 앞에 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="c24a56207aec1ab7e76efac7a53cf162bbbcd2f9" translate="yes" xml:space="preserve">
          <source>The default value is zero, which means that conservative scrolling never happens.</source>
          <target state="translated">기본값은 0이며, 이는 보수적 스크롤이 발생하지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="474d2dbca7fd1c4cd24098b32e8425d766731b4d" translate="yes" xml:space="preserve">
          <source>The default value matches whitespace with certain punctuation characters intermingled.</source>
          <target state="translated">기본값은 특정 문장 부호 문자가 섞인 공백과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="708d542b5cb83d6b27cbfcf294ba98e1c6eb4b90" translate="yes" xml:space="preserve">
          <source>The default value of &lt;code&gt;auto-hscroll-mode&lt;/code&gt; is &lt;code&gt;t&lt;/code&gt;; setting it to &lt;code&gt;current-line&lt;/code&gt; activates a variant of automatic horizontal scrolling whereby only the line showing the cursor is horizontally scrolled to make point visible, the rest of the window is left either unscrolled, or at the minimum scroll amount set by &lt;code&gt;scroll-left&lt;/code&gt; and &lt;code&gt;scroll-right&lt;/code&gt;, see below.</source>
          <target state="translated">&lt;code&gt;auto-hscroll-mode&lt;/code&gt; 의 기본값 은 &lt;code&gt;t&lt;/code&gt; 입니다 . &lt;code&gt;current-line&lt;/code&gt; 설정하면 자동 수평 스크롤의 변형이 활성화되어 커서를 보여주는 행만 수평으로 스크롤하여 포인트를 표시하고 나머지 창은 스크롤되지 않은 상태로 두거나 &lt;code&gt;scroll-left&lt;/code&gt; 및 scroll-left 및 &lt;code&gt;scroll-right&lt;/code&gt; , 아래 참조.</target>
        </trans-unit>
        <trans-unit id="b51a5e882958d495ad310784959e1d391806578c" translate="yes" xml:space="preserve">
          <source>The default value of &lt;code&gt;bidi-display-reordering&lt;/code&gt; controls the reordering of strings which are not directly supplied by a buffer, including the text displayed in mode lines (see &lt;a href=&quot;mode-line-format#Mode-Line-Format&quot;&gt;Mode Line Format&lt;/a&gt;) and header lines (see &lt;a href=&quot;header-lines#Header-Lines&quot;&gt;Header Lines&lt;/a&gt;).</source>
          <target state="translated">기본값 &lt;code&gt;bidi-display-reordering&lt;/code&gt; 직접 텍스트를 포함하는 버퍼에 의해 제공되지 않은 스트링의 재정렬 모드 라인에 표시된 제어 (참조 &lt;a href=&quot;mode-line-format#Mode-Line-Format&quot;&gt;모드 광고 포맷&lt;/a&gt; 헤더 라인 (참조) &lt;a href=&quot;header-lines#Header-Lines&quot;&gt;헤더 선&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="e746e493f187bcdc9f3fc0f756c6ba6a17eaffe8" translate="yes" xml:space="preserve">
          <source>The default value of &lt;code&gt;imenu-create-index-function&lt;/code&gt; is &lt;code&gt;imenu-default-create-index-function&lt;/code&gt;. This function calls the value of &lt;code&gt;imenu-prev-index-position-function&lt;/code&gt; and the value of &lt;code&gt;imenu-extract-index-name-function&lt;/code&gt; to produce the index alist. However, if either of these two variables is &lt;code&gt;nil&lt;/code&gt;, the default function uses &lt;code&gt;imenu-generic-expression&lt;/code&gt; instead.</source>
          <target state="translated">기본값 &lt;code&gt;imenu-create-index-function&lt;/code&gt; 입니다 &lt;code&gt;imenu-default-create-index-function&lt;/code&gt; . 이 함수는 &lt;code&gt;imenu-prev-index-position-function&lt;/code&gt; 의 값과 &lt;code&gt;imenu-extract-index-name-function&lt;/code&gt; 의 값을 호출 하여 인덱스 목록을 생성합니다. 그러나이 두 변수 중 하나가 &lt;code&gt;nil&lt;/code&gt; 이면 기본 함수는 대신 &lt;code&gt;imenu-generic-expression&lt;/code&gt; 을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="25e5a409a50e09859f3f4732e6977f44e72151aa" translate="yes" xml:space="preserve">
          <source>The default value of &lt;code&gt;mode-line-format&lt;/code&gt; is designed to use the values of other variables such as &lt;code&gt;mode-line-position&lt;/code&gt; and &lt;code&gt;mode-line-modes&lt;/code&gt; (which in turn incorporates the values of the variables &lt;code&gt;mode-name&lt;/code&gt; and &lt;code&gt;minor-mode-alist&lt;/code&gt;). Very few modes need to alter &lt;code&gt;mode-line-format&lt;/code&gt; itself. For most purposes, it is sufficient to alter some of the variables that &lt;code&gt;mode-line-format&lt;/code&gt; either directly or indirectly refers to.</source>
          <target state="translated">&lt;code&gt;mode-line-format&lt;/code&gt; 의 기본값 은 &lt;code&gt;mode-line-position&lt;/code&gt; 및 &lt;code&gt;mode-line-modes&lt;/code&gt; (다시 &lt;code&gt;mode-name&lt;/code&gt; 및 &lt;code&gt;minor-mode-alist&lt;/code&gt; 변수의 값을 통합하는 다른 변수의 값을 사용하도록 설계되었습니다. ). &lt;code&gt;mode-line-format&lt;/code&gt; 자체 를 변경해야하는 모드는 거의 없습니다. 대부분의 경우 &lt;code&gt;mode-line-format&lt;/code&gt; 이 직접 또는 간접적으로 참조하는 일부 변수를 변경하는 것으로 충분 합니다.</target>
        </trans-unit>
        <trans-unit id="8603f9889e97902f88b37a045802893e502f1a0b" translate="yes" xml:space="preserve">
          <source>The default value of &lt;var&gt;separators&lt;/var&gt; for &lt;code&gt;split-string&lt;/code&gt;. Its usual value is &lt;code&gt;&quot;[&amp;nbsp;\f\t\n\r\v]+&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;split-string&lt;/code&gt; 에 대한 &lt;var&gt;separators&lt;/var&gt; 의 기본값 입니다. 일반적인 값은 &lt;code&gt;&quot;[&amp;nbsp;\f\t\n\r\v]+&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2f626f251ec5e141bbe937ae58b8aaf07f20d470" translate="yes" xml:space="preserve">
          <source>The default value of this variable is 800. If you set it to a value less than 100, Lisp will reset it to 100 if the given value is reached. Entry to the Lisp debugger increases the value, if there is little room left, to make sure the debugger itself has room to execute.</source>
          <target state="translated">이 변수의 기본값은 800입니다. 100보다 작은 값으로 설정하면 Lisp는 주어진 값에 도달하면이를 100으로 재설정합니다. Lisp 디버거에 들어가면 디버거 자체에 실행할 공간이 있는지 확인하기 위해 남은 공간이 거의없는 경우 값이 증가합니다.</target>
        </trans-unit>
        <trans-unit id="63779c1cdb9430e4b77e711a1e1ae7eb8735f2c6" translate="yes" xml:space="preserve">
          <source>The default value of this variable is &lt;code&gt;&quot;\\`[&amp;nbsp;\t]*\\'&quot;&lt;/code&gt;, which matches only a string of whitespace. The effect of this default is to force the fill prefixes found in one-line paragraphs always to be pure whitespace.</source>
          <target state="translated">이 변수의 기본값은 &lt;code&gt;&quot;\\`[&amp;nbsp;\t]*\\'&quot;&lt;/code&gt; 이며 공백 문자열과 만 일치합니다. 이 기본값의 효과는 한 줄 단락에있는 채우기 접두사를 항상 순수한 공백이되도록 강제하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="217b324a19b504412ef043553ade93bbd8a61750" translate="yes" xml:space="preserve">
          <source>The default value of this variable specifies functions called during redisplay when a window state change has been detected or the window state change flag has been set on at least one frame. The value should be a list of functions that take no argument.</source>
          <target state="translated">이 변수의 기본값은 창 상태 변경이 감지되거나 창 상태 변경 플래그가 하나 이상의 프레임에 설정된 경우 다시 표시하는 동안 호출되는 함수를 지정합니다. 값은 인수가없는 함수 목록이어야합니다.</target>
        </trans-unit>
        <trans-unit id="ac7d9e5d9130c0ce3ad4a6ef24ef8b11019be5bf" translate="yes" xml:space="preserve">
          <source>The default width (in pixels) of any lines created.</source>
          <target state="translated">생성 된 모든 선의 기본 너비 (픽셀)입니다.</target>
        </trans-unit>
        <trans-unit id="cae16c8270beb52faa207be4ea3ec044cff903b8" translate="yes" xml:space="preserve">
          <source>The default width of the left and right fringes of windows in this frame (see &lt;a href=&quot;fringes#Fringes&quot;&gt;Fringes&lt;/a&gt;). If either of these is zero, that effectively removes the corresponding fringe.</source>
          <target state="translated">이 프레임에서 윈도우의 왼쪽과 오른쪽 변두리의 기본 너비 (참조 &lt;a href=&quot;fringes#Fringes&quot;&gt;변두리을&lt;/a&gt; ). 둘 중 하나가 0이면 해당 프린지를 효과적으로 제거합니다.</target>
        </trans-unit>
        <trans-unit id="f3d7400445b75719c99eccd1b0976fe9d039c6d2" translate="yes" xml:space="preserve">
          <source>The defining form itself is not instrumented (that is, Edebug does not stop before and after the defining form), but forms inside it typically will be instrumented. The &lt;code&gt;&amp;amp;define&lt;/code&gt; keyword should be the first element in a list specification.</source>
          <target state="translated">정의 양식 자체는 계측되지 않지만 (즉, Edebug는 정의 양식 전후에 중지되지 않음) 일반적으로 내부의 양식이 계측됩니다. &lt;code&gt;&amp;amp;define&lt;/code&gt; 키워드 목록 사양의 첫 번째 요소해야합니다.</target>
        </trans-unit>
        <trans-unit id="9c5fa5dc8ac20b29bbb924420889ce1b839d9ba5" translate="yes" xml:space="preserve">
          <source>The definition of &amp;ldquo;supported&amp;rdquo; is somewhat heuristic, but basically means that a face containing all the attributes in &lt;var&gt;attributes&lt;/var&gt;, when merged with the default face for display, can be represented in a way that&amp;rsquo;s</source>
          <target state="translated">&quot;지원&quot;의 정의는 다소 발견하지만, 기본적 수단 모두의 속성이 포함 된 직면하는 &lt;var&gt;attributes&lt;/var&gt; 표시에 대한 기본 얼굴과 합병 할 때,의 그 방식으로 표현 될 수</target>
        </trans-unit>
        <trans-unit id="aedb03aaf6dff1ad0c121d98d3217492fba910a6" translate="yes" xml:space="preserve">
          <source>The definition of a word is any sequence of consecutive characters that are assigned to the word constituent syntax class in the current syntax table (see &lt;a href=&quot;syntax-class-table#Syntax-Class-Table&quot;&gt;Syntax Class Table&lt;/a&gt;).</source>
          <target state="translated">단어의 정의는 현재 구문 테이블에서 단어 구성 구문 클래스에 할당 된 연속 문자 시퀀스입니다 ( &lt;a href=&quot;syntax-class-table#Syntax-Class-Table&quot;&gt;구문 클래스 테이블&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="2ae3fd0458aa9fbdb36602fe411a8d0a3f565b34" translate="yes" xml:space="preserve">
          <source>The definitions are only available during the macro-expansion of &lt;var&gt;body&lt;/var&gt;, and are thus not present during execution of compiled code.</source>
          <target state="translated">정의는 &lt;var&gt;body&lt;/var&gt; 의 매크로 확장 중에 만 사용할 수 있으므로 컴파일 된 코드 실행 중에는 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="877a7963eb71e684d92a94b1803dcb705fa62e6e" translate="yes" xml:space="preserve">
          <source>The definitions live in a name space of their own, separate from that of Lisp variables. There is thus no need to attach a suffix like &lt;code&gt;-regexp&lt;/code&gt; to names; they cannot collide with anything else.</source>
          <target state="translated">정의는 Lisp 변수의 이름 공간과는 별도로 자체 이름 공간에 있습니다. 따라서 이름에 &lt;code&gt;-regexp&lt;/code&gt; 와 같은 접미사를 붙일 필요가 없습니다 . 그들은 다른 것과 충돌 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c95395c58aba34be09b3406ccfc84562286cab93" translate="yes" xml:space="preserve">
          <source>The degree of &lt;em&gt;travel&lt;/em&gt; of the window through (the visible portion of) the buffer, i.e. the size of the text above the top of the window expressed as a percentage of all the text outside the window, or &amp;lsquo;</source>
          <target state="translated">버퍼 (의 보이는 부분)를 통한 창의 &lt;em&gt;이동&lt;/em&gt; 정도 , 즉 창 외부의 모든 텍스트에 대한 백분율로 표시되는 창 상단 위의 텍스트 크기 또는 '</target>
        </trans-unit>
        <trans-unit id="d4c578bc284c890724d1b4502b0a9e91e91cf747" translate="yes" xml:space="preserve">
          <source>The depth in parentheses, counting from 0. &lt;strong&gt;Warning:&lt;/strong&gt; this can be negative if there are more close parens than open parens between the parser&amp;rsquo;s starting point and end point.</source>
          <target state="translated">0부터 계산하는 괄호 안의 깊이입니다. &lt;strong&gt;경고 :&lt;/strong&gt; 파서의 시작점과 끝점 사이에 열린 괄호보다 가까운 괄호가 더 많으면 음수가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9ee4a27b6f69857fe6970eaa91ad4c556960063" translate="yes" xml:space="preserve">
          <source>The depth limit counts internal uses of &lt;code&gt;eval&lt;/code&gt;, &lt;code&gt;apply&lt;/code&gt;, and &lt;code&gt;funcall&lt;/code&gt;, such as for calling the functions mentioned in Lisp expressions, and recursive evaluation of function call arguments and function body forms, as well as explicit calls in Lisp code.</source>
          <target state="translated">깊이 제한 은 Lisp 표현식에 언급 된 함수 호출, 함수 호출 인수 및 함수 본문 양식의 재귀 평가, Lisp 코드의 명시 적 호출과 같은 &lt;code&gt;eval&lt;/code&gt; , &lt;code&gt;apply&lt;/code&gt; 및 &lt;code&gt;funcall&lt;/code&gt; 의 내부 사용을 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="a04b7a2c41711ae199f98dbc28e807a536f9db15" translate="yes" xml:space="preserve">
          <source>The derived mode should also define a &lt;em&gt;listing command&lt;/em&gt;. This, not the mode command, is what the user calls (e.g.,</source>
          <target state="translated">파생 모드는 &lt;em&gt;목록 명령&lt;/em&gt; 도 정의해야합니다 . 이것은 모드 명령이 아니라 사용자가 호출하는 것입니다 (예 :</target>
        </trans-unit>
        <trans-unit id="edf217a40e12d6916d0fa58287c1046472b44fae" translate="yes" xml:space="preserve">
          <source>The descriptions of macros and special forms use a more complex notation to specify optional and repeated arguments, because they can break the argument list down into separate arguments in more complicated ways. &amp;lsquo;</source>
          <target state="translated">매크로 및 특수 형식에 대한 설명은 더 복잡한 방식으로 인수 목록을 별도의 인수로 나눌 수 있기 때문에 더 복잡한 표기법을 사용하여 선택적 및 반복 인수를 지정합니다. '</target>
        </trans-unit>
        <trans-unit id="2a9e034a9e7e27057da723954a997fb3896ab0b9" translate="yes" xml:space="preserve">
          <source>The descriptor of the arguments. This can either be a list of arguments, as described in &lt;a href=&quot;argument-list#Argument-List&quot;&gt;Argument List&lt;/a&gt;, or an integer encoding the required number of arguments. In the latter case, the value of the descriptor specifies the minimum number of arguments in the bits zero to 6, and the maximum number of arguments in bits 8 to 14. If the argument list uses &lt;code&gt;&amp;amp;rest&lt;/code&gt;, then bit 7 is set; otherwise it&amp;rsquo;s cleared.</source>
          <target state="translated">인수의 설명자입니다. 이는 &lt;a href=&quot;argument-list#Argument-List&quot;&gt;인수 목록에&lt;/a&gt; 설명 된대로 인수 목록 이거나 필요한 인수 수를 인코딩하는 정수일 수 있습니다. 후자의 경우 디스크립터의 값은 비트 0에서 6까지의 최소 인수 수를 지정하고 비트 8에서 14까지의 최대 인수 수를 지정합니다. 인수 목록이 &lt;code&gt;&amp;amp;rest&lt;/code&gt; 를 사용하면 비트 7이 설정됩니다. 그렇지 않으면 지워집니다.</target>
        </trans-unit>
        <trans-unit id="28d0d52832e8c8eae5fe1ac0bf15f2addec6fe86" translate="yes" xml:space="preserve">
          <source>The destructive aspect of &lt;code&gt;sort&lt;/code&gt; for lists is that it rearranges the cons cells forming &lt;var&gt;sequence&lt;/var&gt; by changing &lt;small&gt;CDR&lt;/small&gt;s. A nondestructive sort function would create new cons cells to store the elements in their sorted order. If you wish to make a sorted copy without destroying the original, copy it first with &lt;code&gt;copy-sequence&lt;/code&gt; and then sort.</source>
          <target state="translated">목록 &lt;code&gt;sort&lt;/code&gt; 의 파괴적인 측면은 &lt;small&gt;CDR&lt;/small&gt; 을 변경 하여 &lt;var&gt;sequence&lt;/var&gt; 를 형성하는 cons 세포를 재 배열한다는 것 입니다. 비파괴 정렬 기능은 정렬 된 순서로 요소를 저장하기 위해 새로운 cons 셀을 생성합니다. 원본을 훼손하지 않고 정렬 된 복사본을 만들려면 먼저 &lt;code&gt;copy-sequence&lt;/code&gt; 로 복사 한 다음 정렬하십시오.&lt;small&gt;&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="d572ffee8a2d69eec0c8cc8132950bf3a5e93701" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;defconst&lt;/code&gt; and &lt;code&gt;defvar&lt;/code&gt; is mainly a matter of intent, serving to inform human readers of whether the value should ever change. Emacs Lisp does not actually prevent you from changing the value of a variable defined with &lt;code&gt;defconst&lt;/code&gt;. One notable difference between the two forms is that &lt;code&gt;defconst&lt;/code&gt; unconditionally initializes the variable, whereas &lt;code&gt;defvar&lt;/code&gt; initializes it only if it is originally void.</source>
          <target state="translated">&lt;code&gt;defconst&lt;/code&gt; 와 &lt;code&gt;defvar&lt;/code&gt; 의 차이점 은 주로 의도의 문제이며, 값이 변경되어야하는지 여부를 인간 독자에게 알리는 역할을합니다. Emacs Lisp는 실제로 &lt;code&gt;defconst&lt;/code&gt; 로 정의 된 변수의 값을 변경하는 것을 방지하지 않습니다 . 두 형식의 한 가지 주목할만한 차이점은 &lt;code&gt;defconst&lt;/code&gt; 는 변수를 무조건 초기화하는 반면 &lt;code&gt;defvar&lt;/code&gt; 는 원래 무효 인 경우에만 초기화한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="00f363a6aefc0d2de4ef2a1c12ef0e6acbfbacc8" translate="yes" xml:space="preserve">
          <source>The difference between a directory name and a directory file name is subtle but crucial. When an Emacs variable or function argument is described as being a directory name, a directory file name is not acceptable. When &lt;code&gt;file-name-directory&lt;/code&gt; returns a string, that is always a directory name.</source>
          <target state="translated">디렉토리 이름과 디렉토리 파일 이름의 차이는 미묘하지만 중요합니다. Emacs 변수 또는 함수 인수가 디렉토리 이름으로 설명 될 때 디렉토리 파일 이름은 허용되지 않습니다. 때 &lt;code&gt;file-name-directory&lt;/code&gt; 문자열을 반환, 그것은 항상 디렉토리 이름입니다.</target>
        </trans-unit>
        <trans-unit id="0c61186b221c080d1307543136c715a6291ad149" translate="yes" xml:space="preserve">
          <source>The difference from &lt;code&gt;start-process&lt;/code&gt; is that this function may invoke a file name handler based on the value of &lt;code&gt;default-directory&lt;/code&gt;. This handler ought to run &lt;var&gt;program&lt;/var&gt;, perhaps on the local host, perhaps on a remote host that corresponds to &lt;code&gt;default-directory&lt;/code&gt;. In the latter case, the local part of &lt;code&gt;default-directory&lt;/code&gt; becomes the working directory of the process.</source>
          <target state="translated">&lt;code&gt;start-process&lt;/code&gt; 와 다른 점은이 함수가 &lt;code&gt;default-directory&lt;/code&gt; 값을 기반으로 파일 이름 처리기를 호출 할 수 있다는 것 입니다. 이 핸들러 는 아마도 로컬 호스트, 아마도 &lt;code&gt;default-directory&lt;/code&gt; 에 해당하는 원격 호스트에서 &lt;var&gt;program&lt;/var&gt; 을 실행해야합니다 . 후자의 경우 &lt;code&gt;default-directory&lt;/code&gt; 의 로컬 부분 이 프로세스의 작업 디렉토리가됩니다.</target>
        </trans-unit>
        <trans-unit id="405409528439a35fcd3fdd61f588ad09de4201e8" translate="yes" xml:space="preserve">
          <source>The difference is in &lt;var&gt;boolean-expression&lt;/var&gt; in &lt;code&gt;guard&lt;/code&gt;: &lt;code&gt;CLEAN&lt;/code&gt; references &lt;code&gt;n&lt;/code&gt; simply and directly, while &lt;code&gt;MAYBE&lt;/code&gt; references &lt;code&gt;n&lt;/code&gt; with a side-effect, in the expression &lt;code&gt;(incf n)&lt;/code&gt;. When &lt;code&gt;integer&lt;/code&gt; is 3, here&amp;rsquo;s what happens:</source>
          <target state="translated">차이점은에 &lt;var&gt;boolean-expression&lt;/var&gt; 에서 &lt;code&gt;guard&lt;/code&gt; : &lt;code&gt;CLEAN&lt;/code&gt; 참조 &lt;code&gt;n&lt;/code&gt; 반면 단순히 직접 &lt;code&gt;MAYBE&lt;/code&gt; 참조 &lt;code&gt;n&lt;/code&gt; 발현 부작용과 &lt;code&gt;(incf n)&lt;/code&gt; . 때 &lt;code&gt;integer&lt;/code&gt; 3, 여기에 무슨이다 :</target>
        </trans-unit>
        <trans-unit id="fbc5a4ab37f1524874d8f0ded5207cb907043590" translate="yes" xml:space="preserve">
          <source>The direct effect of calling &lt;code&gt;provide&lt;/code&gt; is to add &lt;var&gt;feature&lt;/var&gt; to the front of &lt;code&gt;features&lt;/code&gt; if it is not already in that list and call any &lt;code&gt;eval-after-load&lt;/code&gt; code waiting for it (see &lt;a href=&quot;hooks-for-loading#Hooks-for-Loading&quot;&gt;Hooks for Loading&lt;/a&gt;). The argument &lt;var&gt;feature&lt;/var&gt; must be a symbol. &lt;code&gt;provide&lt;/code&gt; returns &lt;var&gt;feature&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;provide&lt;/code&gt; 호출의 직접적인 효과는 &lt;var&gt;feature&lt;/var&gt; 이 해당 목록에 아직없는 경우 &lt;code&gt;features&lt;/code&gt; 을 기능 앞에 추가 하고 대기중인 &lt;code&gt;eval-after-load&lt;/code&gt; 코드를 호출하는 것입니다 ( &lt;a href=&quot;hooks-for-loading#Hooks-for-Loading&quot;&gt;Hooks for Loading&lt;/a&gt; 참조 ). 인수 &lt;var&gt;feature&lt;/var&gt; 은 기호 여야합니다. 반품 &lt;var&gt;feature&lt;/var&gt; &lt;code&gt;provide&lt;/code&gt; 합니다 .</target>
        </trans-unit>
        <trans-unit id="c5e376c6c42e5e68d88b0c49222ae1c46a5afcef" translate="yes" xml:space="preserve">
          <source>The directory for expanding relative file names. This is the value of the buffer-local variable &lt;code&gt;default-directory&lt;/code&gt; (see &lt;a href=&quot;file-name-expansion#File-Name-Expansion&quot;&gt;File Name Expansion&lt;/a&gt;).</source>
          <target state="translated">상대 파일 이름을 확장하기위한 디렉토리입니다. 이것은 버퍼 로컬 변수 &lt;code&gt;default-directory&lt;/code&gt; 의 값입니다 ( &lt;a href=&quot;file-name-expansion#File-Name-Expansion&quot;&gt;파일 이름 확장&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="95896d2cb5e4e00827d6c52c6324b90256c8c47b" translate="yes" xml:space="preserve">
          <source>The directory for writing temporary files via &lt;code&gt;make-nearby-temp-file&lt;/code&gt;. In case of a remote &lt;code&gt;default-directory&lt;/code&gt;, this is a directory for temporary files on that remote host. If such a directory does not exist, or &lt;code&gt;default-directory&lt;/code&gt; ought to be located on a mounted file system (see &lt;code&gt;mounted-file-systems&lt;/code&gt;), the function returns &lt;code&gt;default-directory&lt;/code&gt;. For a non-remote and non-mounted &lt;code&gt;default-directory&lt;/code&gt;, the value of the variable &lt;code&gt;temporary-file-directory&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;make-nearby-temp-file&lt;/code&gt; 을 통해 임시 파일을 쓰기위한 디렉토리입니다 . 원격 &lt;code&gt;default-directory&lt;/code&gt; 의 경우 해당 원격 호스트의 임시 파일을위한 디렉토리입니다. 그러한 디렉토리가 없거나 &lt;code&gt;default-directory&lt;/code&gt; 가 마운트 된 파일 시스템에 있어야하는 경우 ( &lt;code&gt;mounted-file-systems&lt;/code&gt; 참조 ) 함수는 &lt;code&gt;default-directory&lt;/code&gt; 를 반환합니다 . 원격이 아니고 마운트되지 않은 &lt;code&gt;default-directory&lt;/code&gt; 의 경우 &lt;code&gt;temporary-file-directory&lt;/code&gt; 변수 값 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3f0c90883c01ceb7e1d412c839e69e9b41c49f91" translate="yes" xml:space="preserve">
          <source>The directory part of a file name, and the rest.</source>
          <target state="translated">파일 이름의 디렉토리 부분과 나머지.</target>
        </trans-unit>
        <trans-unit id="bb1425231fa4728dea70710d27bed5b876df285a" translate="yes" xml:space="preserve">
          <source>The display Property</source>
          <target state="translated">디스플레이 속성</target>
        </trans-unit>
        <trans-unit id="574c0a83bdb82c9364892cb8a35e8ae877142b4d" translate="yes" xml:space="preserve">
          <source>The display on which to open this frame. It should be a string of the form &amp;lsquo;</source>
          <target state="translated">이 프레임을 열 디스플레이입니다. ''형식의 문자열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="d4d99dccff6bb38fa72897f95b5acb0e7a7f0c6b" translate="yes" xml:space="preserve">
          <source>The display routines insist that the position of point be visible when a buffer is displayed. Normally, they select the display-start position according to their internal logic (and scroll the window if necessary) to make point visible. However, if you specify the start position with this function using &lt;code&gt;nil&lt;/code&gt; for &lt;var&gt;noforce&lt;/var&gt;, it means you want display to start at &lt;var&gt;position&lt;/var&gt; even if that would put the location of point off the screen. If this does place point off screen, the display routines attempt to move point to the left margin on the middle line in the window.</source>
          <target state="translated">디스플레이 루틴은 버퍼가 표시 될 때 포인트의 위치가 보이도록 요구합니다. 일반적으로 내부 논리에 따라 디스플레이 시작 위치를 선택하고 필요한 경우 창을 스크롤하여 포인트를 표시합니다. 그러나 &lt;var&gt;noforce&lt;/var&gt; 에 &lt;code&gt;nil&lt;/code&gt; 을 사용하여이 함수를 사용하여 시작 위치를 지정 하면 화면에서 지점의 위치를 ​​벗어나도 &lt;var&gt;position&lt;/var&gt; 에서 시작하기를 원한다는 의미 입니다. 이것이 화면 밖으로 포인트를 배치하는 경우, 디스플레이 루틴은 포인트를 창의 중간 라인의 왼쪽 여백으로 이동하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="cfbe7f152c0b39bedc406ebf65bdbb56682447f9" translate="yes" xml:space="preserve">
          <source>The display table also has six &lt;em&gt;extra slots&lt;/em&gt; which serve special purposes. Here is a table of their meanings; &lt;code&gt;nil&lt;/code&gt; in any slot means to use the default for that slot, as stated below.</source>
          <target state="translated">디스플레이 테이블에는 특별한 용도로 사용할 수있는 6 개의 &lt;em&gt;추가 슬롯&lt;/em&gt; 이 있습니다. 다음은 그 의미에 대한 표입니다. 모든 슬롯에서 &lt;code&gt;nil&lt;/code&gt; 은 아래에 설명 된대로 해당 슬롯에 대한 기본값을 사용함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d74cb6c53f98889ae644a4ae44d69a5aaec11ebc" translate="yes" xml:space="preserve">
          <source>The distinction between the values &lt;code&gt;t&lt;/code&gt; and &lt;code&gt;auto-raise&lt;/code&gt; is not needed for &amp;ldquo;normal&amp;rdquo; frames because the window manager usually takes care of raising them. It is useful to automatically raise child frames via &lt;code&gt;mouse-autoselect-window&lt;/code&gt; (see &lt;a href=&quot;mouse-window-auto_002dselection#Mouse-Window-Auto_002dselection&quot;&gt;Mouse Window Auto-selection&lt;/a&gt;).</source>
          <target state="translated">창 관리자가 일반적으로 프레임을 올리기 때문에 &quot;일반&quot;프레임 에는 값 &lt;code&gt;t&lt;/code&gt; 와 &lt;code&gt;auto-raise&lt;/code&gt; 사이의 구분 이 필요하지 않습니다. &lt;code&gt;mouse-autoselect-window&lt;/code&gt; 를 통해 자식 프레임을 자동으로 올리는 것이 유용합니다 ( &lt;a href=&quot;mouse-window-auto_002dselection#Mouse-Window-Auto_002dselection&quot;&gt;Mouse Window Auto-selection 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="ac49afe1f8b1d00c40d5b387f20271f4e9795b2b" translate="yes" xml:space="preserve">
          <source>The documentation for the variable, as a C comment. See &lt;a href=&quot;documentation-basics#Documentation-Basics&quot;&gt;Documentation Basics&lt;/a&gt;, for more details.</source>
          <target state="translated">변수에 대한 문서 (C 주석). 자세한 내용은 &lt;a href=&quot;documentation-basics#Documentation-Basics&quot;&gt;문서 기본 사항&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9096506924630d76469ff43fb14e930091df8acb" translate="yes" xml:space="preserve">
          <source>The documentation string (if any); otherwise, &lt;code&gt;nil&lt;/code&gt;. The value may be a number or a list, in case the documentation string is stored in a file. Use the function &lt;code&gt;documentation&lt;/code&gt; to get the real documentation string (see &lt;a href=&quot;accessing-documentation#Accessing-Documentation&quot;&gt;Accessing Documentation&lt;/a&gt;).</source>
          <target state="translated">문서 문자열 (있는 경우) 그렇지 않으면 &lt;code&gt;nil&lt;/code&gt; 입니다. 문서 문자열이 파일에 저장된 경우 값은 숫자 또는 목록 일 수 있습니다. 함수 &lt;code&gt;documentation&lt;/code&gt; 를 사용하여 실제 문서 문자열을 얻으십시오 (문서 &lt;a href=&quot;accessing-documentation#Accessing-Documentation&quot;&gt;액세스&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="7cda64b5ea11cd6957b261df860267c56e609865" translate="yes" xml:space="preserve">
          <source>The documentation string can be followed by a list of C function attributes for the C function that implements the primitive, like this:</source>
          <target state="translated">문서 문자열 뒤에는 다음과 같이 프리미티브를 구현하는 C 함수에 대한 C 함수 속성 목록이 올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2c2488aff2b6b2c8931c7861476fd8beada96a4" translate="yes" xml:space="preserve">
          <source>The documentation string is a Lisp string object placed within the function definition to describe the function for the Emacs help facilities. See &lt;a href=&quot;function-documentation#Function-Documentation&quot;&gt;Function Documentation&lt;/a&gt;.</source>
          <target state="translated">문서화 문자열은 Emacs 도움말 기능에 대한 함수를 설명하기 위해 함수 정의 내에 배치 된 Lisp 문자열 객체입니다. &lt;a href=&quot;function-documentation#Function-Documentation&quot;&gt;함수 문서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8798fcbcbfa841bfd2050e9aff8cc8aa58c79b62" translate="yes" xml:space="preserve">
          <source>The documentation string may include the special documentation substrings, &amp;lsquo;</source>
          <target state="translated">문서 문자열에는 특수 문서 하위 문자열 '</target>
        </trans-unit>
        <trans-unit id="ea2c69ace2daf00b95cdbfd31c14d5463703de87" translate="yes" xml:space="preserve">
          <source>The dumped</source>
          <target state="translated">버려진</target>
        </trans-unit>
        <trans-unit id="eb89833eef2d50da5011e2727744d05d6002e503" translate="yes" xml:space="preserve">
          <source>The dynamic loading feature has certain disadvantages:</source>
          <target state="translated">동적 로딩 기능에는 다음과 같은 몇 가지 단점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="07a8b495dabf40d957fd26c3bb5cf9abd29e9d67" translate="yes" xml:space="preserve">
          <source>The earliest GNU Emacs versions represented meta characters as codes in the range of 128 to 255. At that time, the basic character codes ranged from 0 to 127, so all keyboard character codes did fit in a string. Many Lisp programs used &amp;lsquo;</source>
          <target state="translated">초기 GNU Emacs 버전은 메타 문자를 128에서 255 사이의 코드로 표현했습니다. 당시 기본 문자 코드는 0에서 127까지 였으므로 모든 키보드 문자 코드는 문자열에 맞았습니다. 많은 Lisp 프로그램이 '</target>
        </trans-unit>
        <trans-unit id="f317bf5e201146dfa917711748b39145e9d9a2e3" translate="yes" xml:space="preserve">
          <source>The easiest way to construct a keymap with a prompt string is to specify the string as an argument when you call &lt;code&gt;make-keymap&lt;/code&gt;, &lt;code&gt;make-sparse-keymap&lt;/code&gt; (see &lt;a href=&quot;creating-keymaps#Creating-Keymaps&quot;&gt;Creating Keymaps&lt;/a&gt;), or &lt;code&gt;define-prefix-command&lt;/code&gt; (see &lt;a href=&quot;prefix-keys#Definition-of-define_002dprefix_002dcommand&quot;&gt;Definition of define-prefix-command&lt;/a&gt;). If you do not want the keymap to operate as a menu, don&amp;rsquo;t specify a prompt string for it.</source>
          <target state="translated">프롬프트 문자열로 키맵을 생성하는 가장 쉬운 방법은 &lt;code&gt;make-keymap&lt;/code&gt; , &lt;code&gt;make-sparse-keymap&lt;/code&gt; ( 키맵 &lt;a href=&quot;creating-keymaps#Creating-Keymaps&quot;&gt;생성&lt;/a&gt; 참조 ) 또는 &lt;code&gt;define-prefix-command&lt;/code&gt; ( define-prefix 정의 참조 ) 를 호출 할 때 문자열을 인수로 지정하는 것 &lt;a href=&quot;prefix-keys#Definition-of-define_002dprefix_002dcommand&quot;&gt;입니다. -명령&lt;/a&gt; ). 키맵이 메뉴로 작동하지 않도록하려면 프롬프트 문자열을 지정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="14b25b9720e3a5abd52e30eefdd4ec23c3d93327" translate="yes" xml:space="preserve">
          <source>The easiest way to insert and manipulate links is to use the &lt;code&gt;button&lt;/code&gt; package. See &lt;a href=&quot;buttons#Buttons&quot;&gt;Buttons&lt;/a&gt;. In this section, we will explain how to manually set up clickable text in a buffer, using text properties. For simplicity, we will refer to the clickable text as a &lt;em&gt;link&lt;/em&gt;.</source>
          <target state="translated">링크를 삽입하고 조작하는 가장 쉬운 방법은 &lt;code&gt;button&lt;/code&gt; 패키지 를 사용하는 것 입니다. &lt;a href=&quot;buttons#Buttons&quot;&gt;버튼을&lt;/a&gt; 참조하십시오 . 이 섹션에서는 텍스트 속성을 사용하여 버퍼에서 클릭 가능한 텍스트를 수동으로 설정하는 방법을 설명합니다. 간단히하기 위해 클릭 가능한 텍스트를 &lt;em&gt;링크라고&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="adefbbe3ec3b1c020185f3ff9029cdd73908a5c0" translate="yes" xml:space="preserve">
          <source>The easiest way to make a string with text properties is with &lt;code&gt;propertize&lt;/code&gt;:</source>
          <target state="translated">텍스트 속성으로 문자열을 만드는 가장 쉬운 방법은 &lt;code&gt;propertize&lt;/code&gt; 를 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="21ee8bf0f869856280213273b1b77146340d0758" translate="yes" xml:space="preserve">
          <source>The easiest way to mark a function as obsolete is to put a &lt;code&gt;(declare (obsolete &amp;hellip;))&lt;/code&gt; form in the function&amp;rsquo;s &lt;code&gt;defun&lt;/code&gt; definition. See &lt;a href=&quot;declare-form#Declare-Form&quot;&gt;Declare Form&lt;/a&gt;. Alternatively, you can use the &lt;code&gt;make-obsolete&lt;/code&gt; function, described below.</source>
          <target state="translated">함수를 구식으로 표시하는 가장 쉬운 방법 은 함수의 &lt;code&gt;defun&lt;/code&gt; 정의에 &lt;code&gt;(declare (obsolete &amp;hellip;))&lt;/code&gt; 형식 을 넣는 것 입니다. &lt;a href=&quot;declare-form#Declare-Form&quot;&gt;신고 양식을&lt;/a&gt; 참조하십시오 . 또는 아래에 설명 된 &lt;code&gt;make-obsolete&lt;/code&gt; 기능을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e578edece4b9081d5686e88591733ede2ce224d7" translate="yes" xml:space="preserve">
          <source>The easiest way to write a major mode is to use the macro &lt;code&gt;define-derived-mode&lt;/code&gt;, which sets up the new mode as a variant of an existing major mode. See &lt;a href=&quot;derived-modes#Derived-Modes&quot;&gt;Derived Modes&lt;/a&gt;. We recommend using &lt;code&gt;define-derived-mode&lt;/code&gt; even if the new mode is not an obvious derivative of another mode, as it automatically enforces many coding conventions for you. See &lt;a href=&quot;basic-major-modes#Basic-Major-Modes&quot;&gt;Basic Major Modes&lt;/a&gt;, for common modes to derive from.</source>
          <target state="translated">주 모드를 작성하는 가장 쉬운 방법 은 기존 주 모드의 변형으로 새 모드를 설정 하는 매크로 &lt;code&gt;define-derived-mode&lt;/code&gt; 를 사용하는 것 입니다. &lt;a href=&quot;derived-modes#Derived-Modes&quot;&gt;파생 모드를&lt;/a&gt; 참조하십시오 . 새로운 모드가 다른 모드의 명백한 파생물이 아니더라도 &lt;code&gt;define-derived-mode&lt;/code&gt; 사용 하는 것이 좋습니다. 자동으로 많은 코딩 규칙을 적용하기 때문입니다. 파생되는 공통 모드는 &lt;a href=&quot;basic-major-modes#Basic-Major-Modes&quot;&gt;기본 주요 모드를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d3ecb997307ce78019c7f2cc8553cc19a83270a2" translate="yes" xml:space="preserve">
          <source>The editor command loop automatically calls &lt;code&gt;undo-boundary&lt;/code&gt; just before executing each key sequence, so that each undo normally undoes the effects of one command. A few exceptional commands are &lt;em&gt;amalgamating&lt;/em&gt;: these commands generally cause small changes to buffers, so with these a boundary is inserted only every 20th command, allowing the changes to be undone as a group. By default, the commands &lt;code&gt;self-insert-command&lt;/code&gt;, which produces self-inserting input characters (see &lt;a href=&quot;commands-for-insertion#Commands-for-Insertion&quot;&gt;Commands for Insertion&lt;/a&gt;), and &lt;code&gt;delete-char&lt;/code&gt;, which deletes characters (see &lt;a href=&quot;deletion#Deletion&quot;&gt;Deletion&lt;/a&gt;), are amalgamating. Where a command affects the contents of several buffers, as may happen, for example, when a function on the &lt;code&gt;post-command-hook&lt;/code&gt; affects a buffer other than the &lt;code&gt;current-buffer&lt;/code&gt;, then &lt;code&gt;undo-boundary&lt;/code&gt; will be called in each of the affected buffers.</source>
          <target state="translated">편집기 명령 루프는 각 키 시퀀스를 실행하기 직전에 &lt;code&gt;undo-boundary&lt;/code&gt; 자동으로 호출 하므로 각 실행 취소는 일반적으로 한 명령의 효과를 실행 취소합니다. 몇 가지 예외적 인 명령이 &lt;em&gt;합쳐져 있습니다&lt;/em&gt; . 이러한 명령은 일반적으로 버퍼에 작은 변경을 일으키므로 20 번째 명령마다 경계가 삽입되어 변경 사항을 그룹으로 취소 할 수 있습니다. 기본적으로 자체 삽입 입력 문자 (삽입 &lt;code&gt;self-insert-command&lt;/code&gt; )를 생성하는 self-insert-command 명령 과 문자를 삭제 ( &lt;a href=&quot;deletion#Deletion&quot;&gt;Deletion&lt;/a&gt; 참조 ) 하는 &lt;code&gt;delete-char&lt;/code&gt; &lt;a href=&quot;commands-for-insertion#Commands-for-Insertion&quot;&gt;명령&lt;/a&gt; 이 합쳐집니다. 명령이 여러 버퍼의 내용에 영향을 미치는 경우 (예 : &lt;code&gt;post-command-hook&lt;/code&gt; 댄 다른 버퍼 영향 &lt;code&gt;current-buffer&lt;/code&gt; 후, &lt;code&gt;undo-boundary&lt;/code&gt; 해당 버퍼의 각각에 호출 될 것이다.</target>
        </trans-unit>
        <trans-unit id="6175dd788a5ec79d9f8f9e1ade63289de866ae73" translate="yes" xml:space="preserve">
          <source>The editor command loop reads key sequences using the function &lt;code&gt;read-key-sequence&lt;/code&gt;, which uses &lt;code&gt;read-event&lt;/code&gt;. These and other functions for event input are also available for use in Lisp programs. See also &lt;code&gt;momentary-string-display&lt;/code&gt; in &lt;a href=&quot;temporary-displays#Temporary-Displays&quot;&gt;Temporary Displays&lt;/a&gt;, and &lt;code&gt;sit-for&lt;/code&gt; in &lt;a href=&quot;waiting#Waiting&quot;&gt;Waiting&lt;/a&gt;. See &lt;a href=&quot;terminal-input#Terminal-Input&quot;&gt;Terminal Input&lt;/a&gt;, for functions and variables for controlling terminal input modes and debugging terminal input.</source>
          <target state="translated">편집기 명령 루프 는 &lt;code&gt;read-event&lt;/code&gt; 를 사용하는 &lt;code&gt;read-key-sequence&lt;/code&gt; 함수를 사용하여 키 시퀀스를 읽습니다 . 이벤트 입력을위한 이러한 기능과 기타 기능은 Lisp 프로그램에서도 사용할 수 있습니다. 참조 &lt;code&gt;momentary-string-display&lt;/code&gt; 에 &lt;a href=&quot;temporary-displays#Temporary-Displays&quot;&gt;임시 표시&lt;/a&gt; 하고 &lt;code&gt;sit-for&lt;/code&gt; 에서 &lt;a href=&quot;waiting#Waiting&quot;&gt;대기&lt;/a&gt; . 터미널 입력 모드를 제어하고 터미널 입력을 디버깅하기위한 함수 및 변수는 &lt;a href=&quot;terminal-input#Terminal-Input&quot;&gt;터미널 입력을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b769abdeba8adfc9ee85136ec1467551431d0212" translate="yes" xml:space="preserve">
          <source>The editor command loop sets several Lisp variables to keep status records for itself and for commands that are run. With the exception of &lt;code&gt;this-command&lt;/code&gt; and &lt;code&gt;last-command&lt;/code&gt; it&amp;rsquo;s generally a bad idea to change any of these variables in a Lisp program.</source>
          <target state="translated">편집기 명령 루프는 여러 Lisp 변수를 설정하여 자체 및 실행되는 명령에 대한 상태 레코드를 유지합니다. &lt;code&gt;this-command&lt;/code&gt; 과 &lt;code&gt;last-command&lt;/code&gt; 명령을 제외하고 일반적으로 Lisp 프로그램에서 이러한 변수를 변경하는 것은 좋지 않습니다.</target>
        </trans-unit>
        <trans-unit id="67b5a363399c8d1cc2c7c2647d77f745ef5552bd" translate="yes" xml:space="preserve">
          <source>The effect is that this keymap inherits all the bindings of &lt;var&gt;parent-keymap&lt;/var&gt;, whatever they may be at the time a key is looked up, but can add to them or override them with &lt;var&gt;elements&lt;/var&gt;.</source>
          <target state="translated">결과는이 키맵이 &lt;var&gt;parent-keymap&lt;/var&gt; 의 모든 바인딩을 상속한다는 것입니다 . 키를 조회 할 때 어떤 것이 든 상관없이 추가하거나 &lt;var&gt;elements&lt;/var&gt; 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="591769f891f8125425d2075adee208efc1bbcaaa" translate="yes" xml:space="preserve">
          <source>The effect of &lt;code&gt;debug&lt;/code&gt; here is only to prevent &lt;code&gt;condition-case&lt;/code&gt; from suppressing the call to the debugger. Any given error will invoke the debugger only if &lt;code&gt;debug-on-error&lt;/code&gt; and the other usual filtering mechanisms say it should. See &lt;a href=&quot;error-debugging#Error-Debugging&quot;&gt;Error Debugging&lt;/a&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;debug&lt;/code&gt; 의 효과는 &lt;code&gt;condition-case&lt;/code&gt; 가 디버거 호출을 억제 하지 못하도록 하는 것입니다. 주어진 오류는 오류시 &lt;code&gt;debug-on-error&lt;/code&gt; 및 기타 일반적인 필터링 메커니즘에서 그래야한다고 말하는 경우에만 디버거를 호출 합니다. &lt;a href=&quot;error-debugging#Error-Debugging&quot;&gt;오류 디버깅을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2140fa127d13bbd573539409dfa58bf7787589bd" translate="yes" xml:space="preserve">
          <source>The effective user ID of the user who invoked the process. The corresponding &lt;var&gt;value&lt;/var&gt; is a number. If the process was invoked by the same user who runs the current Emacs session, the value is identical to what &lt;code&gt;user-uid&lt;/code&gt; returns (see &lt;a href=&quot;user-identification#User-Identification&quot;&gt;User Identification&lt;/a&gt;).</source>
          <target state="translated">프로세스를 호출 한 사용자의 유효 사용자 ID입니다. 해당 &lt;var&gt;value&lt;/var&gt; 은 숫자입니다. 현재 Emacs 세션을 실행하는 동일한 사용자에 의해 프로세스가 호출 된 경우 값은 &lt;code&gt;user-uid&lt;/code&gt; 가 반환 하는 것과 동일 합니다 ( &lt;a href=&quot;user-identification#User-Identification&quot;&gt;사용자 식별&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="054dbf07fdb389c2141619772a29e0e605f543c4" translate="yes" xml:space="preserve">
          <source>The element &lt;var&gt;position&lt;/var&gt; is a list describing the position of the event, in the same format as used in a mouse-click event (see &lt;a href=&quot;click-events#Click-Events&quot;&gt;Click Events&lt;/a&gt;), and &lt;var&gt;files&lt;/var&gt; is the list of file names that were dragged and dropped. The usual way to handle this event is by visiting these files.</source>
          <target state="translated">요소의 &lt;var&gt;position&lt;/var&gt; 마우스 클릭 이벤트에서 사용합니다 (같은 형식의 이벤트의 위치를 설명하는 목록입니다 &lt;a href=&quot;click-events#Click-Events&quot;&gt;이벤트를 클릭&lt;/a&gt; )하고, &lt;var&gt;files&lt;/var&gt; 드래그 앤 드롭 한 파일 이름의 목록입니다. 이 이벤트를 처리하는 일반적인 방법은 이러한 파일을 방문하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="39de66e9c3f4b1f00f3f70922dee79dd2890c1eb" translate="yes" xml:space="preserve">
          <source>The elements &lt;code&gt;left-fringe&lt;/code&gt;, &lt;code&gt;right-fringe&lt;/code&gt;, &lt;code&gt;left-margin&lt;/code&gt;, &lt;code&gt;right-margin&lt;/code&gt;, &lt;code&gt;scroll-bar&lt;/code&gt;, and &lt;code&gt;text&lt;/code&gt; specify the width of the corresponding area of the window. When the window displays line numbers (see &lt;a href=&quot;size-of-displayed-text#Size-of-Displayed-Text&quot;&gt;Size of Displayed Text&lt;/a&gt;), the width of the &lt;code&gt;text&lt;/code&gt; area is decreased by the screen space taken by the line-number display.</source>
          <target state="translated">요소는 &lt;code&gt;left-fringe&lt;/code&gt; , &lt;code&gt;right-fringe&lt;/code&gt; , &lt;code&gt;left-margin&lt;/code&gt; , &lt;code&gt;right-margin&lt;/code&gt; , &lt;code&gt;scroll-bar&lt;/code&gt; 및 &lt;code&gt;text&lt;/code&gt; 윈도우의 대응 영역의 폭을 지정. 창에 줄 번호가 표시 될 때 ( &lt;a href=&quot;size-of-displayed-text#Size-of-Displayed-Text&quot;&gt;표시되는 텍스트 크기 참조&lt;/a&gt; ) &lt;code&gt;text&lt;/code&gt; 영역 의 너비 는 줄 번호 디스플레이가 차지하는 화면 공간만큼 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="c19e4ee125f09b12484bc3bf030c6cee2240307a" translate="yes" xml:space="preserve">
          <source>The elements &lt;var&gt;beg&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt; are integers, and together specify a range of indices in the string; &lt;var&gt;plist&lt;/var&gt; is the property list for that range. For example,</source>
          <target state="translated">&lt;var&gt;beg&lt;/var&gt; 및 &lt;var&gt;end&lt;/var&gt; 요소 는 정수이며 함께 문자열에서 인덱스 범위를 지정합니다. &lt;var&gt;plist&lt;/var&gt; 는 해당 범위에 대한 속성 목록입니다. 예를 들면</target>
        </trans-unit>
        <trans-unit id="819edd219dab7009427b8b49d18302d9e0dce52d" translate="yes" xml:space="preserve">
          <source>The elements of an array may be referenced or changed with the functions &lt;code&gt;aref&lt;/code&gt; and &lt;code&gt;aset&lt;/code&gt;, respectively (see &lt;a href=&quot;array-functions#Array-Functions&quot;&gt;Array Functions&lt;/a&gt;).</source>
          <target state="translated">배열의 요소는 &lt;code&gt;aref&lt;/code&gt; 및 &lt;code&gt;aset&lt;/code&gt; 함수를 사용하여 각각 참조되거나 변경 될 수 있습니다 ( &lt;a href=&quot;array-functions#Array-Functions&quot;&gt;배열 함수&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="6f5842ceb731b62f33d895e3247a64f0979807eb" translate="yes" xml:space="preserve">
          <source>The elements of the &lt;code&gt;command-switch-alist&lt;/code&gt; look like this:</source>
          <target state="translated">&lt;code&gt;command-switch-alist&lt;/code&gt; 의 요소는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1f8aa67132fef0998682c755d2d95f66a05ef6fd" translate="yes" xml:space="preserve">
          <source>The elements of the alist are ordered so that the &lt;var&gt;key&lt;/var&gt; increases in length. The first element is always &lt;code&gt;([] . &lt;var&gt;keymap&lt;/var&gt;)&lt;/code&gt;, because the specified keymap is accessible from itself with a prefix of no events.</source>
          <target state="translated">alist의 요소는 &lt;var&gt;key&lt;/var&gt; 길이가 증가 하도록 정렬 됩니다. 첫 번째 요소는 항상 &lt;code&gt;([] . &lt;var&gt;keymap&lt;/var&gt;)&lt;/code&gt; 지정된 키맵은 이벤트가없는 접두사로 자체적으로 액세스 할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="bb682157302be72c8e42a6b49f1e7cf04e43ecde" translate="yes" xml:space="preserve">
          <source>The elements of the list describe the types of the arguments of a calling form. The possible elements of a specification list are described in the following sections.</source>
          <target state="translated">목록의 요소는 호출 양식의 인수 유형을 설명합니다. 사양 목록의 가능한 요소는 다음 섹션에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0572510e8d9760b2ddeeb43410bcfcd96d01ed05" translate="yes" xml:space="preserve">
          <source>The elements of the list, in order, are:</source>
          <target state="translated">목록의 요소는 순서대로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fdd58fe0f1c0198924c53540b3cf5d2e3265fcff" translate="yes" xml:space="preserve">
          <source>The end of a key sequence is detected when that key sequence either is bound to a command, or when Emacs determines that no additional event can lead to a sequence that is bound to a command.</source>
          <target state="translated">키 시퀀스가 ​​명령에 바인딩되어 있거나 Emacs가 추가 이벤트가 명령에 바인딩 된 시퀀스로 이어질 수 없다고 판단 할 때 키 시퀀스의 끝이 감지됩니다.</target>
        </trans-unit>
        <trans-unit id="3c6ae9a7bf2d6a50e19bef0d7e64a8b9acd8c0d0" translate="yes" xml:space="preserve">
          <source>The environment variable name is the series of alphanumeric characters (including underscores) that follow the &amp;lsquo;</source>
          <target state="translated">환경 변수 이름은 '뒤에 오는 일련의 영숫자 (밑줄 포함)입니다.</target>
        </trans-unit>
        <trans-unit id="3b59d11b9a544f51d2f70a6e20d15c14a62127ce" translate="yes" xml:space="preserve">
          <source>The equality tests use &lt;code&gt;eql&lt;/code&gt;.</source>
          <target state="translated">동등성 테스트는 &lt;code&gt;eql&lt;/code&gt; 을 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="32741737ac9bfd8a3c48ea4752a47b7630b57432" translate="yes" xml:space="preserve">
          <source>The equivalences table maps each one of a set of case-related characters into the next character in that set.</source>
          <target state="translated">동등성 테이블은 대소 문자 관련 문자 세트 각각을 해당 세트의 다음 문자로 맵핑합니다.</target>
        </trans-unit>
        <trans-unit id="52b719d4135d0c266c0f2bf15ce2d2663180f53c" translate="yes" xml:space="preserve">
          <source>The error message for this error looks like this:</source>
          <target state="translated">이 오류에 대한 오류 메시지는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8003c4b046bb80fba143c9330ff6bd66ac7fbc19" translate="yes" xml:space="preserve">
          <source>The error string should start with a capital letter but it should not end with a period. This is for consistency with the rest of Emacs.</source>
          <target state="translated">오류 문자열은 대문자로 시작해야하지만 마침표로 끝나서는 안됩니다. 이것은 나머지 Emacs와의 일관성을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="7b8cbe15ec1efdbd3cf5c2578bd1e52ef550cbd8" translate="yes" xml:space="preserve">
          <source>The event type of a double-click event contains the prefix &amp;lsquo;</source>
          <target state="translated">더블 클릭 이벤트의 이벤트 유형에는 접두사 '</target>
        </trans-unit>
        <trans-unit id="e2a9fed30f47fc30631b38b43fbe44a5b00c8585" translate="yes" xml:space="preserve">
          <source>The event type of a function key event is the event symbol itself. See &lt;a href=&quot;classifying-events#Classifying-Events&quot;&gt;Classifying Events&lt;/a&gt;.</source>
          <target state="translated">기능 키 이벤트의 이벤트 유형은 이벤트 기호 자체입니다. &lt;a href=&quot;classifying-events#Classifying-Events&quot;&gt;이벤트 분류를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="46f0d795e1cfdd0fd1c184633351122a8cb62235" translate="yes" xml:space="preserve">
          <source>The event-reading functions invoke the current input method, if any (see &lt;a href=&quot;input-methods#Input-Methods&quot;&gt;Input Methods&lt;/a&gt;). If the value of &lt;code&gt;input-method-function&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it should be a function; when &lt;code&gt;read-event&lt;/code&gt; reads a printing character (including</source>
          <target state="translated">이벤트 읽기 함수는 현재 입력 방법이있는 경우이를 호출합니다 ( &lt;a href=&quot;input-methods#Input-Methods&quot;&gt;입력 방법&lt;/a&gt; 참조 ). 값 경우 &lt;code&gt;input-method-function&lt;/code&gt; 비이다 &lt;code&gt;nil&lt;/code&gt; , 그 함수이어야한다; &lt;code&gt;read-event&lt;/code&gt; 가 인쇄 문자를 읽을 때</target>
        </trans-unit>
        <trans-unit id="c10bb80d00486007c951e5ce70467305dbc1efa0" translate="yes" xml:space="preserve">
          <source>The events types &lt;code&gt;iconify-frame&lt;/code&gt;, &lt;code&gt;make-frame-visible&lt;/code&gt;, &lt;code&gt;delete-frame&lt;/code&gt;, &lt;code&gt;drag-n-drop&lt;/code&gt;, &lt;code&gt;language-change&lt;/code&gt;, and user signals like &lt;code&gt;sigusr1&lt;/code&gt; are normally handled in this way. The keymap which defines how to handle special events&amp;mdash;and which events are special&amp;mdash;is in the variable &lt;code&gt;special-event-map&lt;/code&gt; (see &lt;a href=&quot;controlling-active-maps#Controlling-Active-Maps&quot;&gt;Controlling Active Maps&lt;/a&gt;).</source>
          <target state="translated">이벤트 유형 &lt;code&gt;iconify-frame&lt;/code&gt; , &lt;code&gt;make-frame-visible&lt;/code&gt; , &lt;code&gt;delete-frame&lt;/code&gt; , &lt;code&gt;drag-n-drop&lt;/code&gt; , &lt;code&gt;language-change&lt;/code&gt; 및 &lt;code&gt;sigusr1&lt;/code&gt; 과 같은 사용자 신호 는 일반적으로 이러한 방식으로 처리됩니다. 특수 이벤트를 처리하는 방법과 특별한 이벤트를 정의하는 키맵은 &lt;code&gt;special-event-map&lt;/code&gt; 변수 에 있습니다 ( &lt;a href=&quot;controlling-active-maps#Controlling-Active-Maps&quot;&gt;활성 맵 제어&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="2164e9087e02837e91965cf6aa67235eeccbe4f2" translate="yes" xml:space="preserve">
          <source>The events used so far in the lookup form a complete key, and &lt;var&gt;command&lt;/var&gt; is its binding. See &lt;a href=&quot;what-is-a-function#What-Is-a-Function&quot;&gt;What Is a Function&lt;/a&gt;.</source>
          <target state="translated">지금까지 조회에서 사용 된 이벤트는 완전한 키를 형성하며 &lt;var&gt;command&lt;/var&gt; 은 바인딩입니다. &lt;a href=&quot;what-is-a-function#What-Is-a-Function&quot;&gt;기능이란 무엇입니까?를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4b95399d88e6119154daacebbe8a8379841fe6c4" translate="yes" xml:space="preserve">
          <source>The events used so far in the lookup form a prefix key. The next event of the key sequence is looked up in &lt;var&gt;keymap&lt;/var&gt;.</source>
          <target state="translated">조회에서 지금까지 사용 된 이벤트는 접두사 키를 형성합니다. 키 시퀀스의 다음 이벤트는 &lt;var&gt;keymap&lt;/var&gt; 에서 조회됩니다 .</target>
        </trans-unit>
        <trans-unit id="70cf466181ddda55879b8d247515909cac59befd" translate="yes" xml:space="preserve">
          <source>The exact behavior when using a graphical file dialog is platform-dependent. Here, we simply document the behavior when using the minibuffer.</source>
          <target state="translated">그래픽 파일 대화 상자를 사용할 때 정확한 동작은 플랫폼에 따라 다릅니다. 여기에서는 미니 버퍼를 사용할 때의 동작을 간단히 문서화합니다.</target>
        </trans-unit>
        <trans-unit id="e1783ae90f7011d91125735b7e7f0336f43088d0" translate="yes" xml:space="preserve">
          <source>The exact rules are that at the beginning of a regexp, &amp;lsquo;</source>
          <target state="translated">정확한 규칙은 정규 표현식의 시작 부분에 '</target>
        </trans-unit>
        <trans-unit id="9d0825e8976bc9a5de722249e68385f249965ce0" translate="yes" xml:space="preserve">
          <source>The examples below use the characters &amp;lsquo;</source>
          <target state="translated">아래 예에서는 '</target>
        </trans-unit>
        <trans-unit id="103a1f6fa6f3ce096ff2216407f0ee23d1e12e82" translate="yes" xml:space="preserve">
          <source>The expansion should evaluate each macro arg once.</source>
          <target state="translated">확장은 각 매크로 인수를 한 번 평가해야합니다.</target>
        </trans-unit>
        <trans-unit id="143e736dc0ea57164827c20116a0aca1e23342fe" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;(require 'comint)&lt;/code&gt; loads the file</source>
          <target state="translated">표현식 &lt;code&gt;(require 'comint)&lt;/code&gt; 은 파일을로드합니다.</target>
        </trans-unit>
        <trans-unit id="860aceea4a994059f4b9c519435309d2edcc7bcc" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;(sit-for 0)&lt;/code&gt; is equivalent to &lt;code&gt;(redisplay)&lt;/code&gt;, i.e., it requests a redisplay, without any delay, if there is no pending input. See &lt;a href=&quot;forcing-redisplay#Forcing-Redisplay&quot;&gt;Forcing Redisplay&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;(sit-for 0)&lt;/code&gt; 표현식 은 &lt;code&gt;(redisplay)&lt;/code&gt; 와 동일합니다 . 즉, 대기중인 입력이없는 경우 지연없이 다시 표시를 요청합니다. &lt;a href=&quot;forcing-redisplay#Forcing-Redisplay&quot;&gt;강제 다시 표시를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="918f1833b3bdbe7be1276b1a8696214692e3b6ef" translate="yes" xml:space="preserve">
          <source>The expression &lt;var&gt;standard&lt;/var&gt; can be evaluated at various other times, too&amp;mdash;whenever the customization facility needs to know &lt;var&gt;option&lt;/var&gt;&amp;rsquo;s standard value. So be sure to use an expression which is harmless to evaluate at any time.</source>
          <target state="translated">표현 &lt;var&gt;standard&lt;/var&gt; 은 사용자 정의 기능이 &lt;var&gt;option&lt;/var&gt; 의 표준 값 을 알아야 할 때마다 다른 다양한 시간에도 평가할 수 있습니다 . 따라서 언제든지 평가할 수있는 무해한 표현을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e99a19bec0a84ecbd6e03a29490ce71aa3b4a055" translate="yes" xml:space="preserve">
          <source>The expressions you enter interactively (and their results) are lost when you continue execution; but you can set up an &lt;em&gt;evaluation list&lt;/em&gt; consisting of expressions to be evaluated each time execution stops.</source>
          <target state="translated">대화식으로 입력 한 표현식 (및 그 결과)은 계속 실행하면 손실됩니다. 그러나 실행이 중지 될 때마다 평가할 표현식으로 구성된 &lt;em&gt;평가 목록을&lt;/em&gt; 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="acb0941a66e54ab62147b1a507de3916f48108a1" translate="yes" xml:space="preserve">
          <source>The extra arguments &lt;var&gt;arguments&lt;/var&gt; specify the attributes to set, and the values for them. They should consist of alternating attribute names (such as &lt;code&gt;:family&lt;/code&gt; or &lt;code&gt;:underline&lt;/code&gt;) and values. Thus,</source>
          <target state="translated">추가 인수 &lt;var&gt;arguments&lt;/var&gt; 는 설정할 속성과 해당 값을 지정합니다. 대체 속성 이름 (예 &lt;code&gt;:family&lt;/code&gt; 또는 &lt;code&gt;:underline&lt;/code&gt; )과 값 으로 구성되어야 합니다. 그러므로,</target>
        </trans-unit>
        <trans-unit id="a7526765bc7635e644a9c02766e092ebdc6743ea" translate="yes" xml:space="preserve">
          <source>The extra table &lt;var&gt;canonicalize&lt;/var&gt; maps each character to a canonical equivalent; any two characters that are related by case-conversion have the same canonical equivalent character. For example, since &amp;lsquo;</source>
          <target state="translated">추가 테이블 &lt;var&gt;canonicalize&lt;/var&gt; 는 각 문자를 동등한 표준에 매핑합니다. 대소 문자 변환에 의해 관련된 두 문자는 동일한 표준 동등 문자를 갖습니다. 예를 들어 '</target>
        </trans-unit>
        <trans-unit id="4019803adf73bb1e408bce642878a6814f7ac48a" translate="yes" xml:space="preserve">
          <source>The extra table &lt;var&gt;equivalences&lt;/var&gt; is a map that cyclically permutes each equivalence class (of characters with the same canonical equivalent). (For ordinary</source>
          <target state="translated">추가 테이블 &lt;var&gt;equivalences&lt;/var&gt; 는 각 등가 클래스 (동일한 표준 등가 문자)를 주기적으로 순열하는 맵입니다. (보통</target>
        </trans-unit>
        <trans-unit id="d052c0df805ee1e73aad2615fef93dab0ce7e859" translate="yes" xml:space="preserve">
          <source>The face &lt;var&gt;face&lt;/var&gt; was defined.</source>
          <target state="translated">페이스 &lt;var&gt;face&lt;/var&gt; 정의 하였다.</target>
        </trans-unit>
        <trans-unit id="07cf6c9593efbd571e9c6bc6592f49d62f4691d2" translate="yes" xml:space="preserve">
          <source>The faces are listed with descriptions of their typical usage, and in order of greater to lesser prominence. If a mode&amp;rsquo;s syntactic categories do not fit well with the usage descriptions, the faces can be assigned using the ordering as a guide.</source>
          <target state="translated">얼굴은 일반적인 사용법에 대한 설명과 함께 표시되며 눈에 잘 띄는 순으로 나열됩니다. 모드의 구문 범주가 사용법 설명과 잘 맞지 않으면 순서를 지침으로 사용하여 얼굴을 할당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3adedd7760a2da26b8105efc074b6a1a33143e97" translate="yes" xml:space="preserve">
          <source>The feature &lt;var&gt;feature&lt;/var&gt; was provided.</source>
          <target state="translated">기능 &lt;var&gt;feature&lt;/var&gt; 이 제공되었습니다.</target>
        </trans-unit>
        <trans-unit id="5684eb8ff3a533e9acfb4f148b31be6cf5c33b8f" translate="yes" xml:space="preserve">
          <source>The feature &lt;var&gt;feature&lt;/var&gt; was required.</source>
          <target state="translated">기능 &lt;var&gt;feature&lt;/var&gt; 이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="70390d43913607356ec3483eaaea0f10e086c2b4" translate="yes" xml:space="preserve">
          <source>The fields of a process (for a complete list, see the definition of &lt;code&gt;struct Lisp_Process&lt;/code&gt; in</source>
          <target state="translated">전체 목록은 프로세스의 필드 (의 정의를 참조 &lt;code&gt;struct Lisp_Process&lt;/code&gt; 의를</target>
        </trans-unit>
        <trans-unit id="f16afc33ed846d12b97600fcfe0ed162892cfbb4" translate="yes" xml:space="preserve">
          <source>The fields of a window (for a complete list, see the definition of &lt;code&gt;struct window&lt;/code&gt; in</source>
          <target state="translated">전체 목록은 윈도우의 필드는 (의 정의를 참조 &lt;code&gt;struct window&lt;/code&gt; 에서을</target>
        </trans-unit>
        <trans-unit id="14ce59edc1be8242ff84e768676f78ed344512ee" translate="yes" xml:space="preserve">
          <source>The fifth argument &lt;var&gt;copy-contents&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, means to copy the contents of &lt;var&gt;dirname&lt;/var&gt; directly into &lt;var&gt;newname&lt;/var&gt; if the latter is a directory name, instead of copying &lt;var&gt;dirname&lt;/var&gt; into it as a subdirectory.</source>
          <target state="translated">다섯 번째 인수 &lt;var&gt;copy-contents&lt;/var&gt; , 비 경우 &lt;code&gt;nil&lt;/code&gt; , 수단의 내용을 복사 &lt;var&gt;dirname&lt;/var&gt; 직접적으로 &lt;var&gt;newname&lt;/var&gt; 의 후자 복사하는 대신에, 디렉토리 이름이면 &lt;var&gt;dirname&lt;/var&gt; 은이 서브 디렉토리로로.</target>
        </trans-unit>
        <trans-unit id="dcfbbcf90dfb29480dabe34cba14a8aa961dc30c" translate="yes" xml:space="preserve">
          <source>The fifth argument, &lt;var&gt;no-remap&lt;/var&gt;, determines how this function treats command remappings (see &lt;a href=&quot;remapping-commands#Remapping-Commands&quot;&gt;Remapping Commands&lt;/a&gt;). There are two cases of interest:</source>
          <target state="translated">다섯 번째 인수 &lt;var&gt;no-remap&lt;/var&gt; ,이 기능을 취급이 재 매핑 (참조 명령 결정 방법 &lt;a href=&quot;remapping-commands#Remapping-Commands&quot;&gt;다시 매핑 명령어&lt;/a&gt; ). 두 가지 관심 사례가 있습니다.</target>
        </trans-unit>
        <trans-unit id="56bd5499d60d7cc9296335a519b5d67af9c7d7ca" translate="yes" xml:space="preserve">
          <source>The fifth of these hooks is run when a &lt;em&gt;window configuration change&lt;/em&gt; has been detected which means that either the buffer or the size of a window changed. It differs from the four preceding hooks in the way it is run.</source>
          <target state="translated">이 후크 중 다섯 번째는 &lt;em&gt;창 구성 변경&lt;/em&gt; 이 감지 되었을 때 실행 되며 이는 버퍼 또는 창의 크기가 &lt;em&gt;변경&lt;/em&gt; 되었음을 의미합니다. 실행 방식이 앞선 네 개의 후크와 다릅니다.</target>
        </trans-unit>
        <trans-unit id="97f57dbba7d52a111e94fa33d8036bc6b350fb92" translate="yes" xml:space="preserve">
          <source>The file descriptor for input from the process.</source>
          <target state="translated">프로세스의 입력에 대한 파일 설명자입니다.</target>
        </trans-unit>
        <trans-unit id="36604991f22732ab7544e1de9b5cbc643ee537e4" translate="yes" xml:space="preserve">
          <source>The file descriptor for output to the process.</source>
          <target state="translated">프로세스에 출력하기위한 파일 설명자입니다.</target>
        </trans-unit>
        <trans-unit id="9f84eaecd4c1e8e57755faa13303bc7e7b03876f" translate="yes" xml:space="preserve">
          <source>The file name of the font as a string. This can be &lt;code&gt;nil&lt;/code&gt; if the font back-end does not provide a way to find out the font&amp;rsquo;s file name.</source>
          <target state="translated">문자열로 된 글꼴의 파일 이름입니다. 글꼴 백엔드가 글꼴의 파일 이름을 찾는 방법을 제공하지 않는 경우 이는 &lt;code&gt;nil&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f32ef79257eb8ddf49002ec15d79f408c3bb5192" translate="yes" xml:space="preserve">
          <source>The file name of the notification icon. If set to &lt;code&gt;nil&lt;/code&gt;, no icon is displayed. The default is &lt;code&gt;notifications-application-icon&lt;/code&gt;.</source>
          <target state="translated">알림 아이콘의 파일 이름입니다. &lt;code&gt;nil&lt;/code&gt; 로 설정하면 아이콘이 표시되지 않습니다. 기본값은 &lt;code&gt;notifications-application-icon&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4c16e8ffefdfcb982bf11b0e3b2389776157f73d" translate="yes" xml:space="preserve">
          <source>The file ought to also contain one or more autoload magic comments, as explained in &lt;a href=&quot;packaging-basics#Packaging-Basics&quot;&gt;Packaging Basics&lt;/a&gt;. In the above example, a magic comment autoloads &lt;code&gt;superfrobnicator-mode&lt;/code&gt;.</source>
          <target state="translated">파일에는 &lt;a href=&quot;packaging-basics#Packaging-Basics&quot;&gt;패키징 기본 사항에&lt;/a&gt; 설명 된대로 하나 이상의 자동로드 매직 주석도 포함되어야합니다 . 위의 예에서 매직 주석은 &lt;code&gt;superfrobnicator-mode&lt;/code&gt; 를 자동으로로드 합니다 .</target>
        </trans-unit>
        <trans-unit id="cdc9cfc759343b8d06deb729dbcb7ad07ecd770e" translate="yes" xml:space="preserve">
          <source>The file&amp;rsquo;s</source>
          <target state="translated">파일의</target>
        </trans-unit>
        <trans-unit id="0fae8d03319845dad144dc1c7674908715fd1d6a" translate="yes" xml:space="preserve">
          <source>The file&amp;rsquo;s inode number (&lt;code&gt;file-attribute-inode-number&lt;/code&gt;), a nonnegative integer.</source>
          <target state="translated">파일의 inode 번호 ( &lt;code&gt;file-attribute-inode-number&lt;/code&gt; ), 음이 아닌 정수.</target>
        </trans-unit>
        <trans-unit id="5cd0cae54bf749d964c2e3a85496f50dbb2f4390" translate="yes" xml:space="preserve">
          <source>The file&amp;rsquo;s modes, as a string of ten letters or dashes, as in &amp;lsquo;</source>
          <target state="translated">'에서와 같이 10 개의 문자 또는 대시 문자열로 된 파일의 모드</target>
        </trans-unit>
        <trans-unit id="b8b5bfed28aef3a1155a21532be86f3c1a999048" translate="yes" xml:space="preserve">
          <source>The filesystem number of the device that the file is on &lt;code&gt;file-attribute-device-number&lt;/code&gt;), an integer. This element and the file&amp;rsquo;s inode number together give enough information to distinguish any two files on the system&amp;mdash;no two files can have the same values for both of these numbers.</source>
          <target state="translated">파일이 &lt;code&gt;file-attribute-device-number&lt;/code&gt; ) 에있는 장치의 파일 시스템 번호 , 정수. 이 요소와 파일의 inode 번호는 시스템에있는 두 파일을 구별하기에 충분한 정보를 제공합니다. 두 파일이이 두 번호에 대해 동일한 값을 가질 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9d1fb04dc7a2116b55da5d8efea1baf1fed3eb1e" translate="yes" xml:space="preserve">
          <source>The fill prefix follows the left margin whitespace, if any.</source>
          <target state="translated">채우기 접두사는 왼쪽 여백 공백 (있는 경우) 뒤에옵니다.</target>
        </trans-unit>
        <trans-unit id="cea1ef8b331e237b03da44fbd464cdb2d950b871" translate="yes" xml:space="preserve">
          <source>The final thing this command does is to run the hook &lt;code&gt;post-self-insert-hook&lt;/code&gt;. You could use this to automatically reindent text as it is typed, for example. If any function on this hook needs to act on the region (see &lt;a href=&quot;the-region#The-Region&quot;&gt;The Region&lt;/a&gt;), it should make sure Delete Selection mode (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Using-Region.html#Using-Region&quot;&gt;Delete Selection&lt;/a&gt; in</source>
          <target state="translated">이 명령이 수행하는 마지막 작업은 후크 &lt;code&gt;post-self-insert-hook&lt;/code&gt; 을 실행하는 것 입니다. 예를 들어이를 사용하여 텍스트를 입력 할 때 자동으로 다시 들여 쓰기 할 수 있습니다. 이 후크의 요구에 어떤 기능은 지역에 따라 행동하는 경우 (참조 &lt;a href=&quot;the-region#The-Region&quot;&gt;영역을&lt;/a&gt; , 그것은 확실히 삭제 선택 모드를해야한다) (참조 &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Using-Region.html#Using-Region&quot;&gt;삭제 선택&lt;/a&gt; 의를</target>
        </trans-unit>
        <trans-unit id="c1d3c86385f345c5bc7cf463d494da758eaabee6" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;n&lt;/code&gt; binds it to &lt;var&gt;expval&lt;/var&gt;, i.e., the result of evaluating &lt;code&gt;(* 3 3)&lt;/code&gt;, or 9.</source>
          <target state="translated">처음 &lt;code&gt;n&lt;/code&gt; 은 &lt;var&gt;expval&lt;/var&gt; , 즉 &lt;code&gt;(* 3 3)&lt;/code&gt; 또는 9 를 평가 한 결과에 바인딩합니다 .</target>
        </trans-unit>
        <trans-unit id="41a0ddbc0dd4de61e99ae8c86c48d424b9ae51cb" translate="yes" xml:space="preserve">
          <source>The first &lt;var&gt;number&lt;/var&gt; arguments of the function are &lt;em&gt;distinguished&lt;/em&gt; arguments; the rest are considered the body of the expression. A line in the expression is indented according to whether the first argument on it is distinguished or not. If the argument is part of the body, the line is indented &lt;code&gt;lisp-body-indent&lt;/code&gt; more columns than the open-parenthesis starting the containing expression. If the argument is distinguished and is either the first or second argument, it is indented &lt;em&gt;twice&lt;/em&gt; that many extra columns. If the argument is distinguished and not the first or second argument, the line uses the standard pattern.</source>
          <target state="translated">함수 의 첫 번째 &lt;var&gt;number&lt;/var&gt; 인수는 &lt;em&gt;구별되는&lt;/em&gt; 인수입니다. 나머지는 표현의 본문으로 간주됩니다. 표현식의 행은 첫 번째 인수가 구별되는지 여부에 따라 들여 쓰기됩니다. 인수가 본문의 일부인 경우 라인은 포함하는 표현식을 시작하는 여는 괄호보다 더 많은 열을 &lt;code&gt;lisp-body-indent&lt;/code&gt; 씁니다. lisp-body-indent . 인수가 구별되고 첫 번째 또는 두 번째 인수 인 경우 추가 열 수의 &lt;em&gt;두 배로&lt;/em&gt; 들여 쓰기 &lt;em&gt;됩니다&lt;/em&gt; . 인수가 구별되고 첫 번째 또는 두 번째 인수가 아닌 경우 행은 표준 패턴을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b6792de20ff613a589b600323a8f2769f8d4328f" translate="yes" xml:space="preserve">
          <source>The first argument given to &lt;var&gt;handler&lt;/var&gt; is the name of the primitive, as a symbol; the remaining arguments are the arguments that were passed to that primitive. (The first of these arguments is most often the file name itself.) For example, if you do this:</source>
          <target state="translated">&lt;var&gt;handler&lt;/var&gt; 주어진 첫 번째 인수 는 기호로서 기본 요소의 이름입니다. 나머지 인수는 해당 프리미티브에 전달 된 인수입니다. (이러한 인수 중 첫 번째는 대부분 파일 이름 자체입니다.) 예를 들어 다음과 같이하면됩니다.</target>
        </trans-unit>
        <trans-unit id="722b8b8e4de0471d30abd9c4cc7537deb8572c61" translate="yes" xml:space="preserve">
          <source>The first argument that Lisp hands to the function indicates why it was called. The convention for arguments is detailed in the description of &lt;code&gt;debug&lt;/code&gt; (see &lt;a href=&quot;invoking-the-debugger#Invoking-the-Debugger&quot;&gt;Invoking the Debugger&lt;/a&gt;).</source>
          <target state="translated">Lisp가 함수에 전달하는 첫 번째 인수는 함수가 호출 된 이유를 나타냅니다. 인수에 대한 규칙은 &lt;code&gt;debug&lt;/code&gt; 설명에 자세히 설명되어 있습니다 ( &lt;a href=&quot;invoking-the-debugger#Invoking-the-Debugger&quot;&gt;디버거 호출&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="2066145dc073e9f1dd57632ef58fcd8ec240493d" translate="yes" xml:space="preserve">
          <source>The first case indicates the basic indentation increment to use. If &lt;code&gt;sample-indent-basic&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;, then SMIE uses the global setting &lt;code&gt;smie-indent-basic&lt;/code&gt;. The major mode could have set &lt;code&gt;smie-indent-basic&lt;/code&gt; buffer-locally instead, but that is discouraged.</source>
          <target state="translated">첫 번째 경우는 사용할 기본 들여 쓰기 증분을 나타냅니다. 경우 &lt;code&gt;sample-indent-basic&lt;/code&gt; 이다 &lt;code&gt;nil&lt;/code&gt; , 다음 SMIE 글로벌 설정이 사용 &lt;code&gt;smie-indent-basic&lt;/code&gt; . 메이저 모드는 대신 &lt;code&gt;smie-indent-basic&lt;/code&gt; 버퍼를 로컬로 설정할 수 있지만 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9276082e8b3010c24531b975ec50bcbea5a7818a" translate="yes" xml:space="preserve">
          <source>The first character in a syntax descriptor must be a syntax class designator character. The second character, if present, specifies a matching character (e.g., in Lisp, the matching character for &amp;lsquo;</source>
          <target state="translated">구문 설명 자의 첫 번째 문자는 구문 클래스 지정자 문자 여야합니다. 두 번째 문자 (있는 경우)는 일치하는 문자를 지정합니다 (예 : Lisp에서 '</target>
        </trans-unit>
        <trans-unit id="39c4836db6032a9af6b8895c19c4d302b908bde8" translate="yes" xml:space="preserve">
          <source>The first element of &lt;var&gt;menu&lt;/var&gt; must be a string, which serves as the menu label. It may be followed by any number of the following keyword-argument pairs:</source>
          <target state="translated">&lt;var&gt;menu&lt;/var&gt; 의 첫 번째 요소 는 메뉴 레이블 역할을하는 문자열이어야합니다. 그 뒤에는 다음과 같은 키워드-인수 쌍이 얼마든지 올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15d23f64cb15de341109c55ba69a978fb148aee5" translate="yes" xml:space="preserve">
          <source>The first element of a lambda expression is always the symbol &lt;code&gt;lambda&lt;/code&gt;. This indicates that the list represents a function. The reason functions are defined to start with &lt;code&gt;lambda&lt;/code&gt; is so that other lists, intended for other uses, will not accidentally be valid as functions.</source>
          <target state="translated">람다 식의 첫 번째 요소는 항상 기호 &lt;code&gt;lambda&lt;/code&gt; 입니다. 이것은 목록이 함수를 나타냄을 나타냅니다. 함수가 &lt;code&gt;lambda&lt;/code&gt; 로 시작하도록 정의 된 이유는 다른 용도로 의도 된 다른 목록이 실수로 함수로 유효하지 않도록하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="68cf8f4ab59e90caee8f7fcdd176030805c02094" translate="yes" xml:space="preserve">
          <source>The first element of an array has index zero, the second element has index 1, and so on. This is called &lt;em&gt;zero-origin&lt;/em&gt; indexing. For example, an array of four elements has indices 0, 1, 2, and 3.</source>
          <target state="translated">배열의 첫 번째 요소에는 인덱스 0이 있고 두 번째 요소에는 인덱스 1이있는 식입니다. 이를 &lt;em&gt;제로 출처&lt;/em&gt; 인덱싱 이라고 합니다. 예를 들어, 4 개 요소의 배열에는 인덱스 0, 1, 2, 3이 있습니다.</target>
        </trans-unit>
        <trans-unit id="51f338b4e98aac416f168cd0115601f42b7a93f5" translate="yes" xml:space="preserve">
          <source>The first element of an array has index zero, the second element has index 1, and so on. This is called &lt;em&gt;zero-origin&lt;/em&gt; indexing. For example, an array of four elements has indices 0, 1, 2, and 3. The largest possible index value is one less than the length of the array. Once an array is created, its length is fixed.</source>
          <target state="translated">배열의 첫 번째 요소에는 인덱스 0이 있고 두 번째 요소에는 인덱스 1이있는 식입니다. 이를 &lt;em&gt;제로 출처&lt;/em&gt; 인덱싱 이라고 합니다. 예를 들어, 4 개 요소의 배열에는 인덱스 0, 1, 2 및 3이 있습니다. 가능한 가장 큰 인덱스 값은 배열 길이보다 1이 적습니다. 배열이 생성되면 길이가 고정됩니다.</target>
        </trans-unit>
        <trans-unit id="2524e323ad39aadf65e6819494415de49cf36cc1" translate="yes" xml:space="preserve">
          <source>The first element of the &lt;code&gt;quit-restore&lt;/code&gt; parameter is one of the symbols &lt;code&gt;window&lt;/code&gt;, meaning that the window has been specially created by &lt;code&gt;display-buffer&lt;/code&gt;; &lt;code&gt;frame&lt;/code&gt;, a separate frame has been created; &lt;code&gt;same&lt;/code&gt;, the window has only ever displayed this buffer; or &lt;code&gt;other&lt;/code&gt;, the window showed another buffer before. &lt;code&gt;frame&lt;/code&gt; and &lt;code&gt;window&lt;/code&gt; affect how the window is quit, while &lt;code&gt;same&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; affect the redisplay of buffers previously shown in &lt;var&gt;window&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;quit-restore&lt;/code&gt; 매개 변수 의 첫 번째 요소는 기호 &lt;code&gt;window&lt;/code&gt; 중 하나입니다. 이는 창이 특별히 &lt;code&gt;display-buffer&lt;/code&gt; 에 의해 생성되었음을 의미합니다 . &lt;code&gt;frame&lt;/code&gt; , 별도의 프레임이 생성되었습니다. &lt;code&gt;same&lt;/code&gt; , 창은이 버퍼 만 표시했습니다. 또는 &lt;code&gt;other&lt;/code&gt; , 창에 이전에 다른 버퍼가 표시되었습니다. &lt;code&gt;frame&lt;/code&gt; 과 &lt;code&gt;window&lt;/code&gt; 는 window가 종료되는 방식에 영향을 미치고, &lt;code&gt;same&lt;/code&gt; 과 &lt;code&gt;other&lt;/code&gt; 는 이전에 &lt;var&gt;window&lt;/var&gt; 에 표시된 버퍼의 재 표시에 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="c3f41cf4ec0e02e4a679662ba14fa7fdfffa94fd" translate="yes" xml:space="preserve">
          <source>The first element, &lt;var&gt;decoding-system&lt;/var&gt;, is the coding system to use for decoding (in case &lt;var&gt;operation&lt;/var&gt; does decoding), and &lt;var&gt;encoding-system&lt;/var&gt; is the coding system for encoding (in case &lt;var&gt;operation&lt;/var&gt; does encoding).</source>
          <target state="translated">첫 번째 요소 인 &lt;var&gt;decoding-system&lt;/var&gt; 은 디코딩에 사용할 코딩 시스템 ( &lt;var&gt;operation&lt;/var&gt; 이 디코딩을 수행 하는 경우 )이고 &lt;var&gt;encoding-system&lt;/var&gt; 은 인코딩을위한 코딩 시스템 ( &lt;var&gt;operation&lt;/var&gt; 이 인코딩을 수행하는 경우 )입니다.</target>
        </trans-unit>
        <trans-unit id="2cd75fb3bb07dce6a2ca619dd218795e581be875" translate="yes" xml:space="preserve">
          <source>The first element, &lt;var&gt;keywords&lt;/var&gt;, indirectly specifies the value of &lt;code&gt;font-lock-keywords&lt;/code&gt; which directs search-based fontification. It can be a symbol, a variable or a function whose value is the list to use for &lt;code&gt;font-lock-keywords&lt;/code&gt;. It can also be a list of several such symbols, one for each possible level of fontification. The first symbol specifies the &amp;lsquo;</source>
          <target state="translated">첫 번째 요소 인 &lt;var&gt;keywords&lt;/var&gt; 는 검색 기반 &lt;code&gt;font-lock-keywords&lt;/code&gt; 를 지시하는 font-lock-keywords 값을 간접적으로 지정합니다 . &lt;code&gt;font-lock-keywords&lt;/code&gt; 에 사용할 값이 목록 인 기호, 변수 또는 함수일 수 있습니다. 또한 가능한 글꼴 수준별로 하나씩 이러한 기호의 목록이 될 수도 있습니다. 첫 번째 기호는 '</target>
        </trans-unit>
        <trans-unit id="075cb4d42e18fef81945510253ddc7517a2a9450" translate="yes" xml:space="preserve">
          <source>The first five elements correspond to face attributes; if you specify these attributes for a face, it will use this font.</source>
          <target state="translated">처음 5 개 요소는 얼굴 속성에 해당합니다. 얼굴에 이러한 속성을 지정하면이 글꼴이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="518177047b013c7ced390688d084d6c94e497b17" translate="yes" xml:space="preserve">
          <source>The first function in &lt;code&gt;completion-at-point-functions&lt;/code&gt; to return a non-&lt;code&gt;nil&lt;/code&gt; value is used by &lt;code&gt;completion-at-point&lt;/code&gt;. The remaining functions are not called. The exception to this is when there is an &lt;code&gt;:exclusive&lt;/code&gt; specification, as described above.</source>
          <target state="translated">첫 번째 기능 &lt;code&gt;completion-at-point-functions&lt;/code&gt; 비 반환 &lt;code&gt;nil&lt;/code&gt; 값으로 사용 &lt;code&gt;completion-at-point&lt;/code&gt; . 나머지 함수는 호출되지 않습니다. 이에 대한 예외 는 위에서 설명한대로 &lt;code&gt;:exclusive&lt;/code&gt; 사양 이있는 경우입니다 .</target>
        </trans-unit>
        <trans-unit id="61a427cbbd5fa9f87fd4ca66049624d276b3097d" translate="yes" xml:space="preserve">
          <source>The first hook function is passed a &lt;var&gt;fun&lt;/var&gt; that is equivalent to the default operation of &lt;code&gt;filter-buffer-substring&lt;/code&gt;, i.e., it returns the buffer-substring between &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt; (processed by any &lt;code&gt;buffer-substring-filters&lt;/code&gt;) and optionally deletes the original text from the buffer. In most cases, the hook function will call &lt;var&gt;fun&lt;/var&gt; once, and then do its own processing of the result. The next hook function receives a &lt;var&gt;fun&lt;/var&gt; equivalent to this, and so on. The actual return value is the result of all the hook functions acting in sequence.</source>
          <target state="translated">첫 번째 후크 함수 에는 &lt;code&gt;filter-buffer-substring&lt;/code&gt; 의 기본 작업과 동일한 &lt;var&gt;fun&lt;/var&gt; 이 전달됩니다. 즉, &lt;var&gt;start&lt;/var&gt; 과 &lt;var&gt;end&lt;/var&gt; 사이에 버퍼 하위 문자열을 반환하고 ( &lt;code&gt;buffer-substring-filters&lt;/code&gt; 로 처리됨 ) 선택적으로 원본 텍스트를 삭제합니다. 버퍼에서. 대부분의 경우 후크 함수는 &lt;var&gt;fun&lt;/var&gt; 을 한 번 호출 한 다음 자체적으로 결과를 처리합니다. 다음 후크 함수는 이것과 동등한 &lt;var&gt;fun&lt;/var&gt; 받습니다 . 실제 반환 값은 순서대로 작동하는 모든 후크 함수의 결과입니다.</target>
        </trans-unit>
        <trans-unit id="b857f369cef6dd27f6c9832f3de8944a6080d980" translate="yes" xml:space="preserve">
          <source>The first line of the documentation string should stand on its own, because &lt;code&gt;apropos&lt;/code&gt; displays just this first line. It should consist of one or two complete sentences that summarize the function&amp;rsquo;s purpose.</source>
          <target state="translated">&lt;code&gt;apropos&lt;/code&gt; 는이 첫 번째 줄만 표시 하므로 문서 문자열의 첫 번째 줄은 자체적으로 표시 되어야 합니다. 함수의 목적을 요약하는 하나 또는 두 개의 완전한 문장으로 구성되어야합니다.</target>
        </trans-unit>
        <trans-unit id="95c5ac45f74b85b86e155db5e7a41993f23c1a44" translate="yes" xml:space="preserve">
          <source>The first method, renaming, is the default.</source>
          <target state="translated">첫 번째 방법 인 이름 바꾸기가 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="d5a94c95ffdfdde685e909b15241ffe89d36a213" translate="yes" xml:space="preserve">
          <source>The first of these hooks is run after a &lt;em&gt;window buffer change&lt;/em&gt; is detected, which means that a window was created, deleted or assigned another buffer.</source>
          <target state="translated">이러한 후크 중 첫 번째는 &lt;em&gt;창 버퍼 변경&lt;/em&gt; 이 감지 된 후 실행 되며 이는 창이 생성, 삭제 또는 다른 버퍼에 할당되었음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="5a2945984c3f8a17a8400ccf64f981fcb2eabf09" translate="yes" xml:space="preserve">
          <source>The first one is for locally installed files for a specific Emacs version; the second is for locally installed files meant for use with all installed Emacs versions. (If Emacs is running uninstalled, it also adds</source>
          <target state="translated">첫 번째는 특정 Emacs 버전에 대해 로컬로 설치된 파일 용입니다. 두 번째는 설치된 모든 Emacs 버전과 함께 사용하기 위해 로컬로 설치된 파일을위한 것입니다. (Emacs가 설치되지 않은 상태에서 실행 중이면</target>
        </trans-unit>
        <trans-unit id="6d1221fe22767b7dddd5d1d969f3a50a7d8c7c01" translate="yes" xml:space="preserve">
          <source>The first or next non-keyboard event in the key sequence that invoked the command. More precisely, &amp;lsquo;</source>
          <target state="translated">명령을 호출 한 키 시퀀스의 첫 번째 또는 다음 비 키보드 이벤트입니다. 더 정확하게, '</target>
        </trans-unit>
        <trans-unit id="d02389cbd7c0e8fe951f0c6a0fa8a070ab93cecb" translate="yes" xml:space="preserve">
          <source>The first part of the pattern is a character alternative that matches any one of three characters: period, question mark, and exclamation mark. The match must begin with one of these three characters. (This is one point where the new default regexp used by Emacs differs from the old. The new value also allows some non-</source>
          <target state="translated">패턴의 첫 번째 부분은 마침표, 물음표 및 느낌표의 세 문자 중 하나와 일치하는 대체 문자입니다. 일치는이 세 문자 중 하나로 시작해야합니다. (이것은 Emacs에서 사용하는 새로운 기본 정규식이 이전과 다른 점입니다. 새로운 값은 또한 일부 비</target>
        </trans-unit>
        <trans-unit id="2f07493bfdc49d4184b04abbeaf59e9651306278" translate="yes" xml:space="preserve">
          <source>The first part of the string, &lt;var&gt;fontpattern&lt;/var&gt;, should have the form of a standard X font name, except that the last two fields should be &amp;lsquo;</source>
          <target state="translated">문자열의 첫 부분 인 &lt;var&gt;fontpattern&lt;/var&gt; 은 표준 X 글꼴 이름 형식이어야합니다. 단, 마지막 두 필드는 '</target>
        </trans-unit>
        <trans-unit id="921dc58080d888df09bdaec42ab40231a692a25c" translate="yes" xml:space="preserve">
          <source>The first step in evaluating a function call is to evaluate the remaining elements of the list from left to right. The results are the actual argument values, one value for each list element. The next step is to call the function with this list of arguments, effectively using the function &lt;code&gt;apply&lt;/code&gt; (see &lt;a href=&quot;calling-functions#Calling-Functions&quot;&gt;Calling Functions&lt;/a&gt;). If the function is written in Lisp, the arguments are used to bind the argument variables of the function (see &lt;a href=&quot;lambda-expressions#Lambda-Expressions&quot;&gt;Lambda Expressions&lt;/a&gt;); then the forms in the function body are evaluated in order, and the value of the last body form becomes the value of the function call.</source>
          <target state="translated">함수 호출을 평가하는 첫 번째 단계는 목록의 나머지 요소를 왼쪽에서 오른쪽으로 평가하는 것입니다. 결과는 각 목록 요소에 대해 하나의 값인 실제 인수 값입니다. 다음 단계는 &lt;code&gt;apply&lt;/code&gt; 함수를 사용하여이 인수 목록으로 함수를 호출하는 것입니다 ( 함수 &lt;a href=&quot;calling-functions#Calling-Functions&quot;&gt;호출&lt;/a&gt; 참조 ). 함수가 Lisp로 작성된 경우 인수는 함수의 인수 변수를 바인딩하는 데 사용됩니다 ( &lt;a href=&quot;lambda-expressions#Lambda-Expressions&quot;&gt;Lambda 표현식&lt;/a&gt; 참조 ). 그러면 함수 본문의 형식이 순서대로 평가되고 마지막 본문 형식의 값이 함수 호출의 값이됩니다.</target>
        </trans-unit>
        <trans-unit id="3df285467f12c1e287f61e00067a2ae879440ffa" translate="yes" xml:space="preserve">
          <source>The first step in evaluating a nonempty list is to examine its first element. This element alone determines what kind of form the list is and how the rest of the list is to be processed. The first element is &lt;em&gt;not&lt;/em&gt; evaluated, as it would be in some Lisp dialects such as Scheme.</source>
          <target state="translated">비어 있지 않은 목록을 평가하는 첫 번째 단계는 첫 번째 요소를 검사하는 것입니다. 이 요소만으로도 목록의 형식과 나머지 목록을 처리하는 방법을 결정합니다. 첫 번째 요소는 Scheme과 같은 일부 Lisp 방언 에서처럼 평가 &lt;em&gt;되지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="0b91477185c354f0cf6d4f79757bec67efe4ed2f" translate="yes" xml:space="preserve">
          <source>The first step is to find the defun that is unbalanced. If there is an excess open parenthesis, the way to do this is to go to the end of the file and type</source>
          <target state="translated">첫 번째 단계는 균형이 맞지 않는 defun을 찾는 것입니다. 여는 괄호가 너무 많으면 파일 끝으로 이동하여 다음을 입력합니다.</target>
        </trans-unit>
        <trans-unit id="3e8495b282fa0cf8be0d80ff66ce938f120af166" translate="yes" xml:space="preserve">
          <source>The first thing the command loop must do is read a key sequence, which is a sequence of input events that translates into a command. It does this by calling the function &lt;code&gt;read-key-sequence&lt;/code&gt;. Lisp programs can also call this function (see &lt;a href=&quot;key-sequence-input#Key-Sequence-Input&quot;&gt;Key Sequence Input&lt;/a&gt;). They can also read input at a lower level with &lt;code&gt;read-key&lt;/code&gt; or &lt;code&gt;read-event&lt;/code&gt; (see &lt;a href=&quot;reading-one-event#Reading-One-Event&quot;&gt;Reading One Event&lt;/a&gt;), or discard pending input with &lt;code&gt;discard-input&lt;/code&gt; (see &lt;a href=&quot;event-input-misc#Event-Input-Misc&quot;&gt;Event Input Misc&lt;/a&gt;).</source>
          <target state="translated">명령 루프가 가장 먼저 수행해야하는 일은 명령으로 변환되는 입력 이벤트 시퀀스 인 키 시퀀스를 읽는 것입니다. &lt;code&gt;read-key-sequence&lt;/code&gt; 함수를 호출하여이를 수행 합니다 . Lisp 프로그램은이 함수를 호출 할 수도 있습니다 ( &lt;a href=&quot;key-sequence-input#Key-Sequence-Input&quot;&gt;키 시퀀스 입력&lt;/a&gt; 참조 ). 또한 읽기 &lt;code&gt;read-key&lt;/code&gt; 또는 &lt;code&gt;read-event&lt;/code&gt; 를 사용하여 하위 수준에서 입력을 읽 거나 ( &lt;a href=&quot;reading-one-event#Reading-One-Event&quot;&gt;하나의 이벤트 읽기&lt;/a&gt; 참조 ) 폐기 입력을 사용하여 보류중인 입력을 &lt;code&gt;discard-input&lt;/code&gt; ( &lt;a href=&quot;event-input-misc#Event-Input-Misc&quot;&gt;이벤트 입력 기타&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="9819ecc730c443ef66825eba6fa46be5ddfd672f" translate="yes" xml:space="preserve">
          <source>The first thing this function does is to activate a minibuffer and display it with &lt;var&gt;prompt&lt;/var&gt; (which must be a string) as the prompt. Then the user can edit text in the minibuffer.</source>
          <target state="translated">이 함수가 가장 먼저하는 일은 미니 버퍼를 활성화하고 &lt;var&gt;prompt&lt;/var&gt; (문자열이어야 함)를 프롬프트로 표시하는 것입니다. 그런 다음 사용자는 미니 버퍼에서 텍스트를 편집 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffe911fc31e45fe7a69d03c024357531769f0422" translate="yes" xml:space="preserve">
          <source>The first three clauses use backquote-style patterns. &lt;code&gt;`(add ,x ,y)&lt;/code&gt; is a pattern that checks that &lt;code&gt;form&lt;/code&gt; is a three-element list starting with the literal symbol &lt;code&gt;add&lt;/code&gt;, then extracts the second and third elements and binds them to symbols &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, respectively. The clause body evaluates &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; and adds the results. Similarly, the &lt;code&gt;call&lt;/code&gt; clause implements a function call, and the &lt;code&gt;fn&lt;/code&gt; clause implements an anonymous function definition.</source>
          <target state="translated">처음 세 절은 역 따옴표 스타일 패턴을 사용합니다. &lt;code&gt;`(add ,x ,y)&lt;/code&gt; 는 &lt;code&gt;form&lt;/code&gt; 이 리터럴 기호 &lt;code&gt;add&lt;/code&gt; 로 시작하는 3 요소 목록인지 확인한 다음 두 번째 및 세 번째 요소를 추출하여 각각 기호 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 에 바인딩하는 패턴 입니다. 절 본문은 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 를 평가 하고 결과를 추가합니다. 마찬가지로 &lt;code&gt;call&lt;/code&gt; 절은 함수 호출을 구현 하고 &lt;code&gt;fn&lt;/code&gt; 절은 익명 함수 정의를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="73abbe89ddba4324d8c8e47f4552f5d79ddd1773" translate="yes" xml:space="preserve">
          <source>The first three sections below should tell you enough about Edebug to start using it.</source>
          <target state="translated">아래의 처음 세 섹션은 Edebug 사용을 시작하기에 충분한 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f8cf2175ce1df58161db09af76ff0593cb8a1848" translate="yes" xml:space="preserve">
          <source>The first two arguments, &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt;, are the beginning and end of the region to be filled. The third and fourth arguments, &lt;var&gt;justify&lt;/var&gt; and &lt;var&gt;citation-regexp&lt;/var&gt;, are optional. If &lt;var&gt;justify&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the paragraphs are justified as well as filled. If &lt;var&gt;citation-regexp&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it means the function is operating on a mail message and therefore should not fill the header lines. If &lt;var&gt;citation-regexp&lt;/var&gt; is a string, it is used as a regular expression; if it matches the beginning of a line, that line is treated as a citation marker.</source>
          <target state="translated">처음 두 인수 인 &lt;var&gt;start&lt;/var&gt; 및 &lt;var&gt;end&lt;/var&gt; 는 채울 영역의 시작과 끝입니다. 세 번째 및 네 번째 인수 인 &lt;var&gt;justify&lt;/var&gt; 및 &lt;var&gt;citation-regexp&lt;/var&gt; 는 선택 사항입니다. 경우 &lt;var&gt;justify&lt;/var&gt; 비입니다 &lt;code&gt;nil&lt;/code&gt; , 단락은 물론 충전으로 정당화된다. 경우 &lt;var&gt;citation-regexp&lt;/var&gt; 비이다 &lt;code&gt;nil&lt;/code&gt; ,이 기능은 헤더 라인을 채우기 안 따라서 이메일 메시지상에서 동작하고 말한다. 경우 &lt;var&gt;citation-regexp&lt;/var&gt; 문자열이다, 그것은 정규 표현식으로 사용된다; 줄의 시작 부분과 일치하면 해당 줄이 인용 표시 자로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="ba54bb325792850fbc12f938d5d5d0fe16184dae" translate="yes" xml:space="preserve">
          <source>The first variant, explicit selective display, was designed for use in a Lisp program: it controls which lines are hidden by altering the text. This kind of hiding is now obsolete and deprecated; instead you should use the &lt;code&gt;invisible&lt;/code&gt; property (see &lt;a href=&quot;invisible-text#Invisible-Text&quot;&gt;Invisible Text&lt;/a&gt;) to get the same effect.</source>
          <target state="translated">첫 번째 변형 인 명시 적 선택 표시는 Lisp 프로그램에서 사용하도록 설계되었습니다. 텍스트를 변경하여 숨길 줄을 제어합니다. 이런 종류의 숨기기는 이제 쓸모없고 더 이상 사용되지 않습니다. 대신 동일한 효과를 얻으려면 &lt;code&gt;invisible&lt;/code&gt; 속성 ( &lt;a href=&quot;invisible-text#Invisible-Text&quot;&gt;Invisible Text&lt;/a&gt; 참조 )을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ae5b4e16891d5734b38e80c0203fdd0afd0ce6e9" translate="yes" xml:space="preserve">
          <source>The flag &amp;lsquo;</source>
          <target state="translated">깃발 '</target>
        </trans-unit>
        <trans-unit id="1e9d7078efa70faad8e62d7dac2b994d083d12ef" translate="yes" xml:space="preserve">
          <source>The flag &lt;var&gt;current-group&lt;/var&gt; has no effect when a pipe is used to communicate with the subprocess, because the operating system does not support the distinction in the case of pipes. For the same reason, job-control shells won&amp;rsquo;t work when a pipe is used. See &lt;code&gt;process-connection-type&lt;/code&gt; in &lt;a href=&quot;asynchronous-processes#Asynchronous-Processes&quot;&gt;Asynchronous Processes&lt;/a&gt;.</source>
          <target state="translated">&lt;var&gt;current-group&lt;/var&gt; 플래그 는 파이프가 하위 프로세스와 통신하는 데 사용되는 경우에는 영향을주지 않습니다. 운영 체제가 파이프의 경우 구분을 지원하지 않기 때문입니다. 같은 이유로 작업 제어 셸은 파이프를 사용할 때 작동하지 않습니다. &lt;a href=&quot;asynchronous-processes#Asynchronous-Processes&quot;&gt;비동기 프로세스의 프로세스 &lt;/a&gt; &lt;code&gt;process-connection-type&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ec2c9b05e5630a06e86a36a4fbe950b6561191c6" translate="yes" xml:space="preserve">
          <source>The following</source>
          <target state="translated">다음과 같은</target>
        </trans-unit>
        <trans-unit id="c8513321fed0f5129f9fbc478e3010a771a4d3ef" translate="yes" xml:space="preserve">
          <source>The following C data structures are defined in</source>
          <target state="translated">다음 C 데이터 구조는</target>
        </trans-unit>
        <trans-unit id="5389465bbc2f69e77a3b2484a1984ff2230a7971" translate="yes" xml:space="preserve">
          <source>The following Lisp forms are the forms in Emacs that will work as generalized variables, and so may appear in the &lt;var&gt;place&lt;/var&gt; argument of &lt;code&gt;setf&lt;/code&gt;:</source>
          <target state="translated">다음 Lisp 형식은 일반화 된 변수로 작동하는 Emacs의 형식이므로 &lt;code&gt;setf&lt;/code&gt; 의 &lt;var&gt;place&lt;/var&gt; 인수에 나타날 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="30e3d2decfa7f509aa3c0da9bce3711eec8451b2" translate="yes" xml:space="preserve">
          <source>The following action function for &lt;code&gt;display-buffer&lt;/code&gt; (see &lt;a href=&quot;buffer-display-action-functions#Buffer-Display-Action-Functions&quot;&gt;Buffer Display Action Functions&lt;/a&gt;) creates or reuses a side window for displaying the specified buffer.</source>
          <target state="translated">&lt;code&gt;display-buffer&lt;/code&gt; 대한 다음 작업 함수 ( &lt;a href=&quot;buffer-display-action-functions#Buffer-Display-Action-Functions&quot;&gt;버퍼 디스플레이 작업 함수&lt;/a&gt; 참조 )는 지정된 버퍼를 표시하기위한 사이드 윈도우를 생성하거나 재사용합니다.</target>
        </trans-unit>
        <trans-unit id="dfbcb2a836ed9e2ea7b4444cdff4b5302dc8b282" translate="yes" xml:space="preserve">
          <source>The following are functions for altering the</source>
          <target state="translated">다음은 변경 기능입니다.</target>
        </trans-unit>
        <trans-unit id="4d77a5b5f720da9def084ee3c59bb116b800938f" translate="yes" xml:space="preserve">
          <source>The following are functions for searching for elements in the</source>
          <target state="translated">다음은 요소를 검색하는 기능입니다.</target>
        </trans-unit>
        <trans-unit id="1dfb54b3aba09435f9c449c921d9fd5796ec1366" translate="yes" xml:space="preserve">
          <source>The following aspects of ranges are specific to Emacs, in that POSIX allows but does not require this behavior and programs other than Emacs may behave differently:</source>
          <target state="translated">범위의 다음 측면은 POSIX가이 동작을 허용하지만 요구하지 않으며 Emacs 이외의 프로그램이 다르게 동작 할 수 있다는 점에서 Emacs에 고유합니다.</target>
        </trans-unit>
        <trans-unit id="05135351c4db9bc9b01c91cca9c14d0e6246c79f" translate="yes" xml:space="preserve">
          <source>The following basic action functions are defined in Emacs.</source>
          <target state="translated">Emacs에는 다음과 같은 기본 액션 함수가 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd8640559e0a3145f35e39076da3835c9d10c816" translate="yes" xml:space="preserve">
          <source>The following buffer-local variables control the position and width of fringes in windows showing that buffer.</source>
          <target state="translated">다음 버퍼 로컬 변수는 해당 버퍼를 표시하는 창에서 가장자리의 위치와 너비를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="00cbfbb2bbd87d9035fce6f335cba5b08cdc1cad" translate="yes" xml:space="preserve">
          <source>The following caveats should be considered when adding a function to window change functions:</source>
          <target state="translated">창 변경 기능에 기능을 추가 할 때 다음 사항을 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="fce85ab64d52f9ad9fc3dd20003408e7fd70e516" translate="yes" xml:space="preserve">
          <source>The following code snippet, when applied to a single-window frame, first splits the selected window and makes the selected and the new window constituents of an atomic window with their parent as root. It then displays the buffer</source>
          <target state="translated">다음 코드 스 니펫은 단일 창 프레임에 적용될 때 먼저 선택한 창을 분할하고 선택한 창과 새 창을 부모가 루트 인 원자 창의 구성 요소로 만듭니다. 그런 다음 버퍼를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="e841b3081cb8d309a73a3b7e4ec19b8e893a44c5" translate="yes" xml:space="preserve">
          <source>The following command is handy to toggle the appearance of all side windows on a specified frame.</source>
          <target state="translated">다음 명령은 지정된 프레임에서 모든 측면 창의 모양을 전환하는 데 편리합니다.</target>
        </trans-unit>
        <trans-unit id="57fb79cd5a56bc93119b550457684621fd2045d9" translate="yes" xml:space="preserve">
          <source>The following command uses information on how the window for displaying the buffer was obtained in the first place, thus attempting to automate the above decisions for you.</source>
          <target state="translated">다음 명령은 처음에 버퍼를 표시하기위한 창을 얻은 방법에 대한 정보를 사용하여 위의 결정을 자동화하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="f73e0bc0f4740059294b61a0f93df3282d2be9cb" translate="yes" xml:space="preserve">
          <source>The following command-line options affect some aspects of the startup sequence. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Initial-Options.html#Initial-Options&quot;&gt;Initial Options&lt;/a&gt; in</source>
          <target state="translated">다음 명령 줄 옵션은 시작 순서의 일부 측면에 영향을줍니다. &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Initial-Options.html#Initial-Options&quot;&gt;초기 옵션&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="52e933df89f8a6d2d6eb75a953cd492fb460f70a" translate="yes" xml:space="preserve">
          <source>The following commands and functions mostly provide compatibility with old versions of Emacs. They work by calling &lt;code&gt;set-face-attribute&lt;/code&gt;. Values of &lt;code&gt;t&lt;/code&gt; and &lt;code&gt;nil&lt;/code&gt; (or omitted) for their &lt;var&gt;frame&lt;/var&gt; argument are handled just like &lt;code&gt;set-face-attribute&lt;/code&gt; and &lt;code&gt;face-attribute&lt;/code&gt;. The commands read their arguments using the minibuffer, if called interactively.</source>
          <target state="translated">다음 명령과 함수는 대부분 이전 버전의 Emacs와의 호환성을 제공합니다. &lt;code&gt;set-face-attribute&lt;/code&gt; 를 호출하여 작동 합니다 . &lt;var&gt;frame&lt;/var&gt; 인수에 대한 &lt;code&gt;t&lt;/code&gt; 및 &lt;code&gt;nil&lt;/code&gt; 값 (또는 생략 됨)은 &lt;code&gt;set-face-attribute&lt;/code&gt; 및 &lt;code&gt;face-attribute&lt;/code&gt; 처럼 처리 됩니다. 명령은 대화식으로 호출되는 경우 미니 버퍼를 사용하여 인수를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="37349965f15dc9da05dfef5324363eb60ce661c7" translate="yes" xml:space="preserve">
          <source>The following commands can be used to cycle through the global buffer list, much like &lt;code&gt;bury-buffer&lt;/code&gt; and &lt;code&gt;unbury-buffer&lt;/code&gt;. However, they cycle according to the specified window&amp;rsquo;s history list, rather than the global buffer list. In addition, they restore window-specific window start and point positions, and may show a buffer even if it is already shown in another window. The &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; command, in particular, is used by &lt;code&gt;replace-buffer-in-windows&lt;/code&gt;, &lt;code&gt;bury-buffer&lt;/code&gt; and &lt;code&gt;quit-window&lt;/code&gt; to find a replacement buffer for a window.</source>
          <target state="translated">다음 명령은 &lt;code&gt;bury-buffer&lt;/code&gt; 및 &lt;code&gt;unbury-buffer&lt;/code&gt; 와 같이 전역 버퍼 목록을 순환하는 데 사용할 수 있습니다 . 그러나 전역 버퍼 목록이 아닌 지정된 창의 내역 목록에 따라 순환합니다. 또한 창별 창 시작 및 지점 위치를 복원하고 이미 다른 창에 표시되어 있어도 버퍼를 표시 할 수 있습니다. 특히 &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; 명령은 &lt;code&gt;replace-buffer-in-windows&lt;/code&gt; , &lt;code&gt;bury-buffer&lt;/code&gt; 및 &lt;code&gt;quit-window&lt;/code&gt; 에서 창 에 대한 대체 버퍼를 찾는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4cfae661f65e37ca3c8203dfeb12091ccfd13ecb" translate="yes" xml:space="preserve">
          <source>The following commands exist to set up prefix arguments for the following command. Do not call them for any other reason.</source>
          <target state="translated">다음 명령에 대한 접두사 인수를 설정하기 위해 다음 명령이 존재합니다. 다른 이유로 전화하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="aa7ca6b67a7690e608cf5f0b3d4b7e967062b1ce" translate="yes" xml:space="preserve">
          <source>The following commands resize windows in more specific ways. When called interactively, they act on the selected window.</source>
          <target state="translated">다음 명령은보다 구체적인 방법으로 창 크기를 조정합니다. 대화식으로 호출하면 선택한 창에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="570dc96146735c82ffd1bfbddf49607518fc0e37" translate="yes" xml:space="preserve">
          <source>The following completion functions have nothing in themselves to do with minibuffers. We describe them here to keep them near the higher-level completion features that do use the minibuffer.</source>
          <target state="translated">다음 완료 함수는 그 자체로 미니 버퍼와 관련이 없습니다. 여기에서는 미니 버퍼를 사용하는 더 높은 수준의 완성 기능에 가깝게 유지하기 위해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="0211a8b24b8be85ca2c0dab5dd381bc0a3351017" translate="yes" xml:space="preserve">
          <source>The following convenience function should be used by major mode&amp;rsquo;s indentation engine in support of invocations as sub-modes of another major mode.</source>
          <target state="translated">다음 편의 기능은 다른 주요 모드의 하위 모드로 호출을 지원하기 위해 주요 모드의 들여 쓰기 엔진에서 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="dcdef829dc684ff37c33f2db214834e347de051b" translate="yes" xml:space="preserve">
          <source>The following diagram shows the relationship between these types:</source>
          <target state="translated">다음 다이어그램은 이러한 유형 간의 관계를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="263c6cdc21149473ee03d3c1db3fc6ad830a42fa" translate="yes" xml:space="preserve">
          <source>The following example demonstrates this. Given this (malformed) HTML document:</source>
          <target state="translated">다음 예제는이를 보여줍니다. 이 (잘못된 형식의) HTML 문서가 주어지면 :</target>
        </trans-unit>
        <trans-unit id="6e4d4fe31f9b5d0412811ce2d12a130a112c7a7c" translate="yes" xml:space="preserve">
          <source>The following example features a &lt;code&gt;pcase&lt;/code&gt; form with two clauses and two &lt;var&gt;seqpat&lt;/var&gt;, A and B. Both A and B first check that &lt;var&gt;expval&lt;/var&gt; is a pair (using &lt;code&gt;pred&lt;/code&gt;), and then bind symbols to the &lt;code&gt;car&lt;/code&gt; and &lt;code&gt;cdr&lt;/code&gt; of &lt;var&gt;expval&lt;/var&gt; (using one &lt;code&gt;app&lt;/code&gt; each).</source>
          <target state="translated">다음 예제는 두 개의 절과 두 개의 &lt;var&gt;seqpat&lt;/var&gt; , A 및 B가 있는 &lt;code&gt;pcase&lt;/code&gt; 양식을 특징으로합니다 . A와 B는 먼저 &lt;var&gt;expval&lt;/var&gt; 이 쌍인지 ( &lt;code&gt;pred&lt;/code&gt; 사용 ) 확인한 다음 기호를 &lt;var&gt;expval&lt;/var&gt; 의 &lt;code&gt;car&lt;/code&gt; 및 &lt;code&gt;cdr&lt;/code&gt; 에 바인딩합니다 ( 각각 하나의 &lt;code&gt;app&lt;/code&gt; 사용). ).</target>
        </trans-unit>
        <trans-unit id="cd027753313db3e2bda6d7bd77fd22b1e4340a82" translate="yes" xml:space="preserve">
          <source>The following example has four clauses, which test for the cases where the value of &lt;code&gt;x&lt;/code&gt; is a number, string, buffer and symbol, respectively:</source>
          <target state="translated">다음 예제에는 &lt;code&gt;x&lt;/code&gt; 값 이 각각 숫자, 문자열, 버퍼 및 기호 인 경우를 테스트하는 4 개의 절이 있습니다.</target>
        </trans-unit>
        <trans-unit id="327e6914ac3c21e45d4f2593af1fe07d9cc74645" translate="yes" xml:space="preserve">
          <source>The following example illustrates how window parameters (see &lt;a href=&quot;window-parameters#Window-Parameters&quot;&gt;Window Parameters&lt;/a&gt;) can be used with &lt;code&gt;display-buffer-in-side-window&lt;/code&gt; (see &lt;a href=&quot;displaying-buffers-in-side-windows#Displaying-Buffers-in-Side-Windows&quot;&gt;Displaying Buffers in Side Windows&lt;/a&gt;) to set up code for producing the frame layout sketched above.</source>
          <target state="translated">다음 예는 윈도우 파라미터 (참조 방법을 도시 한 &lt;a href=&quot;window-parameters#Window-Parameters&quot;&gt;윈도우 파라미터&lt;/a&gt; )를 사용할 수있는 &lt;code&gt;display-buffer-in-side-window&lt;/code&gt; (참조 &lt;a href=&quot;displaying-buffers-in-side-windows#Displaying-Buffers-in-Side-Windows&quot;&gt;사이드 윈도우의 버퍼 표시&lt;/a&gt; 프레임의 레이아웃은 상기 스케치의 제조 번호를 설정).</target>
        </trans-unit>
        <trans-unit id="dc386ed858292344d4ceae67e2b47d225cbdc5c4" translate="yes" xml:space="preserve">
          <source>The following example illustrates the symbol indirection process. We use &lt;code&gt;fset&lt;/code&gt; to set the function cell of a symbol and &lt;code&gt;symbol-function&lt;/code&gt; to get the function cell contents (see &lt;a href=&quot;function-cells#Function-Cells&quot;&gt;Function Cells&lt;/a&gt;). Specifically, we store the symbol &lt;code&gt;car&lt;/code&gt; into the function cell of &lt;code&gt;first&lt;/code&gt;, and the symbol &lt;code&gt;first&lt;/code&gt; into the function cell of &lt;code&gt;erste&lt;/code&gt;.</source>
          <target state="translated">다음 예제는 기호 간접 프로세스를 보여줍니다. 우리는 사용 &lt;code&gt;fset&lt;/code&gt; 상징하고의 기능 세포 설정하는 &lt;code&gt;symbol-function&lt;/code&gt; (참조 함수 셀 내용을 얻을 &lt;a href=&quot;function-cells#Function-Cells&quot;&gt;기능 셀&lt;/a&gt; ). 즉, 우리는 심볼 저장소 &lt;code&gt;car&lt;/code&gt; 의 함수로 셀 &lt;code&gt;first&lt;/code&gt; , 상기 심볼을 &lt;code&gt;first&lt;/code&gt; 의 함수로 셀 &lt;code&gt;erste&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50417c92f73fbb1570f2868b9a274b2b3768d629" translate="yes" xml:space="preserve">
          <source>The following example reads from the minibuffer. The prompt is: &amp;lsquo;</source>
          <target state="translated">다음 예제는 미니 버퍼에서 읽습니다. 프롬프트는 '</target>
        </trans-unit>
        <trans-unit id="332aeac42ef2f3fa049798dfb6a5f1315671df58" translate="yes" xml:space="preserve">
          <source>The following example shows how &lt;code&gt;doctor&lt;/code&gt; is prepared for autoloading with a magic comment:</source>
          <target state="translated">다음 예는 &lt;code&gt;doctor&lt;/code&gt; 가 매직 주석으로 자동 로딩을 준비 하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="e5c2aa47b7a24022abda108bb46b665cf282e882" translate="yes" xml:space="preserve">
          <source>The following example shows how to change the &lt;code&gt;make-backup-files&lt;/code&gt; variable only in the Rmail buffers and not elsewhere. Setting it &lt;code&gt;nil&lt;/code&gt; stops Emacs from making backups of these files, which may save disk space. (You would put this code in your init file.)</source>
          <target state="translated">다음 예제는 Rmail 버퍼에서만 &lt;code&gt;make-backup-files&lt;/code&gt; 변수 를 변경하는 방법을 보여줍니다 . &lt;code&gt;nil&lt;/code&gt; 로 설정하면 Emacs가 이러한 파일을 백업 하지 못하므로 디스크 공간을 절약 할 수 있습니다. (이 코드를 init 파일에 넣습니다.)</target>
        </trans-unit>
        <trans-unit id="a65479aec9ccbd5d9fca631c244266e471eff184" translate="yes" xml:space="preserve">
          <source>The following example shows how to implement this behavior (it is similar to the code generated by the &lt;code&gt;define-minor-mode&lt;/code&gt; macro):</source>
          <target state="translated">다음 예제는이 동작을 구현하는 방법을 보여줍니다 ( &lt;code&gt;define-minor-mode&lt;/code&gt; 매크로 에서 생성 된 코드와 유사 함 ).</target>
        </trans-unit>
        <trans-unit id="41826d1f446a51f4203f921570333293d6e9a365" translate="yes" xml:space="preserve">
          <source>The following example shows output to the echo area:</source>
          <target state="translated">다음 예제는 에코 영역에 대한 출력을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="ed8de281701b10f23d7cf126c2510f9e62a9fd5e" translate="yes" xml:space="preserve">
          <source>The following example uses the GNU Multiprecision Library (GMP) to calculate the next probable prime after a given integer. See &lt;a href=&quot;http://www.gmplib.org/manual/index.html#Top&quot;&gt;(gmp)Top&lt;/a&gt;, for a general overview of GMP, and see &lt;a href=&quot;http://www.gmplib.org/manual/Integer-Import-and-Export.html#Integer-Import-and-Export&quot;&gt;(gmp)Integer Import and Export&lt;/a&gt; for how to convert the &lt;code&gt;magnitude&lt;/code&gt; array to and from GMP &lt;code&gt;mpz_t&lt;/code&gt; values.</source>
          <target state="translated">다음 예제는 GNU Multiprecision Library (GMP)를 사용하여 주어진 정수 뒤의 가능한 다음 소수를 계산합니다. 참조 &lt;a href=&quot;http://www.gmplib.org/manual/index.html#Top&quot;&gt;(GMP) 최고&lt;/a&gt; GMP의 일반적인 개요, 볼 &lt;a href=&quot;http://www.gmplib.org/manual/Integer-Import-and-Export.html#Integer-Import-and-Export&quot;&gt;(GMP) 정수 가져 오기 및 내보내기를&lt;/a&gt; 변환하는 방법에 대한 &lt;code&gt;magnitude&lt;/code&gt; 와 GMP의에서 배열을 &lt;code&gt;mpz_t&lt;/code&gt; 의 값.</target>
        </trans-unit>
        <trans-unit id="8ccc6f71275edccfcefe025151e857765f2bef74" translate="yes" xml:space="preserve">
          <source>The following examples apply to C mode. (We use &lt;code&gt;string&lt;/code&gt; to make it easier to see the character returned by &lt;code&gt;char-syntax&lt;/code&gt;.)</source>
          <target state="translated">다음 예는 C 모드에 적용됩니다. ( 문자 &lt;code&gt;char-syntax&lt;/code&gt; 의해 반환 된 문자를 더 쉽게 볼 수 있도록 &lt;code&gt;string&lt;/code&gt; 을 사용 합니다 .)</target>
        </trans-unit>
        <trans-unit id="26d92c15072c5c240ab885269951f66b6b35d5e1" translate="yes" xml:space="preserve">
          <source>The following expressions are supported:</source>
          <target state="translated">다음 표현식이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="ea979b34ff1306c51163d99f45af8eeacfd3a2ed" translate="yes" xml:space="preserve">
          <source>The following four functions return size information about fonts used by various faces, allowing various layout considerations in Lisp programs. These functions take face remapping into consideration, returning information about the remapped face, if the face in question was remapped. See &lt;a href=&quot;face-remapping#Face-Remapping&quot;&gt;Face Remapping&lt;/a&gt;.</source>
          <target state="translated">다음 네 가지 함수는 다양한 얼굴에서 사용되는 글꼴에 대한 크기 정보를 반환하여 Lisp 프로그램에서 다양한 레이아웃 고려 사항을 허용합니다. 이러한 함수는 얼굴 리 맵핑을 고려하여 문제의 얼굴이 다시 매핑 된 경우 다시 매핑 된 얼굴에 대한 정보를 반환합니다. &lt;a href=&quot;face-remapping#Face-Remapping&quot;&gt;면 다시 매핑을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="be78e6b29260e74d50737c0ccdf28a858bff746b" translate="yes" xml:space="preserve">
          <source>The following four functions take as argument a live window which defaults to the selected one.</source>
          <target state="translated">다음 네 가지 함수는 선택한 항목으로 기본 설정되는 라이브 창을 인수로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b28622c4a0c44a36e614e4b99f2b96928420c806" translate="yes" xml:space="preserve">
          <source>The following frame parameters are semi-obsolete in that they are automatically equivalent to particular face attributes of particular faces (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Standard-Faces.html#Standard-Faces&quot;&gt;Standard Faces&lt;/a&gt; in</source>
          <target state="translated">다음 프레임 매개 변수는 특정면의 특정면 속성과 자동으로 동일하다는 점에서 일부 사용되지 않습니다 (의 &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Standard-Faces.html#Standard-Faces&quot;&gt;표준면&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="cb0d5dbd228f2db46d29d8fd495eae184f9211a5" translate="yes" xml:space="preserve">
          <source>The following frame parameters control various aspects of the frame&amp;rsquo;s interaction with the window manager or window system. They have no effect on text terminals.</source>
          <target state="translated">다음 프레임 매개 변수는 창 관리자 또는 창 시스템과의 프레임 상호 작용의 다양한 측면을 제어합니다. 텍스트 터미널에는 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bf7261ff6189a415c2673c506f413d2b2705feb4" translate="yes" xml:space="preserve">
          <source>The following function allows the entire window tree of a frame to be retrieved:</source>
          <target state="translated">다음 함수를 사용하면 프레임의 전체 창 트리를 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c4762fdb24ff2e4d3cb60e8188c313f3b2fbda2" translate="yes" xml:space="preserve">
          <source>The following function can be used to check whether the height of a particular window is preserved:</source>
          <target state="translated">다음 함수를 사용하여 특정 창의 높이가 유지되는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="117c5514e9c0c86e45b8ed5efd7004d773fd526d" translate="yes" xml:space="preserve">
          <source>The following function can be used to retrieve the edges of the outer, native and inner frame.</source>
          <target state="translated">다음 함수를 사용하여 외부, 기본 및 내부 프레임의 가장자리를 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea2cbed368d68e203932ff80be174434c94a4f4d" translate="yes" xml:space="preserve">
          <source>The following function can tell whether the mouse cursor is currently visible on a frame:</source>
          <target state="translated">The following function can tell whether the mouse cursor is currently visible on a frame:</target>
        </trans-unit>
        <trans-unit id="e2ca3d1c501ec1cc5dd734a37cfc409f12e0b6fa" translate="yes" xml:space="preserve">
          <source>The following function comes in handy for applying a certain function to all or part of the characters in a charset:</source>
          <target state="translated">The following function comes in handy for applying a certain function to all or part of the characters in a charset:</target>
        </trans-unit>
        <trans-unit id="f77a31c265b7eeea36fdbae05e58d9985d0570a4" translate="yes" xml:space="preserve">
          <source>The following function may be used to explicitly load the library specified by an autoload object:</source>
          <target state="translated">The following function may be used to explicitly load the library specified by an autoload object:</target>
        </trans-unit>
        <trans-unit id="ceeeb0b1e3b74324880960da48962febae85922a" translate="yes" xml:space="preserve">
          <source>The following function provides a convenient way to perform completion on an arbitrary stretch of text in an Emacs buffer:</source>
          <target state="translated">The following function provides a convenient way to perform completion on an arbitrary stretch of text in an Emacs buffer:</target>
        </trans-unit>
        <trans-unit id="73acc10fc0f8415d20b19b3c2e44bcf404ab2072" translate="yes" xml:space="preserve">
          <source>The following function returns the largest rectangle that can be inscribed in a window without covering text displayed in that window.</source>
          <target state="translated">The following function returns the largest rectangle that can be inscribed in a window without covering text displayed in that window.</target>
        </trans-unit>
        <trans-unit id="fc810414382be279064aacb6e28913b8de3c3ff6" translate="yes" xml:space="preserve">
          <source>The following function returns the root of the atomic window a specified window is part of:</source>
          <target state="translated">The following function returns the root of the atomic window a specified window is part of:</target>
        </trans-unit>
        <trans-unit id="31bd0e6b32efb7b36c0cf9948bd05648d25d411b" translate="yes" xml:space="preserve">
          <source>The following function returns the screen coordinates of a buffer position visible in a window:</source>
          <target state="translated">The following function returns the screen coordinates of a buffer position visible in a window:</target>
        </trans-unit>
        <trans-unit id="26a2f135aeb3b3b38b6b9f7e18e5eead9f063326" translate="yes" xml:space="preserve">
          <source>The following function returns the size in pixels of text as if it were displayed in a given window. This function is used by &lt;code&gt;fit-window-to-buffer&lt;/code&gt; and &lt;code&gt;fit-frame-to-buffer&lt;/code&gt; (see &lt;a href=&quot;resizing-windows#Resizing-Windows&quot;&gt;Resizing Windows&lt;/a&gt;) to make a window exactly as large as the text it contains.</source>
          <target state="translated">The following function returns the size in pixels of text as if it were displayed in a given window. This function is used by &lt;code&gt;fit-window-to-buffer&lt;/code&gt; and &lt;code&gt;fit-frame-to-buffer&lt;/code&gt; (see &lt;a href=&quot;resizing-windows#Resizing-Windows&quot;&gt;Resizing Windows&lt;/a&gt;) to make a window exactly as large as the text it contains.</target>
        </trans-unit>
        <trans-unit id="baaad99ca2ee271ccecab2b6a3ef8d793aeb7ed5" translate="yes" xml:space="preserve">
          <source>The following function returns the window showing the currently active minibuffer.</source>
          <target state="translated">The following function returns the window showing the currently active minibuffer.</target>
        </trans-unit>
        <trans-unit id="8b75ec29519dc9fe45770dfcb9354804e2c7afa9" translate="yes" xml:space="preserve">
          <source>The following function tells how small a specific window can get taking into account the sizes of its areas and the values of &lt;code&gt;window-min-height&lt;/code&gt;, &lt;code&gt;window-min-width&lt;/code&gt; and &lt;code&gt;window-size-fixed&lt;/code&gt; (see &lt;a href=&quot;preserving-window-sizes#Preserving-Window-Sizes&quot;&gt;Preserving Window Sizes&lt;/a&gt;).</source>
          <target state="translated">The following function tells how small a specific window can get taking into account the sizes of its areas and the values of &lt;code&gt;window-min-height&lt;/code&gt; , &lt;code&gt;window-min-width&lt;/code&gt; and &lt;code&gt;window-size-fixed&lt;/code&gt; (see &lt;a href=&quot;preserving-window-sizes#Preserving-Window-Sizes&quot;&gt;Preserving Window Sizes&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="17e4594a68f250e3e8b85fe3ee7531e8c73e1aaf" translate="yes" xml:space="preserve">
          <source>The following function uses the current buffer for temporary display:</source>
          <target state="translated">The following function uses the current buffer for temporary display:</target>
        </trans-unit>
        <trans-unit id="3f030bbc8b308337c1d8037400878c12fc6b75a0" translate="yes" xml:space="preserve">
          <source>The following functions add a button using an overlay (see &lt;a href=&quot;overlays#Overlays&quot;&gt;Overlays&lt;/a&gt;) to hold the button properties:</source>
          <target state="translated">The following functions add a button using an overlay (see &lt;a href=&quot;overlays#Overlays&quot;&gt;Overlays&lt;/a&gt;) to hold the button properties:</target>
        </trans-unit>
        <trans-unit id="9af23f6b20961af61b76c648d84296f5b4b0e9ad" translate="yes" xml:space="preserve">
          <source>The following functions are responsible for installing the user&amp;rsquo;s customization settings for variables and faces, respectively. When the user invokes &amp;lsquo;</source>
          <target state="translated">The following functions are responsible for installing the user&amp;rsquo;s customization settings for variables and faces, respectively. When the user invokes &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="d7b4e728a53c2e4b67182aeaebf7454821ce8777" translate="yes" xml:space="preserve">
          <source>The following functions are similar, but using text properties (see &lt;a href=&quot;text-properties#Text-Properties&quot;&gt;Text Properties&lt;/a&gt;) to hold the button properties. Such buttons do not add markers to the buffer, so editing in the buffer does not slow down if there is an extremely large numbers of buttons. However, if there is an existing face text property on the text (e.g., a face assigned by Font Lock mode), the button face may not be visible. Both of these functions return the starting position of the new button.</source>
          <target state="translated">The following functions are similar, but using text properties (see &lt;a href=&quot;text-properties#Text-Properties&quot;&gt;Text Properties&lt;/a&gt;) to hold the button properties. Such buttons do not add markers to the buffer, so editing in the buffer does not slow down if there is an extremely large numbers of buttons. However, if there is an existing face text property on the text (e.g., a face assigned by Font Lock mode), the button face may not be visible. Both of these functions return the starting position of the new button.</target>
        </trans-unit>
        <trans-unit id="84f3c437913b719438332ee8562848724259dd06" translate="yes" xml:space="preserve">
          <source>The following functions are specialized for handling floating-point numbers:</source>
          <target state="translated">The following functions are specialized for handling floating-point numbers:</target>
        </trans-unit>
        <trans-unit id="b893e578fff503e7493ed1c552081eb143f20c3f" translate="yes" xml:space="preserve">
          <source>The following functions are useful for programmatically enabling and disabling themes:</source>
          <target state="translated">The following functions are useful for programmatically enabling and disabling themes:</target>
        </trans-unit>
        <trans-unit id="531016c102f8f2a24b0893c6bb0481e625b81509" translate="yes" xml:space="preserve">
          <source>The following functions can be used to access symbol properties.</source>
          <target state="translated">The following functions can be used to access symbol properties.</target>
        </trans-unit>
        <trans-unit id="a9b7c957393c6e1fb8ce8837669b7366c5d35273" translate="yes" xml:space="preserve">
          <source>The following functions can be used to determine whether a given window has any adjacent windows.</source>
          <target state="translated">The following functions can be used to determine whether a given window has any adjacent windows.</target>
        </trans-unit>
        <trans-unit id="aad4cbdda12c20812720683836916585e55b1f16" translate="yes" xml:space="preserve">
          <source>The following functions can be used to manipulate property lists. They all compare property names using &lt;code&gt;eq&lt;/code&gt;.</source>
          <target state="translated">The following functions can be used to manipulate property lists. They all compare property names using &lt;code&gt;eq&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b8bab067bedd523b26cfb38d2407d422ebc6485" translate="yes" xml:space="preserve">
          <source>The following functions can be used to obtain information about a font. For these functions, the &lt;var&gt;font&lt;/var&gt; argument can be a font object, a font entity, or a font spec.</source>
          <target state="translated">The following functions can be used to obtain information about a font. For these functions, the &lt;var&gt;font&lt;/var&gt; argument can be a font object, a font entity, or a font spec.</target>
        </trans-unit>
        <trans-unit id="890cbaf248b1c3bd0429284d2b0998f1856c73a5" translate="yes" xml:space="preserve">
          <source>The following functions can be used to relate a set of frame-relative coordinates to a window:</source>
          <target state="translated">The following functions can be used to relate a set of frame-relative coordinates to a window:</target>
        </trans-unit>
        <trans-unit id="907f5fb790174097faee980eaa3e6e493703e37f" translate="yes" xml:space="preserve">
          <source>The following functions can be used to retrieve a child window of an internal window, and the siblings of a child window.</source>
          <target state="translated">The following functions can be used to retrieve a child window of an internal window, and the siblings of a child window.</target>
        </trans-unit>
        <trans-unit id="5abac45b57d6cb02f4a44218dad6bcf05e357901" translate="yes" xml:space="preserve">
          <source>The following functions can be used to work with this structure. Each function takes a</source>
          <target state="translated">The following functions can be used to work with this structure. Each function takes a</target>
        </trans-unit>
        <trans-unit id="5e7b9f761ac410965453c46cb12a7b79355721cc" translate="yes" xml:space="preserve">
          <source>The following functions can be useful to locate a window within its frame.</source>
          <target state="translated">The following functions can be useful to locate a window within its frame.</target>
        </trans-unit>
        <trans-unit id="d4d8b453efb193de073f07eacd52282b298d2182" translate="yes" xml:space="preserve">
          <source>The following functions create strings, either from scratch, or by putting strings together, or by taking them apart.</source>
          <target state="translated">The following functions create strings, either from scratch, or by putting strings together, or by taking them apart.</target>
        </trans-unit>
        <trans-unit id="2830de83f3df2374878d8790525a0ec899df66a3" translate="yes" xml:space="preserve">
          <source>The following functions examine the attributes of a face. They mostly provide compatibility with old versions of Emacs. If you don&amp;rsquo;t specify &lt;var&gt;frame&lt;/var&gt;, they refer to the selected frame; &lt;code&gt;t&lt;/code&gt; refers to the default data for new frames. They return &lt;code&gt;unspecified&lt;/code&gt; if the face doesn&amp;rsquo;t define any value for that attribute. If &lt;var&gt;inherit&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, only an attribute directly defined by the face is returned. If &lt;var&gt;inherit&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, any faces specified by its &lt;code&gt;:inherit&lt;/code&gt; attribute are considered as well, and if &lt;var&gt;inherit&lt;/var&gt; is a face or a list of faces, then they are also considered, until a specified attribute is found. To ensure that the return value is always specified, use a value of &lt;code&gt;default&lt;/code&gt; for &lt;var&gt;inherit&lt;/var&gt;.</source>
          <target state="translated">The following functions examine the attributes of a face. They mostly provide compatibility with old versions of Emacs. If you don&amp;rsquo;t specify &lt;var&gt;frame&lt;/var&gt; , they refer to the selected frame; &lt;code&gt;t&lt;/code&gt; refers to the default data for new frames. They return &lt;code&gt;unspecified&lt;/code&gt; if the face doesn&amp;rsquo;t define any value for that attribute. If &lt;var&gt;inherit&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; , only an attribute directly defined by the face is returned. If &lt;var&gt;inherit&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , any faces specified by its &lt;code&gt;:inherit&lt;/code&gt; attribute are considered as well, and if &lt;var&gt;inherit&lt;/var&gt; is a face or a list of faces, then they are also considered, until a specified attribute is found. To ensure that the return value is always specified, use a value of &lt;code&gt;default&lt;/code&gt; for &lt;var&gt;inherit&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="34336bc291047ecc82ef9e39f037db9645e68fee" translate="yes" xml:space="preserve">
          <source>The following functions implement a higher-level interface to &lt;code&gt;face-remapping-alist&lt;/code&gt;. Most Lisp code should use these functions instead of setting &lt;code&gt;face-remapping-alist&lt;/code&gt; directly, to avoid trampling on remappings applied elsewhere. These functions are intended for buffer-local remappings, so they all make &lt;code&gt;face-remapping-alist&lt;/code&gt; buffer-local as a side-effect. They manage &lt;code&gt;face-remapping-alist&lt;/code&gt; entries of the form</source>
          <target state="translated">The following functions implement a higher-level interface to &lt;code&gt;face-remapping-alist&lt;/code&gt; . Most Lisp code should use these functions instead of setting &lt;code&gt;face-remapping-alist&lt;/code&gt; directly, to avoid trampling on remappings applied elsewhere. These functions are intended for buffer-local remappings, so they all make &lt;code&gt;face-remapping-alist&lt;/code&gt; buffer-local as a side-effect. They manage &lt;code&gt;face-remapping-alist&lt;/code&gt; entries of the form</target>
        </trans-unit>
        <trans-unit id="f45de0afa1e82c2bee6e9b103afe4d0400313b5d" translate="yes" xml:space="preserve">
          <source>The following functions may be used to manipulate and query the watch functions for a variable.</source>
          <target state="translated">The following functions may be used to manipulate and query the watch functions for a variable.</target>
        </trans-unit>
        <trans-unit id="297514168ef2ea3e190861ad8aed9621b2bf0fde" translate="yes" xml:space="preserve">
          <source>The following functions replace characters within a specified region based on their character codes.</source>
          <target state="translated">The following functions replace characters within a specified region based on their character codes.</target>
        </trans-unit>
        <trans-unit id="8ef4900912dcb434358d1e1cc34146dd4ae71b7f" translate="yes" xml:space="preserve">
          <source>The following functions return a window which satisfies some criterion, without selecting it:</source>
          <target state="translated">The following functions return a window which satisfies some criterion, without selecting it:</target>
        </trans-unit>
        <trans-unit id="6c1b3a2ec1e9d599ce858d9c865cc30d35b9cfbd" translate="yes" xml:space="preserve">
          <source>The following functions return window positions in pixels, rather than character units. Though mostly useful on graphical displays, they can also be called on text terminals, where the screen area of each text character is taken to be one pixel.</source>
          <target state="translated">The following functions return window positions in pixels, rather than character units. Though mostly useful on graphical displays, they can also be called on text terminals, where the screen area of each text character is taken to be one pixel.</target>
        </trans-unit>
        <trans-unit id="f2f37ec3b726c43a4c87205d55e42808f4009de8" translate="yes" xml:space="preserve">
          <source>The following functions return window positions in pixels, relative to the origin of the display screen rather than that of the frame:</source>
          <target state="translated">The following functions return window positions in pixels, relative to the origin of the display screen rather than that of the frame:</target>
        </trans-unit>
        <trans-unit id="155cd68525e1e78f8dc1877edd4a3b4cc3b3b32f" translate="yes" xml:space="preserve">
          <source>The following is a list of metadata entries that a completion function may return in response to a &lt;code&gt;metadata&lt;/code&gt; flag argument:</source>
          <target state="translated">The following is a list of metadata entries that a completion function may return in response to a &lt;code&gt;metadata&lt;/code&gt; flag argument:</target>
        </trans-unit>
        <trans-unit id="4a1e6d11578135dd2c40c588ed3ccefbb4f97f26" translate="yes" xml:space="preserve">
          <source>The following is a list of properties that are meaningful for all image types (there are also properties which are meaningful only for certain image types, as documented in the following subsections):</source>
          <target state="translated">The following is a list of properties that are meaningful for all image types (there are also properties which are meaningful only for certain image types, as documented in the following subsections):</target>
        </trans-unit>
        <trans-unit id="4093aee444ad060f90230a5ef648f614d3a0ca58" translate="yes" xml:space="preserve">
          <source>The following is a list of some hook variables that let you provide functions to be called from within Emacs on suitable occasions.</source>
          <target state="translated">The following is a list of some hook variables that let you provide functions to be called from within Emacs on suitable occasions.</target>
        </trans-unit>
        <trans-unit id="ccb2830cf31ad8ceb9e30c7ff4ee6d68c4873ecb" translate="yes" xml:space="preserve">
          <source>The following list of conventions is only partial. Each major mode should aim for consistency in general with other Emacs major modes, as this makes Emacs as a whole more coherent. It is impossible to list here all the possible points where this issue might come up; if the Emacs developers point out an area where your major mode deviates from the usual conventions, please make it compatible.</source>
          <target state="translated">The following list of conventions is only partial. Each major mode should aim for consistency in general with other Emacs major modes, as this makes Emacs as a whole more coherent. It is impossible to list here all the possible points where this issue might come up; if the Emacs developers point out an area where your major mode deviates from the usual conventions, please make it compatible.</target>
        </trans-unit>
        <trans-unit id="2f4c46986c8a870fb9516c70d5b6f51ae0a91573" translate="yes" xml:space="preserve">
          <source>The following macro provides a convenient way to define pop-up menus and/or menu bar menus.</source>
          <target state="translated">The following macro provides a convenient way to define pop-up menus and/or menu bar menus.</target>
        </trans-unit>
        <trans-unit id="5ad57c1f83c65077036b934b7fd3727e3ea0f239" translate="yes" xml:space="preserve">
          <source>The following macros should be used in the body of a function defined by &lt;code&gt;define-inline&lt;/code&gt;.</source>
          <target state="translated">The following macros should be used in the body of a function defined by &lt;code&gt;define-inline&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="61cd8af7f02eeb28f4ce378e89ac8b778f999f77" translate="yes" xml:space="preserve">
          <source>The following network options can be specified when you create a network process. Except for &lt;code&gt;:reuseaddr&lt;/code&gt;, you can also set or modify these options later, using &lt;code&gt;set-network-process-option&lt;/code&gt;.</source>
          <target state="translated">The following network options can be specified when you create a network process. Except for &lt;code&gt;:reuseaddr&lt;/code&gt; , you can also set or modify these options later, using &lt;code&gt;set-network-process-option&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd2fc598c57ec7c3805d2638d2b8b8ee1d26d24c" translate="yes" xml:space="preserve">
          <source>The following option allows to automatically select the window under the mouse pointer. This accomplishes a policy similar to that of window managers that give focus to a frame (and thus trigger its subsequent selection) whenever the mouse pointer enters its window-system window (see &lt;a href=&quot;input-focus#Input-Focus&quot;&gt;Input Focus&lt;/a&gt;).</source>
          <target state="translated">The following option allows to automatically select the window under the mouse pointer. This accomplishes a policy similar to that of window managers that give focus to a frame (and thus trigger its subsequent selection) whenever the mouse pointer enters its window-system window (see &lt;a href=&quot;input-focus#Input-Focus&quot;&gt;Input Focus&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="d7851e2664e5c756dae87ae16e5d4cb14feb40f7" translate="yes" xml:space="preserve">
          <source>The following option specifies how to deal with a frame containing just one window that should be either quit, or whose buffer should be buried.</source>
          <target state="translated">The following option specifies how to deal with a frame containing just one window that should be either quit, or whose buffer should be buried.</target>
        </trans-unit>
        <trans-unit id="ada5ff929af79df9bfadbae1b79b7910e6c1c8cf" translate="yes" xml:space="preserve">
          <source>The following options affect some aspects of the startup sequence.</source>
          <target state="translated">The following options affect some aspects of the startup sequence.</target>
        </trans-unit>
        <trans-unit id="e1aec0ad769964195d8b0b82e98cb13200879f29" translate="yes" xml:space="preserve">
          <source>The following options provide additional control over the placement of side windows.</source>
          <target state="translated">The following options provide additional control over the placement of side windows.</target>
        </trans-unit>
        <trans-unit id="0d184dd753268c287e714dc96de749f048d0308b" translate="yes" xml:space="preserve">
          <source>The following parameters are currently used by the window management code:</source>
          <target state="translated">The following parameters are currently used by the window management code:</target>
        </trans-unit>
        <trans-unit id="bbb0060fafb1b1a12e73884154b4dd11377c3b26" translate="yes" xml:space="preserve">
          <source>The following parameters are supported:</source>
          <target state="translated">다음과 같은 매개 변수가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="4f59f6941bde6c4db5d1e3e41b34d7afbaba9370" translate="yes" xml:space="preserve">
          <source>The following piece of code demonstrates some important principles of working with iterators.</source>
          <target state="translated">The following piece of code demonstrates some important principles of working with iterators.</target>
        </trans-unit>
        <trans-unit id="a4f0eab4462560047e86c6b11d762d5644d33c5b" translate="yes" xml:space="preserve">
          <source>The following predicates test whether a Lisp object is an atom, whether it is a cons cell or is a list, or whether it is the distinguished object &lt;code&gt;nil&lt;/code&gt;. (Many of these predicates can be defined in terms of the others, but they are used so often that it is worth having them.)</source>
          <target state="translated">The following predicates test whether a Lisp object is an atom, whether it is a cons cell or is a list, or whether it is the distinguished object &lt;code&gt;nil&lt;/code&gt; . (Many of these predicates can be defined in terms of the others, but they are used so often that it is worth having them.)</target>
        </trans-unit>
        <trans-unit id="826b4fe071d5c29efd8caca96b29fad3a0a2f2d1" translate="yes" xml:space="preserve">
          <source>The following properties have special meaning:</source>
          <target state="translated">The following properties have special meaning:</target>
        </trans-unit>
        <trans-unit id="ebef11ee154eef7f4eb1fc917c2aac083fcb211f" translate="yes" xml:space="preserve">
          <source>The following properties have special meanings:</source>
          <target state="translated">The following properties have special meanings:</target>
        </trans-unit>
        <trans-unit id="57c6bef4e378aea04508546ae08d21653ab1f737" translate="yes" xml:space="preserve">
          <source>The following regular expression constructs match the empty string&amp;mdash;that is, they don&amp;rsquo;t use up any characters&amp;mdash;but whether they match depends on the context. For all, the beginning and end of the accessible portion of the buffer are treated as if they were the actual beginning and end of the buffer.</source>
          <target state="translated">The following regular expression constructs match the empty string&amp;mdash;that is, they don&amp;rsquo;t use up any characters&amp;mdash;but whether they match depends on the context. For all, the beginning and end of the accessible portion of the buffer are treated as if they were the actual beginning and end of the buffer.</target>
        </trans-unit>
        <trans-unit id="ab93757b1beab2aa1b514e6ad4b5403f0cf390d7" translate="yes" xml:space="preserve">
          <source>The following sample code shows a simple use of &lt;code&gt;abbrev-expand-function&lt;/code&gt;. It assumes that &lt;code&gt;foo-mode&lt;/code&gt; is a mode for editing certain files in which lines that start with &amp;lsquo;</source>
          <target state="translated">The following sample code shows a simple use of &lt;code&gt;abbrev-expand-function&lt;/code&gt; . It assumes that &lt;code&gt;foo-mode&lt;/code&gt; is a mode for editing certain files in which lines that start with &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="cd3bff5b4b8d36513361c4cb174579259d0a14c3" translate="yes" xml:space="preserve">
          <source>The following schematic shows the structure of a live window:</source>
          <target state="translated">The following schematic shows the structure of a live window:</target>
        </trans-unit>
        <trans-unit id="3812318991beb737b8ecfc0d3eb9bffa47526a30" translate="yes" xml:space="preserve">
          <source>The following sections describe how to create a package, and how to put it in a &lt;em&gt;package archive&lt;/em&gt; for others to download. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Packages.html#Packages&quot;&gt;Packages&lt;/a&gt; in</source>
          <target state="translated">The following sections describe how to create a package, and how to put it in a &lt;em&gt;package archive&lt;/em&gt; for others to download. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Packages.html#Packages&quot;&gt;Packages&lt;/a&gt; in</target>
        </trans-unit>
        <trans-unit id="a7f5eb5126f13e48e5d8a4cfa1f8a337e3e76816" translate="yes" xml:space="preserve">
          <source>The following subsections describe dynamic binding and lexical binding in greater detail, and how to enable lexical binding in Emacs Lisp programs.</source>
          <target state="translated">The following subsections describe dynamic binding and lexical binding in greater detail, and how to enable lexical binding in Emacs Lisp programs.</target>
        </trans-unit>
        <trans-unit id="f427796ad98b404b1017d94a966c0d6e0b800693" translate="yes" xml:space="preserve">
          <source>The following subsections describe these tasks and the</source>
          <target state="translated">The following subsections describe these tasks and the</target>
        </trans-unit>
        <trans-unit id="557e3858b495db8eb07b06d74c4bda7f399bc1fd" translate="yes" xml:space="preserve">
          <source>The following three functions are convenient subroutines for packages that define non-</source>
          <target state="translated">The following three functions are convenient subroutines for packages that define non-</target>
        </trans-unit>
        <trans-unit id="536c73ef47f549795a27c13372e2ba64eb41c149" translate="yes" xml:space="preserve">
          <source>The following three functions are like &lt;code&gt;memq&lt;/code&gt;, &lt;code&gt;delq&lt;/code&gt; and &lt;code&gt;remq&lt;/code&gt;, but use &lt;code&gt;equal&lt;/code&gt; rather than &lt;code&gt;eq&lt;/code&gt; to compare elements. See &lt;a href=&quot;equality-predicates#Equality-Predicates&quot;&gt;Equality Predicates&lt;/a&gt;.</source>
          <target state="translated">The following three functions are like &lt;code&gt;memq&lt;/code&gt; , &lt;code&gt;delq&lt;/code&gt; and &lt;code&gt;remq&lt;/code&gt; , but use &lt;code&gt;equal&lt;/code&gt; rather than &lt;code&gt;eq&lt;/code&gt; to compare elements. See &lt;a href=&quot;equality-predicates#Equality-Predicates&quot;&gt;Equality Predicates&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="355f4e1293b1c2362148cc63e3a7bedf8f34b49f" translate="yes" xml:space="preserve">
          <source>The following three functions take as argument a live frame which defaults to the selected one.</source>
          <target state="translated">The following three functions take as argument a live frame which defaults to the selected one.</target>
        </trans-unit>
        <trans-unit id="1f17162ac41b5c364770f2de0d633eda6a4b0b6a" translate="yes" xml:space="preserve">
          <source>The following three variables are used in &lt;code&gt;mode-line-modes&lt;/code&gt;:</source>
          <target state="translated">The following three variables are used in &lt;code&gt;mode-line-modes&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="29c7181d047de2cd97f0970a6987cb63e7fbbb89" translate="yes" xml:space="preserve">
          <source>The following three variables, when non-&lt;code&gt;nil&lt;/code&gt;, cause the second method to be used in certain special cases. They have no effect on the treatment of files that don&amp;rsquo;t fall into the special cases.</source>
          <target state="translated">The following three variables, when non- &lt;code&gt;nil&lt;/code&gt; , cause the second method to be used in certain special cases. They have no effect on the treatment of files that don&amp;rsquo;t fall into the special cases.</target>
        </trans-unit>
        <trans-unit id="115768852bac8cdf35b7fa82a90cdf33ddc11555" translate="yes" xml:space="preserve">
          <source>The following two &lt;code&gt;%&lt;/code&gt;-constructs are still supported, but they are obsolete, since you can get the same results with the variables &lt;code&gt;mode-name&lt;/code&gt; and &lt;code&gt;global-mode-string&lt;/code&gt;.</source>
          <target state="translated">The following two &lt;code&gt;%&lt;/code&gt; -constructs are still supported, but they are obsolete, since you can get the same results with the variables &lt;code&gt;mode-name&lt;/code&gt; and &lt;code&gt;global-mode-string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c8bf40b8538d6f6330c64f3c882e6c1bcb9062c8" translate="yes" xml:space="preserve">
          <source>The following two functions are meant for modes that want to provide help without relinquishing control, such as the electric modes. Their names begin with &amp;lsquo;</source>
          <target state="translated">The following two functions are meant for modes that want to provide help without relinquishing control, such as the electric modes. Their names begin with &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="1abd9368a3d734825a10efb49b4dabc426bea1a2" translate="yes" xml:space="preserve">
          <source>The following two functions are useful for combining a list of individual command-line argument strings into a single string, and taking a string apart into a list of individual command-line arguments. These functions are mainly intended for converting user input in the minibuffer, a Lisp string, into a list of string arguments to be passed to &lt;code&gt;make-process&lt;/code&gt;, &lt;code&gt;call-process&lt;/code&gt; or &lt;code&gt;start-process&lt;/code&gt;, or for converting such lists of arguments into a single Lisp string to be presented in the minibuffer or echo area. Note that if a shell is involved (e.g., if using &lt;code&gt;call-process-shell-command&lt;/code&gt;), arguments should still be protected by &lt;code&gt;shell-quote-argument&lt;/code&gt;; &lt;code&gt;combine-and-quote-strings&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; intended to protect special characters from shell evaluation.</source>
          <target state="translated">The following two functions are useful for combining a list of individual command-line argument strings into a single string, and taking a string apart into a list of individual command-line arguments. These functions are mainly intended for converting user input in the minibuffer, a Lisp string, into a list of string arguments to be passed to &lt;code&gt;make-process&lt;/code&gt; , &lt;code&gt;call-process&lt;/code&gt; or &lt;code&gt;start-process&lt;/code&gt; , or for converting such lists of arguments into a single Lisp string to be presented in the minibuffer or echo area. Note that if a shell is involved (e.g., if using &lt;code&gt;call-process-shell-command&lt;/code&gt; ), arguments should still be protected by &lt;code&gt;shell-quote-argument&lt;/code&gt; ; &lt;code&gt;combine-and-quote-strings&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; intended to protect special characters from shell evaluation.</target>
        </trans-unit>
        <trans-unit id="345ce9209913e7b713026911f4f5e94a02bd44b6" translate="yes" xml:space="preserve">
          <source>The following two functions are useful when a Lisp program needs to map buffer positions to byte offsets in a file visited by the buffer.</source>
          <target state="translated">The following two functions are useful when a Lisp program needs to map buffer positions to byte offsets in a file visited by the buffer.</target>
        </trans-unit>
        <trans-unit id="f6e12a6446862c2522d3f1a9ffd8ddf8904cc177" translate="yes" xml:space="preserve">
          <source>The following two functions can be used to return the total size of a window in units of pixels.</source>
          <target state="translated">The following two functions can be used to return the total size of a window in units of pixels.</target>
        </trans-unit>
        <trans-unit id="a48c7947820ecbb53fcfdd25e5c96ba5864b3d86" translate="yes" xml:space="preserve">
          <source>The following two functions can be useful when working with child and parent frames:</source>
          <target state="translated">The following two functions can be useful when working with child and parent frames:</target>
        </trans-unit>
        <trans-unit id="2a83b06e67c6529bbdbddb0d5afbb5cf809d5bcc" translate="yes" xml:space="preserve">
          <source>The following two functions convert between directory names and directory file names. They do nothing special with environment variable substitutions such as &amp;lsquo;</source>
          <target state="translated">The following two functions convert between directory names and directory file names. They do nothing special with environment variable substitutions such as &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="4fac544aa9936ae6c2b6929f4306babf281bddd4" translate="yes" xml:space="preserve">
          <source>The following two functions move point over a specified set of characters. For example, they are often used to skip whitespace. For related functions, see &lt;a href=&quot;motion-and-syntax#Motion-and-Syntax&quot;&gt;Motion and Syntax&lt;/a&gt;.</source>
          <target state="translated">The following two functions move point over a specified set of characters. For example, they are often used to skip whitespace. For related functions, see &lt;a href=&quot;motion-and-syntax#Motion-and-Syntax&quot;&gt;Motion and Syntax&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="8c338e0f1681bbeb0ada6c9b11a1251284be5bda" translate="yes" xml:space="preserve">
          <source>The following two functions return a mouse position list (see &lt;a href=&quot;click-events#Click-Events&quot;&gt;Click Events&lt;/a&gt;), specifying the position of a mouse event.</source>
          <target state="translated">The following two functions return a mouse position list (see &lt;a href=&quot;click-events#Click-Events&quot;&gt;Click Events&lt;/a&gt;), specifying the position of a mouse event.</target>
        </trans-unit>
        <trans-unit id="cc0b4c0c74f55c58b403e95e6a1acfb6ff12b20c" translate="yes" xml:space="preserve">
          <source>The following two functions return important information about a font.</source>
          <target state="translated">The following two functions return important information about a font.</target>
        </trans-unit>
        <trans-unit id="1e7e472e6478094296cd45e3d521f50016cac3a3" translate="yes" xml:space="preserve">
          <source>The following two options control whether minibuffer windows are resized automatically and how large they can get in the process.</source>
          <target state="translated">The following two options control whether minibuffer windows are resized automatically and how large they can get in the process.</target>
        </trans-unit>
        <trans-unit id="24fa8abe9618c4cb6b7db987de4f0d9cacb7fa8f" translate="yes" xml:space="preserve">
          <source>The following two regular expressions should &lt;em&gt;not&lt;/em&gt; assume the match always starts at the beginning of a line; they should not use &amp;lsquo;</source>
          <target state="translated">The following two regular expressions should &lt;em&gt;not&lt;/em&gt; assume the match always starts at the beginning of a line; they should not use &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="cc6bf9832061e83897200953f3dd12c79d5af846" translate="yes" xml:space="preserve">
          <source>The following two variables are obsoleted by &lt;code&gt;filter-buffer-substring-function&lt;/code&gt;, but are still supported for backward compatibility.</source>
          <target state="translated">The following two variables are obsoleted by &lt;code&gt;filter-buffer-substring-function&lt;/code&gt; , but are still supported for backward compatibility.</target>
        </trans-unit>
        <trans-unit id="4d489eae93ac203d9b2ffd3584656c2dde948029" translate="yes" xml:space="preserve">
          <source>The following values are respected:</source>
          <target state="translated">The following values are respected:</target>
        </trans-unit>
        <trans-unit id="09aa9057414e7950dd19147648c16cf90861056f" translate="yes" xml:space="preserve">
          <source>The following variables affect how certain characters are displayed on the screen. Since they change the number of columns the characters occupy, they also affect the indentation functions. They also affect how the mode line is displayed; if you want to force redisplay of the mode line using the new values, call the function &lt;code&gt;force-mode-line-update&lt;/code&gt; (see &lt;a href=&quot;mode-line-format#Mode-Line-Format&quot;&gt;Mode Line Format&lt;/a&gt;).</source>
          <target state="translated">The following variables affect how certain characters are displayed on the screen. Since they change the number of columns the characters occupy, they also affect the indentation functions. They also affect how the mode line is displayed; if you want to force redisplay of the mode line using the new values, call the function &lt;code&gt;force-mode-line-update&lt;/code&gt; (see &lt;a href=&quot;mode-line-format#Mode-Line-Format&quot;&gt;Mode Line Format&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="14dec20b7fbc6fcced5e5d29086ee55e867ebdd4" translate="yes" xml:space="preserve">
          <source>The following will create a linear gradient that goes from red at the start, to green 25% of the way, to blue at the end:</source>
          <target state="translated">The following will create a linear gradient that goes from red at the start, to green 25% of the way, to blue at the end:</target>
        </trans-unit>
        <trans-unit id="e95288a0f9a444d98e8a41cba18b24ae66da9ad1" translate="yes" xml:space="preserve">
          <source>The font must be an OpenType font that supports these OpenType features, provided Emacs is compiled with a library, such as &amp;lsquo;</source>
          <target state="translated">The font must be an OpenType font that supports these OpenType features, provided Emacs is compiled with a library, such as &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="6556801bce4e544f06ab7ea9eb5f7746cb4afd5e" translate="yes" xml:space="preserve">
          <source>The font name (a string), in either XLFD, Fontconfig, or GTK+ format. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Fonts.html#Fonts&quot;&gt;Fonts&lt;/a&gt; in</source>
          <target state="translated">The font name (a string), in either XLFD, Fontconfig, or GTK+ format. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Fonts.html#Fonts&quot;&gt;Fonts&lt;/a&gt; in</target>
        </trans-unit>
        <trans-unit id="af0bd798857380a819581a44d67b89d6f115632d" translate="yes" xml:space="preserve">
          <source>The font name, a string.</source>
          <target state="translated">The font name, a string.</target>
        </trans-unit>
        <trans-unit id="a7248edb376ccd7b3b10bb9e3cb840736177f911" translate="yes" xml:space="preserve">
          <source>The font size&amp;mdash;either a non-negative integer that specifies the pixel size, or a floating-point number that specifies the point size.</source>
          <target state="translated">The font size&amp;mdash;either a non-negative integer that specifies the pixel size, or a floating-point number that specifies the point size.</target>
        </trans-unit>
        <trans-unit id="23f58ef9a79c9daa9a087fb25286120885af393b" translate="yes" xml:space="preserve">
          <source>The font used to display the face. Its value should be a font object or a fontset. See &lt;a href=&quot;low_002dlevel-font#Low_002dLevel-Font&quot;&gt;Low-Level Font&lt;/a&gt;, for information about font objects, font specs, and font entities. See &lt;a href=&quot;fontsets#Fontsets&quot;&gt;Fontsets&lt;/a&gt;, for information about fontsets.</source>
          <target state="translated">The font used to display the face. Its value should be a font object or a fontset. See &lt;a href=&quot;low_002dlevel-font#Low_002dLevel-Font&quot;&gt;Low-Level Font&lt;/a&gt;, for information about font objects, font specs, and font entities. See &lt;a href=&quot;fontsets#Fontsets&quot;&gt;Fontsets&lt;/a&gt;, for information about fontsets.</target>
        </trans-unit>
        <trans-unit id="3e2495d3f6b500a7c3764a7896dc703df930eb34" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;(+ &lt;var&gt;expr&lt;/var&gt; ...)&lt;/code&gt; adds up the value of the expressions. The form &lt;code&gt;(- &lt;var&gt;expr&lt;/var&gt; ...)&lt;/code&gt; negates or subtracts the value of the expressions.</source>
          <target state="translated">The form &lt;code&gt;(+ &lt;var&gt;expr&lt;/var&gt; ...)&lt;/code&gt; adds up the value of the expressions. The form &lt;code&gt;(- &lt;var&gt;expr&lt;/var&gt; ...)&lt;/code&gt; negates or subtracts the value of the expressions.</target>
        </trans-unit>
        <trans-unit id="f9074ede26f7f654c16278889f1f4de2d0cebbf4" translate="yes" xml:space="preserve">
          <source>The form &lt;var&gt;num&lt;/var&gt; specifies a fraction of the default frame font height or width. The form &lt;code&gt;(&lt;var&gt;num&lt;/var&gt;)&lt;/code&gt; specifies an absolute number of pixels. If &lt;var&gt;num&lt;/var&gt; is a symbol, &lt;var&gt;symbol&lt;/var&gt;, its buffer-local variable binding is used; that binding can be either a number or a cons cell of the forms shown above (including yet another cons cell whose &lt;code&gt;car&lt;/code&gt; is a symbol that has a buffer-local binding).</source>
          <target state="translated">The form &lt;var&gt;num&lt;/var&gt; specifies a fraction of the default frame font height or width. The form &lt;code&gt;(&lt;var&gt;num&lt;/var&gt;)&lt;/code&gt; specifies an absolute number of pixels. If &lt;var&gt;num&lt;/var&gt; is a symbol, &lt;var&gt;symbol&lt;/var&gt; , its buffer-local variable binding is used; that binding can be either a number or a cons cell of the forms shown above (including yet another cons cell whose &lt;code&gt;car&lt;/code&gt; is a symbol that has a buffer-local binding).</target>
        </trans-unit>
        <trans-unit id="eefdf767b9da94cedb2272c4d442fd16a210f77a" translate="yes" xml:space="preserve">
          <source>The format of &lt;var&gt;local-address&lt;/var&gt; or &lt;var&gt;remote-address&lt;/var&gt; depends on the address family:</source>
          <target state="translated">The format of &lt;var&gt;local-address&lt;/var&gt; or &lt;var&gt;remote-address&lt;/var&gt; depends on the address family:</target>
        </trans-unit>
        <trans-unit id="f1523839ef4d5afd7ac94bcc51e58e0b20efc3f4" translate="yes" xml:space="preserve">
          <source>The format of this list is the same as what &lt;code&gt;decode-time&lt;/code&gt; accepts (see &lt;a href=&quot;time-conversion#Time-Conversion&quot;&gt;Time Conversion&lt;/a&gt;), and is described in more detail there. Any element that cannot be determined from the input will be set to &lt;code&gt;nil&lt;/code&gt;. The argument &lt;var&gt;string&lt;/var&gt; should resemble an RFC 822 (or later) or ISO 8601 string, like &amp;ldquo;Fri, 25 Mar 2016 16:24:56 +0100&amp;rdquo; or &amp;ldquo;1998-09-12T12:21:54-0200&amp;rdquo;, but this function will attempt to parse less well-formed time strings as well.</source>
          <target state="translated">The format of this list is the same as what &lt;code&gt;decode-time&lt;/code&gt; accepts (see &lt;a href=&quot;time-conversion#Time-Conversion&quot;&gt;Time Conversion&lt;/a&gt;), and is described in more detail there. Any element that cannot be determined from the input will be set to &lt;code&gt;nil&lt;/code&gt; . The argument &lt;var&gt;string&lt;/var&gt; should resemble an RFC 822 (or later) or ISO 8601 string, like &amp;ldquo;Fri, 25 Mar 2016 16:24:56 +0100&amp;rdquo; or &amp;ldquo;1998-09-12T12:21:54-0200&amp;rdquo;, but this function will attempt to parse less well-formed time strings as well.</target>
        </trans-unit>
        <trans-unit id="a420ccf20ba6d5b4c425fdd899162dfbbd53605d" translate="yes" xml:space="preserve">
          <source>The format we use for buffer contents in examples.</source>
          <target state="translated">The format we use for buffer contents in examples.</target>
        </trans-unit>
        <trans-unit id="4a56368511816baafb987e4550f7fd019ef9406d" translate="yes" xml:space="preserve">
          <source>The format we use for examples of errors.</source>
          <target state="translated">The format we use for examples of errors.</target>
        </trans-unit>
        <trans-unit id="39ba77d521c50dab220364437e7b5dabde639177" translate="yes" xml:space="preserve">
          <source>The format we use for examples of evaluation.</source>
          <target state="translated">The format we use for examples of evaluation.</target>
        </trans-unit>
        <trans-unit id="37518e914cc1faa1cdf2b3e15db2c5a92c8aeff9" translate="yes" xml:space="preserve">
          <source>The format we use when examples print text.</source>
          <target state="translated">The format we use when examples print text.</target>
        </trans-unit>
        <trans-unit id="17e1d52af71f6c32ba5e92306abc4c53f00bf057" translate="yes" xml:space="preserve">
          <source>The former is used by overlay arrows. The latter is unused.</source>
          <target state="translated">The former is used by overlay arrows. The latter is unused.</target>
        </trans-unit>
        <trans-unit id="203096a174bb892e518022e452e96010dd9a8b89" translate="yes" xml:space="preserve">
          <source>The forms &lt;var&gt;pre-form&lt;/var&gt; and &lt;var&gt;post-form&lt;/var&gt; can be used to initialize before, and cleanup after, &lt;var&gt;anchored-matcher&lt;/var&gt; is used. Typically, &lt;var&gt;pre-form&lt;/var&gt; is used to move point to some position relative to the match of &lt;var&gt;matcher&lt;/var&gt;, before starting with &lt;var&gt;anchored-matcher&lt;/var&gt;. &lt;var&gt;post-form&lt;/var&gt; might be used to move back, before resuming with &lt;var&gt;matcher&lt;/var&gt;.</source>
          <target state="translated">The forms &lt;var&gt;pre-form&lt;/var&gt; and &lt;var&gt;post-form&lt;/var&gt; can be used to initialize before, and cleanup after, &lt;var&gt;anchored-matcher&lt;/var&gt; is used. Typically, &lt;var&gt;pre-form&lt;/var&gt; is used to move point to some position relative to the match of &lt;var&gt;matcher&lt;/var&gt; , before starting with &lt;var&gt;anchored-matcher&lt;/var&gt; . &lt;var&gt;post-form&lt;/var&gt; might be used to move back, before resuming with &lt;var&gt;matcher&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="ceadb637a596eb2ee47bea0bcd88b1125c133ad0" translate="yes" xml:space="preserve">
          <source>The fourth argument &lt;var&gt;parents&lt;/var&gt; says whether to create parent directories if they don&amp;rsquo;t exist. Interactively, this happens by default.</source>
          <target state="translated">The fourth argument &lt;var&gt;parents&lt;/var&gt; says whether to create parent directories if they don&amp;rsquo;t exist. Interactively, this happens by default.</target>
        </trans-unit>
        <trans-unit id="49ca71782e46f41b945559e28fbf6e1d7928a06f" translate="yes" xml:space="preserve">
          <source>The fourth element is the buffer whose display caused the creation of this parameter. This function may delete &lt;var&gt;window&lt;/var&gt; if and only if it still shows that buffer.</source>
          <target state="translated">The fourth element is the buffer whose display caused the creation of this parameter. This function may delete &lt;var&gt;window&lt;/var&gt; if and only if it still shows that buffer.</target>
        </trans-unit>
        <trans-unit id="d53d197ac8b2d3804741dce6c2249997a484aa11" translate="yes" xml:space="preserve">
          <source>The fourth of these hooks is run when a &lt;em&gt;window state change&lt;/em&gt; has been detected, which means that at least one of the three preceding window changes has occurred.</source>
          <target state="translated">The fourth of these hooks is run when a &lt;em&gt;window state change&lt;/em&gt; has been detected, which means that at least one of the three preceding window changes has occurred.</target>
        </trans-unit>
        <trans-unit id="d2076a0c8c9f8876e127e6de37bf8d5c9fd0314f" translate="yes" xml:space="preserve">
          <source>The frame is displayed on a GNUstep or Macintosh Cocoa graphical terminal.</source>
          <target state="translated">The frame is displayed on a GNUstep or Macintosh Cocoa graphical terminal.</target>
        </trans-unit>
        <trans-unit id="367eb419b499e34c2cd9b561d4ff309824830d6d" translate="yes" xml:space="preserve">
          <source>The frame is displayed on a MS-Windows graphical terminal.</source>
          <target state="translated">The frame is displayed on a MS-Windows graphical terminal.</target>
        </trans-unit>
        <trans-unit id="bd7f603302ec782d1f108752979a4bc3b06f4239" translate="yes" xml:space="preserve">
          <source>The frame is displayed on a text terminal.</source>
          <target state="translated">The frame is displayed on a text terminal.</target>
        </trans-unit>
        <trans-unit id="fcb9d54a78150d03f883ce9267fb2578c072d2bd" translate="yes" xml:space="preserve">
          <source>The frame is displayed on an MS-DOS terminal.</source>
          <target state="translated">The frame is displayed on an MS-DOS terminal.</target>
        </trans-unit>
        <trans-unit id="0cd07edbb9f4b3175639e8806bf60c5f910fe981" translate="yes" xml:space="preserve">
          <source>The frame is displayed on an X graphical terminal.</source>
          <target state="translated">The frame is displayed on an X graphical terminal.</target>
        </trans-unit>
        <trans-unit id="fede82ee27758855ee100077f5a256f38ab0e02a" translate="yes" xml:space="preserve">
          <source>The frame parameter &lt;code&gt;horizontal-scroll-bars&lt;/code&gt; controls whether the windows in the frame have horizontal scroll bars. The frame parameter &lt;code&gt;scroll-bar-height&lt;/code&gt; specifies how high they are (&lt;code&gt;nil&lt;/code&gt; meaning the default). See &lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;Layout Parameters&lt;/a&gt;.</source>
          <target state="translated">The frame parameter &lt;code&gt;horizontal-scroll-bars&lt;/code&gt; controls whether the windows in the frame have horizontal scroll bars. The frame parameter &lt;code&gt;scroll-bar-height&lt;/code&gt; specifies how high they are ( &lt;code&gt;nil&lt;/code&gt; meaning the default). See &lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;Layout Parameters&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="438a2d89a52bbe188d6d849c93e8088d3f1e967a" translate="yes" xml:space="preserve">
          <source>The frame that this window is on, as a Lisp object.</source>
          <target state="translated">The frame that this window is on, as a Lisp object.</target>
        </trans-unit>
        <trans-unit id="f2ddf76bbb94fa6e3bd71370e008e9006e3aab9c" translate="yes" xml:space="preserve">
          <source>The frame with input focus might not take up the entire screen, and the user might move the mouse outside the scope of the frame. Inside the &lt;code&gt;track-mouse&lt;/code&gt; special form, that produces an event like this:</source>
          <target state="translated">입력 포커스가있는 프레임이 전체 화면을 차지하지 않을 수 있으며 사용자가 마우스를 프레임 범위 밖으로 이동할 수 있습니다. &lt;code&gt;track-mouse&lt;/code&gt; 특수 양식 내부에서 다음과 같은 이벤트를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="875b4545e11911510ae3368c34f49d2bafeade1c" translate="yes" xml:space="preserve">
          <source>The frames can be used either to represent multiple pages (this is usually the case with multi-frame TIFF files, for example), or to create animation (usually the case with multi-frame GIF files).</source>
          <target state="translated">프레임은 여러 페이지를 나타내거나 (일반적으로 다중 프레임 TIFF 파일의 경우) 애니메이션을 만드는 데 사용할 수 있습니다 (일반적으로 다중 프레임 GIF 파일의 경우).</target>
        </trans-unit>
        <trans-unit id="07c1bfad504d407e4dd4bddeff5e7e54de2cc8eb" translate="yes" xml:space="preserve">
          <source>The fringes normally appear between the display margins and the window text. If the value is non-&lt;code&gt;nil&lt;/code&gt;, they appear outside the display margins. See &lt;a href=&quot;display-margins#Display-Margins&quot;&gt;Display Margins&lt;/a&gt;.</source>
          <target state="translated">테두리는 일반적으로 디스플레이 여백과 창 텍스트 사이에 나타납니다. 값이 &lt;code&gt;nil&lt;/code&gt; 이 아니면 디스플레이 여백 밖에 나타납니다. &lt;a href=&quot;display-margins#Display-Margins&quot;&gt;여백 표시를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="10a232c8c99be2bcdac3d854a4c57a0b7926f249" translate="yes" xml:space="preserve">
          <source>The full keymap containing default global key bindings. Modes should not modify the Global map.</source>
          <target state="translated">기본 전역 키 바인딩을 포함하는 전체 키맵입니다. 모드는 글로벌 맵을 수정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="ab21d625fa99d9e8689a87a9df340768d973d686" translate="yes" xml:space="preserve">
          <source>The full name of the font, a string.</source>
          <target state="translated">글꼴의 전체 이름, 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="55c491134e3f247e07eb606aa328fc5be9cb20cc" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;accept-process-output&lt;/code&gt; returns non-&lt;code&gt;nil&lt;/code&gt; if it got output from &lt;var&gt;process&lt;/var&gt;, or from any process if &lt;var&gt;process&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;; this can occur even after a process has exited if the corresponding connection contains buffered data. The function returns &lt;code&gt;nil&lt;/code&gt; if the timeout expired or the connection was closed before output arrived.</source>
          <target state="translated">이 함수 &lt;code&gt;accept-process-output&lt;/code&gt; 을 반환 비 &lt;code&gt;nil&lt;/code&gt; 는 출력 얻으면 &lt;var&gt;process&lt;/var&gt; , 또는 모든 프로세스에서 경우 &lt;var&gt;process&lt;/var&gt; 입니다 &lt;code&gt;nil&lt;/code&gt; ; 이는 해당 연결에 버퍼링 된 데이터가 포함 된 경우 프로세스가 종료 된 후에도 발생할 수 있습니다. 시간 초과가 만료되었거나 출력이 도착하기 전에 연결이 닫혔 으면 함수는 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="ec51fe801ce783ab41bbcfb2b068eb8495fcb6f6" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;assoc-string&lt;/code&gt; is much like &lt;code&gt;assoc&lt;/code&gt; except that it ignores certain differences between strings. See &lt;a href=&quot;text-comparison#Text-Comparison&quot;&gt;Text Comparison&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;assoc-string&lt;/code&gt; 함수 는 문자열 간의 특정 차이점을 무시한다는 점을 제외하면 &lt;code&gt;assoc&lt;/code&gt; 과 매우 유사 합니다. &lt;a href=&quot;text-comparison#Text-Comparison&quot;&gt;텍스트 비교를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8f2e7d56e51665dc0e2c86ee380cef89f5612161" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;backtrace-frame&lt;/code&gt; is intended for use in Lisp debuggers. It returns information about what computation is happening in the stack frame &lt;var&gt;frame-number&lt;/var&gt; levels down.</source>
          <target state="translated">&lt;code&gt;backtrace-frame&lt;/code&gt; 함수 는 Lisp 디버거에서 사용하기위한 것입니다. 스택 프레임 &lt;var&gt;frame-number&lt;/var&gt; 수준 에서 발생하는 계산에 대한 정보를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="2a41471492f0d30da94cc86b34cd0a1d952ae5da" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;backward-prefix-chars&lt;/code&gt; moves back over these characters, as well as over characters whose primary syntax class is prefix (&amp;lsquo;</source>
          <target state="translated">&lt;code&gt;backward-prefix-chars&lt;/code&gt; 함수 는 이러한 문자뿐만 아니라 기본 구문 클래스가 접두사 ( ') 인 문자 위로 다시 이동합니다.</target>
        </trans-unit>
        <trans-unit id="ff9303e475f1b984abb99f23fe5e1bde3414024c" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;buffer-substring-no-properties&lt;/code&gt; does not call these functions, since it ignores text properties anyway.</source>
          <target state="translated">기능 &lt;code&gt;buffer-substring-no-properties&lt;/code&gt; 어쨌든 텍스트 속성을 무시하기 때문에,이 함수를 호출하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ab0ed3a952ff9a1871cc2361e3809682f2c953e2" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;collapse-delayed-warnings&lt;/code&gt; removes repeated entries from &lt;code&gt;delayed-warnings-list&lt;/code&gt;. The function &lt;code&gt;display-delayed-warnings&lt;/code&gt; calls &lt;code&gt;display-warning&lt;/code&gt; on each of the entries in &lt;code&gt;delayed-warnings-list&lt;/code&gt;, in turn, and then sets &lt;code&gt;delayed-warnings-list&lt;/code&gt; to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;collapse-delayed-warnings&lt;/code&gt; 함수 는 &lt;code&gt;delayed-warnings-list&lt;/code&gt; 에서 반복되는 항목을 제거 합니다 . &lt;code&gt;display-delayed-warnings&lt;/code&gt; 함수 는 &lt;code&gt;delayed-warnings-list&lt;/code&gt; 의 각 항목에 대해 &lt;code&gt;display-warning&lt;/code&gt; 을 차례로 호출 한 다음 &lt;code&gt;delayed-warnings-list&lt;/code&gt; 를 &lt;code&gt;nil&lt;/code&gt; 로 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="aca3a04eca1514a9f44c05fb78a24a6564571ff6" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;completing-read&lt;/code&gt; provides a higher-level interface for completion. A call to &lt;code&gt;completing-read&lt;/code&gt; specifies how to determine the list of valid names. The function then activates the minibuffer with a local keymap that binds a few keys to commands useful for completion. Other functions provide convenient simple interfaces for reading certain kinds of names with completion.</source>
          <target state="translated">&lt;code&gt;completing-read&lt;/code&gt; 기능은 완료를 위한 상위 레벨 인터페이스를 제공합니다. &lt;code&gt;completing-read&lt;/code&gt; 호출 은 유효한 이름 목록을 결정하는 방법을 지정합니다. 그런 다음이 함수는 완료에 유용한 명령에 몇 개의 키를 바인딩하는 로컬 키맵을 사용하여 미니 버퍼를 활성화합니다. 다른 함수는 완성 된 특정 종류의 이름을 읽을 수있는 편리한 간단한 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="743a6545ecb435ebd9f3de6185649c8ee66cb997" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;completing-read&lt;/code&gt; uses &lt;code&gt;minibuffer-local-completion-map&lt;/code&gt; as the keymap if &lt;var&gt;require-match&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, and uses &lt;code&gt;minibuffer-local-must-match-map&lt;/code&gt; if &lt;var&gt;require-match&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;. See &lt;a href=&quot;completion-commands#Completion-Commands&quot;&gt;Completion Commands&lt;/a&gt;.</source>
          <target state="translated">기능 &lt;code&gt;completing-read&lt;/code&gt; 용도는 &lt;code&gt;minibuffer-local-completion-map&lt;/code&gt; 경우 키 맵으로 &lt;var&gt;require-match&lt;/var&gt; 있다 &lt;code&gt;nil&lt;/code&gt; , 그리고 사용은 &lt;code&gt;minibuffer-local-must-match-map&lt;/code&gt; 하는 경우 &lt;var&gt;require-match&lt;/var&gt; 비입니다 &lt;code&gt;nil&lt;/code&gt; . &lt;a href=&quot;completion-commands#Completion-Commands&quot;&gt;완료 명령을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="eb114701d962dcc2e639c63a654e62af9ffd7c5a" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;coordinates-in-window-p&lt;/code&gt; does not require a frame as argument because it always uses the frame that &lt;var&gt;window&lt;/var&gt; is on.</source>
          <target state="translated">&lt;code&gt;coordinates-in-window-p&lt;/code&gt; 함수 는 항상 &lt;var&gt;window&lt;/var&gt; 있는 프레임을 사용하기 때문에 인수로 프레임이 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d5b3ded67b9cd070ced5aa2445c9069b81dfc417" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;current-kill&lt;/code&gt; rotates the yanking pointer, which designates the front of the kill ring, by &lt;var&gt;n&lt;/var&gt; places (from newer kills to older ones), and returns the text at that place in the ring.</source>
          <target state="translated">&lt;code&gt;current-kill&lt;/code&gt; 함수 는 킬 링의 앞을 지정하는 yanking 포인터를 &lt;var&gt;n&lt;/var&gt; 자리 (최신 킬에서 이전 킬로)만큼 회전시키고 링의 해당 위치에 텍스트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c09d1b87df08862239116751f48f0df4995d72f7" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;default-boundp&lt;/code&gt; tells you whether &lt;var&gt;symbol&lt;/var&gt;&amp;rsquo;s default value is nonvoid. If &lt;code&gt;(default-boundp 'foo)&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt;, then &lt;code&gt;(default-value 'foo)&lt;/code&gt; would get an error.</source>
          <target state="translated">&lt;code&gt;default-boundp&lt;/code&gt; 함수 는 &lt;var&gt;symbol&lt;/var&gt; 의 기본값이 void가 아닌지 여부를 알려줍니다 . 경우 &lt;code&gt;(default-boundp 'foo)&lt;/code&gt; 반환 &lt;code&gt;nil&lt;/code&gt; 을 , 다음 &lt;code&gt;(default-value 'foo)&lt;/code&gt; 오류가 발생하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3d944e42054c18a15837fce5fb4f736d90edcbfc" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;delete-other-windows&lt;/code&gt; (see &lt;a href=&quot;deleting-windows#Deleting-Windows&quot;&gt;Deleting Windows&lt;/a&gt;), when applied to a constituent of an atomic window, will try to make the atomic window fill its frame or main window (see &lt;a href=&quot;side-windows#Side-Windows&quot;&gt;Side Windows&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;delete-other-windows&lt;/code&gt; 함수 ( 창 &lt;a href=&quot;deleting-windows#Deleting-Windows&quot;&gt;삭제&lt;/a&gt; 참조 )는 원자 창의 구성 요소에 적용될 때 원자 창이 프레임 또는 기본 창을 채우도록 시도합니다 ( &lt;a href=&quot;side-windows#Side-Windows&quot;&gt;사이드&lt;/a&gt; 창 참조 ).</target>
        </trans-unit>
        <trans-unit id="9dffa9767ac8103870c396df1d01712edad9731f" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;delete-window&lt;/code&gt; (see &lt;a href=&quot;deleting-windows#Deleting-Windows&quot;&gt;Deleting Windows&lt;/a&gt;), when applied to a constituent of an atomic window, will try to delete the entire atomic window instead.</source>
          <target state="translated">&lt;code&gt;delete-window&lt;/code&gt; 함수 ( 창 &lt;a href=&quot;deleting-windows#Deleting-Windows&quot;&gt;삭제&lt;/a&gt; 참조 )는 원자 창의 구성 요소에 적용될 때 전체 원자 창을 대신 삭제하려고합니다.</target>
        </trans-unit>
        <trans-unit id="6dbf1bcd36e45950ad0668297034db25fc20918d" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;elt&lt;/code&gt; is similar, but applies to any kind of sequence. For historical reasons, it takes its arguments in the opposite order. See &lt;a href=&quot;sequence-functions#Sequence-Functions&quot;&gt;Sequence Functions&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;elt&lt;/code&gt; 함수 는 비슷하지만 모든 종류의 시퀀스에 적용됩니다. 역사적 이유로, 그것은 반대 순서로 주장을합니다. &lt;a href=&quot;sequence-functions#Sequence-Functions&quot;&gt;시퀀스 함수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="53ea0623909a1543789ee0d4705170a49f5a1097" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;equal&lt;/code&gt; can also compare two window configurations; it regards configurations as unequal if they differ in any respect, even a saved point.</source>
          <target state="translated">&lt;code&gt;equal&lt;/code&gt; 함수 는 두 개의 창 구성을 비교할 수도 있습니다. 저장된 지점을 포함하여 어떤 측면에서든 다른 경우 구성이 동일하지 않은 것으로 간주합니다.</target>
        </trans-unit>
        <trans-unit id="15f22c5a8ef685b2d1157d55627f2e569a64550a" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;foo&lt;/code&gt; subtracts &lt;var&gt;integer1&lt;/var&gt; from &lt;var&gt;integer2&lt;/var&gt;, then adds all the rest of the arguments to the result. If &lt;var&gt;integer2&lt;/var&gt; is not supplied, then the number 19 is used by default.</source>
          <target state="translated">&lt;code&gt;foo&lt;/code&gt; 함수 는 &lt;var&gt;integer2&lt;/var&gt; 에서 &lt;var&gt;integer1&lt;/var&gt; 을 뺀 다음 나머지 인수를 모두 결과에 더합니다. 경우 &lt;var&gt;integer2&lt;/var&gt; 제공되지 않으면 다음 수 (19)가 기본적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="142092b37bd14d5b1415337e59a8ef7820027ffe" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;format-spec&lt;/code&gt; described in this section performs a similar function to &lt;code&gt;format&lt;/code&gt;, except it operates on format control strings that use arbitrary specification characters.</source>
          <target state="translated">이 섹션에서 설명 하는 함수 &lt;code&gt;format-spec&lt;/code&gt; 은 임의의 사양 문자를 사용하는 형식 제어 문자열에서 작동한다는 점을 제외하면 &lt;code&gt;format&lt;/code&gt; 과 유사한 기능을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="580c556614ef2beffd862c0457ca3264d0d95fa2" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;frame-parameters&lt;/code&gt; returns an alist listing all the parameters of &lt;var&gt;frame&lt;/var&gt; and their values. If &lt;var&gt;frame&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; or omitted, this returns the selected frame&amp;rsquo;s parameters</source>
          <target state="translated">기능 &lt;code&gt;frame-parameters&lt;/code&gt; 반환은 alist의 모든 매개 변수 목록 &lt;var&gt;frame&lt;/var&gt; 과 그 값을. 경우 &lt;var&gt;frame&lt;/var&gt; 입니다 &lt;code&gt;nil&lt;/code&gt; 또는 생략이 반환 선택한 프레임의 매개 변수</target>
        </trans-unit>
        <trans-unit id="fc4daa549e176d014e533dbad29a89e4b64d4d76" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;getx&lt;/code&gt; refers to &lt;code&gt;x&lt;/code&gt;. This is a &lt;em&gt;free&lt;/em&gt; reference, in the sense that there is no binding for &lt;code&gt;x&lt;/code&gt; within that &lt;code&gt;defun&lt;/code&gt; construct itself. When we call &lt;code&gt;getx&lt;/code&gt; from within a &lt;code&gt;let&lt;/code&gt; form in which &lt;code&gt;x&lt;/code&gt; is (dynamically) bound, it retrieves the local value (i.e., 1). But when we call &lt;code&gt;getx&lt;/code&gt; outside the &lt;code&gt;let&lt;/code&gt; form, it retrieves the global value (i.e., -99).</source>
          <target state="translated">&lt;code&gt;getx&lt;/code&gt; 함수 는 &lt;code&gt;x&lt;/code&gt; 를 참조합니다 . 이것은 &lt;code&gt;defun&lt;/code&gt; 구조 자체 내에 &lt;code&gt;x&lt;/code&gt; 에 대한 바인딩이 없다는 의미에서 &lt;em&gt;무료&lt;/em&gt; 참조 입니다. &lt;code&gt;x&lt;/code&gt; 가 (동적으로) 바인딩 된 &lt;code&gt;let&lt;/code&gt; 형식 내에서 &lt;code&gt;getx&lt;/code&gt; 를 호출 하면 로컬 값 (즉, 1)을 검색합니다. 그러나 &lt;code&gt;let&lt;/code&gt; 양식 외부에서 &lt;code&gt;getx&lt;/code&gt; 를 호출 하면 전역 값 (즉, -99)을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="e222099e0dbd9ca9d8f1867678a5de58c410df4b" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;insert-file-contents&lt;/code&gt; automatically recognizes file formats when it reads the specified file. It checks the text of the beginning of the file against the regular expressions of the format definitions, and if it finds a match, it calls the decoding function for that format. Then it checks all the known formats over again. It keeps checking them until none of them is applicable.</source>
          <target state="translated">&lt;code&gt;insert-file-contents&lt;/code&gt; 함수 는 지정된 파일을 읽을 때 파일 형식을 자동으로 인식합니다. 형식 정의의 정규식에 대해 파일 시작 부분의 텍스트를 확인하고 일치하는 항목을 찾으면 해당 형식에 대한 디코딩 함수를 호출합니다. 그런 다음 알려진 모든 형식을 다시 확인합니다. 적용 가능한 항목이 없을 때까지 계속 확인합니다.</target>
        </trans-unit>
        <trans-unit id="1b53622592c53b4408af724ef50deb90f84d0660" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;insert-file-contents&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;insert-file-contents&lt;/code&gt; 함수 :</target>
        </trans-unit>
        <trans-unit id="0ced44529508f6a3572121eaa375fc4ced75820b" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;insert-for-yank&lt;/code&gt; automatically sets this variable according to the &lt;var&gt;undo&lt;/var&gt; element of the &lt;code&gt;yank-handler&lt;/code&gt; text property, if there is one.</source>
          <target state="translated">&lt;code&gt;insert-for-yank&lt;/code&gt; 함수 는 &lt;code&gt;yank-handler&lt;/code&gt; 텍스트 속성 의 &lt;var&gt;undo&lt;/var&gt; 요소 (있는 경우)에 따라이 변수를 자동으로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="63c67cfe6f9d58e7894dfaf98f9e257cab3b6ab1" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;kill-all-local-variables&lt;/code&gt; runs this normal hook before it does anything else. This gives major modes a way to arrange for something special to be done if the user switches to a different major mode. It is also useful for buffer-specific minor modes that should be forgotten if the user changes the major mode.</source>
          <target state="translated">&lt;code&gt;kill-all-local-variables&lt;/code&gt; 함수 는 다른 작업을 수행하기 전에이 정상적인 후크를 실행합니다. 이렇게하면 사용자가 다른 주 모드로 전환 할 때 수행 할 특별한 작업을 정렬하는 방법을 주 모드에 제공합니다. 또한 사용자가 주 모드를 변경하면 잊어 버려야하는 버퍼 별 부 모드에도 유용합니다.</target>
        </trans-unit>
        <trans-unit id="db6ce2dd6e8f67ccadb8ee5dc896d171a780cbcc" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;macroexpand&lt;/code&gt; does not expand calls to inline functions. Normally there is no need for that, since a call to an inline function is no harder to understand than a call to an ordinary function.</source>
          <target state="translated">&lt;code&gt;macroexpand&lt;/code&gt; 함수 는 인라인 함수에 대한 호출을 확장 하지 않습니다. 인라인 함수에 대한 호출이 일반 함수에 대한 호출보다 이해하기 더 어렵지 않기 때문에 일반적으로 그럴 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="8ca63acdedc01018b5b5ff8ef5fd299f693dc141" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;map-keymap&lt;/code&gt; calls &lt;var&gt;function&lt;/var&gt; once for each binding in &lt;var&gt;keymap&lt;/var&gt;. It passes two arguments, the event type and the value of the binding. If &lt;var&gt;keymap&lt;/var&gt; has a parent, the parent&amp;rsquo;s bindings are included as well. This works recursively: if the parent has itself a parent, then the grandparent&amp;rsquo;s bindings are also included and so on.</source>
          <target state="translated">함수 &lt;code&gt;map-keymap&lt;/code&gt; 통화 &lt;var&gt;function&lt;/var&gt; 에 결합 각각에 대해 한 번 &lt;var&gt;keymap&lt;/var&gt; . 이벤트 유형과 바인딩 값이라는 두 개의 인수를 전달합니다. &lt;var&gt;keymap&lt;/var&gt; 에 부모가 있으면 부모의 바인딩도 포함됩니다. 이것은 재귀 적으로 작동합니다. 부모가 부모를 가지고 있다면 조부모의 바인딩도 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="4993f97cab68094466e932cb10bb5175cf66f558" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;mapbacktrace&lt;/code&gt; calls &lt;var&gt;function&lt;/var&gt; once for each frame in the backtrace, starting at the first frame whose function is &lt;var&gt;base&lt;/var&gt; (or from the top if &lt;var&gt;base&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt;).</source>
          <target state="translated">함수 &lt;code&gt;mapbacktrace&lt;/code&gt; 의 통화 &lt;var&gt;function&lt;/var&gt; 가진 함수의 첫 번째 프레임에서 시작하여, 역 추적 각 프레임에 대해 한 번 &lt;var&gt;base&lt;/var&gt; (또는 경우 위에서 &lt;var&gt;base&lt;/var&gt; 생략 또는 &lt;code&gt;nil&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ccd658c08c200f4281112668bf7e651adc648cfe" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;member&lt;/code&gt; tests to see whether &lt;var&gt;object&lt;/var&gt; is a member of &lt;var&gt;list&lt;/var&gt;, comparing members with &lt;var&gt;object&lt;/var&gt; using &lt;code&gt;equal&lt;/code&gt;. If &lt;var&gt;object&lt;/var&gt; is a member, &lt;code&gt;member&lt;/code&gt; returns a list starting with its first occurrence in &lt;var&gt;list&lt;/var&gt;. Otherwise, it returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">함수 &lt;code&gt;member&lt;/code&gt; 는 &lt;code&gt;equal&lt;/code&gt; 을 사용 하여 멤버와 &lt;var&gt;object&lt;/var&gt; 를 비교하여 &lt;var&gt;object&lt;/var&gt; 가 &lt;var&gt;list&lt;/var&gt; 의 멤버 인지 여부를 테스트합니다 . 경우 &lt;var&gt;object&lt;/var&gt; 구성원 인 &lt;code&gt;member&lt;/code&gt; 에 처음 발생로 시작하는 목록을 반환 &lt;var&gt;list&lt;/var&gt; . 그렇지 않으면 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="836706fff80e951f88d58f54e4d11838289bf1e2" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;memql&lt;/code&gt; tests to see whether &lt;var&gt;object&lt;/var&gt; is a member of &lt;var&gt;list&lt;/var&gt;, comparing members with &lt;var&gt;object&lt;/var&gt; using &lt;code&gt;eql&lt;/code&gt;, so floating-point elements are compared by value. If &lt;var&gt;object&lt;/var&gt; is a member, &lt;code&gt;memql&lt;/code&gt; returns a list starting with its first occurrence in &lt;var&gt;list&lt;/var&gt;. Otherwise, it returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;memql&lt;/code&gt; 함수 는 &lt;var&gt;object&lt;/var&gt; 가 &lt;var&gt;list&lt;/var&gt; 의 멤버 인지 여부를 테스트 하여 &lt;code&gt;eql&lt;/code&gt; 을 사용 하여 멤버와 &lt;var&gt;object&lt;/var&gt; 를 비교 하므로 부동 소수점 요소가 값으로 비교됩니다. 경우 &lt;var&gt;object&lt;/var&gt; 구성원 인 &lt;code&gt;memql&lt;/code&gt; 는 에 처음 발생로 시작하는 목록을 반환 &lt;var&gt;list&lt;/var&gt; . 그렇지 않으면 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="2086c23f1633b32f5d281ae45401849ef50ca00d" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;process-type&lt;/code&gt; returns the symbol &lt;code&gt;serial&lt;/code&gt; for a process object representing a serial port connection.</source>
          <target state="translated">&lt;code&gt;process-type&lt;/code&gt; 함수 는 직렬 포트 연결을 나타내는 프로세스 객체에 대한 &lt;code&gt;serial&lt;/code&gt; 기호를 반환합니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
