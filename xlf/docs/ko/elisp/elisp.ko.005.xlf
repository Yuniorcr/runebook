<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="elisp">
    <body>
      <group id="elisp">
        <trans-unit id="3a21eefa10a38bebd685a041bc883db13a690f78" translate="yes" xml:space="preserve">
          <source>A sparse keymap used by buttons.</source>
          <target state="translated">버튼에 사용되는 희소 키맵입니다.</target>
        </trans-unit>
        <trans-unit id="7a6d924c29a314704225148c6f1e8e4dd9598ef6" translate="yes" xml:space="preserve">
          <source>A sparse keymap used for responses in &lt;code&gt;query-replace&lt;/code&gt; and related commands; also for &lt;code&gt;y-or-n-p&lt;/code&gt; and &lt;code&gt;map-y-or-n-p&lt;/code&gt;. The functions that use this map do not support prefix keys; they look up one event at a time. &lt;code&gt;multi-query-replace-map&lt;/code&gt; extends &lt;code&gt;query-replace-map&lt;/code&gt; for multi-buffer replacements. See &lt;a href=&quot;search-and-replace#Search-and-Replace&quot;&gt;query-replace-map&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;query-replace&lt;/code&gt; 및 관련 명령의 응답에 사용되는 희소 키맵입니다 . 또한 &lt;code&gt;y-or-n-p&lt;/code&gt; 및 &lt;code&gt;map-y-or-n-p&lt;/code&gt; . 이 맵을 사용하는 기능은 접두사 키를 지원하지 않습니다. 한 번에 하나의 이벤트를 조회합니다. &lt;code&gt;multi-query-replace-map&lt;/code&gt; 은 다중 버퍼 교체를 위해 query-replace-map을 확장 &lt;code&gt;query-replace-map&lt;/code&gt; . &lt;a href=&quot;search-and-replace#Search-and-Replace&quot;&gt;query-replace-map을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2273ae4dbb377e2aa911010dd8b2da0b64c40b7c" translate="yes" xml:space="preserve">
          <source>A sparse keymap used for the</source>
          <target state="translated">에 사용되는 희소 키맵</target>
        </trans-unit>
        <trans-unit id="7144fe372d5198217578856f61ea2cf40f8209ff" translate="yes" xml:space="preserve">
          <source>A sparse keymap used to map certain keys under graphical frames. The function &lt;code&gt;x-setup-function-keys&lt;/code&gt; uses this.</source>
          <target state="translated">그래픽 프레임에서 특정 키를 매핑하는 데 사용되는 희소 키맵입니다. 함수 &lt;code&gt;x-setup-function-keys&lt;/code&gt; 이를 사용한다.</target>
        </trans-unit>
        <trans-unit id="88e891a88be3fe4e62330f9bb2210843e83520a9" translate="yes" xml:space="preserve">
          <source>A sparse keymap used while processing</source>
          <target state="translated">처리하는 동안 사용되는 희소 키맵</target>
        </trans-unit>
        <trans-unit id="765649c4f2ad56ec8ad2f598cca04c9ff7b7da2a" translate="yes" xml:space="preserve">
          <source>A sparse keymap useful for buffers containing buffers. You may want to use this as a parent keymap. See &lt;a href=&quot;buttons#Buttons&quot;&gt;Buttons&lt;/a&gt;.</source>
          <target state="translated">버퍼를 포함하는 버퍼에 유용한 희소 키맵입니다. 이것을 부모 키맵으로 사용할 수 있습니다. &lt;a href=&quot;buttons#Buttons&quot;&gt;버튼을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5f4ac56519c11e0fe0577b1cad8ce3bbe4207fc9" translate="yes" xml:space="preserve">
          <source>A special feature allows you to specify expressions to evaluate if and when a file is loaded (see &lt;a href=&quot;hooks-for-loading#Hooks-for-Loading&quot;&gt;Hooks for Loading&lt;/a&gt;). That feature is not exactly a hook, but does a similar job.</source>
          <target state="translated">특수 기능을 사용하면 파일로드 여부와시기를 평가하는 표현식을 지정할 수 있습니다 ( &lt;a href=&quot;hooks-for-loading#Hooks-for-Loading&quot;&gt;Hooks for Loading&lt;/a&gt; 참조 ). 이 기능은 정확히 훅이 아니지만 유사한 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="5be02abf64fa9f6d03c8545ca5b0ef5253cf8321" translate="yes" xml:space="preserve">
          <source>A special kind of key binding can be used to &lt;em&gt;remap&lt;/em&gt; one command to another, without having to refer to the key sequence(s) bound to the original command. To use this feature, make a key binding for a key sequence that starts with the dummy event &lt;code&gt;remap&lt;/code&gt;, followed by the command name you want to remap; for the binding, specify the new definition (usually a command name, but possibly any other valid definition for a key binding).</source>
          <target state="translated">원래 명령에 바인딩 된 키 시퀀스를 참조 할 필요없이 특별한 종류의 키 바인딩을 사용하여 한 명령을 다른 명령 에 &lt;em&gt;다시 매핑&lt;/em&gt; 할 수 있습니다 . 이 기능을 사용하려면 더미 이벤트 &lt;code&gt;remap&lt;/code&gt; 으로 시작하는 키 시퀀스에 대한 키 바인딩을 만들고 그 뒤에 다시 매핑하려는 명령 이름을 만듭니다 . 바인딩의 경우 새 정의 (일반적으로 명령 이름이지만 키 바인딩에 대한 다른 유효한 정의)를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="b3b13190b49396edf46334298af39e2a2e3045a9" translate="yes" xml:space="preserve">
          <source>A specially constructed list.</source>
          <target state="translated">특별히 구성된 목록입니다.</target>
        </trans-unit>
        <trans-unit id="cdeb8b40b772b9f3c7e2c98e3c8b8dec4698471b" translate="yes" xml:space="preserve">
          <source>A specification can have a &lt;em&gt;width&lt;/em&gt;, which is a decimal number that appears after any field number and flags. If the printed representation of the object contains fewer characters than this width, &lt;code&gt;format&lt;/code&gt; extends it with padding. Any padding introduced by the width normally consists of spaces inserted on the left:</source>
          <target state="translated">사양에는 필드 번호 및 플래그 뒤에 나타나는 10 진수 인 &lt;em&gt;width&lt;/em&gt; 가있을 수 있습니다 . 개체의 인쇄 된 표현에이 너비보다 적은 문자가 포함 된 경우 &lt;code&gt;format&lt;/code&gt; 은 패딩을 사용하여 확장합니다. 너비에 의해 도입 된 패딩은 일반적으로 왼쪽에 삽입 된 공백으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="fffe787c50a5092035410b47c5d5ac737f027fa9" translate="yes" xml:space="preserve">
          <source>A specification list may contain sublists, which match arguments that are themselves lists, or it may contain vectors used for grouping. Sublists and groups thus subdivide the specification list into a hierarchy of levels. Specification keywords apply only to the remainder of the sublist or group they are contained in.</source>
          <target state="translated">사양 목록에는 자체 목록 인 인수와 일치하는 하위 목록이 포함되거나 그룹화에 사용되는 벡터가 포함될 수 있습니다. 따라서 하위 목록과 그룹은 사양 목록을 수준의 계층 구조로 세분화합니다. 사양 키워드는 포함 된 하위 목록 또는 그룹의 나머지 부분에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="9468aabf9aff18dfe4927c4df0cf6ef94a873fcf" translate="yes" xml:space="preserve">
          <source>A string as a mode line construct appears verbatim except for &lt;em&gt;&lt;code&gt;%&lt;/code&gt;-constructs&lt;/em&gt; in it. These stand for substitution of other data; see &lt;a href=&quot;_0025_002dconstructs#g_t_0025_002dConstructs&quot;&gt;%-Constructs&lt;/a&gt;.</source>
          <target state="translated">모드 라인 구조로서의 문자열은 &lt;em&gt; &lt;code&gt;%&lt;/code&gt; -constructs&lt;/em&gt; 를 제외하고 그대로 나타납니다 . 이는 다른 데이터의 대체를 의미합니다. &lt;a href=&quot;_0025_002dconstructs#g_t_0025_002dConstructs&quot;&gt;% -Constructs&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="2532fec68eb63f66911855847dedf967f8f81556" translate="yes" xml:space="preserve">
          <source>A string as input will be used directly. It may be modified by the function (unlike most other Emacs Lisp functions) to reduce the chance of exposing sensitive data after the function does its work.</source>
          <target state="translated">입력 문자열은 직접 사용됩니다. (대부분의 다른 Emacs Lisp 함수와는 달리) 함수에 의해 수정되어 함수가 작동 한 후 민감한 데이터가 노출 될 가능성을 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8bebc2f246c21ea650e3cb3ac8fe99ed1f62459" translate="yes" xml:space="preserve">
          <source>A string can hold properties for the characters it contains, in addition to the characters themselves. This enables programs that copy text between strings and buffers to copy the text&amp;rsquo;s properties with no special effort. See &lt;a href=&quot;text-properties#Text-Properties&quot;&gt;Text Properties&lt;/a&gt;, for an explanation of what text properties mean. Strings with text properties use a special read and print syntax:</source>
          <target state="translated">문자열은 문자 자체뿐 아니라 포함 된 문자에 대한 속성을 보유 할 수 있습니다. 이를 통해 문자열과 버퍼간에 텍스트를 복사하는 프로그램이 특별한 노력없이 텍스트의 속성을 복사 할 수 있습니다. 텍스트 속성의 의미에 대한 설명은 &lt;a href=&quot;text-properties#Text-Properties&quot;&gt;텍스트 속성을&lt;/a&gt; 참조하십시오 . 텍스트 속성이있는 문자열은 특수 읽기 및 인쇄 구문을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="dfef331cf99173b597cb3a4f9ebbdb7c1f294c0a" translate="yes" xml:space="preserve">
          <source>A string containing the same byte sequence as an XBM file would contain. You must not specify &lt;code&gt;:height&lt;/code&gt; and &lt;code&gt;:width&lt;/code&gt; in this case, because omitting them is what indicates the data has the format of an XBM file. The file contents specify the height and width of the image.</source>
          <target state="translated">XBM 파일과 동일한 바이트 시퀀스를 포함하는 문자열이 포함됩니다. 이 경우 &lt;code&gt;:height&lt;/code&gt; 및 &lt;code&gt;:width&lt;/code&gt; 를 지정하지 않아야합니다 . 생략하면 데이터가 XBM 파일 형식을 가짐을 나타 내기 때문입니다. 파일 내용은 이미지의 높이와 너비를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="b80138eb0e7d2ee11a5334072539786172a5e2bd" translate="yes" xml:space="preserve">
          <source>A string displayed by the Emacs tooltip help system; by default, &lt;code&gt;&quot;mouse-2, RET: Push this button&quot;&lt;/code&gt;. Alternatively, a function that returns, or a form that evaluates to, a string to be displayed or &lt;code&gt;nil&lt;/code&gt;. For details see &lt;a href=&quot;special-properties#Text-help_002decho&quot;&gt;Text help-echo&lt;/a&gt;.</source>
          <target state="translated">Emacs 툴팁 도움말 시스템에서 표시하는 문자열입니다. 기본적으로 &lt;code&gt;&quot;mouse-2, RET: Push this button&quot;&lt;/code&gt; . 또는 반환하는 함수 또는 표시 할 문자열 또는 &lt;code&gt;nil&lt;/code&gt; 로 평가되는 양식 . 자세한 내용은 &lt;a href=&quot;special-properties#Text-help_002decho&quot;&gt;Text help-echo&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7e28e179ae46e636da2eca587a2ddde99c5d0cd9" translate="yes" xml:space="preserve">
          <source>A string in Emacs Lisp is an array that contains an ordered sequence of characters. Strings are used as names of symbols, buffers, and files; to send messages to users; to hold text being copied between buffers; and for many other purposes. Because strings are so important, Emacs Lisp has many functions expressly for manipulating them. Emacs Lisp programs use strings more often than individual characters.</source>
          <target state="translated">Emacs Lisp의 문자열은 순서가 지정된 문자 시퀀스를 포함하는 배열입니다. 문자열은 기호, 버퍼 및 파일의 이름으로 사용됩니다. 사용자에게 메시지 보내기 버퍼 사이에 복사되는 텍스트를 보관합니다. 그리고 다른 많은 목적을 위해. 문자열이 매우 중요하기 때문에 Emacs Lisp는 문자열을 조작하기위한 많은 기능을 가지고 있습니다. Emacs Lisp 프로그램은 개별 문자보다 문자열을 더 자주 사용합니다.</target>
        </trans-unit>
        <trans-unit id="97d89176884a6777ab0a93f14e9b3cf203593d01" translate="yes" xml:space="preserve">
          <source>A string is a fixed sequence of characters. It is a type of sequence called a &lt;em&gt;array&lt;/em&gt;, meaning that its length is fixed and cannot be altered once it is created (see &lt;a href=&quot;sequences-arrays-vectors#Sequences-Arrays-Vectors&quot;&gt;Sequences Arrays Vectors&lt;/a&gt;). Unlike in C, Emacs Lisp strings are &lt;em&gt;not&lt;/em&gt; terminated by a distinguished character code.</source>
          <target state="translated">문자열은 고정 된 문자 시퀀스입니다. 이는 &lt;em&gt;배열&lt;/em&gt; 이라고하는 시퀀스 유형입니다. 즉, 길이가 고정되어 있고 생성 된 후에는 변경할 수 없습니다 ( &lt;a href=&quot;sequences-arrays-vectors#Sequences-Arrays-Vectors&quot;&gt;Sequences Arrays Vectors&lt;/a&gt; 참조 ). C와 달리 Emacs Lisp 문자열은 고유 문자 코드로 종료 &lt;em&gt;되지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="fe9aa772c2d97bd3d2707cc2379051eb1e145422" translate="yes" xml:space="preserve">
          <source>A string is an array of characters and a vector is an array of arbitrary objects. A bool-vector can hold only &lt;code&gt;t&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;. These kinds of array may have any length up to the largest fixnum, subject to system architecture limits and available memory. Char-tables are sparse arrays indexed by any valid character code; they can hold arbitrary objects.</source>
          <target state="translated">문자열은 문자의 배열이고 벡터는 임의의 객체의 배열입니다. 부울 벡터는 &lt;code&gt;t&lt;/code&gt; 또는 &lt;code&gt;nil&lt;/code&gt; 만 보유 할 수 있습니다 . 이러한 종류의 어레이는 시스템 아키텍처 제한 및 사용 가능한 메모리에 따라 최대 고정 번호까지의 길이를 가질 수 있습니다. Char-table은 유효한 문자 코드로 색인 된 희소 배열입니다. 임의의 개체를 보유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2441898090949c6885e0d3b806fb9b48c4944a10" translate="yes" xml:space="preserve">
          <source>A string is text saved in the register.</source>
          <target state="translated">문자열은 레지스터에 저장된 텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="49f6b3f288e48e7a1e61f7ccbc7a20aa90fb1620" translate="yes" xml:space="preserve">
          <source>A string or a bool-vector containing the bits of the image (plus perhaps some extra bits at the end that will not be used). It should contain at least &lt;code&gt;&lt;var&gt;stride&lt;/var&gt;&amp;nbsp;*&amp;nbsp;&lt;var&gt;height&lt;/var&gt;&lt;/code&gt; bits, where &lt;var&gt;stride&lt;/var&gt; is the smallest multiple of 8 greater than or equal to the width of the image. In this case, you should specify &lt;code&gt;:height&lt;/code&gt;, &lt;code&gt;:width&lt;/code&gt; and &lt;code&gt;:stride&lt;/code&gt;, both to indicate that the string contains just the bits rather than a whole XBM file, and to specify the size of the image.</source>
          <target state="translated">이미지의 비트를 포함하는 문자열 또는 부울 벡터 (사용되지 않는 끝에 추가 비트가 추가 될 수 있음). &lt;code&gt;&lt;var&gt;stride&lt;/var&gt;&amp;nbsp;*&amp;nbsp;&lt;var&gt;height&lt;/var&gt;&lt;/code&gt; 비트 이상을 포함해야합니다 . 여기서 &lt;var&gt;stride&lt;/var&gt; 는 이미지 너비보다 크거나 같은 8의 가장 작은 배수입니다. 이 경우 &lt;code&gt;:height&lt;/code&gt; , &lt;code&gt;:width&lt;/code&gt; 및 &lt;code&gt;:stride&lt;/code&gt; 를 지정하여 문자열에 전체 XBM 파일이 아닌 비트 만 포함됨을 표시하고 이미지의 크기를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="036a59e22e9f954ee65be3ccd2c0ddd139f906a5" translate="yes" xml:space="preserve">
          <source>A string or vector as &lt;var&gt;command&lt;/var&gt; is executed with &lt;code&gt;execute-kbd-macro&lt;/code&gt;. A function is passed to &lt;code&gt;call-interactively&lt;/code&gt; (see above), along with the &lt;var&gt;record-flag&lt;/var&gt; and &lt;var&gt;keys&lt;/var&gt; arguments.</source>
          <target state="translated">&lt;var&gt;command&lt;/var&gt; 으로서의 문자열 또는 벡터 는 &lt;code&gt;execute-kbd-macro&lt;/code&gt; 로 실행 됩니다. 함수는 &lt;var&gt;record-flag&lt;/var&gt; 및 &lt;var&gt;keys&lt;/var&gt; 인수 와 함께 &lt;code&gt;call-interactively&lt;/code&gt; (위 참조) 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="fb505d9a7d4b3f1a25ce86b9d3dae98375c606b2" translate="yes" xml:space="preserve">
          <source>A string starting with two or more dashes specifies a separator line; see &lt;a href=&quot;menu-separators#Menu-Separators&quot;&gt;Menu Separators&lt;/a&gt;.</source>
          <target state="translated">두 개 이상의 대시로 시작하는 문자열은 구분선을 지정합니다. &lt;a href=&quot;menu-separators#Menu-Separators&quot;&gt;메뉴 구분 기호를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="45afeec22e5b1392a38afb3af0c622aa891ec190" translate="yes" xml:space="preserve">
          <source>A string that gives the repository branch from which Emacs was built. In the most cases this is &lt;code&gt;&quot;master&quot;&lt;/code&gt;. If Emacs was built outside revision control, the value is &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Emacs가 구축 된 저장소 브랜치를 제공하는 문자열. 대부분의 경우 이것은 &lt;code&gt;&quot;master&quot;&lt;/code&gt; 입니다. Emacs가 개정 제어 외부에서 빌드 된 경우 값은 &lt;code&gt;nil&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a176c29cb00e1ce1efdc8fd4de377dd60ec1aa7c" translate="yes" xml:space="preserve">
          <source>A string that gives the repository revision from which Emacs was built. If Emacs was built outside revision control, the value is &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Emacs가 빌드 된 저장소 개정판을 제공하는 문자열. Emacs가 개정 제어 외부에서 빌드 된 경우 값은 &lt;code&gt;nil&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="32c2c310a05a2e4299069228d4059ebe12c87d4e" translate="yes" xml:space="preserve">
          <source>A string that is the name of the process&amp;rsquo;s controlling terminal. On Unix and GNU systems, this is normally the file name of the corresponding terminal device, such as</source>
          <target state="translated">프로세스 제어 터미널의 이름 인 문자열입니다. Unix 및 GNU 시스템에서는 일반적으로 다음과 같은 해당 터미널 장치의 파일 이름입니다.</target>
        </trans-unit>
        <trans-unit id="a07b76952ae2e1b9491a1beda81ccc1a2fb843d7" translate="yes" xml:space="preserve">
          <source>A structure describing where the cursor is in this window.</source>
          <target state="translated">이 창에서 커서가있는 위치를 설명하는 구조입니다.</target>
        </trans-unit>
        <trans-unit id="20ca76b446ea261daca0ab9858048669216bed62" translate="yes" xml:space="preserve">
          <source>A structure describing where the cursor of this window physically is.</source>
          <target state="translated">이 창의 커서가 물리적으로 어디에 있는지 설명하는 구조입니다.</target>
        </trans-unit>
        <trans-unit id="283fbe00ae8cce4ea280dfbb7b15b846c6c4c692" translate="yes" xml:space="preserve">
          <source>A sublist specification may be a dotted list and the corresponding list argument may then be a dotted list. Alternatively, the last &lt;small&gt;CDR&lt;/small&gt; of a dotted list specification may be another sublist specification (via a grouping or an indirect specification, e.g., &lt;code&gt;(spec .  [(more
specs&amp;hellip;)])&lt;/code&gt;) whose elements match the non-dotted list arguments. This is useful in recursive specifications such as in the backquote example. Also see the description of a &lt;code&gt;nil&lt;/code&gt; specification above for terminating such recursion.</source>
          <target state="translated">하위 목록 사양은 점으로 구분 된 목록 일 수 있으며 해당하는 목록 인수는 점으로 구분 된 목록이 될 수 있습니다. 대안으로, 점으로 구분 된 목록 사양 의 마지막 &lt;small&gt;CDR&lt;/small&gt; 은 (그룹화 또는 간접 사양을 통한) 다른 하위 목록 사양 일 수 있으며, 예를 들어 &lt;code&gt;(spec . [(more specs&amp;hellip;)])&lt;/code&gt; ) 그 요소가 점으로 구분되지 않은 목록 인수와 일치합니다. 이것은 역 따옴표 예제와 같은 재귀 사양에서 유용합니다. 또한 이러한 재귀를 종료하려면 위 의 &lt;code&gt;nil&lt;/code&gt; 사양에 대한 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e6bd63f0d6eed94cca2c1d7fa955eac6382d7a76" translate="yes" xml:space="preserve">
          <source>A subprocess of Emacs may be &lt;em&gt;synchronous&lt;/em&gt; or &lt;em&gt;asynchronous&lt;/em&gt;, depending on how it is created. When you create a synchronous subprocess, the Lisp program waits for the subprocess to terminate before continuing execution. When you create an asynchronous subprocess, it can run in parallel with the Lisp program. This kind of subprocess is represented within Emacs by a Lisp object which is also called a &amp;ldquo;process&amp;rdquo;. Lisp programs can use this object to communicate with the subprocess or to control it. For example, you can send signals, obtain status information, receive output from the process, or send input to it.</source>
          <target state="translated">Emacs의 하위 프로세스 는 생성 방법에 따라 &lt;em&gt;동기식&lt;/em&gt; 또는 &lt;em&gt;비동기식&lt;/em&gt; 일 수 있습니다 . 동기식 하위 프로세스를 만들 때 Lisp 프로그램은 실행을 계속하기 전에 하위 프로세스가 종료 될 때까지 기다립니다. 비동기 하위 프로세스를 만들면 Lisp 프로그램과 병렬로 실행할 수 있습니다. 이러한 종류의 하위 프로세스는 &quot;프로세스&quot;라고도하는 Lisp 객체에 의해 Emacs 내에서 표현됩니다. Lisp 프로그램은이 개체를 사용하여 하위 프로세스와 통신하거나 제어 할 수 있습니다. 예를 들어 신호를 보내거나 상태 정보를 얻거나 프로세스에서 출력을 받거나 입력을 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="087de830e58dec95d6c61960121c78d539705185" translate="yes" xml:space="preserve">
          <source>A subprocess of Emacs running on the underlying OS.</source>
          <target state="translated">기본 OS에서 실행되는 Emacs의 하위 프로세스입니다.</target>
        </trans-unit>
        <trans-unit id="35507e345942623bfb6aa6be63bdded05b6c5918" translate="yes" xml:space="preserve">
          <source>A suitable kind of &lt;code&gt;file-error&lt;/code&gt; error is signaled if the file does not exist, or is not deletable. (On GNU and other POSIX-like systems, a file is deletable if its directory is writable.)</source>
          <target state="translated">파일이 존재하지 않거나 삭제할 수없는 경우 적절한 종류의 &lt;code&gt;file-error&lt;/code&gt; 오류가 표시됩니다. (GNU 및 기타 POSIX 유사 시스템에서 파일이 쓰기 가능한 경우 파일을 삭제할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="58e5791b58ed962f6049e196b317aabc08f3c119" translate="yes" xml:space="preserve">
          <source>A symbol as a mode line construct stands for its value. The value of &lt;var&gt;symbol&lt;/var&gt; is used as a mode line construct, in place of &lt;var&gt;symbol&lt;/var&gt;. However, the symbols &lt;code&gt;t&lt;/code&gt; and &lt;code&gt;nil&lt;/code&gt; are ignored, as is any symbol whose value is void.</source>
          <target state="translated">모드 라인 구성으로서의 기호는 그 값을 나타냅니다. 값 &lt;var&gt;symbol&lt;/var&gt; 대신에, 모드 선 구조체로서 사용되는 &lt;var&gt;symbol&lt;/var&gt; . 그러나 값이 void 인 모든 기호 와 마찬가지로 기호 &lt;code&gt;t&lt;/code&gt; 및 &lt;code&gt;nil&lt;/code&gt; 은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="136dfe6f1f6290980b0a544df03bc8031bada37f" translate="yes" xml:space="preserve">
          <source>A symbol as input stream is equivalent to the symbol&amp;rsquo;s function definition (if any).</source>
          <target state="translated">입력 스트림으로서의 기호는 기호의 함수 정의 (있는 경우)와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="11075144c8ce3c1e072d1e5adaac43cdc6ed22f8" translate="yes" xml:space="preserve">
          <source>A symbol as output stream is equivalent to the symbol&amp;rsquo;s function definition (if any).</source>
          <target state="translated">출력 스트림으로서의 기호는 기호의 함수 정의 (있는 경우)와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="bce876b9cd2acba081d2ad07d0fc80b3afe79b3c" translate="yes" xml:space="preserve">
          <source>A symbol can serve as a variable, as a function name, or to hold a property list. Or it may serve only to be distinct from all other Lisp objects, so that its presence in a data structure may be recognized reliably. In a given context, usually only one of these uses is intended. But you can use one symbol in all of these ways, independently.</source>
          <target state="translated">기호는 변수, 함수 이름 또는 속성 목록을 보유하는 역할을 할 수 있습니다. 또는 다른 모든 Lisp 객체와 구별되는 역할 만 할 수 있으므로 데이터 구조에서 그 존재를 안정적으로 인식 할 수 있습니다. 주어진 맥락에서 일반적으로 이러한 용도 중 하나만 사용됩니다. 그러나 이러한 모든 방법으로 하나의 기호를 독립적으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b40c765dfb974c4520f948565e6ea3abebbf26c" translate="yes" xml:space="preserve">
          <source>A symbol can serve as the name of a function.</source>
          <target state="translated">기호는 함수의 이름으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2522095758f15f287bcb68febcef4a1aef3c93ca" translate="yes" xml:space="preserve">
          <source>A symbol can serve as the name of a function. This happens when the symbol&amp;rsquo;s &lt;em&gt;function cell&lt;/em&gt; (see &lt;a href=&quot;symbol-components#Symbol-Components&quot;&gt;Symbol Components&lt;/a&gt;) contains a function object (e.g., a lambda expression). Then the symbol itself becomes a valid, callable function, equivalent to the function object in its function cell.</source>
          <target state="translated">기호는 함수의 이름으로 사용할 수 있습니다. 이것은 심볼의 &lt;em&gt;함수 셀&lt;/em&gt; ( &lt;a href=&quot;symbol-components#Symbol-Components&quot;&gt;심볼 구성 요소&lt;/a&gt; 참조 )에 함수 객체 (예 : 람다 식)가 포함되어 있을 때 발생합니다 . 그런 다음 기호 자체는 함수 셀의 함수 객체에 해당하는 유효하고 호출 가능한 함수가됩니다.</target>
        </trans-unit>
        <trans-unit id="dc66ecbc9c4221d50048e15206869a3b042473a6" translate="yes" xml:space="preserve">
          <source>A symbol is a function to compute the height. It is called with the current height as argument, and should return the new height to use.</source>
          <target state="translated">심볼은 높이를 계산하는 함수입니다. 현재 높이를 인수로 사용하여 호출되며 사용할 새 높이를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="1735c25eacfa5dbfa81d50d3791a7b3948064021" translate="yes" xml:space="preserve">
          <source>A symbol may possess any number of &lt;em&gt;symbol properties&lt;/em&gt;, which can be used to record miscellaneous information about the symbol. For example, when a symbol has a &lt;code&gt;risky-local-variable&lt;/code&gt; property with a non-&lt;code&gt;nil&lt;/code&gt; value, that means the variable which the symbol names is a risky file-local variable (see &lt;a href=&quot;file-local-variables#File-Local-Variables&quot;&gt;File Local Variables&lt;/a&gt;).</source>
          <target state="translated">기호는 &lt;em&gt;기호&lt;/em&gt; 에 대한 기타 정보를 기록하는 데 사용할 수있는 &lt;em&gt;기호 속성을&lt;/em&gt; 얼마든지 가질 수 있습니다. 예를 들어, 심볼에 &lt;code&gt;nil&lt;/code&gt; 이 아닌 값을 가진 &lt;code&gt;risky-local-variable&lt;/code&gt; 속성이있는 경우 이는 심볼 이름이 위험한 파일-로컬 변수 인 변수를 의미합니다 ( &lt;a href=&quot;file-local-variables#File-Local-Variables&quot;&gt;파일 로컬 변수&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="4af456786cdb930cf51a2fe8cb251937c0f92f76" translate="yes" xml:space="preserve">
          <source>A symbol name can contain any characters whatever. Most symbol names are written with letters, digits, and the punctuation characters &amp;lsquo;</source>
          <target state="translated">기호 이름은 모든 문자를 포함 할 수 있습니다. 대부분의 기호 이름은 문자, 숫자 및 구두점 문자 '</target>
        </trans-unit>
        <trans-unit id="c152fe70962941670ef3592324bbdb47115752ec" translate="yes" xml:space="preserve">
          <source>A symbol whose name starts with a colon (&amp;lsquo;</source>
          <target state="translated">이름이 콜론 ( ')으로 시작하는 기호</target>
        </trans-unit>
        <trans-unit id="3728c8c2eb3343e2a05d9141c3b791e811332750" translate="yes" xml:space="preserve">
          <source>A symbol. In other words, &lt;code&gt;(setf x y)&lt;/code&gt; is exactly equivalent to &lt;code&gt;(setq x y)&lt;/code&gt;, and &lt;code&gt;setq&lt;/code&gt; itself is strictly speaking redundant given that &lt;code&gt;setf&lt;/code&gt; exists. Most programmers will continue to prefer &lt;code&gt;setq&lt;/code&gt; for setting simple variables, though, for stylistic and historical reasons. The macro &lt;code&gt;(setf x y)&lt;/code&gt; actually expands to &lt;code&gt;(setq x y)&lt;/code&gt;, so there is no performance penalty for using it in compiled code.</source>
          <target state="translated">상징. 즉, &lt;code&gt;(setf x y)&lt;/code&gt; 는 &lt;code&gt;(setq x y)&lt;/code&gt; 와 정확히 동일 하며 &lt;code&gt;setq&lt;/code&gt; 자체는 &lt;code&gt;setf&lt;/code&gt; 가 존재 한다는 점에서 엄밀히 말하면 중복 됩니다. 그러나 대부분의 프로그래머는 스타일과 역사적 이유로 간단한 변수를 설정하기 위해 &lt;code&gt;setq&lt;/code&gt; 를 계속 선호합니다 . 매크로 &lt;code&gt;(setf x y)&lt;/code&gt; 실제로 &lt;code&gt;(setq x y)&lt;/code&gt; 확장 되므로 컴파일 된 코드에서 사용하는 경우 성능 저하가 없습니다.</target>
        </trans-unit>
        <trans-unit id="1954d27d0637fd3ddd907ebc88c0499752335e55" translate="yes" xml:space="preserve">
          <source>A syntax table can &lt;em&gt;inherit&lt;/em&gt; from another syntax table, which is called its &lt;em&gt;parent syntax table&lt;/em&gt;. A syntax table can leave the syntax class of some characters unspecified, by giving them the &amp;ldquo;inherit&amp;rdquo; syntax class; such a character then acquires the syntax class specified by the parent syntax table (see &lt;a href=&quot;syntax-class-table#Syntax-Class-Table&quot;&gt;Syntax Class Table&lt;/a&gt;). Emacs defines a &lt;em&gt;standard syntax table&lt;/em&gt;, which is the default parent syntax table, and is also the syntax table used by Fundamental mode.</source>
          <target state="translated">구문 테이블은 &lt;em&gt;상위 구문 테이블&lt;/em&gt; 이라는 다른 구문 테이블에서 &lt;em&gt;상속&lt;/em&gt; 할 수 있습니다 . 구문 테이블은 &quot;상속&quot;구문 클래스를 제공하여 일부 문자의 구문 클래스를 지정하지 않은 채로 둘 수 있습니다. 이러한 특성은 다음 상위 신택스 테이블에 의해 지정된 구문 클래스를 획득한다 (참조 : &lt;a href=&quot;syntax-class-table#Syntax-Class-Table&quot;&gt;구문 등급 표&lt;/a&gt; ). Emacs는 기본 부모 구문 테이블이자 기본 모드에서 사용되는 &lt;em&gt;구문 테이블&lt;/em&gt; 인 &lt;em&gt;표준 구문 테이블을&lt;/em&gt; 정의 합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b659b2d3d03e0d7773e900b73de02d70d5ddcd88" translate="yes" xml:space="preserve">
          <source>A syntax table is a data structure which can be used to look up the &lt;em&gt;syntax class&lt;/em&gt; and other syntactic properties of each character. Syntax tables are used by Lisp programs for scanning and moving across text.</source>
          <target state="translated">구문 테이블은 각 문자 의 &lt;em&gt;구문 클래스&lt;/em&gt; 및 기타 구문 속성 을 조회하는 데 사용할 수있는 데이터 구조입니다 . 구문 테이블은 Lisp 프로그램에서 텍스트를 스캔하고 이동하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="611cab9bf171d524f8bb167ff2d975371afdf4c3" translate="yes" xml:space="preserve">
          <source>A terminal device displays frames.</source>
          <target state="translated">터미널 장치는 프레임을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="154579a3c3d7f8dbf4dedff1e12b0784abbfebd3" translate="yes" xml:space="preserve">
          <source>A themable named sound from the freedesktop.org sound naming specification from &amp;lsquo;</source>
          <target state="translated">freedesktop.org 사운드 이름 지정 사양의 '</target>
        </trans-unit>
        <trans-unit id="26c5fb26d2d40b902e4464e332d9e274ac27ae65" translate="yes" xml:space="preserve">
          <source>A thread of Emacs Lisp execution.</source>
          <target state="translated">Emacs Lisp 실행 스레드입니다.</target>
        </trans-unit>
        <trans-unit id="57dfda42a48a44a57cc294b3f4f34e2af8232910" translate="yes" xml:space="preserve">
          <source>A token can be an &lt;code&gt;opener&lt;/code&gt; (something similar to an open-paren), a &lt;code&gt;closer&lt;/code&gt; (like a close-paren), or &lt;code&gt;neither&lt;/code&gt; of the two (e.g., an infix operator, or an inner token like &lt;code&gt;&quot;else&quot;&lt;/code&gt;).</source>
          <target state="translated">토큰은 &lt;code&gt;opener&lt;/code&gt; (열린 괄호와 비슷한 것), &lt;code&gt;closer&lt;/code&gt; (닫는 괄호와 같은) 또는 &lt;code&gt;neither&lt;/code&gt; 중 어느 것도 아닐 수 있습니다 (예 : 중위 연산자 또는 &lt;code&gt;&quot;else&quot;&lt;/code&gt; 와 같은 내부 토큰 ).</target>
        </trans-unit>
        <trans-unit id="0d764cf0b69eb00f7e2c9718e179e351b46213d5" translate="yes" xml:space="preserve">
          <source>A tool bar is a row of images.</source>
          <target state="translated">도구 모음은 이미지 행입니다.</target>
        </trans-unit>
        <trans-unit id="b6e511e3067670e626e12e33340269d446fde317" translate="yes" xml:space="preserve">
          <source>A translation table has two extra slots. The first is either &lt;code&gt;nil&lt;/code&gt; or a translation table that performs the reverse translation; the second is the maximum number of characters to look up for translating sequences of characters (see the description of &lt;code&gt;make-translation-table-from-alist&lt;/code&gt; below).</source>
          <target state="translated">변환 테이블에는 두 개의 추가 슬롯이 있습니다. 첫 번째는 &lt;code&gt;nil&lt;/code&gt; 또는 역변환을 수행하는 변환 테이블입니다. 두 번째는 문자 시퀀스를 번역하기 위해 검색 할 최대 문자 수입니다 (아래의 &lt;code&gt;make-translation-table-from-alist&lt;/code&gt; 에 대한 설명 참조).</target>
        </trans-unit>
        <trans-unit id="fdc3d3499bd5bb07db44fa25b08d5a6a535373e6" translate="yes" xml:space="preserve">
          <source>A true mirror-image of &lt;code&gt;re-search-forward&lt;/code&gt; would require a special feature for matching regular expressions from end to beginning. It&amp;rsquo;s not worth the trouble of implementing that.</source>
          <target state="translated">&lt;code&gt;re-search-forward&lt;/code&gt; 의 진정한 미러 이미지는 처음부터 끝까지 정규 표현식을 일치시키는 특수 기능이 필요합니다. 그것을 구현하는 문제는 가치가 없습니다.</target>
        </trans-unit>
        <trans-unit id="d8e822f12fc2d0ada4fa0abd7fbe433aba2b4039" translate="yes" xml:space="preserve">
          <source>A type predicate function takes one argument; it returns &lt;code&gt;t&lt;/code&gt; if the argument belongs to the appropriate type, and &lt;code&gt;nil&lt;/code&gt; otherwise. Following a general Lisp convention for predicate functions, most type predicates&amp;rsquo; names end with &amp;lsquo;</source>
          <target state="translated">유형 술어 함수는 하나의 인수를 사용합니다. 인수가 적절한 유형에 속하면 &lt;code&gt;t&lt;/code&gt; 를 반환 하고 그렇지 않으면 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다. 조건 자 함수에 대한 일반적인 Lisp 규칙에 따라 대부분의 형식 조건 자 이름은 '</target>
        </trans-unit>
        <trans-unit id="0d50bc7f95aabd11c78a01358b272f4c298b3579" translate="yes" xml:space="preserve">
          <source>A type used for automatically loading seldom-used functions.</source>
          <target state="translated">거의 사용하지 않는 함수를 자동으로로드하는 데 사용되는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="b25d98417944fbcf3fe27fffb07995fdd6887711" translate="yes" xml:space="preserve">
          <source>A typical value might look like this:</source>
          <target state="translated">일반적인 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7068fb3333ff355206cad1f5c8ac4e885a7b5eaa" translate="yes" xml:space="preserve">
          <source>A unique number assigned to this window when it was created.</source>
          <target state="translated">이 창을 만들 때 할당 된 고유 번호입니다.</target>
        </trans-unit>
        <trans-unit id="1f49c36b6b4f969d94158af5c04fa459e6fb756b" translate="yes" xml:space="preserve">
          <source>A user interface for building JSONRPC applications</source>
          <target state="translated">JSONRPC 애플리케이션 구축을위한 사용자 인터페이스</target>
        </trans-unit>
        <trans-unit id="da28673ff5250624bbd9c79fdce5b46476250e40" translate="yes" xml:space="preserve">
          <source>A value of &lt;code&gt;nil&lt;/code&gt; is equivalent to .5, since its effect is to center point. This variable automatically becomes buffer-local when set in any fashion.</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; 값은 그 효과가 중심점에 있기 때문에 .5와 같습니다. 이 변수는 어떤 방식 으로든 설정 될 때 자동으로 버퍼 로컬이됩니다.</target>
        </trans-unit>
        <trans-unit id="761af930570eba02ee4263e0c4625df53668e35d" translate="yes" xml:space="preserve">
          <source>A value of &lt;code&gt;nil&lt;/code&gt; says to ignore the lock and let this user edit the file anyway.</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; 값은 잠금을 무시하고이 사용자가 어쨌든 파일을 편집 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="2614ea86270afac8b5acd08878d712db67414cd0" translate="yes" xml:space="preserve">
          <source>A value of &lt;code&gt;t&lt;/code&gt; says to grab the lock on the file. Then this user may edit the file and &lt;var&gt;other-user&lt;/var&gt; loses the lock.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 값은 파일에 대한 잠금을 확보 함을 의미합니다. 그러면이 사용자가 파일을 편집 할 수 있고 &lt;var&gt;other-user&lt;/var&gt; 는 잠금을 잃게됩니다.</target>
        </trans-unit>
        <trans-unit id="0f7035c80e73faf961d120dfe6ba3e3b9a60ff4c" translate="yes" xml:space="preserve">
          <source>A value of the form &lt;code&gt;(&lt;var&gt;num&lt;/var&gt; . &lt;var&gt;expr&lt;/var&gt;)&lt;/code&gt; stands for the product of the values of &lt;var&gt;num&lt;/var&gt; and &lt;var&gt;expr&lt;/var&gt;. For example, &lt;code&gt;(2 . in)&lt;/code&gt; specifies a width of 2 inches, while &lt;code&gt;(0.5 .
&lt;var&gt;image&lt;/var&gt;)&lt;/code&gt; specifies half the width (or height) of the specified &lt;var&gt;image&lt;/var&gt; (which should be given by its image spec).</source>
          <target state="translated">&lt;code&gt;(&lt;var&gt;num&lt;/var&gt; . &lt;var&gt;expr&lt;/var&gt;)&lt;/code&gt; 형식 의 값은 &lt;var&gt;num&lt;/var&gt; 및 &lt;var&gt;expr&lt;/var&gt; 값의 곱을 나타냅니다 . 예를 들어, &lt;code&gt;(2 . in)&lt;/code&gt; 은 2 인치의 너비를 지정하고 &lt;code&gt;(0.5 . &lt;var&gt;image&lt;/var&gt;)&lt;/code&gt; 지정된 이미지 의 너비 (또는 높이)의 절반을 지정 &lt;var&gt;image&lt;/var&gt; (이미지 사양에서 제공해야 함).</target>
        </trans-unit>
        <trans-unit id="7d6f07646985192c4276dea56a0bd52c3ee59a86" translate="yes" xml:space="preserve">
          <source>A variable can be let-bound (see &lt;a href=&quot;local-variables#Local-Variables&quot;&gt;Local Variables&lt;/a&gt;) to a value. This makes its global value shadowed by the binding; &lt;code&gt;default-value&lt;/code&gt; will then return the value from that binding, not the global value, and &lt;code&gt;set-default&lt;/code&gt; will be prevented from setting the global value (it will change the let-bound value instead). The following two functions allow to reference the global value even if it&amp;rsquo;s shadowed by a let-binding.</source>
          <target state="translated">변수는 값에 바인딩 될 수 있습니다 ( &lt;a href=&quot;local-variables#Local-Variables&quot;&gt;로컬 변수&lt;/a&gt; 참조 ). 이로 인해 글로벌 값이 바인딩에 의해 가려집니다. 그러면 &lt;code&gt;default-value&lt;/code&gt; 는 전역 값이 아닌 해당 바인딩의 값을 반환하고 &lt;code&gt;set-default&lt;/code&gt; 는 전역 값을 설정하지 못하게됩니다 (대신 let-bound 값이 변경됨). 다음 두 함수는 let-binding에 의해 가려진 경우에도 전역 값을 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42469365ae54b87406fe0c4580eafab3e15cd7f7" translate="yes" xml:space="preserve">
          <source>A variable can have buffer-local bindings in some buffers but not in other buffers. The default binding is shared by all the buffers that don&amp;rsquo;t have their own bindings for the variable. (This includes all newly-created buffers.) If you set the variable in a buffer that does not have a buffer-local binding for it, this sets the default binding, so the new value is visible in all the buffers that see the default binding.</source>
          <target state="translated">변수는 일부 버퍼에 버퍼-로컬 바인딩을 가질 수 있지만 다른 버퍼에는 없습니다. 기본 바인딩은 변수에 대한 자체 바인딩이없는 모든 버퍼에서 공유됩니다. (여기에는 새로 생성 된 모든 버퍼가 포함됩니다.) 버퍼-로컬 바인딩이없는 버퍼에서 변수를 설정하면 기본 바인딩이 설정되므로 기본값을 보는 모든 버퍼에서 새 값이 표시됩니다. 제본.</target>
        </trans-unit>
        <trans-unit id="7229e30ed01c65b1f554b2be31bb3ad0ddba289e" translate="yes" xml:space="preserve">
          <source>A variable can have more than one local binding at a time (e.g., if there are nested &lt;code&gt;let&lt;/code&gt; forms that bind the variable). The &lt;em&gt;current binding&lt;/em&gt; is the local binding that is actually in effect. It determines the value returned by evaluating the variable symbol, and it is the binding acted on by &lt;code&gt;setq&lt;/code&gt;.</source>
          <target state="translated">변수는 한 번에 둘 이상의 로컬 바인딩을 가질 수 있습니다 (예 : 변수를 바인딩하는 중첩 된 &lt;code&gt;let&lt;/code&gt; 양식이있는 경우). &lt;em&gt;결합 전류는&lt;/em&gt; 그 효과가 실제로 바인딩 로컬이다. 변수 기호를 평가하여 반환되는 값을 결정하고 &lt;code&gt;setq&lt;/code&gt; 에 의해 작동되는 바인딩 입니다.</target>
        </trans-unit>
        <trans-unit id="a1ac65fb2f3cee8bab9b33ddf4b381098337ecd1" translate="yes" xml:space="preserve">
          <source>A variable declared to be a user option (i.e., satisfying the predicate &lt;code&gt;custom-variable-p&lt;/code&gt;). This reads the variable using &lt;code&gt;read-variable&lt;/code&gt;. See &lt;a href=&quot;high_002dlevel-completion#Definition-of-read_002dvariable&quot;&gt;Definition of read-variable&lt;/a&gt;. Existing, Completion, Prompt.</source>
          <target state="translated">사용자 옵션으로 선언 된 변수 (예 : &lt;code&gt;custom-variable-p&lt;/code&gt; 조건 자 충족 ). 이것은 &lt;code&gt;read-variable&lt;/code&gt; 을 사용하여 변수를 읽습니다 . &lt;a href=&quot;high_002dlevel-completion#Definition-of-read_002dvariable&quot;&gt;읽기 변수 정의를&lt;/a&gt; 참조하십시오 . 기존, 완료, 프롬프트.</target>
        </trans-unit>
        <trans-unit id="714788a2d69016197f589516788c6c86a085d831" translate="yes" xml:space="preserve">
          <source>A variable definition serves three purposes. First, it informs people who read the code that the symbol is &lt;em&gt;intended&lt;/em&gt; to be used a certain way (as a variable). Second, it informs the Lisp system of this, optionally supplying an initial value and a documentation string. Third, it provides information to programming tools such as &lt;code&gt;etags&lt;/code&gt;, allowing them to find where the variable was defined.</source>
          <target state="translated">변수 정의는 세 가지 용도로 사용됩니다. 첫째, 코드를 읽는 사람들에게 기호가 특정 방식 (변수)으로 사용 &lt;em&gt;되도록 의도&lt;/em&gt; 되었음을 알려줍니다 . 둘째, Lisp 시스템에이를 알리고 선택적으로 초기 값과 문서 문자열을 제공합니다. 셋째, &lt;code&gt;etags&lt;/code&gt; 와 같은 프로그래밍 도구에 정보를 제공 하여 변수가 정의 된 위치를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d8469682cf6ae5ee24fbb06b606a67a9bdca6f1" translate="yes" xml:space="preserve">
          <source>A vector of elements groups the elements into a single &lt;em&gt;group specification&lt;/em&gt;. Its meaning has nothing to do with vectors.</source>
          <target state="translated">요소 벡터는 요소를 단일 &lt;em&gt;그룹 사양으로 그룹화합니다&lt;/em&gt; . 그 의미는 벡터와 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="907ba2db0b69ea3ac390ffc8957c9f20ac952af1" translate="yes" xml:space="preserve">
          <source>A vector of glyphs for indicating the presence of invisible lines (the default is &amp;lsquo;</source>
          <target state="translated">보이지 않는 선이 있음을 나타내는 글리프 벡터 (기본값은 '</target>
        </trans-unit>
        <trans-unit id="5b9d67749d8a12ed598e9d50f8a2fa40ed3d9434" translate="yes" xml:space="preserve">
          <source>A vector of strings or bool-vectors, each specifying one line of the image. Do specify &lt;code&gt;:height&lt;/code&gt; and &lt;code&gt;:width&lt;/code&gt;.</source>
          <target state="translated">문자열 또는 부울 벡터로 구성된 벡터로, 각각 이미지의 한 줄을 지정합니다. &lt;code&gt;:height&lt;/code&gt; 및 &lt;code&gt;:width&lt;/code&gt; 를 지정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="bfd393f14b47e46b8b1b11b3ee71f7e6e4effd32" translate="yes" xml:space="preserve">
          <source>A vector, like a string or a number, is considered a constant for evaluation: the result of evaluating it is the same vector. This does not evaluate or even examine the elements of the vector. See &lt;a href=&quot;self_002devaluating-forms#Self_002dEvaluating-Forms&quot;&gt;Self-Evaluating Forms&lt;/a&gt;. Vectors written with square brackets should not be modified via &lt;code&gt;aset&lt;/code&gt; or other destructive operations. See &lt;a href=&quot;mutability#Mutability&quot;&gt;Mutability&lt;/a&gt;.</source>
          <target state="translated">문자열이나 숫자와 같은 벡터는 평가를위한 상수로 간주됩니다. 평가 결과는 동일한 벡터입니다. 이것은 벡터의 요소를 평가하거나 조사하지도 않습니다. &lt;a href=&quot;self_002devaluating-forms#Self_002dEvaluating-Forms&quot;&gt;자체 평가 양식을&lt;/a&gt; 참조하십시오 . 대괄호로 작성된 벡터는 &lt;code&gt;aset&lt;/code&gt; 또는 기타 파괴적인 작업을 통해 수정해서는 안됩니다 . &lt;a href=&quot;mutability#Mutability&quot;&gt;Mutability를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cea3cbc11949c249de3312f294eef9cb9f938425" translate="yes" xml:space="preserve">
          <source>A version number, in a form that the function &lt;code&gt;version-to-list&lt;/code&gt; understands (e.g., &amp;lsquo;</source>
          <target state="translated">버전 &lt;code&gt;version-to-list&lt;/code&gt; 이해 하는 형식의 버전 번호 (예 : '</target>
        </trans-unit>
        <trans-unit id="d6f9261a2dce5769b4273b16b8e7e92056f25007" translate="yes" xml:space="preserve">
          <source>A very simple parsing technique.</source>
          <target state="translated">매우 간단한 구문 분석 기술입니다.</target>
        </trans-unit>
        <trans-unit id="a21b6bc0e953a05c7047f6926acdf8cdb6092af2" translate="yes" xml:space="preserve">
          <source>A visible child frame always appears on top of its parent frame thus obscuring parts of it, except on NS builds where it may be positioned beneath the parent. This is comparable to the window-system window of a top-level frame which also always appears on top of its parent window&amp;mdash;the desktop&amp;rsquo;s root window. When a parent frame is iconified or made invisible (see &lt;a href=&quot;visibility-of-frames#Visibility-of-Frames&quot;&gt;Visibility of Frames&lt;/a&gt;), its child frames are made invisible. When a parent frame is deiconified or made visible, its child frames are made visible.</source>
          <target state="translated">보이는 자식 프레임은 항상 부모 프레임 위에 나타나므로 부모 프레임 아래에 위치 할 수있는 NS 빌드를 제외하고는 부분을가립니다. 이는 항상 부모 창 (데스크톱의 루트 창) 위에 표시되는 최상위 프레임의 창 시스템 창과 비슷합니다. 상위 프레임이 아이콘 화되거나 보이지 않게되면 ( &lt;a href=&quot;visibility-of-frames#Visibility-of-Frames&quot;&gt;프레임 가시성&lt;/a&gt; 참조 ) 하위 프레임이 보이지 않게됩니다. 상위 프레임이 아이콘 화 해제되거나 표시되면 해당 하위 프레임이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="3f15d83470f651a16357e3fbbafed38889367d47" translate="yes" xml:space="preserve">
          <source>A visible frame occupies a rectangular area on its terminal&amp;rsquo;s display. This area may contain a number of nested rectangles, each serving a different purpose. The drawing below sketches the layout of a frame on a graphical terminal:</source>
          <target state="translated">보이는 프레임은 터미널 디스플레이에서 직사각형 영역을 차지합니다. 이 영역에는 각기 다른 용도로 사용되는 여러 개의 중첩 사각형이 포함될 수 있습니다. 아래 그림은 그래픽 터미널의 프레임 레이아웃을 스케치합니다.</target>
        </trans-unit>
        <trans-unit id="9dc2f20dda99554f7dead3ef07cf05023791995d" translate="yes" xml:space="preserve">
          <source>A watch can become invalid if the file or directory it watches is deleted, or if the watcher thread exits abnormally for any other reason. Removing the watch by calling &lt;code&gt;file-notify-rm-watch&lt;/code&gt; also makes it invalid.</source>
          <target state="translated">감시하는 파일 또는 디렉토리가 삭제되거나 감시자 스레드가 다른 이유로 비정상적으로 종료되면 감시가 무효화 될 수 있습니다. &lt;code&gt;file-notify-rm-watch&lt;/code&gt; watch를 호출하여 감시를 제거하면 무효화됩니다.</target>
        </trans-unit>
        <trans-unit id="efb12abaf84e2ff0588000ce76b06f219405368d" translate="yes" xml:space="preserve">
          <source>A web server providing access to a package archive must support the following queries:</source>
          <target state="translated">패키지 아카이브에 대한 액세스를 제공하는 웹 서버는 다음 쿼리를 지원해야합니다.</target>
        </trans-unit>
        <trans-unit id="96a8665d6abd124bc5fe28303880a92b178554c2" translate="yes" xml:space="preserve">
          <source>A well-designed macro definition takes steps to avoid this problem by producing an expansion that evaluates the argument expressions exactly once unless repeated evaluation is part of the intended purpose of the macro. Here is a correct expansion for the &lt;code&gt;for&lt;/code&gt; macro:</source>
          <target state="translated">잘 설계된 매크로 정의는 반복 된 평가가 매크로의 의도 된 목적의 일부가 아닌 경우 인수 식을 정확히 한 번 평가하는 확장을 생성하여이 문제를 방지하기위한 조치를 취합니다. &lt;code&gt;for&lt;/code&gt; 매크로에 대한 올바른 확장은 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="b1827635d79dea77c5cd2894c432de677a45e87a" translate="yes" xml:space="preserve">
          <source>A window can get resized explicitly by using one of the functions from the preceding section or implicitly, for example, when resizing an adjacent window, when splitting or deleting a window (see &lt;a href=&quot;splitting-windows#Splitting-Windows&quot;&gt;Splitting Windows&lt;/a&gt;, see &lt;a href=&quot;deleting-windows#Deleting-Windows&quot;&gt;Deleting Windows&lt;/a&gt;) or when resizing the window&amp;rsquo;s frame (see &lt;a href=&quot;frame-size#Frame-Size&quot;&gt;Frame Size&lt;/a&gt;).</source>
          <target state="translated">이전 섹션의 함수 중 하나를 사용하여 명시 적으로 창 크기를 조정하거나, 예를 들어 인접한 창 크기를 조정할 때, 창 분할 또는 삭제 (창 &lt;a href=&quot;splitting-windows#Splitting-Windows&quot;&gt;분할&lt;/a&gt; 참조, 창 &lt;a href=&quot;deleting-windows#Deleting-Windows&quot;&gt;삭제&lt;/a&gt; 참조 ) 또는 창 프레임 크기 조정 ()과 같이 암시 적으로 창 크기를 조정할 수 있습니다. &lt;a href=&quot;frame-size#Frame-Size&quot;&gt;프레임 크기&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="da0f4aabb2b28d1adb4d16bd804393865c93bf0e" translate="yes" xml:space="preserve">
          <source>A window can have a &lt;em&gt;header line&lt;/em&gt; at the top, just as it can have a mode line at the bottom. The header line feature works just like the mode line feature, except that it&amp;rsquo;s controlled by &lt;code&gt;header-line-format&lt;/code&gt;:</source>
          <target state="translated">창은 맨 아래에 모드 행이있을 수있는 것처럼 맨 위에 &lt;em&gt;헤더 행이&lt;/em&gt; 있을 수 있습니다. 헤더 행 기능은 &lt;code&gt;header-line-format&lt;/code&gt; 에 의해 제어된다는 점을 제외하면 모드 행 기능과 동일하게 작동 합니다 .</target>
        </trans-unit>
        <trans-unit id="7eb040f86ff87638d96bfd4ec298244d1a1c95a8" translate="yes" xml:space="preserve">
          <source>A window is resized if and only if it has been specially created for the buffer. In particular, windows that have shown another buffer before are not resized. By default, this mode uses &lt;code&gt;fit-window-to-buffer&lt;/code&gt; (see &lt;a href=&quot;resizing-windows#Resizing-Windows&quot;&gt;Resizing Windows&lt;/a&gt;) for resizing. You can specify a different function by customizing the options &lt;code&gt;temp-buffer-max-height&lt;/code&gt; and &lt;code&gt;temp-buffer-max-width&lt;/code&gt; below.</source>
          <target state="translated">창은 버퍼 용으로 특별히 생성 된 경우에만 크기가 조정됩니다. 특히 이전에 다른 버퍼를 표시 한 창은 크기가 조정되지 않습니다. 기본적으로이 모드는 크기 조정을 위해 &lt;code&gt;fit-window-to-buffer&lt;/code&gt; ( &lt;a href=&quot;resizing-windows#Resizing-Windows&quot;&gt;Windows 크기 조정&lt;/a&gt; 참조 )을 사용합니다. 아래의 &lt;code&gt;temp-buffer-max-height&lt;/code&gt; 및 &lt;code&gt;temp-buffer-max-width&lt;/code&gt; 옵션을 사용자 지정하여 다른 기능을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5b181ae523d21d580fe4dc9490e28d52beda4e36" translate="yes" xml:space="preserve">
          <source>A window showing a temporary buffer can be fitted to the size of that buffer using the following mode:</source>
          <target state="translated">임시 버퍼를 보여주는 창은 다음 모드를 사용하여 해당 버퍼의 크기에 맞출 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10b80aceee959c8dcb16c72ed1a2553043421e82" translate="yes" xml:space="preserve">
          <source>A window that is just one line tall never displays a header line. A window that is two lines tall cannot display both a mode line and a header line at once; if it has a mode line, then it does not display a header line.</source>
          <target state="translated">한 줄 높이의 창에는 헤더 줄이 표시되지 않습니다. 두 줄의 창은 모드 줄과 헤더 줄을 동시에 표시 할 수 없습니다. 모드 행이있는 경우 헤더 행을 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6004ea783485bff5b8ff0a2c4b58ed331fceaf67" translate="yes" xml:space="preserve">
          <source>A window that showed &lt;var&gt;buffer&lt;/var&gt; before, provided it is not the selected window.</source>
          <target state="translated">보여준 윈도우 &lt;var&gt;buffer&lt;/var&gt; 전에, 그것은 선택된 윈도우하지 제공된다.</target>
        </trans-unit>
        <trans-unit id="24fac820e9dc3bcfec792e9cbea05e313a184dd9" translate="yes" xml:space="preserve">
          <source>A working buffer for decoding.</source>
          <target state="translated">디코딩을위한 작업 버퍼입니다.</target>
        </trans-unit>
        <trans-unit id="a0c46d9d748b73163c147c1ce7040c6c5f099f4e" translate="yes" xml:space="preserve">
          <source>A working buffer for encoding.</source>
          <target state="translated">인코딩을위한 작업 버퍼입니다.</target>
        </trans-unit>
        <trans-unit id="616b07ea95b58bd9c829efac045d8e3b914aeaa6" translate="yes" xml:space="preserve">
          <source>A wrap prefix may also be specified for regions of text, using the &lt;code&gt;wrap-prefix&lt;/code&gt; text or overlay property. This takes precedence over the &lt;code&gt;wrap-prefix&lt;/code&gt; variable. See &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Special Properties&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;wrap-prefix&lt;/code&gt; 텍스트 또는 오버레이 속성을 사용하여 텍스트 영역에 wrap 접두사를 지정할 수도 있습니다 . 이것은 &lt;code&gt;wrap-prefix&lt;/code&gt; 변수 보다 우선 합니다. &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;특수 속성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3b61659ac0aca26e539585c1b71cc13614c39334" translate="yes" xml:space="preserve">
          <source>A wrap-prefix may also be specified for an entire buffer using the &lt;code&gt;wrap-prefix&lt;/code&gt; buffer-local variable (however, a &lt;code&gt;wrap-prefix&lt;/code&gt; text-property takes precedence over the value of the &lt;code&gt;wrap-prefix&lt;/code&gt; variable). See &lt;a href=&quot;truncation#Truncation&quot;&gt;Truncation&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;wrap-prefix&lt;/code&gt; buffer-local 변수를 사용하여 전체 버퍼에 대해 wrap-prefix를 지정할 수도 있습니다 (하지만 &lt;code&gt;wrap-prefix&lt;/code&gt; text-property가 &lt;code&gt;wrap-prefix&lt;/code&gt; 변수 값보다 우선 합니다). &lt;a href=&quot;truncation#Truncation&quot;&gt;잘림을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1a6a3baa60990f601b340b07ecccc1672c3cca03" translate="yes" xml:space="preserve">
          <source>A-</source>
          <target state="translated">A-</target>
        </trans-unit>
        <trans-unit id="a85e90f9835e6411e691ebde65582614cea81732" translate="yes" xml:space="preserve">
          <source>ALT</source>
          <target state="translated">ALT</target>
        </trans-unit>
        <trans-unit id="80d305c58f97edfae92a3627f5a66d9bef4d8d46" translate="yes" xml:space="preserve">
          <source>AM</source>
          <target state="translated">AM</target>
        </trans-unit>
        <trans-unit id="d93d10ff0fbef1b4aa0ddc24e10e907746d3c85a" translate="yes" xml:space="preserve">
          <source>API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="94090230b1f8c256f7ac5dc5a70bd3b20ee4ff15" translate="yes" xml:space="preserve">
          <source>ASCII</source>
          <target state="translated">ASCII</target>
        </trans-unit>
        <trans-unit id="031fd11ba8734ab304116a023b5216306b246bee" translate="yes" xml:space="preserve">
          <source>AT</source>
          <target state="translated">AT</target>
        </trans-unit>
        <trans-unit id="99122025a15b80d993018f40997751b62445924e" translate="yes" xml:space="preserve">
          <source>AT&amp;amp;T Unix System V.</source>
          <target state="translated">AT &amp;amp; T Unix 시스템 V.</target>
        </trans-unit>
        <trans-unit id="54f90b5155803aae21271b2ad64b0075c858dfb3" translate="yes" xml:space="preserve">
          <source>Abbrev Properties</source>
          <target state="translated">약어 속성</target>
        </trans-unit>
        <trans-unit id="f784445cdd616480acdfafb0159b1dd57c47999c" translate="yes" xml:space="preserve">
          <source>Abbrev Table Properties</source>
          <target state="translated">약어 테이블 속성</target>
        </trans-unit>
        <trans-unit id="2a8b96a9acfbae4f72a46878195e3d362ca12a6d" translate="yes" xml:space="preserve">
          <source>Abbrev Tables</source>
          <target state="translated">약어 테이블</target>
        </trans-unit>
        <trans-unit id="a762e02aeaccf777576ff3c307e562d8de1c9496" translate="yes" xml:space="preserve">
          <source>Abbrev tables used by various major modes.</source>
          <target state="translated">다양한 주요 모드에서 사용되는 약어 테이블.</target>
        </trans-unit>
        <trans-unit id="49470700c92eb0723c4ce23a16459e8c3cadae63" translate="yes" xml:space="preserve">
          <source>Abbrevs</source>
          <target state="translated">Abbrevs</target>
        </trans-unit>
        <trans-unit id="0305dceae89338799d1bdcabaff23a024687a7d6" translate="yes" xml:space="preserve">
          <source>Abbrevs and Abbrev Expansion</source>
          <target state="translated">Abbrevs 및 Abbrev 확장</target>
        </trans-unit>
        <trans-unit id="b4aa8f55f18e483e3d99ff9bebe3bd5c52648359" translate="yes" xml:space="preserve">
          <source>Abbrevs are usually expanded by certain interactive commands, including &lt;code&gt;self-insert-command&lt;/code&gt;. This section describes the subroutines used in writing such commands, as well as the variables they use for communication.</source>
          <target state="translated">약어는 일반적으로 &lt;code&gt;self-insert-command&lt;/code&gt; 를 포함한 특정 대화식 명령에 의해 확장됩니다 . 이 섹션에서는 이러한 명령을 작성하는 데 사용되는 서브 루틴과 통신에 사용하는 변수에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1631d5afa2a3227c2b1fff62aedf669a7aee3c55" translate="yes" xml:space="preserve">
          <source>Abbrevs have properties, some of which influence the way they work. You can provide them as arguments to &lt;code&gt;define-abbrev&lt;/code&gt;, and manipulate them with the following functions:</source>
          <target state="translated">약어에는 속성이 있으며, 그 중 일부는 작동 방식에 영향을줍니다. 이를 &lt;code&gt;define-abbrev&lt;/code&gt; 에 대한 인수로 제공하고 다음 함수를 사용하여 조작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd64ebde815890af94b19555b946c61d882f6e1a" translate="yes" xml:space="preserve">
          <source>Abort one level back to the previous command level (&lt;code&gt;abort-recursive-edit&lt;/code&gt;).</source>
          <target state="translated">한 레벨을 이전 명령 레벨로 다시 &lt;code&gt;abort-recursive-edit&lt;/code&gt; 합니다 ( abort-recursive-edit ).</target>
        </trans-unit>
        <trans-unit id="649f859d67e712421f56a26ae61a458542dd60ea" translate="yes" xml:space="preserve">
          <source>Absolute and Relative File Names</source>
          <target state="translated">절대 및 상대 파일 이름</target>
        </trans-unit>
        <trans-unit id="059d44280b6e5c431c206b204f4f62d2e05d3635" translate="yes" xml:space="preserve">
          <source>Absolute times may be specified using a string with a limited variety of formats, and are taken to be times &lt;em&gt;today&lt;/em&gt;, even if already in the past. The recognized forms are &amp;lsquo;</source>
          <target state="translated">제한된 다양한 형식의 문자열을 사용하여 절대 시간을 지정할 수 있으며 , 이미 과거에 있더라도 &lt;em&gt;오늘&lt;/em&gt; 시간으로 간주 됩니다. 인식되는 형식은 '</target>
        </trans-unit>
        <trans-unit id="c2929c3c521daab9f85d0df0bc4e1eb3e6ff7ace" translate="yes" xml:space="preserve">
          <source>Abstract Display</source>
          <target state="translated">추상 디스플레이</target>
        </trans-unit>
        <trans-unit id="0dd14bcbc9ae50a4fc5b86a822cc2f2f4d8cca03" translate="yes" xml:space="preserve">
          <source>Abstract Display Example</source>
          <target state="translated">추상 디스플레이 예</target>
        </trans-unit>
        <trans-unit id="8ca47e66401ef945d4b28414ef0d5576741f3686" translate="yes" xml:space="preserve">
          <source>Abstract Display Functions</source>
          <target state="translated">추상 디스플레이 기능</target>
        </trans-unit>
        <trans-unit id="69257aa08447c746dd43fabf319f01b5bf36c541" translate="yes" xml:space="preserve">
          <source>Accepting Output from Processes</source>
          <target state="translated">프로세스에서 출력 수락</target>
        </trans-unit>
        <trans-unit id="b3e3bbc9103b04d543a6204da8e18664e43f77be" translate="yes" xml:space="preserve">
          <source>Access control</source>
          <target state="translated">액세스 제어</target>
        </trans-unit>
        <trans-unit id="c95b17f402b7316d8ba7de52ef60427ce9506d18" translate="yes" xml:space="preserve">
          <source>Access to Documentation Strings</source>
          <target state="translated">문서 문자열에 대한 액세스</target>
        </trans-unit>
        <trans-unit id="ad4938a0faaa972c17f8af4c4d5fdcca75e5ab35" translate="yes" xml:space="preserve">
          <source>Access to Frame Parameters</source>
          <target state="translated">프레임 매개 변수에 액세스</target>
        </trans-unit>
        <trans-unit id="51a874cb0f96d3ea9f2ce946b1290deba1b58fd0" translate="yes" xml:space="preserve">
          <source>Access, manipulate and search the</source>
          <target state="translated">액세스, 조작 및 검색</target>
        </trans-unit>
        <trans-unit id="21dbc590326eedf17d212f7c64c83e8331fddf48" translate="yes" xml:space="preserve">
          <source>Accessing Elements of Lists</source>
          <target state="translated">목록의 요소에 액세스</target>
        </trans-unit>
        <trans-unit id="b4efd1b0aae332f4b617e49e2f68b08f45ba40e4" translate="yes" xml:space="preserve">
          <source>Accessing Function Cell Contents</source>
          <target state="translated">기능 셀 내용에 액세스</target>
        </trans-unit>
        <trans-unit id="2ae0d4aab84373932fbdccdc1dd027efe8eb99b1" translate="yes" xml:space="preserve">
          <source>Accessing Mouse Events</source>
          <target state="translated">마우스 이벤트에 액세스</target>
        </trans-unit>
        <trans-unit id="7b70ffbc5424e39bca6adad4e4d11285e1ac347b" translate="yes" xml:space="preserve">
          <source>Accessing Other Processes</source>
          <target state="translated">다른 프로세스에 액세스</target>
        </trans-unit>
        <trans-unit id="8339c289bb6c2a3facc1658bda0b35c1d194fecf" translate="yes" xml:space="preserve">
          <source>Accessing Scroll Bar Events</source>
          <target state="translated">스크롤 막대 이벤트에 액세스</target>
        </trans-unit>
        <trans-unit id="8eb474e9f84ed1c8d415f59983dd55f6ddf51322" translate="yes" xml:space="preserve">
          <source>Accessing Symbol Properties</source>
          <target state="translated">심볼 속성에 액세스</target>
        </trans-unit>
        <trans-unit id="dd21e1a656d1c33e1a0961edb1425706c4dca0fb" translate="yes" xml:space="preserve">
          <source>Accessing Variable Values</source>
          <target state="translated">변수 값 액세스</target>
        </trans-unit>
        <trans-unit id="8572c608682fbb32c330cfe123c0c1e48efb3125" translate="yes" xml:space="preserve">
          <source>Accessing a window&amp;rsquo;s size.</source>
          <target state="translated">창 크기에 액세스.</target>
        </trans-unit>
        <trans-unit id="f8f65e4cb3dd5208adf445a32728a6ff8fca1a80" translate="yes" xml:space="preserve">
          <source>Accessing and changing buffer names.</source>
          <target state="translated">버퍼 이름 액세스 및 변경.</target>
        </trans-unit>
        <trans-unit id="3129221bf25c4d4b56aa75c86a37cdcc52d7977f" translate="yes" xml:space="preserve">
          <source>Accessing and recording terminal input.</source>
          <target state="translated">터미널 입력에 액세스하고 기록합니다.</target>
        </trans-unit>
        <trans-unit id="8631d7461d61b93f0e7f285fa1d91660e92fcc8e" translate="yes" xml:space="preserve">
          <source>Accessing files.</source>
          <target state="translated">파일 액세스.</target>
        </trans-unit>
        <trans-unit id="6ab94f81e36e6a4e03c0557995d9d781180dfde7" translate="yes" xml:space="preserve">
          <source>Accessing or setting the function definition of a symbol.</source>
          <target state="translated">기호의 기능 정의에 액세스하거나 설정합니다.</target>
        </trans-unit>
        <trans-unit id="febe729637e545444f7ff407ae1d3c58bfa2095e" translate="yes" xml:space="preserve">
          <source>Accessing other processes running on your system.</source>
          <target state="translated">시스템에서 실행중인 다른 프로세스에 액세스.</target>
        </trans-unit>
        <trans-unit id="317d74ecc1929588bf8f86c73cd8f7de6158a955" translate="yes" xml:space="preserve">
          <source>Accessing property lists stored elsewhere.</source>
          <target state="translated">다른 곳에 저장된 속성 목록에 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="4de3522fad93f3eb20523cf511d421cb8eef7ca4" translate="yes" xml:space="preserve">
          <source>Accessing run-status and other attributes.</source>
          <target state="translated">실행 상태 및 기타 속성에 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="e4d2ebfdc40bb29558e41e11ad7b405042d411f3" translate="yes" xml:space="preserve">
          <source>Accessing single items of match data, such as where a particular subexpression started.</source>
          <target state="translated">특정 하위 표현식이 시작된 위치와 같은 일치 데이터의 단일 항목에 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="e47d1cd990a7768c115296fc95220fcfe9f44b0e" translate="yes" xml:space="preserve">
          <source>Accessing symbol properties.</source>
          <target state="translated">심볼 속성에 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="97a8946bf0993a5ece0972055df9d2232582c889" translate="yes" xml:space="preserve">
          <source>Accessing the Entire Match Data</source>
          <target state="translated">전체 경기 데이터에 액세스</target>
        </trans-unit>
        <trans-unit id="0098eec4c4a85cc7153b9941ac7e084d9e2e8113" translate="yes" xml:space="preserve">
          <source>Accessing the entire match data at once, as a list.</source>
          <target state="translated">한 번에 전체 경기 데이터에 목록으로 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="6d51c3b889a7d39ffb0cd69aa7cdd6137813bf7a" translate="yes" xml:space="preserve">
          <source>Accessor functions are provided to access the elements in this list. The accessors are mentioned along with the descriptions of the elements below.</source>
          <target state="translated">이 목록의 요소에 액세스하기 위해 접근 자 함수가 제공됩니다. 접근자는 아래 요소에 대한 설명과 함께 언급됩니다.</target>
        </trans-unit>
        <trans-unit id="a16eff51e0f2460918136851c80aba409432bd14" translate="yes" xml:space="preserve">
          <source>Accordingly, the native height of a frame may include the height of the tool bar but not that of the menu bar (Lucid, Motif, MS-Windows) or those of the menu bar and the tool bar (non-toolkit and text terminal frames).</source>
          <target state="translated">따라서 프레임의 기본 높이는 도구 모음의 높이를 포함 할 수 있지만 메뉴 모음 (Lucid, Motif, MS-Windows) 또는 메뉴 모음과 도구 모음 (비 툴킷 및 텍스트 터미널 프레임)의 높이는 포함하지 않을 수 있습니다. ).</target>
        </trans-unit>
        <trans-unit id="5d9540ff93a75d47409d6a0aa37491da117ecdf8" translate="yes" xml:space="preserve">
          <source>Acknowledgments</source>
          <target state="translated">Acknowledgments</target>
        </trans-unit>
        <trans-unit id="8be718ab6c21edb41bfaec3e8d4ff0416d658fc0" translate="yes" xml:space="preserve">
          <source>Action Alists for Buffer Display</source>
          <target state="translated">버퍼 표시를위한 조치</target>
        </trans-unit>
        <trans-unit id="ce9f32ee0623ab47f4c96611c146ef4fcb105048" translate="yes" xml:space="preserve">
          <source>Action Functions for Buffer Display</source>
          <target state="translated">버퍼 표시를위한 동작 기능</target>
        </trans-unit>
        <trans-unit id="bea1043802a5a73ba6a935cc95001c4084c8eed4" translate="yes" xml:space="preserve">
          <source>Active Display Table</source>
          <target state="translated">액티브 디스플레이 테이블</target>
        </trans-unit>
        <trans-unit id="1b42bb970933421bd7fe384eb941f0b135fc8d12" translate="yes" xml:space="preserve">
          <source>Active Keymaps</source>
          <target state="translated">활성 키맵</target>
        </trans-unit>
        <trans-unit id="8bae209835d078ba1a2b628e6a1e2a530501a3e6" translate="yes" xml:space="preserve">
          <source>Adapting code using the old defadvice</source>
          <target state="translated">이전 defadvice를 사용하여 코드 조정</target>
        </trans-unit>
        <trans-unit id="fb2cba4aab141960fa84cebe7cdaa1f7b5ca40f1" translate="yes" xml:space="preserve">
          <source>Adapting code using the old defadvice.</source>
          <target state="translated">이전 defadvice를 사용하여 코드 조정.</target>
        </trans-unit>
        <trans-unit id="d3aca0f70608cde924c0c717aa6f76cc5b6dd2c8" translate="yes" xml:space="preserve">
          <source>Adaptive Fill Mode</source>
          <target state="translated">적응 형 채우기 모드</target>
        </trans-unit>
        <trans-unit id="ad3177b884766938f06c1f5cfe5f60876bbecbb6" translate="yes" xml:space="preserve">
          <source>Adaptive Fill mode chooses a fill prefix from context.</source>
          <target state="translated">적응 형 채우기 모드는 컨텍스트에서 채우기 접두사를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="45867255fd797585e4916e018bbccee9a35d212f" translate="yes" xml:space="preserve">
          <source>Adaptive Fill mode is enabled when this variable is non-&lt;code&gt;nil&lt;/code&gt;. It is &lt;code&gt;t&lt;/code&gt; by default.</source>
          <target state="translated">이 변수가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 적응 형 채우기 모드가 활성화됩니다 . 그것은이다 &lt;code&gt;t&lt;/code&gt; 을 기본적으로.</target>
        </trans-unit>
        <trans-unit id="41fe7af53eab5acab9f4d23fedd7b9d027e07088" translate="yes" xml:space="preserve">
          <source>Adaptive Fill mode matches this regular expression against the text starting after the left margin whitespace (if any) on a line; the characters it matches are that line&amp;rsquo;s candidate for the fill prefix.</source>
          <target state="translated">적응 형 채우기 모드는 한 줄의 왼쪽 여백 공백 (있는 경우) 뒤에서 시작하는 텍스트에 대해이 정규식을 일치시킵니다. 일치하는 문자는 채우기 접두사에 대한 해당 줄의 후보입니다.</target>
        </trans-unit>
        <trans-unit id="1298942391d0f9524543f2b581a0f4733a3cd521" translate="yes" xml:space="preserve">
          <source>Add &lt;var&gt;child&lt;/var&gt; to &lt;var&gt;node&lt;/var&gt;&amp;rsquo;s child list before the &lt;var&gt;before&lt;/var&gt; node. If &lt;var&gt;before&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, make &lt;var&gt;child&lt;/var&gt; the first child.</source>
          <target state="translated">추가 &lt;var&gt;child&lt;/var&gt; 에 &lt;var&gt;node&lt;/var&gt; 전과의 자식 목록을 &lt;var&gt;before&lt;/var&gt; 노드입니다. 만약 &lt;var&gt;before&lt;/var&gt; 이다 &lt;code&gt;nil&lt;/code&gt; , 메이크업의 &lt;var&gt;child&lt;/var&gt; 첫 번째 자식.</target>
        </trans-unit>
        <trans-unit id="86a8c842c5f2e03db4ed77dc6cfb42a4e1d59a0e" translate="yes" xml:space="preserve">
          <source>Add a clipping path to &lt;var&gt;svg&lt;/var&gt;. If applied to a shape via the &lt;var&gt;:clip-path&lt;/var&gt; property, parts of that shape which lie outside of the clipping path are not drawn.</source>
          <target state="translated">&lt;var&gt;svg&lt;/var&gt; 에 클리핑 경로를 추가합니다 . &lt;var&gt;:clip-path&lt;/var&gt; 속성을 통해 모양에 적용 하면 클리핑 경로 외부에있는 모양의 일부는 그려지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ca2976f450cc856aed523c528c25b64c84e61f8c" translate="yes" xml:space="preserve">
          <source>Add a function to &lt;code&gt;font-lock-extend-region-functions&lt;/code&gt; that does the &lt;em&gt;identification&lt;/em&gt; and extends the scan so that the scanned text never starts or ends in the middle of a multiline construct.</source>
          <target state="translated">에 기능을 추가 &lt;code&gt;font-lock-extend-region-functions&lt;/code&gt; 않습니다 &lt;em&gt;식별&lt;/em&gt; 및 스캔 한 텍스트가 시작되지 또는 여러 구조의 중간에 끝 결코 스캔 정도 확장합니다.</target>
        </trans-unit>
        <trans-unit id="2437c12b4ee8245aff3c6e915602340a5cb79372" translate="yes" xml:space="preserve">
          <source>Add a polygon to &lt;var&gt;svg&lt;/var&gt; where &lt;var&gt;points&lt;/var&gt; is a list of X/Y pairs that describe the outer circumference of the polygon.</source>
          <target state="translated">&lt;var&gt;svg&lt;/var&gt; 에 다각형을 추가합니다. 여기서 &lt;var&gt;points&lt;/var&gt; 은 다각형의 외부 원주를 설명하는 X / Y 쌍 목록입니다.</target>
        </trans-unit>
        <trans-unit id="d0cd8a519df07a3ed1321bd58a41305e60e7eb92" translate="yes" xml:space="preserve">
          <source>Add a watch for filesystem events pertaining to &lt;var&gt;file&lt;/var&gt;. This arranges for filesystem events pertaining to &lt;var&gt;file&lt;/var&gt; to be reported to Emacs.</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt; 에 관련된 파일 시스템 이벤트에 대한 감시를 추가 합니다 . 이것은 &lt;var&gt;file&lt;/var&gt; 과 관련된 파일 시스템 이벤트 가 Emacs에보고되도록 배열합니다 .</target>
        </trans-unit>
        <trans-unit id="e14f3bd4b7856be2d474146674d049259534d312" translate="yes" xml:space="preserve">
          <source>Add an element to &lt;code&gt;minor-mode-alist&lt;/code&gt; for each minor mode (see &lt;a href=&quot;mode-line-variables#Definition-of-minor_002dmode_002dalist&quot;&gt;Definition of minor-mode-alist&lt;/a&gt;), if you want to indicate the minor mode in the mode line. This element should be a list of the following form:</source>
          <target state="translated">모드 행에서 부 모드를 표시하려면 각 부 모드에 대해 부 모드 &lt;code&gt;minor-mode-alist&lt;/code&gt; 에 요소를 추가 하십시오 (부 모드 앨리스트 &lt;a href=&quot;mode-line-variables#Definition-of-minor_002dmode_002dalist&quot;&gt;정의&lt;/a&gt; 참조 ). 이 요소는 다음 형식의 목록이어야합니다.</target>
        </trans-unit>
        <trans-unit id="7cff03d7e41619c195637edc380375b892f0845c" translate="yes" xml:space="preserve">
          <source>Add an embedded (raster) image to &lt;var&gt;svg&lt;/var&gt;. If &lt;var&gt;datap&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, &lt;var&gt;image&lt;/var&gt; should be a file name; otherwise it should be a string containing the image data as raw bytes. &lt;var&gt;image-type&lt;/var&gt; should be a</source>
          <target state="translated">포함 된 (래스터) 이미지를 &lt;var&gt;svg&lt;/var&gt; 에 추가합니다 . 경우 &lt;var&gt;datap&lt;/var&gt; 있다 &lt;code&gt;nil&lt;/code&gt; , &lt;var&gt;image&lt;/var&gt; 파일 이름이어야합니다; 그렇지 않으면 이미지 데이터를 원시 바이트로 포함하는 문자열이어야합니다. &lt;var&gt;image-type&lt;/var&gt; 은</target>
        </trans-unit>
        <trans-unit id="a711fa29586567ced283637a07f291daf9eccd20" translate="yes" xml:space="preserve">
          <source>Add line breaks and indentation to the top-level Lisp form at point to make it more readable.</source>
          <target state="translated">더 쉽게 읽을 수 있도록 지점에서 최상위 Lisp 양식에 줄 바꿈 및 들여 쓰기를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="4d943f97d99246a36fad53c87be01c95f3a766cf" translate="yes" xml:space="preserve">
          <source>Add the advice &lt;var&gt;function&lt;/var&gt; to the named function &lt;var&gt;symbol&lt;/var&gt;. &lt;var&gt;where&lt;/var&gt; and &lt;var&gt;props&lt;/var&gt; have the same meaning as for &lt;code&gt;add-function&lt;/code&gt; (see &lt;a href=&quot;core-advising-primitives#Core-Advising-Primitives&quot;&gt;Core Advising Primitives&lt;/a&gt;).</source>
          <target state="translated">명명 된 함수 &lt;var&gt;symbol&lt;/var&gt; advice &lt;var&gt;function&lt;/var&gt; 를 추가합니다 . &lt;var&gt;where&lt;/var&gt; 및 &lt;var&gt;props&lt;/var&gt; 는 &lt;code&gt;add-function&lt;/code&gt; 과 동일한 의미를 갖습니다 ( &lt;a href=&quot;core-advising-primitives#Core-Advising-Primitives&quot;&gt;Core Advising Primitives&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="83a774fd7318f04762e68de4e2b137225620ce7f" translate="yes" xml:space="preserve">
          <source>Add the custom node &lt;var&gt;tag&lt;/var&gt; to &lt;var&gt;svg&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;svg&lt;/var&gt; 에 사용자 정의 노드 &lt;var&gt;tag&lt;/var&gt; 를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="3861b616706cb862303f0503ef614aace33c9de7" translate="yes" xml:space="preserve">
          <source>Add the outline of a shape to &lt;var&gt;svg&lt;/var&gt; according to &lt;var&gt;commands&lt;/var&gt;, see &lt;a href=&quot;#SVG-Path-Commands&quot;&gt;SVG Path Commands&lt;/a&gt;.</source>
          <target state="translated">&lt;var&gt;commands&lt;/var&gt; 에 따라 &lt;var&gt;svg&lt;/var&gt; 에 모양의 외곽선을 추가합니다 . &lt;a href=&quot;#SVG-Path-Commands&quot;&gt;SVG 경로 명령을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9913c193acde9c02d5ae3b24bc390ab6d78afa81" translate="yes" xml:space="preserve">
          <source>Add the specified &lt;var&gt;text&lt;/var&gt; to &lt;var&gt;svg&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;svg&lt;/var&gt; 에 지정된 &lt;var&gt;text&lt;/var&gt; 를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="8aacc8a54a520b2ac614e1a90f78fb2eedfee11f" translate="yes" xml:space="preserve">
          <source>Add to &lt;var&gt;svg&lt;/var&gt; a circle whose center is at &lt;var&gt;x&lt;/var&gt;/&lt;var&gt;y&lt;/var&gt; and whose radius is &lt;var&gt;radius&lt;/var&gt;.</source>
          <target state="translated">중심이 &lt;var&gt;x&lt;/var&gt; / &lt;var&gt;y&lt;/var&gt; 이고 반경이 &lt;var&gt;radius&lt;/var&gt; 인 원 을 &lt;var&gt;svg&lt;/var&gt; 에 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="4fe52fae4d07b75457a9542137a4b9b5c60d0aef" translate="yes" xml:space="preserve">
          <source>Add to &lt;var&gt;svg&lt;/var&gt; a line that starts at &lt;var&gt;x1&lt;/var&gt;/&lt;var&gt;y1&lt;/var&gt; and extends to &lt;var&gt;x2&lt;/var&gt;/&lt;var&gt;y2&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;x1&lt;/var&gt; / &lt;var&gt;y1&lt;/var&gt; 에서 시작 하여 &lt;var&gt;x2&lt;/var&gt; / &lt;var&gt;y2&lt;/var&gt; 까지 확장 되는 줄 을 &lt;var&gt;svg&lt;/var&gt; 에 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="6a286d1f3e95235d9468003833dcabc092caa2e1" translate="yes" xml:space="preserve">
          <source>Add to &lt;var&gt;svg&lt;/var&gt; a multiple-segment line (a.k.a. &amp;ldquo;polyline&amp;rdquo;) that goes through &lt;var&gt;points&lt;/var&gt;, which is a list of X/Y position pairs.</source>
          <target state="translated">&lt;var&gt;svg&lt;/var&gt; 에 X / Y 위치 쌍 목록 인 &lt;var&gt;points&lt;/var&gt; 통과하는 다중 세그먼트 선 (일명 &quot;폴리 라인&quot;)을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="565a0d4084aef376e27a550cb97be439640f51cd" translate="yes" xml:space="preserve">
          <source>Add to &lt;var&gt;svg&lt;/var&gt; a rectangle whose upper left corner is at position &lt;var&gt;x&lt;/var&gt;/&lt;var&gt;y&lt;/var&gt; and whose size is &lt;var&gt;width&lt;/var&gt;/&lt;var&gt;height&lt;/var&gt;.</source>
          <target state="translated">왼쪽 위 모서리가 &lt;var&gt;x&lt;/var&gt; / &lt;var&gt;y&lt;/var&gt; 위치에 있고 크기가 &lt;var&gt;width&lt;/var&gt; / &lt;var&gt;height&lt;/var&gt; 인 사각형 을 &lt;var&gt;svg&lt;/var&gt; 에 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="f117e38663daed515f31d78095890b69b59541be" translate="yes" xml:space="preserve">
          <source>Add to &lt;var&gt;svg&lt;/var&gt; an ellipse whose center is at &lt;var&gt;x&lt;/var&gt;/&lt;var&gt;y&lt;/var&gt;, and whose horizontal radius is &lt;var&gt;x-radius&lt;/var&gt; and the vertical radius is &lt;var&gt;y-radius&lt;/var&gt;.</source>
          <target state="translated">중심이 &lt;var&gt;x&lt;/var&gt; / &lt;var&gt;y&lt;/var&gt; 에 있고 수평 반경이 &lt;var&gt;x-radius&lt;/var&gt; 이고 수직 반경이 &lt;var&gt;y-radius&lt;/var&gt; 인 타원 을 &lt;var&gt;svg&lt;/var&gt; 에 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="a72995a8fcd466eb526d56641ee9c271fda926c9" translate="yes" xml:space="preserve">
          <source>Adding additional information about a function.</source>
          <target state="translated">기능에 대한 추가 정보를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="8d9d382c9e9984ab00e1fba4ef0f8c1158adf2d5" translate="yes" xml:space="preserve">
          <source>Adding buttons to Emacs buffers.</source>
          <target state="translated">Emacs 버퍼에 버튼 추가.</target>
        </trans-unit>
        <trans-unit id="53b2f670a3f5ad65cee3f0da686a14d79f042bed" translate="yes" xml:space="preserve">
          <source>Adding clickable buttons to Emacs buffers.</source>
          <target state="translated">Emacs 버퍼에 클릭 가능한 버튼 추가.</target>
        </trans-unit>
        <trans-unit id="4679096d507cd2c89ee536f4f3c0706150098e70" translate="yes" xml:space="preserve">
          <source>Adding new text to a buffer.</source>
          <target state="translated">버퍼에 새 텍스트 추가.</target>
        </trans-unit>
        <trans-unit id="95751041c5c1654a609b5b64e61a15f9bddb79a0" translate="yes" xml:space="preserve">
          <source>Adding to the definition of a function.</source>
          <target state="translated">함수 정의에 추가.</target>
        </trans-unit>
        <trans-unit id="58b99f3d38ede1597b9ac02693be3ab80822e821" translate="yes" xml:space="preserve">
          <source>Adding, subtracting, comparing times, etc.</source>
          <target state="translated">시간 더하기, 빼기, 비교하기 등</target>
        </trans-unit>
        <trans-unit id="500196012d89f448a3af179ba361faa20093707c" translate="yes" xml:space="preserve">
          <source>Additional Options for Displaying Buffers</source>
          <target state="translated">버퍼 표시를위한 추가 옵션</target>
        </trans-unit>
        <trans-unit id="58c09d8cc944ca4e37be6c32b0108073f18357b2" translate="yes" xml:space="preserve">
          <source>Additional alist entries may be defined in the future.</source>
          <target state="translated">추가 목록 항목은 향후 정의 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a22e777afc57137b40767d7ea63841431e6d681d" translate="yes" xml:space="preserve">
          <source>Additional customization facilities.</source>
          <target state="translated">추가 사용자 지정 기능.</target>
        </trans-unit>
        <trans-unit id="d931ed9a4962a5016c462de8f0c48ae86a47f189" translate="yes" xml:space="preserve">
          <source>Additional flags each character can have.</source>
          <target state="translated">각 캐릭터가 가질 수있는 추가 플래그.</target>
        </trans-unit>
        <trans-unit id="94e8d86d4f239006083ee80460e98ca2f47369d1" translate="yes" xml:space="preserve">
          <source>Additional image properties supported for the &lt;code&gt;xbm&lt;/code&gt; image type are:</source>
          <target state="translated">&lt;code&gt;xbm&lt;/code&gt; 이미지 유형에 대해 지원되는 추가 이미지 속성 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6431dff5a05dff6ce51567fbc49ea8750d45e21d" translate="yes" xml:space="preserve">
          <source>Additional keypad duplicates of keys ordinarily found elsewhere. Emacs normally translates these into the like-named non-keypad keys.</source>
          <target state="translated">일반적으로 다른 곳에서 발견되는 키의 추가 키패드 중복. Emacs는 일반적으로 이것을 비슷한 이름의 비 키패드 키로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="6338a470de402714fad49d59e574ee2a004eb402" translate="yes" xml:space="preserve">
          <source>Additional relevant functions for net connections.</source>
          <target state="translated">네트워크 연결에 대한 추가 관련 기능.</target>
        </trans-unit>
        <trans-unit id="3c7e388f967fe300edc4c7b897df6b058218b157" translate="yes" xml:space="preserve">
          <source>Additional space to leave below each text line, in pixels (a positive integer). See &lt;a href=&quot;line-height#Line-Height&quot;&gt;Line Height&lt;/a&gt;, for more information.</source>
          <target state="translated">각 텍스트 줄 아래에 남겨 둘 추가 공간 (픽셀 단위) (양의 정수). 자세한 내용은 &lt;a href=&quot;line-height#Line-Height&quot;&gt;선 높이&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b1fd54e2342c288944104eeefd68ecbc3f125806" translate="yes" xml:space="preserve">
          <source>Additional typographic style information for the font, such as &amp;lsquo;</source>
          <target state="translated">글꼴에 대한 추가 인쇄 스타일 정보 (예 : '</target>
        </trans-unit>
        <trans-unit id="ee273060f190cc74f93860343b827ad47759d5a0" translate="yes" xml:space="preserve">
          <source>Additionally, C code can modify the value of variables directly, bypassing the watchpoint mechanism.</source>
          <target state="translated">또한 C 코드는 감시 점 메커니즘을 우회하여 변수 값을 직접 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8a4e955fb763f3e97efcc9f314ccd7894853f87" translate="yes" xml:space="preserve">
          <source>Additionally, arrange to display &lt;var&gt;doc&lt;/var&gt; along with the docstring of &lt;code&gt;pcase&lt;/code&gt;. By convention, &lt;var&gt;doc&lt;/var&gt; should use &lt;code&gt;EXPVAL&lt;/code&gt; to stand for the result of evaluating &lt;var&gt;expression&lt;/var&gt; (first arg to &lt;code&gt;pcase&lt;/code&gt;).</source>
          <target state="translated">또한 &lt;code&gt;pcase&lt;/code&gt; 의 독 스트링 과 함께 &lt;var&gt;doc&lt;/var&gt; 를 표시하도록 정렬합니다 . 관례에 따라 &lt;var&gt;doc&lt;/var&gt; 은 &lt;code&gt;EXPVAL&lt;/code&gt; 을 사용 하여 &lt;var&gt;expression&lt;/var&gt; 평가 결과 를 &lt;code&gt;pcase&lt;/code&gt; 합니다 (첫 번째 인수에서 pcase로 ).</target>
        </trans-unit>
        <trans-unit id="21af65202f21fc2dc93653ae03092063c5b61dff" translate="yes" xml:space="preserve">
          <source>Additionally, conflicts can occur:</source>
          <target state="translated">또한 충돌이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e75498292efb2e16310b12aff15b14972a22b009" translate="yes" xml:space="preserve">
          <source>Additionally, the &lt;var&gt;collection&lt;/var&gt; should generally not be pre-filtered based on the current text between &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt;, because that is the responsibility of the caller of &lt;code&gt;completion-at-point-functions&lt;/code&gt; to do that according to the completion styles it decides to use.</source>
          <target state="translated">또한 &lt;var&gt;collection&lt;/var&gt; 은 일반적으로 &lt;var&gt;start&lt;/var&gt; 와 &lt;var&gt;end&lt;/var&gt; 사이의 현재 텍스트를 기반으로 사전 필터링되지 않아야 합니다. 이는 사용하기로 결정한 완료 스타일에 따라 완료 &lt;code&gt;completion-at-point-functions&lt;/code&gt; 호출자의 책임이기 때문입니다 .</target>
        </trans-unit>
        <trans-unit id="82ec8503880130af95fe77d33f6e32d8d45be1c7" translate="yes" xml:space="preserve">
          <source>Adjustable Tab Stops</source>
          <target state="translated">조절 가능한 탭 스톱</target>
        </trans-unit>
        <trans-unit id="cce71d8b4de0fbe7b1d1416d923c41d53c78a09c" translate="yes" xml:space="preserve">
          <source>Adjustable, typewriter-like tab stops.</source>
          <target state="translated">조정 가능한 타자기 모양의 탭 스톱.</target>
        </trans-unit>
        <trans-unit id="3b315ad397f4b4a0ed97547b767a1277549aaf87" translate="yes" xml:space="preserve">
          <source>Adjusting Point After Commands</source>
          <target state="translated">Adjusting Point After Commands</target>
        </trans-unit>
        <trans-unit id="9a61906e01d69a6bb351e657b21352956d8d32ce" translate="yes" xml:space="preserve">
          <source>Adjustment of point after a command.</source>
          <target state="translated">Adjustment of point after a command.</target>
        </trans-unit>
        <trans-unit id="e59f2f2723f7c1f609f3550bb2671a6cb90986fe" translate="yes" xml:space="preserve">
          <source>Advice and coding conventions for Emacs Lisp.</source>
          <target state="translated">Advice and coding conventions for Emacs Lisp.</target>
        </trans-unit>
        <trans-unit id="40d1b99315ff674405912fd3cc10e5b67c67dd32" translate="yes" xml:space="preserve">
          <source>Advising Emacs Lisp Functions</source>
          <target state="translated">Advising Emacs Lisp Functions</target>
        </trans-unit>
        <trans-unit id="7d52de2eb6adab7304f81575e610e6fdaba9cc2d" translate="yes" xml:space="preserve">
          <source>Advising Named Functions</source>
          <target state="translated">Advising Named Functions</target>
        </trans-unit>
        <trans-unit id="ab277db91341f63fab17a1c61d2a97a801877f92" translate="yes" xml:space="preserve">
          <source>Advising named functions.</source>
          <target state="translated">Advising named functions.</target>
        </trans-unit>
        <trans-unit id="79ba5e1b3f99abfd54ef8d839ba12bd2ac4d79cb" translate="yes" xml:space="preserve">
          <source>After</source>
          <target state="translated">After</target>
        </trans-unit>
        <trans-unit id="2001d34da0f06a489ff0edce787794897f4aeb55" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;set-text-properties&lt;/code&gt; returns, all the characters in the specified range have identical properties.</source>
          <target state="translated">After &lt;code&gt;set-text-properties&lt;/code&gt; returns, all the characters in the specified range have identical properties.</target>
        </trans-unit>
        <trans-unit id="26622072ea6b71fa07e70b43c76041b80e7e5a30" translate="yes" xml:space="preserve">
          <source>After Emacs changes a file, there are two reasons the changes might not survive later failures of power or media, both having to do with efficiency. First, the operating system might alias written data with data already stored elsewhere on secondary storage until one file or the other is later modified; this will lose both files if the only copy on secondary storage is lost due to media failure. Second, the operating system might not write data to secondary storage immediately, which will lose the data if power is lost.</source>
          <target state="translated">After Emacs changes a file, there are two reasons the changes might not survive later failures of power or media, both having to do with efficiency. First, the operating system might alias written data with data already stored elsewhere on secondary storage until one file or the other is later modified; this will lose both files if the only copy on secondary storage is lost due to media failure. Second, the operating system might not write data to secondary storage immediately, which will lose the data if power is lost.</target>
        </trans-unit>
        <trans-unit id="9f89518425e409284cb01cc7c3c6a1775a6a510d" translate="yes" xml:space="preserve">
          <source>After Emacs reads your init file, it initializes &lt;code&gt;auto-save-list-file-name&lt;/code&gt; (if you have not already set it non-&lt;code&gt;nil&lt;/code&gt;) based on this prefix, adding the host name and process ID. If you set this to &lt;code&gt;nil&lt;/code&gt; in your init file, then Emacs does not initialize &lt;code&gt;auto-save-list-file-name&lt;/code&gt;.</source>
          <target state="translated">After Emacs reads your init file, it initializes &lt;code&gt;auto-save-list-file-name&lt;/code&gt; (if you have not already set it non- &lt;code&gt;nil&lt;/code&gt; ) based on this prefix, adding the host name and process ID. If you set this to &lt;code&gt;nil&lt;/code&gt; in your init file, then Emacs does not initialize &lt;code&gt;auto-save-list-file-name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c6d6ee5d7d9a1dbc90deb665a4ae3ffff4b1c578" translate="yes" xml:space="preserve">
          <source>After Font Lock evaluates &lt;var&gt;pre-form&lt;/var&gt;, it does not search for &lt;var&gt;anchored-matcher&lt;/var&gt; beyond the end of the line. However, if &lt;var&gt;pre-form&lt;/var&gt; returns a buffer position that is greater than the position of point after &lt;var&gt;pre-form&lt;/var&gt; is evaluated, then the position returned by &lt;var&gt;pre-form&lt;/var&gt; is used as the limit of the search instead. It is generally a bad idea to return a position greater than the end of the line; in other words, the &lt;var&gt;anchored-matcher&lt;/var&gt; search should not span lines.</source>
          <target state="translated">After Font Lock evaluates &lt;var&gt;pre-form&lt;/var&gt; , it does not search for &lt;var&gt;anchored-matcher&lt;/var&gt; beyond the end of the line. However, if &lt;var&gt;pre-form&lt;/var&gt; returns a buffer position that is greater than the position of point after &lt;var&gt;pre-form&lt;/var&gt; is evaluated, then the position returned by &lt;var&gt;pre-form&lt;/var&gt; is used as the limit of the search instead. It is generally a bad idea to return a position greater than the end of the line; in other words, the &lt;var&gt;anchored-matcher&lt;/var&gt; search should not span lines.</target>
        </trans-unit>
        <trans-unit id="0d5f3b64280f526c25116915081cc07a4ccb40b7" translate="yes" xml:space="preserve">
          <source>After a &lt;em&gt;synchronous process&lt;/em&gt; is created, Emacs waits for the process to terminate before continuing. Starting Dired on GNU or Unix&lt;a href=&quot;#FOOT21&quot; name=&quot;DOCF21&quot;&gt;&lt;sup&gt;21&lt;/sup&gt;&lt;/a&gt; is an example of this: it runs &lt;code&gt;ls&lt;/code&gt; in a synchronous process, then modifies the output slightly. Because the process is synchronous, the entire directory listing arrives in the buffer before Emacs tries to do anything with it.</source>
          <target state="translated">After a &lt;em&gt;synchronous process&lt;/em&gt; is created, Emacs waits for the process to terminate before continuing. Starting Dired on GNU or Unix&lt;a href=&quot;#FOOT21&quot; name=&quot;DOCF21&quot;&gt;&lt;sup&gt;21&lt;/sup&gt;&lt;/a&gt; is an example of this: it runs &lt;code&gt;ls&lt;/code&gt; in a synchronous process, then modifies the output slightly. Because the process is synchronous, the entire directory listing arrives in the buffer before Emacs tries to do anything with it.</target>
        </trans-unit>
        <trans-unit id="79d05caca5759ed0ecaf87a1fc890988221544d6" translate="yes" xml:space="preserve">
          <source>After adding this advice, if you call &lt;code&gt;my-double&lt;/code&gt; with &amp;lsquo;</source>
          <target state="translated">After adding this advice, if you call &lt;code&gt;my-double&lt;/code&gt; with &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="b482ecda0086b5db531f75dfdba2467dc5429ef2" translate="yes" xml:space="preserve">
          <source>After an inline function is defined, its inline expansion can be performed later on in the same file, just like macros.</source>
          <target state="translated">After an inline function is defined, its inline expansion can be performed later on in the same file, just like macros.</target>
        </trans-unit>
        <trans-unit id="1711c03422a1600eb8ad808ec0bc8cf24123cdd2" translate="yes" xml:space="preserve">
          <source>After defining &lt;var&gt;name&lt;/var&gt; in this way, you can use it as the &lt;var&gt;test&lt;/var&gt; argument in &lt;code&gt;make-hash-table&lt;/code&gt;. When you do that, the hash table will use &lt;var&gt;test-fn&lt;/var&gt; to compare key values, and &lt;var&gt;hash-fn&lt;/var&gt; to compute a hash code from a key value.</source>
          <target state="translated">After defining &lt;var&gt;name&lt;/var&gt; in this way, you can use it as the &lt;var&gt;test&lt;/var&gt; argument in &lt;code&gt;make-hash-table&lt;/code&gt; . When you do that, the hash table will use &lt;var&gt;test-fn&lt;/var&gt; to compare key values, and &lt;var&gt;hash-fn&lt;/var&gt; to compute a hash code from a key value.</target>
        </trans-unit>
        <trans-unit id="cb84be952166d7a786e0f5810ef1b95aefca141b" translate="yes" xml:space="preserve">
          <source>After executing the body of the handler, the &lt;code&gt;condition-case&lt;/code&gt; returns normally, using the value of the last form in the handler body as the overall value.</source>
          <target state="translated">After executing the body of the handler, the &lt;code&gt;condition-case&lt;/code&gt; returns normally, using the value of the last form in the handler body as the overall value.</target>
        </trans-unit>
        <trans-unit id="4dcf95c5a0c487e8209e489fa588abd672d9e8b8" translate="yes" xml:space="preserve">
          <source>After execution of the handler body, execution returns from the &lt;code&gt;condition-case&lt;/code&gt; form. Because the protected form is exited completely before execution of the handler, the handler cannot resume execution at the point of the error, nor can it examine variable bindings that were made within the protected form. All it can do is clean up and proceed.</source>
          <target state="translated">After execution of the handler body, execution returns from the &lt;code&gt;condition-case&lt;/code&gt; form. Because the protected form is exited completely before execution of the handler, the handler cannot resume execution at the point of the error, nor can it examine variable bindings that were made within the protected form. All it can do is clean up and proceed.</target>
        </trans-unit>
        <trans-unit id="f9f96cc122b695225532f65f8c1dc5af1dd81ad0" translate="yes" xml:space="preserve">
          <source>After installation, the installed package is &lt;em&gt;loaded&lt;/em&gt;: Emacs adds the package&amp;rsquo;s content directory to &lt;code&gt;load-path&lt;/code&gt;, and evaluates the autoload definitions in</source>
          <target state="translated">After installation, the installed package is &lt;em&gt;loaded&lt;/em&gt;: Emacs adds the package&amp;rsquo;s content directory to &lt;code&gt;load-path&lt;/code&gt; , and evaluates the autoload definitions in</target>
        </trans-unit>
        <trans-unit id="7d8f54422101c3e253d2eea8938b01fa0aa88a65" translate="yes" xml:space="preserve">
          <source>After moving point, you may wish to jump back to the stop point. You can do that with</source>
          <target state="translated">After moving point, you may wish to jump back to the stop point. You can do that with</target>
        </trans-unit>
        <trans-unit id="70f30068f24e099728f9220f33c66de8c45b3661" translate="yes" xml:space="preserve">
          <source>After selecting</source>
          <target state="translated">After selecting</target>
        </trans-unit>
        <trans-unit id="6b47650b2f0eeaae057157d2f6dba970bba4bcc2" translate="yes" xml:space="preserve">
          <source>After substitution, if a &amp;lsquo;</source>
          <target state="translated">After substitution, if a &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="11efe5f0fdddc5460cc69a92a923925429424bb2" translate="yes" xml:space="preserve">
          <source>After switching windows or buffers, and in some other cases, if the window start is in the middle of a line, Emacs adjusts the window start to the start of a line. This prevents certain operations from leaving the window start at a meaningless point within a line. This feature may interfere with testing some Lisp code by executing it using the commands of Lisp mode, because they trigger this readjustment. To test such code, put it into a command and bind the command to a key.</source>
          <target state="translated">After switching windows or buffers, and in some other cases, if the window start is in the middle of a line, Emacs adjusts the window start to the start of a line. This prevents certain operations from leaving the window start at a meaningless point within a line. This feature may interfere with testing some Lisp code by executing it using the commands of Lisp mode, because they trigger this readjustment. To test such code, put it into a command and bind the command to a key.</target>
        </trans-unit>
        <trans-unit id="495827ab1d768e91f37fdef6604e6f5836895698" translate="yes" xml:space="preserve">
          <source>After that, &lt;var&gt;body&lt;/var&gt; is executed, and the connection-local variables are unwound. Example:</source>
          <target state="translated">After that, &lt;var&gt;body&lt;/var&gt; is executed, and the connection-local variables are unwound. Example:</target>
        </trans-unit>
        <trans-unit id="6ba43c834d967b77f336f5c21c19c92d28a6987a" translate="yes" xml:space="preserve">
          <source>After the &amp;lsquo;</source>
          <target state="translated">After the &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="d9009ae4cb68e38ac581c27d4e2acc4e2c297d9b" translate="yes" xml:space="preserve">
          <source>After the call to the &lt;code&gt;DEFUN&lt;/code&gt; macro, you must write the argument list for the C function, including the types for the arguments. If the primitive accepts a fixed maximum number of Lisp arguments, there must be one C argument for each Lisp argument, and each argument must be of type &lt;code&gt;Lisp_Object&lt;/code&gt;. (Various macros and functions for creating values of type &lt;code&gt;Lisp_Object&lt;/code&gt; are declared in the file</source>
          <target state="translated">After the call to the &lt;code&gt;DEFUN&lt;/code&gt; macro, you must write the argument list for the C function, including the types for the arguments. If the primitive accepts a fixed maximum number of Lisp arguments, there must be one C argument for each Lisp argument, and each argument must be of type &lt;code&gt;Lisp_Object&lt;/code&gt; . (Various macros and functions for creating values of type &lt;code&gt;Lisp_Object&lt;/code&gt; are declared in the file</target>
        </trans-unit>
        <trans-unit id="33d79aff6f896ac6094c3c7ab2c4138388d48ec5" translate="yes" xml:space="preserve">
          <source>After the command loop has translated a key sequence into a command, it invokes that command using the function &lt;code&gt;command-execute&lt;/code&gt;. If the command is a function, &lt;code&gt;command-execute&lt;/code&gt; calls &lt;code&gt;call-interactively&lt;/code&gt;, which reads the arguments and calls the command. You can also call these functions yourself.</source>
          <target state="translated">After the command loop has translated a key sequence into a command, it invokes that command using the function &lt;code&gt;command-execute&lt;/code&gt; . If the command is a function, &lt;code&gt;command-execute&lt;/code&gt; calls &lt;code&gt;call-interactively&lt;/code&gt; , which reads the arguments and calls the command. You can also call these functions yourself.</target>
        </trans-unit>
        <trans-unit id="eb00eb8abe509aa0e806964b17e030d795a6dcae" translate="yes" xml:space="preserve">
          <source>After the file has been loaded, the symbol should have a new function definition that is not an autoload object. The new definition is then called as if it had been there to begin with. From the user&amp;rsquo;s point of view, the function call works as expected, using the function definition in the loaded file.</source>
          <target state="translated">After the file has been loaded, the symbol should have a new function definition that is not an autoload object. The new definition is then called as if it had been there to begin with. From the user&amp;rsquo;s point of view, the function call works as expected, using the function definition in the loaded file.</target>
        </trans-unit>
        <trans-unit id="5e64aa108dd56236b255a2bfaa30873fae10d663" translate="yes" xml:space="preserve">
          <source>After the lines are joined, the function &lt;code&gt;fixup-whitespace&lt;/code&gt; is responsible for deciding whether to leave a space at the junction.</source>
          <target state="translated">After the lines are joined, the function &lt;code&gt;fixup-whitespace&lt;/code&gt; is responsible for deciding whether to leave a space at the junction.</target>
        </trans-unit>
        <trans-unit id="8028d1d381d5b478f2dffeace51ce5901d720198" translate="yes" xml:space="preserve">
          <source>After the terminal is initialized, this is set to the terminal-specific initialization function.</source>
          <target state="translated">After the terminal is initialized, this is set to the terminal-specific initialization function.</target>
        </trans-unit>
        <trans-unit id="c2df18475dff27329715d9ae9944a0845bdbbdd4" translate="yes" xml:space="preserve">
          <source>After these mandatory arguments follow the keyword arguments. The most important is &lt;code&gt;:type&lt;/code&gt;, which describes the data type we want to match with this widget. Here a &lt;code&gt;binary-tree-of-string&lt;/code&gt; is described as being either a string, or a cons-cell whose car and cdr are themselves both &lt;code&gt;binary-tree-of-string&lt;/code&gt;. Note the reference to the widget type we are currently in the process of defining. The &lt;code&gt;:tag&lt;/code&gt; attribute is a string to name the widget in the user interface, and the &lt;code&gt;:offset&lt;/code&gt; argument is there to ensure that child nodes are indented four spaces relative to the parent node, making the tree structure apparent in the customization buffer.</source>
          <target state="translated">After these mandatory arguments follow the keyword arguments. The most important is &lt;code&gt;:type&lt;/code&gt; , which describes the data type we want to match with this widget. Here a &lt;code&gt;binary-tree-of-string&lt;/code&gt; is described as being either a string, or a cons-cell whose car and cdr are themselves both &lt;code&gt;binary-tree-of-string&lt;/code&gt; . Note the reference to the widget type we are currently in the process of defining. The &lt;code&gt;:tag&lt;/code&gt; attribute is a string to name the widget in the user interface, and the &lt;code&gt;:offset&lt;/code&gt; argument is there to ensure that child nodes are indented four spaces relative to the parent node, making the tree structure apparent in the customization buffer.</target>
        </trans-unit>
        <trans-unit id="fdf9c94744bf9492e6805756a0c97707a0c90bae" translate="yes" xml:space="preserve">
          <source>After writing your C code for a module function, you should make a Lisp function object from it using the &lt;code&gt;make_function&lt;/code&gt; function, whose pointer is provided in the environment (recall that the pointer to the environment is returned by &lt;code&gt;get_environment&lt;/code&gt;). This is normally done in the module initialization function (see &lt;a href=&quot;module-initialization#module-initialization-function&quot;&gt;module initialization function&lt;/a&gt;), after verifying the</source>
          <target state="translated">After writing your C code for a module function, you should make a Lisp function object from it using the &lt;code&gt;make_function&lt;/code&gt; function, whose pointer is provided in the environment (recall that the pointer to the environment is returned by &lt;code&gt;get_environment&lt;/code&gt; ). This is normally done in the module initialization function (see &lt;a href=&quot;module-initialization#module-initialization-function&quot;&gt;module initialization function&lt;/a&gt;), after verifying the</target>
        </trans-unit>
        <trans-unit id="01273641f1108e9334b3ff2f2de5aac2328b0349" translate="yes" xml:space="preserve">
          <source>After you activate the change group, any changes you make in that buffer become part of it. Once you have made all the desired changes in the buffer, you must &lt;em&gt;finish&lt;/em&gt; the change group. There are two ways to do this: you can either accept (and finalize) all the changes, or cancel them all.</source>
          <target state="translated">After you activate the change group, any changes you make in that buffer become part of it. Once you have made all the desired changes in the buffer, you must &lt;em&gt;finish&lt;/em&gt; the change group. There are two ways to do this: you can either accept (and finalize) all the changes, or cancel them all.</target>
        </trans-unit>
        <trans-unit id="156a361715177a7a195a547edfc720451b956bc1" translate="yes" xml:space="preserve">
          <source>After you create an archive, remember that it is not accessible in the Package Menu interface unless it is in &lt;code&gt;package-archives&lt;/code&gt;.</source>
          <target state="translated">After you create an archive, remember that it is not accessible in the Package Menu interface unless it is in &lt;code&gt;package-archives&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6177c7642a19bf3ac0b659b32ac63c9a38ada82" translate="yes" xml:space="preserve">
          <source>After you think you have fixed the problem, use</source>
          <target state="translated">After you think you have fixed the problem, use</target>
        </trans-unit>
        <trans-unit id="26afb7a30b02ada3701025dcae553b3342d65c03" translate="yes" xml:space="preserve">
          <source>Alias Menu Items</source>
          <target state="translated">Alias Menu Items</target>
        </trans-unit>
        <trans-unit id="4ecfd05f5c4a9c12f77ec0ab644b70282ba9ee84" translate="yes" xml:space="preserve">
          <source>Alist with elements</source>
          <target state="translated">Alist with elements</target>
        </trans-unit>
        <trans-unit id="4a7098b2dd254466abcb5233fdc2c39c1c9bc767" translate="yes" xml:space="preserve">
          <source>Alists for fine-tuning buffer display.</source>
          <target state="translated">Alists for fine-tuning buffer display.</target>
        </trans-unit>
        <trans-unit id="6a72085653e4c5be8c7640c868ef787cbcf063d1" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">All</target>
        </trans-unit>
        <trans-unit id="a745dcd86b59cafb3c0ca3bc7c385a6602657fcf" translate="yes" xml:space="preserve">
          <source>All &lt;var&gt;exp&lt;/var&gt;s are evaluated first, after which they are matched against their respective &lt;var&gt;pattern&lt;/var&gt;, introducing new variable bindings that can then be used inside &lt;var&gt;body&lt;/var&gt;. The variable bindings are produced by destructuring binding of elements of &lt;var&gt;pattern&lt;/var&gt; to the values of the corresponding elements of the evaluated &lt;var&gt;exp&lt;/var&gt;.</source>
          <target state="translated">All &lt;var&gt;exp&lt;/var&gt; s are evaluated first, after which they are matched against their respective &lt;var&gt;pattern&lt;/var&gt; , introducing new variable bindings that can then be used inside &lt;var&gt;body&lt;/var&gt; . The variable bindings are produced by destructuring binding of elements of &lt;var&gt;pattern&lt;/var&gt; to the values of the corresponding elements of the evaluated &lt;var&gt;exp&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="aa4b6e4b0a07d4d70f84e83caad6fff48d32fad3" translate="yes" xml:space="preserve">
          <source>All Emacs Lisp arrays are one-dimensional. (Most other programming languages support multidimensional arrays, but they are not essential; you can get the same effect with nested one-dimensional arrays.) Each type of array has its own read syntax; see the following sections for details.</source>
          <target state="translated">All Emacs Lisp arrays are one-dimensional. (Most other programming languages support multidimensional arrays, but they are not essential; you can get the same effect with nested one-dimensional arrays.) Each type of array has its own read syntax; see the following sections for details.</target>
        </trans-unit>
        <trans-unit id="78dab1ef3770dfe21362526370a14bdcd828cdca" translate="yes" xml:space="preserve">
          <source>All arguments are instrumented for evaluation.</source>
          <target state="translated">All arguments are instrumented for evaluation.</target>
        </trans-unit>
        <trans-unit id="b6a1d847b868b0a62fa982b38796821b2fb0c23f" translate="yes" xml:space="preserve">
          <source>All arguments are numbers. Floating-point arguments can be tricky, because floating-point arithmetic is inexact. For instance, depending on the machine, it may quite well happen that &lt;code&gt;(number-sequence 0.4 0.6 0.2)&lt;/code&gt; returns the one element list &lt;code&gt;(0.4)&lt;/code&gt;, whereas &lt;code&gt;(number-sequence 0.4 0.8 0.2)&lt;/code&gt; returns a list with three elements. The &lt;var&gt;n&lt;/var&gt;th element of the list is computed by the exact formula &lt;code&gt;(+ &lt;var&gt;from&lt;/var&gt; (* &lt;var&gt;n&lt;/var&gt; &lt;var&gt;separation&lt;/var&gt;))&lt;/code&gt;. Thus, if one wants to make sure that &lt;var&gt;to&lt;/var&gt; is included in the list, one can pass an expression of this exact type for &lt;var&gt;to&lt;/var&gt;. Alternatively, one can replace &lt;var&gt;to&lt;/var&gt; with a slightly larger value (or a slightly more negative value if &lt;var&gt;separation&lt;/var&gt; is negative).</source>
          <target state="translated">All arguments are numbers. Floating-point arguments can be tricky, because floating-point arithmetic is inexact. For instance, depending on the machine, it may quite well happen that &lt;code&gt;(number-sequence 0.4 0.6 0.2)&lt;/code&gt; returns the one element list &lt;code&gt;(0.4)&lt;/code&gt; , whereas &lt;code&gt;(number-sequence 0.4 0.8 0.2)&lt;/code&gt; returns a list with three elements. The &lt;var&gt;n&lt;/var&gt; th element of the list is computed by the exact formula &lt;code&gt;(+ &lt;var&gt;from&lt;/var&gt; (* &lt;var&gt;n&lt;/var&gt; &lt;var&gt;separation&lt;/var&gt;))&lt;/code&gt; . Thus, if one wants to make sure that &lt;var&gt;to&lt;/var&gt; is included in the list, one can pass an expression of this exact type for &lt;var&gt;to&lt;/var&gt; . Alternatively, one can replace &lt;var&gt;to&lt;/var&gt; with a slightly larger value (or a slightly more negative value if &lt;var&gt;separation&lt;/var&gt; is negative).</target>
        </trans-unit>
        <trans-unit id="2208c34161ce80d7a782807d1e4cec6e6a7dd001" translate="yes" xml:space="preserve">
          <source>All breakpoints in a definition are forgotten each time you reinstrument it. If you wish to make a breakpoint that won&amp;rsquo;t be forgotten, you can write a &lt;em&gt;source breakpoint&lt;/em&gt;, which is simply a call to the function &lt;code&gt;edebug&lt;/code&gt; in your source code. You can, of course, make such a call conditional. For example, in the &lt;code&gt;fac&lt;/code&gt; function, you can insert the first line as shown below, to stop when the argument reaches zero:</source>
          <target state="translated">All breakpoints in a definition are forgotten each time you reinstrument it. If you wish to make a breakpoint that won&amp;rsquo;t be forgotten, you can write a &lt;em&gt;source breakpoint&lt;/em&gt;, which is simply a call to the function &lt;code&gt;edebug&lt;/code&gt; in your source code. You can, of course, make such a call conditional. For example, in the &lt;code&gt;fac&lt;/code&gt; function, you can insert the first line as shown below, to stop when the argument reaches zero:</target>
        </trans-unit>
        <trans-unit id="9bb2b7fe1708d34d491b12dd030e589c31b4ac12" translate="yes" xml:space="preserve">
          <source>All built-in functions do check the types of their actual arguments when appropriate, and signal a &lt;code&gt;wrong-type-argument&lt;/code&gt; error if an argument is of the wrong type. For example, here is what happens if you pass an argument to &lt;code&gt;+&lt;/code&gt; that it cannot handle:</source>
          <target state="translated">All built-in functions do check the types of their actual arguments when appropriate, and signal a &lt;code&gt;wrong-type-argument&lt;/code&gt; error if an argument is of the wrong type. For example, here is what happens if you pass an argument to &lt;code&gt;+&lt;/code&gt; that it cannot handle:</target>
        </trans-unit>
        <trans-unit id="0a8b2cb5ecd2f67ffd2840d4654471062074ad24" translate="yes" xml:space="preserve">
          <source>All buttons have a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;button&lt;/code&gt; property, which may be useful in finding regions of text that comprise buttons (which is what the standard button functions do).</source>
          <target state="translated">All buttons have a non- &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;button&lt;/code&gt; property, which may be useful in finding regions of text that comprise buttons (which is what the standard button functions do).</target>
        </trans-unit>
        <trans-unit id="0de9e1669bff9ffa03c0a6b06c8fc7f25b299da9" translate="yes" xml:space="preserve">
          <source>All command loops, including recursive ones, set up all-purpose error handlers so that an error in a command run from the command loop will not exit the loop.</source>
          <target state="translated">All command loops, including recursive ones, set up all-purpose error handlers so that an error in a command run from the command loop will not exit the loop.</target>
        </trans-unit>
        <trans-unit id="2bf532e176c9ef15e8a341ec22d44645c0ae9a2a" translate="yes" xml:space="preserve">
          <source>All connection-local variables, which are specified by &lt;code&gt;default-directory&lt;/code&gt;, are applied.</source>
          <target state="translated">All connection-local variables, which are specified by &lt;code&gt;default-directory&lt;/code&gt; , are applied.</target>
        </trans-unit>
        <trans-unit id="e7f6062bb49c083289ef91ea0670a9dad56b4214" translate="yes" xml:space="preserve">
          <source>All customization types are implemented as widgets; see &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/widget/index.html#Top&quot;&gt;Introduction&lt;/a&gt; in</source>
          <target state="translated">All customization types are implemented as widgets; see &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/widget/index.html#Top&quot;&gt;Introduction&lt;/a&gt; in</target>
        </trans-unit>
        <trans-unit id="dca342b020ceabede3de91c0d8473d75e1b019c2" translate="yes" xml:space="preserve">
          <source>All following elements in the specification list are optional; as soon as one does not match, Edebug stops matching at this level.</source>
          <target state="translated">All following elements in the specification list are optional; as soon as one does not match, Edebug stops matching at this level.</target>
        </trans-unit>
        <trans-unit id="2c01d7a4983336c611392d0fc00fd2b83de2bc6d" translate="yes" xml:space="preserve">
          <source>All following elements in the specification list are repeated zero or more times. In the last repetition, however, it is not a problem if the expression runs out before matching all of the elements of the specification list.</source>
          <target state="translated">All following elements in the specification list are repeated zero or more times. In the last repetition, however, it is not a problem if the expression runs out before matching all of the elements of the specification list.</target>
        </trans-unit>
        <trans-unit id="25b37db993c79b5143fd020bfa5984f4943de615" translate="yes" xml:space="preserve">
          <source>All four kinds of array share these characteristics:</source>
          <target state="translated">All four kinds of array share these characteristics:</target>
        </trans-unit>
        <trans-unit id="b65738468b638316e78cf6dcd55faa5077ce8a18" translate="yes" xml:space="preserve">
          <source>All functions defined in this library are free of side-effects; i.e., they do not modify any sequence (list, vector, or string) that you pass as an argument. Unless otherwise stated, the result is a sequence of the same type as the input. For those functions that take a predicate, this should be a function of one argument.</source>
          <target state="translated">All functions defined in this library are free of side-effects; i.e., they do not modify any sequence (list, vector, or string) that you pass as an argument. Unless otherwise stated, the result is a sequence of the same type as the input. For those functions that take a predicate, this should be a function of one argument.</target>
        </trans-unit>
        <trans-unit id="c71e30856d625975a83aead946dd7f4e5c8c274a" translate="yes" xml:space="preserve">
          <source>All functions that create markers without accepting an argument that specifies the insertion type, create them with insertion type &lt;code&gt;nil&lt;/code&gt; (see &lt;a href=&quot;creating-markers#Creating-Markers&quot;&gt;Creating Markers&lt;/a&gt;). Also, the mark has, by default, insertion type &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">All functions that create markers without accepting an argument that specifies the insertion type, create them with insertion type &lt;code&gt;nil&lt;/code&gt; (see &lt;a href=&quot;creating-markers#Creating-Markers&quot;&gt;Creating Markers&lt;/a&gt;). Also, the mark has, by default, insertion type &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e5df34fc50a10cee1104c398dc0d288148f5677" translate="yes" xml:space="preserve">
          <source>All numbers can be compared with &lt;code&gt;eql&lt;/code&gt; or &lt;code&gt;=&lt;/code&gt;; fixnums can also be compared with &lt;code&gt;eq&lt;/code&gt;. To test whether an integer is a fixnum or a bignum, you can compare it to &lt;code&gt;most-negative-fixnum&lt;/code&gt; and &lt;code&gt;most-positive-fixnum&lt;/code&gt;, or you can use the convenience predicates &lt;code&gt;fixnump&lt;/code&gt; and &lt;code&gt;bignump&lt;/code&gt; on any object.</source>
          <target state="translated">All numbers can be compared with &lt;code&gt;eql&lt;/code&gt; or &lt;code&gt;=&lt;/code&gt; ; fixnums can also be compared with &lt;code&gt;eq&lt;/code&gt; . To test whether an integer is a fixnum or a bignum, you can compare it to &lt;code&gt;most-negative-fixnum&lt;/code&gt; and &lt;code&gt;most-positive-fixnum&lt;/code&gt; , or you can use the convenience predicates &lt;code&gt;fixnump&lt;/code&gt; and &lt;code&gt;bignump&lt;/code&gt; on any object.</target>
        </trans-unit>
        <trans-unit id="c2c85ce8bd7457b271669cf5c05e295e1385ce6f" translate="yes" xml:space="preserve">
          <source>All of the &lt;var&gt;value-form&lt;/var&gt;s in &lt;var&gt;bindings&lt;/var&gt; are evaluated in the order they appear and &lt;em&gt;before&lt;/em&gt; binding any of the symbols to them. Here is an example of this: &lt;code&gt;z&lt;/code&gt; is bound to the old value of &lt;code&gt;y&lt;/code&gt;, which is 2, not the new value of &lt;code&gt;y&lt;/code&gt;, which is 1.</source>
          <target state="translated">All of the &lt;var&gt;value-form&lt;/var&gt; s in &lt;var&gt;bindings&lt;/var&gt; are evaluated in the order they appear and &lt;em&gt;before&lt;/em&gt; binding any of the symbols to them. Here is an example of this: &lt;code&gt;z&lt;/code&gt; is bound to the old value of &lt;code&gt;y&lt;/code&gt; , which is 2, not the new value of &lt;code&gt;y&lt;/code&gt; , which is 1.</target>
        </trans-unit>
        <trans-unit id="cb57c7da298437e1c1c392f0acf73eba41691d75" translate="yes" xml:space="preserve">
          <source>All of the deletion functions operate on the current buffer.</source>
          <target state="translated">All of the deletion functions operate on the current buffer.</target>
        </trans-unit>
        <trans-unit id="af4a5a5cd065f9f5dbe42b33024e60fb527b8391" translate="yes" xml:space="preserve">
          <source>All of the functions described below are actually &lt;em&gt;function pointers&lt;/em&gt; provided via the pointer to the environment which every module function accepts. Therefore, module code should call these functions through the environment pointer, like this:</source>
          <target state="translated">All of the functions described below are actually &lt;em&gt;function pointers&lt;/em&gt; provided via the pointer to the environment which every module function accepts. Therefore, module code should call these functions through the environment pointer, like this:</target>
        </trans-unit>
        <trans-unit id="2486aadd4696b33394cf13a628e5e81f8336dc69" translate="yes" xml:space="preserve">
          <source>All of these keywords, except &lt;code&gt;:tag&lt;/code&gt;, can be used more than once in a given item. Each use of the keyword has an independent effect. The keyword &lt;code&gt;:tag&lt;/code&gt; is an exception because any given item can only display one name.</source>
          <target state="translated">All of these keywords, except &lt;code&gt;:tag&lt;/code&gt; , can be used more than once in a given item. Each use of the keyword has an independent effect. The keyword &lt;code&gt;:tag&lt;/code&gt; is an exception because any given item can only display one name.</target>
        </trans-unit>
        <trans-unit id="7c58a8aa90e29eb8cc586744cbf0bae2b76d1c9b" translate="yes" xml:space="preserve">
          <source>All the Emacs primitives for file access and file name transformation check the given file name against &lt;code&gt;file-name-handler-alist&lt;/code&gt;. If the file name matches &lt;var&gt;regexp&lt;/var&gt;, the primitives handle that file by calling &lt;var&gt;handler&lt;/var&gt;.</source>
          <target state="translated">All the Emacs primitives for file access and file name transformation check the given file name against &lt;code&gt;file-name-handler-alist&lt;/code&gt; . If the file name matches &lt;var&gt;regexp&lt;/var&gt; , the primitives handle that file by calling &lt;var&gt;handler&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="9a0d1e07e928a09c5cfab793d66c3b83e32a68e0" translate="yes" xml:space="preserve">
          <source>All the buffer properties that are related to the buffer text are swapped as well: the positions of point and mark, all the markers, the overlays, the text properties, the undo list, the value of the &lt;code&gt;enable-multibyte-characters&lt;/code&gt; flag (see &lt;a href=&quot;text-representations#Text-Representations&quot;&gt;enable-multibyte-characters&lt;/a&gt;), etc.</source>
          <target state="translated">All the buffer properties that are related to the buffer text are swapped as well: the positions of point and mark, all the markers, the overlays, the text properties, the undo list, the value of the &lt;code&gt;enable-multibyte-characters&lt;/code&gt; flag (see &lt;a href=&quot;text-representations#Text-Representations&quot;&gt;enable-multibyte-characters&lt;/a&gt;), etc.</target>
        </trans-unit>
        <trans-unit id="41d1c4b0b8ba4df658a7d43aad707edd6505e753" translate="yes" xml:space="preserve">
          <source>All the directories in the file system form a tree starting at the root directory. A file name can specify all the directory names starting from the root of the tree; then it is called an &lt;em&gt;absolute&lt;/em&gt; file name. Or it can specify the position of the file in the tree relative to a default directory; then it is called a &lt;em&gt;relative&lt;/em&gt; file name. On GNU and other POSIX-like systems, after any leading &amp;lsquo;</source>
          <target state="translated">All the directories in the file system form a tree starting at the root directory. A file name can specify all the directory names starting from the root of the tree; then it is called an &lt;em&gt;absolute&lt;/em&gt; file name. Or it can specify the position of the file in the tree relative to a default directory; then it is called a &lt;em&gt;relative&lt;/em&gt; file name. On GNU and other POSIX-like systems, after any leading &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="6d03c2077a45424604dd5945928dd7d581573444" translate="yes" xml:space="preserve">
          <source>All the flags except &amp;lsquo;</source>
          <target state="translated">All the flags except &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="1fa32ceee23a50f9250c28b0af70936b4c7fea6b" translate="yes" xml:space="preserve">
          <source>All the following functions take an optional list of keyword parameters that alter the various attributes from their default values. Valid attributes include:</source>
          <target state="translated">All the following functions take an optional list of keyword parameters that alter the various attributes from their default values. Valid attributes include:</target>
        </trans-unit>
        <trans-unit id="fd4e3414635a6335aabdd75003f817dd7df606f1" translate="yes" xml:space="preserve">
          <source>All the operations that transfer text in and out of Emacs have the ability to use a coding system to encode or decode the text. You can also explicitly encode and decode text using the functions in this section.</source>
          <target state="translated">All the operations that transfer text in and out of Emacs have the ability to use a coding system to encode or decode the text. You can also explicitly encode and decode text using the functions in this section.</target>
        </trans-unit>
        <trans-unit id="3d0ec5a014b164fea677713adc2d6869587a38a2" translate="yes" xml:space="preserve">
          <source>All the remaining elements (if any) are collectively called &lt;var&gt;other-vars&lt;/var&gt;. Each of these elements should have the form &lt;code&gt;(&lt;var&gt;variable&lt;/var&gt; . &lt;var&gt;value&lt;/var&gt;)&lt;/code&gt;&amp;mdash;which means, make &lt;var&gt;variable&lt;/var&gt; buffer-local and then set it to &lt;var&gt;value&lt;/var&gt;. You can use these &lt;var&gt;other-vars&lt;/var&gt; to set other variables that affect fontification, aside from those you can control with the first five elements. See &lt;a href=&quot;other-font-lock-variables#Other-Font-Lock-Variables&quot;&gt;Other Font Lock Variables&lt;/a&gt;.</source>
          <target state="translated">All the remaining elements (if any) are collectively called &lt;var&gt;other-vars&lt;/var&gt; . Each of these elements should have the form &lt;code&gt;(&lt;var&gt;variable&lt;/var&gt; . &lt;var&gt;value&lt;/var&gt;)&lt;/code&gt; &amp;mdash;which means, make &lt;var&gt;variable&lt;/var&gt; buffer-local and then set it to &lt;var&gt;value&lt;/var&gt; . You can use these &lt;var&gt;other-vars&lt;/var&gt; to set other variables that affect fontification, aside from those you can control with the first five elements. See &lt;a href=&quot;other-font-lock-variables#Other-Font-Lock-Variables&quot;&gt;Other Font Lock Variables&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="eef34056c9664b484982e4f51615ce7ab9a41812" translate="yes" xml:space="preserve">
          <source>All the specification characters allow an optional &lt;em&gt;precision&lt;/em&gt; after the field number, flags and width, if present. The precision is a decimal-point &amp;lsquo;</source>
          <target state="translated">All the specification characters allow an optional &lt;em&gt;precision&lt;/em&gt; after the field number, flags and width, if present. The precision is a decimal-point &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="ca4ef7026f0627fed1dbae0beb181539bc4f6f15" translate="yes" xml:space="preserve">
          <source>All the usual rules for documentation strings in Lisp code (see &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/elisp/Documentation-Tips.html#Documentation-Tips&quot;&gt;Documentation Tips&lt;/a&gt;) apply to C code documentation strings too.</source>
          <target state="translated">All the usual rules for documentation strings in Lisp code (see &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/elisp/Documentation-Tips.html#Documentation-Tips&quot;&gt;Documentation Tips&lt;/a&gt;) apply to C code documentation strings too.</target>
        </trans-unit>
        <trans-unit id="58d526aa213005ab745d03bed480a0d5feb42ba3" translate="yes" xml:space="preserve">
          <source>All three of the subprocess-creating functions allow to specify command-line arguments for the process to run. For &lt;code&gt;call-process&lt;/code&gt; and &lt;code&gt;call-process-region&lt;/code&gt;, these come in the form of a &lt;code&gt;&amp;amp;rest&lt;/code&gt; argument, &lt;var&gt;args&lt;/var&gt;. For &lt;code&gt;make-process&lt;/code&gt;, both the program to run and its command-line arguments are specified as a list of strings. The command-line arguments must all be strings, and they are supplied to the program as separate argument strings. Wildcard characters and other shell constructs have no special meanings in these strings, since the strings are passed directly to the specified program.</source>
          <target state="translated">All three of the subprocess-creating functions allow to specify command-line arguments for the process to run. For &lt;code&gt;call-process&lt;/code&gt; and &lt;code&gt;call-process-region&lt;/code&gt; , these come in the form of a &lt;code&gt;&amp;amp;rest&lt;/code&gt; argument, &lt;var&gt;args&lt;/var&gt; . For &lt;code&gt;make-process&lt;/code&gt; , both the program to run and its command-line arguments are specified as a list of strings. The command-line arguments must all be strings, and they are supplied to the program as separate argument strings. Wildcard characters and other shell constructs have no special meanings in these strings, since the strings are passed directly to the specified program.</target>
        </trans-unit>
        <trans-unit id="0dd2c1f56aad50efd70754bd7b0f1448e6dee489" translate="yes" xml:space="preserve">
          <source>All you need to do is add a &lt;code&gt;declare-function&lt;/code&gt; statement before the first use of the function in question:</source>
          <target state="translated">All you need to do is add a &lt;code&gt;declare-function&lt;/code&gt; statement before the first use of the function in question:</target>
        </trans-unit>
        <trans-unit id="83a5fc8fd0c6232ad2485feb2941be6df4658ce5" translate="yes" xml:space="preserve">
          <source>Allow &lt;var&gt;command&lt;/var&gt; (a symbol) to be executed without special confirmation from now on, and alter the user&amp;rsquo;s init file (see &lt;a href=&quot;init-file#Init-File&quot;&gt;Init File&lt;/a&gt;) so that this will apply to future sessions.</source>
          <target state="translated">Allow &lt;var&gt;command&lt;/var&gt; (a symbol) to be executed without special confirmation from now on, and alter the user&amp;rsquo;s init file (see &lt;a href=&quot;init-file#Init-File&quot;&gt;Init File&lt;/a&gt;) so that this will apply to future sessions.</target>
        </trans-unit>
        <trans-unit id="fbe56df0c14a0941bf2865207a4eec4975a429b2" translate="yes" xml:space="preserve">
          <source>Almost all the messages displayed in the echo area are also recorded in the</source>
          <target state="translated">Almost all the messages displayed in the echo area are also recorded in the</target>
        </trans-unit>
        <trans-unit id="0a6cdeb0d1c09e0504231be0c620803ea8ce80be" translate="yes" xml:space="preserve">
          <source>Along with the mandatory &lt;code&gt;:request-dispatcher&lt;/code&gt; and &lt;code&gt;:notification-dispatcher&lt;/code&gt; initargs, users of the &lt;code&gt;jsonrpc-process-connection&lt;/code&gt; class should pass the following initargs as keyword-value pairs to &lt;code&gt;make-instance&lt;/code&gt;:</source>
          <target state="translated">Along with the mandatory &lt;code&gt;:request-dispatcher&lt;/code&gt; and &lt;code&gt;:notification-dispatcher&lt;/code&gt; initargs, users of the &lt;code&gt;jsonrpc-process-connection&lt;/code&gt; class should pass the following initargs as keyword-value pairs to &lt;code&gt;make-instance&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="986ce8469a3d5002d455b0f41722b9928e133cc8" translate="yes" xml:space="preserve">
          <source>Alphabetical sorting means that two sort keys are compared by comparing the first characters of each, the second characters of each, and so on. If a mismatch is found, it means that the sort keys are unequal; the sort key whose character is less at the point of first mismatch is the lesser sort key. The individual characters are compared according to their numerical character codes in the Emacs character set.</source>
          <target state="translated">Alphabetical sorting means that two sort keys are compared by comparing the first characters of each, the second characters of each, and so on. If a mismatch is found, it means that the sort keys are unequal; the sort key whose character is less at the point of first mismatch is the lesser sort key. The individual characters are compared according to their numerical character codes in the Emacs character set.</target>
        </trans-unit>
        <trans-unit id="3397c8f08539eaf212b8a514976581cd47575863" translate="yes" xml:space="preserve">
          <source>Also by convention, the &lt;small&gt;CDR&lt;/small&gt; of the last cons cell in a list is &lt;code&gt;nil&lt;/code&gt;. We call such a &lt;code&gt;nil&lt;/code&gt;-terminated structure a &lt;em&gt;proper list&lt;/em&gt;&lt;a href=&quot;#FOOT3&quot; name=&quot;DOCF3&quot;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;. In Emacs Lisp, the symbol &lt;code&gt;nil&lt;/code&gt; is both a symbol and a list with no elements. For convenience, the symbol &lt;code&gt;nil&lt;/code&gt; is considered to have &lt;code&gt;nil&lt;/code&gt; as its &lt;small&gt;CDR&lt;/small&gt; (and also as its &lt;small&gt;CAR&lt;/small&gt;).</source>
          <target state="translated">Also by convention, the &lt;small&gt;CDR&lt;/small&gt; of the last cons cell in a list is &lt;code&gt;nil&lt;/code&gt; . We call such a &lt;code&gt;nil&lt;/code&gt; -terminated structure a &lt;em&gt;proper list&lt;/em&gt;&lt;a href=&quot;#FOOT3&quot; name=&quot;DOCF3&quot;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;. In Emacs Lisp, the symbol &lt;code&gt;nil&lt;/code&gt; is both a symbol and a list with no elements. For convenience, the symbol &lt;code&gt;nil&lt;/code&gt; is considered to have &lt;code&gt;nil&lt;/code&gt; as its &lt;small&gt;CDR&lt;/small&gt; (and also as its &lt;small&gt;CAR&lt;/small&gt;).</target>
        </trans-unit>
        <trans-unit id="fff39e0b11dcde645d91107c5004ab17b6696524" translate="yes" xml:space="preserve">
          <source>Also note that this variable is not meant to be a generic facility for accessing external libraries; only those already known by Emacs can be loaded through it.</source>
          <target state="translated">Also note that this variable is not meant to be a generic facility for accessing external libraries; only those already known by Emacs can be loaded through it.</target>
        </trans-unit>
        <trans-unit id="b0218093aabf50731b0dfd5f6bc99d6da5f04d9a" translate="yes" xml:space="preserve">
          <source>Also see &lt;code&gt;edebug-tracing&lt;/code&gt;, in &lt;a href=&quot;trace-buffer#Trace-Buffer&quot;&gt;Trace Buffer&lt;/a&gt;.</source>
          <target state="translated">Also see &lt;code&gt;edebug-tracing&lt;/code&gt; , in &lt;a href=&quot;trace-buffer#Trace-Buffer&quot;&gt;Trace Buffer&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="4d0d7b652d689c605bbb8e508dce118b76e3835d" translate="yes" xml:space="preserve">
          <source>Also see the following function.</source>
          <target state="translated">Also see the following function.</target>
        </trans-unit>
        <trans-unit id="f91d8e06c0823bced203ecdc95d5ffb09f2dca97" translate="yes" xml:space="preserve">
          <source>Also see the functions &lt;code&gt;bolp&lt;/code&gt; and &lt;code&gt;eolp&lt;/code&gt; in &lt;a href=&quot;near-point#Near-Point&quot;&gt;Near Point&lt;/a&gt;. These functions do not move point, but test whether it is already at the beginning or end of a line.</source>
          <target state="translated">Also see the functions &lt;code&gt;bolp&lt;/code&gt; and &lt;code&gt;eolp&lt;/code&gt; in &lt;a href=&quot;near-point#Near-Point&quot;&gt;Near Point&lt;/a&gt;. These functions do not move point, but test whether it is already at the beginning or end of a line.</target>
        </trans-unit>
        <trans-unit id="1c151f9dd941153aa652ba089e31237c83748274" translate="yes" xml:space="preserve">
          <source>Also, if &lt;code&gt;ignore-window-parameters&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;, this function does not delete any window whose &lt;code&gt;no-delete-other-windows&lt;/code&gt; parameter is non-&lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Also, if &lt;code&gt;ignore-window-parameters&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt; , this function does not delete any window whose &lt;code&gt;no-delete-other-windows&lt;/code&gt; parameter is non- &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7732936fed3ff7cd50aeba214305d9cb5cc02021" translate="yes" xml:space="preserve">
          <source>Also, inline functions do not behave well with respect to debugging, tracing, and advising (see &lt;a href=&quot;advising-functions#Advising-Functions&quot;&gt;Advising Functions&lt;/a&gt;). Since ease of debugging and the flexibility of redefining functions are important features of Emacs, you should not make a function inline, even if it&amp;rsquo;s small, unless its speed is really crucial, and you&amp;rsquo;ve timed the code to verify that using &lt;code&gt;defun&lt;/code&gt; actually has performance problems.</source>
          <target state="translated">Also, inline functions do not behave well with respect to debugging, tracing, and advising (see &lt;a href=&quot;advising-functions#Advising-Functions&quot;&gt;Advising Functions&lt;/a&gt;). Since ease of debugging and the flexibility of redefining functions are important features of Emacs, you should not make a function inline, even if it&amp;rsquo;s small, unless its speed is really crucial, and you&amp;rsquo;ve timed the code to verify that using &lt;code&gt;defun&lt;/code&gt; actually has performance problems.</target>
        </trans-unit>
        <trans-unit id="3a284929ebe4ecbc4627599844c16f8ee2075a18" translate="yes" xml:space="preserve">
          <source>Also, this variable is bound to non-&lt;code&gt;nil&lt;/code&gt; while running those same hook variables, so that by default modifying the buffer from a modification hook does not cause other modification hooks to be run. If you do want modification hooks to be run in a particular piece of code that is itself run from a modification hook, then rebind locally &lt;code&gt;inhibit-modification-hooks&lt;/code&gt; to &lt;code&gt;nil&lt;/code&gt;. However, doing this may cause recursive calls to the modification hooks, so be sure to prepare for that (for example, by binding some variable which tells your hook to do nothing).</source>
          <target state="translated">Also, this variable is bound to non- &lt;code&gt;nil&lt;/code&gt; while running those same hook variables, so that by default modifying the buffer from a modification hook does not cause other modification hooks to be run. If you do want modification hooks to be run in a particular piece of code that is itself run from a modification hook, then rebind locally &lt;code&gt;inhibit-modification-hooks&lt;/code&gt; to &lt;code&gt;nil&lt;/code&gt; . However, doing this may cause recursive calls to the modification hooks, so be sure to prepare for that (for example, by binding some variable which tells your hook to do nothing).</target>
        </trans-unit>
        <trans-unit id="e30eff925100b7c3e119ed678e39009e962455b0" translate="yes" xml:space="preserve">
          <source>Alt</source>
          <target state="translated">Alt</target>
        </trans-unit>
        <trans-unit id="a5a07d26b576b4c962f39501eaa335d2542ec41a" translate="yes" xml:space="preserve">
          <source>Alt-Hyper-Meta-x</source>
          <target state="translated">Alt-Hyper-Meta-x</target>
        </trans-unit>
        <trans-unit id="ce59e9b5171b68822f40796bb3f0c52339cf67a2" translate="yes" xml:space="preserve">
          <source>Alt-TAB</source>
          <target state="translated">Alt-TAB</target>
        </trans-unit>
        <trans-unit id="3569cde666bf1d56550417379b59c63f9186f81c" translate="yes" xml:space="preserve">
          <source>Altering List Elements with setcar</source>
          <target state="translated">Altering List Elements with setcar</target>
        </trans-unit>
        <trans-unit id="c23b06af6029fc510471e91f93630d6b95133fec" translate="yes" xml:space="preserve">
          <source>Altering the CDR of a List</source>
          <target state="translated">Altering the CDR of a List</target>
        </trans-unit>
        <trans-unit id="32b911a69c85aa2eed0e0429593ee1d599f1648f" translate="yes" xml:space="preserve">
          <source>Altering the contents of an existing string.</source>
          <target state="translated">Altering the contents of an existing string.</target>
        </trans-unit>
        <trans-unit id="03e916d44308e382702efa38414c976b82eebcbb" translate="yes" xml:space="preserve">
          <source>Alternative foreground color, a string. This is like &lt;code&gt;:foreground&lt;/code&gt; but the color is only used as a foreground when the background color is near to the foreground that would have been used. This is useful for example when marking text (i.e., the region face). If the text has a foreground that is visible with the region face, that foreground is used. If the foreground is near the region face background, &lt;code&gt;:distant-foreground&lt;/code&gt; is used instead so the text is readable.</source>
          <target state="translated">Alternative foreground color, a string. This is like &lt;code&gt;:foreground&lt;/code&gt; but the color is only used as a foreground when the background color is near to the foreground that would have been used. This is useful for example when marking text (i.e., the region face). If the text has a foreground that is visible with the region face, that foreground is used. If the foreground is near the region face background, &lt;code&gt;:distant-foreground&lt;/code&gt; is used instead so the text is readable.</target>
        </trans-unit>
        <trans-unit id="b201fde3a76a13fb565d2139c2505d62747c3f3d" translate="yes" xml:space="preserve">
          <source>Alternatively, &lt;var&gt;menu&lt;/var&gt; can have the following form:</source>
          <target state="translated">Alternatively, &lt;var&gt;menu&lt;/var&gt; can have the following form:</target>
        </trans-unit>
        <trans-unit id="612d416a8c5c9032e5eee36eda3e173bd67f6d8e" translate="yes" xml:space="preserve">
          <source>Alternatively, a menu item can be a list with the same format as &lt;var&gt;menu&lt;/var&gt;. This is a submenu.</source>
          <target state="translated">Alternatively, a menu item can be a list with the same format as &lt;var&gt;menu&lt;/var&gt; . This is a submenu.</target>
        </trans-unit>
        <trans-unit id="0f3215559a2b65437e72958763c4ad5ae7956797" translate="yes" xml:space="preserve">
          <source>Alternatively, a menu item can be a string. Then that string appears in the menu as unselectable text. A string consisting of dashes is displayed as a separator (see &lt;a href=&quot;menu-separators#Menu-Separators&quot;&gt;Menu Separators&lt;/a&gt;).</source>
          <target state="translated">Alternatively, a menu item can be a string. Then that string appears in the menu as unselectable text. A string consisting of dashes is displayed as a separator (see &lt;a href=&quot;menu-separators#Menu-Separators&quot;&gt;Menu Separators&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="f86166f09a2fa545f30584a0fa07bc98a8228018" translate="yes" xml:space="preserve">
          <source>Alternatively, a menu item may have the form:</source>
          <target state="translated">Alternatively, a menu item may have the form:</target>
        </trans-unit>
        <trans-unit id="2a475682f68cc8d5942ac33225fa6641ddb131e3" translate="yes" xml:space="preserve">
          <source>Alternatively, an &lt;code&gt;interactive&lt;/code&gt; form may be specified in a function symbol&amp;rsquo;s &lt;code&gt;interactive-form&lt;/code&gt; property. A non-&lt;code&gt;nil&lt;/code&gt; value for this property takes precedence over any &lt;code&gt;interactive&lt;/code&gt; form in the function body itself. This feature is seldom used.</source>
          <target state="translated">Alternatively, an &lt;code&gt;interactive&lt;/code&gt; form may be specified in a function symbol&amp;rsquo;s &lt;code&gt;interactive-form&lt;/code&gt; property. A non- &lt;code&gt;nil&lt;/code&gt; value for this property takes precedence over any &lt;code&gt;interactive&lt;/code&gt; form in the function body itself. This feature is seldom used.</target>
        </trans-unit>
        <trans-unit id="70290e19eb34b55b8e6acff0975f8bd70f0b8116" translate="yes" xml:space="preserve">
          <source>Alternatively, the problems sketched above can be avoided by always resizing all windows in the same combination whenever one of its windows is split or deleted. This also permits splitting windows that would be otherwise too small for such an operation.</source>
          <target state="translated">Alternatively, the problems sketched above can be avoided by always resizing all windows in the same combination whenever one of its windows is split or deleted. This also permits splitting windows that would be otherwise too small for such an operation.</target>
        </trans-unit>
        <trans-unit id="b26670ac06db641e3e84463f0ad2daa068f83654" translate="yes" xml:space="preserve">
          <source>Alternatively, the value can specify the bitmap directly, with a list of the form &lt;code&gt;(&lt;var&gt;width&lt;/var&gt; &lt;var&gt;height&lt;/var&gt; &lt;var&gt;data&lt;/var&gt;)&lt;/code&gt;. Here, &lt;var&gt;width&lt;/var&gt; and &lt;var&gt;height&lt;/var&gt; specify the size in pixels, and &lt;var&gt;data&lt;/var&gt; is a string containing the raw bits of the bitmap, row by row. Each row occupies &lt;em&gt;(&lt;var&gt;width&lt;/var&gt; + 7) / 8&lt;/em&gt; consecutive bytes in the string (which should be a unibyte string for best results). This means that each row always occupies at least one whole byte.</source>
          <target state="translated">Alternatively, the value can specify the bitmap directly, with a list of the form &lt;code&gt;(&lt;var&gt;width&lt;/var&gt; &lt;var&gt;height&lt;/var&gt; &lt;var&gt;data&lt;/var&gt;)&lt;/code&gt; . Here, &lt;var&gt;width&lt;/var&gt; and &lt;var&gt;height&lt;/var&gt; specify the size in pixels, and &lt;var&gt;data&lt;/var&gt; is a string containing the raw bits of the bitmap, row by row. Each row occupies &lt;em&gt;( &lt;var&gt;width&lt;/var&gt; + 7) / 8&lt;/em&gt; consecutive bytes in the string (which should be a unibyte string for best results). This means that each row always occupies at least one whole byte.</target>
        </trans-unit>
        <trans-unit id="3fffa4436d30acad881ee763e3e490d5b00c5e0b" translate="yes" xml:space="preserve">
          <source>Alternatively, we can use the &lt;code&gt;with-current-buffer&lt;/code&gt; macro:</source>
          <target state="translated">Alternatively, we can use the &lt;code&gt;with-current-buffer&lt;/code&gt; macro:</target>
        </trans-unit>
        <trans-unit id="b512dedf489786abd4f584013029d9c643312107" translate="yes" xml:space="preserve">
          <source>Alternatively, you can define a function by providing the code which will inline it as a compiler macro. The following macros make this possible.</source>
          <target state="translated">Alternatively, you can define a function by providing the code which will inline it as a compiler macro. The following macros make this possible.</target>
        </trans-unit>
        <trans-unit id="a6177cf1ed61859e6ad146c7a2e9af66ea184b0c" translate="yes" xml:space="preserve">
          <source>Alternatively, you can set &lt;var&gt;min-value&lt;/var&gt; and &lt;var&gt;max-value&lt;/var&gt; to &lt;code&gt;nil&lt;/code&gt;. In that case, the progress reporter does not report process percentages; it instead displays a &amp;ldquo;spinner&amp;rdquo; that rotates a notch each time you update the progress reporter.</source>
          <target state="translated">Alternatively, you can set &lt;var&gt;min-value&lt;/var&gt; and &lt;var&gt;max-value&lt;/var&gt; to &lt;code&gt;nil&lt;/code&gt; . In that case, the progress reporter does not report process percentages; it instead displays a &amp;ldquo;spinner&amp;rdquo; that rotates a notch each time you update the progress reporter.</target>
        </trans-unit>
        <trans-unit id="92226f9d87069cd2db7b3d326f09e83f23a82036" translate="yes" xml:space="preserve">
          <source>Alternatively, you could use the &lt;code&gt;:stderr&lt;/code&gt; parameter with a non-&lt;code&gt;nil&lt;/code&gt; value in a call to &lt;code&gt;make-process&lt;/code&gt; (see &lt;a href=&quot;asynchronous-processes#Asynchronous-Processes&quot;&gt;make-process&lt;/a&gt;) to make the destination of the error output separate from the standard output; in that case, Emacs will use pipes for communicating with the subprocess.</source>
          <target state="translated">Alternatively, you could use the &lt;code&gt;:stderr&lt;/code&gt; parameter with a non- &lt;code&gt;nil&lt;/code&gt; value in a call to &lt;code&gt;make-process&lt;/code&gt; (see &lt;a href=&quot;asynchronous-processes#Asynchronous-Processes&quot;&gt;make-process&lt;/a&gt;) to make the destination of the error output separate from the standard output; in that case, Emacs will use pipes for communicating with the subprocess.</target>
        </trans-unit>
        <trans-unit id="67171d73924b845a3534e0ecdf7ce358ebf03943" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;(time-convert nil nil)&lt;/code&gt; is equivalent to &lt;code&gt;(current-time)&lt;/code&gt;, the latter may be a bit faster.</source>
          <target state="translated">Although &lt;code&gt;(time-convert nil nil)&lt;/code&gt; is equivalent to &lt;code&gt;(current-time)&lt;/code&gt; , the latter may be a bit faster.</target>
        </trans-unit>
        <trans-unit id="ada9e95e67f8cc5ff4fdc84a7549ab0fbfa66304" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;redisplay&lt;/code&gt; tries immediately to redisplay, it does not change how Emacs decides which parts of its frame(s) to redisplay. By contrast, the following function adds certain windows to the pending redisplay work (as if their contents had completely changed), but does not immediately try to perform redisplay.</source>
          <target state="translated">Although &lt;code&gt;redisplay&lt;/code&gt; tries immediately to redisplay, it does not change how Emacs decides which parts of its frame(s) to redisplay. By contrast, the following function adds certain windows to the pending redisplay work (as if their contents had completely changed), but does not immediately try to perform redisplay.</target>
        </trans-unit>
        <trans-unit id="1b09322d9e876baf3954f8eeffbc89a79699d7f4" translate="yes" xml:space="preserve">
          <source>Although Emacs normally respects access permissions of the underlying operating system, in some cases it handles accesses specially. For example, file names can have handlers that treat the files specially, with their own access checking. See &lt;a href=&quot;magic-file-names#Magic-File-Names&quot;&gt;Magic File Names&lt;/a&gt;. Also, a buffer can be read-only even if the corresponding file is writable, and vice versa, which can result in messages such as &amp;lsquo;</source>
          <target state="translated">Although Emacs normally respects access permissions of the underlying operating system, in some cases it handles accesses specially. For example, file names can have handlers that treat the files specially, with their own access checking. See &lt;a href=&quot;magic-file-names#Magic-File-Names&quot;&gt;Magic File Names&lt;/a&gt;. Also, a buffer can be read-only even if the corresponding file is writable, and vice versa, which can result in messages such as &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="41aec9e3c0639b5cbc769510aa631eca22825357" translate="yes" xml:space="preserve">
          <source>Although a &amp;lsquo;</source>
          <target state="translated">Although a &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="0f3c6c13e12239c0128c12d87359384cf4720010" translate="yes" xml:space="preserve">
          <source>Although a character alternative can include duplicates, it is better style to avoid them. For example, &amp;lsquo;</source>
          <target state="translated">Although a character alternative can include duplicates, it is better style to avoid them. For example, &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="003ff1a62df2fa3817a8fd6c5d1dd5fe04cc547c" translate="yes" xml:space="preserve">
          <source>Although a range can denote just one, two, or three characters, it is simpler to list the characters. For example, &amp;lsquo;</source>
          <target state="translated">Although a range can denote just one, two, or three characters, it is simpler to list the characters. For example, &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="743be7d85c6dff8ab2c12b47e5caa1355172e2a0" translate="yes" xml:space="preserve">
          <source>Although a range&amp;rsquo;s bound can be almost any character, it is better style to stay within natural sequences of ASCII letters and digits because most people have not memorized character code tables. For example, &amp;lsquo;</source>
          <target state="translated">범위의 경계는 거의 모든 문자가 될 수 있지만 대부분의 사람들이 문자 코드 테이블을 기억하지 않았기 때문에 ASCII 문자 및 숫자의 자연스러운 시퀀스 내에 머무르는 것이 더 좋습니다. 예 : '</target>
        </trans-unit>
        <trans-unit id="a6f6b98c4f64609315a55f827d800190bc2958cc" translate="yes" xml:space="preserve">
          <source>Although both sorts of failures can largely be avoided by a suitably configured file system, such systems are typically more expensive or less efficient. In more-typical systems, to survive media failure you can copy the file to a different device, and to survive a power failure you can use the &lt;code&gt;write-region&lt;/code&gt; function with the &lt;code&gt;write-region-inhibit-fsync&lt;/code&gt; variable set to &lt;code&gt;nil&lt;/code&gt;. See &lt;a href=&quot;writing-to-files#Writing-to-Files&quot;&gt;Writing to Files&lt;/a&gt;.</source>
          <target state="translated">적절하게 구성된 파일 시스템으로 두 가지 유형의 오류를 모두 방지 할 수 있지만 이러한 시스템은 일반적으로 더 비싸거나 덜 효율적입니다. 보다 일반적인 시스템에서는 미디어 오류를 견디기 위해 파일을 다른 장치에 복사 할 수 있고 정전에서 살아 남기 위해 &lt;code&gt;write-region-inhibit-fsync&lt;/code&gt; 변수를 &lt;code&gt;nil&lt;/code&gt; 로 설정 하여 &lt;code&gt;write-region&lt;/code&gt; 함수를 사용할 수 있습니다 . &lt;a href=&quot;writing-to-files#Writing-to-Files&quot;&gt;파일에 쓰기를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9d6a6f038f930d539ab3543bcd22fa56a80436b0" translate="yes" xml:space="preserve">
          <source>Although completion is usually done in the minibuffer, the completion facility can also be used on the text in ordinary Emacs buffers. In many major modes, in-buffer completion is performed by the</source>
          <target state="translated">완료는 일반적으로 미니 버퍼에서 수행되지만 완료 기능은 일반 Emacs 버퍼의 텍스트에서도 사용할 수 있습니다. 많은 주요 모드에서 버퍼 내 완료는</target>
        </trans-unit>
        <trans-unit id="67fae8b88cdfb0b03098409367fbfcfd4933ca60" translate="yes" xml:space="preserve">
          <source>Although functions are usually defined with &lt;code&gt;defun&lt;/code&gt; and given names at the same time, it is sometimes convenient to use an explicit lambda expression&amp;mdash;an &lt;em&gt;anonymous function&lt;/em&gt;. Anonymous functions are valid wherever function names are. They are often assigned as variable values, or as arguments to functions; for instance, you might pass one as the &lt;var&gt;function&lt;/var&gt; argument to &lt;code&gt;mapcar&lt;/code&gt;, which applies that function to each element of a list (see &lt;a href=&quot;mapping-functions#Mapping-Functions&quot;&gt;Mapping Functions&lt;/a&gt;). See &lt;a href=&quot;accessing-documentation#describe_002dsymbols-example&quot;&gt;describe-symbols example&lt;/a&gt;, for a realistic example of this.</source>
          <target state="translated">함수는 일반적으로 &lt;code&gt;defun&lt;/code&gt; 및 지정된 이름 으로 정의되지만 &lt;em&gt;익명 함수 인&lt;/em&gt; 명시 적 람다 식을 사용하는 것이 편리한 경우가 있습니다 . 익명 함수는 함수 이름이있는 모든 곳에서 유효합니다. 종종 변수 값이나 함수에 대한 인수로 지정됩니다. 예를 들어 &lt;code&gt;mapcar&lt;/code&gt; 에 &lt;var&gt;function&lt;/var&gt; 인수로 하나를 전달하면 해당 함수가 목록의 각 요소에 적용됩니다 ( &lt;a href=&quot;mapping-functions#Mapping-Functions&quot;&gt;매핑 함수&lt;/a&gt; 참조 ). 이에 대한 실제적인 예는 &lt;a href=&quot;accessing-documentation#describe_002dsymbols-example&quot;&gt;describe-symbols example을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1be7de9f1b9c2d003e43c343730f7fd8d2bd62d3" translate="yes" xml:space="preserve">
          <source>Although numbers never change and all markers are mutable, some types have members some of which are mutable and others not. These types include conses, vectors, and strings. For example, although &lt;code&gt;&quot;cons&quot;&lt;/code&gt; and &lt;code&gt;(symbol-name 'cons)&lt;/code&gt; both yield strings that should not be changed, &lt;code&gt;(copy-sequence &quot;cons&quot;)&lt;/code&gt; and &lt;code&gt;(make-string 3 ?a)&lt;/code&gt; both yield mutable strings that can be changed via later calls to &lt;code&gt;aset&lt;/code&gt;.</source>
          <target state="translated">숫자는 변경되지 않고 모든 마커가 변경 가능하지만 일부 유형에는 멤버가 있으며 일부는 변경 가능하고 다른 유형은 불가능합니다. 이러한 유형에는 conses, 벡터 및 문자열이 포함됩니다. 예를 들어, &lt;code&gt;&quot;cons&quot;&lt;/code&gt; 및 &lt;code&gt;(symbol-name 'cons)&lt;/code&gt; 모두 변경해서는 안되는 문자열을 산출하지만 &lt;code&gt;(copy-sequence &quot;cons&quot;)&lt;/code&gt; 및 &lt;code&gt;(make-string 3 ?a)&lt;/code&gt; 둘 다 다음을 통해 변경할 수있는 가변 문자열을 산출합니다. 나중에 &lt;code&gt;aset&lt;/code&gt; 호출 .</target>
        </trans-unit>
        <trans-unit id="cd89d9ee767436b48e243e1fec03f6f21ceca0df" translate="yes" xml:space="preserve">
          <source>Although packing and unpacking operations change the organization of data (in memory), they preserve the data&amp;rsquo;s &lt;em&gt;total length&lt;/em&gt;, which is the sum of all the fields&amp;rsquo; lengths, in bytes. This value is not generally inherent in either the specification or alist alone; instead, both pieces of information contribute to its calculation. Likewise, the length of a string or array being unpacked may be longer than the data&amp;rsquo;s total length as described by the specification.</source>
          <target state="translated">압축 및 압축 해제 작업은 데이터 구성 (메모리)을 변경하지만 모든 필드 &lt;em&gt;길이&lt;/em&gt; 의 &lt;em&gt;합계 인&lt;/em&gt; 데이터의 &lt;em&gt;총 길이 (&lt;/em&gt; 바이트)를 유지합니다. 이 값은 일반적으로 사양 또는 목록에만 내재되어 있지 않습니다. 대신 두 정보 모두 계산에 기여합니다. 마찬가지로 압축을 풀고있는 문자열 또는 배열의 길이는 사양에 설명 된 데이터의 전체 길이보다 길 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d96567dd4450662d62d221615f9401c0781977ac" translate="yes" xml:space="preserve">
          <source>Although the expressions &lt;code&gt;(list '+ 1 2)&lt;/code&gt; and &lt;code&gt;'(+ 1 2)&lt;/code&gt; both yield lists equal to &lt;code&gt;(+ 1 2)&lt;/code&gt;, the former yields a freshly-minted mutable list whereas the latter yields a list built from conses that might be shared and should not be modified. See &lt;a href=&quot;self_002devaluating-forms#Self_002dEvaluating-Forms&quot;&gt;Self-Evaluating Forms&lt;/a&gt;.</source>
          <target state="translated">표현하지만 &lt;code&gt;(list '+ 1 2)&lt;/code&gt; 와 &lt;code&gt;'(+ 1 2)&lt;/code&gt; 리스트는 동일한 양 수율 &lt;code&gt;(+ 1 2)&lt;/code&gt; , 전자 수율 후자 수율 공유 될 수도 conses에서 만들어진리스트 반면 갓 발행 가변 목록 수정해서는 안됩니다. &lt;a href=&quot;self_002devaluating-forms#Self_002dEvaluating-Forms&quot;&gt;자체 평가 양식을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="22404d7c1088551650eedf30d445b02f32c8b26a" translate="yes" xml:space="preserve">
          <source>Although the list &lt;code&gt;(0.5)&lt;/code&gt; was mutable when it was created, it should not have been changed via &lt;code&gt;setcar&lt;/code&gt; because it given to &lt;code&gt;eval&lt;/code&gt;. The reverse does not occur: an object that should not be changed never becomes mutable afterwards.</source>
          <target state="translated">목록 &lt;code&gt;(0.5)&lt;/code&gt; 이 생성 될 때 변경 가능 &lt;code&gt;setcar&lt;/code&gt; &lt;code&gt;eval&lt;/code&gt; 에 주어 졌으므로 setcar 를 통해 변경해서는 안됩니다 . 그 반대는 발생하지 않습니다. 변경되지 않아야하는 객체는 나중에 변경 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="391c1ca03938de65f008bec7937cdacbb0a5f7c8" translate="yes" xml:space="preserve">
          <source>Although the portable dumper code can run on many platforms, the dump files that it produces are not portable&amp;mdash;they can be loaded only by the Emacs executable that dumped them.</source>
          <target state="translated">이식 가능한 덤퍼 코드는 여러 플랫폼에서 실행될 수 있지만 생성되는 덤프 파일은 이식 할 수 없습니다. 덤프 한 Emacs 실행 파일에 의해서만로드 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6fa602a74e291da2cfde0e718a9868c53eb69aef" translate="yes" xml:space="preserve">
          <source>Although top-level calls to &lt;code&gt;require&lt;/code&gt; are evaluated during byte compilation, &lt;code&gt;provide&lt;/code&gt; calls are not. Therefore, you can ensure that a file of definitions is loaded before it is byte-compiled by including a &lt;code&gt;provide&lt;/code&gt; followed by a &lt;code&gt;require&lt;/code&gt; for the same feature, as in the following example.</source>
          <target state="translated">&lt;code&gt;require&lt;/code&gt; 에 대한 최상위 호출 은 바이트 컴파일 중에 평가되지만 &lt;code&gt;provide&lt;/code&gt; 호출은 평가 되지 않습니다. 따라서 다음 예에서와 같이 동일한 기능 에 대한 &lt;code&gt;require&lt;/code&gt; 뒤에 &lt;code&gt;provide&lt;/code&gt; 을 포함하여 바이트 컴파일하기 전에 정의 파일이로드되도록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0d330d60bab6b0316e891e9303762414649958a9" translate="yes" xml:space="preserve">
          <source>Although traditionally Lisp timestamps were integer pairs, their form has evolved and programs ordinarily should not depend on the current default form. If your program needs a particular timestamp form, you can use the &lt;code&gt;time-convert&lt;/code&gt; function to convert it to the needed form. See &lt;a href=&quot;time-conversion#Time-Conversion&quot;&gt;Time Conversion&lt;/a&gt;.</source>
          <target state="translated">전통적으로 Lisp 타임 스탬프는 정수 쌍 이었지만 그 형식은 발전했으며 프로그램은 일반적으로 현재 기본 형식에 의존해서는 안됩니다. 프로그램에 특정 타임 스탬프 형식이 필요한 경우 &lt;code&gt;time-convert&lt;/code&gt; 함수를 사용 하여 필요한 형식으로 변환 할 수 있습니다. &lt;a href=&quot;time-conversion#Time-Conversion&quot;&gt;시간 변환을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="03d337a2cc5120b55c2c85cdc5a80ad1a0f608d6" translate="yes" xml:space="preserve">
          <source>Always use the &lt;code&gt;:set&lt;/code&gt; function to initialize the variable. If the variable is already non-void, reset it by calling the &lt;code&gt;:set&lt;/code&gt; function using the current value (returned by the &lt;code&gt;:get&lt;/code&gt; method). This is the default &lt;code&gt;:initialize&lt;/code&gt; function.</source>
          <target state="translated">항상 &lt;code&gt;:set&lt;/code&gt; 함수를 사용하여 변수를 초기화하십시오. 변수가 이미 void가 아닌 경우 현재 값을 사용하여 &lt;code&gt;:set&lt;/code&gt; 함수를 호출하여 재설정합니다 ( &lt;code&gt;:get&lt;/code&gt; 메서드 에서 반환 됨 ). 이것이 기본 &lt;code&gt;:initialize&lt;/code&gt; 함수입니다.</target>
        </trans-unit>
        <trans-unit id="3d4ac6bb796b287295b9fa9b0f33f9196a9c4247" translate="yes" xml:space="preserve">
          <source>Amongst other things, this function sets up the &lt;code&gt;comment-start&lt;/code&gt; variable to handle Lisp comments:</source>
          <target state="translated">무엇보다도이 함수는 Lisp 주석을 처리하기 위해 &lt;code&gt;comment-start&lt;/code&gt; 변수를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="55327aa4b2861fca2f67242dee6031a0481c6441" translate="yes" xml:space="preserve">
          <source>An (efficient) array of characters.</source>
          <target state="translated">(효율적인) 문자 배열.</target>
        </trans-unit>
        <trans-unit id="b24fa2adc3461b8097e9865ddc5d05a962a6075d" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;end-of-file&lt;/code&gt; error is signaled if reading encounters an unterminated list, vector, or string.</source>
          <target state="translated">&lt;code&gt;end-of-file&lt;/code&gt; 읽기가 종료되지 않은 목록, 벡터, 또는 캐릭터가 발생하면 오류가 신호됩니다.</target>
        </trans-unit>
        <trans-unit id="4fa8eeb2346c8a9639fa3ee155f83ec1952beb3e" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;action alist&lt;/em&gt; is an association list mapping predefined symbols recognized by action functions to values these functions are supposed to interpret accordingly. In each call, &lt;code&gt;display-buffer&lt;/code&gt; constructs a new, possibly empty action alist and passes that entire list on to any action function it calls.</source>
          <target state="translated">&lt;em&gt;액션 alist는&lt;/em&gt; 이러한 기능 그에 따라 해석 해야하는 값으로 동작 기능에 의해 인식 연관 목록 매핑 미리 정의 된 상징이다. 각 호출에서 &lt;code&gt;display-buffer&lt;/code&gt; 는 비어있을 수있는 새로운 작업 목록을 생성하고 전체 목록을 호출하는 모든 작업 함수에 전달합니다.</target>
        </trans-unit>
        <trans-unit id="6fbb202e704ca6497d62596b4b24317b48567731" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;action function&lt;/em&gt; is a function &lt;code&gt;display-buffer&lt;/code&gt; calls for choosing a window to display a buffer. Action functions take two arguments: &lt;var&gt;buffer&lt;/var&gt;, the buffer to display, and &lt;var&gt;alist&lt;/var&gt;, an action alist (see &lt;a href=&quot;buffer-display-action-alists#Buffer-Display-Action-Alists&quot;&gt;Buffer Display Action Alists&lt;/a&gt;). They are supposed to return a window displaying &lt;var&gt;buffer&lt;/var&gt; if they succeed and &lt;code&gt;nil&lt;/code&gt; if they fail.</source>
          <target state="translated">&lt;em&gt;액션 기능을&lt;/em&gt; 하는 기능입니다 &lt;code&gt;display-buffer&lt;/code&gt; 버퍼를 표시하는 창을 선택을 요구한다. 액션 함수는 두 개의 인수를 취합니다 : &lt;var&gt;buffer&lt;/var&gt; , 표시 할 버퍼 및 &lt;var&gt;alist&lt;/var&gt; , 조치 alist ( &lt;a href=&quot;buffer-display-action-alists#Buffer-Display-Action-Alists&quot;&gt;Buffer Display Action Alists&lt;/a&gt; 참조 ). 성공하면 &lt;var&gt;buffer&lt;/var&gt; 표시하는 창을 반환하고 실패하면 &lt;code&gt;nil&lt;/code&gt; 을 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="42d3eec2eded4ad1f09d03ecadb028b0fe97c946" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;array&lt;/em&gt; is a fixed-length object with a slot for each of its elements. All the elements are accessible in constant time. The four types of arrays are strings, vectors, char-tables and bool-vectors.</source>
          <target state="translated">&lt;em&gt;어레이&lt;/em&gt; 요소의 각각에 대한 슬롯 고정 길이 목적이다. 모든 요소는 일정한 시간에 액세스 할 수 있습니다. 네 가지 유형의 배열은 문자열, 벡터, 문자 테이블 및 부울 벡터입니다.</target>
        </trans-unit>
        <trans-unit id="a4bee20b16add7aae2f3af434413439ac2fc3a32" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;array&lt;/em&gt; is composed of an arbitrary number of slots for holding or referring to other Lisp objects, arranged in a contiguous block of memory. Accessing any element of an array takes approximately the same amount of time. In contrast, accessing an element of a list requires time proportional to the position of the element in the list. (Elements at the end of a list take longer to access than elements at the beginning of a list.)</source>
          <target state="translated">&lt;em&gt;어레이&lt;/em&gt; 유지하거나 메모리의 연속 블록 내에 배치 다른 리스프 객체 참조를 위해 슬롯의 임의의 개수로 구성된다. 배열의 요소에 액세스하는 데는 거의 같은 시간이 걸립니다. 반대로 목록의 요소에 액세스하려면 목록의 요소 위치에 비례하는 시간이 필요합니다. (목록 끝에있는 요소는 목록 시작 부분에있는 요소보다 액세스하는 데 더 오래 걸립니다.)</target>
        </trans-unit>
        <trans-unit id="553ed232664b5e6ef74691641b0767d1d08a7cfd" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;array&lt;/em&gt; object has slots that hold a number of other Lisp objects, called the elements of the array. Any element of an array may be accessed in constant time. In contrast, the time to access an element of a list is proportional to the position of that element in the list.</source>
          <target state="translated">&lt;em&gt;배열&lt;/em&gt; 객체 리스프 다른 개체들을 보유 슬롯을 가지며, 배열의 요소라고. 배열의 모든 요소는 일정한 시간에 액세스 할 수 있습니다. 반대로, 목록의 요소에 액세스하는 시간은 목록에서 해당 요소의 위치에 비례합니다.</target>
        </trans-unit>
        <trans-unit id="51d6c8f716e9b88b14b6fb96e89f9851f7407153" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;association list&lt;/em&gt; or &lt;em&gt;alist&lt;/em&gt; is a specially-constructed list whose elements are cons cells. In each element, the &lt;small&gt;CAR&lt;/small&gt; is considered a &lt;em&gt;key&lt;/em&gt;, and the &lt;small&gt;CDR&lt;/small&gt; is considered an &lt;em&gt;associated value&lt;/em&gt;. (In some cases, the associated value is stored in the &lt;small&gt;CAR&lt;/small&gt; of the &lt;small&gt;CDR&lt;/small&gt;.) Association lists are often used as stacks, since it is easy to add or remove associations at the front of the list.</source>
          <target state="translated">&lt;em&gt;연관리스트&lt;/em&gt; 또는 &lt;em&gt;alist는&lt;/em&gt; 요소가 반대 셀인 특별히 구성된리스트이다. 각 요소에서 &lt;small&gt;CAR&lt;/small&gt; 은 &lt;em&gt;키로&lt;/em&gt; 간주 되고 &lt;small&gt;CDR&lt;/small&gt; 은 &lt;em&gt;연관된 값으로&lt;/em&gt; 간주됩니다 . (경우에 따라 관련 값이 &lt;small&gt;CDR&lt;/small&gt; 의 &lt;small&gt;CAR&lt;/small&gt; 에 저장됩니다 .) 연결 목록은 목록의 맨 앞에 연결을 추가하거나 제거하기 쉽기 때문에 스택으로 자주 사용됩니다.&lt;small&gt;&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="1abfa47a133f69e41aaa18f7e94f5e435978d98b" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;association list&lt;/em&gt;, or &lt;em&gt;alist&lt;/em&gt; for short, records a mapping from keys to values. It is a list of cons cells called &lt;em&gt;associations&lt;/em&gt;: the &lt;small&gt;CAR&lt;/small&gt; of each cons cell is the &lt;em&gt;key&lt;/em&gt;, and the &lt;small&gt;CDR&lt;/small&gt; is the &lt;em&gt;associated value&lt;/em&gt;.&lt;a href=&quot;#FOOT5&quot; name=&quot;DOCF5&quot;&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;연관리스트&lt;/em&gt; , 또는 &lt;em&gt;alist&lt;/em&gt; 짧게는 키와 값의 매핑을 기록합니다. 이는 &lt;em&gt;연관&lt;/em&gt; 이라고하는 단점 셀의 목록입니다 . 각 단점 셀 의 &lt;small&gt;CAR&lt;/small&gt; 이 &lt;em&gt;키&lt;/em&gt; 이고 &lt;small&gt;CDR&lt;/small&gt; 이 &lt;em&gt;연관된 값&lt;/em&gt; 입니다. &lt;a href=&quot;#FOOT5&quot; name=&quot;DOCF5&quot;&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b5d765e12413afb561974dbf3e3027981ca84c13" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;autoload object&lt;/em&gt; is a list whose first element is the symbol &lt;code&gt;autoload&lt;/code&gt;. It is stored as the function definition of a symbol, where it serves as a placeholder for the real definition. The autoload object says that the real definition is found in a file of Lisp code that should be loaded when necessary. It contains the name of the file, plus some other information about the real definition.</source>
          <target state="translated">&lt;em&gt;자동로드 객체는&lt;/em&gt; 그 첫 번째 요소 심볼 인 목록을 &lt;code&gt;autoload&lt;/code&gt; . 기호의 함수 정의로 저장되며 실제 정의에 대한 자리 표시 자 역할을합니다. 자동로드 개체는 필요한 경우로드되어야하는 Lisp 코드 파일에서 실제 정의를 찾을 수 있다고 말합니다. 파일 이름과 실제 정의에 대한 기타 정보가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="24cadccfe6209dab134eadc89a088981a88134fc" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;ewoc&lt;/em&gt; is a structure that organizes information required to construct buffer text that represents certain Lisp data. The buffer text of the ewoc has three parts, in order: first, fixed &lt;em&gt;header&lt;/em&gt; text; next, textual descriptions of a series of data elements (Lisp objects that you specify); and last, fixed &lt;em&gt;footer&lt;/em&gt; text. Specifically, an ewoc contains information on:</source>
          <target state="translated">&lt;em&gt;ewoc은&lt;/em&gt; 특정 리스프 데이터 구조를 나타내는 텍스트 버퍼에 필요한 정보를 구성하는 구조이다. ewoc의 버퍼 텍스트는 순서대로 세 부분으로 구성됩니다. 첫째, 고정 &lt;em&gt;헤더&lt;/em&gt; 텍스트; 다음은 일련의 데이터 요소 (사용자가 지정한 Lisp 개체)에 대한 텍스트 설명입니다. 마지막으로 고정 &lt;em&gt;바닥 글&lt;/em&gt; 텍스트입니다. 특히 ewoc에는 다음에 대한 정보가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="45ade8aa3c0307591d943018dc5e837198a89448" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;image descriptor&lt;/em&gt; is a list which specifies the underlying data for an image, and how to display it. It is typically used as the value of a &lt;code&gt;display&lt;/code&gt; overlay or text property (see &lt;a href=&quot;other-display-specs#Other-Display-Specs&quot;&gt;Other Display Specs&lt;/a&gt;); but See &lt;a href=&quot;showing-images#Showing-Images&quot;&gt;Showing Images&lt;/a&gt;, for convenient helper functions to insert images into buffers.</source>
          <target state="translated">&lt;em&gt;이미지 기술자&lt;/em&gt; 이미지에 대한 기본 데이터를 지정 목록 및 방법을 표시한다. 일반적으로 &lt;code&gt;display&lt;/code&gt; 오버레이 또는 텍스트 속성 의 값으로 사용됩니다 ( &lt;a href=&quot;other-display-specs#Other-Display-Specs&quot;&gt;기타 디스플레이 사양&lt;/a&gt; 참조 ). 그러나 버퍼에 이미지를 삽입하는 편리한 도우미 기능은 &lt;a href=&quot;showing-images#Showing-Images&quot;&gt;이미지 표시를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8ee4088b1e46a6b8823f17c1848dbfa1804acba9" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;indirect buffer&lt;/em&gt; shares the text of some other buffer, which is called the &lt;em&gt;base buffer&lt;/em&gt; of the indirect buffer. In some ways it is the analogue, for buffers, of a symbolic link among files. The base buffer may not itself be an indirect buffer.</source>
          <target state="translated">&lt;em&gt;간접 버퍼&lt;/em&gt; 는 &lt;em&gt;간접 버퍼&lt;/em&gt; 의 &lt;em&gt;기본 버퍼&lt;/em&gt; 라고하는 다른 버퍼의 텍스트를 공유합니다 . 어떤면에서는 버퍼의 경우 파일 간의 심볼릭 링크와 유사합니다. 기본 버퍼 자체는 간접 버퍼가 아닐 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d4ce81396c742a0b613f8351db2ccbce4a6b846" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;inline function&lt;/em&gt; is a function that works just like an ordinary function, except for one thing: when you byte-compile a call to the function (see &lt;a href=&quot;byte-compilation#Byte-Compilation&quot;&gt;Byte Compilation&lt;/a&gt;), the function&amp;rsquo;s definition is expanded into the caller.</source>
          <target state="translated">&lt;em&gt;인라인 함수는&lt;/em&gt; 한 가지를 제외하고, 평범한 기능처럼 작동하는 기능입니다 : 당신이 때 함수 호출 (참조 바이트 컴파일 &lt;a href=&quot;byte-compilation#Byte-Compilation&quot;&gt;바이트 컴파일&lt;/a&gt; ), 함수의 정의는 발신자로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="9f6630c098c66be4689d2cdd9cd8bef1da6dd18e" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;overlay&lt;/em&gt; specifies properties that apply to a part of a buffer. Each overlay applies to a specified range of the buffer, and contains a property list (a list whose elements are alternating property names and values). Overlay properties are used to present parts of the buffer temporarily in a different display style. Overlays have no read syntax, and print in hash notation, giving the buffer name and range of positions.</source>
          <target state="translated">&lt;em&gt;오버레이&lt;/em&gt; 버퍼의 일부에 적용되는 속성을 지정한다. 각 오버레이는 버퍼의 지정된 범위에 적용되며 속성 목록 (요소가 속성 이름과 값을 교대로 사용하는 목록)을 포함합니다. 오버레이 속성은 버퍼의 일부를 일시적으로 다른 표시 스타일로 표시하는 데 사용됩니다. 오버레이에는 읽기 구문이 없으며 해시 표기법으로 인쇄하여 버퍼 이름과 위치 범위를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="07799df1b9d386af6360d33cd65d6f9fe665cd6d" translate="yes" xml:space="preserve">
          <source>An &lt;var&gt;rhs&lt;/var&gt; cannot be an empty list (an empty list is never needed, since SMIE allows all non-terminals to match the empty string anyway).</source>
          <target state="translated">&lt;var&gt;rhs&lt;/var&gt; 빈리스트가 될 수 없습니다 (SMIE이 아닌 모든 단말기 어쨌든 빈 문자열과 일치 할 수 있기 때문에 빈 목록은 필요하지 않습니다).</target>
        </trans-unit>
        <trans-unit id="ad5b32c399f18af984f9755a3f1132417efccd31" translate="yes" xml:space="preserve">
          <source>An &lt;var&gt;rhs&lt;/var&gt; cannot have 2 consecutive non-terminals: each pair of non-terminals needs to be separated by a terminal (aka token). This is a fundamental limitation of operator precedence grammars.</source>
          <target state="translated">&lt;var&gt;rhs&lt;/var&gt; 연속 2 비 - 터미널을 가질 수 없다 : 비 단자 요구들의 각 쌍은 단말기 (일명 토큰)로 구분된다. 이것은 연산자 우선 순위 문법의 근본적인 제한 사항입니다.</target>
        </trans-unit>
        <trans-unit id="7922709da81f687d8271ff998b16af874b1814ac" translate="yes" xml:space="preserve">
          <source>An Emacs &lt;em&gt;character set&lt;/em&gt;, or &lt;em&gt;charset&lt;/em&gt;, is a set of characters in which each character is assigned a numeric code point. (The Unicode Standard calls this a &lt;em&gt;coded character set&lt;/em&gt;.) Each Emacs charset has a name which is a symbol. A single character can belong to any number of different character sets, but it will generally have a different code point in each charset. Examples of character sets include &lt;code&gt;ascii&lt;/code&gt;, &lt;code&gt;iso-8859-1&lt;/code&gt;, &lt;code&gt;greek-iso8859-7&lt;/code&gt;, and &lt;code&gt;windows-1255&lt;/code&gt;. The code point assigned to a character in a charset is usually different from its code point used in Emacs buffers and strings.</source>
          <target state="translated">Emacs &lt;em&gt;문자 세트&lt;/em&gt; 또는 &lt;em&gt;charset&lt;/em&gt; 은 각 문자에 숫자 코드 포인트가 할당 된 문자 세트입니다. (유니 코드 표준에서는 이것을 &lt;em&gt;코드화 된 문자 집합&lt;/em&gt; 이라고 부릅니다 .) 각 Emacs &lt;em&gt;문자 집합&lt;/em&gt; 에는 기호 인 이름이 있습니다. 단일 문자는 여러 다른 문자 세트에 속할 수 있지만 일반적으로 각 문자 세트에서 다른 코드 포인트를 갖습니다. 문자 집합의 예로는 &lt;code&gt;ascii&lt;/code&gt; , &lt;code&gt;iso-8859-1&lt;/code&gt; , &lt;code&gt;greek-iso8859-7&lt;/code&gt; 및 &lt;code&gt;windows-1255&lt;/code&gt; 가 있습니다. 문자 집합의 문자에 할당 된 코드 포인트는 일반적으로 Emacs 버퍼 및 문자열에서 사용되는 코드 포인트와 다릅니다.</target>
        </trans-unit>
        <trans-unit id="b460981854f34e1d2df2695ccac2e570ff87d223" translate="yes" xml:space="preserve">
          <source>An Emacs installation may have a &lt;em&gt;default init file&lt;/em&gt;, which is a Lisp library named</source>
          <target state="translated">Emacs 설치에는 &lt;em&gt;기본 init 파일&lt;/em&gt; 이있을 수 있습니다.이 &lt;em&gt;파일&lt;/em&gt; 은 Lisp 라이브러리입니다.</target>
        </trans-unit>
        <trans-unit id="e2785779758cffeebac8e8b91c79bc832a2d5aa1" translate="yes" xml:space="preserve">
          <source>An abbrev table is represented as an obarray. See &lt;a href=&quot;creating-symbols#Creating-Symbols&quot;&gt;Creating Symbols&lt;/a&gt;, for information about obarrays. Each abbreviation is represented by a symbol in the obarray. The symbol&amp;rsquo;s name is the abbreviation; its value is the expansion; its function definition is the hook function for performing the expansion (see &lt;a href=&quot;defining-abbrevs#Defining-Abbrevs&quot;&gt;Defining Abbrevs&lt;/a&gt;); and its property list cell contains various additional properties, including the use count and the number of times the abbreviation has been expanded (see &lt;a href=&quot;abbrev-properties#Abbrev-Properties&quot;&gt;Abbrev Properties&lt;/a&gt;).</source>
          <target state="translated">약어 테이블은 오바 레이로 표시됩니다. 오바 레이에 대한 정보는 &lt;a href=&quot;creating-symbols#Creating-Symbols&quot;&gt;기호 만들기를&lt;/a&gt; 참조하십시오 . 각 약어는 오바 레이에서 기호로 표시됩니다. 기호의 이름은 약어입니다. 그 가치는 확장입니다. 함수 정의는 확장을 수행하기위한 후크 함수입니다 ( &lt;a href=&quot;defining-abbrevs#Defining-Abbrevs&quot;&gt;Abbrevs 정의&lt;/a&gt; 참조 ). 속성 목록 셀에는 사용 횟수 및 약어가 확장 된 횟수를 비롯한 다양한 추가 속성이 포함됩니다 ( &lt;a href=&quot;abbrev-properties#Abbrev-Properties&quot;&gt;Abbrev 속성&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="e708d184dee6ca64093dbe415ec262b16c5b9ff2" translate="yes" xml:space="preserve">
          <source>An abbreviation or &lt;em&gt;abbrev&lt;/em&gt; is a string of characters that may be expanded to a longer string. The user can insert the abbrev string and find it replaced automatically with the expansion of the abbrev. This saves typing.</source>
          <target state="translated">약어 또는 &lt;em&gt;약어&lt;/em&gt; 는 더 긴 문자열로 확장 할 수있는 문자열입니다. 사용자는 abbrev 문자열을 삽입하고 abbrev 확장으로 자동으로 대체되는 것을 찾을 수 있습니다. 이것은 타이핑을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="8be78449d783fd1e94ea043c27376e317eb4caa7" translate="yes" xml:space="preserve">
          <source>An abnormal hook run by &lt;code&gt;delete-terminal&lt;/code&gt;. Each function receives one argument, the &lt;var&gt;terminal&lt;/var&gt; argument passed to &lt;code&gt;delete-terminal&lt;/code&gt;. Due to technical details, the functions may be called either just before the terminal is deleted, or just afterwards.</source>
          <target state="translated">&lt;code&gt;delete-terminal&lt;/code&gt; 에 의해 실행되는 비정상적인 후크 . 각 함수는 하나의 인수를받습니다. &lt;var&gt;terminal&lt;/var&gt; 인수는 &lt;code&gt;delete-terminal&lt;/code&gt; 에 전달됩니다 . 기술적 세부 사항으로 인해 터미널이 삭제되기 직전 또는 직후에 함수가 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b8b396e23526cbc99aafc9321a68ad76aeb57a7" translate="yes" xml:space="preserve">
          <source>An abnormal hook run by &lt;code&gt;make-frame&lt;/code&gt; after it created the frame. Each function in &lt;code&gt;after-make-frame-functions&lt;/code&gt; receives one argument, the frame just created.</source>
          <target state="translated">&lt;code&gt;make-frame&lt;/code&gt; 을 만든 후 메이크 프레임에 의해 실행되는 비정상적인 후크 . After &lt;code&gt;after-make-frame-functions&lt;/code&gt; 각 함수는 방금 생성 된 프레임 인 하나의 인수를받습니다.</target>
        </trans-unit>
        <trans-unit id="d8587f99198f36ccc0868cfa884bdb9eebf7fda4" translate="yes" xml:space="preserve">
          <source>An abnormal hook run by prefix commands (such as</source>
          <target state="translated">접두사 명령 (예 :</target>
        </trans-unit>
        <trans-unit id="a76206aa6573ab5f6706b29d3c45607d86b5bf4d" translate="yes" xml:space="preserve">
          <source>An action function accepts two arguments: the buffer to display and an action alist. It attempts to display the buffer in some window, picking or creating a window according to its own criteria. If successful, it returns the window; otherwise, it returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">작업 함수는 표시 할 버퍼와 작업 목록의 두 가지 인수를받습니다. 일부 창에 버퍼를 표시하고 자체 기준에 따라 창을 선택하거나 만듭니다. 성공하면 창을 반환합니다. 그렇지 않으면 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b8f8b239306495b67e6a33c553a3311a22ea8108" translate="yes" xml:space="preserve">
          <source>An action function for displaying buffers in side windows.</source>
          <target state="translated">사이드 윈도우에 버퍼를 표시하는 작업 함수입니다.</target>
        </trans-unit>
        <trans-unit id="8d4ccdf032d06b3ff88d7877263294cc83765270" translate="yes" xml:space="preserve">
          <source>An alist of the minor modes of this buffer.</source>
          <target state="translated">이 버퍼의 부 모드 목록입니다.</target>
        </trans-unit>
        <trans-unit id="9d0b7856c0ae1bba2fe0095e327228fef5e6cbeb" translate="yes" xml:space="preserve">
          <source>An alternative to keeping around C data structures that need to be passed to module functions later is to create &lt;em&gt;user pointer&lt;/em&gt; objects. A user pointer, or &lt;code&gt;user-ptr&lt;/code&gt;, object is a Lisp object that encapsulates a C pointer and can have an associated finalizer function, which is called when the object is garbage-collected (see &lt;a href=&quot;garbage-collection#Garbage-Collection&quot;&gt;Garbage Collection&lt;/a&gt;). The module</source>
          <target state="translated">나중에 모듈 함수에 전달해야하는 C 데이터 구조를 유지하는 대안은 &lt;em&gt;사용자 포인터&lt;/em&gt; 객체 를 만드는 것 입니다. 사용자 포인터 또는 &lt;code&gt;user-ptr&lt;/code&gt; 객체는 C 포인터를 캡슐화하고 객체가 가비지 수집 될 때 호출되는 연관된 종료 자 함수를 가질 수있는 Lisp 객체입니다 ( &lt;a href=&quot;garbage-collection#Garbage-Collection&quot;&gt;가비지 수집&lt;/a&gt; 참조 ). 모듈</target>
        </trans-unit>
        <trans-unit id="76745f9f38a9adc0e71accf01a6af367ec394a13" translate="yes" xml:space="preserve">
          <source>An alternative, structured regexp notation.</source>
          <target state="translated">대체 구조화 된 정규식 표기법입니다.</target>
        </trans-unit>
        <trans-unit id="49d23cb0a4197518f11c87451f54d2c79b88ddd3" translate="yes" xml:space="preserve">
          <source>An anonymous face: a property list of the form &lt;code&gt;(&lt;var&gt;keyword&lt;/var&gt;
&lt;var&gt;value&lt;/var&gt; &amp;hellip;)&lt;/code&gt;, where each &lt;var&gt;keyword&lt;/var&gt; is a face attribute name and &lt;var&gt;value&lt;/var&gt; is a value for that attribute.</source>
          <target state="translated">익명의 얼굴 : &lt;code&gt;(&lt;var&gt;keyword&lt;/var&gt; &lt;var&gt;value&lt;/var&gt; &amp;hellip;)&lt;/code&gt; 형식의 속성 목록 . 여기서 각 &lt;var&gt;keyword&lt;/var&gt; 는 얼굴 속성 이름이고 &lt;var&gt;value&lt;/var&gt; 은 해당 속성의 값입니다.</target>
        </trans-unit>
        <trans-unit id="0cb1807f666d0b9ab5deb699a6ca67714dc0387b" translate="yes" xml:space="preserve">
          <source>An application can bind this variable to a non-&lt;code&gt;nil&lt;/code&gt; value around calls to these functions. If it does so, the application is fully responsible for correctly assigning the parameters of all involved windows when exiting that function.</source>
          <target state="translated">응용 프로그램은 이러한 함수에 대한 호출에 대해이 변수를 &lt;code&gt;nil&lt;/code&gt; 이 아닌 값에 바인딩 할 수 있습니다 . 그렇게 할 경우 응용 프로그램은 해당 기능을 종료 할 때 관련된 모든 창의 매개 변수를 올바르게 할당해야합니다.</target>
        </trans-unit>
        <trans-unit id="17ba397de5d1c307ab7dde751562e065ea00e3df" translate="yes" xml:space="preserve">
          <source>An arrow in the left fringe indicates the line where the function is executing. Point initially shows where within the line the function is executing, but this ceases to be true if you move point yourself.</source>
          <target state="translated">왼쪽 가장자리에있는 화살표는 함수가 실행중인 줄을 나타냅니다. Point는 처음에 함수가 실행되는 라인 내 위치를 보여 주지만, 직접 포인트를 이동하면 사실이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="ac945ca03e1203355b8e2eb7095f27f8bf8a33d9" translate="yes" xml:space="preserve">
          <source>An asynchronous process is controlled either via a &lt;em&gt;pty&lt;/em&gt; (pseudo-terminal) or a &lt;em&gt;pipe&lt;/em&gt;. The choice of pty or pipe is made when creating the process, by default based on the value of the variable &lt;code&gt;process-connection-type&lt;/code&gt; (see below). If available, ptys are usually preferable for processes visible to the user, as in Shell mode, because they allow for job control (</source>
          <target state="translated">비동기 프로세스는 &lt;em&gt;pty&lt;/em&gt; (의사 터미널) 또는 &lt;em&gt;파이프&lt;/em&gt; 를 통해 제어됩니다 . pty 또는 pipe는 프로세스를 만들 때 기본적으로 변수 &lt;code&gt;process-connection-type&lt;/code&gt; 의 값을 기반으로 선택됩니다 (아래 참조). 가능한 경우 pty는 작업 제어를 허용하므로 셸 모드에서와 같이 사용자에게 표시되는 프로세스에 대해 일반적으로 선호됩니다 (</target>
        </trans-unit>
        <trans-unit id="fed2f1ab264295d6199c8837444baee7f96bfb5c" translate="yes" xml:space="preserve">
          <source>An autoload object is usually created with the function &lt;code&gt;autoload&lt;/code&gt;, which stores the object in the function cell of a symbol. See &lt;a href=&quot;autoload#Autoload&quot;&gt;Autoload&lt;/a&gt;, for more details.</source>
          <target state="translated">autoload 객체는 일반적으로 기호의 함수 셀에 객체를 저장하는 &lt;code&gt;autoload&lt;/code&gt; 함수로 생성됩니다 . 자세한 내용은 &lt;a href=&quot;autoload#Autoload&quot;&gt;Autoload&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="224896b7315afde30421b984952b3f7096f2d130" translate="yes" xml:space="preserve">
          <source>An autoloaded keymap loads automatically during key lookup when a prefix key&amp;rsquo;s binding is the symbol &lt;var&gt;function&lt;/var&gt;. Autoloading does not occur for other kinds of access to the keymap. In particular, it does not happen when a Lisp program gets the keymap from the value of a variable and calls &lt;code&gt;define-key&lt;/code&gt;; not even if the variable name is the same symbol &lt;var&gt;function&lt;/var&gt;.</source>
          <target state="translated">자동로드 된 키맵은 접두사 키의 바인딩이 기호 &lt;var&gt;function&lt;/var&gt; 경우 키 조회 중에 자동으로로드됩니다 . 키맵에 대한 다른 종류의 액세스에 대해서는 자동로드가 발생하지 않습니다. 특히 Lisp 프로그램이 변수 값에서 키맵을 가져와 &lt;code&gt;define-key&lt;/code&gt; 를 호출 할 때는 발생하지 않습니다 . 변수 이름이 동일한 기호 &lt;var&gt;function&lt;/var&gt; 경우에도 마찬가지 입니다.</target>
        </trans-unit>
        <trans-unit id="b47c8f66af20cead9b4237e06f3de8a32193907c" translate="yes" xml:space="preserve">
          <source>An element can also look like this:</source>
          <target state="translated">요소는 다음과 같이 보일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d07aa0262359efa83d0dc291cc7ca1c53bb48bad" translate="yes" xml:space="preserve">
          <source>An empty element in the value of the environment variable, whether trailing (as in the above example), leading, or embedded, is replaced by the default value of &lt;code&gt;load-path&lt;/code&gt; as determined by the standard initialization procedure. If there are no such empty elements, then &lt;code&gt;EMACSLOADPATH&lt;/code&gt; specifies the entire &lt;code&gt;load-path&lt;/code&gt;. You must include either an empty element, or the explicit path to the directory containing the standard Lisp files, else Emacs will not function. (Another way to modify &lt;code&gt;load-path&lt;/code&gt; is to use the</source>
          <target state="translated">후행 (위의 예에서와 같이), 선행 또는 포함 여부에 관계없이 환경 변수 값의 빈 요소 는 표준 초기화 절차에 의해 결정된 &lt;code&gt;load-path&lt;/code&gt; 의 기본값으로 대체됩니다 . 빈 요소가없는 경우 &lt;code&gt;EMACSLOADPATH&lt;/code&gt; 는 전체 &lt;code&gt;load-path&lt;/code&gt; 를 지정합니다 . 빈 요소 또는 표준 Lisp 파일을 포함하는 디렉토리에 대한 명시 적 경로를 포함해야합니다. 그렇지 않으면 Emacs가 작동하지 않습니다. ( &lt;code&gt;load-path&lt;/code&gt; 를 수정하는 또 다른 방법 은</target>
        </trans-unit>
        <trans-unit id="4ebff7dd30b4758ff88bcc9a085f45ded794db52" translate="yes" xml:space="preserve">
          <source>An empty sequence contributes nothing to the value returned by &lt;code&gt;append&lt;/code&gt;. As a consequence of this, a final &lt;code&gt;nil&lt;/code&gt; argument forces a copy of the previous argument:</source>
          <target state="translated">빈 시퀀스는 &lt;code&gt;append&lt;/code&gt; 가 반환하는 값에 영향을주지 않습니다 . 결과적으로 마지막 &lt;code&gt;nil&lt;/code&gt; 인수는 이전 인수의 복사본을 강제합니다.</target>
        </trans-unit>
        <trans-unit id="a86a8ba20f9c2d16da923dc8e59ec1f1d98d5dee" translate="yes" xml:space="preserve">
          <source>An equivalent expression for &lt;code&gt;(add-to-list '&lt;var&gt;var&lt;/var&gt;
&lt;var&gt;value&lt;/var&gt;)&lt;/code&gt; is this:</source>
          <target state="translated">&lt;code&gt;(add-to-list '&lt;var&gt;var&lt;/var&gt; &lt;var&gt;value&lt;/var&gt;)&lt;/code&gt; 해당하는 표현식 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d3b3af3cc140e3e00a2eb7021cf621de45339c06" translate="yes" xml:space="preserve">
          <source>An error in &lt;var&gt;body&lt;/var&gt; does not undo the load, but does prevent execution of the rest of &lt;var&gt;body&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;body&lt;/var&gt; 의 오류 는 하중을 취소하지 않지만 나머지 &lt;var&gt;body&lt;/var&gt; 실행을 방해 합니다.</target>
        </trans-unit>
        <trans-unit id="780991d8624f2cb2ad931ebb1b65ed8116e288c9" translate="yes" xml:space="preserve">
          <source>An error is signaled if &lt;var&gt;command&lt;/var&gt; is not a function or if it cannot be called interactively (i.e., is not a command). Note that keyboard macros (strings and vectors) are not accepted, even though they are considered commands, because they are not functions. If &lt;var&gt;command&lt;/var&gt; is a symbol, then &lt;code&gt;call-interactively&lt;/code&gt; uses its function definition.</source>
          <target state="translated">경우 오류가 신호되는 &lt;var&gt;command&lt;/var&gt; 함수가 아닌 경우, 혹은 대화식으로 호출 할 수없는 경우 (즉, 명령하지 않습니다). 키보드 매크로 (문자열 및 벡터)는 기능이 아니므로 명령으로 간주 되더라도 허용되지 않습니다. 경우 &lt;var&gt;command&lt;/var&gt; 상징, 다음 &lt;code&gt;call-interactively&lt;/code&gt; 의 기능 정의를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="61727b4effcd7b8d96ef35b8becbc54d386ea1fd" translate="yes" xml:space="preserve">
          <source>An error is signaled if &lt;var&gt;directory&lt;/var&gt; is not the name of a directory that can be read.</source>
          <target state="translated">&lt;var&gt;directory&lt;/var&gt; 가 읽을 수있는 디렉토리의 이름이 아닌 경우 오류가 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="a857332d53570982c6dc820fa3fd199f30c64bac" translate="yes" xml:space="preserve">
          <source>An error is signaled if &lt;var&gt;frame&lt;/var&gt; has no side windows and no saved state is found for it.</source>
          <target state="translated">&lt;var&gt;frame&lt;/var&gt; 에 측면 창이없고 저장된 상태가 없으면 오류가 표시 됩니다.</target>
        </trans-unit>
        <trans-unit id="4c7868057424e94cc2ec18aa245abf34334cd76a" translate="yes" xml:space="preserve">
          <source>An error is signaled if &lt;var&gt;marker&lt;/var&gt; is neither a marker nor an integer.</source>
          <target state="translated">&lt;var&gt;marker&lt;/var&gt; 가 마커도 정수도 아닌 경우 오류가 신호를 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="ce502c5c14b3dd5ab57c7b1bc0667e1dce7ae3f1" translate="yes" xml:space="preserve">
          <source>An error is signaled if &lt;var&gt;name&lt;/var&gt; is not a string.</source>
          <target state="translated">&lt;var&gt;name&lt;/var&gt; 이 문자열이 아닌 경우 오류가 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="d180f585f076cc17698606f42a90ec93eb4bf554" translate="yes" xml:space="preserve">
          <source>An error is signaled if you cannot write or create &lt;var&gt;filename&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;filename&lt;/var&gt; 을 쓰거나 만들 수 없으면 오류가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="4b96760d80ee8b7d0f895bcbd78c4d4e13017398" translate="yes" xml:space="preserve">
          <source>An error is signaled unless both &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt; are integers or markers that indicate positions in the current buffer. (It is unimportant which number is larger.)</source>
          <target state="translated">&lt;var&gt;start&lt;/var&gt; 과 &lt;var&gt;end&lt;/var&gt; 이 모두 현재 버퍼의 위치를 ​​나타내는 정수 또는 마커가 아닌 경우 오류가 표시됩니다. (어떤 숫자가 더 큰지는 중요하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="c51f55b2646e08b61f713ce7217e4887d1b95bfb" translate="yes" xml:space="preserve">
          <source>An error that has no explicit handler may call the Lisp debugger. The debugger is enabled if the variable &lt;code&gt;debug-on-error&lt;/code&gt; (see &lt;a href=&quot;error-debugging#Error-Debugging&quot;&gt;Error Debugging&lt;/a&gt;) is non-&lt;code&gt;nil&lt;/code&gt;. Unlike error handlers, the debugger runs in the environment of the error, so that you can examine values of variables precisely as they were at the time of the error.</source>
          <target state="translated">명시 적 처리기가없는 오류는 Lisp 디버거를 호출 할 수 있습니다. &lt;code&gt;debug-on-error&lt;/code&gt; 변수 ( &lt;a href=&quot;error-debugging#Error-Debugging&quot;&gt;Error Debugging&lt;/a&gt; 참조 )가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 디버거가 활성화됩니다 . 오류 처리기와 달리 디버거는 오류 환경에서 실행되므로 오류 발생 당시의 변수 값을 정확하게 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="826bd3cc8d084ab396a2d00d5bdbe16d54e818a5" translate="yes" xml:space="preserve">
          <source>An ewoc maintains its text in the buffer that is current when you create it, so switch to the intended buffer before calling &lt;code&gt;ewoc-create&lt;/code&gt;.</source>
          <target state="translated">ewoc는 생성 할 때 현재 버퍼에 텍스트를 유지하므로 &lt;code&gt;ewoc-create&lt;/code&gt; 를 호출하기 전에 의도 한 버퍼로 전환하십시오 .</target>
        </trans-unit>
        <trans-unit id="fc38d0c598a08a05ef1cbe7256ecba3cfbdd4bb4" translate="yes" xml:space="preserve">
          <source>An example of a major mode derived from Special mode is Buffer Menu mode, which is used by the</source>
          <target state="translated">특수 모드에서 파생 된 주요 모드의 예는 버퍼 메뉴 모드입니다.</target>
        </trans-unit>
        <trans-unit id="7d6bea7b0ca20a81d8dc92f7b4dfca2a43542cbd" translate="yes" xml:space="preserve">
          <source>An example of a major mode derived from Text mode is HTML mode. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/HTML-Mode.html#HTML-Mode&quot;&gt;SGML and HTML Modes&lt;/a&gt; in</source>
          <target state="translated">텍스트 모드에서 파생 된 주요 모드의 예는 HTML 모드입니다. &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/HTML-Mode.html#HTML-Mode&quot;&gt;SGML 및 HTML 모드&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ade7f0bd288bb8a7ac97abf2b4ebdf07442ec432" translate="yes" xml:space="preserve">
          <source>An example of a special form is the definition of &lt;code&gt;or&lt;/code&gt;, from</source>
          <target state="translated">특별한 형태의 예는의 정의는 &lt;code&gt;or&lt;/code&gt; 로부터,</target>
        </trans-unit>
        <trans-unit id="ef33cd83c0ed34c69762159ed48693bced9fc15f" translate="yes" xml:space="preserve">
          <source>An example of a type descriptor is any instance of &lt;code&gt;cl-structure-class&lt;/code&gt;.</source>
          <target state="translated">유형 설명 자의 예는 &lt;code&gt;cl-structure-class&lt;/code&gt; 의 모든 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="24242de3c100a999285b6229c3f4ecef7f0ccd1f" translate="yes" xml:space="preserve">
          <source>An example of speedup from byte compilation.</source>
          <target state="translated">바이트 컴파일 속도 향상의 예입니다.</target>
        </trans-unit>
        <trans-unit id="db343fa7b3e5ada913fce5ea3283f949a1870619" translate="yes" xml:space="preserve">
          <source>An example of the use of &lt;code&gt;defconst&lt;/code&gt; is Emacs&amp;rsquo;s definition of &lt;code&gt;float-pi&lt;/code&gt;&amp;mdash;the mathematical constant &lt;em&gt;pi&lt;/em&gt;, which ought not to be changed by anyone (attempts by the Indiana State Legislature notwithstanding). As the second form illustrates, however, &lt;code&gt;defconst&lt;/code&gt; is only advisory.</source>
          <target state="translated">&lt;code&gt;defconst&lt;/code&gt; 사용의 예 는 Emacs의 &lt;code&gt;float-pi&lt;/code&gt; 정의입니다. 수학적 상수 &lt;em&gt;pi&lt;/em&gt; 는 누구도 변경해서는 안됩니다 (인디애나 주 입법부의 시도에도 불구하고). 그러나 두 번째 형식에서 알 수 있듯이 &lt;code&gt;defconst&lt;/code&gt; 는 권고 사항 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="33511a390c0a0778aeb50d2d3d11dc55b02fecef" translate="yes" xml:space="preserve">
          <source>An exclusive lock for thread synchronization.</source>
          <target state="translated">스레드 동기화를위한 독점 잠금입니다.</target>
        </trans-unit>
        <trans-unit id="33cdd5563375ee0f1deecf7207e816fded24f27d" translate="yes" xml:space="preserve">
          <source>An extended-format menu item is a more flexible and also cleaner alternative to the simple format. You define an event type with a binding that&amp;rsquo;s a list starting with the symbol &lt;code&gt;menu-item&lt;/code&gt;. For a non-selectable string, the binding looks like this:</source>
          <target state="translated">확장 형식 메뉴 항목은 단순 형식보다 더 유연하고 깔끔한 대안입니다. &lt;code&gt;menu-item&lt;/code&gt; 기호로 시작하는 목록 인 바인딩을 사용하여 이벤트 유형을 정의합니다 . 선택 불가능한 문자열의 경우 바인딩은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dd1c3b20fbc2c4f6fdbfa727cc037df93e3d480a" translate="yes" xml:space="preserve">
          <source>An extra vertical space, with no actual line.</source>
          <target state="translated">실제 선이없는 추가 수직 공간.</target>
        </trans-unit>
        <trans-unit id="7d946c1cee5e1ba6a2795eaa7494b0742a37aa80" translate="yes" xml:space="preserve">
          <source>An image map is an alist where each element has the format &lt;code&gt;(&lt;var&gt;area&lt;/var&gt; &lt;var&gt;id&lt;/var&gt; &lt;var&gt;plist&lt;/var&gt;)&lt;/code&gt;. An &lt;var&gt;area&lt;/var&gt; is specified as either a rectangle, a circle, or a polygon.</source>
          <target state="translated">이미지 맵은 각 요소가 &lt;code&gt;(&lt;var&gt;area&lt;/var&gt; &lt;var&gt;id&lt;/var&gt; &lt;var&gt;plist&lt;/var&gt;)&lt;/code&gt; 형식을 갖는 목록 입니다. &lt;var&gt;area&lt;/var&gt; 사각형, 원형 또는 다각형 중 하나로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="13e8bfffc43f95cb01c82af877179e85c97c1ef2" translate="yes" xml:space="preserve">
          <source>An important function of each major mode is to customize the</source>
          <target state="translated">각 주요 모드의 중요한 기능은</target>
        </trans-unit>
        <trans-unit id="3b4e015d01f5bbc54743f05646c0292a69c90141" translate="yes" xml:space="preserve">
          <source>An indication of the depth of recursive editing levels (not counting minibuffer levels): one &amp;lsquo;</source>
          <target state="translated">재귀 편집 레벨의 깊이 표시 (미니 버퍼 레벨 제외) : 하나의 '</target>
        </trans-unit>
        <trans-unit id="93f69cd72673e3fad1210d3ff536f5eac200198d" translate="yes" xml:space="preserve">
          <source>An indirect buffer cannot visit a file, but its base buffer can. If you try to save the indirect buffer, that actually saves the base buffer.</source>
          <target state="translated">간접 버퍼는 파일을 방문 할 수 없지만 기본 버퍼는 방문 할 수 있습니다. 간접 버퍼를 저장하려고하면 실제로 기본 버퍼가 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="f4f16819d5893d8be64117345439137741280e45" translate="yes" xml:space="preserve">
          <source>An indirect buffer shares text with some other buffer.</source>
          <target state="translated">간접 버퍼는 다른 버퍼와 텍스트를 공유합니다.</target>
        </trans-unit>
        <trans-unit id="dd71440c52babfc9828665c875dc912c73851196" translate="yes" xml:space="preserve">
          <source>An input character event consists of a &lt;em&gt;basic code&lt;/em&gt; between 0 and 524287, plus any or all of these &lt;em&gt;modifier bits&lt;/em&gt;:</source>
          <target state="translated">입력 문자 이벤트는 0에서 524287 사이 의 &lt;em&gt;기본 코드&lt;/em&gt; 와 다음 &lt;em&gt;수정 자 비트&lt;/em&gt; 중 일부 또는 모두로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="b3693e265751b6a87adf1612d2ffab4f6ae73018" translate="yes" xml:space="preserve">
          <source>An integer indicating the Universal Time offset in seconds, i.e., the number of seconds east of Greenwich.</source>
          <target state="translated">세계시 오프셋을 초 단위로 나타내는 정수입니다. 즉, 그리니치 동쪽의 초 수입니다.</target>
        </trans-unit>
        <trans-unit id="1b85b9238ec8e0326b1ff24adce97a9f1339ccd1" translate="yes" xml:space="preserve">
          <source>An integer number specifies the desired total height of the chosen window in lines.</source>
          <target state="translated">정수는 선택한 창의 원하는 총 높이를 라인 단위로 지정합니다.</target>
        </trans-unit>
        <trans-unit id="ae5275ccb64692a25834f62374d3e39ff8168087" translate="yes" xml:space="preserve">
          <source>An integer specifies the desired total width of the chosen window in columns.</source>
          <target state="translated">정수는 선택한 창의 원하는 총 너비를 열로 지정합니다.</target>
        </trans-unit>
        <trans-unit id="c25162540c717d611e1426ca74b4483ad68c8fe4" translate="yes" xml:space="preserve">
          <source>An integer that increments each time Emacs is built in the same directory (without cleaning). This is only of relevance when developing Emacs.</source>
          <target state="translated">Emacs가 동일한 디렉토리에 빌드 될 때마다 증가하는 정수입니다 (청소하지 않음). 이것은 Emacs를 개발할 때만 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a372e2277d8f20cbea84272110bbfb45b40e134a" translate="yes" xml:space="preserve">
          <source>An integer that represents the minimum number of colors the terminal should support. This matches a terminal if its &lt;code&gt;display-color-cells&lt;/code&gt; value is at least the specified integer.</source>
          <target state="translated">터미널이 지원해야하는 최소 색상 수를 나타내는 정수입니다. &lt;code&gt;display-color-cells&lt;/code&gt; 값이 최소한 지정된 정수 이면 터미널과 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="666998409bcbf2ebf0bfb7f00ef2a1f48383fd05" translate="yes" xml:space="preserve">
          <source>An integer, the operating system&amp;rsquo;s process</source>
          <target state="translated">정수, 운영 체제의 프로세스</target>
        </trans-unit>
        <trans-unit id="85068ddc5e4eeb621888a2f24d4968195abea28e" translate="yes" xml:space="preserve">
          <source>An integer, which stands for itself.</source>
          <target state="translated">자체를 나타내는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="483624c83a349249c67af72f64c85e27874fdcce" translate="yes" xml:space="preserve">
          <source>An integer. Although this is the simplest form, it cannot represent subsecond timestamps.</source>
          <target state="translated">정수. 이것은 가장 간단한 형식이지만 1 초 미만의 타임 스탬프를 나타낼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="210e35e78b0bac1a6f24a3e4af59acfd7b9cae5d" translate="yes" xml:space="preserve">
          <source>An interned symbol whose name is read in the minibuffer. Terminate the input with either</source>
          <target state="translated">미니 버퍼에서 이름이 읽혀지는 인턴 심볼. 다음 중 하나로 입력을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="d5c7d47ecad208491b6f75958ec8b743a987742f" translate="yes" xml:space="preserve">
          <source>An irrelevant argument. This code always supplies &lt;code&gt;nil&lt;/code&gt; as the argument&amp;rsquo;s value. No I/O.</source>
          <target state="translated">무관 한 주장. 이 코드는 항상 인수 값으로 &lt;code&gt;nil&lt;/code&gt; 을 제공 합니다. I / O가 없습니다.</target>
        </trans-unit>
        <trans-unit id="27856a404b93377dd2ce26256cf827f21924ee05" translate="yes" xml:space="preserve">
          <source>An object which can be invoked via the &lt;code&gt;command-execute&lt;/code&gt; primitive, usually due to the user typing in a key sequence &lt;em&gt;bound&lt;/em&gt; to that command. See &lt;a href=&quot;interactive-call#Interactive-Call&quot;&gt;Interactive Call&lt;/a&gt;. A command is usually a function; if the function is written in Lisp, it is made into a command by an &lt;code&gt;interactive&lt;/code&gt; form in the function definition (see &lt;a href=&quot;defining-commands#Defining-Commands&quot;&gt;Defining Commands&lt;/a&gt;). Commands that are functions can also be called from Lisp expressions, just like other functions.</source>
          <target state="translated">일반적으로 사용자 가 해당 명령에 &lt;em&gt;바인딩 된&lt;/em&gt; 키 시퀀스를 입력하기 때문에 &lt;code&gt;command-execute&lt;/code&gt; 프리미티브 를 통해 호출 할 수있는 객체입니다 . &lt;a href=&quot;interactive-call#Interactive-Call&quot;&gt;대화 형 통화를&lt;/a&gt; 참조하십시오 . 명령은 일반적으로 함수입니다. 함수가 리스프에 기록되면,이 명령에 의해 이루어진다 &lt;code&gt;interactive&lt;/code&gt; 기능 정의의 형태 (참고 &lt;a href=&quot;defining-commands#Defining-Commands&quot;&gt;정의 명령&lt;/a&gt; ). 함수 인 명령은 다른 함수와 마찬가지로 Lisp 식에서 호출 할 수도 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="187267476807f080e4cb1366bd55dc6c3a734b11" translate="yes" xml:space="preserve">
          <source>An old piece of advice such as:</source>
          <target state="translated">다음과 같은 오래된 조언 :</target>
        </trans-unit>
        <trans-unit id="a4f4924d6a637db199a3dbbcbcca04ca29c457ed" translate="yes" xml:space="preserve">
          <source>An ordinary, unencrypted connection.</source>
          <target state="translated">암호화되지 않은 일반 연결입니다.</target>
        </trans-unit>
        <trans-unit id="8f179ba3c57cb5057b94b469bdc747796dcb263d" translate="yes" xml:space="preserve">
          <source>An output stream specifies what to do with the characters produced by printing. Most print functions accept an output stream as an optional argument. Here are the possible types of output stream:</source>
          <target state="translated">출력 스트림은 인쇄로 생성 된 문자로 수행 할 작업을 지정합니다. 대부분의 인쇄 함수는 출력 스트림을 선택적 인수로받습니다. 가능한 출력 스트림 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4a4e0e2275538ba1b3ea01efe71801a7f7f08073" translate="yes" xml:space="preserve">
          <source>An overlay uses markers to record its beginning and end; thus, editing the text of the buffer adjusts the beginning and end of each overlay so that it stays with the text. When you create the overlay, you can specify whether text inserted at the beginning should be inside the overlay or outside, and likewise for the end of the overlay.</source>
          <target state="translated">오버레이는 마커를 사용하여 시작과 끝을 기록합니다. 따라서 버퍼의 텍스트를 편집하면 각 오버레이의 시작과 끝이 조정되어 텍스트와 함께 유지됩니다. 오버레이를 만들 때 처음에 삽입 된 텍스트가 오버레이 내부에 있어야하는지 외부에 있어야하는지 여부를 지정할 수 있으며, 마찬가지로 오버레이 끝에서도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="b25d5a56d0ee9ca005469f384e566fa726e58945" translate="yes" xml:space="preserve">
          <source>An overlay whose &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt; specify the same buffer position is known as &lt;em&gt;empty&lt;/em&gt;. A non-empty overlay can become empty if the text between its &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt; is deleted. When that happens, the overlay is by default not deleted, but you can cause it to be deleted by giving it the &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;start&lt;/var&gt; 과 &lt;var&gt;end&lt;/var&gt; 이 동일한 버퍼 위치를 지정 하는 오버레이 를 &lt;em&gt;비어 있다고&lt;/em&gt; 합니다. 비어 있지 않은 오버레이는 &lt;var&gt;start&lt;/var&gt; 과 &lt;var&gt;end&lt;/var&gt; 사이의 텍스트 가 삭제 되면 비어있을 수 있습니다 . 이 경우 오버레이는 기본적으로 삭제되지 않지만 '</target>
        </trans-unit>
        <trans-unit id="51ba330dcf0b0a0baa7674c3887cbac685290344" translate="yes" xml:space="preserve">
          <source>An overview of all the special sequences.</source>
          <target state="translated">모든 특수 시퀀스의 개요입니다.</target>
        </trans-unit>
        <trans-unit id="045422a0880a1615b24f5a3a512245b1c27b53c3" translate="yes" xml:space="preserve">
          <source>An unspecified value, present for backward compatibility.</source>
          <target state="translated">이전 버전과의 호환성을 위해 존재하는 지정되지 않은 값입니다.</target>
        </trans-unit>
        <trans-unit id="55764c2c6ec8109ce06467af931be863e9f31e08" translate="yes" xml:space="preserve">
          <source>And here is the code to set up the keymap for Lisp mode:</source>
          <target state="translated">다음은 Lisp 모드 용 키맵을 설정하는 코드입니다.</target>
        </trans-unit>
        <trans-unit id="b6e7a99ffdd1e497ee1a0b6591309c08b6de6ce9" translate="yes" xml:space="preserve">
          <source>Animation operates by means of a timer. Note that Emacs imposes a minimum frame delay of 0.01 (&lt;code&gt;image-minimum-frame-delay&lt;/code&gt;) seconds. If the image itself does not specify a delay, Emacs uses &lt;code&gt;image-default-frame-delay&lt;/code&gt;.</source>
          <target state="translated">애니메이션은 타이머를 통해 작동합니다. Emacs는 0.01 ( &lt;code&gt;image-minimum-frame-delay&lt;/code&gt; ) 초의 최소 프레임 지연을 부과합니다 . 이미지 자체가 지연을 지정하지 않으면 Emacs는 &lt;code&gt;image-default-frame-delay&lt;/code&gt; 를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="6f497993755de46018a5ff1778be3f6bc999629d" translate="yes" xml:space="preserve">
          <source>Anonymous Functions</source>
          <target state="translated">익명 함수</target>
        </trans-unit>
        <trans-unit id="d155a6db1755fd84bc4701702679a300873b3893" translate="yes" xml:space="preserve">
          <source>Another annoyance (more an inconvenience than a limitation) is that when a series of &lt;var&gt;condition&lt;/var&gt; predicates implement equality tests, there is a lot of repeated code. (&lt;code&gt;cl-case&lt;/code&gt; solves this inconvenience.)</source>
          <target state="translated">또 다른 성가심 (제한보다 불편 함)은 일련의 &lt;var&gt;condition&lt;/var&gt; 술어가 동등성 테스트를 구현할 때 반복되는 코드가 많다는 것입니다. ( &lt;code&gt;cl-case&lt;/code&gt; 는이 불편 함을 해결합니다.)</target>
        </trans-unit>
        <trans-unit id="5303f5dba20cc28da9809fdf0b019eb440c2beee" translate="yes" xml:space="preserve">
          <source>Another command,</source>
          <target state="translated">또 다른 명령,</target>
        </trans-unit>
        <trans-unit id="46429506bccc14a1fccf369e49c5519916a0ddea" translate="yes" xml:space="preserve">
          <source>Another difference from &lt;code&gt;rx-let&lt;/code&gt; is that the &lt;var&gt;bindings&lt;/var&gt; are dynamically scoped, and thus also available in functions called from &lt;var&gt;body&lt;/var&gt;. However, they are not visible inside functions defined in &lt;var&gt;body&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;rx-let&lt;/code&gt; 과의 또 다른 차이점 은 &lt;var&gt;bindings&lt;/var&gt; 범위가 동적으로 지정되므로 &lt;var&gt;body&lt;/var&gt; 에서 호출 된 함수에서도 사용할 수 있다는 것입니다 . 그러나 &lt;var&gt;body&lt;/var&gt; 에 정의 된 함수 내에서는 보이지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="60eaf91aef5f334ebb5d4be6e2c8a0357829b694" translate="yes" xml:space="preserve">
          <source>Another disadvantage is that making a large function inline can increase the size of compiled code both in files and in memory. Since the speed advantage of inline functions is greatest for small functions, you generally should not make large functions inline.</source>
          <target state="translated">또 다른 단점은 큰 함수를 인라인으로 만들면 파일과 메모리 모두에서 컴파일 된 코드의 크기가 증가 할 수 있다는 것입니다. 인라인 함수의 속도 이점은 작은 함수에서 가장 크므로 일반적으로 큰 함수를 인라인으로 만들면 안됩니다.</target>
        </trans-unit>
        <trans-unit id="6f719d65bc588f6114e05a3ba91ae2e2b8b0fa12" translate="yes" xml:space="preserve">
          <source>Another effect of calling this function is to cause unconditional redisplay of the mode line for the current buffer. In fact, the function &lt;code&gt;force-mode-line-update&lt;/code&gt; works by doing this:</source>
          <target state="translated">이 함수를 호출하는 또 다른 효과는 현재 버퍼에 대한 모드 행을 무조건 다시 표시하는 것입니다. 실제로 &lt;code&gt;force-mode-line-update&lt;/code&gt; 함수 는 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="fe8d47ec903dba59decabf21d52ed6b989d5e361" translate="yes" xml:space="preserve">
          <source>Another element is &lt;code&gt;(selinux-context . &lt;var&gt;context&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;context&lt;/var&gt; is the SELinux context, in the same form returned by &lt;code&gt;file-selinux-context&lt;/code&gt;.</source>
          <target state="translated">또 다른 요소는 &lt;code&gt;(selinux-context . &lt;var&gt;context&lt;/var&gt;)&lt;/code&gt; 이며, 여기서 &lt;var&gt;context&lt;/var&gt; 는 &lt;code&gt;file-selinux-context&lt;/code&gt; 가 반환하는 동일한 형식의 SELinux 컨텍스트 입니다.</target>
        </trans-unit>
        <trans-unit id="d4a41e64a0f4d5fb203b7d54e395a3a3c7314af2" translate="yes" xml:space="preserve">
          <source>Another file for site-customization is</source>
          <target state="translated">사이트 사용자 지정을위한 또 다른 파일은</target>
        </trans-unit>
        <trans-unit id="dc46fb6acabbfa966b8518e0f2262bc229a7fdf8" translate="yes" xml:space="preserve">
          <source>Another important concept is the notion of &lt;em&gt;parent&lt;/em&gt;: The &lt;em&gt;parent&lt;/em&gt; of a token, is the head token of the nearest enclosing syntactic construct. For example, the parent of an &lt;code&gt;else&lt;/code&gt; is the &lt;code&gt;if&lt;/code&gt; to which it belongs, and the parent of an &lt;code&gt;if&lt;/code&gt;, in turn, is the lead token of the surrounding construct. The command &lt;code&gt;backward-sexp&lt;/code&gt; jumps from a token to its parent, but there are some caveats: for &lt;em&gt;openers&lt;/em&gt; (tokens which start a construct, like &lt;code&gt;if&lt;/code&gt;), you need to start with point before the token, while for others you need to start with point after the token. &lt;code&gt;backward-sexp&lt;/code&gt; stops with point before the parent token if that is the &lt;em&gt;opener&lt;/em&gt; of the token of interest, and otherwise it stops with point after the parent token.</source>
          <target state="translated">또 다른 중요한 개념은 &lt;em&gt;부모&lt;/em&gt; 의 개념입니다 . 토큰 의 &lt;em&gt;부모&lt;/em&gt; 는 가장 가까운 둘러싸는 구문 구조의 헤드 토큰입니다. 예를 들면, 부모의 &lt;code&gt;else&lt;/code&gt; 는 IS &lt;code&gt;if&lt;/code&gt; 되는 속해 및 부모의 &lt;code&gt;if&lt;/code&gt; , 결과적으로, 주변 구조의 토큰 리더이다. &lt;code&gt;backward-sexp&lt;/code&gt; 명령 은 토큰에서 부모로 점프하지만 몇 가지주의 사항이 있습니다. &lt;em&gt;오프너&lt;/em&gt; ( &lt;code&gt;if&lt;/code&gt; 와 같이 구성을 시작하는 토큰 )의 경우 토큰 앞의 점으로 시작해야하는 반면 다른 것에서는 시작해야합니다. 토큰 뒤를 가리 킵니다. &lt;code&gt;backward-sexp&lt;/code&gt; 는 부모 토큰 앞의 포인트로 중지됩니다.&lt;em&gt;&lt;/em&gt;관심 토큰의 &lt;em&gt;오프너&lt;/em&gt; 이며 그렇지 않으면 상위 토큰 뒤의 포인트로 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="b9deb7098c7fabbe640d3f39576b579bcc48e2d3" translate="yes" xml:space="preserve">
          <source>Another problem can happen if the macro definition itself evaluates any of the macro argument expressions, such as by calling &lt;code&gt;eval&lt;/code&gt; (see &lt;a href=&quot;eval#Eval&quot;&gt;Eval&lt;/a&gt;). If the argument is supposed to refer to the user&amp;rsquo;s variables, you may have trouble if the user happens to use a variable with the same name as one of the macro arguments. Inside the macro body, the macro argument binding is the most local binding of this variable, so any references inside the form being evaluated do refer to it. Here is an example:</source>
          <target state="translated">매크로 정의 자체가 &lt;code&gt;eval&lt;/code&gt; 호출과 같이 매크로 인수 표현식을 평가하는 경우 또 다른 문제가 발생할 수 있습니다 ( &lt;a href=&quot;eval#Eval&quot;&gt;Eval&lt;/a&gt; 참조 ). 인수가 사용자의 변수를 참조해야하는 경우 사용자가 매크로 인수 중 하나와 이름이 같은 변수를 사용하면 문제가 발생할 수 있습니다. 매크로 본문 내에서 매크로 인수 바인딩은이 변수의 가장 로컬 바인딩이므로 평가되는 양식 내부의 모든 참조가이를 참조합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0557ba812636c13b28f9c028bebedfc50e7d0d42" translate="yes" xml:space="preserve">
          <source>Another problem with calling &lt;code&gt;eval&lt;/code&gt; in a macro definition is that it probably won&amp;rsquo;t do what you intend in a compiled program. The byte compiler runs macro definitions while compiling the program, when the program&amp;rsquo;s own computations (which you might have wished to access with &lt;code&gt;eval&lt;/code&gt;) don&amp;rsquo;t occur and its local variable bindings don&amp;rsquo;t exist.</source>
          <target state="translated">매크로 정의에서 &lt;code&gt;eval&lt;/code&gt; 을 호출하는 또 다른 문제 는 컴파일 된 프로그램에서 의도 한대로 작동하지 않을 수 있다는 것입니다. 바이트 컴파일러는 프로그램을 컴파일하는 동안 프로그램 자체의 계산 ( &lt;code&gt;eval&lt;/code&gt; 을 사용하여 액세스하려고 할 수 있음 )이 발생하지 않고 해당 지역 변수 바인딩이없는 경우 매크로 정의를 실행 합니다.</target>
        </trans-unit>
        <trans-unit id="2808e270cef0e3cc098d7ecd467a657ae4eca448" translate="yes" xml:space="preserve">
          <source>Another prominent use of property lists is for storing symbol properties. Every symbol possesses a list of properties, used to record miscellaneous information about the symbol; these properties are stored in the form of a property list. See &lt;a href=&quot;symbol-properties#Symbol-Properties&quot;&gt;Symbol Properties&lt;/a&gt;.</source>
          <target state="translated">속성 목록의 또 다른 두드러진 용도는 기호 속성을 저장하는 것입니다. 모든 기호에는 기호에 대한 기타 정보를 기록하는 데 사용되는 속성 목록이 있습니다. 이러한 속성은 속성 목록의 형태로 저장됩니다. &lt;a href=&quot;symbol-properties#Symbol-Properties&quot;&gt;기호 속성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a7cde5f29771c6fd0640e059c163a4125f612e60" translate="yes" xml:space="preserve">
          <source>Another use for &lt;code&gt;image-flush&lt;/code&gt; is for memory conservation. If your Lisp program creates a large number of temporary images over a period much shorter than &lt;code&gt;image-cache-eviction-delay&lt;/code&gt; (see below), you can opt to flush unused images yourself, instead of waiting for Emacs to do it automatically.</source>
          <target state="translated">&lt;code&gt;image-flush&lt;/code&gt; 또 다른 용도 는 메모리 보존입니다. Lisp 프로그램이 &lt;code&gt;image-cache-eviction-delay&lt;/code&gt; (아래 참조) 보다 훨씬 짧은 기간 동안 많은 수의 임시 이미지를 생성하는 경우 , Emacs가 자동으로 수행하기를 기다리는 대신 사용하지 않는 이미지를 직접 플러시하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="641eb2680ee1c66beb56d48bd54946b6ae9853e6" translate="yes" xml:space="preserve">
          <source>Another way of classifying character syntax.</source>
          <target state="translated">문자 구문을 분류하는 또 다른 방법입니다.</target>
        </trans-unit>
        <trans-unit id="4bd2ea34cde1c693974149a710eecd977a89a21d" translate="yes" xml:space="preserve">
          <source>Another way to customize Imenu for a major mode is to set the variables &lt;code&gt;imenu-prev-index-position-function&lt;/code&gt; and &lt;code&gt;imenu-extract-index-name-function&lt;/code&gt;:</source>
          <target state="translated">주요 모드에 대해 Imenu를 사용자 정의하는 또 다른 방법은 &lt;code&gt;imenu-prev-index-position-function&lt;/code&gt; 및 &lt;code&gt;imenu-extract-index-name-function&lt;/code&gt; 변수를 설정하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="6a0538015d82239738c87e340807fdb7d0f6e3a0" translate="yes" xml:space="preserve">
          <source>Answer this question &amp;ldquo;no&amp;rdquo;, and give up on the entire series of questions for the current buffer. Continue to the next buffer in the sequence.</source>
          <target state="translated">이 질문에 &quot;아니오&quot;라고 답하고 현재 버퍼에 대한 전체 질문 시리즈를 포기하십시오. 시퀀스의 다음 버퍼로 계속합니다.</target>
        </trans-unit>
        <trans-unit id="274994b09ea810169b43f8a646ebc9ffc6bce18b" translate="yes" xml:space="preserve">
          <source>Answer this question &amp;ldquo;no&amp;rdquo;, and give up on the entire series of questions, assuming that the answers will be &amp;ldquo;no&amp;rdquo;.</source>
          <target state="translated">이 질문에 &quot;아니오&quot;라고 대답하고 대답이 &quot;아니오&quot;라고 가정하여 일련의 질문 전체를 포기합니다.</target>
        </trans-unit>
        <trans-unit id="d8496e3b1f926969c35562be91206a0af61ee16e" translate="yes" xml:space="preserve">
          <source>Answer this question &amp;ldquo;yes&amp;rdquo;, and give up on the entire series of questions, assuming that subsequent answers will be &amp;ldquo;no&amp;rdquo;.</source>
          <target state="translated">이 질문에 &quot;예&quot;에 대답하고 후속 대답이 &quot;아니오&quot;라고 가정하여 일련의 질문 전체를 포기합니다.</target>
        </trans-unit>
        <trans-unit id="f56b5305911f928e39581a218bfd705b0028549b" translate="yes" xml:space="preserve">
          <source>Answer this question &amp;ldquo;yes&amp;rdquo;, but show the results&amp;mdash;don&amp;rsquo;t advance yet to the next question.</source>
          <target state="translated">이 질문에 &quot;예&quot;에 답하되 결과를 표시하십시오. 아직 다음 질문으로 넘어 가지 마십시오.</target>
        </trans-unit>
        <trans-unit id="c32d375e1b285db59346c4795a32d1241b4b196d" translate="yes" xml:space="preserve">
          <source>Answer this question and all subsequent questions in the series with &amp;ldquo;yes&amp;rdquo;, without further user interaction, for all remaining buffers.</source>
          <target state="translated">나머지 모든 버퍼에 대해 추가 사용자 상호 작용없이이 질문과 시리즈의 모든 후속 질문에 &quot;예&quot;로 대답합니다.</target>
        </trans-unit>
        <trans-unit id="cf8d75f96842754b6fdf5c2cb0d9b07cc288c581" translate="yes" xml:space="preserve">
          <source>Answer this question and all subsequent questions in the series with &amp;ldquo;yes&amp;rdquo;, without further user interaction.</source>
          <target state="translated">추가 사용자 상호 작용없이이 질문과 시리즈의 모든 후속 질문에 &quot;예&quot;로 대답하십시오.</target>
        </trans-unit>
        <trans-unit id="58980dd0f49cd2faac7cab10b446ea677250ef35" translate="yes" xml:space="preserve">
          <source>Antinews</source>
          <target state="translated">Antinews</target>
        </trans-unit>
        <trans-unit id="1fa1accc626834eb5e37df54ce5a411a8faa2f5a" translate="yes" xml:space="preserve">
          <source>Any Lisp program output that would normally go to the echo area, either using &lt;code&gt;message&lt;/code&gt;, or using &lt;code&gt;prin1&lt;/code&gt;, etc., with &lt;code&gt;t&lt;/code&gt; as the stream, goes instead to Emacs&amp;rsquo;s standard descriptors when in batch mode: &lt;code&gt;message&lt;/code&gt; writes to the standard error descriptor, while &lt;code&gt;prin1&lt;/code&gt; and other print functions write to the standard output. Similarly, input that would normally come from the minibuffer is read from the standard input descriptor. Thus, Emacs behaves much like a noninteractive application program. (The echo area output that Emacs itself normally generates, such as command echoing, is suppressed entirely.)</source>
          <target state="translated">일반적으로 &lt;code&gt;message&lt;/code&gt; 를 사용 하거나 &lt;code&gt;t&lt;/code&gt; 를 스트림으로 사용하여 &lt;code&gt;prin1&lt;/code&gt; 등을 사용 하여 echo 영역으로 이동하는 Lisp 프로그램 출력 은 배치 모드에서 Emacs의 표준 설명 자로 대신 이동합니다. &lt;code&gt;message&lt;/code&gt; 는 표준 오류 설명자에 기록됩니다. &lt;code&gt;prin1&lt;/code&gt; 및 기타 인쇄 기능은 표준 출력에 기록합니다. 마찬가지로 일반적으로 미니 버퍼에서 오는 입력은 표준 입력 설명자에서 읽습니다. 따라서 Emacs는 비대화 형 응용 프로그램처럼 작동합니다. (명령 에코와 같이 Emacs가 일반적으로 생성하는 에코 영역 출력은 완전히 억제됩니다.)</target>
        </trans-unit>
        <trans-unit id="050f2a1f992936a9f3bd70f97c3df722975a4ffc" translate="yes" xml:space="preserve">
          <source>Any buffer which does not specify values for these variables uses the values specified by the &lt;code&gt;left-fringe&lt;/code&gt; and &lt;code&gt;right-fringe&lt;/code&gt; frame parameters (see &lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;Layout Parameters&lt;/a&gt;).</source>
          <target state="translated">이러한 변수에 대한 값을 지정하지 않는 모든 버퍼는 &lt;code&gt;left-fringe&lt;/code&gt; 및 &lt;code&gt;right-fringe&lt;/code&gt; 프레임 매개 변수에 지정된 값을 사용합니다 ( &lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;레이아웃 매개 변수&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="fd492b9bb3754cde03d33417c72155f2cdb192d7" translate="yes" xml:space="preserve">
          <source>Any conditional construct can be expressed with &lt;code&gt;cond&lt;/code&gt; or with &lt;code&gt;if&lt;/code&gt;. Therefore, the choice between them is a matter of style. For example:</source>
          <target state="translated">조건부 구문은 &lt;code&gt;cond&lt;/code&gt; 또는 &lt;code&gt;if&lt;/code&gt; 로 표현할 수 있습니다 . 따라서 그들 사이의 선택은 스타일의 문제입니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="6a06364a7a0a952bf465c39928bf99f3f61b0422" translate="yes" xml:space="preserve">
          <source>Any connection profile of &lt;var&gt;profiles&lt;/var&gt; must have been already defined by &lt;code&gt;connection-local-set-profile-variables&lt;/code&gt;.</source>
          <target state="translated">임의 접속 프로파일 &lt;var&gt;profiles&lt;/var&gt; 이미 의해 정의되어 있어야 &lt;code&gt;connection-local-set-profile-variables&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a92544790b0c628c4a67c0d9ad0654a8710429c7" translate="yes" xml:space="preserve">
          <source>Any function or macro defined as Lisp code may be set to break on entry, regardless of whether it is interpreted code or compiled code. If the function is a command, it will enter the debugger when called from Lisp and when called interactively (after the reading of the arguments). You can also set debug-on-entry for primitive functions (i.e., those written in C) this way, but it only takes effect when the primitive is called from Lisp code. Debug-on-entry is not allowed for special forms.</source>
          <target state="translated">Lisp 코드로 정의 된 모든 함수 또는 매크로는 해석 된 코드인지 컴파일 된 코드인지에 관계없이 진입시 중단되도록 설정할 수 있습니다. 함수가 명령 인 경우 Lisp에서 호출 될 때와 대화식으로 호출 될 때 (인수를 읽은 후) 디버거에 들어갑니다. 이 방법으로 기본 함수 (즉, C로 작성된 함수)에 대한 진입시 디버그를 설정할 수도 있지만, 이는 기본 함수가 Lisp 코드에서 호출 될 때만 적용됩니다. 입력시 디버그는 특수 양식에 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8638b648157581df0efb6302834ee2f03492764d" translate="yes" xml:space="preserve">
          <source>Any integer glyph code greater than or equal to the length of the glyph table is displayed literally.</source>
          <target state="translated">글리프 테이블의 길이보다 크거나 같은 정수 글리프 코드는 문자 그대로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="4c6a27c6563d69b7aca82f351f60298b13184203" translate="yes" xml:space="preserve">
          <source>Any kind of Lisp code is valid inside &lt;var&gt;body&lt;/var&gt;, but &lt;code&gt;iter-yield&lt;/code&gt; and &lt;code&gt;iter-yield-from&lt;/code&gt; cannot appear inside &lt;code&gt;unwind-protect&lt;/code&gt; forms.</source>
          <target state="translated">모든 종류의 Lisp 코드는 &lt;var&gt;body&lt;/var&gt; 내부에서 유효 하지만 &lt;code&gt;iter-yield&lt;/code&gt; 및 &lt;code&gt;iter-yield-from&lt;/code&gt; 은 &lt;code&gt;unwind-protect&lt;/code&gt; 양식 내부에 나타날 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="a4fc7cbf2349da81499a5258b7f6c62e471e0a86" translate="yes" xml:space="preserve">
          <source>Any of the above window elements (except &lt;code&gt;text&lt;/code&gt;) can also be used with &lt;code&gt;:align-to&lt;/code&gt; to specify that the position is relative to the left edge of the given area. Once the base offset for a relative position has been set (by the first occurrence of one of these symbols), further occurrences of these symbols are interpreted as the width of the specified area. For example, to align to the center of the left-margin, use</source>
          <target state="translated">위의 모든 창 요소 ( &lt;code&gt;text&lt;/code&gt; 제외 )를 &lt;code&gt;:align-to&lt;/code&gt; 와 함께 사용 하여 위치가 지정된 영역의 왼쪽 가장자리에 상대적임을 지정할 수 있습니다. 상대 위치에 대한 기본 오프셋이 설정되면 (이러한 기호 중 하나의 첫 번째 발생에 의해) 이러한 기호의 추가 발생은 지정된 영역의 너비로 해석됩니다. 예를 들어, 왼쪽 여백의 중앙에 맞추려면</target>
        </trans-unit>
        <trans-unit id="947bbfa4cfb925a66b42d553b356034e0c632a8d" translate="yes" xml:space="preserve">
          <source>Any of these arguments can be given to identify the process that is to be configured. If none of these arguments is given, the current buffer&amp;rsquo;s process is used.</source>
          <target state="translated">이러한 인수는 구성 할 프로세스를 식별하기 위해 제공 될 수 있습니다. 이러한 인수가 제공되지 않으면 현재 버퍼의 프로세스가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d761e83aca259b6c169b8f0ba443733debb02169" translate="yes" xml:space="preserve">
          <source>Any other character following &amp;lsquo;</source>
          <target state="translated">'뒤에 오는 다른 모든 문자</target>
        </trans-unit>
        <trans-unit id="8b9b2ed191d1fda99979a3c9c2769788ca05c905" translate="yes" xml:space="preserve">
          <source>Any other format character results in an &amp;lsquo;</source>
          <target state="translated">다른 형식 문자는 '</target>
        </trans-unit>
        <trans-unit id="da32c3cdd65afe4fd7df1698891716e553030ff9" translate="yes" xml:space="preserve">
          <source>Any other keyword arguments are passed directly to the &lt;code&gt;defcustom&lt;/code&gt; generated for the variable &lt;var&gt;mode&lt;/var&gt;.</source>
          <target state="translated">다른 키워드 인수는 변수 &lt;var&gt;mode&lt;/var&gt; 대해 생성 된 &lt;code&gt;defcustom&lt;/code&gt; 에 직접 전달 됩니다 .</target>
        </trans-unit>
        <trans-unit id="a9dd7d9e5f6c66323cdba5127ceece8bda299da3" translate="yes" xml:space="preserve">
          <source>Any other kind of property value is a height spec, which translates into a number&amp;mdash;the specified line height. There are several ways to write a height spec; here&amp;rsquo;s how each of them translates into a number:</source>
          <target state="translated">다른 종류의 속성 값은 높이 사양으로, 지정된 줄 높이 인 숫자로 변환됩니다. 높이 사양을 작성하는 방법에는 여러 가지가 있습니다. 각각이 숫자로 변환되는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="80c9ec34ade8e4048b77d042cf2894fc4d219cf7" translate="yes" xml:space="preserve">
          <source>Any other list is a &lt;em&gt;sublist specification&lt;/em&gt; and the argument must be a list whose elements match the specification &lt;var&gt;elements&lt;/var&gt;.</source>
          <target state="translated">다른 목록은 &lt;em&gt;하위&lt;/em&gt; 목록 &lt;em&gt;사양&lt;/em&gt; 이며 인수는 요소가 사양 &lt;var&gt;elements&lt;/var&gt; 와 일치하는 목록이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="efc5f087f8ebb1db404013a2d9b97f161e290782" translate="yes" xml:space="preserve">
          <source>Any other non-&lt;code&gt;nil&lt;/code&gt; value means to resize minibuffer-only frames by calling &lt;code&gt;fit-frame-to-buffer&lt;/code&gt; (see &lt;a href=&quot;resizing-windows#Resizing-Windows&quot;&gt;Resizing Windows&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; 이 아닌 다른 값은 &lt;code&gt;fit-frame-to-buffer&lt;/code&gt; 를 호출하여 미니 버퍼 전용 프레임의 크기를 조정하는 것을 의미합니다 ( &lt;a href=&quot;resizing-windows#Resizing-Windows&quot;&gt;Windows 크기 조정&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="de1dca44c2e30439c9ac0151a01ef3eee3bfac38" translate="yes" xml:space="preserve">
          <source>Any other non-&lt;code&gt;nil&lt;/code&gt; value means to select a window instantaneously as soon as the mouse pointer enters it.</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; 이 아닌 다른 값은 마우스 포인터가 창에 들어가는 즉시 창을 선택하는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="e871933984652498dd2af321ce39af05be929b56" translate="yes" xml:space="preserve">
          <source>Any other symbol in a specification list may be a predicate or an indirect specification.</source>
          <target state="translated">사양 목록의 다른 기호는 술어 또는 간접 사양 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbbabe65f60d7295c7911e33efd55bcf43789dbf" translate="yes" xml:space="preserve">
          <source>Any other value for &lt;var&gt;order&lt;/var&gt; removes the numeric order of &lt;var&gt;element&lt;/var&gt; if it already has one; otherwise, it is equivalent to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;order&lt;/var&gt; 에 대한 다른 값은 이미 &lt;var&gt;element&lt;/var&gt; 경우 요소 의 숫자 순서를 제거합니다 . 그렇지 않으면 &lt;code&gt;nil&lt;/code&gt; 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="8680b4e68cce538925a1e5ee144f0189a305515f" translate="yes" xml:space="preserve">
          <source>Any other value means consider windows on the selected frame.</source>
          <target state="translated">다른 값은 선택한 프레임의 창을 고려함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="15b4bce70cfe3f06b7b1a2f9ed3099030510e5dc" translate="yes" xml:space="preserve">
          <source>Any other value means to try iconifying the child frame. Since such an attempt may not be honored by all window managers and can even lead to making the child frame unresponsive to user actions, the default is to iconify the top level frame instead.</source>
          <target state="translated">다른 값은 자식 프레임을 아이콘 화하는 것을 의미합니다. 이러한 시도는 모든 창 관리자에 의해 인정되지 않을 수 있으며 하위 프레임이 사용자 작업에 응답하지 않게 만들 수도 있으므로 기본값은 대신 최상위 프레임을 아이콘 화하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ebda99dde61c93e02da1a43ffb05fdba89a8d98e" translate="yes" xml:space="preserve">
          <source>Any other value of &lt;var&gt;require-match&lt;/var&gt; behaves like &lt;code&gt;t&lt;/code&gt;, except that the exit commands won&amp;rsquo;t exit if it performs completion.</source>
          <target state="translated">&lt;var&gt;require-match&lt;/var&gt; 의 다른 모든 값 은 완료를 수행해도 종료 명령이 종료되지 않는다는 점을 제외하고 &lt;code&gt;t&lt;/code&gt; 와 같이 동작 합니다.</target>
        </trans-unit>
        <trans-unit id="86b521e158439e11f2ef9516804d10581a8219f2" translate="yes" xml:space="preserve">
          <source>Any parameters not mentioned in &lt;var&gt;parameters&lt;/var&gt; default to the values in the alist &lt;code&gt;default-frame-alist&lt;/code&gt; (see &lt;a href=&quot;initial-parameters#Initial-Parameters&quot;&gt;Initial Parameters&lt;/a&gt;); parameters not specified there default from the X resources or its equivalent on your operating system (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/X-Resources.html#X-Resources&quot;&gt;X Resources&lt;/a&gt; in</source>
          <target state="translated">매개 변수에 언급되지 않은 &lt;var&gt;parameters&lt;/var&gt; 기본적으로 alist &lt;code&gt;default-frame-alist&lt;/code&gt; 의 값으로 설정됩니다 ( &lt;a href=&quot;initial-parameters#Initial-Parameters&quot;&gt;초기 매개 변수&lt;/a&gt; 참조 ). 매개 변수가 아닌 X 리소스에서이 기본을 지정하거나 운영 체제 (참조에 이에 상응하는 &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/X-Resources.html#X-Resources&quot;&gt;X 자원&lt;/a&gt; 에</target>
        </trans-unit>
        <trans-unit id="9860f00e606061647e41c129f0e0903be5e003a1" translate="yes" xml:space="preserve">
          <source>Any processes that have this buffer as the &lt;code&gt;process-buffer&lt;/code&gt; are sent the &lt;code&gt;SIGHUP&lt;/code&gt; (hangup) signal, which normally causes them to terminate. See &lt;a href=&quot;signals-to-processes#Signals-to-Processes&quot;&gt;Signals to Processes&lt;/a&gt;.</source>
          <target state="translated">이 버퍼를 &lt;code&gt;process-buffer&lt;/code&gt; 버퍼로 사용하는 모든 프로세스 는 &lt;code&gt;SIGHUP&lt;/code&gt; (중단) 신호를 보내며 일반적으로 종료됩니다. &lt;a href=&quot;signals-to-processes#Signals-to-Processes&quot;&gt;프로세스에 대한 신호를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="545802d960c72afb533f784369e021b83a96956f" translate="yes" xml:space="preserve">
          <source>Any redisplay triggering the run of window change functions may be aborted. If the abort occurs before window change functions have run to their completion, they will be run again with the previous values, that is, as if redisplay had not been performed. If aborted later, they will be run with the new values, that is, as if redisplay had been actually performed.</source>
          <target state="translated">창 변경 기능의 실행을 트리거하는 모든 재 표시는 중단 될 수 있습니다. 창 변경 기능이 완료되기 전에 중단이 발생하면 이전 값으로 다시 실행됩니다. 즉, 다시 표시가 수행되지 않은 것처럼 실행됩니다. 나중에 중단되면 새 값, 즉 다시 표시가 실제로 수행 된 것처럼 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="7024b793b36bc3e3bb195637c26938af29b056cc" translate="yes" xml:space="preserve">
          <source>Any two distinct Lisp objects are different as keys.</source>
          <target state="translated">두 개의 개별 Lisp 개체는 키로 다릅니다.</target>
        </trans-unit>
        <trans-unit id="2402827e518f1d5fcdc03543bf7c6c4f8b5d7ef6" translate="yes" xml:space="preserve">
          <source>Any two regular expressions &lt;var&gt;a&lt;/var&gt; and &lt;var&gt;b&lt;/var&gt; can be concatenated. The result is a regular expression that matches a string if &lt;var&gt;a&lt;/var&gt; matches some amount of the beginning of that string and &lt;var&gt;b&lt;/var&gt; matches the rest of the string.</source>
          <target state="translated">두 개의 정규식 &lt;var&gt;a&lt;/var&gt; 와 &lt;var&gt;b&lt;/var&gt; 를 연결할 수 있습니다. 결과는 경우 문자열과 일치하는 정규 표현식입니다 &lt;var&gt;a&lt;/var&gt; 해당 문자열의 시작 부분의 일부 금액을 일치하고 &lt;var&gt;b&lt;/var&gt; 는 문자열의 나머지 부분과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="45ffc4ae2f26e287178694c6132c38fe72023bb0" translate="yes" xml:space="preserve">
          <source>Any unhandled errors while loading a file terminate loading. If the load was done for the sake of &lt;code&gt;autoload&lt;/code&gt;, any function definitions made during the loading are undone.</source>
          <target state="translated">파일을로드하는 동안 처리되지 않은 오류는로드를 종료합니다. &lt;code&gt;autoload&lt;/code&gt; 를 위해로드가 수행 된 경우로드 중에 작성된 모든 함수 정의가 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="1ceb1e23a710f2ab6b34678613c9db79937409cd" translate="yes" xml:space="preserve">
          <source>Any variable whose name has a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;risky-local-variable&lt;/code&gt; property is considered risky. When you define a user option using &lt;code&gt;defcustom&lt;/code&gt;, you can set its &lt;code&gt;risky-local-variable&lt;/code&gt; property by adding the arguments &lt;code&gt;:risky &lt;var&gt;value&lt;/var&gt;&lt;/code&gt; to &lt;code&gt;defcustom&lt;/code&gt; (see &lt;a href=&quot;variable-definitions#Variable-Definitions&quot;&gt;Variable Definitions&lt;/a&gt;). In addition, any variable whose name ends in any of &amp;lsquo;</source>
          <target state="translated">이름에 &lt;code&gt;nil&lt;/code&gt; 이 아닌 &lt;code&gt;risky-local-variable&lt;/code&gt; 속성이있는 모든 변수 는 위험한 것으로 간주됩니다. 당신이 사용하여 사용자 옵션을 정의 할 때 &lt;code&gt;defcustom&lt;/code&gt; 을 , 당신은 설정할 수 있습니다 &lt;code&gt;risky-local-variable&lt;/code&gt; 인수를 추가하여 재산을 &lt;code&gt;:risky &lt;var&gt;value&lt;/var&gt;&lt;/code&gt; 에 &lt;code&gt;defcustom&lt;/code&gt; (참조 &lt;a href=&quot;variable-definitions#Variable-Definitions&quot;&gt;변수 정의를&lt;/a&gt; ). 또한 이름이 '</target>
        </trans-unit>
        <trans-unit id="2146f7db0997563acb7fa242e2c3506c43699f4a" translate="yes" xml:space="preserve">
          <source>Anything else means to consider windows on &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s frame, and no others.</source>
          <target state="translated">다른 것은 &lt;var&gt;window&lt;/var&gt; 프레임의 창만 고려한다는 의미 입니다.</target>
        </trans-unit>
        <trans-unit id="ed179d7c24b9f78db2acddd1c26cf5d5e3a10309" translate="yes" xml:space="preserve">
          <source>Apart from Fundamental mode, there are three major modes that other major modes commonly derive from: Text mode, Prog mode, and Special mode. While Text mode is useful in its own right (e.g., for editing files ending in</source>
          <target state="translated">기본 모드 외에도 다른 주요 모드가 일반적으로 파생되는 세 가지 주요 모드가 있습니다. 텍스트 모드, 프로그램 모드 및 특수 모드입니다. 텍스트 모드는 그 자체로 유용하지만 (예 :</target>
        </trans-unit>
        <trans-unit id="d92f266ff96117cb3b55d3ff2938ee734d58418c" translate="yes" xml:space="preserve">
          <source>Apart from the above usual keymaps, Emacs provides special ways for programs to make other keymaps active. Firstly, the variable &lt;code&gt;overriding-local-map&lt;/code&gt; specifies a keymap that replaces the usual active keymaps, except for the global keymap. Secondly, the terminal-local variable &lt;code&gt;overriding-terminal-local-map&lt;/code&gt; specifies a keymap that takes precedence over &lt;em&gt;all&lt;/em&gt; other keymaps (including &lt;code&gt;overriding-local-map&lt;/code&gt;); this is normally used for modal/transient keybindings (the function &lt;code&gt;set-transient-map&lt;/code&gt; provides a convenient interface for this). See &lt;a href=&quot;controlling-active-maps#Controlling-Active-Maps&quot;&gt;Controlling Active Maps&lt;/a&gt;, for details.</source>
          <target state="translated">위의 일반적인 키맵 외에도 Emacs는 프로그램이 다른 키맵을 활성화하는 특별한 방법을 제공합니다. 첫째, &lt;code&gt;overriding-local-map&lt;/code&gt; 변수 는 전역 키맵을 제외하고 일반적인 활성 키맵을 대체하는 키맵을 지정합니다. 둘째, 터미널 로컬 변수 &lt;code&gt;overriding-terminal-local-map&lt;/code&gt; 은 다른 &lt;em&gt;모든&lt;/em&gt; 키맵 ( &lt;code&gt;overriding-local-map&lt;/code&gt; 포함) 보다 우선하는 키맵을 지정합니다 . 이것은 일반적으로 모달 / 과도 키 바인딩에 사용됩니다 (함수 &lt;code&gt;set-transient-map&lt;/code&gt; 은이를위한 편리한 인터페이스를 제공합니다). 자세한 내용은 &lt;a href=&quot;controlling-active-maps#Controlling-Active-Maps&quot;&gt;활성 맵 제어&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a68119502a0311abd68d0719c5b77a5911c9e84f" translate="yes" xml:space="preserve">
          <source>Apart from the functions documented in this section, you can print Lisp objects to the echo area by specifying &lt;code&gt;t&lt;/code&gt; as the output stream. See &lt;a href=&quot;output-streams#Output-Streams&quot;&gt;Output Streams&lt;/a&gt;.</source>
          <target state="translated">이 섹션에서 설명하는 함수 외에도 &lt;code&gt;t&lt;/code&gt; 를 출력 스트림으로 지정하여 Lisp 객체를 에코 영역에 인쇄 할 수 있습니다 . &lt;a href=&quot;output-streams#Output-Streams&quot;&gt;출력 스트림을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1cd2802aef7e489fd6909738c550b3b9f5ec028d" translate="yes" xml:space="preserve">
          <source>Apart from the values given below, each face attribute can have the value &lt;code&gt;unspecified&lt;/code&gt;. This special value means that the face doesn&amp;rsquo;t specify that attribute directly. An &lt;code&gt;unspecified&lt;/code&gt; attribute tells Emacs to refer instead to a parent face (see the description &lt;code&gt;:inherit&lt;/code&gt; attribute below); or, failing that, to an underlying face (see &lt;a href=&quot;displaying-faces#Displaying-Faces&quot;&gt;Displaying Faces&lt;/a&gt;). The &lt;code&gt;default&lt;/code&gt; face must specify all attributes.</source>
          <target state="translated">아래에 제공된 값을 제외하고 각 face 속성은 &lt;code&gt;unspecified&lt;/code&gt; 값을 가질 수 있습니다 . 이 특수 값은 얼굴이 해당 속성을 직접 지정하지 않음을 의미합니다. &lt;code&gt;unspecified&lt;/code&gt; 속성은 부모의 얼굴 (설명 참조 대신 참조 이맥스를 알려줍니다 &lt;code&gt;:inherit&lt;/code&gt; 아래 속성); 또는 실패하면 기본 얼굴로 이동합니다 (얼굴 &lt;a href=&quot;displaying-faces#Displaying-Faces&quot;&gt;표시&lt;/a&gt; 참조 ). &lt;code&gt;default&lt;/code&gt; 얼굴은 모든 속성을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="f240948e5698f084e306e2f0433d5215c7e9dc03" translate="yes" xml:space="preserve">
          <source>Append &lt;var&gt;child&lt;/var&gt; as the last child of &lt;var&gt;node&lt;/var&gt;.</source>
          <target state="translated">자식을 &lt;var&gt;node&lt;/var&gt; 의 마지막 &lt;var&gt;child&lt;/var&gt; 으로 추가 합니다 .</target>
        </trans-unit>
        <trans-unit id="73973cfd168d40bb8277e2f6044ecdb605409c4e" translate="yes" xml:space="preserve">
          <source>Appendices</source>
          <target state="translated">Appendices</target>
        </trans-unit>
        <trans-unit id="6453a2437bbdcb5f8fffb150dbc05d248106b629" translate="yes" xml:space="preserve">
          <source>Applications should put a function on this hook only if they want to react to changes that happened on (or have been signaled for) two or more frames since last redisplay. In every other case, putting the function on &lt;code&gt;window-state-change-functions&lt;/code&gt; should be preferred.</source>
          <target state="translated">응용 프로그램은 마지막 다시 표시 이후 두 개 이상의 프레임에서 발생한 (또는 신호를받은) 변경 사항에 반응하려는 경우에만이 후크에 함수를 배치해야합니다. 다른 모든 경우에는 함수를 &lt;code&gt;window-state-change-functions&lt;/code&gt; 기능에 두는 것이 선호되어야합니다.</target>
        </trans-unit>
        <trans-unit id="26de2593285b5ae9fccf013cfbb25224e0f5a299" translate="yes" xml:space="preserve">
          <source>Applying Customizations</source>
          <target state="translated">사용자 지정 적용</target>
        </trans-unit>
        <trans-unit id="36aa9251a3a7a8564f2137c662428024f6ade2c8" translate="yes" xml:space="preserve">
          <source>Applying a function to each element of a list, etc.</source>
          <target state="translated">목록의 각 요소에 함수 적용 등</target>
        </trans-unit>
        <trans-unit id="8d1feffaedb79bbeb47768ea8d15131f798d1c88" translate="yes" xml:space="preserve">
          <source>Arbitrary text, read in the minibuffer and returned as a string (see &lt;a href=&quot;text-from-minibuffer#Text-from-Minibuffer&quot;&gt;Text from Minibuffer&lt;/a&gt;). Terminate the input with either</source>
          <target state="translated">&lt;a href=&quot;text-from-minibuffer#Text-from-Minibuffer&quot;&gt;미니 버퍼에서 읽고&lt;/a&gt; 문자열로 반환되는 임의 텍스트입니다 ( 미니 버퍼의 텍스트 참조 ). 다음 중 하나로 입력을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="7d9f86d28b0c0c91c1eb18ed796eb1ba12533f22" translate="yes" xml:space="preserve">
          <source>Arbitrary text, read in the minibuffer using the current buffer&amp;rsquo;s input method, and returned as a string (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Input-Methods.html#Input-Methods&quot;&gt;Input Methods&lt;/a&gt; in</source>
          <target state="translated">임의의 텍스트, 현재 버퍼의 입력 방법을 사용하여 미니 버퍼에서 읽고 문자열로 반환합니다 ( &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Input-Methods.html#Input-Methods&quot;&gt;입력 방법&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="bd4951fd6a7c3feab0f23a3cd32635bc99258318" translate="yes" xml:space="preserve">
          <source>Args out of range</source>
          <target state="translated">범위를 벗어난 인수</target>
        </trans-unit>
        <trans-unit id="0c474d136d838c73efef53606031eb17d140e04e" translate="yes" xml:space="preserve">
          <source>Arguments to &lt;code&gt;literal&lt;/code&gt; and &lt;code&gt;regexp&lt;/code&gt; forms in &lt;var&gt;rx-expr&lt;/var&gt; must be string literals.</source>
          <target state="translated">&lt;var&gt;rx-expr&lt;/var&gt; 의 &lt;code&gt;literal&lt;/code&gt; 및 &lt;code&gt;regexp&lt;/code&gt; 형식에 대한 인수 는 문자열 리터럴이어야합니다.</target>
        </trans-unit>
        <trans-unit id="067d717a61de8fed36456114a24a52f9975bc09e" translate="yes" xml:space="preserve">
          <source>Arithmetic Operations</source>
          <target state="translated">산술 연산</target>
        </trans-unit>
        <trans-unit id="e9ba134322b748a6c1b2b91140e83920bb3352f8" translate="yes" xml:space="preserve">
          <source>Arithmetic error</source>
          <target state="translated">산술 오류</target>
        </trans-unit>
        <trans-unit id="11d55c8ac9f9031983e49487cf4e01cc836699f5" translate="yes" xml:space="preserve">
          <source>Arithmetic overflow error</source>
          <target state="translated">산술 오버플로 오류</target>
        </trans-unit>
        <trans-unit id="d11aaaa37e2311485d3875fbb3013fe0f23d4b0b" translate="yes" xml:space="preserve">
          <source>Around advice such as:</source>
          <target state="translated">다음과 같은 조언을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="41fcc6cba3496dc0275b2af2eceda84dfb41da3d" translate="yes" xml:space="preserve">
          <source>Arrange to scan these files when producing the</source>
          <target state="translated">제작시 이러한 파일을 스캔하도록</target>
        </trans-unit>
        <trans-unit id="5a208284047f94a448814865ab5ceb940cbbaf32" translate="yes" xml:space="preserve">
          <source>Arranging to run a cleanup form if an error happens.</source>
          <target state="translated">오류가 발생하면 정리 양식을 실행하도록 배열합니다.</target>
        </trans-unit>
        <trans-unit id="238a5476b2b099dbf0d0f2fd0cf448d18972ec8a" translate="yes" xml:space="preserve">
          <source>Array Type</source>
          <target state="translated">배열 유형</target>
        </trans-unit>
        <trans-unit id="73e54889ed8e57216f0ca1581847b9782331ae4c" translate="yes" xml:space="preserve">
          <source>Array, a fixed-size set of Lisp objects which may be accessed by an index.</source>
          <target state="translated">인덱스로 액세스 할 수있는 고정 된 크기의 Lisp 개체 집합 인 배열입니다.</target>
        </trans-unit>
        <trans-unit id="b90cc9bfd23567a2ff5ba1f00e7c63ca6da8755e" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Arrays</target>
        </trans-unit>
        <trans-unit id="081ca36507218ed52666e78775654403a5cbd1aa" translate="yes" xml:space="preserve">
          <source>Arrays are fixed-length sequences. They are further subdivided into strings, vectors, char-tables and bool-vectors. Vectors can hold elements of any type, whereas string elements must be characters, and bool-vector elements must be &lt;code&gt;t&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;. Char-tables are like vectors except that they are indexed by any valid character code. The characters in a string can have text properties like characters in a buffer (see &lt;a href=&quot;text-properties#Text-Properties&quot;&gt;Text Properties&lt;/a&gt;), but vectors do not support text properties, even when their elements happen to be characters.</source>
          <target state="translated">배열은 고정 길이 시퀀스입니다. 문자열, 벡터, 문자 테이블 및 부울 벡터로 더 세분화됩니다. 벡터는 모든 유형의 요소를 보유 할 수 있지만 string 요소는 문자 여야하고 bool-vector 요소는 &lt;code&gt;t&lt;/code&gt; 또는 &lt;code&gt;nil&lt;/code&gt; 이어야합니다 . 문자 테이블은 유효한 문자 코드로 색인화된다는 점을 제외하면 벡터와 같습니다. 문자열의 문자는 버퍼의 문자와 같은 텍스트 속성을 가질 수 있지만 ( &lt;a href=&quot;text-properties#Text-Properties&quot;&gt;Text 속성&lt;/a&gt; 참조 ) 벡터는 요소가 문자 인 경우에도 텍스트 속성을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ce9ceca356ae903e8b84ce8876d693efd3ec5212" translate="yes" xml:space="preserve">
          <source>Arrays include strings and vectors.</source>
          <target state="translated">배열에는 문자열과 벡터가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="2a256f62beeee99618180946ede4c7802661b91b" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;lsh&lt;/code&gt; behaves like &lt;code&gt;ash&lt;/code&gt; except when &lt;var&gt;integer1&lt;/var&gt; and &lt;var&gt;count1&lt;/var&gt; are both negative, the following examples focus on these exceptional cases. These examples assume 30-bit fixnums.</source>
          <target state="translated">으로 &lt;code&gt;lsh&lt;/code&gt; 같은 동작합니다 &lt;code&gt;ash&lt;/code&gt; 경우를 제외하고 &lt;var&gt;integer1&lt;/var&gt; 은 과 &lt;var&gt;count1&lt;/var&gt; 모두 음, 다음의 예는 이러한 예외적 인 경우에 초점을 맞 춥니 다. 이 예에서는 30 비트 수정 번호를 가정합니다.</target>
        </trans-unit>
        <trans-unit id="85514a867e7a20560268b28853e86e5aa494f0b6" translate="yes" xml:space="preserve">
          <source>As a &amp;lsquo;</source>
          <target state="translated">'로</target>
        </trans-unit>
        <trans-unit id="06830ace04b31c9ec49e44f925889f374b949f5a" translate="yes" xml:space="preserve">
          <source>As a final step, before returning the chosen coding system, &lt;code&gt;select-safe-coding-system&lt;/code&gt; checks whether that coding system is consistent with what would be selected if the contents of the region were read from a file. (If not, this could lead to data corruption in a file subsequently re-visited and edited.) Normally, &lt;code&gt;select-safe-coding-system&lt;/code&gt; uses &lt;code&gt;buffer-file-name&lt;/code&gt; as the file for this purpose, but if &lt;var&gt;file&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it uses that file instead (this can be relevant for &lt;code&gt;write-region&lt;/code&gt; and similar functions). If it detects an apparent inconsistency, &lt;code&gt;select-safe-coding-system&lt;/code&gt; queries the user before selecting the coding system.</source>
          <target state="translated">마지막 단계로 선택한 코딩 시스템을 반환하기 전에 &lt;code&gt;select-safe-coding-system&lt;/code&gt; system은 해당 코딩 시스템이 영역의 내용을 파일에서 읽은 경우 선택되는 것과 일치하는지 확인합니다. (그렇지 않으면 나중에 다시 방문하여 편집 한 파일의 데이터가 손상 될 수 있습니다.) 일반적으로 &lt;code&gt;select-safe-coding-system&lt;/code&gt; 은 이러한 목적을 위해 &lt;code&gt;buffer-file-name&lt;/code&gt; 을 파일로 사용 하지만 &lt;var&gt;file&lt;/var&gt; 이 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 , 대신 해당 파일을 사용합니다 ( &lt;code&gt;write-region&lt;/code&gt; 및 유사한 기능과 관련 될 수 있음 ). 명백한 불일치를 감지하면 &lt;code&gt;select-safe-coding-system&lt;/code&gt; 은 코딩 시스템을 선택하기 전에 사용자에게 쿼리합니다.</target>
        </trans-unit>
        <trans-unit id="8347ee4e8693c87255357e7f5883850b386cce75" translate="yes" xml:space="preserve">
          <source>As a general recommendation, try to avoid using &lt;code&gt;looking-back&lt;/code&gt; wherever possible, since it is slow. For this reason, there are no plans to add a &lt;code&gt;looking-back-p&lt;/code&gt; function.</source>
          <target state="translated">일반적인 권장 사항으로 사용하여 피하려고 &lt;code&gt;looking-back&lt;/code&gt; 은 천천히 때문에, 가능한합니다. 이러한 이유로 룩백 &lt;code&gt;looking-back-p&lt;/code&gt; 기능 을 추가 할 계획이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="082ed7d43ef6ed77537415a322f89e49796457df" translate="yes" xml:space="preserve">
          <source>As a historical accident, &lt;var&gt;position&lt;/var&gt; was implemented inconsistently in different functions. In &lt;code&gt;completing-read&lt;/code&gt;, &lt;var&gt;position&lt;/var&gt;&amp;rsquo;s value is interpreted as origin-zero; that is, a value of 0 means the beginning of the string, 1 means after the first character, etc. In &lt;code&gt;read-minibuffer&lt;/code&gt;, and the other non-completion minibuffer input functions that support this argument, 1 means the beginning of the string, 2 means after the first character, etc.</source>
          <target state="translated">역사적 사고로서 &lt;var&gt;position&lt;/var&gt; 는 다른 기능에서 일관되지 않게 구현되었습니다. 에서 &lt;code&gt;completing-read&lt;/code&gt; , &lt;var&gt;position&lt;/var&gt; 의 값은 원점 0으로 해석됩니다; 즉, 값 0은 문자열의 시작을 의미하고 1은 첫 번째 문자 뒤를 의미합니다. &lt;code&gt;read-minibuffer&lt;/code&gt; 에서이 인수를 지원하는 다른 완료되지 않은 미니 버퍼 입력 함수에서 1은 문자열의 시작을 의미합니다. 2는 첫 번째 문자 뒤를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="4294650896b83fd9e5d4be93d12e4c592d4f0ccc" translate="yes" xml:space="preserve">
          <source>As a practical matter, if you are writing text for other people to read, you should set &lt;code&gt;fill-column&lt;/code&gt; to no more than 70. Otherwise the line will be too long for people to read comfortably, and this can make the text seem clumsy.</source>
          <target state="translated">실제적으로 다른 사람이 읽을 수 있도록 텍스트를 작성하는 경우 &lt;code&gt;fill-column&lt;/code&gt; 을 70 개 이하로 설정해야합니다. 그렇지 않으면 줄이 너무 길어 사람들이 편안하게 읽을 수 있으며 이로 인해 텍스트가 서투르게 보일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb4aaf8789bdd2420621e991adcf2190aa28b7df" translate="yes" xml:space="preserve">
          <source>As a result, it is currently not possible to represent the character</source>
          <target state="translated">결과적으로 현재는 캐릭터를 표현할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b5eb1265a3a71f4ed8bb8ff9aa6033bf57cae934" translate="yes" xml:space="preserve">
          <source>As a rule, the inner frame is subdivided into the frame&amp;rsquo;s root window (see &lt;a href=&quot;windows-and-frames#Windows-and-Frames&quot;&gt;Windows and Frames&lt;/a&gt;) and the frame&amp;rsquo;s minibuffer window (see &lt;a href=&quot;minibuffer-windows#Minibuffer-Windows&quot;&gt;Minibuffer Windows&lt;/a&gt;). There are two notable exceptions to this rule: A &lt;em&gt;minibuffer-less frame&lt;/em&gt; contains a root window only and does not contain a minibuffer window. A &lt;em&gt;minibuffer-only frame&lt;/em&gt; contains only a minibuffer window which also serves as that frame&amp;rsquo;s root window. See &lt;a href=&quot;initial-parameters#Initial-Parameters&quot;&gt;Initial Parameters&lt;/a&gt; for how to create such frame configurations.</source>
          <target state="translated">일반적으로 내부 프레임은 프레임의 루트 창 ( &lt;a href=&quot;windows-and-frames#Windows-and-Frames&quot;&gt;Windows 및 프레임&lt;/a&gt; 참조 )과 프레임의 &lt;a href=&quot;minibuffer-windows#Minibuffer-Windows&quot;&gt;미니 버퍼&lt;/a&gt; 창 ( 미니 버퍼 창 참조)으로 세분 됩니다. 이 규칙에는 두 가지 주목할만한 예외가 &lt;em&gt;있습니다. 미니 버퍼없는 프레임&lt;/em&gt; 에는 루트 창만 포함되고 미니 버퍼 창은 포함되지 않습니다. &lt;em&gt;미니 버퍼 전용 프레임은&lt;/em&gt; 또한 프레임의 루트 창 역할 만 미니 버퍼 창을 포함합니다. 이러한 프레임 구성을 만드는 방법 은 &lt;a href=&quot;initial-parameters#Initial-Parameters&quot;&gt;초기 매개 변수&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7658703b932157d4e051dbdce1277e8475ac36f2" translate="yes" xml:space="preserve">
          <source>As a side effect, backups are necessarily made by copying. See &lt;a href=&quot;rename-or-copy#Rename-or-Copy&quot;&gt;Rename or Copy&lt;/a&gt;. Yet, at the same time, saving a precious file always breaks all hard links between the file you save and other file names.</source>
          <target state="translated">부작용으로 백업은 반드시 복사를 통해 이루어집니다. &lt;a href=&quot;rename-or-copy#Rename-or-Copy&quot;&gt;이름 바꾸기 또는 복사를&lt;/a&gt; 참조하십시오 . 그러나 동시에 소중한 파일을 저장하면 저장 한 파일과 다른 파일 이름 사이의 모든 하드 링크가 항상 끊어집니다.</target>
        </trans-unit>
        <trans-unit id="c897a9ef1100434cc7715e3fbb47fdb7454824de" translate="yes" xml:space="preserve">
          <source>As a simple example, we can concatenate the regular expressions &amp;lsquo;</source>
          <target state="translated">간단한 예로서 정규 표현식 '</target>
        </trans-unit>
        <trans-unit id="bc0e4551b2a377b6cea04f402200bc2b67248275" translate="yes" xml:space="preserve">
          <source>As a special case, &lt;code&gt;next&lt;/code&gt; of a frame&amp;rsquo;s root window points to the frame&amp;rsquo;s minibuffer window, provided this is not a minibuffer-only or minibuffer-less frame. On such frames &lt;code&gt;prev&lt;/code&gt; of the minibuffer window points to that frame&amp;rsquo;s root window. In any other case, the root window&amp;rsquo;s &lt;code&gt;next&lt;/code&gt; and the minibuffer window&amp;rsquo;s (if present) &lt;code&gt;prev&lt;/code&gt; fields are &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">특별한 경우로, &lt;code&gt;next&lt;/code&gt; 프레임의 루트 창은 미니 버퍼 전용 또는 미니 버퍼없는 프레임이 아닌 경우 프레임의 미니 버퍼 창을 가리 킵니다. 이러한 프레임 에서 미니 버퍼 창의 &lt;code&gt;prev&lt;/code&gt; 은 해당 프레임의 루트 창을 가리 킵니다. 다른 경우에는 루트 창의 &lt;code&gt;next&lt;/code&gt; 창과 미니 버퍼 창 (있는 경우)의 &lt;code&gt;prev&lt;/code&gt; 필드는 &lt;code&gt;nil&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="640b1e7193c0828a7e9c0e26231c2f3a2ad3a5f4" translate="yes" xml:space="preserve">
          <source>As a special case, a function may return with a different buffer current. Emacs takes this to mean that the current buffer contains altered text to be output. It therefore changes the &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt; arguments of the &lt;code&gt;write-region&lt;/code&gt; call, giving them the values of &lt;code&gt;point-min&lt;/code&gt; and &lt;code&gt;point-max&lt;/code&gt; in the new buffer, respectively. It also discards all previous annotations, because they should have been dealt with by this function.</source>
          <target state="translated">특별한 경우로 함수는 다른 버퍼 전류로 반환 될 수 있습니다. Emacs는 이것을 현재 버퍼에 출력 될 변경된 텍스트가 포함되어 있음을 의미합니다. 따라서 &lt;code&gt;write-region&lt;/code&gt; 호출 의 &lt;var&gt;start&lt;/var&gt; 및 &lt;var&gt;end&lt;/var&gt; 인수를 변경하여 각각 새 버퍼 의 &lt;code&gt;point-min&lt;/code&gt; 및 &lt;code&gt;point-max&lt;/code&gt; 값을 제공합니다 . 또한이 함수에서 처리해야했기 때문에 이전 주석을 모두 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="538f59aab9497ba8d48e55c2e55b2635fbda077a" translate="yes" xml:space="preserve">
          <source>As a special case, if &lt;var&gt;cons-cell&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, this function returns &lt;code&gt;nil&lt;/code&gt;. Therefore, any list is a valid argument. An error is signaled if the argument is not a cons cell or &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">특별한 경우로 &lt;var&gt;cons-cell&lt;/var&gt; 이 &lt;code&gt;nil&lt;/code&gt; 이면이 함수는 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 . 따라서 모든 목록은 유효한 인수입니다. 인수가 cons 셀 또는 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 오류가 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="9e59f0605f808bdde6a150c85073aac9e660ad27" translate="yes" xml:space="preserve">
          <source>As a special case, if &lt;var&gt;cons-cell&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, this function returns &lt;code&gt;nil&lt;/code&gt;; therefore, any list is a valid argument. An error is signaled if the argument is not a cons cell or &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">특별한 경우로 &lt;var&gt;cons-cell&lt;/var&gt; 이 &lt;code&gt;nil&lt;/code&gt; 이면이 함수는 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 . 따라서 모든 목록은 유효한 인수입니다. 인수가 cons 셀 또는 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 오류가 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="ca7cece4ddf32f2b45c2031fd9e867d6b7889049" translate="yes" xml:space="preserve">
          <source>As a special case, if &lt;var&gt;flag&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;, &lt;var&gt;window&lt;/var&gt; becomes &lt;em&gt;strongly&lt;/em&gt; dedicated to its buffer. &lt;code&gt;set-window-buffer&lt;/code&gt; signals an error when the window it acts upon is strongly dedicated to its buffer and does not already display the buffer it is asked to display. Other functions do not treat &lt;code&gt;t&lt;/code&gt; differently from any non-&lt;code&gt;nil&lt;/code&gt; value.</source>
          <target state="translated">경우 특별한 경우로, &lt;var&gt;flag&lt;/var&gt; 입니다 &lt;code&gt;t&lt;/code&gt; 을 , &lt;var&gt;window&lt;/var&gt; 된다 &lt;em&gt;강하게&lt;/em&gt; 버퍼에 전념. &lt;code&gt;set-window-buffer&lt;/code&gt; 는 작동하는 창이 버퍼 전용이고 표시하도록 요청 된 버퍼를 아직 표시하지 않은 경우 오류 신호를 보냅니다. 다른 함수는 &lt;code&gt;t&lt;/code&gt; 를 &lt;code&gt;nil&lt;/code&gt; 이 아닌 값 과 다르게 처리하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4aced0063585f5b279a49199acec884cc3288ce9" translate="yes" xml:space="preserve">
          <source>As a special exception, the error symbol &lt;code&gt;quit&lt;/code&gt; does not have the condition &lt;code&gt;error&lt;/code&gt;, because quitting is not considered an error.</source>
          <target state="translated">특별한 예외로, 종료는 오류로 간주 되지 않으므로 오류 기호 &lt;code&gt;quit&lt;/code&gt; 에는 &lt;code&gt;error&lt;/code&gt; 조건 이 없습니다.</target>
        </trans-unit>
        <trans-unit id="07d6ca82a5135dea4c0b8a8393dd8ef483c67bf7" translate="yes" xml:space="preserve">
          <source>As a technical detail, when &lt;var&gt;switches&lt;/var&gt; contains the long &amp;lsquo;</source>
          <target state="translated">기술적 인 세부 사항으로 &lt;var&gt;switches&lt;/var&gt; 에 긴 '</target>
        </trans-unit>
        <trans-unit id="8f4f9b3b2bfdbcd1a575981570d572a49858acde" translate="yes" xml:space="preserve">
          <source>As a trivial example, here&amp;rsquo;s how to add advice that&amp;rsquo;ll modify the return value of a function every time it&amp;rsquo;s called:</source>
          <target state="translated">간단한 예로, 호출 될 때마다 함수의 반환 값을 수정하는 조언을 추가하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b1f3d0120b8c51d503e5e5327b8ce35d598fd0fd" translate="yes" xml:space="preserve">
          <source>As always, there must be no possibility of intervening searches between the call to a search function and the call to &lt;code&gt;match-data&lt;/code&gt; that is intended to access the match data for that search.</source>
          <target state="translated">항상 그렇듯이, 검색 함수에 대한 호출 &lt;code&gt;match-data&lt;/code&gt; 해당 검색에 대한 일치 데이터에 액세스하려는 일치 데이터에 대한 호출 사이에 검색이 개입 될 가능성이 없어야합니다 .</target>
        </trans-unit>
        <trans-unit id="1472e06e8a8fc0331e8821e03360d8c11b163707" translate="yes" xml:space="preserve">
          <source>As an alternative to the string-based syntax, Emacs provides the structured &lt;code&gt;rx&lt;/code&gt; notation based on Lisp S-expressions. This notation is usually easier to read, write and maintain than regexp strings, and can be indented and commented freely. It requires a conversion into string form since that is what regexp functions expect, but that conversion typically takes place during byte-compilation rather than when the Lisp code using the regexp is run.</source>
          <target state="translated">문자열 기반 구문의 대안으로 Emacs는 Lisp S- 표현식을 기반으로 구조화 된 &lt;code&gt;rx&lt;/code&gt; 표기법을 제공합니다 . 이 표기법은 일반적으로 regexp 문자열보다 읽기, 쓰기 및 유지 관리가 더 쉽고 자유롭게 들여 쓰고 주석을 달 수 있습니다. 정규 표현식 함수가 기대하는 것이기 때문에 문자열 형식으로의 변환이 필요하지만 일반적으로 정규 표현식을 사용하는 Lisp 코드가 실행될 때가 아니라 바이트 컴파일 중에 해당 변환이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="95b6d5f91746264f4dd9c82e53bfbbe800efcb96" translate="yes" xml:space="preserve">
          <source>As an example of &lt;code&gt;sort-subr&lt;/code&gt;, here is the complete function definition for &lt;code&gt;sort-lines&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;sort-subr&lt;/code&gt; 의 예로서 다음은 &lt;code&gt;sort-lines&lt;/code&gt; 대한 완전한 함수 정의입니다 .</target>
        </trans-unit>
        <trans-unit id="39d7c3afd50025e1aeeb3300312260fc1e12eaba" translate="yes" xml:space="preserve">
          <source>As an example, here is a sequence of &lt;code&gt;split-window&lt;/code&gt; calls that yields the window configuration discussed in &lt;a href=&quot;windows-and-frames#Windows-and-Frames&quot;&gt;Windows and Frames&lt;/a&gt;. This example demonstrates splitting a live window as well as splitting an internal window. We begin with a frame containing a single window (a live root window), which we denote by &lt;var&gt;W4&lt;/var&gt;. Calling &lt;code&gt;(split-window W4)&lt;/code&gt; yields this window configuration:</source>
          <target state="translated">예를 들어, 다음은 &lt;a href=&quot;windows-and-frames#Windows-and-Frames&quot;&gt;Windows 및 Frames&lt;/a&gt; 에서 논의 된 창 구성을 생성하는 &lt;code&gt;split-window&lt;/code&gt; 호출 시퀀스입니다 . 이 예제는 라이브 창 분할과 내부 창 분할을 보여줍니다. 단일 창 (라이브 루트 창)을 포함하는 프레임으로 시작합니다 . &lt;var&gt;W4&lt;/var&gt; 로 표시됩니다 . &lt;code&gt;(split-window W4)&lt;/code&gt; 를 호출 하면 다음 창 구성이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="3000460ba524b76305a7ac5b84a2be2cc384cf2b" translate="yes" xml:space="preserve">
          <source>As an example, here&amp;rsquo;s a simplified (and inefficient) version of the primitive function &lt;code&gt;next-single-char-property-change&lt;/code&gt; (see &lt;a href=&quot;property-search#Property-Search&quot;&gt;Property Search&lt;/a&gt;). It searches forward from position &lt;var&gt;pos&lt;/var&gt; for the next position where the value of a given property &lt;code&gt;prop&lt;/code&gt;, as obtained from either overlays or text properties, changes.</source>
          <target state="translated">예를 들어, &lt;code&gt;next-single-char-property-change&lt;/code&gt; 은 기본 함수 next-single-char-property-change 의 단순화 된 (비효율적 인) 버전입니다 ( &lt;a href=&quot;property-search#Property-Search&quot;&gt;Property Search&lt;/a&gt; 참조 ). 오버레이 또는 텍스트 속성에서 얻은 것처럼 주어진 속성 &lt;code&gt;prop&lt;/code&gt; 의 값이 변경되는 다음 위치를 &lt;var&gt;pos&lt;/var&gt; 위치에서 앞으로 검색합니다 .</target>
        </trans-unit>
        <trans-unit id="ac2005a3b3b773dfac881bf44c6dc9ffab49bfce" translate="yes" xml:space="preserve">
          <source>As an exception to the rule that a symbol&amp;rsquo;s name serves as its printed representation, &amp;lsquo;</source>
          <target state="translated">기호의 이름이 인쇄 된 표현으로 사용된다는 규칙에 대한 예외로 '</target>
        </trans-unit>
        <trans-unit id="2daa82fa454d2ab6dd7bfac54a9eefb51ae6ff85" translate="yes" xml:space="preserve">
          <source>As an exception, if you evaluate a &lt;code&gt;defface&lt;/code&gt; form with</source>
          <target state="translated">예외적으로 다음과 같이 &lt;code&gt;defface&lt;/code&gt; 양식 을 평가하는 경우</target>
        </trans-unit>
        <trans-unit id="1a2d268c77084e31235d0ca81e4bd6ebfe990b03" translate="yes" xml:space="preserve">
          <source>As an exception, this function reads a file name using a graphical file dialog instead of the minibuffer, if all of the following are true:</source>
          <target state="translated">예외적으로이 함수는 다음 사항이 모두 참인 경우 미니 버퍼 대신 그래픽 파일 대화 상자를 사용하여 파일 이름을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="7f170945bb4b449cfc683c1ed37876c06db96463" translate="yes" xml:space="preserve">
          <source>As an obsolescent calling convention, this function can be given six or more arguments. The first six arguments &lt;var&gt;second&lt;/var&gt;, &lt;var&gt;minute&lt;/var&gt;, &lt;var&gt;hour&lt;/var&gt;, &lt;var&gt;day&lt;/var&gt;, &lt;var&gt;month&lt;/var&gt;, and &lt;var&gt;year&lt;/var&gt; specify most of the components of a decoded time. If there are more than six arguments the &lt;em&gt;last&lt;/em&gt; argument is used as &lt;var&gt;zone&lt;/var&gt; and any other extra arguments are ignored, so that &lt;code&gt;(apply
#'encode-time (decode-time ...))&lt;/code&gt; works. In this obsolescent convention, &lt;var&gt;zone&lt;/var&gt; defaults to the current time zone rule (see &lt;a href=&quot;time-zone-rules#Time-Zone-Rules&quot;&gt;Time Zone Rules&lt;/a&gt;), and &lt;var&gt;dst&lt;/var&gt; is treated as if it was -1.</source>
          <target state="translated">오래된 호출 규칙으로이 함수에는 6 개 이상의 인수가 제공 될 수 있습니다. 처음 6 개의 인수 인 &lt;var&gt;second&lt;/var&gt; , &lt;var&gt;minute&lt;/var&gt; , &lt;var&gt;hour&lt;/var&gt; , &lt;var&gt;day&lt;/var&gt; , &lt;var&gt;month&lt;/var&gt; , &lt;var&gt;year&lt;/var&gt; 는 디코딩 된 시간의 대부분의 구성 요소를 지정합니다. 6 개 이상의 인수가있는 경우 &lt;em&gt;마지막&lt;/em&gt; 인수는 &lt;var&gt;zone&lt;/var&gt; 으로 사용되고 다른 추가 인수는 무시되므로 &lt;code&gt;(apply #'encode-time (decode-time ...))&lt;/code&gt; 작동합니다. 이 오래된 규칙에서 &lt;var&gt;zone&lt;/var&gt; 은 기본적으로 현재 표준 시간대 규칙 ( &lt;a href=&quot;time-zone-rules#Time-Zone-Rules&quot;&gt;표준 시간대 규칙&lt;/a&gt; 참조 )으로 설정되고 &lt;var&gt;dst&lt;/var&gt; 는 -1 인 것처럼 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="2491282a6d1f8281ac0fcd08cc3d8281fc7d632e" translate="yes" xml:space="preserve">
          <source>As editing continues, undo lists get longer and longer. To prevent them from using up all available memory space, garbage collection trims them back to size limits you can set. (For this purpose, the size of an undo list measures the cons cells that make up the list, plus the strings of deleted text.) Three variables control the range of acceptable sizes: &lt;code&gt;undo-limit&lt;/code&gt;, &lt;code&gt;undo-strong-limit&lt;/code&gt; and &lt;code&gt;undo-outer-limit&lt;/code&gt;. In these variables, size is counted as the number of bytes occupied, which includes both saved text and other data.</source>
          <target state="translated">편집이 계속되면 실행 취소 목록이 점점 길어집니다. 사용 가능한 모든 메모리 공간을 사용하는 것을 방지하기 위해 가비지 컬렉션은 사용자가 설정할 수있는 크기 제한으로 다시 트리밍합니다. (이를 위해 실행 취소 목록의 크기는 목록을 구성하는 단점 셀과 삭제 된 텍스트 문자열을 측정합니다.) 세 가지 변수는 허용 가능한 크기 범위를 제어합니다. &lt;code&gt;undo-limit&lt;/code&gt; , &lt;code&gt;undo-strong-limit&lt;/code&gt; 및 &lt;code&gt;undo-outer-limit&lt;/code&gt; . 이러한 변수에서 크기는 저장된 텍스트와 기타 데이터를 모두 포함하는 점유 바이트 수로 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="39fc3a710f302293efc2b0bded9197ae640e963b" translate="yes" xml:space="preserve">
          <source>As explained in &lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;Variable Scoping&lt;/a&gt;, Emacs can optionally enable lexical binding of variables. When lexical binding is enabled, any named function that you create (e.g., with &lt;code&gt;defun&lt;/code&gt;), as well as any anonymous function that you create using the &lt;code&gt;lambda&lt;/code&gt; macro or the &lt;code&gt;function&lt;/code&gt; special form or the &lt;code&gt;#'&lt;/code&gt; syntax (see &lt;a href=&quot;anonymous-functions#Anonymous-Functions&quot;&gt;Anonymous Functions&lt;/a&gt;), is automatically converted into a &lt;em&gt;closure&lt;/em&gt;.</source>
          <target state="translated">&lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;Variable Scoping&lt;/a&gt; 에서 설명했듯이 Emacs는 선택적으로 변수의 어휘 바인딩을 활성화 할 수 있습니다. 어휘 바인딩이 활성화되면 사용자가 만든 명명 된 함수 (예 : &lt;code&gt;defun&lt;/code&gt; 사용)와 &lt;code&gt;lambda&lt;/code&gt; 매크로, &lt;code&gt;function&lt;/code&gt; 특수 형식 또는 &lt;code&gt;#'&lt;/code&gt; 구문 을 사용하여 만든 &lt;a href=&quot;anonymous-functions#Anonymous-Functions&quot;&gt;익명 함수&lt;/a&gt; ( 익명 함수 참조 )가 자동으로 사용됩니다. &lt;em&gt;클로저&lt;/em&gt; 로 변환 .</target>
        </trans-unit>
        <trans-unit id="72d71c3cc374384e0af0a0724fbb040625e0c496" translate="yes" xml:space="preserve">
          <source>As far as &lt;code&gt;define-key&lt;/code&gt; is concerned, &lt;var&gt;item-string&lt;/var&gt; and &lt;var&gt;help-string&lt;/var&gt; are part of the event&amp;rsquo;s binding. However, &lt;code&gt;lookup-key&lt;/code&gt; returns just &lt;var&gt;real-binding&lt;/var&gt;, and only &lt;var&gt;real-binding&lt;/var&gt; is used for executing the key.</source>
          <target state="translated">까지로 &lt;code&gt;define-key&lt;/code&gt; 우려하고, &lt;var&gt;item-string&lt;/var&gt; 과 &lt;var&gt;help-string&lt;/var&gt; 이벤트의 바인딩의 일부입니다. 그러나 &lt;code&gt;lookup-key&lt;/code&gt; 는 &lt;var&gt;real-binding&lt;/var&gt; 만 반환 하고 키 실행에는 &lt;var&gt;real-binding&lt;/var&gt; 만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="04371b35f248ca488e9627aecf5dda4a949a350a" translate="yes" xml:space="preserve">
          <source>As far as possible, new major modes should be derived, either directly or indirectly, from one of these three modes. One reason is that this allows users to customize a single mode hook (e.g., &lt;code&gt;prog-mode-hook&lt;/code&gt;) for an entire family of relevant modes (e.g., all programming language modes).</source>
          <target state="translated">가능한 한 새로운 주요 모드는이 세 가지 모드 중 하나에서 직접 또는 간접적으로 파생되어야합니다. 한 가지 이유는 사용자가 관련 모드의 전체 제품군 (예 : 모든 프로그래밍 언어 모드)에 대해 단일 모드 후크 (예 : &lt;code&gt;prog-mode-hook&lt;/code&gt; ) 를 사용자 지정할 수 있기 때문입니다 .</target>
        </trans-unit>
        <trans-unit id="ff3ef6be607829903e8a6baac8628d90d56c089f" translate="yes" xml:space="preserve">
          <source>As far as the Lisp reader is concerned, &amp;lsquo;</source>
          <target state="translated">Lisp 독자에 관한 한 '</target>
        </trans-unit>
        <trans-unit id="c87e482a1ccf8205de796dac23a5ade838dbdd25" translate="yes" xml:space="preserve">
          <source>As for &lt;code&gt;nil&lt;/code&gt;, but if</source>
          <target state="translated">에 관해서는 &lt;code&gt;nil&lt;/code&gt; 하지만, 경우</target>
        </trans-unit>
        <trans-unit id="e20b47eb8e540da13af46101ac4dc2b6a5827bfb" translate="yes" xml:space="preserve">
          <source>As for &lt;code&gt;x-popup-menu&lt;/code&gt;, an element of the list may be just a string instead of a cons cell &lt;code&gt;(&lt;var&gt;string&lt;/var&gt; . &lt;var&gt;value&lt;/var&gt;)&lt;/code&gt;. That makes a box that cannot be selected.</source>
          <target state="translated">관해서 &lt;code&gt;x-popup-menu&lt;/code&gt; 리스트의 요소는 문자열 대신 반대 셀 수있다 &lt;code&gt;(&lt;var&gt;string&lt;/var&gt; . &lt;var&gt;value&lt;/var&gt;)&lt;/code&gt; . 그것은 선택할 수없는 상자를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="18f02bf364dcfbbb51fe785b93d6502cf175baf7" translate="yes" xml:space="preserve">
          <source>As in the previous example (see &lt;a href=&quot;#pcase_002dexample_002d1&quot;&gt;Example 1&lt;/a&gt;), &lt;code&gt;and&lt;/code&gt; begins with a &lt;code&gt;pred&lt;/code&gt; sub-pattern to ensure the following sub-patterns work with an object of the correct type (string, in this case). If &lt;code&gt;(stringp&amp;nbsp;&lt;var&gt;expval&lt;/var&gt;)&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;pred&lt;/code&gt; fails, and thus &lt;code&gt;and&lt;/code&gt; fails, too.</source>
          <target state="translated">이전 예에서와 같이 (참조 &lt;a href=&quot;#pcase_002dexample_002d1&quot;&gt;예 1&lt;/a&gt; ), &lt;code&gt;and&lt;/code&gt; 로 시작할 &lt;code&gt;pred&lt;/code&gt; (이 경우, 문자열) 올바른 유형의 오브젝트와 다음 서브 패턴 작업을 위해 서브 패턴. 경우 &lt;code&gt;(stringp&amp;nbsp;&lt;var&gt;expval&lt;/var&gt;)&lt;/code&gt; 반환 &lt;code&gt;nil&lt;/code&gt; 을 , &lt;code&gt;pred&lt;/code&gt; 실패하고 이렇게 &lt;code&gt;and&lt;/code&gt; 도 실패합니다.</target>
        </trans-unit>
        <trans-unit id="aca399bc248b6540182b97cdc8a6ceed399a0db7" translate="yes" xml:space="preserve">
          <source>As is the case with &lt;code&gt;format&lt;/code&gt;, a format specification can include a width, which is a decimal number that appears after any flags. If a substitution contains fewer characters than its specified width, it is padded on the left:</source>
          <target state="translated">&lt;code&gt;format&lt;/code&gt; 의 경우와 마찬가지로 형식 사양에는 플래그 뒤에 나타나는 십진수 인 너비가 포함될 수 있습니다. 대체에 지정된 너비보다 적은 문자가 포함 된 경우 왼쪽이 채워집니다.</target>
        </trans-unit>
        <trans-unit id="9007d393cbc677946e3b508fd46f178b4ffc51b8" translate="yes" xml:space="preserve">
          <source>As long as the selected window displays the current buffer, the window&amp;rsquo;s point and the buffer&amp;rsquo;s point always move together; they remain equal.</source>
          <target state="translated">선택한 창에 현재 버퍼가 표시되는 한, 창의 지점과 버퍼의 지점은 항상 함께 이동합니다. 그들은 동등하게 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="a4599968f503223a9b7899912e9301addb3f9878" translate="yes" xml:space="preserve">
          <source>As long as the value of &lt;code&gt;meta-prefix-char&lt;/code&gt; remains 27, key lookup translates</source>
          <target state="translated">&lt;code&gt;meta-prefix-char&lt;/code&gt; 의 값 이 27로 유지되는 한 키 조회는</target>
        </trans-unit>
        <trans-unit id="2403f847930ce8798404ebfea8bddc7017e3a7dd" translate="yes" xml:space="preserve">
          <source>As previously noted in this manual, a Lisp program is represented primarily by Lisp objects, and only secondarily as text. The textual form of a Lisp program is given by the read syntax of the Lisp objects that constitute the program. Hence, the textual form of a variable in a Lisp program is written using the read syntax for the symbol representing the variable.</source>
          <target state="translated">이전에이 설명서에서 언급했듯이 Lisp 프로그램은 주로 Lisp 개체로 표시되고 보조적으로는 텍스트로만 표시됩니다. Lisp 프로그램의 텍스트 형식은 프로그램을 구성하는 Lisp 개체의 읽기 구문에 의해 제공됩니다. 따라서 Lisp 프로그램에서 텍스트 형식의 변수는 변수를 나타내는 기호에 대한 읽기 구문을 사용하여 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="6c8a180c05fd7458e0ef38127404fa2fa9ac26b5" translate="yes" xml:space="preserve">
          <source>As previously noted, Emacs Lisp allows the same symbol to be defined both as a variable (e.g., with &lt;code&gt;defvar&lt;/code&gt;) and as a function or macro (e.g., with &lt;code&gt;defun&lt;/code&gt;). Such definitions do not conflict.</source>
          <target state="translated">앞서 언급했듯이 Emacs Lisp는 동일한 심볼을 변수 (예 : &lt;code&gt;defvar&lt;/code&gt; 사용 )와 함수 또는 매크로 (예 : &lt;code&gt;defun&lt;/code&gt; 사용 )로 정의 할 수 있습니다. 이러한 정의는 충돌하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2a0ddcf1c50ca193923f438a27950fa2767aba7b" translate="yes" xml:space="preserve">
          <source>As the examples in this section illustrate, &lt;code&gt;format-spec&lt;/code&gt; is often used for selectively formatting an assortment of different pieces of information. This is useful in programs that provide user-customizable format strings, as the user can choose to format with a regular syntax and in any desired order only a subset of the information that the program makes available.</source>
          <target state="translated">이 섹션의 예에서 알 수 있듯이 &lt;code&gt;format-spec&lt;/code&gt; 은 다양한 정보의 모음을 선택적으로 형식화하는 데 자주 사용됩니다. 이것은 사용자가 사용자 정의 할 수있는 형식 문자열을 제공하는 프로그램에서 유용합니다. 사용자는 프로그램이 제공하는 정보의 하위 집합 만 일반 구문과 원하는 순서로 형식화하도록 선택할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="fcae404ca40596bab0f46fcb1d1aebb078adf297" translate="yes" xml:space="preserve">
          <source>As the heap size increases, the time to perform a garbage collection increases. Thus, it can be desirable to do them less frequently in proportion.</source>
          <target state="translated">힙 크기가 증가하면 가비지 콜렉션을 수행하는 시간이 늘어납니다. 따라서 비율 적으로 덜 자주 수행하는 것이 바람직 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e3df73939184a50a6120a14310b27d84575c14c" translate="yes" xml:space="preserve">
          <source>As the name implies, this function does not display any messages.</source>
          <target state="translated">이름에서 알 수 있듯이이 기능은 메시지를 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e31d6bc3247e331efa29ece4c6b4b7ecd35823cc" translate="yes" xml:space="preserve">
          <source>As these examples show, you can use a form with a lambda expression as its &lt;small&gt;CAR&lt;/small&gt; to make local variables and give them values. In the old days of Lisp, this technique was the only way to bind and initialize local variables. But nowadays, it is clearer to use the special form &lt;code&gt;let&lt;/code&gt; for this purpose (see &lt;a href=&quot;local-variables#Local-Variables&quot;&gt;Local Variables&lt;/a&gt;). Lambda expressions are mainly used as anonymous functions for passing as arguments to other functions (see &lt;a href=&quot;anonymous-functions#Anonymous-Functions&quot;&gt;Anonymous Functions&lt;/a&gt;), or stored as symbol function definitions to produce named functions (see &lt;a href=&quot;function-names#Function-Names&quot;&gt;Function Names&lt;/a&gt;).</source>
          <target state="translated">이 예제에서 볼 수 있듯이 람다식이있는 양식을 &lt;small&gt;CAR&lt;/small&gt; 로 사용하여 지역 변수를 만들고 값을 제공 할 수 있습니다. Lisp의 예전에는이 기술이 지역 변수를 바인딩하고 초기화하는 유일한 방법이었습니다. 그러나 요즘에는 이 목적을 위해 특수한 형태의 &lt;code&gt;let&lt;/code&gt; 을 사용하는 것이 더 명확합니다 ( &lt;a href=&quot;local-variables#Local-Variables&quot;&gt;Local Variables&lt;/a&gt; 참조 ). Lambda 표현식은 주로 다른 함수에 인수로 전달하기위한 익명 함수로 사용 되거나 ( &lt;a href=&quot;anonymous-functions#Anonymous-Functions&quot;&gt;익명 함수&lt;/a&gt; 참조 ), 명명 된 함수를 생성하기 위해 기호 함수 정의로 저장됩니다 ( &lt;a href=&quot;function-names#Function-Names&quot;&gt;함수 이름&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="37412dfde91c59b85070a1fa6f6188f685c97c7f" translate="yes" xml:space="preserve">
          <source>As you use this manual, we ask that you send corrections as soon as you find them. If you think of a simple, real life example for a function or group of functions, please make an effort to write it up and send it in. Please reference any comments to the node name and function or variable name, as appropriate. Also state the number of the edition you are criticizing.</source>
          <target state="translated">이 설명서를 사용할 때 수정 사항을 찾는 즉시 보내 주시기 바랍니다. 함수 나 함수 그룹에 대한 간단하고 실제적인 예를 생각한다면 그것을 작성하여 보내주십시오. 노드 이름과 함수 또는 변수 이름에 대한 주석을 적절하게 참조하십시오. 또한 당신이 비판하는 에디션의 번호를 적으십시오.</target>
        </trans-unit>
        <trans-unit id="875666f6d9c3564876142613c6760e04a0da95b2" translate="yes" xml:space="preserve">
          <source>Aside from elements that specify bindings for keys, a keymap can also have a string as an element. This is called the &lt;em&gt;overall prompt string&lt;/em&gt; and makes it possible to use the keymap as a menu. See &lt;a href=&quot;defining-menus#Defining-Menus&quot;&gt;Defining Menus&lt;/a&gt;.</source>
          <target state="translated">키에 대한 바인딩을 지정하는 요소 외에도 키맵은 문자열을 요소로 가질 수 있습니다. 이를 &lt;em&gt;전체 프롬프트 문자열&lt;/em&gt; 이라고하며 키맵을 메뉴로 사용할 수 있습니다. &lt;a href=&quot;defining-menus#Defining-Menus&quot;&gt;메뉴 정의를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1d3719187ae715d19fbc05c49ed805a355d60c95" translate="yes" xml:space="preserve">
          <source>Aside from some technical details, the body of the &lt;code&gt;find-file&lt;/code&gt; function is basically equivalent to:</source>
          <target state="translated">몇 가지 기술적 세부 사항을 제외하고 &lt;code&gt;find-file&lt;/code&gt; 기능 의 본문 은 기본적으로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e8854395183315465f485147e2c0e5d0dad0bf04" translate="yes" xml:space="preserve">
          <source>Aside from the four basic conditional forms, Emacs Lisp also has a pattern-matching conditional form, the &lt;code&gt;pcase&lt;/code&gt; macro, a hybrid of &lt;code&gt;cond&lt;/code&gt; and &lt;code&gt;cl-case&lt;/code&gt; (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/cl/Conditionals.html#Conditionals&quot;&gt;Conditionals&lt;/a&gt; in</source>
          <target state="translated">이외에도 네가지 조건 형태에서 이맥스 리스프는 패턴 매칭 조건 형태의 보유 &lt;code&gt;pcase&lt;/code&gt; 의 매크로 하이브리드 &lt;code&gt;cond&lt;/code&gt; 및 &lt;code&gt;cl-case&lt;/code&gt; (참조 &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/cl/Conditionals.html#Conditionals&quot;&gt;조건문&lt;/a&gt; 에</target>
        </trans-unit>
        <trans-unit id="d784be167f97d7b6e1444587a023ff8462f0adde" translate="yes" xml:space="preserve">
          <source>Aside from the mathematical incorrectness of asserting that 9 is a double-digit integer, there is another problem with &lt;code&gt;MAYBE&lt;/code&gt;. The body form references &lt;code&gt;n&lt;/code&gt; once more, yet we do not see the updated value&amp;mdash;10&amp;mdash;at all. What happened to it?</source>
          <target state="translated">9가 두 자리 정수라고 주장하는 수학적 부정확성 외에도 &lt;code&gt;MAYBE&lt;/code&gt; 에 또 다른 문제가 있습니다. 본문 양식은 &lt;code&gt;n&lt;/code&gt; 을 다시 한 번 참조하지만 업데이트 된 값인 10은 전혀 볼 수 없습니다. 무슨 일이 있었나요?</target>
        </trans-unit>
        <trans-unit id="3562777bc6a3edbbbfe49bb7c58769707930308b" translate="yes" xml:space="preserve">
          <source>Ask</source>
          <target state="translated">Ask</target>
        </trans-unit>
        <trans-unit id="5cc8d5b1e25410343b6c6d03e6144240950ba693" translate="yes" xml:space="preserve">
          <source>Ask user a multiple choice question. &lt;var&gt;prompt&lt;/var&gt; should be a string that will be displayed as the prompt.</source>
          <target state="translated">사용자에게 객관식 질문을합니다. &lt;var&gt;prompt&lt;/var&gt; 는 프롬프트 로 표시 될 문자열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="a575156671adcef0e66c96ca9986973728b1a5e6" translate="yes" xml:space="preserve">
          <source>Asking Multiple-Choice Questions</source>
          <target state="translated">객관식 질문하기</target>
        </trans-unit>
        <trans-unit id="f48d4ab0834bb43d119ea91a0df80bf7d9b32ab7" translate="yes" xml:space="preserve">
          <source>Asking a question with a simple answer.</source>
          <target state="translated">간단한 답변으로 질문하기.</target>
        </trans-unit>
        <trans-unit id="fe7e00f4a1fa3a5c1a99ddf9345528ef0e23e5df" translate="yes" xml:space="preserve">
          <source>Asking complex questions.</source>
          <target state="translated">복잡한 질문을합니다.</target>
        </trans-unit>
        <trans-unit id="27b0c683fbfb99510b0eaaaf16a761a3b451a6a0" translate="yes" xml:space="preserve">
          <source>Asking the user to choose a coding system.</source>
          <target state="translated">사용자에게 코딩 시스템을 선택하도록 요청합니다.</target>
        </trans-unit>
        <trans-unit id="e753d0e9020f53ad0de8df59f25fdea5680ef2fc" translate="yes" xml:space="preserve">
          <source>Asking the user to specify a character.</source>
          <target state="translated">사용자에게 문자 지정을 요청합니다.</target>
        </trans-unit>
        <trans-unit id="79f255d18c150763000984a919eb61a8c62cb802" translate="yes" xml:space="preserve">
          <source>Asking where the mouse is, or moving it.</source>
          <target state="translated">마우스가 어디에 있는지 묻거나 이동합니다.</target>
        </trans-unit>
        <trans-unit id="9a8aef5df06c4a0630dba0718222fbda7f2ae98b" translate="yes" xml:space="preserve">
          <source>Assertion failed</source>
          <target state="translated">어설 션 실패</target>
        </trans-unit>
        <trans-unit id="906762c6281b489fa4d8cc099d0c4e13c1902efd" translate="yes" xml:space="preserve">
          <source>Assigning Lisp property lists to text characters.</source>
          <target state="translated">Lisp 속성 목록을 텍스트 문자에 할당합니다.</target>
        </trans-unit>
        <trans-unit id="8f9fb7e8c09158fb874cf09f8dbca8383f6a050c" translate="yes" xml:space="preserve">
          <source>Associate &lt;var&gt;stderr&lt;/var&gt; with the standard error of the process. A non-&lt;code&gt;nil&lt;/code&gt; value should be either a buffer or a pipe process created with &lt;code&gt;make-pipe-process&lt;/code&gt;, described below. If &lt;var&gt;stderr&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, standard error is mixed with standard output, and both are sent to &lt;var&gt;buffer&lt;/var&gt; or &lt;var&gt;filter&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;stderr&lt;/var&gt; 을 프로세스의 표준 오류와 연관 시키십시오. &lt;code&gt;nil&lt;/code&gt; 이 아닌 값은 아래에 설명 된대로 &lt;code&gt;make-pipe-process&lt;/code&gt; 로 생성 된 버퍼 또는 파이프 프로세스 여야 합니다. 경우 &lt;var&gt;stderr&lt;/var&gt; 있다 &lt;code&gt;nil&lt;/code&gt; , 표준 오차는 표준 출력과 혼합하고, 모두가 전송되는 &lt;var&gt;buffer&lt;/var&gt; 또는 &lt;var&gt;filter&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="e3024403263d4d843f0e51777623d2a49c1231db" translate="yes" xml:space="preserve">
          <source>Associating additional information with windows.</source>
          <target state="translated">추가 정보를 창과 연결합니다.</target>
        </trans-unit>
        <trans-unit id="e463ae7c0c475efc422013c7bb62639251e2604f" translate="yes" xml:space="preserve">
          <source>Association List Type</source>
          <target state="translated">협회 목록 유형</target>
        </trans-unit>
        <trans-unit id="c1eecc79e49a6ca7a499806fc8e58814d3aeda58" translate="yes" xml:space="preserve">
          <source>Association Lists</source>
          <target state="translated">협회 목록</target>
        </trans-unit>
        <trans-unit id="a0f646334656079aafb8f68fbbd7ae734d08ae78" translate="yes" xml:space="preserve">
          <source>Association lists (see &lt;a href=&quot;association-lists#Association-Lists&quot;&gt;Association Lists&lt;/a&gt;) are very similar to property lists. In contrast to association lists, the order of the pairs in the property list is not significant, since the property names must be distinct.</source>
          <target state="translated">협회 목록 (참조 &lt;a href=&quot;association-lists#Association-Lists&quot;&gt;협회 목록을&lt;/a&gt; ) 속성 목록과 매우 유사하다. 연관 목록과는 달리, 속성 이름이 구별되어야하므로 속성 목록의 쌍 순서는 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="14ba3cbc75793dbade1b890546d72c62627ca897" translate="yes" xml:space="preserve">
          <source>Association lists are often used to record information that you might otherwise keep on a stack, since new associations may be added easily to the front of the list. When searching an association list for an association with a given key, the first one found is returned, if there is more than one.</source>
          <target state="translated">연관 목록은 새 연관이 목록의 맨 앞에 쉽게 추가 될 수 있으므로 스택에 보관할 수있는 정보를 기록하는 데 자주 사용됩니다. 연관 목록에서 주어진 키와의 연관을 검색 할 때 발견 된 첫 번째 것이 리턴됩니다 (둘 이상인 경우).</target>
        </trans-unit>
        <trans-unit id="c3f9b4c0afa65ab472f88a447b5b643be2caa8ed" translate="yes" xml:space="preserve">
          <source>Asynchronous subprocesses receive input when it is sent to them by Emacs, which is done with the functions in this section. You must specify the process to send input to, and the input data to send. If the subprocess runs a program, the data appears on the standard input of that program; for connections, the data is sent to the connected device or program.</source>
          <target state="translated">비동기 서브 프로세스는이 섹션의 함수로 수행되는 Emacs에 의해 전송 될 때 입력을받습니다. 입력을 보낼 프로세스와 보낼 입력 데이터를 지정해야합니다. 하위 프로세스가 프로그램을 실행하는 경우 데이터는 해당 프로그램의 표준 입력에 나타납니다. 연결의 경우 데이터는 연결된 장치 또는 프로그램으로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="a5bb8623a169e7bd4940e5f36d437427d3e09d1b" translate="yes" xml:space="preserve">
          <source>At any time, one frame in Emacs is the &lt;em&gt;selected frame&lt;/em&gt;. The selected window always resides on the selected frame.</source>
          <target state="translated">언제든지 Emacs의 한 프레임이 &lt;em&gt;선택된 프레임&lt;/em&gt; 입니다. 선택한 창은 항상 선택한 프레임에 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c816364377c69602fd91de24b490b44a6fcd129" translate="yes" xml:space="preserve">
          <source>At any time, several primary keymaps are &lt;em&gt;active&lt;/em&gt;&amp;mdash;that is, in use for finding key bindings. These are the &lt;em&gt;global map&lt;/em&gt;, which is shared by all buffers; the &lt;em&gt;local keymap&lt;/em&gt;, which is usually associated with a specific major mode; and zero or more &lt;em&gt;minor mode keymaps&lt;/em&gt;, which belong to currently enabled minor modes. (Not all minor modes have keymaps.) The local keymap bindings shadow (i.e., take precedence over) the corresponding global bindings. The minor mode keymaps shadow both local and global keymaps. See &lt;a href=&quot;active-keymaps#Active-Keymaps&quot;&gt;Active Keymaps&lt;/a&gt;, for details.</source>
          <target state="translated">언제든지 여러 기본 키맵이 &lt;em&gt;활성화&lt;/em&gt; 되어 키 바인딩을 찾는 데 사용됩니다. 이들은 모든 버퍼가 공유 하는 &lt;em&gt;글로벌 맵입니다&lt;/em&gt; . &lt;em&gt;지역 키맵&lt;/em&gt; 일반적으로 특정 주요 모드와 관련된; 및 현재 활성화 된 부 모드에 속하는 0 개 이상의 &lt;em&gt;부 모드 키맵&lt;/em&gt; . (모든 마이너 모드에 키맵이있는 것은 아닙니다.) 로컬 키맵 바인딩은 해당 글로벌 바인딩을 그림자 (즉, 우선권을 갖습니다)합니다. 부 모드 키맵은 로컬 및 글로벌 키맵을 모두 섀도 잉합니다. 자세한 내용은 &lt;a href=&quot;active-keymaps#Active-Keymaps&quot;&gt;활성 키맵&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8d93bb5f9a38a88b4da1e36b6fa1f9cb4bfd6596" translate="yes" xml:space="preserve">
          <source>At each stage, if a face has a valid &lt;code&gt;:inherit&lt;/code&gt; attribute, Emacs treats any attribute with an &lt;code&gt;unspecified&lt;/code&gt; value as having the corresponding value drawn from the parent face(s). see &lt;a href=&quot;face-attributes#Face-Attributes&quot;&gt;Face Attributes&lt;/a&gt;. Note that the parent face(s) may also leave the attribute unspecified; in that case, the attribute remains unspecified at the next level of face merging.</source>
          <target state="translated">각 단계에서 얼굴에 유효한 &lt;code&gt;:inherit&lt;/code&gt; 속성이있는 경우 Emacs는 &lt;code&gt;unspecified&lt;/code&gt; 값을 가진 모든 속성을 부모 얼굴에서 가져온 해당 값을 갖는 것으로 처리합니다. &lt;a href=&quot;face-attributes#Face-Attributes&quot;&gt;면 속성을&lt;/a&gt; 참조하십시오 . 부모 얼굴은 속성을 지정하지 않은 채로 둘 수도 있습니다. 이 경우 속성은 다음 단계의 얼굴 병합에서 지정되지 않은 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="621cbe593d12331614294e33d27df98bfb14d296" translate="yes" xml:space="preserve">
          <source>At some point in the future the base C dialect will no doubt change to C11.</source>
          <target state="translated">미래의 어느 시점에서 기본 C 방언은 의심 할 여지없이 C11로 변경 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="2d46551267fccda2366ce110501bc5c0ac875511" translate="yes" xml:space="preserve">
          <source>At the beginning or end of a line, the appropriate amount of space is none. Before a character with close parenthesis syntax, or after a character with open parenthesis or expression-prefix syntax, no space is also appropriate. Otherwise, one space is appropriate. See &lt;a href=&quot;syntax-class-table#Syntax-Class-Table&quot;&gt;Syntax Class Table&lt;/a&gt;.</source>
          <target state="translated">줄의 시작 또는 끝에서 적절한 공간은 없음입니다. 닫는 괄호 구문이있는 문자 앞이나 여는 괄호 또는 표현식 접두어 구문이있는 문자 뒤에 공백도 적합하지 않습니다. 그렇지 않으면 하나의 공백이 적절합니다. &lt;a href=&quot;syntax-class-table#Syntax-Class-Table&quot;&gt;구문 클래스 테이블을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="007e79f90925179d568d16a8deaddb8c8e8caa2f" translate="yes" xml:space="preserve">
          <source>At the center of the window is the &lt;em&gt;text area&lt;/em&gt;, or &lt;em&gt;body&lt;/em&gt;, where the buffer text is displayed. The text area can be surrounded by a series of optional areas. On the left and right, from innermost to outermost, these are the left and right fringes, denoted by LF and RF (see &lt;a href=&quot;fringes#Fringes&quot;&gt;Fringes&lt;/a&gt;); the left and right margins, denoted by LM and RM in the schematic (see &lt;a href=&quot;display-margins#Display-Margins&quot;&gt;Display Margins&lt;/a&gt;); the left or right vertical scroll bar, only one of which is present at any time, denoted by LS and RS (see &lt;a href=&quot;scroll-bars#Scroll-Bars&quot;&gt;Scroll Bars&lt;/a&gt;); and the right divider, denoted by RD (see &lt;a href=&quot;window-dividers#Window-Dividers&quot;&gt;Window Dividers&lt;/a&gt;). At the top of the window is the header line (see &lt;a href=&quot;header-lines#Header-Lines&quot;&gt;Header Lines&lt;/a&gt;). At the bottom of the window are the horizontal scroll bar (see &lt;a href=&quot;scroll-bars#Scroll-Bars&quot;&gt;Scroll Bars&lt;/a&gt;); the mode line (see &lt;a href=&quot;mode-line-format#Mode-Line-Format&quot;&gt;Mode Line Format&lt;/a&gt;); and the bottom divider (see &lt;a href=&quot;window-dividers#Window-Dividers&quot;&gt;Window Dividers&lt;/a&gt;).</source>
          <target state="translated">창 중앙 에는 버퍼 텍스트가 표시되는 &lt;em&gt;텍스트 영역&lt;/em&gt; 또는 &lt;em&gt;본문&lt;/em&gt; 이 있습니다. 텍스트 영역은 일련의 선택적 영역으로 둘러싸 일 수 있습니다. 왼쪽과 오른쪽에서 최 내측에, 이는 LF 및 RF (참조 붙이고 좌우 줄무늬가있는 &lt;a href=&quot;fringes#Fringes&quot;&gt;프린지&lt;/a&gt; ); 회로도에서 LM 및 RM으로 표시된 왼쪽 및 오른쪽 여백 ( &lt;a href=&quot;display-margins#Display-Margins&quot;&gt;여백 표시&lt;/a&gt; 참조 ) 왼쪽 또는 오른쪽 수직 스크롤 막대. LS 및 RS로 표시되는 언제든지 하나만 표시됩니다 ( &lt;a href=&quot;scroll-bars#Scroll-Bars&quot;&gt;스크롤 막대&lt;/a&gt; 참조 ). RD로 표시되는 오른쪽 구분선 ( &lt;a href=&quot;window-dividers#Window-Dividers&quot;&gt;창 구분선&lt;/a&gt; 참조 ). 창 상단에는 헤더 라인이 있습니다 ( &lt;a href=&quot;header-lines#Header-Lines&quot;&gt;헤더 라인&lt;/a&gt; 참조).). 창 하단 (참조 수평 스크롤 바있는 &lt;a href=&quot;scroll-bars#Scroll-Bars&quot;&gt;스크롤 바를&lt;/a&gt; ); 모드 라인 ( &lt;a href=&quot;mode-line-format#Mode-Line-Format&quot;&gt;모드 라인 형식&lt;/a&gt; 참조 ) 하단 구분선 ( &lt;a href=&quot;window-dividers#Window-Dividers&quot;&gt;창 구분선&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="fce2ab087a5fd08a2230eb11f4e344519f5c8db6" translate="yes" xml:space="preserve">
          <source>At the level of C code, quitting cannot happen just anywhere; only at the special places that check &lt;code&gt;quit-flag&lt;/code&gt;. The reason for this is that quitting at other places might leave an inconsistency in Emacs&amp;rsquo;s internal state. Because quitting is delayed until a safe place, quitting cannot make Emacs crash.</source>
          <target state="translated">C 코드 수준에서 종료는 어디에서나 일어날 수 없습니다. &lt;code&gt;quit-flag&lt;/code&gt; 를 확인하는 특별한 장소에서만 . 그 이유는 다른 곳에서 그만두면 Emacs의 내부 상태에 불일치를 남길 수 있기 때문입니다. 종료는 안전한 장소까지 지연되기 때문에 종료하면 Emacs가 충돌 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d255c59db332c87b9a24623a21d91ebeac724f41" translate="yes" xml:space="preserve">
          <source>At this moment typing</source>
          <target state="translated">이 순간 타이핑</target>
        </trans-unit>
        <trans-unit id="ede1fb5d661ab864aba9032ff56e1ac325b126c0" translate="yes" xml:space="preserve">
          <source>Atomic Change Groups</source>
          <target state="translated">원자 변경 그룹</target>
        </trans-unit>
        <trans-unit id="aab81d84cf8514fae3d044627f17a742d2c5166b" translate="yes" xml:space="preserve">
          <source>Atomic Windows</source>
          <target state="translated">원자 창</target>
        </trans-unit>
        <trans-unit id="ccb118068fddf7824a58d856e2c3e7b40ebb74f7" translate="yes" xml:space="preserve">
          <source>Atomic windows are implemented with the help of the reserved &lt;code&gt;window-atom&lt;/code&gt; window parameter (see &lt;a href=&quot;window-parameters#Window-Parameters&quot;&gt;Window Parameters&lt;/a&gt;) and an internal window (see &lt;a href=&quot;basic-windows#Basic-Windows&quot;&gt;Basic Windows&lt;/a&gt;) called the root window of the atomic window. All windows that are part of the same atomic window have this root window as their common ancestor and are assigned a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;window-atom&lt;/code&gt; parameter.</source>
          <target state="translated">원자 창은 예약 된 &lt;code&gt;window-atom&lt;/code&gt; 창 매개 변수 ( &lt;a href=&quot;window-parameters#Window-Parameters&quot;&gt;Window 매개 변수&lt;/a&gt; 참조 )와 원자 창의 루트 창이라고 하는 내부 창 ( &lt;a href=&quot;basic-windows#Basic-Windows&quot;&gt;기본&lt;/a&gt; 창 참조) 의 도움으로 구현됩니다 . 동일한 원자 창의 일부인 모든 창은이 루트 창을 공통 조상으로 가지며 &lt;code&gt;nil&lt;/code&gt; 이 아닌 &lt;code&gt;window-atom&lt;/code&gt; 매개 변수 가 할당 됩니다.</target>
        </trans-unit>
        <trans-unit id="a163ce0a704c17ae2c4e7f0c3f6ff0be652a3729" translate="yes" xml:space="preserve">
          <source>Atomic windows are rectangular compositions of at least two live windows. They have the following distinctive characteristics:</source>
          <target state="translated">원자 창은 두 개 이상의 라이브 창으로 구성된 직사각형 구성입니다. 다음과 같은 특징이 있습니다.</target>
        </trans-unit>
        <trans-unit id="84b84a11114f20365d178505da52d54f0c432b05" translate="yes" xml:space="preserve">
          <source>Atomic windows are useful to construct and preserve window layouts that are meaningful only when all involved buffers are shown simultaneously in a specific manner, such as when showing differences between file revisions, or the same text in different languages or markups. They can also be used to permanently display information pertinent to a specific window in bars on that window&amp;rsquo;s sides.</source>
          <target state="translated">원자 적 창은 관련된 모든 버퍼가 특정 방식으로 동시에 표시 될 때만 의미가있는 창 레이아웃을 구성하고 보존하는 데 유용합니다. 또한 특정 창과 관련된 정보를 해당 창 측면의 막대에 영구적으로 표시하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ac3939a8902c4e5ec26fa6e697cca7abee0c334" translate="yes" xml:space="preserve">
          <source>Atomic windows automatically cease to exist when one of their constituents gets deleted. To dissolve an atomic window manually, reset the &lt;code&gt;window-atom&lt;/code&gt; parameter of its constituents&amp;mdash;the root of the atomic window and all its descendants.</source>
          <target state="translated">원자 창은 구성 요소 중 하나가 삭제되면 자동으로 존재하지 않습니다. 원자 창을 수동으로 분해하려면 구성 요소 (원자 창의 루트 및 모든 하위 항목) 의 &lt;code&gt;window-atom&lt;/code&gt; 매개 변수를 재설정합니다 .</target>
        </trans-unit>
        <trans-unit id="b9ac22b82065cc69d28fef7fb37ebf9456c2f8c5" translate="yes" xml:space="preserve">
          <source>Attempt to set a constant symbol</source>
          <target state="translated">상수 기호 설정 시도</target>
        </trans-unit>
        <trans-unit id="040459de5fdc40f82378844a0d54d538e77e475c" translate="yes" xml:space="preserve">
          <source>Attempts to match &lt;var&gt;pattern1&lt;/var&gt;&amp;hellip;, in order, until one of them fails to match. In that case, &lt;code&gt;and&lt;/code&gt; likewise fails to match, and the rest of the sub-patterns are not tested. If all sub-patterns match, &lt;code&gt;and&lt;/code&gt; matches.</source>
          <target state="translated">그중 하나가 일치하지 않을 때까지 &lt;var&gt;pattern1&lt;/var&gt; &amp;hellip;을 순서대로 일치 시키려고 시도합니다 . 이 경우 &lt;code&gt;and&lt;/code&gt; 마찬가지로 일치 실패하고 하위 패턴의 나머지 부분은 테스트되지 않습니다. 모든 하위 패턴이 일치 &lt;code&gt;and&lt;/code&gt; 일치하는 경우.</target>
        </trans-unit>
        <trans-unit id="d62c51b00eb3d0f88c19008784cb02b23b4ba495" translate="yes" xml:space="preserve">
          <source>Attempts to match &lt;var&gt;pattern1&lt;/var&gt;, &lt;var&gt;pattern2&lt;/var&gt;, &amp;hellip;, in order, until one of them succeeds. In that case, &lt;code&gt;or&lt;/code&gt; likewise matches, and the rest of the sub-patterns are not tested. (Note that there must be at least two sub-patterns. Simply &lt;code&gt;(or&amp;nbsp;&lt;var&gt;pattern1&lt;/var&gt;)&lt;/code&gt; signals error.)</source>
          <target state="translated">그들 중 하나가 성공할 때까지 &lt;var&gt;pattern1&lt;/var&gt; , &lt;var&gt;pattern2&lt;/var&gt; ,&amp;hellip;, 순서대로 일치를 시도 합니다. 이 경우 &lt;code&gt;or&lt;/code&gt; 마찬가지로 일치하고 나머지 하위 패턴은 테스트되지 않습니다. (최소한 두 개의 하위 패턴이 있어야합니다. 단순히 &lt;code&gt;(or&amp;nbsp;&lt;var&gt;pattern1&lt;/var&gt;)&lt;/code&gt; 신호 오류입니다.)</target>
        </trans-unit>
        <trans-unit id="5b2467f53cc44078cb438b0c2750bc2ec1578c8a" translate="yes" xml:space="preserve">
          <source>Attract focus to the window chosen</source>
          <target state="translated">선택한 창에 초점을 맞 춥니 다.</target>
        </trans-unit>
        <trans-unit id="19a9640f6e74bf975fe0db395e61ad03d3ece1c7" translate="yes" xml:space="preserve">
          <source>Audible signal to the user.</source>
          <target state="translated">사용자에게 가청 신호.</target>
        </trans-unit>
        <trans-unit id="ee1acfa55eb1476c86c5c4a68f256a67b25289ab" translate="yes" xml:space="preserve">
          <source>Authentication</source>
          <target state="translated">Authentication</target>
        </trans-unit>
        <trans-unit id="2667d909be440bdf6583125971872bea1221d4db" translate="yes" xml:space="preserve">
          <source>Auto Fill mode also enables the functions that change the margins and justification style to refill portions of the text. See &lt;a href=&quot;margins#Margins&quot;&gt;Margins&lt;/a&gt;.</source>
          <target state="translated">자동 채우기 모드에서는 여백 및 양쪽 맞춤 스타일을 변경하여 텍스트의 일부를 다시 채우는 기능도 사용할 수 있습니다. &lt;a href=&quot;margins#Margins&quot;&gt;여백을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="555de047487d343cd666ab6a903a79ef6c09e487" translate="yes" xml:space="preserve">
          <source>Auto Fill mode is a minor mode that fills lines automatically as text is inserted. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Auto-Fill.html#Auto-Fill&quot;&gt;Auto Fill&lt;/a&gt; in</source>
          <target state="translated">자동 채우기 모드는 텍스트가 삽입 될 때 자동으로 줄을 채우는 보조 모드입니다. 참조 &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Auto-Fill.html#Auto-Fill&quot;&gt;자동 채우기&lt;/a&gt; 에</target>
        </trans-unit>
        <trans-unit id="850ade7a51d735a464313dc8f30adc7d11e8a00d" translate="yes" xml:space="preserve">
          <source>Auto Filling</source>
          <target state="translated">자동 채우기</target>
        </trans-unit>
        <trans-unit id="0b4ed412ef994ca0c43e1b7bd22d818d428bb6c5" translate="yes" xml:space="preserve">
          <source>Auto-Saving</source>
          <target state="translated">Auto-Saving</target>
        </trans-unit>
        <trans-unit id="845b01108562c3d927a2af1812a0c1bf88795555" translate="yes" xml:space="preserve">
          <source>Auto-saving...</source>
          <target state="translated">Auto-saving...</target>
        </trans-unit>
        <trans-unit id="c2e779e790c1d4dc28d4326306803dbf362b481e" translate="yes" xml:space="preserve">
          <source>Autoload</source>
          <target state="translated">Autoload</target>
        </trans-unit>
        <trans-unit id="06d7988cf794172658af0153fd1a2481ba35d7d2" translate="yes" xml:space="preserve">
          <source>Autoload Type</source>
          <target state="translated">자동로드 유형</target>
        </trans-unit>
        <trans-unit id="85e513dae1246e61ba8640eb87ad292a21840742" translate="yes" xml:space="preserve">
          <source>Autoload by Prefix</source>
          <target state="translated">접두사 별 자동로드</target>
        </trans-unit>
        <trans-unit id="a316cd16d04dc567c3b4909645684cb65b1f615f" translate="yes" xml:space="preserve">
          <source>Autoload by Prefix.</source>
          <target state="translated">접두사 별 자동로드.</target>
        </trans-unit>
        <trans-unit id="3fa81ba949fafdad4688aed6d9380f82976ca9d7" translate="yes" xml:space="preserve">
          <source>Autoloading</source>
          <target state="translated">Autoloading</target>
        </trans-unit>
        <trans-unit id="eb9cb47e9f34f586b55a9d914f6b2f6403badd01" translate="yes" xml:space="preserve">
          <source>Automatic Face Assignment</source>
          <target state="translated">자동 얼굴 할당</target>
        </trans-unit>
        <trans-unit id="ae90bbb56c1aa1c308fb3a413aa144f52a6ccd37" translate="yes" xml:space="preserve">
          <source>Automatic Indentation of code</source>
          <target state="translated">코드 자동 들여 쓰기</target>
        </trans-unit>
        <trans-unit id="a8cc32cc81dbf9afed120141fd3975ae43627630" translate="yes" xml:space="preserve">
          <source>Automatic updating of frame titles.</source>
          <target state="translated">프레임 제목 자동 업데이트.</target>
        </trans-unit>
        <trans-unit id="a5bc07194f48e4d3351e56450cd28e631e2382b0" translate="yes" xml:space="preserve">
          <source>Automatically re-evaluate a list of expressions and display their results each time Edebug updates the display.</source>
          <target state="translated">표현식 목록을 자동으로 재평가하고 Edebug가 디스플레이를 업데이트 할 때마다 결과를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="1cd844466867bdaf6e1db628300b6112623f0e83" translate="yes" xml:space="preserve">
          <source>Automatically selecting windows with the mouse.</source>
          <target state="translated">마우스로 창을 자동으로 선택합니다.</target>
        </trans-unit>
        <trans-unit id="c89d8ac98afcea167130340f5b561c866ca98fd5" translate="yes" xml:space="preserve">
          <source>Autotyping</source>
          <target state="translated">Autotyping</target>
        </trans-unit>
        <trans-unit id="361af9ca637df41d1dd709df4b2eb262901b3fd8" translate="yes" xml:space="preserve">
          <source>Avoid &lt;code&gt;ssize_t&lt;/code&gt; except when communicating to low-level APIs that have &lt;code&gt;ssize_t&lt;/code&gt;-related limitations. Although it&amp;rsquo;s equivalent to &lt;code&gt;ptrdiff_t&lt;/code&gt; on typical platforms, &lt;code&gt;ssize_t&lt;/code&gt; is occasionally narrower, so using it for size-related calculations could overflow. Also, &lt;code&gt;ptrdiff_t&lt;/code&gt; is more ubiquitous and better-standardized, has standard &lt;code&gt;printf&lt;/code&gt; formats, and is the basis for Emacs&amp;rsquo;s internal size-overflow checking. When using &lt;code&gt;ssize_t&lt;/code&gt;, please note that POSIX requires support only for values in the range -1 .. &lt;code&gt;SSIZE_MAX&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ssize_t&lt;/code&gt; 관련 제한 이있는 저수준 API와 통신하는 경우를 제외하고 &lt;code&gt;ssize_t&lt;/code&gt; 를 사용 하지 마십시오 . 일반적인 플랫폼에서 &lt;code&gt;ptrdiff_t&lt;/code&gt; 와 동일하지만 &lt;code&gt;ssize_t&lt;/code&gt; 는 때때로 더 좁아 지므로 크기 관련 계산에 사용하면 오버플로가 발생할 수 있습니다. 또한 &lt;code&gt;ptrdiff_t&lt;/code&gt; 는 더 편재하고 더 잘 표준화되어 있으며 표준 &lt;code&gt;printf&lt;/code&gt; 형식을 가지고 있으며 Emacs의 내부 크기 오버플로 검사의 기반입니다. &lt;code&gt;ssize_t&lt;/code&gt; 를 사용할 때 POSIX는 -1 .. &lt;code&gt;SSIZE_MAX&lt;/code&gt; 범위의 값만 지원해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4db5c02b78c97409e22545eb6907ca4a351e1990" translate="yes" xml:space="preserve">
          <source>Avoid arbitrary limits. For example, avoid &lt;code&gt;int len = strlen
(s);&lt;/code&gt; unless the length of &lt;code&gt;s&lt;/code&gt; is required for other reasons to fit in &lt;code&gt;int&lt;/code&gt; range.</source>
          <target state="translated">임의의 제한을 피하십시오. 예를 들어, &lt;code&gt;int len = strlen (s);&lt;/code&gt; &lt;code&gt;int&lt;/code&gt; 범위 에 맞추기 위해 다른 이유로 &lt;code&gt;s&lt;/code&gt; 의 길이 가 필요 하지 않는 한 .</target>
        </trans-unit>
        <trans-unit id="0d6e79e0cc19181112cfd0c36a5750ae8c092fc5" translate="yes" xml:space="preserve">
          <source>Avoid depending on how many times expansion is done.</source>
          <target state="translated">확장이 수행되는 횟수에 따라 피하십시오.</target>
        </trans-unit>
        <trans-unit id="2e549352e5b71cd7798ed53124f97e4a4c19088d" translate="yes" xml:space="preserve">
          <source>Avoiding evaluation (to put constants in the program).</source>
          <target state="translated">평가를 피합니다 (프로그램에 상수를 넣는 것).</target>
        </trans-unit>
        <trans-unit id="98c63cc59f3d9c3c7c9d29e55ddfee0b39d55b90" translate="yes" xml:space="preserve">
          <source>Avoiding problems with dynamic binding.</source>
          <target state="translated">동적 바인딩 문제 방지.</target>
        </trans-unit>
        <trans-unit id="ae4f281df5a5d0ff3cad6371f76d5c29b6d953ec" translate="yes" xml:space="preserve">
          <source>B</source>
          <target state="translated">B</target>
        </trans-unit>
        <trans-unit id="16374ac2b9a2eb53d18fcede0cdf14c4d6e18ba5" translate="yes" xml:space="preserve">
          <source>BS</source>
          <target state="translated">BS</target>
        </trans-unit>
        <trans-unit id="b52b36b7269fbfc58ec24bb724691951a3decbe8" translate="yes" xml:space="preserve">
          <source>Back</source>
          <target state="translated">Back</target>
        </trans-unit>
        <trans-unit id="17c0e560f6eadc671493346fc0a13caf302e9875" translate="yes" xml:space="preserve">
          <source>Background color, a string. The value can be a system-defined color name, or a hexadecimal color specification. See &lt;a href=&quot;color-names#Color-Names&quot;&gt;Color Names&lt;/a&gt;.</source>
          <target state="translated">배경색, 문자열. 값은 시스템 정의 색상 이름이거나 16 진수 색상 사양 일 수 있습니다. &lt;a href=&quot;color-names#Color-Names&quot;&gt;색상 이름을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cc48ef84cf0ee761d58df4dcb6d99bd10746fd9a" translate="yes" xml:space="preserve">
          <source>Backquote</source>
          <target state="translated">Backquote</target>
        </trans-unit>
        <trans-unit id="1c6ba351e6ca20e8a37172efc2c86d4aab598c50" translate="yes" xml:space="preserve">
          <source>Backquote-Style Patterns</source>
          <target state="translated">백 쿼트 스타일 패턴</target>
        </trans-unit>
        <trans-unit id="c0ecdab9574e4ebcb9dc4d8aec5335a6fb1dc637" translate="yes" xml:space="preserve">
          <source>Backquote-style patterns are a powerful set of &lt;code&gt;pcase&lt;/code&gt; pattern extensions (created using &lt;code&gt;pcase-defmacro&lt;/code&gt;) that make it easy to match &lt;var&gt;expval&lt;/var&gt; against specifications of its &lt;em&gt;structure&lt;/em&gt;.</source>
          <target state="translated">역 따옴표 스타일 패턴은 &lt;var&gt;expval&lt;/var&gt; 을 &lt;em&gt;구조&lt;/em&gt; 사양 과 쉽게 일치 시킬 수 있는 강력한 &lt;code&gt;pcase&lt;/code&gt; 패턴 확장 ( &lt;code&gt;pcase-defmacro&lt;/code&gt; 를 사용하여 생성됨 ) 집합입니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a017b7b51d9d23728fcdbbcaa591b2596fe0b09a" translate="yes" xml:space="preserve">
          <source>Backslash Constructs in Regular Expressions</source>
          <target state="translated">정규식의 백 슬래시 구문</target>
        </trans-unit>
        <trans-unit id="807e6daac187d064954fd59f10abb8e716892ec1" translate="yes" xml:space="preserve">
          <source>Backslash-sequences in regular expressions.</source>
          <target state="translated">정규식의 백 슬래시 시퀀스.</target>
        </trans-unit>
        <trans-unit id="9bfb245aa5d9e794b82e574165fbbc700e3e2a72" translate="yes" xml:space="preserve">
          <source>Backtraces</source>
          <target state="translated">Backtraces</target>
        </trans-unit>
        <trans-unit id="c3e2b2ecbdd4245dd6be8d66bf5a99a7880e1508" translate="yes" xml:space="preserve">
          <source>Backtracking in Specifications</source>
          <target state="translated">사양의 역 추적</target>
        </trans-unit>
        <trans-unit id="efef7b78f24a9457b9578006ead1a23980b022a2" translate="yes" xml:space="preserve">
          <source>Backtracking is also disabled after successfully matching a quoted symbol or string specification, since this usually indicates a recognized construct. But if you have a set of alternative constructs that all begin with the same symbol, you can usually work around this constraint by factoring the symbol out of the alternatives, e.g., &lt;code&gt;[&quot;foo&quot; &amp;amp;or [first case] [second case] ...]&lt;/code&gt;.</source>
          <target state="translated">역 추적은 일반적으로 인식 된 구조를 나타 내기 때문에 인용 부호 또는 문자열 사양과 성공적으로 일치 한 후에도 비활성화됩니다. 그러나 모두 동일한 기호로 시작하는 대체 구성 집합이있는 경우 대체 항목에서 기호를 인수 분해하여이 제약 조건을 해결할 수 있습니다 (예 : &lt;code&gt;[&quot;foo&quot; &amp;amp;or [first case] [second case] ...]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b80345f727522e6032bad01fc94ae4ee43720c6" translate="yes" xml:space="preserve">
          <source>Backtracking is disabled while matching any of the form specifications (that is, &lt;code&gt;form&lt;/code&gt;, &lt;code&gt;body&lt;/code&gt;, &lt;code&gt;def-form&lt;/code&gt;, and &lt;code&gt;def-body&lt;/code&gt;). These specifications will match any form so any error must be in the form itself rather than at a higher level.</source>
          <target state="translated">양식 사양 (즉, &lt;code&gt;form&lt;/code&gt; , &lt;code&gt;body&lt;/code&gt; , &lt;code&gt;def-form&lt;/code&gt; 및 &lt;code&gt;def-body&lt;/code&gt; ) 과 일치하는 동안에는 역 추적을 사용할 수 없습니다 . 이러한 사양은 모든 형식과 일치하므로 오류는 상위 수준이 아닌 형식 자체에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="a4fc1af88bf3a7f32329f6577445d6679643e427" translate="yes" xml:space="preserve">
          <source>Backup Files</source>
          <target state="translated">백업 파일</target>
        </trans-unit>
        <trans-unit id="40a0ef48a621ee3ca348b1e08eee5e6ff78084ac" translate="yes" xml:space="preserve">
          <source>Backup by Renaming or by Copying?</source>
          <target state="translated">이름을 바꾸거나 복사하여 백업 하시겠습니까?</target>
        </trans-unit>
        <trans-unit id="3e24bb9e6bf592cfc87438fc7775b2a394418349" translate="yes" xml:space="preserve">
          <source>Backup files and auto-save files are two methods by which Emacs tries to protect the user from the consequences of crashes or of the user&amp;rsquo;s own errors. Auto-saving preserves the text from earlier in the current editing session; backup files preserve file contents prior to the current session.</source>
          <target state="translated">백업 파일과 자동 저장 파일은 Emacs가 충돌이나 사용자 자신의 오류로부터 사용자를 보호하는 두 가지 방법입니다. 자동 저장은 현재 편집 세션의 이전 텍스트를 보존합니다. 백업 파일은 현재 세션 이전의 파일 내용을 보존합니다.</target>
        </trans-unit>
        <trans-unit id="2b47ba4274b19191cdf1a5d7d53d13dd0235dd70" translate="yes" xml:space="preserve">
          <source>Backups and Auto-Saving</source>
          <target state="translated">백업 및 자동 저장</target>
        </trans-unit>
        <trans-unit id="0cea14da6f943b9330cb8b19aa3f92fa39fb6f16" translate="yes" xml:space="preserve">
          <source>Backups are usually made by renaming the visited file to a new name. Optionally, you can specify that backup files should be made by copying the visited file. This choice makes a difference for files with multiple names; it also can affect whether the edited file remains owned by the original owner or becomes owned by the user editing it.</source>
          <target state="translated">백업은 일반적으로 방문한 파일의 이름을 새 이름으로 변경하여 수행됩니다. 선택적으로 방문한 파일을 복사하여 백업 파일을 만들도록 지정할 수 있습니다. 이 선택은 여러 이름을 가진 파일에 차이를 만듭니다. 또한 편집 된 파일이 원래 소유자의 소유로 유지되는지 또는 편집 한 사용자가 소유하게되는지 여부에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="980a00caa2a5856cb63bd39c2e2070bc841c28b4" translate="yes" xml:space="preserve">
          <source>Backups of files with names matching &lt;var&gt;regexp&lt;/var&gt; will be made in &lt;var&gt;directory&lt;/var&gt;. &lt;var&gt;directory&lt;/var&gt; may be relative or absolute. If it is absolute, so that all matching files are backed up into the same directory, the file names in this directory will be the full name of the file backed up with all directory separators changed to &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;regexp&lt;/var&gt; 와 일치하는 이름을 가진 파일의 백업이 &lt;var&gt;directory&lt;/var&gt; 만들어집니다 . &lt;var&gt;directory&lt;/var&gt; 는 상대적이거나 절대적 일 수 있습니다. 절대적인 경우 일치하는 모든 파일이 동일한 디렉토리에 백업되도록이 디렉토리의 파일 이름은 모든 디렉토리 구분 기호가 '로 변경된 백업 파일의 전체 이름이됩니다.</target>
        </trans-unit>
        <trans-unit id="fd4a1f65749d89056abcaeac3722a7b7a8fe75a1" translate="yes" xml:space="preserve">
          <source>Backward Compatibility</source>
          <target state="translated">하위 호환성</target>
        </trans-unit>
        <trans-unit id="e514a03485d2668ef95953c312b10de6213c5a6b" translate="yes" xml:space="preserve">
          <source>Base 64 Encoding</source>
          <target state="translated">Base 64 인코딩</target>
        </trans-unit>
        <trans-unit id="2da9b468199d7990437f4078993fd373ed775585" translate="yes" xml:space="preserve">
          <source>Base 64 code is used in email to encode a sequence of 8-bit bytes as a longer sequence of</source>
          <target state="translated">Base 64 코드는 이메일에서 8 비트 바이트 시퀀스를 긴 시퀀스로 인코딩하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4c671100c5a64e216a5296532f998860991bfe71" translate="yes" xml:space="preserve">
          <source>Based on the provided grammar, SMIE will be able to provide automatic indentation without any extra effort. But in practice, this default indentation style will probably not be good enough. You will want to tweak it in many different cases.</source>
          <target state="translated">제공된 문법을 기반으로 SMIE는 별도의 노력없이 자동 들여 쓰기를 제공 할 수 있습니다. 그러나 실제로이 기본 들여 쓰기 스타일은 아마도 충분하지 않을 것입니다. 다양한 경우에이를 조정하고 싶을 것입니다.</target>
        </trans-unit>
        <trans-unit id="ed7c8b81e81eeb80d5baed6aff985328d2115ad0" translate="yes" xml:space="preserve">
          <source>Basic Char Syntax</source>
          <target state="translated">기본 문자 구문</target>
        </trans-unit>
        <trans-unit id="ca917eb6ff98062e696cf80a8ae061ef35888178" translate="yes" xml:space="preserve">
          <source>Basic Completion Functions</source>
          <target state="translated">기본 완성 기능</target>
        </trans-unit>
        <trans-unit id="50e2e3f56e746aee43ca80ef4e5fffdf4609c4f8" translate="yes" xml:space="preserve">
          <source>Basic Concepts of Coding Systems</source>
          <target state="translated">코딩 시스템의 기본 개념</target>
        </trans-unit>
        <trans-unit id="ad89db73741185f622afaecb510f561259b3dde6" translate="yes" xml:space="preserve">
          <source>Basic Concepts of Emacs Windows</source>
          <target state="translated">Emacs Windows의 기본 개념</target>
        </trans-unit>
        <trans-unit id="00f4714f957a02625aba98347f399df3258beab7" translate="yes" xml:space="preserve">
          <source>Basic Faces</source>
          <target state="translated">기본 얼굴</target>
        </trans-unit>
        <trans-unit id="ff9602efc9e32b4e2b30281afa47a5ad0c076c75" translate="yes" xml:space="preserve">
          <source>Basic Major Modes</source>
          <target state="translated">기본 주요 모드</target>
        </trans-unit>
        <trans-unit id="7f5daf3307f72897980331dcafb0dc7eac1c3f87" translate="yes" xml:space="preserve">
          <source>Basic Parameters</source>
          <target state="translated">기본 매개 변수</target>
        </trans-unit>
        <trans-unit id="57d59d1f9034406d74ff83e18c697246b75a0ddb" translate="yes" xml:space="preserve">
          <source>Basic Thread Functions</source>
          <target state="translated">기본 스레드 기능</target>
        </trans-unit>
        <trans-unit id="566fc95e858fa38a59a695bd7cab6cae3b6d8fa3" translate="yes" xml:space="preserve">
          <source>Basic concepts of keymaps.</source>
          <target state="translated">키맵의 기본 개념.</target>
        </trans-unit>
        <trans-unit id="a25b5cf184191bab8faa27ed59d923cece314ddb" translate="yes" xml:space="preserve">
          <source>Basic concepts of syntax tables.</source>
          <target state="translated">구문 테이블의 기본 개념.</target>
        </trans-unit>
        <trans-unit id="8b4ea8050a775a0f3ea3c2ccd48f52d29c5611ab" translate="yes" xml:space="preserve">
          <source>Basic concepts.</source>
          <target state="translated">기본 컨셉.</target>
        </trans-unit>
        <trans-unit id="0f70f9424495752a5144291186246e76da91be5b" translate="yes" xml:space="preserve">
          <source>Basic ideas of mode line control.</source>
          <target state="translated">모드 라인 제어의 기본 아이디어.</target>
        </trans-unit>
        <trans-unit id="1d42c96aca54ef9a010f6e17d0638352d113a90e" translate="yes" xml:space="preserve">
          <source>Basic information about minibuffers.</source>
          <target state="translated">미니 버퍼에 대한 기본 정보입니다.</target>
        </trans-unit>
        <trans-unit id="3d3ef0f3067180013beb55c1d6dc1d28f43802f5" translate="yes" xml:space="preserve">
          <source>Basic information on using windows.</source>
          <target state="translated">창 사용에 대한 기본 정보.</target>
        </trans-unit>
        <trans-unit id="1b6019974338c229459a64e3a602d1c23dece46e" translate="yes" xml:space="preserve">
          <source>Basic layout of frames.</source>
          <target state="translated">프레임의 기본 레이아웃.</target>
        </trans-unit>
        <trans-unit id="2a42ee27cdcf6bfedbc7c589958206e56696aee1" translate="yes" xml:space="preserve">
          <source>Basic properties of strings and characters.</source>
          <target state="translated">문자열과 문자의 기본 속성.</target>
        </trans-unit>
        <trans-unit id="3c23a95b197dbd7c57081385c609a0440865eff0" translate="yes" xml:space="preserve">
          <source>Basic thread functions.</source>
          <target state="translated">Basic thread functions.</target>
        </trans-unit>
        <trans-unit id="8b6d8cb0fe44b1ea97c8dffd9944957e48ec1ad8" translate="yes" xml:space="preserve">
          <source>Batch Mode</source>
          <target state="translated">배치 모드</target>
        </trans-unit>
        <trans-unit id="9b540e8dec8ec13cb761e2f53dc0c1414e9d9fbf" translate="yes" xml:space="preserve">
          <source>Be careful not to redefine existing functions unintentionally. &lt;code&gt;defun&lt;/code&gt; redefines even primitive functions such as &lt;code&gt;car&lt;/code&gt; without any hesitation or notification. Emacs does not prevent you from doing this, because redefining a function is sometimes done deliberately, and there is no way to distinguish deliberate redefinition from unintentional redefinition.</source>
          <target state="translated">Be careful not to redefine existing functions unintentionally. &lt;code&gt;defun&lt;/code&gt; redefines even primitive functions such as &lt;code&gt;car&lt;/code&gt; without any hesitation or notification. Emacs does not prevent you from doing this, because redefining a function is sometimes done deliberately, and there is no way to distinguish deliberate redefinition from unintentional redefinition.</target>
        </trans-unit>
        <trans-unit id="13b72a62f4358262651a47272a3079ef92b405df" translate="yes" xml:space="preserve">
          <source>Be careful when composing these regular expressions; a poorly written pattern can dramatically slow things down! The function &lt;code&gt;regexp-opt&lt;/code&gt; (see &lt;a href=&quot;regexp-functions#Regexp-Functions&quot;&gt;Regexp Functions&lt;/a&gt;) is useful for calculating optimal regular expressions to match several keywords.</source>
          <target state="translated">Be careful when composing these regular expressions; a poorly written pattern can dramatically slow things down! The function &lt;code&gt;regexp-opt&lt;/code&gt; (see &lt;a href=&quot;regexp-functions#Regexp-Functions&quot;&gt;Regexp Functions&lt;/a&gt;) is useful for calculating optimal regular expressions to match several keywords.</target>
        </trans-unit>
        <trans-unit id="27bc044b4c8d3ad73080a8adb64df2e5a46f2bb1" translate="yes" xml:space="preserve">
          <source>Be careful when using non-</source>
          <target state="translated">Be careful when using non-</target>
        </trans-unit>
        <trans-unit id="e685f45a3679a7ec991ede319ba164f9a2bcda4c" translate="yes" xml:space="preserve">
          <source>Be careful when writing macro calls in files that you intend to byte-compile. Since macro calls are expanded when they are compiled, the macros need to be loaded into Emacs or the byte compiler will not do the right thing. The usual way to handle this is with &lt;code&gt;require&lt;/code&gt; forms which specify the files containing the needed macro definitions (see &lt;a href=&quot;named-features#Named-Features&quot;&gt;Named Features&lt;/a&gt;). Normally, the byte compiler does not evaluate the code that it is compiling, but it handles &lt;code&gt;require&lt;/code&gt; forms specially, by loading the specified libraries. To avoid loading the macro definition files when someone &lt;em&gt;runs&lt;/em&gt; the compiled program, write &lt;code&gt;eval-when-compile&lt;/code&gt; around the &lt;code&gt;require&lt;/code&gt; calls (see &lt;a href=&quot;eval-during-compile#Eval-During-Compile&quot;&gt;Eval During Compile&lt;/a&gt;). For more details, See &lt;a href=&quot;compiling-macros#Compiling-Macros&quot;&gt;Compiling Macros&lt;/a&gt;.</source>
          <target state="translated">Be careful when writing macro calls in files that you intend to byte-compile. Since macro calls are expanded when they are compiled, the macros need to be loaded into Emacs or the byte compiler will not do the right thing. The usual way to handle this is with &lt;code&gt;require&lt;/code&gt; forms which specify the files containing the needed macro definitions (see &lt;a href=&quot;named-features#Named-Features&quot;&gt;Named Features&lt;/a&gt;). Normally, the byte compiler does not evaluate the code that it is compiling, but it handles &lt;code&gt;require&lt;/code&gt; forms specially, by loading the specified libraries. To avoid loading the macro definition files when someone &lt;em&gt;runs&lt;/em&gt; the compiled program, write &lt;code&gt;eval-when-compile&lt;/code&gt; around the &lt;code&gt;require&lt;/code&gt; calls (see &lt;a href=&quot;eval-during-compile#Eval-During-Compile&quot;&gt;Eval During Compile&lt;/a&gt;). For more details, See &lt;a href=&quot;compiling-macros#Compiling-Macros&quot;&gt;Compiling Macros&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="c6856b62c3a77e855fac355ce1578434726e9581" translate="yes" xml:space="preserve">
          <source>Be careful with file names that end in spaces. On some filesystems (notably, MS-Windows), trailing whitespace characters in file names are silently and automatically ignored.</source>
          <target state="translated">Be careful with file names that end in spaces. On some filesystems (notably, MS-Windows), trailing whitespace characters in file names are silently and automatically ignored.</target>
        </trans-unit>
        <trans-unit id="7baa8406b5920aeefae8bb15fe88275a07b0c0a0" translate="yes" xml:space="preserve">
          <source>Be sure to verify that the file name is relative before doing that. If you use an absolute file name, the results could be syntactically invalid or refer to the wrong file.</source>
          <target state="translated">Be sure to verify that the file name is relative before doing that. If you use an absolute file name, the results could be syntactically invalid or refer to the wrong file.</target>
        </trans-unit>
        <trans-unit id="98789dc3354690dfbeaecf0f3ce9c8a96fe9026d" translate="yes" xml:space="preserve">
          <source>Because &amp;lsquo;</source>
          <target state="translated">Because &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="e6dbac2a93ea4cf3cf393a42d12efb8fd86797f8" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;kill-emacs&lt;/code&gt; can be called in situations where user interaction is impossible (e.g., when the terminal is disconnected), functions on this hook should not attempt to interact with the user. If you want to interact with the user when Emacs is shutting down, use &lt;code&gt;kill-emacs-query-functions&lt;/code&gt;, described below.</source>
          <target state="translated">Because &lt;code&gt;kill-emacs&lt;/code&gt; can be called in situations where user interaction is impossible (e.g., when the terminal is disconnected), functions on this hook should not attempt to interact with the user. If you want to interact with the user when Emacs is shutting down, use &lt;code&gt;kill-emacs-query-functions&lt;/code&gt; , described below.</target>
        </trans-unit>
        <trans-unit id="0b34653ccb844a855bf2a53664633d4afdefaf2b" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;quote&lt;/code&gt; is used so often in programs, Lisp provides a convenient read syntax for it. An apostrophe character (&amp;lsquo;</source>
          <target state="translated">Because &lt;code&gt;quote&lt;/code&gt; is used so often in programs, Lisp provides a convenient read syntax for it. An apostrophe character (&amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="b2bc1f0e771e6eb95b71dcedaea02b03d8a8a123" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;save-excursion&lt;/code&gt; only saves point for the buffer that was current at the start of the excursion, any changes made to point in other buffers, during the excursion, will remain in effect afterward. This frequently leads to unintended consequences, so the byte compiler warns if you call &lt;code&gt;set-buffer&lt;/code&gt; during an excursion:</source>
          <target state="translated">Because &lt;code&gt;save-excursion&lt;/code&gt; only saves point for the buffer that was current at the start of the excursion, any changes made to point in other buffers, during the excursion, will remain in effect afterward. This frequently leads to unintended consequences, so the byte compiler warns if you call &lt;code&gt;set-buffer&lt;/code&gt; during an excursion:</target>
        </trans-unit>
        <trans-unit id="1d3ee6e492f4a143386c60288985612cf7687a32" translate="yes" xml:space="preserve">
          <source>Because cons cells are so central to Lisp, we also have a word for an object which is not a cons cell. These objects are called &lt;em&gt;atoms&lt;/em&gt;.</source>
          <target state="translated">Because cons cells are so central to Lisp, we also have a word for an object which is not a cons cell. These objects are called &lt;em&gt;atoms&lt;/em&gt;.</target>
        </trans-unit>
        <trans-unit id="8e02576b56371153350d8d25bb27cbfbf989dce0" translate="yes" xml:space="preserve">
          <source>Because each symbol has separate value and function cells, variables names and function names do not conflict. For example, the symbol &lt;code&gt;buffer-file-name&lt;/code&gt; has a value (the name of the file being visited in the current buffer) as well as a function definition (a primitive function that returns the name of the file):</source>
          <target state="translated">Because each symbol has separate value and function cells, variables names and function names do not conflict. For example, the symbol &lt;code&gt;buffer-file-name&lt;/code&gt; has a value (the name of the file being visited in the current buffer) as well as a function definition (a primitive function that returns the name of the file):</target>
        </trans-unit>
        <trans-unit id="d2ece29760102e60138459a857930034eb578422" translate="yes" xml:space="preserve">
          <source>Because it is common to perform arithmetic operations on a marker position, most of these operations (including &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt;) accept markers as arguments. In such cases, the marker stands for its current position.</source>
          <target state="translated">Because it is common to perform arithmetic operations on a marker position, most of these operations (including &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt; ) accept markers as arguments. In such cases, the marker stands for its current position.</target>
        </trans-unit>
        <trans-unit id="29cedf8199b58b0444621f3b1384580f106a0af6" translate="yes" xml:space="preserve">
          <source>Because it takes some time to load the standard Lisp files, the</source>
          <target state="translated">Because it takes some time to load the standard Lisp files, the</target>
        </trans-unit>
        <trans-unit id="42fc09422aef4da2bc16d41efb01630156afbdf1" translate="yes" xml:space="preserve">
          <source>Because most cons cells are used as part of lists, we refer to any structure made out of cons cells as a &lt;em&gt;list structure&lt;/em&gt;.</source>
          <target state="translated">Because most cons cells are used as part of lists, we refer to any structure made out of cons cells as a &lt;em&gt;list structure&lt;/em&gt;.</target>
        </trans-unit>
        <trans-unit id="aecbe3fd5b632bec5904e4eeb626bf628ddaa189" translate="yes" xml:space="preserve">
          <source>Because non terminals cannot appear consecutively in the BNF grammar, it is difficult to correctly handle tokens that act as terminators, so the above grammar treats &lt;code&gt;&quot;;&quot;&lt;/code&gt; as a statement &lt;em&gt;separator&lt;/em&gt; instead, which SMIE can handle very well.</source>
          <target state="translated">Because non terminals cannot appear consecutively in the BNF grammar, it is difficult to correctly handle tokens that act as terminators, so the above grammar treats &lt;code&gt;&quot;;&quot;&lt;/code&gt; as a statement &lt;em&gt;separator&lt;/em&gt; instead, which SMIE can handle very well.</target>
        </trans-unit>
        <trans-unit id="5527da9c81f706f4f494272f6a72b5e6c955dbcd" translate="yes" xml:space="preserve">
          <source>Because of the special nature of lazily bound variables, it is an error to set them (e.g. with &lt;code&gt;setq&lt;/code&gt;).</source>
          <target state="translated">Because of the special nature of lazily bound variables, it is an error to set them (e.g. with &lt;code&gt;setq&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="4cc7eee6b3274dd2df5b26429c74414bad10f743" translate="yes" xml:space="preserve">
          <source>Because of the way lists are implemented on top of cons cells, you can treat &lt;code&gt;list-alist&lt;/code&gt; in the example above as a cons cell alist, where the value type is a list with a single element containing the real value.</source>
          <target state="translated">Because of the way lists are implemented on top of cons cells, you can treat &lt;code&gt;list-alist&lt;/code&gt; in the example above as a cons cell alist, where the value type is a list with a single element containing the real value.</target>
        </trans-unit>
        <trans-unit id="d4920f7b17cfb9be5d144cd02f205a26abedb351" translate="yes" xml:space="preserve">
          <source>Because regular expression matching works only going forward, this is implemented by searching backwards from point for a match that ends at point. That can be quite slow if it has to search a long distance. You can bound the time required by specifying a non-&lt;code&gt;nil&lt;/code&gt; value for &lt;var&gt;limit&lt;/var&gt;, which says not to search before &lt;var&gt;limit&lt;/var&gt;. In this case, the match that is found must begin at or after &lt;var&gt;limit&lt;/var&gt;. Here&amp;rsquo;s an example:</source>
          <target state="translated">Because regular expression matching works only going forward, this is implemented by searching backwards from point for a match that ends at point. That can be quite slow if it has to search a long distance. You can bound the time required by specifying a non- &lt;code&gt;nil&lt;/code&gt; value for &lt;var&gt;limit&lt;/var&gt; , which says not to search before &lt;var&gt;limit&lt;/var&gt; . In this case, the match that is found must begin at or after &lt;var&gt;limit&lt;/var&gt; . Here&amp;rsquo;s an example:</target>
        </trans-unit>
        <trans-unit id="891978e65a108dec966a02f2c109e3c7ab27e318" translate="yes" xml:space="preserve">
          <source>Because the byte-compiled code is evaluated by the byte-code interpreter, instead of being executed directly by the machine&amp;rsquo;s hardware (as true compiled code is), byte-code is completely transportable from machine to machine without recompilation. It is not, however, as fast as true compiled code.</source>
          <target state="translated">Because the byte-compiled code is evaluated by the byte-code interpreter, instead of being executed directly by the machine&amp;rsquo;s hardware (as true compiled code is), byte-code is completely transportable from machine to machine without recompilation. It is not, however, as fast as true compiled code.</target>
        </trans-unit>
        <trans-unit id="9807276681c6c1286c20092e4291987485eca98a" translate="yes" xml:space="preserve">
          <source>Because the match data normally describe the most recent search only, you must be careful not to do another search inadvertently between the search you wish to refer back to and the use of the match data. If you can&amp;rsquo;t avoid another intervening search, you must save and restore the match data around it, to prevent it from being overwritten.</source>
          <target state="translated">Because the match data normally describe the most recent search only, you must be careful not to do another search inadvertently between the search you wish to refer back to and the use of the match data. If you can&amp;rsquo;t avoid another intervening search, you must save and restore the match data around it, to prevent it from being overwritten.</target>
        </trans-unit>
        <trans-unit id="2a9a557d3ce6491f8ae2018c1e6773fb2de8d6d8" translate="yes" xml:space="preserve">
          <source>Because the result of the evaluation is non-&lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;guard&lt;/code&gt; matches, &lt;code&gt;and&lt;/code&gt; matches, and control passes to that clause&amp;rsquo;s body forms.</source>
          <target state="translated">Because the result of the evaluation is non- &lt;code&gt;nil&lt;/code&gt; , &lt;code&gt;guard&lt;/code&gt; matches, &lt;code&gt;and&lt;/code&gt; matches, and control passes to that clause&amp;rsquo;s body forms.</target>
        </trans-unit>
        <trans-unit id="1db90825a22716e728468e821da490caab60e2bd" translate="yes" xml:space="preserve">
          <source>Because the symbols used for abbrevs are not interned in the usual obarray, they will never appear as the result of reading a Lisp expression; in fact, normally they are never used except by the code that handles abbrevs. Therefore, it is safe to use them in a nonstandard way.</source>
          <target state="translated">Because the symbols used for abbrevs are not interned in the usual obarray, they will never appear as the result of reading a Lisp expression; in fact, normally they are never used except by the code that handles abbrevs. Therefore, it is safe to use them in a nonstandard way.</target>
        </trans-unit>
        <trans-unit id="4c851d66714e2bb452c04ba43899f653d596ccbc" translate="yes" xml:space="preserve">
          <source>Because the width of a given string depends on the flags that control the appearance of certain characters, &lt;code&gt;vertical-motion&lt;/code&gt; behaves differently, for a given piece of text, depending on the buffer it is in, and even on the selected window (because the width, the truncation flag, and display table may vary between windows). See &lt;a href=&quot;usual-display#Usual-Display&quot;&gt;Usual Display&lt;/a&gt;.</source>
          <target state="translated">Because the width of a given string depends on the flags that control the appearance of certain characters, &lt;code&gt;vertical-motion&lt;/code&gt; behaves differently, for a given piece of text, depending on the buffer it is in, and even on the selected window (because the width, the truncation flag, and display table may vary between windows). See &lt;a href=&quot;usual-display#Usual-Display&quot;&gt;Usual Display&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="ed8353d04454f502b14b0705a480aaefdecdb99f" translate="yes" xml:space="preserve">
          <source>Because threads were a relatively late addition to Emacs Lisp, and due to the way dynamic binding was sometimes used in conjunction with &lt;code&gt;accept-process-output&lt;/code&gt;, by default a process is locked to the thread that created it. When a process is locked to a thread, output from the process can only be accepted by that thread.</source>
          <target state="translated">Because threads were a relatively late addition to Emacs Lisp, and due to the way dynamic binding was sometimes used in conjunction with &lt;code&gt;accept-process-output&lt;/code&gt; , by default a process is locked to the thread that created it. When a process is locked to a thread, output from the process can only be accepted by that thread.</target>
        </trans-unit>
        <trans-unit id="edefffca965b0362f640503f05f0a22864aaf0c5" translate="yes" xml:space="preserve">
          <source>Because we read from side to side in the inner loop, and from top to bottom in the outer loop, the effect of horizontal scrolling is not like that of textual or vertical scrolling. Textual scrolling involves selection of a portion of text to display, and vertical scrolling moves the window contents contiguously; but horizontal scrolling causes part of &lt;em&gt;each line&lt;/em&gt; to go off screen.</source>
          <target state="translated">Because we read from side to side in the inner loop, and from top to bottom in the outer loop, the effect of horizontal scrolling is not like that of textual or vertical scrolling. Textual scrolling involves selection of a portion of text to display, and vertical scrolling moves the window contents contiguously; but horizontal scrolling causes part of &lt;em&gt;each line&lt;/em&gt; to go off screen.</target>
        </trans-unit>
        <trans-unit id="ca1ce0d49ba0f409cab2f1c7bbd925fafa44fcfe" translate="yes" xml:space="preserve">
          <source>Beeping</source>
          <target state="translated">Beeping</target>
        </trans-unit>
        <trans-unit id="17f7918b2f07183d74812fc33ccac59180f7ee50" translate="yes" xml:space="preserve">
          <source>Before Emacs can draw a character on a graphical display, it must select a &lt;em&gt;font&lt;/em&gt; for that character&lt;a href=&quot;#FOOT23&quot; name=&quot;DOCF23&quot;&gt;&lt;sup&gt;23&lt;/sup&gt;&lt;/a&gt;. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Fonts.html#Fonts&quot;&gt;Fonts&lt;/a&gt; in</source>
          <target state="translated">Before Emacs can draw a character on a graphical display, it must select a &lt;em&gt;font&lt;/em&gt; for that character&lt;a href=&quot;#FOOT23&quot; name=&quot;DOCF23&quot;&gt;&lt;sup&gt;23&lt;/sup&gt;&lt;/a&gt;. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Fonts.html#Fonts&quot;&gt;Fonts&lt;/a&gt; in</target>
        </trans-unit>
        <trans-unit id="13e5148e87ac77ce622c012484f91f5a2b40ed38" translate="yes" xml:space="preserve">
          <source>Before actually playing the sound, &lt;code&gt;play-sound&lt;/code&gt; calls the functions in the list &lt;code&gt;play-sound-functions&lt;/code&gt;. Each function is called with one argument, &lt;var&gt;sound&lt;/var&gt;.</source>
          <target state="translated">Before actually playing the sound, &lt;code&gt;play-sound&lt;/code&gt; calls the functions in the list &lt;code&gt;play-sound-functions&lt;/code&gt; . Each function is called with one argument, &lt;var&gt;sound&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="acfa912275db6abf7aab479d6b8b835a2b7d945e" translate="yes" xml:space="preserve">
          <source>Before any attempt to send the request, the application-specific conditions are checked. Since the &lt;code&gt;jsonrpc&lt;/code&gt; library can&amp;rsquo;t know what these conditions are, the program can use the &lt;code&gt;jsonrpc-connection-ready-p&lt;/code&gt; generic function (see &lt;a href=&quot;generic-functions#Generic-Functions&quot;&gt;Generic Functions&lt;/a&gt;) to specify them. The default method for this function returns &lt;code&gt;t&lt;/code&gt;, but you can add overriding methods that return &lt;code&gt;nil&lt;/code&gt; in some situations, based on the arguments passed to it, which are the &lt;code&gt;jsonrpc-connection&lt;/code&gt; object (see &lt;a href=&quot;jsonrpc-overview#JSONRPC-Overview&quot;&gt;JSONRPC Overview&lt;/a&gt;) and whichever value you passed as the &lt;code&gt;:deferred&lt;/code&gt; keyword argument.</source>
          <target state="translated">Before any attempt to send the request, the application-specific conditions are checked. Since the &lt;code&gt;jsonrpc&lt;/code&gt; library can&amp;rsquo;t know what these conditions are, the program can use the &lt;code&gt;jsonrpc-connection-ready-p&lt;/code&gt; generic function (see &lt;a href=&quot;generic-functions#Generic-Functions&quot;&gt;Generic Functions&lt;/a&gt;) to specify them. The default method for this function returns &lt;code&gt;t&lt;/code&gt; , but you can add overriding methods that return &lt;code&gt;nil&lt;/code&gt; in some situations, based on the arguments passed to it, which are the &lt;code&gt;jsonrpc-connection&lt;/code&gt; object (see &lt;a href=&quot;jsonrpc-overview#JSONRPC-Overview&quot;&gt;JSONRPC Overview&lt;/a&gt;) and whichever value you passed as the &lt;code&gt;:deferred&lt;/code&gt; keyword argument.</target>
        </trans-unit>
        <trans-unit id="dcb73aafe29a27771bb410a3cc2ea9ba475e91b4" translate="yes" xml:space="preserve">
          <source>Before confirming unsaved changes, &lt;code&gt;kill-buffer&lt;/code&gt; calls the functions in the list &lt;code&gt;kill-buffer-query-functions&lt;/code&gt;, in order of appearance, with no arguments. The buffer being killed is the current buffer when they are called. The idea of this feature is that these functions will ask for confirmation from the user. If any of them returns &lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;kill-buffer&lt;/code&gt; spares the buffer&amp;rsquo;s life.</source>
          <target state="translated">Before confirming unsaved changes, &lt;code&gt;kill-buffer&lt;/code&gt; calls the functions in the list &lt;code&gt;kill-buffer-query-functions&lt;/code&gt; , in order of appearance, with no arguments. The buffer being killed is the current buffer when they are called. The idea of this feature is that these functions will ask for confirmation from the user. If any of them returns &lt;code&gt;nil&lt;/code&gt; , &lt;code&gt;kill-buffer&lt;/code&gt; spares the buffer&amp;rsquo;s life.</target>
        </trans-unit>
        <trans-unit id="b2c6df81ff9d3d92d5524e2fbe564a5cd653b1ec" translate="yes" xml:space="preserve">
          <source>Before creating the frame, this function ensures that Emacs is set up to display graphics. For instance, if Emacs has not processed X resources (e.g., if it was started on a text terminal), it does so at this time. In all other respects, this function behaves like &lt;code&gt;make-frame&lt;/code&gt; (see &lt;a href=&quot;creating-frames#Creating-Frames&quot;&gt;Creating Frames&lt;/a&gt;).</source>
          <target state="translated">Before creating the frame, this function ensures that Emacs is set up to display graphics. For instance, if Emacs has not processed X resources (e.g., if it was started on a text terminal), it does so at this time. In all other respects, this function behaves like &lt;code&gt;make-frame&lt;/code&gt; (see &lt;a href=&quot;creating-frames#Creating-Frames&quot;&gt;Creating Frames&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="838498ac25b34bcaba38e8d1736cb5d1213cbd8a" translate="yes" xml:space="preserve">
          <source>Before restoring the previous definitions, &lt;code&gt;unload-feature&lt;/code&gt; runs &lt;code&gt;remove-hook&lt;/code&gt; to remove functions in the library from certain hooks. These hooks include variables whose names end in &amp;lsquo;</source>
          <target state="translated">Before restoring the previous definitions, &lt;code&gt;unload-feature&lt;/code&gt; runs &lt;code&gt;remove-hook&lt;/code&gt; to remove functions in the library from certain hooks. These hooks include variables whose names end in &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="1f9591d8d77ddb1cb74b81db22ada52f623b6efb" translate="yes" xml:space="preserve">
          <source>Before suspending, &lt;code&gt;suspend-emacs&lt;/code&gt; runs the normal hook &lt;code&gt;suspend-hook&lt;/code&gt;. After the user resumes Emacs, &lt;code&gt;suspend-emacs&lt;/code&gt; runs the normal hook &lt;code&gt;suspend-resume-hook&lt;/code&gt;. See &lt;a href=&quot;hooks#Hooks&quot;&gt;Hooks&lt;/a&gt;.</source>
          <target state="translated">Before suspending, &lt;code&gt;suspend-emacs&lt;/code&gt; runs the normal hook &lt;code&gt;suspend-hook&lt;/code&gt; . After the user resumes Emacs, &lt;code&gt;suspend-emacs&lt;/code&gt; runs the normal hook &lt;code&gt;suspend-resume-hook&lt;/code&gt; . See &lt;a href=&quot;hooks#Hooks&quot;&gt;Hooks&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="88b944d20a7b391474416844b970d522dd303815" translate="yes" xml:space="preserve">
          <source>Before the display margins can display anything, you must give them a nonzero width. The usual way to do that is to set these variables:</source>
          <target state="translated">Before the display margins can display anything, you must give them a nonzero width. The usual way to do that is to set these variables:</target>
        </trans-unit>
        <trans-unit id="b44b66b4a5c9db407d2757ab95949e425a1d30d3" translate="yes" xml:space="preserve">
          <source>Before the double-click or double-drag event, Emacs generates a &lt;em&gt;double-down&lt;/em&gt; event when the user presses the button down for the second time. Its event type contains &amp;lsquo;</source>
          <target state="translated">Before the double-click or double-drag event, Emacs generates a &lt;em&gt;double-down&lt;/em&gt; event when the user presses the button down for the second time. Its event type contains &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="27eeeabd3ce039e5d19034d398eafd77b5b99419" translate="yes" xml:space="preserve">
          <source>Before you do this, make sure the defun has enough close parentheses. Otherwise,</source>
          <target state="translated">Before you do this, make sure the defun has enough close parentheses. Otherwise,</target>
        </trans-unit>
        <trans-unit id="cb9703a6b294ccc0880d4c1dfd4f9f3daf981cdb" translate="yes" xml:space="preserve">
          <source>Begin your module by including the header file</source>
          <target state="translated">Begin your module by including the header file</target>
        </trans-unit>
        <trans-unit id="b4042d6d0e34481a13a0bd70105a92db402dff7f" translate="yes" xml:space="preserve">
          <source>Beginning of buffer</source>
          <target state="translated">Beginning of buffer</target>
        </trans-unit>
        <trans-unit id="7967dbe1bdfdc4fa11437c00eb1b6a94e7b1839d" translate="yes" xml:space="preserve">
          <source>Being quick and simple, &lt;code&gt;unsafep&lt;/code&gt; does a very light analysis and rejects many Lisp expressions that are actually safe. There are no known cases where &lt;code&gt;unsafep&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt; for an unsafe expression. However, a safe Lisp expression can return a string with a &lt;code&gt;display&lt;/code&gt; property, containing an associated Lisp expression to be executed after the string is inserted into a buffer. This associated expression can be a virus. In order to be safe, you must delete properties from all strings calculated by user code before inserting them into buffers.</source>
          <target state="translated">Being quick and simple, &lt;code&gt;unsafep&lt;/code&gt; does a very light analysis and rejects many Lisp expressions that are actually safe. There are no known cases where &lt;code&gt;unsafep&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt; for an unsafe expression. However, a safe Lisp expression can return a string with a &lt;code&gt;display&lt;/code&gt; property, containing an associated Lisp expression to be executed after the string is inserted into a buffer. This associated expression can be a virus. In order to be safe, you must delete properties from all strings calculated by user code before inserting them into buffers.</target>
        </trans-unit>
        <trans-unit id="cd79998f02d02ee1f54b550965880ade28c0e5ae" translate="yes" xml:space="preserve">
          <source>Below is a table explaining each element. Note that last &lt;code&gt;heap&lt;/code&gt; entry is optional and present only if an underlying &lt;code&gt;malloc&lt;/code&gt; implementation provides &lt;code&gt;mallinfo&lt;/code&gt; function.</source>
          <target state="translated">Below is a table explaining each element. Note that last &lt;code&gt;heap&lt;/code&gt; entry is optional and present only if an underlying &lt;code&gt;malloc&lt;/code&gt; implementation provides &lt;code&gt;mallinfo&lt;/code&gt; function.</target>
        </trans-unit>
        <trans-unit id="b3840ae760c97e9024f5cab124e17dbea9c19d2c" translate="yes" xml:space="preserve">
          <source>Below is a table of the classes you can use in a character alternative, and what they mean. Note that the &amp;lsquo;</source>
          <target state="translated">Below is a table of the classes you can use in a character alternative, and what they mean. Note that the &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="01bae04f3ae2801c065a4011c8954162185dde4a" translate="yes" xml:space="preserve">
          <source>Below there is a description of a few subtypes of &lt;code&gt;Lisp_Vectorlike&lt;/code&gt;. Buffer object represents the text to display and edit. Window is the part of display structure which shows the buffer or is used as a container to recursively place other windows on the same frame. (Do not confuse Emacs Lisp window object with the window as an entity managed by the user interface system like X; in Emacs terminology, the latter is called frame.) Finally, process object is used to manage the subprocesses.</source>
          <target state="translated">Below there is a description of a few subtypes of &lt;code&gt;Lisp_Vectorlike&lt;/code&gt; . Buffer object represents the text to display and edit. Window is the part of display structure which shows the buffer or is used as a container to recursively place other windows on the same frame. (Do not confuse Emacs Lisp window object with the window as an entity managed by the user interface system like X; in Emacs terminology, the latter is called frame.) Finally, process object is used to manage the subprocesses.</target>
        </trans-unit>
        <trans-unit id="5c8be3db4820388729d86b1200b856644093f20c" translate="yes" xml:space="preserve">
          <source>Below we will give a number of guidelines to redeem the frustration mentioned above and thus to avoid literally losing buffers in-between the windows of a frame.</source>
          <target state="translated">Below we will give a number of guidelines to redeem the frustration mentioned above and thus to avoid literally losing buffers in-between the windows of a frame.</target>
        </trans-unit>
        <trans-unit id="0353802f217c5a533a465f68ec4f0d8faa7c50cf" translate="yes" xml:space="preserve">
          <source>Below, we show first the regexp as a string in Lisp syntax (to distinguish spaces from tab characters), and then the result of evaluating it. The string constant begins and ends with a double-quote. &amp;lsquo;</source>
          <target state="translated">Below, we show first the regexp as a string in Lisp syntax (to distinguish spaces from tab characters), and then the result of evaluating it. The string constant begins and ends with a double-quote. &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="3cca15ebda8dce9819d62b75dc10ad2c1696871b" translate="yes" xml:space="preserve">
          <source>Berkeley BSD and its variants.</source>
          <target state="translated">Berkeley BSD and its variants.</target>
        </trans-unit>
        <trans-unit id="01ea07f92a42549b5de550cce8a6d1e85ce49161" translate="yes" xml:space="preserve">
          <source>Beware: this property operates at a very low level, and affects a lot of code in unexpected ways. So use it with extreme caution. A common misuse is to put an intangible property on invisible text, which is actually unnecessary since the command loop will move point outside of the invisible text at the end of each command anyway. See &lt;a href=&quot;adjusting-point#Adjusting-Point&quot;&gt;Adjusting Point&lt;/a&gt;. For these reasons, this property is obsolete; use the &lt;code&gt;cursor-intangible&lt;/code&gt; property instead.</source>
          <target state="translated">Beware: this property operates at a very low level, and affects a lot of code in unexpected ways. So use it with extreme caution. A common misuse is to put an intangible property on invisible text, which is actually unnecessary since the command loop will move point outside of the invisible text at the end of each command anyway. See &lt;a href=&quot;adjusting-point#Adjusting-Point&quot;&gt;Adjusting Point&lt;/a&gt;. For these reasons, this property is obsolete; use the &lt;code&gt;cursor-intangible&lt;/code&gt; property instead.</target>
        </trans-unit>
        <trans-unit id="f7f5f613a250e0e11c1b4577276a09871c48b610" translate="yes" xml:space="preserve">
          <source>Beyond the basic vector, a lot of objects like markers, overlays and buffers are managed as if they were vectors. The corresponding C data structures include the &lt;code&gt;union vectorlike_header&lt;/code&gt; field whose &lt;code&gt;size&lt;/code&gt; member contains the subtype enumerated by &lt;code&gt;enum pvec_type&lt;/code&gt; and an information about how many &lt;code&gt;Lisp_Object&lt;/code&gt; fields this structure contains and what the size of the rest data is. This information is needed to calculate the memory footprint of an object, and used by the vector allocation code while iterating over the vector blocks.</source>
          <target state="translated">Beyond the basic vector, a lot of objects like markers, overlays and buffers are managed as if they were vectors. The corresponding C data structures include the &lt;code&gt;union vectorlike_header&lt;/code&gt; field whose &lt;code&gt;size&lt;/code&gt; member contains the subtype enumerated by &lt;code&gt;enum pvec_type&lt;/code&gt; and an information about how many &lt;code&gt;Lisp_Object&lt;/code&gt; fields this structure contains and what the size of the rest data is. This information is needed to calculate the memory footprint of an object, and used by the vector allocation code while iterating over the vector blocks.</target>
        </trans-unit>
        <trans-unit id="f2b8d702e0ae298ec5dfa21f68f107c0b717e304" translate="yes" xml:space="preserve">
          <source>Bidirectional Display</source>
          <target state="translated">Bidirectional Display</target>
        </trans-unit>
        <trans-unit id="0f761761aa75d96b2cf2c46b89a33d4202f1f95c" translate="yes" xml:space="preserve">
          <source>Bidirectional reordering can have surprising and unpleasant effects when two strings with bidirectional content are juxtaposed in a buffer, or otherwise programmatically concatenated into a string of text. A typical problematic case is when a buffer consists of sequences of text fields separated by whitespace or punctuation characters, like Buffer Menu mode or Rmail Summary Mode. Because the punctuation characters used as separators have &lt;em&gt;weak directionality&lt;/em&gt;, they take on the directionality of surrounding text. As result, a numeric field that follows a field with bidirectional content can be displayed &lt;em&gt;to the left&lt;/em&gt; of the preceding field, messing up the expected layout. There are several ways to avoid this problem:</source>
          <target state="translated">Bidirectional reordering can have surprising and unpleasant effects when two strings with bidirectional content are juxtaposed in a buffer, or otherwise programmatically concatenated into a string of text. A typical problematic case is when a buffer consists of sequences of text fields separated by whitespace or punctuation characters, like Buffer Menu mode or Rmail Summary Mode. Because the punctuation characters used as separators have &lt;em&gt;weak directionality&lt;/em&gt;, they take on the directionality of surrounding text. As result, a numeric field that follows a field with bidirectional content can be displayed &lt;em&gt;to the left&lt;/em&gt; of the preceding field, messing up the expected layout. There are several ways to avoid this problem:</target>
        </trans-unit>
        <trans-unit id="7618266932012d1bb7d78a709b3b8de0c7e01623" translate="yes" xml:space="preserve">
          <source>Bignums can have arbitrary precision. Operations that overflow a fixnum will return a bignum instead.</source>
          <target state="translated">Bignums can have arbitrary precision. Operations that overflow a fixnum will return a bignum instead.</target>
        </trans-unit>
        <trans-unit id="fb38340a365bddb7a78416de50a44b6a7efdea98" translate="yes" xml:space="preserve">
          <source>Bind the symbol &lt;var&gt;ref&lt;/var&gt; to a submatch that matches &lt;var&gt;rx-expr&lt;/var&gt;&lt;small&gt;...&lt;/small&gt;. &lt;var&gt;ref&lt;/var&gt; is bound in &lt;var&gt;body-forms&lt;/var&gt; to the string of the submatch or nil, but can also be used in &lt;code&gt;backref&lt;/code&gt;.</source>
          <target state="translated">Bind the symbol &lt;var&gt;ref&lt;/var&gt; to a submatch that matches &lt;var&gt;rx-expr&lt;/var&gt; &lt;small&gt;...&lt;/small&gt;. &lt;var&gt;ref&lt;/var&gt; is bound in &lt;var&gt;body-forms&lt;/var&gt; to the string of the submatch or nil, but can also be used in &lt;code&gt;backref&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4379c6bcd5778b843b030784559be7b79a5580f0" translate="yes" xml:space="preserve">
          <source>Binding &lt;code&gt;coding-system-for-write&lt;/code&gt; to a non-&lt;code&gt;nil&lt;/code&gt; value prevents output primitives from calling the function specified by &lt;code&gt;select-safe-coding-system-function&lt;/code&gt; (see &lt;a href=&quot;user_002dchosen-coding-systems#User_002dChosen-Coding-Systems&quot;&gt;User-Chosen Coding Systems&lt;/a&gt;). This is because</source>
          <target state="translated">Binding &lt;code&gt;coding-system-for-write&lt;/code&gt; to a non- &lt;code&gt;nil&lt;/code&gt; value prevents output primitives from calling the function specified by &lt;code&gt;select-safe-coding-system-function&lt;/code&gt; (see &lt;a href=&quot;user_002dchosen-coding-systems#User_002dChosen-Coding-Systems&quot;&gt;User-Chosen Coding Systems&lt;/a&gt;). This is because</target>
        </trans-unit>
        <trans-unit id="fd1754f82b6bd628f04b3f5c068badfc9846c322" translate="yes" xml:space="preserve">
          <source>Binding module functions to Lisp symbols</source>
          <target state="translated">Binding module functions to Lisp symbols</target>
        </trans-unit>
        <trans-unit id="5d759eb09f19bf06ed84ff18e43aee3a19e46979" translate="yes" xml:space="preserve">
          <source>Bitwise Operations on Integers</source>
          <target state="translated">Bitwise Operations on Integers</target>
        </trans-unit>
        <trans-unit id="93fd851ff63a4d886e2fa5d2be01e88deb486b52" translate="yes" xml:space="preserve">
          <source>Blinking Parentheses</source>
          <target state="translated">Blinking Parentheses</target>
        </trans-unit>
        <trans-unit id="6ac648d45e59dfdc6715fe0e3cbd86c82820c6b6" translate="yes" xml:space="preserve">
          <source>Block until &lt;var&gt;thread&lt;/var&gt; exits, or until the current thread is signaled. It returns the result of the &lt;var&gt;thread&lt;/var&gt; function. If &lt;var&gt;thread&lt;/var&gt; has already exited, this returns immediately.</source>
          <target state="translated">Block until &lt;var&gt;thread&lt;/var&gt; exits, or until the current thread is signaled. It returns the result of the &lt;var&gt;thread&lt;/var&gt; function. If &lt;var&gt;thread&lt;/var&gt; has already exited, this returns immediately.</target>
        </trans-unit>
        <trans-unit id="c6929c141afbaefdc4afd63ac4b5596956cfa67c" translate="yes" xml:space="preserve">
          <source>Bool-Vector Type</source>
          <target state="translated">Bool-Vector Type</target>
        </trans-unit>
        <trans-unit id="882f4e1ca02e65db176c079c22995b90c25fc39c" translate="yes" xml:space="preserve">
          <source>Bool-vectors</source>
          <target state="translated">Bool-vectors</target>
        </trans-unit>
        <trans-unit id="c0a12baab63ceb798d7bac34fa38c4622e4b0373" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;kill-ring&lt;/code&gt; and &lt;code&gt;kill-ring-yank-pointer&lt;/code&gt; are Lisp variables whose values are normally lists. The word &amp;ldquo;pointer&amp;rdquo; in the name of the &lt;code&gt;kill-ring-yank-pointer&lt;/code&gt; indicates that the variable&amp;rsquo;s purpose is to identify one element of the list for use by the next yank command.</source>
          <target state="translated">Both &lt;code&gt;kill-ring&lt;/code&gt; and &lt;code&gt;kill-ring-yank-pointer&lt;/code&gt; are Lisp variables whose values are normally lists. The word &amp;ldquo;pointer&amp;rdquo; in the name of the &lt;code&gt;kill-ring-yank-pointer&lt;/code&gt; indicates that the variable&amp;rsquo;s purpose is to identify one element of the list for use by the next yank command.</target>
        </trans-unit>
        <trans-unit id="2fdc0bac385ea879dbde52d2dd508f2b5a448d88" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;read-from-minibuffer&lt;/code&gt; and &lt;code&gt;completing-read&lt;/code&gt; add new elements to the history list automatically, and provide commands to allow the user to reuse items on the list. The only thing your program needs to do to use a history list is to initialize it and to pass its name to the input functions when you wish. But it is safe to modify the list by hand when the minibuffer input functions are not using it.</source>
          <target state="translated">Both &lt;code&gt;read-from-minibuffer&lt;/code&gt; and &lt;code&gt;completing-read&lt;/code&gt; add new elements to the history list automatically, and provide commands to allow the user to reuse items on the list. The only thing your program needs to do to use a history list is to initialize it and to pass its name to the input functions when you wish. But it is safe to modify the list by hand when the minibuffer input functions are not using it.</target>
        </trans-unit>
        <trans-unit id="fc66435a82b20252191500c38ab3e5707fac603e" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;yes-or-no-p&lt;/code&gt; and &lt;code&gt;y-or-n-p&lt;/code&gt; use the minibuffer.</source>
          <target state="translated">Both &lt;code&gt;yes-or-no-p&lt;/code&gt; and &lt;code&gt;y-or-n-p&lt;/code&gt; use the minibuffer.</target>
        </trans-unit>
        <trans-unit id="dfd6cff3dbda1d13ebd279438e41124efaba93e7" translate="yes" xml:space="preserve">
          <source>Both &lt;var&gt;error-symbol&lt;/var&gt; and &lt;var&gt;data&lt;/var&gt; are available to any error handlers that handle the error: &lt;code&gt;condition-case&lt;/code&gt; binds a local variable to a list of the form &lt;code&gt;(&lt;var&gt;error-symbol&lt;/var&gt; .
&lt;var&gt;data&lt;/var&gt;)&lt;/code&gt; (see &lt;a href=&quot;handling-errors#Handling-Errors&quot;&gt;Handling Errors&lt;/a&gt;).</source>
          <target state="translated">Both &lt;var&gt;error-symbol&lt;/var&gt; and &lt;var&gt;data&lt;/var&gt; are available to any error handlers that handle the error: &lt;code&gt;condition-case&lt;/code&gt; binds a local variable to a list of the form &lt;code&gt;(&lt;var&gt;error-symbol&lt;/var&gt; . &lt;var&gt;data&lt;/var&gt;)&lt;/code&gt; (see &lt;a href=&quot;handling-errors#Handling-Errors&quot;&gt;Handling Errors&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="62da8c794cc6a7eb9ffe501a46f505c4219f98f2" translate="yes" xml:space="preserve">
          <source>Both forms of this definition (with backquote and without) suffer from the defect that &lt;var&gt;final&lt;/var&gt; is evaluated on every iteration. If &lt;var&gt;final&lt;/var&gt; is a constant, this is not a problem. If it is a more complex form, say &lt;code&gt;(long-complex-calculation x)&lt;/code&gt;, this can slow down the execution significantly. If &lt;var&gt;final&lt;/var&gt; has side effects, executing it more than once is probably incorrect.</source>
          <target state="translated">Both forms of this definition (with backquote and without) suffer from the defect that &lt;var&gt;final&lt;/var&gt; is evaluated on every iteration. If &lt;var&gt;final&lt;/var&gt; is a constant, this is not a problem. If it is a more complex form, say &lt;code&gt;(long-complex-calculation x)&lt;/code&gt; , this can slow down the execution significantly. If &lt;var&gt;final&lt;/var&gt; has side effects, executing it more than once is probably incorrect.</target>
        </trans-unit>
        <trans-unit id="4b35a12cfb8382543b92627bbee4b04423faea8d" translate="yes" xml:space="preserve">
          <source>Both lists and arrays are classified as sequences.</source>
          <target state="translated">Both lists and arrays are classified as sequences.</target>
        </trans-unit>
        <trans-unit id="d2f3804efa9fdf3073f4d412bb85880a0a67b5c0" translate="yes" xml:space="preserve">
          <source>Both the values and the keys in an alist may be any Lisp objects. For example, in the following alist, the symbol &lt;code&gt;a&lt;/code&gt; is associated with the number &lt;code&gt;1&lt;/code&gt;, and the string &lt;code&gt;&quot;b&quot;&lt;/code&gt; is associated with the &lt;em&gt;list&lt;/em&gt;&lt;code&gt;(2 3)&lt;/code&gt;, which is the &lt;small&gt;CDR&lt;/small&gt; of the alist element:</source>
          <target state="translated">Both the values and the keys in an alist may be any Lisp objects. For example, in the following alist, the symbol &lt;code&gt;a&lt;/code&gt; is associated with the number &lt;code&gt;1&lt;/code&gt; , and the string &lt;code&gt;&quot;b&quot;&lt;/code&gt; is associated with the &lt;em&gt;list&lt;/em&gt; &lt;code&gt;(2 3)&lt;/code&gt; , which is the &lt;small&gt;CDR&lt;/small&gt; of the alist element:</target>
        </trans-unit>
        <trans-unit id="cce7f2f2f0dc525117a70d581d9c335212145e5b" translate="yes" xml:space="preserve">
          <source>Bottom</source>
          <target state="translated">Bottom</target>
        </trans-unit>
        <trans-unit id="e61ada95a3801a523f8d48042eaed868415934b4" translate="yes" xml:space="preserve">
          <source>Breaking on an event.</source>
          <target state="translated">Breaking on an event.</target>
        </trans-unit>
        <trans-unit id="25a85b6e8b7cc5b5a89123c777d9b420bfa8cc33" translate="yes" xml:space="preserve">
          <source>Breakpoints at stop points.</source>
          <target state="translated">Breakpoints at stop points.</target>
        </trans-unit>
        <trans-unit id="50f88da05c8e174324af021a4ee24bc168eb0c3d" translate="yes" xml:space="preserve">
          <source>Breaks</source>
          <target state="translated">Breaks</target>
        </trans-unit>
        <trans-unit id="ee60d60ea805fbda38f6f538481a92d3787df0b9" translate="yes" xml:space="preserve">
          <source>Brief description</source>
          <target state="translated">간단한 설명</target>
        </trans-unit>
        <trans-unit id="3fb0fc86dfa0b9d7362bd38d269b717749f04cef" translate="yes" xml:space="preserve">
          <source>Buffer Basics</source>
          <target state="translated">Buffer Basics</target>
        </trans-unit>
        <trans-unit id="c027215488849466cacd3006649b1340a2edd0fc" translate="yes" xml:space="preserve">
          <source>Buffer File Name</source>
          <target state="translated">Buffer File Name</target>
        </trans-unit>
        <trans-unit id="a4af6911c145bae353cfba5cde3bbb16bdca445e" translate="yes" xml:space="preserve">
          <source>Buffer Internals</source>
          <target state="translated">Buffer Internals</target>
        </trans-unit>
        <trans-unit id="5032b3933a4bf66e8948fdd3b1195bf2ec955ec7" translate="yes" xml:space="preserve">
          <source>Buffer Modification</source>
          <target state="translated">Buffer Modification</target>
        </trans-unit>
        <trans-unit id="a1220d5a5dc0d3413a288b7d866d2b909c573bb8" translate="yes" xml:space="preserve">
          <source>Buffer Modification Time</source>
          <target state="translated">Buffer Modification Time</target>
        </trans-unit>
        <trans-unit id="44e02f9bcee199b59cbd729f000935b0a07991dd" translate="yes" xml:space="preserve">
          <source>Buffer Names</source>
          <target state="translated">Buffer Names</target>
        </trans-unit>
        <trans-unit id="ccf9f9fdff4870f16ae30767ca4be6fe76523e15" translate="yes" xml:space="preserve">
          <source>Buffer Parameters</source>
          <target state="translated">Buffer Parameters</target>
        </trans-unit>
        <trans-unit id="e93f01132bbaec25c49799efddeb64957f02afd2" translate="yes" xml:space="preserve">
          <source>Buffer Text Notation</source>
          <target state="translated">Buffer Text Notation</target>
        </trans-unit>
        <trans-unit id="f1294c425911ac20d751cb9d1c51979e6e34f62e" translate="yes" xml:space="preserve">
          <source>Buffer Type</source>
          <target state="translated">Buffer Type</target>
        </trans-unit>
        <trans-unit id="abcd68a1e18c1b87353060b6dc458244da82927b" translate="yes" xml:space="preserve">
          <source>Buffer is read-only</source>
          <target state="translated">Buffer is read-only</target>
        </trans-unit>
        <trans-unit id="344030f3634d1baa3762609d3692b8f3c1316b48" translate="yes" xml:space="preserve">
          <source>Buffer positions and motion functions.</source>
          <target state="translated">Buffer positions and motion functions.</target>
        </trans-unit>
        <trans-unit id="6246ccf7dd19ff26d69c92fb853ac66fb5ae4f89" translate="yes" xml:space="preserve">
          <source>Buffer positions are measured in character units. This function returns the byte-position corresponding to buffer position &lt;var&gt;position&lt;/var&gt; in the current buffer. This is 1 at the start of the buffer, and counts upward in bytes. If &lt;var&gt;position&lt;/var&gt; is out of range, the value is &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Buffer positions are measured in character units. This function returns the byte-position corresponding to buffer position &lt;var&gt;position&lt;/var&gt; in the current buffer. This is 1 at the start of the buffer, and counts upward in bytes. If &lt;var&gt;position&lt;/var&gt; is out of range, the value is &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35ca209a656833f1530433e2982a81634d31ea0e" translate="yes" xml:space="preserve">
          <source>Buffer positions indicating which text is on-screen in a window.</source>
          <target state="translated">Buffer positions indicating which text is on-screen in a window.</target>
        </trans-unit>
        <trans-unit id="8a53998ea65d2c55189b85c0ba6f6abc07875258" translate="yes" xml:space="preserve">
          <source>Buffer-Local Variables</source>
          <target state="translated">Buffer-Local Variables</target>
        </trans-unit>
        <trans-unit id="e1f999c3ef7294166b2203dddf8a38a2a12863ad" translate="yes" xml:space="preserve">
          <source>Buffer-specific information that is directly accessible is stored in &lt;em&gt;buffer-local&lt;/em&gt; variable bindings, which are variable values that are effective only in a particular buffer. This feature allows each buffer to override the values of certain variables. Most major modes override variables such as &lt;code&gt;fill-column&lt;/code&gt; or &lt;code&gt;comment-column&lt;/code&gt; in this way. For more information about buffer-local variables and functions related to them, see &lt;a href=&quot;buffer_002dlocal-variables#Buffer_002dLocal-Variables&quot;&gt;Buffer-Local Variables&lt;/a&gt;.</source>
          <target state="translated">Buffer-specific information that is directly accessible is stored in &lt;em&gt;buffer-local&lt;/em&gt; variable bindings, which are variable values that are effective only in a particular buffer. This feature allows each buffer to override the values of certain variables. Most major modes override variables such as &lt;code&gt;fill-column&lt;/code&gt; or &lt;code&gt;comment-column&lt;/code&gt; in this way. For more information about buffer-local variables and functions related to them, see &lt;a href=&quot;buffer_002dlocal-variables#Buffer_002dLocal-Variables&quot;&gt;Buffer-Local Variables&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="ea28d2b0e2e067c2d49b361f79f8dd13430b1c1f" translate="yes" xml:space="preserve">
          <source>Buffer-wide commands and bindings for buttons.</source>
          <target state="translated">Buffer-wide commands and bindings for buttons.</target>
        </trans-unit>
        <trans-unit id="4cbcd2f7b704b607643b54842a2d38a1465e1a06" translate="yes" xml:space="preserve">
          <source>Buffers</source>
          <target state="translated">Buffers</target>
        </trans-unit>
        <trans-unit id="c34ea999c856831b2f1f1b93ec2c55bca01f7339" translate="yes" xml:space="preserve">
          <source>Buffers and Windows</source>
          <target state="translated">Buffers and Windows</target>
        </trans-unit>
        <trans-unit id="89fab4e05ae4baad776ec1df498d67259c031ce8" translate="yes" xml:space="preserve">
          <source>Buffers are displayed in windows.</source>
          <target state="translated">Buffers are displayed in windows.</target>
        </trans-unit>
        <trans-unit id="813e70bd28e3a98cb6625b026a7542aa93fd1a0a" translate="yes" xml:space="preserve">
          <source>Buffers exist until explicitly killed.</source>
          <target state="translated">Buffers exist until explicitly killed.</target>
        </trans-unit>
        <trans-unit id="5807d4a79a20e298c7a061e07bafbf257b7f1329" translate="yes" xml:space="preserve">
          <source>Buffers have no read syntax. They print in hash notation, showing the buffer name.</source>
          <target state="translated">Buffers have no read syntax. They print in hash notation, showing the buffer name.</target>
        </trans-unit>
        <trans-unit id="c849b71243437a37c01b415363a9e00d3f75220f" translate="yes" xml:space="preserve">
          <source>Buffers in Emacs editing are objects that have distinct names and hold text that can be edited. Buffers appear to Lisp programs as a special data type. You can think of the contents of a buffer as a string that you can extend; insertions and deletions may occur in any part of the buffer. See &lt;a href=&quot;text#Text&quot;&gt;Text&lt;/a&gt;.</source>
          <target state="translated">Buffers in Emacs editing are objects that have distinct names and hold text that can be edited. Buffers appear to Lisp programs as a special data type. You can think of the contents of a buffer as a string that you can extend; insertions and deletions may occur in any part of the buffer. See &lt;a href=&quot;text#Text&quot;&gt;Text&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="5d9c37d98ed9d04e80b306fce37d88ced34649fb" translate="yes" xml:space="preserve">
          <source>Buffers that are ephemeral and generally uninteresting to the user have names starting with a space, so that the &lt;code&gt;list-buffers&lt;/code&gt; and &lt;code&gt;buffer-menu&lt;/code&gt; commands don&amp;rsquo;t mention them (but if such a buffer visits a file, it &lt;strong&gt;is&lt;/strong&gt; mentioned). A name starting with space also initially disables recording undo information; see &lt;a href=&quot;undo#Undo&quot;&gt;Undo&lt;/a&gt;.</source>
          <target state="translated">Buffers that are ephemeral and generally uninteresting to the user have names starting with a space, so that the &lt;code&gt;list-buffers&lt;/code&gt; and &lt;code&gt;buffer-menu&lt;/code&gt; commands don&amp;rsquo;t mention them (but if such a buffer visits a file, it &lt;strong&gt;is&lt;/strong&gt; mentioned). A name starting with space also initially disables recording undo information; see &lt;a href=&quot;undo#Undo&quot;&gt;Undo&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="330d744f9b4b4abc2c70c54c6b6b286c98dced2b" translate="yes" xml:space="preserve">
          <source>Build a new evaluation list from the contents of the buffer (&lt;code&gt;edebug-update-eval-list&lt;/code&gt;).</source>
          <target state="translated">Build a new evaluation list from the contents of the buffer ( &lt;code&gt;edebug-update-eval-list&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="317d4e3a3a04e5eea5fc26c035b1ef9dd209902c" translate="yes" xml:space="preserve">
          <source>Build new types from other types or data.</source>
          <target state="translated">Build new types from other types or data.</target>
        </trans-unit>
        <trans-unit id="b1f5f048510e296c0efaf69fd58cab73cd422bd8" translate="yes" xml:space="preserve">
          <source>Building Cons Cells and Lists</source>
          <target state="translated">Building Cons Cells and Lists</target>
        </trans-unit>
        <trans-unit id="bdc049a5ba45c2fd12b217cecac69626d97e5db0" translate="yes" xml:space="preserve">
          <source>Building Emacs</source>
          <target state="translated">Building Emacs</target>
        </trans-unit>
        <trans-unit id="f53b042cb4d6b635c59397892faa831033884cbc" translate="yes" xml:space="preserve">
          <source>Building Emacs requires GNU Make version 3.81 or later.</source>
          <target state="translated">Building Emacs requires GNU Make version 3.81 or later.</target>
        </trans-unit>
        <trans-unit id="79b6b1f02a69a8e5241277580817571424a17daa" translate="yes" xml:space="preserve">
          <source>Building and dumping Emacs; internal data structures.</source>
          <target state="translated">Building and dumping Emacs; internal data structures.</target>
        </trans-unit>
        <trans-unit id="34812aaa741da1103c385a52808aa91b80e9594f" translate="yes" xml:space="preserve">
          <source>Built-in &lt;code&gt;rx&lt;/code&gt; forms, like &lt;code&gt;digit&lt;/code&gt; and &lt;code&gt;group&lt;/code&gt;, cannot be redefined.</source>
          <target state="translated">Built-in &lt;code&gt;rx&lt;/code&gt; forms, like &lt;code&gt;digit&lt;/code&gt; and &lt;code&gt;group&lt;/code&gt; , cannot be redefined.</target>
        </trans-unit>
        <trans-unit id="f1c7bd5dfbc70feff63bb4c975105aed8228177c" translate="yes" xml:space="preserve">
          <source>Builtin Commands</source>
          <target state="translated">내장 명령</target>
        </trans-unit>
        <trans-unit id="eb37717154ce80760d9e952968529a057b6b75e2" translate="yes" xml:space="preserve">
          <source>Builtin Constants</source>
          <target state="translated">Builtin Constants</target>
        </trans-unit>
        <trans-unit id="ce64a3485e5540eb2d738ffca93bc4a6a99dac9d" translate="yes" xml:space="preserve">
          <source>Builtin Functions</source>
          <target state="translated">내장 함수</target>
        </trans-unit>
        <trans-unit id="a9cc087245dc67aa0bcbea3954c8f85e35fb9e6d" translate="yes" xml:space="preserve">
          <source>Builtin Macros</source>
          <target state="translated">Builtin Macros</target>
        </trans-unit>
        <trans-unit id="c87bbec5d329be7d9ab3d4f7f28179b67b985893" translate="yes" xml:space="preserve">
          <source>Builtin Special Forms</source>
          <target state="translated">Builtin Special Forms</target>
        </trans-unit>
        <trans-unit id="ce27ad322fdf4fa3514cbeb626501e0ed27f14ae" translate="yes" xml:space="preserve">
          <source>Builtin User Options</source>
          <target state="translated">Builtin User Options</target>
        </trans-unit>
        <trans-unit id="843ed68047eb8a91c66fd38a5ea1a9307d042738" translate="yes" xml:space="preserve">
          <source>Builtin Variables</source>
          <target state="translated">내장 변수</target>
        </trans-unit>
        <trans-unit id="5067c37a304c3bbf7192b5da6e72fcd4d8ed1b67" translate="yes" xml:space="preserve">
          <source>But if you type a control combination not in</source>
          <target state="translated">그러나 컨트롤 조합을 입력하지 않으면</target>
        </trans-unit>
        <trans-unit id="5a9ec335ac0058bc8871067e4469ec28043b246e" translate="yes" xml:space="preserve">
          <source>But this will create conflicts for &lt;code&gt;&quot;ELSE&quot;&lt;/code&gt;: on the one hand, the IF rule implies (among many other things) that &lt;code&gt;&quot;ELSE&quot; = &quot;END&quot;&lt;/code&gt;; but on the other hand, since &lt;code&gt;&quot;ELSE&quot;&lt;/code&gt; appears within &lt;code&gt;cases&lt;/code&gt;, which appears left of &lt;code&gt;&quot;END&quot;&lt;/code&gt;, we also have &lt;code&gt;&quot;ELSE&quot; &amp;gt; &quot;END&quot;&lt;/code&gt;. We can solve the conflict either by using:</source>
          <target state="translated">그러나 이것은 &lt;code&gt;&quot;ELSE&quot;&lt;/code&gt; 에 대한 충돌을 야기 할 것입니다 . 한편으로 IF 규칙은 &lt;code&gt;&quot;ELSE&quot; = &quot;END&quot;&lt;/code&gt; 암시합니다 . 그러나 반면에 &lt;code&gt;&quot;ELSE&quot;&lt;/code&gt; 는 &lt;code&gt;&quot;END&quot;&lt;/code&gt; 왼쪽에 나타나는 &lt;code&gt;cases&lt;/code&gt; 내에 나타나기 때문에 &lt;code&gt;&quot;ELSE&quot; &amp;gt; &quot;END&quot;&lt;/code&gt; 있습니다. 다음을 사용하여 충돌을 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a081c2786dbf00aa6d8f9b177ec4a1ad92a73fe" translate="yes" xml:space="preserve">
          <source>But this would add multiple elements if the library is reloaded. To avoid the problem, use &lt;code&gt;add-to-list&lt;/code&gt; (see &lt;a href=&quot;list-variables#List-Variables&quot;&gt;List Variables&lt;/a&gt;):</source>
          <target state="translated">그러나 라이브러리가 다시로드되면 여러 요소가 추가됩니다. 문제를 방지하려면 &lt;code&gt;add-to-list&lt;/code&gt; 사용 하십시오 ( &lt;a href=&quot;list-variables#List-Variables&quot;&gt;목록 변수&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="07ec1dfa598ebfb12e7443602444d7a051d224dd" translate="yes" xml:space="preserve">
          <source>But we recommend &lt;code&gt;copy-sequence&lt;/code&gt; for this purpose (see &lt;a href=&quot;sequence-functions#Sequence-Functions&quot;&gt;Sequence Functions&lt;/a&gt;).</source>
          <target state="translated">그러나이 목적을 위해 &lt;code&gt;copy-sequence&lt;/code&gt; 를 권장합니다 ( &lt;a href=&quot;sequence-functions#Sequence-Functions&quot;&gt;시퀀스 함수&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="c0bd785491e817f0f44e14205af6a59e1a447d90" translate="yes" xml:space="preserve">
          <source>But you should use &lt;code&gt;advice-add&lt;/code&gt; and &lt;code&gt;advice-remove&lt;/code&gt; for that instead. This separate set of functions to manipulate pieces of advice applied to named functions, offers the following extra features compared to &lt;code&gt;add-function&lt;/code&gt;: they know how to deal with macros and autoloaded functions, they let &lt;code&gt;describe-function&lt;/code&gt; preserve the original docstring as well as document the added advice, and they let you add and remove advice before a function is even defined.</source>
          <target state="translated">하지만 대신에 &lt;code&gt;advice-add&lt;/code&gt; 및 &lt;code&gt;advice-remove&lt;/code&gt; 를 사용해야합니다. 명명 된 함수에 적용된 어드바이스 부분을 조작하는이 별도의 함수 세트는 &lt;code&gt;add-function&lt;/code&gt; 에 비해 다음과 같은 추가 기능을 제공합니다 . 매크로 및 자동로드 된 함수를 처리하는 방법을 알고 있으며 &lt;code&gt;describe-function&lt;/code&gt; 이 원래 문서와 문서를 보존하도록합니다. 추가 된 어드바이스는 함수가 정의되기 전에 어드바이스를 추가하고 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d8a0e63cd1a06ea0e2679c87030f5570105b2a4" translate="yes" xml:space="preserve">
          <source>Button Buffer Commands</source>
          <target state="translated">버튼 버퍼 명령</target>
        </trans-unit>
        <trans-unit id="d055960c135678f62a49f9b6f7a5d94add754440" translate="yes" xml:space="preserve">
          <source>Button Properties</source>
          <target state="translated">버튼 속성</target>
        </trans-unit>
        <trans-unit id="41fa24540db10de11f239ddb922c6363c465adf0" translate="yes" xml:space="preserve">
          <source>Button Types</source>
          <target state="translated">버튼 유형</target>
        </trans-unit>
        <trans-unit id="1e308eff60f72b546296987374ea4612fa02db86" translate="yes" xml:space="preserve">
          <source>Button properties with special meanings.</source>
          <target state="translated">특별한 의미를 가진 버튼 속성.</target>
        </trans-unit>
        <trans-unit id="e8bf727af91015f6f823f13b436c2880666b454a" translate="yes" xml:space="preserve">
          <source>Button-Down Events</source>
          <target state="translated">버튼 다운 이벤트</target>
        </trans-unit>
        <trans-unit id="503d46db37b0db45db898aabed77244252918ca2" translate="yes" xml:space="preserve">
          <source>Buttons</source>
          <target state="translated">Buttons</target>
        </trans-unit>
        <trans-unit id="4c379f628ac77bed975fa656ab1146980f7bff07" translate="yes" xml:space="preserve">
          <source>Buttons are associated with a region of text, using an overlay or text properties to hold button-specific information, all of which are initialized from the button&amp;rsquo;s type (which defaults to the built-in button type &lt;code&gt;button&lt;/code&gt;). Like all Emacs text, the appearance of the button is governed by the &lt;code&gt;face&lt;/code&gt; property; by default (via the &lt;code&gt;face&lt;/code&gt; property inherited from the &lt;code&gt;button&lt;/code&gt; button-type) this is a simple underline, like a typical web-page link.</source>
          <target state="translated">버튼은 오버레이 또는 텍스트 속성을 사용하여 버튼 관련 정보를 보유하는 텍스트 영역과 연결되며, 모두 버튼 유형 (기본 제공 버튼 유형 &lt;code&gt;button&lt;/code&gt; ) 에서 초기화됩니다 . 모든 Emacs 텍스트와 마찬가지로 버튼의 모양은 &lt;code&gt;face&lt;/code&gt; 속성 에 의해 결정됩니다 . 기본적으로 ( &lt;code&gt;button&lt;/code&gt; 버튼 유형 에서 상속 된 &lt;code&gt;face&lt;/code&gt; 속성을 통해 ) 일반적인 웹 페이지 링크와 같은 간단한 밑줄입니다.</target>
        </trans-unit>
        <trans-unit id="91c7c66c2c1453401e19d50861895a10fdbd7d8e" translate="yes" xml:space="preserve">
          <source>By &lt;em&gt;separator&lt;/em&gt;, we mean here a token whose sole purpose is to separate various elements within some enclosing syntactic construct, and which does not have any semantic significance in itself (i.e., it would typically not exist as a node in an abstract syntax tree).</source>
          <target state="translated">으로 &lt;em&gt;구분&lt;/em&gt; , 우리는 여기에 그 목적 일부 둘러싸는 구문 구조 내에서 다양한 요소를 분리하는 것, 그 자체에 어떤 의미 론적 의미가없는 (즉, 그것은 일반적으로 추상 구문 트리의 노드로 존재하지 것이다) 토큰을 의미한다.</target>
        </trans-unit>
        <trans-unit id="1286985575cca5c62cde4a1b9229a630c85b3182" translate="yes" xml:space="preserve">
          <source>By contrast, a Lisp program can do insertion with inheritance or without, depending on the choice of insertion primitive. The ordinary text insertion functions, such as &lt;code&gt;insert&lt;/code&gt;, do not inherit any properties. They insert text with precisely the properties of the string being inserted, and no others. This is correct for programs that copy text from one context to another&amp;mdash;for example, into or out of the kill ring. To insert with inheritance, use the special primitives described in this section. Self-inserting characters inherit properties because they work using these primitives.</source>
          <target state="translated">대조적으로 Lisp 프로그램은 삽입 프리미티브의 선택에 따라 상속을 사용하거나 사용하지 않고 삽입을 수행 할 수 있습니다. &lt;code&gt;insert&lt;/code&gt; 와 같은 일반 텍스트 삽입 함수는 속성을 상속하지 않습니다. 삽입되는 문자열의 속성과 정확히 일치하는 텍스트를 삽입합니다. 이것은 한 컨텍스트에서 다른 컨텍스트로 텍스트를 복사하는 프로그램 (예 : 킬 링 안팎으로)에 적합합니다. 상속과 함께 삽입하려면이 섹션에서 설명하는 특수 기본 형식을 사용하십시오. 자체 삽입 문자는 이러한 기본 요소를 사용하여 작동하기 때문에 속성을 상속합니다.</target>
        </trans-unit>
        <trans-unit id="78d9ed9ffae62086921d390616b3fa2296925abd" translate="yes" xml:space="preserve">
          <source>By contrast, for an array of keyboard input characters (such as a key sequence), a vector may be necessary, because many keyboard input characters are outside the range that will fit in a string. See &lt;a href=&quot;key-sequence-input#Key-Sequence-Input&quot;&gt;Key Sequence Input&lt;/a&gt;.</source>
          <target state="translated">반대로 키보드 입력 문자 배열 (예 : 키 시퀀스)의 경우 많은 키보드 입력 문자가 문자열에 맞는 범위 밖에 있기 때문에 벡터가 필요할 수 있습니다. &lt;a href=&quot;key-sequence-input#Key-Sequence-Input&quot;&gt;키 시퀀스 입력을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="12144324278ff8b90e0a364f623b2e54380c481c" translate="yes" xml:space="preserve">
          <source>By contrast, in programs that manipulate function definitions for other purposes, it is better to use &lt;code&gt;fset&lt;/code&gt;, which does not keep such records. See &lt;a href=&quot;function-cells#Function-Cells&quot;&gt;Function Cells&lt;/a&gt;.</source>
          <target state="translated">대조적으로, 다른 목적으로 함수 정의를 조작하는 프로그램에서는 그러한 레코드를 유지하지 않는 &lt;code&gt;fset&lt;/code&gt; 을 사용하는 것이 좋습니다 . &lt;a href=&quot;function-cells#Function-Cells&quot;&gt;기능 셀을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e28b30f108e8c96578a3e1fc9b8f49f98c5c829d" translate="yes" xml:space="preserve">
          <source>By contrast, object-oriented programs use &lt;em&gt;polymorphic functions&lt;/em&gt;: a set of specialized functions having the same name, each one of which was written for a certain specific set of argument types. Which of the functions is actually called is decided at run time based on the types of the actual arguments.</source>
          <target state="translated">대조적으로, 객체 지향 프로그램은 &lt;em&gt;다형성 함수를&lt;/em&gt; 사용 &lt;em&gt;합니다&lt;/em&gt; . 동일한 이름을 가진 특수 함수 집합이며, 각 함수는 특정 특정 인수 유형 집합에 대해 작성되었습니다. 실제로 호출되는 함수는 실제 인수의 유형에 따라 런타임에 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="955d83a02806ccf2dfd155108f9d134b64fbc8d8" translate="yes" xml:space="preserve">
          <source>By contrast, the following example calls a function without any symbol function indirection, because the first element is an anonymous Lisp function, not a symbol.</source>
          <target state="translated">대조적으로, 다음 예제는 첫 번째 요소가 기호가 아닌 익명 Lisp 함수이기 때문에 기호 함수 간접 지정없이 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="90d9b7ac9f08bada9648d4c6e90292b9adc5f05d" translate="yes" xml:space="preserve">
          <source>By contrast, using only error symbols without condition names would seriously decrease the power of &lt;code&gt;condition-case&lt;/code&gt;. Condition names make it possible to categorize errors at various levels of generality when you write an error handler. Using error symbols alone would eliminate all but the narrowest level of classification.</source>
          <target state="translated">반대로 조건 이름없이 오류 기호 만 사용하면 &lt;code&gt;condition-case&lt;/code&gt; 의 힘이 크게 감소합니다 . 조건 이름을 사용하면 오류 처리기를 작성할 때 다양한 수준의 일반성에서 오류를 분류 할 수 있습니다. 오류 기호 만 사용하면 가장 좁은 수준의 분류를 제외하고 모두 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="c262827c2a008bc82000c720bb603706e79b1b54" translate="yes" xml:space="preserve">
          <source>By convention, any argument whose name contains the name of a type (e.g., &lt;var&gt;integer&lt;/var&gt;, &lt;var&gt;integer1&lt;/var&gt; or &lt;var&gt;buffer&lt;/var&gt;) is expected to be of that type. A plural of a type (such as &lt;var&gt;buffers&lt;/var&gt;) often means a list of objects of that type. An argument named &lt;var&gt;object&lt;/var&gt; may be of any type. (For a list of Emacs object types, see &lt;a href=&quot;lisp-data-types#Lisp-Data-Types&quot;&gt;Lisp Data Types&lt;/a&gt;.) An argument with any other sort of name (e.g., &lt;var&gt;new-file&lt;/var&gt;) is specific to the function; if the function has a documentation string, the type of the argument should be described there (see &lt;a href=&quot;documentation#Documentation&quot;&gt;Documentation&lt;/a&gt;).</source>
          <target state="translated">관례 적으로 이름에 유형의 이름 (예 : &lt;var&gt;integer&lt;/var&gt; , &lt;var&gt;integer1&lt;/var&gt; 또는 &lt;var&gt;buffer&lt;/var&gt; )이 포함 된 모든 인수 는 해당 유형이 될 것으로 예상됩니다. 복수형 (예 : &lt;var&gt;buffers&lt;/var&gt; )은 종종 해당 유형의 객체 목록을 의미합니다. &lt;var&gt;object&lt;/var&gt; 라는 인수 는 모든 유형이 될 수 있습니다. (Emacs 객체 유형 목록은 &lt;a href=&quot;lisp-data-types#Lisp-Data-Types&quot;&gt;Lisp 데이터 유형을&lt;/a&gt; 참조하십시오 .) 다른 종류의 이름 (예 : &lt;var&gt;new-file&lt;/var&gt; )을 가진 인수 는 함수에 고유합니다. 함수에 문서 문자열이있는 경우 인수 유형을 설명해야합니다 ( &lt;a href=&quot;documentation#Documentation&quot;&gt;문서&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="29edadc76625945d3e9732385f723229ac2c6358" translate="yes" xml:space="preserve">
          <source>By convention, if a function&amp;rsquo;s symbol consists of two names separated by &amp;lsquo;</source>
          <target state="translated">규칙에 따라 함수의 기호가 '로 구분 된 두 개의 이름으로 구성된 경우</target>
        </trans-unit>
        <trans-unit id="81288ed35b7f8aec4f961beebc97c447985deae4" translate="yes" xml:space="preserve">
          <source>By convention, the entries &lt;code&gt;window-height&lt;/code&gt;, &lt;code&gt;window-width&lt;/code&gt; and &lt;code&gt;preserve-size&lt;/code&gt; are applied after the chosen window&amp;rsquo;s buffer has been set up and if and only if that window never showed another buffer before. More precisely, the latter means that the window must have been either created by the current &lt;code&gt;display-buffer&lt;/code&gt; call or the window was created earlier by &lt;code&gt;display-buffer&lt;/code&gt; to show the buffer and never was used to show another buffer until it was reused by the current invocation of &lt;code&gt;display-buffer&lt;/code&gt;.</source>
          <target state="translated">관례 적으로 &lt;code&gt;window-height&lt;/code&gt; , &lt;code&gt;window-width&lt;/code&gt; 및 &lt;code&gt;preserve-size&lt;/code&gt; 항목 은 선택한 창의 버퍼가 설정된 후 적용되며 해당 창이 이전에 다른 버퍼를 표시 한 적이없는 경우에만 적용됩니다. 더 정확하게 말하면, 후자는 현재 &lt;code&gt;display-buffer&lt;/code&gt; 호출에 의해 창을 생성했거나 &lt;code&gt;display-buffer&lt;/code&gt; 를 표시하기 위해 디스플레이 버퍼 에 의해 더 일찍 창을 생성 했으며 현재가 재사용 할 때까지 다른 버퍼를 표시하는 데 사용되지 않았 음을 의미합니다. &lt;code&gt;display-buffer&lt;/code&gt; 호출 .</target>
        </trans-unit>
        <trans-unit id="961315a74279b10aa81793f8f190e6ad9e46b005" translate="yes" xml:space="preserve">
          <source>By convention, the height of the chosen window is adjusted only if the window is part of a vertical combination (see &lt;a href=&quot;windows-and-frames#Windows-and-Frames&quot;&gt;Windows and Frames&lt;/a&gt;) to avoid changing the height of other, unrelated windows. Also, this entry should be processed only under certain conditions which are specified right below this list.</source>
          <target state="translated">관례 적으로 선택한 창의 높이는 창이 수직 조합 ( &lt;a href=&quot;windows-and-frames#Windows-and-Frames&quot;&gt;창 및 프레임&lt;/a&gt; 참조)의 일부인 경우에만 조정 되어 관련되지 않은 다른 창의 높이를 변경하지 않도록합니다. 또한이 항목은이 목록 바로 아래에 지정된 특정 조건에서만 처리되어야합니다.</target>
        </trans-unit>
        <trans-unit id="46e87bdc0265fdf29ddfc65a07831e51565c646d" translate="yes" xml:space="preserve">
          <source>By convention, the pixels of the display at the values returned for &lt;var&gt;left&lt;/var&gt; and &lt;var&gt;top&lt;/var&gt; are considered to be inside (part of) &lt;var&gt;frame&lt;/var&gt;. Hence, if &lt;var&gt;left&lt;/var&gt; and &lt;var&gt;top&lt;/var&gt; are both zero, the pixel at the display&amp;rsquo;s origin is part of &lt;var&gt;frame&lt;/var&gt;. The pixels at &lt;var&gt;bottom&lt;/var&gt; and &lt;var&gt;right&lt;/var&gt;, on the other hand, are considered to lie immediately outside &lt;var&gt;frame&lt;/var&gt;. This means that if you have, for example, two side-by-side frames positioned such that the right outer edge of the frame on the left equals the left outer edge of the frame on the right, the pixels at that edge show a part of the frame on the right.</source>
          <target state="translated">관례 적으로 &lt;var&gt;left&lt;/var&gt; 및 &lt;var&gt;top&lt;/var&gt; 에 대해 반환 된 값의 디스플레이 픽셀은 &lt;var&gt;frame&lt;/var&gt; 내부 (일부)로 간주됩니다 . 따라서 &lt;var&gt;left&lt;/var&gt; 와 &lt;var&gt;top&lt;/var&gt; 이 모두 0이면 디스플레이 원점의 픽셀은 &lt;var&gt;frame&lt;/var&gt; 의 일부입니다 . 반면 &lt;var&gt;bottom&lt;/var&gt; 및 &lt;var&gt;right&lt;/var&gt; 의 픽셀은 &lt;var&gt;frame&lt;/var&gt; 바로 외부에있는 것으로 간주됩니다 . 즉, 예를 들어 왼쪽 프레임의 오른쪽 바깥 쪽 가장자리가 오른쪽 프레임의 왼쪽 바깥 쪽 가장자리와 같도록 두 개의 나란히 배치 된 프레임이있는 경우 해당 가장자리의 픽셀은 일부를 표시합니다. 오른쪽 프레임의</target>
        </trans-unit>
        <trans-unit id="6a4bd0ccbb65351d0542d9701b9e76e9ff39eb97" translate="yes" xml:space="preserve">
          <source>By convention, the width of the chosen window is adjusted only if the window is part of a horizontal combination (see &lt;a href=&quot;windows-and-frames#Windows-and-Frames&quot;&gt;Windows and Frames&lt;/a&gt;) to avoid changing the width of other, unrelated windows. Also, this entry should be processed under only certain conditions which are specified right below this list.</source>
          <target state="translated">관례 적으로 선택한 창의 너비는 창이 가로 조합 ( &lt;a href=&quot;windows-and-frames#Windows-and-Frames&quot;&gt;창 및 프레임&lt;/a&gt; 참조)의 일부인 경우에만 조정 되어 관련되지 않은 다른 창의 너비를 변경하지 않도록합니다. 또한이 항목은이 목록 바로 아래에 지정된 특정 조건에서만 처리되어야합니다.</target>
        </trans-unit>
        <trans-unit id="f1f59fea98d20db1b1e18d570c20cefba2dd601a" translate="yes" xml:space="preserve">
          <source>By convention, vertical offsets increase &amp;ldquo;downwards&amp;rdquo;. This means that the height of a frame is obtained by subtracting the offset of its top edge from that of its bottom edge. Horizontal offsets increase &amp;ldquo;rightwards&amp;rdquo;, as expected, so a frame&amp;rsquo;s width is calculated by subtracting the offset of its left edge from that of its right edge.</source>
          <target state="translated">관례 적으로 수직 오프셋은 &quot;아래로&quot;증가합니다. 즉, 프레임의 높이는 아래쪽 가장자리의 오프셋에서 위쪽 가장자리의 오프셋을 뺀 값입니다. 수평 오프셋은 예상대로 &quot;오른쪽으로&quot;증가하므로 프레임의 너비는 오른쪽 가장자리의 오프셋에서 왼쪽 가장자리의 오프셋을 빼서 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="5bc4ab559bcd3485770406aa3206099c2c318a03" translate="yes" xml:space="preserve">
          <source>By convention, when defining variables of a &amp;ldquo;native&amp;rdquo; type (&lt;code&gt;int&lt;/code&gt; and &lt;code&gt;bool&lt;/code&gt;), the name of the C variable is the name of the Lisp variable with &lt;code&gt;-&lt;/code&gt; replaced by &lt;code&gt;_&lt;/code&gt;. When the variable has type &lt;code&gt;Lisp_Object&lt;/code&gt;, the convention is to also prefix the C variable name with &lt;code&gt;V&lt;/code&gt;. i.e.</source>
          <target state="translated">는 &quot;원시&quot;타입 (변수 정의시의 규칙에 따라, &lt;code&gt;int&lt;/code&gt; 및 &lt;code&gt;bool&lt;/code&gt; )은 C 변수의 이름과 리스프 변수의 이름 &lt;code&gt;-&lt;/code&gt; 대체 &lt;code&gt;_&lt;/code&gt; 은 . 변수 유형이 &lt;code&gt;Lisp_Object&lt;/code&gt; 인 경우 규칙은 C 변수 이름 앞에 &lt;code&gt;V&lt;/code&gt; 를 추가하는 것 입니다. 즉</target>
        </trans-unit>
        <trans-unit id="0b42bb254be6d5ac55cc35f34239ee11afcaf79a" translate="yes" xml:space="preserve">
          <source>By convention, you should put the &lt;code&gt;interactive&lt;/code&gt; form in the function body, as the first top-level form. If there is an &lt;code&gt;interactive&lt;/code&gt; form in both the &lt;code&gt;interactive-form&lt;/code&gt; symbol property and the function body, the former takes precedence. The &lt;code&gt;interactive-form&lt;/code&gt; symbol property can be used to add an interactive form to an existing function, or change how its arguments are processed interactively, without redefining the function.</source>
          <target state="translated">관례에 따라 &lt;code&gt;interactive&lt;/code&gt; 양식을 첫 번째 최상위 양식으로 함수 본문에 넣어야합니다 . &lt;code&gt;interactive-form&lt;/code&gt; 심볼 속성과 함수 본문에 &lt;code&gt;interactive&lt;/code&gt; 형식 이있는 경우 전자가 우선합니다. &lt;code&gt;interactive-form&lt;/code&gt; 기호 속성 기능을 재정의 않고, 기존 기능에 양방향 형태의 추가 또는 인수 대화식 처리 방법을 변경하는 데 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="bd6cd1964a58199f17af10ed0710e7304dbef795" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; and &lt;code&gt;switch-to-next-buffer&lt;/code&gt; can switch to a buffer that is already shown in another window. The following option can be used to override this behavior.</source>
          <target state="translated">기본적 &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; 로 &lt;code&gt;switch-to-next-buffer&lt;/code&gt; 및 다음 버퍼로 전환은 이미 다른 창에 표시된 버퍼로 전환 할 수 있습니다. 다음 옵션을 사용하여이 동작을 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2e5b9fa592a3409a2011f26d6c0a6701c7e5da1" translate="yes" xml:space="preserve">
          <source>By default both IPv4 and IPv6 lookups are attempted. The optional argument &lt;var&gt;family&lt;/var&gt; controls this behavior, specifying the symbol &lt;code&gt;ipv4&lt;/code&gt; or &lt;code&gt;ipv6&lt;/code&gt; restricts lookups to IPv4 and IPv6 respectively.</source>
          <target state="translated">기본적으로 IPv4 및 IPv6 조회가 모두 시도됩니다. 선택적 인수 &lt;var&gt;family&lt;/var&gt; 은이 동작을 제어하고, 기호 &lt;code&gt;ipv4&lt;/code&gt; 또는 &lt;code&gt;ipv6&lt;/code&gt; 을 지정하면 각각 IPv4 및 IPv6로 조회를 제한합니다.</target>
        </trans-unit>
        <trans-unit id="af6f338f5f9982890241460392dfd56c79820ad8" translate="yes" xml:space="preserve">
          <source>By default the dumped</source>
          <target state="translated">기본적으로 덤프</target>
        </trans-unit>
        <trans-unit id="ec8b6ebd7649499745ebeafd06ed0b949a38dabd" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;eval-region&lt;/code&gt; does not produce any output. However, if &lt;var&gt;stream&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, any output produced by output functions (see &lt;a href=&quot;output-functions#Output-Functions&quot;&gt;Output Functions&lt;/a&gt;), as well as the values that result from evaluating the expressions in the region are printed using &lt;var&gt;stream&lt;/var&gt;. See &lt;a href=&quot;output-streams#Output-Streams&quot;&gt;Output Streams&lt;/a&gt;.</source>
          <target state="translated">기본적으로 &lt;code&gt;eval-region&lt;/code&gt; 은 출력을 생성하지 않습니다. 그러나 &lt;var&gt;stream&lt;/var&gt; 이 &lt;code&gt;nil&lt;/code&gt; 이 아니면 출력 함수 ( &lt;a href=&quot;output-functions#Output-Functions&quot;&gt;Output Functions&lt;/a&gt; 참조)에 의해 생성 된 모든 출력 과 해당 영역의 표현식을 평가 한 결과 값이 &lt;var&gt;stream&lt;/var&gt; 을 사용하여 인쇄됩니다 . &lt;a href=&quot;output-streams#Output-Streams&quot;&gt;출력 스트림을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a53473f0b03225bb59517eff6e8b663daa1b7774" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;switch-to-buffer&lt;/code&gt; tries to preserve &lt;code&gt;window-point&lt;/code&gt;. This behavior can be tuned using the following option.</source>
          <target state="translated">기본적 &lt;code&gt;switch-to-buffer&lt;/code&gt; &lt;code&gt;window-point&lt;/code&gt; 를 유지하려고합니다 . 이 동작은 다음 옵션을 사용하여 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee1412f6a4896bbf8989a04623bf820b553fdea4" translate="yes" xml:space="preserve">
          <source>By default, &lt;var&gt;keywords&lt;/var&gt; are added at the beginning of &lt;code&gt;font-lock-keywords&lt;/code&gt;. If the optional argument &lt;var&gt;how&lt;/var&gt; is &lt;code&gt;set&lt;/code&gt;, they are used to replace the value of &lt;code&gt;font-lock-keywords&lt;/code&gt;. If &lt;var&gt;how&lt;/var&gt; is any other non-&lt;code&gt;nil&lt;/code&gt; value, they are added at the end of &lt;code&gt;font-lock-keywords&lt;/code&gt;.</source>
          <target state="translated">기본적으로 &lt;var&gt;keywords&lt;/var&gt; 는 &lt;code&gt;font-lock-keywords&lt;/code&gt; 시작 부분에 추가됩니다 . 선택적 인수 &lt;var&gt;how&lt;/var&gt; 가 &lt;code&gt;set&lt;/code&gt; 되면 &lt;code&gt;font-lock-keywords&lt;/code&gt; 값을 대체하는 데 사용됩니다 . &lt;code&gt;nil&lt;/code&gt; 이 아닌 다른 값 이 &lt;var&gt;how&lt;/var&gt; 다면 &lt;code&gt;font-lock-keywords&lt;/code&gt; 끝에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="10521942e8c52f15b21a03de5615c1566c427141" translate="yes" xml:space="preserve">
          <source>By default, Emacs determines the base direction of each paragraph by looking at the text at its beginning. The precise method of determining the base direction is specified by the</source>
          <target state="translated">기본적으로 Emacs는 시작 부분의 텍스트를보고 각 단락의 기준 방향을 결정합니다. 기준 방향을 결정하는 정확한 방법은</target>
        </trans-unit>
        <trans-unit id="d9bc871638c9fc2d81d98a2b4d5d096f7d797fd7" translate="yes" xml:space="preserve">
          <source>By default, Emacs makes a single backup file for each file edited. You can alternatively request numbered backups; then each new backup file gets a new name. You can delete old numbered backups when you don&amp;rsquo;t want them any more, or Emacs can delete them automatically.</source>
          <target state="translated">기본적으로 Emacs는 편집 된 각 파일에 대해 단일 백업 파일을 만듭니다. 또는 번호가 매겨진 백업을 요청할 수 있습니다. 그러면 각각의 새 백업 파일이 새 이름을 갖게됩니다. 더 이상 원하지 않는 이전 번호 백업을 삭제하거나 Emacs에서 자동으로 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb5fb3e174ce7ebaa56506756450880c9f6707f5" translate="yes" xml:space="preserve">
          <source>By default, Emacs starts in multibyte mode: it stores the contents of buffers and strings using an internal encoding that represents non-</source>
          <target state="translated">기본적으로 Emacs는 멀티 바이트 모드로 시작합니다. 비를 나타내는 내부 인코딩을 사용하여 버퍼와 문자열의 내용을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="2439b1b4fb24aa8804e6e4ef3da82558ce16fc14" translate="yes" xml:space="preserve">
          <source>By default, Emacs tries to keep the number of lines and columns of a frame&amp;rsquo;s text area unaltered when, for example, toggling its menu or tool bar, changing its default font or setting the width of any of its scroll bars. This means that in such case Emacs must ask the window manager to resize the frame&amp;rsquo;s window in order to accommodate the size change.</source>
          <target state="translated">기본적으로 Emacs는 메뉴 또는 도구 모음을 전환하거나 기본 글꼴을 변경하거나 스크롤 막대의 너비를 설정하는 경우와 같이 프레임의 텍스트 영역의 행과 열 수를 변경하지 않으려 고합니다. 이것은 이러한 경우에 Emacs는 크기 변경을 수용하기 위해 창 관리자에게 프레임의 창 크기를 조정하도록 요청해야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="c3302471f75eaf89ac88db46d17c6df0b07bc2a8" translate="yes" xml:space="preserve">
          <source>By default, a text property is rear-sticky but not front-sticky; thus, the default is to inherit all the properties of the preceding character, and nothing from the following character.</source>
          <target state="translated">기본적으로 텍스트 속성은 후면 고정이지만 전면 고정은 아닙니다. 따라서 기본값은 선행 문자의 모든 속성을 상속하고 다음 문자에서는 아무것도 상속하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b6bdb814df1ff8f4484bd14e8665079dde59b196" translate="yes" xml:space="preserve">
          <source>By default, all subdirectories are descended into. If &lt;var&gt;predicate&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;, errors when trying to descend into a subdirectory (for instance, if it&amp;rsquo;s not readable by this user) are ignored. If it&amp;rsquo;s neither &lt;code&gt;nil&lt;/code&gt; nor &lt;code&gt;t&lt;/code&gt;, it should be a function that takes one parameter (the subdirectory name) and should return non-&lt;code&gt;nil&lt;/code&gt; if the directory is to be descended into.</source>
          <target state="translated">기본적으로 모든 하위 디렉터리는 아래로 내려갑니다. 경우 &lt;var&gt;predicate&lt;/var&gt; 있다 &lt;code&gt;t&lt;/code&gt; (이것은이 사용자가 읽을 아니라면, 예를 들어) 하위 디렉토리로 내려하려고 할 때 오류가 무시됩니다. &lt;code&gt;nil&lt;/code&gt; 도 &lt;code&gt;t&lt;/code&gt; 도 아닌 경우 하나의 매개 변수 (하위 디렉토리 이름)를 취하는 함수 여야 하며 디렉토리가 &lt;code&gt;nil&lt;/code&gt; 경우 nil 이 아닌 값을 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="34620b2db91cbe790eb8b807c0d8c806964cdff3" translate="yes" xml:space="preserve">
          <source>By default, format specifications correspond to successive values from &lt;var&gt;objects&lt;/var&gt;. Thus, the first format specification in &lt;var&gt;string&lt;/var&gt; uses the first such value, the second format specification uses the second such value, and so on. Any extra format specifications (those for which there are no corresponding values) cause an error. Any extra values to be formatted are ignored.</source>
          <target state="translated">기본적으로 형식 사양은 &lt;var&gt;objects&lt;/var&gt; 연속 값에 해당 합니다 . 따라서 &lt;var&gt;string&lt;/var&gt; 의 첫 번째 형식 사양 은 첫 번째 값을 사용하고 두 번째 형식 사양은 두 번째 값을 사용하는 식입니다. 추가 형식 사양 (해당 값이없는 사양)은 오류를 발생시킵니다. 형식화 할 추가 값은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="cfab6cab0b08bc4c2da07991fa913322ec8175a9" translate="yes" xml:space="preserve">
          <source>By default, frame parameters are saved and restored by the desktop library functions (see &lt;a href=&quot;desktop-save-mode#Desktop-Save-Mode&quot;&gt;Desktop Save Mode&lt;/a&gt;) when the variable &lt;code&gt;desktop-restore-frames&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;. It&amp;rsquo;s the responsibility of applications that their parameters are included in &lt;code&gt;frameset-persistent-filter-alist&lt;/code&gt; to avoid that they get meaningless or even harmful values in restored sessions.</source>
          <target state="translated">기본적으로, 프레임 매개 변수는 &lt;code&gt;desktop-restore-frames&lt;/code&gt; 변수 가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 데스크탑 라이브러리 기능 ( &lt;a href=&quot;desktop-save-mode#Desktop-Save-Mode&quot;&gt;데스크탑 저장 모드&lt;/a&gt; 참조)에 의해 저장 및 복원됩니다 . 복원 된 세션에서 무의미하거나 해로운 값을 얻는 것을 방지하기 위해 해당 매개 변수가 &lt;code&gt;frameset-persistent-filter-alist&lt;/code&gt; 에 포함되는 것은 애플리케이션의 책임입니다 .</target>
        </trans-unit>
        <trans-unit id="4ff08fda735af5f6543bdd7e51226e1a37b99336" translate="yes" xml:space="preserve">
          <source>By default, if the latest auto-save file is more recent than the visited file, and the argument &lt;var&gt;ignore-auto&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;revert-buffer&lt;/code&gt; asks the user whether to use that auto-save instead. When you invoke this command interactively, &lt;var&gt;ignore-auto&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt; if there is no numeric prefix argument; thus, the interactive default is not to check the auto-save file.</source>
          <target state="translated">기본적으로 최신 자동 저장 파일이 방문한 파일보다 최신이고 &lt;var&gt;ignore-auto&lt;/var&gt; 인수 가 &lt;code&gt;nil&lt;/code&gt; 인 경우 &lt;code&gt;revert-buffer&lt;/code&gt; 는 사용자에게 자동 저장을 대신 사용할 것인지 묻습니다. 이 명령을 대화식으로 호출 할 때 숫자 접두사 인수가 없으면 &lt;var&gt;ignore-auto&lt;/var&gt; 는 &lt;code&gt;t&lt;/code&gt; 입니다 . 따라서 대화식 기본값은 자동 저장 파일을 확인하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2816188a5a0e8a3ed928cd480d7464b05373951a" translate="yes" xml:space="preserve">
          <source>By default, it also defines a variable named &lt;var&gt;mode&lt;/var&gt;, which is set to &lt;code&gt;t&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt; by enabling or disabling the mode. The variable is initialized to &lt;var&gt;init-value&lt;/var&gt;. Except in unusual circumstances (see below), this value must be &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">기본적으로 &lt;var&gt;mode&lt;/var&gt; 라는 변수도 정의하며 , 모드 를 활성화하거나 비활성화하여 &lt;code&gt;t&lt;/code&gt; 또는 &lt;code&gt;nil&lt;/code&gt; 로 설정됩니다. 변수는 &lt;var&gt;init-value&lt;/var&gt; 로 초기화됩니다 . 비정상적인 상황 (아래 참조)을 제외하고이 값은 &lt;code&gt;nil&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="1adc609228685b29696e0ff7e75061c83ffb5bde" translate="yes" xml:space="preserve">
          <source>By default, output is put in a buffer.</source>
          <target state="translated">기본적으로 출력은 버퍼에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="410cbb685716930dfd39abc9cbf65a643f166d48" translate="yes" xml:space="preserve">
          <source>By default, process output is inserted in the associated buffer. (You can change this by defining a custom filter function, see &lt;a href=&quot;filter-functions#Filter-Functions&quot;&gt;Filter Functions&lt;/a&gt;.) The position to insert the output is determined by the &lt;code&gt;process-mark&lt;/code&gt;, which is then updated to point to the end of the text just inserted. Usually, but not always, the &lt;code&gt;process-mark&lt;/code&gt; is at the end of the buffer.</source>
          <target state="translated">기본적으로 프로세스 출력은 연관된 버퍼에 삽입됩니다. (사용자가 볼 맞춤 필터 함수를 정의하여이를 변경할 수있는 &lt;a href=&quot;filter-functions#Filter-Functions&quot;&gt;필터 기능&lt;/a&gt; .)에 의해 결정되는 출력 삽입 위치 &lt;code&gt;process-mark&lt;/code&gt; 다음 단지 삽입 된 텍스트의 끝을 가리 키도록 업데이트된다. 항상 그런 것은 아니지만 일반적으로 &lt;code&gt;process-mark&lt;/code&gt; 는 버퍼의 끝에 있습니다.</target>
        </trans-unit>
        <trans-unit id="f08b23f065e4db8b7e347aa8e9d5f1dfa79f259d" translate="yes" xml:space="preserve">
          <source>By default, searches in Emacs ignore the case of the text they are searching through; if you specify searching for &amp;lsquo;</source>
          <target state="translated">기본적으로 Emacs의 검색은 검색중인 텍스트의 대소 문자를 무시합니다. '검색을 지정하는 경우</target>
        </trans-unit>
        <trans-unit id="1fd764f8ebd1a38813dea49832550f50112ed16b" translate="yes" xml:space="preserve">
          <source>By default, side windows cannot be split via &lt;code&gt;split-window&lt;/code&gt; (see &lt;a href=&quot;splitting-windows#Splitting-Windows&quot;&gt;Splitting Windows&lt;/a&gt;). Also, a side window is not reused or split by any buffer display action (see &lt;a href=&quot;buffer-display-action-functions#Buffer-Display-Action-Functions&quot;&gt;Buffer Display Action Functions&lt;/a&gt;) unless it is explicitly specified as target of that action. Note also that &lt;code&gt;delete-other-windows&lt;/code&gt; cannot make a side window the only window on its frame (see &lt;a href=&quot;deleting-windows#Deleting-Windows&quot;&gt;Deleting Windows&lt;/a&gt;).</source>
          <target state="translated">기본적으로 측면 창은 &lt;code&gt;split-window&lt;/code&gt; 통해 분할 할 수 없습니다 ( 창 &lt;a href=&quot;splitting-windows#Splitting-Windows&quot;&gt;분할&lt;/a&gt; 참조 ). 또한 사이드 윈도우는 해당 액션의 대상으로 명시 적으로 지정되지 않는 한 버퍼 디스플레이 액션 ( &lt;a href=&quot;buffer-display-action-functions#Buffer-Display-Action-Functions&quot;&gt;버퍼 디스플레이 액션 함수&lt;/a&gt; 참조)에 의해 재사용되거나 분할되지 않습니다 . 또한 &lt;code&gt;delete-other-windows&lt;/code&gt; 는 측면 창을 프레임의 유일한 창으로 만들 수 없습니다 (창 &lt;a href=&quot;deleting-windows#Deleting-Windows&quot;&gt;삭제&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="337f680b05ae479de5bb330579bb081a7cad8c38" translate="yes" xml:space="preserve">
          <source>By default, the error output from the process, if any, is also passed to the filter function, unless the destination for the standard error stream of the process was separated from the standard output when the process was created. Emacs will only call the filter function during certain function calls. See &lt;a href=&quot;output-from-processes#Output-from-Processes&quot;&gt;Output from Processes&lt;/a&gt;. Note that if any of those functions are called by the filter, the filter may be called recursively.</source>
          <target state="translated">기본적으로 프로세스의 표준 오류 스트림에 대한 대상이 프로세스가 생성 될 때 표준 출력과 분리되지 않은 경우 프로세스의 오류 출력 (있는 경우)도 필터 함수로 전달됩니다. Emacs는 특정 함수 호출 중에 만 필터 함수를 호출합니다. &lt;a href=&quot;output-from-processes#Output-from-Processes&quot;&gt;프로세스의 출력을&lt;/a&gt; 참조하십시오 . 이러한 함수 중 하나가 필터에 의해 호출되면 필터가 재귀 적으로 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06b7d4e5494854a61c5e08ae9fc06e3dd1a74a05" translate="yes" xml:space="preserve">
          <source>By default, the functions that save and restore window configurations or the states of windows (see &lt;a href=&quot;window-configurations#Window-Configurations&quot;&gt;Window Configurations&lt;/a&gt;) do not care about window parameters. This means that when you change the value of a parameter within the body of a &lt;code&gt;save-window-excursion&lt;/code&gt;, the previous value is not restored when that macro exits. It also means that when you restore via &lt;code&gt;window-state-put&lt;/code&gt; a window state saved earlier by &lt;code&gt;window-state-get&lt;/code&gt;, all cloned windows have their parameters reset to &lt;code&gt;nil&lt;/code&gt;. The following variable allows you to override the standard behavior:</source>
          <target state="translated">기본적으로 창 구성 또는 창 상태를 저장하고 복원하는 기능 ( &lt;a href=&quot;window-configurations#Window-Configurations&quot;&gt;창 구성&lt;/a&gt; 참조 )은 창 매개 변수에 대해 신경 쓰지 않습니다. 즉, &lt;code&gt;save-window-excursion&lt;/code&gt; 본문 내에서 매개 변수 값을 변경 하면 해당 매크로가 종료 될 때 이전 값이 복원되지 않습니다. 또한 &lt;code&gt;window-state-put&lt;/code&gt; 을 통해 이전에 &lt;code&gt;window-state-get&lt;/code&gt; 에 의해 저장된 창 상태 를 복원 할 때 모든 복제 된 창은 매개 변수가 &lt;code&gt;nil&lt;/code&gt; 로 재설정됩니다 . 다음 변수를 사용하면 표준 동작을 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42d60f64d2f3044aeab0d538900375a76783a13e" translate="yes" xml:space="preserve">
          <source>By default, the global map binds &lt;code&gt;[tool-bar]&lt;/code&gt; as follows:</source>
          <target state="translated">기본적으로 전역 맵은 다음과 같이 &lt;code&gt;[tool-bar]&lt;/code&gt; 을 바인딩 합니다.</target>
        </trans-unit>
        <trans-unit id="7273860db2763e093bd47c6c91c3aff5ba16714f" translate="yes" xml:space="preserve">
          <source>By default, the local bindings that Emacs creates are &lt;em&gt;dynamic bindings&lt;/em&gt;. Such a binding has &lt;em&gt;dynamic scope&lt;/em&gt;, meaning that any part of the program can potentially access the variable binding. It also has &lt;em&gt;dynamic extent&lt;/em&gt;, meaning that the binding lasts only while the binding construct (such as the body of a &lt;code&gt;let&lt;/code&gt; form) is being executed.</source>
          <target state="translated">기본적으로 Emacs가 생성하는 로컬 바인딩은 &lt;em&gt;동적 바인딩&lt;/em&gt; 입니다. 이러한 바인딩에는 &lt;em&gt;동적 범위가&lt;/em&gt; 있으며 이는 프로그램의 모든 부분이 잠재적으로 변수 바인딩에 액세스 할 수 있음을 의미합니다. 또한 &lt;em&gt;동적 범위가 있습니다&lt;/em&gt; . 즉, 바인딩 구문 (예 : &lt;code&gt;let&lt;/code&gt; 양식 의 본문 )이 실행되는 동안에 만 바인딩이 지속됩니다 .</target>
        </trans-unit>
        <trans-unit id="fd1815fd5a5c0fb02829db09a71557be08961cdb" translate="yes" xml:space="preserve">
          <source>By default, the local variable bindings made by Emacs are dynamic bindings. When a variable is dynamically bound, its current binding at any point in the execution of the Lisp program is simply the most recently-created dynamic local binding for that symbol, or the global binding if there is no such local binding.</source>
          <target state="translated">기본적으로 Emacs에서 만든 로컬 변수 바인딩은 동적 바인딩입니다. 변수가 동적으로 바인딩되면 Lisp 프로그램 실행 중 어느 시점에서든 현재 바인딩은 해당 심볼에 대해 가장 최근에 생성 된 동적 로컬 바인딩이거나 그러한 로컬 바인딩이없는 경우 전역 바인딩입니다.</target>
        </trans-unit>
        <trans-unit id="47f31a9758da1b80f09abc18f1231cee612e7b61" translate="yes" xml:space="preserve">
          <source>By default, the range of codepoints passed to &lt;var&gt;function&lt;/var&gt; includes all the characters in &lt;var&gt;charset&lt;/var&gt;, but optional arguments &lt;var&gt;from-code&lt;/var&gt; and &lt;var&gt;to-code&lt;/var&gt; limit that to the range of characters between these two codepoints of &lt;var&gt;charset&lt;/var&gt;. If either of them is &lt;code&gt;nil&lt;/code&gt;, it defaults to the first or last codepoint of &lt;var&gt;charset&lt;/var&gt;, respectively.</source>
          <target state="translated">기본적으로 &lt;var&gt;function&lt;/var&gt; 에 전달되는 코드 포인트 범위 에는 &lt;var&gt;charset&lt;/var&gt; 의 모든 문자가 포함 되지만 선택적 인수 &lt;var&gt;from-code&lt;/var&gt; 및 &lt;var&gt;to-code&lt;/var&gt; 는 &lt;var&gt;charset&lt;/var&gt; 의 두 코드 포인트 사이의 문자 범위로 제한합니다 . 둘 중 하나가 &lt;code&gt;nil&lt;/code&gt; 이면 각각 &lt;var&gt;charset&lt;/var&gt; 의 첫 번째 또는 마지막 코드 포인트가 기본값 입니다.</target>
        </trans-unit>
        <trans-unit id="3d1494bcaafdc3c540ef160a9f8e6f65dd4261e3" translate="yes" xml:space="preserve">
          <source>By default, the space taken up by &lt;var&gt;window&lt;/var&gt; is given to one of its adjacent sibling windows, if any. However, if the variable &lt;code&gt;window-combination-resize&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the space is proportionally distributed among any remaining windows in the same window combination. See &lt;a href=&quot;recombining-windows#Recombining-Windows&quot;&gt;Recombining Windows&lt;/a&gt;.</source>
          <target state="translated">기본적으로 &lt;var&gt;window&lt;/var&gt; 차지하는 공간 은 인접한 형제 창 중 하나 (있는 경우)에 제공됩니다. 그러나 &lt;code&gt;window-combination-resize&lt;/code&gt; 변수 가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 동일한 창 조합의 나머지 창간 에 공간이 비례 적으로 분산됩니다. &lt;a href=&quot;recombining-windows#Recombining-Windows&quot;&gt;Windows 재결합을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f1defe0245424aab283006a635faaa0b360d0c56" translate="yes" xml:space="preserve">
          <source>By default, the value is a function that asks the user whether to proceed.</source>
          <target state="translated">기본적으로 값은 사용자에게 진행 여부를 묻는 기능입니다.</target>
        </trans-unit>
        <trans-unit id="6d7d2b01d1d4f6143cd45dbac4779e0cc9e9e7c9" translate="yes" xml:space="preserve">
          <source>By default, the values are integers that are 100 times the system load averages, but if &lt;var&gt;use-float&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then they are returned as floating-point numbers without multiplying by 100.</source>
          <target state="translated">기본적으로 값은 시스템 부하 평균의 100 배인 정수이지만 &lt;var&gt;use-float&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 100을 곱하지 않고 부동 소수점 숫자로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e561fba1f476b09361515566e3c64701551c6912" translate="yes" xml:space="preserve">
          <source>By default, this alist contains one entry with the key &lt;code&gt;edebug&lt;/code&gt; and a list of three functions, which are the default implementations of the functions inserted in instrumented code: &lt;code&gt;edebug-enter&lt;/code&gt;, &lt;code&gt;edebug-before&lt;/code&gt; and &lt;code&gt;edebug-after&lt;/code&gt;. To change Edebug&amp;rsquo;s behavior globally, modify the default entry.</source>
          <target state="translated">기본적으로이 목록에는 &lt;code&gt;edebug&lt;/code&gt; 키가있는 항목 하나와 계측 된 코드에 삽입 된 함수의 기본 구현 인 &lt;code&gt;edebug-enter&lt;/code&gt; , &lt;code&gt;edebug-before&lt;/code&gt; 및 &lt;code&gt;edebug-after&lt;/code&gt; 가있는 세 가지 함수 목록이 포함됩니다 . Edebug의 동작을 전역 적으로 변경하려면 기본 항목을 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="a30c2c9f6f69702d4744ebbd4fe0caff5ca90a07" translate="yes" xml:space="preserve">
          <source>By default, this function also moves &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s buffer to the front of the buffer list (see &lt;a href=&quot;buffer-list#Buffer-List&quot;&gt;Buffer List&lt;/a&gt;) and makes &lt;var&gt;window&lt;/var&gt; the most recently selected window. If the optional argument &lt;var&gt;norecord&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, these additional actions are omitted.</source>
          <target state="translated">기본적으로이 기능은 또한 이동 &lt;var&gt;window&lt;/var&gt; 버퍼 목록의 앞에의 버퍼 (참조 &lt;a href=&quot;buffer-list#Buffer-List&quot;&gt;버퍼 목록&lt;/a&gt; ) 및하게 &lt;var&gt;window&lt;/var&gt; 가장 최근에 선택한 창을여십시오. 선택적 인수 &lt;var&gt;norecord&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 이러한 추가 작업이 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="314e04d83201875669bd5820e278b79ec5e410e1" translate="yes" xml:space="preserve">
          <source>By default, this function resets &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s position, display margins, fringe widths, and scroll bar settings, based on the local variables in the specified buffer. However, if the optional argument &lt;var&gt;keep-margins&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it leaves &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s display margins, fringes and scroll bar settings alone.</source>
          <target state="translated">기본적으로이 함수 는 지정된 버퍼의 로컬 변수를 기반으로 &lt;var&gt;window&lt;/var&gt; 위치, 표시 여백, 가장자리 너비 및 스크롤 막대 설정을 재설정합니다. 그러나 선택적 인수 &lt;var&gt;keep-margins&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 &lt;var&gt;window&lt;/var&gt; 디스플레이 여백, 가장자리 및 스크롤 막대 설정 만 남깁니다 .</target>
        </trans-unit>
        <trans-unit id="c8d7822491c87018aaf653bdc89135199d35d678" translate="yes" xml:space="preserve">
          <source>By default, this variable is always set to &lt;code&gt;t&lt;/code&gt;, meaning that a call of &lt;code&gt;process-file&lt;/code&gt; could potentially change any file on a remote host. When set to &lt;code&gt;nil&lt;/code&gt;, a file name handler could optimize its behavior with respect to remote file attribute caching.</source>
          <target state="translated">기본적으로이 변수는 항상 &lt;code&gt;t&lt;/code&gt; 로 설정됩니다 . 즉, &lt;code&gt;process-file&lt;/code&gt; 호출이 원격 호스트의 모든 파일을 잠재적으로 변경할 수 있음을 의미합니다 . &lt;code&gt;nil&lt;/code&gt; 로 설정 하면 파일 이름 처리기가 원격 파일 속성 캐싱과 관련하여 동작을 최적화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe49d9f104dc3f50cf901776febad4cfc3162c78" translate="yes" xml:space="preserve">
          <source>By default, this variable&amp;rsquo;s value is &lt;code&gt;read&lt;/code&gt;. See &lt;a href=&quot;input-functions#Input-Functions&quot;&gt;Input Functions&lt;/a&gt;.</source>
          <target state="translated">기본적으로이 변수의 값은 &lt;code&gt;read&lt;/code&gt; 입니다. &lt;a href=&quot;input-functions#Input-Functions&quot;&gt;입력 함수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c2688defb0c98a25897334d05cea4581b8ab7493" translate="yes" xml:space="preserve">
          <source>By design, action functions are free in their interpretation of action alist entries. In fact, some entries like &lt;code&gt;allow-no-window&lt;/code&gt; or &lt;code&gt;previous-window&lt;/code&gt; have a meaning only for one or a few action functions, and are ignored by the rest. Other entries, like &lt;code&gt;inhibit-same-window&lt;/code&gt; or &lt;code&gt;window-parameters&lt;/code&gt;, are supposed to be respected by most action functions, including those provided by application programs and external packages.</source>
          <target state="translated">설계 상, 액션 함수는 액션 목록 항목의 해석에서 자유 롭습니다. 사실, &lt;code&gt;allow-no-window&lt;/code&gt; 또는 &lt;code&gt;previous-window&lt;/code&gt; 와 같은 일부 항목 은 하나 또는 몇 개의 작업 기능에만 의미가 있으며 나머지는 무시됩니다. &lt;code&gt;inhibit-same-window&lt;/code&gt; 또는 &lt;code&gt;window-parameters&lt;/code&gt; 와 같은 다른 항목 은 응용 프로그램 및 외부 패키지에서 제공하는 기능을 포함하여 대부분의 작업 기능에서 존중되어야합니다.</target>
        </trans-unit>
        <trans-unit id="5df52f7953c9e1e23b06b07d93d36bf7c4082b84" translate="yes" xml:space="preserve">
          <source>By design, operations to make or modify child frames are implemented with the help of frame parameters (see &lt;a href=&quot;frame-parameters#Frame-Parameters&quot;&gt;Frame Parameters&lt;/a&gt;) without any specialized functions or customizable variables. Note that child frames are meaningful on graphical terminals only.</source>
          <target state="translated">설계 상 하위 프레임을 만들거나 수정하는 작업은 특수 함수 나 사용자 정의 가능한 변수없이 &lt;a href=&quot;frame-parameters#Frame-Parameters&quot;&gt;프레임 매개&lt;/a&gt; 변수 (프레임 매개 변수 참조 )를 사용하여 구현됩니다 . 자식 프레임은 그래픽 터미널에서만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc5e006af20582138d39d0ef5f207bc52db0c4b3" translate="yes" xml:space="preserve">
          <source>By editing the buffer in place. In this case, &lt;var&gt;to-fn&lt;/var&gt; should return the end-position of the range of text, as modified.</source>
          <target state="translated">제자리에서 버퍼를 편집합니다. 이 경우 &lt;var&gt;to-fn&lt;/var&gt; 은 수정 된대로 텍스트 범위의 끝 위치를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="63b5c76c72ae22fa7a5d14c68660da304cacecaf" translate="yes" xml:space="preserve">
          <source>By returning a list of annotations. This is a list of elements of the form &lt;code&gt;(&lt;var&gt;position&lt;/var&gt; . &lt;var&gt;string&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;position&lt;/var&gt; is an integer specifying the relative position in the text to be written, and &lt;var&gt;string&lt;/var&gt; is the annotation to add there. The list must be sorted in order of position when &lt;var&gt;to-fn&lt;/var&gt; returns it.</source>
          <target state="translated">주석 목록을 반환합니다. 이것은 &lt;code&gt;(&lt;var&gt;position&lt;/var&gt; . &lt;var&gt;string&lt;/var&gt;)&lt;/code&gt; 형식의 요소 목록입니다 . 여기서 &lt;var&gt;position&lt;/var&gt; 은 기록 할 텍스트의 상대 위치를 지정하는 정수이고 &lt;var&gt;string&lt;/var&gt; 은 추가 할 주석입니다. 목록은 &lt;var&gt;to-fn&lt;/var&gt; 이 반환 할 때 위치 순서대로 정렬되어야 합니다.</target>
        </trans-unit>
        <trans-unit id="b9df056fb7a4026d67a3485fe6622bd0ac5e4705" translate="yes" xml:space="preserve">
          <source>By setting the &lt;var&gt;action&lt;/var&gt; argument, an application effectively overrules any customization of &lt;code&gt;display-buffer-base-action&lt;/code&gt;. Our user can now either accept the choice of the application, or redouble by customizing the option &lt;code&gt;display-buffer-alist&lt;/code&gt; as follows:</source>
          <target state="translated">&lt;var&gt;action&lt;/var&gt; 인수 를 설정하면 애플리케이션이 &lt;code&gt;display-buffer-base-action&lt;/code&gt; 의 모든 사용자 정의를 효과적으로 무시합니다 . 사용자는 이제 응용 프로그램의 선택을 수락하거나 다음과 같이 &lt;code&gt;display-buffer-alist&lt;/code&gt; 옵션을 사용자 지정하여 두 배로 늘릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d82e754d3481447db663d32552753c526295b30" translate="yes" xml:space="preserve">
          <source>Byte Compilation</source>
          <target state="translated">바이트 컴파일</target>
        </trans-unit>
        <trans-unit id="38293ea2f575b674a58092e2860f65e375cf569f" translate="yes" xml:space="preserve">
          <source>Byte compilation functions.</source>
          <target state="translated">바이트 컴파일 기능.</target>
        </trans-unit>
        <trans-unit id="05bc2b18f50e1c59ce5be83b3a043fed7d8464a5" translate="yes" xml:space="preserve">
          <source>Byte compiler warnings can be controlled more precisely by setting the variable &lt;code&gt;byte-compile-warnings&lt;/code&gt;. See its documentation string for details.</source>
          <target state="translated">바이트 컴파일러 경고는 변수 &lt;code&gt;byte-compile-warnings&lt;/code&gt; 를 설정하여보다 정확하게 제어 할 수 있습니다 . 자세한 내용은 설명서 문자열을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="30c3dfd8676a2b612dc32e5e0e6e366336cdb1d2" translate="yes" xml:space="preserve">
          <source>Byte-Code Function Objects</source>
          <target state="translated">바이트 코드 함수 객체</target>
        </trans-unit>
        <trans-unit id="11dfd8a56350515cd4673e500974d1d76f92ac16" translate="yes" xml:space="preserve">
          <source>Byte-Code Function Type</source>
          <target state="translated">바이트 코드 함수 유형</target>
        </trans-unit>
        <trans-unit id="59fecc0a37710dd91bf58606dfa13b25c3069f87" translate="yes" xml:space="preserve">
          <source>Byte-Compilation Functions</source>
          <target state="translated">바이트 컴파일 함수</target>
        </trans-unit>
        <trans-unit id="1a37ba1d3be3c3de01e4d5d496b8285b080495ba" translate="yes" xml:space="preserve">
          <source>Byte-compiled functions have a special data type: they are &lt;em&gt;byte-code function objects&lt;/em&gt;. Whenever such an object appears as a function to be called, Emacs uses the byte-code interpreter to execute the byte-code.</source>
          <target state="translated">바이트 컴파일 된 함수에는 특수 데이터 유형이 있습니다. 이들은 &lt;em&gt;바이트 코드 함수 객체&lt;/em&gt; 입니다. 이러한 객체가 호출 될 함수로 나타날 때마다 Emacs는 바이트 코드 인터프리터를 사용하여 바이트 코드를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="3bb9f8596b1e76a28bc9081c521014596231e12a" translate="yes" xml:space="preserve">
          <source>Byte-compiling a file also executes any &lt;code&gt;require&lt;/code&gt; calls at top-level in the file, so you can ensure that necessary macro definitions are available during compilation by requiring the files that define them (see &lt;a href=&quot;named-features#Named-Features&quot;&gt;Named Features&lt;/a&gt;). To avoid loading the macro definition files when someone &lt;em&gt;runs&lt;/em&gt; the compiled program, write &lt;code&gt;eval-when-compile&lt;/code&gt; around the &lt;code&gt;require&lt;/code&gt; calls (see &lt;a href=&quot;eval-during-compile#Eval-During-Compile&quot;&gt;Eval During Compile&lt;/a&gt;).</source>
          <target state="translated">파일을 바이트 컴파일하면 파일의 최상위 수준에서 &lt;code&gt;require&lt;/code&gt; 호출이 실행 되므로이를 정의하는 파일을 요구하여 컴파일 중에 필요한 매크로 정의를 사용할 수 있는지 확인할 수 있습니다 ( &lt;a href=&quot;named-features#Named-Features&quot;&gt;명명 된 기능&lt;/a&gt; 참조 ). 누군가 컴파일 된 프로그램을 &lt;em&gt;실행할&lt;/em&gt; 때 매크로 정의 파일을로드하지 않으려면 &lt;code&gt;require&lt;/code&gt; 호출 주위에 &lt;code&gt;eval-when-compile&lt;/code&gt; 을 작성 하십시오 ( &lt;a href=&quot;eval-during-compile#Eval-During-Compile&quot;&gt;컴파일 중 평가&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="cc41f45aabe0cfaf8f1fb19aff9d4d9cd35def84" translate="yes" xml:space="preserve">
          <source>Byte-compiling a file often produces warnings about functions that the compiler doesn&amp;rsquo;t know about (see &lt;a href=&quot;compiler-errors#Compiler-Errors&quot;&gt;Compiler Errors&lt;/a&gt;). Sometimes this indicates a real problem, but usually the functions in question are defined in other files which would be loaded if that code is run. For example, byte-compiling</source>
          <target state="translated">파일을 바이트 컴파일하면 컴파일러가 알지 못하는 함수에 대한 경고가 생성되는 경우가 많습니다 ( &lt;a href=&quot;compiler-errors#Compiler-Errors&quot;&gt;컴파일러 오류&lt;/a&gt; 참조 ). 때때로 이것은 실제 문제를 나타내지 만 일반적으로 문제의 함수는 해당 코드가 실행되면로드되는 다른 파일에 정의되어 있습니다. 예를 들어, 바이트 컴파일</target>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="440395ca055b9f07fbed0d7cf4596c35fc237caa" translate="yes" xml:space="preserve">
          <source>C Dialect</source>
          <target state="translated">C 방언</target>
        </trans-unit>
        <trans-unit id="161c19c41476b0282b81eeb78bdaec44cc5f26eb" translate="yes" xml:space="preserve">
          <source>C Integer Types</source>
          <target state="translated">C 정수 유형</target>
        </trans-unit>
        <trans-unit id="f1dfdb58024fd801bb8d8d91b16183f255579149" translate="yes" xml:space="preserve">
          <source>C-</source>
          <target state="translated">C-</target>
        </trans-unit>
        <trans-unit id="e98b70997278aacbb8d37c462eeefc3cbd3956d9" translate="yes" xml:space="preserve">
          <source>C-=</source>
          <target state="translated">C-=</target>
        </trans-unit>
        <trans-unit id="f91ccd340101fead85b132fc626cf86c66e71760" translate="yes" xml:space="preserve">
          <source>C-@</source>
          <target state="translated">C-@</target>
        </trans-unit>
        <trans-unit id="5a32717cd694e62b994ffe84487a025e94d4ba8d" translate="yes" xml:space="preserve">
          <source>C-A</source>
          <target state="translated">C-A</target>
        </trans-unit>
        <trans-unit id="a0720f926a1edd4fcb28152926e89547a933d93b" translate="yes" xml:space="preserve">
          <source>C-DEL</source>
          <target state="translated">C-DEL</target>
        </trans-unit>
        <trans-unit id="e8de50b9ffc20496735696fad0e0b83e070a5838" translate="yes" xml:space="preserve">
          <source>C-M-S-v</source>
          <target state="translated">C-M-S-v</target>
        </trans-unit>
        <trans-unit id="a587267328d8d782313379e66ff7b0b685da74e3" translate="yes" xml:space="preserve">
          <source>C-M-a</source>
          <target state="translated">C-M-a</target>
        </trans-unit>
        <trans-unit id="523363599c87501263758c3178a881d56b0ca0f3" translate="yes" xml:space="preserve">
          <source>C-M-b</source>
          <target state="translated">C-M-b</target>
        </trans-unit>
        <trans-unit id="9ab2ef69a1c8dee51e5c638f3f4dfb634fbe96a6" translate="yes" xml:space="preserve">
          <source>C-M-c</source>
          <target state="translated">C-M-c</target>
        </trans-unit>
        <trans-unit id="a2b4c4a3c492ba7d8900be9b332ed927f932ea89" translate="yes" xml:space="preserve">
          <source>C-M-e</source>
          <target state="translated">C-M-e</target>
        </trans-unit>
        <trans-unit id="1415d2b0c002711c0b18baff2ffb42f215277da7" translate="yes" xml:space="preserve">
          <source>C-M-f</source>
          <target state="translated">C-M-f</target>
        </trans-unit>
        <trans-unit id="e1283736390e7ca8f0e8dae4d7c15501e7285305" translate="yes" xml:space="preserve">
          <source>C-M-i</source>
          <target state="translated">C-M-i</target>
        </trans-unit>
        <trans-unit id="5554d733d6164f6f3c0310969979f52f4373a6f3" translate="yes" xml:space="preserve">
          <source>C-M-q</source>
          <target state="translated">C-M-q</target>
        </trans-unit>
        <trans-unit id="e48088e6addb18372a14ed6b8da1a6b58ad7c957" translate="yes" xml:space="preserve">
          <source>C-M-v</source>
          <target state="translated">C-M-v</target>
        </trans-unit>
        <trans-unit id="e3d2747af9266236b31cfe9dbcc1d21c148863e4" translate="yes" xml:space="preserve">
          <source>C-M-x</source>
          <target state="translated">C-M-x</target>
        </trans-unit>
        <trans-unit id="d149ce62d1e517cc3bc28b8250bb976be43efcc0" translate="yes" xml:space="preserve">
          <source>C-\</source>
          <target state="translated">C-\</target>
        </trans-unit>
        <trans-unit id="015b01935f205cea280aafb1b1c1757c49bc1bf4" translate="yes" xml:space="preserve">
          <source>C-]</source>
          <target state="translated">C-]</target>
        </trans-unit>
        <trans-unit id="5ec9d3dadc7abaeb1f5f16db2365b2aeb6a2f74b" translate="yes" xml:space="preserve">
          <source>C-_</source>
          <target state="translated">C-_</target>
        </trans-unit>
        <trans-unit id="3bff8fb1aa290267671b1c50e3b32db24f00b295" translate="yes" xml:space="preserve">
          <source>C-a</source>
          <target state="translated">C-a</target>
        </trans-unit>
        <trans-unit id="c204a76fc3c1123c96b13dd7ec922d02d4b00e91" translate="yes" xml:space="preserve">
          <source>C-b</source>
          <target state="translated">C-b</target>
        </trans-unit>
        <trans-unit id="b3b7965656c0921692a30673d7781acd51c4eed9" translate="yes" xml:space="preserve">
          <source>C-c</source>
          <target state="translated">C-c</target>
        </trans-unit>
        <trans-unit id="2922399c2d547241985d2d9050d0f4a253f10c73" translate="yes" xml:space="preserve">
          <source>C-c 3</source>
          <target state="translated">참조 3</target>
        </trans-unit>
        <trans-unit id="8c846cf1bd5b4fe56864ee3f4c9665e8b3b8fcc4" translate="yes" xml:space="preserve">
          <source>C-c &lt;var&gt;letter&lt;/var&gt;</source>
          <target state="translated">Cc &lt;var&gt;letter&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="63d94b505b28b164240bf9389a0b04f654a4efe7" translate="yes" xml:space="preserve">
          <source>C-c C-d</source>
          <target state="translated">참조 Cd</target>
        </trans-unit>
        <trans-unit id="d0bed7baa3038554c15ed1dd0d2b6090b9910013" translate="yes" xml:space="preserve">
          <source>C-c C-u</source>
          <target state="translated">Cc Cu</target>
        </trans-unit>
        <trans-unit id="f74c88ff9d7e7d40f5d62f507900f4cb7519ee90" translate="yes" xml:space="preserve">
          <source>C-c C-w</source>
          <target state="translated">Cc Cw</target>
        </trans-unit>
        <trans-unit id="e396508e7aa9423085342ba159b546882b435194" translate="yes" xml:space="preserve">
          <source>C-c C-z</source>
          <target state="translated">Cc Cz</target>
        </trans-unit>
        <trans-unit id="98c56570dd5671b7a19fbc0ebf8785f9ff91eddc" translate="yes" xml:space="preserve">
          <source>C-c ESC</source>
          <target state="translated">참조 ESC</target>
        </trans-unit>
        <trans-unit id="f9d21da244350a9db0114ec30af406d5bef1cb45" translate="yes" xml:space="preserve">
          <source>C-c ESC O P</source>
          <target state="translated">참조 ESC OP</target>
        </trans-unit>
        <trans-unit id="57e4e54e9967cd42daed8a76a5aa899b154b7b12" translate="yes" xml:space="preserve">
          <source>C-c PF1</source>
          <target state="translated">참조 PF1</target>
        </trans-unit>
        <trans-unit id="d2e5a2b66c696b957548f71ee728ee1ae137f0c0" translate="yes" xml:space="preserve">
          <source>C-c h</source>
          <target state="translated">Cc h</target>
        </trans-unit>
        <trans-unit id="a7ef1e89e28b60bd53a0a5ab746fbcd131fdf224" translate="yes" xml:space="preserve">
          <source>C-e</source>
          <target state="translated">C-e</target>
        </trans-unit>
        <trans-unit id="dd71d43937255c2ba419c077fa824865f8267186" translate="yes" xml:space="preserve">
          <source>C-f</source>
          <target state="translated">C-f</target>
        </trans-unit>
        <trans-unit id="a4b41cc50f9ee3592ac03dec905ea87299f64719" translate="yes" xml:space="preserve">
          <source>C-f C-n</source>
          <target state="translated">Cf Cn</target>
        </trans-unit>
        <trans-unit id="a6d13ed5d2d00101157246b7ae1e91a19d7d7406" translate="yes" xml:space="preserve">
          <source>C-g</source>
          <target state="translated">C-g</target>
        </trans-unit>
        <trans-unit id="a8d14a9f4bc55d9a8a84935ad37682321efb17a6" translate="yes" xml:space="preserve">
          <source>C-h</source>
          <target state="translated">C-h</target>
        </trans-unit>
        <trans-unit id="131f9a03ecbf035173b42486265daa4c059aa594" translate="yes" xml:space="preserve">
          <source>C-h C-h</source>
          <target state="translated">채널 채널</target>
        </trans-unit>
        <trans-unit id="8fc1636b1726f0f848e9110d7df8ad94624fe8a2" translate="yes" xml:space="preserve">
          <source>C-h P</source>
          <target state="translated">채널 P</target>
        </trans-unit>
        <trans-unit id="d24cf6f79d3eca79589b614119c65a877786e8e3" translate="yes" xml:space="preserve">
          <source>C-h a</source>
          <target state="translated">Ch a</target>
        </trans-unit>
        <trans-unit id="c947b2d5d96ff5df49e3e32802fd4fbc37367b9c" translate="yes" xml:space="preserve">
          <source>C-h b</source>
          <target state="translated">채널 b</target>
        </trans-unit>
        <trans-unit id="2f32ced337101528820a543fba4ae73fd0b8a020" translate="yes" xml:space="preserve">
          <source>C-h c</source>
          <target state="translated">Ch c</target>
        </trans-unit>
        <trans-unit id="b6509cacdcc73abddf104ea8e33a97a3ac5575fa" translate="yes" xml:space="preserve">
          <source>C-h f</source>
          <target state="translated">Ch f</target>
        </trans-unit>
        <trans-unit id="044ffa482f401d4a34b0ce3d2fc0aa8a6c6451c5" translate="yes" xml:space="preserve">
          <source>C-h m</source>
          <target state="translated">Ch m</target>
        </trans-unit>
        <trans-unit id="94df7f22a37722547e0a4acb987c3e85a4c7583c" translate="yes" xml:space="preserve">
          <source>C-h v</source>
          <target state="translated">채널 v</target>
        </trans-unit>
        <trans-unit id="223627ab9c74b5ae56858c226557c9e9be301085" translate="yes" xml:space="preserve">
          <source>C-i</source>
          <target state="translated">C-i</target>
        </trans-unit>
        <trans-unit id="4d83990cce829d69d972a1ed2a1e206afb6b5b37" translate="yes" xml:space="preserve">
          <source>C-j</source>
          <target state="translated">C-j</target>
        </trans-unit>
        <trans-unit id="d5eeac2f32301e2b964f421e02a44c5afa000881" translate="yes" xml:space="preserve">
          <source>C-k</source>
          <target state="translated">C-k</target>
        </trans-unit>
        <trans-unit id="2fef5b5a274737535a312ecc5d6b8de717c1cb77" translate="yes" xml:space="preserve">
          <source>C-l</source>
          <target state="translated">C-l</target>
        </trans-unit>
        <trans-unit id="aa3408adf600065cf33c17971e8cdd9f76e5d785" translate="yes" xml:space="preserve">
          <source>C-n</source>
          <target state="translated">C-n</target>
        </trans-unit>
        <trans-unit id="332268c029d8126391ff9151361238bdf44870d8" translate="yes" xml:space="preserve">
          <source>C-p</source>
          <target state="translated">C-p</target>
        </trans-unit>
        <trans-unit id="023f8e3d8a24aa022603e7bc5546978051323321" translate="yes" xml:space="preserve">
          <source>C-p 6</source>
          <target state="translated">Cp 6</target>
        </trans-unit>
        <trans-unit id="7e58e0990d0a53938ca001b4ad01a74ad57ecbdf" translate="yes" xml:space="preserve">
          <source>C-p C-f</source>
          <target state="translated">Cp Cf</target>
        </trans-unit>
        <trans-unit id="1666955c646a9bb3fabdb2404112bd45b66ccb34" translate="yes" xml:space="preserve">
          <source>C-q</source>
          <target state="translated">C-q</target>
        </trans-unit>
        <trans-unit id="74b18abb702cb69395f60707416dd8e1f9e92a32" translate="yes" xml:space="preserve">
          <source>C-r</source>
          <target state="translated">C-r</target>
        </trans-unit>
        <trans-unit id="78540d990eb5e51e46b3d550d8999b517398872e" translate="yes" xml:space="preserve">
          <source>C-s</source>
          <target state="translated">C-s</target>
        </trans-unit>
        <trans-unit id="ac7de9aff7d0daffb3ae53140a783f411f89c587" translate="yes" xml:space="preserve">
          <source>C-u</source>
          <target state="translated">C-u</target>
        </trans-unit>
        <trans-unit id="d22f544f91c38776df9e98de756eed3debe16cdc" translate="yes" xml:space="preserve">
          <source>C-u -</source>
          <target state="translated">Cu-</target>
        </trans-unit>
        <trans-unit id="10f8bc5307f68632db725ed0931d63de1460ddfa" translate="yes" xml:space="preserve">
          <source>C-u -1 C-M-u</source>
          <target state="translated">Cu -1 CMu</target>
        </trans-unit>
        <trans-unit id="5f418fb7321d2ab8c56f997e5658b00a3040a2d1" translate="yes" xml:space="preserve">
          <source>C-u 0 C-j</source>
          <target state="translated">Cu 0 Cj</target>
        </trans-unit>
        <trans-unit id="da79c04f91b004dd27140e6acdba5d94bb656395" translate="yes" xml:space="preserve">
          <source>C-u 0 C-x C-e</source>
          <target state="translated">Cu 0 Cx Ce</target>
        </trans-unit>
        <trans-unit id="9abc686ab642db3617ba866712386a2c3367c984" translate="yes" xml:space="preserve">
          <source>C-u 1 2 3-</source>
          <target state="translated">Cu 12 3-</target>
        </trans-unit>
        <trans-unit id="078553441ff260418cd0fae179ba0b421b563072" translate="yes" xml:space="preserve">
          <source>C-u 4</source>
          <target state="translated">Cu 4</target>
        </trans-unit>
        <trans-unit id="b45852e2bb35925480811fa34c28817e312757e2" translate="yes" xml:space="preserve">
          <source>C-u C-M-u</source>
          <target state="translated">Cu CMu</target>
        </trans-unit>
        <trans-unit id="320929c2d1df45760946518161a90d14f7c50bd7" translate="yes" xml:space="preserve">
          <source>C-u C-M-x</source>
          <target state="translated">Cu CMx</target>
        </trans-unit>
        <trans-unit id="c64b6c2b2de84365236fe039ef1643ad9097b181" translate="yes" xml:space="preserve">
          <source>C-u C-f</source>
          <target state="translated">Cu Cf</target>
        </trans-unit>
        <trans-unit id="144ed887662b97ccd7d5e4df38590e6b0c9188ee" translate="yes" xml:space="preserve">
          <source>C-u RET</source>
          <target state="translated">Cu RET</target>
        </trans-unit>
        <trans-unit id="c228f37d7ea330bf7c0d73a894ac443b387f3c40" translate="yes" xml:space="preserve">
          <source>C-u-</source>
          <target state="translated">C-u-</target>
        </trans-unit>
        <trans-unit id="0a23d9de112f4305bbf7d308788b4615cc11e2a2" translate="yes" xml:space="preserve">
          <source>C-v</source>
          <target state="translated">C-v</target>
        </trans-unit>
        <trans-unit id="298ef629795cfb23ea736c739c02035ede13e0c6" translate="yes" xml:space="preserve">
          <source>C-x</source>
          <target state="translated">C-x</target>
        </trans-unit>
        <trans-unit id="4347a3678ac074d5ec07c3503e15ff18b018adc3" translate="yes" xml:space="preserve">
          <source>C-x 0</source>
          <target state="translated">Cx 0</target>
        </trans-unit>
        <trans-unit id="10124bcc79d4680d2849a4ecb1654c7898083a7b" translate="yes" xml:space="preserve">
          <source>C-x 1</source>
          <target state="translated">CX 1</target>
        </trans-unit>
        <trans-unit id="4d47f604c607b6bcf678aa67ec1bf75bf4ba7c33" translate="yes" xml:space="preserve">
          <source>C-x 2</source>
          <target state="translated">CX 2</target>
        </trans-unit>
        <trans-unit id="556f397c3864e7f8b2430507a0e9a218c58fd56b" translate="yes" xml:space="preserve">
          <source>C-x 3</source>
          <target state="translated">CX 3</target>
        </trans-unit>
        <trans-unit id="abc0d3ddf5ac08765cf41363b262bc421ad3ed38" translate="yes" xml:space="preserve">
          <source>C-x 4</source>
          <target state="translated">CX 4</target>
        </trans-unit>
        <trans-unit id="63307f15d6b42550d550cea24aeaa5bda8c024a5" translate="yes" xml:space="preserve">
          <source>C-x 4 C-f</source>
          <target state="translated">Cx 4 Cf</target>
        </trans-unit>
        <trans-unit id="d7e8408a7a87b24eb8ce1e9cd577a71f1abc5c24" translate="yes" xml:space="preserve">
          <source>C-x 4 C-o</source>
          <target state="translated">CX 4 공동</target>
        </trans-unit>
        <trans-unit id="d4b75cbe5b9f13c775f58fb5aadb4fd2fca9c73f" translate="yes" xml:space="preserve">
          <source>C-x 5</source>
          <target state="translated">CX5</target>
        </trans-unit>
        <trans-unit id="74dc274a8f353a10c8762b6eeb01cd5d80e205ba" translate="yes" xml:space="preserve">
          <source>C-x 6</source>
          <target state="translated">Cx 6</target>
        </trans-unit>
        <trans-unit id="b0c7a6e9bf270123c8284d4924a852cb0abe30d2" translate="yes" xml:space="preserve">
          <source>C-x @</source>
          <target state="translated">Cx @</target>
        </trans-unit>
        <trans-unit id="9ac0e333a25e06893ccf8044371d24b9f4683984" translate="yes" xml:space="preserve">
          <source>C-x C-\</source>
          <target state="translated">Cx C- \</target>
        </trans-unit>
        <trans-unit id="fdd391c7388aca6906f3e720a86ca5447e7d9c38" translate="yes" xml:space="preserve">
          <source>C-x C-a C-m</source>
          <target state="translated">Cx Ca Cm</target>
        </trans-unit>
        <trans-unit id="38858c4b382736f825616a2e73e26265ca9bb63a" translate="yes" xml:space="preserve">
          <source>C-x C-c</source>
          <target state="translated">Cx Cc</target>
        </trans-unit>
        <trans-unit id="2e574ba4b6c51b8c22a26b1eabc3a75c78d4ea7e" translate="yes" xml:space="preserve">
          <source>C-x C-e</source>
          <target state="translated">CX Ce</target>
        </trans-unit>
        <trans-unit id="94093db9cb5d3fcd6ac5d93df4e2811d80860744" translate="yes" xml:space="preserve">
          <source>C-x C-f</source>
          <target state="translated">Cx Cf</target>
        </trans-unit>
        <trans-unit id="5aa04c1406d2bc59f9f02c65f0475fb37d41d69f" translate="yes" xml:space="preserve">
          <source>C-x C-g</source>
          <target state="translated">Cx Cg</target>
        </trans-unit>
        <trans-unit id="42560a5db134ba65783348e3bb0520d740376d48" translate="yes" xml:space="preserve">
          <source>C-x C-k</source>
          <target state="translated">Cx Ck</target>
        </trans-unit>
        <trans-unit id="92e72c608b382e9a997922e89877037677057e63" translate="yes" xml:space="preserve">
          <source>C-x C-k RET</source>
          <target state="translated">Cx Ck RET</target>
        </trans-unit>
        <trans-unit id="1c401be2ef044065bde20ae40271bd4ce7c9dbaa" translate="yes" xml:space="preserve">
          <source>C-x C-q</source>
          <target state="translated">Cx Cq</target>
        </trans-unit>
        <trans-unit id="a35119fcea09407a970dc0c67d75cdf4c7493695" translate="yes" xml:space="preserve">
          <source>C-x C-v</source>
          <target state="translated">CX Cv</target>
        </trans-unit>
        <trans-unit id="380c2576bb1153c21b82305ecfd8e9cf75bb83cb" translate="yes" xml:space="preserve">
          <source>C-x C-w</source>
          <target state="translated">Cx Cw</target>
        </trans-unit>
        <trans-unit id="ad8e8247f1608bee89a7e56cab4034588ceeed4a" translate="yes" xml:space="preserve">
          <source>C-x ESC</source>
          <target state="translated">CX ESC</target>
        </trans-unit>
        <trans-unit id="08a670503878dc334b05f1ec67cd80daa09a543f" translate="yes" xml:space="preserve">
          <source>C-x RET</source>
          <target state="translated">CX RET</target>
        </trans-unit>
        <trans-unit id="33f00fe6ae825deab6e618f2518c895513248309" translate="yes" xml:space="preserve">
          <source>C-x RET c</source>
          <target state="translated">Cx RET c</target>
        </trans-unit>
        <trans-unit id="79182736a3f6f4a9b73be73dd66c6a963d18e6ef" translate="yes" xml:space="preserve">
          <source>C-x X =</source>
          <target state="translated">Cx X =</target>
        </trans-unit>
        <trans-unit id="06fec4fbfa2b40b5ba7dcd2878f2262be7a89cc4" translate="yes" xml:space="preserve">
          <source>C-x X W</source>
          <target state="translated">CX XW</target>
        </trans-unit>
        <trans-unit id="b2d82441407b634931a0202fcd846528c8356104" translate="yes" xml:space="preserve">
          <source>C-x X X</source>
          <target state="translated">CX XX</target>
        </trans-unit>
        <trans-unit id="0eabb8db03adc6a93c843bc7c3b4405a882bfbbf" translate="yes" xml:space="preserve">
          <source>C-x X w</source>
          <target state="translated">Cx X w</target>
        </trans-unit>
        <trans-unit id="a433c8910fd90328a865425f7cba86d9473bd9b8" translate="yes" xml:space="preserve">
          <source>C-x a</source>
          <target state="translated">CX는</target>
        </trans-unit>
        <trans-unit id="d678c9278cafdf31c68ce0a63d4dfdb3f69b7e79" translate="yes" xml:space="preserve">
          <source>C-x a i</source>
          <target state="translated">CX AI</target>
        </trans-unit>
        <trans-unit id="2aaaca2013569838cb0a146bd12e35301c230558" translate="yes" xml:space="preserve">
          <source>C-x b</source>
          <target state="translated">Cx b</target>
        </trans-unit>
        <trans-unit id="81a4dfc7002c34a5db314fd55a88c71ce9f8561c" translate="yes" xml:space="preserve">
          <source>C-x l</source>
          <target state="translated">CX l</target>
        </trans-unit>
        <trans-unit id="b228794009dfb59282b23e84edcb2dc535059148" translate="yes" xml:space="preserve">
          <source>C-x left</source>
          <target state="translated">Cx 왼쪽</target>
        </trans-unit>
        <trans-unit id="0b13a73400d0c3c495b50621ca5fbf45fa714316" translate="yes" xml:space="preserve">
          <source>C-x m</source>
          <target state="translated">Cx m</target>
        </trans-unit>
        <trans-unit id="e78aa0259487687b23094dfc0b1d246956ee5054" translate="yes" xml:space="preserve">
          <source>C-x n</source>
          <target state="translated">Cxn</target>
        </trans-unit>
        <trans-unit id="37419a3d9d60f9f4a3c3ceeae49cb867b0552dd5" translate="yes" xml:space="preserve">
          <source>C-x o</source>
          <target state="translated">Cx o</target>
        </trans-unit>
        <trans-unit id="06bba06d9146ec872930935a408ff9e6db7b540e" translate="yes" xml:space="preserve">
          <source>C-x q</source>
          <target state="translated">CX Q</target>
        </trans-unit>
        <trans-unit id="6e1b8f11e4e004ffcd85260453eb416fadd8becd" translate="yes" xml:space="preserve">
          <source>C-x r</source>
          <target state="translated">Cx r</target>
        </trans-unit>
        <trans-unit id="c03a751f3df1d75c00ca555cdecb7ea0f12e35b3" translate="yes" xml:space="preserve">
          <source>C-x t</source>
          <target state="translated">Cx t</target>
        </trans-unit>
        <trans-unit id="16f34907c9a94600e9a207daf61c838d0b36dc8a" translate="yes" xml:space="preserve">
          <source>C-x v</source>
          <target state="translated">CX V</target>
        </trans-unit>
        <trans-unit id="f286461016d3e4db77e8a575a1f55b2d71886961" translate="yes" xml:space="preserve">
          <source>C-y</source>
          <target state="translated">C-y</target>
        </trans-unit>
        <trans-unit id="acbbb692ba3dcc7f0dd54066ac8990ff1950dc9c" translate="yes" xml:space="preserve">
          <source>C-z</source>
          <target state="translated">C-z</target>
        </trans-unit>
        <trans-unit id="ee5254754a61a705597a6d10837027cbbdd49eb6" translate="yes" xml:space="preserve">
          <source>CLOS</source>
          <target state="translated">CLOS</target>
        </trans-unit>
        <trans-unit id="8a9cbc4396b103e6b251b294230c1bb9eed38e2f" translate="yes" xml:space="preserve">
          <source>COM1</source>
          <target state="translated">COM1</target>
        </trans-unit>
        <trans-unit id="23f35962de37902073c854bc889f0133b87d83ae" translate="yes" xml:space="preserve">
          <source>COM9</source>
          <target state="translated">COM9</target>
        </trans-unit>
        <trans-unit id="cbb44b8d4066ca53d103823d7579880a884c46f2" translate="yes" xml:space="preserve">
          <source>CTL</source>
          <target state="translated">CTL</target>
        </trans-unit>
        <trans-unit id="b38bed0f0e9601a07358ec72777da31f91720f2a" translate="yes" xml:space="preserve">
          <source>CTRL</source>
          <target state="translated">CTRL</target>
        </trans-unit>
        <trans-unit id="5e1dd8155002a7d7db24335015acaddd25a44f09" translate="yes" xml:space="preserve">
          <source>CVS</source>
          <target state="translated">CVS</target>
        </trans-unit>
        <trans-unit id="36e5803b7728bb1569947feca18d17ebe22e40b0" translate="yes" xml:space="preserve">
          <source>Calendrical conversion functions always use the Gregorian calendar, even for dates before the Gregorian calendar was introduced. Year numbers count the number of years since the year 1 BC, and do not skip zero as traditional Gregorian years do; for example, the year number -37 represents the Gregorian year 38 BC.</source>
          <target state="translated">달력 변환 함수는 그레고리력이 도입되기 전 날짜에도 항상 그레고리력을 사용합니다. 연도 숫자는 기원전 1 년 이후의 연도를 계산하며, 전통적인 그레고리력 연도처럼 0을 건너 뛰지 않습니다. 예를 들어, 연도 번호 -37은 BC 38 년 그레고리력을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="de42e995f53f7e732b05aa461dce2010e145fa00" translate="yes" xml:space="preserve">
          <source>Call &lt;var&gt;button&lt;/var&gt;&amp;rsquo;s &lt;code&gt;action&lt;/code&gt; property (i.e., invoke the function that is the value of that property, passing it the single argument &lt;var&gt;button&lt;/var&gt;). If &lt;var&gt;use-mouse-action&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, try to invoke the button&amp;rsquo;s &lt;code&gt;mouse-action&lt;/code&gt; property instead of &lt;code&gt;action&lt;/code&gt;; if the button has no &lt;code&gt;mouse-action&lt;/code&gt; property, use &lt;code&gt;action&lt;/code&gt; as normal. If the &lt;code&gt;button-data&lt;/code&gt; property is present in &lt;var&gt;button&lt;/var&gt;, use that as the argument for the &lt;code&gt;action&lt;/code&gt; function instead of &lt;var&gt;button&lt;/var&gt;.</source>
          <target state="translated">통화 &lt;var&gt;button&lt;/var&gt; 의 &lt;code&gt;action&lt;/code&gt; (그것은 하나의 인수 전달, 해당 속성의 값이 함수 호출 즉, 재산 &lt;var&gt;button&lt;/var&gt; ). 경우 &lt;var&gt;use-mouse-action&lt;/var&gt; 비입니다 &lt;code&gt;nil&lt;/code&gt; , 버튼의 호출을 시도 &lt;code&gt;mouse-action&lt;/code&gt; 대신 속성을 &lt;code&gt;action&lt;/code&gt; ; 버튼에 &lt;code&gt;mouse-action&lt;/code&gt; 속성 이 없으면 정상적으로 &lt;code&gt;action&lt;/code&gt; 을 사용 합니다 . 경우] &lt;code&gt;button-data&lt;/code&gt; 재산권에 존재하는 &lt;var&gt;button&lt;/var&gt; 은의 인수로 사용하여 그 &lt;code&gt;action&lt;/code&gt; 대신에 기능 &lt;var&gt;button&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="f7e81e62a0bc26dffa21e5943c5b76d235ec9103" translate="yes" xml:space="preserve">
          <source>Call &lt;var&gt;function&lt;/var&gt; after the old function and only if the old function returned &lt;code&gt;nil&lt;/code&gt;. More specifically, the composition of the two functions behaves like:</source>
          <target state="translated">이전 &lt;var&gt;function&lt;/var&gt; 다음에 함수 를 호출 하고 이전 함수가 &lt;code&gt;nil&lt;/code&gt; 을 반환 한 경우에만 호출 합니다 . 보다 구체적으로, 두 함수의 구성은 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="15f89cad7964a4c4ff36312550efc21a307afff6" translate="yes" xml:space="preserve">
          <source>Call &lt;var&gt;function&lt;/var&gt; after the old function and only if the old function returned non-&lt;code&gt;nil&lt;/code&gt;. Both functions receive the same arguments, and the return value of the composition is the return value of &lt;var&gt;function&lt;/var&gt;. More specifically, the composition of the two functions behaves like:</source>
          <target state="translated">이전 &lt;var&gt;function&lt;/var&gt; 다음에 함수 를 호출 하고 이전 함수가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우에만 함수를 호출 합니다 . 두 함수 모두 동일한 인수를 받고 컴포지션의 반환 값은 &lt;var&gt;function&lt;/var&gt; 의 반환 값입니다 . 보다 구체적으로, 두 함수의 구성은 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="11b9ee6402d0942f809e7bacb34c109edce11c8a" translate="yes" xml:space="preserve">
          <source>Call &lt;var&gt;function&lt;/var&gt; after the old function. Both functions receive the same arguments, and the return value of the composition is the return value of the old function. More specifically, the composition of the two functions behaves like:</source>
          <target state="translated">이전 &lt;var&gt;function&lt;/var&gt; 이후에 함수 를 호출 합니다 . 두 함수 모두 동일한 인수를 받고 컴포지션의 반환 값은 이전 함수의 반환 값입니다. 보다 구체적으로, 두 함수의 구성은 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="dd45f95fef4e571698af292b7cdd92bffd8265e2" translate="yes" xml:space="preserve">
          <source>Call &lt;var&gt;function&lt;/var&gt; before the old function and don&amp;rsquo;t call the old function if &lt;var&gt;function&lt;/var&gt; returns &lt;code&gt;nil&lt;/code&gt;. Both functions receive the same arguments, and the return value of the composition is the return value of the old function. More specifically, the composition of the two functions behaves like:</source>
          <target state="translated">통화 &lt;var&gt;function&lt;/var&gt; 있는 경우 이전 기능 이전과 이전 함수를 호출하지 않는 &lt;var&gt;function&lt;/var&gt; 반환 &lt;code&gt;nil&lt;/code&gt; 을 . 두 함수 모두 동일한 인수를 받고 컴포지션의 반환 값은 이전 함수의 반환 값입니다. 보다 구체적으로, 두 함수의 구성은 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e177089f3e47a75e445f46873115fbe430078933" translate="yes" xml:space="preserve">
          <source>Call &lt;var&gt;function&lt;/var&gt; before the old function and only call the old function if &lt;var&gt;function&lt;/var&gt; returns &lt;code&gt;nil&lt;/code&gt;. More specifically, the composition of the two functions behaves like:</source>
          <target state="translated">전화 &lt;var&gt;function&lt;/var&gt; 이전 기능 이전과 경우에만 이전 함수를 호출 &lt;var&gt;function&lt;/var&gt; 반환 &lt;code&gt;nil&lt;/code&gt; 을 . 보다 구체적으로, 두 함수의 구성은 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="5a61495f3b296416244dbb85cc0933049276d9d5" translate="yes" xml:space="preserve">
          <source>Call &lt;var&gt;function&lt;/var&gt; before the old function. Both functions receive the same arguments, and the return value of the composition is the return value of the old function. More specifically, the composition of the two functions behaves like:</source>
          <target state="translated">이전 &lt;var&gt;function&lt;/var&gt; 전에 함수 를 호출하십시오 . 두 함수 모두 동일한 인수를 받고 컴포지션의 반환 값은 이전 함수의 반환 값입니다. 보다 구체적으로, 두 함수의 구성은 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="f4cc04f8d665904345400ebc070afe6901974fc2" translate="yes" xml:space="preserve">
          <source>Call &lt;var&gt;function&lt;/var&gt; first and use the result (which should be a list) as the new arguments to pass to the old function. More specifically, the composition of the two functions behaves like:</source>
          <target state="translated">먼저 &lt;var&gt;function&lt;/var&gt; 호출 하고 결과 (목록이어야 함)를 이전 함수에 전달할 새 인수로 사용합니다. 보다 구체적으로, 두 함수의 구성은 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e77c6828a07ec693781d6efe3e57ff1a5a36a8c0" translate="yes" xml:space="preserve">
          <source>Call &lt;var&gt;function&lt;/var&gt; for characters in &lt;var&gt;charset&lt;/var&gt;. &lt;var&gt;function&lt;/var&gt; is called with two arguments. The first one is a cons cell &lt;code&gt;(&lt;var&gt;from&lt;/var&gt; .  &lt;var&gt;to&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;from&lt;/var&gt; and &lt;var&gt;to&lt;/var&gt; indicate a range of characters contained in charset. The second argument passed to &lt;var&gt;function&lt;/var&gt; is &lt;var&gt;arg&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;charset&lt;/var&gt; 의 문자에 대한 &lt;var&gt;function&lt;/var&gt; 를 호출 합니다 . &lt;var&gt;function&lt;/var&gt; 는 두 개의 인수로 호출됩니다. 첫 번째는 cons 셀 &lt;code&gt;(&lt;var&gt;from&lt;/var&gt; . &lt;var&gt;to&lt;/var&gt;)&lt;/code&gt; &lt;var&gt;from&lt;/var&gt; . &lt;var&gt;to&lt;/var&gt; )입니다 . 여기서 &lt;var&gt;from&lt;/var&gt; 및 &lt;var&gt;to&lt;/var&gt; 는 문자 집합에 포함 된 문자 범위 를 나타냅니다. &lt;var&gt;function&lt;/var&gt; 에 전달 된 두 번째 인수 는 &lt;var&gt;arg&lt;/var&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fae0114c2201a949abeef4209c12323f1f0e324b" translate="yes" xml:space="preserve">
          <source>Call &lt;var&gt;function&lt;/var&gt; for every piece of advice that was added to the named function &lt;var&gt;symbol&lt;/var&gt;. &lt;var&gt;function&lt;/var&gt; is called with two arguments: the advice function and its properties.</source>
          <target state="translated">명명 된 함수 &lt;var&gt;symbol&lt;/var&gt; 에 추가 된 모든 조언에 대해 &lt;var&gt;function&lt;/var&gt; 를 호출하십시오 . &lt;var&gt;function&lt;/var&gt; 는 두 개의 인수, 즉 advice 함수와 그 속성으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="567ee80f88e9b6fcfc133e840199c180bb8db2d1" translate="yes" xml:space="preserve">
          <source>Call &lt;var&gt;function&lt;/var&gt; instead of the old function, but provide the old function as an extra argument to &lt;var&gt;function&lt;/var&gt;. This is the most flexible composition. For example, it lets you call the old function with different arguments, or many times, or within a let-binding, or you can sometimes delegate the work to the old function and sometimes override it completely. More specifically, the composition of the two functions behaves like:</source>
          <target state="translated">이전 &lt;var&gt;function&lt;/var&gt; 대신 함수 를 호출 하되 이전 함수를 function에 대한 추가 인수로 제공 &lt;var&gt;function&lt;/var&gt; . 이것은 가장 유연한 구성입니다. 예를 들어, 다른 인수를 사용하여 또는 여러 번 또는 let-binding 내에서 이전 함수를 호출 할 수 있습니다. 또는 때로는 작업을 이전 함수에 위임하고 때로는 완전히 재정의 할 수 있습니다. 보다 구체적으로, 두 함수의 구성은 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="d1a7d71503696cf38410fc1322aa1095b06486f0" translate="yes" xml:space="preserve">
          <source>Call the anonymous function with one argument, &lt;var&gt;expval&lt;/var&gt; (see &lt;a href=&quot;lambda-expressions#Lambda-Expressions&quot;&gt;Lambda Expressions&lt;/a&gt;).</source>
          <target state="translated">하나의 인수 &lt;var&gt;expval&lt;/var&gt; 을 사용하여 익명 함수를 호출합니다 ( &lt;a href=&quot;lambda-expressions#Lambda-Expressions&quot;&gt;Lambda 표현식&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="7476fa450c9cf57b9d41330c2668e502b573753f" translate="yes" xml:space="preserve">
          <source>Call the function (the first element of the function call) with &lt;var&gt;n&lt;/var&gt; arguments (the other elements) and an additional &lt;var&gt;n&lt;/var&gt;+1-th argument that is &lt;var&gt;expval&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;n&lt;/var&gt; 개의 인수 (다른 요소)와 추가로 &lt;var&gt;n&lt;/var&gt; 개의 +1 번째 인수 인 &lt;var&gt;expval&lt;/var&gt; 을 사용 하여 함수 (함수 호출의 첫 번째 요소)를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="cce8159a07f7ca94dd3aede2fb066a149472cac4" translate="yes" xml:space="preserve">
          <source>Call the function &lt;var&gt;f&lt;/var&gt; for every piece of advice that was added to &lt;var&gt;function-def&lt;/var&gt;. &lt;var&gt;f&lt;/var&gt; is called with two arguments: the advice function and its properties.</source>
          <target state="translated">&lt;var&gt;function-def&lt;/var&gt; 에 추가 된 모든 조언에 대해 함수 &lt;var&gt;f&lt;/var&gt; 를 호출하십시오 . &lt;var&gt;f&lt;/var&gt; 는 두 개의 인수, 즉 advice 함수와 그 속성으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="f7bee42ac2cfe40e42c5b3d7a4488a39eab8279c" translate="yes" xml:space="preserve">
          <source>Call the named function with one argument, &lt;var&gt;expval&lt;/var&gt;.</source>
          <target state="translated">하나의 인수 &lt;var&gt;expval&lt;/var&gt; 을 사용하여 명명 된 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="c5bef85c072afa5ae3f80c86a71f855f8cba1aac" translate="yes" xml:space="preserve">
          <source>Call the old function first and pass the result to &lt;var&gt;function&lt;/var&gt;. More specifically, the composition of the two functions behaves like:</source>
          <target state="translated">먼저 이전 함수를 호출하고 결과를 &lt;var&gt;function&lt;/var&gt; 에 전달하십시오 . 보다 구체적으로, 두 함수의 구성은 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="6afd776be5db841a6dc68b637bb932e7dfca56a9" translate="yes" xml:space="preserve">
          <source>Call this command after using &lt;code&gt;smie-config-guess&lt;/code&gt;, to save your settings for future sessions.</source>
          <target state="translated">&lt;code&gt;smie-config-guess&lt;/code&gt; 를 사용한 후이 명령을 호출하여 향후 세션에 대한 설정을 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="8506342e0260dd8016e03d646af20a2c9018a199" translate="yes" xml:space="preserve">
          <source>Call this function instead of using a literal value (usually, zero) of the column number for indenting top-level program constructs. The function&amp;rsquo;s value is the column number to use for top-level constructs. When no superior mode is in effect, this function returns zero.</source>
          <target state="translated">최상위 프로그램 구성을 들여 쓰기 위해 열 번호의 리터럴 값 (보통 0)을 사용하는 대신이 함수를 호출하십시오. 함수의 값은 최상위 구성에 사용할 열 번호입니다. 상위 모드가 적용되지 않으면이 함수는 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="98d6a6a2c4f2e6e0e83bdfbcc0730217802507ab" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;concat&lt;/code&gt; converts the list to a string so you can see its contents more clearly.</source>
          <target state="translated">&lt;code&gt;concat&lt;/code&gt; 을 호출 하면 목록이 문자열로 변환되어 내용을 더 명확하게 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa38eb2554dbe5c7a33e4b709e55fe4dded0e886" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;smie-setup&lt;/code&gt; is also sufficient to make</source>
          <target state="translated">&lt;code&gt;smie-setup&lt;/code&gt; 을 호출하는 것으로도 충분합니다.</target>
        </trans-unit>
        <trans-unit id="511ba4c0240efeaabfee01e6c6a8c90f51297283" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;substitute-in-file-name&lt;/code&gt; on output produced by &lt;code&gt;substitute-in-file-name&lt;/code&gt; tends to give incorrect results. For instance, use of &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;substitute-in-file-name&lt;/code&gt; 에서 &lt;code&gt;substitute-in-file-name&lt;/code&gt; 생성 된 출력 에서 파일 이름 으로 대체를 호출 하면 잘못된 결과를 제공하는 경향이 있습니다. 예를 들어 '</target>
        </trans-unit>
        <trans-unit id="9ac3d844132b984a3eb47bf8dcb79e4bbd848878" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;window-preserve-size&lt;/code&gt; (see &lt;a href=&quot;preserving-window-sizes#Preserving-Window-Sizes&quot;&gt;Preserving Window Sizes&lt;/a&gt;) will try to keep the size of the argument window unchanged when popping up a new window. You have to make sure that another window in the same combination can be shrunk instead, though.</source>
          <target state="translated">&lt;code&gt;window-preserve-size&lt;/code&gt; 호출 ( &lt;a href=&quot;preserving-window-sizes#Preserving-Window-Sizes&quot;&gt;창 크기 유지&lt;/a&gt; 참조 )은 새 창을 띄울 때 인수 창의 크기를 변경하지 않고 유지하려고합니다. 하지만 동일한 조합의 다른 창을 대신 축소 할 수 있는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="2f2b1f5f71d89e54c8503e6cf93a04999cc1b58a" translate="yes" xml:space="preserve">
          <source>Calling Functions</source>
          <target state="translated">함수 호출</target>
        </trans-unit>
        <trans-unit id="504886a8ce3a7ab2de140289b5cdac7f6b388ff2" translate="yes" xml:space="preserve">
          <source>Calling a command, so that it will read arguments.</source>
          <target state="translated">명령을 호출하여 인수를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="a961505da75e77209eaa6b59e8f61a3dffb36635" translate="yes" xml:space="preserve">
          <source>Calling the major mode command twice in direct succession should not fail and should do the same thing as calling the command only once. In other words, the major mode command should be idempotent.</source>
          <target state="translated">주 모드 명령을 연속해서 두 번 호출하면 실패하지 않아야하며 명령을 한 번만 호출하는 것과 동일한 작업을 수행해야합니다. 즉, 주 모드 명령은 멱등이어야합니다.</target>
        </trans-unit>
        <trans-unit id="1e6c66b20a23a26c0a918b56cec3c86770820c22" translate="yes" xml:space="preserve">
          <source>Calling this function explicitly is useful for splitting the effects of a command into more than one unit. For example, &lt;code&gt;query-replace&lt;/code&gt; calls &lt;code&gt;undo-boundary&lt;/code&gt; after each replacement, so that the user can undo individual replacements one by one.</source>
          <target state="translated">이 함수를 명시 적으로 호출하면 명령의 효과를 하나 이상의 단위로 분할하는 데 유용합니다. 예를 들어 &lt;code&gt;query-replace&lt;/code&gt; 는 각 교체 후 &lt;code&gt;undo-boundary&lt;/code&gt; 호출 하므로 사용자가 개별 교체를 하나씩 실행 취소 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a5bda3d28236066116676706c47de1d0f0328a6" translate="yes" xml:space="preserve">
          <source>Calling this function is sufficient to make commands such as &lt;code&gt;forward-sexp&lt;/code&gt;, &lt;code&gt;backward-sexp&lt;/code&gt;, and &lt;code&gt;transpose-sexps&lt;/code&gt; be able to properly handle structural elements other than just the paired parentheses already handled by syntax tables. For example, if the provided grammar is precise enough, &lt;code&gt;transpose-sexps&lt;/code&gt; can correctly transpose the two arguments of a &lt;code&gt;+&lt;/code&gt; operator, taking into account the precedence rules of the language.</source>
          <target state="translated">이 함수를 호출하면 &lt;code&gt;forward-sexp&lt;/code&gt; , &lt;code&gt;backward-sexp&lt;/code&gt; 및 &lt;code&gt;transpose-sexps&lt;/code&gt; -sexp 와 같은 명령 이 구문 테이블에서 이미 처리 한 쌍을 이루는 괄호 이외의 구조 요소를 적절하게 처리 할 수 ​​있습니다. 예를 들어 제공된 문법이 충분히 정확하면 &lt;code&gt;transpose-sexps&lt;/code&gt; 는 언어의 우선 순위 규칙을 고려하여 &lt;code&gt;+&lt;/code&gt; 연산자 의 두 인수를 올바르게 전치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5b34fd5a2e36cd4eafb9c4fcecc3d11f251e2e3" translate="yes" xml:space="preserve">
          <source>Cannot determine image type</source>
          <target state="translated">이미지 유형을 확인할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c1186dd76154d57de923217a8dd3d16441be124a" translate="yes" xml:space="preserve">
          <source>Cannot open load file &lt;var&gt;filename&lt;/var&gt;</source>
          <target state="translated">로드 파일 파일 &lt;var&gt;filename&lt;/var&gt; 열 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="311dff8ce71dc0b4b0666e7280ad010d93e7918a" translate="yes" xml:space="preserve">
          <source>Capture groups</source>
          <target state="translated">캡처 그룹</target>
        </trans-unit>
        <trans-unit id="5fe52af8b2d198c370691f5d3a5caec003b55dcc" translate="yes" xml:space="preserve">
          <source>Case Changes</source>
          <target state="translated">케이스 변경</target>
        </trans-unit>
        <trans-unit id="ff5641735ee7c07e5eed18f7107abe940e61dcc3" translate="yes" xml:space="preserve">
          <source>Case Conversion in Lisp</source>
          <target state="translated">Lisp에서 케이스 변환</target>
        </trans-unit>
        <trans-unit id="ee05e5edf5d51051d5e8ea58e5fb1140b748c002" translate="yes" xml:space="preserve">
          <source>Case conversion functions.</source>
          <target state="translated">대소 문자 변환 기능.</target>
        </trans-unit>
        <trans-unit id="4fc7e1d52f22796c47c268de900d6e7082017f5a" translate="yes" xml:space="preserve">
          <source>Case conversion of parts of the buffer.</source>
          <target state="translated">버퍼 부분의 케이스 변환.</target>
        </trans-unit>
        <trans-unit id="60f886006f4b5be396aef39220ae04232401704b" translate="yes" xml:space="preserve">
          <source>Case tables (see &lt;a href=&quot;case-tables#Case-Tables&quot;&gt;Case Tables&lt;/a&gt;).</source>
          <target state="translated">사례 테이블 (참조 &lt;a href=&quot;case-tables#Case-Tables&quot;&gt;사례 테이블&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="760a611d6b77c0b6b7da5b461fa97629808e415a" translate="yes" xml:space="preserve">
          <source>Case-independent or case-significant searching.</source>
          <target state="translated">대소 문자 독립적 또는 대소 문자 구분 검색.</target>
        </trans-unit>
        <trans-unit id="6ccb60071be8f00760a3824d9f7d0fad57de789f" translate="yes" xml:space="preserve">
          <source>Categories</source>
          <target state="translated">Categories</target>
        </trans-unit>
        <trans-unit id="c62bb44b2dbb1eab36c5fe60b6989181f7595720" translate="yes" xml:space="preserve">
          <source>Category character</source>
          <target state="translated">카테고리 캐릭터</target>
        </trans-unit>
        <trans-unit id="ed3dc45ada47ab5b03a62a82e4fe63e2c08a4aa5" translate="yes" xml:space="preserve">
          <source>Category name</source>
          <target state="translated">카테고리 이름</target>
        </trans-unit>
        <trans-unit id="21ee11841e5216e7932316a3ba9dbe3bf176d378" translate="yes" xml:space="preserve">
          <source>Causes the server to suppress playing any sounds, if it has that ability.</source>
          <target state="translated">서버에 해당 기능이있는 경우 사운드 재생을 억제합니다.</target>
        </trans-unit>
        <trans-unit id="bcaa33a7ae44bd5042c37a9cdbea7f843b1cf7c8" translate="yes" xml:space="preserve">
          <source>Caveats</source>
          <target state="translated">Caveats</target>
        </trans-unit>
        <trans-unit id="983a41bf08948cb10ca36f96d754fedb2fa51108" translate="yes" xml:space="preserve">
          <source>Caveats for &lt;var&gt;symbol&lt;/var&gt; in Sequencing Patterns</source>
          <target state="translated">시퀀싱 패턴의 &lt;var&gt;symbol&lt;/var&gt; 에 대한주의 사항</target>
        </trans-unit>
        <trans-unit id="10c846191e34dad7942410f081d90ef9a60dccb4" translate="yes" xml:space="preserve">
          <source>Certain &lt;em&gt;special events&lt;/em&gt; are handled at a very low level&amp;mdash;as soon as they are read. The &lt;code&gt;read-event&lt;/code&gt; function processes these events itself, and never returns them. Instead, it keeps waiting for the first event that is not special and returns that one.</source>
          <target state="translated">특정 &lt;em&gt;특수 이벤트&lt;/em&gt; 는 읽는 즉시 매우 낮은 수준에서 처리됩니다. &lt;code&gt;read-event&lt;/code&gt; 기능은 이러한 이벤트 자체를 처리하고이를 반환하지 않습니다. 대신 특별하지 않은 첫 번째 이벤트를 계속 기다리고 해당 이벤트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2668c38616b8f82385530ab10556316664076de7" translate="yes" xml:space="preserve">
          <source>Certain abbrevs, called &lt;em&gt;system abbrevs&lt;/em&gt;, are defined by a major mode instead of the user. A system abbrev is identified by its non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;:system&lt;/code&gt; property (see &lt;a href=&quot;abbrev-properties#Abbrev-Properties&quot;&gt;Abbrev Properties&lt;/a&gt;). When abbrevs are saved to an abbrev file, system abbrevs are omitted. See &lt;a href=&quot;abbrev-files#Abbrev-Files&quot;&gt;Abbrev Files&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;system abbrevs&lt;/em&gt; 라고하는 특정 약어 는 사용자 대신 주 모드로 정의됩니다. 시스템 abbrev는 &lt;code&gt;nil&lt;/code&gt; 이 아닌 &lt;code&gt;:system&lt;/code&gt; 속성으로 식별됩니다 ( &lt;a href=&quot;abbrev-properties#Abbrev-Properties&quot;&gt;Abbrev 속성&lt;/a&gt; 참조 ). 약어가 약어 파일에 저장되면 시스템 약어가 생략됩니다. &lt;a href=&quot;abbrev-files#Abbrev-Files&quot;&gt;Abbrev 파일을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bb70bbca935cc9ba0d3270144cb857746601caf3" translate="yes" xml:space="preserve">
          <source>Certain format specifications require values of particular types. If you supply a value that doesn&amp;rsquo;t fit the requirements, an error is signaled.</source>
          <target state="translated">특정 형식 사양에는 특정 유형의 값이 필요합니다. 요구 사항에 맞지 않는 값을 제공하면 오류가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="17f9520304f622d054d6e6a095bc91eb04688136" translate="yes" xml:space="preserve">
          <source>Certain function-like objects, called &lt;em&gt;special forms&lt;/em&gt; and &lt;em&gt;macros&lt;/em&gt;, also accept arguments to carry out computations. However, as explained below, these are not considered functions in Emacs Lisp.</source>
          <target state="translated">&lt;em&gt;특수 형식&lt;/em&gt; 및 &lt;em&gt;매크로&lt;/em&gt; 라고하는 특정 함수와 유사한 객체 도 계산을 수행하기 위해 인수를받습니다. 그러나 아래에 설명 된대로 Emacs Lisp에서는 이러한 기능이 고려되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a3317a453486426103c83a8405cdf6293656cb02" translate="yes" xml:space="preserve">
          <source>Certain functions such as &lt;code&gt;read-key-sequence&lt;/code&gt; or &lt;code&gt;read-quoted-char&lt;/code&gt; prevent quitting entirely even though they wait for input. Instead of quitting,</source>
          <target state="translated">&lt;code&gt;read-key-sequence&lt;/code&gt; 또는 &lt;code&gt;read-quoted-char&lt;/code&gt; 와 같은 특정 함수 는 입력을 기다리더라도 완전히 종료되는 것을 방지합니다. 그만두는 대신</target>
        </trans-unit>
        <trans-unit id="9781a84dc281e4b3ac7e8fb884e18e00f10c91d8" translate="yes" xml:space="preserve">
          <source>Certain other values of &lt;var&gt;separator-type&lt;/var&gt; specify a different style of separator. Here is a table of them:</source>
          <target state="translated">다른 &lt;var&gt;separator-type&lt;/var&gt; 값은 다른 구분 기호 스타일을 지정합니다. 다음은 그 테이블입니다.</target>
        </trans-unit>
        <trans-unit id="b28516fbcb8e500a178b2a631de8639fdef46b0f" translate="yes" xml:space="preserve">
          <source>Certain text properties are meaningful in the mode line. The &lt;code&gt;face&lt;/code&gt; property affects the appearance of text; the &lt;code&gt;help-echo&lt;/code&gt; property associates help strings with the text, and &lt;code&gt;keymap&lt;/code&gt; can make the text mouse-sensitive.</source>
          <target state="translated">특정 텍스트 속성은 모드 라인에서 의미가 있습니다. &lt;code&gt;face&lt;/code&gt; 속성은 텍스트의 모양에 영향을 미친다; &lt;code&gt;help-echo&lt;/code&gt; 부동산 동료 도움말 텍스트와 문자열 및 &lt;code&gt;keymap&lt;/code&gt; 텍스트를 마우스 민감 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78b3210742dadf1e3c0eabba8c8ed5204a166dda" translate="yes" xml:space="preserve">
          <source>Change Hooks</source>
          <target state="translated">후크 변경</target>
        </trans-unit>
        <trans-unit id="b474b780b926dcbfa75d96cb86ad31c3233c390b" translate="yes" xml:space="preserve">
          <source>Change the font-related attributes of &lt;var&gt;face&lt;/var&gt; to those of &lt;var&gt;font&lt;/var&gt; (a string or a font object). See &lt;a href=&quot;face-attributes#face_002dfont_002dattribute&quot;&gt;face-font-attribute&lt;/a&gt;, for the supported formats of the &lt;var&gt;font&lt;/var&gt; argument. This function sets the attribute &lt;code&gt;:font&lt;/code&gt; of the face, and indirectly also the &lt;code&gt;:family&lt;/code&gt;, &lt;code&gt;:foundry&lt;/code&gt;, &lt;code&gt;:width&lt;/code&gt;, &lt;code&gt;:height&lt;/code&gt;, &lt;code&gt;:weight&lt;/code&gt;, and &lt;code&gt;:slant&lt;/code&gt; attributes, as defined by the font. If &lt;var&gt;frame&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, only change the attributes on the specified frame.</source>
          <target state="translated">의 글꼴 관련 속성 변경 &lt;var&gt;face&lt;/var&gt; 가진 자에게 &lt;var&gt;font&lt;/var&gt; (문자열이나 폰트 객체). &lt;var&gt;font&lt;/var&gt; 인수 의 지원되는 형식은 &lt;a href=&quot;face-attributes#face_002dfont_002dattribute&quot;&gt;face-font-attribute를&lt;/a&gt; 참조하십시오 . 이 함수는 &lt;code&gt;:font&lt;/code&gt; 에 정의 된대로 얼굴의 : font 속성 과 &lt;code&gt;:family&lt;/code&gt; , &lt;code&gt;:foundry&lt;/code&gt; , &lt;code&gt;:width&lt;/code&gt; , &lt;code&gt;:height&lt;/code&gt; , &lt;code&gt;:weight&lt;/code&gt; 및 &lt;code&gt;:slant&lt;/code&gt; 속성을 간접적으로 설정합니다 . &lt;var&gt;frame&lt;/var&gt; 이 &lt;code&gt;nil&lt;/code&gt; 이 아니면 지정된 프레임의 속성 만 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="100a984c74cd76a27c5abd1250aa8a0325533085" translate="yes" xml:space="preserve">
          <source>Changes in process sentinels take effect immediately&amp;mdash;if the sentinel is slated to be run but has not been called yet, and you specify a new sentinel, the eventual call to the sentinel will use the new one.</source>
          <target state="translated">프로세스 센티넬의 변경 사항은 즉시 적용됩니다. 센티넬이 실행될 예정이지만 아직 호출되지 않은 상태에서 새 센티넬을 지정하면 센티넬에 대한 최종 호출에서 새 센티널을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="156524b67d9176e9980be07f37b022c85504061b" translate="yes" xml:space="preserve">
          <source>Changing File Names and Attributes</source>
          <target state="translated">파일 이름 및 속성 변경</target>
        </trans-unit>
        <trans-unit id="51016b235a030223e05c662ad0783ea8a9b72574" translate="yes" xml:space="preserve">
          <source>Changing Key Bindings</source>
          <target state="translated">키 바인딩 변경</target>
        </trans-unit>
        <trans-unit id="7594cb533c4a496e3f17056c9667959d56338aee" translate="yes" xml:space="preserve">
          <source>Changing Text Properties</source>
          <target state="translated">텍스트 속성 변경</target>
        </trans-unit>
        <trans-unit id="de45395bd6cb72dc2da08ba6aae7cf507d1e0f7f" translate="yes" xml:space="preserve">
          <source>Changing any of the &lt;code&gt;scroll-bar-width&lt;/code&gt;, &lt;code&gt;scroll-bar-height&lt;/code&gt;, &lt;code&gt;vertical-scroll-bars&lt;/code&gt;, &lt;code&gt;horizontal-scroll-bars&lt;/code&gt;, &lt;code&gt;left-fringe&lt;/code&gt; and &lt;code&gt;right-fringe&lt;/code&gt; frame parameters is handled as if the frame contained just one live window. This means, for example, that removing vertical scroll bars on a frame containing several side by side windows will shrink the outer frame width by the width of one scroll bar provided this option is &lt;code&gt;nil&lt;/code&gt; and keep it unchanged if this option is &lt;code&gt;t&lt;/code&gt; or a list containing &lt;code&gt;vertical-scroll-bars&lt;/code&gt;.</source>
          <target state="translated">의 모든 변경 &lt;code&gt;scroll-bar-width&lt;/code&gt; , &lt;code&gt;scroll-bar-height&lt;/code&gt; , &lt;code&gt;vertical-scroll-bars&lt;/code&gt; , &lt;code&gt;horizontal-scroll-bars&lt;/code&gt; , &lt;code&gt;left-fringe&lt;/code&gt; 와 &lt;code&gt;right-fringe&lt;/code&gt; 프레임이 하나의 라이브 창을 포함 것처럼 프레임 매개 변수 처리됩니다. 예를 들어, 여러 개의 나란히있는 창을 포함하는 프레임에서 세로 스크롤 막대를 제거하면이 옵션이 &lt;code&gt;nil&lt;/code&gt; 인 경우 외부 프레임 너비가 하나의 스크롤 막대 너비만큼 축소 되고이 옵션이 &lt;code&gt;t&lt;/code&gt; 또는 목록 이면 변경되지 않습니다. &lt;code&gt;vertical-scroll-bars&lt;/code&gt; 포함 .</target>
        </trans-unit>
        <trans-unit id="fd7f426a8c11556d236e6fe7c9beb52aa001a64a" translate="yes" xml:space="preserve">
          <source>Changing point.</source>
          <target state="translated">포인트 변경.</target>
        </trans-unit>
        <trans-unit id="35bbf3ed9b965bfacb89f9f800e62d4fe12c4c01" translate="yes" xml:space="preserve">
          <source>Changing the &lt;small&gt;CAR&lt;/small&gt; of a cons cell is done with &lt;code&gt;setcar&lt;/code&gt;. When used on a list, &lt;code&gt;setcar&lt;/code&gt; replaces one element of a list with a different element.</source>
          <target state="translated">cons 셀 의 &lt;small&gt;CAR&lt;/small&gt; 변경은 &lt;code&gt;setcar&lt;/code&gt; 로 수행됩니다 . 목록에서 사용되는 경우 &lt;code&gt;setcar&lt;/code&gt; 는 목록의 한 요소를 다른 요소로 대체합니다.</target>
        </trans-unit>
        <trans-unit id="562e2b4207b6c404cf6c751160157bd49ac95781" translate="yes" xml:space="preserve">
          <source>Changing the sizes of windows.</source>
          <target state="translated">창 크기 변경.</target>
        </trans-unit>
        <trans-unit id="6a1f8e8787fc1acb606cc50f5b6e9d8f7bdd458d" translate="yes" xml:space="preserve">
          <source>Changing this variable does not force an update of the mode line.</source>
          <target state="translated">이 변수를 변경해도 모드 행이 강제로 업데이트되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="f0c739408abd052ee5d44db4e8e0adc91f0b680a" translate="yes" xml:space="preserve">
          <source>Char-Table Type</source>
          <target state="translated">Char-Table 유형</target>
        </trans-unit>
        <trans-unit id="ce090131f8a640a66d14740f37efd79c98da2f52" translate="yes" xml:space="preserve">
          <source>Char-Tables</source>
          <target state="translated">Char-Tables</target>
        </trans-unit>
        <trans-unit id="89a0d26064c88761be4481b9b52065531e5e024c" translate="yes" xml:space="preserve">
          <source>Character Classes</source>
          <target state="translated">캐릭터 클래스</target>
        </trans-unit>
        <trans-unit id="8cd166d7b5c972d19c78d965c26afe0d852a6bbc" translate="yes" xml:space="preserve">
          <source>Character Codes</source>
          <target state="translated">문자 코드</target>
        </trans-unit>
        <trans-unit id="198408dd9120e5714424c5f00fa2e02c78a9427b" translate="yes" xml:space="preserve">
          <source>Character Display</source>
          <target state="translated">캐릭터 디스플레이</target>
        </trans-unit>
        <trans-unit id="b1c5fa0155ae3ab9ad380fa3cfc349d0a0ec23e9" translate="yes" xml:space="preserve">
          <source>Character Properties</source>
          <target state="translated">캐릭터 속성</target>
        </trans-unit>
        <trans-unit id="0e7c11d7a7200a36005057b0e953e12aae6033f0" translate="yes" xml:space="preserve">
          <source>Character Sets</source>
          <target state="translated">문자 세트</target>
        </trans-unit>
        <trans-unit id="275450cc1e4926b0829cc65cd3f2b3d835f4e048" translate="yes" xml:space="preserve">
          <source>Character Type</source>
          <target state="translated">문자 유형</target>
        </trans-unit>
        <trans-unit id="ea8d87953a98f75b2aa021b7b8cb876f766bf6b9" translate="yes" xml:space="preserve">
          <source>Character attributes that define their behavior and handling.</source>
          <target state="translated">행동과 처리를 정의하는 캐릭터 속성.</target>
        </trans-unit>
        <trans-unit id="5978dbfeccf01151025eeaa59ed56b27e00fec9f" translate="yes" xml:space="preserve">
          <source>Character category tables (see &lt;a href=&quot;categories#Categories&quot;&gt;Categories&lt;/a&gt;).</source>
          <target state="translated">문자 분류 표 (참조 &lt;a href=&quot;categories#Categories&quot;&gt;카테고리&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="9755699503a79e3114d0435a6c41d83696a2d623" translate="yes" xml:space="preserve">
          <source>Character classes used in regular expressions.</source>
          <target state="translated">정규식에 사용되는 문자 클래스.</target>
        </trans-unit>
        <trans-unit id="1d5a2032f34ffea795feb6720457cf5de1c95dbd" translate="yes" xml:space="preserve">
          <source>Character quotes: &amp;lsquo;</source>
          <target state="translated">문자 따옴표 : '</target>
        </trans-unit>
        <trans-unit id="d4eeaab110722d926fe33c40dc614e75f6d0aef8" translate="yes" xml:space="preserve">
          <source>Characteristics of arrays in Emacs Lisp.</source>
          <target state="translated">Emacs Lisp에서 배열의 특성.</target>
        </trans-unit>
        <trans-unit id="7295605dcc69f48d0631634d8294614f5cae238b" translate="yes" xml:space="preserve">
          <source>Characters for which there is no suitable font, or which cannot be encoded by the terminal&amp;rsquo;s coding system.</source>
          <target state="translated">적합한 글꼴이 없거나 터미널의 코딩 시스템에서 인코딩 할 수없는 문자입니다.</target>
        </trans-unit>
        <trans-unit id="f395a989f7613a08007721455bd0e01ef846f3c5" translate="yes" xml:space="preserve">
          <source>Characters in strings and buffers are currently limited to the range of 0 to 4194303&amp;mdash;twenty two bits (see &lt;a href=&quot;character-codes#Character-Codes&quot;&gt;Character Codes&lt;/a&gt;). Codes 0 through 127 are</source>
          <target state="translated">문자열과 버퍼의 문자는 현재 0에서 4194303 (22 비트) 범위로 제한됩니다 ( &lt;a href=&quot;character-codes#Character-Codes&quot;&gt;문자 코드&lt;/a&gt; 참조 ). 코드 0 ~ 127은</target>
        </trans-unit>
        <trans-unit id="2f2d8febd021625a726bddcf901f92bcf114c32e" translate="yes" xml:space="preserve">
          <source>Characters in this class count as part of words if &lt;code&gt;words-include-escapes&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;. See &lt;a href=&quot;word-motion#Word-Motion&quot;&gt;Word Motion&lt;/a&gt;.</source>
          <target state="translated">이 클래스의 문자는 &lt;code&gt;words-include-escapes&lt;/code&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 단어의 일부로 간주됩니다 . &lt;a href=&quot;word-motion#Word-Motion&quot;&gt;Word Motion을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2a10df5b911a93e079b9555a76636c96ac49a9a5" translate="yes" xml:space="preserve">
          <source>Characters of Unicode General Category [Cf], such as U+200E &lt;small&gt;LEFT-TO-RIGHT MARK&lt;/small&gt;, but excluding characters that have graphic images, such as U+00AD &lt;small&gt;SOFT HYPHEN&lt;/small&gt;.</source>
          <target state="translated">U + 200E &lt;small&gt;LEFT-TO-RIGHT MARK&lt;/small&gt; 와 같은 유니 코드 일반 범주 [Cf]의 문자이지만 U + 00AD &lt;small&gt;SOFT HYPHEN&lt;/small&gt; 과 같은 그래픽 이미지가있는 문자는 제외 됩니다.</target>
        </trans-unit>
        <trans-unit id="d64597528b4665933dfaeebfdafad56f74f0e55b" translate="yes" xml:space="preserve">
          <source>Characters that have the property &lt;code&gt;inhibit-read-only&lt;/code&gt; can be edited even in read-only buffers. See &lt;a href=&quot;read-only-buffers#Read-Only-Buffers&quot;&gt;Read Only Buffers&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;inhibit-read-only&lt;/code&gt; 속성이있는 문자 는 읽기 전용 버퍼에서도 편집 할 수 있습니다. &lt;a href=&quot;read-only-buffers#Read-Only-Buffers&quot;&gt;읽기 전용 버퍼를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e63d767e9c8b2c1671e34752b2089312848063bf" translate="yes" xml:space="preserve">
          <source>Characters that separate symbols and words from each other. Typically, whitespace characters have no other syntactic significance, and multiple whitespace characters are syntactically equivalent to a single one. Space, tab, and formfeed are classified as whitespace in almost all major modes.</source>
          <target state="translated">기호와 단어를 서로 구분하는 문자입니다. 일반적으로 공백 문자는 다른 구문 상 의미가 없으며 여러 공백 문자는 구문 상 단일 문자와 동일합니다. 스페이스, 탭 및 폼 피드는 거의 모든 주요 모드에서 공백으로 분류됩니다.</target>
        </trans-unit>
        <trans-unit id="fa30e64c5637f1d5a32a9a352ecb5ba52a350acf" translate="yes" xml:space="preserve">
          <source>Characters that start an escape sequence, such as is used in string and character constants. The character &amp;lsquo;</source>
          <target state="translated">이스케이프 시퀀스를 시작하는 문자 (예 : 문자열 및 문자 상수에 사용됨). 캐릭터 '</target>
        </trans-unit>
        <trans-unit id="c81c548b4c8ec05d54666a049f54eb670318ccea" translate="yes" xml:space="preserve">
          <source>Characters that start or end a special kind of comment. &lt;em&gt;Any&lt;/em&gt; generic comment delimiter matches &lt;em&gt;any&lt;/em&gt; generic comment delimiter, but they cannot match a comment starter or comment ender; generic comment delimiters can only match each other.</source>
          <target state="translated">특별한 종류의 주석을 시작하거나 종료하는 문자입니다. &lt;em&gt;모든&lt;/em&gt; 일반적인 주석 구분 기호와 일치하는 &lt;em&gt;모든&lt;/em&gt; 일반적인 주석 구분 기호를,하지만 그들은 코멘트 스타터 또는 주석 청산과 일치하지 수 일반 주석 구분 기호는 서로 만 일치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac7296c49b8b1a6c9dc8eb94911bbbba5328c176" translate="yes" xml:space="preserve">
          <source>Characters that start or end a string. This class differs from the string quote class in that &lt;em&gt;any&lt;/em&gt; generic string delimiter can match any other generic string delimiter; but they do not match ordinary string quote characters.</source>
          <target state="translated">문자열의 시작 또는 끝 문자. 점에서 문자열 인용 클래스이 클래스는 다릅니다 &lt;em&gt;어떤&lt;/em&gt; 일반적인 문자열 구분 기호는 다른 일반적인 문자열 구분 기호를 일치시킬 수 있습니다; 그러나 그들은 일반 문자열 인용 문자와 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="878c9eb0cca3656e2070d507e9c66472d4b16d58" translate="yes" xml:space="preserve">
          <source>Characters used as punctuation in a human language, or used in a programming language to separate symbols from one another. Some programming language modes, such as Emacs Lisp mode, have no characters in this class since the few characters that are not symbol or word constituents all have other uses. Other programming language modes, such as C mode, use punctuation syntax for operators.</source>
          <target state="translated">인간 언어에서 구두점으로 사용되거나 기호를 서로 구분하기 위해 프로그래밍 언어에서 사용되는 문자입니다. Emacs Lisp 모드와 같은 일부 프로그래밍 언어 모드는 기호 또는 단어 구성 요소가 아닌 소수의 문자가 모두 다른 용도로 사용되기 때문에이 클래스에 문자가 없습니다. C 모드와 같은 다른 프로그래밍 언어 모드는 연산자에 구두점 구문을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="06f7786b4e99ee5ceb3cb305cfc63a98ff812c14" translate="yes" xml:space="preserve">
          <source>Characters used for syntactic operators that are considered as part of an expression if they appear next to one. In Lisp modes, these characters include the apostrophe, &amp;lsquo;</source>
          <target state="translated">옆에 표시되는 경우 표현식의 일부로 간주되는 구문 연산자에 사용되는 문자입니다. Lisp 모드에서 이러한 문자에는 아포스트로피 '</target>
        </trans-unit>
        <trans-unit id="b0de87a3961de259dc33f8a42911d09393a940b8" translate="yes" xml:space="preserve">
          <source>Characters used in dissimilar pairs to surround sentences or expressions. Such a grouping is begun with an open parenthesis character and terminated with a close. Each open parenthesis character matches a particular close parenthesis character, and vice versa. Normally, Emacs indicates momentarily the matching open parenthesis when you insert a close parenthesis. See &lt;a href=&quot;blinking#Blinking&quot;&gt;Blinking&lt;/a&gt;.</source>
          <target state="translated">문장이나 표현을 둘러싸 기 위해 서로 다른 쌍으로 사용되는 문자입니다. 이러한 그룹화는 여는 괄호 문자로 시작되고 닫기로 끝납니다. 각 여는 괄호 문자는 특정 닫는 괄호 문자와 일치하며 그 반대의 경우도 마찬가지입니다. 일반적으로 Emacs는 닫는 괄호를 삽입 할 때 일치하는 여는 괄호를 일시적으로 나타냅니다. &lt;a href=&quot;blinking#Blinking&quot;&gt;깜박임을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4150dd70fbcba800bf39a3d8687d1d7aeb5b8bb0" translate="yes" xml:space="preserve">
          <source>Characters used in various languages to delimit comments. Human text has no comment characters. In Lisp, the semicolon (&amp;lsquo;</source>
          <target state="translated">주석을 구분하기 위해 다양한 언어로 사용되는 문자. 휴먼 텍스트에는 주석 문자가 없습니다. Lisp에서 세미콜론 ( '</target>
        </trans-unit>
        <trans-unit id="48fc8012fa06ff8528f92e294cf2c321f8c94197" translate="yes" xml:space="preserve">
          <source>Characters used to delimit string constants. The same string quote character appears at the beginning and the end of a string. Such quoted strings do not nest.</source>
          <target state="translated">문자열 상수를 구분하는 데 사용되는 문자입니다. 동일한 문자열 인용 문자가 문자열의 시작과 끝에 나타납니다. 이러한 인용 된 문자열은 중첩되지 않습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
