<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="elisp">
    <body>
      <group id="elisp">
        <trans-unit id="7d5d7ee8f609d032732725e8d3c8c089bc52554d" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;push-mark&lt;/code&gt; normally &lt;em&gt;does not&lt;/em&gt; activate the mark. To do that, specify &lt;code&gt;t&lt;/code&gt; for the argument &lt;var&gt;activate&lt;/var&gt;.</source>
          <target state="translated">기능 &lt;code&gt;push-mark&lt;/code&gt; 일반적으로 마크를 활성화 &lt;em&gt;하지 않습니다&lt;/em&gt; . 이를 수행하려면 &lt;var&gt;activate&lt;/var&gt; 인수에 &lt;code&gt;t&lt;/code&gt; 를 지정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="e9fa560f2451740cc751b4488378f30d7e73bffc" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;read-key-sequence&lt;/code&gt; also transforms some mouse events. It converts unbound drag events into click events, and discards unbound button-down events entirely. It also reshuffles focus events and miscellaneous window events so that they never appear in a key sequence with any other events.</source>
          <target state="translated">&lt;code&gt;read-key-sequence&lt;/code&gt; 함수 는 또한 일부 마우스 이벤트를 변환합니다. 바인딩되지 않은 드래그 이벤트를 클릭 이벤트로 변환하고 바인딩되지 않은 버튼 다운 이벤트를 완전히 버립니다. 또한 포커스 이벤트와 기타 창 이벤트를 다시 섞어 다른 이벤트와 함께 키 시퀀스에 나타나지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="411c4d145671b4036ab4f7cb6fa9e30b7580ebe1" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;read-key-sequence&lt;/code&gt; ignores any button-down events that don&amp;rsquo;t have command bindings; therefore, the Emacs command loop ignores them too. This means that you need not worry about defining button-down events unless you want them to do something. The usual reason to define a button-down event is so that you can track mouse motion (by reading motion events) until the button is released. See &lt;a href=&quot;motion-events#Motion-Events&quot;&gt;Motion Events&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;read-key-sequence&lt;/code&gt; 함수 는 명령 바인딩이없는 버튼 다운 이벤트를 무시합니다. 따라서 Emacs 명령 루프도이를 무시합니다. 이것은 당신이 무언가를 원하지 않는 한 버튼 다운 이벤트를 정의하는 것에 대해 걱정할 필요가 없다는 것을 의미합니다. 버튼 다운 이벤트를 정의하는 일반적인 이유는 버튼을 놓을 때까지 마우스 모션 (모션 이벤트 읽기)을 추적 할 수 있기 때문입니다. &lt;a href=&quot;motion-events#Motion-Events&quot;&gt;모션 이벤트를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="eba65b635c04edcaac2d00aa8b06564194485459" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;read-key-sequence&lt;/code&gt; suppresses quitting:</source>
          <target state="translated">&lt;code&gt;read-key-sequence&lt;/code&gt; 함수 는 종료를 억제합니다.</target>
        </trans-unit>
        <trans-unit id="56cd8086393902fb3f2fd966bb33828c275959f0" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;read-regexp&lt;/code&gt; may use the value of this variable to determine its list of default regular expressions. If non-&lt;code&gt;nil&lt;/code&gt;, the value of this variable should be either:</source>
          <target state="translated">&lt;code&gt;read-regexp&lt;/code&gt; 함수 는이 변수의 값을 사용하여 기본 정규식 목록을 결정할 수 있습니다. &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우이 변수의 값은 다음 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="bfc9d89212eee790f8bef26e1a7f3b5f75f045d1" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;redraw-frame&lt;/code&gt; clears and redisplays the entire contents of a given frame (see &lt;a href=&quot;frames#Frames&quot;&gt;Frames&lt;/a&gt;). This is useful if the screen is corrupted.</source>
          <target state="translated">기능 &lt;code&gt;redraw-frame&lt;/code&gt; 지우고 다시 표시하고, 주어진 프레임의 전체 내용은 (참조 &lt;a href=&quot;frames#Frames&quot;&gt;프레임&lt;/a&gt; ). 화면이 손상된 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="bbfc0c7e3b7ab2136aac8aac4311c80559dc8786" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;run-at-time&lt;/code&gt; returns a timer value that identifies the particular scheduled future action. You can use this value to call &lt;code&gt;cancel-timer&lt;/code&gt; (see below).</source>
          <target state="translated">&lt;code&gt;run-at-time&lt;/code&gt; 함수 는 예정된 특정 미래 작업을 식별하는 타이머 값을 반환합니다. 이 값을 사용하여 &lt;code&gt;cancel-timer&lt;/code&gt; 를 호출 할 수 있습니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="ebf16908ab8cdf77cbe0ed4cf8fac00f9d1be78c" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;run-with-idle-timer&lt;/code&gt; returns a timer value which you can use in calling &lt;code&gt;cancel-timer&lt;/code&gt; (see &lt;a href=&quot;timers#Timers&quot;&gt;Timers&lt;/a&gt;).</source>
          <target state="translated">기능 &lt;code&gt;run-with-idle-timer&lt;/code&gt; 반환 당신이 전화에서 사용할 수있는 타이머 값 &lt;code&gt;cancel-timer&lt;/code&gt; 합니다 ( &lt;a href=&quot;timers#Timers&quot;&gt;타이머&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c8d58a42db5f4f64609112ba848f62aa4f6033e5" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;signal&lt;/code&gt; never returns.</source>
          <target state="translated">함수 &lt;code&gt;signal&lt;/code&gt; 는 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e957fc96b50a902c38bbd9080cce211dda054fa5" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;split-window&lt;/code&gt; (see &lt;a href=&quot;splitting-windows#Splitting-Windows&quot;&gt;Splitting Windows&lt;/a&gt;), when applied to a constituent of an atomic window, will try to create the new window outside of the atomic window.</source>
          <target state="translated">&lt;code&gt;split-window&lt;/code&gt; 함수 ( 창 &lt;a href=&quot;splitting-windows#Splitting-Windows&quot;&gt;분할&lt;/a&gt; 참조 )는 원자 창의 구성 요소에 적용될 때 원자 창 외부에 새 창을 만들려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="6df956fe28921ed43fa43bd2788b8f0492e99c5e" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;substitute-key-definition&lt;/code&gt; scans a keymap for keys that have a certain binding and rebinds them with a different binding. Another feature which is cleaner and can often produce the same results is to remap one command into another (see &lt;a href=&quot;remapping-commands#Remapping-Commands&quot;&gt;Remapping Commands&lt;/a&gt;).</source>
          <target state="translated">함수 &lt;code&gt;substitute-key-definition&lt;/code&gt; 은 특정 바인딩이있는 키의 키맵을 스캔하고 다른 바인딩으로 다시 바인딩합니다. 더 깔끔하고 종종 동일한 결과를 생성 할 수있는 또 다른 기능은 한 명령을 다른 명령으로 다시 매핑하는 것입니다 (명령 &lt;a href=&quot;remapping-commands#Remapping-Commands&quot;&gt;다시 매핑&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="bc471743e21a847c0361cb115c2214f8054e6289" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;syms_of_&lt;var&gt;filename&lt;/var&gt;&lt;/code&gt; is also the place to define any C variables that are to be visible as Lisp variables. &lt;code&gt;DEFVAR_LISP&lt;/code&gt; makes a C variable of type &lt;code&gt;Lisp_Object&lt;/code&gt; visible in Lisp. &lt;code&gt;DEFVAR_INT&lt;/code&gt; makes a C variable of type &lt;code&gt;int&lt;/code&gt; visible in Lisp with a value that is always an integer. &lt;code&gt;DEFVAR_BOOL&lt;/code&gt; makes a C variable of type &lt;code&gt;int&lt;/code&gt; visible in Lisp with a value that is either &lt;code&gt;t&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;. Note that variables defined with &lt;code&gt;DEFVAR_BOOL&lt;/code&gt; are automatically added to the list &lt;code&gt;byte-boolean-vars&lt;/code&gt; used by the byte compiler.</source>
          <target state="translated">&lt;code&gt;syms_of_&lt;var&gt;filename&lt;/var&gt;&lt;/code&gt; 함수 는 Lisp 변수로 표시되는 C 변수를 정의하는 장소이기도합니다. &lt;code&gt;DEFVAR_LISP&lt;/code&gt; 는 Lisp에서 &lt;code&gt;Lisp_Object&lt;/code&gt; 유형의 C 변수를 표시합니다. &lt;code&gt;DEFVAR_INT&lt;/code&gt; 는 항상 정수인 값으로 Lisp에서 &lt;code&gt;int&lt;/code&gt; 유형의 C 변수를 표시합니다. &lt;code&gt;DEFVAR_BOOL&lt;/code&gt; 은 &lt;code&gt;t&lt;/code&gt; 또는 &lt;code&gt;nil&lt;/code&gt; 값으로 Lisp에서 &lt;code&gt;int&lt;/code&gt; 유형의 C 변수를 표시 합니다. &lt;code&gt;DEFVAR_BOOL&lt;/code&gt; 로 정의 된 변수 는 바이트 컴파일러에서 사용하는 &lt;code&gt;byte-boolean-vars&lt;/code&gt; 목록에 자동으로 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="3a8cd13dfa2e44b4ddf44780a2531422e59cdecc" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;throw&lt;/code&gt; finds the matching &lt;code&gt;catch&lt;/code&gt; based on the first argument: it searches for a &lt;code&gt;catch&lt;/code&gt; whose first argument is &lt;code&gt;eq&lt;/code&gt; to the one specified in the &lt;code&gt;throw&lt;/code&gt;. If there is more than one applicable &lt;code&gt;catch&lt;/code&gt;, the innermost one takes precedence. Thus, in the above example, the &lt;code&gt;throw&lt;/code&gt; specifies &lt;code&gt;foo&lt;/code&gt;, and the &lt;code&gt;catch&lt;/code&gt; in &lt;code&gt;foo-outer&lt;/code&gt; specifies the same symbol, so that &lt;code&gt;catch&lt;/code&gt; is the applicable one (assuming there is no other matching &lt;code&gt;catch&lt;/code&gt; in between).</source>
          <target state="translated">&lt;code&gt;throw&lt;/code&gt; 함수 는 첫 번째 인수를 기반으로 일치하는 &lt;code&gt;catch&lt;/code&gt; 를 찾습니다. 첫 번째 인수가 &lt;code&gt;throw&lt;/code&gt; 에 지정된 것과 &lt;code&gt;eq&lt;/code&gt; 인 &lt;code&gt;catch&lt;/code&gt; 를 검색합니다 . 적용 가능한 &lt;code&gt;catch&lt;/code&gt; 가 둘 이상 있는 경우 가장 안쪽에있는 catch 가 우선합니다. 따라서, 상기 예에서, &lt;code&gt;throw&lt;/code&gt; 지정 &lt;code&gt;foo&lt;/code&gt; 는 , 상기 &lt;code&gt;catch&lt;/code&gt; 의 &lt;code&gt;foo-outer&lt;/code&gt; 되도록 지정 동일한 기호 &lt;code&gt;catch&lt;/code&gt; (다른 정합이없는 가정하에 해당 하나 &lt;code&gt;catch&lt;/code&gt; 사이).</target>
        </trans-unit>
        <trans-unit id="5661573f71139d597425c8fd348b8554cabd492f" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;tool-bar-make-keymap&lt;/code&gt;, in turn, derives the actual tool bar map dynamically from the value of the variable &lt;code&gt;tool-bar-map&lt;/code&gt;. Hence, you should normally adjust the default (global) tool bar by changing that map. Some major modes, such as Info mode, completely replace the global tool bar by making &lt;code&gt;tool-bar-map&lt;/code&gt; buffer-local and setting it to a different keymap.</source>
          <target state="translated">&lt;code&gt;tool-bar-make-keymap&lt;/code&gt; 함수 는 차례로 변수 &lt;code&gt;tool-bar-map&lt;/code&gt; 의 값에서 실제 도구 모음 맵을 동적으로 파생합니다 . 따라서 일반적으로 해당 맵을 변경하여 기본 (전역) 도구 모음을 조정해야합니다. 정보 모드와 같은 일부 주요 모드는 도구 모음 &lt;code&gt;tool-bar-map&lt;/code&gt; 버퍼 로컬로 만들고 다른 키맵으로 설정 하여 전역 도구 모음을 완전히 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="05e5fdd0ff72a822c0cc55151d5a6c9edaf5d75c" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;view-buffer&lt;/code&gt; does not enable View mode in buffers whose mode-class is special, because such modes usually provide their own View-like bindings.</source>
          <target state="translated">&lt;code&gt;view-buffer&lt;/code&gt; 함수 는 모드 클래스가 특수한 버퍼에서 뷰 모드를 활성화하지 않습니다. 이러한 모드는 일반적으로 자체 뷰 유사 바인딩을 제공하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="a049ee6872282215d8c5e6687a889741cbf6e11f" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;write-region&lt;/code&gt; converts the data which it writes to the appropriate file formats specified by &lt;code&gt;buffer-file-format&lt;/code&gt; and also calls the functions in the list &lt;code&gt;write-region-annotate-functions&lt;/code&gt;. See &lt;a href=&quot;format-conversion#Format-Conversion&quot;&gt;Format Conversion&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;write-region&lt;/code&gt; 함수는 기록 하는 데이터를 &lt;code&gt;buffer-file-format&lt;/code&gt; 에 지정된 적절한 파일 형식으로 변환하고 &lt;code&gt;write-region-annotate-functions&lt;/code&gt; 목록의 함수도 호출합니다 . &lt;a href=&quot;format-conversion#Format-Conversion&quot;&gt;형식 변환을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2746b27a56c8ff0cc634f6dc15fff67621f22f61" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;write-region&lt;/code&gt;:</source>
          <target state="translated">함수 &lt;code&gt;write-region&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="37f0357f6437343569a44c1bbed9f09179966f30" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;x-get-resource&lt;/code&gt; retrieves a resource value from the X Window defaults database.</source>
          <target state="translated">&lt;code&gt;x-get-resource&lt;/code&gt; 함수 는 X Window 기본 데이터베이스에서 자원 값을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="fb6053497d7338bd26e25c53f5d17dd9d465fac4" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;x-parse-geometry&lt;/code&gt; converts a standard X window geometry string to an alist that you can use as part of the argument to &lt;code&gt;make-frame&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x-parse-geometry&lt;/code&gt; 함수 는 표준 X 윈도우 지오메트리 문자열을 &lt;code&gt;make-frame&lt;/code&gt; 인수의 일부로 사용할 수있는 alist로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="765f4cca514fe5d2dfb2aca5ee2926f744c31bf9" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;y-or-n-p-with-timeout&lt;/code&gt; provides a simple way to use a timer to avoid waiting too long for an answer. See &lt;a href=&quot;yes_002dor_002dno-queries#Yes_002dor_002dNo-Queries&quot;&gt;Yes-or-No Queries&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;y-or-n-p-with-timeout&lt;/code&gt; 함수 는 답변을 너무 오래 기다리지 않도록 타이머를 사용하는 간단한 방법을 제공합니다. &lt;a href=&quot;yes_002dor_002dno-queries#Yes_002dor_002dNo-Queries&quot;&gt;예-아니오 쿼리를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="df0ab2f26bcca2763cb6e43bfe8851ca6f1b858d" translate="yes" xml:space="preserve">
          <source>The function &lt;var&gt;fun&lt;/var&gt; was defined as an autoload.</source>
          <target state="translated">&lt;var&gt;fun&lt;/var&gt; 함수 는 자동로드로 정의되었습니다.</target>
        </trans-unit>
        <trans-unit id="54c8609b51778bf7d45e6af7c3a0089e651dafd8" translate="yes" xml:space="preserve">
          <source>The function &lt;var&gt;fun&lt;/var&gt; was defined.</source>
          <target state="translated">&lt;var&gt;fun&lt;/var&gt; 함수 가 정의되었습니다.</target>
        </trans-unit>
        <trans-unit id="1197aefcb8e997f46503d415a6f7bd440fa422e7" translate="yes" xml:space="preserve">
          <source>The function &lt;var&gt;fun&lt;/var&gt; was previously an autoload before this library redefined it as a function. The following element is always &lt;code&gt;(defun . &lt;var&gt;fun&lt;/var&gt;)&lt;/code&gt;, which represents defining &lt;var&gt;fun&lt;/var&gt; as a function.</source>
          <target state="translated">&lt;var&gt;fun&lt;/var&gt; 함수 는 이전에이 라이브러리가 함수로 재정의하기 전에 자동로드였습니다. 다음 요소는 항상 &lt;code&gt;(defun . &lt;var&gt;fun&lt;/var&gt;)&lt;/code&gt; 이며, 이는 &lt;var&gt;fun&lt;/var&gt; 을 함수로 정의하는 것을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="4a8ed9e0e2bf16ef5d1d934174aa221a2fe5895d" translate="yes" xml:space="preserve">
          <source>The function &lt;var&gt;hash-fn&lt;/var&gt; should accept one argument, a key, and return an integer that is the hash code of that key. For good results, the function should use the whole range of fixnums for hash codes, including negative fixnums.</source>
          <target state="translated">함수 &lt;var&gt;hash-fn&lt;/var&gt; 은 하나의 인수, 키를 허용하고 해당 키의 해시 코드 인 정수를 반환해야합니다. 좋은 결과를 얻으려면 함수는 음수 고정 번호를 포함하여 해시 코드에 대해 전체 고정 번호 범위를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="bceb96a81c6ae7fe6ca85c909a8b34d1e250dcc7" translate="yes" xml:space="preserve">
          <source>The function &lt;var&gt;restore-buffer-function&lt;/var&gt; will be called with argument list</source>
          <target state="translated">기능 &lt;var&gt;restore-buffer-function&lt;/var&gt; 인수 목록으로 호출됩니다</target>
        </trans-unit>
        <trans-unit id="542f7b37d57061c8a923579b6d757e44f707ccd9" translate="yes" xml:space="preserve">
          <source>The function &lt;var&gt;test-fn&lt;/var&gt; should accept two arguments, two keys, and return non-&lt;code&gt;nil&lt;/code&gt; if they are considered the same.</source>
          <target state="translated">&lt;var&gt;test-fn&lt;/var&gt; 함수 는 두 개의 인수, 두 개의 키를 허용해야 하며 동일한 것으로 간주되면 &lt;code&gt;nil&lt;/code&gt; 이 아닌 값을 반환 해야합니다.</target>
        </trans-unit>
        <trans-unit id="0267fd50dfdf570f50991445f5d60831fec0bbb2" translate="yes" xml:space="preserve">
          <source>The function calls &lt;code&gt;set-auto-mode&lt;/code&gt; to choose and set a major mode. If this does not specify a mode, the buffer stays in the major mode determined by the default value of &lt;code&gt;major-mode&lt;/code&gt; (see below).</source>
          <target state="translated">이 함수는 &lt;code&gt;set-auto-mode&lt;/code&gt; 를 호출 하여 주요 모드를 선택하고 설정합니다. 모드를 지정하지 않으면 버퍼는 &lt;code&gt;major-mode&lt;/code&gt; 의 기본값 (아래 참조)에 의해 결정된 주요 모드로 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="b1b2ebec7b7f741cc24d28e6e32513259cab8c5e" translate="yes" xml:space="preserve">
          <source>The function cell holds a symbol&amp;rsquo;s function definition. Often, we refer to &amp;ldquo;the function &lt;code&gt;foo&lt;/code&gt;&amp;rdquo; when we really mean the function stored in the function cell of &lt;code&gt;foo&lt;/code&gt;; we make the distinction explicit only when necessary. Typically, the function cell is used to hold a function (see &lt;a href=&quot;functions#Functions&quot;&gt;Functions&lt;/a&gt;) or a macro (see &lt;a href=&quot;macros#Macros&quot;&gt;Macros&lt;/a&gt;). However, it can also be used to hold a symbol (see &lt;a href=&quot;function-indirection#Function-Indirection&quot;&gt;Function Indirection&lt;/a&gt;), keyboard macro (see &lt;a href=&quot;keyboard-macros#Keyboard-Macros&quot;&gt;Keyboard Macros&lt;/a&gt;), keymap (see &lt;a href=&quot;keymaps#Keymaps&quot;&gt;Keymaps&lt;/a&gt;), or autoload object (see &lt;a href=&quot;autoloading#Autoloading&quot;&gt;Autoloading&lt;/a&gt;). To get the contents of a symbol&amp;rsquo;s function cell, use the function &lt;code&gt;symbol-function&lt;/code&gt; (see &lt;a href=&quot;function-cells#Function-Cells&quot;&gt;Function Cells&lt;/a&gt;).</source>
          <target state="translated">기능 셀에는 기호의 기능 정의가 있습니다. 종종 우리는 &quot;함수를 참조 &lt;code&gt;foo&lt;/code&gt; 는 우리가 정말의 기능 셀에 저장되어있는 기능을 의미한다&quot; &lt;code&gt;foo&lt;/code&gt; 는 ; 우리는 필요할 때만 구별을 명시합니다. 전형적으로, 기능 셀은 함수 (참조 보유하는 데 사용되는 &lt;a href=&quot;functions#Functions&quot;&gt;함수&lt;/a&gt; ) 또는 매크로 (참조 &lt;a href=&quot;macros#Macros&quot;&gt;매크로&lt;/a&gt; ). 그러나 심볼 ( &lt;a href=&quot;function-indirection#Function-Indirection&quot;&gt;Function Indirection&lt;/a&gt; 참조 ), 키보드 매크로 ( &lt;a href=&quot;keyboard-macros#Keyboard-Macros&quot;&gt;Keyboard Macros&lt;/a&gt; 참조 ), keymap ( &lt;a href=&quot;keymaps#Keymaps&quot;&gt;Keymaps&lt;/a&gt; 참조 ) 또는 객체 자동로드 ( &lt;a href=&quot;autoloading#Autoloading&quot;&gt;Autoloading&lt;/a&gt; 참조) 를 유지하는데도 사용할 수 있습니다 . 심볼의 기능 셀 내용을 얻으려면 &lt;code&gt;symbol-function&lt;/code&gt; 함수를 사용 하십시오 ( &lt;a href=&quot;function-cells#Function-Cells&quot;&gt;기능 셀&lt;/a&gt; 참조).).</target>
        </trans-unit>
        <trans-unit id="16328c91ba726096f5314f142ff38c105df7239d" translate="yes" xml:space="preserve">
          <source>The function cell or the value cell may be &lt;em&gt;void&lt;/em&gt;, which means that the cell does not reference any object. (This is not the same thing as holding the symbol &lt;code&gt;void&lt;/code&gt;, nor the same as holding the symbol &lt;code&gt;nil&lt;/code&gt;.) Examining a function or value cell that is void results in an error, such as &amp;lsquo;</source>
          <target state="translated">함수 셀 또는 값 셀이 &lt;em&gt;void&lt;/em&gt; 일 수 있으며 이는 셀이 객체를 참조하지 않음을 의미합니다. (이것은 &lt;code&gt;void&lt;/code&gt; 기호를 들고있는 것과 &lt;code&gt;nil&lt;/code&gt; 기호를 들고있는 것과 같지 않습니다 .) void 인 함수 또는 값 셀을 검사하면 '와 같은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="77d0d2f3edeb3f16b9066342192972eab714c545" translate="yes" xml:space="preserve">
          <source>The function definition of &lt;var&gt;symbol&lt;/var&gt; is used in place of &lt;var&gt;symbol&lt;/var&gt;. If that too is a symbol, then this process is repeated, any number of times. Ultimately this should lead to an object that is a keymap, a command, or a keyboard macro.</source>
          <target state="translated">의 함수 정의 &lt;var&gt;symbol&lt;/var&gt; 대신에 사용되는 &lt;var&gt;symbol&lt;/var&gt; . 그것도 상징이라면,이 과정은 여러 번 반복됩니다. 궁극적으로 이것은 키맵, 명령 또는 키보드 매크로 인 객체로 이어져야합니다.</target>
        </trans-unit>
        <trans-unit id="70e234ce635436f65ccf5ff5428cbb855d712c68" translate="yes" xml:space="preserve">
          <source>The function is called by &lt;code&gt;syntax-ppss&lt;/code&gt; (see &lt;a href=&quot;position-parse#Position-Parse&quot;&gt;Position Parse&lt;/a&gt;), and by Font Lock mode during syntactic fontification (see &lt;a href=&quot;syntactic-font-lock#Syntactic-Font-Lock&quot;&gt;Syntactic Font Lock&lt;/a&gt;). It is called with two arguments, &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt;, which are the starting and ending positions of the text on which it should act. It is allowed to call &lt;code&gt;syntax-ppss&lt;/code&gt; on any position before &lt;var&gt;end&lt;/var&gt;. However, it should not call &lt;code&gt;syntax-ppss-flush-cache&lt;/code&gt;; so, it is not allowed to call &lt;code&gt;syntax-ppss&lt;/code&gt; on some position and later modify the buffer at an earlier position.</source>
          <target state="translated">이 함수는 &lt;code&gt;syntax-ppss&lt;/code&gt; ( &lt;a href=&quot;position-parse#Position-Parse&quot;&gt;Position Parse&lt;/a&gt; 참조 ) 및 &lt;a href=&quot;syntactic-font-lock#Syntactic-Font-Lock&quot;&gt;구문 글꼴 화&lt;/a&gt; 중 글꼴 잠금 모드 ( Syntactic Font Lock 참조)에 의해 호출됩니다 . 두 개의 인수 ( &lt;var&gt;start&lt;/var&gt; 및 &lt;var&gt;end&lt;/var&gt; )를 사용 하여 호출되며 , 이는 텍스트가 작동해야하는 텍스트의 시작 및 끝 위치입니다. &lt;var&gt;end&lt;/var&gt; 이전의 모든 위치에서 &lt;code&gt;syntax-ppss&lt;/code&gt; 를 호출 할 수 있습니다. 그러나 &lt;code&gt;syntax-ppss-flush-cache&lt;/code&gt; 를 호출해서는 안됩니다 . 따라서 어떤 위치에서 &lt;code&gt;syntax-ppss&lt;/code&gt; 를 호출 하고 나중에 이전 위치에서 버퍼를 수정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7b365c1ea990ed74fa23e69f3e59bb3fef165d33" translate="yes" xml:space="preserve">
          <source>The function is called with one argument, the parse state at point returned by &lt;code&gt;parse-partial-sexp&lt;/code&gt;, and should return a face. The default value returns &lt;code&gt;font-lock-comment-face&lt;/code&gt; for comments and &lt;code&gt;font-lock-string-face&lt;/code&gt; for strings (see &lt;a href=&quot;faces-for-font-lock#Faces-for-Font-Lock&quot;&gt;Faces for Font Lock&lt;/a&gt;).</source>
          <target state="translated">함수는 하나의 인수, 즉 &lt;code&gt;parse-partial-sexp&lt;/code&gt; 에 의해 반환 된 시점의 구문 분석 상태로 호출되며 얼굴을 반환해야합니다. 기본값은 &lt;code&gt;font-lock-comment-face&lt;/code&gt; 를 반환 하고 &lt;code&gt;font-lock-string-face&lt;/code&gt; 에 대해 font-lock-string-face 를 반환합니다 ( &lt;a href=&quot;faces-for-font-lock#Faces-for-Font-Lock&quot;&gt;Faces for Font Lock&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="9328a25f093f15182803d9023b33252b886864e6" translate="yes" xml:space="preserve">
          <source>The function is called with three arguments, &lt;var&gt;window&lt;/var&gt;, &lt;var&gt;object&lt;/var&gt;, and &lt;var&gt;pos&lt;/var&gt;. The second argument, &lt;var&gt;object&lt;/var&gt;, is either the overlay that had the property (for overlay buttons), or the buffer containing the button (for text property buttons). The other arguments have the same meaning as for the special text property &lt;code&gt;help-echo&lt;/code&gt;.</source>
          <target state="translated">함수는 &lt;var&gt;window&lt;/var&gt; , &lt;var&gt;object&lt;/var&gt; 및 &lt;var&gt;pos&lt;/var&gt; 의 세 가지 인수로 호출됩니다 . 두 번째 인수 인 &lt;var&gt;object&lt;/var&gt; 는 속성이있는 오버레이 (오버레이 버튼의 경우)이거나 버튼이 포함 된 버퍼 (텍스트 속성 버튼의 경우)입니다. 다른 인수는 특수 텍스트 속성 &lt;code&gt;help-echo&lt;/code&gt; 와 동일한 의미를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="9bcf0f786e7063f34c780ba9d084a745154f7f7f" translate="yes" xml:space="preserve">
          <source>The function is called with two arguments, the severity level and its entry in &lt;code&gt;warning-levels&lt;/code&gt;. It should return a list to use as the entry (this value need not be an actual member of &lt;code&gt;warning-levels&lt;/code&gt;). By constructing this value, the function can change the severity of the warning, or specify different handling for a given severity level.</source>
          <target state="translated">이 함수는 두 개의 인수, 심각도 수준 및 &lt;code&gt;warning-levels&lt;/code&gt; 항목으로 호출 됩니다 . 항목으로 사용할 목록을 반환해야합니다 (이 값은 &lt;code&gt;warning-levels&lt;/code&gt; 의 실제 구성원 일 필요는 없습니다 ). 이 값을 구성함으로써 함수는 경고의 심각도를 변경하거나 주어진 심각도 수준에 대해 다른 처리를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2a2dd9cb6611c3a2fb4ae6ecd12f7c5ac258cb7" translate="yes" xml:space="preserve">
          <source>The function is given three parameters, the standard &lt;var&gt;beg&lt;/var&gt;, &lt;var&gt;end&lt;/var&gt;, and &lt;var&gt;old-len&lt;/var&gt; from &lt;code&gt;after-change-functions&lt;/code&gt; (see &lt;a href=&quot;change-hooks#Change-Hooks&quot;&gt;Change Hooks&lt;/a&gt;). It should return either a cons of the beginning and end buffer positions (in that order) of the region to fontify, or &lt;code&gt;nil&lt;/code&gt; (which means choose the region in the standard way). This function needs to preserve point, the match-data, and the current restriction. The region it returns may start or end in the middle of a line.</source>
          <target state="translated">이 함수는 세 개의 매개 변수, 표준 주어 &lt;var&gt;beg&lt;/var&gt; , &lt;var&gt;end&lt;/var&gt; , 그리고 &lt;var&gt;old-len&lt;/var&gt; 에서는 &lt;code&gt;after-change-functions&lt;/code&gt; (참조 &lt;a href=&quot;change-hooks#Change-Hooks&quot;&gt;변경 후크&lt;/a&gt; ). 글꼴화할 영역의 시작 및 끝 버퍼 위치 (순서대로)의 단점을 반환하거나 &lt;code&gt;nil&lt;/code&gt; (표준 방식으로 영역을 선택 함을 의미) 을 반환 해야합니다. 이 함수는 포인트, 일치 데이터 및 현재 제한을 보존해야합니다. 반환하는 영역은 줄 중간에서 시작하거나 끝날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5d86a312c704be80fff26fc16b50d833ac4546d" translate="yes" xml:space="preserve">
          <source>The function now compares the two candidate prefixes heuristically: if the non-whitespace characters in the line 2 candidate occur in the same order in the line 1 candidate, the function returns the line 2 candidate. Otherwise, it returns the largest initial substring which is common to both candidates (which might be the empty string).</source>
          <target state="translated">이제이 함수는 두 후보 접두사를 경험적으로 비교합니다. 2 행 후보의 공백이 아닌 문자가 1 행 후보에서 동일한 순서로 발생하면 함수는 2 행 후보를 반환합니다. 그렇지 않으면 두 후보에 공통되는 가장 큰 초기 하위 문자열 (빈 문자열 일 수 있음)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3010538a15326f7f4a43ca9704f87dc561e6ae88" translate="yes" xml:space="preserve">
          <source>The function now has a list of regular expressions that it passes to &lt;code&gt;read-from-minibuffer&lt;/code&gt; to obtain the user&amp;rsquo;s input. The first element of the list is the default result in case of empty input. All elements of the list are available to the user as the &amp;ldquo;future minibuffer history&amp;rdquo; list (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Minibuffer-History.html#Minibuffer-History&quot;&gt;future list&lt;/a&gt; in</source>
          <target state="translated">이제 함수 에는 사용자 입력을 얻기 위해 &lt;code&gt;read-from-minibuffer&lt;/code&gt; 전달하는 정규식 목록이 있습니다 . 목록의 첫 번째 요소는 빈 입력의 경우 기본 결과입니다. 목록의 모든 요소는 &quot;미래 미니 버퍼 역사&quot;목록으로 사용자가 사용할 수 있습니다 (참조 &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Minibuffer-History.html#Minibuffer-History&quot;&gt;미래의 목록&lt;/a&gt; 에서을</target>
        </trans-unit>
        <trans-unit id="d3712f3990384c32b001189f990196c3e25d4f1c" translate="yes" xml:space="preserve">
          <source>The function passed as &lt;code&gt;:request-dispatcher&lt;/code&gt; is responsible for handling the remote endpoint&amp;rsquo;s requests, which expect a reply from the local endpoint (in this case, the program you&amp;rsquo;re building). Inside that function, you may either return locally (a normal return) or non-locally (an error return). A local return value must be a Lisp object that can be serialized as JSON (see &lt;a href=&quot;parsing-json#Parsing-JSON&quot;&gt;Parsing JSON&lt;/a&gt;). This determines a success response, and the object is forwarded to the server as the JSONRPC &lt;code&gt;result&lt;/code&gt; object. A non-local return, achieved by calling the function &lt;code&gt;jsonrpc-error&lt;/code&gt;, causes an error response to be sent to the server. The details of the accompanying JSONRPC &lt;code&gt;error&lt;/code&gt; are filled out with whatever was passed to &lt;code&gt;jsonrpc-error&lt;/code&gt;. A non-local return triggered by an unexpected error of any other type also causes an error response to be sent (unless you have set &lt;code&gt;debug-on-error&lt;/code&gt;, in which case this calls the Lisp debugger, see &lt;a href=&quot;error-debugging#Error-Debugging&quot;&gt;Error Debugging&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;:request-dispatcher&lt;/code&gt; 로 전달 된 함수 는 로컬 엔드 포인트 (이 경우 빌드중인 프로그램)에서 응답을 예상하는 원격 엔드 포인트의 요청을 처리합니다. 해당 함수 내에서 로컬 (정상 반환) 또는 비 로컬 (오류 반환)을 반환 할 수 있습니다. 로컬 반환 값은 JSON으로 직렬화 할 수있는 Lisp 객체 여야합니다 ( &lt;a href=&quot;parsing-json#Parsing-JSON&quot;&gt;JSON 구문 분석&lt;/a&gt; 참조 ). 이것은 성공 응답을 결정하고 객체는 JSONRPC &lt;code&gt;result&lt;/code&gt; 객체 로 서버에 전달됩니다 . &lt;code&gt;jsonrpc-error&lt;/code&gt; 함수를 호출하여 로컬이 아닌 반환을 수행 하면 오류 응답이 서버로 전송됩니다. 수반되는 JSONRPC &lt;code&gt;error&lt;/code&gt; 의 세부 사항 은 전달 된 항목으로 채워집니다. &lt;code&gt;jsonrpc-error&lt;/code&gt; . 다른 유형의 예기치 않은 오류에 의해 트리거 된 로컬이 아닌 반환도 오류 응답을 전송합니다 ( &lt;code&gt;debug-on-error&lt;/code&gt; 설정하지 않은 경우,이 경우 Lisp 디버거를 호출합니다 . &lt;a href=&quot;error-debugging#Error-Debugging&quot;&gt;오류 디버깅&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="7f4f854a3fe920f9dd18f4fb474ba93f955016a3" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;nil&lt;/code&gt; if images of this type are not supported. Otherwise it returns an image descriptor.</source>
          <target state="translated">이 유형의 이미지가 지원되지 않으면이 함수는 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 . 그렇지 않으면 이미지 설명자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="271e1437bfe3ecbde27422c4523f32b9c7ffd067" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;t&lt;/code&gt; if it actually tried to redisplay, and &lt;code&gt;nil&lt;/code&gt; otherwise. A value of &lt;code&gt;t&lt;/code&gt; does not mean that redisplay proceeded to completion; it could have been preempted by newly arriving input.</source>
          <target state="translated">이 함수는 실제로 다시 표시하려고하면 &lt;code&gt;t&lt;/code&gt; 를 반환 하고 그렇지 않으면 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다. &lt;code&gt;t&lt;/code&gt; 값은 재 표시가 완료되었음을 의미하지 않습니다. 새로 도착하는 입력에 의해 선점 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2c86b439365c249c948c8efa2d07fe8ef2ae3a2" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;t&lt;/code&gt; if it succeeds in setting the SELinux context of &lt;var&gt;filename&lt;/var&gt;. It returns &lt;code&gt;nil&lt;/code&gt; if the context was not set (e.g., if SELinux is disabled, or if Emacs was compiled without SELinux support).</source>
          <target state="translated">이 함수는 &lt;var&gt;filename&lt;/var&gt; 의 SELinux 컨텍스트 설정에 성공하면 &lt;code&gt;t&lt;/code&gt; 를 반환합니다 . 컨텍스트가 설정되지 않은 경우 (예 : SELinux가 비활성화되었거나 Emacs가 SELinux 지원없이 컴파일 된 경우) &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="8aa3622a93da6a8f83161ce66b0a13088cd542a2" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;t&lt;/code&gt; if it successfully sets the ACL of &lt;var&gt;filename&lt;/var&gt;, &lt;code&gt;nil&lt;/code&gt; otherwise.</source>
          <target state="translated">함수를 반환 &lt;code&gt;t&lt;/code&gt; 은 성공적의 ACL 설정하면 &lt;var&gt;filename&lt;/var&gt; , &lt;code&gt;nil&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="4adc69487e5f1fde8f02ec91f8b4f6899e76a34b" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;t&lt;/code&gt; if the last actual modification time and Emacs&amp;rsquo;s recorded modification time are the same, &lt;code&gt;nil&lt;/code&gt; otherwise. It also returns &lt;code&gt;t&lt;/code&gt; if the buffer has no recorded last modification time, that is if &lt;code&gt;visited-file-modtime&lt;/code&gt; would return zero.</source>
          <target state="translated">이 함수는 마지막 실제 수정 시간과 Emacs의 기록 된 수정 시간이 같으면 &lt;code&gt;t&lt;/code&gt; 를 반환 하고 그렇지 않으면 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다. 또한 버퍼에 기록 된 마지막 수정 시간이없는 경우, 즉 &lt;code&gt;visited-file-modtime&lt;/code&gt; 이 0을 반환하는 경우 &lt;code&gt;t&lt;/code&gt; 를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="eb47fbb29639c623b56d142e3e79686425e3d118" translate="yes" xml:space="preserve">
          <source>The function returns a list of elements that look like this:</source>
          <target state="translated">이 함수는 다음과 같은 요소 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b576d5d04a96dba46391f5334628078f6e91dee5" translate="yes" xml:space="preserve">
          <source>The function returns an existing buffer if there is one; otherwise it creates a new buffer and reads the file into it. When &lt;code&gt;find-file-noselect&lt;/code&gt; uses an existing buffer, it first verifies that the file has not changed since it was last visited or saved in that buffer. If the file has changed, this function asks the user whether to reread the changed file. If the user says &amp;lsquo;</source>
          <target state="translated">이 함수는 기존 버퍼가 있으면 반환합니다. 그렇지 않으면 새 버퍼를 만들고 그 안에 파일을 읽습니다. 때 &lt;code&gt;find-file-noselect&lt;/code&gt; 기존의 버퍼가 마지막으로 방문 또는 버퍼에 저장된 이후 파일이 변경되지 않았 음을 그 첫 번째를 검증를 사용합니다. 파일이 변경된 경우이 기능은 사용자에게 변경된 파일을 다시 읽을 것인지 묻습니다. 사용자가 '</target>
        </trans-unit>
        <trans-unit id="1501aaa047bf3d422b1edc8df28a63aa3d3d72eb" translate="yes" xml:space="preserve">
          <source>The function returns the new buffer position as its value.</source>
          <target state="translated">이 함수는 새 버퍼 위치를 값으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="58c3348b08983e8a23db0b1d6c78b02a290ca8f9" translate="yes" xml:space="preserve">
          <source>The function returns the text of the &lt;var&gt;long-answer&lt;/var&gt; selected by the user, regardless of whether long or short answers were shown in the prompt and typed by the user.</source>
          <target state="translated">이 함수는 긴 답변이 프롬프트에 표시되고 사용자가 입력했는지 여부에 관계없이 사용자가 선택한 &lt;var&gt;long-answer&lt;/var&gt; 의 텍스트를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="715f03109b9380bc908d0550c413f8b1448908f0" translate="yes" xml:space="preserve">
          <source>The function returns the value that &lt;var&gt;func&lt;/var&gt; returned.</source>
          <target state="translated">함수는 &lt;var&gt;func&lt;/var&gt; 가 반환 한 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0e79ba4a0ec06385532067bc2dfd92eef04abf37" translate="yes" xml:space="preserve">
          <source>The function scans text for a change in the &lt;var&gt;prop&lt;/var&gt; property, then returns the position of the change. The scan goes forward from position &lt;var&gt;pos&lt;/var&gt; in the string or buffer &lt;var&gt;object&lt;/var&gt;. In other words, this function returns the position of the first character beyond &lt;var&gt;pos&lt;/var&gt; whose &lt;var&gt;prop&lt;/var&gt; property differs from that of the character just after &lt;var&gt;pos&lt;/var&gt;.</source>
          <target state="translated">이 함수는 텍스트에서 &lt;var&gt;prop&lt;/var&gt; 속성 의 변경 사항을 검색 한 다음 변경 위치를 반환합니다. 스캔은 문자열 또는 버퍼 &lt;var&gt;object&lt;/var&gt; &lt;var&gt;pos&lt;/var&gt; 위치 에서 앞으로 진행됩니다 . 즉,이 함수는 &lt;var&gt;prop&lt;/var&gt; 속성이 &lt;var&gt;pos&lt;/var&gt; 바로 뒤의 캐릭터와 다른 &lt;var&gt;pos&lt;/var&gt; 를 넘어선 첫 번째 캐릭터의 위치를 ​​반환합니다 .</target>
        </trans-unit>
        <trans-unit id="bcc76f6509469249f57ba4ca3b63e8ba3ae15e54" translate="yes" xml:space="preserve">
          <source>The function scans the text forward from position &lt;var&gt;pos&lt;/var&gt; in the string or buffer &lt;var&gt;object&lt;/var&gt; until it finds a change in some text property, then returns the position of the change. In other words, it returns the position of the first character beyond &lt;var&gt;pos&lt;/var&gt; whose properties are not identical to those of the character just after &lt;var&gt;pos&lt;/var&gt;.</source>
          <target state="translated">이 함수 는 문자열 또는 버퍼 &lt;var&gt;object&lt;/var&gt; 의 &lt;var&gt;pos&lt;/var&gt; 위치 에서 텍스트 속성의 변경 사항을 찾을 때까지 텍스트를 앞으로 스캔 한 다음 변경 위치를 반환합니다. 즉, 넘어 첫 번째 문자의 위치를 반환 &lt;var&gt;pos&lt;/var&gt; 속성 직후 캐릭터의 것과 동일하지 않은 &lt;var&gt;pos&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="b2569b6d3f2a4920cd818025751b427d49a3a937" translate="yes" xml:space="preserve">
          <source>The function searches for &lt;var&gt;image&lt;/var&gt; first using &lt;code&gt;image-load-path&lt;/code&gt;, excluding</source>
          <target state="translated">위한 기능 검색 &lt;var&gt;image&lt;/var&gt; 제하여 &lt;code&gt;image-load-path&lt;/code&gt; 제외한</target>
        </trans-unit>
        <trans-unit id="f61dc72b5ae5c926752f9b2ea93c7b17926bb658" translate="yes" xml:space="preserve">
          <source>The function should report its choice by placing the region around it. A good choice is a range of text large enough to give proper results, but not too large so that refontification becomes slow. Typical values are &lt;code&gt;mark-defun&lt;/code&gt; for programming modes or &lt;code&gt;mark-paragraph&lt;/code&gt; for textual modes.</source>
          <target state="translated">함수는 주변에 영역을 배치하여 선택을보고해야합니다. 적절한 결과를 제공 할 수있을만큼 큰 텍스트 범위를 선택하는 것이 좋지만 글꼴 변경이 느려질 정도로 너무 크지 않은 것입니다. 일반적인 값은 프로그래밍 모드의 경우 &lt;code&gt;mark-defun&lt;/code&gt; , 텍스트 모드의 경우 &lt;code&gt;mark-paragraph&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e569deba575fd9eecea0636fcb5581d08c592fbf" translate="yes" xml:space="preserve">
          <source>The function specified by this option is called to automatically hide frames. This function is called with one argument&amp;mdash;a frame.</source>
          <target state="translated">이 옵션으로 지정된 함수는 자동으로 프레임을 숨기기 위해 호출됩니다. 이 함수는 하나의 인수 (프레임)로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="9e523dba464ace87982922281becd877253b4c57" translate="yes" xml:space="preserve">
          <source>The function specified here is called by &lt;code&gt;bury-buffer&lt;/code&gt; (see &lt;a href=&quot;buffer-list#Buffer-List&quot;&gt;Buffer List&lt;/a&gt;) when the selected window is dedicated and shows the buffer to bury. It is also called by &lt;code&gt;quit-restore-window&lt;/code&gt; (see above) when the frame of the window to quit has been specially created for displaying that window&amp;rsquo;s buffer and the buffer is not killed.</source>
          <target state="translated">여기에 지정된 기능 은 선택된 창이 전용이고 묻을 버퍼를 표시 할 때 &lt;code&gt;bury-buffer&lt;/code&gt; ( &lt;a href=&quot;buffer-list#Buffer-List&quot;&gt;버퍼 목록&lt;/a&gt; 참조)에 의해 호출됩니다 . &lt;code&gt;quit-restore-window&lt;/code&gt; 할 창의 프레임이 해당 창의 버퍼를 표시하기 위해 특별히 생성되고 버퍼가 죽지 않을 때 quit-restore-window (위 참조)에 의해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="4c5fe7b1d57c09eb96638f6d29a8d55ea70693dc" translate="yes" xml:space="preserve">
          <source>The function to call when the user invokes the button, which is passed the single argument &lt;var&gt;button&lt;/var&gt;. By default this is &lt;code&gt;ignore&lt;/code&gt;, which does nothing.</source>
          <target state="translated">사용자가 버튼을 호출 할 때 호출 할 함수로, 단일 인수 &lt;var&gt;button&lt;/var&gt; 이 전달 됩니다. 기본적으로 이것은 아무 일도하지 않는 &lt;code&gt;ignore&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0d346489c44defc5f50064e457e61d13f6a78be1" translate="yes" xml:space="preserve">
          <source>The function to define a new widget is called &lt;code&gt;define-widget&lt;/code&gt;. The first argument is the symbol we want to make a new widget type. The second argument is a symbol representing an existing widget, the new widget is going to be defined in terms of difference from the existing widget. For the purpose of defining new customization types, the &lt;code&gt;lazy&lt;/code&gt; widget is perfect, because it accepts a &lt;code&gt;:type&lt;/code&gt; keyword argument with the same syntax as the keyword argument to &lt;code&gt;defcustom&lt;/code&gt; with the same name. The third argument is a documentation string for the new widget. You will be able to see that string with the</source>
          <target state="translated">새 위젯을 정의하는 함수를 &lt;code&gt;define-widget&lt;/code&gt; 이라고 합니다 . 첫 번째 인수는 새 위젯 유형을 만들고자하는 기호입니다. 두 번째 인수는 기존 위젯을 나타내는 기호이며 새 위젯은 기존 위젯과의 차이로 정의됩니다. 새로운 사용자 정의 유형을 정의 할 목적으로 &lt;code&gt;lazy&lt;/code&gt; 위젯이 완벽 합니다 . 동일한 이름의 &lt;code&gt;defcustom&lt;/code&gt; 에 대한 키워드 인수와 동일한 구문 의 &lt;code&gt;:type&lt;/code&gt; 키워드 인수를 허용하기 때문 입니다. 세 번째 인수는 새 위젯에 대한 문서 문자열입니다. 이 문자열을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3be86b3d84b881b3e6d6fe8ec9995afa24e5702" translate="yes" xml:space="preserve">
          <source>The function&amp;rsquo;s return value is the string typed by the user in the minibuffer. However, when called interactively or if the optional argument &lt;var&gt;convert&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it converts any input color name into the corresponding RGB value string and instead returns that. This function requires a valid color specification to be input. Empty color names are allowed when &lt;var&gt;allow-empty&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt; and the user enters null input.</source>
          <target state="translated">함수의 반환 값은 미니 버퍼에 사용자가 입력 한 문자열입니다. 그러나 대화식으로 호출되거나 선택적 인수 &lt;var&gt;convert&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 입력 색상 이름을 해당 RGB 값 문자열로 변환하고 대신 반환합니다. 이 기능을 사용하려면 유효한 색상 사양을 입력해야합니다. &lt;var&gt;allow-empty&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니고 사용자가 null 입력을 입력 하면 빈 색상 이름이 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="24f9a1a492a75ddcf165b535a392f152caa63130" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;create-image&lt;/code&gt;, &lt;code&gt;defimage&lt;/code&gt; and &lt;code&gt;find-image&lt;/code&gt; provide convenient ways to create image descriptors.</source>
          <target state="translated">&lt;code&gt;create-image&lt;/code&gt; , &lt;code&gt;defimage&lt;/code&gt; 및 &lt;code&gt;find-image&lt;/code&gt; 함수는 이미지 설명자를 만드는 편리한 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="930041ed415a386650d1c27097780e324d3d97ff" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;default-value&lt;/code&gt; and &lt;code&gt;setq-default&lt;/code&gt; access and change a variable&amp;rsquo;s default value regardless of whether the current buffer has a buffer-local binding. For example, you could use &lt;code&gt;setq-default&lt;/code&gt; to change the default setting of &lt;code&gt;paragraph-start&lt;/code&gt; for most buffers; and this would work even when you are in a C or Lisp mode buffer that has a buffer-local value for this variable.</source>
          <target state="translated">&lt;code&gt;default-value&lt;/code&gt; 및 &lt;code&gt;setq-default&lt;/code&gt; 함수 는 현재 버퍼에 버퍼 로컬 바인딩이 있는지 여부에 관계없이 변수의 기본값에 액세스하고 변경합니다. 예를 들어, &lt;code&gt;setq-default&lt;/code&gt; 를 사용하여 대부분의 버퍼에 대한 &lt;code&gt;paragraph-start&lt;/code&gt; 의 기본 설정을 변경할 수 있습니다 . 이 변수에 대한 버퍼 로컬 값이있는 C 또는 Lisp 모드 버퍼에있을 때도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="54fbaadcac6b546aa87b794bc4678dae8bd49959" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;event-modifiers&lt;/code&gt; and &lt;code&gt;event-basic-type&lt;/code&gt; are provided to get such information conveniently.</source>
          <target state="translated">기능 &lt;code&gt;event-modifiers&lt;/code&gt; 및 &lt;code&gt;event-basic-type&lt;/code&gt; 편리하게 정보를 얻기 위해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="f14e4ed51e1588f4afeb3f2808a8e88fb021c9e4" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;ffloor&lt;/code&gt;, &lt;code&gt;fceiling&lt;/code&gt;, &lt;code&gt;fround&lt;/code&gt;, and &lt;code&gt;ftruncate&lt;/code&gt; take a floating-point argument and return a floating-point result whose value is a nearby integer. &lt;code&gt;ffloor&lt;/code&gt; returns the nearest integer below; &lt;code&gt;fceiling&lt;/code&gt;, the nearest integer above; &lt;code&gt;ftruncate&lt;/code&gt;, the nearest integer in the direction towards zero; &lt;code&gt;fround&lt;/code&gt;, the nearest integer.</source>
          <target state="translated">함수 &lt;code&gt;ffloor&lt;/code&gt; , &lt;code&gt;fceiling&lt;/code&gt; , &lt;code&gt;fround&lt;/code&gt; 및 &lt;code&gt;ftruncate&lt;/code&gt; 는 부동 소수점 인수를 취하고 값이 가까운 정수인 부동 소수점 결과를 반환합니다. &lt;code&gt;ffloor&lt;/code&gt; 는 아래에서 가장 가까운 정수를 반환합니다. &lt;code&gt;fceiling&lt;/code&gt; , 위에서 가장 가까운 정수; &lt;code&gt;ftruncate&lt;/code&gt; , 0 방향으로 가장 가까운 정수; &lt;code&gt;fround&lt;/code&gt; , 가장 가까운 정수.</target>
        </trans-unit>
        <trans-unit id="2c140441fed92d7b6f61e961aac8a0aa69c39764" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;make-progress-reporter&lt;/code&gt; and &lt;code&gt;y-or-n-p&lt;/code&gt; don&amp;rsquo;t have to do anything special to activate the message log combination feature. It operates whenever two consecutive messages are logged that share a common prefix ending in &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;make-progress-reporter&lt;/code&gt; 및 &lt;code&gt;y-or-n-p&lt;/code&gt; 함수 는 메시지 로그 조합 기능을 활성화하기 위해 특별한 작업을 수행 할 필요가 없습니다. '로 끝나는 공통 접두사를 공유하는 두 개의 연속 메시지가 기록 될 때마다 작동합니다.</target>
        </trans-unit>
        <trans-unit id="1da791873fb7d70506573ba68b6bb43c2ea88baa" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;match-data&lt;/code&gt; and &lt;code&gt;set-match-data&lt;/code&gt; read or write the entire match data, all at once.</source>
          <target state="translated">&lt;code&gt;match-data&lt;/code&gt; 및 &lt;code&gt;set-match-data&lt;/code&gt; 함수 는 전체 일치 데이터를 한 번에 읽거나 씁니다.</target>
        </trans-unit>
        <trans-unit id="9f3763eba26d0fcd98983ff84241c85f7df4ee68" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;mouse-position&lt;/code&gt; and &lt;code&gt;set-mouse-position&lt;/code&gt; give access to the current position of the mouse.</source>
          <target state="translated">&lt;code&gt;mouse-position&lt;/code&gt; 및 &lt;code&gt;set-mouse-position&lt;/code&gt; 기능은 마우스 의 현재 위치에 대한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f6d9b7af5bfb64034127dfa877a8ed48be4859ab" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;window-next-sibling&lt;/code&gt; and &lt;code&gt;window-prev-sibling&lt;/code&gt; should not be confused with the functions &lt;code&gt;next-window&lt;/code&gt; and &lt;code&gt;previous-window&lt;/code&gt;, which return the next and previous window, respectively, in the cyclic ordering of windows (see &lt;a href=&quot;cyclic-window-ordering#Cyclic-Window-Ordering&quot;&gt;Cyclic Window Ordering&lt;/a&gt;).</source>
          <target state="translated">기능 &lt;code&gt;window-next-sibling&lt;/code&gt; 와 &lt;code&gt;window-prev-sibling&lt;/code&gt; 기능과 혼동해서는 안 &lt;code&gt;next-window&lt;/code&gt; 및 &lt;code&gt;previous-window&lt;/code&gt; 윈도우의 순환 순서에 각각 다음 및 이전 윈도우를 반환합니다 ( &lt;a href=&quot;cyclic-window-ordering#Cyclic-Window-Ordering&quot;&gt;순환 윈도우 주문을&lt;/a&gt; ) .</target>
        </trans-unit>
        <trans-unit id="a4599c26cca67f961f777727cb6555459567d4a8" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;window-state-get&lt;/code&gt; and &lt;code&gt;window-state-put&lt;/code&gt; also allow to exchange the contents of two live windows. The following function does precisely that:</source>
          <target state="translated">&lt;code&gt;window-state-get&lt;/code&gt; 및 &lt;code&gt;window-state-put&lt;/code&gt; 함수를 사용하면 두 개의 라이브 창의 내용을 교환 할 수도 있습니다. 다음 함수는이를 정확하게 수행합니다.</target>
        </trans-unit>
        <trans-unit id="9fce438f0ed03253c60350ad3e2d979328b783c3" translate="yes" xml:space="preserve">
          <source>The functions and variables described in this section evaluate forms, specify limits to the evaluation process, or record recently returned values. Loading a file also does evaluation (see &lt;a href=&quot;loading#Loading&quot;&gt;Loading&lt;/a&gt;).</source>
          <target state="translated">이 섹션에서 설명하는 함수 및 변수는 양식을 평가하고, 평가 프로세스에 대한 제한을 지정하거나, 최근에 반환 된 값을 기록합니다. 파일을로드하면 평가도 수행됩니다 ( &lt;a href=&quot;loading#Loading&quot;&gt;로드&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="8e4bd3a8ad416b6b274e61c0311ccc7aceb93329" translate="yes" xml:space="preserve">
          <source>The functions are called in the order listed, with one argument, a buffer position &lt;var&gt;pos&lt;/var&gt;. Collectively they should attempt to assign faces to the text in the current buffer starting at &lt;var&gt;pos&lt;/var&gt;.</source>
          <target state="translated">함수는 하나의 인수 인 버퍼 위치 &lt;var&gt;pos&lt;/var&gt; 와 함께 나열된 순서대로 호출됩니다 . 집합 적으로 그들은 &lt;var&gt;pos&lt;/var&gt; 에서 시작하는 현재 버퍼의 텍스트에 얼굴을 할당하려고 시도해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6521a8bc086f1a3f8aefcf593df4fa2328b88776" translate="yes" xml:space="preserve">
          <source>The functions below signal an error if &lt;var&gt;keymap&lt;/var&gt; is not a keymap, or if &lt;var&gt;key&lt;/var&gt; is not a string or vector representing a key sequence. You can use event types (symbols) as shorthand for events that are lists. The &lt;code&gt;kbd&lt;/code&gt; function (see &lt;a href=&quot;key-sequences#Key-Sequences&quot;&gt;Key Sequences&lt;/a&gt;) is a convenient way to specify the key sequence.</source>
          <target state="translated">아래 함수 는 &lt;var&gt;keymap&lt;/var&gt; 이 키맵 이 아니거나 &lt;var&gt;key&lt;/var&gt; 가 키 시퀀스를 나타내는 문자열 또는 벡터가 아닌 경우 오류를 나타냅니다. 목록 인 이벤트의 약어로 이벤트 유형 (기호)을 사용할 수 있습니다. &lt;code&gt;kbd&lt;/code&gt; 기능 (참조 &lt;a href=&quot;key-sequences#Key-Sequences&quot;&gt;키 시퀀스&lt;/a&gt; ) 키 순서를 지정하는 편리한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="78ab65059bf6060d13b0ce32e999f9aebe8f6925" translate="yes" xml:space="preserve">
          <source>The functions described in this section accept a fixed set of specification characters. The next section describes a function &lt;code&gt;format-spec&lt;/code&gt; which can accept custom specification characters, such as &amp;lsquo;</source>
          <target state="translated">이 섹션에서 설명하는 함수는 고정 된 사양 문자 집합을 허용합니다. 다음 섹션에서는 '와 같은 사용자 지정 사양 문자를 허용 할 수 있는 함수 &lt;code&gt;format-spec&lt;/code&gt; 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="e86fa617815c4b094651f86026f3ee350a021eb8" translate="yes" xml:space="preserve">
          <source>The functions described in this section control how terminal colors are used by Emacs.</source>
          <target state="translated">이 섹션에서 설명하는 기능은 Emacs에서 터미널 색상을 사용하는 방법을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="f169c28c5651085613c243ee2d7b8b6a97f3524f" translate="yes" xml:space="preserve">
          <source>The functions following next return the pixel widths and heights of the native, outer and inner frame and the text area (see &lt;a href=&quot;frame-layout#Frame-Layout&quot;&gt;Frame Layout&lt;/a&gt;) of a given frame. For a text terminal, the results are in characters rather than pixels.</source>
          <target state="translated">다음 함수는 기본, 외부 및 내부 프레임과 주어진 프레임 의 텍스트 영역 ( &lt;a href=&quot;frame-layout#Frame-Layout&quot;&gt;프레임 레이아웃&lt;/a&gt; 참조 )의 픽셀 너비와 높이를 반환합니다 . 텍스트 터미널의 경우 결과는 픽셀이 아닌 문자입니다.</target>
        </trans-unit>
        <trans-unit id="9720c55f16c083bb07299d34092580b6ec7aab89" translate="yes" xml:space="preserve">
          <source>The functions for parsing words described below use the syntax table and &lt;code&gt;char-script-table&lt;/code&gt; to decide whether a given character is part of a word. See &lt;a href=&quot;syntax-tables#Syntax-Tables&quot;&gt;Syntax Tables&lt;/a&gt;, and see &lt;a href=&quot;character-properties#Character-Properties&quot;&gt;Character Properties&lt;/a&gt;.</source>
          <target state="translated">아래에 설명 된 단어를 구문 분석하는 함수는 구문 테이블과 &lt;code&gt;char-script-table&lt;/code&gt; 을 사용하여 주어진 문자가 단어의 일부인지 여부를 결정합니다. 참조 &lt;a href=&quot;syntax-tables#Syntax-Tables&quot;&gt;구문 테이블&lt;/a&gt; , 볼 &lt;a href=&quot;character-properties#Character-Properties&quot;&gt;문자 속성을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="84e553855a8b2ca8a57ae076b9aaef6d677d36c1" translate="yes" xml:space="preserve">
          <source>The functions in &lt;code&gt;quit-window-hook&lt;/code&gt; are run before doing anything else.</source>
          <target state="translated">&lt;code&gt;quit-window-hook&lt;/code&gt; 의 기능은 다른 작업을 수행하기 전에 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="0e800d933c2fece3683cecc14ad7da075688816e" translate="yes" xml:space="preserve">
          <source>The functions in this list could be called either when the file is visited and Emacs wants to decode its contents, and/or when the file&amp;rsquo;s buffer is about to be saved and Emacs wants to determine how to encode its contents.</source>
          <target state="translated">이 목록의 함수는 파일을 방문하고 Emacs가 해당 내용을 디코딩하려고 할 때 및 / 또는 파일의 버퍼가 저장 되려고 할 때 Emacs가 해당 내용을 인코딩하는 방법을 결정하려고 할 때 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="669d58b77eada51f85ff6d10a60632f82115668b" translate="yes" xml:space="preserve">
          <source>The functions in this section are documented mainly because you can customize the naming conventions for backup files by redefining them. If you change one, you probably need to change the rest.</source>
          <target state="translated">이 섹션의 기능은 주로 백업 파일의 이름 지정 규칙을 재정 의하여 사용자 정의 할 수 있기 때문에 문서화됩니다. 하나를 변경하면 나머지도 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="ddf6614534160f658305998c350626e957a6f335" translate="yes" xml:space="preserve">
          <source>The functions in this section describe the basic capabilities of a particular display. Lisp programs can use them to adapt their behavior to what the display can do. For example, a program that ordinarily uses a popup menu could use the minibuffer if popup menus are not supported.</source>
          <target state="translated">이 섹션의 기능은 특정 디스플레이의 기본 기능을 설명합니다. Lisp 프로그램은이를 사용하여 디스플레이가 수행 할 수있는 작업에 맞게 동작을 조정할 수 있습니다. 예를 들어, 일반적으로 팝업 메뉴를 사용하는 프로그램은 팝업 메뉴가 지원되지 않는 경우 미니 버퍼를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f00c70d2142808c1b8036e8e15d164e6ace38175" translate="yes" xml:space="preserve">
          <source>The functions in this section do not actually access files, so they can operate on file names that do not refer to an existing file or directory.</source>
          <target state="translated">이 섹션의 함수는 실제로 파일에 액세스하지 않으므로 기존 파일이나 디렉토리를 참조하지 않는 파일 이름에 대해 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="016907d83a21967cc3e08258bf37e7e359803f3f" translate="yes" xml:space="preserve">
          <source>The functions in this section rename, copy, delete, link, and set the modes (permissions) of files. Typically, they signal a &lt;code&gt;file-error&lt;/code&gt; error if they fail to perform their function, reporting the system-dependent error message that describes the reason for the failure. If they fail because a file is missing, they signal a &lt;code&gt;file-missing&lt;/code&gt; error instead.</source>
          <target state="translated">이 섹션의 기능은 파일의 모드 (권한) 이름을 변경, 복사, 삭제, 연결 및 설정합니다. 일반적으로 기능을 수행하지 못하면 &lt;code&gt;file-error&lt;/code&gt; 오류를 알리고 오류 원인을 설명하는 시스템 종속 오류 메시지를보고합니다. 파일이 누락되어 실패하면 대신 &lt;code&gt;file-missing&lt;/code&gt; 오류를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="890b0146bfdda395f86d14be742c512118143bed" translate="yes" xml:space="preserve">
          <source>The functions in this section return unpredictable values unless otherwise stated.</source>
          <target state="translated">이 섹션의 함수는 달리 명시되지 않는 한 예측할 수없는 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f48a87c01a2f7dffcffdc543703f3903c8ef0749" translate="yes" xml:space="preserve">
          <source>The functions in this section test for numbers, or for a specific type of number. The functions &lt;code&gt;integerp&lt;/code&gt; and &lt;code&gt;floatp&lt;/code&gt; can take any type of Lisp object as argument (they would not be of much use otherwise), but the &lt;code&gt;zerop&lt;/code&gt; predicate requires a number as its argument. See also &lt;code&gt;integer-or-marker-p&lt;/code&gt; and &lt;code&gt;number-or-marker-p&lt;/code&gt;, in &lt;a href=&quot;predicates-on-markers#Predicates-on-Markers&quot;&gt;Predicates on Markers&lt;/a&gt;.</source>
          <target state="translated">이 섹션의 함수는 숫자 또는 특정 유형의 숫자를 테스트합니다. &lt;code&gt;integerp&lt;/code&gt; 및 &lt;code&gt;floatp&lt;/code&gt; 함수 는 모든 유형의 Lisp 객체를 인수로 사용할 수 있지만 (그렇지 않으면 많이 사용되지 않음) &lt;code&gt;zerop&lt;/code&gt; 술어에는 인수로 숫자가 필요합니다. 참조 &lt;code&gt;integer-or-marker-p&lt;/code&gt; 및 &lt;code&gt;number-or-marker-p&lt;/code&gt; 에서, &lt;a href=&quot;predicates-on-markers#Predicates-on-Markers&quot;&gt;마커 술어를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="64495a754cd6c704e9f9d907a29b2bd6ed3d60e3" translate="yes" xml:space="preserve">
          <source>The functions on this hook should generally return quickly, since they may be called very often (e.g., from &lt;code&gt;post-command-hook&lt;/code&gt;). Supplying a function for &lt;var&gt;collection&lt;/var&gt; is strongly recommended if generating the list of completions is an expensive operation. Emacs may internally call functions in &lt;code&gt;completion-at-point-functions&lt;/code&gt; many times, but care about the value of &lt;var&gt;collection&lt;/var&gt; for only some of these calls. By supplying a function for &lt;var&gt;collection&lt;/var&gt;, Emacs can defer generating completions until necessary. You can use &lt;code&gt;completion-table-dynamic&lt;/code&gt; to create a wrapper function:</source>
          <target state="translated">이 후크의 함수는 매우 자주 호출 될 수 있으므로 일반적으로 빠르게 반환되어야합니다 (예 : &lt;code&gt;post-command-hook&lt;/code&gt; 에서 ). 완성 목록을 생성하는 것이 비용이 많이 드는 작업 인 경우 &lt;var&gt;collection&lt;/var&gt; 위한 함수를 제공하는 것이 좋습니다. Emacs는 내부적으로 complete &lt;code&gt;completion-at-point-functions&lt;/code&gt; 여러 번 호출 할 수 있지만 이러한 호출 중 일부에 대해서만 &lt;var&gt;collection&lt;/var&gt; 값에 신경을 씁니다. &lt;var&gt;collection&lt;/var&gt; 에 대한 함수를 제공함으로써 Emacs는 필요할 때까지 생성 완료를 연기 할 수 있습니다. 당신은 사용할 수 있습니다 &lt;code&gt;completion-table-dynamic&lt;/code&gt; 래퍼 함수를 만들 :</target>
        </trans-unit>
        <trans-unit id="2b93b057b358caf809f0e8e2015f2926ba7f4928" translate="yes" xml:space="preserve">
          <source>The functions should record the faces they assign by setting the &lt;code&gt;face&lt;/code&gt; property. They should also add a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;fontified&lt;/code&gt; property to all the text they have assigned faces to. That property tells redisplay that faces have been assigned to that text already.</source>
          <target state="translated">함수는 &lt;code&gt;face&lt;/code&gt; 속성 을 설정하여 할당 된 얼굴을 기록해야 합니다. 또한 얼굴을 할당 한 모든 텍스트에 &lt;code&gt;nil&lt;/code&gt; 이 아닌 &lt;code&gt;fontified&lt;/code&gt; 속성을 추가해야 합니다. 이 속성은면이 이미 해당 텍스트에 할당되었음을 다시 표시합니다.</target>
        </trans-unit>
        <trans-unit id="41a0cd34297ecae8f4a088b103fb22bcddfee322" translate="yes" xml:space="preserve">
          <source>The functions that modify the contents of buffers are described in &lt;a href=&quot;text#Text&quot;&gt;Text&lt;/a&gt;.</source>
          <target state="translated">버퍼의 내용을 수정하는 함수는 &lt;a href=&quot;text#Text&quot;&gt;Text에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f40f1de7f1f1333998ea5f91c2f809716617bf8b" translate="yes" xml:space="preserve">
          <source>The functions you use in these hooks should save and restore the match data if they do anything that uses regular expressions; otherwise, they will interfere in bizarre ways with the editing operations that call them.</source>
          <target state="translated">이러한 후크에서 사용하는 함수는 정규 표현식을 사용하는 모든 작업을 수행하는 경우 일치 데이터를 저장하고 복원해야합니다. 그렇지 않으면 그것들을 호출하는 편집 작업을 기괴하게 방해 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="9072c6223cc7e87e04b922ff1eeb8eb85826e5dd" translate="yes" xml:space="preserve">
          <source>The fundamental interface to input methods is through the variable &lt;code&gt;input-method-function&lt;/code&gt;. See &lt;a href=&quot;reading-one-event#Reading-One-Event&quot;&gt;Reading One Event&lt;/a&gt;, and &lt;a href=&quot;invoking-the-input-method#Invoking-the-Input-Method&quot;&gt;Invoking the Input Method&lt;/a&gt;.</source>
          <target state="translated">입력 방법에 대한 기본 인터페이스는 변수 &lt;code&gt;input-method-function&lt;/code&gt; 을 사용하는 것 입니다. &lt;a href=&quot;reading-one-event#Reading-One-Event&quot;&gt;하나의 이벤트 읽기&lt;/a&gt; 및 &lt;a href=&quot;invoking-the-input-method#Invoking-the-Input-Method&quot;&gt;입력 방법 호출을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="864ab21bc83654287c4cd15a4aee02d9312d9750" translate="yes" xml:space="preserve">
          <source>The gap in the buffer.</source>
          <target state="translated">버퍼의 간격입니다.</target>
        </trans-unit>
        <trans-unit id="2874b04cef330c832d718bb6b17cf07f619d5cf4" translate="yes" xml:space="preserve">
          <source>The garbage collector described above is used to manage data visible from Lisp programs, as well as most of the data internally used by the Lisp interpreter. Sometimes it may be useful to allocate temporary internal objects using the C stack of the interpreter. This can help performance, as stack allocation is typically faster than using heap memory to allocate and the garbage collector to free. The downside is that using such objects after they are freed results in undefined behavior, so uses should be well thought out and carefully debugged by using the &lt;code&gt;GC_CHECK_MARKED_OBJECTS&lt;/code&gt; feature (see</source>
          <target state="translated">위에서 설명한 가비지 수집기는 Lisp 프로그램에서 볼 수있는 데이터와 Lisp 인터프리터가 내부적으로 사용하는 대부분의 데이터를 관리하는 데 사용됩니다. 인터프리터의 C 스택을 사용하여 임시 내부 객체를 할당하는 것이 유용 할 수 있습니다. 스택 할당은 일반적으로 힙 메모리를 사용하여 할당하고 가비지 수집기를 사용하는 것보다 빠르기 때문에 성능에 도움이 될 수 있습니다. 단점은 이러한 객체를 해제 한 후 사용하면 정의되지 않은 동작이 발생하므로 사용을 신중하게 고려하고 &lt;code&gt;GC_CHECK_MARKED_OBJECTS&lt;/code&gt; 기능 을 사용하여 신중하게 디버깅 해야 합니다 (참조</target>
        </trans-unit>
        <trans-unit id="da7a69d66cc2d899f159c6785baa3eb8aa0ce902" translate="yes" xml:space="preserve">
          <source>The general sequence functions &lt;code&gt;copy-sequence&lt;/code&gt; and &lt;code&gt;length&lt;/code&gt; are often useful for objects known to be arrays. See &lt;a href=&quot;sequence-functions#Sequence-Functions&quot;&gt;Sequence Functions&lt;/a&gt;.</source>
          <target state="translated">일반적인 시퀀스 함수 &lt;code&gt;copy-sequence&lt;/code&gt; 및 &lt;code&gt;length&lt;/code&gt; 는 종종 배열로 알려진 객체에 유용합니다. &lt;a href=&quot;sequence-functions#Sequence-Functions&quot;&gt;시퀀스 함수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="74ab5893b0c67e70995b4afd47d2628e73c2db5f" translate="yes" xml:space="preserve">
          <source>The geometry of a frame depends on the toolkit that was used to build this instance of Emacs and the terminal that displays the frame. This chapter describes these dependencies and some of the functions to deal with them. Note that the &lt;var&gt;frame&lt;/var&gt; argument of all of these functions has to specify a live frame (see &lt;a href=&quot;deleting-frames#Deleting-Frames&quot;&gt;Deleting Frames&lt;/a&gt;). If omitted or &lt;code&gt;nil&lt;/code&gt;, it specifies the selected frame (see &lt;a href=&quot;input-focus#Input-Focus&quot;&gt;Input Focus&lt;/a&gt;).</source>
          <target state="translated">프레임의 지오메트리는이 Emacs 인스턴스를 빌드하는 데 사용 된 툴킷과 프레임을 표시하는 터미널에 따라 다릅니다. 이 장에서는 이러한 종속성과이를 처리하는 일부 기능에 대해 설명합니다. 이러한 모든 함수 의 &lt;var&gt;frame&lt;/var&gt; 인수는 라이브 프레임을 지정해야합니다 (프레임 &lt;a href=&quot;deleting-frames#Deleting-Frames&quot;&gt;삭제&lt;/a&gt; 참조 ). 생략되거나 &lt;code&gt;nil&lt;/code&gt; 이면 선택한 프레임을 지정합니다 ( &lt;a href=&quot;input-focus#Input-Focus&quot;&gt;입력 포커스&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="b1b29a18ef7eb3bc56262e0c7ebd91ab2315293b" translate="yes" xml:space="preserve">
          <source>The global break condition is the simplest way to find where in your code some event occurs, but it makes code run much more slowly. So you should reset the condition to &lt;code&gt;nil&lt;/code&gt; when not using it.</source>
          <target state="translated">전역 중단 조건은 코드에서 이벤트가 발생하는 위치를 찾는 가장 간단한 방법이지만 코드가 훨씬 더 느리게 실행됩니다. 따라서 사용하지 않을 때는 조건을 &lt;code&gt;nil&lt;/code&gt; 로 재설정해야 합니다.</target>
        </trans-unit>
        <trans-unit id="677591024d62617ead5c6d0b2e26233fd0d1c3c3" translate="yes" xml:space="preserve">
          <source>The global keymap used for the</source>
          <target state="translated">에 사용되는 전역 키맵</target>
        </trans-unit>
        <trans-unit id="f34b8f5f97a899dc0235f5429a6468bfeef23c7c" translate="yes" xml:space="preserve">
          <source>The global value of a variable with buffer-local bindings is also called the &lt;em&gt;default&lt;/em&gt; value, because it is the value that is in effect whenever neither the current buffer nor the selected frame has its own binding for the variable.</source>
          <target state="translated">버퍼-로컬 바인딩이있는 변수의 전역 값은 현재 버퍼 나 선택한 프레임에 변수에 대한 자체 바인딩이 없을 때 적용되는 값이기 때문에 &lt;em&gt;기본값&lt;/em&gt; 이라고도합니다 .</target>
        </trans-unit>
        <trans-unit id="48d60332f6bc67502145a457cd0abab79aebcbd7" translate="yes" xml:space="preserve">
          <source>The glyph for indicating a character displayed as an octal character code (the default is &amp;lsquo;</source>
          <target state="translated">8 진수 문자 코드로 표시되는 문자를 나타내는 글리프 (기본값은 '</target>
        </trans-unit>
        <trans-unit id="4c3656eced1ce2d785af3b405b7e21744ff87d83" translate="yes" xml:space="preserve">
          <source>The glyph for indicating a control character (the default is &amp;lsquo;</source>
          <target state="translated">제어 문자를 나타내는 글리프 (기본값은 '</target>
        </trans-unit>
        <trans-unit id="69c90a66f7f1266d48dbdea6d60aeb7561e7e5b2" translate="yes" xml:space="preserve">
          <source>The glyph for the end of a continued line (the default is &amp;lsquo;</source>
          <target state="translated">연속 된 줄의 끝을 나타내는 문자 (기본값은 '</target>
        </trans-unit>
        <trans-unit id="306df86e6b80484f756d552795447d03999ab82a" translate="yes" xml:space="preserve">
          <source>The glyph for the end of a truncated screen line (the default for this is &amp;lsquo;</source>
          <target state="translated">잘린 화면 줄 끝의 글리프 (기본값은 '</target>
        </trans-unit>
        <trans-unit id="e37bea5e929c17d760a16f5f703fed0ee026e680" translate="yes" xml:space="preserve">
          <source>The glyph used to draw the border between side-by-side windows (the default is &amp;lsquo;</source>
          <target state="translated">나란히있는 창 사이의 테두리를 그리는 데 사용되는 글리프 (기본값은 '</target>
        </trans-unit>
        <trans-unit id="97cde47c6c4afb345587e69edf666417f9a205ca" translate="yes" xml:space="preserve">
          <source>The gradient created (and inserted into the SVG object) can later be used by all functions that create shapes.</source>
          <target state="translated">생성 된 (그리고 SVG 객체에 삽입 된) 그래디언트는 나중에 모양을 생성하는 모든 함수에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f64a77472c5aab1a530dafab8dc80afd47098d3" translate="yes" xml:space="preserve">
          <source>The grammar category &lt;code&gt;id&lt;/code&gt; has no right hand side: this does not mean that it can match only the empty string, since as mentioned any sequence of sexps can appear anywhere anyway.</source>
          <target state="translated">문법 범주 &lt;code&gt;id&lt;/code&gt; 에는 오른쪽이 없습니다. 언급했듯이 모든 sexps 시퀀스가 ​​어쨌든 나타날 수 있으므로 빈 문자열과 만 일치 할 수 있다는 의미는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="731ba1b7288e05cf815c9c7aa4fd003aeedac70a" translate="yes" xml:space="preserve">
          <source>The greediness of some repetition forms can be controlled using the following constructs. However, it is usually better to use the explicit non-greedy forms above when such matching is required.</source>
          <target state="translated">일부 반복 형식의 탐욕은 다음 구성을 사용하여 제어 할 수 있습니다. 그러나 일반적으로 이러한 일치가 필요한 경우 위의 명시 적 비 탐욕 양식을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="25880d28e40fdac189e642330863b2e6c8e69129" translate="yes" xml:space="preserve">
          <source>The group ID of the effective user ID, a number.</source>
          <target state="translated">유효 사용자 ID의 그룹 ID, 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="b554cee81a954e5281b1fceb788df4a63ce37792" translate="yes" xml:space="preserve">
          <source>The handler function must handle all of the above operations, and possibly others to be added in the future. It need not implement all these operations itself&amp;mdash;when it has nothing special to do for a certain operation, it can reinvoke the primitive, to handle the operation in the usual way. It should always reinvoke the primitive for an operation it does not recognize. Here&amp;rsquo;s one way to do this:</source>
          <target state="translated">핸들러 함수는 위의 모든 작업을 처리해야하며 향후 추가 될 다른 작업도 처리해야합니다. 이 모든 작업을 자체적으로 구현할 필요는 없습니다. 특정 작업에 대해 특별한 작업이없는 경우 기본을 다시 호출하여 일반적인 방식으로 작업을 처리 할 수 ​​있습니다. 인식하지 못하는 작업에 대해서는 항상 기본을 다시 호출해야합니다. 이를 수행하는 한 가지 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8c0ade08243887c3328d4d5be685acc33d281985" translate="yes" xml:space="preserve">
          <source>The handler specifies condition name &lt;code&gt;arith-error&lt;/code&gt; so that it will handle only division-by-zero errors. Other kinds of errors will not be handled (by this &lt;code&gt;condition-case&lt;/code&gt;). Thus:</source>
          <target state="translated">핸들러 는 0으로 나누기 오류 만 처리하도록 조건 이름 &lt;code&gt;arith-error&lt;/code&gt; 를 지정 합니다. 다른 종류의 오류는 처리되지 않습니다 (이 &lt;code&gt;condition-case&lt;/code&gt; 의해 ). 그러므로:</target>
        </trans-unit>
        <trans-unit id="5e2f99bb60355a4bbc279516a684257561edba5f" translate="yes" xml:space="preserve">
          <source>The header and footer strings.</source>
          <target state="translated">머리글 및 바닥 글 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="e6adc3e0fab908b197122795c03e598c9a217b17" translate="yes" xml:space="preserve">
          <source>The height in pixels of the mode line and the header line, or -1 if not known.</source>
          <target state="translated">모드 행과 헤더 행의 높이 (픽셀 단위) 또는 알 수없는 경우 -1입니다.</target>
        </trans-unit>
        <trans-unit id="9e8ea212a3dcb1bbe9f9c723144aa8ee19f65b61" translate="yes" xml:space="preserve">
          <source>The height is normally the length of &lt;var&gt;bits&lt;/var&gt;. However, you can specify a different height with non-&lt;code&gt;nil&lt;/code&gt;&lt;var&gt;height&lt;/var&gt;. The width is normally 8, but you can specify a different width with non-&lt;code&gt;nil&lt;/code&gt;&lt;var&gt;width&lt;/var&gt;. The width must be an integer between 1 and 16.</source>
          <target state="translated">높이는 일반적으로 &lt;var&gt;bits&lt;/var&gt; 길이입니다 . 그러나 비와 다른 높이를 지정할 수 있습니다 &lt;code&gt;nil&lt;/code&gt; &lt;var&gt;height&lt;/var&gt; . 폭은 일반적으로 8,하지만 당신은 비와 다른 폭을 지정할 수 있습니다 &lt;code&gt;nil&lt;/code&gt; &lt;var&gt;width&lt;/var&gt; . 너비는 1에서 16 사이의 정수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="52397327e47c6d0da26d3462e7bc63626661f579" translate="yes" xml:space="preserve">
          <source>The height of horizontal scroll bars, in pixels, or &lt;code&gt;nil&lt;/code&gt; meaning to use the default height.</source>
          <target state="translated">가로 스크롤 막대의 높이 (픽셀 단위) 또는 기본 높이를 사용하는 것을 의미하는 &lt;code&gt;nil&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="085e0e5d1f8cb968ce655bf2b24ca248fa12970b" translate="yes" xml:space="preserve">
          <source>The height of the default face must be specified using an integer; floating point and function values are not allowed.</source>
          <target state="translated">기본 얼굴의 높이는 정수를 사용하여 지정해야합니다. 부동 소수점 및 함수 값은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d18f875e6e2637cf49c5905a5f35264c51a521b7" translate="yes" xml:space="preserve">
          <source>The height of the font in pixels.</source>
          <target state="translated">글꼴의 높이 (픽셀)입니다.</target>
        </trans-unit>
        <trans-unit id="bcc4b1c7f0f04cad27e2f37687ce77b17aac9cc1" translate="yes" xml:space="preserve">
          <source>The height of the font. In the simplest case, this is an integer in units of 1/10 point.</source>
          <target state="translated">글꼴의 높이입니다. 가장 간단한 경우 1/10 포인트 단위의 정수입니다.</target>
        </trans-unit>
        <trans-unit id="3ed16f18e3452e0d7fb567a3976b1f69a672c4c7" translate="yes" xml:space="preserve">
          <source>The height of the line contents is the maximum height of any character or image on that display line, including the final newline if there is one. (A display line that is continued doesn&amp;rsquo;t include a final newline.) That is the default line height, if you do nothing to specify a greater height. (In the most common case, this equals the height of the corresponding frame&amp;rsquo;s default font, see &lt;a href=&quot;frame-font#Frame-Font&quot;&gt;Frame Font&lt;/a&gt;.)</source>
          <target state="translated">줄 내용의 높이는 마지막 줄 바꿈이있는 경우를 포함하여 해당 표시 줄에있는 모든 문자 또는 이미지의 최대 높이입니다. (계속되는 표시 줄에는 최종 줄 바꿈이 포함되지 않습니다.) 더 큰 높이를 지정하기 위해 아무것도하지 않는 경우 기본 줄 높이입니다. (가장 일반적인 경우에는 해당 프레임의 기본 글꼴 높이와 같습니다 . &lt;a href=&quot;frame-font#Frame-Font&quot;&gt;프레임 글꼴을&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="fa5537f62fa0722eb0e8bcb5ec344261bd62fa37" translate="yes" xml:space="preserve">
          <source>The help character is special after prefix keys, too. If it has no binding as a subcommand of the prefix key, it runs &lt;code&gt;describe-prefix-bindings&lt;/code&gt;, which displays a list of all the subcommands of the prefix key.</source>
          <target state="translated">도움말 문자는 접두사 키 이후에도 특별합니다. 접두사 키의 하위 명령으로 바인딩이없는 경우 접두사 키 의 모든 하위 명령 목록을 표시하는 &lt;code&gt;describe-prefix-bindings&lt;/code&gt; 를 실행 합니다.</target>
        </trans-unit>
        <trans-unit id="cf1897bec9624ad141a9f5fdb49dabce4abf14b2" translate="yes" xml:space="preserve">
          <source>The high-level completion functions &lt;code&gt;read-file-name&lt;/code&gt;, &lt;code&gt;read-directory-name&lt;/code&gt;, and &lt;code&gt;read-shell-command&lt;/code&gt; are designed to read file names, directory names, and shell commands, respectively. They provide special features, including automatic insertion of the default directory.</source>
          <target state="translated">고급 완성 함수 &lt;code&gt;read-file-name&lt;/code&gt; , &lt;code&gt;read-directory-name&lt;/code&gt; 및 &lt;code&gt;read-shell-command&lt;/code&gt; 는 각각 파일 이름, 디렉토리 이름 및 셸 명령을 읽도록 설계되었습니다. 기본 디렉토리의 자동 삽입을 포함한 특수 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fc37323f324eaba3ae4eff83c852720c416eda92" translate="yes" xml:space="preserve">
          <source>The homepage for GNU Emacs is at &lt;a href=&quot;https://www.gnu.org/software/emacs/&quot;&gt;https://www.gnu.org/software/emacs/&lt;/a&gt;. For information on using Emacs, refer to the &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/emacs.html&quot;&gt;Emacs Manual&lt;/a&gt;. To view this manual in other formats, click &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/elisp.html&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">GNU Emacs의 홈페이지는 &lt;a href=&quot;https://www.gnu.org/software/emacs/&quot;&gt;https://www.gnu.org/software/emacs/&lt;/a&gt; 입니다. Emacs 사용에 대한 정보는 &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/emacs.html&quot;&gt;Emacs 매뉴얼을&lt;/a&gt; 참조하십시오 . 이 설명서를 다른 형식으로 보려면 &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/elisp.html&quot;&gt;여기를&lt;/a&gt; 클릭 하십시오 .</target>
        </trans-unit>
        <trans-unit id="b911bf982537bd609db0a1e22baeb6c2bb97081a" translate="yes" xml:space="preserve">
          <source>The hook functions are called both before and after each change. If the functions save the information they receive, and compare notes between calls, they can determine exactly what change has been made in the buffer text.</source>
          <target state="translated">후크 함수는 각 변경 전후에 모두 호출됩니다. 함수가 수신 한 정보를 저장하고 호출간에 메모를 비교하면 버퍼 텍스트에서 변경된 내용을 정확히 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22eea4ac020189ebcc5a0b2b55d9b0917f8943a9" translate="yes" xml:space="preserve">
          <source>The hook functions in &lt;code&gt;write-file-functions&lt;/code&gt; are also responsible for encoding the data (if desired): they must choose a suitable coding system and end-of-line conversion (see &lt;a href=&quot;lisp-and-coding-systems#Lisp-and-Coding-Systems&quot;&gt;Lisp and Coding Systems&lt;/a&gt;), perform the encoding (see &lt;a href=&quot;explicit-encoding#Explicit-Encoding&quot;&gt;Explicit Encoding&lt;/a&gt;), and set &lt;code&gt;last-coding-system-used&lt;/code&gt; to the coding system that was used (see &lt;a href=&quot;encoding-and-i_002fo#Encoding-and-I_002fO&quot;&gt;Encoding and I/O&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;write-file-functions&lt;/code&gt; 의 후크 함수 는 데이터 인코딩도 담당합니다 (원하는 경우) : 적절한 코딩 시스템과 줄 끝 변환 ( &lt;a href=&quot;lisp-and-coding-systems#Lisp-and-Coding-Systems&quot;&gt;Lisp 및 코딩 시스템&lt;/a&gt; 참조 )을 선택하고 인코딩을 수행해야합니다 ( &lt;a href=&quot;explicit-encoding#Explicit-Encoding&quot;&gt;명시 적 인코딩&lt;/a&gt; 참조). ), &lt;code&gt;last-coding-system-used&lt;/code&gt; 을 사용 된 코딩 시스템으로 설정합니다 ( &lt;a href=&quot;encoding-and-i_002fo#Encoding-and-I_002fO&quot;&gt;인코딩 및 I / O 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a83d039cd150de7d3779ef3fed719d6f59169d0d" translate="yes" xml:space="preserve">
          <source>The hook variable&amp;rsquo;s value can also be a single function&amp;mdash;either a lambda expression or a symbol with a function definition&amp;mdash;which &lt;code&gt;run-hooks&lt;/code&gt; calls. But this usage is obsolete.</source>
          <target state="translated">후크 변수의 값은 호출 을 &lt;code&gt;run-hooks&lt;/code&gt; 하는 단일 함수 (람다 식 또는 함수 정의가있는 기호) 일 수도 있습니다 . 그러나이 사용법은 쓸모가 없습니다.</target>
        </trans-unit>
        <trans-unit id="917207ef55ed03cab5a1b55d69aa1063946c90b6" translate="yes" xml:space="preserve">
          <source>The horizontal scroll position is measured in units of the normal character width, which is the width of space in the default font. Thus, if the value is 5, that means the window contents are scrolled left by 5 times the normal character width. How many characters actually disappear off to the left depends on their width, and could vary from line to line.</source>
          <target state="translated">가로 스크롤 위치는 기본 글꼴의 공백 너비 인 일반 문자 너비 단위로 측정됩니다. 따라서 값이 5이면 창 내용이 일반 문자 너비의 5 배 왼쪽으로 스크롤됨을 의미합니다. 실제로 왼쪽으로 사라지는 문자 수는 너비에 따라 다르며 줄마다 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c1208df201cdc168e0e1bc7a6b67590a4982002" translate="yes" xml:space="preserve">
          <source>The hour of the day, as an integer between 0 and 23.</source>
          <target state="translated">0에서 23 사이의 정수로 표시되는 시간입니다.</target>
        </trans-unit>
        <trans-unit id="ff593a5384b2422b04132851d0695820fe2b360f" translate="yes" xml:space="preserve">
          <source>The hyper modifier.</source>
          <target state="translated">하이퍼 수정 자입니다.</target>
        </trans-unit>
        <trans-unit id="49029170f2d47fd9fece1b8af2f1320f67032a13" translate="yes" xml:space="preserve">
          <source>The idea of these variables is that you set them once and for all to the defaults you want, and then do not change them again. To specify a particular coding system for a particular operation in a Lisp program, don&amp;rsquo;t change these variables; instead, override them using &lt;code&gt;coding-system-for-read&lt;/code&gt; and &lt;code&gt;coding-system-for-write&lt;/code&gt; (see &lt;a href=&quot;specifying-coding-systems#Specifying-Coding-Systems&quot;&gt;Specifying Coding Systems&lt;/a&gt;).</source>
          <target state="translated">이러한 변수의 개념은 원하는 기본값으로 한 번만 설정 한 다음 다시 변경하지 않는 것입니다. Lisp 프로그램의 특정 작업에 대해 특정 코딩 시스템을 지정하려면 이러한 변수를 변경하지 마십시오. 대신 &lt;code&gt;coding-system-for-read&lt;/code&gt; &lt;code&gt;coding-system-for-write&lt;/code&gt; 및 쓰기 용 코딩 시스템을 사용하여 재정의 하십시오 ( &lt;a href=&quot;specifying-coding-systems#Specifying-Coding-Systems&quot;&gt;코딩 시스템 지정&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="9bcbe3e1bcf694fbe61bf24fe3189fb33ab88208" translate="yes" xml:space="preserve">
          <source>The identified of the shape.</source>
          <target state="translated">모양의 식별.</target>
        </trans-unit>
        <trans-unit id="fcfecb9412ebffc1d18084e74054383228e6b207" translate="yes" xml:space="preserve">
          <source>The image is looked for in &lt;code&gt;image-load-path&lt;/code&gt;.</source>
          <target state="translated">이미지는 &lt;code&gt;image-load-path&lt;/code&gt; 에서 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="8ea3cffbf70cec22855c36d36842437f817a7f5e" translate="yes" xml:space="preserve">
          <source>The image type. See &lt;a href=&quot;image-formats#Image-Formats&quot;&gt;Image Formats&lt;/a&gt;. Every image descriptor must include this property.</source>
          <target state="translated">이미지 유형입니다. &lt;a href=&quot;image-formats#Image-Formats&quot;&gt;이미지 형식을&lt;/a&gt; 참조하십시오 . 모든 이미지 설명자는이 속성을 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="caab580d160dc64b9167916da831f3bf977e17a4" translate="yes" xml:space="preserve">
          <source>The indentation functions are used to examine, move to, and change whitespace that is at the beginning of a line. Some of the functions can also change whitespace elsewhere on a line. Columns and indentation count from zero at the left margin.</source>
          <target state="translated">들여 쓰기 함수는 줄의 시작 부분에있는 공백을 검사, 이동 및 변경하는 데 사용됩니다. 일부 함수는 줄의 다른 곳에서도 공백을 변경할 수 있습니다. 열과 들여 쓰기는 왼쪽 여백에서 0부터 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="6cabff1a9cf356561844c4900ceadda4f5c31acc" translate="yes" xml:space="preserve">
          <source>The index alist can have three types of elements. Simple elements look like this:</source>
          <target state="translated">색인 목록에는 세 가지 유형의 요소가있을 수 있습니다. 간단한 요소는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7a2782dc40deb6629a41f6379bf7a7210bdb0f97" translate="yes" xml:space="preserve">
          <source>The index of the first character of the string is 0, the index of the second character is 1, and so on.</source>
          <target state="translated">문자열의 첫 번째 문자의 인덱스는 0이고 두 번째 문자의 인덱스는 1입니다.</target>
        </trans-unit>
        <trans-unit id="60e96bc26c021609e7a6560eb3d5be49e8d331cc" translate="yes" xml:space="preserve">
          <source>The initial threshold value is &lt;code&gt;GC_DEFAULT_THRESHOLD&lt;/code&gt;, defined in</source>
          <target state="translated">초기 임계 값은 &lt;code&gt;GC_DEFAULT_THRESHOLD&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9fd1b2d43c07a66938f2a442d8dcfd842c600cd8" translate="yes" xml:space="preserve">
          <source>The initial value must be &lt;code&gt;nil&lt;/code&gt; except in cases where (1) the mode is preloaded in Emacs, or (2) it is painless for loading to enable the mode even though the user did not request it. For instance, if the mode has no effect unless something else is enabled, and will always be loaded by that time, enabling it by default is harmless. But these are unusual circumstances. Normally, the initial value must be &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">(1) 모드가 Emacs에 미리로드되어있는 경우를 제외하고 초기 값은 &lt;code&gt;nil&lt;/code&gt; 이어야합니다 . 또는 (2) 사용자가 요청하지 않았음에도 불구하고 모드를 활성화하기 위해로드하는 데 어려움이 없습니다. 예를 들어, 다른 기능이 활성화되어 있지 않으면 모드가 효과가없고 그 시간까지 항상로드되는 경우 기본적으로 활성화하는 것은 무해합니다. 그러나 이것은 비정상적인 상황입니다. 일반적으로 초기 값은 &lt;code&gt;nil&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="b5ea75158d88e76423df4c71cfe451830055f3b4" translate="yes" xml:space="preserve">
          <source>The initialization function should perform whatever initialization is required for the module. In addition, it can perform the following tasks:</source>
          <target state="translated">초기화 기능은 모듈에 필요한 모든 초기화를 수행해야합니다. 또한 다음 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2048f16a290b5e24dd2783eb5cab68b8c1d9c150" translate="yes" xml:space="preserve">
          <source>The input characters are generated by &lt;var&gt;function&lt;/var&gt;, which must support two kinds of calls:</source>
          <target state="translated">입력 문자는 &lt;var&gt;function&lt;/var&gt; 에 의해 생성되며 두 종류의 호출을 지원해야합니다.</target>
        </trans-unit>
        <trans-unit id="d16b3143ae14de892229a66c0119a9b13c4bbc54" translate="yes" xml:space="preserve">
          <source>The input characters are read from &lt;var&gt;buffer&lt;/var&gt;, starting with the character directly after point. Point advances as characters are read.</source>
          <target state="translated">입력 문자는 point 바로 뒤의 문자로 시작하여 &lt;var&gt;buffer&lt;/var&gt; 에서 읽습니다 . 문자를 읽을 때 포인트가 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="b99b6f486be0660a0034322da91996c0f39b3329" translate="yes" xml:space="preserve">
          <source>The input characters are read from the buffer that &lt;var&gt;marker&lt;/var&gt; is in, starting with the character directly after the marker. The marker position advances as characters are read. The value of point in the buffer has no effect when the stream is a marker.</source>
          <target state="translated">입력 문자는 &lt;var&gt;marker&lt;/var&gt; 바로 뒤의 문자부터 시작하여 마커 가 있는 버퍼에서 읽습니다 . 마커 위치는 문자를 읽을 때 이동합니다. 버퍼의 포인트 값은 스트림이 마커 인 경우 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="d8b5e8488b3fb00ae952a888effb061b3b3f5bf0" translate="yes" xml:space="preserve">
          <source>The input characters are taken from &lt;var&gt;string&lt;/var&gt;, starting at the first character in the string and using as many characters as required.</source>
          <target state="translated">입력 문자는 &lt;var&gt;string&lt;/var&gt; 에서 가져 오며 문자열 의 첫 번째 문자에서 시작하여 필요한만큼의 문자를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="30d1dd399ecaac7e239b3eddf29871a33b0d6701" translate="yes" xml:space="preserve">
          <source>The input method function is not called when reading the second and subsequent events of a key sequence. Thus, these characters are not subject to input method processing. The input method function should test the values of &lt;code&gt;overriding-local-map&lt;/code&gt; and &lt;code&gt;overriding-terminal-local-map&lt;/code&gt;; if either of these variables is non-&lt;code&gt;nil&lt;/code&gt;, the input method should put its argument into a list and return that list with no further processing.</source>
          <target state="translated">키 시퀀스의 두 번째 및 후속 이벤트를 읽을 때 입력 방법 함수가 호출되지 않습니다. 따라서 이러한 문자는 입력 방법 처리의 대상이 아닙니다. 입력 메소드 함수는 &lt;code&gt;overriding-local-map&lt;/code&gt; 및 &lt;code&gt;overriding-terminal-local-map&lt;/code&gt; 의 값을 테스트해야합니다 . 이러한 변수 중 하나가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 입력 메소드는 인수를 목록에 넣고 추가 처리없이 해당 목록을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="f8c4abba5f74f931bc34d6747a6123acafdf7779" translate="yes" xml:space="preserve">
          <source>The input method function should return a list of events which should be used as input. (If the list is &lt;code&gt;nil&lt;/code&gt;, that means there is no input, so &lt;code&gt;read-event&lt;/code&gt; waits for another event.) These events are processed before the events in &lt;code&gt;unread-command-events&lt;/code&gt; (see &lt;a href=&quot;event-input-misc#Event-Input-Misc&quot;&gt;Event Input Misc&lt;/a&gt;). Events returned by the input method function are not passed to the input method function again, even if they are printing characters with no modifier bits.</source>
          <target state="translated">입력 방법 함수는 입력으로 사용해야하는 이벤트 목록을 반환해야합니다. (목록이 &lt;code&gt;nil&lt;/code&gt; 이면 입력이 없음을 의미하므로 &lt;code&gt;read-event&lt;/code&gt; 는 다른 이벤트를 기다립니다.) 이러한 이벤트는 &lt;code&gt;unread-command-events&lt;/code&gt; 의 이벤트보다 먼저 처리됩니다 ( &lt;a href=&quot;event-input-misc#Event-Input-Misc&quot;&gt;Event Input Misc&lt;/a&gt; 참조 ). 입력 방법 함수에 의해 반환 된 이벤트는 수정 자 비트가없는 문자를 인쇄하더라도 입력 방법 함수에 다시 전달되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="539f747cb977830607d3cb710459ac2c2e5fa6fa" translate="yes" xml:space="preserve">
          <source>The inputs to GnuTLS cryptographic functions can be specified in several ways, both as primitive Emacs Lisp types or as lists.</source>
          <target state="translated">GnuTLS 암호화 함수에 대한 입력은 기본 Emacs Lisp 유형 또는 목록으로 여러 가지 방법으로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7b8358b8f766540c234e4f8211a9601148d23fb" translate="yes" xml:space="preserve">
          <source>The inserted whitespace characters inherit text properties from the surrounding text (usually, from the preceding text only). See &lt;a href=&quot;sticky-properties#Sticky-Properties&quot;&gt;Sticky Properties&lt;/a&gt;.</source>
          <target state="translated">삽입 된 공백 문자는 주변 텍스트의 텍스트 속성을 상속합니다 (일반적으로 이전 텍스트에서만). &lt;a href=&quot;sticky-properties#Sticky-Properties&quot;&gt;고정 속성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="19fcbfab08e4368504efbf1b8e28b4430ed27384" translate="yes" xml:space="preserve">
          <source>The insertion functions convert text from unibyte to multibyte in order to insert in a multibyte buffer, and vice versa&amp;mdash;if the text comes from a string or from a buffer. However, they do not convert unibyte character codes 128 through 255 to multibyte characters, not even if the current buffer is a multibyte buffer. See &lt;a href=&quot;converting-representations#Converting-Representations&quot;&gt;Converting Representations&lt;/a&gt;.</source>
          <target state="translated">삽입 함수는 멀티 바이트 버퍼에 삽입하기 위해 텍스트를 유니 바이트에서 멀티 바이트로 변환하고 그 반대의 경우도 마찬가지입니다 (텍스트가 문자열 또는 버퍼에서 가져온 경우). 그러나 현재 버퍼가 멀티 바이트 버퍼 인 경우에도 128에서 255까지의 유니 바이트 문자 코드를 멀티 바이트 문자로 변환하지 않습니다. &lt;a href=&quot;converting-representations#Converting-Representations&quot;&gt;표현 변환을&lt;/a&gt; 참고하십시오 .</target>
        </trans-unit>
        <trans-unit id="9edd2288269cf326b182d9af537f1760ef9f7146" translate="yes" xml:space="preserve">
          <source>The integer -1 looks like this:</source>
          <target state="translated">정수 -1은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2f33429d3899a8b5708f577a6767b2323bf9589e" translate="yes" xml:space="preserve">
          <source>The integer number of 365-day years.</source>
          <target state="translated">365 일 연도의 정수입니다.</target>
        </trans-unit>
        <trans-unit id="e0d849236066efb1e790a734829181ed8c3e9ff5" translate="yes" xml:space="preserve">
          <source>The integer number of days.</source>
          <target state="translated">정수 일 수입니다.</target>
        </trans-unit>
        <trans-unit id="5cf7a7da13ec55fcd8e83c9522a19ff613f26c8a" translate="yes" xml:space="preserve">
          <source>The integer number of hours.</source>
          <target state="translated">시간의 정수입니다.</target>
        </trans-unit>
        <trans-unit id="bb774face5c62942103b0f3a113c848cd3042edd" translate="yes" xml:space="preserve">
          <source>The integer number of minutes.</source>
          <target state="translated">분의 정수입니다.</target>
        </trans-unit>
        <trans-unit id="9cbc76323d9ab5bd63ae8f77ccce189f3b0df5e3" translate="yes" xml:space="preserve">
          <source>The integer number of seconds.</source>
          <target state="translated">초의 정수입니다.</target>
        </trans-unit>
        <trans-unit id="d26badfedc58bbcef7881a113b18e385a9856fff" translate="yes" xml:space="preserve">
          <source>The intent of &lt;code&gt;key-translation-map&lt;/code&gt; is for users to map one character set to another, including ordinary characters normally bound to &lt;code&gt;self-insert-command&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key-translation-map&lt;/code&gt; 의 의도는 일반적으로 &lt;code&gt;self-insert-command&lt;/code&gt; 에 바인딩 된 일반 문자를 포함하여 사용자가 한 문자 집합을 다른 문자 집합에 매핑하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="20d665cdf72ab80e27c444ceb9eb5618fb5457fb" translate="yes" xml:space="preserve">
          <source>The interactive declaration is a list of the form &lt;code&gt;(interactive
&lt;var&gt;code-string&lt;/var&gt;)&lt;/code&gt;. This declares how to provide arguments if the function is used interactively. Functions with this declaration are called &lt;em&gt;commands&lt;/em&gt;; they can be called using</source>
          <target state="translated">대화 형 선언은 &lt;code&gt;(interactive &lt;var&gt;code-string&lt;/var&gt;)&lt;/code&gt; 형식의 목록입니다 . 이것은 함수가 대화식으로 사용되는 경우 인수를 제공하는 방법을 선언합니다. 이 선언이있는 함수를 &lt;em&gt;명령&lt;/em&gt; 이라고 &lt;em&gt;합니다&lt;/em&gt; . 그들은 사용하여 호출 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="ae08d2dbfcabdf279e14b8cbd62c32467dc9f2d0" translate="yes" xml:space="preserve">
          <source>The interactive spec (if any). This can be a string or a Lisp expression. It is &lt;code&gt;nil&lt;/code&gt; for a function that isn&amp;rsquo;t interactive.</source>
          <target state="translated">대화 형 사양 (있는 경우). 이것은 문자열 또는 Lisp 표현식 일 수 있습니다. 그것은이다 &lt;code&gt;nil&lt;/code&gt; 상호 작용하지 않는 기능.</target>
        </trans-unit>
        <trans-unit id="2978362f714e301a7d1292d0bf49abf86d8926e4" translate="yes" xml:space="preserve">
          <source>The internal border is a border drawn by Emacs around the inner frame (see below). Its width is specified by the &lt;code&gt;internal-border-width&lt;/code&gt; frame parameter (see &lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;Layout Parameters&lt;/a&gt;). Its color is specified by the background of the &lt;code&gt;internal-border&lt;/code&gt; face.</source>
          <target state="translated">내부 테두리는 내부 프레임 주위에 Emacs가 그린 테두리입니다 (아래 참조). 너비는 &lt;code&gt;internal-border-width&lt;/code&gt; 프레임 매개 변수에 의해 지정됩니다 ( &lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;레이아웃 매개 변수&lt;/a&gt; 참조 ). 색상은 &lt;code&gt;internal-border&lt;/code&gt; 의 배경으로 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="a6cb4b170f13ea9783523a2b390523918e77d98d" translate="yes" xml:space="preserve">
          <source>The interval tree which records the text properties of this buffer.</source>
          <target state="translated">이 버퍼의 텍스트 속성을 기록하는 간격 트리입니다.</target>
        </trans-unit>
        <trans-unit id="2b193cdd686eaf4559317677f35332fe025a0bac" translate="yes" xml:space="preserve">
          <source>The job of &lt;code&gt;make-temp-file&lt;/code&gt; is to prevent two different users or two different jobs from trying to use the exact same file name.</source>
          <target state="translated">&lt;code&gt;make-temp-file&lt;/code&gt; 의 작업은 두 명의 다른 사용자 또는 두 명의 다른 작업이 정확히 동일한 파일 이름을 사용하지 못하도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7d566fc76f2e6f4607003117618cbc1ab1b17dde" translate="yes" xml:space="preserve">
          <source>The key bindings are not commands, just symbols that are meaningful to the functions that use this map.</source>
          <target state="translated">키 바인딩은 명령이 아니라이 맵을 사용하는 기능에 의미있는 기호 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="9bf1df2bbd01f543a3f0da8d68e7df8f3b5f2761" translate="yes" xml:space="preserve">
          <source>The key definition and lookup functions accept an alternate syntax for event types in a key sequence that is a vector: you can use a list containing modifier names plus one base event (a character or function key name). For example, &lt;code&gt;(control ?a)&lt;/code&gt; is equivalent to &lt;code&gt;?\C-a&lt;/code&gt; and &lt;code&gt;(hyper control left)&lt;/code&gt; is equivalent to &lt;code&gt;C-H-left&lt;/code&gt;. One advantage of such lists is that the precise numeric codes for the modifier bits don&amp;rsquo;t appear in compiled files.</source>
          <target state="translated">키 정의 및 검색 기능은 벡터 인 키 시퀀스의 이벤트 유형에 대한 대체 구문을 허용합니다. 수정 자 이름과 하나의 기본 이벤트 (문자 또는 기능 키 이름)를 포함하는 목록을 사용할 수 있습니다. 예를 들어, &lt;code&gt;(control ?a)&lt;/code&gt; 는 &lt;code&gt;?\C-a&lt;/code&gt; 와 같고 &lt;code&gt;(hyper control left)&lt;/code&gt; 는 &lt;code&gt;C-H-left&lt;/code&gt; 와 같습니다 . 이러한 목록의 한 가지 장점은 수정 자 비트에 대한 정확한 숫자 코드가 컴파일 된 파일에 나타나지 않는다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="628ce08bf218a05f5cf92a428c7d664ca579e0cc" translate="yes" xml:space="preserve">
          <source>The key sequence is translated into a command through the currently active keymaps. See &lt;a href=&quot;key-lookup#Key-Lookup&quot;&gt;Key Lookup&lt;/a&gt;, for information on how this is done. The result should be a keyboard macro or an interactively callable function. If the key is</source>
          <target state="translated">키 시퀀스는 현재 활성 키맵을 통해 명령으로 변환됩니다. 이를 수행하는 방법에 대한 정보는 &lt;a href=&quot;key-lookup#Key-Lookup&quot;&gt;Key Lookup을&lt;/a&gt; 참조하십시오 . 결과는 키보드 매크로 또는 대화 형으로 호출 가능한 함수 여야합니다. 열쇠가</target>
        </trans-unit>
        <trans-unit id="569f93f6d66684562d4fe017a80dce902677f074" translate="yes" xml:space="preserve">
          <source>The key sequences bound in a major mode keymap should usually start with</source>
          <target state="translated">주 모드 키맵에 바인딩 된 키 시퀀스는 일반적으로 다음으로 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="7950f6c49354bf68f27de0ba9e4826c034b3d35d" translate="yes" xml:space="preserve">
          <source>The key translation function receives one argument, which is the prompt that was specified in &lt;code&gt;read-key-sequence&lt;/code&gt;&amp;mdash;or &lt;code&gt;nil&lt;/code&gt; if the key sequence is being read by the editor command loop. In most cases you can ignore the prompt value.</source>
          <target state="translated">키 변환 함수는 &lt;code&gt;read-key-sequence&lt;/code&gt; 에 지정된 프롬프트 인 하나의 인수를받습니다. 또는 편집기 명령 루프에서 키 시퀀스를 읽는 경우 &lt;code&gt;nil&lt;/code&gt; 입니다. 대부분의 경우 프롬프트 값을 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c724c94075d725787e5d581c532371826e09281" translate="yes" xml:space="preserve">
          <source>The keymap &lt;var&gt;keymap&lt;/var&gt; is active whenever &lt;var&gt;variable&lt;/var&gt; has a non-&lt;code&gt;nil&lt;/code&gt; value. Typically &lt;var&gt;variable&lt;/var&gt; is the variable that enables or disables a minor mode. See &lt;a href=&quot;keymaps-and-minor-modes#Keymaps-and-Minor-Modes&quot;&gt;Keymaps and Minor Modes&lt;/a&gt;.</source>
          <target state="translated">키맵 &lt;var&gt;keymap&lt;/var&gt; 은 &lt;var&gt;variable&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 값을 가질 때마다 활성화 됩니다. 일반적으로 &lt;var&gt;variable&lt;/var&gt; 는 부 모드를 활성화하거나 비활성화하는 변수입니다. &lt;a href=&quot;keymaps-and-minor-modes#Keymaps-and-Minor-Modes&quot;&gt;키맵 및 부 모드를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="778deedcebfd753f594652405f80825572066516" translate="yes" xml:space="preserve">
          <source>The keymap binding of a prefix key is used for looking up the event that follows the prefix key. (It may instead be a symbol whose function definition is a keymap. The effect is the same, but the symbol serves as a name for the prefix key.) Thus, the binding of</source>
          <target state="translated">접두사 키의 키맵 바인딩은 접두사 키 다음에 오는 이벤트를 찾는 데 사용됩니다. (대신 기능 정의가 키맵 인 심볼 일 수 있습니다. 효과는 동일하지만 심볼은 접두사 키의 이름 역할을합니다.) 따라서 바인딩은</target>
        </trans-unit>
        <trans-unit id="fd6135585180a24face202b71c46d7d4e0321d54" translate="yes" xml:space="preserve">
          <source>The keymap defining the contents of the tab bar. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Tab-Bars.html#Tab-Bars&quot;&gt;Tab Bars&lt;/a&gt; in</source>
          <target state="translated">탭 표시 줄의 내용을 정의하는 키맵입니다. 참조 &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Tab-Bars.html#Tab-Bars&quot;&gt;탭 바&lt;/a&gt; 에서</target>
        </trans-unit>
        <trans-unit id="dbdf9f5934eb2533828d5b82e95608cabd6b6788" translate="yes" xml:space="preserve">
          <source>The keymap defining the contents of the tool bar. See &lt;a href=&quot;tool-bar#Tool-Bar&quot;&gt;Tool Bar&lt;/a&gt;.</source>
          <target state="translated">도구 모음의 내용을 정의하는 키맵입니다. &lt;a href=&quot;tool-bar#Tool-Bar&quot;&gt;도구 모음을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4e0069d3ae618f793f1fa2e4550594c9b75d2f72" translate="yes" xml:space="preserve">
          <source>The keymap for characters following</source>
          <target state="translated">다음 문자의 키맵</target>
        </trans-unit>
        <trans-unit id="c3be0c367d559d4bcc94776ddab26cb11131700e" translate="yes" xml:space="preserve">
          <source>The keymap for translating key sequences to preferred alternatives. If there are none, then it contains an empty sparse keymap. See &lt;a href=&quot;translation-keymaps#Translation-Keymaps&quot;&gt;Translation Keymaps&lt;/a&gt;.</source>
          <target state="translated">키 시퀀스를 선호하는 대안으로 변환하기위한 키맵입니다. 아무것도 없으면 빈 스파 스 키맵을 포함합니다. &lt;a href=&quot;translation-keymaps#Translation-Keymaps&quot;&gt;번역 키맵을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="13b5ef05286cb723bbea46afe3ee9fb02d42a48b" translate="yes" xml:space="preserve">
          <source>The keymap for translating keypad and function keys. If there are none, then it contains an empty sparse keymap. See &lt;a href=&quot;translation-keymaps#Translation-Keymaps&quot;&gt;Translation Keymaps&lt;/a&gt;.</source>
          <target state="translated">키패드 및 기능 키를 번역하기위한 키맵입니다. 아무것도 없으면 빈 스파 스 키맵을 포함합니다. &lt;a href=&quot;translation-keymaps#Translation-Keymaps&quot;&gt;번역 키맵을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9e7dbb9716bd01a43838b53fe70be9a55bda1567" translate="yes" xml:space="preserve">
          <source>The keymap used by Prog mode. See &lt;a href=&quot;basic-major-modes#Basic-Major-Modes&quot;&gt;Basic Major Modes&lt;/a&gt;.</source>
          <target state="translated">Prog 모드에서 사용하는 키맵입니다. &lt;a href=&quot;basic-major-modes#Basic-Major-Modes&quot;&gt;기본 주 모드를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2ab245ddfa519516f3703f74bf4d4e8acfbe8994" translate="yes" xml:space="preserve">
          <source>The keymap used by Special mode. See &lt;a href=&quot;basic-major-modes#Basic-Major-Modes&quot;&gt;Basic Major Modes&lt;/a&gt;.</source>
          <target state="translated">특수 모드에서 사용하는 키맵입니다. &lt;a href=&quot;basic-major-modes#Basic-Major-Modes&quot;&gt;기본 주 모드를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9e1ee3684d67359a88650e4fd1514d3bc1388140" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;&amp;amp;rest&lt;/code&gt; (which must be followed by a single argument name) indicates that any number of arguments can follow. The single argument name following &lt;code&gt;&amp;amp;rest&lt;/code&gt; receives, as its value, a list of all the remaining arguments passed to the function. Do not write &lt;code&gt;&amp;amp;rest&lt;/code&gt; when you call the function.</source>
          <target state="translated">The keyword &lt;code&gt;&amp;amp;rest&lt;/code&gt; (which must be followed by a single argument name) indicates that any number of arguments can follow. The single argument name following &lt;code&gt;&amp;amp;rest&lt;/code&gt; receives, as its value, a list of all the remaining arguments passed to the function. Do not write &lt;code&gt;&amp;amp;rest&lt;/code&gt; when you call the function.</target>
        </trans-unit>
        <trans-unit id="b3a2577e25ef4336cea54dd5ba9525c1ac899432" translate="yes" xml:space="preserve">
          <source>The kill ring records killed text as strings in a list, most recent first. A short kill ring, for example, might look like this:</source>
          <target state="translated">The kill ring records killed text as strings in a list, most recent first. A short kill ring, for example, might look like this:</target>
        </trans-unit>
        <trans-unit id="5310f9fc7ac635f8fb0f1f88e49865f96859f4ff" translate="yes" xml:space="preserve">
          <source>The kind of background&amp;mdash;either &lt;code&gt;light&lt;/code&gt; or &lt;code&gt;dark&lt;/code&gt;.</source>
          <target state="translated">The kind of background&amp;mdash;either &lt;code&gt;light&lt;/code&gt; or &lt;code&gt;dark&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bde2896c92556891a9a522e437678bf44d775c73" translate="yes" xml:space="preserve">
          <source>The kind of display associated with the terminal. This is the symbol returned by the function &lt;code&gt;terminal-live-p&lt;/code&gt; (i.e., &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;t&lt;/code&gt;, &lt;code&gt;w32&lt;/code&gt;, &lt;code&gt;ns&lt;/code&gt;, or &lt;code&gt;pc&lt;/code&gt;). See &lt;a href=&quot;frames#Frames&quot;&gt;Frames&lt;/a&gt;.</source>
          <target state="translated">The kind of display associated with the terminal. This is the symbol returned by the function &lt;code&gt;terminal-live-p&lt;/code&gt; (i.e., &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;t&lt;/code&gt; , &lt;code&gt;w32&lt;/code&gt; , &lt;code&gt;ns&lt;/code&gt; , or &lt;code&gt;pc&lt;/code&gt; ). See &lt;a href=&quot;frames#Frames&quot;&gt;Frames&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="c5c7577d4b10f36a18bbab67549b2c58143927c6" translate="yes" xml:space="preserve">
          <source>The kind of window system the terminal uses&amp;mdash;either &lt;code&gt;graphic&lt;/code&gt; (any graphics-capable display), &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;pc&lt;/code&gt; (for the MS-DOS console), &lt;code&gt;w32&lt;/code&gt; (for MS Windows 9X/NT/2K/XP), or &lt;code&gt;tty&lt;/code&gt; (a non-graphics-capable display). See &lt;a href=&quot;window-systems#Window-Systems&quot;&gt;window-system&lt;/a&gt;.</source>
          <target state="translated">The kind of window system the terminal uses&amp;mdash;either &lt;code&gt;graphic&lt;/code&gt; (any graphics-capable display), &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;pc&lt;/code&gt; (for the MS-DOS console), &lt;code&gt;w32&lt;/code&gt; (for MS Windows 9X/NT/2K/XP), or &lt;code&gt;tty&lt;/code&gt; (a non-graphics-capable display). See &lt;a href=&quot;window-systems#Window-Systems&quot;&gt;window-system&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="01ef18971dfd086d0f3bdf7cf4fbd00a90436fd8" translate="yes" xml:space="preserve">
          <source>The language that the font should support. The value should be a symbol whose name is a two-letter ISO-639 language name. On X, the value is matched against the &amp;ldquo;Additional Style&amp;rdquo; field of the XLFD name of a font, if it is non-empty. On MS-Windows, fonts matching the spec are required to support codepages needed for the language. Currently, only a small set of CJK languages is supported with this property: &amp;lsquo;</source>
          <target state="translated">The language that the font should support. The value should be a symbol whose name is a two-letter ISO-639 language name. On X, the value is matched against the &amp;ldquo;Additional Style&amp;rdquo; field of the XLFD name of a font, if it is non-empty. On MS-Windows, fonts matching the spec are required to support codepages needed for the language. Currently, only a small set of CJK languages is supported with this property: &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="88a7e776b65a937667815eb3a6eaf67a01ff78ce" translate="yes" xml:space="preserve">
          <source>The last</source>
          <target state="translated">The last</target>
        </trans-unit>
        <trans-unit id="dccd686ce06e60750b4337124ef02d3ac122a8dc" translate="yes" xml:space="preserve">
          <source>The last form also makes sure that none of the created side windows are accessible via</source>
          <target state="translated">The last form also makes sure that none of the created side windows are accessible via</target>
        </trans-unit>
        <trans-unit id="37be7c944a107a298305238e57bd913b69f97266" translate="yes" xml:space="preserve">
          <source>The last line of the documentation string can specify calling conventions different from the actual function arguments. Write text like this:</source>
          <target state="translated">The last line of the documentation string can specify calling conventions different from the actual function arguments. Write text like this:</target>
        </trans-unit>
        <trans-unit id="ddcb40b64096f3eaa561946b2a19e292247e85b0" translate="yes" xml:space="preserve">
          <source>The last optional item, &lt;var&gt;noerror&lt;/var&gt;, overrides the normal error when the text can&amp;rsquo;t be encoded using the specified or chosen coding system. When &lt;var&gt;noerror&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, this function silently uses &lt;code&gt;raw-text&lt;/code&gt; coding instead.</source>
          <target state="translated">The last optional item, &lt;var&gt;noerror&lt;/var&gt; , overrides the normal error when the text can&amp;rsquo;t be encoded using the specified or chosen coding system. When &lt;var&gt;noerror&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , this function silently uses &lt;code&gt;raw-text&lt;/code&gt; coding instead.</target>
        </trans-unit>
        <trans-unit id="ab880934452e3eacbf10a61506631f3e7e86eb71" translate="yes" xml:space="preserve">
          <source>The last thing &lt;code&gt;after-find-file&lt;/code&gt; does is call all the functions in the list &lt;code&gt;find-file-hook&lt;/code&gt;.</source>
          <target state="translated">The last thing &lt;code&gt;after-find-file&lt;/code&gt; does is call all the functions in the list &lt;code&gt;find-file-hook&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0003f3c71cb33be508071e1a28e112d5cd1a93de" translate="yes" xml:space="preserve">
          <source>The last three elements give additional information about the font. &lt;var&gt;fixed-p&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt; if the font is fixed-pitch. &lt;var&gt;full&lt;/var&gt; is the full name of the font, and &lt;var&gt;registry-and-encoding&lt;/var&gt; is a string giving the registry and encoding of the font.</source>
          <target state="translated">The last three elements give additional information about the font. &lt;var&gt;fixed-p&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; if the font is fixed-pitch. &lt;var&gt;full&lt;/var&gt; is the full name of the font, and &lt;var&gt;registry-and-encoding&lt;/var&gt; is a string giving the registry and encoding of the font.</target>
        </trans-unit>
        <trans-unit id="6c23485a20be9be1024893537c3477b18df28155" translate="yes" xml:space="preserve">
          <source>The last two values in &lt;var&gt;subexp-highlighter&lt;/var&gt;, &lt;var&gt;override&lt;/var&gt; and &lt;var&gt;laxmatch&lt;/var&gt;, are optional flags. If &lt;var&gt;override&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;, this element can override existing fontification made by previous elements of &lt;code&gt;font-lock-keywords&lt;/code&gt;. If it is &lt;code&gt;keep&lt;/code&gt;, then each character is fontified if it has not been fontified already by some other element. If it is &lt;code&gt;prepend&lt;/code&gt;, the face specified by &lt;var&gt;facespec&lt;/var&gt; is added to the beginning of the &lt;code&gt;font-lock-face&lt;/code&gt; property. If it is &lt;code&gt;append&lt;/code&gt;, the face is added to the end of the &lt;code&gt;font-lock-face&lt;/code&gt; property.</source>
          <target state="translated">The last two values in &lt;var&gt;subexp-highlighter&lt;/var&gt; , &lt;var&gt;override&lt;/var&gt; and &lt;var&gt;laxmatch&lt;/var&gt; , are optional flags. If &lt;var&gt;override&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt; , this element can override existing fontification made by previous elements of &lt;code&gt;font-lock-keywords&lt;/code&gt; . If it is &lt;code&gt;keep&lt;/code&gt; , then each character is fontified if it has not been fontified already by some other element. If it is &lt;code&gt;prepend&lt;/code&gt; , the face specified by &lt;var&gt;facespec&lt;/var&gt; is added to the beginning of the &lt;code&gt;font-lock-face&lt;/code&gt; property. If it is &lt;code&gt;append&lt;/code&gt; , the face is added to the end of the &lt;code&gt;font-lock-face&lt;/code&gt; property.</target>
        </trans-unit>
        <trans-unit id="992a1c51c72e3b37e35b641195dd8337943b2596" translate="yes" xml:space="preserve">
          <source>The last way to customize Imenu for a major mode is to set the variable &lt;code&gt;imenu-create-index-function&lt;/code&gt;:</source>
          <target state="translated">The last way to customize Imenu for a major mode is to set the variable &lt;code&gt;imenu-create-index-function&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3ce25b448ce366df7fb622e8f8aa9485fb8699a5" translate="yes" xml:space="preserve">
          <source>The layer 2 address (Ethernet MAC address, for instance).</source>
          <target state="translated">The layer 2 address (Ethernet MAC address, for instance).</target>
        </trans-unit>
        <trans-unit id="a47ca85c8b203a3f800aea8cd96b6a61549d375d" translate="yes" xml:space="preserve">
          <source>The layout of side windows on the left or right of a frame is not affected by the value of this variable.</source>
          <target state="translated">The layout of side windows on the left or right of a frame is not affected by the value of this variable.</target>
        </trans-unit>
        <trans-unit id="6009ec89412305c052749a52bf8f3c7e8431cbcf" translate="yes" xml:space="preserve">
          <source>The layout of such a frame might appear as follows:</source>
          <target state="translated">The layout of such a frame might appear as follows:</target>
        </trans-unit>
        <trans-unit id="3b025a85b17d93fe80056a9fbbc6aa0c12299f7e" translate="yes" xml:space="preserve">
          <source>The least specialized major mode is called &lt;em&gt;Fundamental mode&lt;/em&gt;, which has no mode-specific definitions or variable settings.</source>
          <target state="translated">The least specialized major mode is called &lt;em&gt;Fundamental mode&lt;/em&gt;, which has no mode-specific definitions or variable settings.</target>
        </trans-unit>
        <trans-unit id="cf0a2de49bf1a621f861fc10249ddf1c3e8e8639" translate="yes" xml:space="preserve">
          <source>The left-hand and top edges of this window, measured in pixels, relative to the top-left corner (0, 0) of the window&amp;rsquo;s native frame.</source>
          <target state="translated">The left-hand and top edges of this window, measured in pixels, relative to the top-left corner (0, 0) of the window&amp;rsquo;s native frame.</target>
        </trans-unit>
        <trans-unit id="0e159da910fc18db25e6c0af5e99bdff417543a4" translate="yes" xml:space="preserve">
          <source>The left-hand edge of the window, measured in columns, relative to the leftmost column (column 0) of the window&amp;rsquo;s native frame.</source>
          <target state="translated">The left-hand edge of the window, measured in columns, relative to the leftmost column (column 0) of the window&amp;rsquo;s native frame.</target>
        </trans-unit>
        <trans-unit id="85b6183109a9a7b6efad378049191669aefc0fd8" translate="yes" xml:space="preserve">
          <source>The length of the array is fixed once you create it; you cannot change the length of an existing array.</source>
          <target state="translated">The length of the array is fixed once you create it; you cannot change the length of an existing array.</target>
        </trans-unit>
        <trans-unit id="bb9a27d08446955ce106744ef3b710dbc15d43b6" translate="yes" xml:space="preserve">
          <source>The length of the file this buffer is visiting, when last read or saved. It can have 2 special values: -1 means auto-saving was turned off in this buffer, and -2 means don&amp;rsquo;t turn off auto-saving if buffer text shrinks a lot. This and other fields concerned with saving are not kept in the &lt;code&gt;buffer_text&lt;/code&gt; structure because indirect buffers are never saved.</source>
          <target state="translated">The length of the file this buffer is visiting, when last read or saved. It can have 2 special values: -1 means auto-saving was turned off in this buffer, and -2 means don&amp;rsquo;t turn off auto-saving if buffer text shrinks a lot. This and other fields concerned with saving are not kept in the &lt;code&gt;buffer_text&lt;/code&gt; structure because indirect buffers are never saved.</target>
        </trans-unit>
        <trans-unit id="2735538fcce561a7758f21b1ebbd03c667ab66da" translate="yes" xml:space="preserve">
          <source>The length of the old text is the difference between the buffer positions before and after that text as it was before the change. As for the changed text, its length is simply the difference between the first two arguments.</source>
          <target state="translated">The length of the old text is the difference between the buffer positions before and after that text as it was before the change. As for the changed text, its length is simply the difference between the first two arguments.</target>
        </trans-unit>
        <trans-unit id="959fbf29c3f8bb0bab090fdff0de9a589ee90bcb" translate="yes" xml:space="preserve">
          <source>The license for this documentation.</source>
          <target state="translated">The license for this documentation.</target>
        </trans-unit>
        <trans-unit id="620613354f3eaf838b72f4f12e00f9803d440b0f" translate="yes" xml:space="preserve">
          <source>The line functions in the previous section count text lines, delimited only by newline characters. By contrast, these functions count screen lines, which are defined by the way the text appears on the screen. A text line is a single screen line if it is short enough to fit the width of the selected window, but otherwise it may occupy several screen lines.</source>
          <target state="translated">The line functions in the previous section count text lines, delimited only by newline characters. By contrast, these functions count screen lines, which are defined by the way the text appears on the screen. A text line is a single screen line if it is short enough to fit the width of the selected window, but otherwise it may occupy several screen lines.</target>
        </trans-unit>
        <trans-unit id="716452ebec7e673d1d9d81cc51b8547f340814e1" translate="yes" xml:space="preserve">
          <source>The line number of a certain position in the buffer, or zero. This is used for displaying the line number of point in the mode line.</source>
          <target state="translated">The line number of a certain position in the buffer, or zero. This is used for displaying the line number of point in the mode line.</target>
        </trans-unit>
        <trans-unit id="839f8d216431863a7a00ea59f4be71c60c8c2e5b" translate="yes" xml:space="preserve">
          <source>The list &lt;code&gt;(rose violet)&lt;/code&gt; is equivalent to &lt;code&gt;(rose . (violet))&lt;/code&gt;, and looks like this:</source>
          <target state="translated">The list &lt;code&gt;(rose violet)&lt;/code&gt; is equivalent to &lt;code&gt;(rose . (violet))&lt;/code&gt; , and looks like this:</target>
        </trans-unit>
        <trans-unit id="962c62424fbca05b4167123b8512730f70e28cc4" translate="yes" xml:space="preserve">
          <source>The list describes the display that &lt;var&gt;frame&lt;/var&gt; is on; if &lt;var&gt;frame&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt;, it applies to the selected frame&amp;rsquo;s display (see &lt;a href=&quot;input-focus#Input-Focus&quot;&gt;Input Focus&lt;/a&gt;).</source>
          <target state="translated">The list describes the display that &lt;var&gt;frame&lt;/var&gt; is on; if &lt;var&gt;frame&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt; , it applies to the selected frame&amp;rsquo;s display (see &lt;a href=&quot;input-focus#Input-Focus&quot;&gt;Input Focus&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="a5e7dd03ee241b78dea866b6e88f99a7a8764678" translate="yes" xml:space="preserve">
          <source>The list form is currently similar to how &lt;code&gt;md5&lt;/code&gt; and &lt;code&gt;secure-hash&lt;/code&gt; operate.</source>
          <target state="translated">The list form is currently similar to how &lt;code&gt;md5&lt;/code&gt; and &lt;code&gt;secure-hash&lt;/code&gt; operate.</target>
        </trans-unit>
        <trans-unit id="f1ee49ad7464cab64ae226a805d7b31a9c327b50" translate="yes" xml:space="preserve">
          <source>The list is ordered so that earlier elements correspond to more recently-shown buffers, and the first element usually corresponds to the buffer most recently removed from the window.</source>
          <target state="translated">The list is ordered so that earlier elements correspond to more recently-shown buffers, and the first element usually corresponds to the buffer most recently removed from the window.</target>
        </trans-unit>
        <trans-unit id="bf28d6cd5c13b4c859c3624b6a63099b610df792" translate="yes" xml:space="preserve">
          <source>The list of the positions of the currently open parentheses, starting with the outermost.</source>
          <target state="translated">The list of the positions of the currently open parentheses, starting with the outermost.</target>
        </trans-unit>
        <trans-unit id="42d7eea344ddd2896a97642d094a7e8335564359" translate="yes" xml:space="preserve">
          <source>The list returned by &lt;code&gt;buffer-list&lt;/code&gt; is constructed specifically; it is not an internal Emacs data structure, and modifying it has no effect on the order of buffers. If you want to change the order of buffers in the fundamental buffer list, here is an easy way:</source>
          <target state="translated">The list returned by &lt;code&gt;buffer-list&lt;/code&gt; is constructed specifically; it is not an internal Emacs data structure, and modifying it has no effect on the order of buffers. If you want to change the order of buffers in the fundamental buffer list, here is an easy way:</target>
        </trans-unit>
        <trans-unit id="a8c850e06ee228bef706e71be70435aebad07c66" translate="yes" xml:space="preserve">
          <source>The load functions evaluate all the expressions in a file just as the &lt;code&gt;eval-buffer&lt;/code&gt; function evaluates all the expressions in a buffer. The difference is that the load functions read and evaluate the text in the file as found on disk, not the text in an Emacs buffer.</source>
          <target state="translated">The load functions evaluate all the expressions in a file just as the &lt;code&gt;eval-buffer&lt;/code&gt; function evaluates all the expressions in a buffer. The difference is that the load functions read and evaluate the text in the file as found on disk, not the text in an Emacs buffer.</target>
        </trans-unit>
        <trans-unit id="bcf097db69a4c3e2b9f156a93318f5b55b88be14" translate="yes" xml:space="preserve">
          <source>The loaded file must contain Lisp expressions, either as source code or as byte-compiled code. Each form in the file is called a &lt;em&gt;top-level form&lt;/em&gt;. There is no special format for the forms in a loadable file; any form in a file may equally well be typed directly into a buffer and evaluated there. (Indeed, most code is tested this way.) Most often, the forms are function definitions and variable definitions.</source>
          <target state="translated">The loaded file must contain Lisp expressions, either as source code or as byte-compiled code. Each form in the file is called a &lt;em&gt;top-level form&lt;/em&gt;. There is no special format for the forms in a loadable file; any form in a file may equally well be typed directly into a buffer and evaluated there. (Indeed, most code is tested this way.) Most often, the forms are function definitions and variable definitions.</target>
        </trans-unit>
        <trans-unit id="95d55d2fde6c278fb97386c98daf3e630c566eab" translate="yes" xml:space="preserve">
          <source>The local address, in internal format.</source>
          <target state="translated">The local address, in internal format.</target>
        </trans-unit>
        <trans-unit id="56aaea215b4bc49234f9ee74677196b8ffb7af78" translate="yes" xml:space="preserve">
          <source>The local keymap and variable list contain entries that individually override global bindings or values. These are used to customize the behavior of programs in different buffers, without actually changing the programs.</source>
          <target state="translated">The local keymap and variable list contain entries that individually override global bindings or values. These are used to customize the behavior of programs in different buffers, without actually changing the programs.</target>
        </trans-unit>
        <trans-unit id="8497e1e143889552fd6d29f50ee9c1a86ceb2d17" translate="yes" xml:space="preserve">
          <source>The local keymap is normally set by the buffer&amp;rsquo;s major mode, and every buffer with the same major mode shares the same local keymap. Hence, if you call &lt;code&gt;local-set-key&lt;/code&gt; (see &lt;a href=&quot;key-binding-commands#Key-Binding-Commands&quot;&gt;Key Binding Commands&lt;/a&gt;) to change the local keymap in one buffer, that also affects the local keymaps in other buffers with the same major mode.</source>
          <target state="translated">The local keymap is normally set by the buffer&amp;rsquo;s major mode, and every buffer with the same major mode shares the same local keymap. Hence, if you call &lt;code&gt;local-set-key&lt;/code&gt; (see &lt;a href=&quot;key-binding-commands#Key-Binding-Commands&quot;&gt;Key Binding Commands&lt;/a&gt;) to change the local keymap in one buffer, that also affects the local keymaps in other buffers with the same major mode.</target>
        </trans-unit>
        <trans-unit id="c20827cfc5ffe09c075650e5199361a56b68cec0" translate="yes" xml:space="preserve">
          <source>The low-level mechanism for disabling a command is to put a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;disabled&lt;/code&gt; property on the Lisp symbol for the command. These properties are normally set up by the user&amp;rsquo;s init file (see &lt;a href=&quot;init-file#Init-File&quot;&gt;Init File&lt;/a&gt;) with Lisp expressions such as this:</source>
          <target state="translated">The low-level mechanism for disabling a command is to put a non- &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;disabled&lt;/code&gt; property on the Lisp symbol for the command. These properties are normally set up by the user&amp;rsquo;s init file (see &lt;a href=&quot;init-file#Init-File&quot;&gt;Init File&lt;/a&gt;) with Lisp expressions such as this:</target>
        </trans-unit>
        <trans-unit id="23fe2196399552d25b3c061985ee305fa84c2b18" translate="yes" xml:space="preserve">
          <source>The low-level primitives for creating buffers do not use this function, but medium-level commands such as &lt;code&gt;switch-to-buffer&lt;/code&gt; and &lt;code&gt;find-file-noselect&lt;/code&gt; use it whenever they create buffers.</source>
          <target state="translated">The low-level primitives for creating buffers do not use this function, but medium-level commands such as &lt;code&gt;switch-to-buffer&lt;/code&gt; and &lt;code&gt;find-file-noselect&lt;/code&gt; use it whenever they create buffers.</target>
        </trans-unit>
        <trans-unit id="8010635f2bb24a96123a821123a02c24a306bdce" translate="yes" xml:space="preserve">
          <source>The lowest level functions for command input are &lt;code&gt;read-event&lt;/code&gt;, &lt;code&gt;read-char&lt;/code&gt;, and &lt;code&gt;read-char-exclusive&lt;/code&gt;.</source>
          <target state="translated">The lowest level functions for command input are &lt;code&gt;read-event&lt;/code&gt; , &lt;code&gt;read-char&lt;/code&gt; , and &lt;code&gt;read-char-exclusive&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14145dceb516643fe37d9fc1ff0f68417500b0ec" translate="yes" xml:space="preserve">
          <source>The lowest-level primitive for modifying a &lt;small&gt;CDR&lt;/small&gt; is &lt;code&gt;setcdr&lt;/code&gt;:</source>
          <target state="translated">The lowest-level primitive for modifying a &lt;small&gt;CDR&lt;/small&gt; is &lt;code&gt;setcdr&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3f8ff2bd3febbb80e6a03979190f1d4a93f85b99" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;condition-case-unless-debug&lt;/code&gt; provides another way to handle debugging of such forms. It behaves exactly like &lt;code&gt;condition-case&lt;/code&gt;, unless the variable &lt;code&gt;debug-on-error&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;, in which case it does not handle any errors at all.</source>
          <target state="translated">The macro &lt;code&gt;condition-case-unless-debug&lt;/code&gt; provides another way to handle debugging of such forms. It behaves exactly like &lt;code&gt;condition-case&lt;/code&gt; , unless the variable &lt;code&gt;debug-on-error&lt;/code&gt; is non- &lt;code&gt;nil&lt;/code&gt; , in which case it does not handle any errors at all.</target>
        </trans-unit>
        <trans-unit id="69ddcd0a4bf2d4a7d5ed7f86f791b6ffe043c1a1" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;define-alternatives&lt;/code&gt; can be used to define &lt;em&gt;generic commands&lt;/em&gt;. These are interactive functions whose implementation can be selected from several alternatives, as a matter of user preference.</source>
          <target state="translated">The macro &lt;code&gt;define-alternatives&lt;/code&gt; can be used to define &lt;em&gt;generic commands&lt;/em&gt;. These are interactive functions whose implementation can be selected from several alternatives, as a matter of user preference.</target>
        </trans-unit>
        <trans-unit id="5119a1b3dc9bf2349246f3d4b6d6761f1510e515" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;define-minor-mode&lt;/code&gt; offers a convenient way of implementing a mode in one self-contained definition.</source>
          <target state="translated">The macro &lt;code&gt;define-minor-mode&lt;/code&gt; offers a convenient way of implementing a mode in one self-contained definition.</target>
        </trans-unit>
        <trans-unit id="a18ca22eed3764c8d5592c00e25721489dd6a12d" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;gv-letplace&lt;/code&gt; can be useful in defining macros that perform similarly to &lt;code&gt;setf&lt;/code&gt;; for example, the &lt;code&gt;incf&lt;/code&gt; macro of Common Lisp could be implemented this way:</source>
          <target state="translated">The macro &lt;code&gt;gv-letplace&lt;/code&gt; can be useful in defining macros that perform similarly to &lt;code&gt;setf&lt;/code&gt; ; for example, the &lt;code&gt;incf&lt;/code&gt; macro of Common Lisp could be implemented this way:</target>
        </trans-unit>
        <trans-unit id="1e1e3b145e098e8f5ecb2f49f1bfd35918691f45" translate="yes" xml:space="preserve">
          <source>The macro cannot be used to suppress file name handlers from magic file names (see &lt;a href=&quot;magic-file-names#Magic-File-Names&quot;&gt;Magic File Names&lt;/a&gt;).</source>
          <target state="translated">The macro cannot be used to suppress file name handlers from magic file names (see &lt;a href=&quot;magic-file-names#Magic-File-Names&quot;&gt;Magic File Names&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="8cf63348f1b08167a736e3e7aac8f62de5938951" translate="yes" xml:space="preserve">
          <source>The macro executes &lt;var&gt;body&lt;/var&gt; normally, but arranges to call the after-change functions just once for a series of several changes&amp;mdash;if that seems safe.</source>
          <target state="translated">The macro executes &lt;var&gt;body&lt;/var&gt; normally, but arranges to call the after-change functions just once for a series of several changes&amp;mdash;if that seems safe.</target>
        </trans-unit>
        <trans-unit id="eae48ac7e81744b77b10a9b79e04ee1eb49c6a47" translate="yes" xml:space="preserve">
          <source>The macros &lt;code&gt;push&lt;/code&gt; (see &lt;a href=&quot;list-variables#List-Variables&quot;&gt;List Variables&lt;/a&gt;) and &lt;code&gt;pop&lt;/code&gt; (see &lt;a href=&quot;list-elements#List-Elements&quot;&gt;List Elements&lt;/a&gt;) can manipulate generalized variables, not just lists. &lt;code&gt;(pop &lt;var&gt;place&lt;/var&gt;)&lt;/code&gt; removes and returns the first element of the list stored in &lt;var&gt;place&lt;/var&gt;. It is analogous to &lt;code&gt;(prog1 (car &lt;var&gt;place&lt;/var&gt;) (setf &lt;var&gt;place&lt;/var&gt; (cdr &lt;var&gt;place&lt;/var&gt;)))&lt;/code&gt;, except that it takes care to evaluate all subforms only once. &lt;code&gt;(push &lt;var&gt;x&lt;/var&gt; &lt;var&gt;place&lt;/var&gt;)&lt;/code&gt; inserts &lt;var&gt;x&lt;/var&gt; at the front of the list stored in &lt;var&gt;place&lt;/var&gt;. It is analogous to &lt;code&gt;(setf
&lt;var&gt;place&lt;/var&gt; (cons &lt;var&gt;x&lt;/var&gt; &lt;var&gt;place&lt;/var&gt;))&lt;/code&gt;, except for evaluation of the subforms. Note that &lt;code&gt;push&lt;/code&gt; and &lt;code&gt;pop&lt;/code&gt; on an &lt;code&gt;nthcdr&lt;/code&gt; place can be used to insert or delete at any position in a list.</source>
          <target state="translated">The macros &lt;code&gt;push&lt;/code&gt; (see &lt;a href=&quot;list-variables#List-Variables&quot;&gt;List Variables&lt;/a&gt;) and &lt;code&gt;pop&lt;/code&gt; (see &lt;a href=&quot;list-elements#List-Elements&quot;&gt;List Elements&lt;/a&gt;) can manipulate generalized variables, not just lists. &lt;code&gt;(pop &lt;var&gt;place&lt;/var&gt;)&lt;/code&gt; removes and returns the first element of the list stored in &lt;var&gt;place&lt;/var&gt; . It is analogous to &lt;code&gt;(prog1 (car &lt;var&gt;place&lt;/var&gt;) (setf &lt;var&gt;place&lt;/var&gt; (cdr &lt;var&gt;place&lt;/var&gt;)))&lt;/code&gt; , except that it takes care to evaluate all subforms only once. &lt;code&gt;(push &lt;var&gt;x&lt;/var&gt; &lt;var&gt;place&lt;/var&gt;)&lt;/code&gt; inserts &lt;var&gt;x&lt;/var&gt; at the front of the list stored in &lt;var&gt;place&lt;/var&gt; . It is analogous to &lt;code&gt;(setf &lt;var&gt;place&lt;/var&gt; (cons &lt;var&gt;x&lt;/var&gt; &lt;var&gt;place&lt;/var&gt;))&lt;/code&gt; , except for evaluation of the subforms. Note that &lt;code&gt;push&lt;/code&gt; and &lt;code&gt;pop&lt;/code&gt; on an &lt;code&gt;nthcdr&lt;/code&gt; place can be used to insert or delete at any position in a list.</target>
        </trans-unit>
        <trans-unit id="09c0ddd15714530f62c1af5eecb2c98c7086baee" translate="yes" xml:space="preserve">
          <source>The macros described in this section use &lt;code&gt;pcase&lt;/code&gt; patterns to perform destructuring binding. The condition of the object to be of compatible structure means that the object must match the pattern, because only then the object&amp;rsquo;s subfields can be extracted. For example:</source>
          <target state="translated">The macros described in this section use &lt;code&gt;pcase&lt;/code&gt; patterns to perform destructuring binding. The condition of the object to be of compatible structure means that the object must match the pattern, because only then the object&amp;rsquo;s subfields can be extracted. For example:</target>
        </trans-unit>
        <trans-unit id="f9f8d8ecb58d3451cb2b5457cb2f37a869983a68" translate="yes" xml:space="preserve">
          <source>The main reason for writing an Emacs module is to make additional functions available to Lisp programs that load the module. This subsection describes how to write such &lt;em&gt;module functions&lt;/em&gt;.</source>
          <target state="translated">The main reason for writing an Emacs module is to make additional functions available to Lisp programs that load the module. This subsection describes how to write such &lt;em&gt;module functions&lt;/em&gt;.</target>
        </trans-unit>
        <trans-unit id="877426dcb86887eef639d5e653cc17f51b41fa0e" translate="yes" xml:space="preserve">
          <source>The main use of &lt;code&gt;const&lt;/code&gt; is inside of &lt;code&gt;choice&lt;/code&gt;. For example, &lt;code&gt;(choice integer (const nil))&lt;/code&gt; allows either an integer or &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">The main use of &lt;code&gt;const&lt;/code&gt; is inside of &lt;code&gt;choice&lt;/code&gt; . For example, &lt;code&gt;(choice integer (const nil))&lt;/code&gt; allows either an integer or &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26e9b14420c609493efab668d934c559a0c3429e" translate="yes" xml:space="preserve">
          <source>The main use of &lt;code&gt;current-idle-time&lt;/code&gt; is when an idle timer function wants to &amp;ldquo;take a break&amp;rdquo; for a while. It can set up another idle timer to call the same function again, after a few seconds more idleness. Here&amp;rsquo;s an example:</source>
          <target state="translated">The main use of &lt;code&gt;current-idle-time&lt;/code&gt; is when an idle timer function wants to &amp;ldquo;take a break&amp;rdquo; for a while. It can set up another idle timer to call the same function again, after a few seconds more idleness. Here&amp;rsquo;s an example:</target>
        </trans-unit>
        <trans-unit id="530ebc1f037074c726faee61b32cae1039f33cbf" translate="yes" xml:space="preserve">
          <source>The main use of &lt;code&gt;other&lt;/code&gt; is as the last element of &lt;code&gt;choice&lt;/code&gt;. For example,</source>
          <target state="translated">The main use of &lt;code&gt;other&lt;/code&gt; is as the last element of &lt;code&gt;choice&lt;/code&gt; . For example,</target>
        </trans-unit>
        <trans-unit id="f26c01b277b5d5c1d3d508a4f0fb33a502c2a50b" translate="yes" xml:space="preserve">
          <source>The major mode command may start by calling some other major mode command (called the &lt;em&gt;parent mode&lt;/em&gt;) and then alter some of its settings. A mode that does this is called a &lt;em&gt;derived mode&lt;/em&gt;. The recommended way to define one is to use the &lt;code&gt;define-derived-mode&lt;/code&gt; macro, but this is not required. Such a mode should call the parent mode command inside a &lt;code&gt;delay-mode-hooks&lt;/code&gt; form. (Using &lt;code&gt;define-derived-mode&lt;/code&gt; does this automatically.) See &lt;a href=&quot;derived-modes#Derived-Modes&quot;&gt;Derived Modes&lt;/a&gt;, and &lt;a href=&quot;mode-hooks#Mode-Hooks&quot;&gt;Mode Hooks&lt;/a&gt;.</source>
          <target state="translated">The major mode command may start by calling some other major mode command (called the &lt;em&gt;parent mode&lt;/em&gt;) and then alter some of its settings. A mode that does this is called a &lt;em&gt;derived mode&lt;/em&gt;. The recommended way to define one is to use the &lt;code&gt;define-derived-mode&lt;/code&gt; macro, but this is not required. Such a mode should call the parent mode command inside a &lt;code&gt;delay-mode-hooks&lt;/code&gt; form. (Using &lt;code&gt;define-derived-mode&lt;/code&gt; does this automatically.) See &lt;a href=&quot;derived-modes#Derived-Modes&quot;&gt;Derived Modes&lt;/a&gt;, and &lt;a href=&quot;mode-hooks#Mode-Hooks&quot;&gt;Mode Hooks&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="5d17a35b712255a2afb0c14c8a0d624c5811e326" translate="yes" xml:space="preserve">
          <source>The major mode command should set the variable &lt;code&gt;major-mode&lt;/code&gt; to the major mode command symbol. This is how &lt;code&gt;describe-mode&lt;/code&gt; discovers which documentation to print.</source>
          <target state="translated">The major mode command should set the variable &lt;code&gt;major-mode&lt;/code&gt; to the major mode command symbol. This is how &lt;code&gt;describe-mode&lt;/code&gt; discovers which documentation to print.</target>
        </trans-unit>
        <trans-unit id="cc2e4f72d7acbc5634e4c8fb360f612e207aadac" translate="yes" xml:space="preserve">
          <source>The major mode command should set the variable &lt;code&gt;mode-name&lt;/code&gt; to the &amp;ldquo;pretty&amp;rdquo; name of the mode, usually a string (but see &lt;a href=&quot;mode-line-data#Mode-Line-Data&quot;&gt;Mode Line Data&lt;/a&gt;, for other possible forms). The name of the mode appears in the mode line.</source>
          <target state="translated">The major mode command should set the variable &lt;code&gt;mode-name&lt;/code&gt; to the &amp;ldquo;pretty&amp;rdquo; name of the mode, usually a string (but see &lt;a href=&quot;mode-line-data#Mode-Line-Data&quot;&gt;Mode Line Data&lt;/a&gt;, for other possible forms). The name of the mode appears in the mode line.</target>
        </trans-unit>
        <trans-unit id="e9542e90f40b187eea4684e0c6016160f19daa55" translate="yes" xml:space="preserve">
          <source>The major mode command should start by calling &lt;code&gt;kill-all-local-variables&lt;/code&gt;. This runs the normal hook &lt;code&gt;change-major-mode-hook&lt;/code&gt;, then gets rid of the buffer-local variables of the major mode previously in effect. See &lt;a href=&quot;creating-buffer_002dlocal#Creating-Buffer_002dLocal&quot;&gt;Creating Buffer-Local&lt;/a&gt;.</source>
          <target state="translated">The major mode command should start by calling &lt;code&gt;kill-all-local-variables&lt;/code&gt; . This runs the normal hook &lt;code&gt;change-major-mode-hook&lt;/code&gt; , then gets rid of the buffer-local variables of the major mode previously in effect. See &lt;a href=&quot;creating-buffer_002dlocal#Creating-Buffer_002dLocal&quot;&gt;Creating Buffer-Local&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="d4edcb1b916452f2aa05fab479bef5803ee546f7" translate="yes" xml:space="preserve">
          <source>The major mode for a newly created buffer is set to Fundamental mode. (The default value of the variable &lt;code&gt;major-mode&lt;/code&gt; is handled at a higher level; see &lt;a href=&quot;auto-major-mode#Auto-Major-Mode&quot;&gt;Auto Major Mode&lt;/a&gt;.) If the name begins with a space, the buffer initially disables undo information recording (see &lt;a href=&quot;undo#Undo&quot;&gt;Undo&lt;/a&gt;).</source>
          <target state="translated">The major mode for a newly created buffer is set to Fundamental mode. (The default value of the variable &lt;code&gt;major-mode&lt;/code&gt; is handled at a higher level; see &lt;a href=&quot;auto-major-mode#Auto-Major-Mode&quot;&gt;Auto Major Mode&lt;/a&gt;.) If the name begins with a space, the buffer initially disables undo information recording (see &lt;a href=&quot;undo#Undo&quot;&gt;Undo&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="ba726196ac6572a0dc3557cdc5106eff7f9d6ee0" translate="yes" xml:space="preserve">
          <source>The major mode for the new buffer is set to Fundamental mode. The default value of the variable &lt;code&gt;major-mode&lt;/code&gt; is handled at a higher level. See &lt;a href=&quot;auto-major-mode#Auto-Major-Mode&quot;&gt;Auto Major Mode&lt;/a&gt;.</source>
          <target state="translated">The major mode for the new buffer is set to Fundamental mode. The default value of the variable &lt;code&gt;major-mode&lt;/code&gt; is handled at a higher level. See &lt;a href=&quot;auto-major-mode#Auto-Major-Mode&quot;&gt;Auto Major Mode&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="87268c52362ac57b90f14c23d4e6a6de48b2d02a" translate="yes" xml:space="preserve">
          <source>The major mode should usually have its own keymap, which is used as the local keymap in all buffers in that mode. The major mode command should call &lt;code&gt;use-local-map&lt;/code&gt; to install this local map. See &lt;a href=&quot;active-keymaps#Active-Keymaps&quot;&gt;Active Keymaps&lt;/a&gt;, for more information.</source>
          <target state="translated">The major mode should usually have its own keymap, which is used as the local keymap in all buffers in that mode. The major mode command should call &lt;code&gt;use-local-map&lt;/code&gt; to install this local map. See &lt;a href=&quot;active-keymaps#Active-Keymaps&quot;&gt;Active Keymaps&lt;/a&gt;, for more information.</target>
        </trans-unit>
        <trans-unit id="172cb58908f30e86253a48b7781eed8cfd4c158b" translate="yes" xml:space="preserve">
          <source>The major version number of Emacs, as an integer. For Emacs version 23.1, the value is 23.</source>
          <target state="translated">The major version number of Emacs, as an integer. For Emacs version 23.1, the value is 23.</target>
        </trans-unit>
        <trans-unit id="0d1af093b0fd27af29ab4b28e1513e6dc00a63aa" translate="yes" xml:space="preserve">
          <source>The manual should be fully correct in what it does cover, and it is therefore open to criticism on anything it says&amp;mdash;from specific examples and descriptive text, to the ordering of chapters and sections. If something is confusing, or you find that you have to look at the sources or experiment to learn something not covered in the manual, then perhaps the manual should be fixed. Please let us know.</source>
          <target state="translated">The manual should be fully correct in what it does cover, and it is therefore open to criticism on anything it says&amp;mdash;from specific examples and descriptive text, to the ordering of chapters and sections. If something is confusing, or you find that you have to look at the sources or experiment to learn something not covered in the manual, then perhaps the manual should be fixed. Please let us know.</target>
        </trans-unit>
        <trans-unit id="a5e22ef195f16823ddf7673778585082a4f46066" translate="yes" xml:space="preserve">
          <source>The mark for the buffer. The mark is a marker, hence it is also included on the list &lt;code&gt;markers&lt;/code&gt;. See &lt;a href=&quot;the-mark#The-Mark&quot;&gt;The Mark&lt;/a&gt;.</source>
          <target state="translated">The mark for the buffer. The mark is a marker, hence it is also included on the list &lt;code&gt;markers&lt;/code&gt; . See &lt;a href=&quot;the-mark#The-Mark&quot;&gt;The Mark&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="b258116b18e88b2e80482d5981d360a38a61fc94" translate="yes" xml:space="preserve">
          <source>The mark is active when this variable is non-&lt;code&gt;nil&lt;/code&gt;. This variable is always buffer-local in each buffer. Do &lt;em&gt;not&lt;/em&gt; use the value of this variable to decide whether a command that normally operates on text near point should operate on the region instead. Use the function &lt;code&gt;use-region-p&lt;/code&gt; for that (see &lt;a href=&quot;the-region#The-Region&quot;&gt;The Region&lt;/a&gt;).</source>
          <target state="translated">The mark is active when this variable is non- &lt;code&gt;nil&lt;/code&gt; . This variable is always buffer-local in each buffer. Do &lt;em&gt;not&lt;/em&gt; use the value of this variable to decide whether a command that normally operates on text near point should operate on the region instead. Use the function &lt;code&gt;use-region-p&lt;/code&gt; for that (see &lt;a href=&quot;the-region#The-Region&quot;&gt;The Region&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="cf467a06fad52dab305b0df8d802a3dd9b6b7599" translate="yes" xml:space="preserve">
          <source>The mark is not active now</source>
          <target state="translated">The mark is not active now</target>
        </trans-unit>
        <trans-unit id="2294805a57144c8f475dd286330832439e218b3b" translate="yes" xml:space="preserve">
          <source>The mark specifies a position to bound a range of text for many commands, such as &lt;code&gt;kill-region&lt;/code&gt; and &lt;code&gt;indent-rigidly&lt;/code&gt;. These commands typically act on the text between point and the mark, which is called the &lt;em&gt;region&lt;/em&gt;. If you are writing a command that operates on the region, don&amp;rsquo;t examine the mark directly; instead, use &lt;code&gt;interactive&lt;/code&gt; with the &amp;lsquo;</source>
          <target state="translated">The mark specifies a position to bound a range of text for many commands, such as &lt;code&gt;kill-region&lt;/code&gt; and &lt;code&gt;indent-rigidly&lt;/code&gt; . These commands typically act on the text between point and the mark, which is called the &lt;em&gt;region&lt;/em&gt;. If you are writing a command that operates on the region, don&amp;rsquo;t examine the mark directly; instead, use &lt;code&gt;interactive&lt;/code&gt; with the &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="1b1540074aa53b63216cd2456d72381dd8d0fc52" translate="yes" xml:space="preserve">
          <source>The markers that refer to this buffer. This is actually a single marker, and successive elements in its marker &lt;em&gt;chain&lt;/em&gt; (a linked list) are the other markers referring to this buffer text.</source>
          <target state="translated">The markers that refer to this buffer. This is actually a single marker, and successive elements in its marker &lt;em&gt;chain&lt;/em&gt; (a linked list) are the other markers referring to this buffer text.</target>
        </trans-unit>
        <trans-unit id="bb06b83e3da02615a4f7e9ab6d8336bdd25a1731" translate="yes" xml:space="preserve">
          <source>The matcher processes a &amp;lsquo;</source>
          <target state="translated">The matcher processes a &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="92f6e3600296536bb76b7fcd8d76a0af6e42a364" translate="yes" xml:space="preserve">
          <source>The mathematical constant &lt;em&gt;e&lt;/em&gt; (2.71828&amp;hellip;).</source>
          <target state="translated">The mathematical constant &lt;em&gt;e&lt;/em&gt; (2.71828&amp;hellip;).</target>
        </trans-unit>
        <trans-unit id="1a3e48f3d1745f4908462da41660cc121d6d0f68" translate="yes" xml:space="preserve">
          <source>The mathematical constant &lt;em&gt;pi&lt;/em&gt; (3.14159&amp;hellip;).</source>
          <target state="translated">The mathematical constant &lt;em&gt;pi&lt;/em&gt; (3.14159&amp;hellip;).</target>
        </trans-unit>
        <trans-unit id="8e605715e3d2691c70b3f21b0b8462b89a7614e5" translate="yes" xml:space="preserve">
          <source>The maximum advance width of the font.</source>
          <target state="translated">The maximum advance width of the font.</target>
        </trans-unit>
        <trans-unit id="978782c408873797cfb6aaf7d660218a112071f9" translate="yes" xml:space="preserve">
          <source>The maximum number of changes that can be amalgamated is controlled by the &lt;code&gt;amalgamating-undo-limit&lt;/code&gt; variable. If this variable is 1, no changes are amalgamated.</source>
          <target state="translated">The maximum number of changes that can be amalgamated is controlled by the &lt;code&gt;amalgamating-undo-limit&lt;/code&gt; variable. If this variable is 1, no changes are amalgamated.</target>
        </trans-unit>
        <trans-unit id="82b0cf778d9e1f9d0ac00a5da272e14e2306ca7f" translate="yes" xml:space="preserve">
          <source>The maximum stack size this function needs.</source>
          <target state="translated">The maximum stack size this function needs.</target>
        </trans-unit>
        <trans-unit id="459b7d57f50aecb28cc2870ce7b74f07723e326b" translate="yes" xml:space="preserve">
          <source>The meaning of a list depends on what it contains:</source>
          <target state="translated">The meaning of a list depends on what it contains:</target>
        </trans-unit>
        <trans-unit id="d3fe651ac40ed9579fa5231d4fcd52354eb5372a" translate="yes" xml:space="preserve">
          <source>The meanings of these list elements are as follows:</source>
          <target state="translated">The meanings of these list elements are as follows:</target>
        </trans-unit>
        <trans-unit id="12d4b0de515899d94eda4148e6b314c9f86a96b8" translate="yes" xml:space="preserve">
          <source>The menu bar (see &lt;a href=&quot;menu-bar#Menu-Bar&quot;&gt;Menu Bar&lt;/a&gt;) can be either internal (drawn by Emacs itself) or external (drawn by the toolkit). Most builds (GTK+, Lucid, Motif and MS-Windows) rely on an external menu bar. NS also uses an external menu bar which, however, is not part of the outer frame. Non-toolkit builds can provide an internal menu bar. On text terminal frames, the menu bar is part of the frame&amp;rsquo;s root window (see &lt;a href=&quot;windows-and-frames#Windows-and-Frames&quot;&gt;Windows and Frames&lt;/a&gt;). As a rule, menu bars are never shown on child frames (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;). Display of the menu bar can be suppressed by setting the &lt;code&gt;menu-bar-lines&lt;/code&gt; parameter (see &lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;Layout Parameters&lt;/a&gt;) to zero.</source>
          <target state="translated">The menu bar (see &lt;a href=&quot;menu-bar#Menu-Bar&quot;&gt;Menu Bar&lt;/a&gt;) can be either internal (drawn by Emacs itself) or external (drawn by the toolkit). Most builds (GTK+, Lucid, Motif and MS-Windows) rely on an external menu bar. NS also uses an external menu bar which, however, is not part of the outer frame. Non-toolkit builds can provide an internal menu bar. On text terminal frames, the menu bar is part of the frame&amp;rsquo;s root window (see &lt;a href=&quot;windows-and-frames#Windows-and-Frames&quot;&gt;Windows and Frames&lt;/a&gt;). As a rule, menu bars are never shown on child frames (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;). Display of the menu bar can be suppressed by setting the &lt;code&gt;menu-bar-lines&lt;/code&gt; parameter (see &lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;Layout Parameters&lt;/a&gt;) to zero.</target>
        </trans-unit>
        <trans-unit id="9c36ca261c29f5622700c6f2f7d03d8bacd64def" translate="yes" xml:space="preserve">
          <source>The menu bar does not recalculate which items are enabled every time you look at a menu. This is because the X toolkit requires the whole tree of menus in advance. To force recalculation of the menu bar, call &lt;code&gt;force-mode-line-update&lt;/code&gt; (see &lt;a href=&quot;mode-line-format#Mode-Line-Format&quot;&gt;Mode Line Format&lt;/a&gt;).</source>
          <target state="translated">The menu bar does not recalculate which items are enabled every time you look at a menu. This is because the X toolkit requires the whole tree of menus in advance. To force recalculation of the menu bar, call &lt;code&gt;force-mode-line-update&lt;/code&gt; (see &lt;a href=&quot;mode-line-format#Mode-Line-Format&quot;&gt;Mode Line Format&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="0671d125fcb3f27fb5c40fddd77a7227205c4dea" translate="yes" xml:space="preserve">
          <source>The menu bar mechanism, which lets you switch between submenus by moving the mouse, cannot look within the definition of a command to see that it calls &lt;code&gt;x-popup-menu&lt;/code&gt;. Therefore, if you try to implement a submenu using &lt;code&gt;x-popup-menu&lt;/code&gt;, it cannot work with the menu bar in an integrated fashion. This is why all menu bar submenus are implemented with menu keymaps within the parent menu, and never with &lt;code&gt;x-popup-menu&lt;/code&gt;. See &lt;a href=&quot;menu-bar#Menu-Bar&quot;&gt;Menu Bar&lt;/a&gt;.</source>
          <target state="translated">The menu bar mechanism, which lets you switch between submenus by moving the mouse, cannot look within the definition of a command to see that it calls &lt;code&gt;x-popup-menu&lt;/code&gt; . Therefore, if you try to implement a submenu using &lt;code&gt;x-popup-menu&lt;/code&gt; , it cannot work with the menu bar in an integrated fashion. This is why all menu bar submenus are implemented with menu keymaps within the parent menu, and never with &lt;code&gt;x-popup-menu&lt;/code&gt; . See &lt;a href=&quot;menu-bar#Menu-Bar&quot;&gt;Menu Bar&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="9fccd406d5e813b76ef7a41fe974c95db256bdc6" translate="yes" xml:space="preserve">
          <source>The menu in this example is intended for use with the mouse. If a menu is intended for use with the keyboard, that is, if it is bound to a key sequence ending with a keyboard event, then the menu items should be bound to characters or real function keys, that can be typed with the keyboard.</source>
          <target state="translated">The menu in this example is intended for use with the mouse. If a menu is intended for use with the keyboard, that is, if it is bound to a key sequence ending with a keyboard event, then the menu items should be bound to characters or real function keys, that can be typed with the keyboard.</target>
        </trans-unit>
        <trans-unit id="884ca4e3a78e0c7d0eb618828c719ec2bc18c4b5" translate="yes" xml:space="preserve">
          <source>The menu&amp;rsquo;s items are the bindings in the keymap. Each binding associates an event type to a definition, but the event types have no significance for the menu appearance. (Usually we use pseudo-events, symbols that the keyboard cannot generate, as the event types for menu item bindings.) The menu is generated entirely from the bindings that correspond in the keymap to these events.</source>
          <target state="translated">The menu&amp;rsquo;s items are the bindings in the keymap. Each binding associates an event type to a definition, but the event types have no significance for the menu appearance. (Usually we use pseudo-events, symbols that the keyboard cannot generate, as the event types for menu item bindings.) The menu is generated entirely from the bindings that correspond in the keymap to these events.</target>
        </trans-unit>
        <trans-unit id="4ffe1db1ee3430043bd7d7cfed2fce90a58b2f33" translate="yes" xml:space="preserve">
          <source>The message is &amp;lsquo;</source>
          <target state="translated">The message is &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="1b4522d132316958b60412509a75ad9dd71138ff" translate="yes" xml:space="preserve">
          <source>The message is &lt;code&gt;Arithmetic range error&lt;/code&gt;.</source>
          <target state="translated">The message is &lt;code&gt;Arithmetic range error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14845ac05edc00f5ef9aed326e6a4acbb2d66dc1" translate="yes" xml:space="preserve">
          <source>The message is the empty string. See &lt;a href=&quot;signaling-errors#Signaling-Errors&quot;&gt;Signaling Errors&lt;/a&gt;.</source>
          <target state="translated">The message is the empty string. See &lt;a href=&quot;signaling-errors#Signaling-Errors&quot;&gt;Signaling Errors&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="a343531eec6204803775063bd43c8b0c3b1e1d7d" translate="yes" xml:space="preserve">
          <source>The message is usually &amp;lsquo;</source>
          <target state="translated">The message is usually &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="a72cf44ed0b2379b5bd18fbbfcf576f977b2239c" translate="yes" xml:space="preserve">
          <source>The meta modifier.</source>
          <target state="translated">The meta modifier.</target>
        </trans-unit>
        <trans-unit id="b1a58020916aba3f6cdf104343f3433939d15e37" translate="yes" xml:space="preserve">
          <source>The meta variants of those characters, with codes in the range of 2**27 to 2**27+127, can also go in the string, but you must change their numeric values. You must set the 2**7 bit instead of the 2**27 bit, resulting in a value between 128 and 255. Only a unibyte string can include these codes.</source>
          <target state="translated">The meta variants of those characters, with codes in the range of 2**27 to 2**27+127, can also go in the string, but you must change their numeric values. You must set the 2**7 bit instead of the 2**27 bit, resulting in a value between 128 and 255. Only a unibyte string can include these codes.</target>
        </trans-unit>
        <trans-unit id="9260d6b48ff908594f1c64bdc5084fd35f5bbde1" translate="yes" xml:space="preserve">
          <source>The minibuffer&amp;rsquo;s window is normally a single line; it grows automatically if the contents require more space. Whilst the minibuffer is active, you can explicitly resize its window temporarily with the window sizing commands; the window reverts to its normal size when the minibuffer is exited. When the minibuffer is not active, you can resize its window permanently by using the window sizing commands in the frame&amp;rsquo;s other window, or dragging the mode line with the mouse. (Due to details of the current implementation, for this to work &lt;code&gt;resize-mini-windows&lt;/code&gt; must be &lt;code&gt;nil&lt;/code&gt;.) If the frame contains just a minibuffer window, you can change its size by changing the frame&amp;rsquo;s size.</source>
          <target state="translated">The minibuffer&amp;rsquo;s window is normally a single line; it grows automatically if the contents require more space. Whilst the minibuffer is active, you can explicitly resize its window temporarily with the window sizing commands; the window reverts to its normal size when the minibuffer is exited. When the minibuffer is not active, you can resize its window permanently by using the window sizing commands in the frame&amp;rsquo;s other window, or dragging the mode line with the mouse. (Due to details of the current implementation, for this to work &lt;code&gt;resize-mini-windows&lt;/code&gt; must be &lt;code&gt;nil&lt;/code&gt; .) If the frame contains just a minibuffer window, you can change its size by changing the frame&amp;rsquo;s size.</target>
        </trans-unit>
        <trans-unit id="fc66b2b22fab10f272a2733f5220517063d244a8" translate="yes" xml:space="preserve">
          <source>The minimum parenthesis depth encountered during this scan.</source>
          <target state="translated">The minimum parenthesis depth encountered during this scan.</target>
        </trans-unit>
        <trans-unit id="f63caeb9d63ae3ea523b1bd607e47fabe4f9c44a" translate="yes" xml:space="preserve">
          <source>The minor mode should, if possible, support enabling and disabling via Custom (see &lt;a href=&quot;customization#Customization&quot;&gt;Customization&lt;/a&gt;). To do this, the mode variable should be defined with &lt;code&gt;defcustom&lt;/code&gt;, usually with &lt;code&gt;:type 'boolean&lt;/code&gt;. If just setting the variable is not sufficient to enable the mode, you should also specify a &lt;code&gt;:set&lt;/code&gt; method which enables the mode by invoking the mode command. Note in the variable&amp;rsquo;s documentation string that setting the variable other than via Custom may not take effect. Also, mark the definition with an autoload cookie (see &lt;a href=&quot;autoload#autoload-cookie&quot;&gt;autoload cookie&lt;/a&gt;), and specify a &lt;code&gt;:require&lt;/code&gt; so that customizing the variable will load the library that defines the mode. For example:</source>
          <target state="translated">The minor mode should, if possible, support enabling and disabling via Custom (see &lt;a href=&quot;customization#Customization&quot;&gt;Customization&lt;/a&gt;). To do this, the mode variable should be defined with &lt;code&gt;defcustom&lt;/code&gt; , usually with &lt;code&gt;:type 'boolean&lt;/code&gt; . If just setting the variable is not sufficient to enable the mode, you should also specify a &lt;code&gt;:set&lt;/code&gt; method which enables the mode by invoking the mode command. Note in the variable&amp;rsquo;s documentation string that setting the variable other than via Custom may not take effect. Also, mark the definition with an autoload cookie (see &lt;a href=&quot;autoload#autoload-cookie&quot;&gt;autoload cookie&lt;/a&gt;), and specify a &lt;code&gt;:require&lt;/code&gt; so that customizing the variable will load the library that defines the mode. For example:</target>
        </trans-unit>
        <trans-unit id="a754ecbf865ded2f8f972fadc0f979ee00b4c003" translate="yes" xml:space="preserve">
          <source>The minor version number of Emacs, as an integer. For Emacs version 23.1, the value is 1.</source>
          <target state="translated">The minor version number of Emacs, as an integer. For Emacs version 23.1, the value is 1.</target>
        </trans-unit>
        <trans-unit id="1778e11c806e3d03eed718920a2bdcbe70425f0c" translate="yes" xml:space="preserve">
          <source>The mnemonics of keyboard, terminal, and buffer coding systems.</source>
          <target state="translated">The mnemonics of keyboard, terminal, and buffer coding systems.</target>
        </trans-unit>
        <trans-unit id="d4aa0cdb7029a5f2355863fdbbab99919ce6ce82" translate="yes" xml:space="preserve">
          <source>The mode can specify a local value for &lt;code&gt;eldoc-documentation-function&lt;/code&gt; to tell ElDoc mode how to handle this mode.</source>
          <target state="translated">The mode can specify a local value for &lt;code&gt;eldoc-documentation-function&lt;/code&gt; to tell ElDoc mode how to handle this mode.</target>
        </trans-unit>
        <trans-unit id="354ca13496161c1669222f09fc05f88ea22e29e9" translate="yes" xml:space="preserve">
          <source>The mode can specify how to complete various keywords by adding one or more buffer-local entries to the special hook &lt;code&gt;completion-at-point-functions&lt;/code&gt;. See &lt;a href=&quot;completion-in-buffers#Completion-in-Buffers&quot;&gt;Completion in Buffers&lt;/a&gt;.</source>
          <target state="translated">The mode can specify how to complete various keywords by adding one or more buffer-local entries to the special hook &lt;code&gt;completion-at-point-functions&lt;/code&gt; . See &lt;a href=&quot;completion-in-buffers#Completion-in-Buffers&quot;&gt;Completion in Buffers&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="9ced895ea9c1431eb7e76df2f2cbdc9e5d0836c8" translate="yes" xml:space="preserve">
          <source>The mode command should accept one optional argument. If called interactively with no prefix argument, it should toggle the mode (i.e., enable if it is disabled, and disable if it is enabled). If called interactively with a prefix argument, it should enable the mode if the argument is positive and disable it otherwise.</source>
          <target state="translated">The mode command should accept one optional argument. If called interactively with no prefix argument, it should toggle the mode (i.e., enable if it is disabled, and disable if it is enabled). If called interactively with a prefix argument, it should enable the mode if the argument is positive and disable it otherwise.</target>
        </trans-unit>
        <trans-unit id="44819a97a0e2f91469bd3f92a2d58321df9329f0" translate="yes" xml:space="preserve">
          <source>The mode line contents are controlled by a data structure called a &lt;em&gt;mode line construct&lt;/em&gt;, made up of lists, strings, symbols, and numbers kept in buffer-local variables. Each data type has a specific meaning for the mode line appearance, as described below. The same data structure is used for constructing frame titles (see &lt;a href=&quot;frame-titles#Frame-Titles&quot;&gt;Frame Titles&lt;/a&gt;) and header lines (see &lt;a href=&quot;header-lines#Header-Lines&quot;&gt;Header Lines&lt;/a&gt;).</source>
          <target state="translated">The mode line contents are controlled by a data structure called a &lt;em&gt;mode line construct&lt;/em&gt;, made up of lists, strings, symbols, and numbers kept in buffer-local variables. Each data type has a specific meaning for the mode line appearance, as described below. The same data structure is used for constructing frame titles (see &lt;a href=&quot;frame-titles#Frame-Titles&quot;&gt;Frame Titles&lt;/a&gt;) and header lines (see &lt;a href=&quot;header-lines#Header-Lines&quot;&gt;Header Lines&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="e208e76c5548c1d095dbde47ed20de1a7d12aa6a" translate="yes" xml:space="preserve">
          <source>The mode may have its own abbrev table or may share one with other related modes. If it has its own abbrev table, it should store this in a variable named &lt;code&gt;&lt;var&gt;modename&lt;/var&gt;-mode-abbrev-table&lt;/code&gt;. If the major mode command defines any abbrevs itself, it should pass &lt;code&gt;t&lt;/code&gt; for the &lt;var&gt;system-flag&lt;/var&gt; argument to &lt;code&gt;define-abbrev&lt;/code&gt;. See &lt;a href=&quot;defining-abbrevs#Defining-Abbrevs&quot;&gt;Defining Abbrevs&lt;/a&gt;.</source>
          <target state="translated">The mode may have its own abbrev table or may share one with other related modes. If it has its own abbrev table, it should store this in a variable named &lt;code&gt;&lt;var&gt;modename&lt;/var&gt;-mode-abbrev-table&lt;/code&gt; . If the major mode command defines any abbrevs itself, it should pass &lt;code&gt;t&lt;/code&gt; for the &lt;var&gt;system-flag&lt;/var&gt; argument to &lt;code&gt;define-abbrev&lt;/code&gt; . See &lt;a href=&quot;defining-abbrevs#Defining-Abbrevs&quot;&gt;Defining Abbrevs&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="566eebc546ff4022d5692ebd193f3372e5deedf9" translate="yes" xml:space="preserve">
          <source>The mode may have its own syntax table or may share one with other related modes. If it has its own syntax table, it should store this in a variable named &lt;code&gt;&lt;var&gt;modename&lt;/var&gt;-mode-syntax-table&lt;/code&gt;. See &lt;a href=&quot;syntax-tables#Syntax-Tables&quot;&gt;Syntax Tables&lt;/a&gt;.</source>
          <target state="translated">The mode may have its own syntax table or may share one with other related modes. If it has its own syntax table, it should store this in a variable named &lt;code&gt;&lt;var&gt;modename&lt;/var&gt;-mode-syntax-table&lt;/code&gt; . See &lt;a href=&quot;syntax-tables#Syntax-Tables&quot;&gt;Syntax Tables&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="7febfb2248d6f317197277153f5791a4f2a7185b" translate="yes" xml:space="preserve">
          <source>The mode should specify how Imenu should find the definitions or sections of a buffer, by setting up a buffer-local value for the variable &lt;code&gt;imenu-generic-expression&lt;/code&gt;, for the two variables &lt;code&gt;imenu-prev-index-position-function&lt;/code&gt; and &lt;code&gt;imenu-extract-index-name-function&lt;/code&gt;, or for the variable &lt;code&gt;imenu-create-index-function&lt;/code&gt; (see &lt;a href=&quot;imenu#Imenu&quot;&gt;Imenu&lt;/a&gt;).</source>
          <target state="translated">The mode should specify how Imenu should find the definitions or sections of a buffer, by setting up a buffer-local value for the variable &lt;code&gt;imenu-generic-expression&lt;/code&gt; , for the two variables &lt;code&gt;imenu-prev-index-position-function&lt;/code&gt; and &lt;code&gt;imenu-extract-index-name-function&lt;/code&gt; , or for the variable &lt;code&gt;imenu-create-index-function&lt;/code&gt; (see &lt;a href=&quot;imenu#Imenu&quot;&gt;Imenu&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="e819d19cb71035bc2b05451e5471df8840dc6d69" translate="yes" xml:space="preserve">
          <source>The mode should specify how to do highlighting for Font Lock mode, by setting up a buffer-local value for the variable &lt;code&gt;font-lock-defaults&lt;/code&gt; (see &lt;a href=&quot;font-lock-mode#Font-Lock-Mode&quot;&gt;Font Lock Mode&lt;/a&gt;).</source>
          <target state="translated">The mode should specify how to do highlighting for Font Lock mode, by setting up a buffer-local value for the variable &lt;code&gt;font-lock-defaults&lt;/code&gt; (see &lt;a href=&quot;font-lock-mode#Font-Lock-Mode&quot;&gt;Font Lock Mode&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="41a1cfe199d882964dc064f09142206bb96f8e6c" translate="yes" xml:space="preserve">
          <source>The modification time of the visited file. It is set when the file is written or read. Before writing the buffer into a file, this field is compared to the modification time of the file to see if the file has changed on disk. See &lt;a href=&quot;buffer-modification#Buffer-Modification&quot;&gt;Buffer Modification&lt;/a&gt;.</source>
          <target state="translated">The modification time of the visited file. It is set when the file is written or read. Before writing the buffer into a file, this field is compared to the modification time of the file to see if the file has changed on disk. See &lt;a href=&quot;buffer-modification#Buffer-Modification&quot;&gt;Buffer Modification&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="4e9e26b12f5c002c1627a4d332042e4cecc33362" translate="yes" xml:space="preserve">
          <source>The modifiers list for a click event explicitly contains &lt;code&gt;click&lt;/code&gt;, but the event symbol name itself does not contain &amp;lsquo;</source>
          <target state="translated">클릭 이벤트의 수정 자 목록에는 &lt;code&gt;click&lt;/code&gt; 이 명시 적으로 포함되어 있지만 이벤트 기호 이름 자체에는 '</target>
        </trans-unit>
        <trans-unit id="b3b787746e135e4f51648da476a31670954846cd" translate="yes" xml:space="preserve">
          <source>The momentary display remains until the next input event. If the next input event is &lt;var&gt;char&lt;/var&gt;, &lt;code&gt;momentary-string-display&lt;/code&gt; ignores it and returns. Otherwise, that event remains buffered for subsequent use as input. Thus, typing &lt;var&gt;char&lt;/var&gt; will simply remove the string from the display, while typing (say)</source>
          <target state="translated">순간 표시는 다음 입력 이벤트까지 유지됩니다. 다음 입력 이벤트가 &lt;var&gt;char&lt;/var&gt; 이면 &lt;code&gt;momentary-string-display&lt;/code&gt; 는이를 무시하고 반환합니다. 그렇지 않으면 해당 이벤트는 나중에 입력으로 사용할 수 있도록 버퍼링 된 상태로 유지됩니다. 따라서 &lt;var&gt;char&lt;/var&gt; 을 입력하면 입력 하는 동안 디스플레이에서 문자열이 제거됩니다 (예 :</target>
        </trans-unit>
        <trans-unit id="6ccfa1f10310929beb049fb30bcfc7d9086811f9" translate="yes" xml:space="preserve">
          <source>The month of the year, as an integer between 1 and 12.</source>
          <target state="translated">1에서 12 사이의 정수로 표시되는 월입니다.</target>
        </trans-unit>
        <trans-unit id="edb5bce3a7e2bd1bf00ac6d3a9eb55fc41355ba2" translate="yes" xml:space="preserve">
          <source>The most basic primitive for minibuffer input is &lt;code&gt;read-from-minibuffer&lt;/code&gt;, which can be used to read either a string or a Lisp object in textual form. The function &lt;code&gt;read-regexp&lt;/code&gt; is used for reading regular expressions (see &lt;a href=&quot;regular-expressions#Regular-Expressions&quot;&gt;Regular Expressions&lt;/a&gt;), which are a special kind of string. There are also specialized functions for reading commands, variables, file names, etc. (see &lt;a href=&quot;completion#Completion&quot;&gt;Completion&lt;/a&gt;).</source>
          <target state="translated">미니 버퍼 입력에 대한 가장 기본적인 기본 요소는 &lt;code&gt;read-from-minibuffer&lt;/code&gt; 이며, 문자열이나 Lisp 객체를 텍스트 형식으로 읽는 데 사용할 수 있습니다. &lt;code&gt;read-regexp&lt;/code&gt; 함수 는 특수한 종류의 문자열 인 정규식을 읽는 데 사용됩니다 ( &lt;a href=&quot;regular-expressions#Regular-Expressions&quot;&gt;정규식&lt;/a&gt; 참조 ). 명령, 변수, 파일 이름 등을 읽기위한 특수 함수도 있습니다 ( &lt;a href=&quot;completion#Completion&quot;&gt;완료&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="04571e47b6db6005c0928b2d449f301cebe34f7a" translate="yes" xml:space="preserve">
          <source>The most basic way to alter the contents of an existing string is with &lt;code&gt;aset&lt;/code&gt; (see &lt;a href=&quot;array-functions#Array-Functions&quot;&gt;Array Functions&lt;/a&gt;). &lt;code&gt;(aset &lt;var&gt;string&lt;/var&gt;
&lt;var&gt;idx&lt;/var&gt; &lt;var&gt;char&lt;/var&gt;)&lt;/code&gt; stores &lt;var&gt;char&lt;/var&gt; into &lt;var&gt;string&lt;/var&gt; at index &lt;var&gt;idx&lt;/var&gt;. Each character occupies one or more bytes, and if &lt;var&gt;char&lt;/var&gt; needs a different number of bytes from the character already present at that index, &lt;code&gt;aset&lt;/code&gt; signals an error.</source>
          <target state="translated">기존 문자열의 내용을 변경하는 가장 기본적인 방법은 &lt;code&gt;aset&lt;/code&gt; 을 사용하는 것입니다 ( &lt;a href=&quot;array-functions#Array-Functions&quot;&gt;배열 함수&lt;/a&gt; 참조 ). &lt;code&gt;(aset &lt;var&gt;string&lt;/var&gt; &lt;var&gt;idx&lt;/var&gt; &lt;var&gt;char&lt;/var&gt;)&lt;/code&gt; &lt;var&gt;char&lt;/var&gt; 는 index &lt;var&gt;idx&lt;/var&gt; 의 &lt;var&gt;string&lt;/var&gt; 에 저장 됩니다 . 각 문자는 하나 이상의 바이트를 차지하며 &lt;var&gt;char&lt;/var&gt; 에 이미 해당 인덱스에있는 문자와 다른 수의 바이트가 필요한 경우 &lt;code&gt;aset&lt;/code&gt; 은 오류 신호를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="bf4dd793bfdf67867b9bdc6495e0ff90954bd76e" translate="yes" xml:space="preserve">
          <source>The most basic way to use the expression parser is to tell it to start at a given position with a certain state, and parse up to a specified end position.</source>
          <target state="translated">표현식 파서를 사용하는 가장 기본적인 방법은 특정 상태의 지정된 위치에서 시작하고 지정된 끝 위치까지 구문 분석하도록 지시하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b7f2a6fce568eb37624dbc5a896f8aecf156540b" translate="yes" xml:space="preserve">
          <source>The most common items to autoload are the interactive entry points to a library. For example, if</source>
          <target state="translated">자동로드 할 가장 일반적인 항목은 라이브러리에 대한 대화 형 진입 점입니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="00ce30cf3da30f9ec9b191e1b5b38d0ab5c7d881" translate="yes" xml:space="preserve">
          <source>The most common problem in writing macros is doing some of the real work prematurely&amp;mdash;while expanding the macro, rather than in the expansion itself. For instance, one real package had this macro definition:</source>
          <target state="translated">매크로 작성에서 가장 일반적인 문제는 확장 자체가 아닌 매크로를 확장하면서 실제 작업의 일부를 조기에 수행하는 것입니다. 예를 들어 하나의 실제 패키지에는 다음과 같은 매크로 정의가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2cf92a8ba2845654523982a452093a675127ce73" translate="yes" xml:space="preserve">
          <source>The most common reason to use &lt;code&gt;:require&lt;/code&gt; is when a variable enables a feature such as a minor mode, and just setting the variable won&amp;rsquo;t have any effect unless the code which implements the mode is loaded.</source>
          <target state="translated">&lt;code&gt;:require&lt;/code&gt; 를 사용하는 가장 일반적인 이유 는 변수가 마이너 모드와 같은 기능을 활성화 할 때이며, 모드를 구현하는 코드가로드되지 않는 한 변수를 설정하는 것만으로는 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="00d251711d163f90f5dc973380466e863d64f7b0" translate="yes" xml:space="preserve">
          <source>The most common repeat events are &lt;em&gt;double-click&lt;/em&gt; events. Emacs generates a double-click event when you click a button twice; the event happens when you release the button (as is normal for all click events).</source>
          <target state="translated">가장 일반적인 반복 이벤트는 &lt;em&gt;두 번 클릭&lt;/em&gt; 이벤트입니다. Emacs는 버튼을 두 번 클릭하면 더블 클릭 이벤트를 생성합니다. 이 이벤트는 버튼을 놓을 때 발생합니다 (모든 클릭 이벤트에 대해 일반적인 경우).</target>
        </trans-unit>
        <trans-unit id="57850c0a76ab6f2efce7f9ee07926b9e3846b613" translate="yes" xml:space="preserve">
          <source>The most common use of buffer-local bindings is for major modes to change variables that control the behavior of commands. For example, C mode and Lisp mode both set the variable &lt;code&gt;paragraph-start&lt;/code&gt; to specify that only blank lines separate paragraphs. They do this by making the variable buffer-local in the buffer that is being put into C mode or Lisp mode, and then setting it to the new value for that mode. See &lt;a href=&quot;major-modes#Major-Modes&quot;&gt;Major Modes&lt;/a&gt;.</source>
          <target state="translated">버퍼 로컬 바인딩의 가장 일반적인 용도는 명령의 동작을 제어하는 ​​변수를 변경하는 주요 모드에 사용됩니다. 예를 들어 C 모드와 Lisp 모드는 모두 &lt;code&gt;paragraph-start&lt;/code&gt; 변수를 설정하여 빈 줄만 단락을 구분하도록 지정합니다. C 모드 또는 Lisp 모드로 들어가는 버퍼에서 변수를 buffer-local로 만든 다음 해당 모드에 대한 새 값으로 설정하여이를 수행합니다. &lt;a href=&quot;major-modes#Major-Modes&quot;&gt;주요 모드를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="702580a0fb96dc0456829bb764ce3a637ffd43c4" translate="yes" xml:space="preserve">
          <source>The most common way of invoking a function is by evaluating a list. For example, evaluating the list &lt;code&gt;(concat &quot;a&quot; &quot;b&quot;)&lt;/code&gt; calls the function &lt;code&gt;concat&lt;/code&gt; with arguments &lt;code&gt;&quot;a&quot;&lt;/code&gt; and &lt;code&gt;&quot;b&quot;&lt;/code&gt;. See &lt;a href=&quot;evaluation#Evaluation&quot;&gt;Evaluation&lt;/a&gt;, for a description of evaluation.</source>
          <target state="translated">함수를 호출하는 가장 일반적인 방법은 목록을 평가하는 것입니다. 예를 들어, 목록 &lt;code&gt;(concat &quot;a&quot; &quot;b&quot;)&lt;/code&gt; 을 평가하면 인수 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;b&quot;&lt;/code&gt; 를 사용하여 &lt;code&gt;concat&lt;/code&gt; 함수가 호출 됩니다. &lt;a href=&quot;evaluation#Evaluation&quot;&gt;평가&lt;/a&gt; 에 대한 설명은 평가를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d131735a093456a7b6d24f8f667e2b2a59acf4e8" translate="yes" xml:space="preserve">
          <source>The most common way to compute the length of a list, when you are not worried that it may be circular, is with &lt;code&gt;length&lt;/code&gt;. See &lt;a href=&quot;sequence-functions#Sequence-Functions&quot;&gt;Sequence Functions&lt;/a&gt;.</source>
          <target state="translated">목록의 길이를 계산하는 가장 일반적인 방법은 목록이 원형 일지 걱정되지 않을 때 &lt;code&gt;length&lt;/code&gt; 를 사용하는 것 입니다. &lt;a href=&quot;sequence-functions#Sequence-Functions&quot;&gt;시퀀스 함수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="347c946e7276a21392ff141fa45e82a75d88329c" translate="yes" xml:space="preserve">
          <source>The most general of the two facilities is controlled by the variable &lt;code&gt;format-alist&lt;/code&gt;, a list of &lt;em&gt;file format&lt;/em&gt; specifications, which describe textual representations used in files for the data in an Emacs buffer. The descriptions for reading and writing are paired, which is why we call this &amp;ldquo;round-trip&amp;rdquo; specification (see &lt;a href=&quot;format-conversion-piecemeal#Format-Conversion-Piecemeal&quot;&gt;Format Conversion Piecemeal&lt;/a&gt;, for non-paired specification).</source>
          <target state="translated">두 기능 중 가장 일반적인 것은 Emacs 버퍼의 데이터에 대한 파일에서 사용되는 텍스트 표현을 설명하는 &lt;em&gt;파일 형식&lt;/em&gt; 사양 목록 인 변수 &lt;code&gt;format-alist&lt;/code&gt; 에 의해 제어됩니다 . 읽기와 쓰기에 대한 설명이 쌍을 이루기 때문에이를 &quot;왕복&quot;사양이라고합니다 ( 쌍이 아닌 사양에 대해서는 &lt;a href=&quot;format-conversion-piecemeal#Format-Conversion-Piecemeal&quot;&gt;Format Conversion Piecemeal&lt;/a&gt; 참조 ).&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cd8ccdf82fe4e52359af0e8e7311554e454e5dd4" translate="yes" xml:space="preserve">
          <source>The most general way to check the type of an object is to call the function &lt;code&gt;type-of&lt;/code&gt;. Recall that each object belongs to one and only one primitive type; &lt;code&gt;type-of&lt;/code&gt; tells you which one (see &lt;a href=&quot;lisp-data-types#Lisp-Data-Types&quot;&gt;Lisp Data Types&lt;/a&gt;). But &lt;code&gt;type-of&lt;/code&gt; knows nothing about non-primitive types. In most cases, it is more convenient to use type predicates than &lt;code&gt;type-of&lt;/code&gt;.</source>
          <target state="translated">객체의 유형을 확인하는 가장 일반적인 방법은 &lt;code&gt;type-of&lt;/code&gt; 함수를 호출하는 것 입니다 . 각 객체는 하나의 기본 유형에만 속한다는 것을 기억하십시오. &lt;code&gt;type-of&lt;/code&gt; 는 어떤 것을 알려줍니다 ( &lt;a href=&quot;lisp-data-types#Lisp-Data-Types&quot;&gt;Lisp 데이터 유형&lt;/a&gt; 참조 ). 그러나 &lt;code&gt;type-of&lt;/code&gt; 는 원시 유형이 아닌 유형에 대해 아무것도 모릅니다. 대부분의 경우 &lt;code&gt;type-of&lt;/code&gt; 보다 type 술어를 사용하는 것이 더 편리합니다 .</target>
        </trans-unit>
        <trans-unit id="c939ba5fb7000b3ef15a75258275fafbcfabe6bd" translate="yes" xml:space="preserve">
          <source>The most important time to enter the debugger is when a Lisp error happens. This allows you to investigate the immediate causes of the error.</source>
          <target state="translated">디버거에 들어가는 가장 중요한 시간은 Lisp 오류가 발생할 때입니다. 이를 통해 오류의 즉각적인 원인을 조사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18cb17b94649eed8921d3ce73d54ecd88ad00023" translate="yes" xml:space="preserve">
          <source>The most simple approach to make a new atomic window is to take an existing internal window and apply the following function:</source>
          <target state="translated">새 원자 창을 만드는 가장 간단한 방법은 기존 내부 창을 가져와 다음 함수를 적용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e1e8fa969491d0969bdb64f111c245755eef7fdd" translate="yes" xml:space="preserve">
          <source>The mutex ensures atomicity, and the loop is for robustness&amp;mdash;there may be spurious notifications.</source>
          <target state="translated">뮤텍스는 원 자성을 보장하고 루프는 견고성을위한 것입니다. 가짜 알림이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20600bb0132abd59b71aa3abecbc6c3c79d7ed11" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;easy-mmode-define-minor-mode&lt;/code&gt; is an alias for this macro.</source>
          <target state="translated">&lt;code&gt;easy-mmode-define-minor-mode&lt;/code&gt; 라는 이름 은이 매크로의 별칭입니다.</target>
        </trans-unit>
        <trans-unit id="0164386da8dab74b0dca8dc21998a6981ad8f3bc" translate="yes" xml:space="preserve">
          <source>The name &lt;var&gt;property&lt;/var&gt; is compared with the existing property names using &lt;code&gt;eq&lt;/code&gt;, so any object is a legitimate property.</source>
          <target state="translated">name &lt;var&gt;property&lt;/var&gt; 은 &lt;code&gt;eq&lt;/code&gt; 를 사용하여 기존 속성 이름과 비교 되므로 모든 객체는 합법적 인 속성입니다.</target>
        </trans-unit>
        <trans-unit id="81686d309fb6971d2f0465f17ae4fbda5d84fd34" translate="yes" xml:space="preserve">
          <source>The name of a face from which to inherit attributes, or a list of face names. Attributes from inherited faces are merged into the face like an underlying face would be, with higher priority than underlying faces (see &lt;a href=&quot;displaying-faces#Displaying-Faces&quot;&gt;Displaying Faces&lt;/a&gt;). If the face to inherit from is &lt;code&gt;unspecified&lt;/code&gt;, it is treated the same as &lt;code&gt;nil&lt;/code&gt;, since Emacs never merges &lt;code&gt;:inherit&lt;/code&gt; attributes. If a list of faces is used, attributes from faces earlier in the list override those from later faces.</source>
          <target state="translated">속성을 상속 할 얼굴의 이름 또는 얼굴 이름 목록입니다. 상속 된면의 속성은 기본면과 같이 기본 면보다 우선 순위가 높은면에 병합됩니다 (면 &lt;a href=&quot;displaying-faces#Displaying-Faces&quot;&gt;표시&lt;/a&gt; 참조 ). 상속 할면이 &lt;code&gt;unspecified&lt;/code&gt; 경우 Emacs는 &lt;code&gt;:inherit&lt;/code&gt; 속성을 병합하지 않으므로 &lt;code&gt;nil&lt;/code&gt; 과 동일하게 처리 됩니다. 얼굴 목록을 사용하는 경우 목록 앞부분에있는 얼굴의 속성이 이후 얼굴의 속성보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="f14b4e7f3d214e623215de71ea76c596c58a8147" translate="yes" xml:space="preserve">
          <source>The name of an existing buffer. By default, uses the name of the current buffer (see &lt;a href=&quot;buffers#Buffers&quot;&gt;Buffers&lt;/a&gt;). Existing, Completion, Default, Prompt.</source>
          <target state="translated">기존 버퍼의 이름입니다. 기본적으로는 현재 버퍼의 이름을 사용합니다 ( &lt;a href=&quot;buffers#Buffers&quot;&gt;버퍼&lt;/a&gt; 참조 ). 기존, 완료, 기본값, 프롬프트.</target>
        </trans-unit>
        <trans-unit id="2d3de7a674caef56f2edb7325689eee077d5c503" translate="yes" xml:space="preserve">
          <source>The name of the &lt;em&gt;font foundry&lt;/em&gt; for the font family specified by the &lt;code&gt;:family&lt;/code&gt; attribute (a string). See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Fonts.html#Fonts&quot;&gt;Fonts&lt;/a&gt; in</source>
          <target state="translated">&lt;code&gt;:family&lt;/code&gt; 속성 (문자열)으로 지정된 글꼴 패밀리에 대한 &lt;em&gt;글꼴 파운드리&lt;/em&gt; 의 이름입니다 . 참조 &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Fonts.html#Fonts&quot;&gt;글꼴&lt;/a&gt; 에</target>
        </trans-unit>
        <trans-unit id="d84e4020bfcfa0d5df12e11e36810c5a458fbc2c" translate="yes" xml:space="preserve">
          <source>The name of the application sending the notification. The default is &lt;code&gt;notifications-application-name&lt;/code&gt;.</source>
          <target state="translated">알림을 보내는 애플리케이션의 이름입니다. 기본값은 &lt;code&gt;notifications-application-name&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="31bc03ff12180dc54cb103b5e65b3d301c362de1" translate="yes" xml:space="preserve">
          <source>The name of the command that runs in the process. This is a string that usually specifies the name of the executable file of the process, without the leading directories. However, some special system processes can report strings that do not correspond to an executable file of a program.</source>
          <target state="translated">프로세스에서 실행되는 명령의 이름입니다. 일반적으로 선행 디렉토리없이 프로세스의 실행 파일 이름을 지정하는 문자열입니다. 그러나 일부 특수 시스템 프로세스는 프로그램의 실행 파일에 해당하지 않는 문자열을보고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd51404aec6b7e3516493114c0df7bd668d69bf8" translate="yes" xml:space="preserve">
          <source>The name of the device used by the terminal (e.g., &amp;lsquo;</source>
          <target state="translated">터미널에서 사용하는 장치의 이름 (예 : '</target>
        </trans-unit>
        <trans-unit id="86223234e995255179c7f5ed59ad98c61222e8f0" translate="yes" xml:space="preserve">
          <source>The name of the file visited in this buffer, or &lt;code&gt;nil&lt;/code&gt;. This is the value of the buffer-local variable &lt;code&gt;buffer-file-name&lt;/code&gt; (see &lt;a href=&quot;buffer-file-name#Buffer-File-Name&quot;&gt;Buffer File Name&lt;/a&gt;).</source>
          <target state="translated">이 버퍼에서 방문한 파일의 이름 또는 &lt;code&gt;nil&lt;/code&gt; . 이것은 버퍼 로컬 변수 &lt;code&gt;buffer-file-name&lt;/code&gt; 의 값입니다 ( &lt;a href=&quot;buffer-file-name#Buffer-File-Name&quot;&gt;버퍼 파일 이름&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="9cf516df8bd70dd62a0f6c98d528269943f52170" translate="yes" xml:space="preserve">
          <source>The name of the font for displaying text in the frame. This is a string, either a valid font name for your system or the name of an Emacs fontset (see &lt;a href=&quot;fontsets#Fontsets&quot;&gt;Fontsets&lt;/a&gt;). It is equivalent to the &lt;code&gt;font&lt;/code&gt; attribute of the &lt;code&gt;default&lt;/code&gt; face.</source>
          <target state="translated">프레임에 텍스트를 표시하기위한 글꼴의 이름입니다. 이것은 시스템의 유효한 글꼴 이름이거나 Emacs 글꼴 세트의 이름 인 문자열입니다 ( &lt;a href=&quot;fontsets#Fontsets&quot;&gt;Fontsets&lt;/a&gt; 참조 ). &lt;code&gt;default&lt;/code&gt; 얼굴 의 &lt;code&gt;font&lt;/code&gt; 속성과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="c12d93ce989364c1c7d4f9a741900cf941c5dab1" translate="yes" xml:space="preserve">
          <source>The name of the frame. The frame name serves as a default for the frame title, if the &lt;code&gt;title&lt;/code&gt; parameter is unspecified or &lt;code&gt;nil&lt;/code&gt;. If you don&amp;rsquo;t specify a name, Emacs sets the frame name automatically (see &lt;a href=&quot;frame-titles#Frame-Titles&quot;&gt;Frame Titles&lt;/a&gt;).</source>
          <target state="translated">프레임의 이름입니다. &lt;code&gt;title&lt;/code&gt; 매개 변수가 지정되지 않거나 &lt;code&gt;nil&lt;/code&gt; 인 경우 프레임 이름은 프레임 제목의 기본값으로 사용됩니다 . 이름을 지정하지 않으면 Emacs는 프레임 이름을 자동으로 설정합니다 ( &lt;a href=&quot;frame-titles#Frame-Titles&quot;&gt;프레임 제목&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="d46a694cb309b5635ce7fcf75332cf135b35bc90" translate="yes" xml:space="preserve">
          <source>The name of the keysym that should stand for the Control modifier (respectively, for Alt, Meta, Hyper, and Super). For example, here is how to swap the Meta and Alt modifiers within Emacs:</source>
          <target state="translated">Control 수정자를 나타내야하는 키 심의 이름입니다 (각각 Alt, Meta, Hyper 및 Super). 예를 들어, Emacs 내에서 Meta 및 Alt 수정자를 교체하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ea60fe57d26ab008b617db1ef54c09ed08318866" translate="yes" xml:space="preserve">
          <source>The name of the package is the same as the base name of the file, as written on the first line. Here, it is &amp;lsquo;</source>
          <target state="translated">패키지 이름은 첫 번째 줄에 기록 된 파일의 기본 이름과 동일합니다. 여기있어 '</target>
        </trans-unit>
        <trans-unit id="e21cb3a697575e4abea29254c179c8f2f42f271b" translate="yes" xml:space="preserve">
          <source>The name of the process. If &lt;var&gt;name&lt;/var&gt; is not given, &lt;var&gt;port&lt;/var&gt; will serve as the process name as well.</source>
          <target state="translated">프로세스의 이름입니다. 경우 &lt;var&gt;name&lt;/var&gt; 주어지지, &lt;var&gt;port&lt;/var&gt; 프로세스 이름이 될뿐만 아니라 것입니다.</target>
        </trans-unit>
        <trans-unit id="33d6a32c269c144c63e53d0f2cba19c64ba4f020" translate="yes" xml:space="preserve">
          <source>The name of the terminal that the subprocess is using, or &lt;code&gt;nil&lt;/code&gt; if it is using pipes.</source>
          <target state="translated">하위 프로세스가 사용하는 터미널의 이름 또는 파이프를 사용하는 경우 &lt;code&gt;nil&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fb41db266496240f445c6fb5baacf0f57a720b53" translate="yes" xml:space="preserve">
          <source>The name of the variable in the C sources.</source>
          <target state="translated">C 소스의 변수 이름입니다.</target>
        </trans-unit>
        <trans-unit id="a4f65da0bf349454db5eb2650407f2361527b7b0" translate="yes" xml:space="preserve">
          <source>The name of the variable to be used by Lisp programs.</source>
          <target state="translated">Lisp 프로그램에서 사용할 변수의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="3670965055037b4c4d3b2f88fc9e6bd05ff338ee" translate="yes" xml:space="preserve">
          <source>The name of this format.</source>
          <target state="translated">이 형식의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="8b92537c9d27af39ba1f11b476a35f30e67426f9" translate="yes" xml:space="preserve">
          <source>The name to use in the icon for this frame, when and if the icon appears. If this is &lt;code&gt;nil&lt;/code&gt;, the frame&amp;rsquo;s title is used.</source>
          <target state="translated">이 프레임의 아이콘에 사용할 이름, 아이콘이 나타나는시기 및 경우. 이것이 &lt;code&gt;nil&lt;/code&gt; 이면 프레임의 제목이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="773601ddb143e48334daba0a066ba237e287a6d6" translate="yes" xml:space="preserve">
          <source>The name used to open the font, a string.</source>
          <target state="translated">글꼴을 여는 데 사용되는 이름, 문자열.</target>
        </trans-unit>
        <trans-unit id="8fcccebb07f7dee6937b0795494fd79034dd2f04" translate="yes" xml:space="preserve">
          <source>The named &lt;var&gt;method&lt;/var&gt; was defined by using &lt;code&gt;cl-defmethod&lt;/code&gt;, with &lt;var&gt;specializers&lt;/var&gt; as its specializers.</source>
          <target state="translated">명명 된 &lt;var&gt;method&lt;/var&gt; 는 &lt;var&gt;specializers&lt;/var&gt; 를 전문화 자로 사용하여 &lt;code&gt;cl-defmethod&lt;/code&gt; 를 사용하여 정의되었습니다 .</target>
        </trans-unit>
        <trans-unit id="fe3c2e352de1a3150f44a8697619e4fda0c3a43a" translate="yes" xml:space="preserve">
          <source>The names &lt;small&gt;CAR&lt;/small&gt; and &lt;small&gt;CDR&lt;/small&gt; derive from the history of Lisp. The original Lisp implementation ran on an IBM 704 computer which divided words into two parts, the address and the decrement; &lt;small&gt;CAR&lt;/small&gt; was an instruction to extract the contents of the address part of a register, and &lt;small&gt;CDR&lt;/small&gt; an instruction to extract the contents of the decrement. By contrast, cons cells are named for the function &lt;code&gt;cons&lt;/code&gt; that creates them, which in turn was named for its purpose, the construction of cells.</source>
          <target state="translated">&lt;small&gt;CAR&lt;/small&gt; 과 &lt;small&gt;CDR&lt;/small&gt; 이라는 이름 은 Lisp의 역사에서 유래되었습니다. 원래 Lisp 구현은 단어를 주소와 감소라는 두 부분으로 나눈 IBM 704 컴퓨터에서 실행되었습니다. &lt;small&gt;CAR&lt;/small&gt; 은 레지스터 주소 부분의 내용을 추출하는 명령 이고, &lt;small&gt;CDR&lt;/small&gt; 은 감소 내용을 추출하는 명령입니다. 대조적으로, cons 셀은이 를 생성 하는 기능 &lt;code&gt;cons&lt;/code&gt; 를 위해 명명되었으며, 차례로 그 목적, 즉 셀 구성으로 명명되었습니다.</target>
        </trans-unit>
        <trans-unit id="ba31422c908b55bb35be7435bbd860d86c29702f" translate="yes" xml:space="preserve">
          <source>The native position of a frame is the reference position for functions that set or return the current position of the mouse (see &lt;a href=&quot;mouse-position#Mouse-Position&quot;&gt;Mouse Position&lt;/a&gt;) and for functions dealing with the position of windows like &lt;code&gt;window-edges&lt;/code&gt;, &lt;code&gt;window-at&lt;/code&gt; or &lt;code&gt;coordinates-in-window-p&lt;/code&gt; (see &lt;a href=&quot;coordinates-and-windows#Coordinates-and-Windows&quot;&gt;Coordinates and Windows&lt;/a&gt;). It also specifies the (0, 0) origin for locating and positioning child frames within this frame (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;).</source>
          <target state="translated">프레임의 기본 위치는 마우스의 현재 위치를 설정하거나 반환하는 함수 ( &lt;a href=&quot;mouse-position#Mouse-Position&quot;&gt;Mouse Position&lt;/a&gt; 참조 ) 및 &lt;code&gt;window-edges&lt;/code&gt; , &lt;code&gt;window-at&lt;/code&gt; 또는 &lt;code&gt;coordinates-in-window-p&lt;/code&gt; 와 같은 창의 위치를 처리하는 함수에 대한 참조 위치입니다. -p ( &lt;a href=&quot;coordinates-and-windows#Coordinates-and-Windows&quot;&gt;좌표 및 창&lt;/a&gt; 참조 ). 또한,이 위치 내에 하위 프레임의 위치 결정에 대해 (0, 0)의 원점을 지정 (참조 &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;하위 프레임&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="79b45725606655f4197b9ae82b2b82dab59aede2" translate="yes" xml:space="preserve">
          <source>The native size of a frame is the size Emacs passes to the window-system or window manager when creating or resizing the frame from within Emacs. It is also the size Emacs receives from the window-system or window manager whenever these resize the frame&amp;rsquo;s window-system window, for example, after maximizing the frame by clicking on the corresponding button in the title bar or when dragging its external border with the mouse.</source>
          <target state="translated">프레임의 기본 크기는 Emacs 내에서 프레임을 만들거나 크기를 조정할 때 Emacs가 창 시스템 또는 창 관리자에 전달하는 크기입니다. 예를 들어 제목 표시 줄에서 해당 버튼을 클릭하여 프레임을 최대화 한 후 또는 외부 테두리를 쥐.</target>
        </trans-unit>
        <trans-unit id="14825e98a6bb7730ba468267f3c379f4d50eadd3" translate="yes" xml:space="preserve">
          <source>The network mask.</source>
          <target state="translated">네트워크 마스크.</target>
        </trans-unit>
        <trans-unit id="7fc5eefdbee523b516c3a56d241e65616fe5cea8" translate="yes" xml:space="preserve">
          <source>The new command &lt;var&gt;variant&lt;/var&gt; is defined to call the function &lt;var&gt;parent&lt;/var&gt;, then override certain aspects of that parent mode:</source>
          <target state="translated">새로운 명령 &lt;var&gt;variant&lt;/var&gt; 은 &lt;var&gt;parent&lt;/var&gt; 함수를 호출 한 다음 해당 상위 모드의 특정 측면을 재정의 하도록 정의 됩니다.</target>
        </trans-unit>
        <trans-unit id="5ce6d115e553357dfd304409824efeb325dc1b14" translate="yes" xml:space="preserve">
          <source>The new definition of &lt;code&gt;for&lt;/code&gt; has a new problem: it introduces a local variable named &lt;code&gt;max&lt;/code&gt; which the user does not expect. This causes trouble in examples such as the following:</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 의 새로운 정의 에는 새로운 문제가 있습니다. 사용자가 예상하지 못한 &lt;code&gt;max&lt;/code&gt; 라는 로컬 변수를 도입했습니다 . 이로 인해 다음과 같은 예에서 문제가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6a336356f22c547d590556ea521f2dad738c8349" translate="yes" xml:space="preserve">
          <source>The new fontset has two names, one long and one short. The long name is &lt;var&gt;fontpattern&lt;/var&gt; in its entirety. The short name is &amp;lsquo;</source>
          <target state="translated">새 글꼴 세트에는 긴 이름과 짧은 이름의 두 가지 이름이 있습니다. 긴 이름은 전체적으로 &lt;var&gt;fontpattern&lt;/var&gt; 입니다. 짧은 이름은 '</target>
        </trans-unit>
        <trans-unit id="c3a411aa70ab9bb343c22475f4a8a3db7a1aaaa6" translate="yes" xml:space="preserve">
          <source>The new marker&amp;rsquo;s insertion type is specified by the argument &lt;var&gt;insertion-type&lt;/var&gt;. See &lt;a href=&quot;marker-insertion-types#Marker-Insertion-Types&quot;&gt;Marker Insertion Types&lt;/a&gt;.</source>
          <target state="translated">새 마커의 삽입 유형은 &lt;var&gt;insertion-type&lt;/var&gt; 인수로 지정됩니다 . &lt;a href=&quot;marker-insertion-types#Marker-Insertion-Types&quot;&gt;마커 삽입 유형을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e53ad877e538af9a720bbb66ac6ff5d4008840d4" translate="yes" xml:space="preserve">
          <source>The new mode has its own abbrev table, kept in the variable &lt;code&gt;&lt;var&gt;variant&lt;/var&gt;-abbrev-table&lt;/code&gt;, unless you override this using the &lt;code&gt;:abbrev-table&lt;/code&gt; keyword (see below).</source>
          <target state="translated">새 모드에는 &lt;code&gt;:abbrev-table&lt;/code&gt; 키워드 (아래 참조)를 사용하여이를 재정의하지 않는 한 변수 &lt;code&gt;&lt;var&gt;variant&lt;/var&gt;-abbrev-table&lt;/code&gt; 유지되는 자체 약어 테이블 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b817ae5e0fd787bbcf07fe3487597358970c4e96" translate="yes" xml:space="preserve">
          <source>The new mode has its own mode hook, &lt;code&gt;&lt;var&gt;variant&lt;/var&gt;-hook&lt;/code&gt;. It runs this hook, after running the hooks of its ancestor modes, with &lt;code&gt;run-mode-hooks&lt;/code&gt;, as the last thing it does, apart from running any &lt;code&gt;:after-hook&lt;/code&gt; form it may have. See &lt;a href=&quot;mode-hooks#Mode-Hooks&quot;&gt;Mode Hooks&lt;/a&gt;.</source>
          <target state="translated">새 모드에는 자체 모드 후크 인 &lt;code&gt;&lt;var&gt;variant&lt;/var&gt;-hook&lt;/code&gt; 있습니다. 그것은과 그 조상 모드의 후크를 실행 한 후,이 후크를 실행 &lt;code&gt;run-mode-hooks&lt;/code&gt; 가 수행하는 마지막으로 떨어져 하나를 실행, &lt;code&gt;:after-hook&lt;/code&gt; 형태가있을 수 있습니다. &lt;a href=&quot;mode-hooks#Mode-Hooks&quot;&gt;모드 후크를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="00570ab789edcc32fb33047192ad9e67acc9f749" translate="yes" xml:space="preserve">
          <source>The new mode has its own sparse keymap, named &lt;code&gt;&lt;var&gt;variant&lt;/var&gt;-map&lt;/code&gt;. &lt;code&gt;define-derived-mode&lt;/code&gt; makes the parent mode&amp;rsquo;s keymap the parent of the new map, unless &lt;code&gt;&lt;var&gt;variant&lt;/var&gt;-map&lt;/code&gt; is already set and already has a parent.</source>
          <target state="translated">새 모드에는 &lt;code&gt;&lt;var&gt;variant&lt;/var&gt;-map&lt;/code&gt; 이라는 고유 한 스파 스 키맵이 있습니다. &lt;code&gt;define-derived-mode&lt;/code&gt; 는 &lt;code&gt;&lt;var&gt;variant&lt;/var&gt;-map&lt;/code&gt; 이 이미 설정되어 있고 이미 상위가 없는 경우 상위 모드의 키맵을 새 맵 의 상위로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="945a91028fd0f8fc9a5b05174767e7c35cb3f960" translate="yes" xml:space="preserve">
          <source>The new mode has its own syntax table, kept in the variable &lt;code&gt;&lt;var&gt;variant&lt;/var&gt;-syntax-table&lt;/code&gt;, unless you override this using the &lt;code&gt;:syntax-table&lt;/code&gt; keyword (see below). &lt;code&gt;define-derived-mode&lt;/code&gt; makes the parent mode&amp;rsquo;s syntax-table the parent of &lt;code&gt;&lt;var&gt;variant&lt;/var&gt;-syntax-table&lt;/code&gt;, unless the latter is already set and already has a parent different from the standard syntax table.</source>
          <target state="translated">새 모드에는 &lt;code&gt;:syntax-table&lt;/code&gt; 키워드 (아래 참조)를 사용하여이를 재정의하지 않는 한 변수 &lt;code&gt;&lt;var&gt;variant&lt;/var&gt;-syntax-table&lt;/code&gt; 보관되는 자체 구문 테이블 이 있습니다. &lt;code&gt;define-derived-mode&lt;/code&gt; 는 후자가 이미 설정되어 있고 이미 표준 구문 테이블과 다른 부모가있는 경우를 제외 하고 부모 모드의 구문 테이블을 &lt;code&gt;&lt;var&gt;variant&lt;/var&gt;-syntax-table&lt;/code&gt; -syntax-table 의 부모로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c2597cc1d2ff3aeb01d30bac9fc3cde7623c9599" translate="yes" xml:space="preserve">
          <source>The new thread is created with no local variable bindings in effect. The new thread&amp;rsquo;s current buffer is inherited from the current thread.</source>
          <target state="translated">로컬 변수 바인딩이 적용되지 않은 상태로 새 스레드가 생성됩니다. 새 스레드의 현재 버퍼는 현재 스레드에서 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="8df0e83e8de1eb380770375b9be1ffb711a27047" translate="yes" xml:space="preserve">
          <source>The newest element in the ring always has index 0. Higher indices correspond to older elements. Indices are computed modulo the ring length. Index -1 corresponds to the oldest element, -2 to the next-oldest, and so forth.</source>
          <target state="translated">링의 최신 요소에는 항상 인덱스 0이 있습니다. 인덱스가 높을수록 이전 요소에 해당합니다. 인덱스는 링 길이의 모듈로 계산됩니다. 인덱스 -1은 가장 오래된 요소에 해당하고 -2는 다음으로 오래된 요소에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="8e1c114485b4df403bf7d12c30cb8c0fba64430c" translate="yes" xml:space="preserve">
          <source>The newline character (character code 10) has a special effect: it ends the preceding line and starts a new line.</source>
          <target state="translated">개행 문자 (문자 코드 10)는 특수 효과가 있습니다. 이전 행을 끝내고 새 행을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="2e9517c16f2af179f8f22773bf78a93935c17bc6" translate="yes" xml:space="preserve">
          <source>The newline character is not special in the read syntax for strings; if you write a new line between the double-quotes, it becomes a character in the string. But an escaped newline&amp;mdash;one that is preceded by &amp;lsquo;</source>
          <target state="translated">개행 문자는 문자열 읽기 구문에서 특별하지 않습니다. 큰 따옴표 사이에 새 줄을 쓰면 문자열에서 문자가됩니다. 하지만 이스케이프 된 개행 문자는 '</target>
        </trans-unit>
        <trans-unit id="4efa69ac3b7f005e072f33b3c4d9d2015117589e" translate="yes" xml:space="preserve">
          <source>The next &lt;code&gt;pred&lt;/code&gt; (lines 4-5) evaluates &lt;code&gt;(string-match&amp;nbsp;RX&amp;nbsp;&lt;var&gt;expval&lt;/var&gt;)&lt;/code&gt; and matches if the result is non-&lt;code&gt;nil&lt;/code&gt;, which means that &lt;var&gt;expval&lt;/var&gt; has the desired form: &lt;code&gt;key:NUMBER&lt;/code&gt;. Again, failing this, &lt;code&gt;pred&lt;/code&gt; fails and &lt;code&gt;and&lt;/code&gt;, too.</source>
          <target state="translated">다음 &lt;code&gt;pred&lt;/code&gt; (4-5 행) 는 결과가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 평가 &lt;code&gt;(string-match&amp;nbsp;RX&amp;nbsp;&lt;var&gt;expval&lt;/var&gt;)&lt;/code&gt; 하고 일치합니다. 즉, &lt;var&gt;expval&lt;/var&gt; 이 원하는 형식 인 &lt;code&gt;key:NUMBER&lt;/code&gt; 를 갖습니다 . 다시 말하지만, 이것을 실패하면, &lt;code&gt;pred&lt;/code&gt; 는 실패 &lt;code&gt;and&lt;/code&gt; , 역시 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="b7694837921d35a54e56c860831d6080ffe61e74" translate="yes" xml:space="preserve">
          <source>The next and previous sibling of this window as Lisp objects. &lt;code&gt;next&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt; if the window is the right-most or bottom-most in its group; &lt;code&gt;prev&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt; if it is the left-most or top-most in its group. Whether the sibling is left/right or up/down is determined by the &lt;code&gt;horizontal&lt;/code&gt; field of the sibling&amp;rsquo;s parent: if it&amp;rsquo;s non-zero, the siblings are arranged horizontally.</source>
          <target state="translated">Lisp 개체로서이 창의 다음 및 이전 형제. &lt;code&gt;next&lt;/code&gt; 는 창이 그룹에서 맨 오른쪽 또는 맨 아래에 있으면 &lt;code&gt;nil&lt;/code&gt; 입니다 . &lt;code&gt;prev&lt;/code&gt; 는 그룹에서 맨 왼쪽 또는 맨 위에 있으면 &lt;code&gt;nil&lt;/code&gt; 입니다. 형제가 왼쪽 / 오른쪽 또는 위 / 아래인지 여부는 형제 부모 의 &lt;code&gt;horizontal&lt;/code&gt; 필드에 의해 결정됩니다. 0이 아닌 경우 형제는 가로로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="20020241f8b21f6f1b62e467e43654e312585449" translate="yes" xml:space="preserve">
          <source>The next four arguments to &lt;code&gt;sort-subr&lt;/code&gt; are functions that are called to move point across a sort record. They are called many times from within &lt;code&gt;sort-subr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sort-subr&lt;/code&gt; 에 대한 다음 네 개의 인수 는 정렬 레코드에서 지점을 이동하기 위해 호출되는 함수입니다. &lt;code&gt;sort-subr&lt;/code&gt; 내에서 여러 번 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="6e6df56c6cfd59f81e1889be41424dbd8e05af1c" translate="yes" xml:space="preserve">
          <source>The next four functions all return markers with insertion type &lt;code&gt;nil&lt;/code&gt;. See &lt;a href=&quot;marker-insertion-types#Marker-Insertion-Types&quot;&gt;Marker Insertion Types&lt;/a&gt;.</source>
          <target state="translated">다음 네 가지 함수는 모두 삽입 유형이 &lt;code&gt;nil&lt;/code&gt; 인 마커를 반환합니다 . &lt;a href=&quot;marker-insertion-types#Marker-Insertion-Types&quot;&gt;마커 삽입 유형을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e6e450313c4033e8457df931e4950913eecef97c" translate="yes" xml:space="preserve">
          <source>The next redisplay after resumption will redraw the entire screen, unless the variable &lt;code&gt;no-redraw-on-reenter&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;. See &lt;a href=&quot;refresh-screen#Refresh-Screen&quot;&gt;Refresh Screen&lt;/a&gt;.</source>
          <target state="translated">재개 후 다음 다시 표시는 변수 &lt;code&gt;no-redraw-on-reenter&lt;/code&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 전체 화면을 다시 그 립니다. &lt;a href=&quot;refresh-screen#Refresh-Screen&quot;&gt;화면 새로 고침을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3c62480706c4435432f9cbd719f04c8c0e8d4d4b" translate="yes" xml:space="preserve">
          <source>The next step is to determine precisely what is wrong. There is no way to be sure of this except by studying the program, but often the existing indentation is a clue to where the parentheses should have been. The easiest way to use this clue is to reindent with</source>
          <target state="translated">다음 단계는 무엇이 잘못되었는지 정확하게 판단하는 것입니다. 프로그램을 공부하는 것 외에는 이것을 확신 할 수있는 방법이 없지만, 종종 기존 들여 쓰기는 괄호가 있어야하는 위치에 대한 단서가됩니다. 이 단서를 사용하는 가장 쉬운 방법은 다음으로 다시 들여 쓰는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e881ec82dc043025b05e415a53a5307e0b9d1a7c" translate="yes" xml:space="preserve">
          <source>The next subsection describes how to define your own fringe bitmaps.</source>
          <target state="translated">다음 하위 섹션에서는 사용자 고유의 프린지 비트 맵을 정의하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="28f5894deb6be2c66452b9dec8f473fdb6fefb38" translate="yes" xml:space="preserve">
          <source>The next two commands are similar to &lt;code&gt;switch-to-buffer&lt;/code&gt;, except for the described features.</source>
          <target state="translated">다음 두 명령은 설명 된 기능을 제외하고 &lt;code&gt;switch-to-buffer&lt;/code&gt; 와 유사 합니다.</target>
        </trans-unit>
        <trans-unit id="7cc9290c0d0d2e4b42ba908efb154f702ea15fc9" translate="yes" xml:space="preserve">
          <source>The next two functions either return the argument &lt;var&gt;string&lt;/var&gt;, or a newly created string with no text properties.</source>
          <target state="translated">다음 두 함수는 &lt;var&gt;string&lt;/var&gt; 인수 또는 텍스트 속성이없는 새로 생성 된 문자열을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c1bc1e54049d4149bb73763e09a0583d8724361a" translate="yes" xml:space="preserve">
          <source>The next two functions signal an error if the mark does not point anywhere. If Transient Mark mode is enabled and &lt;code&gt;mark-even-if-inactive&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;, they also signal an error if the mark is inactive.</source>
          <target state="translated">다음 두 함수는 마크가 아무 곳도 가리 키지 않으면 오류를 나타냅니다. Transient Mark 모드가 활성화되고 &lt;code&gt;mark-even-if-inactive&lt;/code&gt; 가 &lt;code&gt;nil&lt;/code&gt; 인 경우 마크가 비활성화되면 오류 신호도 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="377df722feabe51756819277064a7bd38601469b" translate="yes" xml:space="preserve">
          <source>The non-printable &lt;em&gt;&lt;acronym&gt;ASCII&lt;/acronym&gt; control characters&lt;/em&gt;&amp;mdash;character codes 0 through 31, as well as the</source>
          <target state="translated">인쇄 할 수없는 &lt;em&gt;&lt;acronym&gt;ASCII&lt;/acronym&gt; 제어 문자 &amp;mdash;&lt;/em&gt; 문자 코드 0 ~ 31 및</target>
        </trans-unit>
        <trans-unit id="ce617211fc2ab0bb06bc37aae9e870737adcb1d5" translate="yes" xml:space="preserve">
          <source>The nonce is currently unused and only some MACs support it.</source>
          <target state="translated">nonce는 현재 사용되지 않으며 일부 MAC에서만 지원합니다.</target>
        </trans-unit>
        <trans-unit id="72d8a158209595f8bea693b50b579072c4c32b6d" translate="yes" xml:space="preserve">
          <source>The normal use of this function is to get the window system&amp;rsquo;s clipboard as the most recent kill, even if the selection belongs to another application. See &lt;a href=&quot;window-system-selections#Window-System-Selections&quot;&gt;Window System Selections&lt;/a&gt;. However, if the clipboard contents come from the current Emacs session, this function should return &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">이 함수의 일반적인 사용은 선택 항목이 다른 응용 프로그램에 속해 있더라도 윈도우 시스템의 클립 보드를 가장 최근의 강제 종료로 가져 오는 것입니다. &lt;a href=&quot;window-system-selections#Window-System-Selections&quot;&gt;윈도우 시스템 선택을&lt;/a&gt; 참조하십시오 . 그러나 클립 보드 내용이 현재 Emacs 세션에서 오는 경우이 함수는 &lt;code&gt;nil&lt;/code&gt; 을 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7e4d1f4d52266035590d8daa8fadfd0297361c08" translate="yes" xml:space="preserve">
          <source>The normal use of this function is to put newly killed text in the window system&amp;rsquo;s clipboard. See &lt;a href=&quot;window-system-selections#Window-System-Selections&quot;&gt;Window System Selections&lt;/a&gt;.</source>
          <target state="translated">이 함수의 일반적인 사용은 윈도우 시스템의 클립 보드에 새로 죽인 텍스트를 넣는 것입니다. &lt;a href=&quot;window-system-selections#Window-System-Selections&quot;&gt;윈도우 시스템 선택을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fe1cb8bbe65ec53be9067206dd1dfa6d2cad2dca" translate="yes" xml:space="preserve">
          <source>The normal value of this variable includes &lt;code&gt;user-error&lt;/code&gt;, as well as several errors that happen often during editing but rarely result from bugs in Lisp programs. However, &amp;ldquo;rarely&amp;rdquo; is not &amp;ldquo;never&amp;rdquo;; if your program fails with an error that matches this list, you may try changing this list to debug the error. The easiest way is usually to set &lt;code&gt;debug-ignored-errors&lt;/code&gt; to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">이 변수의 정상 값에는 &lt;code&gt;user-error&lt;/code&gt; 와 편집 중에 자주 발생하지만 Lisp 프로그램의 버그로 인해 거의 발생하지 않는 여러 오류가 포함됩니다. 그러나 &quot;드물게&quot;는 &quot;절대&quot;가 아닙니다. 프로그램이이 목록과 일치하는 오류로 인해 실패하면이 목록을 변경하여 오류를 디버깅 할 수 있습니다. 가장 쉬운 방법은 일반적으로 &lt;code&gt;debug-ignored-errors&lt;/code&gt; 를 &lt;code&gt;nil&lt;/code&gt; 로 설정 하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="615cf55184d1614679df8cf6d2cbadac0179b9d2" translate="yes" xml:space="preserve">
          <source>The normal way to use this feature is that the &lt;code&gt;buffer-access-fontify-functions&lt;/code&gt; functions add this property, as well as others, to the characters they operate on. That way, they avoid being called over and over for the same text.</source>
          <target state="translated">이 기능을 사용하는 일반적인 방법은 &lt;code&gt;buffer-access-fontify-functions&lt;/code&gt; 함수가 작동하는 문자에이 속성과 다른 속성을 추가하는 것입니다. 이렇게하면 동일한 텍스트에 대해 반복해서 호출되는 것을 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5bf403f55157eac254eec47b71824c0e07ba8c39" translate="yes" xml:space="preserve">
          <source>The normal way to use this function is after reading text from a file without decoding, if you decide you would rather have decoded it. Instead of deleting the text and reading it again, this time with decoding, you can call this function.</source>
          <target state="translated">이 기능을 사용하는 일반적인 방법은 디코딩하지 않고 파일에서 텍스트를 읽은 후 디코딩하는 것입니다. 텍스트를 삭제하고 다시 읽는 대신, 이번에는 디코딩을 통해이 함수를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14a4051b3db7273c333fed729bd4705f42b76cf0" translate="yes" xml:space="preserve">
          <source>The notification &lt;var&gt;id&lt;/var&gt; that this notification replaces. &lt;var&gt;id&lt;/var&gt; must be the result of a previous &lt;code&gt;notifications-notify&lt;/code&gt; call.</source>
          <target state="translated">이 알림 이 대체하는 알림 &lt;var&gt;id&lt;/var&gt; 입니다. &lt;var&gt;id&lt;/var&gt; 는 이전 &lt;code&gt;notifications-notify&lt;/code&gt; 호출 의 결과 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="235facb694a3673208a66d292afda77da06ef3e0" translate="yes" xml:space="preserve">
          <source>The notification body text. Depending on the implementation of the notification server, the text could contain HTML markups, like &amp;lsquo;</source>
          <target state="translated">알림 본문 텍스트입니다. 알림 서버의 구현에 따라 텍스트에는 '와 같은 HTML 마크 업이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6d14187af51bbbd99a616baf65fac010ae3eeaf" translate="yes" xml:space="preserve">
          <source>The notification title.</source>
          <target state="translated">알림 제목입니다.</target>
        </trans-unit>
        <trans-unit id="e447b4e8d9dde9805fe495b79d88178d76f80ab4" translate="yes" xml:space="preserve">
          <source>The number and significance of the objects in &lt;var&gt;data&lt;/var&gt; depends on &lt;var&gt;error-symbol&lt;/var&gt;. For example, with a &lt;code&gt;wrong-type-argument&lt;/code&gt; error, there should be two objects in the list: a predicate that describes the type that was expected, and the object that failed to fit that type.</source>
          <target state="translated">&lt;var&gt;data&lt;/var&gt; 에있는 객체의 수와 중요성은 &lt;var&gt;error-symbol&lt;/var&gt; 에 따라 다릅니다 . 예를 들어 &lt;code&gt;wrong-type-argument&lt;/code&gt; 오류가있는 경우 목록에 두 개의 개체가 있어야합니다. 예상 된 형식을 설명하는 술어와 해당 형식에 맞지 않는 개체입니다.</target>
        </trans-unit>
        <trans-unit id="77b891078bd95b24372c2265e2e2cd84fcd84a78" translate="yes" xml:space="preserve">
          <source>The number of &amp;lsquo;</source>
          <target state="translated">개수 '</target>
        </trans-unit>
        <trans-unit id="69d9f447f26ab68125cf7f7418e7b287e062c516" translate="yes" xml:space="preserve">
          <source>The number of bits per byte, which can be 7 or 8. If &lt;var&gt;bytesize&lt;/var&gt; is not given or &lt;code&gt;nil&lt;/code&gt;, it defaults to 8.</source>
          <target state="translated">바이트 당 비트 수는 7 또는 8이 될 수 있습니다. &lt;var&gt;bytesize&lt;/var&gt; 가 제공되지 않거나 &lt;code&gt;nil&lt;/code&gt; 이면 기본값은 8입니다.</target>
        </trans-unit>
        <trans-unit id="e69db1d2aafc1ecd874d0fd32605ef1930ae4340" translate="yes" xml:space="preserve">
          <source>The number of bool vector entries stored for each row; the smallest multiple of 8 greater than or equal to &lt;var&gt;width&lt;/var&gt;.</source>
          <target state="translated">각 행에 저장된 부울 벡터 항목의 수입니다. &lt;var&gt;width&lt;/var&gt; 보다 크거나 같은 8의 최소 배수 .</target>
        </trans-unit>
        <trans-unit id="0c696104f1d296d98cbf922f187ea8cac7fb9e83" translate="yes" xml:space="preserve">
          <source>The number of buffer objects in use. This includes killed buffers invisible to users, i.e., all buffers in &lt;code&gt;all_buffers&lt;/code&gt; list.</source>
          <target state="translated">사용중인 버퍼 개체 수입니다. 여기에는 사용자에게 보이지 않는 죽인 버퍼, 즉 &lt;code&gt;all_buffers&lt;/code&gt; 목록의 모든 버퍼가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="252d4f28db846bbf940d1217fadcdf56740580e5" translate="yes" xml:space="preserve">
          <source>The number of characters at the start and end of the text that are known to be unchanged since the last complete redisplay.</source>
          <target state="translated">마지막으로 완전히 다시 표시된 이후 변경되지 않은 것으로 알려진 텍스트의 시작 및 끝 문자 수입니다.</target>
        </trans-unit>
        <trans-unit id="89a302eaa04563e94b2b926ac658405d57a2374e" translate="yes" xml:space="preserve">
          <source>The number of cons cells for which space has been obtained from the operating system, but that are not currently being used.</source>
          <target state="translated">운영 체제에서 공간을 확보했지만 현재 사용되지 않는 단점 셀 수입니다.</target>
        </trans-unit>
        <trans-unit id="928cf9ce73beb664ce217349a8d5e6418448c470" translate="yes" xml:space="preserve">
          <source>The number of cons cells in use.</source>
          <target state="translated">사용중인 단점 셀 수입니다.</target>
        </trans-unit>
        <trans-unit id="24f7af3992f54804406740120a68503980b1aaf3" translate="yes" xml:space="preserve">
          <source>The number of currently active &lt;code&gt;unwind-protect&lt;/code&gt; forms counts, together with the number of local variable bindings, against the limit &lt;code&gt;max-specpdl-size&lt;/code&gt; (see &lt;a href=&quot;local-variables#Definition-of-max_002dspecpdl_002dsize&quot;&gt;Local Variables&lt;/a&gt;).</source>
          <target state="translated">제한 &lt;code&gt;max-specpdl-size&lt;/code&gt; 에 대해 현재 활성화 된 &lt;code&gt;unwind-protect&lt;/code&gt; 양식의 수와 로컬 변수 바인딩 수를 계산 합니다 ( &lt;a href=&quot;local-variables#Definition-of-max_002dspecpdl_002dsize&quot;&gt;로컬 변수&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="9c35725bb13e2859f8f990b1b6c1b4705566676f" translate="yes" xml:space="preserve">
          <source>The number of currently active calls to &lt;code&gt;eval&lt;/code&gt; is limited to &lt;code&gt;max-lisp-eval-depth&lt;/code&gt; (see below).</source>
          <target state="translated">&lt;code&gt;eval&lt;/code&gt; 에 대한 현재 활성 호출 수 는 &lt;code&gt;max-lisp-eval-depth&lt;/code&gt; 로 제한됩니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="26632f6fb1891fe7db7e3348f1653f11addc21e8" translate="yes" xml:space="preserve">
          <source>The number of floats for which space has been obtained from the operating system, but that are not currently being used.</source>
          <target state="translated">운영 체제에서 공간을 확보했지만 현재 사용되지 않는 부동 소수점 수입니다.</target>
        </trans-unit>
        <trans-unit id="f76646dd4182a8fa6a14d755790c6c7d2864f09c" translate="yes" xml:space="preserve">
          <source>The number of floats in use.</source>
          <target state="translated">사용중인 부동 수입니다.</target>
        </trans-unit>
        <trans-unit id="7d151b45b0c5d7e9e3c605630f35524687f27612" translate="yes" xml:space="preserve">
          <source>The number of free slots in all vector blocks.</source>
          <target state="translated">모든 벡터 블록의 사용 가능한 슬롯 수입니다.</target>
        </trans-unit>
        <trans-unit id="7a5cbacf926b1512cd0ba23780e03b3e4a98118a" translate="yes" xml:space="preserve">
          <source>The number of intervals for which space has been obtained from the operating system, but that are not currently being used.</source>
          <target state="translated">운영 체제에서 공간을 확보했지만 현재 사용되지 않는 간격 수입니다.</target>
        </trans-unit>
        <trans-unit id="602801cbd4078754bb74d81473f6f900a3e284ba" translate="yes" xml:space="preserve">
          <source>The number of intervals in use.</source>
          <target state="translated">사용중인 간격 수입니다.</target>
        </trans-unit>
        <trans-unit id="92de848307ab335b54cbbb276e13709bea52b86a" translate="yes" xml:space="preserve">
          <source>The number of lines to allocate at the top of the frame for a menu bar (see &lt;a href=&quot;menu-bar#Menu-Bar&quot;&gt;Menu Bar&lt;/a&gt;). The default is one if Menu Bar mode is enabled and zero otherwise. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Menu-Bars.html#Menu-Bars&quot;&gt;Menu Bars&lt;/a&gt; in</source>
          <target state="translated">라인의 수는 도구 모음의 프레임의 상단에 할당합니다 ( &lt;a href=&quot;menu-bar#Menu-Bar&quot;&gt;메뉴 바&lt;/a&gt; ). 기본값은 메뉴 모음 모드가 활성화 된 경우 1이고 그렇지 않은 경우 0입니다. 참조 &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Menu-Bars.html#Menu-Bars&quot;&gt;메뉴 바&lt;/a&gt; 에서</target>
        </trans-unit>
        <trans-unit id="5827e772cc5045e135130ea07603e84be0177d9b" translate="yes" xml:space="preserve">
          <source>The number of lines to use for the tool bar (see &lt;a href=&quot;tool-bar#Tool-Bar&quot;&gt;Tool Bar&lt;/a&gt;). The default is one if Tool Bar mode is enabled and zero otherwise. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Tool-Bars.html#Tool-Bars&quot;&gt;Tool Bars&lt;/a&gt; in</source>
          <target state="translated">도구 모음에 사용하는 라인의 수는 (참조 &lt;a href=&quot;tool-bar#Tool-Bar&quot;&gt;도구 모음을&lt;/a&gt; ). 도구 모음 모드가 활성화 된 경우 기본값은 1이고 그렇지 않은 경우 0입니다. 참조 &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Tool-Bars.html#Tool-Bars&quot;&gt;도구 바&lt;/a&gt; 에서</target>
        </trans-unit>
        <trans-unit id="c7f4d7c21579924cbdecd9574578a0259e96375a" translate="yes" xml:space="preserve">
          <source>The number of major page faults caused by the process since its beginning. (Major page faults require a disk to be read, and are thus more expensive than minor page faults.)</source>
          <target state="translated">시작 이후 프로세스로 인해 발생한 주요 페이지 오류 수입니다. (주요 페이지 오류는 디스크를 읽어야하므로 사소한 페이지 오류보다 비용이 많이 듭니다.)</target>
        </trans-unit>
        <trans-unit id="190fa917612a525a4d94c58578c9ab17ff36e051" translate="yes" xml:space="preserve">
          <source>The number of minor page faults caused by the process since its beginning. (Minor page faults are those that don&amp;rsquo;t involve reading from disk.)</source>
          <target state="translated">프로세스가 시작된 이후 발생한 사소한 페이지 오류 수입니다. (사소한 페이지 오류는 디스크에서 읽기와 관련이없는 오류입니다.)</target>
        </trans-unit>
        <trans-unit id="9d5ec76f037793ae468581429ef386612dd124f8" translate="yes" xml:space="preserve">
          <source>The number of minutes past the hour, as an integer between 0 and 59.</source>
          <target state="translated">0에서 59 사이의 정수로 표시되는 시간 (분)입니다.</target>
        </trans-unit>
        <trans-unit id="ad0f8ee15c9aa29fe5fb9cbe7ca13d4d44b5ef6a" translate="yes" xml:space="preserve">
          <source>The number of names the file has (&lt;code&gt;file-attribute-link-number&lt;/code&gt;). Alternate names, also known as hard links, can be created by using the &lt;code&gt;add-name-to-file&lt;/code&gt; function (see &lt;a href=&quot;changing-files#Changing-Files&quot;&gt;Changing Files&lt;/a&gt;).</source>
          <target state="translated">파일의 이름 수 ( &lt;code&gt;file-attribute-link-number&lt;/code&gt; ). 하드 링크라고도하는 대체 이름은 &lt;code&gt;add-name-to-file&lt;/code&gt; 을 사용하여 만들 수 있습니다 ( &lt;a href=&quot;changing-files#Changing-Files&quot;&gt;파일 변경&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="325baa1e7adcb16dc50f6245d77c21d0debe4ede" translate="yes" xml:space="preserve">
          <source>The number of pixels from the top of the scroll bar to the click position. On some toolkits, including GTK+, Emacs cannot extract this data, so the value is always &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">스크롤 막대 상단에서 클릭 위치까지의 픽셀 수입니다. GTK +를 포함한 일부 툴킷에서 Emacs는이 데이터를 추출 할 수 없으므로 값은 항상 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="81f70c31bc5858d0b9ea55feb80b52d7b0622a5a" translate="yes" xml:space="preserve">
          <source>The number of seconds past the minute, with form described below.</source>
          <target state="translated">아래에 설명 된 형식으로 분을 경과 한 시간 (초)입니다.</target>
        </trans-unit>
        <trans-unit id="16f645a9b7573d7e0be85843502b2537b32b9812" translate="yes" xml:space="preserve">
          <source>The number of slots in all used vectors. Slot counts might include some or all overhead from vector headers, depending on the platform.</source>
          <target state="translated">사용 된 모든 벡터의 슬롯 수입니다. 슬롯 수에는 플랫폼에 따라 벡터 헤더의 일부 또는 전체 오버 헤드가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4c7e2965ba0ba590e73e99ea618e58e9f048f9a" translate="yes" xml:space="preserve">
          <source>The number of stopbits used to terminate a transmission of each byte. &lt;var&gt;stopbits&lt;/var&gt; can be 1 or 2. If &lt;var&gt;stopbits&lt;/var&gt; is not given or &lt;code&gt;nil&lt;/code&gt;, it defaults to 1.</source>
          <target state="translated">각 바이트의 전송을 종료하는 데 사용되는 정지 비트 수입니다. &lt;var&gt;stopbits&lt;/var&gt; 는 1 또는 2가 될 수 있습니다. &lt;var&gt;stopbits&lt;/var&gt; 가 주어지지 않거나 &lt;code&gt;nil&lt;/code&gt; 이면 기본값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="584465d6a9c8121efa55f5d37a6a82a27d12aa63" translate="yes" xml:space="preserve">
          <source>The number of string headers for which space has been obtained from the operating system, but that are not currently being used.</source>
          <target state="translated">운영 체제에서 공간을 확보했지만 현재 사용되지 않는 문자열 헤더의 수입니다.</target>
        </trans-unit>
        <trans-unit id="11eee3b04765f2e7c114ec5eb04da8bccc9c8d67" translate="yes" xml:space="preserve">
          <source>The number of string headers in use.</source>
          <target state="translated">사용중인 문자열 헤더의 수입니다.</target>
        </trans-unit>
        <trans-unit id="2adc6fb63d1bc6a3331dbbc9b05d0c9bd724c7c7" translate="yes" xml:space="preserve">
          <source>The number of symbols for which space has been obtained from the operating system, but that are not currently being used.</source>
          <target state="translated">운영 체제에서 공간을 확보했지만 현재 사용되지 않는 기호의 수입니다.</target>
        </trans-unit>
        <trans-unit id="710444e67e6d2313474db8860db1bd9ce9d6ab60" translate="yes" xml:space="preserve">
          <source>The number of symbols in use.</source>
          <target state="translated">사용중인 기호 수입니다.</target>
        </trans-unit>
        <trans-unit id="88b7053411bf3b3b073ba4f231a1da2711e2f38c" translate="yes" xml:space="preserve">
          <source>The number of threads in the process.</source>
          <target state="translated">프로세스의 스레드 수입니다.</target>
        </trans-unit>
        <trans-unit id="7d720d63753916813fff9649510319aa14c02852" translate="yes" xml:space="preserve">
          <source>The number of vector headers allocated from the vector blocks.</source>
          <target state="translated">벡터 블록에서 할당 된 벡터 헤더의 수입니다.</target>
        </trans-unit>
        <trans-unit id="59b6b2c7dabce2307e6e799dfef671c14314174a" translate="yes" xml:space="preserve">
          <source>The numeric prefix argument. (Note that this &amp;lsquo;</source>
          <target state="translated">숫자 접두사 인수입니다. (이 '</target>
        </trans-unit>
        <trans-unit id="839e8e25e1178c7a8e748322d0c3fe4ba4cb103f" translate="yes" xml:space="preserve">
          <source>The numeric prefix argument; but if there is no prefix argument, read a number as with</source>
          <target state="translated">숫자 접두사 인수입니다. 그러나 접두사 인수가 없으면 다음과 같이 숫자를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="439b92119e69deb37b60614763a2c3dea4cdbbe6" translate="yes" xml:space="preserve">
          <source>The numerical priority of the process.</source>
          <target state="translated">프로세스의 숫자 우선 순위입니다.</target>
        </trans-unit>
        <trans-unit id="7fe81b17fc17a93e95e511a73b78731b8a8de04d" translate="yes" xml:space="preserve">
          <source>The numerical process group ID of the foreground process group that uses the process&amp;rsquo;s terminal.</source>
          <target state="translated">프로세스의 터미널을 사용하는 포 그라운드 프로세스 그룹의 숫자 프로세스 그룹 ID입니다.</target>
        </trans-unit>
        <trans-unit id="6fa1cb69c8ffa6967bb6548d178d71e54c8286e1" translate="yes" xml:space="preserve">
          <source>The object &lt;code&gt;nil&lt;/code&gt;, in addition to its other meanings, may be used as a stream. It stands for the value of the variable &lt;code&gt;standard-input&lt;/code&gt; or &lt;code&gt;standard-output&lt;/code&gt;. Also, the object &lt;code&gt;t&lt;/code&gt; as a stream specifies input using the minibuffer (see &lt;a href=&quot;minibuffers#Minibuffers&quot;&gt;Minibuffers&lt;/a&gt;) or output in the echo area (see &lt;a href=&quot;the-echo-area#The-Echo-Area&quot;&gt;The Echo Area&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; 객체 는 다른 의미와 함께 스트림으로 사용될 수 있습니다. 가변 &lt;code&gt;standard-input&lt;/code&gt; 또는 &lt;code&gt;standard-output&lt;/code&gt; 값을 나타냅니다 . 또한 객체 &lt;code&gt;t&lt;/code&gt; 는 스트림으로 &lt;a href=&quot;minibuffers#Minibuffers&quot;&gt;미니 버퍼&lt;/a&gt; ( Minibuffers 참조 )를 사용하여 입력을 지정 하거나 에코 영역 ( &lt;a href=&quot;the-echo-area#The-Echo-Area&quot;&gt;Echo 영역&lt;/a&gt; 참조)에 출력을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="39f7982b68fb4ab2fb51b7f5f14923219a3d96cd" translate="yes" xml:space="preserve">
          <source>The object &lt;var&gt;name&lt;/var&gt; is a character (an integer) identifying the register.</source>
          <target state="translated">개체 &lt;var&gt;name&lt;/var&gt; 은 레지스터를 식별하는 문자 (정수)입니다.</target>
        </trans-unit>
        <trans-unit id="6833fa0e8edf6ce4aefb60918006191561783d76" translate="yes" xml:space="preserve">
          <source>The objects returned by &lt;code&gt;current-window-configuration&lt;/code&gt; die together with the Emacs process. In order to store a window configuration on disk and read it back in another Emacs session, you can use the functions described next. These functions are also useful to clone the state of a frame into an arbitrary live window (&lt;code&gt;set-window-configuration&lt;/code&gt; effectively clones the windows of a frame into the root window of that very frame only).</source>
          <target state="translated">&lt;code&gt;current-window-configuration&lt;/code&gt; 의해 반환 된 객체 는 Emacs 프로세스와 함께 죽습니다. 윈도우 구성을 디스크에 저장하고 다른 Emacs 세션에서 다시 읽으려면 다음에 설명하는 기능을 사용할 수 있습니다. 이러한 함수는 프레임의 상태를 임의의 라이브 창으로 복제하는데도 유용합니다 ( &lt;code&gt;set-window-configuration&lt;/code&gt; 은 프레임의 창을 해당 프레임의 루트 창에만 효과적으로 복제합니다).</target>
        </trans-unit>
        <trans-unit id="72b9bbaab48ff0495bbabbd0f0bb821e6641bf93" translate="yes" xml:space="preserve">
          <source>The offset in pixels from the</source>
          <target state="translated">픽셀 단위의 오프셋</target>
        </trans-unit>
        <trans-unit id="ad4a9f69cf841ef935ee2cfa1f4bc790f26c9421" translate="yes" xml:space="preserve">
          <source>The operating system groups files into directories. To specify a file, you must specify the directory and the file&amp;rsquo;s name within that directory. Therefore, Emacs considers a file name as having two main parts: the &lt;em&gt;directory name&lt;/em&gt; part, and the &lt;em&gt;nondirectory&lt;/em&gt; part (or &lt;em&gt;file name within the directory&lt;/em&gt;). Either part may be empty. Concatenating these two parts reproduces the original file name.</source>
          <target state="translated">운영 체제는 파일을 디렉토리로 그룹화합니다. 파일을 지정하려면 디렉토리와 해당 디렉토리 내의 파일 이름을 지정해야합니다. : 따라서, 이맥스는 두 개의 주요 부분으로 가진 같은 파일 이름을 고려 &lt;em&gt;디렉토리 이름&lt;/em&gt; 부분과 &lt;em&gt;비 디렉토리&lt;/em&gt; (또는 일부 &lt;em&gt;디렉토리 내에서 파일 이름을&lt;/em&gt; ). 두 부분 모두 비어있을 수 있습니다. 이 두 부분을 연결하면 원래 파일 이름이 재현됩니다.</target>
        </trans-unit>
        <trans-unit id="97b655f463790a01acf5417028d665f4f17aa3ca" translate="yes" xml:space="preserve">
          <source>The operation for which certain handlers are presently inhibited.</source>
          <target state="translated">특정 핸들러가 현재 금지 된 작업입니다.</target>
        </trans-unit>
        <trans-unit id="a54beb7452d09412de65a317f1da762f7220f206" translate="yes" xml:space="preserve">
          <source>The operation of inserting text in a buffer also calls the functions listed in the &lt;code&gt;insert-in-front-hooks&lt;/code&gt; property of the following character and in the &lt;code&gt;insert-behind-hooks&lt;/code&gt; property of the preceding character. These functions receive two arguments, the beginning and end of the inserted text. The functions are called &lt;em&gt;after&lt;/em&gt; the actual insertion takes place.</source>
          <target state="translated">버퍼에 텍스트를 삽입하는 작업은 다음 문자 의 &lt;code&gt;insert-in-front-hooks&lt;/code&gt; 속성과 선행 문자 의 &lt;code&gt;insert-behind-hooks&lt;/code&gt; 속성에 나열된 함수도 호출합니다 . 이 함수는 삽입 된 텍스트의 시작과 끝이라는 두 개의 인수를받습니다. 함수는 실제 삽입이 발생한 &lt;em&gt;후에&lt;/em&gt; 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="0102d351953df3a2b1f375d80803fca9ebb0a776" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;resize-mini-windows&lt;/code&gt; does not affect the behavior of minibuffer-only frames (see &lt;a href=&quot;frame-layout#Frame-Layout&quot;&gt;Frame Layout&lt;/a&gt;). The following option allows to automatically resize such frames as well.</source>
          <target state="translated">&lt;code&gt;resize-mini-windows&lt;/code&gt; 옵션 은 미니 버퍼 전용 프레임의 동작에 영향을주지 않습니다 ( &lt;a href=&quot;frame-layout#Frame-Layout&quot;&gt;프레임 레이아웃&lt;/a&gt; 참조 ). 다음 옵션을 사용하면 이러한 프레임의 크기도 자동으로 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab3586d91a06c5d8405e148f25236777a77f39af" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;switch-to-prev-buffer-skip&lt;/code&gt; and the &lt;code&gt;buffer-predicate&lt;/code&gt; (see &lt;a href=&quot;buffer-parameters#Buffer-Parameters&quot;&gt;Buffer Parameters&lt;/a&gt;) of &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s frame affect this command as they do for &lt;code&gt;switch-to-prev-buffer&lt;/code&gt;.</source>
          <target state="translated">옵션 &lt;code&gt;switch-to-prev-buffer-skip&lt;/code&gt; 와 &lt;code&gt;buffer-predicate&lt;/code&gt; (참조 &lt;a href=&quot;buffer-parameters#Buffer-Parameters&quot;&gt;버퍼 매개 변수&lt;/a&gt; 의) &lt;var&gt;window&lt;/var&gt; 그들이 할이 명령에 영향을 미칠의 프레임을 &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c4c6688ae5450a1940363973e63c9245b847575d" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;switch-to-prev-buffer-skip&lt;/code&gt; described below can be used to inhibit switching to certain buffers, for example, to those already shown in another window. Also, if &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s frame has a &lt;code&gt;buffer-predicate&lt;/code&gt; parameter (see &lt;a href=&quot;buffer-parameters#Buffer-Parameters&quot;&gt;Buffer Parameters&lt;/a&gt;), that predicate may inhibit switching to certain buffers.</source>
          <target state="translated">아래에 설명 된 &lt;code&gt;switch-to-prev-buffer-skip&lt;/code&gt; 옵션 은 특정 버퍼로의 전환을 금지하는 데 사용할 수 있습니다 (예 : 다른 창에 이미 표시된 버퍼로의 전환). 또한 &lt;var&gt;window&lt;/var&gt; 프레임에 &lt;code&gt;buffer-predicate&lt;/code&gt; 매개 변수 ( &lt;a href=&quot;buffer-parameters#Buffer-Parameters&quot;&gt;버퍼 매개 변수&lt;/a&gt; 참조 )가있는 경우 해당 조건자는 특정 버퍼로의 전환을 금지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="835de90b506ab91ee5ca88e6c356759c82274cd9" translate="yes" xml:space="preserve">
          <source>The optional &lt;var&gt;form&lt;/var&gt; argument specifies the timestamp form to be returned. If &lt;var&gt;form&lt;/var&gt; is the symbol &lt;code&gt;integer&lt;/code&gt;, this function returns an integer count of seconds. If &lt;var&gt;form&lt;/var&gt; is a positive integer, it specifies a clock frequency and this function returns an integer-pair timestamp &lt;code&gt;(&lt;var&gt;ticks&lt;/var&gt;
. &lt;var&gt;form&lt;/var&gt;)&lt;/code&gt;.&lt;a href=&quot;#FOOT25&quot; name=&quot;DOCF25&quot;&gt;&lt;sup&gt;25&lt;/sup&gt;&lt;/a&gt; If &lt;var&gt;form&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;, this function treats it as a positive integer suitable for representing the timestamp; for example, it is treated as 1000000000 if &lt;var&gt;time&lt;/var&gt; is nil and the platform timestamp has nanosecond resolution. If &lt;var&gt;form&lt;/var&gt; is &lt;code&gt;list&lt;/code&gt;, this function returns an integer list &lt;code&gt;(&lt;var&gt;high&lt;/var&gt; &lt;var&gt;low&lt;/var&gt; &lt;var&gt;micro&lt;/var&gt; &lt;var&gt;pico&lt;/var&gt;)&lt;/code&gt;. Although an omitted or &lt;code&gt;nil&lt;/code&gt;&lt;var&gt;form&lt;/var&gt; currently acts like &lt;code&gt;list&lt;/code&gt;, this is planned to change in a future Emacs version, so callers requiring list timestamps should pass &lt;code&gt;list&lt;/code&gt; explicitly.</source>
          <target state="translated">선택적 &lt;var&gt;form&lt;/var&gt; 인수는 반환 될 타임 스탬프 양식을 지정합니다. 경우 &lt;var&gt;form&lt;/var&gt; 심볼 인 &lt;code&gt;integer&lt;/code&gt; ,이 기능은 초 정수의 수를 반환합니다. 경우 &lt;var&gt;form&lt;/var&gt; 양의 정수이고, 이것은 클록 주파수를 지정하고,이 함수는 정수 쌍 소인 반환 &lt;code&gt;(&lt;var&gt;ticks&lt;/var&gt; . &lt;var&gt;form&lt;/var&gt;)&lt;/code&gt; . &lt;a href=&quot;#FOOT25&quot; name=&quot;DOCF25&quot;&gt;&lt;sup&gt;25&lt;/sup&gt;&lt;/a&gt; 않으면 &lt;var&gt;form&lt;/var&gt; 이며 &lt;code&gt;t&lt;/code&gt; 는 타임 스탬프를 표시하기에 적합한 양의 정수로서 취급이 기능을; 예를 들어 &lt;var&gt;time&lt;/var&gt; 이 nil이고 플랫폼 타임 스탬프에 나노초 해상도가있는 경우 1000000000으로 처리됩니다 . &lt;var&gt;form&lt;/var&gt; 이 &lt;code&gt;list&lt;/code&gt; 경우,이 함수는 정수 목록 &lt;code&gt;(&lt;var&gt;high&lt;/var&gt; &lt;var&gt;low&lt;/var&gt; &lt;var&gt;micro&lt;/var&gt; &lt;var&gt;pico&lt;/var&gt;)&lt;/code&gt; 반환합니다 . 생략되거나 &lt;code&gt;nil&lt;/code&gt; &lt;var&gt;form&lt;/var&gt; 현재 &lt;code&gt;list&lt;/code&gt; 처럼 작동하지만 , 이는 향후 Emacs 버전에서 변경 될 예정이므로 목록 타임 스탬프가 필요한 호출자는 &lt;code&gt;list&lt;/code&gt; 명시 적으로 전달해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="173acab42d67698663274d178deb55ac822fd58b" translate="yes" xml:space="preserve">
          <source>The optional &lt;var&gt;function&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, is a function to call with no arguments, to get the user&amp;rsquo;s attention.</source>
          <target state="translated">선택적 &lt;var&gt;function&lt;/var&gt; 는 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 사용자의주의를 끌기 위해 인수없이 호출하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="426453a518362f581ab8e263e39b1b78287360b0" translate="yes" xml:space="preserve">
          <source>The optional &lt;var&gt;pred&lt;/var&gt; argument provides a predicate that controls which buffers to ask about (or to save silently if &lt;var&gt;save-silently-p&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;). If &lt;var&gt;pred&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, that means to use the value of &lt;code&gt;save-some-buffers-default-predicate&lt;/code&gt; instead of &lt;var&gt;pred&lt;/var&gt;. If the result is &lt;code&gt;nil&lt;/code&gt;, it means ask only about file-visiting buffers. If it is &lt;code&gt;t&lt;/code&gt;, that means also offer to save certain other non-file buffers&amp;mdash;those that have a non-&lt;code&gt;nil&lt;/code&gt; buffer-local value of &lt;code&gt;buffer-offer-save&lt;/code&gt; (see &lt;a href=&quot;killing-buffers#Killing-Buffers&quot;&gt;Killing Buffers&lt;/a&gt;). A user who says &amp;lsquo;</source>
          <target state="translated">선택적 &lt;var&gt;pred&lt;/var&gt; 인수는 요청할 버퍼를 제어하는 ​​술어를 제공합니다 (또는 &lt;var&gt;save-silently-p&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 자동 저장 ). 경우 &lt;var&gt;pred&lt;/var&gt; IS &lt;code&gt;nil&lt;/code&gt; , 수단의 값을 사용하는 것을 &lt;code&gt;save-some-buffers-default-predicate&lt;/code&gt; 대신 &lt;var&gt;pred&lt;/var&gt; . 결과가 &lt;code&gt;nil&lt;/code&gt; 이면 파일 방문 버퍼에 대해서만 묻는 것을 의미합니다. 만약 그것이 &lt;code&gt;t&lt;/code&gt; 이면, 그것은 또한 특정 다른 비 파일 버퍼를 저장하도록 제안한다는 것을 의미합니다. &lt;code&gt;buffer-offer-save&lt;/code&gt; 의 &lt;code&gt;nil&lt;/code&gt; 이 아닌 버퍼-로컬 값을 가진 것들입니다 ( &lt;a href=&quot;killing-buffers#Killing-Buffers&quot;&gt;버퍼 죽이기&lt;/a&gt; 참조 ). '라고 말하는 사용자</target>
        </trans-unit>
        <trans-unit id="3b490b732241cae65bd40b66849ce93f50354a12" translate="yes" xml:space="preserve">
          <source>The optional &lt;var&gt;qualifier&lt;/var&gt; allows combining several applicable methods. If it is not present, the defined method is a &lt;em&gt;primary&lt;/em&gt; method, responsible for providing the primary implementation of the generic function for the specialized arguments. You can also define &lt;em&gt;auxiliary methods&lt;/em&gt;, by using one of the following values as &lt;var&gt;qualifier&lt;/var&gt;:</source>
          <target state="translated">선택적 &lt;var&gt;qualifier&lt;/var&gt; 사용하면 여러 적용 가능한 방법을 결합 할 수 있습니다. 존재하지 않는 경우, 정의 된 메서드는 &lt;em&gt;기본&lt;/em&gt; 메서드이며 특수 인수에 대한 일반 함수의 기본 구현을 제공합니다. 다음 값 중 하나를 &lt;var&gt;qualifier&lt;/var&gt; 로 사용하여 &lt;em&gt;보조 메서드를&lt;/em&gt; 정의 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7e8b24c5a3bacf003c936b526cc2b8bc5211832b" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;accept-default-p&lt;/var&gt; determines whether a coding system selected without user interaction is acceptable. If it&amp;rsquo;s omitted or &lt;code&gt;nil&lt;/code&gt;, such a silent selection is always acceptable. If it is non-&lt;code&gt;nil&lt;/code&gt;, it should be a function; &lt;code&gt;select-safe-coding-system&lt;/code&gt; calls this function with one argument, the base coding system of the selected coding system. If the function returns &lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;select-safe-coding-system&lt;/code&gt; rejects the silently selected coding system, and asks the user to select a coding system from a list of possible candidates.</source>
          <target state="translated">선택적 인수 &lt;var&gt;accept-default-p&lt;/var&gt; 는 사용자 상호 작용없이 선택한 코딩 시스템이 허용되는지 여부를 결정합니다. 생략되거나 &lt;code&gt;nil&lt;/code&gt; 이면 이러한 자동 선택은 항상 허용됩니다. 이 아닌 경우, &lt;code&gt;nil&lt;/code&gt; , 그것은 함수이어야한다; &lt;code&gt;select-safe-coding-system&lt;/code&gt; 은 선택된 코딩 시스템의 기본 코딩 시스템 인 하나의 인수로이 함수를 호출합니다. 함수가 &lt;code&gt;nil&lt;/code&gt; 을 반환 하면 &lt;code&gt;select-safe-coding-system&lt;/code&gt; 은 자동으로 선택된 코딩 시스템을 거부하고 사용자에게 가능한 후보 목록에서 코딩 시스템을 선택하도록 요청합니다.</target>
        </trans-unit>
        <trans-unit id="e961ebb3cc87375ff53fb5dbd5c797ff74355be5" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;access-type&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, should specify the kind of access that will trigger obsolescence warnings; it can be either &lt;code&gt;get&lt;/code&gt; or &lt;code&gt;set&lt;/code&gt;.</source>
          <target state="translated">선택적 인수 &lt;var&gt;access-type&lt;/var&gt; 은 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 노후화 경고를 트리거 할 액세스 종류를 지정해야합니다. &lt;code&gt;get&lt;/code&gt; 또는 &lt;code&gt;set&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="18e8faa626ed3c723b0d4b24ea36af13079f989a" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;action&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, should normally be a display action (described above). &lt;code&gt;display-buffer&lt;/code&gt; builds a list of action functions and an action alist, by consolidating display actions from the following sources (in order of their precedence, from highest to lowest):</source>
          <target state="translated">선택적 인수 &lt;var&gt;action&lt;/var&gt; 은 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 일반적으로 표시 작업이어야합니다 (위에서 설명). &lt;code&gt;display-buffer&lt;/code&gt; 는 다음 소스의 표시 작업을 통합하여 작업 함수 목록과 작업 목록을 작성합니다 (우선 순위 순으로 높은 순서대로).</target>
        </trans-unit>
        <trans-unit id="86a332db454bd3dbba8b146d609ae20fa7e68ddc" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;add&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, specifies how to add &lt;var&gt;font-spec&lt;/var&gt; to the font specifications previously set. If it is &lt;code&gt;prepend&lt;/code&gt;, &lt;var&gt;font-spec&lt;/var&gt; is prepended. If it is &lt;code&gt;append&lt;/code&gt;, &lt;var&gt;font-spec&lt;/var&gt; is appended. By default, &lt;var&gt;font-spec&lt;/var&gt; overrides the previous settings.</source>
          <target state="translated">선택적 인수 &lt;var&gt;add&lt;/var&gt; 는 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 이전에 설정 한 글꼴 사양에 글꼴 &lt;var&gt;font-spec&lt;/var&gt; 을 추가하는 방법을 지정합니다 . 이 경우 &lt;code&gt;prepend&lt;/code&gt; , &lt;var&gt;font-spec&lt;/var&gt; 앞에 추가됩니다. 이 경우 &lt;code&gt;append&lt;/code&gt; , &lt;var&gt;font-spec&lt;/var&gt; 부가된다. 기본적으로 &lt;var&gt;font-spec&lt;/var&gt; 은 이전 설정을 재정의합니다.</target>
        </trans-unit>
        <trans-unit id="f8a3ae8e924fd8f4d27674f1685f4ee6a3fbe53e" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;all-frames&lt;/var&gt; has the same meaning as in &lt;code&gt;next-window&lt;/code&gt;, like a &lt;code&gt;nil&lt;/code&gt;&lt;var&gt;minibuf&lt;/var&gt; argument to &lt;code&gt;next-window&lt;/code&gt;.</source>
          <target state="translated">옵션 인수 &lt;var&gt;all-frames&lt;/var&gt; 에서와 같은 의미가 &lt;code&gt;next-window&lt;/code&gt; 유사한, &lt;code&gt;nil&lt;/code&gt; &lt;var&gt;minibuf&lt;/var&gt; 의 에 인수 &lt;code&gt;next-window&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="202962f0de53dff02d10a00270753bbfa1f06e86" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;all-frames&lt;/var&gt; specifies which frames to consider:</source>
          <target state="translated">선택적 인수 &lt;var&gt;all-frames&lt;/var&gt; frames는 고려할 프레임을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="bb40d66cb55d279a86899a88dfb077d4f8e79fbc" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;base-url&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, should be a string specifying the base URL for relative URLs occurring in links.</source>
          <target state="translated">선택적 인수 &lt;var&gt;base-url&lt;/var&gt; 은 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 링크에서 발생하는 상대 URL에 대한 기본 URL을 지정하는 문자열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="6a1907330d9a397ccfad9b3e354542f50e48a6fb" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;bury-or-kill&lt;/var&gt; specifies how to deal with &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s buffer. The following values are handled:</source>
          <target state="translated">선택적 인수 &lt;var&gt;bury-or-kill&lt;/var&gt; 은 &lt;var&gt;window&lt;/var&gt; 버퍼 를 처리하는 방법을 지정합니다 . 다음 값이 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="2049134810f7e761207b9b8b3bd49725d3167d1d" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;confirm&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, says to read the password twice and insist it must be the same both times. If it isn&amp;rsquo;t the same, the user has to type it over and over until the last two times match.</source>
          <target state="translated">선택적 인수 &lt;var&gt;confirm&lt;/var&gt; 은 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 암호를 두 번 읽고 두 번 모두 동일해야한다고 주장합니다. 동일하지 않은 경우 사용자는 마지막 두 번 일치 할 때까지 반복해서 입력해야합니다.</target>
        </trans-unit>
        <trans-unit id="7bc5835047d79ebfcafd196072cb522b7ad940af" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;contextual&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, forces Font Lock mode to always refontify a syntactically relevant part of the buffer, and not just the modified lines. This argument can usually be omitted.</source>
          <target state="translated">선택적 인수 &lt;var&gt;contextual&lt;/var&gt; 은 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 글꼴 잠금 모드가 수정 된 줄뿐 아니라 항상 버퍼의 구문 관련 부분을 다시 글꼴로 변경하도록합니다. 이 인수는 일반적으로 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="580eb5a9bd0d61ea92cc5b8878cb5564112b1db4" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;count&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, specifies a maximum number of rectangles to return. This means that the return value is a list of triples specifying rectangles with the largest rectangle first. &lt;var&gt;count&lt;/var&gt; can be also a cons cell whose car specifies the number of rectangles to return and whose &lt;small&gt;CDR&lt;/small&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, states that all rectangles returned must be disjoint.</source>
          <target state="translated">선택적 인수 &lt;var&gt;count&lt;/var&gt; 는 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 반환 할 최대 사각형 수를 지정합니다. 즉, 반환 값은 가장 큰 사각형이 먼저있는 사각형을 지정하는 트리플 목록입니다. &lt;var&gt;count&lt;/var&gt; 는 car가 반환 할 사각형의 수를 지정하고 &lt;small&gt;CDR이 &lt;/small&gt; &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 반환 된 모든 사각형이 분리되어야 함을 나타내는 cons 셀일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ebdbb0e5fb0f2b384549756b4989936faa9a770" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;cur-col&lt;/var&gt; specifies the current column when the function is called. This is the window-relative horizontal coordinate of point, measured in units of font width of the frame&amp;rsquo;s default face. Providing it speeds up the function, especially in very long lines, because the function doesn&amp;rsquo;t have to go back in the buffer in order to determine the current column. Note that &lt;var&gt;cur-col&lt;/var&gt; is also counted from the visual start of the line.</source>
          <target state="translated">선택적 인수 &lt;var&gt;cur-col&lt;/var&gt; 은 함수가 호출 될 때 현재 열을 지정합니다. 프레임의 기본면의 글꼴 너비 단위로 측정 된 창 기준 포인트의 수평 좌표입니다. 이를 제공하면 특히 매우 긴 줄에서 함수의 속도가 빨라집니다. 현재 열을 확인하기 위해 함수가 버퍼로 돌아갈 필요가 없기 때문입니다. 참고 &lt;var&gt;cur-col&lt;/var&gt; 또한 광고의 시각적 처음부터 계산된다.</target>
        </trans-unit>
        <trans-unit id="b5a3875cde45d622d71332d1342451631df66196" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;default&lt;/var&gt; is used as in &lt;code&gt;read-from-minibuffer&lt;/code&gt;, except that, if non-&lt;code&gt;nil&lt;/code&gt;, it also specifies a default value to return if the user enters null input. As in &lt;code&gt;read-from-minibuffer&lt;/code&gt; it should be a string, a list of strings, or &lt;code&gt;nil&lt;/code&gt;, which is equivalent to an empty string. When &lt;var&gt;default&lt;/var&gt; is a string, that string is the default value. When it is a list of strings, the first string is the default value. (All these strings are available to the user in the &amp;ldquo;future minibuffer history&amp;rdquo;.)</source>
          <target state="translated">선택적 인수 &lt;var&gt;default&lt;/var&gt; 는 &lt;code&gt;read-from-minibuffer&lt;/code&gt; 에서와 같이 사용됩니다 . 단, &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 사용자가 null 입력을 입력하면 반환 할 기본값도 지정합니다. &lt;code&gt;read-from-minibuffer&lt;/code&gt; 에서 읽기와 마찬가지로 문자열, 문자열 목록 또는 &lt;code&gt;nil&lt;/code&gt; 이어야하며 이는 빈 문자열과 동일합니다. 시 &lt;var&gt;default&lt;/var&gt; 문자열이며, 해당 문자열이 기본값입니다. 문자열 목록 인 경우 첫 번째 문자열이 기본값입니다. (이 모든 문자열은 &quot;미래 미니 버퍼 히스토리&quot;에서 사용자가 사용할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="a8b8f42a687e321f80ab76cd3bccd5897a600a30" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;default&lt;/var&gt; specifies the default password to return if the user enters empty input. If &lt;var&gt;default&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, then &lt;code&gt;read-passwd&lt;/code&gt; returns the null string in that case.</source>
          <target state="translated">선택적 인수 &lt;var&gt;default&lt;/var&gt; 는 사용자가 빈 입력을 입력하는 경우 반환 할 기본 암호를 지정합니다. 경우 &lt;var&gt;default&lt;/var&gt; 이다 &lt;code&gt;nil&lt;/code&gt; , 다음 &lt;code&gt;read-passwd&lt;/code&gt; 경우에 널 (null) 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0048e481ce17eb199983c7400eaac1a428a4cdd4" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;defaults&lt;/var&gt; controls the default value to return if the user enters null input, and should be one of: a string; &lt;code&gt;nil&lt;/code&gt;, which is equivalent to an empty string; a list of strings; or a symbol.</source>
          <target state="translated">선택적 인수 &lt;var&gt;defaults&lt;/var&gt; 는 사용자가 null 입력을 입력하는 경우 반환 할 기본값을 제어하며 다음 중 하나 여야합니다. 문자열; &lt;code&gt;nil&lt;/code&gt; , 이는 빈 문자열과 동일합니다. 문자열 목록; 또는 기호.</target>
        </trans-unit>
        <trans-unit id="228f1c49688198d5cc5f85c1fed83e79ddfe5a7f" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;display&lt;/var&gt; in these functions specifies which display to ask the question about. It can be a display name, a frame (which designates the display that frame is on), or &lt;code&gt;nil&lt;/code&gt; (which refers to the selected frame&amp;rsquo;s display, see &lt;a href=&quot;input-focus#Input-Focus&quot;&gt;Input Focus&lt;/a&gt;).</source>
          <target state="translated">이러한 함수 의 선택적 인수 &lt;var&gt;display&lt;/var&gt; 는 질문 할 디스플레이를 지정합니다. 디스플레이 이름, 프레임 (프레임이 켜져있는 디스플레이를 지정 함) 또는 &lt;code&gt;nil&lt;/code&gt; (선택한 프레임의 디스플레이를 참조 함, &lt;a href=&quot;input-focus#Input-Focus&quot;&gt;입력 포커스&lt;/a&gt; 참조 ) 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ecafec37f62287ed8dd3cb905ab5b45b69aeeb0b" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;frame&lt;/var&gt; specifies which frames to operate on:</source>
          <target state="translated">선택적 인수 &lt;var&gt;frame&lt;/var&gt; 은 작동 할 프레임을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="26bbce4e0ce6d9c586e1c1839883be544a4991a7" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;frame&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, specifies the frame on which the fonts are to be displayed. The optional argument &lt;var&gt;num&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, should be an integer that specifies the maximum length of the returned list. The optional argument &lt;var&gt;prefer&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, should be another font spec, which is used to control the order of the returned list; the returned font entities are sorted in order of decreasing closeness to that font spec.</source>
          <target state="translated">선택적 인수 인 &lt;var&gt;frame&lt;/var&gt; 은 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 글꼴이 표시 될 프레임을 지정합니다. 선택적 인수 &lt;var&gt;num&lt;/var&gt; 은 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 반환 된 목록의 최대 길이를 지정하는 정수 여야합니다. 선택적 인수 &lt;var&gt;prefer&lt;/var&gt; 는 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 반환 된 목록의 순서를 제어하는 ​​데 사용되는 다른 글꼴 사양이어야합니다. 반환 된 글꼴 엔터티는 해당 글꼴 사양에 대한 근접성이 감소하는 순서대로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="160ff97d48ba4a8dfa3b003d791595b0262367a7" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;frame&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, specifies which frames to check when deciding whether the buffer is already displayed. It is equivalent to adding an element &lt;code&gt;(reusable-frames&amp;nbsp;.&amp;nbsp;&lt;var&gt;frame&lt;/var&gt;)&lt;/code&gt; to the action alist of &lt;var&gt;action&lt;/var&gt; (see &lt;a href=&quot;buffer-display-action-alists#Buffer-Display-Action-Alists&quot;&gt;Buffer Display Action Alists&lt;/a&gt;). The &lt;var&gt;frame&lt;/var&gt; argument is provided for compatibility reasons, Lisp programs should not use it.</source>
          <target state="translated">선택적 인수 인 &lt;var&gt;frame&lt;/var&gt; 은 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 버퍼가 이미 표시되었는지 여부를 결정할 때 확인할 프레임을 지정합니다. 이것은 원소 첨가에 상당 &lt;code&gt;(reusable-frames&amp;nbsp;.&amp;nbsp;&lt;var&gt;frame&lt;/var&gt;)&lt;/code&gt; 의 작용에 alist &lt;var&gt;action&lt;/var&gt; (참조 &lt;a href=&quot;buffer-display-action-alists#Buffer-Display-Action-Alists&quot;&gt;버퍼 디스플레이 동작을 Alists&lt;/a&gt; ). &lt;var&gt;frame&lt;/var&gt; 인수가 호환성을 위해 제공되며, 리스프 프로그램을 사용하지 말아야합니다.</target>
        </trans-unit>
        <trans-unit id="50b9dbdcad227dd99d40dacb6820fdfcb31ad949" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;from&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, specifies the first text position to consider, and defaults to the minimum accessible position of the buffer. If &lt;var&gt;from&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;, it stands for the minimum accessible position that is not a newline character. The optional argument &lt;var&gt;to&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, specifies the last text position to consider, and defaults to the maximum accessible position of the buffer. If &lt;var&gt;to&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;, it stands for the maximum accessible position that is not a newline character.</source>
          <target state="translated">의 선택적 인수 &lt;var&gt;from&lt;/var&gt; &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 고려할 첫 번째 텍스트 위치를 지정하고 기본적으로 버퍼의 최소 액세스 가능 위치로 설정됩니다. 경우 &lt;var&gt;from&lt;/var&gt; 입니다 &lt;code&gt;t&lt;/code&gt; 는 , 그것은 개행 문자가 아닌 최소 접근 위치를 의미합니다. 에 대한 선택적 인수 &lt;var&gt;to&lt;/var&gt; &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 고려할 마지막 텍스트 위치를 지정하고 기본적으로 버퍼의 최대 액세스 가능 위치로 설정됩니다. 경우 &lt;var&gt;to&lt;/var&gt; 이다 &lt;code&gt;t&lt;/code&gt; 는 , 그것은 개행 문자가 아닌 최대 접근 가능한 위치를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="48d8b7e116733be79108fa56696b0ae152c9cd92" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;history&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, is a symbol specifying a minibuffer history list to use (see &lt;a href=&quot;minibuffer-history#Minibuffer-History&quot;&gt;Minibuffer History&lt;/a&gt;). If it is omitted or &lt;code&gt;nil&lt;/code&gt;, the history list defaults to &lt;code&gt;regexp-history&lt;/code&gt;.</source>
          <target state="translated">선택적 인수 &lt;var&gt;history&lt;/var&gt; 는 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 사용할 &lt;a href=&quot;minibuffer-history#Minibuffer-History&quot;&gt;미니 버퍼 기록&lt;/a&gt; 목록을 지정하는 기호입니다 ( Minibuffer History 참조 ). 생략되거나 &lt;code&gt;nil&lt;/code&gt; 이면 히스토리 목록의 기본값은 &lt;code&gt;regexp-history&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="54b2555eb4d6971581a755b86e550d7f706a4369" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;ignore&lt;/var&gt; has the same meaning as for the function &lt;code&gt;window-resizable&lt;/code&gt; above.</source>
          <target state="translated">선택적 인수 &lt;var&gt;ignore&lt;/var&gt; 는 위의 &lt;code&gt;window-resizable&lt;/code&gt; 기능과 동일한 의미를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="6bdfa63738d1ccee9b5808f3f8c9f1ebe07b8e9b" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;ignore&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, means ignore restrictions imposed by fixed size windows, &lt;code&gt;window-min-height&lt;/code&gt; or &lt;code&gt;window-min-width&lt;/code&gt; settings. If &lt;var&gt;ignore&lt;/var&gt; equals &lt;code&gt;safe&lt;/code&gt;, live windows may get as small as &lt;code&gt;window-safe-min-height&lt;/code&gt; lines and &lt;code&gt;window-safe-min-width&lt;/code&gt; columns. If &lt;var&gt;ignore&lt;/var&gt; is a window, ignore restrictions for that window only. Any other non-&lt;code&gt;nil&lt;/code&gt; value means ignore all of the above restrictions for all windows.</source>
          <target state="translated">선택적 인수 &lt;var&gt;ignore&lt;/var&gt; 는 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 고정 크기 창, &lt;code&gt;window-min-height&lt;/code&gt; 또는 &lt;code&gt;window-min-width&lt;/code&gt; 설정 에 의해 부과 된 제한을 무시 함을 의미 합니다. 경우 &lt;var&gt;ignore&lt;/var&gt; 같음을 &lt;code&gt;safe&lt;/code&gt; , 라이브 창을 작게받을 수 있습니다 &lt;code&gt;window-safe-min-height&lt;/code&gt; 라인과 &lt;code&gt;window-safe-min-width&lt;/code&gt; 열. &lt;var&gt;ignore&lt;/var&gt; 가 창인 경우 해당 창에 대한 제한 만 무시합니다. &lt;code&gt;nil&lt;/code&gt; 이 아닌 다른 값은 모든 창에 대해 위의 모든 제한을 무시 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="f03394985cfefcfbe4bccbc2c2b7c937f24aa8ff" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;inverse&lt;/var&gt;, if &lt;code&gt;nil&lt;/code&gt;, means that the y-pixel value returned for any line specifies the distance in pixels from the left edge (body edge if &lt;var&gt;body&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;) of &lt;var&gt;window&lt;/var&gt; to the right edge of the last glyph of that line. &lt;var&gt;inverse&lt;/var&gt; non-&lt;code&gt;nil&lt;/code&gt; means that the y-pixel value returned for any line specifies the distance in pixels from the right edge of the last glyph of that line to the right edge (body edge if &lt;var&gt;body&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;) of &lt;var&gt;window&lt;/var&gt;. This is useful for determining the amount of slack space at the end of each line.</source>
          <target state="translated">선택적 인수 &lt;var&gt;inverse&lt;/var&gt; 는 &lt;code&gt;nil&lt;/code&gt; 인 경우 모든 행에 대해 반환 된 y- 픽셀 값 이 &lt;var&gt;window&lt;/var&gt; 왼쪽 가장자리 ( &lt;var&gt;body&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 body 가장자리)에서 마지막 글리프의 오른쪽 가장자리 까지의 거리를 픽셀 단위로 지정 함 을 의미합니다. 선. &lt;var&gt;inverse&lt;/var&gt; non- &lt;code&gt;nil&lt;/code&gt; 은 어떤 라인에 대해 반환 된 y- 픽셀 값이 해당 라인의 마지막 글리프의 오른쪽 가장자리 에서 &lt;var&gt;window&lt;/var&gt; 의 오른쪽 가장자리 ( &lt;var&gt;body&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 body 가장자리)까지의 거리를 픽셀 단위로 지정 함을 의미합니다 . 이것은 각 줄의 끝에있는 여유 공간의 양을 결정하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="36d765e78065810838fe4b4dcd7aee5e46b9c2f7" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;keymap&lt;/var&gt; specifies the keymap for the minor mode. If non-&lt;code&gt;nil&lt;/code&gt;, it should be a variable name (whose value is a keymap), a keymap, or an alist of the form</source>
          <target state="translated">선택적 인수 &lt;var&gt;keymap&lt;/var&gt; 은 부 모드에 대한 키맵을 지정합니다. &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 변수 이름 (값이 키맵), 키맵 또는 형식 목록이어야합니다.</target>
        </trans-unit>
        <trans-unit id="45c7531620e27255788236157222d029e67710a7" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;left&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt; means to return the x- and y-coordinates of the lower left corner of the leftmost character on each line. This is the value that should be used for windows that mostly display text from right to left.</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 선택적 인수 &lt;var&gt;left&lt;/var&gt; 는 각 행에서 가장 왼쪽 문자의 왼쪽 하단 모서리의 x 및 y 좌표를 반환하는 것을 의미합니다. 주로 오른쪽에서 왼쪽으로 텍스트를 표시하는 창에 사용해야하는 값입니다.</target>
        </trans-unit>
        <trans-unit id="fac44c195c8956dce4604ab79b6495b05c7787fa" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;left&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, means to return values suitable for buffers displaying right to left text. In that case, any rectangle returned is assumed to start at the left edge of &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s text area.</source>
          <target state="translated">선택적 인수 &lt;var&gt;left&lt;/var&gt; 는 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 오른쪽에서 왼쪽 텍스트를 표시하는 버퍼에 적합한 값을 반환하는 것을 의미합니다. 이 경우 반환 된 사각형은 &lt;var&gt;window&lt;/var&gt; 텍스트 영역 왼쪽 가장자리에서 시작하는 것으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="6b9c6954a4a938b6fd1e1b213483a278916b13fe" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;locale&lt;/var&gt;, a string, overrides the setting of your current locale identifier for collation. The value is system dependent; a &lt;var&gt;locale&lt;/var&gt;&lt;code&gt;&quot;en_US.UTF-8&quot;&lt;/code&gt; is applicable on POSIX systems, while it would be, e.g., &lt;code&gt;&quot;enu_USA.1252&quot;&lt;/code&gt; on MS-Windows systems.</source>
          <target state="translated">선택적 인수 &lt;var&gt;locale&lt;/var&gt; , 문자열은 데이터 정렬을위한 현재 로케일 식별자 설정을 재정의합니다. 값은 시스템에 따라 다릅니다. &lt;var&gt;locale&lt;/var&gt; &lt;code&gt;&quot;en_US.UTF-8&quot;&lt;/code&gt; 이 될 때, 예를 들어, POSIX 시스템에 적용 할 수있다 &lt;code&gt;&quot;enu_USA.1252&quot;&lt;/code&gt; MS-Windows 시스템.</target>
        </trans-unit>
        <trans-unit id="be924dbedb077a7596937c809656d8809cb7f780" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;locale&lt;/var&gt;, a string, overrides the setting of your current locale identifier for collation. The value is system dependent; a &lt;var&gt;locale&lt;/var&gt;&lt;code&gt;&quot;en_US.UTF-8&quot;&lt;/code&gt; is applicable on POSIX systems, while it would be, e.g., &lt;code&gt;&quot;enu_USA.1252&quot;&lt;/code&gt; on MS-Windows systems. The &lt;var&gt;locale&lt;/var&gt; value of &lt;code&gt;&quot;POSIX&quot;&lt;/code&gt; or &lt;code&gt;&quot;C&quot;&lt;/code&gt; lets &lt;code&gt;string-collate-lessp&lt;/code&gt; behave like &lt;code&gt;string-lessp&lt;/code&gt;:</source>
          <target state="translated">선택적 인수 &lt;var&gt;locale&lt;/var&gt; , 문자열은 데이터 정렬을위한 현재 로케일 식별자 설정을 재정의합니다. 값은 시스템에 따라 다릅니다. &lt;var&gt;locale&lt;/var&gt; &lt;code&gt;&quot;en_US.UTF-8&quot;&lt;/code&gt; 이 될 때, 예를 들어, POSIX 시스템에 적용 할 수있다 &lt;code&gt;&quot;enu_USA.1252&quot;&lt;/code&gt; MS-Windows 시스템. &lt;code&gt;&quot;POSIX&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;C&quot;&lt;/code&gt; 의 &lt;var&gt;locale&lt;/var&gt; 값을 사용하면 &lt;code&gt;string-collate-lessp&lt;/code&gt; 가 &lt;code&gt;string-lessp&lt;/code&gt; 처럼 동작 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4edaf13bc53c89e562d674d18afa431f2d97a551" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;lockname&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, specifies the file name to use for purposes of locking and unlocking, overriding &lt;var&gt;filename&lt;/var&gt; and &lt;var&gt;visit&lt;/var&gt; for that purpose.</source>
          <target state="translated">옵션 인수 &lt;var&gt;lockname&lt;/var&gt; 는 , 비 경우 &lt;code&gt;nil&lt;/code&gt; , 잠금 및 잠금 해제, 오버라이드 (override)의 목적으로 사용할 파일 이름을 지정 &lt;var&gt;filename&lt;/var&gt; 및 &lt;var&gt;visit&lt;/var&gt; 그 목적을 위해.</target>
        </trans-unit>
        <trans-unit id="505418b83113b1a1864d4371b2abfa1905c1136b" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;maximum&lt;/var&gt; sets a limit on how many fonts to return. If it is non-&lt;code&gt;nil&lt;/code&gt;, then the return value is truncated after the first &lt;var&gt;maximum&lt;/var&gt; matching fonts. Specifying a small value for &lt;var&gt;maximum&lt;/var&gt; can make this function much faster, in cases where many fonts match the pattern.</source>
          <target state="translated">선택적 인수 &lt;var&gt;maximum&lt;/var&gt; 은 반환 할 글꼴 수에 대한 제한을 설정합니다. &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 첫 번째 &lt;var&gt;maximum&lt;/var&gt; 일치 글꼴 이후에 반환 값이 잘립니다 . &lt;var&gt;maximum&lt;/var&gt; 값에 작은 값을 지정하면 많은 글꼴이 패턴과 일치하는 경우이 기능이 훨씬 빨라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2fef78645ec648e97c68254439e56ca0814e67d" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;millisec&lt;/var&gt; specifies an additional waiting period measured in milliseconds. This adds to the period specified by &lt;var&gt;seconds&lt;/var&gt;. If the system doesn&amp;rsquo;t support waiting fractions of a second, you get an error if you specify nonzero &lt;var&gt;millisec&lt;/var&gt;.</source>
          <target state="translated">선택적 인수 &lt;var&gt;millisec&lt;/var&gt; 는 밀리 초 단위로 측정되는 추가 대기 기간을 지정합니다. 이렇게하면 &lt;var&gt;seconds&lt;/var&gt; 지정된 기간이 추가됩니다 . 시스템이 1 초의 대기 시간을 지원하지 않는 경우 0이 아닌 &lt;var&gt;millisec&lt;/var&gt; 를 지정하면 오류가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="a79dc72b2d8c8af7d2c6097667a6efcd584162f8" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;minibuf&lt;/var&gt; specifies whether minibuffer windows should be included in the cyclic ordering. Normally, when &lt;var&gt;minibuf&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, a minibuffer window is included only if it is currently active; this matches the behavior of</source>
          <target state="translated">선택적 인수 &lt;var&gt;minibuf&lt;/var&gt; 는 미니 버퍼 창이 순환 순서에 포함되어야하는지 여부를 지정합니다. 일반적으로 &lt;var&gt;minibuf&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이면 현재 활성화 된 경우에만 미니 버퍼 창이 포함됩니다. 이것은 행동과 일치합니다</target>
        </trans-unit>
        <trans-unit id="41718d9699e86f654dd2ea26e540ead2023238f1" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;minibuffer&lt;/var&gt; specifies whether to include the minibuffer window in the returned list. If &lt;var&gt;minibuffer&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;, the minibuffer window is included. If &lt;var&gt;minibuffer&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; or omitted, the minibuffer window is included only if it is active. If &lt;var&gt;minibuffer&lt;/var&gt; is neither &lt;code&gt;nil&lt;/code&gt; nor &lt;code&gt;t&lt;/code&gt;, the minibuffer window is never included.</source>
          <target state="translated">선택적 인수 &lt;var&gt;minibuffer&lt;/var&gt; 는 반환 된 목록에 미니 버퍼 창을 포함할지 여부를 지정합니다. &lt;var&gt;minibuffer&lt;/var&gt; 가 &lt;code&gt;t&lt;/code&gt; 이면 미니 버퍼 창이 포함됩니다. &lt;var&gt;minibuffer&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이거나 생략 된 경우 미니 버퍼 창이 활성화 된 경우에만 포함됩니다. &lt;var&gt;minibuffer&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 도 &lt;code&gt;t&lt;/code&gt; 도 아닌 경우 , minibuffer 창은 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="295f0ea496d93011b8fee19529ccf2a7cf02e05c" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;mode-and-header-line&lt;/var&gt;&lt;code&gt;nil&lt;/code&gt; or omitted means to not include the height of the mode- or header-line of &lt;var&gt;window&lt;/var&gt; in the return value. If it is either the symbol &lt;code&gt;mode-line&lt;/code&gt; or &lt;code&gt;header-line&lt;/code&gt;, include only the height of that line, if present, in the return value. If it is &lt;code&gt;t&lt;/code&gt;, include the height of both, if present, in the return value.</source>
          <target state="translated">선택적 인수 &lt;var&gt;mode-and-header-line&lt;/var&gt; &lt;code&gt;nil&lt;/code&gt; 또는 생략 은 반환 값 에 &lt;var&gt;window&lt;/var&gt; 모드 또는 헤더 행 높이를 포함하지 않음을 의미 합니다. &lt;code&gt;mode-line&lt;/code&gt; 또는 &lt;code&gt;header-line&lt;/code&gt; 기호 이면 해당 줄의 높이 만 반환 값에 포함합니다 (있는 경우). 그런 경우 &lt;code&gt;t&lt;/code&gt; 가 , 양쪽의 높이를 포함하는 본 경우, 반환 값이다.</target>
        </trans-unit>
        <trans-unit id="e8ec5bd3618893a66ce0e97a3f3a6fa2e9be9058" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;no-activate&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, causes Emacs to update its record of installed packages without actually making them available.</source>
          <target state="translated">선택적 인자 &lt;var&gt;no-activate&lt;/var&gt; 는 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 Emacs가 실제로 사용 가능하게하지 않고 설치된 패키지의 기록을 업데이트하도록합니다.</target>
        </trans-unit>
        <trans-unit id="20709a8a77efe587a728d12e613e78b8c48774b1" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;noerror&lt;/var&gt; is obsolete, kept for backward compatibility, and has no effect.</source>
          <target state="translated">선택적 인수 &lt;var&gt;noerror&lt;/var&gt; 는 더 이상 사용되지 않으며 이전 버전과의 호환성을 위해 유지되며 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="2b89e1f5be44e2151710c7bdac8ce82b4cbfb2b4" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;object&lt;/var&gt; specifies which text to search, and defaults to the current buffer. If &lt;var&gt;object&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it can be some other buffer, or it can be a string or a window. If it is a string, the function searches that string. If it is a window, the function searches the buffer displayed in that window. If a buffer whose text you want to examine is displayed in some window, we recommend to specify it by that window, rather than pass the buffer to the function. This is because telling the function about the window allows it to correctly account for window-specific overlays, which might change the result of the function if some text in the buffer is covered by overlays.</source>
          <target state="translated">선택적 인수 &lt;var&gt;object&lt;/var&gt; 는 검색 할 텍스트를 지정하고 기본값은 현재 버퍼입니다. 경우 &lt;var&gt;object&lt;/var&gt; 비이다 &lt;code&gt;nil&lt;/code&gt; , 일부 다른 버퍼가 될 수 있거나, 문자열 또는 윈도우 일 수있다. 문자열 인 경우 함수는 해당 문자열을 검색합니다. 윈도우라면 해당 윈도우에 표시된 버퍼를 검색합니다. 검사하려는 텍스트의 버퍼가 일부 창에 표시되는 경우 버퍼를 함수에 전달하는 것보다 해당 창에서 지정하는 것이 좋습니다. 그 이유는 함수에 창에 대해 알려 주면 창 특정 오버레이를 올바르게 설명 할 수 있기 때문입니다. 버퍼의 일부 텍스트가 오버레이로 덮일 경우 함수의 결과가 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a510836acc518a4ce80759b09b05d4c9fb80e93" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;object&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, specifies a buffer or string to act on, rather than the current buffer. If &lt;var&gt;object&lt;/var&gt; is a string, then &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt; are zero-based indices into the string.</source>
          <target state="translated">선택적 인수 &lt;var&gt;object&lt;/var&gt; 는 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 현재 버퍼가 아닌 작동 할 버퍼 또는 문자열을 지정합니다. 경우 &lt;var&gt;object&lt;/var&gt; 문자열입니다, 다음 &lt;var&gt;start&lt;/var&gt; 및 &lt;var&gt;end&lt;/var&gt; 문자열에 제로 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="6f772ffbd43b315bbe2a2d9ef65a881dd0172794" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;on-exit&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, specifies a function that is called, with no arguments, after &lt;var&gt;keymap&lt;/var&gt; is deactivated.</source>
          <target state="translated">선택적 인수 &lt;var&gt;on-exit&lt;/var&gt; 는 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 &lt;var&gt;keymap&lt;/var&gt; 이 비활성화 된 후 인수없이 호출되는 함수를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="59f86c6b81e54496f12f978a2ada198f4a69de49" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;only-present&lt;/var&gt; indicates how to handle specification characters in &lt;var&gt;template&lt;/var&gt; that are not found in &lt;var&gt;spec-alist&lt;/var&gt;. If it is &lt;code&gt;nil&lt;/code&gt; or omitted, the function signals an error. Otherwise, those format specifications and any occurrences of &amp;lsquo;</source>
          <target state="translated">선택적 인수 &lt;var&gt;only-present&lt;/var&gt; 는 &lt;var&gt;spec-alist&lt;/var&gt; 에서 찾을 수없는 &lt;var&gt;template&lt;/var&gt; 사양 문자를 처리하는 방법을 나타냅니다 . 이 경우 &lt;code&gt;nil&lt;/code&gt; 또는 생략이 함수는 에러 신호를 보낸다. 그렇지 않으면 해당 형식 사양과 '</target>
        </trans-unit>
        <trans-unit id="99357a38b2f2682df0548c2c500e9c64e4f6180b" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;padding&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, is a padding character added at the beginning and end of the result string, to extend it to exactly &lt;var&gt;width&lt;/var&gt; columns. The padding character is used at the end of the result if it falls short of &lt;var&gt;width&lt;/var&gt;. It is also used at the beginning of the result if one multi-column character in &lt;var&gt;string&lt;/var&gt; extends across the column &lt;var&gt;start-column&lt;/var&gt;.</source>
          <target state="translated">선택적 인수 &lt;var&gt;padding&lt;/var&gt; 은 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 결과 문자열의 시작과 끝에 추가되어 정확한 &lt;var&gt;width&lt;/var&gt; 열로 확장됩니다 . 패딩 문자는 &lt;var&gt;width&lt;/var&gt; 가 부족할 경우 결과 끝에 사용됩니다 . &lt;var&gt;string&lt;/var&gt; 의 다중 열 문자 하나가 &lt;var&gt;start-column&lt;/var&gt; 열을 가로 질러 확장 되는 경우 결과의 시작 부분에도 사용 됩니다 .</target>
        </trans-unit>
        <trans-unit id="791557e50f0f19bd2818ee21038e7006cdf9270d" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;paren&lt;/var&gt; can be any of the following:</source>
          <target state="translated">선택적 인수 &lt;var&gt;paren&lt;/var&gt; 은 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9125d9631a53fcb42a447bf4efdec3689610b1c4" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;pixelwise&lt;/var&gt; non-&lt;code&gt;nil&lt;/code&gt; means to measure the new width and height in units of pixels instead. Note that if &lt;code&gt;frame-resize-pixelwise&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;, some toolkits may refuse to truly honor the request if it does not increase/decrease the frame size to a multiple of its character size.</source>
          <target state="translated">선택적 인수 &lt;var&gt;pixelwise&lt;/var&gt; non- &lt;code&gt;nil&lt;/code&gt; 은 대신 픽셀 단위로 새 너비와 높이를 측정하는 것을 의미합니다. 경우주의 &lt;code&gt;frame-resize-pixelwise&lt;/code&gt; 있다 &lt;code&gt;nil&lt;/code&gt; , 일부 툴킷이 진정이 증가 /의 문자 크기의 배수로 프레임 크기를 감소하지 않는 경우 요청을 명예를 거부 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a486c9457c82acbf1a6a199202ab0f46c9a5f6d" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;pixelwise&lt;/var&gt; non-&lt;code&gt;nil&lt;/code&gt; means to return the minimum size of &lt;var&gt;window&lt;/var&gt; counted in pixels.</source>
          <target state="translated">선택적 인수 &lt;var&gt;pixelwise&lt;/var&gt; non- &lt;code&gt;nil&lt;/code&gt; 은 픽셀 단위로 계산 된 &lt;var&gt;window&lt;/var&gt; 최소 크기를 반환하는 것을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="58f7f9c9311afbc394002bdf8390e5e8a66c15d9" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;positions&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, is a cons cell whose &lt;small&gt;CAR&lt;/small&gt; specifies the uppermost and whose &lt;small&gt;CDR&lt;/small&gt; specifies the lowermost pixel position that must be covered by any rectangle returned. These positions measure from the start of the text area of &lt;var&gt;window&lt;/var&gt;.</source>
          <target state="translated">선택적 인수 &lt;var&gt;positions&lt;/var&gt; 는 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 &lt;small&gt;CAR&lt;/small&gt; 이 최상위를 지정하고 &lt;small&gt;CDR이&lt;/small&gt; 반환 된 사각형으로 덮혀 야하는 최하위 픽셀 위치를 지정 하는 cons 셀입니다 . 이 위치는 &lt;var&gt;window&lt;/var&gt; 텍스트 영역의 시작부터 측정됩니다 .</target>
        </trans-unit>
        <trans-unit id="d4d8d2c166f79b72f18b93ddb099c08e8746fd52" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;predicate&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, specifies a function to filter the buffers that should be considered: the function will be called with every potential candidate as its argument, and should return &lt;code&gt;nil&lt;/code&gt; to reject the candidate, non-&lt;code&gt;nil&lt;/code&gt; to accept it.</source>
          <target state="translated">선택적 인자 &lt;var&gt;predicate&lt;/var&gt; &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우) 는 고려해야 할 버퍼를 필터링하는 함수를 지정합니다. 함수는 모든 잠재적 후보를 인수로 사용하여 호출되며 후보 를 거부하려면 &lt;code&gt;nil&lt;/code&gt; 을 반환하고 이를 수락하려면 &lt;code&gt;nil&lt;/code&gt; 이 아닌 값을 반환해야 합니다. .</target>
        </trans-unit>
        <trans-unit id="bf6c3432c82d35a85740cbc2f62db8414db80230" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;predicate&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, specifies a predicate function for testing whether a candidate file is suitable. The predicate is passed the candidate file name as its single argument. If &lt;var&gt;predicate&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; or omitted, &lt;code&gt;locate-file&lt;/code&gt; uses &lt;code&gt;file-readable-p&lt;/code&gt; as the predicate. See &lt;a href=&quot;kinds-of-files#Kinds-of-Files&quot;&gt;Kinds of Files&lt;/a&gt;, for other useful predicates, e.g., &lt;code&gt;file-executable-p&lt;/code&gt; and &lt;code&gt;file-directory-p&lt;/code&gt;.</source>
          <target state="translated">선택적 인수 &lt;var&gt;predicate&lt;/var&gt; 는 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 후보 파일이 적합한 지 테스트하기위한 조건 자 함수를 지정합니다. 술어에는 후보 파일 이름이 단일 인수로 전달됩니다. 경우에 &lt;var&gt;predicate&lt;/var&gt; 있다 &lt;code&gt;nil&lt;/code&gt; 또는 생략 &lt;code&gt;locate-file&lt;/code&gt; 사용하는 &lt;code&gt;file-readable-p&lt;/code&gt; 조건부로. 다른 유용한 술어 (예 : &lt;code&gt;file-executable-p&lt;/code&gt; 및 &lt;code&gt;file-directory-p&lt;/code&gt; )에 대해서는 &lt;a href=&quot;kinds-of-files#Kinds-of-Files&quot;&gt;Kinds of Files를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1e2cb767e72f360984a732e376c1c4554ced51fa" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;preserve-size&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, will install a parameter to preserve the size of &lt;var&gt;window&lt;/var&gt; during future resize operations (see &lt;a href=&quot;preserving-window-sizes#Preserving-Window-Sizes&quot;&gt;Preserving Window Sizes&lt;/a&gt;).</source>
          <target state="translated">선택적 인수 &lt;var&gt;preserve-size&lt;/var&gt; 는 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 향후 크기 조정 작업 중에 &lt;var&gt;window&lt;/var&gt; 크기를 유지하는 매개 변수를 설치 합니다 ( &lt;a href=&quot;preserving-window-sizes#Preserving-Window-Sizes&quot;&gt;창 크기 유지&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="435a1b07679e489657de30782052b8d6eab4ec8b" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;require-match&lt;/var&gt; has the same meaning as in &lt;code&gt;completing-read&lt;/code&gt;. See &lt;a href=&quot;minibuffer-completion#Minibuffer-Completion&quot;&gt;Minibuffer Completion&lt;/a&gt;.</source>
          <target state="translated">선택적 인수 &lt;var&gt;require-match&lt;/var&gt; 는 &lt;code&gt;completing-read&lt;/code&gt; 와 동일한 의미를 갖 습니다 . &lt;a href=&quot;minibuffer-completion#Minibuffer-Completion&quot;&gt;Minibuffer Completion을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e40feac3d056e5b6f3adcd167b868b54bdefa42a" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;rgb&lt;/var&gt;, if specified, is an rgb value, a list of three numbers that specify what the color actually looks like. If you do not specify &lt;var&gt;rgb&lt;/var&gt;, then this color cannot be used by &lt;code&gt;tty-color-approximate&lt;/code&gt; to approximate other colors, because Emacs will not know what it looks like.</source>
          <target state="translated">선택적 인수 &lt;var&gt;rgb&lt;/var&gt; 는 지정된 경우 색상이 실제로 어떻게 보이는지 지정하는 세 개의 숫자 목록 인 rgb 값입니다. &lt;var&gt;rgb&lt;/var&gt; 를 지정하지 않으면 &lt;code&gt;tty-color-approximate&lt;/code&gt; 에서이 색상을 사용하여 다른 색상을 근사화 할 수 없습니다. Emacs는 모양을 알지 못하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="905cbc5fb211abaa07ac0619c5392cdf3e417dd1" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;spec-type&lt;/var&gt; determines which spec to set. If it is omitted or &lt;code&gt;nil&lt;/code&gt; or &lt;code&gt;face-override-spec&lt;/code&gt;, this function sets the &lt;em&gt;override spec&lt;/em&gt;, which overrides face specs on &lt;var&gt;face&lt;/var&gt; of all the other types mentioned below. This is useful when calling this function outside of Custom code. If &lt;var&gt;spec-type&lt;/var&gt; is &lt;code&gt;customized-face&lt;/code&gt; or &lt;code&gt;saved-face&lt;/code&gt;, this function sets the customized spec or the saved custom spec, respectively. If it is &lt;code&gt;face-defface-spec&lt;/code&gt;, this function sets the default face spec (the same one set by &lt;code&gt;defface&lt;/code&gt;). If it is &lt;code&gt;reset&lt;/code&gt;, this function clears out all customization specs and override specs from &lt;var&gt;face&lt;/var&gt; (in this case, the value of &lt;var&gt;spec&lt;/var&gt; is ignored). The effect of any other value of &lt;var&gt;spec-type&lt;/var&gt; on the face specs is reserved for internal use, but the function will still define &lt;var&gt;face&lt;/var&gt; itself and recalculate its attributes, as described above.</source>
          <target state="translated">선택적 인수 &lt;var&gt;spec-type&lt;/var&gt; 은 설정할 사양을 결정합니다. 그것은 생략되거나 경우 &lt;code&gt;nil&lt;/code&gt; 또는 &lt;code&gt;face-override-spec&lt;/code&gt; 이 함수는 세트 &lt;em&gt;오버라이드 사양&lt;/em&gt; 재정의 사양에 얼굴, &lt;var&gt;face&lt;/var&gt; 아래에 언급 된 모든 다른 유형의이. 이것은 사용자 정의 코드 외부에서이 함수를 호출 할 때 유용합니다. 경우 &lt;var&gt;spec-type&lt;/var&gt; 되는 &lt;code&gt;customized-face&lt;/code&gt; 또는 &lt;code&gt;saved-face&lt;/code&gt; ,이 함수는 각각의 사용자 또는 사양 저장된 맞춤 사양을 설정한다. 이 경우 &lt;code&gt;face-defface-spec&lt;/code&gt; 이 기능은 기본면 사양 (하여 동일한 하나의 세트로 설정 &lt;code&gt;defface&lt;/code&gt; 을 ). &lt;code&gt;reset&lt;/code&gt; 경우,이 함수는 모든 사용자 정의 사양을 지우고 &lt;var&gt;face&lt;/var&gt; 에서 사양을 재정의합니다 (이 경우 &lt;var&gt;spec&lt;/var&gt; 값 은 무시 됨). 얼굴 사양에 대한 다른 &lt;var&gt;spec-type&lt;/var&gt; 값의 영향은 내부 사용을 위해 예약되어 있지만 함수는 여전히 위에서 설명한대로 &lt;var&gt;face&lt;/var&gt; 자체를 정의 하고 속성을 다시 계산합니다.</target>
        </trans-unit>
        <trans-unit id="d6f8de3101851c3382246237fec9a41fcf1e43cd" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;start-column&lt;/var&gt; specifies the starting column. If this is non-&lt;code&gt;nil&lt;/code&gt;, then the first &lt;var&gt;start-column&lt;/var&gt; columns of the string are omitted from the value. If one multi-column character in &lt;var&gt;string&lt;/var&gt; extends across the column &lt;var&gt;start-column&lt;/var&gt;, that character is not included.</source>
          <target state="translated">선택적 인수 &lt;var&gt;start-column&lt;/var&gt; 은 시작 열을 지정합니다. 이것이 &lt;code&gt;nil&lt;/code&gt; 이 아니면 문자열 의 첫 번째 &lt;var&gt;start-column&lt;/var&gt; 열이 값에서 생략됩니다. &lt;var&gt;string&lt;/var&gt; 의 다중 열 문자 하나가 &lt;var&gt;start-column&lt;/var&gt; 열을 가로 질러 확장되는 경우 해당 문자는 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="170877c661c774db6181373f0a88ba3c4809375d" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;string&lt;/var&gt; means to get a byte value from that string instead of the current buffer.</source>
          <target state="translated">선택적 인수 &lt;var&gt;string&lt;/var&gt; 은 현재 버퍼 대신 해당 문자열에서 바이트 값을 가져 오는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="08690ee1143f80767485ceb61e6025b4e1f6ad5a" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;suffixes&lt;/var&gt; gives the list of file-name suffixes to append to &lt;var&gt;filename&lt;/var&gt; when searching. &lt;code&gt;locate-file&lt;/code&gt; tries each possible directory with each of these suffixes. If &lt;var&gt;suffixes&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, or &lt;code&gt;(&quot;&quot;)&lt;/code&gt;, then there are no suffixes, and &lt;var&gt;filename&lt;/var&gt; is used only as-is. Typical values of &lt;var&gt;suffixes&lt;/var&gt; are &lt;code&gt;exec-suffixes&lt;/code&gt; (see &lt;a href=&quot;subprocess-creation#Subprocess-Creation&quot;&gt;Subprocess Creation&lt;/a&gt;), &lt;code&gt;load-suffixes&lt;/code&gt;, &lt;code&gt;load-file-rep-suffixes&lt;/code&gt; and the return value of the function &lt;code&gt;get-load-suffixes&lt;/code&gt; (see &lt;a href=&quot;load-suffixes#Load-Suffixes&quot;&gt;Load Suffixes&lt;/a&gt;).</source>
          <target state="translated">선택적 인수 &lt;var&gt;suffixes&lt;/var&gt; 는 검색 할 때 &lt;var&gt;filename&lt;/var&gt; 에 추가 할 파일 이름 접미사 목록을 제공합니다 . &lt;code&gt;locate-file&lt;/code&gt; 은 이러한 각 접미사를 사용하여 가능한 각 디렉토리를 시도합니다. 경우 &lt;var&gt;suffixes&lt;/var&gt; 입니다 &lt;code&gt;nil&lt;/code&gt; , 또는 &lt;code&gt;(&quot;&quot;)&lt;/code&gt; , 다음 더 접미사가 없으며, &lt;var&gt;filename&lt;/var&gt; 그대로에만 사용됩니다. &lt;var&gt;suffixes&lt;/var&gt; 일반적인 값 은 &lt;code&gt;exec-suffixes&lt;/code&gt; ( &lt;a href=&quot;subprocess-creation#Subprocess-Creation&quot;&gt;Subprocess Creation&lt;/a&gt; 참조 ), &lt;code&gt;load-suffixes&lt;/code&gt; , &lt;code&gt;load-file-rep-suffixes&lt;/code&gt; 및 &lt;code&gt;get-load-suffixes&lt;/code&gt; 함수의 반환 값입니다 ( &lt;a href=&quot;load-suffixes#Load-Suffixes&quot;&gt;Load Suffixes&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="6929cd262e2ec8e57cb83b3bca611739b4dfbf41" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;translation&lt;/var&gt; specifies a translation table to use for scanning the text (see &lt;a href=&quot;translation-of-characters#Translation-of-Characters&quot;&gt;Translation of Characters&lt;/a&gt;). If it is non-&lt;code&gt;nil&lt;/code&gt;, then each character in the region is translated through this table, and the value returned describes the translated characters instead of the characters actually in the buffer.</source>
          <target state="translated">선택적 인수 &lt;var&gt;translation&lt;/var&gt; 은 텍스트 스캔에 사용할 번역 테이블을 지정합니다 ( &lt;a href=&quot;translation-of-characters#Translation-of-Characters&quot;&gt;문자 번역&lt;/a&gt; 참조 ). &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 영역의 각 문자가이 테이블을 통해 번역되고 반환 된 값은 실제로 버퍼에있는 문자 대신 번역 된 문자를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="c092e151609e9ec5f01fdc51239dc320c81fb40d" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;type&lt;/var&gt; is a symbol specifying the image type. If &lt;var&gt;type&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;create-image&lt;/code&gt; tries to determine the image type from the file&amp;rsquo;s first few bytes, or else from the file&amp;rsquo;s name.</source>
          <target state="translated">선택적 인수 &lt;var&gt;type&lt;/var&gt; 은 이미지 유형을 지정하는 기호입니다. 경우 &lt;var&gt;type&lt;/var&gt; 생략되거나 &lt;code&gt;nil&lt;/code&gt; , &lt;code&gt;create-image&lt;/code&gt; 파일의 처음 몇 바이트에서 이미지 유형을 확인하려고, 또는 다른 파일의 이름에서.</target>
        </trans-unit>
        <trans-unit id="cffa81c7cb380096c5547dae42e6cb7a9528d1b2" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;type&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, determines the exact type of Lisp object to check for. In that case, &lt;var&gt;type&lt;/var&gt; should be one of &lt;code&gt;font-object&lt;/code&gt;, &lt;code&gt;font-spec&lt;/code&gt;, or &lt;code&gt;font-entity&lt;/code&gt;.</source>
          <target state="translated">선택적 인수 &lt;var&gt;type&lt;/var&gt; 은 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 확인할 Lisp 개체의 정확한 유형을 결정합니다. 이 경우 &lt;var&gt;type&lt;/var&gt; 은 &lt;code&gt;font-object&lt;/code&gt; , &lt;code&gt;font-spec&lt;/code&gt; 또는 &lt;code&gt;font-entity&lt;/code&gt; 중 하나 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="bc15e8d2ee27fc6994759226a8e71c2f534f8ee7" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;width&lt;/var&gt; specifies a desired font width. If it is non-&lt;code&gt;nil&lt;/code&gt;, the function only returns those fonts whose characters are (on average) &lt;var&gt;width&lt;/var&gt; times as wide as &lt;var&gt;reference-face&lt;/var&gt;.</source>
          <target state="translated">선택적 인수 &lt;var&gt;width&lt;/var&gt; 는 원하는 글꼴 너비를 지정합니다. &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우이 함수는 문자가 (평균적으로) &lt;var&gt;width&lt;/var&gt; 가 &lt;var&gt;reference-face&lt;/var&gt; 만큼 너비 인 글꼴 만 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a4adeba927f11ca868cbbc9ac454375db4897015" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;window&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, should be a live window on the specified frame; then &lt;var&gt;window&lt;/var&gt; will be the first element in the returned list. If &lt;var&gt;window&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt;, the window selected within the frame is the first element.</source>
          <target state="translated">선택적 인수 인 &lt;var&gt;window&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 지정된 프레임의 라이브 창이어야합니다. 그러면 &lt;var&gt;window&lt;/var&gt; 는 반환 된 목록의 첫 번째 요소가됩니다. 경우에 &lt;var&gt;window&lt;/var&gt; 생략되거나 &lt;code&gt;nil&lt;/code&gt; , 프레임 내의 선택된 윈도우는 첫 번째 요소이다.</target>
        </trans-unit>
        <trans-unit id="fdc9182a4b3a92a29afde612fa522b47066e0b79" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;x-limit&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, specifies the maximum X coordinate beyond which text should be ignored; it is therefore also the largest value of pixel-width that the function can return. If &lt;var&gt;x-limit&lt;/var&gt;&lt;code&gt;nil&lt;/code&gt; or omitted, it means to use the pixel-width of &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s body (see &lt;a href=&quot;window-sizes#Window-Sizes&quot;&gt;Window Sizes&lt;/a&gt;); this default means that text of truncated lines wider than the window will be ignored. This default is useful when the caller does not intend to change the width of &lt;var&gt;window&lt;/var&gt;. Otherwise, the caller should specify here the maximum width &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s body may assume; in particular, if truncated lines are expected and their text needs to be accounted for, &lt;var&gt;x-limit&lt;/var&gt; should be set to a large value. Since calculating the width of long lines can take some time, it&amp;rsquo;s always a good idea to make this argument as small as needed; in particular, if the buffer might contain long lines that will be truncated anyway.</source>
          <target state="translated">선택적 인수 &lt;var&gt;x-limit&lt;/var&gt; 는 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 텍스트를 무시해야하는 최대 X 좌표를 지정합니다. 따라서 함수가 반환 할 수있는 픽셀 너비의 가장 큰 값이기도합니다. 경우 &lt;var&gt;x-limit&lt;/var&gt; &lt;code&gt;nil&lt;/code&gt; 또는 생략, 그것의 픽셀 폭 사용할 수단 &lt;var&gt;window&lt;/var&gt; 본체 S '(참조 &lt;a href=&quot;window-sizes#Window-Sizes&quot;&gt;윈도우 사이즈를&lt;/a&gt; ); 이 기본값은 창보다 넓은 잘린 줄의 텍스트가 무시됨을 의미합니다. 이 기본값은 호출자가 &lt;var&gt;window&lt;/var&gt; 너비를 변경하지 않을 때 유용합니다 . 그렇지 않으면 호출자는 여기에서 &lt;var&gt;window&lt;/var&gt; 본문이 가정 할 수 있는 최대 너비를 지정해야합니다 . 특히 잘린 줄이 예상되고 해당 텍스트를 고려해야하는 경우 &lt;var&gt;x-limit&lt;/var&gt; 는 큰 값으로 설정해야합니다. 긴 선의 너비를 계산하는 데 시간이 걸릴 수 있으므로 항상이 인수를 필요한만큼 작게 만드는 것이 좋습니다. 특히, 버퍼에 어쨌든 잘릴 긴 줄이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c40e0ed4f1db150d7701a53bd11312d3806432c0" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;xrm-string&lt;/var&gt;, if not &lt;code&gt;nil&lt;/code&gt;, is a string of resource names and values, in the same format used in the</source>
          <target state="translated">선택적 인수 &lt;var&gt;xrm-string&lt;/var&gt; 은 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 리소스 이름 및 값의 문자열이며</target>
        </trans-unit>
        <trans-unit id="e45d1b4575d0268bdd495d97852d103f4fb454e9" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;y-limit&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, specifies the maximum Y coordinate beyond which text is to be ignored; it is therefore also the maximum pixel-height that the function can return. If &lt;var&gt;y-limit&lt;/var&gt; is nil or omitted, it means to considers all the lines of text till the buffer position specified by &lt;var&gt;to&lt;/var&gt;. Since calculating the pixel-height of a large buffer can take some time, it makes sense to specify this argument; in particular, if the caller does not know the size of the buffer.</source>
          <target state="translated">선택적 인수 &lt;var&gt;y-limit&lt;/var&gt; 는 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 텍스트가 무시되는 최대 Y 좌표를 지정합니다. 따라서 함수가 반환 할 수있는 최대 픽셀 높이이기도합니다. 경우 &lt;var&gt;y-limit&lt;/var&gt; 존재하지 않거나 생략 그것은 의해 지정된 버퍼 위치까지 모든 텍스트 라인 판단 수단 &lt;var&gt;to&lt;/var&gt; . 큰 버퍼의 픽셀 높이를 계산하는 데 시간이 걸릴 수 있으므로이 인수를 지정하는 것이 좋습니다. 특히 호출자가 버퍼의 크기를 모르는 경우.</target>
        </trans-unit>
        <trans-unit id="dc3a575ab4003570a9c36540fefa7d4ef44f3823" translate="yes" xml:space="preserve">
          <source>The optional arguments &lt;var&gt;action&lt;/var&gt; and &lt;var&gt;frame&lt;/var&gt; are as for &lt;code&gt;display-buffer&lt;/code&gt;, and only used if a buffer is displayed.</source>
          <target state="translated">선택적 인수 &lt;var&gt;action&lt;/var&gt; 및 &lt;var&gt;frame&lt;/var&gt; 은 &lt;code&gt;display-buffer&lt;/code&gt; 와 같 으며 버퍼가 표시되는 경우에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0c0042672620faa70f4c2ac1559a316ba863df5c" translate="yes" xml:space="preserve">
          <source>The optional arguments &lt;var&gt;component&lt;/var&gt; and &lt;var&gt;subclass&lt;/var&gt; add to the key and the class, respectively. You must specify both of them or neither. If you specify them, the key is &amp;lsquo;</source>
          <target state="translated">선택적 인수 &lt;var&gt;component&lt;/var&gt; 와 &lt;var&gt;subclass&lt;/var&gt; 클래스는 각각 키와 클래스에 추가됩니다. 둘 다 지정하거나 둘 다 지정하지 않아야합니다. 지정하는 경우 키는 '</target>
        </trans-unit>
        <trans-unit id="ee91262e4675f009db2d341be5b1d60c2ec7c619" translate="yes" xml:space="preserve">
          <source>The optional arguments &lt;var&gt;min-width&lt;/var&gt; and &lt;var&gt;min-height&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, specify the minimum width and height of any rectangle returned.</source>
          <target state="translated">선택적 인수 &lt;var&gt;min-width&lt;/var&gt; 및 &lt;var&gt;min-height&lt;/var&gt; 는 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 반환되는 사각형의 최소 너비와 높이를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="372690aff6ae141943d981fae5474ab55ccff89f" translate="yes" xml:space="preserve">
          <source>The optional arguments &lt;var&gt;minibuf&lt;/var&gt; and &lt;var&gt;all-frames&lt;/var&gt; specify the windows to search, and have the same meanings as in &lt;code&gt;next-window&lt;/code&gt;.</source>
          <target state="translated">선택적 인수 &lt;var&gt;minibuf&lt;/var&gt; 및 &lt;var&gt;all-frames&lt;/var&gt; 는 검색 할 창을 지정하고 &lt;code&gt;next-window&lt;/code&gt; 와 동일한 의미를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="2c1039de00a7678732da9114d34b59102a11647b" translate="yes" xml:space="preserve">
          <source>The optional arguments &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt; are character positions specifying the portion of &lt;var&gt;object&lt;/var&gt; to compute the message digest for. If they are &lt;code&gt;nil&lt;/code&gt; or omitted, the hash is computed for the whole of &lt;var&gt;object&lt;/var&gt;.</source>
          <target state="translated">선택적 인수 &lt;var&gt;start&lt;/var&gt; 및 &lt;var&gt;end&lt;/var&gt; 는 메시지 요약을 계산할 &lt;var&gt;object&lt;/var&gt; 부분을 ​​지정하는 문자 위치 입니다. &lt;code&gt;nil&lt;/code&gt; 이거나 생략 된 경우 &lt;var&gt;object&lt;/var&gt; 전체에 대해 해시가 계산됩니다 .</target>
        </trans-unit>
        <trans-unit id="2337e7f6ede507e511fcbe99dd954146514bc80b" translate="yes" xml:space="preserve">
          <source>The optional fifth argument, &lt;var&gt;object&lt;/var&gt;, specifies the string or buffer to scan. Positions are relative to &lt;var&gt;object&lt;/var&gt;. The default for &lt;var&gt;object&lt;/var&gt; is the current buffer.</source>
          <target state="translated">선택적 다섯 번째 인수 &lt;var&gt;object&lt;/var&gt; 는 스캔 할 문자열 또는 버퍼를 지정합니다. 위치는 &lt;var&gt;object&lt;/var&gt; 기준으로 합니다 . &lt;var&gt;object&lt;/var&gt; 의 기본값 은 현재 버퍼입니다.</target>
        </trans-unit>
        <trans-unit id="28e7ede94a8e68a6a581d0669d18f692d137189a" translate="yes" xml:space="preserve">
          <source>The optional fourth argument &lt;var&gt;pixelwise&lt;/var&gt; non-&lt;code&gt;nil&lt;/code&gt; means that &lt;var&gt;frame&lt;/var&gt; should be &lt;var&gt;height&lt;/var&gt; pixels high. Note that if &lt;code&gt;frame-resize-pixelwise&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;, some window managers may refuse to truly honor the request if it does not increase/decrease the frame height to a multiple of its character height.</source>
          <target state="translated">선택적 인수 제 &lt;var&gt;pixelwise&lt;/var&gt; 비 &lt;code&gt;nil&lt;/code&gt; 것을 의미 &lt;var&gt;frame&lt;/var&gt; 이어야 &lt;var&gt;height&lt;/var&gt; 화소 높은. 경우주의 &lt;code&gt;frame-resize-pixelwise&lt;/code&gt; 있다 &lt;code&gt;nil&lt;/code&gt; , 일부 윈도우 관리자가 진정이 증가 /의 문자 높이의 배수로 프레임의 높이를 감소하지 않는 경우 요청을 명예를 거부 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4cea50b6fa2e62214008b025d8e0f2e6fa48a344" translate="yes" xml:space="preserve">
          <source>The optional fourth argument &lt;var&gt;pixelwise&lt;/var&gt; non-&lt;code&gt;nil&lt;/code&gt; means that &lt;var&gt;frame&lt;/var&gt; should be &lt;var&gt;width&lt;/var&gt; pixels wide. Note that if &lt;code&gt;frame-resize-pixelwise&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;, some window managers may refuse to fully honor the request if it does not increase/decrease the frame width to a multiple of its character width.</source>
          <target state="translated">선택적 인수 제 &lt;var&gt;pixelwise&lt;/var&gt; 비 &lt;code&gt;nil&lt;/code&gt; 방법은 &lt;var&gt;frame&lt;/var&gt; 있어야 &lt;var&gt;width&lt;/var&gt; 넓은 픽셀. 경우주의 &lt;code&gt;frame-resize-pixelwise&lt;/code&gt; 있다 &lt;code&gt;nil&lt;/code&gt; , 일부 윈도우 관리자가 완전히이 증가 /의 문자 폭의 배수로 프레임 폭을 감소하지 않는 경우 요청을 명예를 거부 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46a593eb8b77337d54dd037277b7e1d96651e2a6" translate="yes" xml:space="preserve">
          <source>The optional fourth argument &lt;var&gt;pixelwise&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, means to interpret &lt;var&gt;size&lt;/var&gt; in units of pixels, instead of lines and columns.</source>
          <target state="translated">선택적 네 번째 인수 &lt;var&gt;pixelwise&lt;/var&gt; 는 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 행과 열 대신 픽셀 단위로 &lt;var&gt;size&lt;/var&gt; 를 해석하는 것을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="c1d2d517b24a513e68638fc126f01cf14f00b2b4" translate="yes" xml:space="preserve">
          <source>The optional fourth argument &lt;var&gt;window&lt;/var&gt; specifies the window for obtaining parameters such as width, horizontal scrolling, and so on. The default is to use the selected window&amp;rsquo;s parameters.</source>
          <target state="translated">선택적인 네 번째 인수 &lt;var&gt;window&lt;/var&gt; 은 너비, 수평 스크롤링 등과 같은 매개 변수를 얻기위한 창을 지정합니다. 기본값은 선택한 창의 매개 변수를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="32d500e9fa66e6e098845ee8a4f7df222a3a64f2" translate="yes" xml:space="preserve">
          <source>The optional second argument &lt;var&gt;size&lt;/var&gt; determines the sizes of &lt;var&gt;window&lt;/var&gt; and/or the new window. If it is omitted or &lt;code&gt;nil&lt;/code&gt;, both windows are given equal sizes; if there is an odd line, it is allocated to the new window. If &lt;var&gt;size&lt;/var&gt; is a positive number, &lt;var&gt;window&lt;/var&gt; is given &lt;var&gt;size&lt;/var&gt; lines (or columns, depending on the value of &lt;var&gt;side&lt;/var&gt;). If &lt;var&gt;size&lt;/var&gt; is a negative number, the new window is given -&lt;var&gt;size&lt;/var&gt; lines (or columns).</source>
          <target state="translated">선택적인 두 번째 인수 크기는 &lt;var&gt;window&lt;/var&gt; 및 / 또는 새 창의 &lt;var&gt;size&lt;/var&gt; 결정합니다 . 생략되거나 &lt;code&gt;nil&lt;/code&gt; 이면 두 창 모두 동일한 크기가 지정됩니다. 홀수 줄이 있으면 새 창에 할당됩니다. 경우 &lt;var&gt;size&lt;/var&gt; 양수이고, &lt;var&gt;window&lt;/var&gt; 주어진 &lt;var&gt;size&lt;/var&gt; (의 값에 따라, 컬럼 라인 &lt;var&gt;side&lt;/var&gt; ). 경우 &lt;var&gt;size&lt;/var&gt; 부정적인 번호, 새로운 윈도우가 주어집니다 - &lt;var&gt;size&lt;/var&gt; 라인 (또는 열).</target>
        </trans-unit>
        <trans-unit id="3ea25d87cc8b43ad9b6088e35f93a262a0c645a2" translate="yes" xml:space="preserve">
          <source>The optional string &lt;var&gt;docstring&lt;/var&gt; is the documentation string of the variable &lt;var&gt;tabname&lt;/var&gt;. The property list &lt;var&gt;props&lt;/var&gt; is applied to the abbrev table (see &lt;a href=&quot;abbrev-table-properties#Abbrev-Table-Properties&quot;&gt;Abbrev Table Properties&lt;/a&gt;).</source>
          <target state="translated">선택적 문자열 &lt;var&gt;docstring&lt;/var&gt; 은 &lt;var&gt;tabname&lt;/var&gt; 변수의 문서 문자열입니다 . 속성 목록 &lt;var&gt;props&lt;/var&gt; 은 약어 테이블에 적용됩니다 ( &lt;a href=&quot;abbrev-table-properties#Abbrev-Table-Properties&quot;&gt;Abbrev 테이블 속성&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="c222f8e06e9d5450826a8e535233e76c3aefd4d7" translate="yes" xml:space="preserve">
          <source>The optional third argument &lt;var&gt;side&lt;/var&gt; determines the position of the new window relative to &lt;var&gt;window&lt;/var&gt;. If it is &lt;code&gt;nil&lt;/code&gt; or &lt;code&gt;below&lt;/code&gt;, the new window is placed below &lt;var&gt;window&lt;/var&gt;. If it is &lt;code&gt;above&lt;/code&gt;, the new window is placed above &lt;var&gt;window&lt;/var&gt;. In both these cases, &lt;var&gt;size&lt;/var&gt; specifies a total window height, in lines.</source>
          <target state="translated">선택적 번째 인수 &lt;var&gt;side&lt;/var&gt; 에 새로운 윈도우의 위치 결정 &lt;var&gt;window&lt;/var&gt; . 이 경우 &lt;code&gt;nil&lt;/code&gt; 을 또는 &lt;code&gt;below&lt;/code&gt; , 새로운 창 아래에 배치되는 &lt;var&gt;window&lt;/var&gt; . 이 경우 &lt;code&gt;above&lt;/code&gt; 새 창 위에 배치됩니다 &lt;var&gt;window&lt;/var&gt; . 이 두 경우 모두 &lt;var&gt;size&lt;/var&gt; 는 총 창 높이를 라인 단위로 지정합니다.</target>
        </trans-unit>
        <trans-unit id="b1108fc16d48a052af5da3a2a313ad2178d4f97c" translate="yes" xml:space="preserve">
          <source>The optional third argument specifies the argument list of &lt;code&gt;shell-mode&lt;/code&gt;. In this case, it takes no arguments (&lt;code&gt;nil&lt;/code&gt; is different from not specifying a value). In other cases, this might be something like &lt;code&gt;(file &amp;amp;optional overwrite)&lt;/code&gt;. You don&amp;rsquo;t have to specify the argument list, but if you do the byte compiler can check that the calls match the declaration.</source>
          <target state="translated">선택적 세 번째 인수는 &lt;code&gt;shell-mode&lt;/code&gt; 의 인수 목록을 지정 합니다 . 이 경우 인수가 필요하지 않습니다 ( &lt;code&gt;nil&lt;/code&gt; 은 값을 지정하지 않는 것과 다름). 다른 경우에는 &lt;code&gt;(file &amp;amp;optional overwrite)&lt;/code&gt; 와 같을 수 있습니다 . 인수 목록을 지정할 필요는 없지만 바이트 컴파일러는 호출이 선언과 일치하는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c91189f64260a86a1f42683fa6c4e4a546871bd4" translate="yes" xml:space="preserve">
          <source>The order of items in the menu is the same as the order of bindings in the keymap. Since &lt;code&gt;define-key&lt;/code&gt; puts new bindings at the front, you should define the menu items starting at the bottom of the menu and moving to the top, if you care about the order. When you add an item to an existing menu, you can specify its position in the menu using &lt;code&gt;define-key-after&lt;/code&gt; (see &lt;a href=&quot;modifying-menus#Modifying-Menus&quot;&gt;Modifying Menus&lt;/a&gt;).</source>
          <target state="translated">메뉴 항목의 순서는 키맵의 바인딩 순서와 동일합니다. 이후 &lt;code&gt;define-key&lt;/code&gt; 전면 풋 새 바인딩, 메뉴 항목 메뉴의 하단에 시작하고 당신이 순서에 관심 있다면, 상단에 이동을 정의해야합니다. 기존 메뉴에 항목을 추가 할 때 &lt;code&gt;define-key-after&lt;/code&gt; 를 사용하여 메뉴에서 위치를 지정할 수 있습니다 ( &lt;a href=&quot;modifying-menus#Modifying-Menus&quot;&gt;메뉴 수정&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="1eb5686cd4b85626eb2e98bbf5e87da933ba4c3c" translate="yes" xml:space="preserve">
          <source>The order of specifications in &lt;var&gt;template&lt;/var&gt; need not correspond to the order of associations in &lt;var&gt;spec-alist&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;template&lt;/var&gt; 의 사양 순서는 &lt;var&gt;spec-alist&lt;/var&gt; 의 연결 순서와 일치 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="318b3cee5109ab1253568ca38f5b8b67f4c1e472" translate="yes" xml:space="preserve">
          <source>The ordering information is stored in a hash table on &lt;var&gt;symbol&lt;/var&gt;&amp;rsquo;s &lt;code&gt;list-order&lt;/code&gt; property. &lt;var&gt;symbol&lt;/var&gt; cannot refer to a lexical variable.</source>
          <target state="translated">순서 정보는 &lt;var&gt;symbol&lt;/var&gt; 의 &lt;code&gt;list-order&lt;/code&gt; 속성 에있는 해시 테이블에 저장됩니다 . &lt;var&gt;symbol&lt;/var&gt; 는 어휘 변수를 참조 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2226d00d51a88ba323aae0098cc9991d74673a2e" translate="yes" xml:space="preserve">
          <source>The ordering is determined by a depth-first traversal of each frame&amp;rsquo;s window tree, retrieving the live windows which are the leaf nodes of the tree (see &lt;a href=&quot;windows-and-frames#Windows-and-Frames&quot;&gt;Windows and Frames&lt;/a&gt;). If the minibuffer is active, the minibuffer window is included too. The ordering is cyclic, so the last window in the sequence is followed by the first one.</source>
          <target state="translated">순서는 각 프레임의 창 트리를 깊이 우선 순회하여 트리의 리프 노드 인 라이브 창을 검색하여 결정됩니다 ( &lt;a href=&quot;windows-and-frames#Windows-and-Frames&quot;&gt;Windows 및 프레임&lt;/a&gt; 참조 ). 미니 버퍼가 활성화 된 경우 미니 버퍼 창도 포함됩니다. 순서는 주기적이므로 시퀀스의 마지막 창 다음에 첫 번째 창이옵니다.</target>
        </trans-unit>
        <trans-unit id="f22b797aae6cb0756380535cd8ae770baa37540b" translate="yes" xml:space="preserve">
          <source>The ordinary &lt;em&gt;Lisp debugger&lt;/em&gt; provides the ability to suspend evaluation of a form. While evaluation is suspended (a state that is commonly known as a &lt;em&gt;break&lt;/em&gt;), you may examine the run time stack, examine the values of local or global variables, or change those values. Since a break is a recursive edit, all the usual editing facilities of Emacs are available; you can even run programs that will enter the debugger recursively. See &lt;a href=&quot;recursive-editing#Recursive-Editing&quot;&gt;Recursive Editing&lt;/a&gt;.</source>
          <target state="translated">일반 &lt;em&gt;Lisp 디버거&lt;/em&gt; 는 양식 평가를 일시 중단하는 기능을 제공합니다. 평가가 일시 중단되는 동안 (일반적으로 &lt;em&gt;break&lt;/em&gt; 로 알려진 상태 ) 런타임 스택을 검사하거나 로컬 또는 전역 변수의 값을 검사하거나 해당 값을 변경할 수 있습니다. 휴식은 재귀 적 편집이므로 Emacs의 모든 일반적인 편집 기능을 사용할 수 있습니다. 디버거에 재귀 적으로 들어가는 프로그램을 실행할 수도 있습니다. &lt;a href=&quot;recursive-editing#Recursive-Editing&quot;&gt;재귀 편집을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4f996d904bee479b366f2c2d0b17fcd959ce9c44" translate="yes" xml:space="preserve">
          <source>The ordinary elements of the display table are indexed by character codes; the element at index &lt;var&gt;c&lt;/var&gt; says how to display the character code &lt;var&gt;c&lt;/var&gt;. The value should be &lt;code&gt;nil&lt;/code&gt; (which means to display the character &lt;var&gt;c&lt;/var&gt; according to the usual display conventions; see &lt;a href=&quot;usual-display#Usual-Display&quot;&gt;Usual Display&lt;/a&gt;), or a vector of glyph codes (which means to display the character &lt;var&gt;c&lt;/var&gt; as those glyphs; see &lt;a href=&quot;glyphs#Glyphs&quot;&gt;Glyphs&lt;/a&gt;).</source>
          <target state="translated">디스플레이 테이블의 일반 요소는 문자 코드로 색인화됩니다. 색인 &lt;var&gt;c&lt;/var&gt; 의 요소 는 문자 코드 &lt;var&gt;c&lt;/var&gt; 를 표시하는 방법을 나타냅니다 . 값은 &lt;code&gt;nil&lt;/code&gt; ( 일반적인 표시 규칙에 따라 문자 &lt;var&gt;c&lt;/var&gt; 를 표시 함을 의미합니다 . &lt;a href=&quot;usual-display#Usual-Display&quot;&gt;일반 표시&lt;/a&gt; 참조 ) 또는 글리프 코드 벡터 (문자 &lt;var&gt;c&lt;/var&gt; 를 해당 글리프로 표시하는 것을 의미합니다 . &lt;a href=&quot;glyphs#Glyphs&quot;&gt;Glyphs&lt;/a&gt; 참조) 여야 합니다.</target>
        </trans-unit>
        <trans-unit id="623ff6e7f140985ddebe6c27ee8d097d687ce22b" translate="yes" xml:space="preserve">
          <source>The original argument list, modified with the actual connection information, is available via the &lt;code&gt;process-contact&lt;/code&gt; function.</source>
          <target state="translated">실제 연결 정보로 수정 된 원래 인수 목록은 &lt;code&gt;process-contact&lt;/code&gt; 기능을 통해 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3d6da09d571fe6e045570a75658c815203791d82" translate="yes" xml:space="preserve">
          <source>The original argument list, possibly modified by later configuration, is available via the function &lt;code&gt;process-contact&lt;/code&gt;.</source>
          <target state="translated">나중에 구성에 의해 수정 될 수있는 원래 인수 목록은 &lt;code&gt;process-contact&lt;/code&gt; 함수를 통해 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="783a67e957204d836894a368a238fa5382b7ae1b" translate="yes" xml:space="preserve">
          <source>The other Emacs prefix keys are</source>
          <target state="translated">다른 Emacs 접두사 키는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5e87cdc0bc797ddea7fd188f93a5689b5c8765dd" translate="yes" xml:space="preserve">
          <source>The outer position is specified by and can be set via the &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;top&lt;/code&gt; frame parameters (see &lt;a href=&quot;position-parameters#Position-Parameters&quot;&gt;Position Parameters&lt;/a&gt;). For a normal, top-level frame these parameters usually represent its absolute position (see below) with respect to its display&amp;rsquo;s origin. For a child frame (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;) these parameters represent its position relative to the native position (see below) of its parent frame. For frames on text terminals the values of these parameters are meaningless and always zero.</source>
          <target state="translated">외부 위치는로 지정되며 &lt;code&gt;left&lt;/code&gt; 및 &lt;code&gt;top&lt;/code&gt; 프레임 매개 변수 를 통해 설정할 수 있습니다 ( &lt;a href=&quot;position-parameters#Position-Parameters&quot;&gt;위치 매개 변수&lt;/a&gt; 참조 ). 일반적인 최상위 프레임의 경우 이러한 매개 변수는 일반적으로 디스플레이의 원점에 대한 절대 위치 (아래 참조)를 나타냅니다. 아이 프레임 (참조 &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;아이 프레임을&lt;/a&gt; 이 매개 변수는 기본 위치로의 위치를 나타냅니다) 부모 프레임의 (아래 참조). 텍스트 터미널에있는 프레임의 경우 이러한 매개 변수의 값은 무의미하며 항상 0입니다.</target>
        </trans-unit>
        <trans-unit id="9b61b570125b083d2bf973be5f7d446a50b1ff1e" translate="yes" xml:space="preserve">
          <source>The output characters are displayed in the echo area.</source>
          <target state="translated">출력 문자는 에코 영역에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f760a648322efbb4e113d3ec65ce0e0be54106de" translate="yes" xml:space="preserve">
          <source>The output characters are inserted into &lt;var&gt;buffer&lt;/var&gt; at point. Point advances as characters are inserted.</source>
          <target state="translated">출력 문자는 지점에서 &lt;var&gt;buffer&lt;/var&gt; 에 삽입됩니다 . 문자가 삽입되면 포인트가 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="847115e1679c724c2cb4444c6559f9fe7c4d8063" translate="yes" xml:space="preserve">
          <source>The output characters are inserted into the buffer that &lt;var&gt;marker&lt;/var&gt; points into, at the marker position. The marker position advances as characters are inserted. The value of point in the buffer has no effect on printing when the stream is a marker, and this kind of printing does not move point (except that if the marker points at or before the position of point, point advances with the surrounding text, as usual).</source>
          <target state="translated">출력 문자는 &lt;var&gt;marker&lt;/var&gt; 가리키는 버퍼 의 마커 위치에 삽입됩니다 . 마커 위치는 문자가 삽입됨에 따라 진행됩니다. 버퍼의 포인트 값은 스트림이 마커 인 경우 인쇄에 영향을주지 않으며 이러한 종류의 인쇄는 포인트를 이동하지 않습니다 (마커가 포인트의 위치 또는 그 이전을 가리키는 경우 포인트가 주변 텍스트와 함께 진행되는 경우를 제외하고는, 평소처럼).</target>
        </trans-unit>
        <trans-unit id="da1c7a7c56317e365d871f2788f8d99dcda43cbf" translate="yes" xml:space="preserve">
          <source>The output characters are passed to &lt;var&gt;function&lt;/var&gt;, which is responsible for storing them away. It is called with a single character as argument, as many times as there are characters to be output, and is responsible for storing the characters wherever you want to put them.</source>
          <target state="translated">출력 문자는 저장을 담당하는 &lt;var&gt;function&lt;/var&gt; 에 전달 됩니다. 출력 할 문자 수만큼 단일 문자를 인수로 사용하여 호출되며 원하는 위치에 문자를 저장하는 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="97b90b29b23cb79eed0c42878f18676a7f82018f" translate="yes" xml:space="preserve">
          <source>The output from a synchronous subprocess is generally decoded using a coding system, much like text read from a file. The input sent to a subprocess by &lt;code&gt;call-process-region&lt;/code&gt; is encoded using a coding system, much like text written into a file. See &lt;a href=&quot;coding-systems#Coding-Systems&quot;&gt;Coding Systems&lt;/a&gt;.</source>
          <target state="translated">동기식 하위 프로세스의 출력은 일반적으로 파일에서 읽은 텍스트와 같은 코딩 시스템을 사용하여 디코딩됩니다. &lt;code&gt;call-process-region&lt;/code&gt; 에 의해 하위 프로세스로 전송 된 입력 은 파일에 기록 된 텍스트와 매우 유사한 코딩 시스템을 사용하여 인코딩됩니다. &lt;a href=&quot;coding-systems#Coding-Systems&quot;&gt;코딩 시스템을&lt;/a&gt; 참고하십시오 .</target>
        </trans-unit>
        <trans-unit id="1bf1d258cf8161b4fe6f560101ccee767cdb33ab" translate="yes" xml:space="preserve">
          <source>The output string need not be newly-allocated. For example, if &lt;code&gt;x&lt;/code&gt; is the string &lt;code&gt;&quot;foo&quot;&lt;/code&gt;, the expressions &lt;code&gt;(eq x
(format x))&lt;/code&gt; and &lt;code&gt;(eq x (format &quot;%s&quot; x))&lt;/code&gt; might both yield &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">출력 문자열을 새로 할당 할 필요는 없습니다. 예를 들어, &lt;code&gt;x&lt;/code&gt; 가 문자열 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; 이면 식 &lt;code&gt;(eq x (format x))&lt;/code&gt; 및 &lt;code&gt;(eq x (format &quot;%s&quot; x))&lt;/code&gt; 는 모두 &lt;code&gt;t&lt;/code&gt; 를 산출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c3615d741950845df06c53b6a7f56b4c8a5a4ebc" translate="yes" xml:space="preserve">
          <source>The output that an asynchronous subprocess writes to its standard output stream is passed to a function called the &lt;em&gt;filter function&lt;/em&gt;. The default filter function simply inserts the output into a buffer, which is called the associated buffer of the process (see &lt;a href=&quot;process-buffers#Process-Buffers&quot;&gt;Process Buffers&lt;/a&gt;). If the process has no buffer then the default filter discards the output.</source>
          <target state="translated">비동기 하위 프로세스가 표준 출력 스트림에 쓰는 출력은 &lt;em&gt;필터 함수&lt;/em&gt; 라는 함수로 전달됩니다 . 기본 필터 함수는 단순히 출력을 프로세스의 관련 버퍼라고하는 버퍼에 삽입합니다 ( &lt;a href=&quot;process-buffers#Process-Buffers&quot;&gt;Process Buffers&lt;/a&gt; 참조 ). 프로세스에 버퍼가 없으면 기본 필터는 출력을 버립니다.</target>
        </trans-unit>
        <trans-unit id="1ae9bdf1de6c1b3dee1b8c77f2a066e71cd4bda1" translate="yes" xml:space="preserve">
          <source>The output to the filter may come in chunks of any size. A program that produces the same output twice in a row may send it as one batch of 200 characters one time, and five batches of 40 characters the next. If the filter looks for certain text strings in the subprocess output, make sure to handle the case where one of these strings is split across two or more batches of output; one way to do this is to insert the received text into a temporary buffer, which can then be searched.</source>
          <target state="translated">필터에 대한 출력은 모든 크기의 청크로 올 수 있습니다. 동일한 출력을 두 번 연속으로 생성하는 프로그램은 한 번에 200 자씩 한 배치로 보내고 다음 번에는 40 자씩 다섯 배치로 보낼 수 있습니다. 필터가 하위 프로세스 출력에서 ​​특정 텍스트 문자열을 찾는 경우 이러한 문자열 중 하나가 둘 이상의 출력 일괄 처리로 분할되는 경우를 처리해야합니다. 이를 수행하는 한 가지 방법은 수신 된 텍스트를 임시 버퍼에 삽입 한 다음 검색 할 수있는 것입니다.</target>
        </trans-unit>
        <trans-unit id="58e6196b6fc1654a77feeadf775e93f2d335a94f" translate="yes" xml:space="preserve">
          <source>The outside window configuration is saved and restored if &lt;code&gt;edebug-save-windows&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt; (see &lt;a href=&quot;edebug-options#Edebug-Options&quot;&gt;Edebug Options&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;edebug-save-windows&lt;/code&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 외부 창 구성이 저장되고 복원됩니다 ( &lt;a href=&quot;edebug-options#Edebug-Options&quot;&gt;Edebug 옵션&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="443f8535af5feac9009b9eb74d0bd0bbb542eca8" translate="yes" xml:space="preserve">
          <source>The overlay-arrow string is displayed in any given buffer if the value of &lt;code&gt;overlay-arrow-position&lt;/code&gt; in that buffer points into that buffer. Thus, it is possible to display multiple overlay arrow strings by creating buffer-local bindings of &lt;code&gt;overlay-arrow-position&lt;/code&gt;. However, it is usually cleaner to use &lt;code&gt;overlay-arrow-variable-list&lt;/code&gt; to achieve this result.</source>
          <target state="translated">해당 버퍼의 &lt;code&gt;overlay-arrow-position&lt;/code&gt; 값이 해당 버퍼를 가리키는 경우 오버레이 화살표 문자열은 지정된 버퍼에 표시됩니다 . 따라서 &lt;code&gt;overlay-arrow-position&lt;/code&gt; 의 버퍼 로컬 바인딩을 생성하여 여러 오버레이 화살표 문자열을 표시 할 수 있습니다 . 그러나 일반적 으로이 결과를 얻으 려면 &lt;code&gt;overlay-arrow-variable-list&lt;/code&gt; 를 사용하는 것이 더 깨끗합니다 .</target>
        </trans-unit>
        <trans-unit id="0c4e900964a2a9c8ee2b6d6918d8e7e1d4ae357a" translate="yes" xml:space="preserve">
          <source>The package&amp;rsquo;s main or only group should be a member of one or more of the standard customization groups. (To display the full list of them, use</source>
          <target state="translated">패키지의 기본 또는 유일한 그룹은 하나 이상의 표준 사용자 지정 그룹의 구성원이어야합니다. (전체 목록을 표시하려면</target>
        </trans-unit>
        <trans-unit id="056f01b4a46a37e98b55727e87a95ecf4b9b9d41" translate="yes" xml:space="preserve">
          <source>The parameter&amp;rsquo;s second element is either one of the symbols &lt;code&gt;window&lt;/code&gt; or &lt;code&gt;frame&lt;/code&gt;, or a list whose elements are the buffer shown in &lt;var&gt;window&lt;/var&gt; before, that buffer&amp;rsquo;s window start and window point positions, and &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s height at that time. If that buffer is still live when &lt;var&gt;window&lt;/var&gt; is quit, then this function may reuse &lt;var&gt;window&lt;/var&gt; to display it.</source>
          <target state="translated">매개 변수의 두 번째 요소는 기호 &lt;code&gt;window&lt;/code&gt; 또는 &lt;code&gt;frame&lt;/code&gt; 중 하나 이거나 해당 요소가 이전 &lt;var&gt;window&lt;/var&gt; 표시된 버퍼 인 목록 , 해당 버퍼의 창 시작 및 창 지점 위치, 해당 시점의 &lt;var&gt;window&lt;/var&gt; 높이입니다. &lt;var&gt;window&lt;/var&gt; 종료 될 때 해당 버퍼가 여전히 활성 상태 이면이 함수는 &lt;var&gt;window&lt;/var&gt; 을 다시 표시 하여 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0a39a896d6a8873b9effa21ba5ee259cb0e77fd" translate="yes" xml:space="preserve">
          <source>The parameters described below provide support for resizing a frame by dragging its internal borders with the mouse. They also allow moving a frame with the mouse by dragging the header line of its topmost or the mode line of its bottommost window.</source>
          <target state="translated">아래 설명 된 매개 변수는 마우스로 내부 테두리를 드래그하여 프레임 크기 조정을 지원합니다. 또한 맨 위의 헤더 라인이나 맨 아래 창의 모드 라인을 드래그하여 마우스로 프레임을 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c21c17502bd64c3a71bdbc3fc9084a51f8eb952" translate="yes" xml:space="preserve">
          <source>The parent keymap of all &lt;code&gt;local-function-key-map&lt;/code&gt; (q.v.) instances.</source>
          <target state="translated">모든 &lt;code&gt;local-function-key-map&lt;/code&gt; (qv) 인스턴스 의 상위 키맵입니다 .</target>
        </trans-unit>
        <trans-unit id="83241215538033ded1beeee2b0b4fdef97b639a3" translate="yes" xml:space="preserve">
          <source>The parsing facilities of Emacs consider a string as a single token. The usual syntactic meanings of the characters in the string are suppressed.</source>
          <target state="translated">Emacs의 구문 분석 기능은 문자열을 단일 토큰으로 간주합니다. 문자열에있는 문자의 일반적인 구문 의미는 억제됩니다.</target>
        </trans-unit>
        <trans-unit id="a4782b103645e67a505ec03626df6bb33c90727f" translate="yes" xml:space="preserve">
          <source>The parsing skips spaces and tabs at the beginning of &lt;var&gt;string&lt;/var&gt;, then reads as much of &lt;var&gt;string&lt;/var&gt; as it can interpret as a number in the given base. (On some systems it ignores other whitespace at the beginning, not just spaces and tabs.) If &lt;var&gt;string&lt;/var&gt; cannot be interpreted as a number, this function returns 0.</source>
          <target state="translated">구문 분석은 &lt;var&gt;string&lt;/var&gt; 시작 부분의 공백과 탭을 건너 뛴 다음 주어진 밑수에서 숫자로 해석 할 수있는 만큼의 &lt;var&gt;string&lt;/var&gt; 을 읽습니다 . (일부 시스템에서는 공백과 탭뿐 아니라 처음에 다른 공백을 무시합니다.) &lt;var&gt;string&lt;/var&gt; 을 숫자로 해석 할 수없는 경우이 함수는 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d08be782a53bbda1ba8dddd6886664346e48d767" translate="yes" xml:space="preserve">
          <source>The parsing technique used by SMIE does not allow tokens to behave differently in different contexts. For most programming languages, this manifests itself by precedence conflicts when converting the BNF grammar.</source>
          <target state="translated">SMIE에서 사용하는 구문 분석 기술은 토큰이 다른 컨텍스트에서 다르게 작동하는 것을 허용하지 않습니다. 대부분의 프로그래밍 언어에서 이는 BNF 문법을 변환 할 때 우선 순위 충돌로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="fbb6c29935ae3da3bb37e989df0289bf03fba226" translate="yes" xml:space="preserve">
          <source>The part of the scroll bar on which the click occurred. It is one of the symbols &lt;code&gt;handle&lt;/code&gt; (the scroll bar handle), &lt;code&gt;above-handle&lt;/code&gt; (the area above the handle), &lt;code&gt;below-handle&lt;/code&gt; (the area below the handle), &lt;code&gt;up&lt;/code&gt; (the up arrow at one end of the scroll bar), or &lt;code&gt;down&lt;/code&gt; (the down arrow at one end of the scroll bar).</source>
          <target state="translated">클릭이 발생한 스크롤 막대 부분입니다. 심볼 &lt;code&gt;handle&lt;/code&gt; (스크롤 막대 핸들), &lt;code&gt;above-handle&lt;/code&gt; 위 (핸들 위 영역), &lt;code&gt;below-handle&lt;/code&gt; 아래 (핸들 아래 영역), &lt;code&gt;up&lt;/code&gt; (스크롤 막대 한쪽 끝에있는 위쪽 화살표), 또는 &lt;code&gt;down&lt;/code&gt; (스크롤 막대의 한쪽 끝에있는 아래쪽 화살표).</target>
        </trans-unit>
        <trans-unit id="1168a5f90813f2fcee380e2f6e20037287e336c0" translate="yes" xml:space="preserve">
          <source>The parts of a lambda expression.</source>
          <target state="translated">람다 식의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="b276da95227712619d809e264d610c7532aff153" translate="yes" xml:space="preserve">
          <source>The path to a sound file to play when the notification pops up.</source>
          <target state="translated">알림이 표시 될 때 재생할 사운드 파일의 경로입니다.</target>
        </trans-unit>
        <trans-unit id="3eb392db1262ef722d3f867992b904857965d5b1" translate="yes" xml:space="preserve">
          <source>The pcase macro</source>
          <target state="translated">pcase 매크로</target>
        </trans-unit>
        <trans-unit id="bfe752af47d77462d05ad0c5ca61909d42248960" translate="yes" xml:space="preserve">
          <source>The pcase patterns that are useful for destructuring bindings are generally those described in &lt;a href=&quot;backquote-patterns#Backquote-Patterns&quot;&gt;Backquote Patterns&lt;/a&gt;, since they express a specification of the structure of objects that will match.</source>
          <target state="translated">바인딩을 해체하는 데 유용한 pcase 패턴은 일반적으로 일치 할 개체 구조의 사양을 표현하기 때문에 &lt;a href=&quot;backquote-patterns#Backquote-Patterns&quot;&gt;Backquote Patterns에&lt;/a&gt; 설명 된 패턴 입니다.</target>
        </trans-unit>
        <trans-unit id="85e5e6070e7ace2a864fd54495dc677c9fe2f335" translate="yes" xml:space="preserve">
          <source>The percentage of the CPU time used by the process since it started. The corresponding &lt;var&gt;value&lt;/var&gt; is a floating-point number between 0 and 100.</source>
          <target state="translated">시작된 이후 프로세스에서 사용한 CPU 시간의 백분율입니다. 해당 &lt;var&gt;value&lt;/var&gt; 은 0에서 100 사이의 부동 소수점 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="74a0e3e0b308a0aa69a778516c8eba726d6c3004" translate="yes" xml:space="preserve">
          <source>The percentage of the buffer text above the &lt;strong&gt;top&lt;/strong&gt; of window, or &amp;lsquo;</source>
          <target state="translated">창 &lt;strong&gt;상단&lt;/strong&gt; 위의 버퍼 텍스트 백분율 또는 '</target>
        </trans-unit>
        <trans-unit id="5174826a919540ce04dc971e49d9dcc6a90c357a" translate="yes" xml:space="preserve">
          <source>The percentage of the buffer text that is above the &lt;strong&gt;bottom&lt;/strong&gt; of the window (which includes the text visible in the window, as well as the text above the top), plus &amp;lsquo;</source>
          <target state="translated">창 &lt;strong&gt;하단&lt;/strong&gt; 위에있는 버퍼 텍스트의 백분율 (창에 표시되는 텍스트 및 상단 위의 텍스트 포함)에 '</target>
        </trans-unit>
        <trans-unit id="0cf9d906bacdebd3353589bccc8f1c56cff833ae" translate="yes" xml:space="preserve">
          <source>The percentage of the total physical memory installed on the machine used by the process&amp;rsquo;s resident set. The value is a floating-point number between 0 and 100.</source>
          <target state="translated">프로세스의 상주 세트에서 사용하는 시스템에 설치된 총 실제 메모리의 백분율입니다. 값은 0에서 100 사이의 부동 소수점 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="745b0bf167534b10d93c434c0e1e395113673fc2" translate="yes" xml:space="preserve">
          <source>The percentages of text above both the &lt;strong&gt;top&lt;/strong&gt; and the &lt;strong&gt;bottom&lt;/strong&gt; of the window, separated by &amp;lsquo;</source>
          <target state="translated">창의 &lt;strong&gt;상단&lt;/strong&gt; 과 &lt;strong&gt;하단&lt;/strong&gt; 모두 위의 텍스트 비율 ( '로 구분)</target>
        </trans-unit>
        <trans-unit id="0de9363c585da842dc94d7cb92e52e9a964df31b" translate="yes" xml:space="preserve">
          <source>The pixel heights of a window&amp;rsquo;s mode and header line can be retrieved with the functions given below. Their return value is usually accurate unless the window has not been displayed before: In that case, the return value is based on an estimate of the font used for the window&amp;rsquo;s frame.</source>
          <target state="translated">윈도우의 모드와 헤더 라인의 픽셀 높이는 아래에 주어진 함수로 검색 할 수 있습니다. 반환 값은 일반적으로 창이 이전에 표시되지 않은 경우가 아니면 정확합니다.이 경우 반환 값은 창 프레임에 사용 된 글꼴 추정치를 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="43c14cab8a2b2bb269e27efdcb44906c088989c3" translate="yes" xml:space="preserve">
          <source>The pixel size of the font used to open the font.</source>
          <target state="translated">글꼴을 여는 데 사용되는 글꼴의 픽셀 크기입니다.</target>
        </trans-unit>
        <trans-unit id="0d3304078e97e6d9fcd53507ef3658705f5b3745" translate="yes" xml:space="preserve">
          <source>The pixel size of the font.</source>
          <target state="translated">글꼴의 픽셀 크기입니다.</target>
        </trans-unit>
        <trans-unit id="d5e8626e71efeeae5801637fe0d104f5743bf82a" translate="yes" xml:space="preserve">
          <source>The pixel widths of the left and right fringes in this window. A value of -1 means use the values of the frame.</source>
          <target state="translated">이 창에서 왼쪽 및 오른쪽 언저리의 픽셀 너비입니다. 값 -1은 프레임 값을 사용함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="a476ed7f718dc326836a3ad0a813832b8273668d" translate="yes" xml:space="preserve">
          <source>The place where you insert &amp;lsquo;</source>
          <target state="translated">'를 삽입하는 위치</target>
        </trans-unit>
        <trans-unit id="489704a85a579cab25a1f96c62ae86111efc895a" translate="yes" xml:space="preserve">
          <source>The places within a function where Edebug can stop execution are called &lt;em&gt;stop points&lt;/em&gt;. These occur both before and after each subexpression that is a list, and also after each variable reference. Here we use periods to show the stop points in the function &lt;code&gt;fac&lt;/code&gt;:</source>
          <target state="translated">Edebug가 실행을 중지 할 수있는 함수 내의 위치를 &lt;em&gt;중지 지점&lt;/em&gt; 이라고 &lt;em&gt;합니다&lt;/em&gt; . 이는 목록 인 각 하위 표현식 앞뒤와 각 변수 참조 뒤에 발생합니다. 여기서는 &lt;code&gt;fac&lt;/code&gt; 함수의 중지 지점을 표시하기 위해 마침표를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="31d74db390eea1284d7b4e181bb2f481d81da20c" translate="yes" xml:space="preserve">
          <source>The plural &amp;ldquo;frames&amp;rdquo; in the previous paragraph is deliberate: while Emacs itself has only one selected frame, Emacs can have frames on many different terminals (recall that a connection to a window system counts as a terminal), and each terminal has its own idea of which frame has input focus. When you set the input focus to a frame, you set the focus for that frame&amp;rsquo;s terminal, but frames on other terminals may still remain focused.</source>
          <target state="translated">이전 단락에서 복수의 &quot;프레임&quot;은 의도적입니다. Emacs 자체에는 하나의 선택된 프레임 만있는 반면 Emacs는 여러 다른 터미널에 프레임을 가질 수 있으며 (윈도우 시스템에 대한 연결은 터미널로 간주 됨) 각 터미널에는 고유 한 프레임이 있습니다. 입력 포커스가있는 프레임에 대한 아이디어. 입력 포커스를 프레임에 설정하면 해당 프레임의 터미널에 대한 포커스가 설정되지만 다른 터미널의 프레임은 여전히 ​​포커스가 유지 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce65815e1a28f37a72576e7cbec00483473f471a" translate="yes" xml:space="preserve">
          <source>The point of running a program through the shell, rather than directly with &lt;code&gt;make-process&lt;/code&gt; or &lt;code&gt;start-process&lt;/code&gt;, is so that you can employ shell features such as wildcards in the arguments. It follows that if you include any arbitrary user-specified arguments in the command, you should quote them with &lt;code&gt;shell-quote-argument&lt;/code&gt; first, so that any special shell characters do &lt;em&gt;not&lt;/em&gt; have their special shell meanings. See &lt;a href=&quot;shell-arguments#Shell-Arguments&quot;&gt;Shell Arguments&lt;/a&gt;. Of course, when executing commands based on user input you should also consider the security implications.</source>
          <target state="translated">&lt;code&gt;make-process&lt;/code&gt; 또는 &lt;code&gt;start-process&lt;/code&gt; 를 직접 사용 하는 대신 셸을 통해 프로그램을 실행하는 요점은 인수에 와일드 카드와 같은 셸 기능을 사용할 수 있다는 것입니다. 명령에 임의의 사용자 지정 인수를 포함하는 경우 먼저 &lt;code&gt;shell-quote-argument&lt;/code&gt; 해야 특수 쉘 문자가 특수 쉘 의미를 갖지 &lt;em&gt;않게&lt;/em&gt; 됩니다. &lt;a href=&quot;shell-arguments#Shell-Arguments&quot;&gt;쉘 인수를&lt;/a&gt; 참조하십시오 . 물론 사용자 입력을 기반으로 명령을 실행할 때 보안 관련 사항도 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="87e05b91e6233e17b204f23015097c7049303099" translate="yes" xml:space="preserve">
          <source>The position at which the line being indented begins.</source>
          <target state="translated">들여 쓰기되는 줄이 시작되는 위치입니다.</target>
        </trans-unit>
        <trans-unit id="45b07b40e31e169ede72cfe22029fabdc54bc98b" translate="yes" xml:space="preserve">
          <source>The position in the buffer for which the line number is known, or zero meaning none is known. If it is -1, don&amp;rsquo;t display the line number as long as the window shows that buffer.</source>
          <target state="translated">줄 번호가 알려진 버퍼의 위치 또는 알려진 것이 없음을 의미하는 0입니다. -1이면 창에 해당 버퍼가 표시되는 한 줄 번호를 표시하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="7bb41d39783192e6aaaa6d09fb0dcd6b9d067af6" translate="yes" xml:space="preserve">
          <source>The position in the string where the click occurred.</source>
          <target state="translated">클릭이 발생한 문자열의 위치입니다.</target>
        </trans-unit>
        <trans-unit id="1c5737b61d1133d53c07a40026bed5c9ffc696e8" translate="yes" xml:space="preserve">
          <source>The position of a frame on its display.</source>
          <target state="translated">디스플레이에서 프레임의 위치입니다.</target>
        </trans-unit>
        <trans-unit id="887258f07e45dd70c1b6e53e04e7f416f5a7b904" translate="yes" xml:space="preserve">
          <source>The position of point, as an integer (see &lt;a href=&quot;point#Point&quot;&gt;Point&lt;/a&gt;). No I/O.</source>
          <target state="translated">정수로 표시되는 점의 위치입니다 ( &lt;a href=&quot;point#Point&quot;&gt;Point&lt;/a&gt; 참조 ). I / O가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6403590e242da2f2207180f395d2c07e997ed88a" translate="yes" xml:space="preserve">
          <source>The position of the frame on the screen.</source>
          <target state="translated">화면에서 프레임의 위치입니다.</target>
        </trans-unit>
        <trans-unit id="255ed0f6aab596c870f5c23defcace62009a4b51" translate="yes" xml:space="preserve">
          <source>The position of the mark, as an integer. No I/O.</source>
          <target state="translated">마크의 위치 (정수). I / O가 없습니다.</target>
        </trans-unit>
        <trans-unit id="a5dd7b877105dceee61a4c59515a66464dc839be" translate="yes" xml:space="preserve">
          <source>The position of the tool bar when Emacs was built with GTK+. Its value can be one of &lt;code&gt;top&lt;/code&gt;, &lt;code&gt;bottom&lt;/code&gt;&lt;code&gt;left&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;. The default is &lt;code&gt;top&lt;/code&gt;.</source>
          <target state="translated">Emacs가 GTK +로 빌드되었을 때 도구 모음의 위치. 그 값은 &lt;code&gt;top&lt;/code&gt; , &lt;code&gt;bottom&lt;/code&gt; &lt;code&gt;left&lt;/code&gt; , &lt;code&gt;right&lt;/code&gt; 중 하나 일 수 있습니다 . 기본값은 &lt;code&gt;top&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="02d4165115759fe0837c49ced5e39ea743ea4c2a" translate="yes" xml:space="preserve">
          <source>The position of the top left corner of the native frame specifies the &lt;em&gt;native position&lt;/em&gt; of the frame. (1)&amp;ndash;(3) in the drawing above indicate that position for the various builds:</source>
          <target state="translated">기본 프레임의 왼쪽 위 모서리 &lt;em&gt;위치&lt;/em&gt; 는 프레임 의 &lt;em&gt;기본 위치&lt;/em&gt; 를 지정합니다 . 위 그림에서 (1) &amp;ndash; (3)은 다양한 빌드에 대한 위치를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="833e5a5239b46b2d55c382c18b023ecd55ad49ca" translate="yes" xml:space="preserve">
          <source>The position of the upper left corner of the outer frame (indicated by &amp;lsquo;</source>
          <target state="translated">외부 프레임의 왼쪽 상단 모서리 위치 ( '로 표시)</target>
        </trans-unit>
        <trans-unit id="8410a3b5f6f9e6c84d904b172515815de91f0dd2" translate="yes" xml:space="preserve">
          <source>The position, in pixels, of the left outer edge of the frame with respect to the left edge of the frame&amp;rsquo;s display or parent frame. It can be specified in one of the following ways.</source>
          <target state="translated">프레임 디스플레이 또는 상위 프레임의 왼쪽 가장자리에 대한 프레임의 왼쪽 외부 가장자리 위치 (픽셀)입니다. 다음 방법 중 하나로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="159bfe6471c89158a22673c87af74200df998625" translate="yes" xml:space="preserve">
          <source>The possible values for an actual subprocess are:</source>
          <target state="translated">실제 하위 프로세스에 가능한 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ca9c70ab4f2597d1a37484e4797e646e200cc36c" translate="yes" xml:space="preserve">
          <source>The preceding examples all use sequencing patterns which include the &lt;var&gt;symbol&lt;/var&gt; sub-pattern in some way. Here are some important details about that usage.</source>
          <target state="translated">앞의 예제는 모두 어떤 식 으로든 &lt;var&gt;symbol&lt;/var&gt; 하위 패턴을 포함하는 시퀀싱 패턴을 사용 합니다. 다음은 해당 사용법에 대한 몇 가지 중요한 세부 정보입니다.</target>
        </trans-unit>
        <trans-unit id="a258153ccf268c951438b192904eade1c144e0c6" translate="yes" xml:space="preserve">
          <source>The precise effect of adding a value depends on the customization type of &lt;var&gt;symbol&lt;/var&gt;.</source>
          <target state="translated">값 추가의 정확한 효과는 &lt;var&gt;symbol&lt;/var&gt; 의 사용자 정의 유형에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="3f4009f97f05ca5f3cb51352b6efa1949bc23635" translate="yes" xml:space="preserve">
          <source>The precise meaning of a value of &lt;code&gt;nil&lt;/code&gt; for this option depends on the toolkit used. Dragging the external border with the mouse is done character-wise provided the window manager is willing to process the corresponding size hints. Calling &lt;code&gt;set-frame-size&lt;/code&gt; (see below) with arguments that do not specify the frame size as an integer multiple of its character size, however, may: be ignored, cause a rounding (GTK+), or be accepted (Lucid, Motif, MS-Windows).</source>
          <target state="translated">이 옵션에 대한 &lt;code&gt;nil&lt;/code&gt; 값의 정확한 의미는 사용 된 툴킷에 따라 다릅니다. 창 관리자가 해당 크기 힌트를 처리 할 의사가있는 경우 마우스로 외부 테두리를 드래그하는 것은 문자 단위로 수행됩니다. 호출 &lt;code&gt;set-frame-size&lt;/code&gt; 의 문자 크기의 정수 배수로 프레임 크기를 지정하지 않은 인수 (아래 참조) 그러나, 수, 반올림 (GTK +) 원인, 무시, 또는 (맑은 모티브 접수 MS-Windows).</target>
        </trans-unit>
        <trans-unit id="b4aa737004ad2535ebe02bb899113024dc279e7a" translate="yes" xml:space="preserve">
          <source>The precise meaning of the event parameters and the way these parameters are used to display the help-echo text are described in &lt;a href=&quot;special-properties#Text-help_002decho&quot;&gt;Text help-echo&lt;/a&gt;.</source>
          <target state="translated">이벤트 매개 변수의 정확한 의미와 이러한 매개 변수가 help-echo 텍스트를 표시하는 데 사용되는 방법은 &lt;a href=&quot;special-properties#Text-help_002decho&quot;&gt;Text help-echo에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c34b9bbf535e3965b815554ff0467b7f149d988d" translate="yes" xml:space="preserve">
          <source>The previous buffer is usually the buffer shown before the buffer currently shown in &lt;var&gt;window&lt;/var&gt;. However, a buffer that has been buried or killed, or has been already shown by a recent invocation of &lt;code&gt;switch-to-prev-buffer&lt;/code&gt;, does not qualify as previous buffer.</source>
          <target state="translated">이전 버퍼는 일반적으로 현재 &lt;var&gt;window&lt;/var&gt; 표시된 버퍼 이전에 표시된 버퍼 입니다. 그러나 묻혔거나 죽었거나 최근에 &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; 를 호출하여 이미 표시된 버퍼 는 이전 버퍼로 인정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="28721bd17842d6dccb7fd270c15c4194e8d5baba" translate="yes" xml:space="preserve">
          <source>The primary use of this function is as a subroutine by constructs that define or alter functions, like &lt;code&gt;defun&lt;/code&gt; or &lt;code&gt;advice-add&lt;/code&gt; (see &lt;a href=&quot;advising-functions#Advising-Functions&quot;&gt;Advising Functions&lt;/a&gt;). You can also use it to give a symbol a function definition that is not a function, e.g., a keyboard macro (see &lt;a href=&quot;keyboard-macros#Keyboard-Macros&quot;&gt;Keyboard Macros&lt;/a&gt;):</source>
          <target state="translated">이 기능의 주요 용도는 같은 정의 구조 또는 바꾼다 기능에 의한 서브 루틴이다 &lt;code&gt;defun&lt;/code&gt; 는 또는 &lt;code&gt;advice-add&lt;/code&gt; (참조 &lt;a href=&quot;advising-functions#Advising-Functions&quot;&gt;상담 기능&lt;/a&gt; ). 또한이를 사용하여 기능이 아닌 기능 정의 (예 : &lt;a href=&quot;keyboard-macros#Keyboard-Macros&quot;&gt;키보드 매크로&lt;/a&gt; )를 기호에 제공 할 수 있습니다 (키보드 매크로 참조 ).</target>
        </trans-unit>
        <trans-unit id="ba9b5b776cc5667a85cd400075ca47d55ca09c2c" translate="yes" xml:space="preserve">
          <source>The primitive that extracts text from the buffer along with its properties is &lt;code&gt;buffer-substring&lt;/code&gt;. Before examining the properties, this function runs the abnormal hook &lt;code&gt;buffer-access-fontify-functions&lt;/code&gt;.</source>
          <target state="translated">속성과 함께 버퍼에서 텍스트를 추출하는 기본 요소는 &lt;code&gt;buffer-substring&lt;/code&gt; 입니다. 속성을 검사하기 전에이 함수는 비정상적인 후크 &lt;code&gt;buffer-access-fontify-functions&lt;/code&gt; 를 실행 합니다.</target>
        </trans-unit>
        <trans-unit id="6a90a548ae4af1e7a922a25155c161c7315ce8da" translate="yes" xml:space="preserve">
          <source>The primitive way to create a byte-code object is with &lt;code&gt;make-byte-code&lt;/code&gt;:</source>
          <target state="translated">바이트 코드 객체를 만드는 기본 방법은 &lt;code&gt;make-byte-code&lt;/code&gt; 를 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="4906a197371ef069deb8bf9326d82ffeae4a7205" translate="yes" xml:space="preserve">
          <source>The primitives for changing properties apply to a specified range of text in a buffer or string. The function &lt;code&gt;set-text-properties&lt;/code&gt; (see end of section) sets the entire property list of the text in that range; more often, it is useful to add, change, or delete just certain properties specified by name.</source>
          <target state="translated">속성 변경을위한 기본 요소는 버퍼 또는 문자열의 지정된 텍스트 범위에 적용됩니다. &lt;code&gt;set-text-properties&lt;/code&gt; 함수 (섹션 끝 부분 참조)는 해당 범위에있는 텍스트의 전체 속성 목록을 설정합니다. 더 자주 이름으로 지정된 특정 속성 만 추가, 변경 또는 삭제하는 것이 유용합니다.</target>
        </trans-unit>
        <trans-unit id="86e6972405ceac8fb0c2ebcbb1d084d74c15e137" translate="yes" xml:space="preserve">
          <source>The principal function for creating a hash table is &lt;code&gt;make-hash-table&lt;/code&gt;.</source>
          <target state="translated">해시 테이블을 생성하는 주요 기능은 &lt;code&gt;make-hash-table&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3e0ef3a61ced98eb5fb2f872d19a707b38cfe6c5" translate="yes" xml:space="preserve">
          <source>The principal purpose of coding systems is for use in reading and writing files. The function &lt;code&gt;insert-file-contents&lt;/code&gt; uses a coding system to decode the file data, and &lt;code&gt;write-region&lt;/code&gt; uses one to encode the buffer contents.</source>
          <target state="translated">코딩 시스템의 주요 목적은 파일을 읽고 쓰는 데 사용됩니다. &lt;code&gt;insert-file-contents&lt;/code&gt; 함수 는 코딩 시스템을 사용하여 파일 데이터를 디코딩하고 &lt;code&gt;write-region&lt;/code&gt; 은 하나를 사용하여 버퍼 콘텐츠를 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="55a4ae7918bc297ffd67f49ed5d08ef37025a3dc" translate="yes" xml:space="preserve">
          <source>The print name cell always holds a string, and cannot be changed. Each of the other three cells can be set to any Lisp object.</source>
          <target state="translated">인쇄 이름 셀은 항상 문자열을 보유하며 변경할 수 없습니다. 다른 세 개의 셀은 각각 Lisp 개체로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de95f3a3b46a96121feaa824d316764b0883107a" translate="yes" xml:space="preserve">
          <source>The print name cell holds the string that is the name of a symbol. Since symbols are represented textually by their names, it is important not to have two symbols with the same name. The Lisp reader ensures this: every time it reads a symbol, it looks for an existing symbol with the specified name before it creates a new one. To get a symbol&amp;rsquo;s name, use the function &lt;code&gt;symbol-name&lt;/code&gt; (see &lt;a href=&quot;creating-symbols#Creating-Symbols&quot;&gt;Creating Symbols&lt;/a&gt;).</source>
          <target state="translated">인쇄 이름 셀에는 기호 이름 인 문자열이 있습니다. 기호는 이름으로 텍스트로 표현되므로 이름이 같은 두 개의 기호를 사용하지 않는 것이 중요합니다. Lisp 리더는이를 보장합니다. 심볼을 읽을 때마다 새 심볼을 만들기 전에 지정된 이름을 가진 기존 심볼을 찾습니다. 심볼의 이름을 얻으려면 &lt;code&gt;symbol-name&lt;/code&gt; 함수를 사용하십시오 ( &lt;a href=&quot;creating-symbols#Creating-Symbols&quot;&gt;심볼 생성&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="2bbc34bf200918e9a448ed9f1f2b1f066e970b26" translate="yes" xml:space="preserve">
          <source>The printed form represents up to 8 boolean values as a single character:</source>
          <target state="translated">인쇄 된 양식은 단일 문자로 최대 8 개의 부울 값을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="12644b40b0774ec2e789694cfc7abf62c019cde5" translate="yes" xml:space="preserve">
          <source>The printed representation and read syntax for a byte-code function object is like that for a vector, with an additional &amp;lsquo;</source>
          <target state="translated">바이트 코드 함수 객체에 대한 인쇄 된 표현 및 읽기 구문은 벡터의 경우와 유사하며 '</target>
        </trans-unit>
        <trans-unit id="93d512217d9e0e619c1036f6280703870832034c" translate="yes" xml:space="preserve">
          <source>The printed representation for a hash table consists of &amp;lsquo;</source>
          <target state="translated">해시 테이블의 인쇄 된 표현은 '</target>
        </trans-unit>
        <trans-unit id="861954f964e54658232242a23ea2b7ee8994c956" translate="yes" xml:space="preserve">
          <source>The printed representation for floating-point numbers requires either a decimal point (with at least one digit following), an exponent, or both. For example, &amp;lsquo;</source>
          <target state="translated">부동 소수점 숫자에 대한 인쇄 된 표현에는 소수점 (최소 한 자리 뒤에 숫자 포함), 지수 또는 둘 다가 필요합니다. 예 : '</target>
        </trans-unit>
        <trans-unit id="7b99966b7387dd5ed35f73f081dbe0bcb6cc5e9b" translate="yes" xml:space="preserve">
          <source>The printed representation of a bool-vector is like a string, except that it begins with &amp;lsquo;</source>
          <target state="translated">bool-vector의 인쇄 된 표현은 '로 시작하는 것을 제외하고는 문자열과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9a73160413b74c1de6679be1eae2e2a5562706a0" translate="yes" xml:space="preserve">
          <source>The printed representation of a char-table is like a vector except that there is an extra &amp;lsquo;</source>
          <target state="translated">문자 테이블의 인쇄 된 표현은 추가 '가 있다는 점을 제외하면 벡터와 같습니다.</target>
        </trans-unit>
        <trans-unit id="cf4d2204ede2ec7542b976b427c02ab6ac905744" translate="yes" xml:space="preserve">
          <source>The printed representation of a vector consists of a left square bracket, the elements, and a right square bracket. This is also the read syntax. Like numbers and strings, vectors are considered constants for evaluation.</source>
          <target state="translated">벡터의 인쇄 된 표현은 왼쪽 대괄호, 요소 및 오른쪽 대괄호로 구성됩니다. 이것은 또한 읽기 구문입니다. 숫자 및 문자열과 마찬가지로 벡터는 평가를위한 상수로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="54bdda2e2c897bbee3fd6ea2ce6150e050bbdbf0" translate="yes" xml:space="preserve">
          <source>The printed representation of an interned symbol whose name is an empty string (see &lt;a href=&quot;symbol-type#Symbol-Type&quot;&gt;Symbol Type&lt;/a&gt;).</source>
          <target state="translated">이름이 빈 문자열 인 인턴 심볼의 인쇄 된 표현입니다 ( &lt;a href=&quot;symbol-type#Symbol-Type&quot;&gt;심볼 유형&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="b6b4f81ab9ddc9b498748d084ab114136d13e0d2" translate="yes" xml:space="preserve">
          <source>The printed representation of an uninterned symbol whose name is &lt;var&gt;foo&lt;/var&gt; is &amp;lsquo;</source>
          <target state="translated">이름이 &lt;var&gt;foo&lt;/var&gt; 인 uninterned 기호의 인쇄 된 표현 은 '</target>
        </trans-unit>
        <trans-unit id="f0d146789656a2ca889b28283579fa331b709ea3" translate="yes" xml:space="preserve">
          <source>The printed representation of records is &amp;lsquo;</source>
          <target state="translated">기록의 인쇄 된 표현은 '</target>
        </trans-unit>
        <trans-unit id="06414aa54aa49ed289b3f642280e72ea07845a4c" translate="yes" xml:space="preserve">
          <source>The priority matters when two or more overlays cover the same character and both specify the same property; the one whose &lt;code&gt;priority&lt;/code&gt; value is larger overrides the other. (For the &lt;code&gt;face&lt;/code&gt; property, the higher priority overlay&amp;rsquo;s value does not completely override the other value; instead, its face attributes override the face attributes of the lower priority &lt;code&gt;face&lt;/code&gt; property.) If two overlays have the same priority value, and one is nested in the other, then the inner one will prevail over the outer one. If neither is nested in the other then you should not make assumptions about which overlay will prevail.</source>
          <target state="translated">두 개 이상의 오버레이가 동일한 문자를 덮고 둘 다 동일한 속성을 지정하는 경우 우선 순위가 중요합니다. 그 하나의 &lt;code&gt;priority&lt;/code&gt; 값이 더 큰 우선에게 다른 것이다. 합니다 (들어 &lt;code&gt;face&lt;/code&gt; 대신, 얼굴은 낮은 우선 순위의 얼굴 특성을 무시 속성 특성, 우선 순위가 높은 오버레이의 값은 완전히 다른 값을 대체하지 않습니다 &lt;code&gt;face&lt;/code&gt; 이 오버레이가 같은 우선 순위 값이있는 경우, 하나는 중첩되는 속성을.) 다른 하나는 안쪽이 바깥 쪽보다 우세합니다. 둘 다 다른 항목에 중첩되어 있지 않으면 어떤 오버레이가 우세할지 가정하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="e73afd850ba19d88fffc870b34d4546ef04a4eba" translate="yes" xml:space="preserve">
          <source>The process ID of the parent process, a number.</source>
          <target state="translated">상위 프로세스의 프로세스 ID, 숫자.</target>
        </trans-unit>
        <trans-unit id="53e1a9ea303ee6836b551778e58f2f51e300eedc" translate="yes" xml:space="preserve">
          <source>The process group ID of the process, a number.</source>
          <target state="translated">프로세스의 프로세스 그룹 ID, 숫자.</target>
        </trans-unit>
        <trans-unit id="4ccf440991f7f0652996b8ab7560a4dbe5b3aace" translate="yes" xml:space="preserve">
          <source>The process status, as &lt;code&gt;process-status&lt;/code&gt; should return it. This is a Lisp symbol, a cons cell, or a list.</source>
          <target state="translated">같은 프로세스 상태, &lt;code&gt;process-status&lt;/code&gt; 를 반환해야합니다. 이것은 Lisp 기호, 단점 셀 또는 목록입니다.</target>
        </trans-unit>
        <trans-unit id="69ecf0580268b93750c7e889a04309c3293a5f2b" translate="yes" xml:space="preserve">
          <source>The processes are shown in a buffer named</source>
          <target state="translated">프로세스는 다음과 같은 버퍼에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="6c8f30c53cf4f4d39e77991527ad73dbc1793851" translate="yes" xml:space="preserve">
          <source>The product name of the server.</source>
          <target state="translated">서버의 제품 이름입니다.</target>
        </trans-unit>
        <trans-unit id="0cd39baec68fc236a0a093df363f5e95bd2c4fb6" translate="yes" xml:space="preserve">
          <source>The profiler report buffer shows, on each line, a function that was called, followed by how much resources (cpu or memory) it used in absolute and percentage terms since profiling started. If a given line has a &amp;lsquo;</source>
          <target state="translated">프로파일 러 보고서 버퍼는 각 행에 호출 된 함수와 프로파일 링이 시작된 이후 절대 및 백분율 용어로 사용 된 리소스 (cpu 또는 메모리)의 양을 보여줍니다. 주어진 줄에 '</target>
        </trans-unit>
        <trans-unit id="d9d8457c45fc52a797df2f33e4e4ba6a34bec404" translate="yes" xml:space="preserve">
          <source>The prompt string can use &amp;lsquo;</source>
          <target state="translated">프롬프트 문자열은 '</target>
        </trans-unit>
        <trans-unit id="0ea085744f883658e286f289c21d5bb3c923b174" translate="yes" xml:space="preserve">
          <source>The proper place to use &lt;code&gt;defalias&lt;/code&gt; is where a specific function name is being defined&amp;mdash;especially where that name appears explicitly in the source file being loaded. This is because &lt;code&gt;defalias&lt;/code&gt; records which file defined the function, just like &lt;code&gt;defun&lt;/code&gt; (see &lt;a href=&quot;unloading#Unloading&quot;&gt;Unloading&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;defalias&lt;/code&gt; 를 사용하는 적절한 위치 는 특정 함수 이름이 정의되는 위치입니다. 특히로드되는 소스 파일에 해당 이름이 명시 적으로 나타나는 위치입니다. 이것은 &lt;code&gt;defalias&lt;/code&gt; 가 &lt;code&gt;defun&lt;/code&gt; 처럼 함수를 정의한 파일을 기록 하기 때문입니다 ( &lt;a href=&quot;unloading#Unloading&quot;&gt;Unloading&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="d90fe58bfa2b87a1b1cbc6838a53a60deea67366" translate="yes" xml:space="preserve">
          <source>The proper way to construct a keymap with a parent is to use &lt;code&gt;set-keymap-parent&lt;/code&gt;; if you have code that directly constructs a keymap with a parent, please convert the program to use &lt;code&gt;set-keymap-parent&lt;/code&gt; instead.</source>
          <target state="translated">부모와 함께 키맵을 생성하는 적절한 방법은 &lt;code&gt;set-keymap-parent&lt;/code&gt; 를 사용하는 것 입니다 . 부모가있는 키맵을 직접 구성하는 코드가있는 경우 대신 &lt;code&gt;set-keymap-parent&lt;/code&gt; 를 사용하도록 프로그램을 변환하십시오 .</target>
        </trans-unit>
        <trans-unit id="1dfec31a43b4f7ab97faaddb57234977bb256c37" translate="yes" xml:space="preserve">
          <source>The property list cell normally should hold a correctly formatted property list. To get a symbol&amp;rsquo;s property list, use the function &lt;code&gt;symbol-plist&lt;/code&gt;. See &lt;a href=&quot;symbol-properties#Symbol-Properties&quot;&gt;Symbol Properties&lt;/a&gt;.</source>
          <target state="translated">일반적으로 속성 목록 셀에는 올바른 형식의 속성 목록이 있어야합니다. 심볼의 속성 목록을 얻으려면 &lt;code&gt;symbol-plist&lt;/code&gt; 함수를 사용하십시오 . &lt;a href=&quot;symbol-properties#Symbol-Properties&quot;&gt;기호 속성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c911a8445b3bd7bfea7954dcdd17b841dcbd3fcb" translate="yes" xml:space="preserve">
          <source>The property&amp;rsquo;s value for the character before point applies if it is non-&lt;code&gt;nil&lt;/code&gt; and rear-sticky, and the property&amp;rsquo;s value for the character after point applies if it is non-&lt;code&gt;nil&lt;/code&gt; and front-sticky. (For mouse clicks, the position of the click is used instead of the position of point.)</source>
          <target state="translated">점 앞의 문자에 대한 속성 값이 &lt;code&gt;nil&lt;/code&gt; 이 아니고 후면 고정이면 적용되고, 점 이후 문자에 대한 속성 값이 &lt;code&gt;nil&lt;/code&gt; 이 아니고 전면 고정 이면 적용됩니다 . (마우스 클릭의 경우 포인트 위치 대신 클릭 위치가 사용됩니다.)</target>
        </trans-unit>
        <trans-unit id="78c51406ca787ccde17c730ea362d97d0f2b5d6a" translate="yes" xml:space="preserve">
          <source>The purpose of &lt;code&gt;throw&lt;/code&gt; is to return from a return point previously established with &lt;code&gt;catch&lt;/code&gt;. The argument &lt;var&gt;tag&lt;/var&gt; is used to choose among the various existing return points; it must be &lt;code&gt;eq&lt;/code&gt; to the value specified in the &lt;code&gt;catch&lt;/code&gt;. If multiple return points match &lt;var&gt;tag&lt;/var&gt;, the innermost one is used.</source>
          <target state="translated">&lt;code&gt;throw&lt;/code&gt; 의 목적은 이전에 &lt;code&gt;catch&lt;/code&gt; 로 설정된 리턴 지점에서 돌아 오는 것 입니다. 인수 &lt;var&gt;tag&lt;/var&gt; 는 기존의 다양한 반환 지점 중에서 선택하는 데 사용됩니다. 그것은해야 &lt;code&gt;eq&lt;/code&gt; 에 지정된 값으로 &lt;code&gt;catch&lt;/code&gt; . 여러 개의 반환 지점이 &lt;var&gt;tag&lt;/var&gt; 와 일치 하면 가장 안쪽에있는 지점 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a798f48d5361b3f20f9b8da5927f51db1ca4bd70" translate="yes" xml:space="preserve">
          <source>The purpose of records is to allow programmers to create objects with new types that are not built into Emacs. They are used as the underlying representation of &lt;code&gt;cl-defstruct&lt;/code&gt; and &lt;code&gt;defclass&lt;/code&gt; instances.</source>
          <target state="translated">레코드의 목적은 프로그래머가 Emacs에 내장되지 않은 새로운 유형으로 객체를 만들 수 있도록하는 것입니다. 이들은 &lt;code&gt;cl-defstruct&lt;/code&gt; 및 &lt;code&gt;defclass&lt;/code&gt; 인스턴스 의 기본 표현으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="6b48773be77ed3bf897730ad62b02207f496fa84" translate="yes" xml:space="preserve">
          <source>The purpose of this variable is to prevent unreasonably large images from accidentally being loaded into Emacs. It only takes effect the first time an image is loaded. Once an image is placed in the image cache, it can always be displayed, even if the value of &lt;code&gt;max-image-size&lt;/code&gt; is subsequently changed (see &lt;a href=&quot;image-cache#Image-Cache&quot;&gt;Image Cache&lt;/a&gt;).</source>
          <target state="translated">이 변수의 목적은 비합리적으로 큰 이미지가 실수로 Emacs에로드되는 것을 방지하는 것입니다. 이미지를 처음로드 할 때만 적용됩니다. 이미지가 이미지 캐시에 배치되면 이후 에 &lt;code&gt;max-image-size&lt;/code&gt; 값이 변경 되더라도 항상 표시 될 수 있습니다 ( &lt;a href=&quot;image-cache#Image-Cache&quot;&gt;이미지 캐시&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="8b698db8f7ae03128e22b00ae5ae3b89fa737eaf" translate="yes" xml:space="preserve">
          <source>The range of values for a fixnum depends on the machine. The minimum range is -536,870,912 to 536,870,911 (30 bits; i.e., -2**29 to 2**29 - 1) but many machines provide a wider range.</source>
          <target state="translated">고정 번호의 값 범위는 시스템에 따라 다릅니다. 최소 범위는 -536,870,912 ~ 536,870,911 (30 비트, 즉 -2 ** 29 ~ 2 ** 29-1)이지만 많은 시스템에서 더 넓은 범위를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="af85b0412ddc48c46d5b6e80df88faf36ad2e739" translate="yes" xml:space="preserve">
          <source>The range of values for a fixnum depends on the machine. The minimum range is -536,870,912 to 536,870,911 (30 bits; i.e., -2**29 to 2**29 - 1), but many machines provide a wider range.</source>
          <target state="translated">고정 번호의 값 범위는 시스템에 따라 다릅니다. 최소 범위는 -536,870,912 ~ 536,870,911 (30 비트, 즉 -2 ** 29 ~ 2 ** 29-1)이지만 많은 컴퓨터에서 더 넓은 범위를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="cce27534771922ba161893777df990814edba95c" translate="yes" xml:space="preserve">
          <source>The range of values for bignums is limited by the amount of main memory, by machine characteristics such as the size of the word used to represent a bignum&amp;rsquo;s exponent, and by the &lt;code&gt;integer-width&lt;/code&gt; variable. These limits are typically much more generous than the limits for fixnums. A bignum is never numerically equal to a fixnum; Emacs always represents an integer in fixnum range as a fixnum, not a bignum.</source>
          <target state="translated">bignum의 값 범위는 bignum의 지수를 나타내는 데 사용되는 단어의 크기와 같은 기계 특성 및 &lt;code&gt;integer-width&lt;/code&gt; 변수에 의해 주 메모리의 양에 의해 제한됩니다 . 이러한 제한은 일반적으로 고정 번호 제한보다 훨씬 더 관대합니다. bignum은 수치 적으로 fixnum과 같지 않습니다. Emacs는 항상 bignum이 아니라 fixnum 범위의 정수를 fixnum으로 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="88fcc9a379dd1cc063bcdc17672afd2ddd066644" translate="yes" xml:space="preserve">
          <source>The raw prefix argument value used by the previous command.</source>
          <target state="translated">이전 명령에서 사용 된 원시 접두사 인수 값입니다.</target>
        </trans-unit>
        <trans-unit id="188580ce5aed7a8d00ced05add7b99d84193146d" translate="yes" xml:space="preserve">
          <source>The raw prefix argument. (Note that this &amp;lsquo;</source>
          <target state="translated">원시 접두사 인수입니다. (이 '</target>
        </trans-unit>
        <trans-unit id="918eb5fe78ecdeb2b74cf1c707d70d8317c7c8ca" translate="yes" xml:space="preserve">
          <source>The raw process status, as returned by the &lt;code&gt;wait&lt;/code&gt; system call.</source>
          <target state="translated">&lt;code&gt;wait&lt;/code&gt; 시스템 호출 에서 반환 된 원시 프로세스 상태 입니다.</target>
        </trans-unit>
        <trans-unit id="8d40522328efd69f1813ecc9395f2a99749405bb" translate="yes" xml:space="preserve">
          <source>The read syntax &lt;code&gt;#'&lt;/code&gt; is a short-hand for using &lt;code&gt;function&lt;/code&gt;. The following forms are all equivalent:</source>
          <target state="translated">읽기 구문 &lt;code&gt;#'&lt;/code&gt; 은 &lt;code&gt;function&lt;/code&gt; 을 사용하는 약어 입니다. 다음 양식은 모두 동일합니다.</target>
        </trans-unit>
        <trans-unit id="f0ccfae7f5d50ab8dd7bf0125292e2e7d92e715d" translate="yes" xml:space="preserve">
          <source>The read syntax and printed representation for lists are identical, and consist of a left parenthesis, an arbitrary number of elements, and a right parenthesis. Here are examples of lists:</source>
          <target state="translated">목록에 대한 읽기 구문과 인쇄 된 표현은 동일하며 왼쪽 괄호, 임의의 수의 요소 및 오른쪽 괄호로 구성됩니다. 다음은 목록의 예입니다.</target>
        </trans-unit>
        <trans-unit id="699968d5ddfd6c3b251c3bfee7172adb575ecba8" translate="yes" xml:space="preserve">
          <source>The read syntax for a string is a double-quote, an arbitrary number of characters, and another double-quote, &lt;code&gt;&quot;like this&quot;&lt;/code&gt;. To include a double-quote in a string, precede it with a backslash; thus, &lt;code&gt;&quot;\&quot;&quot;&lt;/code&gt; is a string containing just one double-quote character. Likewise, you can include a backslash by preceding it with another backslash, like this: &lt;code&gt;&quot;this \\ is a single embedded
backslash&quot;&lt;/code&gt;.</source>
          <target state="translated">문자열에 대한 읽기 구문은 큰 따옴표, 임의의 수의 문자 및 &lt;code&gt;&quot;like this&quot;&lt;/code&gt; 와 같은 또 다른 큰 따옴표 입니다. 문자열에 큰 따옴표를 포함하려면 앞에 백 슬래시를 사용하십시오. 따라서 &lt;code&gt;&quot;\&quot;&quot;&lt;/code&gt; 는 큰 따옴표 문자 하나만 포함 된 문자열입니다. 마찬가지로 &lt;code&gt;&quot;this \\ is a single embedded backslash&quot;&lt;/code&gt; 와 같이 다른 백 슬래시를 앞에 추가하여 백 슬래시를 포함 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2db9c5ad71fdc5297e7b04c37c25b525f29392e3" translate="yes" xml:space="preserve">
          <source>The read syntax for floating-point numbers requires either a decimal point, an exponent, or both. Optional signs (&amp;lsquo;</source>
          <target state="translated">부동 소수점 숫자에 대한 읽기 구문에는 소수점, 지수 또는 둘 다가 필요합니다. 선택적 기호 ( '</target>
        </trans-unit>
        <trans-unit id="468ea3ba2253c757dfcdac67156c541df702374c" translate="yes" xml:space="preserve">
          <source>The read syntax for integers is a sequence of (base ten) digits with an optional sign at the beginning and an optional period at the end. The printed representation produced by the Lisp interpreter never has a leading &amp;lsquo;</source>
          <target state="translated">정수에 대한 읽기 구문은 시작에 선택적 부호가 있고 끝에 선택적 마침표가있는 일련의 (밑수 10) 숫자입니다. Lisp 인터프리터가 제작 한 인쇄 된 표현에는 '</target>
        </trans-unit>
        <trans-unit id="a0df8f0e56b27b7fdf3f7492d928c4cf0eb4466b" translate="yes" xml:space="preserve">
          <source>The read syntax for meta characters uses &amp;lsquo;</source>
          <target state="translated">메타 문자의 읽기 구문은 '</target>
        </trans-unit>
        <trans-unit id="ef7e662450af28ad76f1d8a4260adb6e69ae8a34" translate="yes" xml:space="preserve">
          <source>The reason for a mode to change this variable instead of &lt;code&gt;revert-buffer-function&lt;/code&gt; is to avoid duplicating or replacing the rest of what &lt;code&gt;revert-buffer&lt;/code&gt; does: asking for confirmation, clearing the undo list, deciding the proper major mode, and running the hooks listed below.</source>
          <target state="translated">모드에 대한 이유는 대신이 변수를 변경 &lt;code&gt;revert-buffer-function&lt;/code&gt; 중복 또는의 나머지 부분을 교체하는 일이 없도록하는 것입니다 무엇을 &lt;code&gt;revert-buffer&lt;/code&gt; 수행합니다 후크를 적절한 주요 모드를 결정, 실행 취소 목록을 삭제, 확인을 요청하고, 실행 아래에 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a9fa0be0804d13fd54899e6b26f2ba4d73ac7bd" translate="yes" xml:space="preserve">
          <source>The reason for the name &lt;code&gt;lazy&lt;/code&gt; is that the other composite widgets convert their inferior widgets to internal form when the widget is instantiated in a buffer. This conversion is recursive, so the inferior widgets will convert &lt;em&gt;their&lt;/em&gt; inferior widgets. If the data structure is itself recursive, this conversion is an infinite recursion. The &lt;code&gt;lazy&lt;/code&gt; widget prevents the recursion: it convert its &lt;code&gt;:type&lt;/code&gt; argument only when needed.</source>
          <target state="translated">&lt;code&gt;lazy&lt;/code&gt; 라는 이름의 이유 는 위젯이 버퍼에서 인스턴스화 될 때 다른 복합 위젯이 하위 위젯을 내부 형식으로 변환하기 때문입니다. 열등한 위젯 변환 있도록이 변환은, 재귀 &lt;em&gt;자신의&lt;/em&gt; 열등한 위젯을. 데이터 구조 자체가 재귀 적이면이 변환은 무한 재귀입니다. &lt;code&gt;lazy&lt;/code&gt; 위젯은 재귀를 방지 : 그것의 변환 &lt;code&gt;:type&lt;/code&gt; 필요한 경우에만 인수를.</target>
        </trans-unit>
        <trans-unit id="97c008ed1abdd793cef86b5d0eab947dc6ccb62d" translate="yes" xml:space="preserve">
          <source>The reason for this somewhat complex behavior is that it lets users easily toggle the minor mode interactively, and also lets the minor mode be easily enabled in a mode hook, like this:</source>
          <target state="translated">이처럼 다소 복잡한 동작의 이유는 사용자가 부 모드를 대화식으로 쉽게 전환 할 수 있도록하고 다음과 같이 모드 후크에서 부 모드를 쉽게 활성화 할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="ab43773cfe02cb70d41dd331c0415859809fddf1" translate="yes" xml:space="preserve">
          <source>The recommended way to add a hook function to a hook is by calling &lt;code&gt;add-hook&lt;/code&gt; (see &lt;a href=&quot;setting-hooks#Setting-Hooks&quot;&gt;Setting Hooks&lt;/a&gt;). The hook functions may be any of the valid kinds of functions that &lt;code&gt;funcall&lt;/code&gt; accepts (see &lt;a href=&quot;what-is-a-function#What-Is-a-Function&quot;&gt;What Is a Function&lt;/a&gt;). Most normal hook variables are initially void; &lt;code&gt;add-hook&lt;/code&gt; knows how to deal with this. You can add hooks either globally or buffer-locally with &lt;code&gt;add-hook&lt;/code&gt;.</source>
          <target state="translated">후크에 후크 함수를 추가하는 권장 방법은 &lt;code&gt;add-hook&lt;/code&gt; 을 호출하는 것입니다 (후크 &lt;a href=&quot;setting-hooks#Setting-Hooks&quot;&gt;설정&lt;/a&gt; 참조 ). 후크 함수는 &lt;code&gt;funcall&lt;/code&gt; 이 허용 하는 유효한 종류의 함수 중 하나 일 수 있습니다 ( &lt;a href=&quot;what-is-a-function#What-Is-a-Function&quot;&gt;What Is a Function&lt;/a&gt; 참조 ). 대부분의 일반적인 후크 변수는 처음에는 무효입니다. &lt;code&gt;add-hook&lt;/code&gt; 은이를 처리하는 방법을 알고 있습니다. &lt;code&gt;add-hook&lt;/code&gt; 을 사용하여 전역 적으로 또는 버퍼 로컬로 후크를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e72e25c71fad41850c51c81a50b1cd4e2873976c" translate="yes" xml:space="preserve">
          <source>The recommended way to define a new major mode is to derive it from an existing one using &lt;code&gt;define-derived-mode&lt;/code&gt;. If there is no closely related mode, you should inherit from either &lt;code&gt;text-mode&lt;/code&gt;, &lt;code&gt;special-mode&lt;/code&gt;, or &lt;code&gt;prog-mode&lt;/code&gt;. See &lt;a href=&quot;basic-major-modes#Basic-Major-Modes&quot;&gt;Basic Major Modes&lt;/a&gt;. If none of these are suitable, you can inherit from &lt;code&gt;fundamental-mode&lt;/code&gt; (see &lt;a href=&quot;major-modes#Major-Modes&quot;&gt;Major Modes&lt;/a&gt;).</source>
          <target state="translated">새로운 주 모드를 정의하는 권장 방법은 &lt;code&gt;define-derived-mode&lt;/code&gt; 를 사용하여 기존 모드에서 파생하는 것입니다 . 밀접하게 관련된 모드가없는 경우 &lt;code&gt;text-mode&lt;/code&gt; , &lt;code&gt;special-mode&lt;/code&gt; 또는 &lt;code&gt;prog-mode&lt;/code&gt; 에서 상속해야 합니다 . &lt;a href=&quot;basic-major-modes#Basic-Major-Modes&quot;&gt;기본 주 모드를&lt;/a&gt; 참조하십시오 . 이들 중 어느 것도 적합하지 않은 경우 &lt;code&gt;fundamental-mode&lt;/code&gt; 에서 상속 할 수 있습니다 ( &lt;a href=&quot;major-modes#Major-Modes&quot;&gt;주요 모드&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="55ee00344a022e04c610024dc173a8e737831bfc" translate="yes" xml:space="preserve">
          <source>The recommended way to use this function is to specify a name which fits the conventions of GNU and Unix systems, and pass it to &lt;code&gt;convert-standard-filename&lt;/code&gt;.</source>
          <target state="translated">이 함수를 사용하는 권장 방법은 GNU 및 Unix 시스템의 규칙에 맞는 이름을 지정하고 &lt;code&gt;convert-standard-filename&lt;/code&gt; 으로 전달하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="55eca5446859f2ea52f9e345f8531406554a48b1" translate="yes" xml:space="preserve">
          <source>The redirection lasts until &lt;code&gt;redirect-frame-focus&lt;/code&gt; is called to change it.</source>
          <target state="translated">리디렉션은 &lt;code&gt;redirect-frame-focus&lt;/code&gt; 가 호출되어 변경 될 때까지 지속됩니다 .</target>
        </trans-unit>
        <trans-unit id="1a588fb9e8fcf72cfed3b3eefc36b97e65fb8bbc" translate="yes" xml:space="preserve">
          <source>The reference to &lt;var&gt;variable&lt;/var&gt; must be in the &lt;var&gt;then-form&lt;/var&gt; of the &lt;code&gt;if&lt;/code&gt;, and &lt;var&gt;variable&lt;/var&gt; must appear quoted in the call to &lt;code&gt;boundp&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;variable&lt;/var&gt; 대한 참조 는 &lt;code&gt;if&lt;/code&gt; 의 &lt;var&gt;then-form&lt;/var&gt; 이어야 하며 &lt;var&gt;variable&lt;/var&gt; 는 &lt;code&gt;boundp&lt;/code&gt; 호출에서 인용 부호로 표시되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="e411de3f279f8655e1e219fed4c21701eca0eed7" translate="yes" xml:space="preserve">
          <source>The references to &lt;code&gt;max&lt;/code&gt; inside the body of the &lt;code&gt;for&lt;/code&gt;, which are supposed to refer to the user&amp;rsquo;s binding of &lt;code&gt;max&lt;/code&gt;, really access the binding made by &lt;code&gt;for&lt;/code&gt;.</source>
          <target state="translated">사용자의 &lt;code&gt;max&lt;/code&gt; 바인딩을 참조 하는 &lt;code&gt;for&lt;/code&gt; 본문 내부의 &lt;code&gt;max&lt;/code&gt; 참조 는 실제로 &lt;code&gt;for&lt;/code&gt; 에서 만든 바인딩에 액세스합니다 .</target>
        </trans-unit>
        <trans-unit id="a5e79117bc2adbb317bdcd941ebc194bbe9e52a9" translate="yes" xml:space="preserve">
          <source>The reformulation demonstrates &lt;var&gt;symbol&lt;/var&gt; binding as well as &lt;code&gt;or&lt;/code&gt;, &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;pred&lt;/code&gt;, &lt;code&gt;app&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt;.</source>
          <target state="translated">재구성은 &lt;code&gt;or&lt;/code&gt; , &lt;code&gt;and&lt;/code&gt; , &lt;code&gt;pred&lt;/code&gt; , &lt;code&gt;app&lt;/code&gt; 및 &lt;code&gt;let&lt;/code&gt; 뿐만 아니라 &lt;var&gt;symbol&lt;/var&gt; 바인딩을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="6b316e0a4b7481395ac11f35d1a9f8c1cc3b4cde" translate="yes" xml:space="preserve">
          <source>The relative pixel coordinates of the click. For clicks in the text area of a window, the coordinate origin &lt;code&gt;(0 . 0)&lt;/code&gt; is taken to be the top left corner of the text area. See &lt;a href=&quot;window-sizes#Window-Sizes&quot;&gt;Window Sizes&lt;/a&gt;. For clicks in a mode line, header line or tab line, the coordinate origin is the top left corner of the window itself. For fringes, margins, and the vertical border, &lt;var&gt;x&lt;/var&gt; does not have meaningful data. For fringes and margins, &lt;var&gt;y&lt;/var&gt; is relative to the bottom edge of the header line. In all cases, the &lt;var&gt;x&lt;/var&gt; and &lt;var&gt;y&lt;/var&gt; coordinates increase rightward and downward respectively.</source>
          <target state="translated">클릭의 상대 픽셀 좌표입니다. 창의 텍스트 영역을 클릭하면 좌표 원점 &lt;code&gt;(0 . 0)&lt;/code&gt; 이 텍스트 영역의 왼쪽 상단 모서리가됩니다. &lt;a href=&quot;window-sizes#Window-Sizes&quot;&gt;창 크기를&lt;/a&gt; 참조하십시오 . 모드 라인, 헤더 라인 또는 탭 라인에서 클릭하는 경우 좌표 원점은 창 자체의 왼쪽 상단 모서리입니다. 언저리, 여백 및 세로 테두리의 경우 &lt;var&gt;x&lt;/var&gt; 에는 의미있는 데이터가 없습니다. 언저리와 여백의 경우 &lt;var&gt;y&lt;/var&gt; 는 머리글 줄의 아래쪽 가장자리를 기준으로합니다. 모든 경우에 &lt;var&gt;x&lt;/var&gt; 및 &lt;var&gt;y&lt;/var&gt; 좌표는 각각 오른쪽과 아래쪽으로 증가합니다.</target>
        </trans-unit>
        <trans-unit id="6789ca1a5596f585de1cc2056e90783a15f620b8" translate="yes" xml:space="preserve">
          <source>The reliable and easy way to extract events from a key sequence so as to put them in &lt;code&gt;unread-command-events&lt;/code&gt; is to use &lt;code&gt;listify-key-sequence&lt;/code&gt; (see below).</source>
          <target state="translated">키 시퀀스에서 이벤트를 추출하여 &lt;code&gt;unread-command-events&lt;/code&gt; 에 넣는 안정적이고 쉬운 방법 은 &lt;code&gt;listify-key-sequence&lt;/code&gt; 를 사용하는 것입니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="6ce491e62987f2bb55f95694ce453e7531e85c7c" translate="yes" xml:space="preserve">
          <source>The remainder of this section covers six hooks that are called during redisplay provided a significant, non-scrolling change of a window has been detected. For simplicity, these hooks and the functions they call will be collectively referred to as &lt;em&gt;window change functions&lt;/em&gt;.</source>
          <target state="translated">이 섹션의 나머지 부분에서는 스크롤하지 않는 중요한 창의 변경 사항이 감지 된 경우 다시 표시하는 동안 호출되는 6 개의 후크를 다룹니다. 단순화를 위해 이러한 후크와 호출하는 함수를 총칭하여 &lt;em&gt;창 변경 함수&lt;/em&gt; 라고 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="fccefbe9e1b3ac84a03c9262e101056ef8f24db4" translate="yes" xml:space="preserve">
          <source>The remaining arguments (&lt;var&gt;args&lt;/var&gt;) will be passed to the process verbatim. Emacs is not involved in processing file names that are present in &lt;var&gt;args&lt;/var&gt;. To avoid confusion, it may be best to avoid absolute file names in &lt;var&gt;args&lt;/var&gt;, but rather to specify all file names as relative to &lt;code&gt;default-directory&lt;/code&gt;. The function &lt;code&gt;file-relative-name&lt;/code&gt; is useful for constructing such relative file names. Alternatively, you can use &lt;code&gt;file-local-name&lt;/code&gt; (see &lt;a href=&quot;magic-file-names#Magic-File-Names&quot;&gt;Magic File Names&lt;/a&gt;) to obtain an absolute file name as seen from the remote host&amp;rsquo;s perspective.</source>
          <target state="translated">나머지 인수 ( &lt;var&gt;args&lt;/var&gt; )는 그대로 프로세스에 전달됩니다. Emacs는 &lt;var&gt;args&lt;/var&gt; 에있는 파일 이름을 처리하는 데 관여하지 않습니다 . 혼동을 피하기 위해 &lt;var&gt;args&lt;/var&gt; 에서 절대 파일 이름을 피하는 것이 가장 좋으며 모든 파일 이름을 &lt;code&gt;default-directory&lt;/code&gt; 에 상대적으로 지정하는 것이 가장 좋습니다 . &lt;code&gt;file-relative-name&lt;/code&gt; 함수 는 이러한 상대 파일 이름을 구성하는 데 유용합니다. 또는 &lt;code&gt;file-local-name&lt;/code&gt; ( &lt;a href=&quot;magic-file-names#Magic-File-Names&quot;&gt;매직 파일 이름&lt;/a&gt; 참조 )을 사용하여 원격 호스트의 관점에서 볼 때 절대 파일 이름을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="670a4e0596da84e4ab53487725c486bc97b4f1aa" translate="yes" xml:space="preserve">
          <source>The remaining arguments &lt;var&gt;parameters&lt;/var&gt; are keyword/argument pairs that are mainly relevant to encrypted connections:</source>
          <target state="translated">나머지 인수 &lt;var&gt;parameters&lt;/var&gt; 는 주로 암호화 된 연결과 관련된 키워드 / 인수 쌍입니다.</target>
        </trans-unit>
        <trans-unit id="711c3203fb757fbb6071fddfb4565e07916d99bb" translate="yes" xml:space="preserve">
          <source>The remaining arguments control the rate of echo area updates. The progress reporter will wait for at least &lt;var&gt;min-change&lt;/var&gt; more percents of the operation to be completed before printing next message; the default is one percent. &lt;var&gt;min-time&lt;/var&gt; specifies the minimum time in seconds to pass between successive prints; the default is 0.2 seconds. (On some operating systems, the progress reporter may handle fractions of seconds with varying precision).</source>
          <target state="translated">나머지 인수는 에코 영역 업데이트 속도를 제어합니다. 진행률보고자는 다음 메시지를 인쇄하기 전에 작업의 더 많은 퍼센트 를 최소한 &lt;var&gt;min-change&lt;/var&gt; 하기를 기다립니다 . 기본값은 1 %입니다. &lt;var&gt;min-time&lt;/var&gt; 연속 인쇄 사이를 통과하는 초 최소 시간을 지정한다; 기본값은 0.2 초입니다. (일부 운영 체제에서는 진행률보고자가 다양한 정밀도로 몇 초 만에 처리 할 수 ​​있습니다.)</target>
        </trans-unit>
        <trans-unit id="922b5762bb85df57750f37171cdcbbec00eba4ff" translate="yes" xml:space="preserve">
          <source>The remaining arguments should be the same arguments that might be given to the corresponding I/O primitive. Depending on the primitive, one of those arguments is selected as the &lt;em&gt;target&lt;/em&gt;. For example, if &lt;var&gt;operation&lt;/var&gt; does file I/O, whichever argument specifies the file name is the target. For subprocess primitives, the process name is the target. For &lt;code&gt;open-network-stream&lt;/code&gt;, the target is the service name or port number.</source>
          <target state="translated">나머지 인수는 해당 I / O 프리미티브에 제공 될 수있는 동일한 인수 여야합니다. 기본 요소에 따라 이러한 인수 중 하나가 &lt;em&gt;대상으로&lt;/em&gt; 선택됩니다 . 예를 들어, &lt;var&gt;operation&lt;/var&gt; 이 파일 I / O를 수행하는 경우 파일 이름을 지정하는 인수가 대상입니다. 하위 프로세스 기본 요소의 경우 프로세스 이름이 대상입니다. 들어 &lt;code&gt;open-network-stream&lt;/code&gt; 대상 서비스 이름 또는 포트 번호입니다.</target>
        </trans-unit>
        <trans-unit id="3a337a486bdd471460754fa0fdb9252c1ad6a6e1" translate="yes" xml:space="preserve">
          <source>The remaining arguments, &lt;var&gt;args&lt;/var&gt;, are strings that specify command line arguments for the program.</source>
          <target state="translated">나머지 인수 &lt;var&gt;args&lt;/var&gt; 는 프로그램의 명령 줄 인수를 지정하는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="c5f9c78575e39313d5c394dcec0f4646b698aca7" translate="yes" xml:space="preserve">
          <source>The remaining arguments, &lt;var&gt;args&lt;/var&gt;, are strings that specify command line arguments for the program. Each string is passed to &lt;var&gt;program&lt;/var&gt; as a separate argument.</source>
          <target state="translated">나머지 인수 &lt;var&gt;args&lt;/var&gt; 는 프로그램의 명령 줄 인수를 지정하는 문자열입니다. 각 문자열은 별도의 인수 로 &lt;var&gt;program&lt;/var&gt; 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="e63ff1b06b54edf88e3df6de1b60c7d8bc9065cf" translate="yes" xml:space="preserve">
          <source>The remaining arguments, &lt;var&gt;props&lt;/var&gt;, specify additional image properties&amp;mdash;for example,</source>
          <target state="translated">나머지 인수 인 &lt;var&gt;props&lt;/var&gt; 는 추가 이미지 속성을 지정합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fbf07a85ca35fefe0fcea21832b76725d5868901" translate="yes" xml:space="preserve">
          <source>The remaining clauses use core patterns. &lt;code&gt;(pred numberp)&lt;/code&gt; matches if &lt;code&gt;form&lt;/code&gt; is a number. On match, the body evaluates it. &lt;code&gt;(pred symbolp)&lt;/code&gt; matches if &lt;code&gt;form&lt;/code&gt; is a symbol. On match, the body looks up the symbol in &lt;code&gt;env&lt;/code&gt; and returns its association. Finally, &lt;code&gt;_&lt;/code&gt; is the catch-all pattern that matches anything, so it&amp;rsquo;s suitable for reporting syntax errors.</source>
          <target state="translated">나머지 절은 핵심 패턴을 사용합니다. &lt;code&gt;(pred numberp)&lt;/code&gt; &lt;code&gt;form&lt;/code&gt; 이 숫자 이면 일치합니다 . 경기에서 신체는 그것을 평가합니다. &lt;code&gt;(pred symbolp)&lt;/code&gt; &lt;code&gt;form&lt;/code&gt; 이 기호 이면 일치합니다 . 일치시 본문은 &lt;code&gt;env&lt;/code&gt; 에서 기호를 찾아 연관성을 반환합니다. 마지막으로 &lt;code&gt;_&lt;/code&gt; 는 모든 항목과 일치하는 포괄 패턴이므로 구문 오류보고에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="169a2fbaa470aeea2e4b7eb66378820fbb16842f" translate="yes" xml:space="preserve">
          <source>The remaining elements in &lt;var&gt;menu&lt;/var&gt; are menu items.</source>
          <target state="translated">&lt;var&gt;menu&lt;/var&gt; 의 나머지 요소 는 메뉴 항목입니다.</target>
        </trans-unit>
        <trans-unit id="4e6dd61e2904f012d61dbb3c359b6a7c4039effd" translate="yes" xml:space="preserve">
          <source>The remaining image types that Emacs can support are:</source>
          <target state="translated">Emacs가 지원할 수있는 나머지 이미지 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="66a6e23b71c61a3f987d7762c7e2a5b7599aa9c3" translate="yes" xml:space="preserve">
          <source>The reordering algorithm uses the bidirectional properties of the characters stored as their &lt;code&gt;bidi-class&lt;/code&gt; property (see &lt;a href=&quot;character-properties#Character-Properties&quot;&gt;Character Properties&lt;/a&gt;). Lisp programs can change these properties by calling the &lt;code&gt;put-char-code-property&lt;/code&gt; function. However, doing this requires a thorough understanding of the</source>
          <target state="translated">재정렬 알고리즘은 &lt;code&gt;bidi-class&lt;/code&gt; 속성 으로 저장된 문자의 양방향 속성을 사용합니다 ( &lt;a href=&quot;character-properties#Character-Properties&quot;&gt;Character Properties&lt;/a&gt; 참조 ). Lisp 프로그램은 &lt;code&gt;put-char-code-property&lt;/code&gt; 함수 를 호출하여 이러한 속성을 변경할 수 있습니다 . 그러나 이렇게하려면 다음 사항에 대한 철저한 이해가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="0e2760fb3d24d66fd982b8a9de029f1dc2534fb7" translate="yes" xml:space="preserve">
          <source>The replacement buffer in each window is chosen via &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; (see &lt;a href=&quot;window-history#Window-History&quot;&gt;Window History&lt;/a&gt;). Any dedicated window displaying &lt;var&gt;buffer-or-name&lt;/var&gt; is deleted if possible (see &lt;a href=&quot;dedicated-windows#Dedicated-Windows&quot;&gt;Dedicated Windows&lt;/a&gt;). If such a window is the only window on its frame and there are other frames on the same terminal, the frame is deleted as well. If the dedicated window is the only window on the only frame on its terminal, the buffer is replaced anyway.</source>
          <target state="translated">각 창의 교체 버퍼는 &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; 통해 선택됩니다 ( &lt;a href=&quot;window-history#Window-History&quot;&gt;창 기록&lt;/a&gt; 참조 ). 가능한 경우 &lt;var&gt;buffer-or-name&lt;/var&gt; 표시하는 전용 창 은 삭제됩니다 ( &lt;a href=&quot;dedicated-windows#Dedicated-Windows&quot;&gt;전용 창&lt;/a&gt; 참조 ). 이러한 창이 프레임에있는 유일한 창이고 동일한 터미널에 다른 프레임이있는 경우 프레임도 삭제됩니다. 전용 창이 터미널의 유일한 프레임에있는 유일한 창인 경우에도 버퍼는 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="a7bc26f1c46834e48b01bc54d1856ec2c2513fe6" translate="yes" xml:space="preserve">
          <source>The replacement is performed using &lt;code&gt;replace-buffer-contents&lt;/code&gt; (see above) which also describes the &lt;var&gt;max-secs&lt;/var&gt; and &lt;var&gt;max-costs&lt;/var&gt; arguments and the return value.</source>
          <target state="translated">대체는 &lt;var&gt;max-secs&lt;/var&gt; 및 &lt;var&gt;max-costs&lt;/var&gt; 인수와 반환 값을 설명하는 &lt;code&gt;replace-buffer-contents&lt;/code&gt; (위 참조)를 사용하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="ec1321a0692fb6ebcc794193c05c46720ae0b1d2" translate="yes" xml:space="preserve">
          <source>The representation of letters, numbers and control characters.</source>
          <target state="translated">문자, 숫자 및 제어 문자의 표현.</target>
        </trans-unit>
        <trans-unit id="1888fa813111440fef4cca1b17158b44c62b32a0" translate="yes" xml:space="preserve">
          <source>The rest of &lt;var&gt;args&lt;/var&gt; are strings that specify command line arguments for the subprocess.</source>
          <target state="translated">나머지 &lt;var&gt;args&lt;/var&gt; 서브 프로세스의 명령 줄 인수를 지정하는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="e64cb5cbfa4900b03ef274ea22ff266b957788b6" translate="yes" xml:space="preserve">
          <source>The rest of the elements are the &lt;em&gt;body&lt;/em&gt; of the function: the Lisp code to do the work of the function (or, as a Lisp programmer would say, &amp;ldquo;a list of Lisp forms to evaluate&amp;rdquo;). The value returned by the function is the value returned by the last element of the body.</source>
          <target state="translated">나머지 요소는 함수 의 &lt;em&gt;본문&lt;/em&gt; 입니다. 함수의 작업을 수행하는 Lisp 코드 (또는 Lisp 프로그래머가 &quot;평가할 Lisp 양식 목록&quot;이라고 말하듯이). 함수가 반환하는 값은 본문의 마지막 요소가 반환 한 값입니다.</target>
        </trans-unit>
        <trans-unit id="0d7105d802c517da10dece05da93fcc235f044de" translate="yes" xml:space="preserve">
          <source>The rest of this section describes several kinds of display specifications and what they mean.</source>
          <target state="translated">이 섹션의 나머지 부분에서는 여러 종류의 디스플레이 사양과 그 의미에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="75d16b63e700fca272954b8d5c9cbea0eaebf3a4" translate="yes" xml:space="preserve">
          <source>The rest of this subsection describes different forms of core patterns, presents some examples, and concludes with important caveats on using the let-binding facility provided by some pattern forms. A core pattern can have the following forms:</source>
          <target state="translated">이 하위 섹션의 나머지 부분에서는 다양한 형태의 코어 패턴을 설명하고, 몇 가지 예를 제시하고, 일부 패턴 형식에서 제공하는 let-binding 기능을 사용하는 데 중요한주의 사항으로 마무리합니다. 코어 패턴은 다음과 같은 형식을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3d63b344006851896165eee8891a4b8d2a80cdd" translate="yes" xml:space="preserve">
          <source>The result &lt;var&gt;prevhpos&lt;/var&gt; is the horizontal position one character back from &lt;var&gt;pos&lt;/var&gt;. The result &lt;var&gt;contin&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt; if the last line was continued after (or within) the previous character.</source>
          <target state="translated">결과 &lt;var&gt;prevhpos&lt;/var&gt; 는 &lt;var&gt;pos&lt;/var&gt; 에서 한 문자 뒤의 수평 위치 입니다. 결과 &lt;var&gt;contin&lt;/var&gt; 은 마지막 줄이 이전 문자 뒤 (또는 내)에 계속 된 경우 &lt;code&gt;t&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="daae51971c3e086b5b343e27b0d5f3425265bcec" translate="yes" xml:space="preserve">
          <source>The result is not &lt;code&gt;(&quot;&quot; &quot;two&quot; &quot;words&quot; &quot;&quot;)&lt;/code&gt;, which would rarely be useful. If you need such a result, use an explicit value for &lt;var&gt;separators&lt;/var&gt;:</source>
          <target state="translated">결과는 거의 유용 하지 않은 &lt;code&gt;(&quot;&quot; &quot;two&quot; &quot;words&quot; &quot;&quot;)&lt;/code&gt; 가 아닙니다 . 이러한 결과가 필요한 경우 &lt;var&gt;separators&lt;/var&gt; 명시 적 값을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b472acbf6233b1409a248f2d33fb8eb9ab0e8df6" translate="yes" xml:space="preserve">
          <source>The result must be accurate. The function may need to encode and decode a large part of the buffer, which is expensive and can be slow.</source>
          <target state="translated">결과는 정확해야합니다. 이 함수는 버퍼의 많은 부분을 인코딩하고 디코딩해야 할 수 있습니다. 이는 비용이 많이 들고 느릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fc3ca66f906ee6817d9bc3b5bb03a793a75bf8c" translate="yes" xml:space="preserve">
          <source>The result of encoding is logically a sequence of bytes, but the buffer remains multibyte if it was multibyte before, and any 8-bit bytes are converted to their multibyte representation (see &lt;a href=&quot;text-representations#Text-Representations&quot;&gt;Text Representations&lt;/a&gt;).</source>
          <target state="translated">인코딩의 결과는 논리적으로 일련의 바이트이지만 이전에 멀티 바이트 인 경우 버퍼는 멀티 바이트로 유지되고 8 비트 바이트는 멀티 바이트 표현으로 변환됩니다 ( &lt;a href=&quot;text-representations#Text-Representations&quot;&gt;텍스트 표현&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="c0ac4c7f55c94e4e68eece5bab668740b85fd079" translate="yes" xml:space="preserve">
          <source>The result of encoding, and the input to decoding, are not ordinary text. They logically consist of a series of byte values; that is, a series of</source>
          <target state="translated">인코딩 결과 및 디코딩에 대한 입력은 일반 텍스트가 아닙니다. 논리적으로 일련의 바이트 값으로 구성됩니다. 즉, 일련의</target>
        </trans-unit>
        <trans-unit id="f2f9b59d04c4a67bead42edef8ea82ec9bf8264f" translate="yes" xml:space="preserve">
          <source>The result of evaluating &lt;var&gt;form&lt;/var&gt; determines whether the item is enabled (non-&lt;code&gt;nil&lt;/code&gt; means yes). If the item is not enabled, you can&amp;rsquo;t really click on it.</source>
          <target state="translated">평가 &lt;var&gt;form&lt;/var&gt; 의 결과는 항목이 활성화되었는지 여부를 결정합니다 ( &lt;code&gt;nil&lt;/code&gt; 이 아님은 예를 의미 함). 항목이 활성화되어 있지 않으면 실제로 클릭 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0ef7684b6652c1f298625050dc4e7b22d73f9616" translate="yes" xml:space="preserve">
          <source>The result of evaluating &lt;var&gt;form&lt;/var&gt; determines whether the item should actually appear in the menu (non-&lt;code&gt;nil&lt;/code&gt; means yes). If the item does not appear, then the menu is displayed as if this item were not defined at all.</source>
          <target state="translated">평가 &lt;var&gt;form&lt;/var&gt; 의 결과는 항목이 실제로 메뉴에 표시되어야하는지 여부를 결정합니다 ( &lt;code&gt;nil&lt;/code&gt; 이 아님은 예를 의미 함). 항목이 나타나지 않으면이 항목이 전혀 정의되지 않은 것처럼 메뉴가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="acbd2ddb72baf0b207a6321fedc1407724073a97" translate="yes" xml:space="preserve">
          <source>The result of this form is &lt;code&gt;t&lt;/code&gt; if it works to specify &lt;var&gt;keyword&lt;/var&gt; with value &lt;var&gt;value&lt;/var&gt; in &lt;code&gt;make-network-process&lt;/code&gt;. Here are some of the &lt;var&gt;keyword&lt;/var&gt;&amp;mdash;&lt;var&gt;value&lt;/var&gt; pairs you can test in this way.</source>
          <target state="translated">이 형식의 결과는 &lt;code&gt;make-network-process&lt;/code&gt; 에서 값 &lt;var&gt;value&lt;/var&gt; 으로 &lt;var&gt;keyword&lt;/var&gt; 를 지정하는 경우 &lt;code&gt;t&lt;/code&gt; 입니다. 다음은 이러한 방식으로 테스트 할 수 있는 몇 가지 &lt;var&gt;keyword&lt;/var&gt; &amp;mdash; &lt;var&gt;value&lt;/var&gt; 쌍입니다.</target>
        </trans-unit>
        <trans-unit id="a66be8edbff7bbe7579ce3f3a75abe46a384d47a" translate="yes" xml:space="preserve">
          <source>The result of this macro is the result returned by &lt;var&gt;body&lt;/var&gt;.</source>
          <target state="translated">이 매크로의 결과는 &lt;var&gt;body&lt;/var&gt; 에서 반환 한 결과 입니다.</target>
        </trans-unit>
        <trans-unit id="27bbea73aa5cdc064da3e057ed92e4ba32abfaad" translate="yes" xml:space="preserve">
          <source>The result of using contradictory flags (for instance, both upper and lower case) is undefined.</source>
          <target state="translated">모순되는 플래그 (예 : 대문자와 소문자 모두)를 사용한 결과는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="46a20d33611240a9e0e5211ef91f6aa318813c3c" translate="yes" xml:space="preserve">
          <source>The resulting mouse position is constrained to the native frame of &lt;var&gt;frame&lt;/var&gt;. If &lt;var&gt;frame&lt;/var&gt; is not visible, this function does nothing. The return value is not significant.</source>
          <target state="translated">그 결과 마우스 위치의 기본 프레임에 구속되어 &lt;var&gt;frame&lt;/var&gt; . 경우 &lt;var&gt;frame&lt;/var&gt; 표시되지 않습니다,이 함수는 작동하지 않습니다. 반환 값은 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="27f056d37a6f909c9875b9547c995c37a964153d" translate="yes" xml:space="preserve">
          <source>The resulting mouse position is not constrained to the native frame of &lt;var&gt;frame&lt;/var&gt;. If &lt;var&gt;frame&lt;/var&gt; is not visible, this function does nothing. The return value is not significant.</source>
          <target state="translated">그 결과 마우스 위치의 기본 프레임에 제한되어 있지 않은 &lt;var&gt;frame&lt;/var&gt; . 경우 &lt;var&gt;frame&lt;/var&gt; 표시되지 않습니다,이 함수는 작동하지 않습니다. 반환 값은 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="97e907e5a3426231ca925e4df1a09f1c6f27899f" translate="yes" xml:space="preserve">
          <source>The resulting pixel is computed from the color intensity of the color resulting from summing up the RGB values of surrounding pixels, multiplied by the specified factors, and dividing that sum by the sum of the factors&amp;rsquo; absolute values.</source>
          <target state="translated">결과 픽셀은 주변 픽셀의 RGB 값을 합산하고 지정된 계수를 곱한 후 그 합을 계수의 절대 값의 합으로 나눈 결과 색상의 색상 강도에서 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="a850c2e30c134550ab81c49f18e64cc8581aca70" translate="yes" xml:space="preserve">
          <source>The resulting regexp is preceded by &lt;var&gt;paren&lt;/var&gt; and followed by &amp;lsquo;</source>
          <target state="translated">결과 정규 표현식은 &lt;var&gt;paren&lt;/var&gt; 앞에 오고 뒤에 '</target>
        </trans-unit>
        <trans-unit id="5cb20d9a2af4a08675a28d5ca902bb392372a3c0" translate="yes" xml:space="preserve">
          <source>The resulting regexp is surrounded by &amp;lsquo;</source>
          <target state="translated">결과 정규식은 '</target>
        </trans-unit>
        <trans-unit id="75f74b291859bcb8fbacd8a981cca3c5abbd5e9c" translate="yes" xml:space="preserve">
          <source>The return value has the form &lt;code&gt;(&lt;var&gt;left&lt;/var&gt; &lt;var&gt;top&lt;/var&gt; &lt;var&gt;right&lt;/var&gt;
&lt;var&gt;bottom&lt;/var&gt;)&lt;/code&gt;. These list elements are, respectively, the X coordinate of the leftmost column occupied by the window, the Y coordinate of the topmost row, the X coordinate one column to the right of the rightmost column, and the Y coordinate one row down from the bottommost row.</source>
          <target state="translated">반환 값은 형식 &lt;code&gt;(&lt;var&gt;left&lt;/var&gt; &lt;var&gt;top&lt;/var&gt; &lt;var&gt;right&lt;/var&gt; &lt;var&gt;bottom&lt;/var&gt;)&lt;/code&gt; 입니다. 이러한 목록 요소는 각각 창이 차지하는 맨 왼쪽 열의 X 좌표, 맨 위 행의 Y 좌표, 맨 오른쪽 열의 오른쪽에있는 X 좌표, 맨 아래에서 한 행 아래에있는 Y 좌표입니다. 열.</target>
        </trans-unit>
        <trans-unit id="d012e9e07ddcadec4d4bdcd9c6d25ee2bd788334" translate="yes" xml:space="preserve">
          <source>The return value includes mode and header line, a horizontal scroll bar and a bottom divider, if any. If &lt;var&gt;window&lt;/var&gt; is an internal window, its pixel height is the pixel height of the screen areas spanned by its children.</source>
          <target state="translated">반환 값에는 모드 및 헤더 줄, 가로 스크롤 막대 및 아래쪽 구분선이 포함됩니다. 경우 &lt;var&gt;window&lt;/var&gt; 내부 창, 그 화소 높이의 아이들 스팬 화면 영역의 픽셀의 높이이다.</target>
        </trans-unit>
        <trans-unit id="02435ab528a9d458375ad989e9c07e91ea1d1315" translate="yes" xml:space="preserve">
          <source>The return value includes the fringes and margins of &lt;var&gt;window&lt;/var&gt; as well as any vertical dividers or scroll bars belonging to &lt;var&gt;window&lt;/var&gt;. If &lt;var&gt;window&lt;/var&gt; is an internal window, its pixel width is the width of the screen areas spanned by its children.</source>
          <target state="translated">리턴 값은 프린지 및 여백 포함 &lt;var&gt;window&lt;/var&gt; 뿐만 아니라, 수직 또는 분배기에 속하는 스크롤바 &lt;var&gt;window&lt;/var&gt; . &lt;var&gt;window&lt;/var&gt; 가 내부 윈도우 인 경우 픽셀 너비는 자식이 차지하는 화면 영역의 너비입니다.</target>
        </trans-unit>
        <trans-unit id="3a98f39fffcef1b3f518f4676f34cc9b1b32069e" translate="yes" xml:space="preserve">
          <source>The return value indicates the distance traveled. It is an integer that is zero or less.</source>
          <target state="translated">반환 값은 이동 한 거리를 나타냅니다. 0 이하의 정수입니다.</target>
        </trans-unit>
        <trans-unit id="3fde61c2b5f5d76aef05339847ec2609e0a0f8e5" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;t&lt;/code&gt; if the function actually changed some property&amp;rsquo;s value; &lt;code&gt;nil&lt;/code&gt; otherwise (if &lt;var&gt;props&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; or if no character in the specified text had any of those properties).</source>
          <target state="translated">함수가 실제로 일부 속성의 값을 변경 한 경우 반환 값은 &lt;code&gt;t&lt;/code&gt; 입니다 . 그렇지 않으면 &lt;code&gt;nil&lt;/code&gt; ( &lt;var&gt;props&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이거나 지정된 텍스트의 문자에 해당 속성이없는 경우).</target>
        </trans-unit>
        <trans-unit id="90f56f2b19d2b305eccb19f73983ee226bf52495" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;t&lt;/code&gt; if the function actually changed some property&amp;rsquo;s value; &lt;code&gt;nil&lt;/code&gt; otherwise (if &lt;var&gt;props&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; or its values agree with those in the text).</source>
          <target state="translated">함수가 실제로 일부 속성의 값을 변경 한 경우 반환 값은 &lt;code&gt;t&lt;/code&gt; 입니다 . 그렇지 않으면 &lt;code&gt;nil&lt;/code&gt; ( &lt;var&gt;props&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이거나 해당 값이 텍스트의 값과 일치하는 경우).</target>
        </trans-unit>
        <trans-unit id="d966c0a5582546e03dd65e09ce5f5b7511e5eb89" translate="yes" xml:space="preserve">
          <source>The return value is &lt;var&gt;overlay&lt;/var&gt;.</source>
          <target state="translated">반환 값은 &lt;var&gt;overlay&lt;/var&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c9c05af5fac5434c5acee584935759af38f45178" translate="yes" xml:space="preserve">
          <source>The return value is &lt;var&gt;value&lt;/var&gt; from the chosen alternative.</source>
          <target state="translated">리턴 값은 &lt;var&gt;value&lt;/var&gt; 선택된 대안에서.</target>
        </trans-unit>
        <trans-unit id="414de02915422d70149abb88fd20a6bbe77b52b9" translate="yes" xml:space="preserve">
          <source>The return value is a Lisp object that serves as a cookie; you can pass this object as an argument to &lt;code&gt;face-remap-remove-relative&lt;/code&gt; if you need to remove the remapping later.</source>
          <target state="translated">반환 값은 쿠키 역할을하는 Lisp 개체입니다. 나중에 다시 매핑을 제거해야하는 경우이 개체를 &lt;code&gt;face-remap-remove-relative&lt;/code&gt; 에 인수로 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="640083b382042a0f9ab141b72092b58d3b3db8e7" translate="yes" xml:space="preserve">
          <source>The return value is a decoded time structure.</source>
          <target state="translated">반환 값은 디코딩 된 시간 구조입니다.</target>
        </trans-unit>
        <trans-unit id="6948835c6ed35bc81ffd72935c26a9c6a4b01e26" translate="yes" xml:space="preserve">
          <source>The return value is a list of five elements:</source>
          <target state="translated">반환 값은 다음 5 개 요소의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="90615d81da8d652dcb6154d1dc922a071b14b8e3" translate="yes" xml:space="preserve">
          <source>The return value is a list of the form &lt;code&gt;(&lt;var&gt;root&lt;/var&gt; &lt;var&gt;mini&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;root&lt;/var&gt; represents the window tree of the frame&amp;rsquo;s root window, and &lt;var&gt;mini&lt;/var&gt; is the frame&amp;rsquo;s minibuffer window.</source>
          <target state="translated">반환 값은 &lt;code&gt;(&lt;var&gt;root&lt;/var&gt; &lt;var&gt;mini&lt;/var&gt;)&lt;/code&gt; 형식의 목록입니다. 여기서 &lt;var&gt;root&lt;/var&gt; 는 프레임의 루트 창의 창 트리를 나타내고 &lt;var&gt;mini&lt;/var&gt; 는 프레임의 미니 버퍼 창을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="52c6a1791b31a7b0eaccc6801b2780ff866415de" translate="yes" xml:space="preserve">
          <source>The return value is a triple of the width and the start and end y-coordinates of the largest rectangle that can be inscribed into the empty space (space not displaying any text) of the text area of &lt;var&gt;window&lt;/var&gt;. No x-coordinates are returned by this function&amp;mdash;any such rectangle is assumed to end at the right edge of &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s text area. If no empty space can be found, the return value is &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">반환 값은 &lt;var&gt;window&lt;/var&gt; 의 텍스트 영역의 빈 공간 (텍스트를 표시하지 않는 공간)에 새길 수있는 가장 큰 사각형의 너비와 시작 및 끝 y 좌표의 3 배입니다 . 이 함수는 x 좌표를 반환하지 않습니다. 이러한 직사각형은 &lt;var&gt;window&lt;/var&gt; 텍스트 영역 오른쪽 가장자리에서 끝나는 것으로 간주됩니다 . 빈 공간을 찾을 수없는 경우 반환 값은 &lt;code&gt;nil&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a2e42df57a0cc7d257e5e9f1e666fc7a3621ad67" translate="yes" xml:space="preserve">
          <source>The return value is always &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">반환 값은 항상 &lt;code&gt;nil&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4fc3028050b974b5c5985a3e65b383b27350e24c" translate="yes" xml:space="preserve">
          <source>The return value is always &lt;code&gt;nil&lt;/code&gt;; to make calls to &lt;code&gt;map-char-table&lt;/code&gt; useful, &lt;var&gt;function&lt;/var&gt; should have side effects. For example, here is how to examine the elements of the syntax table:</source>
          <target state="translated">반환 값은 항상 &lt;code&gt;nil&lt;/code&gt; 입니다 . &lt;code&gt;map-char-table&lt;/code&gt; 을 유용 하게 호출하려면 &lt;var&gt;function&lt;/var&gt; 에 부작용이 있어야합니다. 예를 들어 다음은 구문 테이블의 요소를 검사하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="6e1ef02d50eb6d3d11a008ae86a182534aaddd6c" translate="yes" xml:space="preserve">
          <source>The return value is like what &lt;code&gt;insert-file-contents&lt;/code&gt; returns: a list of the absolute file name and the length of the data inserted (after conversion).</source>
          <target state="translated">반환 값은 &lt;code&gt;insert-file-contents&lt;/code&gt; 가 반환하는 것과 같습니다 : 절대 파일 이름 목록과 삽입 된 데이터의 길이 (변환 후).</target>
        </trans-unit>
        <trans-unit id="1667a16b49f259c48f935a06b46d348e1b7a9a28" translate="yes" xml:space="preserve">
          <source>The return value is never negative. It is zero when no horizontal scrolling has been done in &lt;var&gt;window&lt;/var&gt; (which is usually the case).</source>
          <target state="translated">반환 값은 음수가 아닙니다. &lt;var&gt;window&lt;/var&gt; 에서 수평 스크롤이 수행되지 않은 경우 0 입니다 (대개 경우).</target>
        </trans-unit>
        <trans-unit id="2493392e7fec786dd0b57b9149f6a4de24a60362" translate="yes" xml:space="preserve">
          <source>The return value is the column number actually moved to.</source>
          <target state="translated">반환 값은 실제로 이동 한 열 번호입니다.</target>
        </trans-unit>
        <trans-unit id="728cf9e0720907dab6445cd97c1a912356f7f43f" translate="yes" xml:space="preserve">
          <source>The return value is the distance traveled, which is a nonnegative integer.</source>
          <target state="translated">반환 값은 이동 거리이며 음이 아닌 정수입니다.</target>
        </trans-unit>
        <trans-unit id="e8f11031b2e43a095f2b7b7de82a02dfcbe6b156" translate="yes" xml:space="preserve">
          <source>The return value is the matching value from &lt;var&gt;choices&lt;/var&gt;.</source>
          <target state="translated">반환 값은 &lt;var&gt;choices&lt;/var&gt; 에서 일치하는 값입니다 .</target>
        </trans-unit>
        <trans-unit id="6d181ed19740d80d79cf1130d7058743bf3e3b57" translate="yes" xml:space="preserve">
          <source>The return value is the new window, &lt;code&gt;nil&lt;/code&gt; when creating that window failed.</source>
          <target state="translated">반환 값은 새 창이며 해당 창을 만들 때 실패하면 &lt;code&gt;nil&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f65065166d5e0c6aa1c92410eeb9adf0999014fa" translate="yes" xml:space="preserve">
          <source>The return value is the number of screen lines over which point was moved. The value may be less in absolute value than &lt;var&gt;count&lt;/var&gt; if the beginning or end of the buffer was reached.</source>
          <target state="translated">반환 값은 포인트가 이동 한 스크린 라인의 수입니다. 버퍼의 시작 또는 끝에 도달 한 경우 값은 &lt;var&gt;count&lt;/var&gt; 보다 절대 값이 적을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9d83169f48bfa8d22f5e0a5baa5652dbdd9ad387" translate="yes" xml:space="preserve">
          <source>The return value is the result of this rounding.</source>
          <target state="translated">반환 값은이 반올림의 결과입니다.</target>
        </trans-unit>
        <trans-unit id="a97826aadd65e5acdd8dae2f1cc5f5396c5e9f4d" translate="yes" xml:space="preserve">
          <source>The return value is the same as if you call the low-level parsing function &lt;code&gt;parse-partial-sexp&lt;/code&gt; to parse from the beginning of the visible portion of the buffer to &lt;var&gt;pos&lt;/var&gt; (see &lt;a href=&quot;low_002dlevel-parsing#Low_002dLevel-Parsing&quot;&gt;Low-Level Parsing&lt;/a&gt;). However, &lt;code&gt;syntax-ppss&lt;/code&gt; uses caches to speed up the computation. Due to this optimization, the second value (previous complete subexpression) and sixth value (minimum parenthesis depth) in the returned parser state are not meaningful.</source>
          <target state="translated">리턴 값을 사용하면 낮은 수준 파싱 함수 호출처럼 동일한 &lt;code&gt;parse-partial-sexp&lt;/code&gt; 버퍼의 보이는 부분의 처음부터 파싱 &lt;var&gt;pos&lt;/var&gt; (참조 &lt;a href=&quot;low_002dlevel-parsing#Low_002dLevel-Parsing&quot;&gt;저수준 파싱&lt;/a&gt; ). 그러나 &lt;code&gt;syntax-ppss&lt;/code&gt; 는 계산 속도를 높이기 위해 캐시를 사용합니다. 이 최적화로 인해 반환 된 구문 분석기 상태의 두 번째 값 (이전 전체 하위 표현식)과 여섯 번째 값 (최소 괄호 깊이)은 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e18c940c557733fa2d17296522cd2ee2f382b25f" translate="yes" xml:space="preserve">
          <source>The return value is the total amount of leftward horizontal scrolling in effect after the change&amp;mdash;just like the value returned by &lt;code&gt;window-hscroll&lt;/code&gt; (below).</source>
          <target state="translated">반환 값은 &lt;code&gt;window-hscroll&lt;/code&gt; (아래)에서 반환 된 값과 마찬가지로 변경 후 적용되는 왼쪽 수평 스크롤의 총량입니다 .</target>
        </trans-unit>
        <trans-unit id="d57cd36326fa59864f8c712bddff5dc5bb7f668f" translate="yes" xml:space="preserve">
          <source>The return value is the value of the last form in &lt;var&gt;body&lt;/var&gt;. The current buffer is restored even in case of an abnormal exit via &lt;code&gt;throw&lt;/code&gt; or error (see &lt;a href=&quot;nonlocal-exits#Nonlocal-Exits&quot;&gt;Nonlocal Exits&lt;/a&gt;).</source>
          <target state="translated">반환 값은 &lt;var&gt;body&lt;/var&gt; 의 마지막 양식 값입니다 . 현재 버퍼는 &lt;code&gt;throw&lt;/code&gt; 또는 오류 를 통해 비정상적으로 종료 된 경우에도 복원됩니다 ( &lt;a href=&quot;nonlocal-exits#Nonlocal-Exits&quot;&gt;Nonlocal Exit&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="eb0d4689de602d882bfebd89386a5243b7f33720" translate="yes" xml:space="preserve">
          <source>The return value is the value of the last form in &lt;var&gt;body&lt;/var&gt;. You can return the contents of the temporary buffer by using &lt;code&gt;(buffer-string)&lt;/code&gt; as the last form.</source>
          <target state="translated">반환 값은 &lt;var&gt;body&lt;/var&gt; 의 마지막 양식 값입니다 . &lt;code&gt;(buffer-string)&lt;/code&gt; 을 마지막 형식으로 사용하여 임시 버퍼의 내용을 반환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="98b96176f1db00d3485afd4a66e4aa0f4d04fd5e" translate="yes" xml:space="preserve">
          <source>The return value makes sure that all components of &lt;var&gt;window&lt;/var&gt; remain fully visible if &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s size were actually set to it. With &lt;var&gt;horizontal&lt;/var&gt;&lt;code&gt;nil&lt;/code&gt; it includes the mode and header line, the horizontal scroll bar and the bottom divider, if present. With &lt;var&gt;horizontal&lt;/var&gt; non-&lt;code&gt;nil&lt;/code&gt; it includes the margins and fringes, the vertical scroll bar and the right divider, if present.</source>
          <target state="translated">반환 값의 모든 구성 요소 있는지 확인합니다 &lt;var&gt;window&lt;/var&gt; 경우 완전히 계속 표시 &lt;var&gt;window&lt;/var&gt; 의 크기가 실제로으로 설정되었다. &lt;var&gt;horizontal&lt;/var&gt; &lt;code&gt;nil&lt;/code&gt; 을 사용 하면 모드 및 헤더 행, 수평 스크롤 막대 및 하단 구분선 (있는 경우)이 포함됩니다. 하여 &lt;var&gt;horizontal&lt;/var&gt; 비 &lt;code&gt;nil&lt;/code&gt; 이는 마진 프린지, 수직 스크롤 바 및 우측 산기가 존재하는 경우를 포함한다.</target>
        </trans-unit>
        <trans-unit id="56acd2a554fb8715a71ba301e194647feef1c650" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;call-process-region&lt;/code&gt; is just like that of &lt;code&gt;call-process&lt;/code&gt;: &lt;code&gt;nil&lt;/code&gt; if you told it to return without waiting; otherwise, a number or string which indicates how the subprocess terminated.</source>
          <target state="translated">의 반환 값 &lt;code&gt;call-process-region&lt;/code&gt; 단지의처럼 &lt;code&gt;call-process&lt;/code&gt; : &lt;code&gt;nil&lt;/code&gt; 는 대기하지 않고 반환을 말했다 경우; 그렇지 않으면 하위 프로세스가 종료 된 방법을 나타내는 숫자 또는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="5069facca425b351b86dde2c2ae0c0771e388177" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;completion-table-dynamic&lt;/code&gt; is a function that can be used as the 2nd argument to &lt;code&gt;try-completion&lt;/code&gt; and &lt;code&gt;all-completions&lt;/code&gt;. Note that this function will always return empty metadata and trivial boundaries (see &lt;a href=&quot;#Programmed-Completion&quot;&gt;Programmed Completion&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;completion-table-dynamic&lt;/code&gt; 의 반환 값은 &lt;code&gt;try-completion&lt;/code&gt; 및 &lt;code&gt;all-completions&lt;/code&gt; 의 두 번째 인수로 사용할 수있는 함수입니다 . 이 함수는 항상 빈 메타 데이터와 사소한 경계를 반환합니다 ( &lt;a href=&quot;#Programmed-Completion&quot;&gt;프로그램 된 완성&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="eb1115fc8b41440862e5616560ee61c6930b3d4e" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;defun&lt;/code&gt; is undefined.</source>
          <target state="translated">&lt;code&gt;defun&lt;/code&gt; 의 반환 값 은 정의되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="a22f1787f8edaffd1df1c076115e598858217063" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;indent-relative&lt;/code&gt; is unpredictable.</source>
          <target state="translated">&lt;code&gt;indent-relative&lt;/code&gt; 의 반환 값 은 예측할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="40830d574522cf348ebff2db025053eb30711de0" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;map-y-or-n-p&lt;/code&gt; is the number of objects acted on.</source>
          <target state="translated">&lt;code&gt;map-y-or-n-p&lt;/code&gt; 의 반환 값은 작업 된 객체의 수입니다.</target>
        </trans-unit>
        <trans-unit id="bcb50cbd862df1ce6221c36f84f21509e97f8fb8" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;momentary-string-display&lt;/code&gt; is not meaningful.</source>
          <target state="translated">&lt;code&gt;momentary-string-display&lt;/code&gt; 의 반환 값은 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ee4347aba22a42b7519b85d2086502c660164bde" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;translate-region&lt;/code&gt; is the number of characters that were actually changed by the translation. This does not count characters that were mapped into themselves in the translation table.</source>
          <target state="translated">&lt;code&gt;translate-region&lt;/code&gt; 의 반환 값은 번역에 의해 실제로 변경된 문자 수입니다. 변환 테이블에서 자체적으로 매핑 된 문자는 계산되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ccc82eb191bcbf19332876523e72f6c383beea99" translate="yes" xml:space="preserve">
          <source>The return value of this function is &lt;code&gt;t&lt;/code&gt; if the text would be completely hidden on display, or a non-&lt;code&gt;nil&lt;/code&gt;, non-&lt;code&gt;t&lt;/code&gt; value if the text would be replaced by an ellipsis.</source>
          <target state="translated">이 함수의 리턴 값은 &lt;code&gt;t&lt;/code&gt; 텍스트 디스플레이에 완전히 숨길 것인지 또는 비 &lt;code&gt;nil&lt;/code&gt; , 비 &lt;code&gt;t&lt;/code&gt; 의 텍스트가 생략 부호로 대체 될 경우, 값.</target>
        </trans-unit>
        <trans-unit id="43b0ec1a11637964920ecb2540843fb9ed801524" translate="yes" xml:space="preserve">
          <source>The return value of this function. If omitted or &lt;code&gt;nil&lt;/code&gt;, return a process object. Otherwise, a cons of the form &lt;code&gt;(&lt;var&gt;process-object&lt;/var&gt;
. &lt;var&gt;plist&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;plist&lt;/var&gt; has keywords:</source>
          <target state="translated">이 함수의 반환 값입니다. 생략되거나 &lt;code&gt;nil&lt;/code&gt; 이면 프로세스 객체를 반환합니다. 그렇지 않으면 &lt;code&gt;(&lt;var&gt;process-object&lt;/var&gt; . &lt;var&gt;plist&lt;/var&gt;)&lt;/code&gt; 형식의 단점이 있습니다. 여기서 &lt;var&gt;plist&lt;/var&gt; 에는 키워드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b902298331d5acafbc78a6a866439d8f418148b" translate="yes" xml:space="preserve">
          <source>The returned &lt;em&gt;prec2&lt;/em&gt; table holds constraints between pairs of tokens, and for any given pair only one constraint can be present: T1 &amp;lt; T2, T1 = T2, or T1 &amp;gt; T2.</source>
          <target state="translated">반환 된 &lt;em&gt;prec2&lt;/em&gt; 테이블은 토큰 쌍 사이의 제약 조건을 보유하며 주어진 쌍에 대해 하나의 제약 조건 만 존재할 수 있습니다 : T1 &amp;lt;T2, T1 = T2 또는 T1&amp;gt; T2.</target>
        </trans-unit>
        <trans-unit id="dbc5dc6672398dd058c6b4f7b7fadc842548ff7b" translate="yes" xml:space="preserve">
          <source>The returned event may come directly from the user, or from a keyboard macro. It is not decoded by the keyboard&amp;rsquo;s input coding system (see &lt;a href=&quot;terminal-i_002fo-encoding#Terminal-I_002fO-Encoding&quot;&gt;Terminal I/O Encoding&lt;/a&gt;).</source>
          <target state="translated">반환 된 이벤트는 사용자 또는 키보드 매크로에서 직접 올 수 있습니다. 키보드의 입력 코딩 시스템에 의해 디코딩되지 않습니다 ( &lt;a href=&quot;terminal-i_002fo-encoding#Terminal-I_002fO-Encoding&quot;&gt;터미널 I / O 인코딩 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="4cdf1e97bec67e330632316ef5395fcf7caf2e12" translate="yes" xml:space="preserve">
          <source>The returned regexp is ordered in such a way that it will always match the longest string possible.</source>
          <target state="translated">반환 된 정규 표현식은 항상 가능한 가장 긴 문자열과 일치하도록 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="efdbd6df6dfdf2a517533221caa6311ed4d1e39a" translate="yes" xml:space="preserve">
          <source>The returned string may be &lt;var&gt;string&lt;/var&gt; itself if it does not contain any special characters.</source>
          <target state="translated">반환 된 문자열은 특수 문자를 포함하지 않는 경우 &lt;var&gt;string&lt;/var&gt; 자체 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fd9bc80d26777c7e0a2a7afa6c8e55fbe066df53" translate="yes" xml:space="preserve">
          <source>The returned value is a descriptor for the added watch. Its type depends on the underlying library, it cannot be assumed to be an integer as in the example below. It should be used for comparison by &lt;code&gt;equal&lt;/code&gt; only.</source>
          <target state="translated">반환 된 값은 추가 된 시계에 대한 설명자입니다. 그 유형은 기본 라이브러리에 따라 다르며 아래 예에서와 같이 정수라고 가정 할 수 없습니다. &lt;code&gt;equal&lt;/code&gt; 비교를 위해서만 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5526f73a053a966e99ef6b773d23afe60ad9d26c" translate="yes" xml:space="preserve">
          <source>The returned value is a string.</source>
          <target state="translated">반환 된 값은 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="265dcc02f70278df1fa86f8ca9c808c95d187ef5" translate="yes" xml:space="preserve">
          <source>The returned value is unpredictable.</source>
          <target state="translated">반환 된 값은 예측할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d67d7a62afb4deb22a1a4750f3d9471f23d28534" translate="yes" xml:space="preserve">
          <source>The right way to use this variable is to bind it with &lt;code&gt;let&lt;/code&gt; for a specific I/O operation. Its global value is normally &lt;code&gt;nil&lt;/code&gt;, and you should not globally set it to any other value. Here is an example of the right way to use the variable:</source>
          <target state="translated">이 변수를 사용하는 올바른 방법 은 특정 I / O 작업에 대해 &lt;code&gt;let&lt;/code&gt; 으로 바인딩하는 것입니다 . 전역 값은 일반적으로 &lt;code&gt;nil&lt;/code&gt; 이며 전역 적으로 다른 값으로 설정하면 안됩니다. 다음은 변수를 사용하는 올바른 방법의 예입니다.</target>
        </trans-unit>
        <trans-unit id="39952ca9e7a27cc76fd0f660398052f252830c23" translate="yes" xml:space="preserve">
          <source>The root window of this frame is an internal window, &lt;var&gt;W1&lt;/var&gt;. Its child windows form a horizontal combination, consisting of the live window &lt;var&gt;W2&lt;/var&gt; and the internal window &lt;var&gt;W3&lt;/var&gt;. The child windows of &lt;var&gt;W3&lt;/var&gt; form a vertical combination, consisting of the live windows &lt;var&gt;W4&lt;/var&gt; and &lt;var&gt;W5&lt;/var&gt;. Hence, the live windows in this window tree are &lt;var&gt;W2&lt;/var&gt;, &lt;var&gt;W4&lt;/var&gt;, and &lt;var&gt;W5&lt;/var&gt;.</source>
          <target state="translated">이 프레임의 루트 창은 내부 창 &lt;var&gt;W1&lt;/var&gt; 입니다. 하위 창은 라이브 창 ( &lt;var&gt;W2&lt;/var&gt; ) 과 내부 창 ( &lt;var&gt;W3&lt;/var&gt; ) 으로 구성된 수평 조합을 형성합니다 . &lt;var&gt;W3&lt;/var&gt; 의 자식 창은 라이브 창 &lt;var&gt;W4&lt;/var&gt; 및 &lt;var&gt;W5&lt;/var&gt; 로 구성된 수직 조합을 형성합니다 . 따라서이 창 트리의 라이브 창은 &lt;var&gt;W2&lt;/var&gt; , &lt;var&gt;W4&lt;/var&gt; 및 &lt;var&gt;W5&lt;/var&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="814d3881be5a72669b9ab4a2a2237b0156c64c15" translate="yes" xml:space="preserve">
          <source>The rule for finding the binding of a key sequence assumes that the intermediate bindings (found for the events before the last) are all keymaps; if this is not so, the sequence of events does not form a unit&amp;mdash;it is not really one key sequence. In other words, removing one or more events from the end of any valid key sequence must always yield a prefix key. For example,</source>
          <target state="translated">The rule for finding the binding of a key sequence assumes that the intermediate bindings (found for the events before the last) are all keymaps; if this is not so, the sequence of events does not form a unit&amp;mdash;it is not really one key sequence. In other words, removing one or more events from the end of any valid key sequence must always yield a prefix key. For example,</target>
        </trans-unit>
        <trans-unit id="2122fb4e21ddd11686b2348d982b3ec0119e1727" translate="yes" xml:space="preserve">
          <source>The rule for indentation after &lt;code&gt;&quot;:=&quot;&lt;/code&gt; exists because otherwise SMIE would treat &lt;code&gt;&quot;:=&quot;&lt;/code&gt; as an infix operator and would align the right argument with the left one.</source>
          <target state="translated">The rule for indentation after &lt;code&gt;&quot;:=&quot;&lt;/code&gt; exists because otherwise SMIE would treat &lt;code&gt;&quot;:=&quot;&lt;/code&gt; as an infix operator and would align the right argument with the left one.</target>
        </trans-unit>
        <trans-unit id="37f434c4f0270c5122c827e81b52b88938539dd1" translate="yes" xml:space="preserve">
          <source>The rule for indentation before &lt;code&gt;&quot;begin&quot;&lt;/code&gt; is an example of the use of virtual indentation: This rule is used only when &lt;code&gt;&quot;begin&quot;&lt;/code&gt; is hanging, which can happen only when &lt;code&gt;&quot;begin&quot;&lt;/code&gt; is not at the beginning of a line. So this is not used when indenting &lt;code&gt;&quot;begin&quot;&lt;/code&gt; itself but only when indenting something relative to this &lt;code&gt;&quot;begin&quot;&lt;/code&gt;. Concretely, this rule changes the indentation from:</source>
          <target state="translated">The rule for indentation before &lt;code&gt;&quot;begin&quot;&lt;/code&gt; is an example of the use of virtual indentation: This rule is used only when &lt;code&gt;&quot;begin&quot;&lt;/code&gt; is hanging, which can happen only when &lt;code&gt;&quot;begin&quot;&lt;/code&gt; is not at the beginning of a line. So this is not used when indenting &lt;code&gt;&quot;begin&quot;&lt;/code&gt; itself but only when indenting something relative to this &lt;code&gt;&quot;begin&quot;&lt;/code&gt; . Concretely, this rule changes the indentation from:</target>
        </trans-unit>
        <trans-unit id="d2ae301bb08cbc756929fb8516392dcfbc907e46" translate="yes" xml:space="preserve">
          <source>The rule for indentation before &lt;code&gt;&quot;if&quot;&lt;/code&gt; is similar to the one for &lt;code&gt;&quot;begin&quot;&lt;/code&gt;, but where the purpose is to treat &lt;code&gt;&quot;else if&quot;&lt;/code&gt; as a single unit, so as to align a sequence of tests rather than indent each test further to the right. This function does this only in the case where the &lt;code&gt;&quot;if&quot;&lt;/code&gt; is not placed on a separate line, hence the &lt;code&gt;smie-rule-bolp&lt;/code&gt; test.</source>
          <target state="translated">The rule for indentation before &lt;code&gt;&quot;if&quot;&lt;/code&gt; is similar to the one for &lt;code&gt;&quot;begin&quot;&lt;/code&gt; , but where the purpose is to treat &lt;code&gt;&quot;else if&quot;&lt;/code&gt; as a single unit, so as to align a sequence of tests rather than indent each test further to the right. This function does this only in the case where the &lt;code&gt;&quot;if&quot;&lt;/code&gt; is not placed on a separate line, hence the &lt;code&gt;smie-rule-bolp&lt;/code&gt; test.</target>
        </trans-unit>
        <trans-unit id="3e51195c9e4bef9ac5fed369ac13d21d4ecbb83d" translate="yes" xml:space="preserve">
          <source>The rule for the token &lt;code&gt;&quot;,&quot;&lt;/code&gt; make SMIE try to be more clever when the comma separator is placed at the beginning of lines. It tries to outdent the separator so as to align the code after the comma; for example:</source>
          <target state="translated">The rule for the token &lt;code&gt;&quot;,&quot;&lt;/code&gt; make SMIE try to be more clever when the comma separator is placed at the beginning of lines. It tries to outdent the separator so as to align the code after the comma; for example:</target>
        </trans-unit>
        <trans-unit id="2ea9d036c2f0944a227079154b59cbdc7f4c6f40" translate="yes" xml:space="preserve">
          <source>The rx Structured Regexp Notation</source>
          <target state="translated">The rx Structured Regexp Notation</target>
        </trans-unit>
        <trans-unit id="b8ef342720c667ded9bb4a10754ff3f59b3c59dd" translate="yes" xml:space="preserve">
          <source>The safe value definitions specified with &lt;code&gt;autoload&lt;/code&gt; are copied into the package&amp;rsquo;s autoloads file (</source>
          <target state="translated">The safe value definitions specified with &lt;code&gt;autoload&lt;/code&gt; are copied into the package&amp;rsquo;s autoloads file (</target>
        </trans-unit>
        <trans-unit id="3d3cd8e2cc092de1d198d6e2528520fe0e19f022" translate="yes" xml:space="preserve">
          <source>The same alist shown above could be regarded as having the associated value in the &lt;small&gt;CDR&lt;/small&gt; of the element; the value associated with &lt;code&gt;rose&lt;/code&gt; would be the list &lt;code&gt;(red)&lt;/code&gt;.</source>
          <target state="translated">The same alist shown above could be regarded as having the associated value in the &lt;small&gt;CDR&lt;/small&gt; of the element; the value associated with &lt;code&gt;rose&lt;/code&gt; would be the list &lt;code&gt;(red)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b598a52d532ebb9508666d7703290c6b51b2a77" translate="yes" xml:space="preserve">
          <source>The same comparison is made for the characters before the old and new locations. The result may be to execute two &lt;code&gt;point-left&lt;/code&gt; functions (which may be the same function) and/or two &lt;code&gt;point-entered&lt;/code&gt; functions (which may be the same function). In any case, all the &lt;code&gt;point-left&lt;/code&gt; functions are called first, followed by all the &lt;code&gt;point-entered&lt;/code&gt; functions.</source>
          <target state="translated">The same comparison is made for the characters before the old and new locations. The result may be to execute two &lt;code&gt;point-left&lt;/code&gt; functions (which may be the same function) and/or two &lt;code&gt;point-entered&lt;/code&gt; functions (which may be the same function). In any case, all the &lt;code&gt;point-left&lt;/code&gt; functions are called first, followed by all the &lt;code&gt;point-entered&lt;/code&gt; functions.</target>
        </trans-unit>
        <trans-unit id="76be1f3a5b9d85ac92db6757c8aa658e4c83550f" translate="yes" xml:space="preserve">
          <source>The same list represented in the second box notation looks like this:</source>
          <target state="translated">The same list represented in the second box notation looks like this:</target>
        </trans-unit>
        <trans-unit id="de2afa602b0c6c3641bec0bd9db4c0990c1cd810" translate="yes" xml:space="preserve">
          <source>The same magic comment can copy any kind of form into</source>
          <target state="translated">The same magic comment can copy any kind of form into</target>
        </trans-unit>
        <trans-unit id="4a6fb3f7c0f51bfade6342cfbde9264dd003c537" translate="yes" xml:space="preserve">
          <source>The same sort of thing goes for macros and &lt;code&gt;defsubst&lt;/code&gt; functions defined locally and only for use within the file. They are needed for compiling the file, but in most cases they are not needed for execution of the compiled file. For example,</source>
          <target state="translated">The same sort of thing goes for macros and &lt;code&gt;defsubst&lt;/code&gt; functions defined locally and only for use within the file. They are needed for compiling the file, but in most cases they are not needed for execution of the compiled file. For example,</target>
        </trans-unit>
        <trans-unit id="9eafcd90784684c4b6941c5a7e212f4389f29375" translate="yes" xml:space="preserve">
          <source>The scope of the &lt;code&gt;rx-let&lt;/code&gt; bindings is lexical, which means that they are not visible outside &lt;var&gt;body&lt;/var&gt; itself, even in functions called from &lt;var&gt;body&lt;/var&gt;.</source>
          <target state="translated">The scope of the &lt;code&gt;rx-let&lt;/code&gt; bindings is lexical, which means that they are not visible outside &lt;var&gt;body&lt;/var&gt; itself, even in functions called from &lt;var&gt;body&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="b2fa435053db7e98e5d129031c4eef40310ac931" translate="yes" xml:space="preserve">
          <source>The screen position of the left edge of the frame&amp;rsquo;s icon, in pixels, counting from the left edge of the screen. This takes effect when the frame is iconified, if the window manager supports this feature. If you specify a value for this parameter, then you must also specify a value for &lt;code&gt;icon-top&lt;/code&gt; and vice versa.</source>
          <target state="translated">The screen position of the left edge of the frame&amp;rsquo;s icon, in pixels, counting from the left edge of the screen. This takes effect when the frame is iconified, if the window manager supports this feature. If you specify a value for this parameter, then you must also specify a value for &lt;code&gt;icon-top&lt;/code&gt; and vice versa.</target>
        </trans-unit>
        <trans-unit id="e50e923623c82eb23aa190894066a65503358e35" translate="yes" xml:space="preserve">
          <source>The screen position of the top (or bottom) edge, in pixels, with respect to the top (or bottom) edge of the display or parent frame. It works just like &lt;code&gt;left&lt;/code&gt;, except vertically instead of horizontally.</source>
          <target state="translated">The screen position of the top (or bottom) edge, in pixels, with respect to the top (or bottom) edge of the display or parent frame. It works just like &lt;code&gt;left&lt;/code&gt; , except vertically instead of horizontally.</target>
        </trans-unit>
        <trans-unit id="0cda3076dfbc17092f6e7b4b160ef022e7169a19" translate="yes" xml:space="preserve">
          <source>The screen position of the top edge of the frame&amp;rsquo;s icon, in pixels, counting from the top edge of the screen. This takes effect when the frame is iconified, if the window manager supports this feature.</source>
          <target state="translated">The screen position of the top edge of the frame&amp;rsquo;s icon, in pixels, counting from the top edge of the screen. This takes effect when the frame is iconified, if the window manager supports this feature.</target>
        </trans-unit>
        <trans-unit id="e751536ab732a9f489e9afb199afec619dbdde42" translate="yes" xml:space="preserve">
          <source>The script that the font must support (a symbol).</source>
          <target state="translated">The script that the font must support (a symbol).</target>
        </trans-unit>
        <trans-unit id="5ca4bb9976c740ecc0981b8e9b17319d5ac9d81d" translate="yes" xml:space="preserve">
          <source>The search for an applicable handler checks all the established handlers starting with the most recently established one. Thus, if two nested &lt;code&gt;condition-case&lt;/code&gt; forms offer to handle the same error, the inner of the two gets to handle it.</source>
          <target state="translated">The search for an applicable handler checks all the established handlers starting with the most recently established one. Thus, if two nested &lt;code&gt;condition-case&lt;/code&gt; forms offer to handle the same error, the inner of the two gets to handle it.</target>
        </trans-unit>
        <trans-unit id="473e360900bfeca8b04b8a805f75bfd348f74028" translate="yes" xml:space="preserve">
          <source>The second argument &lt;var&gt;infile&lt;/var&gt; may invoke a file name handler. The file name handler could be different from the handler chosen for the &lt;code&gt;process-file&lt;/code&gt; function itself. (For example, &lt;code&gt;default-directory&lt;/code&gt; could be on one remote host, and &lt;var&gt;infile&lt;/var&gt; on a different remote host. Or &lt;code&gt;default-directory&lt;/code&gt; could be non-special, whereas &lt;var&gt;infile&lt;/var&gt; is on a remote host.)</source>
          <target state="translated">The second argument &lt;var&gt;infile&lt;/var&gt; may invoke a file name handler. The file name handler could be different from the handler chosen for the &lt;code&gt;process-file&lt;/code&gt; function itself. (For example, &lt;code&gt;default-directory&lt;/code&gt; could be on one remote host, and &lt;var&gt;infile&lt;/var&gt; on a different remote host. Or &lt;code&gt;default-directory&lt;/code&gt; could be non-special, whereas &lt;var&gt;infile&lt;/var&gt; is on a remote host.)</target>
        </trans-unit>
        <trans-unit id="79312a7cce37d37bed367239a38284f2028a8f95" translate="yes" xml:space="preserve">
          <source>The second argument &lt;var&gt;size&lt;/var&gt; is the size of text, in characters, following point. The function examines text only within &lt;var&gt;size&lt;/var&gt; characters after point. Normally, the buffer should be positioned at the beginning when this function is called, because one of the places for the &lt;code&gt;coding:&lt;/code&gt; tag is the first one or two lines of the file; in that case, &lt;var&gt;size&lt;/var&gt; should be the size of the buffer.</source>
          <target state="translated">The second argument &lt;var&gt;size&lt;/var&gt; is the size of text, in characters, following point. The function examines text only within &lt;var&gt;size&lt;/var&gt; characters after point. Normally, the buffer should be positioned at the beginning when this function is called, because one of the places for the &lt;code&gt;coding:&lt;/code&gt; tag is the first one or two lines of the file; in that case, &lt;var&gt;size&lt;/var&gt; should be the size of the buffer.</target>
        </trans-unit>
        <trans-unit id="b1571642b672d840c71b1f3b7f58f82da1c8dc26" translate="yes" xml:space="preserve">
          <source>The second argument of &lt;code&gt;condition-case&lt;/code&gt; is called the &lt;em&gt;protected form&lt;/em&gt;. (In the example above, the protected form is a call to &lt;code&gt;delete-file&lt;/code&gt;.) The error handlers go into effect when this form begins execution and are deactivated when this form returns. They remain in effect for all the intervening time. In particular, they are in effect during the execution of functions called by this form, in their subroutines, and so on. This is a good thing, since, strictly speaking, errors can be signaled only by Lisp primitives (including &lt;code&gt;signal&lt;/code&gt; and &lt;code&gt;error&lt;/code&gt;) called by the protected form, not by the protected form itself.</source>
          <target state="translated">The second argument of &lt;code&gt;condition-case&lt;/code&gt; is called the &lt;em&gt;protected form&lt;/em&gt;. (In the example above, the protected form is a call to &lt;code&gt;delete-file&lt;/code&gt; .) The error handlers go into effect when this form begins execution and are deactivated when this form returns. They remain in effect for all the intervening time. In particular, they are in effect during the execution of functions called by this form, in their subroutines, and so on. This is a good thing, since, strictly speaking, errors can be signaled only by Lisp primitives (including &lt;code&gt;signal&lt;/code&gt; and &lt;code&gt;error&lt;/code&gt; ) called by the protected form, not by the protected form itself.</target>
        </trans-unit>
        <trans-unit id="335d04a9fb11a0984d4c4b395642d49eb8062099" translate="yes" xml:space="preserve">
          <source>The second argument, &lt;var&gt;minibuf&lt;/var&gt;, says which frames to consider:</source>
          <target state="translated">The second argument, &lt;var&gt;minibuf&lt;/var&gt; , says which frames to consider:</target>
        </trans-unit>
        <trans-unit id="043e175330e7a9266b5fd9e72aad0ac9c4f497a2" translate="yes" xml:space="preserve">
          <source>The second cons cell, which previously held the element &lt;code&gt;b&lt;/code&gt;, still exists and its &lt;small&gt;CAR&lt;/small&gt; is still &lt;code&gt;b&lt;/code&gt;, but it no longer forms part of this list.</source>
          <target state="translated">The second cons cell, which previously held the element &lt;code&gt;b&lt;/code&gt; , still exists and its &lt;small&gt;CAR&lt;/small&gt; is still &lt;code&gt;b&lt;/code&gt; , but it no longer forms part of this list.</target>
        </trans-unit>
        <trans-unit id="cc4971cc83ebc92e997f73e4a1271f23051fec45" translate="yes" xml:space="preserve">
          <source>The second crucial difference between macros and functions is that the value returned by the macro body is an alternate Lisp expression, also known as the &lt;em&gt;expansion&lt;/em&gt; of the macro. The Lisp interpreter proceeds to evaluate the expansion as soon as it comes back from the macro.</source>
          <target state="translated">The second crucial difference between macros and functions is that the value returned by the macro body is an alternate Lisp expression, also known as the &lt;em&gt;expansion&lt;/em&gt; of the macro. The Lisp interpreter proceeds to evaluate the expansion as soon as it comes back from the macro.</target>
        </trans-unit>
        <trans-unit id="f1a6950eaae19621908380f623f25ce6e57c63a4" translate="yes" xml:space="preserve">
          <source>The second element is a list of symbols&amp;mdash;the argument variable names. This is called the &lt;em&gt;lambda list&lt;/em&gt;. When a Lisp function is called, the argument values are matched up against the variables in the lambda list, which are given local bindings with the values provided. See &lt;a href=&quot;local-variables#Local-Variables&quot;&gt;Local Variables&lt;/a&gt;.</source>
          <target state="translated">The second element is a list of symbols&amp;mdash;the argument variable names. This is called the &lt;em&gt;lambda list&lt;/em&gt;. When a Lisp function is called, the argument values are matched up against the variables in the lambda list, which are given local bindings with the values provided. See &lt;a href=&quot;local-variables#Local-Variables&quot;&gt;Local Variables&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="ca40c0325b239bb969d90b6c5d596d17aee4f342" translate="yes" xml:space="preserve">
          <source>The second element, &lt;var&gt;keywords-only&lt;/var&gt;, specifies the value of the variable &lt;code&gt;font-lock-keywords-only&lt;/code&gt;. If this is omitted or &lt;code&gt;nil&lt;/code&gt;, syntactic fontification (of strings and comments) is also performed. If this is non-&lt;code&gt;nil&lt;/code&gt;, syntactic fontification is not performed. See &lt;a href=&quot;syntactic-font-lock#Syntactic-Font-Lock&quot;&gt;Syntactic Font Lock&lt;/a&gt;.</source>
          <target state="translated">The second element, &lt;var&gt;keywords-only&lt;/var&gt; , specifies the value of the variable &lt;code&gt;font-lock-keywords-only&lt;/code&gt; . If this is omitted or &lt;code&gt;nil&lt;/code&gt; , syntactic fontification (of strings and comments) is also performed. If this is non- &lt;code&gt;nil&lt;/code&gt; , syntactic fontification is not performed. See &lt;a href=&quot;syntactic-font-lock#Syntactic-Font-Lock&quot;&gt;Syntactic Font Lock&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="05af5100d6bbcd92ab672dd54e8a7002bdd81fa9" translate="yes" xml:space="preserve">
          <source>The second example shows that when the final argument is a sequence but not a list, the sequence&amp;rsquo;s elements do not become elements of the resulting list. Instead, the sequence becomes the final &lt;small&gt;CDR&lt;/small&gt;, like any other non-list final argument.</source>
          <target state="translated">The second example shows that when the final argument is a sequence but not a list, the sequence&amp;rsquo;s elements do not become elements of the resulting list. Instead, the sequence becomes the final &lt;small&gt;CDR&lt;/small&gt;, like any other non-list final argument.</target>
        </trans-unit>
        <trans-unit id="78870468f3063c31ec99a482f80bcfe4fdf9caa7" translate="yes" xml:space="preserve">
          <source>The second item in the list, &lt;var&gt;regexp&lt;/var&gt;, is a regular expression (see &lt;a href=&quot;regular-expressions#Regular-Expressions&quot;&gt;Regular Expressions&lt;/a&gt;); anything in the buffer that it matches is considered a definition, something to mention in the buffer index. The third item, &lt;var&gt;index&lt;/var&gt;, is a non-negative integer that indicates which subexpression in &lt;var&gt;regexp&lt;/var&gt; matches the definition&amp;rsquo;s name.</source>
          <target state="translated">The second item in the list, &lt;var&gt;regexp&lt;/var&gt; , is a regular expression (see &lt;a href=&quot;regular-expressions#Regular-Expressions&quot;&gt;Regular Expressions&lt;/a&gt;); anything in the buffer that it matches is considered a definition, something to mention in the buffer index. The third item, &lt;var&gt;index&lt;/var&gt; , is a non-negative integer that indicates which subexpression in &lt;var&gt;regexp&lt;/var&gt; matches the definition&amp;rsquo;s name.</target>
        </trans-unit>
        <trans-unit id="39db81295962c9250ac04e8024ae7b73da16e061" translate="yes" xml:space="preserve">
          <source>The second of these hooks is run when a &lt;em&gt;window size change&lt;/em&gt; has been detected which means that a window was created, assigned another buffer, or changed its total size or that of its text area.</source>
          <target state="translated">The second of these hooks is run when a &lt;em&gt;window size change&lt;/em&gt; has been detected which means that a window was created, assigned another buffer, or changed its total size or that of its text area.</target>
        </trans-unit>
        <trans-unit id="e10a4024014db92893950553799fa332ec4eec91" translate="yes" xml:space="preserve">
          <source>The second part of the pattern matches any closing braces and quotation marks, zero or more of them, that may follow the period, question mark or exclamation mark. The &lt;code&gt;\&quot;&lt;/code&gt; is Lisp syntax for a double-quote in a string. The &amp;lsquo;</source>
          <target state="translated">The second part of the pattern matches any closing braces and quotation marks, zero or more of them, that may follow the period, question mark or exclamation mark. The &lt;code&gt;\&quot;&lt;/code&gt; is Lisp syntax for a double-quote in a string. The &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="7da34c753b40326f37f6172c1b58a8c5f825b8f9" translate="yes" xml:space="preserve">
          <source>The selected frame is on a graphical display supporting such dialogs.</source>
          <target state="translated">The selected frame is on a graphical display supporting such dialogs.</target>
        </trans-unit>
        <trans-unit id="dda9cd63960f9a91b850378b1927da3e714f3287" translate="yes" xml:space="preserve">
          <source>The selected window if it is either specified by a &lt;code&gt;previous-window&lt;/code&gt;&lt;var&gt;alist&lt;/var&gt; entry or showed &lt;var&gt;buffer&lt;/var&gt; before.</source>
          <target state="translated">The selected window if it is either specified by a &lt;code&gt;previous-window&lt;/code&gt; &lt;var&gt;alist&lt;/var&gt; entry or showed &lt;var&gt;buffer&lt;/var&gt; before.</target>
        </trans-unit>
        <trans-unit id="4beffd62ee0e9328af316739d55ab903054a8e51" translate="yes" xml:space="preserve">
          <source>The selected window is considered part of a group when the buffer local variable &lt;code&gt;selected-window-group-function&lt;/code&gt; is set to a function. In this case, &lt;code&gt;selected-window-group&lt;/code&gt; calls it with no arguments and returns its result (which should be the list of windows in the group).</source>
          <target state="translated">The selected window is considered part of a group when the buffer local variable &lt;code&gt;selected-window-group-function&lt;/code&gt; is set to a function. In this case, &lt;code&gt;selected-window-group&lt;/code&gt; calls it with no arguments and returns its result (which should be the list of windows in the group).</target>
        </trans-unit>
        <trans-unit id="c7b994494213138fb5de0429d794e7e303777bef" translate="yes" xml:space="preserve">
          <source>The selected window is the one that you edit in.</source>
          <target state="translated">The selected window is the one that you edit in.</target>
        </trans-unit>
        <trans-unit id="8665184a4907ab2354fc3286c669e4a6527d1f62" translate="yes" xml:space="preserve">
          <source>The selected window&amp;rsquo;s mode line is usually displayed in a different color using the face &lt;code&gt;mode-line&lt;/code&gt;. Other windows&amp;rsquo; mode lines appear in the face &lt;code&gt;mode-line-inactive&lt;/code&gt; instead. See &lt;a href=&quot;faces#Faces&quot;&gt;Faces&lt;/a&gt;.</source>
          <target state="translated">The selected window&amp;rsquo;s mode line is usually displayed in a different color using the face &lt;code&gt;mode-line&lt;/code&gt; . Other windows&amp;rsquo; mode lines appear in the face &lt;code&gt;mode-line-inactive&lt;/code&gt; instead. See &lt;a href=&quot;faces#Faces&quot;&gt;Faces&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="e8000cca8be137f75ed18782493ccc880df1113c" translate="yes" xml:space="preserve">
          <source>The semantics of maximizing and iconifying child frames is highly window-system dependent. As a rule, applications should never invoke these operations on child frames. By default, invoking &lt;code&gt;iconify-frame&lt;/code&gt; on a child frame will try to iconify the top-level frame corresponding to that child frame instead. To obtain a different behavior, users may customize the option &lt;code&gt;iconify-child-frame&lt;/code&gt; described below.</source>
          <target state="translated">The semantics of maximizing and iconifying child frames is highly window-system dependent. As a rule, applications should never invoke these operations on child frames. By default, invoking &lt;code&gt;iconify-frame&lt;/code&gt; on a child frame will try to iconify the top-level frame corresponding to that child frame instead. To obtain a different behavior, users may customize the option &lt;code&gt;iconify-child-frame&lt;/code&gt; described below.</target>
        </trans-unit>
        <trans-unit id="1fdee8f54d168addba0e7230f98080d05a806af9" translate="yes" xml:space="preserve">
          <source>The sequence of calls to &lt;code&gt;select-window&lt;/code&gt; with a non-&lt;code&gt;nil&lt;/code&gt;&lt;var&gt;norecord&lt;/var&gt; argument determines an ordering of windows by their selection time. The function &lt;code&gt;get-lru-window&lt;/code&gt; can be used to retrieve the least recently selected live window (see &lt;a href=&quot;cyclic-window-ordering#Cyclic-Window-Ordering&quot;&gt;Cyclic Window Ordering&lt;/a&gt;).</source>
          <target state="translated">The sequence of calls to &lt;code&gt;select-window&lt;/code&gt; with a non- &lt;code&gt;nil&lt;/code&gt; &lt;var&gt;norecord&lt;/var&gt; argument determines an ordering of windows by their selection time. The function &lt;code&gt;get-lru-window&lt;/code&gt; can be used to retrieve the least recently selected live window (see &lt;a href=&quot;cyclic-window-ordering#Cyclic-Window-Ordering&quot;&gt;Cyclic Window Ordering&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="b6126ae190f28d94232911a10b32f330dbd4538f" translate="yes" xml:space="preserve">
          <source>The sequence of kills in the kill ring wraps around, so that after the oldest one comes the newest one, and before the newest one goes the oldest.</source>
          <target state="translated">The sequence of kills in the kill ring wraps around, so that after the oldest one comes the newest one, and before the newest one goes the oldest.</target>
        </trans-unit>
        <trans-unit id="d17460f17018f05e49ff10eb23d17bcf4ac2e075" translate="yes" xml:space="preserve">
          <source>The serial port can be configured at run-time, without having to close and re-open it. The function &lt;code&gt;serial-process-configure&lt;/code&gt; lets you change the speed, bytesize, and other parameters. In a terminal window created by &lt;code&gt;serial-term&lt;/code&gt;, you can click on the mode line for configuration.</source>
          <target state="translated">The serial port can be configured at run-time, without having to close and re-open it. The function &lt;code&gt;serial-process-configure&lt;/code&gt; lets you change the speed, bytesize, and other parameters. In a terminal window created by &lt;code&gt;serial-term&lt;/code&gt; , you can click on the mode line for configuration.</target>
        </trans-unit>
        <trans-unit id="d2a9ae6c941e0bf24383fb2647a4f9171e1de594" translate="yes" xml:space="preserve">
          <source>The server supports hyperlinks in the notifications.</source>
          <target state="translated">The server supports hyperlinks in the notifications.</target>
        </trans-unit>
        <trans-unit id="1636c548d4728e3546b4e61c467b130421fb3043" translate="yes" xml:space="preserve">
          <source>The server supports images in the notifications.</source>
          <target state="translated">The server supports images in the notifications.</target>
        </trans-unit>
        <trans-unit id="3b6b682f52a52c12c8f9b21281af0b720bd16c65" translate="yes" xml:space="preserve">
          <source>The server supports persistence of notifications.</source>
          <target state="translated">The server supports persistence of notifications.</target>
        </trans-unit>
        <trans-unit id="21a9b47dbf0032eaa7cb77326a6a549f6f528a88" translate="yes" xml:space="preserve">
          <source>The server supports sounds on notifications.</source>
          <target state="translated">The server supports sounds on notifications.</target>
        </trans-unit>
        <trans-unit id="32a2fb16a21966056b09359c49d25b26580e0735" translate="yes" xml:space="preserve">
          <source>The server will provide the specified actions to the user.</source>
          <target state="translated">The server will provide the specified actions to the user.</target>
        </trans-unit>
        <trans-unit id="487bc1e1eea831388d87886ebed5499c261328d4" translate="yes" xml:space="preserve">
          <source>The server will render an animation of all the frames in a given image array.</source>
          <target state="translated">The server will render an animation of all the frames in a given image array.</target>
        </trans-unit>
        <trans-unit id="3d669bc7256cde6bc52048dc9f7dc18c0ff77233" translate="yes" xml:space="preserve">
          <source>The server&amp;rsquo;s process buffer value is never used directly, but the log function can retrieve it and use it to log connections by inserting text there.</source>
          <target state="translated">The server&amp;rsquo;s process buffer value is never used directly, but the log function can retrieve it and use it to log connections by inserting text there.</target>
        </trans-unit>
        <trans-unit id="d4af74ba408681f224f4eae7dc1fcceae876b1eb" translate="yes" xml:space="preserve">
          <source>The server&amp;rsquo;s version number.</source>
          <target state="translated">The server&amp;rsquo;s version number.</target>
        </trans-unit>
        <trans-unit id="850499dab30d08985261f9268e55591d68aa5d33" translate="yes" xml:space="preserve">
          <source>The session ID of the process. This is a number that is the process ID of the process&amp;rsquo;s &lt;em&gt;session leader&lt;/em&gt;.</source>
          <target state="translated">The session ID of the process. This is a number that is the process ID of the process&amp;rsquo;s &lt;em&gt;session leader&lt;/em&gt;.</target>
        </trans-unit>
        <trans-unit id="76fb62b9ff894328ee87291f8886595e1599a44b" translate="yes" xml:space="preserve">
          <source>The set of abbrevs currently in effect is recorded in an &lt;em&gt;abbrev table&lt;/em&gt;. Each buffer has a local abbrev table, but normally all buffers in the same major mode share one abbrev table. There is also a global abbrev table. Normally both are used.</source>
          <target state="translated">The set of abbrevs currently in effect is recorded in an &lt;em&gt;abbrev table&lt;/em&gt;. Each buffer has a local abbrev table, but normally all buffers in the same major mode share one abbrev table. There is also a global abbrev table. Normally both are used.</target>
        </trans-unit>
        <trans-unit id="13bc56e40d973a547522dffd931b5104b534cbab" translate="yes" xml:space="preserve">
          <source>The set of possible multi-event key sequences depends on the bindings for prefix keys; therefore, it can be different for different keymaps, and can change when bindings are changed. However, a one-event sequence is always a key sequence, because it does not depend on any prefix keys for its well-formedness.</source>
          <target state="translated">The set of possible multi-event key sequences depends on the bindings for prefix keys; therefore, it can be different for different keymaps, and can change when bindings are changed. However, a one-event sequence is always a key sequence, because it does not depend on any prefix keys for its well-formedness.</target>
        </trans-unit>
        <trans-unit id="ea89afa3ebcf085515befba35c098def36ebf120" translate="yes" xml:space="preserve">
          <source>The set of supported &lt;code&gt;TZ&lt;/code&gt; strings is system-dependent. GNU and many other systems support the tzdata database, e.g., &amp;lsquo;</source>
          <target state="translated">The set of supported &lt;code&gt;TZ&lt;/code&gt; strings is system-dependent. GNU and many other systems support the tzdata database, e.g., &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="ed52d340e29425d0c36d441fce1706eefbff92a9" translate="yes" xml:space="preserve">
          <source>The setf Macro</source>
          <target state="translated">The setf Macro</target>
        </trans-unit>
        <trans-unit id="656aedcd7cd333555b5a910bc06a2f9bb048509a" translate="yes" xml:space="preserve">
          <source>The shell command &lt;code&gt;printenv&lt;/code&gt; prints all or part of the environment:</source>
          <target state="translated">The shell command &lt;code&gt;printenv&lt;/code&gt; prints all or part of the environment:</target>
        </trans-unit>
        <trans-unit id="697532010a390342417a302aa64e0eeb89a98cb2" translate="yes" xml:space="preserve">
          <source>The shell command &lt;code&gt;uptime&lt;/code&gt; returns similar information.</source>
          <target state="translated">The shell command &lt;code&gt;uptime&lt;/code&gt; returns similar information.</target>
        </trans-unit>
        <trans-unit id="7c0ee07626a06ec319c5fa6dda80e5cd02b895c5" translate="yes" xml:space="preserve">
          <source>The shift modifier.</source>
          <target state="translated">The shift modifier.</target>
        </trans-unit>
        <trans-unit id="526047c002039949790c223830818877585cd005" translate="yes" xml:space="preserve">
          <source>The significant way that errors are classified is by their condition names&amp;mdash;the names used to match errors with handlers. An error symbol serves only as a convenient way to specify the intended error message and list of condition names. It would be cumbersome to give &lt;code&gt;signal&lt;/code&gt; a list of condition names rather than one error symbol.</source>
          <target state="translated">The significant way that errors are classified is by their condition names&amp;mdash;the names used to match errors with handlers. An error symbol serves only as a convenient way to specify the intended error message and list of condition names. It would be cumbersome to give &lt;code&gt;signal&lt;/code&gt; a list of condition names rather than one error symbol.</target>
        </trans-unit>
        <trans-unit id="701a4ad01ef06b4bddd59b324ead42eff350dde1" translate="yes" xml:space="preserve">
          <source>The simple way to define an inline function, is to write &lt;code&gt;defsubst&lt;/code&gt; instead of &lt;code&gt;defun&lt;/code&gt;. The rest of the definition looks just the same, but using &lt;code&gt;defsubst&lt;/code&gt; says to make it inline for byte compilation.</source>
          <target state="translated">The simple way to define an inline function, is to write &lt;code&gt;defsubst&lt;/code&gt; instead of &lt;code&gt;defun&lt;/code&gt; . The rest of the definition looks just the same, but using &lt;code&gt;defsubst&lt;/code&gt; says to make it inline for byte compilation.</target>
        </trans-unit>
        <trans-unit id="51e0da75b610832dceffa32e7fc903b0a72cc0e2" translate="yes" xml:space="preserve">
          <source>The simpler (and original) way to define a menu item is to bind some event type (it doesn&amp;rsquo;t matter what event type) to a binding like this:</source>
          <target state="translated">The simpler (and original) way to define a menu item is to bind some event type (it doesn&amp;rsquo;t matter what event type) to a binding like this:</target>
        </trans-unit>
        <trans-unit id="c63bdaac10002dfd9144bf4493ac37c5ee6a7227" translate="yes" xml:space="preserve">
          <source>The simplest order of execution is sequential execution: first form &lt;var&gt;a&lt;/var&gt;, then form &lt;var&gt;b&lt;/var&gt;, and so on. This is what happens when you write several forms in succession in the body of a function, or at top level in a file of Lisp code&amp;mdash;the forms are executed in the order written. We call this &lt;em&gt;textual order&lt;/em&gt;. For example, if a function body consists of two forms &lt;var&gt;a&lt;/var&gt; and &lt;var&gt;b&lt;/var&gt;, evaluation of the function evaluates first &lt;var&gt;a&lt;/var&gt; and then &lt;var&gt;b&lt;/var&gt;. The result of evaluating &lt;var&gt;b&lt;/var&gt; becomes the value of the function.</source>
          <target state="translated">The simplest order of execution is sequential execution: first form &lt;var&gt;a&lt;/var&gt; , then form &lt;var&gt;b&lt;/var&gt; , and so on. This is what happens when you write several forms in succession in the body of a function, or at top level in a file of Lisp code&amp;mdash;the forms are executed in the order written. We call this &lt;em&gt;textual order&lt;/em&gt;. For example, if a function body consists of two forms &lt;var&gt;a&lt;/var&gt; and &lt;var&gt;b&lt;/var&gt; , evaluation of the function evaluates first &lt;var&gt;a&lt;/var&gt; and then &lt;var&gt;b&lt;/var&gt; . The result of evaluating &lt;var&gt;b&lt;/var&gt; becomes the value of the function.</target>
        </trans-unit>
        <trans-unit id="2e0a2f8802289814697d3ff9bc642bb98ac915eb" translate="yes" xml:space="preserve">
          <source>The simplest way to add an element to an alist is like this:</source>
          <target state="translated">The simplest way to add an element to an alist is like this:</target>
        </trans-unit>
        <trans-unit id="b58a2304ffb2d18ce86b489ba35624a904a8a1e9" translate="yes" xml:space="preserve">
          <source>The simplest way to examine text properties is to ask for the value of a particular property of a particular character. For that, use &lt;code&gt;get-text-property&lt;/code&gt;. Use &lt;code&gt;text-properties-at&lt;/code&gt; to get the entire property list of a character. See &lt;a href=&quot;property-search#Property-Search&quot;&gt;Property Search&lt;/a&gt;, for functions to examine the properties of a number of characters at once.</source>
          <target state="translated">The simplest way to examine text properties is to ask for the value of a particular property of a particular character. For that, use &lt;code&gt;get-text-property&lt;/code&gt; . Use &lt;code&gt;text-properties-at&lt;/code&gt; to get the entire property list of a character. See &lt;a href=&quot;property-search#Property-Search&quot;&gt;Property Search&lt;/a&gt;, for functions to examine the properties of a number of characters at once.</target>
        </trans-unit>
        <trans-unit id="adc76fb843de7f5b33d2478fbfc134dfe5c4dcf3" translate="yes" xml:space="preserve">
          <source>The simplest way to use a variable is &lt;em&gt;globally&lt;/em&gt;. This means that the variable has just one value at a time, and this value is in effect (at least for the moment) throughout the Lisp system. The value remains in effect until you specify a new one. When a new value replaces the old one, no trace of the old value remains in the variable.</source>
          <target state="translated">The simplest way to use a variable is &lt;em&gt;globally&lt;/em&gt;. This means that the variable has just one value at a time, and this value is in effect (at least for the moment) throughout the Lisp system. The value remains in effect until you specify a new one. When a new value replaces the old one, no trace of the old value remains in the variable.</target>
        </trans-unit>
        <trans-unit id="2b36ac08912d39209d118742c10208da562be7cf" translate="yes" xml:space="preserve">
          <source>The size of buffer&amp;rsquo;s gap. See &lt;a href=&quot;buffer-gap#Buffer-Gap&quot;&gt;Buffer Gap&lt;/a&gt;.</source>
          <target state="translated">The size of buffer&amp;rsquo;s gap. See &lt;a href=&quot;buffer-gap#Buffer-Gap&quot;&gt;Buffer Gap&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="873e96ede3bbdf4e5518603c5529cf1eece61c3f" translate="yes" xml:space="preserve">
          <source>The size of the accessible part of the current buffer; basically &lt;code&gt;(- (point-max) (point-min))&lt;/code&gt;.</source>
          <target state="translated">The size of the accessible part of the current buffer; basically &lt;code&gt;(- (point-max) (point-min))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a849ae6a00f9521aec6d2261f95fba3341d311e" translate="yes" xml:space="preserve">
          <source>The size of the file in bytes (&lt;code&gt;file-attribute-size&lt;/code&gt;).</source>
          <target state="translated">The size of the file in bytes ( &lt;code&gt;file-attribute-size&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="8f563b6a9a8db0e9d2b8a141ce4f9b7d9e8e1e86" translate="yes" xml:space="preserve">
          <source>The size of the new window can be adjusted by supplying &lt;code&gt;window-height&lt;/code&gt; and &lt;code&gt;window-width&lt;/code&gt; entries in &lt;var&gt;alist&lt;/var&gt;. If &lt;var&gt;alist&lt;/var&gt; contains a &lt;code&gt;preserve-size&lt;/code&gt; entry, Emacs will also try to preserve the size of the new window during future resize operations (see &lt;a href=&quot;preserving-window-sizes#Preserving-Window-Sizes&quot;&gt;Preserving Window Sizes&lt;/a&gt;).</source>
          <target state="translated">The size of the new window can be adjusted by supplying &lt;code&gt;window-height&lt;/code&gt; and &lt;code&gt;window-width&lt;/code&gt; entries in &lt;var&gt;alist&lt;/var&gt; . If &lt;var&gt;alist&lt;/var&gt; contains a &lt;code&gt;preserve-size&lt;/code&gt; entry, Emacs will also try to preserve the size of the new window during future resize operations (see &lt;a href=&quot;preserving-window-sizes#Preserving-Window-Sizes&quot;&gt;Preserving Window Sizes&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="43af7be726f5955aa5ff42c15118a19504247059" translate="yes" xml:space="preserve">
          <source>The size of the process&amp;rsquo;s &lt;em&gt;resident set&lt;/em&gt;, the number of kilobytes occupied by the process in the machine&amp;rsquo;s physical memory.</source>
          <target state="translated">The size of the process&amp;rsquo;s &lt;em&gt;resident set&lt;/em&gt;, the number of kilobytes occupied by the process in the machine&amp;rsquo;s physical memory.</target>
        </trans-unit>
        <trans-unit id="576b8e3ff0609705a9b9504b486dacc40004ea6d" translate="yes" xml:space="preserve">
          <source>The sorting functions described in this section all rearrange text in a buffer. This is in contrast to the function &lt;code&gt;sort&lt;/code&gt;, which rearranges the order of the elements of a list (see &lt;a href=&quot;rearrangement#Rearrangement&quot;&gt;Rearrangement&lt;/a&gt;). The values returned by these functions are not meaningful.</source>
          <target state="translated">The sorting functions described in this section all rearrange text in a buffer. This is in contrast to the function &lt;code&gt;sort&lt;/code&gt; , which rearranges the order of the elements of a list (see &lt;a href=&quot;rearrangement#Rearrangement&quot;&gt;Rearrangement&lt;/a&gt;). The values returned by these functions are not meaningful.</target>
        </trans-unit>
        <trans-unit id="4c3d2a4b26d988675d4c78f53514dab4c53dcc03" translate="yes" xml:space="preserve">
          <source>The sound must be stored as a file in RIFF-WAVE format (&amp;lsquo;</source>
          <target state="translated">The sound must be stored as a file in RIFF-WAVE format (&amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="0497cf1b10750bd04c03011dc18b4f0cfdc47413" translate="yes" xml:space="preserve">
          <source>The space of possible character codes is divided into various character sets.</source>
          <target state="translated">The space of possible character codes is divided into various character sets.</target>
        </trans-unit>
        <trans-unit id="9432d6b9187cb979929edaa344995bf72578704f" translate="yes" xml:space="preserve">
          <source>The special commands of Edebug are available in the source code buffer in addition to the commands of Emacs Lisp mode. For example, you can type the Edebug command</source>
          <target state="translated">The special commands of Edebug are available in the source code buffer in addition to the commands of Emacs Lisp mode. For example, you can type the Edebug command</target>
        </trans-unit>
        <trans-unit id="749a997c2ad2240b06198fe40cd85ef622970354" translate="yes" xml:space="preserve">
          <source>The special commands of these modes bind &lt;code&gt;buffer-read-only&lt;/code&gt; to &lt;code&gt;nil&lt;/code&gt; (with &lt;code&gt;let&lt;/code&gt;) or bind &lt;code&gt;inhibit-read-only&lt;/code&gt; to &lt;code&gt;t&lt;/code&gt; around the places where they themselves change the text.</source>
          <target state="translated">The special commands of these modes bind &lt;code&gt;buffer-read-only&lt;/code&gt; to &lt;code&gt;nil&lt;/code&gt; (with &lt;code&gt;let&lt;/code&gt; ) or bind &lt;code&gt;inhibit-read-only&lt;/code&gt; to &lt;code&gt;t&lt;/code&gt; around the places where they themselves change the text.</target>
        </trans-unit>
        <trans-unit id="388ba11e949e8870ac609c14e29761f15abdd417" translate="yes" xml:space="preserve">
          <source>The special form &lt;code&gt;interactive&lt;/code&gt; turns a Lisp function into a command. The &lt;code&gt;interactive&lt;/code&gt; form must be located at top-level in the function body, usually as the first form in the body; this applies to both lambda expressions (see &lt;a href=&quot;lambda-expressions#Lambda-Expressions&quot;&gt;Lambda Expressions&lt;/a&gt;) and &lt;code&gt;defun&lt;/code&gt; forms (see &lt;a href=&quot;defining-functions#Defining-Functions&quot;&gt;Defining Functions&lt;/a&gt;). This form does nothing during the actual execution of the function; its presence serves as a flag, telling the Emacs command loop that the function can be called interactively. The argument of the &lt;code&gt;interactive&lt;/code&gt; form specifies how the arguments for an interactive call should be read.</source>
          <target state="translated">The special form &lt;code&gt;interactive&lt;/code&gt; turns a Lisp function into a command. The &lt;code&gt;interactive&lt;/code&gt; form must be located at top-level in the function body, usually as the first form in the body; this applies to both lambda expressions (see &lt;a href=&quot;lambda-expressions#Lambda-Expressions&quot;&gt;Lambda Expressions&lt;/a&gt;) and &lt;code&gt;defun&lt;/code&gt; forms (see &lt;a href=&quot;defining-functions#Defining-Functions&quot;&gt;Defining Functions&lt;/a&gt;). This form does nothing during the actual execution of the function; its presence serves as a flag, telling the Emacs command loop that the function can be called interactively. The argument of the &lt;code&gt;interactive&lt;/code&gt; form specifies how the arguments for an interactive call should be read.</target>
        </trans-unit>
        <trans-unit id="0005a6b722d00b053f8a1c5bab2e99c2e0e932c1" translate="yes" xml:space="preserve">
          <source>The special form &lt;code&gt;quote&lt;/code&gt; returns its single argument, as written, without evaluating it. This provides a way to include constant symbols and lists, which are not self-evaluating objects, in a program. (It is not necessary to quote self-evaluating objects such as numbers, strings, and vectors.)</source>
          <target state="translated">The special form &lt;code&gt;quote&lt;/code&gt; returns its single argument, as written, without evaluating it. This provides a way to include constant symbols and lists, which are not self-evaluating objects, in a program. (It is not necessary to quote self-evaluating objects such as numbers, strings, and vectors.)</target>
        </trans-unit>
        <trans-unit id="244f4b5640ec3dae1a8ddb2bdbc59df8cee21b33" translate="yes" xml:space="preserve">
          <source>The special form &lt;code&gt;track-mouse&lt;/code&gt; enables generation of motion events within its body. Outside of &lt;code&gt;track-mouse&lt;/code&gt; forms, Emacs does not generate events for mere motion of the mouse, and these events do not appear. See &lt;a href=&quot;mouse-tracking#Mouse-Tracking&quot;&gt;Mouse Tracking&lt;/a&gt;.</source>
          <target state="translated">The special form &lt;code&gt;track-mouse&lt;/code&gt; enables generation of motion events within its body. Outside of &lt;code&gt;track-mouse&lt;/code&gt; forms, Emacs does not generate events for mere motion of the mouse, and these events do not appear. See &lt;a href=&quot;mouse-tracking#Mouse-Tracking&quot;&gt;Mouse Tracking&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="28ba34c98e1a089b9214cef4dc2999430a1d7a09" translate="yes" xml:space="preserve">
          <source>The special forms &lt;code&gt;defvar&lt;/code&gt; and &lt;code&gt;defconst&lt;/code&gt; also set the default value (if they set the variable at all), rather than any buffer-local value.</source>
          <target state="translated">The special forms &lt;code&gt;defvar&lt;/code&gt; and &lt;code&gt;defconst&lt;/code&gt; also set the default value (if they set the variable at all), rather than any buffer-local value.</target>
        </trans-unit>
        <trans-unit id="5e119bef1e610c9f0380fd95f6e4af11230682fc" translate="yes" xml:space="preserve">
          <source>The special forms &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;let*&lt;/code&gt; exist to create local bindings:</source>
          <target state="translated">The special forms &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;let*&lt;/code&gt; exist to create local bindings:</target>
        </trans-unit>
        <trans-unit id="67b8199effbdb879bbf1f5d04029672e2a21aec2" translate="yes" xml:space="preserve">
          <source>The special marker &amp;lsquo;</source>
          <target state="translated">The special marker &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="417f26037bec7ec878e05ef7fce97d3107e1525c" translate="yes" xml:space="preserve">
          <source>The special position where editing takes place.</source>
          <target state="translated">The special position where editing takes place.</target>
        </trans-unit>
        <trans-unit id="6604b0bf24124b0211a16d199be68fe327c5aa41" translate="yes" xml:space="preserve">
          <source>The special properties &lt;code&gt;point-entered&lt;/code&gt; and &lt;code&gt;point-left&lt;/code&gt; record hook functions that report motion of point. Each time point moves, Emacs compares these two property values:</source>
          <target state="translated">The special properties &lt;code&gt;point-entered&lt;/code&gt; and &lt;code&gt;point-left&lt;/code&gt; record hook functions that report motion of point. Each time point moves, Emacs compares these two property values:</target>
        </trans-unit>
        <trans-unit id="84235cb39de6ef4fc27674810653ef520a1cb95c" translate="yes" xml:space="preserve">
          <source>The special return value &amp;lsquo;</source>
          <target state="translated">The special return value &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="3cfd33d505b3e301ef67641d59464fa7fe2f87dd" translate="yes" xml:space="preserve">
          <source>The special value &lt;code&gt;child-frame&lt;/code&gt; means to make a minibuffer-only child frame (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;) whose parent becomes the frame created. As if specified as &lt;code&gt;nil&lt;/code&gt;, Emacs will set this parameter to the minibuffer window of the child frame but will not select the child frame after its creation.</source>
          <target state="translated">The special value &lt;code&gt;child-frame&lt;/code&gt; means to make a minibuffer-only child frame (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;) whose parent becomes the frame created. As if specified as &lt;code&gt;nil&lt;/code&gt; , Emacs will set this parameter to the minibuffer window of the child frame but will not select the child frame after its creation.</target>
        </trans-unit>
        <trans-unit id="fcdc41fab620d4b9e47384a2bf4786023f64d828" translate="yes" xml:space="preserve">
          <source>The specification for backquote below illustrates how to match dotted lists and use &lt;code&gt;nil&lt;/code&gt; to terminate recursion. It also illustrates how components of a vector may be matched. (The actual specification defined by Edebug is a little different, and does not support dotted lists because doing so causes very deep recursion that could fail.)</source>
          <target state="translated">The specification for backquote below illustrates how to match dotted lists and use &lt;code&gt;nil&lt;/code&gt; to terminate recursion. It also illustrates how components of a vector may be matched. (The actual specification defined by Edebug is a little different, and does not support dotted lists because doing so causes very deep recursion that could fail.)</target>
        </trans-unit>
        <trans-unit id="27d6230ee26567ac631f3131ae7886bcc7a72c78" translate="yes" xml:space="preserve">
          <source>The specification string also says which fonts to use in the fontset. See below for the details.</source>
          <target state="translated">The specification string also says which fonts to use in the fontset. See below for the details.</target>
        </trans-unit>
        <trans-unit id="7f25f9498af3ebb82fd4fd0ed6c991c529aa68e9" translate="yes" xml:space="preserve">
          <source>The specification version the server is compliant with.</source>
          <target state="translated">The specification version the server is compliant with.</target>
        </trans-unit>
        <trans-unit id="9a30b5e6e028131d98090823da5db94954c0fdbe" translate="yes" xml:space="preserve">
          <source>The specified &lt;var&gt;alist&lt;/var&gt; is an association list of symbols and values. The following symbols have a special meaning:</source>
          <target state="translated">The specified &lt;var&gt;alist&lt;/var&gt; is an association list of symbols and values. The following symbols have a special meaning:</target>
        </trans-unit>
        <trans-unit id="e407764dfcb6e2f1247a11cf715cac7ed4f26bbf" translate="yes" xml:space="preserve">
          <source>The specified &lt;var&gt;frame&lt;/var&gt; becomes the selected frame, and its terminal becomes the selected terminal. This function then calls &lt;code&gt;select-window&lt;/code&gt; as a subroutine, passing the window selected within &lt;var&gt;frame&lt;/var&gt; as its first argument and &lt;var&gt;norecord&lt;/var&gt; as its second argument (hence, if &lt;var&gt;norecord&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, this avoids changing the order of recently selected windows and the buffer list). See &lt;a href=&quot;selecting-windows#Selecting-Windows&quot;&gt;Selecting Windows&lt;/a&gt;.</source>
          <target state="translated">The specified &lt;var&gt;frame&lt;/var&gt; becomes the selected frame, and its terminal becomes the selected terminal. This function then calls &lt;code&gt;select-window&lt;/code&gt; as a subroutine, passing the window selected within &lt;var&gt;frame&lt;/var&gt; as its first argument and &lt;var&gt;norecord&lt;/var&gt; as its second argument (hence, if &lt;var&gt;norecord&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , this avoids changing the order of recently selected windows and the buffer list). See &lt;a href=&quot;selecting-windows#Selecting-Windows&quot;&gt;Selecting Windows&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="87e2533bf5024d0890c44a2a577f82288504b5ca" translate="yes" xml:space="preserve">
          <source>The specified functions are stored in the property list of &lt;var&gt;name&lt;/var&gt; under the property &lt;code&gt;hash-table-test&lt;/code&gt;; the property value&amp;rsquo;s form is &lt;code&gt;(&lt;var&gt;test-fn&lt;/var&gt; &lt;var&gt;hash-fn&lt;/var&gt;)&lt;/code&gt;.</source>
          <target state="translated">The specified functions are stored in the property list of &lt;var&gt;name&lt;/var&gt; under the property &lt;code&gt;hash-table-test&lt;/code&gt; ; the property value&amp;rsquo;s form is &lt;code&gt;(&lt;var&gt;test-fn&lt;/var&gt; &lt;var&gt;hash-fn&lt;/var&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="91455a3d8f4bdb484463e73b427656cc16a89567" translate="yes" xml:space="preserve">
          <source>The speed of the serial port in bits per second, a.k.a. &lt;em&gt;baud rate&lt;/em&gt;. The value can be any number, but most serial ports work only at a few defined values between 1200 and 115200, with 9600 being the most common value. If &lt;var&gt;speed&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, the function ignores all other arguments and does not configure the port. This may be useful for special serial ports such as Bluetooth-to-serial converters, which can only be configured through &amp;lsquo;</source>
          <target state="translated">The speed of the serial port in bits per second, a.k.a. &lt;em&gt;baud rate&lt;/em&gt;. The value can be any number, but most serial ports work only at a few defined values between 1200 and 115200, with 9600 being the most common value. If &lt;var&gt;speed&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; , the function ignores all other arguments and does not configure the port. This may be useful for special serial ports such as Bluetooth-to-serial converters, which can only be configured through &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="52128a6146c27dc1c3960ab9a318c70adfaf8c01" translate="yes" xml:space="preserve">
          <source>The speed of the serial port in bits per second. This function calls &lt;code&gt;serial-process-configure&lt;/code&gt; to handle the speed; see the following documentation of that function for more details.</source>
          <target state="translated">The speed of the serial port in bits per second. This function calls &lt;code&gt;serial-process-configure&lt;/code&gt; to handle the speed; see the following documentation of that function for more details.</target>
        </trans-unit>
        <trans-unit id="fbb6c823ca23a02980eeae5e0a0001e4cc0886fe" translate="yes" xml:space="preserve">
          <source>The square brackets indicate that the &lt;code&gt;&amp;amp;optional&lt;/code&gt; and &lt;code&gt;&amp;amp;rest&lt;/code&gt; clauses, and the variables that follow them, are optional.</source>
          <target state="translated">The square brackets indicate that the &lt;code&gt;&amp;amp;optional&lt;/code&gt; and &lt;code&gt;&amp;amp;rest&lt;/code&gt; clauses, and the variables that follow them, are optional.</target>
        </trans-unit>
        <trans-unit id="81a3604cf4a5ac01501948bd0680c4975564433d" translate="yes" xml:space="preserve">
          <source>The stack frame made for the function call which enters the debugger in this way will be flagged automatically so that the debugger will be called again when the frame is exited. You can use the</source>
          <target state="translated">The stack frame made for the function call which enters the debugger in this way will be flagged automatically so that the debugger will be called again when the frame is exited. You can use the</target>
        </trans-unit>
        <trans-unit id="9a119c8d6df162a4c1cd3d34b9608179ca3eb2aa" translate="yes" xml:space="preserve">
          <source>The standard GNU Emacs Lisp directory tree contains the code for several major modes, in files such as</source>
          <target state="translated">The standard GNU Emacs Lisp directory tree contains the code for several major modes, in files such as</target>
        </trans-unit>
        <trans-unit id="88217deefb3d70a4db90b540339f6b3e6d2c6eee" translate="yes" xml:space="preserve">
          <source>The standard definition of the &lt;code&gt;delete-frame&lt;/code&gt; event is to delete &lt;var&gt;frame&lt;/var&gt;.</source>
          <target state="translated">The standard definition of the &lt;code&gt;delete-frame&lt;/code&gt; event is to delete &lt;var&gt;frame&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="03b918691e790a880d4fba6e47f98dbbdb8910de" translate="yes" xml:space="preserve">
          <source>The standard definition of this function is as follows:</source>
          <target state="translated">The standard definition of this function is as follows:</target>
        </trans-unit>
        <trans-unit id="6292beb7dc766e9cc6bfb7027445782776c9d55b" translate="yes" xml:space="preserve">
          <source>The standard definition of this function, on most operating systems, is as follows:</source>
          <target state="translated">The standard definition of this function, on most operating systems, is as follows:</target>
        </trans-unit>
        <trans-unit id="259daec623d20179dd6c873402018404fce5ae52" translate="yes" xml:space="preserve">
          <source>The standard input for the new process comes from file &lt;var&gt;infile&lt;/var&gt; if &lt;var&gt;infile&lt;/var&gt; is not &lt;code&gt;nil&lt;/code&gt;, and from the null device otherwise. The argument &lt;var&gt;destination&lt;/var&gt; says where to put the process output. Here are the possibilities:</source>
          <target state="translated">The standard input for the new process comes from file &lt;var&gt;infile&lt;/var&gt; if &lt;var&gt;infile&lt;/var&gt; is not &lt;code&gt;nil&lt;/code&gt; , and from the null device otherwise. The argument &lt;var&gt;destination&lt;/var&gt; says where to put the process output. Here are the possibilities:</target>
        </trans-unit>
        <trans-unit id="44c287ca4b32485d2fbd1b0533c6bc30851eaea0" translate="yes" xml:space="preserve">
          <source>The standard letter-codes for reading arguments in various ways.</source>
          <target state="translated">The standard letter-codes for reading arguments in various ways.</target>
        </trans-unit>
        <trans-unit id="8f49ffda7284df4c0cd9b03dae4b8a52126166b8" translate="yes" xml:space="preserve">
          <source>The start of the documentation string is usually indented in the source file, but since these spaces come before the starting double-quote, they are not part of the string. Some people make a practice of indenting any additional lines of the string so that the text lines up in the program source. &lt;em&gt;That is a mistake.&lt;/em&gt; The indentation of the following lines is inside the string; what looks nice in the source code will look ugly when displayed by the help commands.</source>
          <target state="translated">The start of the documentation string is usually indented in the source file, but since these spaces come before the starting double-quote, they are not part of the string. Some people make a practice of indenting any additional lines of the string so that the text lines up in the program source. &lt;em&gt;That is a mistake.&lt;/em&gt; The indentation of the following lines is inside the string; what looks nice in the source code will look ugly when displayed by the help commands.</target>
        </trans-unit>
        <trans-unit id="4c672e151d200c22d18367c0a5d6b7e540bedaea" translate="yes" xml:space="preserve">
          <source>The state code of the process. This is a short string that encodes the scheduling state of the process. Here&amp;rsquo;s a list of the most frequently seen codes:</source>
          <target state="translated">The state code of the process. This is a short string that encodes the scheduling state of the process. Here&amp;rsquo;s a list of the most frequently seen codes:</target>
        </trans-unit>
        <trans-unit id="f2d7146dc12f6d9513c21cfa997b6a60f75f956d" translate="yes" xml:space="preserve">
          <source>The state of keyboard macro definition is saved and restored. While Edebug is active, &lt;code&gt;defining-kbd-macro&lt;/code&gt; is bound to &lt;code&gt;edebug-continue-kbd-macro&lt;/code&gt;.</source>
          <target state="translated">키보드 매크로 정의 상태가 저장되고 복원됩니다. Edebug가 활성화되어있는 동안, definition &lt;code&gt;defining-kbd-macro&lt;/code&gt; 는 &lt;code&gt;edebug-continue-kbd-macro&lt;/code&gt; 에 바인딩됩니다 .</target>
        </trans-unit>
        <trans-unit id="8c91d0e0a6d197098d1a02ec3a2503f351103980" translate="yes" xml:space="preserve">
          <source>The state of keyboard macro execution is saved and restored. While Edebug is active, &lt;code&gt;executing-kbd-macro&lt;/code&gt; is bound to &lt;code&gt;nil&lt;/code&gt; unless &lt;code&gt;edebug-continue-kbd-macro&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">키보드 매크로 실행 상태가 저장되고 복원됩니다. Edebug이 작동하는 동안, &lt;code&gt;executing-kbd-macro&lt;/code&gt; 에 바인딩 &lt;code&gt;nil&lt;/code&gt; 않는 &lt;code&gt;edebug-continue-kbd-macro&lt;/code&gt; 비이다 &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf9ddd67b0e2736562e5e1b48123ad8e5e1a7a7d" translate="yes" xml:space="preserve">
          <source>The state of visibility of the frame. There are three possibilities: &lt;code&gt;nil&lt;/code&gt; for invisible, &lt;code&gt;t&lt;/code&gt; for visible, and &lt;code&gt;icon&lt;/code&gt; for iconified. See &lt;a href=&quot;visibility-of-frames#Visibility-of-Frames&quot;&gt;Visibility of Frames&lt;/a&gt;.</source>
          <target state="translated">프레임의 가시성 상태입니다. 세 가지 가능성이 있습니다 : 보이지 않는 경우 &lt;code&gt;nil&lt;/code&gt; , 보이는 경우 &lt;code&gt;t&lt;/code&gt; , &lt;code&gt;icon&lt;/code&gt; 화 된 경우 아이콘. &lt;a href=&quot;visibility-of-frames#Visibility-of-Frames&quot;&gt;프레임 가시성을&lt;/a&gt; 참고하십시오 .</target>
        </trans-unit>
        <trans-unit id="9e8a0a928375b331768ea9541d2c2a6c4d37acbb" translate="yes" xml:space="preserve">
          <source>The status of the subprocess belonging to the current buffer, obtained with &lt;code&gt;process-status&lt;/code&gt;. See &lt;a href=&quot;process-information#Process-Information&quot;&gt;Process Information&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;process-status&lt;/code&gt; 로 얻은 현재 버퍼에 속하는 하위 프로세스의 상태 입니다. &lt;a href=&quot;process-information#Process-Information&quot;&gt;프로세스 정보를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="999eb55350809e41053d193b69ed4373f0358a4b" translate="yes" xml:space="preserve">
          <source>The string &lt;var&gt;buffer-name&lt;/var&gt; specifies the temporary buffer, which need not already exist. The argument must be a string, not a buffer. The buffer is erased initially (with no questions asked), and it is marked as unmodified after &lt;code&gt;with-output-to-temp-buffer&lt;/code&gt; exits.</source>
          <target state="translated">&lt;var&gt;buffer-name&lt;/var&gt; 문자열 은 임시 버퍼를 지정합니다.이 버퍼는 아직 존재하지 않아도됩니다. 인수는 버퍼가 아닌 문자열이어야합니다. 버퍼는 처음에 지워지고 (질문없이), &lt;code&gt;with-output-to-temp-buffer&lt;/code&gt; 가 종료 된 후 수정되지 않은 것으로 표시 됩니다.</target>
        </trans-unit>
        <trans-unit id="a4d3cb799dfeca2e1bb98a62be5a7ac517d5ffb4" translate="yes" xml:space="preserve">
          <source>The string &lt;var&gt;lighter&lt;/var&gt; says what to display in the mode line when the mode is enabled; if it is &lt;code&gt;nil&lt;/code&gt;, the mode is not displayed in the mode line.</source>
          <target state="translated">문자열 &lt;var&gt;lighter&lt;/var&gt; 는 모드가 활성화되었을 때 모드 행에 표시 할 내용을 나타냅니다. 이 경우 &lt;code&gt;nil&lt;/code&gt; , 모드는 모드 표시 줄에 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a03446e19ee8800b453720d31c0b60da78dc7e80" translate="yes" xml:space="preserve">
          <source>The string containing the byte-code instructions.</source>
          <target state="translated">바이트 코드 명령어가 포함 된 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="1ba6ac8d60c10283435c94518d321e4f95295bb9" translate="yes" xml:space="preserve">
          <source>The string describing the event looks like one of the following:</source>
          <target state="translated">이벤트를 설명하는 문자열은 다음 중 하나와 같습니다.</target>
        </trans-unit>
        <trans-unit id="26291a7cd459e196bf1c635f5e136cb0085033bb" translate="yes" xml:space="preserve">
          <source>The string is inserted literally.</source>
          <target state="translated">문자열은 문자 그대로 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="c1cb47cdeee50f6839e7f1b4e7667115d1fdbb0c" translate="yes" xml:space="preserve">
          <source>The string or comment start position. While inside a comment, this is the position where the comment began; while inside a string, this is the position where the string began. When outside of strings and comments, this element is &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">문자열 또는 주석 시작 위치입니다. 주석 안에있는 동안 주석이 시작된 위치입니다. 문자열 내부에서 이것은 문자열이 시작된 위치입니다. 문자열 및 주석 외부에있는 경우이 요소는 &lt;code&gt;nil&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="80ad211627a8eba28dd5ef9816837befb4643331" translate="yes" xml:space="preserve">
          <source>The string that this function returns is what is recorded in the symbolic link; it may or may not include any leading directories. This function does &lt;em&gt;not&lt;/em&gt; expand the link target to produce a fully-qualified file name, and in particular does not use the leading directories, if any, of the &lt;var&gt;filename&lt;/var&gt; argument if the link target is not an absolute file name. Here&amp;rsquo;s an example:</source>
          <target state="translated">이 함수가 반환하는 문자열은 심볼릭 링크에 기록 된 것입니다. 선행 디렉토리를 포함하거나 포함하지 않을 수 있습니다. 이 함수는 완전한 파일 이름을 생성하기 위해 링크 대상을 확장 하지 &lt;em&gt;않으며&lt;/em&gt; , 특히 링크 대상이 절대 파일 이름이 아닌 경우 &lt;var&gt;filename&lt;/var&gt; 인수 의 선행 디렉토리 (있는 경우)를 사용하지 않습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ed696d53e7ac7bcc7d08d01175d6eb89bf0c571f" translate="yes" xml:space="preserve">
          <source>The string to be completed.</source>
          <target state="translated">완료 할 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="07cf4d672d43fc0025d53260f62ef95ec1c50b45" translate="yes" xml:space="preserve">
          <source>The string which was clicked on, including any properties.</source>
          <target state="translated">속성을 포함하여 클릭 된 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="9e01c44c700489e51d428a65abb3864ced471545" translate="yes" xml:space="preserve">
          <source>The strings are compared by the numeric values of their characters. For instance, &lt;var&gt;str1&lt;/var&gt; is considered less than &lt;var&gt;str2&lt;/var&gt; if its first differing character has a smaller numeric value. If &lt;var&gt;ignore-case&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, characters are converted to upper-case before comparing them. Unibyte strings are converted to multibyte for comparison (see &lt;a href=&quot;text-representations#Text-Representations&quot;&gt;Text Representations&lt;/a&gt;), so that a unibyte string and its conversion to multibyte are always regarded as equal.</source>
          <target state="translated">문자열은 해당 문자의 숫자 값으로 비교됩니다. 예를 들어, 첫 번째 다른 문자의 숫자 값이 더 작 으면 &lt;var&gt;str1&lt;/var&gt; 은 &lt;var&gt;str2&lt;/var&gt; 보다 작은 것으로 간주됩니다 . &lt;var&gt;ignore-case&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 문자를 비교하기 전에 대문자로 변환합니다. 유니 바이트 문자열은 비교를 위해 멀티 바이트로 변환 되므로 ( &lt;a href=&quot;text-representations#Text-Representations&quot;&gt;텍스트 표현&lt;/a&gt; 참조 ) 유니 바이트 문자열과 멀티 바이트로의 변환은 항상 동일한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="44b6399fd6b44ca0035a1f2fc79dfcc1e1445a5f" translate="yes" xml:space="preserve">
          <source>The strings in &lt;var&gt;list-of-strings&lt;/var&gt; that need quoting are those that include &lt;var&gt;separator&lt;/var&gt; as their substring. Quoting a string encloses it in double quotes &lt;code&gt;&quot;&amp;hellip;&quot;&lt;/code&gt;. In the simplest case, if you are consing a command from the individual command-line arguments, every argument that includes embedded blanks will be quoted.</source>
          <target state="translated">인용이 필요한 &lt;var&gt;list-of-strings&lt;/var&gt; 의 문자열 은 &lt;var&gt;separator&lt;/var&gt; 를 하위 문자열로 포함 하는 문자열입니다. 문자열을 인용하면 큰 따옴표 &lt;code&gt;&quot;&amp;hellip;&quot;&lt;/code&gt; 로 묶습니다 . 가장 간단한 경우, 개별 명령 줄 인수에서 명령을 생성하는 경우 포함 된 공백을 포함하는 모든 인수가 인용됩니다.</target>
        </trans-unit>
        <trans-unit id="6eb3410ffb193ecb3bb6cdb461cdb85ed0d15602" translate="yes" xml:space="preserve">
          <source>The strings matching the first nine grouping constructs appearing in the entire regular expression passed to a search or matching function are assigned numbers 1 through 9 in the order that the open parentheses appear in the regular expression. So you can use &amp;lsquo;</source>
          <target state="translated">검색 또는 일치하는 함수에 전달 된 전체 정규식에 나타나는 처음 9 개의 그룹화 구문과 일치하는 문자열에는 여는 괄호가 정규식에 나타나는 순서대로 1에서 9까지의 숫자가 할당됩니다. 따라서 '</target>
        </trans-unit>
        <trans-unit id="d581c2599c93c8f407b1007bbe2ce48ba6714abb" translate="yes" xml:space="preserve">
          <source>The subprocess inherits its environment from Emacs, but you can specify overrides for it with &lt;code&gt;process-environment&lt;/code&gt;. See &lt;a href=&quot;system-environment#System-Environment&quot;&gt;System Environment&lt;/a&gt;. The subprocess gets its current directory from the value of &lt;code&gt;default-directory&lt;/code&gt;.</source>
          <target state="translated">하위 프로세스는 Emacs에서 환경을 상속하지만 &lt;code&gt;process-environment&lt;/code&gt; 를 사용하여 재정의를 지정할 수 있습니다 . &lt;a href=&quot;system-environment#System-Environment&quot;&gt;시스템 환경을&lt;/a&gt; 참조하십시오 . 하위 프로세스는 &lt;code&gt;default-directory&lt;/code&gt; 값에서 현재 디렉토리를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="36e61db0284478d461aa89c79eac1cab50f7a0e0" translate="yes" xml:space="preserve">
          <source>The substitutions performed by &amp;lsquo;</source>
          <target state="translated">'에 의해 수행 된 대체</target>
        </trans-unit>
        <trans-unit id="8b19565b999d7f6150d2a072214b083a7f92bdb0" translate="yes" xml:space="preserve">
          <source>The subtype controls the number of &lt;em&gt;extra slots&lt;/em&gt; in the char-table. This number is specified by the subtype&amp;rsquo;s &lt;code&gt;char-table-extra-slots&lt;/code&gt; symbol property (see &lt;a href=&quot;symbol-properties#Symbol-Properties&quot;&gt;Symbol Properties&lt;/a&gt;), whose value should be an integer between 0 and 10. If the subtype has no such symbol property, the char-table has no extra slots.</source>
          <target state="translated">하위 유형 은 문자 테이블 의 &lt;em&gt;추가 슬롯&lt;/em&gt; 수를 제어 합니다. 이 숫자는 하위 유형의 &lt;code&gt;char-table-extra-slots&lt;/code&gt; 기호 속성 ( &lt;a href=&quot;symbol-properties#Symbol-Properties&quot;&gt;Symbol Properties&lt;/a&gt; 참조 )에 의해 지정되며 값은 0에서 10 사이의 정수 여야합니다. 하위 유형에 이러한 기호 속성이 없으면 char-table에 추가 슬롯이 없습니다. .</target>
        </trans-unit>
        <trans-unit id="3b7c16dd882ba705b433c0230563b93def38601b" translate="yes" xml:space="preserve">
          <source>The subtype provides an easy way to tell what the char-table is for. For instance, display tables are char-tables with &lt;code&gt;display-table&lt;/code&gt; as the subtype, and syntax tables are char-tables with &lt;code&gt;syntax-table&lt;/code&gt; as the subtype. The subtype can be queried using the function &lt;code&gt;char-table-subtype&lt;/code&gt;, described below.</source>
          <target state="translated">하위 유형은 char-table의 용도를 쉽게 알 수있는 방법을 제공합니다. 예를 들어 디스플레이 테이블은 하위 유형으로 &lt;code&gt;display-table&lt;/code&gt; 을 사용하는 char-table이고 구문 테이블은 하위 유형으로 &lt;code&gt;syntax-table&lt;/code&gt; 을 사용하는 char-table입니다 . 하위 유형은 아래에 설명 된 &lt;code&gt;char-table-subtype&lt;/code&gt; 함수를 사용하여 쿼리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="68ac4cd83ea417c1f7f9af452e5cc5b822c521ce" translate="yes" xml:space="preserve">
          <source>The sum of &lt;code&gt;utime&lt;/code&gt; and &lt;code&gt;stime&lt;/code&gt;. The corresponding &lt;var&gt;value&lt;/var&gt; is a Lisp timestamp.</source>
          <target state="translated">&lt;code&gt;utime&lt;/code&gt; 및 &lt;code&gt;stime&lt;/code&gt; 의 합계입니다 . 해당 &lt;var&gt;value&lt;/var&gt; 은 Lisp 타임 스탬프입니다.</target>
        </trans-unit>
        <trans-unit id="d35712cec496be81a5cc381ab6d618570491eb43" translate="yes" xml:space="preserve">
          <source>The super modifier.</source>
          <target state="translated">슈퍼 수정 자입니다.</target>
        </trans-unit>
        <trans-unit id="8e705c61a14589689176e3b34a3649287549f965" translate="yes" xml:space="preserve">
          <source>The sweep phase puts unused cons cells onto a &lt;em&gt;free list&lt;/em&gt; for future allocation; likewise for symbols and markers. It compacts the accessible strings so they occupy fewer 8k blocks; then it frees the other 8k blocks. Unreachable vectors from vector blocks are coalesced to create largest possible free areas; if a free area spans a complete 4k block, that block is freed. Otherwise, the free area is recorded in a free list array, where each entry corresponds to a free list of areas of the same size. Large vectors, buffers, and other large objects are allocated and freed individually.</source>
          <target state="translated">스윕 단계에서는 사용되지 않은 단점 셀 을 향후 할당을 위해 사용 &lt;em&gt;가능한 목록&lt;/em&gt; 에 넣습니다 . 기호 및 마커도 마찬가지입니다. 액세스 가능한 문자열을 압축하여 8k 블록을 더 적게 차지합니다. 그런 다음 다른 8k 블록을 해제합니다. 벡터 블록에서 도달 할 수없는 벡터는 합쳐져 가능한 가장 큰 여유 영역을 만듭니다. 자유 영역이 완전한 4k 블록에 걸쳐 있으면 해당 블록이 해제됩니다. 그렇지 않으면 사용 가능한 영역이 사용 가능한 목록 배열에 기록되며 각 항목은 동일한 크기의 사용 가능한 영역 목록에 해당합니다. 큰 벡터, 버퍼 및 기타 큰 개체는 개별적으로 할당되고 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="80c81c27e3f0ac4ab84d01b9b6f0b0331d39a84e" translate="yes" xml:space="preserve">
          <source>The symbol &lt;code&gt;-&lt;/code&gt;. This indicates that</source>
          <target state="translated">기호 &lt;code&gt;-&lt;/code&gt; . 이것은</target>
        </trans-unit>
        <trans-unit id="d524cc19731a4d7319fdb32e1fd42c2468c1ccdb" translate="yes" xml:space="preserve">
          <source>The symbol &lt;code&gt;undefined&lt;/code&gt; is worth special mention: it means to treat the key as undefined. Strictly speaking, the key is defined, and its binding is the command &lt;code&gt;undefined&lt;/code&gt;; but that command does the same thing that is done automatically for an undefined key: it rings the bell (by calling &lt;code&gt;ding&lt;/code&gt;) but does not signal an error.</source>
          <target state="translated">&lt;code&gt;undefined&lt;/code&gt; 기호 는 특별히 언급 할 가치가 있습니다. 이는 키를 정의되지 않은 것으로 취급한다는 의미입니다. 엄밀히 말하면 키가 정의되고 바인딩은 &lt;code&gt;undefined&lt;/code&gt; 명령입니다 . 그러나이 명령은 정의되지 않은 키에 대해 자동으로 수행되는 것과 동일한 작업을 수행합니다. 종을 울리지 만 ( &lt;code&gt;ding&lt;/code&gt; 을 호출 하여) 오류 신호를 보내지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="262aaa6e5851917f322ee907187b949e88c9ea3d" translate="yes" xml:space="preserve">
          <source>The symbol &lt;var&gt;var&lt;/var&gt; was defined as a variable.</source>
          <target state="translated">&lt;var&gt;var&lt;/var&gt; 기호가 변수 로 정의되었습니다.</target>
        </trans-unit>
        <trans-unit id="5b0a7c1e7a600f3ceec6a0c096061763b149143e" translate="yes" xml:space="preserve">
          <source>The symbol must have an Edebug specification, which is used instead. This indirection is repeated until another kind of specification is found. This allows you to inherit the specification from another macro.</source>
          <target state="translated">기호에는 대신 사용되는 Edebug 사양이 있어야합니다. 다른 종류의 사양이 발견 될 때까지이 간접적 인 방법이 반복됩니다. 이를 통해 다른 매크로에서 사양을 상속 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6db9e28485fd698ef52d7e3eb3a2773fea9702ff" translate="yes" xml:space="preserve">
          <source>The symbol&amp;rsquo;s current value as a variable.</source>
          <target state="translated">변수로서의 심볼의 현재 값.</target>
        </trans-unit>
        <trans-unit id="a0a66fbe0304b2b0365a8eb85d918232ae7d5a27" translate="yes" xml:space="preserve">
          <source>The symbol&amp;rsquo;s function definition. It can also hold a symbol, a keymap, or a keyboard macro.</source>
          <target state="translated">기호의 기능 정의. 또한 심볼, 키맵 또는 키보드 매크로를 보유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="116bb8f437931ac9fdc82686fd01e5886bbdad99" translate="yes" xml:space="preserve">
          <source>The symbol&amp;rsquo;s name.</source>
          <target state="translated">기호의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="4815883f12f3ddda91c2ff86c5cf8ead169410ab" translate="yes" xml:space="preserve">
          <source>The symbol&amp;rsquo;s property list.</source>
          <target state="translated">심볼의 속성 목록입니다.</target>
        </trans-unit>
        <trans-unit id="0da588e9c066744bf4c6e6a6cdf66d1b7de2d7a2" translate="yes" xml:space="preserve">
          <source>The symbol&amp;rsquo;s value is used.</source>
          <target state="translated">기호의 값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4757d314ae2103a000ffd713b4431bdf90047a13" translate="yes" xml:space="preserve">
          <source>The symbols &lt;code&gt;nil&lt;/code&gt; and &lt;code&gt;t&lt;/code&gt; are treated specially, so that the value of &lt;code&gt;nil&lt;/code&gt; is always &lt;code&gt;nil&lt;/code&gt;, and the value of &lt;code&gt;t&lt;/code&gt; is always &lt;code&gt;t&lt;/code&gt;; you cannot set or bind them to any other values. Thus, these two symbols act like self-evaluating forms, even though &lt;code&gt;eval&lt;/code&gt; treats them like any other symbol. A symbol whose name starts with &amp;lsquo;</source>
          <target state="translated">기호 &lt;code&gt;nil&lt;/code&gt; 및 &lt;code&gt;t&lt;/code&gt; 는 특별히 처리되므로 &lt;code&gt;nil&lt;/code&gt; 의 값 은 항상 &lt;code&gt;nil&lt;/code&gt; 이고 &lt;code&gt;t&lt;/code&gt; 의 값 은 항상 &lt;code&gt;t&lt;/code&gt; 입니다 . 다른 값으로 설정하거나 바인딩 할 수 없습니다. 따라서이 두 기호 는 &lt;code&gt;eval&lt;/code&gt; 이 다른 기호처럼 취급 하더라도 자체 평가 형식처럼 작동 합니다. 이름이 '로 시작하는 기호</target>
        </trans-unit>
        <trans-unit id="f0a7fe54d498086e0224f1254ce0302e2d45b30e" translate="yes" xml:space="preserve">
          <source>The symbols &lt;code&gt;user-login-name&lt;/code&gt;, &lt;code&gt;user-real-login-name&lt;/code&gt; and &lt;code&gt;user-full-name&lt;/code&gt; are variables as well as functions. The functions return the same values that the variables hold. These variables allow you to fake out Emacs by telling the functions what to return. The variables are also useful for constructing frame titles (see &lt;a href=&quot;frame-titles#Frame-Titles&quot;&gt;Frame Titles&lt;/a&gt;).</source>
          <target state="translated">기호의 &lt;code&gt;user-login-name&lt;/code&gt; , &lt;code&gt;user-real-login-name&lt;/code&gt; 과 &lt;code&gt;user-full-name&lt;/code&gt; 변수뿐만 아니라 함수입니다. 함수는 변수가 보유하는 것과 동일한 값을 반환합니다. 이 변수를 사용하면 반환 할 내용을 함수에 알려 Emacs를 가짜로 만들 수 있습니다. 변수는 프레임 제목을 구성하는데도 유용합니다 ( &lt;a href=&quot;frame-titles#Frame-Titles&quot;&gt;프레임 제목&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="0804f73f2468d63be3d44abb01edffb59c0ad975" translate="yes" xml:space="preserve">
          <source>The synchronous subprocess functions return an indication of how the process terminated.</source>
          <target state="translated">동기식 하위 프로세스 함수는 프로세스가 종료 된 방법에 대한 표시를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="42db7ccb5bf39d0ef36aec66fdcf39beff2dbdf3" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;(rose . violet . buttercup)&lt;/code&gt; is invalid because there is nothing that it could mean. If anything, it would say to put &lt;code&gt;buttercup&lt;/code&gt; in the &lt;small&gt;CDR&lt;/small&gt; of a cons cell whose &lt;small&gt;CDR&lt;/small&gt; is already used for &lt;code&gt;violet&lt;/code&gt;.</source>
          <target state="translated">구문 &lt;code&gt;(rose . violet . buttercup)&lt;/code&gt; 은 의미가 없기 때문에 유효하지 않습니다. 어떤 경우에는 넣어 말할 것 &lt;code&gt;buttercup&lt;/code&gt; 에서 &lt;small&gt;CDR&lt;/small&gt; 단점 셀의 &lt;small&gt;CDR&lt;/small&gt; 이미 사용된다 &lt;code&gt;violet&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cab7667e7d8ac62d20cdad9ef7c79cda38e5bc22" translate="yes" xml:space="preserve">
          <source>The syntax for integers in bases other than 10 consists of &amp;lsquo;</source>
          <target state="translated">밑 수가 10이 아닌 정수에 대한 구문은 '</target>
        </trans-unit>
        <trans-unit id="88b43371f5f28d88c8b06cc0133c5c8be8a7772e" translate="yes" xml:space="preserve">
          <source>The syntax is changed only for &lt;var&gt;table&lt;/var&gt;, which defaults to the current buffer&amp;rsquo;s syntax table, and not in any other syntax table.</source>
          <target state="translated">구문은 &lt;var&gt;table&lt;/var&gt; 에 대해서만 변경되며 기본값은 현재 버퍼의 구문 테이블이며 다른 구문 테이블에서는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="239ff1bb3df2ca92e1729acd450422ea90926247" translate="yes" xml:space="preserve">
          <source>The syntax of &lt;code&gt;EMACSLOADPATH&lt;/code&gt; is the same as used for &lt;code&gt;PATH&lt;/code&gt;; directories are separated by &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;EMACSLOADPATH&lt;/code&gt; 의 구문은 &lt;code&gt;PATH&lt;/code&gt; 에 사용 된 것과 동일합니다 . 디렉토리는 '로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="1999b037e6c53b71c64122a6e2bea19301ea2ee4" translate="yes" xml:space="preserve">
          <source>The syntax of format specifications accepted by &lt;code&gt;format-spec&lt;/code&gt; is similar, but not identical, to that accepted by &lt;code&gt;format&lt;/code&gt;. In both cases, a format specification is a sequence of characters beginning with &amp;lsquo;</source>
          <target state="translated">수락 포맷 규격의 문법 &lt;code&gt;format-spec&lt;/code&gt; 수락 된 것과 유사하지만 동일하지 않은 &lt;code&gt;format&lt;/code&gt; . 두 경우 모두 형식 사양은 '로 시작하는 일련의 문자입니다.</target>
        </trans-unit>
        <trans-unit id="a7719f40601bdc59c72de428210fe56812c73911" translate="yes" xml:space="preserve">
          <source>The syntax table controls the interpretation of characters, so these functions can be used for Lisp expressions when in Lisp mode and for C expressions when in C mode. See &lt;a href=&quot;list-motion#List-Motion&quot;&gt;List Motion&lt;/a&gt;, for convenient higher-level functions for moving over balanced expressions.</source>
          <target state="translated">구문 테이블은 문자 해석을 제어하므로 Lisp 모드에서는 Lisp 표현식에, C 모드에서는 C 표현식에 이러한 함수를 사용할 수 있습니다. 균형 잡힌 표현 위로 이동하기위한 편리한 상위 수준 함수는 &lt;a href=&quot;list-motion#List-Motion&quot;&gt;List Motion을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1d3dd35ac27520d192421173419189f92bfde5f7" translate="yes" xml:space="preserve">
          <source>The syntax table controls word and list parsing.</source>
          <target state="translated">구문 테이블은 단어 및 목록 구문 분석을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="1b828fe7a14532d3214216229166278069ec53be" translate="yes" xml:space="preserve">
          <source>The tab character (character code 9) displays as whitespace stretching up to the next tab stop column. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Text-Display.html#Text-Display&quot;&gt;Text Display&lt;/a&gt; in</source>
          <target state="translated">탭 문자 (문자 코드 9)는 다음 탭 정지 열까지 확장되는 공백으로 표시됩니다. &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Text-Display.html#Text-Display&quot;&gt;텍스트 디스플레이&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4cdb77457b03ae8e4189510caa2d2cd8affcf775" translate="yes" xml:space="preserve">
          <source>The tail of the list, &lt;var&gt;item-property-list&lt;/var&gt;, has the form of a property list which contains other information.</source>
          <target state="translated">목록의 뒷부분 인 &lt;var&gt;item-property-list&lt;/var&gt; 는 다른 정보를 포함하는 속성 목록의 형태를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="7527554605fcb9db76071476569c6f6b0cf4a1ce" translate="yes" xml:space="preserve">
          <source>The term &lt;em&gt;function&lt;/em&gt; refers to all Emacs functions, whether written in Lisp or C. See &lt;a href=&quot;function-type#Function-Type&quot;&gt;Function Type&lt;/a&gt;, for information about the functions written in Lisp.</source>
          <target state="translated">&lt;em&gt;함수&lt;/em&gt; 라는 용어 는 Lisp 또는 C로 작성된 모든 Emacs &lt;em&gt;함수를&lt;/em&gt; 나타냅니다. Lisp로 작성된 &lt;a href=&quot;function-type#Function-Type&quot;&gt;함수&lt;/a&gt; 에 대한 정보는 Function Type을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bd8132ad5a485b9ab38224ae63509adce1e85797" translate="yes" xml:space="preserve">
          <source>The terminal and keyboard coding systems used on the terminal. See &lt;a href=&quot;terminal-i_002fo-encoding#Terminal-I_002fO-Encoding&quot;&gt;Terminal I/O Encoding&lt;/a&gt;.</source>
          <target state="translated">터미널에서 사용되는 터미널 및 키보드 코딩 시스템. &lt;a href=&quot;terminal-i_002fo-encoding#Terminal-I_002fO-Encoding&quot;&gt;터미널 I / O 인코딩을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6ad03be7d14630f60e2cb6b2a4f58289b95b8877" translate="yes" xml:space="preserve">
          <source>The terminal output functions send output to a text terminal, or keep track of output sent to the terminal. The variable &lt;code&gt;baud-rate&lt;/code&gt; tells you what Emacs thinks is the output speed of the terminal.</source>
          <target state="translated">터미널 출력 함수는 출력을 텍스트 터미널로 보내거나 터미널로 보낸 출력을 추적합니다. 가변 &lt;code&gt;baud-rate&lt;/code&gt; 는 Emacs가 터미널의 출력 속도라고 생각하는 것을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="3a63395bf693f4ea5dbf2a2a8a31fd4771954d08" translate="yes" xml:space="preserve">
          <source>The terms &lt;em&gt;line height&lt;/em&gt; and &lt;em&gt;canonical character height&lt;/em&gt; are sometimes used instead of &amp;ldquo;default character height&amp;rdquo;. Similarly, the terms &lt;em&gt;column width&lt;/em&gt; and &lt;em&gt;canonical character width&lt;/em&gt; are used instead of &amp;ldquo;default character width&amp;rdquo;.</source>
          <target state="translated">&lt;em&gt;줄 높이&lt;/em&gt; 및 &lt;em&gt;표준 문자 높이&lt;/em&gt; 라는 용어 가 &quot;기본 문자 높이&quot;대신 사용되기도합니다. 마찬가지로 &quot;기본 문자 너비&quot;대신 &lt;em&gt;열 너비&lt;/em&gt; 및 &lt;em&gt;표준 문자 너비&lt;/em&gt; 라는 용어 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4e683c537d7a88f401925ed633251e10fa4e0d2a" translate="yes" xml:space="preserve">
          <source>The terms used herein, such as IV (Initialization Vector), require some familiarity with cryptography and will not be defined in detail. Please consult &lt;a href=&quot;https://www.gnutls.org/&quot;&gt;https://www.gnutls.org/&lt;/a&gt; for specific documentation which may help you understand the terminology and structure of the GnuTLS library.</source>
          <target state="translated">IV (Initialization Vector)와 같이 여기에서 사용되는 용어는 암호화에 어느 정도 익숙해야하며 자세히 정의하지 않습니다. GnuTLS 라이브러리의 용어와 구조를 이해하는 데 도움이 될 수있는 특정 문서 는 &lt;a href=&quot;https://www.gnutls.org/&quot;&gt;https://www.gnutls.org/&lt;/a&gt; 를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="6650dc3f7c947a7cc0f8b1e2e8887236711ab190" translate="yes" xml:space="preserve">
          <source>The test for an existing file, when &lt;var&gt;mustbenew&lt;/var&gt; is &lt;code&gt;excl&lt;/code&gt;, uses a special system feature. At least for files on a local disk, there is no chance that some other program could create a file of the same name before Emacs does, without Emacs&amp;rsquo;s noticing.</source>
          <target state="translated">&lt;var&gt;mustbenew&lt;/var&gt; 가 &lt;code&gt;excl&lt;/code&gt; 인 경우 기존 파일에 대한 테스트 는 특수 시스템 기능을 사용합니다. 적어도 로컬 디스크에있는 파일의 경우 Emacs가 알지 못하는 사이에 다른 프로그램이 Emacs보다 먼저 동일한 이름의 파일을 만들 수있는 가능성은 없습니다.</target>
        </trans-unit>
        <trans-unit id="f4bec060d8606173e4510214d476948b1b689bd6" translate="yes" xml:space="preserve">
          <source>The text between point and the mark is known as &lt;em&gt;the region&lt;/em&gt;. Various functions operate on text delimited by point and the mark, but only those functions specifically related to the region itself are described here.</source>
          <target state="translated">포인트와 마크 사이의 텍스트를 &lt;em&gt;영역이라고&lt;/em&gt; 합니다. 다양한 기능은 포인트와 마크로 구분 된 텍스트에서 작동하지만, 여기서는 영역 자체와 특별히 관련된 기능 만 설명합니다.</target>
        </trans-unit>
        <trans-unit id="427235673649693cef34eec5a1c49c535c367214" translate="yes" xml:space="preserve">
          <source>The text in the minibuffer always starts with the &lt;em&gt;prompt string&lt;/em&gt;, the text that was specified by the program that is using the minibuffer to tell the user what sort of input to type. This text is marked read-only so you won&amp;rsquo;t accidentally delete or change it. It is also marked as a field (see &lt;a href=&quot;fields#Fields&quot;&gt;Fields&lt;/a&gt;), so that certain motion functions, including &lt;code&gt;beginning-of-line&lt;/code&gt;, &lt;code&gt;forward-word&lt;/code&gt;, &lt;code&gt;forward-sentence&lt;/code&gt;, and &lt;code&gt;forward-paragraph&lt;/code&gt;, stop at the boundary between the prompt and the actual text.</source>
          <target state="translated">미니 버퍼의 텍스트는 항상 사용자에게 입력 할 입력 유형을 알려주기 위해 미니 버퍼를 사용하는 프로그램에서 지정한 텍스트 인 &lt;em&gt;prompt string으로&lt;/em&gt; 시작 합니다. 이 텍스트는 읽기 전용으로 표시되므로 실수로 삭제하거나 변경하지 않습니다. 또한 필드 ( &lt;a href=&quot;fields#Fields&quot;&gt;필드&lt;/a&gt; 참조 )로 표시되므로 &lt;code&gt;beginning-of-line&lt;/code&gt; , &lt;code&gt;forward-word&lt;/code&gt; , &lt;code&gt;forward-sentence&lt;/code&gt; 및 &lt;code&gt;forward-paragraph&lt;/code&gt; 포함한 특정 동작 기능 이 프롬프트와 실제 텍스트 사이의 경계에서 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="e254c01685b37e41ab942a41fbf59829e6d11ec6" translate="yes" xml:space="preserve">
          <source>The text of the indirect buffer is always identical to the text of its base buffer; changes made by editing either one are visible immediately in the other. This includes the text properties as well as the characters themselves.</source>
          <target state="translated">간접 버퍼의 텍스트는 항상 기본 버퍼의 텍스트와 동일합니다. 둘 중 하나를 편집하여 변경 한 내용은 다른 하나에 즉시 표시됩니다. 여기에는 문자 자체뿐만 아니라 텍스트 속성도 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="af246ddc000534af5859563e36f5153516e93316" translate="yes" xml:space="preserve">
          <source>The text properties &lt;code&gt;front-sticky&lt;/code&gt; and &lt;code&gt;rear-nonsticky&lt;/code&gt;, when used, take precedence over the default &lt;var&gt;nonstickiness&lt;/var&gt; specified in &lt;code&gt;text-property-default-nonsticky&lt;/code&gt;.</source>
          <target state="translated">사용되는 경우 텍스트 속성 &lt;code&gt;front-sticky&lt;/code&gt; 및 &lt;code&gt;rear-nonsticky&lt;/code&gt; 는 &lt;code&gt;text-property-default-nonsticky&lt;/code&gt; 에 지정된 기본 &lt;var&gt;nonstickiness&lt;/var&gt; 보다 우선 합니다 .</target>
        </trans-unit>
        <trans-unit id="61de37a77d48c5a03418142f4c57cbd435c8202a" translate="yes" xml:space="preserve">
          <source>The text properties in &lt;code&gt;minibuffer-prompt-properties&lt;/code&gt; are applied to the prompt. By default, this property list defines a face to use for the prompt. This face, if present, is applied to the end of the face list and merged before display.</source>
          <target state="translated">&lt;code&gt;minibuffer-prompt-properties&lt;/code&gt; 의 텍스트 속성 이 프롬프트 에 적용됩니다. 기본적으로이 속성 목록은 프롬프트에 사용할면을 정의합니다. 이 얼굴이있는 경우 얼굴 목록 끝에 적용되고 표시되기 전에 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="53d1c0b3638f705814caf89c18a7ce3da885e071" translate="yes" xml:space="preserve">
          <source>The text size of any frame can be set and retrieved with the help of the &lt;code&gt;height&lt;/code&gt; and &lt;code&gt;width&lt;/code&gt; frame parameters (see &lt;a href=&quot;size-parameters#Size-Parameters&quot;&gt;Size Parameters&lt;/a&gt;). The text size of the initial frame can be also set with the help of an X-style geometry specification. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Emacs-Invocation.html#Emacs-Invocation&quot;&gt;Command Line Arguments for Emacs Invocation&lt;/a&gt; in</source>
          <target state="translated">모든 프레임의 텍스트 크기는 &lt;code&gt;height&lt;/code&gt; 및 &lt;code&gt;width&lt;/code&gt; 프레임 매개 변수를 사용하여 설정하고 검색 할 수 있습니다 ( &lt;a href=&quot;size-parameters#Size-Parameters&quot;&gt;크기 매개 변수&lt;/a&gt; 참조 ). 초기 프레임의 텍스트 크기는 X 스타일 지오메트리 사양을 사용하여 설정할 수도 있습니다. &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Emacs-Invocation.html#Emacs-Invocation&quot;&gt;Emacs 호출&lt;/a&gt; 에 대한 명령 줄 인수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c67ee1668cafc5069fd19fd9ac4ce5d1dfafd95a" translate="yes" xml:space="preserve">
          <source>The text&amp;rsquo;s start position in the buffer.</source>
          <target state="translated">버퍼에서 텍스트의 시작 위치입니다.</target>
        </trans-unit>
        <trans-unit id="459ecfaa7406a56efb8cf84eab33df64259674fe" translate="yes" xml:space="preserve">
          <source>The third argument &lt;var&gt;keep-time&lt;/var&gt; non-&lt;code&gt;nil&lt;/code&gt; means to preserve the modification time of the copied files. A prefix arg makes &lt;var&gt;keep-time&lt;/var&gt; non-&lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">세 번째 인수 &lt;var&gt;keep-time&lt;/var&gt; non - &lt;code&gt;nil&lt;/code&gt; 은 복사 된 파일의 수정 시간을 보존하는 것을 의미합니다. 접두 인수의 차종은 &lt;var&gt;keep-time&lt;/var&gt; 비 &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da9ba46202c97f906aff04419daf0a2467b172a5" translate="yes" xml:space="preserve">
          <source>The third element is the window selected at the time the parameter was created. If this function deletes &lt;var&gt;window&lt;/var&gt;, it subsequently tries to reselect the window named by that element.</source>
          <target state="translated">세 번째 요소는 매개 변수가 생성 될 때 선택한 창입니다. 이 함수가 &lt;var&gt;window&lt;/var&gt; 를 삭제하면 이후에 해당 요소로 명명 된 창을 다시 선택하려고합니다.</target>
        </trans-unit>
        <trans-unit id="290b74a62fe3a2fe85d724d61465dc891525fd6f" translate="yes" xml:space="preserve">
          <source>The third element, &lt;var&gt;case-fold&lt;/var&gt;, specifies the value of &lt;code&gt;font-lock-keywords-case-fold-search&lt;/code&gt;. If it is non-&lt;code&gt;nil&lt;/code&gt;, Font Lock mode ignores case during search-based fontification.</source>
          <target state="translated">세 번째 요소 인 &lt;var&gt;case-fold&lt;/var&gt; 는 &lt;code&gt;font-lock-keywords-case-fold-search&lt;/code&gt; 의 값을 지정합니다 . &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 글꼴 잠금 모드는 검색 기반 글꼴 화 중에 대소 문자를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="a0049f036ce91322d4b97e568763827ed24c4fa6" translate="yes" xml:space="preserve">
          <source>The third element, &lt;var&gt;real-binding&lt;/var&gt;, can be the command to execute (in which case you get a normal menu item). It can also be a keymap, which will result in a submenu. Finally, it can be &lt;code&gt;nil&lt;/code&gt;, in which case you will get a non-selectable menu item. This is mostly useful when creating separator lines and the like.</source>
          <target state="translated">세 번째 요소 인 &lt;var&gt;real-binding&lt;/var&gt; 은 실행할 명령이 될 수 있습니다 (이 경우 일반 메뉴 항목이 표시됨). 하위 메뉴를 생성하는 키맵 일 수도 있습니다. 마지막으로 &lt;code&gt;nil&lt;/code&gt; 일 수 있으며 ,이 경우 선택 불가능한 메뉴 항목이 표시됩니다. 이것은 구분선 등을 만들 때 주로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="5ded74e35ae11b189414eb3a2feeeaf0372642b2" translate="yes" xml:space="preserve">
          <source>The third of these hooks is run when a &lt;em&gt;window selection change&lt;/em&gt; has selected another window since the last redisplay.</source>
          <target state="translated">이러한 후크 중 세 번째는 &lt;em&gt;창 선택 변경&lt;/em&gt; 이 마지막 다시 표시 이후 다른 창을 &lt;em&gt;선택&lt;/em&gt; 했을 때 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="c89651a099ca91af6c8a8b83f402ae4da806d1ff" translate="yes" xml:space="preserve">
          <source>The third part of the pattern matches the whitespace that follows the end of a sentence: the end of a line (optionally with a space), or a tab, or two spaces. The double backslashes mark the parentheses and vertical bars as regular expression syntax; the parentheses delimit a group and the vertical bars separate alternatives. The dollar sign is used to match the end of a line.</source>
          <target state="translated">패턴의 세 번째 부분은 문장의 끝 뒤에 오는 공백과 일치합니다. 행 끝 (선택적으로 공백 포함), 탭 또는 공백 두 개. 이중 백 슬래시는 정규식 구문으로 괄호와 세로 막대를 표시합니다. 괄호는 그룹을 구분하고 세로 막대는 대안을 구분합니다. 달러 기호는 줄 끝을 일치시키는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="607c3d642b7b987d71b42da79930af648e956246" translate="yes" xml:space="preserve">
          <source>The three Lisp modes (Lisp mode, Emacs Lisp mode, and Lisp Interaction mode) have more features than Text mode and the code is correspondingly more complicated. Here are excerpts from</source>
          <target state="translated">세 가지 Lisp 모드 (Lisp 모드, Emacs Lisp 모드 및 Lisp 상호 작용 모드)는 텍스트 모드보다 더 많은 기능을 가지고 있으며 이에 따라 코드가 더 복잡합니다. 다음은 발췌 내용입니다.</target>
        </trans-unit>
        <trans-unit id="45ee5df28937c07f3548f70fd6cc8c94bf25c3ce" translate="yes" xml:space="preserve">
          <source>The three modes for Lisp share much of their code. For instance, each calls the following function to set various variables:</source>
          <target state="translated">Lisp의 세 가지 모드는 대부분의 코드를 공유합니다. 예를 들어, 각각은 다음 함수를 호출하여 다양한 변수를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="54870091d56fd5e724ee385ddc157eb207f13d76" translate="yes" xml:space="preserve">
          <source>The time at which the event occurred, as an integer number of milliseconds since a system-dependent initial time.</source>
          <target state="translated">이벤트가 발생한 시간 (시스템 종속 초기 시간 이후 정수 밀리 초)입니다.</target>
        </trans-unit>
        <trans-unit id="1ebfb539c64783c4344442794aee02ad7006a6f2" translate="yes" xml:space="preserve">
          <source>The time at which the event occurred, in milliseconds. On some toolkits, including GTK+, Emacs cannot extract this data, so the value is always &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">이벤트가 발생한 시간 (밀리 초)입니다. GTK +를 포함한 일부 툴킷에서 Emacs는이 데이터를 추출 할 수 없으므로 값은 항상 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="98e57126dedf2d6400ffdfdef20aa57a4ca36ef3" translate="yes" xml:space="preserve">
          <source>The time elapsed since the process started, as a Lisp timestamp.</source>
          <target state="translated">프로세스가 시작된 이후 경과 한 시간 (Lisp 타임 스탬프)입니다.</target>
        </trans-unit>
        <trans-unit id="00b925b3b99613c5ebaf63a3e99e731129a59a23" translate="yes" xml:space="preserve">
          <source>The time of last access as a Lisp timestamp (&lt;code&gt;file-attribute-access-time&lt;/code&gt;). The timestamp is in the style of &lt;code&gt;current-time&lt;/code&gt; (see &lt;a href=&quot;time-of-day#Time-of-Day&quot;&gt;Time of Day&lt;/a&gt;) and is truncated to that of the filesystem&amp;rsquo;s timestamp resolution; for example, on some FAT-based filesystems, only the date of last access is recorded, so this time will always hold the midnight of the day of the last access.</source>
          <target state="translated">Lisp 타임 스탬프로 마지막 액세스 시간 ( &lt;code&gt;file-attribute-access-time&lt;/code&gt; ). 타임 스탬프는 &lt;code&gt;current-time&lt;/code&gt; 스타일 ( &lt;a href=&quot;time-of-day#Time-of-Day&quot;&gt;Time of Day&lt;/a&gt; 참조 )이며 파일 시스템의 타임 스탬프 해상도로 잘립니다. 예를 들어 일부 FAT 기반 파일 시스템에서는 마지막 액세스 날짜 만 기록되므로이 시간은 항상 마지막 액세스 날짜의 자정을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="96f255ff11207f96a6ff4be345f0df83a02d827c" translate="yes" xml:space="preserve">
          <source>The time of last modification as a Lisp timestamp (&lt;code&gt;file-attribute-modification-time&lt;/code&gt;). This is the last time when the file&amp;rsquo;s contents were modified.</source>
          <target state="translated">Lisp 타임 스탬프로 마지막 수정 시간 ( &lt;code&gt;file-attribute-modification-time&lt;/code&gt; ). 파일의 내용이 마지막으로 수정 된 시간입니다.</target>
        </trans-unit>
        <trans-unit id="7647d2bb474bf5d47880005e9fa4aa2091b44379" translate="yes" xml:space="preserve">
          <source>The time of last status change as a Lisp timestamp (&lt;code&gt;file-attribute-status-change-time&lt;/code&gt;). This is the time of the last change to the file&amp;rsquo;s access mode bits, its owner and group, and other information recorded in the filesystem for the file, beyond the file&amp;rsquo;s contents.</source>
          <target state="translated">Lisp 타임 스탬프로 마지막 상태 변경 시간 ( &lt;code&gt;file-attribute-status-change-time&lt;/code&gt; ). 이것은 파일의 액세스 모드 비트, 소유자 및 그룹, 파일의 내용을 넘어 파일 시스템에 기록 된 기타 정보에 대한 마지막 변경 시간입니다.</target>
        </trans-unit>
        <trans-unit id="24c20ed315222312a2625d91bebf7c20d8b009b0" translate="yes" xml:space="preserve">
          <source>The time to use &lt;code&gt;make-variable-buffer-local&lt;/code&gt; is when it is crucial that no two buffers ever share the same binding. For example, when a variable is used for internal purposes in a Lisp program which depends on having separate values in separate buffers, then using &lt;code&gt;make-variable-buffer-local&lt;/code&gt; can be the best solution.</source>
          <target state="translated">&lt;code&gt;make-variable-buffer-local&lt;/code&gt; 을 사용하는 시간 은 두 버퍼가 동일한 바인딩을 공유하지 않는 것이 중요 할 때입니다. 예를 들어, 별도의 버퍼에 별도의 값을 갖는 것에 의존하는 Lisp 프로그램에서 내부 목적으로 &lt;code&gt;make-variable-buffer-local&lt;/code&gt; 를 사용하는 경우 make-variable-buffer-local 을 사용하는 것이 최상의 솔루션이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c627015afbabd38bf35740a5ee9f2c3cb23dc48d" translate="yes" xml:space="preserve">
          <source>The time when the buffer was last auto-saved.</source>
          <target state="translated">버퍼가 마지막으로 자동 저장된 시간입니다.</target>
        </trans-unit>
        <trans-unit id="1e0d0c1f4808016965104728546b5791c182f028" translate="yes" xml:space="preserve">
          <source>The time when the process was started, as a Lisp timestamp.</source>
          <target state="translated">프로세스가 시작된 시간 (Lisp 타임 스탬프)입니다.</target>
        </trans-unit>
        <trans-unit id="802393edc2b9a42653a80bc4d4ec3e5e5f24f1f4" translate="yes" xml:space="preserve">
          <source>The timeout time in milliseconds since the display of the notification at which the notification should automatically close. If -1, the notification&amp;rsquo;s expiration time is dependent on the notification server&amp;rsquo;s settings, and may vary for the type of notification. If 0, the notification never expires. Default value is -1.</source>
          <target state="translated">알림이 자동으로 닫히는 알림 표시 이후 시간 초과 시간 (밀리 초)입니다. -1 인 경우 알림의 만료 시간은 알림 서버의 설정에 따라 다르며 알림 유형에 따라 다를 수 있습니다. 0이면 알림이 만료되지 않습니다. 기본값은 -1입니다.</target>
        </trans-unit>
        <trans-unit id="5f4688992c1cae810c4b2847d1acc4a25d6a81f0" translate="yes" xml:space="preserve">
          <source>The title (only on a window system) or the name of the selected frame. See &lt;a href=&quot;basic-parameters#Basic-Parameters&quot;&gt;Basic Parameters&lt;/a&gt;.</source>
          <target state="translated">제목 (윈도우 시스템에만 해당) 또는 선택한 프레임의 이름입니다. &lt;a href=&quot;basic-parameters#Basic-Parameters&quot;&gt;기본 매개 변수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="00a751eb6540114fecfd6321e7957f9e5fe58259" translate="yes" xml:space="preserve">
          <source>The title of the notification. If &lt;var&gt;title&lt;/var&gt; is a string, it is displayed in a larger font immediately above the body text. The title text can be up to 63 characters long; longer text will be truncated.</source>
          <target state="translated">알림의 제목입니다. 경우 &lt;var&gt;title&lt;/var&gt; 문자열입니다, 그것은 바로 본문 위의 더 큰 글꼴로 표시됩니다. 제목 텍스트는 최대 63 자까지 가능합니다. 긴 텍스트는 잘립니다.</target>
        </trans-unit>
        <trans-unit id="fb5b566b508b98eab0c7c5b9ce2a802059ff0fbe" translate="yes" xml:space="preserve">
          <source>The toggle command takes one optional (prefix) argument. If called interactively with no argument it toggles the mode on or off. A positive prefix argument enables the mode, any other prefix argument disables it. From Lisp, an argument of &lt;code&gt;toggle&lt;/code&gt; toggles the mode, whereas an omitted or &lt;code&gt;nil&lt;/code&gt; argument enables the mode. This makes it easy to enable the minor mode in a major mode hook, for example. If &lt;var&gt;doc&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, the macro supplies a default documentation string explaining the above.</source>
          <target state="translated">toggle 명령은 하나의 선택적 (접두사) 인수를 사용합니다. 인수없이 대화식으로 호출하면 모드를 켜거나 끕니다. 양의 접두사 인수는 모드를 활성화하고 다른 접두사 인수는 모드를 비활성화합니다. Lisp에서 &lt;code&gt;toggle&lt;/code&gt; 인수 는 모드를 전환하는 반면 생략되거나 &lt;code&gt;nil&lt;/code&gt; 인수는 모드를 활성화합니다. 예를 들어 주 모드 후크에서 부 모드를 쉽게 활성화 할 수 있습니다. 경우 &lt;var&gt;doc&lt;/var&gt; 있다 &lt;code&gt;nil&lt;/code&gt; , 매크로 공급 장치는 기본 문서 문자열은 위의 설명.</target>
        </trans-unit>
        <trans-unit id="ee396be1bc2edeec5a010e520887af01b2c0ec1a" translate="yes" xml:space="preserve">
          <source>The tool bar contents are controlled by a menu keymap attached to a fake function key called</source>
          <target state="translated">도구 모음 내용은 가짜 기능 키에 연결된 메뉴 키맵으로 제어됩니다.</target>
        </trans-unit>
        <trans-unit id="c8e2bf3f449141de6022307bd19ac291ae6a42dd" translate="yes" xml:space="preserve">
          <source>The top edge of the window, measured in lines, relative to the topmost line (line 0) of the window&amp;rsquo;s native frame.</source>
          <target state="translated">창 기본 프레임의 맨 위 줄 (줄 0)을 기준으로 줄 단위로 측정 한 창의 위쪽 가장자리입니다.</target>
        </trans-unit>
        <trans-unit id="80ecb166938baeaaabb20112d9fe96a939c773d4" translate="yes" xml:space="preserve">
          <source>The top level variable, mode-line-format.</source>
          <target state="translated">최상위 수준 변수, mode-line-format.</target>
        </trans-unit>
        <trans-unit id="10fcd8fbdfa1f56f99b62be921ede3801375f31b" translate="yes" xml:space="preserve">
          <source>The top-level forms in the file defining the mode should be written so that they may be evaluated more than once without adverse consequences. For instance, use &lt;code&gt;defvar&lt;/code&gt; or &lt;code&gt;defcustom&lt;/code&gt; to set mode-related variables, so that they are not reinitialized if they already have a value (see &lt;a href=&quot;defining-variables#Defining-Variables&quot;&gt;Defining Variables&lt;/a&gt;).</source>
          <target state="translated">모드를 정의하는 파일의 최상위 양식은 불리한 결과없이 두 번 이상 평가 될 수 있도록 작성되어야합니다. 예를 들어, &lt;code&gt;defvar&lt;/code&gt; 또는 &lt;code&gt;defcustom&lt;/code&gt; 을 사용 하여 모드 관련 변수를 설정하면 이미 값이있는 경우 다시 초기화되지 않습니다 ( &lt;a href=&quot;defining-variables#Defining-Variables&quot;&gt;변수 정의&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="e0bf6b79b51361600ab0d2d09d4929d9f08d380a" translate="yes" xml:space="preserve">
          <source>The total height of each display line consists of the height of the contents of the line, plus optional additional vertical line spacing above or below the display line.</source>
          <target state="translated">각 디스플레이 라인의 총 높이는 라인 내용의 높이와 디스플레이 라인 위 또는 아래의 추가 수직 라인 간격으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="31d0e82b6a88e74d0b24a216385d5fc85a5cec98" translate="yes" xml:space="preserve">
          <source>The total length, in pixels, of the scroll bar. On some toolkits, including GTK+, Emacs cannot extract this data, so the value is always &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">스크롤 막대의 총 길이 (픽셀)입니다. GTK +를 포함한 일부 툴킷에서 Emacs는이 데이터를 추출 할 수 없으므로 값은 항상 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b25cf92e537fbc457f73f8b8ccd34da35b4b1e0f" translate="yes" xml:space="preserve">
          <source>The total number of cons cells that have been allocated so far in this Emacs session.</source>
          <target state="translated">이 Emacs 세션에서 지금까지 할당 된 총 단점 셀 수입니다.</target>
        </trans-unit>
        <trans-unit id="a994cddf9b826ab8c3b89d449d09ae2a9b73e706" translate="yes" xml:space="preserve">
          <source>The total number of floats that have been allocated so far in this Emacs session.</source>
          <target state="translated">이 Emacs 세션에서 지금까지 할당 된 총 float 수입니다.</target>
        </trans-unit>
        <trans-unit id="fdcf07b9e5a059b00bbaae5593cd683d00025222" translate="yes" xml:space="preserve">
          <source>The total number of intervals that have been allocated so far in this Emacs session.</source>
          <target state="translated">이 Emacs 세션에서 지금까지 할당 된 총 간격 수입니다.</target>
        </trans-unit>
        <trans-unit id="614654e18f37f5b5f422dea3bbdcbb3a165f297e" translate="yes" xml:space="preserve">
          <source>The total number of string characters that have been allocated so far in this session.</source>
          <target state="translated">이 세션에서 지금까지 할당 된 총 문자열 문자 수입니다.</target>
        </trans-unit>
        <trans-unit id="abb717f47f8933d7923fb2b52cfb28bd464f36e9" translate="yes" xml:space="preserve">
          <source>The total number of strings that have been allocated so far in this Emacs session.</source>
          <target state="translated">이 Emacs 세션에서 지금까지 할당 된 총 문자열 수입니다.</target>
        </trans-unit>
        <trans-unit id="e9b8f06e1c94173e7b8d8a404718b1b724454813" translate="yes" xml:space="preserve">
          <source>The total number of symbols that have been allocated so far in this Emacs session.</source>
          <target state="translated">이 Emacs 세션에서 지금까지 할당 된 총 심볼 수입니다.</target>
        </trans-unit>
        <trans-unit id="27a10a08d892e6a91c5cf07d46fe77aa2af1a3fa" translate="yes" xml:space="preserve">
          <source>The total number of vector cells that have been allocated so far in this Emacs session. This includes vector-like objects such as markers and overlays, plus certain objects not visible to users.</source>
          <target state="translated">이 Emacs 세션에서 지금까지 할당 된 총 벡터 셀 수입니다. 여기에는 마커 및 오버레이와 같은 벡터와 유사한 개체와 사용자에게 표시되지 않는 특정 개체가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="441a3e680eaafec796a9e2a7060e2a280535485a" translate="yes" xml:space="preserve">
          <source>The total size of all string data in bytes.</source>
          <target state="translated">모든 문자열 데이터의 총 크기 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="c7d14b13c564dd0ff16404189a2b255627fffdf3" translate="yes" xml:space="preserve">
          <source>The total width and height of the window measured in pixels.</source>
          <target state="translated">픽셀 단위로 측정 한 창의 총 너비와 높이입니다.</target>
        </trans-unit>
        <trans-unit id="1ccf2de5b65512cde61e59a9ed444c1197414f54" translate="yes" xml:space="preserve">
          <source>The total width and height of the window, measured in columns and lines respectively. The values include scroll bars and fringes, dividers and/or the separator line on the right of the window (if any).</source>
          <target state="translated">각각 열과 선으로 측정 한 창의 총 너비와 높이입니다. 값에는 스크롤 막대와 테두리, 구분선 및 / 또는 창 오른쪽의 구분선 (있는 경우)이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="bc966a52b3595d2fcaff1f0ffe9ad07780edb9e3" translate="yes" xml:space="preserve">
          <source>The translation table &lt;var&gt;table&lt;/var&gt; is a string or a char-table; &lt;code&gt;(aref &lt;var&gt;table&lt;/var&gt; &lt;var&gt;ochar&lt;/var&gt;)&lt;/code&gt; gives the translated character corresponding to &lt;var&gt;ochar&lt;/var&gt;. If &lt;var&gt;table&lt;/var&gt; is a string, any characters with codes larger than the length of &lt;var&gt;table&lt;/var&gt; are not altered by the translation.</source>
          <target state="translated">변환 테이블 &lt;var&gt;table&lt;/var&gt; 은 문자열 또는 문자 테이블입니다. &lt;code&gt;(aref &lt;var&gt;table&lt;/var&gt; &lt;var&gt;ochar&lt;/var&gt;)&lt;/code&gt; 는 &lt;var&gt;ochar&lt;/var&gt; 에 해당하는 번역 된 문자를 제공합니다 . 경우 &lt;var&gt;table&lt;/var&gt; 문자열입니다,의 길이보다 큰 코드로 모든 문자 &lt;var&gt;table&lt;/var&gt; 번역에 의해 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="397c955cc662600cfb57e3c9c25331b73b22fe24" translate="yes" xml:space="preserve">
          <source>The two constructs described next are mostly identical to &lt;code&gt;with-temp-buffer-window&lt;/code&gt; but differ from it as specified:</source>
          <target state="translated">다음에 설명하는 두 가지 구조는 &lt;code&gt;with-temp-buffer-window&lt;/code&gt; 와 거의 동일 하지만 지정된 것과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="04a05211cdc885470090771446510a238e8b75f7" translate="yes" xml:space="preserve">
          <source>The type &lt;var&gt;type&lt;/var&gt; was defined.</source>
          <target state="translated">유형 &lt;var&gt;type&lt;/var&gt; 이 정의되었습니다.</target>
        </trans-unit>
        <trans-unit id="9989a67db7c219bdacd778e97cc75a29828fcbdc" translate="yes" xml:space="preserve">
          <source>The type of connection. Options are:</source>
          <target state="translated">연결 유형입니다. 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="10723b34477adf1a54c090dcb75c1b850f7f8519" translate="yes" xml:space="preserve">
          <source>The type of flow control to use for this connection, which is either &lt;code&gt;nil&lt;/code&gt; (don&amp;rsquo;t use flow control), the symbol &lt;code&gt;hw&lt;/code&gt; (use RTS/CTS hardware flow control), or the symbol &lt;code&gt;sw&lt;/code&gt; (use XON/XOFF software flow control). If &lt;var&gt;flowcontrol&lt;/var&gt; is not given, it defaults to no flow control.</source>
          <target state="translated">이 연결에 사용할 흐름 제어 유형은 &lt;code&gt;nil&lt;/code&gt; (흐름 제어 사용 안 함), 기호 &lt;code&gt;hw&lt;/code&gt; (RTS / CTS 하드웨어 흐름 제어 사용) 또는 &lt;code&gt;sw&lt;/code&gt; 기호 (XON / XOFF 소프트웨어 흐름 제어 사용)입니다. . 경우 &lt;var&gt;flowcontrol&lt;/var&gt; 는 흐름 제어가 기본값으로 제공되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="824546068f92ce5ea60e0deff376010de3e1fec4" translate="yes" xml:space="preserve">
          <source>The type of icon to use for this frame. If the value is a string, that specifies a file containing a bitmap to use; &lt;code&gt;nil&lt;/code&gt; specifies no icon (in which case the window manager decides what to show); any other non-&lt;code&gt;nil&lt;/code&gt; value specifies the default Emacs icon.</source>
          <target state="translated">이 프레임에 사용할 아이콘 유형입니다. 값이 문자열이면 사용할 비트 맵이 포함 된 파일을 지정합니다. &lt;code&gt;nil&lt;/code&gt; 은 아이콘을 지정하지 않습니다 (이 경우 창 관리자가 표시 할 내용을 결정합니다). &lt;code&gt;nil&lt;/code&gt; 이 아닌 다른 값은 기본 Emacs 아이콘을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="77d40006d2d51026df28ce9827773f880edd24d6" translate="yes" xml:space="preserve">
          <source>The type of notification this is, a string. See the &lt;a href=&quot;https://developer.gnome.org/notification-spec/#categories&quot;&gt;Desktop Notifications Specification&lt;/a&gt; for a list of standard categories.</source>
          <target state="translated">알림 유형은 문자열입니다. 표준 범주 목록은 &lt;a href=&quot;https://developer.gnome.org/notification-spec/#categories&quot;&gt;데스크탑 알림 사양&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="55bdf0d544649480b63a1172ccccf6ea3ae2d63d" translate="yes" xml:space="preserve">
          <source>The type slot should be a symbol or a type descriptor. If it&amp;rsquo;s a type descriptor, the symbol naming its type will be returned; &lt;a href=&quot;type-descriptors#Type-Descriptors&quot;&gt;Type Descriptors&lt;/a&gt;. Any other kind of object is returned as-is.</source>
          <target state="translated">유형 슬롯은 기호 또는 유형 설명자 여야합니다. 유형 설명자인 경우 해당 유형을 명명하는 기호가 반환됩니다. &lt;a href=&quot;type-descriptors#Type-Descriptors&quot;&gt;유형 설명자&lt;/a&gt; . 다른 종류의 개체는있는 그대로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e025c62fbc48998b73600c44b54165169adc5d17" translate="yes" xml:space="preserve">
          <source>The type specializer, &lt;code&gt;(&lt;var&gt;arg&lt;/var&gt; &lt;var&gt;type&lt;/var&gt;)&lt;/code&gt;, can specify one of the &lt;em&gt;system types&lt;/em&gt; in the following list. When a parent type is specified, an argument whose type is any of its more specific child types, as well as grand-children, grand-grand-children, etc. will also be compatible.</source>
          <target state="translated">유형 전문 &lt;code&gt;(&lt;var&gt;arg&lt;/var&gt; &lt;var&gt;type&lt;/var&gt;)&lt;/code&gt; ( arg &lt;var&gt;type&lt;/var&gt; ) 는 다음 목록 에있는 &lt;em&gt;시스템 유형&lt;/em&gt; 중 하나를 지정할 수 있습니다 . 부모 유형이 지정되면 해당 유형이 더 구체적인 자식 유형 인 인수는 물론 손자, 손자 등도 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="918de08f5d10241b12396b2606b071d4bc53db4a" translate="yes" xml:space="preserve">
          <source>The type, height, and width of the cursor that was last displayed on this window.</source>
          <target state="translated">이 창에 마지막으로 표시된 커서의 유형, 높이 및 너비입니다.</target>
        </trans-unit>
        <trans-unit id="813fe6c3982289dedb90eb513614087f1cf82291" translate="yes" xml:space="preserve">
          <source>The types in the previous section are used for general programming purposes, and most of them are common to most Lisp dialects. Emacs Lisp provides several additional data types for purposes connected with editing.</source>
          <target state="translated">이전 섹션의 유형은 일반 프로그래밍 목적으로 사용되며 대부분은 대부분의 Lisp 방언에 공통입니다. Emacs Lisp는 편집과 관련된 목적을 위해 몇 가지 추가 데이터 유형을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e4129664d859d9f2877eb29408df21ab5cb6661f" translate="yes" xml:space="preserve">
          <source>The types of this window&amp;rsquo;s vertical and horizontal scroll bars.</source>
          <target state="translated">이 창의 수직 및 수평 스크롤 막대 유형입니다.</target>
        </trans-unit>
        <trans-unit id="4ebd8369f764b15f8731d7001594b37607f527c5" translate="yes" xml:space="preserve">
          <source>The underlying ACL implementation is platform-specific; on GNU/Linux and BSD, Emacs uses the POSIX ACL interface, while on MS-Windows Emacs emulates the POSIX ACL interface with native file security APIs.</source>
          <target state="translated">기본 ACL 구현은 플랫폼에 따라 다릅니다. GNU / Linux 및 BSD에서 Emacs는 POSIX ACL 인터페이스를 사용하는 반면 MS-Windows에서 Emacs는 기본 파일 보안 API로 POSIX ACL 인터페이스를 에뮬레이트합니다.</target>
        </trans-unit>
        <trans-unit id="32e0037f866c0451ac34d2bce4ba7d40d8a695e5" translate="yes" xml:space="preserve">
          <source>The unibyte and multibyte text representations use different character codes. The valid character codes for unibyte representation range from 0 to &lt;code&gt;#xFF&lt;/code&gt; (255)&amp;mdash;the values that can fit in one byte. The valid character codes for multibyte representation range from 0 to &lt;code&gt;#x3FFFFF&lt;/code&gt;. In this code space, values 0 through &lt;code&gt;#x7F&lt;/code&gt; (127) are for</source>
          <target state="translated">유니 바이트 및 멀티 바이트 텍스트 표현은 다른 문자 코드를 사용합니다. 유니 바이트 표현의 유효한 문자 코드 범위는 0에서 &lt;code&gt;#xFF&lt;/code&gt; (255) (1 바이트에 들어갈 수있는 값)까지입니다. 멀티 바이트 표현의 유효한 문자 코드는 0에서 &lt;code&gt;#x3FFFFF&lt;/code&gt; 까지 입니다. 이 코드 공간에서 0부터 &lt;code&gt;#x7F&lt;/code&gt; (127) 까지의 값 은</target>
        </trans-unit>
        <trans-unit id="9cca45442a6da20dbdae7b6615f2dc10baadc419" translate="yes" xml:space="preserve">
          <source>The unit of heap space measurement, always equal to 1024 bytes.</source>
          <target state="translated">힙 공간 측정 단위이며 항상 1024 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="63b023b466e3bce22e9d5ba36aecbcf660e048b0" translate="yes" xml:space="preserve">
          <source>The upcase table maps each character into the corresponding upper case character.</source>
          <target state="translated">upcase 테이블은 각 문자를 해당 대문자로 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="a0c17633f0138ef3e9286c2d1a5c0258bfdb10e0" translate="yes" xml:space="preserve">
          <source>The urgency level. It can be &lt;code&gt;low&lt;/code&gt;, &lt;code&gt;normal&lt;/code&gt;, or &lt;code&gt;critical&lt;/code&gt;.</source>
          <target state="translated">긴급 수준. &lt;code&gt;low&lt;/code&gt; , &lt;code&gt;normal&lt;/code&gt; 또는 &lt;code&gt;critical&lt;/code&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6ce53fb4d208bc4c27337bdd863033417c703f3c" translate="yes" xml:space="preserve">
          <source>The use of a special variable as a formal argument in a function is discouraged. Doing so gives rise to unspecified behavior when lexical binding mode is enabled (it may use lexical binding sometimes, and dynamic binding other times).</source>
          <target state="translated">함수에서 형식 인수로 특수 변수를 사용하는 것은 권장되지 않습니다. 이렇게하면 어휘 바인딩 모드가 활성화 될 때 지정되지 않은 동작이 발생합니다 (어휘 바인딩을 가끔 사용하고 다른 시간에는 동적 바인딩을 사용할 수 있음).</target>
        </trans-unit>
        <trans-unit id="143e85103669e6f3a73e45520cffeb3311a2e64f" translate="yes" xml:space="preserve">
          <source>The use of numbered backups ultimately leads to a large number of backup versions, which must then be deleted. Emacs can do this automatically or it can ask the user whether to delete them.</source>
          <target state="translated">번호가 매겨진 백업을 사용하면 궁극적으로 많은 백업 버전이 생성되므로 삭제해야합니다. Emacs는이 작업을 자동으로 수행하거나 사용자에게 삭제할 것인지 묻습니다.</target>
        </trans-unit>
        <trans-unit id="a8707423f159b173b39f4962f0556071463cb869" translate="yes" xml:space="preserve">
          <source>The use of the &lt;var&gt;debugger-args&lt;/var&gt; is that &lt;code&gt;debug&lt;/code&gt; displays the rest of its arguments at the top of the</source>
          <target state="translated">&lt;var&gt;debugger-args&lt;/var&gt; 의 사용은 &lt;code&gt;debug&lt;/code&gt; 가 맨 위에 나머지 인수를 표시 한다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="511c6540e54c5649d62befa61b017dde79ffef3a" translate="yes" xml:space="preserve">
          <source>The user can add any key matching the specified key type, but you can give some keys a preferential treatment by specifying them with the &lt;code&gt;:options&lt;/code&gt; (see &lt;a href=&quot;variable-definitions#Variable-Definitions&quot;&gt;Variable Definitions&lt;/a&gt;). The specified keys will always be shown in the customize buffer (together with a suitable value), with a checkbox to include or exclude or disable the key/value pair from the alist. The user will not be able to edit the keys specified by the &lt;code&gt;:options&lt;/code&gt; keyword argument.</source>
          <target state="translated">사용자는 지정된 키 유형과 일치하는 모든 키를 추가 할 수 있지만 일부 키를 &lt;code&gt;:options&lt;/code&gt; 로 지정하여 우선적으로 처리 할 수 있습니다 ( &lt;a href=&quot;variable-definitions#Variable-Definitions&quot;&gt;변수 정의&lt;/a&gt; 참조 ). 지정된 키는 목록에서 키 / 값 쌍을 포함 또는 제외 또는 비활성화하는 확인란과 함께 사용자 정의 버퍼에 항상 표시됩니다 (적절한 값과 함께). 사용자는 &lt;code&gt;:options&lt;/code&gt; 키워드 인수로 지정된 키를 편집 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="fdfe999c9bdc85b3810a58353ece516fc9370b63" translate="yes" xml:space="preserve">
          <source>The user can type</source>
          <target state="translated">사용자가 입력 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd064556685bc85b9d72d2d84d2adeec46f6b9f6" translate="yes" xml:space="preserve">
          <source>The user option &lt;code&gt;display-buffer-alist&lt;/code&gt;.</source>
          <target state="translated">사용자 옵션 &lt;code&gt;display-buffer-alist&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="51ded933043196b29f2223baab0f1acb3d9183ff" translate="yes" xml:space="preserve">
          <source>The user option &lt;code&gt;display-buffer-base-action&lt;/code&gt;.</source>
          <target state="translated">사용자 옵션 &lt;code&gt;display-buffer-base-action&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2793d8b41a5fb22673ccbb20fb899bf671a14181" translate="yes" xml:space="preserve">
          <source>The user-level commands for using Imenu are described in the Emacs Manual (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Imenu.html#Imenu&quot;&gt;Imenu&lt;/a&gt; in</source>
          <target state="translated">IMENU를 사용하는 사용자 - 레벨 명령어는 수동 이맥스에 기재되어있다 (참조 &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Imenu.html#Imenu&quot;&gt;IMENU를&lt;/a&gt; 년</target>
        </trans-unit>
        <trans-unit id="30be3069546127e24c5678d1a47150d319e9b5c5" translate="yes" xml:space="preserve">
          <source>The usual and simplest way is to set the variable &lt;code&gt;imenu-generic-expression&lt;/code&gt;:</source>
          <target state="translated">일반적이고 가장 간단한 방법은 &lt;code&gt;imenu-generic-expression&lt;/code&gt; 변수를 설정하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="90c75b3bffda92eeaca86bfbbe99a7430c08eb6e" translate="yes" xml:space="preserve">
          <source>The usual conventions for displaying characters.</source>
          <target state="translated">문자를 표시하는 일반적인 규칙입니다.</target>
        </trans-unit>
        <trans-unit id="2bd44e25afda0f432266a4e8544ff3b09136787e" translate="yes" xml:space="preserve">
          <source>The usual effect of signaling an error is to terminate the command that is running and return immediately to the Emacs editor command loop. You can arrange to trap errors occurring in a part of your program by establishing an error handler, with the special form &lt;code&gt;condition-case&lt;/code&gt;. A simple example looks like this:</source>
          <target state="translated">오류 신호의 일반적인 효과는 실행중인 명령을 종료하고 즉시 Emacs 편집기 명령 루프로 돌아가는 것입니다. 특수한 형태의 &lt;code&gt;condition-case&lt;/code&gt; 를 사용하여 오류 처리기를 설정하여 프로그램의 일부에서 발생하는 오류를 트랩하도록 정렬 할 수 있습니다 . 간단한 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bda6ef848c823990e6e54452a3858487c06e4809" translate="yes" xml:space="preserve">
          <source>The usual interface functions for visiting.</source>
          <target state="translated">방문을위한 일반적인 인터페이스 기능.</target>
        </trans-unit>
        <trans-unit id="af1901f1654ae4b4ade44f3e4daa9e941c61b525" translate="yes" xml:space="preserve">
          <source>The usual menu keymap item properties, &lt;code&gt;:visible&lt;/code&gt;, &lt;code&gt;:enable&lt;/code&gt;, &lt;code&gt;:button&lt;/code&gt;, and &lt;code&gt;:filter&lt;/code&gt;, are useful in tool bar bindings and have their normal meanings. The &lt;var&gt;real-binding&lt;/var&gt; in the item must be a command, not a keymap; in other words, it does not work to define a tool bar icon as a prefix key.</source>
          <target state="translated">일반적인 메뉴 키맵 항목 속성, &lt;code&gt;:visible&lt;/code&gt; , &lt;code&gt;:enable&lt;/code&gt; , &lt;code&gt;:button&lt;/code&gt; 및 &lt;code&gt;:filter&lt;/code&gt; 는 도구 모음 바인딩에 유용하며 일반적인 의미를 갖습니다. 항목 의 &lt;var&gt;real-binding&lt;/var&gt; 은 키맵이 아닌 명령이어야합니다. 즉, 도구 모음 아이콘을 접두사 키로 정의하는 것은 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ac47370c7e29666366c5084b597a830112308e12" translate="yes" xml:space="preserve">
          <source>The usual purpose of tracking mouse motion is to indicate on the screen the consequences of pushing or releasing a button at the current position.</source>
          <target state="translated">마우스 동작을 추적하는 일반적인 목적은 현재 위치에서 버튼을 누르거나 놓은 결과를 화면에 표시하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4945884c017dad70b10d5d997fdc2f6a3086adf5" translate="yes" xml:space="preserve">
          <source>The usual read syntax for alphanumeric characters is a question mark followed by the character; thus, &amp;lsquo;</source>
          <target state="translated">영숫자 문자에 대한 일반적인 읽기 구문은 물음표 다음에 문자가 오는 것입니다. 따라서 '</target>
        </trans-unit>
        <trans-unit id="5b4827bb568bf80753c3882d75fd2ab2a82f4c4c" translate="yes" xml:space="preserve">
          <source>The usual reason to specify a documentation string for a type is to provide more information about the meanings of alternatives inside a &lt;code&gt;choice&lt;/code&gt; type or the parts of some other composite type.</source>
          <target state="translated">유형에 대한 문서 문자열을 지정하는 일반적인 이유는 &lt;code&gt;choice&lt;/code&gt; 유형 내부의 대안의 의미 또는 다른 복합 유형의 일부 에 대한 자세한 정보를 제공하기위한 것 입니다.</target>
        </trans-unit>
        <trans-unit id="93b29e680886ef3e32073a78d95db6b48a506c98" translate="yes" xml:space="preserve">
          <source>The usual regexp special characters are not special inside a character alternative. A completely different set of characters is special: &amp;lsquo;</source>
          <target state="translated">일반적인 정규 표현식 특수 문자는 대체 문자 내에서 특별하지 않습니다. 완전히 다른 문자 세트는 특별합니다. '</target>
        </trans-unit>
        <trans-unit id="d9d1876d8ad2be0bc6c8de7cd54c94dfc02c0053" translate="yes" xml:space="preserve">
          <source>The usual regular expression functions do backtracking when necessary to handle the &amp;lsquo;</source>
          <target state="translated">일반적인 정규식 함수는 '를 처리하는 데 필요할 때 역 추적을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="c019ba7cb944335d1fef89c7810b797ce8729a29" translate="yes" xml:space="preserve">
          <source>The usual role of a terminal-specific library is to enable special keys to send sequences that Emacs can recognize. It may also need to set or add to &lt;code&gt;input-decode-map&lt;/code&gt; if the Termcap or Terminfo entry does not specify all the terminal&amp;rsquo;s function keys. See &lt;a href=&quot;terminal-input#Terminal-Input&quot;&gt;Terminal Input&lt;/a&gt;.</source>
          <target state="translated">터미널 특정 라이브러리의 일반적인 역할은 Emacs가 인식 할 수있는 시퀀스를 보낼 수있는 특수 키를 활성화하는 것입니다. 또한 Termcap 또는 Terminfo 항목이 터미널의 모든 기능 키를 지정하지 않는 경우 &lt;code&gt;input-decode-map&lt;/code&gt; 을 설정하거나 추가해야 할 수 있습니다 . &lt;a href=&quot;terminal-input#Terminal-Input&quot;&gt;터미널 입력을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d3392a5efb2e33159132ee8ca55dd0bd95184127" translate="yes" xml:space="preserve">
          <source>The usual use of this feature is to fill comments in programming language modes. If the function needs to fill a paragraph in the usual way, it can do so as follows:</source>
          <target state="translated">이 기능의 일반적인 사용은 프로그래밍 언어 모드에서 주석을 채우는 것입니다. 함수가 일반적인 방법으로 단락을 채워야하는 경우 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba8560d5e995fe38c893b74271adb5dbf50667f4" translate="yes" xml:space="preserve">
          <source>The usual way to change the value of a variable is with the special form &lt;code&gt;setq&lt;/code&gt;. When you need to compute the choice of variable at run time, use the function &lt;code&gt;set&lt;/code&gt;.</source>
          <target state="translated">변수 값을 변경하는 일반적인 방법은 특수 형식 &lt;code&gt;setq&lt;/code&gt; 입니다. 런타임에 선택한 변수를 계산해야하는 경우 &lt;code&gt;set&lt;/code&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ad41ba273b5018a4ad09f4b5ea08e124af9c068c" translate="yes" xml:space="preserve">
          <source>The usual way to define a face is through the &lt;code&gt;defface&lt;/code&gt; macro. This macro associates a face name (a symbol) with a default &lt;em&gt;face spec&lt;/em&gt;. A face spec is a construct which specifies what attributes a face should have on any given terminal; for example, a face spec might specify one foreground color on high-color terminals, and a different foreground color on low-color terminals.</source>
          <target state="translated">얼굴을 정의하는 일반적인 방법은 &lt;code&gt;defface&lt;/code&gt; 매크로를 사용하는 것입니다. 이 매크로는 얼굴 이름 (기호)을 기본 &lt;em&gt;얼굴 사양과 연결&lt;/em&gt; 합니다. 면 사양은 주어진 터미널에서면이 가져야하는 속성을 지정하는 구성입니다. 예를 들어, 얼굴 사양은 하이 컬러 터미널에서 하나의 전경색을 지정하고 낮은 컬러 터미널에서 다른 전경색을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab4be22e46f2537548bcdd8b14595a57667df9f7" translate="yes" xml:space="preserve">
          <source>The usual way to define the SMIE grammar of a language is by defining a new global variable that holds the precedence table by giving a set of BNF rules. For example, the grammar definition for a small Pascal-like language could look like:</source>
          <target state="translated">언어의 SMIE 문법을 정의하는 일반적인 방법은 일련의 BNF 규칙을 제공하여 우선 순위 테이블을 보유하는 새로운 전역 변수를 정의하는 것입니다. 예를 들어, 파스칼과 유사한 작은 언어에 대한 문법 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ea823ab039487ce6c627239fb33b038961688356" translate="yes" xml:space="preserve">
          <source>The usual way to make a buffer-local binding is with &lt;code&gt;make-local-variable&lt;/code&gt;, which is what major mode commands typically use. This affects just the current buffer; all other buffers (including those yet to be created) will continue to share the default value unless they are explicitly given their own buffer-local bindings.</source>
          <target state="translated">버퍼 로컬 바인딩을 만드는 일반적인 방법 은 메이저 모드 명령이 일반적으로 사용하는 &lt;code&gt;make-local-variable&lt;/code&gt; 을 사용하는 것입니다. 이것은 현재 버퍼에만 영향을줍니다. 다른 모든 버퍼 (아직 생성되지 않은 버퍼 포함)는 명시 적으로 자체 버퍼 로컬 바인딩이 제공되지 않는 한 기본값을 계속 공유합니다.</target>
        </trans-unit>
        <trans-unit id="0fe16ddfa309e34d499b3360c2ffbfd59734391f" translate="yes" xml:space="preserve">
          <source>The usual way to make a menu keymap produce a menu is to make it the definition of a prefix key. (A Lisp program can explicitly pop up a menu and receive the user&amp;rsquo;s choice&amp;mdash;see &lt;a href=&quot;pop_002dup-menus#Pop_002dUp-Menus&quot;&gt;Pop-Up Menus&lt;/a&gt;.)</source>
          <target state="translated">메뉴 키맵이 메뉴를 생성하도록 만드는 일반적인 방법은 접두사 키의 정의로 만드는 것입니다. (A 리스프 프로그램이 명시 적으로 메뉴를 팝업 및 사용자의 수신 할 수있는 선택을-참조 &lt;a href=&quot;pop_002dup-menus#Pop_002dUp-Menus&quot;&gt;팝업 메뉴를&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="413eaf722746475cb7fc0070f78d8c7cbef5d401" translate="yes" xml:space="preserve">
          <source>The usual way to read a file into a buffer as a sequence of bytes, so you can decode the contents explicitly, is with &lt;code&gt;insert-file-contents-literally&lt;/code&gt; (see &lt;a href=&quot;reading-from-files#Reading-from-Files&quot;&gt;Reading from Files&lt;/a&gt;); alternatively, specify a non-&lt;code&gt;nil&lt;/code&gt;&lt;var&gt;rawfile&lt;/var&gt; argument when visiting a file with &lt;code&gt;find-file-noselect&lt;/code&gt;. These methods result in a unibyte buffer.</source>
          <target state="translated">파일을 바이트 시퀀스로 버퍼에 읽는 일반적인 방법은 내용을 명시 적으로 디코딩 할 수 있도록 &lt;code&gt;insert-file-contents-literally&lt;/code&gt; 를 사용하는 것입니다 ( &lt;a href=&quot;reading-from-files#Reading-from-Files&quot;&gt;파일에서 읽기&lt;/a&gt; 참조 ). 또는 &lt;code&gt;find-file-noselect&lt;/code&gt; 를 사용 하여 파일을 방문 할 때 &lt;code&gt;nil&lt;/code&gt; 이 아닌 &lt;var&gt;rawfile&lt;/var&gt; 인수를 지정하십시오 . 이러한 메서드는 유니 바이트 버퍼를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="5a11c911f5b0f69a171b92b7cffb6822859b5ec3" translate="yes" xml:space="preserve">
          <source>The usual way to reference a variable is to write the symbol which names it. See &lt;a href=&quot;symbol-forms#Symbol-Forms&quot;&gt;Symbol Forms&lt;/a&gt;.</source>
          <target state="translated">변수를 참조하는 일반적인 방법은 이름을 지정하는 기호를 작성하는 것입니다. &lt;a href=&quot;symbol-forms#Symbol-Forms&quot;&gt;기호 양식을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5526547f8b2c540a3aed5c614e44c4e6712243b8" translate="yes" xml:space="preserve">
          <source>The usual way to use the byte sequence that results from explicitly encoding text is to copy it to a file or process&amp;mdash;for example, to write it with &lt;code&gt;write-region&lt;/code&gt; (see &lt;a href=&quot;writing-to-files#Writing-to-Files&quot;&gt;Writing to Files&lt;/a&gt;), and suppress encoding by binding &lt;code&gt;coding-system-for-write&lt;/code&gt; to &lt;code&gt;no-conversion&lt;/code&gt;.</source>
          <target state="translated">명시 적으로 텍스트를 인코딩 한 결과 인 바이트 시퀀스를 사용하는 일반적인 방법은이를 파일 또는 프로세스에 복사하는 것입니다. 예를 들어 &lt;code&gt;write-region&lt;/code&gt; ( &lt;a href=&quot;writing-to-files#Writing-to-Files&quot;&gt;파일에 쓰기&lt;/a&gt; 참조 ) 을 사용하여 작성하고 &lt;code&gt;coding-system-for-write&lt;/code&gt; 을 바인딩하여 인코딩을 억제합니다. for-write to &lt;code&gt;no-conversion&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="36be957267ce38e09b5982a5646ced40aa3279e5" translate="yes" xml:space="preserve">
          <source>The valid values of &lt;code&gt;syntax-table&lt;/code&gt; text property are:</source>
          <target state="translated">&lt;code&gt;syntax-table&lt;/code&gt; 텍스트 속성 의 유효한 값 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="356e00fd867a17cbdcb1217100288420420a4192" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;auto-raise&lt;/code&gt; should be used when your window manager has the focus automatically follow the position of the mouse pointer and a frame that gains focus is raised automatically.</source>
          <target state="translated">&lt;code&gt;auto-raise&lt;/code&gt; 값 은 창 관리자가 마우스 포인터의 위치를 ​​자동으로 따라가는 포커스가 있고 포커스를받는 프레임이 자동으로 올라갈 때 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="893aaa83d61bb05c575aed10c479a15392b8a63f" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;t&lt;/code&gt; should be used when your window manager has the focus automatically follow the position of the mouse pointer but a frame that gains focus is not raised automatically and may even remain occluded by other window-system windows.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 값 은 창 관리자가 마우스 포인터의 위치를 ​​자동으로 따라가는 포커스를 가지지 만 포커스를 얻는 프레임이 자동으로 올라가지 않고 다른 창 시스템 창에 의해 가려진 상태로 남아있을 때 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="aed9f61a23e975eb7392678e85f51f4d74310e87" translate="yes" xml:space="preserve">
          <source>The value &lt;var&gt;color&lt;/var&gt; specifies the color to draw with. The default is the foreground color of the face for simple boxes, and the background color of the face for 3D boxes.</source>
          <target state="translated">값 &lt;var&gt;color&lt;/var&gt; 은 그릴 색상을 지정합니다. 기본값은 단순한 상자의 경우 얼굴의 전경색이고 3D 상자의 경우 얼굴의 배경색입니다.</target>
        </trans-unit>
        <trans-unit id="726b5e07fbd252dac7c2dae2a2b05f252281e1cf" translate="yes" xml:space="preserve">
          <source>The value &lt;var&gt;height&lt;/var&gt; is the value that was specified for the height of the horizontal scroll bar (which may be &lt;code&gt;nil&lt;/code&gt;); &lt;var&gt;lines&lt;/var&gt; is the (possibly rounded) number of lines that the horizontally scroll bar actually occupies.</source>
          <target state="translated">값 &lt;var&gt;height&lt;/var&gt; (수있다 수평 스크롤 바의 높이에 대해 지정된 값이다 &lt;code&gt;nil&lt;/code&gt; ); &lt;var&gt;lines&lt;/var&gt; 은 가로 스크롤 막대가 실제로 차지하는 (반올림 된) 줄 수입니다.</target>
        </trans-unit>
        <trans-unit id="db2573e485b9f1d52d90fe7b697fd92212845cf8" translate="yes" xml:space="preserve">
          <source>The value &lt;var&gt;style&lt;/var&gt; specifies whether to draw a 3D box. If it is &lt;code&gt;released-button&lt;/code&gt;, the box looks like a 3D button that is not being pressed. If it is &lt;code&gt;pressed-button&lt;/code&gt;, the box looks like a 3D button that is being pressed. If it is &lt;code&gt;nil&lt;/code&gt; or omitted, a plain 2D box is used.</source>
          <target state="translated">값 &lt;var&gt;style&lt;/var&gt; 은 3D 상자를 그릴 지 여부를 지정합니다. 그것은 경우 &lt;code&gt;released-button&lt;/code&gt; 누르면되지 않는 차원 버튼과 같은 상자 모양입니다. 그것은 경우 &lt;code&gt;pressed-button&lt;/code&gt; , 누르고있는 3 차원 버튼과 같은 상자 모양입니다. 이 경우 &lt;code&gt;nil&lt;/code&gt; 또는 생략, 일반 2D 상자가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1eb8d30e0ef6e2c616649855299438edaa4b6387" translate="yes" xml:space="preserve">
          <source>The value &lt;var&gt;width&lt;/var&gt; is the value that was specified for the width of the vertical scroll bar (which may be &lt;code&gt;nil&lt;/code&gt;); &lt;var&gt;columns&lt;/var&gt; is the (possibly rounded) number of columns that the vertical scroll bar actually occupies.</source>
          <target state="translated">값 &lt;var&gt;width&lt;/var&gt; (수있다 수직 스크롤 바의 폭에 대해 지정된 값이다 &lt;code&gt;nil&lt;/code&gt; ); &lt;var&gt;columns&lt;/var&gt; 은 수직 스크롤 막대가 실제로 차지하는 (반올림 된) 열 수입니다.</target>
        </trans-unit>
        <trans-unit id="738dcd4e09dec82d9c9cbf00960b591b0d043018" translate="yes" xml:space="preserve">
          <source>The value can also be a list of error conditions (see &lt;a href=&quot;signaling-errors#Signaling-Errors&quot;&gt;Signaling Errors&lt;/a&gt;). Then the debugger is called only for error conditions in this list (except those also listed in &lt;code&gt;debug-ignored-errors&lt;/code&gt;). For example, if you set &lt;code&gt;debug-on-error&lt;/code&gt; to the list &lt;code&gt;(void-variable)&lt;/code&gt;, the debugger is only called for errors about a variable that has no value.</source>
          <target state="translated">이 값은 오류 조건 목록 일 수도 있습니다 ( &lt;a href=&quot;signaling-errors#Signaling-Errors&quot;&gt;신호 오류&lt;/a&gt; 참조 ). 그런 다음이 목록의 오류 조건에 대해서만 디버거가 호출됩니다 ( &lt;code&gt;debug-ignored-errors&lt;/code&gt; 에 나열된 오류 조건 제외 ). 예를 들어, &lt;code&gt;debug-on-error&lt;/code&gt; 를 목록 &lt;code&gt;(void-variable)&lt;/code&gt; 으로 설정하면 디버거는 값이없는 변수에 대한 오류에 대해서만 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="0fca95603596a3c0776843a564cf75cbd2a26719" translate="yes" xml:space="preserve">
          <source>The value can also be a symbol with a function definition. That is equivalent to &lt;code&gt;t&lt;/code&gt;, except that the next warning will also call the function with no arguments with the warnings buffer current. The function can insert text which will serve as a header for the series of warnings.</source>
          <target state="translated">값은 함수 정의가있는 기호 일 수도 있습니다. 에 해당 즉 &lt;code&gt;t&lt;/code&gt; , 다음 경고는 또한 경고와 함께 인수없이 기능을 현재 버퍼 호출하는 것을 제외하고. 이 함수는 일련의 경고에 대한 헤더 역할을 할 텍스트를 삽입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="036ce65d4e444cc9ca133db8c5ff911fde4b8b3b" translate="yes" xml:space="preserve">
          <source>The value can also be floating point or a function, which specifies the height relative to an &lt;em&gt;underlying face&lt;/em&gt; (see &lt;a href=&quot;displaying-faces#Displaying-Faces&quot;&gt;Displaying Faces&lt;/a&gt;). A floating-point value specifies the amount by which to scale the height of the underlying face. A function value is called with one argument, the height of the underlying face, and returns the height of the new face. If the function is passed an integer argument, it must return an integer.</source>
          <target state="translated">값은 부동 소수점 또는 &lt;em&gt;기본면에&lt;/em&gt; 상대적인 높이를 지정하는 함수일 수도 있습니다 ( &lt;em&gt;면 &lt;/em&gt;&lt;a href=&quot;displaying-faces#Displaying-Faces&quot;&gt;표시&lt;/a&gt; 참조 ). 부동 소수점 값은 기본 얼굴의 높이를 조정하는 양을 지정합니다. 함수 값은 하나의 인수, 기본 얼굴의 높이와 함께 호출되고 새 얼굴의 높이를 반환합니다. 함수에 정수 인수가 전달되면 정수를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="93f34264bf299dd9ff1623c4a048f9a90b6d13e4" translate="yes" xml:space="preserve">
          <source>The value can be &lt;code&gt;nil&lt;/code&gt; (don&amp;rsquo;t use parity), the symbol &lt;code&gt;odd&lt;/code&gt; (use odd parity), or the symbol &lt;code&gt;even&lt;/code&gt; (use even parity). If &lt;var&gt;parity&lt;/var&gt; is not given, it defaults to no parity.</source>
          <target state="translated">값은 다음 &lt;code&gt;nil&lt;/code&gt; (패리티를 사용하지 않음), 상기 심볼 &lt;code&gt;odd&lt;/code&gt; (홀수 패리티를 사용), 또는 기호 &lt;code&gt;even&lt;/code&gt; (짝수 패리티를 사용). &lt;var&gt;parity&lt;/var&gt; 가 제공되지 않으면 패리티 없음으로 기본 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="b19ab7691b129f64fc5f72d4c526e81bb1415159" translate="yes" xml:space="preserve">
          <source>The value can be a string; that should be the name of a file containing external-format X bitmap data. The file is found in the directories listed in the variable &lt;code&gt;x-bitmap-file-path&lt;/code&gt;.</source>
          <target state="translated">값은 문자열 일 수 있습니다. 외부 형식 X 비트 맵 데이터를 포함하는 파일의 이름이어야합니다. 파일은 &lt;code&gt;x-bitmap-file-path&lt;/code&gt; 변수에 나열된 디렉토리에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90810279cbdbc3d6497008e3e858bcead8d9c860" translate="yes" xml:space="preserve">
          <source>The value can be an approximation. The function may avoid expensive processing and return an inexact result.</source>
          <target state="translated">값은 근사치 일 수 있습니다. 이 함수는 값 비싼 처리를 피하고 정확하지 않은 결과를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0ff635173abbeea2ba4af8f9b36759383fe725e" translate="yes" xml:space="preserve">
          <source>The value cell holds a symbol&amp;rsquo;s value as a variable, which is what you get if the symbol itself is evaluated as a Lisp expression. See &lt;a href=&quot;variables#Variables&quot;&gt;Variables&lt;/a&gt;, for details about how values are set and retrieved, including complications such as &lt;em&gt;local bindings&lt;/em&gt; and &lt;em&gt;scoping rules&lt;/em&gt;. Most symbols can have any Lisp object as a value, but certain special symbols have values that cannot be changed; these include &lt;code&gt;nil&lt;/code&gt; and &lt;code&gt;t&lt;/code&gt;, and any symbol whose name starts with &amp;lsquo;</source>
          <target state="translated">값 셀은 기호의 값을 변수로 보유하며, 이는 기호 자체가 Lisp 표현식으로 평가되는 경우 얻을 수있는 것입니다. &lt;em&gt;로컬 바인딩&lt;/em&gt; 및 &lt;em&gt;범위 지정 규칙&lt;/em&gt; 과 같은 문제를 포함하여 값을 설정하고 검색하는 방법에 대한 자세한 내용은 &lt;a href=&quot;variables#Variables&quot;&gt;변수를&lt;/a&gt; 참조하십시오 . 대부분의 기호는 Lisp 객체를 값으로 가질 수 있지만 특정 특수 기호에는 변경할 수없는 값이 있습니다. 여기에는 &lt;code&gt;nil&lt;/code&gt; 및 &lt;code&gt;t&lt;/code&gt; 및 이름이 '로 시작하는 모든 기호가 포함됩니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="00902684377c36ec854c666f66e1def68419f7f0" translate="yes" xml:space="preserve">
          <source>The value decides which Lisp object to use for representing a JSON array. It can be either &lt;code&gt;array&lt;/code&gt;, the default, to use Lisp arrays; or &lt;code&gt;list&lt;/code&gt; to use lists.</source>
          <target state="translated">값은 JSON 배열을 나타내는 데 사용할 Lisp 개체를 결정합니다. Lisp 배열을 사용하려면 기본값 인 &lt;code&gt;array&lt;/code&gt; 중 하나 일 수 있습니다 . 또는 &lt;code&gt;list&lt;/code&gt; 을 사용하려면 목록.</target>
        </trans-unit>
        <trans-unit id="16edef5cb81f91f4adf2188db4dc4f629deae17d" translate="yes" xml:space="preserve">
          <source>The value decides which Lisp object to use for representing the key-value mappings of a JSON object. It can be either &lt;code&gt;hash-table&lt;/code&gt;, the default, to make hashtables with strings as keys; &lt;code&gt;alist&lt;/code&gt; to use alists with symbols as keys; or &lt;code&gt;plist&lt;/code&gt; to use plists with keyword symbols as keys.</source>
          <target state="translated">이 값은 JSON 개체의 키-값 매핑을 나타내는 데 사용할 Lisp 개체를 결정합니다. 문자열을 키로 사용하여 해시 테이블을 만드는 것은 기본값 인 &lt;code&gt;hash-table&lt;/code&gt; 일 수 있습니다 . &lt;code&gt;alist&lt;/code&gt; 는 기호가있는 alist 를 키로 사용합니다. 또는 &lt;code&gt;plist&lt;/code&gt; 를 사용하여 키워드 기호가있는 plist 를 키로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3fa2905ebfc7e60316747f384efec8fd2b021c6b" translate="yes" xml:space="preserve">
          <source>The value decides which Lisp object to use to represent the JSON keyword &lt;code&gt;false&lt;/code&gt;. It defaults to the symbol &lt;code&gt;:false&lt;/code&gt;.</source>
          <target state="translated">값은 JSON 키워드 &lt;code&gt;false&lt;/code&gt; 를 나타내는 데 사용할 Lisp 객체를 결정합니다 . 기본값은 &lt;code&gt;:false&lt;/code&gt; 기호 입니다.</target>
        </trans-unit>
        <trans-unit id="70971f173ca78b68c08bef1aa1b243f7d8fcb51c" translate="yes" xml:space="preserve">
          <source>The value decides which Lisp object to use to represent the JSON keyword &lt;code&gt;null&lt;/code&gt;. It defaults to the symbol &lt;code&gt;:null&lt;/code&gt;.</source>
          <target state="translated">값은 JSON 키워드 &lt;code&gt;null&lt;/code&gt; 을 나타내는 데 사용할 Lisp 개체를 결정합니다 . 기본값은 &lt;code&gt;:null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0fe437d2786c53546e9e4721af67a363a80470e7" translate="yes" xml:space="preserve">
          <source>The value denotes the side of the frame or window where a new window displaying the buffer shall be created. This entry is used by &lt;code&gt;display-buffer-in-side-window&lt;/code&gt; to indicate the side of the frame where a new side window shall be placed (see &lt;a href=&quot;displaying-buffers-in-side-windows#Displaying-Buffers-in-Side-Windows&quot;&gt;Displaying Buffers in Side Windows&lt;/a&gt;). It is also used by &lt;code&gt;display-buffer-in-atom-window&lt;/code&gt; to indicate the side of an existing window where the new window shall be located (see &lt;a href=&quot;atomic-windows#Atomic-Windows&quot;&gt;Atomic Windows&lt;/a&gt;).</source>
          <target state="translated">값은 버퍼를 표시하는 새 창이 생성 될 프레임 또는 창의 측면을 나타냅니다. 이 항목은 &lt;code&gt;display-buffer-in-side-window&lt;/code&gt; 에서 새 사이드 윈도우가 배치 될 프레임의 측면을 표시하는 데 사용됩니다 ( &lt;a href=&quot;displaying-buffers-in-side-windows#Displaying-Buffers-in-Side-Windows&quot;&gt;사이드 윈도우에 버퍼 표시&lt;/a&gt; 참조 ). 그것도 의해 사용되는 &lt;code&gt;display-buffer-in-atom-window&lt;/code&gt; (참조 새로운 윈도우가 위치한다 기존 창의 측면을 나타내도록 &lt;a href=&quot;atomic-windows#Atomic-Windows&quot;&gt;원자 윈도우&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="f7ee348338ce1106641a672b981019be718a72ff" translate="yes" xml:space="preserve">
          <source>The value has no effect when renaming would not alter the owner or group of the file; that is, for files which are owned by the user and whose group matches the default for a new file created there by the user.</source>
          <target state="translated">이름을 변경해도 파일의 소유자 또는 그룹이 변경되지 않으면 값이 적용되지 않습니다. 즉, 사용자가 소유하고 그룹이 사용자가 생성 한 새 파일의 기본값과 일치하는 파일의 경우.</target>
        </trans-unit>
        <trans-unit id="ffc415f45e41ef7cef7291f52d1ca8b82b116694" translate="yes" xml:space="preserve">
          <source>The value has the form &lt;code&gt;(&lt;var&gt;offset&lt;/var&gt; &lt;var&gt;abbr&lt;/var&gt;)&lt;/code&gt;. Here &lt;var&gt;offset&lt;/var&gt; is an integer giving the number of seconds ahead of Universal Time (east of Greenwich). A negative value means west of Greenwich. The second element, &lt;var&gt;abbr&lt;/var&gt;, is a string giving an abbreviation for the time zone, e.g., &amp;lsquo;</source>
          <target state="translated">값의 형식은 &lt;code&gt;(&lt;var&gt;offset&lt;/var&gt; &lt;var&gt;abbr&lt;/var&gt;)&lt;/code&gt; 입니다. 여기서 &lt;var&gt;offset&lt;/var&gt; 은 세계시 (그리니치 동부)보다 앞선 시간 (초)을 제공하는 정수입니다. 음수 값은 그리니치 서쪽을 의미합니다. 두 번째 요소 &lt;var&gt;abbr&lt;/var&gt; 은 시간대의 약어를 제공하는 문자열입니다 (예 : '</target>
        </trans-unit>
        <trans-unit id="d54c14bbe8e273d4103e284f553d7a5a47ac3803" translate="yes" xml:space="preserve">
          <source>The value is 5 because that is the</source>
          <target state="translated">값은 5입니다.</target>
        </trans-unit>
        <trans-unit id="fcb6e2e9389f7780a675906dacf95eb444c0772f" translate="yes" xml:space="preserve">
          <source>The value is &lt;code&gt;nil&lt;/code&gt; for a subexpression inside a &amp;lsquo;</source>
          <target state="translated">값은 '내부의 하위 표현식에 대해 &lt;code&gt;nil&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ac9636b8cfc92069e35cc830e2013018fdbb6b7e" translate="yes" xml:space="preserve">
          <source>The value is &lt;code&gt;nil&lt;/code&gt; if &lt;var&gt;count&lt;/var&gt; is out of range, or for a subexpression inside a &amp;lsquo;</source>
          <target state="translated">값은 &lt;code&gt;nil&lt;/code&gt; 경우 &lt;var&gt;count&lt;/var&gt; 돌며 범위를 벗어나거나 표현식은 '</target>
        </trans-unit>
        <trans-unit id="c167e0d6bf2b798519700d2a08b4be56ddb7ac7a" translate="yes" xml:space="preserve">
          <source>The value is &lt;code&gt;nil&lt;/code&gt; if &lt;var&gt;pos&lt;/var&gt; is not visible in &lt;var&gt;window&lt;/var&gt;. If &lt;var&gt;window&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, that stands for the selected window. If &lt;var&gt;pos&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, that stands for the value of point in &lt;var&gt;window&lt;/var&gt;.</source>
          <target state="translated">값은 &lt;code&gt;nil&lt;/code&gt; 경우 &lt;var&gt;pos&lt;/var&gt; 가 에 보이지 않는 &lt;var&gt;window&lt;/var&gt; . 경우 &lt;var&gt;window&lt;/var&gt; 입니다 &lt;code&gt;nil&lt;/code&gt; , 그 선택된 창을 의미합니다. 경우 &lt;var&gt;pos&lt;/var&gt; 가 있다 &lt;code&gt;nil&lt;/code&gt; , 그에서 점의 값을 의미합니다 &lt;var&gt;window&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="a178845a64825fe33f0ce1505830cf0c8571ccb5" translate="yes" xml:space="preserve">
          <source>The value is &lt;code&gt;nil&lt;/code&gt; if &lt;var&gt;state&lt;/var&gt; represents a parse which has arrived at a top level position.</source>
          <target state="translated">&lt;var&gt;state&lt;/var&gt; 가 최상위 위치에 도달 한 구문 분석을 나타내는 경우 값은 &lt;code&gt;nil&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f1847ffb79e4ef977f22b0f89bbfa3a8711353ea" translate="yes" xml:space="preserve">
          <source>The value is &lt;code&gt;nil&lt;/code&gt; if the properties remain unchanged all the way to the end of &lt;var&gt;object&lt;/var&gt; and &lt;var&gt;limit&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;. If the value is non-&lt;code&gt;nil&lt;/code&gt;, it is a position greater than or equal to &lt;var&gt;pos&lt;/var&gt;. The value equals &lt;var&gt;pos&lt;/var&gt; only when &lt;var&gt;limit&lt;/var&gt; equals &lt;var&gt;pos&lt;/var&gt;.</source>
          <target state="translated">값은 &lt;code&gt;nil&lt;/code&gt; 속성이의 말에 모든 방법을 그대로 유지하는 경우 &lt;var&gt;object&lt;/var&gt; 및 &lt;var&gt;limit&lt;/var&gt; 입니다 &lt;code&gt;nil&lt;/code&gt; . 값이 &lt;code&gt;nil&lt;/code&gt; 이 아니면 &lt;var&gt;pos&lt;/var&gt; 보다 크거나 같은 위치 입니다. 값은 &lt;var&gt;limit&lt;/var&gt; 가 &lt;var&gt;pos&lt;/var&gt; 일 때만 &lt;var&gt;pos&lt;/var&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="f42191ef8fc8d62fa782e6182ae3d4adf74e945c" translate="yes" xml:space="preserve">
          <source>The value is &lt;code&gt;nil&lt;/code&gt; if the property remains unchanged all the way to the end of &lt;var&gt;object&lt;/var&gt; and &lt;var&gt;limit&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;. If the value is non-&lt;code&gt;nil&lt;/code&gt;, it is a position greater than or equal to &lt;var&gt;pos&lt;/var&gt;; it equals &lt;var&gt;pos&lt;/var&gt; only if &lt;var&gt;limit&lt;/var&gt; equals &lt;var&gt;pos&lt;/var&gt;.</source>
          <target state="translated">값은 &lt;code&gt;nil&lt;/code&gt; 속성 줄곧의 끝까지 변하지 경우 &lt;var&gt;object&lt;/var&gt; 및 &lt;var&gt;limit&lt;/var&gt; 인 &lt;code&gt;nil&lt;/code&gt; . 값이 &lt;code&gt;nil&lt;/code&gt; 이 아니면 &lt;var&gt;pos&lt;/var&gt; 보다 크거나 같은 위치입니다 . 그것은 동일 &lt;var&gt;pos&lt;/var&gt; 경우에만 &lt;var&gt;limit&lt;/var&gt; 동일 &lt;var&gt;pos&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="862c753ca19532a871df595b1b786989741df504" translate="yes" xml:space="preserve">
          <source>The value is a form (an expression).</source>
          <target state="translated">값은 양식 (표현식)입니다.</target>
        </trans-unit>
        <trans-unit id="ec33dbdc3801cba4b2a38abf814dcf1da00c4804" translate="yes" xml:space="preserve">
          <source>The value is a function.</source>
          <target state="translated">값은 함수입니다.</target>
        </trans-unit>
        <trans-unit id="18ad4635bccc9d11d2025c4e0e4bf454e39e4870" translate="yes" xml:space="preserve">
          <source>The value is a key sequence. The customization buffer shows the key sequence using the same syntax as the</source>
          <target state="translated">값은 키 시퀀스입니다. 사용자 정의 버퍼는 다음과 같은 구문을 사용하여 키 시퀀스를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="92047d2ff22dd07d30de54ae74480f7db138859c" translate="yes" xml:space="preserve">
          <source>The value is a list of all defined character set names.</source>
          <target state="translated">값은 정의 된 모든 문자 세트 이름의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="42e3b3b8e9f18abe4b0e6fc019c88b2b88f0e5a7" translate="yes" xml:space="preserve">
          <source>The value is a list of forms (expressions).</source>
          <target state="translated">값은 양식 (표현식) 목록입니다.</target>
        </trans-unit>
        <trans-unit id="d9d7add64fd5fda2d55573b4b40ddee4fa132824" translate="yes" xml:space="preserve">
          <source>The value is a list of functions.</source>
          <target state="translated">값은 함수 목록입니다.</target>
        </trans-unit>
        <trans-unit id="744e014c080a028da5111b9957a721b5376e2f9e" translate="yes" xml:space="preserve">
          <source>The value is a predicate&amp;mdash;a function of one argument that returns non-&lt;code&gt;nil&lt;/code&gt; for success and &lt;code&gt;nil&lt;/code&gt; for failure.</source>
          <target state="translated">값은 하나 개의 인수의 조건 - 함수 반환이 아닌이 &lt;code&gt;nil&lt;/code&gt; 성공을위한 &lt;code&gt;nil&lt;/code&gt; 실패.</target>
        </trans-unit>
        <trans-unit id="fc95eed350ead41f92d508546cbe37902aff0c7a" translate="yes" xml:space="preserve">
          <source>The value is a program name.</source>
          <target state="translated">값은 프로그램 이름입니다.</target>
        </trans-unit>
        <trans-unit id="b563d6300ce73a67d16482c93e6765622dfc6342" translate="yes" xml:space="preserve">
          <source>The value is a whole shell command.</source>
          <target state="translated">값은 전체 쉘 명령입니다.</target>
        </trans-unit>
        <trans-unit id="0fb0a1e296cb5eb5561689c7425698e96e4d5162" translate="yes" xml:space="preserve">
          <source>The value is always a string ending with a slash.</source>
          <target state="translated">값은 항상 슬래시로 끝나는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="38abcf64aec0a36e0f511c163ed2cd547b75773a" translate="yes" xml:space="preserve">
          <source>The value is an alist or nested alist in which each element describes one unpacked field.</source>
          <target state="translated">값은 각 요소가 압축 해제 된 하나의 필드를 설명하는 alist 또는 중첩 된 alist입니다.</target>
        </trans-unit>
        <trans-unit id="f7f574a40cde0014d34b1f4c77ea68404bc7d6db" translate="yes" xml:space="preserve">
          <source>The value is an expression for determining whether the named menu item should be enabled in menus. See &lt;a href=&quot;simple-menu-items#Simple-Menu-Items&quot;&gt;Simple Menu Items&lt;/a&gt;.</source>
          <target state="translated">값은 메뉴에서 명명 된 메뉴 항목을 활성화해야하는지 여부를 결정하기위한 표현식입니다. &lt;a href=&quot;simple-menu-items#Simple-Menu-Items&quot;&gt;간단한 메뉴 항목을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="988d1fb03cc87294d6912ad4a008a4a541a3d1cf" translate="yes" xml:space="preserve">
          <source>The value is an interactive form for the named function. Normally, you should not set this directly; use the &lt;code&gt;interactive&lt;/code&gt; special form instead. See &lt;a href=&quot;interactive-call#Interactive-Call&quot;&gt;Interactive Call&lt;/a&gt;.</source>
          <target state="translated">값은 명명 된 함수에 대한 대화 형 형식입니다. 일반적으로 직접 설정하면 안됩니다. 사용 &lt;code&gt;interactive&lt;/code&gt; 대신 특별한 양식을. &lt;a href=&quot;interactive-call#Interactive-Call&quot;&gt;대화 형 통화를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a2675782eef27c42642a60fce1752cbb34644db5" translate="yes" xml:space="preserve">
          <source>The value is boolean&amp;mdash;either &lt;code&gt;nil&lt;/code&gt; or &lt;code&gt;t&lt;/code&gt;. Note that by using &lt;code&gt;choice&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; together (see the next section), you can specify that the value must be &lt;code&gt;nil&lt;/code&gt; or &lt;code&gt;t&lt;/code&gt;, but also specify the text to describe each value in a way that fits the specific meaning of the alternative.</source>
          <target state="translated">값은 부울 ( &lt;code&gt;nil&lt;/code&gt; 또는 &lt;code&gt;t&lt;/code&gt; ) 입니다. &lt;code&gt;choice&lt;/code&gt; 와 &lt;code&gt;const&lt;/code&gt; 를 함께 사용 하면 (다음 섹션 참조) 값이 &lt;code&gt;nil&lt;/code&gt; 또는 &lt;code&gt;t&lt;/code&gt; 여야 함을 지정할 수 있지만 대안의 특정 의미에 맞는 방식으로 각 값을 설명하는 텍스트도 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3894f2edc61204404042bc861be88ec42f3d3a29" translate="yes" xml:space="preserve">
          <source>The value is copied from &lt;code&gt;this-command&lt;/code&gt; when a command returns to the command loop, except when the command has specified a prefix argument for the following command.</source>
          <target state="translated">명령이 다음 명령에 대한 접두사 인수를 지정한 경우를 제외하고 명령이 명령 루프로 반환 될 때이 &lt;code&gt;this-command&lt;/code&gt; 에서 값이 복사됩니다 .</target>
        </trans-unit>
        <trans-unit id="306c554506d781ac28efad2e4ea92701f816dce5" translate="yes" xml:space="preserve">
          <source>The value is either a major mode or a list of major modes. &lt;code&gt;display-buffer-reuse-mode-window&lt;/code&gt; may reuse a window whenever the value specified by this entry matches the major mode of that window&amp;rsquo;s buffer. Other action functions ignore such entries.</source>
          <target state="translated">값은 주 모드 또는 주 모드 목록입니다. &lt;code&gt;display-buffer-reuse-mode-window&lt;/code&gt; 는이 항목에 지정된 값이 해당 창 버퍼의 주 모드와 일치 할 때마다 창을 재사용 할 수 있습니다. 다른 작업 함수는 이러한 항목을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="1843e0f5c17e7f0a09b0d1319f9a950d3c352fa5" translate="yes" xml:space="preserve">
          <source>The value is either the empty vector, or is a newly constructed nonempty vector that is not &lt;code&gt;eq&lt;/code&gt; to any existing vector.</source>
          <target state="translated">값은 빈 벡터이거나 기존 벡터에 &lt;code&gt;eq&lt;/code&gt; 이 아닌 새로 생성 된 비어 있지 않은 벡터입니다 .</target>
        </trans-unit>
        <trans-unit id="eb6e5361e7a91533e27cdf7399370f943e9ba10d" translate="yes" xml:space="preserve">
          <source>The value is measured in baud.</source>
          <target state="translated">값은 보드 단위로 측정됩니다.</target>
        </trans-unit>
        <trans-unit id="be4e71b6f99d1f91e5e6b4886554248affe4a867" translate="yes" xml:space="preserve">
          <source>The value is negative if the first substring is less, positive if the first is greater, and zero if they are equal. The absolute value of the result is one plus the index of the first differing characters within the substrings.</source>
          <target state="translated">값은 첫 번째 부분 문자열이 더 작 으면 음수이고, 첫 번째 부분 문자열이 더 크면 양수, 같으면 0입니다. 결과의 절대 값은 1에 하위 문자열 내에서 처음으로 다른 문자의 인덱스를 더한 값입니다.</target>
        </trans-unit>
        <trans-unit id="a221deec0b7b326eded452b6cef1afc0c42096b1" translate="yes" xml:space="preserve">
          <source>The value is normally &lt;code&gt;nil&lt;/code&gt;; Lisp programs bind it to &lt;code&gt;t&lt;/code&gt; for brief periods of time.</source>
          <target state="translated">값은 일반적으로 &lt;code&gt;nil&lt;/code&gt; 입니다 . Lisp 프로그램 은 짧은 시간 동안이 를 &lt;code&gt;t&lt;/code&gt; 에 바인딩합니다 .</target>
        </trans-unit>
        <trans-unit id="a10d990baa1d6dc687c357d4165562f04a895757" translate="yes" xml:space="preserve">
          <source>The value is normally a list of the form &lt;code&gt;(&lt;var&gt;filenum&lt;/var&gt;
&lt;var&gt;devnum&lt;/var&gt;)&lt;/code&gt;. This pair of numbers uniquely identifies the file among all files accessible on the system. See the function &lt;code&gt;file-attributes&lt;/code&gt;, in &lt;a href=&quot;file-attributes#File-Attributes&quot;&gt;File Attributes&lt;/a&gt;, for more information about them.</source>
          <target state="translated">값은 일반적으로 형식 &lt;code&gt;(&lt;var&gt;filenum&lt;/var&gt; &lt;var&gt;devnum&lt;/var&gt;)&lt;/code&gt; 의 목록입니다 . 이 숫자 쌍은 시스템에서 액세스 할 수있는 모든 파일 중에서 파일을 고유하게 식별합니다. 이에 대한 자세한 정보 는 &lt;a href=&quot;file-attributes#File-Attributes&quot;&gt;파일 속성의 &lt;/a&gt; &lt;code&gt;file-attributes&lt;/code&gt; 함수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f6457f0bb5cd3fdfe83d6454775a62a020b7ae87" translate="yes" xml:space="preserve">
          <source>The value is normally an absolute file name. It can also be &lt;code&gt;nil&lt;/code&gt;, if the definition is not associated with any file. If &lt;var&gt;symbol&lt;/var&gt; specifies an autoloaded function, the value can be a relative file name without extension.</source>
          <target state="translated">값은 일반적으로 절대 파일 이름입니다. 정의가 파일과 연관되지 않은 경우 &lt;code&gt;nil&lt;/code&gt; 일 수도 있습니다 . &lt;var&gt;symbol&lt;/var&gt; 이 자동로드 된 함수를 지정하는 경우 값은 확장자가없는 상대 파일 이름 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4bcfcbe7d05d1c0191cd0ba7af653328fe120d2" translate="yes" xml:space="preserve">
          <source>The value is significant only as to whether it is &lt;code&gt;nil&lt;/code&gt; or not. Since such variables often end up acquiring more values over time, this convention is not strongly recommended.</source>
          <target state="translated">이 값은 &lt;code&gt;nil&lt;/code&gt; 인지 여부에 대해서만 중요합니다 . 이러한 변수는 시간이 지남에 따라 더 많은 값을 획득하는 경우가 많으므로이 규칙은 강력히 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="778494fde2953cd1ddb11ad185ad2d2dd95186e4" translate="yes" xml:space="preserve">
          <source>The value may also be &lt;code&gt;nil&lt;/code&gt;. Then all commands work normally, even disabled ones.</source>
          <target state="translated">값은 &lt;code&gt;nil&lt;/code&gt; 일 수도 있습니다 . 그런 다음 모든 명령이 정상적으로 작동하며 비활성화 된 명령도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="ef59b01ef55bdf2efe2493eea3cfaf23a97d2e9e" translate="yes" xml:space="preserve">
          <source>The value may be any Lisp object that can be printed and read back. You can use &lt;code&gt;sexp&lt;/code&gt; as a fall-back for any option, if you don&amp;rsquo;t want to take the time to work out a more specific type to use.</source>
          <target state="translated">값은 인쇄하고 다시 읽을 수있는 Lisp 개체 일 수 있습니다. 더 구체적인 유형을 사용하는 데 시간을 할애하지 않으려면 모든 옵션에 대한 &lt;code&gt;sexp&lt;/code&gt; 으로 sexp 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b99730ddec359b16348016cabda6e3291d81a09e" translate="yes" xml:space="preserve">
          <source>The value must be &lt;var&gt;value&lt;/var&gt;&amp;mdash;nothing else is allowed.</source>
          <target state="translated">값은해야 &lt;var&gt;value&lt;/var&gt; 허용되는 다른 - 아무것도.</target>
        </trans-unit>
        <trans-unit id="87b4d5cd14fe72c47e3003a8680a757eb4604dbf" translate="yes" xml:space="preserve">
          <source>The value must be a character code. A character code is actually an integer, but this type shows the value by inserting the character in the buffer, rather than by showing the number.</source>
          <target state="translated">값은 문자 코드 여야합니다. 문자 코드는 실제로 정수이지만이 유형은 숫자를 표시하는 대신 버퍼에 문자를 삽입하여 값을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="356d38d5cf3fa505e305c63022ab492161a1a6ed" translate="yes" xml:space="preserve">
          <source>The value must be a coding-system name, and you can do completion with</source>
          <target state="translated">값은 코딩 시스템 이름이어야하며 다음을 사용하여 완료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63573ffb5bc552f254086ecf27ae3051cb0cceff" translate="yes" xml:space="preserve">
          <source>The value must be a cons cell, its &lt;small&gt;CAR&lt;/small&gt; must fit &lt;var&gt;car-type&lt;/var&gt;, and its &lt;small&gt;CDR&lt;/small&gt; must fit &lt;var&gt;cdr-type&lt;/var&gt;. For example, &lt;code&gt;(cons string
symbol)&lt;/code&gt; is a customization type which matches values such as &lt;code&gt;(&quot;foo&quot; . foo)&lt;/code&gt;.</source>
          <target state="translated">값은 cons 셀 이어야 하고 &lt;small&gt;CAR&lt;/small&gt; 은 &lt;var&gt;car-type&lt;/var&gt; 에 맞아야 하며 &lt;small&gt;CDR&lt;/small&gt; 은 &lt;var&gt;cdr-type&lt;/var&gt; 에 맞아야 합니다 . 예를 들어, &lt;code&gt;(cons string symbol)&lt;/code&gt; 은 &lt;code&gt;(&quot;foo&quot; . foo)&lt;/code&gt; 와 같은 값과 일치하는 사용자 정의 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="57910dac76238c31c6f7af52f08cdcf756ebfb61" translate="yes" xml:space="preserve">
          <source>The value must be a directory. The widget provides completion.</source>
          <target state="translated">값은 디렉토리 여야합니다. 위젯이 완성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="810836eddfb49dd28f43e49c497214d6e73aaac5" translate="yes" xml:space="preserve">
          <source>The value must be a file name for an existing file. The widget provides completion.</source>
          <target state="translated">값은 기존 파일의 파일 이름이어야합니다. 위젯이 완성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b6a74a7f285c0c5906e259820de400e746147836" translate="yes" xml:space="preserve">
          <source>The value must be a file name. The widget provides completion.</source>
          <target state="translated">값은 파일 이름이어야합니다. 위젯이 완성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="13f9e716c79c89cbb1b9b4a0a3061a3b3b7535c7" translate="yes" xml:space="preserve">
          <source>The value must be a function taking one argument (a frame), supposed to return non-&lt;code&gt;nil&lt;/code&gt; if that frame is a candidate for displaying the buffer. This entry is used by &lt;code&gt;display-buffer-use-some-frame&lt;/code&gt;.</source>
          <target state="translated">값은 하나의 인수 (프레임)를 사용하는 함수 여야하며 해당 프레임이 버퍼를 표시 할 후보 인 경우 &lt;code&gt;nil&lt;/code&gt; 이 아닌 값을 반환해야합니다 . 이 항목은 &lt;code&gt;display-buffer-use-some-frame&lt;/code&gt; 에서 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="d0769814e541d4c1c6d9cf382832b62aff25584a" translate="yes" xml:space="preserve">
          <source>The value must be a function that takes one argument, a window, and returns either a new window (which will be used to display the desired buffer) or &lt;code&gt;nil&lt;/code&gt; (which means the splitting failed). The default value is &lt;code&gt;split-window-sensibly&lt;/code&gt;, which is documented next.</source>
          <target state="translated">값은 하나의 인수 인 창을 취하고 새 창 (원하는 버퍼를 표시하는 데 사용됨) 또는 &lt;code&gt;nil&lt;/code&gt; (분할 실패를 의미 함 )을 반환하는 함수 여야합니다 . 기본값은 &lt;code&gt;split-window-sensibly&lt;/code&gt; 이며 다음에 설명합니다.</target>
        </trans-unit>
        <trans-unit id="10add5bdc2dc784e1ca37482866dfd6d4c60ef8f" translate="yes" xml:space="preserve">
          <source>The value must be a list and each element of the list must fit the type &lt;var&gt;element-type&lt;/var&gt;. This appears in the customization buffer as a list of elements, with &amp;lsquo;</source>
          <target state="translated">값은 목록이어야하며 목록의 각 요소는 &lt;var&gt;element-type&lt;/var&gt; 유형에 맞아야합니다 . 이것은 사용자 정의 버퍼에 '</target>
        </trans-unit>
        <trans-unit id="69283ab46854490317f97e1feb0235ad06aef920" translate="yes" xml:space="preserve">
          <source>The value must be a list of cons-cells, the &lt;small&gt;CAR&lt;/small&gt; of each cell representing a key of customization type &lt;var&gt;key-type&lt;/var&gt;, and the &lt;small&gt;CDR&lt;/small&gt; of the same cell representing a value of customization type &lt;var&gt;value-type&lt;/var&gt;. The user can add and delete key/value pairs, and edit both the key and the value of each pair.</source>
          <target state="translated">값은 cons-cells 목록, 사용자 정의 유형 &lt;var&gt;key-type&lt;/var&gt; 의 키를 나타내는 각 셀 의 &lt;small&gt;CAR&lt;/small&gt; 및 사용자 정의 유형 &lt;var&gt;value-type&lt;/var&gt; 의 값을 나타내는 동일한 셀 의 &lt;small&gt;CDR&lt;/small&gt; 이어야합니다 . 사용자는 키 / 값 쌍을 추가 및 삭제할 수 있으며 각 쌍의 키와 값을 모두 편집 할 수 있습니다.&lt;small&gt;&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="e94e481856916cf8928303ce6c5fe6173ae9d7b6" translate="yes" xml:space="preserve">
          <source>The value must be a list of functions. This customization type is used for hook variables. You can use the &lt;code&gt;:options&lt;/code&gt; keyword in a hook variable&amp;rsquo;s &lt;code&gt;defcustom&lt;/code&gt; to specify a list of functions recommended for use in the hook; See &lt;a href=&quot;variable-definitions#Variable-Definitions&quot;&gt;Variable Definitions&lt;/a&gt;.</source>
          <target state="translated">값은 함수 목록이어야합니다. 이 사용자 정의 유형은 후크 변수에 사용됩니다. 당신이 사용할 수있는 &lt;code&gt;:options&lt;/code&gt; 후크 변수에 키워드 &lt;code&gt;defcustom&lt;/code&gt; 를 후크의 사용을 권장 기능 목록을 지정; &lt;a href=&quot;variable-definitions#Variable-Definitions&quot;&gt;변수 정의를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="54b586711663d904f858b9b290b8d22b94a091f6" translate="yes" xml:space="preserve">
          <source>The value must be a list with exactly as many elements as the &lt;var&gt;element-types&lt;/var&gt; given; and each element must fit the corresponding &lt;var&gt;element-type&lt;/var&gt;.</source>
          <target state="translated">값은 주어진 &lt;var&gt;element-types&lt;/var&gt; 만큼 정확하게 많은 요소가있는 목록이어야합니다 . 각 요소는 해당 &lt;var&gt;element-type&lt;/var&gt; 맞아야합니다 .</target>
        </trans-unit>
        <trans-unit id="896d6796a36a3b3136852c309aa7d01c3792f5f6" translate="yes" xml:space="preserve">
          <source>The value must be a list, and each element of the list must match one of the &lt;var&gt;types&lt;/var&gt; specified.</source>
          <target state="translated">값은 목록이어야하며 목록의 각 요소는 지정된 &lt;var&gt;types&lt;/var&gt; 중 하나와 일치해야 합니다.</target>
        </trans-unit>
        <trans-unit id="3aeeaa45e096ad8313dd25ab21d8c10013208130" translate="yes" xml:space="preserve">
          <source>The value must be a number (floating point or integer).</source>
          <target state="translated">값은 숫자 (부동 소수점 또는 정수) 여야합니다.</target>
        </trans-unit>
        <trans-unit id="945efd91d2acb86b2c28413feb5748c4d0bd2079" translate="yes" xml:space="preserve">
          <source>The value must be a string. The customization buffer shows the string without delimiting &amp;lsquo;</source>
          <target state="translated">값은 문자열이어야합니다. 사용자 정의 버퍼는 '를 구분하지 않고 문자열을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="4752821348ac6fabc91456f988d3e618cd05d1f6" translate="yes" xml:space="preserve">
          <source>The value must be a symbol which is a face name. The widget provides completion.</source>
          <target state="translated">값은 얼굴 이름 인 기호 여야합니다. 위젯이 완성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="67a06078fab94776bb45407ad95be9c13181139f" translate="yes" xml:space="preserve">
          <source>The value must be a symbol. It appears in the customization buffer as the symbol name. The widget provides completion.</source>
          <target state="translated">값은 기호 여야합니다. 사용자 정의 버퍼에 기호 이름으로 나타납니다. 위젯이 완성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5849f60cb5b32368a764c6539b8c8a00d225ed38" translate="yes" xml:space="preserve">
          <source>The value must be a valid color name. The widget provides completion for color names, as well as a sample and a button for selecting a color name from a list of color names shown in a</source>
          <target state="translated">값은 유효한 색상 이름이어야합니다. 위젯은 색상 이름에 대한 완성 기능을 제공 할뿐만 아니라에 표시된 색상 이름 목록에서 색상 이름을 선택하기위한 샘플 및 버튼을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d2c0b88b87276fde817f7f25e6fbe66a3b002536" translate="yes" xml:space="preserve">
          <source>The value must be a variable name. The widget provides completion.</source>
          <target state="translated">값은 변수 이름이어야합니다. 위젯이 완성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="866e1c92bc84fa3056c2cc92aa9eb34d171bc22b" translate="yes" xml:space="preserve">
          <source>The value must be an integer.</source>
          <target state="translated">값은 정수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="ce3a6a49432bb3e2bb25953ebf11758d62c57727" translate="yes" xml:space="preserve">
          <source>The value must be either a lambda expression or a function name. The widget provides completion for function names.</source>
          <target state="translated">값은 람다 식 또는 함수 이름이어야합니다. 위젯은 함수 이름에 대한 완성 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9de80c74f410724e3e9d2d4e057e94956796434d" translate="yes" xml:space="preserve">
          <source>The value must be floating point.</source>
          <target state="translated">값은 부동 소수점이어야합니다.</target>
        </trans-unit>
        <trans-unit id="597960a6ce739f902fa9c94199257d090be01a23" translate="yes" xml:space="preserve">
          <source>The value must fit one of &lt;var&gt;alternative-types&lt;/var&gt;. For example, &lt;code&gt;(choice integer string)&lt;/code&gt; allows either an integer or a string.</source>
          <target state="translated">값은 &lt;var&gt;alternative-types&lt;/var&gt; 중 하나에 맞아야합니다 . 예를 들어, &lt;code&gt;(choice integer string)&lt;/code&gt; 은 정수 또는 문자열을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="c16d4e66c8a9aef6f1bbfad4e5db9283eb01c2d3" translate="yes" xml:space="preserve">
          <source>The value must specify a window that may have displayed the buffer previously. &lt;code&gt;display-buffer-in-previous-window&lt;/code&gt; will give preference to such a window provided it is still live and not dedicated to another buffer.</source>
          <target state="translated">값은 이전에 버퍼를 표시했을 수있는 창을 지정해야합니다. &lt;code&gt;display-buffer-in-previous-window&lt;/code&gt; 는 여전히 라이브 상태이고 다른 버퍼 전용이 아닌 경우 이러한 창을 선호합니다.</target>
        </trans-unit>
        <trans-unit id="a8dcd9a15008fc01a594ad9652de93cb7a57eb20" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;(acos &lt;var&gt;arg&lt;/var&gt;)&lt;/code&gt; is a number between 0 and pi (inclusive) whose cosine is &lt;var&gt;arg&lt;/var&gt;. If &lt;var&gt;arg&lt;/var&gt; is out of range (outside [-1, 1]), &lt;code&gt;acos&lt;/code&gt; returns a NaN.</source>
          <target state="translated">값 &lt;code&gt;(acos &lt;var&gt;arg&lt;/var&gt;)&lt;/code&gt; 0 코사인 인 PI (포함) 사이의 수이다 &lt;var&gt;arg&lt;/var&gt; . 경우 &lt;var&gt;arg&lt;/var&gt; 범위를 벗어나 (외부 [-1, 1]) &lt;code&gt;acos&lt;/code&gt; 리턴 NaN이.</target>
        </trans-unit>
        <trans-unit id="fd06b4d6ba82cc559a28714761ccf61d840a6365" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;(asin &lt;var&gt;arg&lt;/var&gt;)&lt;/code&gt; is a number between -pi/2 and pi/2 (inclusive) whose sine is &lt;var&gt;arg&lt;/var&gt;. If &lt;var&gt;arg&lt;/var&gt; is out of range (outside [-1, 1]), &lt;code&gt;asin&lt;/code&gt; returns a NaN.</source>
          <target state="translated">&lt;code&gt;(asin &lt;var&gt;arg&lt;/var&gt;)&lt;/code&gt; 의 값은 사인이 &lt;var&gt;arg&lt;/var&gt; 인 -pi / 2와 pi / 2 (포함) 사이의 숫자 입니다. 경우 &lt;var&gt;arg&lt;/var&gt; 범위를 벗어나 (외부 [-1, 1]) &lt;code&gt;asin&lt;/code&gt; 리턴 NaN이.</target>
        </trans-unit>
        <trans-unit id="9a7380bf9f6c5b9249cafc94b2adcec1cea58bac" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;(atan &lt;var&gt;y&lt;/var&gt;)&lt;/code&gt; is a number between -pi/2 and pi/2 (exclusive) whose tangent is &lt;var&gt;y&lt;/var&gt;. If the optional second argument &lt;var&gt;x&lt;/var&gt; is given, the value of &lt;code&gt;(atan y x)&lt;/code&gt; is the angle in radians between the vector &lt;code&gt;[&lt;var&gt;x&lt;/var&gt;, &lt;var&gt;y&lt;/var&gt;]&lt;/code&gt; and the &lt;code&gt;X&lt;/code&gt; axis.</source>
          <target state="translated">&lt;code&gt;(atan &lt;var&gt;y&lt;/var&gt;)&lt;/code&gt; 의 값은 탄젠트가 &lt;var&gt;y&lt;/var&gt; 인 -pi / 2에서 pi / 2 (배타적) 사이의 숫자 입니다. 선택적 두 번째 인수 &lt;var&gt;x&lt;/var&gt; 가 주어지면 &lt;code&gt;(atan y x)&lt;/code&gt; 의 값은 벡터 &lt;code&gt;[&lt;var&gt;x&lt;/var&gt;, &lt;var&gt;y&lt;/var&gt;]&lt;/code&gt; 와 &lt;code&gt;X&lt;/code&gt; 축 사이의 각도 (라디안 단위 ) 입니다 .</target>
        </trans-unit>
        <trans-unit id="c9e728ea829977e40f53b131b5144e09a9f2f814" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;auto-fill-function&lt;/code&gt; is &lt;code&gt;do-auto-fill&lt;/code&gt; when Auto Fill mode is enabled. That is a function whose sole purpose is to implement the usual strategy for breaking a line.</source>
          <target state="translated">의 값 &lt;code&gt;auto-fill-function&lt;/code&gt; 있다 &lt;code&gt;do-auto-fill&lt;/code&gt; 자동 채우기 모드가 활성화 된 경우. 그것은 유일한 목적이 줄을 끊는 일반적인 전략을 구현하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d3bae7cd024789f811c4af6bb48478148919779d" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;exec-path&lt;/code&gt; is used by &lt;code&gt;call-process&lt;/code&gt; and &lt;code&gt;start-process&lt;/code&gt; when the &lt;var&gt;program&lt;/var&gt; argument is not an absolute file name.</source>
          <target state="translated">값 &lt;code&gt;exec-path&lt;/code&gt; 에서 사용되는 &lt;code&gt;call-process&lt;/code&gt; 및 &lt;code&gt;start-process&lt;/code&gt; 때 &lt;var&gt;program&lt;/var&gt; 인수 절대 파일명 아니다.</target>
        </trans-unit>
        <trans-unit id="30c13d6566147e5f7ff2d3b3fa785aa4e4166cab" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;global-mode-string&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;global-mode-string&lt;/code&gt; 값 .</target>
        </trans-unit>
        <trans-unit id="3d3a2b88654bd12f5337924840af3d4601a33e57" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;input-decode-map&lt;/code&gt; is usually set up automatically according to the terminal&amp;rsquo;s Terminfo or Termcap entry, but sometimes those need help from terminal-specific Lisp files. Emacs comes with terminal-specific files for many common terminals; their main purpose is to make entries in &lt;code&gt;input-decode-map&lt;/code&gt; beyond those that can be deduced from Termcap and Terminfo. See &lt;a href=&quot;terminal_002dspecific#Terminal_002dSpecific&quot;&gt;Terminal-Specific&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;input-decode-map&lt;/code&gt; 의 값 은 일반적으로 터미널의 Terminfo 또는 Termcap 항목에 따라 자동으로 설정되지만 때로는 터미널 별 Lisp 파일의 도움이 필요합니다. Emacs는 많은 일반 터미널에 대한 터미널 특정 파일과 함께 제공됩니다. 주요 목적은 Termcap 및 Terminfo에서 추론 할 수있는 항목을 넘어서 &lt;code&gt;input-decode-map&lt;/code&gt; 항목을 만드는 것입니다 . &lt;a href=&quot;terminal_002dspecific#Terminal_002dSpecific&quot;&gt;터미널 별을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="639680a63cdaad1e211652d86db8f9e826824dca" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;kill-ring-yank-pointer&lt;/code&gt; is always &lt;code&gt;eq&lt;/code&gt; to one of the links in the kill ring list. The element it identifies is the &lt;small&gt;CAR&lt;/small&gt; of that link. Kill commands, which change the kill ring, also set this variable to the value of &lt;code&gt;kill-ring&lt;/code&gt;. The effect is to rotate the ring so that the newly killed text is at the front.</source>
          <target state="translated">&lt;code&gt;kill-ring-yank-pointer&lt;/code&gt; 의 값 은 항상 킬 링 목록의 링크 중 하나에 &lt;code&gt;eq&lt;/code&gt; 입니다. 식별하는 요소 는 해당 링크 의 &lt;small&gt;CAR&lt;/small&gt; 입니다. 킬 링을 변경하는 킬 명령도이 변수를 &lt;code&gt;kill-ring&lt;/code&gt; 값으로 설정합니다 . 효과는 새로 죽인 텍스트가 맨 앞에 오도록 링을 회전하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b0adbfa26a0f5e416e962a7d1ef1be229d44f4eb" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;load-history&lt;/code&gt; may have one element whose &lt;small&gt;CAR&lt;/small&gt; is &lt;code&gt;nil&lt;/code&gt;. This element describes definitions made with &lt;code&gt;eval-buffer&lt;/code&gt; on a buffer that is not visiting a file.</source>
          <target state="translated">&lt;code&gt;load-history&lt;/code&gt; 값에는 &lt;small&gt;CAR&lt;/small&gt; 이 &lt;code&gt;nil&lt;/code&gt; 인 하나의 요소가있을 수 있습니다 . 이 요소 는 파일을 방문하지 않는 &lt;code&gt;eval-buffer&lt;/code&gt; 에서 eval-buffer 로 만든 정의를 설명 합니다.</target>
        </trans-unit>
        <trans-unit id="0c0cf4e96ec8565ee4c3ece809d9e7876396b3e6" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;mode-name&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mode-name&lt;/code&gt; 의 값 .</target>
        </trans-unit>
        <trans-unit id="01f5f8f11917d60cc33932b39ed53647b1e12540" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;pointm&lt;/code&gt; at the last redisplay time.</source>
          <target state="translated">마지막 다시 표시 시간 의 &lt;code&gt;pointm&lt;/code&gt; 값입니다 .</target>
        </trans-unit>
        <trans-unit id="15b964ce86184c0c14ba0a0fa6d8168b77cc4283" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;process-connection-type&lt;/code&gt; takes effect when &lt;code&gt;make-process&lt;/code&gt; or &lt;code&gt;start-process&lt;/code&gt; is called. So you can specify how to communicate with one subprocess by binding the variable around the call to these functions.</source>
          <target state="translated">&lt;code&gt;process-connection-type&lt;/code&gt; 의 값은 &lt;code&gt;make-process&lt;/code&gt; 또는 &lt;code&gt;start-process&lt;/code&gt; 가 호출 될 때 적용됩니다 . 따라서 이러한 함수에 대한 호출 주변의 변수를 바인딩하여 하나의 하위 프로세스와 통신하는 방법을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4917d7965a0a2a0eceea9527333fc312c3a1d97" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;track-mouse&lt;/code&gt; is that of the last form in &lt;var&gt;body&lt;/var&gt;. You should design &lt;var&gt;body&lt;/var&gt; to return when it sees the up-event that indicates the release of the button, or whatever kind of event means it is time to stop tracking.</source>
          <target state="translated">&lt;code&gt;track-mouse&lt;/code&gt; 의 값은 &lt;var&gt;body&lt;/var&gt; 의 마지막 형태 의 값입니다 . 버튼을 놓았 음을 나타내는 up-event 또는 어떤 종류의 이벤트가 추적을 중지 해야 하는지를 나타내는 이벤트를 볼 때 반환 할 &lt;var&gt;body&lt;/var&gt; 를 디자인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8e1d48548038a94283629f3b24139decfc462f06" translate="yes" xml:space="preserve">
          <source>The value of &lt;var&gt;geometry&lt;/var&gt; should be a list of the form &lt;code&gt;(&lt;var&gt;width&lt;/var&gt; &lt;var&gt;height&lt;/var&gt; &lt;var&gt;x&lt;/var&gt; &lt;var&gt;y&lt;/var&gt;)&lt;/code&gt;. &lt;var&gt;width&lt;/var&gt; and &lt;var&gt;height&lt;/var&gt; specify the width and height of the cropped image. If &lt;var&gt;x&lt;/var&gt; is a positive number it specifies the offset of the cropped area from the left of the original image, and if negative the offset from the right. If &lt;var&gt;y&lt;/var&gt; is a positive number it specifies the offset from the top of the original image, and if negative from the bottom. If &lt;var&gt;x&lt;/var&gt; or &lt;var&gt;y&lt;/var&gt; are &lt;code&gt;nil&lt;/code&gt; or unspecified the crop area will be centered on the original image.</source>
          <target state="translated">&lt;var&gt;geometry&lt;/var&gt; 값은 &lt;code&gt;(&lt;var&gt;width&lt;/var&gt; &lt;var&gt;height&lt;/var&gt; &lt;var&gt;x&lt;/var&gt; &lt;var&gt;y&lt;/var&gt;)&lt;/code&gt; 형식의 목록이어야합니다 . &lt;var&gt;width&lt;/var&gt; 와 &lt;var&gt;height&lt;/var&gt; 잘린 이미지의 너비 와 높이를 지정합니다. 경우에는 &lt;var&gt;x&lt;/var&gt; 가 원 화상의 좌측으로부터 잘라낸 영역의 오프셋을 지정하는 정수이며, 음수는 우측 오프셋. 경우 &lt;var&gt;y&lt;/var&gt; 는 양의 수이며 이는 원본 이미지의 상부로부터 오프셋을 지정하고, 아래에서 음수. 경우에는 &lt;var&gt;x&lt;/var&gt; 또는 &lt;var&gt;y&lt;/var&gt; 있다 &lt;code&gt;nil&lt;/code&gt; 또는 불특정 자르기 영역은 원본 이미지에 집중 될 것이다.</target>
        </trans-unit>
        <trans-unit id="f9a0aa42133a8566714c8da5cfb1ac14d08f0cbd" translate="yes" xml:space="preserve">
          <source>The value of &lt;var&gt;list&lt;/var&gt; specifies the objects to ask questions about. It should be either a list of objects or a generator function. If it is a function, it should expect no arguments, and should return either the next object to ask about, or &lt;code&gt;nil&lt;/code&gt;, meaning to stop asking questions.</source>
          <target state="translated">&lt;var&gt;list&lt;/var&gt; 의 값은 질문 할 개체를 지정합니다. 객체 목록이거나 생성기 함수 여야합니다. 함수 인 경우 인수를 기대하지 않아야하며 질문 할 다음 객체를 반환하거나 질문을 중지하는 것을 의미하는 &lt;code&gt;nil&lt;/code&gt; 을 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="292f71c1213df0a0c0f3e562c978b3b0e7d59643" translate="yes" xml:space="preserve">
          <source>The value of &lt;var&gt;package&lt;/var&gt; needs to be unique and it needs to match the &lt;var&gt;package&lt;/var&gt; value appearing in the &lt;code&gt;:package-version&lt;/code&gt; keyword. Since the user might see the value in an error message, a good choice is the official name of the package, such as MH-E or Gnus.</source>
          <target state="translated">&lt;var&gt;package&lt;/var&gt; 값은 고유해야 하며 &lt;code&gt;:package-version&lt;/code&gt; 키워드에 나타나는 &lt;var&gt;package&lt;/var&gt; 값 과 일치해야 합니다. 사용자가 오류 메시지에서 값을 볼 수 있으므로 MH-E 또는 Gnus와 같은 패키지의 공식 이름을 선택하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="fb4c37d36e42ca7bde0fbebe3ad9e40de14d67b3" translate="yes" xml:space="preserve">
          <source>The value of &lt;var&gt;persistent&lt;/var&gt; is the value specified for &lt;var&gt;window&lt;/var&gt; with the last successful invocation of &lt;code&gt;set-window-scroll-bars&lt;/code&gt;, &lt;code&gt;nil&lt;/code&gt; if there never was one.</source>
          <target state="translated">&lt;var&gt;persistent&lt;/var&gt; 값 은 &lt;code&gt;set-window-scroll-bars&lt;/code&gt; 를 마지막으로 성공적으로 호출 한 &lt;var&gt;window&lt;/var&gt; 지정된 값이며 , &lt;code&gt;nil&lt;/code&gt; 경우 nil 입니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
