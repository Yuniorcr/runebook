<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="elisp">
    <body>
      <group id="elisp">
        <trans-unit id="ded2b381f768b0426ee02fc11e7b1ea526d86382" translate="yes" xml:space="preserve">
          <source>M-p</source>
          <target state="translated">M-p</target>
        </trans-unit>
        <trans-unit id="0f8046567a7777233033e7c62fcbaaf077eb077a" translate="yes" xml:space="preserve">
          <source>M-r</source>
          <target state="translated">M-r</target>
        </trans-unit>
        <trans-unit id="0006025ee1ee308621c9836f080cfbad730b00dd" translate="yes" xml:space="preserve">
          <source>M-s</source>
          <target state="translated">M-s</target>
        </trans-unit>
        <trans-unit id="e2dbd97a24cfd42feafe4155928e5e36e05f30f3" translate="yes" xml:space="preserve">
          <source>M-v</source>
          <target state="translated">M-v</target>
        </trans-unit>
        <trans-unit id="5516e58102890d870825312fe7edb083af235de4" translate="yes" xml:space="preserve">
          <source>M-x</source>
          <target state="translated">M-x</target>
        </trans-unit>
        <trans-unit id="e96ee2840300f270b45095c2f0ec40521a00cde5" translate="yes" xml:space="preserve">
          <source>M-x &lt;var&gt;command&lt;/var&gt;</source>
          <target state="translated">M-x &lt;var&gt;command&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="30b1c3d10bd4ea36dfe161af71f9b59cff94dfbf" translate="yes" xml:space="preserve">
          <source>M-x &lt;var&gt;command&lt;/var&gt;RET</source>
          <target state="translated">M-x &lt;var&gt;command&lt;/var&gt; RET</target>
        </trans-unit>
        <trans-unit id="c8f918be9ef0d86eff9e8b262b173a76afb5d823" translate="yes" xml:space="preserve">
          <source>M-x apropos RET x-pointer RET</source>
          <target state="translated">M-x apropos RET x-pointer RET</target>
        </trans-unit>
        <trans-unit id="19d036c0bdece7df51bbb22b25a57a912bb781fc" translate="yes" xml:space="preserve">
          <source>M-x customize</source>
          <target state="translated">M-x customize</target>
        </trans-unit>
        <trans-unit id="350cf2e68d92268174ae9d7178734cce54adaa8c" translate="yes" xml:space="preserve">
          <source>M-x describe-categories RET</source>
          <target state="translated">M-x describe-categories RET</target>
        </trans-unit>
        <trans-unit id="28a7266291890a298f219fa24bf612c876e68a3a" translate="yes" xml:space="preserve">
          <source>M-x dired-default-directory-on-left</source>
          <target state="translated">M-x dired-default-directory-on-left</target>
        </trans-unit>
        <trans-unit id="d0dbe2e240aeb6f1a78c981c88c230cc06b9fce7" translate="yes" xml:space="preserve">
          <source>M-x edebug-all-defs</source>
          <target state="translated">M-x edebug-all-defs</target>
        </trans-unit>
        <trans-unit id="c71a2298fbf3e6b350d972a5f6758ef0c7f37945" translate="yes" xml:space="preserve">
          <source>M-x edebug-all-forms</source>
          <target state="translated">M-x edebug-all-forms</target>
        </trans-unit>
        <trans-unit id="66031655733aef9ceba93288111a34d690630332" translate="yes" xml:space="preserve">
          <source>M-x edebug-backtrace-hide-instrumentation</source>
          <target state="translated">M-x edebug-backtrace-hide-instrumentation</target>
        </trans-unit>
        <trans-unit id="f849db42cc80a644b891cceb796496aea5a33446" translate="yes" xml:space="preserve">
          <source>M-x edebug-backtrace-show-instrumentation</source>
          <target state="translated">M-x edebug-backtrace-show-instrumentation</target>
        </trans-unit>
        <trans-unit id="0e0239d280915da82047b3562e0edc1ef7e13f61" translate="yes" xml:space="preserve">
          <source>M-x edebug-eval-top-level-form</source>
          <target state="translated">M-x edebug-eval-top-level-form</target>
        </trans-unit>
        <trans-unit id="95fa4b4069fcd95b6d5ac0204ea4c9cff0ee6f75" translate="yes" xml:space="preserve">
          <source>M-x edit-tab-stops</source>
          <target state="translated">M-x edit-tab-stops</target>
        </trans-unit>
        <trans-unit id="924625b2d7b939bdd69c369a8e0e7552d4621132" translate="yes" xml:space="preserve">
          <source>M-x list-colors-display</source>
          <target state="translated">M-x list-colors-display</target>
        </trans-unit>
        <trans-unit id="2d76ea9e63fcbb859b33f48edd7feb794a1730b1" translate="yes" xml:space="preserve">
          <source>M-x list-processes</source>
          <target state="translated">M-x list-processes</target>
        </trans-unit>
        <trans-unit id="84edc9f7052f2c9a7f036d7890685dfe8db762ec" translate="yes" xml:space="preserve">
          <source>M-x load-library RET package-x RET</source>
          <target state="translated">M-x load-library RET package-x RET</target>
        </trans-unit>
        <trans-unit id="b609619759aa9b92d26776cb6f14ab4bcfcc31de" translate="yes" xml:space="preserve">
          <source>M-x profiler-&amp;hellip;</source>
          <target state="translated">M-x profiler-&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="0773bdccb110b28fb0a67898b66d8dd11444e9cc" translate="yes" xml:space="preserve">
          <source>M-x profiler-report</source>
          <target state="translated">M-x profiler-report</target>
        </trans-unit>
        <trans-unit id="4f21aa5941ccf75086060a4caa6ef135d1f402a8" translate="yes" xml:space="preserve">
          <source>M-x profiler-start</source>
          <target state="translated">M-x profiler-start</target>
        </trans-unit>
        <trans-unit id="7f9fd75200c3ba11f87c5df3770346f3beaa6c06" translate="yes" xml:space="preserve">
          <source>M-x profiler-stop</source>
          <target state="translated">M-x profiler-stop</target>
        </trans-unit>
        <trans-unit id="e1f1559513ee5a73bed6212288039c357856e5b7" translate="yes" xml:space="preserve">
          <source>M-x python-mode</source>
          <target state="translated">M-x python-mode</target>
        </trans-unit>
        <trans-unit id="9a178593a35bbea7f02403c42d651edd7a1bdd3d" translate="yes" xml:space="preserve">
          <source>M-x re-builder</source>
          <target state="translated">M-x re-builder</target>
        </trans-unit>
        <trans-unit id="02844767c038cdd2dda139c1d2eab250404388db" translate="yes" xml:space="preserve">
          <source>M-x report-emacs-bug</source>
          <target state="translated">M-x report-emacs-bug</target>
        </trans-unit>
        <trans-unit id="4a8d44402484cf1af704bb5188c0b2f67fd9deae" translate="yes" xml:space="preserve">
          <source>M-x serial-term</source>
          <target state="translated">M-x serial-term</target>
        </trans-unit>
        <trans-unit id="d262f66141e61698a64505a1167b86f852cd6537" translate="yes" xml:space="preserve">
          <source>M-x set-visited-file-name</source>
          <target state="translated">M-x set-visited-file-name</target>
        </trans-unit>
        <trans-unit id="ddd4cde942039a43aa69d7aaf7874a8689013014" translate="yes" xml:space="preserve">
          <source>M-x shell</source>
          <target state="translated">M-x shell</target>
        </trans-unit>
        <trans-unit id="aeb29959992cb9268370a1bd309d2ce9f465185c" translate="yes" xml:space="preserve">
          <source>M-x testcover-mark-all</source>
          <target state="translated">M-x testcover-mark-all</target>
        </trans-unit>
        <trans-unit id="e8f70ba057d5e0dc5100fc76829c8002a8f06257" translate="yes" xml:space="preserve">
          <source>M-x testcover-next-mark</source>
          <target state="translated">M-x testcover-next-mark</target>
        </trans-unit>
        <trans-unit id="91f5f461f2c3a31e68b3789ab862a2b579739b85" translate="yes" xml:space="preserve">
          <source>M-x testcover-start RET&lt;var&gt;file&lt;/var&gt;RET</source>
          <target state="translated">M-x testcover-start RET &lt;var&gt;file&lt;/var&gt; RET</target>
        </trans-unit>
        <trans-unit id="0cb1249115b25aa2690a25b8910733c67b4a92a4" translate="yes" xml:space="preserve">
          <source>M-x untabify</source>
          <target state="translated">M-x untabify</target>
        </trans-unit>
        <trans-unit id="8938bda20b679e9984362cfe3b0025e2957609de" translate="yes" xml:space="preserve">
          <source>M-x update-directory-autoloads</source>
          <target state="translated">M-x update-directory-autoloads</target>
        </trans-unit>
        <trans-unit id="17a3a65ded9cf97168d2d48abac758964baf3233" translate="yes" xml:space="preserve">
          <source>M-x update-file-autoloads</source>
          <target state="translated">M-x update-file-autoloads</target>
        </trans-unit>
        <trans-unit id="157b9065ca9092b93a2cd86b2065b6f97cb3c423" translate="yes" xml:space="preserve">
          <source>M-x widget-browse RET binary-tree-of-string RET</source>
          <target state="translated">M-x widget-browse RET binary-tree-of-string RET</target>
        </trans-unit>
        <trans-unit id="3aa424326e8c65a4310c522189aff3bdb49730f9" translate="yes" xml:space="preserve">
          <source>M-xelp-instrument-listRET nil RET</source>
          <target state="translated">M-xelp-instrument-listRET nil RET</target>
        </trans-unit>
        <trans-unit id="d61a0439c16b301031a2c72fbbf40aec0781473a" translate="yes" xml:space="preserve">
          <source>M-xelp-results</source>
          <target state="translated">M-xelp-results</target>
        </trans-unit>
        <trans-unit id="4cb98f7867f1180986c1b84ef1785ff0b2c4dc15" translate="yes" xml:space="preserve">
          <source>M-xlist-buffers</source>
          <target state="translated">M-xlist-buffers</target>
        </trans-unit>
        <trans-unit id="05b684cd2cc4407a760fc4776a9afa8ac8eaddb7" translate="yes" xml:space="preserve">
          <source>M-xlist-tags</source>
          <target state="translated">M-xlist-tags</target>
        </trans-unit>
        <trans-unit id="7555a33395fef6db20d121fb58c3221aa124e48c" translate="yes" xml:space="preserve">
          <source>M-y</source>
          <target state="translated">M-y</target>
        </trans-unit>
        <trans-unit id="db42242da8c9daf4dc32a3e8f6a8c77ab461abee" translate="yes" xml:space="preserve">
          <source>MENU-BAR</source>
          <target state="translated">MENU-BAR</target>
        </trans-unit>
        <trans-unit id="40bb78ac4a8f75b73057a2a259dcfa335c88dad4" translate="yes" xml:space="preserve">
          <source>META</source>
          <target state="translated">META</target>
        </trans-unit>
        <trans-unit id="2d4aa5a5271bf55bf5139dda546f0f30ba06a6bd" translate="yes" xml:space="preserve">
          <source>MIME</source>
          <target state="translated">MIME</target>
        </trans-unit>
        <trans-unit id="240ac4da20e27f25d9defe42a63eca4461adbce9" translate="yes" xml:space="preserve">
          <source>MS-DOS and MS-Windows systems usually lack the standard Unix program &lt;code&gt;ls&lt;/code&gt;, so this function emulates the standard Unix program &lt;code&gt;ls&lt;/code&gt; with Lisp code.</source>
          <target state="translated">MS-DOS and MS-Windows systems usually lack the standard Unix program &lt;code&gt;ls&lt;/code&gt; , so this function emulates the standard Unix program &lt;code&gt;ls&lt;/code&gt; with Lisp code.</target>
        </trans-unit>
        <trans-unit id="a6a56e5df064567806bfd2d02ec60d53d177da70" translate="yes" xml:space="preserve">
          <source>MS-DOS doesn&amp;rsquo;t support asynchronous subprocesses, so this option doesn&amp;rsquo;t work there.</source>
          <target state="translated">MS-DOS doesn&amp;rsquo;t support asynchronous subprocesses, so this option doesn&amp;rsquo;t work there.</target>
        </trans-unit>
        <trans-unit id="660bf78961f4ec6bd8bd8b37a3b0b2769db2b14a" translate="yes" xml:space="preserve">
          <source>Macro</source>
          <target state="translated">Macro</target>
        </trans-unit>
        <trans-unit id="0d2da2eb949e2df3a96a434a98613935cdfa18a4" translate="yes" xml:space="preserve">
          <source>Macro Type</source>
          <target state="translated">Macro Type</target>
        </trans-unit>
        <trans-unit id="3764e4ae50932da915ec9a84fd2ba1b1c33188ce" translate="yes" xml:space="preserve">
          <source>Macro calls (see &lt;a href=&quot;macros#Macros&quot;&gt;Macros&lt;/a&gt;).</source>
          <target state="translated">매크로 호출 ( &lt;a href=&quot;macros#Macros&quot;&gt;매크로&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="730c77b761075cf87c04f675fec25c96f12254c7" translate="yes" xml:space="preserve">
          <source>Macro expansion can have counterintuitive consequences. This section describes some important consequences that can lead to trouble, and rules to follow to avoid trouble.</source>
          <target state="translated">매크로 확장은 직관에 반하는 결과를 초래할 수 있습니다. 이 섹션에서는 문제를 일으킬 수있는 몇 가지 중요한 결과와 문제를 방지하기 위해 따라야 할 규칙에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="7c8148b5f3e72ae81e30a87c1414a699978cee33" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;1value&lt;/strong&gt;&lt;em&gt;form&lt;/em&gt;</source>
          <target state="translated">매크로 : 1 &lt;strong&gt;값 &lt;/strong&gt;&lt;em&gt;형식&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f625904d011437c920c24217d1112932e75fdede" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;EMACS_LIMB_MAX&lt;/strong&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;EMACS_LIMB_MAX&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f63e91ed8761158e2824094f3c035978e33f0b75" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;add-function&lt;/strong&gt;&lt;em&gt;where place function &amp;amp;optional props&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;em&gt;위치 기능 및 옵션 소품 &lt;/em&gt;&lt;strong&gt;추가 기능&lt;/strong&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5429d225c6285d485886a63d9a654b44fd9af85a" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;cl-defgeneric&lt;/strong&gt;&lt;em&gt;name arguments [documentation] [options-and-methods&amp;hellip;] &amp;amp;rest body&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;cl-defgeneric &lt;/strong&gt;&lt;em&gt;이름 인수 [문서] [옵션 및 방법&amp;hellip;] &amp;amp; rest body&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ba5cedae4a4b306427387f90edd4dbd185e02578" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;cl-defmethod&lt;/strong&gt;&lt;em&gt;name [qualifier] arguments [&amp;amp;context (expr spec)&amp;hellip;] &amp;amp;rest [docstring] body&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;cl-defmethod &lt;/strong&gt;&lt;em&gt;name [qualifier] arguments [&amp;amp; context (expr spec)&amp;hellip;] &amp;amp; rest [docstring] body&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1ff2b909c891d19da7650f8ccd70d4ff20d5f0ef" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;combine-after-change-calls&lt;/strong&gt;&lt;em&gt;body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;변경 후 호출 결합 &lt;/strong&gt;&lt;em&gt;본문&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6ee51599c974e6734d6444e666498d94c6309037" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;combine-change-calls&lt;/strong&gt;&lt;em&gt;beg end body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;결합 변경 호출이 &lt;/strong&gt;&lt;em&gt;최종 본문을 요청합니다&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3aee740831df3fe36c5e3627bd95688debd9b10c" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;condition-case-unless-debug&lt;/strong&gt;&lt;em&gt;var protected-form handlers&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;condition-case-unless-debug &lt;/strong&gt;&lt;em&gt;var 보호 양식 핸들러&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="be46ac442c6b283fe5303544430db1733ede80cf" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;declare-function&lt;/strong&gt;&lt;em&gt;function file &amp;amp;optional arglist fileonly&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;함수 선언 &lt;/strong&gt;&lt;em&gt;기능 파일 및 선택적 arglist 파일 전용&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="62a5106ba44b52792efba46fd9abcd6f50d2a690" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;declare&lt;/strong&gt;&lt;em&gt;specs&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;em&gt;사양 &lt;/em&gt;&lt;strong&gt;선언 &lt;/strong&gt;&lt;em&gt;&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="aad917e7e24305c69cc7b616287145940c7bc611" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;def-edebug-spec&lt;/strong&gt;&lt;em&gt;macro specification&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;def-edebug-spec &lt;/strong&gt;&lt;em&gt;매크로 사양&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e8850ae7654fdd0f9e7e3643b836d299119c8eb3" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;defcustom&lt;/strong&gt;&lt;em&gt;option standard doc [keyword value]&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;defcustom &lt;/strong&gt;&lt;em&gt;옵션 표준 문서 [키워드 값]&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5434cd21483dbb5ef69be871541753221bd178a5" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;defface&lt;/strong&gt;&lt;em&gt;face spec doc [keyword value]&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;defface &lt;/strong&gt;&lt;em&gt;face spec doc [키워드 값]&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="14c7fabc7b52a8375cc5c9e142c3ac122d2ea4bc" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;defgroup&lt;/strong&gt;&lt;em&gt;group members doc [keyword value]&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;defgroup &lt;/strong&gt;&lt;em&gt;그룹 구성원 문서 [키워드 값]&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="28b55593ba483070425de7736987bf774bd2c491" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;defimage&lt;/strong&gt;&lt;em&gt;symbol specs &amp;amp;optional doc&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;defimage &lt;/strong&gt;&lt;em&gt;기호 사양 및 선택적 문서&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fea6bef8b59da7c79bbd75395190d7484736ecf9" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;define-advice&lt;/strong&gt;&lt;em&gt;symbol (where lambda-list &amp;amp;optional name depth) &amp;amp;rest body&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;정의 권고 &lt;/strong&gt;&lt;em&gt;기호 (여기서 람다 목록 및 선택적 이름 깊이) 및 나머지 본문&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="70852342716d3e0bca8b4f3d79c1ec5991f6b9cc" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;define-alternatives&lt;/strong&gt;&lt;em&gt;command &amp;amp;rest customizations&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;define-alternatives &lt;/strong&gt;&lt;em&gt;명령 및 나머지 사용자 정의&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="af424b3d2ee378903109c9532c12c3d915726f60" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;define-derived-mode&lt;/strong&gt;&lt;em&gt;variant parent name docstring keyword-args&amp;hellip; body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;정의 파생 모드 &lt;/strong&gt;&lt;em&gt;변형 상위 이름 docstring keyword-args&amp;hellip; body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d039443b2fcf2ccb94276b2881ba59ab7c4bef6e" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;define-generic-mode&lt;/strong&gt;&lt;em&gt;mode comment-list keyword-list font-lock-list auto-mode-list function-list &amp;amp;optional docstring&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;define-generic-mode &lt;/strong&gt;&lt;em&gt;mode comment-list keyword-list font-lock-list auto-mode-list function-list &amp;amp; optional docstring&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3be7a42eb17b3b478f941dfaad3f2a091b3d9de0" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;define-globalized-minor-mode&lt;/strong&gt;&lt;em&gt;global-mode mode turn-on keyword-args&amp;hellip; body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;define-globalized-minor-mode &lt;/strong&gt;&lt;em&gt;전역 모드 모드 turn-on keyword-args&amp;hellip; body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c3698aa5f5a4cf22d04e63dba4fd63eeab2b198c" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;define-inline&lt;/strong&gt;&lt;em&gt;name args [doc] [declare] body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;정의 인라인 &lt;/strong&gt;&lt;em&gt;이름 args [doc] [declare] body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1872fe945d43990f77596fefa545da1cad14ecf2" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;define-minor-mode&lt;/strong&gt;&lt;em&gt;mode doc [init-value [lighter [keymap]]] keyword-args&amp;hellip; body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;부 모드 &lt;/strong&gt;&lt;em&gt;모드 &lt;/em&gt;&lt;strong&gt;정의 &lt;/strong&gt;&lt;em&gt;문서 [init-value [lighter [keymap]]] keyword-args&amp;hellip; body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e428f2f8e85f45dc22b5c0ef48e7d972c7378dba" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;define-obsolete-face-alias&lt;/strong&gt;&lt;em&gt;obsolete-face current-face when&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;쓸모없는 얼굴 별칭 정의 쓸모없는 &lt;/strong&gt;&lt;em&gt;얼굴 현재 얼굴&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="803af6ea30a01f534dc197a816a8b6feeabe7985" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;define-obsolete-function-alias&lt;/strong&gt;&lt;em&gt;obsolete-name current-name when &amp;amp;optional doc&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;define-obsolete-function-alias &lt;/strong&gt;&lt;em&gt;obsolete-name current-name when &amp;amp; optional doc&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c1c5b6a54e8e1d18babd8fbf3277042db07db8a8" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;define-obsolete-variable-alias&lt;/strong&gt;&lt;em&gt;obsolete-name current-name &amp;amp;optional when docstring&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;폐기 된 변수 별명 정의 &lt;/strong&gt;&lt;em&gt;폐기 된 이름 현재 이름 및 독 스트링시 선택 사항&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="10f5376be352b9daee65a34b48f0eb2a91bc607c" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;defmacro&lt;/strong&gt;&lt;em&gt;name args [doc] [declare] body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;defmacro &lt;/strong&gt;&lt;em&gt;name args [doc] [declare] body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="78c0fc24e6b16b98abe1b0908482cec19956ca6f" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;defsubst&lt;/strong&gt;&lt;em&gt;name args [doc] [declare] [interactive] body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;defsubst &lt;/strong&gt;&lt;em&gt;name args [doc] [declare] [interactive] body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1683d10fb7854b9d19dee990d4fa2a5c7aa5855c" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;deftheme&lt;/strong&gt;&lt;em&gt;theme &amp;amp;optional doc&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;deftheme &lt;/strong&gt;&lt;em&gt;테마 및 선택적 문서&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8f549c138328cc6f82aa82edd990d79c318eb798" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;defun&lt;/strong&gt;&lt;em&gt;name args [doc] [declare] [interactive] body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;defun &lt;/strong&gt;&lt;em&gt;name args [doc] [declare] [interactive] body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="10c945e44b82a451a5291eaa330f70caa9d10af2" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;defvar-local&lt;/strong&gt;&lt;em&gt;variable value &amp;amp;optional docstring&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;defvar-local &lt;/strong&gt;&lt;em&gt;변수 값 및 선택적 docstring&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cc1f8d335ca6f3d1108310f49f1d7c79312c2310" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;delay-mode-hooks&lt;/strong&gt;&lt;em&gt;body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;지연 모드 후크 &lt;/strong&gt;&lt;em&gt;본문&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="236c5615e3d9ad7c6a4ecbd45a98af3f3547666f" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;dolist-with-progress-reporter&lt;/strong&gt;&lt;em&gt;(var count [result]) reporter-or-message body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;dolist-with-progress-reporter &lt;/strong&gt;&lt;em&gt;(var count [result]) reporter-or-message body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="af38a7273fecb69f9c319a26123467a4b36e125d" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;dolist&lt;/strong&gt;&lt;em&gt;(var list [result]) body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;dolist &lt;/strong&gt;&lt;em&gt;(var list [result]) 본문&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f09315db5afa839072a62fbc1535685142261f35" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;dotimes-with-progress-reporter&lt;/strong&gt;&lt;em&gt;(var count [result]) reporter-or-message body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;dotimes-with-progress-reporter &lt;/strong&gt;&lt;em&gt;(var count [result]) reporter-or-message body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7f92ffa9680e321f5b7958eb9df3da33cc00a96e" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;dotimes&lt;/strong&gt;&lt;em&gt;(var count [result]) body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;dotimes &lt;/strong&gt;&lt;em&gt;(var count [result]) 본문&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="27132dd2125d6a24d297f0e928ce24fd5c66c2a4" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;easy-menu-define&lt;/strong&gt;&lt;em&gt;symbol maps doc menu&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;쉬운 메뉴 정의 &lt;/strong&gt;&lt;em&gt;기호 맵 문서 메뉴&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4202975359e6a5a35e94aebc824c1980bfa133ab" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;edebug-tracing&lt;/strong&gt;&lt;em&gt;string body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;edebug-tracing &lt;/strong&gt;&lt;em&gt;string body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="97209372ca87135e65cd9c81713566e0e5ffbbed" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;file-name-quote&lt;/strong&gt;&lt;em&gt;name&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;파일 이름 인용 &lt;/strong&gt;&lt;em&gt;이름&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d492c007d3e41ed8529a79c7de06f64a383b0bb4" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;file-name-quoted-p&lt;/strong&gt;&lt;em&gt;name&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;파일 이름 인용 p &lt;/strong&gt;&lt;em&gt;이름&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="84eef64536eebdfb99700969216aebc1568b1a93" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;file-name-unquote&lt;/strong&gt;&lt;em&gt;name&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;파일 이름 인용 해제 &lt;/strong&gt;&lt;em&gt;이름&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="726f23b904d3162d0b6b2ce258aedc6f34085b01" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;gv-define-expander&lt;/strong&gt;&lt;em&gt;name handler&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;gv-define-expander &lt;/strong&gt;&lt;em&gt;이름 핸들러&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3e8e8e6f9fb8ae64c4b81b0efb77b3aec46b1848" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;gv-define-setter&lt;/strong&gt;&lt;em&gt;name arglist &amp;amp;rest body&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;gv-define-setter &lt;/strong&gt;&lt;em&gt;이름 arglist &amp;amp; rest body&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1ba4267fb86a2133c14e3991e850bf82e933e6cf" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;gv-define-simple-setter&lt;/strong&gt;&lt;em&gt;name setter &amp;amp;optional fix-return&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;gv-define-simple-setter &lt;/strong&gt;&lt;em&gt;이름 설정 기 &amp;amp; optional fix-return&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fe36114bc819fefed7ef2aa455dfe1201e1f3794" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;gv-letplace&lt;/strong&gt;&lt;em&gt;(getter setter) place &amp;amp;rest body&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;gv-letplace &lt;/strong&gt;&lt;em&gt;(getter setter) place &amp;amp; rest body&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4d988bb7298849df77bbbf913cc1608cf1c65a48" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;ignore-error&lt;/strong&gt;&lt;em&gt;condition body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;오류 &lt;/strong&gt;&lt;em&gt;상태 본문 &lt;/em&gt;&lt;strong&gt;무시 &lt;/strong&gt;&lt;em&gt;&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c0a70bba890a42f68ebbfdbefb8d53b65ab046ba" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;ignore-errors&lt;/strong&gt;&lt;em&gt;body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;오류 &lt;/strong&gt;&lt;em&gt;본문 &lt;/em&gt;&lt;strong&gt;무시 &lt;/strong&gt;&lt;em&gt;&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8d8cf7a6718df181f54afa400b67ca2ca8fa1da3" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;inline-const-p&lt;/strong&gt;&lt;em&gt;expression&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;inline-const-p &lt;/strong&gt;&lt;em&gt;표현식&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a2f83ce40aaee4b4c13e471e1088895be676b70e" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;inline-const-val&lt;/strong&gt;&lt;em&gt;expression&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;inline-const-val &lt;/strong&gt;&lt;em&gt;표현식&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="53a8c04b7bc095c6f92dc2e1ef62aceb2230f983" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;inline-error&lt;/strong&gt;&lt;em&gt;format &amp;amp;rest args&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;인라인 오류 &lt;/strong&gt;&lt;em&gt;형식 및 나머지 인수&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="18c258c00d0a0eefa18864e32e22a05027f102ed" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;inline-letevals&lt;/strong&gt;&lt;em&gt;(bindings&amp;hellip;) body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;inline-letevals &lt;/strong&gt;&lt;em&gt;(bindings&amp;hellip;) body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7ea22905659127e33e1bae1fa9ee88c436a06ea8" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;inline-quote&lt;/strong&gt;&lt;em&gt;expression&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;인라인 따옴표 &lt;/strong&gt;&lt;em&gt;식&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="591cc65dde8d823c972143bbff5028af79cbb9db" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;iter-defun&lt;/strong&gt;&lt;em&gt;name args [doc] [declare] [interactive] body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;iter-defun &lt;/strong&gt;&lt;em&gt;name args [doc] [declare] [interactive] body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5dec5c51dc2ec952f84f4bbfed169751066042a1" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;iter-do&lt;/strong&gt;&lt;em&gt;(var iterator) body &amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;iter-do &lt;/strong&gt;&lt;em&gt;(var iterator) 본문&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6af415e6cbf9f96bba0dce565e09bab755f1b4a1" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;iter-lambda&lt;/strong&gt;&lt;em&gt;args [doc] [interactive] body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;iter-lambda &lt;/strong&gt;&lt;em&gt;args [doc] [interactive] body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d034239c1317860ddb076eb18efff19e3bf9b86f" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;iter-yield-from&lt;/strong&gt;&lt;em&gt;iterator&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;iter-yield-from &lt;/strong&gt;&lt;em&gt;iterator&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8295211938d4a3f738add01d06599196ba528680" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;iter-yield&lt;/strong&gt;&lt;em&gt;value&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;반복 수익률 &lt;/strong&gt;&lt;em&gt;값&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fb4abdbc2718878523fc62e401ee9bbb454e720e" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;lambda&lt;/strong&gt;&lt;em&gt;args [doc] [interactive] body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;lambda &lt;/strong&gt;&lt;em&gt;args [doc] [interactive] body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="97e12fdbcb9c7d29cfa4fb4a4d5bebd3b572b4be" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;lazy-completion-table&lt;/strong&gt;&lt;em&gt;var fun&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;lazy-completion-table &lt;/strong&gt;&lt;em&gt;var fun&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a13b390be25a1fbc366c265b47e90db671786c62" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;let-alist&lt;/strong&gt;&lt;em&gt;alist body&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;let-alist &lt;/strong&gt;&lt;em&gt;alist body&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0ff539998c76c30f04c81c659cfe2406d40230c9" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;make-help-screen&lt;/strong&gt;&lt;em&gt;fname help-line help-text help-map&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;make-help-screen &lt;/strong&gt;&lt;em&gt;fname help-line help-text help-map&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bcb098a03ed9e790b3a8274d37d20c47f9829b78" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;minibuffer-with-setup-hook&lt;/strong&gt;&lt;em&gt;function &amp;amp;rest body&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;설치 후크 &lt;/strong&gt;&lt;em&gt;기능이있는 &lt;/em&gt;&lt;strong&gt;미니 버퍼 &lt;/strong&gt;&lt;em&gt;및 본체&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8438b00f04bfd18b4b0ae35e53a7cc991b2b59c9" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;noreturn&lt;/strong&gt;&lt;em&gt;form&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;noreturn &lt;/strong&gt;&lt;em&gt;양식&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cec782422ca74e562fbd1f338919db0b374e18fc" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;pcase-defmacro&lt;/strong&gt;&lt;em&gt;name args [doc] &amp;amp;rest body&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;pcase-defmacro &lt;/strong&gt;&lt;em&gt;name args [doc] &amp;amp; rest body&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cbac1c3a887c3fb24e6cc7cf54c7c2199087fe99" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;pcase-dolist&lt;/strong&gt;&lt;em&gt;(pattern list) body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;pcase-dolist &lt;/strong&gt;&lt;em&gt;(패턴 목록) 본문&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0c05dbc3c6db6b261f36f043c6e80c8f33eda5de" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;pcase-let*&lt;/strong&gt;&lt;em&gt;bindings body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;pcase-let * &lt;/strong&gt;&lt;em&gt;바인딩 본문&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bb51fe5b0cf3705a47723c876b1e4bcd04dc577a" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;pcase-let&lt;/strong&gt;&lt;em&gt;bindings body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;pcase-let &lt;/strong&gt;&lt;em&gt;바인딩 본문&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ca87b97e541c841df38930296559cb00658e2768" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;pcase&lt;/strong&gt;&lt;em&gt;expression &amp;amp;rest clauses&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;pcase &lt;/strong&gt;&lt;em&gt;표현식 &amp;amp; rest 절&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="983e88ae1faa1be0650589312d5418fdde60f1bc" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;pop&lt;/strong&gt;&lt;em&gt;listname&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;팝 &lt;/strong&gt;&lt;em&gt;listname&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8e0e2b6a982aeda0e4decaf96d35ea59a59bd598" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;provide-theme&lt;/strong&gt;&lt;em&gt;theme&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;테마 제공 &lt;/strong&gt;&lt;em&gt;테마&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1dc602f484a77596e515278730a111ba18108235" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;push&lt;/strong&gt;&lt;em&gt;element listname&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;em&gt;요소 목록 이름 &lt;/em&gt;&lt;strong&gt;푸시&lt;/strong&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f156a8123bbcf74aa52f2b693a342c402f146879" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;remove-function&lt;/strong&gt;&lt;em&gt;place function&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;기능 제거 &lt;/strong&gt;&lt;em&gt;기능&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dade05721b4bb5b2388ba9e36428808b0bd35b85" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;rx-define&lt;/strong&gt;&lt;em&gt;name [arglist] rx-form&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;rx-define &lt;/strong&gt;&lt;em&gt;name [arglist] rx-form&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="96bddb173e4fc87b0212f01a02bc2ff46662fd79" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;rx-let-eval&lt;/strong&gt;&lt;em&gt;bindings body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;rx-let-eval &lt;/strong&gt;&lt;em&gt;바인딩 본문&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0f690b0183cee377b178ae7b310b55bed43dc046" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;rx-let&lt;/strong&gt;&lt;em&gt;(bindings&amp;hellip;) body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;rx-let &lt;/strong&gt;&lt;em&gt;(bindings&amp;hellip;) body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6b7d03766c09f7e22083ae5f1e5632dbe96a4075" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;rx&lt;/strong&gt;&lt;em&gt;rx-expr&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;rx &lt;/strong&gt;&lt;em&gt;rx-expr&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7e38445717db19d10c7b2ff0da1e3c8e5606a741" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;save-mark-and-excursion&lt;/strong&gt;&lt;em&gt;body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;저장 표시 및 이동 &lt;/strong&gt;&lt;em&gt;본문&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d9f08975e9fff445dfb403167bb2325ccb174e76" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;save-match-data&lt;/strong&gt;&lt;em&gt;body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;일치 데이터 &lt;/strong&gt;&lt;em&gt;본문 &lt;/em&gt;&lt;strong&gt;저장 &lt;/strong&gt;&lt;em&gt;&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="92793bf9d32a9540658805cb43a3ae0efa7f3128" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;save-selected-window&lt;/strong&gt;&lt;em&gt;forms&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;선택한 창 &lt;/strong&gt;&lt;em&gt;양식 &lt;/em&gt;&lt;strong&gt;저장 &lt;/strong&gt;&lt;em&gt;&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e56a36e57644762b26c7a8043ad96444679ee21f" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;save-window-excursion&lt;/strong&gt;&lt;em&gt;forms&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;저장 창 제외 &lt;/strong&gt;&lt;em&gt;양식&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="12a277b9203d5ab428dff62199f053203e4f9360" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;seq-doseq&lt;/strong&gt;&lt;em&gt;(var sequence) body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;seq-doseq &lt;/strong&gt;&lt;em&gt;(var 시퀀스) 본문&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b835674eb567909d999b1d3adb5b36f56b21eb76" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;seq-let&lt;/strong&gt;&lt;em&gt;var-sequence val-sequence body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;seq-let &lt;/strong&gt;&lt;em&gt;var-sequence val-sequence 본문&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e1c8aece33f7cb04f9bb4e8e78e941ba25f10c8a" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;setf&lt;/strong&gt;&lt;em&gt;[place form]&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;setf &lt;/strong&gt;&lt;em&gt;[place form]&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9ae20fe71c0e147bb6bc4871d96f5e92f5c5660a" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;setq-local&lt;/strong&gt;&lt;em&gt;&amp;amp;rest pairs&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;setq-local &lt;/strong&gt;&lt;em&gt;&amp;amp; rest 쌍&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7fc00650723cfa16788a6eb8c490f8e2cbe554c7" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;thunk-delay&lt;/strong&gt;&lt;em&gt;forms&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;썽크 지연 &lt;/strong&gt;&lt;em&gt;양식&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f74169099eddfe8865dcdf5990bc129a1fdc6673" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;thunk-let*&lt;/strong&gt;&lt;em&gt;(bindings&amp;hellip;) forms&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;thunk-let * &lt;/strong&gt;&lt;em&gt;(bindings&amp;hellip;) 양식&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2a1e217877c5526cceda285dd42d4924b08e82f6" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;thunk-let&lt;/strong&gt;&lt;em&gt;(bindings&amp;hellip;) forms&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;thunk-let &lt;/strong&gt;&lt;em&gt;(bindings&amp;hellip;) 양식&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="766201ee854ac160680cf24ccec173e582e1a7ed" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;track-mouse&lt;/strong&gt;&lt;em&gt;body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;트랙 마우스 &lt;/strong&gt;&lt;em&gt;본체&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="feb84a0ba8e8559be9ca8af3789ff323f8333f22" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;unless&lt;/strong&gt;&lt;em&gt;condition forms&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;em&gt;조건이 형성 &lt;/em&gt;&lt;strong&gt;되지 않는 경우 &lt;/strong&gt;&lt;em&gt;&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d5aff66224e617a69f0607a954cf4ce95d91c0fc" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;when&lt;/strong&gt;&lt;em&gt;condition then-forms&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;em&gt;조건이 형성 &lt;/em&gt;&lt;strong&gt;되면 &lt;/strong&gt;&lt;em&gt;&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f205733ce1922f5715da64c2f9555232afd3f01c" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;while-no-input&lt;/strong&gt;&lt;em&gt;body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;입력이없는 &lt;/strong&gt;&lt;em&gt;본문&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f712914bd7ea1c83173b9e57d39ac648cc864f03" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-case-table&lt;/strong&gt;&lt;em&gt;table body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;케이스 테이블 &lt;/strong&gt;&lt;em&gt;테이블 본문 포함&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="756ee1443c1beb536eabc9fa307af9516c8aef78" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-coding-priority&lt;/strong&gt;&lt;em&gt;coding-systems &amp;amp;rest body&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;코딩 우선 &lt;/strong&gt;&lt;em&gt;코딩 시스템 및 나머지 본문&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b0626d3bcff6d0f9b11bce251e24405f3aef3212" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-connection-local-variables&lt;/strong&gt;&lt;em&gt;&amp;amp;rest body&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;with-connection-local-variables &lt;/strong&gt;&lt;em&gt;&amp;amp; rest body&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e90a90d3854565590ceddc4b00fa70821a122a93" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-current-buffer-window&lt;/strong&gt;&lt;em&gt;buffer-or-name action quit-function &amp;amp;rest body&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;with-current-buffer-window &lt;/strong&gt;&lt;em&gt;buffer-or-name action quit-function &amp;amp; rest body&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6e67efe0226ce402a3b6577c2572b74269dde5f8" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-current-buffer&lt;/strong&gt;&lt;em&gt;buffer-or-name body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;with-current-buffer &lt;/strong&gt;&lt;em&gt;buffer-or-name body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a213d0fd2a350c51fd6e821ffbef2c3c4e957b3f" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-demoted-errors&lt;/strong&gt;&lt;em&gt;format body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;강등 오류 &lt;/strong&gt;&lt;em&gt;형식 본문&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="92216dc544bae7ab562994e1580bab8f27e5c500" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-displayed-buffer-window&lt;/strong&gt;&lt;em&gt;buffer-or-name action quit-function &amp;amp;rest body&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;표시 버퍼 창 &lt;/strong&gt;&lt;em&gt;버퍼 또는 이름 작업 종료 기능 및 나머지 본문&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="02e7d013fbb53c92f365f47d71935d53a79d3a44" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-eval-after-load&lt;/strong&gt;&lt;em&gt;library body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;with-eval-after-load &lt;/strong&gt;&lt;em&gt;라이브러리 본문&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3ef9c7bbb2f8fd032cb894c0974bac62ca556b08" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-file-modes&lt;/strong&gt;&lt;em&gt;mode body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;with-file-modes &lt;/strong&gt;&lt;em&gt;모드 본문&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2e1ad0b0fa15e75e81fefccc043649d47a0ec7e8" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-help-window&lt;/strong&gt;&lt;em&gt;buffer-or-name body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;with-help-window &lt;/strong&gt;&lt;em&gt;buffer-or-name body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fe85851374c7d77e353d19f39d6c72494baf5727" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-local-quit&lt;/strong&gt;&lt;em&gt;body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;with-local-quit &lt;/strong&gt;&lt;em&gt;본문&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bf3fce278bf45ed1fb14e057cc0160271c67cbe1" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-mutex&lt;/strong&gt;&lt;em&gt;mutex body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;with-mutex &lt;/strong&gt;&lt;em&gt;mutex body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b5ce9ef0c5615794d7bdaada637134dc5ef72f95" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-output-to-string&lt;/strong&gt;&lt;em&gt;body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;with-output-to-string &lt;/strong&gt;&lt;em&gt;body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="145e9acb2514daffd471084b4b74175db21ac6c3" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-output-to-temp-buffer&lt;/strong&gt;&lt;em&gt;buffer-name body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;출력 대 임시 버퍼 &lt;/strong&gt;&lt;em&gt;버퍼 이름 본문&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="014aa5fdf2960526d77b8827eae2e874906c5c72" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-selected-window&lt;/strong&gt;&lt;em&gt;window forms&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;선택한 창 &lt;/strong&gt;&lt;em&gt;창 양식&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a68f1966ed297f73ea9922e372523354a6209aeb" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-silent-modifications&lt;/strong&gt;&lt;em&gt;body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;자동 수정 &lt;/strong&gt;&lt;em&gt;바디&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1b76c740d791472ee05bb84bd685f4830fbd0565" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-syntax-table&lt;/strong&gt;&lt;em&gt;table body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;구문 표 포함 &lt;/strong&gt;&lt;em&gt;표 본문&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7179c68d1d61234db5bb28f842f04ab503193f52" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-temp-buffer-window&lt;/strong&gt;&lt;em&gt;buffer-or-name action quit-function body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;with-temp-buffer-window &lt;/strong&gt;&lt;em&gt;buffer-or-name action quit-function body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cb335e848f2b8117c60546cedb994f0aab8f2d72" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-temp-buffer&lt;/strong&gt;&lt;em&gt;body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;온도 버퍼 &lt;/strong&gt;&lt;em&gt;본문 포함&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="68e9e5f62833f7dad75fa42c04a754f63c197fe2" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-temp-file&lt;/strong&gt;&lt;em&gt;file body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;with-temp-file &lt;/strong&gt;&lt;em&gt;파일 본문&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6e02315ac7e8b3f0ae1f5ca75a9f6f493bcaeceb" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-temp-message&lt;/strong&gt;&lt;em&gt;message &amp;amp;rest body&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;임시 메시지 &lt;/strong&gt;&lt;em&gt;메시지 및 나머지 본문 포함&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="87f26c950e83c00d565896bc264176d651cbc638" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-timeout&lt;/strong&gt;&lt;em&gt;(seconds timeout-forms&amp;hellip;) body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">매크로 : &lt;strong&gt;제한 시간 포함 &lt;/strong&gt;&lt;em&gt;(초 제한 시간 양식&amp;hellip;) 본문&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="899bd694d29ace1be956ab35177075021977560b" translate="yes" xml:space="preserve">
          <source>Macros</source>
          <target state="translated">Macros</target>
        </trans-unit>
        <trans-unit id="b7ffee61760e61c23c93306e84f4ed865540a241" translate="yes" xml:space="preserve">
          <source>Macros and Byte Compilation</source>
          <target state="translated">매크로 및 바이트 컴파일</target>
        </trans-unit>
        <trans-unit id="e9174412561f9b06e7358a460619f423a936460d" translate="yes" xml:space="preserve">
          <source>Macros are a way to extend the Lisp language.</source>
          <target state="translated">매크로는 Lisp 언어를 확장하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="df1edfc722b17bf0432a6a39f4d123de99bb02e1" translate="yes" xml:space="preserve">
          <source>Macros can do this because they operate on the unevaluated expressions for the arguments, not on the argument values as functions do. They can therefore construct an expansion containing these argument expressions or parts of them.</source>
          <target state="translated">매크로는 함수처럼 인수 값이 아니라 인수에 대해 평가되지 않은 식에서 작동하기 때문에이를 수행 할 수 있습니다. 따라서 이러한 인수 표현식 또는 그 일부를 포함하는 확장을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86ad4286948aac2e22fb320469457597f40e25e9" translate="yes" xml:space="preserve">
          <source>Macros like &lt;code&gt;save-window-excursion&lt;/code&gt;, &lt;code&gt;with-selected-window&lt;/code&gt; or &lt;code&gt;with-current-buffer&lt;/code&gt; can be used when running window change functions.</source>
          <target state="translated">&lt;code&gt;save-window-excursion&lt;/code&gt; , &lt;code&gt;with-selected-window&lt;/code&gt; 또는 &lt;code&gt;with-current-buffer&lt;/code&gt; 와 같은 매크로는 창 변경 기능을 실행할 때 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8609149c2452193a39482806645c173c455fdb7e" translate="yes" xml:space="preserve">
          <source>Macros often need to construct large list structures from a mixture of constants and nonconstant parts. To make this easier, use the &amp;lsquo;</source>
          <target state="translated">매크로는 종종 상수와 비상 수 부분의 혼합으로 큰 목록 구조를 구성해야합니다. 이 작업을 더 쉽게하려면 '</target>
        </trans-unit>
        <trans-unit id="e02a2089bfc650b4d78c5778356a47b4f6c929d4" translate="yes" xml:space="preserve">
          <source>Maintaining Undo Lists</source>
          <target state="translated">실행 취소 목록 유지</target>
        </trans-unit>
        <trans-unit id="b4800c1dbe2e7fe97716c9f437b2d989b0114297" translate="yes" xml:space="preserve">
          <source>Maintaining a public package archive entails a degree of responsibility. When Emacs users install packages from your archive, those packages can cause Emacs to run arbitrary code with the permissions of the installing user. (This is true for Emacs code in general, not just for packages.) So you should ensure that your archive is well-maintained and keep the hosting system secure.</source>
          <target state="translated">공개 패키지 아카이브를 유지하는 것은 어느 정도의 책임을 수반합니다. Emacs 사용자가 아카이브에서 패키지를 설치할 때 이러한 패키지로 인해 Emacs가 설치 사용자의 권한으로 임의의 코드를 실행할 수 있습니다. (이것은 패키지뿐만 아니라 일반적으로 Emacs 코드에도 해당됩니다.) 따라서 아카이브가 잘 유지되고 호스팅 시스템을 안전하게 유지해야합니다.</target>
        </trans-unit>
        <trans-unit id="c19746ba61877a021e38d926e000d62be983a896" translate="yes" xml:space="preserve">
          <source>Maintaining package archives.</source>
          <target state="translated">패키지 아카이브 유지.</target>
        </trans-unit>
        <trans-unit id="606cf8196868e5f549fd1168472b48701f267c5f" translate="yes" xml:space="preserve">
          <source>Major Mode Conventions</source>
          <target state="translated">주요 모드 규칙</target>
        </trans-unit>
        <trans-unit id="bb282fd14bccfc29a60ab093b4041c44964f43f9" translate="yes" xml:space="preserve">
          <source>Major Mode Examples</source>
          <target state="translated">주요 모드 예</target>
        </trans-unit>
        <trans-unit id="a8b5ad1cdceba549e2a4b89898c34005d52785df" translate="yes" xml:space="preserve">
          <source>Major Modes</source>
          <target state="translated">주요 모드</target>
        </trans-unit>
        <trans-unit id="cd5fed78b53dc008bcaa949f077e4002fa314735" translate="yes" xml:space="preserve">
          <source>Major and Minor Modes</source>
          <target state="translated">메이저 및 마이너 모드</target>
        </trans-unit>
        <trans-unit id="e37f2a35397994a75b440b8e162b38fe39bb718b" translate="yes" xml:space="preserve">
          <source>Major modes for editing text should not define</source>
          <target state="translated">텍스트 편집을위한 주요 모드는</target>
        </trans-unit>
        <trans-unit id="4fa4f3d22c7a7ae10c0e45ce33e8b5151b9a09b1" translate="yes" xml:space="preserve">
          <source>Major modes should not alter options that are primarily a matter of user preference, such as whether Auto-Fill mode is enabled. Leave this to each user to decide. However, a major mode should customize other variables so that Auto-Fill mode will work usefully &lt;em&gt;if&lt;/em&gt; the user decides to use it.</source>
          <target state="translated">주요 모드는 자동 채우기 모드 활성화 여부와 같이 주로 사용자 기본 설정의 문제인 옵션을 변경해서는 안됩니다. 이를 각 사용자에게 맡기고 결정하십시오. 그러나 주 모드는 사용자가 사용하기로 결정한 &lt;em&gt;경우&lt;/em&gt; 자동 채우기 모드가 유용하게 작동하도록 다른 변수를 사용자 정의해야 합니다.</target>
        </trans-unit>
        <trans-unit id="d5246cd7371de3f7eda0f9bf9b7e1bf7a313c280" translate="yes" xml:space="preserve">
          <source>Major modes should run their mode hook using this function. It is similar to &lt;code&gt;run-hooks&lt;/code&gt; (see &lt;a href=&quot;hooks#Hooks&quot;&gt;Hooks&lt;/a&gt;), but it also runs &lt;code&gt;change-major-mode-after-body-hook&lt;/code&gt;, &lt;code&gt;hack-local-variables&lt;/code&gt; (when the buffer is visiting a file) (see &lt;a href=&quot;file-local-variables#File-Local-Variables&quot;&gt;File Local Variables&lt;/a&gt;), and &lt;code&gt;after-change-major-mode-hook&lt;/code&gt;. The last thing it does is to evaluate any &lt;code&gt;:after-hook&lt;/code&gt; forms declared by parent modes (see &lt;a href=&quot;derived-modes#Derived-Modes&quot;&gt;Derived Modes&lt;/a&gt;).</source>
          <target state="translated">주요 모드는이 기능을 사용하여 모드 후크를 실행해야합니다. &lt;code&gt;run-hooks&lt;/code&gt; ( &lt;a href=&quot;hooks#Hooks&quot;&gt;Hooks&lt;/a&gt; 참조 ) 와 유사 하지만 &lt;code&gt;change-major-mode-after-body-hook&lt;/code&gt; , &lt;code&gt;hack-local-variables&lt;/code&gt; (버퍼가 파일을 방문 할 때) ( &lt;a href=&quot;file-local-variables#File-Local-Variables&quot;&gt;파일 로컬 변수&lt;/a&gt; 참조 )도 실행합니다. &lt;code&gt;after-change-major-mode-hook&lt;/code&gt; . 마지막으로하는 일은 부모 모드에서 선언 한 모든 &lt;code&gt;:after-hook&lt;/code&gt; 형식 을 평가하는 것입니다 ( &lt;a href=&quot;derived-modes#Derived-Modes&quot;&gt;파생 모드&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="2923364acdd14ce08c91c050cf84d8d42591bb6e" translate="yes" xml:space="preserve">
          <source>Major modes specialize Emacs for editing or interacting with particular kinds of text. Each buffer has exactly one major mode at a time. Every major mode is associated with a &lt;em&gt;major mode command&lt;/em&gt;, whose name should end in &amp;lsquo;</source>
          <target state="translated">주요 모드는 특정 유형의 텍스트를 편집하거나 상호 작용하기위한 Emacs를 전문화합니다. 각 버퍼에는 한 번에 정확히 하나의 주 모드가 있습니다. 모든 주 모드는 이름이 '로 끝나야 하는 &lt;em&gt;주 모드 명령&lt;/em&gt; 과 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="38d00cb263c96ca2a52e27564fd94babb43bab35" translate="yes" xml:space="preserve">
          <source>Make a finalizer that will run &lt;var&gt;function&lt;/var&gt;. &lt;var&gt;function&lt;/var&gt; will be called after garbage collection when the returned finalizer object becomes unreachable. If the finalizer object is reachable only through references from finalizer objects, it does not count as reachable for the purpose of deciding whether to run &lt;var&gt;function&lt;/var&gt;. &lt;var&gt;function&lt;/var&gt; will be run once per finalizer object.</source>
          <target state="translated">&lt;var&gt;function&lt;/var&gt; 을 실행할 종료자를 만듭니다 . 반환 된 종료 자 개체에 도달 할 수 없게되면 가비지 수집 후에 &lt;var&gt;function&lt;/var&gt; 가 호출됩니다. 종료 자 객체가 종료 자 객체의 참조를 통해서만 도달 할 수있는 경우 &lt;var&gt;function&lt;/var&gt; 실행 여부를 결정할 목적으로 도달 가능한 것으로 간주되지 않습니다 . &lt;var&gt;function&lt;/var&gt; 는 종료 자 개체 당 한 번 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="7d05b1ed3c0802c954e67c3ed43ecc3f76f2dcb8" translate="yes" xml:space="preserve">
          <source>Make a new condition variable associated with &lt;var&gt;mutex&lt;/var&gt;. If &lt;var&gt;name&lt;/var&gt; is specified, it is a name given to the condition variable. It must be a string. The name is for debugging purposes only; it has no meaning to Emacs.</source>
          <target state="translated">&lt;var&gt;mutex&lt;/var&gt; 와 관련된 새 조건 변수를 만듭니다 . 경우 &lt;var&gt;name&lt;/var&gt; 지정되어,이 조건 변수에 주어진 이름입니다. 문자열이어야합니다. 이름은 디버깅 목적으로 만 사용됩니다. Emacs에게는 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="1c29998a0cfecf6c2e9ce2a81215d8045a8a6c92" translate="yes" xml:space="preserve">
          <source>Make numbered backups if the visited file already has numbered backups; otherwise, do not. This is the default.</source>
          <target state="translated">방문한 파일에 이미 번호가 매겨진 백업이있는 경우 번호가 매겨진 백업을 만듭니다. 그렇지 않으면하지 마십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="2da90c1787d3c7d351f1c46baa7a638097f08e65" translate="yes" xml:space="preserve">
          <source>Make numbered backups.</source>
          <target state="translated">번호가 매겨진 백업을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="711b2ff4a299052a936b40c6f84cbfef1eba50db" translate="yes" xml:space="preserve">
          <source>Make sure &lt;code&gt;jit-lock-contextually&lt;/code&gt; is set and rely on it doing its job. This will only rehighlight the part of the construct that follows the actual change, and will do it after a short delay. This only works if the highlighting of the various parts of your multiline construct never depends on text in subsequent lines. Since &lt;code&gt;jit-lock-contextually&lt;/code&gt; is activated by default, this can be an attractive solution.</source>
          <target state="translated">&lt;code&gt;jit-lock-contextually&lt;/code&gt; 가 설정되어 있는지 확인 하고 작업에 의존하십시오. 이렇게하면 실제 변경 사항을 따르는 구성 부분 만 다시 강조 표시되며 잠시 후에 수행됩니다. 이것은 여러 줄 구성의 다양한 부분의 강조가 후속 줄의 텍스트에 절대 의존하지 않는 경우에만 작동합니다. &lt;code&gt;jit-lock-contextually&lt;/code&gt; 는 기본적으로 활성화되어 있기 때문에 매력적인 솔루션이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6a7dff46b149b27821f54fd9ae7b59aa7b81e46" translate="yes" xml:space="preserve">
          <source>Make the &lt;code&gt;rx&lt;/code&gt; definitions in &lt;var&gt;bindings&lt;/var&gt; available locally for &lt;code&gt;rx&lt;/code&gt; macro invocations in &lt;var&gt;body&lt;/var&gt;, which is then evaluated.</source>
          <target state="translated">&lt;var&gt;bindings&lt;/var&gt; 의 &lt;code&gt;rx&lt;/code&gt; 정의를 &lt;var&gt;body&lt;/var&gt; 의 &lt;code&gt;rx&lt;/code&gt; 매크로 호출에 대해 로컬 에서 사용할 수 있도록 한 다음 평가합니다.</target>
        </trans-unit>
        <trans-unit id="7cbe1d5e07a300b4e199aa52e31ab4c25575ef27" translate="yes" xml:space="preserve">
          <source>Making Backup Files</source>
          <target state="translated">백업 파일 만들기</target>
        </trans-unit>
        <trans-unit id="d519807d2832f393ececd53cc3b5b0781e852aed" translate="yes" xml:space="preserve">
          <source>Making Buttons</source>
          <target state="translated">버튼 만들기</target>
        </trans-unit>
        <trans-unit id="6bc49c91daf67a006b0afd80b17ad707dc94b52d" translate="yes" xml:space="preserve">
          <source>Making Certain File Names &amp;ldquo;Magic&amp;rdquo;</source>
          <target state="translated">특정 파일 이름을 &quot;매직&quot;으로 만들기</target>
        </trans-unit>
        <trans-unit id="c34b468d532d0ce0f0dafb7d482d36723b3412cd" translate="yes" xml:space="preserve">
          <source>Making Certain File Names “Magic”</source>
          <target state="translated">특정 파일 이름을 &quot;매직&quot;으로 만들기</target>
        </trans-unit>
        <trans-unit id="c51c6eff7a755274f117eedefbb312175db7a807" translate="yes" xml:space="preserve">
          <source>Making a command distinguish interactive calls.</source>
          <target state="translated">명령을 내리면 대화 형 호출이 구별됩니다.</target>
        </trans-unit>
        <trans-unit id="7318dd947ef8c106ed8ecd66b4999fa87252517d" translate="yes" xml:space="preserve">
          <source>Making a frame the child of another.</source>
          <target state="translated">프레임을 다른 프레임의 자식으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="a4f8e97640cd04a362c1fe6f0e955802fe3826fe" translate="yes" xml:space="preserve">
          <source>Making a frame visible usually makes all its child frames (and their descendants) visible as well (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;).</source>
          <target state="translated">프레임을 표시하면 일반적으로 모든 하위 프레임 (및 하위 프레임)도 표시됩니다 ( &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;하위 프레임&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="681222f25961ab30aded517088045711c219585c" translate="yes" xml:space="preserve">
          <source>Making a function inline often makes its function calls run faster. But it also has disadvantages. For one thing, it reduces flexibility; if you change the definition of the function, calls already inlined still use the old definition until you recompile them.</source>
          <target state="translated">함수를 인라인으로 만들면 함수 호출이 더 빨리 실행되는 경우가 많습니다. 하지만 단점도 있습니다. 한 가지는 유연성을 감소시킵니다. 함수의 정의를 변경하면 이미 인라인 된 호출은 다시 컴파일 할 때까지 이전 정의를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f2089d7853bf8479df80e0abc427bb46a0ae24ca" translate="yes" xml:space="preserve">
          <source>Making a simple menu.</source>
          <target state="translated">간단한 메뉴 만들기.</target>
        </trans-unit>
        <trans-unit id="8439e43257d843b9c56d5b30e329b96824cfd5a0" translate="yes" xml:space="preserve">
          <source>Making a trace buffer is not the same thing as using trace execution mode (see &lt;a href=&quot;edebug-execution-modes#Edebug-Execution-Modes&quot;&gt;Edebug Execution Modes&lt;/a&gt;).</source>
          <target state="translated">추적 버퍼를 만드는 것은 추적 실행 모드를 사용하는 &lt;a href=&quot;edebug-execution-modes#Edebug-Execution-Modes&quot;&gt;것과는 다릅니다&lt;/a&gt; ( Edebug 실행 모드 참조 ).</target>
        </trans-unit>
        <trans-unit id="e9a2a5554b24dffde38c378df6b1ed44b56af090" translate="yes" xml:space="preserve">
          <source>Making a variable buffer-local within a &lt;code&gt;let&lt;/code&gt;-binding for that variable does not work reliably, unless the buffer in which you do this is not current either on entry to or exit from the &lt;code&gt;let&lt;/code&gt;. This is because &lt;code&gt;let&lt;/code&gt; does not distinguish between different kinds of bindings; it knows only which variable the binding was made for.</source>
          <target state="translated">해당 변수에 대한 &lt;code&gt;let&lt;/code&gt; 바인딩 내에서 변수를 buffer-local 로 설정하는 것은이 작업을 수행하는 버퍼가 &lt;code&gt;let&lt;/code&gt; 에 진입하거나 종료 할 때 현재 상태가 아닌 경우 안정적으로 작동하지 않습니다 . 이는 &lt;code&gt;let&lt;/code&gt; 이 서로 다른 종류의 바인딩을 구분하지 않기 때문 입니다. 바인딩이 만들어진 변수 만 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a77df4e83035e98ff42ae3948f6a82cd13e6bb3" translate="yes" xml:space="preserve">
          <source>Making and Deleting Numbered Backup Files</source>
          <target state="translated">번호가 매겨진 백업 파일 만들기 및 삭제</target>
        </trans-unit>
        <trans-unit id="502cd69036f8965c9870fb3f5a0ea43cc7a0e64d" translate="yes" xml:space="preserve">
          <source>Making elements that match multiline constructs work properly has two aspects: correct &lt;em&gt;identification&lt;/em&gt; and correct &lt;em&gt;rehighlighting&lt;/em&gt;. The first means that Font Lock finds all multiline constructs. The second means that Font Lock will correctly rehighlight all the relevant text when a multiline construct is changed&amp;mdash;for example, if some of the text that was previously part of a multiline construct ceases to be part of it. The two aspects are closely related, and often getting one of them to work will appear to make the other also work. However, for reliable results you must attend explicitly to both aspects.</source>
          <target state="translated">여러 줄 구성과 일치하는 요소가 제대로 작동하도록하려면 올바른 &lt;em&gt;식별&lt;/em&gt; 과 올바른 &lt;em&gt;다시 강조 &lt;/em&gt;&lt;em&gt;표시&lt;/em&gt; 라는 두 가지 측면이 있습니다. 첫 번째는 Font Lock이 모든 여러 줄 구성을 찾는다는 것을 의미합니다. 두 번째는 여러 줄 구성이 변경 될 때 글꼴 잠금이 모든 관련 텍스트를 올바르게 다시 강조 표시한다는 것을 의미합니다. 두 가지 측면은 밀접하게 관련되어 있으며, 종종 그중 하나를 작동 시키면 다른 하나도 작동하는 것처럼 보입니다. 그러나 신뢰할 수있는 결과를 얻으려면 두 측면 모두에 명시 적으로주의를 기울여야합니다.</target>
        </trans-unit>
        <trans-unit id="098d22cd28360badafbde33dc08e76c95b4320aa" translate="yes" xml:space="preserve">
          <source>Making empty markers or markers at certain places.</source>
          <target state="translated">특정 위치에 빈 마커 또는 마커 만들기.</target>
        </trans-unit>
        <trans-unit id="525dbea9386c59969f103c79f75f5f87fc2f3fcd" translate="yes" xml:space="preserve">
          <source>Making keymaps active is not the only way to use them. Keymaps are also used in other ways, such as for translating events within &lt;code&gt;read-key-sequence&lt;/code&gt;. See &lt;a href=&quot;translation-keymaps#Translation-Keymaps&quot;&gt;Translation Keymaps&lt;/a&gt;.</source>
          <target state="translated">키맵을 활성화하는 것이 키맵을 사용하는 유일한 방법은 아닙니다. 키맵은 &lt;code&gt;read-key-sequence&lt;/code&gt; 내에서 이벤트를 번역하는 것과 같은 다른 방식으로도 사용됩니다 . &lt;a href=&quot;translation-keymaps#Translation-Keymaps&quot;&gt;번역 키맵을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="541485b8dffefaa5c41c8732b845592eb77e4506" translate="yes" xml:space="preserve">
          <source>Making multiple system-level windows.</source>
          <target state="translated">여러 시스템 수준 창 만들기.</target>
        </trans-unit>
        <trans-unit id="7aea42fe562cd12b8ebe2dbf3e921b54d524ae69" translate="yes" xml:space="preserve">
          <source>Making printable descriptions of non-printing characters and key sequences.</source>
          <target state="translated">인쇄되지 않는 문자 및 키 시퀀스에 대한 인쇄 가능한 설명을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="a8c2048498ddf380173f943840a29bb5648daa3a" translate="yes" xml:space="preserve">
          <source>Making variables and faces customizable.</source>
          <target state="translated">변수와 얼굴을 사용자 정의 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="f955f72d31d474b19bd9671e9ef2cb781d7e8a14" translate="yes" xml:space="preserve">
          <source>Making windows atomic (see &lt;a href=&quot;atomic-windows#Atomic-Windows&quot;&gt;Atomic Windows&lt;/a&gt;) avoids breaking an existing window composition when popping up a new window. The new window will pop up outside the composition instead.</source>
          <target state="translated">창 원자 만들기 (참조 &lt;a href=&quot;atomic-windows#Atomic-Windows&quot;&gt;원자 Windows가&lt;/a&gt; 새 창을 팝업 때 기존 윈도우 성분을 파괴 방지). 대신 새 창이 컴포지션 외부에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="e6360d86a643276430e992495fad2c7dbbc295a9" translate="yes" xml:space="preserve">
          <source>Managing Overlays</source>
          <target state="translated">오버레이 관리</target>
        </trans-unit>
        <trans-unit id="debda63f7ddcebd0c0dfe38a3022559f7abc90ec" translate="yes" xml:space="preserve">
          <source>Managing a Fixed-Size Ring of Objects</source>
          <target state="translated">고정 된 크기의 개체 링 관리</target>
        </trans-unit>
        <trans-unit id="fdce057e8f54be9a848c2533b0fadb72cdfd78bc" translate="yes" xml:space="preserve">
          <source>Managing a fixed-size ring of objects.</source>
          <target state="translated">고정 된 크기의 개체 링 관리.</target>
        </trans-unit>
        <trans-unit id="75bd65a788f8528d79762b0605df956da0550547" translate="yes" xml:space="preserve">
          <source>Manipulating Buttons</source>
          <target state="translated">버튼 조작</target>
        </trans-unit>
        <trans-unit id="e43177bf40b32f1208c84ad9ee839111b074ef8c" translate="yes" xml:space="preserve">
          <source>Manipulating windows and displaying buffers.</source>
          <target state="translated">창 조작 및 버퍼 표시.</target>
        </trans-unit>
        <trans-unit id="4e836fdc2572ab23d5dc8c36bd613ac6b0f82d63" translate="yes" xml:space="preserve">
          <source>Manual</source>
          <target state="translated">Manual</target>
        </trans-unit>
        <trans-unit id="7492182c02f487bb6ba19f1d0693155fc4bbcfd0" translate="yes" xml:space="preserve">
          <source>Many 32-bit operating systems are limited to system times containing 32 bits of information in their seconds component; these systems typically handle only the times from 1901-12-13 20:45:52 through 2038-01-19 03:14:07 Universal Time. However, 64-bit and some 32-bit operating systems have larger seconds components, and can represent times far in the past or future.</source>
          <target state="translated">많은 32 비트 운영 체제는 초 구성 요소에 32 비트 정보를 포함하는 시스템 시간으로 제한됩니다. 이러한 시스템은 일반적으로 1901-12-13 20:45:52에서 2038-01-19 03:14:07까지의 시간 만 처리합니다. 그러나 64 비트 및 일부 32 비트 운영 체제에는 더 큰 초 구성 요소가 있으며 과거 또는 미래의 시간을 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79e5ea61e3cd212d27c82f4613eb12341df1f45d" translate="yes" xml:space="preserve">
          <source>Many alists use lists with two elements, instead of cons cells. For example,</source>
          <target state="translated">많은 alist는 cons 셀 대신 두 개의 요소가있는 목록을 사용합니다. 예를 들면</target>
        </trans-unit>
        <trans-unit id="cb227181787da48817c942e26d864e081c59be50" translate="yes" xml:space="preserve">
          <source>Many efforts in the design of &lt;code&gt;display-buffer&lt;/code&gt; have been given to maintain compatibility with code that uses older options like &lt;code&gt;pop-up-windows&lt;/code&gt;, &lt;code&gt;pop-up-frames&lt;/code&gt;, &lt;code&gt;pop-up-frame-alist&lt;/code&gt;, &lt;code&gt;same-window-buffer-names&lt;/code&gt; and &lt;code&gt;same-window-regexps&lt;/code&gt;. Lisp Programs and users should refrain from using these options. Above we already warned against customizing &lt;code&gt;pop-up-frame-alist&lt;/code&gt;. Here we describe how to convert the remaining options to use display actions instead.</source>
          <target state="translated">의 설계에 많은 노력 &lt;code&gt;display-buffer&lt;/code&gt; 와 같은 용도로 나이가 옵션 그 코드와의 호환성을 유지하기 위해 부여 된 &lt;code&gt;pop-up-windows&lt;/code&gt; , &lt;code&gt;pop-up-frames&lt;/code&gt; , &lt;code&gt;pop-up-frame-alist&lt;/code&gt; , &lt;code&gt;same-window-buffer-names&lt;/code&gt; 및 &lt;code&gt;same-window-regexps&lt;/code&gt; . Lisp 프로그램 및 사용자는 이러한 옵션을 사용하지 않아야합니다. 위에서 우리는 이미 &lt;code&gt;pop-up-frame-alist&lt;/code&gt; 사용자 정의에 대해 경고했습니다 . 여기에서는 표시 작업을 대신 사용하도록 나머지 옵션을 변환하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="4b9ab87576a609558bdd9e7bef4e47ebe7d12419" translate="yes" xml:space="preserve">
          <source>Many filter functions sometimes (or always) insert the output in the process&amp;rsquo;s buffer, mimicking the actions of the default filter. Such filter functions need to make sure that they save the current buffer, select the correct buffer (if different) before inserting output, and then restore the original buffer. They should also check whether the buffer is still alive, update the process marker, and in some cases update the value of point. Here is how to do these things:</source>
          <target state="translated">많은 필터 함수는 때때로 (또는 항상) 출력을 프로세스의 버퍼에 삽입하여 기본 필터의 동작을 모방합니다. 이러한 필터 함수는 현재 버퍼를 저장하고 출력을 삽입하기 전에 올바른 버퍼 (다른 경우)를 선택한 다음 원래 버퍼를 복원해야합니다. 또한 버퍼가 아직 살아 있는지 확인하고 프로세스 마커를 업데이트하고 경우에 따라 포인트 값을 업데이트해야합니다. 이러한 작업을 수행하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bd93bafe41da62c5221706aaaa782fac79369062" translate="yes" xml:space="preserve">
          <source>Many functions are provided to look at the characters around point. Several simple functions are described here. See also &lt;code&gt;looking-at&lt;/code&gt; in &lt;a href=&quot;regexp-search#Regexp-Search&quot;&gt;Regexp Search&lt;/a&gt;.</source>
          <target state="translated">포인트 주변의 문자를 볼 수있는 많은 기능이 제공됩니다. 여기에서는 몇 가지 간단한 기능에 대해 설명합니다. 참조 &lt;code&gt;looking-at&lt;/code&gt; 의 &lt;a href=&quot;regexp-search#Regexp-Search&quot;&gt;정규 표현식 검색&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="99061e430b89d1f2aeaea52a5d8f4cb245b9c411" translate="yes" xml:space="preserve">
          <source>Many functions build lists, as lists reside at the very heart of Lisp. &lt;code&gt;cons&lt;/code&gt; is the fundamental list-building function; however, it is interesting to note that &lt;code&gt;list&lt;/code&gt; is used more times in the source code for Emacs than &lt;code&gt;cons&lt;/code&gt;.</source>
          <target state="translated">목록이 Lisp의 중심에 있기 때문에 많은 함수가 목록을 작성합니다. &lt;code&gt;cons&lt;/code&gt; 은 기본적인 목록 작성 기능입니다. 그러나 Emacs의 소스 코드에서 &lt;code&gt;cons&lt;/code&gt; 보다 &lt;code&gt;list&lt;/code&gt; 가 더 많이 사용 된다는 점은 흥미 롭습니다 .</target>
        </trans-unit>
        <trans-unit id="b118195a9372d8b227bd6e9ed5773cbb28b54e10" translate="yes" xml:space="preserve">
          <source>Many functions like &lt;code&gt;current-time&lt;/code&gt; and &lt;code&gt;file-attributes&lt;/code&gt; return &lt;em&gt;Lisp timestamp&lt;/em&gt; values that count seconds, and that can represent absolute time by counting seconds since the &lt;em&gt;epoch&lt;/em&gt; of 1970-01-01 00:00:00 UTC.</source>
          <target state="translated">같은 많은 기능을 &lt;code&gt;current-time&lt;/code&gt; 과 &lt;code&gt;file-attributes&lt;/code&gt; 반환 &lt;em&gt;리스프 타임 스탬프&lt;/em&gt; 초 카운트 값을, 그은 이후 계수 초에 의해 절대 시간을 나타낼 수있는 &lt;em&gt;획기적인&lt;/em&gt; 1970-01-01 0시 0 분 0 초 세계 협정.</target>
        </trans-unit>
        <trans-unit id="802952a287eebffddbd929e1038f8cdef315746b" translate="yes" xml:space="preserve">
          <source>Many functions that interact with process objects, (for instance, &lt;code&gt;process-datagram-address&lt;/code&gt;) rely on them at least having a socket before they can return a useful value. These functions will block until the socket has achieved the desired status. The recommended way of interacting with asynchronous sockets is to place a sentinel on the process, and not try to interact with it before it has changed status to &amp;lsquo;</source>
          <target state="translated">프로세스 객체와 상호 작용하는 많은 함수 (예 : &lt;code&gt;process-datagram-address&lt;/code&gt; )는 유용한 값을 반환하기 전에 최소한 소켓이 있어야합니다. 이러한 기능은 소켓이 원하는 상태가 될 때까지 차단됩니다. 비동기 소켓과 상호 작용하는 권장 방법은 프로세스에 센티넬을 배치하고 상태가 '로 변경되기 전에 상호 작용을 시도하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="34060d8cea305615df58234c0c74340b92bdbb96" translate="yes" xml:space="preserve">
          <source>Many of the examples in this manual print text when they are evaluated. If you execute example code in a Lisp Interaction buffer (such as the buffer</source>
          <target state="translated">이 설명서의 많은 예제는 평가 될 때 텍스트를 인쇄합니다. Lisp 상호 작용 버퍼 (예 : 버퍼</target>
        </trans-unit>
        <trans-unit id="2cb6eeef569da5d2926960dd49593235b8a4de19" translate="yes" xml:space="preserve">
          <source>Many of the file functions take one or more arguments that are file names. A file name is a string. Most of these functions expand file name arguments using the function &lt;code&gt;expand-file-name&lt;/code&gt;, so that</source>
          <target state="translated">많은 파일 함수는 파일 이름 인 하나 이상의 인수를 사용합니다. 파일 이름은 문자열입니다. 이러한 함수의 대부분은 &lt;code&gt;expand-file-name&lt;/code&gt; 함수를 사용하여 파일 이름 인수를 확장 하므로</target>
        </trans-unit>
        <trans-unit id="856002faf420bf01c022be5d9fd84713d7c5ea95" translate="yes" xml:space="preserve">
          <source>Many of the functions described in this chapter accept markers for arguments in place of numbers. (See &lt;a href=&quot;markers#Markers&quot;&gt;Markers&lt;/a&gt;.) Since the actual arguments to such functions may be either numbers or markers, we often give these arguments the name &lt;var&gt;number-or-marker&lt;/var&gt;. When the argument value is a marker, its position value is used and its buffer is ignored.</source>
          <target state="translated">이 장에서 설명하는 많은 함수는 숫자 대신 인수에 대한 마커를 허용합니다. ( &lt;a href=&quot;markers#Markers&quot;&gt;Markers를&lt;/a&gt; 참조하십시오 .) 이러한 함수에 대한 실제 인수는 숫자 또는 마커 일 수 있으므로 종종 이러한 인수에 &lt;var&gt;number-or-marker&lt;/var&gt; 이름을 지정 합니다 . 인수 값이 마커이면 해당 위치 값이 사용되고 버퍼가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="ede60666649bf60156d4a427812b20ad852466a6" translate="yes" xml:space="preserve">
          <source>Many of the specialized editing and I/O facilities of Emacs accept only strings. For example, you cannot insert a vector of characters into a buffer the way you can insert a string. See &lt;a href=&quot;strings-and-characters#Strings-and-Characters&quot;&gt;Strings and Characters&lt;/a&gt;.</source>
          <target state="translated">Emacs의 많은 전문 편집 및 I / O 기능은 문자열 만 허용합니다. 예를 들어, 문자열을 삽입 할 수있는 방식으로 문자 벡터를 버퍼에 삽입 할 수 없습니다. &lt;a href=&quot;strings-and-characters#Strings-and-Characters&quot;&gt;문자열 및 문자를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3629e89080e09e327cdd6dfb7f47d74e11faec96" translate="yes" xml:space="preserve">
          <source>Many of the standard Emacs functions manipulate or test the characters in the current buffer; a whole chapter in this manual is devoted to describing these functions (see &lt;a href=&quot;text#Text&quot;&gt;Text&lt;/a&gt;).</source>
          <target state="translated">대부분의 표준 Emacs 함수는 현재 버퍼의 문자를 조작하거나 테스트합니다. 이 설명서의 전체 장은 이러한 기능을 설명하는 데 전념합니다 ( &lt;a href=&quot;text#Text&quot;&gt;텍스트&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="d945fb20602aed4abd69b2e84e025e54ece264be" translate="yes" xml:space="preserve">
          <source>Many of the valid output streams are also valid as input streams. The difference between input and output streams is therefore more a matter of how you use a Lisp object, than of different types of object.</source>
          <target state="translated">많은 유효한 출력 스트림이 입력 스트림으로도 유효합니다. 따라서 입력 스트림과 출력 스트림의 차이는 다른 유형의 객체보다 Lisp 객체를 사용하는 방법의 문제입니다.</target>
        </trans-unit>
        <trans-unit id="f337e3c741b2e5363e4452e88afb97f9e466bc3f" translate="yes" xml:space="preserve">
          <source>Many overlay properties have special meanings; here is a table of them:</source>
          <target state="translated">많은 오버레이 속성에는 특별한 의미가 있습니다. 여기에 그들에 대한 표가 있습니다.</target>
        </trans-unit>
        <trans-unit id="28669a5c2141fd75140a0f1efc7ec3dc89659c90" translate="yes" xml:space="preserve">
          <source>Many text-related functions operate on a region of text defined by two buffer positions passed in arguments named &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt;. These arguments should be either markers (see &lt;a href=&quot;markers#Markers&quot;&gt;Markers&lt;/a&gt;) or numeric character positions (see &lt;a href=&quot;positions#Positions&quot;&gt;Positions&lt;/a&gt;). The order of these arguments does not matter; it is all right for &lt;var&gt;start&lt;/var&gt; to be the end of the region and &lt;var&gt;end&lt;/var&gt; the beginning. For example, &lt;code&gt;(delete-region 1
10)&lt;/code&gt; and &lt;code&gt;(delete-region 10 1)&lt;/code&gt; are equivalent. An &lt;code&gt;args-out-of-range&lt;/code&gt; error is signaled if either &lt;var&gt;start&lt;/var&gt; or &lt;var&gt;end&lt;/var&gt; is outside the accessible portion of the buffer. In an interactive call, point and the mark are used for these arguments.</source>
          <target state="translated">많은 텍스트 관련 함수는 &lt;var&gt;start&lt;/var&gt; 및 &lt;var&gt;end&lt;/var&gt; 라는 인수에 전달 된 두 버퍼 위치로 정의 된 텍스트 영역에서 작동합니다 . 이러한 인수는 마커 ( &lt;a href=&quot;markers#Markers&quot;&gt;Markers&lt;/a&gt; 참조 ) 또는 숫자 문자 위치 ( &lt;a href=&quot;positions#Positions&quot;&gt;Positions&lt;/a&gt; 참조) 여야합니다 . 이러한 주장의 순서는 중요하지 않습니다. 모든 권리 &lt;var&gt;start&lt;/var&gt; 이 지역의 끝을하고하는 &lt;var&gt;end&lt;/var&gt; 시작합니다. 예를 들어, &lt;code&gt;(delete-region 1 10)&lt;/code&gt; 및 &lt;code&gt;(delete-region 10 1)&lt;/code&gt; 은 동일합니다. &lt;code&gt;args-out-of-range&lt;/code&gt; 어느 경우 오류가 신호됩니다 &lt;var&gt;start&lt;/var&gt; 또는 &lt;var&gt;end&lt;/var&gt; 버퍼의 액세스 가능한 부분 밖에 있습니다. 대화 형 호출에서는 이러한 인수에 대해 포인트와 마크가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6ed3e3bf0cc6abbeb7fc11924e0595f7cbb9b258" translate="yes" xml:space="preserve">
          <source>Many window-systems are not able to change the opacity (see &lt;a href=&quot;font-and-color-parameters#Font-and-Color-Parameters&quot;&gt;Font and Color Parameters&lt;/a&gt;) of child frames.</source>
          <target state="translated">많은 윈도우 시스템은 자식 프레임 의 불투명도 ( &lt;a href=&quot;font-and-color-parameters#Font-and-Color-Parameters&quot;&gt;글꼴 및 색상 매개 변수&lt;/a&gt; 참조)를 변경할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="213b455d1f0caf22fcf0e2374a037400baed7c91" translate="yes" xml:space="preserve">
          <source>Mapping Functions</source>
          <target state="translated">매핑 기능</target>
        </trans-unit>
        <trans-unit id="7b7987be97e32819225bc7a4606b16bf612de0b6" translate="yes" xml:space="preserve">
          <source>Mapping for such special cases are taken from &lt;code&gt;special-uppercase&lt;/code&gt;, &lt;code&gt;special-lowercase&lt;/code&gt; and &lt;code&gt;special-titlecase&lt;/code&gt; See &lt;a href=&quot;character-properties#Character-Properties&quot;&gt;Character Properties&lt;/a&gt;.</source>
          <target state="translated">이러한 특수 사례에 대한 매핑은 &lt;code&gt;special-uppercase&lt;/code&gt; , &lt;code&gt;special-lowercase&lt;/code&gt; 및 &lt;code&gt;special-titlecase&lt;/code&gt; 에서 가져옵니다 . &lt;a href=&quot;character-properties#Character-Properties&quot;&gt;문자 속성&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="f093ddf02abeed7e13d39bb01f441baf4324273f" translate="yes" xml:space="preserve">
          <source>Margins for Filling</source>
          <target state="translated">채우기 여백</target>
        </trans-unit>
        <trans-unit id="e693e76b5d2e33add6fdff9ff18a57f6b466043e" translate="yes" xml:space="preserve">
          <source>Mark set</source>
          <target state="translated">마크 세트</target>
        </trans-unit>
        <trans-unit id="40c9d9aab143333b8799668f89011a977e366648" translate="yes" xml:space="preserve">
          <source>Mark the function or macro as obsolete, similar to a call to &lt;code&gt;make-obsolete&lt;/code&gt; (see &lt;a href=&quot;obsolete-functions#Obsolete-Functions&quot;&gt;Obsolete Functions&lt;/a&gt;). &lt;var&gt;current-name&lt;/var&gt; should be a symbol (in which case the warning message says to use that instead), a string (specifying the warning message), or &lt;code&gt;nil&lt;/code&gt; (in which case the warning message gives no extra details). &lt;var&gt;when&lt;/var&gt; should be a string indicating when the function or macro was first made obsolete.</source>
          <target state="translated">&lt;code&gt;make-obsolete&lt;/code&gt; 호출과 유사하게 함수 또는 매크로를 더 이상 사용되지 않음으로 표시합니다 ( &lt;a href=&quot;obsolete-functions#Obsolete-Functions&quot;&gt;Obsolete Functions&lt;/a&gt; 참조 ). &lt;var&gt;current-name&lt;/var&gt; 은 기호 (이 경우 경고 메시지가 대신 사용하라고 표시됨), 문자열 (경고 메시지 지정) 또는 &lt;code&gt;nil&lt;/code&gt; (이 경우 경고 메시지가 추가 세부 사항을 제공하지 않음 )이어야합니다 . &lt;var&gt;when&lt;/var&gt; 은 함수 또는 매크로가 처음 폐기 된시기를 나타내는 문자열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="75ec2d229775005fdc921c3a210ff1b8c8b13b6e" translate="yes" xml:space="preserve">
          <source>Marker Insertion Types</source>
          <target state="translated">마커 삽입 유형</target>
        </trans-unit>
        <trans-unit id="20a369b8d549cf56bd368b32f6f9b7f7febde165" translate="yes" xml:space="preserve">
          <source>Marker Type</source>
          <target state="translated">마커 유형</target>
        </trans-unit>
        <trans-unit id="c64fa883b0b011047af44d0deea4165129c087b1" translate="yes" xml:space="preserve">
          <source>Markers</source>
          <target state="translated">Markers</target>
        </trans-unit>
        <trans-unit id="3a15c9c37c23f1de054f9f2fb2d0661fb9245c11" translate="yes" xml:space="preserve">
          <source>Markers have no read syntax. They print in hash notation, giving the current character position and the name of the buffer.</source>
          <target state="translated">마커에는 읽기 구문이 없습니다. 해시 표기법으로 인쇄하여 현재 문자 위치와 버퍼 이름을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="90ec4189b2e9a955fa94b8f4c8d3ea5a03189fdd" translate="yes" xml:space="preserve">
          <source>Markers pointing into any sort records are left with no useful position after &lt;code&gt;sort-subr&lt;/code&gt; returns.</source>
          <target state="translated">정렬 레코드를 가리키는 마커는 &lt;code&gt;sort-subr&lt;/code&gt; 이 리턴 된 후 유용한 위치가없이 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6e97fbd0e2de79918f6c8ca8bf38d32ac3071bf" translate="yes" xml:space="preserve">
          <source>Markers represent positions and update automatically when the text is changed.</source>
          <target state="translated">마커는 위치를 나타내며 텍스트가 변경되면 자동으로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="c3ffcb290c16e09210daad56e90773ef95a42fa0" translate="yes" xml:space="preserve">
          <source>Marking multiline chunks with a text property.</source>
          <target state="translated">텍스트 속성으로 여러 줄 청크 표시.</target>
        </trans-unit>
        <trans-unit id="adb842e548d37ba30e15d8d71ecca123602b790c" translate="yes" xml:space="preserve">
          <source>Marks the selected window as non-dedicated and proceeds.</source>
          <target state="translated">선택한 창을 비 전용으로 표시하고 계속 진행합니다.</target>
        </trans-unit>
        <trans-unit id="63136e6c72133709fdd14fe590280a9e7adfb5ae" translate="yes" xml:space="preserve">
          <source>Match &lt;var&gt;rx&lt;/var&gt;, with &lt;code&gt;zero-or-more&lt;/code&gt;, &lt;code&gt;0+&lt;/code&gt;, &lt;code&gt;one-or-more&lt;/code&gt;, &lt;code&gt;1+&lt;/code&gt;, &lt;code&gt;zero-or-one&lt;/code&gt;, &lt;code&gt;opt&lt;/code&gt; and &lt;code&gt;optional&lt;/code&gt; using greedy matching. This is the default.</source>
          <target state="translated">매치 &lt;var&gt;rx&lt;/var&gt; 와, &lt;code&gt;zero-or-more&lt;/code&gt; , &lt;code&gt;0+&lt;/code&gt; , &lt;code&gt;one-or-more&lt;/code&gt; , &lt;code&gt;1+&lt;/code&gt; , &lt;code&gt;zero-or-one&lt;/code&gt; , &lt;code&gt;opt&lt;/code&gt; 및 &lt;code&gt;optional&lt;/code&gt; 욕심 일치를 사용하여. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="2e1d4ec9e304a391aeeff942a7e3f04f60b8de56" translate="yes" xml:space="preserve">
          <source>Match &lt;var&gt;rx&lt;/var&gt;, with &lt;code&gt;zero-or-more&lt;/code&gt;, &lt;code&gt;0+&lt;/code&gt;, &lt;code&gt;one-or-more&lt;/code&gt;, &lt;code&gt;1+&lt;/code&gt;, &lt;code&gt;zero-or-one&lt;/code&gt;, &lt;code&gt;opt&lt;/code&gt; and &lt;code&gt;optional&lt;/code&gt; using non-greedy matching.</source>
          <target state="translated">매치 &lt;var&gt;rx&lt;/var&gt; 와, &lt;code&gt;zero-or-more&lt;/code&gt; , &lt;code&gt;0+&lt;/code&gt; , &lt;code&gt;one-or-more&lt;/code&gt; , &lt;code&gt;1+&lt;/code&gt; , &lt;code&gt;zero-or-one&lt;/code&gt; , &lt;code&gt;opt&lt;/code&gt; 및 &lt;code&gt;optional&lt;/code&gt; 사용하여 비 욕심 일치.</target>
        </trans-unit>
        <trans-unit id="71abe0286e229c1d876f4a021f7e016ea6b1fc99" translate="yes" xml:space="preserve">
          <source>Match a character from a named character class:</source>
          <target state="translated">명명 된 문자 클래스의 문자와 일치 :</target>
        </trans-unit>
        <trans-unit id="ad6d6fc231dbd73dfc165b65f61e36d58bad1af7" translate="yes" xml:space="preserve">
          <source>Match a character in category &lt;var&gt;category&lt;/var&gt;, which is either one of the names below or its category character.</source>
          <target state="translated">아래 이름 중 하나이거나 해당 범주 문자 인 category &lt;var&gt;category&lt;/var&gt; 의 문자와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="de8031dd3712abe87445e83aadf5d0e6910dc120" translate="yes" xml:space="preserve">
          <source>Match a character included in all of the &lt;var&gt;charset&lt;/var&gt;s. Each &lt;var&gt;charset&lt;/var&gt; can be a character, a single-character string, an &lt;code&gt;any&lt;/code&gt; form without character classes, or an &lt;code&gt;intersection&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt; or &lt;code&gt;not&lt;/code&gt; form whose arguments are also &lt;var&gt;charset&lt;/var&gt;s.</source>
          <target state="translated">모든 &lt;var&gt;charset&lt;/var&gt; 에 포함 된 문자와 일치합니다 . 각 &lt;var&gt;charset&lt;/var&gt; 캐릭터, 단일 문자열, 될 수 &lt;code&gt;any&lt;/code&gt; 문자 클래스없는 형태로, 또는 &lt;code&gt;intersection&lt;/code&gt; , &lt;code&gt;or&lt;/code&gt; 나 &lt;code&gt;not&lt;/code&gt; , 그 인수 또한 형태의 &lt;var&gt;charset&lt;/var&gt; 들.</target>
        </trans-unit>
        <trans-unit id="1d6ce8155afacb2f041062878ec1c97fa63888c6" translate="yes" xml:space="preserve">
          <source>Match a character not included in &lt;var&gt;charspec&lt;/var&gt;. &lt;var&gt;charspec&lt;/var&gt; can be a character, a single-character string, an &lt;code&gt;any&lt;/code&gt;, &lt;code&gt;not&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, &lt;code&gt;intersection&lt;/code&gt;, &lt;code&gt;syntax&lt;/code&gt; or &lt;code&gt;category&lt;/code&gt; form, or a character class. If &lt;var&gt;charspec&lt;/var&gt; is an &lt;code&gt;or&lt;/code&gt; form, its arguments have the same restrictions as those of &lt;code&gt;intersection&lt;/code&gt;; see below. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;charspec&lt;/var&gt; 에 포함되지 않은 문자와 일치합니다 . &lt;var&gt;charspec&lt;/var&gt; 는 문자, 단일 문자열,이 될 수 &lt;code&gt;any&lt;/code&gt; , &lt;code&gt;not&lt;/code&gt; , &lt;code&gt;or&lt;/code&gt; , &lt;code&gt;intersection&lt;/code&gt; , &lt;code&gt;syntax&lt;/code&gt; 또는 &lt;code&gt;category&lt;/code&gt; 형태, 또는 문자 클래스. 경우 &lt;var&gt;charspec&lt;/var&gt; 가 이다 &lt;code&gt;or&lt;/code&gt; 형태의 인수의 것과 동일한 제한이 &lt;code&gt;intersection&lt;/code&gt; ; 아래를 참조하십시오. 해당 문자열 regexp : '</target>
        </trans-unit>
        <trans-unit id="20528df965fcdab88638f3141ed3bb0a4816a094" translate="yes" xml:space="preserve">
          <source>Match a character with syntax &lt;var&gt;syntax&lt;/var&gt;, being one of the following names:</source>
          <target state="translated">다음 이름 중 하나 인 구문 &lt;var&gt;syntax&lt;/var&gt; 있는 문자를 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="d97d65b8ec18624513dc0b5597c7a311786d6e2f" translate="yes" xml:space="preserve">
          <source>Match a single character from one of the &lt;var&gt;set&lt;/var&gt;s. Each &lt;var&gt;set&lt;/var&gt; is a character, a string representing the set of its characters, a range or a character class (see below). A range is either a hyphen-separated string like &lt;code&gt;&quot;A-Z&quot;&lt;/code&gt;, or a cons of characters like &lt;code&gt;(?A . ?Z)&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;set&lt;/var&gt; 중 하나의 단일 문자와 일치합니다 . 각 &lt;var&gt;set&lt;/var&gt; 는 문자, 문자 세트를 나타내는 문자열, 범위 또는 문자 클래스입니다 (아래 참조). 범위는 &lt;code&gt;&quot;A-Z&quot;&lt;/code&gt; 와 같이 하이픈으로 구분 된 문자열 이거나 &lt;code&gt;(?A . ?Z)&lt;/code&gt; 와 같은 문자의 단점입니다 .</target>
        </trans-unit>
        <trans-unit id="2dd2fbec99fc2ab616903412ba0cff721c4c9e90" translate="yes" xml:space="preserve">
          <source>Match alphabetic characters and digits. More precisely, match characters whose Unicode &amp;lsquo;</source>
          <target state="translated">알파벳 문자와 숫자를 일치시킵니다. 보다 정확하게는 유니 코드 '</target>
        </trans-unit>
        <trans-unit id="82708ce98f9d023741d282ec7721747edbd6f773" translate="yes" xml:space="preserve">
          <source>Match alphabetic characters. More precisely, match characters whose Unicode &amp;lsquo;</source>
          <target state="translated">알파벳 문자와 일치합니다. 보다 정확하게는 유니 코드 '</target>
        </trans-unit>
        <trans-unit id="8bb62c1f38a88090666bab18fcce11f7a820ad8a" translate="yes" xml:space="preserve">
          <source>Match any</source>
          <target state="translated">일치</target>
        </trans-unit>
        <trans-unit id="c6bedd2c326b64596143cbeea5bbc65702a26806" translate="yes" xml:space="preserve">
          <source>Match any character except a newline. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">개행을 제외한 모든 문자와 일치합니다. 해당 문자열 regexp : '</target>
        </trans-unit>
        <trans-unit id="cc22989554162915a08cc2b0ae06291b07457a73" translate="yes" xml:space="preserve">
          <source>Match any character except whitespace,</source>
          <target state="translated">공백을 제외한 모든 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="7e7f303c256818204aa47a2cf16fd245fafcb2e6" translate="yes" xml:space="preserve">
          <source>Match any character that has whitespace syntax (see &lt;a href=&quot;syntax-class-table#Syntax-Class-Table&quot;&gt;Syntax Class Table&lt;/a&gt;).</source>
          <target state="translated">공백 구문이있는 모든 문자와 일치합니다 ( &lt;a href=&quot;syntax-class-table#Syntax-Class-Table&quot;&gt;구문 클래스 테이블&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="20fbfb2c118e7dfaf594921c0c9ef8d863759b77" translate="yes" xml:space="preserve">
          <source>Match any character that has word syntax (see &lt;a href=&quot;syntax-class-table#Syntax-Class-Table&quot;&gt;Syntax Class Table&lt;/a&gt;).</source>
          <target state="translated">단어 구문이있는 모든 문자와 일치합니다 ( &lt;a href=&quot;syntax-class-table#Syntax-Class-Table&quot;&gt;구문 클래스 테이블&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="68242dc98a557b85cf91e4b3c6ac38743362dde2" translate="yes" xml:space="preserve">
          <source>Match any character whose code is in the range 0&amp;ndash;31.</source>
          <target state="translated">코드가 0-31 범위에있는 모든 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="a9facac9ba78f72ef2c064b0654d33707cf5d808" translate="yes" xml:space="preserve">
          <source>Match any character. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">모든 문자와 일치합니다. 해당 문자열 regexp : '</target>
        </trans-unit>
        <trans-unit id="d134eaf7cc09f30a884da1beb70b95fea1c42f48" translate="yes" xml:space="preserve">
          <source>Match any non-</source>
          <target state="translated">비</target>
        </trans-unit>
        <trans-unit id="ef8bad91a3175348513872b6c54736f0c4acdee3" translate="yes" xml:space="preserve">
          <source>Match any punctuation character. (At present, for multibyte characters, anything that has non-word syntax.)</source>
          <target state="translated">구두점 문자와 일치합니다. (현재 멀티 바이트 문자의 경우 비 단어 구문이있는 모든 것)</target>
        </trans-unit>
        <trans-unit id="b234e5cee3141027589e4ab45ac9e2ef3aef0df9" translate="yes" xml:space="preserve">
          <source>Match anything lower-case, as determined by the current case table. If &lt;code&gt;case-fold-search&lt;/code&gt; is non-nil, this also matches any upper-case letter.</source>
          <target state="translated">현재 케이스 테이블에 의해 결정된대로 소문자와 일치합니다. 경우 &lt;code&gt;case-fold-search&lt;/code&gt; nil이 아닌이며, 이것은 또한 모든 대문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="b2217b7ab7ecff3396b14564129755a0ed8ebb52" translate="yes" xml:space="preserve">
          <source>Match anything upper-case, as determined by the current case table. If &lt;code&gt;case-fold-search&lt;/code&gt; is non-nil, this also matches any lower-case letter.</source>
          <target state="translated">현재 케이스 테이블에 의해 결정된 모든 대문자와 일치합니다. 경우 &lt;code&gt;case-fold-search&lt;/code&gt; nil이 아닌이며, 이것은 또한 모든 소문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="407d34a704815e72fde4647d011a88e9c5656f33" translate="yes" xml:space="preserve">
          <source>Match anywhere but at the beginning or end of a word. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">단어의 시작 또는 끝을 제외한 모든 위치에서 일치합니다. 해당 문자열 regexp : '</target>
        </trans-unit>
        <trans-unit id="a152ee853f24a37ea457df3b8d2fdc8d7fc9b34c" translate="yes" xml:space="preserve">
          <source>Match at point. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">지점에서 일치합니다. 해당 문자열 regexp : '</target>
        </trans-unit>
        <trans-unit id="f259a5bdb641748dc6291dbf1194b2479f6cc58c" translate="yes" xml:space="preserve">
          <source>Match at the beginning of a line. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">줄의 시작 부분에서 일치합니다. 해당 문자열 regexp : '</target>
        </trans-unit>
        <trans-unit id="381a3b6056cd0802e4c2d50199de3b52bc4cc745" translate="yes" xml:space="preserve">
          <source>Match at the beginning of a symbol. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">기호의 시작 부분에서 일치합니다. 해당 문자열 regexp : '</target>
        </trans-unit>
        <trans-unit id="06202c9463fb84fe0562bd42d6d713a2880e374b" translate="yes" xml:space="preserve">
          <source>Match at the beginning of a word. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">단어의 시작 부분에서 일치합니다. 해당 문자열 regexp : '</target>
        </trans-unit>
        <trans-unit id="96950b0283f2ce0a0d3b906dc2439e842ea803e8" translate="yes" xml:space="preserve">
          <source>Match at the beginning or end of a word. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">단어의 시작 또는 끝에서 일치합니다. 해당 문자열 regexp : '</target>
        </trans-unit>
        <trans-unit id="44efaac71dd0cf46b4e63e407bdb35817ac76578" translate="yes" xml:space="preserve">
          <source>Match at the end of a line. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">줄 끝에서 일치합니다. 해당 문자열 regexp : '</target>
        </trans-unit>
        <trans-unit id="290249cf5c2235f1cd6f27816d45a80df534d2c5" translate="yes" xml:space="preserve">
          <source>Match at the end of a symbol. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">기호의 끝에서 일치합니다. 해당 문자열 regexp : '</target>
        </trans-unit>
        <trans-unit id="e8ba6be4fdd0b132f04646bba49b7c6fc783a283" translate="yes" xml:space="preserve">
          <source>Match at the end of a word. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">단어의 끝에서 일치합니다. 해당 문자열 regexp : '</target>
        </trans-unit>
        <trans-unit id="c43211f21a3160a9d519576413e4b08b88f31ae7" translate="yes" xml:space="preserve">
          <source>Match at the end of the string or buffer being matched against. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">일치하는 문자열 또는 버퍼의 끝에서 일치합니다. 해당 문자열 regexp : '</target>
        </trans-unit>
        <trans-unit id="8efde31ba8632a39a1c15dd9f32b844f802c7c3d" translate="yes" xml:space="preserve">
          <source>Match at the start of the string or buffer being matched against. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">일치하는 문자열 또는 버퍼의 시작 부분에서 일치합니다. 해당 문자열 regexp : '</target>
        </trans-unit>
        <trans-unit id="b731924293870a882dd28691dfcda9844f7ce67b" translate="yes" xml:space="preserve">
          <source>Match exactly one of the &lt;var&gt;rx&lt;/var&gt;s. If all arguments are strings, characters, or &lt;code&gt;or&lt;/code&gt; forms so constrained, the longest possible match will always be used. Otherwise, either the longest match or the first (in left-to-right order) will be used. Without arguments, the expression will not match anything at all. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;rx&lt;/var&gt; 중 정확히 하나와 일치합니다 . 모든 인수가 문자열, 문자 &lt;code&gt;or&lt;/code&gt; 양식이므로 제한되는 경우 항상 가능한 가장 긴 일치 항목이 사용됩니다. 그렇지 않으면 가장 긴 일치 또는 첫 번째 (왼쪽에서 오른쪽 순서로)가 사용됩니다. 인수가 없으면 표현식이 전혀 일치하지 않습니다. 해당 문자열 regexp : '</target>
        </trans-unit>
        <trans-unit id="7248472c4540b5bb98fb3d7078116ee5540becd2" translate="yes" xml:space="preserve">
          <source>Match horizontal whitespace. More precisely, match characters whose Unicode &amp;lsquo;</source>
          <target state="translated">수평 공백과 일치합니다. 보다 정확하게는 유니 코드 '</target>
        </trans-unit>
        <trans-unit id="39ffee8a3eb0d7a19803afa6abf19912b7bfc01e" translate="yes" xml:space="preserve">
          <source>Match the &lt;var&gt;rx&lt;/var&gt;s &lt;var&gt;n&lt;/var&gt; or more times. Greedy. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;rx&lt;/var&gt; s를 &lt;var&gt;n&lt;/var&gt; 번 이상 일치시킵니다 . 욕심. 해당 문자열 regexp : '</target>
        </trans-unit>
        <trans-unit id="88b7d7bd4b35ad1b528a3b8246e2f6305909616e" translate="yes" xml:space="preserve">
          <source>Match the &lt;var&gt;rx&lt;/var&gt;s at least &lt;var&gt;n&lt;/var&gt; but no more than &lt;var&gt;m&lt;/var&gt; times. Greedy. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;rx&lt;/var&gt; s를 &lt;var&gt;n&lt;/var&gt; 번 이상 &lt;var&gt;m&lt;/var&gt; 번 이하로 일치시킵니다 . 욕심. 해당 문자열 regexp : '</target>
        </trans-unit>
        <trans-unit id="de1b336fa7f4a968c25a0903b00419f673937ea9" translate="yes" xml:space="preserve">
          <source>Match the &lt;var&gt;rx&lt;/var&gt;s exactly &lt;var&gt;n&lt;/var&gt; times. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;rx&lt;/var&gt; s를 정확히 &lt;var&gt;n&lt;/var&gt; 번 일치시킵니다 . 해당 문자열 regexp : '</target>
        </trans-unit>
        <trans-unit id="54969cf7c5583dafecdf62c967082837d0ecd45e" translate="yes" xml:space="preserve">
          <source>Match the &lt;var&gt;rx&lt;/var&gt;s in sequence. Without arguments, the expression matches the empty string. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;rx&lt;/var&gt; 를 순서대로 일치시킵니다 . 인수가 없으면 식은 빈 문자열과 일치합니다. 해당 문자열 regexp : '</target>
        </trans-unit>
        <trans-unit id="812a5d6c5321c4869a91d7591bbf90a4ff04128c" translate="yes" xml:space="preserve">
          <source>Match the &lt;var&gt;rx&lt;/var&gt;s once or an empty string. Greedy by default. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;rx&lt;/var&gt; 를 한 번 또는 빈 문자열과 일치시킵니다 . 기본적으로 욕심. 해당 문자열 regexp : '</target>
        </trans-unit>
        <trans-unit id="9d0e81755a90f55e663c35482e9b674dfc7de4d6" translate="yes" xml:space="preserve">
          <source>Match the &lt;var&gt;rx&lt;/var&gt;s once or an empty string. Greedy. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;rx&lt;/var&gt; 를 한 번 또는 빈 문자열과 일치시킵니다 . 욕심. 해당 문자열 regexp : '</target>
        </trans-unit>
        <trans-unit id="fd8b263c55e5ec0df49c18d0e47fbf0a1224d33d" translate="yes" xml:space="preserve">
          <source>Match the &lt;var&gt;rx&lt;/var&gt;s one or more times. Greedy by default. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;rx&lt;/var&gt; s를 한 번 이상 일치시킵니다 . 기본적으로 욕심. 해당 문자열 regexp : '</target>
        </trans-unit>
        <trans-unit id="2490a514c7217f45471d9b7c69875762fbd73841" translate="yes" xml:space="preserve">
          <source>Match the &lt;var&gt;rx&lt;/var&gt;s one or more times. Greedy. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;rx&lt;/var&gt; s를 한 번 이상 일치시킵니다 . 욕심. 해당 문자열 regexp : '</target>
        </trans-unit>
        <trans-unit id="5f0c30af008a7a0ac54edf6206107e136e38294e" translate="yes" xml:space="preserve">
          <source>Match the &lt;var&gt;rx&lt;/var&gt;s one or more times. Non-greedy. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;rx&lt;/var&gt; s를 한 번 이상 일치시킵니다 . 탐욕스럽지 않습니다. 해당 문자열 regexp : '</target>
        </trans-unit>
        <trans-unit id="83cd886da13deacda47e2fa48ca143a7370599e2" translate="yes" xml:space="preserve">
          <source>Match the &lt;var&gt;rx&lt;/var&gt;s or an empty string. Non-greedy. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;rx&lt;/var&gt; 또는 빈 문자열과 일치합니다 . 탐욕스럽지 않습니다. 해당 문자열 regexp : '</target>
        </trans-unit>
        <trans-unit id="3ab134fd7cf12648498ed41926f7c6ef78bd3c0f" translate="yes" xml:space="preserve">
          <source>Match the &lt;var&gt;rx&lt;/var&gt;s zero or more times. Greedy by default. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;rx&lt;/var&gt; s를 0 번 이상 일치시킵니다 . 기본적으로 욕심. 해당 문자열 regexp : '</target>
        </trans-unit>
        <trans-unit id="d5a7ac9731ccc96d5cf2d592aa59dafb6c31bd41" translate="yes" xml:space="preserve">
          <source>Match the &lt;var&gt;rx&lt;/var&gt;s zero or more times. Greedy. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;rx&lt;/var&gt; s를 0 번 이상 일치시킵니다 . 욕심. 해당 문자열 regexp : '</target>
        </trans-unit>
        <trans-unit id="f105243e42ef3ab66e32f5d3b154f392aaed42cc" translate="yes" xml:space="preserve">
          <source>Match the &lt;var&gt;rx&lt;/var&gt;s zero or more times. Non-greedy. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;rx&lt;/var&gt; s를 0 번 이상 일치시킵니다 . 탐욕스럽지 않습니다. 해당 문자열 regexp : '</target>
        </trans-unit>
        <trans-unit id="5fe3267ec0ff2cb20b90f39f1574039c8a4d6b35" translate="yes" xml:space="preserve">
          <source>Match the &lt;var&gt;rx&lt;/var&gt;s, making the matched text and position accessible in the match data. The first group in a regexp is numbered 1; subsequent groups will be numbered one higher than the previous group. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">경기 &lt;var&gt;rx&lt;/var&gt; 경기 데이터에 일치하는 텍스트 및 위치에 액세스 할 수 있도록,들. 정규 표현식의 첫 번째 그룹은 1로 번호가 지정됩니다. 후속 그룹은 이전 그룹보다 1 더 높은 번호가 지정됩니다. 해당 문자열 regexp : '</target>
        </trans-unit>
        <trans-unit id="d7ef5aa9b8bbb06530907d3195d5d192d80e7284" translate="yes" xml:space="preserve">
          <source>Match the character &amp;lsquo;</source>
          <target state="translated">문자 '</target>
        </trans-unit>
        <trans-unit id="40ed76ce7b1c68d6b3c8c8bd4b855cfc96f6c033" translate="yes" xml:space="preserve">
          <source>Match the digits &amp;lsquo;</source>
          <target state="translated">숫자 '</target>
        </trans-unit>
        <trans-unit id="365ffcf90847f5dfedeacb92fb74bfd5ac33dc8a" translate="yes" xml:space="preserve">
          <source>Match the hexadecimal digits &amp;lsquo;</source>
          <target state="translated">16 진수 '</target>
        </trans-unit>
        <trans-unit id="4a6978bcd14cd4f93782a8738d7349ba0d760be5" translate="yes" xml:space="preserve">
          <source>Match the literal string that is the result from evaluating the Lisp expression &lt;var&gt;expr&lt;/var&gt;. The evaluation takes place at call time, in the current lexical environment.</source>
          <target state="translated">Lisp 표현식 &lt;var&gt;expr&lt;/var&gt; 을 평가 한 결과 인 리터럴 문자열과 일치합니다 . 평가는 현재 어휘 환경에서 호출 시간에 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="1b502a84ddadc23f3da402b6793e0b908501bce7" translate="yes" xml:space="preserve">
          <source>Match the rx form that is the result from evaluating the Lisp expression &lt;var&gt;expr&lt;/var&gt;. The evaluation takes place at macro-expansion time for &lt;code&gt;rx&lt;/code&gt;, at call time for &lt;code&gt;rx-to-string&lt;/code&gt;, in the current global environment.</source>
          <target state="translated">Lisp 표현식 &lt;var&gt;expr&lt;/var&gt; 을 평가 한 결과 인 rx 형식과 일치합니다 . 평가는 현재 전역 환경 에서 &lt;code&gt;rx&lt;/code&gt; 에 대한 매크로 확장 시간 , &lt;code&gt;rx-to-string&lt;/code&gt; 에 대한 호출 시간에 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="3205c51d28824b4cbb8711f257894d8bb4c2f6f1" translate="yes" xml:space="preserve">
          <source>Match the string &amp;lsquo;</source>
          <target state="translated">문자열 '</target>
        </trans-unit>
        <trans-unit id="7b75719d500955e334549481f6c7ea7b50a1ad73" translate="yes" xml:space="preserve">
          <source>Match the string regexp that is the result from evaluating the Lisp expression &lt;var&gt;expr&lt;/var&gt;. The evaluation takes place at call time, in the current lexical environment.</source>
          <target state="translated">Lisp 표현식 &lt;var&gt;expr&lt;/var&gt; 을 평가 한 결과 인 문자열 regexp와 일치합니다 . 평가는 현재 어휘 환경에서 호출 시간에 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="ae757acb76ba91417eef2b42ffb76c4521c4b810" translate="yes" xml:space="preserve">
          <source>Match the text previously matched by group number &lt;var&gt;n&lt;/var&gt;. &lt;var&gt;n&lt;/var&gt; must be in the range 1&amp;ndash;9. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">이전에 그룹 번호 &lt;var&gt;n&lt;/var&gt; 과 일치하는 텍스트와 일치합니다 . &lt;var&gt;n&lt;/var&gt; 은 1-9 범위에 있어야합니다. 해당 문자열 regexp : '</target>
        </trans-unit>
        <trans-unit id="a9d49dbe39ad1efa260b09b12e904b32531ad43c" translate="yes" xml:space="preserve">
          <source>Match whitespace or a character matched by &lt;code&gt;graph&lt;/code&gt;.</source>
          <target state="translated">공백 또는 &lt;code&gt;graph&lt;/code&gt; 와 일치하는 문자와 일치 합니다 .</target>
        </trans-unit>
        <trans-unit id="54273900d77a58b496b801254cfc591edb749bf9" translate="yes" xml:space="preserve">
          <source>Matches any &lt;var&gt;expval&lt;/var&gt;, and additionally let-binds &lt;var&gt;symbol&lt;/var&gt; to &lt;var&gt;expval&lt;/var&gt;, such that this binding is available to &lt;var&gt;body-forms&lt;/var&gt; (see &lt;a href=&quot;dynamic-binding#Dynamic-Binding&quot;&gt;Dynamic Binding&lt;/a&gt;).</source>
          <target state="translated">모든 &lt;var&gt;expval&lt;/var&gt; 과 일치 하고 추가로 &lt;var&gt;symbol&lt;/var&gt; 를 &lt;var&gt;expval&lt;/var&gt; 에 let-binds 하여이 바인딩을 &lt;var&gt;body-forms&lt;/var&gt; 에서 사용할 수 있도록 합니다 ( &lt;a href=&quot;dynamic-binding#Dynamic-Binding&quot;&gt;동적 바인딩&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="132befd5d9407a174f4ad033d6cea023a4b37857" translate="yes" xml:space="preserve">
          <source>Matches any &lt;var&gt;expval&lt;/var&gt;. This is also known as &lt;em&gt;don&amp;rsquo;t care&lt;/em&gt; or &lt;em&gt;wildcard&lt;/em&gt;.</source>
          <target state="translated">모든 &lt;var&gt;expval&lt;/var&gt; 과 일치합니다 . 이것은 &lt;em&gt;무정의&lt;/em&gt; 또는 &lt;em&gt;와일드 카드&lt;/em&gt; 라고도 합니다.</target>
        </trans-unit>
        <trans-unit id="282c53348f7fcd0ad68d33bb9c7f6cccc54a4565" translate="yes" xml:space="preserve">
          <source>Matches if &lt;var&gt;boolean-expression&lt;/var&gt; evaluates to non-&lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;boolean-expression&lt;/var&gt; 이 &lt;code&gt;nil&lt;/code&gt; 이 아닌 것으로 평가 되면 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="257d039f7b35b3e0442ca76380b5ef90a0d77303" translate="yes" xml:space="preserve">
          <source>Matches if &lt;var&gt;expval&lt;/var&gt; equals &lt;var&gt;val&lt;/var&gt;. The comparison is done as if by &lt;code&gt;equal&lt;/code&gt; (see &lt;a href=&quot;equality-predicates#Equality-Predicates&quot;&gt;Equality Predicates&lt;/a&gt;).</source>
          <target state="translated">&lt;var&gt;expval&lt;/var&gt; 이 &lt;var&gt;val&lt;/var&gt; 과 같으면 일치합니다 . 비교는 &lt;code&gt;equal&lt;/code&gt; 수행됩니다 ( &lt;a href=&quot;equality-predicates#Equality-Predicates&quot;&gt;동등 술어&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="0b1481ca7fe064087aacfb37775ecc46665629cf" translate="yes" xml:space="preserve">
          <source>Matches if &lt;var&gt;expval&lt;/var&gt; equals the literal object. This is a special case of &lt;code&gt;'&lt;var&gt;val&lt;/var&gt;&lt;/code&gt;, above, possible because literal objects of these types are self-quoting.</source>
          <target state="translated">&lt;var&gt;expval&lt;/var&gt; 이 리터럴 객체와 같으면 일치 합니다. 이것은 특별한 경우입니다 &lt;code&gt;'&lt;var&gt;val&lt;/var&gt;&lt;/code&gt; , 이러한 유형의 문자 객체가 위에서 가능하기 때문에 자기 인용.</target>
        </trans-unit>
        <trans-unit id="978883ed6eed2d6a28b654dbedeb42b8609b3fad" translate="yes" xml:space="preserve">
          <source>Matches if &lt;var&gt;expval&lt;/var&gt; is a cons cell whose &lt;code&gt;car&lt;/code&gt; matches &lt;var&gt;qpat1&lt;/var&gt; and whose &lt;code&gt;cdr&lt;/code&gt; matches &lt;var&gt;qpat2&lt;/var&gt;. This readily generalizes to lists as in &lt;code&gt;(&lt;var&gt;qpat1&lt;/var&gt;&amp;nbsp;&lt;var&gt;qpat2&lt;/var&gt;&amp;nbsp;&amp;hellip;)&lt;/code&gt;.</source>
          <target state="translated">일치하는 경우 &lt;var&gt;expval&lt;/var&gt; 가 단점 세포 인 &lt;code&gt;car&lt;/code&gt; 경기 &lt;var&gt;qpat1&lt;/var&gt; 누구의 &lt;code&gt;cdr&lt;/code&gt; 과 일치 &lt;var&gt;qpat2&lt;/var&gt; 가 . 이것은 &lt;code&gt;(&lt;var&gt;qpat1&lt;/var&gt;&amp;nbsp;&lt;var&gt;qpat2&lt;/var&gt;&amp;nbsp;&amp;hellip;)&lt;/code&gt; 와 같이 목록으로 쉽게 일반화됩니다 .</target>
        </trans-unit>
        <trans-unit id="8d421ecc7a203998190360c012b97d967bb56647" translate="yes" xml:space="preserve">
          <source>Matches if &lt;var&gt;expval&lt;/var&gt; is a vector of length &lt;var&gt;m&lt;/var&gt; whose &lt;code&gt;0&lt;/code&gt;..&lt;code&gt;(&lt;var&gt;m&lt;/var&gt;-1)&lt;/code&gt;th elements match &lt;var&gt;qpat1&lt;/var&gt;, &lt;var&gt;qpat2&lt;/var&gt; &amp;hellip; &lt;var&gt;qpatm&lt;/var&gt;, respectively.</source>
          <target state="translated">&lt;var&gt;expval&lt;/var&gt; 이 &lt;code&gt;0&lt;/code&gt; .. &lt;code&gt;(&lt;var&gt;m&lt;/var&gt;-1)&lt;/code&gt; &lt;var&gt;m&lt;/var&gt; -1) 번째 요소가 각각 &lt;var&gt;qpat1&lt;/var&gt; , &lt;var&gt;qpat2&lt;/var&gt; &amp;hellip; &lt;var&gt;qpatm&lt;/var&gt; 과 일치 하는 길이 &lt;var&gt;m&lt;/var&gt; 의 벡터 인 경우 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="7ae908cffb91a06454159f03a0002153cc9d96fb" translate="yes" xml:space="preserve">
          <source>Matches if &lt;var&gt;function&lt;/var&gt; called on &lt;var&gt;expval&lt;/var&gt; returns a value that matches &lt;var&gt;pattern&lt;/var&gt;. &lt;var&gt;function&lt;/var&gt; can take one of the forms described for &lt;code&gt;pred&lt;/code&gt;, above. Unlike &lt;code&gt;pred&lt;/code&gt;, however, &lt;code&gt;app&lt;/code&gt; tests the result against &lt;var&gt;pattern&lt;/var&gt;, rather than against a boolean truth value.</source>
          <target state="translated">경우 일치 &lt;var&gt;function&lt;/var&gt; 호출 &lt;var&gt;expval&lt;/var&gt; 반환과 일치하는 값 &lt;var&gt;pattern&lt;/var&gt; . &lt;var&gt;function&lt;/var&gt; 는 위의 &lt;code&gt;pred&lt;/code&gt; 에 대해 설명한 형식 중 하나를 취할 수 있습니다 . 달리 &lt;code&gt;pred&lt;/code&gt; , 그러나, &lt;code&gt;app&lt;/code&gt; 에 대한 결과를 테스트 &lt;var&gt;pattern&lt;/var&gt; 이 아니라 부울 진리 값에 대한보다.</target>
        </trans-unit>
        <trans-unit id="739f57f309dcf068954c6199fcd5d3b33f050610" translate="yes" xml:space="preserve">
          <source>Matches if the corresponding element of &lt;var&gt;expval&lt;/var&gt; is &lt;code&gt;equal&lt;/code&gt; to the specified literal object.</source>
          <target state="translated">일치하는 경우, 해당 엘리먼트 &lt;var&gt;expval&lt;/var&gt; 가 있다 &lt;code&gt;equal&lt;/code&gt; 지정된 문자 객체.</target>
        </trans-unit>
        <trans-unit id="674ff3b825d9ae7d265a12ff2ae08223fcb7d64f" translate="yes" xml:space="preserve">
          <source>Matches if the corresponding element of &lt;var&gt;expval&lt;/var&gt; matches &lt;var&gt;pattern&lt;/var&gt;. Note that &lt;var&gt;pattern&lt;/var&gt; is any kind that &lt;code&gt;pcase&lt;/code&gt; supports. (In the example above, &lt;code&gt;second-elem&lt;/code&gt; is a &lt;var&gt;symbol&lt;/var&gt; core pattern; it therefore matches anything, and let-binds &lt;code&gt;second-elem&lt;/code&gt;.)</source>
          <target state="translated">일치하는 경우, 해당 엘리먼트 &lt;var&gt;expval&lt;/var&gt; 가 일치하는 &lt;var&gt;pattern&lt;/var&gt; . 하는 것으로 &lt;var&gt;pattern&lt;/var&gt; 그 어떤 종류의 &lt;code&gt;pcase&lt;/code&gt; 의 지원은. (위의 예에서 &lt;code&gt;second-elem&lt;/code&gt; 은 &lt;var&gt;symbol&lt;/var&gt; 코어 패턴이므로 모든 항목과 일치하며 &lt;code&gt;second-elem&lt;/code&gt; 을 let-binds 합니다 .)</target>
        </trans-unit>
        <trans-unit id="1308a03f9d82916c80a7d812b1deda28157315b6" translate="yes" xml:space="preserve">
          <source>Matches if the predicate &lt;var&gt;function&lt;/var&gt; returns non-&lt;code&gt;nil&lt;/code&gt; when called on &lt;var&gt;expval&lt;/var&gt;. the predicate &lt;var&gt;function&lt;/var&gt; can have one of the following forms:</source>
          <target state="translated">조건 자 &lt;var&gt;function&lt;/var&gt; 가 &lt;var&gt;expval&lt;/var&gt; 에서 호출 될 때 &lt;code&gt;nil&lt;/code&gt; 이 아닌 값을 반환 하면 일치합니다 . 술어 &lt;var&gt;function&lt;/var&gt; 는 다음 양식 중 하나를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d30d930e31b7cc8d8611f9ee7e28b703c1f1f15" translate="yes" xml:space="preserve">
          <source>Matches strings against the regexp &lt;var&gt;rx-expr&lt;/var&gt;&amp;hellip;, using the &lt;code&gt;rx&lt;/code&gt; regexp notation (see &lt;a href=&quot;rx-notation#Rx-Notation&quot;&gt;Rx Notation&lt;/a&gt;), as if by &lt;code&gt;string-match&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;string-match&lt;/code&gt; 에서처럼 &lt;code&gt;rx&lt;/code&gt; regexp 표기법 ( &lt;a href=&quot;rx-notation#Rx-Notation&quot;&gt;Rx 표기법&lt;/a&gt; 참조)을 사용하여 regexp &lt;var&gt;rx-expr&lt;/var&gt; &amp;hellip; 에 대해 문자열을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="4c220368bb4219d0ac89ca454946be8bddd2829b" translate="yes" xml:space="preserve">
          <source>Matching single characters</source>
          <target state="translated">단일 문자 일치</target>
        </trans-unit>
        <trans-unit id="0c2d501ea6626d380ec030a4b996efde369c2ab2" translate="yes" xml:space="preserve">
          <source>Measuring the resources that your code uses.</source>
          <target state="translated">코드에서 사용하는 리소스를 측정합니다.</target>
        </trans-unit>
        <trans-unit id="03a68b7d8b854f2e082850074e2a8ddc1224e602" translate="yes" xml:space="preserve">
          <source>Memory Usage</source>
          <target state="translated">메모리 사용량</target>
        </trans-unit>
        <trans-unit id="3b9c0cfb66cbc7f431d2be01c6c671bec7a34644" translate="yes" xml:space="preserve">
          <source>Menu Bar</source>
          <target state="translated">메뉴 바</target>
        </trans-unit>
        <trans-unit id="16caad169ee406031f21f23e1b6301b797fa0084" translate="yes" xml:space="preserve">
          <source>Menu Example</source>
          <target state="translated">메뉴 예</target>
        </trans-unit>
        <trans-unit id="b12062efe3af477059c284119d8434d41ae242a3" translate="yes" xml:space="preserve">
          <source>Menu Keymaps</source>
          <target state="translated">메뉴 키맵</target>
        </trans-unit>
        <trans-unit id="6fb0b0290e8b0a35d56be9fedd24c4318262e46c" translate="yes" xml:space="preserve">
          <source>Menu Separators</source>
          <target state="translated">메뉴 구분 기호</target>
        </trans-unit>
        <trans-unit id="15c6cdd8a7fcc3254e0110b90d40dcb9521b5c10" translate="yes" xml:space="preserve">
          <source>Menus and the Keyboard</source>
          <target state="translated">메뉴 및 키보드</target>
        </trans-unit>
        <trans-unit id="7ed3131770bb3cf28e7cdf82c3c9fbd8d687f5e1" translate="yes" xml:space="preserve">
          <source>Menus and the Mouse</source>
          <target state="translated">메뉴와 마우스</target>
        </trans-unit>
        <trans-unit id="c18bb98ae36a93e8052f0d6c9f161d8d49feaa19" translate="yes" xml:space="preserve">
          <source>Messages like &amp;lsquo;</source>
          <target state="translated">'와 같은 메시지</target>
        </trans-unit>
        <trans-unit id="8d546a6dea9ff90d517b51c25b35319931ae4e04" translate="yes" xml:space="preserve">
          <source>Meta</source>
          <target state="translated">Meta</target>
        </trans-unit>
        <trans-unit id="7d26ac8fefd98dd2e2239d0d83cfc7025404ed00" translate="yes" xml:space="preserve">
          <source>Meta-Character Syntax</source>
          <target state="translated">메타 문자 구문</target>
        </trans-unit>
        <trans-unit id="25523a0222c9047ee4b9673f05cad4ee5f070cad" translate="yes" xml:space="preserve">
          <source>Method definitions can make use of a new argument-list keyword, &lt;code&gt;&amp;amp;context&lt;/code&gt;, which introduces extra specializers that test the environment at the time the method is run. This keyword should appear after the list of required arguments, but before any &lt;code&gt;&amp;amp;rest&lt;/code&gt; or &lt;code&gt;&amp;amp;optional&lt;/code&gt; keywords. The &lt;code&gt;&amp;amp;context&lt;/code&gt; specializers look much like regular argument specializers&amp;mdash;(&lt;var&gt;expr&lt;/var&gt;&lt;var&gt;spec&lt;/var&gt;)&amp;mdash;except that &lt;var&gt;expr&lt;/var&gt; is an expression to be evaluated in the current context, and the &lt;var&gt;spec&lt;/var&gt; is a value to compare against. For example, &lt;code&gt;&amp;amp;context (overwrite-mode (eql t))&lt;/code&gt; will make the method applicable only when &lt;code&gt;overwrite-mode&lt;/code&gt; is turned on. The &lt;code&gt;&amp;amp;context&lt;/code&gt; keyword can be followed by any number of context specializers. Because the context specializers are not part of the generic function&amp;rsquo;s argument signature, they may be omitted in methods that don&amp;rsquo;t require them.</source>
          <target state="translated">메소드 정의는 새로운 argument-list 키워드 인 &lt;code&gt;&amp;amp;context&lt;/code&gt; 사용할 수 있습니다.이 키워드 는 메소드가 실행될 때 환경을 테스트하는 추가 전문가를 도입합니다. 이 키워드는 필수 인수 목록 뒤, &lt;code&gt;&amp;amp;rest&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;optional&lt;/code&gt; 키워드 앞에 표시되어야 합니다. &lt;code&gt;&amp;amp;context&lt;/code&gt; specializers 훨씬처럼 정규 인수 specializers- ( &lt;var&gt;expr&lt;/var&gt; &lt;var&gt;spec&lt;/var&gt; )에 빼고 것을 &lt;var&gt;expr&lt;/var&gt; 이 현재 콘텍스트에서 평가 될 수있는 표현이며, 상기 &lt;var&gt;spec&lt;/var&gt; 비교 대상 값이다. 예를 들어 &lt;code&gt;&amp;amp;context (overwrite-mode (eql t))&lt;/code&gt; 는 &lt;code&gt;overwrite-mode&lt;/code&gt; 가 켜져 있을 때만 메서드를 적용 할 수 있도록합니다 . 그만큼 &lt;code&gt;&amp;amp;context&lt;/code&gt; 키워드 뒤에는 여러 컨텍스트 전문가가 올 수 있습니다. 컨텍스트 전문화자는 제네릭 함수의 인수 서명의 일부가 아니기 때문에 필요하지 않은 메서드에서는 생략 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3814dd76362cfffd02ba4b1937ed1c2c87e7844e" translate="yes" xml:space="preserve">
          <source>Microsoft Windows NT, 9X and later. The value of &lt;code&gt;system-type&lt;/code&gt; is always &lt;code&gt;windows-nt&lt;/code&gt;, e.g., even on Windows 10.</source>
          <target state="translated">Microsoft Windows NT, 9X 이상. &lt;code&gt;system-type&lt;/code&gt; 의 값 은 항상 &lt;code&gt;windows-nt&lt;/code&gt; 입니다 . 예를 들어 Windows 10에서도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="2767e46afcc3ac1795e792eb132101e2b44c1778" translate="yes" xml:space="preserve">
          <source>Microsoft&amp;rsquo;s DOS. Emacs compiled with DJGPP for MS-DOS binds &lt;code&gt;system-type&lt;/code&gt; to &lt;code&gt;ms-dos&lt;/code&gt; even when you run it on MS-Windows.</source>
          <target state="translated">Microsoft의 DOS. MS-DOS 용 DJGPP로 컴파일 된 Emacs 는 MS-Windows에서 실행할 때에도 &lt;code&gt;system-type&lt;/code&gt; 을 &lt;code&gt;ms-dos&lt;/code&gt; 에 바인딩 합니다 .</target>
        </trans-unit>
        <trans-unit id="f9c9c8db7156a7448700d445deeeb649c319eb70" translate="yes" xml:space="preserve">
          <source>Minibuffer Commands</source>
          <target state="translated">미니 버퍼 명령</target>
        </trans-unit>
        <trans-unit id="b66e5aaaf448e820ada310fc0fc7cfcb0f0786b0" translate="yes" xml:space="preserve">
          <source>Minibuffer Commands that Do Completion</source>
          <target state="translated">완료를 수행하는 미니 버퍼 명령</target>
        </trans-unit>
        <trans-unit id="6a3f154cb3d12adeba658562da192d175d080908" translate="yes" xml:space="preserve">
          <source>Minibuffer Contents</source>
          <target state="translated">미니 버퍼 내용</target>
        </trans-unit>
        <trans-unit id="c9ecc01b5e1b40232e2354f19e5d6b7647cfab66" translate="yes" xml:space="preserve">
          <source>Minibuffer History</source>
          <target state="translated">미니 버퍼 기록</target>
        </trans-unit>
        <trans-unit id="5711d65bace0facc4ca32fe822109910ac6088d3" translate="yes" xml:space="preserve">
          <source>Minibuffer Miscellany</source>
          <target state="translated">미니 버퍼 기타</target>
        </trans-unit>
        <trans-unit id="7af96936c990ed708387e7161673b6638521b972" translate="yes" xml:space="preserve">
          <source>Minibuffer Windows</source>
          <target state="translated">미니 버퍼 창</target>
        </trans-unit>
        <trans-unit id="d3a911d1b2be32f6461ffe02d45b48c543df77a1" translate="yes" xml:space="preserve">
          <source>Minibuffer commands that do completion.</source>
          <target state="translated">완료를 수행하는 미니 버퍼 명령.</target>
        </trans-unit>
        <trans-unit id="d54ac200a7fb55100cb14bfbd0ecda71c040d192" translate="yes" xml:space="preserve">
          <source>Minibuffer input is a special kind of recursive editing. It has a few special wrinkles, such as enabling display of the minibuffer and the minibuffer window, but fewer than you might suppose. Certain keys behave differently in the minibuffer, but that is only because of the minibuffer&amp;rsquo;s local map; if you switch windows, you get the usual Emacs commands.</source>
          <target state="translated">미니 버퍼 입력은 특별한 종류의 재귀 편집입니다. 미니 버퍼와 미니 버퍼 창을 표시하는 것과 같은 몇 가지 특별한 주름이 있지만 예상보다 적습니다. 특정 키는 미니 버퍼에서 다르게 작동하지만 이는 미니 버퍼의 로컬 맵 때문입니다. 창을 전환하면 일반적인 Emacs 명령을 받게됩니다.</target>
        </trans-unit>
        <trans-unit id="367762892b20350b19f7bd8cd60d6489ac911db6" translate="yes" xml:space="preserve">
          <source>Minibuffers</source>
          <target state="translated">Minibuffers</target>
        </trans-unit>
        <trans-unit id="edccf3bc0f1044797feeb7318644812ec8808a04" translate="yes" xml:space="preserve">
          <source>Minibuffers and Frames</source>
          <target state="translated">미니 버퍼 및 프레임</target>
        </trans-unit>
        <trans-unit id="a6078aaad32f5816f061d4e9117bdbc1d7ee3400" translate="yes" xml:space="preserve">
          <source>Minimum value of &lt;code&gt;hscroll&lt;/code&gt;, set by the user via &lt;code&gt;set-window-hscroll&lt;/code&gt; (see &lt;a href=&quot;horizontal-scrolling#Horizontal-Scrolling&quot;&gt;Horizontal Scrolling&lt;/a&gt;). When only the current line is hscrolled, this describes the horizontal scrolling of lines other than the current one.</source>
          <target state="translated">사용자가 &lt;code&gt;set-window-hscroll&lt;/code&gt; 을 통해 설정 한 &lt;code&gt;hscroll&lt;/code&gt; 의 최소값입니다 ( &lt;a href=&quot;horizontal-scrolling#Horizontal-Scrolling&quot;&gt;수평 스크롤&lt;/a&gt; 참조 ). 현재 행만 hscroll 된 경우 현재 행이 아닌 행의 수평 스크롤을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="64f24a9a0dc69d512190fb4f05f76bebd963ffc9" translate="yes" xml:space="preserve">
          <source>Minor Modes</source>
          <target state="translated">부 모드</target>
        </trans-unit>
        <trans-unit id="63be5c97e7240142a22356e2f1777fc2c8d3904a" translate="yes" xml:space="preserve">
          <source>Minor modes may bind commands to key sequences consisting of</source>
          <target state="translated">부 모드는 다음으로 구성된 키 시퀀스에 명령을 바인딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8df431838fe5f9e1d63617cd34c66e591a88b4ec" translate="yes" xml:space="preserve">
          <source>Misc Network Facilities</source>
          <target state="translated">기타 네트워크 시설</target>
        </trans-unit>
        <trans-unit id="8e515a2e618367c7a4a06c28d8c1be931f8c03d1" translate="yes" xml:space="preserve">
          <source>Miscellaneous Convenience Functions for Modules</source>
          <target state="translated">모듈을위한 기타 편의 기능</target>
        </trans-unit>
        <trans-unit id="7a052e4f76928458969464505a52746d5a78fea2" translate="yes" xml:space="preserve">
          <source>Miscellaneous Edebug Commands</source>
          <target state="translated">기타 Edebug 명령</target>
        </trans-unit>
        <trans-unit id="a47827783224a9ce5dd490948eb1ebddc3b4d684" translate="yes" xml:space="preserve">
          <source>Miscellaneous Event Input Features</source>
          <target state="translated">기타 이벤트 입력 기능</target>
        </trans-unit>
        <trans-unit id="b29522452ab33d2ad0ba96dda015a6308c7b2c75" translate="yes" xml:space="preserve">
          <source>Miscellaneous System Events</source>
          <target state="translated">기타 시스템 이벤트</target>
        </trans-unit>
        <trans-unit id="03e893e20e6aedf9fdd003184f4239c14fa31543" translate="yes" xml:space="preserve">
          <source>Miscellaneous commands.</source>
          <target state="translated">기타 명령.</target>
        </trans-unit>
        <trans-unit id="513913e8f1b8df71a57aef2147717f04b5a5ff53" translate="yes" xml:space="preserve">
          <source>Miscellaneous.</source>
          <target state="translated">Miscellaneous.</target>
        </trans-unit>
        <trans-unit id="b841515cb79574557871d33c6c685c8b786e812e" translate="yes" xml:space="preserve">
          <source>Mode Hooks</source>
          <target state="translated">모드 후크</target>
        </trans-unit>
        <trans-unit id="1660228964a84777507d5db30661351095dda9bc" translate="yes" xml:space="preserve">
          <source>Mode Line Basics</source>
          <target state="translated">모드 라인 기본 사항</target>
        </trans-unit>
        <trans-unit id="92a5ca248b99dee1b2ae58ed98e940b4cbfc322d" translate="yes" xml:space="preserve">
          <source>Mode Line Format</source>
          <target state="translated">모드 라인 형식</target>
        </trans-unit>
        <trans-unit id="1a4b9da8f1b1256a549fb046003a7eb28cd18a68" translate="yes" xml:space="preserve">
          <source>Mode line construct for miscellaneous information. By default, this shows the information specified by &lt;code&gt;global-mode-string&lt;/code&gt;.</source>
          <target state="translated">기타 정보를위한 모드 라인 구성. 기본적으로 이것은 &lt;code&gt;global-mode-string&lt;/code&gt; 으로 지정된 정보를 표시 합니다 .</target>
        </trans-unit>
        <trans-unit id="79f5b225cffab11e22dc40b6f05abef1d33d1561" translate="yes" xml:space="preserve">
          <source>Modes</source>
          <target state="translated">Modes</target>
        </trans-unit>
        <trans-unit id="72b2168254baad89e5c1ab9acb3b6040544bd8fb" translate="yes" xml:space="preserve">
          <source>Modes derived from Tabulated List mode should call this after setting the above variables (in particular, only after setting &lt;code&gt;tabulated-list-format&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;tabulated-list-format&lt;/code&gt; List 모드에서 파생 된 모드는 위의 변수를 설정 한 후이를 호출해야합니다 (특히 tabulated-list-format 설정 한 후에 만 ).</target>
        </trans-unit>
        <trans-unit id="f37280f5c8b796776063d76ead3db5950069843b" translate="yes" xml:space="preserve">
          <source>Modes for program source code should set this to &lt;code&gt;left-to-right&lt;/code&gt;. Prog mode does this by default, so modes derived from Prog mode do not need to set this explicitly (see &lt;a href=&quot;basic-major-modes#Basic-Major-Modes&quot;&gt;Basic Major Modes&lt;/a&gt;).</source>
          <target state="translated">프로그램 소스 코드의 모드는 이것을 &lt;code&gt;left-to-right&lt;/code&gt; 설정해야합니다 . Prog 모드는 기본적으로이 작업을 수행하므로 Prog 모드에서 파생 된 모드는이를 명시 적으로 설정할 필요가 없습니다 ( &lt;a href=&quot;basic-major-modes#Basic-Major-Modes&quot;&gt;Basic Major Modes&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="b5803becd9e65746e44a5fb6727af1b147951979" translate="yes" xml:space="preserve">
          <source>Modes such as Dired and Rmail make buffers read-only when altering the contents with the usual editing commands would probably be a mistake.</source>
          <target state="translated">Dired 및 Rmail과 같은 모드는 일반적인 편집 명령으로 내용을 변경하는 것이 아마도 실수 일 때 버퍼를 읽기 전용으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="3e0d60bdae51618466cc5411408a226c74100aa3" translate="yes" xml:space="preserve">
          <source>Modes such as Dired mode, in which the text being edited does not consist of a file&amp;rsquo;s contents but can be regenerated in some other fashion, can give this variable a buffer-local value that is a special function to regenerate the contents.</source>
          <target state="translated">편집중인 텍스트가 파일의 내용으로 구성되지 않고 다른 방식으로 다시 생성 될 수있는 Dired 모드와 같은 모드는이 변수에 내용을 다시 생성하는 특수 함수 인 버퍼 로컬 값을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a24cfeea8738c2ef8dbe6b0b8299a0d52050626" translate="yes" xml:space="preserve">
          <source>Modes that other modes are often derived from.</source>
          <target state="translated">다른 모드가 종종 파생되는 모드입니다.</target>
        </trans-unit>
        <trans-unit id="9b381b9e6c64fcffa354dbacacd2ce3c1b8c0754" translate="yes" xml:space="preserve">
          <source>Modifying Existing List Structure</source>
          <target state="translated">기존 목록 구조 수정</target>
        </trans-unit>
        <trans-unit id="c3379a41bf4759b0d4c70d3387480936a6059e23" translate="yes" xml:space="preserve">
          <source>Modifying List Variables</source>
          <target state="translated">목록 변수 수정</target>
        </trans-unit>
        <trans-unit id="df42359d215a53db6ed9a7c4b8cbe68fd027284d" translate="yes" xml:space="preserve">
          <source>Modifying Menus</source>
          <target state="translated">메뉴 수정</target>
        </trans-unit>
        <trans-unit id="06b27e179bc67d2eb79dac2d1e6d2015650bd5ca" translate="yes" xml:space="preserve">
          <source>Modifying Strings</source>
          <target state="translated">문자열 수정</target>
        </trans-unit>
        <trans-unit id="8e9379a55961a6ef4c12aeb1fda47c055107980d" translate="yes" xml:space="preserve">
          <source>Modifying and Translating Input Events</source>
          <target state="translated">입력 이벤트 수정 및 번역</target>
        </trans-unit>
        <trans-unit id="0c57ccfc431bc2516e5717214f07522071c88c48" translate="yes" xml:space="preserve">
          <source>Modifying lists stored in variables.</source>
          <target state="translated">변수에 저장된 목록 수정.</target>
        </trans-unit>
        <trans-unit id="0a7be6ae1c4a45d3076b49b4bc3c1a4ee48cb902" translate="yes" xml:space="preserve">
          <source>Modifying text is not allowed in a read-only buffer.</source>
          <target state="translated">읽기 전용 버퍼에서는 텍스트 수정이 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="23f3dc3212ed2957d48473bfbcff7fdc730bbb06" translate="yes" xml:space="preserve">
          <source>Module Initialization Code</source>
          <target state="translated">모듈 초기화 코드</target>
        </trans-unit>
        <trans-unit id="71d4613afbc49b703267c29c22712c23464539a5" translate="yes" xml:space="preserve">
          <source>Module functions including the &lt;code&gt;emacs_module_init&lt;/code&gt; function (see &lt;a href=&quot;module-initialization#module-initialization-function&quot;&gt;module initialization function&lt;/a&gt;) may only interact with Emacs by calling environment functions from some live &lt;code&gt;emacs_env&lt;/code&gt; pointer while being called directly or indirectly from Emacs. In other words, if a module function wants to call Lisp functions or Emacs primitives, convert &lt;code&gt;emacs_value&lt;/code&gt; objects to and from C datatypes (see &lt;a href=&quot;module-values#Module-Values&quot;&gt;Module Values&lt;/a&gt;), or interact with Emacs in any other way, some call from Emacs to &lt;code&gt;emacs_module_init&lt;/code&gt; or to a module function must be in the call stack. Module function may not interact with Emacs while garbage collection is running; see &lt;a href=&quot;garbage-collection#Garbage-Collection&quot;&gt;Garbage Collection&lt;/a&gt;. They may only interact with Emacs from Lisp interpreter threads (including the main thread) created by Emacs; see &lt;a href=&quot;threads#Threads&quot;&gt;Threads&lt;/a&gt;. The</source>
          <target state="translated">&lt;code&gt;emacs_module_init&lt;/code&gt; 함수 ( &lt;a href=&quot;module-initialization#module-initialization-function&quot;&gt;모듈 초기화 함수&lt;/a&gt; 참조)를 포함하는 모듈 함수 는 Emacs에서 직접 또는 간접적으로 호출되는 동안 일부 라이브 &lt;code&gt;emacs_env&lt;/code&gt; 포인터 에서 환경 함수를 호출하여 Emacs 와만 상호 작용할 수 있습니다 . 즉, 모듈 함수가 Lisp 함수 또는 Emacs 프리미티브를 호출하거나, &lt;code&gt;emacs_value&lt;/code&gt; 객체를 C 데이터 유형으로 ( &lt;a href=&quot;module-values#Module-Values&quot;&gt;모듈 값&lt;/a&gt; 참조 ) 변환 하거나, 다른 방식으로 Emacs와 상호 작용하려면 Emacs에서 &lt;code&gt;emacs_module_init&lt;/code&gt; 또는 모듈 로 호출 합니다. 함수는 호출 스택에 있어야합니다. 모듈 함수는 가비지 수집이 실행되는 동안 Emacs와 상호 작용하지 않을 수 있습니다. 참조 &lt;a href=&quot;garbage-collection#Garbage-Collection&quot;&gt;가비지 컬렉션을&lt;/a&gt;. Emacs가 만든 Lisp 인터프리터 스레드 (메인 스레드 포함)에서만 Emacs와 상호 작용할 수 있습니다. &lt;a href=&quot;threads#Threads&quot;&gt;스레드를&lt;/a&gt; 참조하십시오 . 그만큼</target>
        </trans-unit>
        <trans-unit id="aa62ecac906e7dae2c8e2d7e79864dfd62f36887" translate="yes" xml:space="preserve">
          <source>Module functions use the type &lt;code&gt;emacs_value&lt;/code&gt; to communicate Lisp objects between Emacs and the module (see &lt;a href=&quot;module-values#Module-Values&quot;&gt;Module Values&lt;/a&gt;). The</source>
          <target state="translated">모듈 함수는 &lt;code&gt;emacs_value&lt;/code&gt; 유형을 사용하여 Emacs와 모듈간에 Lisp 객체를 전달합니다 ( &lt;a href=&quot;module-values#Module-Values&quot;&gt;모듈 값&lt;/a&gt; 참조 ). 그만큼</target>
        </trans-unit>
        <trans-unit id="53078183c7061fe0cd9edd96cc36e5ce37d0a31b" translate="yes" xml:space="preserve">
          <source>Modules can create &lt;code&gt;user-ptr&lt;/code&gt; Lisp objects that embed pointers to C struct&amp;rsquo;s defined by the module. This is useful for keeping around complex data structures created by a module, to be passed back to the module&amp;rsquo;s functions. User-ptr objects can also have associated &lt;em&gt;finalizers&lt;/em&gt; &amp;ndash; functions to be run when the object is GC&amp;rsquo;ed; this is useful for freeing any resources allocated for the underlying data structure, such as memory, open file descriptors, etc. See &lt;a href=&quot;module-values#Module-Values&quot;&gt;Module Values&lt;/a&gt;.</source>
          <target state="translated">모듈은 모듈 에서 정의한 C 구조체에 대한 포인터를 포함하는 &lt;code&gt;user-ptr&lt;/code&gt; Lisp 개체를 만들 수 있습니다 . 이것은 모듈에 의해 생성 된 복잡한 데이터 구조를 유지하고 모듈의 함수로 다시 전달하는 데 유용합니다. 사용자 PTR 객체도 관련 지을 수가 &lt;em&gt;파이 나라&lt;/em&gt; - 기능을 실행하는 객체가 GC'ed 때; 이는 메모리, 열린 파일 설명자 등과 같은 기본 데이터 구조에 할당 된 리소스를 해제하는 데 유용합니다 . &lt;a href=&quot;module-values#Module-Values&quot;&gt;모듈 값을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cdaf1615e9fcf09128f766c4a11eb97589359016" translate="yes" xml:space="preserve">
          <source>Modules provide additional Lisp primitives.</source>
          <target state="translated">모듈은 추가 Lisp 프리미티브를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6ec2f205aeddb216abff070de47e318b831ed982" translate="yes" xml:space="preserve">
          <source>More commonly, a face is referred to via a &lt;em&gt;face name&lt;/em&gt;: a Lisp symbol associated with a set of face attributes&lt;a href=&quot;#FOOT22&quot; name=&quot;DOCF22&quot;&gt;&lt;sup&gt;22&lt;/sup&gt;&lt;/a&gt;. Named faces are defined using the &lt;code&gt;defface&lt;/code&gt; macro (see &lt;a href=&quot;defining-faces#Defining-Faces&quot;&gt;Defining Faces&lt;/a&gt;). Emacs comes with several standard named faces (see &lt;a href=&quot;basic-faces#Basic-Faces&quot;&gt;Basic Faces&lt;/a&gt;).</source>
          <target state="translated">보다 일반적으로, 얼굴은 &lt;em&gt;얼굴 이름&lt;/em&gt; 을 통해 참조됩니다 : 얼굴 속성 집합 &lt;a href=&quot;#FOOT22&quot; name=&quot;DOCF22&quot;&gt;&lt;sup&gt;22&lt;/sup&gt;&lt;/a&gt; 와 관련된 Lisp 기호 . 명명 &lt;code&gt;defface&lt;/code&gt; 은 defface 매크로를 사용하여 &lt;a href=&quot;defining-faces#Defining-Faces&quot;&gt;정의됩니다 (면 정의&lt;/a&gt; 참조 ). Emacs에는 몇 가지 표준 이름의 얼굴이 있습니다 ( &lt;a href=&quot;basic-faces#Basic-Faces&quot;&gt;기본 얼굴&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="b94de5ef15a44f90d2da93f96e38f761c889651d" translate="yes" xml:space="preserve">
          <source>More complex menu item definitions.</source>
          <target state="translated">더 복잡한 메뉴 항목 정의.</target>
        </trans-unit>
        <trans-unit id="754bbd6d917505e0487bb8bfca83939b74396492" translate="yes" xml:space="preserve">
          <source>More generally,</source>
          <target state="translated">더 일반적으로,</target>
        </trans-unit>
        <trans-unit id="d436056747a2fab716975cd61c740bc6fb24a4a3" translate="yes" xml:space="preserve">
          <source>More generally, &lt;code&gt;listname&lt;/code&gt; can be a generalized variable. In that case, this macro does the equivalent of &lt;code&gt;(setf&amp;nbsp;&lt;var&gt;listname&lt;/var&gt;&amp;nbsp;(cons&amp;nbsp;&lt;var&gt;element&lt;/var&gt;&amp;nbsp;&lt;var&gt;listname&lt;/var&gt;))&lt;/code&gt;. See &lt;a href=&quot;generalized-variables#Generalized-Variables&quot;&gt;Generalized Variables&lt;/a&gt;.</source>
          <target state="translated">보다 일반적으로 &lt;code&gt;listname&lt;/code&gt; 은 일반화 된 변수 일 수 있습니다. 이 경우이 매크로는 &lt;code&gt;(setf&amp;nbsp;&lt;var&gt;listname&lt;/var&gt;&amp;nbsp;(cons&amp;nbsp;&lt;var&gt;element&lt;/var&gt;&amp;nbsp;&lt;var&gt;listname&lt;/var&gt;))&lt;/code&gt; 합니다. &lt;a href=&quot;generalized-variables#Generalized-Variables&quot;&gt;일반화 변수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="55172490781de7bea7e9de094ce64599830a7212" translate="yes" xml:space="preserve">
          <source>More generally, &lt;var&gt;listname&lt;/var&gt; can be a generalized variable. In that case, this macro saves into &lt;var&gt;listname&lt;/var&gt; using &lt;code&gt;setf&lt;/code&gt;. See &lt;a href=&quot;generalized-variables#Generalized-Variables&quot;&gt;Generalized Variables&lt;/a&gt;.</source>
          <target state="translated">보다 일반적으로 &lt;var&gt;listname&lt;/var&gt; 은 일반화 된 변수 일 수 있습니다. 이 경우이 매크로는 &lt;code&gt;setf&lt;/code&gt; 를 사용하여 &lt;var&gt;listname&lt;/var&gt; 에 저장됩니다 . &lt;a href=&quot;generalized-variables#Generalized-Variables&quot;&gt;일반화 변수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d7ab2fa4e143762f1cbf98c94412199e5e759c95" translate="yes" xml:space="preserve">
          <source>More generally, &lt;var&gt;mode-line-string&lt;/var&gt; can be any mode line construct. It appears in the mode line when the value of &lt;var&gt;minor-mode-variable&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, and not otherwise. These strings should begin with spaces so that they don&amp;rsquo;t run together. Conventionally, the &lt;var&gt;minor-mode-variable&lt;/var&gt; for a specific mode is set to a non-&lt;code&gt;nil&lt;/code&gt; value when that minor mode is activated.</source>
          <target state="translated">보다 일반적으로 &lt;var&gt;mode-line-string&lt;/var&gt; 은 모든 모드 라인 구성이 될 수 있습니다. &lt;var&gt;minor-mode-variable&lt;/var&gt; 값 이 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 모드 행에 나타납니다 . 이러한 문자열은 함께 실행되지 않도록 공백으로 시작해야합니다. 일반적 으로 특정 모드에 대한 &lt;var&gt;minor-mode-variable&lt;/var&gt; 는 부 모드가 활성화 될 때 &lt;code&gt;nil&lt;/code&gt; 이 아닌 값으로 설정 됩니다.</target>
        </trans-unit>
        <trans-unit id="759e70a01a264315afd54c72c902aa5e03d4acbc" translate="yes" xml:space="preserve">
          <source>More generally, the final argument to &lt;code&gt;append&lt;/code&gt; may be any Lisp object. The final argument is not copied or converted; it becomes the &lt;small&gt;CDR&lt;/small&gt; of the last cons cell in the new list. If the final argument is itself a list, then its elements become in effect elements of the result list. If the final element is not a list, the result is a dotted list since its final &lt;small&gt;CDR&lt;/small&gt; is not &lt;code&gt;nil&lt;/code&gt; as required in a proper list (see &lt;a href=&quot;cons-cells#Cons-Cells&quot;&gt;Cons Cells&lt;/a&gt;).</source>
          <target state="translated">더 일반적으로 &lt;code&gt;append&lt;/code&gt; 할 최종 인수 는 Lisp 객체 일 수 있습니다. 마지막 인수는 복사되거나 변환되지 않습니다. 새 목록에서 마지막 단점 셀 의 &lt;small&gt;CDR&lt;/small&gt; 이됩니다. 최종 인수 자체가 목록이면 해당 요소는 결과 목록의 유효한 요소가됩니다. 최종 요소가 목록이 아닌 경우 최종 &lt;small&gt;CDR&lt;/small&gt; 이 적절한 목록에 필요한대로 &lt;code&gt;nil&lt;/code&gt; 이 아니기 때문에 결과는 점으로 구분 된 목록입니다 ( &lt;a href=&quot;cons-cells#Cons-Cells&quot;&gt;Cons Cells&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="5c06fdd4f23cd4daee8d294f03b24245dc305ec4" translate="yes" xml:space="preserve">
          <source>More generally, you can use the variable &lt;code&gt;buffer-invisibility-spec&lt;/code&gt; to control which values of the &lt;code&gt;invisible&lt;/code&gt; property make text invisible. This permits you to classify the text into different subsets in advance, by giving them different &lt;code&gt;invisible&lt;/code&gt; values, and subsequently make various subsets visible or invisible by changing the value of &lt;code&gt;buffer-invisibility-spec&lt;/code&gt;.</source>
          <target state="translated">더 일반적으로 변수 &lt;code&gt;buffer-invisibility-spec&lt;/code&gt; 을 사용하여 &lt;code&gt;invisible&lt;/code&gt; 속성의 값을 제어 하여 텍스트를 보이지 않게 할 수 있습니다. 이렇게하면 다른 &lt;code&gt;invisible&lt;/code&gt; 값 을 제공하여 미리 텍스트를 다른 하위 집합으로 분류 한 다음 &lt;code&gt;buffer-invisibility-spec&lt;/code&gt; 값을 변경하여 다양한 하위 집합을 표시하거나 숨길 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="60a18e357538be44773938629786b367e89b0ffd" translate="yes" xml:space="preserve">
          <source>More individual control is possible by using a cons cell: In that case the frame&amp;rsquo;s width ratio is preserved if the &lt;small&gt;CAR&lt;/small&gt; of the cell is either &lt;code&gt;t&lt;/code&gt; or &lt;code&gt;width-only&lt;/code&gt;. The height ratio is preserved if the &lt;small&gt;CAR&lt;/small&gt; of the cell is either &lt;code&gt;t&lt;/code&gt; or &lt;code&gt;height-only&lt;/code&gt;. The left position ratio is preserved if the &lt;small&gt;CDR&lt;/small&gt; of the cell is either &lt;code&gt;t&lt;/code&gt; or &lt;code&gt;left-only&lt;/code&gt;. The top position ratio is preserved if the &lt;small&gt;CDR&lt;/small&gt; of the cell is either &lt;code&gt;t&lt;/code&gt; or &lt;code&gt;top-only&lt;/code&gt;.</source>
          <target state="translated">cons 셀을 사용하면보다 개별적인 제어가 가능합니다.이 경우 셀 의 &lt;small&gt;CAR&lt;/small&gt; 이 &lt;code&gt;t&lt;/code&gt; 또는 &lt;code&gt;width-only&lt;/code&gt; 인 경우 프레임의 너비 비율이 유지 됩니다 . 셀 의 &lt;small&gt;CAR&lt;/small&gt; 이 &lt;code&gt;t&lt;/code&gt; 또는 &lt;code&gt;height-only&lt;/code&gt; 인 경우 높이 비율이 유지 됩니다 . 셀 의 &lt;small&gt;CDR&lt;/small&gt; 이 &lt;code&gt;t&lt;/code&gt; 또는 &lt;code&gt;left-only&lt;/code&gt; 인 경우 왼쪽 위치 비율이 유지 됩니다 . 셀 의 &lt;small&gt;CDR&lt;/small&gt; 이 &lt;code&gt;t&lt;/code&gt; 또는 &lt;code&gt;top-only&lt;/code&gt; 인 경우 상단 위치 비율이 유지 됩니다 .</target>
        </trans-unit>
        <trans-unit id="2d35b8a3c91aa8470e9a099d606cc2c1c7acaba3" translate="yes" xml:space="preserve">
          <source>More precisely, we should now have a Lisp function (a lambda expression), a byte-code function, a primitive function, a Lisp macro, a special form, or an autoload object. Each of these types is a case described in one of the following sections. If the object is not one of these types, Emacs signals an &lt;code&gt;invalid-function&lt;/code&gt; error.</source>
          <target state="translated">보다 정확하게는 이제 Lisp 함수 (람다 식), 바이트 코드 함수, 기본 함수, Lisp 매크로, 특수 형식 또는 자동로드 개체가 있어야합니다. 이러한 각 유형은 다음 섹션 중 하나에서 설명하는 케이스입니다. 객체가 이러한 유형 중 하나가 아니면 Emacs는 &lt;code&gt;invalid-function&lt;/code&gt; 오류를 알립니다 .</target>
        </trans-unit>
        <trans-unit id="5d1907fa94271e60953cb92c6af32f80577dca2a" translate="yes" xml:space="preserve">
          <source>Most Emacs Lisp file-manipulation functions get errors when used on files that are directories. For example, you cannot delete a directory with &lt;code&gt;delete-file&lt;/code&gt;. These special functions exist to create and delete directories.</source>
          <target state="translated">대부분의 Emacs Lisp 파일 조작 함수는 디렉토리 인 파일에 사용될 때 오류가 발생합니다. 예를 들어, &lt;code&gt;delete-file&lt;/code&gt; 을 사용하여 디렉토리를 삭제할 수 없습니다 . 이러한 특수 기능은 디렉토리를 만들고 삭제하기 위해 존재합니다.</target>
        </trans-unit>
        <trans-unit id="09eed349899d3e99c3026461a2438ccf55662d6f" translate="yes" xml:space="preserve">
          <source>Most Emacs commands can use a &lt;em&gt;prefix argument&lt;/em&gt;, a number specified before the command itself. (Don&amp;rsquo;t confuse prefix arguments with prefix keys.) The prefix argument is at all times represented by a value, which may be &lt;code&gt;nil&lt;/code&gt;, meaning there is currently no prefix argument. Each command may use the prefix argument or ignore it.</source>
          <target state="translated">대부분의 Emacs 명령은 명령 자체 앞에 지정된 숫자 인 &lt;em&gt;prefix 인수를&lt;/em&gt; 사용할 수 있습니다 . (접두사 인수와 접두사 키를 혼동하지 마십시오.) 접두사 인수는 항상 값으로 표현되며 &lt;code&gt;nil&lt;/code&gt; 일 수 있습니다 . 이는 현재 접두사 인수가 없음 을 의미합니다. 각 명령은 접두사 인수를 사용하거나 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="964d2f546749ab746319cf9bf92a58945c9983a6" translate="yes" xml:space="preserve">
          <source>Most Lisp code should not use this macro; &lt;code&gt;save-selected-window&lt;/code&gt; is typically sufficient. In particular, this macro cannot reliably prevent the code in &lt;var&gt;forms&lt;/var&gt; from opening new windows, because new windows might be opened in other frames (see &lt;a href=&quot;choosing-window#Choosing-Window&quot;&gt;Choosing Window&lt;/a&gt;), and &lt;code&gt;save-window-excursion&lt;/code&gt; only saves and restores the window configuration on the current frame.</source>
          <target state="translated">대부분의 Lisp 코드는이 매크로를 사용하지 않아야합니다. 일반적으로 &lt;code&gt;save-selected-window&lt;/code&gt; 이면 충분합니다. 특히이 매크로는 &lt;var&gt;forms&lt;/var&gt; 의 코드가 새 창을 여는 것을 안정적으로 방지 할 수 없습니다. 새 창이 다른 프레임에서 열릴 수 있고 ( &lt;a href=&quot;choosing-window#Choosing-Window&quot;&gt;창 선택&lt;/a&gt; 참조 ) &lt;code&gt;save-window-excursion&lt;/code&gt; 은 현재 프레임의 창 구성 만 저장하고 복원하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="fe2ae73f5ba28b3bd7e0ab7c9daa9a827c4bf56e" translate="yes" xml:space="preserve">
          <source>Most applications should not use recursive editing, except as part of using the minibuffer. Usually it is more convenient for the user if you change the major mode of the current buffer temporarily to a special major mode, which should have a command to go back to the previous mode. (The</source>
          <target state="translated">미니 버퍼를 사용하는 경우를 제외하고 대부분의 응용 프로그램은 재귀 편집을 사용하지 않아야합니다. 일반적으로 현재 버퍼의 주 모드를 일시적으로 특수 주 모드로 변경하면 이전 모드로 돌아가라는 명령이 있어야 사용자에게 더 편리합니다. (그만큼</target>
        </trans-unit>
        <trans-unit id="1eaf100a3aafa712a449e3207bf7cabe96c9c0ab" translate="yes" xml:space="preserve">
          <source>Most buffers have an &lt;em&gt;undo list&lt;/em&gt;, which records all changes made to the buffer&amp;rsquo;s text so that they can be undone. (The buffers that don&amp;rsquo;t have one are usually special-purpose buffers for which Emacs assumes that undoing is not useful. In particular, any buffer whose name begins with a space has its undo recording off by default; see &lt;a href=&quot;buffer-names#Buffer-Names&quot;&gt;Buffer Names&lt;/a&gt;.) All the primitives that modify the text in the buffer automatically add elements to the front of the undo list, which is in the variable &lt;code&gt;buffer-undo-list&lt;/code&gt;.</source>
          <target state="translated">대부분의 버퍼에는 &lt;em&gt;취소&lt;/em&gt; 할 수 있도록 버퍼의 텍스트에 대한 모든 변경 사항을 기록 하는 &lt;em&gt;실행 취소 목록&lt;/em&gt; 이 있습니다. (버퍼가없는 버퍼는 일반적으로 Emacs가 실행 취소가 유용하지 않다고 가정하는 특수 목적 버퍼입니다. 특히 이름이 공백으로 시작하는 버퍼는 기본적으로 실행 취소 기록이 꺼져 있습니다. &lt;a href=&quot;buffer-names#Buffer-Names&quot;&gt;버퍼 이름&lt;/a&gt; 참조 ) 모두 버퍼의 텍스트를 수정하는 프리미티브는 자동으로 변수 &lt;code&gt;buffer-undo-list&lt;/code&gt; 에있는 실행 취소 목록의 맨 앞에 요소를 추가 합니다 .</target>
        </trans-unit>
        <trans-unit id="b6dcfcc1ab586c7c06232994a3f579a591ce8d2a" translate="yes" xml:space="preserve">
          <source>Most control constructs affect only the flow of control within the construct itself. The function &lt;code&gt;throw&lt;/code&gt; is the exception to this rule of normal program execution: it performs a nonlocal exit on request. (There are other exceptions, but they are for error handling only.) &lt;code&gt;throw&lt;/code&gt; is used inside a &lt;code&gt;catch&lt;/code&gt;, and jumps back to that &lt;code&gt;catch&lt;/code&gt;. For example:</source>
          <target state="translated">대부분의 제어 구조는 구조 자체 내의 제어 흐름에만 영향을줍니다. 함수 &lt;code&gt;throw&lt;/code&gt; 는 정상적인 프로그램 실행 규칙에 대한 예외입니다. 요청시 로컬이 아닌 종료를 수행합니다. (다른 예외가 있지만 오류 처리 전용입니다.) &lt;code&gt;throw&lt;/code&gt; 는 &lt;code&gt;catch&lt;/code&gt; 내부에서 사용 되며 해당 &lt;code&gt;catch&lt;/code&gt; 로 다시 점프합니다 . 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="72373bc3f93b6102b1ff980fc9edb816c70fbcbd" translate="yes" xml:space="preserve">
          <source>Most errors are signaled automatically within Lisp primitives which you call for other purposes, such as if you try to take the &lt;small&gt;CAR&lt;/small&gt; of an integer or move forward a character at the end of the buffer. You can also signal errors explicitly with the functions &lt;code&gt;error&lt;/code&gt; and &lt;code&gt;signal&lt;/code&gt;.</source>
          <target state="translated">대부분의 오류는 정수 의 &lt;small&gt;CAR&lt;/small&gt; 을 가져 오거나 버퍼의 끝에서 문자를 앞으로 이동 하려는 경우와 같이 다른 목적으로 호출하는 Lisp 프리미티브 내에서 자동으로 신호를받습니다 . &lt;code&gt;error&lt;/code&gt; 및 &lt;code&gt;signal&lt;/code&gt; 함수를 사용하여 명시 적으로 오류를 신호 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="266fa78b8886478b8a397f099e61b861826a3118" translate="yes" xml:space="preserve">
          <source>Most keyboards also have &lt;em&gt;function keys&lt;/em&gt;&amp;mdash;keys that have names or symbols that are not characters. Function keys are represented in Emacs Lisp as symbols; the symbol&amp;rsquo;s name is the function key&amp;rsquo;s label, in lower case. For example, pressing a key labeled</source>
          <target state="translated">대부분의 키보드에는 &lt;em&gt;기능 키 (&lt;/em&gt; 문자가 아닌 이름 또는 기호가있는 &lt;em&gt;키)&lt;/em&gt; 도 있습니다 . 기능 키는 Emacs Lisp에서 기호로 표시됩니다. 기호의 이름은 소문자로 된 기능 키의 레이블입니다. 예를 들어, 레이블이 붙은 키를 누르면</target>
        </trans-unit>
        <trans-unit id="9f00659321a54a5b7e744a95bacbe846e1ba78fa" translate="yes" xml:space="preserve">
          <source>Most minor modes implement features that are independent of the major mode, and can thus be used with most major modes. For example, Auto Fill mode works with any major mode that permits text insertion. A few minor modes, however, are specific to a particular major mode. For example, Diff Auto Refine mode is a minor mode that is intended to be used only with Diff mode.</source>
          <target state="translated">대부분의 부 모드는 주 모드와 독립적 인 기능을 구현하므로 대부분의 주 모드에서 사용할 수 있습니다. 예를 들어, 자동 채우기 모드는 텍스트 삽입을 허용하는 모든 주요 모드에서 작동합니다. 그러나 몇 가지 부 모드는 특정 주 모드에 고유합니다. 예를 들어, Diff Auto Refine 모드는 Diff 모드에서만 사용하기위한 부 모드입니다.</target>
        </trans-unit>
        <trans-unit id="c397a5c428cdfab905c1bb14033fe204e686e090" translate="yes" xml:space="preserve">
          <source>Most needs are satisfied by these two ways that backtracking is automatically disabled, but occasionally it is useful to explicitly disable backtracking by using the &lt;code&gt;gate&lt;/code&gt; specification. This is useful when you know that no higher alternatives could apply. See the example of the &lt;code&gt;let&lt;/code&gt; specification.</source>
          <target state="translated">대부분의 요구 사항은 역 추적이 자동으로 비활성화되는이 두 가지 방법으로 충족되지만 경우에 따라 &lt;code&gt;gate&lt;/code&gt; 사양 을 사용하여 역 추적을 명시 적으로 비활성화하는 것이 유용합니다 . 이것은 더 높은 대안이 적용될 수 없다는 것을 알고있을 때 유용합니다. &lt;code&gt;let&lt;/code&gt; 사양 의 예를 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="cc4ca8d6208ffb0d4a36e05a18b9c69498324dc6" translate="yes" xml:space="preserve">
          <source>Most of the Lisp functions for reading text take an &lt;em&gt;input stream&lt;/em&gt; as an argument. The input stream specifies where or how to get the characters of the text to be read. Here are the possible types of input stream:</source>
          <target state="translated">텍스트를 읽기위한 대부분의 Lisp 함수는 &lt;em&gt;입력 스트림&lt;/em&gt; 을 인수로 사용합니다. 입력 스트림은 읽을 텍스트의 문자를 가져 오는 위치 또는 방법을 지정합니다. 가능한 입력 스트림 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f7fb5ab8ace2fa15e51d35ce50aee4d936080390" translate="yes" xml:space="preserve">
          <source>Most of the commands in this section return values that are not meaningful. All the functions that do filling take note of the current left margin, current right margin, and current justification style (see &lt;a href=&quot;margins#Margins&quot;&gt;Margins&lt;/a&gt;). If the current justification style is &lt;code&gt;none&lt;/code&gt;, the filling functions don&amp;rsquo;t actually do anything.</source>
          <target state="translated">이 섹션에있는 대부분의 명령은 의미가없는 값을 반환합니다. 채우기를 수행하는 모든 함수는 현재 왼쪽 여백, 현재 오른쪽 여백 및 현재 자리 맞추기 스타일을 기록합니다 ( &lt;a href=&quot;margins#Margins&quot;&gt;여백&lt;/a&gt; 참조 ). 현재 자리 맞추기 스타일이 &lt;code&gt;none&lt;/code&gt; 이면 채우기 함수가 실제로 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cbad2a18a2d91f80015c7e2ea18ca8a1aab103fa" translate="yes" xml:space="preserve">
          <source>Most of the functions below take a name and sometimes an obarray as arguments. A &lt;code&gt;wrong-type-argument&lt;/code&gt; error is signaled if the name is not a string, or if the obarray is not a vector.</source>
          <target state="translated">아래의 대부분의 함수는 이름을 취하고 때로는 오바 레이를 인수로 사용합니다. &lt;code&gt;wrong-type-argument&lt;/code&gt; 이름이 문자열이 아닌 경우, 또는 obarray가 벡터가 아닌 경우 오류가 신호됩니다.</target>
        </trans-unit>
        <trans-unit id="68726f32511ba6a9522b1792a27d11825f7b4a12" translate="yes" xml:space="preserve">
          <source>Most of the functions described below became available in Emacs 25, the first Emacs release that supported dynamic modules. For the few functions that became available in later Emacs releases, we mention the first Emacs version that supported them.</source>
          <target state="translated">아래에 설명 된 대부분의 기능은 동적 모듈을 지원하는 최초의 Emacs 릴리스 인 Emacs 25에서 사용할 수있게되었습니다. 이후 Emacs 릴리스에서 사용할 수있게 된 몇 가지 기능에 대해이를 지원하는 첫 번째 Emacs 버전을 언급합니다.</target>
        </trans-unit>
        <trans-unit id="b3d67ad5f3eb4dfd9ab8ef87986f724f3ad34348" translate="yes" xml:space="preserve">
          <source>Most of the hooks in Emacs are &lt;em&gt;normal hooks&lt;/em&gt;. These variables contain lists of functions to be called with no arguments. By convention, whenever the hook name ends in &amp;lsquo;</source>
          <target state="translated">Emacs에있는 대부분의 훅은 &lt;em&gt;일반 훅&lt;/em&gt; 입니다. 이러한 변수에는 인수없이 호출 할 함수 목록이 포함되어 있습니다. 관례 적으로 후크 이름이 '로 끝날 때마다</target>
        </trans-unit>
        <trans-unit id="fbcca09d8ca07315a2c9111b156bdf457cc5150a" translate="yes" xml:space="preserve">
          <source>Most of the kill commands are primarily for interactive use, and are not described here. What we do describe are the functions provided for use in writing such commands. You can use these functions to write commands for killing text. When you need to delete text for internal purposes within a Lisp function, you should normally use deletion functions, so as not to disturb the kill ring contents. See &lt;a href=&quot;deletion#Deletion&quot;&gt;Deletion&lt;/a&gt;.</source>
          <target state="translated">대부분의 kill 명령은 주로 대화식 사용을위한 것이며 여기에서는 설명하지 않습니다. 우리가 설명하는 것은 그러한 명령을 작성하는 데 사용하기 위해 제공되는 함수입니다. 이 함수를 사용하여 텍스트를 죽이는 명령을 작성할 수 있습니다. Lisp 함수 내에서 내부 목적으로 텍스트를 삭제해야하는 경우 킬 링 콘텐츠를 방해하지 않도록 일반적으로 삭제 함수를 사용해야합니다. &lt;a href=&quot;deletion#Deletion&quot;&gt;삭제를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cc3c2124fc3bae720b8252b979a43c48fb44d9b9" translate="yes" xml:space="preserve">
          <source>Most of the time, functions are called when their names are written in Lisp expressions in Lisp programs. However, you can construct or obtain a function object at run time and then call it with the primitive functions &lt;code&gt;funcall&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt;. See &lt;a href=&quot;calling-functions#Calling-Functions&quot;&gt;Calling Functions&lt;/a&gt;.</source>
          <target state="translated">대부분의 경우 함수는 Lisp 프로그램에서 Lisp 표현식으로 이름이 작성 될 때 호출됩니다. 그러나 런타임에 함수 객체를 생성하거나 얻은 다음 기본 함수 &lt;code&gt;funcall&lt;/code&gt; 및 &lt;code&gt;apply&lt;/code&gt; 로 호출 할 수 있습니다 . &lt;a href=&quot;calling-functions#Calling-Functions&quot;&gt;함수 호출을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ad2a15ba084ba8bc4aa18e87ac5aa225a45b1c5d" translate="yes" xml:space="preserve">
          <source>Most of the time, it&amp;rsquo;s not useful to distinguish the two. So normally &lt;code&gt;local-function-key-map&lt;/code&gt; (see &lt;a href=&quot;translation-keymaps#Translation-Keymaps&quot;&gt;Translation Keymaps&lt;/a&gt;) is set up to map &lt;code&gt;tab&lt;/code&gt; into 9. Thus, a key binding for character code 9 (the character</source>
          <target state="translated">대부분의 경우 둘을 구별하는 것은 유용하지 않습니다. 따라서 일반적으로 &lt;code&gt;local-function-key-map&lt;/code&gt; ( &lt;a href=&quot;translation-keymaps#Translation-Keymaps&quot;&gt;Translation Keymaps&lt;/a&gt; 참조 )은 &lt;code&gt;tab&lt;/code&gt; 을 9 로 매핑하도록 설정됩니다. 따라서 문자 코드 9 (문자</target>
        </trans-unit>
        <trans-unit id="abe6f1d63c7f88d045c5b31ba7795c4ed74c53bd" translate="yes" xml:space="preserve">
          <source>Most of these error symbols are defined in C (mainly</source>
          <target state="translated">이러한 오류 기호의 대부분은 C (주로</target>
        </trans-unit>
        <trans-unit id="49da26863e7f22566b2cf4a25068c25f6cd2d052" translate="yes" xml:space="preserve">
          <source>Most of these variables have names ending with &amp;lsquo;</source>
          <target state="translated">이러한 변수의 대부분은 '로 끝나는 이름을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="9c4e0cce8a81ef3708db9a9d44182e2b8fe94a9d" translate="yes" xml:space="preserve">
          <source>Most often, forms are evaluated automatically, by virtue of their occurrence in a program being run. On rare occasions, you may need to write code that evaluates a form that is computed at run time, such as after reading a form from text being edited or getting one from a property list. On these occasions, use the &lt;code&gt;eval&lt;/code&gt; function. Often &lt;code&gt;eval&lt;/code&gt; is not needed and something else should be used instead. For example, to get the value of a variable, while &lt;code&gt;eval&lt;/code&gt; works, &lt;code&gt;symbol-value&lt;/code&gt; is preferable; or rather than store expressions in a property list that then need to go through &lt;code&gt;eval&lt;/code&gt;, it is better to store functions instead that are then passed to &lt;code&gt;funcall&lt;/code&gt;.</source>
          <target state="translated">대부분의 경우 양식은 실행중인 프로그램에서 발생하므로 자동으로 평가됩니다. 드물지만 편집중인 텍스트에서 양식을 읽거나 속성 목록에서 양식을 가져온 후와 같이 런타임에 계산되는 양식을 평가하는 코드를 작성해야 할 수도 있습니다. 이러한 경우 &lt;code&gt;eval&lt;/code&gt; 함수를 사용하십시오 . 종종 &lt;code&gt;eval&lt;/code&gt; 이 필요하지 않으며 대신 다른 것을 사용해야합니다. 예를 들어, &lt;code&gt;eval&lt;/code&gt; 이 작동 하는 동안 변수 값을 얻으려면 &lt;code&gt;symbol-value&lt;/code&gt; 가 바람직합니다. 또는 &lt;code&gt;eval&lt;/code&gt; 을 거쳐야하는 속성 목록에 표현식 을 저장하는 대신 &lt;code&gt;funcall&lt;/code&gt; 에 전달되는 함수를 저장하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="aa3d06d22c97d444806afc27e617f43b0ad086a7" translate="yes" xml:space="preserve">
          <source>Most often, the &lt;var&gt;types&lt;/var&gt; in a &lt;code&gt;set&lt;/code&gt; are &lt;code&gt;const&lt;/code&gt; types, as shown here:</source>
          <target state="translated">대부분의 경우는 &lt;var&gt;types&lt;/var&gt; A의 &lt;code&gt;set&lt;/code&gt; 입니다 &lt;code&gt;const&lt;/code&gt; 를 다음과 같이 유형은 :</target>
        </trans-unit>
        <trans-unit id="2104b44b9ba0cc9d20b66b199ac691005bd0bed2" translate="yes" xml:space="preserve">
          <source>Most uses of &lt;code&gt;eval-and-compile&lt;/code&gt; are fairly sophisticated.</source>
          <target state="translated">대부분의 &lt;code&gt;eval-and-compile&lt;/code&gt; 사용 은 상당히 정교합니다.</target>
        </trans-unit>
        <trans-unit id="81869f1759c2b1872ff235184d70faf9f4fd2d64" translate="yes" xml:space="preserve">
          <source>Most window systems use a desktop metaphor. Part of this metaphor is the idea that system-level windows (representing, e.g., Emacs frames) are stacked in a notional third dimension perpendicular to the screen surface. The order induced by stacking is total and usually referred to as stacking (or Z-) order. Where the areas of two windows overlap, the one higher up in that order will (partially) cover the one underneath.</source>
          <target state="translated">대부분의 윈도우 시스템은 데스크탑 메타포를 사용합니다. 이 은유의 일부는 시스템 수준 창 (예 : Emacs 프레임을 나타냄)이 화면 표면에 수직 인 개념적 3 차원으로 쌓인다는 아이디어입니다. 스택에 의해 유도 된 순서는 총계이며 일반적으로 스택 (또는 Z-) 순서라고합니다. 두 창의 영역이 겹치는 경우 해당 순서에서 더 높은 영역이 (부분적으로) 아래 영역을 덮습니다.</target>
        </trans-unit>
        <trans-unit id="0a9fbf9f714ce6a3a5ea4ced3ed7f3d62099211d" translate="yes" xml:space="preserve">
          <source>Most window-systems clip a child frame at the native edges (see &lt;a href=&quot;frame-geometry#Frame-Geometry&quot;&gt;Frame Geometry&lt;/a&gt;) of its parent frame&amp;mdash;everything outside these edges is usually invisible. A child frame&amp;rsquo;s &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;top&lt;/code&gt; parameters specify a position relative to the top-left corner of its parent&amp;rsquo;s native frame. When the parent frame is resized, this position remains conceptually unaltered.</source>
          <target state="translated">대부분의 윈도우 시스템 은 상위 프레임 의 기본 가장자리 ( &lt;a href=&quot;frame-geometry#Frame-Geometry&quot;&gt;프레임 지오메트리&lt;/a&gt; 참조 )에서 하위 프레임을 자릅니다. 이러한 가장자리 외부의 모든 것은 일반적으로 보이지 않습니다. 자식 프레임의 &lt;code&gt;left&lt;/code&gt; 및 &lt;code&gt;top&lt;/code&gt; 매개 변수는 부모 기본 프레임의 왼쪽 상단 모서리를 기준으로 위치를 지정합니다. 상위 프레임의 크기가 조정될 때이 위치는 개념적으로 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="852329adec48160b733c7ed9efcc2bd1ea539df5" translate="yes" xml:space="preserve">
          <source>Mostly, however, this function is called automatically at an appropriate time.</source>
          <target state="translated">그러나 대부분이 함수는 적절한 시간에 자동으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="e040db2b7f1361a938099464de9858040e353ddb" translate="yes" xml:space="preserve">
          <source>Motion</source>
          <target state="translated">Motion</target>
        </trans-unit>
        <trans-unit id="4c333f9eac917041de2dbe5d4e12612fb84fb008" translate="yes" xml:space="preserve">
          <source>Motion Commands Based on Parsing</source>
          <target state="translated">구문 분석에 기반한 모션 명령</target>
        </trans-unit>
        <trans-unit id="e8a12b0b4cf9966d415d89a1d69b08c8352f976f" translate="yes" xml:space="preserve">
          <source>Motion Events</source>
          <target state="translated">모션 이벤트</target>
        </trans-unit>
        <trans-unit id="91315d6877510cf4da5e405826b3221c94135c3e" translate="yes" xml:space="preserve">
          <source>Motion and Syntax</source>
          <target state="translated">동작 및 구문</target>
        </trans-unit>
        <trans-unit id="e092df3cd889f7ec86f740980f392f5d6e8af02e" translate="yes" xml:space="preserve">
          <source>Motion by Characters</source>
          <target state="translated">캐릭터 별 모션</target>
        </trans-unit>
        <trans-unit id="d2ce7e2f90144ab22f36527dc8781160c756549d" translate="yes" xml:space="preserve">
          <source>Motion by Screen Lines</source>
          <target state="translated">스크린 라인에 의한 모션</target>
        </trans-unit>
        <trans-unit id="4dce4bd28a86b1ce27d0bd612a7561462c7cc60b" translate="yes" xml:space="preserve">
          <source>Motion by Text Lines</source>
          <target state="translated">텍스트 라인에 의한 모션</target>
        </trans-unit>
        <trans-unit id="2d29ecb574b2bce083871d9d9c13f5b680f74abd" translate="yes" xml:space="preserve">
          <source>Motion by Words</source>
          <target state="translated">말에 의한 움직임</target>
        </trans-unit>
        <trans-unit id="633150abc226c78ac7b073c2e31944ab3ddd0ae8" translate="yes" xml:space="preserve">
          <source>Motion functions change the value of point, either relative to the current value of point, relative to the beginning or end of the buffer, or relative to the edges of the selected window. See &lt;a href=&quot;point#Point&quot;&gt;Point&lt;/a&gt;.</source>
          <target state="translated">모션 함수는 현재 포인트 값을 기준으로, 버퍼의 시작 또는 끝을 기준으로, 또는 선택한 창의 가장자리를 기준으로 포인트 값을 변경합니다. &lt;a href=&quot;point#Point&quot;&gt;Point를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="013a79eacf73d8474d69b249a7fcb74f3bc7d072" translate="yes" xml:space="preserve">
          <source>Motion functions that work by parsing.</source>
          <target state="translated">파싱으로 작동하는 모션 함수.</target>
        </trans-unit>
        <trans-unit id="37802ebb8eb19a12e9b66522e9d801b5abfc80a9" translate="yes" xml:space="preserve">
          <source>Motion to an End of the Buffer</source>
          <target state="translated">버퍼 끝까지의 움직임</target>
        </trans-unit>
        <trans-unit id="48637a9a84940dbd837461865518bd9300ca2cf2" translate="yes" xml:space="preserve">
          <source>Mouse Dragging Parameters</source>
          <target state="translated">마우스 끌기 매개 변수</target>
        </trans-unit>
        <trans-unit id="b239ecd4f1b125963a812db57dc3cec60573502b" translate="yes" xml:space="preserve">
          <source>Mouse Events</source>
          <target state="translated">마우스 이벤트</target>
        </trans-unit>
        <trans-unit id="99a6a713af3081ea16c4b4ba861aeaea079ffefd" translate="yes" xml:space="preserve">
          <source>Mouse Position</source>
          <target state="translated">마우스 위치</target>
        </trans-unit>
        <trans-unit id="c15f4049211f898d49c97d76dd71469c52292f33" translate="yes" xml:space="preserve">
          <source>Mouse Tracking</source>
          <target state="translated">마우스 추적</target>
        </trans-unit>
        <trans-unit id="4a803cb0d07554c2f9f3761b9162a772b63c4e18" translate="yes" xml:space="preserve">
          <source>Mouse Window Auto-selection</source>
          <target state="translated">마우스 창 자동 선택</target>
        </trans-unit>
        <trans-unit id="f47c56f8e3df66caa71e2d0ce49ed9adb3c1a9bd" translate="yes" xml:space="preserve">
          <source>Mouse auto-selection can be used to emulate a focus follows mouse policy for child frames (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;) which usually are not tracked by the window manager. This requires to set the value of &lt;code&gt;focus-follows-mouse&lt;/code&gt; (see &lt;a href=&quot;input-focus#Input-Focus&quot;&gt;Input Focus&lt;/a&gt;) to a non-&lt;code&gt;nil&lt;/code&gt; value. If the value of &lt;code&gt;focus-follows-mouse&lt;/code&gt; is &lt;code&gt;auto-raise&lt;/code&gt;, entering a child frame with the mouse will raise it automatically above all other child frames of that frame&amp;rsquo;s parent frame.</source>
          <target state="translated">마우스 자동 선택은 일반적으로 창 관리자가 추적하지 않는 하위 프레임 ( &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;하위 프레임&lt;/a&gt; 참조)에 대한 마우스 정책을 따르는 포커스를 에뮬레이션하는 데 사용할 수 있습니다 . 이를 위해서는 &lt;code&gt;focus-follows-mouse&lt;/code&gt; ( &lt;a href=&quot;input-focus#Input-Focus&quot;&gt;Input Focus&lt;/a&gt; 참조 ) 값을 &lt;code&gt;nil&lt;/code&gt; 이 아닌 값으로 설정해야합니다. &lt;code&gt;focus-follows-mouse&lt;/code&gt; 의 값 이 &lt;code&gt;auto-raise&lt;/code&gt; 이면 마우스 로 자식 프레임을 입력하면 해당 프레임의 부모 프레임의 다른 모든 자식 프레임 위에 자동으로 올라갑니다.</target>
        </trans-unit>
        <trans-unit id="2df64335cf98c72ba6ba9a9e8bb30c7f288e379f" translate="yes" xml:space="preserve">
          <source>Mouse auto-selection selects the minibuffer window only if it is active, and never deselects the active minibuffer window.</source>
          <target state="translated">마우스 자동 선택은 미니 버퍼 창이 활성화 된 경우에만 선택하고 활성 미니 버퍼 창을 선택 취소하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e56ccfe134223b80437e24ef8272e7c77b397941" translate="yes" xml:space="preserve">
          <source>Move back to the previous place that a question was asked about.</source>
          <target state="translated">질문이 있었던 이전 위치로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="fcfc1a5d81c2fd67d3d58302e0edda1d94a48c17" translate="yes" xml:space="preserve">
          <source>Move point back to the current stop point in the source code buffer (&lt;code&gt;edebug-where&lt;/code&gt;).</source>
          <target state="translated">포인트를 소스 코드 버퍼 ( &lt;code&gt;edebug-where&lt;/code&gt; ) 의 현재 중지 포인트로 다시 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="e8011edd1eeb2660ed2ab6bdc47c4b387b009944" translate="yes" xml:space="preserve">
          <source>Move point to &lt;var&gt;limit&lt;/var&gt; (or the end of the accessible portion of the buffer) and return &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;limit&lt;/var&gt; (또는 버퍼의 액세스 가능한 부분의 끝)으로 포인트를 이동 하고 &lt;code&gt;nil&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="97b7fff41223832602e81589fc86fce13dac6227" translate="yes" xml:space="preserve">
          <source>Move point to the next breakpoint in the current definition (&lt;code&gt;edebug-next-breakpoint&lt;/code&gt;).</source>
          <target state="translated">현재 정의 ( &lt;code&gt;edebug-next-breakpoint&lt;/code&gt; ) 에서 다음 중단 점으로 포인트를 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="ef08217195a398b9b9595051fd75d3bbcfe68238" translate="yes" xml:space="preserve">
          <source>Move the pen to the first point in &lt;var&gt;points&lt;/var&gt;. Additional points are connected with lines. &lt;var&gt;points&lt;/var&gt; is a list of X/Y coordinate pairs. Subsequent &lt;code&gt;moveto&lt;/code&gt; commands represent the start of a new &lt;em&gt;subpath&lt;/em&gt;.</source>
          <target state="translated">최초의 지점으로 펜을 이동 &lt;var&gt;points&lt;/var&gt; . 추가 포인트는 선으로 연결됩니다. &lt;var&gt;points&lt;/var&gt; 는 X / Y 좌표 쌍의 목록입니다. 후속 &lt;code&gt;moveto&lt;/code&gt; 명령은 새 &lt;em&gt;하위 경로&lt;/em&gt; 의 시작을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="f66eccc892556cafb6abe680c2768bcdf1cc6f5c" translate="yes" xml:space="preserve">
          <source>Move to first non-blank character.</source>
          <target state="translated">공백이 아닌 첫 번째 문자로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="77f061b9a5f55737090245a4c987a501fd31859d" translate="yes" xml:space="preserve">
          <source>Move to the &lt;var&gt;n&lt;/var&gt;th next button, or &lt;var&gt;n&lt;/var&gt;th previous button if &lt;var&gt;n&lt;/var&gt; is negative. If &lt;var&gt;n&lt;/var&gt; is zero, move to the start of any button at point. If &lt;var&gt;wrap&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, moving past either end of the buffer continues from the other end. If &lt;var&gt;display-message&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the button&amp;rsquo;s help-echo string is displayed. Any button with a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;skip&lt;/code&gt; property is skipped over. Returns the button found, and signals an error if no buttons can be found. If &lt;var&gt;no-error&lt;/var&gt; in non-&lt;code&gt;nil&lt;/code&gt;, return nil instead of signaling the error.</source>
          <target state="translated">받는 이동 &lt;var&gt;n&lt;/var&gt; 번째 다음 버튼 또는 &lt;var&gt;n&lt;/var&gt; 경우 번째 이전 버튼 &lt;var&gt;n&lt;/var&gt; 은 음수가된다. 경우 &lt;var&gt;n&lt;/var&gt; 제로 지점에서 아무 버튼의 시작으로 이동합니다. 경우 &lt;var&gt;wrap&lt;/var&gt; 비이다 &lt;code&gt;nil&lt;/code&gt; 버퍼의 양쪽 끝을지나 이동 타단에서 계속된다. &lt;var&gt;display-message&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 버튼의 도움말-에코 문자열이 표시됩니다. &lt;code&gt;nil&lt;/code&gt; 이 아닌 &lt;code&gt;skip&lt;/code&gt; 속성을 가진 모든 버튼 은 건너 뜁니다. 찾은 버튼을 반환하고 버튼을 찾을 수없는 경우 오류를 알립니다. 경우 &lt;var&gt;no-error&lt;/var&gt; 비의 &lt;code&gt;nil&lt;/code&gt; 오류 신호 대신 nil을 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="43a8000e954824d989286ea299c734a6c7cfc47e" translate="yes" xml:space="preserve">
          <source>Move to the &lt;var&gt;n&lt;/var&gt;th previous button, or &lt;var&gt;n&lt;/var&gt;th next button if &lt;var&gt;n&lt;/var&gt; is negative. If &lt;var&gt;n&lt;/var&gt; is zero, move to the start of any button at point. If &lt;var&gt;wrap&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, moving past either end of the buffer continues from the other end. If &lt;var&gt;display-message&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the button&amp;rsquo;s help-echo string is displayed. Any button with a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;skip&lt;/code&gt; property is skipped over. Returns the button found, and signals an error if no buttons can be found. If &lt;var&gt;no-error&lt;/var&gt; in non-&lt;code&gt;nil&lt;/code&gt;, return nil instead of signaling the error.</source>
          <target state="translated">받는 이동 &lt;var&gt;n&lt;/var&gt; 번째 이전 버튼 또는 &lt;var&gt;n&lt;/var&gt; 경우 번째 다음 버튼을 &lt;var&gt;n&lt;/var&gt; 음수가된다. 경우 &lt;var&gt;n&lt;/var&gt; 제로 지점에서 아무 버튼의 시작으로 이동합니다. 경우 &lt;var&gt;wrap&lt;/var&gt; 비이다 &lt;code&gt;nil&lt;/code&gt; 버퍼의 양쪽 끝을지나 이동 타단에서 계속된다. &lt;var&gt;display-message&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 버튼의 도움말-에코 문자열이 표시됩니다. &lt;code&gt;nil&lt;/code&gt; 이 아닌 &lt;code&gt;skip&lt;/code&gt; 속성을 가진 모든 버튼 은 건너 뜁니다. 찾은 버튼을 반환하고 버튼을 찾을 수없는 경우 오류를 알립니다. 경우 &lt;var&gt;no-error&lt;/var&gt; 비의 &lt;code&gt;nil&lt;/code&gt; 오류 신호 대신 nil을 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="82c00742d33b45dc4a64242477e55b1102b66060" translate="yes" xml:space="preserve">
          <source>Move to the beginning of the frame, or to the beginning of the previous frame.</source>
          <target state="translated">프레임의 시작 또는 이전 프레임의 시작으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="f893b5353d62ff9e12c35b7fb0f50fcaa8318d21" translate="yes" xml:space="preserve">
          <source>Move to the beginning of the next frame.</source>
          <target state="translated">다음 프레임의 시작 부분으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="f297af264dbf0d0932fcc470cbe1fecf16841cb6" translate="yes" xml:space="preserve">
          <source>Moving Marker Positions</source>
          <target state="translated">마커 위치 이동</target>
        </trans-unit>
        <trans-unit id="0bd65246c05a2e512da13871350157d560493acf" translate="yes" xml:space="preserve">
          <source>Moving around the existing windows.</source>
          <target state="translated">기존 창에서 이동합니다.</target>
        </trans-unit>
        <trans-unit id="2450710a86f0e38a5a79572127c7c737f5ad650e" translate="yes" xml:space="preserve">
          <source>Moving by parsing lists and sexps.</source>
          <target state="translated">목록과 성별을 구문 분석하여 이동합니다.</target>
        </trans-unit>
        <trans-unit id="bcf6a5cad29fb42b7bcbea23a358b3e4f0f14190" translate="yes" xml:space="preserve">
          <source>Moving in terms of characters.</source>
          <target state="translated">캐릭터 측면에서 이동합니다.</target>
        </trans-unit>
        <trans-unit id="5a0a7594babae65e9fe76da6d52f721490d43cae" translate="yes" xml:space="preserve">
          <source>Moving in terms of lines as displayed.</source>
          <target state="translated">표시된대로 줄 단위로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="13133c035ed058b88d7defb0074a4f22a2f70555" translate="yes" xml:space="preserve">
          <source>Moving in terms of lines of text.</source>
          <target state="translated">텍스트 줄로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="26b889272e175455d666cb66239aca23e15df9b4" translate="yes" xml:space="preserve">
          <source>Moving in terms of words.</source>
          <target state="translated">단어의 관점에서 움직입니다.</target>
        </trans-unit>
        <trans-unit id="53e7a90c8dae3998834ecec2913e2cd430599962" translate="yes" xml:space="preserve">
          <source>Moving over Balanced Expressions</source>
          <target state="translated">균형 잡힌 표현 위로 이동</target>
        </trans-unit>
        <trans-unit id="8693a264fbf00aa36cb635bdd23ca472a4fefbca" translate="yes" xml:space="preserve">
          <source>Moving over characters with certain syntaxes.</source>
          <target state="translated">특정 구문의 문자 위로 이동.</target>
        </trans-unit>
        <trans-unit id="042aaa586f3cf81580cc5e1f174b18fabcc9a6c1" translate="yes" xml:space="preserve">
          <source>Moving text up and down through the window.</source>
          <target state="translated">창을 통해 텍스트를 위아래로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="e0d03b42d9316b69bb4bfb00e411362bd9b92f0d" translate="yes" xml:space="preserve">
          <source>Moving the contents sideways on the window.</source>
          <target state="translated">창에서 콘텐츠를 옆으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="16062acc29ac83c08f815d725d13ca53166d371d" translate="yes" xml:space="preserve">
          <source>Moving the contents up and down on the window.</source>
          <target state="translated">창에서 콘텐츠를 위아래로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="7d1c895a6a69bb551cb3ab05a9436825b15affd7" translate="yes" xml:space="preserve">
          <source>Moving the marker to a new buffer or position.</source>
          <target state="translated">마커를 새 버퍼 또는 위치로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="ef6300d4905ba5885914045db1c0057a8e7f4297" translate="yes" xml:space="preserve">
          <source>Moving the mouse before releasing the button.</source>
          <target state="translated">버튼을 놓기 전에 마우스를 움직입니다.</target>
        </trans-unit>
        <trans-unit id="96d5ebfd5d41e3ac266699afa4c07f17d42dc6a2" translate="yes" xml:space="preserve">
          <source>Moving the mouse between frames.</source>
          <target state="translated">프레임간에 마우스를 이동합니다.</target>
        </trans-unit>
        <trans-unit id="1a17774ff24591b3f0339a2975566bc3052acf2a" translate="yes" xml:space="preserve">
          <source>Moving to the beginning or end of the buffer.</source>
          <target state="translated">버퍼의 시작 또는 끝으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="6bc8df29048775edb3b67797f960add5fb20f24e" translate="yes" xml:space="preserve">
          <source>Multi-Frame Images</source>
          <target state="translated">다중 프레임 이미지</target>
        </trans-unit>
        <trans-unit id="075c17f7c3e017a54cdac2a44040577e98923617" translate="yes" xml:space="preserve">
          <source>Multi-file Packages</source>
          <target state="translated">다중 파일 패키지</target>
        </trans-unit>
        <trans-unit id="5dd969976c5aa3ebe5d20441de8bf258343ebb9c" translate="yes" xml:space="preserve">
          <source>Multiline Font Lock Constructs</source>
          <target state="translated">여러 줄 글꼴 잠금 구성</target>
        </trans-unit>
        <trans-unit id="850c8a0b5e9ff569211d95d52d7ed685c25d8241" translate="yes" xml:space="preserve">
          <source>Multiple Terminals</source>
          <target state="translated">여러 터미널</target>
        </trans-unit>
        <trans-unit id="0b79f8e4890c8608e67c29a1e344d765772f2753" translate="yes" xml:space="preserve">
          <source>Mutability</source>
          <target state="translated">Mutability</target>
        </trans-unit>
        <trans-unit id="ad5e52be06b8d534aed54257f0dbf7aa8ff2ec03" translate="yes" xml:space="preserve">
          <source>Mutex Type</source>
          <target state="translated">뮤텍스 유형</target>
        </trans-unit>
        <trans-unit id="dd060da851122b430bf0f99b458f73ce7b008e14" translate="yes" xml:space="preserve">
          <source>Mutex objects have no read syntax. They print in hash notation, giving the name of the mutex (if it has been given a name) or its address in core:</source>
          <target state="translated">Mutex 개체에는 읽기 구문이 없습니다. 해시 표기법으로 인쇄하여 뮤텍스의 이름 (이름이 부여 된 경우) 또는 코어의 주소를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="82f2c9599c5c14be2ce92b9de958cb57db81b38f" translate="yes" xml:space="preserve">
          <source>Mutexes</source>
          <target state="translated">Mutexes</target>
        </trans-unit>
        <trans-unit id="5255835bbfa8722501d3084e2ba916530d5a554c" translate="yes" xml:space="preserve">
          <source>Mutexes allow exclusive access to data.</source>
          <target state="translated">뮤텍스는 데이터에 대한 독점 액세스를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="b51a60734da64be0e618bacbea2865a8a7dcd669" translate="yes" xml:space="preserve">
          <source>N</source>
          <target state="translated">N</target>
        </trans-unit>
        <trans-unit id="ad4ff2f947bcd2ef0dc89fd3a7ca83591ba37e18" translate="yes" xml:space="preserve">
          <source>NS builds consider the tool bar to be a decoration, and therefore hide it on an undecorated frame.</source>
          <target state="translated">NS 빌드는 도구 모음을 장식으로 간주하므로 장식되지 않은 프레임에 숨 깁니다.</target>
        </trans-unit>
        <trans-unit id="e97a54619a408647abe8729216664f6e3b8d47e9" translate="yes" xml:space="preserve">
          <source>NS builds do not clip child frames at the parent frame&amp;rsquo;s edges, allowing them to be positioned so they do not obscure the parent frame while still being visible themselves.</source>
          <target state="translated">NS 빌드는 부모 프레임의 가장자리에서 자식 프레임을 자르지 않으므로 위치를 지정하여 여전히 자체적으로 표시되는 동안 부모 프레임을 가리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eef19c54306daa69eda49c0272623bdb5e2b341f" translate="yes" xml:space="preserve">
          <source>NULL</source>
          <target state="translated">NULL</target>
        </trans-unit>
        <trans-unit id="93ba4abc16637fa77fe2aca725d91f288b90cfbb" translate="yes" xml:space="preserve">
          <source>NaCl</source>
          <target state="translated">NaCl</target>
        </trans-unit>
        <trans-unit id="f7fd9c68f804acda665d2ab082217bb1583318f2" translate="yes" xml:space="preserve">
          <source>NaN</source>
          <target state="translated">NaN</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="33b8ab26e443037c1b6a008d5daac383b918372d" translate="yes" xml:space="preserve">
          <source>Name of the physical monitor as &lt;var&gt;string&lt;/var&gt;.</source>
          <target state="translated">물리적 모니터의 이름 ( &lt;var&gt;string&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="33fc3e5c2e89aacc9b50f1169d442c12bb23fe2c" translate="yes" xml:space="preserve">
          <source>Naming Backup Files</source>
          <target state="translated">백업 파일 이름 지정</target>
        </trans-unit>
        <trans-unit id="e93d31d911fab1a3e2aba574d0e113197a0b7e55" translate="yes" xml:space="preserve">
          <source>Naming a Function</source>
          <target state="translated">함수 이름 지정</target>
        </trans-unit>
        <trans-unit id="697edbe4acd10b9466b672837ee81bd016c23b79" translate="yes" xml:space="preserve">
          <source>Narrow</source>
          <target state="translated">Narrow</target>
        </trans-unit>
        <trans-unit id="8ecb67c30433187282f082e25e52e62490e245cc" translate="yes" xml:space="preserve">
          <source>Narrowing</source>
          <target state="translated">Narrowing</target>
        </trans-unit>
        <trans-unit id="ba453f44e68e8506ff49aa121453956a2b98d6dd" translate="yes" xml:space="preserve">
          <source>Narrowing is specified with two buffer positions, which become the beginning and end of the accessible portion. For most editing commands and primitives, these positions replace the values of the beginning and end of the buffer. While narrowing is in effect, no text outside the accessible portion is displayed, and point cannot move outside the accessible portion. Note that narrowing does not alter actual buffer positions (see &lt;a href=&quot;point#Point&quot;&gt;Point&lt;/a&gt;); it only determines which positions are considered the accessible portion of the buffer. Most functions refuse to operate on text that is outside the accessible portion.</source>
          <target state="translated">축소는 액세스 가능한 부분의 시작과 끝이되는 두 개의 버퍼 위치로 지정됩니다. 대부분의 편집 명령 및 기본 요소의 경우 이러한 위치는 버퍼의 시작 및 끝 값을 대체합니다. 축소가 적용되는 동안 액세스 가능한 부분 외부의 텍스트는 표시되지 않으며 포인트가 액세스 가능한 부분 외부로 이동할 수 없습니다. 축소는 실제 버퍼 위치를 변경하지 않습니다 ( &lt;a href=&quot;point#Point&quot;&gt;Point&lt;/a&gt; 참조 ). 버퍼의 액세스 가능한 부분으로 간주되는 위치 만 결정합니다. 대부분의 함수는 액세스 가능한 부분 밖에있는 텍스트에서 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7bdf9620ee53a876bad1749f32c91f0860d2de5f" translate="yes" xml:space="preserve">
          <source>Native Frame</source>
          <target state="translated">네이티브 프레임</target>
        </trans-unit>
        <trans-unit id="bd2f2298f83f47b01df37aff3486ab3d7c655bdf" translate="yes" xml:space="preserve">
          <source>Naturally, Emacs will never signal &lt;code&gt;new-error&lt;/code&gt; on its own; only an explicit call to &lt;code&gt;signal&lt;/code&gt; (see &lt;a href=&quot;signaling-errors#Definition-of-signal&quot;&gt;Definition of signal&lt;/a&gt;) in your code can do this:</source>
          <target state="translated">당연히 Emacs는 자체적으로 &lt;code&gt;new-error&lt;/code&gt; 를 신호하지 않습니다 . 코드에서 &lt;code&gt;signal&lt;/code&gt; 대한 명시 적 호출 ( 시그널 &lt;a href=&quot;signaling-errors#Definition-of-signal&quot;&gt;정의&lt;/a&gt; 참조) 만이이를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d596b97b9719e1805fb3852fa7a7684551f102c" translate="yes" xml:space="preserve">
          <source>Negative parameter values position the right edge of the outer frame by &lt;var&gt;-x&lt;/var&gt; pixels left from the right edge of the screen (or the parent frame&amp;rsquo;s native rectangle) and the bottom edge by &lt;var&gt;-y&lt;/var&gt; pixels up from the bottom edge of the screen (or the parent frame&amp;rsquo;s native rectangle).</source>
          <target state="translated">음수 파라미터 값은에 의해 외부 프레임의 우측 에지 위치 &lt;var&gt;-x&lt;/var&gt; 화면의 우단에서 좌측 픽셀 (또는 상위 프레임의 기본 사각형) 및 의해 아래쪽 가장자리 &lt;var&gt;-y&lt;/var&gt; 화면 하단 에지로부터 픽셀 업 (또는 부모 프레임의 기본 사각형).</target>
        </trans-unit>
        <trans-unit id="5806a4fdd1b51a9d2dde88f7b0063ac5bf8c2a79" translate="yes" xml:space="preserve">
          <source>Negative values never indicate an offset from the right or bottom edge of &lt;var&gt;frame&lt;/var&gt;&amp;rsquo;s display or parent frame. Rather, they mean that &lt;var&gt;frame&lt;/var&gt;&amp;rsquo;s outer position is on the left and/or above the origin of its display or the native position of its parent frame. This usually means that &lt;var&gt;frame&lt;/var&gt; is only partially visible (or completely invisible). However, on systems where the display&amp;rsquo;s origin does not coincide with its top-left corner, the frame may be visible on a secondary monitor.</source>
          <target state="translated">음수 값은 &lt;var&gt;frame&lt;/var&gt; 표시 또는 상위 프레임 의 오른쪽 또는 아래쪽 가장자리에서의 오프셋을 나타내지 않습니다 . 오히려 이는 &lt;var&gt;frame&lt;/var&gt; 의 외부 위치가 디스플레이의 원점 또는 상위 프레임의 기본 위치 왼쪽 및 / 또는 위에 있음을 의미합니다. 이것은 일반적으로 &lt;var&gt;frame&lt;/var&gt; 이 부분적으로 만 보이거나 완전히 보이지 않음을 의미합니다. 그러나 디스플레이의 원점이 왼쪽 상단 모서리와 일치하지 않는 시스템에서는 프레임이 보조 모니터에 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50f671274ba560467341410034be03976b38330e" translate="yes" xml:space="preserve">
          <source>Nested association lists is supported:</source>
          <target state="translated">중첩 된 연관 목록이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="c347c211993fddc45bd180abc87a138a590651c8" translate="yes" xml:space="preserve">
          <source>Nested use of several change groups for the same buffer works as you would expect. Non-nested use of change groups for the same buffer will get Emacs confused, so don&amp;rsquo;t let it happen; the first change group you start for any given buffer should be the last one finished.</source>
          <target state="translated">동일한 버퍼에 대해 여러 변경 그룹을 중첩하여 사용하면 예상대로 작동합니다. 동일한 버퍼에 대해 변경 그룹을 중첩하지 않으면 Emacs가 혼란스러워 지므로 그렇게하지 마십시오. 주어진 버퍼에 대해 시작하는 첫 번째 변경 그룹은 마지막으로 완료된 그룹이어야합니다.</target>
        </trans-unit>
        <trans-unit id="d179e139906d2dd2f78172ff8723394a1290a6a3" translate="yes" xml:space="preserve">
          <source>Nesting &lt;code&gt;let-alist&lt;/code&gt; inside each other is allowed, but the code in the inner &lt;code&gt;let-alist&lt;/code&gt; can&amp;rsquo;t access the variables bound by the outer &lt;code&gt;let-alist&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;let-alist&lt;/code&gt; 를 서로 내부에 중첩하는 것은 허용되지만 내부 &lt;code&gt;let-alist&lt;/code&gt; 의 코드 는 외부 &lt;code&gt;let-alist&lt;/code&gt; 에 의해 바인딩 된 변수에 액세스 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="f4512de22f11934fdb81d9289bb39ac4b395feae" translate="yes" xml:space="preserve">
          <source>Network Connections</source>
          <target state="translated">네트워크 연결</target>
        </trans-unit>
        <trans-unit id="1a2ceca984e39b172fda21e503d83194676acb77" translate="yes" xml:space="preserve">
          <source>Network Options</source>
          <target state="translated">네트워크 옵션</target>
        </trans-unit>
        <trans-unit id="92a0a91f7ea484b5d2e0caa0572673102ce764e4" translate="yes" xml:space="preserve">
          <source>Network Servers</source>
          <target state="translated">네트워크 서버</target>
        </trans-unit>
        <trans-unit id="5e5da2cd3c810a62709e4258b89df7da017dd9e1" translate="yes" xml:space="preserve">
          <source>Network access</source>
          <target state="translated">네트워크 액세스</target>
        </trans-unit>
        <trans-unit id="4db16d13f459789c5e4f3a0b0eb58ac0b72836a4" translate="yes" xml:space="preserve">
          <source>Network connections and servers are created by calling &lt;code&gt;make-network-process&lt;/code&gt; with an argument list consisting of keyword/argument pairs, for example &lt;code&gt;:server t&lt;/code&gt; to create a server process, or &lt;code&gt;:type 'datagram&lt;/code&gt; to create a datagram connection. See &lt;a href=&quot;low_002dlevel-network#Low_002dLevel-Network&quot;&gt;Low-Level Network&lt;/a&gt;, for details. You can also use the &lt;code&gt;open-network-stream&lt;/code&gt; function described below.</source>
          <target state="translated">네트워크 연결 및 서버는 키워드 / 인수 쌍으로 구성된 인수 목록을 사용하여 &lt;code&gt;make-network-process&lt;/code&gt; 를 호출 하여 생성됩니다 &lt;code&gt;:server t&lt;/code&gt; 예를 들어 : server t 를 사용하여 서버 프로세스를 생성하거나 &lt;code&gt;:type 'datagram&lt;/code&gt; 을 사용하여 데이터 그램 연결을 생성합니다. 자세한 내용은 &lt;a href=&quot;low_002dlevel-network#Low_002dLevel-Network&quot;&gt;저수준 네트워크&lt;/a&gt; 를 참조하십시오. 아래에 설명 된 &lt;code&gt;open-network-stream&lt;/code&gt; 기능을 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="03c2b7b3aa6dd8790276a40fdff32df5fbd4ba6e" translate="yes" xml:space="preserve">
          <source>Network servers let Emacs accept net connections.</source>
          <target state="translated">네트워크 서버는 Emacs가 네트워크 연결을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="f7f37df5443218422ad6ebd50122d98556ecefca" translate="yes" xml:space="preserve">
          <source>Never add an autoload &lt;em&gt;comment&lt;/em&gt; to silence a compiler warning in another file. In the file that produces the warning, use &lt;code&gt;(defvar foo)&lt;/code&gt; to silence an undefined variable warning, and &lt;code&gt;declare-function&lt;/code&gt; (see &lt;a href=&quot;declaring-functions#Declaring-Functions&quot;&gt;Declaring Functions&lt;/a&gt;) to silence an undefined function warning; or require the relevant library; or use an explicit autoload &lt;em&gt;statement&lt;/em&gt;.</source>
          <target state="translated">다른 파일에서 컴파일러 경고를 무음 화하기 위해 자동로드 &lt;em&gt;주석&lt;/em&gt; 을 추가하지 마십시오 . 경고를 생성하는 파일에서 &lt;code&gt;(defvar foo)&lt;/code&gt; 를 사용 하여 정의되지 않은 변수 경고를 끄고 &lt;code&gt;declare-function&lt;/code&gt; ( 함수 &lt;a href=&quot;declaring-functions#Declaring-Functions&quot;&gt;선언&lt;/a&gt; 참조 )를 사용하여 정의되지 않은 함수 경고를 끄십시오 . 또는 관련 라이브러리가 필요합니다. 또는 명시적인 자동로드 &lt;em&gt;문을&lt;/em&gt; 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="9c2964759b06a2623b93cf7c65f17e2ef21aa268" translate="yes" xml:space="preserve">
          <source>Next in precedence are keymaps specified by enabled minor modes. These keymaps, if any, are specified by the variables &lt;code&gt;emulation-mode-map-alists&lt;/code&gt;, &lt;code&gt;minor-mode-overriding-map-alist&lt;/code&gt;, and &lt;code&gt;minor-mode-map-alist&lt;/code&gt;. See &lt;a href=&quot;controlling-active-maps#Controlling-Active-Maps&quot;&gt;Controlling Active Maps&lt;/a&gt;.</source>
          <target state="translated">다음은 활성화 된 부 모드로 지정된 키맵입니다. 이러한 키맵이있는 경우 &lt;code&gt;emulation-mode-map-alists&lt;/code&gt; , &lt;code&gt;minor-mode-overriding-map-alist&lt;/code&gt; 및 &lt;code&gt;minor-mode-map-alist&lt;/code&gt; 변수에 의해 지정됩니다 . &lt;a href=&quot;controlling-active-maps#Controlling-Active-Maps&quot;&gt;활성 맵 제어를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cf11fa80110f5add1f6e8df89357b576825e8423" translate="yes" xml:space="preserve">
          <source>Next in precedence is the buffer&amp;rsquo;s &lt;em&gt;local keymap&lt;/em&gt;, containing key bindings specific to the buffer. The minibuffer also has a local keymap (see &lt;a href=&quot;intro-to-minibuffers#Intro-to-Minibuffers&quot;&gt;Intro to Minibuffers&lt;/a&gt;). If there is a &lt;code&gt;local-map&lt;/code&gt; text or overlay property at point, that specifies the local keymap to use, in place of the buffer&amp;rsquo;s default local keymap.</source>
          <target state="translated">다음은 버퍼에 고유 한 키 바인딩을 포함 하는 버퍼의 &lt;em&gt;로컬 키맵&lt;/em&gt; 입니다. &lt;a href=&quot;intro-to-minibuffers#Intro-to-Minibuffers&quot;&gt;미니 버퍼&lt;/a&gt; 에는 로컬 키맵도 있습니다 ( 미니 버퍼 소개 참조 ). 가있는 경우 &lt;code&gt;local-map&lt;/code&gt; 지점에서 텍스트 또는 오버레이 속성, 그 지정 버퍼의 기본 로컬 키 맵 대신에 사용할 로컬 키맵.</target>
        </trans-unit>
        <trans-unit id="ea6e9f5900f2c58fe85d30179802bd1c82319521" translate="yes" xml:space="preserve">
          <source>Next to every menu bar item, Emacs displays a key binding that runs the same command (if such a key binding exists). This serves as a convenient hint for users who do not know the key binding. If a command has multiple bindings, Emacs normally displays the first one it finds. You can specify one particular key binding by assigning an &lt;code&gt;:advertised-binding&lt;/code&gt; symbol property to the command. See &lt;a href=&quot;keys-in-documentation#Keys-in-Documentation&quot;&gt;Keys in Documentation&lt;/a&gt;.</source>
          <target state="translated">모든 메뉴 모음 항목 옆에 Emacs는 동일한 명령을 실행하는 키 바인딩을 표시합니다 (이러한 키 바인딩이있는 경우). 이는 키 바인딩을 모르는 사용자에게 편리한 힌트 역할을합니다. 명령에 여러 바인딩이있는 경우 Emacs는 일반적으로 찾은 첫 번째 바인딩을 표시합니다. &lt;code&gt;:advertised-binding&lt;/code&gt; 기호 속성을 명령 에 할당하여 하나의 특정 키 바인딩을 지정할 수 있습니다 . &lt;a href=&quot;keys-in-documentation#Keys-in-Documentation&quot;&gt;문서의 키를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="27f58e46bfcfa765f0350cd6b6821ef674d81fef" translate="yes" xml:space="preserve">
          <source>Next we define the menu items:</source>
          <target state="translated">다음으로 메뉴 항목을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="71ae8da1cccbc9f22418d39bfa80cb8b8749d267" translate="yes" xml:space="preserve">
          <source>Next, Emacs adds any extra load directories that you specify using the</source>
          <target state="translated">다음으로 Emacs는 다음을 사용하여 지정하는 추가로드 디렉토리를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="d62380513230c1ed3241e1f5ee2099ae36407b91" translate="yes" xml:space="preserve">
          <source>Next, we call &lt;code&gt;(split-window W3 nil 'left)&lt;/code&gt;, passing the internal window &lt;var&gt;W3&lt;/var&gt; as the argument. The result:</source>
          <target state="translated">다음으로 &lt;code&gt;(split-window W3 nil 'left)&lt;/code&gt; 를 호출 하여 내부 창 &lt;var&gt;W3&lt;/var&gt; 을 인수로 전달합니다 . 결과:</target>
        </trans-unit>
        <trans-unit id="b961cdbb90d8271bcd99e03aa14df9f662fda815" translate="yes" xml:space="preserve">
          <source>Next, write an initialization function for the module.</source>
          <target state="translated">다음으로 모듈에 대한 초기화 함수를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="e71dbb9278b56b980f41278b5bdbd5ad829743eb" translate="yes" xml:space="preserve">
          <source>Next: stop at the next stop point encountered after an expression (&lt;code&gt;edebug-next-mode&lt;/code&gt;). Also see &lt;code&gt;edebug-forward-sexp&lt;/code&gt; in &lt;a href=&quot;jumping#Jumping&quot;&gt;Jumping&lt;/a&gt;.</source>
          <target state="translated">다음 : 표현식 ( &lt;code&gt;edebug-next-mode&lt;/code&gt; ) 다음에 만나는 다음 중지 지점에서 중지합니다 . 또한 참조 &lt;code&gt;edebug-forward-sexp&lt;/code&gt; 에서 &lt;a href=&quot;jumping#Jumping&quot;&gt;점프&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1e86fd1a5ff5402fe649662053b5f46f96ea16c3" translate="yes" xml:space="preserve">
          <source>No argument is matched but backtracking through the gate is disabled while matching the remainder of the specifications at this level. This is primarily used to generate more specific syntax error messages. See &lt;a href=&quot;backtracking#Backtracking&quot;&gt;Backtracking&lt;/a&gt;, for more details. Also see the &lt;code&gt;let&lt;/code&gt; example.</source>
          <target state="translated">일치하는 인수는 없지만 게이트를 통한 역 추적은이 수준에서 나머지 사양과 일치하는 동안 비활성화됩니다. 이것은 주로 더 구체적인 구문 오류 메시지를 생성하는 데 사용됩니다. 자세한 내용은 &lt;a href=&quot;backtracking#Backtracking&quot;&gt;역 추적&lt;/a&gt; 을 참조하십시오. &lt;code&gt;let&lt;/code&gt; 예제 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5cadafbd2e7190a2f1d2b8eedb1454e2868f07a2" translate="yes" xml:space="preserve">
          <source>No catch for tag</source>
          <target state="translated">태그 잡기 없음</target>
        </trans-unit>
        <trans-unit id="bbeb07f8bf2d7e3c732cf8947945435e8e59adfe" translate="yes" xml:space="preserve">
          <source>No obarray contains all symbols; in fact, some symbols are not in any obarray. They are called &lt;em&gt;uninterned symbols&lt;/em&gt;. An uninterned symbol has the same four cells as other symbols; however, the only way to gain access to it is by finding it in some other object or as the value of a variable.</source>
          <target state="translated">오바 레이에는 모든 기호가 포함되어 있지 않습니다. 실제로 일부 기호는 오바 레이에 없습니다. 비 &lt;em&gt;인터 기호&lt;/em&gt; 라고 합니다. 비 인터 기호에는 다른 기호와 동일한 4 개의 셀이 있습니다. 그러나 액세스 권한을 얻는 유일한 방법은 다른 개체에서 또는 변수의 값으로 찾는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8838111d4610c90296b30fc380a23778ca2a7a0e" translate="yes" xml:space="preserve">
          <source>No text is inserted.</source>
          <target state="translated">텍스트가 삽입되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="de830dc532a97e327dc9112b349772dda4316853" translate="yes" xml:space="preserve">
          <source>Non-</source>
          <target state="translated">Non-</target>
        </trans-unit>
        <trans-unit id="dd3e47873c08c1cbf08bc18047d3d358e469fc94" translate="yes" xml:space="preserve">
          <source>Non-&lt;code&gt;nil&lt;/code&gt; if IPv6 is supported.</source>
          <target state="translated">비 &lt;code&gt;nil&lt;/code&gt; IPv6의 경우 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="c137cc4db2df7f4be1c8cd466be3bbfbab527f39" translate="yes" xml:space="preserve">
          <source>Non-&lt;code&gt;nil&lt;/code&gt; if datagrams are supported.</source>
          <target state="translated">비 &lt;code&gt;nil&lt;/code&gt; 그램이 지원되는 경우.</target>
        </trans-unit>
        <trans-unit id="85ba9cd318b20fd143c7eef7c3f80b8dac2a20df" translate="yes" xml:space="preserve">
          <source>Non-&lt;code&gt;nil&lt;/code&gt; if inside a string. More precisely, this is the character that will terminate the string, or &lt;code&gt;t&lt;/code&gt; if a generic string delimiter character should terminate it.</source>
          <target state="translated">비 &lt;code&gt;nil&lt;/code&gt; 문자열 내부의 경우. 보다 정확하게는 이것은 문자열을 종료 할 문자이거나 일반 문자열 구분 문자가 종료해야하는 경우 &lt;code&gt;t&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9c329207815f864cfe40c306c4b2308f01044b65" translate="yes" xml:space="preserve">
          <source>Non-&lt;code&gt;nil&lt;/code&gt; if local (a.k.a. &amp;ldquo;UNIX domain&amp;rdquo;) sockets are supported.</source>
          <target state="translated">비 &lt;code&gt;nil&lt;/code&gt; 지역 (일명 &quot;UNIX 도메인 ') 소켓이 지원되는 경우.</target>
        </trans-unit>
        <trans-unit id="5b4d81358027d2cd5d76892ec114515c0d94000f" translate="yes" xml:space="preserve">
          <source>Non-&lt;code&gt;nil&lt;/code&gt; if non-blocking connect is supported.</source>
          <target state="translated">비 차단 연결이 지원되는 경우 &lt;code&gt;nil&lt;/code&gt; 이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="6a0195fbc2801af663ba0ec5723eebf901180bde" translate="yes" xml:space="preserve">
          <source>Non-&lt;code&gt;nil&lt;/code&gt; if the system can select the port for a server.</source>
          <target state="translated">비 &lt;code&gt;nil&lt;/code&gt; 시스템은 서버의 포트를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="298a4e63bde074768d01508f47e1e3a7d52b639a" translate="yes" xml:space="preserve">
          <source>Non-&lt;code&gt;nil&lt;/code&gt; if this window is dedicated to its buffer.</source>
          <target state="translated">비 &lt;code&gt;nil&lt;/code&gt; 이 창을 버퍼에 전념합니다.</target>
        </trans-unit>
        <trans-unit id="2d45527490c53e7bb3fcf4095792dbed717b907d" translate="yes" xml:space="preserve">
          <source>Non-&lt;code&gt;nil&lt;/code&gt; means current value of &lt;code&gt;start&lt;/code&gt; was the beginning of a line when it was chosen.</source>
          <target state="translated">Non- &lt;code&gt;nil&lt;/code&gt; 은 &lt;code&gt;start&lt;/code&gt; 의 현재 값 이 선택되었을 때 줄 의 시작 이라는 것을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="97e7e8cff888f916fc069faab013939aece0c530" translate="yes" xml:space="preserve">
          <source>Non-&lt;code&gt;nil&lt;/code&gt; means that regular expression matching for the sake of &lt;code&gt;font-lock-keywords&lt;/code&gt; should be case-insensitive.</source>
          <target state="translated">비 &lt;code&gt;nil&lt;/code&gt; 를 위해서 정규 표현 매칭 것을 의미 &lt;code&gt;font-lock-keywords&lt;/code&gt; 대소 문자를 구별해야한다.</target>
        </trans-unit>
        <trans-unit id="17f14e42cfe6c0c5fa4278037593c1cf2a9f7e46" translate="yes" xml:space="preserve">
          <source>Non-&lt;code&gt;nil&lt;/code&gt;&lt;var&gt;region-noncontiguous-p&lt;/var&gt; means that the region between &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt; is composed of noncontiguous pieces. The most common example of this is a rectangular region, where the pieces are separated by newline characters.</source>
          <target state="translated">Non- &lt;code&gt;nil&lt;/code&gt; &lt;var&gt;region-noncontiguous-p&lt;/var&gt; 는 &lt;var&gt;start&lt;/var&gt; 과 &lt;var&gt;end&lt;/var&gt; 사이의 영역 이 비 연속적인 부분으로 구성되어 있음을 의미합니다 . 가장 일반적인 예는 조각이 줄 바꿈 문자로 구분되는 직사각형 영역입니다.</target>
        </trans-unit>
        <trans-unit id="5d29f2d794a4e41245bc116e7d56afd0854763f8" translate="yes" xml:space="preserve">
          <source>Non-ASCII Characters</source>
          <target state="translated">비 ASCII 문자</target>
        </trans-unit>
        <trans-unit id="9a1964e6f1fd92781e6b1f5855e1a8b90a085deb" translate="yes" xml:space="preserve">
          <source>Non-ASCII Characters in Strings</source>
          <target state="translated">문자열의 비 ASCII 문자</target>
        </trans-unit>
        <trans-unit id="ee03ca40fe0fddf419289b00e54d3e235f27f181" translate="yes" xml:space="preserve">
          <source>Non-ASCII text in buffers and strings.</source>
          <target state="translated">버퍼 및 문자열의 비 ASCII 텍스트.</target>
        </trans-unit>
        <trans-unit id="6371bd35cb6aae61f199a61590cfd0399446eef8" translate="yes" xml:space="preserve">
          <source>Non-ASCII text written to the standard output or error descriptors is by default encoded using &lt;code&gt;locale-coding-system&lt;/code&gt; (see &lt;a href=&quot;locales#Locales&quot;&gt;Locales&lt;/a&gt;) if it is non-&lt;code&gt;nil&lt;/code&gt;; this can be overridden by binding &lt;code&gt;coding-system-for-write&lt;/code&gt; to a coding system of you choice (see &lt;a href=&quot;explicit-encoding#Explicit-Encoding&quot;&gt;Explicit Encoding&lt;/a&gt;).</source>
          <target state="translated">표준 출력 또는 오류 설명자에 기록 된 비 ASCII 텍스트 는 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 기본적으로 &lt;code&gt;locale-coding-system&lt;/code&gt; ( &lt;a href=&quot;locales#Locales&quot;&gt;Locales&lt;/a&gt; 참조 )을 사용하여 인코딩 됩니다 . 이 바인딩에 의해 대체 될 수 있습니다 &lt;code&gt;coding-system-for-write&lt;/code&gt; (참조 당신의 코딩 시스템의 선택에 &lt;a href=&quot;explicit-encoding#Explicit-Encoding&quot;&gt;명시 인코딩&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8f9dde119327e925337a2b9bade0b26729d73142" translate="yes" xml:space="preserve">
          <source>Non-constant variables whose value can &lt;em&gt;not&lt;/em&gt; be an arbitrary Lisp object.</source>
          <target state="translated">값 이 임의의 Lisp 객체가 될 수 &lt;em&gt;없는&lt;/em&gt; 상수가 아닌 변수 .</target>
        </trans-unit>
        <trans-unit id="ba5ac4c4b4eca5c161d4957f66dd2e8e98dbac8b" translate="yes" xml:space="preserve">
          <source>Non-printing control flag. When it is used, other specifiers must be given in the order of decreasing size, i.e., years before days, hours before minutes, etc. Nothing will be produced in the result string to the left of &amp;lsquo;</source>
          <target state="translated">인쇄되지 않는 제어 플래그. 사용되는 경우 다른 지정자는 크기가 줄어드는 순서 (예 : 몇 일 전, 몇 시간 전 등)를 지정해야합니다. '의 왼쪽에있는 결과 문자열에는 아무것도 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0978c4a08e7aa3c2e4530a665830e83fac749d6d" translate="yes" xml:space="preserve">
          <source>Non-zero if communication with the subprocess uses a pty; zero if it uses a pipe.</source>
          <target state="translated">하위 프로세스와의 통신이 pty를 사용하는 경우 0이 아닙니다. 파이프를 사용하는 경우 0입니다.</target>
        </trans-unit>
        <trans-unit id="5f22d5c13ab24217b6cce33d3adbd30e573e6278" translate="yes" xml:space="preserve">
          <source>Non-zero if this window is a &lt;em&gt;pseudo window&lt;/em&gt;. A pseudo window is either a window used to display the menu bar or the tool bar (when Emacs uses toolkits that don&amp;rsquo;t display their own menu bar and tool bar) or the tab bar or a window showing a tooltip on a tooltip frame. Pseudo windows are in general not accessible from Lisp code.</source>
          <target state="translated">이 창이 &lt;em&gt;의사 창 인&lt;/em&gt; 경우 0이 &lt;em&gt;아닙니다&lt;/em&gt; . 의사 창은 메뉴 막대 또는 도구 막대 (Emacs가 자체 메뉴 막대 및 도구 막대를 표시하지 않는 도구 키트를 사용하는 경우)를 표시하는 데 사용되는 창이거나 도구 설명 프레임에 도구 설명을 표시하는 창 또는 탭 막대입니다. 의사 창은 일반적으로 Lisp 코드에서 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="54314d871cb31d9ea8c00c7bd36602724ec562af" translate="yes" xml:space="preserve">
          <source>Non-zero if this window is a minibuffer window, a window showing the minibuffer or the echo area.</source>
          <target state="translated">이 창이 미니 버퍼 창, 미니 버퍼 또는 에코 영역을 표시하는 창인 경우 0이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="0ba1c3d1e346952de45a35d971ea7bad1bf252e0" translate="yes" xml:space="preserve">
          <source>Non-zero means the cursor in this window is logically off. This is used for blinking the cursor.</source>
          <target state="translated">0이 아님은이 창의 커서가 논리적으로 꺼져 있음을 의미합니다. 커서를 깜박이는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="16075a3db57978fdbecdd0a45ee972e34d651059" translate="yes" xml:space="preserve">
          <source>Non-zero means this window&amp;rsquo;s mode line needs to be updated.</source>
          <target state="translated">0이 아님은이 창의 모드 행을 업데이트해야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="71fab370af08ad66d6e2717a8c670408d7a79d19" translate="yes" xml:space="preserve">
          <source>None of the above functions suppress quitting.</source>
          <target state="translated">위의 기능 중 어느 것도 종료를 억제하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9bfc03cabd4be3ad4520d8a6d451463b5aa1986e" translate="yes" xml:space="preserve">
          <source>None of the arguments is instrumented.</source>
          <target state="translated">계측 된 인수가 없습니다.</target>
        </trans-unit>
        <trans-unit id="2df251e672be89a4e3f1f02e5d89d7600b0e8d4d" translate="yes" xml:space="preserve">
          <source>None of these three functions will make a frame smaller than needed to display all of its windows together with their scroll bars, fringes, margins, dividers, mode and header lines. This contrasts with requests by the window manager triggered, for example, by dragging the external border of a frame with the mouse. Such requests are always honored by clipping, if necessary, portions that cannot be displayed at the right, bottom corner of the frame. The parameters &lt;code&gt;min-width&lt;/code&gt; and &lt;code&gt;min-height&lt;/code&gt; (see &lt;a href=&quot;size-parameters#Size-Parameters&quot;&gt;Size Parameters&lt;/a&gt;) can be used to obtain a similar behavior when changing the frame size from within Emacs.</source>
          <target state="translated">이 세 가지 기능 중 어느 것도 스크롤 막대, 가장자리, 여백, 구분선, 모드 및 헤더 행과 함께 모든 창을 표시하는 데 필요한 것보다 작은 프레임을 만들지 않습니다. 이는 예를 들어 마우스로 프레임의 외부 테두리를 드래그하여 트리거 된 창 관리자의 요청과 대조됩니다. 이러한 요청은 필요한 경우 프레임의 오른쪽 하단 모서리에 표시 할 수없는 부분을 클리핑하여 항상 처리됩니다. 파라미터의 &lt;code&gt;min-width&lt;/code&gt; 및 &lt;code&gt;min-height&lt;/code&gt; (볼 &lt;a href=&quot;size-parameters#Size-Parameters&quot;&gt;크기 파라미터&lt;/a&gt; ) 이맥스 내에서 프레임 크기를 변경하는 경우와 유사한 문제를 얻기 위해 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="a13391618a7eb550b931b1ca7f5e7dea3f609549" translate="yes" xml:space="preserve">
          <source>Nonlocal Exits</source>
          <target state="translated">로컬이 아닌 출구</target>
        </trans-unit>
        <trans-unit id="04cfa77523068f9d99f2dadfb2d56696bd61d7b4" translate="yes" xml:space="preserve">
          <source>Nonlocal Exits in Modules</source>
          <target state="translated">모듈의 비 로컬 엑시트</target>
        </trans-unit>
        <trans-unit id="989a5aecc184b93ecbd769ecbad5acdea9c400aa" translate="yes" xml:space="preserve">
          <source>Nonlocal exits for the program&amp;rsquo;s own purposes.</source>
          <target state="translated">프로그램 자체의 목적을위한 비 로컬 종료.</target>
        </trans-unit>
        <trans-unit id="9fd8001fd6d82a32c9adc0fec8386196b8416cea" translate="yes" xml:space="preserve">
          <source>Nonprinting Characters in Strings</source>
          <target state="translated">문자열의 인쇄되지 않는 문자</target>
        </trans-unit>
        <trans-unit id="f8770b24b50ea318a926e10ce75d22b10fca1574" translate="yes" xml:space="preserve">
          <source>Normally all the elements are markers or &lt;code&gt;nil&lt;/code&gt;, but if &lt;var&gt;integers&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, that means to use integers instead of markers. (In that case, the buffer itself is appended as an additional element at the end of the list, to facilitate complete restoration of the match data.) If the last match was done on a string with &lt;code&gt;string-match&lt;/code&gt;, then integers are always used, since markers can&amp;rsquo;t point into a string.</source>
          <target state="translated">일반적으로 모든 요소는 마커 또는 &lt;code&gt;nil&lt;/code&gt; 이지만 &lt;var&gt;integers&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 마커 대신 정수를 사용한다는 의미입니다. (이 경우 버퍼 자체는 일치 데이터의 완전한 복원을 용이하게하기 위해 목록 끝에 추가 요소로 추가됩니다.) &lt;code&gt;string-match&lt;/code&gt; 가 있는 문자열에서 마지막 일치가 수행 된 경우 항상 정수가 사용됩니다. , 마커는 문자열을 가리킬 수 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="192d978732b9939fab239d8824137b1ba2ec3243" translate="yes" xml:space="preserve">
          <source>Normally any upper case event is converted to lower case if the original event is undefined and the lower case equivalent is defined. The argument &lt;var&gt;dont-downcase-last&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, means do not convert the last event to lower case. This is appropriate for reading a key sequence to be defined.</source>
          <target state="translated">일반적으로 원래 이벤트가 정의되지 않고 소문자에 해당하는 이벤트가 정의되면 모든 대문자 이벤트가 소문자로 변환됩니다. 인수 &lt;var&gt;dont-downcase-last&lt;/var&gt; , 비 경우 &lt;code&gt;nil&lt;/code&gt; 수단은 소문자로 마지막 이벤트를 변환하지 않습니다. 정의 할 키 시퀀스를 읽는 데 적합합니다.</target>
        </trans-unit>
        <trans-unit id="dad78cd65a27cbbd2fd73355d58cb98bdd207435" translate="yes" xml:space="preserve">
          <source>Normally completion operates on the whole string, so for all normal collections, this will always return &lt;code&gt;(0 . (length
&lt;var&gt;suffix&lt;/var&gt;))&lt;/code&gt;. But more complex completion such as completion on files is done one field at a time. For example, completion of &lt;code&gt;&quot;/usr/sh&quot;&lt;/code&gt; will include &lt;code&gt;&quot;/usr/share/&quot;&lt;/code&gt; but not &lt;code&gt;&quot;/usr/share/doc&quot;&lt;/code&gt; even if &lt;code&gt;&quot;/usr/share/doc&quot;&lt;/code&gt; exists. Also &lt;code&gt;all-completions&lt;/code&gt; on &lt;code&gt;&quot;/usr/sh&quot;&lt;/code&gt; will not include &lt;code&gt;&quot;/usr/share/&quot;&lt;/code&gt; but only &lt;code&gt;&quot;share/&quot;&lt;/code&gt;. So if &lt;var&gt;string&lt;/var&gt; is &lt;code&gt;&quot;/usr/sh&quot;&lt;/code&gt; and &lt;var&gt;suffix&lt;/var&gt; is &lt;code&gt;&quot;e/doc&quot;&lt;/code&gt;, &lt;code&gt;completion-boundaries&lt;/code&gt; will return &lt;code&gt;(5 . 1)&lt;/code&gt; which tells us that the &lt;var&gt;collection&lt;/var&gt; will only return completion information that pertains to the area after &lt;code&gt;&quot;/usr/&quot;&lt;/code&gt; and before &lt;code&gt;&quot;/doc&quot;&lt;/code&gt;.</source>
          <target state="translated">일반적으로 완성은 전체 문자열에서 작동하므로 모든 일반 컬렉션에 대해 항상 &lt;code&gt;(0 . (length &lt;var&gt;suffix&lt;/var&gt;))&lt;/code&gt; 반환 합니다. 그러나 파일 완성과 같은 더 복잡한 완성은 한 번에 한 필드 씩 수행됩니다. 예를 들어, 완료 &lt;code&gt;&quot;/usr/sh&quot;&lt;/code&gt; 포함 &lt;code&gt;&quot;/usr/share/&quot;&lt;/code&gt; 가 아니라 &lt;code&gt;&quot;/usr/share/doc&quot;&lt;/code&gt; 하더라도 &lt;code&gt;&quot;/usr/share/doc&quot;&lt;/code&gt; 존재한다. 또한 &lt;code&gt;all-completions&lt;/code&gt; 에 &lt;code&gt;&quot;/usr/sh&quot;&lt;/code&gt; 포함되지 않습니다 &lt;code&gt;&quot;/usr/share/&quot;&lt;/code&gt; 하지만 &lt;code&gt;&quot;share/&quot;&lt;/code&gt; . 따라서 &lt;var&gt;string&lt;/var&gt; 이 &lt;code&gt;&quot;/usr/sh&quot;&lt;/code&gt; 이면및 &lt;var&gt;suffix&lt;/var&gt; 입니다 &lt;code&gt;&quot;e/doc&quot;&lt;/code&gt; , &lt;code&gt;completion-boundaries&lt;/code&gt; 는 &lt;code&gt;(5 . 1)&lt;/code&gt; 을 반환 하여 &lt;var&gt;collection&lt;/var&gt; 이 &lt;code&gt;&quot;/usr/&quot;&lt;/code&gt; 이후 및 &lt;code&gt;&quot;/doc&quot;&lt;/code&gt; 이전 의 영역과 관련된 완료 정보 만 반환 함 을 알려줍니다 .</target>
        </trans-unit>
        <trans-unit id="eef86229b8453b39f2aa268e50526cd24df0ce4f" translate="yes" xml:space="preserve">
          <source>Normally the frame parameter &lt;code&gt;vertical-scroll-bars&lt;/code&gt; controls whether the windows in the frame have vertical scroll bars, and whether they are on the left or right. The frame parameter &lt;code&gt;scroll-bar-width&lt;/code&gt; specifies how wide they are (&lt;code&gt;nil&lt;/code&gt; meaning the default).</source>
          <target state="translated">일반적으로 프레임 매개 변수 &lt;code&gt;vertical-scroll-bars&lt;/code&gt; 는 프레임의 창에 세로 스크롤 막대가 있는지 여부와 왼쪽 또는 오른쪽에 있는지 여부를 제어합니다. 프레임 매개 변수 &lt;code&gt;scroll-bar-width&lt;/code&gt; 는 너비를 지정합니다 ( &lt;code&gt;nil&lt;/code&gt; 은 기본값을 의미 함).</target>
        </trans-unit>
        <trans-unit id="b67289438b7d78753fd70ed6a9106b4a91cda89b" translate="yes" xml:space="preserve">
          <source>Normally the menu bar shows global items followed by items defined by the local maps.</source>
          <target state="translated">일반적으로 메뉴 표시 줄에는 전역 항목과 로컬 맵에 정의 된 항목이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="b4ce40396bab6737ba31fe0b078bdd852088010f" translate="yes" xml:space="preserve">
          <source>Normally the strings in this menu are determined automatically from the choices; however, you can specify different strings for the menu by including the &lt;code&gt;:tag&lt;/code&gt; keyword in the alternatives. For example, if an integer stands for a number of spaces, while a string is text to use verbatim, you might write the customization type this way,</source>
          <target state="translated">일반적으로이 메뉴의 문자열은 선택 사항에 따라 자동으로 결정됩니다. 그러나 대안에 &lt;code&gt;:tag&lt;/code&gt; 키워드를 포함하여 메뉴에 대해 다른 문자열을 지정할 수 있습니다 . 예를 들어 정수가 여러 공백을 나타내고 문자열이 그대로 사용할 텍스트 인 경우 사용자 지정 유형을 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62b64002f4f8b319511bb978309afeb856e1036e" translate="yes" xml:space="preserve">
          <source>Normally this function returns a list of coding systems that could handle decoding the text that was scanned. They are listed in order of decreasing priority. But if &lt;var&gt;highest&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then the return value is just one coding system, the one that is highest in priority.</source>
          <target state="translated">일반적으로이 함수는 스캔 한 텍스트의 디코딩을 처리 할 수있는 코딩 시스템 목록을 반환합니다. 우선 순위가 낮은 순서대로 나열됩니다. 하지만 &lt;var&gt;highest&lt;/var&gt; 비입니다 &lt;code&gt;nil&lt;/code&gt; , 반환 값은 하나의 코딩 시스템, 우선 순위가 가장 높은 사람이다.</target>
        </trans-unit>
        <trans-unit id="ab4019dfe8ddc7d2f4af3e844b877df3f30a8685" translate="yes" xml:space="preserve">
          <source>Normally you add events to the front of this list, so that the events most recently unread will be reread first.</source>
          <target state="translated">일반적으로이 목록의 맨 앞에 이벤트를 추가하여 가장 최근에 읽지 않은 이벤트를 먼저 다시 읽도록합니다.</target>
        </trans-unit>
        <trans-unit id="9b2e214efb7720744217eac6eff20d8f98ffd008" translate="yes" xml:space="preserve">
          <source>Normally you do not need to set the stipple attribute, because it is used automatically to handle certain shades of gray.</source>
          <target state="translated">일반적으로 점각 속성은 특정 회색 음영을 처리하는 데 자동으로 사용되기 때문에 설정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c998bbdbb3cbe3ac5764a0951dbc909e2665a30b" translate="yes" xml:space="preserve">
          <source>Normally you don&amp;rsquo;t specify the name explicitly, and Emacs computes the frame name automatically based on a template stored in the variable &lt;code&gt;frame-title-format&lt;/code&gt;. Emacs recomputes the name each time the frame is redisplayed.</source>
          <target state="translated">일반적으로 이름을 명시 적으로 지정하지 않으며 Emacs는 변수 &lt;code&gt;frame-title-format&lt;/code&gt; 에 저장된 템플릿을 기반으로 프레임 이름을 자동으로 계산 합니다 . Emacs는 프레임이 다시 표시 될 때마다 이름을 다시 계산합니다.</target>
        </trans-unit>
        <trans-unit id="802f45620f0b9ed768e00202f167ac521857caf7" translate="yes" xml:space="preserve">
          <source>Normally you should not change the value of this variable.</source>
          <target state="translated">일반적으로이 변수의 값을 변경하면 안됩니다.</target>
        </trans-unit>
        <trans-unit id="7a23d4c059b6f9f25f5adc759fee5b9b134865c2" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;add-to-history&lt;/code&gt; removes duplicate members from the history list if &lt;code&gt;history-delete-duplicates&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;. However, if &lt;var&gt;keep-all&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, that says not to remove duplicates, and to add &lt;var&gt;newelt&lt;/var&gt; to the list even if it is empty.</source>
          <target state="translated">일반적으로 &lt;code&gt;add-to-history&lt;/code&gt; 는 &lt;code&gt;history-delete-duplicates&lt;/code&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 기록 목록에서 중복 멤버를 제거합니다 . 그러나 &lt;var&gt;keep-all&lt;/var&gt; 이 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 중복을 제거하지 않고 비어있는 경우에도 목록 에 &lt;var&gt;newelt&lt;/var&gt; 를 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="84a125fd6e14f51bb1790a0c3b9796a123e66347" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;define-abbrev&lt;/code&gt; sets the variable &lt;code&gt;abbrevs-changed&lt;/code&gt; to &lt;code&gt;t&lt;/code&gt;, if it actually changes the abbrev. This is so that some commands will offer to save the abbrevs. It does not do this for a system abbrev, since those aren&amp;rsquo;t saved anyway.</source>
          <target state="translated">일반적으로 &lt;code&gt;define-abbrev&lt;/code&gt; 는 실제로 abbrev를 변경하는 경우 &lt;code&gt;abbrevs-changed&lt;/code&gt; 변수 를 &lt;code&gt;t&lt;/code&gt; 로 설정합니다. 이것은 일부 명령이 약어를 저장하도록 제공하기위한 것입니다. 어차피 저장되지 않기 때문에 시스템 약어에 대해서는이를 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="970594f1826445de648390764f7d9d23076e7277" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;emacs_value&lt;/code&gt; objects have a rather short lifetime: it ends when the &lt;code&gt;emacs_env&lt;/code&gt; pointer used for their creation goes out of scope. Occasionally, you may need to create &lt;em&gt;global references&lt;/em&gt;: &lt;code&gt;emacs_value&lt;/code&gt; objects that live as long as you wish. Use the following two functions to manage such objects.</source>
          <target state="translated">일반적으로 &lt;code&gt;emacs_value&lt;/code&gt; 객체는 수명이 짧 습니다. 생성에 사용 된 &lt;code&gt;emacs_env&lt;/code&gt; 포인터가 범위를 벗어나 면 종료됩니다 . 때때로, 당신은 만들어야 할 수도 있습니다 &lt;em&gt;글로벌 참조&lt;/em&gt; : &lt;code&gt;emacs_value&lt;/code&gt; 만큼 당신이 원하는대로 살 개체를. 이러한 개체를 관리하려면 다음 두 가지 기능을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="39b787a71e5fbae9edb48d71ec234482e20b431b" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;map-y-or-n-p&lt;/code&gt; binds &lt;code&gt;cursor-in-echo-area&lt;/code&gt; while prompting. But if &lt;var&gt;no-cursor-in-echo-area&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it does not do that.</source>
          <target state="translated">일반적으로 &lt;code&gt;map-y-or-n-p&lt;/code&gt; 메시지를 표시하는 동안 &lt;code&gt;cursor-in-echo-area&lt;/code&gt; 바인딩 합니다. 그러나 &lt;var&gt;no-cursor-in-echo-area&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 그렇게하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b1b62f370a1c1a6e7086ac926443ce71d3d50fde" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;md5&lt;/code&gt; signals an error if the text can&amp;rsquo;t be encoded using the specified or chosen coding system. However, if &lt;var&gt;noerror&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it silently uses &lt;code&gt;raw-text&lt;/code&gt; coding instead.</source>
          <target state="translated">일반적으로 &lt;code&gt;md5&lt;/code&gt; 는 지정된 또는 선택한 코딩 시스템을 사용하여 텍스트를 인코딩 할 수없는 경우 오류 신호를 보냅니다. 그러나 &lt;var&gt;noerror&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 자동으로 &lt;code&gt;raw-text&lt;/code&gt; 코딩을 대신 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4c4fc931c5f12a4d2220d2a0743fc463a725a420" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;revert-buffer&lt;/code&gt; asks for confirmation before it changes the buffer; but if the argument &lt;var&gt;noconfirm&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;revert-buffer&lt;/code&gt; does not ask for confirmation.</source>
          <target state="translated">일반적으로 &lt;code&gt;revert-buffer&lt;/code&gt; 는 버퍼를 변경하기 전에 확인을 요청합니다. 인수하지만 만약 &lt;var&gt;noconfirm&lt;/var&gt; 비입니다 &lt;code&gt;nil&lt;/code&gt; , &lt;code&gt;revert-buffer&lt;/code&gt; 확인을 요구하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c7a8f6a1665078c7e303220251e8e70e9878aff0" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;transpose-regions&lt;/code&gt; relocates markers with the transposed text; a marker previously positioned within one of the two transposed portions moves along with that portion, thus remaining between the same two characters in their new position. However, if &lt;var&gt;leave-markers&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;transpose-regions&lt;/code&gt; does not do this&amp;mdash;it leaves all markers unrelocated.</source>
          <target state="translated">일반적으로 &lt;code&gt;transpose-regions&lt;/code&gt; 는 바뀐 텍스트로 마커를 재배치합니다. 두 개의 전치 된 부분 중 하나에 이전에 배치 된 마커는 해당 부분과 함께 이동하므로 새 위치에서 동일한 두 문자 사이에 남아 있습니다. 그러나 &lt;var&gt;leave-markers&lt;/var&gt; 비입니다 &lt;code&gt;nil&lt;/code&gt; , &lt;code&gt;transpose-regions&lt;/code&gt; 하지 않습니다이-는 unrelocated 모든 마커를 떠난다.</target>
        </trans-unit>
        <trans-unit id="c224a495efc6cae4ffaacc3200216d71860a3648" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;write-region&lt;/code&gt; displays the message &amp;lsquo;</source>
          <target state="translated">일반적으로 &lt;code&gt;write-region&lt;/code&gt; 은 '</target>
        </trans-unit>
        <trans-unit id="a463efccfae5102145810b771db2db6ac9df4444" translate="yes" xml:space="preserve">
          <source>Normally, &lt;var&gt;keymap&lt;/var&gt; is used just once, to look up the very next key. If the optional argument &lt;var&gt;keep-pred&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;, the map stays active as long as the user types keys defined in &lt;var&gt;keymap&lt;/var&gt;; when the user types a key that is not in &lt;var&gt;keymap&lt;/var&gt;, the transient keymap is deactivated and normal key lookup continues for that key.</source>
          <target state="translated">일반적으로 &lt;var&gt;keymap&lt;/var&gt; 은 바로 다음 키를 찾기 위해 한 번만 사용됩니다. 선택적 인수 &lt;var&gt;keep-pred&lt;/var&gt; 가 &lt;code&gt;t&lt;/code&gt; 이면 사용자가 &lt;var&gt;keymap&lt;/var&gt; 에 정의 된 키를 입력하는 한 맵은 활성 상태로 유지됩니다 . 사용자가 &lt;var&gt;keymap&lt;/var&gt; 에 없는 키를 입력 하면 임시 키맵이 비활성화되고 해당 키에 대한 일반 키 조회가 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="f65ffe59e12caca0f23c215b2caa4e497fa21c12" translate="yes" xml:space="preserve">
          <source>Normally, Emacs uses the face specs of each face to automatically calculate its attributes on each frame (see &lt;a href=&quot;defining-faces#Defining-Faces&quot;&gt;Defining Faces&lt;/a&gt;). The function &lt;code&gt;set-face-attribute&lt;/code&gt; can override this calculation by directly assigning attributes to a face, either on a specific frame or for all frames. This function is mostly intended for internal usage.</source>
          <target state="translated">일반적으로 Emacs는 각 얼굴의 얼굴 사양을 사용하여 각 프레임의 속성을 자동으로 계산합니다 ( &lt;a href=&quot;defining-faces#Defining-Faces&quot;&gt;얼굴 정의&lt;/a&gt; 참조 ). &lt;code&gt;set-face-attribute&lt;/code&gt; 함수 는 특정 프레임 또는 모든 프레임에서 얼굴에 속성을 직접 할당하여이 계산을 재정의 할 수 있습니다. 이 기능은 대부분 내부 용입니다.</target>
        </trans-unit>
        <trans-unit id="56d71e2eece71984f9cf83046339cf5cde803b82" translate="yes" xml:space="preserve">
          <source>Normally, a face is declared just once, using &lt;code&gt;defface&lt;/code&gt;, and any further changes to its appearance are applied using the Customize framework (e.g., via the Customize user interface or via the &lt;code&gt;custom-set-faces&lt;/code&gt; function; see &lt;a href=&quot;applying-customizations#Applying-Customizations&quot;&gt;Applying Customizations&lt;/a&gt;), or by face remapping (see &lt;a href=&quot;face-remapping#Face-Remapping&quot;&gt;Face Remapping&lt;/a&gt;). In the rare event that you need to change a face spec directly from Lisp, you can use the &lt;code&gt;face-spec-set&lt;/code&gt; function.</source>
          <target state="translated">일반적으로 얼굴은 &lt;code&gt;defface&lt;/code&gt; 를 사용하여 한 번만 선언 되며 , 모양에 대한 추가 변경 사항은 Customize 프레임 워크를 사용하여 적용됩니다 (예 : Customize 사용자 인터페이스 또는 &lt;code&gt;custom-set-faces&lt;/code&gt; 함수 를 통해, 사용자 정의 &lt;a href=&quot;applying-customizations#Applying-Customizations&quot;&gt;적용&lt;/a&gt; 참조 ). 얼굴 다시 매핑 ( &lt;a href=&quot;face-remapping#Face-Remapping&quot;&gt;얼굴 다시 매핑&lt;/a&gt; 참조 ). Lisp에서 직접 얼굴 사양을 변경해야하는 드문 경우에는 &lt;code&gt;face-spec-set&lt;/code&gt; 함수를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ef564d0438f8b582059c4f06fa6f5901a7eb5fe3" translate="yes" xml:space="preserve">
          <source>Normally, a newline is automatically inserted after the header, the footer and every node&amp;rsquo;s textual description. If &lt;var&gt;nosep&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, no newline is inserted. This may be useful for displaying an entire ewoc on a single line, for example, or for making nodes invisible by arranging for &lt;var&gt;pretty-printer&lt;/var&gt; to do nothing for those nodes.</source>
          <target state="translated">일반적으로 새 줄은 머리글, 바닥 글 및 모든 노드의 텍스트 설명 뒤에 자동으로 삽입됩니다. 경우 &lt;var&gt;nosep&lt;/var&gt; 가 비이다 &lt;code&gt;nil&lt;/code&gt; , 개행을 삽입하지 않는다. 이것은 예를 들어 한 줄에 전체 ewoc을 표시하거나 &lt;var&gt;pretty-printer&lt;/var&gt; 가 해당 노드에 대해 아무것도하지 않도록 배열하여 노드를 보이지 않게 만드는 데 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="78ecfe635d86fae4e7dabe6c5a40c28ac6789c76" translate="yes" xml:space="preserve">
          <source>Normally, a red highlight indicates the form was never completely evaluated; a brown highlight means it always evaluated to the same value (meaning there has been little testing of what is done with the result). However, the red highlight is skipped for forms that can&amp;rsquo;t possibly complete their evaluation, such as &lt;code&gt;error&lt;/code&gt;. The brown highlight is skipped for forms that are expected to always evaluate to the same value, such as &lt;code&gt;(setq x 14)&lt;/code&gt;.</source>
          <target state="translated">일반적으로 빨간색 강조 표시는 양식이 완전히 평가되지 않았 음을 나타냅니다. 갈색 강조 표시는 항상 동일한 값으로 평가됨을 의미합니다 (결과로 수행 된 작업에 대한 테스트가 거의 없음을 의미 함). 그러나 &lt;code&gt;error&lt;/code&gt; 와 같이 평가를 완료 할 수없는 양식의 경우 빨간색 강조 표시를 건너 뜁니다 . &lt;code&gt;(setq x 14)&lt;/code&gt; 와 같이 항상 동일한 값으로 평가 될 것으로 예상되는 양식의 경우 갈색 강조 표시를 건너 뜁니다 .</target>
        </trans-unit>
        <trans-unit id="b7854440eb6b90acf05dcac089bc58cb02d3786d" translate="yes" xml:space="preserve">
          <source>Normally, commands specify which representation to use for the prefix argument, either numeric or raw, in the &lt;code&gt;interactive&lt;/code&gt; specification. (See &lt;a href=&quot;using-interactive#Using-Interactive&quot;&gt;Using Interactive&lt;/a&gt;.) Alternatively, functions may look at the value of the prefix argument directly in the variable &lt;code&gt;current-prefix-arg&lt;/code&gt;, but this is less clean.</source>
          <target state="translated">일반적으로 명령은 &lt;code&gt;interactive&lt;/code&gt; 사양 에서 접두사 인수에 사용할 표현 (숫자 또는 원시)을 지정합니다. ( &lt;a href=&quot;using-interactive#Using-Interactive&quot;&gt;대화 형 사용&lt;/a&gt; 참조 ) 또는 함수는 &lt;code&gt;current-prefix-arg&lt;/code&gt; 변수에서 직접 접두사 인수의 값을 볼 수 있지만 덜 명확합니다.</target>
        </trans-unit>
        <trans-unit id="0922fd40705d46e517e311d0b4534c4d4aea3a25" translate="yes" xml:space="preserve">
          <source>Normally, deleting a large amount of text from a buffer inhibits further auto-saving of that buffer because it has shrunk. However, &lt;code&gt;erase-buffer&lt;/code&gt; does not do this, the idea being that the future text is not really related to the former text, and its size should not be compared with that of the former text.</source>
          <target state="translated">일반적으로 버퍼에서 많은 양의 텍스트를 삭제하면 버퍼가 축소 되었기 때문에 해당 버퍼의 추가 자동 저장이 금지됩니다. 그러나 &lt;code&gt;erase-buffer&lt;/code&gt; 는이를 수행하지 않습니다. 미래 텍스트는 이전 텍스트와 실제로 관련이 없으며 크기를 이전 텍스트와 비교해서는 안된다는 생각입니다.</target>
        </trans-unit>
        <trans-unit id="2b35691422f5a8a262ba1ccbae353a8209b947f0" translate="yes" xml:space="preserve">
          <source>Normally, displaying a long message resizes the echo area to display the entire message. But if the variable &lt;code&gt;message-truncate-lines&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the echo area does not resize, and the message is truncated to fit it.</source>
          <target state="translated">일반적으로 긴 메시지를 표시하면 전체 메시지를 표시하도록 에코 영역의 크기가 조정됩니다. 그러나 &lt;code&gt;message-truncate-lines&lt;/code&gt; 변수 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 에코 영역의 크기가 조정되지 않고 메시지가 이에 맞게 잘립니다.</target>
        </trans-unit>
        <trans-unit id="f23d4ac50b4b0692f85e2c612a9dbf51f5ee0c69" translate="yes" xml:space="preserve">
          <source>Normally, each entry in a &lt;code&gt;list&lt;/code&gt; or &lt;code&gt;vector&lt;/code&gt; type specification describes a single element type. But when an entry contains &lt;code&gt;:inline t&lt;/code&gt;, the value it matches is merged directly into the containing sequence. For example, if the entry matches a list with three elements, those become three elements of the overall sequence. This is analogous to &amp;lsquo;</source>
          <target state="translated">일반적으로 &lt;code&gt;list&lt;/code&gt; 또는 &lt;code&gt;vector&lt;/code&gt; 유형 사양의 각 항목 은 단일 요소 유형을 설명합니다. 그러나 항목에 &lt;code&gt;:inline t&lt;/code&gt; 가 포함되어 있으면 일치하는 값이 포함하는 시퀀스에 직접 병합됩니다. 예를 들어 항목이 세 개의 요소가있는 목록과 일치하면 전체 시퀀스의 세 요소가됩니다. 이것은 '</target>
        </trans-unit>
        <trans-unit id="467a0b75a915def14074129749af0e39f8c66a1c" translate="yes" xml:space="preserve">
          <source>Normally, each frame has its own minibuffer window at the bottom, which is used whenever that frame is selected. You can get that window with the function &lt;code&gt;minibuffer-window&lt;/code&gt; (see &lt;a href=&quot;minibuffer-windows#Minibuffer-Windows&quot;&gt;Minibuffer Windows&lt;/a&gt;).</source>
          <target state="translated">일반적으로 각 프레임에는 해당 프레임이 선택 될 때마다 사용되는 자체 미니 버퍼 창이 맨 아래에 있습니다. &lt;code&gt;minibuffer-window&lt;/code&gt; 함수로 해당 창을 가져올 수 있습니다 ( &lt;a href=&quot;minibuffer-windows#Minibuffer-Windows&quot;&gt;Minibuffer Windows&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="f47235bc295fc9ef73d437c414c49bbdf12a693c" translate="yes" xml:space="preserve">
          <source>Normally, elements of &lt;code&gt;font-lock-keywords&lt;/code&gt; should not match across multiple lines; that doesn&amp;rsquo;t work reliably, because Font Lock usually scans just part of the buffer, and it can miss a multi-line construct that crosses the line boundary where the scan starts. (The scan normally starts at the beginning of a line.)</source>
          <target state="translated">일반적으로 &lt;code&gt;font-lock-keywords&lt;/code&gt; 의 요소는 여러 행에서 일치하지 않아야합니다. 글꼴 잠금은 일반적으로 버퍼의 일부만 스캔하고 스캔이 시작되는 라인 경계를 가로 지르는 다중 라인 구성을 놓칠 수 있기 때문에 안정적으로 작동하지 않습니다. (스캔은 일반적으로 줄의 시작 부분에서 시작됩니다.)</target>
        </trans-unit>
        <trans-unit id="d12bd9c60258b05b553df099e61b1e0db5cc0eb0" translate="yes" xml:space="preserve">
          <source>Normally, errors caught by &lt;code&gt;condition-case&lt;/code&gt; never invoke the debugger. The &lt;code&gt;condition-case&lt;/code&gt; gets a chance to handle the error before the debugger gets a chance.</source>
          <target state="translated">일반적으로 &lt;code&gt;condition-case&lt;/code&gt; 의해 포착 된 오류 는 디버거를 호출하지 않습니다. &lt;code&gt;condition-case&lt;/code&gt; 디버거가 기회를 얻기 전에 오류를 처리 할 수있는 기회를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="54a2bd94783a47980369965cd627bee242490611" translate="yes" xml:space="preserve">
          <source>Normally, if &lt;var&gt;character&lt;/var&gt; is an</source>
          <target state="translated">일반적으로 &lt;var&gt;character&lt;/var&gt; 가</target>
        </trans-unit>
        <trans-unit id="d50713f555db79e954a816742203790399e0673d" translate="yes" xml:space="preserve">
          <source>Normally, if &lt;var&gt;element&lt;/var&gt; is added, it is added to the front of &lt;var&gt;symbol&lt;/var&gt;, but if the optional argument &lt;var&gt;append&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it is added at the end.</source>
          <target state="translated">일반적으로 &lt;var&gt;element&lt;/var&gt; 가 추가되면 &lt;var&gt;symbol&lt;/var&gt; 앞에 추가 되지만 선택적인 인수 &lt;var&gt;append&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 끝에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="d6187789e5ea59be13e6c842c07c9deb29b1d4bb" translate="yes" xml:space="preserve">
          <source>Normally, it is not necessary to manipulate fonts directly. In case you need to do so, this section explains how.</source>
          <target state="translated">일반적으로 글꼴을 직접 조작 할 필요는 없습니다. 필요한 경우이 섹션에서 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="becd1bd4e621ec277e1f58244c23bb4b5b4c4b17" translate="yes" xml:space="preserve">
          <source>Normally, it modifies a category set by adding &lt;var&gt;category&lt;/var&gt; to it. But if &lt;var&gt;reset&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then it deletes &lt;var&gt;category&lt;/var&gt; instead.</source>
          <target state="translated">일반적으로 카테고리 세트에 &lt;var&gt;category&lt;/var&gt; 를 추가하여 수정 합니다. 그러나 &lt;var&gt;reset&lt;/var&gt; 이 &lt;code&gt;nil&lt;/code&gt; 이 아니면 대신 &lt;var&gt;category&lt;/var&gt; 를 삭제 합니다.</target>
        </trans-unit>
        <trans-unit id="33a09b1e73b35c5e6e469be538e26ad9f62399d8" translate="yes" xml:space="preserve">
          <source>Normally, prefer &lt;code&gt;intptr_t&lt;/code&gt; for internal representations of pointers, or for integers bounded only by the number of objects that can exist at any given time or by the total number of bytes that can be allocated. However, prefer &lt;code&gt;uintptr_t&lt;/code&gt; to represent pointer arithmetic that could cross page boundaries. For example, on a machine with a 32-bit address space an array could cross the 0x7fffffff/0x80000000 boundary, which would cause an integer overflow when adding 1 to &lt;code&gt;(intptr_t) 0x7fffffff&lt;/code&gt;.</source>
          <target state="translated">일반적으로 포인터의 내부 표현 또는 주어진 시간에 존재할 수있는 객체 수 또는 할당 할 수있는 총 바이트 수로 제한되는 정수의 경우 &lt;code&gt;intptr_t&lt;/code&gt; 를 선호합니다 . 그러나 페이지 경계를 넘을 수있는 포인터 산술을 나타내려면 &lt;code&gt;uintptr_t&lt;/code&gt; 를 선호 하십시오. 예를 들어 32 비트 주소 공간이있는 시스템에서 배열은 0x7fffffff / 0x80000000 경계를 넘을 수 있으며, 이로 인해 &lt;code&gt;(intptr_t) 0x7fffffff&lt;/code&gt; 1을 더할 때 정수 오버플로가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="1e6c689be8312b59b07bf40709097a3c5731537c" translate="yes" xml:space="preserve">
          <source>Normally, repetition forms are greedy, in that they attempt to match as many times as possible. Some forms are non-greedy; they try to match as few times as possible (see &lt;a href=&quot;regexp-special#Non_002dgreedy-repetition&quot;&gt;Non-greedy repetition&lt;/a&gt;).</source>
          <target state="translated">일반적으로 반복 형식은 가능한 한 여러 번 일치 시키려고 시도한다는 점에서 탐욕 스럽습니다. 일부 양식은 탐욕스럽지 않습니다. 가능한 한 적은 횟수로 매칭을 시도합니다 ( &lt;a href=&quot;regexp-special#Non_002dgreedy-repetition&quot;&gt;욕심없는 반복&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="8afe6491950d0be63d8da54adfd8c5f2338d800f" translate="yes" xml:space="preserve">
          <source>Normally, the</source>
          <target state="translated">일반적으로</target>
        </trans-unit>
        <trans-unit id="30802bf54b72f5663b6407f90667f9e51d089434" translate="yes" xml:space="preserve">
          <source>Normally, the argument expressions are not evaluated as part of computing the macro expansion, but instead appear as part of the expansion, so they are computed when the expansion is evaluated.</source>
          <target state="translated">일반적으로 인수 표현식은 매크로 확장 계산의 일부로 평가되지 않고 대신 확장의 일부로 표시되므로 확장이 평가 될 때 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="629b571150fb4d121b8cb2e6cf7f1cf6cc68f709" translate="yes" xml:space="preserve">
          <source>Normally, the buffer displayed in the selected window is the current buffer, but this is not always so: a Lisp program can temporarily designate any buffer as current in order to operate on its contents, without changing what is displayed on the screen. The most basic function for designating a current buffer is &lt;code&gt;set-buffer&lt;/code&gt;.</source>
          <target state="translated">일반적으로 선택한 창에 표시되는 버퍼는 현재 버퍼이지만 항상 그런 것은 아닙니다. Lisp 프로그램은 화면에 표시되는 내용을 변경하지 않고 내용에 대해 작동하기 위해 일시적으로 버퍼를 현재 버퍼로 지정할 수 있습니다. 현재 버퍼를 지정하는 가장 기본적인 기능은 &lt;code&gt;set-buffer&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1ef79e40f4fe75ea19a532d8a9828e867c6dc545" translate="yes" xml:space="preserve">
          <source>Normally, the cursor is displayed at the beginning or the end of any overlay and text property strings present at the current buffer position. You can place the cursor on any desired character of these strings by giving that character a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;cursor&lt;/code&gt; text property. In addition, if the value of the &lt;code&gt;cursor&lt;/code&gt; property is an integer, it specifies the number of buffer&amp;rsquo;s character positions, starting with the position where the overlay or the &lt;code&gt;display&lt;/code&gt; property begins, for which the cursor should be displayed on that character. Specifically, if the value of the &lt;code&gt;cursor&lt;/code&gt; property of a character is the number &lt;var&gt;n&lt;/var&gt;, the cursor will be displayed on this character for any buffer position in the range &lt;code&gt;[&lt;var&gt;ovpos&lt;/var&gt;..&lt;var&gt;ovpos&lt;/var&gt;+&lt;var&gt;n&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;ovpos&lt;/var&gt; is the overlay&amp;rsquo;s starting position given by &lt;code&gt;overlay-start&lt;/code&gt; (see &lt;a href=&quot;managing-overlays#Managing-Overlays&quot;&gt;Managing Overlays&lt;/a&gt;), or the position where the &lt;code&gt;display&lt;/code&gt; text property begins in the buffer.</source>
          <target state="translated">일반적으로 커서는 현재 버퍼 위치에있는 오버레이 및 텍스트 속성 문자열의 시작 또는 끝 부분에 표시됩니다. 해당 문자에 &lt;code&gt;nil&lt;/code&gt; 이 아닌 &lt;code&gt;cursor&lt;/code&gt; 텍스트 속성을 지정 하여 이러한 문자열의 원하는 문자에 커서를 놓을 수 있습니다 . 또한 &lt;code&gt;cursor&lt;/code&gt; 속성 의 값이 정수이면 해당 문자에 커서가 표시되어야 하는 오버레이 또는 &lt;code&gt;display&lt;/code&gt; 속성이 시작 되는 위치부터 시작하여 버퍼의 문자 위치 수를 지정합니다 . 특히, 문자 의 &lt;code&gt;cursor&lt;/code&gt; 속성 값이 숫자 &lt;var&gt;n&lt;/var&gt; 인 경우 커서는 &lt;code&gt;[&lt;var&gt;ovpos&lt;/var&gt;..&lt;var&gt;ovpos&lt;/var&gt;+&lt;var&gt;n&lt;/var&gt;)&lt;/code&gt; , 여기서 &lt;var&gt;ovpos&lt;/var&gt; 는 &lt;code&gt;overlay-start&lt;/code&gt; (&lt;a href=&quot;managing-overlays#Managing-Overlays&quot;&gt; 오버레이 관리&lt;/a&gt; 참조)에의해 제공된 오버레이의 시작 위치또는버퍼에서 &lt;code&gt;display&lt;/code&gt; 텍스트 속성이 시작되는위치입니다.</target>
        </trans-unit>
        <trans-unit id="6e260092c506bb0904c31069887686f085d03db5" translate="yes" xml:space="preserve">
          <source>Normally, the keymap &lt;code&gt;query-replace-map&lt;/code&gt; defines the possible user responses for queries. The argument &lt;var&gt;map&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, specifies a keymap to use instead of &lt;code&gt;query-replace-map&lt;/code&gt;.</source>
          <target state="translated">일반적으로 keymap &lt;code&gt;query-replace-map&lt;/code&gt; 은 쿼리에 대한 가능한 사용자 응답을 정의합니다. &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 인수 &lt;var&gt;map&lt;/var&gt; 은 &lt;code&gt;query-replace-map&lt;/code&gt; 대신 사용할 키맵을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="c9bc529dca0e2a9cf79b4d035ef919efc70874fc" translate="yes" xml:space="preserve">
          <source>Normally, the specified buffer is put at the front of the buffer list&amp;mdash;both the global buffer list and the selected frame&amp;rsquo;s buffer list (see &lt;a href=&quot;buffer-list#Buffer-List&quot;&gt;Buffer List&lt;/a&gt;). However, this is not done if the optional argument &lt;var&gt;norecord&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">일반적으로 지정된 버퍼는 전역 버퍼 목록과 선택한 프레임의 버퍼 목록 모두 버퍼 목록의 맨 앞에 배치됩니다 ( &lt;a href=&quot;buffer-list#Buffer-List&quot;&gt;버퍼 목록&lt;/a&gt; 참조 ). 그러나 선택적 인수 &lt;var&gt;norecord&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우에는 수행되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7936ac8e02ea68233dc9ba1fd5cca740f87f5020" translate="yes" xml:space="preserve">
          <source>Normally, the variables &lt;code&gt;window-min-height&lt;/code&gt; and &lt;code&gt;window-min-width&lt;/code&gt; specify the smallest allowable window size (see &lt;a href=&quot;window-sizes#Window-Sizes&quot;&gt;Window Sizes&lt;/a&gt;). However, if the optional argument &lt;var&gt;ignore&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, this function ignores &lt;code&gt;window-min-height&lt;/code&gt; and &lt;code&gt;window-min-width&lt;/code&gt;, as well as &lt;code&gt;window-size-fixed&lt;/code&gt;. Instead, it considers the minimum-height window to be one consisting of a header and a mode line, a horizontal scrollbar and a bottom divider (if any), plus a text area one line tall; and a minimum-width window as one consisting of fringes, margins, a scroll bar and a right divider (if any), plus a text area two columns wide.</source>
          <target state="translated">일반적으로 &lt;code&gt;window-min-height&lt;/code&gt; 및 &lt;code&gt;window-min-width&lt;/code&gt; 변수 는 허용 가능한 최소 창 크기를 지정합니다 ( &lt;a href=&quot;window-sizes#Window-Sizes&quot;&gt;창 크기&lt;/a&gt; 참조 ). 그러나 선택적 인수 &lt;var&gt;ignore&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우이 함수는 &lt;code&gt;window-min-height&lt;/code&gt; 및 &lt;code&gt;window-min-width&lt;/code&gt; 와 &lt;code&gt;window-size-fixed&lt;/code&gt; 를 무시합니다 . 대신, 최소 높이 창을 헤더와 모드 라인, 수평 스크롤바 및 하단 구분선 (있는 경우), 한 줄 높이의 텍스트 영역으로 구성된 창으로 간주합니다. 가장자리, 여백, 스크롤 막대 및 오른쪽 구분선 (있는 경우)과 2 열 너비의 텍스트 영역으로 구성된 최소 너비 창.</target>
        </trans-unit>
        <trans-unit id="c5713371bb37a8cdef55c3106ef4460970d0eab6" translate="yes" xml:space="preserve">
          <source>Normally, this command puts point before the inserted text, and the mark after it. However, if the optional second argument &lt;var&gt;beforep&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it puts the mark before and point after.</source>
          <target state="translated">일반적으로이 명령은 삽입 된 텍스트 앞에 포인트를 배치하고 그 뒤에 마크를 배치합니다. 그러나 선택적인 두 번째 인수 &lt;var&gt;beforep&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 표시를 앞뒤에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="3d42087a0d42cd57b27861aa1a1b4a750c8b489d" translate="yes" xml:space="preserve">
          <source>Normally, this command reinitializes the buffer&amp;rsquo;s major and minor modes using &lt;code&gt;normal-mode&lt;/code&gt;. But if &lt;var&gt;preserve-modes&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the modes remain unchanged.</source>
          <target state="translated">일반적으로이 명령은 &lt;code&gt;normal-mode&lt;/code&gt; 를 사용하여 버퍼의 주 모드와 부 모드를 다시 초기화 합니다 . 그러나 &lt;var&gt;preserve-modes&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 모드는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aa1a4bffdaf1e62a462694623e95b20201dc51ec" translate="yes" xml:space="preserve">
          <source>Normally, this function asks the user for confirmation if there already is a buffer visiting &lt;var&gt;filename&lt;/var&gt;. If &lt;var&gt;no-query&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, that prevents asking this question. If there already is a buffer visiting &lt;var&gt;filename&lt;/var&gt;, and the user confirms or &lt;var&gt;no-query&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, this function makes the new buffer name unique by appending a number inside of &amp;lsquo;</source>
          <target state="translated">Normally, this function asks the user for confirmation if there already is a buffer visiting &lt;var&gt;filename&lt;/var&gt; . If &lt;var&gt;no-query&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , that prevents asking this question. If there already is a buffer visiting &lt;var&gt;filename&lt;/var&gt; , and the user confirms or &lt;var&gt;no-query&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , this function makes the new buffer name unique by appending a number inside of &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="64fcbebdb92f9124f1312a1ae2441a038070f262" translate="yes" xml:space="preserve">
          <source>Normally, this function inserts newline characters into the encoded text, to avoid overlong lines. However, if the optional argument &lt;var&gt;no-line-break&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, these newlines are not added, so the output is just one long line.</source>
          <target state="translated">Normally, this function inserts newline characters into the encoded text, to avoid overlong lines. However, if the optional argument &lt;var&gt;no-line-break&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , these newlines are not added, so the output is just one long line.</target>
        </trans-unit>
        <trans-unit id="f43ac9933802532b28a287e5f45c7854bcc33b0b" translate="yes" xml:space="preserve">
          <source>Normally, this function inserts newline characters into the encoded text, to avoid overlong lines. However, if the optional argument &lt;var&gt;no-line-break&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, these newlines are not added, so the result string is just one long line.</source>
          <target state="translated">Normally, this function inserts newline characters into the encoded text, to avoid overlong lines. However, if the optional argument &lt;var&gt;no-line-break&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , these newlines are not added, so the result string is just one long line.</target>
        </trans-unit>
        <trans-unit id="d37dcdec76f9e6b7d0121007f21ec47b7057c83e" translate="yes" xml:space="preserve">
          <source>Normally, this function signals an error if you attempt to delete the sole active terminal, but if &lt;var&gt;force&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, you are allowed to do so. Emacs automatically calls this function when the last frame on a terminal is deleted (see &lt;a href=&quot;deleting-frames#Deleting-Frames&quot;&gt;Deleting Frames&lt;/a&gt;).</source>
          <target state="translated">Normally, this function signals an error if you attempt to delete the sole active terminal, but if &lt;var&gt;force&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , you are allowed to do so. Emacs automatically calls this function when the last frame on a terminal is deleted (see &lt;a href=&quot;deleting-frames#Deleting-Frames&quot;&gt;Deleting Frames&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="6dd336d19d532b36fa2861068df8621fa7546f25" translate="yes" xml:space="preserve">
          <source>Normally, well-designed Lisp programs should not use &lt;code&gt;with-eval-after-load&lt;/code&gt;. If you need to examine and set the variables defined in another library (those meant for outside use), you can do it immediately&amp;mdash;there is no need to wait until the library is loaded. If you need to call functions defined by that library, you should load the library, preferably with &lt;code&gt;require&lt;/code&gt; (see &lt;a href=&quot;named-features#Named-Features&quot;&gt;Named Features&lt;/a&gt;).</source>
          <target state="translated">Normally, well-designed Lisp programs should not use &lt;code&gt;with-eval-after-load&lt;/code&gt; . If you need to examine and set the variables defined in another library (those meant for outside use), you can do it immediately&amp;mdash;there is no need to wait until the library is loaded. If you need to call functions defined by that library, you should load the library, preferably with &lt;code&gt;require&lt;/code&gt; (see &lt;a href=&quot;named-features#Named-Features&quot;&gt;Named Features&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="32213d153ad203f84c268998070d9c91fd7446c2" translate="yes" xml:space="preserve">
          <source>Normally, when &lt;var&gt;tree&lt;/var&gt; is anything other than a cons cell, &lt;code&gt;copy-tree&lt;/code&gt; simply returns &lt;var&gt;tree&lt;/var&gt;. However, if &lt;var&gt;vecp&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it copies vectors too (and operates recursively on their elements).</source>
          <target state="translated">Normally, when &lt;var&gt;tree&lt;/var&gt; is anything other than a cons cell, &lt;code&gt;copy-tree&lt;/code&gt; simply returns &lt;var&gt;tree&lt;/var&gt; . However, if &lt;var&gt;vecp&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , it copies vectors too (and operates recursively on their elements).</target>
        </trans-unit>
        <trans-unit id="a3c03c3e2f02de6a73dd67dd8665632ac3ecb4d6" translate="yes" xml:space="preserve">
          <source>Normally, you specify the Edebug execution mode by typing a command to continue the program in a certain mode. Here is a table of these commands; all except for</source>
          <target state="translated">Normally, you specify the Edebug execution mode by typing a command to continue the program in a certain mode. Here is a table of these commands; all except for</target>
        </trans-unit>
        <trans-unit id="28a2d6a083bc6ad019b2a98e4e29d81c91548221" translate="yes" xml:space="preserve">
          <source>Not all convenient formats are strings. If &lt;var&gt;time&lt;/var&gt; is a number (integer or floating point), that specifies a relative time measured in seconds. The result of &lt;code&gt;encode-time&lt;/code&gt; can also be used to specify an absolute value for &lt;var&gt;time&lt;/var&gt;.</source>
          <target state="translated">Not all convenient formats are strings. If &lt;var&gt;time&lt;/var&gt; is a number (integer or floating point), that specifies a relative time measured in seconds. The result of &lt;code&gt;encode-time&lt;/code&gt; can also be used to specify an absolute value for &lt;var&gt;time&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="cb74d9cca41ce9c386501e0756ab5861fff45519" translate="yes" xml:space="preserve">
          <source>Not all grammars are accepted:</source>
          <target state="translated">Not all grammars are accepted:</target>
        </trans-unit>
        <trans-unit id="99f0e2cc9f83cb30e3ae050f9b9f847c4120fdb6" translate="yes" xml:space="preserve">
          <source>Not every string is a valid regular expression. For example, a string that ends inside a character alternative without a terminating &amp;lsquo;</source>
          <target state="translated">Not every string is a valid regular expression. For example, a string that ends inside a character alternative without a terminating &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="43ff9e862a86dab0a657fc6384f26e1419f49f75" translate="yes" xml:space="preserve">
          <source>Not used by core Emacs features.</source>
          <target state="translated">Not used by core Emacs features.</target>
        </trans-unit>
        <trans-unit id="c7c5413b8718cba59a931876fd41b752eae55f77" translate="yes" xml:space="preserve">
          <source>Notation for describing functions, variables, etc.</source>
          <target state="translated">Notation for describing functions, variables, etc.</target>
        </trans-unit>
        <trans-unit id="4c3b785fe5302404be7fd8ebefe6a435a4164b8b" translate="yes" xml:space="preserve">
          <source>Note also that &lt;code&gt;expand-file-name&lt;/code&gt; does not follow symbolic links at any level. This results in a difference between the way &lt;code&gt;file-truename&lt;/code&gt; and &lt;code&gt;expand-file-name&lt;/code&gt; treat &amp;lsquo;</source>
          <target state="translated">Note also that &lt;code&gt;expand-file-name&lt;/code&gt; does not follow symbolic links at any level. This results in a difference between the way &lt;code&gt;file-truename&lt;/code&gt; and &lt;code&gt;expand-file-name&lt;/code&gt; treat &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="e8c1e3068af42529c71ce3761f404a8c7cb2b54f" translate="yes" xml:space="preserve">
          <source>Note also that the native position of a frame usually remains unaltered on its display when removing or adding the window manager decorations by changing the frame&amp;rsquo;s &lt;code&gt;override-redirect&lt;/code&gt; or &lt;code&gt;undecorated&lt;/code&gt; parameter (see &lt;a href=&quot;management-parameters#Management-Parameters&quot;&gt;Management Parameters&lt;/a&gt;).</source>
          <target state="translated">Note also that the native position of a frame usually remains unaltered on its display when removing or adding the window manager decorations by changing the frame&amp;rsquo;s &lt;code&gt;override-redirect&lt;/code&gt; or &lt;code&gt;undecorated&lt;/code&gt; parameter (see &lt;a href=&quot;management-parameters#Management-Parameters&quot;&gt;Management Parameters&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="e06a1498bcc4e46f5b08f1b485bfe2d29db14c40" translate="yes" xml:space="preserve">
          <source>Note also that this translation is done before the characters are supplied to input methods (see &lt;a href=&quot;input-methods#Input-Methods&quot;&gt;Input Methods&lt;/a&gt;). Use &lt;code&gt;translation-table-for-input&lt;/code&gt; (see &lt;a href=&quot;translation-of-characters#Translation-of-Characters&quot;&gt;Translation of Characters&lt;/a&gt;), if you want to translate characters after input methods operate.</source>
          <target state="translated">Note also that this translation is done before the characters are supplied to input methods (see &lt;a href=&quot;input-methods#Input-Methods&quot;&gt;Input Methods&lt;/a&gt;). Use &lt;code&gt;translation-table-for-input&lt;/code&gt; (see &lt;a href=&quot;translation-of-characters#Translation-of-Characters&quot;&gt;Translation of Characters&lt;/a&gt;), if you want to translate characters after input methods operate.</target>
        </trans-unit>
        <trans-unit id="f37c9faec19e5f322f365ce34f1cd5f26d62fd9b" translate="yes" xml:space="preserve">
          <source>Note also that under certain circumstances &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; and &lt;code&gt;switch-to-next-buffer&lt;/code&gt; may ignore this option, for example, when there is only one buffer left these functions can switch to.</source>
          <target state="translated">Note also that under certain circumstances &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; and &lt;code&gt;switch-to-next-buffer&lt;/code&gt; may ignore this option, for example, when there is only one buffer left these functions can switch to.</target>
        </trans-unit>
        <trans-unit id="e43f096d72c1fa7eda8bb11cbb26469630c96a62" translate="yes" xml:space="preserve">
          <source>Note also that window managers usually do not ask for resizing a frame when they change the number of lines occupied by an external menu or tool bar. Typically, such &amp;ldquo;wrappings&amp;rdquo; occur when a user shrinks a frame horizontally, making it impossible to display all elements of its menu or tool bar. They may also result from a change of the major mode altering the number of items of a menu or tool bar. Any such wrappings may implicitly alter the number of lines of a frame&amp;rsquo;s text area and are unaffected by the setting of this option.</source>
          <target state="translated">Note also that window managers usually do not ask for resizing a frame when they change the number of lines occupied by an external menu or tool bar. Typically, such &amp;ldquo;wrappings&amp;rdquo; occur when a user shrinks a frame horizontally, making it impossible to display all elements of its menu or tool bar. They may also result from a change of the major mode altering the number of items of a menu or tool bar. Any such wrappings may implicitly alter the number of lines of a frame&amp;rsquo;s text area and are unaffected by the setting of this option.</target>
        </trans-unit>
        <trans-unit id="c02c5b53625103bbcd1e981469317bde4d2eff01" translate="yes" xml:space="preserve">
          <source>Note also the function &lt;code&gt;window-largest-empty-rectangle&lt;/code&gt; (see &lt;a href=&quot;coordinates-and-windows#Coordinates-and-Windows&quot;&gt;Coordinates and Windows&lt;/a&gt;) which can be used to inscribe a child frame in the largest empty area of an existing window. This can be useful to avoid that a child frame obscures any text shown in that window.</source>
          <target state="translated">Note also the function &lt;code&gt;window-largest-empty-rectangle&lt;/code&gt; (see &lt;a href=&quot;coordinates-and-windows#Coordinates-and-Windows&quot;&gt;Coordinates and Windows&lt;/a&gt;) which can be used to inscribe a child frame in the largest empty area of an existing window. This can be useful to avoid that a child frame obscures any text shown in that window.</target>
        </trans-unit>
        <trans-unit id="ac296846d6e88621711014648ad3889107526b49" translate="yes" xml:space="preserve">
          <source>Note also, that positions specified relative to the right/bottom edge of a display, workarea or parent frame as well as floating-point offsets are stored internally as integer offsets relative to the left/top edge of the display, workarea or parent frame edge. They are also returned as such by functions like &lt;code&gt;frame-parameters&lt;/code&gt; and restored as such by the desktop saving routines.</source>
          <target state="translated">Note also, that positions specified relative to the right/bottom edge of a display, workarea or parent frame as well as floating-point offsets are stored internally as integer offsets relative to the left/top edge of the display, workarea or parent frame edge. They are also returned as such by functions like &lt;code&gt;frame-parameters&lt;/code&gt; and restored as such by the desktop saving routines.</target>
        </trans-unit>
        <trans-unit id="4ee808f9b4d3b62c6e1c4ae8210950ef2323557e" translate="yes" xml:space="preserve">
          <source>Note also, that the combined action alist may contain duplicate entries and entries for the same key with different values. As a rule, action functions always use the first association of a key they find. Hence, the association an action function uses is not necessarily the association provided by the display action that specified that action function,</source>
          <target state="translated">Note also, that the combined action alist may contain duplicate entries and entries for the same key with different values. As a rule, action functions always use the first association of a key they find. Hence, the association an action function uses is not necessarily the association provided by the display action that specified that action function,</target>
        </trans-unit>
        <trans-unit id="e5cf53f2f379d0df5750245ed5d07f62c700d148" translate="yes" xml:space="preserve">
          <source>Note how both &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; sub-patterns finish in the same way: by trying (always successfully) to match against the &lt;var&gt;symbol&lt;/var&gt; pattern &lt;code&gt;val&lt;/code&gt;, in the process binding &lt;code&gt;val&lt;/code&gt;. Thus, &lt;code&gt;or&lt;/code&gt; always matches and control always passes to the body form (line 9). Because that is the last body form in a successfully matched &lt;code&gt;pcase&lt;/code&gt; clause, it is the value of &lt;code&gt;pcase&lt;/code&gt; and likewise the return value of &lt;code&gt;grok/pcase&lt;/code&gt; (see &lt;a href=&quot;what-is-a-function#What-Is-a-Function&quot;&gt;What Is a Function&lt;/a&gt;).</source>
          <target state="translated">Note how both &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; sub-patterns finish in the same way: by trying (always successfully) to match against the &lt;var&gt;symbol&lt;/var&gt; pattern &lt;code&gt;val&lt;/code&gt; , in the process binding &lt;code&gt;val&lt;/code&gt; . Thus, &lt;code&gt;or&lt;/code&gt; always matches and control always passes to the body form (line 9). Because that is the last body form in a successfully matched &lt;code&gt;pcase&lt;/code&gt; clause, it is the value of &lt;code&gt;pcase&lt;/code&gt; and likewise the return value of &lt;code&gt;grok/pcase&lt;/code&gt; (see &lt;a href=&quot;what-is-a-function#What-Is-a-Function&quot;&gt;What Is a Function&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="da5b870679158a8dc429765e73588de68e861a6b" translate="yes" xml:space="preserve">
          <source>Note that &amp;lsquo;</source>
          <target state="translated">'</target>
        </trans-unit>
        <trans-unit id="5a8aa4751bb1c982814a77bf1d580dce6aad70e9" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;(car foo)&lt;/code&gt; is not executed if &lt;code&gt;(consp foo)&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt;, thus avoiding an error.</source>
          <target state="translated">Note that &lt;code&gt;(car foo)&lt;/code&gt; is not executed if &lt;code&gt;(consp foo)&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt; , thus avoiding an error.</target>
        </trans-unit>
        <trans-unit id="82cc38abe8d3c167aceee216d425c0ab550d1382" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;(delq 'c sample-list)&lt;/code&gt; modifies &lt;code&gt;sample-list&lt;/code&gt; to splice out the third element, but &lt;code&gt;(delq 'a sample-list)&lt;/code&gt; does not splice anything&amp;mdash;it just returns a shorter list. Don&amp;rsquo;t assume that a variable which formerly held the argument &lt;var&gt;list&lt;/var&gt; now has fewer elements, or that it still holds the original list! Instead, save the result of &lt;code&gt;delq&lt;/code&gt; and use that. Most often we store the result back into the variable that held the original list:</source>
          <target state="translated">Note that &lt;code&gt;(delq 'c sample-list)&lt;/code&gt; modifies &lt;code&gt;sample-list&lt;/code&gt; to splice out the third element, but &lt;code&gt;(delq 'a sample-list)&lt;/code&gt; does not splice anything&amp;mdash;it just returns a shorter list. Don&amp;rsquo;t assume that a variable which formerly held the argument &lt;var&gt;list&lt;/var&gt; now has fewer elements, or that it still holds the original list! Instead, save the result of &lt;code&gt;delq&lt;/code&gt; and use that. Most often we store the result back into the variable that held the original list:</target>
        </trans-unit>
        <trans-unit id="88ce8d10722b09594fee9067ec46be961db1010b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;ad-activate&lt;/code&gt; had a global effect: it activated all pieces of advice enabled for that specified function. If you wanted to only activate or deactivate a particular piece, you needed to &lt;em&gt;enable&lt;/em&gt; or &lt;em&gt;disable&lt;/em&gt; it with &lt;code&gt;ad-enable-advice&lt;/code&gt; and &lt;code&gt;ad-disable-advice&lt;/code&gt;. The new mechanism does away with this distinction.</source>
          <target state="translated">Note that &lt;code&gt;ad-activate&lt;/code&gt; had a global effect: it activated all pieces of advice enabled for that specified function. If you wanted to only activate or deactivate a particular piece, you needed to &lt;em&gt;enable&lt;/em&gt; or &lt;em&gt;disable&lt;/em&gt; it with &lt;code&gt;ad-enable-advice&lt;/code&gt; and &lt;code&gt;ad-disable-advice&lt;/code&gt; . The new mechanism does away with this distinction.</target>
        </trans-unit>
        <trans-unit id="a8b9b0264afaff2247ccc31f5609c567f52bbb12" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;display-buffer-reuse-window&lt;/code&gt; appears redundant in the customization of &lt;code&gt;display-buffer-base-action&lt;/code&gt; because it is already part of &lt;code&gt;display-buffer-fallback-action&lt;/code&gt; and should be tried there anyway. However, that would fail because due to the precedence of &lt;code&gt;display-buffer-base-action&lt;/code&gt; over &lt;code&gt;display-buffer-fallback-action&lt;/code&gt;, at that time &lt;code&gt;display-buffer-pop-up-frame&lt;/code&gt; would have already won the race. In fact, this:</source>
          <target state="translated">Note that &lt;code&gt;display-buffer-reuse-window&lt;/code&gt; appears redundant in the customization of &lt;code&gt;display-buffer-base-action&lt;/code&gt; because it is already part of &lt;code&gt;display-buffer-fallback-action&lt;/code&gt; and should be tried there anyway. However, that would fail because due to the precedence of &lt;code&gt;display-buffer-base-action&lt;/code&gt; over &lt;code&gt;display-buffer-fallback-action&lt;/code&gt; , at that time &lt;code&gt;display-buffer-pop-up-frame&lt;/code&gt; would have already won the race. In fact, this:</target>
        </trans-unit>
        <trans-unit id="420700b2d9abe3e5aa5c3ba405713ee29ec392d5" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;eval-expression-debug-on-error&lt;/code&gt; overrides this variable in some cases; see below.</source>
          <target state="translated">Note that &lt;code&gt;eval-expression-debug-on-error&lt;/code&gt; overrides this variable in some cases; see below.</target>
        </trans-unit>
        <trans-unit id="bcbdaf4d50a8c86ab39d55059a3ac469c00b587e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;expand-file-name&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; expand environment variables; only &lt;code&gt;substitute-in-file-name&lt;/code&gt; does that:</source>
          <target state="translated">Note that &lt;code&gt;expand-file-name&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; expand environment variables; only &lt;code&gt;substitute-in-file-name&lt;/code&gt; does that:</target>
        </trans-unit>
        <trans-unit id="ab80ac2f4a9d468cbc4712bf3ee278edec445477" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;let&lt;/code&gt; bindings are treated specially by the Emacs Lisp implementation. There is no way to duplicate this unwinding and rewinding behavior other than by using &lt;code&gt;let&lt;/code&gt;. For example, a manual implementation of &lt;code&gt;let&lt;/code&gt; written using &lt;code&gt;unwind-protect&lt;/code&gt; cannot arrange for variable values to be thread-specific.</source>
          <target state="translated">Note that &lt;code&gt;let&lt;/code&gt; bindings are treated specially by the Emacs Lisp implementation. There is no way to duplicate this unwinding and rewinding behavior other than by using &lt;code&gt;let&lt;/code&gt; . For example, a manual implementation of &lt;code&gt;let&lt;/code&gt; written using &lt;code&gt;unwind-protect&lt;/code&gt; cannot arrange for variable values to be thread-specific.</target>
        </trans-unit>
        <trans-unit id="89f00f3fb6940c8e5695af8eb8543d457737771c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;macroexpand&lt;/code&gt; does not look at the subexpressions of &lt;var&gt;form&lt;/var&gt; (although some macro definitions may do so). Even if they are macro calls themselves, &lt;code&gt;macroexpand&lt;/code&gt; does not expand them.</source>
          <target state="translated">Note that &lt;code&gt;macroexpand&lt;/code&gt; does not look at the subexpressions of &lt;var&gt;form&lt;/var&gt; (although some macro definitions may do so). Even if they are macro calls themselves, &lt;code&gt;macroexpand&lt;/code&gt; does not expand them.</target>
        </trans-unit>
        <trans-unit id="d670e88e4393319b698452d1022060ef368672e8" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;nil&lt;/code&gt;, being both a valid alist and a valid plist, represents &lt;code&gt;{}&lt;/code&gt;, the empty JSON object; not &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;, or an empty array, all of which are different JSON values.</source>
          <target state="translated">Note that &lt;code&gt;nil&lt;/code&gt; , being both a valid alist and a valid plist, represents &lt;code&gt;{}&lt;/code&gt; , the empty JSON object; not &lt;code&gt;null&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; , or an empty array, all of which are different JSON values.</target>
        </trans-unit>
        <trans-unit id="9fa6019796c4614fd1ce6adb41579f6d542fd75e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;set-window-hscroll&lt;/code&gt; may appear not to work if you test it by evaluating a call with</source>
          <target state="translated">Note that &lt;code&gt;set-window-hscroll&lt;/code&gt; may appear not to work if you test it by evaluating a call with</target>
        </trans-unit>
        <trans-unit id="2ea6c975bcb32bc398a9332341b86368aab4d1e0" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;sort-columns&lt;/code&gt; rejects text that contains tabs, because tabs could be split across the specified columns. Use</source>
          <target state="translated">Note that &lt;code&gt;sort-columns&lt;/code&gt; rejects text that contains tabs, because tabs could be split across the specified columns. Use</target>
        </trans-unit>
        <trans-unit id="e14386726913a3c2fd59bf734e821066eca6e0b8" translate="yes" xml:space="preserve">
          <source>Note that &lt;var&gt;condition&lt;/var&gt; will only be evaluated when redisplay examines the text where this display spec is located, so this feature is best suited for conditions that are relatively stable, i.e. yield, for each particular buffer position, the same results on every evaluation. If the results change for the same text location, e.g., if the result depends on the position of point, then the conditional specification might not do what you want, because redisplay examines only those parts of buffer text where it has reasons to assume that something changed since the last display cycle.</source>
          <target state="translated">Note that &lt;var&gt;condition&lt;/var&gt; will only be evaluated when redisplay examines the text where this display spec is located, so this feature is best suited for conditions that are relatively stable, i.e. yield, for each particular buffer position, the same results on every evaluation. If the results change for the same text location, e.g., if the result depends on the position of point, then the conditional specification might not do what you want, because redisplay examines only those parts of buffer text where it has reasons to assume that something changed since the last display cycle.</target>
        </trans-unit>
        <trans-unit id="11c86dc7160f3159d0caf4f8ca652e035830aeb9" translate="yes" xml:space="preserve">
          <source>Note that &lt;var&gt;row&lt;/var&gt; is counted from the top of the text area. If the window given by &lt;var&gt;position&lt;/var&gt; possesses a header line (see &lt;a href=&quot;header-lines#Header-Lines&quot;&gt;Header Lines&lt;/a&gt;) or a tab line, they are &lt;em&gt;not&lt;/em&gt; included in the &lt;var&gt;row&lt;/var&gt; count.</source>
          <target state="translated">Note that &lt;var&gt;row&lt;/var&gt; is counted from the top of the text area. If the window given by &lt;var&gt;position&lt;/var&gt; possesses a header line (see &lt;a href=&quot;header-lines#Header-Lines&quot;&gt;Header Lines&lt;/a&gt;) or a tab line, they are &lt;em&gt;not&lt;/em&gt; included in the &lt;var&gt;row&lt;/var&gt; count.</target>
        </trans-unit>
        <trans-unit id="36140c7862902330c0ed8b4c4f62d98557115715" translate="yes" xml:space="preserve">
          <source>Note that C code cannot call functions by name unless they are defined in C. The way to call a function written in Lisp is to use &lt;code&gt;Ffuncall&lt;/code&gt;, which embodies the Lisp function &lt;code&gt;funcall&lt;/code&gt;. Since the Lisp function &lt;code&gt;funcall&lt;/code&gt; accepts an unlimited number of arguments, in C it takes two: the number of Lisp-level arguments, and a one-dimensional array containing their values. The first Lisp-level argument is the Lisp function to call, and the rest are the arguments to pass to it.</source>
          <target state="translated">Note that C code cannot call functions by name unless they are defined in C. The way to call a function written in Lisp is to use &lt;code&gt;Ffuncall&lt;/code&gt; , which embodies the Lisp function &lt;code&gt;funcall&lt;/code&gt; . Since the Lisp function &lt;code&gt;funcall&lt;/code&gt; accepts an unlimited number of arguments, in C it takes two: the number of Lisp-level arguments, and a one-dimensional array containing their values. The first Lisp-level argument is the Lisp function to call, and the rest are the arguments to pass to it.</target>
        </trans-unit>
        <trans-unit id="e556b978b826723508b3c9b15f0f641cf8aad16e" translate="yes" xml:space="preserve">
          <source>Note that Emacs automatically saves and restores the match data while executing filter functions. See &lt;a href=&quot;match-data#Match-Data&quot;&gt;Match Data&lt;/a&gt;.</source>
          <target state="translated">Note that Emacs automatically saves and restores the match data while executing filter functions. See &lt;a href=&quot;match-data#Match-Data&quot;&gt;Match Data&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="849766f54cbb0ac387cb87a85961815edd45103c" translate="yes" xml:space="preserve">
          <source>Note that Emacs automatically saves and restores the match data while executing sentinels. See &lt;a href=&quot;match-data#Match-Data&quot;&gt;Match Data&lt;/a&gt;.</source>
          <target state="translated">Note that Emacs automatically saves and restores the match data while executing sentinels. See &lt;a href=&quot;match-data#Match-Data&quot;&gt;Match Data&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="fd5df05fa87dff11a9d0af24fb74e840bb6e9f14" translate="yes" xml:space="preserve">
          <source>Note that Emacs sometimes uses non-numeric priority values for some of its internal overlays, so do not try to do arithmetic on the priority of an overlay (unless it is one that you created). In particular, the overlay used for showing the region uses a priority value of the form &lt;code&gt;(&lt;var&gt;primary&lt;/var&gt;&amp;nbsp;.&amp;nbsp;&lt;var&gt;secondary&lt;/var&gt;)&lt;/code&gt;, where the &lt;var&gt;primary&lt;/var&gt; value is used as described above, and &lt;var&gt;secondary&lt;/var&gt; is the fallback value used when &lt;var&gt;primary&lt;/var&gt; and the nesting considerations fail to resolve the precedence between overlays. However, you are advised not to design Lisp programs based on this implementation detail; if you need to put overlays in priority order, use the &lt;var&gt;sorted&lt;/var&gt; argument of &lt;code&gt;overlays-at&lt;/code&gt;. See &lt;a href=&quot;finding-overlays#Finding-Overlays&quot;&gt;Finding Overlays&lt;/a&gt;.</source>
          <target state="translated">Note that Emacs sometimes uses non-numeric priority values for some of its internal overlays, so do not try to do arithmetic on the priority of an overlay (unless it is one that you created). In particular, the overlay used for showing the region uses a priority value of the form &lt;code&gt;(&lt;var&gt;primary&lt;/var&gt;&amp;nbsp;.&amp;nbsp;&lt;var&gt;secondary&lt;/var&gt;)&lt;/code&gt; , where the &lt;var&gt;primary&lt;/var&gt; value is used as described above, and &lt;var&gt;secondary&lt;/var&gt; is the fallback value used when &lt;var&gt;primary&lt;/var&gt; and the nesting considerations fail to resolve the precedence between overlays. However, you are advised not to design Lisp programs based on this implementation detail; if you need to put overlays in priority order, use the &lt;var&gt;sorted&lt;/var&gt; argument of &lt;code&gt;overlays-at&lt;/code&gt; . See &lt;a href=&quot;finding-overlays#Finding-Overlays&quot;&gt;Finding Overlays&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="1d3be1a87b3711b91ae65cc80a7d5b435901ca0c" translate="yes" xml:space="preserve">
          <source>Note that Emacs tries to expand macros when loading an uncompiled Lisp file. This is not always possible, but if it is, it speeds up subsequent execution. See &lt;a href=&quot;how-programs-do-loading#How-Programs-Do-Loading&quot;&gt;How Programs Do Loading&lt;/a&gt;.</source>
          <target state="translated">Note that Emacs tries to expand macros when loading an uncompiled Lisp file. This is not always possible, but if it is, it speeds up subsequent execution. See &lt;a href=&quot;how-programs-do-loading#How-Programs-Do-Loading&quot;&gt;How Programs Do Loading&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="0b3adfb09c7f22559fa8fff3314fa3e947a0a9c9" translate="yes" xml:space="preserve">
          <source>Note that a frame cannot be deleted as long as its minibuffer serves as surrogate minibuffer for another frame (see &lt;a href=&quot;minibuffers-and-frames#Minibuffers-and-Frames&quot;&gt;Minibuffers and Frames&lt;/a&gt;). Normally, you cannot delete a frame if all other frames are invisible, but if &lt;var&gt;force&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then you are allowed to do so.</source>
          <target state="translated">Note that a frame cannot be deleted as long as its minibuffer serves as surrogate minibuffer for another frame (see &lt;a href=&quot;minibuffers-and-frames#Minibuffers-and-Frames&quot;&gt;Minibuffers and Frames&lt;/a&gt;). Normally, you cannot delete a frame if all other frames are invisible, but if &lt;var&gt;force&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , then you are allowed to do so.</target>
        </trans-unit>
        <trans-unit id="6c88bb0b96b0659e2468d8c7144a4535dc553f33" translate="yes" xml:space="preserve">
          <source>Note that a sublist specification written as &lt;code&gt;(specs .  nil)&lt;/code&gt; is equivalent to &lt;code&gt;(specs)&lt;/code&gt;, and &lt;code&gt;(specs .
(sublist-elements&amp;hellip;))&lt;/code&gt; is equivalent to &lt;code&gt;(specs
sublist-elements&amp;hellip;)&lt;/code&gt;.</source>
          <target state="translated">Note that a sublist specification written as &lt;code&gt;(specs . nil)&lt;/code&gt; is equivalent to &lt;code&gt;(specs)&lt;/code&gt; , and &lt;code&gt;(specs . (sublist-elements&amp;hellip;))&lt;/code&gt; is equivalent to &lt;code&gt;(specs sublist-elements&amp;hellip;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b700a940d8e3ee969e5d08838da33d645a36c49b" translate="yes" xml:space="preserve">
          <source>Note that a symbol used as a function name may also be used as a variable; these two uses of a symbol are independent and do not conflict. (This is not the case in some dialects of Lisp, like Scheme.)</source>
          <target state="translated">Note that a symbol used as a function name may also be used as a variable; these two uses of a symbol are independent and do not conflict. (This is not the case in some dialects of Lisp, like Scheme.)</target>
        </trans-unit>
        <trans-unit id="0e7d278c76ca3c97b7fc7f52a288a7ed8d2b5fc0" translate="yes" xml:space="preserve">
          <source>Note that all functions described below will respect the adherence of frames (and all other window-system windows) to their respective z-group (see &lt;a href=&quot;position-parameters#Position-Parameters&quot;&gt;Position Parameters&lt;/a&gt;). For example, you usually cannot lower a frame below that of the desktop window and you cannot raise a frame whose &lt;code&gt;z-group&lt;/code&gt; parameter is &lt;code&gt;nil&lt;/code&gt; above the window-system&amp;rsquo;s taskbar or tooltip window.</source>
          <target state="translated">Note that all functions described below will respect the adherence of frames (and all other window-system windows) to their respective z-group (see &lt;a href=&quot;position-parameters#Position-Parameters&quot;&gt;Position Parameters&lt;/a&gt;). For example, you usually cannot lower a frame below that of the desktop window and you cannot raise a frame whose &lt;code&gt;z-group&lt;/code&gt; parameter is &lt;code&gt;nil&lt;/code&gt; above the window-system&amp;rsquo;s taskbar or tooltip window.</target>
        </trans-unit>
        <trans-unit id="1eca8603245bea5b809eedfce8382a27e1e6ac6e" translate="yes" xml:space="preserve">
          <source>Note that among the internal functions listed here, &lt;code&gt;display-buffer--maybe-same-window&lt;/code&gt; is effectively ignored while &lt;code&gt;display-buffer--maybe-pop-up-frame-or-window&lt;/code&gt; actually runs &lt;code&gt;display-buffer-pop-up-window&lt;/code&gt;.</source>
          <target state="translated">Note that among the internal functions listed here, &lt;code&gt;display-buffer--maybe-same-window&lt;/code&gt; is effectively ignored while &lt;code&gt;display-buffer--maybe-pop-up-frame-or-window&lt;/code&gt; actually runs &lt;code&gt;display-buffer-pop-up-window&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d006d7d82c4cf8967401facb8495eb53ce2b548" translate="yes" xml:space="preserve">
          <source>Note that any functions added to these hooks by your initial file are usually not run for the initial frame, since Emacs reads the initial file only after creating that frame. However, if the initial frame is specified to use a separate minibuffer frame (see &lt;a href=&quot;minibuffers-and-frames#Minibuffers-and-Frames&quot;&gt;Minibuffers and Frames&lt;/a&gt;), the functions will be run for both, the minibuffer-less and the minibuffer frame.</source>
          <target state="translated">Note that any functions added to these hooks by your initial file are usually not run for the initial frame, since Emacs reads the initial file only after creating that frame. However, if the initial frame is specified to use a separate minibuffer frame (see &lt;a href=&quot;minibuffers-and-frames#Minibuffers-and-Frames&quot;&gt;Minibuffers and Frames&lt;/a&gt;), the functions will be run for both, the minibuffer-less and the minibuffer frame.</target>
        </trans-unit>
        <trans-unit id="6b08f2421a6c05a0ee00e59222f1df594f4fd0e9" translate="yes" xml:space="preserve">
          <source>Note that any non-&lt;code&gt;nil&lt;/code&gt; symbol might be used as an event or an event type; &lt;code&gt;eventp&lt;/code&gt; cannot distinguish whether a symbol is intended by Lisp code to be used as an event.</source>
          <target state="translated">Note that any non- &lt;code&gt;nil&lt;/code&gt; symbol might be used as an event or an event type; &lt;code&gt;eventp&lt;/code&gt; cannot distinguish whether a symbol is intended by Lisp code to be used as an event.</target>
        </trans-unit>
        <trans-unit id="d1591e27e69961a04460b2fe1820737613f07080" translate="yes" xml:space="preserve">
          <source>Note that case conversion is not a one-to-one mapping of codepoints and length of the result may differ from length of the argument. Furthermore, because passing a character forces return type to be a character, functions are unable to perform proper substitution and result may differ compared to treating a one-character string. For example:</source>
          <target state="translated">Note that case conversion is not a one-to-one mapping of codepoints and length of the result may differ from length of the argument. Furthermore, because passing a character forces return type to be a character, functions are unable to perform proper substitution and result may differ compared to treating a one-character string. For example:</target>
        </trans-unit>
        <trans-unit id="ce70eb5a1727174c7a315b786b751a0ce2e6823e" translate="yes" xml:space="preserve">
          <source>Note that display tables affect how the mode line is displayed, so if you want to force redisplay of the mode line using a new display table, call &lt;code&gt;force-mode-line-update&lt;/code&gt; (see &lt;a href=&quot;mode-line-format#Mode-Line-Format&quot;&gt;Mode Line Format&lt;/a&gt;).</source>
          <target state="translated">Note that display tables affect how the mode line is displayed, so if you want to force redisplay of the mode line using a new display table, call &lt;code&gt;force-mode-line-update&lt;/code&gt; (see &lt;a href=&quot;mode-line-format#Mode-Line-Format&quot;&gt;Mode Line Format&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="3e027fd5d05afab1bae33a36130ab5cf384d7efa" translate="yes" xml:space="preserve">
          <source>Note that elements of &lt;code&gt;minor-mode-map-alist&lt;/code&gt; do not have the same structure as elements of &lt;code&gt;minor-mode-alist&lt;/code&gt;. The map must be the &lt;small&gt;CDR&lt;/small&gt; of the element; a list with the map as the second element will not do. The &lt;small&gt;CDR&lt;/small&gt; can be either a keymap (a list) or a symbol whose function definition is a keymap.</source>
          <target state="translated">Note that elements of &lt;code&gt;minor-mode-map-alist&lt;/code&gt; do not have the same structure as elements of &lt;code&gt;minor-mode-alist&lt;/code&gt; . The map must be the &lt;small&gt;CDR&lt;/small&gt; of the element; a list with the map as the second element will not do. The &lt;small&gt;CDR&lt;/small&gt; can be either a keymap (a list) or a symbol whose function definition is a keymap.</target>
        </trans-unit>
        <trans-unit id="5c6f5e6a17b21c98d8da299e04e71ec5bc5fccaa" translate="yes" xml:space="preserve">
          <source>Note that for &lt;code&gt;nthcdr&lt;/code&gt;, the list argument of the function must itself be a valid &lt;var&gt;place&lt;/var&gt; form. For example, &lt;code&gt;(setf (nthcdr
0 foo) 7)&lt;/code&gt; will set &lt;code&gt;foo&lt;/code&gt; itself to 7.</source>
          <target state="translated">Note that for &lt;code&gt;nthcdr&lt;/code&gt; , the list argument of the function must itself be a valid &lt;var&gt;place&lt;/var&gt; form. For example, &lt;code&gt;(setf (nthcdr 0 foo) 7)&lt;/code&gt; will set &lt;code&gt;foo&lt;/code&gt; itself to 7.</target>
        </trans-unit>
        <trans-unit id="b7031d4a6bb1fd17ff90dc3b21b4c28dae0691db" translate="yes" xml:space="preserve">
          <source>Note that hyphen (&lt;code&gt;-&lt;/code&gt;) is special in strings in this construct, since it acts as a range separator. To include a hyphen, add it as a separate character or single-character string. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">Note that hyphen ( &lt;code&gt;-&lt;/code&gt; ) is special in strings in this construct, since it acts as a range separator. To include a hyphen, add it as a separate character or single-character string. Corresponding string regexp: &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="71a252b7e10406a1efe10d060f22023cc1adeb54" translate="yes" xml:space="preserve">
          <source>Note that if Emacs already has a buffer visiting the same file non-literally, it will not visit the same file literally, but instead just switch to the existing buffer. If you want to be sure of accessing a file&amp;rsquo;s contents literally, you should create a temporary buffer and then read the file contents into it using &lt;code&gt;insert-file-contents-literally&lt;/code&gt; (see &lt;a href=&quot;reading-from-files#Reading-from-Files&quot;&gt;Reading from Files&lt;/a&gt;).</source>
          <target state="translated">Note that if Emacs already has a buffer visiting the same file non-literally, it will not visit the same file literally, but instead just switch to the existing buffer. If you want to be sure of accessing a file&amp;rsquo;s contents literally, you should create a temporary buffer and then read the file contents into it using &lt;code&gt;insert-file-contents-literally&lt;/code&gt; (see &lt;a href=&quot;reading-from-files#Reading-from-Files&quot;&gt;Reading from Files&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="7aabecd82de173080e0d6a40e3c8b6bd5b301744" translate="yes" xml:space="preserve">
          <source>Note that if the string to be displayed in the margin doesn&amp;rsquo;t specify a face, its face is determined using the same rules and priorities as it is for strings displayed in the text area (see &lt;a href=&quot;displaying-faces#Displaying-Faces&quot;&gt;Displaying Faces&lt;/a&gt;). If this results in undesirable &amp;ldquo;leaking&amp;rdquo; of faces into the margin, make sure the string has an explicit face specified for it.</source>
          <target state="translated">Note that if the string to be displayed in the margin doesn&amp;rsquo;t specify a face, its face is determined using the same rules and priorities as it is for strings displayed in the text area (see &lt;a href=&quot;displaying-faces#Displaying-Faces&quot;&gt;Displaying Faces&lt;/a&gt;). If this results in undesirable &amp;ldquo;leaking&amp;rdquo; of faces into the margin, make sure the string has an explicit face specified for it.</target>
        </trans-unit>
        <trans-unit id="d4e506505176e0289fea2ef20ed99c25d90708a5" translate="yes" xml:space="preserve">
          <source>Note that if the text also has a &lt;code&gt;height&lt;/code&gt; display specification, which was specified before (i.e. to the left of) &lt;code&gt;raise&lt;/code&gt;, the latter will affect the amount of raising or lowering in pixels, because that is based on the height of the text being raised. Therefore, if you want to display a sub- or superscript that is smaller than the normal text height, consider specifying &lt;code&gt;raise&lt;/code&gt; before &lt;code&gt;height&lt;/code&gt;.</source>
          <target state="translated">Note that if the text also has a &lt;code&gt;height&lt;/code&gt; display specification, which was specified before (i.e. to the left of) &lt;code&gt;raise&lt;/code&gt; , the latter will affect the amount of raising or lowering in pixels, because that is based on the height of the text being raised. Therefore, if you want to display a sub- or superscript that is smaller than the normal text height, consider specifying &lt;code&gt;raise&lt;/code&gt; before &lt;code&gt;height&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f83321e2dc6362ff6bb142d1319ba7d1841f375" translate="yes" xml:space="preserve">
          <source>Note that image types &lt;code&gt;pbm&lt;/code&gt; and &lt;code&gt;xbm&lt;/code&gt; do not need entries in this variable because they do not depend on external libraries and are always available in Emacs.</source>
          <target state="translated">Note that image types &lt;code&gt;pbm&lt;/code&gt; and &lt;code&gt;xbm&lt;/code&gt; do not need entries in this variable because they do not depend on external libraries and are always available in Emacs.</target>
        </trans-unit>
        <trans-unit id="2b90bd2256efbea7d91a8f1731d6cbc9dc04839d" translate="yes" xml:space="preserve">
          <source>Note that in contrast to &lt;code&gt;or&lt;/code&gt;, both arguments are always evaluated.</source>
          <target state="translated">Note that in contrast to &lt;code&gt;or&lt;/code&gt; , both arguments are always evaluated.</target>
        </trans-unit>
        <trans-unit id="f1d398c647559c7e5536cae0d92bd8598b1b5529" translate="yes" xml:space="preserve">
          <source>Note that in the third example, the function returned</source>
          <target state="translated">Note that in the third example, the function returned</target>
        </trans-unit>
        <trans-unit id="f10b1133c79e4544a6c4fd2a1bf8f43bddfa17d8" translate="yes" xml:space="preserve">
          <source>Note that keymaps and keyboard macros (strings and vectors) are not valid functions, so a symbol with a keymap, string, or vector as its function definition is invalid as a function. It is, however, valid as a key binding. If the definition is a keyboard macro, then the symbol is also valid as an argument to &lt;code&gt;command-execute&lt;/code&gt; (see &lt;a href=&quot;interactive-call#Interactive-Call&quot;&gt;Interactive Call&lt;/a&gt;).</source>
          <target state="translated">Note that keymaps and keyboard macros (strings and vectors) are not valid functions, so a symbol with a keymap, string, or vector as its function definition is invalid as a function. It is, however, valid as a key binding. If the definition is a keyboard macro, then the symbol is also valid as an argument to &lt;code&gt;command-execute&lt;/code&gt; (see &lt;a href=&quot;interactive-call#Interactive-Call&quot;&gt;Interactive Call&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="f7ca497421798c821a09facd3f3452f27743e204" translate="yes" xml:space="preserve">
          <source>Note that negative values do not permit to align the right or bottom edge of &lt;var&gt;frame&lt;/var&gt; exactly at the right or bottom edge of its display or parent frame. Neither do they allow to specify a position that does not lie within the edges of the display or parent frame. The frame parameters &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;top&lt;/code&gt; (see &lt;a href=&quot;position-parameters#Position-Parameters&quot;&gt;Position Parameters&lt;/a&gt;) allow to do that, but may still fail to provide good results for the initial or a new frame.</source>
          <target state="translated">Note that negative values do not permit to align the right or bottom edge of &lt;var&gt;frame&lt;/var&gt; exactly at the right or bottom edge of its display or parent frame. Neither do they allow to specify a position that does not lie within the edges of the display or parent frame. The frame parameters &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;top&lt;/code&gt; (see &lt;a href=&quot;position-parameters#Position-Parameters&quot;&gt;Position Parameters&lt;/a&gt;) allow to do that, but may still fail to provide good results for the initial or a new frame.</target>
        </trans-unit>
        <trans-unit id="6bb86bc06ff9fe96cf961221500aba7002f6114c" translate="yes" xml:space="preserve">
          <source>Note that on multi-monitor displays (see &lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;Multiple Terminals&lt;/a&gt;), the window manager might position the frame differently than specified by the positional parameters in &lt;var&gt;parameters&lt;/var&gt; (see &lt;a href=&quot;position-parameters#Position-Parameters&quot;&gt;Position Parameters&lt;/a&gt;). For example, some window managers have a policy of displaying the frame on the monitor that contains the largest part of the window (a.k.a. the &lt;em&gt;dominating&lt;/em&gt; monitor).</source>
          <target state="translated">Note that on multi-monitor displays (see &lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;Multiple Terminals&lt;/a&gt;), the window manager might position the frame differently than specified by the positional parameters in &lt;var&gt;parameters&lt;/var&gt; (see &lt;a href=&quot;position-parameters#Position-Parameters&quot;&gt;Position Parameters&lt;/a&gt;). For example, some window managers have a policy of displaying the frame on the monitor that contains the largest part of the window (a.k.a. the &lt;em&gt;dominating&lt;/em&gt; monitor).</target>
        </trans-unit>
        <trans-unit id="451dabba0c45d6a9da92c12dfcbef25151b92f65" translate="yes" xml:space="preserve">
          <source>Note that once you have defined a face (usually with &lt;code&gt;defface&lt;/code&gt;), you cannot later undefine this face safely, except by restarting Emacs.</source>
          <target state="translated">Note that once you have defined a face (usually with &lt;code&gt;defface&lt;/code&gt; ), you cannot later undefine this face safely, except by restarting Emacs.</target>
        </trans-unit>
        <trans-unit id="8be3a3df08c2c43245d05ddcd5d07fbab7b209b4" translate="yes" xml:space="preserve">
          <source>Note that property lists are similar to association lists in several respects. A property list behaves like an association list in which each key can occur only once. See &lt;a href=&quot;property-lists#Property-Lists&quot;&gt;Property Lists&lt;/a&gt;, for a comparison of property lists and association lists.</source>
          <target state="translated">Note that property lists are similar to association lists in several respects. A property list behaves like an association list in which each key can occur only once. See &lt;a href=&quot;property-lists#Property-Lists&quot;&gt;Property Lists&lt;/a&gt;, for a comparison of property lists and association lists.</target>
        </trans-unit>
        <trans-unit id="cf01d48b51913f0cf00ab32bac6c884aa95173f2" translate="yes" xml:space="preserve">
          <source>Note that providing such an entry alone does not necessarily make the window as tall as specified by its value. To actually resize an existing window or make a new window as tall as specified by that value, a &lt;code&gt;window-height&lt;/code&gt; entry specifying that value should be provided as well. Such a &lt;code&gt;window-height&lt;/code&gt; entry can, however, specify a completely different value or ask the window height to be fit to that of its buffer in which case the &lt;code&gt;window-min-height&lt;/code&gt; entry provides the guaranteed minimum height of the window used.</source>
          <target state="translated">Note that providing such an entry alone does not necessarily make the window as tall as specified by its value. To actually resize an existing window or make a new window as tall as specified by that value, a &lt;code&gt;window-height&lt;/code&gt; entry specifying that value should be provided as well. Such a &lt;code&gt;window-height&lt;/code&gt; entry can, however, specify a completely different value or ask the window height to be fit to that of its buffer in which case the &lt;code&gt;window-min-height&lt;/code&gt; entry provides the guaranteed minimum height of the window used.</target>
        </trans-unit>
        <trans-unit id="a8d1c86e0cb1777d5c4381401ecb75f9d100b2f8" translate="yes" xml:space="preserve">
          <source>Note that references to &lt;code&gt;foo&lt;/code&gt; in &lt;var&gt;body&lt;/var&gt; access the buffer-local binding of buffer &amp;lsquo;</source>
          <target state="translated">Note that references to &lt;code&gt;foo&lt;/code&gt; in &lt;var&gt;body&lt;/var&gt; access the buffer-local binding of buffer &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="944ce22b3c1e0e4361ff98e0b47922f894f4954d" translate="yes" xml:space="preserve">
          <source>Note that remapping only takes place through active keymaps; for example, putting a remapping in a prefix keymap like &lt;code&gt;ctl-x-map&lt;/code&gt; typically has no effect, as such keymaps are not themselves active. In addition, remapping only works through a single level; in the following example,</source>
          <target state="translated">Note that remapping only takes place through active keymaps; for example, putting a remapping in a prefix keymap like &lt;code&gt;ctl-x-map&lt;/code&gt; typically has no effect, as such keymaps are not themselves active. In addition, remapping only works through a single level; in the following example,</target>
        </trans-unit>
        <trans-unit id="aa44f3362212f49d475dc95b39b81576e77893a3" translate="yes" xml:space="preserve">
          <source>Note that setting this variable to a non-&lt;code&gt;nil&lt;/code&gt; value does not change the fact that auto-saving is different from saving the buffer; e.g., the hooks described in &lt;a href=&quot;saving-buffers#Saving-Buffers&quot;&gt;Saving Buffers&lt;/a&gt; are &lt;em&gt;not&lt;/em&gt; run when a buffer is auto-saved.</source>
          <target state="translated">Note that setting this variable to a non- &lt;code&gt;nil&lt;/code&gt; value does not change the fact that auto-saving is different from saving the buffer; e.g., the hooks described in &lt;a href=&quot;saving-buffers#Saving-Buffers&quot;&gt;Saving Buffers&lt;/a&gt; are &lt;em&gt;not&lt;/em&gt; run when a buffer is auto-saved.</target>
        </trans-unit>
        <trans-unit id="ce4d07d18464ef749e1edb147a33de09d0f7af7e" translate="yes" xml:space="preserve">
          <source>Note that several rings in Emacs, like the kill ring and the mark ring, are actually implemented as simple lists, &lt;em&gt;not&lt;/em&gt; using the &lt;code&gt;ring&lt;/code&gt; package; thus the following functions won&amp;rsquo;t work on them.</source>
          <target state="translated">Note that several rings in Emacs, like the kill ring and the mark ring, are actually implemented as simple lists, &lt;em&gt;not&lt;/em&gt; using the &lt;code&gt;ring&lt;/code&gt; package; thus the following functions won&amp;rsquo;t work on them.</target>
        </trans-unit>
        <trans-unit id="ada2f27c9ba203cc421e71266f32365f19ed4b0f" translate="yes" xml:space="preserve">
          <source>Note that since &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; is called by &lt;code&gt;bury-buffer&lt;/code&gt;, &lt;code&gt;replace-buffer-in-windows&lt;/code&gt; and &lt;code&gt;quit-restore-window&lt;/code&gt; as well, customizing this option may also affect the behavior of Emacs when a window is quit or a buffer gets buried or killed.</source>
          <target state="translated">Note that since &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; is called by &lt;code&gt;bury-buffer&lt;/code&gt; , &lt;code&gt;replace-buffer-in-windows&lt;/code&gt; and &lt;code&gt;quit-restore-window&lt;/code&gt; as well, customizing this option may also affect the behavior of Emacs when a window is quit or a buffer gets buried or killed.</target>
        </trans-unit>
        <trans-unit id="df75894a436d2ac6f25b076d7908978b97f93102" translate="yes" xml:space="preserve">
          <source>Note that since this is a function, it can only return non-&lt;code&gt;nil&lt;/code&gt; for variables which are permanently special, but not for those that are only special in the current lexical scope.</source>
          <target state="translated">Note that since this is a function, it can only return non- &lt;code&gt;nil&lt;/code&gt; for variables which are permanently special, but not for those that are only special in the current lexical scope.</target>
        </trans-unit>
        <trans-unit id="2fac15f40439742424e3aa18f0429ca4f01e2aaf" translate="yes" xml:space="preserve">
          <source>Note that sometimes selecting a window is not enough to show it, or make its frame the top-most frame on display: you may also need to raise the frame or make sure input focus is directed to that frame. See &lt;a href=&quot;input-focus#Input-Focus&quot;&gt;Input Focus&lt;/a&gt;.</source>
          <target state="translated">Note that sometimes selecting a window is not enough to show it, or make its frame the top-most frame on display: you may also need to raise the frame or make sure input focus is directed to that frame. See &lt;a href=&quot;input-focus#Input-Focus&quot;&gt;Input Focus&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="1028e973fd6d45e7d7652a7eded330cbb5470222" translate="yes" xml:space="preserve">
          <source>Note that space properties are treated as paragraph separators for the purposes of reordering bidirectional text for display. See &lt;a href=&quot;bidirectional-display#Bidirectional-Display&quot;&gt;Bidirectional Display&lt;/a&gt;, for the details.</source>
          <target state="translated">Note that space properties are treated as paragraph separators for the purposes of reordering bidirectional text for display. See &lt;a href=&quot;bidirectional-display#Bidirectional-Display&quot;&gt;Bidirectional Display&lt;/a&gt;, for the details.</target>
        </trans-unit>
        <trans-unit id="7cb5ad3eb4a2271a938c9aa7f77ae8d741838eaf" translate="yes" xml:space="preserve">
          <source>Note that specifying a value, even &lt;code&gt;nil&lt;/code&gt;, marks the variable as special permanently. Whereas if &lt;var&gt;value&lt;/var&gt; is omitted then the variable is only marked special locally (i.e. within the current lexical scope, or file if at the top-level). This can be useful for suppressing byte compilation warnings, see &lt;a href=&quot;compiler-errors#Compiler-Errors&quot;&gt;Compiler Errors&lt;/a&gt;.</source>
          <target state="translated">Note that specifying a value, even &lt;code&gt;nil&lt;/code&gt; , marks the variable as special permanently. Whereas if &lt;var&gt;value&lt;/var&gt; is omitted then the variable is only marked special locally (i.e. within the current lexical scope, or file if at the top-level). This can be useful for suppressing byte compilation warnings, see &lt;a href=&quot;compiler-errors#Compiler-Errors&quot;&gt;Compiler Errors&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="d0bceaee80bf44f350b2b336e7bdc4aca04effe6" translate="yes" xml:space="preserve">
          <source>Note that storing a new binding for</source>
          <target state="translated">Note that storing a new binding for</target>
        </trans-unit>
        <trans-unit id="ca0f3720c830567e36124202fdc192dd9c282156" translate="yes" xml:space="preserve">
          <source>Note that storing new values into the &lt;small&gt;CDR&lt;/small&gt;s of cons cells in this list does &lt;em&gt;not&lt;/em&gt; change the buffer-local values of the variables.</source>
          <target state="translated">Note that storing new values into the &lt;small&gt;CDR&lt;/small&gt;s of cons cells in this list does &lt;em&gt;not&lt;/em&gt; change the buffer-local values of the variables.</target>
        </trans-unit>
        <trans-unit id="bcb5445ab75b38c5ccd760396b2859fa80f84f86" translate="yes" xml:space="preserve">
          <source>Note that text in paragraphs whose base direction is right-to-left (see &lt;a href=&quot;bidirectional-display#Bidirectional-Display&quot;&gt;Bidirectional Display&lt;/a&gt;) moves in the opposite direction: e.g., it moves to the right when &lt;code&gt;scroll-left&lt;/code&gt; is invoked with a positive value of &lt;var&gt;count&lt;/var&gt;.</source>
          <target state="translated">Note that text in paragraphs whose base direction is right-to-left (see &lt;a href=&quot;bidirectional-display#Bidirectional-Display&quot;&gt;Bidirectional Display&lt;/a&gt;) moves in the opposite direction: e.g., it moves to the right when &lt;code&gt;scroll-left&lt;/code&gt; is invoked with a positive value of &lt;var&gt;count&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="643a90b7cc572aa8f24a2a4aeec18309319e74d7" translate="yes" xml:space="preserve">
          <source>Note that the</source>
          <target state="translated">참고</target>
        </trans-unit>
        <trans-unit id="e36a773ef709e536a82e2d886a7cd51f572df233" translate="yes" xml:space="preserve">
          <source>Note that the &amp;lsquo;</source>
          <target state="translated">'</target>
        </trans-unit>
        <trans-unit id="a6469f422f7ec9a279d6ed4b82f424847330e523" translate="yes" xml:space="preserve">
          <source>Note that the argument &lt;code&gt;(assq 'handler list)&lt;/code&gt; appears in the expansion.</source>
          <target state="translated">Note that the argument &lt;code&gt;(assq 'handler list)&lt;/code&gt; appears in the expansion.</target>
        </trans-unit>
        <trans-unit id="4368eeb627f6bc57851f8ed6589cb35a499c91b1" translate="yes" xml:space="preserve">
          <source>Note that the arguments can be the results of other function calls, as in this example:</source>
          <target state="translated">Note that the arguments can be the results of other function calls, as in this example:</target>
        </trans-unit>
        <trans-unit id="60b6c61854c649097ce19157cbb7f0ddb8c5eefa" translate="yes" xml:space="preserve">
          <source>Note that the docstrings mention &lt;var&gt;args&lt;/var&gt; (in this case, only one: &lt;code&gt;n&lt;/code&gt;) in the usual way, and also mention &lt;code&gt;EXPVAL&lt;/code&gt; by convention. The first rewrite (i.e., &lt;var&gt;body&lt;/var&gt; for &lt;code&gt;less-than&lt;/code&gt;) uses one core pattern: &lt;code&gt;pred&lt;/code&gt;. The second uses two core patterns: &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;pred&lt;/code&gt;, as well as the newly-defined pattern &lt;code&gt;less-than&lt;/code&gt;. Both use a single backquote construct (see &lt;a href=&quot;backquote#Backquote&quot;&gt;Backquote&lt;/a&gt;).</source>
          <target state="translated">Note that the docstrings mention &lt;var&gt;args&lt;/var&gt; (in this case, only one: &lt;code&gt;n&lt;/code&gt; ) in the usual way, and also mention &lt;code&gt;EXPVAL&lt;/code&gt; by convention. The first rewrite (i.e., &lt;var&gt;body&lt;/var&gt; for &lt;code&gt;less-than&lt;/code&gt; ) uses one core pattern: &lt;code&gt;pred&lt;/code&gt; . The second uses two core patterns: &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;pred&lt;/code&gt; , as well as the newly-defined pattern &lt;code&gt;less-than&lt;/code&gt; . Both use a single backquote construct (see &lt;a href=&quot;backquote#Backquote&quot;&gt;Backquote&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="c2edb0886e867e4ca5989b4ab0140428caf42280" translate="yes" xml:space="preserve">
          <source>Note that the documentation strings for Emacs are not the same thing as the Emacs manual. Manuals have their own source files, written in the Texinfo language; documentation strings are specified in the definitions of the functions and variables they apply to. A collection of documentation strings is not sufficient as a manual because a good manual is not organized in that fashion; it is organized in terms of topics of discussion.</source>
          <target state="translated">Note that the documentation strings for Emacs are not the same thing as the Emacs manual. Manuals have their own source files, written in the Texinfo language; documentation strings are specified in the definitions of the functions and variables they apply to. A collection of documentation strings is not sufficient as a manual because a good manual is not organized in that fashion; it is organized in terms of topics of discussion.</target>
        </trans-unit>
        <trans-unit id="fca742cf8fd5cf459a0d4b4751312094297df69c" translate="yes" xml:space="preserve">
          <source>Note that the effect of restacking will only hold as long as neither of the involved frames is iconified or made invisible. You can use the &lt;code&gt;z-group&lt;/code&gt; (see &lt;a href=&quot;position-parameters#Position-Parameters&quot;&gt;Position Parameters&lt;/a&gt;) frame parameter to add a frame to a group of frames permanently shown above or below other frames. As long as a frame belongs to one of these groups, restacking it will only affect its relative stacking position within that group. The effect of restacking frames belonging to different z-groups is undefined. You can list frames in their current stacking order with the function &lt;code&gt;frame-list-z-order&lt;/code&gt; (see &lt;a href=&quot;finding-all-frames#Finding-All-Frames&quot;&gt;Finding All Frames&lt;/a&gt;).</source>
          <target state="translated">Note that the effect of restacking will only hold as long as neither of the involved frames is iconified or made invisible. You can use the &lt;code&gt;z-group&lt;/code&gt; (see &lt;a href=&quot;position-parameters#Position-Parameters&quot;&gt;Position Parameters&lt;/a&gt;) frame parameter to add a frame to a group of frames permanently shown above or below other frames. As long as a frame belongs to one of these groups, restacking it will only affect its relative stacking position within that group. The effect of restacking frames belonging to different z-groups is undefined. You can list frames in their current stacking order with the function &lt;code&gt;frame-list-z-order&lt;/code&gt; (see &lt;a href=&quot;finding-all-frames#Finding-All-Frames&quot;&gt;Finding All Frames&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="2582678e0a51538e9f647014c2a05c8ea4765da3" translate="yes" xml:space="preserve">
          <source>Note that the first &lt;var&gt;form&lt;/var&gt; is evaluated, then the first &lt;var&gt;symbol&lt;/var&gt; is set, then the second &lt;var&gt;form&lt;/var&gt; is evaluated, then the second &lt;var&gt;symbol&lt;/var&gt; is set, and so on:</source>
          <target state="translated">Note that the first &lt;var&gt;form&lt;/var&gt; is evaluated, then the first &lt;var&gt;symbol&lt;/var&gt; is set, then the second &lt;var&gt;form&lt;/var&gt; is evaluated, then the second &lt;var&gt;symbol&lt;/var&gt; is set, and so on:</target>
        </trans-unit>
        <trans-unit id="9173ba72010925230c9678e4a9c448ec671403eb" translate="yes" xml:space="preserve">
          <source>Note that the first read skips a space. Reading skips any amount of whitespace preceding the significant text.</source>
          <target state="translated">Note that the first read skips a space. Reading skips any amount of whitespace preceding the significant text.</target>
        </trans-unit>
        <trans-unit id="5b4a82bbf9da4eb3b066c08dd5991f582e95b2ff" translate="yes" xml:space="preserve">
          <source>Note that the function specified by this option is called only if the specified frame contains just one live window and there is at least one other frame on the same terminal.</source>
          <target state="translated">Note that the function specified by this option is called only if the specified frame contains just one live window and there is at least one other frame on the same terminal.</target>
        </trans-unit>
        <trans-unit id="43a4f6baecfda8409de3b10f1d269557bab73567" translate="yes" xml:space="preserve">
          <source>Note that the handling of &lt;code&gt;command-switch-alist&lt;/code&gt; doesn&amp;rsquo;t treat equals signs in &lt;var&gt;option&lt;/var&gt; specially. That is, if there&amp;rsquo;s an option like &lt;code&gt;--name=value&lt;/code&gt; on the command line, then only a &lt;code&gt;command-switch-alist&lt;/code&gt; member whose &lt;code&gt;car&lt;/code&gt; is literally &lt;code&gt;--name=value&lt;/code&gt; will match this option. If you want to parse such options, you need to use &lt;code&gt;command-line-functions&lt;/code&gt; instead (see below).</source>
          <target state="translated">Note that the handling of &lt;code&gt;command-switch-alist&lt;/code&gt; doesn&amp;rsquo;t treat equals signs in &lt;var&gt;option&lt;/var&gt; specially. That is, if there&amp;rsquo;s an option like &lt;code&gt;--name=value&lt;/code&gt; on the command line, then only a &lt;code&gt;command-switch-alist&lt;/code&gt; member whose &lt;code&gt;car&lt;/code&gt; is literally &lt;code&gt;--name=value&lt;/code&gt; will match this option. If you want to parse such options, you need to use &lt;code&gt;command-line-functions&lt;/code&gt; instead (see below).</target>
        </trans-unit>
        <trans-unit id="10d410d8d2209e47d081d1091cbeb510cad74888" translate="yes" xml:space="preserve">
          <source>Note that the meaning of &lt;code&gt;nil&lt;/code&gt; differs slightly from that of the &lt;var&gt;all-frames&lt;/var&gt; argument to &lt;code&gt;next-window&lt;/code&gt; (see &lt;a href=&quot;cyclic-window-ordering#Cyclic-Window-Ordering&quot;&gt;Cyclic Window Ordering&lt;/a&gt;).</source>
          <target state="translated">Note that the meaning of &lt;code&gt;nil&lt;/code&gt; differs slightly from that of the &lt;var&gt;all-frames&lt;/var&gt; argument to &lt;code&gt;next-window&lt;/code&gt; (see &lt;a href=&quot;cyclic-window-ordering#Cyclic-Window-Ordering&quot;&gt;Cyclic Window Ordering&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="46305bb5f2b4deb49120db52fdc405524ee1ca0b" translate="yes" xml:space="preserve">
          <source>Note that the minibuffer window used by a frame need not be part of that frame&amp;mdash;a frame that has no minibuffer of its own necessarily uses some other frame&amp;rsquo;s minibuffer window. The minibuffer window of a minibuffer-less frame can be changed by setting that frame&amp;rsquo;s &lt;code&gt;minibuffer&lt;/code&gt; frame parameter (see &lt;a href=&quot;buffer-parameters#Buffer-Parameters&quot;&gt;Buffer Parameters&lt;/a&gt;).</source>
          <target state="translated">Note that the minibuffer window used by a frame need not be part of that frame&amp;mdash;a frame that has no minibuffer of its own necessarily uses some other frame&amp;rsquo;s minibuffer window. The minibuffer window of a minibuffer-less frame can be changed by setting that frame&amp;rsquo;s &lt;code&gt;minibuffer&lt;/code&gt; frame parameter (see &lt;a href=&quot;buffer-parameters#Buffer-Parameters&quot;&gt;Buffer Parameters&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="29787cca83afbad5cb5731b6b829bddd7a5a6e3f" translate="yes" xml:space="preserve">
          <source>Note that the open and close parentheses remain in the list. The Lisp reader encountered the open parenthesis, decided that it ended the input, and unread it. Another attempt to read from the stream at this point would read &amp;lsquo;</source>
          <target state="translated">Note that the open and close parentheses remain in the list. The Lisp reader encountered the open parenthesis, decided that it ended the input, and unread it. Another attempt to read from the stream at this point would read &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="59f13de0f3c2b965927d50d1e0831d83e4c0b4e3" translate="yes" xml:space="preserve">
          <source>Note that the option &lt;code&gt;fit-window-to-buffer-horizontally&lt;/code&gt; must have a non-&lt;code&gt;nil&lt;/code&gt; value in order to allow horizontal adjustment of windows. Entries are also added that ask for preserving the height of side windows at the top and bottom of the frame and the width of side windows at the left or right of the frame. To assure that side windows retain their respective sizes when maximizing the frame, the variable &lt;code&gt;window-resize-pixelwise&lt;/code&gt; is set to a non-&lt;code&gt;nil&lt;/code&gt; value. See &lt;a href=&quot;resizing-windows#Resizing-Windows&quot;&gt;Resizing Windows&lt;/a&gt;.</source>
          <target state="translated">Note that the option &lt;code&gt;fit-window-to-buffer-horizontally&lt;/code&gt; must have a non- &lt;code&gt;nil&lt;/code&gt; value in order to allow horizontal adjustment of windows. Entries are also added that ask for preserving the height of side windows at the top and bottom of the frame and the width of side windows at the left or right of the frame. To assure that side windows retain their respective sizes when maximizing the frame, the variable &lt;code&gt;window-resize-pixelwise&lt;/code&gt; is set to a non- &lt;code&gt;nil&lt;/code&gt; value. See &lt;a href=&quot;resizing-windows#Resizing-Windows&quot;&gt;Resizing Windows&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="9a70f1cf74ad105152fa3a136ffd4bd441d193a1" translate="yes" xml:space="preserve">
          <source>Note that the second argument is always the list of &lt;em&gt;all&lt;/em&gt; action alist entries specified by the sources named above. Hence, the first element of that list is the first action alist entry specified by &lt;code&gt;display-buffer-overriding-action&lt;/code&gt;, if any. Its last element is the last alist entry of &lt;code&gt;display-buffer-base-action&lt;/code&gt;, if any (the action alist of &lt;code&gt;display-buffer-fallback-action&lt;/code&gt; is empty).</source>
          <target state="translated">Note that the second argument is always the list of &lt;em&gt;all&lt;/em&gt; action alist entries specified by the sources named above. Hence, the first element of that list is the first action alist entry specified by &lt;code&gt;display-buffer-overriding-action&lt;/code&gt; , if any. Its last element is the last alist entry of &lt;code&gt;display-buffer-base-action&lt;/code&gt; , if any (the action alist of &lt;code&gt;display-buffer-fallback-action&lt;/code&gt; is empty).</target>
        </trans-unit>
        <trans-unit id="074011f5871b6c0968cba6e5251ad570a7913126" translate="yes" xml:space="preserve">
          <source>Note that the term &amp;ldquo;command&amp;rdquo;, in this context, refers to an interactively callable function (or function-like object), or a keyboard macro. It does not refer to the key sequence used to invoke a command (see &lt;a href=&quot;keymaps#Keymaps&quot;&gt;Keymaps&lt;/a&gt;).</source>
          <target state="translated">Note that the term &amp;ldquo;command&amp;rdquo;, in this context, refers to an interactively callable function (or function-like object), or a keyboard macro. It does not refer to the key sequence used to invoke a command (see &lt;a href=&quot;keymaps#Keymaps&quot;&gt;Keymaps&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="2b48ed316676b2a77757a76ff8c81c0c3beb1931" translate="yes" xml:space="preserve">
          <source>Note that the time returned by this function excludes the time Emacs was not using the processor, and if the Emacs process has several threads, the returned value is the sum of the processor times used up by all Emacs threads.</source>
          <target state="translated">Note that the time returned by this function excludes the time Emacs was not using the processor, and if the Emacs process has several threads, the returned value is the sum of the processor times used up by all Emacs threads.</target>
        </trans-unit>
        <trans-unit id="87ffd6d39e1afd8a7828b54719c1a46abb2defc0" translate="yes" xml:space="preserve">
          <source>Note that the user-level incremental search feature handles case distinctions differently. When the search string contains only lower case letters, the search ignores case, but when the search string contains one or more upper case letters, the search becomes case-sensitive. But this has nothing to do with the searching functions used in Lisp code. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Incremental-Search.html#Incremental-Search&quot;&gt;Incremental Search&lt;/a&gt; in</source>
          <target state="translated">Note that the user-level incremental search feature handles case distinctions differently. When the search string contains only lower case letters, the search ignores case, but when the search string contains one or more upper case letters, the search becomes case-sensitive. But this has nothing to do with the searching functions used in Lisp code. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Incremental-Search.html#Incremental-Search&quot;&gt;Incremental Search&lt;/a&gt; in</target>
        </trans-unit>
        <trans-unit id="aa30ecc6a9801e96a10f51cc845ae8140b1365d1" translate="yes" xml:space="preserve">
          <source>Note that the user-level incremental search feature handles case distinctions differently. When the search string contains only lower case letters, the search ignores case, but when the search string contains one or more upper case letters, the search becomes case-sensitive. But this has nothing to do with the searching functions used in Lisp code. See &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/Incremental-Search.html#Incremental-Search&quot;&gt;Incremental Search&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f06cef1accb1f0afe0d8f8b378512094228d0996" translate="yes" xml:space="preserve">
          <source>Note that the value of the &lt;code&gt;window-atom&lt;/code&gt; parameter does not really matter as long as it is non-&lt;code&gt;nil&lt;/code&gt;. The values assigned by &lt;code&gt;display-buffer-in-atom-window&lt;/code&gt; just allow for easy retrieval of the original and the new window after that function has been applied. Note also that the &lt;code&gt;window-atom&lt;/code&gt; parameter is the only window parameter assigned by &lt;code&gt;display-buffer-in-atom-window&lt;/code&gt;. Further parameters have to be set by the application explicitly via a &lt;code&gt;window-parameters&lt;/code&gt; entry in &lt;var&gt;alist&lt;/var&gt;.</source>
          <target state="translated">Note that the value of the &lt;code&gt;window-atom&lt;/code&gt; parameter does not really matter as long as it is non- &lt;code&gt;nil&lt;/code&gt; . The values assigned by &lt;code&gt;display-buffer-in-atom-window&lt;/code&gt; just allow for easy retrieval of the original and the new window after that function has been applied. Note also that the &lt;code&gt;window-atom&lt;/code&gt; parameter is the only window parameter assigned by &lt;code&gt;display-buffer-in-atom-window&lt;/code&gt; . Further parameters have to be set by the application explicitly via a &lt;code&gt;window-parameters&lt;/code&gt; entry in &lt;var&gt;alist&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="3fb6d667bc03880b5ccfb18ddea5d35e1c03ca93" translate="yes" xml:space="preserve">
          <source>Note that the value of this variable is ignored when &lt;code&gt;make-process&lt;/code&gt; is called with a non-&lt;code&gt;nil&lt;/code&gt; value of the &lt;code&gt;:stderr&lt;/code&gt; parameter; in that case, Emacs will communicate with the process using pipes. It is also ignored if ptys are unavailable (MS-Windows).</source>
          <target state="translated">Note that the value of this variable is ignored when &lt;code&gt;make-process&lt;/code&gt; is called with a non- &lt;code&gt;nil&lt;/code&gt; value of the &lt;code&gt;:stderr&lt;/code&gt; parameter; in that case, Emacs will communicate with the process using pipes. It is also ignored if ptys are unavailable (MS-Windows).</target>
        </trans-unit>
        <trans-unit id="4a97b13e6f37fae9d240fea05dd6e0d29f53c80f" translate="yes" xml:space="preserve">
          <source>Note that the values of the above two variables take effect at display time, so let-binding them around code which produces echo-area messages will not work. If you want to prevent resizing of minibuffer windows when displaying long messages, bind the &lt;code&gt;message-truncate-lines&lt;/code&gt; variable instead (see &lt;a href=&quot;echo-area-customization#Echo-Area-Customization&quot;&gt;Echo Area Customization&lt;/a&gt;).</source>
          <target state="translated">Note that the values of the above two variables take effect at display time, so let-binding them around code which produces echo-area messages will not work. If you want to prevent resizing of minibuffer windows when displaying long messages, bind the &lt;code&gt;message-truncate-lines&lt;/code&gt; variable instead (see &lt;a href=&quot;echo-area-customization#Echo-Area-Customization&quot;&gt;Echo Area Customization&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="cc4faf74f63a3bd8358aed546107967e25cd284b" translate="yes" xml:space="preserve">
          <source>Note that there is no conflict between the variable named &lt;code&gt;list&lt;/code&gt; used in this example and the function named &lt;code&gt;list&lt;/code&gt; described below; any symbol can serve both purposes.</source>
          <target state="translated">Note that there is no conflict between the variable named &lt;code&gt;list&lt;/code&gt; used in this example and the function named &lt;code&gt;list&lt;/code&gt; described below; any symbol can serve both purposes.</target>
        </trans-unit>
        <trans-unit id="f915f57254052f46a7173c363fa3e8ad81bbb90f" translate="yes" xml:space="preserve">
          <source>Note that these are the actual outer edges of the window, including any header line, mode line, scroll bar, fringes, window divider and display margins. On a text terminal, if the window has a neighbor on its right, its right edge includes the separator line between the window and its neighbor.</source>
          <target state="translated">Note that these are the actual outer edges of the window, including any header line, mode line, scroll bar, fringes, window divider and display margins. On a text terminal, if the window has a neighbor on its right, its right edge includes the separator line between the window and its neighbor.</target>
        </trans-unit>
        <trans-unit id="3e29252ca0099b32f668a2f0acad91a2370dc400" translate="yes" xml:space="preserve">
          <source>Note that these meanings differ slightly from those of the &lt;var&gt;all-frames&lt;/var&gt; argument to &lt;code&gt;next-window&lt;/code&gt; (see &lt;a href=&quot;cyclic-window-ordering#Cyclic-Window-Ordering&quot;&gt;Cyclic Window Ordering&lt;/a&gt;). This function may be changed in a future version of Emacs to eliminate this discrepancy.</source>
          <target state="translated">Note that these meanings differ slightly from those of the &lt;var&gt;all-frames&lt;/var&gt; argument to &lt;code&gt;next-window&lt;/code&gt; (see &lt;a href=&quot;cyclic-window-ordering#Cyclic-Window-Ordering&quot;&gt;Cyclic Window Ordering&lt;/a&gt;). This function may be changed in a future version of Emacs to eliminate this discrepancy.</target>
        </trans-unit>
        <trans-unit id="aeecc111a3fa90e2f602220a93eb501df7032c35" translate="yes" xml:space="preserve">
          <source>Note that these two map variables do affect the execution of key sequences entered using the menu bar, even if they do not affect the menu bar display. So if a menu bar key sequence comes in, you should clear the variables before looking up and executing that key sequence. Modes that use the variables would typically do this anyway; normally they respond to events that they do not handle by &amp;ldquo;unreading&amp;rdquo; them and exiting.</source>
          <target state="translated">Note that these two map variables do affect the execution of key sequences entered using the menu bar, even if they do not affect the menu bar display. So if a menu bar key sequence comes in, you should clear the variables before looking up and executing that key sequence. Modes that use the variables would typically do this anyway; normally they respond to events that they do not handle by &amp;ldquo;unreading&amp;rdquo; them and exiting.</target>
        </trans-unit>
        <trans-unit id="e346e2d0ff56f6335dc3e655ea9c25b7e0e40014" translate="yes" xml:space="preserve">
          <source>Note that this argument does not have the same meaning as in other functions which scan all live windows (see &lt;a href=&quot;cyclic-window-ordering#Cyclic-Window-Ordering&quot;&gt;Cyclic Window Ordering&lt;/a&gt;). Specifically, the meanings of &lt;code&gt;t&lt;/code&gt; and &lt;code&gt;nil&lt;/code&gt; here are the opposite of what they are in those other functions.</source>
          <target state="translated">Note that this argument does not have the same meaning as in other functions which scan all live windows (see &lt;a href=&quot;cyclic-window-ordering#Cyclic-Window-Ordering&quot;&gt;Cyclic Window Ordering&lt;/a&gt;). Specifically, the meanings of &lt;code&gt;t&lt;/code&gt; and &lt;code&gt;nil&lt;/code&gt; here are the opposite of what they are in those other functions.</target>
        </trans-unit>
        <trans-unit id="894d286209e758f0c8e4e2de8dc595b49367a3dd" translate="yes" xml:space="preserve">
          <source>Note that this does not tell you whether the display you are using really supports that color. When using X, you can ask for any defined color on any kind of display, and you will get some result&amp;mdash;typically, the closest it can do. To determine whether a frame can really display a certain color, use &lt;code&gt;color-supported-p&lt;/code&gt; (see below).</source>
          <target state="translated">이것은 사용중인 디스플레이가 실제로 해당 색상을 지원하는지 여부를 알려주지 않습니다. X를 사용할 때 모든 종류의 디스플레이에서 정의 된 색상을 요청할 수 있으며 일반적으로 가능한 가장 가까운 결과를 얻을 수 있습니다. 프레임이 실제로 특정 색상을 표시 할 수 있는지 확인하려면 &lt;code&gt;color-supported-p&lt;/code&gt; 를 사용 하십시오 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="9c87143dafdf2015bda6be19171c454f6308b5a5" translate="yes" xml:space="preserve">
          <source>Note that this function disregards the minibuffer window (see &lt;a href=&quot;minibuffer-windows#Minibuffer-Windows&quot;&gt;Minibuffer Windows&lt;/a&gt;). Hence, with &lt;var&gt;side&lt;/var&gt; equal to &lt;code&gt;bottom&lt;/code&gt; it may return &lt;code&gt;t&lt;/code&gt; also when the minibuffer window appears right below &lt;var&gt;window&lt;/var&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;minibuffer-windows#Minibuffer-Windows&quot;&gt;미니 버퍼&lt;/a&gt; 창을 무시합니다 ( 미니 버퍼 창 참조 ). 따라서 &lt;var&gt;side&lt;/var&gt; 가 &lt;code&gt;bottom&lt;/code&gt; 과 같으면 minibuffer 창이 window 바로 아래에 나타날 때도 &lt;code&gt;t&lt;/code&gt; 를 반환 할 수 &lt;var&gt;window&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="3c74267c9a9889a0868c5053a41c16d0ecce8ab6" translate="yes" xml:space="preserve">
          <source>Note that this function doesn&amp;rsquo;t account for the visual width of characters on display, like the number of visual columns taken by a tab character or an image. If you need the coordinates in canonical character units, use &lt;code&gt;posn-col-row&lt;/code&gt; instead.</source>
          <target state="translated">이 함수는 탭 문자 나 이미지에서 가져온 시각적 열 수와 같이 표시되는 문자의 시각적 너비를 고려하지 않습니다. 표준 문자 단위의 좌표가 필요한 경우 대신 &lt;code&gt;posn-col-row&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="998f1206a8bc180e46c0f799b8b5a670212afaad" translate="yes" xml:space="preserve">
          <source>Note that this function has an ambiguity if the found element is identical to &lt;var&gt;default&lt;/var&gt;, as in that case it cannot be known whether an element was found or not.</source>
          <target state="translated">이 함수는 발견 된 요소가 &lt;var&gt;default&lt;/var&gt; 와 동일한 경우 모호성이 있습니다.이 경우 요소가 발견되었는지 여부를 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6df96098672080fc58058b91a33fcbca6a21515b" translate="yes" xml:space="preserve">
          <source>Note that this function has to retrieve the dimensions of each line of &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s glyph matrix via &lt;code&gt;window-lines-pixel-dimensions&lt;/code&gt; (see &lt;a href=&quot;size-of-displayed-text#Size-of-Displayed-Text&quot;&gt;Size of Displayed Text&lt;/a&gt;). Hence, this function may also return &lt;code&gt;nil&lt;/code&gt; when the current glyph matrix of &lt;var&gt;window&lt;/var&gt; is not up-to-date.</source>
          <target state="translated">이 함수는 각각의 라인의 크기를 검색하는 것을 유의 &lt;var&gt;window&lt;/var&gt; 의 그래프를 통해 매트릭스 &lt;code&gt;window-lines-pixel-dimensions&lt;/code&gt; (참조 &lt;a href=&quot;size-of-displayed-text#Size-of-Displayed-Text&quot;&gt;표시된 텍스트의 크기&lt;/a&gt; ). 따라서이 함수는 &lt;var&gt;window&lt;/var&gt; 의 현재 글리프 행렬이 최신 이 아닌 경우 &lt;code&gt;nil&lt;/code&gt; 을 반환 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5054dbcacc1045ce838f26e3713bfdb492fb165" translate="yes" xml:space="preserve">
          <source>Note that this function might return inaccurate results in some situations, such as the following:</source>
          <target state="translated">이 함수는 다음과 같은 일부 상황에서 부정확 한 결과를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28e1bb3bf31dd9667c950f330d082131ff2cc74a" translate="yes" xml:space="preserve">
          <source>Note that this function only changes the buffer contents; it does not alter &lt;code&gt;tabulated-list-entries&lt;/code&gt;.</source>
          <target state="translated">이 함수는 버퍼 내용 만 변경합니다. &lt;code&gt;tabulated-list-entries&lt;/code&gt; 는 변경하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6f915802707d0be2b41295f510d267fae8df11a6" translate="yes" xml:space="preserve">
          <source>Note that this function returns only IPv4 information.</source>
          <target state="translated">이 함수는 IPv4 정보 만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="20b5e54b67d99f5fc2e693cae10cc92ff59c28aa" translate="yes" xml:space="preserve">
          <source>Note that this incorporates the submenu keymap, which is the value of the variable &lt;code&gt;menu-bar-replace-menu&lt;/code&gt;, rather than the symbol &lt;code&gt;menu-bar-replace-menu&lt;/code&gt; itself. Using that symbol in the parent menu item would be meaningless because &lt;code&gt;menu-bar-replace-menu&lt;/code&gt; is not a command.</source>
          <target state="translated">여기 에는 기호 &lt;code&gt;menu-bar-replace-menu&lt;/code&gt; 자체가 아니라 변수 &lt;code&gt;menu-bar-replace-menu&lt;/code&gt; 의 값인 하위 메뉴 키맵이 포함되어 있습니다. &lt;code&gt;menu-bar-replace-menu&lt;/code&gt; 가 명령이 아니기 때문에 부모 메뉴 항목에서 해당 기호를 사용하는 것은 의미 가 없습니다.</target>
        </trans-unit>
        <trans-unit id="aa1d2cd987fde9747e5aba9be8d033f0786b741e" translate="yes" xml:space="preserve">
          <source>Note that this option does not distinguish &amp;ldquo;sloppy&amp;rdquo; focus (where the frame that previously had focus retains focus as long as the mouse pointer does not move into another window manager window) from &amp;ldquo;strict&amp;rdquo; focus (where a frame immediately loses focus when it&amp;rsquo;s left by the mouse pointer). Neither does it recognize whether your window manager supports delayed focusing or auto-raising where you can explicitly specify the time until a new frame gets focus or is auto-raised.</source>
          <target state="translated">이 옵션은 &quot;느슨한&quot;초점 (마우스 포인터가 다른 창 관리자 창으로 이동하지 않는 한 이전에 초점이 있던 프레임이 초점을 유지하는 경우)과 &quot;엄격한&quot;초점 (프레임이 초점을 잃을 때 즉시 초점을 잃는 경우)을 구별하지 않습니다. 마우스 포인터로 왼쪽). 창 관리자가 지연된 초점을 지원하는지 또는 새 프레임이 초점을 맞추거나 자동으로 올라갈 때까지 시간을 명시 적으로 지정할 수있는 자동 올리기를 지원하는지 여부도 인식하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a7ad66f5d269e6734f06cb2f3c0014bbfb55b77d" translate="yes" xml:space="preserve">
          <source>Note that this translation is the first thing that happens to a character after it is read from the terminal. Record-keeping features such as &lt;code&gt;recent-keys&lt;/code&gt; and dribble files record the characters after translation.</source>
          <target state="translated">이 번역은 터미널에서 읽은 후 문자에 가장 먼저 발생하는 것입니다. &lt;code&gt;recent-keys&lt;/code&gt; 및 드리블 파일과 같은 기록 보관 기능은 번역 후 문자를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="8b01ecccbe829efd57fc886cd453e999a2cf9884" translate="yes" xml:space="preserve">
          <source>Note that this variable applies only to events that really come from the keyboard, and has no effect on mouse events or any other events.</source>
          <target state="translated">이 변수는 실제로 키보드에서 발생하는 이벤트에만 적용되며 마우스 이벤트 나 기타 이벤트에는 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="879e8333c0e4e7f970d5416ebcdb0f1f832c6b93" translate="yes" xml:space="preserve">
          <source>Note that unlike &lt;code&gt;reverse&lt;/code&gt;, this function doesn&amp;rsquo;t work with strings. Although you can alter string data by using &lt;code&gt;aset&lt;/code&gt;, it is strongly encouraged to treat strings as immutable even when they are mutable. See &lt;a href=&quot;mutability#Mutability&quot;&gt;Mutability&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;reverse&lt;/code&gt; 와 달리이 함수는 문자열에서 작동하지 않습니다. &lt;code&gt;aset&lt;/code&gt; 을 사용하여 문자열 데이터를 변경할 수 있지만 문자열 이 변경 가능하더라도 변경 불가능한 문자열로 처리하는 것이 좋습니다. &lt;a href=&quot;mutability#Mutability&quot;&gt;Mutability를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="95e0f840e124ea1d4b479e3c1de97bffda6d36fe" translate="yes" xml:space="preserve">
          <source>Note that unlike dynamic variables which are tied to the symbol object itself, the relationship between lexical variables and symbols is only present in the interpreter (or compiler). Therefore, functions which take a symbol argument (like &lt;code&gt;symbol-value&lt;/code&gt;, &lt;code&gt;boundp&lt;/code&gt;, and &lt;code&gt;set&lt;/code&gt;) can only retrieve or modify a variable&amp;rsquo;s dynamic binding (i.e., the contents of its symbol&amp;rsquo;s value cell).</source>
          <target state="translated">심볼 객체 자체에 연결된 동적 변수와 달리 어휘 변수와 심볼 간의 관계는 인터프리터 (또는 컴파일러)에만 존재합니다. 따라서 기호 인수 (예 : &lt;code&gt;symbol-value&lt;/code&gt; , &lt;code&gt;boundp&lt;/code&gt; 및 &lt;code&gt;set&lt;/code&gt; )를받는 함수는 변수의 동적 바인딩 (즉, 기호 값 셀의 내용) 만 검색하거나 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b42ea23442a5852b3e3945f946840be547f84efc" translate="yes" xml:space="preserve">
          <source>Note that using &lt;code&gt;mode-line&lt;/code&gt;, &lt;code&gt;mode-line-inactive&lt;/code&gt;, or &lt;code&gt;header-line&lt;/code&gt; as &lt;var&gt;face&lt;/var&gt; will actually redisplay the mode line or the header line, respectively, using the current definitions of the corresponding face, in addition to returning the formatted string. (Other faces do not cause redisplay.)</source>
          <target state="translated">사용하여 참고 &lt;code&gt;mode-line&lt;/code&gt; , &lt;code&gt;mode-line-inactive&lt;/code&gt; 또는 &lt;code&gt;header-line&lt;/code&gt; 등 &lt;var&gt;face&lt;/var&gt; 실제로 형식 문자열을 반환 이외에 대응면의 현재의 정의를 이용하여, 각각 상기 모드 선 또는 헤더 라인을 다시 표시한다. (다른 얼굴은 다시 표시되지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="da7485093f3e51570042141c7d27e976a6d49566" translate="yes" xml:space="preserve">
          <source>Note that versions of Windows before W2K support only &lt;code&gt;:icon&lt;/code&gt; and &lt;code&gt;:tip&lt;/code&gt;. The other parameters can be passed, but they will be ignored on those old systems.</source>
          <target state="translated">W2K 이전의 Windows 버전은 &lt;code&gt;:icon&lt;/code&gt; 및 &lt;code&gt;:tip&lt;/code&gt; 만 지원합니다 . 다른 매개 변수는 전달할 수 있지만 이전 시스템에서는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="32213ce9630018bd32281e740807f4edfc3f4d49" translate="yes" xml:space="preserve">
          <source>Note that void is not the same as &lt;code&gt;nil&lt;/code&gt; or the symbol &lt;code&gt;void&lt;/code&gt;. The symbols &lt;code&gt;nil&lt;/code&gt; and &lt;code&gt;void&lt;/code&gt; are Lisp objects, and can be stored into a function cell just as any other object can be (and they can be valid functions if you define them in turn with &lt;code&gt;defun&lt;/code&gt;). A void function cell contains no object whatsoever.</source>
          <target state="translated">void는 &lt;code&gt;nil&lt;/code&gt; 또는 &lt;code&gt;void&lt;/code&gt; 기호 와 동일하지 않습니다 . &lt;code&gt;nil&lt;/code&gt; 및 &lt;code&gt;void&lt;/code&gt; 기호 는 Lisp 객체이며 다른 객체와 마찬가지로 함수 셀에 저장할 수 있습니다 ( &lt;code&gt;defun&lt;/code&gt; 으로 차례로 정의하면 유효한 함수가 될 수 있음 ). void 함수 셀에는 객체가 전혀 포함되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c55ed2cdfec3c287af375d8415ca35326ee5ad2a" translate="yes" xml:space="preserve">
          <source>Note that we didn&amp;rsquo;t care to specify a &lt;code&gt;reusable-frames&lt;/code&gt; action alist entry in our specification of &lt;code&gt;display-buffer-alist&lt;/code&gt;. &lt;code&gt;display-buffer&lt;/code&gt; always takes the first one it finds&amp;mdash;in our case the one specified by &lt;code&gt;display-buffer-base-action&lt;/code&gt;. If we wanted to use a different specification, for example, to exclude iconified frames showing</source>
          <target state="translated">&lt;code&gt;display-buffer-alist&lt;/code&gt; 사양에서 &lt;code&gt;reusable-frames&lt;/code&gt; 작업 목록 항목 을 지정하는 데는 신경 쓰지 않았습니다 . &lt;code&gt;display-buffer&lt;/code&gt; 는 항상 가장 먼저 찾은 것을 가져옵니다. 우리의 경우에는 &lt;code&gt;display-buffer-base-action&lt;/code&gt; 에 의해 지정된 것 입니다. 예를 들어 다른 사양을 사용하려는 경우</target>
        </trans-unit>
        <trans-unit id="695d219c90e242ce9ab38b41dd5442dca50f0c95" translate="yes" xml:space="preserve">
          <source>Note that we do not quote the &lt;code&gt;lambda&lt;/code&gt; form.</source>
          <target state="translated">&lt;code&gt;lambda&lt;/code&gt; 형식을 인용하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="27279efa933392e2845851f38f8ebb1579dfb1cb" translate="yes" xml:space="preserve">
          <source>Note that we never modify the data in each node, which is fixed when the ewoc is created to be either &lt;code&gt;nil&lt;/code&gt; or an index into the vector &lt;code&gt;colorcomp-data&lt;/code&gt;, the actual color components.</source>
          <target state="translated">우리는 각 노드의 데이터를 절대 수정하지 않습니다. ewoc가 실제 색 구성 요소 인 벡터 &lt;code&gt;colorcomp-data&lt;/code&gt; 에 대한 &lt;code&gt;nil&lt;/code&gt; 또는 인덱스로 생성 될 때 수정됩니다 .</target>
        </trans-unit>
        <trans-unit id="e11f9f08db090622f4787f9d406b1aa205d88060" translate="yes" xml:space="preserve">
          <source>Note that when a frame is not large enough to accommodate a change of any of the parameters listed above, Emacs may try to enlarge the frame even if this option is non-&lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">프레임이 위에 나열된 매개 변수의 변경을 수용 할만큼 충분히 크지 않은 경우 Emacs는이 옵션이 &lt;code&gt;nil&lt;/code&gt; 이 아니더라도 프레임을 확대하려고 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="93e5de1e980991d9fdbf3fb24041ced46918aafe" translate="yes" xml:space="preserve">
          <source>Note that when a frame&amp;rsquo;s pixel size is not a multiple of its character size, at least one window may get resized pixelwise even if this option is &lt;code&gt;nil&lt;/code&gt;. The default value is &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">프레임의 픽셀 크기가 문자 크기의 배수가 아닌 경우이 옵션이 &lt;code&gt;nil&lt;/code&gt; 인 경우에도 하나 이상의 창 크기가 픽셀 단위로 조정될 수 있습니다 . 기본값은 &lt;code&gt;nil&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0488512718b2693ed44b51fbae789514d6f0a966" translate="yes" xml:space="preserve">
          <source>Note that when evaluating under lexical binding the result is a closure object (see &lt;a href=&quot;closures#Closures&quot;&gt;Closures&lt;/a&gt;).</source>
          <target state="translated">어휘 바인딩에서 평가할 때 결과는 클로저 객체입니다 ( &lt;a href=&quot;closures#Closures&quot;&gt;클로저&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="2b2dcc95bd27b61f320e52671bde8d565c5541e0" translate="yes" xml:space="preserve">
          <source>Note that window change functions provide no information about which windows have been deleted since the last time they were run. If necessary, applications should remember any window showing a specific buffer in a local variable of that buffer and update it in a function run by the default values of any of the hooks that are run when a window buffer change was detected.</source>
          <target state="translated">창 변경 기능은 마지막으로 실행 된 이후 삭제 된 창에 대한 정보를 제공하지 않습니다. 필요한 경우 응용 프로그램은 해당 버퍼의 로컬 변수에 특정 버퍼를 표시하는 모든 창을 기억하고 창 버퍼 변경이 감지되었을 때 실행되는 후크의 기본값으로 실행되는 함수에서 업데이트해야합니다.</target>
        </trans-unit>
        <trans-unit id="b1db01bbe0bf3270ff266bbfef6dae125e24f80a" translate="yes" xml:space="preserve">
          <source>Note that with multiple monitors, the origin of the display does not necessarily coincide with the top-left corner of the entire usable display area of the terminal. Hence the absolute position of a frame can be negative in such an environment even when that frame is completely visible.</source>
          <target state="translated">여러 대의 모니터를 사용하는 경우 디스플레이의 원점이 터미널의 전체 사용 가능한 디스플레이 영역의 왼쪽 상단 모서리와 반드시 일치하지는 않습니다. 따라서 프레임이 완전히 보이는 경우에도 프레임의 절대 위치는 이러한 환경에서 음수가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c81d4cca0834a0ff81c0a8aba5344f507503f4ac" translate="yes" xml:space="preserve">
          <source>Note that you cannot specify a hash table whose initial contents include objects that have no read syntax, such as buffers and frames. Such objects may be added to the hash table after it is created.</source>
          <target state="translated">초기 내용에 버퍼 및 프레임과 같은 읽기 구문이없는 개체가 포함 된 해시 테이블은 지정할 수 없습니다. 이러한 개체는 생성 된 후 해시 테이블에 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df97661ee2013a21758ac0f65cab67196b09b407" translate="yes" xml:space="preserve">
          <source>Note that you could implement an equivalent test by using &lt;code&gt;intern&lt;/code&gt; to get an &lt;code&gt;emacs_value&lt;/code&gt; representing &lt;code&gt;nil&lt;/code&gt;, then use &lt;code&gt;eq&lt;/code&gt;, described above, to test for equality. But using this function is more convenient.</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; 을 나타내는 &lt;code&gt;emacs_value&lt;/code&gt; 를 얻기 위해 &lt;code&gt;intern&lt;/code&gt; 을 사용하여 동등한 테스트를 구현 한 다음 위에서 설명한 &lt;code&gt;eq&lt;/code&gt; 를 사용 하여 동등성을 테스트 할 수 있습니다. 그러나이 기능을 사용하는 것이 더 편리합니다.</target>
        </trans-unit>
        <trans-unit id="8085c903afbf6def946357e85a074fc45d960104" translate="yes" xml:space="preserve">
          <source>Note that you may reenter the same Edebug level several times if, for example, an instrumented function is called several times from one command.</source>
          <target state="translated">예를 들어 계측 된 함수가 하나의 명령에서 여러 번 호출되는 경우 동일한 Edebug 수준을 여러 번 다시 입력 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9728aac91e0d5d7d3233a093047d1e3cf2f7b5fb" translate="yes" xml:space="preserve">
          <source>Note that, unlike in message-based OO languages, such as C</source>
          <target state="translated">C와 같은 메시지 기반 OO 언어와 달리</target>
        </trans-unit>
        <trans-unit id="906465653e9352a3acf19ee4e06fa8005cc8906b" translate="yes" xml:space="preserve">
          <source>Note the call to &lt;code&gt;maybe_quit&lt;/code&gt; inside the loop: this function checks whether the user pressed</source>
          <target state="translated">루프 내에서 &lt;code&gt;maybe_quit&lt;/code&gt; 호출에 유의하십시오 .이 함수는 사용자가 눌렀는지 여부를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="18449a6bba4a3bf6dccfca75e5c0114afa84bfeb" translate="yes" xml:space="preserve">
          <source>Note the symbols which the bindings are made for; these appear inside square brackets, in the key sequence being defined. In some cases, this symbol is the same as the command name; sometimes it is different. These symbols are treated as function keys, but they are not real function keys on the keyboard. They do not affect the functioning of the menu itself, but they are echoed in the echo area when the user selects from the menu, and they appear in the output of &lt;code&gt;where-is&lt;/code&gt; and &lt;code&gt;apropos&lt;/code&gt;.</source>
          <target state="translated">바인딩이 만들어진 기호에 유의하십시오. 정의되는 키 시퀀스에서 대괄호 안에 표시됩니다. 어떤 경우에는이 기호가 명령 이름과 동일합니다. 때로는 다릅니다. 이러한 기호는 기능 키로 취급되지만 키보드의 실제 기능 키는 아닙니다. 메뉴 자체의 기능에는 영향을주지 않지만 사용자가 메뉴에서 선택할 때 에코 영역에 에코되고 &lt;code&gt;where-is&lt;/code&gt; 및 &lt;code&gt;apropos&lt;/code&gt; 의 출력에 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="090bff393075f6b58e2d0efa3893f085f97dd09d" translate="yes" xml:space="preserve">
          <source>Note: If the replacement is a string, it will be placed in a temporary buffer so that &lt;code&gt;replace-buffer-contents&lt;/code&gt; can operate on it. Therefore, if you already have the replacement in a buffer, it makes no sense to convert it to a string using &lt;code&gt;buffer-substring&lt;/code&gt; or similar.</source>
          <target state="translated">참고 : 교체가 문자열 인 경우 &lt;code&gt;replace-buffer-contents&lt;/code&gt; 이 작동 할 수 있도록 임시 버퍼에 배치됩니다 . 따라서 버퍼에 이미 대체가있는 경우 &lt;code&gt;buffer-substring&lt;/code&gt; 등을 사용하여 문자열로 변환하는 것은 의미가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="15b8243f03b0e985c78ff44d43c977a16ec664d5" translate="yes" xml:space="preserve">
          <source>Note: The interactive spec of &lt;var&gt;function&lt;/var&gt; will apply to the combined function and should hence obey the calling convention of the combined function rather than that of &lt;var&gt;function&lt;/var&gt;. In many cases, it makes no difference since they are identical, but it does matter for &lt;code&gt;:around&lt;/code&gt;, &lt;code&gt;:filter-args&lt;/code&gt;, and &lt;code&gt;:filter-return&lt;/code&gt;, where &lt;var&gt;function&lt;/var&gt; receives different arguments than the original function stored in &lt;var&gt;place&lt;/var&gt;.</source>
          <target state="translated">참고 :의 상호 작용 스펙 &lt;var&gt;function&lt;/var&gt; 결합 된 기능에 적용되며, 따라서 그보다는 결합 된 함수의 호출 규칙을 준수해야한다 &lt;var&gt;function&lt;/var&gt; . 대부분의 경우 동일하기 때문에 차이가 없지만 &lt;code&gt;:around&lt;/code&gt; , &lt;code&gt;:filter-args&lt;/code&gt; 및 &lt;code&gt;:filter-return&lt;/code&gt; 에 대해 중요합니다 . 여기서 &lt;var&gt;function&lt;/var&gt; 은 &lt;var&gt;place&lt;/var&gt; 에 저장된 원래 함수와 다른 인수를받습니다 .</target>
        </trans-unit>
        <trans-unit id="086829d75bac2c9e339b5bb59f87867c9bac04d0" translate="yes" xml:space="preserve">
          <source>Note: face remapping is non-recursive. If &lt;var&gt;remapping&lt;/var&gt; references the same face name &lt;var&gt;face&lt;/var&gt;, either directly or via the &lt;code&gt;:inherit&lt;/code&gt; attribute of some other face in &lt;var&gt;remapping&lt;/var&gt;, that reference uses the normal definition of &lt;var&gt;face&lt;/var&gt;. For instance, if the &lt;code&gt;mode-line&lt;/code&gt; face is remapped using this entry in &lt;code&gt;face-remapping-alist&lt;/code&gt;:</source>
          <target state="translated">참고 : 얼굴 다시 매핑은 비재 귀적입니다. 하면 &lt;var&gt;remapping&lt;/var&gt; 참조를 동일면 이름 &lt;var&gt;face&lt;/var&gt; 직접 또는 비아 중, &lt;code&gt;:inherit&lt;/code&gt; 의 다른면의 속성 &lt;var&gt;remapping&lt;/var&gt; , 그 기준은 정상적인 사용 정의 &lt;var&gt;face&lt;/var&gt; . 예를 들어, &lt;code&gt;face-remapping-alist&lt;/code&gt; 에서이 항목을 사용하여 &lt;code&gt;mode-line&lt;/code&gt; 얼굴이 다시 매핑되는 경우 :</target>
        </trans-unit>
        <trans-unit id="48c1f7cc7802f63e35b4a25aa793c719285304f9" translate="yes" xml:space="preserve">
          <source>Note: the properties &lt;code&gt;composition&lt;/code&gt;, &lt;code&gt;display&lt;/code&gt;, &lt;code&gt;invisible&lt;/code&gt; and &lt;code&gt;intangible&lt;/code&gt; can also cause point to move to an acceptable place, after each Emacs command. See &lt;a href=&quot;adjusting-point#Adjusting-Point&quot;&gt;Adjusting Point&lt;/a&gt;.</source>
          <target state="translated">참고 : 각 Emacs 명령 이후에 &lt;code&gt;composition&lt;/code&gt; , &lt;code&gt;display&lt;/code&gt; , &lt;code&gt;invisible&lt;/code&gt; 및 &lt;code&gt;intangible&lt;/code&gt; 의 속성으로 인해 포인트가 허용 가능한 위치로 이동할 수 있습니다. &lt;a href=&quot;adjusting-point#Adjusting-Point&quot;&gt;포인트 조정을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e6cd208317b8407557bf5e9e8a5213d6396ae797" translate="yes" xml:space="preserve">
          <source>Notice how those lexers return the empty string when in front of parentheses. This is because SMIE automatically takes care of the parentheses defined in the syntax table. More specifically if the lexer returns &lt;code&gt;nil&lt;/code&gt; or an empty string, SMIE tries to handle the corresponding text as a sexp according to syntax tables.</source>
          <target state="translated">이러한 렉서가 괄호 앞에있을 때 어떻게 빈 문자열을 반환하는지 주목하십시오. 이는 SMIE가 구문 테이블에 정의 된 괄호를 자동으로 처리하기 때문입니다. 보다 구체적으로 어휘 분석기가 &lt;code&gt;nil&lt;/code&gt; 또는 빈 문자열을 반환 하면 SMIE는 구문 테이블에 따라 해당 텍스트를 sexp로 처리하려고합니다.</target>
        </trans-unit>
        <trans-unit id="1e7899e05f54c7cf4e3b193d5da99af8fc028b7c" translate="yes" xml:space="preserve">
          <source>Notice that all functions are allowed to overwrite the match data unless they&amp;rsquo;re explicitly documented not to do so. A consequence is that functions that are run implicitly in the background (see &lt;a href=&quot;timers#Timers&quot;&gt;Timers&lt;/a&gt;, and &lt;a href=&quot;idle-timers#Idle-Timers&quot;&gt;Idle Timers&lt;/a&gt;) should likely save and restore the match data explicitly.</source>
          <target state="translated">명시 적으로 문서화되지 않은 한 모든 함수는 일치 데이터를 덮어 쓸 수 있습니다. 결과적으로 백그라운드에서 암시 적으로 실행되는 함수 ( &lt;a href=&quot;timers#Timers&quot;&gt;Timers&lt;/a&gt; 및 &lt;a href=&quot;idle-timers#Idle-Timers&quot;&gt;Idle Timers 참조&lt;/a&gt; )는 일치 데이터를 명시 적으로 저장하고 복원해야합니다.</target>
        </trans-unit>
        <trans-unit id="7bf3df555a929d338861ed3b64bf8199a25afe42" translate="yes" xml:space="preserve">
          <source>Notification severity level, one of &lt;code&gt;info&lt;/code&gt;, &lt;code&gt;warning&lt;/code&gt;, or &lt;code&gt;error&lt;/code&gt;. If given, the value determines the icon displayed to the left of the notification title, but only if the &lt;code&gt;:title&lt;/code&gt; parameter (see below) is also specified and is a string.</source>
          <target state="translated">알림 심각도 수준, &lt;code&gt;info&lt;/code&gt; , &lt;code&gt;warning&lt;/code&gt; 또는 &lt;code&gt;error&lt;/code&gt; 중 하나입니다 . 주어진 경우 값은 알림 제목의 왼쪽에 표시되는 아이콘을 결정하지만 &lt;code&gt;:title&lt;/code&gt; 매개 변수 (아래 참조)도 지정되고 문자열 인 경우에만 해당됩니다 .</target>
        </trans-unit>
        <trans-unit id="864d97d356a80a5cd27ad60eb5336174f9507562" translate="yes" xml:space="preserve">
          <source>Notifications on File Changes</source>
          <target state="translated">파일 변경에 대한 알림</target>
        </trans-unit>
        <trans-unit id="e3768fb5cf0372c526b5e173f1befdd62061f9c9" translate="yes" xml:space="preserve">
          <source>Notify &lt;var&gt;cond&lt;/var&gt;. The mutex with &lt;var&gt;cond&lt;/var&gt; must be held before calling this. Ordinarily a single waiting thread is woken by &lt;code&gt;condition-notify&lt;/code&gt;; but if &lt;var&gt;all&lt;/var&gt; is not &lt;code&gt;nil&lt;/code&gt;, then all threads waiting on &lt;var&gt;cond&lt;/var&gt; are notified.</source>
          <target state="translated">&lt;var&gt;cond&lt;/var&gt; 에게 알립니다 . 이것을 호출하기 전에 &lt;var&gt;cond&lt;/var&gt; 가있는 뮤텍스를 보유해야합니다. 일반적으로 단일 대기 스레드는 &lt;code&gt;condition-notify&lt;/code&gt; 에 의해 깨어납니다 . 그러나 &lt;var&gt;all&lt;/var&gt; 이 &lt;code&gt;nil&lt;/code&gt; 이 아니면 &lt;var&gt;cond&lt;/var&gt; 대기중인 모든 스레드에 알림이 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="f36fcd20d98f1c2ef6f745daf470b6fc6dd07587" translate="yes" xml:space="preserve">
          <source>Novice Emacs Lisp programmers often try to use the mark for the wrong purposes. The mark saves a location for the user&amp;rsquo;s convenience. An editing command should not alter the mark unless altering the mark is part of the user-level functionality of the command. (And, in that case, this effect should be documented.) To remember a location for internal use in the Lisp program, store it in a Lisp variable. For example:</source>
          <target state="translated">초보자 Emacs Lisp 프로그래머는 종종 잘못된 목적으로 마크를 사용하려고합니다. 마크는 사용자의 편의를 위해 위치를 저장합니다. 마크 변경이 명령의 사용자 수준 기능의 일부가 아닌 한 편집 명령은 마크를 변경해서는 안됩니다. (그리고이 경우이 효과는 문서화되어야합니다.) Lisp 프로그램에서 내부적으로 사용할 위치를 기억하려면 Lisp 변수에 저장하십시오. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="93fe86956bd461c4f9006b03bcbecd888324bf7d" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s change the argument given to &lt;code&gt;catch2&lt;/code&gt;:</source>
          <target state="translated">이제 &lt;code&gt;catch2&lt;/code&gt; 에 주어진 인수를 변경해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="7551c107ba5514ae35edf328fbdb7f4e01b52801" translate="yes" xml:space="preserve">
          <source>Now that &lt;code&gt;app&lt;/code&gt; has matched, all &lt;code&gt;and&lt;/code&gt; sub-patterns have matched, and so &lt;code&gt;and&lt;/code&gt; matches. Likewise, once &lt;code&gt;and&lt;/code&gt; has matched, &lt;code&gt;or&lt;/code&gt; matches and does not proceed to try sub-pattern &lt;code&gt;let&lt;/code&gt; (line 8).</source>
          <target state="translated">이제 &lt;code&gt;app&lt;/code&gt; 일치했다, 모든 &lt;code&gt;and&lt;/code&gt; 하위 패턴이 일치하는, 그래서 한 &lt;code&gt;and&lt;/code&gt; 일치. 이와 마찬가지로, 한 번 &lt;code&gt;and&lt;/code&gt; 일치하고있다, &lt;code&gt;or&lt;/code&gt; 일치 서브 패턴 시도를 진행하지 않습니다 &lt;code&gt;let&lt;/code&gt; (행 8).</target>
        </trans-unit>
        <trans-unit id="8bf81c47d3466cac8f8f1e05225e708ff47181f9" translate="yes" xml:space="preserve">
          <source>Now we can put the output in the proper order by reversing the list:</source>
          <target state="translated">이제 목록을 반대로하여 출력을 올바른 순서로 배치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d2c4f3b6b617ec480f6e2553990ecdaa4eb658c" translate="yes" xml:space="preserve">
          <source>Now we create a hard link, by calling &lt;code&gt;add-name-to-file&lt;/code&gt;, then list the files again. This shows two names for one file,</source>
          <target state="translated">이제 &lt;code&gt;add-name-to-file&lt;/code&gt; 을 호출하여 하드 링크를 만든 다음 파일을 다시 나열합니다. 이것은 하나의 파일에 대해 두 개의 이름을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="07f78a209cc321ded7c29827738886e3593f46f8" translate="yes" xml:space="preserve">
          <source>Now we read using the stream thus constructed:</source>
          <target state="translated">이제 이렇게 구성된 스트림을 사용하여 읽습니다.</target>
        </trans-unit>
        <trans-unit id="429cf392dcfad2eb5b3fb43671b8d50dc62f2be6" translate="yes" xml:space="preserve">
          <source>Now we show a use of a marker as an output stream. Initially, the marker is in buffer &lt;code&gt;foo&lt;/code&gt;, between the &amp;lsquo;</source>
          <target state="translated">이제 마커를 출력 스트림으로 사용하는 방법을 보여줍니다. 처음에, 마커가 버퍼에 &lt;code&gt;foo&lt;/code&gt; 는 '사이</target>
        </trans-unit>
        <trans-unit id="6fb2e1a0ad356df5d65425e68c286f81f8d8b450" translate="yes" xml:space="preserve">
          <source>Now you can go to the beginning of the defun and type</source>
          <target state="translated">이제 defun의 시작 부분으로 이동하여</target>
        </trans-unit>
        <trans-unit id="e23718dfb830dd77b88fcfc0d1b3bea6a5e6fca3" translate="yes" xml:space="preserve">
          <source>Now, when enlarging a window vertically, Emacs tries to obtain the corresponding space from its lower sibling, provided such a window exists. In our scenario, enlarging &lt;var&gt;W4&lt;/var&gt; will steal space from &lt;var&gt;W3&lt;/var&gt;.</source>
          <target state="translated">이제 창을 수직으로 확대 할 때 Emacs는 해당 창이 존재하는 경우 하위 형제로부터 해당 공간을 얻으려고합니다. 우리의 시나리오에서 &lt;var&gt;W4&lt;/var&gt; 를 확대 하면 &lt;var&gt;W3&lt;/var&gt; 에서 공간을 훔칩니다 .</target>
        </trans-unit>
        <trans-unit id="9e06af5545a3e4354b7d4ee0852c0eed7a91cb67" translate="yes" xml:space="preserve">
          <source>Number of seconds to pause when a breakpoint is reached and the execution mode is trace or continue. See &lt;a href=&quot;edebug-execution-modes#Edebug-Execution-Modes&quot;&gt;Edebug Execution Modes&lt;/a&gt;.</source>
          <target state="translated">중단 점에 도달하고 실행 모드가 추적 또는 계속 일 때 일시 중지하는 시간 (초)입니다. &lt;a href=&quot;edebug-execution-modes#Edebug-Execution-Modes&quot;&gt;Edebug 실행 모드를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="322456515cb687e293b524d7ce7beddddcb9bc80" translate="yes" xml:space="preserve">
          <source>Number of spaces</source>
          <target state="translated">공간 수</target>
        </trans-unit>
        <trans-unit id="7e53821f70ae16079c4a6a64c52a91fae645bc5f" translate="yes" xml:space="preserve">
          <source>Numbers</source>
          <target state="translated">Numbers</target>
        </trans-unit>
        <trans-unit id="7e3c0a7716da4e48fa5db56b8609023d7442bc77" translate="yes" xml:space="preserve">
          <source>Numbers and arithmetic functions.</source>
          <target state="translated">숫자와 산술 함수.</target>
        </trans-unit>
        <trans-unit id="f004d111f9eecf4e07d15edb9e80b8c6a0bb7fb8" translate="yes" xml:space="preserve">
          <source>Numbers controlling how to compose characters.</source>
          <target state="translated">문자를 구성하는 방법을 제어하는 ​​숫자.</target>
        </trans-unit>
        <trans-unit id="4632fc07fc740627ec8979b8ae726d58ce6441a0" translate="yes" xml:space="preserve">
          <source>Numbers with fractional parts and with a large range.</source>
          <target state="translated">분수 부분이 있고 범위가 넓은 숫자.</target>
        </trans-unit>
        <trans-unit id="238f75d73961cd8ec3a93e41f8eca572c815790b" translate="yes" xml:space="preserve">
          <source>Numbers without fractional parts.</source>
          <target state="translated">소수 부분이없는 숫자.</target>
        </trans-unit>
        <trans-unit id="30a62380404b3b267a5c4e21b5e111455d09031e" translate="yes" xml:space="preserve">
          <source>Numeric</source>
          <target state="translated">Numeric</target>
        </trans-unit>
        <trans-unit id="f72c4497b8297399ea538316ed693eb0b0f69dbb" translate="yes" xml:space="preserve">
          <source>Numeric Conversions</source>
          <target state="translated">숫자 변환</target>
        </trans-unit>
        <trans-unit id="08a914cde05039694ef0194d9ee79ff9a79dde33" translate="yes" xml:space="preserve">
          <source>O</source>
          <target state="translated">O</target>
        </trans-unit>
        <trans-unit id="a7947cd1693d4f1df0716adaabddf52493ff1007" translate="yes" xml:space="preserve">
          <source>O P</source>
          <target state="translated">OP</target>
        </trans-unit>
        <trans-unit id="c363dc3457ef24cf6ba8971bbc948dded316392b" translate="yes" xml:space="preserve">
          <source>Obarrays are also a kind of hash table, but they are a different type of object and are used only for recording interned symbols (see &lt;a href=&quot;creating-symbols#Creating-Symbols&quot;&gt;Creating Symbols&lt;/a&gt;).</source>
          <target state="translated">Obarray는 일종의 해시 테이블이지만 다른 유형의 객체이며 인턴 된 기호를 기록하는 데만 사용됩니다 ( &lt;a href=&quot;creating-symbols#Creating-Symbols&quot;&gt;기호 만들기&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="6f56ee4a102e69c064a8440479a96623086d8758" translate="yes" xml:space="preserve">
          <source>Object Internals</source>
          <target state="translated">개체 내부</target>
        </trans-unit>
        <trans-unit id="9101d7a347d0a3885fc114e1cef91162863e5343" translate="yes" xml:space="preserve">
          <source>Objects holding information about types.</source>
          <target state="translated">유형에 대한 정보를 보유하는 객체입니다.</target>
        </trans-unit>
        <trans-unit id="d2b0ba186e391135f71f9fbac7110335d650cacf" translate="yes" xml:space="preserve">
          <source>Objects that have no read syntax are presented like this (see &lt;a href=&quot;printed-representation#Printed-Representation&quot;&gt;Printed Representation&lt;/a&gt;).</source>
          <target state="translated">읽기 구문이없는 객체는 다음과 같이 표시됩니다 ( &lt;a href=&quot;printed-representation#Printed-Representation&quot;&gt;Printed Representation&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="d7717e27b11c625514b5d6b2df3dc3a2a3bbea53" translate="yes" xml:space="preserve">
          <source>Obtain rudimentary coverage testing and frequency counts.</source>
          <target state="translated">기초적인 커버리지 테스트 및 빈도 수를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="523942562b4a55d93a983d95b45b7177c8e4772d" translate="yes" xml:space="preserve">
          <source>Obtaining random integers, predictable or not.</source>
          <target state="translated">예측 가능 여부에 관계없이 임의의 정수를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="46a01ce0f03ec80a793aa30a264989482df496b0" translate="yes" xml:space="preserve">
          <source>Obviously, this does not actually modify &lt;code&gt;previous-line&lt;/code&gt;. For that the old advice needed:</source>
          <target state="translated">분명히 이것은 실제로 &lt;code&gt;previous-line&lt;/code&gt; 수정하지 않습니다 . 이를 위해 오래된 조언이 필요했습니다.</target>
        </trans-unit>
        <trans-unit id="264277b0376bfa4b86c520e9ec23072a05a7fe4d" translate="yes" xml:space="preserve">
          <source>Occasionally problems result from the fact that a macro call is expanded each time it is evaluated in an interpreted function, but is expanded only once (during compilation) for a compiled function. If the macro definition has side effects, they will work differently depending on how many times the macro is expanded.</source>
          <target state="translated">매크로 호출이 해석 된 함수에서 평가 될 때마다 확장되지만 컴파일 된 함수에 대해 한 번만 확장된다는 사실로 인해 문제가 발생하는 경우가 있습니다. 매크로 정의에 부작용이있는 경우 매크로가 확장 된 횟수에 따라 다르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="bce973a751cd4a03300fce0010a6712f601f9f80" translate="yes" xml:space="preserve">
          <source>Occasionally you will want to test explicitly whether a library has already been loaded. If the library uses &lt;code&gt;provide&lt;/code&gt; to provide a named feature, you can use &lt;code&gt;featurep&lt;/code&gt; earlier in the file to test whether the &lt;code&gt;provide&lt;/code&gt; call has been executed before (see &lt;a href=&quot;named-features#Named-Features&quot;&gt;Named Features&lt;/a&gt;). Alternatively, you could use something like this:</source>
          <target state="translated">때로는 라이브러리가 이미로드되었는지 여부를 명시 적으로 테스트하고 싶을 것입니다. 라이브러리가 &lt;code&gt;provide&lt;/code&gt; 를 사용하여 명명 된 기능을 제공하는 경우 파일의 앞부분에있는 &lt;code&gt;featurep&lt;/code&gt; 를 사용 하여 &lt;code&gt;provide&lt;/code&gt; 호출이 이전에 실행 되었는지 여부를 테스트 할 수 있습니다 ( &lt;a href=&quot;named-features#Named-Features&quot;&gt;명명 된 기능&lt;/a&gt; 참조 ). 또는 다음과 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3bce6877b2fad79bb26a891e5eaabc5fa131f26b" translate="yes" xml:space="preserve">
          <source>Occasionally, Emacs needs to hold and manipulate encoded text or binary non-text data in its buffers or strings. For example, when Emacs visits a file, it first reads the file&amp;rsquo;s text verbatim into a buffer, and only then converts it to the internal representation. Before the conversion, the buffer holds encoded text.</source>
          <target state="translated">때때로 Emacs는 버퍼 나 문자열에 인코딩 된 텍스트 또는 텍스트가 아닌 바이너리 데이터를 보유하고 조작해야합니다. 예를 들어, Emacs가 파일을 방문하면 먼저 파일의 텍스트를 그대로 버퍼로 읽은 다음 내부 표현으로 만 변환합니다. 변환 전에 버퍼는 인코딩 된 텍스트를 보유합니다.</target>
        </trans-unit>
        <trans-unit id="3dbe249e6f95e11f5e11808a2753212c83d62b34" translate="yes" xml:space="preserve">
          <source>Occasionally, such &lt;em&gt;implied frame resizing&lt;/em&gt; may be unwanted, for example, when a frame has been maximized or made full-screen (where it&amp;rsquo;s turned off by default). In general, users can disable implied resizing with the following option:</source>
          <target state="translated">경우에 따라 프레임이 최대화되거나 전체 화면이 된 경우 (기본적으로 꺼져있는 경우) 이러한 &lt;em&gt;암시 적 프레임 크기 조정&lt;/em&gt; 이 원하지 않을 수 있습니다. 일반적으로 사용자는 다음 옵션을 사용하여 묵시적 크기 조정을 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0aff50bf865a5c17280fbf067141c1f7c36c3a36" translate="yes" xml:space="preserve">
          <source>Occasionally, you may want to reference a variable which is only determined at run time. In that case, you cannot specify the variable name in the text of the program. You can use the &lt;code&gt;symbol-value&lt;/code&gt; function to extract the value.</source>
          <target state="translated">경우에 따라 런타임에만 결정되는 변수를 참조 할 수 있습니다. 이 경우 프로그램 텍스트에 변수 이름을 지정할 수 없습니다. &lt;code&gt;symbol-value&lt;/code&gt; 함수를 사용하여 값을 추출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="22fc935449693a1e814188a46a216288f35c0512" translate="yes" xml:space="preserve">
          <source>Of course, if the actual value of the option fits this alternative, it will appear showing the actual value, not &lt;var&gt;default&lt;/var&gt;.</source>
          <target state="translated">물론 옵션의 실제 값이이 대안에 맞으면 &lt;var&gt;default&lt;/var&gt; 가 아닌 실제 값을 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="15696db648937c4ccbe88be9cf5f24c7996a1367" translate="yes" xml:space="preserve">
          <source>Of these usual keymaps, the highest-precedence one is specified by the &lt;code&gt;keymap&lt;/code&gt; text or overlay property at point, if any. (For a mouse input event, Emacs uses the event position instead of point; see &lt;a href=&quot;searching-keymaps#Searching-Keymaps&quot;&gt;Searching Keymaps&lt;/a&gt;.)</source>
          <target state="translated">이러한 일반적인 키맵 중에서 가장 높은 우선 순위는 &lt;code&gt;keymap&lt;/code&gt; 텍스트 또는 오버레이 속성 (있는 경우)에 의해 지정됩니다 . (마우스 입력 이벤트의 경우 Emacs는 포인트 대신 이벤트 위치를 사용합니다 . &lt;a href=&quot;searching-keymaps#Searching-Keymaps&quot;&gt;키맵 검색을&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="4dc8a5d2b3bac37c9f0883d213f98c63e2f5757f" translate="yes" xml:space="preserve">
          <source>Often &lt;code&gt;window-size-fixed&lt;/code&gt; is overly aggressive because it inhibits any attempt to explicitly resize or split an affected window as well. This may even happen after the window has been resized implicitly, for example, when deleting an adjacent window or resizing the window&amp;rsquo;s frame. The following function tries hard to never disallow resizing such a window explicitly:</source>
          <target state="translated">종종 &lt;code&gt;window-size-fixed&lt;/code&gt; 는 영향을받는 창을 명시 적으로 크기 조정하거나 분할하려는 시도를 금지하기 때문에 지나치게 공격적입니다. 이는 예를 들어 인접한 창을 삭제하거나 창의 프레임 크기를 조정할 때와 같이 창 크기가 암시 적으로 조정 된 후에도 발생할 수 있습니다. 다음 함수는 그러한 창의 크기를 명시 적으로 절대 허용하지 않으려 고 노력합니다.</target>
        </trans-unit>
        <trans-unit id="eee3f476e8d88bba8df49970967c0f8d91d77b1e" translate="yes" xml:space="preserve">
          <source>Often we want to execute the last clause whenever none of the previous clauses was successful. To do this, we use &lt;code&gt;t&lt;/code&gt; as the &lt;var&gt;condition&lt;/var&gt; of the last clause, like this: &lt;code&gt;(t
&lt;var&gt;body-forms&lt;/var&gt;)&lt;/code&gt;. The form &lt;code&gt;t&lt;/code&gt; evaluates to &lt;code&gt;t&lt;/code&gt;, which is never &lt;code&gt;nil&lt;/code&gt;, so this clause never fails, provided the &lt;code&gt;cond&lt;/code&gt; gets to it at all. For example:</source>
          <target state="translated">종종 우리는 이전 절이 성공하지 못할 때마다 마지막 절을 실행하려고합니다. 이를 위해 다음 과 같이 마지막 절의 &lt;var&gt;condition&lt;/var&gt; 으로 &lt;code&gt;t&lt;/code&gt; 를 사용 합니다 : &lt;code&gt;(t &lt;var&gt;body-forms&lt;/var&gt;)&lt;/code&gt; &lt;var&gt;body-forms&lt;/var&gt; ) . 양식 &lt;code&gt;t&lt;/code&gt; 평가됩니다에 &lt;code&gt;t&lt;/code&gt; 결코, &lt;code&gt;nil&lt;/code&gt; 제공되는이 절은 결코 실패하지 않도록, &lt;code&gt;cond&lt;/code&gt; 전혀 그것을 가져옵니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="ab20aa539406f6dcc74005792b8dba230e5c4baa" translate="yes" xml:space="preserve">
          <source>Older implementations of &lt;code&gt;display-buffer&lt;/code&gt; frequently caused users and applications to fight over the settings of user options like &lt;code&gt;pop-up-frames&lt;/code&gt; and &lt;code&gt;pop-up-windows&lt;/code&gt; (see &lt;a href=&quot;choosing-window-options#Choosing-Window-Options&quot;&gt;Choosing Window Options&lt;/a&gt;). This was one major reason for redesigning &lt;code&gt;display-buffer&lt;/code&gt;&amp;mdash;to provide a clear framework specifying what users and applications should be allowed to do.</source>
          <target state="translated">&lt;code&gt;display-buffer&lt;/code&gt; 의 이전 구현으로 인해 사용자와 응용 프로그램이 &lt;code&gt;pop-up-frames&lt;/code&gt; 및 &lt;code&gt;pop-up-windows&lt;/code&gt; 같은 사용자 옵션 설정을 놓고 싸우는 경우가 많았 습니다 ( &lt;a href=&quot;choosing-window-options#Choosing-Window-Options&quot;&gt;창 옵션 선택&lt;/a&gt; 참조 ). 이것이 &lt;code&gt;display-buffer&lt;/code&gt; 를 재 설계 한 주요 이유 중 하나였습니다. 사용자와 애플리케이션이 수행 할 수있는 작업을 지정하는 명확한 프레임 워크를 제공하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="bde4db5a93db0c668793ff17fa3effb0028c7b23" translate="yes" xml:space="preserve">
          <source>Omitting the argument &lt;var&gt;end&lt;/var&gt; is equivalent to specifying &lt;code&gt;nil&lt;/code&gt;. It follows that &lt;code&gt;(substring &lt;var&gt;string&lt;/var&gt; 0)&lt;/code&gt; returns a copy of all of &lt;var&gt;string&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;end&lt;/var&gt; 인수를 생략하는 것은 &lt;code&gt;nil&lt;/code&gt; 을 지정하는 것과 같습니다 . 다음은 &lt;code&gt;(substring &lt;var&gt;string&lt;/var&gt; 0)&lt;/code&gt; 모든 &lt;var&gt;string&lt;/var&gt; 의 복사본을 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="066afc902473c5cdc45a4d6cd87ac56bcadb3222" translate="yes" xml:space="preserve">
          <source>On GNU and Unix systems, each X display is a separate graphical terminal. When Emacs is started from within the X window system, it uses the X display specified by the &lt;code&gt;DISPLAY&lt;/code&gt; environment variable, or by the &amp;lsquo;</source>
          <target state="translated">GNU 및 Unix 시스템에서 각 X 디스플레이는 별도의 그래픽 터미널입니다. Emacs가 X 윈도우 시스템 내에서 시작되면 &lt;code&gt;DISPLAY&lt;/code&gt; 환경 변수 또는 '</target>
        </trans-unit>
        <trans-unit id="091b227d1e7a53734313af3b399630351b76696a" translate="yes" xml:space="preserve">
          <source>On GNU and Unix systems, you can create additional frames on any available terminal, within a single Emacs session, regardless of whether Emacs was started on a text or graphical terminal. Emacs can display on both graphical and text terminals simultaneously. This comes in handy, for instance, when you connect to the same session from several remote locations. See &lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;Multiple Terminals&lt;/a&gt;.</source>
          <target state="translated">GNU 및 Unix 시스템에서는 Emacs가 텍스트 또는 그래픽 터미널에서 시작되었는지 여부에 관계없이 단일 Emacs 세션 내에서 사용 가능한 모든 터미널에 추가 프레임을 만들 수 있습니다. Emacs는 그래픽 및 텍스트 터미널에 동시에 표시 할 수 있습니다. 예를 들어 여러 원격 위치에서 동일한 세션에 연결할 때 유용합니다. &lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;다중 터미널을&lt;/a&gt; 참고하십시오 .</target>
        </trans-unit>
        <trans-unit id="86008f191b802986f9373390d1207c585a06279d" translate="yes" xml:space="preserve">
          <source>On GNU and other POSIX-like systems, a string returned by this function always ends in a slash. On MS-DOS it can also end in a colon.</source>
          <target state="translated">GNU 및 기타 POSIX 유사 시스템에서이 함수가 반환하는 문자열은 항상 슬래시로 끝납니다. MS-DOS에서는 콜론으로 끝날 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ec76dde782f694fa2ff646fa44724ed20f56abf" translate="yes" xml:space="preserve">
          <source>On GNU and other POSIX-like systems, this simply returns &lt;var&gt;filename&lt;/var&gt;. On other operating systems, it may enforce system-specific file name conventions; for example, on MS-DOS this function performs a variety of changes to enforce MS-DOS file name limitations, including converting any leading &amp;lsquo;</source>
          <target state="translated">GNU 및 기타 POSIX 유사 시스템에서는 단순히 &lt;var&gt;filename&lt;/var&gt; 을 반환합니다 . 다른 운영 체제에서는 시스템 별 파일 이름 규칙을 적용 할 수 있습니다. 예를 들어, MS-DOS에서이 기능은 MS-DOS 파일 이름 제한을 적용하기 위해 다양한 변경을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="d87da634547b00223204825e52b32ac75a53d3aa" translate="yes" xml:space="preserve">
          <source>On GNU platforms when operating on a local file, this function is atomic: if the filesystem is simultaneously being changed by some other process, this function returns the file&amp;rsquo;s attributes either before or after the change. Otherwise this function is not atomic, and might return &lt;code&gt;nil&lt;/code&gt; if it detects the race condition, or might return a hodgepodge of the previous and current file attributes.</source>
          <target state="translated">GNU 플랫폼에서 로컬 파일에서 작동 할 때이 함수는 원자 적입니다. 파일 시스템이 다른 프로세스에 의해 동시에 변경되는 경우이 함수는 변경 전후에 파일의 속성을 반환합니다. 그렇지 않으면이 함수는 원자 적이 지 않으며 경쟁 조건을 감지하면 &lt;code&gt;nil&lt;/code&gt; 을 반환하거나 이전 및 현재 파일 속성의 뒤죽박죽을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8d088ebe683822c85b3d4ba7ca6f051bd5326f5" translate="yes" xml:space="preserve">
          <source>On MS-DOS and MS-Windows, these functions (like the function that actually operate on files) accept MS-DOS or MS-Windows file-name syntax, where backslashes separate the components, as well as POSIX syntax; but they always return POSIX syntax. This enables Lisp programs to specify file names in POSIX syntax and work properly on all systems without change.&lt;a href=&quot;#FOOT15&quot; name=&quot;DOCF15&quot;&gt;&lt;sup&gt;15&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">MS-DOS 및 MS-Windows에서 이러한 함수 (예 : 파일에서 실제로 작동하는 함수)는 MS-DOS 또는 MS-Windows 파일 이름 구문을 허용합니다. 여기서 백 슬래시는 구성 요소와 POSIX 구문을 구분합니다. 그러나 그들은 항상 POSIX 구문을 반환합니다. 이를 통해 Lisp 프로그램은 POSIX 구문으로 파일 이름을 지정하고 변경없이 모든 시스템에서 올바르게 작동 할 수 있습니다. &lt;a href=&quot;#FOOT15&quot; name=&quot;DOCF15&quot;&gt;&lt;sup&gt;15&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2928e4c3bab1512e37407ed35b34ba158366a196" translate="yes" xml:space="preserve">
          <source>On MS-DOS filesystems without long names this variable is always ignored.</source>
          <target state="translated">긴 이름이없는 MS-DOS 파일 시스템에서이 변수는 항상 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="e12a5b8ff044d26de039b2ea5eb8fbb324b2d8e4" translate="yes" xml:space="preserve">
          <source>On MS-DOS, Emacs sets the &lt;code&gt;TERM&lt;/code&gt; environment variable to &amp;lsquo;</source>
          <target state="translated">MS-DOS에서 Emacs는 &lt;code&gt;TERM&lt;/code&gt; 환경 변수를 '</target>
        </trans-unit>
        <trans-unit id="ec2bac6013926e2f9b7a2cc7618659e3f89fcfa1" translate="yes" xml:space="preserve">
          <source>On MS-Windows the &lt;var&gt;noactivate&lt;/var&gt; argument has no effect. However, if &lt;var&gt;frame&lt;/var&gt; is a child frame (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;), this function usually focuses &lt;var&gt;frame&lt;/var&gt; without raising it above other child frames.</source>
          <target state="translated">MS-Windows에서 &lt;var&gt;noactivate&lt;/var&gt; 인수는 효과가 없습니다. 그러나, &lt;var&gt;frame&lt;/var&gt; 아이 프레임 (참조 인 &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;아이 프레임을&lt;/a&gt; ),이 기능은 일반적으로 초점을 맞추고 &lt;var&gt;frame&lt;/var&gt; 다른 아이 프레임 이상을 발생시키지 않고.</target>
        </trans-unit>
        <trans-unit id="ef4fecbe41a5626c5f763eccb62f475909804106" translate="yes" xml:space="preserve">
          <source>On Windows 2000 and later, Emacs by default uses Unicode APIs to pass file names to the OS, so the value of &lt;code&gt;file-name-coding-system&lt;/code&gt; is largely ignored. Lisp applications that need to encode or decode file names on the Lisp level should use &lt;code&gt;utf-8&lt;/code&gt; coding-system when &lt;code&gt;system-type&lt;/code&gt; is &lt;code&gt;windows-nt&lt;/code&gt;; the conversion of UTF-8 encoded file names to the encoding appropriate for communicating with the OS is performed internally by Emacs.</source>
          <target state="translated">Windows 2000 이상에서 Emacs는 기본적으로 Unicode API를 사용하여 OS에 파일 이름을 전달하므로 &lt;code&gt;file-name-coding-system&lt;/code&gt; 의 값 은 대부분 무시됩니다. Lisp 수준에서 파일 이름을 인코딩하거나 디코딩해야하는 Lisp 응용 프로그램은 &lt;code&gt;system-type&lt;/code&gt; 이 &lt;code&gt;windows-nt&lt;/code&gt; 일 때 &lt;code&gt;utf-8&lt;/code&gt; 코딩 시스템을 사용해야합니다 . UTF-8로 인코딩 된 파일 이름을 OS와의 통신에 적합한 인코딩으로 변환하는 작업은 Emacs에서 내부적으로 수행합니다.</target>
        </trans-unit>
        <trans-unit id="3d9d3c2776e23b63f854890fc4c9449192d7124d" translate="yes" xml:space="preserve">
          <source>On a graphical display, tiny arrow images in the window fringes indicate truncated and continued lines (see &lt;a href=&quot;fringes#Fringes&quot;&gt;Fringes&lt;/a&gt;). On a text terminal, a &amp;lsquo;</source>
          <target state="translated">그래픽 디스플레이에서 윈도우 변두리에있는 작은 화살표 이미지가 잘립니다와 (참조 라인을 계속 나타냅니다 &lt;a href=&quot;fringes#Fringes&quot;&gt;변두리을&lt;/a&gt; ). 텍스트 터미널에서 '</target>
        </trans-unit>
        <trans-unit id="80f59247bbce1d1c9f874202c878dbd846f48819" translate="yes" xml:space="preserve">
          <source>On a graphical terminal that supports extended</source>
          <target state="translated">확장을 지원하는 그래픽 터미널에서</target>
        </trans-unit>
        <trans-unit id="71814826cf878c3c911d09d9a92001d4a2a4fb2c" translate="yes" xml:space="preserve">
          <source>On a graphical terminal the following two functions allow the absolute position of the mouse cursor to be retrieved and set.</source>
          <target state="translated">그래픽 터미널에서 다음 두 가지 기능을 사용하면 마우스 커서의 절대 위치를 검색하고 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da4884a418379ce0d9a42cbe8229e4ebb6fbeeba" translate="yes" xml:space="preserve">
          <source>On a graphical terminal this form &amp;ldquo;warps&amp;rdquo; the mouse cursor to the upper left corner of the glyph at the selected window&amp;rsquo;s point. A position calculated this way can be also used to show a tooltip window there.</source>
          <target state="translated">그래픽 터미널에서이 양식은 마우스 커서를 선택한 창의 지점에서 글리프의 왼쪽 상단 모서리로 &quot;뒤틀&quot;습니다. 이 방법으로 계산 된 위치를 사용하여 도구 설명 창을 표시 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c638ecc2a4ea2d5a12f6c70496e911bec175971e" translate="yes" xml:space="preserve">
          <source>On a graphical terminal we distinguish two types of frames: A normal &lt;em&gt;top-level frame&lt;/em&gt; is a frame whose window-system window is a child of the window-system&amp;rsquo;s root window for that terminal. A child frame is a frame whose window-system window is the child of the window-system window of another Emacs frame. See &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;.</source>
          <target state="translated">그래픽 터미널에서 우리는 두 가지 유형의 프레임을 구분합니다. 일반 &lt;em&gt;최상위&lt;/em&gt; 프레임은 창 시스템 창이 해당 터미널에 대한 창 시스템 루트 창의 자식 인 프레임입니다. 자식 프레임은 윈도우 시스템 창이 다른 Emacs 프레임의 윈도우 시스템 윈도우의 자식 인 프레임입니다. &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;하위 프레임을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c566ed32a5007176cbb7b1c85495717dc12a7b9d" translate="yes" xml:space="preserve">
          <source>On a text terminal frame both values are zero.</source>
          <target state="translated">텍스트 터미널 프레임에서 두 값은 모두 0입니다.</target>
        </trans-unit>
        <trans-unit id="a9edfd72a3d801155297af0b22f3986badadf241" translate="yes" xml:space="preserve">
          <source>On a text terminal, all frames are considered visible for the purposes of this function, even though only one frame is displayed. See &lt;a href=&quot;raising-and-lowering#Raising-and-Lowering&quot;&gt;Raising and Lowering&lt;/a&gt;.</source>
          <target state="translated">텍스트 터미널에서는 하나의 프레임 만 표시 되더라도이 기능을 위해 모든 프레임이 보이는 것으로 간주됩니다. &lt;a href=&quot;raising-and-lowering#Raising-and-Lowering&quot;&gt;올리기 및 내리기를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5c4eb786d6a56a9b0991f45bcfa777150db81f17" translate="yes" xml:space="preserve">
          <source>On each frame, the frame parameter &lt;code&gt;tool-bar-lines&lt;/code&gt; controls how many lines&amp;rsquo; worth of height to reserve for the tool bar. A zero value suppresses the tool bar. If the value is nonzero, and &lt;code&gt;auto-resize-tool-bars&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the tool bar expands and contracts automatically as needed to hold the specified contents. If the value is &lt;code&gt;grow-only&lt;/code&gt;, the tool bar expands automatically, but does not contract automatically.</source>
          <target state="translated">각 프레임에서 프레임 매개 변수 &lt;code&gt;tool-bar-lines&lt;/code&gt; 는 도구 모음을 위해 예약 할 선의 높이를 제어합니다. 값이 0이면 도구 모음이 표시되지 않습니다. 값이 0이 아니고 &lt;code&gt;auto-resize-tool-bars&lt;/code&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 도구 모음은 지정된 내용을 유지하기 위해 필요에 따라 자동으로 확장 및 축소됩니다. 값이 &lt;code&gt;grow-only&lt;/code&gt; 이면 도구 모음이 자동으로 확장되지만 자동으로 축소되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="a47451314dff3dd8ebd99643acb7f9a5e541559a" translate="yes" xml:space="preserve">
          <source>On graphical displays, Emacs draws &lt;em&gt;fringes&lt;/em&gt; next to each window: thin vertical strips down the sides which can display bitmaps indicating truncation, continuation, horizontal scrolling, and so on.</source>
          <target state="translated">그래픽 디스플레이에서 Emacs는 각 창 옆에 &lt;em&gt;프린지를&lt;/em&gt; 그립니다 . 측면 아래에 얇은 수직 스트립이있어 잘림, 연속, 수평 스크롤 등을 나타내는 비트 맵을 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc01dccb2a56362cf18d4aefcda75bb95fe48802" translate="yes" xml:space="preserve">
          <source>On graphical systems, the position of a normal top-level frame is specified as the absolute position of its outer frame (see &lt;a href=&quot;frame-geometry#Frame-Geometry&quot;&gt;Frame Geometry&lt;/a&gt;). The position of a child frame (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;) is specified via pixel offsets of its outer edges relative to the native position of its parent frame.</source>
          <target state="translated">그래픽 시스템에서 일반 최상위 프레임의 위치는 외부 프레임의 절대 위치로 지정됩니다 ( &lt;a href=&quot;frame-geometry#Frame-Geometry&quot;&gt;프레임 형상&lt;/a&gt; 참조 ). 하위 프레임의 위치 ( &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;하위 프레임&lt;/a&gt; 참조 )는 상위 프레임의 기본 위치를 기준으로 외부 가장자리의 픽셀 오프셋을 통해 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="ec338cdd1a9ff313906eec5d348a8022f6c825b7" translate="yes" xml:space="preserve">
          <source>On graphical terminals, you can specify the line spacing for all lines in a frame, using the &lt;code&gt;line-spacing&lt;/code&gt; frame parameter (see &lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;Layout Parameters&lt;/a&gt;). However, if the default value of &lt;code&gt;line-spacing&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it overrides the frame&amp;rsquo;s &lt;code&gt;line-spacing&lt;/code&gt; parameter. An integer specifies the number of pixels put below lines. A floating-point number specifies the spacing relative to the frame&amp;rsquo;s default line height.</source>
          <target state="translated">그래픽 터미널에서 &lt;code&gt;line-spacing&lt;/code&gt; 프레임 매개 변수를 사용하여 프레임의 모든 줄에 대한 줄 간격을 지정할 수 있습니다 ( &lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;레이아웃 매개 변수&lt;/a&gt; 참조 ). 그러나 &lt;code&gt;line-spacing&lt;/code&gt; 의 기본값 이 &lt;code&gt;nil&lt;/code&gt; 이 아니면 프레임의 &lt;code&gt;line-spacing&lt;/code&gt; 매개 변수를 재정의합니다 . 정수는 행 아래에 놓이는 픽셀 수를 지정합니다. 부동 소수점 숫자는 프레임의 기본 줄 높이에 상대적인 간격을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="b46ca9680188aa91809e991a0175bded9c6cfada" translate="yes" xml:space="preserve">
          <source>On match, the clause&amp;rsquo;s body forms can reference the set of symbols the pattern let-binds. When &lt;var&gt;seqpat&lt;/var&gt; is &lt;code&gt;and&lt;/code&gt;, this set is the union of all the symbols each of its sub-patterns let-binds. This makes sense because, for &lt;code&gt;and&lt;/code&gt; to match, all the sub-patterns must match.</source>
          <target state="translated">일치시 절의 본문 양식은 패턴 let-binds 기호 세트를 참조 할 수 있습니다. 때 &lt;var&gt;seqpat&lt;/var&gt; 이 있다 &lt;code&gt;and&lt;/code&gt; ,이 세트는 서브 패턴의 각 렛 바인딩 모든 기호의 조합입니다. 들어 있기 때문에이 말이 &lt;code&gt;and&lt;/code&gt; 일치하는 모든 하위 패턴이 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="c2fe00d1b0cab19cc3dbd01c42a2c9d3f1167cf5" translate="yes" xml:space="preserve">
          <source>On most systems, the directory part is everything up to and including the last slash (backslash is also allowed in input on MS-DOS or MS-Windows); the nondirectory part is the rest.</source>
          <target state="translated">대부분의 시스템에서 디렉토리 부분은 마지막 슬래시를 포함하여 모든 것입니다 (백 슬래시는 MS-DOS 또는 MS-Windows의 입력에서도 허용됨). 디렉토리가 아닌 부분이 나머지입니다.</target>
        </trans-unit>
        <trans-unit id="d9f9275391241753a0fc3733e8b2d3b0ad7002b2" translate="yes" xml:space="preserve">
          <source>On most systems, this function works by running a directory listing program whose name is in the variable &lt;code&gt;insert-directory-program&lt;/code&gt;. If &lt;var&gt;wildcard&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it also runs the shell specified by &lt;code&gt;shell-file-name&lt;/code&gt;, to expand the wildcards.</source>
          <target state="translated">대부분의 시스템에서이 함수는 이름이 &lt;code&gt;insert-directory-program&lt;/code&gt; 변수에있는 디렉토리 목록 프로그램을 실행하여 작동 합니다 . 경우 &lt;var&gt;wildcard&lt;/var&gt; 아닌 것입니다 &lt;code&gt;nil&lt;/code&gt; , 그것은 또한에 의해 지정된 쉘 실행 &lt;code&gt;shell-file-name&lt;/code&gt; 와일드 카드를 확장을,.</target>
        </trans-unit>
        <trans-unit id="6d4535f8da402c43490a2180be3f0732c9111726" translate="yes" xml:space="preserve">
          <source>On multi-monitor displays it is possible to use the command &lt;code&gt;make-frame-on-monitor&lt;/code&gt; to make frames on the specified monitor.</source>
          <target state="translated">다중 모니터 디스플레이에서 &lt;code&gt;make-frame-on-monitor&lt;/code&gt; 명령을 사용 하여 지정된 모니터에서 프레임을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="424aff0ac8fca763b6c89e454a579a4f615d419e" translate="yes" xml:space="preserve">
          <source>On some multi-monitor setups, a single X display outputs to more than one physical monitor. You can use the functions &lt;code&gt;display-monitor-attributes-list&lt;/code&gt; and &lt;code&gt;frame-monitor-attributes&lt;/code&gt; to obtain information about such setups.</source>
          <target state="translated">일부 다중 모니터 설정에서 단일 X 디스플레이는 둘 이상의 물리적 모니터로 출력됩니다. &lt;code&gt;display-monitor-attributes-list&lt;/code&gt; 및 &lt;code&gt;frame-monitor-attributes&lt;/code&gt; 함수를 사용하여 이러한 설정에 대한 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25a3df6f65657e687d2e69c45bc13942a081601f" translate="yes" xml:space="preserve">
          <source>On some operating systems, an absolute file name begins with a device name. On such systems, &lt;var&gt;filename&lt;/var&gt; has no relative equivalent based on &lt;var&gt;directory&lt;/var&gt; if they start with two different device names. In this case, &lt;code&gt;file-relative-name&lt;/code&gt; returns &lt;var&gt;filename&lt;/var&gt; in absolute form.</source>
          <target state="translated">일부 운영 체제에서 절대 파일 이름은 장치 이름으로 시작합니다. 이러한 시스템에서 &lt;var&gt;filename&lt;/var&gt; 은 두 개의 다른 장치 이름으로 시작하는 경우 &lt;var&gt;directory&lt;/var&gt; 기준으로 상대적으로 동등한 항목이 없습니다 . 이 경우 &lt;code&gt;file-relative-name&lt;/code&gt; 은 절대 형식으로 &lt;var&gt;filename&lt;/var&gt; 이름을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="213a628dbf886420d394fb191adc21bae49c70bf" translate="yes" xml:space="preserve">
          <source>On some operating systems, each file can be associated with arbitrary &lt;em&gt;extended file attributes&lt;/em&gt;. At present, Emacs supports querying and setting two specific sets of extended file attributes: Access Control Lists (ACLs) and SELinux contexts. These extended file attributes are used, on some systems, to impose more sophisticated file access controls than the basic Unix-style permissions discussed in the previous sections.</source>
          <target state="translated">일부 운영 체제에서 각 파일은 임의의 &lt;em&gt;확장 파일 속성&lt;/em&gt; 과 연관 될 수 있습니다 . 현재 Emacs는 액세스 제어 목록 (ACL) 및 SELinux 컨텍스트의 두 가지 특정 확장 파일 속성 세트를 쿼리하고 설정하는 것을 지원합니다. 이러한 확장 파일 속성은 일부 시스템에서 이전 섹션에서 설명한 기본 Unix 스타일 권한보다 더 정교한 파일 액세스 제어를 적용하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="73e008db2f82ffdcf0d72c8e1923a9faeb539e93" translate="yes" xml:space="preserve">
          <source>On some operating systems, more complex sets of access permissions can be specified, via mechanisms such as Access Control Lists (ACLs). See &lt;a href=&quot;extended-attributes#Extended-Attributes&quot;&gt;Extended Attributes&lt;/a&gt;, for how to query and set those permissions.</source>
          <target state="translated">일부 운영 체제에서는 ACL (액세스 제어 목록)과 같은 메커니즘을 통해보다 복잡한 액세스 권한 집합을 지정할 수 있습니다. 이러한 권한을 쿼리하고 설정하는 방법 은 &lt;a href=&quot;extended-attributes#Extended-Attributes&quot;&gt;확장 된 속성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c32f84426cac9a32d45d101e0d8f5f9e2996aa5c" translate="yes" xml:space="preserve">
          <source>On some systems, when Emacs reads the output from a subprocess, the output data is read in very small blocks, potentially resulting in very poor performance. This behavior can be remedied to some extent by setting the variable &lt;code&gt;process-adaptive-read-buffering&lt;/code&gt; to a non-&lt;code&gt;nil&lt;/code&gt; value (the default), as it will automatically delay reading from such processes, thus allowing them to produce more output before Emacs tries to read it.</source>
          <target state="translated">일부 시스템에서 Emacs가 하위 프로세스의 출력을 읽을 때 출력 데이터는 매우 작은 블록으로 읽혀 잠재적으로 성능이 매우 저하 될 수 있습니다. 이 동작은 &lt;code&gt;process-adaptive-read-buffering&lt;/code&gt; 변수를 &lt;code&gt;nil&lt;/code&gt; 이 아닌 값 (기본값) 으로 설정하여 어느 정도 해결할 수 있습니다. 이러한 프로세스에서 읽기를 자동으로 지연시켜 Emacs가 시도하기 전에 더 많은 출력을 생성 할 수 있기 때문입니다. 그것을 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="819b49b75e3e8487d55fbdd732a2765e416d401d" translate="yes" xml:space="preserve">
          <source>On success, it returns a list of a binary string (the output) and the IV used.</source>
          <target state="translated">성공하면 이진 문자열 (출력) 및 사용 된 IV 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5b8c9a445132c5cf6d56dccf077cd1f1c5b172c2" translate="yes" xml:space="preserve">
          <source>On text terminals, it is possible to &lt;em&gt;suspend Emacs&lt;/em&gt;, which means stopping Emacs temporarily and returning control to its superior process, which is usually the shell. This allows you to resume editing later in the same Emacs process, with the same buffers, the same kill ring, the same undo history, and so on. To resume Emacs, use the appropriate command in the parent shell&amp;mdash;most likely &lt;code&gt;fg&lt;/code&gt;.</source>
          <target state="translated">텍스트 터미널에서는 &lt;em&gt;Emacs&lt;/em&gt; 를 &lt;em&gt;일시 중지&lt;/em&gt; 할 수 있습니다. 즉, Emacs를 일시적으로 중지하고 제어권을 일반적으로 쉘인 상위 프로세스로 되 돌리는 것을 의미합니다. 이렇게하면 동일한 버퍼, 동일한 킬 링, 동일한 실행 취소 히스토리 등을 사용하여 동일한 Emacs 프로세스에서 나중에 편집을 재개 할 수 있습니다. 이맥스를 다시 시작하려면, 부모 쉘 - 대부분의 해당 명령을 사용 &lt;code&gt;fg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="77e13395725f09ad2c8856d110ef6337fce6ac46" translate="yes" xml:space="preserve">
          <source>On text terminals, suspending and resuming Emacs normally also refreshes the screen. Some terminal emulators record separate contents for display-oriented programs such as Emacs and for ordinary sequential display. If you are using such a terminal, you might want to inhibit the redisplay on resumption.</source>
          <target state="translated">텍스트 터미널에서 Emacs를 일시 중지하고 다시 시작하면 일반적으로 화면이 새로 고쳐집니다. 일부 터미널 에뮬레이터는 Emacs와 같은 디스플레이 지향 프로그램과 일반 순차 디스플레이에 대해 별도의 내용을 기록합니다. 이러한 터미널을 사용하는 경우 재개시 재 표시를 금지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20d88ccd4c937138f50db938fd11563e2dd25a8e" translate="yes" xml:space="preserve">
          <source>On text terminals, the line spacing cannot be altered.</source>
          <target state="translated">텍스트 터미널에서는 줄 간격을 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e069fc175afc43cf759588b838318611f81e51ce" translate="yes" xml:space="preserve">
          <source>On the other hand, &lt;code&gt;assq&lt;/code&gt; is not usually useful in alists where the keys may not be symbols:</source>
          <target state="translated">반면에 &lt;code&gt;assq&lt;/code&gt; 는 키가 기호가 아닐 수있는 alist 에서는 일반적으로 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2812f8f2bcfa7413b908d5f9a288205c2972743e" translate="yes" xml:space="preserve">
          <source>On the other hand, the order of &lt;em&gt;bindings&lt;/em&gt; is unspecified: in the following example, either 1 or 2 might be printed.</source>
          <target state="translated">반면 &lt;em&gt;바인딩&lt;/em&gt; 순서 는 지정되지 않습니다. 다음 예에서는 1 또는 2가 인쇄 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f85ff0be4cebfcaf47b004ec226b3b02a71dc33" translate="yes" xml:space="preserve">
          <source>On the whole, Emacs follows the Unicode Standard in its implementation of character properties. In particular, Emacs supports the &lt;a href=&quot;https://www.unicode.org/reports/tr23/&quot;&gt;Unicode Character Property Model&lt;/a&gt;, and the Emacs character property database is derived from the Unicode Character Database (</source>
          <target state="translated">전체적으로 Emacs는 문자 속성 구현에서 유니 코드 표준을 따릅니다. 특히 Emacs는 &lt;a href=&quot;https://www.unicode.org/reports/tr23/&quot;&gt;유니 코드 문자 속성 모델을&lt;/a&gt; 지원하며 Emacs 문자 속성 데이터베이스는 유니 코드 문자 데이터베이스 (</target>
        </trans-unit>
        <trans-unit id="0df1af20ccce16453cf49d86077bec23de12dd86" translate="yes" xml:space="preserve">
          <source>On window systems that support it, Emacs tries by default to make the text size of a frame measured in pixels a multiple of the frame&amp;rsquo;s character size. This, however, usually means that a frame can be resized only in character size increments when dragging its external borders. It also may break attempts to truly maximize the frame or making it &amp;ldquo;fullheight&amp;rdquo; or &amp;ldquo;fullwidth&amp;rdquo; (see &lt;a href=&quot;size-parameters#Size-Parameters&quot;&gt;Size Parameters&lt;/a&gt;) leaving some empty space below and/or on the right of the frame. The following option may help in that case.</source>
          <target state="translated">이를 지원하는 윈도우 시스템에서 Emacs는 기본적으로 프레임의 텍스트 크기를 프레임 문자 크기의 배수로 픽셀로 측정하려고합니다. 그러나 이는 일반적으로 외부 테두리를 드래그 할 때 문자 크기 증분으로 만 프레임 크기를 조정할 수 있음을 의미합니다. 또한 프레임을 진정으로 최대화하려는 시도를 중단하거나 프레임 아래 및 / 또는 오른쪽에 빈 공간을 남겨 &quot;전체 높이&quot;또는 &quot;전체 너비&quot;( &lt;a href=&quot;size-parameters#Size-Parameters&quot;&gt;크기 매개 변수&lt;/a&gt; 참조 )로 만들 수 있습니다. 이 경우 다음 옵션이 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="841d1d478ab20c6c338cac784c3bcdb7e40083b9" translate="yes" xml:space="preserve">
          <source>On window systems, you can also enable auto-raising (on frame selection) or auto-lowering (on frame deselection) using frame parameters. See &lt;a href=&quot;management-parameters#Management-Parameters&quot;&gt;Management Parameters&lt;/a&gt;.</source>
          <target state="translated">윈도우 시스템에서는 프레임 매개 변수를 사용하여 자동 올리기 (프레임 선택시) 또는 자동 내리기 (프레임 선택 해제시)를 활성화 할 수도 있습니다. &lt;a href=&quot;management-parameters#Management-Parameters&quot;&gt;관리 매개 변수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="77c8d598496ec2e71e45a895d0ca263179948375" translate="yes" xml:space="preserve">
          <source>On-demand loading of support libraries.</source>
          <target state="translated">지원 라이브러리의 주문형로드.</target>
        </trans-unit>
        <trans-unit id="ad07b4aac29586e1b0b7c1f1bda28884c7ab4bca" translate="yes" xml:space="preserve">
          <source>Once Emacs decides that a certain handler handles the error, it returns control to that handler. To do so, Emacs unbinds all variable bindings made by binding constructs that are being exited, and executes the cleanups of all &lt;code&gt;unwind-protect&lt;/code&gt; forms that are being exited. Once control arrives at the handler, the body of the handler executes normally.</source>
          <target state="translated">Emacs가 특정 핸들러가 오류를 처리한다고 결정하면 해당 핸들러에 제어를 반환합니다. 이를 위해 Emacs는 종료되는 바인딩 구조에 의해 만들어진 모든 변수 바인딩을 해제하고 종료되는 모든 &lt;code&gt;unwind-protect&lt;/code&gt; 형식 의 정리를 실행합니다 . 제어가 핸들러에 도착하면 핸들러의 본문이 정상적으로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="778c77b00697e4553fcdfbf4f104e11fe2eb93ee" translate="yes" xml:space="preserve">
          <source>Once a function is instrumented, any call to the function activates Edebug. Depending on which Edebug execution mode you have selected, activating Edebug may stop execution and let you step through the function, or it may update the display and continue execution while checking for debugging commands. The default execution mode is step, which stops execution. See &lt;a href=&quot;edebug-execution-modes#Edebug-Execution-Modes&quot;&gt;Edebug Execution Modes&lt;/a&gt;.</source>
          <target state="translated">함수가 계측되면 함수를 호출하면 Edebug가 활성화됩니다. 선택한 Edebug 실행 모드에 따라 Edebug를 활성화하면 실행이 중지되고 기능을 단계별로 진행할 수 있거나 디스플레이를 업데이트하고 디버깅 명령을 확인하는 동안 실행을 계속할 수 있습니다. 기본 실행 모드는 실행을 중지하는 단계입니다. &lt;a href=&quot;edebug-execution-modes#Edebug-Execution-Modes&quot;&gt;Edebug 실행 모드를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7e4ee3d26197fcab8232cca69fb16d0f05f95688" translate="yes" xml:space="preserve">
          <source>Once a series has begun, the value is a marker which points to the buffer position in the warnings buffer of the start of the series.</source>
          <target state="translated">시리즈가 시작되면 값은 시리즈 시작의 경고 버퍼에서 버퍼 위치를 가리키는 마커입니다.</target>
        </trans-unit>
        <trans-unit id="36b6d567cfa67a7659808b6d1ff19d545a0d2c63" translate="yes" xml:space="preserve">
          <source>Once set up, side windows also change the behavior of the commands &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; and &lt;code&gt;switch-to-next-buffer&lt;/code&gt; (see &lt;a href=&quot;window-history#Window-History&quot;&gt;Window History&lt;/a&gt;). In particular, these commands will refrain from showing, in a side window, buffers that have not been displayed in that window before. They will also refrain from having a normal, non-side window show a buffer that has been already displayed in a side window. A notable exception to the latter rule occurs when an application, after displaying a buffer, resets that buffer&amp;rsquo;s local variables.</source>
          <target state="translated">설정이 완료되면 사이드 윈도우는 &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; 로 &lt;code&gt;switch-to-next-buffer&lt;/code&gt; 및 다음 버퍼 로 전환 명령의 동작도 변경합니다 ( &lt;a href=&quot;window-history#Window-History&quot;&gt;창 기록&lt;/a&gt; 참조 ). 특히, 이러한 명령은 이전에 해당 창에 표시되지 않았던 버퍼를 사이드 창에 표시하지 않습니다. 또한 사이드 윈도우에 이미 표시된 버퍼가 사이드 윈도우가 아닌 일반 윈도우에 표시되지 않도록합니다. 후자의 규칙에 대한 주목할만한 예외는 애플리케이션이 버퍼를 표시 한 후 해당 버퍼의 로컬 변수를 재설정 할 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="46c1926d71b4e8e4b97adb3110fa61cac0093fb9" translate="yes" xml:space="preserve">
          <source>Once the buffer has a suitable &lt;code&gt;revert-buffer-function&lt;/code&gt; and &lt;code&gt;buffer-stale-function&lt;/code&gt;, several problems usually remain.</source>
          <target state="translated">버퍼에 적절한 &lt;code&gt;revert-buffer-function&lt;/code&gt; 및 &lt;code&gt;buffer-stale-function&lt;/code&gt; 이 있으면 일반적으로 몇 가지 문제가 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="59381f9a9d9f927b9e2c3c74e1d9f85d8c8d831a" translate="yes" xml:space="preserve">
          <source>Once the mark exists in a buffer, it normally never ceases to exist. However, it may become &lt;em&gt;inactive&lt;/em&gt;, if Transient Mark mode is enabled. The buffer-local variable &lt;code&gt;mark-active&lt;/code&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, means that the mark is active. A command can call the function &lt;code&gt;deactivate-mark&lt;/code&gt; to deactivate the mark directly, or it can request deactivation of the mark upon return to the editor command loop by setting the variable &lt;code&gt;deactivate-mark&lt;/code&gt; to a non-&lt;code&gt;nil&lt;/code&gt; value.</source>
          <target state="translated">마크가 버퍼에 있으면 일반적으로 존재하는 것을 멈추지 않습니다. 그러나 Transient Mark 모드가 활성화 된 경우 &lt;em&gt;비활성화&lt;/em&gt; 될 수 있습니다. 버퍼 로컬 변수 &lt;code&gt;mark-active&lt;/code&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 마크가 활성 상태임을 의미합니다. 명령은 &lt;code&gt;deactivate-mark&lt;/code&gt; 함수를 호출하여 마크를 직접 비활성화하거나, &lt;code&gt;deactivate-mark&lt;/code&gt; 변수를 &lt;code&gt;nil&lt;/code&gt; 이 아닌 값 으로 설정하여 편집기 명령 루프로 돌아갈 때 마크 비활성화를 요청할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="197124b549991ea7d2db5253b6de18d693ff5eb3" translate="yes" xml:space="preserve">
          <source>Once the variable has a value, you can refer to it by using the symbol itself as an expression. Thus,</source>
          <target state="translated">변수에 값이 있으면 기호 자체를 표현식으로 사용하여 참조 할 수 있습니다. 그러므로,</target>
        </trans-unit>
        <trans-unit id="fd18cae1d555d9632ceb9466f9b376521bcb7fd1" translate="yes" xml:space="preserve">
          <source>Once you scroll a window as far right as it can go, back to its normal position where the total leftward scrolling is zero, attempts to scroll any farther right have no effect.</source>
          <target state="translated">창을 최대한 오른쪽으로 스크롤하면 전체 왼쪽 스크롤링이 0 인 정상 위치로 돌아 가면 더 오른쪽으로 스크롤하려는 시도는 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e2ef1484d788b8e71ea675fa55e9514ec4d62317" translate="yes" xml:space="preserve">
          <source>Once your module function detected that a nonlocal exit is pending, it can either return to Emacs (after performing the necessary local cleanup), or it can attempt to recover from the nonlocal exit. The following</source>
          <target state="translated">모듈 함수가 비 로컬 종료가 보류 중임을 감지하면 (필요한 로컬 정리를 수행 한 후) Emacs로 돌아가거나 비 로컬 종료에서 복구를 시도 할 수 있습니다. 다음과 같은</target>
        </trans-unit>
        <trans-unit id="d1513ef69753da579d30dff357ebb3c01e465563" translate="yes" xml:space="preserve">
          <source>Once your module is written, compile it to produce a shared library, according to the conventions of the underlying platform. Then place the shared library in a directory mentioned in &lt;code&gt;load-path&lt;/code&gt; (see &lt;a href=&quot;library-search#Library-Search&quot;&gt;Library Search&lt;/a&gt;), where Emacs will find it.</source>
          <target state="translated">모듈이 작성되면 기본 플랫폼의 규칙에 따라 컴파일하여 공유 라이브러리를 생성합니다. 그런 다음 공유 라이브러리를 &lt;code&gt;load-path&lt;/code&gt; ( &lt;a href=&quot;library-search#Library-Search&quot;&gt;라이브러리 검색&lt;/a&gt; 참조)에 언급 된 디렉토리에 배치하면 Emacs가 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3c0b70cb22f00da9b2ba81dbf3bf978932a071a" translate="yes" xml:space="preserve">
          <source>One &amp;lsquo;</source>
          <target state="translated">하나 '</target>
        </trans-unit>
        <trans-unit id="4adda958bb416b9b9ce93994e71859b6fceded90" translate="yes" xml:space="preserve">
          <source>One example of a case where this variable makes a difference is when the default font has no italic equivalent. With the default ordering, the &lt;code&gt;italic&lt;/code&gt; face will use a non-italic font that is similar to the default one. But if you put &lt;code&gt;:slant&lt;/code&gt; before &lt;code&gt;:height&lt;/code&gt;, the &lt;code&gt;italic&lt;/code&gt; face will use an italic font, even if its height is not quite right.</source>
          <target state="translated">이 변수가 차이를 만드는 한 가지 예는 기본 글꼴에 이탤릭체가없는 경우입니다. 기본 순서를 사용하면 &lt;code&gt;italic&lt;/code&gt; 은 기본 글꼴과 유사한 기울임 꼴이 아닌 글꼴을 사용합니다. 당신이 넣어하지만 &lt;code&gt;:slant&lt;/code&gt; 전에 &lt;code&gt;:height&lt;/code&gt; 의 &lt;code&gt;italic&lt;/code&gt; 얼굴은 높이가 꽤 괜찮없는 경우에도, 이탤릭 글꼴을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="577e046c059fefb7e07e716cb84ee3c1d1a8d0ea" translate="yes" xml:space="preserve">
          <source>One object can have multiple textual representations. For example, &amp;lsquo;</source>
          <target state="translated">하나의 객체는 여러 텍스트 표현을 가질 수 있습니다. 예 : '</target>
        </trans-unit>
        <trans-unit id="e131db88539c1a117d848bab11ab32a20ff4ae32" translate="yes" xml:space="preserve">
          <source>One of the effects of making a minor mode global is that the &lt;var&gt;mode&lt;/var&gt; variable becomes a customization variable. Toggling it through the Customize interface turns the mode on and off, and its value can be saved for future Emacs sessions (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Saving-Customizations.html#Saving-Customizations&quot;&gt;Saving Customizations&lt;/a&gt; in</source>
          <target state="translated">마이너 모드를 전역으로 만드는 효과 중 하나는 &lt;var&gt;mode&lt;/var&gt; 변수가 사용자 지정 변수가된다는 것입니다. 사용자 정의 인터페이스를 통해 토글 온 및 오프 모드를 전환하고, 그 가치는 미래 이맥스 세션 (참조 저장할 수 있습니다 &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Saving-Customizations.html#Saving-Customizations&quot;&gt;저장 사용자 정의를&lt;/a&gt; 에</target>
        </trans-unit>
        <trans-unit id="8145e40ecbe1251ccfc0d64cf4ef8a0311780a53" translate="yes" xml:space="preserve">
          <source>One of the effects of making a minor mode global is that the &lt;var&gt;mode&lt;/var&gt; variable becomes a customization variable. Toggling it through the Customize interface turns the mode on and off, and its value can be saved for future Emacs sessions (see &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/Saving-Customizations.html#Saving-Customizations&quot;&gt;Saving Customizations&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a45c275128e0b9c2732acf99d11b72a739cabbf7" translate="yes" xml:space="preserve">
          <source>One of the elements is &lt;code&gt;(acl . &lt;var&gt;acl&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;acl&lt;/var&gt; has the same form returned by &lt;code&gt;file-acl&lt;/code&gt;.</source>
          <target state="translated">요소 중 하나는 &lt;code&gt;(acl . &lt;var&gt;acl&lt;/var&gt;)&lt;/code&gt; 이며, 여기서 &lt;var&gt;acl&lt;/var&gt; 은 &lt;code&gt;file-acl&lt;/code&gt; 이 반환 한 것과 동일한 형식을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="33b9427a7425593acc13906a9fe5a0f436f2867b" translate="yes" xml:space="preserve">
          <source>One of the files in the content directory must be named</source>
          <target state="translated">콘텐츠 디렉터리에있는 파일 중 하나의 이름을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="889f4e481c60baff17ff497b3fc3a3ae3d75286d" translate="yes" xml:space="preserve">
          <source>One or more flag characters can appear immediately after the &amp;lsquo;</source>
          <target state="translated">하나 이상의 플래그 문자는 '</target>
        </trans-unit>
        <trans-unit id="b9aff7d2a1cda9fb1100f1f1c7d6d8ce23f3a07d" translate="yes" xml:space="preserve">
          <source>One possible consequence of this process is an infinite loop, in the event that a symbol&amp;rsquo;s function cell refers to the same symbol. Otherwise, we eventually obtain a non-symbol, which ought to be a function or other suitable object.</source>
          <target state="translated">이 프로세스의 한 가지 가능한 결과는 심볼의 기능 셀이 동일한 심볼을 참조하는 경우 무한 루프입니다. 그렇지 않으면 우리는 결국 함수 나 다른 적절한 객체가되어야하는 비 기호를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="2efc7bf28038f291b21bb7d6c5b6e4024d66a9f9" translate="yes" xml:space="preserve">
          <source>One potential reason for such a failure to instrument is that some macro definitions are not yet known to Emacs. To work around this, load the file which defines the function you are about to instrument.</source>
          <target state="translated">이러한 계측 실패의 한 가지 잠재적 인 이유는 일부 매크로 정의가 아직 Emacs에 알려지지 않았기 때문입니다. 이 문제를 해결하려면 계측하려는 기능을 정의하는 파일을로드하십시오.</target>
        </trans-unit>
        <trans-unit id="c73c9472ca68902783f9eff8fc7a9275e411bae6" translate="yes" xml:space="preserve">
          <source>One responsibility of &lt;var&gt;from-fn&lt;/var&gt; is to make sure that the beginning of the file no longer matches &lt;var&gt;regexp&lt;/var&gt;. Otherwise it is likely to get called again. Also, &lt;var&gt;from-fn&lt;/var&gt; must not involve buffers or files other than the one being decoded, otherwise the internal buffer used for formatting might be overwritten.</source>
          <target state="translated">&lt;var&gt;from-fn&lt;/var&gt; 의 한 가지 책임은 파일의 시작 부분이 더 이상 &lt;var&gt;regexp&lt;/var&gt; 와 일치하지 않도록하는 것 입니다. 그렇지 않으면 다시 호출 될 가능성이 있습니다. 또한 &lt;var&gt;from-fn&lt;/var&gt; 은 디코딩중인 버퍼 또는 파일 이외의 파일을 포함해서는 안됩니다. 그렇지 않으면 포맷에 사용 된 내부 버퍼를 덮어 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a512c4c508943629411341265b0a1b3580ada561" translate="yes" xml:space="preserve">
          <source>One special kind of side effect can&amp;rsquo;t be avoided: constructing Lisp objects. Almost all macro expansions include constructed lists; that is the whole point of most macros. This is usually safe; there is just one case where you must be careful: when the object you construct is part of a quoted constant in the macro expansion.</source>
          <target state="translated">한 가지 특별한 부작용은 피할 수 없습니다 : Lisp 객체를 생성하는 것입니다. 거의 모든 매크로 확장에는 구성된 목록이 포함됩니다. 이것이 대부분의 매크로의 요점입니다. 이것은 일반적으로 안전합니다. 주의해야 할 한 가지 경우가 있습니다. 생성 한 객체가 매크로 확장에서 인용 된 상수의 일부인 경우입니다.</target>
        </trans-unit>
        <trans-unit id="c55a9d4e3055cc50dcbf39304bdeafccb27e6553" translate="yes" xml:space="preserve">
          <source>One unusual thing about this command is that the entire line containing position &lt;var&gt;beg&lt;/var&gt;, and the entire line containing position &lt;var&gt;end&lt;/var&gt;, are included in the region sorted.</source>
          <target state="translated">이 명령에 대한 한 가지 특이한 점은 &lt;var&gt;beg&lt;/var&gt; 위치를 포함 하는 전체 줄과 &lt;var&gt;end&lt;/var&gt; 위치를 포함하는 전체 줄이 정렬 된 영역에 포함된다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a2d226d6e0986fd5ff1e62cb952a91648093c02f" translate="yes" xml:space="preserve">
          <source>One use for &lt;code&gt;image-flush&lt;/code&gt; is to tell Emacs about a change in an image file. If an image specification contains a &lt;code&gt;:file&lt;/code&gt; property, the image is cached based on the file&amp;rsquo;s contents when the image is first displayed. Even if the file subsequently changes, Emacs continues displaying the old version of the image. Calling &lt;code&gt;image-flush&lt;/code&gt; flushes the image from the cache, forcing Emacs to re-read the file the next time it needs to display that image.</source>
          <target state="translated">&lt;code&gt;image-flush&lt;/code&gt; 한 가지 용도 는 이미지 파일의 변경 사항을 Emacs에 알리는 것 입니다. 이미지 사양에 &lt;code&gt;:file&lt;/code&gt; 속성이 포함 된 경우 이미지가 처음 표시 될 때 파일의 내용을 기반으로 이미지가 캐시됩니다. 파일이 이후에 변경 되더라도 Emacs는 이전 버전의 이미지를 계속 표시합니다. &lt;code&gt;image-flush&lt;/code&gt; 를 호출 하면 캐시에서 이미지가 플러시 되어 다음에 해당 이미지를 표시해야 할 때 Emacs가 파일을 다시 읽도록합니다.</target>
        </trans-unit>
        <trans-unit id="6f05610b66d19812d3d46bdeffc2bf46fe230ffa" translate="yes" xml:space="preserve">
          <source>One use of &lt;code&gt;regexp-quote&lt;/code&gt; is to combine an exact string match with context described as a regular expression. For example, this searches for the string that is the value of &lt;var&gt;string&lt;/var&gt;, surrounded by whitespace:</source>
          <target state="translated">&lt;code&gt;regexp-quote&lt;/code&gt; 의 한 가지 용도 는 정확한 문자열 일치를 정규 표현식으로 설명 된 컨텍스트와 결합하는 것입니다. 예를 들어 다음은 공백으로 둘러싸인 &lt;var&gt;string&lt;/var&gt; 의 값인 문자열을 검색합니다 .</target>
        </trans-unit>
        <trans-unit id="6b443615f7088e219757f3ce2e0767b4fb5de64b" translate="yes" xml:space="preserve">
          <source>One use of focus redirection is for frames that don&amp;rsquo;t have minibuffers. These frames use minibuffers on other frames. Activating a minibuffer on another frame redirects focus to that frame. This puts the focus on the minibuffer&amp;rsquo;s frame, where it belongs, even though the mouse remains in the frame that activated the minibuffer.</source>
          <target state="translated">포커스 리디렉션의 한 가지 용도는 미니 버퍼가없는 프레임에 사용됩니다. 이러한 프레임은 다른 프레임에서 미니 버퍼를 사용합니다. 다른 프레임에서 미니 버퍼를 활성화하면 포커스가 해당 프레임으로 리디렉션됩니다. 마우스가 미니 버퍼를 활성화 한 프레임에 남아 있어도 미니 버퍼가 속한 프레임에 포커스를 둡니다.</target>
        </trans-unit>
        <trans-unit id="55ca5f8a1f3a2f9f4a1e3fefe222967bb4301ed6" translate="yes" xml:space="preserve">
          <source>One use of minor mode keymaps is to modify the behavior of certain self-inserting characters so that they do something else as well as self-insert. (Another way to customize &lt;code&gt;self-insert-command&lt;/code&gt; is through &lt;code&gt;post-self-insert-hook&lt;/code&gt;, see &lt;a href=&quot;commands-for-insertion#Commands-for-Insertion&quot;&gt;Commands for Insertion&lt;/a&gt;. Apart from this, the facilities for customizing &lt;code&gt;self-insert-command&lt;/code&gt; are limited to special cases, designed for abbrevs and Auto Fill mode. Do not try substituting your own definition of &lt;code&gt;self-insert-command&lt;/code&gt; for the standard one. The editor command loop handles this function specially.)</source>
          <target state="translated">부 모드 키맵의 한 가지 용도는 특정 자체 삽입 문자의 동작을 수정하여 자체 삽입뿐 아니라 다른 작업도 수행하도록하는 것입니다. ( &lt;code&gt;self-insert-command&lt;/code&gt; 을 사용자 정의하는 또 다른 방법 은 &lt;code&gt;post-self-insert-hook&lt;/code&gt; 을 사용하는 것입니다. &lt;a href=&quot;commands-for-insertion#Commands-for-Insertion&quot;&gt;삽입 명령을&lt;/a&gt; 참조하십시오 .이 외에도 &lt;code&gt;self-insert-command&lt;/code&gt; 를 사용자 정의하는 기능 은 약어 및 자동 채우기 용으로 설계된 특수한 경우로 제한됩니다. &lt;code&gt;self-insert-command&lt;/code&gt; 의 정의를 표준 명령으로 대체하지 마십시오 . 편집기 명령 루프는이 기능을 특별히 처리합니다.)</target>
        </trans-unit>
        <trans-unit id="964a845b7c3be261e46e6c16cfdd2b39ae693122" translate="yes" xml:space="preserve">
          <source>One use of this function is in preparation for defining a longer key that uses &lt;var&gt;key&lt;/var&gt; as a prefix&amp;mdash;which would not be allowed if &lt;var&gt;key&lt;/var&gt; has a non-prefix binding. For example:</source>
          <target state="translated">이 기능을 사용하는 이유 중 하나는 더 이상 키를 정의하기위한 준비입니다 용도의 &lt;var&gt;key&lt;/var&gt; 접두사-경우 허용되지 않을 것 같은 &lt;var&gt;key&lt;/var&gt; 바인딩이 아닌 접두사를 가지고가. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="992da344af8495da1bf5875640a42f02ebd76cdf" translate="yes" xml:space="preserve">
          <source>One use of this function is to define function keys on terminals that have downloadable function key definitions. For example, this is how (on certain terminals) to define function key 4 to move forward four characters (by transmitting the characters</source>
          <target state="translated">이 기능의 한 가지 용도는 다운로드 가능한 기능 키 정의가있는 터미널에서 기능 키를 정의하는 것입니다. 예를 들어, (특정 터미널에서) 기능 키 4를 정의하여 4 개의 문자를 앞으로 이동 (문자를 전송하여</target>
        </trans-unit>
        <trans-unit id="023abc72efceee06dfb7ea03706101194c813d2e" translate="yes" xml:space="preserve">
          <source>One use of this variable is for telling &lt;code&gt;x-popup-menu&lt;/code&gt; where to pop up a menu. It is also used internally by &lt;code&gt;y-or-n-p&lt;/code&gt; (see &lt;a href=&quot;yes_002dor_002dno-queries#Yes_002dor_002dNo-Queries&quot;&gt;Yes-or-No Queries&lt;/a&gt;).</source>
          <target state="translated">이 변수의 한 가지 용도는 &lt;code&gt;x-popup-menu&lt;/code&gt; 에 메뉴를 표시 할 위치를 알려주는 것입니다 . 또한 &lt;code&gt;y-or-n-p&lt;/code&gt; 의해 내부적으로 사용됩니다 ( &lt;a href=&quot;yes_002dor_002dno-queries#Yes_002dor_002dNo-Queries&quot;&gt;예-또는-아니오 쿼리 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="bde8277d79875f5ea95a8ec30aa3980302baf104" translate="yes" xml:space="preserve">
          <source>One way or another, these mechanisms specify a Lisp value for the spacing of each line. The value is a height spec, and it translates into a Lisp value as described above. However, in this case the numeric height value specifies the line spacing, rather than the line height.</source>
          <target state="translated">어떤 식 으로든 이러한 메커니즘은 각 줄의 간격에 대한 Lisp 값을 지정합니다. 값은 높이 사양이며 위에서 설명한대로 Lisp 값으로 변환됩니다. 그러나이 경우 숫자 높이 값은 줄 높이가 아닌 줄 간격을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="f712e3c7ea934966609bea4ea08c88d53b0d34d7" translate="yes" xml:space="preserve">
          <source>One way to avoid pathological cases like this is to think of &lt;code&gt;empty-object&lt;/code&gt; as a funny kind of constant, not as a memory allocation construct. You wouldn&amp;rsquo;t use &lt;code&gt;setcar&lt;/code&gt; on a constant such as &lt;code&gt;'(nil)&lt;/code&gt;, so naturally you won&amp;rsquo;t use it on &lt;code&gt;(empty-object)&lt;/code&gt; either.</source>
          <target state="translated">이와 같은 병리학적인 경우를 피하는 한 가지 방법은 &lt;code&gt;empty-object&lt;/code&gt; 를 메모리 할당 구조가 아닌 재미있는 종류의 상수로 생각하는 것입니다 . &lt;code&gt;'(nil)&lt;/code&gt; 과 같은 상수 에는 &lt;code&gt;setcar&lt;/code&gt; 를 사용하지 않으므로 당연히 &lt;code&gt;(empty-object)&lt;/code&gt; 사용하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="21005527907c627869027aeb58d2b47e207aa33d" translate="yes" xml:space="preserve">
          <source>One way to cope with circular structure is to set &lt;code&gt;print-length&lt;/code&gt; or &lt;code&gt;print-level&lt;/code&gt; to truncate the printing. Edebug does this for you; it binds &lt;code&gt;print-length&lt;/code&gt; and &lt;code&gt;print-level&lt;/code&gt; to the values of the variables &lt;code&gt;edebug-print-length&lt;/code&gt; and &lt;code&gt;edebug-print-level&lt;/code&gt; (so long as they have non-&lt;code&gt;nil&lt;/code&gt; values). See &lt;a href=&quot;output-variables#Output-Variables&quot;&gt;Output Variables&lt;/a&gt;.</source>
          <target state="translated">원형 구조에 대처하는 한 가지 방법은 &lt;code&gt;print-length&lt;/code&gt; 또는 &lt;code&gt;print-level&lt;/code&gt; 을 설정하여 인쇄를 자르는 것입니다. Edebug는이 작업을 수행합니다. 이는 결합 &lt;code&gt;print-length&lt;/code&gt; 와 &lt;code&gt;print-level&lt;/code&gt; 변수의 값에 &lt;code&gt;edebug-print-length&lt;/code&gt; 및 &lt;code&gt;edebug-print-level&lt;/code&gt; (그래서 그들이 비 가지고 &lt;code&gt;nil&lt;/code&gt; 값). &lt;a href=&quot;output-variables#Output-Variables&quot;&gt;출력 변수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fb79df4c6bc7c681333d9bd2d1fe18512e30d371" translate="yes" xml:space="preserve">
          <source>One way to ensure reliable rehighlighting of multiline Font Lock constructs is to put on them the text property &lt;code&gt;font-lock-multiline&lt;/code&gt;. It should be present and non-&lt;code&gt;nil&lt;/code&gt; for text that is part of a multiline construct.</source>
          <target state="translated">여러 줄 글꼴 잠금 구조를 안정적으로 다시 강조 표시하는 한 가지 방법은 텍스트 속성 &lt;code&gt;font-lock-multiline&lt;/code&gt; 을 추가하는 것 입니다. 여러 줄 구조의 일부인 텍스트에 대해서는 존재하고 &lt;code&gt;nil&lt;/code&gt; 이 아니 어야합니다 .</target>
        </trans-unit>
        <trans-unit id="c715d20a7533e9f52b8676dee0de643ff507bb6b" translate="yes" xml:space="preserve">
          <source>One way to increase the security of your packages is to &lt;em&gt;sign&lt;/em&gt; them using a cryptographic key. If you have generated a private/public gpg key pair, you can use gpg to sign the package like this:</source>
          <target state="translated">패키지의 보안을 강화하는 한 가지 방법 은 암호화 키를 사용하여 &lt;em&gt;서명&lt;/em&gt; 하는 것입니다. 개인 / 공개 gpg 키 쌍을 생성 한 경우 gpg를 사용하여 다음과 같이 패키지에 서명 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fbc2d56b429ee910d28dbf2fbd89ff2226fc991f" translate="yes" xml:space="preserve">
          <source>One way to represent a face is as a property list of attributes, like &lt;code&gt;(:foreground &quot;red&quot; :weight bold)&lt;/code&gt;. Such a list is called an &lt;em&gt;anonymous face&lt;/em&gt;. For example, you can assign an anonymous face as the value of the &lt;code&gt;face&lt;/code&gt; text property, and Emacs will display the underlying text with the specified attributes. See &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Special Properties&lt;/a&gt;.</source>
          <target state="translated">얼굴을 표현하는 한 가지 방법은 &lt;code&gt;(:foreground &quot;red&quot; :weight bold)&lt;/code&gt; 와 같은 속성의 속성 목록입니다 . 이러한 목록을 &lt;em&gt;익명의 얼굴&lt;/em&gt; 이라고합니다 . 예를 들어 익명의 얼굴을 &lt;code&gt;face&lt;/code&gt; 텍스트 속성 의 값으로 할당 할 수 있으며 Emacs는 지정된 속성을 가진 기본 텍스트를 표시합니다. &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;특수 속성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="85f792f34f1609454c8ad7752317553e8a6aea26" translate="yes" xml:space="preserve">
          <source>One way to use &lt;code&gt;catch&lt;/code&gt; and &lt;code&gt;throw&lt;/code&gt; is to exit from a doubly nested loop. (In most languages, this would be done with a &lt;code&gt;goto&lt;/code&gt;.) Here we compute &lt;code&gt;(foo &lt;var&gt;i&lt;/var&gt; &lt;var&gt;j&lt;/var&gt;)&lt;/code&gt; for &lt;var&gt;i&lt;/var&gt; and &lt;var&gt;j&lt;/var&gt; varying from 0 to 9:</source>
          <target state="translated">&lt;code&gt;catch&lt;/code&gt; and &lt;code&gt;throw&lt;/code&gt; 를 사용하는 한 가지 방법 은 이중 중첩 루프를 종료하는 것입니다. (대부분의 언어에서 이것은 &lt;code&gt;goto&lt;/code&gt; 로 수행됩니다 .) 여기서 우리 는 &lt;var&gt;i&lt;/var&gt; 와 &lt;var&gt;j&lt;/var&gt; 에 대해 0에서 9까지 다양한 &lt;code&gt;(foo &lt;var&gt;i&lt;/var&gt; &lt;var&gt;j&lt;/var&gt;)&lt;/code&gt; 를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="48d778b2ad99cdef9eebb6a0fb329935a9f7da52" translate="yes" xml:space="preserve">
          <source>One-dimensional arrays of &lt;code&gt;t&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 또는 &lt;code&gt;nil&lt;/code&gt; 의 1 차원 배열 .</target>
        </trans-unit>
        <trans-unit id="6073cf4225ea4cf9fd99b377fa082aad9eea6d61" translate="yes" xml:space="preserve">
          <source>One-dimensional arrays.</source>
          <target state="translated">1 차원 배열.</target>
        </trans-unit>
        <trans-unit id="be996260ce0e4df49d84c11ecb1d8434ceb9918f" translate="yes" xml:space="preserve">
          <source>One-dimensional sparse arrays indexed by characters.</source>
          <target state="translated">문자로 인덱싱 된 1 차원 희소 배열.</target>
        </trans-unit>
        <trans-unit id="ae88654faca91364a5a35b8017f9b11dd388a0bf" translate="yes" xml:space="preserve">
          <source>Only &lt;var&gt;body-form&lt;/var&gt; is protected by the &lt;code&gt;unwind-protect&lt;/code&gt;. If any of the &lt;var&gt;cleanup-forms&lt;/var&gt; themselves exits nonlocally (via a &lt;code&gt;throw&lt;/code&gt; or an error), &lt;code&gt;unwind-protect&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; guaranteed to evaluate the rest of them. If the failure of one of the &lt;var&gt;cleanup-forms&lt;/var&gt; has the potential to cause trouble, then protect it with another &lt;code&gt;unwind-protect&lt;/code&gt; around that form.</source>
          <target state="translated">만 &lt;var&gt;body-form&lt;/var&gt; 에 의해 보호됩니다 &lt;code&gt;unwind-protect&lt;/code&gt; . 의 (있는 경우) &lt;var&gt;cleanup-forms&lt;/var&gt; 자체가 nonlocally 종료 (A를 통해 &lt;code&gt;throw&lt;/code&gt; 또는 오류), &lt;code&gt;unwind-protect&lt;/code&gt; 되어 &lt;em&gt;있지&lt;/em&gt; 이들의 나머지 부분을 평가하기 위해 보장. &lt;var&gt;cleanup-forms&lt;/var&gt; 중 하나의 실패 로 인해 문제가 발생할 가능성이있는 경우 해당 양식 주변의 다른 &lt;code&gt;unwind-protect&lt;/code&gt; 방지 장치로 보호하십시오 .</target>
        </trans-unit>
        <trans-unit id="5ddbb81d5905d23be7a9282a488499d00d5db21e" translate="yes" xml:space="preserve">
          <source>Only available on macOS, if non-&lt;code&gt;nil&lt;/code&gt;, set the titlebar and toolbar to be transparent. This effectively sets the background color of both to match the Emacs background color.</source>
          <target state="translated">macOS에서만 사용할 수 있으며 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 제목 표시 줄과 도구 모음을 투명하게 설정합니다. 이것은 Emacs 배경색과 일치하도록 둘 다의 배경색을 효과적으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="18179e6d777e1c5274c1d80de143a1698c76c5dd" translate="yes" xml:space="preserve">
          <source>Only available on macOS, if set to &lt;code&gt;dark&lt;/code&gt; draw this frame&amp;rsquo;s window-system window using the &amp;ldquo;vibrant dark&amp;rdquo; theme, otherwise use the system default. The &amp;ldquo;vibrant dark&amp;rdquo; theme can be used to set the toolbar and scrollbars to a dark appearance when using an Emacs theme with a dark background.</source>
          <target state="translated">macOS에서만 사용할 수 있으며, &lt;code&gt;dark&lt;/code&gt; 설정 하면 &quot;진동 어두운&quot;테마를 사용하여이 프레임의 창 시스템 창을 그립니다. 그렇지 않으면 시스템 기본값을 사용합니다. 어두운 배경에 Emacs 테마를 사용할 때 &quot;생생한 어두운&quot;테마를 사용하여 도구 모음과 스크롤바를 어두운 모양으로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4e0867e177c2c0fb6455a0e2fbcd920632c9814" translate="yes" xml:space="preserve">
          <source>Only if creating a new frame fails, &lt;code&gt;display-buffer&lt;/code&gt; will apply the actions supplied by &lt;code&gt;display-buffer-fallback-action&lt;/code&gt; which means to again try reusing a window, popping up a new window and so on. A trivial way to make frame creation fail is supplied by the following form:</source>
          <target state="translated">새 프레임 생성이 실패한 경우에만 &lt;code&gt;display-buffer&lt;/code&gt; 는 &lt;code&gt;display-buffer-fallback-action&lt;/code&gt; 에서 제공하는 작업을 적용합니다. 즉, 창을 다시 사용하고 새 창을 띄우는 등의 작업 을 다시 시도합니다. 프레임 생성을 실패하게 만드는 간단한 방법은 다음 형식으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="586047e86826f6dbd9c9e2881cee476941126e1e" translate="yes" xml:space="preserve">
          <source>Only top-level values (arrays and objects) can be serialized to JSON. The subobjects within these top-level values can be of any type. Likewise, the parsing functions will only return vectors, hashtables, alists, and plists.</source>
          <target state="translated">최상위 값 (배열 및 개체) 만 JSON으로 직렬화 할 수 있습니다. 이러한 최상위 값 내의 하위 개체는 모든 유형이 될 수 있습니다. 마찬가지로 구문 분석 함수는 벡터, 해시 테이블, alist 및 plist 만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d7386c857a6085eb01544217b3270be05da5ce62" translate="yes" xml:space="preserve">
          <source>Open parenthesis characters: &amp;lsquo;</source>
          <target state="translated">여는 괄호 문자 : '</target>
        </trans-unit>
        <trans-unit id="7c1e62f5f482a805fbc3795b139cfba4a6ee67ba" translate="yes" xml:space="preserve">
          <source>Opening network connections.</source>
          <target state="translated">네트워크 연결을 여는 중입니다.</target>
        </trans-unit>
        <trans-unit id="8a38f5abc74dccf57ac90365fb1a9bb0148242a3" translate="yes" xml:space="preserve">
          <source>Operating System Environment</source>
          <target state="translated">운영 체제 환경</target>
        </trans-unit>
        <trans-unit id="47ccf7c0529a8c5659311c8f82bec6086b29bb6c" translate="yes" xml:space="preserve">
          <source>Operating System Interface</source>
          <target state="translated">운영 체제 인터페이스</target>
        </trans-unit>
        <trans-unit id="686c6069aa66b3b4e21a44c27c9586de497a2f96" translate="yes" xml:space="preserve">
          <source>Operating on X11 Keysyms</source>
          <target state="translated">X11 키심에서 작동</target>
        </trans-unit>
        <trans-unit id="1f124ca397e717abcc79b77c1f05d2b73214fbd7" translate="yes" xml:space="preserve">
          <source>Operating on key symbols for X Windows.</source>
          <target state="translated">X Windows의 키 기호에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="f100a2b248d1a840348b4d7eb2abbcfa1fd0b916" translate="yes" xml:space="preserve">
          <source>Operating on the special minibuffer windows.</source>
          <target state="translated">특수 미니 버퍼 창에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="30642cc8933c44209f3f574d7f685d3dbe69cad1" translate="yes" xml:space="preserve">
          <source>Operator Precedence Grammars</source>
          <target state="translated">연산자 우선 순위 문법</target>
        </trans-unit>
        <trans-unit id="9abbe311bb8d8a0022002079a7ed956ab53457b0" translate="yes" xml:space="preserve">
          <source>Operator precedence grammar is a very primitive technology for parsing compared to some of the more common techniques used in compilers. It has the following characteristics: its parsing power is very limited, and it is largely unable to detect syntax errors, but it has the advantage of being algorithmically efficient and able to parse forward just as well as backward. In practice that means that SMIE can use it for indentation based on backward parsing, that it can provide both &lt;code&gt;forward-sexp&lt;/code&gt; and &lt;code&gt;backward-sexp&lt;/code&gt; functionality, and that it will naturally work on syntactically incorrect code without any extra effort. The downside is that it also means that most programming languages cannot be parsed correctly using SMIE, at least not without resorting to some special tricks (see &lt;a href=&quot;smie-tricks#SMIE-Tricks&quot;&gt;SMIE Tricks&lt;/a&gt;).</source>
          <target state="translated">연산자 우선 순위 문법은 컴파일러에서 사용되는보다 일반적인 기술 중 일부에 비해 구문 분석을위한 매우 원시적 인 기술입니다. 다음과 같은 특징이 있습니다. 파싱 능력이 매우 제한적이며 구문 오류를 감지 할 수없는 경우가 많지만 알고리즘 적으로 효율적이고 앞뒤로 구문 분석 할 수 있다는 장점이 있습니다. 실제로 이는 SMIE가 역방향 구문 분석을 기반으로 들여 쓰기에 사용할 수 있고, &lt;code&gt;forward-sexp&lt;/code&gt; 및 &lt;code&gt;backward-sexp&lt;/code&gt; 기능을 모두 제공 할 수 있으며 , 추가 노력없이 구문 적으로 잘못된 코드에서 자연스럽게 작동 함을 의미합니다. 단점은 대부분의 프로그래밍 언어가 SMIE를 사용하여 올바르게 구문 분석 될 수 없다는 것입니다. 적어도 몇 가지 특별한 트릭에 의존하지 않으면&lt;a href=&quot;smie-tricks#SMIE-Tricks&quot;&gt;SMIE 트릭&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="433ecb082f2de86ea14497d016e6339cef126f75" translate="yes" xml:space="preserve">
          <source>Option variables for customizing Edebug.</source>
          <target state="translated">Edebug를 사용자 정의하기위한 옵션 변수.</target>
        </trans-unit>
        <trans-unit id="41725bd17665c6ac89cc5165603ca309d1ea2d7c" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;var&gt;family&lt;/var&gt; specified as symbol &lt;code&gt;ipv4&lt;/code&gt; or &lt;code&gt;ipv6&lt;/code&gt; restricts the returned information to IPv4 and IPv6 addresses respectively, independently of the value of &lt;var&gt;full&lt;/var&gt;. Specifying &lt;code&gt;ipv6&lt;/code&gt; when IPv6 support is not available will result in an error being signaled.</source>
          <target state="translated">기호 &lt;code&gt;ipv4&lt;/code&gt; 또는 &lt;code&gt;ipv6&lt;/code&gt; 으로 지정된 선택적 인수 &lt;var&gt;family&lt;/var&gt; 은 반환 된 정보를 &lt;var&gt;full&lt;/var&gt; 값에 관계없이 각각 IPv4 및 IPv6 주소로 제한합니다 . IPv6 지원을 사용할 수 없을 때 &lt;code&gt;ipv6&lt;/code&gt; 을 지정 하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b0205e865ebbb646fcce5e119e547b665d053edb" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;var&gt;full&lt;/var&gt; non-&lt;code&gt;nil&lt;/code&gt; means to instead return a list of one or more elements of the form &lt;code&gt;(&lt;var&gt;ifname&lt;/var&gt;&amp;nbsp;&lt;var&gt;addr&lt;/var&gt;&amp;nbsp;&lt;var&gt;bcast&lt;/var&gt;&amp;nbsp;&lt;var&gt;netmask&lt;/var&gt;)&lt;/code&gt;. &lt;var&gt;ifname&lt;/var&gt; is a non-unique string naming the interface. &lt;var&gt;addr&lt;/var&gt;, &lt;var&gt;bcast&lt;/var&gt;, and &lt;var&gt;netmask&lt;/var&gt; are vectors of integers detailing the IP address, broadcast address, and network mask.</source>
          <target state="translated">선택적 인수 &lt;var&gt;full&lt;/var&gt; non- &lt;code&gt;nil&lt;/code&gt; 은 대신 &lt;code&gt;(&lt;var&gt;ifname&lt;/var&gt;&amp;nbsp;&lt;var&gt;addr&lt;/var&gt;&amp;nbsp;&lt;var&gt;bcast&lt;/var&gt;&amp;nbsp;&lt;var&gt;netmask&lt;/var&gt;)&lt;/code&gt; 형식의 하나 이상의 요소 목록을 반환하는 것을 의미합니다 . &lt;var&gt;ifname&lt;/var&gt; 은 인터페이스 이름을 지정하는 고유하지 않은 문자열입니다. &lt;var&gt;addr&lt;/var&gt; , &lt;var&gt;bcast&lt;/var&gt; 및 &lt;var&gt;netmask&lt;/var&gt; 는 IP 주소, 브로드 캐스트 주소 및 네트워크 마스크를 자세히 설명하는 정수 벡터입니다.</target>
        </trans-unit>
        <trans-unit id="3ce281c8a118cd3ed61dcec4880e6886db816d03" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;var&gt;size&lt;/var&gt; non-&lt;code&gt;nil&lt;/code&gt; means to try swapping the sizes of &lt;var&gt;window-1&lt;/var&gt; and &lt;var&gt;window-2&lt;/var&gt; as well. A value of &lt;code&gt;height&lt;/code&gt; means to swap heights only, a value of &lt;code&gt;width&lt;/code&gt; means to swap widths only, while &lt;code&gt;t&lt;/code&gt; means to swap both widths and heights, if possible. Frames are not resized by this function.</source>
          <target state="translated">선택적 인자 &lt;var&gt;size&lt;/var&gt; non- &lt;code&gt;nil&lt;/code&gt; 은 &lt;var&gt;window-1&lt;/var&gt; 과 &lt;var&gt;window-2&lt;/var&gt; 의 크기를 바꾸는 것을 의미합니다 . &lt;code&gt;height&lt;/code&gt; 값은 높이 만 바꾸는 것을 의미하고, &lt;code&gt;width&lt;/code&gt; 값은 너비 만 바꾸는 것을 의미하며, &lt;code&gt;t&lt;/code&gt; 는 가능하면 너비와 높이를 모두 바꾸는 것을 의미합니다. 이 기능으로 프레임 크기가 조정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ce411d37922de190b756838011d8fc8421d7f336" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;var&gt;suffix&lt;/var&gt; is a string to be displayed after &lt;var&gt;reporter&lt;/var&gt;&amp;rsquo;s main message and progress text. If &lt;var&gt;reporter&lt;/var&gt; is a non-numerical reporter, then &lt;var&gt;value&lt;/var&gt; should be &lt;code&gt;nil&lt;/code&gt;, or a string to use instead of &lt;var&gt;suffix&lt;/var&gt;.</source>
          <target state="translated">선택적 인수 &lt;var&gt;suffix&lt;/var&gt; 는 &lt;var&gt;reporter&lt;/var&gt; 의 기본 메시지와 진행 텍스트 뒤에 표시되는 문자열 입니다. 경우 &lt;var&gt;reporter&lt;/var&gt; 아닌 숫자 기자, 다음 &lt;var&gt;value&lt;/var&gt; 해야 &lt;code&gt;nil&lt;/code&gt; , 또는 문자열 대신 사용하는 &lt;var&gt;suffix&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="a305373f5ab4c8179b157e7348094ea4ce59f3c4" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;var&gt;type&lt;/var&gt; specifies the type of the edges to return: &lt;code&gt;outer-edges&lt;/code&gt; means to return the outer edges of &lt;var&gt;frame&lt;/var&gt;, &lt;code&gt;native-edges&lt;/code&gt; (or &lt;code&gt;nil&lt;/code&gt;) means to return its native edges and &lt;code&gt;inner-edges&lt;/code&gt; means to return its inner edges.</source>
          <target state="translated">선택적 인수의 &lt;var&gt;type&lt;/var&gt; 을 지정 에지의 종류 반환 : &lt;code&gt;outer-edges&lt;/code&gt; 수단의 외측 에지 반환 &lt;var&gt;frame&lt;/var&gt; , &lt;code&gt;native-edges&lt;/code&gt; (또는 &lt;code&gt;nil&lt;/code&gt; 네이티브 가장자리 반환) 수단 &lt;code&gt;inner-edges&lt;/code&gt; 의 내부 가장자리를 반환하는 수단.</target>
        </trans-unit>
        <trans-unit id="b389bdb03281d5aed10905c4bf13e4c443b15b78" translate="yes" xml:space="preserve">
          <source>Options for how input is processed.</source>
          <target state="translated">입력 처리 방법에 대한 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="676740d3b53e425b59a5051ef0cf6614000f6153" translate="yes" xml:space="preserve">
          <source>Ordinarily the first argument is a list &lt;code&gt;(&lt;var&gt;second&lt;/var&gt; &lt;var&gt;minute&lt;/var&gt; &lt;var&gt;hour&lt;/var&gt; &lt;var&gt;day&lt;/var&gt; &lt;var&gt;month&lt;/var&gt;
&lt;var&gt;year&lt;/var&gt; &lt;var&gt;ignored&lt;/var&gt; &lt;var&gt;dst&lt;/var&gt; &lt;var&gt;zone&lt;/var&gt;)&lt;/code&gt; that specifies a decoded time in the style of &lt;code&gt;decode-time&lt;/code&gt;, so that &lt;code&gt;(encode-time (decode-time ...))&lt;/code&gt; works. For the meanings of these list members, see the table under &lt;code&gt;decode-time&lt;/code&gt;.</source>
          <target state="translated">일반적으로 첫 번째 인수는 &lt;code&gt;(encode-time (decode-time ...))&lt;/code&gt; 작동 할 수 있도록 &lt;code&gt;decode-time&lt;/code&gt; 된 시간을 decode-time 스타일로 지정 하는 목록 &lt;code&gt;(&lt;var&gt;second&lt;/var&gt; &lt;var&gt;minute&lt;/var&gt; &lt;var&gt;hour&lt;/var&gt; &lt;var&gt;day&lt;/var&gt; &lt;var&gt;month&lt;/var&gt; &lt;var&gt;year&lt;/var&gt; &lt;var&gt;ignored&lt;/var&gt; &lt;var&gt;dst&lt;/var&gt; &lt;var&gt;zone&lt;/var&gt;)&lt;/code&gt; 입니다 . 이러한 목록 멤버의 의미는 &lt;code&gt;decode-time&lt;/code&gt; 아래의 표를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4c6d5310c1a644ae25978f7caf49bad39c82c0ef" translate="yes" xml:space="preserve">
          <source>Ordinarily, &lt;code&gt;fill-individual-paragraphs&lt;/code&gt; regards each change in indentation as starting a new paragraph. If &lt;code&gt;fill-individual-varying-indent&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then only separator lines separate paragraphs. That mode can handle indented paragraphs with additional indentation on the first line.</source>
          <target state="translated">일반적으로 &lt;code&gt;fill-individual-paragraphs&lt;/code&gt; 는 들여 쓰기의 각 변경 사항을 새 단락을 시작하는 것으로 간주합니다. 경우 &lt;code&gt;fill-individual-varying-indent&lt;/code&gt; 비이다 &lt;code&gt;nil&lt;/code&gt; , 만 분리 라인 단락을 분리한다. 이 모드는 첫 줄에 추가 들여 쓰기가있는 들여 쓰기 된 단락을 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="375f3605b67b9e5591350d037468627ffa4a6244" translate="yes" xml:space="preserve">
          <source>Ordinarily, &lt;code&gt;rename-buffer&lt;/code&gt; signals an error if &lt;var&gt;newname&lt;/var&gt; is already in use. However, if &lt;var&gt;unique&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it modifies &lt;var&gt;newname&lt;/var&gt; to make a name that is not in use. Interactively, you can make &lt;var&gt;unique&lt;/var&gt; non-&lt;code&gt;nil&lt;/code&gt; with a numeric prefix argument. (This is how the command &lt;code&gt;rename-uniquely&lt;/code&gt; is implemented.)</source>
          <target state="translated">일반적으로 &lt;code&gt;rename-buffer&lt;/code&gt; 는 &lt;var&gt;newname&lt;/var&gt; 이 이미 사용중인 경우 오류 신호를 보냅니다 . 그러나 &lt;var&gt;unique&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 &lt;var&gt;newname&lt;/var&gt; 을 수정 하여 사용하지 않는 이름으로 만듭니다. 대화식 으로 숫자 접두사 인수를 사용하여 &lt;var&gt;unique&lt;/var&gt; 비 &lt;code&gt;nil&lt;/code&gt; 을 만들 수 있습니다 . (이것은 &lt;code&gt;rename-uniquely&lt;/code&gt; 명령 이 구현되는 방법입니다.)</target>
        </trans-unit>
        <trans-unit id="49604b10b3ce6fc4e228c33eaf4c9eabebbafb54" translate="yes" xml:space="preserve">
          <source>Ordinarily, &lt;code&gt;unload-feature&lt;/code&gt; refuses to unload a library on which other loaded libraries depend. (A library &lt;var&gt;a&lt;/var&gt; depends on library &lt;var&gt;b&lt;/var&gt; if &lt;var&gt;a&lt;/var&gt; contains a &lt;code&gt;require&lt;/code&gt; for &lt;var&gt;b&lt;/var&gt;.) If the optional argument &lt;var&gt;force&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, dependencies are ignored and you can unload any library.</source>
          <target state="translated">일반적으로 &lt;code&gt;unload-feature&lt;/code&gt; 는 로드 된 다른 라이브러리가 의존하는 라이브러리의 언로드를 거부합니다. (A 라이브러리 &lt;var&gt;a&lt;/var&gt; 는 라이브러리에 따라 &lt;var&gt;b&lt;/var&gt; 경우 &lt;var&gt;a&lt;/var&gt; A가 포함되어 &lt;code&gt;require&lt;/code&gt; 에 대한 &lt;var&gt;b&lt;/var&gt; .) 선택적 인수의 경우 &lt;var&gt;force&lt;/var&gt; 아닌 것입니다 &lt;code&gt;nil&lt;/code&gt; 의존성을 무시하고, 당신이 어떤 라이브러리를 언로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1bfbb016c1886fa701a54a40747d69fbc68c3719" translate="yes" xml:space="preserve">
          <source>Ordinarily, functions that operate on text or move point do not care whether the text is invisible, they process invisible characters and visible characters alike. The user-level line motion commands, such as &lt;code&gt;next-line&lt;/code&gt;, &lt;code&gt;previous-line&lt;/code&gt;, ignore invisible newlines if &lt;code&gt;line-move-ignore-invisible&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt; (the default), i.e., behave like these invisible newlines didn&amp;rsquo;t exist in the buffer, but only because they are explicitly programmed to do so.</source>
          <target state="translated">일반적으로 텍스트 또는 이동 지점에서 작동하는 함수는 텍스트가 보이지 않는지 여부에 상관없이 보이지 않는 문자와 보이는 문자를 모두 처리합니다. &lt;code&gt;next-line&lt;/code&gt; , &lt;code&gt;previous-line&lt;/code&gt; 과 같은 사용자 수준의 라인 모션 명령은 &lt;code&gt;line-move-ignore-invisible&lt;/code&gt; 이 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 (기본값) 보이지 않는 줄 바꿈을 무시합니다 . 즉, 이러한 보이지 않는 줄 바꿈이 버퍼에 명시 적으로 프로그래밍되어 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="2931150327a52dd944296ebe55052fed18d6a2ee" translate="yes" xml:space="preserve">
          <source>Ordinarily, this function deletes all existing frames not listed in &lt;var&gt;configuration&lt;/var&gt;. But if &lt;var&gt;nodelete&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the unwanted frames are iconified instead.</source>
          <target state="translated">일반적으로이 기능은 &lt;var&gt;configuration&lt;/var&gt; 에 나열되지 않은 기존 프레임을 모두 삭제 합니다 . 그러나 &lt;var&gt;nodelete&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 원하지 않는 프레임이 대신 아이콘 화됩니다.</target>
        </trans-unit>
        <trans-unit id="87302b912cb01c9639fa44884323306db9210741" translate="yes" xml:space="preserve">
          <source>Ordinary Lisp variables can be assigned any value that is a valid Lisp object. However, certain Lisp variables are not defined in Lisp, but in C. Most of these variables are defined in the C code using &lt;code&gt;DEFVAR_LISP&lt;/code&gt;. Like variables defined in Lisp, these can take on any value. However, some variables are defined using &lt;code&gt;DEFVAR_INT&lt;/code&gt; or &lt;code&gt;DEFVAR_BOOL&lt;/code&gt;. See &lt;a href=&quot;writing-emacs-primitives#Defining-Lisp-variables-in-C&quot;&gt;Writing Emacs Primitives&lt;/a&gt;, in particular the description of functions of the type &lt;code&gt;syms_of_&lt;var&gt;filename&lt;/var&gt;&lt;/code&gt;, for a brief discussion of the C implementation.</source>
          <target state="translated">일반 Lisp 변수에는 유효한 Lisp 개체 인 모든 값을 할당 할 수 있습니다. 그러나 특정 Lisp 변수는 Lisp에서 정의되지 않고 C로 정의됩니다. 이러한 변수의 대부분은 &lt;code&gt;DEFVAR_LISP&lt;/code&gt; 를 사용하여 C 코드에서 정의됩니다 . Lisp에 정의 된 변수와 마찬가지로 이러한 변수는 모든 값을 가질 수 있습니다. 그러나 일부 변수는 &lt;code&gt;DEFVAR_INT&lt;/code&gt; 또는 &lt;code&gt;DEFVAR_BOOL&lt;/code&gt; 을 사용하여 정의됩니다 . C 구현에 대한 간략한 설명은 특히 &lt;code&gt;syms_of_&lt;var&gt;filename&lt;/var&gt;&lt;/code&gt; &lt;var&gt;filename&lt;/var&gt; 유형의 함수에 대한 설명 인 &lt;a href=&quot;writing-emacs-primitives#Defining-Lisp-variables-in-C&quot;&gt;Writing Emacs Primitives를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9aa2f051f923703f2af383ff67fd2ab1b21d7049" translate="yes" xml:space="preserve">
          <source>Ordinary characters &amp;ndash; keys with symbols on them.</source>
          <target state="translated">일반 문자 &amp;ndash; 기호가있는 키.</target>
        </trans-unit>
        <trans-unit id="ea6b2ec77fa1c5f39197cbc7ea3990c82fb9841d" translate="yes" xml:space="preserve">
          <source>Ordinary evaluation of a macro call finishes by evaluating the expansion. However, the macro expansion is not necessarily evaluated right away, or at all, because other programs also expand macro calls, and they may or may not evaluate the expansions.</source>
          <target state="translated">매크로 호출의 일반적인 평가는 확장을 평가하여 완료됩니다. 그러나 다른 프로그램도 매크로 호출을 확장하고 확장을 평가할 수도 있고 평가하지 않을 수도 있기 때문에 매크로 확장이 반드시 즉시 평가되거나 전혀 평가되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="08b529b0be834d360e6ea5bc83de04138368fecc" translate="yes" xml:space="preserve">
          <source>Ordinary quitting gives no information about why the program was looping. To get more information, you can set the variable &lt;code&gt;debug-on-quit&lt;/code&gt; to non-&lt;code&gt;nil&lt;/code&gt;. Once you have the debugger running in the middle of the infinite loop, you can proceed from the debugger using the stepping commands. If you step through the entire loop, you may get enough information to solve the problem.</source>
          <target state="translated">일반 종료는 프로그램이 왜 루핑되었는지에 대한 정보를 제공하지 않습니다. 자세한 정보를 얻으려면 &lt;code&gt;debug-on-quit&lt;/code&gt; 변수 를 non - &lt;code&gt;nil&lt;/code&gt; 로 설정할 수 있습니다 . 무한 루프 중간에서 디버거를 실행하면 스테핑 명령을 사용하여 디버거에서 진행할 수 있습니다. 전체 루프를 진행하면 문제를 해결하는 데 충분한 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34d1e835211103e55315f8950b093575e40b4d28" translate="yes" xml:space="preserve">
          <source>Other Character Modifier Bits</source>
          <target state="translated">기타 문자 수정 자 비트</target>
        </trans-unit>
        <trans-unit id="33198adc02f29100fbe001bcd24af108bb8d17c8" translate="yes" xml:space="preserve">
          <source>Other Display Specifications</source>
          <target state="translated">기타 디스플레이 사양</target>
        </trans-unit>
        <trans-unit id="e1b5fab73cfe1a3afaa115ab03f0edad57c69f7f" translate="yes" xml:space="preserve">
          <source>Other Features of Argument Lists</source>
          <target state="translated">인수 목록의 기타 기능</target>
        </trans-unit>
        <trans-unit id="4e097fdc9bb03d4937b671db92b45a0f360cd315" translate="yes" xml:space="preserve">
          <source>Other Font Lock Variables</source>
          <target state="translated">기타 글꼴 잠금 변수</target>
        </trans-unit>
        <trans-unit id="46737ad394242fbdb99171fff4fda522659876cd" translate="yes" xml:space="preserve">
          <source>Other Hash Table Functions</source>
          <target state="translated">기타 해시 테이블 함수</target>
        </trans-unit>
        <trans-unit id="56044b82f8d646d772974c14d2a91bcbcbcb3ce7" translate="yes" xml:space="preserve">
          <source>Other Image Types</source>
          <target state="translated">다른 이미지 유형</target>
        </trans-unit>
        <trans-unit id="edfdae8d79c7493898f253dfe960e84840b69477" translate="yes" xml:space="preserve">
          <source>Other Lisp objects are &lt;em&gt;mutable&lt;/em&gt;: it is safe to change their values via destructive operations involving side effects. For example, an existing marker can be changed by moving the marker to point to somewhere else.</source>
          <target state="translated">다른 Lisp 객체는 &lt;em&gt;변경 가능합니다&lt;/em&gt; . 부작용과 관련된 파괴적인 작업을 통해 값을 변경하는 것이 안전합니다. 예를 들어 마커를 다른 곳으로 이동하여 기존 마커를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="041cab119371080f5c14fa74fa5fa41d2e6a8bf9" translate="yes" xml:space="preserve">
          <source>Other Topics Related to Functions</source>
          <target state="translated">기능과 관련된 기타 주제</target>
        </trans-unit>
        <trans-unit id="6eb08d88c80caa45384446348816e55ba7c955ae" translate="yes" xml:space="preserve">
          <source>Other aspects of tooltip display are controlled by several customizable settings; see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Tooltips.html#Tooltips&quot;&gt;Tooltips&lt;/a&gt; in</source>
          <target state="translated">도구 설명 표시의 다른 측면은 여러 사용자 정의 가능한 설정으로 제어됩니다. 참조 &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Tooltips.html#Tooltips&quot;&gt;툴팁&lt;/a&gt; 에</target>
        </trans-unit>
        <trans-unit id="2807813fd14e72f66d18c3e9088c2eaa37295f37" translate="yes" xml:space="preserve">
          <source>Other aspects of tooltip display are controlled by several customizable settings; see &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/Tooltips.html#Tooltips&quot;&gt;Tooltips&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a64c877816cb35a6c766c7fbbe33ffb08e05d25" translate="yes" xml:space="preserve">
          <source>Other definition types:</source>
          <target state="translated">다른 정의 유형 :</target>
        </trans-unit>
        <trans-unit id="21ad92f8be5dc4e33dd7afb9682a8336e5b8df9f" translate="yes" xml:space="preserve">
          <source>Other events the system can generate.</source>
          <target state="translated">시스템이 생성 할 수있는 기타 이벤트.</target>
        </trans-unit>
        <trans-unit id="d9542df9ae63b6d508bd2e2ee21aec4ef7962dc9" translate="yes" xml:space="preserve">
          <source>Other frequently used commands are</source>
          <target state="translated">자주 사용되는 다른 명령은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="db54d46555d1f340a37db3a33c9204c8396d6479" translate="yes" xml:space="preserve">
          <source>Other functions to compare with this one include &lt;code&gt;make-vector&lt;/code&gt; (see &lt;a href=&quot;vectors#Vectors&quot;&gt;Vectors&lt;/a&gt;) and &lt;code&gt;make-list&lt;/code&gt; (see &lt;a href=&quot;building-lists#Building-Lists&quot;&gt;Building Lists&lt;/a&gt;).</source>
          <target state="translated">이 함수와 비교할 다른 함수로는 &lt;code&gt;make-vector&lt;/code&gt; ( &lt;a href=&quot;vectors#Vectors&quot;&gt;Vectors&lt;/a&gt; 참조 ) 및 &lt;code&gt;make-list&lt;/code&gt; ( &lt;a href=&quot;building-lists#Building-Lists&quot;&gt;Building Lists&lt;/a&gt; 참조 )가 있습니다.</target>
        </trans-unit>
        <trans-unit id="408167f431dbe022874b25fe0cbeecaf0058b490" translate="yes" xml:space="preserve">
          <source>Other functions you can use to create buffers include &lt;code&gt;with-output-to-temp-buffer&lt;/code&gt; (see &lt;a href=&quot;temporary-displays#Temporary-Displays&quot;&gt;Temporary Displays&lt;/a&gt;) and &lt;code&gt;create-file-buffer&lt;/code&gt; (see &lt;a href=&quot;visiting-files#Visiting-Files&quot;&gt;Visiting Files&lt;/a&gt;). Starting a subprocess can also create a buffer (see &lt;a href=&quot;processes#Processes&quot;&gt;Processes&lt;/a&gt;).</source>
          <target state="translated">버퍼를 생성하는 데 사용할 수있는 다른 함수로는 &lt;code&gt;with-output-to-temp-buffer&lt;/code&gt; ( &lt;a href=&quot;temporary-displays#Temporary-Displays&quot;&gt;임시 디스플레이&lt;/a&gt; 참조 ) 및 &lt;code&gt;create-file-buffer&lt;/code&gt; ( &lt;a href=&quot;visiting-files#Visiting-Files&quot;&gt;파일 방문&lt;/a&gt; 참조 )가 있습니다. 하위 프로세스를 시작하면 버퍼가 생성 될 수도 있습니다 ( &lt;a href=&quot;processes#Processes&quot;&gt;프로세스&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="12da01fa29e6553cd0e8cb48e03d6be151f33875" translate="yes" xml:space="preserve">
          <source>Other keyboard character events cannot fit in a string. This includes keyboard events in the range of 128 to 255.</source>
          <target state="translated">다른 키보드 문자 이벤트는 문자열에 들어갈 수 없습니다. 여기에는 128 ~ 255 범위의 키보드 이벤트가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="4ac0b6dbdd8cbd1b63c08a470ab7011f7b3c910a" translate="yes" xml:space="preserve">
          <source>Other primitives to look inside of window configurations would make sense, but are not implemented because we did not need them. See the file</source>
          <target state="translated">창 구성 내부를 살펴 보는 다른 프리미티브는 의미가 있지만 필요하지 않았기 때문에 구현되지 않았습니다. 파일보기</target>
        </trans-unit>
        <trans-unit id="f2e96a7c2811cdfc73c1ef4d1bd1a2c29ec6dda7" translate="yes" xml:space="preserve">
          <source>Other programs can also use custom printing; see</source>
          <target state="translated">다른 프로그램에서도 사용자 정의 인쇄를 사용할 수 있습니다. 보다</target>
        </trans-unit>
        <trans-unit id="0656cfe9687d5b1c6eec51fbeb7667af045fb347" translate="yes" xml:space="preserve">
          <source>Other quoting constructs include &lt;code&gt;function&lt;/code&gt; (see &lt;a href=&quot;anonymous-functions#Anonymous-Functions&quot;&gt;Anonymous Functions&lt;/a&gt;), which causes an anonymous lambda expression written in Lisp to be compiled, and &amp;lsquo;</source>
          <target state="translated">다른 인용 구문에는 Lisp로 작성된 익명 람다식이 컴파일되도록하는 &lt;code&gt;function&lt;/code&gt; ( &lt;a href=&quot;anonymous-functions#Anonymous-Functions&quot;&gt;Anonymous Functions&lt;/a&gt; 참조 )과 '</target>
        </trans-unit>
        <trans-unit id="d862e1f98dfca98bea09cf7215fbefad08c4cef4" translate="yes" xml:space="preserve">
          <source>Other times, after careful consideration you may conclude that those conflicts are not serious and simply resolve them via the &lt;var&gt;resolvers&lt;/var&gt; argument of &lt;code&gt;smie-bnf-&amp;gt;prec2&lt;/code&gt;. Usually this is because the grammar is simply ambiguous: the conflict does not affect the set of programs described by the grammar, but only the way those programs are parsed. This is typically the case for separators and associative infix operators, where you want to add a resolver like &lt;code&gt;'((assoc &quot;|&quot;))&lt;/code&gt;. Another case where this can happen is for the classic &lt;em&gt;dangling else&lt;/em&gt; problem, where you will use &lt;code&gt;'((assoc
&quot;else&quot; &quot;then&quot;))&lt;/code&gt;. It can also happen for cases where the conflict is real and cannot really be resolved, but it is unlikely to pose a problem in practice.</source>
          <target state="translated">다른 경우에는 신중한 고려 후 이러한 충돌이 심각하지 않다고 결론을 내리고 &lt;code&gt;smie-bnf-&amp;gt;prec2&lt;/code&gt; 의 &lt;var&gt;resolvers&lt;/var&gt; 인수를 통해 간단히 해결할 수 있습니다 . 일반적으로 이것은 문법이 모호하기 때문입니다. 충돌은 문법에 설명 된 프로그램 집합에 영향을주지 않고 해당 프로그램이 구문 분석되는 방식에만 영향을줍니다. 이는 일반적으로 &lt;code&gt;'((assoc &quot;|&quot;))&lt;/code&gt; 와 같은 해석기를 추가하려는 분리 기호 및 연관 중위 연산자의 경우입니다 . 이런 일이 발생할 수있는 또 다른 경우는 &lt;code&gt;'((assoc &quot;else&quot; &quot;then&quot;))&lt;/code&gt; 사용 하는 전형적인 &lt;em&gt;dangling else&lt;/em&gt; 문제의 경우입니다.&lt;em&gt;&lt;/em&gt;. 갈등이 실제적이고 실제로 해결할 수없는 경우에도 발생할 수 있지만 실제로는 문제를 일으키지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="4957b132ab51bc30771f521b4940cb71793014c9" translate="yes" xml:space="preserve">
          <source>Other useful tools for debugging input and output problems are the dribble file (see &lt;a href=&quot;terminal-input#Terminal-Input&quot;&gt;Terminal Input&lt;/a&gt;) and the &lt;code&gt;open-termscript&lt;/code&gt; function (see &lt;a href=&quot;terminal-output#Terminal-Output&quot;&gt;Terminal Output&lt;/a&gt;).</source>
          <target state="translated">입력 및 출력 문제를 디버깅하는 데 유용한 다른 도구로는 드리블 파일 ( &lt;a href=&quot;terminal-input#Terminal-Input&quot;&gt;터미널 입력&lt;/a&gt; 참조 )과 &lt;code&gt;open-termscript&lt;/code&gt; 함수 ( &lt;a href=&quot;terminal-output#Terminal-Output&quot;&gt;터미널 출력&lt;/a&gt; 참조 )가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a49240e9e249989689d2ce97e9d81c517eb880e2" translate="yes" xml:space="preserve">
          <source>Other value</source>
          <target state="translated">기타 가치</target>
        </trans-unit>
        <trans-unit id="f3fdcd50495da9607d64876c8b19f3585d001e97" translate="yes" xml:space="preserve">
          <source>Otherwise the function &lt;code&gt;call-process&lt;/code&gt; does no redisplay, and the results become visible on the screen only when Emacs redisplays that buffer in the normal course of events.</source>
          <target state="translated">그렇지 않으면 함수 &lt;code&gt;call-process&lt;/code&gt; 가 다시 표시되지 않으며 Emacs가 정상적인 이벤트 과정에서 해당 버퍼를 다시 표시 할 때만 결과가 화면에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e5cf2c68d7f5c24121fcd7006c95c362d16d9910" translate="yes" xml:space="preserve">
          <source>Otherwise the value should be an alist that specifies which fringe indicators to display and where. Each element of the alist should have the form &lt;code&gt;(&lt;var&gt;indicator&lt;/var&gt; . &lt;var&gt;position&lt;/var&gt;)&lt;/code&gt;. Here, &lt;var&gt;indicator&lt;/var&gt; is one of &lt;code&gt;top&lt;/code&gt;, &lt;code&gt;bottom&lt;/code&gt;, &lt;code&gt;up&lt;/code&gt;, &lt;code&gt;down&lt;/code&gt;, and &lt;code&gt;t&lt;/code&gt; (which covers all the icons not yet specified), while &lt;var&gt;position&lt;/var&gt; is one of &lt;code&gt;left&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt; and &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">그렇지 않으면 값은 표시 할 프린지 표시기와 위치를 지정하는 alist 여야합니다. alist의 각 요소는 폼 있어야 &lt;code&gt;(&lt;var&gt;indicator&lt;/var&gt; . &lt;var&gt;position&lt;/var&gt;)&lt;/code&gt; . 여기서 &lt;var&gt;indicator&lt;/var&gt; 는 &lt;code&gt;top&lt;/code&gt; , &lt;code&gt;bottom&lt;/code&gt; , &lt;code&gt;up&lt;/code&gt; , &lt;code&gt;down&lt;/code&gt; , &lt;code&gt;t&lt;/code&gt; (아직 지정되지 않은 모든 아이콘을 포함) 중 하나 이고 &lt;var&gt;position&lt;/var&gt; 은 &lt;code&gt;left&lt;/code&gt; , &lt;code&gt;right&lt;/code&gt; 및 &lt;code&gt;nil&lt;/code&gt; 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="6cd6099948cb8e952f2e06ed3844cf9915b36c22" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;var&gt;window&lt;/var&gt; was previously used for displaying other buffers (see &lt;a href=&quot;window-history#Window-History&quot;&gt;Window History&lt;/a&gt;), the most recent buffer in that history will be displayed. In either case, if &lt;var&gt;window&lt;/var&gt; is not deleted, its &lt;code&gt;quit-restore&lt;/code&gt; parameter is reset to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">그렇지 않으면 &lt;var&gt;window&lt;/var&gt; 이전에 다른 버퍼를 표시하는 데 사용 된 경우 ( &lt;a href=&quot;window-history#Window-History&quot;&gt;창 기록&lt;/a&gt; 참조 ) 해당 기록의 가장 최근 버퍼가 표시됩니다. 두 경우 모두 &lt;var&gt;window&lt;/var&gt; 삭제되지 않으면 &lt;code&gt;quit-restore&lt;/code&gt; 매개 변수가 &lt;code&gt;nil&lt;/code&gt; 로 재설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="b22d99af3628f670cc53b3c236b49d8671be213f" translate="yes" xml:space="preserve">
          <source>Otherwise, if the indentation function in &lt;code&gt;indent-line-function&lt;/code&gt; is &lt;code&gt;indent-to-left-margin&lt;/code&gt; (a trivial command that inserts a tab character), or if the variable &lt;code&gt;tab-always-indent&lt;/code&gt; specifies that a tab character ought to be inserted (see below), then it inserts a tab character.</source>
          <target state="translated">그렇지 않으면 &lt;code&gt;indent-line-function&lt;/code&gt; 의 &lt;code&gt;indent-to-left-margin&lt;/code&gt; 함수 가 indent-to-left-margin (탭 문자를 삽입하는 간단한 명령)이거나 &lt;code&gt;tab-always-indent&lt;/code&gt; 변수 가 탭 문자를 삽입해야한다고 지정하는 경우 ( 아래 참조) 탭 문자를 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="4a70357a80ea185af667a6cf9db2f85e272ad161" translate="yes" xml:space="preserve">
          <source>Otherwise, it indents the current line; this is done by calling the function in &lt;code&gt;indent-line-function&lt;/code&gt;. If the line is already indented, and the value of &lt;code&gt;tab-always-indent&lt;/code&gt; is &lt;code&gt;complete&lt;/code&gt; (see below), it tries completing the text at point.</source>
          <target state="translated">그렇지 않으면 현재 줄을 들여 씁니다. &lt;code&gt;indent-line-function&lt;/code&gt; 에서 함수를 호출하면 됩니다 . 줄이 이미 들여 쓰기되어 있고 &lt;code&gt;tab-always-indent&lt;/code&gt; 값 이 &lt;code&gt;complete&lt;/code&gt; (아래 참조) 해당 지점에서 텍스트 완성을 시도합니다.</target>
        </trans-unit>
        <trans-unit id="f0728e46990b904a5fc71835f81206fdedceb327" translate="yes" xml:space="preserve">
          <source>Otherwise, the base location should be a directory name. In this case, Emacs retrieves packages from this archive via ordinary file access. Such local archives are mainly useful for testing.</source>
          <target state="translated">그렇지 않으면 기본 위치는 디렉토리 이름이어야합니다. 이 경우 Emacs는 일반 파일 액세스를 통해이 아카이브에서 패키지를 검색합니다. 이러한 로컬 아카이브는 주로 테스트에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="45a47ab7c8110b367a5eb7d10e05ec778824df4d" translate="yes" xml:space="preserve">
          <source>Otherwise, the file modes of &lt;var&gt;newname&lt;/var&gt; are left unchanged if it is an existing file, and set to those of &lt;var&gt;oldname&lt;/var&gt;, masked by the default file permissions (see &lt;code&gt;set-default-file-modes&lt;/code&gt; below), if &lt;var&gt;newname&lt;/var&gt; is to be newly created. The Access Control List or SELinux context are not copied over in either case.</source>
          <target state="translated">그렇지 않으면 &lt;var&gt;newname&lt;/var&gt; 의 파일 모드 는 기존 파일 인 경우 변경되지 않고 그대로 유지 되고 &lt;var&gt;newname&lt;/var&gt; 이 새로 생성 되는 경우 기본 파일 권한 (아래 &lt;code&gt;set-default-file-modes&lt;/code&gt; 참조) 으로 마스크 된 &lt;var&gt;oldname&lt;/var&gt; 의모드로 설정 됩니다 . 액세스 제어 목록 또는 SELinux 컨텍스트는 두 경우 모두 복사되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="81d57dfe0afd7a0985d57a78533c79c5a914182c" translate="yes" xml:space="preserve">
          <source>Otherwise, the symbol should be a predicate. The predicate is called with the argument, and if the predicate returns &lt;code&gt;nil&lt;/code&gt;, the specification fails and the argument is not instrumented.</source>
          <target state="translated">그렇지 않으면 기호는 술어 여야합니다. 조건자는 인수와 함께 호출되며 조건자가 &lt;code&gt;nil&lt;/code&gt; 을 반환 하면 사양이 실패하고 인수가 계측되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="763f06232ee2847cc0f578d2a2ffd866f636432a" translate="yes" xml:space="preserve">
          <source>Otherwise, the value must be a list of regular expressions. Then a scalable font is enabled for use if its name matches any regular expression in the list. For example,</source>
          <target state="translated">그렇지 않으면 값은 정규식 목록이어야합니다. 그런 다음 이름이 목록의 정규 표현식과 일치하면 확장 가능한 글꼴을 사용할 수 있습니다. 예를 들면</target>
        </trans-unit>
        <trans-unit id="c8f0909271c68b7b8449d51302ffcf15bff72083" translate="yes" xml:space="preserve">
          <source>Otherwise, the value should be a function which returns a list of the above form when called with no arguments.</source>
          <target state="translated">그렇지 않은 경우 값은 인수없이 호출 될 때 위 형식의 목록을 반환하는 함수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="14d051441dd1704941ec3ffbfe4f559120510bb1" translate="yes" xml:space="preserve">
          <source>Otherwise, this returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">그렇지 않으면 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="575a546ff3b142ba0fac4a6250e6ac440f035d5e" translate="yes" xml:space="preserve">
          <source>Our simple sample function, &lt;code&gt;(lambda (a b c) (+ a b c))&lt;/code&gt;, specifies three argument variables, so it must be called with three arguments: if you try to call it with only two arguments or four arguments, you get a &lt;code&gt;wrong-number-of-arguments&lt;/code&gt; error (see &lt;a href=&quot;errors#Errors&quot;&gt;Errors&lt;/a&gt;).</source>
          <target state="translated">우리의 간단한 예제 함수, &lt;code&gt;(lambda (a b c) (+ a b c))&lt;/code&gt; , 지정하는 세 개의 인수 변수, 세 개의 인수로 호출해야하므로 : 만 두 개의 인수 또는 네 개의 인수를 호출하려고하면, 당신이 얻을 &lt;code&gt;wrong-number-of-arguments&lt;/code&gt; 오류 ( &lt;a href=&quot;errors#Errors&quot;&gt;오류&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="a9852d0d719ff08733d222f566af473ea8319ac5" translate="yes" xml:space="preserve">
          <source>Outer Border</source>
          <target state="translated">외부 테두리</target>
        </trans-unit>
        <trans-unit id="d03df9879e63c94d1ef1ef625db82f7c6086fd99" translate="yes" xml:space="preserve">
          <source>Outer Frame</source>
          <target state="translated">외부 프레임</target>
        </trans-unit>
        <trans-unit id="d25d9ab5e677c4a9d400b4025bd92a3b5bab6708" translate="yes" xml:space="preserve">
          <source>Outer borders are never shown on text terminal frames and on frames generated by GTK+ routines. On MS-Windows, the outer border is emulated with the help of a one pixel wide external border. Non-toolkit builds on X allow to change the color of the outer border by setting the &lt;code&gt;border-color&lt;/code&gt; frame parameter (see &lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;Layout Parameters&lt;/a&gt;).</source>
          <target state="translated">텍스트 터미널 프레임과 GTK + 루틴에 의해 생성 된 프레임에는 외부 테두리가 표시되지 않습니다. MS-Windows에서 외부 테두리는 1 픽셀 너비의 외부 테두리를 사용하여 에뮬레이션됩니다. X를 기반으로하는 툴킷이 아닌 빌드에서는 &lt;code&gt;border-color&lt;/code&gt; 프레임 매개 변수 를 설정하여 외부 테두리의 색상을 변경할 수 있습니다 ( &lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;레이아웃 매개 변수&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="b23b7fca5f6573328ef2d805a7e0260cd5710efd" translate="yes" xml:space="preserve">
          <source>Output Functions</source>
          <target state="translated">출력 기능</target>
        </trans-unit>
        <trans-unit id="9a91268a8670899c3fa6018e379c6499b8b7af3e" translate="yes" xml:space="preserve">
          <source>Output Streams</source>
          <target state="translated">출력 스트림</target>
        </trans-unit>
        <trans-unit id="c32e9bc6a6bca97190de9cf86b1d5bfe5eb2f34a" translate="yes" xml:space="preserve">
          <source>Output from a subprocess can arrive only while Emacs is waiting: when reading terminal input (see the function &lt;code&gt;waiting-for-user-input-p&lt;/code&gt;), in &lt;code&gt;sit-for&lt;/code&gt; and &lt;code&gt;sleep-for&lt;/code&gt; (see &lt;a href=&quot;waiting#Waiting&quot;&gt;Waiting&lt;/a&gt;), in &lt;code&gt;accept-process-output&lt;/code&gt; (see &lt;a href=&quot;accepting-output#Accepting-Output&quot;&gt;Accepting Output&lt;/a&gt;), and in functions which send data to processes (see &lt;a href=&quot;input-to-processes#Input-to-Processes&quot;&gt;Input to Processes&lt;/a&gt;). This minimizes the problem of timing errors that usually plague parallel programming. For example, you can safely create a process and only then specify its buffer or filter function; no output can arrive before you finish, if the code in between does not call any primitive that waits.</source>
          <target state="translated">하위 프로세스의 출력은 Emacs가 대기하는 동안에 만 도착할 수 있습니다. 터미널 입력을 읽을 때 ( &lt;code&gt;waiting-for-user-input-p&lt;/code&gt; 함수 참조 ), &lt;code&gt;sit-for&lt;/code&gt; 및 &lt;code&gt;sleep-for&lt;/code&gt; ( &lt;a href=&quot;waiting#Waiting&quot;&gt;Waiting&lt;/a&gt; 참조 ), &lt;code&gt;accept-process-output&lt;/code&gt; 에서 ( &lt;a href=&quot;accepting-output#Accepting-Output&quot;&gt;출력 수락&lt;/a&gt; 참조 ), 데이터를 프로세스에 보내는 함수 (프로세스에 대한 &lt;a href=&quot;input-to-processes#Input-to-Processes&quot;&gt;입력&lt;/a&gt; 참조 ). 이것은 일반적으로 병렬 프로그래밍을 괴롭히는 타이밍 오류의 문제를 최소화합니다. 예를 들어, 안전하게 프로세스를 생성 한 다음 버퍼 또는 필터 기능을 지정할 수 있습니다. 중간 코드가 대기하는 프리미티브를 호출하지 않으면 완료하기 전에 출력이 도착할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="21c758cdd849bd8a6c5c89059360afc09cd26de1" translate="yes" xml:space="preserve">
          <source>Output from asynchronous subprocesses normally arrives only while Emacs is waiting for some sort of external event, such as elapsed time or terminal input. Occasionally it is useful in a Lisp program to explicitly permit output to arrive at a specific point, or even to wait until output arrives from a process.</source>
          <target state="translated">비동기 하위 프로세스의 출력은 일반적으로 Emacs가 경과 시간이나 터미널 입력과 같은 일종의 외부 이벤트를 기다리는 동안에 만 도착합니다. 때로는 출력이 특정 지점에 도달하도록 명시 적으로 허용하거나 프로세스에서 출력이 도착할 때까지 기다리는 것이 Lisp 프로그램에서 유용합니다.</target>
        </trans-unit>
        <trans-unit id="0b9ca3340cc6c5af5f85b890299ce5ced2b68445" translate="yes" xml:space="preserve">
          <source>Output of messages into the</source>
          <target state="translated">메시지 출력</target>
        </trans-unit>
        <trans-unit id="8c784b59ac07f59605bca80bc6385a0c8abe5d2b" translate="yes" xml:space="preserve">
          <source>Output trace information on function calls and returns.</source>
          <target state="translated">함수 호출 및 반환에 대한 추적 정보를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="e4053b393b6a34936a44a25f539116ecb913583a" translate="yes" xml:space="preserve">
          <source>Outside Emacs, characters can be represented in many different encodings, such as ISO-8859-1, GB-2312, Big-5, etc. Emacs converts between these external encodings and its internal representation, as appropriate, when it reads text into a buffer or a string, or when it writes text to a disk file or passes it to some other process.</source>
          <target state="translated">Emacs 외부에서 문자는 ISO-8859-1, GB-2312, Big-5 등과 같은 다양한 인코딩으로 표현 될 수 있습니다. Emacs는 텍스트를 버퍼 또는 문자열 또는 디스크 파일에 텍스트를 쓰거나 다른 프로세스로 전달할 때.</target>
        </trans-unit>
        <trans-unit id="c0a2a08afab0fbd40ca04201e1206a333c99a403" translate="yes" xml:space="preserve">
          <source>Outside of Emacs, on systems with job control, the stop character (usually</source>
          <target state="translated">Emacs 외부, 작업 제어 기능이있는 시스템에서 중지 문자 (일반적으로</target>
        </trans-unit>
        <trans-unit id="b22b6e787ba475871fd62e316803a0a0753ded2f" translate="yes" xml:space="preserve">
          <source>Over void parts of the window (parts that do not correspond to any of the buffer contents), the mouse pointer usually uses the &lt;code&gt;arrow&lt;/code&gt; style, but you can specify a different style (one of those above) by setting &lt;code&gt;void-text-area-pointer&lt;/code&gt;.</source>
          <target state="translated">창의 빈 부분 (버퍼 내용에 해당하지 않는 부분) 위에 마우스 포인터는 일반적으로 &lt;code&gt;arrow&lt;/code&gt; 스타일을 사용하지만 &lt;code&gt;void-text-area-pointer&lt;/code&gt; 설정하여 다른 스타일 (위의 스타일 중 하나)을 지정할 수 있습니다. 포인터 .</target>
        </trans-unit>
        <trans-unit id="0fea430e693a45386a3c9636b829f4fd78379194" translate="yes" xml:space="preserve">
          <source>Overall, the key-value pairs passed to &lt;var&gt;function&lt;/var&gt; describe all the values stored in &lt;var&gt;char-table&lt;/var&gt;.</source>
          <target state="translated">전반적으로 &lt;var&gt;function&lt;/var&gt; 에 전달 된 키-값 쌍 은 &lt;var&gt;char-table&lt;/var&gt; 에 저장된 모든 값을 설명 합니다 .</target>
        </trans-unit>
        <trans-unit id="c67eb8bae9c49b877d15564d28cb90029ac13ef6" translate="yes" xml:space="preserve">
          <source>Overlay Properties</source>
          <target state="translated">오버레이 속성</target>
        </trans-unit>
        <trans-unit id="7e2d14eedf83ae2cc686557be0c0dade27cbfcb8" translate="yes" xml:space="preserve">
          <source>Overlay Type</source>
          <target state="translated">오버레이 유형</target>
        </trans-unit>
        <trans-unit id="4e8e813f097ac9fdf229d20b7105e0cc57cfc922" translate="yes" xml:space="preserve">
          <source>Overlay properties are like text properties in that the properties that alter how a character is displayed can come from either source. But in most respects they are different. See &lt;a href=&quot;text-properties#Text-Properties&quot;&gt;Text Properties&lt;/a&gt;, for comparison.</source>
          <target state="translated">오버레이 속성은 문자가 표시되는 방식을 변경하는 속성이 어느 소스에서나 올 수 있다는 점에서 텍스트 속성과 같습니다. 그러나 대부분의 측면에서 그들은 다릅니다. 비교를 위해 &lt;a href=&quot;text-properties#Text-Properties&quot;&gt;텍스트 속성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="30f888d222b77006610001ff65a62036e76c8b9f" translate="yes" xml:space="preserve">
          <source>Overlays</source>
          <target state="translated">Overlays</target>
        </trans-unit>
        <trans-unit id="7436ded961ede3d7e72f8b002fd2f760f034b992" translate="yes" xml:space="preserve">
          <source>Overlays also support the &lt;code&gt;modification-hooks&lt;/code&gt; property, but the details are somewhat different (see &lt;a href=&quot;overlay-properties#Overlay-Properties&quot;&gt;Overlay Properties&lt;/a&gt;).</source>
          <target state="translated">오버레이는 또한 modify &lt;code&gt;modification-hooks&lt;/code&gt; 속성을 지원 하지만 세부 사항은 약간 다릅니다 ( &lt;a href=&quot;overlay-properties#Overlay-Properties&quot;&gt;오버레이 속성&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="38346ff2dbbd0c10b491d604ab1d0f5bf067809c" translate="yes" xml:space="preserve">
          <source>Overriding syntax with text properties.</source>
          <target state="translated">텍스트 속성으로 구문을 재정의합니다.</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="3b314bcbaf594e58e02b7f1ac94d0a07d164ad50" translate="yes" xml:space="preserve">
          <source>Overview of Markers</source>
          <target state="translated">마커 개요</target>
        </trans-unit>
        <trans-unit id="e5dff67285e4f2b89cea9a5461f21bbf12d615e1" translate="yes" xml:space="preserve">
          <source>Overview of customizing Font Lock.</source>
          <target state="translated">글꼴 잠금 사용자 지정 개요.</target>
        </trans-unit>
        <trans-unit id="48001e2fa21457daa7eb4268da77364c19623e16" translate="yes" xml:space="preserve">
          <source>Overview of mouse events.</source>
          <target state="translated">마우스 이벤트 개요.</target>
        </trans-unit>
        <trans-unit id="f42cdff5bec245ffb3bc5a0b0105f795984699c8" translate="yes" xml:space="preserve">
          <source>Overview of streams, reading and printing.</source>
          <target state="translated">스트림, 읽기 및 인쇄 개요.</target>
        </trans-unit>
        <trans-unit id="511993d3c99719e38a6779073019dacd7178ddb9" translate="yes" xml:space="preserve">
          <source>P</source>
          <target state="translated">P</target>
        </trans-unit>
        <trans-unit id="d613d88cb2d86f484f6f82d44ac1fc60722abe20" translate="yes" xml:space="preserve">
          <source>PDF</source>
          <target state="translated">PDF</target>
        </trans-unit>
        <trans-unit id="1d7fd5d567d57918b31b5a2025c0ead430339e0b" translate="yes" xml:space="preserve">
          <source>PF1</source>
          <target state="translated">PF1</target>
        </trans-unit>
        <trans-unit id="dde57e820d65c87a0777da46aba7cd35a0c8436a" translate="yes" xml:space="preserve">
          <source>PID</source>
          <target state="translated">PID</target>
        </trans-unit>
        <trans-unit id="0c95dc6163ff0d09e82f44e7c50db7ad6b089bf3" translate="yes" xml:space="preserve">
          <source>PM</source>
          <target state="translated">PM</target>
        </trans-unit>
        <trans-unit id="70fe60b7dfe0837f2c69677bfef128c134937b16" translate="yes" xml:space="preserve">
          <source>PNG</source>
          <target state="translated">PNG</target>
        </trans-unit>
        <trans-unit id="74235b074241ce94a5e09f007b23a0ca401ea696" translate="yes" xml:space="preserve">
          <source>POSIX Regular Expression Searching</source>
          <target state="translated">POSIX 정규식 검색</target>
        </trans-unit>
        <trans-unit id="871ee878f58ebcf07fad71fd2bcebbda6088639b" translate="yes" xml:space="preserve">
          <source>POSIX specifies several environment variables that can affect how Emacs behaves. Any environment variable whose name consists entirely of uppercase ASCII letters, digits, and the underscore may affect the internal behavior of Emacs. Emacs uses several such variables, e.g., &lt;code&gt;EMACSLOADPATH&lt;/code&gt;. See &lt;a href=&quot;library-search#Library-Search&quot;&gt;Library Search&lt;/a&gt;. On some platforms some environment variables (e.g., &lt;code&gt;PATH&lt;/code&gt;, &lt;code&gt;POSIXLY_CORRECT&lt;/code&gt;, &lt;code&gt;SHELL&lt;/code&gt;, &lt;code&gt;TMPDIR&lt;/code&gt;) need to have properly-configured values in order to get standard behavior for any utility Emacs might invoke. Even seemingly-benign variables like &lt;code&gt;TZ&lt;/code&gt; may have security implications. See &lt;a href=&quot;system-environment#System-Environment&quot;&gt;System Environment&lt;/a&gt;.</source>
          <target state="translated">POSIX는 Emacs의 작동 방식에 영향을 줄 수있는 여러 환경 변수를 지정합니다. 이름이 ASCII 대문자, 숫자 및 밑줄로만 구성된 환경 변수는 Emacs의 내부 동작에 영향을 미칠 수 있습니다. Emacs는 예를 들어 &lt;code&gt;EMACSLOADPATH&lt;/code&gt; 와 같은 여러 변수를 사용합니다 . &lt;a href=&quot;library-search#Library-Search&quot;&gt;도서관 검색을&lt;/a&gt; 참조하십시오 . 일부 플랫폼에서 일부 환경 변수 (예 : &lt;code&gt;PATH&lt;/code&gt; , &lt;code&gt;POSIXLY_CORRECT&lt;/code&gt; , &lt;code&gt;SHELL&lt;/code&gt; , &lt;code&gt;TMPDIR&lt;/code&gt; )는 Emacs가 호출 할 수있는 모든 유틸리티에 대한 표준 동작을 얻기 위해 적절하게 구성된 값을 가져야합니다. &lt;code&gt;TZ&lt;/code&gt; 와 같이 겉으로보기에 좋은 변수조차도 보안에 영향을 미칠 수 있습니다. &lt;a href=&quot;system-environment#System-Environment&quot;&gt;시스템 환경을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="31021705d55f66068349f6ead54a6f4f1f1f4e1c" translate="yes" xml:space="preserve">
          <source>Package-Requires</source>
          <target state="translated">Package-Requires</target>
        </trans-unit>
        <trans-unit id="400112f99c45dae97ae81ee287e883c5967448d7" translate="yes" xml:space="preserve">
          <source>Package-Version</source>
          <target state="translated">Package-Version</target>
        </trans-unit>
        <trans-unit id="c26ef24c1e9c01425e91a34b0caa85ab70d66bf6" translate="yes" xml:space="preserve">
          <source>Packages distributed as part of Emacs that use the &lt;code&gt;:package-version&lt;/code&gt; keyword must also update the &lt;code&gt;customize-package-emacs-version-alist&lt;/code&gt; variable.</source>
          <target state="translated">&lt;code&gt;:package-version&lt;/code&gt; 키워드 를 사용하는 Emacs의 일부로 배포 된 패키지 는 &lt;code&gt;customize-package-emacs-version-alist&lt;/code&gt; 변수 도 업데이트해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3a39b68c35be609fae3db651a70893a29f102145" translate="yes" xml:space="preserve">
          <source>Packaging</source>
          <target state="translated">Packaging</target>
        </trans-unit>
        <trans-unit id="42f9009cd9572c10d5a27ab040ba2ba3d71640ce" translate="yes" xml:space="preserve">
          <source>Packaging Basics</source>
          <target state="translated">포장 기본 사항</target>
        </trans-unit>
        <trans-unit id="e0fb56429e1a2ef765c166a971fbafb2df17fb78" translate="yes" xml:space="preserve">
          <source>Packing and Unpacking Byte Arrays</source>
          <target state="translated">바이트 배열 압축 및 압축 풀기</target>
        </trans-unit>
        <trans-unit id="7cba3e212dcc3d05c7ed8450a9553450544ee41d" translate="yes" xml:space="preserve">
          <source>PageDown</source>
          <target state="translated">PageDown</target>
        </trans-unit>
        <trans-unit id="2e2bbfe16d99367325be3ba50291408aefa81595" translate="yes" xml:space="preserve">
          <source>Paired delimiters: &amp;lsquo;</source>
          <target state="translated">쌍을 이루는 구분 기호 : '</target>
        </trans-unit>
        <trans-unit id="d4c7c2e3ad59ecdbc81f52c2333acc0ab45fc3f5" translate="yes" xml:space="preserve">
          <source>Pairs of characters are compared according to their character codes. Keep in mind that lower case letters have higher numeric values in the</source>
          <target state="translated">문자 쌍은 문자 코드에 따라 비교됩니다. 소문자는 더 높은 숫자 값을가집니다.</target>
        </trans-unit>
        <trans-unit id="2836a2cd0203ab3c4a413cfd2f0b910b3a2b2fef" translate="yes" xml:space="preserve">
          <source>Parameters common for all frames on terminal.</source>
          <target state="translated">터미널의 모든 프레임에 공통적 인 매개 변수입니다.</target>
        </trans-unit>
        <trans-unit id="82045ada54eb55bca7be07c13568a28bcd4565bf" translate="yes" xml:space="preserve">
          <source>Parameters describing the X- and Y-offsets of a frame are always measured in pixels. For a normal, non-child frame they specify the frame&amp;rsquo;s outer position (see &lt;a href=&quot;frame-geometry#Frame-Geometry&quot;&gt;Frame Geometry&lt;/a&gt;) relative to its display&amp;rsquo;s origin. For a child frame (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;) they specify the frame&amp;rsquo;s outer position relative to the native position of the frame&amp;rsquo;s parent frame. (Note that none of these parameters is meaningful on TTY frames.)</source>
          <target state="translated">프레임의 X 및 Y 오프셋을 설명하는 매개 변수는 항상 픽셀 단위로 측정됩니다. 자식이 아닌 일반 프레임의 경우 디스플레이 원점을 기준으로 프레임의 외부 위치 ( &lt;a href=&quot;frame-geometry#Frame-Geometry&quot;&gt;프레임 지오메트리&lt;/a&gt; 참조 ) 를 지정합니다 . 아이 프레임 (참조 &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;아이 프레임을&lt;/a&gt; 그들이 프레임의 상위 프레임의 기본 위치로 프레임의 외부 위치를 지정합니다). (이러한 매개 변수는 TTY 프레임에서 의미가 없습니다.)</target>
        </trans-unit>
        <trans-unit id="6fe4da0442db9ec376fd1ebd0885e7871dd6c06a" translate="yes" xml:space="preserve">
          <source>Parameters for interacting with other frames.</source>
          <target state="translated">다른 프레임과 상호 작용하기위한 매개 변수입니다.</target>
        </trans-unit>
        <trans-unit id="187e29395efb81d6e368498d4c21b83faa4f6bac" translate="yes" xml:space="preserve">
          <source>Parameters for resizing and moving frames with the mouse.</source>
          <target state="translated">마우스로 프레임 크기 조정 및 이동을위한 매개 변수입니다.</target>
        </trans-unit>
        <trans-unit id="3304283cc7ef5bd20c4b8b92ab9f7d659a1d933a" translate="yes" xml:space="preserve">
          <source>Parameters that affect parsing.</source>
          <target state="translated">구문 분석에 영향을 미치는 매개 변수입니다.</target>
        </trans-unit>
        <trans-unit id="662b563f3e8a80a489f1f7aa600b993494c4ca80" translate="yes" xml:space="preserve">
          <source>Parameters that are fundamental.</source>
          <target state="translated">기본적인 매개 변수.</target>
        </trans-unit>
        <trans-unit id="71dcb10469ca71f255f80878d6bb08653414646f" translate="yes" xml:space="preserve">
          <source>Parameters to Control Parsing</source>
          <target state="translated">구문 분석을 제어하는 ​​매개 변수</target>
        </trans-unit>
        <trans-unit id="3a77d88b486083a5b1a286e032cc2eaf602cab89" translate="yes" xml:space="preserve">
          <source>Parent mode for buffers containing tabulated data.</source>
          <target state="translated">표로 작성된 데이터를 포함하는 버퍼의 상위 모드입니다.</target>
        </trans-unit>
        <trans-unit id="00e169811424fee10d949efd728dc5985c0c3f1b" translate="yes" xml:space="preserve">
          <source>Parent type: &lt;code&gt;array&lt;/code&gt;.</source>
          <target state="translated">상위 유형 : &lt;code&gt;array&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc475e11afc91bfdb5091ef734af47c9e9ec4c73" translate="yes" xml:space="preserve">
          <source>Parent type: &lt;code&gt;list&lt;/code&gt;.</source>
          <target state="translated">상위 유형 : &lt;code&gt;list&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f98d45fa291377ce2d003ec40640eeb0e4c79445" translate="yes" xml:space="preserve">
          <source>Parent type: &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">상위 유형 : &lt;code&gt;number&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="defc0b42f93cf65435dd3de8a8247bacb70982ad" translate="yes" xml:space="preserve">
          <source>Parent type: &lt;code&gt;sequence&lt;/code&gt;.</source>
          <target state="translated">상위 유형 : &lt;code&gt;sequence&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1b04c0c36b344236da631ede7b83372f26428b9" translate="yes" xml:space="preserve">
          <source>Parent type: &lt;code&gt;symbol&lt;/code&gt;</source>
          <target state="translated">상위 유형 : &lt;code&gt;symbol&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7a33d7f2f11c1fed9edd1a0648e4921a4b929017" translate="yes" xml:space="preserve">
          <source>Parent windows do not display buffers, and play little role in display except to shape their child windows. Emacs Lisp programs cannot directly manipulate parent windows; they operate on the windows at the leaves of the tree, which actually display buffers.</source>
          <target state="translated">부모 창은 버퍼를 표시하지 않으며 자식 창 모양을 제외하고는 표시에서 거의 역할을하지 않습니다. Emacs Lisp 프로그램은 부모 창을 직접 조작 할 수 없습니다. 그들은 실제로 버퍼를 표시하는 나무 잎의 창에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="a9a6581c08789385ed2a0f325a688a832347f188" translate="yes" xml:space="preserve">
          <source>Parser State</source>
          <target state="translated">파서 상태</target>
        </trans-unit>
        <trans-unit id="4526a4b5852177789cf8e9bfecfe9da2131c54cb" translate="yes" xml:space="preserve">
          <source>Parsing Expressions</source>
          <target state="translated">식 구문 분석</target>
        </trans-unit>
        <trans-unit id="e231765095ab882fb7fcf938cb7f6e8c8c4b17f6" translate="yes" xml:space="preserve">
          <source>Parsing HTML and XML</source>
          <target state="translated">HTML 및 XML 구문 분석</target>
        </trans-unit>
        <trans-unit id="fe6bf59025bd0e2925b6d89834e3acc681649e86" translate="yes" xml:space="preserve">
          <source>Parsing HTML and XML.</source>
          <target state="translated">HTML 및 XML 구문 분석.</target>
        </trans-unit>
        <trans-unit id="08eb2ab878002b2ff0551a7f614ba8a4ce7a1b19" translate="yes" xml:space="preserve">
          <source>Parsing across a specified region.</source>
          <target state="translated">지정된 지역에서 구문 분석.</target>
        </trans-unit>
        <trans-unit id="f40cea5e85407269571363df9bd9391ce3f4ad7b" translate="yes" xml:space="preserve">
          <source>Parsing and Formatting Times</source>
          <target state="translated">시간 구문 분석 및 서식 지정</target>
        </trans-unit>
        <trans-unit id="ac97cfccea0017cf98319b0ca0948a055efe585f" translate="yes" xml:space="preserve">
          <source>Parsing and generating JSON values</source>
          <target state="translated">JSON 값 구문 분석 및 생성</target>
        </trans-unit>
        <trans-unit id="d9c9a717935cc6b02f547040191d6f2545e876ed" translate="yes" xml:space="preserve">
          <source>Parsing and generating JSON values.</source>
          <target state="translated">JSON 값 구문 분석 및 생성.</target>
        </trans-unit>
        <trans-unit id="5217da08a22ae64804bc400d2407ec040403c3c7" translate="yes" xml:space="preserve">
          <source>Parsing balanced expressions using the syntax table.</source>
          <target state="translated">구문 테이블을 사용하여 균형 잡힌 식을 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="cfd676e977daa56fd9d54f7c8b9c4143d00aec36" translate="yes" xml:space="preserve">
          <source>Parsing geometry specifications.</source>
          <target state="translated">기하학 사양을 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="094f3d7cfff68518244aec1c04b390842b32aced" translate="yes" xml:space="preserve">
          <source>Particular properties with special meanings.</source>
          <target state="translated">특별한 의미를 가진 특정 속성.</target>
        </trans-unit>
        <trans-unit id="7bdf4b7194fa08f8c2706fdc986660b700d98bb5" translate="yes" xml:space="preserve">
          <source>Parts of words in human languages. These are typically used in variable and command names in programs. All upper- and lower-case letters, and the digits, are typically word constituents.</source>
          <target state="translated">인간 언어로 된 단어의 일부. 이들은 일반적으로 프로그램의 변수 및 명령 이름에 사용됩니다. 모든 대문자 및 소문자와 숫자는 일반적으로 단어 구성 요소입니다.</target>
        </trans-unit>
        <trans-unit id="3fe618d6f369040b19cdcd8393043d5b040f5577" translate="yes" xml:space="preserve">
          <source>Pattern-Matching Conditional</source>
          <target state="translated">패턴 매칭 조건부</target>
        </trans-unit>
        <trans-unit id="4849c1facbc8d17ea4d09ce55cc45604ad2f39f1" translate="yes" xml:space="preserve">
          <source>Pcase patterns not only express a condition on the form of the objects they can match, but they can also extract sub-fields of those objects. For example we can extract 2 elements from a list that is the value of the variable &lt;code&gt;my-list&lt;/code&gt; with the following code:</source>
          <target state="translated">Pcase 패턴은 일치 할 수있는 개체의 형태에 대한 조건을 표현할뿐만 아니라 해당 개체의 하위 필드를 추출 할 수도 있습니다. 예를 들어 다음 코드를 사용하여 &lt;code&gt;my-list&lt;/code&gt; 변수의 값인 목록에서 2 개의 요소를 추출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f88d30015d65ab6f358329e5144fe34af976d4ca" translate="yes" xml:space="preserve">
          <source>People are sometimes tempted to create a variable whose value is a face name. In the vast majority of cases, this is not necessary; the usual procedure is to define a face with &lt;code&gt;defface&lt;/code&gt;, and then use its name directly.</source>
          <target state="translated">사람들은 때때로 값이 얼굴 이름 인 변수를 만들려는 유혹을받습니다. 대부분의 경우 이것은 필요하지 않습니다. 일반적인 절차는 &lt;code&gt;defface&lt;/code&gt; 로면 을 정의한 다음 이름을 직접 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="16d67645704093cc2992f9742e395e378a4a7842" translate="yes" xml:space="preserve">
          <source>People do not write byte-code; that job is left to the byte compiler. But we provide a disassembler to satisfy a cat-like curiosity. The disassembler converts the byte-compiled code into human-readable form.</source>
          <target state="translated">사람들은 바이트 코드를 작성하지 않습니다. 그 작업은 바이트 컴파일러에게 맡겨집니다. 그러나 우리는 고양이 같은 호기심을 충족시키기 위해 디스어셈블러를 제공합니다. 디스어셈블러는 바이트 컴파일 된 코드를 사람이 읽을 수있는 형식으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="d246b3473da94f1b94146151c91359171732e430" translate="yes" xml:space="preserve">
          <source>People often use &lt;code&gt;global-set-key&lt;/code&gt; in their init files (see &lt;a href=&quot;init-file#Init-File&quot;&gt;Init File&lt;/a&gt;) for simple customization. For example,</source>
          <target state="translated">사람들은 종종 간단한 사용자 정의를 위해 init 파일에서 &lt;code&gt;global-set-key&lt;/code&gt; 를 사용 합니다 ( &lt;a href=&quot;init-file#Init-File&quot;&gt;Init 파일&lt;/a&gt; 참조 ). 예를 들면</target>
        </trans-unit>
        <trans-unit id="26e74f2999a60551463cceee8a64dda32c66da77" translate="yes" xml:space="preserve">
          <source>Perform &lt;var&gt;action&lt;/var&gt; if the user clicks on a button.</source>
          <target state="translated">사용자가 버튼을 클릭하면 &lt;var&gt;action&lt;/var&gt; 수행 합니다.</target>
        </trans-unit>
        <trans-unit id="6aa0734a37f43c716d45db437864376f51cf5a6d" translate="yes" xml:space="preserve">
          <source>Perform a quit right away. Only &lt;code&gt;y-or-n-p&lt;/code&gt; and related functions use this answer.</source>
          <target state="translated">즉시 금연하십시오. &lt;code&gt;y-or-n-p&lt;/code&gt; 및 관련 함수 만이 답변을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="69869cd815dc383536f8d4d158ed0475269499de" translate="yes" xml:space="preserve">
          <source>Perform destructuring binding of variables according to &lt;var&gt;bindings&lt;/var&gt;, and then evaluate &lt;var&gt;body&lt;/var&gt;.</source>
          <target state="translated">수행 destructuring에 따라 변수의 바인딩 &lt;var&gt;bindings&lt;/var&gt; 다음과 평가 &lt;var&gt;body&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="c54c145e4d62a63d0c1782ba7e752fadb7b82eec" translate="yes" xml:space="preserve">
          <source>Perform the action specified by a button at location &lt;var&gt;pos&lt;/var&gt;. &lt;var&gt;pos&lt;/var&gt; may be either a buffer position or a mouse-event. If &lt;var&gt;use-mouse-action&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, or &lt;var&gt;pos&lt;/var&gt; is a mouse-event (see &lt;a href=&quot;mouse-events#Mouse-Events&quot;&gt;Mouse Events&lt;/a&gt;), try to invoke the button&amp;rsquo;s &lt;code&gt;mouse-action&lt;/code&gt; property instead of &lt;code&gt;action&lt;/code&gt;; if the button has no &lt;code&gt;mouse-action&lt;/code&gt; property, use &lt;code&gt;action&lt;/code&gt; as normal. &lt;var&gt;pos&lt;/var&gt; defaults to point, except when &lt;code&gt;push-button&lt;/code&gt; is invoked interactively as the result of a mouse-event, in which case, the mouse event&amp;rsquo;s position is used. If there&amp;rsquo;s no button at &lt;var&gt;pos&lt;/var&gt;, do nothing and return &lt;code&gt;nil&lt;/code&gt;, otherwise return &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;pos&lt;/var&gt; 위치에서 버튼으로 지정된 작업을 수행합니다 . &lt;var&gt;pos&lt;/var&gt; 는 버퍼 위치 또는 마우스 이벤트 일 수 있습니다. 경우 &lt;var&gt;use-mouse-action&lt;/var&gt; 비입니다 &lt;code&gt;nil&lt;/code&gt; , 또는 &lt;var&gt;pos&lt;/var&gt; 가 마우스 이벤트이다 ( &lt;a href=&quot;mouse-events#Mouse-Events&quot;&gt;마우스 이벤트를&lt;/a&gt; , 버튼의 호출 할) &lt;code&gt;mouse-action&lt;/code&gt; 대신 속성을 &lt;code&gt;action&lt;/code&gt; ; 버튼에 &lt;code&gt;mouse-action&lt;/code&gt; 속성 이 없으면 정상적으로 &lt;code&gt;action&lt;/code&gt; 을 사용 합니다 . &lt;var&gt;pos&lt;/var&gt; 는 마우스 이벤트의 결과로 &lt;code&gt;push-button&lt;/code&gt; 이 대화식으로 호출되는 경우를 제외하고는 point로 기본 설정됩니다 .이 경우 마우스 이벤트의 위치가 사용됩니다. &lt;var&gt;pos&lt;/var&gt; 에 버튼이없는 경우, 아무것도하지 않고 &lt;code&gt;nil&lt;/code&gt; 을 반환 하고 그렇지 않으면 &lt;code&gt;t&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="4f225f76cbcb682ebabbd6df30985ed39beadca0" translate="yes" xml:space="preserve">
          <source>Perform the specified window scroll operation, then ask the same question again. Only &lt;code&gt;y-or-n-p&lt;/code&gt; and related functions use this answer.</source>
          <target state="translated">지정된 창 스크롤 작업을 수행 한 다음 동일한 질문을 다시하십시오. &lt;code&gt;y-or-n-p&lt;/code&gt; 및 관련 함수 만이 답변을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="67a71f8eb164bf8cbebbd57b3abbfb3d805ffe84" translate="yes" xml:space="preserve">
          <source>Performance of Byte-Compiled Code</source>
          <target state="translated">바이트 컴파일 된 코드의 성능</target>
        </trans-unit>
        <trans-unit id="6547e00c11db8db176592a59424033b3f90c9a4b" translate="yes" xml:space="preserve">
          <source>Piecemeal Specification</source>
          <target state="translated">단편 사양</target>
        </trans-unit>
        <trans-unit id="8a2c6ee815e7a7247ddacfd3b50b4d7a7829a89f" translate="yes" xml:space="preserve">
          <source>Pixel Specification for Spaces</source>
          <target state="translated">공간에 대한 픽셀 사양</target>
        </trans-unit>
        <trans-unit id="e342bbd9ca43541fd7f27aae1acd3394adc60779" translate="yes" xml:space="preserve">
          <source>Place a &lt;code&gt;font-lock-multiline&lt;/code&gt; property on the construct. This will rehighlight the whole construct if any part of it is changed. In some cases you can do this automatically by setting the &lt;code&gt;font-lock-multiline&lt;/code&gt; variable, which see.</source>
          <target state="translated">구성에 &lt;code&gt;font-lock-multiline&lt;/code&gt; 특성을 배치합니다. 구성의 일부가 변경되면 전체 구성이 다시 강조 표시됩니다. 어떤 경우에는 &lt;code&gt;font-lock-multiline&lt;/code&gt; 변수 를 설정하여이를 자동으로 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c235c05182119ad368fe267076dee6d0dd6a6b9c" translate="yes" xml:space="preserve">
          <source>Place a &lt;code&gt;jit-lock-defer-multiline&lt;/code&gt; property on the construct. This works only if &lt;code&gt;jit-lock-contextually&lt;/code&gt; is used, and with the same delay before rehighlighting, but like &lt;code&gt;font-lock-multiline&lt;/code&gt;, it also handles the case where highlighting depends on subsequent lines.</source>
          <target state="translated">구성에 &lt;code&gt;jit-lock-defer-multiline&lt;/code&gt; 특성을 배치하십시오. 이것은 &lt;code&gt;jit-lock-contextually&lt;/code&gt; 가 사용되는 경우에만 작동 하고 다시 강조 표시 되기 전에 동일한 지연이 있지만 &lt;code&gt;font-lock-multiline&lt;/code&gt; 과 마찬가지로 강조 표시가 후속 행에 의존하는 경우를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="0892bc999ffda43cddb1e182b36617e30f0fe235" translate="yes" xml:space="preserve">
          <source>Playing sounds on the computer&amp;rsquo;s speaker.</source>
          <target state="translated">컴퓨터 스피커에서 소리를 재생합니다.</target>
        </trans-unit>
        <trans-unit id="061394dac9aea5d18455df9eaa1d0cd858c9f0b8" translate="yes" xml:space="preserve">
          <source>Please answer y or n.</source>
          <target state="translated">y 또는 n으로 대답하십시오.</target>
        </trans-unit>
        <trans-unit id="6a490ec11b9140306205d30629596595e9b6e94f" translate="yes" xml:space="preserve">
          <source>Please answer yes or no.</source>
          <target state="translated">예 또는 아니오로 대답하십시오.</target>
        </trans-unit>
        <trans-unit id="71ece59413670b96fc75ee700d7e27c649f7e924" translate="yes" xml:space="preserve">
          <source>Please send comments and corrections using</source>
          <target state="translated">다음을 사용하여 의견 및 수정 사항을 보내주십시오.</target>
        </trans-unit>
        <trans-unit id="f79a28423ed1ae0232efb54ad41227d0955084f3" translate="yes" xml:space="preserve">
          <source>Point</source>
          <target state="translated">Point</target>
        </trans-unit>
        <trans-unit id="f5cc952a1d9de36117c7758546bd79fa0d592285" translate="yes" xml:space="preserve">
          <source>Point (2) implies that a &lt;code&gt;:weight black&lt;/code&gt; attribute will be satisfied by any display that can display bold, as will &lt;code&gt;:foreground &quot;yellow&quot;&lt;/code&gt; as long as some yellowish color can be displayed, but &lt;code&gt;:slant italic&lt;/code&gt; will &lt;em&gt;not&lt;/em&gt; be satisfied by the tty display code&amp;rsquo;s automatic substitution of a dim face for italic.</source>
          <target state="translated">포인트 (2) 는 굵게 표시 할 수있는 모든 디스플레이 에서 &lt;code&gt;:weight black&lt;/code&gt; 속성을 만족 한다는 것을 의미합니다 &lt;code&gt;:foreground &quot;yellow&quot;&lt;/code&gt; 는 노란색을 표시 할 수 있지만 &lt;code&gt;:slant italic&lt;/code&gt; 은 tty에 의해 충족 &lt;em&gt;되지 않습니다&lt;/em&gt; . 이탤릭체에 대한 희미한 얼굴의 디스플레이 코드의 자동 대체.</target>
        </trans-unit>
        <trans-unit id="396cf0edbfa0128fdb159e61630df3d416f1062f" translate="yes" xml:space="preserve">
          <source>Point and the mark, as two numeric arguments, smallest first. This is the only code letter that specifies two successive arguments rather than one. This will signal an error if the mark is not set in the buffer which is current when the command is invoked. No I/O.</source>
          <target state="translated">두 개의 숫자 인수로 포인트와 마크, 가장 작은 것 먼저. 이것은 하나가 아닌 두 개의 연속적인 인수를 지정하는 유일한 코드 문자입니다. 이것은 명령이 호출 될 때 현재 버퍼에 마크가 설정되지 않은 경우 오류를 나타냅니다. I / O가 없습니다.</target>
        </trans-unit>
        <trans-unit id="607e97203b9ceed3b508490569d375e75af49959" translate="yes" xml:space="preserve">
          <source>Pointer Shape</source>
          <target state="translated">포인터 모양</target>
        </trans-unit>
        <trans-unit id="952493c99caa2adef127c34f7eb386dd95d6f98f" translate="yes" xml:space="preserve">
          <source>Polymorphism, Emacs-style.</source>
          <target state="translated">다형성, Emacs 스타일.</target>
        </trans-unit>
        <trans-unit id="ed7450dfdd1d277c3cabc1ce06c43cba4a362b92" translate="yes" xml:space="preserve">
          <source>Pop-Up Menus</source>
          <target state="translated">팝업 메뉴</target>
        </trans-unit>
        <trans-unit id="5307f05e0199e2333e229d7e2d00200cc6d0db03" translate="yes" xml:space="preserve">
          <source>Popping up a new window will fail if there is not enough space on the selected frame. In an uncustomized Emacs it typically fails when there are already two windows on a frame. For example, if you now type</source>
          <target state="translated">선택한 프레임에 충분한 공간이 없으면 새 창을 열지 못합니다. 사용자 정의되지 않은 Emacs에서는 일반적으로 프레임에 이미 두 개의 창이있는 경우 실패합니다. 예를 들어, 지금 입력하면</target>
        </trans-unit>
        <trans-unit id="a6a8cdd50e41aeb0ad1784d8f1195a61e89f7520" translate="yes" xml:space="preserve">
          <source>Position Parameters</source>
          <target state="translated">위치 매개 변수</target>
        </trans-unit>
        <trans-unit id="fcd7e6b774c8f47ead8ead0ed8f33c8f9f736a14" translate="yes" xml:space="preserve">
          <source>Position of the top-left corner and size of the work area (usable space) in pixels as &amp;lsquo;</source>
          <target state="translated">왼쪽 상단 모서리의 위치와 작업 영역 (사용 가능한 공간)의 크기 (픽셀 단위) '</target>
        </trans-unit>
        <trans-unit id="e7f9862a7c40fe020b33ccbf1989aac5bbb93333" translate="yes" xml:space="preserve">
          <source>Position of the top-left corner of the monitor&amp;rsquo;s screen and its size, in pixels, as &amp;lsquo;</source>
          <target state="translated">모니터 화면의 왼쪽 상단 모서리 위치 및 크기 (픽셀 단위)</target>
        </trans-unit>
        <trans-unit id="cd4683fadf7005eca07e4d6267ddbb19ebcb91fa" translate="yes" xml:space="preserve">
          <source>Positions</source>
          <target state="translated">Positions</target>
        </trans-unit>
        <trans-unit id="da11d4c9a25e9c8a4126db50b558133457b0ac80" translate="yes" xml:space="preserve">
          <source>Positions are usually represented as integers starting from 1, but can also be represented as &lt;em&gt;markers&lt;/em&gt;&amp;mdash;special objects that relocate automatically when text is inserted or deleted so they stay with the surrounding characters. Functions that expect an argument to be a position (an integer), but accept a marker as a substitute, normally ignore which buffer the marker points into; they convert the marker to an integer, and use that integer, exactly as if you had passed the integer as the argument, even if the marker points to the wrong buffer. A marker that points nowhere cannot convert to an integer; using it instead of an integer causes an error. See &lt;a href=&quot;markers#Markers&quot;&gt;Markers&lt;/a&gt;.</source>
          <target state="translated">위치는 일반적으로 1부터 시작하는 정수로 표시되지만 &lt;em&gt;마커 (&lt;/em&gt; 텍스트가 삽입되거나 삭제 될 때 자동으로 재배치되어 주변 문자와 함께 유지되는 특수 개체) 로 &lt;em&gt;표시&lt;/em&gt; 될 수도 있습니다 . 인수가 위치 (정수)가 될 것으로 예상하지만 마커를 대체물로 받아들이는 함수는 일반적으로 마커가 가리키는 버퍼를 무시합니다. 마커를 정수로 변환하고, 마커가 잘못된 버퍼를 가리키는 경우에도 정수를 인수로 전달한 것처럼 정확히 해당 정수를 사용합니다. 아무데도 가리키는 마커는 정수로 변환 할 수 없습니다. 정수 대신 사용하면 오류가 발생합니다. &lt;a href=&quot;markers#Markers&quot;&gt;마커를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0d57c1560194ed5b9740be5062e662f21bf258a8" translate="yes" xml:space="preserve">
          <source>Precalculated Fontification</source>
          <target state="translated">미리 계산 된 글꼴 화</target>
        </trans-unit>
        <trans-unit id="bb31a3184fc540673e8536291743e02cc7cb150c" translate="yes" xml:space="preserve">
          <source>Precautions about loading a file twice.</source>
          <target state="translated">파일을 두 번로드 할 때주의 사항.</target>
        </trans-unit>
        <trans-unit id="566ae5a22bce2d820a88dbf4901446093188d136" translate="yes" xml:space="preserve">
          <source>Precedence conflicts can be resolved via &lt;var&gt;resolvers&lt;/var&gt;, which is a list of &lt;em&gt;precs&lt;/em&gt; tables (see &lt;code&gt;smie-precs-&amp;gt;prec2&lt;/code&gt;): for each precedence conflict, if those &lt;code&gt;precs&lt;/code&gt; tables specify a particular constraint, then the conflict is resolved by using this constraint instead, else a conflict is reported and one of the conflicting constraints is picked arbitrarily and the others are simply ignored.</source>
          <target state="translated">우선 순위 충돌은 &lt;em&gt;precs&lt;/em&gt; 테이블 목록 인 &lt;var&gt;resolvers&lt;/var&gt; 를 통해 해결할 수 있습니다 ( &lt;code&gt;smie-precs-&amp;gt;prec2&lt;/code&gt; 참조 ) : 각 우선 순위 충돌에 대해 해당 &lt;code&gt;precs&lt;/code&gt; 테이블이 특정 제약 조건을 지정하면 충돌은 대신이 제약 조건을 사용하여 해결됩니다. 그렇지 않으면 충돌이보고되고 충돌하는 제약 조건 중 하나가 임의로 선택되고 나머지는 무시됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="964094642c54dd1cde6edca379d013120bbe6cdf" translate="yes" xml:space="preserve">
          <source>Precedence of Action Functions</source>
          <target state="translated">액션 함수의 우선 순위</target>
        </trans-unit>
        <trans-unit id="7f421f63196a5c9594ee21a2f12cf973d50a9e3c" translate="yes" xml:space="preserve">
          <source>Precisely what this function does depends on your operating system. The function is designed to work with the syntax of your system&amp;rsquo;s standard shell; if you use an unusual shell, you will need to redefine this function. See &lt;a href=&quot;security-considerations#Security-Considerations&quot;&gt;Security Considerations&lt;/a&gt;.</source>
          <target state="translated">이 기능의 정확한 기능은 운영 체제에 따라 다릅니다. 이 함수는 시스템의 표준 쉘 구문과 함께 작동하도록 설계되었습니다. 비정상적인 셸을 사용하는 경우이 기능을 다시 정의해야합니다. &lt;a href=&quot;security-considerations#Security-Considerations&quot;&gt;보안 고려 사항을&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
