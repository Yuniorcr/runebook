<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="eslint">
    <body>
      <group id="eslint">
        <trans-unit id="14eabcc20ca1ae6d595dd0146dacc275446c2785" translate="yes" xml:space="preserve">
          <source>Note that operator &lt;code&gt;+&lt;/code&gt; in &lt;code&gt;allow&lt;/code&gt; list would allow &lt;code&gt;+foo&lt;/code&gt; (number coercion) as well as &lt;code&gt;&quot;&quot; + foo&lt;/code&gt; (string coercion).</source>
          <target state="translated">&lt;code&gt;allow&lt;/code&gt; 목록의 연산자 &lt;code&gt;+&lt;/code&gt; 는 &lt;code&gt;&quot;&quot; + foo&lt;/code&gt; (문자열 강제) 뿐만 아니라 &lt;code&gt;+foo&lt;/code&gt; (숫자 강제)도 허용 합니다 .</target>
        </trans-unit>
        <trans-unit id="a2ea103023fbbea878ee580810efa43b1ce5e514" translate="yes" xml:space="preserve">
          <source>Note that simply checking &lt;code&gt;foo.hasOwnProperty(key)&lt;/code&gt; is likely to cause an error in some cases; see &lt;a href=&quot;no-prototype-builtins&quot;&gt;no-prototype-builtins&lt;/a&gt;.</source>
          <target state="translated">단순히 &lt;code&gt;foo.hasOwnProperty(key)&lt;/code&gt; 를 확인 하면 오류가 발생할 수 있습니다. &lt;a href=&quot;no-prototype-builtins&quot;&gt;프로토 타입이없는 내장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="da8f31abf81fd1530a65a1c89cbaf28a84d87fe4" translate="yes" xml:space="preserve">
          <source>Note that the following words are always ignored by this rule: &lt;code&gt;[&quot;jscs&quot;, &quot;jshint&quot;, &quot;eslint&quot;, &quot;istanbul&quot;, &quot;global&quot;, &quot;globals&quot;, &quot;exported&quot;]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;[&quot;jscs&quot;, &quot;jshint&quot;, &quot;eslint&quot;, &quot;istanbul&quot;, &quot;global&quot;, &quot;globals&quot;, &quot;exported&quot;]&lt;/code&gt; 규칙은 항상 다음 단어를 무시합니다 .</target>
        </trans-unit>
        <trans-unit id="92871ffd4aceb2bd3a9e8edec06e56e2e05d821f" translate="yes" xml:space="preserve">
          <source>Note that the last &lt;code&gt;case&lt;/code&gt; statement in these examples does not cause a warning because there is nothing to fall through into.</source>
          <target state="translated">이 예제에서 마지막 &lt;code&gt;case&lt;/code&gt; 문은 아무런 문제가 없으므로 경고를 일으키지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9fe60f0778016b7de275c5c3433b4ff7fcd68bdb" translate="yes" xml:space="preserve">
          <source>Note that the patterns considered problems are &lt;strong&gt;not&lt;/strong&gt; flagged by the &lt;a href=&quot;semi&quot;&gt;semi&lt;/a&gt; rule.</source>
          <target state="translated">문제로 간주되는 패턴 에는 &lt;a href=&quot;semi&quot;&gt;세미&lt;/a&gt; 규칙이 표시 &lt;strong&gt;되지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="649f078207c83d3aa9f8117c4caa24a177fa6e14" translate="yes" xml:space="preserve">
          <source>Note that this also affects the &lt;a href=&quot;../developer-guide/nodejs-api#cliengineexecuteonfiles&quot;&gt;&lt;code&gt;CLIEngine.executeOnFiles()&lt;/code&gt;&lt;/a&gt; API.</source>
          <target state="translated">이는 &lt;a href=&quot;../developer-guide/nodejs-api#cliengineexecuteonfiles&quot;&gt; &lt;code&gt;CLIEngine.executeOnFiles()&lt;/code&gt; &lt;/a&gt; API 에도 영향을 미칩니다 .</target>
        </trans-unit>
        <trans-unit id="4e1fc0ebbd12c442e0e5e74e0e029ef6f09efa61" translate="yes" xml:space="preserve">
          <source>Note that this also enables parsing for other features from ES2018, such as &lt;a href=&quot;https://github.com/tc39/proposal-async-iteration&quot;&gt;async iteration&lt;/a&gt;. When using ESLint v5 with the default parser, it is no longer possible to toggle syntax support for object rest/spread independently of other features.</source>
          <target state="translated">이를 통해 &lt;a href=&quot;https://github.com/tc39/proposal-async-iteration&quot;&gt;비동기 반복&lt;/a&gt; 과 같은 ES2018의 다른 기능을 구문 분석 할 수도 있습니다 . 기본 파서와 함께 ESLint v5를 사용하는 경우 더 이상 다른 기능과 독립적으로 객체 휴식 / 확산에 대한 구문 지원을 토글 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="82d62f793b20020481672da21ac064b568a683e5" translate="yes" xml:space="preserve">
          <source>Note that this rule does not disallow assignments to read-only global variables. See &lt;a href=&quot;no-global-assign&quot;&gt;no-global-assign&lt;/a&gt; if you also want to disallow those assignments.</source>
          <target state="translated">이 규칙은 읽기 전용 전역 변수에 대한 할당을 허용하지 않습니다. 이러한 할당을 허용하지 않으려면 &lt;a href=&quot;no-global-assign&quot;&gt;no-global-assign을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a5a9767c41439a621031ba6529109fef573ecf23" translate="yes" xml:space="preserve">
          <source>Note that this rule does not enforce the usage of single-line statements in general. If you would like to disallow single-line statements, use the &lt;a href=&quot;curly&quot;&gt;&lt;code&gt;curly&lt;/code&gt;&lt;/a&gt; rule instead.</source>
          <target state="translated">이 규칙은 일반적으로 한 줄 문장의 사용을 강요하지 않습니다. 한 줄로 된 문장을 허용하지 않으려면 대신 &lt;a href=&quot;curly&quot;&gt; &lt;code&gt;curly&lt;/code&gt; &lt;/a&gt; 규칙을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d826b4d17235a608a3c9cd20c92fa11e3d5d2e94" translate="yes" xml:space="preserve">
          <source>Note that this rule only enforces spacing within parentheses; it does not check spacing within curly or square brackets, but will enforce or disallow spacing of those brackets if and only if they are adjacent to an opening or closing parenthesis.</source>
          <target state="translated">이 규칙은 괄호 안에 만 간격을 적용합니다. 중괄호 또는 대괄호 안의 간격을 확인하지는 않지만 괄호가 시작 또는 닫는 괄호에 인접한 경우에만 해당 브래킷의 간격을 적용하거나 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="347d91e7a5b838e6bcb85cf66bf52f2d967e3ca1" translate="yes" xml:space="preserve">
          <source>Note that when using the &lt;code&gt;node&lt;/code&gt; or &lt;code&gt;commonjs&lt;/code&gt; environments (or &lt;code&gt;ecmaFeatures.globalReturn&lt;/code&gt;, if using the default parser), the top scope of a program is not actually the global scope, but rather a &quot;module&quot; scope. When this is the case, declaring a variable named after a builtin global is not a redeclaration, but rather a shadowing of the global variable. In that case, the &lt;a href=&quot;no-shadow&quot;&gt;&lt;code&gt;no-shadow&lt;/code&gt;&lt;/a&gt; rule with the &lt;code&gt;&quot;builtinGlobals&quot;&lt;/code&gt; option should be used.</source>
          <target state="translated">사용할 때주의 &lt;code&gt;node&lt;/code&gt; 또는 &lt;code&gt;commonjs&lt;/code&gt; (또는 환경을 &lt;code&gt;ecmaFeatures.globalReturn&lt;/code&gt; 기본 파서를 사용하는 경우), 프로그램의 정상 범위는 실제로 전역, 오히려 &quot;모듈&quot;의 범위가 아닙니다. 이 경우 내장 전역의 이름을 딴 변수를 선언하는 것은 재 선언이 아니라 전역 변수의 음영입니다. 이 경우 &lt;code&gt;&quot;builtinGlobals&quot;&lt;/code&gt; 옵션이있는 &lt;a href=&quot;no-shadow&quot;&gt; &lt;code&gt;no-shadow&lt;/code&gt; &lt;/a&gt; 규칙을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="1125aced35499b31bb41c702c9945c7bd12e9b07" translate="yes" xml:space="preserve">
          <source>Note that you can leave off the &lt;code&gt;.js&lt;/code&gt; from the filename. In this way, you can add as many additional configs to your package as you'd like.</source>
          <target state="translated">파일 이름 에서 &lt;code&gt;.js&lt;/code&gt; 를 생략 할 수 있습니다 . 이런 식으로 패키지에 원하는만큼 구성을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76aa0f033fd5d1d41d32bcaf6fd648d73e33b956" translate="yes" xml:space="preserve">
          <source>Note that, as with core rules and plugin rules, you still need to enable the rules in configuration or via the &lt;code&gt;--rule&lt;/code&gt; CLI option in order to actually run those rules during linting. Specifying a rules directory with &lt;code&gt;--rulesdir&lt;/code&gt; does not automatically enable the rules within that directory.</source>
          <target state="translated">핵심 규칙 및 플러그인 규칙과 마찬가지로 &lt;code&gt;--rule&lt;/code&gt; 중에 규칙을 실제로 실행하려면 구성에서 또는 --rule CLI 옵션을 통해 규칙을 활성화해야합니다 . &lt;code&gt;--rulesdir&lt;/code&gt; 을 사용 하여 rules 디렉토리를 지정해도 해당 디렉토리 내의 규칙이 자동으로 활성화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e9b6296c44a9bc30cef358e801b33c46b39d24f5" translate="yes" xml:space="preserve">
          <source>Note the use of a semicolon as the final part of this statement. There should be a space before and after the &lt;code&gt;while&lt;/code&gt; keyword.</source>
          <target state="translated">이 명령문의 마지막 부분으로 세미콜론을 사용하십시오. &lt;code&gt;while&lt;/code&gt; 키워드 앞뒤에 공백이 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="cc6c88398cdded8def6acc02b6ff7133a562ee36" translate="yes" xml:space="preserve">
          <source>Note when using a custom parser, the &lt;code&gt;parserOptions&lt;/code&gt; configuration property is still required for ESLint to work properly with features not in ECMAScript 5 by default. Parsers are all passed &lt;code&gt;parserOptions&lt;/code&gt; and may or may not use them to determine which features to enable.</source>
          <target state="translated">사용자 정의 파서를 사용할 때 ESLint가 기본적으로 ECMAScript 5에없는 기능과 올바르게 작동하려면 &lt;code&gt;parserOptions&lt;/code&gt; 구성 등록 정보가 여전히 필요합니다. 파서는 모두 &lt;code&gt;parserOptions&lt;/code&gt; 에 전달 되며 이를 사용하여 사용할 기능을 결정하거나 사용하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50c39afa03191645dbc4d28c7d2359af7e538e42" translate="yes" xml:space="preserve">
          <source>Note: Currently &lt;code&gt;CLIEngine&lt;/code&gt; does not validate options passed to it, but may start doing so in the future.</source>
          <target state="translated">참고 : 현재 &lt;code&gt;CLIEngine&lt;/code&gt; 은 전달 된 옵션의 유효성을 검사하지 않지만 나중에 그렇게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="984b1133cbe92feba750f10ab3475f0c23c1b51a" translate="yes" xml:space="preserve">
          <source>Note: For a rule preventing deletion of variables, see &lt;a href=&quot;no-delete-var&quot;&gt;no-delete-var instead&lt;/a&gt;</source>
          <target state="translated">참고 : 변수 삭제를 방지하는 규칙은 &lt;a href=&quot;no-delete-var&quot;&gt;대신 no-delete-var를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d25aa0b7adae8f5ed33576b5806bc8d4bbf49549" translate="yes" xml:space="preserve">
          <source>Note: Formatting for Terminals</source>
          <target state="translated">참고 : 터미널 포맷</target>
        </trans-unit>
        <trans-unit id="be22f31f5831c296a952cd7a2998bc8d390f968e" translate="yes" xml:space="preserve">
          <source>Note: Suggestions will be applied as a stand-alone change, without triggering multipass fixes. Each suggestion should focus on a singular change in the code and should not try to conform to user defined styles. For example, if a suggestion is adding a new statement into the codebase, it should not try to match correct indentation, or confirm to user preferences on presence/absence of semicolons. All of those things can be corrected by multipass autofix when the user triggers it.</source>
          <target state="translated">Note: Suggestions will be applied as a stand-alone change, without triggering multipass fixes. Each suggestion should focus on a singular change in the code and should not try to conform to user defined styles. For example, if a suggestion is adding a new statement into the codebase, it should not try to match correct indentation, or confirm to user preferences on presence/absence of semicolons. All of those things can be corrected by multipass autofix when the user triggers it.</target>
        </trans-unit>
        <trans-unit id="094162498ea0d1d13c56050f15e2107cd8551770" translate="yes" xml:space="preserve">
          <source>Note: Suggestions will be applied as a stand-alone change, without triggering multipass fixes. Each suggestion should focus on a singular change in the code and should not try to conform to user defined styles. For example, if a suggestion is adding a new statement into the codebase, it should not try to match correct indentation, or confirm to user preferences on presence/absence of semicolumns. All of those things can be corrected by multipass autofix when the user triggers it.</source>
          <target state="translated">참고 : 제안 사항은 멀티 패스 수정을 트리거하지 않고 독립형 변경 사항으로 적용됩니다. 각 제안은 코드의 단일 변경에 중점을 두어야하며 사용자 정의 스타일을 따르지 않아야합니다. 예를 들어, 제안이 코드베이스에 새 명령문을 추가하는 경우 올바른 들여 쓰기를 일치 시키거나 세미 컬럼 유무에 대한 사용자 기본 설정을 확인하려고 시도해서는 안됩니다. 이러한 모든 사항은 사용자가 트리거 할 때 멀티 패스 자동 수정으로 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a96d12cefbf530755a3476759379971f31c30b2" translate="yes" xml:space="preserve">
          <source>Note: This API is deprecated as of 4.0.0.</source>
          <target state="translated">참고 :이 API는 4.0.0부터 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0f4d27cca8900b2f84cb2149ba7b39507829e56c" translate="yes" xml:space="preserve">
          <source>Note: this rule ignores async generator functions. This is because generators yield rather than return a value and async generators might yield all the values of another async generator without ever actually needing to use await.</source>
          <target state="translated">Note: this rule ignores async generator functions. This is because generators yield rather than return a value and async generators might yield all the values of another async generator without ever actually needing to use await.</target>
        </trans-unit>
        <trans-unit id="24de5bcbd5c3607fa22b1b0d298fae9fdf45a3ea" translate="yes" xml:space="preserve">
          <source>Now here are ES6 equivalents:</source>
          <target state="translated">다음은 ES6에 해당하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="87fe1cc3d574f9be3c85d698f90d866c75ac44a8" translate="yes" xml:space="preserve">
          <source>Now inside your &lt;code&gt;/lib/ci/backend.js&lt;/code&gt;</source>
          <target state="translated">이제 &lt;code&gt;/lib/ci/backend.js&lt;/code&gt; 내부</target>
        </trans-unit>
        <trans-unit id="35e2195ff597916ba2ef234cdbb68bdf57b69342" translate="yes" xml:space="preserve">
          <source>Now inside your package you have &lt;code&gt;/lib/defaults.js&lt;/code&gt;, which contains:</source>
          <target state="translated">이제 패키지 &lt;code&gt;/lib/defaults.js&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4137e109ac15d620738ab61f944d78dc01861a63" translate="yes" xml:space="preserve">
          <source>Now it is very clear that three spaces are expected to be matched.</source>
          <target state="translated">이제 세 개의 공백이 일치 할 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="5bca21c074e0d721a5fd90d89b255318c8ce0216" translate="yes" xml:space="preserve">
          <source>Now when you run &lt;code&gt;eslint&lt;/code&gt;, it will be running your local copy and showing your changes.</source>
          <target state="translated">이제 &lt;code&gt;eslint&lt;/code&gt; 를 실행하면 로컬 사본이 실행되고 변경 사항이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="57c585f4798ef4591adf413472a8e4f97e198bfd" translate="yes" xml:space="preserve">
          <source>Now you're ready to send the pull request. Go to your ESLint fork and then follow the &lt;a href=&quot;https://help.github.com/articles/creating-a-pull-request&quot;&gt;GitHub documentation&lt;/a&gt; on how to send a pull request.</source>
          <target state="translated">이제 풀 요청을 보낼 준비가되었습니다. ESLint 포크로 이동하여 풀 요청을 보내는 방법에 대한 &lt;a href=&quot;https://help.github.com/articles/creating-a-pull-request&quot;&gt;GitHub 문서&lt;/a&gt; 를 따르십시오 .</target>
        </trans-unit>
        <trans-unit id="20482a66574043c6f07e88950af557ca9ba4cb34" translate="yes" xml:space="preserve">
          <source>Now, consider the following group configuration: &lt;code&gt;{&quot;groups&quot;: [[&quot;&amp;amp;&quot;, &quot;|&quot;, &quot;^&quot;, &quot;~&quot;, &quot;&amp;lt;&amp;lt;&quot;, &quot;&amp;gt;&amp;gt;&quot;, &quot;&amp;gt;&amp;gt;&amp;gt;&quot;], [&quot;&amp;amp;&amp;amp;&quot;, &quot;||&quot;]]}&lt;/code&gt;. There are 2 groups specified in this configuration: bitwise operators and logical operators. This rule checks if the operators belong to the same group only. In this case, this rule checks if bitwise operators and logical operators are mixed, but ignores all other operators.</source>
          <target state="translated">이제 다음 그룹 구성을 고려하십시오 : &lt;code&gt;{&quot;groups&quot;: [[&quot;&amp;amp;&quot;, &quot;|&quot;, &quot;^&quot;, &quot;~&quot;, &quot;&amp;lt;&amp;lt;&quot;, &quot;&amp;gt;&amp;gt;&quot;, &quot;&amp;gt;&amp;gt;&amp;gt;&quot;], [&quot;&amp;amp;&amp;amp;&quot;, &quot;||&quot;]]}&lt;/code&gt; . 이 구성에는 비트 연산자와 논리 연산자의 두 그룹이 지정됩니다. 이 규칙은 연산자가 동일한 그룹에만 속하는지 확인합니다. 이 경우이 규칙은 비트 연산자와 논리 연산자가 혼합되어 있는지 확인하지만 다른 모든 연산자는 무시합니다.</target>
        </trans-unit>
        <trans-unit id="b4992572eba9e898e29cdb06f84784a8f96e8a75" translate="yes" xml:space="preserve">
          <source>Now, the remote &lt;code&gt;upstream&lt;/code&gt; points to the upstream source.</source>
          <target state="translated">이제 원격 &lt;code&gt;upstream&lt;/code&gt; 이 업스트림 소스를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="8dad4f5a3bcf9c3bffdb2bf8a3903f51188938d6" translate="yes" xml:space="preserve">
          <source>Now, those variables and references have correct values in these properties.</source>
          <target state="translated">이제 이러한 변수와 참조는 이러한 속성에서 올바른 값을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="b69cceaa39cc9827d135c31a0a311643f64c4242" translate="yes" xml:space="preserve">
          <source>Numbers should be written as decimal integers, e-notation integers, hexadecimal integers or floating-point decimals with at least one digit before and one digit after the decimal point. Never use octal literals.</source>
          <target state="translated">숫자는 소수점 앞뒤 한 자리 이상, 소수점 이하 한 자리 이상을 갖는 십진 정수, 전자 표기 정수, 16 진 정수 또는 부동 소수점 십진수로 작성해야합니다. 8 진 리터럴을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="afb8e044bcdc5720b645f5bad798ce2422b144b7" translate="yes" xml:space="preserve">
          <source>Object Getters</source>
          <target state="translated">객체 게터</target>
        </trans-unit>
        <trans-unit id="bff5a67a67ce40c0fd925410f2eb22f8e622ed24" translate="yes" xml:space="preserve">
          <source>Object Literals</source>
          <target state="translated">객체 리터럴</target>
        </trans-unit>
        <trans-unit id="8c039bd2c30b64d60bbf9c614cffee3af09daea6" translate="yes" xml:space="preserve">
          <source>Object Rest/Spread Properties for ECMAScript</source>
          <target state="translated">ECMAScript의 오브젝트 레스트 / 스프레드 속성</target>
        </trans-unit>
        <trans-unit id="5b78ac9af4a56a7e0611f75dde6336ad4efc93cf" translate="yes" xml:space="preserve">
          <source>Object Setters</source>
          <target state="translated">객체 세터</target>
        </trans-unit>
        <trans-unit id="4671b195767e872ed26e93314009bf9a02b4925b" translate="yes" xml:space="preserve">
          <source>Object initializer - MDN</source>
          <target state="translated">객체 이니셜 라이저-MDN</target>
        </trans-unit>
        <trans-unit id="ffa631f7811b9675c18511c35ebd3c5888d3c693" translate="yes" xml:space="preserve">
          <source>Object literal property names can be defined in two ways: using literals or using strings. For example, these two objects are equivalent:</source>
          <target state="translated">객체 리터럴 속성 이름은 리터럴 사용 또는 문자열 사용의 두 가지 방법으로 정의 할 수 있습니다. 예를 들어이 두 개체는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="01a531c72bfc336c6dd4074ad4379fdce5371193" translate="yes" xml:space="preserve">
          <source>Object literals should have the following format:</source>
          <target state="translated">객체 리터럴은 다음 형식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="593c1a9b247ae9203d0656b7697e245c92cca212" translate="yes" xml:space="preserve">
          <source>Object literals.</source>
          <target state="translated">객체 리터럴.</target>
        </trans-unit>
        <trans-unit id="d0906ffdbaac63ebcdad566357ec1fa32b660ce9" translate="yes" xml:space="preserve">
          <source>Object option (when &lt;code&gt;&quot;always&quot;&lt;/code&gt;):</source>
          <target state="translated">객체 옵션 ( &lt;code&gt;&quot;always&quot;&lt;/code&gt; ) :</target>
        </trans-unit>
        <trans-unit id="ac9c86f6b8a7b6cb8ef56a7d1efe7d9ef0bb7e18" translate="yes" xml:space="preserve">
          <source>Object option (when &lt;code&gt;&quot;never&quot;&lt;/code&gt;):</source>
          <target state="translated">객체 옵션 ( &lt;code&gt;&quot;never&quot;&lt;/code&gt; 인 경우 ) :</target>
        </trans-unit>
        <trans-unit id="f8eb5265b464019bacbbf51d8d1ff30364921024" translate="yes" xml:space="preserve">
          <source>Object option:</source>
          <target state="translated">객체 옵션 :</target>
        </trans-unit>
        <trans-unit id="149ecb5e6d435ef3f0c0b95567c172606e31d857" translate="yes" xml:space="preserve">
          <source>Object properties follow the same naming conventions as variables. Object methods follow the same naming conventions as functions. If a property or method is meant to be private, then it should be prefixed with an underscore character.</source>
          <target state="translated">객체 속성은 변수와 동일한 명명 규칙을 따릅니다. 객체 메소드는 함수와 동일한 명명 규칙을 따릅니다. 속성 또는 메서드가 개인용 인 경우 밑줄 문자가 접두사로 붙어야합니다.</target>
        </trans-unit>
        <trans-unit id="07cc26cad16fa208535abacfadeea81f2c8f08d7" translate="yes" xml:space="preserve">
          <source>Object properties for variants of the &lt;code&gt;&quot;as-needed&quot;&lt;/code&gt; option:</source>
          <target state="translated">&lt;code&gt;&quot;as-needed&quot;&lt;/code&gt; 옵션의 변형에 대한 객체 속성 :</target>
        </trans-unit>
        <trans-unit id="c4dfaa986b5d14c627c83c972171a7941c5b7be6" translate="yes" xml:space="preserve">
          <source>Object rest/spread is now an official part of the JavaScript language, so our support for it is no longer experimental. In both ESLint v4 and ESLint v5, object rest/spread can now be enabled with the &lt;code&gt;&quot;ecmaVersion&quot;: 2018&lt;/code&gt; option:</source>
          <target state="translated">객체 휴식 / 확산은 이제 JavaScript 언어의 공식적인 부분이므로 더 이상 실험적으로 지원되지 않습니다. ESLint v4 및 ESLint v5에서 &lt;code&gt;&quot;ecmaVersion&quot;: 2018&lt;/code&gt; 옵션을 사용하여 오브젝트 레스트 / 스프레드를 활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="11a92c8196539fdab3857b1551dea0f331c775a8" translate="yes" xml:space="preserve">
          <source>Object.getPrototypeOf</source>
          <target state="translated">Object.getPrototypeOf</target>
        </trans-unit>
        <trans-unit id="fa8ae9f7df131e038e636e584d189c8515f58a8c" translate="yes" xml:space="preserve">
          <source>ObjectExpression</source>
          <target state="translated">ObjectExpression</target>
        </trans-unit>
        <trans-unit id="793061db282a75e8ed5dcc678e2f977602f536e5" translate="yes" xml:space="preserve">
          <source>ObjectExpression and ObjectPattern</source>
          <target state="translated">ObjectExpression 및 ObjectPattern</target>
        </trans-unit>
        <trans-unit id="72a83add2c5ede877c10d23f302d3e17accbadab" translate="yes" xml:space="preserve">
          <source>Objects</source>
          <target state="translated">Objects</target>
        </trans-unit>
        <trans-unit id="79c19740aba487d5c36feef2d71ebeab770748e7" translate="yes" xml:space="preserve">
          <source>Occasionally, a core ESLint rule needs to be changed. This is not necessarily a bug, but rather, an enhancement that makes a rule more configurable. In those situations, we will consider making changes to rules.</source>
          <target state="translated">때로는 핵심 ESLint 규칙을 변경해야합니다. 이것은 반드시 버그 일 필요는 없으며 규칙을보다 구성 가능하게 만드는 개선 사항입니다. 이러한 상황에서는 규칙을 변경하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="503c1e8b34ff2b306e45ab8d949857759bce53e9" translate="yes" xml:space="preserve">
          <source>Octal literals are numerals that begin with a leading zero, such as:</source>
          <target state="translated">8 진 리터럴은 다음과 같이 선행 0으로 시작하는 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="5270a8f48af0485d13759bcff94f40182ae7fbe6" translate="yes" xml:space="preserve">
          <source>Of course, you could also have a style guide that disallows spaces around keywords.</source>
          <target state="translated">물론 키워드 주위에 공백을 허용하지 않는 스타일 가이드가있을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1125ca598816239bf6b761a79b64ee161ec9a9d7" translate="yes" xml:space="preserve">
          <source>Of course, you could also have a style guide that disallows spaces before keywords.</source>
          <target state="translated">물론 키워드 앞에 공백을 허용하지 않는 스타일 가이드를 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c141537fefa1f7236bb95371a0c1823cf3d5a82a" translate="yes" xml:space="preserve">
          <source>Of particular note is that like &lt;code&gt;.gitignore&lt;/code&gt; files, all paths used as patterns for both &lt;code&gt;.eslintignore&lt;/code&gt; and &lt;code&gt;--ignore-pattern&lt;/code&gt; must use forward slashes as their path separators.</source>
          <target state="translated">특히 &lt;code&gt;.gitignore&lt;/code&gt; 파일 과 마찬가지로 &lt;code&gt;.eslintignore&lt;/code&gt; 및 &lt;code&gt;--ignore-pattern&lt;/code&gt; 의 패턴으로 사용되는 모든 경로 는 슬래시를 경로 구분 기호로 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="051c540be9962a7623f661578a805c175aaad210" translate="yes" xml:space="preserve">
          <source>On a separate line, describing the code beneath it.</source>
          <target state="translated">별도의 줄에 코드를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="41a98baf04faa90e085c1d5b39d3f2303b09a371" translate="yes" xml:space="preserve">
          <source>On multiple lines, to comment out sections of code.</source>
          <target state="translated">여러 줄에서 코드 섹션을 주석 처리합니다.</target>
        </trans-unit>
        <trans-unit id="dd6bc408351897c37ede1ee1ad09032dd8381b52" translate="yes" xml:space="preserve">
          <source>On the first line, the JavaScript engine will automatically insert a semicolon, so this is not considered a syntax error. The JavaScript engine still knows how to interpret the line and knows that the line end indicates the end of the statement.</source>
          <target state="translated">첫 번째 줄에서 JavaScript 엔진은 세미콜론을 자동으로 삽입하므로 구문 오류로 간주되지 않습니다. JavaScript 엔진은 여전히 ​​라인을 해석하는 방법을 알고 있으며 라인 끝은 명령문의 끝을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="be62b8888255b7d5db97a2146275b0a473a3cd7f" translate="yes" xml:space="preserve">
          <source>On the other hand, if the code is targeting only ES5-compliant environments passing the radix &lt;code&gt;10&lt;/code&gt; may be redundant. In such a case you might want to disallow using such a radix.</source>
          <target state="translated">한편, 코드가 기수 ( &lt;code&gt;10&lt;/code&gt; )를 통과하는 ES5 호환 환경만을 목표로하는 경우 중복 될 수있다. 이러한 경우 기수 사용을 금지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54325008781cc6962735603ca0f94ac6486bda16" translate="yes" xml:space="preserve">
          <source>On the other side of the argument are those who say that since semicolons are inserted automatically, they are optional and do not need to be inserted manually. However, the ASI mechanism can also be tricky to people who don't use semicolons. For example, consider this code:</source>
          <target state="translated">반론의 반대편에는 세미콜론이 자동으로 삽입되므로 선택 사항이며 수동으로 삽입 할 필요가 없다고 말하는 사람들이 있습니다. 그러나 세미콜론을 사용하지 않는 사람들에게는 ASI 메커니즘이 까다로울 수 있습니다. 예를 들어 다음 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="96134602d9113347d1bc859098545b8dd3e69676" translate="yes" xml:space="preserve">
          <source>Once again, the intent here is to show that the developer intended for there to be no default behavior.</source>
          <target state="translated">다시 한 번, 여기서 의도는 개발자가 기본 동작이 없도록 의도했음을 보여주기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="c1de3fc4cbdd3e50999095504fb8e328eb84c3d2" translate="yes" xml:space="preserve">
          <source>Once npm is installed, run the following</source>
          <target state="translated">npm이 설치되면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="c04fc496076254cace10e1520cd55bfc500cbbe1" translate="yes" xml:space="preserve">
          <source>Once the AST is available, &lt;code&gt;estraverse&lt;/code&gt; is used to traverse the AST from top to bottom. At each node, the &lt;code&gt;Linter&lt;/code&gt; object emits an event that has the same name as the node type (i.e., &quot;Identifier&quot;, &quot;WithStatement&quot;, etc.). On the way back up the subtree, an event is emitted with the AST type name and suffixed with &quot;:exit&quot;, such as &quot;Identifier:exit&quot; - this allows rules to take action both on the way down and on the way up in the traversal. Each event is emitted with the appropriate AST node available.</source>
          <target state="translated">AST가 사용 가능하면 &lt;code&gt;estraverse&lt;/code&gt; 를 사용하여 AST를 위에서 아래로 순회합니다. 각 노드에서 &lt;code&gt;Linter&lt;/code&gt; 객체는 노드 유형과 이름이 같은 이벤트 (예 : &quot;식별자&quot;, &quot;WithStatement&quot;등)를 생성합니다. 하위 트리를 백업하는 중에는 AST 유형 이름으로 이벤트가 생성되고 &quot;Identifier : exit&quot;와 같이 &quot;: exit&quot;로 접미사가 붙습니다. 이렇게하면 규칙이 진행중인 작업과 진행중인 작업을 모두 수행 할 수 있습니다. 순회. 각 이벤트는 사용 가능한 적절한 AST 노드와 함께 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="64e40e04906a03b72ac5f6ed6329c5032886299c" translate="yes" xml:space="preserve">
          <source>Once you get a report object, it's up to you to determine how to output the results. Fixes will not be automatically applied to the files, even if you set &lt;code&gt;fix: true&lt;/code&gt; when constructing the &lt;code&gt;CLIEngine&lt;/code&gt; instance. To apply fixes to the files, call &lt;a href=&quot;#cliengineoutputfixes&quot;&gt;&lt;code&gt;outputFixes&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">보고서 개체를 얻은 후에는 결과를 출력하는 방법을 결정해야합니다. &lt;code&gt;CLIEngine&lt;/code&gt; 인스턴스를 구성 할 때 &lt;code&gt;fix: true&lt;/code&gt; 를 설정하더라도 파일에 수정 사항이 자동으로 적용되지 않습니다 . 파일에 수정 사항을 적용하려면 &lt;a href=&quot;#cliengineoutputfixes&quot;&gt; &lt;code&gt;outputFixes&lt;/code&gt; 를&lt;/a&gt; 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="b58e4b61287e965d92e76370ea203cbb83aba778" translate="yes" xml:space="preserve">
          <source>Once you have a local copy and have Node.JS and npm installed, you'll need to install the ESLint dependencies:</source>
          <target state="translated">로컬 사본이 있고 Node.JS 및 npm이 설치되면 ESLint 종속성을 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="e7288581c9fd0f9fb86a36a0098329661fafddf0" translate="yes" xml:space="preserve">
          <source>Once you have an instance of &lt;code&gt;SourceCode&lt;/code&gt;, you can use the methods on it to work with the code:</source>
          <target state="translated">&lt;code&gt;SourceCode&lt;/code&gt; 의 인스턴스가 있으면 그 메소드를 사용하여 코드 작업을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c35dc0ae3fcf2f907c56b8a61b2d1c1013797195" translate="yes" xml:space="preserve">
          <source>Once you have the configuration information, you can pass it into the &lt;code&gt;linter&lt;/code&gt; object:</source>
          <target state="translated">구성 정보가 있으면이를 &lt;code&gt;linter&lt;/code&gt; 객체 로 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b5819a1bbc0e4af2eebf7583e7e5176671549350" translate="yes" xml:space="preserve">
          <source>Once you have your development environment installed, you can make and submit changes to the ESLint source files. Doing this successfully requires careful adherence to our &lt;a href=&quot;contributing/pull-requests&quot;&gt;pull-request submission workflow&lt;/a&gt;.</source>
          <target state="translated">개발 환경이 설치되면 ESLint 소스 파일을 변경하고 제출할 수 있습니다. 이 작업을 성공적으로 수행하려면 &lt;a href=&quot;contributing/pull-requests&quot;&gt;풀 요청 제출 워크 플로우&lt;/a&gt; 를주의 깊게 준수해야합니다 .</target>
        </trans-unit>
        <trans-unit id="df1fc06bd4ba0916a355e415a08d9ac385fc744f" translate="yes" xml:space="preserve">
          <source>Once you've cloned the repository, run &lt;code&gt;npm install&lt;/code&gt; to get all the necessary dependencies:</source>
          <target state="translated">저장소를 복제 한 후 &lt;code&gt;npm install&lt;/code&gt; 을 실행 하여 필요한 모든 종속성을 가져 오십시오.</target>
        </trans-unit>
        <trans-unit id="a952bd0499233ed62352245dbdd816bb714cb93a" translate="yes" xml:space="preserve">
          <source>Once you've got ESLint running, you'll probably want to adjust the configuration to better suit your project. This section explains all the different ways you can configure ESLint.</source>
          <target state="translated">ESLint를 실행 한 후에는 프로젝트에 더 적합하도록 구성을 조정하고 싶을 것입니다. 이 섹션에서는 ESLint를 구성 할 수있는 모든 다른 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="80320c8df4e958c73560fc248b42aa546a052559" translate="yes" xml:space="preserve">
          <source>Once you've made changes that you want to share with the community, the next step is to submit those changes back via a pull request.</source>
          <target state="translated">커뮤니티와 공유하고 싶은 변경을 한 후 다음 단계는 풀 요청을 통해 변경 사항을 다시 제출하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="73e73f412681c6b3c636b32c5dd0a954ee56c9f0" translate="yes" xml:space="preserve">
          <source>Once your pull request is sent, it's time for the team to review it. As such, please make sure to:</source>
          <target state="translated">풀 요청이 전송되면 팀이이를 검토 할 때입니다. 따라서 다음을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="461bb8bc5f902440c44a097ed81d4ff591b9129d" translate="yes" xml:space="preserve">
          <source>Once your shareable config is ready, you can &lt;a href=&quot;https://docs.npmjs.com/getting-started/publishing-npm-packages&quot;&gt;publish to npm&lt;/a&gt; to share with others. We recommend using the &lt;code&gt;eslint&lt;/code&gt; and &lt;code&gt;eslintconfig&lt;/code&gt; keywords so others can easily find your module.</source>
          <target state="translated">공유 가능한 구성이 준비되면 &lt;a href=&quot;https://docs.npmjs.com/getting-started/publishing-npm-packages&quot;&gt;npm&lt;/a&gt; 에 게시하여 다른 사람들과 공유 할 수 있습니다. 다른 사용자가 쉽게 모듈을 찾을 수 있도록 &lt;code&gt;eslint&lt;/code&gt; 및 &lt;code&gt;eslintconfig&lt;/code&gt; 키워드를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="968cb18b99b4f357f4169659789d6d35558a5b6b" translate="yes" xml:space="preserve">
          <source>One blank line should always be used in the following circumstances:</source>
          <target state="translated">다음과 같은 상황에서는 항상 빈 줄 하나를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="6e05f3f48106cca4c55183384c239e9f6781eecf" translate="yes" xml:space="preserve">
          <source>One common variant of one true brace style is called Stroustrup, in which the &lt;code&gt;else&lt;/code&gt; statements in an &lt;code&gt;if-else&lt;/code&gt; construct, as well as &lt;code&gt;catch&lt;/code&gt; and &lt;code&gt;finally&lt;/code&gt;, must be on its own line after the preceding closing brace. For example:</source>
          <target state="translated">진정한 중괄호 스타일의 하나 개의 일반적인 변형이있는, 스트로브 스트 룹라고 &lt;code&gt;else&lt;/code&gt; 에 문 &lt;code&gt;if-else&lt;/code&gt; 구조뿐만 아니라 &lt;code&gt;catch&lt;/code&gt; 하고 &lt;code&gt;finally&lt;/code&gt; , 앞의 닫는 중괄호 후 자신의 행에 있어야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="074902a0b6265654f7818885f2c699f282da2808" translate="yes" xml:space="preserve">
          <source>One key is &lt;code&gt;VariableDeclarator&lt;/code&gt; and the other is &lt;code&gt;AssignmentExpression&lt;/code&gt;, which can be used to control the destructuring requirement for each of those types independently. Each property accepts an object that accepts two properties, &lt;code&gt;array&lt;/code&gt; and &lt;code&gt;object&lt;/code&gt;, which can be used to control the destructuring requirement for each of &lt;code&gt;array&lt;/code&gt; and &lt;code&gt;object&lt;/code&gt; independently for variable declarations and assignment expressions. By default, &lt;code&gt;array&lt;/code&gt; and &lt;code&gt;object&lt;/code&gt; are set to true for both &lt;code&gt;VariableDeclarator&lt;/code&gt; and &lt;code&gt;AssignmentExpression&lt;/code&gt;.</source>
          <target state="translated">하나의 키는 &lt;code&gt;VariableDeclarator&lt;/code&gt; 이고 다른 하나는 &lt;code&gt;AssignmentExpression&lt;/code&gt; 으로 , 각 유형에 대한 디스트 럭처링 요구 사항을 독립적으로 제어하는 ​​데 사용할 수 있습니다. 각 속성은 &lt;code&gt;array&lt;/code&gt; 와 &lt;code&gt;object&lt;/code&gt; 의 두 속성을 허용하는 객체를 허용합니다.이 속성은 변수 선언과 할당 표현식에 대해 개별적으로 각 &lt;code&gt;array&lt;/code&gt; 과 &lt;code&gt;object&lt;/code&gt; 대한 구조화 요구 사항을 제어하는 ​​데 사용할 수 있습니다 . 기본적으로 &lt;code&gt;array&lt;/code&gt; 과 &lt;code&gt;object&lt;/code&gt; 는 &lt;code&gt;VariableDeclarator&lt;/code&gt; 및 &lt;code&gt;AssignmentExpression&lt;/code&gt; 모두에 대해 true로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="7b40cc8090e56f00ece04fc448cb76c1a5545421" translate="yes" xml:space="preserve">
          <source>One of benefits of this option is that it prevents the incorrect use of arrow functions in conditionals:</source>
          <target state="translated">이 옵션의 장점 중 하나는 조건부에서 화살표 기능이 잘못 사용되는 것을 방지한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="91d4f19646312c60afdd6cb23f93395bc802b054" translate="yes" xml:space="preserve">
          <source>One of the benefits of this option is that it prevents the incorrect use of arrow functions in conditionals:</source>
          <target state="translated">One of the benefits of this option is that it prevents the incorrect use of arrow functions in conditionals:</target>
        </trans-unit>
        <trans-unit id="93a084e0710ce98d42a3b6895d5f4238168d8a76" translate="yes" xml:space="preserve">
          <source>One of the great things about open source projects is that anyone can contribute in any number of meaningful ways. ESLint couldn't exist without the help of the many contributors it's had since the project began, and we want you to feel like you can contribute and make a difference as well.</source>
          <target state="translated">오픈 소스 프로젝트의 가장 큰 장점 중 하나는 누구나 의미있는 방식으로 많은 기여를 할 수 있다는 것입니다. 프로젝트가 시작된 이래 많은 기여자들의 도움 없이는 ESLint가 존재할 수 없었습니다.</target>
        </trans-unit>
        <trans-unit id="8fe321b030cabb7b6a56d2b3c7ba46379fd8d541" translate="yes" xml:space="preserve">
          <source>One of the interesting, and sometimes confusing, aspects of JavaScript is that assignment can happen at almost any point. Because of this, an errant equals sign can end up causing assignment when the true intent was to do a comparison. This is especially true when using a &lt;code&gt;return&lt;/code&gt; statement. For example:</source>
          <target state="translated">JavaScript의 흥미롭고 때로는 혼란스러운 측면 중 하나는 거의 모든 시점에서 할당이 가능하다는 것입니다. 이 때문에 잘못된 의도 부호는 실제 의도가 비교를 수행 할 때 할당을 야기 할 수 있습니다. &lt;code&gt;return&lt;/code&gt; 문을 사용할 때 특히 그렇습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dc2c724cf22353a00eb4d8e0b5ec68baf78eb5ec" translate="yes" xml:space="preserve">
          <source>One of the justifications for using Comma First style is that it can help track missing and trailing commas. These are problematic because missing commas in variable declarations can lead to the leakage of global variables and trailing commas can lead to errors in older versions of IE.</source>
          <target state="translated">쉼표 첫 번째 스타일을 사용하는 데 필요한 타당성 중 하나는 누락되고 후행 쉼표를 추적 할 수 있다는 것입니다. 변수 선언에서 쉼표가 누락되면 전역 변수가 누출되고 후행 쉼표가 이전 버전의 IE에서 오류가 발생할 수 있기 때문에 문제가됩니다.</target>
        </trans-unit>
        <trans-unit id="43739dc5f4290e33b069d3cbfc858a0190a0b218" translate="yes" xml:space="preserve">
          <source>One way to fix this issue would be to ensure that &lt;code&gt;totalLength&lt;/code&gt; is read at the same time as it's updated, like this:</source>
          <target state="translated">이 문제를 해결하는 한 가지 방법 은 다음과 같이 &lt;code&gt;totalLength&lt;/code&gt; 가 업데이트되는 동시에 읽 도록하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="82d457ac979b2d749bfa1fff14b37ecb16e90d1f" translate="yes" xml:space="preserve">
          <source>Only &lt;code&gt;return&lt;/code&gt; without a value is allowed, as it's a control flow statement.</source>
          <target state="translated">제어 흐름 문이므로 값이없는 &lt;code&gt;return&lt;/code&gt; 만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="865b1b6e5f709be37accdd161c63ae845508b783" translate="yes" xml:space="preserve">
          <source>Only make one fix per message. This is enforced because you must return the result of the fixer operation from &lt;code&gt;fix()&lt;/code&gt;.</source>
          <target state="translated">메시지 당 하나만 수정하십시오. fixer 조작의 결과를 &lt;code&gt;fix()&lt;/code&gt; 에서 리턴해야하기 때문에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="651a50a7f66b3213d4ddbca3f4a04a538e94dae9" translate="yes" xml:space="preserve">
          <source>Only the &lt;code&gt;Property&lt;/code&gt; node type is ignored by default, because for the &lt;a href=&quot;key-spacing&quot;&gt;key-spacing&lt;/a&gt; rule some alignment options require multiple spaces in properties of object literals.</source>
          <target state="translated">&lt;a href=&quot;key-spacing&quot;&gt;키 간격&lt;/a&gt; 규칙의 경우 일부 정렬 옵션에는 객체 리터럴 속성에 여러 공백이 필요 하므로 &lt;code&gt;Property&lt;/code&gt; 노드 유형 만 기본적으로 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="29e0482fd1761fdd60ab2cbaa6f30278bf01c57e" translate="yes" xml:space="preserve">
          <source>Open up developer tools</source>
          <target state="translated">개발자 도구를 엽니 다</target>
        </trans-unit>
        <trans-unit id="528fa3274e8f2faac58c536989703b2a7691898b" translate="yes" xml:space="preserve">
          <source>Operator Spacing</source>
          <target state="translated">연산자 간격</target>
        </trans-unit>
        <trans-unit id="f31ac1bc0518dff16e20d2bee973046b839b0d11" translate="yes" xml:space="preserve">
          <source>Operators with two operands must be preceded and followed by a single space to make the expression clear. Operators include assignments and logical operators.</source>
          <target state="translated">피연산자가 두 개인 연산자는 앞에 공백이 있어야하고 그 뒤에식이 명확해야합니다. 연산자에는 할당 및 논리 연산자가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="5cf9f8318f166d81f0832974953640e35cb76c75" translate="yes" xml:space="preserve">
          <source>Opponents of Yoda conditions point out that tooling has made us better programmers because tools will catch the mistaken use of &lt;code&gt;=&lt;/code&gt; instead of &lt;code&gt;==&lt;/code&gt; (ESLint will catch this for you). Therefore, they argue, the utility of the pattern doesn't outweigh the readability hit the code takes while using Yoda conditions.</source>
          <target state="translated">Yoda 조건의 반대자들은 툴링이 &lt;code&gt;==&lt;/code&gt; 대신 실수로 &lt;code&gt;=&lt;/code&gt; 를 사용하기 때문에 툴링이 더 나은 프로그래머가되었다고 지적합니다 (ESLint가이를 잡을 것입니다). 따라서 그들은 패턴의 유용성이 Yoda 조건을 사용하는 동안 코드가 읽는 가독성을 초과하지 않는다고 주장합니다.</target>
        </trans-unit>
        <trans-unit id="cc2f1a7f94147f105a8901b8c9bb3f24406fa1ff" translate="yes" xml:space="preserve">
          <source>Optional Exception</source>
          <target state="translated">선택적 예외</target>
        </trans-unit>
        <trans-unit id="a89a55547173e68a8fb3ba71bad23165f06ceb9e" translate="yes" xml:space="preserve">
          <source>Optional. If &lt;code&gt;true&lt;/code&gt; is present and the &lt;code&gt;options.filePath&lt;/code&gt; is a file ESLint should ignore, this method returns a lint result contains a warning message.</source>
          <target state="translated">Optional. If &lt;code&gt;true&lt;/code&gt; is present and the &lt;code&gt;options.filePath&lt;/code&gt; is a file ESLint should ignore, this method returns a lint result contains a warning message.</target>
        </trans-unit>
        <trans-unit id="f8431df7be1c6293b85fd6c46fb7d73eae65d45c" translate="yes" xml:space="preserve">
          <source>Optional. The path to the file of the source code text. If omitted, the &lt;code&gt;result.filePath&lt;/code&gt; becomes the string &lt;code&gt;&quot;&amp;lt;text&amp;gt;&quot;&lt;/code&gt;.</source>
          <target state="translated">Optional. The path to the file of the source code text. If omitted, the &lt;code&gt;result.filePath&lt;/code&gt; becomes the string &lt;code&gt;&quot;&amp;lt;text&amp;gt;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f2085951383e2cdbc090c9683b06731c8ef7ac4" translate="yes" xml:space="preserve">
          <source>Optionally, this rule can also enforce consistent order (&lt;code&gt;getBeforeSet&lt;/code&gt; or &lt;code&gt;setBeforeGet&lt;/code&gt;).</source>
          <target state="translated">선택적으로이 규칙은 일관된 순서 ( &lt;code&gt;getBeforeSet&lt;/code&gt; 또는 &lt;code&gt;setBeforeGet&lt;/code&gt; )를 적용 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3f583032cbdd550a2873302394f975358318e3c2" translate="yes" xml:space="preserve">
          <source>Optionally, you may specify a &lt;code&gt;max&lt;/code&gt; object property:</source>
          <target state="translated">선택적으로 &lt;code&gt;max&lt;/code&gt; object 속성을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="babf5970a0d99737bb086b6569f51b231437e499" translate="yes" xml:space="preserve">
          <source>Options Schemas</source>
          <target state="translated">옵션 스키마</target>
        </trans-unit>
        <trans-unit id="125e188e5c535aba49305bcd42d96422853718e3" translate="yes" xml:space="preserve">
          <source>Options that accept array values can be specified by repeating the option or with a comma-delimited list (other than &lt;code&gt;--ignore-pattern&lt;/code&gt; which does not allow the second style).</source>
          <target state="translated">배열 값을 허용하는 옵션은 옵션을 반복하거나 쉼표로 구분 된 목록 ( 두 번째 스타일을 허용하지 않는 &lt;code&gt;--ignore-pattern&lt;/code&gt; 이외)으로 지정하여 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cc6d4354c518051842952b8b24cff75c301ac9bd" translate="yes" xml:space="preserve">
          <source>Or an object option (Requires line breaks if any of properties is satisfied. Otherwise, disallows line breaks):</source>
          <target state="translated">또는 객체 옵션 (속성이 충족되면 줄 바꿈이 필요합니다. 그렇지 않으면 줄 바꿈이 허용되지 않음) :</target>
        </trans-unit>
        <trans-unit id="48fb5dcfee6b391a00a0d645f582f3d72542e395" translate="yes" xml:space="preserve">
          <source>Or an object option:</source>
          <target state="translated">또는 객체 옵션 :</target>
        </trans-unit>
        <trans-unit id="8e04bc60d27598107203a60a335ed572e88264d3" translate="yes" xml:space="preserve">
          <source>Or for non-iterable 'array-like' objects:</source>
          <target state="translated">또는 반복 불가능한 '배열과 같은'객체의 경우 :</target>
        </trans-unit>
        <trans-unit id="8b117f5f38fcd06ba55849762c28b3c6a4df0d38" translate="yes" xml:space="preserve">
          <source>Or for tabbed indentation:</source>
          <target state="translated">또는 탭 들여 쓰기</target>
        </trans-unit>
        <trans-unit id="534b36ed6d3baf1cd0fb88cab59bd33364f67414" translate="yes" xml:space="preserve">
          <source>Or in a &lt;code&gt;package.json&lt;/code&gt; file</source>
          <target state="translated">또는 &lt;code&gt;package.json&lt;/code&gt; 파일에서</target>
        </trans-unit>
        <trans-unit id="983504f1db047b4a14f090593364eea27f5c86b0" translate="yes" xml:space="preserve">
          <source>Or you can enforce that calls to &lt;code&gt;setTimeout&lt;/code&gt; always have two arguments:</source>
          <target state="translated">또는 &lt;code&gt;setTimeout&lt;/code&gt; 호출에 항상 두 개의 인수가 있도록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2349626c15ba88b850dda985180df347efff61da" translate="yes" xml:space="preserve">
          <source>Originally, &lt;code&gt;Variable&lt;/code&gt; objects and &lt;code&gt;Reference&lt;/code&gt; objects refer each other:</source>
          <target state="translated">원래 &lt;code&gt;Variable&lt;/code&gt; 객체와 &lt;code&gt;Reference&lt;/code&gt; 객체는 서로를 참조 합니다.</target>
        </trans-unit>
        <trans-unit id="0c7f2d70c0ac6c087885c2e18648286544190997" translate="yes" xml:space="preserve">
          <source>Other Integration Lists</source>
          <target state="translated">다른 통합 목록</target>
        </trans-unit>
        <trans-unit id="121423f7955be6f99034dbe35e9109d534d3bb31" translate="yes" xml:space="preserve">
          <source>Other code conventions allow you to skip the &lt;code&gt;default&lt;/code&gt; case so long as there is a comment indicating the omission is intentional, such as:</source>
          <target state="translated">다른 코드 규칙에서는 다음 과 같이 생략을 의도적으로 나타내는 주석이있는 경우 &lt;code&gt;default&lt;/code&gt; 사례 를 건너 뛸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c413664d095ba6eda32b2e5180bd3f63ad775b0e" translate="yes" xml:space="preserve">
          <source>Others prefer to declare one var per line.</source>
          <target state="translated">다른 사람들은 한 줄에 하나의 var를 선언하는 것을 선호합니다.</target>
        </trans-unit>
        <trans-unit id="777e3867f41cdcbbc95d8a27831735e4439631d1" translate="yes" xml:space="preserve">
          <source>Otherwise are considered problems.</source>
          <target state="translated">그렇지 않으면 문제로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="8f226c4b9fa003489fea8332ce25c85c4ade2f50" translate="yes" xml:space="preserve">
          <source>Otherwise the &lt;code&gt;&quot;safe&quot;&lt;/code&gt; option corresponds to the &lt;code&gt;&quot;function&quot;&lt;/code&gt; option. Note that if &lt;code&gt;&quot;globalReturn&quot;: false&lt;/code&gt; is explicitly specified in the configuration, the &lt;code&gt;&quot;safe&quot;&lt;/code&gt; option will correspond to the &lt;code&gt;&quot;function&quot;&lt;/code&gt; option regardless of the specified environment.</source>
          <target state="translated">그렇지 않으면 &lt;code&gt;&quot;safe&quot;&lt;/code&gt; 옵션은 &lt;code&gt;&quot;function&quot;&lt;/code&gt; 옵션에 해당합니다 . 경우주의 &lt;code&gt;&quot;globalReturn&quot;: false&lt;/code&gt; 명시 적 구성에 지정되면, &lt;code&gt;&quot;safe&quot;&lt;/code&gt; 옵션은에 해당한다 &lt;code&gt;&quot;function&quot;&lt;/code&gt; 에 관계없이 지정된 환경의 옵션을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="0b2741d82e791a60bad1a8621fcdbf97b20d60b3" translate="yes" xml:space="preserve">
          <source>Otherwise, &lt;code&gt;RuleTester#run&lt;/code&gt; will simply execute all of the tests in sequence, and will throw an error if one of them fails. This means you can simply execute a test file that calls &lt;code&gt;RuleTester.run&lt;/code&gt; using &lt;code&gt;node&lt;/code&gt;, without needing a testing framework.</source>
          <target state="translated">그렇지 않으면 &lt;code&gt;RuleTester#run&lt;/code&gt; 은 모든 테스트를 순서대로 실행하며 그 중 하나가 실패하면 오류를 발생시킵니다. 즉 , 테스트 프레임 워크없이 &lt;code&gt;node&lt;/code&gt; 를 사용하여 &lt;code&gt;RuleTester.run&lt;/code&gt; 을 호출하는 테스트 파일을 간단히 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="da453deb49d685f98fdc9eee6730a3db89861b4f" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;code&gt;describe&lt;/code&gt; and &lt;code&gt;it&lt;/code&gt; are present as globals, &lt;code&gt;RuleTester&lt;/code&gt; will use &lt;code&gt;global.describe&lt;/code&gt; and &lt;code&gt;global.it&lt;/code&gt; to run tests. This allows &lt;code&gt;RuleTester&lt;/code&gt; to work when using frameworks like &lt;a href=&quot;https://mochajs.org/&quot;&gt;Mocha&lt;/a&gt; without any additional configuration.</source>
          <target state="translated">그렇지 않으면, &lt;code&gt;describe&lt;/code&gt; 과 &lt;code&gt;it&lt;/code&gt; 전역와 같은 존재, &lt;code&gt;RuleTester&lt;/code&gt; 는 사용 &lt;code&gt;global.describe&lt;/code&gt; 을 하고 &lt;code&gt;global.it&lt;/code&gt; 테스트를 실행합니다. 따라서 추가 구성없이 &lt;a href=&quot;https://mochajs.org/&quot;&gt;Mocha&lt;/a&gt; 와 같은 프레임 워크를 사용할 때 &lt;code&gt;RuleTester&lt;/code&gt; 가 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f111dde36a2183fb8b31d84bb35478c7ad28ae40" translate="yes" xml:space="preserve">
          <source>Otherwise, if the node does not declare any variables, an empty array is returned.</source>
          <target state="translated">그렇지 않으면 노드가 변수를 선언하지 않으면 빈 배열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="112f84fde1efd0a6b137f4ef4aeed3c549b08bd5" translate="yes" xml:space="preserve">
          <source>Our commit message format is as follows:</source>
          <target state="translated">커밋 메시지 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="874ef7e39663f7db82348ed922daa965002f8637" translate="yes" xml:space="preserve">
          <source>Our public &lt;a href=&quot;https://github.com/eslint/eslint/issues&quot;&gt;issues tracker&lt;/a&gt; lists all of the things we plan on doing as well as suggestions from the community. Before starting to work on an issue, be sure you read through the rest of this page.</source>
          <target state="translated">우리의 공개 &lt;a href=&quot;https://github.com/eslint/eslint/issues&quot;&gt;이슈 트래커&lt;/a&gt; 는 우리가 계획 한 모든 것들과 커뮤니티의 제안을 나열합니다. 문제에 대한 작업을 시작하기 전에이 페이지의 나머지 부분을 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="4bed336194a9a5c86b6a734f03b3570d2aae1a68" translate="yes" xml:space="preserve">
          <source>Output</source>
          <target state="translated">Output</target>
        </trans-unit>
        <trans-unit id="50d578ebf4e00d8649eb4f95a59bf792edcd3b16" translate="yes" xml:space="preserve">
          <source>Output Examples</source>
          <target state="translated">출력 예</target>
        </trans-unit>
        <trans-unit id="f721699fc008a02ac10d406435648374991b8df2" translate="yes" xml:space="preserve">
          <source>Output object from this method:</source>
          <target state="translated">이 메소드의 출력 오브젝트 :</target>
        </trans-unit>
        <trans-unit id="2ae3c877f13160bf4fb915afd2aa35c94e464b88" translate="yes" xml:space="preserve">
          <source>Output to the console</source>
          <target state="translated">콘솔로 출력</target>
        </trans-unit>
        <trans-unit id="afb6b4b6cae2618f58f61a3533c0fccfc233090f" translate="yes" xml:space="preserve">
          <source>Outputting to the console</source>
          <target state="translated">콘솔로 출력</target>
        </trans-unit>
        <trans-unit id="afdf6e15c0ce33e13907329dd18f3fa61951053c" translate="yes" xml:space="preserve">
          <source>Outputting to the filesystem</source>
          <target state="translated">파일 시스템으로 출력</target>
        </trans-unit>
        <trans-unit id="744acdca9924738f6ba20a057659f4dab8956cfb" translate="yes" xml:space="preserve">
          <source>Over the past several releases, we have been deprecating rules and introducing new rules to take their place. The following is a list of the removed rules and their replacements:</source>
          <target state="translated">지난 몇 가지 릴리스에서 우리는 규칙을 더 이상 사용하지 않고 새로운 규칙을 도입했습니다. 다음은 제거 된 규칙 및 대체 목록입니다.</target>
        </trans-unit>
        <trans-unit id="f15e25b67d56c0b50f6e65a89912cb8c44445c60" translate="yes" xml:space="preserve">
          <source>Overall Performance</source>
          <target state="translated">전반적인 성능</target>
        </trans-unit>
        <trans-unit id="bed3eb091eb6a1e8a3c68cc9f2b8cad9f0ea7e35" translate="yes" xml:space="preserve">
          <source>Override blocks can also specify patterns to exclude from matches. If a file matches any of the excluded patterns, the configuration won't apply.</source>
          <target state="translated">재정의 블록은 일치 항목에서 제외 할 패턴을 지정할 수도 있습니다. 파일이 제외 된 패턴과 일치하면 구성이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d65d233ad72a12dd5f816f689346ed699f068f74" translate="yes" xml:space="preserve">
          <source>Overrides in a config file can now match dotfiles</source>
          <target state="translated">구성 파일의 재정의는 이제 점 파일과 일치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7279b45cea6645bd003b55c34e4e0b68128806b" translate="yes" xml:space="preserve">
          <source>Overrides in an extended config file can now be overridden by a parent config file</source>
          <target state="translated">확장 구성 파일의 재정의를 상위 구성 파일로 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84e380bd7906ce369799455bb337baa4a7e912c3" translate="yes" xml:space="preserve">
          <source>Packaging the Custom Formatter</source>
          <target state="translated">커스텀 포맷터 패키징</target>
        </trans-unit>
        <trans-unit id="a975eea30db9fa05003e3b5097688bd49ec7e01b" translate="yes" xml:space="preserve">
          <source>Parameters</source>
          <target state="translated">Parameters</target>
        </trans-unit>
        <trans-unit id="0a0e056314281df7ebe5bff4801d78e2bcb2e0da" translate="yes" xml:space="preserve">
          <source>Parentheses Spacing</source>
          <target state="translated">괄호 간격</target>
        </trans-unit>
        <trans-unit id="8b047ea57f8d4953d13e87c42cd0dfbacf8b9d4e" translate="yes" xml:space="preserve">
          <source>Passing Arguments to Formatters</source>
          <target state="translated">포맷터에 인수 전달</target>
        </trans-unit>
        <trans-unit id="bbad3fbb9280e935e855b557b50f0feb18c726b1" translate="yes" xml:space="preserve">
          <source>Passing the callback by reference</source>
          <target state="translated">참조로 콜백 전달</target>
        </trans-unit>
        <trans-unit id="866764460d5b328ce01c5d25fea87d4f72c58d7e" translate="yes" xml:space="preserve">
          <source>Path to the cache file. If none specified &lt;code&gt;.eslintcache&lt;/code&gt; will be used. The file will be created in the directory where the &lt;code&gt;eslint&lt;/code&gt; command is executed. &lt;strong&gt;Deprecated&lt;/strong&gt;: Use &lt;code&gt;--cache-location&lt;/code&gt; instead.</source>
          <target state="translated">캐시 파일의 경로입니다. 지정하지 않으면 &lt;code&gt;.eslintcache&lt;/code&gt; 가 사용됩니다. &lt;code&gt;eslint&lt;/code&gt; 명령이 실행되는 디렉토리에 파일이 작성됩니다 . &lt;strong&gt;더 이상 사용되지 않음&lt;/strong&gt; : 대신 &lt;code&gt;--cache-location&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="1a4f2472b12ffd8aaa283f1912f4a749bb112a9e" translate="yes" xml:space="preserve">
          <source>Path to the cache location. Can be a file or a directory. If no location is specified, &lt;code&gt;.eslintcache&lt;/code&gt; will be used. In that case, the file will be created in the directory where the &lt;code&gt;eslint&lt;/code&gt; command is executed.</source>
          <target state="translated">캐시 위치에 대한 경로입니다. 파일 또는 디렉토리 일 수 있습니다. 위치를 지정하지 않으면 &lt;code&gt;.eslintcache&lt;/code&gt; 가 사용됩니다. 이 경우 파일은 &lt;code&gt;eslint&lt;/code&gt; 명령이 실행되는 디렉토리에 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="9cf1a4ce359a6f23066671fb0ce9dcb0cf168d6e" translate="yes" xml:space="preserve">
          <source>Paths are relative to &lt;code&gt;.eslintignore&lt;/code&gt; location or the current working directory. This is also true of paths passed in via the &lt;code&gt;--ignore-pattern&lt;/code&gt;&lt;a href=&quot;command-line-interface#--ignore-pattern&quot;&gt;command&lt;/a&gt;.</source>
          <target state="translated">경로는 &lt;code&gt;.eslintignore&lt;/code&gt; 위치 또는 현재 작업 디렉토리에 상대적 입니다. &lt;code&gt;--ignore-pattern&lt;/code&gt; &lt;a href=&quot;command-line-interface#--ignore-pattern&quot;&gt;명령&lt;/a&gt; 을 통해 전달 된 경로에서도 마찬가지입니다 .</target>
        </trans-unit>
        <trans-unit id="be2e483ed2197aec27cb04e7cf1f6436f2920c5c" translate="yes" xml:space="preserve">
          <source>Paths are relative to the current working directory. This is also true of paths passed in via the &lt;code&gt;--ignore-pattern&lt;/code&gt;&lt;a href=&quot;command-line-interface#--ignore-pattern&quot;&gt;command&lt;/a&gt;.</source>
          <target state="translated">Paths are relative to the current working directory. This is also true of paths passed in via the &lt;code&gt;--ignore-pattern&lt;/code&gt; &lt;a href=&quot;command-line-interface#--ignore-pattern&quot;&gt;command&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="0493aae6aa03f23cee93bbaad9b496620e893832" translate="yes" xml:space="preserve">
          <source>Peer Dependency</source>
          <target state="translated">동료 의존성</target>
        </trans-unit>
        <trans-unit id="d4a170a4c994882082963476d79b1a77b04c7ae7" translate="yes" xml:space="preserve">
          <source>Per-rule Performance</source>
          <target state="translated">규칙 별 성능</target>
        </trans-unit>
        <trans-unit id="ed363adcc6ae50f9e2d44c956c484ce493017156" translate="yes" xml:space="preserve">
          <source>Perform any asynchronous operations</source>
          <target state="translated">비동기 작업 수행</target>
        </trans-unit>
        <trans-unit id="9b69332b09b8aef3669c8068b4744d1b0de90bdd" translate="yes" xml:space="preserve">
          <source>Performance Testing</source>
          <target state="translated">성능 시험</target>
        </trans-unit>
        <trans-unit id="be4da6f0c7a2438c9087ddd0f224ce1c2084f2f0" translate="yes" xml:space="preserve">
          <source>Performing an operation on each element of an iterable is a common task. However, performing an &lt;code&gt;await&lt;/code&gt; as part of each operation is an indication that the program is not taking full advantage of the parallelization benefits of &lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt;.</source>
          <target state="translated">iterable의 각 요소에 대해 작업을 수행하는 것은 일반적인 작업입니다. 그러나 각 작업의 일부로 &lt;code&gt;await&lt;/code&gt; 를 수행 한다는 것은 프로그램이 &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; 의 병렬화 이점을 충분히 활용하지 않음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="95901ce3386d6d8922a77162d48436823c7874d9" translate="yes" xml:space="preserve">
          <source>Personal Configuration File (deprecated)</source>
          <target state="translated">개인 구성 파일 (더 이상 사용되지 않음)</target>
        </trans-unit>
        <trans-unit id="df4e75f6b932e3d5f6b66dcca11234789a64b98d" translate="yes" xml:space="preserve">
          <source>Piping Code Into ESLint</source>
          <target state="translated">ESLint에 파이핑 코드</target>
        </trans-unit>
        <trans-unit id="06f50881a755583b161af4399bd829f0111ebe4f" translate="yes" xml:space="preserve">
          <source>Place all of your runtime rules in the same directory (e.g., &lt;code&gt;eslint_rules&lt;/code&gt;).</source>
          <target state="translated">모든 런타임 규칙을 동일한 디렉토리 (예 : &lt;code&gt;eslint_rules&lt;/code&gt; ) 에 두십시오 .</target>
        </trans-unit>
        <trans-unit id="31ccc366a57c10600d02a87ddb1627ad8fcf83e4" translate="yes" xml:space="preserve">
          <source>Place all of your runtime rules in the same directory (i.e., &lt;code&gt;eslint_rules&lt;/code&gt;).</source>
          <target state="translated">모든 런타임 규칙을 동일한 디렉토리 (예 : &lt;code&gt;eslint_rules&lt;/code&gt; ) 에 두십시오 .</target>
        </trans-unit>
        <trans-unit id="92009e0d6a0520471a107f4e981c2e736fb0840b" translate="yes" xml:space="preserve">
          <source>Placeholders in suggestion messages</source>
          <target state="translated">제안 메시지의 자리 표시 자</target>
        </trans-unit>
        <trans-unit id="e51396525bede24fbfd195365328421b2712f903" translate="yes" xml:space="preserve">
          <source>Please include as much detail as possible to help us properly address your issue. If we need to triage issues and constantly ask people for more detail, that's time taken away from actually fixing issues. Help us be as efficient as possible by including a lot of detail in your issues.</source>
          <target state="translated">문제를 올바르게 해결하는 데 도움이되도록 최대한 자세하게 설명해주세요. 문제를 심사하고 지속적으로 사람들에게 더 자세한 정보를 요청해야하는 경우 실제로 문제를 해결하는 데 시간이 걸립니다. 귀하의 문제에 많은 세부 사항을 포함시켜 최대한 효율적으로 도와주십시오.</target>
        </trans-unit>
        <trans-unit id="8fe040cc7654341f94ac91393bb05581350df1ab" translate="yes" xml:space="preserve">
          <source>Please note that &lt;code&gt;&quot;always&quot;&lt;/code&gt; and &lt;code&gt;&quot;as-needed&quot;&lt;/code&gt; require function expressions and function declarations in &lt;code&gt;export default&lt;/code&gt; declarations to have a name.</source>
          <target state="translated">Please note that &lt;code&gt;&quot;always&quot;&lt;/code&gt; and &lt;code&gt;&quot;as-needed&quot;&lt;/code&gt; require function expressions and function declarations in &lt;code&gt;export default&lt;/code&gt; declarations to have a name.</target>
        </trans-unit>
        <trans-unit id="58942fbcaefe941982699b63620879d5c168e499" translate="yes" xml:space="preserve">
          <source>Please note that &lt;code&gt;data&lt;/code&gt; in a test case does not assert &lt;code&gt;data&lt;/code&gt; passed to &lt;code&gt;context.report&lt;/code&gt;. Instead, it is used to form the expected message text which is then compared with the received &lt;code&gt;message&lt;/code&gt;.</source>
          <target state="translated">Please note that &lt;code&gt;data&lt;/code&gt; in a test case does not assert &lt;code&gt;data&lt;/code&gt; passed to &lt;code&gt;context.report&lt;/code&gt; . Instead, it is used to form the expected message text which is then compared with the received &lt;code&gt;message&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2dd72b1131b99a3809611bb27561465f891b142" translate="yes" xml:space="preserve">
          <source>Please note that most editors show an additional empty line at the end if the file ends with a line break. This rule does not count that extra line.</source>
          <target state="translated">Please note that most editors show an additional empty line at the end if the file ends with a line break. This rule does not count that extra line.</target>
        </trans-unit>
        <trans-unit id="cd6cb4e45c0a145bc991dcd0e8f4ab88f39165d4" translate="yes" xml:space="preserve">
          <source>Please note that supporting JSX syntax is not the same as supporting React. React applies specific semantics to JSX syntax that ESLint doesn't recognize. We recommend using &lt;a href=&quot;https://github.com/yannickcr/eslint-plugin-react&quot;&gt;eslint-plugin-react&lt;/a&gt; if you are using React and want React semantics. By the same token, supporting ES6 syntax is not the same as supporting new ES6 globals (e.g., new types such as &lt;code&gt;Set&lt;/code&gt;). For ES6 syntax, use &lt;code&gt;{ &quot;parserOptions&quot;: { &quot;ecmaVersion&quot;: 6 } }&lt;/code&gt;; for new ES6 global variables, use &lt;code&gt;{ &quot;env&quot;: { &quot;es6&quot;: true } }&lt;/code&gt;. &lt;code&gt;{ &quot;env&quot;: { &quot;es6&quot;: true } }&lt;/code&gt; enables ES6 syntax automatically, but &lt;code&gt;{ &quot;parserOptions&quot;: { &quot;ecmaVersion&quot;: 6 } }&lt;/code&gt; does not enable ES6 globals automatically. Parser options are set in your &lt;code&gt;.eslintrc.*&lt;/code&gt; file by using the &lt;code&gt;parserOptions&lt;/code&gt; property. The available options are:</source>
          <target state="translated">JSX 구문 지원은 React 지원과 다릅니다. React는 ESLint가 인식하지 못하는 JSX 구문에 특정 의미를 적용합니다. React를 사용하고 있고 React 의미 를 &lt;a href=&quot;https://github.com/yannickcr/eslint-plugin-react&quot;&gt;원하면 eslint-plugin-react를&lt;/a&gt; 사용하는 것이 좋습니다 . 같은 토큰으로 ES6 구문을 지원하는 것은 새로운 ES6 전역 (예 : &lt;code&gt;Set&lt;/code&gt; 과 같은 새로운 유형)을 지원하는 것과 다릅니다 . ES6 구문의 경우 &lt;code&gt;{ &quot;parserOptions&quot;: { &quot;ecmaVersion&quot;: 6 } }&lt;/code&gt; ; 새로운 ES6 전역 변수의 경우 &lt;code&gt;{ &quot;env&quot;: { &quot;es6&quot;: true } }&lt;/code&gt; . &lt;code&gt;{ &quot;env&quot;: { &quot;es6&quot;: true } }&lt;/code&gt; 은 ES6 구문을 자동으로 활성화하지만 &lt;code&gt;{ &quot;parserOptions&quot;: { &quot;ecmaVersion&quot;: 6 } }&lt;/code&gt; 은 ES6 전역을 자동으로 활성화하지 않습니다.파서 옵션은 &lt;code&gt;.eslintrc.*&lt;/code&gt; &lt;code&gt;parserOptions&lt;/code&gt; 속성 을 사용하여 사용 가능한 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="caa1e575508ae90c0c1f3ba9cbc5f1d6c3021954" translate="yes" xml:space="preserve">
          <source>Please note that the following methods have been deprecated and will be removed in a future version of ESLint:</source>
          <target state="translated">다음 방법은 더 이상 사용되지 않으며 향후 ESLint 버전에서 제거 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="32dcca51ba22590cfb1a0282165e0b20b80790ba" translate="yes" xml:space="preserve">
          <source>Please note that this option applies only to identifiers inside destructuring patterns. It doesn't additionally allow any particular use of the created variables later in the code apart from the use that is already allowed by default or by other options.</source>
          <target state="translated">이 옵션은 파괴 패턴 내부의 식별자에만 적용됩니다. 또한 기본적으로 또는 다른 옵션에 의해 이미 허용 된 사용과는 별도로 코드에서 나중에 생성 된 변수의 특정 사용을 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2d2fdf1d62a3776fdec8b729a28be6e793bf8d2a" translate="yes" xml:space="preserve">
          <source>Please note that this rule does not compare conditions from the chain with conditions inside statements, and will not warn in the cases such as follows:</source>
          <target state="translated">이 규칙은 체인의 조건과 진술 내부의 조건을 비교하지 않으며 다음과 같은 경우에는 경고하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="970fbd12b618363bade0db3e52057a632da36216" translate="yes" xml:space="preserve">
          <source>Please note that when passing a glob as a parameter, it will be expanded by your shell. The results of the expansion can vary depending on your shell, and its configuration. If you want to use node &lt;code&gt;glob&lt;/code&gt; syntax, you have to quote your parameter (using double quotes if you need it to run in Windows), as follows:</source>
          <target state="translated">glob를 매개 변수로 전달할 때 쉘에 의해 확장됩니다. 확장 결과는 쉘 및 구성에 따라 달라질 수 있습니다. 노드 &lt;code&gt;glob&lt;/code&gt; 구문 을 사용하려면 다음과 같이 매개 변수를 인용해야합니다 (Windows에서 실행해야하는 경우 큰 따옴표를 사용).</target>
        </trans-unit>
        <trans-unit id="7e110a34a2db33270f753e46f8b7ab8a3821147b" translate="yes" xml:space="preserve">
          <source>Please note that you can either use the top-level options or the grouped options (&lt;code&gt;singleLine&lt;/code&gt; and &lt;code&gt;multiLine&lt;/code&gt;) but not both.</source>
          <target state="translated">최상위 옵션 또는 그룹화 된 옵션 ( &lt;code&gt;singleLine&lt;/code&gt; 및 &lt;code&gt;multiLine&lt;/code&gt; )을 사용할 수 있지만 둘 다 사용할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="a115fb1f05052d949674b5ad9f4dd54cca5e205b" translate="yes" xml:space="preserve">
          <source>Please note that you have to provide &lt;code&gt;data&lt;/code&gt; on the suggestion's object. Suggestion messages cannot use properties from the overall error's &lt;code&gt;data&lt;/code&gt;.</source>
          <target state="translated">제안의 대상에 대한 &lt;code&gt;data&lt;/code&gt; 를 제공해야 합니다. 제안 메시지는 전체 오류 &lt;code&gt;data&lt;/code&gt; 의 속성을 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="8131e2054fa3d6ce5d0136ddb8d6ac107226cb3a" translate="yes" xml:space="preserve">
          <source>Please read the user guide's section on &lt;a href=&quot;../user-guide/configuring#specifying-parser-options&quot;&gt;configuring parser options&lt;/a&gt; to learn more.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;../user-guide/configuring#specifying-parser-options&quot;&gt;구문 분석기 옵션 구성&lt;/a&gt; 에 대한 사용자 안내서 섹션을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="4e9e14b73e813f94faf81a7bf4b8e790aeed433c" translate="yes" xml:space="preserve">
          <source>Please see &lt;code&gt;.gitignore&lt;/code&gt;'s specification for further examples of valid syntax.</source>
          <target state="translated">유효한 구문의 추가 예제는 &lt;code&gt;.gitignore&lt;/code&gt; 의 사양을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="910be8bbebe15605e3211e93adb45fe019aed843" translate="yes" xml:space="preserve">
          <source>Please see the &lt;a href=&quot;https://github.com/eslint/generator-eslint&quot;&gt;generator documentation&lt;/a&gt; for instructions on how to use it.</source>
          <target state="translated">사용 방법에 대한 지침 은 &lt;a href=&quot;https://github.com/eslint/generator-eslint&quot;&gt;생성기 설명서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2c576146a981b5faae12b330f7bab5f655d4de92" translate="yes" xml:space="preserve">
          <source>Plugin authors may need to update installation instructions</source>
          <target state="translated">플러그인 작성자는 설치 지침을 업데이트해야 할 수도 있습니다</target>
        </trans-unit>
        <trans-unit id="e3b560171bc6f34e81c89e0ab2f15568841517f3" translate="yes" xml:space="preserve">
          <source>Plugin environments can define the following objects:</source>
          <target state="translated">플러그인 환경은 다음 객체를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fbbbaf384cbc0ee72d4f8c606fcf5d504bca04e" translate="yes" xml:space="preserve">
          <source>Plugins No Longer Have Default Configurations</source>
          <target state="translated">더 이상 기본 구성이없는 플러그인</target>
        </trans-unit>
        <trans-unit id="7b2f2b7399c496bf73ff7e69192e8907b6ce6f81" translate="yes" xml:space="preserve">
          <source>Plugins and shareable configs are no longer affected by ESLint's location</source>
          <target state="translated">플러그인 및 공유 가능한 구성은 더 이상 ESLint의 위치에 영향을받지 않습니다</target>
        </trans-unit>
        <trans-unit id="6b2a2fcf74ee4cecce3ba1b5cd83e800b49e72b4" translate="yes" xml:space="preserve">
          <source>Plugins are resolved relative to the config file. In other words, ESLint will load the plugin as a user would obtain by running &lt;code&gt;require('eslint-plugin-pluginname')&lt;/code&gt; in the config file.</source>
          <target state="translated">Plugins are resolved relative to the config file. In other words, ESLint will load the plugin as a user would obtain by running &lt;code&gt;require('eslint-plugin-pluginname')&lt;/code&gt; in the config file.</target>
        </trans-unit>
        <trans-unit id="ee9003d71c823216744370af56f21413e11f9752" translate="yes" xml:space="preserve">
          <source>Plugins can expose additional environments for use in ESLint. To do so, the plugin must export an &lt;code&gt;environments&lt;/code&gt; object. The keys of the &lt;code&gt;environments&lt;/code&gt; object are the names of the different environments provided and the values are the environment settings. For example:</source>
          <target state="translated">플러그인은 ESLint에서 사용하기 위해 추가 환경을 노출 할 수 있습니다. 그렇게하려면 플러그인이 &lt;code&gt;environments&lt;/code&gt; 객체를 내 보내야 합니다. &lt;code&gt;environments&lt;/code&gt; 오브젝트 의 키는 제공된 다른 환경의 이름이며 값은 환경 설정입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dec281e97d018cacc13382cfc427e305389a0405" translate="yes" xml:space="preserve">
          <source>Plugins can expose additional rules for use in ESLint. To do so, the plugin must export a &lt;code&gt;rules&lt;/code&gt; object containing a key-value mapping of rule ID to rule. The rule ID does not have to follow any naming convention (so it can just be &lt;code&gt;dollar-sign&lt;/code&gt;, for instance).</source>
          <target state="translated">플러그인은 ESLint에서 사용하기위한 추가 규칙을 노출 할 수 있습니다. 이를 위해 플러그인 은 규칙 ID와 규칙의 키-값 매핑이 포함 된 &lt;code&gt;rules&lt;/code&gt; 객체를 내 보내야합니다 . 규칙 ID는 이름 지정 규칙을 따를 필요가 없습니다 ( 예 : &lt;code&gt;dollar-sign&lt;/code&gt; 일 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="b69b69c3f7bf908cf04b17050967f012181e0472" translate="yes" xml:space="preserve">
          <source>Plugins in scoped packages are now resolvable in configs</source>
          <target state="translated">범위가 지정된 패키지의 플러그인은 이제 구성에서 해석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06ed5affa3a994c517d473c69ea0a4badefd02a1" translate="yes" xml:space="preserve">
          <source>Plugins in the base configuration (loaded by &lt;code&gt;extends&lt;/code&gt; setting) are relative to the derived config file. For example, if &lt;code&gt;./.eslintrc&lt;/code&gt; has &lt;code&gt;extends: [&quot;foo&quot;]&lt;/code&gt; and the &lt;code&gt;eslint-config-foo&lt;/code&gt; has &lt;code&gt;plugins: [&quot;bar&quot;]&lt;/code&gt;, ESLint finds the &lt;code&gt;eslint-plugin-bar&lt;/code&gt; from &lt;code&gt;./node_modules/&lt;/code&gt; (rather than &lt;code&gt;./node_modules/eslint-config-foo/node_modules/&lt;/code&gt;) or ancestor directories. Thus every plugin in the config file and base configurations is resolved uniquely.</source>
          <target state="translated">Plugins in the base configuration (loaded by &lt;code&gt;extends&lt;/code&gt; setting) are relative to the derived config file. For example, if &lt;code&gt;./.eslintrc&lt;/code&gt; has &lt;code&gt;extends: [&quot;foo&quot;]&lt;/code&gt; and the &lt;code&gt;eslint-config-foo&lt;/code&gt; has &lt;code&gt;plugins: [&quot;bar&quot;]&lt;/code&gt; , ESLint finds the &lt;code&gt;eslint-plugin-bar&lt;/code&gt; from &lt;code&gt;./node_modules/&lt;/code&gt; (rather than &lt;code&gt;./node_modules/eslint-config-foo/node_modules/&lt;/code&gt; ) or ancestor directories. Thus every plugin in the config file and base configurations is resolved uniquely.</target>
        </trans-unit>
        <trans-unit id="f9ec5b88d6b7fe33abdb0cd312d875b7aee0a01e" translate="yes" xml:space="preserve">
          <source>Plugins may provide processors. Processors can extract JavaScript code from another kind of files, then lets ESLint lint the JavaScript code. Or processors can convert JavaScript code in preprocessing for some purpose.</source>
          <target state="translated">플러그인은 프로세서를 제공 할 수 있습니다. 프로세서는 다른 종류의 파일에서 JavaScript 코드를 추출한 다음 ESLint가 JavaScript 코드를 보풀이 할 수 있습니다. 또는 프로세서가 특정 목적으로 전처리에서 JavaScript 코드를 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04de60818b1275febaa49d420056bd8ab7e76e8e" translate="yes" xml:space="preserve">
          <source>Polyjuice works with JSON configuration files, so if you're using a JavaScript or YAML JSCS configuration file, you should first convert it into a JSON configuration file.</source>
          <target state="translated">Polyjuice는 JSON 구성 파일과 함께 작동하므로 JavaScript 또는 YAML JSCS 구성 파일을 사용하는 경우 먼저 JSON 구성 파일로 변환해야합니다.</target>
        </trans-unit>
        <trans-unit id="4db8807336771db69984fb33e2ecb89b2b778d76" translate="yes" xml:space="preserve">
          <source>Possible Errors</source>
          <target state="translated">가능한 오류</target>
        </trans-unit>
        <trans-unit id="51e379f50f0321cddf83015a5392ece47d742feb" translate="yes" xml:space="preserve">
          <source>Prefer destructuring from arrays and objects (prefer-destructuring)</source>
          <target state="translated">배열과 객체에서 구조 제거를 선호합니다 (구조 제거 선호)</target>
        </trans-unit>
        <trans-unit id="c228b3216b65c6046a15d3f0b6ae1deea05d3ecb" translate="yes" xml:space="preserve">
          <source>Prefer use of an object spread over &lt;code&gt;Object.assign&lt;/code&gt; (prefer-object-spread)</source>
          <target state="translated">&lt;code&gt;Object.assign&lt;/code&gt; (object-spread) 보다 분산 된 객체 사용을 선호</target>
        </trans-unit>
        <trans-unit id="ad7e776a42690874c6d781cece37cffe753da846" translate="yes" xml:space="preserve">
          <source>Prerequisites: &lt;a href=&quot;https://nodejs.org/en/&quot;&gt;Node.js&lt;/a&gt; (&lt;code&gt;^10.12.0&lt;/code&gt;, or &lt;code&gt;&amp;gt;=12.0.0&lt;/code&gt;) built with SSL support. (If you are using an official Node.js distribution, SSL is always built in.)</source>
          <target state="translated">Prerequisites: &lt;a href=&quot;https://nodejs.org/en/&quot;&gt;Node.js&lt;/a&gt; ( &lt;code&gt;^10.12.0&lt;/code&gt; , or &lt;code&gt;&amp;gt;=12.0.0&lt;/code&gt; ) built with SSL support. (If you are using an official Node.js distribution, SSL is always built in.)</target>
        </trans-unit>
        <trans-unit id="82062f1465f3be0589e9c94efa76e989985103e4" translate="yes" xml:space="preserve">
          <source>Prerequisites: &lt;a href=&quot;https://nodejs.org/en/&quot;&gt;Node.js&lt;/a&gt; (&lt;code&gt;^8.10.0&lt;/code&gt;, &lt;code&gt;^10.13.0&lt;/code&gt;, or &lt;code&gt;&amp;gt;=11.10.1&lt;/code&gt;) built with SSL support. (If you are using an official Node.js distribution, SSL is always built in.)</source>
          <target state="translated">전제 조건 : SSL 지원으로 빌드 된 &lt;a href=&quot;https://nodejs.org/en/&quot;&gt;Node.js&lt;/a&gt; ( &lt;code&gt;^8.10.0&lt;/code&gt; , &lt;code&gt;^10.13.0&lt;/code&gt; 또는 &lt;code&gt;&amp;gt;=11.10.1&lt;/code&gt; ) (공식 Node.js 배포를 사용하는 경우 SSL은 항상 내장되어 있습니다.)</target>
        </trans-unit>
        <trans-unit id="2a14e1b8f5938872ffc8263a306ac7453d0b08cd" translate="yes" xml:space="preserve">
          <source>Previous versions of ESLint silently ignored any nonexistent files and globs provided on the command line:</source>
          <target state="translated">이전 버전의 ESLint는 명령 줄에 제공된 존재하지 않는 파일과 글로브를 자동으로 무시했습니다.</target>
        </trans-unit>
        <trans-unit id="861eb458285d7d2f2e5428c183895fe75d599908" translate="yes" xml:space="preserve">
          <source>Previously, &lt;code&gt;RuleTester&lt;/code&gt; used loose equality when making some of its assertions. For example, if a rule produced the string &lt;code&gt;&quot;7&quot;&lt;/code&gt; as a result of autofixing, &lt;code&gt;RuleTester&lt;/code&gt; would allow the number &lt;code&gt;7&lt;/code&gt; in an &lt;code&gt;output&lt;/code&gt; assertion, rather than the string &lt;code&gt;&quot;7&quot;&lt;/code&gt;. In ESLint v5, comparisons from &lt;code&gt;RuleTester&lt;/code&gt; use strict equality, so an assertion like this will no longer pass.</source>
          <target state="translated">이전에 &lt;code&gt;RuleTester&lt;/code&gt; 는 일부 어설 션을 만들 때 느슨한 동등성을 사용했습니다. 예를 들어, 규칙 이 자동 수정의 결과로 문자열 &lt;code&gt;&quot;7&quot;&lt;/code&gt; 을 생성 한 경우 &lt;code&gt;RuleTester&lt;/code&gt; 는 문자열 &lt;code&gt;&quot;7&quot;&lt;/code&gt; 대신 &lt;code&gt;output&lt;/code&gt; 어설 션 에서 숫자 &lt;code&gt;7&lt;/code&gt; 을 허용합니다 . ESLint v5에서 &lt;code&gt;RuleTester&lt;/code&gt; 와의 비교는 엄격한 동등성을 사용하므로 이와 같은 주장은 더 이상 통과하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3f50639030ce290e0b2d963a0feb9b72be44a4b6" translate="yes" xml:space="preserve">
          <source>Previously, ESLint loaded plugins relative to the location of the ESLint package itself. As a result, we suggested that users with global ESLint installations should also install plugins globally, and users with local ESLint installations should install plugins locally. However, due to a design bug, this strategy caused ESLint to randomly fail to load plugins and shareable configs under certain circumstances, particularly when using package management tools like &lt;a href=&quot;https://github.com/lerna/lerna&quot;&gt;&lt;code&gt;lerna&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://yarnpkg.com/lang/en/docs/pnp/&quot;&gt;Yarn Plug n' Play&lt;/a&gt;.</source>
          <target state="translated">이전에는 ESLint가 ESLint 패키지 자체의 위치를 ​​기준으로 플러그인을로드했습니다. 결과적으로 글로벌 ESLint 설치 사용자는 플러그인을 전체적으로 설치하고 로컬 ESLint 설치 사용자는 플러그인을 로컬로 설치해야합니다. 그러나 설계 버그로 인해이 전략으로 인해 특정 상황에서, 특히 &lt;a href=&quot;https://github.com/lerna/lerna&quot;&gt; &lt;code&gt;lerna&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://yarnpkg.com/lang/en/docs/pnp/&quot;&gt;Yarn Plug n 'Play&lt;/a&gt; 와 같은 패키지 관리 도구를 사용할 때 ESLint가 플러그인 및 공유 가능한 구성을 임의로로드하지 못했습니다 .</target>
        </trans-unit>
        <trans-unit id="e5a31efe99bb4ae0265c26c456f8708e8b3abad7" translate="yes" xml:space="preserve">
          <source>Previously, ESLint would add an &lt;code&gt;eslintExplicitGlobalComment&lt;/code&gt; property to &lt;code&gt;Variable&lt;/code&gt; objects in scope analysis to indicate that a variable was introduced as a result of a &lt;code&gt;/* global */&lt;/code&gt; comment. This property was undocumented, and the ESLint team was unable to find any usage of the property outside of ESLint core. The property has been removed in ESLint v6, and replaced with the &lt;code&gt;eslintExplicitGlobalComments&lt;/code&gt; property, which can contain a list of all &lt;code&gt;/* global */&lt;/code&gt; comments if a variable was declared with more than one of them.</source>
          <target state="translated">이전에 ESLint는 범위 분석에서 &lt;code&gt;Variable&lt;/code&gt; 객체에 &lt;code&gt;eslintExplicitGlobalComment&lt;/code&gt; 속성을 추가하여 &lt;code&gt;/* global */&lt;/code&gt; 주석 의 결과로 변수가 도입되었음을 나타냅니다 . 이 속성은 문서화되지 않았으며 ESLint 팀이 ESLint 코어 외부에서 해당 속성의 사용법을 찾지 못했습니다. 이 건물은 ESLint 버전 6에서 제거하고 대체되었습니다 &lt;code&gt;eslintExplicitGlobalComments&lt;/code&gt; 의 모든 목록을 포함 할 수 있습니다 재산, &lt;code&gt;/* global */&lt;/code&gt; 변수가 그 중 하나 이상의로 선언 된 경우 의견을.</target>
        </trans-unit>
        <trans-unit id="a1d351994dd8ff11b19e958c9018b81f03cb97ca" translate="yes" xml:space="preserve">
          <source>Previously, ESLint would ignore these malformed directive comments. ESLint v5 will report an error when it sees a problem like this, so that the issue can be more easily corrected.</source>
          <target state="translated">이전에는 ESLint가 이러한 잘못된 지시문 주석을 무시했습니다. ESLint v5는 이와 같은 문제가 발생하면 오류를보고하므로 문제를보다 쉽게 ​​해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6b010cfb49c2bd7324d04fb33de705502ddf710" translate="yes" xml:space="preserve">
          <source>Previously, ESLint would set the &lt;code&gt;parent&lt;/code&gt; property on each AST node immediately before running rule listeners for that node. This caused some confusion for rule authors, because the &lt;code&gt;parent&lt;/code&gt; property would not initially be present on any nodes, and it was sometimes necessary to complicate the structure of a rule to ensure that the &lt;code&gt;parent&lt;/code&gt; property of a given node would be available when needed.</source>
          <target state="translated">이전에는 ESLint가 해당 노드의 규칙 수신기를 실행하기 직전에 각 AST 노드 에서 &lt;code&gt;parent&lt;/code&gt; 속성을 설정했습니다 . &lt;code&gt;parent&lt;/code&gt; 속성이 처음에 어떤 노드에도 존재하지 않았기 때문에 규칙 작성자에게 약간의 혼동이 생겼으며, 때로는 주어진 노드 의 &lt;code&gt;parent&lt;/code&gt; 속성이 필요할 때 사용할 수 있도록 규칙의 구조를 복잡하게 해야했습니다.</target>
        </trans-unit>
        <trans-unit id="2efde3c7b07c84bb2b96e4b7cf3ee1a328ba78ff" translate="yes" xml:space="preserve">
          <source>Previously, it was possible for rules to report AST nodes without providing a report message. This was not intended behavior, and as a result the default formatter would crash if a rule omitted a message. However, it was possible to avoid a crash when using a non-default formatter, such as &lt;code&gt;json&lt;/code&gt;.</source>
          <target state="translated">이전에는 규칙이보고 메시지를 제공하지 않고 AST 노드를보고 할 수있었습니다. 이것은 의도 된 동작이 아니므로 규칙에서 메시지를 생략하면 기본 포맷터가 충돌합니다. 그러나 &lt;code&gt;json&lt;/code&gt; 과 같은 기본이 아닌 포맷터를 사용할 때 충돌을 피할 수있었습니다 .</target>
        </trans-unit>
        <trans-unit id="665203081aa657ef14f3fd259bc736ff48eade7a" translate="yes" xml:space="preserve">
          <source>Previously, rule context objects had an undocumented &lt;code&gt;_linter&lt;/code&gt; property, which was used internally within ESLint to process reports from rules. Some rules used this property to achieve functionality that was not intended to be possible for rules. For example, several plugins used the &lt;code&gt;_linter&lt;/code&gt; property in a rule to monitor reports from other rules, for the purpose of checking for unused &lt;code&gt;/* eslint-disable */&lt;/code&gt; directive comments. Although this functionality was useful for users, it could also cause stability problems for projects using ESLint. For example, an upgrade to a rule in one plugin could unexpectedly cause a rule in another plugin to start reporting errors.</source>
          <target state="translated">이전에는 규칙 컨텍스트 객체에 문서화되지 않은 &lt;code&gt;_linter&lt;/code&gt; 속성이있었습니다.이 속성은 ESLint 내부에서 규칙의 보고서를 처리하는 데 사용되었습니다. 일부 규칙은 규칙에 사용할 수없는 기능을 달성하기 위해이 속성을 사용했습니다. 예를 들어, 여러 플러그인 은 규칙에서 &lt;code&gt;_linter&lt;/code&gt; 속성을 사용하여 사용되지 않은 &lt;code&gt;/* eslint-disable */&lt;/code&gt; 지시문 주석 을 확인하기 위해 다른 규칙의 보고서를 모니터링했습니다 . 이 기능은 사용자에게 유용했지만 ESLint를 사용하는 프로젝트의 안정성 문제를 일으킬 수도 있습니다. 예를 들어 한 플러그인에서 규칙으로 업그레이드하면 예기치 않게 다른 플러그인의 규칙에서 오류보고가 시작될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ad7f54686fbe669487e9816787f55d0683c5950" translate="yes" xml:space="preserve">
          <source>Previously, the &lt;a href=&quot;../rules/comma-dangle&quot;&gt;&lt;code&gt;comma-dangle&lt;/code&gt;&lt;/a&gt; rule would ignore trailing function arguments and parameters, unless explicitly configured to check for function commas. In ESLint v6, function commas are treated the same way as other types of trailing commas.</source>
          <target state="translated">이전에는 함수 쉼표를 확인하도록 명시 적으로 구성하지 않으면 &lt;a href=&quot;../rules/comma-dangle&quot;&gt; &lt;code&gt;comma-dangle&lt;/code&gt; &lt;/a&gt; 규칙은 후미 함수 인수 및 매개 변수를 무시합니다. ESLint v6에서 함수 쉼표는 다른 유형의 후행 쉼표와 동일한 방식으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="bb4d9004d86d873bce13da59ea0da1efcb652b6e" translate="yes" xml:space="preserve">
          <source>Previously, the &lt;a href=&quot;../rules/indent&quot;&gt;&lt;code&gt;indent&lt;/code&gt;&lt;/a&gt; rule was fairly lenient about checking indentation; there were many code patterns where indentation was not validated by the rule. This caused confusion for users, because they were accidentally writing code with incorrect indentation, and they expected ESLint to catch the issues.</source>
          <target state="translated">이전에는 &lt;a href=&quot;../rules/indent&quot;&gt; &lt;code&gt;indent&lt;/code&gt; &lt;/a&gt; 규칙이 들여 쓰기 확인에 상당히 관대했습니다. 규칙에 의해 들여 쓰기가 검증되지 않은 많은 코드 패턴이있었습니다. 실수로 들여 쓰기가 잘못된 코드를 작성했기 때문에 혼동을 일으켜 ESLint가 문제를 포착 할 것으로 예상했습니다.</target>
        </trans-unit>
        <trans-unit id="cac4dad357054ea6ee0c7634c9a4e7c59614fbef" translate="yes" xml:space="preserve">
          <source>Previously, the &lt;code&gt;context.getScope()&lt;/code&gt; method changed its behavior based on the &lt;code&gt;parserOptions.ecmaVersion&lt;/code&gt; property. However, this could cause confusing behavior when using a parser that doesn't respond to the &lt;code&gt;ecmaVersion&lt;/code&gt; option, such as &lt;code&gt;babel-eslint&lt;/code&gt;.</source>
          <target state="translated">이전에는 &lt;code&gt;context.getScope()&lt;/code&gt; 메서드가 &lt;code&gt;parserOptions.ecmaVersion&lt;/code&gt; 속성을 기반으로 동작을 변경했습니다 . 그러나 &lt;code&gt;babel-eslint&lt;/code&gt; 와 같이 &lt;code&gt;ecmaVersion&lt;/code&gt; 옵션에 응답하지 않는 구문 분석기를 사용할 때 혼란스러운 동작이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="40450d3f81bf0c288fef5278f775f18d1a6902ca" translate="yes" xml:space="preserve">
          <source>Previously, the &lt;code&gt;linter.verify()&lt;/code&gt; API accepted a &lt;code&gt;global&lt;/code&gt; config option, which was a synonym for the documented &lt;code&gt;globals&lt;/code&gt; property. The &lt;code&gt;global&lt;/code&gt; option was never documented or officially supported, and did not work in config files. It has been removed in 4.0.</source>
          <target state="translated">이전에 &lt;code&gt;linter.verify()&lt;/code&gt; API 는 문서화 된 &lt;code&gt;globals&lt;/code&gt; 특성과 동의어 인 &lt;code&gt;global&lt;/code&gt; 구성 옵션을 승인했습니다 . &lt;code&gt;global&lt;/code&gt; 옵션은 문서화하거나 공식적으로 지원하고, 설정 파일에 작동하지 않았다. 4.0에서 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="759b8740ec08f1087d9d1461adf3e37a3bf5b531" translate="yes" xml:space="preserve">
          <source>Previously, when configuring a set of global variables with an object, it was possible to use anything as the values of the object. An unknown value would be treated the same as &lt;code&gt;&quot;writable&quot;&lt;/code&gt;.</source>
          <target state="translated">이전에는 객체로 전역 변수 세트를 구성 할 때 객체의 값으로 무엇이든 사용할 수있었습니다. 알 수없는 값은 &lt;code&gt;&quot;writable&quot;&lt;/code&gt; 과 동일하게 취급 됩니다.</target>
        </trans-unit>
        <trans-unit id="d7b32ac883bfc23aab343c6372688bec1c7d6449" translate="yes" xml:space="preserve">
          <source>Previously, when linting code with a parser that had not been previously defined, the &lt;code&gt;Linter&lt;/code&gt; API would attempt to load the parser from the filesystem. However, this behavior was confusing because &lt;code&gt;Linter&lt;/code&gt; never access the filesystem in any other cases, and it was difficult to ensure that the correct parser would be found when loading the parser from the filesystem.</source>
          <target state="translated">이전에 정의되지 않은 파서와 코드를 linting 때 이전의 &lt;code&gt;Linter&lt;/code&gt; API는 파일 시스템에서 파서를로드하려고합니다. 그러나 &lt;code&gt;Linter&lt;/code&gt; 가 다른 경우에는 파일 시스템에 액세스하지 않기 때문에이 동작이 혼란 스러웠 으며 파일 시스템에서 구문 분석기를로드 할 때 올바른 구문 분석기를 찾을 수 없었습니다.</target>
        </trans-unit>
        <trans-unit id="8a3ba3b815ccf0fde610368afb8b3a032a9740a4" translate="yes" xml:space="preserve">
          <source>Previously, when parsing JS code like &lt;code&gt;const foo = {...data}&lt;/code&gt; with the &lt;code&gt;experimentalObjectRestSpread&lt;/code&gt; option enabled, the default parser would generate an &lt;code&gt;ExperimentalSpreadProperty&lt;/code&gt; node type for the &lt;code&gt;...data&lt;/code&gt; spread element.</source>
          <target state="translated">이전 에는 &lt;code&gt;experimentalObjectRestSpread&lt;/code&gt; 옵션이 활성화 된 &lt;code&gt;const foo = {...data}&lt;/code&gt; 와 같은 JS 코드를 구문 분석 할 때 기본 구문 분석기는 &lt;code&gt;...data&lt;/code&gt; spread 요소에 대한 &lt;code&gt;ExperimentalSpreadProperty&lt;/code&gt; 노드 유형을 생성했습니다 .</target>
        </trans-unit>
        <trans-unit id="3572fe8f9bf308c3f1c32a5c5c8ecf7ade2e2992" translate="yes" xml:space="preserve">
          <source>Previously, when parsing JS code like &lt;code&gt;const {foo, ...rest} = data&lt;/code&gt; with the &lt;code&gt;experimentalObjectRestSpread&lt;/code&gt; option enabled, the default parser would generate an &lt;code&gt;ExperimentalRestProperty&lt;/code&gt; node type for the &lt;code&gt;...data&lt;/code&gt; rest element.</source>
          <target state="translated">이전 에는 &lt;code&gt;experimentalObjectRestSpread&lt;/code&gt; 옵션이 활성화 된 &lt;code&gt;const {foo, ...rest} = data&lt;/code&gt; 와 같은 JS 코드를 구문 분석 할 때 기본 구문 분석기는 &lt;code&gt;...data&lt;/code&gt; rest 요소에 대한 &lt;code&gt;ExperimentalRestProperty&lt;/code&gt; 노드 유형을 생성했습니다 .</target>
        </trans-unit>
        <trans-unit id="ac97c7d1bc4493830e4f2c35fbc7b98e9d1581e8" translate="yes" xml:space="preserve">
          <source>Previously, when using the default parser it was possible to use the &lt;code&gt;experimentalObjectRestSpread&lt;/code&gt; option to enable support for &lt;a href=&quot;https://developers.google.com/web/updates/2017/06/object-rest-spread&quot;&gt;rest/spread properties&lt;/a&gt;, as follows:</source>
          <target state="translated">이전에는 기본 파서를 사용할 때 다음과 같이 &lt;code&gt;experimentalObjectRestSpread&lt;/code&gt; 옵션을 사용하여 &lt;a href=&quot;https://developers.google.com/web/updates/2017/06/object-rest-spread&quot;&gt;rest / spread 속성을&lt;/a&gt; 지원할 수있었습니다 .</target>
        </trans-unit>
        <trans-unit id="393a7447e4d30c62abea4ddc9f0d3dfc3e208e74" translate="yes" xml:space="preserve">
          <source>Previously, when using the default parser, a config could use the &lt;code&gt;experimentalObjectRestSpread&lt;/code&gt; option to enable parsing support for object rest/spread properties:</source>
          <target state="translated">이전에는 기본 구문 분석기를 사용할 때 구성에서 &lt;code&gt;experimentalObjectRestSpread&lt;/code&gt; 옵션을 사용하여 오브젝트 휴지 / 스프레드 특성에 대한 구문 분석 지원을 사용할 수있었습니다 .</target>
        </trans-unit>
        <trans-unit id="6c1fec0a04a3eab043ee811142120d57785cfef0" translate="yes" xml:space="preserve">
          <source>Primitive Literals</source>
          <target state="translated">원시 리터럴</target>
        </trans-unit>
        <trans-unit id="8c8f400f7e3e42d398c134471b34479ab1e3ff12" translate="yes" xml:space="preserve">
          <source>Prior to 2.0.0, if a directory contained both an &lt;code&gt;.eslintrc&lt;/code&gt; file and a &lt;code&gt;package.json&lt;/code&gt; file with ESLint configuration information, the settings from the two files would be merged together. In 2.0.0, only the settings from the &lt;code&gt;.eslintrc.*&lt;/code&gt; file are used and the ones in &lt;code&gt;package.json&lt;/code&gt; are ignored when both are present. Otherwise, &lt;code&gt;package.json&lt;/code&gt; can still be used with ESLint configuration, but only if no other &lt;code&gt;.eslintrc.*&lt;/code&gt; files are present.</source>
          <target state="translated">2.0.0 이전에는 디렉토리 에 ESLint 구성 정보가 있는 &lt;code&gt;.eslintrc&lt;/code&gt; 파일과 &lt;code&gt;package.json&lt;/code&gt; 파일이 모두 포함 된 경우 두 파일의 설정이 병합됩니다. 2.0.0에서는 &lt;code&gt;.eslintrc.*&lt;/code&gt; 파일 의 설정 만 사용되며 &lt;code&gt;package.json&lt;/code&gt; 의 설정 은 모두 무시됩니다. 그렇지 않으면 &lt;code&gt;package.json&lt;/code&gt; 을 ESLint 구성과 함께 사용할 수 있지만 다른 &lt;code&gt;.eslintrc.*&lt;/code&gt; 파일이 없는 경우에만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bacbbe4722ec9b78f85bdddd7ed97a705ae7d9fe" translate="yes" xml:space="preserve">
          <source>Prior to 2.0.0, new global variables that were standardized as part of ES6 such as &lt;code&gt;Promise&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, and &lt;code&gt;Symbol&lt;/code&gt; were included in the built-in global environment. This could lead to potential issues when, for example, &lt;code&gt;no-undef&lt;/code&gt; permitted use of the &lt;code&gt;Promise&lt;/code&gt; constructor even in ES5 code where promises are unavailable. In 2.0.0, the built-in environment only includes the standard ES5 global variables, and the new ES6 global variables have been moved to the &lt;code&gt;es6&lt;/code&gt; environment.</source>
          <target state="translated">2.0.0 이전에는 &lt;code&gt;Promise&lt;/code&gt; , &lt;code&gt;Map&lt;/code&gt; , &lt;code&gt;Set&lt;/code&gt; 및 &lt;code&gt;Symbol&lt;/code&gt; 과 같은 ES6의 일부로 표준화 된 새로운 전역 변수가 내장 전역 환경에 포함되었습니다. 예를 들어 약속을 사용할 수없는 ES5 코드에서도 &lt;code&gt;Promise&lt;/code&gt; 생성자를 &lt;code&gt;no-undef&lt;/code&gt; 허용하는 경우 잠재적 인 문제가 발생할 수 있습니다. 2.0.0에서 내장 환경에는 표준 ES5 전역 변수 만 포함되며 새 ES6 전역 변수가 &lt;code&gt;es6&lt;/code&gt; 환경 으로 이동되었습니다 .</target>
        </trans-unit>
        <trans-unit id="ea53a76cd88b434dcfaff09ec72ada7ae7831a08" translate="yes" xml:space="preserve">
          <source>Prior to 2.0.0, the way to enable language options was by using &lt;code&gt;ecmaFeatures&lt;/code&gt; in your configuration. In 2.0.0:</source>
          <target state="translated">2.0.0 이전에는 언어 옵션을 활성화하는 방법은 구성에서 &lt;code&gt;ecmaFeatures&lt;/code&gt; 를 사용하는 것이 었 습니다. 2.0.0에서 :</target>
        </trans-unit>
        <trans-unit id="6b9f0362f6ea97fabedbee28f3e42f7c63d479c2" translate="yes" xml:space="preserve">
          <source>Prior to 4.0, ESLint required parsers to implement comment attachment, a process where AST nodes would gain additional properties corresponding to their leading and trailing comments in the source file. This made it difficult for users to develop custom parsers, because they would have to replicate the confusing comment attachment semantics required by ESLint.</source>
          <target state="translated">4.0 이전에 ESLint는 구문 분석기가 주석 첨부 파일을 구현해야했습니다.이 프로세스는 AST 노드가 소스 파일에서 선행 및 후행 주석에 해당하는 추가 특성을 얻는 프로세스입니다. 따라서 ESLint에 필요한 혼란스러운 주석 첨부 파일 의미 체계를 복제해야하므로 사용자가 사용자 정의 파서를 개발하기가 어려웠습니다.</target>
        </trans-unit>
        <trans-unit id="5e3d392b20fe6d9664c81b4a65c6b601daf8e9bf" translate="yes" xml:space="preserve">
          <source>Prior to 4.0, shebang comments in a source file would not appear in the output of &lt;code&gt;sourceCode.getAllComments()&lt;/code&gt; or &lt;code&gt;sourceCode.getComments()&lt;/code&gt;, but they would appear in the output of &lt;code&gt;sourceCode.getTokenOrCommentBefore&lt;/code&gt; as line comments. This inconsistency led to some confusion for rule developers.</source>
          <target state="translated">4.0 이전에는 소스 파일의 shebang 주석이 &lt;code&gt;sourceCode.getAllComments()&lt;/code&gt; 또는 &lt;code&gt;sourceCode.getComments()&lt;/code&gt; 의 출력에 나타나지 않지만 &lt;code&gt;sourceCode.getTokenOrCommentBefore&lt;/code&gt; 의 출력에는 행 주석으로 표시됩니다. 이러한 불일치로 인해 규칙 개발자에게는 약간의 혼란이 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="b3be15561d5151f64c56456dc30fa7cef13a71e7" translate="yes" xml:space="preserve">
          <source>Prior to v0.16.0 this rule also enforced that there was only a single line at the end of the file. If you still want this behavior, consider enabling &lt;a href=&quot;no-multiple-empty-lines&quot;&gt;no-multiple-empty-lines&lt;/a&gt; with &lt;code&gt;maxEOF&lt;/code&gt; and/or &lt;a href=&quot;no-trailing-spaces&quot;&gt;no-trailing-spaces&lt;/a&gt;.</source>
          <target state="translated">v0.16.0 이전에는이 ​​규칙이 파일 끝에 한 줄만 존재하도록했습니다. 이 동작을 계속 원하면 &lt;code&gt;maxEOF&lt;/code&gt; 및 / 또는 &lt;a href=&quot;no-trailing-spaces&quot;&gt;후행 공백없이 &lt;/a&gt;&lt;a href=&quot;no-multiple-empty-lines&quot;&gt;여러 개의 빈 줄을&lt;/a&gt; 사용 하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="af52f1493bafbe39bd3dae2bc861bf916727dd6e" translate="yes" xml:space="preserve">
          <source>Prior to v2.0.0, plugins could specify a &lt;code&gt;rulesConfig&lt;/code&gt; for the plugin. The &lt;code&gt;rulesConfig&lt;/code&gt; would automatically be applied whenever someone uses the plugin, which is the opposite of what ESLint does in every other situation (where nothing is on by default). To bring plugins behavior in line, we have removed support for &lt;code&gt;rulesConfig&lt;/code&gt; in plugins.</source>
          <target state="translated">&lt;code&gt;rulesConfig&lt;/code&gt; 이전에는 플러그인이 플러그인에 대해 rulesConfig 를 지정할 수있었습니다 . &lt;code&gt;rulesConfig&lt;/code&gt; 는 사람이 ESLint은 (아무것도 기본적으로 없음) 다른 모든 상황에서 무엇의 반대 플러그인을 사용할 때마다 자동으로 적용됩니다. 플러그인 작동을 위해 플러그인에서 &lt;code&gt;rulesConfig&lt;/code&gt; 에 대한 지원을 제거 했습니다.</target>
        </trans-unit>
        <trans-unit id="692a54c10f74d805a38453bd22bb1d25068c3ba0" translate="yes" xml:space="preserve">
          <source>Processors in Plugins</source>
          <target state="translated">플러그인의 프로세서</target>
        </trans-unit>
        <trans-unit id="ee555673e8664c98d4ada2d762c610f965ba2a31" translate="yes" xml:space="preserve">
          <source>Processors may make named code blocks such as &lt;code&gt;0.js&lt;/code&gt; and &lt;code&gt;1.js&lt;/code&gt;. ESLint handles such a named code block as a child file of the original file. You can specify additional configurations for named code blocks in the &lt;code&gt;overrides&lt;/code&gt; section of the config. For example, the following disables &lt;code&gt;strict&lt;/code&gt; rule for the named code blocks which end with &lt;code&gt;.js&lt;/code&gt; in markdown files.</source>
          <target state="translated">프로세서는 &lt;code&gt;0.js&lt;/code&gt; 및 &lt;code&gt;1.js&lt;/code&gt; 와 같은 명명 된 코드 블록을 만들 수 있습니다 . ESLint는 이러한 명명 된 코드 블록을 원본 파일의 하위 파일로 처리합니다. 구성의 &lt;code&gt;overrides&lt;/code&gt; 섹션 에서 명명 된 코드 블록에 대한 추가 구성을 지정할 수 있습니다 . 예를 들어, 다음은 마크 다운 파일에서 &lt;code&gt;.js&lt;/code&gt; 로 끝나는 명명 된 코드 블록에 대해 &lt;code&gt;strict&lt;/code&gt; 규칙을 비활성화 합니다.</target>
        </trans-unit>
        <trans-unit id="f32c5098fb499f12ad76958c7a61d5b8091f9763" translate="yes" xml:space="preserve">
          <source>Program is expressed with several code paths. A code path is expressed with objects of two kinds: &lt;code&gt;CodePath&lt;/code&gt; and &lt;code&gt;CodePathSegment&lt;/code&gt;.</source>
          <target state="translated">프로그램은 여러 코드 경로로 표현됩니다. 코드 경로는 &lt;code&gt;CodePath&lt;/code&gt; 및 &lt;code&gt;CodePathSegment&lt;/code&gt; 의 두 가지 개체로 표현됩니다 .</target>
        </trans-unit>
        <trans-unit id="42fa885d13da97a910ec7164bf19b94acb08d0f0" translate="yes" xml:space="preserve">
          <source>Programming language style guides are important for the long-term maintainability of software. This guide is based on the &lt;a href=&quot;https://java.sun.com/docs/codeconv/&quot;&gt;Code Conventions for the Java Programming Language&lt;/a&gt; and &lt;a href=&quot;http://javascript.crockford.com/code.html&quot;&gt;Douglas Crockford's Code Conventions for the JavaScript Programming Language&lt;/a&gt;. Modifications have been made due to my personal experience and preferences.</source>
          <target state="translated">프로그래밍 언어 스타일 가이드는 소프트웨어의 장기적인 유지 관리에 중요합니다. 이 안내서는 &lt;a href=&quot;https://java.sun.com/docs/codeconv/&quot;&gt;Java 프로그래밍 언어&lt;/a&gt; 에 대한 코드 규약 및 &lt;a href=&quot;http://javascript.crockford.com/code.html&quot;&gt;JavaScript 프로그래밍 언어에 대한 Douglas Crockford의 코드 규약을&lt;/a&gt; 기반으로합니다 . 개인적인 경험과 선호로 인해 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="43f3ace69f2fe7131543d9052cb08b303ff904e4" translate="yes" xml:space="preserve">
          <source>Project-level configuration:</source>
          <target state="translated">프로젝트 레벨 구성 :</target>
        </trans-unit>
        <trans-unit id="33fb62ee4504c98b469fcbf6c4712f39685712fe" translate="yes" xml:space="preserve">
          <source>Property descriptors in &lt;code&gt;Object.create&lt;/code&gt;, &lt;code&gt;Object.defineProperty&lt;/code&gt;, &lt;code&gt;Object.defineProperties&lt;/code&gt;, and &lt;code&gt;Reflect.defineProperty&lt;/code&gt; methods of the global objects.</source>
          <target state="translated">전역 객체의 &lt;code&gt;Object.create&lt;/code&gt; , &lt;code&gt;Object.defineProperty&lt;/code&gt; , &lt;code&gt;Object.defineProperties&lt;/code&gt; 및 &lt;code&gt;Reflect.defineProperty&lt;/code&gt; 메서드의 속성 설명자</target>
        </trans-unit>
        <trans-unit id="b5e66a1596415565d4a94aaddcf8bb5751542451" translate="yes" xml:space="preserve">
          <source>Proponents of Yoda conditions highlight that it is impossible to mistakenly use &lt;code&gt;=&lt;/code&gt; instead of &lt;code&gt;==&lt;/code&gt; because you cannot assign to a literal value. Doing so will cause a syntax error and you will be informed of the mistake early on. This practice was therefore very common in early programming where tools were not yet available.</source>
          <target state="translated">Yoda 조건의 지지자들은 리터럴 값을 할당 할 수 없기 때문에 &lt;code&gt;==&lt;/code&gt; 대신 실수로 &lt;code&gt;=&lt;/code&gt; 를 사용할 수 없음을 강조합니다 . 그렇게하면 구문 오류가 발생하고 실수를 미리 알려줍니다. 따라서이 방법은 도구를 아직 사용할 수없는 초기 프로그래밍에서 매우 일반적이었습니다.</target>
        </trans-unit>
        <trans-unit id="d36f5aee868ae6db86c6284531cdd8f72d77db1c" translate="yes" xml:space="preserve">
          <source>Proposing a &lt;a href=&quot;new-rules&quot;&gt;New Rule&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;new-rules&quot;&gt;새로운 규칙&lt;/a&gt; 제안</target>
        </trans-unit>
        <trans-unit id="ecaeee3736f17c6a22f424961f98b463abcd212d" translate="yes" xml:space="preserve">
          <source>Proposing a &lt;a href=&quot;rule-changes&quot;&gt;Rule Change&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;rule-changes&quot;&gt;규칙 변경&lt;/a&gt; 제안</target>
        </trans-unit>
        <trans-unit id="8fde9b438a1e10afec4812ddd08e7722642dc36e" translate="yes" xml:space="preserve">
          <source>Proposing a Rule</source>
          <target state="translated">규칙 제안</target>
        </trans-unit>
        <trans-unit id="341849141f80cca77602012c6f342ce4742319fd" translate="yes" xml:space="preserve">
          <source>Proposing a Rule Change</source>
          <target state="translated">규칙 변경 제안</target>
        </trans-unit>
        <trans-unit id="86ee7e213745f3cf674455c23534700070da7b53" translate="yes" xml:space="preserve">
          <source>Provide as many unit tests as possible. Your pull request will never be turned down for having too many tests submitted with it!</source>
          <target state="translated">가능한 많은 단위 테스트를 제공하십시오. 너무 많은 테스트를 제출하여 풀 요청이 거절되지 않습니다!</target>
        </trans-unit>
        <trans-unit id="4ffdc87852320c6294c2b02843d1425e91d10cfc" translate="yes" xml:space="preserve">
          <source>Providing Suggestions</source>
          <target state="translated">제안하기</target>
        </trans-unit>
        <trans-unit id="5591bbc620225df439fe2bdef9369c8238d4af8c" translate="yes" xml:space="preserve">
          <source>Publishing a Shareable Config</source>
          <target state="translated">공유 가능한 구성 게시</target>
        </trans-unit>
        <trans-unit id="30ab8d084e2209d47a1dc198c8de1e251f390a94" translate="yes" xml:space="preserve">
          <source>Pull Requests</source>
          <target state="translated">풀 요청</target>
        </trans-unit>
        <trans-unit id="8317963e9e1ff1e717106bf4888341b278d74c92" translate="yes" xml:space="preserve">
          <source>Push your changes</source>
          <target state="translated">당신의 변화를 밀어</target>
        </trans-unit>
        <trans-unit id="8c720088282bb804281d4141100281d68e2719bb" translate="yes" xml:space="preserve">
          <source>Putting default parameter at last allows function calls to omit optional tail arguments.</source>
          <target state="translated">기본 매개 변수를 마지막에두면 함수 호출로 선택적 꼬리 인수를 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="289df8885d703027d487fef77d56fc52e316d891" translate="yes" xml:space="preserve">
          <source>Rather than creating separate rules for every language feature you want to turn off, this rule allows you to configure the syntax elements you want to restrict use of. These elements are represented by their &lt;a href=&quot;https://github.com/estree/estree&quot;&gt;ESTree&lt;/a&gt; node types. For example, a function declaration is represented by &lt;code&gt;FunctionDeclaration&lt;/code&gt; and the &lt;code&gt;with&lt;/code&gt; statement is represented by &lt;code&gt;WithStatement&lt;/code&gt;. You may find the full list of AST node names you can use &lt;a href=&quot;https://github.com/eslint/espree/blob/master/lib/ast-node-types.js&quot;&gt;on GitHub&lt;/a&gt; and use &lt;a href=&quot;https://astexplorer.net/&quot;&gt;AST Explorer&lt;/a&gt; with the espree parser to see what type of nodes your code consists of.</source>
          <target state="translated">사용하지 않으려는 모든 언어 기능에 대해 별도의 규칙을 작성하는 대신이 규칙을 사용하여 사용을 제한하려는 구문 요소를 구성 할 수 있습니다. 이 요소는 &lt;a href=&quot;https://github.com/estree/estree&quot;&gt;ESTree&lt;/a&gt; 노드 유형으로 표시됩니다 . 예를 들어, 함수 선언에 의해 표현된다 &lt;code&gt;FunctionDeclaration&lt;/code&gt; 과 &lt;code&gt;with&lt;/code&gt; 문에 의해 표현된다 &lt;code&gt;WithStatement&lt;/code&gt; . &lt;a href=&quot;https://github.com/eslint/espree/blob/master/lib/ast-node-types.js&quot;&gt;GitHub&lt;/a&gt; 에서 사용할 수있는 AST 노드 이름의 전체 목록을 찾고 espree 파서와 함께 &lt;a href=&quot;https://astexplorer.net/&quot;&gt;AST Explorer&lt;/a&gt; 를 사용 하여 코드가 어떤 유형의 노드로 구성되어 있는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d1f996aa17807ebebdb5143b01f86f170d5bea6" translate="yes" xml:space="preserve">
          <source>React</source>
          <target state="translated">React</target>
        </trans-unit>
        <trans-unit id="9ee3f643952093b19948a020203596de344dc34f" translate="yes" xml:space="preserve">
          <source>Read the &lt;a href=&quot;https://eslint.org/conduct&quot;&gt;Code of Conduct&lt;/a&gt;</source>
          <target state="translated">Read the &lt;a href=&quot;https://eslint.org/conduct&quot;&gt;Code of Conduct&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8bf3ca1af55a4ac765bcc067d56c1abf4201ae04" translate="yes" xml:space="preserve">
          <source>Read the &lt;a href=&quot;https://js.foundation/community/code-of-conduct&quot;&gt;Code of Conduct&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://js.foundation/community/code-of-conduct&quot;&gt;행동 강령&lt;/a&gt; 읽기</target>
        </trans-unit>
        <trans-unit id="3c28870b2e40bf75ddc825d7f6ccf7aef23e7e4b" translate="yes" xml:space="preserve">
          <source>Read-only global variables</source>
          <target state="translated">읽기 전용 전역 변수</target>
        </trans-unit>
        <trans-unit id="f7f699bcbeea4f59d35cf84d686c1fe9d26c6cd2" translate="yes" xml:space="preserve">
          <source>Reading configuration information from config files (including &lt;code&gt;.eslintrc&lt;/code&gt; and &lt;code&gt;package.json&lt;/code&gt;)</source>
          <target state="translated">구성 파일에서 구성 정보 읽기 ( &lt;code&gt;.eslintrc&lt;/code&gt; 및 &lt;code&gt;package.json&lt;/code&gt; 포함 )</target>
        </trans-unit>
        <trans-unit id="c503dd1f9c9f723f78d9b1e948ede74c06ed1112" translate="yes" xml:space="preserve">
          <source>Reading from the file system</source>
          <target state="translated">파일 시스템에서 읽기</target>
        </trans-unit>
        <trans-unit id="256ac291cd34fa721dc7063e9c7a456d831fad1e" translate="yes" xml:space="preserve">
          <source>Rebase onto upstream</source>
          <target state="translated">업스트림으로 리베이스</target>
        </trans-unit>
        <trans-unit id="3636419e1cfae4b85f914484288a2e7b2429d45d" translate="yes" xml:space="preserve">
          <source>Rebasing</source>
          <target state="translated">Rebasing</target>
        </trans-unit>
        <trans-unit id="15bc3424085a46a8b413590042e27673eda36b4b" translate="yes" xml:space="preserve">
          <source>Recommended keywords:</source>
          <target state="translated">추천 키워드 :</target>
        </trans-unit>
        <trans-unit id="8532988ca58a814f1543477fc268a1acefe668d0" translate="yes" xml:space="preserve">
          <source>Redeclarations of read-only global variables and assignments to read-only global variables.</source>
          <target state="translated">읽기 전용 전역 변수의 재 선언 및 읽기 전용 전역 변수에 대한 할당.</target>
        </trans-unit>
        <trans-unit id="4462d29bec3d07aaf9a71ae4d7273bee7d450028" translate="yes" xml:space="preserve">
          <source>Reference Information</source>
          <target state="translated">참조 정보</target>
        </trans-unit>
        <trans-unit id="df9e76446650cac75008b6bf87079e749a453bdb" translate="yes" xml:space="preserve">
          <source>Reference interface</source>
          <target state="translated">참조 인터페이스</target>
        </trans-unit>
        <trans-unit id="53c2a1c2bb6e1d4d8148660156aec1a0a17d24a8" translate="yes" xml:space="preserve">
          <source>ReferenceError: assignment to undeclared variable</source>
          <target state="translated">ReferenceError : 선언되지 않은 변수에 대입</target>
        </trans-unit>
        <trans-unit id="eb264a799738b600bd47d5135f4fc05dfcd5b1d5" translate="yes" xml:space="preserve">
          <source>References to scoped plugins in config files are now required to include the scope</source>
          <target state="translated">구성 파일에서 범위가 지정된 플러그인에 대한 참조는 이제 범위를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="e4409d5bd36638733bfa9227649affbe8de8da69" translate="yes" xml:space="preserve">
          <source>Reflect.apply</source>
          <target state="translated">Reflect.apply</target>
        </trans-unit>
        <trans-unit id="f2f9fd068e4242fbb4c065fab823928d6658dcc6" translate="yes" xml:space="preserve">
          <source>Reflect.defineProperty</source>
          <target state="translated">Reflect.defineProperty</target>
        </trans-unit>
        <trans-unit id="d9c40e72ed42277e621938140990fecec31860d2" translate="yes" xml:space="preserve">
          <source>Reflect.deleteProperty</source>
          <target state="translated">Reflect.deleteProperty</target>
        </trans-unit>
        <trans-unit id="dca299dec7c4b27406c99a9db8613312969fc8ef" translate="yes" xml:space="preserve">
          <source>Reflect.getOwnPropertyDescriptor</source>
          <target state="translated">Reflect.getOwnPropertyDescriptor</target>
        </trans-unit>
        <trans-unit id="9e55b43471522e73de67aec1ebffc5cdb9fa1436" translate="yes" xml:space="preserve">
          <source>Reflect.getOwnPropertyNames</source>
          <target state="translated">Reflect.getOwnPropertyNames</target>
        </trans-unit>
        <trans-unit id="c4ccc5cd40402aca6f2327273b607a16273c4cf3" translate="yes" xml:space="preserve">
          <source>Reflect.getPrototypeOf</source>
          <target state="translated">Reflect.getPrototypeOf</target>
        </trans-unit>
        <trans-unit id="67b946573d9e6181078c2c26d4ca78a319f779cb" translate="yes" xml:space="preserve">
          <source>Reflect.isExtensible</source>
          <target state="translated">Reflect.isExtensible</target>
        </trans-unit>
        <trans-unit id="9578443035eb8705bd126e9acab6f34b58453535" translate="yes" xml:space="preserve">
          <source>Reflect.preventExtensions</source>
          <target state="translated">Reflect.preventExtensions</target>
        </trans-unit>
        <trans-unit id="a5a0796157a708b39407cdcc3b1149e74aa1ba55" translate="yes" xml:space="preserve">
          <source>Reflect.setPrototypeOf</source>
          <target state="translated">Reflect.setPrototypeOf</target>
        </trans-unit>
        <trans-unit id="5a1a35c83df714211f74bb546dc5facc26363344" translate="yes" xml:space="preserve">
          <source>RegExp &lt;code&gt;u&lt;/code&gt; flag has two effects:</source>
          <target state="translated">RegExp &lt;code&gt;u&lt;/code&gt; 플래그에는 두 가지 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc019f867ae1e63caad1e171c9ac68f393022fd6" translate="yes" xml:space="preserve">
          <source>RegExp literals such as &lt;code&gt;(/abc/).test(var)&lt;/code&gt; to avoid conflicts with the &lt;a href=&quot;wrap-regex&quot;&gt;wrap-regex&lt;/a&gt; rule</source>
          <target state="translated">&lt;a href=&quot;wrap-regex&quot;&gt;wrap-regex&lt;/a&gt; 규칙 과의 충돌을 피하기 위해 &lt;code&gt;(/abc/).test(var)&lt;/code&gt; 와 같은 RegExp 리터럴</target>
        </trans-unit>
        <trans-unit id="7114653a737d7346ec01e388401a05144edff375" translate="yes" xml:space="preserve">
          <source>Regular expression literals, e.g., &lt;code&gt;/abc/u&lt;/code&gt;.</source>
          <target state="translated">정규 표현식 리터럴, 예를 들어, &lt;code&gt;/abc/u&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0ccd845025a375ba8f53989cf7554162e8cbfee" translate="yes" xml:space="preserve">
          <source>Regular expressions can be very complex and difficult to understand, which is why it's important to keep them as simple as possible in order to avoid mistakes. One of the more error-prone things you can do with a regular expression is to use more than one space, such as:</source>
          <target state="translated">정규 표현식은 매우 복잡하고 이해하기 어려울 수 있으므로 실수를 피하기 위해 가능한 한 단순하게 유지하는 것이 중요합니다. 정규식으로 수행 할 수있는 오류가 발생하기 쉬운 작업 중 하나는 다음과 같이 둘 이상의 공백을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="73df01ef95fe676ecd6771adb485003ded6e2733" translate="yes" xml:space="preserve">
          <source>Related Rules</source>
          <target state="translated">관련 규칙</target>
        </trans-unit>
        <trans-unit id="33749d1fd374471a64ca2130b8acf29edc1c7f83" translate="yes" xml:space="preserve">
          <source>Related rules</source>
          <target state="translated">관련 규칙</target>
        </trans-unit>
        <trans-unit id="c8ca31e64125f97916f5430dc1a846a8fb66cb93" translate="yes" xml:space="preserve">
          <source>Relational Operators: &lt;code&gt;&quot;in&quot;&lt;/code&gt;, &lt;code&gt;&quot;instanceof&quot;&lt;/code&gt;</source>
          <target state="translated">관계 연산자 : &lt;code&gt;&quot;in&quot;&lt;/code&gt; , &lt;code&gt;&quot;instanceof&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9e4f647ac04e2d41dbb5b8e09ff6b1cdb35b950d" translate="yes" xml:space="preserve">
          <source>Relative glob patterns</source>
          <target state="translated">상대 글로브 패턴</target>
        </trans-unit>
        <trans-unit id="e67d73e5c8870b0aee2e6a5b9e1177d2a9866243" translate="yes" xml:space="preserve">
          <source>Remember that ESLint is completely pluggable, which means you can create your own rules and distribute them using plugins. We did this on purpose because we don't want to be the gatekeepers for all possible rules. Even if we don't accept a rule into the core, that doesn't mean you can't have the exact rule that you want. See the &lt;a href=&quot;../working-with-rules&quot;&gt;working with rules&lt;/a&gt; and &lt;a href=&quot;../working-with-plugins&quot;&gt;working with plugins&lt;/a&gt; documentation for more information.</source>
          <target state="translated">ESLint는 완전히 플러그 가능하므로 자신 만의 규칙을 만들고 플러그인을 사용하여 배포 할 수 있습니다. 가능한 모든 규칙의 게이트 키퍼가되기를 원하지 않기 때문에 의도적으로 수행했습니다. 핵심 규칙을 수락하지 않더라도 원하는 정확한 규칙을 가질 수는 없습니다. 참고 항목 &lt;a href=&quot;../working-with-rules&quot;&gt;규칙 작업&lt;/a&gt; 및 &lt;a href=&quot;../working-with-plugins&quot;&gt;플러그인 작업&lt;/a&gt; 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="960f6a4b27df973ccb71be9fd4f6a93b7639f03e" translate="yes" xml:space="preserve">
          <source>Remove the severity from the schema</source>
          <target state="translated">스키마에서 심각도 제거</target>
        </trans-unit>
        <trans-unit id="b5e77c5c02a90c01b16fea8f21a1083425ebe0e0" translate="yes" xml:space="preserve">
          <source>Removed</source>
          <target state="translated">Removed</target>
        </trans-unit>
        <trans-unit id="546fa02adabca3448dcb8a362469072d1db5cf13" translate="yes" xml:space="preserve">
          <source>Removed Rules</source>
          <target state="translated">제거 된 규칙</target>
        </trans-unit>
        <trans-unit id="9e30b455061dff243e207fa18925b8c54a0ca2ad" translate="yes" xml:space="preserve">
          <source>Removed rule</source>
          <target state="translated">삭제 된 규칙</target>
        </trans-unit>
        <trans-unit id="4db98af9e39320a953bbea6bb998fe7493c40e5e" translate="yes" xml:space="preserve">
          <source>Replaced by</source>
          <target state="translated">로 교체되다</target>
        </trans-unit>
        <trans-unit id="8ada39071f07cad84f271436e272e3f53d42073a" translate="yes" xml:space="preserve">
          <source>Report Unused &lt;code&gt;eslint-disable&lt;/code&gt; Comments</source>
          <target state="translated">사용하지 않은 &lt;code&gt;eslint-disable&lt;/code&gt; 설명 신고</target>
        </trans-unit>
        <trans-unit id="a5bb62e8d7d2cc84df075be591e2610b579c891d" translate="yes" xml:space="preserve">
          <source>Reported problems have the following location information:</source>
          <target state="translated">보고 된 문제점에는 다음 위치 정보가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c54bc0da768d4c877c77485784187863c28ad3c" translate="yes" xml:space="preserve">
          <source>Reporting Bugs</source>
          <target state="translated">버그보고</target>
        </trans-unit>
        <trans-unit id="e73f2c6a276df317f0e8251b594b9c3a7772ea2d" translate="yes" xml:space="preserve">
          <source>Reporting a security vulnerability</source>
          <target state="translated">보안 취약점보고</target>
        </trans-unit>
        <trans-unit id="4ba09f6e2cd39c11132e45ba62fe27e6d6484469" translate="yes" xml:space="preserve">
          <source>Reporting back the results of the execution</source>
          <target state="translated">실행 결과보고</target>
        </trans-unit>
        <trans-unit id="7fb8531d32f9fc2cf4e7e644d67cb16c9b2b084a" translate="yes" xml:space="preserve">
          <source>Reporting warnings when certain patterns are found</source>
          <target state="translated">특정 패턴이 발견되면 경고보고</target>
        </trans-unit>
        <trans-unit id="924d4980aa5047bdf606a251026020006a83efbe" translate="yes" xml:space="preserve">
          <source>Requesting a &lt;a href=&quot;changes&quot;&gt;Change&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;changes&quot;&gt;변경&lt;/a&gt; 요청</target>
        </trans-unit>
        <trans-unit id="9670695fdbad92ea104f8e7230b9955bfb27da6e" translate="yes" xml:space="preserve">
          <source>Require === and !== (eqeqeq)</source>
          <target state="translated">=== 및! == (eqeqeq) 필요</target>
        </trans-unit>
        <trans-unit id="c9f4e2dc2e937fe6aab7b4d4c5b9b14070f93f68" translate="yes" xml:space="preserve">
          <source>Require Brace Style (brace-style)</source>
          <target state="translated">브레이스 스타일 필요 (브레이스 스타일)</target>
        </trans-unit>
        <trans-unit id="29f8a3517efa09985e94aaa3daa4acd42449e8f9" translate="yes" xml:space="preserve">
          <source>Require CamelCase (camelcase)</source>
          <target state="translated">낙타 케이스 필요 (낙타)</target>
        </trans-unit>
        <trans-unit id="e6c502a34157a55662fdb96c649dfac3dca1c26c" translate="yes" xml:space="preserve">
          <source>Require Consistent This (consistent-this)</source>
          <target state="translated">일관성이 필요함 (일관성)</target>
        </trans-unit>
        <trans-unit id="32bfc48d08ec21670f3f949a648100cdfb446f0d" translate="yes" xml:space="preserve">
          <source>Require Default Case in Switch Statements (default-case)</source>
          <target state="translated">스위치 문에 기본 대 / 소문자 필요 (기본 대 / 소문자)</target>
        </trans-unit>
        <trans-unit id="c4bf33ba1bc063ecb08ea78c74d6e52247e78f9e" translate="yes" xml:space="preserve">
          <source>Require Dot Notation (dot-notation)</source>
          <target state="translated">점 표기법 필요 (점 표기법)</target>
        </trans-unit>
        <trans-unit id="a3af1a645caf25364b15e6b49f5552b803adff40" translate="yes" xml:space="preserve">
          <source>Require Following Curly Brace Conventions (curly)</source>
          <target state="translated">곱슬 중괄호 규칙 준수 (곱슬)</target>
        </trans-unit>
        <trans-unit id="11631863fa9bc606f91797315db692789e0485a5" translate="yes" xml:space="preserve">
          <source>Require Guarding for-in (guard-for-in)</source>
          <target state="translated">보호대 필요 (guard-for-in)</target>
        </trans-unit>
        <trans-unit id="ad26fbff7070e7dd41742c51df353b22c939a838" translate="yes" xml:space="preserve">
          <source>Require IIFEs to be Wrapped (wrap-iife)</source>
          <target state="translated">IIFE를 포장해야 함 (wrap-iife)</target>
        </trans-unit>
        <trans-unit id="eedd486c2cd16ec02fb12f728bf82116a2f3dc18" translate="yes" xml:space="preserve">
          <source>Require Object Literal Shorthand Syntax (object-shorthand)</source>
          <target state="translated">객체 리터럴 약식 구문 필요 (object-shorthand)</target>
        </trans-unit>
        <trans-unit id="0f941f716fc3ec6b74fefe19704d5a768596d353" translate="yes" xml:space="preserve">
          <source>Require Or Disallow Space Before Blocks (space-before-blocks)</source>
          <target state="translated">블록 앞의 공간 필요 또는 허용 안 함 (블록 앞의 공간)</target>
        </trans-unit>
        <trans-unit id="ba41a13b01bc7714d82241f45ba769d95682a9b8" translate="yes" xml:space="preserve">
          <source>Require Radix Parameter (radix)</source>
          <target state="translated">기수 매개 변수 필요 (기수)</target>
        </trans-unit>
        <trans-unit id="4649036a73fddd6b7bf8df27f93ba7f530bd0494" translate="yes" xml:space="preserve">
          <source>Require Regex Literals to be Wrapped (wrap-regex)</source>
          <target state="translated">정규식 리터럴을 래핑해야 함 (랩핑 정규식)</target>
        </trans-unit>
        <trans-unit id="7b4e071d32a73a0c6741662339d8cb1bea0829d1" translate="yes" xml:space="preserve">
          <source>Require Variable Declarations to be at the top of their scope (vars-on-top)</source>
          <target state="translated">변수 선언이 해당 범위의 상단에 있어야 함 (vars-on-top)</target>
        </trans-unit>
        <trans-unit id="c6b80ff02932afc7cc099abcdbfedd2d3d1808fb" translate="yes" xml:space="preserve">
          <source>Require braces in arrow function body (arrow-body-style)</source>
          <target state="translated">화살표 함수 바디에 괄호 필요 (화살표 바디 스타일)</target>
        </trans-unit>
        <trans-unit id="5f98bbcd6bc31019c27bf6149a981097646acd25" translate="yes" xml:space="preserve">
          <source>Require grouped accessor pairs in object literals and classes (grouped-accessor-pairs)</source>
          <target state="translated">객체 리터럴 및 클래스에 그룹화 된 접근 자 쌍 필요 (그룹화 된 접근 자 쌍)</target>
        </trans-unit>
        <trans-unit id="be3fbbc21cd8535fe4650e22a2253265af6b017c" translate="yes" xml:space="preserve">
          <source>Require or disallow Yoda Conditions (yoda)</source>
          <target state="translated">요다 조건 필요 또는 금지 (요다)</target>
        </trans-unit>
        <trans-unit id="3150215ce32a56ca1cf1f6ef2c30ca41b3749bd6" translate="yes" xml:space="preserve">
          <source>Require or disallow a space before function parenthesis (space-before-function-paren)</source>
          <target state="translated">함수 괄호 앞에 공백 필요 또는 허용하지 않음</target>
        </trans-unit>
        <trans-unit id="5b30f13883fdda696fb76a56e4bd8aac05c52c33" translate="yes" xml:space="preserve">
          <source>Require or disallow named &lt;code&gt;function&lt;/code&gt; expressions (func-names)</source>
          <target state="translated">명명 된 &lt;code&gt;function&lt;/code&gt; 표현식 필요 (Func-names)</target>
        </trans-unit>
        <trans-unit id="6923954808ca2c5768d91fe26208484172008328" translate="yes" xml:space="preserve">
          <source>Require or disallow padding lines between statements (padding-line-between-statements)</source>
          <target state="translated">명령문 사이에 패딩 라인을 요구하거나 허용하지 않습니다 (패딩 라인 사이의 명령문)</target>
        </trans-unit>
        <trans-unit id="64d620bf8940dde332be8b599fc3f3b67a15d6b1" translate="yes" xml:space="preserve">
          <source>Require or disallow spaces before/after unary operators (space-unary-ops)</source>
          <target state="translated">단항 연산자 (space-unary-ops) 전 / 후에 공백 필요 또는 불허</target>
        </trans-unit>
        <trans-unit id="2e4ed016a312c06b04085359a4f3ce7e5514db8a" translate="yes" xml:space="preserve">
          <source>Require or disallow spacing between template tags and their literals (template-tag-spacing)</source>
          <target state="translated">템플릿 태그와 해당 리터럴 사이의 간격을 요구하거나 허용하지 않습니다 (템플릿 태그 간격).</target>
        </trans-unit>
        <trans-unit id="9a6d4f3d8ac0a43fa465b1bfeb17312af22eec9d" translate="yes" xml:space="preserve">
          <source>Require or disallow the Unicode Byte Order Mark (BOM) (unicode-bom)</source>
          <target state="translated">BOM (Unicode Byte Order Mark) 필요 또는 금지 (unicode-bom)</target>
        </trans-unit>
        <trans-unit id="5414253a02d05bc00109d790a3a30b0adf3a9258" translate="yes" xml:space="preserve">
          <source>Require parens in arrow function arguments (arrow-parens)</source>
          <target state="translated">화살표 함수 인수에 화살표가 필요합니다 (화살표)</target>
        </trans-unit>
        <trans-unit id="6c6d01b7d910c82fc9e7e87b504603648dc910c7" translate="yes" xml:space="preserve">
          <source>Require regex literals to escape division operators.</source>
          <target state="translated">나누기 연산자를 이스케이프하려면 정규식 리터럴이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c6c78079204bca77a98f474edfbb061ab779251e" translate="yes" xml:space="preserve">
          <source>Require space before/after arrow function's arrow (arrow-spacing)</source>
          <target state="translated">화살표 기능의 화살표 전후 화살표가 필요합니다 (화살표 간격).</target>
        </trans-unit>
        <trans-unit id="3d1e419b6e19b50c4107c427e372b159f6aa3f96" translate="yes" xml:space="preserve">
          <source>Require spaces following &lt;code&gt;return&lt;/code&gt;, &lt;code&gt;throw&lt;/code&gt;, and &lt;code&gt;case&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt; , &lt;code&gt;throw&lt;/code&gt; 및 &lt;code&gt;case&lt;/code&gt; 뒤에 공백이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="2aa899302df0644585abff63972bace73e121583" translate="yes" xml:space="preserve">
          <source>Require spaces following unary word operators.</source>
          <target state="translated">단항 단어 연산자 뒤에 공백이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="72a6e138634f7c51472518cc96850ccfd3e29b3f" translate="yes" xml:space="preserve">
          <source>Require using arrow functions for callbacks (prefer-arrow-callback)</source>
          <target state="translated">콜백에 화살표 기능 사용 필요 (화살표 콜백 선호)</target>
        </trans-unit>
        <trans-unit id="1d4909a86e26429441b20437aa655cdf89900831" translate="yes" xml:space="preserve">
          <source>Requires or disallows a whitespace (space or tab) beginning a comment (spaced-comment)</source>
          <target state="translated">주석 (공백 주석)을 시작하는 공백 (공백 또는 탭)을 요구하거나 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="76af06a553a0453a9044a446da55d272ab01d8fe" translate="yes" xml:space="preserve">
          <source>Requires that every file have a top-level &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; statement.</source>
          <target state="translated">모든 파일에는 최상위 &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; 문 이 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="e58d216d4c343337c98dbf82f961ebd1b1a6fd84" translate="yes" xml:space="preserve">
          <source>Requiring Configuration to Run</source>
          <target state="translated">실행할 구성 요구</target>
        </trans-unit>
        <trans-unit id="a190ae07585f55210601db70caeb73d10cf5a08d" translate="yes" xml:space="preserve">
          <source>Reserved words as property names</source>
          <target state="translated">속성 이름으로 예약어</target>
        </trans-unit>
        <trans-unit id="87df60de337fb58864343e396696d74611e0d403" translate="yes" xml:space="preserve">
          <source>Resources</source>
          <target state="translated">Resources</target>
        </trans-unit>
        <trans-unit id="787f008daf743bf86dcef2a2f647bc232a0260e8" translate="yes" xml:space="preserve">
          <source>Respond to comments left on the pull request from team members. Remember, we want to help you land your code, so please be receptive to our feedback.</source>
          <target state="translated">팀 구성원의 풀 요청에 남겨진 의견에 응답하십시오. 코드를 작성하는 데 도움을 드리고자합니다. 피드백을 받아 주시기 바랍니다.</target>
        </trans-unit>
        <trans-unit id="5e8db4f15f13d726195782f734cfad7c22163767" translate="yes" xml:space="preserve">
          <source>Restrict what can be thrown as an exception (no-throw-literal)</source>
          <target state="translated">예외로 던질 수있는 것을 제한하십시오 (th-th-literal)</target>
        </trans-unit>
        <trans-unit id="d0dfe217a11c007cdb80ffac3d869a5f9a91d024" translate="yes" xml:space="preserve">
          <source>Restricting syntax with selectors</source>
          <target state="translated">선택기로 구문 제한</target>
        </trans-unit>
        <trans-unit id="0cde1762953d450159956d185082cff8d76cd6b3" translate="yes" xml:space="preserve">
          <source>Resulting actual config: &lt;code&gt;&quot;eqeqeq&quot;: [&quot;warn&quot;, &quot;allow-null&quot;]&lt;/code&gt;</source>
          <target state="translated">결과 실제 구성 : &lt;code&gt;&quot;eqeqeq&quot;: [&quot;warn&quot;, &quot;allow-null&quot;]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="637d7bf830d8b7c31d75616f1f6184a3ad69451f" translate="yes" xml:space="preserve">
          <source>Resulting actual config: &lt;code&gt;&quot;quotes&quot;: [&quot;error&quot;, &quot;single&quot;]&lt;/code&gt;</source>
          <target state="translated">실제 구성 결과 : &lt;code&gt;&quot;quotes&quot;: [&quot;error&quot;, &quot;single&quot;]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b969c8dc0ad380e6594b1beedc5370d8f8a5d756" translate="yes" xml:space="preserve">
          <source>Retrieves a formatter, which you can then use to format a report object. The argument is either the name of a built-in formatter:</source>
          <target state="translated">보고서 개체를 형식화하는 데 사용할 수있는 포맷터를 검색합니다. 인수는 내장 포맷터의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="4ed1a51e3c7c6cf43a3633b3e58f69e74b9dd263" translate="yes" xml:space="preserve">
          <source>Return Value</source>
          <target state="translated">반환 값</target>
        </trans-unit>
        <trans-unit id="426dd4f5734405b3041af3bb0cf97c4f743e8aa6" translate="yes" xml:space="preserve">
          <source>Returning the correct exit code</source>
          <target state="translated">올바른 종료 코드 리턴</target>
        </trans-unit>
        <trans-unit id="a8af8ce64c5e78a1bab5c7411bdc15d47c7d3cee" translate="yes" xml:space="preserve">
          <source>Rollup: &lt;a href=&quot;https://www.npmjs.com/package/rollup-plugin-eslint&quot;&gt;rollup-plugin-eslint&lt;/a&gt;</source>
          <target state="translated">롤업 : &lt;a href=&quot;https://www.npmjs.com/package/rollup-plugin-eslint&quot;&gt;rollup-plugin-eslint&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ee3c4356687403593882e1c450ecd5fa91ef9176" translate="yes" xml:space="preserve">
          <source>Rule Acceptance Criteria</source>
          <target state="translated">규칙 수락 기준</target>
        </trans-unit>
        <trans-unit id="4fea3171fe249e115dde51b612942d51ff597112" translate="yes" xml:space="preserve">
          <source>Rule Basics</source>
          <target state="translated">규칙 기본</target>
        </trans-unit>
        <trans-unit id="58f4d8dcadb0bda6b1de9bc0a5d352f60cf07234" translate="yes" xml:space="preserve">
          <source>Rule Changes</source>
          <target state="translated">규칙 변경</target>
        </trans-unit>
        <trans-unit id="7fd1351f99409305b16b0a09a4498bd284b5d93e" translate="yes" xml:space="preserve">
          <source>Rule Deprecation</source>
          <target state="translated">사용 중단 규칙</target>
        </trans-unit>
        <trans-unit id="2f74fe952a58aefbda52fe4dd186b37f5595f912" translate="yes" xml:space="preserve">
          <source>Rule Details</source>
          <target state="translated">규칙 세부 사항</target>
        </trans-unit>
        <trans-unit id="a6cbaaefbab1ddfd94efe95cec74c44f36be693f" translate="yes" xml:space="preserve">
          <source>Rule Naming Conventions</source>
          <target state="translated">규칙 명명 규칙</target>
        </trans-unit>
        <trans-unit id="3183951c7dd470388a3c3557d1a5436eae05d87f" translate="yes" xml:space="preserve">
          <source>Rule Schema Changes</source>
          <target state="translated">규칙 스키마 변경</target>
        </trans-unit>
        <trans-unit id="793bcb95f3d538bb319a28344fffc4123fe887c4" translate="yes" xml:space="preserve">
          <source>Rule Unit Tests</source>
          <target state="translated">규칙 단위 테스트</target>
        </trans-unit>
        <trans-unit id="ebc497fdd0042b59fbb043aa6dad9e62ad6aaedd" translate="yes" xml:space="preserve">
          <source>Rule configuration are validated more strictly</source>
          <target state="translated">규칙 구성이보다 엄격하게 검증됩니다</target>
        </trans-unit>
        <trans-unit id="b423a892d42c8b952873772e3d160731bd071f84" translate="yes" xml:space="preserve">
          <source>Rule source</source>
          <target state="translated">규칙 소스</target>
        </trans-unit>
        <trans-unit id="c79090f879452ce67b81c8904f848b8ac0346c07" translate="yes" xml:space="preserve">
          <source>Rule to disallow a duplicate case label (no-duplicate-case)</source>
          <target state="translated">중복 사례 라벨을 허용하지 않는 규칙 (중복 사례 없음)</target>
        </trans-unit>
        <trans-unit id="a6dc24b3b766471c01f26defe2df961bd51fa80c" translate="yes" xml:space="preserve">
          <source>RuleTester</source>
          <target state="translated">RuleTester</target>
        </trans-unit>
        <trans-unit id="bb11a8e3f8712e36e7cd9d1c615a4e3dbb03336a" translate="yes" xml:space="preserve">
          <source>Rules</source>
          <target state="translated">Rules</target>
        </trans-unit>
        <trans-unit id="8af516527308d5f596f472b28e50707a3c2ec990" translate="yes" xml:space="preserve">
          <source>Rules are now required to provide messages along with reports</source>
          <target state="translated">보고서와 함께 메시지를 제공하는 규칙이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c130e2f455ef978067c1ba9937f4a4b55ad9b4d6" translate="yes" xml:space="preserve">
          <source>Rules in ESLint are grouped by category to help you understand their purpose.</source>
          <target state="translated">ESLint의 규칙은 범주별로 그룹화되어 목적을 이해하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="a375a11830a6fc15a9c077874fa2553a5e211c2a" translate="yes" xml:space="preserve">
          <source>Rules in Plugins</source>
          <target state="translated">플러그인 규칙</target>
        </trans-unit>
        <trans-unit id="6012963a27096009406f4a3e3efbeb71a5dd3e0c" translate="yes" xml:space="preserve">
          <source>Rules like &lt;a href=&quot;../rules/max-len&quot;&gt;&lt;code&gt;max-len&lt;/code&gt;&lt;/a&gt; accept a string option which is interpreted as a regular expression. In ESLint v6.0.0, these regular expressions are interpreted with the &lt;a href=&quot;https://mathiasbynens.be/notes/es6-unicode-regex&quot;&gt;unicode flag&lt;/a&gt;, which should exhibit more reasonable behavior when matching characters like astral symbols. Unicode regexes also validate escape sequences more strictly than non-unicode regexes.</source>
          <target state="translated">&lt;a href=&quot;../rules/max-len&quot;&gt; &lt;code&gt;max-len&lt;/code&gt; &lt;/a&gt; 과 같은 규칙 은 정규식으로 해석되는 문자열 옵션을 허용합니다. ESLint v6.0.0에서 이러한 정규식은 &lt;a href=&quot;https://mathiasbynens.be/notes/es6-unicode-regex&quot;&gt;유니 코드 플래그&lt;/a&gt; 로 해석되며 , 이는 아스트랄 기호와 같은 문자를 일치시킬 때보다 합리적인 동작을 나타내야합니다. 유니 코드 정규 표현식은 비 유니 코드 정규 표현식보다 더 엄격하게 이스케이프 시퀀스의 유효성을 검사합니다.</target>
        </trans-unit>
        <trans-unit id="ce446a008739b0122bfbf913623e68d18926810d" translate="yes" xml:space="preserve">
          <source>Rules may export a &lt;code&gt;schema&lt;/code&gt; property, which is a &lt;a href=&quot;http://json-schema.org/&quot;&gt;JSON schema&lt;/a&gt; format description of a rule's options which will be used by ESLint to validate configuration options and prevent invalid or unexpected inputs before they are passed to the rule in &lt;code&gt;context.options&lt;/code&gt;.</source>
          <target state="translated">규칙은 &lt;code&gt;schema&lt;/code&gt; 옵션을 내보낼 수 있습니다.이 속성은 ESLint에서 구성 옵션의 유효성을 검사하고 &lt;code&gt;context.options&lt;/code&gt; 의 규칙에 전달되기 전에 유효하지 않은 또는 예기치 않은 입력을 방지하기 위해 사용되는 규칙 옵션의 &lt;a href=&quot;http://json-schema.org/&quot;&gt;JSON 스키마&lt;/a&gt; 형식 설명입니다 .</target>
        </trans-unit>
        <trans-unit id="93c2759fe03a902a67d153b036b0d4f1c07d1f3c" translate="yes" xml:space="preserve">
          <source>Rules will be deprecated as needed, and marked as such in all documentation.</source>
          <target state="translated">규칙은 필요에 따라 더 이상 사용되지 않으며 모든 문서에 그대로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e93f0f77000adc61fb508077599d138239b58cd6" translate="yes" xml:space="preserve">
          <source>Rules will never be removed from ESLint.</source>
          <target state="translated">ESLint에서 규칙이 제거되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3d27ff71d65030f0e00381932a052d2a17b92776" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;../user-guide/command-line-interface&quot;&gt;command line interface&lt;/a&gt; using the &lt;code&gt;--rulesdir&lt;/code&gt; option to specify the location of your runtime rules.</source>
          <target state="translated">&lt;code&gt;--rulesdir&lt;/code&gt; 옵션을 사용하여 &lt;a href=&quot;../user-guide/command-line-interface&quot;&gt;명령 행 인터페이스&lt;/a&gt; 를 실행 하여 런타임 규칙의 위치를 ​​지정하십시오.</target>
        </trans-unit>
        <trans-unit id="95227c2b581e8476ae8110dc2d62c41753abc92b" translate="yes" xml:space="preserve">
          <source>Run the tests</source>
          <target state="translated">테스트를 실행</target>
        </trans-unit>
        <trans-unit id="82584eccefdf0e64733530fb7b37a5c4e7baadbe" translate="yes" xml:space="preserve">
          <source>Running &lt;code&gt;eslint&lt;/code&gt; with the previous custom formatter,</source>
          <target state="translated">이전 사용자 정의 포맷터로 &lt;code&gt;eslint&lt;/code&gt; 를 실행 하면</target>
        </trans-unit>
        <trans-unit id="cc4ca7c771cd08213f4b8be7b584910f7669bad1" translate="yes" xml:space="preserve">
          <source>Running Individual Tests</source>
          <target state="translated">개별 테스트 실행</target>
        </trans-unit>
        <trans-unit id="441a534445ce234b3c86dbe18e6044480f3bedfd" translate="yes" xml:space="preserve">
          <source>Running individual tests is useful when you're working on a specific bug and iterating on the solution. You should be sure to run &lt;code&gt;npm test&lt;/code&gt; before submitting a pull request.</source>
          <target state="translated">개별 테스트를 실행하면 특정 버그에 대해 작업하고 솔루션을 반복 할 때 유용합니다. 풀 요청을 제출하기 전에 &lt;code&gt;npm test&lt;/code&gt; 를 실행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5d976eb8e273ca6d6ba9fdfa6ef367a56a3b6ffd" translate="yes" xml:space="preserve">
          <source>Running the tests is the best way to ensure you have correctly set up your development environment. Make sure you're in the &lt;code&gt;eslint&lt;/code&gt; directory and run:</source>
          <target state="translated">테스트를 실행하는 것이 개발 환경을 올바르게 설정했는지 확인하는 가장 좋은 방법입니다. &lt;code&gt;eslint&lt;/code&gt; 디렉토리 에 있는지 확인 하고 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="d106aea3ee94c9ea07b2d08364473f5561ff6c88" translate="yes" xml:space="preserve">
          <source>Runs a subset of tests in PhantomJS</source>
          <target state="translated">PhantomJS에서 테스트의 하위 집합을 실행합니다</target>
        </trans-unit>
        <trans-unit id="3a49577a7bd2d4bd0341a073ea8ac28454947600" translate="yes" xml:space="preserve">
          <source>Runs all tests on Node.js</source>
          <target state="translated">Node.js에서 모든 테스트를 실행합니다</target>
        </trans-unit>
        <trans-unit id="2242ca7138a532d29176cff8e842e87d6315b52e" translate="yes" xml:space="preserve">
          <source>Runs just the JavaScript and JSON linting on the repository</source>
          <target state="translated">리포지토리에서 JavaScript 및 JSON Linting 만 실행합니다.</target>
        </trans-unit>
        <trans-unit id="16d64887294214d8ed081b14945edfe9e11fdda5" translate="yes" xml:space="preserve">
          <source>Runtime Rules</source>
          <target state="translated">런타임 규칙</target>
        </trans-unit>
        <trans-unit id="735c74977973d2da5bffd227fd5f002279654583" translate="yes" xml:space="preserve">
          <source>Runtime rules are written in the same format as all other rules. Create your rule as you would any other and then follow these steps:</source>
          <target state="translated">런타임 규칙은 다른 모든 규칙과 동일한 형식으로 작성됩니다. 다른 방법으로 규칙을 작성한 후 다음 단계를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="d4a37f09fbd0b4d14017c11606211cf2ba713d3b" translate="yes" xml:space="preserve">
          <source>Sails.js: &lt;a href=&quot;https://www.npmjs.com/package/sails-hook-lint&quot;&gt;sails-hook-lint&lt;/a&gt;, &lt;a href=&quot;https://www.npmjs.com/package/sails-eslint&quot;&gt;sails-eslint&lt;/a&gt;</source>
          <target state="translated">Sails.js : 세일링 &lt;a href=&quot;https://www.npmjs.com/package/sails-hook-lint&quot;&gt;린트&lt;/a&gt; , &lt;a href=&quot;https://www.npmjs.com/package/sails-eslint&quot;&gt;세일링 엘리트&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="09d7f145b9b7e1d0c79daf58a80e9abbdc849945" translate="yes" xml:space="preserve">
          <source>Same reason as the point above: You shouldn't configure terms that are used very often (e.g. central parts of the native language used in your comments).</source>
          <target state="translated">위의 요점과 같은 이유 : 자주 사용되는 용어 (예 : 주석에 사용되는 모국어의 중앙 부분)를 구성해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="7c671e8c47943a8c325952dde1f0ea58ab681314" translate="yes" xml:space="preserve">
          <source>Scope Analysis Changes</source>
          <target state="translated">범위 분석 변경</target>
        </trans-unit>
        <trans-unit id="36ab5b6d2a8bb7e55f7b1d6b39e4e5ce11688937" translate="yes" xml:space="preserve">
          <source>Scope Type</source>
          <target state="translated">범위 유형</target>
        </trans-unit>
        <trans-unit id="1ababc4ffaa5b7bdf69961b71c11caa9ddda5aef" translate="yes" xml:space="preserve">
          <source>Scope interface</source>
          <target state="translated">범위 인터페이스</target>
        </trans-unit>
        <trans-unit id="0a313e66995747d51d210db31cc5a359aecf5923" translate="yes" xml:space="preserve">
          <source>ScopeManager</source>
          <target state="translated">ScopeManager</target>
        </trans-unit>
        <trans-unit id="f83f415575654aec918367fa7b4efd53484afeb7" translate="yes" xml:space="preserve">
          <source>ScopeManager interface</source>
          <target state="translated">ScopeManager 인터페이스</target>
        </trans-unit>
        <trans-unit id="9f61e165e4f63a9799a4482983a897b3c392fb00" translate="yes" xml:space="preserve">
          <source>Second option</source>
          <target state="translated">두 번째 옵션</target>
        </trans-unit>
        <trans-unit id="37b1dc04082b220b42be965eea192bef3c547ba5" translate="yes" xml:space="preserve">
          <source>Second, it advances to &lt;code&gt;ForStatement.body&lt;/code&gt;. Of course the &lt;code&gt;body&lt;/code&gt; segment is preceded by the &lt;code&gt;test&lt;/code&gt; segment. It keeps the &lt;code&gt;update&lt;/code&gt; segment hovering.</source>
          <target state="translated">둘째, &lt;code&gt;ForStatement.body&lt;/code&gt; 로 진행합니다 . 물론 &lt;code&gt;body&lt;/code&gt; 세그먼트 앞에 &lt;code&gt;test&lt;/code&gt; 세그먼트가 있습니다. 그것은 계속 &lt;code&gt;update&lt;/code&gt; 세그먼트 떠오르게합니다.</target>
        </trans-unit>
        <trans-unit id="8323971eba037489129f23f49f88dde8358fa8ad" translate="yes" xml:space="preserve">
          <source>Second, it creates the looping path. At this time, the next segment has existed already, so the &lt;code&gt;onCodePathSegmentStart&lt;/code&gt; event is not fired. It fires &lt;code&gt;onCodePathSegmentLoop&lt;/code&gt; instead.</source>
          <target state="translated">둘째, 루핑 경로를 만듭니다. 현재 다음 세그먼트가 이미 존재 했으므로 &lt;code&gt;onCodePathSegmentStart&lt;/code&gt; 이벤트가 시작되지 않습니다. 대신 &lt;code&gt;onCodePathSegmentLoop&lt;/code&gt; 를 발생 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="5b4acc9dc16ce636a836361190495f1196e2d6f8" translate="yes" xml:space="preserve">
          <source>Section 1: Get the &lt;a href=&quot;source-code&quot;&gt;Source Code&lt;/a&gt;</source>
          <target state="translated">섹션 1 : &lt;a href=&quot;source-code&quot;&gt;소스 코드&lt;/a&gt; 얻기</target>
        </trans-unit>
        <trans-unit id="3b1637242cb5f4b3e36d4492cd36c48e74446f57" translate="yes" xml:space="preserve">
          <source>Section 2: Set up a &lt;a href=&quot;development-environment&quot;&gt;Development Environment&lt;/a&gt;</source>
          <target state="translated">섹션 2 : &lt;a href=&quot;development-environment&quot;&gt;개발 환경&lt;/a&gt; 설정</target>
        </trans-unit>
        <trans-unit id="78f0e7c8b704185ecfe739a5f8c33c68a075ef9e" translate="yes" xml:space="preserve">
          <source>Section 3: Run the &lt;a href=&quot;unit-tests&quot;&gt;Unit Tests&lt;/a&gt;</source>
          <target state="translated">섹션 3 : &lt;a href=&quot;unit-tests&quot;&gt;단위 테스트&lt;/a&gt; 실행</target>
        </trans-unit>
        <trans-unit id="d3b79d5d78e14a8c4b0ba5bc3059259a23cad08b" translate="yes" xml:space="preserve">
          <source>Section 4: &lt;a href=&quot;working-with-rules&quot;&gt;Working with Rules&lt;/a&gt;</source>
          <target state="translated">섹션 4 : &lt;a href=&quot;working-with-rules&quot;&gt;규칙 작업&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="03c3cb69551b14b8df9cb910afaab136f027242f" translate="yes" xml:space="preserve">
          <source>Section 5: &lt;a href=&quot;working-with-plugins&quot;&gt;Working with Plugins&lt;/a&gt;</source>
          <target state="translated">섹션 5 : &lt;a href=&quot;working-with-plugins&quot;&gt;플러그인 작업&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7b994bfa5badb9f811f171491ad2085ca2163162" translate="yes" xml:space="preserve">
          <source>Section 6: &lt;a href=&quot;working-with-custom-parsers&quot;&gt;Working with Custom Parsers&lt;/a&gt;</source>
          <target state="translated">섹션 6 : &lt;a href=&quot;working-with-custom-parsers&quot;&gt;사용자 정의 파서 작업&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7cef9b81d7487df40316eccfb3ac59bb6e5049a8" translate="yes" xml:space="preserve">
          <source>Section 7: &lt;a href=&quot;nodejs-api&quot;&gt;Node.js API&lt;/a&gt;</source>
          <target state="translated">섹션 7 : &lt;a href=&quot;nodejs-api&quot;&gt;Node.js API&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b89f1494eec98976470a195404c75143a7d87a8b" translate="yes" xml:space="preserve">
          <source>Section 8: &lt;a href=&quot;contributing/index&quot;&gt;Contributing&lt;/a&gt;</source>
          <target state="translated">섹션 8 : &lt;a href=&quot;contributing/index&quot;&gt;기여&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a36f58a29f1275ec5d968141f07cf060b746bc67" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../user-guide/configuring#specifying-processor&quot;&gt;Specifying Processor&lt;/a&gt; for details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;../user-guide/configuring#specifying-processor&quot;&gt;프로세서 지정&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1b6969594f8da02157a002f4a80fcf1d497e64bb" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;no-dupe-class-members&quot;&gt;no-dupe-class-members&lt;/a&gt; if you also want to disallow duplicate names in class definitions.</source>
          <target state="translated">클래스 정의에서 중복 이름을 허용하지 않으려면 &lt;a href=&quot;no-dupe-class-members&quot;&gt;no-dupe-class-members를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b75b5956411bc41a59d15e137400fe418c3a0502" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;no-dupe-keys&quot;&gt;no-dupe-keys&lt;/a&gt; if you also want to disallow duplicate keys in object literals.</source>
          <target state="translated">볼 &lt;a href=&quot;no-dupe-keys&quot;&gt;노 속는 - 키를&lt;/a&gt; 당신은 또한 객체 리터럴에 중복 키를 허용하지 않으려합니다.</target>
        </trans-unit>
        <trans-unit id="61a08f389a25b863d0fca5015a2885ff6fd5c8cd" translate="yes" xml:space="preserve">
          <source>See Also:</source>
          <target state="translated">또한보십시오:</target>
        </trans-unit>
        <trans-unit id="2601bab23f6d6b7f8c2a0b4d06f87b74ca15b5fc" translate="yes" xml:space="preserve">
          <source>See Also: &lt;a href=&quot;https://github.com/eslint/eslint/blob/master/lib/rules/constructor-super.js&quot;&gt;constructor-super&lt;/a&gt;, &lt;a href=&quot;https://github.com/eslint/eslint/blob/master/lib/rules/no-this-before-super.js&quot;&gt;no-this-before-super&lt;/a&gt;</source>
          <target state="translated">다음도 참조 : &lt;a href=&quot;https://github.com/eslint/eslint/blob/master/lib/rules/constructor-super.js&quot;&gt;constructor-super&lt;/a&gt; , &lt;a href=&quot;https://github.com/eslint/eslint/blob/master/lib/rules/no-this-before-super.js&quot;&gt;no-this-before-super&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1f2f2da9007ba35b167fb5fbeeeef552aaaf5204" translate="yes" xml:space="preserve">
          <source>See Also: &lt;a href=&quot;https://github.com/eslint/eslint/blob/master/lib/rules/no-unreachable.js&quot;&gt;no-unreachable&lt;/a&gt;, &lt;a href=&quot;https://github.com/eslint/eslint/blob/master/lib/rules/no-fallthrough.js&quot;&gt;no-fallthrough&lt;/a&gt;, &lt;a href=&quot;https://github.com/eslint/eslint/blob/master/lib/rules/consistent-return.js&quot;&gt;consistent-return&lt;/a&gt;</source>
          <target state="translated">다음 사항도 참조 : &lt;a href=&quot;https://github.com/eslint/eslint/blob/master/lib/rules/no-unreachable.js&quot;&gt;연결할 수 없음&lt;/a&gt; , 오류 &lt;a href=&quot;https://github.com/eslint/eslint/blob/master/lib/rules/no-fallthrough.js&quot;&gt;없음&lt;/a&gt; , &lt;a href=&quot;https://github.com/eslint/eslint/blob/master/lib/rules/consistent-return.js&quot;&gt;일관된 반환&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5475994619c5659ff506420bcda0f2341a59e086" translate="yes" xml:space="preserve">
          <source>See all &lt;a href=&quot;https://www.npmjs.com/search?q=eslint-formatter&quot;&gt;formatters on npm&lt;/a&gt;;</source>
          <target state="translated">&lt;a href=&quot;https://www.npmjs.com/search?q=eslint-formatter&quot;&gt;npm의&lt;/a&gt; 모든 포맷터를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d711728163616d324e06d612e575de7b428f280d" translate="yes" xml:space="preserve">
          <source>See also: the &lt;a href=&quot;https://github.com/eslint/eslint/commit/e3e9dbd9876daf4bdeb4e15f8a76a9d5e6e03e39#diff-b01a5cfd9361ca9280a460fd6bb8edbbL1&quot;&gt;full diff&lt;/a&gt; where the defaults were changed.</source>
          <target state="translated">기본값이 변경된 &lt;a href=&quot;https://github.com/eslint/eslint/commit/e3e9dbd9876daf4bdeb4e15f8a76a9d5e6e03e39#diff-b01a5cfd9361ca9280a460fd6bb8edbbL1&quot;&gt;전체 diff&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4df28d2cb8a74e0553a8b501f660f7fd482671ed" translate="yes" xml:space="preserve">
          <source>Selectors</source>
          <target state="translated">Selectors</target>
        </trans-unit>
        <trans-unit id="ba1dd4d24595765d36380d449f2f63da8783485e" translate="yes" xml:space="preserve">
          <source>Selectors are not limited to matching against single node types. For example, the selector &lt;code&gt;VariableDeclarator &amp;gt; Identifier&lt;/code&gt; will match all &lt;code&gt;Identifier&lt;/code&gt; nodes that have a &lt;code&gt;VariableDeclarator&lt;/code&gt; as a direct parent. In the program above, this will match the node for &lt;code&gt;foo&lt;/code&gt;, but not the nodes for &lt;code&gt;bar&lt;/code&gt; and &lt;code&gt;baz&lt;/code&gt;.</source>
          <target state="translated">선택기는 단일 노드 유형과 일치하는 것으로 제한되지 않습니다. 예를 들어, 선택자 &lt;code&gt;VariableDeclarator &amp;gt; Identifier&lt;/code&gt; 는 &lt;code&gt;VariableDeclarator&lt;/code&gt; 가 직접 상위 인 모든 &lt;code&gt;Identifier&lt;/code&gt; 노드 와 일치합니다 . 위 프로그램에서 이는 &lt;code&gt;foo&lt;/code&gt; 의 노드와 일치 하지만 &lt;code&gt;bar&lt;/code&gt; 및 &lt;code&gt;baz&lt;/code&gt; 의 노드는 일치 하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="52a3f1908b1bbd91b0b9259682b062315f687ab1" translate="yes" xml:space="preserve">
          <source>Self assignments have no effect, so probably those are an error due to incomplete refactoring. Those indicate that what you should do is still remaining.</source>
          <target state="translated">자체 할당은 효과가 없으므로 불완전한 리팩토링으로 인한 오류 일 수 있습니다. 그것들은 당신이해야 할 일은 여전히 ​​남아 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f7959cd9f43abd1103f282c5754afbee5224b16f" translate="yes" xml:space="preserve">
          <source>Semicolons are usually optional in JavaScript, because of automatic semicolon insertion (ASI). You can require or disallow semicolons with the &lt;a href=&quot;semi&quot;&gt;semi&lt;/a&gt; rule.</source>
          <target state="translated">세미콜론은 자동 세미콜론 삽입 (ASI)으로 인해 일반적으로 JavaScript에서 선택 사항입니다. &lt;a href=&quot;semi&quot;&gt;세미&lt;/a&gt; 규칙으로 세미콜론을 요구하거나 허용하지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7ef827951df1f89ec5fb16c5c417655c418fa285" translate="yes" xml:space="preserve">
          <source>Sequence expressions (those using a comma, such as &lt;code&gt;a = 1, b = 2&lt;/code&gt;) are always considered unused unless their return value is assigned or used in a condition evaluation, or a function call is made with the sequence expression value.</source>
          <target state="translated">시퀀스 표현식 ( &lt;code&gt;a = 1, b = 2&lt;/code&gt; 와 같은 쉼표를 사용하는 표현식 )은 리턴 값이 조건 평가에 지정되거나 사용되지 않거나 시퀀스 표현식 값으로 함수 호출이 수행되지 않는 한 항상 사용되지 않는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="a171fcac3dd876a9a68a177995635a2d7e821db8" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;&quot;capIsConstructor&quot;&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; if you want those functions to be treated as 'regular' functions.</source>
          <target state="translated">해당 함수를 '일반'함수로 처리하려면 &lt;code&gt;&quot;capIsConstructor&quot;&lt;/code&gt; 를 &lt;code&gt;false&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="c0180f010e4da395331d6d54df6959189e9dae8b" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;&quot;enforceForIndexOf&quot;&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; if you want this rule to report &lt;code&gt;indexOf(NaN)&lt;/code&gt; and &lt;code&gt;lastIndexOf(NaN)&lt;/code&gt; method calls.</source>
          <target state="translated">이 규칙이 &lt;code&gt;indexOf(NaN)&lt;/code&gt; 및 &lt;code&gt;lastIndexOf(NaN)&lt;/code&gt; 메소드 호출 을보고하도록하려면 &lt;code&gt;&quot;enforceForIndexOf&quot;&lt;/code&gt; 를 &lt;code&gt;true&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="618ceba957897722ae596312a10c551288948191" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;&quot;enforceForSwitchCase&quot;&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; if you want this rule to report &lt;code&gt;case NaN&lt;/code&gt; and &lt;code&gt;switch(NaN)&lt;/code&gt; in &lt;code&gt;switch&lt;/code&gt; statements.</source>
          <target state="translated">설정 &lt;code&gt;&quot;enforceForSwitchCase&quot;&lt;/code&gt; 에 &lt;code&gt;true&lt;/code&gt; 이 보고서에이 규칙하려는 경우 &lt;code&gt;case NaN&lt;/code&gt; 와 &lt;code&gt;switch(NaN)&lt;/code&gt; 의 &lt;code&gt;switch&lt;/code&gt; 문을.</target>
        </trans-unit>
        <trans-unit id="fa3491e34539a3ccbb31246fccfeafd612faa9f3" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;&quot;lexicalBindings&quot;&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; if you want this rule to check &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;class&lt;/code&gt; declarations as well.</source>
          <target state="translated">이 규칙이 &lt;code&gt;const&lt;/code&gt; , &lt;code&gt;let&lt;/code&gt; 및 &lt;code&gt;class&lt;/code&gt; 선언도 검사하도록하려면 &lt;code&gt;&quot;lexicalBindings&quot;&lt;/code&gt; 를 &lt;code&gt;true&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="faf94416ab2a050dcb6bbfd98218d385084c3972" translate="yes" xml:space="preserve">
          <source>Set the &lt;code&gt;allowKeywords&lt;/code&gt; option to &lt;code&gt;false&lt;/code&gt; (default is &lt;code&gt;true&lt;/code&gt;) to follow ECMAScript version 3 compatible style, avoiding dot notation for reserved word properties.</source>
          <target state="translated">예약어 속성에 대한 점 표기법을 피하면서 ECMAScript 버전 3 호환 스타일을 따르 려면 &lt;code&gt;allowKeywords&lt;/code&gt; 옵션을 &lt;code&gt;false&lt;/code&gt; (기본값은 &lt;code&gt;true&lt;/code&gt; )로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="be2fe335d32f03aea39945e0531758a541f8d75d" translate="yes" xml:space="preserve">
          <source>Set the &lt;code&gt;allowPattern&lt;/code&gt; option to a regular expression string to allow bracket notation for property names that match a pattern (by default, no pattern is tested).</source>
          <target state="translated">패턴과 일치하는 특성 이름의 대괄호 표기법을 허용 하려면 &lt;code&gt;allowPattern&lt;/code&gt; 옵션을 정규식 문자열로 설정하십시오 (기본적으로 패턴은 테스트되지 않음).</target>
        </trans-unit>
        <trans-unit id="1c81c3037407b2aa16474a63ef04fe8a38928ef4" translate="yes" xml:space="preserve">
          <source>Set the &lt;code&gt;commentPattern&lt;/code&gt; option to a regular expression string to change the default &lt;code&gt;/^no default$/i&lt;/code&gt; comment test pattern</source>
          <target state="translated">설정 &lt;code&gt;commentPattern&lt;/code&gt; 기본 변경하지 정규 표현식 문자열에 옵션을 &lt;code&gt;/^no default$/i&lt;/code&gt; 코멘트 테스트 패턴을</target>
        </trans-unit>
        <trans-unit id="0013f5c88955deac87e1686900438d34e9741c2d" translate="yes" xml:space="preserve">
          <source>Set the &lt;code&gt;commentPattern&lt;/code&gt; option to a regular expression string to change the test for intentional fallthrough comment</source>
          <target state="translated">의도적 인 오류 설명에 대한 테스트를 변경 하려면 &lt;code&gt;commentPattern&lt;/code&gt; 옵션을 정규식 문자열로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="68ce687ddf0f134fff7cf81f9dc938e6b3878d8a" translate="yes" xml:space="preserve">
          <source>Set the &lt;code&gt;int32Hint&lt;/code&gt; option to &lt;code&gt;true&lt;/code&gt; (default is &lt;code&gt;false&lt;/code&gt;) to allow write &lt;code&gt;a|0&lt;/code&gt; without space.</source>
          <target state="translated">공백없이 &lt;code&gt;a|0&lt;/code&gt; 을 쓸 수있게 하려면 &lt;code&gt;int32Hint&lt;/code&gt; 옵션을 &lt;code&gt;true&lt;/code&gt; (기본값은 &lt;code&gt;false&lt;/code&gt; )로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="3134ee2112bdc78853bd1511d97b31e6159ccb88" translate="yes" xml:space="preserve">
          <source>Set to &lt;code&gt;true&lt;/code&gt; by default. Setting this option to &lt;code&gt;false&lt;/code&gt; allows constant expressions in loops.</source>
          <target state="translated">기본적 으로 &lt;code&gt;true&lt;/code&gt; 로 설정하십시오. 이 옵션을 &lt;code&gt;false&lt;/code&gt; 로 설정하면 루프에서 상수 표현식이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="70eda033c7f0c498a86724919e7320f305b80b0d" translate="yes" xml:space="preserve">
          <source>Set up a &lt;a href=&quot;../development-environment&quot;&gt;development environment&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../development-environment&quot;&gt;개발 환경을&lt;/a&gt; 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="f8322127967adf862ac72c512b139ae1854bca05" translate="yes" xml:space="preserve">
          <source>Setters cannot return values.</source>
          <target state="translated">세터는 값을 반환 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c9c749d001ff268cbeb4ea4c24c216a86d9a6a4d" translate="yes" xml:space="preserve">
          <source>Setting parser options helps ESLint determine what is a parsing error. All language options are &lt;code&gt;false&lt;/code&gt; by default.</source>
          <target state="translated">구문 분석기 옵션을 설정하면 ESLint가 구문 분석 오류를 판별하는 데 도움이됩니다. 모든 언어 옵션은 기본적으로 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="37c53c1b3fac94914ae01b6fca4c4e53991f792a" translate="yes" xml:space="preserve">
          <source>Setting the &lt;code&gt;ignoreInlineComments&lt;/code&gt; option to &lt;code&gt;true&lt;/code&gt; means that comments in the middle of code (with a token on the same line as the beginning of the comment, and another token on the same line as the end of the comment) will not be reported by this rule.</source>
          <target state="translated">&lt;code&gt;ignoreInlineComments&lt;/code&gt; 옵션을 &lt;code&gt;true&lt;/code&gt; 로 설정하면 코드 중간의 주석 (주석의 시작과 동일한 행에 토큰이 있고 주석의 끝과 동일한 행에 다른 토큰이 있음)은이 규칙에 의해보고되지 않습니다. .</target>
        </trans-unit>
        <trans-unit id="7a21f615bd35450d045383608de1e8b616f708b6" translate="yes" xml:space="preserve">
          <source>Shadowing is the process by which a local variable shares the same name as a variable in its containing scope. For example:</source>
          <target state="translated">섀도 잉은 로컬 변수가 포함하는 범위의 변수와 동일한 이름을 공유하는 프로세스입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6bf3b29e45e3e5e600d18ebc1d069a9b49cb2211" translate="yes" xml:space="preserve">
          <source>Share Plugins</source>
          <target state="translated">플러그인 공유</target>
        </trans-unit>
        <trans-unit id="d411f634d35296374dbb079a9b10699e721c60b8" translate="yes" xml:space="preserve">
          <source>Shareable Configs</source>
          <target state="translated">공유 가능한 구성</target>
        </trans-unit>
        <trans-unit id="f7728f13ff64a72cf6ff58838bc2cf984afc2062" translate="yes" xml:space="preserve">
          <source>Shareable configs are designed to work with the &lt;code&gt;extends&lt;/code&gt; feature of &lt;code&gt;.eslintrc&lt;/code&gt; files. Instead of using a file path for the value of &lt;code&gt;extends&lt;/code&gt;, use your module name. For example:</source>
          <target state="translated">공유 가능한 구성은 &lt;code&gt;.eslintrc&lt;/code&gt; 파일 의 &lt;code&gt;extends&lt;/code&gt; 기능 과 작동하도록 설계되었습니다 . &lt;code&gt;extends&lt;/code&gt; 값으로 파일 경로를 사용하는 대신 모듈 이름을 사용하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ac98661439154e24e66154b8b56ea65970febcd8" translate="yes" xml:space="preserve">
          <source>Shareable configs are simply npm packages that export a configuration object. To start, &lt;a href=&quot;https://docs.npmjs.com/getting-started/creating-node-modules&quot;&gt;create a Node.js module&lt;/a&gt; like you normally would. Make sure the module name begins with &lt;code&gt;eslint-config-&lt;/code&gt;, such as &lt;code&gt;eslint-config-myconfig&lt;/code&gt;.</source>
          <target state="translated">공유 가능한 구성은 구성 개체를 내보내는 npm 패키지입니다. 시작하려면 평상시처럼 &lt;a href=&quot;https://docs.npmjs.com/getting-started/creating-node-modules&quot;&gt;Node.js 모듈을 만드십시오&lt;/a&gt; . 모듈 이름이 &lt;code&gt;eslint-config-myconfig&lt;/code&gt; 와 같은 &lt;code&gt;eslint-config-&lt;/code&gt; 로 시작하는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="5de27ab2273537b3d6d14a587e6661a643b307d7" translate="yes" xml:space="preserve">
          <source>Sharing Multiple Configs</source>
          <target state="translated">여러 구성 공유</target>
        </trans-unit>
        <trans-unit id="8fc88f1b91b2fde5e1092771afaef36f9a2e347a" translate="yes" xml:space="preserve">
          <source>Shebangs are now returned from comment APIs</source>
          <target state="translated">Shebangs는 이제 주석 API에서 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="7017708c1c06a3f1e90941c34316e9d4607c7d9c" translate="yes" xml:space="preserve">
          <source>Shebangs are represented by tokens of type &lt;code&gt;&quot;Shebang&quot;&lt;/code&gt;. They are treated as comments and can be accessed by the methods outlined above.</source>
          <target state="translated">Shebang은 &lt;code&gt;&quot;Shebang&quot;&lt;/code&gt; 유형의 토큰으로 표시됩니다 . 이들은 주석으로 취급되며 위에서 설명한 방법으로 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23210f846566656bab3b173307947416d7f3ca0b" translate="yes" xml:space="preserve">
          <source>Sign our &lt;a href=&quot;https://cla.js.foundation/eslint/eslint&quot;&gt;Contributor License Agreement&lt;/a&gt;.</source>
          <target state="translated">우리의 가입 &lt;a href=&quot;https://cla.js.foundation/eslint/eslint&quot;&gt;기여자 라이센스 계약&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2be01717d65543f816e780251a90121cfccc7576" translate="yes" xml:space="preserve">
          <source>Signing the CLA</source>
          <target state="translated">CLA 서명</target>
        </trans-unit>
        <trans-unit id="0ec28340f6b30cc1ce90c43020055c994f7d5efb" translate="yes" xml:space="preserve">
          <source>Similar to the valid cases, you can also specify &lt;code&gt;options&lt;/code&gt; to be passed to the rule:</source>
          <target state="translated">유효한 경우와 마찬가지로 규칙에 전달할 &lt;code&gt;options&lt;/code&gt; 을 지정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="83f59937d173df040577971290f0e1cacd671a9c" translate="yes" xml:space="preserve">
          <source>Simple Statements</source>
          <target state="translated">간단한 진술</target>
        </trans-unit>
        <trans-unit id="24da9670085c68ec6aa7a55a98200997a7091b66" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;context.options&lt;/code&gt; is just an array, you can use it to determine how many options have been passed as well as retrieving the actual options themselves. Keep in mind that the error level is not part of &lt;code&gt;context.options&lt;/code&gt;, as the error level cannot be known or modified from inside a rule.</source>
          <target state="translated">&lt;code&gt;context.options&lt;/code&gt; 는 배열 일 뿐이 므로 실제 옵션 자체를 검색 할뿐만 아니라 몇 개의 옵션이 전달되었는지 확인할 수 있습니다. 규칙 내에서 오류 수준을 알거나 수정할 수 없으므로 오류 수준 은 &lt;code&gt;context.options&lt;/code&gt; 의 일부가 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="3dec31ada8554ba1a6a6debc16cb59773af96567" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;index.js&lt;/code&gt; is just JavaScript, you can optionally read these settings from a file or generate them dynamically.</source>
          <target state="translated">&lt;code&gt;index.js&lt;/code&gt; 는 JavaScript 일 뿐이 므로 선택적으로 파일에서 이러한 설정을 읽거나 동적으로 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48bb4d613279d48459f21ef7090afc2c9bd1a5ba" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;require()&lt;/code&gt; does a synchronous load, it can cause performance problems when used in other locations.</source>
          <target state="translated">이후 &lt;code&gt;require()&lt;/code&gt; 동기로드를 수행 다른 장소에서 사용하는 경우, 그것은 성능 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4072153bf32cdf523ee16f38e671d010ceab044" translate="yes" xml:space="preserve">
          <source>Since ESLint v5, &lt;code&gt;ecmaFeatures: { experimentalObjectRestSpread: true }&lt;/code&gt; has been equivalent to &lt;code&gt;ecmaVersion: 2018&lt;/code&gt;, and has also emitted a deprecation warning. In ESLint v6, the &lt;code&gt;experimentalObjectRestSpread&lt;/code&gt; feature has been removed entirely and has no effect. If your config was relying on &lt;code&gt;experimentalObjectRestSpread&lt;/code&gt; to enable ES2018 parsing, you might start seeing parsing errors for recent syntax.</source>
          <target state="translated">ESLint v5부터 &lt;code&gt;ecmaFeatures: { experimentalObjectRestSpread: true }&lt;/code&gt; 는 &lt;code&gt;ecmaVersion: 2018&lt;/code&gt; 과 동일 하며 더 이상 사용되지 않음 경고를 표시했습니다. ESLint 버전 6에서 &lt;code&gt;experimentalObjectRestSpread&lt;/code&gt; 의 기능은 완전히 제거하고 아무런 효과가 없습니다. ES2018 구문 분석을 활성화 하기 위해 구성이 &lt;code&gt;experimentalObjectRestSpread&lt;/code&gt; 에 의존하는 경우 최근 구문에 대한 구문 분석 오류가 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d13ae6387ed366be6d8b805801c5cfb3cfb9ad21" translate="yes" xml:space="preserve">
          <source>Since all rules are run again after the initial round of fixes is applied, it's not necessary for a rule to check whether the code style of a fix will cause errors to be reported by another rule.</source>
          <target state="translated">초기 수정 라운드가 적용된 후 모든 규칙이 다시 실행되므로 수정 규칙의 코드 스타일로 인해 다른 규칙에서 오류가보고되는지 여부를 규칙에서 확인할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="18fb1e3007320b11f3d7fd9d833d2b32f18f24bd" translate="yes" xml:space="preserve">
          <source>Since deprecated rules will never be removed, you can continue to use them indefinitely if they are working for you. However, keep in mind that deprecated rules will effectively be unmaintained.</source>
          <target state="translated">더 이상 사용되지 않는 규칙은 제거되지 않으므로 규칙이 계속 작동하는 경우 계속 사용할 수 있습니다. 그러나 더 이상 사용되지 않는 규칙은 효과적으로 유지 관리되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0b45593d5f75200b1272e2e445af7ba7a6ca42cb" translate="yes" xml:space="preserve">
          <source>Since it's good to have a consistent code style, you should either always write padded blocks or never do it.</source>
          <target state="translated">일관된 코드 스타일을 갖는 것이 좋으므로 항상 패딩 된 블록을 쓰거나 절대로 쓰지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="20e1b60daaa62f4d5667736af96bfb991b249553" translate="yes" xml:space="preserve">
          <source>Single-Line Comments</source>
          <target state="translated">한 줄 주석</target>
        </trans-unit>
        <trans-unit id="56f06f07d3754fea01009119715bfd5517b24da3" translate="yes" xml:space="preserve">
          <source>Single-line comments should be used to document one line of code or a group of related lines of code. A single-line comment may be used in three ways:</source>
          <target state="translated">한 줄의 코드 또는 한 줄의 관련 코드 줄을 문서화하려면 한 줄 주석을 사용해야합니다. 한 줄 주석은 세 가지 방식으로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5725de7b903a8b05de6ad0470647699fe07e580" translate="yes" xml:space="preserve">
          <source>Small - Runs ESLint on KnockoutJS</source>
          <target state="translated">소규모-KnockoutJS에서 ESLint 실행</target>
        </trans-unit>
        <trans-unit id="8a314d2e7d6188c8847f81a281bc5f5ae16c1c06" translate="yes" xml:space="preserve">
          <source>Smart Tabs</source>
          <target state="translated">스마트 탭</target>
        </trans-unit>
        <trans-unit id="f4e452300a2b0f07b41745625016cd897fb85bfe" translate="yes" xml:space="preserve">
          <source>So running &lt;code&gt;eslint&lt;/code&gt; with this custom formatter:</source>
          <target state="translated">따라서이 사용자 정의 포맷터로 &lt;code&gt;eslint&lt;/code&gt; 를 실행 하십시오 .</target>
        </trans-unit>
        <trans-unit id="65f774dd6ab39438c5f5df28e0b861b09e448b2d" translate="yes" xml:space="preserve">
          <source>So the second argument &lt;code&gt;ast&lt;/code&gt; also should be parsed from stripped text.</source>
          <target state="translated">따라서 두 번째 인수 &lt;code&gt;ast&lt;/code&gt; 도 제거 된 텍스트에서 구문 분석해야합니다.</target>
        </trans-unit>
        <trans-unit id="31a71f85cf4f793cf2a2e4f0097c3f2e95ba388a" translate="yes" xml:space="preserve">
          <source>Software Module size and file size</source>
          <target state="translated">소프트웨어 모듈 크기 및 파일 크기</target>
        </trans-unit>
        <trans-unit id="be134f7c50807cfb772cbc0bcb5081b5a12c45d8" translate="yes" xml:space="preserve">
          <source>Some code conventions require that all &lt;code&gt;switch&lt;/code&gt; statements have a &lt;code&gt;default&lt;/code&gt; case, even if the default case is empty, such as:</source>
          <target state="translated">일부 코드 규칙은 모든 것을 요구하고 &lt;code&gt;switch&lt;/code&gt; 문은이 &lt;code&gt;default&lt;/code&gt; 기본 경우와 같은, 비어있는 경우에도 경우 :</target>
        </trans-unit>
        <trans-unit id="c8b6c94f005c780b423c192df3948fbf6b0bc032" translate="yes" xml:space="preserve">
          <source>Some code styles prohibit &lt;code&gt;void&lt;/code&gt; operator, marking it as non-obvious and hard to read.</source>
          <target state="translated">일부 코드 스타일은 &lt;code&gt;void&lt;/code&gt; 연산자를 금지 하여 불명확하고 읽기 어려운 것으로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="5c5510f077de709ac2acb2de150530c1a834f95a" translate="yes" xml:space="preserve">
          <source>Some consider this to be a bad practice as it was an undocumented feature of JavaScript that was only formalized later.</source>
          <target state="translated">일부는 나중에 공식화되지 않은 JavaScript의 문서화되지 않은 기능이기 때문에 이것이 나쁜 습관이라고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="5c13b92416e3720dc9efdcd598e2b13bb218f8f0" translate="yes" xml:space="preserve">
          <source>Some developers declare multiple var statements on the same line:</source>
          <target state="translated">일부 개발자는 같은 줄에 여러 var 문을 선언합니다.</target>
        </trans-unit>
        <trans-unit id="88fde2b94b3e6e7f06f28f5ca48809414c632781" translate="yes" xml:space="preserve">
          <source>Some developers find that placing operators at the beginning of the line makes the code more readable.</source>
          <target state="translated">일부 개발자는 줄의 시작 부분에 연산자를 배치하면 코드를 더 읽기 쉽게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="da83d59be8d3c1fa61746c9667b3e144b3b46f21" translate="yes" xml:space="preserve">
          <source>Some developers prefer to have multiple blank lines removed, while others feel that it helps improve readability. Whitespace is useful for separating logical sections of code, but excess whitespace takes up more of the screen.</source>
          <target state="translated">일부 개발자는 빈 줄을 여러 개 제거하는 것을 선호하지만 다른 개발자는 가독성을 높이는 데 도움이된다고 생각합니다. 공백은 코드의 논리적 섹션을 분리하는 데 유용하지만 초과 공백은 더 많은 화면을 차지합니다.</target>
        </trans-unit>
        <trans-unit id="319b3df86b7ba843599bf2b2dd9f3af029a3c402" translate="yes" xml:space="preserve">
          <source>Some exposed APIs are now ES2015 classes</source>
          <target state="translated">노출 된 일부 API는 이제 ES2015 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="70eec175aefc8c0ac35582826149396333b51a6a" translate="yes" xml:space="preserve">
          <source>Some global variables have been deprecated or removed for code running in Node.js, browsers, and Jest. (For example, browsers used to expose an &lt;code&gt;SVGAltGlyphElement&lt;/code&gt; global variable to JavaScript code, but this global has been removed from web standards and is no longer present in browsers.) As a result, we have removed these globals from the corresponding &lt;code&gt;eslint&lt;/code&gt; environments, so use of these globals will trigger an error when using rules such as &lt;a href=&quot;../rules/no-undef&quot;&gt;&lt;code&gt;no-undef&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Node.js, 브라우저 및 Jest에서 실행되는 코드에 대해 일부 전역 변수가 더 이상 사용되지 않거나 제거되었습니다. 예를 들어, 브라우저는 &lt;code&gt;SVGAltGlyphElement&lt;/code&gt; 전역 변수를 JavaScript 코드 에 노출하는 데 사용 되었지만이 전역은 웹 표준에서 제거되어 더 이상 브라우저에 존재하지 않습니다. 결과적으로 해당 &lt;code&gt;eslint&lt;/code&gt; 환경 에서 이러한 전역을 제거했습니다. 이 전역을 사용하면 &lt;a href=&quot;../rules/no-undef&quot;&gt; &lt;code&gt;no-undef&lt;/code&gt; &lt;/a&gt; 와 같은 규칙을 사용할 때 오류가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="f062f278fdeadb9e299ef656855a628748c5bb85" translate="yes" xml:space="preserve">
          <source>Some imports might not make sense in a particular environment. For example, Node.js' &lt;code&gt;fs&lt;/code&gt; module would not make sense in an environment that didn't have a file system.</source>
          <target state="translated">특정 환경에서는 일부 가져 오기가 의미가 없을 수 있습니다. 예를 들어, Node.js의 &lt;code&gt;fs&lt;/code&gt; 모듈은 파일 시스템이없는 환경에서는 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="8a1845bade3c1e32522c230c7fd34c3040711d50" translate="yes" xml:space="preserve">
          <source>Some issues have had monetary rewards attached to them. Those are labeled &lt;code&gt;bounty&lt;/code&gt;. Bounties are assigned via &lt;a href=&quot;https://www.bountysource.com/teams/eslint/issues&quot;&gt;BountySource&lt;/a&gt;.</source>
          <target state="translated">일부 문제에는 금전적 보상이 첨부되었습니다. 이것들은 &lt;code&gt;bounty&lt;/code&gt; 이라고 표시되어 있습니다. &lt;a href=&quot;https://www.bountysource.com/teams/eslint/issues&quot;&gt;바운티&lt;/a&gt; 는 BountySource 를 통해 할당됩니다 .</target>
        </trans-unit>
        <trans-unit id="cc97f15ec33a8fb0d8f181362b5bbc40bdbb948d" translate="yes" xml:space="preserve">
          <source>Some modules provide similar or identical functionality, think &lt;code&gt;lodash&lt;/code&gt; and &lt;code&gt;underscore&lt;/code&gt;. Your project may have standardized on a module. You want to make sure that the other alternatives are not being used as this would unnecessarily bloat the project and provide a higher maintenance cost of two dependencies when one would suffice.</source>
          <target state="translated">일부 모듈은 유사하거나 동일한 기능을 제공하며 &lt;code&gt;lodash&lt;/code&gt; 와 &lt;code&gt;underscore&lt;/code&gt; 생각 하십시오 . 프로젝트가 모듈에서 표준화되었을 수 있습니다. 프로젝트가 불필요하게 부풀려 져서 하나의 충분할 때 두 가지 종속성의 유지 보수 비용이 높아 지므로 다른 대안을 사용하지 않도록하십시오.</target>
        </trans-unit>
        <trans-unit id="264939a2d43fd66c197012a9cf9648b42c36337b" translate="yes" xml:space="preserve">
          <source>Some modules return a constructor which can potentially lead to code such as:</source>
          <target state="translated">일부 모듈은 다음과 같은 코드로 이어질 수있는 생성자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="29ba1427e8c92e96a16255e3f6eb4ecbfabc34f6" translate="yes" xml:space="preserve">
          <source>Some people consider large files a code smell. Large files tend to do a lot of things and can make it hard following what's going. While there is not an objective maximum number of lines considered acceptable in a file, most people would agree it should not be in the thousands. Recommendations usually range from 100 to 500 lines.</source>
          <target state="translated">어떤 사람들은 큰 파일을 코드 냄새라고 생각합니다. 큰 파일은 많은 일을하는 경향이 있으며 진행 상황에 따라 어려워 질 수 있습니다. 파일에 허용되는 것으로 간주되는 객관적인 최대 줄 수는 없지만 대부분의 사람들은 수천 줄을 넘지 않아야한다는 데 동의합니다. 권장 사항은 일반적으로 100 ~ 500 줄입니다.</target>
        </trans-unit>
        <trans-unit id="a357eb75979b31ab9472de29b249e979f6b6b141" translate="yes" xml:space="preserve">
          <source>Some people consider large functions a code smell. Large functions tend to do a lot of things and can make it hard following what's going on. Many coding style guides dictate a limit of the number of lines that a function can comprise of. This rule can help enforce that style.</source>
          <target state="translated">어떤 사람들은 큰 기능을 코드 냄새라고 생각합니다. 큰 기능은 많은 일을하는 경향이 있으며 진행 상황에 따라 어려워 질 수 있습니다. 많은 코딩 스타일 가이드는 함수가 구성 할 수있는 줄 수의 제한을 나타냅니다. 이 규칙은 해당 스타일을 적용하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b516222d790d0bfe6d8641c249e0071402e077c0" translate="yes" xml:space="preserve">
          <source>Some rules and APIs allow the use of selectors to query an AST. This page is intended to:</source>
          <target state="translated">일부 규칙 및 API에서는 선택기를 사용하여 AST를 쿼리 할 수 ​​있습니다. 이 페이지는 다음을 목적으로합니다 :</target>
        </trans-unit>
        <trans-unit id="d46d7f40436527e02e15f42c4b8e72f68eaadfc8" translate="yes" xml:space="preserve">
          <source>Some rules require options in order to function correctly. These options appear in configuration (&lt;code&gt;.eslintrc&lt;/code&gt;, command line, or in comments). For example:</source>
          <target state="translated">일부 규칙은 제대로 작동하려면 옵션이 필요합니다. 이러한 옵션은 구성 ( &lt;code&gt;.eslintrc&lt;/code&gt; , 명령 줄 또는 주석)에 나타납니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="00275b3b345f6b9172064ad3c4803175ae258c34" translate="yes" xml:space="preserve">
          <source>Some style guides disallow comments on the same line as code. Code can become difficult to read if comments immediately follow the code on the same line. On the other hand, it is sometimes faster and more obvious to put comments immediately following code.</source>
          <target state="translated">일부 스타일 가이드는 코드와 같은 줄에 주석을 허용하지 않습니다. 주석이 즉시 같은 행의 코드를 따르는 경우 코드를 읽기가 어려워 질 수 있습니다. 반면에, 코드 바로 뒤에 주석을 추가하는 것이 때로는 더 빠르고 분명합니다.</target>
        </trans-unit>
        <trans-unit id="1849aab38ed123bdc6d7b029034a46313136fc00" translate="yes" xml:space="preserve">
          <source>Some style guides don't allow the use of tab characters at all, including within comments.</source>
          <target state="translated">일부 스타일 가이드에서는 주석을 포함하여 탭 문자를 전혀 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2244458667f3ce520967956eda4ce510fbeed0c1" translate="yes" xml:space="preserve">
          <source>Some style guides may require a consistent spacing for function names.</source>
          <target state="translated">일부 스타일 가이드에는 함수 이름에 일정한 간격이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="030befb9cb1b6a4b5dacb92a3f92d4b8ba5e2c62" translate="yes" xml:space="preserve">
          <source>Some style guides require JSDoc comments for all functions as a way of explaining function behavior.</source>
          <target state="translated">일부 스타일 가이드에는 함수 동작을 설명하는 방법으로 모든 함수에 대해 JSDoc 주석이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="dc237e4772e0207c27c1e378f2525052a1ff94c6" translate="yes" xml:space="preserve">
          <source>Some style guides require block statements to start and end with blank lines. The goal is to improve readability by visually separating the block content and the surrounding code.</source>
          <target state="translated">일부 스타일 안내서에는 빈 줄로 시작하고 끝나는 블록 문이 필요합니다. 블록 내용과 주변 코드를 시각적으로 분리하여 가독성을 향상시키는 것이 목표입니다.</target>
        </trans-unit>
        <trans-unit id="201550e6abc7ddd420de4b881ba83ce28f29f0b9" translate="yes" xml:space="preserve">
          <source>Some style guides require or disallow a whitespace immediately after the initial &lt;code&gt;//&lt;/code&gt; of a line comment. Whitespace after the &lt;code&gt;//&lt;/code&gt; makes it easier to read text in comments. On the other hand, commenting out code is easier without having to put a whitespace right after the &lt;code&gt;//&lt;/code&gt;.</source>
          <target state="translated">일부 스타일 가이드 는 줄 주석 의 초기 &lt;code&gt;//&lt;/code&gt; 직후에 공백을 요구하거나 허용하지 않습니다 . &lt;code&gt;//&lt;/code&gt; 다음의 공백 은 주석에서 텍스트를 쉽게 읽을 수있게합니다. 반면에 &lt;code&gt;//&lt;/code&gt; 바로 뒤에 공백을 넣지 않아도 코드 주석 처리가 더 쉽습니다 .</target>
        </trans-unit>
        <trans-unit id="a1c5fdd2ea4191bb42ab7f9fca487d91da02843c" translate="yes" xml:space="preserve">
          <source>Some style guides require or disallow a whitespace immediately after the initial &lt;code&gt;//&lt;/code&gt; or &lt;code&gt;/*&lt;/code&gt; of a comment. Whitespace after the &lt;code&gt;//&lt;/code&gt; or &lt;code&gt;/*&lt;/code&gt; makes it easier to read text in comments. On the other hand, commenting out code is easier without having to put a whitespace right after the &lt;code&gt;//&lt;/code&gt; or &lt;code&gt;/*&lt;/code&gt;.</source>
          <target state="translated">일부 스타일 가이드 는 주석의 &lt;code&gt;//&lt;/code&gt; 또는 &lt;code&gt;/*&lt;/code&gt; 직후에 공백을 요구하거나 허용하지 않습니다 . &lt;code&gt;//&lt;/code&gt; 또는 &lt;code&gt;/*&lt;/code&gt; 뒤의 공백 은 주석에서 텍스트를보다 쉽게 ​​읽을 수있게합니다. 반면에 &lt;code&gt;//&lt;/code&gt; 또는 &lt;code&gt;/*&lt;/code&gt; 바로 뒤에 공백을 넣지 않아도 코드 주석 처리가 더 쉽습니다 .</target>
        </trans-unit>
        <trans-unit id="9568a858ccab377c3f347cbea8a8037f371d4712" translate="yes" xml:space="preserve">
          <source>Some style guides require or disallow spaces before or after unary operators. This is mainly a stylistic issue, however, some JavaScript expressions can be written without spacing which makes it harder to read and maintain.</source>
          <target state="translated">일부 스타일 가이드는 단항 연산자 전후에 공백이 필요하거나 허용되지 않습니다. 이것은 주로 문체 문제이지만 일부 JavaScript 표현식은 간격없이 작성할 수 있으므로 읽고 유지 관리하기가 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="1cd1de3034a3fc730da0bea8dd9b8d360a4330f4" translate="yes" xml:space="preserve">
          <source>Some style guides require or disallow spaces inside of parentheses:</source>
          <target state="translated">일부 스타일 가이드는 괄호 안에 공백이 필요하거나 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c3070c75d033320e5f7ebe414b6237a3ba652bf4" translate="yes" xml:space="preserve">
          <source>Some style guides will require or disallow spaces following the certain keywords.</source>
          <target state="translated">일부 스타일 가이드는 특정 키워드 다음에 공백이 필요하거나 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c4be317e60f6aa965f4ab059cd2ad659412f195d" translate="yes" xml:space="preserve">
          <source>Some tests require that a certain parser configuration must be used. This can be specified in test specifications via the &lt;code&gt;parserOptions&lt;/code&gt; setting.</source>
          <target state="translated">일부 테스트에서는 특정 파서 구성을 사용해야합니다. 이것은 &lt;code&gt;parserOptions&lt;/code&gt; 설정을 통해 테스트 사양에서 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="838af6a85f479a1fedfe1a6da00a3f1b6a2a4200" translate="yes" xml:space="preserve">
          <source>Sometimes (especially in big projects) the name of the error variable is not consistent across the project, so you need a more flexible configuration to ensure that the rule reports all unhandled errors.</source>
          <target state="translated">때때로 (특히 큰 프로젝트에서) 오류 변수의 이름이 프로젝트 전체에서 일치하지 않으므로 규칙이 처리되지 않은 모든 오류를보고하도록보다 유연한 구성이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="50c696bd306a1b3a43860828cc49620093926e56" translate="yes" xml:space="preserve">
          <source>Sometimes during the course of code maintenance, the &lt;code&gt;this&lt;/code&gt; value is removed from the function body. In that case, you can end up with a call to &lt;code&gt;bind()&lt;/code&gt; that doesn't accomplish anything:</source>
          <target state="translated">코드 유지 보수 과정 &lt;code&gt;this&lt;/code&gt; 값이 함수 본문에서 제거되는 경우가 있습니다. 이 경우 아무것도 수행하지 않는 &lt;code&gt;bind()&lt;/code&gt; 호출로 끝날 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e1239a4ef3312baebd03a9fadd3dc1da7a196cfc" translate="yes" xml:space="preserve">
          <source>Sometimes in the course of editing files, you can end up with extra whitespace at the end of lines. These whitespace differences can be picked up by source control systems and flagged as diffs, causing frustration for developers. While this extra whitespace causes no functional issues, many code conventions require that trailing spaces be removed before check-in.</source>
          <target state="translated">때로는 파일을 편집하는 동안 줄 끝에 여분의 공백이 생길 수 있습니다. 이러한 공백 차이는 소스 제어 시스템에 의해 포착되고 diff로 표시되어 개발자에게 좌절을 줄 수 있습니다. 이 추가 공백은 기능상의 문제를 일으키지 않지만 많은 코드 규칙에서는 체크인 전에 후행 공백을 제거해야합니다.</target>
        </trans-unit>
        <trans-unit id="7b37110e5b01350732eac4676af2611966b9ccef" translate="yes" xml:space="preserve">
          <source>Source Code</source>
          <target state="translated">소스 코드</target>
        </trans-unit>
        <trans-unit id="f13b901ad76229dac734487a39808cdde93abfe1" translate="yes" xml:space="preserve">
          <source>Source Control</source>
          <target state="translated">소스 컨트롤</target>
        </trans-unit>
        <trans-unit id="d7f23e409b1f9d227333564c23108a422010e901" translate="yes" xml:space="preserve">
          <source>SourceCode</source>
          <target state="translated">SourceCode</target>
        </trans-unit>
        <trans-unit id="bce4c495898f1faddcaa7c35b37ab4481ede3b00" translate="yes" xml:space="preserve">
          <source>SourceCode constructor (Node API) changes</source>
          <target state="translated">SourceCode 생성자 (노드 API) 변경</target>
        </trans-unit>
        <trans-unit id="4295a0eca57863562626d681cbe158963892a6fd" translate="yes" xml:space="preserve">
          <source>SourceCode#splitLines()</source>
          <target state="translated">SourceCode#splitLines()</target>
        </trans-unit>
        <trans-unit id="db40a182aaf7dc66373c8652a068c39e88c92f7e" translate="yes" xml:space="preserve">
          <source>Space issues can also cause code to look inconsistent and harder to read.</source>
          <target state="translated">공간 문제로 인해 코드가 일관되지 않고 읽기 어려워 질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b903a63fa074533e05ee538bb400f7ae7d25ae0" translate="yes" xml:space="preserve">
          <source>Spacing around colons improves readability of &lt;code&gt;case&lt;/code&gt;/&lt;code&gt;default&lt;/code&gt; clauses.</source>
          <target state="translated">콜론 주위의 간격은 &lt;code&gt;case&lt;/code&gt; / &lt;code&gt;default&lt;/code&gt; 절의 가독성을 향상시킵니다 .</target>
        </trans-unit>
        <trans-unit id="bee60614d09a5dc287b728aa03f9ca804bb2765e" translate="yes" xml:space="preserve">
          <source>Spacing around commas improves readability of a list of items. Although most of the style guidelines for languages prescribe adding a space after a comma and not before it, it is subjective to the preferences of a project.</source>
          <target state="translated">쉼표 주위의 간격은 항목 목록의 가독성을 향상시킵니다. 언어에 대한 대부분의 스타일 지침은 쉼표 뒤에 공백이 아닌 쉼표 뒤에 공백을 추가하도록 규정하지만, 프로젝트 환경 설정에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="85517ae7d9ab81a8dc4d785d38d52af351849a64" translate="yes" xml:space="preserve">
          <source>Sparse arrays contain empty slots, most frequently due to multiple commas being used in an array literal, such as:</source>
          <target state="translated">스파 스 배열에는 빈 슬롯이 포함되어 있습니다. 가장 자주 다음과 같이 배열 리터럴에 여러 개의 쉼표가 사용되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="0b7e749be12e1d4e6f29f80172dc19cac2d01996" translate="yes" xml:space="preserve">
          <source>Specifying Environments</source>
          <target state="translated">환경 지정</target>
        </trans-unit>
        <trans-unit id="056af97903e3dc6e6f43b88d96ae94278918b7f2" translate="yes" xml:space="preserve">
          <source>Specifying File extensions to Lint</source>
          <target state="translated">Lint에 파일 확장자 지정</target>
        </trans-unit>
        <trans-unit id="42e1afab26529373a5755f37ed73c9992e7a1f27" translate="yes" xml:space="preserve">
          <source>Specifying Globals</source>
          <target state="translated">글로벌 지정</target>
        </trans-unit>
        <trans-unit id="615655edaa8435cea59ad96bf63fd800fe901df4" translate="yes" xml:space="preserve">
          <source>Specifying Parser</source>
          <target state="translated">파서 지정</target>
        </trans-unit>
        <trans-unit id="3fdf1ff8c15b6bfb3e42d6729c40289a364a0934" translate="yes" xml:space="preserve">
          <source>Specifying Parser Options</source>
          <target state="translated">파서 옵션 지정</target>
        </trans-unit>
        <trans-unit id="a5dba7920ee9d85457d6a302a8028c1f41b8cc64" translate="yes" xml:space="preserve">
          <source>Specifying Processor</source>
          <target state="translated">프로세서 지정</target>
        </trans-unit>
        <trans-unit id="ec5cdef761600831584f51b13c5e7e1af51231d0" translate="yes" xml:space="preserve">
          <source>Specifying Processor in Config Files</source>
          <target state="translated">구성 파일에서 프로세서 지정</target>
        </trans-unit>
        <trans-unit id="dd101a9b3761464c88a971471d60c8157de97419" translate="yes" xml:space="preserve">
          <source>Specifying Target Files to Lint</source>
          <target state="translated">Specifying Target Files to Lint</target>
        </trans-unit>
        <trans-unit id="fd3a805a25d509c02dbba7487be2139a847549f5" translate="yes" xml:space="preserve">
          <source>Specifying rules and plugins</source>
          <target state="translated">규칙 및 플러그인 지정</target>
        </trans-unit>
        <trans-unit id="96c2be7c78e35ecedf2f6d32e197f0983c7d3765" translate="yes" xml:space="preserve">
          <source>Start Developing</source>
          <target state="translated">개발 시작</target>
        </trans-unit>
        <trans-unit id="d5ebef5b5d844222a804e3497fcaed1e87e4a705" translate="yes" xml:space="preserve">
          <source>Start: &lt;a href=&quot;https://www.npmjs.com/package/@start/plugin-lib-eslint&quot;&gt;@start/plugin-lib-eslint&lt;/a&gt;</source>
          <target state="translated">시작 : &lt;a href=&quot;https://www.npmjs.com/package/@start/plugin-lib-eslint&quot;&gt;@ start / plugin-lib-eslint&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="67086f02eed6ec69807b5ddb9e07150ee0b0c38d" translate="yes" xml:space="preserve">
          <source>Starting Work</source>
          <target state="translated">작업 시작</target>
        </trans-unit>
        <trans-unit id="91b0ca4a9a5191f5469dcbd23531b6ea8254d67c" translate="yes" xml:space="preserve">
          <source>Starting in 3.1.0, rules have been able to specify the &lt;em&gt;end&lt;/em&gt; location of a reported problem, in addition to the start location, by explicitly specifying an end location in the &lt;code&gt;report&lt;/code&gt; call. This is useful for tools like editor integrations, which can use the range to precisely display where a reported problem occurs. Starting in 4.0, if a &lt;em&gt;node&lt;/em&gt; is reported rather than a location, the end location of the range will automatically be inferred from the end location of the node. As a result, many more reported problems will have end locations.</source>
          <target state="translated">3.1.0부터 규칙은 &lt;code&gt;report&lt;/code&gt; 호출 에서 종료 위치를 명시 적으로 지정하여 시작 위치 외에보고 된 문제 의 &lt;em&gt;종료&lt;/em&gt; 위치 를 지정할 수있었습니다 . 이 기능은 편집기 통합과 같은 도구에 유용하며, 범위를 사용하여보고 된 문제가 발생한 위치를 정확하게 표시 할 수 있습니다. 4.0부터는 위치가 아닌 &lt;em&gt;노드&lt;/em&gt; 가보고되는 경우 범위의 끝 위치가 노드의 끝 위치에서 자동으로 추론됩니다. 결과적으로 더 많은보고 된 문제점이 종료 위치에있게됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5f2ecf2f7eb4335fbd187d0845b33268b44df84a" translate="yes" xml:space="preserve">
          <source>Starting in 4.0, &lt;code&gt;LineComment&lt;/code&gt; and &lt;code&gt;BlockComments&lt;/code&gt; events will not be emitted during AST traversal. There are two reasons for this:</source>
          <target state="translated">4.0부터는 AST 통과 동안 &lt;code&gt;LineComment&lt;/code&gt; 및 &lt;code&gt;BlockComments&lt;/code&gt; 이벤트가 생성되지 않습니다. 이에 대한 두 가지 이유가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a9fefe6ba1eb3abeeec5967b3b58b648a035245" translate="yes" xml:space="preserve">
          <source>Starting in 4.0, the &lt;code&gt;RuleTester&lt;/code&gt; utility will validate properties of test case objects, and an error will be thrown if an unknown property is encountered. This change was added because we found that it was relatively common for developers to make typos in rule tests, often invalidating the assertions that the test cases were trying to make.</source>
          <target state="translated">4.0부터 &lt;code&gt;RuleTester&lt;/code&gt; 유틸리티는 테스트 케이스 오브젝트의 특성을 유효성 검증하며 알 수없는 특성이 발생하면 오류가 발생합니다. 이 변경 사항은 개발자가 규칙 테스트에서 오타를 만드는 것이 일반적이며 테스트 사례에서 시도한 어설 션을 무효화하는 것이 일반적이기 때문에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="5653cebc057d4791ce07031ad9286e729de6d691" translate="yes" xml:space="preserve">
          <source>Statements</source>
          <target state="translated">Statements</target>
        </trans-unit>
        <trans-unit id="6a5813201a4580fe5f1fbb25f1a522d4d505bf2d" translate="yes" xml:space="preserve">
          <source>Static Methods</source>
          <target state="translated">정적 방법</target>
        </trans-unit>
        <trans-unit id="633c64990d0fd3fb0088750ad9faa31590a9c3f0" translate="yes" xml:space="preserve">
          <source>Step 1: Create a new branch</source>
          <target state="translated">1 단계 : 새 브랜치 생성</target>
        </trans-unit>
        <trans-unit id="c743a1387584019a5b9e49c171021066a9274bbd" translate="yes" xml:space="preserve">
          <source>Step 1: Install Node.js</source>
          <target state="translated">1 단계 : Node.js 설치</target>
        </trans-unit>
        <trans-unit id="ebb615d0e8fbd3bc64c658bdeea517e1be8a7501" translate="yes" xml:space="preserve">
          <source>Step 2: Fork and checkout your own ESLint repository</source>
          <target state="translated">2 단계 : 자체 ESLint 리포지토리 포크 및 체크 아웃</target>
        </trans-unit>
        <trans-unit id="4b277bac8f09c41a896b5778dc93caf8cea1b8d1" translate="yes" xml:space="preserve">
          <source>Step 2: Make your changes</source>
          <target state="translated">2 단계 : 변경</target>
        </trans-unit>
        <trans-unit id="162e5376e301468cf0fb8feee5902817e041ced1" translate="yes" xml:space="preserve">
          <source>Step 3: Add the upstream source</source>
          <target state="translated">3 단계 : 업스트림 소스 추가</target>
        </trans-unit>
        <trans-unit id="c69e88aa3310028acfe11e07da987e642ed7401d" translate="yes" xml:space="preserve">
          <source>Step 3: Rebase onto upstream</source>
          <target state="translated">3 단계 : 업스트림으로 리베이스</target>
        </trans-unit>
        <trans-unit id="11d3053005d884cc0baea0d55f626ee5d58a2a6e" translate="yes" xml:space="preserve">
          <source>Step 4: Install the Yeoman Generator</source>
          <target state="translated">4 단계 : Yeoman Generator 설치</target>
        </trans-unit>
        <trans-unit id="d2be3c72779cd587be34e70421fd2467e7894ea1" translate="yes" xml:space="preserve">
          <source>Step 4: Run the tests</source>
          <target state="translated">4 단계 : 테스트 실행</target>
        </trans-unit>
        <trans-unit id="e9fd76aa2302af763cd9bb123a722b970152c5fc" translate="yes" xml:space="preserve">
          <source>Step 5: Double check your submission</source>
          <target state="translated">5 단계 : 제출물 확인</target>
        </trans-unit>
        <trans-unit id="1c864ce6457173a3a941ae978f55091a735f72c1" translate="yes" xml:space="preserve">
          <source>Step 5: Run the tests</source>
          <target state="translated">5 단계 : 테스트 실행</target>
        </trans-unit>
        <trans-unit id="b96518c7b052df6c7c228843ed78292c66a91d9a" translate="yes" xml:space="preserve">
          <source>Step 6: Push your changes</source>
          <target state="translated">6 단계 : 변경 사항 푸시</target>
        </trans-unit>
        <trans-unit id="baa82a802e0780c46eb5d8b0c851c905af055f75" translate="yes" xml:space="preserve">
          <source>Step 7: Send the pull request</source>
          <target state="translated">7 단계 : 풀 요청 보내기</target>
        </trans-unit>
        <trans-unit id="f1823ff4064066ec41c29ab620ef5de461f12793" translate="yes" xml:space="preserve">
          <source>Store the info about processed files in order to only operate on the changed ones. The cache is stored in &lt;code&gt;.eslintcache&lt;/code&gt; by default. Enabling this option can dramatically improve ESLint's running time by ensuring that only changed files are linted.</source>
          <target state="translated">변경된 파일에서만 작동하도록 처리 된 파일에 대한 정보를 저장하십시오. 캐시는 기본적으로 &lt;code&gt;.eslintcache&lt;/code&gt; 에 저장됩니다 . 이 옵션을 활성화하면 변경된 파일 만 보풀이되도록하여 ESLint의 실행 시간을 대폭 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="040fdcc5343129a76b072a4ce16081703504850c" translate="yes" xml:space="preserve">
          <source>Storing Node.js application config data - Ben Hall's blog</source>
          <target state="translated">Node.js 애플리케이션 구성 데이터 저장-Ben Hall의 블로그</target>
        </trans-unit>
        <trans-unit id="7c183131363f4251f89993f5090afc10d8f0caad" translate="yes" xml:space="preserve">
          <source>Strict Mode</source>
          <target state="translated">엄격한 모드</target>
        </trans-unit>
        <trans-unit id="10944d62374d1d35c0aa7618089752217945a8f3" translate="yes" xml:space="preserve">
          <source>Strict mode is enabled by using the following pragma in your code:</source>
          <target state="translated">코드에서 다음 pragma를 사용하여 엄격한 모드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c2e19e5bce9b19bbc0b58f76bc3e3dfe6a9b44a" translate="yes" xml:space="preserve">
          <source>Strict mode should be used in all modules, specified below the file overview comment and above everything else:</source>
          <target state="translated">엄격한 모드는 모든 모듈에서 사용해야하며 파일 개요 주석 아래 및 다른 모든 것 위에 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="3c519ccf5be0c1f36a3bbdf75106a4c822cfcb9f" translate="yes" xml:space="preserve">
          <source>String option:</source>
          <target state="translated">문자열 옵션 :</target>
        </trans-unit>
        <trans-unit id="7c0095620910afa8aafa46572a5f1abcd3e6d132" translate="yes" xml:space="preserve">
          <source>String options are:</source>
          <target state="translated">문자열 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="219423ce2478de8f7bc615787c69eeec3ac8cfbb" translate="yes" xml:space="preserve">
          <source>Strings should always use double quotes (never single quotes) and should always appear on a single line. Never use a slash to create a new line in a string.</source>
          <target state="translated">문자열은 항상 큰 따옴표를 사용하고 작은 따옴표는 사용하지 않아야하며 항상 한 줄에 표시해야합니다. 문자열에 새 줄을 만들 때 슬래시를 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="2bd1e348298a2cd13100d6cde33eeacf35aa2449" translate="yes" xml:space="preserve">
          <source>Style guides may require a space after the &lt;code&gt;function&lt;/code&gt; keyword for anonymous functions, while others specify no whitespace. Similarly, the space after a function name may or may not be required.</source>
          <target state="translated">스타일 가이드는 익명 함수의 경우 &lt;code&gt;function&lt;/code&gt; 키워드 다음에 공백이 필요할 수 있지만 다른 함수는 공백을 지정하지 않습니다. 마찬가지로 함수 이름 뒤에 공백이 필요하거나 필요하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2602aec88a266da02fb6e6a39ad0ff098e617d0" translate="yes" xml:space="preserve">
          <source>Stylistic Issues</source>
          <target state="translated">문체 문제</target>
        </trans-unit>
        <trans-unit id="ff5943f72b414aaa4a17049e5bbb2634c96a77ee" translate="yes" xml:space="preserve">
          <source>Sublime Text 3:</source>
          <target state="translated">숭고한 텍스트 3 :</target>
        </trans-unit>
        <trans-unit id="030c1749f522d7238c0443341747221266a4ca54" translate="yes" xml:space="preserve">
          <source>SublimeLinter-eslint</source>
          <target state="translated">SublimeLinter-eslint</target>
        </trans-unit>
        <trans-unit id="6ecdca9060c4831fb381d364edb6e63d253d9af3" translate="yes" xml:space="preserve">
          <source>Submit the pull request</source>
          <target state="translated">풀 요청 제출</target>
        </trans-unit>
        <trans-unit id="583b503cc37a3a03e3fd4c13e083b2095261ea25" translate="yes" xml:space="preserve">
          <source>Submitting a &lt;a href=&quot;pull-requests&quot;&gt;Pull Request&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;pull-requests&quot;&gt;풀 요청&lt;/a&gt; 제출</target>
        </trans-unit>
        <trans-unit id="0198b462f882ff4a84867d9897d73f6245ad627e" translate="yes" xml:space="preserve">
          <source>Such as:</source>
          <target state="translated">같은 :</target>
        </trans-unit>
        <trans-unit id="3374f6918890228b021e90be8c3993cedad5f95b" translate="yes" xml:space="preserve">
          <source>Suggest using &lt;code&gt;const&lt;/code&gt; (prefer-const)</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 사용 제안 ( const -const)</target>
        </trans-unit>
        <trans-unit id="d7fda7e48105f11ea112f4b9190ecb9e41f8c30a" translate="yes" xml:space="preserve">
          <source>Suggest using Reflect methods where applicable (prefer-reflect)</source>
          <target state="translated">해당되는 경우 Reflect 방법을 사용하도록 제안하십시오 (Ref-reflect)</target>
        </trans-unit>
        <trans-unit id="73a842e9ea440efda64fd80635a0d7967bf45ec9" translate="yes" xml:space="preserve">
          <source>Suggest using named capture group in regular expression (prefer-named-capture-group)</source>
          <target state="translated">정규식에서 명명 된 캡처 그룹 사용 제안 (바람직한 캡처 그룹)</target>
        </trans-unit>
        <trans-unit id="28675d097f0b67789bcf9a4622cdbd9ec701d7ad" translate="yes" xml:space="preserve">
          <source>Suggest using spread syntax instead of &lt;code&gt;.apply()&lt;/code&gt;. (prefer-spread)</source>
          <target state="translated">&lt;code&gt;.apply()&lt;/code&gt; 대신 스프레드 구문을 사용하도록 제안하십시오 . (확산 선호)</target>
        </trans-unit>
        <trans-unit id="3ff97015207b9f4a9f111ed9aa1e794add36b5bd" translate="yes" xml:space="preserve">
          <source>Suggest using template literals instead of string concatenation. (prefer-template)</source>
          <target state="translated">문자열 연결 대신 템플릿 리터럴 사용을 제안하십시오. (템플릿 선호)</target>
        </trans-unit>
        <trans-unit id="73db0ab9a4b1b8fe9efa5f9e4facb96f6382eb3d" translate="yes" xml:space="preserve">
          <source>Suggest using the rest parameters instead of &lt;code&gt;arguments&lt;/code&gt; (prefer-rest-params)</source>
          <target state="translated">&lt;code&gt;arguments&lt;/code&gt; 대신 나머지 매개 변수를 사용하도록 제안하십시오 (rest -rest-params).</target>
        </trans-unit>
        <trans-unit id="2eb3a8ff27b81cae5e0a8c513b02aac9cbb867f5" translate="yes" xml:space="preserve">
          <source>Suggestion &lt;code&gt;messageId&lt;/code&gt;s</source>
          <target state="translated">제안 &lt;code&gt;messageId&lt;/code&gt; 가 의</target>
        </trans-unit>
        <trans-unit id="18e9be223aea66671eb28836cf2ba42607386bfd" translate="yes" xml:space="preserve">
          <source>Suggestions are intended to provide fixes. ESLint will automatically remove the whole suggestion from the linting output if the suggestion's &lt;code&gt;fix&lt;/code&gt; function returned &lt;code&gt;null&lt;/code&gt; or an empty array/sequence.</source>
          <target state="translated">Suggestions are intended to provide fixes. ESLint will automatically remove the whole suggestion from the linting output if the suggestion's &lt;code&gt;fix&lt;/code&gt; function returned &lt;code&gt;null&lt;/code&gt; or an empty array/sequence.</target>
        </trans-unit>
        <trans-unit id="f7db9952d2964aa65b756b67c22f5246a1c46374" translate="yes" xml:space="preserve">
          <source>Suggestions can be tested by defining a &lt;code&gt;suggestions&lt;/code&gt; key on an errors object. The options to check for the suggestions are the following (all are optional):</source>
          <target state="translated">Suggestions can be tested by defining a &lt;code&gt;suggestions&lt;/code&gt; key on an errors object. The options to check for the suggestions are the following (all are optional):</target>
        </trans-unit>
        <trans-unit id="c916d9f4a8ffd629b95d93d9124a2f7c4e41d96c" translate="yes" xml:space="preserve">
          <source>Suggestions can be tested by defining a &lt;code&gt;suggestions&lt;/code&gt; key on an errors object. The options to check for the suggestions are the following (all are optional): * &lt;code&gt;desc&lt;/code&gt; (string): The suggestion &lt;code&gt;desc&lt;/code&gt; value * &lt;code&gt;messageId&lt;/code&gt; (string): The suggestion &lt;code&gt;messageId&lt;/code&gt; value for suggestions that use &lt;code&gt;messageId&lt;/code&gt;s * &lt;code&gt;output&lt;/code&gt; (string): A code string representing the result of applying the suggestion fix to the input code</source>
          <target state="translated">오류 개체에 &lt;code&gt;suggestions&lt;/code&gt; 키를 정의하여 제안을 테스트 할 수 있습니다 . 제안을 확인 할 수있는 옵션은 (모든 선택 사항) 다음과 같다 : * &lt;code&gt;desc&lt;/code&gt; (문자열) : 제안의 &lt;code&gt;desc&lt;/code&gt; 값을 * &lt;code&gt;messageId&lt;/code&gt; 가 (문자열) : 제안의 &lt;code&gt;messageId&lt;/code&gt; 사용 제안 값 &lt;code&gt;messageId&lt;/code&gt; 가 의 * &lt;code&gt;output&lt;/code&gt; (문자열), &amp;bull; 코드 제안 수정 사항을 입력 코드에 적용한 결과를 나타내는 문자열</target>
        </trans-unit>
        <trans-unit id="3e50b8781a635b4ef2043bf1c55b61ebd430b444" translate="yes" xml:space="preserve">
          <source>Summary formatter</source>
          <target state="translated">요약 포맷터</target>
        </trans-unit>
        <trans-unit id="f728bb607703d5d8840e57203c2748461be1c478" translate="yes" xml:space="preserve">
          <source>Supplied callback names</source>
          <target state="translated">제공된 콜백 이름</target>
        </trans-unit>
        <trans-unit id="9e4bceec48f473d3d0d75720f392d38042d15367" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;scopeManager&lt;/code&gt; was added in ESLint v4.14.0. ESLint versions which support &lt;code&gt;scopeManager&lt;/code&gt; will provide an &lt;code&gt;eslintScopeManager: true&lt;/code&gt; property in &lt;code&gt;parserOptions&lt;/code&gt;, which can be used for feature detection.</source>
          <target state="translated">&lt;code&gt;scopeManager&lt;/code&gt; 에 대한 지원이 ESLint v4.14.0 에서 추가되었습니다. 지원 ESLint 버전 &lt;code&gt;scopeManager&lt;/code&gt; 이 제공합니다 &lt;code&gt;eslintScopeManager: true&lt;/code&gt; 재산 &lt;code&gt;parserOptions&lt;/code&gt; 특징 검출에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3be2b0d911459b5814d53e32d33fa047f7443bd" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;visitorKeys&lt;/code&gt; was added in ESLint v4.14.0. ESLint versions which support &lt;code&gt;visitorKeys&lt;/code&gt; will provide an &lt;code&gt;eslintVisitorKeys: true&lt;/code&gt; property in &lt;code&gt;parserOptions&lt;/code&gt;, which can be used for feature detection.</source>
          <target state="translated">&lt;code&gt;visitorKeys&lt;/code&gt; 에 대한 지원이 ESLint v4.14.0 에서 추가되었습니다. 지원 ESLint 버전 &lt;code&gt;visitorKeys&lt;/code&gt; 이 제공합니다 &lt;code&gt;eslintVisitorKeys: true&lt;/code&gt; 재산 &lt;code&gt;parserOptions&lt;/code&gt; 특징 검출에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="998fadcd171167b554bf2c08de343941a1465d16" translate="yes" xml:space="preserve">
          <source>SwitchCase</source>
          <target state="translated">SwitchCase</target>
        </trans-unit>
        <trans-unit id="3253b8236b095baad85b618af991aec7e4b807ea" translate="yes" xml:space="preserve">
          <source>Symbol Objects specification</source>
          <target state="translated">심볼 객체 사양</target>
        </trans-unit>
        <trans-unit id="4b8745ced25b460b42f0ffff119fb7e742454610" translate="yes" xml:space="preserve">
          <source>Symbol Objects specification: Symbol description</source>
          <target state="translated">심볼 객체 사양 : 심볼 설명</target>
        </trans-unit>
        <trans-unit id="5c1a0f585424dee7b8554275b5954f6b460c63ba" translate="yes" xml:space="preserve">
          <source>Syntastic</source>
          <target state="translated">Syntastic</target>
        </trans-unit>
        <trans-unit id="9730d4326a7b8a0d13c2be3b7fe29b80ad152bf6" translate="yes" xml:space="preserve">
          <source>Table of Contents</source>
          <target state="translated">목차</target>
        </trans-unit>
        <trans-unit id="1bb44ac0ce6df50699361a74b6a78b3bcf6d27e3" translate="yes" xml:space="preserve">
          <source>Tabs: jQuery</source>
          <target state="translated">탭 : jQuery</target>
        </trans-unit>
        <trans-unit id="b56e0af9912b57fe07bd022ded51e9d34177d6b8" translate="yes" xml:space="preserve">
          <source>Template literals (MDN)</source>
          <target state="translated">템플릿 리터럴 (MDN)</target>
        </trans-unit>
        <trans-unit id="3760c9870e77d722186e405789b255d1fc4397f6" translate="yes" xml:space="preserve">
          <source>Temporal Dead Zone</source>
          <target state="translated">일시적 데드 존</target>
        </trans-unit>
        <trans-unit id="21d278837034557e7a9b46210d42d6e7b8075142" translate="yes" xml:space="preserve">
          <source>Terminology</source>
          <target state="translated">Terminology</target>
        </trans-unit>
        <trans-unit id="40735bc727ae1db7f555635000520d9343037f8c" translate="yes" xml:space="preserve">
          <source>Ternary Operator</source>
          <target state="translated">삼항 연산자</target>
        </trans-unit>
        <trans-unit id="73ae0e17a1d0167b6266afc4c66bc3cd1157963b" translate="yes" xml:space="preserve">
          <source>Ternary Operator: &lt;code&gt;?:&lt;/code&gt;</source>
          <target state="translated">삼항 연산자 : &lt;code&gt;?:&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0820b32b206b7352858e8903a838ed14319acdfd" translate="yes" xml:space="preserve">
          <source>Testing</source>
          <target state="translated">Testing</target>
        </trans-unit>
        <trans-unit id="aa91a5a624af7d8296afa52521f68fe2c22fbe6f" translate="yes" xml:space="preserve">
          <source>Testing Suggestions</source>
          <target state="translated">테스트 제안</target>
        </trans-unit>
        <trans-unit id="fac2d0573011312ce352636a228659611db6e134" translate="yes" xml:space="preserve">
          <source>Testing errors with &lt;code&gt;messageId&lt;/code&gt;</source>
          <target state="translated">Testing errors with &lt;code&gt;messageId&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d720305ae3061bec3ca536cef916c4141b41323c" translate="yes" xml:space="preserve">
          <source>TextMate 2:</source>
          <target state="translated">텍스트 메이트 2 :</target>
        </trans-unit>
        <trans-unit id="9d341ea56c03bc023005aac875b425f57d6428b2" translate="yes" xml:space="preserve">
          <source>That works fine when you don't want a fallthrough, but what if the fallthrough is intentional, there is no way to indicate that in the language. It's considered a best practice to always indicate when a fallthrough is intentional using a comment which matches the &lt;code&gt;/falls?\s?through/i&lt;/code&gt; regular expression:</source>
          <target state="translated">폴 스루를 원하지 않을 때 잘 작동하지만, 폴스 루가 의도적 인 경우 언어로 표시 할 방법이 없습니다. &lt;code&gt;/falls?\s?through/i&lt;/code&gt; 정규식 과 일치하는 주석을 사용하여 폴스 루가 의도적 인시기를 항상 표시하는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="6ae09c7ad75a7a8f54ad7a675b476d63d3d4806c" translate="yes" xml:space="preserve">
          <source>The &quot;max&quot; object property is optional (default: 1).</source>
          <target state="translated">&quot;max&quot;객체 속성은 선택 사항입니다 (기본값 : 1).</target>
        </trans-unit>
        <trans-unit id="dbb58b13b991ead49bcb9152b87b31df2d758c54" translate="yes" xml:space="preserve">
          <source>The 1-based column number of the begin point of this message.</source>
          <target state="translated">The 1-based column number of the begin point of this message.</target>
        </trans-unit>
        <trans-unit id="77bfab5d4b122d435b42f1cc6e25f3b15431c3ba" translate="yes" xml:space="preserve">
          <source>The 1-based column number of the end point of this message. This property is undefined if this message is not a range.</source>
          <target state="translated">The 1-based column number of the end point of this message. This property is undefined if this message is not a range.</target>
        </trans-unit>
        <trans-unit id="1bfeaeabc605c8970a4e9a4943be75663e3151fb" translate="yes" xml:space="preserve">
          <source>The 1-based line number of the begin point of this message.</source>
          <target state="translated">The 1-based line number of the begin point of this message.</target>
        </trans-unit>
        <trans-unit id="217ce3c9eec171b0c8f48cc98ef0326f12fd81a8" translate="yes" xml:space="preserve">
          <source>The 1-based line number of the end point of this message. This property is undefined if this message is not a range.</source>
          <target state="translated">The 1-based line number of the end point of this message. This property is undefined if this message is not a range.</target>
        </trans-unit>
        <trans-unit id="b16353fd54f2f4a9ee74c0161bfe191f44ad0ae0" translate="yes" xml:space="preserve">
          <source>The 1st option is &lt;code&gt;&quot;asc&quot;&lt;/code&gt; or &lt;code&gt;&quot;desc&quot;&lt;/code&gt;.</source>
          <target state="translated">첫 번째 옵션은 &lt;code&gt;&quot;asc&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;desc&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="45905a15b4e98684c96286c7a579ca2e9122122b" translate="yes" xml:space="preserve">
          <source>The 2nd option is an object which has 3 properties.</source>
          <target state="translated">두 번째 옵션은 3 가지 속성을 가진 객체입니다.</target>
        </trans-unit>
        <trans-unit id="9a3b916c01c8581fb8b9ca9adec25cef6c29aac2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#-editinfo-type&quot;&gt;EditInfo&lt;/a&gt; object of autofix. This property is undefined if this message is not fixable.</source>
          <target state="translated">The &lt;a href=&quot;#-editinfo-type&quot;&gt;EditInfo&lt;/a&gt; object of autofix. This property is undefined if this message is not fixable.</target>
        </trans-unit>
        <trans-unit id="a7ca023748464e13f90714830960ee50f938ef1e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#-lintresult-type&quot;&gt;LintResult&lt;/a&gt; objects to filter.</source>
          <target state="translated">The &lt;a href=&quot;#-lintresult-type&quot;&gt;LintResult&lt;/a&gt; objects to filter.</target>
        </trans-unit>
        <trans-unit id="b70253817a5926115cf28ddc0ea4683ac9393e08" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#-lintresult-type&quot;&gt;LintResult&lt;/a&gt; objects to write.</source>
          <target state="translated">The &lt;a href=&quot;#-lintresult-type&quot;&gt;LintResult&lt;/a&gt; objects to write.</target>
        </trans-unit>
        <trans-unit id="29ce05a67597e0643fcdc8100c44eaa9d1419d89" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#using-rule-metadata&quot;&gt;Using Rule metadata&lt;/a&gt; example shows how to use the &lt;code&gt;data&lt;/code&gt; object in a custom formatter. See the &lt;a href=&quot;working-with-rules&quot;&gt;Working with Rules&lt;/a&gt; page for more information about rules.</source>
          <target state="translated">&lt;a href=&quot;#using-rule-metadata&quot;&gt;사용 규칙 메타 데이터&lt;/a&gt; 예를 보여줍니다이 방법을 사용하는 &lt;code&gt;data&lt;/code&gt; 사용자 정의 포맷터에서 개체를. 참고 항목 &lt;a href=&quot;working-with-rules&quot;&gt;규칙 작업&lt;/a&gt; 규칙에 대한 자세한 내용은 페이지를.</target>
        </trans-unit>
        <trans-unit id="5b1896cdaec6c51ba10667d39b756eedd5551922" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../rules/no-undef&quot;&gt;no-undef&lt;/a&gt; rule will warn on variables that are accessed but not defined within the same file. If you are using global variables inside of a file then it's worthwhile to define those globals so that ESLint will not warn about their usage. You can define global variables either using comments inside of a file or in the configuration file.</source>
          <target state="translated">&lt;a href=&quot;../rules/no-undef&quot;&gt;없는 미확정&lt;/a&gt; 규칙은 액세스하지만 같은 파일 내에서 정의되지 않은 변수에 경고합니다. 파일 내에서 전역 변수를 사용하는 경우 ESLint가 사용법에 대해 경고하지 않도록 전역 변수를 정의하는 것이 좋습니다. 파일 내부 또는 구성 파일의 주석을 사용하여 전역 변수를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="047eac5397259d4ad14b6243aa57de4dae1a614d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://es5.github.io/#x15.8&quot;&gt;ECMAScript 5 specification&lt;/a&gt; makes it clear that both &lt;code&gt;Math&lt;/code&gt; and &lt;code&gt;JSON&lt;/code&gt; cannot be invoked:</source>
          <target state="translated">&lt;a href=&quot;https://es5.github.io/#x15.8&quot;&gt;인 ECMAScript 5 사양&lt;/a&gt; 이 모두 분명하게 &lt;code&gt;Math&lt;/code&gt; 및 &lt;code&gt;JSON&lt;/code&gt; 이 호출 할 수 없습니다 :</target>
        </trans-unit>
        <trans-unit id="1a35e82f6be72b6be61cd4a886d86c858f228012" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.ecma-international.org/ecma-262/6.0/index.html#sec-reflect-object&quot;&gt;ECMAScript 2015 specification&lt;/a&gt; makes it clear that &lt;code&gt;Reflect&lt;/code&gt; cannot be invoked:</source>
          <target state="translated">&lt;a href=&quot;https://www.ecma-international.org/ecma-262/6.0/index.html#sec-reflect-object&quot;&gt;ECMAScript를 2015 사양&lt;/a&gt; 이 분명하게 &lt;code&gt;Reflect&lt;/code&gt; 호출 할 수 없습니다 :</target>
        </trans-unit>
        <trans-unit id="81c1cb58f2de5577eeb597a1918e8584414249b1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;always&quot;&lt;/code&gt; option (default) enforces the use of &lt;code&gt;===&lt;/code&gt; and &lt;code&gt;!==&lt;/code&gt; in every situation (except when you opt-in to more specific handling of &lt;code&gt;null&lt;/code&gt; [see below]).</source>
          <target state="translated">&lt;code&gt;&quot;always&quot;&lt;/code&gt; 옵션 (기본값)의 사용을 강제 &lt;code&gt;===&lt;/code&gt; 와 &lt;code&gt;!==&lt;/code&gt; 모든 상황에서 (당신이 선택 된 경우의 처리보다 구체적인를 제외하고 &lt;code&gt;null&lt;/code&gt; [아래 참조]).</target>
        </trans-unit>
        <trans-unit id="0234b9d3610f2d5c0d1890c03b252abd7cefab7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;as-needed&quot;, { &quot;requireForBlockBody&quot;: true }&lt;/code&gt; rule is directly inspired by the Airbnb &lt;a href=&quot;https://github.com/airbnb/javascript#arrows--one-arg-parens&quot;&gt;JS Style Guide&lt;/a&gt;.</source>
          <target state="translated">은 &lt;code&gt;&quot;as-needed&quot;, { &quot;requireForBlockBody&quot;: true }&lt;/code&gt; 규칙은 직접 에어 비앤비에서 영감을 &lt;a href=&quot;https://github.com/airbnb/javascript#arrows--one-arg-parens&quot;&gt;JS 스타일 가이드&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d82ce97069386b44a427b995707c718f99559346" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;builtinGlobals&quot;&lt;/code&gt; option will check for redeclaration of built-in globals in global scope.</source>
          <target state="translated">&lt;code&gt;&quot;builtinGlobals&quot;&lt;/code&gt; 옵션은 글로벌 범위 전역에서 내장의 재 선언 확인합니다.</target>
        </trans-unit>
        <trans-unit id="258321fe90655819f22eef5ffbb3f4fe1c32eec4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;empty&quot;&lt;/code&gt; exception concerns empty parentheses, and works the same way as the other exceptions, inverting the first option.</source>
          <target state="translated">&lt;code&gt;&quot;empty&quot;&lt;/code&gt; 예외 우려 빈 괄호, 그리고 첫 번째 옵션을 반전, 다른 예외와 동일한 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="3b02d6c73ff7b77ebcbfdce42ad57c73245465b3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;eslint:recommended&quot;&lt;/code&gt; configuration contains many of the same default rule settings from 0.x, but not all. These rules are no longer on by default, so you should review your settings to ensure they are still as you expect:</source>
          <target state="translated">&lt;code&gt;&quot;eslint:recommended&quot;&lt;/code&gt; 구성은 아니지만, 0.x에서 동일한 기본 규칙 설정의 대부분이 포함되어 있습니다. 이 규칙은 더 이상 기본적으로 설정되어 있지 않으므로 설정을 검토하여 여전히 예상과 같은지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="5913f4b04b709c4a37956c8f0a355bb3e59d6045" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;exceptions&quot;&lt;/code&gt; value is an array of string patterns which are considered exceptions to the rule. Please note that exceptions are ignored if the first argument is &lt;code&gt;&quot;never&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;exceptions&quot;&lt;/code&gt; 값은 규칙에 대한 예외를 고려 문자열 패턴의 배열이다. 첫 번째 인수가 &lt;code&gt;&quot;never&quot;&lt;/code&gt; 이면 예외가 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="fe039a59a04c46fd505176d921318453636d178a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;exceptions&quot;&lt;/code&gt; value is an array of string patterns which are considered exceptions to the rule. The rule will not warn when the pattern starts from the beginning of the comment and repeats until the end of the line or &lt;code&gt;*/&lt;/code&gt; if the comment is a single line comment. Please note that exceptions are ignored if the first argument is &lt;code&gt;&quot;never&quot;&lt;/code&gt;.</source>
          <target state="translated">The &lt;code&gt;&quot;exceptions&quot;&lt;/code&gt; value is an array of string patterns which are considered exceptions to the rule. The rule will not warn when the pattern starts from the beginning of the comment and repeats until the end of the line or &lt;code&gt;*/&lt;/code&gt; if the comment is a single line comment. Please note that exceptions are ignored if the first argument is &lt;code&gt;&quot;never&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e34f8d72a6e0abd2b6cd46f7f53eb977a9c25ad6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;extends&quot;: &quot;eslint:recommended&quot;&lt;/code&gt; property in a configuration file enables this rule.</source>
          <target state="translated">구성 파일 의 &lt;code&gt;&quot;extends&quot;: &quot;eslint:recommended&quot;&lt;/code&gt; 속성이이 규칙을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="ec76be0c108097d6838a0ac4fbb38e16745647e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;markers&quot;&lt;/code&gt; value is an array of string patterns which are considered markers for docblock-style comments, such as an additional &lt;code&gt;/&lt;/code&gt;, used to denote documentation read by doxygen, vsdoc, etc. which must have additional characters. The &lt;code&gt;&quot;markers&quot;&lt;/code&gt; array will apply regardless of the value of the first argument, e.g. &lt;code&gt;&quot;always&quot;&lt;/code&gt; or &lt;code&gt;&quot;never&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;markers&quot;&lt;/code&gt; 값은 추가로 docblock 스타일의 의견 마커를 고려하는 문자열 패턴의 배열입니다 &lt;code&gt;/&lt;/code&gt; , 나타낸다 문서에 사용되는 문자를 추가해야합니다 doxygen이, vsdoc 등 읽을. &lt;code&gt;&quot;markers&quot;&lt;/code&gt; 배열은 예를 들어,에 관계없이 첫 번째 인수의 값에 적용되지 않습니다 &lt;code&gt;&quot;always&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;never&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5df38b7cf9b33c3fdba20972fad0ce2f4e5d6596" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;never&quot;&lt;/code&gt; option ignores &lt;code&gt;const&lt;/code&gt; variable initializations.</source>
          <target state="translated">&lt;code&gt;&quot;never&quot;&lt;/code&gt; 옵션 무시는 &lt;code&gt;const&lt;/code&gt; 변수 초기화를.</target>
        </trans-unit>
        <trans-unit id="665c133a9b40f2ee21d1a8c214ccb5968d500388" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;property&quot;&lt;/code&gt; option requires the dot to be on the same line as the property.</source>
          <target state="translated">&lt;code&gt;&quot;property&quot;&lt;/code&gt; 옵션은 속성과 같은 줄에있을 점을 필요로한다.</target>
        </trans-unit>
        <trans-unit id="a8917282c9e6924d8221f022d420501eebe8dd61" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;safe&quot;&lt;/code&gt; option corresponds to the &lt;code&gt;&quot;global&quot;&lt;/code&gt; option if ESLint considers a file to be a &lt;strong&gt;Node.js&lt;/strong&gt; or &lt;strong&gt;CommonJS&lt;/strong&gt; module because the configuration specifies either of the following:</source>
          <target state="translated">&lt;code&gt;&quot;safe&quot;&lt;/code&gt; 받는 옵션 대응 &lt;code&gt;&quot;global&quot;&lt;/code&gt; ESLint가 될 파일을 고려하면 옵션 &lt;strong&gt;Node.js를&lt;/strong&gt; 또는 &lt;strong&gt;CommonJS&lt;/strong&gt; 모듈 때문에 중 다음의 구성을 지정 :</target>
        </trans-unit>
        <trans-unit id="335d3d2aadf4b8cd6d235ef1c1ab85d30c55e2fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;smart&quot;&lt;/code&gt; option enforces the use of &lt;code&gt;===&lt;/code&gt; and &lt;code&gt;!==&lt;/code&gt; except for these cases:</source>
          <target state="translated">&lt;code&gt;&quot;smart&quot;&lt;/code&gt; 옵션의 사용을 강제 &lt;code&gt;===&lt;/code&gt; 와 &lt;code&gt;!==&lt;/code&gt; 이 경우를 제외하고를 :</target>
        </trans-unit>
        <trans-unit id="757da32c45a012c497f6f5b85d15dfd792bd342d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; directive applies to the scope in which it appears and all inner scopes contained within that scope. Therefore, using the &lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; directive in one of these inner scopes is unnecessary.</source>
          <target state="translated">는 &lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; 지시문은 표시되는 범위와 해당 범위 내에 포함 된 모든 내부 범위에 적용됩니다. 따라서 &lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; 이러한 내부 범위 중 하나의 지시어는 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="34c46639b01057382b6b9a17c0ce73084f411d5f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--fix&lt;/code&gt; option on the &lt;a href=&quot;../user-guide/command-line-interface#fix&quot;&gt;command line&lt;/a&gt; automatically fixed problems reported by this rule.</source>
          <target state="translated">&lt;a href=&quot;../user-guide/command-line-interface#fix&quot;&gt;명령 행&lt;/a&gt; 의 &lt;code&gt;--fix&lt;/code&gt; 옵션은 이 규칙에 의해보고 된 문제를 자동으로 수정합니다.</target>
        </trans-unit>
        <trans-unit id="5b8b6136da33c3a25813fde1f0b5cd20a7b643a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--fix&lt;/code&gt; option on the &lt;a href=&quot;../user-guide/command-line-interface#fix&quot;&gt;command line&lt;/a&gt; automatically fixes problems (currently mostly whitespace) reported by rules which have a wrench  below.</source>
          <target state="translated">The &lt;code&gt;--fix&lt;/code&gt; option on the &lt;a href=&quot;../user-guide/command-line-interface#fix&quot;&gt;command line&lt;/a&gt; automatically fixes problems (currently mostly whitespace) reported by rules which have a wrench below.</target>
        </trans-unit>
        <trans-unit id="8c7a3a09ba8e134da02e62a2b097beafa2f467a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--fix&lt;/code&gt; option on the &lt;a href=&quot;../user-guide/command-line-interface#fixing-problems&quot;&gt;command line&lt;/a&gt; can automatically fix some of the problems reported by this rule.</source>
          <target state="translated">&lt;a href=&quot;../user-guide/command-line-interface#fixing-problems&quot;&gt;명령 행&lt;/a&gt; 의 &lt;code&gt;--fix&lt;/code&gt; 옵션은 이 규칙에 의해보고 된 일부 문제를 자동으로 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ad561df4151ebb76e63f840b52ab0f6ae886e08" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--fix&lt;/code&gt; option on the command line automatically fixes some problems reported by this rule. A problem is only fixed if one of the operands is a &lt;code&gt;typeof&lt;/code&gt; expression, or if both operands are literals with the same type.</source>
          <target state="translated">명령 행 의 &lt;code&gt;--fix&lt;/code&gt; 옵션은이 규칙에 의해보고 된 일부 문제를 자동으로 수정합니다. 문제점은 피연산자 중 하나가 고정되는 경우 &lt;code&gt;typeof&lt;/code&gt; 발현, 또는 둘 모두의 피연산자는 동일한 유형 리터럴 경우.</target>
        </trans-unit>
        <trans-unit id="cfc6a5d47bc7a83b2362366b0d3b2b186202a528" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--fix&lt;/code&gt; option on the command line automatically fixes some problems reported by this rule: multiple members on a single line are automatically sorted (e.g. &lt;code&gt;import { b, a } from 'foo.js'&lt;/code&gt; is corrected to &lt;code&gt;import { a, b } from 'foo.js'&lt;/code&gt;), but multiple lines are not reordered.</source>
          <target state="translated">&lt;code&gt;--fix&lt;/code&gt; 명령 행 옵션이 자동으로 몇 가지 문제는이 규칙에 의해보고 해결 한 줄에 여러 멤버가 자동으로 (예를 들면 분류되어 &lt;code&gt;import { b, a } from 'foo.js'&lt;/code&gt; 로 수정되는 &lt;code&gt;import { a, b } from 'foo.js'&lt;/code&gt; ), 여러 줄은 재정렬되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6ee7ab0d0ef494b690762e7c764488b7d5a3c387" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--fix&lt;/code&gt; option on the command line does not insert new &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; statements, but only removes unneeded statements.</source>
          <target state="translated">명령 행 의 &lt;code&gt;--fix&lt;/code&gt; 옵션은 새로운 &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; 명령문을 삽입하지 않고 불필요한 명령문 만 제거합니다.</target>
        </trans-unit>
        <trans-unit id="3d24607e46229c7268d72a682e31b53d3099f57e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--fix&lt;/code&gt; option on the command line fixes only problems reported in variable declarations, and among them only those that fall under the category &lt;code&gt;object&lt;/code&gt; destructuring. Furthermore, the name of the declared variable has to be the same as the name used for non-computed member access in the initializer. For example, &lt;code&gt;var foo = object.foo&lt;/code&gt; can be automatically fixed by this rule. Problems that involve computed member access (e.g., &lt;code&gt;var foo = object[foo]&lt;/code&gt;) or renamed properties (e.g., &lt;code&gt;var foo = object.bar&lt;/code&gt;) are not automatically fixed.</source>
          <target state="translated">The &lt;code&gt;--fix&lt;/code&gt; option on the command line fixes only problems reported in variable declarations, and among them only those that fall under the category &lt;code&gt;object&lt;/code&gt; destructuring. Furthermore, the name of the declared variable has to be the same as the name used for non-computed member access in the initializer. For example, &lt;code&gt;var foo = object.foo&lt;/code&gt; can be automatically fixed by this rule. Problems that involve computed member access (e.g., &lt;code&gt;var foo = object[foo]&lt;/code&gt; ) or renamed properties (e.g., &lt;code&gt;var foo = object.bar&lt;/code&gt; ) are not automatically fixed.</target>
        </trans-unit>
        <trans-unit id="651165c0cfafa6ed91a01ff2f3a275112628a26a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@author&lt;/code&gt; field gives you credit for having created the file.</source>
          <target state="translated">&lt;code&gt;@author&lt;/code&gt; 의 필드는 파일을 생성 한 당신에게 신용을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8d050940abfee32adbac0c6eb00b3c5418a91500" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CLIEngine#executeOnText()&lt;/code&gt; method has changed to work more like &lt;code&gt;CLIEngine#executeOnFiles()&lt;/code&gt;. In v2.x, &lt;code&gt;CLIEngine#executeOnText()&lt;/code&gt; warned about ignored files by default and didn't have a way to opt-out of those warnings whereas &lt;code&gt;CLIEngine#executeOnFiles()&lt;/code&gt; did not warn about ignored files by default and allowed you to opt-in to warning about them. The &lt;code&gt;CLIEngine#executeOnText()&lt;/code&gt; method now also does not warn about ignored files by default and allows you to opt-in with a new, third argument (a boolean, &lt;code&gt;true&lt;/code&gt; to warn about ignored files and &lt;code&gt;false&lt;/code&gt; to not warn).</source>
          <target state="translated">&lt;code&gt;CLIEngine#executeOnText()&lt;/code&gt; 메소드는 같은 더 많은 작업 변경되었습니다 &lt;code&gt;CLIEngine#executeOnFiles()&lt;/code&gt; . v2.x에서 &lt;code&gt;CLIEngine#executeOnText()&lt;/code&gt; 는 기본적으로 무시 된 파일에 대해 경고하고 해당 경고를 거부 할 수있는 방법이 &lt;code&gt;CLIEngine#executeOnFiles()&lt;/code&gt; 는 기본적으로 무시 된 파일에 대해 경고하지 않았으므로 옵트 인 할 수있었습니다. 그들에 대해 경고합니다. &lt;code&gt;CLIEngine#executeOnText()&lt;/code&gt; 메소드는 이제 기본적으로 무시 파일에 대한 경고하고 당신을 허용하지 않습니다 옵트 인 (부울, 새로운, 세 번째 인수와 &lt;code&gt;true&lt;/code&gt; 무시 파일에 대해 경고하는 &lt;code&gt;false&lt;/code&gt; 경고하지에).</target>
        </trans-unit>
        <trans-unit id="cd01e52d3805d8a62d247b8499d65fa83701f436" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CLIEngine&lt;/code&gt; is a constructor, and you can create a new instance by passing in the options you want to use. The available options are:</source>
          <target state="translated">&lt;code&gt;CLIEngine&lt;/code&gt; 는 생성자, 당신은 당신이 사용할 옵션을 전달하여 새 인스턴스를 만들 수 있습니다. 사용 가능한 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="36a91b8e915150c788d9aa4f17ae522dfcd51ab4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CLIEngine&lt;/code&gt; object</source>
          <target state="translated">&lt;code&gt;CLIEngine&lt;/code&gt; 의 객체</target>
        </trans-unit>
        <trans-unit id="cb04e559741ded700b750c763c58609e67280d3e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CLIEngine&lt;/code&gt; type represents the core functionality of the CLI except that it reads nothing from the command line and doesn't output anything by default. Instead, it accepts many (but not all) of the arguments that are passed into the CLI. It reads both configuration and source files as well as managing the environment that is passed into the &lt;code&gt;Linter&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;CLIEngine&lt;/code&gt; 의 유형은 명령 줄에서 아무것도 읽지 않습니다 기본적으로 아무것도 출력하지 않는 것을 제외하고는 CLI의 핵심 기능을 나타냅니다. 대신 CLI로 전달되는 많은 인수를 받아들입니다. &lt;code&gt;Linter&lt;/code&gt; 오브젝트 로 전달되는 환경 관리는 물론 구성 및 소스 파일을 모두 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="7c04bc333459294a802b327b5827d0068e581953" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CLIEngine&lt;/code&gt;, &lt;code&gt;SourceCode&lt;/code&gt;, and &lt;code&gt;RuleTester&lt;/code&gt; modules from ESLint's Node.js API are now ES2015 classes. This will not break any documented behavior, but it does have some observable effects (for example, the methods on &lt;code&gt;CLIEngine.prototype&lt;/code&gt; are now non-enumerable).</source>
          <target state="translated">ESLint의 Node.js API 의 &lt;code&gt;CLIEngine&lt;/code&gt; , &lt;code&gt;SourceCode&lt;/code&gt; 및 &lt;code&gt;RuleTester&lt;/code&gt; 모듈은 이제 ES2015 클래스입니다. 이로 인해 문서화 된 동작이 중단되지는 않지만 관찰 가능한 영향이 있습니다 (예 : &lt;code&gt;CLIEngine.prototype&lt;/code&gt; 의 메소드 는 열거 할 수 없음).</target>
        </trans-unit>
        <trans-unit id="8dff6f94cd40c096f350e419d585278490290c3e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ESLint&lt;/code&gt; class is the primary class to use in Node.js applications.</source>
          <target state="translated">The &lt;code&gt;ESLint&lt;/code&gt; class is the primary class to use in Node.js applications.</target>
        </trans-unit>
        <trans-unit id="448de94e4a5c6b54e20b7d92beb049e1353254ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ESLint&lt;/code&gt; constructor takes an &lt;code&gt;options&lt;/code&gt; object. If you omit the &lt;code&gt;options&lt;/code&gt; object then it uses default values for all options. The &lt;code&gt;options&lt;/code&gt; object has the following properties.</source>
          <target state="translated">The &lt;code&gt;ESLint&lt;/code&gt; constructor takes an &lt;code&gt;options&lt;/code&gt; object. If you omit the &lt;code&gt;options&lt;/code&gt; object then it uses default values for all options. The &lt;code&gt;options&lt;/code&gt; object has the following properties.</target>
        </trans-unit>
        <trans-unit id="cb55f87af3939b8a26c09301489c8b88cb0d4b46" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;EditInfo&lt;/code&gt; value is information to edit text. The &lt;code&gt;fix&lt;/code&gt; and &lt;code&gt;suggestions&lt;/code&gt; properties of &lt;a href=&quot;#-lintmessage-type&quot;&gt;LintMessage&lt;/a&gt; type contain it. It has following properties:</source>
          <target state="translated">The &lt;code&gt;EditInfo&lt;/code&gt; value is information to edit text. The &lt;code&gt;fix&lt;/code&gt; and &lt;code&gt;suggestions&lt;/code&gt; properties of &lt;a href=&quot;#-lintmessage-type&quot;&gt;LintMessage&lt;/a&gt; type contain it. It has following properties:</target>
        </trans-unit>
        <trans-unit id="bc6ee1cbc4284429934a86ecac444fe81dc04e8e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Formatter&lt;/code&gt; value is the object to convert the &lt;a href=&quot;#-lintresult-type&quot;&gt;LintResult&lt;/a&gt; objects to text. The &lt;a href=&quot;#-eslintloadformatternameorpath&quot;&gt;eslint.loadFormatter()&lt;/a&gt; method returns it. It has the following method:</source>
          <target state="translated">The &lt;code&gt;Formatter&lt;/code&gt; value is the object to convert the &lt;a href=&quot;#-lintresult-type&quot;&gt;LintResult&lt;/a&gt; objects to text. The &lt;a href=&quot;#-eslintloadformatternameorpath&quot;&gt;eslint.loadFormatter()&lt;/a&gt; method returns it. It has the following method:</target>
        </trans-unit>
        <trans-unit id="10215453b4d9e38705bc6510ce93465250bda0fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LintMessage&lt;/code&gt; value is the information of each linting error. The &lt;code&gt;messages&lt;/code&gt; property of the &lt;a href=&quot;#-lintresult-type&quot;&gt;LintResult&lt;/a&gt; type contains it. It has the following properties:</source>
          <target state="translated">The &lt;code&gt;LintMessage&lt;/code&gt; value is the information of each linting error. The &lt;code&gt;messages&lt;/code&gt; property of the &lt;a href=&quot;#-lintresult-type&quot;&gt;LintResult&lt;/a&gt; type contains it. It has the following properties:</target>
        </trans-unit>
        <trans-unit id="80d5223bd532c8881ed7de1546fb3c0c20284147" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LintResult&lt;/code&gt; value is the information of the linting result of each file. The &lt;a href=&quot;#-eslintlintfilespatterns&quot;&gt;&lt;code&gt;eslint.lintFiles()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#-eslintlinttextcode-options&quot;&gt;&lt;code&gt;eslint.lintText()&lt;/code&gt;&lt;/a&gt; methods return it. It has the following properties:</source>
          <target state="translated">The &lt;code&gt;LintResult&lt;/code&gt; value is the information of the linting result of each file. The &lt;a href=&quot;#-eslintlintfilespatterns&quot;&gt; &lt;code&gt;eslint.lintFiles()&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;#-eslintlinttextcode-options&quot;&gt; &lt;code&gt;eslint.lintText()&lt;/code&gt; &lt;/a&gt; methods return it. It has the following properties:</target>
        </trans-unit>
        <trans-unit id="5c9b20fb5b6252830eb519435c0219003fa37dba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Linter&lt;/code&gt; object</source>
          <target state="translated">&lt;code&gt;Linter&lt;/code&gt; 객체</target>
        </trans-unit>
        <trans-unit id="1d37bb325bb6d585cfb9ad4d89a7dcea80388f30" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Linter&lt;/code&gt; object does the actual evaluation of the JavaScript code. It doesn't do any filesystem operations, it simply parses and reports on the code. In particular, the &lt;code&gt;Linter&lt;/code&gt; object does not process configuration objects or files. The &lt;code&gt;Linter&lt;/code&gt; is a constructor, and you can create a new instance by passing in the options you want to use. The available options are:</source>
          <target state="translated">&lt;code&gt;Linter&lt;/code&gt; 객체는 자바 스크립트 코드의 실제 평가를 수행합니다. 파일 시스템 작업을 수행하지 않고 단순히 코드를 구문 분석하고보고합니다. 특히 &lt;code&gt;Linter&lt;/code&gt; 오브젝트는 구성 오브젝트 또는 파일을 처리하지 않습니다. &lt;code&gt;Linter&lt;/code&gt; 생성자, 당신은 당신이 사용할 옵션을 전달하여 새 인스턴스를 만들 수 있습니다. 사용 가능한 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6b3697f8c0f76c13f38759df3544e6dd3e1c83db" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Literal&lt;/code&gt; node must have &lt;code&gt;raw&lt;/code&gt; property.</source>
          <target state="translated">&lt;code&gt;Literal&lt;/code&gt; 노드가 있어야합니다 &lt;code&gt;raw&lt;/code&gt; 속성을.</target>
        </trans-unit>
        <trans-unit id="6199c13da52a235cf644776c5b0a32c08d65bf50" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Literal&lt;/code&gt; node:</source>
          <target state="translated">&lt;code&gt;Literal&lt;/code&gt; 노드 :</target>
        </trans-unit>
        <trans-unit id="b0e719a9b8eee0a7e784f9393820037edebb8384" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Object&lt;/code&gt; constructor is used to create new generic objects in JavaScript, such as:</source>
          <target state="translated">&lt;code&gt;Object&lt;/code&gt; 생성자는 다음과 같은 자바 스크립트에서 새 일반 객체를 만드는 데 사용됩니다 :</target>
        </trans-unit>
        <trans-unit id="26fa98a82c9b4be9d13ddb25b7b39470825fc8b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Program&lt;/code&gt; node must have &lt;code&gt;tokens&lt;/code&gt; and &lt;code&gt;comments&lt;/code&gt; properties. Both properties are an array of the below Token interface.</source>
          <target state="translated">&lt;code&gt;Program&lt;/code&gt; 노드가 있어야합니다 &lt;code&gt;tokens&lt;/code&gt; 및 &lt;code&gt;comments&lt;/code&gt; 속성을. 두 속성 모두 아래 토큰 인터페이스의 배열입니다.</target>
        </trans-unit>
        <trans-unit id="bcf1f4affa5a7dea7c1e9653f4ab221ce29cdab1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Program&lt;/code&gt; node:</source>
          <target state="translated">&lt;code&gt;Program&lt;/code&gt; 노드 :</target>
        </trans-unit>
        <trans-unit id="70ccd03ac71f531e40460156a41567e273392912" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RegExp&lt;/code&gt; constructor function, e.g., &lt;code&gt;new RegExp(&quot;abc&quot;, &quot;u&quot;)&lt;/code&gt; or &lt;code&gt;RegExp(&quot;abc&quot;, &quot;u&quot;)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;RegExp&lt;/code&gt; 생성자 함수, 예를 들면, &lt;code&gt;new RegExp(&quot;abc&quot;, &quot;u&quot;)&lt;/code&gt; 또는 &lt;code&gt;RegExp(&quot;abc&quot;, &quot;u&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18ac7817ce0d8138e79809c23852f9087177a2fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RuleTester#run()&lt;/code&gt; method is used to run the tests. It should be passed the following arguments:</source>
          <target state="translated">&lt;code&gt;RuleTester#run()&lt;/code&gt; 메소드는 테스트를 실행하는 데 사용됩니다. 다음과 같은 인수를 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="e3f4c9bab5a0c5a3adc959e3a3fdfbbb58b5ebf6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RuleTester&lt;/code&gt; constructor accepts an optional object argument, which can be used to specify defaults for your test cases. For example, if all of your test cases use ES2015, you can set it as a default:</source>
          <target state="translated">&lt;code&gt;RuleTester&lt;/code&gt; 의 생성자는 테스트 케이스에 대한 기본값을 지정하는 데 사용할 수있는 선택적 오브젝트 인수를 받아들입니다. 예를 들어 모든 테스트 사례가 ES2015를 사용하는 경우이를 기본값으로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a5077bac9449562ad14f14c5e522a6fd8f8637a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SourceCode&lt;/code&gt; constructor strips Unicode BOM. Please note the AST also should be parsed from stripped text.</source>
          <target state="translated">&lt;code&gt;SourceCode&lt;/code&gt; 생성자는 유니 코드 BOM을 제거합니다. AST도 제거 된 텍스트에서 구문 분석해야합니다.</target>
        </trans-unit>
        <trans-unit id="db75fab00b139e2cb8ebf27b845a2a26e0849306" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SourceCode&lt;/code&gt; constructor throws an error if the AST is missing any of the required information.</source>
          <target state="translated">&lt;code&gt;SourceCode&lt;/code&gt; 생성자는 AST 필요한 정보의 누락 된 경우 에러가 발생.</target>
        </trans-unit>
        <trans-unit id="1218e56286f97f65b8425325264eb5a0d40ee097" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SourceCode&lt;/code&gt; object is the main object for getting more information about the source code being linted. You can retrieve the &lt;code&gt;SourceCode&lt;/code&gt; object at any time by using the &lt;code&gt;getSourceCode()&lt;/code&gt; method:</source>
          <target state="translated">&lt;code&gt;SourceCode&lt;/code&gt; 객체는 소스 코드 linted 것에 대해 자세한 정보를 얻기위한 주요 목적이다. &lt;code&gt;getSourceCode()&lt;/code&gt; 메소드를 사용하여 언제든지 &lt;code&gt;SourceCode&lt;/code&gt; 오브젝트를 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="479675aca73cae5c11d5d90c4454a08ce8e61d27" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SourceCode&lt;/code&gt; type represents the parsed source code that ESLint executes on. It's used internally in ESLint and is also available so that already-parsed code can be used. You can create a new instance of &lt;code&gt;SourceCode&lt;/code&gt; by passing in the text string representing the code and an abstract syntax tree (AST) in &lt;a href=&quot;https://github.com/estree/estree&quot;&gt;ESTree&lt;/a&gt; format (including location information, range information, comments, and tokens):</source>
          <target state="translated">&lt;code&gt;SourceCode&lt;/code&gt; 유형은 ESLint에서 실행되는 해석 된 소스 코드를 나타낸다. ESLint에서 내부적으로 사용되며 이미 구문 분석 된 코드를 사용할 수 있도록 사용할 수도 있습니다. 코드를 나타내는 텍스트 문자열과 &lt;a href=&quot;https://github.com/estree/estree&quot;&gt;ESTree&lt;/a&gt; 형식 의 추상 구문 트리 (AST) (위치 정보, 범위 정보, 주석 및 토큰 포함 )를 전달하여 &lt;code&gt;SourceCode&lt;/code&gt; 의 새 인스턴스를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0f460ba3a888cb7885538cd22b45cfa2e1993d93" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Symbol&lt;/code&gt; function may have an optional description:</source>
          <target state="translated">&lt;code&gt;Symbol&lt;/code&gt; 기능은 선택적 설명이있을 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="2d21736c63a542408cd25bebb0064399dafd3380" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Tag&lt;/code&gt; is one of the following:</source>
          <target state="translated">&lt;code&gt;Tag&lt;/code&gt; 다음 중 하나입니다 :</target>
        </trans-unit>
        <trans-unit id="4017431bd4ca04209028b2fd7c8155020d0e96be" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__iterator__&lt;/code&gt; property was a SpiderMonkey extension to JavaScript that could be used to create custom iterators that are compatible with JavaScript's &lt;code&gt;for in&lt;/code&gt; and &lt;code&gt;for each&lt;/code&gt; constructs. However, this property is now obsolete, so it should not be used. Here's an example of how this used to work:</source>
          <target state="translated">&lt;code&gt;__iterator__&lt;/code&gt; 속성은 자바 스크립트의와 호환되는 사용자 정의 반복자 만드는 데 사용할 수있는 자바 스크립트에 SpiderMonkey를 확장했다 &lt;code&gt;for in&lt;/code&gt; 및 &lt;code&gt;for each&lt;/code&gt; 구조를. 그러나이 특성은 이제 더 이상 사용되지 않으므로 사용해서는 안됩니다. 이것이 어떻게 작동했는지에 대한 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5c5ed6ba19e731544b6cd87b09fe8abbca32c289" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;_linter&lt;/code&gt; property has been removed in ESLint v5.0, so it is no longer possible to implement rules with this functionality. However, the &lt;a href=&quot;command-line-interface#--report-unused-disable-directives&quot;&gt;&lt;code&gt;--report-unused-disable-directives&lt;/code&gt;&lt;/a&gt; CLI flag can be used to flag unused directive comments.</source>
          <target state="translated">&lt;code&gt;_linter&lt;/code&gt; 의 는이 기능과 규칙을 구현하는 것은 더 이상 가능하므로 속성이 ESLint의 5.0에서 제거되지 않았습니다. 그러나 &lt;a href=&quot;command-line-interface#--report-unused-disable-directives&quot;&gt; &lt;code&gt;--report-unused-disable-directives&lt;/code&gt; &lt;/a&gt; CLI 플래그를 사용하여 사용되지 않은 지시문 주석에 플래그를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9b2ca0a9deb95b8d07936a6b72107ed5085c1aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;_linter&lt;/code&gt; property on rule context objects has been removed</source>
          <target state="translated">규칙 컨텍스트 오브젝트 의 &lt;code&gt;_linter&lt;/code&gt; 특성이 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="1540bf038d822cce14da545ed574c51549eac1e8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;align&lt;/code&gt; option can take additional configuration through the &lt;code&gt;beforeColon&lt;/code&gt;, &lt;code&gt;afterColon&lt;/code&gt;, &lt;code&gt;mode&lt;/code&gt;, and &lt;code&gt;on&lt;/code&gt; options.</source>
          <target state="translated">&lt;code&gt;align&lt;/code&gt; 옵션을 통해 추가 구성을 취할 수 &lt;code&gt;beforeColon&lt;/code&gt; , &lt;code&gt;afterColon&lt;/code&gt; , &lt;code&gt;mode&lt;/code&gt; , 그리고 &lt;code&gt;on&lt;/code&gt; 옵션을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d05ba21959dd3bd33b13539a51873b945545c638" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;allow&lt;/code&gt; option is an array of identifier names for which shadowing is allowed. For example, &lt;code&gt;&quot;resolve&quot;&lt;/code&gt;, &lt;code&gt;&quot;reject&quot;&lt;/code&gt;, &lt;code&gt;&quot;done&quot;&lt;/code&gt;, &lt;code&gt;&quot;cb&quot;&lt;/code&gt;.</source>
          <target state="translated">는 &lt;code&gt;allow&lt;/code&gt; 옵션은 그림자가 허용되는 식별자 이름의 배열입니다. 예를 들어 &lt;code&gt;&quot;resolve&quot;&lt;/code&gt; , &lt;code&gt;&quot;reject&quot;&lt;/code&gt; , &lt;code&gt;&quot;done&quot;&lt;/code&gt; , &lt;code&gt;&quot;cb&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a3afd6725b2244693e0d6e156a1e44afd3600d41" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;args&lt;/code&gt; option has three settings:</source>
          <target state="translated">&lt;code&gt;args&lt;/code&gt; 옵션은 세 가지 설정이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="4cadc8103349def3aa303140050911f6d8949c38" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;argsIgnorePattern&lt;/code&gt; option specifies exceptions not to check for usage: arguments whose names match a regexp pattern. For example, variables whose names begin with an underscore.</source>
          <target state="translated">&lt;code&gt;argsIgnorePattern&lt;/code&gt; 옵션을 지정 예외는 사용을 확인하지 : 이름이 인수는 정규 표현식 패턴과 일치. 예를 들어, 이름이 밑줄로 시작하는 변수입니다.</target>
        </trans-unit>
        <trans-unit id="6bb74f27a7dcda830e7e3515e710fd44a61861b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bind()&lt;/code&gt; method is used to create functions with specific &lt;code&gt;this&lt;/code&gt; values and, optionally, binds arguments to specific values. When used to specify the value of &lt;code&gt;this&lt;/code&gt;, it's important that the function actually uses &lt;code&gt;this&lt;/code&gt; in its function body. For example:</source>
          <target state="translated">&lt;code&gt;bind()&lt;/code&gt; 메소드에 특정 함수를 생성하는 데 사용 &lt;code&gt;this&lt;/code&gt; 특정 값을 임의로 값 및 바인드 인수. 의 값을 지정하는 데 사용하는 경우 &lt;code&gt;this&lt;/code&gt; ,이 함수가 실제로 사용하는 것이 중요합니다 &lt;code&gt;this&lt;/code&gt; 그 기능 본문에. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="23c983ff96826f2c7de4f17b4756b8bba9663c70" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;block-scoped-var&lt;/code&gt; rule generates warnings when variables are used outside of the block in which they were defined. This emulates C-style block scope.</source>
          <target state="translated">&lt;code&gt;block-scoped-var&lt;/code&gt; 변수들이 정의되어있는 블록의 외부에 사용될 때 규칙 경고를 발생한다. 이것은 C 스타일 블록 범위를 에뮬레이트합니다.</target>
        </trans-unit>
        <trans-unit id="53bdd73b3413849fa66b3556c625138c24847f8f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;break outer&lt;/code&gt; statement ensures that this code will not result in an infinite loop because control is returned to the next statement after the &lt;code&gt;outer&lt;/code&gt; label was applied. If this statement was changed to be just &lt;code&gt;break&lt;/code&gt;, control would flow back to the outer &lt;code&gt;while&lt;/code&gt; statement and an infinite loop would result.</source>
          <target state="translated">&lt;code&gt;break outer&lt;/code&gt; 애프터 컨트롤이 다음 문장에 반환되기 때문에이 코드는 무한 루프가 발생하지 않습니다 문을 보장하지만 &lt;code&gt;outer&lt;/code&gt; 라벨이 적용되었다. 이 명령문이 &lt;code&gt;break&lt;/code&gt; 로 변경 되면 제어는 외부 &lt;code&gt;while&lt;/code&gt; 명령문으로 다시 흐르며 무한 루프가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e35e957bc5c45db7810cd6dc9b85c777f96b5c7a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;browser&lt;/code&gt; environment has many built-in global variables (for example, &lt;code&gt;top&lt;/code&gt;). Some of built-in global variables cannot be redeclared.</source>
          <target state="translated">&lt;code&gt;browser&lt;/code&gt; 환경은 많은 내장되어 있습니다 (예를 들어, 전역 변수 &lt;code&gt;top&lt;/code&gt; ). 내장 전역 변수 중 일부는 다시 선언 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9c91130ea2cd4ecd093fc52993fc6956e053783c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;builtinGlobals&lt;/code&gt; option is &lt;code&gt;false&lt;/code&gt; by default. If it is &lt;code&gt;true&lt;/code&gt;, the rule prevents shadowing of built-in global variables: &lt;code&gt;Object&lt;/code&gt;, &lt;code&gt;Array&lt;/code&gt;, &lt;code&gt;Number&lt;/code&gt;, and so on.</source>
          <target state="translated">&lt;code&gt;builtinGlobals&lt;/code&gt; 의 옵션은 &lt;code&gt;false&lt;/code&gt; 기본적으로. 이 경우 &lt;code&gt;true&lt;/code&gt; , 규칙 방지이의 그림자 내장 전역 변수 : &lt;code&gt;Object&lt;/code&gt; , &lt;code&gt;Array&lt;/code&gt; , &lt;code&gt;Number&lt;/code&gt; 등, 그리고.</target>
        </trans-unit>
        <trans-unit id="2e369ffae5876263cbc79c574ac64d2933232f47" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;call/apply/bind&lt;/code&gt; method of the function is called directly.</source>
          <target state="translated">함수 의 &lt;code&gt;call/apply/bind&lt;/code&gt; 메소드가 직접 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="980901839cc98d894fc636088c44f1085352a1ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;caughtErrors&lt;/code&gt; option is used for &lt;code&gt;catch&lt;/code&gt; block arguments validation.</source>
          <target state="translated">&lt;code&gt;caughtErrors&lt;/code&gt; 의 옵션이 사용됩니다 &lt;code&gt;catch&lt;/code&gt; 블록 인수 확인.</target>
        </trans-unit>
        <trans-unit id="ce4f2ac1f670fbb48541447196e9d9315225fdf2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;caughtErrorsIgnorePattern&lt;/code&gt; option specifies exceptions not to check for usage: catch arguments whose names match a regexp pattern. For example, variables whose names begin with a string 'ignore'.</source>
          <target state="translated">&lt;code&gt;caughtErrorsIgnorePattern&lt;/code&gt; 의 이름이 regexp와 패턴과 일치하는 캐치 인수 : 옵션을 지정 예외는 사용을 확인하지. 예를 들어, 이름이 문자열 'ignore'로 시작하는 변수입니다.</target>
        </trans-unit>
        <trans-unit id="8b0cd31aec7aa29af2f5a3abfb81a77e7a641899" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cli&lt;/code&gt; object</source>
          <target state="translated">&lt;code&gt;cli&lt;/code&gt; 객체</target>
        </trans-unit>
        <trans-unit id="6a94eb63df1e6ac352e9b186b0e6694f22a6e525" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cli&lt;/code&gt; object is the API for the command line interface. Literally, the &lt;code&gt;bin/eslint.js&lt;/code&gt; file simply passes arguments to the &lt;code&gt;cli&lt;/code&gt; object and then sets &lt;code&gt;process.exitCode&lt;/code&gt; to the returned exit code.</source>
          <target state="translated">&lt;code&gt;cli&lt;/code&gt; 개체는 명령 줄 인터페이스에 대한 API이다. 문자 적으로 &lt;code&gt;bin/eslint.js&lt;/code&gt; 파일은 단순히 &lt;code&gt;cli&lt;/code&gt; 객체에 인수를 전달한 다음 &lt;code&gt;process.exitCode&lt;/code&gt; 를 반환 된 종료 코드로 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="cdf300be717f0ef1b9048b6ac9761ea3a6565f01" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;comma-dangle&lt;/code&gt; rule is now more strict by default</source>
          <target state="translated">&lt;code&gt;comma-dangle&lt;/code&gt; 규칙은 기본적으로 더 엄격하다</target>
        </trans-unit>
        <trans-unit id="b16f7c12a77c8c69c18c6cd7c66a8ffbf55f6b7b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;context.getScope()&lt;/code&gt; method now returns more proper scopes</source>
          <target state="translated">&lt;code&gt;context.getScope()&lt;/code&gt; 메소드는 이제 더 적절한 범위를 반환</target>
        </trans-unit>
        <trans-unit id="922325a01666733ad05e06be2a7e01ae31e121a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;context&lt;/code&gt; object contains additional functionality that is helpful for rules to do their jobs. As the name implies, the &lt;code&gt;context&lt;/code&gt; object contains information that is relevant to the context of the rule. The &lt;code&gt;context&lt;/code&gt; object has the following properties:</source>
          <target state="translated">&lt;code&gt;context&lt;/code&gt; 객체는 규칙이 자신의 일을하는 데 도움이되는 추가 기능이 포함되어 있습니다. 이름에서 알 수 있듯이 &lt;code&gt;context&lt;/code&gt; 개체에는 규칙의 컨텍스트와 관련된 정보가 포함됩니다. &lt;code&gt;context&lt;/code&gt; 객체에는 다음과 같은 속성이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="42b1848493047b28e69ceb4cc9991185d8cabd5a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;continue&lt;/code&gt; statement terminates execution of the statements in the current iteration of the current or labeled loop, and continues execution of the loop with the next iteration. When used incorrectly it makes code less testable, less readable and less maintainable. Structured control flow statements such as &lt;code&gt;if&lt;/code&gt; should be used instead.</source>
          <target state="translated">는 &lt;code&gt;continue&lt;/code&gt; 현재 또는 라벨 루프의 현재 반복의 문 문 종료 실행하고 다음 반복으로 루프의 실행을 계속합니다. 잘못 사용하면 코드의 테스트 가능성이 떨어지고 읽기 쉽고 유지 관리가 용이하지 않습니다. &lt;code&gt;if&lt;/code&gt; 와 같은 구조화 된 제어 흐름 문을 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="b85184b855dad09a62d467252a42e39fc124a249" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; Argument</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 인수</target>
        </trans-unit>
        <trans-unit id="78eb3b7cfb10f4790691c3c7134c3e3e580dff94" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;debugger&lt;/code&gt; statement is used to tell the executing JavaScript environment to stop execution and start up a debugger at the current point in the code. This has fallen out of favor as a good practice with the advent of modern debugging and development tools. Production code should definitely not contain &lt;code&gt;debugger&lt;/code&gt;, as it will cause the browser to stop executing code and open an appropriate debugger.</source>
          <target state="translated">&lt;code&gt;debugger&lt;/code&gt; 문이 실행을 중지하고 코드의 현재 위치에서 디버거를 시작하기 위해 실행 자바 스크립트 환경을 이야기하는 데 사용됩니다. 이것은 현대의 디버깅 및 개발 도구의 출현으로 좋은 사례로 선호되지 않았습니다. 프로덕션 코드는 브라우저가 코드 실행을 중지하고 적절한 디버거를 열게되므로 반드시 &lt;code&gt;debugger&lt;/code&gt; 포함하지 않아야합니다 .</target>
        </trans-unit>
        <trans-unit id="64766836102f731f14e0abe461d47d745b9f3795" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;do&lt;/code&gt; class of statements should have the following form:</source>
          <target state="translated">&lt;code&gt;do&lt;/code&gt; 문 클래스는 다음과 같은 형태를 따른다 :</target>
        </trans-unit>
        <trans-unit id="0d9bf1e7a06807b0d9dd6dee731608e28dac63d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ecmaFeatures.modules&lt;/code&gt; flag has been replaced by a &lt;code&gt;sourceType&lt;/code&gt; property under &lt;code&gt;parserOptions&lt;/code&gt; which can be set to &lt;code&gt;&quot;script&quot;&lt;/code&gt; (default) or &lt;code&gt;&quot;module&quot;&lt;/code&gt; for ES6 modules.</source>
          <target state="translated">&lt;code&gt;ecmaFeatures.modules&lt;/code&gt; 의 플래그는 대체되었습니다 &lt;code&gt;sourceType&lt;/code&gt; 에서 부동산 &lt;code&gt;parserOptions&lt;/code&gt; 로 설정 될 수있다 &lt;code&gt;&quot;script&quot;&lt;/code&gt; (기본값) 또는 &lt;code&gt;&quot;module&quot;&lt;/code&gt; ES6 모듈.</target>
        </trans-unit>
        <trans-unit id="114daf2c10a876d1a0119d1127fb9645cebbe320" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ecmaFeatures&lt;/code&gt; property is now under a top-level &lt;code&gt;parserOptions&lt;/code&gt; property.</source>
          <target state="translated">&lt;code&gt;ecmaFeatures&lt;/code&gt; 의 속성은 최상위 중이다 &lt;code&gt;parserOptions&lt;/code&gt; 의 속성입니다.</target>
        </trans-unit>
        <trans-unit id="e77d2b26470f6a64bf6847f6dfa1ccf21481c369" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ecmaVersion&lt;/code&gt; parser option is set to something other than a number, such as the string &lt;code&gt;&quot;2015&quot;&lt;/code&gt;. (Previously, a non-number option would simply be ignored.)</source>
          <target state="translated">&lt;code&gt;ecmaVersion&lt;/code&gt; 의 파서 옵션은 같은 문자열, 숫자 이외로 설정되어 &lt;code&gt;&quot;2015&quot;&lt;/code&gt; . (이전에는 숫자가 아닌 옵션은 무시됩니다.)</target>
        </trans-unit>
        <trans-unit id="e8001be05979a363d68c0b97cd9a4ec677d66ab1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;eslint --init&lt;/code&gt; command can create a configuration so you can extend a popular style guide (for example, &lt;code&gt;eslint-config-standard&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;eslint --init&lt;/code&gt; (예,의 인기있는 스타일 가이드를 확장 할 수 있도록 명령은 구성을 만들 수 있습니다 &lt;code&gt;eslint-config-standard&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="76fc19e1d805a61118a2c1a81a45040f447d9365" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;eslint --init&lt;/code&gt; command can create a configuration so you can extend the recommended rules.</source>
          <target state="translated">&lt;code&gt;eslint --init&lt;/code&gt; 권장되는 규칙을 확장 할 수 있도록 명령은 구성을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4229b7a6eefed924206c9eb78fcfba7b8bfcf1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;eslint-plugin-&lt;/code&gt; prefix can be omitted for non-scoped packages</source>
          <target state="translated">범위가 지정되지 않은 패키지 의 경우 &lt;code&gt;eslint-plugin-&lt;/code&gt; 접두사를 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61707a8cc213e8d436fdfb7b834fbdfa71c295b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;eslint-tester&lt;/code&gt; module, which has long been the primary tester for ESLint rules, has now been moved into the &lt;code&gt;eslint&lt;/code&gt; module. This was the result of a difficult relationship between these two modules that created circular dependencies and was causing a lot of problems in rule tests. Moving the tester into the &lt;code&gt;eslint&lt;/code&gt; module fixed a lot of those issues.</source>
          <target state="translated">&lt;code&gt;eslint-tester&lt;/code&gt; 긴 ESLint 규칙에 대한 기본 테스터왔다 모듈은 이제로 이동 된 &lt;code&gt;eslint&lt;/code&gt; 용 모듈. 이것은 순환 종속성을 생성하고 규칙 테스트에서 많은 문제를 일으키는이 두 모듈 사이의 어려운 관계의 결과였습니다. 테스터를 &lt;code&gt;eslint&lt;/code&gt; 모듈 로 옮기면 많은 문제가 해결되었습니다.</target>
        </trans-unit>
        <trans-unit id="8900c3358f2163358ec0b84e6c957c7b7bbbb087" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;eslint.linter&lt;/code&gt; object (deprecated) is an instance of the &lt;code&gt;Linter&lt;/code&gt; class as defined &lt;a href=&quot;#linter&quot;&gt;above&lt;/a&gt;. &lt;code&gt;eslint.linter&lt;/code&gt; exists for backwards compatibility, but we do not recommend using it because any mutations to it are shared among every module that uses &lt;code&gt;eslint&lt;/code&gt;. Instead, please create your own instance of &lt;code&gt;eslint.Linter&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;eslint.linter&lt;/code&gt; 의 객체 (중단)은의 인스턴스 &lt;code&gt;Linter&lt;/code&gt; 정의 클래스 &lt;a href=&quot;#linter&quot;&gt;상술&lt;/a&gt; . &lt;code&gt;eslint.linter&lt;/code&gt; 는 이전 버전과의 호환성을 위해 존재하지만 &lt;code&gt;eslint&lt;/code&gt; 를 사용하는 모든 모듈간에 돌연변이가 공유되므로이를 사용하지 않는 것이 좋습니다 . 대신 자신 만의 &lt;code&gt;eslint.Linter&lt;/code&gt; 인스턴스를 만드십시오 .</target>
        </trans-unit>
        <trans-unit id="d379a4d77b2607390afe7d33df57381bc7286ee9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;eslint.linter&lt;/code&gt; property is now non-enumerable</source>
          <target state="translated">&lt;code&gt;eslint.linter&lt;/code&gt; 의 속성은 이제 비 열거</target>
        </trans-unit>
        <trans-unit id="a9a4221ba818f86c812a9ad87857f70725c68eaf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;eslintExplicitGlobalComment&lt;/code&gt; scope analysis property has been removed</source>
          <target state="translated">&lt;code&gt;eslintExplicitGlobalComment&lt;/code&gt; 범위 분석 특성이 삭제되었습니다</target>
        </trans-unit>
        <trans-unit id="127d896dfbc583589aff8498ff51854129f845e8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;exceptMethods&lt;/code&gt; option allows you to pass an array of method names for which you would like to ignore warnings. For example, you might have a spec from an external library that requires you to overwrite a method as a regular function (and not as a static method) and does not use &lt;code&gt;this&lt;/code&gt; inside the function body. In this case, you can add that method to ignore in the warnings.</source>
          <target state="translated">&lt;code&gt;exceptMethods&lt;/code&gt; 의 옵션을 사용하면 경고를 무시하고자하는 메소드 이름의 배열을 전달할 수 있습니다. 예를 들어, 정적 라이브러리가 아닌 일반 함수로 메소드를 겹쳐 써야 하며 함수 본문 내에서 &lt;code&gt;this&lt;/code&gt; 사용하지 않는 외부 라이브러리의 스펙이있을 수 있습니다 . 이 경우 경고에서 무시하기 위해 해당 방법을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8077695416ecc34868ba7b9a8633341faa182787" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;exceptions&lt;/code&gt; option allows you to pass an array of methods names you'd like to continue to use in the old style.</source>
          <target state="translated">&lt;code&gt;exceptions&lt;/code&gt; 옵션을 사용하면 기존의 스타일로 계속 사용하고 싶은 방법 이름의 배열을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="252d44a66cbab7b2a0ad26d5562589f321a9a54d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;experimentalObjectRestSpread&lt;/code&gt; option has been deprecated</source>
          <target state="translated">&lt;code&gt;experimentalObjectRestSpread&lt;/code&gt; 의 옵션은 더 이상 사용되지 않습니다</target>
        </trans-unit>
        <trans-unit id="837260e2c2d2bb0e44d170f7a8580e9382461154" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extends&lt;/code&gt; property value can be &lt;code&gt;&quot;eslint:all&quot;&lt;/code&gt; to enable all core rules in the currently installed version of ESLint. The set of core rules can change at any minor or major version of ESLint.</source>
          <target state="translated">(가) &lt;code&gt;extends&lt;/code&gt; 속성 값이 될 수있다 &lt;code&gt;&quot;eslint:all&quot;&lt;/code&gt; ESLint의 현재 설치된 버전의 모든 핵심 규칙을 활성화합니다. 핵심 규칙 세트는 ESLint의 부 버전 또는 주 버전에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b1c15d923b6c7281b7fb8242da0395d1224b9fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extends&lt;/code&gt; property value can be an absolute or relative path to a base &lt;a href=&quot;#using-configuration-files&quot;&gt;configuration file&lt;/a&gt;. ESLint resolves a relative path to a base configuration file relative to the configuration file that uses it.</source>
          <target state="translated">는 &lt;code&gt;extends&lt;/code&gt; 속성 값베이스의 절대 또는 상대 경로 일 수있는 &lt;a href=&quot;#using-configuration-files&quot;&gt;구성 파일&lt;/a&gt; . ESLint는 기본 구성 파일을 사용하는 구성 파일을 기준으로 상대 구성 경로를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="5fa785db2037479c7f03a5b52934be5b58f71e97" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extends&lt;/code&gt; property value can consist of:</source>
          <target state="translated">는 &lt;code&gt;extends&lt;/code&gt; 속성 값을 구성 될 수있다 :</target>
        </trans-unit>
        <trans-unit id="003522290cdebe1b2fbd30a1f0cbdc59c0904961" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extends&lt;/code&gt; property value can omit the &lt;code&gt;eslint-config-&lt;/code&gt; prefix of the package name.</source>
          <target state="translated">는 &lt;code&gt;extends&lt;/code&gt; 생략 할 수 속성 값을 &lt;code&gt;eslint-config-&lt;/code&gt; 패키지 이름의 접두사.</target>
        </trans-unit>
        <trans-unit id="0a2b44eee9bddc2d60e480fea08a5f4ceb3bdae2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extends&lt;/code&gt; property value is either:</source>
          <target state="translated">는 &lt;code&gt;extends&lt;/code&gt; 속성 값 중 하나입니다 :</target>
        </trans-unit>
        <trans-unit id="1cb5e8d9c216034fade7c978ad13805a9c312bc7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fixer&lt;/code&gt; object has the following methods:</source>
          <target state="translated">&lt;code&gt;fixer&lt;/code&gt; 객체는 다음과 같은 방법이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="a3edba7f97a325dd3428ee6498ff770178efa766" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; class of statements should have the following form:</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 진술의 수준은 다음과 같은 형태를 따른다 :</target>
        </trans-unit>
        <trans-unit id="d49f70042d3e336aa930fa3d8a67c5746bfb590f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;global&lt;/code&gt; property in the &lt;code&gt;linter.verify()&lt;/code&gt; API is no longer supported</source>
          <target state="translated">&lt;code&gt;linter.verify()&lt;/code&gt; API 의 &lt;code&gt;global&lt;/code&gt; 특성 이 더 이상 지원되지 않습니다</target>
        </trans-unit>
        <trans-unit id="21aab0ed37e0be4d941cff2e17dc050a87694419" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hoist&lt;/code&gt; option has three settings:</source>
          <target state="translated">&lt;code&gt;hoist&lt;/code&gt; 옵션은 세 가지 설정이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="462609b8b9ea4983f2b2d00bf8596dc0d30d89b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; class of statements should have the following form:</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 문장의 수준은 다음과 같은 형태를 따른다 :</target>
        </trans-unit>
        <trans-unit id="0d8118a2bec951d156bb19df18c746496e386f70" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ignorePattern&lt;/code&gt; object takes a string value, which is used as a regular expression applied to the first word of a comment.</source>
          <target state="translated">&lt;code&gt;ignorePattern&lt;/code&gt; 목적은 일반 식 코멘트의 첫 번째 단어에 적용으로 사용되는 문자열 값을 취한다.</target>
        </trans-unit>
        <trans-unit id="ae972c6712702d048215995c50a75a39891b07a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ignorePatterns&lt;/code&gt; property affects only the directory that the config file placed.</source>
          <target state="translated">&lt;code&gt;ignorePatterns&lt;/code&gt; 의 속성은 설정 파일 배치 만 디렉토리에 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="b5e9061da183286584b4711c4a63bfba8da71be2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ignoreRestSiblings&lt;/code&gt; option is a boolean (default: &lt;code&gt;false&lt;/code&gt;). Using a &lt;a href=&quot;https://github.com/tc39/proposal-object-rest-spread&quot;&gt;Rest Property&lt;/a&gt; it is possible to &quot;omit&quot; properties from an object, but by default the sibling properties are marked as &quot;unused&quot;. With this option enabled the rest property's siblings are ignored.</source>
          <target state="translated">&lt;code&gt;ignoreRestSiblings&lt;/code&gt; 의 옵션은 부울 (: 기본값은 &lt;code&gt;false&lt;/code&gt; ). &lt;a href=&quot;https://github.com/tc39/proposal-object-rest-spread&quot;&gt;나머지 속성을&lt;/a&gt; 사용 하면 개체에서 속성을 &quot;생략&quot;할 수 있지만 기본적으로 형제 속성은 &quot;미사용&quot;으로 표시됩니다. 이 옵션을 사용하면 나머지 속성의 형제가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="85cb7a860cbd820f9d90f12cf28b759ca78ece90" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;indent&lt;/code&gt; rule is more strict</source>
          <target state="translated">&lt;code&gt;indent&lt;/code&gt; 규칙은 더 엄격하다</target>
        </trans-unit>
        <trans-unit id="7da93c489e9178d0f216041fee0bdfd9d92b14f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main&lt;/code&gt; entry should be the JavaScript file implementing your custom formatter.</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 항목은 사용자 정의 포맷터를 구현하는 자바 스크립트 파일이어야합니다.</target>
        </trans-unit>
        <trans-unit id="b638eabe7da26a08a3d704c7037df4934e4bc5a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;max-statements&lt;/code&gt; rule allows you to specify the maximum number of statements allowed in a function.</source>
          <target state="translated">&lt;code&gt;max-statements&lt;/code&gt; 규칙은 함수에 허용되는 문장의 최대 수를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a13c3e797d7391ff2cce66ebe8056f876d975eb2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;message&lt;/code&gt; Object</source>
          <target state="translated">&lt;code&gt;message&lt;/code&gt; 객체</target>
        </trans-unit>
        <trans-unit id="7cfb0e1495e0c320f6699634a8ccde094dae7f26" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;multiLine&lt;/code&gt; and &lt;code&gt;align&lt;/code&gt; options can differ, which allows for fine-tuned control over the &lt;code&gt;key-spacing&lt;/code&gt; of your files. &lt;code&gt;align&lt;/code&gt; will &lt;strong&gt;not&lt;/strong&gt; inherit from &lt;code&gt;multiLine&lt;/code&gt; if &lt;code&gt;align&lt;/code&gt; is configured as an object.</source>
          <target state="translated">&lt;code&gt;multiLine&lt;/code&gt; 및 &lt;code&gt;align&lt;/code&gt; 옵션을 통해 미세 조정 제어 할 수있는 다를 수 있습니다 &lt;code&gt;key-spacing&lt;/code&gt; 파일의. &lt;code&gt;align&lt;/code&gt; 이 객체로 구성된 경우 &lt;code&gt;align&lt;/code&gt; 은 &lt;code&gt;multiLine&lt;/code&gt; 에서 상속 &lt;strong&gt;되지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="d09e48c81deff2fe74829687d8d386203bf2e1ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new Promise&lt;/code&gt; constructor accepts an &lt;em&gt;executor&lt;/em&gt; function as an argument, which has &lt;code&gt;resolve&lt;/code&gt; and &lt;code&gt;reject&lt;/code&gt; parameters that can be used to control the state of the created Promise. For example:</source>
          <target state="translated">&lt;code&gt;new Promise&lt;/code&gt; 생성자는 허용 &lt;em&gt;실행기&lt;/em&gt; 있는 인자로서 기능 &lt;code&gt;resolve&lt;/code&gt; 및 &lt;code&gt;reject&lt;/code&gt; 생성 약속의 상태를 제어하는데 사용될 수있는 매개 변수. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="098f4a5cbac65ca4cffcaba3c9ba560edcebc8fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt; operator in JavaScript creates a new instance of a particular type of object. That type of object is represented by a constructor function. Since constructor functions are just regular functions, the only defining characteristic is that &lt;code&gt;new&lt;/code&gt; is being used as part of the call. Native JavaScript functions begin with an uppercase letter to distinguish those functions that are to be used as constructors from functions that are not. Many style guides recommend following this pattern to more easily determine which functions are to be used as constructors.</source>
          <target state="translated">JavaScript 의 &lt;code&gt;new&lt;/code&gt; 연산자는 특정 유형의 객체의 새 인스턴스를 만듭니다. 해당 유형의 객체는 생성자 함수로 표시됩니다. 생성자 함수는 단지 일반 함수이므로, 정의하는 유일한 특성은 &lt;code&gt;new&lt;/code&gt; 가 호출의 일부로 사용되고 있다는 것 입니다. 기본 JavaScript 함수는 대문자로 시작하여 생성자로 사용되는 함수와 그렇지 않은 함수를 구별합니다. 많은 스타일 가이드는 생성자로 사용할 함수를보다 쉽게 ​​결정하기 위해이 패턴을 따르는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4b9844e9b711c0c78b88e1df4f24b4e7ffcc90b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no-confusing-arrow&lt;/code&gt; rule is now more lenient by default</source>
          <target state="translated">&lt;code&gt;no-confusing-arrow&lt;/code&gt; 규칙은 기본적으로 더 관대</target>
        </trans-unit>
        <trans-unit id="6d1a64da4353dccbefcdf2ee522647ae870b3b07" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no-eq-null&lt;/code&gt; rule aims reduce potential bug and unwanted behavior by ensuring that comparisons to &lt;code&gt;null&lt;/code&gt; only match &lt;code&gt;null&lt;/code&gt;, and not also &lt;code&gt;undefined&lt;/code&gt;. As such it will flag comparisons to null when using &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;no-eq-null&lt;/code&gt; 규칙의 목적은에 비교하도록함으로써 잠재적 인 버그와 원치 않는 행동을 감소 &lt;code&gt;null&lt;/code&gt; 단지 일치 &lt;code&gt;null&lt;/code&gt; , 또한하지 &lt;code&gt;undefined&lt;/code&gt; . 따라서 &lt;code&gt;==&lt;/code&gt; 및 &lt;code&gt;!=&lt;/code&gt; 사용하면 비교를 null로 플래그 지정 합니다.</target>
        </trans-unit>
        <trans-unit id="2cf7599f9ca5e81f4584651a246f272a61b94bee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no-magic-numbers&lt;/code&gt; rule aims to make code more readable and refactoring easier by ensuring that special numbers are declared as constants to make their meaning explicit.</source>
          <target state="translated">는 &lt;code&gt;no-magic-numbers&lt;/code&gt; 더 읽기와 상수가 명시 적 의미를 만들기 위해 같은 특수 번호를 선언하도록함으로써 쉽게 리팩토링 메이크 코드에 목적을 지배하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="584d3863241e3dd7bef2bc890fe46f1e0dacede5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no-multi-spaces&lt;/code&gt; rule is more strict by default</source>
          <target state="translated">&lt;code&gt;no-multi-spaces&lt;/code&gt; 규칙은 기본적으로 더 엄격하다</target>
        </trans-unit>
        <trans-unit id="22f51e16b3d2fa232175e558615aef4ba7d91884" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no-nested-ternary&lt;/code&gt; rule disallows nested ternary expressions.</source>
          <target state="translated">&lt;code&gt;no-nested-ternary&lt;/code&gt; 규칙 것을 허용하지 삼항 표현을 중첩.</target>
        </trans-unit>
        <trans-unit id="116b22d947fe1ce535309217a88923e033d53bfd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no-redeclare&lt;/code&gt; rule is now more strict by default</source>
          <target state="translated">&lt;code&gt;no-redeclare&lt;/code&gt; 규칙은 기본적으로 더 엄격하다</target>
        </trans-unit>
        <trans-unit id="0aeabea2c1edc1a249245bfe09f229e42dd63ee8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;npm run perf&lt;/code&gt; command gives a high-level overview of ESLint running time with default rules (&lt;code&gt;eslint:recommended&lt;/code&gt;) enabled.</source>
          <target state="translated">&lt;code&gt;npm run perf&lt;/code&gt; 명령은 기본 규칙 (와 ESLint 실행 시간에 대한 높은 수준의 개요를 제공합니다 &lt;code&gt;eslint:recommended&lt;/code&gt; 활성화).</target>
        </trans-unit>
        <trans-unit id="02b6ae240bb49fb262b6c6c5aa5ce3a0f704dc54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;onlyEquality&lt;/code&gt; option allows a superset of the exceptions which &lt;code&gt;exceptRange&lt;/code&gt; allows, thus both options are not useful together.</source>
          <target state="translated">&lt;code&gt;onlyEquality&lt;/code&gt; 의 옵션은 예외의 슈퍼 수 있습니다 &lt;code&gt;exceptRange&lt;/code&gt; 은 따라서 두 가지 옵션이 유용 함께하지 않은, 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3664b7a3e8295f10c165e69c19822430ecc4a8ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options&lt;/code&gt; property must be an array of options. This gets passed through to &lt;code&gt;context.options&lt;/code&gt; in the rule.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 속성은 옵션의 배열이어야합니다. 이것은 규칙의 &lt;code&gt;context.options&lt;/code&gt; 로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="138b40a2090025ead37bb2b810503f00fc28051a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;padded-blocks&lt;/code&gt; rule is more strict by default</source>
          <target state="translated">&lt;code&gt;padded-blocks&lt;/code&gt; 규칙은 기본적으로 더 엄격하다</target>
        </trans-unit>
        <trans-unit id="8d637daeacbd8ce09ca4965da79910941e8f067c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parent&lt;/code&gt; property of AST nodes is now set before rules start running</source>
          <target state="translated">규칙이 실행되기 전에 AST 노드 의 &lt;code&gt;parent&lt;/code&gt; 속성이 설정되었습니다.</target>
        </trans-unit>
        <trans-unit id="ac6604963767894ebe97a28abec444c272e929c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parent&lt;/code&gt; property of all nodes must be rewritable. ESLint sets each node's &lt;code&gt;parent&lt;/code&gt; property to its parent node while traversing, before any rules have access to the AST.</source>
          <target state="translated">The &lt;code&gt;parent&lt;/code&gt; property of all nodes must be rewritable. ESLint sets each node's &lt;code&gt;parent&lt;/code&gt; property to its parent node while traversing, before any rules have access to the AST.</target>
        </trans-unit>
        <trans-unit id="853c13962a666c12683d5753aa639223e6ad5a5d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parent&lt;/code&gt; property of all nodes must be rewriteable. ESLint sets each node's &lt;code&gt;parent&lt;/code&gt; property to its parent node while traversing, before any rules have access to the AST.</source>
          <target state="translated">모든 노드 의 &lt;code&gt;parent&lt;/code&gt; 속성은 다시 쓸 수 있어야합니다. ESLint는 규칙이 AST에 액세스하기 전에 순회하는 동안 각 노드의 &lt;code&gt;parent&lt;/code&gt; 속성을 부모 노드로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="944a63b184acd73eda9811179639d595d02aa85d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parseInt()&lt;/code&gt; and &lt;code&gt;Number.parseInt()&lt;/code&gt; functions can be used to turn binary, octal, and hexadecimal strings into integers. As binary, octal, and hexadecimal literals are supported in ES6, this rule encourages use of those numeric literals instead of &lt;code&gt;parseInt()&lt;/code&gt; or &lt;code&gt;Number.parseInt()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;parseInt()&lt;/code&gt; 와 &lt;code&gt;Number.parseInt()&lt;/code&gt; 함수는 이진 정수로, 8 진수 16 진수 문자열을 설정하는데 사용될 수있다. ES6에서는 2 진, 8 진 및 16 진 리터럴이 지원 &lt;code&gt;Number.parseInt()&lt;/code&gt; 규칙은 &lt;code&gt;parseInt()&lt;/code&gt; 또는 Number.parseInt () 대신 숫자 리터럴을 사용하도록 권장합니다 .</target>
        </trans-unit>
        <trans-unit id="a6a8b14c45ea844b14e7b8898d1ed3a957925154" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;plugins&lt;/code&gt;&lt;a href=&quot;#configuring-plugins&quot;&gt;property value&lt;/a&gt; can omit the &lt;code&gt;eslint-plugin-&lt;/code&gt; prefix of the package name.</source>
          <target state="translated">&lt;code&gt;plugins&lt;/code&gt; &lt;a href=&quot;#configuring-plugins&quot;&gt;속성 값은&lt;/a&gt; 생략 할 수 있습니다 &lt;code&gt;eslint-plugin-&lt;/code&gt; 패키지 이름의 접두사.</target>
        </trans-unit>
        <trans-unit id="379ae11932b2a6155c0dd857a96208194dd56ffa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;position&lt;/code&gt; option has two settings:</source>
          <target state="translated">&lt;code&gt;position&lt;/code&gt; 옵션은 두 가지 설정이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="c999b4122281345d94d147575183f7bf02e84b31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;process.env&lt;/code&gt; object in Node.js is used to store deployment/configuration parameters. Littering it through out a project could lead to maintenance issues as it's another kind of global dependency. As such, it could lead to merge conflicts in a multi-user setup and deployment issues in a multi-server setup. Instead, one of the best practices is to define all those parameters in a single configuration/settings file which could be accessed throughout the project.</source>
          <target state="translated">Node.js 의 &lt;code&gt;process.env&lt;/code&gt; 객체는 배포 / 구성 매개 변수를 저장하는 데 사용됩니다. 프로젝트를 통해 쓰레기를 버리는 것은 또 다른 종류의 글로벌 종속성이기 때문에 유지 보수 문제를 일으킬 수 있습니다. 따라서 다중 사용자 설정에서 병합 충돌이 발생하고 다중 서버 설정에서 배포 문제가 발생할 수 있습니다. 대신 모범 사례 중 하나는 프로젝트 전체에서 액세스 할 수있는 단일 구성 / 설정 파일에서 모든 매개 변수를 정의하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="53444e809ed43079efe95348d4604d7a24ea38a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;process.exit()&lt;/code&gt; method in Node.js is used to immediately stop the Node.js process and exit. This is a dangerous operation because it can occur in any method at any point in time, potentially stopping a Node.js application completely when an error occurs. For example:</source>
          <target state="translated">Node.js 의 &lt;code&gt;process.exit()&lt;/code&gt; 메소드는 Node.js 프로세스를 즉시 중지하고 종료하는 데 사용됩니다. 이는 언제라도 어떤 방법 으로든 발생할 수 있으므로 오류가 발생하면 Node.js 응용 프로그램을 완전히 중지시킬 수 있으므로 위험한 작업입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="00253dead4a64430ced775a37d1801dbac8821d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;quotes&lt;/code&gt; rule in this example has one option, &lt;code&gt;&quot;double&quot;&lt;/code&gt; (the &lt;code&gt;2&lt;/code&gt; is the error level). You can retrieve the options for a rule by using &lt;code&gt;context.options&lt;/code&gt;, which is an array containing every configured option for the rule. In this case, &lt;code&gt;context.options[0]&lt;/code&gt; would contain &lt;code&gt;&quot;double&quot;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;quotes&lt;/code&gt; 이 예에서는 규칙은 하나의 옵션이 &lt;code&gt;&quot;double&quot;&lt;/code&gt; 합니다 ( &lt;code&gt;2&lt;/code&gt; 는 오류 수준이다). 규칙에 대해 구성된 모든 옵션을 포함하는 배열 인 &lt;code&gt;context.options&lt;/code&gt; 를 사용하여 규칙에 대한 옵션을 검색 할 수 있습니다 . 이 경우 &lt;code&gt;context.options[0]&lt;/code&gt; 에는 &lt;code&gt;&quot;double&quot;&lt;/code&gt; 이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="15bbabad9361578bf4fae1f2a49b29be60fa376b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;quotes&lt;/code&gt; rule in this example has one option, &lt;code&gt;&quot;double&quot;&lt;/code&gt; (the &lt;code&gt;error&lt;/code&gt; is the error level). You can retrieve the options for a rule by using &lt;code&gt;context.options&lt;/code&gt;, which is an array containing every configured option for the rule. In this case, &lt;code&gt;context.options[0]&lt;/code&gt; would contain &lt;code&gt;&quot;double&quot;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;quotes&lt;/code&gt; 이 예에서는 규칙은 하나의 옵션이 &lt;code&gt;&quot;double&quot;&lt;/code&gt; 합니다 ( &lt;code&gt;error&lt;/code&gt; 오류 수준이다). 규칙에 대해 구성된 모든 옵션을 포함하는 배열 인 &lt;code&gt;context.options&lt;/code&gt; 를 사용하여 규칙에 대한 옵션을 검색 할 수 있습니다 . 이 경우 &lt;code&gt;context.options[0]&lt;/code&gt; 에는 &lt;code&gt;&quot;double&quot;&lt;/code&gt; 이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="472145e67d0e65f7aa06bad378cebc04916b8bba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;range&lt;/code&gt; property contains two indexes in the code, referring to the start and end location of a contiguous section of text that will be replaced. The &lt;code&gt;text&lt;/code&gt; property refers to the text that will replace the given range.</source>
          <target state="translated">&lt;code&gt;range&lt;/code&gt; 속성은 대체됩니다 텍스트의 연속 섹션의 시작과 끝 위치를 참조하여 코드에서 두 개의 인덱스가 포함되어 있습니다. &lt;code&gt;text&lt;/code&gt; 속성은 지정된 범위를 대체 할 텍스트를 말합니다.</target>
        </trans-unit>
        <trans-unit id="e4064f447f590c1765f1771747724c820f183198" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;report&lt;/code&gt; returned from &lt;code&gt;executeOnText()&lt;/code&gt; is in the same format as from &lt;code&gt;executeOnFiles()&lt;/code&gt;, but there is only ever one result in &lt;code&gt;report.results&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;report&lt;/code&gt; 에서 반환 &lt;code&gt;executeOnText()&lt;/code&gt; 에서와 같은 형식으로되어 있습니다 &lt;code&gt;executeOnFiles()&lt;/code&gt; 하지만에서 오직 하나의 결과가 &lt;code&gt;report.results&lt;/code&gt; 은 .</target>
        </trans-unit>
        <trans-unit id="92953a45beba64856673b9e8fbcb1ed126d0847b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;require&lt;/code&gt; function is used to include modules that exist in separate files, such as:</source>
          <target state="translated">&lt;code&gt;require&lt;/code&gt; 기능과 같은 별도의 파일로 존재하는 모듈을 포함하는 데 사용된다 :</target>
        </trans-unit>
        <trans-unit id="064be5c0f666fc3e35b5524048c68a20f53a49bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;result&lt;/code&gt; Object</source>
          <target state="translated">&lt;code&gt;result&lt;/code&gt; 객체</target>
        </trans-unit>
        <trans-unit id="9af8b29a9523a61b024585850f17334d070e6e12" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;results&lt;/code&gt; Object</source>
          <target state="translated">&lt;code&gt;results&lt;/code&gt; 객체</target>
        </trans-unit>
        <trans-unit id="61d30c932bc83cd2faa8787d31852a2a495de05f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;results&lt;/code&gt; object passed into a formatter is an array of objects containing the lint results for individual files. Here's some example output:</source>
          <target state="translated">포맷터로 전달 된 &lt;code&gt;results&lt;/code&gt; 객체는 개별 파일에 대한 린트 결과를 포함하는 객체의 배열입니다. 다음은 예제 출력입니다.</target>
        </trans-unit>
        <trans-unit id="3993cb0067ab7703186a7c2f2b6970449e1be544" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rules&lt;/code&gt; property can do any of the following to extend (or override) the set of rules:</source>
          <target state="translated">&lt;code&gt;rules&lt;/code&gt; 속성은 규칙의 집합을 확장 (또는 대체)하려면 다음을 수행 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="561e9293e5a8d3ad27376df8faff3ae931698040" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;source&lt;/code&gt; property is no longer available on individual linting messages</source>
          <target state="translated">&lt;code&gt;source&lt;/code&gt; 속성은 더 이상 개별 linting 메시지에 사용할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="0a93eec94b022c4aa2a02db660060ca362fa877f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sourceType: &quot;module&quot;&lt;/code&gt; parser option is set while &lt;code&gt;ecmaVersion&lt;/code&gt; is set to &lt;code&gt;5&lt;/code&gt; or left unspecified. (Previously, setting &lt;code&gt;sourceType: &quot;module&quot;&lt;/code&gt; would implicitly cause &lt;code&gt;ecmaVersion&lt;/code&gt; to be set to a minimum of 2015, which could be surprising.)</source>
          <target state="translated">&lt;code&gt;sourceType: &quot;module&quot;&lt;/code&gt; 동안 파서 옵션이 설정되어 &lt;code&gt;ecmaVersion&lt;/code&gt; 이 설정되어 &lt;code&gt;5&lt;/code&gt; 또는 지정되지 않은 상태. 이전에는 &lt;code&gt;sourceType: &quot;module&quot;&lt;/code&gt; 을 설정 하면 &lt;code&gt;ecmaVersion&lt;/code&gt; 이 최소 2015로 설정되어 놀라운 결과가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c9529163ca9cdfc78596b70a0088a17d7d3a0b6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sourceType&lt;/code&gt; is set to anything other than &lt;code&gt;&quot;script&quot;&lt;/code&gt; or &lt;code&gt;&quot;module&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sourceType&lt;/code&gt; 이외로 설정 &lt;code&gt;&quot;script&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;module&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="77552117314df4545a21208d082a3e6e878f860f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;space-before-function-paren&lt;/code&gt; rule is more strict by default</source>
          <target state="translated">&lt;code&gt;space-before-function-paren&lt;/code&gt; 규칙은 기본적으로 더 엄격하다</target>
        </trans-unit>
        <trans-unit id="3f8f7815159b1b5e0f229864128c1f7bd11839da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;switch&lt;/code&gt; class of statements should have the following form:</source>
          <target state="translated">&lt;code&gt;switch&lt;/code&gt; 문 클래스는 다음과 같은 형태를 따른다 :</target>
        </trans-unit>
        <trans-unit id="e7bd19d734e1f9c5b8f9f98d650cecfc8c20f132" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;switch&lt;/code&gt; statement in JavaScript is one of the more error-prone constructs of the language thanks in part to the ability to &quot;fall through&quot; from one &lt;code&gt;case&lt;/code&gt; to the next. For example:</source>
          <target state="translated">&lt;code&gt;switch&lt;/code&gt; 자바 스크립트의 문은 하나의 &quot;를 통해 가을&quot;에 능력 부분에 언어 덕분에 더 많은 오류가 발생하기 쉬운 구조 중 하나 인 &lt;code&gt;case&lt;/code&gt; 다음에. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b828067e8b794059a7226d1fb4af5dcfec1299b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;switch&lt;/code&gt; statement internally uses the &lt;code&gt;===&lt;/code&gt; comparison to match the expression's value to a case clause. Therefore, it can never match &lt;code&gt;case NaN&lt;/code&gt;. Also, &lt;code&gt;switch(NaN)&lt;/code&gt; can never match a case clause.</source>
          <target state="translated">&lt;code&gt;switch&lt;/code&gt; 문은 내부적으로 사용 &lt;code&gt;===&lt;/code&gt; 경우 절에 표현의 값과 일치하도록 비교. 따라서 &lt;code&gt;case NaN&lt;/code&gt; 과 절대 일치 할 수 없습니다 . 또한 &lt;code&gt;switch(NaN)&lt;/code&gt; 는 case 절과 절대 일치 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2ada90da9d605eb89fdcd67423cc995f53e41596" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try&lt;/code&gt; class of statements should have the following form:</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt; 문 클래스는 다음과 같은 형태를 따른다 :</target>
        </trans-unit>
        <trans-unit id="8692ce1aa1a507fdbc0506510178169257caaf18" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;u&lt;/code&gt; flag disables the recovering logic Annex B defined. As a result, you can find errors early. This is similar to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode&quot;&gt;the strict mode&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;u&lt;/code&gt; 플래그는 부록 B는 정의 된 복구 논리 비활성화. 결과적으로 오류를 조기에 찾을 수 있습니다. 이것은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode&quot;&gt;엄격 모드&lt;/a&gt; 와 유사 합니다 .</target>
        </trans-unit>
        <trans-unit id="c13131f24eb9329164eba24a2cd91b75577b1971" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;undefined&lt;/code&gt; variable in JavaScript is actually a property of the global object. As such, in ECMAScript 3 it was possible to overwrite the value of &lt;code&gt;undefined&lt;/code&gt;. While ECMAScript 5 disallows overwriting &lt;code&gt;undefined&lt;/code&gt;, it's still possible to shadow &lt;code&gt;undefined&lt;/code&gt;, such as:</source>
          <target state="translated">&lt;code&gt;undefined&lt;/code&gt; 자바 스크립트의 변수는 실제로는 전역 객체의 속성입니다. 따라서 ECMAScript 3에서는 &lt;code&gt;undefined&lt;/code&gt; 값을 덮어 쓸 수있었습니다 . ECMAScript 5는 &lt;code&gt;undefined&lt;/code&gt; 덮어 쓰기를 허용하지 않지만 다음과 같이 &lt;code&gt;undefined&lt;/code&gt; 를 섀도 잉 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e4e9951e2f561acaf841dbfd8453226510314be0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vars-on-top&lt;/code&gt; rule generates warnings when variable declarations are not used serially at the top of a function scope or the top of a program. By default variable declarations are always moved (&amp;ldquo;hoisted&amp;rdquo;) invisibly to the top of their containing scope by the JavaScript interpreter. This rule forces the programmer to represent that behavior by manually moving the variable declaration to the top of its containing scope.</source>
          <target state="translated">&lt;code&gt;vars-on-top&lt;/code&gt; 변수 선언이 함수 영역의 위쪽 또는 프로그램의 상단에 연속적으로 사용하지 않을 때 규칙 경고를 발생한다. 기본적으로 변수 선언은 JavaScript 인터프리터에 의해 항상 포함 범위의 상단으로 이동합니다 ( &quot;호이 스팅&quot;). 이 규칙은 프로그래머가 변수 선언을 포함하는 범위의 맨 위로 수동으로 이동하여 해당 동작을 나타내도록합니다.</target>
        </trans-unit>
        <trans-unit id="8437526de99e51c9af62b182483b3c46ca377dbd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vars&lt;/code&gt; option has two settings:</source>
          <target state="translated">&lt;code&gt;vars&lt;/code&gt; 옵션은 두 가지 설정이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="7f313683e74a50e68d4d012882437f3a941bbebc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;varsIgnorePattern&lt;/code&gt; option specifies exceptions not to check for usage: variables whose names match a regexp pattern. For example, variables whose names contain &lt;code&gt;ignored&lt;/code&gt; or &lt;code&gt;Ignored&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;varsIgnorePattern&lt;/code&gt; 의 옵션을 지정 예외는 사용을 확인하지 : 이름이 변수는 정규 표현식 패턴과 일치. 예를 들어, 이름이 변수는 포함 &lt;code&gt;ignored&lt;/code&gt; 하거나 &lt;code&gt;Ignored&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c6c8741b7358a7fc6ab1d9e9c87df7567465e2dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;verify()&lt;/code&gt; method returns an array of objects containing information about the linting warnings and errors. Here's an example:</source>
          <target state="translated">&lt;code&gt;verify()&lt;/code&gt; 메소드는 linting 경고와 에러에 대한 정보를 포함하는 오브젝트의 배열을 반환한다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8f646bffb41dff01a7acc0aab19c45366759c6bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;void&lt;/code&gt; operator takes an operand and returns &lt;code&gt;undefined&lt;/code&gt;: &lt;code&gt;void expression&lt;/code&gt; will evaluate &lt;code&gt;expression&lt;/code&gt; and return &lt;code&gt;undefined&lt;/code&gt;. It can be used to ignore any side effects &lt;code&gt;expression&lt;/code&gt; may produce:</source>
          <target state="translated">&lt;code&gt;void&lt;/code&gt; 연산자는 피연산자 반환합니다 &lt;code&gt;undefined&lt;/code&gt; : &lt;code&gt;void expression&lt;/code&gt; 평가합니다 &lt;code&gt;expression&lt;/code&gt; 반환 &lt;code&gt;undefined&lt;/code&gt; . &lt;code&gt;expression&lt;/code&gt; 발생할 수 있는 부작용을 무시하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2556ce629f24ecc77f8ee75b29af595f5d1ce4bd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;while&lt;/code&gt; class of statements should have the following form:</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; 진술의 클래스는 다음과 같은 형태를 따른다 :</target>
        </trans-unit>
        <trans-unit id="16267e1a7f6497f96f435d3ed8e9d95c9f05b4e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;with&lt;/code&gt; statement is potentially problematic because it adds members of an object to the current scope, making it impossible to tell what a variable inside the block actually refers to.</source>
          <target state="translated">&lt;code&gt;with&lt;/code&gt; 그것이 불가능 블록 내부의 변수가 사실에 의미 무슨 얘기하고, 현재 범위에 개체의 멤버를 추가하기 때문에 문은 잠재적으로 문제가있다.</target>
        </trans-unit>
        <trans-unit id="23d60138df9b187d83c9c312e2d8240dbd86a484" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;one true brace style&lt;/em&gt; is one of the most common brace styles in JavaScript, in which the opening brace of a block is placed on the same line as its corresponding statement or declaration. For example:</source>
          <target state="translated">&lt;em&gt;진정한 중괄호 스타일&lt;/em&gt; 블록의 여는 중괄호가 그에 대응하는 문 또는 선언과 같은 줄에 배치되는 자바 스크립트에서 가장 흔한 중괄호 스타일 중 하나입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="318db8bc3442a0b948f2278731ddfaa2b3371483" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;upstream source&lt;/em&gt; is the main ESLint repository that active development happens on. While you won't have push access to upstream, you will have pull access, allowing you to pull in the latest code whenever you want.</source>
          <target state="translated">&lt;em&gt;업스트림 소스는&lt;/em&gt; 활성 개발에서 발생하는 주요 ESLint 저장소입니다. 업스트림에 대한 푸시 액세스 권한은 없지만 풀 액세스 권한이 있으므로 원하는 때마다 최신 코드를 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="985796a6dfb39061b3806f06ead742513b9f7132" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;upstream source&lt;/em&gt; is the main ESLint repository where active development happens. While you won't have push access to upstream, you will have pull access, allowing you to pull in the latest code whenever you want.</source>
          <target state="translated">The &lt;em&gt;upstream source&lt;/em&gt; is the main ESLint repository where active development happens. While you won't have push access to upstream, you will have pull access, allowing you to pull in the latest code whenever you want.</target>
        </trans-unit>
        <trans-unit id="00a652484a4e470b827e739fbc799706911bd125" translate="yes" xml:space="preserve">
          <source>The AST specification</source>
          <target state="translated">AST 사양</target>
        </trans-unit>
        <trans-unit id="e60cbbce8f620754c9d5e236855c0dfac9399492" translate="yes" xml:space="preserve">
          <source>The AST that custom parsers should create is based on &lt;a href=&quot;https://github.com/estree/estree&quot;&gt;ESTree&lt;/a&gt;. The AST requires some additional properties about detail information of the source code.</source>
          <target state="translated">사용자 정의 파서가 작성해야하는 AST는 &lt;a href=&quot;https://github.com/estree/estree&quot;&gt;ESTree를&lt;/a&gt; 기반으로 합니다 . AST에는 소스 코드의 세부 정보에 대한 몇 가지 추가 속성이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="d12093d685b556a69445173fd5520486f1407941" translate="yes" xml:space="preserve">
          <source>The Art Of Node: Callbacks</source>
          <target state="translated">노드의 기술 : 콜백</target>
        </trans-unit>
        <trans-unit id="dc42f36cf4efb4177d2faa05bda904369e189f7a" translate="yes" xml:space="preserve">
          <source>The Atomics object does not have a &lt;code&gt;[[Call]]&lt;/code&gt; internal method; it is not possible to invoke the Atomics object as a function.</source>
          <target state="translated">Atomics 객체에는 &lt;code&gt;[[Call]]&lt;/code&gt; 내부 메소드가 없습니다. Atomics 객체를 함수로 호출 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="121e8d7f53d94f39796abb445eea1ec6c84df947" translate="yes" xml:space="preserve">
          <source>The Comma Style rule enforces styles for comma-separated lists. There are two comma styles primarily used in JavaScript:</source>
          <target state="translated">쉼표 스타일 규칙은 쉼표로 구분 된 목록에 스타일을 적용합니다. JavaScript에서 주로 사용되는 두 가지 쉼표 스타일이 있습니다.</target>
        </trans-unit>
        <trans-unit id="751c7e36741c66d3a05895481f8942a38ca2dce1" translate="yes" xml:space="preserve">
          <source>The Context Object</source>
          <target state="translated">컨텍스트 객체</target>
        </trans-unit>
        <trans-unit id="699ac6d6b4ec2baa85b4732c274fadb3ca039ae9" translate="yes" xml:space="preserve">
          <source>The ECMAScript 5 Annotated Specification - Strict Mode</source>
          <target state="translated">ECMAScript 5 주석 사양-엄격한 모드</target>
        </trans-unit>
        <trans-unit id="80e0be2b0df7dc0f52165f27603e2898ae8a5e99" translate="yes" xml:space="preserve">
          <source>The ES6 Reflect API comes with a handful of methods which somewhat deprecate methods on old constructors:</source>
          <target state="translated">ES6 Reflect API는 이전 생성자의 메소드를 다소 사용하지 않는 몇 가지 메소드를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="66003f739f69d29de4ae86e20e78496ebb3153ae" translate="yes" xml:space="preserve">
          <source>The ESLint directory and file structure is as follows:</source>
          <target state="translated">ESLint 디렉토리 및 파일 구조는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d93e8b36b02e3c814ab20860021ac1e2f00ac494" translate="yes" xml:space="preserve">
          <source>The ESLint team doesn't implement new rules that are suggested by users because we have a limited number of people and need to focus on the overall roadmap. Once a rule is accepted, you are responsible for implementing and documenting the rule. You may, alternately, recruit another person to help you implement the rule. The ESLint team member who championed the rule is your resource to help guide you through the rest of this process.</source>
          <target state="translated">ESLint 팀은 인원이 적고 전체 로드맵에 집중해야하기 때문에 사용자가 제안한 새로운 규칙을 구현하지 않습니다. 규칙이 수락되면 규칙을 구현하고 문서화해야합니다. 교대로 규칙을 이행하는 데 도움이되도록 다른 사람을 모집 할 수도 있습니다. 규칙을 준수한 ESLint 팀원은이 프로세스의 나머지 단계를 안내하는 데 도움이되는 리소스입니다.</target>
        </trans-unit>
        <trans-unit id="0c711d16f14ea7343d52f05830b40ccdb9522bc8" translate="yes" xml:space="preserve">
          <source>The ESLint team doesn't implement rule changes that are suggested by users because we have a limited number of people and need to focus on the overall roadmap. Once a rule change is accepted, you are responsible for implementing and documenting it. You may, alternately, recruit another person to help you. The ESLint team member who championed the rule is your resource to help guide you through the rest of this process.</source>
          <target state="translated">ESLint 팀은 인원이 적고 전체 로드맵에 집중해야하기 때문에 사용자가 제안한 규칙 변경을 구현하지 않습니다. 규칙 변경이 수락되면이를 구현하고 문서화해야합니다. 또는 다른 사람을 고용하여 도움을 줄 수도 있습니다. 규칙을 준수한 ESLint 팀원은이 프로세스의 나머지 단계를 안내하는 데 도움이되는 리소스입니다.</target>
        </trans-unit>
        <trans-unit id="aeda0c340295fff5de3b84af83b961b23c1f657b" translate="yes" xml:space="preserve">
          <source>The ESLint team is committed to making upgrading as easy and painless as possible. This section outlines the guidelines the team has set in place for the deprecation of rules in future releases.</source>
          <target state="translated">ESLint 팀은 업그레이드를 최대한 쉽고 쉽게 수행 할 수 있도록 노력하고 있습니다. 이 섹션에서는 팀에서 향후 릴리스에서 더 이상 사용되지 않는 규칙에 대해 설정 한 지침을 간략하게 설명합니다.</target>
        </trans-unit>
        <trans-unit id="42ccbdbc3911d666627517f8ffa3964275678b01" translate="yes" xml:space="preserve">
          <source>The ESLint team is committed to making upgrading as easy and painless as possible. To that end, the team has agreed upon the following set of guidelines for deprecating rules in the future. The goal of these guidelines is to allow for improvements and changes to be made without breaking existing configurations.</source>
          <target state="translated">ESLint 팀은 업그레이드를 최대한 쉽고 쉽게 수행 할 수 있도록 노력하고 있습니다. 이를 위해 팀은 향후 규칙을 폐기하기위한 다음과 같은 지침에 동의했습니다. 이 지침의 목표는 기존 구성을 손상시키지 않고 개선 및 변경이 가능하도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d4e733f98b935c588d211926e08fdfd98589d4ae" translate="yes" xml:space="preserve">
          <source>The JSCS &lt;code&gt;--auto-configure&lt;/code&gt; option created a configuration based on what it found in a given file:</source>
          <target state="translated">JSCS &lt;code&gt;--auto-configure&lt;/code&gt; 옵션은 주어진 파일에서 찾은 것을 기반으로 구성 을 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="fa1c39fed1338615abafccd715f9a9ceec0208c2" translate="yes" xml:space="preserve">
          <source>The Math Object</source>
          <target state="translated">수학 객체</target>
        </trans-unit>
        <trans-unit id="9459a63048e2fc499f7aeacaa3d20ab484e34e90" translate="yes" xml:space="preserve">
          <source>The Math object does not have a &lt;code&gt;[[Call]]&lt;/code&gt; internal property; it is not possible to invoke the Math object as a function.</source>
          <target state="translated">Math 객체에는 &lt;code&gt;[[Call]]&lt;/code&gt; 내부 속성이 없습니다. Math 객체를 함수로 호출 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="03344790500f2127bf5b89f81cc0b7f1bd8cbe99" translate="yes" xml:space="preserve">
          <source>The Reflect object also does not have a &lt;code&gt;[[Call]]&lt;/code&gt; internal method; it is not possible to invoke the Reflect object as a function.</source>
          <target state="translated">Reflect 객체에는 또한 &lt;code&gt;[[Call]]&lt;/code&gt; 내부 메소드가 없습니다. Reflect 객체를 함수로 호출 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d8e01d191666fc3fab613c0e7605b0dd8117adb5" translate="yes" xml:space="preserve">
          <source>The Unicode Byte Order Mark (BOM) is used to specify whether code units are big endian or little endian. That is, whether the most significant or least significant bytes come first. UTF-8 does not require a BOM because byte ordering does not matter when characters are a single byte. Since UTF-8 is the dominant encoding of the web, we make &lt;code&gt;&quot;never&quot;&lt;/code&gt; the default option.</source>
          <target state="translated">BOM (Unicode Byte Order Mark)은 코드 단위가 빅 엔디안인지 리틀 엔디안인지를 지정하는 데 사용됩니다. 즉, 최상위 바이트 또는 최하위 바이트가 먼저 오는지 여부입니다. 문자가 단일 바이트 인 경우 바이트 순서는 중요하지 않으므로 UTF-8에는 BOM이 필요하지 않습니다. UTF-8은 웹의 주요 인코딩이므로 &lt;code&gt;&quot;never&quot;&lt;/code&gt; 를 기본 옵션으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="dee0f2bfcb123659c532724653e8c4e345e84a42" translate="yes" xml:space="preserve">
          <source>The `--fix` option on the &lt;a href=&quot;../user-guide/command-line-interface#fix&quot;&gt;command line&lt;/a&gt; automatically fixes problems (currently mostly whitespace) reported by rules which have a wrench  below.</source>
          <target state="translated">&lt;a href=&quot;../user-guide/command-line-interface#fix&quot;&gt;명령 행&lt;/a&gt; 의`--fix` 옵션은 아래에 렌치가있는 규칙에 의해보고 된 문제 (현재는 대부분 공백)를 자동으로 수정합니다.</target>
        </trans-unit>
        <trans-unit id="db8728aed09dfa6de429370be79c24bb69a35744" translate="yes" xml:space="preserve">
          <source>The above can be rewritten as the following to improve readability and more clearly delineate the operands:</source>
          <target state="translated">위의 내용은 가독성을 높이고 피연산자를보다 명확하게 설명하기 위해 다음과 같이 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65f3cb6e1b55fcacecc756bb976bc88a3674a7e6" translate="yes" xml:space="preserve">
          <source>The above methods return a &lt;code&gt;fixing&lt;/code&gt; object. The &lt;code&gt;fix()&lt;/code&gt; function can return the following values:</source>
          <target state="translated">위의 메소드는 &lt;code&gt;fixing&lt;/code&gt; 객체를 반환 합니다. &lt;code&gt;fix()&lt;/code&gt; 함수는 다음과 같은 값들을 반환 할 수있다 :</target>
        </trans-unit>
        <trans-unit id="9907806cacfab0036e1c3174ec8f1e3740b6c513" translate="yes" xml:space="preserve">
          <source>The absolute path to the file of this result. This is the string &lt;code&gt;&quot;&amp;lt;text&amp;gt;&quot;&lt;/code&gt; if the file path is unknown (when you didn't pass the &lt;code&gt;options.filePath&lt;/code&gt; option to the &lt;a href=&quot;#-eslintlinttextcode-options&quot;&gt;&lt;code&gt;eslint.lintText()&lt;/code&gt;&lt;/a&gt; method).</source>
          <target state="translated">The absolute path to the file of this result. This is the string &lt;code&gt;&quot;&amp;lt;text&amp;gt;&quot;&lt;/code&gt; if the file path is unknown (when you didn't pass the &lt;code&gt;options.filePath&lt;/code&gt; option to the &lt;a href=&quot;#-eslintlinttextcode-options&quot;&gt; &lt;code&gt;eslint.lintText()&lt;/code&gt; &lt;/a&gt; method).</target>
        </trans-unit>
        <trans-unit id="534b2fcf7f67846ee9ee4948ebf52bf0568bd28a" translate="yes" xml:space="preserve">
          <source>The array can contain values of &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;string&lt;/code&gt; types. If it's a string, the text must be parsed as &lt;code&gt;bigint&lt;/code&gt; literal (e.g., &lt;code&gt;&quot;100n&quot;&lt;/code&gt;).</source>
          <target state="translated">The array can contain values of &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;string&lt;/code&gt; types. If it's a string, the text must be parsed as &lt;code&gt;bigint&lt;/code&gt; literal (e.g., &lt;code&gt;&quot;100n&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b83b06a5a4117b1ebec2ee0a831243105811ba6c" translate="yes" xml:space="preserve">
          <source>The array of &lt;a href=&quot;#-lintmessage-type&quot;&gt;LintMessage&lt;/a&gt; objects.</source>
          <target state="translated">The array of &lt;a href=&quot;#-lintmessage-type&quot;&gt;LintMessage&lt;/a&gt; objects.</target>
        </trans-unit>
        <trans-unit id="0c94f2b50ef7b0d53ba00f8a03e35b8008133138" translate="yes" xml:space="preserve">
          <source>The basic pattern for a rule unit test file is:</source>
          <target state="translated">규칙 단위 테스트 파일의 기본 패턴은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="56d7ca1af2103271f042bd642392c591643ab810" translate="yes" xml:space="preserve">
          <source>The best practice is to always use a function for the first argument of &lt;code&gt;setTimeout()&lt;/code&gt; and &lt;code&gt;setInterval()&lt;/code&gt; (and avoid &lt;code&gt;execScript()&lt;/code&gt;).</source>
          <target state="translated">가장 좋은 방법은 항상 &lt;code&gt;setTimeout()&lt;/code&gt; 및 &lt;code&gt;setInterval()&lt;/code&gt; 의 첫 번째 인수에 대해 함수를 사용하는 것입니다 ( &lt;code&gt;execScript()&lt;/code&gt; 피하십시오 ).</target>
        </trans-unit>
        <trans-unit id="1e8c340ffa3f95f2957d6bb3facc83797eb47d1e" translate="yes" xml:space="preserve">
          <source>The built-in formatter options are:</source>
          <target state="translated">내장 포맷터 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f4a074b29cc31436f926afa21bd394791fa680f4" translate="yes" xml:space="preserve">
          <source>The callback pattern is at the heart of most I/O and event-driven programming in JavaScript.</source>
          <target state="translated">콜백 패턴은 JavaScript에서 대부분의 I / O 및 이벤트 중심 프로그래밍의 핵심입니다.</target>
        </trans-unit>
        <trans-unit id="17cf8e65252c53144326fa3b3cb3dee6a9c49a73" translate="yes" xml:space="preserve">
          <source>The change introduces no functional regression. Be sure to run &lt;code&gt;npm test&lt;/code&gt; to verify your changes before submitting a pull request.</source>
          <target state="translated">이 변경으로 인해 기능적 회귀가 발생하지 않습니다. 실행해야합니다 &lt;code&gt;npm test&lt;/code&gt; 끌어 오기 요청을 제출하기 전에 변경 사항을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="95b1da556ce89be353ded0ac57710b104d6f438e" translate="yes" xml:space="preserve">
          <source>The closing brace should be on a separate line.</source>
          <target state="translated">닫는 버팀대는 별도의 줄에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="0e877e0656f0ec69724c1b6cc3a12731f64fac75" translate="yes" xml:space="preserve">
          <source>The code above creates an object with just a setter for the property &lt;code&gt;&quot;a&quot;&lt;/code&gt;.</source>
          <target state="translated">위의 코드는 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 속성에 대한 setter 만있는 객체를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="7d7fe0fd83bc9845d159f7bbddda58e021a2af8e" translate="yes" xml:space="preserve">
          <source>The code can be rewritten as:</source>
          <target state="translated">코드는 다음과 같이 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eae223ac7cf3bcd6d761f22884ef878f4080872a" translate="yes" xml:space="preserve">
          <source>The code might be mistaken for an error.</source>
          <target state="translated">코드가 오류로 오인되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07b81fa2d7c3787fd397d4cedde653ceddf32951" translate="yes" xml:space="preserve">
          <source>The combining characters are characters which belong to one of &lt;code&gt;Mc&lt;/code&gt;, &lt;code&gt;Me&lt;/code&gt;, and &lt;code&gt;Mn&lt;/code&gt;&lt;a href=&quot;http://www.unicode.org/L2/L1999/UnicodeData.html#General%20Category&quot;&gt;Unicode general categories&lt;/a&gt;.</source>
          <target state="translated">결합 문자는 &lt;code&gt;Mc&lt;/code&gt; , &lt;code&gt;Me&lt;/code&gt; 및 &lt;code&gt;Mn&lt;/code&gt; &lt;a href=&quot;http://www.unicode.org/L2/L1999/UnicodeData.html#General%20Category&quot;&gt;Unicode 일반 범주&lt;/a&gt; 중 하나에 속하는 문자입니다 .</target>
        </trans-unit>
        <trans-unit id="73d750e0d0367037fdad99a42bc958f0afea170d" translate="yes" xml:space="preserve">
          <source>The comma and any whitespace that delimit property specifications are not considered parts of them. Therefore, the rule permits both of these formats:</source>
          <target state="translated">속성 사양을 구분하는 쉼표 및 공백은 그 일부로 간주되지 않습니다. 따라서이 규칙은 다음 두 형식을 모두 허용합니다.</target>
        </trans-unit>
        <trans-unit id="d9368f1df7787717cd62dddc2cb7c148f9058bfd" translate="yes" xml:space="preserve">
          <source>The comma operator includes multiple expressions where only one is expected. It evaluates each operand from left to right and returns the value of the last operand. However, this frequently obscures side effects, and its use is often an accident. Here are some examples of sequences:</source>
          <target state="translated">쉼표 연산자에는 하나만 필요한 여러식이 포함됩니다. 각 피연산자를 왼쪽에서 오른쪽으로 평가하고 마지막 피연산자의 값을 반환합니다. 그러나 이것은 부작용을 자주 가려서 사용하는 경우가 종종 있습니다. 시퀀스의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6cbddd96542ae6a1209e95d3af05dcfc89e192c0" translate="yes" xml:space="preserve">
          <source>The command line utility has several options. You can view the options by running &lt;code&gt;eslint -h&lt;/code&gt;.</source>
          <target state="translated">명령 행 유틸리티에는 몇 가지 옵션이 있습니다. &lt;code&gt;eslint -h&lt;/code&gt; 를 실행하여 옵션을 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9c80af650686399cb1e0e7040218608587eb5be3" translate="yes" xml:space="preserve">
          <source>The commit message format is important because these messages are used to create a changelog for each release. The tag and issue number help to create more consistent and useful changelogs.</source>
          <target state="translated">커밋 메시지 형식은 이러한 메시지가 각 릴리스에 대한 변경 로그를 작성하는 데 사용되므로 중요합니다. 태그 및 이슈 번호는보다 일관되고 유용한 변경 로그를 작성하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="a8123064f7d126e4a3b589e9af343947dfe7c445" translate="yes" xml:space="preserve">
          <source>The commit message is properly formatted.</source>
          <target state="translated">커밋 메시지가 올바르게 형식화되었습니다.</target>
        </trans-unit>
        <trans-unit id="e4677fbe3218552fdaa136e42baa9d0c902d41ca" translate="yes" xml:space="preserve">
          <source>The common case of using &lt;code&gt;void&lt;/code&gt; operator is to get a &quot;pure&quot; &lt;code&gt;undefined&lt;/code&gt; value as prior to ES5 the &lt;code&gt;undefined&lt;/code&gt; variable was mutable:</source>
          <target state="translated">&lt;code&gt;void&lt;/code&gt; 연산자 를 사용하는 일반적인 경우는 ES5 이전에 &lt;code&gt;undefined&lt;/code&gt; 변수가 변경 가능한 &quot;순수한&quot; &lt;code&gt;undefined&lt;/code&gt; 값 을 얻는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="affdad1a3137988828bd199a2283a60df1bc5075" translate="yes" xml:space="preserve">
          <source>The complete configuration hierarchy, from highest precedence to lowest precedence, is as follows:</source>
          <target state="translated">가장 높은 우선 순위에서 가장 낮은 우선 순위까지 ​​전체 구성 계층 구조는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7505181a37b9fb762478197cf4096ed5622b8d1b" translate="yes" xml:space="preserve">
          <source>The config in &lt;code&gt;app/.eslintrc.json&lt;/code&gt; defines the glob pattern &lt;code&gt;**/*Spec.js&lt;/code&gt;. This pattern is relative to the base directory of &lt;code&gt;app/.eslintrc.json&lt;/code&gt;. So, this pattern would match &lt;code&gt;app/lib/fooSpec.js&lt;/code&gt; and &lt;code&gt;app/components/barSpec.js&lt;/code&gt; but &lt;strong&gt;NOT&lt;/strong&gt;&lt;code&gt;server/serverSpec.js&lt;/code&gt;. If you defined the same pattern in the &lt;code&gt;.eslintrc.json&lt;/code&gt; file within in the &lt;code&gt;project-root&lt;/code&gt; folder, it would match all three of the &lt;code&gt;*Spec&lt;/code&gt; files.</source>
          <target state="translated">&lt;code&gt;app/.eslintrc.json&lt;/code&gt; 의 구성 은 glob 패턴 &lt;code&gt;**/*Spec.js&lt;/code&gt; 를 정의합니다 . 이 패턴은 &lt;code&gt;app/.eslintrc.json&lt;/code&gt; 의 기본 디렉토리와 관련이 있습니다 . 따라서이 패턴은 &lt;code&gt;app/lib/fooSpec.js&lt;/code&gt; 및 &lt;code&gt;app/components/barSpec.js&lt;/code&gt; 와 일치 하지만 &lt;code&gt;server/serverSpec.js&lt;/code&gt; 와는 일치&lt;strong&gt;하지 않습니다&lt;/strong&gt; . &lt;code&gt;project-root&lt;/code&gt; 폴더 의 &lt;code&gt;.eslintrc.json&lt;/code&gt; 파일에서 동일한 패턴을 정의한 경우 세 가지 &lt;code&gt;*Spec&lt;/code&gt; 파일 모두와 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="761a0c741d5f1588ef78c2680d748e9585f5469d" translate="yes" xml:space="preserve">
          <source>The configuration cascade works by using the closest &lt;code&gt;.eslintrc&lt;/code&gt; file to the file being linted as the highest priority, then any configuration files in the parent directory, and so on. When you run ESLint on this project, all files in &lt;code&gt;lib/&lt;/code&gt; will use the &lt;code&gt;.eslintrc&lt;/code&gt; file at the root of the project as their configuration. When ESLint traverses into the &lt;code&gt;tests/&lt;/code&gt; directory, it will then use &lt;code&gt;your-project/tests/.eslintrc&lt;/code&gt; in addition to &lt;code&gt;your-project/.eslintrc&lt;/code&gt;. So &lt;code&gt;your-project/tests/test.js&lt;/code&gt; is linted based on the combination of the two &lt;code&gt;.eslintrc&lt;/code&gt; files in its directory hierarchy, with the closest one taking priority. In this way, you can have project-level ESLint settings and also have directory-specific overrides.</source>
          <target state="translated">구성 단계는 가장 근접한 &lt;code&gt;.eslintrc&lt;/code&gt; 파일을 가장 우선 순위가 높은 파일에 린트 한 다음 상위 디렉토리의 구성 파일 등을 사용하여 작동합니다. 이 프로젝트에 ESLint를 실행하면, 모든 파일 &lt;code&gt;lib/&lt;/code&gt; 사용합니다 &lt;code&gt;.eslintrc&lt;/code&gt; 의 자신의 구성과 프로젝트의 루트에 파일을. ESLint가 &lt;code&gt;tests/&lt;/code&gt; 디렉토리 로 이동하면 &lt;code&gt;your-project/tests/.eslintrc&lt;/code&gt; 외에도 &lt;code&gt;your-project/.eslintrc&lt;/code&gt; 됩니다. 따라서 &lt;code&gt;your-project/tests/test.js&lt;/code&gt; 는 두 &lt;code&gt;.eslintrc&lt;/code&gt; 의 조합에 따라 보풀이됩니다.디렉토리 계층 구조의 파일 중 가장 가까운 파일이 우선합니다. 이러한 방식으로 프로젝트 수준 ESLint 설정을 사용하고 디렉토리 별 재정의를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dcdf3251f61da2ed7fea4070dd8de83ac8b210fc" translate="yes" xml:space="preserve">
          <source>The configuration that you have in your &lt;code&gt;.eslintrc&lt;/code&gt; file is an important part of your project, and as such, you may want to share it with other projects or people. Shareable configs allow you to publish your configuration settings on &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt; and have others download and use it in their ESLint projects.</source>
          <target state="translated">당신이 당신에 가지고 구성 &lt;code&gt;.eslintrc&lt;/code&gt; 파일은 프로젝트의 중요한 부분이며, 같은 다른 프로젝트 나 사람들과 공유 할 수 있습니다. 공유 가능한 구성을 사용하면 &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm에&lt;/a&gt; 구성 설정을 게시 하고 다른 사람들이 ESLint 프로젝트에서 구성 설정을 다운로드하여 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32170e7d3eae30d6911a8ee9094599efb5b60bbf" translate="yes" xml:space="preserve">
          <source>The confusion around sparse arrays defined in this manner is enough that it's recommended to avoid using them unless you are certain that they are useful in your code.</source>
          <target state="translated">이러한 방식으로 정의 된 희소 배열에 대한 혼동은 코드에서 유용하지 않다면 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="84a32a3cbfb78fbed02519d25670fc0e1cc660ca" translate="yes" xml:space="preserve">
          <source>The constructor function is particularly useful when you want to dynamically generate the pattern, because it takes string arguments.</source>
          <target state="translated">생성자 함수는 문자열 인수를 사용하므로 패턴을 동적으로 생성하려는 경우에 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="1c3dff42ca3b1d5caf72f42e977b149fee7f9002" translate="yes" xml:space="preserve">
          <source>The contents of the &lt;code&gt;if&lt;/code&gt; statement is an arrow function, not a comparison.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 문의 내용은 비교가 아니라 화살표 함수입니다.</target>
        </trans-unit>
        <trans-unit id="dc960e48baa84799c5c10650483220ba5c93ce2e" translate="yes" xml:space="preserve">
          <source>The custom message will be appended to the default error message. Please note that you may not specify custom error messages for restricted patterns as a particular import may match more than one pattern.</source>
          <target state="translated">사용자 정의 메시지가 기본 오류 메시지에 추가됩니다. 특정 가져 오기가 둘 이상의 패턴과 일치 할 수 있으므로 제한된 패턴에 대해 사용자 정의 오류 메시지를 지정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="02091995aebc0237ea1f370d1e9e697cb283fce5" translate="yes" xml:space="preserve">
          <source>The custom message will be appended to the default error message. Please note that you may not specify custom error messages for restricted patterns as a particular module may match more than one pattern.</source>
          <target state="translated">사용자 정의 메시지가 기본 오류 메시지에 추가됩니다. 특정 모듈이 둘 이상의 패턴과 일치 할 수 있으므로 제한된 패턴에 대해 사용자 정의 오류 메시지를 지정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2db40330539be8a023ce70cd6de477ff5ec12779" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;&quot;never&quot;&lt;/code&gt; option can have exception options in an object literal:</source>
          <target state="translated">기본 &lt;code&gt;&quot;never&quot;&lt;/code&gt; 옵션은 객체 리터럴에 예외 옵션이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aad36d23c9c66cf621dc65a4fdf5357b747ebf25" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;&quot;object&quot;&lt;/code&gt; option requires the dot to be on the same line as the object.</source>
          <target state="translated">기본 &lt;code&gt;&quot;object&quot;&lt;/code&gt; 옵션을 사용하려면 점이 개체와 같은 줄에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="eb214d0a96891b20944eb86c406846b8c0682ec0" translate="yes" xml:space="preserve">
          <source>The default configuration is &lt;code&gt;&quot;after&quot;, { &quot;overrides&quot;: { &quot;?&quot;: &quot;before&quot;, &quot;:&quot;: &quot;before&quot; } }&lt;/code&gt;</source>
          <target state="translated">기본 구성은 &lt;code&gt;&quot;after&quot;, { &quot;overrides&quot;: { &quot;?&quot;: &quot;before&quot;, &quot;:&quot;: &quot;before&quot; } }&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="796093e436a921806e600ed6ffc0bb010636d015" translate="yes" xml:space="preserve">
          <source>The default configuration is &lt;code&gt;{ &quot;before&quot;: true, &quot;after&quot;: true }&lt;/code&gt;.</source>
          <target state="translated">기본 구성은 &lt;code&gt;{ &quot;before&quot;: true, &quot;after&quot;: true }&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ffd96c78ae8b308cef5ee180c2cafbcfe74c3226" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;&quot;always&quot;&lt;/code&gt;.</source>
          <target state="translated">기본값은 &lt;code&gt;&quot;always&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2d709b74ae2cf658c17f26fdf6ce2c1bfe069742" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;{&quot;before&quot;: false, &quot;after&quot;: true}&lt;/code&gt;.</source>
          <target state="translated">기본값은 &lt;code&gt;{&quot;before&quot;: false, &quot;after&quot;: true}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="535a63e8e2a6cdd1ad85243a0f44cac231300bc7" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;{&quot;before&quot;: true, &quot;after&quot;: false}&lt;/code&gt;.</source>
          <target state="translated">기본값은 &lt;code&gt;{&quot;before&quot;: true, &quot;after&quot;: false}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="baa5bd9ea8cd406c936d48459561cdc0703e1522" translate="yes" xml:space="preserve">
          <source>The default option (that is, no string option specified) for this rule was &lt;strong&gt;removed&lt;/strong&gt; in ESLint v1.0. The &lt;code&gt;&quot;function&quot;&lt;/code&gt; option is most similar to the removed option.</source>
          <target state="translated">이 규칙에 대한 기본 옵션 (즉, 문자열 옵션이 지정되지 않음)이 ESLint v1.0에서 &lt;strong&gt;제거&lt;/strong&gt; 되었습니다. &lt;code&gt;&quot;function&quot;&lt;/code&gt; 옵션은 제거 된 옵션과 가장 유사하다.</target>
        </trans-unit>
        <trans-unit id="ea560e9329be81e2a97fb02fb917528a08a7dfda" translate="yes" xml:space="preserve">
          <source>The default options for some rules have changed</source>
          <target state="translated">일부 규칙의 기본 옵션이 변경되었습니다</target>
        </trans-unit>
        <trans-unit id="e1b30fc08a505ea690637325f1e931c67ab9c7ce" translate="yes" xml:space="preserve">
          <source>The default options for the &lt;a href=&quot;../rules/no-confusing-arrow&quot;&gt;&lt;code&gt;no-confusing-arrow&lt;/code&gt;&lt;/a&gt; rule have changed from &lt;code&gt;{ allowParens: false }&lt;/code&gt; to &lt;code&gt;{ allowParens: true }&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../rules/no-confusing-arrow&quot;&gt; &lt;code&gt;no-confusing-arrow&lt;/code&gt; &lt;/a&gt; 규칙 의 기본 옵션이 &lt;code&gt;{ allowParens: false }&lt;/code&gt; 에서 &lt;code&gt;{ allowParens: true }&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="544468a6bb41999c9c49e104c2162d56de2501c3" translate="yes" xml:space="preserve">
          <source>The default options for the &lt;a href=&quot;../rules/no-redeclare&quot;&gt;&lt;code&gt;no-redeclare&lt;/code&gt;&lt;/a&gt; rule have changed from &lt;code&gt;{ builtinGlobals: false }&lt;/code&gt; to &lt;code&gt;{ builtinGlobals: true }&lt;/code&gt;. Additionally, the &lt;code&gt;no-redeclare&lt;/code&gt; rule will now report an error for globals enabled by comments like &lt;code&gt;/* global foo */&lt;/code&gt; if those globals were already enabled through configuration anyway.</source>
          <target state="translated">&lt;a href=&quot;../rules/no-redeclare&quot;&gt; &lt;code&gt;no-redeclare&lt;/code&gt; &lt;/a&gt; &lt;code&gt;{ builtinGlobals: false }&lt;/code&gt; 규칙 의 기본 옵션이 {builtinGlobals : false} 에서 &lt;code&gt;{ builtinGlobals: true }&lt;/code&gt; . 또한 &lt;code&gt;no-redeclare&lt;/code&gt; 규칙은 이제 전역이 구성을 통해 이미 활성화 된 경우 &lt;code&gt;/* global foo */&lt;/code&gt; 와 같은 주석으로 활성화 된 전역에 대한 오류를보고 합니다.</target>
        </trans-unit>
        <trans-unit id="4b68ac7ed408d41719943a7ec2a3599de96e8bf8" translate="yes" xml:space="preserve">
          <source>The default options for the &lt;a href=&quot;../rules/object-curly-newline&quot;&gt;&lt;code&gt;object-curly-newline&lt;/code&gt;&lt;/a&gt; rule have changed from &lt;code&gt;{ multiline: true }&lt;/code&gt; to &lt;code&gt;{ consistent: true }&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../rules/object-curly-newline&quot;&gt; &lt;code&gt;object-curly-newline&lt;/code&gt; &lt;/a&gt; 규칙 의 기본 옵션이 &lt;code&gt;{ multiline: true }&lt;/code&gt; 에서 &lt;code&gt;{ consistent: true }&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b7ab1e46a9e7c204637eb33434f00becfe8a66d" translate="yes" xml:space="preserve">
          <source>The default options object for the &lt;a href=&quot;../rules/no-self-assign&quot;&gt;&lt;code&gt;no-self-assign&lt;/code&gt;&lt;/a&gt; rule has changed from &lt;code&gt;{ props: false }&lt;/code&gt; to &lt;code&gt;{ props: true }&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../rules/no-self-assign&quot;&gt; &lt;code&gt;no-self-assign&lt;/code&gt; &lt;/a&gt; 규칙 의 기본 옵션 오브젝트 가 &lt;code&gt;{ props: false }&lt;/code&gt; 에서 &lt;code&gt;{ props: true }&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f7d8ef8740358e7014a22b0fc66ddeed7cc30fcc" translate="yes" xml:space="preserve">
          <source>The default parser now validates options more strictly</source>
          <target state="translated">기본 파서는 이제 더 엄격하게 옵션의 유효성을 검사합니다</target>
        </trans-unit>
        <trans-unit id="cb91917a4ee5c4169d24eee0779ed1f5fecc0213" translate="yes" xml:space="preserve">
          <source>The deprecated &lt;code&gt;experimentalObjectRestSpread&lt;/code&gt; option has been removed</source>
          <target state="translated">더 이상 사용되지 않는 &lt;code&gt;experimentalObjectRestSpread&lt;/code&gt; 옵션이 제거되었습니다</target>
        </trans-unit>
        <trans-unit id="417c3b37d6ea8d516aaec94e4251e5a47c517230" translate="yes" xml:space="preserve">
          <source>The difference between a marker and an exception is that a marker only appears at the beginning of the comment whereas exceptions can occur anywhere in the comment string.</source>
          <target state="translated">마커와 예외의 차이점은 마커가 주석의 시작 부분에만 나타나고 주석 문자열의 어느 곳에서나 예외가 발생할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="be6b4fc0012e62a768e63daa1d092d896e9cd14d" translate="yes" xml:space="preserve">
          <source>The difference between these two patterns is subtle, especially because the problematic empty pattern looks just like an object literal.</source>
          <target state="translated">이 두 패턴의 차이는 미묘합니다. 특히 문제가있는 빈 패턴이 객체 리터럴과 유사하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="5f8c988db3120f6ad6d74976827259fee73007f6" translate="yes" xml:space="preserve">
          <source>The easiest way to start creating a plugin is to use the &lt;a href=&quot;https://www.npmjs.com/package/generator-eslint&quot;&gt;Yeoman generator&lt;/a&gt;. The generator will guide you through setting up the skeleton of a plugin.</source>
          <target state="translated">플러그인 생성을 시작하는 가장 쉬운 방법은 &lt;a href=&quot;https://www.npmjs.com/package/generator-eslint&quot;&gt;Yeoman 생성기&lt;/a&gt; 를 사용하는 것 입니다. 생성기는 플러그인의 골격을 설정하는 과정을 안내합니다.</target>
        </trans-unit>
        <trans-unit id="43705ef6db2efcf221d0e395d353b64954c6c747" translate="yes" xml:space="preserve">
          <source>The enclosed statements should be indented one more level than the compound statement.</source>
          <target state="translated">동봉 된 명령문은 복합 명령문보다 한 단계 더 들여 쓰기해야합니다.</target>
        </trans-unit>
        <trans-unit id="b118bf659a71ae3c29fa483a5256dbcff0e3c82c" translate="yes" xml:space="preserve">
          <source>The end of the &lt;code&gt;try&lt;/code&gt; block.</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt; 블록 의 끝입니다 .</target>
        </trans-unit>
        <trans-unit id="4a0628012c2d77c4a62f2562528b964f8e826cdc" translate="yes" xml:space="preserve">
          <source>The error message.</source>
          <target state="translated">오류 메시지</target>
        </trans-unit>
        <trans-unit id="8db72bff78f8373ee30f8c8fd310da3156ec6caa" translate="yes" xml:space="preserve">
          <source>The executor function can also be an &lt;code&gt;async function&lt;/code&gt;. However, this is usually a mistake, for a few reasons:</source>
          <target state="translated">실행기 기능은 &lt;code&gt;async function&lt;/code&gt; 일 수도 있습니다 . 그러나 이것은 몇 가지 이유로 일반적으로 실수입니다.</target>
        </trans-unit>
        <trans-unit id="67f85a36ed894f5ee40529023db3887ad5bbee0c" translate="yes" xml:space="preserve">
          <source>The exported function receives an optional second argument named &lt;code&gt;data&lt;/code&gt;. The &lt;code&gt;data&lt;/code&gt; object provides extended information related to the analysis results. Currently, the &lt;code&gt;data&lt;/code&gt; object consists of a single property named &lt;code&gt;rulesMeta&lt;/code&gt;. This property is a dictionary of rule metadata, keyed with &lt;code&gt;ruleId&lt;/code&gt;. The value for each entry is the &lt;code&gt;meta&lt;/code&gt; property from the corresponding rule object. The dictionary contains an entry for each rule that was run during the analysis.</source>
          <target state="translated">내 보낸 함수는 &lt;code&gt;data&lt;/code&gt; 라는 선택적 두 번째 인수를받습니다 . &lt;code&gt;data&lt;/code&gt; 객체는 분석 결과에 관련된 확장 정보를 제공한다. 현재 &lt;code&gt;data&lt;/code&gt; 오브젝트는 &lt;code&gt;rulesMeta&lt;/code&gt; 라는 단일 특성으로 구성됩니다 . 이 특성은 &lt;code&gt;ruleId&lt;/code&gt; 로 키가 지정된 규칙 메타 데이터의 사전입니다 . 각 항목의 값 은 해당 규칙 객체 의 &lt;code&gt;meta&lt;/code&gt; 속성입니다. 사전에는 분석 중에 실행 된 각 규칙에 대한 항목이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="10638ad26a2336c237513cb7fa8ba9e360e6572f" translate="yes" xml:space="preserve">
          <source>The expressions in a &lt;code&gt;for&lt;/code&gt; statement should be separated by blank spaces. Blank spaces should only be used after semicolons, not before.</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 문의 표현식은 공백으로 분리해야합니다. 공백은 세미콜론 뒤에 사용해야하며 이전에는 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="fc9043ab9742cf8199292ae41ac858900ddd79ad" translate="yes" xml:space="preserve">
          <source>The filtered &lt;a href=&quot;#-lintresult-type&quot;&gt;LintResult&lt;/a&gt; objects.</source>
          <target state="translated">The filtered &lt;a href=&quot;#-lintresult-type&quot;&gt;LintResult&lt;/a&gt; objects.</target>
        </trans-unit>
        <trans-unit id="0857209508949425ce9520e024dc97908dd75683" translate="yes" xml:space="preserve">
          <source>The first is a string which be either &lt;code&gt;&quot;always&quot;&lt;/code&gt; or &lt;code&gt;&quot;never&quot;&lt;/code&gt;. The default is &lt;code&gt;&quot;always&quot;&lt;/code&gt;.</source>
          <target state="translated">첫 번째는 &lt;code&gt;&quot;always&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;never&quot;&lt;/code&gt; 문자열입니다 . 기본값은 &lt;code&gt;&quot;always&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6c11e634588bcc74080a015687bda5aa0bfac1d9" translate="yes" xml:space="preserve">
          <source>The first is using &lt;code&gt;setTimeout()&lt;/code&gt;, &lt;code&gt;setInterval()&lt;/code&gt; or &lt;code&gt;execScript()&lt;/code&gt; (Internet Explorer only), all of which can accept a string of JavaScript code as their first argument. For example:</source>
          <target state="translated">첫 번째는 &lt;code&gt;setTimeout()&lt;/code&gt; , &lt;code&gt;setInterval()&lt;/code&gt; 또는 &lt;code&gt;execScript()&lt;/code&gt; (Internet Explorer에만 해당)를 사용하는 것입니다.이 모두는 첫 번째 인수로 JavaScript 코드 문자열을 허용 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6d4bbf2fb18f805ebaadc20bfc29b2a73d3969ac" translate="yes" xml:space="preserve">
          <source>The first line contains only the &lt;code&gt;/*&lt;/code&gt; comment opening. No further text is allowed on this line.</source>
          <target state="translated">첫 번째 줄에는 &lt;code&gt;/*&lt;/code&gt; 주석 만 포함되어 있습니다 . 이 줄에는 더 이상 텍스트가 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6154e02adfa070a6b3e169f562e328e046578b3d" translate="yes" xml:space="preserve">
          <source>The first line of multi-comments should be indented to the same level as the code it describes. Each subsequent line should have the same indentation plus one space (for proper alignment of the &lt;code&gt;*&lt;/code&gt; characters). Each multi-line comment should be preceded by one empty line.</source>
          <target state="translated">다중 주석의 첫 번째 줄은 설명하는 코드와 같은 수준으로 들여 쓰기해야합니다. 이후의 각 줄은 들여 쓰기와 공백이 같아야합니다 ( &lt;code&gt;*&lt;/code&gt; 문자 의 올바른 정렬을 위해 ). 각 여러 줄 주석 앞에 하나의 빈 줄이 와야합니다.</target>
        </trans-unit>
        <trans-unit id="5072260dd42b4b3af826cc62dd8fbb33239f1233" translate="yes" xml:space="preserve">
          <source>The first line of the commit message (the summary) must have a specific format. This format is checked by our build tools.</source>
          <target state="translated">커밋 메시지의 첫 번째 줄 (요약)은 특정 형식이어야합니다. 이 형식은 빌드 도구에서 확인합니다.</target>
        </trans-unit>
        <trans-unit id="eaba518aba6a1d6f3d301b713e35495cf26fd58b" translate="yes" xml:space="preserve">
          <source>The first problem is that primitive wrapper objects are, in fact, objects. That means &lt;code&gt;typeof&lt;/code&gt; will return &lt;code&gt;&quot;object&quot;&lt;/code&gt; instead of &lt;code&gt;&quot;string&quot;&lt;/code&gt;, &lt;code&gt;&quot;number&quot;&lt;/code&gt;, or &lt;code&gt;&quot;boolean&quot;&lt;/code&gt;. The second problem comes with boolean objects. Every object is truthy, that means an instance of &lt;code&gt;Boolean&lt;/code&gt; always resolves to &lt;code&gt;true&lt;/code&gt; even when its actual value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">첫 번째 문제점은 기본 랩퍼 오브젝트가 실제로 오브젝트라는 것입니다. 즉, &lt;code&gt;typeof&lt;/code&gt; 는 &lt;code&gt;&quot;string&quot;&lt;/code&gt; , &lt;code&gt;&quot;number&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;boolean&quot;&lt;/code&gt; 대신 &lt;code&gt;&quot;object&quot;&lt;/code&gt; 를 반환 합니다 . 두 번째 문제는 부울 객체와 관련이 있습니다. 모든 객체는 정직합니다. 즉, 실제 값이 &lt;code&gt;false&lt;/code&gt; 인 &lt;code&gt;true&lt;/code&gt; 에도 &lt;code&gt;Boolean&lt;/code&gt; 인스턴스는 항상 true로 해석됩니다 .</target>
        </trans-unit>
        <trans-unit id="984bf5268b0ddf754b28d771410a618bd31b5080" translate="yes" xml:space="preserve">
          <source>The first step to sending a pull request is to create a new branch in your ESLint fork. Give the branch a descriptive name that describes what it is you're fixing, such as:</source>
          <target state="translated">풀 요청을 보내는 첫 번째 단계는 ESLint 포크에 새 분기를 만드는 것입니다. 브랜치에 다음과 같이 수정하려는 내용을 설명하는 설명적인 이름을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="89a5d6f7116af9ee2720543818896897a369050f" translate="yes" xml:space="preserve">
          <source>The first throwable node (e.g. a function call) in the &lt;code&gt;try&lt;/code&gt; block.</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt; 블록 에서 첫 번째로 던질 수있는 노드 (예 : 함수 호출)</target>
        </trans-unit>
        <trans-unit id="d71475a3d6080cbad00254ef62ed2324f9e45663" translate="yes" xml:space="preserve">
          <source>The first way to use configuration files is via &lt;code&gt;.eslintrc.*&lt;/code&gt; and &lt;code&gt;package.json&lt;/code&gt; files. ESLint will automatically look for them in the directory of the file to be linted, and in successive parent directories all the way up to the root directory of the filesystem (unless &lt;code&gt;root: true&lt;/code&gt; is specified). This option is useful when you want different configurations for different parts of a project or when you want others to be able to use ESLint directly without needing to remember to pass in the configuration file.</source>
          <target state="translated">구성 파일을 사용하는 첫 번째 방법은 &lt;code&gt;.eslintrc.*&lt;/code&gt; 및 &lt;code&gt;package.json&lt;/code&gt; 파일 을 이용하는 것입니다 . ESLint는 보풀 될 파일의 ​​디렉토리에서 파일 시스템의 루트 디렉토리까지 루트 디렉토리까지 루트 디렉토리까지 자동으로 찾습니다 ( &lt;code&gt;root: true&lt;/code&gt; 가 지정 되지 않은 경우). 이 옵션은 프로젝트의 다른 부분에 대해 다른 구성을 원하거나 구성 파일을 전달할 필요없이 다른 사람들이 ESLint를 직접 사용할 수 있도록하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="cc7819bcb56a4f8a3f4c63d8cc7e3fc0c5244e52" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;--ignore-pattern&lt;/code&gt; is also equivalent:</source>
          <target state="translated">The following &lt;code&gt;--ignore-pattern&lt;/code&gt; is also equivalent:</target>
        </trans-unit>
        <trans-unit id="7899f93b94b39beef8a71db444282ddbbd5e7124" translate="yes" xml:space="preserve">
          <source>The following configuration ignores indentation in the body of IIFEs.</source>
          <target state="translated">다음 구성은 IIFE 본문의 들여 쓰기를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="41c40b6e586fc5cb09bbc72af12c8f09e123d736" translate="yes" xml:space="preserve">
          <source>The following configuration ignores the indentation of &lt;code&gt;ConditionalExpression&lt;/code&gt; (&quot;ternary expression&quot;) nodes:</source>
          <target state="translated">다음 구성은 &lt;code&gt;ConditionalExpression&lt;/code&gt; ( &quot;삼항 표현식&quot;) 노드 의 들여 쓰기를 무시합니다 .</target>
        </trans-unit>
        <trans-unit id="d5fa8b20b228bdd086131e38e40e897cbd6cbf7a" translate="yes" xml:space="preserve">
          <source>The following examples &lt;strong&gt;will not&lt;/strong&gt; be flagged:</source>
          <target state="translated">다음 예제 &lt;strong&gt;는&lt;/strong&gt; 플래그가 지정 &lt;strong&gt;되지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="f5287d99a37de7104aa2ed235baa902a0ec5078d" translate="yes" xml:space="preserve">
          <source>The following examples &lt;strong&gt;will&lt;/strong&gt; be flagged:</source>
          <target state="translated">다음 예제 &lt;strong&gt;가&lt;/strong&gt; 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="c14ba9c0ea8a095e66d6957614fae22fac370baf" translate="yes" xml:space="preserve">
          <source>The following exceptions are available:</source>
          <target state="translated">다음과 같은 예외가 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf3496b833b4ce7626fcd6541bf610fb0c36af11" translate="yes" xml:space="preserve">
          <source>The following exceptions are available: &lt;code&gt;[&quot;{}&quot;, &quot;[]&quot;, &quot;()&quot;, &quot;empty&quot;]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;[&quot;{}&quot;, &quot;[]&quot;, &quot;()&quot;, &quot;empty&quot;]&lt;/code&gt; 예외는 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="fc06f672c1606cd07e74f3dea672e030eb3b9e95" translate="yes" xml:space="preserve">
          <source>The following is another example of this behavior:</source>
          <target state="translated">다음은이 동작의 다른 예입니다.</target>
        </trans-unit>
        <trans-unit id="2a56e159d769ca06392168750d10004a388bb2d2" translate="yes" xml:space="preserve">
          <source>The following methods internally use the &lt;code&gt;===&lt;/code&gt; comparison to match the given value with an array element:</source>
          <target state="translated">다음 메소드는 내부적으로 &lt;code&gt;===&lt;/code&gt; 비교를 사용 하여 주어진 값을 배열 요소와 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="5d5534fd1ddcbfd687919d332b483e9a80e0f5bb" translate="yes" xml:space="preserve">
          <source>The following operators can be used in &lt;code&gt;groups&lt;/code&gt; option:</source>
          <target state="translated">다음 연산자는 &lt;code&gt;groups&lt;/code&gt; 옵션 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6b976bf24d5d6d504746e7c6ab5309ec8057839f" translate="yes" xml:space="preserve">
          <source>The following parsers are compatible with ESLint:</source>
          <target state="translated">다음 파서는 ESLint와 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="0d78993759d70053fb65fd89fcd97c00ecd762fb" translate="yes" xml:space="preserve">
          <source>The following pattern is under strict mode globally and is considered valid with the &lt;code&gt;&quot;always&quot;&lt;/code&gt; option and a warning with the &lt;code&gt;&quot;never&quot;&lt;/code&gt; option.</source>
          <target state="translated">다음 패턴은 전체적으로 엄격 모드에 있으며 &lt;code&gt;&quot;always&quot;&lt;/code&gt; 옵션으로 유효 하고 &lt;code&gt;&quot;never&quot;&lt;/code&gt; 옵션 으로 경고로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="d729325dfb7e6f59aa92e87801a3213c9448843d" translate="yes" xml:space="preserve">
          <source>The following patterns apply strict mode only to functions so are valid with the &lt;code&gt;&quot;never&quot;&lt;/code&gt; option but are problems with the &lt;code&gt;&quot;always&quot;&lt;/code&gt; option.</source>
          <target state="translated">다음 패턴은 기능에만 엄격 모드를 적용하므로 &lt;code&gt;&quot;never&quot;&lt;/code&gt; 옵션 에는 유효 하지만 &lt;code&gt;&quot;always&quot;&lt;/code&gt; 옵션 에는 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c8beda3159d864bcb7168811d6ca919b1da89c2" translate="yes" xml:space="preserve">
          <source>The following rules have been added to the &lt;a href=&quot;configuring#using-eslintrecommended&quot;&gt;&lt;code&gt;eslint:recommended&lt;/code&gt;&lt;/a&gt; config:</source>
          <target state="translated">&lt;a href=&quot;configuring#using-eslintrecommended&quot;&gt; &lt;code&gt;eslint:recommended&lt;/code&gt; &lt;/a&gt; 구성에 다음 규칙이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="43d343a3ec041d356d216b275ad524155322bd82" translate="yes" xml:space="preserve">
          <source>The following rules have been deprecated with new rules created to take their place. The following is a list of the removed rules and their replacements:</source>
          <target state="translated">다음 규칙은 새로운 규칙이 적용되어 더 이상 사용되지 않습니다. 다음은 제거 된 규칙 및 대체 목록입니다.</target>
        </trans-unit>
        <trans-unit id="fd8fba26361e9e9eea3de62de397689436cfaa0d" translate="yes" xml:space="preserve">
          <source>The following rules were modified:</source>
          <target state="translated">다음 규칙이 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="cbf28d7aa679ef7fb32bcf23869dde2a833ca6c5" translate="yes" xml:space="preserve">
          <source>The following rules were removed from &lt;code&gt;&quot;eslint:recommended&quot;&lt;/code&gt;:</source>
          <target state="translated">다음 규칙이 &lt;code&gt;&quot;eslint:recommended&quot;&lt;/code&gt; 에서 제거되었습니다 .</target>
        </trans-unit>
        <trans-unit id="4b1c496bbd734835e82ecba2dcd535dd72437441" translate="yes" xml:space="preserve">
          <source>The following selectors are supported:</source>
          <target state="translated">다음과 같은 선택기가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="50fe0ca19519467513afe9de899977912a5dca9e" translate="yes" xml:space="preserve">
          <source>The function declaration portion rule will be rendered obsolete when &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=585536&quot;&gt;block-scoped functions&lt;/a&gt; land in ES6, but until then, it should be left on to enforce valid constructions. Disable checking variable declarations when using &lt;a href=&quot;block-scoped-var&quot;&gt;block-scoped-var&lt;/a&gt; or if declaring variables in nested blocks is acceptable despite hoisting.</source>
          <target state="translated">&lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=585536&quot;&gt;블록 범위 함수&lt;/a&gt; 가 ES6에 도달 하면 함수 선언 부분 규칙이 더 이상 사용되지 않지만 유효한 구조를 유지하려면 계속 유지해야합니다. &lt;a href=&quot;block-scoped-var&quot;&gt;block-scoped-var을 사용&lt;/a&gt; 하거나 호이 스팅에도 불구하고 중첩 된 블록에서 변수를 선언 할 수있는 경우 변수 선언 확인을 비활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="db3dccfd930abb34e566f04f78fc9ed70b467b0b" translate="yes" xml:space="preserve">
          <source>The function has &lt;code&gt;@this&lt;/code&gt; tag in its JSDoc comment.</source>
          <target state="translated">이 함수는 JSDoc 주석에 &lt;code&gt;@this&lt;/code&gt; 태그가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5620d241e1ebd93a4e8ac57b317c474f477713ad" translate="yes" xml:space="preserve">
          <source>The function invocation can be written by &lt;code&gt;Function.prototype.call()&lt;/code&gt; and &lt;code&gt;Function.prototype.apply()&lt;/code&gt;. But &lt;code&gt;Function.prototype.call()&lt;/code&gt; and &lt;code&gt;Function.prototype.apply()&lt;/code&gt; are slower than the normal function invocation.</source>
          <target state="translated">함수 호출은 &lt;code&gt;Function.prototype.call()&lt;/code&gt; 및 &lt;code&gt;Function.prototype.apply()&lt;/code&gt; 로 작성할 수 있습니다 . 그러나 &lt;code&gt;Function.prototype.call()&lt;/code&gt; 및 &lt;code&gt;Function.prototype.apply()&lt;/code&gt; 는 일반 함수 호출보다 느립니다.</target>
        </trans-unit>
        <trans-unit id="a5351ac484a8bf3cb3ea45d7dd69d4667a894926" translate="yes" xml:space="preserve">
          <source>The function is a callback of array methods (such as &lt;code&gt;.forEach()&lt;/code&gt;) if &lt;code&gt;thisArg&lt;/code&gt; is given.</source>
          <target state="translated">&lt;code&gt;thisArg&lt;/code&gt; 가 제공 되면 함수는 배열 메소드 (예 : &lt;code&gt;.forEach()&lt;/code&gt; ) 의 콜백입니다 .</target>
        </trans-unit>
        <trans-unit id="deb40c3066f6e38deb8139ba56f87dc333a2a42d" translate="yes" xml:space="preserve">
          <source>The function is a constructor of ES2015 Classes.</source>
          <target state="translated">이 함수는 ES2015 클래스의 생성자입니다.</target>
        </trans-unit>
        <trans-unit id="de02b593b295da2bc2bad8e8f15be1427537b0d8" translate="yes" xml:space="preserve">
          <source>The function is a method/getter/setter of ES2015 Classes. (excepts static methods)</source>
          <target state="translated">이 함수는 ES2015 클래스의 메소드 / getter / setter입니다. (정적 메소드 제외)</target>
        </trans-unit>
        <trans-unit id="58b8b313fb5fc9cea0cb6de31e257ad439368b79" translate="yes" xml:space="preserve">
          <source>The function is assigned to a property.</source>
          <target state="translated">이 기능은 속성에 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="1ec2f55a7c94721043c141bc1c6ef3a223affda5" translate="yes" xml:space="preserve">
          <source>The function is assigned to a variable which starts with an uppercase letter.</source>
          <target state="translated">이 기능은 대문자로 시작하는 변수에 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="f1a468e18550838069874f9e16dfdc8a15a09a28" translate="yes" xml:space="preserve">
          <source>The function is on an object literal.</source>
          <target state="translated">함수는 객체 리터럴에 있습니다.</target>
        </trans-unit>
        <trans-unit id="24287496e1c3d7550a774298bb9d98fa77335f61" translate="yes" xml:space="preserve">
          <source>The function's</source>
          <target state="translated">기능</target>
        </trans-unit>
        <trans-unit id="aeaafe54aaf295b5e3e4fde9b2befddf145018a6" translate="yes" xml:space="preserve">
          <source>The get syntax binds an object property to a function that will be called when that property is looked up. It was first introduced in ECMAScript 5:</source>
          <target state="translated">get 구문은 객체 속성을 해당 속성을 조회 할 때 호출되는 함수에 바인딩합니다. ECMAScript 5에서 처음 소개되었습니다.</target>
        </trans-unit>
        <trans-unit id="5303cca7341f758ff7259b4665508fac4ca8d017" translate="yes" xml:space="preserve">
          <source>The global's</source>
          <target state="translated">세계의</target>
        </trans-unit>
        <trans-unit id="cd1ea1f16f00e056aa55de069fc2ba6f16e8946b" translate="yes" xml:space="preserve">
          <source>The goal of using &lt;code&gt;new&lt;/code&gt; with a constructor is typically to create an object of a particular type and store that object in a variable, such as:</source>
          <target state="translated">생성자와 함께 &lt;code&gt;new&lt;/code&gt; 를 사용하는 목표 는 일반적으로 특정 유형의 객체를 만들고 해당 객체를 변수에 다음과 같이 저장하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="acac3d2c78a0442ff5e1d6b8f826069158684f0b" translate="yes" xml:space="preserve">
          <source>The implementation is not aware of any local functions with the name &lt;code&gt;require&lt;/code&gt; that may shadow Node.js' global &lt;code&gt;require&lt;/code&gt;.</source>
          <target state="translated">구현시 Node.js의 글로벌 &lt;code&gt;require&lt;/code&gt; 를 가리킬 수있는 &lt;code&gt;require&lt;/code&gt; 라는 이름의 로컬 함수를 인식하지 못합니다 .</target>
        </trans-unit>
        <trans-unit id="032f95f2ad52750fe42b95d8612f0f3b8a88f333" translate="yes" xml:space="preserve">
          <source>The import statement can also import a module without exported bindings. Used when the module does not export anything, but runs it own code or changes the global context object.</source>
          <target state="translated">import 문은 내 보낸 바인딩없이 모듈을 가져올 수도 있습니다. 모듈이 아무것도 내 보내지 않지만 자체 코드를 실행하거나 전역 컨텍스트 객체를 변경할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0eeaf642c54558bc59a95b083b854c711c38cc2b" translate="yes" xml:space="preserve">
          <source>The import statement is used to import members (functions, objects or primitives) that have been exported from an external module. Using a specific member syntax:</source>
          <target state="translated">import 문은 외부 모듈에서 내 보낸 멤버 (함수, 객체 또는 프리미티브)를 가져 오는 데 사용됩니다. 특정 멤버 구문 사용 :</target>
        </trans-unit>
        <trans-unit id="828330981111cc0aaf5513c653c9b3ff72d6b8c6" translate="yes" xml:space="preserve">
          <source>The information about the deprecated rules that were used to check this file.</source>
          <target state="translated">The information about the deprecated rules that were used to check this file.</target>
        </trans-unit>
        <trans-unit id="4a80f2125f069a5f1c92caf6dad61a91aa823038" translate="yes" xml:space="preserve">
          <source>The information available for each linting message is:</source>
          <target state="translated">각 보푸라기 메시지에 사용 가능한 정보는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7675327e3125cbdffe94a48f7416e4309f48e134" translate="yes" xml:space="preserve">
          <source>The information available is:</source>
          <target state="translated">사용 가능한 정보는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="026fee076803b9a433c8e9acb756fb2b3e489841" translate="yes" xml:space="preserve">
          <source>The kind of the way to address variables in destructuring. There are 2 values:</source>
          <target state="translated">파괴에서 변수를 다루는 방법의 종류. 두 가지 값이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="c38f57d73e2ff10d4366adce9c62d418943b8650" translate="yes" xml:space="preserve">
          <source>The last line has the &lt;code&gt;*/&lt;/code&gt; comment opening aligned with the preceding lines. No other text is allowed on this line.</source>
          <target state="translated">마지막 줄에는 &lt;code&gt;*/&lt;/code&gt; 주석이 앞줄과 정렬되어 있습니다. 이 줄에는 다른 텍스트가 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cf2418cd74bfe3b3574af71ae7e2102cc8457373" translate="yes" xml:space="preserve">
          <source>The line comment &lt;code&gt;// exported variableName&lt;/code&gt; will not work as &lt;code&gt;exported&lt;/code&gt; is not line-specific.</source>
          <target state="translated">라인 주석 &lt;code&gt;// exported variableName&lt;/code&gt; 대로 작동하지 않습니다 &lt;code&gt;exported&lt;/code&gt; 라인 별 아니다.</target>
        </trans-unit>
        <trans-unit id="dd3923f68fea3cc32c62bea7c26b00e55243f62f" translate="yes" xml:space="preserve">
          <source>The line is &lt;code&gt;--&lt;/code&gt; or &lt;code&gt;++&lt;/code&gt; (in which case it will decrement/increment the next token.)</source>
          <target state="translated">행은 &lt;code&gt;--&lt;/code&gt; 또는 &lt;code&gt;++&lt;/code&gt; 입니다 (이 경우 다음 토큰이 감소 / 증가합니다).</target>
        </trans-unit>
        <trans-unit id="8fc6d3dc22f28ddac02852365e2f486c4a9fbcb1" translate="yes" xml:space="preserve">
          <source>The linebreaks (new lines) used in windows operating system are usually &lt;em&gt;carriage returns&lt;/em&gt; (CR) followed by a &lt;em&gt;line feed&lt;/em&gt; (LF) making it a &lt;em&gt;carriage return line feed&lt;/em&gt; (CRLF) whereas Linux and Unix use a simple &lt;em&gt;line feed&lt;/em&gt; (LF). The corresponding &lt;em&gt;control sequences&lt;/em&gt; are &lt;code&gt;&quot;\n&quot;&lt;/code&gt; (for LF) and &lt;code&gt;&quot;\r\n&quot;&lt;/code&gt; for (CRLF).</source>
          <target state="translated">Windows 운영 체제에서 사용되는 줄 바꿈 (새 줄)은 일반적으로 &lt;em&gt;캐리지 리턴&lt;/em&gt; (CR) 다음에 &lt;em&gt;줄 바꿈&lt;/em&gt; (LF)이되어 &lt;em&gt;캐리지 리턴 줄 바꿈&lt;/em&gt; (CRLF)이되고 Linux와 Unix는 단순 &lt;em&gt;줄 바꿈&lt;/em&gt; (LF)을 사용합니다. 해당 &lt;em&gt;제어 시퀀스&lt;/em&gt; 는 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; (LF의 경우) 및 &lt;code&gt;&quot;\r\n&quot;&lt;/code&gt; ((CRLF)의 경우)입니다.</target>
        </trans-unit>
        <trans-unit id="26d7358730984ec96df0ef330056949a6cca706a" translate="yes" xml:space="preserve">
          <source>The lint target files. This can contain any of file paths, directory paths, and glob patterns.</source>
          <target state="translated">The lint target files. This can contain any of file paths, directory paths, and glob patterns.</target>
        </trans-unit>
        <trans-unit id="6ba0efe7b079abf8625759c3ee06d0fef820cbba" translate="yes" xml:space="preserve">
          <source>The list of suggestions. Each suggestion is the pair of a description and an &lt;a href=&quot;#-editinfo-type&quot;&gt;EditInfo&lt;/a&gt; object to fix code. API users such as editor integrations can choose one of them to fix the problem of this message. This property is undefined if this message doesn't have any suggestions.</source>
          <target state="translated">The list of suggestions. Each suggestion is the pair of a description and an &lt;a href=&quot;#-editinfo-type&quot;&gt;EditInfo&lt;/a&gt; object to fix code. API users such as editor integrations can choose one of them to fix the problem of this message. This property is undefined if this message doesn't have any suggestions.</target>
        </trans-unit>
        <trans-unit id="2201d7d5091e9b276f0386c81e6c9e6b5aad5f13" translate="yes" xml:space="preserve">
          <source>The lists below are ordered roughly by the number of users each change is expected to affect, where the first items are expected to affect the most users.</source>
          <target state="translated">아래 목록은 각 변경이 영향을받을 것으로 예상되는 사용자 수에 따라 대략적으로 정렬되며, 첫 번째 항목이 가장 많은 사용자에게 영향을 줄 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="cd5ba3dd3a61a71ce3c2df5c8c27632dbb8e611b" translate="yes" xml:space="preserve">
          <source>The main method is &lt;code&gt;cli.execute()&lt;/code&gt;, which accepts an array of strings that represent the command line options (as if &lt;code&gt;process.argv&lt;/code&gt; were passed without the first two arguments). If you want to run ESLint from inside of another program and have it act like the CLI, then &lt;code&gt;cli&lt;/code&gt; is the object to use.</source>
          <target state="translated">주요 방법은 &lt;code&gt;cli.execute()&lt;/code&gt; (것처럼 명령 줄 옵션을 나타내는 문자열 배열 받아 &lt;code&gt;process.argv&lt;/code&gt; 는 처음 두 인수없이 전달 된 참조). 다른 프로그램 내에서 ESLint를 실행하고 CLI처럼 작동하게하려면 &lt;code&gt;cli&lt;/code&gt; 가 사용할 객체입니다.</target>
        </trans-unit>
        <trans-unit id="82c7fc418c96dfe485b72e97d5785c7b1f84d1d1" translate="yes" xml:space="preserve">
          <source>The main method of the &lt;code&gt;CLIEngine&lt;/code&gt; is &lt;code&gt;executeOnFiles()&lt;/code&gt;, which accepts an array of file and directory names to run the linter on.</source>
          <target state="translated">&lt;code&gt;CLIEngine&lt;/code&gt; 의 주요 메소드 는 &lt;code&gt;executeOnFiles()&lt;/code&gt; 이며, 파일 및 디렉토리 이름 배열을 사용하여 린터를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa5cd71ecca317561d0f3120437420e4eb266e86" translate="yes" xml:space="preserve">
          <source>The main method of the &lt;code&gt;Linter&lt;/code&gt; object is &lt;code&gt;verify()&lt;/code&gt; and accepts two arguments: the source text to verify and a configuration object (the baked configuration of the given configuration file plus command line options). The method first parses the given text with &lt;code&gt;espree&lt;/code&gt; (or whatever the configured parser is) and retrieves the AST. The AST is produced with both line/column and range locations which are useful for reporting location of issues and retrieving the source text related to an AST node, respectively.</source>
          <target state="translated">&lt;code&gt;Linter&lt;/code&gt; 객체 의 주요 메소드 는 &lt;code&gt;verify()&lt;/code&gt; 이며, 검증 할 소스 텍스트와 구성 객체 (주어진 구성 파일의 구워진 구성 및 명령 행 옵션)의 두 가지 인수를 허용합니다. 이 방법은 먼저 주어진 텍스트를 &lt;code&gt;espree&lt;/code&gt; (또는 구성된 파서가 무엇이든)로 구문 분석하고 AST를 검색합니다. AST는 문제의 위치를보고하고 AST 노드와 관련된 소스 텍스트를 각각 검색하는 데 유용한 행 / 열 및 범위 위치로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="b71267395abe4b458e8e16055642b9f1606731d6" translate="yes" xml:space="preserve">
          <source>The main method you'll use is &lt;code&gt;context.report()&lt;/code&gt;, which publishes a warning or error (depending on the configuration being used). This method accepts a single argument, which is an object containing the following properties:</source>
          <target state="translated">사용할 주요 메소드는 &lt;code&gt;context.report()&lt;/code&gt; 이며, 사용중인 구성에 따라 경고 또는 오류를 게시합니다. 이 메소드는 단일 특성을 허용하며 이는 다음 특성을 포함하는 오브젝트입니다.</target>
        </trans-unit>
        <trans-unit id="2aa043d4f97cda6b2c4e5a4d1829ce7593f304b2" translate="yes" xml:space="preserve">
          <source>The message summary should be a one-sentence description of the change, and it must be 72 characters in length or shorter. If the pull request addresses an issue, then the issue number should be mentioned at the end. If the commit doesn't completely fix the issue, then use &lt;code&gt;(refs #1234)&lt;/code&gt; instead of &lt;code&gt;(fixes #1234)&lt;/code&gt;.</source>
          <target state="translated">메시지 요약은 변경 사항을 한 문장으로 설명해야하며 길이는 72 자 이하 여야합니다. 풀 요청으로 문제가 해결되면 마지막에 문제 번호를 언급해야합니다. (가) 완전히 문제가 해결되지 않는 커밋 경우, 사용 &lt;code&gt;(refs #1234)&lt;/code&gt; 대신 &lt;code&gt;(fixes #1234)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6fc4e5ab9c1873762f005496619a765f850f8b95" translate="yes" xml:space="preserve">
          <source>The method to convert the &lt;a href=&quot;#-lintresult-type&quot;&gt;LintResult&lt;/a&gt; objects to text.</source>
          <target state="translated">The method to convert the &lt;a href=&quot;#-lintresult-type&quot;&gt;LintResult&lt;/a&gt; objects to text.</target>
        </trans-unit>
        <trans-unit id="447ba6b4ad05e52da0b122358fe9cf1656020fec" translate="yes" xml:space="preserve">
          <source>The modification does not depend on whether the object option is set to &lt;code&gt;true&lt;/code&gt;. In other words, ESLint never collects all the property specifications onto a single line, even when the object option would permit that.</source>
          <target state="translated">수정은 object 옵션이 &lt;code&gt;true&lt;/code&gt; 로 설정되어 있는지 여부에 따라 달라지지 않습니다 . 다시 말해 ESLint는 객체 옵션이 허용하는 경우에도 모든 속성 사양을 한 줄로 수집하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="928b12c02eeb60a25ebbe56b73b080bf2235439f" translate="yes" xml:space="preserve">
          <source>The modified source code text. This property is undefined if any fixable messages didn't exist.</source>
          <target state="translated">The modified source code text. This property is undefined if any fixable messages didn't exist.</target>
        </trans-unit>
        <trans-unit id="d8b8c078bf2e1f6851bd595f2c2f5cc6bbf13048" translate="yes" xml:space="preserve">
          <source>The module name can also be customized, just note that when using &lt;a href=&quot;https://docs.npmjs.com/misc/scope&quot;&gt;scoped modules&lt;/a&gt; it is not possible to omit the &lt;code&gt;eslint-config-&lt;/code&gt; prefix. Doing so would result in package naming conflicts, and thus in resolution errors in most of cases. For example a package named &lt;code&gt;@scope/eslint-config-myconfig&lt;/code&gt; vs &lt;code&gt;@scope/my-config&lt;/code&gt;, since both are valid scoped package names, the configuration should be specified as:</source>
          <target state="translated">모듈 이름을 사용자 지정할 수도 있습니다. &lt;a href=&quot;https://docs.npmjs.com/misc/scope&quot;&gt;범위가 지정된 모듈&lt;/a&gt; 을 사용할 때는 &lt;code&gt;eslint-config-&lt;/code&gt; 접두사 를 생략 할 수 없습니다 . 그렇게하면 패키지 이름 충돌이 발생하여 대부분의 경우 해결 오류가 발생합니다. 예를 들어, 패키지 이름 &lt;code&gt;@scope/eslint-config-myconfig&lt;/code&gt; VS &lt;code&gt;@scope/my-config&lt;/code&gt; 모두 유효 범위의 패키지 이름이므로 구성과 같이 지정한다 :</target>
        </trans-unit>
        <trans-unit id="391d507111f772a5e622a4978aa02bebdf000901" translate="yes" xml:space="preserve">
          <source>The most important difference in v1.0.0 is that all rules are off by default. We made this change after numerous requests to allow turning off the default rules from within configuration files. While that wasn't technically feasible, it was feasible to have all rules off by default and then re-enable rules in configuration files using &lt;code&gt;extends&lt;/code&gt;. As such, we've made the &lt;code&gt;--reset&lt;/code&gt; behavior the default and removed this command line option.</source>
          <target state="translated">v1.0.0에서 가장 중요한 차이점은 모든 규칙이 기본적으로 해제되어 있다는 것입니다. 구성 파일 내에서 기본 규칙을 해제 할 수 있도록 여러 번 요청한 후에이 변경을 수행했습니다. 기술적으로는 가능하지 않았지만 기본적으로 모든 규칙을 해제 한 다음 &lt;code&gt;extends&lt;/code&gt; 를 사용하여 구성 파일에서 규칙을 다시 활성화하는 것이 가능했습니다 . 따라서 &lt;code&gt;--reset&lt;/code&gt; 동작을 기본값으로 설정하고이 명령 줄 옵션을 제거했습니다.</target>
        </trans-unit>
        <trans-unit id="2981f174eb319000ec7b9dc71dff618ba3924b94" translate="yes" xml:space="preserve">
          <source>The most important method on &lt;code&gt;Linter&lt;/code&gt; is &lt;code&gt;verify()&lt;/code&gt;, which initiates linting of the given text. This method accepts three arguments:</source>
          <target state="translated">&lt;code&gt;Linter&lt;/code&gt; 에서 가장 중요한 방법 은 &lt;code&gt;verify()&lt;/code&gt; , 주어진 텍스트의 린트를 시작합니다. 이 메소드는 세 가지 인수를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="2d9309f4804540bc446c7db5a5a0e204ff20ebd8" translate="yes" xml:space="preserve">
          <source>The name of the function starts with uppercase.</source>
          <target state="translated">함수 이름은 대문자로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="c187d7bc3b11447dcbf3b003402ff51671b83ee4" translate="yes" xml:space="preserve">
          <source>The name of the rule (string)</source>
          <target state="translated">규칙의 이름 (문자열)</target>
        </trans-unit>
        <trans-unit id="3d05f85495e18f50c10102d3389fcbc9d5973e21" translate="yes" xml:space="preserve">
          <source>The names &lt;code&gt;&quot;semi&quot;&lt;/code&gt; and &lt;code&gt;&quot;quotes&quot;&lt;/code&gt; are the names of &lt;a href=&quot;https://eslint.org/docs/rules&quot;&gt;rules&lt;/a&gt; in ESLint. The first value is the error level of the rule and can be one of these values:</source>
          <target state="translated">이름 &lt;code&gt;&quot;semi&quot;&lt;/code&gt; 과 &lt;code&gt;&quot;quotes&quot;&lt;/code&gt; 의 이름입니다 &lt;a href=&quot;https://eslint.org/docs/rules&quot;&gt;규칙&lt;/a&gt; ESLint한다. 첫 번째 값은 규칙의 오류 수준이며 다음 값 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03f1e3c6076e63d911680ce1f195f2b2861a99e5" translate="yes" xml:space="preserve">
          <source>The next line starts with &lt;code&gt;[&lt;/code&gt;, &lt;code&gt;(&lt;/code&gt;, &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;,&lt;/code&gt;, &lt;code&gt;.&lt;/code&gt;, or some other binary operator that can only be found between two tokens in a single expression.</source>
          <target state="translated">다음으로 광고 시작 &lt;code&gt;[&lt;/code&gt; , &lt;code&gt;(&lt;/code&gt; , &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;,&lt;/code&gt; , &lt;code&gt;.&lt;/code&gt; , 또는 단일 식에서 두 토큰 사이에서 발견 될 수있는 일부 다른 이진 연산자.</target>
        </trans-unit>
        <trans-unit id="ed3de168e4acf1680325d171a28dd7b74b024412" translate="yes" xml:space="preserve">
          <source>The next line(s) have a &lt;code&gt;*&lt;/code&gt; aligned with the &lt;code&gt;*&lt;/code&gt; in the first line. Text is allowed on these lines.</source>
          <target state="translated">다음 줄 은 첫 줄에서 &lt;code&gt;*&lt;/code&gt; 와 &lt;code&gt;*&lt;/code&gt; 가 정렬되어 있습니다. 이 줄에는 텍스트가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="00194fc1917a102824f66484638b388a032a7482" translate="yes" xml:space="preserve">
          <source>The node contains all of the information necessary to figure out the line and column number of the offending text as well the source text representing the node.</source>
          <target state="translated">노드에는 문제를 일으키는 텍스트의 행 및 열 번호와 노드를 나타내는 소스 텍스트를 파악하는 데 필요한 모든 정보가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b4ed3f78adad10420e57b7e0edb1eca371c23d68" translate="yes" xml:space="preserve">
          <source>The number of errors that can be fixed automatically by the &lt;code&gt;fix&lt;/code&gt; constructor option.</source>
          <target state="translated">The number of errors that can be fixed automatically by the &lt;code&gt;fix&lt;/code&gt; constructor option.</target>
        </trans-unit>
        <trans-unit id="6d50e11c18c94c2f0420745923f450c9aeb9f0a2" translate="yes" xml:space="preserve">
          <source>The number of errors. This includes fixable errors.</source>
          <target state="translated">The number of errors. This includes fixable errors.</target>
        </trans-unit>
        <trans-unit id="ba2a30d0b9505f420e855f975645b4c8a258575c" translate="yes" xml:space="preserve">
          <source>The number of warnings that can be fixed automatically by the &lt;code&gt;fix&lt;/code&gt; constructor option.</source>
          <target state="translated">The number of warnings that can be fixed automatically by the &lt;code&gt;fix&lt;/code&gt; constructor option.</target>
        </trans-unit>
        <trans-unit id="91ed0bffbaeedc91108fa8391d7c91ea93e12b94" translate="yes" xml:space="preserve">
          <source>The number of warnings. This includes fixable warnings.</source>
          <target state="translated">The number of warnings. This includes fixable warnings.</target>
        </trans-unit>
        <trans-unit id="d45e635828bcb31db112256ea444b8c6bf3fd18e" translate="yes" xml:space="preserve">
          <source>The only acceptable time to have multiple single-line comments on successive lines is to comment out large sections of code. Multi-line comments should not be used for this purpose.</source>
          <target state="translated">연속적인 행에 여러 개의 단일 행 주석을 포함 할 수있는 유일한 시간은 큰 코드 섹션을 주석 처리하는 것입니다. 이 목적으로 여러 줄 주석을 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="6a644e143491953839301b85bb8b200e474de5ab" translate="yes" xml:space="preserve">
          <source>The only time you would compare a variable against itself is when you are testing for &lt;code&gt;NaN&lt;/code&gt;. However, it is far more appropriate to use &lt;code&gt;typeof x === 'number' &amp;amp;&amp;amp; isNaN(x)&lt;/code&gt; or the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN&quot;&gt;Number.isNaN ES2015 function&lt;/a&gt; for that use case rather than leaving the reader of the code to determine the intent of self comparison.</source>
          <target state="translated">변수와 자체를 비교하는 유일한 시간은 &lt;code&gt;NaN&lt;/code&gt; 을 테스트 할 때 입니다. 그러나 자체 비교 의도를 결정하기 위해 코드 리더를 남겨 두지 않고 해당 유스 케이스에 &lt;code&gt;typeof x === 'number' &amp;amp;&amp;amp; isNaN(x)&lt;/code&gt; 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN&quot;&gt;Number.isNaN ES2015 함수&lt;/a&gt; 를 사용하는 것이 훨씬 더 적합합니다 .</target>
        </trans-unit>
        <trans-unit id="fae2f2bc90a52f0d6909f6ceb19aaafac0a26360" translate="yes" xml:space="preserve">
          <source>The opening brace should be at the end of the line that begins the compound statement; the closing brace should begin a line and be indented to the beginning of the compound statement.</source>
          <target state="translated">여는 괄호는 복합 문을 시작하는 줄의 끝에 있어야합니다. 닫는 중괄호는 줄을 시작하고 복합 명령문의 시작 부분에 들여 쓰기해야합니다.</target>
        </trans-unit>
        <trans-unit id="abfabb83ce95a74f0937675f7094af1e6695a2c0" translate="yes" xml:space="preserve">
          <source>The opening brace should be on the same line as the containing statement.</source>
          <target state="translated">여는 중괄호는 포함 명령문과 같은 줄에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="e9b551f3ef4076d91cd7f96a1f41ae4787a40977" translate="yes" xml:space="preserve">
          <source>The option also has a string shorthand:</source>
          <target state="translated">이 옵션에는 문자열 속기도 있습니다.</target>
        </trans-unit>
        <trans-unit id="de7031af6085176060b0ac36063990d91e8f177b" translate="yes" xml:space="preserve">
          <source>The optional exception does not excuse this case, because the entire collection of property specifications spans 4 lines, not 1.</source>
          <target state="translated">속성 사양의 전체 컬렉션이 1이 아닌 4 줄에 걸쳐 있기 때문에 선택적 예외는이 경우를 변명하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dcedceca0a5fbd9f7abfd655550b7f46c22973d8" translate="yes" xml:space="preserve">
          <source>The options allow labels with loop or switch statements:</source>
          <target state="translated">이 옵션은 loop 또는 switch 문이있는 레이블을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="cf49b44308f034d8aba18fe071fc2b7ec04bd224" translate="yes" xml:space="preserve">
          <source>The options available and the expected syntax for &lt;code&gt;parserOptions&lt;/code&gt; is the same as those used in &lt;a href=&quot;../user-guide/configuring#specifying-parser-options&quot;&gt;configuration&lt;/a&gt;.</source>
          <target state="translated">사용 가능한 옵션 및 &lt;code&gt;parserOptions&lt;/code&gt; 의 예상 구문 은 &lt;a href=&quot;../user-guide/configuring#specifying-parser-options&quot;&gt;구성에&lt;/a&gt; 사용 된 것과 동일 합니다 .</target>
        </trans-unit>
        <trans-unit id="c4af5a293dd844cadf7c1778b14e98c1b7daf5ee" translate="yes" xml:space="preserve">
          <source>The original source code text. This property is undefined if any messages didn't exist or the &lt;code&gt;output&lt;/code&gt; property exists.</source>
          <target state="translated">The original source code text. This property is undefined if any messages didn't exist or the &lt;code&gt;output&lt;/code&gt; property exists.</target>
        </trans-unit>
        <trans-unit id="a61791ccd424eca040a7f63b8afadbed687c913a" translate="yes" xml:space="preserve">
          <source>The output will be</source>
          <target state="translated">출력은</target>
        </trans-unit>
        <trans-unit id="f4dc89186e373e825b6dfa59c8110b3946aeee21" translate="yes" xml:space="preserve">
          <source>The output would be:</source>
          <target state="translated">결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c021a3a657e4f53d4e449ea1c6f0c78f48d2adfc" translate="yes" xml:space="preserve">
          <source>The pair of 0-based indices in source code text to remove.</source>
          <target state="translated">The pair of 0-based indices in source code text to remove.</target>
        </trans-unit>
        <trans-unit id="046ede3288f3c1cadbd2cfefc7b488c9fd37084c" translate="yes" xml:space="preserve">
          <source>The path to the file whose configuration you would like to calculate. Directory paths are forbidden because ESLint cannot handle the &lt;code&gt;overrides&lt;/code&gt; setting.</source>
          <target state="translated">The path to the file whose configuration you would like to calculate. Directory paths are forbidden because ESLint cannot handle the &lt;code&gt;overrides&lt;/code&gt; setting.</target>
        </trans-unit>
        <trans-unit id="0831c2dd23b6e63812d13e269c384cd1d40181e7" translate="yes" xml:space="preserve">
          <source>The path to the file you want to check.</source>
          <target state="translated">The path to the file you want to check.</target>
        </trans-unit>
        <trans-unit id="cd939e136292c4dcd7638cc19ed24250e2872fad" translate="yes" xml:space="preserve">
          <source>The path to the file you want to check. The following values are allowed:</source>
          <target state="translated">The path to the file you want to check. The following values are allowed:</target>
        </trans-unit>
        <trans-unit id="9789ff50f50df37207f7264a43f1a689f0688f0a" translate="yes" xml:space="preserve">
          <source>The patterns are applied against the file path relative to the directory of the config file. For example, if your config file has the path &lt;code&gt;/Users/john/workspace/any-project/.eslintrc.js&lt;/code&gt; and the file you want to lint has the path &lt;code&gt;/Users/john/workspace/any-project/lib/util.js&lt;/code&gt;, then the pattern provided in &lt;code&gt;.eslintrc.js&lt;/code&gt; will be executed against the relative path &lt;code&gt;lib/util.js&lt;/code&gt;.</source>
          <target state="translated">패턴은 구성 파일의 디렉토리를 기준으로 파일 경로에 적용됩니다. 예를 들어, 구성 파일에 &lt;code&gt;/Users/john/workspace/any-project/.eslintrc.js&lt;/code&gt; 경로가 있고 보풀하려는 파일의 경로는 &lt;code&gt;/Users/john/workspace/any-project/lib/util.js&lt;/code&gt; 이면 &lt;code&gt;.eslintrc.js&lt;/code&gt; 에 제공된 패턴 이 상대 경로 &lt;code&gt;lib/util.js&lt;/code&gt; util.js 에 대해 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="d7c7d55489a5efe043679a245ed2e68741b450b6" translate="yes" xml:space="preserve">
          <source>The pitfalls of using objects as maps in JavaScript</source>
          <target state="translated">JavaScript에서 객체를 맵으로 사용하는 함정</target>
        </trans-unit>
        <trans-unit id="05157eccd9a4d06e6ff4c2778c2a6f7b853c19e7" translate="yes" xml:space="preserve">
          <source>The prefer-reflect rule will flag usage of any older method, suggesting to instead use the newer Reflect version.</source>
          <target state="translated">prefer-reflect 규칙은 이전 방법의 사용을 표시하여 대신 최신 Reflect 버전을 사용하도록 제안합니다.</target>
        </trans-unit>
        <trans-unit id="019176c59859ffc7e6915010bb0d29fc4116cb11" translate="yes" xml:space="preserve">
          <source>The primary Node.js API is &lt;code&gt;CLIEngine&lt;/code&gt;, which is the underlying utility that runs the ESLint command line interface. This object will read the filesystem for configuration and file information but will not output any results. Instead, it allows you direct access to the important information so you can deal with the output yourself.</source>
          <target state="translated">기본 Node.js API는 &lt;code&gt;CLIEngine&lt;/code&gt; 인데 이는 ESLint 명령 행 인터페이스를 실행하는 기본 유틸리티입니다. 이 객체는 구성 및 파일 정보에 대한 파일 시스템을 읽지 만 결과는 출력하지 않습니다. 대신 중요한 정보에 직접 액세스 할 수 있으므로 출력을 직접 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="c476b276186c6fb97acc415f8441c0d6359f3d36" translate="yes" xml:space="preserve">
          <source>The primary difference between &lt;code&gt;function&lt;/code&gt; declarations and &lt;code&gt;function expressions&lt;/code&gt; is that declarations are &lt;em&gt;hoisted&lt;/em&gt; to the top of the scope in which they are defined, which allows you to write code that uses the function before its declaration. For example:</source>
          <target state="translated">주요 차이점 &lt;code&gt;function&lt;/code&gt; 선언과 &lt;code&gt;function expressions&lt;/code&gt; 선언하는 것입니다 &lt;em&gt;게양&lt;/em&gt; 선언하기 전에 함수를 사용하여 코드를 작성 당신을 수 있습니다 그들이 정의 된 범위의 상단에. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cc5cca2ea790657770c377a55c8c2c9d38976e25" translate="yes" xml:space="preserve">
          <source>The primary reason to use asynchronous functions is typically to use the &lt;code&gt;await&lt;/code&gt; operator, such as this:</source>
          <target state="translated">비동기 함수를 사용하는 주요 이유는 일반적 으로 다음과 같은 &lt;code&gt;await&lt;/code&gt; 연산자 를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="27f63a6807abd8b3bd2aa20888273f48ea3fa67c" translate="yes" xml:space="preserve">
          <source>The primary script to use is &lt;code&gt;npm test&lt;/code&gt;, which does several things:</source>
          <target state="translated">사용할 기본 스크립트는 &lt;code&gt;npm test&lt;/code&gt; 이며 몇 가지 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="88571aeb3633660582e146f8ca69889ac98fb83d" translate="yes" xml:space="preserve">
          <source>The problem is when these developers work together in a project. This rule enforces a coding style where empty newlines are allowed or disallowed after &lt;code&gt;var&lt;/code&gt;, &lt;code&gt;let&lt;/code&gt;, or &lt;code&gt;const&lt;/code&gt; statements. It helps the code to look consistent across the entire project.</source>
          <target state="translated">문제는이 개발자들이 프로젝트에서 함께 일할 때입니다. 이 규칙은 &lt;code&gt;var&lt;/code&gt; , &lt;code&gt;let&lt;/code&gt; 또는 &lt;code&gt;const&lt;/code&gt; 문 다음에 빈 줄 바꿈이 허용되거나 허용되지 않는 코딩 스타일을 적용합니다 . 코드가 전체 프로젝트에서 일관되게 보이도록 도와줍니다.</target>
        </trans-unit>
        <trans-unit id="c7abf9c98248c9d5e551542e1f7cf64b22ee6b71" translate="yes" xml:space="preserve">
          <source>The problem you want to solve.</source>
          <target state="translated">해결하려는 문제.</target>
        </trans-unit>
        <trans-unit id="fbe43fced48ce154fc594e0d7efd5a4fe22b0e58" translate="yes" xml:space="preserve">
          <source>The process of submitting a pull request is fairly straightforward and generally follows the same pattern each time:</source>
          <target state="translated">풀 요청을 제출하는 프로세스는 매우 간단하며 일반적으로 매번 동일한 패턴을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="a05409697e85649207fda3ec4adf2978841d64e9" translate="yes" xml:space="preserve">
          <source>The promise that will be fulfilled after all files are written.</source>
          <target state="translated">The promise that will be fulfilled after all files are written.</target>
        </trans-unit>
        <trans-unit id="2a2cd5efb0c948ebdbe12aabca7fbb672ea3acab" translate="yes" xml:space="preserve">
          <source>The promise that will be fulfilled with a &lt;a href=&quot;#-formatter-type&quot;&gt;Formatter&lt;/a&gt; object.</source>
          <target state="translated">The promise that will be fulfilled with a &lt;a href=&quot;#-formatter-type&quot;&gt;Formatter&lt;/a&gt; object.</target>
        </trans-unit>
        <trans-unit id="478dfcc83dc754277166d46e9b3d38e748913611" translate="yes" xml:space="preserve">
          <source>The promise that will be fulfilled with a configuration object.</source>
          <target state="translated">The promise that will be fulfilled with a configuration object.</target>
        </trans-unit>
        <trans-unit id="c0fc0e0cd457cdd25ed6e640cda0efc522fcc0b6" translate="yes" xml:space="preserve">
          <source>The promise that will be fulfilled with an array of &lt;a href=&quot;#-lintresult-type&quot;&gt;LintResult&lt;/a&gt; objects.</source>
          <target state="translated">The promise that will be fulfilled with an array of &lt;a href=&quot;#-lintresult-type&quot;&gt;LintResult&lt;/a&gt; objects.</target>
        </trans-unit>
        <trans-unit id="aa291d0f16227cc6e0c9871b3f5369125da25d86" translate="yes" xml:space="preserve">
          <source>The promise that will be fulfilled with an array of &lt;a href=&quot;#-lintresult-type&quot;&gt;LintResult&lt;/a&gt; objects. This is an array (despite there being only one lint result) in order to keep the interfaces between this and the &lt;a href=&quot;#-eslintlintfilespatterns&quot;&gt;&lt;code&gt;eslint.lintFiles()&lt;/code&gt;&lt;/a&gt; method similar.</source>
          <target state="translated">The promise that will be fulfilled with an array of &lt;a href=&quot;#-lintresult-type&quot;&gt;LintResult&lt;/a&gt; objects. This is an array (despite there being only one lint result) in order to keep the interfaces between this and the &lt;a href=&quot;#-eslintlintfilespatterns&quot;&gt; &lt;code&gt;eslint.lintFiles()&lt;/code&gt; &lt;/a&gt; method similar.</target>
        </trans-unit>
        <trans-unit id="8a5e3b16efbb634d1ac4a691dd800a96c5e8a3a4" translate="yes" xml:space="preserve">
          <source>The promise that will be fulfilled with whether the file is ignored or not. If the file is ignored, then it will return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">The promise that will be fulfilled with whether the file is ignored or not. If the file is ignored, then it will return &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c3bb0c19b313c5a8f9e87aaba0c7d42779858d8a" translate="yes" xml:space="preserve">
          <source>The proponents of these extra spaces believe it make the code easier to read and can more easily highlight potential errors, such as:</source>
          <target state="translated">이 여분의 공간을지지하는 사람들은 코드를 더 쉽게 읽을 수 있고 다음과 같은 잠재적 오류를 더 쉽게 강조 할 수 있다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="842b4413185a6f29a14a60bf357af03cfc8c67fc" translate="yes" xml:space="preserve">
          <source>The pull request must have a description. The description should explain what you did and how its effects can be seen.</source>
          <target state="translated">풀 요청에는 설명이 있어야합니다. 설명은 당신이 한 일과 그 효과를 볼 수있는 방법을 설명해야합니다.</target>
        </trans-unit>
        <trans-unit id="9f51bbd346695224f5a3bba69d99964bfc48d685" translate="yes" xml:space="preserve">
          <source>The purpose is to avoid expressions such as &lt;code&gt;! a &amp;lt; b&lt;/code&gt; (which is equivalent to &lt;code&gt;(a ? 0 : 1) &amp;lt; b&lt;/code&gt;) when what is really intended is &lt;code&gt;!(a &amp;lt; b)&lt;/code&gt;.</source>
          <target state="translated">목적은 다음과 같은 표현을 피하는 것입니다 &lt;code&gt;! a &amp;lt; b&lt;/code&gt; (에 해당 &lt;code&gt;(a ? 0 : 1) &amp;lt; b&lt;/code&gt; ) 정말로 의도하는 때 &lt;code&gt;!(a &amp;lt; b)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d6c661a567da1e6f27caf7616e695a2df7785021" translate="yes" xml:space="preserve">
          <source>The purpose of the &lt;code&gt;delete&lt;/code&gt; operator is to remove a property from an object. Using the &lt;code&gt;delete&lt;/code&gt; operator on a variable might lead to unexpected behavior.</source>
          <target state="translated">&lt;code&gt;delete&lt;/code&gt; 연산자 의 목적은 객체에서 속성을 제거하는 것입니다. 변수 에서 &lt;code&gt;delete&lt;/code&gt; 연산자를 사용하면 예기치 않은 동작이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8dc19192de8fb3195f72308a36d5ed027027af0b" translate="yes" xml:space="preserve">
          <source>The range indexes of all tokens and comments must not overlap with the range of other tokens and comments.</source>
          <target state="translated">모든 토큰 및 주석의 범위 색인이 다른 토큰 및 주석의 범위와 겹치지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="b0a76dd0dfcefbc58816ee112b837c5543da7412" translate="yes" xml:space="preserve">
          <source>The reason for this is that &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; do type coercion which follows the rather obscure &lt;a href=&quot;https://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3&quot;&gt;Abstract Equality Comparison Algorithm&lt;/a&gt;. For instance, the following statements are all considered &lt;code&gt;true&lt;/code&gt;:</source>
          <target state="translated">그 이유는 &lt;code&gt;==&lt;/code&gt; 와 &lt;code&gt;!=&lt;/code&gt; 가 다소 모호한 &lt;a href=&quot;https://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3&quot;&gt;추상 평등 비교 알고리즘&lt;/a&gt; 을 따르는 유형 강제 변환 때문입니다 . 예를 들어, 다음 내용은 모두 &lt;code&gt;true&lt;/code&gt; 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="01205e0f79602a8ffcecdc5bb5ff7825b476d8a2" translate="yes" xml:space="preserve">
          <source>The replacement for &lt;code&gt;eslint-tester&lt;/code&gt; is called &lt;code&gt;RuleTester&lt;/code&gt;. It's a simplified version of &lt;code&gt;ESLintTester&lt;/code&gt; that's designed to work with any testing framework. This object is exposed by the package.</source>
          <target state="translated">&lt;code&gt;eslint-tester&lt;/code&gt; 의 대체를 RuleTester 라고 &lt;code&gt;RuleTester&lt;/code&gt; . 모든 테스트 프레임 워크에서 작동하도록 설계된 &lt;code&gt;ESLintTester&lt;/code&gt; 의 단순화 된 버전입니다 . 이 객체는 패키지에 의해 노출됩니다.</target>
        </trans-unit>
        <trans-unit id="ec0504699dd72d01190815f60c9e51a4931c510f" translate="yes" xml:space="preserve">
          <source>The resulting configuration file will be created in the current directory.</source>
          <target state="translated">결과 구성 파일이 현재 디렉토리에 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="e5b1d156a93c697ddb2fcff08bf4e5ddbeae4405" translate="yes" xml:space="preserve">
          <source>The return value is always a &lt;code&gt;Promise&lt;/code&gt;.</source>
          <target state="translated">반환 값은 항상 &lt;code&gt;Promise&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fed8bcfb8b284135209f390faca018017c1afbc2" translate="yes" xml:space="preserve">
          <source>The return value is an object containing the results of the linting operation. Here's an example of a report object:</source>
          <target state="translated">반환 값은 linting 작업 결과를 포함하는 객체입니다. 보고서 개체의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="66df5448c616e295ecb49452adc535d44bedae83" translate="yes" xml:space="preserve">
          <source>The returned value is a &lt;a href=&quot;scope-manager-interface&quot;&gt;&lt;code&gt;Scope&lt;/code&gt; object&lt;/a&gt; defined by the &lt;code&gt;eslint-scope&lt;/code&gt; package. The &lt;code&gt;Variable&lt;/code&gt; objects of global variables have some additional properties.</source>
          <target state="translated">반환 값은 &lt;code&gt;eslint-scope&lt;/code&gt; 패키지로 정의 된 &lt;a href=&quot;scope-manager-interface&quot;&gt; &lt;code&gt;Scope&lt;/code&gt; 객체&lt;/a&gt; 입니다. 전역 변수 의 &lt;code&gt;Variable&lt;/code&gt; 개체에는 몇 가지 추가 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fb2e185527cd54c372b96c8a8cf85ca7037ac9b" translate="yes" xml:space="preserve">
          <source>The rule &lt;code&gt;func-style&lt;/code&gt; has a default configuration of &lt;code&gt;&quot;expression&quot;&lt;/code&gt;, but in ESLint &lt;code&gt;1.x&lt;/code&gt;, &lt;code&gt;eslint:recommended&lt;/code&gt; defaulted it to &lt;code&gt;&quot;declaration&quot;&lt;/code&gt;.</source>
          <target state="translated">규칙 &lt;code&gt;func-style&lt;/code&gt; 의 기본 구성은 &lt;code&gt;&quot;expression&quot;&lt;/code&gt; 이지만 ESLint &lt;code&gt;1.x&lt;/code&gt; 에서는 &lt;code&gt;eslint:recommended&lt;/code&gt; 가 기본적으로 &lt;code&gt;&quot;declaration&quot;&lt;/code&gt; 으로 설정했습니다 .</target>
        </trans-unit>
        <trans-unit id="21a84406c09ff8a1049a29b0ba218718b7bf5a81" translate="yes" xml:space="preserve">
          <source>The rule &lt;code&gt;no-multiple-empty-lines&lt;/code&gt; has no default exceptions, but in ESLint &lt;code&gt;1.x&lt;/code&gt;, a default from &lt;code&gt;eslint:recommended&lt;/code&gt; was applied such that a maximum of two empty lines would be permitted.</source>
          <target state="translated">&lt;code&gt;no-multiple-empty-lines&lt;/code&gt; 규칙 에는 기본 예외가 없지만 ESLint &lt;code&gt;1.x&lt;/code&gt; 에서는 &lt;code&gt;eslint:recommended&lt;/code&gt; 의 기본값 이 적용되어 최대 두 개의 빈 줄이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="7adf5f9d34968505ac2e7499ab22de53834a46bf" translate="yes" xml:space="preserve">
          <source>The rule always ignores directive comments such as &lt;code&gt;/* eslint-disable */&lt;/code&gt;. Additionally, unless the mode is &lt;code&gt;&quot;starred-block&quot;&lt;/code&gt;, the rule ignores JSDoc comments.</source>
          <target state="translated">규칙은 항상 &lt;code&gt;/* eslint-disable */&lt;/code&gt; 와 같은 지시문 주석을 무시합니다 . 또한 모드가 &lt;code&gt;&quot;starred-block&quot;&lt;/code&gt; 이 아니면 규칙은 JSDoc 주석을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="a5ddf9fff8f7365d084f3f3463580ae57890e091" translate="yes" xml:space="preserve">
          <source>The rule applies to the operators listed in the above table. It does not report the logical assignment operators &lt;code&gt;&amp;amp;&amp;amp;=&lt;/code&gt;, &lt;code&gt;||=&lt;/code&gt;, and &lt;code&gt;??=&lt;/code&gt; because their short-circuiting behavior is different from the other assignment operators.</source>
          <target state="translated">The rule applies to the operators listed in the above table. It does not report the logical assignment operators &lt;code&gt;&amp;amp;&amp;amp;=&lt;/code&gt; , &lt;code&gt;||=&lt;/code&gt; , and &lt;code&gt;??=&lt;/code&gt; because their short-circuiting behavior is different from the other assignment operators.</target>
        </trans-unit>
        <trans-unit id="1171a6f455e8b040c25a7ba3151c5477780f5c03" translate="yes" xml:space="preserve">
          <source>The rule can also be configured to discourage the use of parens when they are not required:</source>
          <target state="translated">필요하지 않은 경우 Parens 사용을 권장하지 않도록 규칙을 구성 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8d163ee49a74afcc2907a73bba3064a962e824c" translate="yes" xml:space="preserve">
          <source>The rule cannot easily verify that the assignment is safe (e.g. if an assigned variable is local and would not be readable from anywhere else while the function is paused).</source>
          <target state="translated">규칙은 할당이 안전한지 쉽게 확인할 수 없습니다 (예 : 할당 된 변수가 로컬이고 함수가 일시 중지 된 동안 다른 곳에서 읽을 수없는 경우).</target>
        </trans-unit>
        <trans-unit id="4e9a5ee2475613eb335126f52cf5aaa9b33b67b5" translate="yes" xml:space="preserve">
          <source>The rule disallows octal literals.</source>
          <target state="translated">이 규칙은 8 진 리터럴을 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bed31bfa847f3bb2487f9e377612a105ec30b864" translate="yes" xml:space="preserve">
          <source>The rule does not disallow all use of the &lt;code&gt;RegExp&lt;/code&gt; constructor. It should be still used for dynamically generated regular expressions.</source>
          <target state="translated">규칙에 따라 &lt;code&gt;RegExp&lt;/code&gt; 생성자를 모두 사용할 수있는 것은 아닙니다 . 동적으로 생성 된 정규식에 계속 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="888d43f5f339c3eab2911b0abe2728f2ab5aeaab" translate="yes" xml:space="preserve">
          <source>The rule has a second object with a single key, &lt;code&gt;enforceForRenamedProperties&lt;/code&gt;, which determines whether the &lt;code&gt;object&lt;/code&gt; destructuring applies to renamed variables.</source>
          <target state="translated">이 규칙에는 단일 키 ( &lt;code&gt;enforceForRenamedProperties&lt;/code&gt; 가있는 두 번째 객체가 있으며 ,이 키 를 사용하면 &lt;code&gt;object&lt;/code&gt; 변경이 이름이 바뀐 변수에 적용 되는지 여부가 결정 됩니다.</target>
        </trans-unit>
        <trans-unit id="3437f8bb30162415e42db275afc1baef0285612b" translate="yes" xml:space="preserve">
          <source>The rule name that generates this lint message. If this message is generated by the ESLint core rather than rules, this is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">The rule name that generates this lint message. If this message is generated by the ESLint core rather than rules, this is &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac3e6cce45a94e0899d9d17de8ece5be87643b66" translate="yes" xml:space="preserve">
          <source>The rule naming conventions for ESLint are fairly simple:</source>
          <target state="translated">ESLint의 규칙 명명 규칙은 매우 간단합니다.</target>
        </trans-unit>
        <trans-unit id="6a2d5c1c9e0896db23badf6274b8965eaac23cce" translate="yes" xml:space="preserve">
          <source>The rule object itself (see &lt;a href=&quot;working-with-rules&quot;&gt;&quot;working with rules&quot;&lt;/a&gt;)</source>
          <target state="translated">규칙 객체 자체 ( &lt;a href=&quot;working-with-rules&quot;&gt;&quot;규칙 작업&quot;&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="573e671e86a4cf56bbe5f205a42e8701c29ec3d5" translate="yes" xml:space="preserve">
          <source>The rule offers one object option, &lt;code&gt;allowAllPropertiesOnSameLine&lt;/code&gt; (a deprecated synonym is &lt;code&gt;allowMultiplePropertiesPerLine&lt;/code&gt;). If you set it to &lt;code&gt;true&lt;/code&gt;, object literals such as the first two above, with all property specifications on the same line, will be permitted, but one like</source>
          <target state="translated">이 규칙은 &lt;code&gt;allowAllPropertiesOnSameLine&lt;/code&gt; 이라는 하나의 객체 옵션을 제공합니다 (더 이상 사용되지 않는 동의어는 &lt;code&gt;allowMultiplePropertiesPerLine&lt;/code&gt; ). &lt;code&gt;true&lt;/code&gt; 로 설정하면 모든 속성 사양이 같은 줄에있는 위의 처음 두 개와 같은 객체 리터럴이 허용되지만</target>
        </trans-unit>
        <trans-unit id="eb4b25449f8d19c4a4b92c230c486f587789325f" translate="yes" xml:space="preserve">
          <source>The rule prohibits the colocation on any line of at least 1 character of one property specification with at least 1 character of any other property specification. For example, the rule prohibits</source>
          <target state="translated">이 규칙은 하나의 특성 스펙에서 하나 이상의 문자를 다른 특성 스펙에서 하나 이상의 문자로 배치하는 것을 금지합니다. 예를 들어, 규칙은</target>
        </trans-unit>
        <trans-unit id="bdcc4c0ed6a72ea505652fd2189129b9ba9488a3" translate="yes" xml:space="preserve">
          <source>The rule should warn against code that tries to compare against -0, since that will not work as intended. That is, code like x === -0 will pass for both +0 and -0. The author probably intended Object.is(x, -0).</source>
          <target state="translated">규칙은 -0과 비교하려는 코드에 대해 경고해야합니다. 의도 된대로 작동하지 않기 때문입니다. 즉, x === -0과 같은 코드는 +0과 -0 모두에 전달됩니다. 저자는 아마도 Object.is (x, -0)을 의도했을 것입니다.</target>
        </trans-unit>
        <trans-unit id="9b89d3d9863252a32c9946759fd7f3504dc7b79d" translate="yes" xml:space="preserve">
          <source>The rule takes a single option - an array of possible callback names - which may include object methods. The default callback names are &lt;code&gt;callback&lt;/code&gt;, &lt;code&gt;cb&lt;/code&gt;, &lt;code&gt;next&lt;/code&gt;.</source>
          <target state="translated">규칙에는 단일 콜백 이름 배열 인 단일 옵션이 있으며 여기에는 객체 메소드가 포함될 수 있습니다. 기본 콜백 이름은 &lt;code&gt;callback&lt;/code&gt; , &lt;code&gt;cb&lt;/code&gt; , &lt;code&gt;next&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e78c1edcadc43d22698299cf6fb661f963ea1c1d" translate="yes" xml:space="preserve">
          <source>The rule takes a single string option: the name of the error parameter. The default is &lt;code&gt;&quot;err&quot;&lt;/code&gt;.</source>
          <target state="translated">규칙에는 단일 문자열 옵션 인 오류 매개 변수의 이름이 사용됩니다. 기본값은 &lt;code&gt;&quot;err&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="73945e310046d0fe600a76487db931bee8eb7989" translate="yes" xml:space="preserve">
          <source>The rule takes an option which specifies when it should be applied. It can be set to one of the following values:</source>
          <target state="translated">규칙은 적용시기를 지정하는 옵션을 사용합니다. 다음 값 중 하나로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c17458aebea2edf7596655f8173de5c166baa09e" translate="yes" xml:space="preserve">
          <source>The rule takes one option, a string, which must contain one of the following values:</source>
          <target state="translated">이 규칙은 다음 옵션 중 하나를 포함해야하는 하나의 옵션 인 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1f25147392b3d78c1603fd60eeee2d70ca798f11" translate="yes" xml:space="preserve">
          <source>The rule takes one option, a string:</source>
          <target state="translated">규칙은 하나의 옵션 인 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="742233dad80fe18547618108d6a2b86bff76a785" translate="yes" xml:space="preserve">
          <source>The rule takes one option, an object, which has two keys &lt;code&gt;before&lt;/code&gt; and &lt;code&gt;after&lt;/code&gt; having boolean values &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">규칙은 하나 개의 옵션, 두 개의 키를 가진 개체, 소요 &lt;code&gt;before&lt;/code&gt; 과 &lt;code&gt;after&lt;/code&gt; 부울 값을 가진 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="827020a96c9caecec65cc7a0552676f015b27688" translate="yes" xml:space="preserve">
          <source>The rule takes one option, an object, which has two keys &lt;code&gt;before&lt;/code&gt; and &lt;code&gt;after&lt;/code&gt; having boolean values &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. If &lt;code&gt;before&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, space is enforced before semicolons and if it's &lt;code&gt;false&lt;/code&gt;, space is disallowed before semicolons. If &lt;code&gt;after&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, space is enforced after semicolons and if it's &lt;code&gt;false&lt;/code&gt;, space is disallowed after semicolons. The &lt;code&gt;after&lt;/code&gt; option will be only applied if a semicolon is not at the end of line.</source>
          <target state="translated">규칙은 하나 개의 옵션, 두 개의 키를 가진 개체, 소요 &lt;code&gt;before&lt;/code&gt; 과 &lt;code&gt;after&lt;/code&gt; 부울 값을 가진 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; . 경우 &lt;code&gt;before&lt;/code&gt; 인 &lt;code&gt;true&lt;/code&gt; , 공간이 그것의 세미콜론 전과 경우 적용됩니다 &lt;code&gt;false&lt;/code&gt; , 공간은 세미콜론 전에 허용되지 않습니다. 경우 &lt;code&gt;after&lt;/code&gt; 있다 &lt;code&gt;true&lt;/code&gt; , 공간 세미콜론 후 적용됩니다하고 있다면 &lt;code&gt;false&lt;/code&gt; , 공간은 세미콜론 후 허용되지 않습니다. &lt;code&gt;after&lt;/code&gt; 세미콜론은 줄의 끝에 아닌 경우 옵션은 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="96c7f241e413db9d83cd41a7c8e69e1a5a46c14d" translate="yes" xml:space="preserve">
          <source>The rule takes one or more strings as options: the names of restricted identifiers.</source>
          <target state="translated">규칙은 하나 이상의 문자열을 옵션으로 사용합니다 (제한된 식별자의 이름).</target>
        </trans-unit>
        <trans-unit id="4375aa6346f33b27f068e7c881fdcd22248263e0" translate="yes" xml:space="preserve">
          <source>The rule takes one or more strings as options: the names of restricted modules.</source>
          <target state="translated">규칙은 하나 이상의 문자열을 옵션으로 사용합니다 : 제한된 모듈의 이름.</target>
        </trans-unit>
        <trans-unit id="a9cca4aaa304d533ffa99e0d4d45692dc6af248a" translate="yes" xml:space="preserve">
          <source>The rule takes one or two options. The first is a string, which can be:</source>
          <target state="translated">이 규칙에는 하나 또는 두 가지 옵션이 있습니다. 첫 번째 문자열은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2047f79a374a9de4c018efebf01b37f2c42427b1" translate="yes" xml:space="preserve">
          <source>The rule takes two options.</source>
          <target state="translated">이 규칙에는 두 가지 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="47e30af986fb27902392df154c435e433c1df14f" translate="yes" xml:space="preserve">
          <source>The rule takes two options:</source>
          <target state="translated">이 규칙에는 두 가지 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8014e10667a7389e5554d8b3b067d38491926c25" translate="yes" xml:space="preserve">
          <source>The rules for ASI are relatively straightforward: As once described by Isaac Schlueter, a newline character always ends a statement, just like a semicolon, &lt;strong&gt;except&lt;/strong&gt; where one of the following is true:</source>
          <target state="translated">ASI의 규칙은 비교적 간단합니다. Isaac Schlueter가 설명한대로 줄 바꿈 문자 는 다음 중 하나에 해당하는 &lt;strong&gt;경우를 제외하고&lt;/strong&gt; 항상 세미콜론과 같이 명령문을 종료 합니다.</target>
        </trans-unit>
        <trans-unit id="031820acd6f073ce407b24b6015d596945b36976" translate="yes" xml:space="preserve">
          <source>The rules in your custom rules directory must follow the same format as bundled rules to work properly. You can also specify multiple locations for custom rules by including multiple &lt;code&gt;--rulesdir&lt;/code&gt; options:</source>
          <target state="translated">사용자 정의 규칙 디렉토리의 규칙은 번들 규칙과 동일한 형식을 따라야 제대로 작동합니다. 여러 개의 &lt;code&gt;--rulesdir&lt;/code&gt; 옵션 을 포함하여 사용자 정의 규칙의 여러 위치를 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f407752be68d13cfd5b93589acf43759c14d2f6" translate="yes" xml:space="preserve">
          <source>The same rule does apply to scoped packages:</source>
          <target state="translated">범위가 지정된 패키지에도 동일한 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="bfddd41eadd81befb51598e392aaccc185efc70f" translate="yes" xml:space="preserve">
          <source>The second argument is an object with one key, &lt;code&gt;&quot;exceptions&quot;&lt;/code&gt;. The value is an array of string patterns which are considered exceptions to the rule. It is important to note that the exceptions are ignored if the first argument is &lt;code&gt;&quot;never&quot;&lt;/code&gt;. Exceptions cannot be mixed.</source>
          <target state="translated">두 번째 인수는 &lt;code&gt;&quot;exceptions&quot;&lt;/code&gt; 키가있는 객체입니다 . 이 값은 규칙에 대한 예외로 간주되는 문자열 패턴의 배열입니다. 첫 번째 인수가 &lt;code&gt;&quot;never&quot;&lt;/code&gt; 이면 예외가 무시된다는 점에 유의해야합니다 . 예외는 섞일 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2e888e2ddf0328509e3f74a9a7c6bebd8faf02e4" translate="yes" xml:space="preserve">
          <source>The second is to save the file wherever you would like and pass its location to the CLI using the &lt;code&gt;-c&lt;/code&gt; option, such as:</source>
          <target state="translated">두 번째는 원하는 위치에 파일을 저장하고 &lt;code&gt;-c&lt;/code&gt; 옵션을 사용하여 파일의 위치를 ​​CLI에 전달하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="414ed43decb6eceb64655ac8086b20e4b3916b91" translate="yes" xml:space="preserve">
          <source>The second one is an object for more fine-grained configuration when the first option is &lt;code&gt;&quot;as-needed&quot;&lt;/code&gt;. Currently, the only available option is &lt;code&gt;requireReturnForObjectLiteral&lt;/code&gt;, a boolean property. It's &lt;code&gt;false&lt;/code&gt; by default. If set to &lt;code&gt;true&lt;/code&gt;, it requires braces and an explicit return for object literals.</source>
          <target state="translated">두 번째 옵션은 첫 번째 옵션이 &lt;code&gt;&quot;as-needed&quot;&lt;/code&gt; 경우보다 세밀한 구성을위한 객체입니다 . 현재 사용 가능한 유일한 옵션은 부울 특성 인 &lt;code&gt;requireReturnForObjectLiteral&lt;/code&gt; 입니다. 그건 &lt;code&gt;false&lt;/code&gt; 기본적으로. &lt;code&gt;true&lt;/code&gt; 로 설정되면 중괄호와 객체 리터럴에 대한 명시적인 리턴이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="6fa0c837ba16265ad24b0a06aa85ae08d877f9ec" translate="yes" xml:space="preserve">
          <source>The second parameter &lt;code&gt;options&lt;/code&gt; is omittable.</source>
          <target state="translated">The second parameter &lt;code&gt;options&lt;/code&gt; is omittable.</target>
        </trans-unit>
        <trans-unit id="13894c1b5ba8814ae6cea3f9f081dfbf8a0d8858" translate="yes" xml:space="preserve">
          <source>The selector &quot;&lt;code&gt;Identifier&lt;/code&gt;&quot; will match all &lt;code&gt;Identifier&lt;/code&gt; nodes in the program. In this case, the selector will match the nodes for &lt;code&gt;foo&lt;/code&gt;, &lt;code&gt;bar&lt;/code&gt;, and &lt;code&gt;baz&lt;/code&gt;.</source>
          <target state="translated">선택기 &quot; &lt;code&gt;Identifier&lt;/code&gt; &quot;는 프로그램의 모든 &lt;code&gt;Identifier&lt;/code&gt; 노드 와 일치합니다 . 이 경우 선택기는 &lt;code&gt;foo&lt;/code&gt; , &lt;code&gt;bar&lt;/code&gt; 및 &lt;code&gt;baz&lt;/code&gt; 의 노드와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="d627846098bcddfc8705e956620c4e04bad2e321" translate="yes" xml:space="preserve">
          <source>The severity of this message. &lt;code&gt;1&lt;/code&gt; means warning and &lt;code&gt;2&lt;/code&gt; means error.</source>
          <target state="translated">The severity of this message. &lt;code&gt;1&lt;/code&gt; means warning and &lt;code&gt;2&lt;/code&gt; means error.</target>
        </trans-unit>
        <trans-unit id="8edd9e143d8665e59cc0b39cb5fd1623512f2c40" translate="yes" xml:space="preserve">
          <source>The shortened object literal syntax for generators is not affected by this rule.</source>
          <target state="translated">생성기의 단축 된 객체 리터럴 구문은이 규칙의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="05a4cde718543d121082d5debd9a3bdb1d814202" translate="yes" xml:space="preserve">
          <source>The simplest example is to use just &lt;code&gt;node&lt;/code&gt; and &lt;code&gt;message&lt;/code&gt;:</source>
          <target state="translated">가장 간단한 예는 &lt;code&gt;node&lt;/code&gt; 와 &lt;code&gt;message&lt;/code&gt; 만 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="58e6895bfed7fd7cc1d658c75e9fdd7ba3d0ec89" translate="yes" xml:space="preserve">
          <source>The simplest selector is just a node type. A node type selector will match all nodes with the given type. For example, consider the following program:</source>
          <target state="translated">가장 간단한 선택기는 노드 유형입니다. 노드 유형 선택기는 주어진 유형의 모든 노드와 일치합니다. 예를 들어 다음 프로그램을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="62b57f47427459031359008bfc01d02938d4e4ea" translate="yes" xml:space="preserve">
          <source>The single-declaration school of thought is based in pre-ECMAScript 6 behaviors, where there was no such thing as block scope, only function scope. Since all &lt;code&gt;var&lt;/code&gt; statements are hoisted to the top of the function anyway, some believe that declaring all variables in a single declaration at the top of the function removes confusion around scoping rules.</source>
          <target state="translated">단일 선언 학교는 ECMAScript 6 이전의 행동을 기반으로하며, 블록 범위와 기능 범위 만있는 것은 아닙니다. 어쨌든 모든 &lt;code&gt;var&lt;/code&gt; 문이 함수의 최상위에 올려 지기 때문에 일부 함수는 함수의 맨 위에 단일 선언으로 모든 변수를 선언하면 범위 지정 규칙에 대한 혼란을 제거한다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="3f23c0f8e2212324dafb94566a41cfac12779d1c" translate="yes" xml:space="preserve">
          <source>The source code text to check.</source>
          <target state="translated">The source code text to check.</target>
        </trans-unit>
        <trans-unit id="98081cf0b97551ce142d7f451c1b647ed7d9f73b" translate="yes" xml:space="preserve">
          <source>The source file for a rule exports an object with the following properties.</source>
          <target state="translated">규칙의 소스 파일은 다음 특성으로 오브젝트를 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="13c2d1557a31408916c7784e491c197a095f73af" translate="yes" xml:space="preserve">
          <source>The spacing after the semicolon if it is the first token in the line.</source>
          <target state="translated">세미콜론 뒤의 간격은 줄의 첫 번째 토큰 인 경우입니다.</target>
        </trans-unit>
        <trans-unit id="cb8aafac65e7fc97800fb3d3dac293cf6812e694" translate="yes" xml:space="preserve">
          <source>The spacing around the semicolon in a for loop with an empty condition (&lt;code&gt;for(;;)&lt;/code&gt;).</source>
          <target state="translated">빈 조건 ( &lt;code&gt;for(;;)&lt;/code&gt; )이 있는 for 루프에서 세미콜론 주위 간격 입니다.</target>
        </trans-unit>
        <trans-unit id="e3e73e8052d68647147779e7d358e891ec3d4c7d" translate="yes" xml:space="preserve">
          <source>The spacing before the semicolon if it is after an opening parenthesis (&lt;code&gt;(&lt;/code&gt; or &lt;code&gt;{&lt;/code&gt;), or the spacing after the semicolon if it is before a closing parenthesis (&lt;code&gt;)&lt;/code&gt; or &lt;code&gt;}&lt;/code&gt;). That spacing is checked by &lt;code&gt;space-in-parens&lt;/code&gt; or &lt;code&gt;block-spacing&lt;/code&gt;.</source>
          <target state="translated">세미콜론 앞의 간격은 여는 괄호 뒤에있는 경우 ( &lt;code&gt;(&lt;/code&gt; 또는 &lt;code&gt;{&lt;/code&gt; ), 세미콜론 뒤의 간격은 닫는 괄호 ( &lt;code&gt;)&lt;/code&gt; 또는 &lt;code&gt;}&lt;/code&gt; 앞에있는 것입니다 . 이 간격은 &lt;code&gt;space-in-parens&lt;/code&gt; &lt;code&gt;block-spacing&lt;/code&gt; 또는 블록 간격으로 확인됩니다 .</target>
        </trans-unit>
        <trans-unit id="115bcb8edde69d7ab538f77d4ffd79b7c96251f6" translate="yes" xml:space="preserve">
          <source>The special value &lt;code&gt;null&lt;/code&gt; should be used only in the following situations:</source>
          <target state="translated">특수 값 &lt;code&gt;null&lt;/code&gt; 은 다음 상황에서만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="55d71491bd24bf8e9266ef7d9b3ed94580c8ef81" translate="yes" xml:space="preserve">
          <source>The standard style, in which commas are placed at the end of the current line</source>
          <target state="translated">현재 줄의 끝에 쉼표가있는 표준 스타일</target>
        </trans-unit>
        <trans-unit id="66b17246512ea6227166b244bbc0ac43dcd2b7c9" translate="yes" xml:space="preserve">
          <source>The statement beginning keyword, such as &lt;code&gt;if&lt;/code&gt;, should be followed by one space and the opening brace should be preceded by a space.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 와 같은 명령문 시작 키워드 뒤에 공백이 하나 있어야하고 여는 중괄호 앞에 공백이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="940d15ed0a28b1df513a69296639eec227beace3" translate="yes" xml:space="preserve">
          <source>The statement has an unclosed paren, array literal, or object literal or ends in some other way that is not a valid way to end a statement. (For instance, ending with &lt;code&gt;.&lt;/code&gt; or &lt;code&gt;,&lt;/code&gt;.)</source>
          <target state="translated">명령문에 닫히지 않은 paren, array 리터럴 또는 오브젝트 리터럴이 있거나 명령문을 종료하는 올바른 방법이 아닌 다른 방식으로 끝납니다. (예 : &lt;code&gt;.&lt;/code&gt; 또는 &lt;code&gt;,&lt;/code&gt; 로 끝나는 )</target>
        </trans-unit>
        <trans-unit id="ad8b8f54b2a420ddeed65e63d39098cd71d92cbc" translate="yes" xml:space="preserve">
          <source>The static analysis of this rule does not detect that the program calls the callback from within a nested function or an immediately-invoked function expression (IIFE).</source>
          <target state="translated">이 규칙의 정적 분석은 프로그램이 중첩 함수 또는 즉시 호출 된 함수 표현식 (IIFE) 내에서 콜백을 호출 함을 감지하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f3fcd362b8cea026256d5c99fc33540bb48255c4" translate="yes" xml:space="preserve">
          <source>The static analysis of this rule does not detect that the program calls the callback if it is an argument of a function (for example, &lt;code&gt;setTimeout&lt;/code&gt;).</source>
          <target state="translated">이 규칙의 정적 분석에서는 프로그램이 함수의 인수 인 경우 (예 : &lt;code&gt;setTimeout&lt;/code&gt; ) 콜백을 호출하는 것을 감지하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b0d50eb0c6a5a75a5254c188fa79ce03846654c4" translate="yes" xml:space="preserve">
          <source>The static analysis of this rule does not detect that the program calls the callback only one time in each branch of an &lt;code&gt;if&lt;/code&gt; statement.</source>
          <target state="translated">이 규칙의 정적 분석은 프로그램이 &lt;code&gt;if&lt;/code&gt; 문의 각 분기에서 한 번만 콜백을 호출한다는 것을 감지하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2f6cfcf93f0774ec1b281ebd4cefac2327a634e4" translate="yes" xml:space="preserve">
          <source>The string and object formats can be freely mixed in the configuration as needed.</source>
          <target state="translated">필요에 따라 구성에서 문자열 및 객체 형식을 자유롭게 혼합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd57f78073587288601a6f8bd191a69e0806d4ed" translate="yes" xml:space="preserve">
          <source>The string option does not check async arrow function expressions for backward compatibility.</source>
          <target state="translated">문자열 옵션은 이전 버전과의 호환성을 위해 비동기 화살표 함수 표현식을 확인하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="311d87885350cd8d74996d157aa1c8fa01351e72" translate="yes" xml:space="preserve">
          <source>The syntax for AST selectors is similar to the syntax for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors&quot;&gt;CSS selectors&lt;/a&gt;. If you've used CSS selectors before, the syntax for AST selectors should be easy to understand.</source>
          <target state="translated">AST 선택기의 구문은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors&quot;&gt;CSS 선택기&lt;/a&gt; 의 구문과 유사합니다 . 이전에 CSS 선택기를 사용한 적이 있다면 AST 선택기의 구문을 이해하기 쉬워야합니다.</target>
        </trans-unit>
        <trans-unit id="224d6b2ad3ce554f3d0f9f8c4d66cbd9efd8197b" translate="yes" xml:space="preserve">
          <source>The syntax to specify restricted imports looks like this:</source>
          <target state="translated">제한된 가져 오기를 지정하는 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b7efceeec030359c477714b00506090fb8984485" translate="yes" xml:space="preserve">
          <source>The ternary operator is used to conditionally assign a value to a variable. Some believe that the use of ternary operators leads to unclear code.</source>
          <target state="translated">삼항 연산자는 조건부로 변수에 값을 할당하는 데 사용됩니다. 일부는 삼항 연산자를 사용하면 코드가 명확하지 않다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="d10f8a42895796da61c03baea8c9b4879c335514" translate="yes" xml:space="preserve">
          <source>The ternary operator should be used only for assigning values conditionally and never as a shortcut for an &lt;code&gt;if&lt;/code&gt; statement.</source>
          <target state="translated">삼항 연산자는 조건부로 값을 할당하는 경우에만 사용해야하며 &lt;code&gt;if&lt;/code&gt; 문의 바로 가기로 사용해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="f096cdc8dc30e248084bfa4304f67adc152c3c50" translate="yes" xml:space="preserve">
          <source>The testing takes a few minutes to complete. If any tests fail, that likely means one or more parts of the environment setup didn't complete correctly. The upstream tests always pass.</source>
          <target state="translated">테스트는 완료하는 데 몇 분이 걸립니다. 테스트가 실패하면 환경 설정의 하나 이상의 부분이 올바르게 완료되지 않았 음을 의미합니다. 업스트림 테스트는 항상 통과합니다.</target>
        </trans-unit>
        <trans-unit id="aa432e2f60af21e69cfa908f06604c8b4d0ae385" translate="yes" xml:space="preserve">
          <source>The text to add.</source>
          <target state="translated">The text to add.</target>
        </trans-unit>
        <trans-unit id="7bbb1f82d6c0a19e1279187e629a297da44271f1" translate="yes" xml:space="preserve">
          <source>The thing that makes ESLint different from other linters is the ability to define custom rules at runtime. This is perfect for rules that are specific to your project or company and wouldn't make sense for ESLint to ship with. With runtime rules, you don't have to wait for the next version of ESLint or be disappointed that your rule isn't general enough to apply to the larger JavaScript community, just write your rules and include them at runtime.</source>
          <target state="translated">ESLint를 다른 린터와 다르게 만드는 것은 런타임에 사용자 정의 규칙을 정의하는 기능입니다. 이는 프로젝트 또는 회사 고유의 규칙에 적합하며 ESLint와 함께 제공되는 것은 적합하지 않습니다. 런타임 규칙을 사용하면 ESLint의 다음 버전을 기다릴 필요가 없으며 규칙이 더 큰 JavaScript 커뮤니티에 적용하기에 충분하지 않다는 것에 실망하지 않아도됩니다. 규칙을 작성하여 런타임에 포함시키기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="aeba12234ad663f0a0ec6980e71a7b41b7d994ef" translate="yes" xml:space="preserve">
          <source>The thinking is that it's better to always explicitly state what the default behavior should be so that it's clear whether or not the developer forgot to include the default behavior by mistake.</source>
          <target state="translated">사고는 기본 행동이 무엇인지 명시 적으로 명시하는 것이 더 낫기 때문에 개발자가 실수로 기본 행동을 포함시키는 것을 잊었는지 여부가 명확 해집니다.</target>
        </trans-unit>
        <trans-unit id="da7d071d3f4e1e51df3ea8518936e97a10e59509" translate="yes" xml:space="preserve">
          <source>The three error levels allow you fine-grained control over how ESLint applies rules (for more configuration options and details, see the &lt;a href=&quot;user-guide/configuring&quot;&gt;configuration docs&lt;/a&gt;).</source>
          <target state="translated">세 가지 오류 수준을 통해 ESLint가 규칙을 적용하는 방법을 세밀하게 제어 할 수 있습니다 (자세한 구성 옵션 및 세부 사항은 &lt;a href=&quot;user-guide/configuring&quot;&gt;구성 문서&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="df9af8c915bee6673ff22d532ac03047c8960a90" translate="yes" xml:space="preserve">
          <source>The top-level report object also has &lt;code&gt;errorCount&lt;/code&gt; and &lt;code&gt;warningCount&lt;/code&gt; which give the exact number of errors and warnings respectively on all the files. Additionally, &lt;code&gt;usedDeprecatedRules&lt;/code&gt; signals any deprecated rules used and their replacement (if available). Specifically, it is an array of objects with properties like so:</source>
          <target state="translated">The top-level report object also has &lt;code&gt;errorCount&lt;/code&gt; and &lt;code&gt;warningCount&lt;/code&gt; which give the exact number of errors and warnings respectively on all the files. Additionally, &lt;code&gt;usedDeprecatedRules&lt;/code&gt; signals any deprecated rules used and their replacement (if available). Specifically, it is an array of objects with properties like so:</target>
        </trans-unit>
        <trans-unit id="41d769ab16b1f7f3308de0b859c5b9860b2b26e5" translate="yes" xml:space="preserve">
          <source>The top-level report object also has &lt;code&gt;errorCount&lt;/code&gt; and &lt;code&gt;warningCount&lt;/code&gt; which give the exact number of errors and warnings respectively on all the files. Additionally, &lt;code&gt;usedDeprecatedRules&lt;/code&gt; signals any deprecated rules used and their replacement (if available). Specifically, it is array of objects with properties like so:</source>
          <target state="translated">최상위 보고서 개체에는 &lt;code&gt;errorCount&lt;/code&gt; 및 &lt;code&gt;warningCount&lt;/code&gt; 가 있어 모든 파일에서 각각 정확한 수의 오류 및 경고를 제공합니다. 또한 &lt;code&gt;usedDeprecatedRules&lt;/code&gt; 는 사용되지 않는 규칙과 교체 (사용 가능한 경우)를 알려줍니다 . 특히, 다음과 같은 속성을 가진 객체의 배열입니다.</target>
        </trans-unit>
        <trans-unit id="df600fd43354fe093f2997a1e86f286e369b6a13" translate="yes" xml:space="preserve">
          <source>The top-level report object has a &lt;code&gt;results&lt;/code&gt; array containing all linting results for files that had warnings or errors (any files that did not produce a warning or error are omitted). Each file result includes:</source>
          <target state="translated">최상위 보고서 개체에는 경고 또는 오류가있는 파일에 대한 모든 보푸라기 결과가 포함 된 &lt;code&gt;results&lt;/code&gt; 배열이 있습니다 (경고 또는 오류를 생성하지 않은 파일은 생략 됨). 각 파일 결과에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="594a7b21bd7855de18adf0c69dd40a240b1def08" translate="yes" xml:space="preserve">
          <source>The two properties, &lt;code&gt;VariableDeclarator&lt;/code&gt; and &lt;code&gt;AssignmentExpression&lt;/code&gt;, which can be used to turn on or off the destructuring requirement for &lt;code&gt;array&lt;/code&gt; and &lt;code&gt;object&lt;/code&gt;. By default, all values are true.</source>
          <target state="translated">&lt;code&gt;VariableDeclarator&lt;/code&gt; 및 &lt;code&gt;AssignmentExpression&lt;/code&gt; 이라는 두 가지 속성 은 &lt;code&gt;array&lt;/code&gt; 및 &lt;code&gt;object&lt;/code&gt; 대한 파괴 요구 사항을 설정하거나 해제하는 데 사용할 수 있습니다 . 기본적으로 모든 값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="e8bf7a9dd0b016497dca472797a392ec1424c8b6" translate="yes" xml:space="preserve">
          <source>The two properties, &lt;code&gt;array&lt;/code&gt; and &lt;code&gt;object&lt;/code&gt;, can be used to turn on or off the destructuring requirement for each of those types independently. By default, both are true.</source>
          <target state="translated">&lt;code&gt;array&lt;/code&gt; 와 &lt;code&gt;object&lt;/code&gt; 의 두 속성을 사용하여 해당 유형 각각에 대한 구조화 요구 사항을 독립적으로 켜거나 끌 수 있습니다. 기본적으로 둘 다 true입니다.</target>
        </trans-unit>
        <trans-unit id="d35a58b0a18350e1534de85ad73ac8b06f837e84" translate="yes" xml:space="preserve">
          <source>The two properties, &lt;code&gt;array&lt;/code&gt; and &lt;code&gt;object&lt;/code&gt;, which can be used to turn on or off the destructuring requirement for each of those types independently. By default, both are true.</source>
          <target state="translated">&lt;code&gt;array&lt;/code&gt; 와 &lt;code&gt;object&lt;/code&gt; 의 두 속성 은 이러한 유형 각각에 대한 구조화 요구 사항을 독립적으로 켜거나 끄는 데 사용할 수 있습니다. 기본적으로 둘 다 true입니다.</target>
        </trans-unit>
        <trans-unit id="4f16a3bf5e4813936b00b45e231c747c7726a1d4" translate="yes" xml:space="preserve">
          <source>The updates of imported bindings by ES Modules cause runtime errors.</source>
          <target state="translated">ES 모듈에서 가져온 바인딩을 업데이트하면 런타임 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5514e8b27889c92b548abd8ebff5998bdf418288" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;arguments.caller&lt;/code&gt; and &lt;code&gt;arguments.callee&lt;/code&gt; make several code optimizations impossible. They have been deprecated in future versions of JavaScript and their use is forbidden in ECMAScript 5 while in strict mode.</source>
          <target state="translated">의 사용 &lt;code&gt;arguments.caller&lt;/code&gt; 및 &lt;code&gt;arguments.callee&lt;/code&gt; 를 몇 가지 코드 최적화는 불가능합니다. 향후 버전의 JavaScript에서는 더 이상 사용되지 않으며 엄격 모드에서는 ECMAScript 5에서 사용이 금지됩니다.</target>
        </trans-unit>
        <trans-unit id="2924f354dcd960a1ab58164e2009cd5c61e0aa99" translate="yes" xml:space="preserve">
          <source>The use of bitwise operators in JavaScript is very rare and often &lt;code&gt;&amp;amp;&lt;/code&gt; or &lt;code&gt;|&lt;/code&gt; is simply a mistyped &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; or &lt;code&gt;||&lt;/code&gt;, which will lead to unexpected behavior.</source>
          <target state="translated">JavaScript에서 비트 연산자를 사용하는 것은 매우 드물며 종종 &lt;code&gt;&amp;amp;&lt;/code&gt; 또는 &lt;code&gt;|&lt;/code&gt; 단순히 잘못 입력 된 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 또는 &lt;code&gt;||&lt;/code&gt; 예기치 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e8c966ed7def78def5c80c88dca826c0a9cd55fd" translate="yes" xml:space="preserve">
          <source>The version of ESLint you are using.</source>
          <target state="translated">사용중인 ESLint 버전</target>
        </trans-unit>
        <trans-unit id="1f352eb6a0dacd48f9b129fd6892459730a9afd3" translate="yes" xml:space="preserve">
          <source>The version string of ESLint. E.g. &lt;code&gt;&quot;7.0.0&quot;&lt;/code&gt;.</source>
          <target state="translated">The version string of ESLint. E.g. &lt;code&gt;&quot;7.0.0&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eac9f3d4f7ff9fa27be37b9559de95a3dfd24dc8" translate="yes" xml:space="preserve">
          <source>Then any code used within the same scope would not get the global &lt;code&gt;undefined&lt;/code&gt;, but rather the local version with a very different meaning.</source>
          <target state="translated">그런 다음 동일한 범위 내에서 사용되는 코드는 전역 &lt;code&gt;undefined&lt;/code&gt; 가 아니라 매우 다른 의미의 로컬 버전을 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="91dec8db4a7ce736df71ea88ef47e6b7cca8d86f" translate="yes" xml:space="preserve">
          <source>Then the &lt;code&gt;array&lt;/code&gt; part of this rule is not recommended, as destructuring does not match this use case very well.</source>
          <target state="translated">그런 다음 이 규칙 의 &lt;code&gt;array&lt;/code&gt; 부분은 구조화가이 사용 사례와 매우 일치하지 않으므로 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1e7df54ba4b2f3d2b8de3ddfb22cf55076b84b07" translate="yes" xml:space="preserve">
          <source>Then you can change to:</source>
          <target state="translated">그런 다음 다음으로 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ece258a004458918b4a9b465e59a062ce1c5448" translate="yes" xml:space="preserve">
          <source>Then you should enable ES6 using &lt;code&gt;ecmaVersion&lt;/code&gt;:</source>
          <target state="translated">그런 다음 &lt;code&gt;ecmaVersion&lt;/code&gt; 을 사용하여 ES6을 활성화해야합니다 .</target>
        </trans-unit>
        <trans-unit id="99179c89c62e68c70478cf6465b8ea928c3d5143" translate="yes" xml:space="preserve">
          <source>Then you should move &lt;code&gt;ecmaFeatures&lt;/code&gt; under &lt;code&gt;parserOptions&lt;/code&gt;:</source>
          <target state="translated">그런 다음 &lt;code&gt;ecmaFeatures&lt;/code&gt; 아래에서 &lt;code&gt;parserOptions&lt;/code&gt; 이동해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3039d0ca1aa2f7e206fbb9a1bd4f394c4c999ec2" translate="yes" xml:space="preserve">
          <source>Then, assuming you're using the package name &lt;code&gt;eslint-config-myconfig&lt;/code&gt;, you can access the additional config via:</source>
          <target state="translated">그런 다음 &lt;code&gt;eslint-config-myconfig&lt;/code&gt; 패키지 이름을 사용한다고 가정하면 다음을 통해 추가 구성에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f25801971afeae4363e40fabd963bdc80f985e55" translate="yes" xml:space="preserve">
          <source>Then, in your project that wants to use your shareable config, type:</source>
          <target state="translated">그런 다음 공유 가능한 구성을 사용하려는 프로젝트에서 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="353db37a3c8a86c69c78b807d1c427cfb81575aa" translate="yes" xml:space="preserve">
          <source>Then, you can install the ESLint Yeoman generator:</source>
          <target state="translated">그런 다음 ESLint Yeoman 생성기를 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32c357211ab9b4b485ca19fa3a0a2b2bd4c1fa46" translate="yes" xml:space="preserve">
          <source>There are a few reasons you might want to turn this rule off:</source>
          <target state="translated">There are a few reasons you might want to turn this rule off:</target>
        </trans-unit>
        <trans-unit id="7429e55770a7db6e1f799e481661c23075ea68a0" translate="yes" xml:space="preserve">
          <source>There are a lot of command line flags for ESLint and this section explains what they do.</source>
          <target state="translated">ESLint에는 많은 명령 행 플래그가 있으며이 섹션에서는 해당 기능을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="80da262ce40592a7a4ec9cf4f30bca5562293bb5" translate="yes" xml:space="preserve">
          <source>There are a lot of unit tests included with ESLint to make sure that we're keeping on top of code quality. This section explains how to run the unit tests.</source>
          <target state="translated">ESLint에는 많은 단위 테스트가 포함되어있어 코드 품질을 최상으로 유지하고 있습니다. 이 섹션에서는 단위 테스트를 실행하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="cdec16b05bc1e8b3e8a535ea7297a5e3f4035c95" translate="yes" xml:space="preserve">
          <source>There are also cases where the usage of &lt;code&gt;=&amp;gt;&lt;/code&gt; can be ambiguous and should be rewritten to more clearly show the author's intent:</source>
          <target state="translated">&lt;code&gt;=&amp;gt;&lt;/code&gt; 사용법 이 모호 할 수 있고 저자의 의도를보다 명확하게 나타 내기 위해 다시 작성해야하는 경우도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ecd3fd5720fb4421416968b3c583504ac473a76" translate="yes" xml:space="preserve">
          <source>There are also some exceptions to these rules:</source>
          <target state="translated">There are also some exceptions to these rules:</target>
        </trans-unit>
        <trans-unit id="320a38d150f5e795565c18aa62c12c2350485cbd" translate="yes" xml:space="preserve">
          <source>There are also some properties you can access:</source>
          <target state="translated">액세스 할 수있는 속성도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6665f51b7045a2fee788e7afb911686880b53609" translate="yes" xml:space="preserve">
          <source>There are cases where it may be safe for your application to ignore errors, however only ignore errors if you are confident that some other form of monitoring will help you catch the problem.</source>
          <target state="translated">응용 프로그램이 오류를 무시해도 안전한 경우가 있지만 다른 형태의 모니터링으로 문제를 파악하는 데 도움이 될 경우에만 오류를 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="77159dc5778802775842bc1ad78d4c7a0b0534fa" translate="yes" xml:space="preserve">
          <source>There are five events related to code paths, and you can define event handlers in rules.</source>
          <target state="translated">코드 경로와 관련된 5 가지 이벤트가 있으며 규칙에서 이벤트 핸들러를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2c161633c01783c2c492dc2f82954fa87f98f0e" translate="yes" xml:space="preserve">
          <source>There are four different styles and the default member syntax sort order is:</source>
          <target state="translated">네 가지 스타일이 있으며 기본 멤버 구문 정렬 순서는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="73182a6c9f6d8f8a463d75ad9c8c1f7a1954215f" translate="yes" xml:space="preserve">
          <source>There are many commonly used aliases for &lt;code&gt;this&lt;/code&gt; such as &lt;code&gt;that&lt;/code&gt;, &lt;code&gt;self&lt;/code&gt; or &lt;code&gt;me&lt;/code&gt;. It is desirable to ensure that whichever alias the team agrees upon is used consistently throughout the application.</source>
          <target state="translated">많은 일반적으로 사용되는 별명이있다 &lt;code&gt;this&lt;/code&gt; 같은 &lt;code&gt;that&lt;/code&gt; , &lt;code&gt;self&lt;/code&gt; 또는 &lt;code&gt;me&lt;/code&gt; . 팀이 동의 한 별칭이 응용 프로그램 전체에서 일관되게 사용되도록하는 것이 바람직합니다.</target>
        </trans-unit>
        <trans-unit id="778d71a993fc4934f67d793df316de2759b96d65" translate="yes" xml:space="preserve">
          <source>There are rest parameters in ES2015. We can use that feature for variadic functions instead of the &lt;code&gt;arguments&lt;/code&gt; variable.</source>
          <target state="translated">ES2015에는 나머지 매개 변수가 있습니다. &lt;code&gt;arguments&lt;/code&gt; 변수 대신이 함수를 가변 함수에 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="117709bbbf6fc954ac87eb9e1642b49467ac9606" translate="yes" xml:space="preserve">
          <source>There are several common guidelines which require specific indentation of nested blocks and statements, like:</source>
          <target state="translated">다음과 같이 중첩 된 블록 및 명령문의 특정 들여 쓰기를 요구하는 몇 가지 공통 지침이 있습니다.</target>
        </trans-unit>
        <trans-unit id="09bf0b1004131d5cbb653018ebf059cb68d11044" translate="yes" xml:space="preserve">
          <source>There are several pieces of information that can be configured:</source>
          <target state="translated">구성 할 수있는 몇 가지 정보가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c953a0cd08a66ee80bdb67484900a4f8c19fb94" translate="yes" xml:space="preserve">
          <source>There are shareable configs available for most JSCS presets. The equivalent shareable configs for each JSCS preset are listed in the following table:</source>
          <target state="translated">대부분의 JSCS 사전 설정에 사용 가능한 공유 구성이 있습니다. 각 JSCS 사전 설정에 해당하는 공유 가능한 구성이 다음 표에 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7939cad36b767508efc1de1d7ff66357f07843a6" translate="yes" xml:space="preserve">
          <source>There are some cases where you might want to call a callback function more than once. In those cases this rule may lead to incorrect behavior. In those cases you may want to reserve a special name for those callbacks and not include that in the list of callbacks that trigger warnings.</source>
          <target state="translated">콜백 함수를 두 번 이상 호출하려는 경우가 있습니다. 이러한 경우이 규칙은 잘못된 동작으로 이어질 수 있습니다. 이러한 경우 해당 콜백의 특수 이름을 예약하고 경고를 트리거하는 콜백 목록에 해당 이름을 포함시키지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8dbaf6481b7dab508d130fe84b6a20188b6da785" translate="yes" xml:space="preserve">
          <source>There are three primitive types in JavaScript that have wrapper objects: string, number, and boolean. These are represented by the constructors &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Number&lt;/code&gt;, and &lt;code&gt;Boolean&lt;/code&gt;, respectively. The primitive wrapper types are used whenever one of these primitive values is read, providing them with object-like capabilities such as methods. Behind the scenes, an object of the associated wrapper type is created and then destroyed, which is why you can call methods on primitive values, such as:</source>
          <target state="translated">JavaScript에는 래퍼 객체가있는 기본 유형이 세 가지가 있습니다 : 문자열, 숫자 및 부울. 이들은 각각 생성자 &lt;code&gt;String&lt;/code&gt; , &lt;code&gt;Number&lt;/code&gt; 및 &lt;code&gt;Boolean&lt;/code&gt; 로 표시됩니다. 기본 랩퍼 유형은 이러한 기본 값 중 하나를 읽을 때마다 사용되어 메소드와 같은 오브젝트와 같은 기능을 제공합니다. 장면 뒤에서 관련 랩퍼 유형의 오브젝트가 작성되었다가 파괴되므로 다음과 같은 기본 값에 대한 메소드를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="09b78e56913ec7f5884521cf5e33b733c08a8425" translate="yes" xml:space="preserve">
          <source>There are two formats for a rule's exported &lt;code&gt;schema&lt;/code&gt;. The first is a full JSON Schema object describing all possible options the rule accepts, including the rule's error level as the first argument and any optional arguments thereafter.</source>
          <target state="translated">규칙의 내 보낸 &lt;code&gt;schema&lt;/code&gt; 에는 두 가지 형식이 있습니다 . 첫 번째는 규칙의 첫 번째 인수로의 오류 수준 및 이후의 선택적 인수를 포함하여 규칙이 허용하는 모든 가능한 옵션을 설명하는 전체 JSON 스키마 객체입니다.</target>
        </trans-unit>
        <trans-unit id="6e4161ef27c6d8d2328512ff0c53aa33ebb66d6d" translate="yes" xml:space="preserve">
          <source>There are two options for this rule:</source>
          <target state="translated">이 규칙에는 두 가지 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5b03151c21194f8185c6c4c16037975222ef285" translate="yes" xml:space="preserve">
          <source>There are two schools of thought in this regard:</source>
          <target state="translated">이와 관련하여 두 가지 사고 학교가 있습니다.</target>
        </trans-unit>
        <trans-unit id="187de8e977c674d5524ac7c3cf7fd7ff80275095" translate="yes" xml:space="preserve">
          <source>There are two ways of defining functions in JavaScript: &lt;code&gt;function&lt;/code&gt; declarations and &lt;code&gt;function&lt;/code&gt; expressions. Declarations contain the &lt;code&gt;function&lt;/code&gt; keyword first, followed by a name and then its arguments and the function body, for example:</source>
          <target state="translated">JavaScript에서 함수를 정의하는 방법에는 &lt;code&gt;function&lt;/code&gt; 선언과 &lt;code&gt;function&lt;/code&gt; 표현식 의 두 가지가 있습니다 . 선언에는 먼저 &lt;code&gt;function&lt;/code&gt; 키워드와 이름, 인수 및 함수 본문이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="1e031938fbb5ab85e074efc0c3921234cc1f1c89" translate="yes" xml:space="preserve">
          <source>There are two ways to create a regular expression:</source>
          <target state="translated">정규식을 만드는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d52e9915f94a31af6aaead1be831dbb80f676371" translate="yes" xml:space="preserve">
          <source>There are two ways to use configuration files.</source>
          <target state="translated">구성 파일을 사용하는 방법에는 두 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1a8bd447439a90516a50974c91e0f6c8ad77c25" translate="yes" xml:space="preserve">
          <source>There are valid reasons to use assignment operators in conditional statements. However, it can be difficult to tell whether a specific assignment was intentional.</source>
          <target state="translated">조건문에 대입 연산자를 사용해야하는 유효한 이유가 있습니다. 그러나 특정 과제가 의도적인지 여부를 판단하기가 어려울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4715777b3c61a89e3562896681adc37a424d282e" translate="yes" xml:space="preserve">
          <source>There are, however, some occasions when you must use quotes:</source>
          <target state="translated">그러나 따옴표를 사용해야하는 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb6f41837f8cfadd5c03780bba3f02ff7b3c971d" translate="yes" xml:space="preserve">
          <source>There are, however, some who prefer to only use braces when there is more than one statement to be executed.</source>
          <target state="translated">그러나 실행해야 할 명령문이 둘 이상일 때 중괄호 만 사용하는 것을 선호하는 사람들이 있습니다.</target>
        </trans-unit>
        <trans-unit id="342cd48e476dc7314107f25dac7c78229501f3ce" translate="yes" xml:space="preserve">
          <source>There is actually a long history of using dangling underscores to indicate &quot;private&quot; members of objects in JavaScript (though JavaScript doesn't have truly private members, this convention served as a warning). This began with SpiderMonkey adding nonstandard methods such as &lt;code&gt;__defineGetter__()&lt;/code&gt;. The intent with the underscores was to make it obvious that this method was special in some way. Since that time, using a single underscore prefix has become popular as a way to indicate &quot;private&quot; members of objects.</source>
          <target state="translated">실제로 밑줄을 사용하여 JavaScript에서 객체의 &quot;비공개&quot;멤버를 표시하는 데 오랜 역사가 있습니다 (JavaScript에는 실제로 비공개 멤버가 없지만이 규칙은 경고로 사용됨). 이것은 &lt;code&gt;__defineGetter__()&lt;/code&gt; 와 같은 비표준 메소드를 추가하는 SpiderMonkey로 시작되었습니다 . 밑줄의 의도는이 방법이 어떤면에서 특별하다는 것을 분명히하는 것이 었습니다. 그 이후로, 단일 밑줄 접두어를 사용하는 것은 &quot;개인&quot;개체의 구성원을 나타내는 방법으로 인기를 얻었습니다.</target>
        </trans-unit>
        <trans-unit id="4a96991a903b3e1ff68ea9a24be9b087a375a49f" translate="yes" xml:space="preserve">
          <source>There is also a &lt;code&gt;Linter.version&lt;/code&gt; property that you can read without instantiating &lt;code&gt;Linter&lt;/code&gt;:</source>
          <target state="translated">도 있습니다 &lt;code&gt;Linter.version&lt;/code&gt; 의 이 인스턴스없이 읽을 수있는 특성 &lt;code&gt;Linter&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="871b96618532f5a624a5eebc653ef9799b4af97b" translate="yes" xml:space="preserve">
          <source>There is an explicit way to create a global variable when needed, by assigning to a property of the global object.</source>
          <target state="translated">필요한 경우 전역 객체의 속성에 할당하여 전역 변수를 만드는 명시적인 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a847459418c85beaf5623fd3b6978b33df19c866" translate="yes" xml:space="preserve">
          <source>There is no hard and fast rule about whether empty lines should precede &lt;code&gt;return&lt;/code&gt; statements in JavaScript. However, clearly delineating where a function is returning can greatly increase the readability and clarity of the code. For example:</source>
          <target state="translated">JavaScript에서 빈 줄이 &lt;code&gt;return&lt;/code&gt; 문 앞에 와야하는지에 대한 단단하고 빠른 규칙은 없습니다 . 그러나 함수가 반환되는 위치를 명확하게 설명하면 코드의 가독성과 선명도가 크게 향상 될 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7c688c9ecfeeb2e718d9853398cce5aa37907224" translate="yes" xml:space="preserve">
          <source>There is one situation where initializing to &lt;code&gt;undefined&lt;/code&gt; behaves differently than omitting the initialization, and that's when a &lt;code&gt;var&lt;/code&gt; declaration occurs inside of a loop. For example:</source>
          <target state="translated">&lt;code&gt;undefined&lt;/code&gt; 로 초기화하는 것이 초기화를 생략하는 것과 다르게 동작하는 상황이 있는데 , 이것이 &lt;code&gt;var&lt;/code&gt; 선언이 루프 안에서 발생할 때 입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f393cd7001d9c02a6a4db52334b4f6aa81c0dd84" translate="yes" xml:space="preserve">
          <source>There may be a part of a Node.js application that is responsible for determining the correct exit code to return upon exiting. In that case, you should turn this rule off to allow proper handling of the exit code.</source>
          <target state="translated">종료시 리턴 할 올바른 종료 코드를 결정하는 Node.js 애플리케이션의 일부가있을 수 있습니다. 이 경우 종료 코드를 올바르게 처리 할 수 ​​있도록이 규칙을 해제해야합니다.</target>
        </trans-unit>
        <trans-unit id="3f8f96957f0116bd3dee02cc31450b17131c06e6" translate="yes" xml:space="preserve">
          <source>There should be just one variable declaration for all variables in the function. That declaration typically appears at the top of the function.</source>
          <target state="translated">함수의 모든 변수에 대해 하나의 변수 선언이 있어야합니다. 이 선언은 일반적으로 함수의 맨 위에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="af6c3ae1870f67e9ba1a6645267df7a0ed8e6f39" translate="yes" xml:space="preserve">
          <source>There's a &lt;code&gt;jquery&lt;/code&gt; environment defined in this plugin. To use the environment in ESLint, you would use the unprefixed plugin name, followed by a slash, followed by the environment name. So if this plugin were named &lt;code&gt;eslint-plugin-myplugin&lt;/code&gt;, then you would set the environment in your configuration to be &lt;code&gt;&quot;myplugin/jquery&quot;&lt;/code&gt;.</source>
          <target state="translated">이 플러그인 에는 &lt;code&gt;jquery&lt;/code&gt; 환경이 정의되어 있습니다. ESLint에서 환경을 사용하려면 접두사가 붙지 않은 플러그인 이름, 슬래시, 환경 이름을 차례로 사용합니다. 따라서이 플러그인의 이름이 &lt;code&gt;eslint-plugin-myplugin&lt;/code&gt; 이면 구성의 환경을 &lt;code&gt;&quot;myplugin/jquery&quot;&lt;/code&gt; 로 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="4649a897c49ce8c22f4047b05ff4f46b049d69e6" translate="yes" xml:space="preserve">
          <source>Therefore, for any array &lt;code&gt;foo&lt;/code&gt;, &lt;code&gt;foo.indexOf(NaN)&lt;/code&gt; and &lt;code&gt;foo.lastIndexOf(NaN)&lt;/code&gt; will always return &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">따라서 &lt;code&gt;foo&lt;/code&gt; 배열의 경우 &lt;code&gt;foo.indexOf(NaN)&lt;/code&gt; 및 &lt;code&gt;foo.lastIndexOf(NaN)&lt;/code&gt; 은 항상 &lt;code&gt;-1&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="ee735b7f7a5f024f90771cc2fdec6e27abf7cb89" translate="yes" xml:space="preserve">
          <source>Therefore, the &lt;code&gt;u&lt;/code&gt; flag lets us work better with regular expressions.</source>
          <target state="translated">따라서 &lt;code&gt;u&lt;/code&gt; 플래그를 사용하면 정규식으로 더 잘 작업 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="772ede07a4703392f30e23da9503d4982ba7ac6d" translate="yes" xml:space="preserve">
          <source>Therefore, use &lt;code&gt;Number.isNaN()&lt;/code&gt; or global &lt;code&gt;isNaN()&lt;/code&gt; functions to test whether a value is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">따라서 &lt;code&gt;Number.isNaN()&lt;/code&gt; 또는 전역 &lt;code&gt;isNaN()&lt;/code&gt; 함수를 사용하여 값이 &lt;code&gt;NaN&lt;/code&gt; 인지 테스트하십시오 .</target>
        </trans-unit>
        <trans-unit id="201cc4664da2bdb9c50a7d4f0ca2e44472bb57f6" translate="yes" xml:space="preserve">
          <source>These annotations may be used with either single-line or multi-line comments and should follow the same formatting rules as the general comment type. Examples:</source>
          <target state="translated">이러한 주석은 한 줄 또는 여러 줄 주석과 함께 사용할 수 있으며 일반 주석 유형과 동일한 서식 규칙을 따라야합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="4c52137db447105931b557eed8e46933af4bdec4" translate="yes" xml:space="preserve">
          <source>These are the most common scenarios recommended in different style guides:</source>
          <target state="translated">서로 다른 스타일 가이드에서 권장되는 가장 일반적인 시나리오는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="acdb0470966c593cea7812a42d4a917d42c23356" translate="yes" xml:space="preserve">
          <source>These can be combined as much as you like. To make all methods exceptions (thereby rendering this rule useless), use &lt;code&gt;prefer-reflect: [2, { &quot;exceptions&quot;: [&quot;apply&quot;, &quot;call&quot;, &quot;defineProperty&quot;, &quot;getOwnPropertyDescriptor&quot;, &quot;getPrototypeOf&quot;, &quot;setPrototypeOf&quot;, &quot;isExtensible&quot;, &quot;getOwnPropertyNames&quot;, &quot;preventExtensions&quot;, &quot;delete&quot;] }]&lt;/code&gt;</source>
          <target state="translated">이들은 원하는만큼 결합 할 수 있습니다. 모든 메소드를 예외 (이 규칙을 쓸모 없게 렌더링)로 만들려면 &lt;code&gt;prefer-reflect: [2, { &quot;exceptions&quot;: [&quot;apply&quot;, &quot;call&quot;, &quot;defineProperty&quot;, &quot;getOwnPropertyDescriptor&quot;, &quot;getPrototypeOf&quot;, &quot;setPrototypeOf&quot;, &quot;isExtensible&quot;, &quot;getOwnPropertyNames&quot;, &quot;preventExtensions&quot;, &quot;delete&quot;] }]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="16b0a2f3a34d0787ea10fc5517dc6d1c9a76c309" translate="yes" xml:space="preserve">
          <source>These environments are not mutually exclusive, so you can define more than one at a time.</source>
          <target state="translated">이러한 환경은 상호 배타적이지 않으므로 한 번에 둘 이상을 정의 할 수 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
