<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="ember">
    <body>
      <group id="ember">
        <trans-unit id="8c165b17a642662e30f428db8ec59304e29197b2" translate="yes" xml:space="preserve">
          <source>There are also community APIs available for writing your own modifiers, such as &lt;a href=&quot;https://github.com/ember-modifier/ember-modifier&quot;&gt;ember-modifier&lt;/a&gt;. Ember itself has low level APIs known as &lt;em&gt;modifier managers&lt;/em&gt; which can be used to write these higher level APIs. In general, it's recommended to use a community addon to write modifiers, and &lt;em&gt;not&lt;/em&gt; to write your own modifier manager.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07dc5b987a506f1827c7174aac49e91df915147a" translate="yes" xml:space="preserve">
          <source>There are also times when we need to loop through the keys and values of an object rather than an array, similar to JavaScript's &lt;code&gt;for...in&lt;/code&gt; loop. We can use the &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Ember.Templates.helpers/methods#each-in&quot;&gt;&lt;code&gt;{{#each-in}}&lt;/code&gt;&lt;/a&gt; helper to do this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0359b98b88e850c909fee09f5815ae21b16d401e" translate="yes" xml:space="preserve">
          <source>There are assistive technologies (known as screen readers) available for all common desktop platforms and mobile devices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d63cdbaaf5acafc467755d0fe3dadd094986c1f" translate="yes" xml:space="preserve">
          <source>There are many addons that cover all kinds of use cases. For more detail, as well as examples of what addons can do, we invite you to have a look at the &lt;a href=&quot;https://cli.emberjs.com/release/basic-use/using-addons/&quot;&gt;Ember CLI documentation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="578096648c11d6a69dd22171bb32ab27d9d7328e" translate="yes" xml:space="preserve">
          <source>There are many other reasons you probably want to have the last word on whether a user can or cannot access a certain page. Ember allows you to control that access with a combination of hooks and methods in your route.</source>
          <target state="translated">사용자가 특정 페이지에 액세스 할 수 있는지 여부에 대한 마지막 단어를 갖고 싶은 다른 많은 이유가 있습니다. Ember를 사용하면 경로에 후크와 메소드를 조합하여 액세스를 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="775b203c577bdb140ffa94c799cf2a6a1b4a311d" translate="yes" xml:space="preserve">
          <source>There are only two required serializer methods, one for normalizing data from the server API format into JSON:API, and another for serializing records via &lt;code&gt;Snapshots&lt;/code&gt; into the expected server API format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69a2f9362be5ece6004337fb1919abd173f60009" translate="yes" xml:space="preserve">
          <source>There are seven required adapter methods, one for each of the primary request types that EmberData issues.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6205ecb1c706ed6b9a63517df8cc3501ccd070fd" translate="yes" xml:space="preserve">
          <source>There are some &lt;code&gt;aria&lt;/code&gt; attributes that can have multiple values &lt;strong&gt;and&lt;/strong&gt; the order of those values matter. The most frequently used of these is &lt;code&gt;aria-describedby&lt;/code&gt; and &lt;code&gt;aria-labelledby&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12806d9b5503b976f19a8bd2d11453b604b4436e" translate="yes" xml:space="preserve">
          <source>There are some existing Ember addons that may help you make your app more accessible. Each addon should be evaluated for its own usefulness and merit- you may find in some instances, that it would be better to implement the ideas presented in the addon in your own application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e116b7284a783a93524c56507c577f15c7f8f3a" translate="yes" xml:space="preserve">
          <source>There are some typical properties for &lt;code&gt;JSONAPI&lt;/code&gt; payload:</source>
          <target state="translated">&lt;code&gt;JSONAPI&lt;/code&gt; 에는 몇 가지 일반적인 속성이 있습니다. 페이로드 .</target>
        </trans-unit>
        <trans-unit id="fa40a8819696a1f893c91e0074003303e8e955ba" translate="yes" xml:space="preserve">
          <source>There are three contexts an action helper can be used in. The first two contexts to discuss are attribute context, and Handlebars value context.</source>
          <target state="translated">액션 헬퍼가 사용될 수있는 컨텍스트는 세 가지가 있습니다. 논의 할 처음 두 컨텍스트는 속성 컨텍스트와 핸들 바 값 컨텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="eb35d84a7b28ef37fc1f3ad04e7b79de4e7986bd" translate="yes" xml:space="preserve">
          <source>There are three different classifications of tests that you will need: &lt;strong&gt;Acceptance&lt;/strong&gt;, &lt;strong&gt;Unit&lt;/strong&gt;, and &lt;strong&gt;Integration&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;승인&lt;/strong&gt; , &lt;strong&gt;단위&lt;/strong&gt; 및 &lt;strong&gt;통합의&lt;/strong&gt; 세 가지 테스트 분류가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="55ec0fd33fa933ba8edc87cdec2dedca23c0d9b2" translate="yes" xml:space="preserve">
          <source>There are three major changes to templates in Octane compared to classic Ember:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61e915bce39600ae78d86a8a2f57b0a6e3650f57" translate="yes" xml:space="preserve">
          <source>There are three reasons to reach for modifiers for DOM element interactions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7367662dcdee81e54f51c21bbee10f32226fbf53" translate="yes" xml:space="preserve">
          <source>There are times when dealing with promises that it seems like any errors are being 'swallowed', and not properly raised. This makes it extremely difficult to track down where a given issue is coming from. Thankfully, &lt;code&gt;RSVP&lt;/code&gt; has a solution for this problem built in.</source>
          <target state="translated">약속을 다룰 때 어떤 오류가 '삼키는'것처럼 보이고 적절하게 제기되지 않는 것처럼 보일 때가 있습니다. 이로 인해 특정 문제가 발생한 위치를 추적하기가 매우 어렵습니다. 고맙게도 &lt;code&gt;RSVP&lt;/code&gt; 에는이 문제에 대한 해결책이 내장되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbbbf6730bf36824753412fd002e78a4cdd85e2c" translate="yes" xml:space="preserve">
          <source>There are two areas of focus for upgrading to Octane: learning, and implementing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58292ec01fe4732965c33151b41b5ee2bb29dfe4" translate="yes" xml:space="preserve">
          <source>There are two common invocation patterns for &lt;code&gt;.addObserver()&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="857fe0ed7c7e175d8f1aea817ccf0ed3aa408b2b" translate="yes" xml:space="preserve">
          <source>There are two special values for &lt;code&gt;key&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44cfec86f1ebe6d62f3d92a60b1b8d46e0ac4e6e" translate="yes" xml:space="preserve">
          <source>There are two types of initializers: application initializers and application instance initializers.</source>
          <target state="translated">이니셜 라이저에는 응용 프로그램 이니셜 라이저와 응용 프로그램 인스턴스 이니셜 라이저의 두 가지 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c0f5bf8ffcc2ef833217f862744e578168bb7d9" translate="yes" xml:space="preserve">
          <source>There are two ways to link to a dynamic segment from an &lt;code&gt;.hbs&lt;/code&gt; template using &lt;a href=&quot;https://guides.emberjs.com/templates/links/&quot;&gt;&lt;code&gt;&amp;lt;LinkTo&amp;gt;&lt;/code&gt;&lt;/a&gt;. Depending on which approach you use, it will affect whether that route's &lt;code&gt;model&lt;/code&gt; hook is run. To learn how to link to a dynamic segment from within the JavaScript file, see the API documentation on &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/RouterService/methods#transitionTo&quot;&gt;&lt;code&gt;transitionTo&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ddc863139b61f386947ab375dcee77d68a6db49" translate="yes" xml:space="preserve">
          <source>There is a difference between browse mode and focus mode in screen readers- see &lt;a href=&quot;https://codepen.io/melsumner/live/ZJeYoP&quot;&gt;&quot;Focus Please&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f270a949030a35146d8584768a6326689af3a42b" translate="yes" xml:space="preserve">
          <source>There is a problem with this though &amp;ndash; if you tried this in the browser, you will quickly discover that clicking on the buttons will bring up an alert dialog that said &quot;The person's name is &lt;code&gt;[Object MouseEvent]&lt;/code&gt;!&quot; &amp;ndash; eek!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd6415938d2259e6b11974583516c4b28493285c" translate="yes" xml:space="preserve">
          <source>There is also a &lt;em&gt;tight coupling&lt;/em&gt; between your application's UI and the network code. If the URL or the format of the JSON payload changes, it is likely to break all of your UI components in ways that are hard to track down.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c93293573cc4730e6f6925ce1aadc37cf558354" translate="yes" xml:space="preserve">
          <source>There is also a &lt;em&gt;tight coupling&lt;/em&gt; between your application's UI and the network code. If the url or the format of the JSON payload changes, it is likely to break all of your UI components in ways that are hard to track down.</source>
          <target state="translated">도있다 &lt;em&gt;꽉 커플 링&lt;/em&gt; 응용 프로그램의 UI와 네트워크 코드간에 이 있습니다. URL 또는 JSON 페이로드 형식이 변경되면 추적하기 어려운 방식으로 모든 UI 구성 요소가 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d05d80fad77d5b9ca545ded611a63131b8dfe96" translate="yes" xml:space="preserve">
          <source>There is also a way to share data within your blog post component with the content it is wrapping. In our blog post component we want to provide a way for the user to configure what type of style they want to write their post in. We will give them the option to specify either &lt;code&gt;markdown-style&lt;/code&gt; or &lt;code&gt;html-style&lt;/code&gt;.</source>
          <target state="translated">블로그 게시물 구성 요소 내에서 데이터를 줄 바꿈하는 내용과 공유하는 방법도 있습니다. 블로그 게시물 구성 요소에서 사용자가 게시물을 작성하려는 스타일 유형을 구성 할 수있는 방법을 제공하고자합니다. &lt;code&gt;markdown-style&lt;/code&gt; 또는 &lt;code&gt;html-style&lt;/code&gt; 스타일 중 하나를 지정할 수있는 옵션을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="66baec3dcfb862e412f8645d5dd62af38e05aa9e" translate="yes" xml:space="preserve">
          <source>There is an official, free tutorial here in the Guides that delves deeper into some of the features you used today. &lt;a href=&quot;https://guides.emberjs.com/tutorial/part-1/&quot;&gt;Give it a try!&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bce1dba6eb8d20d25b8d3b47eeeb56679f7d843" translate="yes" xml:space="preserve">
          <source>There is an option of not embedding JSON in the serialized payload by using serialize: 'ids'. If you do not want the relationship sent at all, you can use &lt;code&gt;serialize: false&lt;/code&gt;.</source>
          <target state="translated">serialize : 'ids'를 사용하여 직렬화 된 페이로드에 JSON을 포함하지 않는 옵션이 있습니다. 관계를 전혀 보내지 않으려면 &lt;code&gt;serialize: false&lt;/code&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="954498fe7dd0c3f6aac9164ddf4b53324de41ed9" translate="yes" xml:space="preserve">
          <source>There is no confusing two-way data binding for arguments via the component class, data can only flow in one direction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa91d2b4e4c0d7b9ccd13335fc8f54b86eb5baf7" translate="yes" xml:space="preserve">
          <source>There is one exception to this, which is the &lt;code&gt;class&lt;/code&gt; attribute. &lt;code&gt;class&lt;/code&gt; will get merged, since its more often the case that users of the component want to &lt;em&gt;add&lt;/em&gt; a class than completely override the existing ones. For &lt;code&gt;class&lt;/code&gt;, the order of &lt;code&gt;...attributes&lt;/code&gt; will determine the order of merging. Putting it before:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="596e48ed005d8f1769bfccf612d9adb9087b29b8" translate="yes" xml:space="preserve">
          <source>There's a new component API in Octane! For this section, we'll be focusing on the differences between the new style, known as Glimmer components, and classic components, and how to upgrade. &quot;Classic&quot; components refer to older-style components that do not use native classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdcc4e622a6269348d6ee83409631d2d40cd629a" translate="yes" xml:space="preserve">
          <source>There's no one-size-fits-all strategy, but here is a checklist you can adapt, once you're familiar with what Octane has to offer:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c0962f2c7df03fd0ed2a6aa0f4eb2fdab83af0e" translate="yes" xml:space="preserve">
          <source>Therefore, if this function is comparing some numeric values, simple &lt;code&gt;itemA - itemB&lt;/code&gt; or &lt;code&gt;itemA.get( 'foo' ) - itemB.get( 'foo' )&lt;/code&gt; can be used instead of series of &lt;code&gt;if&lt;/code&gt;.</source>
          <target state="translated">따라서이 함수가 일부 숫자 값을 비교하는 &lt;code&gt;if&lt;/code&gt; 일련의 if 대신 간단한 &lt;code&gt;itemA - itemB&lt;/code&gt; 또는 &lt;code&gt;itemA.get( 'foo' ) - itemB.get( 'foo' )&lt;/code&gt; 사용할 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="aad175917d363bcce8de657f15e60b1692b21276" translate="yes" xml:space="preserve">
          <source>These Guides do not cover how to load data in components, since the majority of data fetching should be done in a route's &lt;code&gt;model&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b113c2abb173382c15c2dd806d68e416f093b34c" translate="yes" xml:space="preserve">
          <source>These accessibility learning resources will provide additional support to the developer looking to improve the quality of the code they write.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d873f60929440340af9336691d42395001d2da6" translate="yes" xml:space="preserve">
          <source>These are also mostly the same between native and classic classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c0660d5302de3d7014b6613e931596da4023437" translate="yes" xml:space="preserve">
          <source>These are both languages that compile to JavaScript. You're able to write your code using the syntax they offer and when ready you compile your TypeScript or CoffeeScript into JavaScript.</source>
          <target state="translated">이들은 모두 JavaScript로 컴파일되는 언어입니다. 제공하는 구문을 사용하여 코드를 작성할 수 있으며 준비가되면 TypeScript 또는 CoffeeScript를 JavaScript로 컴파일 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c8de96641d3cbe8d9c8edc8dc4c69c126a40fc2" translate="yes" xml:space="preserve">
          <source>These are meant to replace the &lt;code&gt;{{action}}&lt;/code&gt; helper/modifier, which will be deprecated in the future. You can use them like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31a3130dbfaeb9b8e566839bfa8b94686af9524c" translate="yes" xml:space="preserve">
          <source>These are the main reasons to load data in a &lt;code&gt;model&lt;/code&gt; hook:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f8d310b142485d1a7ea1b222ade6e3057013180" translate="yes" xml:space="preserve">
          <source>These can be used to setup the class and tear it down, respectively. Other lifecycle hooks, like &lt;code&gt;didInsertElement&lt;/code&gt; and &lt;code&gt;didUpdate&lt;/code&gt; don't have equivalents. Instead, you should use &lt;em&gt;modifiers&lt;/em&gt; to fill their use cases. These are discussed in more detail later on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d3e697f7096d0082422200a034677663294c6f5" translate="yes" xml:space="preserve">
          <source>These can generally be replaced either by using getters, in cases where they are related to updating component state, or by using &lt;em&gt;modifiers&lt;/em&gt;. For example, installing the &lt;a href=&quot;https://github.com/emberjs/ember-render-modifiers&quot;&gt;&lt;code&gt;ember-render-modifiers&lt;/code&gt;&lt;/a&gt; addon will give you the ability to use &lt;code&gt;{{did-insert}}&lt;/code&gt; and &lt;code&gt;{{did-update}}&lt;/code&gt;. You can also write your own modifiers! Keep reading below to learn more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f634da40a54ec867094862d4220f2487fe12f5b" translate="yes" xml:space="preserve">
          <source>These commands run your tests using &lt;a href=&quot;https://github.com/airportyh/testem&quot;&gt;Testem&lt;/a&gt; to make testing multiple browsers very easy. You can configure Testem using the &lt;code&gt;testem.js&lt;/code&gt; file in your application root.</source>
          <target state="translated">이 명령은 &lt;a href=&quot;https://github.com/airportyh/testem&quot;&gt;Testem&lt;/a&gt; 을 사용하여 테스트를 실행하여 여러 브라우저를 매우 쉽게 테스트합니다. 응용 프로그램 루트에서 &lt;code&gt;testem.js&lt;/code&gt; 파일을 사용하여 Testem을 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="61777bbf5e521d73865a1db0cd7e3363d228be73" translate="yes" xml:space="preserve">
          <source>These components are similar in HTML markup to the native &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; elements. In contrast to the native elements, &lt;code&gt;&amp;lt;Input&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;Textarea&amp;gt;&lt;/code&gt; automatically update the state of their bound values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="786a36961ca585971e2e7546d5f6e047e5c8cc4e" translate="yes" xml:space="preserve">
          <source>These components don't have a wrapping element. This is referred to as &lt;em&gt;outer HTML semantics&lt;/em&gt;, and it means that whatever you see in the template is what you get in the final rendered DOM:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b434af3b0a23d493db802f77a8fea21f94ada5a0" translate="yes" xml:space="preserve">
          <source>These components have 2 lifecycle hooks:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ac140f85fac47671e02dda468bad7f3d465b715" translate="yes" xml:space="preserve">
          <source>These functions will be invoked when a matching &lt;code&gt;{{action}}&lt;/code&gt; is triggered from within a template and the application's current route is this route.</source>
          <target state="translated">템플릿 내에서 일치하는 &lt;code&gt;{{action}}&lt;/code&gt; 이 (가) 트리거되고 응용 프로그램의 현재 경로가이 경로 인 경우 이러한 함수가 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="0057e815fd8b2620dc9e4b8bc9d8daca9ff42a47" translate="yes" xml:space="preserve">
          <source>These have been replaced or made optional in Octane:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13bbe9645b476da8535e27b2466b716e791a8efb" translate="yes" xml:space="preserve">
          <source>These modifiers run the function passed to them when the &lt;em&gt;element&lt;/em&gt; they are applied to is inserted into or removed from the DOM. This makes the hooks explicit in the element they are acting on. There is also a &lt;code&gt;did-update&lt;/code&gt; modifier, which does not run on insertion, but runs whenever any of its passed values &lt;em&gt;change&lt;/em&gt;, allowing you to update the element:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="161059d7370879ddfe7243a0b810cace10c1efd5" translate="yes" xml:space="preserve">
          <source>These new components give you all the benefits described in Native Classes above</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94056680d2238e5f9418ea4d621a35f14aa9069e" translate="yes" xml:space="preserve">
          <source>These new types of Components &lt;em&gt;require&lt;/em&gt; native class syntax. You can define one like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fdc6a595f0ee640c4a0b599450ef35192869b98" translate="yes" xml:space="preserve">
          <source>These parameters can then be used like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a989452889acc49f04f1b5d711e50b032ffaa9f" translate="yes" xml:space="preserve">
          <source>These tests differ in how many parts of your app they integrate to help you arrive at a logical conclusion. On one end, unit tests let you check a section of your code in isolation. On the other, application tests let you experience your entire application as end-user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="380d201ee7339dc3fbb3c8548f0e008b245953d6" translate="yes" xml:space="preserve">
          <source>These three modifiers are basic modifiers that allow you to cover most of the functionality that lifecycle hooks contained.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f000050ca0200e805c16a0913f8c1fad925ae6a7" translate="yes" xml:space="preserve">
          <source>These tips will help you identify problems early so they can be addressed systematically, rather than in a last-minute scramble.</source>
          <target state="translated">이 팁을 통해 문제를 조기에 파악할 수 있으므로 마지막 순간이 아닌 체계적으로 문제를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ac01f1f97000458db4f5a61a0b13b2cb9e93dd3" translate="yes" xml:space="preserve">
          <source>These values are recalculated every time the property is accessed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c379b7b1ea9ca10a78f7b0e63c171cdd0497c5d8" translate="yes" xml:space="preserve">
          <source>They also do not have equivalents in JavaScript directly, so they cannot be used for other situations where binding would be useful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83968a2b833ec299014955b669844bf935a80325" translate="yes" xml:space="preserve">
          <source>They are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1baa2dd1813d850d4d58e12f7e00f8d101a1f77" translate="yes" xml:space="preserve">
          <source>They can be thought of as &lt;em&gt;functional&lt;/em&gt; components, in the sense that their output (the rendered template) is a pure function of their inputs (their arguments). The fact that they can't have state makes them much easier to reason about in general, and less prone to errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58881cdbdcce8e5a64c38827cd226f41285e6d20" translate="yes" xml:space="preserve">
          <source>They don't extend from &lt;code&gt;EmberObject&lt;/code&gt; at all, which means that they don't need &lt;code&gt;EmberObject&lt;/code&gt; APIs, such as &lt;code&gt;reopenClass&lt;/code&gt;, &lt;code&gt;extend&lt;/code&gt;. You can safely use &lt;code&gt;constructor&lt;/code&gt; for all setup code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="333001595a5f1bb5ef4cea25934228133faa1100" translate="yes" xml:space="preserve">
          <source>They don't have that wrapping HTML element that got in the way of CSS styling and layout</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59baf199ee991542e1d1bd15a351ae5c730a7ad5" translate="yes" xml:space="preserve">
          <source>They enforce a &quot;public API&quot; of all values that are trackable in your class. With computed properties, it was possible to watch &lt;em&gt;any&lt;/em&gt; value in a class for changes, and there was nothing you as the class author could do about it. With tracked properties, only the values you &lt;em&gt;want&lt;/em&gt; to be trackable will trigger updates to anything external to your class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1681b170c17035ae17e0710fc60495ba3fbbd028" translate="yes" xml:space="preserve">
          <source>They enforce that all of the trackable properties in your classes are annotated, making them easy to find. With computed properties, it was common to have properties be &quot;implicit&quot; in a class definition, like in the example above; the classic class version of &lt;code&gt;Image&lt;/code&gt; doesn't have &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; properties defined, but they are &lt;em&gt;implied&lt;/em&gt; by their existence as dependencies in the &lt;code&gt;aspectRatio&lt;/code&gt; computed property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5d8fb2fbdaea0c4272ca86c1513cf90803ca1b3" translate="yes" xml:space="preserve">
          <source>They exist on the class's &lt;em&gt;prototype&lt;/em&gt;, and are only readily callable by instances. However, they can be added to the class directly using the &lt;code&gt;static&lt;/code&gt; keyword, which is described in more detail below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75fc311a8a7aa86afd9963a3b4b7eeeaf07c2b2d" translate="yes" xml:space="preserve">
          <source>Things to know</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd79b21c1e6bc707f846d1f0dbbb85f955d73575" translate="yes" xml:space="preserve">
          <source>Think of this as evaluating the template from scratch, substituting in the new values, and updating the output with the new contents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="181131df6a38e6d28e2f4421a72b6584672cb091" translate="yes" xml:space="preserve">
          <source>Thinking About Updates</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb68b862cfa676cabebaff85159658805baa3a42" translate="yes" xml:space="preserve">
          <source>Third-party APIs.</source>
          <target state="translated">타사 API.</target>
        </trans-unit>
        <trans-unit id="ddfb0ac04a55327aee053575597c9dda63adb165" translate="yes" xml:space="preserve">
          <source>Third-party JavaScript not available as an addon or Bower package should be placed in the &lt;code&gt;vendor/&lt;/code&gt; folder in your project.</source>
          <target state="translated">애드온 또는 Bower 패키지로 사용할 수없는 타사 JavaScript는 프로젝트 의 &lt;code&gt;vendor/&lt;/code&gt; 폴더에 배치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2b2d7e78185f072c22436993b20d284d1f30739b" translate="yes" xml:space="preserve">
          <source>Third-party JavaScript not available as an addon or npm package should be placed in the &lt;code&gt;vendor/&lt;/code&gt; folder in your project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c152859cd8202abcdaed3b38272a28b1f61176c" translate="yes" xml:space="preserve">
          <source>Third-party assets that are not added via &lt;code&gt;app.import()&lt;/code&gt; will not be present in the final build.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ffb1109d5b126cb0663125d9dacbb7624bde715" translate="yes" xml:space="preserve">
          <source>Third-party assets that are not added via &lt;code&gt;import()&lt;/code&gt; will not be present in the final build.</source>
          <target state="translated">&lt;code&gt;import()&lt;/code&gt; 를 통해 추가되지 않은 타사 자산 은 최종 빌드에 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="452f64b3ac568069b0d3fb42cc4172b03c430605" translate="yes" xml:space="preserve">
          <source>This API allows you to provide a reference with new data. The simplest usage of this API is similar to &lt;code&gt;store.push&lt;/code&gt;: you provide a normalized hash of data and the object represented by the reference will update.</source>
          <target state="translated">이 API를 사용하면 새 데이터에 대한 참조를 제공 할 수 있습니다. 이 API의 가장 간단한 사용법은 &lt;code&gt;store.push&lt;/code&gt; 와 유사합니다. 합니다. 정규화 된 데이터 해시를 제공하면 참조로 표시되는 객체가 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="37ffc8f135d22f0957ffebde87903095e52c78e0" translate="yes" xml:space="preserve">
          <source>This Ember.js hook allows an object to be notified when a property is defined.</source>
          <target state="translated">이 Ember.js 후크를 사용하면 속성이 정의 될 때 객체에 알릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b09c105db361629ca95455f0150513486c5dc1db" translate="yes" xml:space="preserve">
          <source>This action uses the &lt;code&gt;onCreate&lt;/code&gt; argument to expose a public API for defining what happens when a message is created. This way, the &lt;code&gt;&amp;lt;NewMessageInput&amp;gt;&lt;/code&gt; component doesn't have to worry about the external details - it can focus on getting the new message input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6b8e36a48ff33ef3a57b6d9dd97582f0dfd4fca" translate="yes" xml:space="preserve">
          <source>This adapter does not make any assumptions as to the format of the &lt;code&gt;errors&lt;/code&gt; object. It will simply be passed along as is, wrapped in an instance of &lt;code&gt;DS.InvalidError&lt;/code&gt; or &lt;code&gt;DS.AdapterError&lt;/code&gt;. The serializer can interpret it afterwards.</source>
          <target state="translated">이 어댑터는 &lt;code&gt;errors&lt;/code&gt; 오브젝트 의 형식에 대한 가정을하지 않습니다 . &lt;code&gt;DS.InvalidError&lt;/code&gt; 또는 &lt;code&gt;DS.AdapterError&lt;/code&gt; 의 인스턴스에 싸여있는 그대로 그대로 전달됩니다. . 시리얼 라이저는 나중에 해석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31309097c652bcb29f43566cdd5ee615b8e45a1c" translate="yes" xml:space="preserve">
          <source>This adapter does not make any assumptions as to the format of the &lt;code&gt;errors&lt;/code&gt; object. It will simply be passed along as is, wrapped in an instance of &lt;code&gt;InvalidError&lt;/code&gt; or &lt;code&gt;AdapterError&lt;/code&gt;. The serializer can interpret it afterwards.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad2124edee9f5095f02b332c56318c024bf9499a" translate="yes" xml:space="preserve">
          <source>This adapter is designed around the idea that the JSON exchanged with the server should be conventional.</source>
          <target state="translated">이 어댑터는 서버와 교환 된 JSON이 기존이어야한다는 아이디어를 중심으로 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="853904908c1556303a04442689a343ac7e65fed7" translate="yes" xml:space="preserve">
          <source>This adapter will extend the &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.JSONAPIAdapter.html&quot;&gt;&lt;code&gt;JSONAPIAdapter&lt;/code&gt;&lt;/a&gt; base class from Ember Data:</source>
          <target state="translated">이 어댑터는 Ember Data에서 &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.JSONAPIAdapter.html&quot;&gt; &lt;code&gt;JSONAPIAdapter&lt;/code&gt; &lt;/a&gt; 기본 클래스를 확장합니다 .</target>
        </trans-unit>
        <trans-unit id="7f8c99814d002a149e53514eb44437d60a2e1b46" translate="yes" xml:space="preserve">
          <source>This addon does nothing by default, but provides a command-line interface to enable and disable breaking changes in Ember.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d5dbdc061173e19b17b6f110fb18cfb4cd22c55" translate="yes" xml:space="preserve">
          <source>This affects query param behavior in two ways:</source>
          <target state="translated">이는 두 가지 방법으로 쿼리 매개 변수 동작에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="fb40c747b5f5c098cf71b6fa217888659cbabe96" translate="yes" xml:space="preserve">
          <source>This allows each in-app location state to be tracked uniquely across history state changes via the &lt;code&gt;uuid&lt;/code&gt; field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9236129e7ad8572a6f3cfa7ce7b534bcdc1773a8" translate="yes" xml:space="preserve">
          <source>This allows ember-testing to play nicely with other asynchronous events, such as an application that is waiting for a CSS3 transition or an IndexDB transaction. The waiter runs periodically after each async helper (i.e. &lt;code&gt;click&lt;/code&gt;, &lt;code&gt;andThen&lt;/code&gt;, &lt;code&gt;visit&lt;/code&gt;, etc) has executed, until the returning result is truthy. After the waiters finish, the next async helper is executed and the process repeats.</source>
          <target state="translated">이를 통해 ember-testing은 CSS3 전환을 기다리는 응용 프로그램이나 IndexDB 트랜잭션과 같은 다른 비동기 이벤트와 잘 작동합니다. 웨이터 (즉, 각 비동기 도우미 후 주기적으로 실행 &lt;code&gt;click&lt;/code&gt; , &lt;code&gt;andThen&lt;/code&gt; 을 , &lt;code&gt;visit&lt;/code&gt; 돌아 오는 결과가 truthy 때까지, 실행 된, 등). 웨이터가 완료되면 다음 비동기 도우미가 실행되고 프로세스가 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="59effbfb5ad3093ffb299683ce194cb7792a2e6a" translate="yes" xml:space="preserve">
          <source>This allows the developer to introduce shorter names for certain computations in the template.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17544a9635bda05a65f8cbf8e04034181c47050d" translate="yes" xml:space="preserve">
          <source>This allows the manager to store metadata that it doesn't want to expose to the user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d63f6d895f9dbaa7a1f0c7f4aab7d30d5d8234cc" translate="yes" xml:space="preserve">
          <source>This allows the original method to continue operating as it normally would.</source>
          <target state="translated">이렇게하면 원래 방법이 정상적으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="24a13b7fd5f29060d14130a50f2cc487cfbbe911" translate="yes" xml:space="preserve">
          <source>This allows you to define different &lt;em&gt;kinds&lt;/em&gt; of objects, which have their own methods, properties, fields, and more. This is essentially Object Oriented Programming - you define different types of objects that handle different problems and concerns, keeping your code organized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24bcc3785d46e8ac4ffd376b07abde90f0f28ecb" translate="yes" xml:space="preserve">
          <source>This allows you to do whatever kind of munging you need and is especially useful if your server is inconsistent and you need to do munging differently for many different kinds of responses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="283d55de2d3a0d1c60968c365e7a92f311d2ac8a" translate="yes" xml:space="preserve">
          <source>This allows you to do whatever kind of munging you need, and is especially useful if your server is inconsistent and you need to do munging differently for many different kinds of responses.</source>
          <target state="translated">이를 통해 필요한 종류의 뭉치를 수행 할 수 있으며, 서버가 일치하지 않고 여러 종류의 응답에 대해 다르게 뭉개 야하는 경우에 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="fd87b224bfacdd8f67d689202e0b6d11b295e8ca" translate="yes" xml:space="preserve">
          <source>This allows you to perform asynchronous setup logic and defer booting your application until the setup has finished.</source>
          <target state="translated">이를 통해 비동기 설정 논리를 수행하고 설정이 완료 될 때까지 응용 프로그램 부팅을 연기 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f64fc9d39bf58ac731301cee5c513c4b5484e576" translate="yes" xml:space="preserve">
          <source>This allows you to see at a glance whether a value is an argument, which will likely affect the JS of a component, or an attribute, which will likely affect the HTML of a component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecbde4b0429160e6e38b29497afe7050bd66eba4" translate="yes" xml:space="preserve">
          <source>This approach works great when you're trying to produce output that can be represented in HTML. But what about aspects of your component that aren't represented in HTML, like event handlers? In those cases, Ember tries to stick to the spirit of the Principle of Substitution, and allow you to write templates as if they only ran one time, and then automatically keep the output up to date for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cdde2b5de75dbd9f848f898dbadf64aaba67fae" translate="yes" xml:space="preserve">
          <source>This argument will become the model context of the linked route:</source>
          <target state="translated">이 인수는 연결된 경로의 모델 컨텍스트가됩니다.</target>
        </trans-unit>
        <trans-unit id="28fcfea622d48bd9ddb516b9d25db4e8b821a9b4" translate="yes" xml:space="preserve">
          <source>This article is a good launching point for learning more about focus: &lt;a href=&quot;https://webaim.org/techniques/keyboard/&quot;&gt;Keyboard accessibility&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4324e0761c8ed6f27abea5db22464d25198145c1" translate="yes" xml:space="preserve">
          <source>This assumes you have already created the &lt;code&gt;dist/&lt;/code&gt; directory by running this command</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="941f661a9bdc6020b125f022848bfff58eb9c9a2" translate="yes" xml:space="preserve">
          <source>This behavior extends to object creation as well. Continuing the above example:</source>
          <target state="translated">이 동작은 객체 생성까지 확장됩니다. 위의 예를 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="53fa6c0fd3b00088bf6ab65b06527f4d9856bb1d" translate="yes" xml:space="preserve">
          <source>This behavior is not available during object &lt;code&gt;create&lt;/code&gt; calls. It is only available at &lt;code&gt;extend&lt;/code&gt; time.</source>
          <target state="translated">오브젝트 &lt;code&gt;create&lt;/code&gt; 호출 중에는이 동작을 사용할 수 없습니다 . &lt;code&gt;extend&lt;/code&gt; 시간 에만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="43d2dd221d5ae1ea9bb7a9856edbf09d1a30ce17" translate="yes" xml:space="preserve">
          <source>This behavior is similar to &lt;code&gt;&amp;lt;LinkTo /&amp;gt;&lt;/code&gt;, which also lets you opt into a &lt;code&gt;replaceState&lt;/code&gt; transition via &lt;code&gt;replace=true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b10353972c333adf35b656d7d67ecb6081d088a1" translate="yes" xml:space="preserve">
          <source>This behaviour can be easily customized by extending this method.</source>
          <target state="translated">이 방법을 확장하면이 동작을 쉽게 사용자 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7087d2aa7e0c9dbae55ad8456ac0ed7c2474bcbd" translate="yes" xml:space="preserve">
          <source>This behaviour is similar to &lt;code&gt;link-to&lt;/code&gt;, which also lets you opt into a &lt;code&gt;replaceState&lt;/code&gt; transition via &lt;code&gt;replace=true&lt;/code&gt;.</source>
          <target state="translated">이 동작은 &lt;code&gt;link-to&lt;/code&gt; 와 유사하며 &lt;code&gt;replace=true&lt;/code&gt; 를 통해 &lt;code&gt;replaceState&lt;/code&gt; 전환을 선택할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="646b88b52695fd5b351e17ed4f20ebf3a312b1da" translate="yes" xml:space="preserve">
          <source>This callback will be called whenever an async operation has completed.</source>
          <target state="translated">이 콜백은 비동기 작업이 완료 될 때마다 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="9d3decb642e6ed5fe3151ae228c0dab60ea9dbcb" translate="yes" xml:space="preserve">
          <source>This callback will be called whenever an async operation is about to start.</source>
          <target state="translated">이 콜백은 비동기 작업이 시작될 때마다 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="d94c197506d9b806492553adc280734f866e9c03" translate="yes" xml:space="preserve">
          <source>This can also be used in JavaScript code directly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e4f6495a0bfd49c0b770ee29b970fcdc0b8a129" translate="yes" xml:space="preserve">
          <source>This can be achieved by configuring the &lt;code&gt;rootURL&lt;/code&gt; property on &lt;code&gt;ENV&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;ENV&lt;/code&gt; 에서 &lt;code&gt;rootURL&lt;/code&gt; 속성을 구성하면 됩니다 .</target>
        </trans-unit>
        <trans-unit id="592e84b1e0b4e61032446b865d26f0c9377deab5" translate="yes" xml:space="preserve">
          <source>This can be done on the result of a &lt;code&gt;store.query()&lt;/code&gt; call:</source>
          <target state="translated">이것은 &lt;code&gt;store.query()&lt;/code&gt; 호출 결과에서 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9a9791a95fe25e97691cfe2cc4d22cfc96f21523" translate="yes" xml:space="preserve">
          <source>This cheatsheet is a quick reference for the best practices and differences in native and classic classes. Remember, you should &lt;em&gt;prefer&lt;/em&gt; using native class syntax and &lt;em&gt;not&lt;/em&gt; extending from &lt;code&gt;EmberObject&lt;/code&gt; at all in your apps.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3f869a4e4a76d784deb8c0310fd8160dedadf6c" translate="yes" xml:space="preserve">
          <source>This class can also be useful as a layer to transform the contents of an array, as they are accessed. This can be done by overriding &lt;code&gt;objectAtContent&lt;/code&gt;:</source>
          <target state="translated">이 클래스는 액세스 할 때 배열의 내용을 변환하는 레이어로 유용 할 수 있습니다. &lt;code&gt;objectAtContent&lt;/code&gt; 를 재정 의하여 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5c735fa315afadd4e939bc22605b4168dc7fd925" translate="yes" xml:space="preserve">
          <source>This class can be extended by a custom resolver implementer to override some of the methods with library-specific code.</source>
          <target state="translated">이 클래스는 사용자 정의 리졸버 구현 자에 의해 확장되어 라이브러리 특정 코드로 일부 메소드를 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3106dd228ae8524f2463f5eb418ced8f6f5d8666" translate="yes" xml:space="preserve">
          <source>This class implements the methods defined by Ember.Test.Adapter for the QUnit testing framework.</source>
          <target state="translated">이 클래스는 QUnit 테스트 프레임 워크를 위해 Ember.Test.Adapter에 의해 정의 된 메소드를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="0865d5cdf769ef7337ee72ac5a5a24e52404e677" translate="yes" xml:space="preserve">
          <source>This class implements the methods defined by TestAdapter for the QUnit testing framework.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="320b5810ffa80935692e4a814095e9bb406c7d7d" translate="yes" xml:space="preserve">
          <source>This class will be extended by a persistence library which will override some of the methods with library-specific code.</source>
          <target state="translated">이 클래스는 라이브러리 특정 코드로 일부 메소드를 대체하는 지속성 라이브러리로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="27a1bf954f28f9228362cbc78df0337d440875b7" translate="yes" xml:space="preserve">
          <source>This code example uses a feature of JavaScript called classes. Learn more with this &lt;a href=&quot;https://ponyfoo.com/articles/es6&quot;&gt;overview of the latest JavaScript features&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="674eb11f18e5896906fc06f889797fc9a66d2250" translate="yes" xml:space="preserve">
          <source>This code example uses the latest features in JavaScript, some of which you may not be familiar with. Learn more with this &lt;a href=&quot;https://ponyfoo.com/articles/es6&quot;&gt;overview of the newest JavaScript features&lt;/a&gt;.</source>
          <target state="translated">이 코드 예제는 JavaScript의 최신 기능을 사용하지만 일부는 익숙하지 않을 수 있습니다. &lt;a href=&quot;https://ponyfoo.com/articles/es6&quot;&gt;최신 JavaScript 기능에 대한 개요를&lt;/a&gt; 자세히 살펴보십시오 .</target>
        </trans-unit>
        <trans-unit id="9cbc5b39eb798eb51d77f552d2e0d841fdd661b2" translate="yes" xml:space="preserve">
          <source>This code includes the &lt;code&gt;&amp;lt;Avatar&amp;gt;&lt;/code&gt; component, which expects two &lt;em&gt;arguments&lt;/em&gt;: &lt;code&gt;@title&lt;/code&gt; and &lt;code&gt;@initial&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b058885d803d2851bab3b76256360f9c6b694f72" translate="yes" xml:space="preserve">
          <source>This code needs to run after the element is rendered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="741c3c5c9cbc26a8058ac14397f68ef356ac31ed" translate="yes" xml:space="preserve">
          <source>This command will create your application with French defined as the primary language on the &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; element's &lt;code&gt;lang&lt;/code&gt; attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75f38d5fab184552fc6e1d3c8a9a21567a04ca7a" translate="yes" xml:space="preserve">
          <source>This component could then be invoked like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42747deec204b16bbd726cbdb8758b3c96383a2a" translate="yes" xml:space="preserve">
          <source>This component is invoked with a block:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6994d84354b5d5369f1efbb938cdaffbfff8abdb" translate="yes" xml:space="preserve">
          <source>This component is invoked with block params:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d11a1a27fac3bf7919d31fb41ebc66d539dfc70a" translate="yes" xml:space="preserve">
          <source>This component is invoked without a block:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51ba6f902cb3179e8a817fb66b9ce04fcc18109b" translate="yes" xml:space="preserve">
          <source>This component is invoked without block params:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f38bf488518f6eb94f480d68c4e9cd4e6005d41" translate="yes" xml:space="preserve">
          <source>This component would be invoked this way:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fc86456128b2bec3fcb1e1970d2427a1fdb6365" translate="yes" xml:space="preserve">
          <source>This component would render the following:</source>
          <target state="translated">이 구성 요소는 다음을 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="e42d35491e18c0eb8d5095f19ff074a10aab3fc5" translate="yes" xml:space="preserve">
          <source>This computed property would return a map describing these relationships, like this:</source>
          <target state="translated">이 계산 된 속성은 다음과 같이 이러한 관계를 설명하는 맵을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e801b088f01bc479b0a62d07e708e3f59c7fa4fc" translate="yes" xml:space="preserve">
          <source>This could be rewritten using the &lt;code&gt;{{did-insert}}&lt;/code&gt; and &lt;code&gt;{{will-destroy}}&lt;/code&gt; modifiers, if you install &lt;a href=&quot;https://github.com/emberjs/ember-render-modifiers&quot;&gt;ember-render-modifiers&lt;/a&gt; in your app:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41901a4413a6388d0163c06aa5caaeddb4abd187" translate="yes" xml:space="preserve">
          <source>This creates a controller file at &lt;code&gt;app/controllers/my-controller-name.js&lt;/code&gt;, and a unit test file at &lt;code&gt;tests/unit/controllers/my-controller-name-test.js&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec813caf1f669a427b25e6f09bf93ba65ce6c773" translate="yes" xml:space="preserve">
          <source>This creates a route file at &lt;code&gt;app/routes/route-name.js&lt;/code&gt;, a template for the route at &lt;code&gt;app/templates/route-name.hbs&lt;/code&gt;, and a unit test file at &lt;code&gt;tests/unit/routes/route-name-test.js&lt;/code&gt;. It also adds the route to the router.</source>
          <target state="translated">이렇게하면 &lt;code&gt;app/routes/route-name.js&lt;/code&gt; 에 경로 파일 , &lt;code&gt;app/templates/route-name.hbs&lt;/code&gt; 에 경로 템플릿 , &lt;code&gt;tests/unit/routes/route-name-test.js&lt;/code&gt; 단위 테스트 파일이 생성됩니다 . JS . 또한 라우터에 경로를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="91ce519eb8ba59c7f3b8c3662743cb9f43554cc3" translate="yes" xml:space="preserve">
          <source>This declares &lt;code&gt;fullName&lt;/code&gt; to be a computed property, with &lt;code&gt;firstName&lt;/code&gt; and &lt;code&gt;lastName&lt;/code&gt; as the properties it depends on. The first time you access the &lt;code&gt;fullName&lt;/code&gt; property, the function will be called and the results will be cached. Subsequent access of &lt;code&gt;fullName&lt;/code&gt; will read from the cache without calling the function. Changing any of the dependent properties causes the cache to invalidate, so that the computed function runs again on the next access.</source>
          <target state="translated">이는 &lt;code&gt;fullName&lt;/code&gt; 을 계산 된 특성으로 선언 하며, &lt;code&gt;firstName&lt;/code&gt; 및 &lt;code&gt;lastName&lt;/code&gt; 을 종속 특성으로 사용합니다. &lt;code&gt;fullName&lt;/code&gt; 속성에 처음 액세스하면 함수가 호출되고 결과가 캐시됩니다. &lt;code&gt;fullName&lt;/code&gt; 에 대한 후속 액세스 는 함수를 호출하지 않고 캐시에서 읽습니다. 종속 특성을 변경하면 캐시가 무효화되어 계산 된 기능이 다음 액세스에서 다시 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="31bb2006f39cafcc9484e2a81a9f308f7180aef7" translate="yes" xml:space="preserve">
          <source>This defines a new &lt;code&gt;Person&lt;/code&gt; class with a &lt;code&gt;say()&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;say()&lt;/code&gt; 메소드 로 새로운 &lt;code&gt;Person&lt;/code&gt; 클래스를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="116d968a917da2cb6719f721c279bfccee4349ce" translate="yes" xml:space="preserve">
          <source>This defines a new subclass of Ember.Object: &lt;code&gt;Person&lt;/code&gt;. It contains one method: &lt;code&gt;say()&lt;/code&gt;.</source>
          <target state="translated">이것은 Ember.Object의 새로운 서브 클래스를 정의합니다 : &lt;code&gt;Person&lt;/code&gt; . 여기에는 &lt;code&gt;say()&lt;/code&gt; 메소드가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="507be2b201a787f598f02ddf1f2d63fb67b3e63f" translate="yes" xml:space="preserve">
          <source>This defines a new subclass of EmberObject: &lt;code&gt;Person&lt;/code&gt;. It contains one method: &lt;code&gt;say()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38e367c32d9360c0c04a62f0fdb65d8584bf4d3e" translate="yes" xml:space="preserve">
          <source>This destroyables API exposes the basic building blocks for destruction:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4af4dccef2a80a69c041a6f95a959661b8e03a9" translate="yes" xml:space="preserve">
          <source>This doesn't usually affect application code because computed properties are almost always observed at the same time as they are fetched. For example, you get the value of a computed property, put it in DOM (or draw it with D3), and then observe it so you can update the DOM once the property changes.</source>
          <target state="translated">계산 된 속성은 거의 항상 페치되는 것과 동시에 관찰되므로 응용 프로그램 코드에는 영향을 미치지 않습니다. 예를 들어 계산 된 속성의 값을 가져 와서 DOM에 넣거나 D3으로 그리면 속성이 변경되면 DOM을 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="784b0ed31150b193e479ab80ab41ebf62f83f1ec" translate="yes" xml:space="preserve">
          <source>This error would then be returned by an adapter's &lt;code&gt;handleResponse&lt;/code&gt; method:</source>
          <target state="translated">이 오류는 어댑터의 &lt;code&gt;handleResponse&lt;/code&gt; 메소드에 의해 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="b6170d3568edf87d92c7c80728ddd942353f0af6" translate="yes" xml:space="preserve">
          <source>This event is triggered when the router completely exits this route. It is not executed when the model for the route changes.</source>
          <target state="translated">이 이벤트는 라우터가이 경로를 완전히 종료하면 트리거됩니다. 라우트 모델이 변경되면 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4b0c96e516f34305bd6b72b775ae4db9e3545500" translate="yes" xml:space="preserve">
          <source>This event is triggered when the router enters the route. It is not executed when the model for the route changes.</source>
          <target state="translated">이 이벤트는 라우터가 경로에 들어 오면 트리거됩니다. 라우트 모델이 변경되면 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d16fd1f0dc576c2612cded3cdb4e1f4f8b33fa5c" translate="yes" xml:space="preserve">
          <source>This example combines several Handlebars features to create a personalized experience for the user, something we couldn't do with just static HTML alone. We used the comment syntax (&lt;code&gt;{{!-- ... --}}&lt;/code&gt;) to leave a note for future developers, the double curly braces syntax (&lt;code&gt;{{...}}&lt;/code&gt;) to include dynamic values, as well as using the &lt;code&gt;{{#if}}...{{/if}}&lt;/code&gt; syntax to conditionally render some extra content.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cab4a8f298d62a398a20d8205ec2eba83599f69c" translate="yes" xml:space="preserve">
          <source>This example of a post model has many comments:</source>
          <target state="translated">이 포스트 모델 예제에는 많은 주석이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fe7ed9c19bb8a7f1cbe6b019c963a036d9478fe" translate="yes" xml:space="preserve">
          <source>This example of an author model belongs to a post model:</source>
          <target state="translated">이 저자 모델의 예는 포스트 모델에 속합니다.</target>
        </trans-unit>
        <trans-unit id="7ccc911768f0da88e6ef9f3cf49eef3b432ed969" translate="yes" xml:space="preserve">
          <source>This example uses the &lt;code&gt;=&amp;gt;&lt;/code&gt; function syntax, which is a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;new ES2015 syntax for callback functions&lt;/a&gt; that provides a lexical &lt;code&gt;this&lt;/code&gt;. If this syntax is new, think of it as a function that has the same &lt;code&gt;this&lt;/code&gt; as the context it is defined in.</source>
          <target state="translated">이 예제는 &lt;code&gt;=&amp;gt;&lt;/code&gt; 함수 구문을 사용하는데 , 이것은 어휘 &lt;code&gt;this&lt;/code&gt; 을 제공하는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;콜백 함수에 대한 새로운 ES2015 구문입니다&lt;/a&gt; . 이 구문이 새로운 경우, 동일한 갖는 함수로 생각 &lt;code&gt;this&lt;/code&gt; 그것에서 정의되는 컨텍스트있다.</target>
        </trans-unit>
        <trans-unit id="71cde9139e41d931d3bdacfa5f2ca54241aeb5c1" translate="yes" xml:space="preserve">
          <source>This example will create a &lt;code&gt;posts&lt;/code&gt; property on the &lt;code&gt;post&lt;/code&gt; controller that looks up the &lt;code&gt;posts&lt;/code&gt; controller in the container, making it easy to reference other controllers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff609b107eeeef59c10a02a7f765526a45b3b82b" translate="yes" xml:space="preserve">
          <source>This example will create a &lt;code&gt;posts&lt;/code&gt; property on the &lt;code&gt;post&lt;/code&gt; controller that looks up the &lt;code&gt;posts&lt;/code&gt; controller in the container, making it easy to reference other controllers. This is functionally equivalent to:</source>
          <target state="translated">이 예는 만듭니다 &lt;code&gt;posts&lt;/code&gt; 상의 특성 &lt;code&gt;post&lt;/code&gt; 위로 보이는 컨트롤러 &lt;code&gt;posts&lt;/code&gt; 컨테이너의 컨트롤러는, 쉽게 다른 컨트롤러를 참조 할 수있게합니다. 이것은 기능적으로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="49855cd9123878194ff56a8b6fd54aa27e05b647" translate="yes" xml:space="preserve">
          <source>This example will create an &lt;code&gt;authManager&lt;/code&gt; property on the application route that looks up the &lt;code&gt;auth&lt;/code&gt; service in the container, making it easily accessible in the &lt;code&gt;model&lt;/code&gt; hook.</source>
          <target state="translated">이 예제는 컨테이너에서 &lt;code&gt;auth&lt;/code&gt; 서비스 를 찾는 응용 프로그램 경로에 &lt;code&gt;authManager&lt;/code&gt; 속성을 만들어 &lt;code&gt;model&lt;/code&gt; 후크 에서 쉽게 액세스 할 수 있도록합니다 .</target>
        </trans-unit>
        <trans-unit id="6567df05d4a192c48cd4c99f719e2addb19ced5a" translate="yes" xml:space="preserve">
          <source>This example would create the font file in &lt;code&gt;dist/font-awesome/fonts/fontawesome-webfont.ttf&lt;/code&gt;.</source>
          <target state="translated">이 예제는 &lt;code&gt;dist/font-awesome/fonts/fontawesome-webfont.ttf&lt;/code&gt; 에 글꼴 파일을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="487dfa2fb498fbeeecec5ffef779e77c25b4bf73" translate="yes" xml:space="preserve">
          <source>This feature is available for you to use throughout the Ember object model, although typical app developers are likely to use it infrequently. Since it changes expectations about behavior of properties, you should properly document its usage in each individual concatenated property (to not mislead your users to think they can override the property in a subclass).</source>
          <target state="translated">이 기능은 Ember 객체 모델 전체에서 사용할 수 있지만 일반적인 앱 개발자는 자주 사용하지 않을 수 있습니다. 속성의 동작에 대한 기대치가 변경되므로 각 개별 연결된 속성의 사용법을 올바르게 문서화해야합니다 (사용자가 하위 클래스의 속성을 재정의 할 수 있다고 오인하지 않도록).</target>
        </trans-unit>
        <trans-unit id="0e9e3a7edaabb385dc159a68dfa2582b6dd6bf05" translate="yes" xml:space="preserve">
          <source>This feature is available for you to use throughout the Ember object model, although typical app developers are likely to use it infrequently. Since it changes expectations about behavior of properties, you should properly document its usage in each individual merged property (to not mislead your users to think they can override the property in a subclass).</source>
          <target state="translated">이 기능은 Ember 객체 모델 전체에서 사용할 수 있지만 일반적인 앱 개발자는 자주 사용하지 않을 수 있습니다. 속성의 동작에 대한 기대치가 변경되므로 병합 된 각 개별 속성의 사용법을 올바르게 문서화해야합니다 (사용자가 하위 클래스의 속성을 재정의 할 수 있다고 오인하지 않도록).</target>
        </trans-unit>
        <trans-unit id="d8a914b8d45890e4d1608c302453e2c8af0f22d0" translate="yes" xml:space="preserve">
          <source>This feature is backed by &lt;a href=&quot;https://github.com/ai/browserslist&quot;&gt;Browserlist&lt;/a&gt; and &lt;a href=&quot;http://caniuse.com/&quot;&gt;Can I Use&lt;/a&gt;. These websites track usage stats of browsers, so you can use complex queries based on the user base of every browser.</source>
          <target state="translated">이 기능에 의해 백업됩니다 &lt;a href=&quot;https://github.com/ai/browserslist&quot;&gt;Browserlist&lt;/a&gt; 및 &lt;a href=&quot;http://caniuse.com/&quot;&gt;수 있습니까 사용&lt;/a&gt; . 이러한 웹 사이트는 브라우저의 사용 통계를 추적하므로 모든 브라우저의 사용자 기반에 따라 복잡한 쿼리를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5f27096f81286c74af81139f2656aefdd7ce466" translate="yes" xml:space="preserve">
          <source>This form does not work with native decorators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42e04b12a3e8406ffc417ced15bf24d60f4988fe" translate="yes" xml:space="preserve">
          <source>This form of &lt;code&gt;tracked&lt;/code&gt; also accepts an optional configuration object containing either an initial &lt;code&gt;value&lt;/code&gt; or an &lt;code&gt;initializer&lt;/code&gt; function (but not both).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90f88dc9d490b3e27b450d9ddbd71c7b8b636e53" translate="yes" xml:space="preserve">
          <source>This function asserts that all objects which have associated destructors or associated children have been destroyed at the time it is called. It is meant to be a low level hook that testing frameworks can use to hook into and validate that all destroyables have in fact been destroyed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03b7e29be2a6d0b1b9a7c23f78882cd55b024912" translate="yes" xml:space="preserve">
          <source>This function instructs the destroyable system to keep track of all destroyables (their children, destructors, etc). This enables a future usage of &lt;code&gt;assertDestroyablesDestroyed&lt;/code&gt; to be used to ensure that all destroyable tasks (registered destructors and associated children) have completed when &lt;code&gt;assertDestroyablesDestroyed&lt;/code&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64538eeaa69495fbf439bdd1cfc24f0232fa5ecb" translate="yes" xml:space="preserve">
          <source>This function is used to associate a destroyable object with a parent. When the parent is destroyed, all registered children will also be destroyed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83f2bb14b91e952f8096d91d5ace072d883fe155" translate="yes" xml:space="preserve">
          <source>This function requires that &lt;code&gt;enableDestroyableTracking&lt;/code&gt; was called previously, and is only available in non-production builds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecc77b26d29bca9f5a5a76e216f7aa3707d9f628" translate="yes" xml:space="preserve">
          <source>This function should return negative number (e.g. &lt;code&gt;-1&lt;/code&gt;) when &lt;code&gt;itemA&lt;/code&gt; should come before &lt;code&gt;itemB&lt;/code&gt;. It should return positive number (e.g. &lt;code&gt;1&lt;/code&gt;) when &lt;code&gt;itemA&lt;/code&gt; should come after &lt;code&gt;itemB&lt;/code&gt;. If the &lt;code&gt;itemA&lt;/code&gt; and &lt;code&gt;itemB&lt;/code&gt; are equal this function should return &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;itemA&lt;/code&gt; 가 &lt;code&gt;itemB&lt;/code&gt; 앞에 오면 음수 (예 : &lt;code&gt;-1&lt;/code&gt; )를 반환 해야합니다 . &lt;code&gt;itemA&lt;/code&gt; 가 &lt;code&gt;itemB&lt;/code&gt; 뒤에 올 때 양수 (예 : &lt;code&gt;1&lt;/code&gt; )를 반환 해야합니다 . 는 IF &lt;code&gt;itemA&lt;/code&gt; 및 &lt;code&gt;itemB&lt;/code&gt; 은 동일한 기능이 돌려 &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f30316f73cbc0d1bc15eef0cddcc2f8521c3da8f" translate="yes" xml:space="preserve">
          <source>This function takes an optional 2nd argument that will become the &quot;this&quot; value for the callback. If this argument is passed then the 3rd argument becomes the function.</source>
          <target state="translated">이 함수는 콜백의 &quot;this&quot;값이 될 선택적 두 번째 인수를 사용합니다. 이 인수가 전달되면 세 번째 인수가 함수가됩니다.</target>
        </trans-unit>
        <trans-unit id="569c2d2cb1416ab5465654a84f35d8786fd5b227" translate="yes" xml:space="preserve">
          <source>This function takes an optional 2nd argument that will become the &quot;this&quot; value for the callback. When the target parameter is used the callback method becomes the third argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4f4cb957931dcfb537731cc8f27357bfd707b9e" translate="yes" xml:space="preserve">
          <source>This generates the following HTML:</source>
          <target state="translated">다음과 같은 HTML이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="b56834d4d36dbad6e5fe72083562d1d2e8904eaf" translate="yes" xml:space="preserve">
          <source>This generates this file:</source>
          <target state="translated">이 파일을 생성합니다 :</target>
        </trans-unit>
        <trans-unit id="acffd8287f5f7fa62edb1b3b419955bbdbbac080" translate="yes" xml:space="preserve">
          <source>This gives you the flexibility to compute a value &lt;em&gt;before&lt;/em&gt; it is passed in as an argument or an attribute of another.</source>
          <target state="translated">이를 통해 인수 또는 다른 속성으로 전달 &lt;em&gt;되기 전에&lt;/em&gt; 값을 유연하게 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4dbabbfbc43356c6224bdd446df2e419dd36b317" translate="yes" xml:space="preserve">
          <source>This guide assumes that you have read the &lt;a href=&quot;https://guides.emberjs.com/components/&quot;&gt;component guides&lt;/a&gt; and are familiar with how Ember components work. We'll cover components in more depth in this section. At the end, we'll present recommended component patterns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3fcb44dfac184e5f4739827479344f6a392ecca" translate="yes" xml:space="preserve">
          <source>This guide doesn't intend to fully delve into all the different ways promises can be used, but if you'd like a more thorough introduction, take a look at the readme for &lt;a href=&quot;https://github.com/tildeio/rsvp.js&quot;&gt;RSVP&lt;/a&gt;, the promise library that Ember uses.</source>
          <target state="translated">이 안내서는 약속이 사용될 수있는 모든 다른 방법을 완전히 탐구하지는 않지만보다 철저한 소개를 원한다면 Ember가 사용하는 약속 라이브러리 인 &lt;a href=&quot;https://github.com/tildeio/rsvp.js&quot;&gt;RSVP&lt;/a&gt; 에 대한 추가 정보를 살펴보십시오 .</target>
        </trans-unit>
        <trans-unit id="519728bf5c4799871945553705bcdcc4b7233129" translate="yes" xml:space="preserve">
          <source>This guide is for developers who already know Ember, and who want to learn the new concepts introduced by Octane, Ember's first Edition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bf01cc260ad5042f4b62199661456049868a798" translate="yes" xml:space="preserve">
          <source>This guide will go over the basics of classes, along with two new features that are still in development in JavaScript: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Field_declarations&quot;&gt;class fields&lt;/a&gt; and &lt;a href=&quot;https://github.com/tc39/proposal-decorators&quot;&gt;decorators&lt;/a&gt;. We use these features in Ember because they are very useful and make writing class code much easier, and they have made it far enough along the process of being added to JavaScript to depend on in production applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0e66094f6d943792b41d17683719c61a494f26d" translate="yes" xml:space="preserve">
          <source>This guide will teach you how to build a simple app using Ember from scratch.</source>
          <target state="translated">이 안내서는 Ember를 사용하여 처음부터 간단한 앱을 작성하는 방법을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="30d220e5292c20d9ac340b310df750f8c7cfdd17" translate="yes" xml:space="preserve">
          <source>This happens if you are using a version of Ember &amp;lt; 1.3.</source>
          <target state="translated">Ember &amp;lt;1.3 버전을 사용하는 경우에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="02c316553c03e6bb16963930257b1149ad1c5f21" translate="yes" xml:space="preserve">
          <source>This has the effect of providing a default template when using a component in the non-block form but providing yielded values for use with block params when using a block expression.</source>
          <target state="translated">이는 비 블록 형태의 구성 요소를 사용할 때 기본 템플리트를 제공하지만 블록 표현식을 사용할 때 블록 매개 변수와 함께 사용할 수있는 값을 제공하는 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d69577f3c578c6eabf0c4658463bd74f9978c696" translate="yes" xml:space="preserve">
          <source>This helper can later be called without arguments because it will be called with &lt;code&gt;app&lt;/code&gt; as the first parameter.</source>
          <target state="translated">이 도우미는 나중에 &lt;code&gt;app&lt;/code&gt; 없이 첫 번째 매개 변수로 호출되므로 인수없이 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9980bdea2787a4277e138ccf5100590320a94254" translate="yes" xml:space="preserve">
          <source>This helper has two forms, block and inline.</source>
          <target state="translated">이 도우미에는 블록과 인라인의 두 가지 형태가 있습니다.</target>
        </trans-unit>
        <trans-unit id="78766705ae99c240131efc47a151aeeb110c957c" translate="yes" xml:space="preserve">
          <source>This helper returns a new property descriptor that wraps the passed computed property function. You can use this helper to define properties with mixins or via &lt;code&gt;Ember.defineProperty()&lt;/code&gt;.</source>
          <target state="translated">이 도우미는 전달 된 계산 된 속성 함수를 래핑하는 새로운 속성 설명자를 반환합니다. 이 헬퍼를 사용하여 mixin 또는 &lt;code&gt;Ember.defineProperty()&lt;/code&gt; 를 통해 속성을 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="be36723a46b5b249d9e1dbdbd2ab416928f233bd" translate="yes" xml:space="preserve">
          <source>This helper returns a new property descriptor that wraps the passed computed property function. You can use this helper to define properties with native decorator syntax, mixins, or via &lt;code&gt;defineProperty()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10ab382783ea15303c4f3ab1e310527699744871" translate="yes" xml:space="preserve">
          <source>This helper will output a value of &lt;code&gt;6&lt;/code&gt;.</source>
          <target state="translated">이 도우미는 &lt;code&gt;6&lt;/code&gt; 값을 출력합니다 .</target>
        </trans-unit>
        <trans-unit id="6c987e5674d133f7c1af95e69f41a85eb2745738" translate="yes" xml:space="preserve">
          <source>This hook defers the readiness of the application, so that you can start the app when your tests are ready to run. It also sets the router's location to 'none', so that the window's location will not be modified (preventing both accidental leaking of state between tests and interference with your testing framework). &lt;code&gt;setupForTesting&lt;/code&gt; should only be called after setting a custom &lt;code&gt;router&lt;/code&gt; class (for example &lt;code&gt;App.Router = Router.extend(&lt;/code&gt;).</source>
          <target state="translated">이 후크는 응용 프로그램의 준비 상태를 지연시켜 테스트를 실행할 준비가되었을 때 앱을 시작할 수 있도록합니다. 또한 라우터의 위치를 ​​'없음'으로 설정하여 창의 위치가 수정되지 않도록합니다 (테스트 사이에 실수로 상태가 누출되거나 테스트 프레임 워크와의 간섭이 발생하지 않도록 함). &lt;code&gt;setupForTesting&lt;/code&gt; 은 사용자 정의 &lt;code&gt;router&lt;/code&gt; 클래스를 설정 한 후에 만 ​​호출해야합니다 (예 : &lt;code&gt;App.Router = Router.extend(&lt;/code&gt; )).</target>
        </trans-unit>
        <trans-unit id="9f3850932b6cdc771f8eba24e4c0356c191dabae" translate="yes" xml:space="preserve">
          <source>This hook follows the asynchronous/promise semantics described in the documentation for &lt;code&gt;beforeModel&lt;/code&gt;. In particular, if a promise returned from &lt;code&gt;model&lt;/code&gt; fails, the error will be handled by the &lt;code&gt;error&lt;/code&gt; hook on &lt;code&gt;Ember.Route&lt;/code&gt;.</source>
          <target state="translated">이 후크는 &lt;code&gt;beforeModel&lt;/code&gt; 문서에 설명 된 비동기 / 약속 시맨틱을 따릅니다 . 특히, &lt;code&gt;model&lt;/code&gt; 에서 반환 된 약속 이 실패하면 오류는 &lt;code&gt;Ember.Route&lt;/code&gt; 의 &lt;code&gt;error&lt;/code&gt; 후크에 의해 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="4516c5380128a6d4a51ce2dd886f6a079aeafb21" translate="yes" xml:space="preserve">
          <source>This hook follows the asynchronous/promise semantics described in the documentation for &lt;code&gt;beforeModel&lt;/code&gt;. In particular, if a promise returned from &lt;code&gt;model&lt;/code&gt; fails, the error will be handled by the &lt;code&gt;error&lt;/code&gt; hook on &lt;code&gt;Route&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff4a499b1734e2648c668e8abe544aa5bbb1bac0" translate="yes" xml:space="preserve">
          <source>This hook has the following timing semantics:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2c3771a5c2a2c87e58d1d7c291c46a9fa428f30" translate="yes" xml:space="preserve">
          <source>This hook is &lt;em&gt;not&lt;/em&gt; autotracked - changes to tracked values used within this hook will &lt;em&gt;not&lt;/em&gt; result in a call to any of the other lifecycle hooks. This is because it is unclear what should happen if it invalidates, and rather than make a decision at this point, the initial API is aiming to allow as much expressivity as possible. This could change in the future with changes to capabilities and their behaviors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8ee41feb9ddc3fa7957fac4385c3669d97c9aa0" translate="yes" xml:space="preserve">
          <source>This hook is called after this route's model has resolved. It follows identical async/promise semantics to &lt;code&gt;beforeModel&lt;/code&gt; but is provided the route's resolved model in addition to the &lt;code&gt;transition&lt;/code&gt;, and is therefore suited to performing logic that can only take place after the model has already resolved.</source>
          <target state="translated">이 라우트는이 경로의 모델이 해결 된 후에 호출됩니다. &lt;code&gt;beforeModel&lt;/code&gt; 과 동일한 비동기 / 약속 시맨틱을 따르지만 &lt;code&gt;transition&lt;/code&gt; 외에도 경로의 해석 된 모델이 제공 되므로 모델이 이미 해석 된 후에 만 ​​수행 할 수있는 논리를 수행하는 데 적합합니다.</target>
        </trans-unit>
        <trans-unit id="91fc7822f66113746c2dc6a2c52016d2d0d0b2ea" translate="yes" xml:space="preserve">
          <source>This hook is called when the value is requested from the helper (e.g. when the template is rendering and the helper value is needed). The hook is autotracked, and will rerun whenever any tracked values used inside of it are updated. Otherwise it does not rerun.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eabb2494e26202e5215d9e0f9642c252667f7896" translate="yes" xml:space="preserve">
          <source>This hook is executed when the router completely exits this route. It is not executed when the model for the route changes.</source>
          <target state="translated">이 후크는 라우터가이 경로를 완전히 종료 할 때 실행됩니다. 라우트 모델이 변경되면 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ab287814fce6cc5b5c9f8e315d84a3c408dbd520" translate="yes" xml:space="preserve">
          <source>This hook is executed when the router enters the route. It is not executed when the model for the route changes.</source>
          <target state="translated">이 훅은 라우터가 경로에 들어갈 때 실행됩니다. 라우트 모델이 변경되면 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="af76bb7c096814efef9043709f61f4f387940cbb" translate="yes" xml:space="preserve">
          <source>This hook is only called for helpers with the &lt;code&gt;hasScheduledEffect&lt;/code&gt; capability enabled. This hook is also not called in SSR currently, though this could be added as a capability in the future. It has the following timing semantics:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27f0d6018950fffa85b3cd23c210ac2ced77d849" translate="yes" xml:space="preserve">
          <source>This hook is only called for helpers with the &lt;code&gt;hasValue&lt;/code&gt; capability enabled. This hook has the following timing semantics:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ed5112cc8742b9d70e3846b62e3c7a4f35140f1" translate="yes" xml:space="preserve">
          <source>This hook is provided the current &lt;code&gt;transition&lt;/code&gt; attempt as a parameter, which can be used to &lt;code&gt;.abort()&lt;/code&gt; the transition, save it for a later &lt;code&gt;.retry()&lt;/code&gt;, or retrieve values set on it from a previous hook. You can also just call &lt;code&gt;this.transitionTo&lt;/code&gt; to another route to implicitly abort the &lt;code&gt;transition&lt;/code&gt;.</source>
          <target state="translated">이 후크는 현재 제공되는 &lt;code&gt;transition&lt;/code&gt; 하는데 사용될 수있는 매개 변수로서 시도 &lt;code&gt;.abort()&lt;/code&gt; 이후의 저장을 위해 천이를 &lt;code&gt;.retry()&lt;/code&gt; 또는 이전 후크에서 설정 값을 검색한다. &lt;code&gt;this.transitionTo&lt;/code&gt; 를 다른 경로로 호출 하여 &lt;code&gt;transition&lt;/code&gt; 을 암시 적으로 중단 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9c61f00c51ff62a7e2fe708f7669b39e4f7e010f" translate="yes" xml:space="preserve">
          <source>This hook is scheduled to be called some time after render and prior to paint. There is not a guaranteed, 1-to-1 relationship between a render pass and this hook firing. For instance, multiple render passes could occur, and the hook may only trigger once. It may also never trigger if it was dirtied in one render pass and then destroyed in the next.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03eecee84bea910e6f484a02d840e085770096a0" translate="yes" xml:space="preserve">
          <source>This hook is the first of the route entry validation hooks called when an attempt is made to transition into a route or one of its children. It is called before &lt;code&gt;model&lt;/code&gt; and &lt;code&gt;afterModel&lt;/code&gt;, and is appropriate for cases when:</source>
          <target state="translated">이 후크는 경로 또는 하위 경로 중 하나로 전환하려고 할 때 호출되는 첫 번째 경로 항목 유효성 검증 후크입니다. &lt;code&gt;model&lt;/code&gt; 및 &lt;code&gt;afterModel&lt;/code&gt; 전에 호출 되며 다음과 같은 경우에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="77e8a262fef81666b48b6131a8b3be017a044f7d" translate="yes" xml:space="preserve">
          <source>This hook passes the class being set up, as well as the key and value being defined. So, for example, when the user does this:</source>
          <target state="translated">이 후크는 설정중인 키와 값뿐만 아니라 설정중인 클래스를 전달합니다. 예를 들어, 사용자가이를 수행 할 때 :</target>
        </trans-unit>
        <trans-unit id="b11aa29d15777ceef5c81c577245a76748891249" translate="yes" xml:space="preserve">
          <source>This hook would be called with &quot;parent&quot; as the key and the computed property returned by &lt;code&gt;DS.belongsTo&lt;/code&gt; as the value.</source>
          <target state="translated">이 후크는 &quot;parent&quot;를 키로 사용하고 &lt;code&gt;DS.belongsTo&lt;/code&gt; 가 값을 반환하는 계산 된 속성으로 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="3fc7a1f064649acf207da18e9b59a14b7d7c2ed5" translate="yes" xml:space="preserve">
          <source>This illustrates that once you change a query param, it is stored and tied to the model loaded into the route.</source>
          <target state="translated">이는 쿼리 매개 변수를 변경 한 후에는 쿼리 매개 변수가 저장되고 경로에로드 된 모델에 연결되어 있음을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="94954009755f7b62385acf4ff8569cb1a9193610" translate="yes" xml:space="preserve">
          <source>This implementation groups together records that have the same base URL but differing ids. For example &lt;code&gt;/comments/1&lt;/code&gt; and &lt;code&gt;/comments/2&lt;/code&gt; will be grouped together because we know findMany can coalesce them together as &lt;code&gt;/comments?ids[]=1&amp;amp;ids[]=2&lt;/code&gt;</source>
          <target state="translated">이 구현은 기본 URL은 동일하지만 ID가 다른 레코드를 그룹화합니다. 예를 들어 &lt;code&gt;/comments/1&lt;/code&gt; 과 &lt;code&gt;/comments/2&lt;/code&gt; 는 &lt;code&gt;/comments?ids[]=1&amp;amp;ids[]=2&lt;/code&gt; 로 통합 할 수 있다는 것을 알기 때문에 그룹화됩니다.</target>
        </trans-unit>
        <trans-unit id="43a57a8aa1cac3820168c45cb5637c10d424bc60" translate="yes" xml:space="preserve">
          <source>This initializer will now have the name &lt;code&gt;my-logger&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc9ad364e420bf1a681684a934117cc1159d58e2" translate="yes" xml:space="preserve">
          <source>This injects the shopping cart service into the component and makes it available as the &lt;code&gt;cart&lt;/code&gt; property.</source>
          <target state="translated">이렇게하면 장바구니 서비스가 구성 요소에 주입되어 &lt;code&gt;cart&lt;/code&gt; 속성으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="32952c300d761f7fe44ea070c8e1f6c98890254d" translate="yes" xml:space="preserve">
          <source>This injects the shopping cart service into the component and makes it available as the &lt;code&gt;shoppingCart&lt;/code&gt; property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="918384a3831377bfd82a1b852b04244ee7f5702c" translate="yes" xml:space="preserve">
          <source>This injects the test helpers into the &lt;code&gt;helperContainer&lt;/code&gt; object. If an object is provided it will be used as the helperContainer. If &lt;code&gt;helperContainer&lt;/code&gt; is not set it will default to &lt;code&gt;window&lt;/code&gt;. If a function of the same name has already been defined it will be cached (so that it can be reset if the helper is removed with &lt;code&gt;unregisterHelper&lt;/code&gt; or &lt;code&gt;removeTestHelpers&lt;/code&gt;).</source>
          <target state="translated">그러면 테스트 헬퍼가 &lt;code&gt;helperContainer&lt;/code&gt; 오브젝트에 주입 됩니다. 객체가 제공되면 helperContainer로 사용됩니다. 경우 &lt;code&gt;helperContainer&lt;/code&gt; 이 설정되지 않은이 기본값이됩니다 &lt;code&gt;window&lt;/code&gt; . 동일한 이름의 함수가 이미 정의되어 있으면 캐시됩니다 ( &lt;code&gt;unregisterHelper&lt;/code&gt; 또는 &lt;code&gt;removeTestHelpers&lt;/code&gt; 로 도우미를 제거하면 재설정 할 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="f723a6881e5d6d4df77092077259b1e266ea97bd" translate="yes" xml:space="preserve">
          <source>This is a concept that typically means providing JavaScript which tests for features that are missing (prototypes not defined, etc) and &quot;fills&quot; them by providing an implementation.</source>
          <target state="translated">이것은 일반적으로 누락 된 기능 (정의되지 않은 프로토 타입 등)을 테스트하고 구현을 제공하여 &quot;채우는&quot;JavaScript를 제공한다는 개념입니다.</target>
        </trans-unit>
        <trans-unit id="b176511dc82a11995524ba7ee6d3eaf35d75f683" translate="yes" xml:space="preserve">
          <source>This is a container for an assortment of testing related functionality:</source>
          <target state="translated">다음은 다양한 테스트 관련 기능을위한 컨테이너입니다.</target>
        </trans-unit>
        <trans-unit id="9c26132c65fad6b850f1d387d6b3b5c7d82263a8" translate="yes" xml:space="preserve">
          <source>This is a convenient alias for &lt;code&gt;Promise.all&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a63f64e440a57d49236d809d5040ac1f45e1e988" translate="yes" xml:space="preserve">
          <source>This is a convenient alias for &lt;code&gt;Promise.race&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dbd81e39a9935f1225a812f3c6adac63a0c0789" translate="yes" xml:space="preserve">
          <source>This is a convenient alias for &lt;code&gt;Promise.reject&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7154e612ed9db7397dd7cf0cf599eeb3ccfdf549" translate="yes" xml:space="preserve">
          <source>This is a convenient alias for &lt;code&gt;Promise.resolve&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="822a2e55a49b0a3ce1602c9de4a12deec4027902" translate="yes" xml:space="preserve">
          <source>This is a convenient alias for &lt;code&gt;RSVP.Promise.all&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;RSVP.Promise.all&lt;/code&gt; 의 편리한 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="a49db288a4492f38be2239b9a4aecd51132e4df3" translate="yes" xml:space="preserve">
          <source>This is a convenient alias for &lt;code&gt;RSVP.Promise.race&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;RSVP.Promise.race&lt;/code&gt; 의 편리한 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="c5311bad197bc2e95ae7fce155d89195d60075c0" translate="yes" xml:space="preserve">
          <source>This is a convenient alias for &lt;code&gt;RSVP.Promise.reject&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;RSVP.Promise.reject&lt;/code&gt; 의 편리한 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="302b1ad84c9db80e1b5c3df3fe7952f0681a2eae" translate="yes" xml:space="preserve">
          <source>This is a convenient alias for &lt;code&gt;RSVP.Promise.resolve&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;RSVP.Promise.resolve&lt;/code&gt; 의 편리한 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="4971ebf34a654ca424132ff11439c59713fb5e6b" translate="yes" xml:space="preserve">
          <source>This is a great way to use the parent context to load something that you want. Using &lt;code&gt;paramsFor&lt;/code&gt; will also give you the query params defined on that route's controller. This method could also be used to look up the current route's parameters from an action or another method on the route, and in that case we have a shortcut: &lt;code&gt;this.paramsFor(this.routeName)&lt;/code&gt;.</source>
          <target state="translated">이것은 부모 컨텍스트를 사용하여 원하는 것을로드하는 좋은 방법입니다. &lt;code&gt;paramsFor&lt;/code&gt; 를 사용하면 해당 경로의 컨트롤러에 정의 된 쿼리 매개 변수도 제공됩니다. 이 메소드는 액션이나 라우트의 다른 메소드에서 현재 라우트의 매개 변수를 찾는 데 사용될 수 있으며,이 경우 바로 가기 &lt;code&gt;this.paramsFor(this.routeName)&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="55cd0539422e5b82b20c0cc8f62bbdbb7052339e" translate="yes" xml:space="preserve">
          <source>This is a helper to be used in conjunction with the link-to helper. It will supply url query parameters to the target route.</source>
          <target state="translated">이것은 링크 헬퍼와 함께 사용되는 헬퍼입니다. URL 쿼리 매개 변수를 대상 경로에 제공합니다.</target>
        </trans-unit>
        <trans-unit id="05915bea473f3b9dca751ce1d38f16283b7858bd" translate="yes" xml:space="preserve">
          <source>This is a more semantically meaningful alias of &lt;code&gt;computed.oneWay&lt;/code&gt;, whose name is somewhat ambiguous as to which direction the data flows.</source>
          <target state="translated">이것은 의미 적으로 의미가있는 &lt;code&gt;computed.oneWay&lt;/code&gt; 의 별칭 으로, 데이터가 어느 방향으로 흐르는 지에 대한 이름이 다소 모호합니다.</target>
        </trans-unit>
        <trans-unit id="6d8df01af0767ac4f864bdb935d5fd81c46a68ea" translate="yes" xml:space="preserve">
          <source>This is a replacement for &lt;code&gt;{{action}}&lt;/code&gt; when it is used as a modifier:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76ffabe250c4850f0de1f943c4559093a6f83c75" translate="yes" xml:space="preserve">
          <source>This is a replacement for passing parameters to the &lt;code&gt;{{action}}&lt;/code&gt; modifier or helper:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46a94c8f55595ad1f21083bd7fb3718a4dbf03a0" translate="yes" xml:space="preserve">
          <source>This is a stamp for the Ember Inspector to differentiate between the versions to be able to support older versions too.</source>
          <target state="translated">Ember Inspector가 이전 버전도 지원할 수 있도록 버전을 구별하기위한 스탬프입니다.</target>
        </trans-unit>
        <trans-unit id="ec2df623b6ecc9f4e570340c54e42cd3266c977a" translate="yes" xml:space="preserve">
          <source>This is actually used internally by the &lt;code&gt;keyEvent&lt;/code&gt; helper like so:</source>
          <target state="translated">이것은 실제로 다음과 같이 &lt;code&gt;keyEvent&lt;/code&gt; 도우미에 의해 내부적으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="cae98a4a7769d71f37361f60ba843a38154b60b5" translate="yes" xml:space="preserve">
          <source>This is also useful when working with older Ember code which has not yet been updated to tracked properties. If you're unsure, you can use &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; to be safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="308ba443f81e87e775aa3ae34fbf288a703e8c5c" translate="yes" xml:space="preserve">
          <source>This is an interface class that exists purely to document the available options; you do not need to construct it manually. Simply pass a regular JavaScript object containing the desired options into methods that require one of these options object:</source>
          <target state="translated">사용 가능한 옵션을 문서화하기 위해 존재하는 인터페이스 클래스입니다. 수동으로 구성 할 필요가 없습니다. 원하는 옵션이 포함 된 일반 JavaScript 객체를 다음 옵션 객체 중 하나가 필요한 메소드에 전달하면됩니다.</target>
        </trans-unit>
        <trans-unit id="b98c4393def85ba88d54bfd3c7d44f84bd97ad65" translate="yes" xml:space="preserve">
          <source>This is considered best practice, since it means that methods will be bound correctly no matter where they are used. By contrast, the &lt;code&gt;{{action}}&lt;/code&gt; helper and modifier can also be used to bind context, but it will be required for every usage of the method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52b5acc36d459304c86eb8b1da50a28c5a055843" translate="yes" xml:space="preserve">
          <source>This is equivalent to having the following entry in &lt;code&gt;app/router.js&lt;/code&gt; file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b6d36748b25d028f4bf8ba16c564fda1c4ec965" translate="yes" xml:space="preserve">
          <source>This is especially useful if you are passing properties to a component that receives a lot of options and you want to clean up the invocation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="306dec7bd8c7954e508c1735c09535d1dd8b815e" translate="yes" xml:space="preserve">
          <source>This is especially useful when you depend on properties of an object, since it allows you to replace:</source>
          <target state="translated">다음과 같이 바꿀 수 있기 때문에 객체의 속성에 의존 할 때 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="c46a6c0ebb4282802f95e4e63e750434a46d6914" translate="yes" xml:space="preserve">
          <source>This is exactly equivalent to the &lt;code&gt;format-currency&lt;/code&gt; example above. You can think of the function version as a shorthand for the longer class form if it does not require dependency injection.</source>
          <target state="translated">이것은 위 의 &lt;code&gt;format-currency&lt;/code&gt; 예 와 정확히 동일합니다 . 의존성 주입이 필요하지 않으면 함수 버전을 더 긴 클래스 형식의 속기라고 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80b9a9d98da12b68b0c4b2e6f44b4b81fb921c26" translate="yes" xml:space="preserve">
          <source>This is generally used internally from the acceptance/integration test infrastructure.</source>
          <target state="translated">이는 일반적으로 수락 / 통합 테스트 인프라에서 내부적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a02623baf101f6c1f72c8f3ddff6f2d7a7b7ddbb" translate="yes" xml:space="preserve">
          <source>This is guaranteed to work because the parent route is loaded. But if you tried to do &lt;code&gt;paramsFor&lt;/code&gt; on a sibling route, you wouldn't have the results you expected.</source>
          <target state="translated">부모 경로가로드되었으므로 작동합니다. 그러나 형제 루트에서 &lt;code&gt;paramsFor&lt;/code&gt; 를 시도 하면 예상 한 결과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="33576dec1bb55808eaf77c0499cb0de647da565d" translate="yes" xml:space="preserve">
          <source>This is just one example of how developers can use HTML's built in features to improve accessibility and reduce the need for custom code. Read more here: &lt;a href=&quot;https://developer.paciellogroup.com/blog/2011/04/html5-accessibility-chops-just-use-a-button/&quot;&gt;&quot;Just use a button&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa36d77986525618ad7065da5d31723d28369a95" translate="yes" xml:space="preserve">
          <source>This is most often used as the return value for the helper functions (see 'click', 'fillIn','visit',etc). However, there is a method to register a test helper which utilizes this method without the need to actually call &lt;code&gt;wait()&lt;/code&gt; in your helpers.</source>
          <target state="translated">이것은 도우미 함수의 반환 값으로 가장 자주 사용됩니다 ( 'click', 'fillIn', 'visit'등 참조). 그러나 헬퍼에서 실제로 &lt;code&gt;wait()&lt;/code&gt; 를 호출 할 필요없이이 메소드를 사용하는 테스트 헬퍼를 등록하는 메소드 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e012518624cc2f89b04d821689a88883b2eadb7c" translate="yes" xml:space="preserve">
          <source>This is not an Ember application</source>
          <target state="translated">이것은 Ember 애플리케이션이 아닙니다</target>
        </trans-unit>
        <trans-unit id="c62cbb1d5e63e1e37b85a51686c003fd0001230a" translate="yes" xml:space="preserve">
          <source>This is not just a performance optimization. If an attribute has not changed, it is important not to clobber the element's &quot;hidden state&quot;. For example, if you set an input's &lt;code&gt;value&lt;/code&gt; to the same value as before, it will clobber selection state and cursor position. In other words, setting an attribute is not &lt;strong&gt;always&lt;/strong&gt; idempotent.</source>
          <target state="translated">이것은 단지 성능 최적화가 아닙니다. 속성이 변경되지 않은 경우 요소의 &quot;숨겨진 상태&quot;를 방해하지 않는 것이 중요합니다. 당신이 입력의 설정 예를 들어, &lt;code&gt;value&lt;/code&gt; 이전과 동일한 값으로,이 선택 상태 및 커서 위치를 소지품 것입니다. 다시 말해, 속성 설정이 &lt;strong&gt;항상&lt;/strong&gt; dem 등한 것은 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="2539c270f8689ccfed557582f8b1c7e030447925" translate="yes" xml:space="preserve">
          <source>This is one of the primitives you must implement to support &lt;code&gt;Array&lt;/code&gt;. You should replace amt objects started at idx with the objects in the passed array. You should also call &lt;code&gt;this.arrayContentDidChange()&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfe703d974f911cefa2119330aa9316aad45d5a9" translate="yes" xml:space="preserve">
          <source>This is one of the primitives you must implement to support &lt;code&gt;Ember.Array&lt;/code&gt;. If your object supports retrieving the value of an array item using &lt;code&gt;get()&lt;/code&gt; (i.e. &lt;code&gt;myArray.get(0)&lt;/code&gt;), then you do not need to implement this method yourself.</source>
          <target state="translated">이것은 &lt;code&gt;Ember.Array&lt;/code&gt; 를 지원하기 위해 구현해야하는 기본 요소 중 하나입니다 . 객체가 &lt;code&gt;get()&lt;/code&gt; (예 : &lt;code&gt;myArray.get(0)&lt;/code&gt; )을 사용하여 배열 항목의 값 검색을 지원 하면이 메소드를 직접 구현할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e9a9fd73a9f803dbe1cc43144f590d9b54349043" translate="yes" xml:space="preserve">
          <source>This is one of the primitives you must implement to support &lt;code&gt;Ember.Array&lt;/code&gt;. You should replace amt objects started at idx with the objects in the passed array. You should also call &lt;code&gt;this.enumerableContentDidChange()&lt;/code&gt;</source>
          <target state="translated">이것은 &lt;code&gt;Ember.Array&lt;/code&gt; 를 지원하기 위해 구현해야하는 기본 요소 중 하나입니다 . idx에서 시작한 amt 객체를 전달 된 배열의 객체로 바꿔야합니다. &lt;code&gt;this.enumerableContentDidChange()&lt;/code&gt; 도 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="a74aba5bf2dd635bf9b1cda3fbe336d3243b3f69" translate="yes" xml:space="preserve">
          <source>This is one of the primitives you must implement to support &lt;code&gt;EmberArray&lt;/code&gt;. If your object supports retrieving the value of an array item using &lt;code&gt;get()&lt;/code&gt; (i.e. &lt;code&gt;myArray.get(0)&lt;/code&gt;), then you do not need to implement this method yourself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f356f63243afe37729165e88f111f35dc1627c0e" translate="yes" xml:space="preserve">
          <source>This is particularly useful for polymorphic relationships where records don't share the same table and the &lt;code&gt;id&lt;/code&gt; is not enough information.</source>
          <target state="translated">레코드가 동일한 테이블을 공유하지 않고 &lt;code&gt;id&lt;/code&gt; 가 충분한 정보가 아닌 다형성 관계에 특히 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="202d339791e806b1e70147736eb9208a5f3911be" translate="yes" xml:space="preserve">
          <source>This is primarily used when syncing bindings, which may try to update after an object has been destroyed.</source>
          <target state="translated">이것은 바인딩을 동기화 할 때 주로 사용되며, 객체가 파괴 된 후에 업데이트를 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="daeaceef80ff296a12644de6285774c59ae74c52" translate="yes" xml:space="preserve">
          <source>This is the core method used to register an observer for a property.</source>
          <target state="translated">이것은 속성에 대한 관찰자를 등록하는 데 사용되는 핵심 방법입니다.</target>
        </trans-unit>
        <trans-unit id="bac9760d303007d38afed39bbecd73ad9b39f5bb" translate="yes" xml:space="preserve">
          <source>This is the element that will be passed to the Application's, &lt;code&gt;eventDispatcher&lt;/code&gt;, which sets up the listeners for event delegation. Every view in your application should be a child of the element you specify here.</source>
          <target state="translated">이것은 이벤트 위임을위한 리스너를 설정 하는 ApplicationDispatcher &lt;code&gt;eventDispatcher&lt;/code&gt; 로 전달되는 요소입니다 . 응용 프로그램의 모든 뷰는 여기에 지정한 요소의 자식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="3a569fa746c8405832bed1c05febae66d94a94fc" translate="yes" xml:space="preserve">
          <source>This is the extent to which Ember.js enhances native prototypes. We have carefully weighed the trade-offs involved with changing these prototypes, and recommend that most Ember.js developers use them. These extensions significantly reduce the amount of boilerplate code that must be typed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="decc32c6cf9850c53e2f6bac9e782138a3406ae1" translate="yes" xml:space="preserve">
          <source>This is the extent to which Ember.js enhances native prototypes. We have carefully weighed the tradeoffs involved with changing these prototypes, and recommend that most Ember.js developers use them. These extensions significantly reduce the amount of boilerplate code that must be typed.</source>
          <target state="translated">이것은 Ember.js가 기본 프로토 타입을 향상시키는 정도입니다. 우리는 이러한 프로토 타입 변경과 관련된 트레이드 오프를 신중하게 검토했으며 대부분의 Ember.js 개발자가이 프로토 타입을 사용하도록 권장합니다. 이러한 확장은 입력해야하는 상용구 코드의 양을 크게 줄입니다.</target>
        </trans-unit>
        <trans-unit id="94928a1a6bed0b1e582ca40e9000c55b3eb6631f" translate="yes" xml:space="preserve">
          <source>This is the handler for the special array content property. If you get this property, it will return this. If you set this property to a new array, it will replace the current content.</source>
          <target state="translated">이것은 특별한 배열 내용 속성의 핸들러입니다. 이 속성을 가져 오면이를 반환합니다. 이 속성을 새 배열로 설정하면 현재 내용이 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="a3d9ffb17ccc89ae953b1bcdd608ab0903d935a3" translate="yes" xml:space="preserve">
          <source>This is the resolved return value from the route's model hook.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbbcde5990b7a38adaafc218c59a9597d423bbd5" translate="yes" xml:space="preserve">
          <source>This is the syntax for an &lt;code&gt;if&lt;/code&gt; statement in block form. If the &lt;code&gt;condition&lt;/code&gt; is true, Ember will render the content that is inside the block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d0aeb8539d4ac13c1b43ef5712487f0500ab378" translate="yes" xml:space="preserve">
          <source>This is the syntax for an &lt;code&gt;if&lt;/code&gt; statement in inline form. If the &lt;code&gt;condition&lt;/code&gt; is true, Ember will use &lt;code&gt;value&lt;/code&gt; at the invocation site.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f051ff0c94165498e453f7c24f725d220d0bf59d" translate="yes" xml:space="preserve">
          <source>This is the very similar to defining the &lt;code&gt;Person&lt;/code&gt; class with a constructor like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dada04f5800d31f549425491d1886c63a016bd11" translate="yes" xml:space="preserve">
          <source>This is typically a paid service you can use to get great performance for your app. Many CDNs act as caching proxies to your origin server; some require you to upload your assets to them. They give you a URL for each resource in your app. This URL will resolve differently for folks depending on where they're browsing.</source>
          <target state="translated">일반적으로 앱의 성능을 높이기 위해 사용할 수있는 유료 서비스입니다. 많은 CDN은 오리진 서버에 프록시를 캐싱하는 역할을합니다. 일부는 자산을 업로드해야합니다. 앱의 각 리소스에 대한 URL을 제공합니다. 이 URL은 사용자가 탐색하는 위치에 따라 다르게 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="b0dcf6a43e9a72bfb12e3bb5077f5422dc0fbbbe" translate="yes" xml:space="preserve">
          <source>This is useful for communicating assumptions in the code to other human readers as well as catching bugs that accidentally violates these expectations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9029cd114fa0d3c8586307b8eff931586da2bfe7" translate="yes" xml:space="preserve">
          <source>This is useful if you have a good sense of what records the user will need next. When they click on a link, instead of waiting for a network request to finish, Ember.js can render the new template immediately. It feels instantaneous.</source>
          <target state="translated">다음에 사용자에게 필요한 레코드가 무엇인지 잘 알고있는 경우에 유용합니다. 링크를 클릭하면 네트워크 요청이 완료되기를 기다리는 대신 Ember.js가 새 템플릿을 즉시 렌더링 할 수 있습니다. 순간적으로 느낀다.</target>
        </trans-unit>
        <trans-unit id="9c0e2a474431ea68ddf5ecf51a7ea34a70a0a409" translate="yes" xml:space="preserve">
          <source>This is useful in many ways, as the controller specified will be:</source>
          <target state="translated">지정된 컨트롤러는 다음과 같이 여러 가지 방법으로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="05b6a97bb57b5dddb0183025a13b19fcb8089e6d" translate="yes" xml:space="preserve">
          <source>This is useful when you want to create a component that can optionally take a block and then render a default template when it is not invoked with a block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfc8c1ff007f969ec72037eadac7eef5a773d669" translate="yes" xml:space="preserve">
          <source>This is useful when you want to create a component that can render itself differently when it is not invoked with block params.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e62480fdd97ece07a8f43a03399112cd947a3bd" translate="yes" xml:space="preserve">
          <source>This is usually sufficient, so in most cases, the &lt;code&gt;key&lt;/code&gt; option is simply not needed. However, in some rare cases, the objects' identities may change even though they represent the same underlying data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2fb2f884217983006b8b8e8d2fa01aa0d3916bf" translate="yes" xml:space="preserve">
          <source>This is very similar to defining the &lt;code&gt;Permission&lt;/code&gt; class with a constructor like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ade33abb6fdd45e411d88ae2ac98039f0bf103b" translate="yes" xml:space="preserve">
          <source>This is why all Ember's test helpers are wrapped in code that ensures Ember is back in a synchronized state when it makes its assertions. It saves you from having to wrap everything in code that does that, and it makes it easier to read your tests because there's less boilerplate in them.</source>
          <target state="translated">그렇기 때문에 모든 Ember의 테스트 헬퍼가 코드로 감싸 져있어 Ember가 어설 션을 만들 때 동기화 상태로 돌아갑니다. 이를 통해 모든 것을 코드로 감싸지 않아도되며, 상용구가 적기 때문에 테스트를보다 쉽게 ​​읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f81078bdd16c56d5ce8e099f63a66414055f7a65" translate="yes" xml:space="preserve">
          <source>This is why getters should generally &lt;em&gt;avoid&lt;/em&gt; mutating state on the instance, and you should be aware of their performance cost since they'll rerun the code every time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36a619a3c774a79fc088bfa87be2e0068406b665" translate="yes" xml:space="preserve">
          <source>This keeps the responsibilities clearly delineated, and makes it much easier to reason about what each individual API is doing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="373629a051fd9d6a82479c3fb955dcff38bff20a" translate="yes" xml:space="preserve">
          <source>This list of attributes is inherited from the component's superclasses, as well.</source>
          <target state="translated">이 속성 목록은 구성 요소의 수퍼 클래스에서도 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="9d2978c3cf092adf7f085027707c1fa11a58cc84" translate="yes" xml:space="preserve">
          <source>This list of properties is inherited from the component's superclasses as well.</source>
          <target state="translated">이 속성 목록은 구성 요소의 수퍼 클래스에서도 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="fb5f23b5212bb7243dee0fb723c49f54d8ba342c" translate="yes" xml:space="preserve">
          <source>This may be helpful for keeping links active for:</source>
          <target state="translated">링크를 활성 상태로 유지하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48bf2a80eecc91ba8c0cc640cc15dd93a2ce4248" translate="yes" xml:space="preserve">
          <source>This means that all of the following HTML features work as-is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d8d90e20c4960944f5d4bfc511c8c0d5bc0399b" translate="yes" xml:space="preserve">
          <source>This means that the field created is assigned for every &lt;em&gt;instance&lt;/em&gt;, instead of once on the prototype like properties. This has a few important implications:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f1437c8a96afb9704b37db936b4718d9929b39b" translate="yes" xml:space="preserve">
          <source>This means that you no longer have to customize your component using any of the following APIs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4888089f036f3bfaae8dabe19bbed72fa838b8f" translate="yes" xml:space="preserve">
          <source>This method allows for normalization of data when &lt;code&gt;store.pushPayload&lt;/code&gt; is called and should be implemented if you want to use that method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd65fb1a8b4790597e5a153d1da512dab6fb3ee8" translate="yes" xml:space="preserve">
          <source>This method allows for you to split pending requests for records into multiple &lt;code&gt;findMany&lt;/code&gt; requests. It receives an array of snapshots where each snapshot represents a unique record requested via &lt;code&gt;store.findRecord&lt;/code&gt; during the most recent &lt;code&gt;runloop&lt;/code&gt; that was not found in the cache or needs to be reloaded. It should return an array of groups.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="627b891473247bd5815547809011482806305c21" translate="yes" xml:space="preserve">
          <source>This method allows you to push a payload containing top-level collections of records organized per type.</source>
          <target state="translated">이 방법을 사용하면 유형별로 구성된 최상위 레코드 모음이 포함 된 페이로드를 푸시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a33ed191a5e22ddc6587f89a182ff201376ef50b" translate="yes" xml:space="preserve">
          <source>This method also takes a hash of boot-time configuration options for customizing the instance's behavior. See the documentation on &lt;code&gt;ApplicationInstance.BootOptions&lt;/code&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb9e9c872a5cfd75bae202c4ea4839d24085215a" translate="yes" xml:space="preserve">
          <source>This method also takes a hash of boot-time configuration options for customizing the instance's behavior. See the documentation on &lt;code&gt;Ember.ApplicationInstance.BootOptions&lt;/code&gt; for details.</source>
          <target state="translated">이 방법은 또한 인스턴스 동작을 사용자 정의하기 위해 부팅시 구성 옵션의 해시를 사용합니다. 자세한 내용은 &lt;code&gt;Ember.ApplicationInstance.BootOptions&lt;/code&gt; 설명서를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="0d3f7722b1918a033bfc704ab024b6e1cf5c8659" translate="yes" xml:space="preserve">
          <source>This method can be overridden to set up and render additional or alternative templates.</source>
          <target state="translated">추가 또는 대체 템플릿을 설정하고 렌더링하기 위해이 방법을 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75131c915bde03ba240c1d475bfd5896ca45f619" translate="yes" xml:space="preserve">
          <source>This method can be used both to push in brand new records, as well as to update existing records.</source>
          <target state="translated">이 방법을 사용하면 새로운 레코드를 푸시하고 기존 레코드를 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f6b399d017a3f3f52b041707517412999041988" translate="yes" xml:space="preserve">
          <source>This method can be used both to push in brand new records, as well as to update existing records. You can push in more than one type of object at once. All objects should be in the format expected by the serializer.</source>
          <target state="translated">이 방법을 사용하면 새로운 레코드를 푸시하고 기존 레코드를 업데이트 할 수 있습니다. 한 번에 여러 유형의 객체를 밀어 넣을 수 있습니다. 모든 객체는 시리얼 라이저가 예상하는 형식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="b02dc4cad6cf02610e6058c95d7caebe5eb539eb" translate="yes" xml:space="preserve">
          <source>This method can be used when it is certain that the server will return a single object for the primary data.</source>
          <target state="translated">이 메소드는 서버가 기본 데이터에 대한 단일 오브젝트를 리턴 할 것으로 확신 할 때 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31a10777d9035c12a3fcba90767411843e07f906" translate="yes" xml:space="preserve">
          <source>This method delegates a query to the adapter. This is the one place where adapter-level semantics are exposed to the application.</source>
          <target state="translated">이 메소드는 조회를 어댑터에 위임합니다. 이것은 어댑터 레벨 시맨틱이 애플리케이션에 노출되는 곳입니다.</target>
        </trans-unit>
        <trans-unit id="7ae3f2f0c751efc8927d65bfd222cb31c552601f" translate="yes" xml:space="preserve">
          <source>This method delegates to a more specific normalize method based on the &lt;code&gt;requestType&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;code&gt;requestType&lt;/code&gt; 에 따라보다 구체적인 normalize 메소드를 위임합니다 .</target>
        </trans-unit>
        <trans-unit id="a25d67dc575ed0fba225af931e94045db1b5a8f9" translate="yes" xml:space="preserve">
          <source>This method expects normalized &lt;a href=&quot;http://jsonapi.org/&quot;&gt;JSON API&lt;/a&gt; document. This means you have to follow &lt;a href=&quot;http://jsonapi.org/format/&quot;&gt;JSON API specification&lt;/a&gt; with few minor adjustments:</source>
          <target state="translated">이 방법에는 정규화 된 &lt;a href=&quot;http://jsonapi.org/&quot;&gt;JSON API&lt;/a&gt; 문서가 필요합니다. 즉, 약간만 조정 하면 &lt;a href=&quot;http://jsonapi.org/format/&quot;&gt;JSON API 사양&lt;/a&gt; 을 따라야합니다 .</target>
        </trans-unit>
        <trans-unit id="b793cd33b0dda2d7814c4efa8f1fc4cea44de39f" translate="yes" xml:space="preserve">
          <source>This method has the same behavior of JavaScript's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes&quot;&gt;Array.includes&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7df7b83c336ab5cbac360f1c5c272ebe13752bdd" translate="yes" xml:space="preserve">
          <source>This method is &lt;em&gt;only&lt;/em&gt; checked by the store when the store is returning a cached record array.</source>
          <target state="translated">이 방법이 &lt;em&gt;단지&lt;/em&gt; 매장 캐시 기록 배열을 반환 할 때 매장 조사했다.</target>
        </trans-unit>
        <trans-unit id="e8062e08f7c0f7fcdf86622114e1823949507341" translate="yes" xml:space="preserve">
          <source>This method is &lt;em&gt;only&lt;/em&gt; checked by the store when the store is returning a cached record.</source>
          <target state="translated">이 방법이 &lt;em&gt;유일한&lt;/em&gt; 저장소가 캐시 기록을 반환 할 때 상점에 의해 확인.</target>
        </trans-unit>
        <trans-unit id="0d46ff24f336be7a98aa657eb9226dd692056b66" translate="yes" xml:space="preserve">
          <source>This method is called by &lt;code&gt;snapshot.serialize()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="689587cc6e16e93dbddabd5968491f5542448ecf" translate="yes" xml:space="preserve">
          <source>This method is called by the &lt;code&gt;Store&lt;/code&gt; when &lt;code&gt;store.normalize(modelName, payload)&lt;/code&gt; is called. It is recommended to use &lt;code&gt;store.serializerFor(modelName).normalizeResponse&lt;/code&gt; over &lt;code&gt;store.normalize&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3509ace1db000a92db88fe8a1836ad0b7713cbb8" translate="yes" xml:space="preserve">
          <source>This method is called via the container's resolver method. It parses the provided &lt;code&gt;fullName&lt;/code&gt; and then looks up and returns the appropriate template or class.</source>
          <target state="translated">이 메소드는 컨테이너의 리졸버 메소드를 통해 호출됩니다. 제공된 &lt;code&gt;fullName&lt;/code&gt; 을 구문 분석 한 후 적절한 템플리트 또는 클래스를 찾아 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="9ce28964f15279cf3d730ef68345532b784ce703" translate="yes" xml:space="preserve">
          <source>This method is called when &lt;code&gt;transitionTo&lt;/code&gt; is called with a context in order to populate the URL.</source>
          <target state="translated">이 메소드는 URL을 채우기 위해 컨텍스트로 &lt;code&gt;transitionTo&lt;/code&gt; 를 호출 할 때 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="f0c4ee83b8e7fbb139652d78dd5741771d80faf6" translate="yes" xml:space="preserve">
          <source>This method is called when you call &lt;code&gt;query&lt;/code&gt; on the store.</source>
          <target state="translated">이 메소드는 상점에서 &lt;code&gt;query&lt;/code&gt; 를 호출 할 때 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="13a7fe79d0533fe9608f31da98b7023d71e69453" translate="yes" xml:space="preserve">
          <source>This method is called with the controller for the current route and the model supplied by the &lt;code&gt;model&lt;/code&gt; hook.</source>
          <target state="translated">이 메소드는 현재 라우트 및 &lt;code&gt;model&lt;/code&gt; 후크에서 제공 한 모델에 대한 컨트롤러와 함께 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="bbedcce78155921a2bf55755fabf12698cc38674" translate="yes" xml:space="preserve">
          <source>This method is called with the controller for the current route and the model supplied by the &lt;code&gt;model&lt;/code&gt; hook. By default, it renders the route's template, configured with the controller for the route.</source>
          <target state="translated">이 메소드는 현재 라우트 및 &lt;code&gt;model&lt;/code&gt; 후크에서 제공 한 모델에 대한 컨트롤러와 함께 호출됩니다 . 기본적으로 경로에 대한 컨트롤러로 구성된 경로 템플릿을 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="c6d0b6398b87777d58312eba81fe646f7810a695" translate="yes" xml:space="preserve">
          <source>This method is generally very similar to calling &lt;code&gt;object[&quot;key&quot;] = value&lt;/code&gt; or &lt;code&gt;object.key = value&lt;/code&gt;, except that it provides support for computed properties, the &lt;code&gt;setUnknownProperty()&lt;/code&gt; method and property observers.</source>
          <target state="translated">이 메소드는 일반적으로 계산 된 특성, &lt;code&gt;setUnknownProperty()&lt;/code&gt; 메소드 및 특성 관찰자를 지원한다는 점을 제외하고는 &lt;code&gt;object[&quot;key&quot;] = value&lt;/code&gt; 또는 &lt;code&gt;object.key = value&lt;/code&gt; 호출과 매우 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="74bd84dac410bdb6c99add62a62d5417953e7c5c" translate="yes" xml:space="preserve">
          <source>This method is handy for performing intermediate transitions on the way to a final destination route, and is called internally by the default implementations of the &lt;code&gt;error&lt;/code&gt; and &lt;code&gt;loading&lt;/code&gt; handlers.</source>
          <target state="translated">이 방법은 최종 목적지 경로로가는 도중에 중간 전환을 수행하는 데 편리하며 &lt;code&gt;error&lt;/code&gt; 및 &lt;code&gt;loading&lt;/code&gt; 핸들러 의 기본 구현에 의해 내부적으로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="6e1b3ac3cee3c21cae8befd0ad80964b9df49462" translate="yes" xml:space="preserve">
          <source>This method is intended to normalize data into a &lt;a href=&quot;https://jsonapi.org/format/#document-structure&quot;&gt;JSON:API Document&lt;/a&gt; with a data member containing a single &lt;a href=&quot;https://jsonapi.org/format/#document-resource-objects&quot;&gt;Resource&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fea818b09106addf019b8f0b55ff58039848df8" translate="yes" xml:space="preserve">
          <source>This method is responsible for normalizing the value resolved from the promise returned by an Adapter request into the format expected by the &lt;code&gt;Store&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86c218f86eaf174e7d4e58e194162a1a6ff14deb" translate="yes" xml:space="preserve">
          <source>This method is responsible for serializing an individual record via a &lt;a href=&quot;snapshot&quot;&gt;Snapshot&lt;/a&gt; into the format expected by the API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4221d761150152984c7c3ca386868626f2f0a116" translate="yes" xml:space="preserve">
          <source>This method is similar to the &lt;code&gt;find()&lt;/code&gt; method defined in ECMAScript 2015.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa05443efe853cc3f28766f6d6fb9fe7a13a6090" translate="yes" xml:space="preserve">
          <source>This method is used by the store to determine if the store should reload a record after the &lt;code&gt;store.findRecord&lt;/code&gt; method resolves a cached record.</source>
          <target state="translated">이 메소드는 &lt;code&gt;store.findRecord&lt;/code&gt; 메소드가 캐시 된 레코드를 분석 한 후 상점이 레코드를 다시로드해야하는지 여부를 판별하기 위해 상점에서 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="ba3f4183468eab98d1908948e41cd0eef07925e8" translate="yes" xml:space="preserve">
          <source>This method is used by the store to determine if the store should reload a record array after the &lt;code&gt;store.findAll&lt;/code&gt; method resolves with a cached record array.</source>
          <target state="translated">이 메소드는 &lt;code&gt;store.findAll&lt;/code&gt; 메소드가 캐시 된 레코드 배열로 분석 된 후 저장소가 레코드 배열을 다시로드해야하는지 여부를 판별하기 위해 저장소에서 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="0dc1d4e602a3dbc746be228073f7c5e9072291ae" translate="yes" xml:space="preserve">
          <source>This method is used by the store to determine if the store should reload a record from the adapter when a record is requested by &lt;code&gt;store.findRecord&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;code&gt;store.findRecord&lt;/code&gt; 가 레코드를 요청할 때 저장소가 어댑터에서 레코드를 다시로드해야하는지 여부를 판별하기 위해 저장소에서 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="8ce64195ca8b7e509dff95556cc7ab216203e10e" translate="yes" xml:space="preserve">
          <source>This method is used by the store to determine if the store should reload all records from the adapter when records are requested by &lt;code&gt;store.findAll&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;store.findAll&lt;/code&gt; 에서 레코드를 요청할 때 저장소에서 어댑터에서 모든 레코드를 다시로드해야하는지 여부를 판별하기 위해 저장소에서이 메소드를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="726a13d031eb08fa1d97022da145454908c66cf3" translate="yes" xml:space="preserve">
          <source>This method is used to convert each JSON root key in the payload into a modelName that it can use to look up the appropriate model for that part of the payload.</source>
          <target state="translated">이 메소드는 페이로드의 각 JSON 루트 키를 페이로드의 해당 부분에 적합한 모델을 찾는 데 사용할 수있는 modelName으로 변환하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6c5bbd7f853651246ca39c9ea5a7bd46d3c9d051" translate="yes" xml:space="preserve">
          <source>This method is usually similar to using &lt;code&gt;object[keyName]&lt;/code&gt; or &lt;code&gt;object.keyName&lt;/code&gt;, however it supports both computed properties and the unknownProperty handler.</source>
          <target state="translated">이 메소드는 일반적으로 &lt;code&gt;object[keyName]&lt;/code&gt; 또는 &lt;code&gt;object.keyName&lt;/code&gt; 사용과 유사 하지만 계산 된 특성과 unknownProperty 핸들러를 모두 지원합니다.</target>
        </trans-unit>
        <trans-unit id="b114921bcf8d16e2e444b824deee9fc587f6fb2a" translate="yes" xml:space="preserve">
          <source>This method makes a request for one record, where the &lt;code&gt;id&lt;/code&gt; is not known beforehand (if the &lt;code&gt;id&lt;/code&gt; is known, use &lt;a href=&quot;#method_findRecord&quot;&gt;&lt;code&gt;findRecord&lt;/code&gt;&lt;/a&gt; instead).</source>
          <target state="translated">이 메소드는 &lt;code&gt;id&lt;/code&gt; 를 미리 알 수없는 하나의 레코드를 요청 합니다 ( &lt;code&gt;id&lt;/code&gt; 가 알려진 경우 &lt;a href=&quot;#method_findRecord&quot;&gt; &lt;code&gt;findRecord&lt;/code&gt; 를&lt;/a&gt; 대신 사용 하십시오 ).</target>
        </trans-unit>
        <trans-unit id="9189dad7da9da0a19a5a58d8e0fbed8333814043" translate="yes" xml:space="preserve">
          <source>This method makes a request for one record, where the &lt;code&gt;id&lt;/code&gt; is not known beforehand (if the &lt;code&gt;id&lt;/code&gt; is known, use &lt;a href=&quot;../classes/store/methods#findRecord&quot;&gt;&lt;code&gt;findRecord&lt;/code&gt;&lt;/a&gt; instead).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="238521c0958db6a0539fd05f5b408a4f1cb6977a" translate="yes" xml:space="preserve">
          <source>This method may also be called when normalizing embedded relationships when using the &lt;code&gt;EmbeddedRecordsMixin&lt;/code&gt;. If using this mixin in a serializer in your application we recommend implementing this method, but caution that it may lead to unexpected mixing of formats.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67fd9e92dfa4396d5b162756b9cf663a85a3fdbe" translate="yes" xml:space="preserve">
          <source>This method may be called when also using the &lt;code&gt;JSONAPISerializer&lt;/code&gt; when normalizing included records. If mixing serializer usage in this way we recommend implementing this method, but caution that it may lead to unexpected mixing of formats.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66fbdc56effaf56f7af34e2ad54d6ad71801c28b" translate="yes" xml:space="preserve">
          <source>This method may be called when also using the &lt;code&gt;RESTSerializer&lt;/code&gt; when &lt;code&gt;serializer.pushPayload&lt;/code&gt; is called by &lt;code&gt;store.pushPayload&lt;/code&gt;. However, it is recommended to use &lt;code&gt;store.push&lt;/code&gt; over &lt;code&gt;store.pushPayload&lt;/code&gt; after normalizing the payload directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe413c14bf4da8f3d5f53d8ded6cddab3dfd4a8c" translate="yes" xml:space="preserve">
          <source>This method normalizes a modelName into the format Ember Data uses internally.</source>
          <target state="translated">이 메소드는 modelName을 Ember Data가 내부적으로 사용하는 형식으로 정규화합니다.</target>
        </trans-unit>
        <trans-unit id="08631e46477a7a941a13e8472a1d4934d0dfbb83" translate="yes" xml:space="preserve">
          <source>This method performs an HTTP &lt;code&gt;GET&lt;/code&gt; request with the id provided as part of the query string.</source>
          <target state="translated">이 메소드 는 쿼리 문자열의 일부로 제공된 ID 로 HTTP &lt;code&gt;GET&lt;/code&gt; 요청을 수행 합니다.</target>
        </trans-unit>
        <trans-unit id="7856b76816169cfe893ef391554413f9b77a695b" translate="yes" xml:space="preserve">
          <source>This method provides a way to read an element's attribute and also update the last value Ember knows about at the same time. This makes setting an attribute idempotent.</source>
          <target state="translated">이 방법은 요소의 속성을 읽고 동시에 Ember가 알고있는 마지막 값을 업데이트하는 방법을 제공합니다. 이것은 속성을 dem 등원으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="eaa052f406471ed8cf31fb7bf4efd7f61a813eea" translate="yes" xml:space="preserve">
          <source>This method provides the ability to generate an ID to assign to a new record whenever &lt;code&gt;store.createRecord&lt;/code&gt; is called if no &lt;code&gt;id&lt;/code&gt; was provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1be81e576abbc9f8bf07bfebbb5d7035d8f905c9" translate="yes" xml:space="preserve">
          <source>This method receives the &lt;code&gt;store&lt;/code&gt;, the Model class for the request, the payload, the id of the record request (or &lt;code&gt;null&lt;/code&gt; if there is no id associated with the request), and the request type (a string with the possible values of: &lt;code&gt;'findRecord'&lt;/code&gt;, &lt;code&gt;'queryRecord'&lt;/code&gt;, &lt;code&gt;'findAll'&lt;/code&gt;, &lt;code&gt;'findBelongsTo'&lt;/code&gt;, &lt;code&gt;'findHasMany'&lt;/code&gt;, &lt;code&gt;'findMany'&lt;/code&gt;, &lt;code&gt;'query'&lt;/code&gt;, &lt;code&gt;'createRecord'&lt;/code&gt;, &lt;code&gt;'deleteRecord'&lt;/code&gt;, and &lt;code&gt;'updateRecord'&lt;/code&gt;) as arguments.</source>
          <target state="translated">이 메소드는 &lt;code&gt;store&lt;/code&gt; , 요청의 Model 클래스, 페이로드, 레코드 요청의 ID (또는 요청 과 연관된 ID가없는 경우 &lt;code&gt;null&lt;/code&gt; ) 및 요청 유형 (가능한 값이 &lt;code&gt;'findRecord'&lt;/code&gt; 문자열 ' 을 수신합니다. ' findRecord ' , &lt;code&gt;'queryRecord'&lt;/code&gt; , &lt;code&gt;'findAll'&lt;/code&gt; , &lt;code&gt;'findBelongsTo'&lt;/code&gt; , &lt;code&gt;'findHasMany'&lt;/code&gt; , &lt;code&gt;'findMany'&lt;/code&gt; , &lt;code&gt;'query'&lt;/code&gt; , &lt;code&gt;'createRecord'&lt;/code&gt; , &lt;code&gt;'deleteRecord'&lt;/code&gt; 및 &lt;code&gt;'updateRecord'&lt;/code&gt; )를 인수로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="83cfea1ccac994b0f515944e96fac8ec32c2f20c" translate="yes" xml:space="preserve">
          <source>This method returns a filtered array that contains all of the known records for a given type in the store.</source>
          <target state="translated">이 메소드는 상점에서 주어진 유형에 대해 알려진 모든 레코드를 포함하는 필터링 된 배열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="6a6a5fc1791645c2940034d3812b1b516a3835b0" translate="yes" xml:space="preserve">
          <source>This method returns a manager which can be used for introspection of the factory's class or for the creation of factory instances with initial properties. The manager is an object with the following properties:</source>
          <target state="translated">이 메소드는 팩토리 클래스의 내부 검사 또는 초기 특성을 가진 팩토리 인스턴스 작성에 사용할 수있는 관리자를 리턴합니다. 관리자는 다음과 같은 속성을 가진 개체입니다.</target>
        </trans-unit>
        <trans-unit id="b23b68987e06baaee9d2d14013a12d56a2d0b3b3" translate="yes" xml:space="preserve">
          <source>This method returns a promise, which is resolved with an &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.AdapterPopulatedRecordArray.html&quot;&gt;&lt;code&gt;AdapterPopulatedRecordArray&lt;/code&gt;&lt;/a&gt; once the server returns.</source>
          <target state="translated">이 메소드는 서버를 리턴 하면 &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.AdapterPopulatedRecordArray.html&quot;&gt; &lt;code&gt;AdapterPopulatedRecordArray&lt;/code&gt; &lt;/a&gt; 로 해결되는 promise를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="9d3268bf3eda6c50900b9a2834239939db28ea9b" translate="yes" xml:space="preserve">
          <source>This method returns a promise, which is resolved with an &lt;a href=&quot;https://api.emberjs.com/ember-data/release/classes/AdapterPopulatedRecordArray&quot;&gt;&lt;code&gt;AdapterPopulatedRecordArray&lt;/code&gt;&lt;/a&gt; once the server returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eed4c7cdb29f6c03f0723f0629feb07c3656376e" translate="yes" xml:space="preserve">
          <source>This method returns a promise, which resolves with the found record.</source>
          <target state="translated">이 메소드는 검색된 약속으로 해결되는 약속을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="a9ee61f9f9c7e39cc14b2113ef18411dc61a4eca" translate="yes" xml:space="preserve">
          <source>This method returns a record for a given type and id combination.</source>
          <target state="translated">이 메소드는 주어진 유형 및 ID 조합에 대한 레코드를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="5addfbbe95b2a58af44bf1bdcf2499db95fe3c02" translate="yes" xml:space="preserve">
          <source>This method returns true if a record for a given modelName and id is already loaded in the store. Use this function to know beforehand if a findRecord() will result in a request or that it will be a cache hit.</source>
          <target state="translated">주어진 modelName 및 id에 대한 레코드가 이미 저장소에로드 된 경우이 메소드는 true를 리턴합니다. findRecord ()로 인해 요청이 발생하는지 또는 캐시 적중인지 미리 알려면이 함수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="29ad6b6ad91ee119d75a9bab0ee8ae0631edf987" translate="yes" xml:space="preserve">
          <source>This method should be returned by async helpers such as &lt;code&gt;wait&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;code&gt;wait&lt;/code&gt; 와 같은 비동기 헬퍼가 리턴해야합니다 .</target>
        </trans-unit>
        <trans-unit id="df6dcf687152ce38d873a2ff72a1326ba3f69cb3" translate="yes" xml:space="preserve">
          <source>This method should be used when an event may be called multiple times but the action should only be called once when the event is done firing. A common example is for scroll events where you only want updates to happen once scrolling has ceased.</source>
          <target state="translated">이 메소드는 이벤트가 여러 번 호출 될 수있을 때 사용해야하지만 이벤트가 실행 된 경우 조치는 한 번만 호출되어야합니다. 일반적인 예는 스크롤이 중지 된 후에 만 ​​업데이트를 수행하려는 스크롤 이벤트입니다.</target>
        </trans-unit>
        <trans-unit id="1b7af68bf1d14a0a7494d03c440d73e28a4b7190" translate="yes" xml:space="preserve">
          <source>This method unloads all records in the store. It schedules unloading to happen during the next run loop.</source>
          <target state="translated">이 메소드는 상점에서 모든 레코드를 언로드합니다. 다음 실행 루프 중에 언로드가 발생하도록 스케줄합니다.</target>
        </trans-unit>
        <trans-unit id="f68e595b779d29ca69cd56edd16cad0978ac86aa" translate="yes" xml:space="preserve">
          <source>This method will be called with the parent record and &lt;code&gt;/people/1/group&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 부모 레코드 및 &lt;code&gt;/people/1/group&lt;/code&gt; 으로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="90e07dd7b94be524253c05e8e1714813e05bd28a" translate="yes" xml:space="preserve">
          <source>This method will be called with the parent record and &lt;code&gt;/posts/1/comments&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 부모 레코드 및 &lt;code&gt;/posts/1/comments&lt;/code&gt; 와 함께 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="105f0e895ac617988c6c362e0f459352f9da2718" translate="yes" xml:space="preserve">
          <source>This method will only be called if content is non-&lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 content가 &lt;code&gt;null&lt;/code&gt; 이외의 경우에만 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="657150ab50b85204bae3030b7eec6fc817ac1dfb" translate="yes" xml:space="preserve">
          <source>This method will synchronously return the record if it is available in the store, otherwise it will return &lt;code&gt;null&lt;/code&gt;. A record is available if it has been fetched earlier, or pushed manually into the store.</source>
          <target state="translated">이 메소드는 레코드가 상점에서 사용 가능한 경우 동 기적으로 레코드를 리턴하고, 그렇지 않으면 &lt;code&gt;null&lt;/code&gt; 을 리턴 합니다. 레코드를 이전에 가져 오거나 상점으로 수동으로 푸시 한 경우 레코드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d308bedb05bb7d9b40bb5a78f093cc80094bac4" translate="yes" xml:space="preserve">
          <source>This method works much like the more generic &lt;code&gt;find()&lt;/code&gt; method.</source>
          <target state="translated">이 메소드는보다 일반적인 &lt;code&gt;find()&lt;/code&gt; 메소드 와 매우 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="28c70fd4104148a561dcde3c0978e4acb10eaa64" translate="yes" xml:space="preserve">
          <source>This method would ensure that whenever you do &lt;code&gt;store.findAll('ticket')&lt;/code&gt; you will always get a list of tickets that are no more than 20 minutes old. In case a cached version is more than 20 minutes old, &lt;code&gt;findAll&lt;/code&gt; will not resolve until you fetched the latest versions.</source>
          <target state="translated">이 방법을 사용하면 &lt;code&gt;store.findAll('ticket')&lt;/code&gt; 을 수행 할 때마다 20 분 이하의 티켓 목록이 항상 표시됩니다. 캐시 된 버전이 20 분 이상 지난 경우 &lt;code&gt;findAll&lt;/code&gt; 은 최신 버전을 가져올 때까지 해결되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2678263a74a0b565310ba1599428e1ae18b8c295" translate="yes" xml:space="preserve">
          <source>This method would ensure that whenever you do &lt;code&gt;store.findRecord('ticket',
id)&lt;/code&gt; you will always get a ticket that is no more than 20 minutes old. In case the cached version is more than 20 minutes old, &lt;code&gt;findRecord&lt;/code&gt; will not resolve until you fetched the latest version.</source>
          <target state="translated">이 방법을 사용하면 &lt;code&gt;store.findRecord('ticket', id)&lt;/code&gt; 를 수행 할 때마다 항상 20 분 이하의 티켓을 얻을 수 있습니다. 캐시 된 버전이 20 분 이상 지난 경우 &lt;code&gt;findRecord&lt;/code&gt; 는 최신 버전을 가져올 때까지 해결되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ec834c3e944edee230a4909331939d62bcbb6301" translate="yes" xml:space="preserve">
          <source>This mixin allows for Ember objects to subscribe to and emit events.</source>
          <target state="translated">이 믹스 인을 사용하면 Ember 객체가 이벤트를 구독하고 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6ba832406a1e0178c844251cd0911414c38c230" translate="yes" xml:space="preserve">
          <source>This mixin defines methods specifically for collections that provide index-ordered access to their contents. When you are designing code that needs to accept any kind of Array-like object, you should use these methods instead of Array primitives because these will properly notify observers of changes to the array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bf4568e2d4c8f66ef058891e43df4c9d7beb31a" translate="yes" xml:space="preserve">
          <source>This mixin defines the API for modifying array-like objects. These methods can be applied only to a collection that keeps its items in an ordered set. It builds upon the Array mixin and adds methods to modify the array. One concrete implementations of this class include ArrayProxy.</source>
          <target state="translated">이 믹스 인은 배열과 유사한 객체를 수정하기위한 API를 정의합니다. 이러한 메소드는 항목을 순서가 지정된 세트로 유지하는 콜렉션에만 적용 할 수 있습니다. Array 믹스 인을 기반으로하고 배열을 수정하는 메소드를 추가합니다. 이 클래스의 구체적인 구현에는 ArrayProxy가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="0c9ab29a7ae181e083871bfe59c6eb5fa8dee6de" translate="yes" xml:space="preserve">
          <source>This mixin defines the API for modifying generic enumerables. These methods can be applied to an object regardless of whether it is ordered or unordered.</source>
          <target state="translated">이 믹스 인은 일반 열거 형을 수정하기위한 API를 정의합니다. 이러한 방법은 순서에 관계없이 객체에 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c505b5abe483be3c71930f0a0c5dfa5e8fc1384e" translate="yes" xml:space="preserve">
          <source>This mixin defines the common interface implemented by enumerable objects in Ember. Most of these methods follow the standard Array iteration API defined up to JavaScript 1.8 (excluding language-specific features that cannot be emulated in older versions of JavaScript).</source>
          <target state="translated">이 믹스 인은 Ember에서 열거 가능한 객체로 구현 된 공통 인터페이스를 정의합니다. 이러한 메소드는 대부분 JavaScript 1.8까지 정의 된 표준 배열 반복 API를 따릅니다 (이전 버전의 JavaScript에서는 에뮬레이션 할 수없는 언어 별 기능 제외).</target>
        </trans-unit>
        <trans-unit id="a9d0130ce13b8d50b5ddf38e1dae3ada3564de2d" translate="yes" xml:space="preserve">
          <source>This mixin implements Observer-friendly Array-like behavior. It is not a concrete implementation, but it can be used up by other classes that want to appear like arrays.</source>
          <target state="translated">이 믹스 인은 관찰자 친화적 인 배열과 유사한 동작을 구현합니다. 구체적인 구현은 아니지만 배열처럼 보이고 싶은 다른 클래스에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d8916c9cfd84a7db880c63d8afc0d632f773b4d" translate="yes" xml:space="preserve">
          <source>This mixin is applied automatically to the Array class on page load, so you can use any of these methods on simple arrays. If Array already implements one of these methods, the mixin will not override them.</source>
          <target state="translated">이 믹스 인은 페이지로드시 Array 클래스에 자동으로 적용되므로 간단한 배열에서 이러한 메소드를 사용할 수 있습니다. Array가 이러한 메소드 중 하나를 이미 구현 한 경우 mixin은 해당 메소드를 대체하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="763268c55e99fe8d5e6cfe80a692c9e9a1ec4278" translate="yes" xml:space="preserve">
          <source>This mixin provides properties and property observing functionality, core features of the Ember object model.</source>
          <target state="translated">이 믹스 인은 Ember 객체 모델의 핵심 기능인 속성 및 속성 관찰 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fa268524ae8db1ab4917b0e45f5723396b09f37b" translate="yes" xml:space="preserve">
          <source>This modifier generalizes the functionality that the component implemented using lifecycle hooks before, so we can use this modifier whenever we need to in &lt;em&gt;any&lt;/em&gt; component. This is a much better solution than manually managing event listeners every time we need one! At this point, the modifier is effectively the same as the &lt;code&gt;{{on}}&lt;/code&gt; modifier as well, so we could get rid of it altogether and replace it with &lt;code&gt;on&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16c6c4f7af60f66230f7ffba2118c188148ccc3d" translate="yes" xml:space="preserve">
          <source>This namespace contains all Ember methods and functions. Future versions of Ember may overwrite this namespace and therefore, you should avoid adding any new properties.</source>
          <target state="translated">이 네임 스페이스에는 모든 Ember 메서드 및 함수가 포함됩니다. 이후 버전의 Ember는이 네임 스페이스를 덮어 쓸 수 있으므로 새 속성을 추가하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="5c0f1fb8cd697c512e05d5434c4202f674808490" translate="yes" xml:space="preserve">
          <source>This one command will create a new directory called &lt;code&gt;ember-quickstart&lt;/code&gt; and set up a new Ember application inside of it. Out of the box, your application will include:</source>
          <target state="translated">이 명령은 &lt;code&gt;ember-quickstart&lt;/code&gt; 라는 새 디렉토리를 만들고 그 안에 새 Ember 응용 프로그램을 설정합니다. 즉시 사용 가능한 응용 프로그램은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="22b05375afd4c5a6fbf1b0596508c3b38ba312ab" translate="yes" xml:space="preserve">
          <source>This one command will create a new directory called &lt;code&gt;ember-quickstart&lt;/code&gt; and set up a new Ember application inside of it. The &lt;code&gt;--lang en&lt;/code&gt; option sets the app's primary language to English to help improve &lt;a href=&quot;https://guides.emberjs.com/accessibility/application-considerations/&quot;&gt;accessibility&lt;/a&gt;. Out of the box, your application will include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d1ae48e7202427b88a954866fa91e5d3ebf6ba4" translate="yes" xml:space="preserve">
          <source>This only works on primitive data types, e.g. Strings, Numbers, etc.</source>
          <target state="translated">이것은 문자열, 숫자 등과 같은 기본 데이터 유형에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="308984791a98ba4402203e44b8c501a854c6be67" translate="yes" xml:space="preserve">
          <source>This option logs all the lookups that are done to the console. Custom objects you've created yourself have a tick, and Ember generated ones don't.</source>
          <target state="translated">이 옵션은 콘솔에 대한 모든 조회를 기록합니다. 직접 만든 커스텀 객체에는 진드기가 있고 Ember는 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="827122ab1dbe9e086209a96121534bdf50459740" translate="yes" xml:space="preserve">
          <source>This package adds roughly .6 KB when minified and compressed to your application in production; however, you can opt out of shipping this addon in production via options in &lt;code&gt;ember-cli-build.js&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4932c0bd7aa01b1b43179f723f190ae1a102d2fc" translate="yes" xml:space="preserve">
          <source>This package provides the &lt;code&gt;DataAdapter&lt;/code&gt; which the &lt;a href=&quot;https://github.com/emberjs/ember-inspector&quot;&gt;Ember Inspector&lt;/a&gt; uses to subscribe and retrieve information for the &lt;code&gt;data&lt;/code&gt; tab in the inspector.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92634f5f6b56e889bfe5bd98c614519c1b9f68df" translate="yes" xml:space="preserve">
          <source>This parameter is no longer used and will always be null.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="895ebcf851270f30da8196f670fecc5894c45820" translate="yes" xml:space="preserve">
          <source>This pattern is known as &lt;em&gt;Data-Down, Actions Up&lt;/em&gt;, or &lt;em&gt;unidirectional data flow&lt;/em&gt;. For these new components, this pattern is enforced - all mutations must occur through actions. This clarifies the data flow, because it's immediately possible to see where all of the mutations are occurring.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="864837a696f2c980e81e10f2eb17aa9ee09a9e87" translate="yes" xml:space="preserve">
          <source>This pause-on-promise behavior is extremely valuable for when you need to guarantee that a route's data has fully loaded before displaying a new template.</source>
          <target state="translated">이 약속시 일시 중지 동작은 새 템플릿을 표시하기 전에 경로 데이터가 완전히로드되었는지 확인해야 할 때 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="68b70d5b5dbc2ccc714f22b801fc4c2b2e2527d0" translate="yes" xml:space="preserve">
          <source>This prevents the reverse flow, and also throws an exception when it occurs.</source>
          <target state="translated">이렇게하면 역류가 방지되고 예외가 발생할 때 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f188f197791f50828cb93afbcf35a833dccb3e89" translate="yes" xml:space="preserve">
          <source>This property can be specified as either an element or a &lt;a href=&quot;http://api.jquery.com/category/selectors/&quot;&gt;jQuery-compatible selector string&lt;/a&gt;.</source>
          <target state="translated">이 속성은 요소 또는 &lt;a href=&quot;http://api.jquery.com/category/selectors/&quot;&gt;jQuery 호환 선택기 문자열&lt;/a&gt; 로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="092e990dea4b4b80085b80d8d2436d253e79f3f5" translate="yes" xml:space="preserve">
          <source>This property can be specified as either an element or a &lt;a href=&quot;https://api.jquery.com/category/selectors/&quot;&gt;jQuery-compatible selector string&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="259eb851af0e49aa172ab983617f64d1b8524d4e" translate="yes" xml:space="preserve">
          <source>This property contains the testing helpers for the current application. These are created once you call &lt;code&gt;injectTestHelpers&lt;/code&gt; on your &lt;code&gt;Ember.Application&lt;/code&gt; instance. The included helpers are also available on the &lt;code&gt;window&lt;/code&gt; object by default, but can be used from this object on the individual application also.</source>
          <target state="translated">이 속성에는 현재 응용 프로그램의 테스트 도우미가 포함됩니다. &lt;code&gt;Ember.Application&lt;/code&gt; 인스턴스 에서 &lt;code&gt;injectTestHelpers&lt;/code&gt; 를 호출하면 생성 됩니다. 포함 된 도우미는 기본적으로 &lt;code&gt;window&lt;/code&gt; 개체 에서도 사용할 수 있지만 개별 응용 프로그램의이 개체에서도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c153ca85376c7d3f3baec72fd802aaaa30a6dd4" translate="yes" xml:space="preserve">
          <source>This property holds the &lt;code&gt;AdapterError&lt;/code&gt; object with which last adapter operation was rejected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="880b36e1d1b71d83f727290b52d71974b054fd06" translate="yes" xml:space="preserve">
          <source>This property holds the &lt;code&gt;DS.AdapterError&lt;/code&gt; object with which last adapter operation was rejected.</source>
          <target state="translated">이 특성은 마지막 어댑터 조작이 거부 된 &lt;code&gt;DS.AdapterError&lt;/code&gt; 오브젝트를 보유합니다 .</target>
        </trans-unit>
        <trans-unit id="c2672723b4000e8dc3a4be8a1dec2e30fc2e556d" translate="yes" xml:space="preserve">
          <source>This property indicates whether or not this application is currently in testing mode. This is set when &lt;code&gt;setupForTesting&lt;/code&gt; is called on the current application.</source>
          <target state="translated">이 특성은이 애플리케이션이 현재 테스트 모드인지 여부를 나타냅니다. 현재 애플리케이션에서 &lt;code&gt;setupForTesting&lt;/code&gt; 이 호출 될 때 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="9827e139537e2e6df485db87bf1d8a8b5e6721eb" translate="yes" xml:space="preserve">
          <source>This property is a &lt;code&gt;RouteInfo&lt;/code&gt; object that represents where the router is transitioning to. It's important to note that a &lt;code&gt;RouteInfo&lt;/code&gt; is a linked list and this property represents the leafmost route.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63de6d307d7a245c691791efc25b406e879ae75a" translate="yes" xml:space="preserve">
          <source>This property is a &lt;code&gt;RouteInfo&lt;/code&gt; object that represents where transition originated from. It's important to note that a &lt;code&gt;RouteInfo&lt;/code&gt; is a linked list and this property represents the head node of the list. In the case of an initial render, &lt;code&gt;from&lt;/code&gt; will be set to &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="feece382aeeb11aff2c1f402bfa62d1348fb6268" translate="yes" xml:space="preserve">
          <source>This property is guaranteed to change whenever a route transition happens (even when that transition only changes parameters and doesn't change the active route).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d61da15319a8f6d477ea54281d1f750de320a8d" translate="yes" xml:space="preserve">
          <source>This property must be specified upon creation, and should not be changed once created.</source>
          <target state="translated">이 특성은 작성시 지정해야하며 일단 작성되면 변경해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="7cb254d7e44a7f93fba2ee853638d58a655e0c55" translate="yes" xml:space="preserve">
          <source>This property overrides the default property defined in &lt;code&gt;Ember.Enumerable&lt;/code&gt;.</source>
          <target state="translated">이 속성은 &lt;code&gt;Ember.Enumerable&lt;/code&gt; 에 정의 된 기본 속성보다 우선합니다 .</target>
        </trans-unit>
        <trans-unit id="bc4839933224a7545119e48843b9c5e1290794d8" translate="yes" xml:space="preserve">
          <source>This property represents the logical name of the route, which is comma separated. For the following router:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bf517043771a30954400aa054dd262728704215" translate="yes" xml:space="preserve">
          <source>This property will return &lt;code&gt;/my-root&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9773d501349ee6511de2ee684d6598a19311be0d" translate="yes" xml:space="preserve">
          <source>This property would contain the following:</source>
          <target state="translated">이 속성에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d20b59f6a96b6617ee0085cdddc214c8c3d28af2" translate="yes" xml:space="preserve">
          <source>This removes all helpers that have been registered, and resets and functions that were overridden by the helpers.</source>
          <target state="translated">이렇게하면 등록 된 모든 도우미가 제거되고 도우미가 재정의 한 재설정 및 기능이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="f3b7c25a3f2e20075045c10f4cbaf58f922adbe5" translate="yes" xml:space="preserve">
          <source>This results in the creation of a model file and a test file:</source>
          <target state="translated">결과적으로 모델 파일과 테스트 파일이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="2a89f1868ed6f1ee9a365b3c0e407202123ba3e9" translate="yes" xml:space="preserve">
          <source>This results in the entire tree of destroyables being first marked as destroying, then having all of their destructors called, and finally all being marked as isDestroyed. There won't be any in between states where some items are marked as &lt;code&gt;isDestroying&lt;/code&gt; while destroying, while others are not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d2448d5cbbd2264adc36cdc0345ffb2188196cb" translate="yes" xml:space="preserve">
          <source>This returns a string that represents how the reference will be looked up when it is loaded. If the relationship has a link it will use the &quot;link&quot; otherwise it defaults to &quot;id&quot;.</source>
          <target state="translated">참조가로드 될 때 참조를 찾는 방법을 나타내는 문자열을 반환합니다. 관계에 링크가있는 경우 &quot;link&quot;를 사용하고 그렇지 않으면 기본값은 &quot;id&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="f4a77f92e2016358406f536036ee528d0389ad89" translate="yes" xml:space="preserve">
          <source>This returns a thenable tailored for testing. It catches failed &lt;code&gt;onSuccess&lt;/code&gt; callbacks and invokes the &lt;code&gt;Ember.Test.adapter.exception&lt;/code&gt; callback in the last chained then.</source>
          <target state="translated">그러면 테스트에 맞게 조정 가능한 결과가 반환됩니다. 실패한 &lt;code&gt;onSuccess&lt;/code&gt; 콜백을 포착 하고 마지막 체인에서 &lt;code&gt;Ember.Test.adapter.exception&lt;/code&gt; 콜백을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="50faf92dba9f3a4835092fca1ed3e0228234be67" translate="yes" xml:space="preserve">
          <source>This returns the objects at the specified indexes, using &lt;code&gt;objectAt&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;objectAt&lt;/code&gt; 를 사용하여 지정된 인덱스의 객체를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f1e3aaaf80637b6eaa622e8df1944a99aa521731" translate="yes" xml:space="preserve">
          <source>This route is part of every application, so you don't need to specify it in your &lt;code&gt;app/router.js&lt;/code&gt;.</source>
          <target state="translated">이 경로는 모든 응용 프로그램의 일부이므로 &lt;code&gt;app/router.js&lt;/code&gt; 에서 지정할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="03d7bba0ebc44c5b5992d770552d3d3655e4353b" translate="yes" xml:space="preserve">
          <source>This router creates a route for &lt;code&gt;/posts&lt;/code&gt; and for &lt;code&gt;/posts/new&lt;/code&gt;. When a user visits &lt;code&gt;/posts&lt;/code&gt;, they'll simply see the &lt;code&gt;posts.hbs&lt;/code&gt; template. (Below, &lt;a href=&quot;#toc_index-routes&quot;&gt;index routes&lt;/a&gt; explains an important addition to this.) When the user visits &lt;code&gt;posts/new&lt;/code&gt;, they'll see the &lt;code&gt;posts/new.hbs&lt;/code&gt; template rendered into the &lt;code&gt;{{outlet}}&lt;/code&gt; of the &lt;code&gt;posts&lt;/code&gt; template.</source>
          <target state="translated">이 라우터는 &lt;code&gt;/posts&lt;/code&gt; 및 &lt;code&gt;/posts/new&lt;/code&gt; 에 대한 경로를 만듭니다 . 사용자가 &lt;code&gt;/posts&lt;/code&gt; 를 방문 하면 &lt;code&gt;posts.hbs&lt;/code&gt; 템플릿을 보게 됩니다. (아래, &lt;a href=&quot;#toc_index-routes&quot;&gt;인덱스 노선&lt;/a&gt; 이에 중요한 추가에 대해 설명합니다.) 사용자가 방문의 경우에는 &lt;code&gt;posts/new&lt;/code&gt; , 그들이 볼 수 &lt;code&gt;posts/new.hbs&lt;/code&gt; 에 렌더링 템플릿 &lt;code&gt;{{outlet}}&lt;/code&gt; 의 &lt;code&gt;posts&lt;/code&gt; 템플릿입니다.</target>
        </trans-unit>
        <trans-unit id="2682ff7e745a9f583a877a94603b3a194f20069b" translate="yes" xml:space="preserve">
          <source>This section covers some more advanced features of the router and its capability for handling complex async logic within your app.</source>
          <target state="translated">이 섹션에서는 라우터의 고급 기능과 앱 내에서 복잡한 비동기 로직을 ​​처리하는 기능에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="356477e9c652b8c488b3be5d88a9d6be9a9cca4e" translate="yes" xml:space="preserve">
          <source>This section of the Guides describes the essential features of Ember Data, a powerful set of tools for formatting requests, normalizing responses, and efficiently managing a local cache of data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6349d18558bd40c087dbdecb5a17a71ea3aa9584" translate="yes" xml:space="preserve">
          <source>This section will walk you through two ways to deploy your ember application to production using the Netlify platform:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d03de60bffa51d324cefb82c172247484bdd27e" translate="yes" xml:space="preserve">
          <source>This separation of concerns not only clarifies the architecture of your app, it can also improve its efficiency. This is particularly true when your app needs to be booted repeatedly during testing and / or server-rendering (e.g. via &lt;a href=&quot;https://github.com/tildeio/ember-cli-fastboot&quot;&gt;FastBoot&lt;/a&gt;). The configuration of a single &lt;code&gt;Application&lt;/code&gt; can be done once and shared among multiple stateful &lt;code&gt;ApplicationInstance&lt;/code&gt; instances. These instances can be discarded once they're no longer needed (e.g. when a test has run or FastBoot request has finished).</source>
          <target state="translated">이러한 관심의 분리는 앱의 아키텍처를 명확하게 할뿐만 아니라 효율성을 향상시킬 수 있습니다. 테스트 및 / 또는 서버 렌더링 중에 (예 : &lt;a href=&quot;https://github.com/tildeio/ember-cli-fastboot&quot;&gt;FastBoot&lt;/a&gt; 를 통해 ) 앱을 반복적으로 부팅해야하는 경우 특히 그렇습니다 . 단일 &lt;code&gt;Application&lt;/code&gt; 의 구성은 한 번 수행하고 여러 상태 저장 &lt;code&gt;ApplicationInstance&lt;/code&gt; 인스턴스 간에 공유 할 수 있습니다 . 이러한 인스턴스는 더 이상 필요하지 않은 경우 (예 : 테스트가 실행되었거나 FastBoot 요청이 완료된 경우) 버릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4805cff80c4003c73bc07ed858d965751990b299" translate="yes" xml:space="preserve">
          <source>This serializer expects this &lt;code&gt;errors&lt;/code&gt; object to be an Array similar to the following, compliant with the &lt;a href=&quot;https://jsonapi.org/format/#errors&quot;&gt;https://jsonapi.org/format/#errors&lt;/a&gt; specification:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="789aeba7e703a9b9f8a1615849db9c70a791d7f5" translate="yes" xml:space="preserve">
          <source>This serializer expects this &lt;code&gt;errors&lt;/code&gt; object to be an Array similar to the following, compliant with the JSON-API specification:</source>
          <target state="translated">이 시리얼 라이저는이 &lt;code&gt;errors&lt;/code&gt; 객체가 JSON-API 사양을 준수하는 다음과 유사한 배열 일 것으로 예상합니다 .</target>
        </trans-unit>
        <trans-unit id="bb8c0ec823dbba7a7a2ed2b41b55cb5e08ee937a" translate="yes" xml:space="preserve">
          <source>This serializer normalizes a JSON API payload that looks like:</source>
          <target state="translated">이 시리얼 라이저는 다음과 같은 JSON API 페이로드를 정규화합니다.</target>
        </trans-unit>
        <trans-unit id="6ae149f60b66b9e03410e34d8b8dd68ba195fe2d" translate="yes" xml:space="preserve">
          <source>This serializer will generate JSON that looks like this:</source>
          <target state="translated">이 시리얼 라이저는 다음과 같은 JSON을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a037d496c03267daf854fbff115ff2ed3892a36d" translate="yes" xml:space="preserve">
          <source>This sets up a binding between the &lt;code&gt;category&lt;/code&gt; query param in the URL, and the &lt;code&gt;category&lt;/code&gt; property on &lt;code&gt;controller:articles&lt;/code&gt;. In other words, once the &lt;code&gt;articles&lt;/code&gt; route has been entered, any changes to the &lt;code&gt;category&lt;/code&gt; query param in the URL will update the &lt;code&gt;category&lt;/code&gt; property on &lt;code&gt;controller:articles&lt;/code&gt;, and vice versa. Note that you can't bind &lt;code&gt;queryParams&lt;/code&gt; to computed properties, they have to be values.</source>
          <target state="translated">URL 의 &lt;code&gt;category&lt;/code&gt; 쿼리 매개 변수와 &lt;code&gt;controller:articles&lt;/code&gt; 의 &lt;code&gt;category&lt;/code&gt; 특성 사이에 바인딩이 설정됩니다 . 즉, &lt;code&gt;articles&lt;/code&gt; 경로가 입력되면 URL 의 &lt;code&gt;category&lt;/code&gt; 쿼리 매개 변수를 변경하면 &lt;code&gt;controller:articles&lt;/code&gt; 의 &lt;code&gt;category&lt;/code&gt; 속성 이 업데이트 되고 그 반대의 경우도 마찬가지입니다. &lt;code&gt;queryParams&lt;/code&gt; 를 계산 된 특성에 바인드 할 수 없으며 값이어야합니다.</target>
        </trans-unit>
        <trans-unit id="8dc21fa764ab09b3766ad6e775fb8fca84781eb0" translate="yes" xml:space="preserve">
          <source>This sets up a binding between the &lt;code&gt;category&lt;/code&gt; query param in the URL, and the &lt;code&gt;category&lt;/code&gt; property on &lt;code&gt;controller:articles&lt;/code&gt;. In other words, once the &lt;code&gt;articles&lt;/code&gt; route has been entered, any changes to the &lt;code&gt;category&lt;/code&gt; query param in the URL will update the &lt;code&gt;category&lt;/code&gt; property on &lt;code&gt;controller:articles&lt;/code&gt;, and vice versa. Note that you can't make &lt;code&gt;queryParams&lt;/code&gt; be a dynamically generated property (neither computed property, nor property getter); they have to be values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4fca12a79c237845effaba4d5f11c49b9077507" translate="yes" xml:space="preserve">
          <source>This setup allows you to run the routing layer of your Ember app in a server environment using Node.js and completely disable rendering. This allows you to simulate and discover the resources (i.e. AJAX requests) needed to fulfill a given request and eagerly &quot;push&quot; these resources to the client.</source>
          <target state="translated">이 설정을 사용하면 Node.js를 사용하여 서버 환경에서 Ember 앱의 라우팅 계층을 실행하고 렌더링을 완전히 비활성화 할 수 있습니다. 이를 통해 주어진 요청을 이행하는 데 필요한 자원 (예 : AJAX 요청)을 시뮬레이션하고 발견하고 이러한 자원을 클라이언트에 &quot;푸시&quot;할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02dd78ab18220d6a23d424669cd9bfd4688435b6" translate="yes" xml:space="preserve">
          <source>This setup allows you to run your Ember app in a server environment using Node.js and render its content into static HTML for SEO purposes.</source>
          <target state="translated">이 설정을 사용하면 Node.js를 사용하여 서버 환경에서 Ember 앱을 실행하고 SEO 목적으로 해당 컨텐츠를 정적 HTML로 렌더링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fc8bfa537605301181bc268ec1121a0fff7f530" translate="yes" xml:space="preserve">
          <source>This shows the literal string &lt;code&gt;&amp;lt;b&amp;gt;Hello world&amp;lt;/b&amp;gt;&lt;/code&gt; to the user, rather than the text in bold as you probably intended. We can tell Ember not to escape the return value (that is, that it is &lt;em&gt;safe&lt;/em&gt;) by using the &lt;a href=&quot;http://emberjs.com/api/classes/Ember.String.html#method_htmlSafe&quot;&gt;&lt;code&gt;htmlSafe&lt;/code&gt;&lt;/a&gt; string utility:</source>
          <target state="translated">원하는대로 굵게 표시된 텍스트 대신 리터럴 문자열 &lt;code&gt;&amp;lt;b&amp;gt;Hello world&amp;lt;/b&amp;gt;&lt;/code&gt; 가 사용자에게 표시됩니다. &lt;a href=&quot;http://emberjs.com/api/classes/Ember.String.html#method_htmlSafe&quot;&gt; &lt;code&gt;htmlSafe&lt;/code&gt; &lt;/a&gt; 문자열 유틸리티를 사용하여 Ember에게 반환 값 (즉, &lt;em&gt;안전함&lt;/em&gt; ) 을 이스케이프 처리하지 않도록 지시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="14461f490d3629183001df3471224dbd1beb7332" translate="yes" xml:space="preserve">
          <source>This snippet says &quot;take the &lt;code&gt;userDidDeleteAccount&lt;/code&gt; action from the parent and make it available on the child component as the property &lt;code&gt;onConfirm&lt;/code&gt;.&quot; Note the use here of the &lt;code&gt;action&lt;/code&gt; helper, which serves to return the function named &lt;code&gt;&quot;userDidDeleteAccount&quot;&lt;/code&gt; that we are passing to the component.</source>
          <target state="translated">이 스 니펫은 &quot; 부모로부터 &lt;code&gt;userDidDeleteAccount&lt;/code&gt; 조치를 취하여 하위 구성 요소에서 &lt;code&gt;onConfirm&lt;/code&gt; 특성으로 사용 가능하게하십시오 &quot;라고 말합니다 . 컴포넌트에 전달하는 &lt;code&gt;&quot;userDidDeleteAccount&quot;&lt;/code&gt; 라는 함수를 리턴 하는 &lt;code&gt;action&lt;/code&gt; 헬퍼 의 사용에 주목하십시오 .</target>
        </trans-unit>
        <trans-unit id="10aa9c950fe3b173b7fe0ffb80e1c78f6a244f66" translate="yes" xml:space="preserve">
          <source>This synchronous behavior can also lead to observers being fired multiple times when observing multiple properties:</source>
          <target state="translated">이 동기 동작으로 인해 여러 속성을 관찰 할 때 관찰자가 여러 번 발사 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="365161a9879b63b8be4e252766b6673143714259" translate="yes" xml:space="preserve">
          <source>This syntax is known as &lt;em&gt;classic class&lt;/em&gt; syntax, and if you're starting out on a new Ember application it's recommended that you stick with native classes instead. However, if you are working in an older application, or in an addon, you may encounter this syntax, so you can check out the &lt;a href=&quot;https://guides.emberjs.com/v3.12.0/object-model/&quot;&gt;pre-Octane guides on classic classes&lt;/a&gt; for more information on them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ca7bb302863b1f3661818e192c30d8b7af3c091" translate="yes" xml:space="preserve">
          <source>This syntax offers the convenience to add a class if a property is &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="translated">이 구문은 속성이 &lt;code&gt;false&lt;/code&gt; 인 경우 클래스를 추가하는 편의성을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="a9ae6e226ca09bce17c61dde6d0c00e6d37618ea" translate="yes" xml:space="preserve">
          <source>This technique is a reasonable first step, but has limitations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1ed53e820aed98abe96f4bcad2c93d5f60e035c" translate="yes" xml:space="preserve">
          <source>This template would display all properties on the &lt;code&gt;developer&lt;/code&gt; object in a list:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eee93099eea962e7715594aebb65f2ee2649df43" translate="yes" xml:space="preserve">
          <source>This template would display all properties on the &lt;code&gt;user&lt;/code&gt; object in a list:</source>
          <target state="translated">이 템플릿은 &lt;code&gt;user&lt;/code&gt; 객체의 모든 속성을 목록으로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="afccb08d1ac5974f56f2db8b4c4a83dee7fac93b" translate="yes" xml:space="preserve">
          <source>This time when we setup our &lt;code&gt;moduleFor&lt;/code&gt; we need to pass an options object as our third argument that has the controller's &lt;code&gt;needs&lt;/code&gt;.</source>
          <target state="translated">이번에는 &lt;code&gt;moduleFor&lt;/code&gt; 을 설정할 때 컨트롤러에 &lt;code&gt;needs&lt;/code&gt; 세 번째 인수로 옵션 객체를 전달 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="26eb1c85e3767170ddbe236d44279a005945e744" translate="yes" xml:space="preserve">
          <source>This title will take effect when we enter the &amp;ldquo;post&amp;rdquo; route, and the line of code in our &lt;code&gt;willDestroy&lt;/code&gt; hook will take care of restoring the former title when we return to the &amp;ldquo;posts&amp;rdquo; route.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d62e458d7d882a12cb4203c51a285838866941d2" translate="yes" xml:space="preserve">
          <source>This transformation allows you to &lt;code&gt;import&lt;/code&gt; moment in your app. (e.g. &lt;code&gt;import moment from 'moment';&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="472a11330a41f27829d5766ed001e83edced7c89" translate="yes" xml:space="preserve">
          <source>This utility function is used to declare a given component has no backing class. When the rendering engine detects this it is able to perform a number of optimizations. Templates that are associated with &lt;code&gt;templateOnly()&lt;/code&gt; will be rendered &lt;em&gt;as is&lt;/em&gt; without adding a wrapping &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; (or any of the other element customization behaviors of &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Component&quot;&gt;@ember/component&lt;/a&gt;). Specifically, this means that the template will be rendered as &quot;outer HTML&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d01f3b8c1863d9586e5d760a848d3d268d6bdf8" translate="yes" xml:space="preserve">
          <source>This value is defaulted to &lt;code&gt;auto&lt;/code&gt; by the &lt;code&gt;locationType&lt;/code&gt; setting of &lt;code&gt;/config/environment.js&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="320e20ec08a17dd14b114fefba162280a1a8e762" translate="yes" xml:space="preserve">
          <source>This way the &lt;code&gt;{{action}}&lt;/code&gt; will fire when clicking with the alt key pressed down.</source>
          <target state="translated">이렇게 하면 alt 키를 누른 상태에서 클릭 할 때 &lt;code&gt;{{action}}&lt;/code&gt; 이 (가) 실행 됩니다.</target>
        </trans-unit>
        <trans-unit id="e963dddd92986a8f66f2f216766871bc0c689a3c" translate="yes" xml:space="preserve">
          <source>This way the action will fire when clicking with the alt key pressed down. Alternatively, supply &quot;any&quot; to the &lt;code&gt;allowedKeys&lt;/code&gt; option to accept any combination of modifier keys.</source>
          <target state="translated">이렇게하면 alt 키를 누른 상태에서 클릭 할 때 작업이 시작됩니다. 또는, 수정 자 키 조합을 허용 하려면 &lt;code&gt;allowedKeys&lt;/code&gt; 옵션에 &quot;any&quot;를 제공하십시오 .</target>
        </trans-unit>
        <trans-unit id="93d9f53f59f84e70d021255650919e1893d8f819" translate="yes" xml:space="preserve">
          <source>This will allow you to import jQuery from &lt;code&gt;jquery&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd6de6f2495f60b0b45637260afcb844ddcddbc6" translate="yes" xml:space="preserve">
          <source>This will also trigger a rerender. No matter where the update occurs, updating a tracked property will let Ember know to rerender any affected portion of the app.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bedb78f365050fbd4069b91241e79e0fffc66905" translate="yes" xml:space="preserve">
          <source>This will be set to the Application instance when it is created.</source>
          <target state="translated">응용 프로그램 인스턴스를 만들 때이 인스턴스가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="b0d2a0761856747c7bdf1757594db900c323b0ab" translate="yes" xml:space="preserve">
          <source>This will bind checked state of this checkbox to the value of &lt;code&gt;isEmberized&lt;/code&gt; -- if either one changes, it will be reflected in the other.</source>
          <target state="translated">그러면이 확인란의 확인 된 상태가 &lt;code&gt;isEmberized&lt;/code&gt; 값에 바인딩 됩니다. 둘 중 하나가 변경되면 다른 쪽에도 반영됩니다.</target>
        </trans-unit>
        <trans-unit id="25e3b1918ed474cee33c724ea48d9dc47b998531" translate="yes" xml:space="preserve">
          <source>This will call the &lt;code&gt;targetAction&lt;/code&gt; method on the &lt;code&gt;targetObject&lt;/code&gt; whenever the value of the &lt;code&gt;propertyKey&lt;/code&gt; changes.</source>
          <target state="translated">&lt;code&gt;propertyKey&lt;/code&gt; 값이 변경 될 때마다 &lt;code&gt;targetObject&lt;/code&gt; 에서 &lt;code&gt;targetAction&lt;/code&gt; 메소드를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="1112ad430de08e3a9e5b258697086fe3531f93eb" translate="yes" xml:space="preserve">
          <source>This will cause changes to the &lt;code&gt;controller:articles&lt;/code&gt;'s &lt;code&gt;category&lt;/code&gt; property to update the &lt;code&gt;articles_category&lt;/code&gt; query param, and vice versa.</source>
          <target state="translated">이는 변경의 원인이됩니다 &lt;code&gt;controller:articles&lt;/code&gt; 의 &lt;code&gt;category&lt;/code&gt; 업데이트하는 특성 &lt;code&gt;articles_category&lt;/code&gt; 의 쿼리 PARAM를, 그리고 그 반대를 반대.</target>
        </trans-unit>
        <trans-unit id="b9755f75a3b22405decec5b951256d1bf2194edb" translate="yes" xml:space="preserve">
          <source>This will combine the values of the array into a single value. It is a useful way to collect a summary value from an array. This corresponds to the &lt;code&gt;reduce()&lt;/code&gt; method defined in JavaScript 1.8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01abb5b2dee8f3eadfbf27cf12dc694c82c9b0fa" translate="yes" xml:space="preserve">
          <source>This will combine the values of the enumerator into a single value. It is a useful way to collect a summary value from an enumeration. This corresponds to the &lt;code&gt;reduce()&lt;/code&gt; method defined in JavaScript 1.8.</source>
          <target state="translated">열거 자의 값을 단일 값으로 결합합니다. 열거 형에서 요약 값을 수집하는 유용한 방법입니다. 이것은 JavaScript 1.8에 정의 된 &lt;code&gt;reduce()&lt;/code&gt; 메소드에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="4d8eee678a37c71d0c8bd12462d3862f9e24bd5a" translate="yes" xml:space="preserve">
          <source>This will create a new &lt;code&gt;comment&lt;/code&gt; record and save it to the server. Ember Data will also update the blogPost to include our newly created comment in its &lt;code&gt;comments&lt;/code&gt; relationship.</source>
          <target state="translated">새로운 &lt;code&gt;comment&lt;/code&gt; 레코드 가 생성 되어 서버에 저장됩니다. Ember Data는 새로 작성된 의견을 &lt;code&gt;comments&lt;/code&gt; 관계 에 포함하도록 blogPost를 업데이트합니다 .</target>
        </trans-unit>
        <trans-unit id="33c9e6435e1c4f883e5e4bdb72fe6185866b3577" translate="yes" xml:space="preserve">
          <source>This will create two files, our helper and its related test:</source>
          <target state="translated">그러면 도우미와 관련 테스트라는 두 개의 파일이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="dcbe74f9dc4684893252fa7928f87a33353149e1" translate="yes" xml:space="preserve">
          <source>This will display the result of &lt;code&gt;this.foo.item1&lt;/code&gt; when index is 1, and &lt;code&gt;this.foo.item2&lt;/code&gt; when index is 2, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06a61beff59c9a238e101b8d830b62a3ba3f1d36" translate="yes" xml:space="preserve">
          <source>This will display the result of &lt;code&gt;this.get('foo.item1')&lt;/code&gt; when index is 1, and &lt;code&gt;this.get('foo.item2')&lt;/code&gt; when index is 2, etc.</source>
          <target state="translated">이 결과 표시 &lt;code&gt;this.get('foo.item1')&lt;/code&gt; 인덱스가 1 인 경우와 &lt;code&gt;this.get('foo.item2')&lt;/code&gt; 인덱스가 2 인 경우 등에</target>
        </trans-unit>
        <trans-unit id="a9259ca0bb82d89e48df977ef1e42ddeb57457e8" translate="yes" xml:space="preserve">
          <source>This will generate the following file:</source>
          <target state="translated">다음 파일이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="f66f6e9c3264383a6dc79ef4dba17dfe12475045" translate="yes" xml:space="preserve">
          <source>This will make three new commands available to Ember CLI within your project, &lt;code&gt;feature:list&lt;/code&gt;, &lt;code&gt;feature:enable&lt;/code&gt;, and &lt;code&gt;feature:disable&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df9f78f7b1600d62af8dbc79c8ec1c529fffac70" translate="yes" xml:space="preserve">
          <source>This will modify your &lt;code&gt;package.json&lt;/code&gt; (and &lt;code&gt;package-lock.json&lt;/code&gt; or &lt;code&gt;yarn.lock&lt;/code&gt;), typically bringing in other dependencies. Some addons will also add additional files to your projects when relevant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="906404e31e56fa309043de215463e96251e5794e" translate="yes" xml:space="preserve">
          <source>This will only work if the record has already finished loading.</source>
          <target state="translated">레코드로드가 이미 완료된 경우에만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="275c4807a4fc7dd57c70ad52977455a63b60071c" translate="yes" xml:space="preserve">
          <source>This will push the tag for the &lt;code&gt;[]&lt;/code&gt; property onto the autotrack stack, and that property is what is invalidated when the array is updated with KVO methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="128514546a9dca77c2ec486e9e802bd28c483968" translate="yes" xml:space="preserve">
          <source>This will remove jQuery from your vendor.js bundle and disable any use of jQuery in Ember itself. Now your app will be about 30KB lighter!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8d929b9d0335a3ed5cf736b11bdf433272222ee" translate="yes" xml:space="preserve">
          <source>This will result in a posts.new url of &lt;code&gt;/#/posts/new&lt;/code&gt;.</source>
          <target state="translated">그러면 posts.new URL &lt;code&gt;/#/posts/new&lt;/code&gt; 가 생성 됩니다.</target>
        </trans-unit>
        <trans-unit id="29fb1351e61c41fb104416f7850a8b5069cdd3f6" translate="yes" xml:space="preserve">
          <source>This will result in a posts.new url of &lt;code&gt;/posts/new&lt;/code&gt; for modern browsers that support the &lt;code&gt;history&lt;/code&gt; api or &lt;code&gt;/#/posts/new&lt;/code&gt; for older ones, like Internet Explorer 9 and below.</source>
          <target state="translated">그러면 Internet Explorer 9 이하와 같이 이전 API를 위해 &lt;code&gt;history&lt;/code&gt; API 또는 &lt;code&gt;/#/posts/new&lt;/code&gt; 를 지원하는 최신 브라우저 의 경우 posts.new URL &lt;code&gt;/posts/new&lt;/code&gt; 가 생성 됩니다.</target>
        </trans-unit>
        <trans-unit id="ef38bf8c063d320ef5caf31e346a8a11963ad798" translate="yes" xml:space="preserve">
          <source>This will result in a posts.new url of &lt;code&gt;/posts/new&lt;/code&gt;.</source>
          <target state="translated">그러면 posts.new URL &lt;code&gt;/posts/new&lt;/code&gt; 가 생성 됩니다.</target>
        </trans-unit>
        <trans-unit id="a594b83e2729c4c06fe483d9931d88196c8ca620" translate="yes" xml:space="preserve">
          <source>This will tell the JSON API adapter that requests for &lt;code&gt;formula&lt;/code&gt; should go to &lt;code&gt;/formulae/1&lt;/code&gt; instead of &lt;code&gt;/formulas/1&lt;/code&gt;, and that requests for &lt;code&gt;advice&lt;/code&gt; should go to &lt;code&gt;/advice/1&lt;/code&gt; instead of &lt;code&gt;/advices/1&lt;/code&gt;.</source>
          <target state="translated">이렇게하면 JSON API 어댑터에 &lt;code&gt;formula&lt;/code&gt; 요청 이 &lt;code&gt;/formulae/1&lt;/code&gt; 대신 &lt;code&gt;/formulas/1&lt;/code&gt; 로 이동하고 &lt;code&gt;advice&lt;/code&gt; 요청 은 &lt;code&gt;/advices/1&lt;/code&gt; 대신 &lt;code&gt;/advice/1&lt;/code&gt; 로 이동해야합니다 .</target>
        </trans-unit>
        <trans-unit id="388cb66fb1ec711f83c1701450ba620236ebbe6b" translate="yes" xml:space="preserve">
          <source>This will use the primitive &lt;code&gt;replace()&lt;/code&gt; method to insert an object at the specified index.</source>
          <target state="translated">프리미티브 &lt;code&gt;replace()&lt;/code&gt; 메소드를 사용하여 지정된 인덱스에 객체를 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="43bffd1dffcb32d458aa58f02d05febe38e1f4a7" translate="yes" xml:space="preserve">
          <source>This works great for the &lt;code&gt;list-of-drafts&lt;/code&gt; component. However, your app is likely made up of many different components. On another page you may want a component to display the number of drafts. You may be tempted to copy and paste your existing &lt;code&gt;willRender&lt;/code&gt; code into the new component.</source>
          <target state="translated">이것은 &lt;code&gt;list-of-drafts&lt;/code&gt; 구성 요소에 효과적 입니다. 그러나 앱은 여러 구성 요소로 구성되어있을 수 있습니다. 다른 페이지에서 구성 요소가 초안 수를 표시하도록 할 수 있습니다. 기존 &lt;code&gt;willRender&lt;/code&gt; 코드 를 복사 하여 새 구성 요소에 붙여 넣으려고 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="560b1385ffc6e729721990fa2a58263d2b72df09" translate="yes" xml:space="preserve">
          <source>This works pretty well, but the message content is very different. It's also pretty long, so it wouldn't really be easy to pass the message content through as an argument. What we really want is to leave a placeholder for any content supplied by the &lt;code&gt;&amp;lt;Message&amp;gt;&lt;/code&gt; tag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14da4507e84203e01b9ae7da382b3a00aaae7fdc" translate="yes" xml:space="preserve">
          <source>This would render this HTML when no title is passed to the component:</source>
          <target state="translated">제목이 구성 요소에 전달되지 않으면이 HTML을 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="8336ed0cc011aca5ef8d79b9105deaab281f7bb6" translate="yes" xml:space="preserve">
          <source>This would render this HTML:</source>
          <target state="translated">이것은이 HTML을 렌더링합니다 :</target>
        </trans-unit>
        <trans-unit id="0bafaa0983dca2c93a7d748f2e163597e94bf0d7" translate="yes" xml:space="preserve">
          <source>Three notable properties on the &lt;code&gt;ENV&lt;/code&gt; object are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddbb8f268d6b753ca5221af5991b8173c660326e" translate="yes" xml:space="preserve">
          <source>Throwing an &lt;code&gt;InvalidError&lt;/code&gt; makes per-attribute errors available for records to use in the UI as needed. Records can also use this information to mark themselves as being in an &lt;code&gt;invalid&lt;/code&gt; state. For more reading &lt;a href=&quot;https://emberjs.github.io/rfcs/0465-record-data-errors.html&quot;&gt;see the RecordData Errors RFC&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84006ec1fbe089f93f04790646a82cbef861bb3e" translate="yes" xml:space="preserve">
          <source>Thus when the div is clicked, the action on that context is called. Because the &lt;code&gt;actionFunction&lt;/code&gt; is just a function, closure actions can be passed between components and still execute in the correct context.</source>
          <target state="translated">따라서 div를 클릭하면 해당 컨텍스트에 대한 조치가 호출됩니다. &lt;code&gt;actionFunction&lt;/code&gt; 은 함수일 뿐이 므로 클로저 조치는 구성 요소간에 전달 될 수 있으며 여전히 올바른 컨텍스트에서 실행될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="777fb441ed8a221e3154f33948c533e6c0b3cd66" translate="yes" xml:space="preserve">
          <source>Thus, many of Ember's built-in helpers (as well as your custom helpers) can be used in nested form.</source>
          <target state="translated">따라서 많은 Ember의 내장 헬퍼 (및 사용자 정의 헬퍼)는 중첩 된 형태로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc09fd602f6d10a4673777c6b4fc42a255573839" translate="yes" xml:space="preserve">
          <source>Thus, the output of these combined helpers is &lt;code&gt;10&lt;/code&gt;.</source>
          <target state="translated">따라서 이러한 결합 된 헬퍼의 출력은 &lt;code&gt;10&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="22a4ad2c60d9b1a4a4ab47810c732e12faec00b0" translate="yes" xml:space="preserve">
          <source>TimeoutError</source>
          <target state="translated">TimeoutError</target>
        </trans-unit>
        <trans-unit id="1f2ce174b2e23b432db6447553d675ab0c9dda04" translate="yes" xml:space="preserve">
          <source>Timer information for use in canceling, see `cancel`.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8708c4922aad6bc5f7d4fb439f5a35edf457ec9" translate="yes" xml:space="preserve">
          <source>Timer information for use in canceling, see `run.cancel`.</source>
          <target state="translated">취소에 사용되는 타이머 정보는`run.cancel`을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ad8314f52b2f4c62535401de872ed1002612344d" translate="yes" xml:space="preserve">
          <source>Timer object to cancel</source>
          <target state="translated">취소 할 타이머 객체</target>
        </trans-unit>
        <trans-unit id="d393dc0e4b2a5c2cc44ef7e4ef9df6956f16e16f" translate="yes" xml:space="preserve">
          <source>To access a service, you can inject it in any container-resolved object such as a component or another service using the &lt;code&gt;Ember.inject.service&lt;/code&gt; function. There are two ways to use this function. You can either invoke it with no arguments, or you can pass it the registered name of the service. When no arguments are passed, the service is loaded based on the name of the variable key. You can load the shopping cart service with no arguments like below.</source>
          <target state="translated">서비스에 액세스하기 위해 &lt;code&gt;Ember.inject.service&lt;/code&gt; 기능을 사용하여 컴포넌트 또는 다른 서비스와 같은 컨테이너 해결 오브젝트에 서비스를 삽입 할 수 있습니다 . 이 기능을 사용하는 방법은 두 가지가 있습니다. 인수없이 호출하거나 등록 된 서비스 이름을 전달할 수 있습니다. 인수가 전달되지 않으면 변수 키의 이름을 기반으로 서비스가로드됩니다. 다음과 같은 인수없이 장바구니 서비스를로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="47a48f940e245023ae65dbf358116a8794750b2b" translate="yes" xml:space="preserve">
          <source>To access a service, you can inject it in any container-resolved object such as a component or another service using the &lt;code&gt;inject&lt;/code&gt; decorator from the &lt;code&gt;@ember/service&lt;/code&gt; module. Standard practice is to alias &lt;code&gt;inject&lt;/code&gt; as &lt;code&gt;service&lt;/code&gt; to make it more clear that it is performing service injection. There are two ways to use this decorator. You can either invoke it with no arguments, or you can pass it the registered name of the service. When no arguments are passed, the service is loaded based on the name of the decorated property. You can load the shopping cart service with no arguments like below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffe33c827a08c52160d5affa7f5c08e93d329fbb" translate="yes" xml:space="preserve">
          <source>To accomplish that, we'll create a modifier in &lt;code&gt;app/modifiers/autofocus.js&lt;/code&gt;. First, install &lt;a href=&quot;https://github.com/ember-modifier/ember-modifier&quot;&gt;&lt;code&gt;ember-modifier&lt;/code&gt;&lt;/a&gt; and then generate an &lt;code&gt;autofocus&lt;/code&gt; modifier for your app:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="331593d4190d1c8bc321ea7f987f9d54aab9f978" translate="yes" xml:space="preserve">
          <source>To accomplish this, we can use &lt;a href=&quot;https://github.com/ember-modifier/ember-modifier&quot;&gt;&lt;code&gt;ember-modifier&lt;/code&gt;&lt;/a&gt; to create a &lt;code&gt;on-click-outside&lt;/code&gt; modifier that sets up the event listener after the element is first inserted and removes the event listener when the element is removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cb96283d1f05e33a412979c08b0402944a820d8" translate="yes" xml:space="preserve">
          <source>To add JavaScript to a component, create a JavaScript file in the same location as the template file, with the same name, and export a subclass of &lt;code&gt;Component&lt;/code&gt; as the default value. For example, to add Javascript to the &lt;code&gt;PersonProfile&lt;/code&gt; component which we defined above, we would create &lt;code&gt;app/comopnents/person-profile.js&lt;/code&gt; and export our class as the default, like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad4e497b4d36c647d22f988a7c0708a0614aef99" translate="yes" xml:space="preserve">
          <source>To add a &lt;code&gt;category&lt;/code&gt; query parameter that will filter out all the articles that haven't been categorized as popular we'd specify &lt;code&gt;'category'&lt;/code&gt; as one of &lt;code&gt;controller:article&lt;/code&gt;'s &lt;code&gt;queryParams&lt;/code&gt;:</source>
          <target state="translated">인기있는 카테고리로 분류되지 않은 모든 기사를 필터링 하는 &lt;code&gt;category&lt;/code&gt; 쿼리 매개 변수 를 추가하려면 &lt;code&gt;controller:article&lt;/code&gt; 's &lt;code&gt;queryParams&lt;/code&gt; 중 하나로 &lt;code&gt;'category'&lt;/code&gt; 를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="881e05d45a48244e280518b093e6c499505339ae" translate="yes" xml:space="preserve">
          <source>To add a &lt;code&gt;category&lt;/code&gt; query parameter that will filter out all the articles that haven't been categorized as popular we'd specify &lt;code&gt;'category'&lt;/code&gt; as one of &lt;code&gt;controller:articles&lt;/code&gt;'s &lt;code&gt;queryParams&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64b4906525b4bd262e5a9d0ce454f20e5241165a" translate="yes" xml:space="preserve">
          <source>To add a new helper, create a file with the name of the helper you want (e.g. &lt;code&gt;format-currency.js&lt;/code&gt;) in your application's &lt;code&gt;helpers&lt;/code&gt; directory. You can also have Ember generate the file for you from the command line:</source>
          <target state="translated">새 도우미를 추가하려면 응용 프로그램의 &lt;code&gt;helpers&lt;/code&gt; 디렉토리에 원하는 도우미 이름 (예 : &lt;code&gt;format-currency.js&lt;/code&gt; ) 으로 파일을 만듭니다 . 명령 행에서 Ember가 파일을 생성하도록 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccf70d0371c2fbff368e75db67c4c62218610aa5" translate="yes" xml:space="preserve">
          <source>To add an object to an enumerable, use the &lt;code&gt;addObject()&lt;/code&gt; method. This method will only add the object to the enumerable if the object is not already present and is of a type supported by the enumerable.</source>
          <target state="translated">열거 가능 객체에 객체를 추가하려면 &lt;code&gt;addObject()&lt;/code&gt; 메서드를 사용하십시오 . 이 메소드는 오브젝트가 존재하지 않고 열거 가능 오브젝트에서 지원되는 유형 인 경우에만 오브젝트를 열거 가능 오브젝트에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="612437c7a9dd2aab848343a115ff82b4a3a49077" translate="yes" xml:space="preserve">
          <source>To add an observer for a property, call:</source>
          <target state="translated">속성에 대한 관찰자를 추가하려면 다음을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="4867be37996666d07d63c82a065245790f59a744" translate="yes" xml:space="preserve">
          <source>To add behavior to the Application's boot process, you can define initializers in the &lt;code&gt;app/initializers&lt;/code&gt; directory, or with &lt;code&gt;ember generate initializer&lt;/code&gt; using Ember CLI. These files should export a named &lt;code&gt;initialize&lt;/code&gt; function which will receive the created &lt;code&gt;application&lt;/code&gt; object as its first argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64f77ec9361b31e70af01b3aeed99d505520fad8" translate="yes" xml:space="preserve">
          <source>To add functions and properties to instances of a constructor by extending the constructor's prototype see &lt;code&gt;reopen&lt;/code&gt;</source>
          <target state="translated">생성자의 프로토 타입을 확장하여 생성자의 인스턴스에 함수와 속성을 추가하려면 &lt;code&gt;reopen&lt;/code&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fbc1d24b350815efa8e5ebb0581fbf2701efa8fd" translate="yes" xml:space="preserve">
          <source>To add functions and properties to the constructor itself, see &lt;code&gt;reopenClass&lt;/code&gt;</source>
          <target state="translated">생성자 자체에 함수와 속성을 추가하려면 &lt;code&gt;reopenClass&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0e1f6f236f185a772efb6540307b2e949361e3c1" translate="yes" xml:space="preserve">
          <source>To add new events to be listened to:</source>
          <target state="translated">청취 할 새 이벤트를 추가하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="dd74399dd3c625fbe38e2a7a93a9e1356892dc03" translate="yes" xml:space="preserve">
          <source>To allow the &lt;code&gt;willTransition&lt;/code&gt; event to continue bubbling to the parent route, use &lt;code&gt;return true;&lt;/code&gt;. When the &lt;code&gt;willTransition&lt;/code&gt; method has a return value of &lt;code&gt;true&lt;/code&gt; then the parent route's &lt;code&gt;willTransition&lt;/code&gt; method will be fired, enabling &quot;bubbling&quot; behavior for the event.</source>
          <target state="translated">&lt;code&gt;willTransition&lt;/code&gt; 이벤트가 상위 경로로 버블 링을 계속 하도록하려면 &lt;code&gt;return true;&lt;/code&gt; 사용하십시오 . . 때 &lt;code&gt;willTransition&lt;/code&gt; 의 방법의 반환 값이 &lt;code&gt;true&lt;/code&gt; 다음 상위 경로의 &lt;code&gt;willTransition&lt;/code&gt; 의 방법이 발사됩니다 가능을 이벤트에 대한 동작을 &quot;버블 링&quot;.</target>
        </trans-unit>
        <trans-unit id="f55c6421e541207d1e25237aa0749707b6d2ce1f" translate="yes" xml:space="preserve">
          <source>To allow the user to widen the image, we will need to add an action that toggles the value of &lt;code&gt;isWide&lt;/code&gt;. Let's call this action &lt;code&gt;toggleImageSize&lt;/code&gt;</source>
          <target state="translated">사용자가 이미지를 넓히려면 &lt;code&gt;isWide&lt;/code&gt; 값을 토글하는 액션을 추가해야합니다 . 이 동작을 &lt;code&gt;toggleImageSize&lt;/code&gt; 라고 하겠습니다</target>
        </trans-unit>
        <trans-unit id="3893ea84ac6eb7bbc9a0aae0f524ff440385112a" translate="yes" xml:space="preserve">
          <source>To annotate computed properties, use the &lt;code&gt;Ember.computed()&lt;/code&gt; method to wrap the function:</source>
          <target state="translated">계산 된 속성에 주석을 &lt;code&gt;Ember.computed()&lt;/code&gt; 메서드를 사용하여 함수를 래핑하십시오.</target>
        </trans-unit>
        <trans-unit id="e071cc851bb0bc0f6989e55a7267d408ac9f27fc" translate="yes" xml:space="preserve">
          <source>To attach an event handler to an HTML tag, we use the &lt;code&gt;on&lt;/code&gt; HTML modifier. HTML modifiers are an Ember syntax that allow us to attach logic to a tag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fe75361f7d4d895b287bf14c5b819b85797d1a1" translate="yes" xml:space="preserve">
          <source>To avoid this behavior, it is encouraged to initialize those arrays and object properties during &lt;code&gt;init()&lt;/code&gt;. Doing so ensures each instance will be unique.</source>
          <target state="translated">이 동작을 피하려면 &lt;code&gt;init()&lt;/code&gt; 동안 해당 배열과 객체 속성을 초기화하는 것이 좋습니다 . 그렇게하면 각 인스턴스가 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="7023afe6c467f1d9d8a77531b4eee7ffb2d113e8" translate="yes" xml:space="preserve">
          <source>To begin, let's generate our new component. We'll call this component &lt;code&gt;list-filter&lt;/code&gt;, since all we want our component to do is filter the list of rentals based on input.</source>
          <target state="translated">먼저 새 컴포넌트를 생성 해 봅시다. 이 컴포넌트를 &lt;code&gt;list-filter&lt;/code&gt; 라고 부릅니다. 컴포넌트 가 원하는 것은 입력을 기준으로 대여 목록을 필터링하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="2041c7e5184639b6652b147ff7731d4861370040" translate="yes" xml:space="preserve">
          <source>To browse addons, visit the &lt;a href=&quot;https://emberobserver.com/&quot;&gt;Ember Observer&lt;/a&gt; website. It catalogs and categorizes Ember addons that have been published to NPM and assigns them a score based on a variety of criteria.</source>
          <target state="translated">애드온을 찾아 보려면 &lt;a href=&quot;https://emberobserver.com/&quot;&gt;Ember Observer&lt;/a&gt; 웹 사이트를 방문하십시오 . NPM에 게시 된 Ember 애드온을 카탈로그로 분류하고 다양한 기준에 따라 점수를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="72c79a645f164969a578face136c93d7b1bba2ca" translate="yes" xml:space="preserve">
          <source>To call an action on specific events, use the &lt;code&gt;{{on}}&lt;/code&gt; modifier:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d2de65aa264859c42ccec965b16380ce611d54d" translate="yes" xml:space="preserve">
          <source>To change the format of the data that is sent to the backend store, you can use the &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.JSONAPISerializer.html#method_serialize&quot;&gt;&lt;code&gt;serialize()&lt;/code&gt;&lt;/a&gt; hook. Let's say that we have this JSON API response from Ember Data:</source>
          <target state="translated">백엔드 저장소로 전송되는 데이터 형식을 변경하려면 &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.JSONAPISerializer.html#method_serialize&quot;&gt; &lt;code&gt;serialize()&lt;/code&gt; &lt;/a&gt; 후크를 사용할 수 있습니다 . Ember Data의 JSON API 응답이 있다고 가정 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="b8e8771ec7ed4b3c5ee9b1bbe9db135c8bf0b4ce" translate="yes" xml:space="preserve">
          <source>To change the format of the data that is sent to the backend store, you can use the &lt;a href=&quot;https://api.emberjs.com/ember-data/release/classes/JSONAPISerializer/methods#serialize&quot;&gt;&lt;code&gt;serialize()&lt;/code&gt;&lt;/a&gt; hook. Let's say that we have this JSON:API response from Ember Data:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8147260956e1d80c68ae4385b8dfaf8e846f2a9f" translate="yes" xml:space="preserve">
          <source>To check that rentals are listed with an automated test, we will create a test to visit the index route and check that the results show 3 listings.</source>
          <target state="translated">대여가 자동 테스트와 함께 나열되어 있는지 확인하기 위해 인덱스 경로를 방문하고 결과에 3 개의 목록이 표시되는지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="1f8255d58ff45b69a2cfcbdef10d629721ba8fc6" translate="yes" xml:space="preserve">
          <source>To clear the currently logged Promises, click on the clear icon on the top left of the tab.</source>
          <target state="translated">현재 기록 된 약속을 지우려면 탭 왼쪽 위에있는 지우기 아이콘을 클릭하십시오.</target>
        </trans-unit>
        <trans-unit id="29f27b12694ecb81b431f0d90751a5300c28c856" translate="yes" xml:space="preserve">
          <source>To collect deprecations, first run your in-browser test suite by starting your development server and navigating to &lt;a href=&quot;http://localhost:4200/tests&quot;&gt;&lt;code&gt;http://localhost:4200/tests&lt;/code&gt;&lt;/a&gt;. If your test suite isn't fully covering your app's functionality, you may also manually exercise functionality within your app where needed. Once you've exercised the app to your satisfaction, run the following command within your browser console: &lt;code&gt;deprecationWorkflow.flushDeprecations()&lt;/code&gt;. This will print to the console JavaScript code, which you should then copy to a new file in your project called &lt;code&gt;/config/deprecation-workflow.js&lt;/code&gt;</source>
          <target state="translated">지원 중단을 수집하려면 먼저 개발 서버를 시작하고 &lt;a href=&quot;http://localhost:4200/tests&quot;&gt; &lt;code&gt;http://localhost:4200/tests&lt;/code&gt; 로&lt;/a&gt; 이동하여 브라우저 내 테스트 스위트를 실행하십시오 . 테스트 스위트가 앱의 기능을 완전히 다루지 않는 경우 필요한 경우 앱 내에서 수동으로 기능을 연습 할 수도 있습니다. 앱을 만족스럽게 연습 한 후 브라우저 콘솔 내에서 &lt;code&gt;deprecationWorkflow.flushDeprecations()&lt;/code&gt; 명령을 실행하십시오 . 그러면 콘솔 JavaScript 코드로 인쇄 된 다음 프로젝트의 &lt;code&gt;/config/deprecation-workflow.js&lt;/code&gt; 라는 새 파일로 복사해야합니다.</target>
        </trans-unit>
        <trans-unit id="e7e50ab7bdcafc87b9e1da97ba46ad133f5b5047" translate="yes" xml:space="preserve">
          <source>To collect deprecations, first run your in-browser test suite by starting your development server and navigating to &lt;a href=&quot;http://localhost:4200/tests&quot;&gt;&lt;code&gt;http://localhost:4200/tests&lt;/code&gt;&lt;/a&gt;. If your test suite isn't fully covering your app's functionality, you may also manually exercise functionality within your app where needed. Once you've exercised the app to your satisfaction, run the following command within your browser console: &lt;code&gt;deprecationWorkflow.flushDeprecations()&lt;/code&gt;. This will print to the console JavaScript code, which you should then copy to a new file in your project called &lt;code&gt;config/deprecation-workflow.js&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fdc1331bae434af40f12bc03ea73f91e17ec118" translate="yes" xml:space="preserve">
          <source>To configure feature-flags at runtime you will want to configure &lt;code&gt;window.EmberDataENV = {}&lt;/code&gt; appropriately. You should add this global property in your app prior to your application booting. At the top of your &lt;code&gt;app.js&lt;/code&gt; file is a convenient location, as is within &lt;code&gt;index.html&lt;/code&gt; as a script running prior to loading any other scripts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e30036137bbed352514ffa1a7f66b8cbe2dcdd5f" translate="yes" xml:space="preserve">
          <source>To configure your compatibility version, set the &lt;code&gt;compatWith&lt;/code&gt; to the version you are compatible with on the &lt;code&gt;emberData&lt;/code&gt; config in your &lt;code&gt;ember-cli-build.js&lt;/code&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a04c51d3d1b4bc7bda88a128ff59a1c6cc33823" translate="yes" xml:space="preserve">
          <source>To consult all available built-in helpers, you can check the &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Ember.Templates.helpers/&quot;&gt;template helpers API documentation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3175b38418b12c2d580746cc8cc19dc3a953fab7" translate="yes" xml:space="preserve">
          <source>To create a class-based helper, rather than exporting a simple function, you should export a subclass of &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Helper.html&quot;&gt;&lt;code&gt;Ember.Helper&lt;/code&gt;&lt;/a&gt;. Helper classes must contain a &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Helper.html#method_compute&quot;&gt;&lt;code&gt;compute&lt;/code&gt;&lt;/a&gt; method that behaves the same as the function passed to &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Helper.html#method_helper&quot;&gt;&lt;code&gt;Ember.Helper.helper&lt;/code&gt;&lt;/a&gt;. In order to access a service, you must first inject it into the class-based helper. Once added, you can call the service's methods or access its properties from within the &lt;code&gt;compute()&lt;/code&gt; method.</source>
          <target state="translated">간단한 함수를 내 보내지 않고 클래스 기반 도우미를 만들려면 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Helper.html&quot;&gt; &lt;code&gt;Ember.Helper&lt;/code&gt; &lt;/a&gt; 하위 클래스를 내 보내야 합니다. 헬퍼 클래스는 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Helper.html#method_helper&quot;&gt; &lt;code&gt;Ember.Helper.helper&lt;/code&gt; 에&lt;/a&gt; 전달 된 함수와 동일하게 동작 하는 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Helper.html#method_compute&quot;&gt; &lt;code&gt;compute&lt;/code&gt; &lt;/a&gt; 메소드를 포함해야합니다 . 서비스에 액세스하려면 먼저 클래스 기반 도우미에 서비스를 주입해야합니다. 추가 한 후에는 서비스의 메소드를 호출하거나 &lt;code&gt;compute()&lt;/code&gt; 메소드 에서 해당 특성에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="483b244a408fb90428d0b9a44c7fe6d9ad8692be" translate="yes" xml:space="preserve">
          <source>To create a custom error to signal a specific error state in communicating with an external API, extend the &lt;code&gt;DS.AdapterError&lt;/code&gt;. For example if the external API exclusively used HTTP &lt;code&gt;503 Service Unavailable&lt;/code&gt; to indicate it was closed for maintenance:</source>
          <target state="translated">외부 API와 통신 할 때 특정 오류 상태를 알리는 사용자 정의 오류를 작성하려면 &lt;code&gt;DS.AdapterError&lt;/code&gt; 를 확장하십시오 . 예를 들어 외부 API가 HTTP &lt;code&gt;503 Service Unavailable&lt;/code&gt; 독점적으로 사용 하여 유지 보수를 위해 닫 혔음 을 표시하는 경우 :</target>
        </trans-unit>
        <trans-unit id="d9f0badc4f0227ed4677bc2258f094b4ab9b5955" translate="yes" xml:space="preserve">
          <source>To create a new app that has every Octane feature enabled, first make sure you have the latest Ember CLI version installed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f58871b9ab756fa7fbfd2a0634d267d3a4ce8ae" translate="yes" xml:space="preserve">
          <source>To create a new instance of a &lt;code&gt;Post&lt;/code&gt; that has a relationship with a &lt;code&gt;User&lt;/code&gt; record:</source>
          <target state="translated">&lt;code&gt;User&lt;/code&gt; 레코드 와 관계가있는 &lt;code&gt;Post&lt;/code&gt; 의 새 인스턴스를 작성하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="0e61e0cae04fd9ad56d0c4c5698e8faa32a1f269" translate="yes" xml:space="preserve">
          <source>To create a new instance of a &lt;code&gt;Post&lt;/code&gt;:</source>
          <target state="translated">(A)의 새 인스턴스를 만들려면 &lt;code&gt;Post&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7fa82787ae3f63115905a224cbbd4da31001a607" translate="yes" xml:space="preserve">
          <source>To create a new project using Ember CLI, use the &lt;code&gt;new&lt;/code&gt; command. In preparation for the tutorial in the next section, you can make an app called &lt;code&gt;super-rentals&lt;/code&gt;.</source>
          <target state="translated">Ember CLI를 사용하여 새 프로젝트를 만들려면 &lt;code&gt;new&lt;/code&gt; 명령을 사용하십시오 . 다음 섹션의 튜토리얼을 준비하면서 &lt;code&gt;super-rentals&lt;/code&gt; 라는 앱을 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0507bf8200bc0fc65ea17fae004600ec931bee74" translate="yes" xml:space="preserve">
          <source>To create an acceptance test, run &lt;code&gt;ember generate acceptance-test &amp;lt;name&amp;gt;&lt;/code&gt;. For example:</source>
          <target state="translated">승인 테스트를 작성하려면 &lt;code&gt;ember generate acceptance-test &amp;lt;name&amp;gt;&lt;/code&gt; . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="189a622c1c4bcbb39d736471076d4c691a324ae2" translate="yes" xml:space="preserve">
          <source>To create an application test, run &lt;code&gt;ember generate acceptance-test &amp;lt;name&amp;gt;&lt;/code&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6546ce366ebc2a0397c0ab3926caf7dfba659cf6" translate="yes" xml:space="preserve">
          <source>To create an index nested route, run the following command:</source>
          <target state="translated">인덱스 중첩 경로를 만들려면 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="f16533be33b27f3dabd74f1c1a59b9369d04e94e" translate="yes" xml:space="preserve">
          <source>To customize how &lt;code&gt;JSONSerializer&lt;/code&gt; normalizes a specific response from the server, use one of the many specific &lt;code&gt;normalizeResponse&lt;/code&gt; hooks.</source>
          <target state="translated">&lt;code&gt;JSONSerializer&lt;/code&gt; 가 서버의 특정 응답을 정규화하는 방법을 사용자 정의하려면 많은 특정 &lt;code&gt;normalizeResponse&lt;/code&gt; 후크 중 하나를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="efffbb69cac955b484ca11b4daebd1d8a4b7475b" translate="yes" xml:space="preserve">
          <source>To customize how &lt;code&gt;JSONSerializer&lt;/code&gt; normalizes the whole server response, use the &lt;code&gt;normalizeResponse&lt;/code&gt; hook.</source>
          <target state="translated">&lt;code&gt;JSONSerializer&lt;/code&gt; 가 전체 서버 응답을 정규화하는 방법을 사용자 정의하려면 &lt;code&gt;normalizeResponse&lt;/code&gt; 후크를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="85f903926c89b490fde43d23a09ec470fcb5dc60" translate="yes" xml:space="preserve">
          <source>To customize how &lt;code&gt;JSONSerializer&lt;/code&gt; normalizes your id, attributes or relationships, use the &lt;code&gt;extractId&lt;/code&gt;, &lt;code&gt;extractAttributes&lt;/code&gt; and &lt;code&gt;extractRelationships&lt;/code&gt; hooks.</source>
          <target state="translated">방법을 사용자 정의하려면 &lt;code&gt;JSONSerializer&lt;/code&gt; 가 귀하의 ID, 속성이나 관계를 정상화, 사용 &lt;code&gt;extractId&lt;/code&gt; , &lt;code&gt;extractAttributes&lt;/code&gt; 및 &lt;code&gt;extractRelationships&lt;/code&gt; 의 후크를.</target>
        </trans-unit>
        <trans-unit id="ba373f1b978a32c09a08e1c1a2055e76267a7a9f" translate="yes" xml:space="preserve">
          <source>To customize how a single record is normalized, use the &lt;code&gt;normalize&lt;/code&gt; hook.</source>
          <target state="translated">단일 레코드의 정규화 방법을 사용자 정의하려면 &lt;code&gt;normalize&lt;/code&gt; 후크를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="896f7618df1a2c5ae15b21da0d539bcce0c86fef" translate="yes" xml:space="preserve">
          <source>To customize metadata extraction, check out the documentation for your serializer.</source>
          <target state="translated">메타 데이터 추출을 사용자 정의하려면 직렬 변환기 설명서를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="d00f2a82ea97d7698e61579522a38bad982a0f6f" translate="yes" xml:space="preserve">
          <source>To declare a many-to-many relationship between two models, use &lt;code&gt;DS.hasMany&lt;/code&gt;:</source>
          <target state="translated">두 모델 사이의 다 대다 관계를 선언하려면 &lt;code&gt;DS.hasMany&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="cc67abd9992f5eb4a7a6b6a250d06fb9592d2ffd" translate="yes" xml:space="preserve">
          <source>To declare a many-to-many relationship between two models, use &lt;code&gt;hasMany&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f384718df6203efdfa0de22885112131e57b9ef5" translate="yes" xml:space="preserve">
          <source>To declare a one-to-many relationship between two models, use &lt;code&gt;DS.belongsTo&lt;/code&gt; in combination with &lt;code&gt;DS.hasMany&lt;/code&gt;, like this:</source>
          <target state="translated">두 모델 간의 일대 다 관계를 사용 선언하려면 &lt;code&gt;DS.belongsTo&lt;/code&gt; 와 함께 &lt;code&gt;DS.hasMany&lt;/code&gt; 이 등을 :</target>
        </trans-unit>
        <trans-unit id="fe1ed030da25f0ac767e451614ef71155dfe5a43" translate="yes" xml:space="preserve">
          <source>To declare a one-to-many relationship between two models, use &lt;code&gt;belongsTo&lt;/code&gt; in combination with &lt;code&gt;hasMany&lt;/code&gt;, like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd45271172de2827aec0b66ded46c1526981e4f0" translate="yes" xml:space="preserve">
          <source>To declare a one-to-one relationship between two models, use &lt;code&gt;DS.belongsTo&lt;/code&gt;:</source>
          <target state="translated">두 모델간에 일대일 관계를 선언하려면 &lt;code&gt;DS.belongsTo&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="db339c08523231f8edd90171a686e296be3611f1" translate="yes" xml:space="preserve">
          <source>To declare a one-to-one relationship between two models, use &lt;code&gt;belongsTo&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22bb95d7016d3a82a771c01b24a90740704cb355" translate="yes" xml:space="preserve">
          <source>To define a Controller, run:</source>
          <target state="translated">컨트롤러를 정의하려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="537f62c13bb7ffd878dfd54110b3a5a612606ee8" translate="yes" xml:space="preserve">
          <source>To define a component, run:</source>
          <target state="translated">구성 요소를 정의하려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="284d1b21151d2a0f19c15e660bf3d35370f288b5" translate="yes" xml:space="preserve">
          <source>To define a new Ember &lt;em&gt;class&lt;/em&gt;, call the &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Object.html#method_extend&quot;&gt;&lt;code&gt;extend()&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Object.html&quot;&gt;&lt;code&gt;Ember.Object&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">새로운 Ember &lt;em&gt;클래스&lt;/em&gt; 를 정의하려면 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Object.html&quot;&gt; &lt;code&gt;Ember.Object&lt;/code&gt; &lt;/a&gt; 에서 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Object.html#method_extend&quot;&gt; &lt;code&gt;extend()&lt;/code&gt; &lt;/a&gt; 메소드를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="820da85f7f75fe525eb448c437bc45950e1f888d" translate="yes" xml:space="preserve">
          <source>To define a route, run</source>
          <target state="translated">경로를 정의하려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="e7d7b2d08cd1de85998600ba46809350abc299b9" translate="yes" xml:space="preserve">
          <source>To deploy an Ember application simply transfer the output from &lt;code&gt;ember build&lt;/code&gt; to a web server. This can be done with standard Unix file transfer tools such as &lt;code&gt;rsync&lt;/code&gt; or &lt;code&gt;scp&lt;/code&gt;. There are also services that will let you deploy easily.</source>
          <target state="translated">Ember 애플리케이션을 배포하려면 단순히 엠버 &lt;code&gt;ember build&lt;/code&gt; 의 출력을 웹 서버 로 전송하십시오 . 이것은 &lt;code&gt;rsync&lt;/code&gt; 또는 &lt;code&gt;scp&lt;/code&gt; 와 같은 표준 Unix 파일 전송 도구를 사용하여 수행 할 수 있습니다 . 쉽게 배포 할 수있는 서비스도 있습니다.</target>
        </trans-unit>
        <trans-unit id="065fd99d1476baffa1b82c4b08460d031141cb32" translate="yes" xml:space="preserve">
          <source>To deploy to the same URL after making changes, perform the same steps, reusing the same domain as before.</source>
          <target state="translated">변경 후 동일한 URL에 배포하려면 이전과 동일한 도메인을 재사용하여 동일한 단계를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="49f0e5a5556d1784583a08d323f8bb602095029d" translate="yes" xml:space="preserve">
          <source>To dig deeper into accessible input patterns in Ember check out the &lt;a href=&quot;https://emberjs-1.gitbook.io/ember-component-patterns/form-components/input&quot;&gt;ember-component-patterns article on Input Fields&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6734a6e5bb3c4c06ddac515519b73ca33307818c" translate="yes" xml:space="preserve">
          <source>To disable bubbling with closure style actions you must create your own wrapper helper that makes use of &lt;code&gt;event.stopPropagation()&lt;/code&gt;:</source>
          <target state="translated">클로저 스타일 액션으로 버블 링을 비활성화하려면 &lt;code&gt;event.stopPropagation()&lt;/code&gt; 사용하는 자체 래퍼 도우미를 만들어야합니다 .</target>
        </trans-unit>
        <trans-unit id="03d431777776d94843205036e89382929b67b7df" translate="yes" xml:space="preserve">
          <source>To disable bubbling, pass &lt;code&gt;bubbles=false&lt;/code&gt; to the helper:</source>
          <target state="translated">버블 링을 비활성화하려면 &lt;code&gt;bubbles=false&lt;/code&gt; 를 도우미에게 전달 하십시오.</target>
        </trans-unit>
        <trans-unit id="0a92d47537f25ade1c4b932096e3e3c06b398c23" translate="yes" xml:space="preserve">
          <source>To disable this feature, first migrate away from the jQuery integration APIs. Below is a list of the jQuery specific APIs in Ember, and how to migrate away from them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83f92bbd711ff46b48c7b3053ad6815ca742a2e1" translate="yes" xml:space="preserve">
          <source>To dispatch an action on specific events, such as &lt;code&gt;enter&lt;/code&gt; or &lt;code&gt;key-press&lt;/code&gt;, use the following</source>
          <target state="translated">&lt;code&gt;enter&lt;/code&gt; 또는 &lt;code&gt;key-press&lt;/code&gt; 와 같은 특정 이벤트에 대한 조치를 전달하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="53be2d3cee464dda29e541bcc47ec4c0a39972d4" translate="yes" xml:space="preserve">
          <source>To do so, run the following command:</source>
          <target state="translated">이렇게하려면 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="0711a711e6a702ee3f035ad582cb0f83d0ea3111" translate="yes" xml:space="preserve">
          <source>To do so, simply set the &lt;code&gt;EmberENV.EXTEND_PROTOTYPES&lt;/code&gt; flag to &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="translated">이렇게하려면 &lt;code&gt;EmberENV.EXTEND_PROTOTYPES&lt;/code&gt; 플래그를 &lt;code&gt;false&lt;/code&gt; 로 설정하면 됩니다 .</target>
        </trans-unit>
        <trans-unit id="642b3e926c752f7b1f53ecb9a54d25f0d597ad8b" translate="yes" xml:space="preserve">
          <source>To do that, replace occurrences of &lt;code&gt;/list-rentals&lt;/code&gt; in the generated test with &lt;code&gt;/&lt;/code&gt;. The test will start our app at the base url, &lt;code&gt;http://localhost:4200/&lt;/code&gt;, and then do a basic check that the page has finished loading and that the url is what we want it to be.</source>
          <target state="translated">이를 위해의 발생 교체 &lt;code&gt;/list-rentals&lt;/code&gt; 로 생성 된 테스트에서 &lt;code&gt;/&lt;/code&gt; . 테스트는 기본 URL &lt;code&gt;http://localhost:4200/&lt;/code&gt; 에서 앱을 시작한 다음 페이지로드가 완료되었으며 URL이 원하는 것인지 기본 확인합니다.</target>
        </trans-unit>
        <trans-unit id="1df522ee440a55de68e6a9dd8378f737af37e593" translate="yes" xml:space="preserve">
          <source>To do that, we modify our route as follows:</source>
          <target state="translated">이를 위해 다음과 같이 경로를 수정합니다.</target>
        </trans-unit>
        <trans-unit id="077ff282e23889aeeea0b97f0141bf14b2b23e54" translate="yes" xml:space="preserve">
          <source>To do that, we'll use a &lt;a href=&quot;https://guides.emberjs.com/templates/links/&quot;&gt;&lt;code&gt;{{link-to}}&lt;/code&gt;&lt;/a&gt; helper that Ember provides that makes it easy to link between our routes. Let's adjust our &lt;code&gt;about.hbs&lt;/code&gt; file:</source>
          <target state="translated">이를 위해 Ember에서 제공 하는 &lt;a href=&quot;https://guides.emberjs.com/templates/links/&quot;&gt; &lt;code&gt;{{link-to}}&lt;/code&gt; &lt;/a&gt; 도우미를 사용하여 경로를 쉽게 연결할 수 있습니다. &lt;code&gt;about.hbs&lt;/code&gt; 파일을 조정 해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="11c58088248b73af9dd4c10ee5d8407a7c330748" translate="yes" xml:space="preserve">
          <source>To do this, create an &lt;a href=&quot;https://guides.emberjs.com/applications/initializers/&quot;&gt;Initializer&lt;/a&gt; file containing your customizations. The Ember CLI's &lt;code&gt;initializer&lt;/code&gt; generator can be used &lt;code&gt;ember generate initializer custom-inflector-rules&lt;/code&gt; to create the file. Update its content as follow:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d87c2ae1d29eef6f28426678419f6574ae578e14" translate="yes" xml:space="preserve">
          <source>To embed the &lt;code&gt;ids&lt;/code&gt; for a related object (using a hasMany relationship):</source>
          <target state="translated">hasMany 관계를 사용하여 관련 오브젝트 의 &lt;code&gt;ids&lt;/code&gt; 를 임베드하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="7b266ec9d9020d51490a793b222a2e15e77408c1" translate="yes" xml:space="preserve">
          <source>To embed the relationship as a collection of objects with &lt;code&gt;id&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt; keys, set &lt;code&gt;ids-and-types&lt;/code&gt; for the related object.</source>
          <target state="translated">행을 가진 객체의 컬렉션으로서 포함 관계 &lt;code&gt;id&lt;/code&gt; 및 &lt;code&gt;type&lt;/code&gt; 키 세트 &lt;code&gt;ids-and-types&lt;/code&gt; 관련 개체를.</target>
        </trans-unit>
        <trans-unit id="9f64d9ceccb26c4763feaef7f57fe7b97b194674" translate="yes" xml:space="preserve">
          <source>To enable full stacktrace mode in Backburner, and thus determine the stack of the task when it was scheduled onto the run loop, you can set:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4dbe3553d2c10be5b18402a6280f709c7557952" translate="yes" xml:space="preserve">
          <source>To enable support for data attributes an attribute binding must be added to the component, e.g. &lt;a href=&quot;http://emberjs.com/api/classes/Ember.LinkComponent.html&quot;&gt;&lt;code&gt;Ember.LinkComponent&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;http://emberjs.com/api/classes/Ember.TextField.html&quot;&gt;&lt;code&gt;Ember.TextField&lt;/code&gt;&lt;/a&gt; for the specific attribute:</source>
          <target state="translated">데이터 속성을 지원하려면 특정 속성에 대해 속성 바인딩을 컴포넌트에 추가해야합니다 (예 : &lt;a href=&quot;http://emberjs.com/api/classes/Ember.LinkComponent.html&quot;&gt; &lt;code&gt;Ember.LinkComponent&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.TextField.html&quot;&gt; &lt;code&gt;Ember.TextField&lt;/code&gt; )&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9395edf3439fe814bda2e423bd1d2d6905021476" translate="yes" xml:space="preserve">
          <source>To enable the Ember favicon to show up in the URL bar whenever you are visiting a site that uses Ember visit &lt;code&gt;about:addons&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb5f57bc075f6cf1a9892170f5cc300d7a2ec2da" translate="yes" xml:space="preserve">
          <source>To enable the Tomster icon to show up in the URL bar whenever you are visiting a site that uses Ember visit &lt;code&gt;about:addons&lt;/code&gt;.</source>
          <target state="translated">Ember를 사용하는 사이트를 방문 할 때마다 URL 막대에 Tomster 아이콘이 표시되도록하려면 &lt;code&gt;about:addons&lt;/code&gt; 를 방문하십시오 .</target>
        </trans-unit>
        <trans-unit id="52c2b2d458eaa991122169345b898417f6372aad" translate="yes" xml:space="preserve">
          <source>To enable this mode you can set:</source>
          <target state="translated">이 모드를 활성화하려면 다음을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="d3e54ffc59a679009cd71018fbf20dc2908c33d0" translate="yes" xml:space="preserve">
          <source>To enumerate all the values of an enumerable object, use the &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Enumerable.html#method_forEach&quot;&gt;&lt;code&gt;forEach()&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="translated">열거 가능한 객체의 모든 값을 열거하려면 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Enumerable.html#method_forEach&quot;&gt; &lt;code&gt;forEach()&lt;/code&gt; &lt;/a&gt; 메서드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d359b2db0086dd5035c16e4f02e4ba46333d6fbe" translate="yes" xml:space="preserve">
          <source>To evaluate more addons to add/manage content in the &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; of a page, view this category on &lt;a href=&quot;https://emberobserver.com/categories/header-content&quot;&gt;Ember Observer&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2576d6fed5029c6df127ccc7ce3941b77810324b" translate="yes" xml:space="preserve">
          <source>To facilitate pluralizing model names when generating route URLs Ember Data comes bundled with &lt;a href=&quot;https://github.com/stefanpenner/ember-inflector&quot;&gt;Ember Inflector&lt;/a&gt;, an ActiveSupport::Inflector compatible library for inflecting words between plural and singular forms. Irregular or uncountable pluralizations can be specified via &lt;code&gt;Ember.Inflector.inflector&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e247d282c81bce4351bac12e80aee643f2064371" translate="yes" xml:space="preserve">
          <source>To facilitate pluralizing model names when generating route urls Ember Data comes bundled with &lt;a href=&quot;https://github.com/stefanpenner/ember-inflector&quot;&gt;Ember Inflector&lt;/a&gt;, an ActiveSupport::Inflector compatible library for inflecting words between plural and singular forms. Irregular or uncountable pluralizations can be specified via &lt;code&gt;Ember.Inflector.inflector&lt;/code&gt;. A common way to do this is:</source>
          <target state="translated">경로 URL을 생성 할 때 모델 이름을 다원화하기 위해 Ember Data는 &lt;a href=&quot;https://github.com/stefanpenner/ember-inflector&quot;&gt;Ember Inflector&lt;/a&gt; 와 함께 번들로 제공됩니다. Ember Inflector 는 ActiveSupport :: Inflector 호환 라이브러리로, 복수형과 단수형 사이의 단어를 반영합니다. 불규칙하거나 셀 수없는 복수형은 &lt;code&gt;Ember.Inflector.inflector&lt;/code&gt; 를 통해 지정할 수 있습니다 . 이를 수행하는 일반적인 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="89387035491e2b9779d432c33ff0f9bc1db9ee30" translate="yes" xml:space="preserve">
          <source>To facilitate this, Ember provides the &lt;code&gt;@each&lt;/code&gt; key illustrated below:</source>
          <target state="translated">이를 용이하게하기 위해 Ember는 아래에 설명 된 &lt;code&gt;@each&lt;/code&gt; 키를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="d181f0d9ef256075afc193e940cb2778cc125a3c" translate="yes" xml:space="preserve">
          <source>To fetch an instantiated factory from the running application you can call the &lt;a href=&quot;http://emberjs.com/api/classes/Ember.ApplicationInstance.html#method_lookup&quot;&gt;&lt;code&gt;lookup&lt;/code&gt;&lt;/a&gt; method on an application instance. This method takes a string to identify a factory and returns the appropriate object.</source>
          <target state="translated">실행중인 응용 프로그램에서 인스턴스화 된 팩토리를 가져 오려면 응용 프로그램 인스턴스 에서 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.ApplicationInstance.html#method_lookup&quot;&gt; &lt;code&gt;lookup&lt;/code&gt; &lt;/a&gt; 메서드를 호출 할 수 있습니다 . 이 메소드는 문자열을 사용하여 팩토리를 식별하고 적절한 오브젝트를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="528db8f8f881013ff42a8ee9a66389f79f4204aa" translate="yes" xml:space="preserve">
          <source>To fetch an instantiated factory from the running application you can call the &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/ApplicationInstance/methods#lookup&quot;&gt;&lt;code&gt;lookup&lt;/code&gt;&lt;/a&gt; method on an application instance. This method takes a string to identify a factory and returns the appropriate object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d1f23fd8117e1414f047abb53730ce2c42e57e9" translate="yes" xml:space="preserve">
          <source>To filter the logs, type a query in the search box.</source>
          <target state="translated">로그를 필터링하려면 검색 상자에 쿼리를 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="0333f3c27efad06e51f74436dfa3235419a97177" translate="yes" xml:space="preserve">
          <source>To find out the problem, you can add &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/debugger&quot;&gt;&lt;code&gt;debugger&lt;/code&gt;&lt;/a&gt; to your code to check the intermediate state. You can add this line to both test and application code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9c9e9ecb077e7d53718dabf283948eae57a0fe4" translate="yes" xml:space="preserve">
          <source>To find out whether at least one item in an enumerable matches some condition, you can use the &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Enumerable.html#method_any&quot;&gt;&lt;code&gt;any()&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="translated">열거 가능한 항목 중 적어도 하나의 항목이 어떤 조건과 일치하는지 확인하려면 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Enumerable.html#method_any&quot;&gt; &lt;code&gt;any()&lt;/code&gt; &lt;/a&gt; 메서드를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4c63511432e85445a8b4de943b86b4ff86b52bda" translate="yes" xml:space="preserve">
          <source>To find out whether every item in an enumerable matches some condition, you can use the &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Enumerable.html#method_every&quot;&gt;&lt;code&gt;every()&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="translated">열거 가능한 모든 항목이 특정 조건과 일치하는지 확인하려면 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Enumerable.html#method_every&quot;&gt; &lt;code&gt;every()&lt;/code&gt; &lt;/a&gt; 메서드를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="06062dde08f65defee01d144c5693a07b8897c5e" translate="yes" xml:space="preserve">
          <source>To find the elements that have a class called &lt;code&gt;listing&lt;/code&gt;, we'll use a test helper called &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Test.html#method_find&quot;&gt;find&lt;/a&gt;. The &lt;code&gt;find&lt;/code&gt; function returns the elements that match the given &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors&quot;&gt;CSS selector&lt;/a&gt;. In this case it will return an array of all the elements with a class called &lt;code&gt;listing&lt;/code&gt;.</source>
          <target state="translated">라는 클래스가있는 요소를 찾으려면 &lt;code&gt;listing&lt;/code&gt; , 우리라는 테스트 도우미 사용합니다 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Test.html#method_find&quot;&gt;찾기&lt;/a&gt; . &lt;code&gt;find&lt;/code&gt; 함수는 주어진 일치하는 요소를 반환 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors&quot;&gt;CSS 선택기를&lt;/a&gt; . 이 경우 &lt;code&gt;listing&lt;/code&gt; 이라는 클래스를 가진 모든 요소의 배열을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="2fd9f8a52de87bee0c288eaed67d1f195e5f6ddf" translate="yes" xml:space="preserve">
          <source>To fix this add a file called '.htaccess' to the root folder of your website. Add these lines:</source>
          <target state="translated">이 문제를 해결하려면 웹 사이트의 루트 폴더에 '.htaccess'라는 파일을 추가하십시오. 다음 줄을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="04005e74615bbb182cf85c5e41c6f4392088d120" translate="yes" xml:space="preserve">
          <source>To force a particular &lt;code&gt;location&lt;/code&gt; API implementation to be used in your application you can set a location type on your &lt;code&gt;config/environment&lt;/code&gt;. For example, to set the &lt;code&gt;history&lt;/code&gt; type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4874052fd3da4130e20d57017b5ff65b2f9c812f" translate="yes" xml:space="preserve">
          <source>To generate a controller, run</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc22e48a36a2fa58e492a5c1d7190654605ab3b1" translate="yes" xml:space="preserve">
          <source>To get around these problems, you should make use of &lt;a href=&quot;http://emberjs.com/api/classes/Ember.run.html#method_once&quot;&gt;&lt;code&gt;Ember.run.once()&lt;/code&gt;&lt;/a&gt;. This will ensure that any processing you need to do only happens once, and happens in the next run loop once all bindings are synchronized:</source>
          <target state="translated">이러한 문제를 해결하려면 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.run.html#method_once&quot;&gt; &lt;code&gt;Ember.run.once()&lt;/code&gt; &lt;/a&gt; 사용해야 합니다. 이렇게하면 필요한 처리가 한 번만 수행되고 모든 바인딩이 동기화되면 다음 실행 루프에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0c5c7f3992c8b26c72a8ca9516e0759dd90b734e" translate="yes" xml:space="preserve">
          <source>To get different &lt;em&gt;pages&lt;/em&gt; of data, you'd simply change your offset in increments of 10. So far, so good. But how do you know how many pages of data you have? Your server would need to return the total number of records as a piece of metadata.</source>
          <target state="translated">다른 &lt;em&gt;페이지&lt;/em&gt; 의 데이터 를 얻으 려면 오프셋을 10 씩 증분 변경하면됩니다. 지금까지는 좋습니다. 그러나 얼마나 많은 데이터 페이지가 있는지 어떻게 알 수 있습니까? 서버는 총 레코드 수를 메타 데이터로 리턴해야합니다.</target>
        </trans-unit>
        <trans-unit id="f2a4e5cc694d3be2b7e400ea560253d1f71eaa5c" translate="yes" xml:space="preserve">
          <source>To get multiple properties at once, call &lt;code&gt;Ember.getProperties&lt;/code&gt; with an object followed by a list of strings or an array:</source>
          <target state="translated">한 번에 여러 속성을 가져 오려면 개체와 문자열 목록 또는 배열을 사용하여 &lt;code&gt;Ember.getProperties&lt;/code&gt; 를 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="a4eb5bbacbba2cef49091dbac7935cb10725ae22" translate="yes" xml:space="preserve">
          <source>To get multiple properties at once, call &lt;code&gt;getProperties&lt;/code&gt; with an object followed by a list of strings or an array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f78d2de846a584ba2b1e880b414bf10c370b52c9" translate="yes" xml:space="preserve">
          <source>To get started with optional features, you must install the addon:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52ae9585ef4ff335f0b0a68e5513ed3dbe6488ec" translate="yes" xml:space="preserve">
          <source>To get started, let's generate a helper for &lt;code&gt;rental-property-type&lt;/code&gt;:</source>
          <target state="translated">시작하려면 &lt;code&gt;rental-property-type&lt;/code&gt; 대한 도우미를 생성 해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="73b15a2e4a984f27699d34f68a905af2183041a0" translate="yes" xml:space="preserve">
          <source>To get the most use out of a component, it is important to understand these lifecycle methods.</source>
          <target state="translated">구성 요소를 최대한 활용하려면 이러한 수명주기 방법을 이해하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="6236f3f8e8d8fe3fca72807f5fa28810b0997175" translate="yes" xml:space="preserve">
          <source>To get the multiplied number into the template, we'll use a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get&quot;&gt;JavaScript getter&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e28feb25417f98b442624123c65f66c40e988f2" translate="yes" xml:space="preserve">
          <source>To get the values of multiple properties at once, call &lt;code&gt;getProperties&lt;/code&gt; with a list of strings or an array:</source>
          <target state="translated">여러 속성의 값을 한 번에 얻으려면 문자열 목록 또는 배열을 사용하여 &lt;code&gt;getProperties&lt;/code&gt; 를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="48925557944e4e5ce54e4156dc66a8b020363878" translate="yes" xml:space="preserve">
          <source>To give the project a path forward when a breaking change is mandatory, we've released the &lt;a href=&quot;https://github.com/emberjs/ember-optional-features&quot;&gt;&lt;code&gt;@ember/optional-features&lt;/code&gt;&lt;/a&gt; addon.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7806e1c587e05f08b69393f6478019cb19942b1e" translate="yes" xml:space="preserve">
          <source>To handle this function call you need to modify the &lt;code&gt;people-list&lt;/code&gt; component file to add the function to be called. In the component, add an &lt;code&gt;actions&lt;/code&gt; object with a &lt;code&gt;showPerson&lt;/code&gt; function that alerts the first argument.</source>
          <target state="translated">이 함수 호출을 처리하려면 &lt;code&gt;people-list&lt;/code&gt; 구성 요소 파일을 수정하여 호출 할 함수 를 추가해야합니다. 컴포넌트 에서 첫 번째 인수를 알리는 &lt;code&gt;showPerson&lt;/code&gt; 함수를 사용 하여 &lt;code&gt;actions&lt;/code&gt; 오브젝트를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="5416b7eb8dce5acb1c8efef4e78276fe44c883b2" translate="yes" xml:space="preserve">
          <source>To have your route do something beyond render a template with the same name, you'll need to create a route handler. The following guides will explore the different features of route handlers. For more information on routes, see the API documentation for &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Router.html&quot;&gt;the router&lt;/a&gt; and for &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Route.html&quot;&gt;route handlers&lt;/a&gt;.</source>
          <target state="translated">동일한 이름으로 템플릿을 렌더링하는 것 이상의 경로를 만들려면 경로 처리기를 만들어야합니다. 다음 가이드는 다양한 경로 처리기 기능을 살펴 봅니다. 라우트에 대한 자세한 정보 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Router.html&quot;&gt;는 라우터&lt;/a&gt; 및 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Route.html&quot;&gt;라우트 핸들러에&lt;/a&gt; 대한 API 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="914b4488aebbaf7feacdaea87f6b86fabbc536b7" translate="yes" xml:space="preserve">
          <source>To have your route do something beyond render a template with the same name, you'll need to create a route handler. The following guides will explore the different features of route handlers. For more information on routes, see the API documentation for &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/EmberRouter&quot;&gt;the router&lt;/a&gt; and for &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Route&quot;&gt;route handlers&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9afb56800cc2c35a1d33a4613b349e4ff3b51493" translate="yes" xml:space="preserve">
          <source>To implement a serializer, export a class that conforms to the structure described by the &lt;a href=&quot;https://api.emberjs.com/ember-data/release/classes/MinimumSerializerInterface&quot;&gt;MinimumSerializerInterface&lt;/a&gt; from the &lt;code&gt;app/serializers/&lt;/code&gt; directory. An example is below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba8d875adbf72e3a77f820466038fcca4672c52f" translate="yes" xml:space="preserve">
          <source>To implement a skip link in an application, add an anchor element as close as possible after the opening &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; element, and have it link to the beginning of the page's main content area.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37017a8822c89a19516c602dcc48cbd220d1dbfb" translate="yes" xml:space="preserve">
          <source>To implement the &lt;code&gt;filter&lt;/code&gt; function to do the actual filter of rentals by city, we'll create a &lt;code&gt;rentals&lt;/code&gt; controller. &lt;a href=&quot;https://guides.emberjs.com/controllers/&quot;&gt;Controllers&lt;/a&gt; contain actions and properties available to the template of its corresponding route. In our case we want to generate a controller called &lt;code&gt;rentals&lt;/code&gt;. Ember will know that a controller with the name of &lt;code&gt;rentals&lt;/code&gt; will apply to the route with the same name.</source>
          <target state="translated">도시 별 실제 임대 &lt;code&gt;filter&lt;/code&gt; 를 수행하는 필터 기능 을 구현하기 위해 &lt;code&gt;rentals&lt;/code&gt; 컨트롤러를 만듭니다 . &lt;a href=&quot;https://guides.emberjs.com/controllers/&quot;&gt;컨트롤러&lt;/a&gt; 에는 해당 경로의 템플릿에 사용 가능한 작업 및 속성이 포함됩니다. 우리의 경우 &lt;code&gt;rentals&lt;/code&gt; 이라는 컨트롤러를 생성하려고합니다 . Ember는 &lt;code&gt;rentals&lt;/code&gt; 이름을 가진 컨트롤러가 동일한 이름을 가진 경로에 적용될 것임을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a18fa809ef2b226e508df95e115d1c7866fed2b" translate="yes" xml:space="preserve">
          <source>To implement the helper, we write a JavaScript function that takes its arguments as an &lt;em&gt;array&lt;/em&gt;. This is because helpers can also receive &lt;em&gt;named&lt;/em&gt; arguments, which we'll discuss next.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db39c8ec99de08b269bbe4798a73309f9f804b4b" translate="yes" xml:space="preserve">
          <source>To improve the network performance of your application, you can optimize your adapter by overriding these lower-level methods:</source>
          <target state="translated">응용 프로그램의 네트워크 성능을 향상시키기 위해 다음과 같은 하위 수준 방법을 재정 의하여 어댑터를 최적화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a1b8fc671a0891cd11cc8c038ed274d72de5dc3" translate="yes" xml:space="preserve">
          <source>To include jQuery in your Ember app and enable the jQuery integration APIs such as &lt;code&gt;this.$()&lt;/code&gt;, follow the instructions above to install &lt;code&gt;@ember/optional-features&lt;/code&gt;. Next, enable the feature:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45c60387f626fac146933d93ac9b0afdd5ae5762" translate="yes" xml:space="preserve">
          <source>To invoke it using angle bracket syntax, you would do the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cdcf89a4a448babacd6de864831466ba71fbff2" translate="yes" xml:space="preserve">
          <source>To iterate over a list of items, use the &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_each&quot;&gt;&lt;code&gt;{{#each}}&lt;/code&gt;&lt;/a&gt; helper. The first argument to this helper is the array to be iterated, and the value being iterated is yielded as a block param. Block params are only available inside the block of their helper.</source>
          <target state="translated">항목 목록을 반복하려면 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_each&quot;&gt; &lt;code&gt;{{#each}}&lt;/code&gt; &lt;/a&gt; 도우미를 사용하십시오. 이 헬퍼에 대한 첫 번째 인수는 반복 될 배열이며, 반복되는 값은 블록 매개 변수로 나타납니다. 블록 매개 변수는 도우미 블록 내에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37a8c0af98548e46e1f92597c00cca2ab2c7f773" translate="yes" xml:space="preserve">
          <source>To keep this guide concise, we built a separate site for &lt;a href=&quot;https://emberjs-1.gitbook.io/ember-component-patterns/&quot;&gt;component patterns in Ember&lt;/a&gt;. This project also addresses anti-patterns and accessibility for components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a88256a4a31be9bc45d51ea6053877423fd02664" translate="yes" xml:space="preserve">
          <source>To learn more about &lt;code&gt;aria&lt;/code&gt; roles and accessibility in Ember, check out the &lt;a href=&quot;https://guides.emberjs.com/reference/accessibility-guide/&quot;&gt;Accessibility Guide&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e19aea22e6a2837bc8ee95e58af45dcff1d5f81b" translate="yes" xml:space="preserve">
          <source>To learn more about options for testing, you can visit &lt;a href=&quot;https://ember-cli.com/testing&quot;&gt;Ember CLI Documentation&lt;/a&gt; or type &lt;code&gt;ember help test&lt;/code&gt; in the command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="495824f667e5b6c15d06332388e59af8ef8bc393" translate="yes" xml:space="preserve">
          <source>To learn more about the events Ember components use, see</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05f24d5f6782acbbef958bb70776badee1ad078d" translate="yes" xml:space="preserve">
          <source>To learn more about the events Ember components use, see &lt;a href=&quot;https://guides.emberjs.com/v2.6.0/components/handling-events/#toc_event-names&quot;&gt;components/handling-events&lt;/a&gt;.</source>
          <target state="translated">Ember 구성 요소가 사용하는 이벤트에 대한 자세한 내용은 &lt;a href=&quot;https://guides.emberjs.com/v2.6.0/components/handling-events/#toc_event-names&quot;&gt;components / handling-events를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="33fe7cdd3e4959aca8ceb9ad1340e73c0d1046f0" translate="yes" xml:space="preserve">
          <source>To learn more about the lang attribute and how to use it: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/lang&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/lang&lt;/a&gt;. Unsure which language subtag to use? Try &lt;a href=&quot;https://r12a.github.io/app-subtags/&quot;&gt;the Language Subtag Lookup tool&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1d4e80f03459d1f52f2363e1225daa9d4f187cf" translate="yes" xml:space="preserve">
          <source>To limit the test to validating only its own behavior and not the service, we'll take advantage of the registration API to register a stub maps service. That way when Ember injects the map service into the component, it uses our fake service instead of the real one.</source>
          <target state="translated">서비스가 아닌 자체 동작 만 검증하도록 테스트를 제한하기 위해 등록 API를 활용하여 스텁 맵 서비스를 등록합니다. 이렇게하면 Ember가 맵 서비스를 컴포넌트에 삽입 할 때 실제 서비스 대신 가짜 서비스를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="77755e062047f1b190e24cc4c004d477b633a1d4" translate="yes" xml:space="preserve">
          <source>To load a model for the &lt;code&gt;favorite-posts&lt;/code&gt; route, you would use the &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Route.html#method_model&quot;&gt;&lt;code&gt;model()&lt;/code&gt;&lt;/a&gt; hook in the &lt;code&gt;favorite-posts&lt;/code&gt; route handler:</source>
          <target state="translated">&lt;code&gt;favorite-posts&lt;/code&gt; 라우트에 대한 모델을로드하려면 &lt;code&gt;favorite-posts&lt;/code&gt; 라우트 핸들러 에서 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Route.html#method_model&quot;&gt; &lt;code&gt;model()&lt;/code&gt; &lt;/a&gt; 후크를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="cb784f4c7a7e45243b2ca051231756f4e509689e" translate="yes" xml:space="preserve">
          <source>To make that more concrete, let's take a look at two similar components representing different user's messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e87807c4d673ac108892ab383e4f9629d81be61" translate="yes" xml:space="preserve">
          <source>To make the most out of the guides, you should have a working knowledge of &lt;strong&gt;HTML, CSS, and JavaScript&lt;/strong&gt; - the building blocks of web pages. You can find out more about each of these technologies in the &lt;a href=&quot;working-with-html-css-and-javascript&quot;&gt;Working with HTML, CSS, and JavaScript&lt;/a&gt; guide, including some of the special features that Ember uses such as class fields and decorators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f654c2cf3da300af867e72e2bd26f7caf007cd2a" translate="yes" xml:space="preserve">
          <source>To make the most out of the guides, you should have a working knowledge of:</source>
          <target state="translated">가이드를 최대한 활용하려면 다음에 대한 실무 지식이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="e5b3fef2d40648db9d74e2b4390e982acb8c7ae7" translate="yes" xml:space="preserve">
          <source>To make this work, we will need to stop hard coding the number, and we will need to wire up the buttons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b48bbd7cf636ae4aa97041195d11824d502d201" translate="yes" xml:space="preserve">
          <source>To make those event handlers do something, we will need to define &lt;em&gt;actions&lt;/em&gt; in the component JavaScript. An action is a JavaScript method that can be used from a template.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0de715ec4bdc05fe56d9fee36be46b5f31b2be4" translate="yes" xml:space="preserve">
          <source>To make your own custom class enumerable, you need two items:</source>
          <target state="translated">자신 만의 커스텀 클래스를 열거 가능하게하려면 두 가지 항목이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="1c466dfb41d5e397019aa3e58144514a595ced70" translate="yes" xml:space="preserve">
          <source>To match multiple routes 'space-separate' the routes:</source>
          <target state="translated">여러 경로를 '공간 분리'하여 경로를 일치 시키려면 :</target>
        </trans-unit>
        <trans-unit id="13060a627addc391f25235a99ca3db1518034089" translate="yes" xml:space="preserve">
          <source>To measure components and templates that are rendered on initial application boot, click on the &quot;Reload&quot; button at the top. This button ensures that the Inspector starts measuring render times when your app boots.</source>
          <target state="translated">초기 응용 프로그램 부팅시 렌더링되는 구성 요소 및 템플릿을 측정하려면 상단의 &quot;재로드&quot;버튼을 클릭하십시오. 이 버튼을 사용하면 앱이 부팅 될 때 인스펙터가 렌더링 시간 측정을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="dc09e7ab0122ed1f10aad8febf2686e9ee8f8063" translate="yes" xml:space="preserve">
          <source>To normalize only a single model, you can use the &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.JSONAPISerializer.html#method_normalize&quot;&gt;&lt;code&gt;normalize()&lt;/code&gt;&lt;/a&gt; hook similarly.</source>
          <target state="translated">단일 모델 만 정규화하려면 normalize &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.JSONAPISerializer.html#method_normalize&quot;&gt; &lt;code&gt;normalize()&lt;/code&gt; &lt;/a&gt; 후크를 유사하게 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1cdccb6c958acd580a297a3496a9089227ce41f9" translate="yes" xml:space="preserve">
          <source>To normalize only a single model, you can use the &lt;a href=&quot;https://api.emberjs.com/ember-data/release/classes/JSONAPISerializer/methods#normalize&quot;&gt;&lt;code&gt;normalize()&lt;/code&gt;&lt;/a&gt; hook similarly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b36d9c0d96220aa91e734666c278c544e5c33712" translate="yes" xml:space="preserve">
          <source>To open the Inspector, click on the new bookmark. Safari blocks popups by default, so you'll need to enable popups before using the bookmarklet.</source>
          <target state="translated">인스펙터를 열려면 새 북마크를 클릭하십시오. Safari는 기본적으로 팝업을 차단하므로 책갈피를 사용하기 전에 팝업을 활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="e32951622e512a5e2dbbf6daeb91928456978164" translate="yes" xml:space="preserve">
          <source>To override this method with a custom one, make sure to call &lt;code&gt;return this._super(store, primaryModelClass, payload, id, requestType)&lt;/code&gt; with your pre-processed data.</source>
          <target state="translated">이 메소드를 사용자 정의 메소드로 대체하려면 사전 처리 된 데이터로 &lt;code&gt;return this._super(store, primaryModelClass, payload, id, requestType)&lt;/code&gt; 을 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="643424ccbff431db940e6db1682aad8fbb931a53" translate="yes" xml:space="preserve">
          <source>To override this option for your entire application, see &quot;Overriding Application-wide Defaults&quot;.</source>
          <target state="translated">전체 응용 프로그램에 대해이 옵션을 재정의하려면 &quot;응용 프로그램 전체 기본값 재정의&quot;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e7b7de1f5b2acd114aa92dfc71c79109066e6419" translate="yes" xml:space="preserve">
          <source>To pass multiple arguments to a helper, add them as a space-separated list after the helper name:</source>
          <target state="translated">도우미에 여러 인수를 전달하려면 도우미 이름 뒤에 공백으로 구분 된 목록으로 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="782db8348bb156313d7ba95741850dae22fcade0" translate="yes" xml:space="preserve">
          <source>To prevent Ember from setting up a listener for a default event, specify the event name with a &lt;code&gt;null&lt;/code&gt; value in the &lt;code&gt;customEvents&lt;/code&gt; property:</source>
          <target state="translated">Ember가 기본 이벤트에 대한 리스너를 설정하지 못하게하려면 &lt;code&gt;customEvents&lt;/code&gt; 특성 에 이벤트 이름을 &lt;code&gt;null&lt;/code&gt; 값으로 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="7ad2dcdf74eb53253ee43f5d7112c03d7ee0c5cc" translate="yes" xml:space="preserve">
          <source>To prevent default events from being listened to:</source>
          <target state="translated">기본 이벤트가 수신되지 않도록하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="d140dc02f52e1fafe21fbb1f3e0a87899ed55913" translate="yes" xml:space="preserve">
          <source>To prevent setting an attribute altogether, use &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; as the return value of the &lt;code&gt;attributeBindings&lt;/code&gt; monitored property:</source>
          <target state="translated">속성을 모두 설정하지 못하게하려면 &lt;code&gt;attributeBindings&lt;/code&gt; 모니터링 되는 속성 의 반환 값으로 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="73a02062b3e08887f288a9fd11ff79db2b0726ee" translate="yes" xml:space="preserve">
          <source>To prevent setting an attribute altogether, use &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; as the value of the property used in &lt;code&gt;attributeBindings&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88949b439b77da8a131b94c8c49c2264eabd59cf" translate="yes" xml:space="preserve">
          <source>To protect your application from cross-site scripting attacks (XSS), Ember automatically escapes any value you return from a helper so that the browser will not interpret it as HTML.</source>
          <target state="translated">XSS (Cross-Site Scripting Attack)로부터 응용 프로그램을 보호하기 위해 Ember는 브라우저에서 HTML로 해석하지 않도록 도우미에서 반환 한 값을 자동으로 이스케이프 처리합니다.</target>
        </trans-unit>
        <trans-unit id="410e671fa5ad1d60ce482717f4854a77655715ac" translate="yes" xml:space="preserve">
          <source>To provide a &lt;code&gt;firstName&lt;/code&gt; and &lt;code&gt;lastName&lt;/code&gt; to the above template, properties must be added to the application controller. If you are following along with an Ember CLI application, you may need to create this file:</source>
          <target state="translated">위의 템플릿에 &lt;code&gt;firstName&lt;/code&gt; 과 &lt;code&gt;lastName&lt;/code&gt; 을 제공하려면 응용 프로그램 컨트롤러에 속성을 추가해야합니다. Ember CLI 애플리케이션을 따라가는 경우이 파일을 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="29f27a0e8e02bfdfa170f1d9c3e3d514551a7d10" translate="yes" xml:space="preserve">
          <source>To push a record into the store, call the store's &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Store.html#method_push&quot;&gt;&lt;code&gt;push()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">상점으로 레코드를 푸시하려면 상점의 &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Store.html#method_push&quot;&gt; &lt;code&gt;push()&lt;/code&gt; &lt;/a&gt; 메소드를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="37becbf52e680e8079dbf9fd6ab0890843872f81" translate="yes" xml:space="preserve">
          <source>To push a record into the store, call the store's &lt;a href=&quot;https://api.emberjs.com/ember-data/release/classes/Store/methods#push&quot;&gt;&lt;code&gt;push()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bb00b92ec7eb5ae8ed0e4fc8df3e54dd14fd77c" translate="yes" xml:space="preserve">
          <source>To read more about skip links, visit the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Learn/Accessibility/HTML#Skip_links&quot;&gt;MDN docs&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a185e83c481228539f24bb1c09c6b0245f73852" translate="yes" xml:space="preserve">
          <source>To remove a &lt;code&gt;belongsTo&lt;/code&gt; relationship, we can set it to &lt;code&gt;null&lt;/code&gt;, which will also remove it from the &lt;code&gt;hasMany&lt;/code&gt; side:</source>
          <target state="translated">&lt;code&gt;belongsTo&lt;/code&gt; 관계 를 제거하기 위해 ,이를 &lt;code&gt;null&lt;/code&gt; 로 설정 하면 &lt;code&gt;hasMany&lt;/code&gt; 측에서도 제거됩니다 :</target>
        </trans-unit>
        <trans-unit id="432349a69d598accb34ee2c2bc3e7748a2394e9f" translate="yes" xml:space="preserve">
          <source>To remove an object from an enumerable, use the &lt;code&gt;removeObject()&lt;/code&gt; method. This will only remove the object if it is present in the enumerable, otherwise this method has no effect.</source>
          <target state="translated">열거 가능 객체에서 객체를 제거하려면 &lt;code&gt;removeObject()&lt;/code&gt; 메서드를 사용하십시오 . 열거 형에 개체가있는 경우에만 개체를 ​​제거합니다. 그렇지 않으면이 방법이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7d9de26d22f9d5fddcc6b008df4be9a302d40e54" translate="yes" xml:space="preserve">
          <source>To represent the children as IDs:</source>
          <target state="translated">자녀를 ID로 나타내려면</target>
        </trans-unit>
        <trans-unit id="96baf3260095c6e999a09f07d2439de39521a921" translate="yes" xml:space="preserve">
          <source>To represent the children relationship as a URL:</source>
          <target state="translated">하위 관계를 URL로 표시하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="61b2e6985c9d49eab39fc6b2473ca71648f4f595" translate="yes" xml:space="preserve">
          <source>To run a subset of your tests by title use the &lt;code&gt;--filter&lt;/code&gt; option. Quickly test your current work &lt;code&gt;ember test --filter=&quot;dashboard&quot;&lt;/code&gt;, or only run a certain type of test &lt;code&gt;ember test --filter=&quot;integration&quot;&lt;/code&gt;. When using QUnit it is possible to exclude tests by adding an exclamation point to the beginning of the filter &lt;code&gt;ember test --filter=&quot;!acceptance&quot;&lt;/code&gt;.</source>
          <target state="translated">제목별로 테스트의 하위 세트를 실행하려면 &lt;code&gt;--filter&lt;/code&gt; 옵션을 사용하십시오 . 현재 작업 &lt;code&gt;ember test --filter=&quot;dashboard&quot;&lt;/code&gt; 빠르게 테스트 하거나 특정 유형의 테스트 &lt;code&gt;ember test --filter=&quot;integration&quot;&lt;/code&gt; 만 실행하십시오 . QUnit을 사용할 때 필터 &lt;code&gt;ember test --filter=&quot;!acceptance&quot;&lt;/code&gt; 의 시작 부분에 느낌표를 추가하여 테스트를 제외 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1886972c9e7e9a4f558bbcd67fc568ef5594acf6" translate="yes" xml:space="preserve">
          <source>To see a list of libraries used in your application, click on the &lt;code&gt;Info&lt;/code&gt; menu. This view displays the libraries used, along with their version.</source>
          <target state="translated">응용 프로그램에 사용 된 라이브러리 목록을 보려면 &lt;code&gt;Info&lt;/code&gt; 메뉴를 클릭하십시오 . 이보기에는 사용 된 라이브러리와 버전이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="bd3f95548b425d3595dc1e5a7a281f78a35f8f4c" translate="yes" xml:space="preserve">
          <source>To see how a template was rendered by Ember, click on the template in the View Tree. If you're using Chrome or Firefox, you'll be sent to the Elements panel with that DOM element selected.</source>
          <target state="translated">Ember가 템플릿을 렌더링 한 방법을 보려면 뷰 트리에서 템플릿을 클릭하십시오. Chrome 또는 Firefox를 사용하는 경우 해당 DOM 요소가 선택된 요소 패널로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="e44b68c60f76b61bbdf60c921597a9cf8aad1469" translate="yes" xml:space="preserve">
          <source>To see the full list of computed property macros, have a look at &lt;a href=&quot;http://emberjs.com/api/classes/Ember.computed.html&quot;&gt;the API documentation&lt;/a&gt;</source>
          <target state="translated">계산 된 속성 매크로의 전체 목록을 보려면 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.computed.html&quot;&gt;API 설명서를&lt;/a&gt; 살펴보십시오</target>
        </trans-unit>
        <trans-unit id="44dfd079527ff92f76f15c9e2233ee33c127f0bf" translate="yes" xml:space="preserve">
          <source>To see the power of QUnit DOM, consider this code snippet. It checks whether our button component shows the right label and the right attributes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64c967ef9e903d9ceb1995e5404c8ab3a7e41b10" translate="yes" xml:space="preserve">
          <source>To see which optional features are available, you can run the following command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10d1aa4aa9fe506d80116cddb13e609d02185dad" translate="yes" xml:space="preserve">
          <source>To set the component up to receive parameters this way, you need to set the &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Component.html#property_positionalParams&quot;&gt;&lt;code&gt;positionalParams&lt;/code&gt;&lt;/a&gt; attribute in your component class.</source>
          <target state="translated">이러한 방식으로 구성 요소가 매개 변수를 받도록 설정하려면 구성 요소 클래스에서 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Component.html#property_positionalParams&quot;&gt; &lt;code&gt;positionalParams&lt;/code&gt; &lt;/a&gt; 특성 을 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="844e0103c86e1064d969400e55f8cbd4212c42ec" translate="yes" xml:space="preserve">
          <source>To set up embedded records, include the mixin when extending a serializer then define and configure embedded relationships.</source>
          <target state="translated">임베디드 레코드를 설정하려면 직렬 변환기를 확장 할 때 믹스 인을 포함시킨 후 임베디드 관계를 정의하고 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="7823165518baac275622086e0a64947c8412aa36" translate="yes" xml:space="preserve">
          <source>To set up embedded records, include the mixin when extending a serializer, then define and configure embedded (model) relationships.</source>
          <target state="translated">임베디드 레코드를 설정하려면 직렬 변환기를 확장 할 때 믹스 인을 포함시킨 후 임베디드 (모델) 관계를 정의하고 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="04b6c1283408d9d9cea206ac24ad417174a73fb9" translate="yes" xml:space="preserve">
          <source>To show an error from the server related to the &lt;code&gt;title&lt;/code&gt; and &lt;code&gt;content&lt;/code&gt; properties your adapter could return a promise that rejects with a &lt;code&gt;DS.InvalidError&lt;/code&gt; object that looks like this:</source>
          <target state="translated">&lt;code&gt;title&lt;/code&gt; 및 &lt;code&gt;content&lt;/code&gt; 특성 과 관련된 서버의 오류를 표시하기 위해 어댑터는 다음과 같은 &lt;code&gt;DS.InvalidError&lt;/code&gt; 오브젝트로 거부되는 약속을 리턴 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5de09f992e282286fbce2df4cdb2170153b10b38" translate="yes" xml:space="preserve">
          <source>To show an error from the server related to the &lt;code&gt;title&lt;/code&gt; and &lt;code&gt;content&lt;/code&gt; properties your adapter could return a promise that rejects with a &lt;code&gt;InvalidError&lt;/code&gt; object that looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d22fb46ffa697dab0c28d5708fe886c943fb273" translate="yes" xml:space="preserve">
          <source>To show something on every page, we can use the application template (which we edited earlier). Let's open it again (&lt;code&gt;/app/templates/application.hbs&lt;/code&gt;) and replace its contents with the following:</source>
          <target state="translated">모든 페이지에 무언가를 보여주기 위해, 우리는 이전에 편집 한 응용 프로그램 템플릿을 사용할 수 있습니다. 다시 열고 ( &lt;code&gt;/app/templates/application.hbs&lt;/code&gt; ) 내용을 다음과 같이 바꾸자 :</target>
        </trans-unit>
        <trans-unit id="ce4f53072b200771a6bd1a485f9c6358e79dc97f" translate="yes" xml:space="preserve">
          <source>To show the basic setup of an Ember application, we'll walk through building an app for a property rental site called Super Rentals. We'll start with a homepage, an about page and a contact page.</source>
          <target state="translated">Ember 애플리케이션의 기본 설정을 보여주기 위해 Super Rentals라는 부동산 임대 사이트 용 앱을 작성하는 과정을 안내합니다. 홈페이지, 정보 페이지 및 연락처 페이지로 시작하겠습니다.</target>
        </trans-unit>
        <trans-unit id="393642dc2786c94991716cb91c7abd6d69b2c10b" translate="yes" xml:space="preserve">
          <source>To solve this problem, or maybe to cross-link comments from photos other than the currently active one, you can pass an array of model objects using the &lt;code&gt;@models&lt;/code&gt; argument and the &lt;code&gt;{{array}}&lt;/code&gt; helper:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c27517c0e2be0e963976ab64dbcdf375c7c6419" translate="yes" xml:space="preserve">
          <source>To specify that a parameter is mutable, when invoking the child &lt;code&gt;Component&lt;/code&gt;:</source>
          <target state="translated">하위 &lt;code&gt;Component&lt;/code&gt; 를 호출 할 때 매개 변수를 변경할 수 있도록 지정하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="9e5e44d1e323523fd04fa6c63b5e27609319bbd8" translate="yes" xml:space="preserve">
          <source>To start, here's an example of returning a simple array from the &lt;code&gt;model&lt;/code&gt; hook. Even if we eventually plan to fetch this data over a network, starting with something simple makes initial development of a new route quick and easy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ca79710a45c8aed09d51d44e598c3593126facf" translate="yes" xml:space="preserve">
          <source>To stub the location service in your test, create a local stub object that extends &lt;code&gt;Ember.Service&lt;/code&gt;, and register the stub as the service your tests need in the beforeEach function. In this case we initially force location to New York.</source>
          <target state="translated">테스트에서 위치 서비스를 스텁하려면 &lt;code&gt;Ember.Service&lt;/code&gt; 를 확장하는 로컬 스텁 오브젝트를 작성하고 테스트가 beforeEach 함수에서 필요한 서비스로 스텁을 등록하십시오. 이 경우 처음에 위치를 뉴욕으로 강제합니다.</target>
        </trans-unit>
        <trans-unit id="e616fccd7436f63f17fdce0168c842b758d82ca3" translate="yes" xml:space="preserve">
          <source>To stub the location service in your test, create a local stub object that extends &lt;code&gt;Service&lt;/code&gt; from &lt;code&gt;@ember/service&lt;/code&gt;, and register the stub as the service your tests need in the beforeEach function. In this case we initially force location to &quot;New York&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9098d98f5bd71ee073118d2cf99cd0bc1bee3928" translate="yes" xml:space="preserve">
          <source>To style the application, copy the following CSS into &lt;code&gt;app/styles/app.css&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83c3a034dda372c47a7e55506b94a499dd11f2f5" translate="yes" xml:space="preserve">
          <source>To successfully extract and serialize embedded records the model relationships must be setup correcty. See the &lt;a href=&quot;https://emberjs.com/guides/models/defining-models/#toc_defining-relationships&quot;&gt;defining relationships&lt;/a&gt; section of the &lt;strong&gt;Defining Models&lt;/strong&gt; guide page.</source>
          <target state="translated">임베드 된 레코드를 추출하고 직렬화하려면 모델 관계를 올바르게 설정해야합니다. 참고 항목 &lt;a href=&quot;https://emberjs.com/guides/models/defining-models/#toc_defining-relationships&quot;&gt;정의 관계&lt;/a&gt; 의 섹션 &lt;strong&gt;정의 모델&lt;/strong&gt; 가이드 페이지를.</target>
        </trans-unit>
        <trans-unit id="5761ba208af86e2cfca0cbd986b96597bbcbe5f9" translate="yes" xml:space="preserve">
          <source>To sum it up, the new mental model is that the &quot;wrapping&quot; element is just like any other element in your template, and you interact with it in exactly the same way. This means that when converting a classic component, you will need to add the wrapping element that was there previously to the template (unless it was a tagless component, e.g. &lt;code&gt;tagName: ''&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6f5b7a5feba70d7bbd8e7ea599c7843b8360f83" translate="yes" xml:space="preserve">
          <source>To support &lt;code&gt;Ember.Array&lt;/code&gt; in your own class, you must override two primitives to use it: &lt;code&gt;length()&lt;/code&gt; and &lt;code&gt;objectAt()&lt;/code&gt;.</source>
          <target state="translated">자신의 클래스에서 &lt;code&gt;Ember.Array&lt;/code&gt; 를 지원하려면 &lt;code&gt;length()&lt;/code&gt; 와 &lt;code&gt;objectAt()&lt;/code&gt; 두 가지 기본 요소를 재정의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="abb5441db3b24bf9c5e1a7d877b0758ccc2bf085" translate="yes" xml:space="preserve">
          <source>To support &lt;code&gt;EmberArray&lt;/code&gt; in your own class, you must override two primitives to use it: &lt;code&gt;length()&lt;/code&gt; and &lt;code&gt;objectAt()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="284156262ec009225218096a34db99fe111eef94" translate="yes" xml:space="preserve">
          <source>To tell the application which rental we want to access, we need to replace the &lt;code&gt;show&lt;/code&gt; route path with the ID of the rental listing. We also want to simplify the URL so that it looks more like this: &lt;code&gt;localhost:4200/rentals/id-for-rental&lt;/code&gt;.</source>
          <target state="translated">애플리케이션에 액세스하려는 임대를 알려주려면 &lt;code&gt;show&lt;/code&gt; 경로 경로를 임대 목록의 ID 로 바꿔야합니다 . 또한 &lt;code&gt;localhost:4200/rentals/id-for-rental&lt;/code&gt; 과 같이 URL을 단순화하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="94da23cc0d21ccaeb4d36e6224841c46fd4046cc" translate="yes" xml:space="preserve">
          <source>To test a feature you MUST be using a canary build. Canary builds are published to &lt;code&gt;npm&lt;/code&gt; and can be installed using a precise tag (such as &lt;code&gt;ember-data@3.16.0-alpha.1&lt;/code&gt;) or by installing the latest dist-tag published to the &lt;code&gt;canary&lt;/code&gt; channel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb8bdc2ee12cbad5bed5fddb2deaabca492791bd" translate="yes" xml:space="preserve">
          <source>To test it, we create an instance of our class &lt;code&gt;SomeThing&lt;/code&gt; as defined above, call the &lt;code&gt;testMethod&lt;/code&gt; method and assert that the internal state is correct as a result of the method call.</source>
          <target state="translated">이를 테스트하기 위해 위에서 정의 &lt;code&gt;SomeThing&lt;/code&gt; 클래스의 인스턴스를 작성 하고 &lt;code&gt;testMethod&lt;/code&gt; 메소드를 호출 한 후 메소드 호출의 결과로 내부 상태가 올바른지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="5469506e055e796f8450fa42672d0e80ba255641" translate="yes" xml:space="preserve">
          <source>To trace a Promise, click on the &lt;code&gt;Trace&lt;/code&gt; button next to the label, which will send the Promise stack trace to the console.</source>
          <target state="translated">Promise를 추적하려면 레이블 옆 에있는 &lt;code&gt;Trace&lt;/code&gt; 버튼을 클릭 하면 Promise 스택 추적이 콘솔로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="81efb30747bfc7cc6e140692ae70701b93384146" translate="yes" xml:space="preserve">
          <source>To trigger this event:</source>
          <target state="translated">이 이벤트를 트리거하려면</target>
        </trans-unit>
        <trans-unit id="2bcedd4c9e4a623cc510a72ad9fb73f9dac4c3f9" translate="yes" xml:space="preserve">
          <source>To try them out, do the following steps:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48d77718e1db6d457932cf1dfee14241b04544bc" translate="yes" xml:space="preserve">
          <source>To use a tag other than &lt;code&gt;div&lt;/code&gt;, subclass &lt;code&gt;Ember.Component&lt;/code&gt; and assign it a &lt;code&gt;tagName&lt;/code&gt; property. This property can be any valid HTML5 tag name as a string.</source>
          <target state="translated">&lt;code&gt;div&lt;/code&gt; 이외의 태그를 사용하려면 &lt;code&gt;Ember.Component&lt;/code&gt; 를 서브 클래스로 만들고 &lt;code&gt;tagName&lt;/code&gt; 속성을 지정하십시오 . 이 속성은 문자열로 유효한 HTML5 태그 이름이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a10e85d71bb02f30ffa65660d976a2614878268" translate="yes" xml:space="preserve">
          <source>To use it in your application you will need to define a &lt;code&gt;serializer:application&lt;/code&gt; that extends the &lt;code&gt;JSONSerializer&lt;/code&gt;.</source>
          <target state="translated">애플리케이션에서 사용하려면 &lt;code&gt;JSONSerializer&lt;/code&gt; 를 확장 하는 &lt;code&gt;serializer:application&lt;/code&gt; 을 정의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3ac55d23e3de772ab700ee1e89d91af6e27bd4d1" translate="yes" xml:space="preserve">
          <source>To use it, pass the conditional value to the &lt;code&gt;if&lt;/code&gt; helper, using the block form to wrap the section of template you want to conditionally render. Like so:</source>
          <target state="translated">이를 사용하려면 조건부로 렌더링하려는 템플리트의 섹션을 랩 양식으로 랩핑하여 조건부 값을 &lt;code&gt;if&lt;/code&gt; 헬퍼에 전달하십시오 . 이렇게 :</target>
        </trans-unit>
        <trans-unit id="d4ed92f3e127472a3aa889d5c0b4781b9d9a78db" translate="yes" xml:space="preserve">
          <source>To use our new Ember Data Model object, we need to update the &lt;code&gt;model&lt;/code&gt; function we &lt;a href=&quot;../model-hook&quot;&gt;previously defined&lt;/a&gt; in our route handler. Delete the hard-coded JavaScript Array, and replace it with the following call to the &lt;a href=&quot;https://guides.emberjs.com/models/#toc_the-store-and-a-single-source-of-truth&quot;&gt;Ember Data Store service&lt;/a&gt;. The &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Store.html&quot;&gt;store service&lt;/a&gt; is injected into all routes and components in Ember. It is the main interface you use to interact with Ember Data. In this case, call the &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Store.html#method_findAll&quot;&gt;&lt;code&gt;findAll&lt;/code&gt;&lt;/a&gt; function on the store and provide it with the name of your newly created rental model class.</source>
          <target state="translated">새로운 Ember Data Model 객체를 사용하려면 &lt;a href=&quot;../model-hook&quot;&gt;이전&lt;/a&gt; 에 경로 핸들러에서 정의한 &lt;code&gt;model&lt;/code&gt; 함수 를 업데이트해야 합니다. 하드 코딩 된 JavaScript 배열을 삭제하고 &lt;a href=&quot;https://guides.emberjs.com/models/#toc_the-store-and-a-single-source-of-truth&quot;&gt;Ember Data Store 서비스에&lt;/a&gt; 대한 다음 호출로 바꿉니다 . &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Store.html&quot;&gt;저장소 서비스는&lt;/a&gt; 엠버의 모든 경로와 구성 요소로 주입된다. Ember Data와 상호 작용하는 데 사용하는 기본 인터페이스입니다. 이 경우 상점 에서 &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Store.html#method_findAll&quot;&gt; &lt;code&gt;findAll&lt;/code&gt; &lt;/a&gt; 함수를 호출하고 새로 작성된 임대 모델 클래스의 이름을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="a1bd3b7a10987c576e4b3e5ef0d1eb55854bd669" translate="yes" xml:space="preserve">
          <source>To use the &lt;code&gt;format-currency&lt;/code&gt; helper, you call it using curly braces in your template:</source>
          <target state="translated">서식 &lt;code&gt;format-currency&lt;/code&gt; 도우미 를 사용하려면 템플릿에서 중괄호를 사용하여 호출합니다.</target>
        </trans-unit>
        <trans-unit id="ff265ce4f656a5022fc0eb3e3b6a48bcf6f66b72" translate="yes" xml:space="preserve">
          <source>To use the &lt;code&gt;meta&lt;/code&gt; data outside of the &lt;code&gt;model&lt;/code&gt; hook, you need to return it:</source>
          <target state="translated">&lt;code&gt;model&lt;/code&gt; 후크 외부 에서 &lt;code&gt;meta&lt;/code&gt; 데이터 를 사용하려면 메타 데이터 를 리턴해야합니다.</target>
        </trans-unit>
        <trans-unit id="6c97e84d6c7f8dbcc0f576804dd9a172f8ea4443" translate="yes" xml:space="preserve">
          <source>To use the Inspector with the &lt;code&gt;file://&lt;/code&gt; protocol, visit &lt;code&gt;chrome://extensions&lt;/code&gt; in Chrome and check the &quot;Allow access to file URLs&quot; checkbox:</source>
          <target state="translated">Inspector를 &lt;code&gt;file://&lt;/code&gt; 프로토콜 과 함께 사용하려면 Chrome에서 &lt;code&gt;chrome://extensions&lt;/code&gt; 를 방문 하여 &quot;파일 URL에 대한 액세스 허용&quot;확인란을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="5b4b9b0f7d1081e76bebbad8d407bc61b550eeac" translate="yes" xml:space="preserve">
          <source>To use the block form, add a &lt;code&gt;#&lt;/code&gt; character to the beginning of the component name, then make sure to add a closing tag.</source>
          <target state="translated">블록 형식을 사용하려면 구성 요소 이름의 시작 부분에 &lt;code&gt;#&lt;/code&gt; 문자를 추가 한 다음 닫는 태그를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="2b34f2fce983b8f7e66aeba0dcd54687c1641fe4" translate="yes" xml:space="preserve">
          <source>To use url building, include the mixin when extending an adapter, and call &lt;code&gt;buildURL&lt;/code&gt; where needed. The default behaviour is designed for RESTAdapter.</source>
          <target state="translated">URL 작성을 사용하려면 어댑터를 확장 할 때 믹스 인을 포함시키고 필요한 경우 &lt;code&gt;buildURL&lt;/code&gt; 을 호출 하십시오 . 기본 작동은 RESTAdapter를 위해 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="b06bc5d392cd3c4ae056891cbe7f6e4fea87f456" translate="yes" xml:space="preserve">
          <source>To utilize an &lt;code&gt;event&lt;/code&gt; object as a function parameter:</source>
          <target state="translated">&lt;code&gt;event&lt;/code&gt; 객체를 함수 매개 변수로 활용하려면 :</target>
        </trans-unit>
        <trans-unit id="c8e7168cd76584331b5822b4bec75e170927b9af" translate="yes" xml:space="preserve">
          <source>To verify that your installation was successful, run:</source>
          <target state="translated">성공적으로 설치되었는지 확인하려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="4c45291da01a2d21f8e4e871bb2b3b252689cfbd" translate="yes" xml:space="preserve">
          <source>To view the list of deprecations in an app, click on the &lt;code&gt;Deprecations&lt;/code&gt; menu.</source>
          <target state="translated">앱에서 지원 중단 목록을 보려면 지원 &lt;code&gt;Deprecations&lt;/code&gt; 메뉴를 클릭하십시오 .</target>
        </trans-unit>
        <trans-unit id="bc6b3697807941cf644d0c3ddef26bebd3c914d3" translate="yes" xml:space="preserve">
          <source>Together, the &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;id&lt;/code&gt; properties form a composite key for the identity map.</source>
          <target state="translated">이와 함께 &lt;code&gt;type&lt;/code&gt; 및 &lt;code&gt;id&lt;/code&gt; 속성은 신원지도에 대한 복합 키를 형성한다.</target>
        </trans-unit>
        <trans-unit id="d56de7b370288540849e6b1f840001a93d377139" translate="yes" xml:space="preserve">
          <source>Tomster says...</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="212af41073666530ad8bf245becce259a0964242" translate="yes" xml:space="preserve">
          <source>Toolbar</source>
          <target state="translated">Toolbar</target>
        </trans-unit>
        <trans-unit id="f9ed2d73afa9c116adcb8e39bc914e28acd8bed9" translate="yes" xml:space="preserve">
          <source>Topics in the &lt;a href=&quot;https://ember-learn.github.io/ember-octane-vs-classic-cheat-sheet/&quot;&gt;cheat sheet&lt;/a&gt; include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c201b38fdebbb9bb45b78e75ce5a39c7cd55dd3a" translate="yes" xml:space="preserve">
          <source>Total number of errors.</source>
          <target state="translated">총 오류 수</target>
        </trans-unit>
        <trans-unit id="feca6ac147fe6946560ac4f3352301d8cb402e31" translate="yes" xml:space="preserve">
          <source>Touch events:</source>
          <target state="translated">터치 이벤트 :</target>
        </trans-unit>
        <trans-unit id="68c508431455ff22684105af9cb2ecc131f7e321" translate="yes" xml:space="preserve">
          <source>Tracing</source>
          <target state="translated">Tracing</target>
        </trans-unit>
        <trans-unit id="62aa935fa553c399eb205ec038f54040176e41b4" translate="yes" xml:space="preserve">
          <source>Tracked Properties</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36dadccfbf6b0a562e3d2d31c8194949fce9d447" translate="yes" xml:space="preserve">
          <source>Tracked Properties in Custom Classes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6ec23565c8db5fcd7f5868497b3f514f9b037e2" translate="yes" xml:space="preserve">
          <source>Tracked properties are fully backwards compatible with computed properties and &lt;code&gt;get&lt;/code&gt;/&lt;code&gt;set&lt;/code&gt;. Computed properties can depend on tracked properties like any other dependency:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0de365a3324ea771edb043edf9fc43d7465591b4" translate="yes" xml:space="preserve">
          <source>Tracked properties can also be applied to your own custom classes, and used within your components and routes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed56cadc9ca1726b0fcb5052461fc8a8057508ba" translate="yes" xml:space="preserve">
          <source>Tracked properties can be updated like any other property, using standard JavaScript syntax. For instance, we could update a tracked property via an action, as in this example component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="338f7f75821dd5e87c99535dfd8c4169066c6d13" translate="yes" xml:space="preserve">
          <source>Tracked properties have subtler benefits as well:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="792ac62324ec24646a9d1e12b4446100b04a3de6" translate="yes" xml:space="preserve">
          <source>Tracked properties replace computed properties. Unlike computed properties, which require you to annotate every getter with the values it depends on, tracked properties only require you to annotate the values that are &lt;em&gt;trackable&lt;/em&gt;, that is values that:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5271bbbae154f516a424da7d054f458ac3e263e5" translate="yes" xml:space="preserve">
          <source>Tracked vs Computed Properties</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="417871b118006bea50a751b23725ff8029ea56b2" translate="yes" xml:space="preserve">
          <source>Tracking Through Methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dea51bb13a4467c505ee6181171375f497334d54" translate="yes" xml:space="preserve">
          <source>Transform</source>
          <target state="translated">Transform</target>
        </trans-unit>
        <trans-unit id="0cef4df4d340703594fc301669e90430e959441b" translate="yes" xml:space="preserve">
          <source>Transforms</source>
          <target state="translated">Transforms</target>
        </trans-unit>
        <trans-unit id="ee9a7401cfdf77cbfcfa276345967663f2ed541e" translate="yes" xml:space="preserve">
          <source>Transforms are not required. If you do not specify a transform name Ember Data will do no additional processing of the value.</source>
          <target state="translated">변환이 필요하지 않습니다. 변환 이름을 지정하지 않으면 Ember Data는 값을 추가로 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4ead496f48fa5f6d2d96f52143b2d7c60b4140d3" translate="yes" xml:space="preserve">
          <source>Transition</source>
          <target state="translated">Transition</target>
        </trans-unit>
        <trans-unit id="3a38dd0e80493ddad0a8b9fc31e36c252b5d7258" translate="yes" xml:space="preserve">
          <source>Transition Plans</source>
          <target state="translated">전환 계획</target>
        </trans-unit>
        <trans-unit id="58d6d64ea8820023309981d51b607f7cb4f0da7e" translate="yes" xml:space="preserve">
          <source>Transition into another route while replacing the current URL, if possible. The route may be either a single route or route path:</source>
          <target state="translated">가능한 경우 현재 URL을 바꾸면서 다른 경로로 전환하십시오. 경로는 단일 경로 또는 경로 경로 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc1b0e501d34e708fc9cc731a2b3c2033acc8b08" translate="yes" xml:space="preserve">
          <source>Transition into another route while replacing the current URL, if possible. This will replace the current history entry instead of adding a new one. Beside that, it is identical to &lt;code&gt;transitionTo&lt;/code&gt; in all other respects. See 'transitionTo' for additional information regarding multiple models.</source>
          <target state="translated">가능한 경우 현재 URL을 바꾸면서 다른 경로로 전환하십시오. 새 항목을 추가하지 않고 현재 기록 항목을 대체합니다. 그 외에도 다른 모든 점에서 &lt;code&gt;transitionTo&lt;/code&gt; 와 동일 합니다. 여러 모델에 대한 추가 정보는 'transitionTo'를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3817345cd736105fd19da678c761e0ee0dc1d3d6" translate="yes" xml:space="preserve">
          <source>Transition into another route while replacing the current URL, if possible. This will replace the current history entry instead of adding a new one. Beside that, it is identical to &lt;code&gt;transitionToRoute&lt;/code&gt; in all other respects.</source>
          <target state="translated">가능한 경우 현재 URL을 바꾸면서 다른 경로로 전환하십시오. 새 항목을 추가하지 않고 현재 기록 항목을 대체합니다. 그 외에는 다른 모든 측면에서 &lt;code&gt;transitionToRoute&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="f9fbe2b3f5c5cd05ac457782cac8426ace4067da" translate="yes" xml:space="preserve">
          <source>Transition the application into another route. The route may be either a single route or route path:</source>
          <target state="translated">응용 프로그램을 다른 경로로 전환하십시오. 경로는 단일 경로 또는 경로 경로 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="09485928bf975e30a09112e580ae8b87390ef25d" translate="yes" xml:space="preserve">
          <source>Transition to a nested route</source>
          <target state="translated">내포 된 경로로 전환</target>
        </trans-unit>
        <trans-unit id="2e8d1954c6e263dec2af78024bacfdd651c85cb4" translate="yes" xml:space="preserve">
          <source>Transitioning After the Model is Known</source>
          <target state="translated">모델을 알고 난 후 전환</target>
        </trans-unit>
        <trans-unit id="8eeb89d7f7b67faed7cc1a366a765420b6ef9289" translate="yes" xml:space="preserve">
          <source>Transitioning Before the Model is Known</source>
          <target state="translated">모델을 알기 전에 전환</target>
        </trans-unit>
        <trans-unit id="3f2c8e69cd8ba2d1f715431bd113f96337919877" translate="yes" xml:space="preserve">
          <source>Transitioning Between Routes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04eb77e03c3f23bf5e6e18ba4df0da5cd5f31776" translate="yes" xml:space="preserve">
          <source>Transitions are aborted and their promises rejected when redirects occur; this method returns a promise that will follow any redirects that occur and fulfill with the value fulfilled by any redirecting transitions that occur.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b867dfc8d8f207f8f4c1fbcb4af23d1d9288622d" translate="yes" xml:space="preserve">
          <source>Transpile</source>
          <target state="translated">Transpile</target>
        </trans-unit>
        <trans-unit id="7be9134d32caa15cd71ab9ecd34dc5705a1ebaf0" translate="yes" xml:space="preserve">
          <source>Treating a function like a property is useful because they can work with bindings, just like any other property.</source>
          <target state="translated">함수를 속성처럼 취급하는 것은 다른 속성과 마찬가지로 바인딩으로 작업 할 수 있기 때문에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="6b82a6a604ce871413a50334f0f8ba973ba15b4b" translate="yes" xml:space="preserve">
          <source>Trigger the function on the leading instead of the trailing edge of the wait interval. Defaults to false.</source>
          <target state="translated">대기 간격의 후행 가장자리 대신 리딩에서 함수를 트리거합니다. 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="6bd621dbfc252949948e1fe15e02e3b79027c1b3" translate="yes" xml:space="preserve">
          <source>Trigger the function on the leading instead of the trailing edge of the wait interval. Defaults to true.</source>
          <target state="translated">대기 간격의 후행 가장자리 대신 리딩에서 함수를 트리거합니다. 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="a2759c77b24ab94668e8d1b8b501df3aeb5de2d0" translate="yes" xml:space="preserve">
          <source>Triggering Changes with Actions</source>
          <target state="translated">동작으로 변경 트리거</target>
        </trans-unit>
        <trans-unit id="edfa1c6872dd277eb5731ab22fc55770b3601c4a" translate="yes" xml:space="preserve">
          <source>Triggering an update like this will cause any getters that used the &lt;code&gt;_cache&lt;/code&gt; to recalculate. Note that we can use the &lt;code&gt;get&lt;/code&gt; method to access the cache, and it will still push the &lt;code&gt;_cache&lt;/code&gt; tracked property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73a3d9bc198a238e77a9c030c52dc7b578779d72" translate="yes" xml:space="preserve">
          <source>Triggering an update like this will cause any getters that used the &lt;code&gt;cache&lt;/code&gt; to recalculate. Note that we can use the &lt;code&gt;get&lt;/code&gt; method to access the cache, and it will still push the &lt;code&gt;_cache&lt;/code&gt; tracked property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05c0c58fbbc9f0cf9c0bb880afe8c0b49d825dcd" translate="yes" xml:space="preserve">
          <source>Triggers a fetch for the backing entity based on its &lt;code&gt;remoteType&lt;/code&gt; (see &lt;code&gt;remoteType&lt;/code&gt; definitions per reference type).</source>
          <target state="translated">&lt;code&gt;remoteType&lt;/code&gt; 을 기준으로 백업 엔티티의 페치를 트리거합니다 (참조 &lt;code&gt;remoteType&lt;/code&gt; 정의 참조).</target>
        </trans-unit>
        <trans-unit id="1f7ec6fd588f66e0f74bc20fe04496819936427e" translate="yes" xml:space="preserve">
          <source>Triggers a named action on the &lt;code&gt;ActionHandler&lt;/code&gt;. Any parameters supplied after the &lt;code&gt;actionName&lt;/code&gt; string will be passed as arguments to the action target function.</source>
          <target state="translated">&lt;code&gt;ActionHandler&lt;/code&gt; 에서 이름 지정된 조치를 트리거합니다 . &lt;code&gt;actionName&lt;/code&gt; 문자열 다음에 제공된 모든 매개 변수 는 조치 대상 함수에 인수로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="caf81df837a77ea1a1597867231d2fd92f696d66" translate="yes" xml:space="preserve">
          <source>Triggers a named event for the object. Any additional arguments will be passed as parameters to the functions that are subscribed to the event.</source>
          <target state="translated">객체의 명명 된 이벤트를 트리거합니다. 추가 인수는 이벤트를 구독하는 함수에 매개 변수로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="b37a90c35c25e5423f4922a95a3be6ba46a762f1" translate="yes" xml:space="preserve">
          <source>Triggers a reload of the value in this relationship. If the remoteType is &lt;code&gt;&quot;link&quot;&lt;/code&gt; Ember Data will use the relationship link to reload the relationship. Otherwise it will reload the record by its id.</source>
          <target state="translated">이 관계에서 값의 재로드를 트리거합니다. remoteType이 &lt;code&gt;&quot;link&quot;&lt;/code&gt; 인 경우 Ember Data는 관계 링크를 사용하여 관계를 다시로드합니다. 그렇지 않으면 ID로 레코드를 다시로드합니다.</target>
        </trans-unit>
        <trans-unit id="90ab4ebeae51b5fd454cba0691dd4c85d5df4631" translate="yes" xml:space="preserve">
          <source>Triggers the given DOM event on the element identified by the provided selector. Example:</source>
          <target state="translated">제공된 선택기로 식별 된 요소에서 지정된 DOM 이벤트를 트리거합니다. 예:</target>
        </trans-unit>
        <trans-unit id="b3c7ae9f5129772a579c1a689085b260b5f7a672" translate="yes" xml:space="preserve">
          <source>Triggers the given event, e.g. &lt;code&gt;blur&lt;/code&gt;, &lt;code&gt;dblclick&lt;/code&gt; on the element identified by the provided selector.</source>
          <target state="translated">제공된 선택기로 식별 된 요소 에서 주어진 이벤트 (예 : &lt;code&gt;blur&lt;/code&gt; , &lt;code&gt;dblclick&lt;/code&gt; ) 를 트리거합니다 .</target>
        </trans-unit>
        <trans-unit id="88ede053a62e801fe94c3f39f9283bc95d7953b4" translate="yes" xml:space="preserve">
          <source>Triggers the router level &lt;code&gt;didTransition&lt;/code&gt; hook.</source>
          <target state="translated">라우터 수준 &lt;code&gt;didTransition&lt;/code&gt; 후크를 트리거합니다 .</target>
        </trans-unit>
        <trans-unit id="fd1c5125e97b8ef7401e3054a46c338003dc15f5" translate="yes" xml:space="preserve">
          <source>Triggers the router level &lt;code&gt;willTransition&lt;/code&gt; hook.</source>
          <target state="translated">라우터 레벨 &lt;code&gt;willTransition&lt;/code&gt; 훅을 트리거합니다 .</target>
        </trans-unit>
        <trans-unit id="c4f15d1227f1cecd460d1f08b6f43ba52c0f8b32" translate="yes" xml:space="preserve">
          <source>Triple curly brackets are a convenient way to put dynamic HTML into Ember templates, but are not recommended for production apps. Inserting unknown HTML can create unexpected results and security issues. Be sure to sanitize the HTML before you render it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="285ec850c11d78bac10f6bfa31b69a37f1b257c9" translate="yes" xml:space="preserve">
          <source>Troubleshooting</source>
          <target state="translated">Troubleshooting</target>
        </trans-unit>
        <trans-unit id="32c1f66a64fae49554e8daf1291a5edd4605373b" translate="yes" xml:space="preserve">
          <source>Try refactoring one existing component to use Octane style. Check out the &lt;a href=&quot;cheat-sheet&quot;&gt;Cheat Sheet&lt;/a&gt; and &lt;a href=&quot;https://guides.emberjs.com/in-depth-topics/&quot;&gt;Edition's Deep Dive&lt;/a&gt; for some pointers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51139440f1946cdd636cad160b3632b12dfda096" translate="yes" xml:space="preserve">
          <source>Try refactoring one existing component to use Octane style. Check out the &lt;a href=&quot;cheat-sheet&quot;&gt;Cheat Sheet&lt;/a&gt; and &lt;a href=&quot;https://guides.emberjs.com/v3.25.0/in-depth-topics/&quot;&gt;Edition's Deep Dive&lt;/a&gt; for some pointers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3afd3167184bdb3baea996bf37e014fc89cdadc8" translate="yes" xml:space="preserve">
          <source>Turn on resolver resolution logging</source>
          <target state="translated">확인자 해결 로깅 설정</target>
        </trans-unit>
        <trans-unit id="171dc559b8c86e4b5f59e4b10965ed25793a055c" translate="yes" xml:space="preserve">
          <source>Tweaking the Default JSON</source>
          <target state="translated">기본 JSON 조정</target>
        </trans-unit>
        <trans-unit id="7b4a2b410126ecccb887285bdab4c6d3146bd760" translate="yes" xml:space="preserve">
          <source>Two, unit tests allow you to focus on small pieces of logic that might be difficult to exercise in higher-level tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59ae438323ad843da4c143e3db72fa92cf8f29ed" translate="yes" xml:space="preserve">
          <source>Typical Example:</source>
          <target state="translated">전형적인 예 :</target>
        </trans-unit>
        <trans-unit id="92bbd30186d37d129136d1fb54f7113f7bd05fd7" translate="yes" xml:space="preserve">
          <source>Typically &lt;code&gt;serializerFor&lt;/code&gt; will be used to find a serializer with a name matching that of the primary resource &lt;code&gt;type&lt;/code&gt; for the request, falling back to the &lt;code&gt;application&lt;/code&gt; serializer for those types that do not have a defined serializer. This is often described as a &lt;code&gt;per-model&lt;/code&gt; or &lt;code&gt;per-type&lt;/code&gt; strategy for defining serializers. However, because APIs rarely format payloads per-type but rather per-API-version, this may not be a desired strategy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4dd5329de229683bdb2f5069e615011060b419a" translate="yes" xml:space="preserve">
          <source>Typically these features represent work that might introduce a new concept, new API, change an API, or risk an unintended change in behavior to consuming applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1016393aae80d0b7e8ffa293c223fee10559838d" translate="yes" xml:space="preserve">
          <source>Typically, most models are loaded from and saved to a server that uses a database to store data. Usually you will send JSON representations of models back and forth to an HTTP server that you have written. However, Ember makes it easy to use other durable storage, such as saving to the user's hard disk with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API&quot;&gt;IndexedDB&lt;/a&gt;, or hosted storage solutions that let you avoid writing and hosting your own servers.</source>
          <target state="translated">일반적으로 대부분의 모델은 데이터베이스를 사용하여 데이터를 저장하는 서버에서로드 및 저장됩니다. 일반적으로 모델의 JSON 표현을 작성한 HTTP 서버로주고받습니다. 그러나 Ember를 사용하면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API&quot;&gt;IndexedDB&lt;/a&gt; 를 사용하여 사용자의 하드 디스크에 저장하거나 자체 서버를 작성하거나 호스팅하지 않아도 되는 호스팅 된 스토리지 솔루션 과 같은 다른 내구성있는 스토리지를 쉽게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0f00d1a5e9139be33f8866b6b8f269ded268029" translate="yes" xml:space="preserve">
          <source>Typically, the &lt;code&gt;model&lt;/code&gt; hook should return an &lt;a href=&quot;https://guides.emberjs.com/models/&quot;&gt;Ember Data&lt;/a&gt; record, but it can also return any &lt;a href=&quot;https://www.promisejs.org/&quot;&gt;promise&lt;/a&gt; object (Ember Data records are promises), or a plain JavaScript object or array. Ember will wait until the data finishes loading (until the promise is resolved) before rendering the template.</source>
          <target state="translated">일반적으로 &lt;code&gt;model&lt;/code&gt; 후크는 &lt;a href=&quot;https://guides.emberjs.com/models/&quot;&gt;Ember 데이터&lt;/a&gt; 레코드를 반환해야 하지만 &lt;a href=&quot;https://www.promisejs.org/&quot;&gt;약속&lt;/a&gt; 개체 (Ember 데이터 레코드는 약속) 또는 일반 JavaScript 개체 또는 배열을 반환 할 수도 있습니다 . Ember는 템플릿을 렌더링하기 전에 데이터로드가 완료 될 때까지 (약속이 해결 될 때까지) 기다립니다.</target>
        </trans-unit>
        <trans-unit id="90f6a780943179d8b1aae6e03c66f89fa92e7702" translate="yes" xml:space="preserve">
          <source>Typically, the application object is the only global variable. All other classes in your app should be properties on the &lt;code&gt;Ember.Application&lt;/code&gt; instance, which highlights its first role: a global namespace.</source>
          <target state="translated">일반적으로 응용 프로그램 개체는 유일한 전역 변수입니다. 앱의 다른 모든 클래스는 &lt;code&gt;Ember.Application&lt;/code&gt; 인스턴스의 속성이어야하며 , 첫 번째 역할은 글로벌 네임 스페이스입니다.</target>
        </trans-unit>
        <trans-unit id="9a9cecfe60e474fbd88d57ddf86af2698a9750c5" translate="yes" xml:space="preserve">
          <source>Typos, missing words, and code samples with errors are all considered documentation bugs. If you spot one of them, or want to otherwise improve the existing guides, we are happy to help you help us!</source>
          <target state="translated">오타, 누락 된 단어 및 오류가있는 코드 샘플은 모두 문서 버그로 간주됩니다. 그 중 하나를 발견하거나 기존 가이드를 개선하려는 경우 도움을 드리겠습니다.</target>
        </trans-unit>
        <trans-unit id="9d57875196c613785a1eee010c55223a0f1aa821" translate="yes" xml:space="preserve">
          <source>UI</source>
          <target state="translated">UI</target>
        </trans-unit>
        <trans-unit id="0ba153f162628204eee9e4b45358dd42399839e8" translate="yes" xml:space="preserve">
          <source>UI elements whose data is independent of a route. For example, a modal that could appear on many different routes, and the modal has its own unique data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56ec268e73f8f2ff103ef53a9916b081ba7f3172" translate="yes" xml:space="preserve">
          <source>UI stands for User Interface and is essentially what the user sees and interacts with on a device. In terms of the web, the UI is generally composed of a series of pages containing visual elements such as buttons and icons that a user can interact with to perform a specific function.</source>
          <target state="translated">UI는 사용자 인터페이스를 나타내며 본질적으로 사용자가 장치에서보고 상호 작용하는 것입니다. 웹과 관련하여 UI는 일반적으로 사용자가 특정 기능을 수행하기 위해 상호 작용할 수있는 버튼 및 아이콘과 같은 시각적 요소를 포함하는 일련의 페이지로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="25ba44ec3b391ba4ce5fbbd2979635e254775e7d" translate="yes" xml:space="preserve">
          <source>UNKNOWN</source>
          <target state="translated">UNKNOWN</target>
        </trans-unit>
        <trans-unit id="0e2d9b0777a485c1276de0803c12a7d76fbc5c39" translate="yes" xml:space="preserve">
          <source>URL</source>
          <target state="translated">URL</target>
        </trans-unit>
        <trans-unit id="2a78301c31a5cdf1806010201d9c88a248b6e24f" translate="yes" xml:space="preserve">
          <source>URL Conventions</source>
          <target state="translated">URL 규칙</target>
        </trans-unit>
        <trans-unit id="76d8d79b3321afa690f6de9e3b55b258a0c6db9c" translate="yes" xml:space="preserve">
          <source>UnauthorizedError</source>
          <target state="translated">UnauthorizedError</target>
        </trans-unit>
        <trans-unit id="1d0b24ed134011a2aa230bdbb865f186a7f4281a" translate="yes" xml:space="preserve">
          <source>Unbound:</source>
          <target state="translated">Unbound:</target>
        </trans-unit>
        <trans-unit id="adcff83915dac1afac720f25d1f1be8c41ff4bd5" translate="yes" xml:space="preserve">
          <source>Unconsumed Computed Properties Do Not Trigger Observers</source>
          <target state="translated">소비되지 않은 계산 된 속성은 관찰자를 트리거하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0646f4afd90c8fdb87bbcb57b63ee1911f5a9a46" translate="yes" xml:space="preserve">
          <source>Undefined</source>
          <target state="translated">Undefined</target>
        </trans-unit>
        <trans-unit id="b2cf9e638539bf147e1afc2be86aae23bea12dca" translate="yes" xml:space="preserve">
          <source>Unfortunately we don't have control over the Firefox review process, so if you need the latest Inspector version, download and install it manually from &lt;a href=&quot;https://github.com/emberjs/ember-inspector&quot;&gt;GitHub&lt;/a&gt;.</source>
          <target state="translated">안타깝게도 Firefox 검토 프로세스를 제어 할 수 없으므로 최신 검사기 버전이 필요한 경우 &lt;a href=&quot;https://github.com/emberjs/ember-inspector&quot;&gt;GitHub&lt;/a&gt; 에서 수동으로 다운로드하여 설치하십시오 .</target>
        </trans-unit>
        <trans-unit id="2cac43b24a13e42d8cce322b40984d5b87556749" translate="yes" xml:space="preserve">
          <source>Unfortunately, the app will now make two separate requests for the same information. Not only is the redundant data fetching costly in terms of wasted bandwidth and affecting the perceived speed of your app, it's easy for the two values to get out-of-sync. You yourself have probably used a web application where the list of items gets out of sync with the counter in a toolbar, leading to a frustrating and inconsistent experience.</source>
          <target state="translated">불행히도 앱은 이제 동일한 정보에 대해 두 개의 별도 요청을합니다. 불필요한 데이터 반입은 대역폭 낭비 및 앱의 인식 속도에 영향을 줄뿐만 아니라 두 값이 동기화되지 않는 것이 쉽습니다. 자신이 항목 목록이 도구 모음의 카운터와 동기화되지 않아서 실망스럽고 일관되지 않은 경험이있는 웹 응용 프로그램을 사용했을 것입니다.</target>
        </trans-unit>
        <trans-unit id="435a0121b4b4da7be6794568d5ff9daf201cc903" translate="yes" xml:space="preserve">
          <source>Unit Testing Basics</source>
          <target state="translated">단위 테스트 기본 사항</target>
        </trans-unit>
        <trans-unit id="55319d93decd49524c6577ad2944aab8499b8def" translate="yes" xml:space="preserve">
          <source>Unit Tests</source>
          <target state="translated">단위 테스트</target>
        </trans-unit>
        <trans-unit id="93ff14f84e553511a6d925afc2fd312d4a69fdf2" translate="yes" xml:space="preserve">
          <source>Unit testing a Service</source>
          <target state="translated">서비스 단위 테스트</target>
        </trans-unit>
        <trans-unit id="e953abafc0e9309d7c5083375c031969ba683421" translate="yes" xml:space="preserve">
          <source>Unit testing controllers is very simple using the unit test helper which is part of the ember-qunit framework.</source>
          <target state="translated">단위 테스트 컨트롤러는 ember-qunit 프레임 워크의 일부인 단위 테스트 도우미를 사용하면 매우 간단합니다.</target>
        </trans-unit>
        <trans-unit id="69c9113ad75da6e23f23a276dff26e75c7de4dc5" translate="yes" xml:space="preserve">
          <source>Unit tests</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b03ebbb65885649ce0fbc7112c728f9a7b47136d" translate="yes" xml:space="preserve">
          <source>Unit tests (as well as container tests) are generally used to test a small piece of code and ensure that it is doing what was intended. Unlike application tests, they are narrow in scope and do not require the Ember application to be running.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f2e8408bfaa4887c87ced8532981f549a2f0ac1" translate="yes" xml:space="preserve">
          <source>Unit tests are generally used to test a small piece of code and ensure that it is doing what was intended. Unlike acceptance tests, they are narrow in scope and do not require the Ember application to be running.</source>
          <target state="translated">단위 테스트는 일반적으로 작은 코드를 테스트하고 의도 한대로 작동하는지 확인하는 데 사용됩니다. 승인 테스트와 달리 범위는 좁으며 Ember 응용 프로그램을 실행할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="477bdac7302f74643108a43b14379442934d16fb" translate="yes" xml:space="preserve">
          <source>Unit tests are often testing methods that call other methods or work with other objects. A stub is a substitute method or object to be used during the test. This isolates a unit test to the actual method under test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb68db7729e7a12b83a5c5895b39431e1671922d" translate="yes" xml:space="preserve">
          <source>Unit tests are used to test isolated chunks of functionality, or &quot;units&quot;. They can be written against any isolated application logic.</source>
          <target state="translated">단위 테스트는 분리 된 기능 덩어리 또는 &quot;단위&quot;를 테스트하는 데 사용됩니다. 격리 된 응용 프로그램 논리에 대해 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65fdd323176f359323fb786c58eb952cf8a02fd5" translate="yes" xml:space="preserve">
          <source>Unit tests check the &lt;strong&gt;correctness of individual methods and functions&lt;/strong&gt;. Given an input, does the method return the right output? Since unit tests can check code at the method level, they can form the &lt;strong&gt;foundation of your test suite&lt;/strong&gt;. Unit tests are also &lt;strong&gt;extremely fast&lt;/strong&gt; by nature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="722fe06f105e9e949dd86f88ac62441b0e5583fb" translate="yes" xml:space="preserve">
          <source>Unit tests gets created automatically when you use Ember CLI to create &lt;a href=&quot;https://guides.emberjs.com/models/customizing-adapters/&quot;&gt;adapters&lt;/a&gt;, controllers, initializers, &lt;a href=&quot;https://guides.emberjs.com/models/defining-models/&quot;&gt;models&lt;/a&gt;, &lt;a href=&quot;https://guides.emberjs.com/models/customizing-serializers/&quot;&gt;serializers&lt;/a&gt;, &lt;a href=&quot;https://guides.emberjs.com/services/&quot;&gt;services&lt;/a&gt;, and utilities. We encourage you to read the rest of the documentation to learn writing tests for each.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17909e26819874f7405577d82491e99531963e55" translate="yes" xml:space="preserve">
          <source>Unit tests use the function called &lt;code&gt;this.subject&lt;/code&gt; to instantiate the object to test, and lets the test pass in initial values as arguments. In our case we are passing in our fake map utility object in the first test, and passing a cache object for the second test.</source>
          <target state="translated">단위 테스트는 &lt;code&gt;this.subject&lt;/code&gt; 라는 함수를 사용하여 테스트 할 객체를 인스턴스화하고 테스트가 초기 값을 인수로 전달하도록합니다. 우리의 경우 첫 번째 테스트에서 가짜 맵 유틸리티 개체를 전달하고 두 번째 테스트를 위해 캐시 개체를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="699a683faaa9485bee8084684b0d1eae07aa0ba1" translate="yes" xml:space="preserve">
          <source>Unknown Properties</source>
          <target state="translated">알 수없는 속성</target>
        </trans-unit>
        <trans-unit id="e645e94764f04f4c7f3e561913a7d9a2e676183b" translate="yes" xml:space="preserve">
          <source>Unless you have specific needs for &lt;code&gt;CoreView&lt;/code&gt;, you will use &lt;code&gt;Ember.Component&lt;/code&gt; in your applications.</source>
          <target state="translated">&lt;code&gt;CoreView&lt;/code&gt; 에 대한 특정 요구가 없으면 응용 프로그램에서 &lt;code&gt;Ember.Component&lt;/code&gt; 를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="f1dc9a4536b97fe5b5d22858d040db7f2f7b9e35" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;https://guides.emberjs.com/components/defining-a-component/&quot;&gt;components&lt;/a&gt;, which require a dash in the name to follow the Custom Element spec, helper names can be single or multi-word. If your helper's name is multi-word, it should be dasherized as the examples on this page.</source>
          <target state="translated">사용자 정의 요소 스펙을 따르기 위해 이름에 대시가 필요한 &lt;a href=&quot;https://guides.emberjs.com/components/defining-a-component/&quot;&gt;components&lt;/a&gt; 와 달리 도우미 이름은 단일 단어 또는 여러 단어 일 수 있습니다. 도우미 이름이 여러 단어 인 경우이 페이지의 예와 같이 대시 형식으로 표시해야합니다.</target>
        </trans-unit>
        <trans-unit id="0ba71c17b8be5769afabb31b692ab4883feaae70" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;Ember.Enumerable,&lt;/code&gt; this mixin defines methods specifically for collections that provide index-ordered access to their contents. When you are designing code that needs to accept any kind of Array-like object, you should use these methods instead of Array primitives because these will properly notify observers of changes to the array.</source>
          <target state="translated">&lt;code&gt;Ember.Enumerable,&lt;/code&gt; 과 달리 , 이 믹스 인은 컨텐츠에 인덱스 순서로 액세스 할 수있는 콜렉션에 대한 메소드를 정의합니다. 모든 종류의 Array와 같은 객체를 수용해야하는 코드를 디자인 할 때는 Array 프리미티브 대신 이러한 메소드를 사용해야합니다.이 메소드는 관찰자에게 어레이의 변경 사항을 올바르게 알리기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="c2346a7015c8d7f54cbe428fcb6f3328b3d12eff" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;Ember.typeOf&lt;/code&gt; this method returns true even if the passed object is not formally an array but appears to be array-like (i.e. implements &lt;code&gt;Ember.Array&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;Ember.typeOf&lt;/code&gt; 와 달리이 메소드는 전달 된 객체가 공식적으로 배열이 아니지만 배열과 같은 것처럼 보이는 경우에도 true를 리턴합니다 (즉, &lt;code&gt;Ember.Array&lt;/code&gt; 를 구현 함 )</target>
        </trans-unit>
        <trans-unit id="48f1b9ff4d1a0458244d8e86c4b05ccfa10f68f1" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;RSVP.all&lt;/code&gt; or &lt;code&gt;RSVP.hash&lt;/code&gt;, which implement a fail-fast method, but like &lt;code&gt;RSVP.allSettled&lt;/code&gt;, &lt;code&gt;hashSettled&lt;/code&gt; waits until all the constituent promises have returned and then shows you all the results with their states and values/reasons. This is useful if you want to handle multiple promises' failure states together as a set.</source>
          <target state="translated">달리 &lt;code&gt;RSVP.all&lt;/code&gt; 또는 &lt;code&gt;RSVP.hash&lt;/code&gt; , 페일 빠른 방법을 구현하지만, 같은 &lt;code&gt;RSVP.allSettled&lt;/code&gt; , &lt;code&gt;hashSettled&lt;/code&gt; 다음 쇼 당신에게 자신의 상태와 가치 / 이유 모든 결과를 모든 구성 약속이 반환 될 때까지 대기합니다. 여러 약속의 실패 상태를 집합으로 함께 처리하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="2a3d689226368801677173ed390db24291389456" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;all&lt;/code&gt; or &lt;code&gt;hash&lt;/code&gt;, which implement a fail-fast method, but like &lt;code&gt;allSettled&lt;/code&gt;, &lt;code&gt;hashSettled&lt;/code&gt; waits until all the constituent promises have returned and then shows you all the results with their states and values/reasons. This is useful if you want to handle multiple promises' failure states together as a set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dbbd0ee4cec488c0bcd007e3fc3536b828c4409" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;typeOf&lt;/code&gt; this method returns true even if the passed object is not formally an array but appears to be array-like (i.e. implements &lt;code&gt;Array&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a08498d44947ff6cad133013afcd3e725d914842" translate="yes" xml:space="preserve">
          <source>Unlike attributes, element modifiers do &lt;strong&gt;not&lt;/strong&gt; run on the server-side, because there is no general-purpose and complete way to serialize the results of an element modifier into HTML.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bee6d6d59812dc43ec15a1949e4a9aea2e5d664" translate="yes" xml:space="preserve">
          <source>Unlike callbacks, promises are great composable primitives.</source>
          <target state="translated">콜백과 달리 약속은 훌륭한 컴포저 블 프리미티브입니다.</target>
        </trans-unit>
        <trans-unit id="e43318987c768f8fb9f16d1a9218b08aab2bb57f" translate="yes" xml:space="preserve">
          <source>Unlike most other frameworks that include some sort of binding implementation, bindings in Ember.js can be used with any object. That said, bindings are most often used within the Ember framework itself, and for most problems Ember app developers face, computed properties are the appropriate solution.</source>
          <target state="translated">일종의 바인딩 구현을 포함하는 대부분의 다른 프레임 워크와 달리 Ember.js의 바인딩은 모든 객체와 함께 사용할 수 있습니다. 즉, 바인딩은 Ember 프레임 워크 자체 내에서 가장 자주 사용되며, Ember 앱 개발자가 겪는 대부분의 문제에 대해 계산 된 속성이 적절한 솔루션입니다.</target>
        </trans-unit>
        <trans-unit id="17e1fed215e92f510045ef5c63c8abbeeddb605f" translate="yes" xml:space="preserve">
          <source>Unlike the other route handlers we've made so far, the &lt;code&gt;index&lt;/code&gt; route is special: it does NOT require an entry in the router's mapping. We'll learn more about why the entry isn't required later on when we look at &lt;a href=&quot;../subroutes&quot;&gt;nested routes&lt;/a&gt; in Ember.</source>
          <target state="translated">지금까지 만든 다른 경로 처리기와 달리 &lt;code&gt;index&lt;/code&gt; 경로는 특별합니다. 라우터 매핑에 항목을 입력 할 필요가 없습니다. 나중에 Ember 에서 &lt;a href=&quot;../subroutes&quot;&gt;중첩 된 경로&lt;/a&gt; 를 볼 때 입력이 필요하지 않은 이유에 대해 자세히 알아볼 것 입니다.</target>
        </trans-unit>
        <trans-unit id="0a31d24114be4656ec50e863002c0179157848ce" translate="yes" xml:space="preserve">
          <source>Unloads the record from the store. This will cause the record to be destroyed and freed up for garbage collection.</source>
          <target state="translated">상점에서 레코드를 언로드합니다. 이로 인해 레코드가 삭제되고 가비지 수집을 위해 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="0dae4316acf45078caf64366600a3d5db302e2df" translate="yes" xml:space="preserve">
          <source>Unloads the record from the store. This will not send a delete request to your server, it just unloads the record from memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43070cef7aeb427607d411dd1ba9004d00927bf7" translate="yes" xml:space="preserve">
          <source>Unregister a factory.</source>
          <target state="translated">공장 등록을 취소하십시오.</target>
        </trans-unit>
        <trans-unit id="4f9491f2acb9ac489a58e64c4620334de6474d19" translate="yes" xml:space="preserve">
          <source>Unshift an object to start of array. Works just like &lt;code&gt;unshift()&lt;/code&gt; but it is KVO-compliant.</source>
          <target state="translated">배열의 시작을 위해 개체의 이동을 해제하십시오. &lt;code&gt;unshift()&lt;/code&gt; 처럼 작동 하지만 KVO 호환입니다.</target>
        </trans-unit>
        <trans-unit id="164f698a644916b960657c8f2ff6769690a513d0" translate="yes" xml:space="preserve">
          <source>Up to this point, we've generated four top level routes.</source>
          <target state="translated">지금까지 4 개의 최상위 경로를 생성했습니다.</target>
        </trans-unit>
        <trans-unit id="fb91e24fa52d8d2b32937bf04d843f730319a902" translate="yes" xml:space="preserve">
          <source>Update</source>
          <target state="translated">Update</target>
        </trans-unit>
        <trans-unit id="1cfa49d59018eef26ef97632e877b7882570010a" translate="yes" xml:space="preserve">
          <source>Update &lt;code&gt;postRecord.save()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;postRecord.save()&lt;/code&gt; 업데이트</target>
        </trans-unit>
        <trans-unit id="ac2e17800a0ab0d112375860107fae65bea51067" translate="yes" xml:space="preserve">
          <source>Update URL with &lt;code&gt;replaceState&lt;/code&gt; instead</source>
          <target state="translated">대신 &lt;code&gt;replaceState&lt;/code&gt; 로 URL 업데이트</target>
        </trans-unit>
        <trans-unit id="283ecf05902b1f4ae28ebde679dcfbd32a70c589" translate="yes" xml:space="preserve">
          <source>Update `postRecord.save()`</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f40768a6e2c45ddd1db6d9752d413302ad8b03c7" translate="yes" xml:space="preserve">
          <source>Update the content of the integration test to the following to fix it:</source>
          <target state="translated">통합 테스트의 컨텐츠를 다음으로 업데이트하여 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="f44d15f99a99d55ba65a02fe8182dacce539418d" translate="yes" xml:space="preserve">
          <source>Updates to the property of an attribute binding will result in automatic update of the HTML attribute in the component's HTML output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af48d19b99946eb85b1c250ae52baaf10a9733dd" translate="yes" xml:space="preserve">
          <source>Updates to the property of an attribute binding will result in automatic update of the HTML attribute in the component's rendered HTML representation. &lt;code&gt;attributeBindings&lt;/code&gt; is a concatenated property. See &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Object.html&quot;&gt;Ember.Object&lt;/a&gt; documentation for more information about concatenated properties.</source>
          <target state="translated">속성 바인딩의 속성을 업데이트하면 구성 요소의 렌더링 된 HTML 표현에서 HTML 속성이 자동으로 업데이트됩니다. &lt;code&gt;attributeBindings&lt;/code&gt; 는 연결된 속성입니다. 연결된 속성에 대한 자세한 내용은 &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Object.html&quot;&gt;Ember.Object&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="be507a9e83cd3f83b3a85b340f1acf039f989a67" translate="yes" xml:space="preserve">
          <source>Updates to the value of a class name binding will result in automatic update of the HTML &lt;code&gt;class&lt;/code&gt; attribute in the component's rendered HTML representation. If the value becomes &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; the class name will be removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85553080c5bd51708efff543f11a80f132dd3bad" translate="yes" xml:space="preserve">
          <source>Updates to the value of a class name binding will result in automatic update of the HTML &lt;code&gt;class&lt;/code&gt; attribute in the component's rendered HTML representation. If the value becomes &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; the class name will be removed. Both &lt;code&gt;classNames&lt;/code&gt; and &lt;code&gt;classNameBindings&lt;/code&gt; are concatenated properties. See &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Object.html&quot;&gt;Ember.Object&lt;/a&gt; documentation for more information about concatenated properties.</source>
          <target state="translated">클래스 이름 바인딩 값을 업데이트 하면 구성 요소의 렌더링 된 HTML 표현에서 HTML &lt;code&gt;class&lt;/code&gt; 특성이 자동으로 업데이트됩니다 . 값이 &lt;code&gt;false&lt;/code&gt; 이거나 &lt;code&gt;undefined&lt;/code&gt; 않으면 클래스 이름이 제거됩니다. 두 &lt;code&gt;classNames&lt;/code&gt; 과 &lt;code&gt;classNameBindings&lt;/code&gt; 은 연결된 속성입니다. 연결된 속성에 대한 자세한 내용은 &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Object.html&quot;&gt;Ember.Object&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1a89fee8955539e6cbec654a32c63f6e50462e63" translate="yes" xml:space="preserve">
          <source>Updating Existing Records</source>
          <target state="translated">기존 레코드 업데이트</target>
        </trans-unit>
        <trans-unit id="6bd9c9b66922bfad86141b602f4fb9dff2ad1b54" translate="yes" xml:space="preserve">
          <source>Updating Lists</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5b09343b2238bb74ea50d37eff3231b6eb0978f" translate="yes" xml:space="preserve">
          <source>Updating Records</source>
          <target state="translated">레코드 업데이트</target>
        </trans-unit>
        <trans-unit id="6092cd6e56ba0e1df831fd6765619573bcc81e1b" translate="yes" xml:space="preserve">
          <source>Updating Tracked Properties</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ac6235a9bbbe7f6e90305851495b8bbe8fb3841" translate="yes" xml:space="preserve">
          <source>Updating component state</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3c251798976c1a4eaea1b25759d885d99218eb3" translate="yes" xml:space="preserve">
          <source>Updating the Model Hook</source>
          <target state="translated">모델 후크 업데이트</target>
        </trans-unit>
        <trans-unit id="f7084ea284959866b9e5683c0595c9d4d36808f8" translate="yes" xml:space="preserve">
          <source>Upgrading to Octane</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="9629fc5be7eebf84f66a1a4fe14d7eee29fbc498" translate="yes" xml:space="preserve">
          <source>Usage Example:</source>
          <target state="translated">사용 예 :</target>
        </trans-unit>
        <trans-unit id="fec43ce445f974147bd0eb223a50147e7fb7202d" translate="yes" xml:space="preserve">
          <source>Usage example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b00b4ece5adc635acb7f5dc011be482040b5b456" translate="yes" xml:space="preserve">
          <source>Usage with Native Classes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5babfd7f28c97261be5d747a98ff927af4a35448" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;ds.jsonserializer&quot;&gt;DS.JSONSerializer&lt;/a&gt; to get the JSON representation of a record.</source>
          <target state="translated">&lt;a href=&quot;ds.jsonserializer&quot;&gt;DS.JSONSerializer&lt;/a&gt; 를 사용 하여 레코드의 JSON 표현을 가져 오십시오 .</target>
        </trans-unit>
        <trans-unit id="79babe4a58b3c5377a30d47b99f3a166cc374c1c" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Store.html#method_findAll&quot;&gt;&lt;code&gt;store.findAll()&lt;/code&gt;&lt;/a&gt; to retrieve all of the records for a given type:</source>
          <target state="translated">주어진 유형에 대한 모든 레코드를 검색 하려면 &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Store.html#method_findAll&quot;&gt; &lt;code&gt;store.findAll()&lt;/code&gt; &lt;/a&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="1eeddfe464eb2a59d11d65139e6a152e23204fe3" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Store.html#method_findRecord&quot;&gt;&lt;code&gt;store.findRecord()&lt;/code&gt;&lt;/a&gt; to retrieve a record by its type and ID. This will return a promise that fulfills with the requested record:</source>
          <target state="translated">&lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Store.html#method_findRecord&quot;&gt; &lt;code&gt;store.findRecord()&lt;/code&gt; &lt;/a&gt; 를 사용 하여 유형 및 ID별로 레코드를 검색하십시오. 요청 된 레코드를 충족시키는 약속을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cdebe1f775b156e00e0b7192c360b92d672f22ea" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Store.html#method_peekAll&quot;&gt;&lt;code&gt;store.peekAll()&lt;/code&gt;&lt;/a&gt; to retrieve all of the records for a given type that are already loaded into the store, without making a network request:</source>
          <target state="translated">&lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Store.html#method_peekAll&quot;&gt; &lt;code&gt;store.peekAll()&lt;/code&gt; &lt;/a&gt; 을 사용 하여 네트워크 요청없이 상점에 이미로드 된 지정된 유형의 모든 레코드를 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="b6be3a24df2cc3843f7fe4f0b083c1f949820c19" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Store.html#method_peekRecord&quot;&gt;&lt;code&gt;store.peekRecord()&lt;/code&gt;&lt;/a&gt; to retrieve a record by its type and ID, without making a network request. This will return the record only if it is already present in the store:</source>
          <target state="translated">네트워크 요청없이 &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Store.html#method_peekRecord&quot;&gt; &lt;code&gt;store.peekRecord()&lt;/code&gt; &lt;/a&gt; 를 사용 하여 유형 및 ID별로 레코드를 검색하십시오. 상점에 이미 존재하는 경우에만 레코드를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="a4859223f768210296b47b666b66691fc9711573" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://api.emberjs.com/ember-data/release/classes/Store/methods#findAll&quot;&gt;&lt;code&gt;store.findAll()&lt;/code&gt;&lt;/a&gt; to retrieve all of the records for a given type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3783ab5084026a76399c8e4742116f09328d9c1d" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://api.emberjs.com/ember-data/release/classes/Store/methods#findRecord&quot;&gt;&lt;code&gt;store.findRecord()&lt;/code&gt;&lt;/a&gt; to retrieve a record by its type and ID. This will return a promise that fulfills with the requested record:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47db5e9551640021722a698d193fe4986ca61029" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://api.emberjs.com/ember-data/release/classes/Store/methods#peekAll&quot;&gt;&lt;code&gt;store.peekAll()&lt;/code&gt;&lt;/a&gt; to retrieve all of the records for a given type that are already loaded into the store, without making a network request:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="845461ca687dc3a79feada7430e1ec683234bbd9" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://api.emberjs.com/ember-data/release/classes/Store/methods#peekRecord&quot;&gt;&lt;code&gt;store.peekRecord()&lt;/code&gt;&lt;/a&gt; to retrieve a record by its type and ID, without making a network request. This will return the record only if it is already present in the store:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21e8bdf95a6108d0bc0eeba659302eb1aae7b857" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;jsonserializer&quot;&gt;JSONSerializer&lt;/a&gt; to get the JSON representation of a record.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="392764678d8366e741ee8ecc091620344bb6b590" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;templates#toc_named-arguments&quot;&gt;Named Arguments&lt;/a&gt; and &lt;code&gt;this&lt;/code&gt; in your templates, by running the &lt;a href=&quot;https://github.com/ember-codemods/ember-no-implicit-this-codemod&quot;&gt;&lt;code&gt;ember-no-implicit-this-codemod&lt;/code&gt;&lt;/a&gt;. Component behavior should not change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af15101421b39bbd5b9e6e5fa1102dcad5bbaa91" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;class&lt;/code&gt; when defining a class, and &lt;code&gt;class ... extends&lt;/code&gt; when extending a class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1b3cd7d64a31d9f368592138fce8b354df82dbd" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;create&lt;/code&gt; instead of &lt;code&gt;new&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02022d360c80799822eb1c41ac85caa35c731f30" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;init&lt;/code&gt; instead of &lt;code&gt;constructor&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30a8de43ef5f7fad2338e36c8c2b12cc6db80fae" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;reopenClass&lt;/code&gt; to add static elements to the constructor:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00e000124add0ce9217af1c895a1ba1b021e403c" translate="yes" xml:space="preserve">
          <source>Use a custom (type) serializer for the post model to configure embedded author</source>
          <target state="translated">게시 모델에 사용자 지정 (유형) 직렬 변환기를 사용하여 포함 된 작성자 구성</target>
        </trans-unit>
        <trans-unit id="2822b36d55ca0f281fdd5caf6ce712c478b4c480" translate="yes" xml:space="preserve">
          <source>Use a custom (type) serializer for the post model to configure embedded comments</source>
          <target state="translated">포스트 모델에 사용자 정의 (유형) 직렬 변환기를 사용하여 포함 된 주석을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="18a2f23148493346b4dfeba036baa75787a6bab3" translate="yes" xml:space="preserve">
          <source>Use of Observable Methods and Properties</source>
          <target state="translated">관찰 가능한 방법 및 속성 사용</target>
        </trans-unit>
        <trans-unit id="aae16ef21556478e52876efe7f2def61a654dbec" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Ember.Templates.helpers/methods#debugger&quot;&gt;&lt;code&gt;{{debugger}}&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Ember.Templates.helpers/methods#log&quot;&gt;&lt;code&gt;{{log}}&lt;/code&gt;&lt;/a&gt; helper to inspect the &lt;code&gt;{{@model}}&lt;/code&gt; from the template</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d96d62219181a82960b50004a708bec5880356f9" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;https://api.emberjs.com/ember/release/functions/@ember%2Fobject/create&quot;&gt;&lt;code&gt;create&lt;/code&gt;&lt;/a&gt; static method to create instances of the class:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2623def3eedab83b13cf09d5b748b498a25cbb89" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;https://api.emberjs.com/ember/release/functions/@ember%2Fobject/extend&quot;&gt;&lt;code&gt;extend&lt;/code&gt;&lt;/a&gt; static method to define a class, with &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/EmberObject&quot;&gt;&lt;code&gt;EmberObject&lt;/code&gt;&lt;/a&gt; as the root base class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="130f409f7044687437389390fa8c19bce475ecad" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;https://github.com/ember-codemods/ember-native-class-codemod&quot;&gt;&lt;code&gt;ember-native-class-codemod&lt;/code&gt;&lt;/a&gt; on your non-component JavaScript files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7694a895c2720d34384666722189e92ffb017e1" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;_super()&lt;/code&gt; function to call the super method with the same name as the current method that is executing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76eef6568923fe3c5ee9d20276bdbfd3bdb13882" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;init&lt;/code&gt; method instead of the &lt;code&gt;constructor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e397b43dbbe9978bfd8289900d9094ad56d0665" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;new&lt;/code&gt; keyword to create instances of the class</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9896a0dc24fd0d039379529f13a88d43f6189a2" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;super&lt;/code&gt; keyword</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3fd739fa9c9591a0117b09c96aea594a051f255" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;{{array}}&lt;/code&gt; helper to create an array to pass as an option to your components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97fdbc8ed53b640b746052deb57d44ffe6c429d2" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;{{hash}}&lt;/code&gt; helper to create a hash to pass as an option to your components. This is specially useful for contextual components where you can just yield a hash:</source>
          <target state="translated">사용 &lt;code&gt;{{hash}}&lt;/code&gt; 컴포넌트에 옵션으로 전달하는 해시를 생성하는 도우미. 해시를 생성 할 수있는 상황에 맞는 구성 요소에 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="8e7ccd90e8cfeff420ef08923c36a50e99640cd2" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;{{with}}&lt;/code&gt; helper when you want to alias a property to a new name. This is helpful for semantic clarity as it allows you to retain default scope or to reference a property from another &lt;code&gt;{{with}}&lt;/code&gt; block.</source>
          <target state="translated">속성을 새 이름으로 별칭 지정 하려면 &lt;code&gt;{{with}}&lt;/code&gt; 도우미를 사용하십시오 . 기본 범위를 유지하거나 다른 &lt;code&gt;{{with}}&lt;/code&gt; 블록 에서 속성을 참조 할 수 있으므로 의미를 명확하게하는 데 도움이 됩니다.</target>
        </trans-unit>
        <trans-unit id="b101cb1e03e8a43550840a8c7fd20af20f00b55b" translate="yes" xml:space="preserve">
          <source>Use the tips described in &lt;a href=&quot;../object-inspector&quot;&gt;Object Inspector&lt;/a&gt; to inspect models and controllers. See below for templates and components.</source>
          <target state="translated">&lt;a href=&quot;../object-inspector&quot;&gt;Object Inspector&lt;/a&gt; 에 설명 된 팁을 사용하여 모델 및 컨트롤러를 검사하십시오. 템플릿 및 구성 요소는 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7830b0609b9584de5bbebc9de314d759ef55371b" translate="yes" xml:space="preserve">
          <source>Use this instead of the built-in &lt;code&gt;typeof&lt;/code&gt; to get the type of an item. It will return the same result across all browsers and includes a bit more detail. Here is what will be returned:</source>
          <target state="translated">기본 제공 &lt;code&gt;typeof&lt;/code&gt; 대신 이것을 사용 하여 항목 유형을 가져옵니다. 모든 브라우저에서 동일한 결과를 반환하며 조금 더 자세하게 포함되어 있습니다. 반환되는 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c645581e547e78cc873442313071c5e0586bcb0f" translate="yes" xml:space="preserve">
          <source>Use this to defer readiness until some condition is true.</source>
          <target state="translated">일부 조건이 충족 될 때까지 준비 상태를 연기하려면이 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="48121977e8f8997c6672074e5371d5969d40ddbf" translate="yes" xml:space="preserve">
          <source>Use with &lt;code&gt;Component&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="306cbcab821af23dfb473fbf6d987c353799e01a" translate="yes" xml:space="preserve">
          <source>Use with Ember.Component</source>
          <target state="translated">Ember.Component와 함께 사용</target>
        </trans-unit>
        <trans-unit id="542d6ad86b7eee775bf26a301d712477fe03a84b" translate="yes" xml:space="preserve">
          <source>Used this way, the &lt;code&gt;{{action}}&lt;/code&gt; helper provides a useful shortcut for registering an HTML element in a template for a single DOM event and forwarding that interaction to the template's context (controller or component). If the context of a template is a controller, actions used this way will bubble to routes when the controller does not implement the specified action. Once an action hits a route, it will bubble through the route hierarchy.</source>
          <target state="translated">이러한 방식으로 사용되는 &lt;code&gt;{{action}}&lt;/code&gt; 도우미는 단일 DOM 이벤트의 템플리트에 HTML 요소를 등록하고 해당 상호 작용을 템플리트의 컨텍스트 (컨트롤러 또는 구성 요소)로 전달하는 데 유용한 단축키를 제공합니다. 템플릿의 컨텍스트가 컨트롤러 인 경우 컨트롤러가 지정된 작업을 구현하지 않으면이 방법으로 사용 된 작업이 라우팅됩니다. 액션이 라우트에 도달하면 라우트 계층을 통해 버블 링됩니다.</target>
        </trans-unit>
        <trans-unit id="4c7c0d10b10d1e9407fe7fd091a42e7426902b37" translate="yes" xml:space="preserve">
          <source>Used to allow ember-testing to communicate with a specific testing framework.</source>
          <target state="translated">엠버 테스트가 특정 테스트 프레임 워크와 통신하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="55d2ee6134860f5a3842aa0334e35e2b668dc821" translate="yes" xml:space="preserve">
          <source>Used to determine if the array contains the passed object. Returns &lt;code&gt;true&lt;/code&gt; if found, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df5646ff626d5a83284889dd2548a84aebedbe9d" translate="yes" xml:space="preserve">
          <source>Used to determine the passed object's first occurrence in the array. Returns the index if found, -1 if no match is found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2522c403a71c0acbdd066953587aaea739ffa591" translate="yes" xml:space="preserve">
          <source>Used to determine when this &lt;code&gt;LinkComponent&lt;/code&gt; is active.</source>
          <target state="translated">이 &lt;code&gt;LinkComponent&lt;/code&gt; 가 활성화 된 시기를 판별하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e06eb9fc01574fd7225f291066780d472903fee4" translate="yes" xml:space="preserve">
          <source>Used to get the latest version of all of the records in this array from the adapter.</source>
          <target state="translated">이 어레이에있는 모든 레코드의 최신 버전을 어댑터에서 가져 오는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b625a63d0e499059d2ca14c82e5df7615a107612" translate="yes" xml:space="preserve">
          <source>Used to register callbacks to be fired whenever &lt;code&gt;App.injectTestHelpers&lt;/code&gt; is called.</source>
          <target state="translated">&lt;code&gt;App.injectTestHelpers&lt;/code&gt; 가 호출 될 때마다 발생하는 콜백을 등록하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="cb7f2badb8e4d94f6c7118903ad2f323f4cc77e3" translate="yes" xml:space="preserve">
          <source>User/session authentication.</source>
          <target state="translated">사용자 / 세션 인증.</target>
        </trans-unit>
        <trans-unit id="fed8214c42275ba9c04a1e30208425f4358807a9" translate="yes" xml:space="preserve">
          <source>Users may explicitly declare a record should/should not be background reloaded by passing &lt;code&gt;backgroundReload: true&lt;/code&gt; or &lt;code&gt;backgroundReload: false&lt;/code&gt; as an option to the request respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3973a9700b0b87a3d0ce2660254fee68a542cb75" translate="yes" xml:space="preserve">
          <source>Users may explicitly declare that this background request should/should not occur by passing &lt;code&gt;backgroundReload: true&lt;/code&gt; or &lt;code&gt;backgroundReload: false&lt;/code&gt; as an option to the request respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16bc4c4d7d89c3b988308786cd8619cfd3a339a8" translate="yes" xml:space="preserve">
          <source>Uses:</source>
          <target state="translated">Uses:</target>
        </trans-unit>
        <trans-unit id="9b8970c914983383f99e53ae30acfba6c7f27456" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;HashLocation&lt;/code&gt; results in URLs with a &lt;code&gt;#&lt;/code&gt; (hash sign) separating the server side URL portion of the URL from the portion that is used by Ember.</source>
          <target state="translated">&lt;code&gt;HashLocation&lt;/code&gt; 을 사용하면 URL 의 서버 측 URL 부분과 Ember에서 사용하는 부분을 분리 하는 &lt;code&gt;#&lt;/code&gt; (해시 기호)가있는 URL이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="2e374626d7a0702cc9f9268ad2fdcfaaf4d3ebb8" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;HistoryLocation&lt;/code&gt; results in URLs that are indistinguishable from a standard URL. This relies upon the browser's &lt;code&gt;history&lt;/code&gt; API.</source>
          <target state="translated">&lt;code&gt;HistoryLocation&lt;/code&gt; 을 사용 하면 표준 URL과 구별 할 수없는 URL이 생성됩니다. 이것은 브라우저의 &lt;code&gt;history&lt;/code&gt; API에 의존합니다 .</target>
        </trans-unit>
        <trans-unit id="12d381ddb9c8137de1d2923feb2b3a6160cab716" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;HistoryLocation&lt;/code&gt; will also result in location states being recorded by the browser &lt;code&gt;history&lt;/code&gt; API with the following schema:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b274154b8cd2e420cefe87ab03d519a29e9efd6b" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;NoneLocation&lt;/code&gt; causes Ember to not store the applications URL state in the actual URL. This is generally used for testing purposes, and is one of the changes made when calling &lt;code&gt;App.setupForTesting()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NoneLocation&lt;/code&gt; 을 사용 하면 Ember가 애플리케이션 URL 상태를 실제 URL에 저장하지 않습니다. 이것은 일반적으로 테스트 목적으로 사용되며 &lt;code&gt;App.setupForTesting()&lt;/code&gt; 호출 할 때 변경되는 것 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="60d8d1f0299627d742dc7cc43fee81d677009b4e" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;denodeify&lt;/code&gt; makes it easier to compose asynchronous operations instead of using callbacks. For example, instead of:</source>
          <target state="translated">사용 &lt;code&gt;denodeify&lt;/code&gt; 은 쉽게 대신 콜백을 사용하는 비동기 작업을 구성 할 수 있습니다. 예를 들어,</target>
        </trans-unit>
        <trans-unit id="f5822b7870a8d5523c5615715941fb03bf4b2289" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;get()&lt;/code&gt; and &lt;code&gt;set()&lt;/code&gt;</source>
          <target state="translated">사용 &lt;code&gt;get()&lt;/code&gt; 과 &lt;code&gt;set()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a807017af45e47826656353c74a452531495803d" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;super&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2b903f4ec447c2f19c335196b01fe88d084b735" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;{{on}}&lt;/code&gt; instead of the actions helper in templates</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8109d0339990f1783cd0634fdca5b574393894cb" translate="yes" xml:space="preserve">
          <source>Using Block Params</source>
          <target state="translated">블록 매개 변수 사용</target>
        </trans-unit>
        <trans-unit id="6790aa0871b5a22aba4914c2aca702feae6e26fa" translate="yes" xml:space="preserve">
          <source>Using Blocks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74f837326f24cf10cc05302b64d55360b8652855" translate="yes" xml:space="preserve">
          <source>Using BuildURLMixin</source>
          <target state="translated">BuildURLMixin 사용</target>
        </trans-unit>
        <trans-unit id="e8517af265fabf196c410cce740af7a7b6bec59d" translate="yes" xml:space="preserve">
          <source>Using Embedded Records</source>
          <target state="translated">내장 레코드 사용</target>
        </trans-unit>
        <trans-unit id="165fcfc43ecaff89929b038e0b256dd0b70e6794" translate="yes" xml:space="preserve">
          <source>Using Ember Data</source>
          <target state="translated">Ember 데이터 사용</target>
        </trans-unit>
        <trans-unit id="fb2881f07ad66266580a01fb816b0dce10a1a576" translate="yes" xml:space="preserve">
          <source>Using Ember Enumeration with Other Libraries</source>
          <target state="translated">다른 라이브러리와 함께 Ember 열거 형 사용</target>
        </trans-unit>
        <trans-unit id="32288de7b5b629b3ca02d918cfe820a4ecaf3608" translate="yes" xml:space="preserve">
          <source>Using Ember helpers</source>
          <target state="translated">Ember 헬퍼 사용하기</target>
        </trans-unit>
        <trans-unit id="b0f12819e1b49d9c8c49a88f3c0717d94a82974f" translate="yes" xml:space="preserve">
          <source>Using a Serializer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca7a4602a2a74d46f96031f6b4efa287c3f5c2c8" translate="yes" xml:space="preserve">
          <source>Using a helper to get a property dynamically</source>
          <target state="translated">도우미를 사용하여 속성을 동적으로 가져 오기</target>
        </trans-unit>
        <trans-unit id="9059eac12c500c79a5a3d1134418440b0c07e282" translate="yes" xml:space="preserve">
          <source>Using a string instead of an array allows for an arbitrary number of parameters:</source>
          <target state="translated">배열 대신 문자열을 사용하면 임의의 수의 매개 변수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28caefd8a232351fe54aff62842c8eb333074b44" translate="yes" xml:space="preserve">
          <source>Using an Adapter</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e7f18de2a8e24c22728aa51e8b3f677f7daf728" translate="yes" xml:space="preserve">
          <source>Using an Application Instance Within an Instance Initializer</source>
          <target state="translated">인스턴스 이니셜 라이저 내에서 애플리케이션 인스턴스 사용</target>
        </trans-unit>
        <trans-unit id="34b9681fe55a7ecfb5a0c7ea34a9b1845ae5fc03" translate="yes" xml:space="preserve">
          <source>Using an identity map is important because it ensures that changes you make in one part of your UI are propagated to other parts of the UI. It also means that you don't have to manually keep records in sync&amp;mdash;you can ask for a record by ID and not have to worry about whether other parts of your application have already asked for and loaded it.</source>
          <target state="translated">아이디 맵을 사용하는 것은 UI의 한 부분에서 변경 한 내용이 UI의 다른 부분으로 전파되도록하기 때문에 중요합니다. 또한 수동으로 레코드를 동기화 할 필요가 없음을 의미합니다. ID별로 레코드를 요청할 수 있으며 응용 프로그램의 다른 부분에서 이미 요청하고로드했는지에 대해 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="07ce6f1c64ca461dcf2e1ecf7c141612e2c8b87b" translate="yes" xml:space="preserve">
          <source>Using angle bracket invocation, this looks like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fad29eae11c2c19b66190933f6cc057fc210083" translate="yes" xml:space="preserve">
          <source>Using jQuery to simulate user click events might lead to unexpected test results as the action can potentially be called twice.</source>
          <target state="translated">jQuery를 사용하여 사용자 클릭 이벤트를 시뮬레이션하면 조치가 두 번 호출 될 수 있으므로 예상치 않은 테스트 결과가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83b0855b5b2fdec20f88550a7559cc5f3fbd42a0" translate="yes" xml:space="preserve">
          <source>Using link-to as an inline component</source>
          <target state="translated">인라인 구성 요소로 링크를 사용</target>
        </trans-unit>
        <trans-unit id="6b21844246a5e746bf6603cfe1437e125a8c0ffa" translate="yes" xml:space="preserve">
          <source>Using named arguments, we could make our template a lot clearer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3361a59105672115887409f50dc1f334cdbc7e8" translate="yes" xml:space="preserve">
          <source>Using native classes, and switching back to the old Ember Object model is fully supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89489b3c821f9036ebeead0732861e05bc042122" translate="yes" xml:space="preserve">
          <source>Using new features</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6514ea0b7a4031dd4cfdf0f43db752921a2b16e5" translate="yes" xml:space="preserve">
          <source>Using the &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Ember.Templates.helpers/methods#array&quot;&gt;&lt;code&gt;{{array}}&lt;/code&gt;&lt;/a&gt; helper, you can pass arrays directly from the template as an argument to your components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7b09c136d923d47d3169d52132488fce4871697" translate="yes" xml:space="preserve">
          <source>Using the &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Ember.Templates.helpers/methods#hash&quot;&gt;&lt;code&gt;{{hash}}&lt;/code&gt;&lt;/a&gt; helper, you can pass objects directly from the template as an argument to your components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dfc559dfffe991176278a255237452049d26387" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;concatenatedProperties&lt;/code&gt; property, we can tell Ember to mix the content of the properties.</source>
          <target state="translated">&lt;code&gt;concatenatedProperties&lt;/code&gt; 속성을 사용하여 속성의 내용을 혼합하도록 Ember에 지시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8441b31a8ac6de25541ff52dececd458a113c5a" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;did-insert&lt;/code&gt; modifier works well for one-off cases, but if you want to pull this logic into reusable functionality that you can use throughout your app, you can make your &lt;em&gt;own&lt;/em&gt; modifier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc052a6c684d0a200b80b2590fd8a6190ba4ab89" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;model&lt;/code&gt; hook</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="016843e89fab219d5ff8dfd7056e0e1c600484ca" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;value&lt;/code&gt; option modifies that behavior by extracting that property from the event object:</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; 옵션을 사용하면 이벤트 객체에서 해당 속성을 추출하여 해당 동작을 수정합니다.</target>
        </trans-unit>
        <trans-unit id="81f782cd38bd4d2134d355c024bfa8805f72b089" translate="yes" xml:space="preserve">
          <source>Using the Inspector adds a delay to your rendering, so the durations you see are not an accurate representation of the speed of your production apps. Use these times to compare durations and debug rendering bottlenecks, but not as a way to accurately measure rendering times.</source>
          <target state="translated">인스펙터를 사용하면 렌더링에 지연이 발생하므로, 지속 시간이 프로덕션 앱의 속도를 정확하게 나타내는 것은 아닙니다. 이 시간을 사용하여 지속 시간을 비교하고 렌더링 병목 현상을 디버그 할 수 있지만 렌더링 시간을 정확하게 측정하는 방법은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="74184cac3d00b39dad0d578fed89481eadcba9cb" translate="yes" xml:space="preserve">
          <source>Using the Inspector with JS Bin</source>
          <target state="translated">JS Bin과 함께 인스펙터 사용하기</target>
        </trans-unit>
        <trans-unit id="efa1a79a6306766f409c4bca723bf29d0eb2184f" translate="yes" xml:space="preserve">
          <source>Using the block form of this helper is similar to using the block form of a component. Given the following application template:</source>
          <target state="translated">이 헬퍼의 블록 형태를 사용하는 것은 컴포넌트의 블록 형태를 사용하는 것과 유사합니다. 다음과 같은 응용 프로그램 템플릿이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="391f67adbcc74616743bc53de0dfefcb12d91038" translate="yes" xml:space="preserve">
          <source>Using the pencil icon on the top-right of each guide page</source>
          <target state="translated">각 가이드 페이지의 오른쪽 상단에있는 연필 아이콘 사용</target>
        </trans-unit>
        <trans-unit id="c04c131609186adfe1bc7ccc394a0ad9c1f75084" translate="yes" xml:space="preserve">
          <source>Using the same process we did for our about and contact pages, we will first generate a new route called &lt;code&gt;index&lt;/code&gt;.</source>
          <target state="translated">정보 및 연락처 페이지에 대해 동일한 프로세스를 사용하여 먼저 &lt;code&gt;index&lt;/code&gt; 라는 새 경로를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="7440a853c106707a120cc166daeabd6069ac7294" translate="yes" xml:space="preserve">
          <source>Usually the response will be empty, but you may include additional updates in the response. The response will be fed to the associated serializer's &lt;code&gt;normalizeResponse&lt;/code&gt; method with the &lt;code&gt;requestType&lt;/code&gt; set to &lt;code&gt;deleteRecord&lt;/code&gt;, which should return a &lt;code&gt;JSON:API&lt;/code&gt; document.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76df093ba11570d1d43808629350f8343fd79f73" translate="yes" xml:space="preserve">
          <source>Usually you will not need the value or revision parameters at the end. In this case, it is common to write observer methods that take only a sender and key value as parameters or, if you aren't interested in any of these values, to write an observer that has no parameters at all.</source>
          <target state="translated">일반적으로 끝에 값 또는 개정 매개 변수가 필요하지 않습니다. 이 경우, 송신자와 키 값만 매개 변수로 사용하는 관찰자 메소드를 작성하거나이 값에 관심이없는 경우 매개 변수가없는 관찰자를 작성하는 것이 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="c82b6bdbc274f53f32f9ce798b9cacbb11fe43b3" translate="yes" xml:space="preserve">
          <source>Utility functions which can be imported and used in multiple classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b33892fbddeffc3368077b4904ad0b3d562a7312" translate="yes" xml:space="preserve">
          <source>VERSION</source>
          <target state="translated">VERSION</target>
        </trans-unit>
        <trans-unit id="c88dde9be6de65aa9f6a4053123062cf461174e1" translate="yes" xml:space="preserve">
          <source>VERSIONpublic</source>
          <target state="translated">VERSIONpublic</target>
        </trans-unit>
        <trans-unit id="72661fddf00221bbd8be22e1f6b3314d366e3aaf" translate="yes" xml:space="preserve">
          <source>Value to test</source>
          <target state="translated">테스트 할 가치</target>
        </trans-unit>
        <trans-unit id="2a2eb4b0d611b447805fded2ec383687ba6268e8" translate="yes" xml:space="preserve">
          <source>Verifies that a value is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, an empty string, or an empty array.</source>
          <target state="translated">값이 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; , 빈 문자열 또는 빈 배열인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="7bf5be677a008f785ff4bef5b2686070101bd076" translate="yes" xml:space="preserve">
          <source>Verify that a certain expectation is met, or throw a exception otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40eefdc490f84d2d7d51132947e203d320fc75e7" translate="yes" xml:space="preserve">
          <source>Very often, batching similar work has benefits. Web browsers do something quite similar by batching changes to the DOM.</source>
          <target state="translated">종종 유사한 작업을 일괄 처리하면 이점이 있습니다. 웹 브라우저는 DOM 변경 사항을 일괄 처리하여 비슷한 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="d356352bbabea4b8461ad53f2b6e5047c3a92bb4" translate="yes" xml:space="preserve">
          <source>Via Bookmarklet</source>
          <target state="translated">Bookmarklet을 통해</target>
        </trans-unit>
        <trans-unit id="191609c3bfb4b60d2e752147db86c5085d463647" translate="yes" xml:space="preserve">
          <source>Vice-versa, computed properties used in native getters will autotrack and cause the getter to update correctly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f75e28a09edb173079d6821dcac995b9d3fa468" translate="yes" xml:space="preserve">
          <source>View all registered templates</source>
          <target state="translated">등록 된 모든 템플릿보기</target>
        </trans-unit>
        <trans-unit id="fed11cb30e531fe5e8a975933cbf81d152f07822" translate="yes" xml:space="preserve">
          <source>ViewMixin</source>
          <target state="translated">ViewMixin</target>
        </trans-unit>
        <trans-unit id="e0b53d31dd0d08c5d637bdbcfd99da245e929f76" translate="yes" xml:space="preserve">
          <source>ViewMixin.$()</source>
          <target state="translated">ViewMixin.$()</target>
        </trans-unit>
        <trans-unit id="6e319bb0cbbf9bda646e8734599d271812fbe1c8" translate="yes" xml:space="preserve">
          <source>Viewing Objects</source>
          <target state="translated">객체보기</target>
        </trans-unit>
        <trans-unit id="ddbd58eaa27448b7a8896aa4d192125c461285ac" translate="yes" xml:space="preserve">
          <source>Viewing the Current Route</source>
          <target state="translated">현재 경로보기</target>
        </trans-unit>
        <trans-unit id="e22d9da12b10d6e11d609d7f966b50128d1e7d62" translate="yes" xml:space="preserve">
          <source>Views / Templates</source>
          <target state="translated">뷰 / 템플릿</target>
        </trans-unit>
        <trans-unit id="a78ad277616170813560c5fab7aabae8ac9cfb23" translate="yes" xml:space="preserve">
          <source>Vim</source>
          <target state="translated">Vim</target>
        </trans-unit>
        <trans-unit id="3c2ff4664e6df2af21fbcdce20e8aeceafa0f794" translate="yes" xml:space="preserve">
          <source>Vim is a highly configurable text editor built to make creating and changing any kind of text very efficient. It is included as &quot;vi&quot; with most UNIX systems and with Apple OS X.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cab0d7e1c96c3ea19c16733af4fdea5420773df9" translate="yes" xml:space="preserve">
          <source>Virtual DOM</source>
          <target state="translated">가상 DOM</target>
        </trans-unit>
        <trans-unit id="a465424577f9d8a6535a1629848bbf0b98d3c16e" translate="yes" xml:space="preserve">
          <source>Visit &lt;code&gt;chrome://extensions&lt;/code&gt;, then click on &lt;code&gt;Options&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;chrome://extensions&lt;/code&gt; 를 방문한 다음 &lt;code&gt;Options&lt;/code&gt; 을 클릭하십시오 .</target>
        </trans-unit>
        <trans-unit id="c3935bcb4dc9aa73ef69d15d8fca3aca079699e2" translate="yes" xml:space="preserve">
          <source>Visit &lt;code&gt;http://localhost:4200/tests&lt;/code&gt; in your browser</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e27c0f23c9732cbd86ef5de81e90796e9f8537ab" translate="yes" xml:space="preserve">
          <source>Visit each page of your app and refresh. Does it still work as expected? If not, you may need to refactor where your app makes data requests or use query params to track state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22c950d9edbfed65c9f96562f33f6915d0dc933e" translate="yes" xml:space="preserve">
          <source>Visit the Add-on page on the &lt;a href=&quot;https://addons.mozilla.org/en-US/firefox/addon/ember-inspector/&quot;&gt;Mozilla Add-ons site&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://addons.mozilla.org/en-US/firefox/addon/ember-inspector/&quot;&gt;Mozilla 애드온 사이트의 애드온&lt;/a&gt; 페이지를 방문 하십시오 .</target>
        </trans-unit>
        <trans-unit id="36e79518d0364a56d61df135d558d8f6663cb025" translate="yes" xml:space="preserve">
          <source>Visit the Add-on page on the &lt;a href=&quot;https://addons.mozilla.org/en-US/firefox/addon/ember-inspector/&quot;&gt;Mozilla Addons site&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3678db269e3fe76460953e9c72646a1f16d3cc77" translate="yes" xml:space="preserve">
          <source>Visits the given route and returns a promise that fulfills when all resulting async behavior is complete.</source>
          <target state="translated">주어진 경로를 방문하여 모든 비동기 동작이 완료되면 이행하는 약속을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="423f1f3d80c4d824ca917e13649a5c584a13ec87" translate="yes" xml:space="preserve">
          <source>Visual Studio Code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e448bacd0d7e08e1b986c6f41b3406d4e0b0214" translate="yes" xml:space="preserve">
          <source>Visual Studio Code is a code editor optimized for building and debugging modern web applications. Visual Studio Code is one of the most popular text editors among Ember developers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24b60821ac7f3fed786bd94a8d7c617d56a8df97" translate="yes" xml:space="preserve">
          <source>VoiceOver, integrated in Apple products</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="207c7c00630b836d3afb46848bdb24a92023331d" translate="yes" xml:space="preserve">
          <source>Void</source>
          <target state="translated">Void</target>
        </trans-unit>
        <trans-unit id="745c743d98b1b3fb097bf85457820d6602c2ed22" translate="yes" xml:space="preserve">
          <source>W3C Working Draft</source>
          <target state="translated">W3C 작업 초안</target>
        </trans-unit>
        <trans-unit id="1c94052dc8e3b79f99ca4a72f4623c05fefaf225" translate="yes" xml:space="preserve">
          <source>WARNING: This interface is likely to change in order to accomodate &lt;a href=&quot;https://github.com/emberjs/rfcs/pull/4&quot;&gt;https://github.com/emberjs/rfcs/pull/4&lt;/a&gt;</source>
          <target state="translated">경고 :이 인터페이스는 &lt;a href=&quot;https://github.com/emberjs/rfcs/pull/4&quot;&gt;https://github.com/emberjs/rfcs/pull/4&lt;/a&gt; 를 수용하기 위해 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6aa0358a08931c1d7d8fa7c6e9e6fc515572b8cd" translate="yes" xml:space="preserve">
          <source>Wait Helpers</source>
          <target state="translated">헬퍼를 기다립니다</target>
        </trans-unit>
        <trans-unit id="3d68e1241b229e5b8feafc79aefd9b39e529fc4f" translate="yes" xml:space="preserve">
          <source>Waiting on Asynchronous Behavior</source>
          <target state="translated">비동기 동작 대기</target>
        </trans-unit>
        <trans-unit id="828357c3569d7e51335798b042828e1409dc8e89" translate="yes" xml:space="preserve">
          <source>Watchman (optional)</source>
          <target state="translated">경비원 (선택 사항)</target>
        </trans-unit>
        <trans-unit id="c9d28ee44ab604daa14f1ec23dee2ae1c41d6a30" translate="yes" xml:space="preserve">
          <source>Ways to associate labels and inputs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84045d81b9276a47f2e9131445990d42b57f6d87" translate="yes" xml:space="preserve">
          <source>We add another initializer named &lt;code&gt;second&lt;/code&gt;, specifying that it should run after the initializer named &lt;code&gt;first&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;first&lt;/code&gt; 라는 이니셜 라이저 다음에 실행되도록 지정하는 &lt;code&gt;second&lt;/code&gt; 라는 다른 이니셜 라이저를 추가 합니다 .</target>
        </trans-unit>
        <trans-unit id="344bd202f0f01182b485cbed5ea1f3890a4f88a0" translate="yes" xml:space="preserve">
          <source>We are going to call the &lt;code&gt;my-post&lt;/code&gt; component, passing a title which is the title of the post suffixed with the name of the blog, the content of the post, and a series of options defined in-place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eed522ad465a007af829de5460c5930e29e604ae" translate="yes" xml:space="preserve">
          <source>We are not testing the actual filtering of rentals in this test, since it is focused on only the capability of the component. We will test the full logic of filtering in acceptance tests, described in the next section.</source>
          <target state="translated">이 테스트에서는 구성 요소의 기능에만 중점을두기 때문에이 테스트에서는 실제 임대 필터링을 테스트하지 않습니다. 다음 섹션에서 설명하는 승인 테스트에서 필터링의 전체 논리를 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="cabb5b7c4a4187b9fc6e817a4c98d08de8be9b77" translate="yes" xml:space="preserve">
          <source>We call the record to which a relationship belongs the relationship's &lt;em&gt;owner&lt;/em&gt;.</source>
          <target state="translated">관계가 관계의 &lt;em&gt;소유자 인&lt;/em&gt; 레코드를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="7a04cbc10d487c55fca246e338e4cf7675c544ab" translate="yes" xml:space="preserve">
          <source>We call the record to which a relationship belongs-to the relationship's &lt;em&gt;owner&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3332d6bcd42e017f425e6741f05b40fe962c5758" translate="yes" xml:space="preserve">
          <source>We can also check if a block receives parameters using the &lt;code&gt;(has-block-params)&lt;/code&gt; keyword, and conditionally yield different values if so.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db95d52d9cfac20d8d8e8d823114e1cf043cd539" translate="yes" xml:space="preserve">
          <source>We can also pass actions down to components via their arguments, which allows child components to communicate with their parents and notify them of changes to state. For instance, if we wanted to add back the doubling button we had previously, we could using an action passed down via arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cf5809fea567240b7d05ae9629bc0c397775313" translate="yes" xml:space="preserve">
          <source>We can also use a short-hand syntax called &lt;em&gt;brace expansion&lt;/em&gt; to declare the dependents. You surround the dependent properties with braces (&lt;code&gt;{}&lt;/code&gt;), and separate with commas, like so:</source>
          <target state="translated">또한 &lt;em&gt;중괄호 확장&lt;/em&gt; 이라는 간단한 구문을 사용 하여 종속 항목을 선언 할 수 있습니다. 종속 속성을 중괄호 ( &lt;code&gt;{}&lt;/code&gt; )로 묶고 다음과 같이 쉼표로 구분합니다.</target>
        </trans-unit>
        <trans-unit id="ec020ec180e7728849a778d877ba8273c5f0b4b1" translate="yes" xml:space="preserve">
          <source>We can create a component that can be used in both situations by &lt;em&gt;templating&lt;/em&gt; the parts of the HTML that are different.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3869ad9aae760b9afc2f878d668966932d2ca6e" translate="yes" xml:space="preserve">
          <source>We can do a similar thing for our &lt;code&gt;send-message&lt;/code&gt; component:</source>
          <target state="translated">&lt;code&gt;send-message&lt;/code&gt; 구성 요소에 대해 비슷한 작업을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cb509cbf7a734e2d6efd91304815e4bb7cac1780" translate="yes" xml:space="preserve">
          <source>We can do the same for the &lt;code&gt;&amp;lt;SentMessage&amp;gt;&lt;/code&gt; component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edb9d64c9ab05d3cbe8f73587d93feac19066994" translate="yes" xml:space="preserve">
          <source>We can do this by marking the field with the &lt;code&gt;@tracked&lt;/code&gt; decorator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0ef9021f1ba0ba5b613c8842d2d927edf0263f2" translate="yes" xml:space="preserve">
          <source>We can do this by marking the field with the &lt;code&gt;@tracked&lt;/code&gt; decorator:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b08e7c3b6fef6d30c90ec006c46d165bad92d16" translate="yes" xml:space="preserve">
          <source>We can include our new component into our application by using HTML tag syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34bab3cee02986c772e29b6bab11c7229c871938" translate="yes" xml:space="preserve">
          <source>We can make additional style tweaks to &lt;code&gt;vendor/ember-tutorial.css&lt;/code&gt;, and the changes will take effect whenever we restart the app.</source>
          <target state="translated">우리는 &lt;code&gt;vendor/ember-tutorial.css&lt;/code&gt; 스타일을 추가로 조정할 수 있으며 , 앱을 다시 시작할 때마다 변경 사항이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="ba7db9fcb1fe54640fa0cdff7fa5f94c653a0b5f" translate="yes" xml:space="preserve">
          <source>We can now also properly test if a helper will respond to property changes.</source>
          <target state="translated">또한 도우미가 속성 변경에 응답하는지 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8d36abf9da835afe94bedc8160a00d0555f097c" translate="yes" xml:space="preserve">
          <source>We can now update the template to use the &lt;code&gt;total&lt;/code&gt; property:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4fb8ae546ae3ae837ff391be815ee5e21bd8c97" translate="yes" xml:space="preserve">
          <source>We can represent the goals above as &lt;a href=&quot;https://guides.emberjs.com/testing/acceptance/&quot;&gt;Ember acceptance tests&lt;/a&gt;. Acceptance tests interact with our app like an actual person would, but are automated, helping ensure that our app doesn't break in the future.</source>
          <target state="translated">위의 목표를 &lt;a href=&quot;https://guides.emberjs.com/testing/acceptance/&quot;&gt;Ember 승인 테스트&lt;/a&gt; 로 나타낼 수 있습니다 . 승인 테스트는 실제 사람처럼 앱과 상호 작용하지만 자동화되어 향후 앱이 중단되지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="12347628afee2bdbfe829e4c398c4dc8f08b55ed" translate="yes" xml:space="preserve">
          <source>We can see that if the property &lt;code&gt;isExpanded&lt;/code&gt; is toggled to true, we will show the body property of the model to the user. This &lt;code&gt;isExpanded&lt;/code&gt; is stored in the controller.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05a2b409d552263133b17d63dc1a008d4585945e" translate="yes" xml:space="preserve">
          <source>We can see the now familiar output for the route generator:</source>
          <target state="translated">이제 경로 생성기에 익숙한 출력을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f6848525d747cfeaf1cfe0d7110ea0049ba5a7f" translate="yes" xml:space="preserve">
          <source>We can tell the action to invoke the &lt;code&gt;sendMessage&lt;/code&gt; action directly on the messaging service with the &lt;code&gt;target&lt;/code&gt; attribute.</source>
          <target state="translated">&lt;code&gt;target&lt;/code&gt; 속성 을 사용하여 메시징 서비스에서 직접 &lt;code&gt;sendMessage&lt;/code&gt; 작업을 호출하도록 작업에 지시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8fd202e30e9dfaf8e9312982221be63d6c416895" translate="yes" xml:space="preserve">
          <source>We can tell the action to invoke the &lt;code&gt;sendMessage&lt;/code&gt; action directly on the messaging service.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2d96f7bbd8d7273fb9ba80b308ff3ffbf64462d" translate="yes" xml:space="preserve">
          <source>We can test that changing the component's &lt;code&gt;name&lt;/code&gt; property updates the component's &lt;code&gt;style&lt;/code&gt; attribute and is reflected in the rendered HTML:</source>
          <target state="translated">컴포넌트의 &lt;code&gt;name&lt;/code&gt; 속성을 변경하면 컴포넌트의 &lt;code&gt;style&lt;/code&gt; 속성이 업데이트 되고 렌더링 된 HTML에 반영되는지 테스트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5d1f15612b1f46ee85eacd7d28bddd7386939f02" translate="yes" xml:space="preserve">
          <source>We can then use the &lt;code&gt;::&lt;/code&gt; separator in templates to access components within a folder:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de3eab786afb916107b8491dcadb27751e84a79b" translate="yes" xml:space="preserve">
          <source>We can then use this helper in the component's template to get the first letter of the username.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a086f3d7118276837543e634754ba5955ea1b3df" translate="yes" xml:space="preserve">
          <source>We can then use this value in the block like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5ae9728d249a94edb07d0467840ac30af0a3686" translate="yes" xml:space="preserve">
          <source>We can tighten up the implementation by moving the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;destructuring&lt;/a&gt; into the function's signature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05413438d4aaefc36cec13fdd858893db64d4207" translate="yes" xml:space="preserve">
          <source>We can use components &lt;em&gt;within&lt;/em&gt; other components, so we can continue to break down our template into smaller pieces if we want. For instance, Tomster's avatar could be made into its own component that is then used within the &lt;code&gt;&amp;lt;ReceivedMessage&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c446cb97ed2cecf3bb4f22b8ef4132bff4346eee" translate="yes" xml:space="preserve">
          <source>We can use the &lt;a href=&quot;https://api.emberjs.com/ember/release/functions/@ember%2Ftemplate/htmlSafe&quot;&gt;htmlSafe&lt;/a&gt; function to mark a sanitized HTML as safe, then use double curly brackets to render the HTML. We can also create a &lt;a href=&quot;../helper-functions&quot;&gt;helper&lt;/a&gt; that sanitizes the HTML, marks it as safe, and returns the output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acdef20152fdd39508fb6ea7068f63114599e8e2" translate="yes" xml:space="preserve">
          <source>We can use the &lt;code&gt;route:application&lt;/code&gt; to do so. The &lt;code&gt;route:application&lt;/code&gt; is the top-most route in the route hierarchy, and its &lt;code&gt;model&lt;/code&gt; hook gets called once when the app starts up.</source>
          <target state="translated">&lt;code&gt;route:application&lt;/code&gt; 을 사용하여 그렇게 할 수 있습니다. &lt;code&gt;route:application&lt;/code&gt; 경로 계층 구조의 최상위 경로이며, 그 &lt;code&gt;model&lt;/code&gt; 훅은 응용 프로그램이 시작될 때 한 번 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="105a4c47b88f0af5a2ec7f31753e90bb02e9543b" translate="yes" xml:space="preserve">
          <source>We can use this helper to set the page title at any point in any template.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c4737f6845bce4f769e8480b5745211aa3b11ec" translate="yes" xml:space="preserve">
          <source>We can yield back multiple values as well, separated by spaces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a772c8776f21128d3db926f8e7cd83bf6500962f" translate="yes" xml:space="preserve">
          <source>We chose funny-name.surge.sh but you may use any unclaimed subdomain you like or use a custom domain that you own and have pointed the DNS to one of surges servers. If the second argument is left blank surge will prompt you with a suggested subdomain.</source>
          <target state="translated">funny-name.surge.sh를 선택했지만 원하는 소유권이없는 하위 도메인을 사용하거나 자신이 소유하고 사용자가 서지 서버 중 하나에 DNS를 지정한 사용자 지정 도메인을 사용할 수 있습니다. 두 번째 인수가 비어 있으면 서지가 제안 된 하위 도메인을 프롬프트합니다.</target>
        </trans-unit>
        <trans-unit id="09674f796d4cd746dcbb22784d97262e462a04a9" translate="yes" xml:space="preserve">
          <source>We could accomplish this requirement by using the &lt;code&gt;if&lt;/code&gt; helper inside of an attribute:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2aa2c5b2de193a2fb2f794b0b00be9b4678fdb4e" translate="yes" xml:space="preserve">
          <source>We could also extract the username from the message:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d43d8a045ad3dc68d2c072194acd24bdc73be4b" translate="yes" xml:space="preserve">
          <source>We could have also linked the two records together by updating the blogPost's &lt;code&gt;hasMany&lt;/code&gt; relationship:</source>
          <target state="translated">또한 blogPost의 &lt;code&gt;hasMany&lt;/code&gt; 관계를 업데이트하여 두 레코드를 서로 연결할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9fd928242649957020233269717bd6b5d9490d3b" translate="yes" xml:space="preserve">
          <source>We could then invoke it like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61e1ee86eabfb27e99d5d8fc614c5f17c85d1034" translate="yes" xml:space="preserve">
          <source>We could then use the &lt;code&gt;modal&lt;/code&gt; component this way:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c78c1ef9a203957391cf3433b016cac21925d6c5" translate="yes" xml:space="preserve">
          <source>We define helper functions in the &lt;code&gt;app/helpers&lt;/code&gt; folder.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66a621b360f69638e676da656a565a3966cef035" translate="yes" xml:space="preserve">
          <source>We don't have to use the &lt;code&gt;moduleFor&lt;/code&gt; helper for unit testing helpers. Helpers are functions, which can be easily tested with &lt;code&gt;module&lt;/code&gt;.</source>
          <target state="translated">단위 테스트 도우미를 위해 &lt;code&gt;moduleFor&lt;/code&gt; 도우미 를 사용할 필요는 없습니다 . 도우미는 &lt;code&gt;module&lt;/code&gt; 로 쉽게 테스트 할 수있는 기능 입니다.</target>
        </trans-unit>
        <trans-unit id="d26817d55848c868b988fd806de5b1e32a953cca" translate="yes" xml:space="preserve">
          <source>We don't want to use &lt;code&gt;{{on &quot;click&quot;}}&lt;/code&gt; here because we want the opposite behavior: do something whenever the user clicks &lt;em&gt;outside&lt;/em&gt; of the &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;. To accomplish that, we'll register a &lt;code&gt;click&lt;/code&gt; handler on the entire document and then hit-test it, looking something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5af15d361879d47a1ffb398a38a710339f7d8d31" translate="yes" xml:space="preserve">
          <source>We force the action by generating a &lt;code&gt;keyUp&lt;/code&gt; event on our input field, and then assert that only one item is rendered.</source>
          <target state="translated">입력 필드에 &lt;code&gt;keyUp&lt;/code&gt; 이벤트를 생성하여 작업을 강제 한 다음 하나의 항목 만 렌더링되도록합니다.</target>
        </trans-unit>
        <trans-unit id="93f7ee3a4c5ee96ce430f42c49dc82dab1d4ff31" translate="yes" xml:space="preserve">
          <source>We generally recommend leaving this option set to true however, if you need to turn it off, you can add the configuration property &lt;code&gt;EXTEND_PROTOTYPES&lt;/code&gt; to &lt;code&gt;EmberENV&lt;/code&gt; and set it to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc3bdc09dd5efba1fa010f8ceafc901a0d8c1b66" translate="yes" xml:space="preserve">
          <source>We have one last component to extract. Let's pull out the new message input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dbbae3f342afe3e9010ee1f3f01e1cf465f33d3" translate="yes" xml:space="preserve">
          <source>We introduce two new helpers into this test, &lt;code&gt;fillIn&lt;/code&gt; and &lt;code&gt;keyEvent&lt;/code&gt;.</source>
          <target state="translated">이 테스트에는 &lt;code&gt;fillIn&lt;/code&gt; 과 &lt;code&gt;keyEvent&lt;/code&gt; 의 두 가지 새로운 도우미를 소개 합니다.</target>
        </trans-unit>
        <trans-unit id="b9fb933733deb10bc3b4b7e41a4641f9c623b68e" translate="yes" xml:space="preserve">
          <source>We learned that, by default, Ember provides 3 types of tests: unit, rendering, and application tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6c0c006a7c6f41f88694e034d106cada67bf9da" translate="yes" xml:space="preserve">
          <source>We may want to give the user the ability to put extra content before or after the post, such as an image or a profile. Since we don't know what the user wants to do with the body of the post, we can instead pass the body back to them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e78a8508d479e0fb1c9ce3180cbae22fd2cf480f" translate="yes" xml:space="preserve">
          <source>We mentioned above that helpers can be nested. This can be combined with different dynamic helpers. For example, the &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Ember.Templates.helpers/methods#concat&quot;&gt;&lt;code&gt;{{concat}}&lt;/code&gt;&lt;/a&gt; helper makes it easy to dynamically send a number of parameters to a component or helper as a single parameter in the format of a concatenated string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec254fe5964525c5e52d5539d23c4eede8ed1aae" translate="yes" xml:space="preserve">
          <source>We mentioned that the built-in components are similar in HTML markup to their native counterparts. What does this mean?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8b1317d968ebe5e737be5bcb1af90e31abf8c78" translate="yes" xml:space="preserve">
          <source>We might also test this component to ensure that the content of its template is being rendered properly:</source>
          <target state="translated">템플릿의 내용이 올바르게 렌더링되는지 확인하기 위해이 구성 요소를 테스트 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f09ff94b844e8d099d1cd7b9327a85f9d504f630" translate="yes" xml:space="preserve">
          <source>We need to add a &lt;em&gt;setter&lt;/em&gt; in order to be able to set it. Generally, the setter function stores the value somewhere, and the getter function retrieves it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6446910653b2a626fcb0855d68ef1d06df9faedf" translate="yes" xml:space="preserve">
          <source>We need to compute a value based on the results of the model hook</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d57f4fb9663406bdbcca59a18eb0648aeac14593" translate="yes" xml:space="preserve">
          <source>We need to support query parameters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3677f761534906e5eee3fed2c4d70c64652a0667" translate="yes" xml:space="preserve">
          <source>We now have a model object that we can use for our Ember Data implementation.</source>
          <target state="translated">이제 Ember Data 구현에 사용할 수있는 모델 객체가 있습니다.</target>
        </trans-unit>
        <trans-unit id="de7d01b5284ad5190215b09fb6656237d40de474" translate="yes" xml:space="preserve">
          <source>We only need to generate a Controller file if we want to customize the properties or provide any actions to the Route. If we have no customizations, Ember will provide a default Controller instance for us at run time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed5b896f8eda0644ab9681451806087217a00dc9" translate="yes" xml:space="preserve">
          <source>We provide the maps service into our component by initializing a property of our component, called &lt;code&gt;maps&lt;/code&gt;. Services are commonly made available in components and other Ember objects by &lt;a href=&quot;https://guides.emberjs.com/applications/services/#toc_accessing-services&quot;&gt;&quot;service injection&quot;&lt;/a&gt;. When you initialize a property with &lt;code&gt;Ember.inject.service()&lt;/code&gt;, Ember tries to set that property with a service matching its name.</source>
          <target state="translated">구성 요소의 속성 인 &lt;code&gt;maps&lt;/code&gt; 를 초기화하여 구성 요소에지도 서비스를 제공합니다 . 서비스는 일반적으로 &lt;a href=&quot;https://guides.emberjs.com/applications/services/#toc_accessing-services&quot;&gt;&quot;서비스 주입&quot;을&lt;/a&gt; 통해 컴포넌트 및 기타 Ember 오브젝트에서 사용 가능 합니다. &lt;code&gt;Ember.inject.service()&lt;/code&gt; 로 속성을 초기화하면 Ember는 해당 속성을 이름과 일치하는 서비스로 설정하려고합니다.</target>
        </trans-unit>
        <trans-unit id="86ea7af7b3ce7dbcf327164e27766386cbe07185" translate="yes" xml:space="preserve">
          <source>We recommend familiarizing yourself with the following concepts in particular to make the most out of these guides and of Ember:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4796744b7aeea7cf65dadaf2408df7e4f37e87aa" translate="yes" xml:space="preserve">
          <source>We recommend that all developers go through the &lt;a href=&quot;../../getting-started/quick-start&quot;&gt;Quick Start Tutorial&lt;/a&gt; to learn the fundamentals of Octane, and then the main &lt;a href=&quot;https://guides.emberjs.com/v3.25.0/tutorial/&quot;&gt;Tutorial&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e30d681ef9c1c377e3ec59ffdc28bb94b8a8f349" translate="yes" xml:space="preserve">
          <source>We recommend that all developers go through the &lt;a href=&quot;https://guides.emberjs.com/getting-started/quick-start/&quot;&gt;Quick Start Tutorial&lt;/a&gt; to learn the fundamentals of Octane, and then the main &lt;a href=&quot;https://guides.emberjs.com/tutorial/&quot;&gt;Tutorial&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0392d3120def495c8bb3a75804e9d02babbf5e2c" translate="yes" xml:space="preserve">
          <source>We recommend using native DOM events wrapped inside the run loop or the &lt;a href=&quot;https://github.com/cibernox/ember-native-dom-helpers&quot;&gt;&lt;code&gt;ember-native-dom-helpers&lt;/code&gt;&lt;/a&gt; addon to simulate user interaction and test that the title is updated when the button is clicked.</source>
          <target state="translated">실행 루프 또는 &lt;a href=&quot;https://github.com/cibernox/ember-native-dom-helpers&quot;&gt; &lt;code&gt;ember-native-dom-helpers&lt;/code&gt; &lt;/a&gt; 애드온에 래핑 된 기본 DOM 이벤트를 사용하여 사용자 상호 작용을 시뮬레이션하고 버튼을 클릭 할 때 제목이 업데이트되는지 테스트하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="1ce3107006cc7f608a1fc35546a4adace75ce526" translate="yes" xml:space="preserve">
          <source>We refer to a component's argument from JavaScript by prefixing them with &lt;code&gt;this.args.&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a381713ed4d46ca6610fcd38a6d33532494cc13" translate="yes" xml:space="preserve">
          <source>We see that the browser will rerender the template twice.</source>
          <target state="translated">브라우저가 템플릿을 두 번 다시 렌더링한다는 것을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bcf6fb188e06877ea86984c5124c68bf5caddafd" translate="yes" xml:space="preserve">
          <source>We take these API designs into account and end up with a reusable component. The component uses an inline &lt;code&gt;if&lt;/code&gt; to conditionally apply the &lt;code&gt;is-active&lt;/code&gt; class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4fbab8d9368db17ea6a78e8c40c05cdf7b7f58e" translate="yes" xml:space="preserve">
          <source>We then make a call to the &lt;code&gt;andThen&lt;/code&gt; helper which will wait for the preceding asynchronous test helpers to complete (specifically, &lt;code&gt;andThen&lt;/code&gt; will only be called &lt;strong&gt;after&lt;/strong&gt; the new posts URL was visited, the text filled in and the submit button was clicked, &lt;strong&gt;and&lt;/strong&gt; the browser has returned from doing whatever those actions required). Note &lt;code&gt;andThen&lt;/code&gt; has a single argument of the function that contains the code to execute after the other test helpers have finished.</source>
          <target state="translated">우리는 다음에 호출 할 &lt;code&gt;andThen&lt;/code&gt; 의 (특히, 완료 이전 비동기 테스트 헬퍼 기다리는 도우미 &lt;code&gt;andThen&lt;/code&gt; 은 에만 호출됩니다 &lt;strong&gt;이후&lt;/strong&gt; 새 게시물 URL을 방문했다, 채워 텍스트와 클릭 된 전송 버튼, &lt;strong&gt;그리고&lt;/strong&gt; 브라우저를 필요한 조치를 취하지 않고 돌아 왔습니다). 참고 &lt;code&gt;andThen&lt;/code&gt; 에는 다른 테스트 도우미가 완료 한 후 실행할 코드가 포함 된 함수의 단일 인수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="89d7017358e1fd53677d28f0d7d36b0f3814d3c1" translate="yes" xml:space="preserve">
          <source>We use &lt;code&gt;--environment=development&lt;/code&gt; here so that Mirage will continue to mock fake data. However, normally we would use &lt;code&gt;ember build --environment=production&lt;/code&gt; which optimizes your application for production.</source>
          <target state="translated">여기서 Mirage가 가짜 데이터를 계속 모방 할 수 있도록 &lt;code&gt;--environment=development&lt;/code&gt; 를 사용 합니다. 그러나 일반적으로 &lt;code&gt;ember build --environment=production&lt;/code&gt; 을 사용하여 응용 프로그램을 프로덕션 환경에 최적화합니다.</target>
        </trans-unit>
        <trans-unit id="437b3d5d4b5e3d3b7a96a7d22c758c9b17206794" translate="yes" xml:space="preserve">
          <source>We want the component to simply provide an input field and yield the results list to its block, so our template will be simple:</source>
          <target state="translated">컴포넌트가 단순히 입력 필드를 제공하고 결과 목록을 블록에 제공하기를 원하므로 템플릿은 간단합니다.</target>
        </trans-unit>
        <trans-unit id="8d8a33d979d2a378731ecc9906f6d745c82e33ee" translate="yes" xml:space="preserve">
          <source>We want to arrange for the action to be invoked from within &lt;code&gt;ButtonWithConfirmation&lt;/code&gt; with both arguments. We've seen already that if we provide a &lt;code&gt;messageType&lt;/code&gt; value to the &lt;code&gt;fn&lt;/code&gt; helper when we insert &lt;code&gt;ButtonWithConfirmation&lt;/code&gt; into its parent &lt;code&gt;SendMessage&lt;/code&gt; template, that value will be passed to the &lt;code&gt;sendMessage&lt;/code&gt; action as its first argument automatically when invoked as &lt;code&gt;onConfirm&lt;/code&gt;. If we subsequently pass a single additional argument to &lt;code&gt;onConfirm&lt;/code&gt; explicitly, that argument will be passed to &lt;code&gt;sendMessage&lt;/code&gt; as its second argument (This ability to provide arguments to a function one at a time is known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Partial_application&quot;&gt;partial application&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27eca1244a2d042815d63447bfd3d4bafc33c45e" translate="yes" xml:space="preserve">
          <source>We want to arrange for the action to be invoked from within &lt;code&gt;button-with-confirmation&lt;/code&gt; with both arguments. We've seen already that if we provide a &lt;code&gt;messageType&lt;/code&gt; value to the &lt;code&gt;action&lt;/code&gt; helper when we insert &lt;code&gt;button-with-confirmation&lt;/code&gt; into its parent &lt;code&gt;send-message&lt;/code&gt; template, that value will be passed to the &lt;code&gt;sendMessage&lt;/code&gt; action as its first argument automatically when invoked as &lt;code&gt;onConfirm&lt;/code&gt;. If we subsequently pass a single additional argument to &lt;code&gt;onConfirm&lt;/code&gt; explicitly, that argument will be passed to &lt;code&gt;sendMessage&lt;/code&gt; as its second argument (This ability to provide arguments to a function one at a time is known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Currying&quot;&gt;currying&lt;/a&gt;).</source>
          <target state="translated">우리는 두 가지 인수를 모두 사용하여 &lt;code&gt;button-with-confirmation&lt;/code&gt; 내에서 작업이 호출되도록 준비하려고합니다 . 우리는 우리가 제공하는 경우 이미 본 적이 &lt;code&gt;messageType&lt;/code&gt; 받는 값 &lt;code&gt;action&lt;/code&gt; 도우미를 삽입 우리가 때 &lt;code&gt;button-with-confirmation&lt;/code&gt; 부모로 &lt;code&gt;send-message&lt;/code&gt; 템플릿, 그 값이 전달됩니다 &lt;code&gt;sendMessage&lt;/code&gt; 의 첫 번째 인수로 작업으로 호출 할 때 자동으로 &lt;code&gt;onConfirm&lt;/code&gt; . 나중에 &lt;code&gt;onConfirm&lt;/code&gt; 에 단일 추가 인수를 명시 적으로 전달하면 해당 인수가 &lt;code&gt;sendMessage&lt;/code&gt; 에 두 번째 인수로 전달됩니다 (한 번에 하나씩 함수에 인수를 제공하는 기능은 다음과 같습니다.&lt;a href=&quot;https://en.wikipedia.org/wiki/Currying&quot;&gt;커링&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="57871ac98119b392f78a67f54e863fe9ea2740e2" translate="yes" xml:space="preserve">
          <source>We want to pass down actions or variables to share with a Route&amp;rsquo;s child components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5748c7642668b5173a2078dab6f3ce97a1306d7" translate="yes" xml:space="preserve">
          <source>We want to verify that we can click on a specific rental and load a detailed view to the page. We'll click on the title and validate that an expanded description of the rental is shown.</source>
          <target state="translated">특정 임대를 클릭하고 상세보기를 페이지에로드 할 수 있는지 확인하고 싶습니다. 제목을 클릭하고 대여에 대한 확장 된 설명이 표시되는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="8561199c13d7dc65608eefd4f1b6885051807097" translate="yes" xml:space="preserve">
          <source>We will cover these advanced component features in a later chapter. For now, let's see these core concepts in action by building a property rental application in the next lesson.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58623492e918c1212102733eb4d80f52c1725f65" translate="yes" xml:space="preserve">
          <source>We will go into more details about each of these template features later on in this guide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71d647a4022262d3a708d8f65093c6f6252fdbf8" translate="yes" xml:space="preserve">
          <source>We will start by editing the &lt;code&gt;application&lt;/code&gt; template. This template is always on screen while the user has your application loaded. In your editor, open &lt;code&gt;app/templates/application.hbs&lt;/code&gt; and change it to the following:</source>
          <target state="translated">&lt;code&gt;application&lt;/code&gt; 템플릿 을 편집하여 시작하겠습니다 . 이 템플릿은 사용자가 응용 프로그램을로드하는 동안 항상 화면에 표시됩니다. 편집기에서 &lt;code&gt;app/templates/application.hbs&lt;/code&gt; 를 열고 다음으로 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="56e5f5b48c6b928345891aaa143baffe89fe7553" translate="yes" xml:space="preserve">
          <source>We'd like our helper to print pounds sterling rather than US dollars:</source>
          <target state="translated">우리는 도우미가 미국 달러가 아닌 파운드를 인쇄하기를 원합니다.</target>
        </trans-unit>
        <trans-unit id="621911b4faa7e3dd3e785815b13ad5972379bd5d" translate="yes" xml:space="preserve">
          <source>We'll add some additional functionality to our &lt;code&gt;filterByCity&lt;/code&gt; action to additionally return a single rental, represented by the variable &lt;code&gt;FILTERED_ITEMS&lt;/code&gt; when any value is set.</source>
          <target state="translated">값이 설정되면 변수 &lt;code&gt;FILTERED_ITEMS&lt;/code&gt; 로 표시되는 단일 임대를 추가로 반환하기 위해 &lt;code&gt;filterByCity&lt;/code&gt; 작업에 일부 기능을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="2c5d938a89ee99595180f09de543d94bc99b847c" translate="yes" xml:space="preserve">
          <source>We'll also want to use the component elsewhere, perhaps like this:</source>
          <target state="translated">또한 다음과 같이 다른 곳에서 구성 요소를 사용하려고합니다.</target>
        </trans-unit>
        <trans-unit id="ca74fd7a1a443edb25110d84fc02382671ff3490" translate="yes" xml:space="preserve">
          <source>We'll break apart the larger HTML file into files containing each of these parts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caa6ee9d9ee5e479d7688d157d008530d368ce91" translate="yes" xml:space="preserve">
          <source>We'll call this the &lt;code&gt;ButtonWithConfirmation&lt;/code&gt; component. We can start off with a normal component definition, like we've seen before:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d1a55c50bbd1c4fe9c2f78f99cb3a7271f219bd" translate="yes" xml:space="preserve">
          <source>We'll cover these steps:</source>
          <target state="translated">다음 단계를 다룰 것입니다.</target>
        </trans-unit>
        <trans-unit id="76c90f3a2bc09cf017b4258b98acd18706384829" translate="yes" xml:space="preserve">
          <source>We'll discuss the capabilities and core concepts of templates in the following chapters, but before we do that, we should get started with the basics. The simplest way to get started on an Ember template is with some HTML!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddafa1f647707c3a72a39d4018c65c4526daeeda" translate="yes" xml:space="preserve">
          <source>We'll implement an action on the parent component called &lt;code&gt;deleteAccount()&lt;/code&gt; that, when called, gets a hypothetical &lt;code&gt;login&lt;/code&gt;&lt;a href=&quot;https://guides.emberjs.com/services/&quot;&gt;service&lt;/a&gt; and calls the service's &lt;code&gt;deleteUser()&lt;/code&gt; method. We'll go over services later on - for now, think of it as an API that manages the user's login and information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec7141941ff5757a9e139f4b128b4730b901c1ef" translate="yes" xml:space="preserve">
          <source>We'll implement an action on the parent component called &lt;code&gt;userDidDeleteAccount()&lt;/code&gt; that, when called, gets a hypothetical &lt;code&gt;login&lt;/code&gt;&lt;a href=&quot;https://guides.emberjs.com/applications/services/&quot;&gt;service&lt;/a&gt; and calls the service's &lt;code&gt;deleteUser()&lt;/code&gt; method.</source>
          <target state="translated">호출 될 때 가상 &lt;code&gt;login&lt;/code&gt; &lt;a href=&quot;https://guides.emberjs.com/applications/services/&quot;&gt;서비스를&lt;/a&gt; 가져오고 서비스의 &lt;code&gt;deleteUser()&lt;/code&gt; 메소드를 호출하는 &lt;code&gt;userDidDeleteAccount()&lt;/code&gt; 라는 상위 컴포넌트에 조치를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="b3a69d6b8f6bb9d602758ceab1b52171fd6fe0b5" translate="yes" xml:space="preserve">
          <source>We'll need to make some changes to the code we wrote before.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfa461b4980a08c7849802896e48b45579b62013" translate="yes" xml:space="preserve">
          <source>We'll plan to use the component in a template something like this:</source>
          <target state="translated">다음과 같은 템플릿에서 컴포넌트를 사용할 계획입니다.</target>
        </trans-unit>
        <trans-unit id="49fbd6ef6ee0f4a7335e4946320842c0633ffb54" translate="yes" xml:space="preserve">
          <source>We'll start by using Ember CLI to generate a new acceptance test:</source>
          <target state="translated">먼저 Ember CLI를 사용하여 새로운 승인 테스트를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="6b512f7c526eddf7cb5027f4b3755d3635c93db8" translate="yes" xml:space="preserve">
          <source>We'll start with a simple example. We have a &lt;code&gt;Person&lt;/code&gt; object with &lt;code&gt;firstName&lt;/code&gt; and &lt;code&gt;lastName&lt;/code&gt; properties, but we also want a &lt;code&gt;fullName&lt;/code&gt; property that joins the two names when either of them changes:</source>
          <target state="translated">간단한 예부터 시작하겠습니다. 우리는이 &lt;code&gt;Person&lt;/code&gt; 과 객체 &lt;code&gt;firstName&lt;/code&gt; 과 &lt;code&gt;lastName&lt;/code&gt; 이라는 속성을하지만, 우리는 또한 원하는 &lt;code&gt;fullName&lt;/code&gt; 의의 그들 중 하나가 변경 될 때 두 개의 이름을 조인 속성을 :</target>
        </trans-unit>
        <trans-unit id="28d4aab512bcec9f852a9bba9595bee7c9e27c8c" translate="yes" xml:space="preserve">
          <source>We'll take the code created for us by the generator and add a &lt;code&gt;model()&lt;/code&gt; method to the &lt;code&gt;Route&lt;/code&gt;:</source>
          <target state="translated">생성기에서 생성 한 코드를 가져와 &lt;code&gt;Route&lt;/code&gt; 에 &lt;code&gt;model()&lt;/code&gt; 메서드를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="5d6d9a78d5453b569f967dc69a5ceb971007c2f8" translate="yes" xml:space="preserve">
          <source>We'll use a unit test to validate the service. Unit tests are more isolated than integration tests and acceptance tests, and are intended for testing specific logic within a class.</source>
          <target state="translated">서비스를 확인하기 위해 단위 테스트를 사용합니다. 단위 테스트는 통합 테스트 및 승인 테스트보다 격리되어 있으며 클래스 내에서 특정 논리를 테스트하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="0f28fdf4934be1cf10d3779562c79625bf3b8794" translate="yes" xml:space="preserve">
          <source>We're going to demonstrate how to test helpers by testing the &lt;code&gt;format-currency&lt;/code&gt; helper from &lt;a href=&quot;https://guides.emberjs.com/templates/writing-helpers&quot;&gt;Writing Helpers&lt;/a&gt;.</source>
          <target state="translated">우리는 &lt;a href=&quot;https://guides.emberjs.com/templates/writing-helpers&quot;&gt;Writing Helpers&lt;/a&gt; 에서 &lt;code&gt;format-currency&lt;/code&gt; helper를 테스트하여 helper 를 테스트하는 방법을 보여줄 것 입니다.</target>
        </trans-unit>
        <trans-unit id="5a19c5b762ef4e30aec6b9c84897a002a09a8c4c" translate="yes" xml:space="preserve">
          <source>We're going to demonstrate how to test helpers by testing the &lt;code&gt;format-currency&lt;/code&gt; helper from &lt;a href=&quot;https://guides.emberjs.com/templates/writing-helpers/&quot;&gt;Writing Helpers&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d418058b4c745f5dd2b0304598ea74f7419421d8" translate="yes" xml:space="preserve">
          <source>We're going to tell our component:</source>
          <target state="translated">우리는 우리의 구성 요소를 말할 것입니다 :</target>
        </trans-unit>
        <trans-unit id="66dc772c65bef2a0f7cba14bb42e3cd58c1d560a" translate="yes" xml:space="preserve">
          <source>We're just missing the &lt;code&gt;current-user&lt;/code&gt; class on the HTML &lt;code&gt;&amp;lt;aside&amp;gt;&lt;/code&gt; element. To make that work, we'll specify the HTML attribute &lt;code&gt;class&lt;/code&gt; on the &lt;code&gt;&amp;lt;Avatar&amp;gt;&lt;/code&gt; tag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1d3da965644f107ee64edf7439c05d63040adf6" translate="yes" xml:space="preserve">
          <source>We're really, really close.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e0c1d5f20ebc7ff2c45ca5efab5fb48e8816aef" translate="yes" xml:space="preserve">
          <source>We're using the &lt;code&gt;submit&lt;/code&gt; event on the form itself here rather than adding a &lt;code&gt;click&lt;/code&gt; event handler to the button since it is about submitting the form as a whole. We also updated the &lt;code&gt;input&lt;/code&gt; tag to instead use the built in &lt;code&gt;&amp;lt;Input&amp;gt;&lt;/code&gt; component, which automatically updates the value we pass to &lt;code&gt;@value&lt;/code&gt;. Next, let's add the component class:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd4797da80eae7d8f95ba056eff22702f9595be0" translate="yes" xml:space="preserve">
          <source>We've also renamed &lt;code&gt;scientist&lt;/code&gt; to the more-generic &lt;code&gt;person&lt;/code&gt;, decreasing the coupling of our component to where it's used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1e5d59e02f3c455fb66d9e1d5b4e9d1ff8de041" translate="yes" xml:space="preserve">
          <source>We've covered the case when a model promise fulfills, but what if it rejects?</source>
          <target state="translated">우리는 모델 약속이 이행되는 경우를 다루었지만 거부한다면 어떻게 될까요?</target>
        </trans-unit>
        <trans-unit id="f859088711ed3a94c742e4bd935f2d138c2f9ca1" translate="yes" xml:space="preserve">
          <source>We've just created our first component!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9e644093a7a7b66e6a61bd2e7b50d0b70e2ed5d" translate="yes" xml:space="preserve">
          <source>We've seen most of this before, but the &lt;code&gt;{{outlet}}&lt;/code&gt; beneath &lt;code&gt;&amp;lt;div class=&quot;body&quot;&amp;gt;&lt;/code&gt; is new. The &lt;code&gt;{{outlet}}&lt;/code&gt; helper tells Ember where content for our current route (such as &lt;code&gt;about&lt;/code&gt; or &lt;code&gt;contact&lt;/code&gt;) should be shown.</source>
          <target state="translated">우리는 이전에이 대부분을 보았지만 &lt;code&gt;&amp;lt;div class=&quot;body&quot;&amp;gt;&lt;/code&gt; 아래 의 &lt;code&gt;{{outlet}}&lt;/code&gt; 은 새로운 것입니다. &lt;code&gt;{{outlet}}&lt;/code&gt; 도우미 (예 : 현재 경로에 대한 내용 엠버 이야기 &lt;code&gt;about&lt;/code&gt; 또는 &lt;code&gt;contact&lt;/code&gt; ) 표시되어야합니다.</target>
        </trans-unit>
        <trans-unit id="fd96ebe1f53832334ded31f142c8aaf2661be3db" translate="yes" xml:space="preserve">
          <source>We've taken a big HTML file and broken it up into &lt;em&gt;components&lt;/em&gt; to make the content easier to understand and maintain.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb4a73abdeb9df38b385d119bf485b42937822a0" translate="yes" xml:space="preserve">
          <source>Web Content Accessibility Guidelines(WCAG) 2.1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9adbbf981a608a69c175cd257a4594e6b28af94f" translate="yes" xml:space="preserve">
          <source>Web Development</source>
          <target state="translated">웹 개발</target>
        </trans-unit>
        <trans-unit id="06173f30ba037cccb9d203c2dee575ebeb29f9ea" translate="yes" xml:space="preserve">
          <source>Web components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ca6740481490592d182c54c048bffd7426b589c" translate="yes" xml:space="preserve">
          <source>WebSocket callbacks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4d3b53a7eaf3764d59f45e670b49e2810dc9bf1" translate="yes" xml:space="preserve">
          <source>WebSockets.</source>
          <target state="translated">WebSockets.</target>
        </trans-unit>
        <trans-unit id="5df1449d8121c876d37d0580d5ac59c93e722e17" translate="yes" xml:space="preserve">
          <source>Websocket callbacks</source>
          <target state="translated">웹 소켓 콜백</target>
        </trans-unit>
        <trans-unit id="0882292973fec4cdc6e646a0ef2fb781fce44cce" translate="yes" xml:space="preserve">
          <source>Welcome to Ember! Follow this guide to build a simple web app using HTML, JavaScript, the command line, and some of Ember's best features. Each step has code you can copy and paste directly or modify to make it your own. Along the way, you will be introduced to the Ember community so that you know who to ask for help and how to continue your learning journey.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5be4cb435a04586775c457a3fbcdeb080a06b851" translate="yes" xml:space="preserve">
          <source>Welcome to the Ember Tutorial! This tutorial is meant to introduce basic Ember concepts while creating a professional looking application. If you get stuck at any point during the tutorial, feel free to download &lt;a href=&quot;https://github.com/ember-learn/super-rentals&quot;&gt;https://github.com/ember-learn/super-rentals&lt;/a&gt; for a working example of the completed app.</source>
          <target state="translated">Ember Tutorial에 오신 것을 환영합니다! 이 튜토리얼은 전문적인 응용 프로그램을 만들면서 기본적인 Ember 개념을 소개하기위한 것입니다. 튜토리얼 중 어느 시점에서든 문제가 발생하면 &lt;a href=&quot;https://github.com/ember-learn/super-rentals&quot;&gt;https://github.com/ember-learn/super-rentals&lt;/a&gt; 를 다운로드 하여 완성 된 앱의 실제 예제 를 다운로드 하십시오 .</target>
        </trans-unit>
        <trans-unit id="9842b19893cf1c143654b0168e1196702a8520a6" translate="yes" xml:space="preserve">
          <source>Welcome to the Ember.js Guides! This documentation will take you from total beginner to Ember expert.</source>
          <target state="translated">Ember.js 가이드에 오신 것을 환영합니다! 이 문서는 초보자부터 Ember 전문가까지 안내합니다.</target>
        </trans-unit>
        <trans-unit id="489c59f4db30188992ce5592879b4fcfe217e1f7" translate="yes" xml:space="preserve">
          <source>What Tools Can Help Me?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2bf8908ff31eb0ad409d99921c5c64c1d2f0c96" translate="yes" xml:space="preserve">
          <source>What are Computed Properties?</source>
          <target state="translated">계산 된 속성이란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="c6006257bc079837ccfa8256d6e0abef2c5ce8f4" translate="yes" xml:space="preserve">
          <source>What are Ember Data models?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="965cc49bbf709aa781a3233924d56b6c9a09b261" translate="yes" xml:space="preserve">
          <source>What are Engines?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a45e8ed9d6c9849a9dc59f27c0e9f825db12547b" translate="yes" xml:space="preserve">
          <source>What are other things that you can test for?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="414cbfaecc94d5ca7aa8d5d4b0b070784cc03fbe" translate="yes" xml:space="preserve">
          <source>What are the queues, and what is their priority order?</source>
          <target state="translated">대기열은 무엇이며 우선 순위는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="77a582f0743a83fe16d7738cbbc6fe32a10c6365" translate="yes" xml:space="preserve">
          <source>What array of people to use, via the &lt;code&gt;@people&lt;/code&gt; argument. We'll provide this route's &lt;code&gt;@model&lt;/code&gt; as the list of people.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8084f8358944029b7c618b1c600f50f0008886dc" translate="yes" xml:space="preserve">
          <source>What array of people to use, via the &lt;code&gt;people&lt;/code&gt; attribute. We'll provide this route's &lt;code&gt;model&lt;/code&gt; as the list of people.</source>
          <target state="translated">&lt;code&gt;people&lt;/code&gt; 속성을 통해 사용할 사람들의 배열 이 경로의 &lt;code&gt;model&lt;/code&gt; 을 사람 목록으로 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="4c6a74ca18745291eec4b8e7bd75a3239a0efe03" translate="yes" xml:space="preserve">
          <source>What does &lt;code&gt;setupRenderingTest()&lt;/code&gt; do? First, it uses &lt;code&gt;setupTest()&lt;/code&gt; behind the scenes. Just like in &lt;a href=&quot;../test-types#toc_what-to-watch-out-for&quot;&gt;Unit Tests&lt;/a&gt;, you have access to &lt;code&gt;this.owner&lt;/code&gt;, &lt;code&gt;this.get()&lt;/code&gt;, &lt;code&gt;this.set()&lt;/code&gt;, and &lt;code&gt;pauseTest()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a922ff72dedf9379c499035b1aa5ab32532df37b" translate="yes" xml:space="preserve">
          <source>What happens if I forget to start a run loop in an async handler?</source>
          <target state="translated">비동기 처리기에서 실행 루프를 시작하지 않으면 어떻게됩니까?</target>
        </trans-unit>
        <trans-unit id="cf6ddbfe4d20d55010944430453bfb3e2538ad87" translate="yes" xml:space="preserve">
          <source>What happens in these queues?</source>
          <target state="translated">이 대기열에서 어떻게됩니까?</target>
        </trans-unit>
        <trans-unit id="f549e5aa4336f1737efe7a24d791858c80e0559d" translate="yes" xml:space="preserve">
          <source>What if you want to handle an event in one part of your component by calling a DOM method on another part? For example, let's say you're creating an audio component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45c0fb256c4d03bffb51f5e28bed6782177705a1" translate="yes" xml:space="preserve">
          <source>What is Ember Octane?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ed3f6e9db41f7194c82e74c8365b1cacfa80b07" translate="yes" xml:space="preserve">
          <source>What is Ember?</source>
          <target state="translated">Ember 란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="f976987a119bdc1734e183b718ef7804c4053052" translate="yes" xml:space="preserve">
          <source>What is a Controller?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9138ca30e6c050393ea819ef398598c4601fc85" translate="yes" xml:space="preserve">
          <source>What should you do if you need the &lt;code&gt;model&lt;/code&gt; to return the results of multiple API requests?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd6d4999cbbb3d6716c424f48072b86e1a1f6c9d" translate="yes" xml:space="preserve">
          <source>What the Heck is Shadow DOM?</source>
          <target state="translated">도대체 DOM은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="4c7ba9fcadb7660dfe62b7add263e9829f3b2117" translate="yes" xml:space="preserve">
          <source>What title to use, via the &lt;code&gt;@title&lt;/code&gt; argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c40774de8da3d6f1735ec3622c0cc4f7f489eb8" translate="yes" xml:space="preserve">
          <source>What title to use, via the &lt;code&gt;title&lt;/code&gt; attribute.</source>
          <target state="translated">&lt;code&gt;title&lt;/code&gt; 속성을 통해 사용할 제목</target>
        </trans-unit>
        <trans-unit id="4856f9d805ed3c92102385ef9d0eed847b666a85" translate="yes" xml:space="preserve">
          <source>What to Watch Out for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="425d40f649c4a4a152ad38f28a16151d9e71d616" translate="yes" xml:space="preserve">
          <source>What we need is a way to display the local time if &lt;code&gt;@localTime&lt;/code&gt; exists. We can do this with an &lt;code&gt;if&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b50276f62cd48092fe2b224dc32bc245b64733f6" translate="yes" xml:space="preserve">
          <source>What's happening here is we are adding our own stub maps service that simply creates an empty div. Then we are putting it in Ember's &lt;a href=&quot;https://guides.emberjs.com/applications/dependency-injection#toc_factory-registrations&quot;&gt;registry&lt;/a&gt;, and injecting it into the &lt;code&gt;location-map&lt;/code&gt; component that uses it. That way every time that component is created, our stub map service gets injected over the Google maps service. Now when we run our acceptance tests, you'll notice that maps do not get rendered as the test runs.</source>
          <target state="translated">여기서 일어나는 일은 단순히 빈 div를 만드는 자체 스텁 맵 서비스를 추가하는 것입니다. 그런 다음 Ember의 &lt;a href=&quot;https://guides.emberjs.com/applications/dependency-injection#toc_factory-registrations&quot;&gt;registry&lt;/a&gt; 에 넣고 그것을 사용 하는 &lt;code&gt;location-map&lt;/code&gt; 구성 요소에 주입 합니다. 이렇게하면 구성 요소를 만들 때마다 스텁 맵 서비스가 Google 맵 서비스에 주입됩니다. 이제 승인 테스트를 실행하면 테스트가 실행될 때 맵이 렌더링되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e2354f75bedc71afce4246694064820a904997d1" translate="yes" xml:space="preserve">
          <source>Whatever shows up in the URL at the &lt;code&gt;:post_id&lt;/code&gt;, the dynamic segment, will be available in the params for the route's &lt;code&gt;model&lt;/code&gt; hook:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92b158f903e2985e4cf49bb4bc78b7644c732050" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;autoboot&lt;/code&gt; is disabled, calling &lt;code&gt;visit&lt;/code&gt; would first cause the application to boot, which runs the application initializers.</source>
          <target state="translated">때 &lt;code&gt;autoboot&lt;/code&gt; 불가능 호출 &lt;code&gt;visit&lt;/code&gt; 첫 번째 응용 프로그램 초기화를 실행 부팅에 응용 프로그램을 일으킬 것입니다.</target>
        </trans-unit>
        <trans-unit id="a97db7600a941b8c2922fc7d0191155824b7dd9b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;coordinatePoint&lt;/code&gt; is received from the API, it is expected to be an array:</source>
          <target state="translated">&lt;code&gt;coordinatePoint&lt;/code&gt; 가 API에서 수신 되면 배열이 될 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="ca4c53301080f84de219e124485638a246285643" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;store.findAll(&amp;lt;type&amp;gt;)&lt;/code&gt; is called and a &lt;code&gt;reload&lt;/code&gt; is not initiated, the adapter is presented the opportunity to trigger a new non-blocking (background) request for records of that type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c16991f9228e65d9e9c66fd4c04fb1632071f700" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;store.findAll(&amp;lt;type&amp;gt;)&lt;/code&gt; is called without a &lt;code&gt;reload&lt;/code&gt; option, the adapter is presented the opportunity to trigger a new request for records of that type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64bcb9bda88f06c6f7d931508e844c4c85ee14f4" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;disabled&lt;/em&gt;, this div will not be output. This is usually desirable, but may break the styling of an existing application in subtle ways:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a89f4c37b6fc937f61c56c227c4083c051d5574" translate="yes" xml:space="preserve">
          <source>When Ember first renders a component, it renders the initial &lt;em&gt;state&lt;/em&gt; of that component - the state of the instance, and state of the arguments that are passed to it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8315c0a0f7ae27482af6274c37c80899744e3060" translate="yes" xml:space="preserve">
          <source>When Ember instantiates a controller, view, or other framework component it can attach a dependency to that component. This is often used to provide services to a set of framework components.</source>
          <target state="translated">Ember가 컨트롤러, 뷰 또는 기타 프레임 워크 구성 요소를 인스턴스화하면 해당 구성 요소에 종속성을 연결할 수 있습니다. 이것은 종종 프레임 워크 구성 요소 세트에 서비스를 제공하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9723817b7b18ae317264d92944e92a5ba69baaab" translate="yes" xml:space="preserve">
          <source>When Ember renders a value like &lt;code&gt;{{this.greeting}}&lt;/code&gt; in the template, it takes note of any tracked properties that it encounters, in this case &lt;code&gt;language&lt;/code&gt;. If these values change in the future, it schedules a rerender, and then updates &lt;em&gt;only&lt;/em&gt; the values that could have changed. This means that when &lt;code&gt;language&lt;/code&gt; changes, only the &lt;code&gt;Hello&lt;/code&gt; text in the browser will rerender - Ember leaves the &lt;code&gt;, Jen Weber!&lt;/code&gt; portion completely alone!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6d268aa97a60988690ce67fa45e369ef9323618" translate="yes" xml:space="preserve">
          <source>When Ember renders this template, we get:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f7f428dfb57ca67c18248ff77a041cc6fd944c5" translate="yes" xml:space="preserve">
          <source>When Ember renders this template, you will see the following HTML code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2eb96beec7460653b379fff8aec34c25e0afd889" translate="yes" xml:space="preserve">
          <source>When Promises Reject...</source>
          <target state="translated">약속이 거절 될 때 ...</target>
        </trans-unit>
        <trans-unit id="6928933b74ca93e68fe065e4e82c69f5eba72f13" translate="yes" xml:space="preserve">
          <source>When a component detects that it is time to remove itself from the DOM, Ember will trigger the &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Component.html#event_willDestroyElement&quot;&gt;&lt;code&gt;willDestroyElement()&lt;/code&gt;&lt;/a&gt; method, allowing for any teardown logic to be performed.</source>
          <target state="translated">컴포넌트가 DOM에서 자신을 제거 할 시간임을 감지하면 Ember는 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Component.html#event_willDestroyElement&quot;&gt; &lt;code&gt;willDestroyElement()&lt;/code&gt; &lt;/a&gt; 메소드를 트리거하여 테어 다운 로직을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="60559043c1e6ffcda817b4e753ae1270d6d60184" translate="yes" xml:space="preserve">
          <source>When a controller's query param property is currently set to its default value, this value won't be serialized into the URL. So in the above example, if &lt;code&gt;page&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt;, the URL might look like &lt;code&gt;/articles&lt;/code&gt;, but once someone sets the controller's &lt;code&gt;page&lt;/code&gt; value to &lt;code&gt;2&lt;/code&gt;, the URL will become &lt;code&gt;/articles?page=2&lt;/code&gt;.</source>
          <target state="translated">컨트롤러의 query param 속성이 현재 기본값으로 설정되어 있으면이 값이 URL로 직렬화되지 않습니다. 위의 예에서 &lt;code&gt;page&lt;/code&gt; 가 &lt;code&gt;1&lt;/code&gt; 이면 URL은 &lt;code&gt;/articles&lt;/code&gt; 처럼 보일 수 있지만 누군가 컨트롤러의 &lt;code&gt;page&lt;/code&gt; 값을 &lt;code&gt;2&lt;/code&gt; 로 설정하면 URL은 &lt;code&gt;/articles?page=2&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="71f0172b25858f42459a129f9504adf20cbc9e61" translate="yes" xml:space="preserve">
          <source>When a developer adds a new feature to the &lt;code&gt;canary&lt;/code&gt; channel (i.e. the &lt;code&gt;master&lt;/code&gt; branch on github), they also add an entry to &lt;a href=&quot;https://github.com/emberjs/ember.js/blob/master/FEATURES.md&quot;&gt;&lt;code&gt;FEATURES.md&lt;/code&gt;&lt;/a&gt; explaining what the feature does, and linking to their originating pull request. This list is kept current, and reflects what is available in each channel (&lt;code&gt;release&lt;/code&gt;, &lt;code&gt;beta&lt;/code&gt;, and &lt;code&gt;canary&lt;/code&gt;).</source>
          <target state="translated">개발자가 &lt;code&gt;canary&lt;/code&gt; 채널에 새 기능을 추가하면 (예 : github 의 &lt;code&gt;master&lt;/code&gt; 브랜치) 기능이 무엇인지 설명하고 원래 풀 요청에 연결 하는 항목을 &lt;a href=&quot;https://github.com/emberjs/ember.js/blob/master/FEATURES.md&quot;&gt; &lt;code&gt;FEATURES.md&lt;/code&gt; 에&lt;/a&gt; 추가합니다 . 이 목록은 최신 상태로 유지되며 각 채널에서 사용할 수있는 항목 ( &lt;code&gt;release&lt;/code&gt; , &lt;code&gt;beta&lt;/code&gt; 및 &lt;code&gt;canary&lt;/code&gt; )을 반영합니다.</target>
        </trans-unit>
        <trans-unit id="0fa8cd77765c3c60ecb4a59d7a68466ab220f46c" translate="yes" xml:space="preserve">
          <source>When a new instance is created, its &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Object.html#method_init&quot;&gt;&lt;code&gt;init()&lt;/code&gt;&lt;/a&gt; method is invoked automatically. This is the ideal place to implement setup required on new instances:</source>
          <target state="translated">새 인스턴스가 작성되면 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Object.html#method_init&quot;&gt; &lt;code&gt;init()&lt;/code&gt; &lt;/a&gt; 메소드가 자동으로 호출됩니다. 새로운 인스턴스에 필요한 설정을 구현하기에 이상적인 장소입니다.</target>
        </trans-unit>
        <trans-unit id="beed679da3967bec2aa8a4351e6a947bbe9c786f" translate="yes" xml:space="preserve">
          <source>When a record is already available in the store and is requested again via &lt;code&gt;store.findRecord&lt;/code&gt;, and &lt;code&gt;reload&lt;/code&gt; is not specified as an option in the request, this method is called to determine whether the record should be reloaded prior to returning the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75a68293b40ec67aa969d2056c5f58a41c78b1dc" translate="yes" xml:space="preserve">
          <source>When a record is already available in the store and is requested again via &lt;code&gt;store.findRecord&lt;/code&gt;, and the record does not need to be reloaded prior to return, this method provides the ability to specify whether a refresh of the data for the reload should be scheduled to occur in the background.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="127d57cd6a4f7c4d5d0a4aea37c60c45b1da2f9e" translate="yes" xml:space="preserve">
          <source>When a request errors and your adapter does not have the ability to recover from the error, you may either reject the promise returned by your adapter method with the error or simply throw the error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d1543fb4b5b015042457ca87160036d3cc4c7f9" translate="yes" xml:space="preserve">
          <source>When a transition is attempted, whether via &lt;code&gt;&amp;lt;LinkTo /&amp;gt;&lt;/code&gt;, &lt;code&gt;transitionTo&lt;/code&gt;, or a URL change, a &lt;code&gt;willTransition&lt;/code&gt; action is fired on the currently active routes. This gives each active route, starting with the leaf-most route, the opportunity to decide whether or not the transition should occur.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd147475ad0e68eacc33463a5ee33c1accb6a4b3" translate="yes" xml:space="preserve">
          <source>When a transition is attempted, whether via &lt;code&gt;{{link-to}}&lt;/code&gt;, &lt;code&gt;transitionTo&lt;/code&gt;, or a URL change, a &lt;code&gt;willTransition&lt;/code&gt; action is fired on the currently active routes. This gives each active route, starting with the leaf-most route, the opportunity to decide whether or not the transition should occur.</source>
          <target state="translated">&lt;code&gt;{{link-to}}&lt;/code&gt; , &lt;code&gt;transitionTo&lt;/code&gt; 또는 URL 변경을 통해 전환을 시도 하면 &lt;code&gt;willTransition&lt;/code&gt; 작업이 현재 활성화 된 경로에서 시작됩니다. 이것은 가장 활발한 경로부터 시작하여 각 활성 경로에 전환 발생 여부를 결정할 수있는 기회를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c05f72b55c08ef694a24c0fa35fd9f01a8e3123a" translate="yes" xml:space="preserve">
          <source>When a user comments on a blogPost, we need to create a relationship between the two records. We can simply set the &lt;code&gt;belongsTo&lt;/code&gt; relationship in our new comment:</source>
          <target state="translated">사용자가 blogPost에 댓글을 달 때 두 레코드 간의 관계를 만들어야합니다. 새로운 주석에서 &lt;code&gt;belongsTo&lt;/code&gt; 관계 를 설정하면됩니다 :</target>
        </trans-unit>
        <trans-unit id="9ba430c40dea9616974d43b1952ac6c52744bd7a" translate="yes" xml:space="preserve">
          <source>When a user navigates to &lt;code&gt;/posts&lt;/code&gt;, the contents of &lt;code&gt;index.hbs&lt;/code&gt; will be rendered. This is similar to a user navigating to the child route of &lt;code&gt;/posts&lt;/code&gt;. &lt;code&gt;/posts/index&lt;/code&gt; is child route like &lt;code&gt;/posts/comments&lt;/code&gt; or &lt;code&gt;/posts/likes&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3a8ee7ab3a1dca16668aeae3dae6013c870afab" translate="yes" xml:space="preserve">
          <source>When a user visits a link to your application, they will be automatically upgraded or downgraded to the appropriate &lt;code&gt;Location&lt;/code&gt; class, with the URL transformed accordingly, if needed.</source>
          <target state="translated">사용자가 애플리케이션에 대한 링크를 방문 하면 필요한 경우 URL 이 적절히 변환되어 적절한 &lt;code&gt;Location&lt;/code&gt; 클래스 로 자동 업그레이드되거나 다운 그레이드됩니다 .</target>
        </trans-unit>
        <trans-unit id="c5b7b2935359609128d898dfd758ea026ebff970" translate="yes" xml:space="preserve">
          <source>When a value is used as a helper in a template, the helper manager is looked up on the object by walking up its prototype chain and finding the first helper manager. This manager then receives the value and can create and manage an instance of a helper from it. This provides a layer of indirection that allows users to design high-level helper APIs, without Ember needing to worry about the details. High-level APIs can be experimented with and iterated on while the core of Ember helpers remains stable, and new APIs can be introduced gradually over time to existing code bases.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
