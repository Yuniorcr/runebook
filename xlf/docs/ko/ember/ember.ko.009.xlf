<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="ember">
    <body>
      <group id="ember">
        <trans-unit id="d743a54ea772eeabcfa94500a128f22d956e73e7" translate="yes" xml:space="preserve">
          <source>Standard attribute values applied to the component are treated like &lt;em&gt;plain-old HTML attributes&lt;/em&gt;. This means you can assign any valid HTML attribute, and it will be reflected onto the component directly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbbc2d09acef9d54bec542a8902adc3b0bd87a72" translate="yes" xml:space="preserve">
          <source>Start by running &lt;code&gt;ember g controller rentals/index&lt;/code&gt; to create an index controller for our nested route.</source>
          <target state="translated">실행하여 시작 &lt;code&gt;ember g controller rentals/index&lt;/code&gt; 우리의 중첩 된 경로에 대한 인덱스 컨트롤러를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed3689b34944e00b45a933d94ff2ffb05b06064e" translate="yes" xml:space="preserve">
          <source>Starting index in the array to replace. If idx &amp;gt;= length, then append to the end of the array.</source>
          <target state="translated">대체 할 배열의 인덱스 시작 idx&amp;gt; = length 인 경우 배열 끝에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="50509f2c508c7caf141113627595d51c2a28a0d2" translate="yes" xml:space="preserve">
          <source>Starting with Ember Octane, we recommend using the &lt;code&gt;{{on}}&lt;/code&gt; modifier to call an action on specific events such as the &lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/HTMLElement/input_event&quot;&gt;input event&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a72502067518684f9deeec70cf119fd26326cd33" translate="yes" xml:space="preserve">
          <source>State</source>
          <target state="translated">State</target>
        </trans-unit>
        <trans-unit id="e2943b559f079da6407626d86e22f36963a935be" translate="yes" xml:space="preserve">
          <source>Statements like &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_if&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_unless&quot;&gt;&lt;code&gt;unless&lt;/code&gt;&lt;/a&gt; are implemented as built-in helpers. Helpers can be invoked three ways, each of which is illustrated below with conditionals.</source>
          <target state="translated">문이 좋아하는 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_if&quot;&gt; &lt;code&gt;if&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_unless&quot;&gt; &lt;code&gt;unless&lt;/code&gt; &lt;/a&gt; 내장에 도우미로 구현됩니다. 도우미는 세 가지 방법으로 호출 할 수 있으며 각 방법은 아래에 조건부와 함께 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1feba1e46ddf6c53b1adc00d9107a1d9ebc21a7" translate="yes" xml:space="preserve">
          <source>States are hierarchical and every state is a substate of the &lt;code&gt;RootState&lt;/code&gt;. For example, a record can be in the &lt;code&gt;root.deleted.uncommitted&lt;/code&gt; state, then transition into the &lt;code&gt;root.deleted.inFlight&lt;/code&gt; state. If a child state does not implement an event handler, the state manager will attempt to invoke the event on all parent states until the root state is reached. The state hierarchy of a record is described in terms of a path string. You can determine a record's current state by getting the state's &lt;code&gt;stateName&lt;/code&gt; property:</source>
          <target state="translated">상태는 계층 적이며 모든 상태는 &lt;code&gt;RootState&lt;/code&gt; 의 하위 상태입니다 . 예를 들어, 레코드가있을 수 &lt;code&gt;root.deleted.uncommitted&lt;/code&gt; 로 전환 한 후, 상태 &lt;code&gt;root.deleted.inFlight&lt;/code&gt; 의 상태. 하위 상태가 이벤트 핸들러를 구현하지 않으면 상태 관리자는 루트 상태에 도달 할 때까지 모든 상위 상태에서 이벤트를 호출하려고 시도합니다. 레코드의 상태 계층은 경로 문자열로 설명됩니다. 상태의 &lt;code&gt;stateName&lt;/code&gt; 속성 을 가져와 레코드의 현재 상태를 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fc4ae63f1cc040532b1be2fbda0bb3eb87555b92" translate="yes" xml:space="preserve">
          <source>Static Elements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b16fec19f1cd336c7cc66b43507e900972d3de0" translate="yes" xml:space="preserve">
          <source>Static class elements are &lt;em&gt;not&lt;/em&gt; available on instances, and are only available directly on the class itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79348bf7c01d88bc29dea0babea8fe5b1270f0e6" translate="yes" xml:space="preserve">
          <source>Static class elements are also inherited this way:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00eb37c2ad8ac597d25ead8c96dc4b915e4541c5" translate="yes" xml:space="preserve">
          <source>Sticky Query Param Values</source>
          <target state="translated">고정 쿼리 매개 변수 값</target>
        </trans-unit>
        <trans-unit id="0d8a7046c8d39d9cbd86abcdfb704b161a601f9e" translate="yes" xml:space="preserve">
          <source>Store</source>
          <target state="translated">Store</target>
        </trans-unit>
        <trans-unit id="f1666d2bcbc1f1662ac087a581ceacb42b38e437" translate="yes" xml:space="preserve">
          <source>Store createRecord() vs. push() vs. pushPayload()</source>
          <target state="translated">createRecord () 대 push () 및 pushPayload () 저장</target>
        </trans-unit>
        <trans-unit id="9c9e836e042084875f2706702835fd50f3d499b1" translate="yes" xml:space="preserve">
          <source>Storing and Retrying a Transition</source>
          <target state="translated">전환 저장 및 재시도</target>
        </trans-unit>
        <trans-unit id="3df63b7acb0522da685dad5fe84b81fdd7b25264" translate="yes" xml:space="preserve">
          <source>String</source>
          <target state="translated">String</target>
        </trans-unit>
        <trans-unit id="b3d17fda1094db33050217bb63ea9c24bd2b99dc" translate="yes" xml:space="preserve">
          <source>String or Function</source>
          <target state="translated">문자열 또는 함수</target>
        </trans-unit>
        <trans-unit id="39c8ee4b004e65cdc082fa7eb5ee8ed640fb37c0" translate="yes" xml:space="preserve">
          <source>String,Function</source>
          <target state="translated">String,Function</target>
        </trans-unit>
        <trans-unit id="1c9540a017269c9feb496d71189bffe50f7d5885" translate="yes" xml:space="preserve">
          <source>String...|Array</source>
          <target state="translated">String...|Array</target>
        </trans-unit>
        <trans-unit id="f0d3c25699981cc6a89aac831ec30d8b3c22399b" translate="yes" xml:space="preserve">
          <source>String.w()</source>
          <target state="translated">String.w()</target>
        </trans-unit>
        <trans-unit id="b603ec5b979b7ed45c788051514c9a24004fc62e" translate="yes" xml:space="preserve">
          <source>StringTransform</source>
          <target state="translated">StringTransform</target>
        </trans-unit>
        <trans-unit id="ee053f700e38efa717c2bdfc628b701ca4789740" translate="yes" xml:space="preserve">
          <source>String[]|string</source>
          <target state="translated">String[]|string</target>
        </trans-unit>
        <trans-unit id="3816c4beac471c733eed1d91c213f8c2b6a29262" translate="yes" xml:space="preserve">
          <source>Strings</source>
          <target state="translated">Strings</target>
        </trans-unit>
        <trans-unit id="5e2de559df2862cc71558e06f2eeae9cf0efe5c0" translate="yes" xml:space="preserve">
          <source>Strings will no longer have the convenience methods described in the &lt;a href=&quot;http://emberjs.com/api/classes/Ember.String.html&quot;&gt;&lt;code&gt;Ember.String&lt;/code&gt; API reference&lt;/a&gt;. Instead, you can use the similarly-named methods of the &lt;code&gt;Ember.String&lt;/code&gt; object and pass the string to use as the first parameter:</source>
          <target state="translated">문자열은 더 이상 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.String.html&quot;&gt; &lt;code&gt;Ember.String&lt;/code&gt; API 참조에&lt;/a&gt; 설명 된 편리한 메소드를 갖지 않습니다 . 대신 비슷한 이름의 &lt;code&gt;Ember.String&lt;/code&gt; 객체 메서드 를 사용하고 첫 번째 매개 변수로 사용할 문자열을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac886a143f6aa8b8d037fa39cd99d06520d04d9f" translate="yes" xml:space="preserve">
          <source>Strings will no longer have the convenience methods described in the &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/String&quot;&gt;&lt;code&gt;Ember.String&lt;/code&gt; API reference&lt;/a&gt;. Instead, you can use the similarly-named methods of the &lt;code&gt;Ember.String&lt;/code&gt; object and pass the string to use as the first parameter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3524a89f0508fdccd88639d09b323af881a667b5" translate="yes" xml:space="preserve">
          <source>String|Function</source>
          <target state="translated">String|Function</target>
        </trans-unit>
        <trans-unit id="f9855c2923df85d9ccaa6e5a653e82994824844a" translate="yes" xml:space="preserve">
          <source>String|Function|Array</source>
          <target state="translated">String|Function|Array</target>
        </trans-unit>
        <trans-unit id="096cde0b9a1b5f451a441cdfbe8d57859fd850e0" translate="yes" xml:space="preserve">
          <source>String|Integer</source>
          <target state="translated">String|Integer</target>
        </trans-unit>
        <trans-unit id="7dffcf19da01173ef7755fae671bcdb375a056de" translate="yes" xml:space="preserve">
          <source>String|Number</source>
          <target state="translated">String|Number</target>
        </trans-unit>
        <trans-unit id="c54337b559e9f029d16387ab04f89b68d4a2d8c3" translate="yes" xml:space="preserve">
          <source>String|Number|Object</source>
          <target state="translated">String|Number|Object</target>
        </trans-unit>
        <trans-unit id="7510182a2f01b9f70534bd7ab87456330ddc7be5" translate="yes" xml:space="preserve">
          <source>String|Object</source>
          <target state="translated">String|Object</target>
        </trans-unit>
        <trans-unit id="baca1a7147855eb5795ff280775be4b9cf07d961" translate="yes" xml:space="preserve">
          <source>String|Property</source>
          <target state="translated">String|Property</target>
        </trans-unit>
        <trans-unit id="181ecbb6aef5c83776022689fb77ac544b65b588" translate="yes" xml:space="preserve">
          <source>String|null</source>
          <target state="translated">String|null</target>
        </trans-unit>
        <trans-unit id="7087dd5b60a0e5d36d078de3709bb645d286db69" translate="yes" xml:space="preserve">
          <source>Stubbing Services</source>
          <target state="translated">스터 빙 서비스</target>
        </trans-unit>
        <trans-unit id="27aa4c7ccfa314309a981fe2957b63393d5fce5e" translate="yes" xml:space="preserve">
          <source>Stubbing Services in Acceptance Tests</source>
          <target state="translated">수락 테스트에서 스터 빙 서비스</target>
        </trans-unit>
        <trans-unit id="9dc3603bb97ae39b239f616d1c3f49aa8e97a153" translate="yes" xml:space="preserve">
          <source>Stubbing a method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b04b789fc93b3b824841a8162b871d74667d08e2" translate="yes" xml:space="preserve">
          <source>Stubbing an object</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3107408a50c756bdc03dcf7d5aed6d74eb0c9e3e" translate="yes" xml:space="preserve">
          <source>Stubs</source>
          <target state="translated">Stubs</target>
        </trans-unit>
        <trans-unit id="7457e80447c5b08f0a338e6ccc3e0598378f4591" translate="yes" xml:space="preserve">
          <source>Style it up</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad93ff1976c357fa1090e4a8fa0775d82c5386b1" translate="yes" xml:space="preserve">
          <source>Subclass of Model</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ce6ba148fe8d9ab4a1efa44f043d11727e7f6ee" translate="yes" xml:space="preserve">
          <source>Sublime Text</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87fc913c19cccd1420f6549019e6ab07d2652eb8" translate="yes" xml:space="preserve">
          <source>Submitting a post without a title displays a red validation state on the field and gives the user text indicating that the title is required.</source>
          <target state="translated">제목없이 게시물을 제출하면 필드에 빨간색 유효성 검사 상태가 표시되고 제목이 필요함을 나타내는 텍스트가 사용자에게 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="12d390f8025584ad2ceb29d8156199827eb766f2" translate="yes" xml:space="preserve">
          <source>Submodules</source>
          <target state="translated">Submodules</target>
        </trans-unit>
        <trans-unit id="6ef9815ada2a0398b68221d1261a977ff08f7246" translate="yes" xml:space="preserve">
          <source>Subscribe to a listener by using &lt;code&gt;Ember.subscribe&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Ember.subscribe&lt;/code&gt; 를 사용하여 리스너를 구독 하십시오 .</target>
        </trans-unit>
        <trans-unit id="eb7e7cd9296878731ca54a308b73da381671370f" translate="yes" xml:space="preserve">
          <source>Subscribes a function to a named event and then cancels the subscription after the first time the event is triggered. It is good to use &lt;code&gt;one&lt;/code&gt; when you only care about the first time an event has taken place.</source>
          <target state="translated">명명 된 이벤트에 함수를 구독 한 다음 이벤트가 처음 트리거 된 후 구독을 취소합니다. 사용하는 것이 좋다 &lt;code&gt;one&lt;/code&gt; 당신은 단지 이벤트가 일어난 것은 이번이 처음 관심을 때.</target>
        </trans-unit>
        <trans-unit id="1a236ce5c458753d003516cfdb6d3fbc2147baa0" translate="yes" xml:space="preserve">
          <source>Subscribes to a named event with given function.</source>
          <target state="translated">주어진 기능으로 명명 된 이벤트를 구독합니다.</target>
        </trans-unit>
        <trans-unit id="21ff0eedd4b3be556de21a3ebae1bcf1865e815e" translate="yes" xml:space="preserve">
          <source>Success and failure</source>
          <target state="translated">성공과 실패</target>
        </trans-unit>
        <trans-unit id="8cfff872da8f8d3db914a033e03cf90b9d758302" translate="yes" xml:space="preserve">
          <source>Such features have their implementations guarded by a &quot;feature flag&quot;, and the flag is only activated once the core-data team is prepared to ship the work in a canary release.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12b71c3e0fe5f7c0b8d17cc03186e281412da4a8" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="translated">Summary</target>
        </trans-unit>
        <trans-unit id="37b4f4ecb28fa687bfddae48caa1243e2b716d9c" translate="yes" xml:space="preserve">
          <source>Summary: The Principle of Substitution</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6889fc97e14b42dec11a8c183ea791c5465b658" translate="yes" xml:space="preserve">
          <source>Super</source>
          <target state="translated">Super</target>
        </trans-unit>
        <trans-unit id="d566bb22908b1ec9a9610a20f300bf499e0d3e6f" translate="yes" xml:space="preserve">
          <source>Supplying a model</source>
          <target state="translated">모델 공급</target>
        </trans-unit>
        <trans-unit id="307ad7bba7045cbdfbe8ab3762416f0cfe2eeea8" translate="yes" xml:space="preserve">
          <source>Supplying a tagName</source>
          <target state="translated">tagName 제공</target>
        </trans-unit>
        <trans-unit id="2a1281cd7b34a3b437d33cc93541bd5fe0eac5b8" translate="yes" xml:space="preserve">
          <source>Supplying an explicit dynamic segment value</source>
          <target state="translated">명시 적 동적 세그먼트 값 제공</target>
        </trans-unit>
        <trans-unit id="ac7e6f74b23299de001ce35020dda39ed87fccdf" translate="yes" xml:space="preserve">
          <source>Supplying multiple models</source>
          <target state="translated">여러 모델 공급</target>
        </trans-unit>
        <trans-unit id="3c4685eb55ed20aeb850f996709d097128114b51" translate="yes" xml:space="preserve">
          <source>Support for ES2015/ES6 JavaScript via the &lt;a href=&quot;https://babeljs.io/learn-es2015/&quot;&gt;Babel&lt;/a&gt; project. This includes support for &lt;a href=&quot;http://exploringjs.com/es6/ch_modules.html&quot;&gt;JavaScript modules&lt;/a&gt;, which are used throughout this guide.</source>
          <target state="translated">&lt;a href=&quot;https://babeljs.io/learn-es2015/&quot;&gt;Babel&lt;/a&gt; 프로젝트 를 통해 ES2015 / ES6 JavaScript를 지원합니다 . 여기에는 이 안내서 전체에서 사용되는 &lt;a href=&quot;http://exploringjs.com/es6/ch_modules.html&quot;&gt;JavaScript 모듈에&lt;/a&gt; 대한 지원이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="48012bbbd369e7cf9dbf01a37cf616f579aef634" translate="yes" xml:space="preserve">
          <source>Supported Features</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2c0191bfc5d5b1bd1375a04ab5288df11a1e581" translate="yes" xml:space="preserve">
          <source>Supported Scenarios</source>
          <target state="translated">지원되는 시나리오</target>
        </trans-unit>
        <trans-unit id="f158e8ae8a0fd5a1bbca7308d27f425549f52faa" translate="yes" xml:space="preserve">
          <source>Supporting both block and non-block component usage in one template</source>
          <target state="translated">하나의 템플릿에서 블록 및 비 블록 구성 요소 사용 지원</target>
        </trans-unit>
        <trans-unit id="21d313eca972677af60300d5c32cdc508135a054" translate="yes" xml:space="preserve">
          <source>Supporting different editing styles will require different body components to provide special validation and highlighting. To load a different body component based on editing style, you can yield the component using the &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_component&quot;&gt;&lt;code&gt;component helper&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_hash&quot;&gt;&lt;code&gt;hash helper&lt;/code&gt;&lt;/a&gt;. Here, the appropriate component is assigned to a hash using nested helpers and yielded to the template. Notice &lt;code&gt;editStyle&lt;/code&gt; being used as an argument to the component helper.</source>
          <target state="translated">다른 편집 스타일을 지원하려면 특별한 검증 및 강조를 제공하기 위해 다른 바디 구성 요소가 필요합니다. 편집 스타일을 기반으로 다른 본문 구성 요소를로드하려면 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_component&quot;&gt; &lt;code&gt;component helper&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_hash&quot;&gt; &lt;code&gt;hash helper&lt;/code&gt; &lt;/a&gt; 사용하여 구성 요소를 생성 할 수 있습니다 . 여기에서 중첩 된 도우미를 사용하여 적절한 구성 요소가 해시에 할당되고 템플릿으로 생성됩니다. 공지 사항 &lt;code&gt;editStyle&lt;/code&gt; 는 구성 요소 도우미에 대한 인수로 사용된다.</target>
        </trans-unit>
        <trans-unit id="870b6a43f9969937a6b78668e5f67b305829ac03" translate="yes" xml:space="preserve">
          <source>Suppose we have an object that has a property and a method observing that property.</source>
          <target state="translated">속성이있는 객체와 해당 속성을 관찰하는 메서드가 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="9675587d4669654928b069872d4f2938fc8dc804" translate="yes" xml:space="preserve">
          <source>Suppose you want to integrate your favorite date picker library into an Ember project. Typically, 3rd party JS/jQuery libraries require a DOM element to bind to. So, where is the best place to initialize and attach the library?</source>
          <target state="translated">자주 사용하는 날짜 선택기 라이브러리를 Ember 프로젝트에 통합한다고 가정합니다. 일반적으로 타사 JS / jQuery 라이브러리에는 바인딩 할 DOM 요소가 필요합니다. 그렇다면 라이브러리를 초기화하고 연결하는 가장 좋은 곳은 어디입니까?</target>
        </trans-unit>
        <trans-unit id="54897732f4b63d3c5ff931e91d4d9c2898d5e1a1" translate="yes" xml:space="preserve">
          <source>Suppose, instead, you want the suite to run after every file change. You can enter &lt;code&gt;ember test --server&lt;/code&gt;, or &lt;code&gt;ember t -s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32022615c098204ea1317378c836b09ed172550a" translate="yes" xml:space="preserve">
          <source>Sync relationships</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20aeee9b0344b503f9d7a448f7aba7ca9a8c5cca" translate="yes" xml:space="preserve">
          <source>Synchronous Example</source>
          <target state="translated">동기 예</target>
        </trans-unit>
        <trans-unit id="495d2949869c7e350f566c1678a60431b1cc2fcf" translate="yes" xml:space="preserve">
          <source>Synchronous Helpers</source>
          <target state="translated">동기 헬퍼</target>
        </trans-unit>
        <trans-unit id="342d5495308e369e444baf3f33f246d0bcc29b75" translate="yes" xml:space="preserve">
          <source>Synchronous example:</source>
          <target state="translated">동기식 예 :</target>
        </trans-unit>
        <trans-unit id="d54e57d31e1997c6a23c5f4f4a2538763d613e21" translate="yes" xml:space="preserve">
          <source>Synchronous helpers are performed immediately when triggered.</source>
          <target state="translated">동기 헬퍼는 트리거 될 때 즉시 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="7863003b76de30fb0d39d091532fa48c8ca6a75e" translate="yes" xml:space="preserve">
          <source>Tackling Deprecations</source>
          <target state="translated">지원 중단 문제</target>
        </trans-unit>
        <trans-unit id="1d6f3b9629d6275a16e909978a30680b410d16c9" translate="yes" xml:space="preserve">
          <source>Tag name for the view's outer element. The tag name is only used when an element is first created. If you change the &lt;code&gt;tagName&lt;/code&gt; for an element, you must destroy and recreate the view element.</source>
          <target state="translated">뷰의 외부 요소에 대한 태그 이름입니다. 태그 이름은 요소가 처음 생성 될 때만 사용됩니다. 요소 의 &lt;code&gt;tagName&lt;/code&gt; 을 변경 하면보기 요소를 삭제 한 후 다시 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="eb8e3e9f7283008461ee747f3e130db27bb0a277" translate="yes" xml:space="preserve">
          <source>Take for example the following routes:</source>
          <target state="translated">다음 경로를 예로 들어 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="3ec52ecdefa033f73faa855e208c64afc320736f" translate="yes" xml:space="preserve">
          <source>Takes a string URL and returns a &lt;code&gt;RouteInfo&lt;/code&gt; for the leafmost route represented by the URL. Returns &lt;code&gt;null&lt;/code&gt; if the URL is not recognized. This method expects to receive the actual URL as seen by the browser including the app's &lt;code&gt;rootURL&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49503513d896013da572f384f659640b2f6fdcaa" translate="yes" xml:space="preserve">
          <source>Takes a string URL and returns a promise that resolves to a &lt;code&gt;RouteInfoWithAttributes&lt;/code&gt; for the leafmost route represented by the URL. The promise rejects if the URL is not recognized or an unhandled exception is encountered. This method expects to receive the actual URL as seen by the browser including the app's &lt;code&gt;rootURL&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c60cfa4ea62384dd026b50e8f6e0eed19938e00" translate="yes" xml:space="preserve">
          <source>Takes an ajax response, and returns the json payload or an error.</source>
          <target state="translated">ajax 응답을 가져 와서 json 페이로드 또는 오류를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="2607d7927aff0804548c4b0b185cdde8d7b9102d" translate="yes" xml:space="preserve">
          <source>TalkBack, integrated in Android products</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab8aad230fdba67c86441e29f313daf20e0add73" translate="yes" xml:space="preserve">
          <source>TargetActionSupport</source>
          <target state="translated">TargetActionSupport</target>
        </trans-unit>
        <trans-unit id="f590f0054800d249efd62e16a06110d361c76fc3" translate="yes" xml:space="preserve">
          <source>Teams can gradually refactor an app to use named arguments, separately from upgrading to angle bracket invocation. You don't need to worry about whether the parent used angle brackets or curly brackets. For example, this works just fine:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0782e2070079b67a13f7176a63f28870645b1f6f" translate="yes" xml:space="preserve">
          <source>Template Lifecycle, DOM, and Modifiers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1e8254c86f37cbe15667c32cc8a8a8fff4cd1ef" translate="yes" xml:space="preserve">
          <source>Template compilation.</source>
          <target state="translated">템플릿 편집.</target>
        </trans-unit>
        <trans-unit id="3ac2af30c21f5b1269cc739ce0c14fb3441d07af" translate="yes" xml:space="preserve">
          <source>Template-Only Components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aaa235ac4be56bea19f002cc34ac2da7658f852" translate="yes" xml:space="preserve">
          <source>Template-only components have no backing class instance, so &lt;code&gt;this&lt;/code&gt; in their templates is &lt;code&gt;null&lt;/code&gt;. This means that you can only reference passed in arguments via named argument syntax (e.g. &lt;code&gt;{{@arg}}&lt;/code&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f25b700ed9f092123a43acb205a6869342cf9dd6" translate="yes" xml:space="preserve">
          <source>Templates</source>
          <target state="translated">Templates</target>
        </trans-unit>
        <trans-unit id="e0798b75e7948295bcd979bc81fbd4910dc431b4" translate="yes" xml:space="preserve">
          <source>Templates are HTML</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f26dba0d688990ff76ff8c4eada0b9b5921db5b4" translate="yes" xml:space="preserve">
          <source>Templates are backed with a context. A context is an object from which Handlebars expressions read their properties. In Ember this is often a component. For templates rendered by a route (like &lt;code&gt;application.hbs&lt;/code&gt;), the context is a controller.</source>
          <target state="translated">템플릿은 컨텍스트와 함께 백업됩니다. 컨텍스트는 Handlebars 표현식이 해당 속성을 읽는 객체입니다. Ember에서 이것은 종종 컴포넌트입니다. 경로 ( &lt;code&gt;application.hbs&lt;/code&gt; 와 같은 )로 렌더링 된 템플릿의 경우 컨텍스트는 컨트롤러입니다.</target>
        </trans-unit>
        <trans-unit id="bca019d1b04ef7b9ee38e243a74a67fd82e673fa" translate="yes" xml:space="preserve">
          <source>Templates can also display properties provided to them from their context, which is either a component or a route's controller. For example:</source>
          <target state="translated">템플릿은 구성 요소 또는 경로의 컨트롤러 인 컨텍스트에서 제공되는 속성을 표시 할 수도 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0cb8a4e07271b0d340c62e076dc95d47778b3c6f" translate="yes" xml:space="preserve">
          <source>Templates can use &lt;code&gt;...attributes&lt;/code&gt; to target attributes and element modifiers passed from an angle bracket invocation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="517698063a175f12911d21c0535adc2e76938ecf" translate="yes" xml:space="preserve">
          <source>Templates manage the flow of an application's UI, and display state (through the DOM) to a user. For example, given a component with the property &quot;name&quot;, that component's template can use the name in several ways:</source>
          <target state="translated">템플릿은 응용 프로그램의 UI 흐름을 관리하고 DOM을 통해 사용자에게 상태를 표시합니다. 예를 들어, 속성이 &quot;name&quot;인 구성 요소가 제공된 경우 해당 구성 요소의 템플리트는 여러 가지 방법으로 이름을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21d278837034557e7a9b46210d42d6e7b8075142" translate="yes" xml:space="preserve">
          <source>Terminology</source>
          <target state="translated">Terminology</target>
        </trans-unit>
        <trans-unit id="640ab2bae07bedc4c163f679a746f7ab7fb5d1fa" translate="yes" xml:space="preserve">
          <source>Test</source>
          <target state="translated">Test</target>
        </trans-unit>
        <trans-unit id="51813b0814adc6202a7752710fd028f16f5bf477" translate="yes" xml:space="preserve">
          <source>Test Helpers</source>
          <target state="translated">테스트 도우미</target>
        </trans-unit>
        <trans-unit id="9ba8c6bbd43ca0d7489cc83f242056e6bd9ccd25" translate="yes" xml:space="preserve">
          <source>Test Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71e87427c5c1776079aac1a6e43414bf22f2e47e" translate="yes" xml:space="preserve">
          <source>Test that against the model class of your persistence library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aed406fa903d6e94bc7feee88a130462ff9783a9" translate="yes" xml:space="preserve">
          <source>Test visiting our About and Contact pages</source>
          <target state="translated">정보 및 연락처 페이지 방문 테스트</target>
        </trans-unit>
        <trans-unit id="ffc6d1799bcae14a2ddec680d4c9ccc44518207d" translate="yes" xml:space="preserve">
          <source>TestAdapter</source>
          <target state="translated">TestAdapter</target>
        </trans-unit>
        <trans-unit id="0820b32b206b7352858e8903a838ed14319acdfd" translate="yes" xml:space="preserve">
          <source>Testing</source>
          <target state="translated">Testing</target>
        </trans-unit>
        <trans-unit id="c59410bf3ca2f20fd8b0393728deccf2dc47f93a" translate="yes" xml:space="preserve">
          <source>Testing Actions</source>
          <target state="translated">테스트 동작</target>
        </trans-unit>
        <trans-unit id="ef83d323bedb05179963458a14ff0749094e76b1" translate="yes" xml:space="preserve">
          <source>Testing Application</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc497a114746f541bb8dc098d7f12a25187ca8c6" translate="yes" xml:space="preserve">
          <source>Testing Basics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06b38cb08494d08dd0969ccda46c766ca333f501" translate="yes" xml:space="preserve">
          <source>Testing Components</source>
          <target state="translated">구성 요소 테스트</target>
        </trans-unit>
        <trans-unit id="111ae9c10175e16d69526c94a465e0225d9f1710" translate="yes" xml:space="preserve">
          <source>Testing Computed Properties</source>
          <target state="translated">계산 된 속성 테스트</target>
        </trans-unit>
        <trans-unit id="99b77cfd86fdd51de87c409f5f7edff06aa85329" translate="yes" xml:space="preserve">
          <source>Testing Considerations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91816ac28cf876440112f405559c1a49b916b2f0" translate="yes" xml:space="preserve">
          <source>Testing Controller Actions</source>
          <target state="translated">컨트롤러 동작 테스트</target>
        </trans-unit>
        <trans-unit id="bbdb40de641b7bd903d12a3a7d8dcdf9f0d4da40" translate="yes" xml:space="preserve">
          <source>Testing Controller Needs</source>
          <target state="translated">컨트롤러 요구 사항 테스트</target>
        </trans-unit>
        <trans-unit id="a3634a65dd330502bee5446e899329476bf7ded2" translate="yes" xml:space="preserve">
          <source>Testing Controllers</source>
          <target state="translated">테스트 컨트롤러</target>
        </trans-unit>
        <trans-unit id="fcc10e5ab4dd75f9eb46dbd24ec0395685a9aa13" translate="yes" xml:space="preserve">
          <source>Testing Frameworks</source>
          <target state="translated">테스트 프레임 워크</target>
        </trans-unit>
        <trans-unit id="e309e778695eab20a3a8bc01dba2b39e99684bfe" translate="yes" xml:space="preserve">
          <source>Testing Helpers</source>
          <target state="translated">헬퍼 테스트</target>
        </trans-unit>
        <trans-unit id="f487e84bdaccef5eb28911d350ffc027190e112c" translate="yes" xml:space="preserve">
          <source>Testing Models</source>
          <target state="translated">테스트 모델</target>
        </trans-unit>
        <trans-unit id="82df70ae5a532aff7c33f9b6a39a13c4ceb157d6" translate="yes" xml:space="preserve">
          <source>Testing Object Methods</source>
          <target state="translated">테스트 객체 메소드</target>
        </trans-unit>
        <trans-unit id="10598855856ed90e10e02c787702f60e5e73921b" translate="yes" xml:space="preserve">
          <source>Testing Observers</source>
          <target state="translated">관찰자 테스트</target>
        </trans-unit>
        <trans-unit id="c2719b0d81b37187b81d8b3c83b30f393e2ac71c" translate="yes" xml:space="preserve">
          <source>Testing Our Application As We Go</source>
          <target state="translated">응용 프로그램 테스트</target>
        </trans-unit>
        <trans-unit id="a6c9220ff39e33f54e9415c82938ea24da9ff5cf" translate="yes" xml:space="preserve">
          <source>Testing Relationships</source>
          <target state="translated">테스트 관계</target>
        </trans-unit>
        <trans-unit id="3beda4357979b576777318de0cd80c86b2eba9a4" translate="yes" xml:space="preserve">
          <source>Testing Routes</source>
          <target state="translated">테스트 경로</target>
        </trans-unit>
        <trans-unit id="48d04cd7bff00c397a2449e46bae4e190877dce0" translate="yes" xml:space="preserve">
          <source>Testing User Interaction</source>
          <target state="translated">사용자 상호 작용 테스트</target>
        </trans-unit>
        <trans-unit id="627445291b103d97223f554921c6a4122db19397" translate="yes" xml:space="preserve">
          <source>Testing is a core part of the Ember framework and its development cycle.</source>
          <target state="translated">테스트는 Ember 프레임 워크와 개발주기의 핵심 부분입니다.</target>
        </trans-unit>
        <trans-unit id="9829d58d7519decb98a016ef2876759597109cbf" translate="yes" xml:space="preserve">
          <source>Testing routes can be done both via acceptance or unit tests. Acceptance tests will likely provide better coverage for routes because routes are typically used to perform transitions and load data, both of which are tested more easily in full context rather than isolation.</source>
          <target state="translated">테스트 경로는 승인 또는 단위 테스트를 통해 수행 할 수 있습니다. 일반적으로 경로는 전이 및로드 데이터를 수행하는 데 사용되므로 경로를 더 잘 커버 할 수 있습니다. 둘 다 격리보다는 전체 컨텍스트에서 더 쉽게 테스트됩니다.</target>
        </trans-unit>
        <trans-unit id="4993290ab096c9732f9bb7c79412c75370542561" translate="yes" xml:space="preserve">
          <source>Testing routes can be done both via application tests or container tests. Application tests will likely provide better coverage for routes because routes are typically used to perform transitions and load data, both of which are tested more easily in full context rather than isolation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c06feb4db18fe22ca99f672e2f6701eab0410aae" translate="yes" xml:space="preserve">
          <source>Tests can also be executed when you are running a local development server (started by running &lt;code&gt;ember server&lt;/code&gt;), at the &lt;code&gt;/tests&lt;/code&gt; URI which renders the &lt;code&gt;tests/index.html&lt;/code&gt; template. A word of caution using this approach: Tests run using &lt;code&gt;ember server&lt;/code&gt; have the environment configuration &lt;code&gt;development&lt;/code&gt;, whereas tests executed under &lt;code&gt;ember test --server&lt;/code&gt; are run with the configuration &lt;code&gt;test&lt;/code&gt;. This could cause differences in execution, such as which libraries are loaded and available. Therefore its recommended that you use &lt;code&gt;ember test --server&lt;/code&gt; for test execution.</source>
          <target state="translated">&lt;code&gt;tests/index.html&lt;/code&gt; 템플릿 을 렌더링하는 &lt;code&gt;/tests&lt;/code&gt; URI 에서 로컬 개발 서버 ( &lt;code&gt;ember server&lt;/code&gt; 실행으로 시작)를 실행할 때 테스트를 실행할 수도 있습니다 . 이 접근 방식을 사용할 때주의 할 점 : &lt;code&gt;ember server&lt;/code&gt; 사용하여 실행되는 테스트 에는 환경 구성 &lt;code&gt;development&lt;/code&gt; 이 있고 &lt;code&gt;ember test --server&lt;/code&gt; 에서 실행 된 &lt;code&gt;test&lt;/code&gt; 는 구성 테스트 로 실행됩니다 . 로드되어 사용 가능한 라이브러리와 같은 실행에 차이가 발생할 수 있습니다. 따라서 테스트 실행에 &lt;code&gt;ember test --server&lt;/code&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="397b6080e414f58dca5e208b2d6e35210d1b3660" translate="yes" xml:space="preserve">
          <source>Text Areas</source>
          <target state="translated">텍스트 영역</target>
        </trans-unit>
        <trans-unit id="dc7b11db79436bd2c512f4d9967fc73904ef80da" translate="yes" xml:space="preserve">
          <source>Text field</source>
          <target state="translated">텍스트 필드</target>
        </trans-unit>
        <trans-unit id="f9168144e4f6dc56ba8e02f8cb5754a06a331b7a" translate="yes" xml:space="preserve">
          <source>Text fields</source>
          <target state="translated">텍스트 필드</target>
        </trans-unit>
        <trans-unit id="6803da9ee11ff492530f9c8867cacf0bf23256dc" translate="yes" xml:space="preserve">
          <source>TextArea</source>
          <target state="translated">TextArea</target>
        </trans-unit>
        <trans-unit id="ed595662ad10d27de0f2faece995e2ca2b8e7012" translate="yes" xml:space="preserve">
          <source>TextField</source>
          <target state="translated">TextField</target>
        </trans-unit>
        <trans-unit id="18d077a1a2979a8d6bce31e5dbe43320be8e25bf" translate="yes" xml:space="preserve">
          <source>TextField.max</source>
          <target state="translated">TextField.max</target>
        </trans-unit>
        <trans-unit id="5f0b052f28a0bd79ca6d930fe4c63eb5ecf68887" translate="yes" xml:space="preserve">
          <source>TextField.min</source>
          <target state="translated">TextField.min</target>
        </trans-unit>
        <trans-unit id="18e5d205fad575a252d1a26dc2fa9ef4f4a1b761" translate="yes" xml:space="preserve">
          <source>TextField.size</source>
          <target state="translated">TextField.size</target>
        </trans-unit>
        <trans-unit id="5c2de3d7d34ecad27d764569b0d805502a88a8e0" translate="yes" xml:space="preserve">
          <source>TextField.type</source>
          <target state="translated">TextField.type</target>
        </trans-unit>
        <trans-unit id="27df24da0e29d9bd616074b4f3101aac223ebbe7" translate="yes" xml:space="preserve">
          <source>TextSupport</source>
          <target state="translated">TextSupport</target>
        </trans-unit>
        <trans-unit id="41c7f09b2c8daee02a607c30d9fb577e826692c7" translate="yes" xml:space="preserve">
          <source>Thanks to Ember's setup, you can also use &lt;a href=&quot;https://github.com/emberjs/ember-test-helpers/blob/master/API.md#pausetest&quot;&gt;&lt;code&gt;pauseTest()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://github.com/emberjs/ember-test-helpers/blob/master/API.md#resumetest&quot;&gt;&lt;code&gt;resumeTest()&lt;/code&gt;&lt;/a&gt; to debug your tests. &lt;code&gt;pauseTest&lt;/code&gt; allows you to inspect the DOM easily, but can only be used in the test code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="896ebbfa2a930c2ebb792bc4a285cf153ed60f61" translate="yes" xml:space="preserve">
          <source>Thanks to its use of the &lt;em&gt;adapter pattern&lt;/em&gt;, Ember Data can be configured to work with many different kinds of backends. There is &lt;a href=&quot;http://emberobserver.com/categories/ember-data-adapters&quot;&gt;an entire ecosystem of adapters&lt;/a&gt; and several &lt;a href=&quot;customizing-adapters&quot;&gt;built-in adapters&lt;/a&gt; that allow your Ember app to talk to different types of servers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3412c92e9c7c36dbce60a4d0caa17409de5decd" translate="yes" xml:space="preserve">
          <source>Thanks to its use of the &lt;em&gt;adapter pattern&lt;/em&gt;, Ember Data can be configured to work with many different kinds of backends. There is &lt;a href=&quot;http://emberobserver.com/categories/ember-data-adapters&quot;&gt;an entire ecosystem of adapters&lt;/a&gt; that allow your Ember app to talk to different types of servers without you writing any networking code.</source>
          <target state="translated">&lt;em&gt;어댑터 패턴을&lt;/em&gt; 사용하여 Ember Data는 다양한 종류의 백엔드에서 작동하도록 구성 할 수 있습니다. 이 &lt;a href=&quot;http://emberobserver.com/categories/ember-data-adapters&quot;&gt;어댑터의 전체 생태계&lt;/a&gt; 당신의 엠버 애플 리케이션은 당신이 어떤 네트워킹 코드를 작성하지 않고 서버의 서로 다른 종류의 이야기를 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a27d58e2e3d965544b4feb8e4d0ab324cedc936" translate="yes" xml:space="preserve">
          <source>That app we made is a bit plain. Do you know any CSS? Put your styles in &lt;code&gt;app/styles/app.css&lt;/code&gt;, which is automatically included in your app build.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11b0d72b181597a438cad12584afe940c8ab6127" translate="yes" xml:space="preserve">
          <source>That being said, sometimes it is important to test your routes in a smaller scope. For example, let's say we'd like to have an alert that can be triggered from anywhere within our application. The alert function &lt;code&gt;displayAlert&lt;/code&gt; should be put into the &lt;code&gt;ApplicationRoute&lt;/code&gt; because all actions and events bubble up to it from sub-routes and controllers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="318520d5f37197c6df1e09018c18e851802ae7ae" translate="yes" xml:space="preserve">
          <source>That being said, sometimes it is important to unit test your routes. For example, let's say we'd like to have an alert that can be triggered from anywhere within our application. The alert function &lt;code&gt;displayAlert&lt;/code&gt; should be put into the &lt;code&gt;ApplicationRoute&lt;/code&gt; because all actions and events bubble up to it from sub-routes and controllers.</source>
          <target state="translated">그러나 때때로 경로를 단위 테스트하는 것이 중요합니다. 예를 들어, 애플리케이션 내 어디에서나 트리거 될 수있는 경고를 원한다고 가정 해 봅시다. 모든 조치 및 이벤트가 서브 라우트 및 컨트롤러에서 버블 링되므로 경보 기능 &lt;code&gt;displayAlert&lt;/code&gt; 를 &lt;code&gt;ApplicationRoute&lt;/code&gt; 에 넣어야합니다 .</target>
        </trans-unit>
        <trans-unit id="a36f83caf5ff2b93a1e4e5fcdc3584558ac63704" translate="yes" xml:space="preserve">
          <source>That default configuration matches the wider set of browsers that Ember.js itself supports. However, if your app does not need to support IE anymore, you can change it to:</source>
          <target state="translated">기본 구성은 Ember.js 자체가 지원하는 광범위한 브라우저와 일치합니다. 그러나 앱이 더 이상 IE를 지원할 필요가없는 경우 다음과 같이 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c82a49b447f0a46a1e511a5df799dfb0834560f" translate="yes" xml:space="preserve">
          <source>That file should export a function wrapped with &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Helper.html&quot;&gt;&lt;code&gt;Ember.Helper.helper()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 파일은 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Helper.html&quot;&gt; &lt;code&gt;Ember.Helper.helper()&lt;/code&gt; &lt;/a&gt; 감싸 진 함수를 내 보내야합니다 .</target>
        </trans-unit>
        <trans-unit id="3b922bfea8e08f9290c3bf2fa6bff5f3b54ebd4c" translate="yes" xml:space="preserve">
          <source>That is Ember telling you that it has created:</source>
          <target state="translated">그것은 당신이 그것을 만들었다 고 말하는 Ember입니다.</target>
        </trans-unit>
        <trans-unit id="e0de9e3a4d4633aeeb18a289a56bd4805b9cfcbf" translate="yes" xml:space="preserve">
          <source>That is why Ember CLI exposes a way of configuring what browsers your app targets. It can figure out automatically what features are supported by the browsers you are targeting, and apply the minimum set of transformations possible to your code.</source>
          <target state="translated">그렇기 때문에 Ember CLI는 앱이 대상으로하는 브라우저를 구성하는 방법을 제공합니다. 대상으로하는 브라우저에서 지원하는 기능을 자동으로 파악하고 가능한 최소한의 변환 세트를 코드에 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c3ec01be68e48073d9e918cf0f3b59651463160" translate="yes" xml:space="preserve">
          <source>That makes it easy to remember how to add an action to a component. It's like passing an attribute, but you use the &lt;code&gt;action&lt;/code&gt; helper to pass a function instead.</source>
          <target state="translated">따라서 구성 요소에 동작을 추가하는 방법을 쉽게 기억할 수 있습니다. 속성을 전달하는 것과 비슷하지만 &lt;code&gt;action&lt;/code&gt; 헬퍼를 사용하여 대신 함수를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="78ba75708cf1770d1ec144b19670b70c95278a4c" translate="yes" xml:space="preserve">
          <source>That said, sometimes you may want to make behavior of helpers configurable by the developers that call them from their templates. For example, let's abandon our Americentric ways and update our &lt;code&gt;format-currency&lt;/code&gt; helper to take an optional configuration for which currency symbol to display.</source>
          <target state="translated">즉, 때로는 템플릿에서 호출하는 개발자가 도우미의 동작을 구성 할 수 있도록 할 수도 있습니다. 예를 들어, Americentric 방식을 포기하고 &lt;code&gt;format-currency&lt;/code&gt; 도우미를 업데이트 하여 통화 기호를 표시 할 선택적 구성을 선택해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="d7606bb113640faa278cf7a28f2eb3e24d5170f8" translate="yes" xml:space="preserve">
          <source>That state is what the &lt;code&gt;ApplicationInstance&lt;/code&gt; manages: it is responsible for creating the container that contains all application state, and disposing of it once the particular test run or FastBoot request has finished.</source>
          <target state="translated">이 상태는 &lt;code&gt;ApplicationInstance&lt;/code&gt; 가 관리하는 것입니다. 모든 응용 프로그램 상태를 포함하는 컨테이너를 만들고 특정 테스트 실행 또는 FastBoot 요청이 완료되면 처리합니다.</target>
        </trans-unit>
        <trans-unit id="e53c9021b9ec9d905f7edbfc8bee2fd601077a71" translate="yes" xml:space="preserve">
          <source>That way the generated URL will be deterministic and that simplifies caching mechanisms in the backend.</source>
          <target state="translated">이렇게하면 생성 된 URL이 결정적이고 백엔드의 캐싱 메커니즘이 단순화됩니다.</target>
        </trans-unit>
        <trans-unit id="e2769f35ade6a9d29a01d9c917f9298af7fa4c81" translate="yes" xml:space="preserve">
          <source>That's it for the component: we're translating the user's interactions into &lt;em&gt;state&lt;/em&gt;. Now we need to build a modifier to translate the state into the appropriate DOM method calls!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="9aec71d1c4ae8c3b94a1bb90bf2dfcfdbb43f8ca" translate="yes" xml:space="preserve">
          <source>The &quot;new message&quot; input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="720842f69df82f5d3ebbf07455c593a84d9581a1" translate="yes" xml:space="preserve">
          <source>The &quot;off&quot; branch of feature-flagged code is always stripped from production builds, so you MUST use the build-time environment variable to activate a flag if testing production.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cca06a831613fdc449a54b01a0421b8fde878db7" translate="yes" xml:space="preserve">
          <source>The &quot;this&quot; binding for the callback</source>
          <target state="translated">콜백에 대한 &quot;this&quot;바인딩</target>
        </trans-unit>
        <trans-unit id="ccc5b4bf89b158d0eb41c14adb3ba628e5e78e8e" translate="yes" xml:space="preserve">
          <source>The 'Whoops' error will be thrown on the next turn of the event loop and you can watch for it in your console. You can also handle it using a rejection handler given to &lt;code&gt;.then&lt;/code&gt; or &lt;code&gt;.catch&lt;/code&gt; on the returned promise.</source>
          <target state="translated">다음 번 이벤트 루프에서 '후프'오류가 발생하며 콘솔에서이를 확인할 수 있습니다. 반환 된 약속의 &lt;code&gt;.then&lt;/code&gt; 또는 &lt;code&gt;.catch&lt;/code&gt; 에 제공된 거부 처리기를 사용하여 처리 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="12f898edea55f5f355fe5f02c909ee411cb027ea" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Router.html#method_map&quot;&gt;&lt;code&gt;map()&lt;/code&gt;&lt;/a&gt; method of your Ember application's router can be invoked to define URL mappings. When calling &lt;code&gt;map()&lt;/code&gt;, you should pass a function that will be invoked with the value &lt;code&gt;this&lt;/code&gt; set to an object which you can use to create routes.</source>
          <target state="translated">Ember 애플리케이션 라우터 의 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Router.html#method_map&quot;&gt; &lt;code&gt;map()&lt;/code&gt; &lt;/a&gt; 메소드를 호출하여 URL 매핑을 정의 할 수 있습니다. 호출 할 때 &lt;code&gt;map()&lt;/code&gt; , 당신은 값으로 호출되는 함수 통과해야 &lt;code&gt;this&lt;/code&gt; 당신이 경로를 만드는 데 사용할 수있는 객체로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="23489b054c9d1e661085fd7ade8acb2475375094" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_component&quot;&gt;&lt;code&gt;{{component}}&lt;/code&gt;&lt;/a&gt; helper can be used to defer the selection of a component to run time. The &lt;code&gt;{{my-component}}&lt;/code&gt; syntax always renders the same component, while using the &lt;code&gt;{{component}}&lt;/code&gt; helper allows choosing a component to render on the fly. This is useful in cases where you want to interact with different external libraries depending on the data. Using the &lt;code&gt;{{component}}&lt;/code&gt; helper would allow you to keep different logic well separated.</source>
          <target state="translated">는 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_component&quot;&gt; &lt;code&gt;{{component}}&lt;/code&gt; &lt;/a&gt; 도우미는 런타임에 구성 요소의 선택을 연기 할 수 있습니다. &lt;code&gt;{{my-component}}&lt;/code&gt; 사용하는 동안 구문은 항상 같은 구성 요소를 렌더링 &lt;code&gt;{{component}}&lt;/code&gt; 도우미가 즉시 렌더링 할 구성 요소를 선택하는 허용한다. 이는 데이터에 따라 다른 외부 라이브러리와 상호 작용하려는 경우에 유용합니다. 은 Using &lt;code&gt;{{component}}&lt;/code&gt; 헬퍼하면 잘 분리 된 다른 논리를 유지 할 수있다.</target>
        </trans-unit>
        <trans-unit id="80ffe12423c4f4418b92c52ce25e13ca8840255f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_debugger&quot;&gt;&lt;code&gt;{{debugger}}&lt;/code&gt;&lt;/a&gt; helper provides a handlebars equivalent to JavaScript's &lt;code&gt;debugger&lt;/code&gt; keyword. It will halt execution inside the debugger helper and give you the ability to inspect the current rendering context:</source>
          <target state="translated">&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_debugger&quot;&gt; &lt;code&gt;{{debugger}}&lt;/code&gt; &lt;/a&gt; 헬퍼는 자바 스크립트의 동등한 핸들 제공 &lt;code&gt;debugger&lt;/code&gt; 키워드를. 디버거 도우미 내에서 실행이 중단되고 현재 렌더링 컨텍스트를 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c8f61b48bfab920e95655c42840396a2f3f8014" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_each&quot;&gt;&lt;code&gt;{{#each}}&lt;/code&gt;&lt;/a&gt; helper can have a corresponding &lt;code&gt;{{else}}&lt;/code&gt;. The contents of this block will render if the array passed to &lt;code&gt;{{#each}}&lt;/code&gt; is empty:</source>
          <target state="translated">&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_each&quot;&gt; &lt;code&gt;{{#each}}&lt;/code&gt; &lt;/a&gt; 헬퍼가있을 수 있습니다 해당 &lt;code&gt;{{else}}&lt;/code&gt; . &lt;code&gt;{{#each}}&lt;/code&gt; 에 전달 된 배열 이 비어 있으면이 블록의 내용이 렌더링됩니다 .</target>
        </trans-unit>
        <trans-unit id="6a5dfe3aacaf09268ef43166eeb9e8edcded68ab" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_each-in&quot;&gt;&lt;code&gt;{{#each-in}}&lt;/code&gt;&lt;/a&gt; helper can have a matching &lt;code&gt;{{else}}&lt;/code&gt;. The contents of this block will render if the object is empty, null, or undefined:</source>
          <target state="translated">&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_each-in&quot;&gt; &lt;code&gt;{{#each-in}}&lt;/code&gt; &lt;/a&gt; 도우미는 일치 할 수 있습니다 &lt;code&gt;{{else}}&lt;/code&gt; . 이 블록의 내용은 객체가 비어 있거나 null이거나 정의되지 않은 경우 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="b327dbd565eb9fdd986c4b054241ad5e30065698" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_get&quot;&gt;&lt;code&gt;{{get}}&lt;/code&gt;&lt;/a&gt; helper makes it easy to dynamically send the value of a variable to another helper or component. This can be useful if you want to output one of several values based on the result of a computed property.</source>
          <target state="translated">&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_get&quot;&gt; &lt;code&gt;{{get}}&lt;/code&gt; &lt;/a&gt; 도우미 동적으로 다른 도우미 또는 구성 요소에 변수의 값을 쉽게 전송할을 수 있습니다. 계산 된 속성의 결과에 따라 여러 값 중 하나를 출력하려는 ​​경우에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61302d7882e1a4a6e553fe68b02feeeae75416e4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_input&quot;&gt;&lt;code&gt;{{input}}&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_textarea&quot;&gt;&lt;code&gt;{{textarea}}&lt;/code&gt;&lt;/a&gt; helpers in Ember.js are the easiest way to create common form controls. Using these helpers, you can create form controls that are almost identical to the native HTML &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; elements, but are aware of Ember's two-way bindings and can automatically update.</source>
          <target state="translated">Ember.js 의 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_input&quot;&gt; &lt;code&gt;{{input}}&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_textarea&quot;&gt; &lt;code&gt;{{textarea}}&lt;/code&gt; &lt;/a&gt; 도우미는 일반적인 양식 컨트롤을 만드는 가장 쉬운 방법입니다. 이러한 도우미를 사용하면 네이티브 HTML &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; 요소와 거의 동일한 양식 컨트롤을 만들 수 있지만 Ember의 양방향 바인딩을 인식하고 자동으로 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b85d9f0441c7c29d7da9b855a389e22f68bcf461" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_log&quot;&gt;&lt;code&gt;{{log}}&lt;/code&gt;&lt;/a&gt; helper makes it easy to output variables or expressions in the current rendering context into your browser's console:</source>
          <target state="translated">는 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_log&quot;&gt; &lt;code&gt;{{log}}&lt;/code&gt; &lt;/a&gt; 헬퍼는 브라우저의 콘솔에 현재 렌더링 컨텍스트에서 출력 변수 나 표현에 쉽게 그것을 만드는 :</target>
        </trans-unit>
        <trans-unit id="17f528362a0405c2911a3e6d031edc5b960dfd08" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Test.html#method_fillIn&quot;&gt;&lt;code&gt;fillIn&lt;/code&gt;&lt;/a&gt; helper &quot;fills in&quot; the given text into an input field matching the given selector.</source>
          <target state="translated">&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Test.html#method_fillIn&quot;&gt; &lt;code&gt;fillIn&lt;/code&gt; &lt;/a&gt; 헬퍼 지정된 선택 입력 정합 필드에 지정된 텍스트 &quot;채운다&quot;.</target>
        </trans-unit>
        <trans-unit id="fadd4ef675168e49d87ffb530f6637c11e100846" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Test.html#method_keyEvent&quot;&gt;&lt;code&gt;keyEvent&lt;/code&gt;&lt;/a&gt; helper sends a key stroke event to the UI, simulating the user typing a key.</source>
          <target state="translated">&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Test.html#method_keyEvent&quot;&gt; &lt;code&gt;keyEvent&lt;/code&gt; &lt;/a&gt; 도우미는 키를 입력하는 사용자를 모방하여 UI에 키 스트로크 이벤트를 송신한다.</target>
        </trans-unit>
        <trans-unit id="0aef6d62598e457e26c06a939a5185bf766acd4c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.JSONAPIAdapter.html&quot;&gt;DS.JSONAPIAdapter&lt;/a&gt; has a handful of hooks that are commonly used to extend it to work with non-standard backends.</source>
          <target state="translated">&lt;a href=&quot;http://emberjs.com/api/data/classes/DS.JSONAPIAdapter.html&quot;&gt;DS.JSONAPIAdapter는&lt;/a&gt; 일반적 비표준 백엔드 작동하도록 확장하는 데 사용되는 후크의 소수를 갖는다.</target>
        </trans-unit>
        <trans-unit id="fa3846a6cb3e359333026cfaf3e060eb1aca1350" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://api.emberjs.com/ember-data/release/classes/JSONAPIAdapter&quot;&gt;JSONAPIAdapter&lt;/a&gt; has a handful of hooks that are commonly used to extend it to work with non-standard backends.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e539506c12893b869f4ccb263c9cf65cc67e2d3d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Ember.Templates.helpers/methods#component&quot;&gt;&lt;code&gt;{{component}}&lt;/code&gt;&lt;/a&gt; helper can be used to defer the selection of a component to run time. The &lt;code&gt;&amp;lt;MyComponent /&amp;gt;&lt;/code&gt; syntax always renders the same component, while using the &lt;code&gt;{{component}}&lt;/code&gt; helper allows choosing a component to render on the fly. This is useful in cases where you want to interact with different external libraries depending on the data. Using the &lt;code&gt;{{component}}&lt;/code&gt; helper would allow you to keep different logic well separated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6d00c088d2bffcebcfbbca5d2ccac683a3d8877" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Ember.Templates.helpers/methods#each&quot;&gt;&lt;code&gt;{{#each}}&lt;/code&gt;&lt;/a&gt; helper can also have a corresponding &lt;code&gt;{{else}}&lt;/code&gt;. The contents of this block will render if the array passed to &lt;code&gt;{{#each}}&lt;/code&gt; is empty:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97b388db0523c638573d12d31d2a4f80abe3d2d6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Ember.Templates.helpers/methods#each-in&quot;&gt;&lt;code&gt;{{#each-in}}&lt;/code&gt;&lt;/a&gt; helper can have a matching &lt;code&gt;{{else}}&lt;/code&gt;. The contents of this block will render if the object is empty, null, or undefined:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff90f7755bb2a497299044ed47c55e08f5ae74d5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Ember.Templates.helpers/methods#get&quot;&gt;&lt;code&gt;{{get}}&lt;/code&gt;&lt;/a&gt; helper makes it easy to dynamically send the value of a variable to another helper or component. This can be useful if you want to output one of several values based on the result of a getter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e475fb0b6305f5c59e599d4afd64bc72447dc29" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/EmberRouter/methods#map&quot;&gt;&lt;code&gt;map()&lt;/code&gt;&lt;/a&gt; method of your Ember application's router can be invoked to define URL mappings. When calling &lt;code&gt;map()&lt;/code&gt;, you should pass a function that will be invoked with the value &lt;code&gt;this&lt;/code&gt; set to an object which you can use to create routes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="484456215b5f899d8ed5e829d7551272461d51b9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developers.google.com/maps/documentation/javascript/tutorial&quot;&gt;Google Maps API&lt;/a&gt; requires us to reference its library from a remote script. In this case we'll provide this script to our Ember app via an Addon called &lt;code&gt;ember-simple-google-maps&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developers.google.com/maps/documentation/javascript/tutorial&quot;&gt;Google지도 API는&lt;/a&gt; 원격 스크립트의 라이브러리를 참조하기 위해 우리를 필요로한다. 이 경우 &lt;code&gt;ember-simple-google-maps&lt;/code&gt; 라는 애드온을 통해이 스크립트를 Ember 앱에 제공 합니다 .</target>
        </trans-unit>
        <trans-unit id="abde774e4aee4358f084878a18b8ccc5535273fa" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/ember-codemods/ember-native-class-codemod&quot;&gt;&lt;code&gt;ember-native-class-codemod&lt;/code&gt;&lt;/a&gt; will help you convert your existing code to Native Classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b47055d729e108b5891bf286a66017f614a6dfd8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/emberjs/ember-inspector&quot;&gt;Ember Inspector&lt;/a&gt; is a browser extension that makes it easy to understand and debug your Ember.js application. To learn more, check out the &lt;a href=&quot;https://guides.emberjs.com/ember-inspector/&quot;&gt;dedicated guide&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="721d0aca3cae4958efdc2c786984eea8d65f5f0d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://guides.emberjs.com/addons-and-dependencies/managing-dependencies/#toc_other-assets&quot;&gt;&lt;code&gt;vendor&lt;/code&gt; directory&lt;/a&gt; in Ember is a special directory where you can include content that gets compiled into your application. When Ember CLI builds our app from our source code, it copies &lt;code&gt;ember-tutorial.css&lt;/code&gt; into a file called &lt;code&gt;vendor.css&lt;/code&gt;.</source>
          <target state="translated">Ember 의 &lt;a href=&quot;https://guides.emberjs.com/addons-and-dependencies/managing-dependencies/#toc_other-assets&quot;&gt; &lt;code&gt;vendor&lt;/code&gt; 디렉토리&lt;/a&gt; 는 애플리케이션으로 컴파일 된 컨텐츠를 포함 할 수있는 특수 디렉토리입니다. Ember CLI가 소스 코드에서 앱을 빌드 할 때 &lt;code&gt;ember-tutorial.css&lt;/code&gt; 를 &lt;code&gt;vendor.css&lt;/code&gt; 파일에 복사 합니다.</target>
        </trans-unit>
        <trans-unit id="f3296c43c92a794424bfcbe162e716bebeab8f9f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://guides.emberjs.com/object-model/&quot;&gt;Object Model&lt;/a&gt; section of the Guides describes how to write computed properties, observers, and bindings without prototype extensions. Below you can learn about how to convert existing code to the format now encouraged.</source>
          <target state="translated">안내서의 &lt;a href=&quot;https://guides.emberjs.com/object-model/&quot;&gt;객체 모델&lt;/a&gt; 섹션에서는 프로토 타입 확장없이 계산 된 속성, 관찰자 ​​및 바인딩을 작성하는 방법에 대해 설명합니다. 아래에서 기존 코드를 현재 권장되는 형식으로 변환하는 방법에 대해 배울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1b590693203d5bd4714134ee9bffd8ada6da3b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;LinkTo /&amp;gt;&lt;/code&gt; Component</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="347be04eec0510add3357dc1d233d2f6089d1c4f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;LinkTo /&amp;gt;&lt;/code&gt; component supports specifying query params using the &lt;code&gt;@query&lt;/code&gt; argument, along with the &lt;code&gt;{{hash}}&lt;/code&gt; helper:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="687445d2263e6d351636878f5acc0b61994904dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;LinkTo /&amp;gt;&lt;/code&gt; component takes into account query parameters when determining its &quot;active&quot; state, and will set the class appropriately. The active state is determined by calculating whether the query params end up the same after clicking a link. You don't have to supply all of the current, active query params for this to be true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a313e65540f5651b2749a64d99e0b7dd0f4677e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;LinkTo /&amp;gt;&lt;/code&gt; component will also add an &lt;code&gt;active&lt;/code&gt; class to the link that points to the currently active route.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd9594d821d9c211c549857aa931470d2546f2bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--filter&lt;/code&gt; option is more versatile. You can provide a phrase to match against the modules and test descriptions. A test description is what appears in &lt;code&gt;test()&lt;/code&gt; in QUnit, or &lt;code&gt;it()&lt;/code&gt; in Mocha.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01eacb2dc451f3841a67b62498f8892723ba638d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--module&lt;/code&gt; option allows you to select a &lt;strong&gt;module&lt;/strong&gt;&amp;mdash;a group of tests that you specified in &lt;code&gt;module()&lt;/code&gt; in QUnit, or &lt;code&gt;describe()&lt;/code&gt; in Mocha.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="359579dfab0ea7c705e6923622a9025aba3dd10a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;...attributes&lt;/code&gt; syntax determines where the attributes from a tag should appear in the component's template. Any number of attributes can be specified on the avatar component now, and they will all end up on the element that has &lt;code&gt;...attributes&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e78ddd2c47b691451039e46345569728779e14b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@action&lt;/code&gt; Decorator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec58632f6fb0c70a2661a8dce020b12cc0c7068f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@action&lt;/code&gt; decorator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68e0b4da4e97bb8a4ecbf77fefad05e5c85f569b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@model&lt;/code&gt; argument is merely a special case for the more general &lt;code&gt;@models&lt;/code&gt; argument. Therefore, it is an error to pass &lt;em&gt;both&lt;/em&gt; arguments at the same time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37581d1dd710f3e6c4f8c88b9087421a235020be" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@query&lt;/code&gt; argument, along with the &lt;code&gt;{{hash}}&lt;/code&gt; helper, can be used to set query params on a link:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afc25db1ba24f7959dcc95ab020bb73280d21a8e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@route&lt;/code&gt; argument is the name of the route to link to, and the &lt;code&gt;@model&lt;/code&gt; argument is a model object to fill in the &lt;a href=&quot;https://guides.emberjs.com/routing/defining-your-routes/#toc_dynamic-segments&quot;&gt;dynamic segment&lt;/a&gt; for the route.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3016cd065a1ea33674454f4b4409c5a76ecee77d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ApplicationInstance&lt;/code&gt; encapsulates all of the stateful aspects of a running &lt;code&gt;Application&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ApplicationInstance&lt;/code&gt; 실행중인의 상태 측면을 모두 캡슐화 &lt;code&gt;Application&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f930fd3f23af023ef9f744a703e14d94dcebcaeb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BlogPost&lt;/code&gt; model would have properties like:</source>
          <target state="translated">&lt;code&gt;BlogPost&lt;/code&gt; 모델과 같은 특성을 가지고 것입니다 :</target>
        </trans-unit>
        <trans-unit id="ea79958a2feaa365d1dd1e72a888a59ebe1b581f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BooleanTransform&lt;/code&gt; class is used to serialize and deserialize boolean attributes on Ember Data record objects. This transform is used when &lt;code&gt;boolean&lt;/code&gt; is passed as the type parameter to the &lt;a href=&quot;https://api.emberjs.com/ember-data/release/functions/@ember-data%2Fmodel/attr&quot;&gt;attr&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fae849844f7c3ca3ad9b933a44e600ae65479143" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BroadwayStar&lt;/code&gt; class contains three methods: &lt;code&gt;say()&lt;/code&gt;, &lt;code&gt;sing()&lt;/code&gt;, and &lt;code&gt;dance()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BroadwayStar&lt;/code&gt; 의 : 클래스는 세 가지 방법이 포함되어 &lt;code&gt;say()&lt;/code&gt; , &lt;code&gt;sing()&lt;/code&gt; 와 &lt;code&gt;dance()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d63f1b0f445b29ddfc61aeec73fb12eb211d5567" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ContainerDebugAdapter&lt;/code&gt; helps the container and resolver interface with tools that debug Ember such as the &lt;a href=&quot;https://github.com/emberjs/ember-inspector&quot;&gt;Ember Inspector&lt;/a&gt; for Chrome and Firefox.</source>
          <target state="translated">&lt;code&gt;ContainerDebugAdapter&lt;/code&gt; 는 등 같은 디버그 엠버 그 도구를 사용하여 용기 및 해결 프로그램 인터페이스 도움 &lt;a href=&quot;https://github.com/emberjs/ember-inspector&quot;&gt;엠버 경위&lt;/a&gt; 크롬과 파이어 폭스를.</target>
        </trans-unit>
        <trans-unit id="2b819ff65f7652ad8943fa82a80ca24f474b2a1d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DS.BooleanTransform&lt;/code&gt; class is used to serialize and deserialize boolean attributes on Ember Data record objects. This transform is used when &lt;code&gt;boolean&lt;/code&gt; is passed as the type parameter to the &lt;a href=&quot;https://emberjs.com/api/ember-data/data#method_attr&quot;&gt;DS.attr&lt;/a&gt; function.</source>
          <target state="translated">&lt;code&gt;DS.BooleanTransform&lt;/code&gt; 의 클래스는 직렬화에 사용 엠버 데이터 레코드 개체에 대한 부울 속성을 역 직렬화된다. 이 변환은 &lt;code&gt;boolean&lt;/code&gt; 이 유형 매개 변수로 &lt;a href=&quot;https://emberjs.com/api/ember-data/data#method_attr&quot;&gt;DS.attr&lt;/a&gt; 함수에 전달 될 때 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="bd3e9a0eed710efe4a88384528b918c339217700" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DS.DateTransform&lt;/code&gt; class is used to serialize and deserialize date attributes on Ember Data record objects. This transform is used when &lt;code&gt;date&lt;/code&gt; is passed as the type parameter to the &lt;a href=&quot;https://emberjs.com/api/ember-data/data#method_attr&quot;&gt;DS.attr&lt;/a&gt; function. It uses the &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;&lt;code&gt;ISO 8601&lt;/code&gt;&lt;/a&gt; standard.</source>
          <target state="translated">&lt;code&gt;DS.DateTransform&lt;/code&gt; 의 클래스는 직렬화에 사용되며, 직렬화 날짜 엠버 데이터 레코드 객체에 속성. 이 변환은 &lt;code&gt;date&lt;/code&gt; 가 유형 매개 변수로 &lt;a href=&quot;https://emberjs.com/api/ember-data/data#method_attr&quot;&gt;DS.attr&lt;/a&gt; 함수에 전달 될 때 사용됩니다 . &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt; &lt;code&gt;ISO 8601&lt;/code&gt; &lt;/a&gt; 표준을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="2982cc3dc82ca2b47f88e8fdbe38cb683d0cbfa8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DS.Model&lt;/code&gt; states are themselves stateless. What that means is that, the hierarchical states that each of &lt;em&gt;those&lt;/em&gt; points to is a shared data structure. For performance reasons, instead of each record getting its own copy of the hierarchy of states, each record points to this global, immutable shared instance. How does a state know which record it should be acting on? We pass the record instance into the state's event handlers as the first argument.</source>
          <target state="translated">그만큼 &lt;code&gt;DS.Model&lt;/code&gt; 의 상태는 그 자체가 상태입니다. 그 수단이, 계층 상태 란이 각각 &lt;em&gt;그&lt;/em&gt; 포인트 공유 데이터 구조에 관한 것이다. 성능상의 이유로 각 레코드가 고유 한 상태 계층 복사본을 가져 오는 대신 각 레코드는 변경 불가능한이 전역 공유 인스턴스를 가리 킵니다. 국가는 어떤 기록이 행동해야하는지 어떻게 알 수 있습니까? 레코드 인스턴스를 첫 번째 인수로 상태의 이벤트 핸들러에 전달합니다.</target>
        </trans-unit>
        <trans-unit id="f0eb91368a9212981a5c1132e3c4cf949c7a59b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DS.NumberTransform&lt;/code&gt; class is used to serialize and deserialize numeric attributes on Ember Data record objects. This transform is used when &lt;code&gt;number&lt;/code&gt; is passed as the type parameter to the &lt;a href=&quot;https://emberjs.com/api/ember-data/data#method_attr&quot;&gt;DS.attr&lt;/a&gt; function.</source>
          <target state="translated">&lt;code&gt;DS.NumberTransform&lt;/code&gt; 의 클래스는 직렬화에 사용 엠버 데이터 레코드 개체의 숫자 속성을 역 직렬화된다. 이 변환은 &lt;code&gt;number&lt;/code&gt; 가 유형 매개 변수로 &lt;a href=&quot;https://emberjs.com/api/ember-data/data#method_attr&quot;&gt;DS.attr&lt;/a&gt; 함수에 전달 .</target>
        </trans-unit>
        <trans-unit id="57ede3918d3480e3b06e6aa03ddac19ce5a83194" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DS.StringTransform&lt;/code&gt; class is used to serialize and deserialize string attributes on Ember Data record objects. This transform is used when &lt;code&gt;string&lt;/code&gt; is passed as the type parameter to the &lt;a href=&quot;https://emberjs.com/api/ember-data/data#method_attr&quot;&gt;DS.attr&lt;/a&gt; function.</source>
          <target state="translated">&lt;code&gt;DS.StringTransform&lt;/code&gt; 의 클래스는 직렬화에 사용되며, 직렬화 문자열은 엠버 데이터 레코드 객체에 속성. 이 변환은 &lt;code&gt;string&lt;/code&gt; 이 유형 매개 변수로 &lt;a href=&quot;https://emberjs.com/api/ember-data/data#method_attr&quot;&gt;DS.attr&lt;/a&gt; 함수에 전달 .</target>
        </trans-unit>
        <trans-unit id="4c7d84bb5ae36b5bebe679b64273fe856da64324" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DS.Transform&lt;/code&gt; class is used to serialize and deserialize model attributes when they are saved or loaded from an adapter. Subclassing &lt;code&gt;DS.Transform&lt;/code&gt; is useful for creating custom attributes. All subclasses of &lt;code&gt;DS.Transform&lt;/code&gt; must implement a &lt;code&gt;serialize&lt;/code&gt; and a &lt;code&gt;deserialize&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;DS.Transform&lt;/code&gt; 의 클래스는 직렬화에 사용하고 저장하거나 어댑터에서로드 할 때 직렬화 모델 속성. 서브 클래 &lt;code&gt;DS.Transform&lt;/code&gt; 은 사용자 정의 속성을 작성하는 데 유용합니다. &lt;code&gt;DS.Transform&lt;/code&gt; 의 모든 하위 클래스 는 &lt;code&gt;serialize&lt;/code&gt; 를 구현해야합니다. 및 &lt;code&gt;deserialize&lt;/code&gt; 메서드를 .</target>
        </trans-unit>
        <trans-unit id="ce0eb8c05c343a64394f217c251dbdb597172f5e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DataAdapter&lt;/code&gt; helps a data persistence library interface with tools that debug Ember such as the &lt;a href=&quot;https://github.com/emberjs/ember-inspector&quot;&gt;Ember Inspector&lt;/a&gt; for Chrome and Firefox.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e00a79faab114e9901c4f0599964d16729665318" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DataAdapter&lt;/code&gt; helps a data persistence library interface with tools that debug Ember such as the &lt;a href=&quot;https://github.com/tildeio/ember-extension&quot;&gt;Ember Extension&lt;/a&gt; for Chrome and Firefox.</source>
          <target state="translated">그만큼 &lt;code&gt;DataAdapter&lt;/code&gt; 데이터가 같은 같은 디버그 엠버 그 도구를 사용하여 라이브러리 인터페이스 지속성하는 데 도움이 &lt;a href=&quot;https://github.com/tildeio/ember-extension&quot;&gt;엠버 확장&lt;/a&gt; 크롬과 파이어 폭스를.</target>
        </trans-unit>
        <trans-unit id="41477828cb10d4407ff68edf944f4673b8b65cc4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DateTransform&lt;/code&gt; class is used to serialize and deserialize date attributes on Ember Data record objects. This transform is used when &lt;code&gt;date&lt;/code&gt; is passed as the type parameter to the &lt;a href=&quot;https://api.emberjs.com/ember-data/release/functions/@ember-data%2Fmodel/attr&quot;&gt;attr&lt;/a&gt; function. It uses the &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;&lt;code&gt;ISO 8601&lt;/code&gt;&lt;/a&gt; standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="244c350309c03449bf979421f09fb8c35aecdbe0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ENV&lt;/code&gt; object is defined at build time, but you can access the &lt;code&gt;ENV&lt;/code&gt; object in application code via import from &lt;code&gt;your-application-name/config/environment&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="319307645bea1fa807d738e83c0a90cd1cf5ef96" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Ember.EventDispatcher&lt;/code&gt; responsible for delegating events to this application's views.</source>
          <target state="translated">그만큼 &lt;code&gt;Ember.EventDispatcher&lt;/code&gt; 이 응용 프로그램의 뷰에 이벤트를 위임 할 책임 Ember.EventDispatcher 입니다.</target>
        </trans-unit>
        <trans-unit id="5a1153767edf9a9bc5406d38e28481d0c34bda34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Ember.Mixin&lt;/code&gt; class allows you to create mixins, whose properties can be added to other classes. For instance,</source>
          <target state="translated">그만큼 &lt;code&gt;Ember.Mixin&lt;/code&gt; 의 클래스는 그 속성을 다른 클래스에 추가 할 수 있습니다 유지 mixin을 만들 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="6a4036df61adabd029b6eba87bb294575bc9d7bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Ember.Route&lt;/code&gt; class is used to define individual routes. Refer to the &lt;a href=&quot;https://emberjs.com/guides/routing/&quot;&gt;routing guide&lt;/a&gt; for documentation.</source>
          <target state="translated">&lt;code&gt;Ember.Route&lt;/code&gt; 클래스는 각각의 경로를 정의하는 데 사용됩니다. &lt;a href=&quot;https://emberjs.com/guides/routing/&quot;&gt;설명서&lt;/a&gt; 는 라우팅 가이드 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="885e6e3f5749d0e1ec5e434cb9dfa2078fb80a8d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Ember.Router&lt;/code&gt; class manages the application state and URLs. Refer to the &lt;a href=&quot;https://emberjs.com/guides/routing/&quot;&gt;routing guide&lt;/a&gt; for documentation.</source>
          <target state="translated">&lt;code&gt;Ember.Router&lt;/code&gt; 클래스는 응용 프로그램 상태와 URL을 관리합니다. &lt;a href=&quot;https://emberjs.com/guides/routing/&quot;&gt;설명서&lt;/a&gt; 는 라우팅 안내서 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fc3fc88704387afa16f9189be9903ddb6b3dedbb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Ember.run&lt;/code&gt; method can be used to create a run loop. In this example, &lt;code&gt;Ember.run&lt;/code&gt; is used to handle an online event (browser gains internet access) and run some Ember code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="211a8a0ab63aee094d2b679406429c9861efd416" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Ember.run&lt;/code&gt; method can be used to create a run loop. In this example, jQuery and &lt;code&gt;Ember.run&lt;/code&gt; are used to handle a click event and run some Ember code.</source>
          <target state="translated">&lt;code&gt;Ember.run&lt;/code&gt; 방법은 실행 루프를 만드는 데 사용할 수 있습니다. 이 예제에서 jQuery 및 &lt;code&gt;Ember.run&lt;/code&gt; 은 클릭 이벤트를 처리하고 일부 Ember 코드를 실행하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bd4497b1227e625d2656dcafaf6cfe898268e734" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;EmberRouter&lt;/code&gt; class manages the application state and URLs. Refer to the &lt;a href=&quot;https://guides.emberjs.com/release/routing/&quot;&gt;routing guide&lt;/a&gt; for documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c7c53858dc783a25f5941955654a26b7b31a8c4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Engine&lt;/code&gt; class contains core functionality for both applications and engines.</source>
          <target state="translated">그만큼 &lt;code&gt;Engine&lt;/code&gt; 클래스는 응용 프로그램과 엔진 모두를위한 핵심 기능이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="14638c0630a0a3cff87817f36c2554b1c8d6490b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;EngineInstance&lt;/code&gt; encapsulates all of the stateful aspects of a running &lt;code&gt;Engine&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;EngineInstance&lt;/code&gt; 는 실행중인의 상태 측면을 모두 캡슐화 &lt;code&gt;Engine&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef790b8517960a1d3695e93af0bd1b8f3839440a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;JSONAPIAdapter&lt;/code&gt; is smart enough to determine the URLs it communicates with based on the name of the model. For example, if you ask for a &lt;code&gt;Post&lt;/code&gt; by ID:</source>
          <target state="translated">&lt;code&gt;JSONAPIAdapter&lt;/code&gt; 는 이 모델의 이름을 기반으로 통신하는 URL을 결정하는 스마트 충분하다. 예를 들어 &lt;code&gt;Post&lt;/code&gt; ID 별 게시물 :</target>
        </trans-unit>
        <trans-unit id="c950fbe2c97da63e2b034eaca1b0c609b4171279" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;JSONAPIAdapter&lt;/code&gt; is the default adapter used by Ember Data. It is responsible for transforming the store's requests into HTTP requests that follow the &lt;a href=&quot;http://jsonapi.org/format/&quot;&gt;JSON API&lt;/a&gt; format.</source>
          <target state="translated">&lt;code&gt;JSONAPIAdapter&lt;/code&gt; 은 엠버 데이터가 사용하는 기본 어댑터입니다. 상점의 요청을 HTTP 요청으로 변환하는 책임이 있습니다.&lt;a href=&quot;http://jsonapi.org/format/&quot;&gt; JSON API&lt;/a&gt; 형식 합니다.</target>
        </trans-unit>
        <trans-unit id="34c3733779dc0df0421669354af118f5e875520e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;JSONAPISerializer&lt;/code&gt; expects the backend to return a JSON API Document that follows the JSON API specification and the conventions of the examples found on &lt;a href=&quot;http://jsonapi.org/format/&quot;&gt;http://jsonapi.org/format&lt;/a&gt;. This means all type names should be pluralized and attribute and relationship names should be dash-cased. For example, if you request a record from &lt;code&gt;/people/123&lt;/code&gt;, the response should look like this:</source>
          <target state="translated">&lt;code&gt;JSONAPISerializer&lt;/code&gt; 는 백엔드는 JSON의 API 사양 및에있는 예제의 규칙을 따르는 JSON API 문서 반환 할 것으로 예상 &lt;a href=&quot;http://jsonapi.org/format/&quot;&gt;http://jsonapi.org/format을&lt;/a&gt; . 즉, 모든 유형 이름은 복수형이어야하고 속성 및 관계 이름은 대괄호로 묶어야합니다. 예를 들어, &lt;code&gt;/people/123&lt;/code&gt; 하면 응답은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="167dca6fcf30ad4dd3f48bce7dfddbeff3a42de4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;JSONAPISerializer&lt;/code&gt; expects the backend to return a JSON:API Document that follows the JSON:API specification and the conventions of the examples found in the &lt;a href=&quot;http://jsonapi.org/format/&quot;&gt;JSON:API spec&lt;/a&gt;. This means all type names should be pluralized and attribute and relationship names should be dash-cased. For example, if you request a record from &lt;code&gt;/people/123&lt;/code&gt;, the response should look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a163a2de99844b44ded1af52c454ec8cb95bad1f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;JSONAPISerializer&lt;/code&gt; is built on top of the &lt;code&gt;JSONSerializer&lt;/code&gt; so they share many of the same hooks for customizing the behavior of the serialization process. Be sure to check out the &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.JSONSerializer.html&quot;&gt;API docs&lt;/a&gt; for a full list of methods and properties.</source>
          <target state="translated">&lt;code&gt;JSONAPISerializer&lt;/code&gt; 은 의 상단에 내장되어 &lt;code&gt;JSONSerializer&lt;/code&gt; 가 직렬화 프로세스의 동작을 사용자 정의에 대해 같은 후크의 많은 것을 공유 할 수 있도록. 확인하십시오&lt;a href=&quot;http://emberjs.com/api/data/classes/DS.JSONSerializer.html&quot;&gt;&lt;/a&gt;메서드 및 속성의 전체 목록은 API 문서 .</target>
        </trans-unit>
        <trans-unit id="c9d170221457f84b4fd18fe32d97e55372499905" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;JSONAPISerializer&lt;/code&gt; is built on top of the &lt;code&gt;JSONSerializer&lt;/code&gt; so they share many of the same hooks for customizing the behavior of the serialization process. Be sure to check out the &lt;a href=&quot;https://api.emberjs.com/ember-data/release/classes/JSONSerializer&quot;&gt;API docs&lt;/a&gt; for a full list of methods and properties.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2372e29f3591a6e06a86749f11f23bc152d06ae0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;JSONSerializer&lt;/code&gt; normalization process follows these steps:</source>
          <target state="translated">&lt;code&gt;JSONSerializer&lt;/code&gt; 정상화 과정은 다음 단계에 따라 :</target>
        </trans-unit>
        <trans-unit id="f4cd750db3d7f36c53872e7b66a6bfdeb3cd648b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LOG_STACKTRACE_ON_DEPRECATION&lt;/code&gt; property, when true, tells Ember to log a full stack trace during deprecation warnings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53b8ccc5add83e52a73670fa9d3c40bfe82b5d45" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LOG_VERSION&lt;/code&gt; property, when true, tells Ember to log versions of all dependent libraries in use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8d7134db8562c548ba83e1398f6d35393db9323" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Last Update: {{lastUpdateTimestamp}}&lt;/code&gt; will be rendered in place of the &lt;code&gt;{{yield}}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Last Update: {{lastUpdateTimestamp}}&lt;/code&gt; 의 위치에 렌더링됩니다 &lt;code&gt;{{yield}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d22551ec5b53f6d68685e639c7e1e39180f00ac3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Last Update: {{this.lastUpdateTimestamp}}&lt;/code&gt; will be rendered in place of the &lt;code&gt;{{yield}}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="595ef6a646450a473c800b0f4386c1825ddf018a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ManyArray&lt;/code&gt; is instantiated lazily the first time the relationship is requested.</source>
          <target state="translated">&lt;code&gt;ManyArray&lt;/code&gt; 는 게으르게 관계가 요청 처음 인스턴스화됩니다.</target>
        </trans-unit>
        <trans-unit id="0b6f84c2a781e6980287c45f8d8ed99e438f68e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Mixin&lt;/code&gt; class allows you to create mixins, whose properties can be added to other classes. For instance,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0312be95af27e29522a08b2babcd2ab09013f545" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NumberTransform&lt;/code&gt; class is used to serialize and deserialize numeric attributes on Ember Data record objects. This transform is used when &lt;code&gt;number&lt;/code&gt; is passed as the type parameter to the &lt;a href=&quot;https://api.emberjs.com/ember-data/release/functions/@ember-data%2Fmodel/attr&quot;&gt;attr&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c84f7566c1be766c1e06e2454452912739ec439" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Route&lt;/code&gt; class is used to define individual routes. Refer to the &lt;a href=&quot;https://guides.emberjs.com/release/routing/&quot;&gt;routing guide&lt;/a&gt; for documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dfb03cf2957c12e3cd48a12a2a6c5c0716c3419" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Router.map&lt;/code&gt; function allows you to define mappings from URLs to routes in your application. These mappings are defined within the supplied callback function using &lt;code&gt;this.route&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Router.map&lt;/code&gt; 의 기능을 사용하면 응용 프로그램의 루트에 URL의 매핑을 정의 할 수 있습니다. 이러한 매핑은 &lt;code&gt;this.route&lt;/code&gt; 를 사용하여 제공된 콜백 함수 내에 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="50007ea5308c43c38c5dd9b4b9985e647fb8482a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;StringTransform&lt;/code&gt; class is used to serialize and deserialize string attributes on Ember Data record objects. This transform is used when &lt;code&gt;string&lt;/code&gt; is passed as the type parameter to the &lt;a href=&quot;https://api.emberjs.com/ember-data/release/functions/@ember-data%2Fmodel/attr&quot;&gt;attr&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b94bcc514f833c5ef1923bb0c25457ea933534f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;action&lt;/code&gt; helper allows you to add event listeners to elements and call named functions. By default, the &lt;code&gt;action&lt;/code&gt; helper adds a &lt;code&gt;click&lt;/code&gt; event listener, but it can be used to listen for any element event. Now, when the &lt;code&gt;li&lt;/code&gt; element is clicked a &lt;code&gt;showPerson&lt;/code&gt; function will be called from the &lt;code&gt;actions&lt;/code&gt; object in the &lt;code&gt;people-list&lt;/code&gt; component. Think of this like calling &lt;code&gt;this.actions.showPerson(person)&lt;/code&gt; from our template.</source>
          <target state="translated">&lt;code&gt;action&lt;/code&gt; 도우미는 요소에 이벤트 리스너를 추가하고 이름이 지정된 함수를 호출 할 수 있습니다. 기본적으로 &lt;code&gt;action&lt;/code&gt; 헬퍼는 &lt;code&gt;click&lt;/code&gt; 이벤트 리스너를 추가 하지만 모든 요소 이벤트를 청취하는 데 사용할 수 있습니다. 이제 &lt;code&gt;li&lt;/code&gt; 요소를 클릭하면 &lt;code&gt;people-list&lt;/code&gt; 구성 요소 의 &lt;code&gt;actions&lt;/code&gt; 오브젝트에서 &lt;code&gt;showPerson&lt;/code&gt; 함수가 호출됩니다 . 템플릿에서 &lt;code&gt;this.actions.showPerson(person)&lt;/code&gt; 을 호출하는 것과 같이 이것을 생각하십시오 .</target>
        </trans-unit>
        <trans-unit id="6781996b5d8528d30fde9ec99ae34a524c6762c6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;actions&lt;/code&gt; hash will inherit action handlers from the &lt;code&gt;actions&lt;/code&gt; hash defined on extended parent classes or mixins rather than just replace the entire hash, e.g.:</source>
          <target state="translated">&lt;code&gt;actions&lt;/code&gt; 해시는에서 액션 핸들러를 상속합니다 &lt;code&gt;actions&lt;/code&gt; 단지 전체 해시, 예를 대체하기보다는 확장 된 상위 클래스 나 유지 mixin에 정의 된 해시 :</target>
        </trans-unit>
        <trans-unit id="9f0188c56bfb8d604ed462187f6484e25c179952" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;actions&lt;/code&gt; queue is the general work queue and will typically contain scheduled tasks e.g. promises.</source>
          <target state="translated">&lt;code&gt;actions&lt;/code&gt; 큐는 일반 작업 큐이며, 일반적으로 작업 예를 들어, 약속 일정을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="41ff0eeabf56cfc059010cc4c18262f67f627814" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;afterRender&lt;/code&gt; queue contains jobs meant to be run after all previously scheduled render tasks are complete. This is often good for 3rd-party DOM manipulation libraries, that should only be run after an entire tree of DOM has been updated.</source>
          <target state="translated">&lt;code&gt;afterRender&lt;/code&gt; 큐는 모든 이전 작업이 완료 렌더링 예약 후 의미 작업이 실행되도록이 포함되어 있습니다. 이것은 종종 DOM 전체 트리가 업데이트 된 후에 만 ​​실행되는 타사 DOM 조작 라이브러리에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="95d664e2d1d83fcd6e5b1affc99d006e5870087d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;andThen&lt;/code&gt; helper will wait for all preceding asynchronous helpers to complete prior to progressing forward. Let's take a look at the following example.</source>
          <target state="translated">&lt;code&gt;andThen&lt;/code&gt; 도우미 앞으로 진행하기 전에 완료하기 위해 모든 이전 비동기 헬퍼 기다립니다. 다음 예를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="4d4a81e4ca7c1ec493df5706886873c52cf64207" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;application&lt;/code&gt; route is entered when your app first boots up. Like other routes, it will load a template with the same name (&lt;code&gt;application&lt;/code&gt; in this case) by default. You should put your header, footer, and any other decorative content here. All other routes will render their templates into the &lt;code&gt;application.hbs&lt;/code&gt; template's &lt;code&gt;{{outlet}}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;application&lt;/code&gt; 경로는 경우 앱이 처음 부팅 입력됩니다. 다른 경로와 마찬가지로 기본적으로 동일한 이름 ( 이 경우 &lt;code&gt;application&lt;/code&gt; )으로 템플릿을로드합니다 . 머리글, 바닥 글 및 기타 장식적인 내용을 여기에 넣어야합니다. 다른 모든 경로는 템플릿을 &lt;code&gt;application.hbs&lt;/code&gt; 템플릿의 &lt;code&gt;{{outlet}}&lt;/code&gt; 에 렌더링합니다 .</target>
        </trans-unit>
        <trans-unit id="b582698bc53fe300b6da4e31402e3e94ba67f723" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;args&lt;/code&gt; property of Glimmer components is an object that contains the &lt;em&gt;arguments&lt;/em&gt; that are passed to the component. For instance, the following component usage:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a16346decab3b61baad24880aedf46633230c1ad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;array&lt;/code&gt; helper</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a5ab553a8d271896a510ee5268f14190264cb5a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;attrs&lt;/code&gt; object can be used to declare a simple mapping between property names on &lt;code&gt;DS.Model&lt;/code&gt; records and payload keys in the serialized JSON object representing the record. An object with the property &lt;code&gt;key&lt;/code&gt; can also be used to designate the attribute's key on the response payload.</source>
          <target state="translated">&lt;code&gt;attrs&lt;/code&gt; 객체에 속성 이름과 간단한 매핑 선언 할 수 있습니다 &lt;code&gt;DS.Model&lt;/code&gt; 의 기록을 나타내는 직렬화 된 JSON 개체의 레코드와 페이로드 키를. 속성 &lt;code&gt;key&lt;/code&gt; 가 있는 객체를 사용하여 응답 페이로드 에서 속성 키를 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2d66bc83e872c9bd0033c21c7974df478a00038" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;attrs&lt;/code&gt; object can be used to declare a simple mapping between property names on &lt;code&gt;Model&lt;/code&gt; records and payload keys in the serialized JSON object representing the record. An object with the property &lt;code&gt;key&lt;/code&gt; can also be used to designate the attribute's key on the response payload.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dc40241d339c1bb5c98150382b9bbb509e1494e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;attrs&lt;/code&gt; option for a resource &lt;code&gt;{ embedded: 'always' }&lt;/code&gt; is shorthand for:</source>
          <target state="translated">&lt;code&gt;attrs&lt;/code&gt; 자원에 대한 옵션은 &lt;code&gt;{ embedded: 'always' }&lt;/code&gt; 에 대한 속기입니다 :</target>
        </trans-unit>
        <trans-unit id="d11fb7ffee10a29dcba72e4be14a34886533a524" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;attrs&lt;/code&gt; property can be set on the &lt;code&gt;ApplicationSerializer&lt;/code&gt; or a per-type serializer.</source>
          <target state="translated">&lt;code&gt;attrs&lt;/code&gt; 속성은 설정할 수 있습니다 &lt;code&gt;ApplicationSerializer&lt;/code&gt; 또는 당 형 시리얼.</target>
        </trans-unit>
        <trans-unit id="91ff220601d5dc8de2569eafda2d847e2de3da0a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;backgroundReload&lt;/code&gt; option is used to prevent the fetching of the destroyed record, since &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Store.html#method_findRecord&quot;&gt;&lt;code&gt;findRecord()&lt;/code&gt;&lt;/a&gt; automatically schedules a fetch of the record from the adapter.</source>
          <target state="translated">&lt;code&gt;backgroundReload&lt;/code&gt; 의 옵션이 파괴 된 레코드의 인출을 방지하기 위해 사용되기 때문에 &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Store.html#method_findRecord&quot;&gt; &lt;code&gt;findRecord()&lt;/code&gt; &lt;/a&gt; 자동으로 일정은 어댑터에서 레코드의 가져 오기.</target>
        </trans-unit>
        <trans-unit id="a4f5e918a009088b91687277e637fe04016877fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;boolean&lt;/code&gt; transform can handle values other than &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. The strings &lt;code&gt;&quot;true&quot;&lt;/code&gt; or &lt;code&gt;&quot;t&quot;&lt;/code&gt; in any casing, &lt;code&gt;&quot;1&quot;&lt;/code&gt;, and the number &lt;code&gt;1&lt;/code&gt; will all coerce to &lt;code&gt;true&lt;/code&gt;, and &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">는 &lt;code&gt;boolean&lt;/code&gt; 이외의 값 처리 할 수있는 변환 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; . 모든 케이스에서 문자열 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;t&quot;&lt;/code&gt; , &lt;code&gt;&quot;1&quot;&lt;/code&gt; 및 숫자 &lt;code&gt;1&lt;/code&gt; 은 모두 &lt;code&gt;true&lt;/code&gt; 로 강제 변환 되고 &lt;code&gt;false&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="71a103dc62034f2f7cae2908b76c1995a2fd8b2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;build&lt;/code&gt; command packages up all of the assets that make up your application&amp;mdash;JavaScript, templates, CSS, web fonts, images, and more.</source>
          <target state="translated">&lt;code&gt;build&lt;/code&gt; 응용 프로그램 - 자바 스크립트, 템플릿, CSS, 웹 글꼴, 이미지 등을 구성하는 모든 자산까지 명령 패키지로 제공된다.</target>
        </trans-unit>
        <trans-unit id="fd33d9b6d0ab56a5652a4f3c40541be7a9070e5d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;checked&lt;/code&gt; attribute of an &lt;code&gt;Checkbox&lt;/code&gt; object should always be set through the Ember object or by interacting with its rendered element representation via the mouse, keyboard, or touch. Updating the value of the checkbox via jQuery will result in the checked value of the object and its element losing synchronization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84d78207fa37bb2b65a91e18bf5316cd6ed67a48" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;checked&lt;/code&gt; attribute of an &lt;code&gt;Ember.Checkbox&lt;/code&gt; object should always be set through the Ember object or by interacting with its rendered element representation via the mouse, keyboard, or touch. Updating the value of the checkbox via jQuery will result in the checked value of the object and its element losing synchronization.</source>
          <target state="translated">&lt;code&gt;Ember.Checkbox&lt;/code&gt; 객체 의 &lt;code&gt;checked&lt;/code&gt; 속성 은 항상 Ember 객체를 통해 설정하거나 마우스, 키보드 또는 터치를 통해 렌더링 된 요소 표현과 상호 작용하여 설정해야합니다. jQuery를 통해 확인란의 값을 업데이트하면 객체와 해당 요소의 확인 된 값이 동기화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="388167e41998946f805b5e706d65af0e5c7f26f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;component&lt;/code&gt; helper can be used to package a component path with initial attrs. The included attrs can then be merged during the final invocation. For example, given a &lt;code&gt;person-form&lt;/code&gt; component with the following template:</source>
          <target state="translated">&lt;code&gt;component&lt;/code&gt; 도우미는 초기 attrs에있는 구성 요소 경로를 포장하는 데 사용할 수 있습니다. 그런 다음 포함 된 속성을 최종 호출 중에 병합 할 수 있습니다. 예를 들어 다음과 같은 템플릿을 사용 하는 &lt;code&gt;person-form&lt;/code&gt; 구성 요소가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="f10d7ab67dcbf9ed37e4d22dea1fe64ea50033dc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;concat&lt;/code&gt; helper</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1f2c97fc9f583e72f22cf0ed1d84746cb68b872" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;constructor&lt;/code&gt; can't be called in any other way. It doesn't exist on the class or instances:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b1ddfd17f539ac7b8a2663277ed2804f5e3e0db" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;constructor&lt;/code&gt; function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51f756b882769b9089adac0476c658ecb08bec84" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;constructor&lt;/code&gt; method is a special method in classes. It's run when you create a new instance of the class, and can be used to setup the class:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c34fbc331365e1345b641ddb67e8318a5245aaf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;context&lt;/code&gt; argument allows you to optionally specify the &lt;code&gt;this&lt;/code&gt; with which your callback will be invoked.</source>
          <target state="translated">&lt;code&gt;context&lt;/code&gt; 인수는 선택적으로 지정할 수 있습니다 &lt;code&gt;this&lt;/code&gt; 콜백이 호출 될 함께합니다.</target>
        </trans-unit>
        <trans-unit id="89d688b3c007bc970797daf54bb128d1ea052cf8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;create()&lt;/code&gt; on line #17 creates an &lt;em&gt;instance&lt;/em&gt; of the &lt;code&gt;Soldier&lt;/code&gt; class. The &lt;code&gt;extend()&lt;/code&gt; on line #8 creates a &lt;em&gt;subclass&lt;/em&gt; of &lt;code&gt;Person&lt;/code&gt;. Any instance of the &lt;code&gt;Person&lt;/code&gt; class will &lt;em&gt;not&lt;/em&gt; have the &lt;code&gt;march()&lt;/code&gt; method.</source>
          <target state="translated">17 번 줄 의 &lt;code&gt;create()&lt;/code&gt; 는 &lt;code&gt;Soldier&lt;/code&gt; 클래스 의 &lt;em&gt;인스턴스&lt;/em&gt; 를 만듭니다 . # 8 행 의 &lt;code&gt;extend()&lt;/code&gt; 는 &lt;code&gt;Person&lt;/code&gt; 의 &lt;em&gt;서브 클래스&lt;/em&gt; 를 만듭니다 . &lt;code&gt;Person&lt;/code&gt; 클래스 의 모든 인스턴스 에는 &lt;code&gt;march()&lt;/code&gt; 메소드 가 &lt;em&gt;없습니다&lt;/em&gt; .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c49797066693990d496ec9bb1f4d6f26783f06a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;createRecord&lt;/code&gt; method serializes the record and makes an Ajax (HTTP POST) request to a URL computed by &lt;code&gt;buildURL&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;createRecord&lt;/code&gt; 의 방법은 기록을 직렬화에 의해 계산 된 URL에 아약스 (HTTP POST) 요청합니다 &lt;code&gt;buildURL&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="f8e1669d9956b7ef08bd24a7d718d36d0e688bbf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;currentRoute&lt;/code&gt; property contains metadata about the current leaf route. It returns a &lt;code&gt;RouteInfo&lt;/code&gt; object that has information like the route name, params, query params and more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9a93643d5938fe543825d7c0628e35429505c3d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;date&lt;/code&gt; transform will transform an &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601&lt;/a&gt; string to a JavaScript date object.</source>
          <target state="translated">&lt;code&gt;date&lt;/code&gt; 변환됩니다 변환 &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601&lt;/a&gt; 자바 스크립트 날짜 개체에 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="ff34e8e1920ca2093675f8274922edc027f03d95" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;default-async-observers&lt;/code&gt; feature affects the behavior of observers application-wide, but you can still instruct individual observers to run synchronously or async manually. By using the &lt;code&gt;sync: true&lt;/code&gt; option, observers who are otherwise async by default can be marked as synchronous manually. Similarly, observers can be set to run asynchronously using the &lt;code&gt;sync: false&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e80e5ce5365720cc0f4de3729b802465bc83fe09" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;defaultSerializer&lt;/code&gt; property can be used to specify the serializer that will be used by this adapter. This is only used when a model specific serializer or &lt;code&gt;serializer:application&lt;/code&gt; are not defined.</source>
          <target state="translated">&lt;code&gt;defaultSerializer&lt;/code&gt; 의 속성은이 어댑터가 사용되는 시리얼을 지정하는 데 사용할 수 있습니다. 모델 고유의 serializer 또는 &lt;code&gt;serializer:application&lt;/code&gt; 이 정의되지 않은 경우에만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="47279489597e5ac74e3e86c13c5db07112deff0a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deleteRecord&lt;/code&gt; method makes an Ajax (HTTP DELETE) request to a URL computed by &lt;code&gt;buildURL&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;deleteRecord&lt;/code&gt; 의 방법은 아약스에 의해 계산 된 URL에 (HTTP DELETE) 요청합니다 &lt;code&gt;buildURL&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="a4d5273a464eca58d08f2ab0430b416271bc18c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deleteUser&lt;/code&gt; action is prepended with &lt;code&gt;this.&lt;/code&gt;, since &lt;code&gt;SystemPreferencesEditor&lt;/code&gt; is where the action is defined now. If the action was passed from a parent, then it might have looked like &lt;code&gt;@deleteUser&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c30f86ae15c9c161bf558adf4801995e475ede16" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;destroy&lt;/code&gt; queue contains jobs to finish the teardown of objects other jobs have scheduled to destroy.</source>
          <target state="translated">는 &lt;code&gt;destroy&lt;/code&gt; 큐 다른 작업이 파괴 예약 한 개체의 분해를 완료하는 작업이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="dba2c22a1d63dedd6e7edb5e5023be561abc95eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;did-insert&lt;/code&gt; modifier will call a function after its element is added to the DOM. That function receives the element as a parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dec8ac796a650bf4f17575a944af8c803f7569ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;didRender&lt;/code&gt; hook is called during both render and re-render after the template has rendered and the DOM updated. You can leverage this hook to perform post-processing on the DOM of a component after it's been updated.</source>
          <target state="translated">&lt;code&gt;didRender&lt;/code&gt; 의 후크는 동안이라고 모두 렌더링 템플릿을 렌더링하고, DOM을 업데이트 한 후 다시 렌더링합니다. 이 후크를 사용하여 업데이트 된 구성 요소의 DOM에서 사후 처리를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58ea898b33c2a437dd96438a1f46ae35d27a088e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;didTransition&lt;/code&gt; action is fired after a transition has successfully been completed. This occurs after the normal model hooks (&lt;code&gt;beforeModel&lt;/code&gt;, &lt;code&gt;model&lt;/code&gt;, &lt;code&gt;afterModel&lt;/code&gt;, &lt;code&gt;setupController&lt;/code&gt;) have resolved. The &lt;code&gt;didTransition&lt;/code&gt; action has no arguments, however, it can be useful for tracking page views or resetting state on the controller.</source>
          <target state="translated">&lt;code&gt;didTransition&lt;/code&gt; 의 전환이 성공적으로 완료 한 후 작업이 시작됩니다. 이는 일반적인 모델 후크 ( &lt;code&gt;beforeModel&lt;/code&gt; , &lt;code&gt;model&lt;/code&gt; , &lt;code&gt;afterModel&lt;/code&gt; , &lt;code&gt;setupController&lt;/code&gt; )가 해결 된 후에 발생합니다 . &lt;code&gt;didTransition&lt;/code&gt; 에 작용하지만, 그 컨트롤러의 상태를 페이지 뷰를 추적 또는 재설정에 유용 할 수있는 인자가 없다.</target>
        </trans-unit>
        <trans-unit id="3130357b52e4dd341684a411c14f9aaf8e594d3b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ember-cli-deprecation-workflow&lt;/code&gt; addon provides a command that will collect deprecations from your console and generate JavaScript code listing its findings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a086025716096321d67695ebde6dc9edd575027f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error&lt;/code&gt; and &lt;code&gt;loading&lt;/code&gt; substates exist as a part of each route, so they should not be added to your &lt;code&gt;router.js&lt;/code&gt; file. To utilize a substate, the route, controller, and template may be optionally defined as desired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d29eb3566c4cfb0d03f10d6c75bd7952980a0abf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error&lt;/code&gt; event</source>
          <target state="translated">&lt;code&gt;error&lt;/code&gt; 이벤트</target>
        </trans-unit>
        <trans-unit id="068d236c0c1376d4308bceaec965d2b3becf06ad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;errors&lt;/code&gt; property is useful for displaying error messages to the user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dc3d2be3a232d5f74fd199e8ed0506d40b409b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;errors&lt;/code&gt; property us useful for displaying error messages to the user.</source>
          <target state="translated">&lt;code&gt;errors&lt;/code&gt; 속성을 사용자에게 오류 메시지를 표시하는 우리에게 유용하다.</target>
        </trans-unit>
        <trans-unit id="115d726ddd808f785aca1eceaa420a26f06ecae9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;filter&lt;/code&gt; function is passed in by the calling object. This is a pattern known as &lt;a href=&quot;https://guides.emberjs.com/components/triggering-changes-with-actions/#toc_passing-the-action-to-the-component&quot;&gt;closure actions&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;filter&lt;/code&gt; 함수는 호출 객체에 의해 전달된다. 이것은 &lt;a href=&quot;https://guides.emberjs.com/components/triggering-changes-with-actions/#toc_passing-the-action-to-the-component&quot;&gt;클로저 액션으로&lt;/a&gt; 알려진 패턴 입니다.</target>
        </trans-unit>
        <trans-unit id="387361e1d1ae1eef1a52fa056d048c8cd9b110ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;findAll()&lt;/code&gt; method is used to retrieve all records for a given type.</source>
          <target state="translated">&lt;code&gt;findAll()&lt;/code&gt; 메소드는 주어진 유형에 대한 모든 기록을 검색하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="602c663ac51ac56be167a8f4fb8f2bd27b6e2b2a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;findAll&lt;/code&gt; method makes an Ajax (HTTP GET) request to a URL computed by &lt;code&gt;buildURL&lt;/code&gt;, and returns a promise for the resulting payload.</source>
          <target state="translated">&lt;code&gt;findAll&lt;/code&gt; 방법에 의해 계산 된 URL에 아약스 (HTTP GET) 요청합니다 &lt;code&gt;buildURL&lt;/code&gt; 을 , 그 결과 페이로드에 대한 약속을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ce7f071cf50d33d185134e7eba5ac98888f204a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;findBelongsTo&lt;/code&gt; method will make an Ajax (HTTP GET) request to the originally specified URL.</source>
          <target state="translated">&lt;code&gt;findBelongsTo&lt;/code&gt; 의 방법은 원래 지정된 URL에 아약스 (HTTP GET) 요청을 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="f44dcd4f85b2dd0552451d53e497afcda8a7a1c6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;findHasMany&lt;/code&gt; method will make an Ajax (HTTP GET) request to the originally specified URL.</source>
          <target state="translated">&lt;code&gt;findHasMany&lt;/code&gt; 의 방법은 원래 지정된 URL에 아약스 (HTTP GET) 요청을 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="ae10eeaf2c63ca125251ac98e9be799c680141ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;findMany&lt;/code&gt; method makes an Ajax (HTTP GET) request to a URL computed by &lt;code&gt;buildURL&lt;/code&gt;, and returns a promise for the resulting payload.</source>
          <target state="translated">&lt;code&gt;findMany&lt;/code&gt; 의 방법에 의해 계산 된 URL에 아약스 (HTTP GET) 요청합니다 &lt;code&gt;buildURL&lt;/code&gt; 을 , 그 결과 페이로드에 대한 약속을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7a08ab933ff65b656dd2d84e9309be457ddf1cf0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;findRecord()&lt;/code&gt; method is invoked when the store is asked for a record that has not previously been loaded. In response to &lt;code&gt;findRecord()&lt;/code&gt; being called, you should query your persistence layer for a record with the given ID. The &lt;code&gt;findRecord&lt;/code&gt; method should return a promise that will resolve to a JavaScript object that will be normalized by the serializer.</source>
          <target state="translated">&lt;code&gt;findRecord()&lt;/code&gt; 저장소가 이전에로드되지 않은 레코드에 대한 요구 될 때 메서드가 호출됩니다. 에 대한 응답으로 &lt;code&gt;findRecord()&lt;/code&gt; 는 지정된 ID를 가진 레코드에 대한 당신의 영속 계층을 쿼리해야 호출되고. &lt;code&gt;findRecord&lt;/code&gt; 의 방법은 시리얼 라이저에 의해 정규화됩니다 자바 스크립트 객체에 해결할 약속을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="4a203cdf205b6bed873c25d04719c09b1c068376" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;findRecord&lt;/code&gt; method makes an Ajax request to a URL computed by &lt;code&gt;buildURL&lt;/code&gt;, and returns a promise for the resulting payload.</source>
          <target state="translated">&lt;code&gt;findRecord&lt;/code&gt; 의 방법에 의해 계산 된 URL에 Ajax 요청하게 &lt;code&gt;buildURL&lt;/code&gt; 을 , 그 결과 페이로드에 대한 약속을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d296cef402c6e9fdee3e60b6eab8186006e33659" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;findRecord&lt;/code&gt; method will always resolve its promise with the same object for a given type and &lt;code&gt;id&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;findRecord&lt;/code&gt; 의 방법은 항상 지정된 형태와의 동일한 개체와의 약속 해결할 &lt;code&gt;id&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8946fd1a72779985021b67a58d0554338af6fd98" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;findRecord&lt;/code&gt; method will always return a &lt;strong&gt;promise&lt;/strong&gt; that will be resolved with the record.</source>
          <target state="translated">&lt;code&gt;findRecord&lt;/code&gt; 의 방법은 항상 반환 &lt;strong&gt;약속&lt;/strong&gt; 기록으로 해결 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="70a1277075e83917b1e91129c777128de706c278" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;firstName&lt;/code&gt; and &lt;code&gt;lastName&lt;/code&gt; properties are read from the context (the application controller in this case), and rendered inside the &lt;code&gt;&amp;lt;strong&amp;gt;&lt;/code&gt; HTML tag.</source>
          <target state="translated">&lt;code&gt;firstName&lt;/code&gt; 및 &lt;code&gt;lastName&lt;/code&gt; 이라는 속성 컨텍스트 (이 경우, 프로그램 제어기)로부터 판독하고, 내부 렌더링 &lt;code&gt;&amp;lt;strong&amp;gt;&lt;/code&gt; HTML 태그.</target>
        </trans-unit>
        <trans-unit id="cd6236735803b08c551e37efc7476c3b47d12870" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fn&lt;/code&gt; helper allows you to ensure a function that you are passing off to another component, helper, or modifier has access to arguments that are available in the template.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2cd1e74db759e699d89efeb874150a69a9ce052" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;generateIdForRecord()&lt;/code&gt; method will be invoked with the requesting store as the first parameter and the newly created record as the second parameter:</source>
          <target state="translated">&lt;code&gt;generateIdForRecord()&lt;/code&gt; 메소드는 첫번째 파라미터로서 요청 저장소 및 상기 제 파라미터로서 새롭게 생성 된 레코드를 호출한다 :</target>
        </trans-unit>
        <trans-unit id="bc51086852a3dddc57511bb5c719fec56bca56fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;get&lt;/code&gt; helper</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbf4d7e5cc6903ad89c7bab8e09192b731fe7906" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hash&lt;/code&gt; helper</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d6dcd303e28c2f50e7fa209f969128e6c261668" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hash&lt;/code&gt; option uses the URL's anchor to load the starting state of your application and will keep it in sync as you move around. At present, this relies on a &lt;a href=&quot;http://caniuse.com/hashchange&quot;&gt;hashchange&lt;/a&gt; event existing in the browser.</source>
          <target state="translated">&lt;code&gt;hash&lt;/code&gt; 옵션은 응용 프로그램의 시작 상태를로드 할 URL의 앵커를 사용하고 당신이 주변에 이동 동기화를 유지합니다. 현재 이것은 브라우저에 존재 하는 &lt;a href=&quot;http://caniuse.com/hashchange&quot;&gt;해시 변경&lt;/a&gt; 이벤트 에 의존 합니다.</target>
        </trans-unit>
        <trans-unit id="cc7c1171eccb8480ea2f8fa3d717e7fae73bc7e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hash&lt;/code&gt; option uses the URL's anchor to load the starting state of your application and will keep it in sync as you move around. At present, this relies on a &lt;a href=&quot;https://caniuse.com/hashchange&quot;&gt;hashchange&lt;/a&gt; event existing in the browser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efb3ddd1dd864b1ccd297455ce4d0857982f5192" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;host&lt;/code&gt; and &lt;code&gt;namespace&lt;/code&gt; attributes will be used if defined, and are optional.</source>
          <target state="translated">&lt;code&gt;host&lt;/code&gt; 와 &lt;code&gt;namespace&lt;/code&gt; 속성이 정의 된 경우 사용하고, 선택적됩니다.</target>
        </trans-unit>
        <trans-unit id="09f92bbffc457efd3c7472e55fd0edc358cab44a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;html&lt;/code&gt; element may not have multiple &lt;code&gt;lang&lt;/code&gt;&lt;em&gt;values&lt;/em&gt;. If an element contains content in a language different from the primary, then you can provide the element its own &lt;code&gt;lang&lt;/code&gt; attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="726d76cd26c3550c4a16d511675ea50195fe236a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id&lt;/code&gt; of the record that this reference refers to.</source>
          <target state="translated">이 참조가 참조하는 레코드 의 &lt;code&gt;id&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e484f981133bd6e9e051ecd67de8179c1ab49e1d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id&lt;/code&gt; of the record that this reference refers to. Together, the &lt;code&gt;type()&lt;/code&gt; and &lt;code&gt;id()&lt;/code&gt; methods form a composite key for the identity map. This can be used to access the id of an async relationship without triggering a fetch that would normally happen if you attempted to use &lt;code&gt;record.get('relationship.id')&lt;/code&gt;.</source>
          <target state="translated">이 참조가 참조하는 레코드 의 &lt;code&gt;id&lt;/code&gt; 입니다. 이와 함께 &lt;code&gt;type()&lt;/code&gt; 와 &lt;code&gt;id()&lt;/code&gt; 메소드는 아이덴티티 맵 복합 키를 형성한다. 이것은 &lt;code&gt;record.get('relationship.id')&lt;/code&gt; 를 사용하려고 시도 할 때 일반적으로 발생하는 페치를 트리거하지 않고 비동기 관계의 ID에 액세스하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7f2554d8b80727fbc1ff07b514fe870c4417b1df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;identifier&lt;/code&gt; of the record that this reference refers to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b8ddb4404d56063acf9b99af25e8cc6e7326302" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; helper allows you to conditionally render one of two branches, depending on the &quot;truthiness&quot; of a property. For example the following values are all falsey: &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;undefined&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;&quot;&quot;&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;NaN&lt;/code&gt; or an empty array.</source>
          <target state="translated">는 &lt;code&gt;if&lt;/code&gt; 도우미는 조건부 속성의 &quot;truthiness&quot;에 따라 두 가지 중 하나를 렌더링 할 수 있습니다. 예를 들어, &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;undefined&lt;/code&gt; , &lt;code&gt;null&lt;/code&gt; , &lt;code&gt;&quot;&quot;&lt;/code&gt; , &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;NaN&lt;/code&gt; 또는 빈 배열 값은 모두 false 입니다.</target>
        </trans-unit>
        <trans-unit id="80811688a39848ac2d9ee0077e1365518ccd1205" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;in-element&lt;/code&gt; helper renders its block content outside of the regular flow, into a DOM element given by its &lt;code&gt;destinationElement&lt;/code&gt; positional argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f533c5c4a9490cabd083312090b309dba8b8080" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;index&lt;/code&gt; route, which we've set up to redirect to the &lt;code&gt;rentals&lt;/code&gt; route.</source>
          <target state="translated">&lt;code&gt;index&lt;/code&gt; 우리가 설정 한 경로는 리디렉션하는 &lt;code&gt;rentals&lt;/code&gt; 경로.</target>
        </trans-unit>
        <trans-unit id="a37a3988ddfb70864ed4f197d72873cd75421874" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;index&lt;/code&gt; template will be rendered into the &lt;code&gt;{{outlet}}&lt;/code&gt; in the &lt;code&gt;application&lt;/code&gt; template. If the user navigates to &lt;code&gt;/favorites&lt;/code&gt;, Ember will replace the &lt;code&gt;index&lt;/code&gt; template with the &lt;code&gt;favorites&lt;/code&gt; template.</source>
          <target state="translated">&lt;code&gt;index&lt;/code&gt; 템플릿은로 표현 될 것이다 &lt;code&gt;{{outlet}}&lt;/code&gt; 에서 &lt;code&gt;application&lt;/code&gt; 템플릿. 사용자가 &lt;code&gt;/favorites&lt;/code&gt; 로 이동하면 Ember는 &lt;code&gt;index&lt;/code&gt; 템플릿을 &lt;code&gt;favorites&lt;/code&gt; 템플릿으로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="49b15fbb06ca8bff74b94354d94c2100eddd21f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;init&lt;/code&gt; hook still exists on many existing classes, and runs &lt;em&gt;after&lt;/em&gt;&lt;code&gt;constructor&lt;/code&gt;, so you can generally convert to native class syntax without rewriting your &lt;code&gt;init&lt;/code&gt; methods. However, in the future &lt;code&gt;init&lt;/code&gt; will be removed, so you should eventually transition to &lt;code&gt;constructor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05ea9f1721ce49a0176be60d2b1643295decf184" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;invokeHelper&lt;/code&gt; function can be used to create a helper instance in JavaScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21469bb82f8ec9ad5cd5418651baff8e6f8128b6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;is-active&lt;/code&gt; class is responsible for showing the active icon. &lt;em&gt;How&lt;/em&gt; that icon is rendered may change over time, so we won't use &lt;code&gt;...attributes&lt;/code&gt; to apply the &lt;code&gt;is-active&lt;/code&gt; class. Instead, we'll pass the argument &lt;code&gt;@isActive&lt;/code&gt; to dictate &lt;em&gt;what&lt;/em&gt; to do (e.g. render the icon).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="894fed72e604e69d2c832ed37e77607f8aedfc96" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;isDone&lt;/code&gt; property of any of the objects in the &lt;code&gt;todos&lt;/code&gt; array changes.</source>
          <target state="translated">&lt;code&gt;todos&lt;/code&gt; 배열 의 객체 중 하나 의 &lt;code&gt;isDone&lt;/code&gt; 속성이 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="2e33c9e0c11bc81e1d1a61b55510989fd637ce87" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;key-up&lt;/code&gt; property will be bound to the &lt;code&gt;handleFilterEntry&lt;/code&gt; action.</source>
          <target state="translated">&lt;code&gt;key-up&lt;/code&gt; 속성은 바인딩됩니다 &lt;code&gt;handleFilterEntry&lt;/code&gt; 의 작업입니다.</target>
        </trans-unit>
        <trans-unit id="936bd94b4aebf6a1e14654f35827f1ee229e7066" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;key&lt;/code&gt; option is used to tell Ember how to determine if the array being iterated over with &lt;code&gt;{{#each}}&lt;/code&gt; has changed between renders. By helping Ember detect that some elements in the array are the same, DOM elements can be re-used, significantly improving rendering speed.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 옵션이 배열의 존재가로 반복 처리 여부를 결정하는 방법 엠버에게 사용되는 &lt;code&gt;{{#each}}&lt;/code&gt; 이 렌더링 사이에 변경되었습니다. 배열의 일부 요소가 동일하다는 것을 Ember가 감지하면 DOM 요소를 재사용하여 렌더링 속도를 크게 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1609229b8d32f8c877e2321394121fb050df90a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;key&lt;/code&gt; option is used to tell Ember how to determine if the items in the array being iterated over with &lt;code&gt;{{#each}}&lt;/code&gt; has changed between renders. By default the item's object identity is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4254dc01c23c02d17d589a33a983d7751521cfab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;layout&lt;/code&gt; property can be used to dynamically specify a template associated with a component class, instead of relying on Ember to link together a component class and a template based on file names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e379a754151ed1a36cad1c06e086c55bb932b1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;layout&lt;/code&gt; property should be set to the default export of a template module, which is the name of a template file without the &lt;code&gt;.hbs&lt;/code&gt; extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89fd99904bc293783c2fb90fd3aa58828b6a8a8c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;let&lt;/code&gt; helper</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c13a30c7f33720be941a98a0ea6cf11d16443ad2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;let&lt;/code&gt; helper receives one or more positional arguments and yields them out as block params.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8f5fca5b000aac4891ae81f3df31b8436f67cee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link-to&lt;/code&gt; helper supports specifying query params using the &lt;code&gt;query-params&lt;/code&gt; subexpression helper.</source>
          <target state="translated">&lt;code&gt;link-to&lt;/code&gt; 사용하여 검색어 매개 변수 지정 도우미 지원 &lt;code&gt;query-params&lt;/code&gt; 표현식 도우미를.</target>
        </trans-unit>
        <trans-unit id="1769aac2882e47d76fb4a9a01749791965335a0d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link-to&lt;/code&gt; helper takes into account query parameters when determining its &quot;active&quot; state, and will set the class appropriately. The active state is determined by calculating whether the query params end up the same after clicking a link. You don't have to supply all of the current, active query params for this to be true.</source>
          <target state="translated">&lt;code&gt;link-to&lt;/code&gt; 도우미는 &quot;활성&quot;상태를 결정할 때 계정 쿼리 매개 변수로 받아, 적절한 클래스를 설정합니다. 활성 상태는 링크를 클릭 한 후 쿼리 매개 변수가 동일한 지 여부를 계산하여 결정됩니다. 이것이 사실이기 위해 현재 활성화 된 쿼리 매개 변수를 모두 제공 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="ce7461f1dc052dfdd78139e56ef3705e2ee872bd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;live-updating-chart&lt;/code&gt; component will be appended when &lt;code&gt;isMarketOpen&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, and the &lt;code&gt;market-close-summary&lt;/code&gt; component will be appended when &lt;code&gt;isMarketOpen&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;. If the value changes while the app is running, the component will be automatically swapped out accordingly. Note: You should not use this helper when you are consistently rendering the same component. In that case, use standard component syntax, for example:</source>
          <target state="translated">&lt;code&gt;live-updating-chart&lt;/code&gt; 경우 구성 요소가 추가됩니다 &lt;code&gt;isMarketOpen&lt;/code&gt; 이 있다 &lt;code&gt;true&lt;/code&gt; , 그리고 &lt;code&gt;market-close-summary&lt;/code&gt; 하면 구성 요소가 추가됩니다 &lt;code&gt;isMarketOpen&lt;/code&gt; 이 있다 &lt;code&gt;false&lt;/code&gt; . 앱이 실행되는 동안 값이 변경되면 그에 따라 구성 요소가 자동으로 교체됩니다. 참고 : 동일한 구성 요소를 일관되게 렌더링 할 때는이 도우미를 사용하지 마십시오. 이 경우 표준 구성 요소 구문을 사용하십시오 (예 :</target>
        </trans-unit>
        <trans-unit id="d5bb787fdea75d1b00a27bb3674ec987c8aaa6ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;loading&lt;/code&gt; action is fired on the route when a route's &lt;code&gt;model&lt;/code&gt; hook returns a promise that is not already resolved. The current &lt;code&gt;Transition&lt;/code&gt; object is the first parameter and the route that triggered the loading event is the second parameter.</source>
          <target state="translated">&lt;code&gt;loading&lt;/code&gt; 경로의 경우 동작이 노선에 발사되는 &lt;code&gt;model&lt;/code&gt; 후크가 이미 해결되지 약속을 반환합니다. 현재 &lt;code&gt;Transition&lt;/code&gt; 객체는 첫 번째 매개 변수이고 loading 이벤트를 트리거 한 경로는 두 번째 매개 변수입니다.</target>
        </trans-unit>
        <trans-unit id="62709da4cb7722dd75455fa1b4a1e73beda37c01" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;loading&lt;/code&gt; event</source>
          <target state="translated">&lt;code&gt;loading&lt;/code&gt; 이벤트</target>
        </trans-unit>
        <trans-unit id="51f4b8a7cab225c00b8bad7fe9f237a843ec218c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;location&lt;/code&gt; property determines the type of URL's that your application will use.</source>
          <target state="translated">&lt;code&gt;location&lt;/code&gt; 속성은 URL의 형식이 응용 프로그램이 사용하는 것입니다 결정합니다.</target>
        </trans-unit>
        <trans-unit id="14f62e503b235977ff447d099e3c7bfe5c7fa61c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;location&lt;/code&gt; property returns what implementation of the &lt;code&gt;location&lt;/code&gt; API your application is using, which determines what type of URL is being used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9eb2d558c702885a649840fb36c05bc2fa210e48" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;max&lt;/code&gt; attribute of input element used with &lt;code&gt;type=&quot;number&quot;&lt;/code&gt; or &lt;code&gt;type=&quot;range&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;type=&quot;number&quot;&lt;/code&gt; 또는 &lt;code&gt;type=&quot;range&quot;&lt;/code&gt; 와 함께 사용되는 입력 요소 의 &lt;code&gt;max&lt;/code&gt; 속성입니다 .</target>
        </trans-unit>
        <trans-unit id="761d8a8dfab983312074a19ca9afd183bd59ab2c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;min&lt;/code&gt; attribute of input element used with &lt;code&gt;type=&quot;number&quot;&lt;/code&gt; or &lt;code&gt;type=&quot;range&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;type=&quot;number&quot;&lt;/code&gt; 또는 &lt;code&gt;type=&quot;range&quot;&lt;/code&gt; 와 함께 사용되는 입력 요소 의 &lt;code&gt;min&lt;/code&gt; 속성입니다 .</target>
        </trans-unit>
        <trans-unit id="c7131d261d610c4ef91dd5c572c5bc3e35e27588" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;model&lt;/code&gt; hook may automatically re-run in certain conditions, as you'll read about below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a16647d6821ede1b677029aeacce468053baa77" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;model&lt;/code&gt;, &lt;code&gt;beforeModel&lt;/code&gt;, and &lt;code&gt;afterModel&lt;/code&gt; hooks described in &lt;a href=&quot;../asynchronous-routing&quot;&gt;Asynchronous Routing&lt;/a&gt; each get called with a transition object. This makes it possible for destination routes to abort attempted transitions.</source>
          <target state="translated">&lt;code&gt;model&lt;/code&gt; , &lt;code&gt;beforeModel&lt;/code&gt; 및 &lt;code&gt;afterModel&lt;/code&gt; 의 후크에 기재된 &lt;a href=&quot;../asynchronous-routing&quot;&gt;비동기 라우팅&lt;/a&gt; 전이 객체 호출을 각각 GET. 따라서 대상 경로에서 시도한 전환을 중단 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf129aa4a0fe0a75f718d18c4bdf9834b17154da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;module&lt;/code&gt; from QUnit will scope your tests into groups of tests which can be configured and run independently. Make sure to call the &lt;code&gt;setupRenderingTest&lt;/code&gt; function together with the &lt;code&gt;hooks&lt;/code&gt; parameter first in your new module. This will do the necessary setup for testing your component for you, including setting up a way to access the rendered DOM of your component later on in the test, and cleaning up once your tests in this module are finished.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a07d77d0d198d3536ee44ea45215a0d56f6c718" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;moduleForComponent&lt;/code&gt; helper will find the component by name (&lt;code&gt;pretty-color&lt;/code&gt;) and its template (if available). Make sure to set &lt;code&gt;integration: true&lt;/code&gt; to enable integration test capability.</source>
          <target state="translated">&lt;code&gt;moduleForComponent&lt;/code&gt; 의 도우미 이름 (기준 구성 요소 찾을 수 &lt;code&gt;pretty-color&lt;/code&gt; )과 템플릿 (사용 가능한 경우). 통합 테스트 기능을 사용하려면 &lt;code&gt;integration: true&lt;/code&gt; 를 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="1f0b4c4d37c65b2375c09c8c275bd27b63a64ba7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mut&lt;/code&gt; helper changes the &lt;code&gt;totalClicks&lt;/code&gt; value to what was provided as the &lt;code&gt;fn&lt;/code&gt; argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="644ef1f7a187d6716007454db3fc278899d36342" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mut&lt;/code&gt; helper changes the &lt;code&gt;totalClicks&lt;/code&gt; value to what was provided as the action argument.</source>
          <target state="translated">&lt;code&gt;mut&lt;/code&gt; 도우미는 변경 &lt;code&gt;totalClicks&lt;/code&gt; 의 액션 인수로 제공 한 것과 값입니다.</target>
        </trans-unit>
        <trans-unit id="edbf9526f6f8f8b4f51d74862e43afb24dca9baa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mut&lt;/code&gt; helper lets you &lt;strong&gt;clearly specify&lt;/strong&gt; that a child &lt;code&gt;Component&lt;/code&gt; can update the (mutable) value passed to it, which will &lt;strong&gt;change the value of the parent component&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;mut&lt;/code&gt; 도우미는 할 수 &lt;strong&gt;명확하게 지정&lt;/strong&gt; 아이 것을 &lt;code&gt;Component&lt;/code&gt; 됩니다 전달 된 (변경 가능) 값을 업데이트 할 수 있습니다 &lt;strong&gt;부모 요소의 값을 변경을&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="47f4565230c7ebd7ee1ea8d2cea1cd329802f14d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mut&lt;/code&gt; helper, when used with &lt;code&gt;action&lt;/code&gt;, will return a function that sets the value passed to &lt;code&gt;mut&lt;/code&gt; to its first argument. This works like any other closure action and interacts with the other features &lt;code&gt;action&lt;/code&gt; provides. As an example, we can create a button that increments a value passing the value directly to the &lt;code&gt;action&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;mut&lt;/code&gt; 헬퍼 함께 사용했을 때 &lt;code&gt;action&lt;/code&gt; 값이 전달 세트 해당 함수 리턴 &lt;code&gt;mut&lt;/code&gt; 첫번째 인수한다. 이것은 다른 폐쇄 작업과 마찬가지로 작동하며 &lt;code&gt;action&lt;/code&gt; 제공 하는 다른 기능과 상호 작용 합니다. 예를 들어, 값을 직접 &lt;code&gt;action&lt;/code&gt; 전달하는 값을 증가시키는 버튼을 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9e8e9c42b8f5502e474054e2d46d2d420c98123c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mut&lt;/code&gt; helper, when used with &lt;code&gt;fn&lt;/code&gt;, will return a function that sets the value passed to &lt;code&gt;mut&lt;/code&gt; to its first argument. As an example, we can create a button that increments a value passing the value directly to the &lt;code&gt;fn&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56d78c00c87e98a8c72600ac52ce6a122f8289e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;namespace&lt;/code&gt; property can be used to prefix requests with a specific URL namespace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e89da7babb87da3e213ca546f7a89e9c5ec5c0f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;namespace&lt;/code&gt; property can be used to prefix requests with a specific url namespace.</source>
          <target state="translated">&lt;code&gt;namespace&lt;/code&gt; 속성은 특정의 URL 네임 스페이스와 요청을 접두사로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfed5d466aa02a365425fe10dfe05ec1cbdf595d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt; command generates a project structure with the following files and directories:</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 명령은 다음 파일과 디렉토리와 프로젝트 구조를 생성합니다 :</target>
        </trans-unit>
        <trans-unit id="ed24ef77b982f52329f6db5f8b171af6032be5a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;newValue&lt;/code&gt; parameter thus becomes the &lt;code&gt;target.value&lt;/code&gt; property of the event object, which is the value of the input field the user typed. (e.g 'Foo Fighters')</source>
          <target state="translated">따라서 &lt;code&gt;newValue&lt;/code&gt; 매개 변수 는 이벤트 오브젝트 의 &lt;code&gt;target.value&lt;/code&gt; 특성이되며 이는 사용자가 입력 한 입력 필드의 값입니다. (예 : '푸 파이터')</target>
        </trans-unit>
        <trans-unit id="3b9f3dead33374ca86a671206cb69b9ea69de17d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;normalize&lt;/code&gt; method is used to convert a payload received from your external data source into the normalized form &lt;code&gt;store.push()&lt;/code&gt; expects. You should override this method, munge the hash and return the normalized payload.</source>
          <target state="translated">&lt;code&gt;normalize&lt;/code&gt; 방법은 정규화 된 형태로 외부 데이터 소스로부터 수신되는 페이로드를 변환하는 데 사용된다 &lt;code&gt;store.push()&lt;/code&gt; 기대한다. 이 방법을 재정의하고 해시를 제거하고 정규화 된 페이로드를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="20e85f3eb6d6503ba01eeae172d760d7f90937b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;normalize&lt;/code&gt; method will be called three times:</source>
          <target state="translated">&lt;code&gt;normalize&lt;/code&gt; 방법은 세 번 호출됩니다 :</target>
        </trans-unit>
        <trans-unit id="1d0fd3bcdefae28cf2e583c51b6f6f637f4b37a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;normalizeResponse&lt;/code&gt; method is used to normalize a payload from the server to a JSON-API Document.</source>
          <target state="translated">&lt;code&gt;normalizeResponse&lt;/code&gt; 의 방법은 JSON-API 문서를 서버로부터 페이로드를 정규화하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="0c2db818043d2ecfecb9f10542f615aa9bab50e8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;observes&lt;/code&gt; extension of Javascript's Function prototype is available when &lt;code&gt;EmberENV.EXTEND_PROTOTYPES&lt;/code&gt; or &lt;code&gt;EmberENV.EXTEND_PROTOTYPES.Function&lt;/code&gt; is true, which is the default.</source>
          <target state="translated">는 &lt;code&gt;observes&lt;/code&gt; 할 때 자바 스크립트의 기능 프로토 타입의 확장을 사용할 수 &lt;code&gt;EmberENV.EXTEND_PROTOTYPES&lt;/code&gt; 또는 &lt;code&gt;EmberENV.EXTEND_PROTOTYPES.Function&lt;/code&gt; 가 기본값 인 true.</target>
        </trans-unit>
        <trans-unit id="559f9d9165fd051912e8156d55437a2c4f0bc86f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;on-click-outside&lt;/code&gt; modifier adds the click handler to the &lt;code&gt;document&lt;/code&gt; and returns &lt;em&gt;another function&lt;/em&gt; that should be run when Ember removes the element the modifier is attached to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f03013d375dee1ad0017ee24be6c12bc6613607" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;on&lt;/code&gt; extension of Javascript's Function prototype is available when &lt;code&gt;EmberENV.EXTEND_PROTOTYPES&lt;/code&gt; or &lt;code&gt;EmberENV.EXTEND_PROTOTYPES.Function&lt;/code&gt; is true, which is the default.</source>
          <target state="translated">&lt;code&gt;on&lt;/code&gt; 때 자바 스크립트의 기능 프로토 타입의 확장이 가능 &lt;code&gt;EmberENV.EXTEND_PROTOTYPES&lt;/code&gt; 또는 &lt;code&gt;EmberENV.EXTEND_PROTOTYPES.Function&lt;/code&gt; 가 기본값 인 true.</target>
        </trans-unit>
        <trans-unit id="297b35be5fa3a29b2bfdd9b1aca553208fd9387a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options&lt;/code&gt; hash is passed as second argument to a transforms' &lt;code&gt;serialize&lt;/code&gt; and &lt;code&gt;deserialize&lt;/code&gt; method. This allows to configure a transformation and adapt the corresponding value, based on the config:</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 해시는 변환 '두 번째 인수로서 건네 &lt;code&gt;serialize&lt;/code&gt; 및 &lt;code&gt;deserialize&lt;/code&gt; 방법. 이를 통해 구성을 기반으로 변환을 구성하고 해당 값을 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a48eca6e5279e14ea0ca6e2582655554ba9b2b05" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;partial&lt;/code&gt; helper renders another template without changing the template context:</source>
          <target state="translated">&lt;code&gt;partial&lt;/code&gt; 헬퍼 템플릿 컨텍스트를 변경하지 않고 다른 템플릿을 렌더링 :</target>
        </trans-unit>
        <trans-unit id="9dab6744a08664ce82b1d25a8cd8dabeafdb4d4d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pattern&lt;/code&gt; attribute of input element.</source>
          <target state="translated">입력 요소 의 &lt;code&gt;pattern&lt;/code&gt; 속성</target>
        </trans-unit>
        <trans-unit id="beed0cd468b2c43cc334c3ee15857caebfa7e869" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;person&lt;/code&gt; model we generated earlier didn't have any attributes. Let's add first and last name, as well as the birthday, using &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.html#method_attr&quot;&gt;&lt;code&gt;DS.attr&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;person&lt;/code&gt; 우리가 이전에 생성 된 모델은 어떤 속성을 가지고 있지 않았다. &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.html#method_attr&quot;&gt; &lt;code&gt;DS.attr&lt;/code&gt; 을&lt;/a&gt; 사용하여 생일뿐만 아니라 이름과 성을 추가합시다 .</target>
        </trans-unit>
        <trans-unit id="90725d198f3ce393688476515379f34e09113068" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;person&lt;/code&gt; model we generated earlier didn't have any attributes. Let's add first and last name, as well as the birthday, using &lt;a href=&quot;https://api.emberjs.com/ember-data/release/functions/@ember-data%2Fmodel/attr&quot;&gt;&lt;code&gt;attr&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c726fa5adf1c99c0bbb0555060826f16888f5c7b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;primaryKey&lt;/code&gt; is used when serializing and deserializing data. Ember Data always uses the &lt;code&gt;id&lt;/code&gt; property to store the id of the record. The external source may not always follow this convention. In these cases it is useful to override the &lt;code&gt;primaryKey&lt;/code&gt; property to match the &lt;code&gt;primaryKey&lt;/code&gt; of your external store.</source>
          <target state="translated">&lt;code&gt;primaryKey&lt;/code&gt; 직렬화 및 역 직렬화 된 데이터를 할 때 사용된다. Ember Data는 항상 &lt;code&gt;id&lt;/code&gt; 속성을 사용 하여 레코드의 id를 저장합니다. 외부 소스가이 규칙을 항상 따르는 것은 아닙니다. 이 경우 무시하는 데 유용합니다 &lt;code&gt;primaryKey&lt;/code&gt; 일치하는 특성 &lt;code&gt;primaryKey&lt;/code&gt; 외부 저장소의를.</target>
        </trans-unit>
        <trans-unit id="1ddda9eaba646249c47555954c9e00b3441e3959" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;property&lt;/code&gt; extension of Javascript's Function prototype is available when &lt;code&gt;EmberENV.EXTEND_PROTOTYPES&lt;/code&gt; or &lt;code&gt;EmberENV.EXTEND_PROTOTYPES.Function&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, which is the default.</source>
          <target state="translated">&lt;code&gt;property&lt;/code&gt; 때 자바 스크립트의 기능 프로토 타입의 확장이 가능 &lt;code&gt;EmberENV.EXTEND_PROTOTYPES&lt;/code&gt; 또는 &lt;code&gt;EmberENV.EXTEND_PROTOTYPES.Function&lt;/code&gt; 가 있다 &lt;code&gt;true&lt;/code&gt; 기본이다.</target>
        </trans-unit>
        <trans-unit id="741ea22ea557846205bbcb6432415861ed43b265" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;push()&lt;/code&gt; method is also important when working with complex endpoints. You may find your application has an endpoint that performs some business logic then creates several records. This likely does not map cleanly to Ember Data's existing &lt;code&gt;save()&lt;/code&gt; API which is structured around persisting a single record. Instead you should make your own custom AJAX request and push the resulting model data into the store so it can be accessed by other parts of your application.</source>
          <target state="translated">&lt;code&gt;push()&lt;/code&gt; 복합 엔드 포인트로 작업 할 때 방법도 중요하다. 애플리케이션에 일부 비즈니스 로직을 수행 한 다음 여러 레코드를 작성하는 엔드 포인트가있을 수 있습니다. 이것은 단일 레코드를 유지하도록 구성된 Ember Data의 기존 &lt;code&gt;save()&lt;/code&gt; API에 명확하게 매핑되지 않을 수 있습니다 . 대신 사용자 정의 AJAX 요청을 작성하고 결과 모델 데이터를 상점으로 푸시하여 애플리케이션의 다른 부분에서 액세스 할 수 있도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="aae259eec78af16010c733438f33779155e77926" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;push()&lt;/code&gt; method is also important when working with complex endpoints. You may find your application has an endpoint that performs some business logic then creates several records. This likely does not map cleanly to Ember Data's existing &lt;code&gt;save()&lt;/code&gt; API which is structured around persisting a single record. Instead you should make your own custom network request and push the resulting model data into the store so it can be accessed by other parts of your application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aba7f7dcf3bc1a43f03c260d10824580744e938c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;query()&lt;/code&gt; and &lt;code&gt;queryRecord()&lt;/code&gt; methods each take a &lt;code&gt;query&lt;/code&gt; argument that is serialized directly into the URL query string and the &lt;code&gt;include&lt;/code&gt; parameter may form part of that argument. For example:</source>
          <target state="translated">&lt;code&gt;query()&lt;/code&gt; 및 &lt;code&gt;queryRecord()&lt;/code&gt; 방법을 각각 가지고 &lt;code&gt;query&lt;/code&gt; 의 URL 쿼리 문자열에 직접 직렬화와입니다 인수 &lt;code&gt;include&lt;/code&gt; 매개 변수가 인수의 일부를 형성 할 수있다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="40ae82990914385fed7743c850d721020c13355a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;query-params&lt;/code&gt; helper can be used to set query params on a link:</source>
          <target state="translated">&lt;code&gt;query-params&lt;/code&gt; 도우미는 링크를 설정 검색어 매개 변수에 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="a8fe29792accf52f26efa3e35355502b262e7a69" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;query&lt;/code&gt; argument is a simple JavaScript object that will be passed directly to the server as parameters.</source>
          <target state="translated">&lt;code&gt;query&lt;/code&gt; 인수는 매개 변수로 서버에 직접 전달하는 간단한 자바 스크립트 객체입니다.</target>
        </trans-unit>
        <trans-unit id="3bceeb7be0a9c6e0f887c2b26aab4a16695618f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;query&lt;/code&gt; method makes an Ajax (HTTP GET) request to a URL computed by &lt;code&gt;buildURL&lt;/code&gt;, and returns a promise for the resulting payload.</source>
          <target state="translated">&lt;code&gt;query&lt;/code&gt; 방법에 의해 계산 된 URL에 아약스 (HTTP GET) 요청합니다 &lt;code&gt;buildURL&lt;/code&gt; 을 , 그 결과 페이로드에 대한 약속을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ac86f04028c107b848f45d261d4b4fb39028dabb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;queryRecord()&lt;/code&gt; method is invoked when the store is asked for a single record through a query object.</source>
          <target state="translated">&lt;code&gt;queryRecord()&lt;/code&gt; 저장소가 쿼리 개체를 통해 단일 레코드를 요청하는 경우 메서드가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="5f566f5912a6205cfc53d29bb1ff422d225d2210" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;queryRecord&lt;/code&gt; method makes an Ajax (HTTP GET) request to a URL computed by &lt;code&gt;buildURL&lt;/code&gt;, and returns a promise for the resulting payload.</source>
          <target state="translated">&lt;code&gt;queryRecord&lt;/code&gt; 의 방법에 의해 계산 된 URL에 아약스 (HTTP GET) 요청합니다 &lt;code&gt;buildURL&lt;/code&gt; 을 , 그 결과 페이로드에 대한 약속을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d4ea793c0781cfc5c0cec6bad75f521580c0c469" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;render&lt;/code&gt; queue contains jobs meant for rendering, these will typically update the DOM.</source>
          <target state="translated">은 &lt;code&gt;render&lt;/code&gt; 대기열이 일반적으로 DOM을 업데이트합니다 렌더링에 대한 의미 작업이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7f84a235783d75983b71d54f1ff2d957db34aa0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rental_id&lt;/code&gt; will now be passed to the route.</source>
          <target state="translated">&lt;code&gt;rental_id&lt;/code&gt; 은 이제 경로로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="2ab02947d511f36cd80dcd1ce1d3df5d48a3288d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rootElement&lt;/code&gt; can be either a DOM element or a jQuery-compatible selector string. Note that &lt;em&gt;views appended to the DOM outside the root element will not receive events.&lt;/em&gt; If you specify a custom root element, make sure you only append views inside it!</source>
          <target state="translated">&lt;code&gt;rootElement&lt;/code&gt; 는 DOM 요소 또는 jQuery를 호환 선택 문자열이 될 수 있습니다. 참고 &lt;em&gt;보기가 이벤트를받을 수 없습니다 루트 요소 외부의 DOM에 추가. &lt;/em&gt;사용자 지정 루트 요소를 지정하면 그 안에보기 만 추가해야합니다!</target>
        </trans-unit>
        <trans-unit id="3a8da5a439d38001229221cfd68b305ff89d4757" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rootURL&lt;/code&gt; property represents the URL of the root of the application, '/' by default. This prefix is assumed on all routes defined on this app.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd06e623a0e6df47b04f0a8932c4bef6f6416747" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;routeDidChange&lt;/code&gt; event only fires once a transition has settled. This includes aborts and error substates. Like the &lt;code&gt;routeWillChange&lt;/code&gt; event it receives a Transition as the sole argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d04a86b8c675c12689a56d91099c0d28bdfd9b96" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;routeWillChange&lt;/code&gt; event fires whenever a new route is chosen as the desired target of a transition. This includes &lt;code&gt;transitionTo&lt;/code&gt;, &lt;code&gt;replaceWith&lt;/code&gt;, all redirection for any reason including error handling, and abort. Aborting implies changing the desired target back to where you already were. Once a transition has completed, &lt;code&gt;routeDidChange&lt;/code&gt; fires.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65791ea1d9b51d6b065121c4a5924caf3e445b87" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;routeWillChange&lt;/code&gt; event is fired at the beginning of any attempted transition with a &lt;code&gt;Transition&lt;/code&gt; object as the sole argument. This action can be used for aborting, redirecting, or decorating the transition from the currently active routes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cb53ef77e44dde0ccc9cdeab769f0e6ab2e0202" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;routerTransitions&lt;/code&gt; queue contains transition jobs in the router.</source>
          <target state="translated">&lt;code&gt;routerTransitions&lt;/code&gt; 의 큐는 라우터의 전환 작업을 포함한다.</target>
        </trans-unit>
        <trans-unit id="914db6574906c68800e0d33d2e398128993fa468" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;select&lt;/code&gt; action handler would be called with a single argument containing the post model:</source>
          <target state="translated">&lt;code&gt;select&lt;/code&gt; 액션 핸들러는 포스트 모델을 포함하는 단일 인수로 호출 할 것입니다 :</target>
        </trans-unit>
        <trans-unit id="df2eb6d01d9ec8f4cdf6e2424d4b714982ede9b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sender&lt;/code&gt; is the object that changed. The &lt;code&gt;key&lt;/code&gt; is the property that changes. The &lt;code&gt;value&lt;/code&gt; property is currently reserved and unused. The &lt;code&gt;rev&lt;/code&gt; is the last property revision of the object when it changed, which you can use to detect if the key value has really changed or not.</source>
          <target state="translated">&lt;code&gt;sender&lt;/code&gt; 변경된 것을 목적으로한다. &lt;code&gt;key&lt;/code&gt; 변경하는 속성입니다. &lt;code&gt;value&lt;/code&gt; 속성은 현재 예약 및 사용되지 않습니다. &lt;code&gt;rev&lt;/code&gt; 당신이 키 값이 정말 변경하거나하지 않은 경우 감지하는 데 사용할 수있는가 변경 객체의 마지막 속성 수정합니다.</target>
        </trans-unit>
        <trans-unit id="320d415a375ebee02086a1803913992fa35a52e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;serialize&lt;/code&gt; and &lt;code&gt;deserialize&lt;/code&gt; keys support 3 values:</source>
          <target state="translated">&lt;code&gt;serialize&lt;/code&gt; 및 &lt;code&gt;deserialize&lt;/code&gt; 키는 3 개 값을 지원 :</target>
        </trans-unit>
        <trans-unit id="6f25c439a903f72adbb9b751611fc24318fc0bef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;serialize&lt;/code&gt; method is used when a record is saved in order to convert the record into the form that your external data source expects.</source>
          <target state="translated">&lt;code&gt;serialize&lt;/code&gt; 레코드가 외부 데이터 소스가 예상하는 형태로 기록을 변환하기 위해 저장 될 때 방법이 사용된다.</target>
        </trans-unit>
        <trans-unit id="ca79fc713fd97bd184a81e559e72c3c10e563ff9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;set&lt;/code&gt; function should accept two parameters, &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt;. The value returned from &lt;code&gt;set&lt;/code&gt; will be the new value of the property.</source>
          <target state="translated">&lt;code&gt;set&lt;/code&gt; 함수는 두 개의 매개 변수를 받아 들여야 &lt;code&gt;key&lt;/code&gt; 와 &lt;code&gt;value&lt;/code&gt; . &lt;code&gt;set&lt;/code&gt; 에서 반환 된 값은 속성의 새로운 값이됩니다.</target>
        </trans-unit>
        <trans-unit id="a684fad7961dc364370365a25b511543e6cc74b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;setProps&lt;/code&gt; action directly sets one property, and calls the method to set the other. In our generated test file, Ember CLI already uses the &lt;code&gt;module&lt;/code&gt; and the &lt;code&gt;setupTest&lt;/code&gt; helpers to set up a test container:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2b783248728ef736c417d1b8a02ac7a76ba4c00" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;setProps&lt;/code&gt; action directly sets one property, and calls the method to set the other. In our generated test, ember-cli already uses the &lt;code&gt;moduleFor&lt;/code&gt; helper to set up a test container:</source>
          <target state="translated">&lt;code&gt;setProps&lt;/code&gt; 의 작업은 직접 하나 개의 속성을 설정하고, 다른 설정하는 메소드를 호출합니다. 생성 된 테스트에서 ember-cli는 이미 &lt;code&gt;moduleFor&lt;/code&gt; 도우미를 사용하여 테스트 컨테이너를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="a7a5bc8047dfc31a806acf70a107363435688016" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;signUp&lt;/code&gt; action is simply a function defined on the &lt;code&gt;actions&lt;/code&gt; hash of a component. Since the action is assigned to an inline handler, the function definition can define the event object as its first parameter.</source>
          <target state="translated">&lt;code&gt;signUp&lt;/code&gt; 작업은 단순히에 정의 된 함수 &lt;code&gt;actions&lt;/code&gt; 구성 요소의 해시. 조치가 인라인 핸들러에 지정되므로 함수 정의는 이벤트 오브젝트를 첫 번째 매개 변수로 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="905ce447cd074e63c0b217b907cdbd799228dbdc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;size&lt;/code&gt; of the text field in characters.</source>
          <target state="translated">텍스트 필드 의 &lt;code&gt;size&lt;/code&gt; 문자)입니다.</target>
        </trans-unit>
        <trans-unit id="ee3dc15a96239617e5bccc59e1e5326f374fae3a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;static&lt;/code&gt; keyword can be applied to all class elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60ce209fb9d274970aad161ade621ac9ba4ac11c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;store&lt;/code&gt; property is the application's &lt;code&gt;store&lt;/code&gt; that contains all records. It can be used to look up serializers for other model types that may be nested inside the payload response.</source>
          <target state="translated">&lt;code&gt;store&lt;/code&gt; 속성은 응용 프로그램입니다 &lt;code&gt;store&lt;/code&gt; 모든 레코드를 포함합니다. 페이로드 응답 내에 중첩 될 수있는 다른 모델 유형의 직렬 변환기를 찾는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="296139528fe79390dc0a604c903db62d7f189968" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sync&lt;/code&gt; queue contains binding synchronization jobs.</source>
          <target state="translated">&lt;code&gt;sync&lt;/code&gt; 큐 동기화 작업을 포함 바인딩.</target>
        </trans-unit>
        <trans-unit id="18bb76e64d8cba533e55a608d9dc04cd74b53eb3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;templates/posts/index.hbs&lt;/code&gt; file has the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d45888c4b5f26f9dbee726ba4b3f0dd55bd31fed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;templates/posts/post.hbs&lt;/code&gt; file has the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ff37492a4d1b522cbb2957ffd8cce10aa8ee652" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;todos&lt;/code&gt; property of the component is changed to a different array.</source>
          <target state="translated">구성 요소 의 &lt;code&gt;todos&lt;/code&gt; 특성이 다른 배열로 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="47de40fd6b0fa63948385f1ece4518b508dfa9bf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;total&lt;/code&gt; is now computed by multiplying a piece of &lt;em&gt;local state&lt;/em&gt; (&lt;code&gt;this.count&lt;/code&gt;) with an argument (&lt;code&gt;this.args.multiple&lt;/code&gt;). You can mix and match local state and arguments however you wish, which allows you to easily break up a component into smaller pieces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="131b771f6ba43c138d365e36164154f5cb2e8c6d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type&lt;/code&gt; attribute of the input element.</source>
          <target state="translated">입력 요소 의 &lt;code&gt;type&lt;/code&gt; 속성입니다.</target>
        </trans-unit>
        <trans-unit id="4c5bc75c3e6f8899fec6ea16cb876d5a2fdd47fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unbound&lt;/code&gt; helper only accepts a single argument, and it return an unbound value.</source>
          <target state="translated">&lt;code&gt;unbound&lt;/code&gt; 도우미는 하나의 인수를 받아, 그것은 언 바운드 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5de73c1d5e1af2fc912363ffcf138ae01e88ec89" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unless&lt;/code&gt; helper is the inverse of the &lt;code&gt;if&lt;/code&gt; helper. It displays if a value is falsey (&quot;not true&quot; or &quot;is false&quot;). Example values that will display with &lt;code&gt;unless&lt;/code&gt;: &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;undefined&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;&quot;&quot;&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;NaN&lt;/code&gt; or an empty array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efdf958209e8428c763eee6028027f027891e782" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;updateRecord&lt;/code&gt; method serializes the record and makes an Ajax (HTTP PUT) request to a URL computed by &lt;code&gt;buildURL&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;updateRecord&lt;/code&gt; 의 방법은 기록을 직렬화에 의해 계산 된 URL에 아약스 (HTTP PUT) 요청합니다 &lt;code&gt;buildURL&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="1b6470eade078efa5a7597b68a9c894e7656a268" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;value&lt;/code&gt; attribute of the input element. As the user inputs text, this property is updated live.</source>
          <target state="translated">입력 요소 의 &lt;code&gt;value&lt;/code&gt; 속성 사용자가 텍스트를 입력하면이 속성이 실시간으로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="89d5c88cd2756f1f000db7d6ac6178bf03b70a15" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;wait&lt;/code&gt; helper is built into &lt;code&gt;registerAsyncHelper&lt;/code&gt; by default. You will not need to &lt;code&gt;return app.testHelpers.wait();&lt;/code&gt; - the wait behavior is provided for you.</source>
          <target state="translated">&lt;code&gt;wait&lt;/code&gt; 도우미에 내장되어 &lt;code&gt;registerAsyncHelper&lt;/code&gt; 기본적으로. &lt;code&gt;return app.testHelpers.wait();&lt;/code&gt; 을 반환 할 필요는 없습니다 . -대기 동작이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="2a3d56e189d128908470bf74976b11ba03b8229c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;willTransition&lt;/code&gt; action is fired at the beginning of any attempted transition with a &lt;code&gt;Transition&lt;/code&gt; object as the sole argument. This action can be used for aborting, redirecting, or decorating the transition from the currently active routes.</source>
          <target state="translated">&lt;code&gt;willTransition&lt;/code&gt; 의 행동은 어떤 시도 전환의 시작 부분에 발사되는 &lt;code&gt;Transition&lt;/code&gt; 유일한 인수로 객체입니다. 이 동작은 현재 활성화 된 경로에서 전환을 중단, 리디렉션 또는 장식하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dac36ab23aab0d6a37141a494ed024c387292289" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{#each}}&lt;/code&gt; helper loops over elements in a collection. It is an extension of the base Handlebars &lt;code&gt;{{#each}}&lt;/code&gt; helper.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="816958a0f032f49a594b1d8da2c79bf4235daf44" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{#each}}&lt;/code&gt; helper loops over elements in a collection. It is an extension of the base Handlebars &lt;code&gt;{{#each}}&lt;/code&gt; helper. The default behavior of &lt;code&gt;{{#each}}&lt;/code&gt; is to yield its inner block once for every item in an array passing the item as the first block parameter.</source>
          <target state="translated">는 &lt;code&gt;{{#each}}&lt;/code&gt; 이 도우미는 컬렉션의 요소를 반복합니다. 기본 핸들 바 &lt;code&gt;{{#each}}&lt;/code&gt; 헬퍼 의 확장입니다 . &lt;code&gt;{{#each}}&lt;/code&gt; 의 기본 동작은 첫 번째 블록 매개 변수로 항목을 전달하는 배열의 모든 항목에 대해 내부 블록을 한 번 생성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c79d6054773867f3779b96924372f54a35225401" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{action}}&lt;/code&gt; helper provides a way to pass triggers for behavior (usually just a function) between components, and into components from controllers.</source>
          <target state="translated">&lt;code&gt;{{action}}&lt;/code&gt; 도우미 구성 요소 간의 동작에 대한 트리거 (대개 함수)를 통과하고, 컨트롤러의 구성 요소로 할 수있는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="dc88bcada3bcd41329cc8f3578d0c16a488a1ac2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{action}}&lt;/code&gt; modifier called &lt;code&gt;event.preventDefault()&lt;/code&gt; under the hood, but the &lt;code&gt;{{on}}&lt;/code&gt; modifier does not, so if you need to do anything other than the default action for a particular event, you must call &lt;code&gt;event.preventDefault&lt;/code&gt; within the action.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a6c5532500bbeb15495208ec4c966b8426e5b6f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{component}}&lt;/code&gt; helper lets you add instances of &lt;code&gt;Component&lt;/code&gt; to a template. See &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Component&quot;&gt;Component&lt;/a&gt; for additional information on how a &lt;code&gt;Component&lt;/code&gt; functions. &lt;code&gt;{{component}}&lt;/code&gt;'s primary use is for cases where you want to dynamically change which type of component is rendered as the state of your application changes. This helper has three modes: inline, block, and nested.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2188ae955717f0311ee55bfeb274d37ec4fab50a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{component}}&lt;/code&gt; helper lets you add instances of &lt;code&gt;Ember.Component&lt;/code&gt; to a template. See &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Component.html&quot;&gt;Ember.Component&lt;/a&gt; for additional information on how a &lt;code&gt;Component&lt;/code&gt; functions. &lt;code&gt;{{component}}&lt;/code&gt;'s primary use is for cases where you want to dynamically change which type of component is rendered as the state of your application changes. This helper has three modes: inline, block, and nested.</source>
          <target state="translated">&lt;code&gt;{{component}}&lt;/code&gt; 도우미는 인스턴스에 추가 할 수 있습니다 &lt;code&gt;Ember.Component&lt;/code&gt; 을 템플릿으로. &lt;code&gt;Component&lt;/code&gt; 작동 방법에 대한 추가 정보는 &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Component.html&quot;&gt;Ember.Component&lt;/a&gt; 를 참조하십시오 . &lt;code&gt;{{component}}&lt;/code&gt; 의 주요 용도는 애플리케이션 상태가 변경 될 때 렌더링되는 구성 요소 유형을 동적으로 변경하려는 경우에 사용됩니다. 이 도우미에는 인라인, 차단 및 중첩의 세 가지 모드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccb3abeccf1d3935a6c118b1810a1a10f67f5fd8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{each-in}}&lt;/code&gt; helper loops over properties on an object.</source>
          <target state="translated">&lt;code&gt;{{each-in}}&lt;/code&gt; 객체의 속성을 통해 도우미 루프.</target>
        </trans-unit>
        <trans-unit id="240feaf7ad994caa30e9d9dad22a171983e55e2d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{fn}}&lt;/code&gt; Helper</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d895059b0f1b0624bd9622f3e083c7eff2cb675f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{fn}}&lt;/code&gt; helper</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3212095109428b4cbc3365440b62953596163903" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{get}}&lt;/code&gt; helper allows you to dynamically specify which property to bind, while the &lt;code&gt;{{mut}}&lt;/code&gt; helper allows the binding to be updated from the input. See the respective helper documentation for more detail.</source>
          <target state="translated">&lt;code&gt;{{get}}&lt;/code&gt; (가) 동안 도우미는 동적 바인딩 할 속성을 지정할 수 있습니다 &lt;code&gt;{{mut}}&lt;/code&gt; 도우미 바인딩은 입력에서 업데이트 할 수 있습니다. 자세한 내용은 해당 도우미 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1dd52b3d4451df8b3e98fa8c26e98140209780df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{get}}&lt;/code&gt; helper allows you to dynamically specify which property to bind, while the &lt;code&gt;{{mut}}&lt;/code&gt; helper allows the binding to be updated from the input. See the respective helper documentation for more detail: &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Ember.Templates.helpers/methods#get&quot;&gt;&lt;code&gt;{{get}}&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Ember.Templates.helpers/methods#mut&quot;&gt;&lt;code&gt;{{mut}}&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b4f5775189e04e5beb9481aaf74caccbff888df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{get}}&lt;/code&gt; helper can also respect mutable values itself. For example:</source>
          <target state="translated">&lt;code&gt;{{get}}&lt;/code&gt; 도우미는 변경 가능한 값 자체를 존중 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bd0b47992fc4b78b9df9bbf1e6731c7ed45259f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{input}}&lt;/code&gt; helper lets you create an HTML &lt;code&gt;&amp;lt;input /&amp;gt;&lt;/code&gt; component. It causes an &lt;code&gt;Ember.TextField&lt;/code&gt; component to be rendered. For more info, see the &lt;a href=&quot;https://emberjs.com/api/classes/Ember.TextField.html&quot;&gt;Ember.TextField&lt;/a&gt; docs and the &lt;a href=&quot;https://emberjs.com/guides/templates/input-helpers/&quot;&gt;templates guide&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;{{input}}&lt;/code&gt; 도우미는 당신이 HTML 만들 수 있습니다 &lt;code&gt;&amp;lt;input /&amp;gt;&lt;/code&gt; 요소를. 그것은 발생 &lt;code&gt;Ember.TextField&lt;/code&gt; 의 컴포넌트가 렌더링된다. 자세한 내용은 &lt;a href=&quot;https://emberjs.com/api/classes/Ember.TextField.html&quot;&gt;Ember.TextField&lt;/a&gt; 문서 및 &lt;a href=&quot;https://emberjs.com/guides/templates/input-helpers/&quot;&gt;템플릿 안내서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a7acad9bb4a31001b61e35a4c0adf75c035da764" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{link-to}}&lt;/code&gt; Component</source>
          <target state="translated">&lt;code&gt;{{link-to}}&lt;/code&gt; 구성 요소</target>
        </trans-unit>
        <trans-unit id="3ea57e523caa15a38446ec50b9e79ddf92910c41" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{link-to}}&lt;/code&gt; component renders a link to the supplied &lt;code&gt;routeName&lt;/code&gt; passing an optionally supplied model to the route as its &lt;code&gt;model&lt;/code&gt; context of the route. The block for &lt;code&gt;{{link-to}}&lt;/code&gt; becomes the innerHTML of the rendered element:</source>
          <target state="translated">&lt;code&gt;{{link-to}}&lt;/code&gt; 요소가 제공하는 링크 렌더링 &lt;code&gt;routeName&lt;/code&gt; 그와 같은 경로를 선택적으로 공급 모델을 전달 &lt;code&gt;model&lt;/code&gt; 경로의 컨텍스트. &lt;code&gt;{{link-to}}&lt;/code&gt; 의 블록 은 렌더링 된 요소의 innerHTML이됩니다.</target>
        </trans-unit>
        <trans-unit id="e774d713fb0f90f4a303ddde2564100df64e2437" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{link-to}}&lt;/code&gt; component takes one or two arguments:</source>
          <target state="translated">&lt;code&gt;{{link-to}}&lt;/code&gt; 구성 요소는 하나 개 또는 두 개의 인수를 :</target>
        </trans-unit>
        <trans-unit id="39dd886ddbed7524e4a83856c25fa9788916f62d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{link-to}}&lt;/code&gt; helper will also add an &lt;code&gt;active&lt;/code&gt; class to the link that points to the currently active route.</source>
          <target state="translated">&lt;code&gt;{{link-to}}&lt;/code&gt; 도우미도 추가 할 것입니다 &lt;code&gt;active&lt;/code&gt; 이 점 현재 활성화 된 경로에 링크에 클래스를.</target>
        </trans-unit>
        <trans-unit id="90bfcd41e8565432c07cbbddf8858b5ba91f619a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{log}}&lt;/code&gt; helper also accepts primitive types such as strings or numbers.</source>
          <target state="translated">&lt;code&gt;{{log}}&lt;/code&gt; 도우미는 또한 문자열이나 숫자 등의 원시적 형을 받아들입니다.</target>
        </trans-unit>
        <trans-unit id="e201996bfd3ba8afd0712fffee879e9357d52b69" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{mount}}&lt;/code&gt; helper lets you embed a routeless engine in a template. Mounting an engine will cause an instance to be booted and its &lt;code&gt;application&lt;/code&gt; template to be rendered.</source>
          <target state="translated">&lt;code&gt;{{mount}}&lt;/code&gt; 도우미 템플릿에 routeless 엔진을 포함 할 수 있습니다. 엔진을 마운트하면 인스턴스가 부팅되고 해당 &lt;code&gt;application&lt;/code&gt; 템플릿이 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="2e95ed4a7acef7c8d23a923fbf339c5edcd4cf66" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{on}}&lt;/code&gt; Modifier</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7b0a3359c41146c4be8f10c4bd1c1af9ffd5991" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{on}}&lt;/code&gt; modifier</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0114680e3acb525c836a2dfd5bc6f7c20f8fce9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{on}}&lt;/code&gt; modifier lets you easily add event listeners (it uses &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener&quot;&gt;EventTarget.addEventListener&lt;/a&gt; internally).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31eeebbd0adb9055cb1d8e00dfafd1d5331e5d95" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{outlet}}&lt;/code&gt; helper lets you specify where a child route will render in your template. An important use of the &lt;code&gt;{{outlet}}&lt;/code&gt; helper is in your application's &lt;code&gt;application.hbs&lt;/code&gt; file:</source>
          <target state="translated">&lt;code&gt;{{outlet}}&lt;/code&gt; 도우미 아이 경로는 템플릿에 렌더링 위치를 지정할 수 있습니다. &lt;code&gt;{{outlet}}&lt;/code&gt; 헬퍼 의 중요한 사용법은 응용 프로그램의 &lt;code&gt;application.hbs&lt;/code&gt; 파일에 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ebbf8fe3922c7aefb3561c65af8dc306db37942" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{unbound}}&lt;/code&gt; helper disconnects the one-way binding of a property, essentially freezing its value at the moment of rendering. For example, in this example the display of the variable &lt;code&gt;name&lt;/code&gt; will not change even if it is set with a new value:</source>
          <target state="translated">는 &lt;code&gt;{{unbound}}&lt;/code&gt; 도우미는 기본적으로 렌더링의 순간에 그 값을 동결, 속성의 결합 단방향 연결을 끊습니다. 예를 들어,이 예에서 변수 &lt;code&gt;name&lt;/code&gt; 의 표시 는 새 값으로 설정 되어도 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d49990e3735b9831607abf7ee9c337d84e066164" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;structure&lt;/em&gt; of these components is identical, but they have somewhat different content (the user's first initial) and attributes (the &lt;code&gt;title&lt;/code&gt; and &lt;code&gt;class&lt;/code&gt; attributes).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfb95953e4853806edc231fdf38f698d6bd6a93e" translate="yes" xml:space="preserve">
          <source>The API for &lt;code&gt;{{on}}&lt;/code&gt; is the same as JavaScript's native &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener&quot;&gt;&lt;code&gt;addEventListener&lt;/code&gt;&lt;/a&gt;. It receives the event name as the first argument, and a callback function as the second argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea5c5af6a1cd7d259b450f74a023e4bd5f103ab7" translate="yes" xml:space="preserve">
          <source>The Application Template</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c3bbef8d77a015f1b44f113e8413c77e1d8e3ae" translate="yes" xml:space="preserve">
          <source>The CLI &lt;code&gt;generate util&lt;/code&gt; command will create a utility file and a unit test. We'll delete the unit test since we don't want to test Google code.</source>
          <target state="translated">CLI &lt;code&gt;generate util&lt;/code&gt; 명령은 유틸리티 파일과 단위 테스트를 만듭니다. Google 코드를 테스트하고 싶지 않으므로 단위 테스트를 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="314686d9ca63241b41addc06dbaf29e1f9de2111" translate="yes" xml:space="preserve">
          <source>The CSS class name used for active classes can be customized for a single use of &lt;code&gt;{{link-to}}&lt;/code&gt; by passing an &lt;code&gt;activeClass&lt;/code&gt; option:</source>
          <target state="translated">&lt;code&gt;activeClass&lt;/code&gt; 옵션 을 전달하여 &lt;code&gt;{{link-to}}&lt;/code&gt; 의 단일 사용을 위해 활성 클래스에 사용되는 CSS 클래스 이름을 사용자 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a18277d28224fe13bf61456994d23cdddba18d00" translate="yes" xml:space="preserve">
          <source>The CSS class to apply to &lt;code&gt;LinkComponent&lt;/code&gt;'s element when its &lt;code&gt;active&lt;/code&gt; property is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;active&lt;/code&gt; 속성이 &lt;code&gt;true&lt;/code&gt; 일 때 &lt;code&gt;LinkComponent&lt;/code&gt; 요소 에 적용 할 CSS 클래스 입니다 .</target>
        </trans-unit>
        <trans-unit id="3560d1810ba6a290f018a30acb7a6abe17dc478d" translate="yes" xml:space="preserve">
          <source>The Component Lifecycle</source>
          <target state="translated">구성 요소 수명주기</target>
        </trans-unit>
        <trans-unit id="54973a80b2d95fa00a37554801d6e43a8529a06b" translate="yes" xml:space="preserve">
          <source>The Component Tree</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8f803b88937c7eaa188957977fa8a0218a4aa93" translate="yes" xml:space="preserve">
          <source>The Components tab displays a collapsible representation of the views and components that are currently being rendered. Selecting a component from the tree will open it in the &lt;a href=&quot;../object-inspector&quot;&gt;Object Inspector&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be34b5a31efa66b89e017638eee272b8df985bde" translate="yes" xml:space="preserve">
          <source>The DOM events for which the event dispatcher should listen.</source>
          <target state="translated">이벤트 디스패처가 청취해야하는 DOM 이벤트.</target>
        </trans-unit>
        <trans-unit id="16262c4e9109f80339ca991e19c44c9238c16f0c" translate="yes" xml:space="preserve">
          <source>The Data tab is kept in sync with the data loaded in your application. Any record additions, deletions, or changes are reflected immediately. If you have unsaved records, they will be displayed in green by clicking on the New pill.</source>
          <target state="translated">데이터 탭은 응용 프로그램에로드 된 데이터와 동기화되어 유지됩니다. 모든 레코드 추가, 삭제 또는 변경 사항이 즉시 반영됩니다. 저장하지 않은 기록이있는 경우 새 알약을 클릭하면 녹색으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="d52fbf4800c86d55bd033e9092c8b9094d06aa21" translate="yes" xml:space="preserve">
          <source>The DefaultResolver defines the default lookup rules to resolve container lookups before consulting the container for registered items:</source>
          <target state="translated">DefaultResolver는 등록 된 항목을 컨테이너에 문의하기 전에 컨테이너 조회를 해결하기위한 기본 조회 규칙을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="c29711481fa25b48f2527c2fa7d8f0b8bed7a3b1" translate="yes" xml:space="preserve">
          <source>The Development Server</source>
          <target state="translated">개발 서버</target>
        </trans-unit>
        <trans-unit id="ed05a3cd2719814bf85e78b39e4626d5b1cd6abf" translate="yes" xml:space="preserve">
          <source>The Duration column displays the render time for a given template, including the template's children.</source>
          <target state="translated">Duration 열에는 템플릿의 자식을 포함하여 지정된 템플릿의 렌더링 시간이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="2ea15e43ed02f23a492330509b7d70ff1b380882" translate="yes" xml:space="preserve">
          <source>The ENV object contains three important keys:</source>
          <target state="translated">ENV 객체에는 세 가지 중요한 키가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f945314114021b149d52673626a64f4c3fb7096" translate="yes" xml:space="preserve">
          <source>The Ember Data store provides an interface for retrieving records of a single type.</source>
          <target state="translated">Ember 데이터 저장소는 단일 유형의 레코드를 검색하기위한 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="487c17cf393eda62f1f2c80da81270c64a1b3885" translate="yes" xml:space="preserve">
          <source>The Ember Inspector is a browser add-on designed to help you understand and debug your Ember applications. You can install it on &lt;a href=&quot;installation#toc_google-chrome&quot;&gt;Google Chrome&lt;/a&gt;, &lt;a href=&quot;installation#toc_firefox&quot;&gt;Firefox&lt;/a&gt; and &lt;a href=&quot;installation#toc_via-bookmarklet&quot;&gt;other browsers&lt;/a&gt; (via a bookmarklet)</source>
          <target state="translated">Ember Inspector는 Ember 응용 프로그램을 이해하고 디버깅하는 데 도움이되도록 설계된 브라우저 애드온입니다. &lt;a href=&quot;installation#toc_google-chrome&quot;&gt;Chromelet&lt;/a&gt; , &lt;a href=&quot;installation#toc_firefox&quot;&gt;Firefox&lt;/a&gt; 및 &lt;a href=&quot;installation#toc_via-bookmarklet&quot;&gt;기타 브라우저&lt;/a&gt; (북마크릿을 통해) 에 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5ad72511f1a7b31a3a54993b2baf0d48b44720c" translate="yes" xml:space="preserve">
          <source>The Ember Router allows you to provide feedback that a route is loading, as well as when an error occurs in loading a route.</source>
          <target state="translated">Ember 라우터를 사용하면 경로를로드 할 때 오류가 발생할 때뿐만 아니라 경로가로드되고 있다는 피드백을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ea4b816f906b34f146cdfa88e561a4f6528023a" translate="yes" xml:space="preserve">
          <source>The Ember application is inside a sandboxed iframe with no URL (if you are using JS Bin, follow &lt;a href=&quot;#toc_using-the-inspector-with-js-bin&quot;&gt;these steps&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d259bb541551f92c36e45ba009a06cd16a1ca136" translate="yes" xml:space="preserve">
          <source>The Ember application is inside a sandboxed iframe with no url (if you are using JS Bin, follow &lt;a href=&quot;#toc_using-the-inspector-with-js-bin&quot;&gt;these steps&lt;/a&gt;.</source>
          <target state="translated">Ember 애플리케이션은 URL이없는 샌드 박스 iframe 안에 있습니다 (JS Bin을 사용하는 경우 &lt;a href=&quot;#toc_using-the-inspector-with-js-bin&quot;&gt;다음 단계를 수행하십시오)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="af24320baeebbee895e834cbd681b449b1bcd52c" translate="yes" xml:space="preserve">
          <source>The Ember community publishes and maintains many addons, and it can be difficult to know if one (or many!) exists that covers your needs. The website &lt;a href=&quot;https://www.emberobserver.com/&quot;&gt;Ember Observer&lt;/a&gt; keeps an up-to-date index of Ember Addons, sorted by categories, and rated according to objective metrics. If you are looking for an addon, we recommend that you start there!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf6333e738da626887805c4ba5c1a1355ba0d71f" translate="yes" xml:space="preserve">
          <source>The Ember community values collaboration and building common tools that everyone relies on. If you're interested in deploying your app to production in a fast and reliable way, check out the &lt;a href=&quot;http://ember-cli-deploy.com/&quot;&gt;Ember CLI Deploy&lt;/a&gt; addon.</source>
          <target state="translated">Ember 커뮤니티는 협업과 모든 사람이 사용하는 공통 도구 구축을 중요하게 생각합니다. 빠르고 안정적인 방식으로 프로덕션에 앱을 &lt;a href=&quot;http://ember-cli-deploy.com/&quot;&gt;배포&lt;/a&gt; 하려면 Ember CLI Deploy 애드온을 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="dd16b48b3b7627eda9a94aaf81db356a438f0ccb" translate="yes" xml:space="preserve">
          <source>The Ember router has four options to manage your application's URL: &lt;code&gt;history&lt;/code&gt;, which uses the HTML5 History API; &lt;code&gt;hash&lt;/code&gt;, which uses anchor-based URLs; &lt;code&gt;auto&lt;/code&gt;, which uses &lt;code&gt;history&lt;/code&gt; if supported by the user's browser, and falls back to &lt;code&gt;hash&lt;/code&gt; otherwise; and &lt;code&gt;none&lt;/code&gt;, which doesn't update the URL. By default, Ember CLI configures the router to use &lt;code&gt;auto&lt;/code&gt;. You can change this option in &lt;code&gt;config/environment.js&lt;/code&gt; under &lt;code&gt;ENV.locationType&lt;/code&gt;.</source>
          <target state="translated">Ember 라우터에는 애플리케이션의 URL을 관리하는 4 가지 옵션이 있습니다 : &lt;code&gt;history&lt;/code&gt; , HTML5 History API를 사용합니다. 앵커 기반 URL을 사용하는 &lt;code&gt;hash&lt;/code&gt; ; &lt;code&gt;auto&lt;/code&gt; 는 사용자 브라우저에서 지원하는 경우 &lt;code&gt;history&lt;/code&gt; 을 사용 하고 그렇지 않으면 &lt;code&gt;hash&lt;/code&gt; 로 폴백 합니다. 및 &lt;code&gt;none&lt;/code&gt; URL을 업데이트하지 않습니다. 기본적으로 Ember CLI는 라우터가 &lt;code&gt;auto&lt;/code&gt; 를 사용하도록 구성합니다 . &lt;code&gt;ENV.locationType&lt;/code&gt; 아래의 &lt;code&gt;config/environment.js&lt;/code&gt; 에서이 옵션을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a7a78387322a36a85c1c5009f5fb0f7c35f76084" translate="yes" xml:space="preserve">
          <source>The Guides are intended to contain practical explanations of how to build Ember apps, focusing on the most widely-used features of Ember.js. For comprehensive documentation of every Ember feature and API, see the &lt;a href=&quot;http://emberjs.com/api/&quot;&gt;Ember.js API documentation&lt;/a&gt;.</source>
          <target state="translated">이 안내서에는 Ember.js의 가장 널리 사용되는 기능을 중심으로 Ember 앱을 구축하는 방법에 대한 실제 설명이 포함되어 있습니다. 모든 Ember 기능 및 API에 대한 포괄적 인 설명서는 &lt;a href=&quot;http://emberjs.com/api/&quot;&gt;Ember.js API 설명서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="171cd31c1e6f13733fc0b87625558c93f2e08163" translate="yes" xml:space="preserve">
          <source>The Guides are intended to contain practical explanations of how to build Ember apps, focusing on the most widely-used features of Ember.js. For comprehensive documentation of every Ember feature and API, see the &lt;a href=&quot;https://api.emberjs.com/&quot;&gt;Ember.js API documentation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f275cf778b6d119ab020c3d01e5250ad0219426" translate="yes" xml:space="preserve">
          <source>The Guides begin with an explanation of how to get started with Ember, followed by a tutorial on how to build your first Ember app. If you're brand new to Ember, we recommend you start off by following along with these first two sections of the Guides.</source>
          <target state="translated">이 안내서는 Ember를 시작하는 방법에 대한 설명과 첫 번째 Ember 앱을 구축하는 방법에 대한 자습서로 시작됩니다. Ember를 처음 사용하는 경우 가이드의 처음 두 섹션과 함께 시작하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3c07d3314a98bd2f32c93ed811bdc5e03c2e9eb7" translate="yes" xml:space="preserve">
          <source>The HTML &lt;code&gt;class&lt;/code&gt; attribute of a component's tag can be set by providing a &lt;code&gt;classNames&lt;/code&gt; property that is set to an array of strings:</source>
          <target state="translated">문자열 배열로 설정된 &lt;code&gt;classNames&lt;/code&gt; 속성을 제공하여 구성 요소 태그 의 HTML &lt;code&gt;class&lt;/code&gt; 속성을 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="712c891dbe91ea95b6ed85832f3affbadeaa1d8c" translate="yes" xml:space="preserve">
          <source>The HTML &lt;code&gt;id&lt;/code&gt; of the component's element in the DOM. You can provide this value yourself but it must be unique (just as in HTML):</source>
          <target state="translated">DOM에서 컴포넌트 요소의 HTML &lt;code&gt;id&lt;/code&gt; 입니다. 이 값을 직접 제공 할 수 있지만 HTML과 마찬가지로 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="77babb069a61a648d0e212eb50fbca403ad78359" translate="yes" xml:space="preserve">
          <source>The HTML &lt;code&gt;id&lt;/code&gt; of the view's element in the DOM. You can provide this value yourself but it must be unique (just as in HTML):</source>
          <target state="translated">DOM에서보기 요소 의 HTML &lt;code&gt;id&lt;/code&gt; 입니다. 이 값을 직접 제공 할 수 있지만 HTML과 마찬가지로 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="d5ce9a853ceec8935a32736d2ed256b8ef580453" translate="yes" xml:space="preserve">
          <source>The HTML attribute section of a component's tag can be set by providing an &lt;code&gt;attributeBindings&lt;/code&gt; property set to an array of property names on the component. The return value of these properties will be used as the value of the component's HTML associated attribute:</source>
          <target state="translated">구성 요소 태그의 HTML 속성 섹션은 구성 요소의 특성 이름 배열에 &lt;code&gt;attributeBindings&lt;/code&gt; 특성 세트를 제공하여 설정할 수 있습니다 . 이러한 속성의 반환 값은 구성 요소의 HTML 관련 특성 값으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f3ca8096b2b2a08769eef8f9d51a7c386381b928" translate="yes" xml:space="preserve">
          <source>The IDs will be passed as a URL-encoded Array of IDs, in this form:</source>
          <target state="translated">ID는 다음과 같은 형식으로 URL 인코딩 된 ID 배열로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="c9440c491aa7e5a5571ef8d623370fad7dc61a99" translate="yes" xml:space="preserve">
          <source>The Inspector displays the parent objects and mixins that are composed into the chosen object, including the inherited properties.</source>
          <target state="translated">인스펙터는 상속 된 속성을 포함하여 선택된 객체로 구성된 상위 객체와 믹스 인을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="751510e2504c4b774d23cdd66c8c40b91042175d" translate="yes" xml:space="preserve">
          <source>The Inspector displays these routes:</source>
          <target state="translated">인스펙터는 다음 경로를 표시합니다 :</target>
        </trans-unit>
        <trans-unit id="690c38e1e0e3e9aad8aa3afc61469ec327e5aab8" translate="yes" xml:space="preserve">
          <source>The Inspector highlights the currently active routes. However, if your app has grown too large for this to be useful, you can use the &lt;code&gt;Current Route Only&lt;/code&gt; checkbox to hide all routes except the currently active ones.</source>
          <target state="translated">인스펙터는 현재 활성화 된 경로를 강조 표시합니다. 그러나 앱이 너무 커져 유용하지 않은 경우 &lt;code&gt;Current Route Only&lt;/code&gt; 확인란을 사용 하여 현재 활성화 된 경로를 제외한 모든 경로를 숨길 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f30f50f616f12ec02246e464e631a2ca7d407d6d" translate="yes" xml:space="preserve">
          <source>The Inspector includes a panel that allows you to view and interact with your Ember objects. To open it, click on any Ember object. You can then view the object's properties.</source>
          <target state="translated">인스펙터에는 Ember 객체를보고 상호 작용할 수있는 패널이 있습니다. 그것을 열려면 Ember 객체를 클릭하십시오. 그런 다음 객체의 속성을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b07f0c70b2f17b1a0937f0084ad1769ae1c7b677" translate="yes" xml:space="preserve">
          <source>The Inspector provides a way to look at all Promises created in your application. Click on the &lt;code&gt;Promises&lt;/code&gt; menu to start inspecting them.</source>
          <target state="translated">인스펙터는 어플리케이션에서 생성 된 모든 약속을 볼 수있는 방법을 제공합니다. &lt;code&gt;Promises&lt;/code&gt; 메뉴를 클릭하여 검사를 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="62cf4d7c67083a3006feaede174affa0b51ea132" translate="yes" xml:space="preserve">
          <source>The Inspector provides a way to view a Promise's stack trace. Tracing Promises is disabled by default for performance reasons. To enable tracing, check the &lt;code&gt;Trace promise&lt;/code&gt; checkbox. You may want to reload to trace existing Promises.</source>
          <target state="translated">인스펙터는 Promise의 스택 트레이스를 볼 수있는 방법을 제공합니다. 성능상의 이유로 추적 약속은 기본적으로 비활성화되어 있습니다. 추적을 사용하려면 &lt;code&gt;Trace promise&lt;/code&gt; 확인란을 선택하십시오. 기존 약속을 추적하기 위해 다시로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a817980043f7fb6f67f44a551dd1bc461d4d9f8e" translate="yes" xml:space="preserve">
          <source>The JSON API adapter will automatically send a &lt;code&gt;GET&lt;/code&gt; request to &lt;code&gt;/posts/1&lt;/code&gt;.</source>
          <target state="translated">JSON API 어댑터는 &lt;code&gt;GET&lt;/code&gt; 요청을 &lt;code&gt;/posts/1&lt;/code&gt; 로 자동 전송합니다 .</target>
        </trans-unit>
        <trans-unit id="010af95fc7f9a5c21dd89196b646d7c1093ea5b8" translate="yes" xml:space="preserve">
          <source>The JSON payload should be an object that contains the record inside a root property. For example, in response to a &lt;code&gt;GET&lt;/code&gt; request for &lt;code&gt;/posts/1&lt;/code&gt;, the JSON should look like this:</source>
          <target state="translated">JSON 페이로드는 루트 속성 내에 레코드가 포함 된 객체 여야합니다. 예를 들어 &lt;code&gt;/posts/1&lt;/code&gt; 에 대한 &lt;code&gt;GET&lt;/code&gt; 요청에 대한 JSON은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="01e0b389167fcbb21b9dfab152a2b6136aa145d1" translate="yes" xml:space="preserve">
          <source>The JSON returned should look like this:</source>
          <target state="translated">반환 된 JSON은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="04d2c141e4adc4849c1a9d91f7f144599c2898c1" translate="yes" xml:space="preserve">
          <source>The JSON should encode the relationship as an ID to another record:</source>
          <target state="translated">JSON은 관계를 다른 레코드의 ID로 인코딩해야합니다.</target>
        </trans-unit>
        <trans-unit id="8b9146885924e80940db37b81326f9209df93900" translate="yes" xml:space="preserve">
          <source>The JSON should encode the relationship as an array of IDs and types:</source>
          <target state="translated">JSON은 관계를 ID 및 유형의 배열로 인코딩해야합니다.</target>
        </trans-unit>
        <trans-unit id="6e8ce80ea19f94ae1f67487717c1c1102e6c43b1" translate="yes" xml:space="preserve">
          <source>The JSON:API adapter will automatically send a &lt;code&gt;GET&lt;/code&gt; request to &lt;code&gt;/posts/1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="663c959e7f02d1a965ff9bc467fe56677cdc3d5e" translate="yes" xml:space="preserve">
          <source>The JSON:API adapter will now make requests for &lt;code&gt;Campus&lt;/code&gt; models to &lt;code&gt;/campuses&lt;/code&gt; and &lt;code&gt;/campuses/1&lt;/code&gt; (instead of &lt;code&gt;/campus/&lt;/code&gt; and &lt;code&gt;/campus/1&lt;/code&gt;), and requests for &lt;code&gt;advice&lt;/code&gt; to &lt;code&gt;/advice&lt;/code&gt; and &lt;code&gt;/advice/1&lt;/code&gt; (instead of &lt;code&gt;/advices/&lt;/code&gt; and &lt;code&gt;/advices/1&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72ba4ee7e150eef0fccde680666bfff57c452740" translate="yes" xml:space="preserve">
          <source>The JSONAPIAdapter uses JSON API conventions for building the URL for a record and selecting the HTTP verb to use with a request. The actions you can take on a record map onto the following URLs in the JSON API adapter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa6abe7bb9f4b0f9e54508fdc1d5224614314c01" translate="yes" xml:space="preserve">
          <source>The JSONAPIAdapter uses JSON API conventions for building the url for a record and selecting the HTTP verb to use with a request. The actions you can take on a record map onto the following URLs in the JSON API adapter:</source>
          <target state="translated">JSONAPIAdapter는 JSON API 규칙을 사용하여 레코드의 URL을 작성하고 요청에 사용할 HTTP 동사를 선택합니다. 레코드 맵에서 수행 할 수있는 조치는 JSON API 어댑터의 다음 URL에 있습니다.</target>
        </trans-unit>
        <trans-unit id="319a4c20db8f22613ffca3673ffd0b4f116cbd53" translate="yes" xml:space="preserve">
          <source>The JSONAPIAdapter will consider a success any response with a status code of the 2xx family (&quot;Success&quot;), as well as 304 (&quot;Not Modified&quot;). Any other status code will be considered a failure.</source>
          <target state="translated">JSONAPIAdapter는 2xx 제품군 ( &quot;성공&quot;)의 상태 코드와 304 ( &quot;수정되지 않음&quot;)의 응답이 성공한 것으로 간주합니다. 다른 상태 코드는 실패로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="f974fd383c2a0a1df4e730ce000912a320c7420d" translate="yes" xml:space="preserve">
          <source>The JavaScript Error object used by Ember.assert.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="487ab77d5dbd345e6346d5f74c302b58d482236b" translate="yes" xml:space="preserve">
          <source>The Model Hook</source>
          <target state="translated">모델 훅</target>
        </trans-unit>
        <trans-unit id="97c09292b53b45afc09c57770f7220ff9a4c953a" translate="yes" xml:space="preserve">
          <source>The NativeArray mixin contains the properties needed to make the native Array support Ember.MutableArray and all of its dependent APIs. Unless you have &lt;code&gt;EmberENV.EXTEND_PROTOTYPES&lt;/code&gt; or &lt;code&gt;EmberENV.EXTEND_PROTOTYPES.Array&lt;/code&gt; set to false, this will be applied automatically. Otherwise you can apply the mixin at anytime by calling &lt;code&gt;Ember.NativeArray.apply(Array.prototype)&lt;/code&gt;.</source>
          <target state="translated">NativeArray 믹스 인에는 네이티브 배열이 Ember.MutableArray 및 모든 종속 API를 지원하는 데 필요한 속성이 포함되어 있습니다. &lt;code&gt;EmberENV.EXTEND_PROTOTYPES&lt;/code&gt; 또는 &lt;code&gt;EmberENV.EXTEND_PROTOTYPES.Array&lt;/code&gt; 를 false로 설정 하지 않으면 이 값이 자동으로 적용됩니다. 그렇지 않으면 &lt;code&gt;Ember.NativeArray.apply(Array.prototype)&lt;/code&gt; 을 호출하여 언제든지 믹스 인을 적용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5acd2f3fd8e6e1b2d468fa2fd3e181209d0b1609" translate="yes" xml:space="preserve">
          <source>The NativeArray mixin contains the properties needed to make the native Array support MutableArray and all of its dependent APIs. Unless you have &lt;code&gt;EmberENV.EXTEND_PROTOTYPES&lt;/code&gt; or &lt;code&gt;EmberENV.EXTEND_PROTOTYPES.Array&lt;/code&gt; set to false, this will be applied automatically. Otherwise you can apply the mixin at anytime by calling &lt;code&gt;Ember.NativeArray.apply(Array.prototype)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9b65ae9629384b86f0a3ac3136275bf91020819" translate="yes" xml:space="preserve">
          <source>The New Message Input</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f728d39e800e681d2478973af1aacfb873e272e4" translate="yes" xml:space="preserve">
          <source>The Parent Route</source>
          <target state="translated">부모 루트</target>
        </trans-unit>
        <trans-unit id="8e7bb3b57567e2227a221f010574edc6b4965cd1" translate="yes" xml:space="preserve">
          <source>The REST adapter allows your store to communicate with an HTTP server by transmitting JSON via XHR. Most Ember.js apps that consume a JSON API should use the REST adapter.</source>
          <target state="translated">REST 어댑터를 사용하면 상점이 XHR을 통해 JSON을 전송하여 상점이 HTTP 서버와 통신 할 수 있습니다. JSON API를 사용하는 대부분의 Ember.js 앱은 REST 어댑터를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="fc6f2d961e0e8648bf62845bef00cfd62c181e1b" translate="yes" xml:space="preserve">
          <source>The REST adapter expects the JSON returned from your server to follow these conventions.</source>
          <target state="translated">REST 어댑터는 서버에서 리턴 된 JSON이 이러한 규칙을 따를 것으로 예상합니다.</target>
        </trans-unit>
        <trans-unit id="5ebe4d3849e4f0595a2c49dc9cebb6616874d70b" translate="yes" xml:space="preserve">
          <source>The REST adapter will consider a success any response with a status code of the 2xx family (&quot;Success&quot;), as well as 304 (&quot;Not Modified&quot;). Any other status code will be considered a failure.</source>
          <target state="translated">REST 어댑터는 2xx 제품군 ( &quot;성공&quot;)의 상태 코드와 304 ( &quot;수정되지 않음&quot;)의 응답이 성공한 것으로 간주합니다. 다른 상태 코드는 실패로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="b3b95d4fe88347e6289fc0aedef69eeed34f95c2" translate="yes" xml:space="preserve">
          <source>The Received Message</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3172f22137802d4a8642cfa5668354ec4d3eeea5" translate="yes" xml:space="preserve">
          <source>The Router Pauses for Promises</source>
          <target state="translated">라우터가 약속을 위해 멈춤</target>
        </trans-unit>
        <trans-unit id="5173699439dec730d6932d8fca8ce730f73eabdc" translate="yes" xml:space="preserve">
          <source>The Router service is the public API that provides access to the router.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efc37914e3487c9ca3df5d1d763f3449e864fe55" translate="yes" xml:space="preserve">
          <source>The Router service is the public API that provides component/view layer access to the router.</source>
          <target state="translated">라우터 서비스는 라우터에 대한 컴포넌트 / 뷰 레이어 액세스를 제공하는 공개 API입니다.</target>
        </trans-unit>
        <trans-unit id="0c9d4cff939b6e9fcde57c63e9fa2dc698d186a0" translate="yes" xml:space="preserve">
          <source>The Routes tab displays a list of your application's routes.</source>
          <target state="translated">경로 탭에는 응용 프로그램의 경로 목록이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="84729b1e90f85ba399f1de4cfa6c0e4c113086c4" translate="yes" xml:space="preserve">
          <source>The Run Loop</source>
          <target state="translated">런 루프</target>
        </trans-unit>
        <trans-unit id="c32cedc8b4658f5a2c9ec3fd3e53275c0943aca6" translate="yes" xml:space="preserve">
          <source>The SOLID principles of good design tell us that objects should have a single responsibility. The responsibility of a component should be presenting model data to the user, not fetching the model.</source>
          <target state="translated">우수한 디자인의 SOLID 원칙은 객체에 단일 책임이 있어야 함을 알려줍니다. 구성 요소의 책임은 모델을 가져 오지 않고 사용자에게 모델 데이터를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="27e2511593535f887df2079da995aee5cb7996cf" translate="yes" xml:space="preserve">
          <source>The Sent Message</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2750c3a85432d63bf43d76ed414a487327be0ac0" translate="yes" xml:space="preserve">
          <source>The Store and a Single Source of Truth</source>
          <target state="translated">상점과 진실의 단일 출처</target>
        </trans-unit>
        <trans-unit id="45328ea59c1214501dde9c95207252958c40b1b9" translate="yes" xml:space="preserve">
          <source>The Transition's internal promise. Calling &lt;code&gt;.then&lt;/code&gt; on this property is that same as calling &lt;code&gt;.then&lt;/code&gt; on the Transition object itself, but this property is exposed for when you want to pass around a Transition's promise, but not the Transition object itself, since Transition object can be externally &lt;code&gt;abort&lt;/code&gt;ed, while the promise cannot.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f42b50dcb01303923e39ca4b080e7c21fefec38" translate="yes" xml:space="preserve">
          <source>The URL can be set in a few ways:</source>
          <target state="translated">몇 가지 방법으로 URL을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0bcc0cf43c5c46031ea589d18baa3c4b454de17b" translate="yes" xml:space="preserve">
          <source>The View Tree</source>
          <target state="translated">뷰 트리</target>
        </trans-unit>
        <trans-unit id="41ef7117b31fdc6690fac73d0b81e21453b46c57" translate="yes" xml:space="preserve">
          <source>The View Tree ignores components and inline views by default. To load these into the View Tree check the &lt;code&gt;Components&lt;/code&gt; and &lt;code&gt;All Views&lt;/code&gt; checkboxes.</source>
          <target state="translated">뷰 트리는 기본적으로 구성 요소 및 인라인 뷰를 무시합니다. 이를 뷰 트리에로드하려면 &lt;code&gt;Components&lt;/code&gt; 및 &lt;code&gt;All Views&lt;/code&gt; 확인란을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="b3bb30d409dd94a905d7278b4f7300834afaa9d8" translate="yes" xml:space="preserve">
          <source>The WAI-ARIA role of the control represented by this view. For example, a button may have a role of type 'button', or a pane may have a role of type 'alertdialog'. This property is used by assistive software to help visually challenged users navigate rich web applications.</source>
          <target state="translated">이 뷰로 표시되는 컨트롤의 WAI-ARIA 역할. 예를 들어, 단추에는 'button'유형의 역할이 있거나 분할 창에 'alertdialog'유형의 역할이있을 수 있습니다. 이 속성은 시각 장애인이 풍부한 웹 응용 프로그램을 탐색 할 수 있도록 보조 소프트웨어에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="599db392fb52dd7a9d9ebf1a02ad877e6dc24952" translate="yes" xml:space="preserve">
          <source>The ability to consume a growing ecosystem of &lt;a href=&quot;https://emberobserver.com/&quot;&gt;Ember Addons&lt;/a&gt;.</source>
          <target state="translated">성장하는 &lt;a href=&quot;https://emberobserver.com/&quot;&gt;Ember Addons의&lt;/a&gt; 생태계를 소비하는 능력 .</target>
        </trans-unit>
        <trans-unit id="236eb25e1509b24135c459c63eaaa974644a72a7" translate="yes" xml:space="preserve">
          <source>The above code will allow you invoke the &lt;code&gt;sum()&lt;/code&gt; function as a &lt;code&gt;{{sum}}&lt;/code&gt; handlebars &quot;helper&quot; in your templates:</source>
          <target state="translated">위의 코드를 통해 템플릿에서 &lt;code&gt;{{sum}}&lt;/code&gt; 핸들 바 &quot;도우미&quot; 로 &lt;code&gt;sum()&lt;/code&gt; 함수 를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="17aff5f3819b34917a219ca60e2165bb9008b501" translate="yes" xml:space="preserve">
          <source>The above example contains two arguments:</source>
          <target state="translated">위의 예에는 두 가지 인수가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f30b8685376aad3470d0d8bc20b92baa1adf445" translate="yes" xml:space="preserve">
          <source>The above example returns the original arguments (after your customizations) back to the parent class, so it can continue with its normal operations.</source>
          <target state="translated">위의 예제는 사용자 지정 후 원래 인수를 부모 클래스로 다시 반환하므로 정상적인 작업을 계속할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0de72be9fc4a958c468aab5fce926f1c1d8e1f2a" translate="yes" xml:space="preserve">
          <source>The above example template will render a template named &quot;-nav&quot;, which has the same context as the parent template it's rendered into, so if the &quot;-nav&quot; template also referenced &lt;code&gt;{{foo}}&lt;/code&gt;, it would print the same thing as the &lt;code&gt;{{foo}}&lt;/code&gt; in the above example.</source>
          <target state="translated">위의 예제 템플릿은 렌더링되는 상위 템플릿과 동일한 컨텍스트를 가진 &quot;-nav&quot;라는 템플릿을 렌더링하므로 &quot;-nav&quot;템플릿도 &lt;code&gt;{{foo}}&lt;/code&gt; 를 참조 하면 &lt;code&gt;{{foo}}&lt;/code&gt; 위의 예이다.</target>
        </trans-unit>
        <trans-unit id="b5a49ec8b75cd43831c857a7b5a6f317839e3550" translate="yes" xml:space="preserve">
          <source>The above example will look up the value of &lt;code&gt;someTemplateName&lt;/code&gt; on the template context (e.g. a controller) and use that value as the name of the template to render. If the resolved value is falsy, nothing will be rendered. If &lt;code&gt;someTemplateName&lt;/code&gt; changes, the partial will be re-rendered using the new template name.</source>
          <target state="translated">위의 예제는 템플릿 컨텍스트 (예 : 컨트롤러) 에서 &lt;code&gt;someTemplateName&lt;/code&gt; 의 값을 찾고 해당 값을 렌더링 할 템플릿의 이름으로 사용합니다. 해결 된 값이 거짓이면 아무것도 렌더링되지 않습니다. 경우 &lt;code&gt;someTemplateName&lt;/code&gt; 이 변경 부분은 새 템플릿의 이름을 사용하여 렌더링 재됩니다.</target>
        </trans-unit>
        <trans-unit id="4a17372c1a6f0d338afcba08934ad438cff05188" translate="yes" xml:space="preserve">
          <source>The above example will print a list like this:</source>
          <target state="translated">위의 예는 다음과 같은 목록을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="14759cf8b76d4ce53586ecc24fe64560891c5d11" translate="yes" xml:space="preserve">
          <source>The above template and controller render as the following HTML:</source>
          <target state="translated">위의 템플릿과 컨트롤러는 다음 HTML로 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="647c3ca2996d871bb4527f63fd867d23a1ddf4a8" translate="yes" xml:space="preserve">
          <source>The above template will render HTML like this:</source>
          <target state="translated">위의 템플릿은 다음과 같이 HTML을 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="1b6db4d979bea0f132b8aecf3e051e28b2ff75cb" translate="yes" xml:space="preserve">
          <source>The above will result in the following HTML output:</source>
          <target state="translated">위의 결과는 다음과 같은 HTML 출력이됩니다.</target>
        </trans-unit>
        <trans-unit id="3d75636210394ce5e5a666bfe55c598294499452" translate="yes" xml:space="preserve">
          <source>The absolute best method for learning how a screen reader works is using one yourself! It might feel a little awkward at first, but understanding how to use a screen reader (and other assistive technology) will help you become a more skilled developer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f4cb9f31c2595e4f16286bd14d0a1224fdd7a4e" translate="yes" xml:space="preserve">
          <source>The action &lt;code&gt;deleteUser&lt;/code&gt; is in quotes, since &lt;code&gt;system-preferences-editor&lt;/code&gt; is where the action is defined now. Quotes indicate that the action should be looked for in &lt;code&gt;actions&lt;/code&gt; local to that component, rather than in those that have been passed from a parent.</source>
          <target state="translated">&lt;code&gt;system-preferences-editor&lt;/code&gt; 가 조치가 정의 된 위치 이므로 &lt;code&gt;deleteUser&lt;/code&gt; 조치 는 따옴표로 묶습니다 . 인용 부호 는 상위에서 전달 된 것이 아니라 해당 구성 요소의 로컬 &lt;code&gt;actions&lt;/code&gt; 에서 조치 를 찾아야 함을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="8e4c226f28ea2d4ccbb31bb1fe60fdb964130638" translate="yes" xml:space="preserve">
          <source>The action decorator also &lt;em&gt;binds&lt;/em&gt; actions, so you can refer to them directly in templates without the &lt;code&gt;{{action}}&lt;/code&gt; helper:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc124545536eb0f1b78bc91d3e1823a25158f2d9" translate="yes" xml:space="preserve">
          <source>The action to trigger</source>
          <target state="translated">트리거 할 조치</target>
        </trans-unit>
        <trans-unit id="fffafad4245d122f1f8b1d4f82482f6c6e9972ee" translate="yes" xml:space="preserve">
          <source>The actions &quot;play&quot; and &quot;stop&quot; must be passed to this &lt;code&gt;play-button&lt;/code&gt; component:</source>
          <target state="translated">&quot;재생&quot;및 &quot;중지&quot;작업은이 &lt;code&gt;play-button&lt;/code&gt; 구성 요소 로 전달되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="b15d60efde70e42a8401dc81cb70c844a7ab5b07" translate="yes" xml:space="preserve">
          <source>The actions you can take on a record map onto the following URLs in the JSON API adapter:</source>
          <target state="translated">레코드 맵에서 수행 할 수있는 조치는 JSON API 어댑터의 다음 URL에 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2fc296bf6476dd843ea551f59559ad491097fd7" translate="yes" xml:space="preserve">
          <source>The actions you can take on a record map onto the following URLs in the JSON:API adapter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61f498285f596848fc23f04d9e51276702a760d4" translate="yes" xml:space="preserve">
          <source>The adapter is responsible for answering all of these questions. Whenever your app asks the store for a record that it doesn't have cached, it will ask the adapter for it. If you change a record and save it, the store will hand the record to the adapter to send the appropriate data to your server and confirm that the save was successful.</source>
          <target state="translated">어댑터는이 모든 질문에 대답 할 책임이 있습니다. 앱이 스토어에 캐시하지 않은 레코드를 요청할 때마다 어댑터가 요청합니다. 레코드를 변경하고 저장하면 저장소는 레코드를 어댑터에 전달하여 적절한 데이터를 서버로 보내고 저장이 완료되었음을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="ad248e90ac6d8ba6c4d90263b68bd3e56fc49c63" translate="yes" xml:space="preserve">
          <source>The adapter passes in &lt;code&gt;includeId: true&lt;/code&gt; when serializing a record for &lt;code&gt;createRecord&lt;/code&gt;, but not for &lt;code&gt;updateRecord&lt;/code&gt;.</source>
          <target state="translated">어댑터는 &lt;code&gt;createRecord&lt;/code&gt; 의 레코드를 직렬화 할 때 &lt;code&gt;includeId: true&lt;/code&gt; 전달 하지만 &lt;code&gt;updateRecord&lt;/code&gt; 의 레코드는 전달 하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="efdf679155c7a3919c2945e73db79499e695fec9" translate="yes" xml:space="preserve">
          <source>The adapter will need to be registered in the application's container as &lt;code&gt;container-debug-adapter:main&lt;/code&gt;.</source>
          <target state="translated">어댑터는 애플리케이션 컨테이너에 &lt;code&gt;container-debug-adapter:main&lt;/code&gt; 으로 등록해야합니다 .</target>
        </trans-unit>
        <trans-unit id="131e20e9576979fea3838369ca8bebc9bee71a7f" translate="yes" xml:space="preserve">
          <source>The adapter will need to be registered in the application's container as &lt;code&gt;dataAdapter:main&lt;/code&gt;.</source>
          <target state="translated">어댑터는 애플리케이션 컨테이너에 &lt;code&gt;dataAdapter:main&lt;/code&gt; 으로 등록해야합니다 .</target>
        </trans-unit>
        <trans-unit id="de1f8ea65a9d062ad63b311606da2e19fac5c593" translate="yes" xml:space="preserve">
          <source>The advantage of an async helper is that it will not run until the last async helper has completed. All async helpers after it will wait for it complete before running.</source>
          <target state="translated">비동기 도우미의 장점은 마지막 비동기 도우미가 완료 될 때까지 실행되지 않는다는 것입니다. 모든 비동기 헬퍼는 실행하기 전에 완료를 기다립니다.</target>
        </trans-unit>
        <trans-unit id="8bb5c28c5aa5480291901fa41b6595212381d7c5" translate="yes" xml:space="preserve">
          <source>The advantage to writing components this way is that there is no way to make a mistake and forget to update the output correctly in some situations. As long as the template produces the right HTML for its inputs, the output will remain up to date.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="132b17863e2451dad65a1fc69e5aa6a2e2be4784" translate="yes" xml:space="preserve">
          <source>The algorithm works this way:</source>
          <target state="translated">알고리즘은 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="5ff582d708a589904a1b030c787773bd60458940" translate="yes" xml:space="preserve">
          <source>The alternative syntax, with prototype extensions, might look like:</source>
          <target state="translated">프로토 타입 확장이 포함 된 대체 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5c3682b20b3168f59d213bbd7233481e751bc3ef" translate="yes" xml:space="preserve">
          <source>The amount to decrement by. Defaults to 1</source>
          <target state="translated">감소 할 금액입니다. 기본값은 1</target>
        </trans-unit>
        <trans-unit id="5b7201edf1c359c10f638704266bcb43f6ade922" translate="yes" xml:space="preserve">
          <source>The amount to increment by. Defaults to 1</source>
          <target state="translated">증분 할 금액입니다. 기본값은 1</target>
        </trans-unit>
        <trans-unit id="fa0a776984235353b154722f7512403200c08097" translate="yes" xml:space="preserve">
          <source>The any() method executes the callback function once for each element present in the array until it finds the one where callback returns a truthy value (i.e. &lt;code&gt;true&lt;/code&gt;). If such an element is found, any() immediately returns true. Otherwise, any() returns false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed509f29503bfd3d0043d389191e47926618eace" translate="yes" xml:space="preserve">
          <source>The application instance is passed to Ember's instance initializer hooks and it is added as the &quot;owner&quot; of each object that was instantiated by the application instance.</source>
          <target state="translated">응용 프로그램 인스턴스는 Ember의 인스턴스 이니셜 라이저 후크로 전달되며 응용 프로그램 인스턴스에서 인스턴스화 된 각 객체의 &quot;소유자&quot;로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="355a1c859de0828ab927049176efde71ae67825a" translate="yes" xml:space="preserve">
          <source>The application route</source>
          <target state="translated">신청 경로</target>
        </trans-unit>
        <trans-unit id="901ed3ac0d84e9e2dd2f95578ab1d0ccdf2c001f" translate="yes" xml:space="preserve">
          <source>The argument name is always dasherized (e.g. &lt;code&gt;@focus-out&lt;/code&gt;, &lt;code&gt;@input&lt;/code&gt;, &lt;code&gt;@key-down&lt;/code&gt;). To minimize confusion, we recommend that you use the &lt;code&gt;{{on}}&lt;/code&gt; modifier. (&lt;a href=&quot;https://guides.emberjs.com/upgrading/current-edition/action-on-and-fn/#toc_the-on-modifier&quot;&gt;Learn more about the &lt;code&gt;{{on}}&lt;/code&gt; modifier.&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc69913b03727770065706d5ae763881554440df" translate="yes" xml:space="preserve">
          <source>The arguments to pass to the method</source>
          <target state="translated">메소드에 전달할 인수</target>
        </trans-unit>
        <trans-unit id="e850ec910ddafcfd153f778405adf847a5eaecec" translate="yes" xml:space="preserve">
          <source>The array represents the diff of the canonical state with the local state of the model. Note: if the model is created locally, the canonical state is empty since the adapter hasn't acknowledged the attributes yet:</source>
          <target state="translated">이 배열은 표준 상태와 모델의 로컬 상태의 차이를 나타냅니다. 참고 : 모델이 로컬로 작성된 경우 어댑터가 속성을 아직 인식하지 않았으므로 표준 상태는 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="328ea951bcca35c60833b889806dffdcae966e78" translate="yes" xml:space="preserve">
          <source>The array that the proxy pretends to be. In the default &lt;code&gt;ArrayProxy&lt;/code&gt; implementation, this and &lt;code&gt;content&lt;/code&gt; are the same. Subclasses of &lt;code&gt;ArrayProxy&lt;/code&gt; can override this property to provide things like sorting and filtering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99c78324552871aebe8cd51c6ee3188a58db2b9c" translate="yes" xml:space="preserve">
          <source>The asynchronous test helpers from &lt;code&gt;@ember/test-helpers&lt;/code&gt; are meant to be used together with the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await&quot;&gt;ES2017 feature async/await&lt;/a&gt; to write easy-to-read tests which deal with asynchronous behavior as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7876ec17eeb81f6ca541bc1ef63a2af2ef9b1f5a" translate="yes" xml:space="preserve">
          <source>The attrs options object can use more specific instruction for extracting and serializing. When serializing, an option to embed &lt;code&gt;ids&lt;/code&gt;, &lt;code&gt;ids-and-types&lt;/code&gt; or &lt;code&gt;records&lt;/code&gt; can be set. When extracting the only option is &lt;code&gt;records&lt;/code&gt;.</source>
          <target state="translated">attrs 옵션 오브젝트는 추출 및 직렬화에 대해보다 구체적인 지시 사항을 사용할 수 있습니다. 직렬화 할 때 &lt;code&gt;ids&lt;/code&gt; , &lt;code&gt;ids-and-types&lt;/code&gt; 또는 &lt;code&gt;records&lt;/code&gt; 를 포함하는 옵션을 설정할 수 있습니다. 유일한 옵션을 추출 할 때는 &lt;code&gt;records&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="227d9fca09139aac513d98ddeada59e1a4905b3f" translate="yes" xml:space="preserve">
          <source>The avatar and username components are directly related to the sent and received message components. Right now, they're grouped at the top level. As you get more components, this could make a big mess! Instead, we want to group the related components together in the filesystem. We can do this by moving them into subfolders within &lt;code&gt;app/components&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f166495fefd5148a4270e72b38f3bf4df45b3f1" translate="yes" xml:space="preserve">
          <source>The avatar component also needs to specify where to put attributes that were specified on the tag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ba4bf965a4a66ae929256c9894a0896fb8e5c53" translate="yes" xml:space="preserve">
          <source>The benefits of having unit tests are threefold.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fc2c631617077867650b6978f7b8d361d4055ce" translate="yes" xml:space="preserve">
          <source>The best way to discover new features is to read the &lt;a href=&quot;https://blog.emberjs.com/tags/releases.html&quot;&gt;release blog posts&lt;/a&gt;. If a new feature requires you to opt-in, it's called an optional feature. Follow &lt;a href=&quot;../configuring-ember/optional-features&quot;&gt;the optional features guide&lt;/a&gt; to learn which optional features are available in your app's version of Ember, and how to enable them. In many cases, codemods will be available to help you make syntax-related updates. A codemod is a tool that rewrites your existing code into a new syntax. When they are available, they can save a lot of time that you would spend making edits by hand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40a1417c17584385ecc5f2f82be71fb21fdb09e1" translate="yes" xml:space="preserve">
          <source>The best way to discover new features is to read the &lt;a href=&quot;https://blog.emberjs.com/tags/releases.html&quot;&gt;release blog posts&lt;/a&gt;. If a new feature requires you to opt-in, it's called an optional feature. Follow &lt;a href=&quot;https://guides.emberjs.com/configuring-ember/optional-features/&quot;&gt;the optional features guide&lt;/a&gt; to learn which optional features are available in your app's version of Ember, and how to enable them. In many cases, codemods will be available to help you make syntax-related updates. A codemod is a tool that rewrites your existing code into a new syntax. When they are available, they can save a lot of time that you would spend making edits by hand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="692cb52572458fcee0dcfc7ce5597337ffbedcc6" translate="yes" xml:space="preserve">
          <source>The block expression can then use block params to bind names to any yielded values for use in the block. This allows for template customization when using a component, where the markup is provided by the consuming template, but any event handling behavior implemented in the component is retained such as &lt;code&gt;click()&lt;/code&gt; handlers.</source>
          <target state="translated">그런 다음 블록 표현식은 블록 매개 변수를 사용하여 이름을 블록에 사용하기 위해 생성 된 값에 바인딩 할 수 있습니다. 이렇게하면 소비 템플릿에서 마크 업이 제공되는 구성 요소를 사용할 때 템플릿을 사용자 정의 할 수 있지만 &lt;code&gt;click()&lt;/code&gt; 핸들러 와 같이 구성 요소에 구현 된 모든 이벤트 처리 동작은 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="230b18f150ea432b7fc63ef20d6f97b9cd3ebdce" translate="yes" xml:space="preserve">
          <source>The block form of helpers allows you to control how the UI is created based on the values of properties. A third form of helper is called &quot;nested&quot;. For example here the concat helper will add &quot; Doe&quot; to a displayed name if the person has no last name:</source>
          <target state="translated">도우미의 블록 형식을 사용하면 속성 값을 기반으로 UI를 만드는 방법을 제어 할 수 있습니다. 도우미의 세 번째 형태는 &quot;중첩&quot;이라고합니다. 예를 들어, concat 도우미는성에 이름이없는 경우 표시된 이름에 &quot;Doe&quot;를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="cdafa2c9116008ccf0ab97418b925c097c3252ac" translate="yes" xml:space="preserve">
          <source>The blog post list scrolls to position a new post at the top of the viewport.</source>
          <target state="translated">블로그 게시물 목록이 스크롤되어 뷰포트 상단에 새 게시물이 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="b7d9739a4b01627d57b94f19432fdc1037c8b0d6" translate="yes" xml:space="preserve">
          <source>The cache API was released in Ember 3.22. If you want to leverage this API between versions 3.13 and 3.21, you can install &lt;a href=&quot;https://github.com/ember-polyfills/ember-cache-primitive-polyfill&quot;&gt;ember-cache-primitive-polyfill&lt;/a&gt; to your project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af6e26b49064e993b28a797e047db6b65613464e" translate="yes" xml:space="preserve">
          <source>The cached value of the computed property, if any</source>
          <target state="translated">계산 된 속성의 캐시 된 값 (있는 경우)</target>
        </trans-unit>
        <trans-unit id="70f3ab63a321edca05f8d7fe826eff4a7da47248" translate="yes" xml:space="preserve">
          <source>The call made to the server, using a Rails backend, will look something like this:</source>
          <target state="translated">Rails 백엔드를 사용하여 서버에 대한 호출은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="939bb0a279b018152f9c264171bbf1c866b675ab" translate="yes" xml:space="preserve">
          <source>The call to the function &lt;code&gt;this.inject.service&lt;/code&gt;&lt;a href=&quot;https://guides.emberjs.com/applications/dependency-injection/#toc_ad-hoc-injections&quot;&gt;injects&lt;/a&gt; the service we just registered into the context of the tests, so each test may access it through &lt;code&gt;this.get('mapsService')&lt;/code&gt;. In the example we assert that &lt;code&gt;calledWithLocation&lt;/code&gt; in our stub is set to the location we passed to the component.</source>
          <target state="translated">함수를 호출 &lt;code&gt;this.inject.service&lt;/code&gt; 의&lt;a href=&quot;https://guides.emberjs.com/applications/dependency-injection/#toc_ad-hoc-injections&quot;&gt;주입 또는&lt;/a&gt; 각각의 테스트를 통해 액세스 할 수 있도록 다만, 시험의 컨텍스트에 등록 된 서비스 &lt;code&gt;this.get('mapsService')&lt;/code&gt; . 이 예에서는 스텁의 &lt;code&gt;calledWithLocation&lt;/code&gt; 이 컴포넌트에 전달한 위치로 설정되어 있다고 가정 합니다.</target>
        </trans-unit>
        <trans-unit id="6165fe98748987844899c6930403c4c1ab5d19eb" translate="yes" xml:space="preserve">
          <source>The call to the server, using a Rails backend, will look something like this:</source>
          <target state="translated">Rails 백엔드를 사용한 서버 호출은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="de462a9910b6a2b87d874126e661ea2d619d056e" translate="yes" xml:space="preserve">
          <source>The callback function passed to &lt;code&gt;{{on}}&lt;/code&gt; will receive any arguments that are passed to the event handler. Most commonly this would be the &lt;code&gt;event&lt;/code&gt; itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e38940c1dd9193a8ac3b956829bfe16ac3160dd" translate="yes" xml:space="preserve">
          <source>The callback method should have the following signature:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d0699b4fba58c3f4df0d8bbb8c406317b7efb2c" translate="yes" xml:space="preserve">
          <source>The callback method you provide should have the following signature (all parameters are optional):</source>
          <target state="translated">제공하는 콜백 메소드에는 다음 서명이 있어야합니다 (모든 매개 변수는 선택 사항 임).</target>
        </trans-unit>
        <trans-unit id="7db19daead06e2c546317e025647247b05e290f5" translate="yes" xml:space="preserve">
          <source>The callback method you provide should have the following signature. &lt;code&gt;item&lt;/code&gt; is the current item in the iteration. &lt;code&gt;index&lt;/code&gt; is the integer index of the current item in the iteration.</source>
          <target state="translated">제공하는 콜백 메소드에는 다음 서명이 있어야합니다. &lt;code&gt;item&lt;/code&gt; 은 반복에서 현재 항목입니다. &lt;code&gt;index&lt;/code&gt; 는 반복에서 현재 항목의 정수 색인입니다.</target>
        </trans-unit>
        <trans-unit id="e6388916ece31666bfa3bce621dc9190d0851704" translate="yes" xml:space="preserve">
          <source>The callback method you provide should have the following signature. &lt;code&gt;item&lt;/code&gt; is the current item in the iteration. &lt;code&gt;index&lt;/code&gt; is the integer index of the current item in the iteration. &lt;code&gt;array&lt;/code&gt; is the dependant array itself.</source>
          <target state="translated">제공하는 콜백 메소드에는 다음 서명이 있어야합니다. &lt;code&gt;item&lt;/code&gt; 은 반복에서 현재 항목입니다. &lt;code&gt;index&lt;/code&gt; 는 반복에서 현재 항목의 정수 색인입니다. &lt;code&gt;array&lt;/code&gt; 는 종속 배열 자체입니다.</target>
        </trans-unit>
        <trans-unit id="747b58783f30aeed09a97bff68b7a7ed7e662bd5" translate="yes" xml:space="preserve">
          <source>The callback method you provide should have the following signature:</source>
          <target state="translated">제공하는 콜백 메소드에는 다음 서명이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="3d86eb979382fa479d1f0e875f699adf9c61634f" translate="yes" xml:space="preserve">
          <source>The callback to execute</source>
          <target state="translated">실행할 콜백</target>
        </trans-unit>
        <trans-unit id="1c0bf787c4ef76014ebc5214fa4f8f083cd20164" translate="yes" xml:space="preserve">
          <source>The callback to invoke. It is invoked once per expansion, and is passed the expansion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="378f4ac8c5402e27d2f5c1371ff15299fb646fad" translate="yes" xml:space="preserve">
          <source>The callback will receive the current application as an argument.</source>
          <target state="translated">콜백은 현재 응용 프로그램을 인수로받습니다.</target>
        </trans-unit>
        <trans-unit id="c9031269dfc89716348ced7afe2453c21bf575e8" translate="yes" xml:space="preserve">
          <source>The capabilities object instance</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74a44bb8a72660d6a666643c8eecacba545836e5" translate="yes" xml:space="preserve">
          <source>The capabilities property &lt;em&gt;must&lt;/em&gt; be provided using the &lt;code&gt;capabilities()&lt;/code&gt; function imported from the same module as &lt;code&gt;setHelperManager&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf865f46a8d91a51d334b7806ab5f7f89bbecff5" translate="yes" xml:space="preserve">
          <source>The capabilities values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="107b78d2e608ef92e8a7f001aab1e580890d2636" translate="yes" xml:space="preserve">
          <source>The capitalized string.</source>
          <target state="translated">대문자 문자열</target>
        </trans-unit>
        <trans-unit id="93ca0a4ffd1dc6274323ac9107d82b2dcea9625c" translate="yes" xml:space="preserve">
          <source>The cause of this bug is that we wrote our action to take an argument &amp;ndash; the person's name &amp;ndash; and we forgot to pass it. The fix is easy enough:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15d00f65c9638d1ca2f6257ef2bcfd23eac05be4" translate="yes" xml:space="preserve">
          <source>The central template in an Ember application is the &lt;code&gt;app/templates/application.hbs&lt;/code&gt; file. We can copy HTML into this file, and it will work without any changes. For instance, you can copy the following example HTML for a simple messaging app:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbbb92bec845d62ef32b3b4db4795ff8fb8678df" translate="yes" xml:space="preserve">
          <source>The child &lt;code&gt;Component&lt;/code&gt; can then modify the parent's value just by modifying its own property:</source>
          <target state="translated">그런 다음 자식 &lt;code&gt;Component&lt;/code&gt; 는 자체 속성을 수정하여 부모 값을 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="257db548c086357f7aead64fe919a39c98588cac" translate="yes" xml:space="preserve">
          <source>The child &lt;code&gt;Component&lt;/code&gt; would invoke the action with the new click value:</source>
          <target state="translated">하위 &lt;code&gt;Component&lt;/code&gt; 는 새로운 클릭 값으로 조치를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="0b1f4eed5e1ce8cc4ca660b923639074a39687bc" translate="yes" xml:space="preserve">
          <source>The child &lt;code&gt;Component&lt;/code&gt; would invoke the function with the new click value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01b4ccc47f51a076e5b8b5bc1b2f43c46487fa20" translate="yes" xml:space="preserve">
          <source>The class of a model might be useful if you want to get a list of all the relationship names of the model, see &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Model.html#property_relationshipNames&quot;&gt;&lt;code&gt;relationshipNames&lt;/code&gt;&lt;/a&gt; for example.</source>
          <target state="translated">모델의 모든 관계 이름 목록을 가져 오려면 모델 클래스가 유용 할 수 있습니다 ( 예 : &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Model.html#property_relationshipNames&quot;&gt; &lt;code&gt;relationshipNames&lt;/code&gt; &lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="3d9297b426d0c41a47e556048f763799486035d4" translate="yes" xml:space="preserve">
          <source>The class of a model might be useful if you want to get a list of all the relationship names of the model, see &lt;a href=&quot;https://api.emberjs.com/ember-data/release/classes/Model#relationshipNames&quot;&gt;&lt;code&gt;relationshipNames&lt;/code&gt;&lt;/a&gt; for example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48f539537c66e244c744c84eda7209879551eaf4" translate="yes" xml:space="preserve">
          <source>The code below is the deprecation-workflow file with the first deprecation set to throw an exception on occurrence. The image demonstrates what that deprecation looks like when you run your tests.</source>
          <target state="translated">아래 코드는 첫 번째 사용 중단이 발생하여 예외가 발생하도록 설정된 사용 중단 워크 플로 파일입니다. 이미지는 테스트를 실행할 때 사용 중단이 어떻게 보이는지 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="1b947f40f550601638c2b2a68083672c065ab4d6" translate="yes" xml:space="preserve">
          <source>The code below shows how unit tests check individual methods. Imagine that our app has a utility that helps us work with numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f8a70fc13fa93c2df0e88a63de3f7485bf862bd" translate="yes" xml:space="preserve">
          <source>The code for calling the audio element's &lt;code&gt;play&lt;/code&gt; and &lt;code&gt;pause&lt;/code&gt; can be reused. It isn't tied to this particular audio component. It can be tested independently, too!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93cd13234a3187a294d47fbdde9fd0427c708c5b" translate="yes" xml:space="preserve">
          <source>The collection of functions, keyed by name, available on this &lt;code&gt;ActionHandler&lt;/code&gt; as action targets.</source>
          <target state="translated">이 &lt;code&gt;ActionHandler&lt;/code&gt; 에서 이름으로 키가 지정된 함수 콜렉션을 조치 대상으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9d2bfcf3313d4bc0a7bda43e5de7a8ef0369007f" translate="yes" xml:space="preserve">
          <source>The command will generate the following output, showing that it created a single file called &lt;code&gt;tests/acceptance/list-rentals-test.js&lt;/code&gt;.</source>
          <target state="translated">이 명령은 다음 출력을 생성하여 &lt;code&gt;tests/acceptance/list-rentals-test.js&lt;/code&gt; 라는 단일 파일을 생성했음을 보여 줍니다 .</target>
        </trans-unit>
        <trans-unit id="0f0141d4d954c6b40b635ca87daf9c4fc9548802" translate="yes" xml:space="preserve">
          <source>The complete list of which versions specific deprecations will be removed in can be found &lt;a href=&quot;https://github.com/emberjs/data/tree/master/packages/private-build-infra/addon/current-deprecations.ts&quot;&gt;here&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a6bdd19a4196300d3fed3ccaf29bc7c89c1afa5" translate="yes" xml:space="preserve">
          <source>The component below takes a list of items and displays them on the screen. Additionally, it takes an object representing which item is selected and will select and set the scroll top to that item.</source>
          <target state="translated">아래 구성 요소는 항목 목록을 가져 와서 화면에 표시합니다. 또한 선택된 항목을 나타내는 객체를 가져 와서 해당 항목에 대한 스크롤 상단을 선택하여 설정합니다.</target>
        </trans-unit>
        <trans-unit id="56b41d4893b68c648ad4f70fff5b9d4ee7e84cd2" translate="yes" xml:space="preserve">
          <source>The component name is in &lt;code&gt;CapitalCase&lt;/code&gt; instead of &lt;code&gt;kebab-case&lt;/code&gt;. &lt;code&gt;{{my-component}}&lt;/code&gt; becomes &lt;code&gt;&amp;lt;MyComponent /&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00924038d9acbd0206114498f918d95680c59534" translate="yes" xml:space="preserve">
          <source>The component should show details about the rental</source>
          <target state="translated">구성 요소에 대여에 대한 세부 사항이 표시되어야합니다.</target>
        </trans-unit>
        <trans-unit id="03d4f32bac2eee953b37844aa3ddbdccc1b00e16" translate="yes" xml:space="preserve">
          <source>The component should toggle the existence of a wide class on click, to expand and shrink the photo of the rental.</source>
          <target state="translated">구성 요소는 대여시 사진을 확대하거나 축소하기 위해 클릭시 와이드 클래스의 존재를 토글해야합니다.</target>
        </trans-unit>
        <trans-unit id="bb8277dc02802176f96c31e5577dcf1f7ddceafa" translate="yes" xml:space="preserve">
          <source>The component template will have a button and a div that shows the confirmation dialog based on the value of &lt;code&gt;confirmShown&lt;/code&gt;.</source>
          <target state="translated">구성 요소 템플릿에는 &lt;code&gt;confirmShown&lt;/code&gt; 값을 기반으로 확인 대화 상자를 표시하는 단추와 div가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3e02882f24ccee1b6087710e6540fa437584878" translate="yes" xml:space="preserve">
          <source>The component's element has been both created and inserted into the DOM.</source>
          <target state="translated">컴포넌트의 요소가 생성되어 DOM에 삽입되었습니다.</target>
        </trans-unit>
        <trans-unit id="4cc0a17e4b5e6b7c7ced86a1cc438b4160335bc6" translate="yes" xml:space="preserve">
          <source>The component's element is accessible via the component's &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Component.html#method__&quot;&gt;&lt;code&gt;$()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">컴포넌트의 요소는 컴포넌트의 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Component.html#method__&quot;&gt; &lt;code&gt;$()&lt;/code&gt; &lt;/a&gt; 메소드 를 통해 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="19e3b433aa23f12bd05532ff968ce2bca61fcddc" translate="yes" xml:space="preserve">
          <source>The components look similar, don't they? The first component shows extra information about the user's local time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f87081eb897d1fd3835c5c46606eabc3f8f40d2c" translate="yes" xml:space="preserve">
          <source>The computed macros expect you to use an array, so there is no need to use the &lt;code&gt;[]&lt;/code&gt; key in these cases. However, building your own custom computed property requires you to tell Ember.js that it is watching for array changes, which is where the &lt;code&gt;[]&lt;/code&gt; key comes in handy.</source>
          <target state="translated">계산 된 매크로는 배열을 사용해야하므로 이러한 경우에는 &lt;code&gt;[]&lt;/code&gt; 키 를 사용할 필요가 없습니다 . 그러나 사용자 정의 계산 속성을 만들려면 Ember.js에게 &lt;code&gt;[]&lt;/code&gt; 키가 유용한 배열 변경을 감시하고 있다고 알려 주어야 합니다.</target>
        </trans-unit>
        <trans-unit id="ae175a7f89b4f83b59ccbd1676223dd012eb30c9" translate="yes" xml:space="preserve">
          <source>The computed property function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c04629937de1c7126ae68322907abae8ecd667fc" translate="yes" xml:space="preserve">
          <source>The container calls this object's &lt;code&gt;resolve&lt;/code&gt; method with the &lt;code&gt;fullName&lt;/code&gt; argument.</source>
          <target state="translated">컨테이너 는 &lt;code&gt;fullName&lt;/code&gt; 인수를 사용 하여이 객체의 &lt;code&gt;resolve&lt;/code&gt; 메소드를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="dedba2d51f22aac0e2c4ffa20bbb5629c1192057" translate="yes" xml:space="preserve">
          <source>The container-debug-adapter which is used to list all models.</source>
          <target state="translated">모든 모델을 나열하는 데 사용되는 컨테이너 디버그 어댑터입니다.</target>
        </trans-unit>
        <trans-unit id="01d36d5d6b5e9909fad007034d4409bd063620d8" translate="yes" xml:space="preserve">
          <source>The content array. Must be an object that implements &lt;code&gt;Array&lt;/code&gt; and/or &lt;code&gt;MutableArray.&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71bc08d35f4aa7dfc82186fc932b83df95fed7ce" translate="yes" xml:space="preserve">
          <source>The controller associated with this route.</source>
          <target state="translated">이 경로와 관련된 컨트롤러입니다.</target>
        </trans-unit>
        <trans-unit id="8b3eab1e8d1492edcda2af7cd55a05ab06f81f5f" translate="yes" xml:space="preserve">
          <source>The controller instance must already have been created, either through entering the associated route or using &lt;code&gt;generateController&lt;/code&gt;.</source>
          <target state="translated">연관된 경로를 입력하거나 &lt;code&gt;generateController&lt;/code&gt; 를 사용하여 컨트롤러 인스턴스가 이미 작성되어 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="ddb8d9fa2f2e1f80a239b246d3f4353a508a5c76" translate="yes" xml:space="preserve">
          <source>The controller name &lt;code&gt;my-controller-name&lt;/code&gt; must match the name of the Route that renders it. So if the Route is named &lt;code&gt;blog-post&lt;/code&gt;, it should have a matching Controller named &lt;code&gt;blog-post&lt;/code&gt;. The matching file names of the Controller and the Route signals to Ember that this Controller must be used when landing on the &lt;code&gt;blog-post&lt;/code&gt; Route.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d996ccba50d2a03192ad84043d699c49c674c9d6" translate="yes" xml:space="preserve">
          <source>The controller receives a single property from the Route &amp;ndash; &lt;code&gt;model&lt;/code&gt; &amp;ndash; which is the return value of the Route's &lt;code&gt;model()&lt;/code&gt; method.</source>
          <target state="translated">컨트롤러는 Route &amp;ndash; &lt;code&gt;model&lt;/code&gt; &amp;ndash; Route의 &lt;code&gt;model()&lt;/code&gt; 메소드 의 반환 값인 단일 속성을받습니다 .</target>
        </trans-unit>
        <trans-unit id="9805ee9f09f7a6c9f18fe8f84f7390a97217c750" translate="yes" xml:space="preserve">
          <source>The controller's current model. When retrieving or modifying a controller's model, this property should be used instead of the &lt;code&gt;content&lt;/code&gt; property.</source>
          <target state="translated">컨트롤러의 현재 모델. 컨트롤러 모델을 검색하거나 수정할 때 &lt;code&gt;content&lt;/code&gt; 속성 대신이 속성을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="301f36390a7be64dbf55d036bcf24116fa60dea1" translate="yes" xml:space="preserve">
          <source>The copied object</source>
          <target state="translated">복사 된 객체</target>
        </trans-unit>
        <trans-unit id="dc497b43d9a73eae6ffff08e5aaad7d8aea85919" translate="yes" xml:space="preserve">
          <source>The current set of flags are defined below. If you want to add a new flag, in addition to the area below, you will also need to declare it in the &lt;code&gt;DS.Model&lt;/code&gt; class.</source>
          <target state="translated">현재 플래그 세트가 아래에 정의되어 있습니다. 아래 영역 외에 새 플래그를 추가하려면 &lt;code&gt;DS.Model&lt;/code&gt; 클래스 에서도 선언해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0524bb6abfd181d72da352389fd69941fb6778cc" translate="yes" xml:space="preserve">
          <source>The currently active URL.</source>
          <target state="translated">현재 활성화 된 URL입니다.</target>
        </trans-unit>
        <trans-unit id="64c535e9f2e1008eed7eb1be8de9fd6230cf64a1" translate="yes" xml:space="preserve">
          <source>The currently active path.</source>
          <target state="translated">현재 활성 경로입니다.</target>
        </trans-unit>
        <trans-unit id="7ae269b3fbb6278f1b83a6fe01cfa16233ee99a2" translate="yes" xml:space="preserve">
          <source>The decorator &lt;em&gt;is&lt;/em&gt; important, as it binds the action directly to the class so it can reference it later on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e660db36e9b08057f50c55c5c7416d69ef68df7e" translate="yes" xml:space="preserve">
          <source>The decorator leaves the method intact without any changes, so you can continue to use it like a normal method. This also means that you can reference the action directly in templates, instead of using strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4b1d59e80066fe1a38250044448beb82d44ec54" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;serialize&lt;/code&gt; method will insert the model's &lt;code&gt;id&lt;/code&gt; into the route's dynamic segment (in this case, &lt;code&gt;:post_id&lt;/code&gt;) if the segment contains '_id'. If the route has multiple dynamic segments or does not contain '_id', &lt;code&gt;serialize&lt;/code&gt; will return &lt;code&gt;Ember.getProperties(model, params)&lt;/code&gt;</source>
          <target state="translated">세그먼트에 '_id'가 포함 된 경우 기본 &lt;code&gt;serialize&lt;/code&gt; 메소드는 모델의 &lt;code&gt;id&lt;/code&gt; 를 경로의 동적 세그먼트 (이 경우 &lt;code&gt;:post_id&lt;/code&gt; )에 삽입합니다. 경로에 동적 세그먼트가 여러 개 있거나 '_id'를 포함하지 않으면 &lt;code&gt;serialize&lt;/code&gt; 는 &lt;code&gt;Ember.getProperties(model, params)&lt;/code&gt; 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a2dbf25f0a660ec806508b272583db389f3613a0" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;serialize&lt;/code&gt; method will insert the model's &lt;code&gt;id&lt;/code&gt; into the route's dynamic segment (in this case, &lt;code&gt;:post_id&lt;/code&gt;) if the segment contains '_id'. If the route has multiple dynamic segments or does not contain '_id', &lt;code&gt;serialize&lt;/code&gt; will return &lt;code&gt;getProperties(model, params)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9804540a4930794a37fbff41c2089e9b1c714b1" translate="yes" xml:space="preserve">
          <source>The default HTML tag name used for a component's DOM representation is &lt;code&gt;div&lt;/code&gt;. This can be customized by setting the &lt;code&gt;tagName&lt;/code&gt; property. The following component class:</source>
          <target state="translated">컴포넌트의 DOM 표현에 사용되는 기본 HTML 태그 이름은 &lt;code&gt;div&lt;/code&gt; 입니다. &lt;code&gt;tagName&lt;/code&gt; 속성 을 설정하여 사용자 지정할 수 있습니다 . 다음 컴포넌트 클래스 :</target>
        </trans-unit>
        <trans-unit id="b36c85b8bca569261536774fd6ba634fc5ceed47" translate="yes" xml:space="preserve">
          <source>The default HTML tag name used for a component's HTML representation is &lt;code&gt;div&lt;/code&gt;. This can be customized by setting the &lt;code&gt;tagName&lt;/code&gt; property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba661251bae2c58457a6583501ea31468be49e4e" translate="yes" xml:space="preserve">
          <source>The default adapter to use to communicate to a backend server or other persistence layer. This will be overridden by an application adapter if present.</source>
          <target state="translated">백엔드 서버 또는 기타 지속성 계층과 통신하는 데 사용되는 기본 어댑터입니다. 존재하는 경우 응용 프로그램 어댑터가이를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="d48ca495b259e7b4f0c08e2c8e0b6fc93859dce8" translate="yes" xml:space="preserve">
          <source>The default behavior for &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_link-to&quot;&gt;&lt;code&gt;link-to&lt;/code&gt;&lt;/a&gt; is to add entries to the browser's history when transitioning between the routes. However, to replace the current entry in the browser's history you can use the &lt;code&gt;replace=true&lt;/code&gt; option:</source>
          <target state="translated">&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_link-to&quot;&gt; &lt;code&gt;link-to&lt;/code&gt; &lt;/a&gt; 의 기본 동작 은 경로 간 전환시 브라우저 기록에 항목을 추가하는 것입니다. 그러나 브라우저 기록에서 현재 항목을 바꾸려면 &lt;code&gt;replace=true&lt;/code&gt; 옵션을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b3922692f347baa13e2c06395bc6ba435b1e4cd9" translate="yes" xml:space="preserve">
          <source>The default behavior for the &lt;code&gt;&amp;lt;LinkTo /&amp;gt;&lt;/code&gt; component is to add entries to the browser's history when transitioning between routes. However, to replace the current entry in the browser's history instead, you can use the &lt;code&gt;@replace&lt;/code&gt; option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bca2a901121a7451f6489ec6d86fbe872ab37681" translate="yes" xml:space="preserve">
          <source>The default behavior if this method is not implemented and the option is not specified is to not reload, the same as a return of &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="562769c02d4c07aefbed025e3fd4ce1715ca1c58" translate="yes" xml:space="preserve">
          <source>The default behavior if this method is not implemented and the option is not specified is to perform a reload, the same as a return of &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="790f926751ceaeb677f46339fcfc28ea52ee3052" translate="yes" xml:space="preserve">
          <source>The default behavior if this method is not implemented and the option was not specified is to background reload, the same as a return of &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="028b9616eef359dc09d07d3be87a5ac87b8aea59" translate="yes" xml:space="preserve">
          <source>The default behavior is for lookup to return a singleton instance. The singleton is scoped to the container, allowing multiple containers to all have their own locally scoped singletons.</source>
          <target state="translated">기본 동작은 조회가 단일 인스턴스를 반환하는 것입니다. 싱글 톤은 컨테이너로 범위가 지정되므로 여러 컨테이너가 모두 로컬로 범위가 지정된 싱글 톤을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f6ae78488106d28afaef3992514442eda491907" translate="yes" xml:space="preserve">
          <source>The default behavior of &lt;code&gt;{{#each}}&lt;/code&gt; is to yield its inner block once for every item in an array passing the item as the first block parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33cd28df250e1a3d71b927a14510954a829fa40c" translate="yes" xml:space="preserve">
          <source>The default implementation returns the records as a single group.</source>
          <target state="translated">기본 구현은 레코드를 단일 그룹으로 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="6d55dd2f84ce398a6b7ca904972aeeb8f8ea5d4c" translate="yes" xml:space="preserve">
          <source>The default serialization would create a JSON object like:</source>
          <target state="translated">기본 직렬화는 다음과 같은 JSON 객체를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="037f412e390fb1167574e0aba238d8caebe3ba1b" translate="yes" xml:space="preserve">
          <source>The definition passed into setHelperManager</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9deb1673b1b3a8d76398226ea7d92d1e9f24c75" translate="yes" xml:space="preserve">
          <source>The definition to associate the manager factory with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9726fa72bad036507b0c7e1f772d49c8a42328a7" translate="yes" xml:space="preserve">
          <source>The denodified function inherits from the original function. It works in all environments, except IE 10 and below. Consequently all properties of the original function are available to you. However, any properties you change on the denodeified function won't be changed on the original function. Example:</source>
          <target state="translated">denodified 함수는 원래 함수에서 상속됩니다. IE 10 이하를 제외한 모든 환경에서 작동합니다. 결과적으로 원래 기능의 모든 속성을 사용할 수 있습니다. 그러나 denodeified 기능에서 변경 한 특성은 원래 기능에서 변경되지 않습니다. 예:</target>
        </trans-unit>
        <trans-unit id="a81bacb27ef7a7c4a59cca0a9ad3aa5799647431" translate="yes" xml:space="preserve">
          <source>The deprecation handler API was released in Ember 2.1. If you would like to leverage this API in a prior release of Ember you can install the &lt;a href=&quot;http://emberobserver.com/addons/ember-debug-handlers-polyfill&quot;&gt;ember-debug-handlers-polyfill&lt;/a&gt; addon into your project.</source>
          <target state="translated">지원 중단 처리기 API가 Ember 2.1에서 릴리스되었습니다. Ember의 이전 릴리스에서이 API를 활용하려면 &lt;a href=&quot;http://emberobserver.com/addons/ember-debug-handlers-polyfill&quot;&gt;ember-debug-handlers-polyfill&lt;/a&gt; 애드온을 프로젝트에 설치할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d14be1f3c6637fd072ea31a6dbb848736f0f9b4c" translate="yes" xml:space="preserve">
          <source>The deserialized value</source>
          <target state="translated">역 직렬화 된 값</target>
        </trans-unit>
        <trans-unit id="12ad61a0cf3b9d504e9237bd85b7563a6d615b88" translate="yes" xml:space="preserve">
          <source>The destructor function is passed a single argument, which is the destroyable itself. This allows the function to be reused multiple times for many destroyables, rather than creating a closure function per destroyable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="114abbe6ec3ae2a55474ea166d4a44af1882720d" translate="yes" xml:space="preserve">
          <source>The developer would need to write the following additional code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d321ab17a248d722f4b0af0b7c1fb90212dc2e34" translate="yes" xml:space="preserve">
          <source>The difference between keyboard and screen reader navigation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ad5ff32eedb89ab1a75c8b607eeab8daf0934f3" translate="yes" xml:space="preserve">
          <source>The difference is that instances of classes &lt;em&gt;inherit&lt;/em&gt; elements that are defined in the class definition. For instance, we can define a &lt;em&gt;method&lt;/em&gt; on the person class, and then call it from the instance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64135b4c9cbf7e6c2746c87a70265ddfacced586" translate="yes" xml:space="preserve">
          <source>The dot-separated, fully-qualified name of the route, like &quot;people.index&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61863b6efe342207f2c2beda0291c57e7b350c15" translate="yes" xml:space="preserve">
          <source>The easiest way to create a two-way binding is to use a &lt;a href=&quot;http://emberjs.com/api/classes/Ember.computed.html#method_alias&quot;&gt;&lt;code&gt;computed.alias()&lt;/code&gt;&lt;/a&gt;, that specifies the path to another object.</source>
          <target state="translated">양방향 바인딩을 만드는 가장 쉬운 방법은 다른 객체의 경로를 지정 하는 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.computed.html#method_alias&quot;&gt; &lt;code&gt;computed.alias()&lt;/code&gt; &lt;/a&gt; 를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="51b9dfe652430a47b7813879322835fda06a5e1e" translate="yes" xml:space="preserve">
          <source>The easiest way to create an &lt;code&gt;Ember.Component&lt;/code&gt; is via a template. If you name a template &lt;code&gt;app/components/my-foo.hbs&lt;/code&gt;, you will be able to use &lt;code&gt;{{my-foo}}&lt;/code&gt; in other templates, which will make an instance of the isolated component.</source>
          <target state="translated">&lt;code&gt;Ember.Component&lt;/code&gt; 를 생성하는 가장 쉬운 방법 은 템플릿을 이용하는 것 입니다. &lt;code&gt;app/components/my-foo.hbs&lt;/code&gt; 템플리트 이름을 지정하면 다른 템플리트에서 &lt;code&gt;{{my-foo}}&lt;/code&gt; 를 사용 하여 격리 된 컴포넌트의 인스턴스를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a90adc5ebc180395b92d51213f2e4db5db7c4d5" translate="yes" xml:space="preserve">
          <source>The ember-cli-deprecation-workflow addon provides a command that will collect deprecations from your console and generate JavaScript code listing its findings.</source>
          <target state="translated">ember-cli-deprecation-workflow 애드온은 콘솔에서 사용 중단을 수집하고 결과를 나열하는 JavaScript 코드를 생성하는 명령을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fdd655946489d5fc1eb29277282f0228a2f44088" translate="yes" xml:space="preserve">
          <source>The end result is that there will be one &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; element corresponding to each scientist in the array inside the &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; unordered list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c08d687a1f142539937b2a75e02478a1de2910c4" translate="yes" xml:space="preserve">
          <source>The enumerable API follows ECMAScript specifications as much as possible. This minimizes incompatibility with other libraries, and allows Ember.js to use the native browser implementations in arrays where available.</source>
          <target state="translated">열거 가능한 API는 가능한 ECMAScript 사양을 따릅니다. 이것은 다른 라이브러리와의 비 호환성을 최소화하고 Ember.js가 가능한 경우 기본 브라우저 구현을 배열로 사용할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="53296ae205ad56bb6a6d30fa5131406fb5ceb504" translate="yes" xml:space="preserve">
          <source>The event can be &lt;em&gt;any&lt;/em&gt; event name, not just the &lt;code&gt;click&lt;/code&gt; event, which makes &lt;code&gt;{{on}}&lt;/code&gt; perfect for handling any kind of DOM event. For a list of native browser events, see the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events&quot;&gt;MDN documentation&lt;/a&gt;. The callback function will receive the event as its first argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f251a4ec622923c4684a280b97957e070d1f3fc" translate="yes" xml:space="preserve">
          <source>The event dispatcher is created by the application at initialization time and sets up event listeners on the DOM element described by the application's &lt;code&gt;rootElement&lt;/code&gt; property.</source>
          <target state="translated">이벤트 디스패처는 초기화시 응용 프로그램에 의해 작성되며 응용 프로그램의 &lt;code&gt;rootElement&lt;/code&gt; 특성에 의해 설명 된 DOM 요소에 이벤트 리스너를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="053c279c50f244b9eb896230e5a90c90796a9df5" translate="yes" xml:space="preserve">
          <source>The event handling examples described above respond to one set of events. The names of the built-in events are listed below. Custom events can be registered by using &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Application.html#property_customEvents&quot;&gt;Ember.Application.customEvents&lt;/a&gt;.</source>
          <target state="translated">위에서 설명한 이벤트 처리 예제는 하나의 이벤트 세트에 응답합니다. 내장 이벤트의 이름은 다음과 같습니다. &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Application.html#property_customEvents&quot;&gt;Ember.Application.customEvents&lt;/a&gt; 를 사용하여 커스텀 이벤트를 등록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0d6920661dd01b9f6799a3d90341150d42ee514c" translate="yes" xml:space="preserve">
          <source>The event name (e.g. &lt;code&gt;&quot;focusout&quot;&lt;/code&gt;, &lt;code&gt;&quot;input&quot;&lt;/code&gt;, &lt;code&gt;&quot;keydown&quot;&lt;/code&gt;) always follows the casing that the HTML standard uses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b863b4625ecf29a56bcdfb71eee44abd26ee138c" translate="yes" xml:space="preserve">
          <source>The event type to be triggered.</source>
          <target state="translated">트리거 할 이벤트 유형.</target>
        </trans-unit>
        <trans-unit id="5e377f2c4a3dec86abf2ac3efcc334847d1f52b8" translate="yes" xml:space="preserve">
          <source>The exception to be raised.</source>
          <target state="translated">발생할 예외입니다.</target>
        </trans-unit>
        <trans-unit id="2422f0ff43e6667a702a73460791a92f8d19db60" translate="yes" xml:space="preserve">
          <source>The feature to check</source>
          <target state="translated">확인하는 기능</target>
        </trans-unit>
        <trans-unit id="c9385406411bb8482a8fc544996b6376f89a672f" translate="yes" xml:space="preserve">
          <source>The filter values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95787b699dfdd06e98ccefd8263560e2e6b5a8f1" translate="yes" xml:space="preserve">
          <source>The filterFunction is a function used to test records from the store to determine if they should be part of the record array.</source>
          <target state="translated">filterFunction은 상점에서 레코드를 테스트하여 레코드 배열의 일부 여야하는지 여부를 판별하는 데 사용되는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="656472f642ee79659dcf28806545d76eaf64f3f5" translate="yes" xml:space="preserve">
          <source>The final result after normalization to &lt;code&gt;JSON:API&lt;/code&gt; will be added to store via &lt;code&gt;store.push&lt;/code&gt; where it will merge with any existing data for the record.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c62272857f5accc9a6fb8673f93bc859ef49b47" translate="yes" xml:space="preserve">
          <source>The final result after normalization to &lt;code&gt;JSON:API&lt;/code&gt; will be added to store via &lt;code&gt;store.push&lt;/code&gt; where it will merge with any existing data for the returned record.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afa48fbea9f134d061d47901eef0a77c871d6cc5" translate="yes" xml:space="preserve">
          <source>The final result after normalization to &lt;code&gt;JSON:API&lt;/code&gt; will be added to store via &lt;code&gt;store.push&lt;/code&gt; where it will merge with any existing data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1354cf6d6ebfe63295cf54e7cfb3f6cf36145522" translate="yes" xml:space="preserve">
          <source>The final result after normalization to &lt;code&gt;JSON:API&lt;/code&gt; will be added to store via &lt;code&gt;store.push&lt;/code&gt; where it will merge with any existing records for &lt;code&gt;type&lt;/code&gt;. Existing records for the &lt;code&gt;type&lt;/code&gt; will not be removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea3e9a433232958757b8ce097b65b99bf100d389" translate="yes" xml:space="preserve">
          <source>The final segment of the fully-qualified name of the route, like &quot;index&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62e163152ac939e91938ed4bba47c089f566a9f1" translate="yes" xml:space="preserve">
          <source>The final test should look as follows:</source>
          <target state="translated">최종 테스트는 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="251b44a6daaf2e9098e7b6561f96f4b93ffee050" translate="yes" xml:space="preserve">
          <source>The find method is called on the model class with the value of the dynamic segment.</source>
          <target state="translated">find 메소드는 동적 세그먼트의 값으로 모델 클래스에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="44a9ee1d503ae41f5ebe88c3bedc84b26ec908ac" translate="yes" xml:space="preserve">
          <source>The first argument (&lt;code&gt;@model&lt;/code&gt;) was curried over, and the run-time argument (&lt;code&gt;event&lt;/code&gt;) becomes a second argument. Action calls can be nested this way because each simply returns a function. Any function can be passed to the &lt;code&gt;{{action}}&lt;/code&gt; helper, including other actions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c6ab5f4ba11276c830d14ace1931f03db22503d" translate="yes" xml:space="preserve">
          <source>The first argument (&lt;code&gt;model&lt;/code&gt;) was curried over, and the run-time argument (&lt;code&gt;event&lt;/code&gt;) becomes a second argument. Action calls can be nested this way because each simply returns a function. Any function can be passed to the &lt;code&gt;{{action}}&lt;/code&gt; helper, including other actions.</source>
          <target state="translated">첫 번째 인수 ( &lt;code&gt;model&lt;/code&gt; )가 커리되어 런타임 인수 ( &lt;code&gt;event&lt;/code&gt; )가 두 번째 인수가됩니다. 액션 호출은 각각 단순히 함수를 반환하기 때문에 이런 식으로 중첩 될 수 있습니다. 다른 조치를 포함하여 모든 함수를 &lt;code&gt;{{action}}&lt;/code&gt; 도우미에 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="231551dd76228e5db17232fd8be733900240443b" translate="yes" xml:space="preserve">
          <source>The first argument to capabilities is a version string, which is the version of Ember that the capabilities were defined in. Ember can add new versions at any time, and these may have entirely different behaviors, but it will not remove old versions until the next major version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed7c239cf4e865e182877517567062ddaf11cb4e" translate="yes" xml:space="preserve">
          <source>The first nested route to generate will be the index route. An index nested route works similarly to the base index route. It is the default route that renders when no route is provided. Therefore in our case, when we navigate to &lt;code&gt;/rentals&lt;/code&gt;, Ember will attempt to load the rentals index route as a nested route.</source>
          <target state="translated">생성 할 첫 번째 중첩 경로는 인덱스 경로입니다. 인덱스 중첩 경로는 기본 인덱스 경로와 유사하게 작동합니다. 경로가 제공되지 않을 때 렌더링되는 기본 경로입니다. 따라서이 경우 &lt;code&gt;/rentals&lt;/code&gt; 로 이동하면 Ember는 임대 인덱스 경로를 중첩 된 경로로로드하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="7ef6ca8fdea7601f72ee382521ce6bdd17cdb515" translate="yes" xml:space="preserve">
          <source>The first object in the array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b696429bcf9bb7779fc28bd415eb7c6e73818d44" translate="yes" xml:space="preserve">
          <source>The first object in the array, or &lt;code&gt;undefined&lt;/code&gt; if the array is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f27629eb91cae8f4b9ccb3dcfb7838c50ccd34f1" translate="yes" xml:space="preserve">
          <source>The first option is, you could leave most older components as-is, and gradually convert them to Octane style components whenever the course of your work requires you to edit those files. The advantage is that it is very easy for everyone to tell whether a component is classic or Octane. The disadvantage is that muscle memory for Objects vs Classes is tough to overcome.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="983c3b259f765a841e0ba8fde3f9e8cb7899878d" translate="yes" xml:space="preserve">
          <source>The first parameter is the name of the route which is used by default as the path name as well.</source>
          <target state="translated">첫 번째 매개 변수는 경로 이름으로 기본적으로 사용되는 경로의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="867dad7c3f5ffacd925eef7fa9afe4dfec51964e" translate="yes" xml:space="preserve">
          <source>The first parameter of the helper is the name of a component to render, as a string. So &lt;code&gt;{{component 'blog-post'}}&lt;/code&gt; is the same as using &lt;code&gt;&amp;lt;BlogPost /&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9105fbebbf22cf85d2b2f209a6496fbe8783578b" translate="yes" xml:space="preserve">
          <source>The first parameter of the helper is the name of a component to render, as a string. So &lt;code&gt;{{component 'blog-post'}}&lt;/code&gt; is the same as using &lt;code&gt;{{blog-post}}&lt;/code&gt;.</source>
          <target state="translated">도우미의 첫 번째 매개 변수는 렌더링 할 구성 요소의 이름입니다 (문자열). 따라서 &lt;code&gt;{{component 'blog-post'}}&lt;/code&gt; 은 &lt;code&gt;{{blog-post}}&lt;/code&gt; 를 사용하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="d5209e6f0bdb73ab73f04317f2793d14718036b7" translate="yes" xml:space="preserve">
          <source>The first style of invocation is &lt;strong&gt;inline invocation&lt;/strong&gt;. This looks similar to displaying a property, but helpers accept arguments. For example:</source>
          <target state="translated">첫 번째 호출 스타일은 &lt;strong&gt;인라인 호출&lt;/strong&gt; 입니다. 이것은 속성을 표시하는 것과 비슷하지만 도우미가 인수를 허용합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="75890c317887371b09062eb2031229122ca2996b" translate="yes" xml:space="preserve">
          <source>The first thing we want to do in our new project is to remove the welcome screen. We do this by simply opening up the application template file located at &lt;code&gt;app/templates/application.hbs&lt;/code&gt;.</source>
          <target state="translated">새 프로젝트에서 가장 먼저 할 일은 시작 화면을 제거하는 것입니다. &lt;code&gt;app/templates/application.hbs&lt;/code&gt; 에있는 애플리케이션 템플릿 파일을 열면됩니다 .</target>
        </trans-unit>
        <trans-unit id="df63a4fe845371eed7bc197ad02924db53d537c3" translate="yes" xml:space="preserve">
          <source>The first time the &lt;code&gt;Article&lt;/code&gt; component is rendered, it would produce this output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4857e8065fbf4081ce57d36f5907b225a8fef2b9" translate="yes" xml:space="preserve">
          <source>The first time the object is looked up, the factory function will be called to create the helper manager. It will be cached, and in subsequent lookups the cached helper manager will be used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f64cb4a633c43e464c1ff818f86a7f51cbaf2da" translate="yes" xml:space="preserve">
          <source>The first time your application asks the store for a record, the store sees that it doesn't have a local copy and requests it from your adapter. Your adapter will go and retrieve the record from your persistence layer; typically, this will be a JSON representation of the record served from an HTTP server.</source>
          <target state="translated">애플리케이션이 처음으로 상점에 레코드를 요청할 때 상점은 로컬 사본이없는 것을보고 어댑터에서이를 요청합니다. 어댑터는 지속성 계층에서 레코드를 검색합니다. 일반적으로 이는 HTTP 서버에서 제공되는 레코드의 JSON 표현입니다.</target>
        </trans-unit>
        <trans-unit id="bd9a731b8654e32704a346674674446e3d3a69b4" translate="yes" xml:space="preserve">
          <source>The flag status in the generated build is controlled by the &lt;a href=&quot;https://github.com/emberjs/ember.js/blob/master/features.json&quot;&gt;&lt;code&gt;features.json&lt;/code&gt;&lt;/a&gt; file in the root of the Ember.js project. This file lists all new features and their current status.</source>
          <target state="translated">생성 된 빌드의 플래그 상태 는 Ember.js 프로젝트의 루트 에있는 &lt;a href=&quot;https://github.com/emberjs/ember.js/blob/master/features.json&quot;&gt; &lt;code&gt;features.json&lt;/code&gt; &lt;/a&gt; 파일에 의해 제어됩니다 . 이 파일은 모든 새로운 기능과 현재 상태를 나열합니다.</target>
        </trans-unit>
        <trans-unit id="fe992690ad7d096a2f9afd1aaf7866e7673d02e4" translate="yes" xml:space="preserve">
          <source>The flag status in the generated build is controlled by the &lt;a href=&quot;https://github.com/emberjs/ember.js/blob/master/packages/@ember/canary-features/index.ts&quot;&gt;&lt;code&gt;@ember/canary-features&lt;/code&gt;&lt;/a&gt; package. This package exports a list of all available features and their current status.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb3cef84c92085a6d2d883851701837207c0ed5e" translate="yes" xml:space="preserve">
          <source>The flag to signal a &lt;code&gt;RecordArray&lt;/code&gt; is currently loading data.</source>
          <target state="translated">&lt;code&gt;RecordArray&lt;/code&gt; 에 신호를 보내는 플래그 가 현재 데이터를로드 중입니다.</target>
        </trans-unit>
        <trans-unit id="53188ffd1056282eaa9b367801d327c2d664d389" translate="yes" xml:space="preserve">
          <source>The flag to signal a &lt;code&gt;RecordArray&lt;/code&gt; is finished loading data.</source>
          <target state="translated">&lt;code&gt;RecordArray&lt;/code&gt; 를 알리는 플래그가 데이터로드를 완료했습니다.</target>
        </trans-unit>
        <trans-unit id="39accfabc1616fbff84cfef1e2405eff54644354" translate="yes" xml:space="preserve">
          <source>The following HTML attributes can be set via the helper:</source>
          <target state="translated">도우미를 통해 다음 HTML 속성을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb79dc0afa03345796e1814d66f43dab53b2351b" translate="yes" xml:space="preserve">
          <source>The following HTML attributes can be set:</source>
          <target state="translated">다음과 같은 HTML 속성을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44fc4180b9b05e8989204eb9f584bb53e9d638f4" translate="yes" xml:space="preserve">
          <source>The following HTML would be rendered:</source>
          <target state="translated">다음 HTML이 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="1f0a3c7a9779e06c8201841fbe9265d91073f48e" translate="yes" xml:space="preserve">
          <source>The following chart is a visual representation of what takes place when the escape key is pressed in this scenario:</source>
          <target state="translated">다음 차트는이 시나리오에서 Esc 키를 눌렀을 때 발생하는 상황을 시각적으로 나타낸 것입니다.</target>
        </trans-unit>
        <trans-unit id="37c67db7954be266e8e6d6ff4e4e5081f2a3c808" translate="yes" xml:space="preserve">
          <source>The following code injects the &lt;code&gt;shopping-cart&lt;/code&gt; service on the &lt;code&gt;cart-contents&lt;/code&gt; component as the property &lt;code&gt;cart&lt;/code&gt;:</source>
          <target state="translated">다음 코드 는 &lt;code&gt;cart-contents&lt;/code&gt; 컴포넌트 에 &lt;code&gt;shopping-cart&lt;/code&gt; 서비스를 특성 &lt;code&gt;cart&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="729b7f0e23b374cb4e57a6cdd204d250859aaf3b" translate="yes" xml:space="preserve">
          <source>The following controller code:</source>
          <target state="translated">다음 컨트롤러 코드 :</target>
        </trans-unit>
        <trans-unit id="5f70fdd699bda0ef491d01141402f07249723c95" translate="yes" xml:space="preserve">
          <source>The following demonstrates how you can override both the scope and the query param URL key of a single controller query param property:</source>
          <target state="translated">다음은 단일 컨트롤러 쿼리 매개 변수 속성의 범위 및 쿼리 매개 변수 URL 키를 재정의하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="c25fcb78f8ce32888e37289c4e3ec48b550205a2" translate="yes" xml:space="preserve">
          <source>The following equivalent default options will be applied when the Route calls &lt;code&gt;render&lt;/code&gt;:</source>
          <target state="translated">라우트 호출이 &lt;code&gt;render&lt;/code&gt; 될 때 다음과 같은 기본 옵션이 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="1c4f56e0c501f86b7a8f875bd1a2f2ae5dfd1313" translate="yes" xml:space="preserve">
          <source>The following example creates a tag like &lt;code&gt;&amp;lt;div priority=&quot;high&quot; /&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">다음 예제는 &lt;code&gt;&amp;lt;div priority=&quot;high&quot; /&amp;gt;&lt;/code&gt; 와 같은 태그를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="1e094e921fd819fa5e76624b61faecd882472c2a" translate="yes" xml:space="preserve">
          <source>The following example creates markup like &lt;code&gt;&amp;lt;div visible /&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">다음 예제는 &lt;code&gt;&amp;lt;div visible /&amp;gt;&lt;/code&gt; 과 같은 마크 업을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="dc0a3fedd616180b3a327dd59feed1f6924220c2" translate="yes" xml:space="preserve">
          <source>The following example shows how to bind &lt;code&gt;this.userComment&lt;/code&gt; to a text area's value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b6754ec9663f1a21ad10b8107f936386c921788" translate="yes" xml:space="preserve">
          <source>The following location types are available by default: &lt;code&gt;auto&lt;/code&gt;, &lt;code&gt;hash&lt;/code&gt;, &lt;code&gt;history&lt;/code&gt;, &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afdab8293445b11ec924bd3e51d6a5d98083d81e" translate="yes" xml:space="preserve">
          <source>The following location types are currently available:</source>
          <target state="translated">현재 사용할 수있는 위치 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="444af6ddc510304a303ba597ca9b18905abc9569" translate="yes" xml:space="preserve">
          <source>The following scenarios may help with understanding the &lt;code&gt;index&lt;/code&gt; route:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d99880308d15f3270bb92cdc1b4925f6bea7510d" translate="yes" xml:space="preserve">
          <source>The following will not render anything:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a04ae17d99bdb1ca3ff7d3f029873e55f621ebc" translate="yes" xml:space="preserve">
          <source>The format of your &lt;code&gt;links&lt;/code&gt; value will influence the final request URL via the &lt;code&gt;urlPrefix&lt;/code&gt; method:</source>
          <target state="translated">&lt;code&gt;links&lt;/code&gt; 값 의 형식은 &lt;code&gt;urlPrefix&lt;/code&gt; 메소드 를 통해 최종 요청 URL에 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="609b07ebd91a9564a1e401e69867af9f43852ebd" translate="yes" xml:space="preserve">
          <source>The full list of valid WAI-ARIA roles is available at: &lt;a href=&quot;http://www.w3.org/TR/wai-aria/roles#roles_categorization&quot;&gt;http://www.w3.org/TR/wai-aria/roles#roles_categorization&lt;/a&gt;</source>
          <target state="translated">유효한 WAI-ARIA 역할의 전체 목록은 &lt;a href=&quot;http://www.w3.org/TR/wai-aria/roles#roles_categorization&quot;&gt;http://www.w3.org/TR/wai-aria/roles#roles_categorization&lt;/a&gt; 에서 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a6e45911667579f9d564ca32ff7f674da9c67e45" translate="yes" xml:space="preserve">
          <source>The full list of valid WAI-ARIA roles is available at: &lt;a href=&quot;https://www.w3.org/TR/wai-aria/#roles_categorization&quot;&gt;https://www.w3.org/TR/wai-aria/#roles_categorization&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9511008deb941834774d3d5ef5d5eb87d148f334" translate="yes" xml:space="preserve">
          <source>The function of the subscription</source>
          <target state="translated">구독 기능</target>
        </trans-unit>
        <trans-unit id="e4e26ae3113858c8eb15c0dc4d04f32f42e1f9a1" translate="yes" xml:space="preserve">
          <source>The function or the name of a function of the subscription</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0cd84bb592c3813b530b12d48aa8e49154cd375" translate="yes" xml:space="preserve">
          <source>The function to be called.</source>
          <target state="translated">호출 할 함수입니다.</target>
        </trans-unit>
        <trans-unit id="082ed932b0ef334e05715d349323974d215f0f06" translate="yes" xml:space="preserve">
          <source>The function to be executed.</source>
          <target state="translated">실행될 기능.</target>
        </trans-unit>
        <trans-unit id="20346332ef72742b031a9ca3509b52ecb5e982e4" translate="yes" xml:space="preserve">
          <source>The function to call to remove all observers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="517f087bd001691420b5cdf2016bdad0607c3b4d" translate="yes" xml:space="preserve">
          <source>The function to turn into an action, when used in classic classes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb1e00c09e0f91fcfb54af8c8c11530f8722ad41" translate="yes" xml:space="preserve">
          <source>The function used to resolve the promise.</source>
          <target state="translated">약속을 해결하는 데 사용되는 기능입니다.</target>
        </trans-unit>
        <trans-unit id="79464200d9e3ddbdb2fe8367a586a4583bb4305d" translate="yes" xml:space="preserve">
          <source>The globals provided by some assets (like &lt;code&gt;moment&lt;/code&gt; in the below example) can be used in your application without the need to &lt;code&gt;import&lt;/code&gt; them. Provide the asset path as the first and only argument.</source>
          <target state="translated">(같은 일부 자산을 제공하는 전역 &lt;code&gt;moment&lt;/code&gt; 예를 아래에)을 할 필요없이 응용 프로그램에서 사용할 수있는 &lt;code&gt;import&lt;/code&gt; 를. 자산 경로를 첫 번째이자 유일한 인수로 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="933a1192be634af8a21616acc066822633b90230" translate="yes" xml:space="preserve">
          <source>The goal of initializers should be to register dependencies and injections. This phase runs once. Because these initializers may load code, they are allowed to defer application readiness and advance it. If you need to access the container or store you should use an InstanceInitializer that will be run after all initializers and therefore after all code is loaded and the app is ready.</source>
          <target state="translated">이니셜 라이저의 목표는 의존성 및 주입을 등록하는 것입니다. 이 단계는 한 번만 실행됩니다. 이러한 이니셜 라이저는 코드를로드 할 수 있으므로 응용 프로그램 준비를 연기하고 진행할 수 있습니다. 컨테이너 또는 저장소에 액세스해야하는 경우 모든 초기화 프로그램 이후에 실행되므로 모든 코드가로드되고 앱이 준비된 후에 실행되는 InstanceInitializer를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="b9c39dbd4973fde26a84eeab934b9541d4d9d411" translate="yes" xml:space="preserve">
          <source>The handler function takes the following arguments:</source>
          <target state="translated">핸들러 함수는 다음 인수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d9976137b5fc46c82802f55ca4a18f19ec76f045" translate="yes" xml:space="preserve">
          <source>The hash of enabled Canary features. Add to this, any canary features before creating your application.</source>
          <target state="translated">활성화 된 카나리아 기능의 해시. 응용 프로그램을 만들기 전에 모든 카나리아 기능을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="f3bd13d101777fcc85f4a786366b50ce298d07ab" translate="yes" xml:space="preserve">
          <source>The hash of environment variables used to control various configuration settings. To specify your own or override default settings, add the desired properties to a global hash named &lt;code&gt;EmberENV&lt;/code&gt; (or &lt;code&gt;ENV&lt;/code&gt; for backwards compatibility with earlier versions of Ember). The &lt;code&gt;EmberENV&lt;/code&gt; hash must be created before loading Ember.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1f5d4f4f7e10915f4694e587719c74a6240d5a1" translate="yes" xml:space="preserve">
          <source>The hash that you pass to the &lt;code&gt;meta()&lt;/code&gt; function will be saved on the computed property descriptor under the &lt;code&gt;_meta&lt;/code&gt; key. Ember runtime exposes a public API for retrieving these values from classes, via the &lt;code&gt;metaForProperty()&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;meta()&lt;/code&gt; 함수에 전달한 해시 는 계산 된 속성 설명자에 &lt;code&gt;_meta&lt;/code&gt; 키 아래에 저장 됩니다. Ember 런타임은 &lt;code&gt;metaForProperty()&lt;/code&gt; 함수 를 통해 클래스에서 이러한 값을 검색하기위한 공개 API를 노출 합니다.</target>
        </trans-unit>
        <trans-unit id="ca21eb1ac808b66726237aab6478d493b882f2e4" translate="yes" xml:space="preserve">
          <source>The helper allows some user events to send actions.</source>
          <target state="translated">도우미는 일부 사용자 이벤트가 작업을 보낼 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="a9bc08f7454fc33317953aa1d0764e69128fbd18" translate="yes" xml:space="preserve">
          <source>The helper can send multiple actions based on user events. The action property defines the action which is send when the user presses the return key.</source>
          <target state="translated">도우미는 사용자 이벤트를 기반으로 여러 작업을 보낼 수 있습니다. action 특성은 사용자가 리턴 키를 누를 때 전송되는 조치를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="467dd7598d6007e1305b827d35702192c6fb827f" translate="yes" xml:space="preserve">
          <source>The helper can send multiple actions based on user events. The action property defines the action which is sent when the user presses the return key.</source>
          <target state="translated">도우미는 사용자 이벤트를 기반으로 여러 작업을 보낼 수 있습니다. action 특성은 사용자가 리턴 키를 누를 때 전송되는 조치를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="f14ebca5a9493f4d2a211160aa65d2640ff18e72" translate="yes" xml:space="preserve">
          <source>The helper definition</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd3ae270075b46e8c72806c87f05194a68ec4531" translate="yes" xml:space="preserve">
          <source>The helper function</source>
          <target state="translated">도우미 기능</target>
        </trans-unit>
        <trans-unit id="a7b07a977cc772121d830f7df8058bbfdf781828" translate="yes" xml:space="preserve">
          <source>The helper method will always be called with the current Application as the first parameter.</source>
          <target state="translated">도우미 응용 프로그램은 항상 현재 응용 프로그램을 첫 번째 매개 변수로 사용하여 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="d352679de326e446da8bcf7ae02cdf1d2b388cc3" translate="yes" xml:space="preserve">
          <source>The helper method will always be called with the current Application as the first parameter. Other parameters, such as assert, need to be provided when calling the helper. Helpers need to be registered prior to calling &lt;code&gt;startApp&lt;/code&gt;, but ember-cli will take care of it for you.</source>
          <target state="translated">도우미 응용 프로그램은 항상 현재 응용 프로그램을 첫 번째 매개 변수로 사용하여 호출됩니다. 도우미를 호출 할 때는 assert와 같은 다른 매개 변수를 제공해야합니다. &lt;code&gt;startApp&lt;/code&gt; 를 호출하기 전에 헬퍼를 등록해야 하지만 ember-cli가이를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="20ee84ece384b1c7bf0a5f88c860139387c74bc6" translate="yes" xml:space="preserve">
          <source>The helper to remove.</source>
          <target state="translated">헬퍼를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="d01c5bd098982ca73ec7c55be9abde28b9b34a69" translate="yes" xml:space="preserve">
          <source>The hierarchy of valid states that ship with ember data looks like this:</source>
          <target state="translated">불씨 데이터와 함께 제공되는 유효한 상태의 계층 구조는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="68c89db6b29208c854763ad0480098f6d5a30824" translate="yes" xml:space="preserve">
          <source>The hook is also run during a time period where state mutations are &lt;em&gt;disabled&lt;/em&gt; in Ember. Any tracked state mutation will throw an error during this time, including changes to tracked properties, changes made using &lt;code&gt;Ember.set&lt;/code&gt;, updates to computed properties, etc. This is meant to prevent infinite rerenders and other antipatterns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47cb2e13420a1b957b4fcba174d9d1358ae53a96" translate="yes" xml:space="preserve">
          <source>The hook is autotracked, and will rerun whenever any tracked values used inside of it are updated. Otherwise it does not rerun.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6e2f5503b24777429c126a35c56b33d77b5055f" translate="yes" xml:space="preserve">
          <source>The id of the record in this belongsTo relationship.</source>
          <target state="translated">이 belongTo 관계의 레코드 ID입니다.</target>
        </trans-unit>
        <trans-unit id="8d93476bc0286bac3afbab171f7e9f39fc33828a" translate="yes" xml:space="preserve">
          <source>The id of the record.</source>
          <target state="translated">레코드의 ID입니다.</target>
        </trans-unit>
        <trans-unit id="82590e675d5bc1575afedb28d74680a06ba9de24" translate="yes" xml:space="preserve">
          <source>The identifier of the record.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ff46cda5606c5e7a37cd133795e79fcba629d16" translate="yes" xml:space="preserve">
          <source>The ids in this has-many relationship</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4faa84fc5172e99a8fce7d5c36e3348f6689acc6" translate="yes" xml:space="preserve">
          <source>The immediate benefit of the Router service is that you can inject it into components, giving them a friendly way to initiate transitions and ask questions about the current global router state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8942f8a026e7cff9b4bbcd39ba946b736b97427a" translate="yes" xml:space="preserve">
          <source>The index of each item in the array is provided as a second block param. This can be useful at times if you need the index, for instance if you needed to print positions in a queue</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71fe696ada77a1df388294168858e15ad016bb74" translate="yes" xml:space="preserve">
          <source>The index of the item to return.</source>
          <target state="translated">반환 할 항목의 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="e48be5efafef2f4ea1b2ff7461bc06581cff5d64" translate="yes" xml:space="preserve">
          <source>The index route is most helpful for rendering a view when the route has &lt;a href=&quot;#toc_dynamic-segments&quot;&gt;dynamic segments&lt;/a&gt; defined in it or there are nested routes. In other words, an &lt;code&gt;index&lt;/code&gt; template is used to show content that should not be present on sibling and child routes. For example, a blog app might have an &lt;code&gt;index&lt;/code&gt; route that shows a list of all posts, but if a user clicks on a post, they should only see the content for the individual post. Here is how that looks in practice:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf6c6f036f009d345c5f9f4a01b236f9acff2d54" translate="yes" xml:space="preserve">
          <source>The index to retrieve.</source>
          <target state="translated">검색 할 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="a59b1536c7b56b8fd58d1ea97c5500491fd87390" translate="yes" xml:space="preserve">
          <source>The initial URL to navigate to</source>
          <target state="translated">탐색 할 초기 URL</target>
        </trans-unit>
        <trans-unit id="6ec073e684d780eaf847bfcf50ff16099c381dae" translate="yes" xml:space="preserve">
          <source>The inline &lt;code&gt;if&lt;/code&gt; helper conditionally renders a single property or string.</source>
          <target state="translated">인라인이 &lt;code&gt;if&lt;/code&gt; 도우미 조건부 하나의 속성 또는 문자열을 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="d6d29959063e476cd6d120667a761a34e0a62dbb" translate="yes" xml:space="preserve">
          <source>The inline &lt;code&gt;unless&lt;/code&gt; helper conditionally renders a single property or string. This helper acts like a ternary operator. If the first property is falsy, the second argument will be displayed, otherwise, the third argument will be displayed</source>
          <target state="translated">도우미가 조건 적으로 단일 속성 또는 문자열을 렌더링 &lt;code&gt;unless&lt;/code&gt; 인라인 이 도우미는 삼항 연산자처럼 작동합니다. 첫 번째 속성이 거짓이면 두 번째 인수가 표시되고, 그렇지 않으면 세 번째 인수가 표시됩니다</target>
        </trans-unit>
        <trans-unit id="56b5934e9ef4b5884ae55376c33f1e9407f0ec2d" translate="yes" xml:space="preserve">
          <source>The interesting part is that the action from the service just works, because it's auto-bound to that service.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14e0d70d0190177bdf436a92b5e0a624b81f3c2a" translate="yes" xml:space="preserve">
          <source>The internal class used to create text inputs when the &lt;code&gt;Input&lt;/code&gt; component is used with &lt;code&gt;type&lt;/code&gt; of &lt;code&gt;text&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="875191874130e97e6feff5b21de2bc9eb0a9019c" translate="yes" xml:space="preserve">
          <source>The internal class used to create text inputs when the &lt;code&gt;{{input}}&lt;/code&gt; helper is used with &lt;code&gt;type&lt;/code&gt; of &lt;code&gt;checkbox&lt;/code&gt;.</source>
          <target state="translated">내부 클래스는 경우 텍스트 입력을 만드는 데 사용 &lt;code&gt;{{input}}&lt;/code&gt; 도우미가 함께 사용되는 &lt;code&gt;type&lt;/code&gt; 의 &lt;code&gt;checkbox&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5fdad83afa3d51d43a413c1abadbd70ea9c1b3b9" translate="yes" xml:space="preserve">
          <source>The internal class used to create text inputs when the &lt;code&gt;{{input}}&lt;/code&gt; helper is used with &lt;code&gt;type&lt;/code&gt; of &lt;code&gt;text&lt;/code&gt;. See &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Templates.helpers.html#method_input&quot;&gt;Ember.Templates.helpers.input&lt;/a&gt; for usage details.</source>
          <target state="translated">내부 클래스 때 문자 입력을 만드는 데 사용 &lt;code&gt;{{input}}&lt;/code&gt; 헬퍼 함께 사용되는 &lt;code&gt;type&lt;/code&gt; 의 &lt;code&gt;text&lt;/code&gt; . 사용법에 대한 자세한 내용 은 &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Templates.helpers.html#method_input&quot;&gt;Ember.Templates.helpers.input&lt;/a&gt; 을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="d607ba34fe18795114b4f433109ab02b90bb0adf" translate="yes" xml:space="preserve">
          <source>The internal class used to create textarea element when the &lt;code&gt;{{textarea}}&lt;/code&gt; helper is used.</source>
          <target state="translated">&lt;code&gt;{{textarea}}&lt;/code&gt; 헬퍼가 사용될 때 textarea 요소를 작성하는 데 사용되는 내부 클래스 입니다.</target>
        </trans-unit>
        <trans-unit id="361a1e9c264c708bc95babada9f413342830afcc" translate="yes" xml:space="preserve">
          <source>The internal representation used for &lt;code&gt;Textarea&lt;/code&gt; invocations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d750dea4a93a39d4b9db6798a523e5e15dcbad1" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;code&gt;{{if}}&lt;/code&gt; is &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_unless&quot;&gt;&lt;code&gt;{{unless}}&lt;/code&gt;&lt;/a&gt;, which can be used in the same three styles of invocation. For example, this template only shows an amount due when the user has not paid:</source>
          <target state="translated">&lt;code&gt;{{if}}&lt;/code&gt; 의 역 은 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_unless&quot;&gt; &lt;code&gt;{{unless}}&lt;/code&gt; &lt;/a&gt; 이며, 동일한 세 가지 스타일의 호출에서 사용할 수 있습니다. 예를 들어,이 템플릿은 사용자가 지불하지 않았을 때의 금액 만 표시합니다.</target>
        </trans-unit>
        <trans-unit id="d45de9e199e155b8777a207a094e041487a424da" translate="yes" xml:space="preserve">
          <source>The key &lt;code&gt;detail&lt;/code&gt; provides a textual description of the problem. Alternatively, the key &lt;code&gt;title&lt;/code&gt; can be used for the same purpose.</source>
          <target state="translated">주요 &lt;code&gt;detail&lt;/code&gt; 은 문제점에 대한 텍스트 설명을 제공합니다. 또는 키 &lt;code&gt;title&lt;/code&gt; 을 같은 목적으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65702202e37c204458f0da5be8d10b15dea8e083" translate="yes" xml:space="preserve">
          <source>The key of the sort definition (an array of sort properties), the sort function, or an array of additional dependent keys</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b7555d5282e96bd6e24cc32840ea3424b4844f1" translate="yes" xml:space="preserve">
          <source>The key to observe</source>
          <target state="translated">관찰의 열쇠</target>
        </trans-unit>
        <trans-unit id="bda81920321dffb71626e245008601afdbbd6199" translate="yes" xml:space="preserve">
          <source>The key to set</source>
          <target state="translated">설정하는 열쇠</target>
        </trans-unit>
        <trans-unit id="3a37ba2f54c8f8714e0c7608bafd94d61d56bf8f" translate="yes" xml:space="preserve">
          <source>The last index of the `object` in the array or -1 if not found</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eeedcde3650feea4c700ea4d5431330f4ad17e1" translate="yes" xml:space="preserve">
          <source>The last object in the array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ca2fa14c4fc099e27319297dcfa0ff98f1f9538" translate="yes" xml:space="preserve">
          <source>The last object in the array, or &lt;code&gt;undefined&lt;/code&gt; if the array is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6ee319d67963224e6cc6a893a3f09344964cfb2" translate="yes" xml:space="preserve">
          <source>The link Ember Data will use to fetch or reload this belongs-to relationship.</source>
          <target state="translated">Ember Data 링크는이 소속 관계를 가져 오거나 다시로드하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="df6a49096075b75f24d4bda7b0d30a1279be1940" translate="yes" xml:space="preserve">
          <source>The link Ember Data will use to fetch or reload this has-many relationship.</source>
          <target state="translated">Ember Data 링크는이 has-many 관계를 가져 오거나 다시로드하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d438ad26ddcf5d6460dbc8940bb903f47d13ab01" translate="yes" xml:space="preserve">
          <source>The link at which the associated resource collection might be found</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="985c30aaaeb77cdf5f5c1f2b96ab76fb8945b562" translate="yes" xml:space="preserve">
          <source>The link at which the associated resource might be found</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58a432726997d9234da6501577a946c77e95315e" translate="yes" xml:space="preserve">
          <source>The list of available feature-flags is located &lt;a href=&quot;https://github.com/emberjs/data/tree/master/packages/canary-features/addon/default-features.ts&quot;&gt;here&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb4639de6bdd5d693c4936a26db0f36475d3d91c" translate="yes" xml:space="preserve">
          <source>The loading state of this array</source>
          <target state="translated">이 배열의 로딩 상태</target>
        </trans-unit>
        <trans-unit id="c19c7109c687fbc9fcd386c8c0b1f5cabb138c0a" translate="yes" xml:space="preserve">
          <source>The location in the cache has been &lt;a href=&quot;http://emberjs.com/api/classes/Ember.String.html#method_camelize&quot;&gt;&lt;code&gt;camelized&lt;/code&gt;&lt;/a&gt; (line 30), so that it may be used as a key to look up our element. This matches the behavior in &lt;code&gt;getMapElement&lt;/code&gt; when city has not yet been cached.</source>
          <target state="translated">캐시의 위치는 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.String.html#method_camelize&quot;&gt; &lt;code&gt;camelized&lt;/code&gt; &lt;/a&gt; (30 행), 요소를 찾는 키로 사용될 수 있습니다. 도시가 아직 캐시되지 않은 경우 &lt;code&gt;getMapElement&lt;/code&gt; 의 동작과 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="a788518ddcd9fbbee4defbf1d862f0e936c78c17" translate="yes" xml:space="preserve">
          <source>The mapped array.</source>
          <target state="translated">매핑 된 배열입니다.</target>
        </trans-unit>
        <trans-unit id="18d8bcb9bddd16b3086b442996831dcaa439d784" translate="yes" xml:space="preserve">
          <source>The meta data for the belongs-to relationship.</source>
          <target state="translated">소속 관계에 대한 메타 데이터입니다.</target>
        </trans-unit>
        <trans-unit id="a85e08823b46b35e1ce946c3b00a085d8f560820" translate="yes" xml:space="preserve">
          <source>The meta information for the belongs-oo relationship.</source>
          <target state="translated">belongs-oo 관계에 대한 메타 정보.</target>
        </trans-unit>
        <trans-unit id="48f5b7224539ab7f4e87bf901aae2948123adfb0" translate="yes" xml:space="preserve">
          <source>The meta information for the belongs-to relationship.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34f2833b8151391b99f9c680911406631b2b6fdd" translate="yes" xml:space="preserve">
          <source>The meta information for the has-many relationship.</source>
          <target state="translated">has-many 관계에 대한 메타 정보.</target>
        </trans-unit>
        <trans-unit id="5d8430c934b008d50c8359ba00d5a45d0de82a9c" translate="yes" xml:space="preserve">
          <source>The method is responsible for pushing new data to the store using &lt;code&gt;store.push&lt;/code&gt; once any necessary normalization has occurred, and no data in the store will be updated unless it does so.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49369103b0464b44493cf84cb646510c7e94536a" translate="yes" xml:space="preserve">
          <source>The method name to check for</source>
          <target state="translated">확인할 메소드 이름</target>
        </trans-unit>
        <trans-unit id="0263e067489f60c9e685cbc3d24f7b8e48689a36" translate="yes" xml:space="preserve">
          <source>The method to invoke</source>
          <target state="translated">호출하는 방법</target>
        </trans-unit>
        <trans-unit id="19540d3f9bb05ef81877198fb53c8953af81b641" translate="yes" xml:space="preserve">
          <source>The method to invoke. If you pass a string it will be resolved on the target at the time the method is invoked.</source>
          <target state="translated">호출 할 메소드입니다. 문자열을 전달하면 메서드가 호출 될 때 대상에서 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="0de0091a090dc150acbc0fbf24a9397407d002b0" translate="yes" xml:space="preserve">
          <source>The method to invoke. If you pass a string it will be resolved on the target object at the time the scheduled item is invoked allowing you to change the target function.</source>
          <target state="translated">호출 할 메소드입니다. 문자열을 전달하면 예약 된 항목이 호출 될 때 대상 객체에서 해결되어 대상 기능을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3506db6058e732c49d0d84aa3928be98489273e0" translate="yes" xml:space="preserve">
          <source>The method to invoke. May be a function or a string. If you pass a string then it will be looked up on the passed target.</source>
          <target state="translated">호출 할 메소드입니다. 함수 또는 문자열 일 수 있습니다. 문자열을 전달하면 전달 된 대상에서 문자열을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="e194b891dd0bdf837df286a64c9c0349d4765a81" translate="yes" xml:space="preserve">
          <source>The methods in this mixin have been moved to &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/MutableArray&quot;&gt;MutableArray&lt;/a&gt;. This mixin has been intentionally preserved to avoid breaking Enumerable.detect checks until the community migrates away from them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d11f6516cbacb45fdea866478b595ee9ed7bf1d3" translate="yes" xml:space="preserve">
          <source>The methods likely to be overridden are:</source>
          <target state="translated">재정의 될 가능성이있는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eb3c70dade0bce9d1ab411df82e04ea62f4ddfac" translate="yes" xml:space="preserve">
          <source>The methods of this object are designed to be easy to override in a subclass. For example, you could enhance how a template is resolved like so:</source>
          <target state="translated">이 객체의 메소드는 서브 클래스에서 쉽게 오버라이드되도록 설계되었습니다. 예를 들어 템플릿을 다음과 같이 해결하는 방법을 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9047c74c1590bc009ee5e6df824e3a60a2c8e26" translate="yes" xml:space="preserve">
          <source>The model class is determined from the segment (&lt;code&gt;post_id&lt;/code&gt;'s class is &lt;code&gt;App.Post&lt;/code&gt;)</source>
          <target state="translated">모델 클래스는 세그먼트에서 결정됩니다 ( &lt;code&gt;post_id&lt;/code&gt; 의 클래스는 &lt;code&gt;App.Post&lt;/code&gt; 입니다 )</target>
        </trans-unit>
        <trans-unit id="5da58253b88e1c437a81d76ece8cc0c89fc0db69" translate="yes" xml:space="preserve">
          <source>The model class that all Ember Data records descend from. This is the public API of Ember Data models. If you are using Ember Data in your application, this is the class you should use. If you are working on Ember Data internals, you most likely want to be dealing with &lt;code&gt;InternalModel&lt;/code&gt;</source>
          <target state="translated">모든 Ember Data 레코드의 자손 모델 클래스. Ember Data 모델의 공개 API입니다. 응용 프로그램에서 Ember Data를 사용하는 경우이 클래스를 사용해야합니다. Ember Data 내부 작업을하고 있다면 &lt;code&gt;InternalModel&lt;/code&gt; 을 다루고 싶을 것입니다.</target>
        </trans-unit>
        <trans-unit id="7e351f80cd5556cb6da014791c372d237924a3b0" translate="yes" xml:space="preserve">
          <source>The model for the &lt;code&gt;post&lt;/code&gt; route is &lt;code&gt;store.findRecord('post', params.post_id)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;post&lt;/code&gt; 경로 의 모델 은 &lt;code&gt;store.findRecord('post', params.post_id)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="61a80d68a8a250e49493ed6f67e0f4faa9238b3d" translate="yes" xml:space="preserve">
          <source>The model hooks (&lt;code&gt;beforeModel&lt;/code&gt;, &lt;code&gt;model&lt;/code&gt;, and &lt;code&gt;afterModel&lt;/code&gt;) of an error substate are not called. Only the &lt;code&gt;setupController&lt;/code&gt; method of the error substate is called with the &lt;code&gt;error&lt;/code&gt; as the model. See example below:</source>
          <target state="translated">오류 하위 상태 의 모델 후크 ( &lt;code&gt;beforeModel&lt;/code&gt; , &lt;code&gt;model&lt;/code&gt; 및 &lt;code&gt;afterModel&lt;/code&gt; )는 호출되지 않습니다. 오류 하위 상태 의 &lt;code&gt;setupController&lt;/code&gt; 메소드 만 &lt;code&gt;error&lt;/code&gt; 를 모델로 호출 합니다. 아래 예를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b8016ce6655155fdadd4d35b5e510555347bbeed" translate="yes" xml:space="preserve">
          <source>The model is passed from the Route to the Controller by default using the &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Route/methods#setupController&quot;&gt;&lt;code&gt;setupController()&lt;/code&gt;&lt;/a&gt; function. The Controller is then often used to decorate the model with display properties such as retrieving the full name from a name model.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19ae229adfd578f13d92ff0a6a38ca5deaa02ad7" translate="yes" xml:space="preserve">
          <source>The model name.</source>
          <target state="translated">모델명.</target>
        </trans-unit>
        <trans-unit id="280c3aad18626cc5e1384613f6c69059889e22fc" translate="yes" xml:space="preserve">
          <source>The model's relationships as a map, keyed on the type of the relationship. The value of each entry is an array containing a descriptor for each relationship with that type, describing the name of the relationship as well as the type.</source>
          <target state="translated">관계 유형에 따라 맵으로 모델의 관계. 각 항목의 값은 해당 유형과의 각 관계에 대한 설명자를 포함하는 배열이며 관계 이름과 유형을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="d0e3568f7b5ea35bae50803475ef2f179bff0fad" translate="yes" xml:space="preserve">
          <source>The modelClass represented by this record array.</source>
          <target state="translated">이 레코드 배열이 나타내는 modelClass</target>
        </trans-unit>
        <trans-unit id="1b04aa2d53410185338ec80a1de0f471ec5c2cca" translate="yes" xml:space="preserve">
          <source>The modern, Octane-style way to handle keyboard events is to &lt;a href=&quot;https://guides.emberjs.com/upgrading/current-edition/glimmer-components/#toc_writing-your-own-modifiers&quot;&gt;write a modifier&lt;/a&gt; to separate concerns: The component manages the state, while the modifier manages interactions with the DOM. Your action will receive an actual &lt;code&gt;event&lt;/code&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1468fe922c4d358e1fb64d192198edd28ad5323b" translate="yes" xml:space="preserve">
          <source>The modifier takes 1 argument, a Boolean that specifies if we should call the element's &lt;code&gt;play&lt;/code&gt; or &lt;code&gt;pause&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b5cb3250e657154b846921be6b421736593a830" translate="yes" xml:space="preserve">
          <source>The modifier that we made for the audio player component can be reused on &lt;em&gt;any&lt;/em&gt; element that implements &lt;code&gt;play&lt;/code&gt; and &lt;code&gt;pause&lt;/code&gt; methods. In particular, we can reuse the modifier on any &lt;code&gt;HTMLMediaElement&lt;/code&gt;, which includes &lt;code&gt;audio&lt;/code&gt; and &lt;code&gt;video&lt;/code&gt; elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3370a1c791c00ea8404d8d2d8350797b938bd250" translate="yes" xml:space="preserve">
          <source>The modifier that we're going to build will allow us to say:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06574cdcebf2b12553ee5033ae390a06647355df" translate="yes" xml:space="preserve">
          <source>The most common case for using the run loop is integrating with a non-Ember API that includes some sort of asynchronous callback. For example:</source>
          <target state="translated">실행 루프를 사용하는 가장 일반적인 경우는 일종의 비동기 콜백을 포함하는 비 Ember API와 통합하는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cacb8b5741c18afe5abd31963d74c05c17355b34" translate="yes" xml:space="preserve">
          <source>The most common place you'll want to access &lt;code&gt;modelName&lt;/code&gt; is in your serializer's &lt;code&gt;payloadKeyFromModelName&lt;/code&gt; method. For example, to change payload keys to underscore (instead of dasherized), you might use the following code:</source>
          <target state="translated">&lt;code&gt;modelName&lt;/code&gt; 에 액세스하려는 가장 일반적인 장소 는 시리얼 라이저의 &lt;code&gt;payloadKeyFromModelName&lt;/code&gt; 메소드입니다. 예를 들어, 대시 보드 대신 페이로드 키를 밑줄로 변경하려면 다음 코드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="222ca871cd60800a1adcf1df212f18f99834d9b6" translate="yes" xml:space="preserve">
          <source>The most important difference between this example and the cases we've seen so far is that we need to remove the &lt;code&gt;click&lt;/code&gt; event handler from the document when this element is destroyed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72e917e7fbfea1d894c8dfaa034cc1e720bdd4e4" translate="yes" xml:space="preserve">
          <source>The most important thing to know about named argument syntax is that an argument with an &lt;code&gt;@&lt;/code&gt;&lt;em&gt;always&lt;/em&gt; refers to the &lt;em&gt;original&lt;/em&gt; value that was passed when the component was invoked. If you change that value in a classic component, it will &lt;em&gt;not&lt;/em&gt; update:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4860165ddeb1c56516173150ded5daec90a22733" translate="yes" xml:space="preserve">
          <source>The name of a route. In this example, it would be &lt;code&gt;index&lt;/code&gt;, &lt;code&gt;photos&lt;/code&gt;, or &lt;code&gt;photos.edit&lt;/code&gt;.</source>
          <target state="translated">경로의 이름입니다. 이 예에서는 &lt;code&gt;index&lt;/code&gt; , &lt;code&gt;photos&lt;/code&gt; 또는 &lt;code&gt;photos.edit&lt;/code&gt; 입니다. 입니다.</target>
        </trans-unit>
        <trans-unit id="f70391ad509d6330a846870500a48929f3fe644d" translate="yes" xml:space="preserve">
          <source>The name of the controller to associate with this route.</source>
          <target state="translated">이 라우트와 연관시킬 컨트롤러의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="8a0f4ba13feddd8f7a0fcb578c4a64ee25577bba" translate="yes" xml:space="preserve">
          <source>The name of the currently active route.</source>
          <target state="translated">현재 활성화 된 경로의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="2d5cd10d5efb705d95ff6ef881164cb30052e176" translate="yes" xml:space="preserve">
          <source>The name of the event</source>
          <target state="translated">행사 명</target>
        </trans-unit>
        <trans-unit id="79193a57dbbc3246321cf5ba9ea7e09896c27a92" translate="yes" xml:space="preserve">
          <source>The name of the helper method to add.</source>
          <target state="translated">추가 할 헬퍼 메소드의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="0be317d734b30c2e8a916f8992d44b13a519d341" translate="yes" xml:space="preserve">
          <source>The name of the model type for this payload</source>
          <target state="translated">이 페이로드에 대한 모델 유형의 이름</target>
        </trans-unit>
        <trans-unit id="48937d3df342f8b3c9377985edf9ceb5b1837454" translate="yes" xml:space="preserve">
          <source>The name of the property to decrement</source>
          <target state="translated">감액 할 자산의 이름</target>
        </trans-unit>
        <trans-unit id="a664383b45acf8957aaf6e6f496db9828833977d" translate="yes" xml:space="preserve">
          <source>The name of the property to increment</source>
          <target state="translated">증분 할 속성의 이름</target>
        </trans-unit>
        <trans-unit id="8a46946ba08b63ffb9945d5218fd4eaab85e6281" translate="yes" xml:space="preserve">
          <source>The name of the property to retrieve</source>
          <target state="translated">검색 할 속성의 이름</target>
        </trans-unit>
        <trans-unit id="645bc5da9840b9064b59ef1eef330781affe8068" translate="yes" xml:space="preserve">
          <source>The name of the property to toggle</source>
          <target state="translated">토글 할 속성의 이름</target>
        </trans-unit>
        <trans-unit id="5fb100cec0ff90d54ebe800238fc00ef6238601d" translate="yes" xml:space="preserve">
          <source>The name of the queue to schedule against. Default queues are 'sync' and 'actions'</source>
          <target state="translated">스케줄 할 큐의 이름입니다. 기본 대기열은 'sync'및 'actions'입니다.</target>
        </trans-unit>
        <trans-unit id="4c90a724a69d75c22285140dd18e22630ce627af" translate="yes" xml:space="preserve">
          <source>The name of the queue to schedule against. Default queues are 'sync' and 'actions'.</source>
          <target state="translated">스케줄 할 큐의 이름입니다. 기본 대기열은 'sync'및 'actions'입니다.</target>
        </trans-unit>
        <trans-unit id="412c7edabb449d585fb3b04777cadf040be0c6fb" translate="yes" xml:space="preserve">
          <source>The name of the queue to schedule against. Default queues is 'actions'</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58a7a93b5cf03f01876ff341f3a948fb65c42f65" translate="yes" xml:space="preserve">
          <source>The name of the queue to schedule against. Default queues is 'actions'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92bd55fef05773932c03eea0113227b4aea76072" translate="yes" xml:space="preserve">
          <source>The name of the remote type. This should either be &quot;link&quot; or &quot;id&quot;</source>
          <target state="translated">원격 유형의 이름입니다. &quot;link&quot;또는 &quot;id&quot;여야합니다.</target>
        </trans-unit>
        <trans-unit id="a7278ab5074a42a98d664c4226440fce451e40e3" translate="yes" xml:space="preserve">
          <source>The name of the remote type. This should either be &quot;link&quot; or &quot;ids&quot;</source>
          <target state="translated">원격 유형의 이름입니다. &quot;link&quot;또는 &quot;ids&quot;여야합니다.</target>
        </trans-unit>
        <trans-unit id="6838390afde7ef9b39749e803754bdd090c5e4ec" translate="yes" xml:space="preserve">
          <source>The name of the remote type. This should either be `link` or `ids`</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15f44cca7344c2cf48a11e2ee934769fefd135d2" translate="yes" xml:space="preserve">
          <source>The name of the route, defined by the router, is &lt;code&gt;post&lt;/code&gt;.</source>
          <target state="translated">라우터가 정의한 경로 이름은 &lt;code&gt;post&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bf231cf3a8a2a447118471fb31238f6056887442" translate="yes" xml:space="preserve">
          <source>The name of the route, dot-delimited, including the engine prefix if applicable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08a86bad24be595b560f010d3688c6353e6a3adf" translate="yes" xml:space="preserve">
          <source>The name of the route, dot-delimited.</source>
          <target state="translated">경로로 구분 된 이름입니다.</target>
        </trans-unit>
        <trans-unit id="289954f9d601b7db9c6b62df2307ce4028bd72f5" translate="yes" xml:space="preserve">
          <source>The name of the template to render minus the leading underscore.</source>
          <target state="translated">밑줄을 뺀 렌더링 할 템플릿의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="585502711f2ed284be4b7d4f4cbfdd64b80f43da" translate="yes" xml:space="preserve">
          <source>The name of the template to use by default when rendering this routes template.</source>
          <target state="translated">이 경로 템플릿을 렌더링 할 때 기본적으로 사용할 템플릿 이름입니다.</target>
        </trans-unit>
        <trans-unit id="ac02b1d310f7ef275f6aa37d5a1c1857a4953643" translate="yes" xml:space="preserve">
          <source>The named arguments are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66bd3365f2c2e07363112e9b122a98da62e8cf5e" translate="yes" xml:space="preserve">
          <source>The named arguments to the helper</source>
          <target state="translated">도우미에 대한 명명 된 주장</target>
        </trans-unit>
        <trans-unit id="a509b315f0cde9d1bc56906fc1ff01f0fa7cd5eb" translate="yes" xml:space="preserve">
          <source>The names are bound in the order that they are passed to &lt;code&gt;yield&lt;/code&gt; in the component template.</source>
          <target state="translated">이름은 구성 요소 템플릿에서 &lt;code&gt;yield&lt;/code&gt; 하도록 전달 된 순서대로 바인딩됩니다 .</target>
        </trans-unit>
        <trans-unit id="e77eb65bd28e587e371b48a93647ea7203a5a5b5" translate="yes" xml:space="preserve">
          <source>The native decorator version functions the same, just with a slightly different syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af735066725f72033af215f7de9ba3c390ea1309" translate="yes" xml:space="preserve">
          <source>The nested helper is called first returning &lt;code&gt;&quot;zoooom&quot;&lt;/code&gt; only if &lt;code&gt;isFueled&lt;/code&gt; is true. Then the inline expression is called, rendering the nested helper's value (&lt;code&gt;&quot;zoooom&quot;&lt;/code&gt;) only if &lt;code&gt;isFast&lt;/code&gt; is true.</source>
          <target state="translated">중첩 된 도우미는 &lt;code&gt;isFueled&lt;/code&gt; 가 true 인 경우에만 먼저 &lt;code&gt;&quot;zoooom&quot;&lt;/code&gt; 을 반환 합니다. 그런 다음 &lt;code&gt;isFast&lt;/code&gt; 가 true 인 경우에만 중첩 된 도우미 값 ( &lt;code&gt;&quot;zoooom&quot;&lt;/code&gt; )을 렌더링하여 인라인 표현식이 호출 됩니다 .</target>
        </trans-unit>
        <trans-unit id="d1a53ba45425a490db9af03715c5bdb612eaf800" translate="yes" xml:space="preserve">
          <source>The nested keys &lt;code&gt;source.pointer&lt;/code&gt; detail which specific element of the request data was invalid.</source>
          <target state="translated">중첩 된 키 &lt;code&gt;source.pointer&lt;/code&gt; 는 요청 데이터의 특정 요소가 유효하지 않은 세부 사항입니다.</target>
        </trans-unit>
        <trans-unit id="3760ba7804e24bcfab76505e83862a063874ae43" translate="yes" xml:space="preserve">
          <source>The new APIs split each of these pieces of functionality out into one clearly defined API:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c12d2d252b58333d9ab6aaa11b78422d2a1172e" translate="yes" xml:space="preserve">
          <source>The new owner object of the object instance.</source>
          <target state="translated">객체 인스턴스의 새로운 소유자 객체.</target>
        </trans-unit>
        <trans-unit id="0086db850d74927843eccf283540af44ecddc2fe" translate="yes" xml:space="preserve">
          <source>The new property value</source>
          <target state="translated">새로운 속성 값</target>
        </trans-unit>
        <trans-unit id="a8598df9298115d19b4f856a4a205f3b2de8355a" translate="yes" xml:space="preserve">
          <source>The next example includes a dynamic segment, and will return &lt;code&gt;true&lt;/code&gt; if the current route is &lt;code&gt;/posts/1&lt;/code&gt;, assuming the post has an id of 1:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f13234869d6044bbe39065b2ac29afdf278e2d5" translate="yes" xml:space="preserve">
          <source>The normal behavior for a function defined in &lt;code&gt;actions&lt;/code&gt; does not receive the browser event as an argument. So, the function definition for the action cannot define an event parameter. The following example demonstrates the default behavior using an action.</source>
          <target state="translated">&lt;code&gt;actions&lt;/code&gt; 정의 된 함수의 정상적인 동작 은 브라우저 이벤트를 인수로받지 않습니다. 따라서 조치에 대한 함수 정의는 이벤트 매개 변수를 정의 할 수 없습니다. 다음 예제는 조치를 사용하여 기본 작동을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="ba645aaa52d49d720b744b7458d92f0fa898b311" translate="yes" xml:space="preserve">
          <source>The normalized JSON format that Ember Data expects is a &lt;a href=&quot;http://jsonapi.org/&quot;&gt;JSON API&lt;/a&gt; document with a couple of additional restrictions.</source>
          <target state="translated">Ember Data가 기대하는 정규화 된 JSON 형식 은 몇 가지 추가 제한 이있는 &lt;a href=&quot;http://jsonapi.org/&quot;&gt;JSON API&lt;/a&gt; 문서입니다.</target>
        </trans-unit>
        <trans-unit id="25ea6956efd1543b5c8bfa3c8a43cfe9ca4cb62c" translate="yes" xml:space="preserve">
          <source>The normalized JSON format that Ember Data expects is a &lt;a href=&quot;http://jsonapi.org/&quot;&gt;JSON:API&lt;/a&gt; document with a couple of additional restrictions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c8de9de7d8715fcd640ec12ea5f6988255f2d0e" translate="yes" xml:space="preserve">
          <source>The normalized JSON object that Ember Data expects a serializer to return looks like this:</source>
          <target state="translated">Ember Data가 serializer가 리턴 할 것으로 예상되는 정규화 된 JSON 객체는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0ccea401d7f2c57f31fb97091aeada81b3b9a1c9" translate="yes" xml:space="preserve">
          <source>The normalized form pushed to the store should be a &lt;a href=&quot;https://jsonapi.org/format/#document-structure&quot;&gt;JSON:API Document&lt;/a&gt; with the following additional restrictions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00b1abab6fd9ec65b4425bed0a462ed09048b6e0" translate="yes" xml:space="preserve">
          <source>The normalized payload</source>
          <target state="translated">정규화 된 페이로드</target>
        </trans-unit>
        <trans-unit id="a349a314b9df21dfbe3354d6dd9d45d18d122cff" translate="yes" xml:space="preserve">
          <source>The number of items that were added. If you pass `null` assumes 0.</source>
          <target state="translated">추가 된 항목 수 null을 전달하면 0으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="2d2399ceba6066f06edc5df6a7ec02fa87dba439" translate="yes" xml:space="preserve">
          <source>The number of items that were removed. If you pass `null` assumes 0</source>
          <target state="translated">제거 된 항목 수입니다. null을 전달하면 0을 가정합니다.</target>
        </trans-unit>
        <trans-unit id="91de528748ecbc74aef2c6d96b0c6e4f03f6131b" translate="yes" xml:space="preserve">
          <source>The number of items that will be added. If you pass `null` assumes 0.</source>
          <target state="translated">추가 할 항목 수입니다. null을 전달하면 0으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="975c27e833e6ea26acbcf63ae5b7ecc849744c75" translate="yes" xml:space="preserve">
          <source>The number of items that will be removed. If you pass `null` assumes 0</source>
          <target state="translated">제거 할 항목 수입니다. null을 전달하면 0을 가정합니다.</target>
        </trans-unit>
        <trans-unit id="e816df9aec6afce2dab560624ebd5e2d88a63a6f" translate="yes" xml:space="preserve">
          <source>The number of items to remove from the content.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="639768cbeb0d904ac01029f55e97c377a305a71d" translate="yes" xml:space="preserve">
          <source>The object containing named arguments is passed as the second argument to the helper function. Here is our example from above, updated to support the optional &lt;code&gt;sign&lt;/code&gt; option:</source>
          <target state="translated">명명 된 인수를 포함하는 객체는 도우미 함수에 두 번째 인수로 전달됩니다. 다음은 선택적 &lt;code&gt;sign&lt;/code&gt; 옵션 을 지원하도록 업데이트 된 위의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="c51a687fc71aeecf9c4dd958d6df740581650633" translate="yes" xml:space="preserve">
          <source>The object observing the array.</source>
          <target state="translated">배열을 관찰하는 객체입니다.</target>
        </trans-unit>
        <trans-unit id="1f67ed68402a22d74098c4257ec3b53cafc15f90" translate="yes" xml:space="preserve">
          <source>The object returned from &lt;code&gt;RSVP.defer&lt;/code&gt; is a plain object with three properties:</source>
          <target state="translated">&lt;code&gt;RSVP.defer&lt;/code&gt; 에서 반환 된 개체는 다음 세 가지 속성을 가진 일반 개체입니다.</target>
        </trans-unit>
        <trans-unit id="a22e7374b19cc8596804fc741752de92aaff8198" translate="yes" xml:space="preserve">
          <source>The object returned from &lt;code&gt;defer&lt;/code&gt; is a plain object with three properties:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcce5060e65cd2c99b0f4c620ad0472078d080ff" translate="yes" xml:space="preserve">
          <source>The object stays intact until the end of the run loop at which point the &lt;code&gt;isDestroyed&lt;/code&gt; flag is set.</source>
          <target state="translated">&lt;code&gt;isDestroyed&lt;/code&gt; 플래그가 설정 되는 시점에서 실행 루프가 끝날 때까지 객체는 그대로 유지 됩니다.</target>
        </trans-unit>
        <trans-unit id="95c8a20f0925b5bbf96fad0499bac57039d137a8" translate="yes" xml:space="preserve">
          <source>The object to add to the enumerable.</source>
          <target state="translated">열거 형에 추가 할 객체입니다.</target>
        </trans-unit>
        <trans-unit id="3cf4a0d87f7ef69ab445296f735a615e0fc9dd1e" translate="yes" xml:space="preserve">
          <source>The object to assign into</source>
          <target state="translated">할당 할 객체</target>
        </trans-unit>
        <trans-unit id="8af03bf022efd9a0cec5228d3be213b9c85f758e" translate="yes" xml:space="preserve">
          <source>The object to check for the method</source>
          <target state="translated">메소드를 확인할 객체</target>
        </trans-unit>
        <trans-unit id="0955c243cfd3d12d78e568b378af83363f51f222" translate="yes" xml:space="preserve">
          <source>The object to clone</source>
          <target state="translated">복제 할 객체</target>
        </trans-unit>
        <trans-unit id="39bee534497a07212f93576f4aad1e60752a86d9" translate="yes" xml:space="preserve">
          <source>The object to copy properties from</source>
          <target state="translated">속성을 복사 할 객체</target>
        </trans-unit>
        <trans-unit id="65d2fc606502a1327b27b00711f4cf8c80ff80d1" translate="yes" xml:space="preserve">
          <source>The object to merge into</source>
          <target state="translated">병합 할 객체</target>
        </trans-unit>
        <trans-unit id="e4f8472045258fdd0fca12c9ca54919b2134defc" translate="yes" xml:space="preserve">
          <source>The object to modify.</source>
          <target state="translated">수정할 객체입니다.</target>
        </trans-unit>
        <trans-unit id="79abb60263af3837b02a264e27ebb51b2ad3b831" translate="yes" xml:space="preserve">
          <source>The object to remove from the enumerable.</source>
          <target state="translated">열거 가능한 객체에서 제거 할 객체입니다.</target>
        </trans-unit>
        <trans-unit id="01c87d6a0a7d961661808d6108688f7202e3182f" translate="yes" xml:space="preserve">
          <source>The object to retrieve from.</source>
          <target state="translated">검색 할 객체입니다.</target>
        </trans-unit>
        <trans-unit id="2bb20788eae84e07081d526563f29dae4b083856" translate="yes" xml:space="preserve">
          <source>The object to search for.</source>
          <target state="translated">검색 할 객체입니다.</target>
        </trans-unit>
        <trans-unit id="85154a5e735c921ec2b690de03758de42871ced1" translate="yes" xml:space="preserve">
          <source>The object to set</source>
          <target state="translated">설정할 객체</target>
        </trans-unit>
        <trans-unit id="c3f77d96cdc8b56e6910e3df6d5a9f1c5613f0e4" translate="yes" xml:space="preserve">
          <source>The object to test</source>
          <target state="translated">테스트 할 객체</target>
        </trans-unit>
        <trans-unit id="2bf3733b3229286b376b10082612e1163e376d99" translate="yes" xml:space="preserve">
          <source>The object to which actions from the view should be sent.</source>
          <target state="translated">뷰에서 조치를 전송해야하는 오브젝트입니다.</target>
        </trans-unit>
        <trans-unit id="f2e260d2b4ad3400e0f245818f68da026a61b131" translate="yes" xml:space="preserve">
          <source>The object whose properties will be forwarded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd986381270f07f0062f1ef0c9b835aa255c1311" translate="yes" xml:space="preserve">
          <source>The objects to copy properties from</source>
          <target state="translated">속성을 복사 할 객체</target>
        </trans-unit>
        <trans-unit id="372e877cd43ae664673ebc043c2112a916e22b72" translate="yes" xml:space="preserve">
          <source>The observer object.</source>
          <target state="translated">관찰자 객체.</target>
        </trans-unit>
        <trans-unit id="448dcc70f1215ccab08f58246150159cb7a80828" translate="yes" xml:space="preserve">
          <source>The only class that is &lt;em&gt;not&lt;/em&gt; supported out of the box is the &lt;em&gt;classic Ember component&lt;/em&gt; class, i.e. one imported from &lt;code&gt;@ember/component&lt;/code&gt;. However, you can instead use external addons like &lt;a href=&quot;https://ember-decorators.github.io/ember-decorators&quot;&gt;ember-decorators&lt;/a&gt; if you want to convert these to native classes, and refer to their documentation as a guide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd1d5fc6ac23ff50def69e2c4b83e165b6a3f7b3" translate="yes" xml:space="preserve">
          <source>The only pattern supported is brace-expansion, anything else will be passed once to &lt;code&gt;callback&lt;/code&gt; directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86ce6ebe7d9f65ca0fad2ad947fec199ce6da745" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;startAt&lt;/code&gt; argument can be used to pass a starting index to search from, effectively slicing the searchable portion of the array. If it's negative it will add the array length to the startAt value passed in as the index to search from. If less than or equal to &lt;code&gt;-1 * array.length&lt;/code&gt; the entire array is searched.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bd8eb25be5a5fbd3fb1135a8b16d0f54738ece3" translate="yes" xml:space="preserve">
          <source>The optional features available to your project will depend on the Ember version your project is using.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="711d7a87524d1dd84793229cd8b47d431d1d8180" translate="yes" xml:space="preserve">
          <source>The options passed into the &lt;code&gt;DS.attr&lt;/code&gt; function when the attribute is declared on the model is also available in the transform.</source>
          <target state="translated">모델에서 속성이 선언 될 때 &lt;code&gt;DS.attr&lt;/code&gt; 함수에 전달 된 옵션 도 변환에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4f866c519a5e8c630cd9a5e6dd63f20316368ea" translate="yes" xml:space="preserve">
          <source>The options to be passed to jQuery.Event.</source>
          <target state="translated">jQuery.Event에 전달할 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="1d5b199ecaf9f6851a87242945e3563cbeca4d9e" translate="yes" xml:space="preserve">
          <source>The ordered list of the names of the params required for this route. It will contain the same strings as &lt;code&gt;Object.keys(params)&lt;/code&gt;, but here the order is significant. This allows users to correctly pass params into routes programmatically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f193bff1f5340e2150109b94091164061bd23641" translate="yes" xml:space="preserve">
          <source>The ordered list of the names of the params required for this route. It will contain the same strings as Object.keys(params), but here the order is significant. This allows users to correctly pass params into routes programmatically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a15f5af6bdfd5a89f7ac048643da0da0b69b48f" translate="yes" xml:space="preserve">
          <source>The other major benefit to the above approach is that &lt;code&gt;next&lt;/code&gt; introduces an element of non-determinism, which can make things much harder to test, due to its reliance on &lt;code&gt;setTimeout&lt;/code&gt;; it's much harder to guarantee the order of scheduled operations when they are scheduled outside of the current run loop, i.e. with &lt;code&gt;next&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56c3cd7a661678595c73eb270a9318b5eac13978" translate="yes" xml:space="preserve">
          <source>The other major benefit to the above approach is that &lt;code&gt;run.next&lt;/code&gt; introduces an element of non-determinism, which can make things much harder to test, due to its reliance on &lt;code&gt;setTimeout&lt;/code&gt;; it's much harder to guarantee the order of scheduled operations when they are scheduled outside of the current run loop, i.e. with &lt;code&gt;run.next&lt;/code&gt;.</source>
          <target state="translated">위의 접근 방식의 다른 주요 이점은 &lt;code&gt;run.next&lt;/code&gt; 가 비 결정적 요소를 도입하여 &lt;code&gt;setTimeout&lt;/code&gt; 에 의존하기 때문에 테스트하기가 훨씬 어려워진다는 것입니다 . 현재 실행 루프 외부에서 예약 된 경우 (예 : &lt;code&gt;run.next&lt;/code&gt; ) 예약 된 작업의 순서를 보장하는 것이 훨씬 어렵 습니다 .</target>
        </trans-unit>
        <trans-unit id="c14211cb494d4ea352d68e2ab9fb3c84186d8bce" translate="yes" xml:space="preserve">
          <source>The other one is &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Route.html#method_replaceWith&quot;&gt;&lt;code&gt;replaceWith()&lt;/code&gt;&lt;/a&gt; which works the same way as &lt;code&gt;transitionTo()&lt;/code&gt;. The only difference between them is how they manage history. &lt;code&gt;replaceWith()&lt;/code&gt; substitutes the current route entry and replaces it with that of the route we are redirecting to, while &lt;code&gt;transitionTo()&lt;/code&gt; leaves the entry for the current route and creates a new one for the redirection.</source>
          <target state="translated">다른 하나는 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Route.html#method_replaceWith&quot;&gt; &lt;code&gt;replaceWith()&lt;/code&gt; &lt;/a&gt; 이며 &lt;code&gt;transitionTo()&lt;/code&gt; 와 같은 방식으로 작동합니다 . 그들 사이의 유일한 차이점은 그들이 역사를 관리하는 방법입니다. &lt;code&gt;replaceWith()&lt;/code&gt; 는 현재 경로 항목을 대체하고 경로를 리디렉션하려는 경로의 항목으로 바꿉니다. &lt;code&gt;transitionTo()&lt;/code&gt; 는 현재 경로에 대한 항목을 남겨두고 리디렉션을위한 새 항목을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="db073562ceb1b92e3c932f55b5af938bebfe3a7a" translate="yes" xml:space="preserve">
          <source>The other one is &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Route/methods#replaceWith&quot;&gt;&lt;code&gt;replaceWith()&lt;/code&gt;&lt;/a&gt; which works the same way as &lt;code&gt;transitionTo()&lt;/code&gt;. The only difference between them is how they manage history. &lt;code&gt;replaceWith()&lt;/code&gt; substitutes the current route entry and replaces it with that of the route we are redirecting to, while &lt;code&gt;transitionTo()&lt;/code&gt; leaves the entry for the current route and creates a new one for the redirection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71ba9a0210d410c7455d5ed7adcabeabe2e374ec" translate="yes" xml:space="preserve">
          <source>The output looks the same as before, but now the &lt;code&gt;0&lt;/code&gt; comes from JavaScript, and after some more work, we can change its value with the buttons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acc6d06fca4a644df1fa4d9b90eb32abb2585f8e" translate="yes" xml:space="preserve">
          <source>The output of the above would be:</source>
          <target state="translated">위의 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2df66ad1e70181a147b06a0d20c75558216b98af" translate="yes" xml:space="preserve">
          <source>The output should be a &lt;a href=&quot;https://jsonapi.org/format/#document-structure&quot;&gt;JSON:API Document&lt;/a&gt; with the following additional restrictions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ab0c6bf981d7228ae87a74eeb932536510cc267" translate="yes" xml:space="preserve">
          <source>The parameter supplied to &lt;code&gt;partial&lt;/code&gt; can also be a path to a property containing a template name, e.g.:</source>
          <target state="translated">&lt;code&gt;partial&lt;/code&gt; 에 제공되는 매개 변수 는 템플릿 이름이 포함 된 속성의 경로 일 수도 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="efd37fb222c7e149dff6b49705240fe10a539217" translate="yes" xml:space="preserve">
          <source>The parameters can be referred to just like named parameters:</source>
          <target state="translated">매개 변수는 명명 된 매개 변수와 같이 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a227f12b3522d68730e7b36f0fc78aec0552a35a" translate="yes" xml:space="preserve">
          <source>The parameters can then be referred to by enumerating over the list:</source>
          <target state="translated">그런 다음 목록을 열거하여 매개 변수를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c73fdf7e2735901254b02ac94d2829f4059d49e9" translate="yes" xml:space="preserve">
          <source>The parent context of the helper</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42fc8fe2689da3394272f78c6f0c5ad6c77884c6" translate="yes" xml:space="preserve">
          <source>The parent engine instance.</source>
          <target state="translated">부모 엔진 인스턴스</target>
        </trans-unit>
        <trans-unit id="c4808789947bb1b66c38cf5e3bcb54bc1949343c" translate="yes" xml:space="preserve">
          <source>The passed in hash</source>
          <target state="translated">해시로 전달</target>
        </trans-unit>
        <trans-unit id="15aed930cca97a392fc79410e1ca9b8700445feb" translate="yes" xml:space="preserve">
          <source>The passed value</source>
          <target state="translated">전달 된 값</target>
        </trans-unit>
        <trans-unit id="91af4f77ef8ac669f3229c88e3020c84a9befbfd" translate="yes" xml:space="preserve">
          <source>The path to the 'from' side of the binding. Must be relative to obj or a global path.</source>
          <target state="translated">바인딩의 '보낸 사람'쪽의 경로입니다. obj 또는 전역 경로에 상대적이어야합니다.</target>
        </trans-unit>
        <trans-unit id="c9f763dddcc9c776652d4d1ccb6796bf300cbcd8" translate="yes" xml:space="preserve">
          <source>The path to the 'to' side of the binding. Must be relative to obj.</source>
          <target state="translated">바인딩의 'to'쪽에 대한 경로입니다. obj에 상대적이어야합니다.</target>
        </trans-unit>
        <trans-unit id="7b506261d52f3ffd5dc72f947e233a320f4ec200" translate="yes" xml:space="preserve">
          <source>The positional arguments are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3646b2c1a754bb29df7ef8518480d66f2cd86f09" translate="yes" xml:space="preserve">
          <source>The positional arguments to the helper</source>
          <target state="translated">도우미에 대한 위치 주장</target>
        </trans-unit>
        <trans-unit id="ecb5a8ced356dc6af28858715a012657c8c144f7" translate="yes" xml:space="preserve">
          <source>The positioning of &lt;code&gt;...attributes&lt;/code&gt; matters, with respect to the other attributes in the element it is applied to. Attributes that come &lt;em&gt;before&lt;/em&gt;&lt;code&gt;...attributes&lt;/code&gt; can be overridden, but attributes that come &lt;em&gt;after&lt;/em&gt; cannot:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b2ab9413880d940f49d12c1781a196be650c645" translate="yes" xml:space="preserve">
          <source>The post's comments would then be available in your template as &lt;code&gt;model.comments&lt;/code&gt;.</source>
          <target state="translated">그러면 게시물의 댓글을 템플릿에서 &lt;code&gt;model.comments&lt;/code&gt; 로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3bd0c52e66d7e75622548d76aa2f7b29dbedb829" translate="yes" xml:space="preserve">
          <source>The presence of a wrapping &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; means the application is contained in a block-layout element. When removed, and depending on if the application specifies a &lt;code&gt;rootElement&lt;/code&gt; in &lt;code&gt;config/environment.js&lt;/code&gt;, the application may no longer be contained in a block-layout element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8884e5a83dfe81deaf4fd5eb5cc8081003657de6" translate="yes" xml:space="preserve">
          <source>The primary purpose of this class is to create hooks that can be implemented by an adapter for various test frameworks.</source>
          <target state="translated">이 클래스의 기본 목적은 다양한 테스트 프레임 워크에 대한 어댑터로 구현할 수있는 후크를 작성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="fdbd93abc6b826746762fa62fd7c056d63d5bc62" translate="yes" xml:space="preserve">
          <source>The primary task here is to run any registered instance initializers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c9ce1bc115a79248bbaed83eaf438de9db2bc44" translate="yes" xml:space="preserve">
          <source>The primary way of interacting with a promise is through its &lt;code&gt;then&lt;/code&gt; method, which registers callbacks to receive either a promise's eventual value or the reason why the promise cannot be fulfilled.</source>
          <target state="translated">약속과 상호 작용하는 주요 방법은 &lt;code&gt;then&lt;/code&gt; 메소드를 사용하여 약속의 최종 가치 또는 약속을 이행 할 수없는 이유를 받도록 콜백을 등록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="59d128dbc75fda5894fb5dea6412a07651640a9e" translate="yes" xml:space="preserve">
          <source>The process of removing the feature flags from the resulting build output is handled by &lt;a href=&quot;https://github.com/thomasboyt/defeatureify&quot;&gt;&lt;code&gt;defeatureify&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">결과 빌드 출력에서 ​​기능 플래그를 제거하는 프로세스는 &lt;a href=&quot;https://github.com/thomasboyt/defeatureify&quot;&gt; &lt;code&gt;defeatureify&lt;/code&gt; &lt;/a&gt; 의해 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="291f652ab49a4eb74576b1a1bb6950593d5373e8" translate="yes" xml:space="preserve">
          <source>The promise whose fulfillment value is being proxied by this object.</source>
          <target state="translated">이행 목표가이 목표에 의해 프록시되고있는 약속.</target>
        </trans-unit>
        <trans-unit id="fef1a4bf9ee24be7227aafb8824116d835ff8551" translate="yes" xml:space="preserve">
          <source>The property &lt;code&gt;isExpanded&lt;/code&gt; keeps track if the user has expanded the body or not. The action &lt;code&gt;toggleBody()&lt;/code&gt; provides a way for the user to provide their setting. Both of them are used in the updated template below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc7758b607302e53a0da31210b9497cab24a954d" translate="yes" xml:space="preserve">
          <source>The property key to be notified about.</source>
          <target state="translated">통지 할 프로퍼티 키.</target>
        </trans-unit>
        <trans-unit id="11ef23efc9663b08bd99db214c95e5dc5d1cd5ea" translate="yes" xml:space="preserve">
          <source>The property key to retrieve</source>
          <target state="translated">검색 할 속성 키</target>
        </trans-unit>
        <trans-unit id="841185ba10823f766df7d71131c49e92c5b6ee9e" translate="yes" xml:space="preserve">
          <source>The property key to set</source>
          <target state="translated">설정할 속성 키</target>
        </trans-unit>
        <trans-unit id="37b81ff8e5f127d9996f4e45ec5e0deebeaf6ce8" translate="yes" xml:space="preserve">
          <source>The property path to set</source>
          <target state="translated">설정할 속성 경로</target>
        </trans-unit>
        <trans-unit id="09da5b0066d9f8254640ee13a778ca966360cf7e" translate="yes" xml:space="preserve">
          <source>The property pattern to expand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb6eddea047f11a03af1d5ee0f7e00977dfd358c" translate="yes" xml:space="preserve">
          <source>The property to retrieve</source>
          <target state="translated">검색 할 속성</target>
        </trans-unit>
        <trans-unit id="8611964c338d3f650ff1f5dffbfb19d6cfa92a6b" translate="yes" xml:space="preserve">
          <source>The property to set</source>
          <target state="translated">설정할 속성</target>
        </trans-unit>
        <trans-unit id="34a11ee7cca8e3277193e578a732c953c3658ceb" translate="yes" xml:space="preserve">
          <source>The property value or the defaultValue.</source>
          <target state="translated">특성 값 또는 defaultValue</target>
        </trans-unit>
        <trans-unit id="bb368158afde88e0d072275a3061843e6612c710" translate="yes" xml:space="preserve">
          <source>The property value or undefined.</source>
          <target state="translated">특성 값 또는 정의되지 않은.</target>
        </trans-unit>
        <trans-unit id="19f5671dd388019c1e7b9993c2e1610d92a167e3" translate="yes" xml:space="preserve">
          <source>The provided controller will be one resolved based on the name of this route.</source>
          <target state="translated">제공된 컨트롤러는이 경로의 이름에 따라 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="43f2ede5675faaa434d556fbe9e5fc7a71392d4b" translate="yes" xml:space="preserve">
          <source>The purpose of the Ember Instrumentation module is to provide efficient, general-purpose instrumentation for Ember.</source>
          <target state="translated">Ember Instrumentation 모듈의 목적은 Ember를위한 효율적인 범용 계측을 제공하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a46c1e5d7f1f40934068c5a223c77b5885a2af0d" translate="yes" xml:space="preserve">
          <source>The query params are defined per route/controller. They are not global to the app. For example, if a route &lt;code&gt;first-route&lt;/code&gt; has a query param &lt;code&gt;firstParam&lt;/code&gt; associated with it and we try to navigate to &lt;code&gt;first-route&lt;/code&gt; by using &lt;code&gt;&amp;lt;LinkTo /&amp;gt;&lt;/code&gt; component from a different route &lt;code&gt;second-route&lt;/code&gt;, like in the following handlebar template, the &lt;code&gt;firstParam&lt;/code&gt; will be omitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea6214654ceb2a10baaed0d0fd30ab6e2f224940" translate="yes" xml:space="preserve">
          <source>The raw JSON response data returned from an API request. This JSON should be in the API format expected by the serializer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d199ab9f01a62305bceb66a40e23c1ed5ada5fc" translate="yes" xml:space="preserve">
          <source>The raw JSON response data returned from an API request. This correlates to the value the promise returned by the adapter method that performed the request resolved to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="423ed4fcc7c2521ed4d18b49830304fce9133a79" translate="yes" xml:space="preserve">
          <source>The real value of &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_component&quot;&gt;&lt;code&gt;{{component}}&lt;/code&gt;&lt;/a&gt; comes from being able to dynamically pick the component being rendered. Below is an example of using the helper as a means of choosing different components for displaying different kinds of posts:</source>
          <target state="translated">&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_component&quot;&gt; &lt;code&gt;{{component}}&lt;/code&gt; &lt;/a&gt; 의 실제 가치는 렌더링 할 구성 요소를 동적으로 선택할 수 있다는 데 있습니다. 다음은 다른 종류의 게시물을 표시하기 위해 다른 구성 요소를 선택하는 수단으로 도우미를 사용하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="9fe576bc72572a7bfe2508f350461cc1200207f4" translate="yes" xml:space="preserve">
          <source>The real value of &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Ember.Templates.helpers/methods#component&quot;&gt;&lt;code&gt;{{component}}&lt;/code&gt;&lt;/a&gt; comes from being able to dynamically pick the component being rendered. Below is an example of using the helper as a means of choosing different components for displaying different kinds of posts:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efa336b434d1c206c6f998b9813612733c12b618" translate="yes" xml:space="preserve">
          <source>The reason for this change is to provide extra clarity to both users reading templates, and the compiler. Without explicitly referring to &lt;code&gt;this&lt;/code&gt;, a lot of handlebars statements are pretty ambiguous - for instance, &lt;code&gt;{{title}}&lt;/code&gt; could be a helper, a local variable, or a component property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccc3117b00b752ea73ddb44717909dc3bf36538e" translate="yes" xml:space="preserve">
          <source>The reasons being:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bee180750ce962548f091c93665de54feda848a" translate="yes" xml:space="preserve">
          <source>The received message (Tomster's message).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e8ff0e7bdc9ab64effb374f18a8c11d0b169173" translate="yes" xml:space="preserve">
          <source>The record instance</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e81c3e4c75a09b4c1f938081ce7c263e7f97700" translate="yes" xml:space="preserve">
          <source>The record instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94d0b948c12d2a0e9c041073d0e9e25cd67c32bc" translate="yes" xml:space="preserve">
          <source>The record passed as the first parameter is where you should stash state about the record if needed; you should never store data on the state object itself.</source>
          <target state="translated">첫 번째 매개 변수로 전달 된 레코드는 필요한 경우 레코드에 대해 상태를 숨겨야하는 위치입니다. 상태 객체 자체에 데이터를 저장해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="a9efd8591a090c2d6e10ed54968aee1551a9d896" translate="yes" xml:space="preserve">
          <source>The records color. Possible options: black, red, blue, green.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e847eeb0e7b887a5ab5a982823e0c83a639d123" translate="yes" xml:space="preserve">
          <source>The reduced value.</source>
          <target state="translated">감소 된 값.</target>
        </trans-unit>
        <trans-unit id="6e588a2c9e2c86b51f204f41c83c576f838e6536" translate="yes" xml:space="preserve">
          <source>The relationship descriptor argument is an object with the following properties.</source>
          <target state="translated">관계 설명자 인수는 다음과 같은 속성을 가진 개체입니다.</target>
        </trans-unit>
        <trans-unit id="f282f5d1355901b15ca747b3a5ab165ce7bc1457" translate="yes" xml:space="preserve">
          <source>The reload behavior is configured either via the passed &lt;code&gt;options&lt;/code&gt; hash or the result of the adapter's &lt;code&gt;shouldReloadRecord&lt;/code&gt;.</source>
          <target state="translated">재로드 동작은 전달 된 &lt;code&gt;options&lt;/code&gt; 해시 또는 어댑터의 &lt;code&gt;shouldReloadRecord&lt;/code&gt; 결과를 통해 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="1d16a00fa0a148bd51f60453ee3799ada1798f8f" translate="yes" xml:space="preserve">
          <source>The remaining sections in this guide will go into details about how to upgrade each individual feature. There's a lot to learn here, but remember, you can gradually adopt these features in existing apps. Everything you used to do will also work all the way through the rest of Ember 3, since Ember follows SemVer strictly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db525ceb99e1840957b4e97df93348fb6ea8f6f3" translate="yes" xml:space="preserve">
          <source>The request is made through the adapters' &lt;code&gt;queryRecord&lt;/code&gt;:</source>
          <target state="translated">요청은 어댑터의 &lt;code&gt;queryRecord&lt;/code&gt; 를 통해 이루어집니다 .</target>
        </trans-unit>
        <trans-unit id="07296fb90dfe4eee53f9a4a51505275a960def68" translate="yes" xml:space="preserve">
          <source>The request made to the server will look something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41441812d681fe9fb5a2b27e3821d50566b0e53f" translate="yes" xml:space="preserve">
          <source>The resolver instance of the application being debugged. This property will be injected on creation.</source>
          <target state="translated">디버깅중인 응용 프로그램의 리졸버 인스턴스입니다. 이 속성은 생성시 주입됩니다.</target>
        </trans-unit>
        <trans-unit id="71f68bc673958abd8537ab6aaa1394e3c0eb7589" translate="yes" xml:space="preserve">
          <source>The response will be fed to the associated serializer's &lt;code&gt;normalizeResponse&lt;/code&gt; method with the &lt;code&gt;requestType&lt;/code&gt; set to &lt;code&gt;createRecord&lt;/code&gt;, which should return a &lt;code&gt;JSON:API&lt;/code&gt; document.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ae30eae8ef20456dc7c396f6a4c74047a453aed" translate="yes" xml:space="preserve">
          <source>The response will be fed to the associated serializer's &lt;code&gt;normalizeResponse&lt;/code&gt; method with the &lt;code&gt;requestType&lt;/code&gt; set to &lt;code&gt;findAll&lt;/code&gt;, which should return a &lt;code&gt;JSON:API&lt;/code&gt; document.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5afd8a4b698c0288d9a43ee73c640dd6daa95d92" translate="yes" xml:space="preserve">
          <source>The response will be fed to the associated serializer's &lt;code&gt;normalizeResponse&lt;/code&gt; method with the &lt;code&gt;requestType&lt;/code&gt; set to &lt;code&gt;findBelongsTo&lt;/code&gt;, which should return a &lt;code&gt;JSON:API&lt;/code&gt; document.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7db8668cf5577137190be69d4bd25e2a1f50b3b1" translate="yes" xml:space="preserve">
          <source>The response will be fed to the associated serializer's &lt;code&gt;normalizeResponse&lt;/code&gt; method with the &lt;code&gt;requestType&lt;/code&gt; set to &lt;code&gt;findHasMany&lt;/code&gt;, which should return a &lt;code&gt;JSON:API&lt;/code&gt; document.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37eff849a8f536f5b43e8ee249dd94f6bb685d5b" translate="yes" xml:space="preserve">
          <source>The response will be fed to the associated serializer's &lt;code&gt;normalizeResponse&lt;/code&gt; method with the &lt;code&gt;requestType&lt;/code&gt; set to &lt;code&gt;findMany&lt;/code&gt;, which should return a &lt;code&gt;JSON:API&lt;/code&gt; document.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8a841f2c99e42951d522eb0c9519e93fd634319" translate="yes" xml:space="preserve">
          <source>The response will be fed to the associated serializer's &lt;code&gt;normalizeResponse&lt;/code&gt; method with the &lt;code&gt;requestType&lt;/code&gt; set to &lt;code&gt;findRecord&lt;/code&gt;, which should return a &lt;code&gt;JSON:API&lt;/code&gt; document.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d26eb7b4df5ff8cf265c998ef02749c7f68a44db" translate="yes" xml:space="preserve">
          <source>The response will be fed to the associated serializer's &lt;code&gt;normalizeResponse&lt;/code&gt; method with the &lt;code&gt;requestType&lt;/code&gt; set to &lt;code&gt;query&lt;/code&gt;, which should return a &lt;code&gt;JSON:API&lt;/code&gt; document.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98d23d4d60f1df3e96bd21f6ed47220d46e2abe6" translate="yes" xml:space="preserve">
          <source>The response will be fed to the associated serializer's &lt;code&gt;normalizeResponse&lt;/code&gt; method with the &lt;code&gt;requestType&lt;/code&gt; set to &lt;code&gt;queryRecord&lt;/code&gt;, which should return a &lt;code&gt;JSON:API&lt;/code&gt; document.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf3bacfa8c1c32de384bc5a56675d465899274cc" translate="yes" xml:space="preserve">
          <source>The response will be fed to the associated serializer's &lt;code&gt;normalizeResponse&lt;/code&gt; method with the &lt;code&gt;requestType&lt;/code&gt; set to &lt;code&gt;updateRecord&lt;/code&gt;, which should return a &lt;code&gt;JSON:API&lt;/code&gt; document.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6b9640e7b99b17fc81a06d8eee1b1da9fd34eff" translate="yes" xml:space="preserve">
          <source>The rest of this guide describes how to enhance your templates with event handlers, custom DOM properties and other kinds of custom JavaScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e00afb986323ba904efea3a982c45371e5a241e" translate="yes" xml:space="preserve">
          <source>The result will be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cb5a49233ae300cc034f89c2d81a2f89b2d6f87" translate="yes" xml:space="preserve">
          <source>The resulting HTML will look similar to this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2737a43de8d300c30b5d1d2f2763ebb462553cb1" translate="yes" xml:space="preserve">
          <source>The resulting HTML will looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="473773a9f0ae3a524717a98bf2bff757a44c072d" translate="yes" xml:space="preserve">
          <source>The resulting template render logic would be:</source>
          <target state="translated">결과 템플릿 렌더링 로직은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="64e24c1771c3d34bfc6f390eb86af08b179c758c" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;then&lt;/code&gt; is itself a promise. This second, 'downstream' promise is resolved with the return value of the first promise's fulfillment or rejection handler, or rejected if the handler throws an exception.</source>
          <target state="translated">&lt;code&gt;then&lt;/code&gt; 의 반환 가치 는 그 자체가 약속입니다. 이 두 번째 '다운 스트림'약속은 첫 번째 약속 이행 또는 거부 처리기의 반환 값으로 해결되거나 처리기가 예외를 throw하면 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="8d20833918be8aaca0fedabee7a9e43ef5581cff" translate="yes" xml:space="preserve">
          <source>The returned promise is fulfilled with a hash that has the same key names as the &lt;code&gt;promises&lt;/code&gt; object argument. If any of the values in the object are not promises, they will be copied over to the fulfilled object and marked with state 'fulfilled'.</source>
          <target state="translated">리턴 된 약속은 &lt;code&gt;promises&lt;/code&gt; 객체 인수 와 동일한 키 이름을 가진 해시로 이행됩니다 . 개체의 값 중 하나라도 약속이 아니면 이행 된 개체로 복사되고 상태가 '완료 됨'으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="8735a66c3c58858c4137385dfcf321c94c6cd283" translate="yes" xml:space="preserve">
          <source>The returned value is placed where the &lt;code&gt;{{}}&lt;/code&gt; is called. The above style is called &quot;inline&quot;. A second style of helper usage is called &quot;block&quot;. For example:</source>
          <target state="translated">리턴 된 값은 &lt;code&gt;{{}}&lt;/code&gt; 이 (가) 호출 되는 곳에 있습니다. 위의 스타일을 &quot;인라인&quot;이라고합니다. 도우미 사용의 두 번째 스타일을 &quot;차단&quot;이라고합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7e2e21dc44f676bf1bd060e0463dcf7e7e820d3a" translate="yes" xml:space="preserve">
          <source>The root DOM element of the Application. This can be specified as an element or a &lt;a href=&quot;http://api.jquery.com/category/selectors/&quot;&gt;jQuery-compatible selector string&lt;/a&gt;.</source>
          <target state="translated">응용 프로그램의 루트 DOM 요소 요소 또는 &lt;a href=&quot;http://api.jquery.com/category/selectors/&quot;&gt;jQuery 호환 선택기 문자열&lt;/a&gt; 로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eecac9c9d2d99121f7c3692d02975aa4bfbc76ff" translate="yes" xml:space="preserve">
          <source>The root object of the transform.</source>
          <target state="translated">변환의 루트 객체입니다.</target>
        </trans-unit>
        <trans-unit id="ff90f47a360da5112c540e62daf0f08e82b6235e" translate="yes" xml:space="preserve">
          <source>The route defined above will by default use the &lt;code&gt;blog-post.js&lt;/code&gt; route handler, the &lt;code&gt;blog-post.hbs&lt;/code&gt; template, and be referred to as &lt;code&gt;blog-post&lt;/code&gt; in any &lt;code&gt;&amp;lt;LinkTo /&amp;gt;&lt;/code&gt; components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bb1190332a9040ced62948350a42acdb8d03375" translate="yes" xml:space="preserve">
          <source>The route defined above will by default use the &lt;code&gt;blog-post.js&lt;/code&gt; route handler, the &lt;code&gt;blog-post.hbs&lt;/code&gt; template, and be referred to as &lt;code&gt;blog-post&lt;/code&gt; in any &lt;code&gt;{{link-to}}&lt;/code&gt; helpers.</source>
          <target state="translated">위에 정의 된 경로는 기본적으로 &lt;code&gt;blog-post.js&lt;/code&gt; 경로 핸들러, &lt;code&gt;blog-post.hbs&lt;/code&gt; 템플릿을 사용하며 &lt;code&gt;{{link-to}}&lt;/code&gt; 에서 &lt;code&gt;blog-post&lt;/code&gt; 이라고합니다. 헬퍼 합니다.</target>
        </trans-unit>
        <trans-unit id="1547b257edc696cf9d97b9973174fdd903d969e5" translate="yes" xml:space="preserve">
          <source>The route handler then typically does two things:</source>
          <target state="translated">그런 다음 경로 처리기는 일반적으로 두 가지 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="5a25dcb793cf10fb01f14c9659469d0ea089350c" translate="yes" xml:space="preserve">
          <source>The route that triggered the loading event</source>
          <target state="translated">로딩 이벤트를 트리거 한 경로</target>
        </trans-unit>
        <trans-unit id="40ef35919f724f529657ab517634c7e128df098d" translate="yes" xml:space="preserve">
          <source>The route will then set the return value from the &lt;code&gt;model&lt;/code&gt; hook as the &lt;code&gt;model&lt;/code&gt; property of the controller. You will then be able to access the controller's &lt;code&gt;model&lt;/code&gt; property in your template:</source>
          <target state="translated">그런 다음 경로는 &lt;code&gt;model&lt;/code&gt; 후크 의 반환 값을 컨트롤러 의 &lt;code&gt;model&lt;/code&gt; 속성으로 설정합니다. 그런 다음 템플릿에서 컨트롤러의 &lt;code&gt;model&lt;/code&gt; 속성에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d9055510d33898a55dfaabcdf80c77508cc19202" translate="yes" xml:space="preserve">
          <source>The router considers any object with a &lt;code&gt;then()&lt;/code&gt; method defined on it to be a promise.</source>
          <target state="translated">라우터는 정의 된 &lt;code&gt;then()&lt;/code&gt; 메소드가 있는 오브젝트를 약속으로 간주합니다.</target>
        </trans-unit>
        <trans-unit id="4c0f657b892b0b496ef8dcb14f5cd47b2928367f" translate="yes" xml:space="preserve">
          <source>The router is designed to solve those problems for you in the majority of common situations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20ae5f1ef171342e36f277fd6cd573513d476f32" translate="yes" xml:space="preserve">
          <source>The run loop API calls that &lt;em&gt;schedule&lt;/em&gt; work, i.e. &lt;a href=&quot;http://emberjs.com/api/classes/Ember.run.html#method_schedule&quot;&gt;&lt;code&gt;run.schedule&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://emberjs.com/api/classes/Ember.run.html#method_scheduleOnce&quot;&gt;&lt;code&gt;run.scheduleOnce&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://emberjs.com/api/classes/Ember.run.html#method_once&quot;&gt;&lt;code&gt;run.once&lt;/code&gt;&lt;/a&gt; have the property that they will approximate a run loop for you if one does not already exist. These automatically created run loops we call &lt;em&gt;autoruns&lt;/em&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://emberjs.com/api/classes/Ember.run.html#method_schedule&quot;&gt; &lt;code&gt;run.schedule&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;http://emberjs.com/api/classes/Ember.run.html#method_scheduleOnce&quot;&gt; &lt;code&gt;run.scheduleOnce&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;http://emberjs.com/api/classes/Ember.run.html#method_once&quot;&gt; &lt;code&gt;run.once&lt;/code&gt; &lt;/a&gt; 작업 을 &lt;em&gt;예약&lt;/em&gt; 하는 실행 루프 API 호출 은 실행 루프가없는 경우 사용자를 위해 실행 루프와 비슷한 속성을 갖습니다. 이 자동으로 생성 실행 루프 우리는 전화 &lt;em&gt;가 자동 실행을&lt;/em&gt;&lt;em&gt;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="9eae2dd384c4090fb2db27d7f5d0ce7c5baddd92" translate="yes" xml:space="preserve">
          <source>The run loop API calls that &lt;em&gt;schedule&lt;/em&gt; work, i.e. &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/@ember%2Frunloop/methods#schedule&quot;&gt;&lt;code&gt;run.schedule&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/@ember%2Frunloop/methods#scheduleOnce&quot;&gt;&lt;code&gt;run.scheduleOnce&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/@ember%2Frunloop/methods#once&quot;&gt;&lt;code&gt;run.once&lt;/code&gt;&lt;/a&gt; have the property that they will approximate a run loop for you if one does not already exist. These automatically created run loops we call &lt;em&gt;autoruns&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aab8740741c5d7b401984a17e059a4e0f2aa2178" translate="yes" xml:space="preserve">
          <source>The same applies to &lt;code&gt;belongsTo&lt;/code&gt; relationships:</source>
          <target state="translated">&lt;code&gt;belongsTo&lt;/code&gt; 관계 에도 동일하게 적용됩니다 :</target>
        </trans-unit>
        <trans-unit id="5d0929ac1141f7bbbbe00a7bde3540ce5998e9f7" translate="yes" xml:space="preserve">
          <source>The same philosophy that applies to changing text also applies to changing attributes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79f91cf22c7dca84c509c4f77da4cb434629965b" translate="yes" xml:space="preserve">
          <source>The same rules apply to arrays of primitives.</source>
          <target state="translated">프리미티브 배열에도 동일한 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="fd7b8fd9eac5480b43026cdd22b54a66a4559b81" translate="yes" xml:space="preserve">
          <source>The scroll happens on &lt;code&gt;didRender&lt;/code&gt;, where it will scroll the component's container to the element with the selected class name.</source>
          <target state="translated">스크롤은 &lt;code&gt;didRender&lt;/code&gt; 에서 발생하며 , 여기서 컴포넌트의 컨테이너를 선택된 클래스 이름을 가진 요소로 스크롤합니다.</target>
        </trans-unit>
        <trans-unit id="6f7c42a925e94c12e7ce7ceb33f4b3aeeeb9aafb" translate="yes" xml:space="preserve">
          <source>The second argument is an object of capabilities and boolean values indicating whether they are enabled or disabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c16e7ab42d40b7ba98b835fbc52225702d39a53" translate="yes" xml:space="preserve">
          <source>The second option is, you could run the &lt;a href=&quot;https://github.com/ember-codemods/ember-native-class-codemod&quot;&gt;&lt;code&gt;ember-native-class-codemod&lt;/code&gt;&lt;/a&gt; for all remaining components. This will turn them into components that import from &lt;code&gt;@ember/component&lt;/code&gt;, retaining all the same APIs that classic components have, but just represented in a Native Class syntax. Then, following a similar pattern as option number one, you could convert them to import from &lt;code&gt;@glimmer/component&lt;/code&gt; as you work. The advantage is that everyone gets used to working with Native Classes right away. The disadvantage is that the visual differences between a Native Class &lt;code&gt;@ember/component&lt;/code&gt; and a &lt;code&gt;@glimmer/component&lt;/code&gt; are subtle, and time could easily be lost to mistakes like trying to use &lt;code&gt;didInsertElement&lt;/code&gt; on the &lt;code&gt;@glimmer/component&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d4cba2063c093b6e0028f97cd82cdeaa6816998" translate="yes" xml:space="preserve">
          <source>The second parameter is the optional options hash. Available options are:</source>
          <target state="translated">두 번째 매개 변수는 선택적 옵션 해시입니다. 사용 가능한 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ae0e927bc564d192141ecf229fb991b5bb185f5a" translate="yes" xml:space="preserve">
          <source>The second way of doing the same thing is to link the two records together by updating the blogPost's &lt;code&gt;hasMany&lt;/code&gt; relationship as shown below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b090381a04a9e48621d42bb0bf53fa4cba4f1e4" translate="yes" xml:space="preserve">
          <source>The semantic version</source>
          <target state="translated">시맨틱 버전</target>
        </trans-unit>
        <trans-unit id="ae102e1db18c498864e8334458f4e9b2f24a1a5d" translate="yes" xml:space="preserve">
          <source>The sent message (Zoey's message).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f38bd2b1df14793a918cfb86c695e7bb1738385" translate="yes" xml:space="preserve">
          <source>The serialized value</source>
          <target state="translated">직렬화 된 값</target>
        </trans-unit>
        <trans-unit id="1441caa2180aa5deaa1d21c6c8bad5b37a9eaf47" translate="yes" xml:space="preserve">
          <source>The serializer properly converts the blog request payload into a blog post model object.</source>
          <target state="translated">직렬 변환기는 블로그 요청 페이로드를 블로그 게시물 모델 오브젝트로 올바르게 변환합니다.</target>
        </trans-unit>
        <trans-unit id="c14938d7774e56e262de01aeb6eb9013ddc6fc80" translate="yes" xml:space="preserve">
          <source>The setup is largely similar to how Ember works out-of-the-box. Normally, Ember will boot a default instance for your Application on &quot;DOM ready&quot;. However, you can customize this behavior by disabling &lt;code&gt;autoboot&lt;/code&gt;.</source>
          <target state="translated">설정은 Ember가 기본적으로 작동하는 방식과 거의 유사합니다. 일반적으로 Ember는 &quot;DOM ready&quot;에서 애플리케이션의 기본 인스턴스를 부팅합니다. 그러나 &lt;code&gt;autoboot&lt;/code&gt; 을 비활성화하여이 동작을 사용자 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5f60051ffdc26f8b94d2d2e7e288fed7d4415582" translate="yes" xml:space="preserve">
          <source>The simplest way to accomplish this is by using the &lt;code&gt;did-insert&lt;/code&gt; modifier from &lt;a href=&quot;https://github.com/emberjs/ember-render-modifiers&quot;&gt;@ember/render-modifiers&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b61b5d3588b52ce8149370f1531a251484abdca5" translate="yes" xml:space="preserve">
          <source>The simplest way to create a component is to create a template file in &lt;code&gt;app/templates/components&lt;/code&gt;. For example, if you name a template &lt;code&gt;app/templates/components/person-profile.hbs&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44bd33d4e5c5dbd425e1b01d352cce7c15b457b1" translate="yes" xml:space="preserve">
          <source>The sorted array.</source>
          <target state="translated">정렬 된 배열.</target>
        </trans-unit>
        <trans-unit id="cb8a199ba2e4d0c7c99df9a4c891ca5cc466be3d" translate="yes" xml:space="preserve">
          <source>The starting index</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bbcdf9dc99641ff8f9df51339a76d30dd24a554" translate="yes" xml:space="preserve">
          <source>The starting index in the array that did change.</source>
          <target state="translated">변경된 배열의 시작 색인입니다.</target>
        </trans-unit>
        <trans-unit id="edab6dfda8b0a675cd3b277a658515192ee54ac2" translate="yes" xml:space="preserve">
          <source>The starting index in the array that will change.</source>
          <target state="translated">변경 될 배열의 시작 색인입니다.</target>
        </trans-unit>
        <trans-unit id="d500b9e13d11202509045e908764c952698f3004" translate="yes" xml:space="preserve">
          <source>The store can be customized by extending the service in the following manner:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="565a8bbec3976cbbd11685d7a0db28bb110f442f" translate="yes" xml:space="preserve">
          <source>The store contains all of the data for records loaded from the server. It is also responsible for creating instances of &lt;code&gt;DS.Model&lt;/code&gt; that wrap the individual data for a record, so that they can be bound to in your Handlebars templates.</source>
          <target state="translated">저장소에는 서버에서로드 된 레코드에 대한 모든 데이터가 포함됩니다. 또한 핸들 바 템플릿에 바인딩 될 수 있도록 레코드의 개별 데이터를 랩핑하는 &lt;code&gt;DS.Model&lt;/code&gt; 인스턴스를 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="bd1641cbe5dc00ca11bff91f0a9e4a4c7d1b52e6" translate="yes" xml:space="preserve">
          <source>The store object is available in controllers and routes using &lt;code&gt;this.get('store')&lt;/code&gt;.</source>
          <target state="translated">상점 객체는 &lt;code&gt;this.get('store')&lt;/code&gt; 를 사용하여 컨트롤러 및 경로에서 사용할 수 있습니다. 합니다.</target>
        </trans-unit>
        <trans-unit id="9048551c723d7fb82c9bc4e4ab0fc166fb192e7b" translate="yes" xml:space="preserve">
          <source>The store object is available in controllers and routes using &lt;code&gt;this.store&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9b1269778250371106783075e2d9ba12e8b0581" translate="yes" xml:space="preserve">
          <source>The store provides multiple ways to create new record objects. They have some subtle differences in their use which are detailed below:</source>
          <target state="translated">상점은 새 레코드 오브젝트를 작성하는 여러 가지 방법을 제공합니다. 사용 방법에 미묘한 차이점이 있으며 아래에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5bc4ac84dbb157b99050486d2a507091b7f27ed0" translate="yes" xml:space="preserve">
          <source>The store service contains all of the data for records loaded from the server. It is also responsible for creating instances of &lt;code&gt;Model&lt;/code&gt; that wrap the individual data for a record, so that they can be bound to in your Handlebars templates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39347f24af1bfcefbc0652b641ac4e755431a795" translate="yes" xml:space="preserve">
          <source>The store service that initiated the request being normalized</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2c599c05627277afc6c6ecc983a68b24eda3344" translate="yes" xml:space="preserve">
          <source>The store then takes that JSON, initializes the record with the JSON data, and resolves the promise returned to your application with the newly-loaded record.</source>
          <target state="translated">그런 다음 상점은 해당 JSON을 가져 와서 JSON 데이터로 레코드를 초기화하고 새로로드 된 레코드로 애플리케이션에 리턴 된 약속을 해결합니다.</target>
        </trans-unit>
        <trans-unit id="41b68f114ba57e357ad03f70aa549d7262c8caa5" translate="yes" xml:space="preserve">
          <source>The store will automatically cache records for you. If a record had already been loaded, asking for it a second time will always return the same object instance. This minimizes the number of round-trips to the server, and allows your application to render its UI to the user as fast as possible.</source>
          <target state="translated">상점은 자동으로 레코드를 캐시합니다. 레코드가 이미로드 된 경우 다시 요청하면 항상 동일한 객체 인스턴스가 반환됩니다. 이를 통해 서버로의 왕복 횟수를 최소화하고 응용 프로그램에서 UI를 사용자에게 최대한 빨리 렌더링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01207237cd4ccf3b900d21e60db5b725e70f8924" translate="yes" xml:space="preserve">
          <source>The store will call &lt;code&gt;findMany&lt;/code&gt; instead of multiple &lt;code&gt;findRecord&lt;/code&gt; requests to find multiple records at once if coalesceFindRequests is true.</source>
          <target state="translated">coalesceFindRequests가 true 인 경우 상점은 여러 개의 &lt;code&gt;findRecord&lt;/code&gt; 요청 대신 &lt;code&gt;findMany&lt;/code&gt; 를 호출 하여 한 번에 여러 레코드를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="d2f69dc65e213b2fb8cdb1b7cbc4e005ab648a25" translate="yes" xml:space="preserve">
          <source>The store's &lt;code&gt;push()&lt;/code&gt; method is a low level API which accepts a JSON API document with a few important differences from the JSON API document that the JSONAPISerializer accepts. The type name in the JSON API document must match the type name of the model exactly (In the example above the type is &lt;code&gt;album&lt;/code&gt; because the model is defined in &lt;code&gt;app/models/album.js&lt;/code&gt;). Attributes and relationship names must match the casing of the properties defined on the Model class.</source>
          <target state="translated">상점의 &lt;code&gt;push()&lt;/code&gt; 메소드는 JSONAPISerializer가 허용하는 JSON API 문서와 몇 가지 중요한 차이점이있는 JSON API 문서를 승인하는 저수준 API입니다. JSON API 문서의 유형 이름은 모델의 유형 이름과 정확히 일치해야합니다 ( 모델이 &lt;code&gt;app/models/album.js&lt;/code&gt; 에 정의되어 있으므로 위의 예에서 유형은 &lt;code&gt;album&lt;/code&gt; 임) ). 속성 및 관계 이름은 Model 클래스에 정의 된 속성의 케이스와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="3c796594a6b93db637ae2b09fcb292d565c316db" translate="yes" xml:space="preserve">
          <source>The store's &lt;code&gt;push()&lt;/code&gt; method is a low level API which accepts a JSON API document with a few important differences from the JSON:API document that the JSONAPISerializer accepts. The type name in the JSON API document must match the type name of the model exactly (In the example above the type is &lt;code&gt;album&lt;/code&gt; because the model is defined in &lt;code&gt;app/models/album.js&lt;/code&gt;). Attributes and relationship names must match the casing of the properties defined on the Model class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba2337f1b869281822cbec365330fc6ed3a87eb9" translate="yes" xml:space="preserve">
          <source>The string to camelize.</source>
          <target state="translated">camelize 할 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="e2b9d608f0fe83dbf1e7d9c07afcec863203911e" translate="yes" xml:space="preserve">
          <source>The string to capitalize.</source>
          <target state="translated">대문자로 지정할 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="6562d656544896269e6510021a24eb0fe047f8cd" translate="yes" xml:space="preserve">
          <source>The string to dasherize.</source>
          <target state="translated">대시 할 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="827deb88bf3cf7b323e93ba14d05290d5e8a6b48" translate="yes" xml:space="preserve">
          <source>The string to decamelize.</source>
          <target state="translated">디카 멜화할 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="8aef10dc78a1b6b0b047d67f1b41e8c2eacf1322" translate="yes" xml:space="preserve">
          <source>The string to format</source>
          <target state="translated">형식화 할 문자열</target>
        </trans-unit>
        <trans-unit id="2b0b9ffa844d16267c8115855979ed48b6d4bc64" translate="yes" xml:space="preserve">
          <source>The string to format.</source>
          <target state="translated">형식화 할 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="8bb5d2b6d14eab5fb11c8b4cd7eded396880eafd" translate="yes" xml:space="preserve">
          <source>The string to split</source>
          <target state="translated">분할 할 문자열</target>
        </trans-unit>
        <trans-unit id="504f1fdddf0d3ae9e6968c1488e9aaed471044e1" translate="yes" xml:space="preserve">
          <source>The string to underscore.</source>
          <target state="translated">밑줄을 표시 할 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="6b2ca2bba7cfc3b3d4f9eb164041ee4b3f478da7" translate="yes" xml:space="preserve">
          <source>The string values provided for the template name, and controller will eventually pass through to the resolver for lookup. See Ember.Resolver for how these are mapped to JavaScript objects in your application. The template to render into needs to be related to either the current route or one of its ancestors.</source>
          <target state="translated">템플릿 이름 및 컨트롤러에 제공된 문자열 값은 결국 조회를 위해 리졸버로 전달됩니다. 애플리케이션에서 JavaScript 객체에 매핑되는 방법은 Ember.Resolver를 참조하십시오. 렌더링 할 템플릿은 현재 경로 또는 조상 중 하나와 관련이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="ba5818842ce855fe275a24b3307838b7fe2c0695" translate="yes" xml:space="preserve">
          <source>The string values provided for the template name, and controller will eventually pass through to the resolver for lookup. See Resolver for how these are mapped to JavaScript objects in your application. The template to render into needs to be related to either the current route or one of its ancestors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e044bf34a7e8afe296c75937fe0122a79c5e8ce1" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;{{@initial}}&lt;/code&gt; means that the contents inside the &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; tag are &lt;em&gt;dynamic&lt;/em&gt; and will be specified by the &lt;code&gt;&amp;lt;Avatar&amp;gt;&lt;/code&gt; tag. Likewise, the &lt;code&gt;{{@title}}&lt;/code&gt; syntax means that the contents of the &lt;code&gt;title&lt;/code&gt; attribute are dynamic and will be specified in the same way. We can now replace the received message avatar by using the &lt;code&gt;&amp;lt;Avatar&amp;gt;&lt;/code&gt; tag and providing it with some arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40e5aa73406cd7ed8554338b6d4c3b179b9fb02c" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;{{substring @username 0 1}}&lt;/code&gt; is a little hard to read. We see some numbers at the end but can't tell what exactly they mean. We can use &lt;em&gt;named arguments&lt;/em&gt; to make the &lt;code&gt;substring&lt;/code&gt; helper easier to read.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c15310baae72447d4757eb2e55e534acbbc316b" translate="yes" xml:space="preserve">
          <source>The target object to invoke</source>
          <target state="translated">호출 할 대상 객체</target>
        </trans-unit>
        <trans-unit id="de10ba709439df9674dd354fe1c515eac06ba807" translate="yes" xml:space="preserve">
          <source>The target object to use</source>
          <target state="translated">사용할 대상 객체</target>
        </trans-unit>
        <trans-unit id="54d029f20e1dadec96b103ccc865dfcca39add60" translate="yes" xml:space="preserve">
          <source>The target of the method to invoke.</source>
          <target state="translated">호출 할 메소드의 대상입니다.</target>
        </trans-unit>
        <trans-unit id="e2ed41e561ef82bfe2b3a4d933412915eae9db07" translate="yes" xml:space="preserve">
          <source>The target of the subscription</source>
          <target state="translated">구독 대상</target>
        </trans-unit>
        <trans-unit id="4ceffd13443beb5575ab1e4483fbd512664207b4" translate="yes" xml:space="preserve">
          <source>The template contains an &lt;a href=&quot;https://guides.emberjs.com/templates/input-helpers&quot;&gt;&lt;code&gt;{{input}}&lt;/code&gt;&lt;/a&gt; helper that renders as a text field, in which the user can type a pattern to filter the list of cities used in a search. The &lt;code&gt;value&lt;/code&gt; property of the &lt;code&gt;input&lt;/code&gt; will be kept in sync with the &lt;code&gt;value&lt;/code&gt; property in the component.</source>
          <target state="translated">템플릿에는 텍스트 필드로 렌더링 되는 &lt;a href=&quot;https://guides.emberjs.com/templates/input-helpers&quot;&gt; &lt;code&gt;{{input}}&lt;/code&gt; &lt;/a&gt; 도우미가 포함되어 있으며, 사용자는 검색에 사용 된 도시 목록을 필터링하기 위해 패턴을 입력 할 수 있습니다. &lt;code&gt;value&lt;/code&gt; 의 속성 &lt;code&gt;input&lt;/code&gt; 와 동기화를 유지한다 &lt;code&gt;value&lt;/code&gt; 컴포넌트의 속성.</target>
        </trans-unit>
        <trans-unit id="d74f4833f85af93d253619500c9b82c2db0b7e23" translate="yes" xml:space="preserve">
          <source>The template inside of the &lt;code&gt;{{#each-in}}&lt;/code&gt; block is repeated once for each key in the passed object. The first block parameter (&lt;code&gt;category&lt;/code&gt; in the above example) is the key for this iteration, while the second block parameter (&lt;code&gt;products&lt;/code&gt;) is the actual value of that key.</source>
          <target state="translated">전달 된 객체의 각 키에 &lt;code&gt;{{#each-in}}&lt;/code&gt; 블록 내부의 템플릿 이 한 번 반복됩니다. 첫 번째 블록 매개 변수 ( 위의 예에서 &lt;code&gt;category&lt;/code&gt; )가이 반복의 핵심이며 두 번째 블록 매개 변수 ( &lt;code&gt;products&lt;/code&gt; )는 해당 키의 실제 값입니다.</target>
        </trans-unit>
        <trans-unit id="722bc70d44379d1b5cfee1e8ad82e651eaf53bd8" translate="yes" xml:space="preserve">
          <source>The template inside of the &lt;code&gt;{{#each}}&lt;/code&gt; block will be repeated once for each item in the array, with the each item set to the &lt;code&gt;person&lt;/code&gt; block param.</source>
          <target state="translated">&lt;code&gt;{{#each}}&lt;/code&gt; 블록 내부의 템플릿 은 배열의 각 항목마다 한 번씩 반복되며 각 항목은 &lt;code&gt;person&lt;/code&gt; 블록 매개 변수로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="e14b256b8bf613a58dde6fd95e9abcd1338adcd7" translate="yes" xml:space="preserve">
          <source>The test locates the results of the search by finding elements with a class of &lt;code&gt;listing&lt;/code&gt;, which we gave to our &lt;code&gt;rental-listing&lt;/code&gt; component in the &lt;a href=&quot;../simple-component&quot;&gt;&quot;Building a Simple Component&quot;&lt;/a&gt; section of the tutorial.</source>
          <target state="translated">이 테스트의 클래스 요소를 찾아 검색 결과를 찾아 &lt;code&gt;listing&lt;/code&gt; 우리가 우리에게 준, &lt;code&gt;rental-listing&lt;/code&gt; 에서 구성 요소 &lt;a href=&quot;../simple-component&quot;&gt;&quot;건물 간단한 구성 요소&quot;&lt;/a&gt; 자습서의 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2a64607c214ef37d87d8ad67e76908fa5af07f02" translate="yes" xml:space="preserve">
          <source>The test verifies that after filling in the search input with &quot;Seattle&quot;, the rental list reduces from 3 to 1, and the item displayed shows &quot;Seattle&quot; as the location.</source>
          <target state="translated">테스트에서는 &quot;시애틀&quot;로 검색 입력을 채운 후 대여 목록이 3에서 1로 감소하고 표시되는 항목에 &quot;시애틀&quot;이 위치로 표시되는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="89d72c69007c893df81d99979fa6b2e66b8f23a3" translate="yes" xml:space="preserve">
          <source>The test would call the &lt;code&gt;calc&lt;/code&gt; method and assert it gets back the correct value.</source>
          <target state="translated">테스트는 &lt;code&gt;calc&lt;/code&gt; 메소드를 호출 하고 올바른 값을 얻도록합니다.</target>
        </trans-unit>
        <trans-unit id="9e4b46dc9e309d54bfec19901f419a3f701c4206" translate="yes" xml:space="preserve">
          <source>The third context of the &lt;code&gt;{{action}}&lt;/code&gt; helper can be called &quot;element space&quot;. For example:</source>
          <target state="translated">&lt;code&gt;{{action}}&lt;/code&gt; 헬퍼 의 세 번째 컨텍스트를 &quot;요소 공간&quot;이라고합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="37d7a55f997fe0c18460ae452e7f09adc66aa219" translate="yes" xml:space="preserve">
          <source>The third form of helper usage is &lt;strong&gt;block invocation&lt;/strong&gt;. Use block helpers to render only part of a template. Block invocation of a helper can be recognized by the &lt;code&gt;#&lt;/code&gt; before the helper name, and the closing &lt;code&gt;{{/&lt;/code&gt; double curly brace at the end of the invocation.</source>
          <target state="translated">도우미 사용의 세 번째 형태는 &lt;strong&gt;블록 호출&lt;/strong&gt; 입니다. 블록 도우미를 사용하여 템플릿의 일부만 렌더링합니다. 헬퍼의 블록 호출은 헬퍼 이름 앞 의 &lt;code&gt;#&lt;/code&gt; 로 , 그리고 호출의 끝에 닫는 &lt;code&gt;{{/&lt;/code&gt; 이중 중괄호 로 인식 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="944b09433ee6559023c1be9d8df4b25f0ac83680" translate="yes" xml:space="preserve">
          <source>The third parameter is a function, which can be used to nest routes. Nested routes, by default, will have the parent route tree's route name and path prepended to it's own.</source>
          <target state="translated">세 번째 매개 변수는 라우트를 중첩하는 데 사용할 수있는 함수입니다. 기본적으로 중첩 된 경로는 상위 경로 트리의 경로 이름과 경로 앞에 붙습니다.</target>
        </trans-unit>
        <trans-unit id="584e0d556960d1ef1c03be6a0d0c76cb94980333" translate="yes" xml:space="preserve">
          <source>The top-level index route is analogous to &lt;code&gt;index.html&lt;/code&gt;. For example, when someone visits &lt;code&gt;https://some-ember-app.com&lt;/code&gt;, the contents of the &lt;code&gt;template/index.hbs&lt;/code&gt; file will be rendered. There is no need to add an entry &lt;code&gt;this.route('index', { path: '/' });&lt;/code&gt; in &lt;code&gt;app/router.js&lt;/code&gt; file. The &lt;code&gt;index&lt;/code&gt; route is implicitly included in order to help reduce verbose declarations in the &lt;code&gt;app/router.js&lt;/code&gt;. The &lt;code&gt;app/router.js&lt;/code&gt; file could be empty, and the &lt;code&gt;index&lt;/code&gt; would still be shown:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e623839ca6c4caf8cd5f058a6f44779bb9b01076" translate="yes" xml:space="preserve">
          <source>The two icons to the left of the search field will expand or collapse all components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebcf7d15355b9ffa9191ba8a8a24f0fb06198de5" translate="yes" xml:space="preserve">
          <source>The type (or modelName) of record being created</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="311168c82ceeb94e5dfa9eb1a7893961d2596cad" translate="yes" xml:space="preserve">
          <source>The type of request the Adapter had been asked to perform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="147526a2a9e7840b61e7afb24045b79c209cc65d" translate="yes" xml:space="preserve">
          <source>The type. e.g. &quot;model&quot;, &quot;controller&quot;, &quot;route&quot;.</source>
          <target state="translated">유형. &quot;모델&quot;, &quot;컨트롤러&quot;, &quot;경로&quot;.</target>
        </trans-unit>
        <trans-unit id="4f039fe10b59dfaf945a628a511ceac52bce6aa9" translate="yes" xml:space="preserve">
          <source>The updateRecord method is expected to return a promise that will resolve with the serialized record. This allows the backend to inform the Ember Data store the current state of this record after the update. If it is not possible to return a serialized record the updateRecord promise can also resolve with &lt;code&gt;undefined&lt;/code&gt; and the Ember Data store will assume all of the updates were successfully applied on the backend.</source>
          <target state="translated">updateRecord 메소드는 직렬화 된 레코드로 해결할 약속을 리턴 할 것으로 예상됩니다. 이를 통해 업데이트 후 백엔드가 Ember 데이터 저장소에이 레코드의 현재 상태를 알릴 수 있습니다. 직렬화 된 레코드를 반환 할 수없는 경우 updateRecord 약속은 &lt;code&gt;undefined&lt;/code&gt; 해결할 수도 있으며 Ember 데이터 저장소는 모든 업데이트가 백엔드에 성공적으로 적용된 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="924807e0bd496c91f4a1657c376c80b756e72ccc" translate="yes" xml:space="preserve">
          <source>The use cases for proxies are generally cases where some data is very dynamic, and its not possible to know ahead of time how to create a class that is decorated. For instance, &lt;a href=&quot;https://github.com/hjdivad/ember-m3&quot;&gt;&lt;code&gt;ember-m3&lt;/code&gt;&lt;/a&gt; is an addon that allows Ember Data to work with dynamically generated models instead of models defined using &lt;code&gt;@attr&lt;/code&gt;, &lt;code&gt;@hasMany&lt;/code&gt;, and &lt;code&gt;@belongsTo&lt;/code&gt;. This cuts back on code shipped to the browser, but it means that the models have to &lt;em&gt;dynamically&lt;/em&gt; watch and update values. A proxy allows all accesses and updates to be intercepted, so &lt;code&gt;m3&lt;/code&gt; can do what it needs to do without predefined classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8b2d5a0ec1efed52d5fc609cabe5e05b7bb7070" translate="yes" xml:space="preserve">
          <source>The user can make comments on a blog post</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ab6120f5189495dcad2408ccee06142b8221963" translate="yes" xml:space="preserve">
          <source>The user can read, update, and delete blog posts (possibly in a batch operation)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6e5d00523cade2eb22b6f2fc4216929c8429edf" translate="yes" xml:space="preserve">
          <source>The user can share a blog post</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51de670ab53c3db59ec8a0666e66364d58ad96c2" translate="yes" xml:space="preserve">
          <source>The user changes the URL manually, such as by clicking the back button or by editing the address bar.</source>
          <target state="translated">사용자는 뒤로 단추를 클릭하거나 주소 표시 줄을 편집하여 URL을 수동으로 변경합니다.</target>
        </trans-unit>
        <trans-unit id="5351613497c3004771812d248a543cbdc66656b3" translate="yes" xml:space="preserve">
          <source>The user clicks a link within the app.</source>
          <target state="translated">사용자는 앱 내에서 링크를 클릭합니다.</target>
        </trans-unit>
        <trans-unit id="9921d7f5710f25509ee88606a85dee5d311bd63d" translate="yes" xml:space="preserve">
          <source>The user loads the app for the first time.</source>
          <target state="translated">사용자가 처음으로 앱을로드합니다.</target>
        </trans-unit>
        <trans-unit id="09abc237b50bd030b6153ce55b7e4c7f70090c0d" translate="yes" xml:space="preserve">
          <source>The user receives feedback if there is an error</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08136d6a7fb502f1305da2cc091889097a7120f3" translate="yes" xml:space="preserve">
          <source>The user should be authorized to take actions on a blog</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74e880123198891577360a791645732bdf32b1e5" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;isWide&lt;/code&gt; comes from our component's JavaScript file, in this case &lt;code&gt;rental-listing.js&lt;/code&gt;. Since we want the image to be smaller at first, we will set the property to start as &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;isWide&lt;/code&gt; 의 가치는 컴포넌트의 JavaScript 파일 (이 경우 &lt;code&gt;rental-listing.js&lt;/code&gt; ) 에서 비롯됩니다 . 처음에는 이미지를 작게 만들고 싶기 때문에 속성을 &lt;code&gt;false&lt;/code&gt; 로 시작하도록 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="d23a5a16f505fa5c0bc4c22ed6862d2f7cf30588" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;my-controller-name&lt;/code&gt; must match the name of the Route that renders it. So a Route named &lt;code&gt;blog-post&lt;/code&gt; would have a matching Controller named &lt;code&gt;blog-post&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;my-controller-name&lt;/code&gt; 의 값은이 를 렌더링하는 Route의 이름과 일치해야합니다. 따라서 &lt;code&gt;blog-post&lt;/code&gt; 라는 경로는 blog-post 라는 이름의 일치하는 컨트롤러를 갖 &lt;code&gt;blog-post&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd1f47d5724e57f16f4762fa4b7b499056b744cd" translate="yes" xml:space="preserve">
          <source>The value to be returned.</source>
          <target state="translated">반환 할 값입니다.</target>
        </trans-unit>
        <trans-unit id="04a60bcf4638b39535e993d6cbd42eae6ce46172" translate="yes" xml:space="preserve">
          <source>The value to return if the property value is undefined</source>
          <target state="translated">특성 값이 정의되지 않은 경우 리턴 할 값</target>
        </trans-unit>
        <trans-unit id="9571ab424dffa7c5f376c7c97c04d87fb698a99b" translate="yes" xml:space="preserve">
          <source>The value to set</source>
          <target state="translated">설정할 값</target>
        </trans-unit>
        <trans-unit id="cc012a4e9d5bd52a06928e9abc8926ab3ec9e9e2" translate="yes" xml:space="preserve">
          <source>The value to set or `null`.</source>
          <target state="translated">설정할 값 또는 'null'입니다.</target>
        </trans-unit>
        <trans-unit id="5900ce9ec83abfc5697f80f63b4c885c80e4800b" translate="yes" xml:space="preserve">
          <source>The values of any queryParams on this route.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0db7cf4c23f0cf4a43bbaf5f2d74fac5aafaffd4" translate="yes" xml:space="preserve">
          <source>The values of the route's parameters. These are the same params that are received as arguments to the route's &lt;code&gt;model&lt;/code&gt; hook. Contains only the parameters valid for this route, if any (params for parent or child routes are not merged).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59f7270b74d7554717d99b5200acac3d49b140c1" translate="yes" xml:space="preserve">
          <source>The values of the route's parameters. These are the same params that are received as arguments to the route's model hook. Contains only the parameters valid for this route, if any (params for parent or child routes are not merged).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43104aed3631db414614a2232d0cfd8f1a7bdd2c" translate="yes" xml:space="preserve">
          <source>The version of capabilities that are being used</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acbfee1e0879c64f080cc1dfce56c65619ec7c00" translate="yes" xml:space="preserve">
          <source>The way to do this in Ember is by using the &lt;code&gt;{{yield}}&lt;/code&gt; syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85b0483616a023e3131bcbeb48e37ef7796a8a2a" translate="yes" xml:space="preserve">
          <source>Their structure is pretty straightforward and similar, so we can use arguments and conditionals to handle the differences in content between them (see the previous chapters for details on how to do this).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85f8e47c70845d61b42b97a3b17772fc4c8e6e69" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;Grab a coat, it's chilly!&lt;/code&gt; will be rendered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66ed92b099921e39838f582833afc6fe6e27756e" translate="yes" xml:space="preserve">
          <source>Then it checks for the presence of a type-specific instance method of the form &lt;code&gt;resolve[Type]&lt;/code&gt; and calls it if it exists. For example if it was resolving 'template:post', it would call the &lt;code&gt;resolveTemplate&lt;/code&gt; method.</source>
          <target state="translated">그런 다음 &lt;code&gt;resolve[Type]&lt;/code&gt; 인스턴스 메소드가 있는지 확인하고 존재하는 경우이를 호출합니다. 예를 들어 'template : post'를 해결하는 경우 &lt;code&gt;resolveTemplate&lt;/code&gt; 을 호출합니다. 메소드를 .</target>
        </trans-unit>
        <trans-unit id="b84d5d369559d8464394c4cd54dfca6e70c52f87" translate="yes" xml:space="preserve">
          <source>Then it will display:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4534dee611a1e10715ed11ebd2eb28c7450c7ec8" translate="yes" xml:space="preserve">
          <source>Then make sure the &quot;Display the Ember favicon when a site runs Ember.js&quot; checkbox is checked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="124bbec613e0740a2add94968e72e7ab45cd285a" translate="yes" xml:space="preserve">
          <source>Then make sure the &quot;Display the Tomster icon when a site runs Ember.js&quot; checkbox is checked.</source>
          <target state="translated">그런 다음 &quot;사이트에서 Ember.js를 실행할 때 Tomster 아이콘 표시&quot;확인란이 선택되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="2add5961065ee48f1cfd0ab8d647d7e7158664db" translate="yes" xml:space="preserve">
          <source>Then our &lt;code&gt;SystemPreferencesEditor&lt;/code&gt; template passes its local &lt;code&gt;deleteUser&lt;/code&gt; action into the &lt;code&gt;UserProfile&lt;/code&gt; as that component's &lt;code&gt;deleteCurrentUser&lt;/code&gt; argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0963cd90e4c018ee024de78af4821e7b2fb93a50" translate="yes" xml:space="preserve">
          <source>Then our &lt;code&gt;system-preferences-editor&lt;/code&gt; template passes its local &lt;code&gt;deleteUser&lt;/code&gt; action into the &lt;code&gt;user-profile&lt;/code&gt; as that component's &lt;code&gt;deleteCurrentUser&lt;/code&gt; property.</source>
          <target state="translated">그런 다음 &lt;code&gt;system-preferences-editor&lt;/code&gt; 템플릿은 해당 로컬 &lt;code&gt;deleteUser&lt;/code&gt; 작업을 해당 구성 요소의 &lt;code&gt;deleteCurrentUser&lt;/code&gt; 로 &lt;code&gt;user-profile&lt;/code&gt; 전달합니다. 속성 합니다.</target>
        </trans-unit>
        <trans-unit id="3eaf3fd0a30bffe671cfe2d6231cbed038099e8f" translate="yes" xml:space="preserve">
          <source>Then pass through the applicable fields to your &lt;code&gt;findRecord&lt;/code&gt; request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b94c945aa553087e491135e87e7caa5e6c5b7883" translate="yes" xml:space="preserve">
          <source>Then you can use the &lt;code&gt;surge&lt;/code&gt; command to deploy your application. Note you will also need to rename index.html to 200.html to enable Ember's client-side routing.</source>
          <target state="translated">그런 다음 &lt;code&gt;surge&lt;/code&gt; 사용할 수 있습니다 명령을 하여 응용 프로그램을 배포 할 수 있습니다. Ember의 클라이언트 측 라우팅을 활성화하려면 index.html의 이름을 200.html로 바꿔야합니다.</target>
        </trans-unit>
        <trans-unit id="0d901353d4e943cc8e0760df4cb86a77339d4096" translate="yes" xml:space="preserve">
          <source>Then you can use the attributes in the component exactly as if they had been passed in like &lt;code&gt;{{blog-post title=post.title body=post.body}}&lt;/code&gt;.</source>
          <target state="translated">그러면 &lt;code&gt;{{blog-post title=post.title body=post.body}}&lt;/code&gt; 와 같이 전달 된 것처럼 구성 요소의 속성을 정확하게 사용할 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="df8e16196d8c26785bdaea771ed92ec9cf988d46" translate="yes" xml:space="preserve">
          <source>Then you could test that the relationship by looking it up on the &lt;code&gt;user&lt;/code&gt; model which it is part of.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c92853aa810fa69277504403a7af77504ee617b3" translate="yes" xml:space="preserve">
          <source>Then you could test that the relationship is wired up correctly with this test.</source>
          <target state="translated">그런 다음이 테스트와의 관계가 올바르게 연결되었는지 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c62800783a829bacf57534374af6b3071a57058b" translate="yes" xml:space="preserve">
          <source>Then, calling &lt;a href=&quot;https://api.emberjs.com/ember-data/release/classes/Store/methods#queryRecord&quot;&gt;&lt;code&gt;store.queryRecord()&lt;/code&gt;&lt;/a&gt; will retrieve that object from the server:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3864d8c7c138de0f81c4de21f35667b9b23ba001" translate="yes" xml:space="preserve">
          <source>Then, create your app:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3315a12d13dc102c7bd2ac08d709f1294b93ed4c" translate="yes" xml:space="preserve">
          <source>Then, install the &lt;code&gt;@ember/jquery&lt;/code&gt; addon:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5013c7570df139ed1edffbbede967f716ad3f68" translate="yes" xml:space="preserve">
          <source>Then, remove &lt;code&gt;@ember/jquery&lt;/code&gt; from your package.json.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d51c16b01e98b6e11c327ad6160d9601f2a6c39d" translate="yes" xml:space="preserve">
          <source>Then, we can add an &lt;code&gt;{{each}}&lt;/code&gt; helper to the template by passing &lt;code&gt;this.messages&lt;/code&gt; to it. &lt;code&gt;{{each}}&lt;/code&gt; will receive each message as its first block param, and we can use that item in the template block for the loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdee4e1e5030463d5f57f5d6ba9e22f526e1b349" translate="yes" xml:space="preserve">
          <source>Then, we'll update the template to call the &lt;code&gt;double&lt;/code&gt; action. We'll also add &lt;code&gt;this.multiple&lt;/code&gt; to our output to help us confirm that our button is working.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50fb0ecf136b54e6245ad8f68f686d260693ef7c" translate="yes" xml:space="preserve">
          <source>There are 4 major types of elements that can be defined in a class:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="211ba0f801222320dc4443fb5dd9feba96f392ec" translate="yes" xml:space="preserve">
          <source>There are &lt;a href=&quot;https://emberobserver.com/?query=keyboard&quot;&gt;community-made addons&lt;/a&gt; to help manage keyboard events. For example, with &lt;a href=&quot;https://github.com/adopted-ember-addons/ember-keyboard&quot;&gt;ember-keyboard&lt;/a&gt;, you can write,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44f94093f4fe4176292468959f1216768595d0c1" translate="yes" xml:space="preserve">
          <source>There are a few APIs that exist in Ember still that directly expose jQuery, Disabling this optional feature disables those APIs, but does not remove jQuery itself. jQuery is provided by the &lt;code&gt;@ember/jquery&lt;/code&gt; addon, independent of the integration APIs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66b66bd3fbb4e38766f9d224a19b9c58ac71f618" translate="yes" xml:space="preserve">
          <source>There are a few things going on here, but the most important part is &lt;code&gt;@tracked count = 0&lt;/code&gt;. This line creates a dynamic value called &lt;code&gt;count&lt;/code&gt;, which you can stick inside of the template instead of hard coding it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58be2e1d47ed527c420b18412a94a606be46f332" translate="yes" xml:space="preserve">
          <source>There are a few things to look out for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6aaeabca116411bcf4c1a7398dff6575fb20c9cb" translate="yes" xml:space="preserve">
          <source>There are a few things to note about the &lt;code&gt;didInsertElement()&lt;/code&gt; hook:</source>
          <target state="translated">&lt;code&gt;didInsertElement()&lt;/code&gt; 후크에 대해 몇 가지주의 할 사항이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4def01593cdd3ee3dd0b65d4d1374dd6433ec5d2" translate="yes" xml:space="preserve">
          <source>There are a handful of restrictions on the HTML that you can put in an Ember template:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4a72425f5f9b4159f6c94de9e4fbddbb71a0684" translate="yes" xml:space="preserve">
          <source>There are also a number of hooks that you might find useful to define across-the-board rules for your payload. These rules will be useful if your server is consistent, or if you're building an adapter for an infrastructure service, like Firebase, and want to encode service conventions.</source>
          <target state="translated">페이로드에 대한 전체 규칙을 정의하는 데 유용한 여러 가지 후크도 있습니다. 이 규칙은 서버가 일관성이 있거나 Firebase와 같은 인프라 서비스 용 어댑터를 구축하고 서비스 규칙을 인코딩하려는 경우에 유용합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
